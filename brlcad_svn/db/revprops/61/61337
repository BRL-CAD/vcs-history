K 10
svn:author
V 11
indianlarry
K 8
svn:date
V 27
2014-06-17T10:45:55.530474Z
K 7
svn:log
V 1491
The rt_botface_w_normals_[double|float]() function is used as part of rt_bot_prep and is used to check for degenerate BOT faces and to fill in BOT normals. This function checks to make sure the magnitude squared of the of triangle leg deltas (m1 = MAGSQ(trip->tri_BA) &&  m2 = MAGSQ(trip->tri_CA)) are >= tol->dist_sq. It also calculates a cross product using these same leg deltas ( VCROSS(trip->tri_wn, trip->tri_BA, trip->tri_CA) ) to get the triangle normal direction. Also as part of its degenerate face check it calculates the magnitude squared of this normal (m4 = MAGSQ(trip->tri_wn)) and compares it to tol->dist_sq. This causes a problem because when your triangle leg deltas are near tol->dist the magnitude squared of the normal is well below tol->dist_sq. I ran into this problem from an STL conversion where the converter successfully created a BOT with leg deltas near tol->dist but later when raytracing(or calculating bounding box) called this function as part of the Bot prep and tossed out the majority of faces. We still need to check to make sure the triangle isn't degenerate by making sure the triangle legs aren't parallel or coincident. To do this and keep our tolerance checks in bounds I decided to use the dot product of the triangle legs and check that against our parallel tolerance. So now, (m4 = fabs(VDOT(trip->tri_BA, trip->tri_CA))) and check it like (m4 >= tol->para). The raytrace and the bounding box for these sub-millimeter facets looked much better.

END
