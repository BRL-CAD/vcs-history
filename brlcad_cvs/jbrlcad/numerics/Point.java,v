head     1.1;
branch   1.1.1;
access   ;
symbols  start:1.1.1.1 a:1.1.1;
locks    ; strict;
comment  @# @;


1.1
date     2006.09.27.02.23.06;  author butler;  state Exp;
branches 1.1.1.1;
next     ;

1.1.1.1
date     2006.09.27.02.23.06;  author butler;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@/* Generated by Together */


package numerics;
import java.io.Serializable;
import static java.lang.Math.*;

/**
 * Point.
 * <p/>
 * <p/>
 * <b>Source:</b>
 * <p/>
 * <pre>
 *  The U. S. Army Research Laboratory Aberdeen Proving Ground, Maryland 21005 USA
 * </pre>
 * <p/>
 * <p/>
 * <p/>
 * <b>Copyright Notice:</b>
 * <p/>
 * <pre>
 *  This software is Copyright (C) 2004 by the United States Army. All rights reserved.
 * </pre>
 * <p/>
 * <p/>
 * <p/>
 * <b>Responsibilities:</b>
 * <ul><li>Represents a 3D point</li>
 * </ul>
 */

/*
 * $Header: /cvs/brlcadJava/numerics/Point.java,v 1.3 2005/02/10 04:14:26 jra Exp $
 */
	public class Point implements Serializable
{
    double tolerance = 0.00000000001;

		double x;
		double y;
		double z;

    /**
	 * No argument constructor to support JavaBeans
	 */
    public Point()
	{
		x = 0;
		y = 0;
		z = 0;
    }

    /**
	 * Construct a Point from 3 coordinates
	 *
	 * @@param x_in The X coordinate
	 * @@param y_in The Y coordinate
	 * @@param z_in The Z coordinate
	 */
    public Point(double x_in, double y_in, double z_in)
	{
		x = x_in;
		y = y_in;
		z = z_in;
    }

    /**
	 * Copy constructor.
	 * @@param p the point to copy
	 */
    public Point(Point p)
	{
		x = p.x;
		y = p.y;
		z = p.z;
    }

    /**
	 * Produce a String representation of this point in the form "(x, y, z)"
	 */
    public String toString()
	{
		return "(" + x + ", " + y + ", " + z + ")";
    }

    /**
	 * method to measure distance between two points.
	 *
	 * @@param p The other point to measure against.
	 * @@return	double describing the distance.
	 */
    public double dist(Point p)
	{
		return sqrt((x - p.x) * (x - p.x) +
						(y - p.y) * (y - p.y) + (z - p.z) * (z -
															 p.
															 z));
    }

    /**
	 * Set the X coordinate of the Point
	 *
	 * @@param x The value of the X coordinate
	 */
    public void setX(double x)
	{
		this.x = x;
    }

    /**
	 * Set the Y coordinate of the Point
	 *
	 * @@param y The value of the Y coordinate
	 */
    public void setY(double y)
	{
		this.y = y;
    }

    /**
	 * Set the Z coordinate of the Point
	 *
	 * @@param z The value of the Z coordinate
	 */
    public void setZ(double z)
	{
		this.z = z;
    }

    /**
	 * Get the X coordinate of this Point
	 *
	 * @@return The X coordinate of this Point
	 */
    public double getX()
	{
		return (x);
    }

    /**
	 * Get the Y coordinate of this Point
	 *
	 * @@return The Y coordinate of this Point
	 */
    public double getY()
	{
		return (y);
    }

    /**
	 * Get the Z coordinate of this Point
	 *
	 * @@return The Z coordinate of this Point
	 */
    public double getZ()
	{
		return (z);
    }
	
	public double get( int index )
	{
		switch( index )
		{
			case 0:
				return x;
			case 1:
				return y;
			case 2:
				return z;
		}
		
		return 0.0;
	}

    /**
	 * Report the current tolerance (epsilon).
	 *
	 * @@return the tolerance.
	 */
    public double getTolerance()
	{
		return tolerance;
    }

    /**
	 * Update the tolerance.
	 *
	 * @@param t Tolerance to set.
	 */
    public void setTolerance(double t)
	{
		tolerance = abs(t);
    }

    /**
	 * Test if two points are in the same place (within epsilon). The
	 * tolerance aspect applies to half-edge length of a bounding box.
	 *
	 * @@param p Point to compare against
	 * @@return if the points are 'close' enough to call equal.
	 */
    public boolean isEqual(Point p)
	{
		if (abs(p.getX() - x) < tolerance
			&& abs(p.getY() - y) < tolerance
			&& abs(p.getZ() - z) < tolerance)
			return true;
		return false;
    }

    /**
	 * Test if two points are in the same place (within epsilon). The
	 * tolerance aspect applies to half-edge length of a bounding box.
	 *
	 * @@param p1 Point to compare.
	 * @@param p2 Point to compare.
	 * @@return if the points are 'close' enough to call equal.
	 */
    public static boolean isEqual(Point p1, Point p2)
	{
		return p1.isEqual(p2);
    }

    /**
	 * Test equality of points.
	 *
	 * @@param o Object that may or may not be a point.
	 * @@return true if 'o' is a point and the points are in the same place,
	 *         within the tolerance of 'this'.
	 */
    public boolean equals(Object o)
	{
		if (o instanceof Point)
			return isEqual((Point) o);
		return false;
    }

	/**
	 * Method hashCode
	 *
	 * @@return   an int
	 *
	 */
    public int hashCode()
	{

		int result = 11;

		result = 7 * Double.toHexString( this.x ).hashCode();
		result = 7 * Double.toHexString( this.y ).hashCode();
		result = 7 * Double.toHexString( this.z ).hashCode();

		return result;
    }

    /**
	 * Move this point by the amount specified by the supplied
	 * @@param vector
	 */
    public void translate(Vector3 vector)
	{
		x += vector.getX();
		y += vector.getY();
		z += vector.getZ();
    }

	/**
	 * Method scale
	 *
	 * @@param    scaleFactor         a  double
	 *
	 */
	public void scale( double scaleFactor )
	{
		x *= scaleFactor;
		y *= scaleFactor;
		z *= scaleFactor;
	}

	public void join( double dist, Vector3 dir )
	{
		x += dist * dir.getX();
		y += dist * dir.getY();
		z += dist * dir.getZ();
	}
	
	public void plus( Point pt )
	{
		x += pt.getX();
		y += pt.getY();
		z += pt.getZ();
	}
	
	public Vector3 subtract( Point pt )
	{
		return new Vector3( this.x - pt.x, this.y - pt.y, this.z - pt.z );
	}
}
@


1.1.1.1
log
@Original
@
text
@@
