head	1.15;
access;
symbols
	rel-7-10-4:1.14
	STABLE:1.14.0.2
	rel-7-10-2:1.14
	rel-7-10-0:1.14;
locks; strict;
comment	@ * @;


1.15
date	2007.09.14.15.21.00;	author erikgreenwald;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.28.13.21.03;	author d_rossberg;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.27.21.56.47;	author jlowenz;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.23.20.11.54;	author jlowenz;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.15.20.13.16;	author jlowenz;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.09.11.58.57;	author d_rossberg;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.06.16.18.19;	author erikgreenwald;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.04.21.22.49;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.01.17.45.11;	author jlowenz;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.01.16.13.37;	author jlowenz;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.28.19.04.18;	author jlowenz;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.28.18.46.20;	author jlowenz;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.28.17.10.46;	author jlowenz;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.28.16.40.46;	author jlowenz;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.27.19.42.07;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


1.15
log
@removed trailing whitespace
@
text
@#ifndef __VECTOR_X86
#define __VECTOR_X86

#include "common.h"

#ifdef HAVE_EMMINTRIN_H
#  include <emmintrin.h>
#endif

//#define ALIGN16(_m) (double*)((((long)(_m)) + 0x10L) & ~0xFL);
#undef VEC_ALIGN
#define VEC_ALIGN __attribute__((aligned(16)))

typedef double v2df __attribute__((vector_size(16)));

template<int LEN>
struct vec_internal {
  v2df v[LEN/2];
};

// inline dvec4::dvec4(double a, double b, double c, double d)
//     : dvec<4>(
// {
//     double t[4] VEC_ALIGN = {a, b, c, d};

// }

template<int LEN>
inline dvec<LEN>::dvec(double s)
{
  double t[LEN] VEC_ALIGN;
  for (int i = 0; i < LEN/2; i++) {
    t[i*2]   = s;
    t[i*2+1] = s;
    data.v[i] = _mm_load_pd(&t[i*2]);
  }
}

template<int LEN>
inline dvec<LEN>::dvec(const double* vals, bool aligned)
{
  if (aligned) {
    for (int i = 0; i < LEN/2; i++) {
      data.v[i] = _mm_load_pd(&vals[i*2]);
    }
  } else {
    for (int i = 0; i < LEN/2; i++) {
      data.v[i] = _mm_loadu_pd(&vals[i*2]);
    }
  }
}

template<int LEN>
inline dvec<LEN>::dvec(const dvec<LEN>& p)
{
  for (int i = 0; i < LEN/2; i++) {
    data.v[i] = p.data.v[i];
  }
}

template<int LEN>
inline dvec<LEN>::dvec(const vec_internal<LEN>& d)
{
  for (int i = 0; i < LEN/2; i++) data.v[i] = d.v[i];
}

template<int LEN>
inline dvec<LEN>&
dvec<LEN>::operator=(const dvec<LEN>& p)
{
  for (int i = 0; i < LEN/2; i++) {
    data.v[i] = p.data.v[i];
  }
  return *this;
}

template<int LEN>
inline double
dvec<LEN>::operator[](const int index) const
{
  double t[2] __attribute__((aligned(16)));
  _mm_store_pd(t, data.v[index/2]);
  return t[index%2];
}

template<int LEN>
inline void
dvec<LEN>::u_store(double* arr) const
{
  for (int i = 0; i < LEN/2; i++) {
    _mm_storeu_pd(&arr[i*2], data.v[i]);
  }
}

template<int LEN>
inline void
dvec<LEN>::a_store(double* arr) const
{
  for (int i = 0; i < LEN/2; i++) {
    _mm_store_pd(&arr[i*2], data.v[i]);
  }
}

template<int LEN>
inline bool
dvec<LEN>::operator==(const dvec<LEN>& b) const
{
  double ta[LEN] VEC_ALIGN;
  double tb[LEN] VEC_ALIGN;
  a_store(ta);
  b.a_store(tb);
  for (int i = 0; i < LEN; i++)
    if (fabs(ta[i]-tb[i]) > VEQUALITY) return false;
  return true;
}

#define OP_IMPL(__op__) {                         \
  vec_internal<LEN> result;                       \
  for (int i = 0; i < LEN/2; i++) {               \
    result.v[i] = __op__(data.v[i], b.data.v[i]); \
  }                                               \
 return dvec<LEN>(result);                        \
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::operator+(const dvec<LEN>& b)
{
  OP_IMPL(_mm_add_pd)
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::operator-(const dvec<LEN>& b)
{
  OP_IMPL(_mm_sub_pd)
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::operator*(const dvec<LEN>& b)
{
  OP_IMPL(_mm_mul_pd)
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::operator/(const dvec<LEN>& b)
{
  OP_IMPL(_mm_div_pd)
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::madd(const dvec<LEN>& s, const dvec<LEN>& b)
{
  vec_internal<LEN> r;
  for (int i = 0; i < LEN/2; i++) {
    r.v[i] = _mm_mul_pd(data.v[i], s.data.v[i]);
  }
  for (int i = 0; i < LEN/2; i++) {
    r.v[i] = _mm_add_pd(r.v[i], b.data.v[i]);
  }
  return dvec<LEN>(r);
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::madd(const double s, const dvec<LEN>& b)
{
  double _t[LEN] VEC_ALIGN;
  for (int i = 0; i < LEN; i++) _t[i] = s;
  dvec<LEN> t(_t,true);
  return madd(t, b);
}

template<int LEN>
inline double
dvec<LEN>::foldr(double identity, const dvec_op& op, int limit)
{
    double _t[LEN] VEC_ALIGN;
    a_store(_t);
    double val = identity;
    for (int i = limit-1; i >= 0; i--) {
	val = op(_t[i],val);
    }
    return val;
}

template<int LEN>
inline double
dvec<LEN>::foldl(double identity, const dvec_op& op, int limit)
{
    double _t[LEN] VEC_ALIGN;
    a_store(_t);
    double val = identity;
    for (int i = 0; i < limit; i++) {
	val = op(val,_t[i]);
    }
    return val;
}


template<int LEN>
inline dvec<LEN>
dvec<LEN>::map(const dvec_unop& op, int limit)
{
    double _t[LEN] VEC_ALIGN;
    a_store(_t);
    for (int i = 0; i < limit; i++) {
	_t[i] = op(_t[i]);
    }
    return dvec<LEN>(_t);
}


template <int LEN>
inline std::ostream&
operator<<(std::ostream& out, const dvec<LEN>& v)
{
  double _t[LEN] VEC_ALIGN;
  v.a_store(_t);
  out << "<";
  for (int i = 0; i < LEN; i++) {
    out << _t[i];
    if (i != LEN-1)
      out << ",";
  }
  out << ">";
  return out;
}

class vec2d {
public:

  vec2d() {
    _init(0,0);
  }

  vec2d(double x, double y) {
    _init(x,y);
  }

  vec2d(const vec2d& proto)
  {
    _vec = proto._vec;
  }

  vec2d& operator=(const vec2d& b)
  {
    _vec = b._vec;
    return *this;
  }

  double operator[](int index) const {
    double  v[2] __attribute__((aligned(16)));
    _mm_store_pd(v, _vec);
    return v[index];
  }

  void ustore(double* arr) const {
    // assume nothing about the alignment of arr
    double  v[2] __attribute__((aligned(16)));
    _mm_store_pd(v, _vec);
    arr[0] = v[0];
    arr[1] = v[1];
  }

  double x() const { return (*this)[0]; }
  double y() const { return (*this)[1]; }

  vec2d operator+(const vec2d& b) const
  {
    return vec2d(_mm_add_pd(_vec,b._vec));
  }

  vec2d operator-(const vec2d& b) const
  {
    return vec2d(_mm_sub_pd(vec(),b.vec()));
  }

  vec2d operator*(const vec2d& b) const
  {
    return vec2d(_mm_mul_pd(vec(),b.vec()));
  }

  vec2d operator/(const vec2d& b) const
  {
    return vec2d(_mm_div_pd(vec(),b.vec()));
  }

  vec2d madd(const double& scalar, const vec2d& b) const
  {
    return madd(vec2d(scalar,scalar), b);
  }

  vec2d madd(const vec2d& s, const vec2d& b) const
  {
    return vec2d(_mm_add_pd(_mm_mul_pd(vec(),s.vec()),b.vec()));
  }

private:
  //double  v[2] __attribute__((aligned(16)));
  v2df _vec;

  vec2d(const v2df& result)
  {
    _vec = result;
  }

  v2df vec() const { return _vec; }

  void _init(double x, double y)
  {
    double  v[2] __attribute__((aligned(16)));
    v[0] = x;
    v[1] = y;
    _vec = _mm_load_pd(v);
  }

};

inline std::ostream&
operator<<(std::ostream& out, const vec2d& v)
{
  out << "<" << v.x() << "," << v.y() << ">";
  return out;
}

#endif

/*
 * Local Variables:
 * mode: C++
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.14
log
@VC++ 6.0 adaptions:
removed (redundant) struct keywords
removed the unnecessary friend statements (operator<< does not access private class members), they cause trouble only
@
text
@d25 1
a25 1
    
d68 1
a68 1
inline dvec<LEN>& 
d78 1
a78 1
inline double 
d87 1
a87 1
inline void 
d96 1
a96 1
inline void 
d106 1
a106 1
dvec<LEN>::operator==(const dvec<LEN>& b) const 
d112 1
a112 1
  for (int i = 0; i < LEN; i++) 
d124 1
a124 1
   
d126 1
a126 1
inline dvec<LEN> 
d133 1
a133 1
inline dvec<LEN> 
d140 1
a140 1
inline dvec<LEN> 
d147 1
a147 1
inline dvec<LEN> 
d154 1
a154 1
inline dvec<LEN> 
d168 1
a168 1
inline dvec<LEN> 
d170 1
a170 1
{  
d178 1
a178 1
inline double 
d191 1
a191 1
inline double 
d226 1
a226 1
    if (i != LEN-1) 
d235 3
a237 3
  
  vec2d() { 
    _init(0,0); 
d239 1
a239 1
  
d249 1
a249 1
  vec2d& operator=(const vec2d& b) 
d263 1
a263 1
    double  v[2] __attribute__((aligned(16)));    
d276 1
a276 1
  
d281 1
a281 1
  
d286 1
a286 1
  
d305 2
a306 2
  
  vec2d(const v2df& result) 
d310 1
a310 1
   
d312 2
a313 2
 
  void _init(double x, double y) 
d319 1
a319 1
  }    
d322 2
a323 2
  
inline std::ostream& 
@


1.13
log
@fix fold() implementation problem (now left/right versions)
@
text
@d118 1
a118 1
  struct vec_internal<LEN> result;                \
d157 1
a157 1
  struct vec_internal<LEN> r;
a320 1
  friend std::ostream& operator<<(std::ostream& out, const vec2d& v);
@


1.12
log
@add map function and a couple binary operators
@
text
@d179 14
a192 1
dvec<LEN>::fold(double identity, const dvec_op& op, int limit)
d203 1
@


1.11
log
@add support for folding a vector into a single value. make the default constructor assume aligned data.
@
text
@d21 7
d31 1
a31 1
  double t[LEN] __attribute__((aligned(16)));
d190 13
@


1.10
log
@VC++ 6.0 does not like the (redundant) struct keyword in connection with a template
@
text
@d170 13
@


1.9
log
@remove "extra qualifications" that g++4 complains about (still works on g++3)
@
text
@d55 1
a55 1
inline dvec<LEN>::dvec(const struct vec_internal<LEN>& d)
@


1.8
log
@apparently some linux systems don't have emmintrin.h
@
text
@d259 1
a259 1
  vec2d::vec2d(const v2df& result) 
@


1.7
log
@"finish" implementing dvec. added operator for debugging.
@
text
@d4 5
a8 1
#include <emmintrin.h>
@


1.6
log
@more progress on dvec class: constructors, equality and addition.
@
text
@d106 8
d118 1
a118 5
  struct vec_internal<LEN> result;
  for (int i = 0; i < LEN/2; i++) {
    result.v[i] = _mm_add_pd(data.v[i], b.data.v[i]);
  }
  return dvec<LEN>(result);
d125 1
a125 1
  return dvec<LEN>(0.0);
d132 1
a132 1
  return dvec<LEN>(0.0);
d139 1
a139 1
  return dvec<LEN>(0.0);
d146 8
a153 1
  return dvec<LEN>(0.0);
d160 20
a179 1
  return dvec<LEN>(0.0);
a181 1

@


1.5
log
@begin fleshing out arbitrary length vector class. class definition and stub functions.
@
text
@d6 3
a8 1
#define ALIGN16(_m) (double*)((((long)(_m)) + 0x10L) & ~0xFL);
d12 4
d20 6
a25 1
  
d29 1
a29 1
inline dvec<LEN>::dvec(const double* vals)
d31 9
a39 1

d45 4
d50 4
d60 3
d68 1
a68 1
dvec<LEN>::operator[](int index) const
d70 3
a72 1
  return 0.0;
d79 3
a81 1
  return 0.0;
d88 4
d93 11
d110 5
a114 1
  return dvec<LEN>(0.0);
@


1.4
log
@switch to SSE intrinsics (more portable than builtins)
@
text
@d10 90
@


1.3
log
@fix inlining of << operator. should alleviate the problems with multiply-defined symbols seen earlier.
@
text
@d4 2
a9 14
#if !defined(__builtin_ia32_storeapd) 
static inline void __builtin_ia32_storeapd(double* v, v2df vector) 
{
    __builtin_ia32_storeupd(v, vector);
}
#endif

#if !defined(__builtin_ia32_loadapd)
static inline v2df __builtin_ia32_loadapd(double* v)
{
    return __builtin_ia32_loadupd(v);
}
#endif

d23 1
a23 2
    v = ALIGN16(m);
    __builtin_ia32_storeapd(v,proto.vec());
d28 1
a28 1
    __builtin_ia32_storeapd(v, b.vec());
d33 2
d38 10
a47 2
  double x() const { return v[0]; }
  double y() const { return v[1]; }
d51 1
a51 1
    return vec2d(__builtin_ia32_addpd(vec(),b.vec()));
d56 1
a56 1
    return vec2d(__builtin_ia32_subpd(vec(),b.vec()));
d61 1
a61 1
    return vec2d(__builtin_ia32_mulpd(vec(),b.vec()));
d66 1
a66 1
    return vec2d(__builtin_ia32_divpd(vec(),b.vec()));
d76 1
a76 2
    
    return vec2d(__builtin_ia32_addpd(__builtin_ia32_mulpd(vec(),s.vec()),b.vec()));
d80 2
a81 2
  double  m[4];
  double* v;
d83 3
a85 8
    vec2d::vec2d(const v2df& result) 
    {
	v = ALIGN16(m);
	__builtin_ia32_storeapd(v, result);
    }
    
  v2df vec() const {
    return __builtin_ia32_loadapd(v);
d87 3
a89 1

d92 1
a92 1
    v = ALIGN16(m);
d95 1
d97 1
@


1.2
log
@temporarily define replacements for missing(?) builtins
@
text
@d106 1
a106 1
std::ostream& 
@


1.1
log
@Add vector class, with very initial support for simd operations.
@
text
@d2 1
a2 1
#define __VECTOR_x86
d4 3
a6 1
typedef double v2df __attribute__((mode(V2DF)));
d8 13
a20 1
#define ALIGN16(_m) (double*)((((long)(_m)) + 0x10L) & ~0xFL);
d33 1
a33 1
  vec2d(const vec2d& proto) : v(NULL)
d87 6
a92 6
  vec2d(v2df result)
  {
    v = ALIGN16(m);
    __builtin_ia32_storeapd(v, result);
  }

d112 1
a112 1
  
@

