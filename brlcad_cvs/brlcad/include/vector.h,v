head	1.15;
access;
symbols
	rel-7-10-4:1.14
	STABLE:1.14.0.2
	rel-7-10-2:1.14
	rel-7-10-0:1.12;
locks; strict;
comment	@ * @;


1.15
date	2007.09.14.15.21.00;	author erikgreenwald;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.21.20.31.48;	author jlowenz;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.31.21.03.36;	author jlowenz;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.28.13.21.03;	author d_rossberg;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.27.21.56.47;	author jlowenz;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.23.20.11.54;	author jlowenz;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.15.20.13.16;	author jlowenz;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.09.11.58.56;	author d_rossberg;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.09.11.49.38;	author d_rossberg;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.04.21.23.54;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.01.17.45.11;	author jlowenz;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.01.16.13.37;	author jlowenz;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.28.19.04.18;	author jlowenz;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.28.16.06.49;	author jlowenz;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.27.19.42.07;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


1.15
log
@removed trailing whitespace
@
text
@#ifndef __VECTOR
#define __VECTOR

#include "common.h"
#include <math.h>

extern "C++" {
#include <iostream>

  const double VEQUALITY = 0.0000001;

  template<int LEN>
  struct vec_internal;

  template<int LEN>
  class dvec;

  template<int LEN>
  std::ostream& operator<<(std::ostream& out, const dvec<LEN>& v);

  class dvec_unop {
  public:
    virtual double operator()(double a) const = 0;
  };

  class dvec_op {
  public:
    virtual double operator()(double a, double b) const = 0;
  };

  template<int LEN>
  class dvec {
  public:
    dvec(double s);
    dvec(const double* vals, bool aligned=true);
    dvec(const dvec<LEN>& p);

    dvec<LEN>& operator=(const dvec<LEN>& p);
    double operator[](int index) const;
    void u_store(double* arr) const;
    void a_store(double* arr) const;

    bool operator==(const dvec<LEN>& b) const;

    dvec<LEN> operator+(const dvec<LEN>& b);
    dvec<LEN> operator-(const dvec<LEN>& b);
    dvec<LEN> operator*(const dvec<LEN>& b);
    dvec<LEN> operator/(const dvec<LEN>& b);

    dvec<LEN> madd(const dvec<LEN>& s, const dvec<LEN>& b);
    dvec<LEN> madd(const double s, const dvec<LEN>& b);

    dvec<LEN> map(const dvec_unop& operation, int limit = LEN);
    double foldr(double proto, const dvec_op& operation, int limit = LEN);
    double foldl(double proto, const dvec_op& operation, int limit = LEN);

    class mul : public dvec_op {
    public:
      double operator()(double a, double b) const { return a * b; }
    };

    class add : public dvec_op {
    public:
      double operator()(double a, double b) const { return a + b; }
    };

    class sub : public dvec_op {
    public:
      double operator()(double a, double b) const { return a - b; }
    };

    class sqrt : public dvec_unop {
    public:
      double operator()(double a) const { return ::sqrt(a); }
    };
  private:
    vec_internal<LEN> data;

    dvec(const vec_internal<LEN>& d);
  };

  //#define DVEC4(V,t,a,b,c,d) double v#t[4] VEC_ALIGN = {(a),(b),(c),(d)}; V(v#t)

  // use this to create 16-byte aligned memory on platforms that support it
#define VEC_ALIGN

  /*#undef __SSE2__*/ // Test FPU version
#if defined(__SSE2__) && defined(__GNUC__) && defined(HAVE_EMMINTRIN_H)
#define __x86_vector__
#include "vector_x86.h"
#else
#define __fpu_vector__
#include "vector_fpu.h"
#endif

  inline bool vequals(const vec2d& a, const vec2d& b) {
    return
      (fabs(a.x()-b.x()) < VEQUALITY) &&
      (fabs(a.y()-b.y()) < VEQUALITY);
  }

  //--------------------------------------------------------------------------------
  // MATH / VECTOR ops
  // XXX put in VMATH?
  typedef fastf_t pt2d_t[2] VEC_ALIGN;
  typedef fastf_t mat2d_t[4] VEC_ALIGN; // row-major
  inline
  bool mat2d_inverse(mat2d_t inv, mat2d_t m) {
    pt2d_t _a = {m[0],m[1]};
    pt2d_t _b = {m[3],m[2]};
    dvec<2> a(_a);
    dvec<2> b(_b);
    dvec<2> c = a*b;
    fastf_t det = c.foldr(0,dvec<2>::sub());
    if (NEAR_ZERO(det,VUNITIZE_TOL)) return false;
    fastf_t scale = 1.0 / det;
    double tmp[4] VEC_ALIGN = {m[3],-m[1],-m[2],m[0]};
    dvec<4> iv(tmp);
    dvec<4> sv(scale);
    dvec<4> r = iv * sv;
    r.a_store(inv);
    return true;
  }
  inline
  void mat2d_pt2d_mul(pt2d_t r, mat2d_t m, pt2d_t p) {
    pt2d_t _a = {m[0],m[2]};
    pt2d_t _b = {m[1],m[3]};
    dvec<2> x(p[0]);
    dvec<2> y(p[1]);
    dvec<2> a(_a);
    dvec<2> b(_b);
    dvec<2> c = a*x + b*y;
    c.a_store(r);
  }
  inline
  void pt2dsub(pt2d_t r, pt2d_t a, pt2d_t b) {
    dvec<2> va(a);
    dvec<2> vb(b);
    dvec<2> vr = va - vb;
    vr.a_store(r);
  }

  inline
  fastf_t v2mag(pt2d_t p) {
    dvec<2> a(p);
    dvec<2> sq = a*a;
    return sqrt(sq.foldr(0,dvec<2>::add()));
  }
  inline
  void move(pt2d_t a, const pt2d_t b) {
    a[0] = b[0];
    a[1] = b[1];
  }
}

#endif
@


1.14
log
@move now takes a const pointer to the pt
@
text
@d9 1
a9 1
  
d14 1
a14 1
  
d27 1
a27 1
  public:   
d30 1
a30 1
  
d37 1
a37 1
    
d42 1
a42 1
    
d49 1
a49 1
    
d58 1
a58 1
    public: 
d80 1
a80 1
  };  
d83 1
a83 1
  
d95 1
a95 1
  
d97 1
a97 1
    return 
d106 1
a106 1
  typedef fastf_t mat2d_t[4] VEC_ALIGN; // row-major 
d124 1
a124 1
  inline 
d142 1
a142 1
  
d153 1
a153 1
  }    
@


1.13
log
@Move vector point/matrix functionality here from g_brep.cpp
@
text
@d150 1
a150 1
  void move(pt2d_t a, pt2d_t b) {
@


1.12
log
@VC++ 6.0 adaptions:
removed (redundant) struct keywords
removed the unnecessary friend statements (operator<< does not access private class members), they cause trouble only
@
text
@d101 53
@


1.11
log
@fix fold() implementation problem (now left/right versions)
@
text
@a56 2
    friend std::ostream& operator<< <LEN>(std::ostream& out, const dvec<LEN>& v);   

d74 1
a74 1
      double operator()(double a) const { return sqrt(a); }
d77 1
a77 1
    struct vec_internal<LEN> data;
@


1.10
log
@add map function and a couple binary operators
@
text
@d54 2
a55 1
    double fold(double proto, const dvec_op& operation, int limit = LEN);
@


1.9
log
@add support for folding a vector into a single value. make the default constructor assume aligned data.
@
text
@d5 1
d21 5
d53 1
d62 15
d83 2
@


1.8
log
@VC++ 6.0 does not like the (redundant) struct keyword in connection with a template
@
text
@d20 5
d29 1
a29 1
    dvec(const double* vals, bool aligned=false);
d47 8
a54 1
    friend std::ostream& operator<<(std::ostream& out, const dvec<LEN>& v);
d59 1
a59 1
  };
@


1.7
log
@the spezialization is friend, not the template
@
text
@d46 1
a46 1
    dvec(const struct vec_internal<LEN>& d);
@


1.6
log
@common.h comes before all system headers.  wasn't able to find an alternative (though I didn't look really hard) for emmintrin.h, so if the header doesn't exist don't do the x86 vector foo.
@
text
@d42 1
a42 1
    friend std::ostream& operator<< <>(std::ostream& out, const dvec<LEN>& v);
@


1.5
log
@"finish" implementing dvec. added operator for debugging.
@
text
@d4 2
d53 1
a53 1
#if defined(__SSE2__) && defined(__GNUC__)
@


1.4
log
@more progress on dvec class: constructors, equality and addition.
@
text
@d13 6
d40 1
d50 1
a50 1
  //#undef __SSE2__
@


1.3
log
@begin fleshing out arbitrary length vector class. class definition and stub functions.
@
text
@d10 3
d16 1
a16 1
    dvec(const double* vals);
d24 2
d33 5
d40 2
d43 1
@


1.2
log
@Wrap vector in extern c++, fix multiply-defined symbol errors on vequals function
@
text
@d9 22
@


1.1
log
@Add vector class, with very initial support for simd operations.
@
text
@d4 1
d6 2
a7 2

const double VEQUALITY = 0.0000001;
d16 6
a21 5

bool vequals(const vec2d& a, const vec2d& b) {
  return 
    (fabs(a.x()-b.x()) < VEQUALITY) &&
    (fabs(a.y()-b.y()) < VEQUALITY);
@

