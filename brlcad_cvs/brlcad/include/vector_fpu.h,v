head	1.11;
access;
symbols
	rel-7-10-4:1.10
	STABLE:1.10.0.2
	rel-7-10-2:1.10
	rel-7-10-0:1.10;
locks; strict;
comment	@ * @;


1.11
date	2007.09.14.15.21.00;	author erikgreenwald;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.28.13.21.03;	author d_rossberg;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.27.21.56.47;	author jlowenz;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.23.20.11.54;	author jlowenz;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.15.20.13.16;	author jlowenz;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.09.11.58.57;	author d_rossberg;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.01.17.45.11;	author jlowenz;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.01.16.13.37;	author jlowenz;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.28.19.04.18;	author jlowenz;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.28.17.10.46;	author jlowenz;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.27.19.42.07;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


1.11
log
@removed trailing whitespace
@
text
@#ifndef __VECTOR_FPU
#define __VECTOR_FPU

#ifdef __GNUC__
#undef VEC_ALIGN
#define VEC_ALIGN __attribute__((aligned(16)))
#endif

template<int LEN>
struct vec_internal {
  double v[LEN] VEC_ALIGN;
};

template<int LEN>
inline dvec<LEN>::dvec(double s)
{
  for (int i = 0; i < LEN; i++)
    data.v[i] = s;
}

template<int LEN>
inline dvec<LEN>::dvec(const double* vals, bool aligned)
{
  for (int i = 0; i < LEN; i++)
    data.v[i] = vals[i];
}

template<int LEN>
inline dvec<LEN>::dvec(const dvec<LEN>& p)
{
  for (int i = 0; i < LEN; i++)
    data.v[i] = p.data.v[i];
}

template<int LEN>
inline dvec<LEN>::dvec(const vec_internal<LEN>& d)
{
  for (int i = 0; i < LEN; i++)
    data.v[i] = d.v[i];
}

template<int LEN>
inline dvec<LEN>&
dvec<LEN>::operator=(const dvec<LEN>& p)
{
  for (int i = 0; i < LEN; i++)
    data.v[i] = p.data.v[i];
  return *this;
}

template<int LEN>
inline double
dvec<LEN>::operator[](int index) const
{
  return data.v[index];
}

template<int LEN>
inline void
dvec<LEN>::u_store(double* arr) const
{
  a_store(arr);
}

template<int LEN>
inline void
dvec<LEN>::a_store(double* arr) const
{
  for (int i = 0; i < LEN; i++)
    arr[i] = data.v[i];
}

template<int LEN>
inline bool
dvec<LEN>::operator==(const dvec<LEN>& b) const
{
  for (int i = 0; i < LEN; i++)
    if (fabs(data.v[i]-b.data.v[i]) > VEQUALITY) return false;
  return true;
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::operator+(const dvec<LEN>& b)
{
  vec_internal<LEN> r;
  for (int i = 0; i < LEN; i++)
    r.v[i] = data.v[i] + b.data.v[i];
  return dvec<LEN>(r);
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::operator-(const dvec<LEN>& b)
{
  vec_internal<LEN> r;
  for (int i = 0; i < LEN; i++)
    r.v[i] = data.v[i] - b.data.v[i];
  return dvec<LEN>(r);
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::operator*(const dvec<LEN>& b)
{
  vec_internal<LEN> r;
  for (int i = 0; i < LEN; i++)
    r.v[i] = data.v[i] * b.data.v[i];
  return dvec<LEN>(r);
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::operator/(const dvec<LEN>& b)
{
  vec_internal<LEN> r;
  for (int i = 0; i < LEN; i++)
    r.v[i] = data.v[i] / b.data.v[i];
  return dvec<LEN>(r);
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::madd(const dvec<LEN>& s, const dvec<LEN>& b)
{
  vec_internal<LEN> r;
  for (int i = 0; i < LEN; i++)
    r.v[i] = data.v[i] * s.data.v[i] + b.data.v[i];
  return dvec<LEN>(r);
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::madd(const double s, const dvec<LEN>& b)
{
  vec_internal<LEN> r;
  for (int i = 0; i < LEN; i++)
    r.v[i] = data.v[i] * s +  b.data.v[i];
  return dvec<LEN>(r);
}

template<int LEN>
inline double
dvec<LEN>::foldr(double identity, const dvec_op& op, int limit)
{
    double val = identity;
    for (int i = limit-1; i >= 0; i--) {
	val = op(data.v[i],val);
    }
    return val;
}
template<int LEN>
inline double
dvec<LEN>::foldl(double identity, const dvec_op& op, int limit)
{
    double val = identity;
    for (int i = 0; i < limit; i++) {
	val = op(val,data.v[i]);
    }
    return val;
}

template<int LEN>
inline dvec<LEN>
dvec<LEN>::map(const dvec_unop& op, int limit)
{
    vec_internal<LEN> r;
    for (int i = 0; i < limit; i++) {
	r.v[i] = op(data.v[i]);
    }
    return dvec<LEN>(r);
}


template <int LEN>
inline std::ostream&
operator<<(std::ostream& out, const dvec<LEN>& v)
{
  out << "<";
  for (int i = 0; i < LEN; i++) {
    out << v.data.v[i];
    if (i != LEN-1)
      out << ",";
  }
  out << ">";
  return out;
}

class vec2d {
public:

  vec2d() {
    _init(0,0);
  }

  vec2d(double x, double y) {
    _init(x,y);
  }

  vec2d(const vec2d& proto)
  {
    _init(proto.v[0],proto.v[1]);
  }

  vec2d& operator=(const vec2d& b)
  {
    v[0] = b.v[0];
    v[1] = b.v[1];
    return *this;
  }

  double operator[](int index) const { return v[index]; }

  double x() const { return v[0]; }
  double y() const { return v[1]; }

  vec2d operator+(const vec2d& b) const
  {
    return vec2d(v[0] + b.v[0], v[1] + b.v[1]);
  }

  vec2d operator-(const vec2d& b) const
  {
    return vec2d(v[0] - b.v[0], v[1] - b.v[1]);
  }

  vec2d operator*(const vec2d& b) const
  {
    return vec2d(v[0] * b.v[0], v[1] * b.v[1]);
  }

  vec2d operator/(const vec2d& b) const
  {
    return vec2d(v[0] / b.v[0], v[1] / b.v[1]);
  }

  vec2d madd(const double& scalar, const vec2d& b) const
  {
    return vec2d(v[0]*scalar+b.v[0],v[1]*scalar+b.v[1]);
  }

  vec2d madd(const vec2d& s, const vec2d& b) const
  {
    return vec2d(v[0]*s.v[0]+b.v[0],v[1]*s.v[1]+b.v[1]);
  }

private:
  double* v;
  double  m[4];

  void _init(double x, double y) {
    // align to 16-byte boundary
    v = (double*)((((long)m) + 0x10L) & ~0xFL);
    v[0] = x;
    v[1] = y;
  }
};

inline std::ostream&
operator<<(std::ostream& out, const vec2d& v)
{
  out << "<" << v.x() << "," << v.y() << ">";
  return out;
}

#endif

/*
 * Local Variables:
 * mode: C++
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.10
log
@VC++ 6.0 adaptions:
removed (redundant) struct keywords
removed the unnecessary friend statements (operator<< does not access private class members), they cause trouble only
@
text
@d17 1
a17 1
  for (int i = 0; i < LEN; i++) 
d24 1
a24 1
  for (int i = 0; i < LEN; i++) 
d31 1
a31 1
  for (int i = 0; i < LEN; i++) 
d38 1
a38 1
  for (int i = 0; i < LEN; i++) 
d43 1
a43 1
inline dvec<LEN>& 
d46 1
a46 1
  for (int i = 0; i < LEN; i++) 
d52 1
a52 1
inline double 
d59 1
a59 1
inline void 
d66 1
a66 1
inline void 
d69 1
a69 1
  for (int i = 0; i < LEN; i++) 
d74 1
a74 1
inline bool 
d83 1
a83 1
inline dvec<LEN> 
d87 1
a87 1
  for (int i = 0; i < LEN; i++) 
d93 1
a93 1
inline dvec<LEN> 
d97 1
a97 1
  for (int i = 0; i < LEN; i++) 
d103 1
a103 1
inline dvec<LEN> 
d107 1
a107 1
  for (int i = 0; i < LEN; i++) 
d113 1
a113 1
inline dvec<LEN> 
d117 1
a117 1
  for (int i = 0; i < LEN; i++) 
d123 1
a123 1
inline dvec<LEN> 
d127 1
a127 1
  for (int i = 0; i < LEN; i++) 
d133 1
a133 1
inline dvec<LEN> 
d135 1
a135 1
{  
d137 1
a137 1
  for (int i = 0; i < LEN; i++) 
d143 1
a143 1
inline double 
d153 1
a153 1
inline double 
d182 1
a182 1
    if (i != LEN-1) 
d191 3
a193 3
    
  vec2d() { 
    _init(0,0); 
d195 1
a195 1
  
d205 1
a205 1
  vec2d& operator=(const vec2d& b) 
d221 1
a221 1
  
d226 1
a226 1
  
d231 1
a231 1
  
d256 1
a256 1
  }    
d259 1
a259 1
inline std::ostream& 
@


1.9
log
@fix fold() implementation problem (now left/right versions)
@
text
@d86 1
a86 1
  struct vec_internal<LEN> r;
d96 1
a96 1
  struct vec_internal<LEN> r;
d106 1
a106 1
  struct vec_internal<LEN> r;
d116 1
a116 1
  struct vec_internal<LEN> r;
d126 1
a126 1
  struct vec_internal<LEN> r;
d136 1
a136 1
  struct vec_internal<LEN> r;
d167 1
a167 1
    struct vec_internal<LEN> r;
a256 1
  friend std::ostream& operator<<(std::ostream& out, const vec2d& v);
@


1.8
log
@add map function and a couple binary operators
@
text
@d144 11
a154 1
dvec<LEN>::fold(double identity, const dvec_op& op, int limit)
@


1.7
log
@add support for folding a vector into a single value. make the default constructor assume aligned data.
@
text
@d153 10
@


1.6
log
@VC++ 6.0 does not like the (redundant) struct keyword in connection with a template
@
text
@d142 13
@


1.5
log
@"finish" implementing dvec. added operator for debugging.
@
text
@d36 1
a36 1
inline dvec<LEN>::dvec(const struct vec_internal<LEN>& d)
@


1.4
log
@more progress on dvec class: constructors, equality and addition.
@
text
@d96 4
a99 1
  return dvec<LEN>(0.0);
d106 4
a109 1
  return dvec<LEN>(0.0);
d116 4
a119 1
  return dvec<LEN>(0.0);
d126 4
a129 1
  return dvec<LEN>(0.0);
d136 18
a153 1
  return dvec<LEN>(0.0);
@


1.3
log
@begin fleshing out arbitrary length vector class. class definition and stub functions.
@
text
@d4 10
d17 2
a18 1
  
d22 1
a22 1
inline dvec<LEN>::dvec(const double* vals)
d24 2
a25 1

d31 3
d35 5
d46 2
d55 1
a55 1
  return 0.0;
d62 1
a62 1
  return 0.0;
d69 3
d73 7
d86 4
a89 1
  return dvec<LEN>(0.0);
@


1.2
log
@fix inlining of << operator. should alleviate the problems with multiply-defined symbols seen earlier.
@
text
@d4 88
@


1.1
log
@Add vector class, with very initial support for simd operations.
@
text
@d75 1
a75 1
std::ostream& 
@

