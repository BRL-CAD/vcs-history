head	14.24;
access;
symbols
	rel-7-10-4:14.21
	STABLE:14.21.0.2
	stable-branch:14.4
	rel-7-10-2:14.21
	rel-7-10-0:14.14
	rel-7-8-4:14.10
	rel-7-8-2:14.7
	rel-7-8-0:14.7
	trimnurbs-branch:14.7.0.2
	help:14.7
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.6
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.2
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.24
date	2007.12.31.17.34.41;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.12.16.15.34.29;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.10.22.08.43.48;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.07.26.01.13.50;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.05.26.02.08.01;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.05.26.01.45.04;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.19.00.50.03;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.18.04.13.43;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.05.14.16.53.54;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.05.14.16.39.14;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.01.40;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.20;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.21.04.45.40;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.40;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.09.18.05.24.07;	author lbutler;	state Exp;
branches;
next	14.9;

14.9
date	2006.08.31.04.41.19;	author lbutler;	state Exp;
branches;
next	14.8;

14.8
date	2006.07.09.20.51.40;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.10;	author brlcad;	state Exp;
branches
	14.7.2.1;
next	14.6;

14.6
date	2005.10.23.04.44.26;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.09.19.17.38.51;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.30.10;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.21.06.23.18;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.06.38;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.10;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.08.23.24.20;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.24.04.10.50;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.10;	author brlcad;	state Exp;
branches;
next	;

14.7.2.1
date	2006.03.13.15.18.49;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.24
log
@c89 is assumed, remove the \!__STDC__ protections/sections
@
text
@/*                           N M G . H
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup nmg */
/** @@{ */
/** @@file nmg.h
 *
 *
 *  @@author	Lee A. Butler
 *  @@author	Michael John Muuss
 *
 * @@brief
 *  Definition of data structures for "Non-Manifold Geometry Modelling."
 *  Developed from "Non-Manifold Geometric Boundary Modeling" by
 *  Kevin Weiler, 5/7/87 (SIGGraph 1989 Course #20 Notes)
 *
 *  Include Sequencing -
 *	#  include <stdio.h>
 *	# include <math.h>
 *	# include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	# include "vmath.h"	/_* For vect_t definition *_/
 *	# include "nmg.h"
 *	# include "raytrace.h"
 *	# include "nurb.h"	/_* OPTIONAL, follows raytrace.h when used *_/
 *
 *  @@par Libraries Used -
 *	LIBRT LIBRT_LIBES -lm -lc
 */

#ifndef __NMG_H__
#define __NMG_H__

#include "common.h"

/* interface headers */
#include "machine.h"
#include "vmath.h"
#include "bu.h"

#ifndef NULL
#  define NULL 0
#endif

#define	NMG_EXTERN(type_and_name,args)	RT_EXTERN(type_and_name,args)


#define DEBUG_PL_ANIM	0x00000001	/**< @@brief 1 mged: animated evaluation */
#define DEBUG_PL_SLOW	0x00000002	/**< @@brief 2 mged: add delays to animation */
#define DEBUG_GRAPHCL	0x00000004	/**< @@brief 3 mged: graphic classification */
#define DEBUG_PL_LOOP	0x00000008	/**< @@brief 4 loop class (needs GRAPHCL) */
#define DEBUG_PLOTEM	0x00000010	/**< @@brief 5 make plots in debugged routines (needs other flags set too) */
#define DEBUG_POLYSECT	0x00000020	/**< @@brief 6 nmg_inter: face intersection */
#define DEBUG_VERIFY	0x00000040	/**< @@brief 7 nmg_vshell() frequently, verify health */
#define DEBUG_BOOL	0x00000080	/**< @@brief 8 nmg_bool:  */
#define DEBUG_CLASSIFY	0x00000100	/**< @@brief 9 nmg_class: */
#define DEBUG_BOOLEVAL	0x00000200	/**< @@brief 10 nmg_eval: what to retain */
#define DEBUG_BASIC	0x00000400	/**< @@brief 013 nmg_mk.c and nmg_mod.c routines */
#define DEBUG_MESH	0x00000800	/**< @@brief 12 nmg_mesh: describe edge search */
#define DEBUG_MESH_EU	0x00001000	/**< @@brief 13 nmg_mesh: list edges meshed */
#define DEBUG_POLYTO	0x00002000	/**< @@brief 14 nmg_misc: polytonmg */
#define DEBUG_LABEL_PTS 0x00004000	/**< @@brief 15 label points in plot files */
/***#define DEBUG_INS	0x00008000	/_* 16 bu_ptbl table insert */
#define DEBUG_NMGRT	0x00010000	/**< @@brief 17 ray tracing */
#define DEBUG_FINDEU	0x00020000	/**< @@brief 18 nmg_mod: nmg_findeu() */
#define DEBUG_CMFACE	0x00040000	/**< @@brief 19 nmg_mod: nmg_cmface() */
#define DEBUG_CUTLOOP	0x00080000	/**< @@brief 024 nmg_mod: nmg_cut_loop */
#define DEBUG_VU_SORT	0x00100000	/**< @@brief 025 nmg_fcut: coincident vu sort */
#define DEBUG_FCUT	0x00200000	/**< @@brief 026 nmg_fcut: face cutter */
#define DEBUG_RT_SEGS	0x00400000	/**< @@brief 027 nmg_rt_segs: */
#define DEBUG_RT_ISECT	0x00800000	/**< @@brief 028 nmg_rt_isect: */
#define DEBUG_TRI	0x01000000	/**< @@brief 029 nmg_tri */
#define DEBUG_PT_FU	0x02000000	/**< @@brief 029 nmg_pt_fu */
#define DEBUG_MANIF	0x04000000	/**< @@brief 029 nmg_manif */
#define NMG_DEBUG_FORMAT \
"\020\033MANIF\032PTFU\031TRIANG\030RT_ISECT\
\027RT_SEGS\026FCUT\025VU_SORT\024CUTLOOP\023CMFACE\022FINDEU\021RT_ISECT\020(FREE)\
\017LABEL_PTS\016POLYTO\015MESH_EU\014MESH\013BASIC\012BOOLEVAL\011CLASSIFY\
\010BOOL\7VERIFY\6POLYSECT\5PLOTEM\4PL_LOOP\3GRAPHCL\2PL_SLOW\1PL_ANIM"

/*
 *  Macros for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 */
#if __STDC__ || USE_PROTOTYPES
#	define	NMG_ARGS(args)			args
#else
#	define	NMG_ARGS(args)			()
#endif

/* Boolean operations */
#define NMG_BOOL_SUB 1		/**< @@brief subtraction */
#define NMG_BOOL_ADD 2		/**< @@brief addition/union */
#define NMG_BOOL_ISECT 4	/**< @@brief intsersection */

/* Boolean classifications */
#define NMG_CLASS_Unknown	-1
#define NMG_CLASS_AinB		0
#define NMG_CLASS_AonBshared	1
#define NMG_CLASS_AonBanti	2
#define NMG_CLASS_AoutB		3
#define NMG_CLASS_BinA		4
#define NMG_CLASS_BonAshared	5
#define NMG_CLASS_BonAanti	6
#define NMG_CLASS_BoutA		7

/* orientations available.  All topological elements are orientable. */
#define OT_NONE     0    /**< @@brief no orientation (error) */
#define OT_SAME     1    /**< @@brief orientation same */
#define OT_OPPOSITE 2    /**< @@brief orientation opposite */
#define OT_UNSPEC   3    /**< @@brief orientation unspecified */
#define OT_BOOLPLACE 4   /**< @@brief object is intermediate data for boolean ops */

/*
 *  Magic Numbers.
 */
#define NMG_MODEL_MAGIC 	0x12121212
#define NMG_REGION_MAGIC	0x23232323
#define NMG_REGION_A_MAGIC	0x696e6720
#define NMG_SHELL_MAGIC 	0x71077345	/**< @@brief shell oil */
#define NMG_SHELL_A_MAGIC	0x65207761
#define NMG_FACE_MAGIC		0x45454545
#define NMG_FACE_G_PLANE_MAGIC	0x726b6e65
#define NMG_FACE_G_SNURB_MAGIC	0x736e7262	/**< @@brief was RT_SNURB_MAGIC */
#define NMG_FACEUSE_MAGIC	0x56565656
#define NMG_LOOP_MAGIC		0x67676767
#define NMG_LOOP_G_MAGIC	0x6420224c
#define NMG_LOOPUSE_MAGIC	0x78787878
#define NMG_EDGE_MAGIC		0x33333333
#define NMG_EDGE_G_LSEG_MAGIC	0x6c696768
#define NMG_EDGE_G_CNURB_MAGIC	0x636e7262	/**< @@brief was RT_CNURB_MAGIC */
#define NMG_EDGEUSE_MAGIC	0x90909090
#define NMG_EDGEUSE2_MAGIC	0x91919191	/**< @@brief used in eu->l2.magic */
#define NMG_VERTEX_MAGIC	0x00123123
#define NMG_VERTEX_G_MAGIC	0x72737707
#define NMG_VERTEXUSE_MAGIC	0x12341234
#define NMG_VERTEXUSE_A_PLANE_MAGIC	0x69676874
#define NMG_VERTEXUSE_A_CNURB_MAGIC	0x20416e64
#define NMG_KNOT_VECTOR_MAGIC	0x6b6e6f74	/**< @@brief aka RT_KNOT_VECTOR_MAGIC */

/**
 * macros to check/validate a structure pointer
 */
#define NMG_CKMAG(_ptr, _magic, _str)	BU_CKMAG(_ptr,_magic,_str)
#define NMG_CK2MAG(_ptr, _magic1, _magic2, _str)	\
	if( !(_ptr) || (*((long *)(_ptr)) != (_magic1) && *((long *)(_ptr)) != (_magic2) ) )  { \
		bu_badmagic( (long *)(_ptr), _magic1, _str, __FILE__, __LINE__ ); \
	}

#define NMG_CK_MODEL(_p)	NMG_CKMAG(_p, NMG_MODEL_MAGIC, "model")
#define NMG_CK_REGION(_p)	NMG_CKMAG(_p, NMG_REGION_MAGIC, "region")
#define NMG_CK_REGION_A(_p)	NMG_CKMAG(_p, NMG_REGION_A_MAGIC, "region_a")
#define NMG_CK_SHELL(_p)	NMG_CKMAG(_p, NMG_SHELL_MAGIC, "shell")
#define NMG_CK_SHELL_A(_p)	NMG_CKMAG(_p, NMG_SHELL_A_MAGIC, "shell_a")
#define NMG_CK_FACE(_p)		NMG_CKMAG(_p, NMG_FACE_MAGIC, "face")
#define NMG_CK_FACE_G_PLANE(_p)	NMG_CKMAG(_p, NMG_FACE_G_PLANE_MAGIC, "face_g_plane")
#define NMG_CK_FACE_G_SNURB(_p)	NMG_CKMAG(_p, NMG_FACE_G_SNURB_MAGIC, "face_g_snurb")
#define NMG_CK_FACE_G_EITHER(_p)	NMG_CK2MAG(_p, NMG_FACE_G_PLANE_MAGIC, NMG_FACE_G_SNURB_MAGIC, "face_g_plane|face_g_snurb")
#define NMG_CK_FACEUSE(_p)	NMG_CKMAG(_p, NMG_FACEUSE_MAGIC, "faceuse")
#define NMG_CK_LOOP(_p)		NMG_CKMAG(_p, NMG_LOOP_MAGIC, "loop")
#define NMG_CK_LOOP_G(_p)	NMG_CKMAG(_p, NMG_LOOP_G_MAGIC, "loop_g")
#define NMG_CK_LOOPUSE(_p)	NMG_CKMAG(_p, NMG_LOOPUSE_MAGIC, "loopuse")
#define NMG_CK_EDGE(_p)		NMG_CKMAG(_p, NMG_EDGE_MAGIC, "edge")
#define NMG_CK_EDGE_G_LSEG(_p)	NMG_CKMAG(_p, NMG_EDGE_G_LSEG_MAGIC, "edge_g_lseg")
#define NMG_CK_EDGE_G_CNURB(_p)	NMG_CKMAG(_p, NMG_EDGE_G_CNURB_MAGIC, "edge_g_cnurb")
#define NMG_CK_EDGE_G_EITHER(_p)	NMG_CK2MAG(_p, NMG_EDGE_G_LSEG_MAGIC, NMG_EDGE_G_CNURB_MAGIC, "edge_g_lseg|edge_g_cnurb")
#define NMG_CK_EDGEUSE(_p)	NMG_CKMAG(_p, NMG_EDGEUSE_MAGIC, "edgeuse")
#define NMG_CK_VERTEX(_p)	NMG_CKMAG(_p, NMG_VERTEX_MAGIC, "vertex")
#define NMG_CK_VERTEX_G(_p)	NMG_CKMAG(_p, NMG_VERTEX_G_MAGIC, "vertex_g")
#define NMG_CK_VERTEXUSE(_p)	NMG_CKMAG(_p, NMG_VERTEXUSE_MAGIC, "vertexuse")
#define NMG_CK_VERTEXUSE_A_PLANE(_p)	NMG_CKMAG(_p, NMG_VERTEXUSE_A_PLANE_MAGIC, "vertexuse_a_plane")
#define NMG_CK_VERTEXUSE_A_CNURB(_p)	NMG_CKMAG(_p, NMG_VERTEXUSE_A_CNURB_MAGIC, "vertexuse_a_cnurb")
#define NMG_CK_VERTEXUSE_A_EITHER(_p)	NMG_CK2MAG(_p, NMG_VERTEXUSE_A_PLANE_MAGIC, NMG_VERTEXUSE_A_CNURB_MAGIC, "vertexuse_a_plane|vertexuse_a_cnurb")
#define NMG_CK_LIST(_p)		BU_CKMAG(_p, BU_LIST_HEAD_MAGIC, "bu_list")

/* Used only in nmg_mod.c */
#define NMG_TEST_EDGEUSE(_p) \
	if (!(_p)->l.forw || !(_p)->l.back || !(_p)->eumate_p || \
	    !(_p)->radial_p || !(_p)->e_p || !(_p)->vu_p || \
	    !(_p)->up.magic_p ) { \
		bu_log("in %s at %d, Bad edgeuse member pointer\n",\
			 __FILE__, __LINE__);  nmg_pr_eu(_p, (char *)NULL); \
		bu_bomb("NULL pointer\n"); \
	} else if ((_p)->vu_p->up.eu_p != (_p) || \
		(_p)->eumate_p->vu_p->up.eu_p != (_p)->eumate_p) {\
		bu_log("in %s at %d, edgeuse lost vertexuse\n",\
			 __FILE__, __LINE__); \
		bu_bomb("bye"); \
	}

/**
 *			K N O T _ V E C T O R
 * @@brief
 *  Definition of a knot vector.
 *
 *  Not found independently, but used in the cnurb and snurb structures.
 *  (Exactly the same as the definition in nurb.h)
 */
struct knot_vector {
	int		magic;
	int		k_size;		/**< @@brief knot vector size */
	fastf_t		* knots;	/**< @@brief pointer to knot vector  */
};
#define RT_KNOT_VECTOR_MAGIC	NMG_KNOT_VECTOR_MAGIC	/**< @@brief nurb.h compat */

/*
 *	N O T I C E !
 *
 *	We rely on the fact that the first long in a struct is the magic
 *	number (which is used to identify the struct type).
 *	This may be either a long, or an rt_list structure, which
 *	starts with a magic number.
 *
 *	To these ends, there is a standard ordering for fields in "object-use"
 *	structures.  That ordering is:
 *		1) magic number, or rt_list structure
 *		2) pointer to parent
 *		5) pointer to mate
 *		6) pointer to geometry
 *		7) pointer to attributes
 *		8) pointer to child(ren)
 */


/**
 *			M O D E L
 */
struct model {
	long			magic;
	struct bu_list		r_hd;	/**< @@brief list of regions */
	long			index;	/**< @@brief struct # in this model */
	long			maxindex; /**< @@brief # of structs so far */
};

/**
 *			R E G I O N
 */
struct nmgregion {
	struct bu_list		l;	/**< @@brief regions, in model's r_hd list */
	struct model   		*m_p;	/**< @@brief owning model */
	struct nmgregion_a	*ra_p;	/**< @@brief attributes */
	struct bu_list		s_hd;	/**< @@brief list of shells in region */
	long			index;	/**< @@brief struct # in this model */
};

struct nmgregion_a {
	long			magic;
	point_t			min_pt;	/**< @@brief minimums of bounding box */
	point_t			max_pt;	/**< @@brief maximums of bounding box */
	long			index;	/**< @@brief struct # in this model */
};

/**
 *			S H E L L
 *
 *  When a shell encloses volume, it's done entirely by the list of faceuses.
 *
 *  The wire loopuses (each of which heads a list of edges) define a
 *  set of connected line segments which form a closed path, but do not
 *  enclose either volume or surface area.
 *
 *  The wire edgeuses are disconnected line segments.
 *  There is a special interpetation to the eu_hd list of wire edgeuses.
 *  Unlike edgeuses seen in loops, the eu_hd list contains eu1, eu1mate,
 *  eu2, eu2mate, ..., where each edgeuse and it's mate comprise a
 *  *non-connected* "wire" edge which starts at eu1->vu_p->v_p and ends
 *  at eu1mate->vu_p->v_p.  There is no relationship between the pairs
 *  of edgeuses at all, other than that they all live on the same linked
 *  list.
 */
struct shell {
	struct bu_list		l;	/**< @@brief shells, in region's s_hd list */
	struct nmgregion	*r_p;	/**< @@brief owning region */
	struct shell_a		*sa_p;	/**< @@brief attribs */

	struct bu_list		fu_hd;	/**< @@brief list of face uses in shell */
	struct bu_list		lu_hd;	/**< @@brief wire loopuses (edge groups) */
	struct bu_list		eu_hd;	/**< @@brief wire list (shell has wires) */
	struct vertexuse	*vu_p;	/**< @@brief internal ptr to single vertexuse */
	long			index;	/**< @@brief struct # in this model */
};

struct shell_a {
	long			magic;
	point_t			min_pt;	/**< @@brief minimums of bounding box */
	point_t			max_pt;	/**< @@brief maximums of bounding box */
	long			index;	/**< @@brief struct # in this model */
};

/**
 *			F A C E
 *
 *  Note: there will always be exactly two faceuse's using a face.
 *  To find them, go up fu_p for one, then across fumate_p to other.
 */
struct face {
	struct bu_list		l;	/**< @@brief faces in face_g's f_hd list */
	struct faceuse		*fu_p;	/**< @@brief Ptr up to one use of this face */
	union {
		long		    *magic_p;
		struct face_g_plane *plane_p;
		struct face_g_snurb *snurb_p;
	} g;				/**< @@brief geometry */
	int			flip;	/**< @@brief !0 ==> flip normal of fg */
	/* These might be better stored in a face_a (not faceuse_a!) */
	/* These are not stored on disk */
	point_t			min_pt;	/**< @@brief minimums of bounding box */
	point_t			max_pt;	/**< @@brief maximums of bounding box */
	long			index;	/**< @@brief struct # in this model */
};

struct face_g_plane {
	long			magic;
	struct bu_list		f_hd;	/**< @@brief list of faces sharing this surface */
	plane_t			N;	/**< @@brief Plane equation (incl normal) */
	long			index;	/**< @@brief struct # in this model */
};

struct face_g_snurb {
	/* NOTICE:  l.forw & l.back *not* stored in database.  For LIBNURB internal use only. */
	struct bu_list		l;
	struct bu_list		f_hd;	/**< @@brief list of faces sharing this surface */
	int			order[2]; /**< @@brief surface order [0] = u, [1] = v */
	struct knot_vector	u;	/**< @@brief surface knot vectors */
	struct knot_vector	v;	/**< @@brief surface knot vectors */
	/* surface control points */
	int			s_size[2]; /**< @@brief mesh size, u,v */
	int			pt_type; /**< @@brief surface point type */
	fastf_t			*ctl_points; /**< @@brief array [size[0]*size[1]] */
	/* START OF ITEMS VALID IN-MEMORY ONLY -- NOT STORED ON DISK */
	int			dir;	/**< @@brief direction of last refinement */
	point_t			min_pt;	/**< @@brief min corner of bounding box */
	point_t			max_pt;	/**< @@brief max corner of bounding box */
	/*   END OF ITEMS VALID IN-MEMORY ONLY -- NOT STORED ON DISK */
	long			index;	/**< @@brief struct # in this model */
};

struct faceuse {
	struct bu_list		l;	/**< @@brief fu's, in shell's fu_hd list */
	struct shell		*s_p;	/**< @@brief owning shell */
	struct faceuse		*fumate_p;    /**< @@brief opposite side of face */
	int			orientation;  /**< @@brief rel to face geom defn */
	int			outside; /**< @@brief RESERVED for future:  See Lee Butler */
	struct face		*f_p;	/**< @@brief face definition and attributes */
	struct bu_list		lu_hd;	/**< @@brief list of loops in face-use */
	long			index;	/**< @@brief struct # in this model */
};

/** Returns a 3-tuple (vect_t), given faceuse and state of flip flags */
#define NMG_GET_FU_NORMAL(_N, _fu)	{ \
	register const struct faceuse	*_fu1 = (_fu); \
	register const struct face_g_plane	*_fg; \
	NMG_CK_FACEUSE(_fu1); \
	NMG_CK_FACE(_fu1->f_p); \
	_fg = _fu1->f_p->g.plane_p; \
	NMG_CK_FACE_G_PLANE(_fg); \
	if( (_fu1->orientation != OT_SAME) != (_fu1->f_p->flip != 0) )  { \
		VREVERSE( _N, _fg->N); \
	} else { \
		VMOVE( _N, _fg->N ); \
	} }

/** Returns a 4-tuple (plane_t), given faceuse and state of flip flags */
#define NMG_GET_FU_PLANE(_N, _fu)	{ \
	register const struct faceuse	*_fu1 = (_fu); \
	register const struct face_g_plane	*_fg; \
	NMG_CK_FACEUSE(_fu1); \
	NMG_CK_FACE(_fu1->f_p); \
	_fg = _fu1->f_p->g.plane_p; \
	NMG_CK_FACE_G_PLANE(_fg); \
	if( (_fu1->orientation != OT_SAME) != (_fu1->f_p->flip != 0) )  { \
		HREVERSE( _N, _fg->N); \
	} else { \
		HMOVE( _N, _fg->N ); \
	} }

/**
 *			L O O P
 *
 *  To find all the uses of this loop, use lu_p for one loopuse,
 *  then go down and find an edge,
 *  then wander around either eumate_p or radial_p from there.
 *
 *  Normally, down_hd heads a doubly linked list of edgeuses.
 *  But, before using it, check BU_LIST_FIRST_MAGIC(&lu->down_hd)
 *  for the magic number type.
 *  If this is a self-loop on a single vertexuse, then get the vertex pointer
 *  with vu = BU_LIST_FIRST(vertexuse, &lu->down_hd)
 *
 *  This is an especially dangerous storage efficiency measure ("hack"),
 *  because the list that the vertexuse structure belongs to is headed,
 *  not by a superior element type, but by the vertex structure.
 *  When a loopuse needs to point down to a vertexuse, rip off the
 *  forw pointer.  Take careful note that this is just a pointer,
 *  **not** the head of a linked list (single, double, or otherwise)!
 *  Exercise great care!
 *
 *  The edges of an exterior (OT_SAME) loop occur in counter-clockwise
 *  order, as viewed from the normalward side (outside).
 */
#define RT_LIST_SET_DOWN_TO_VERT(_hp,_vu)	{ \
	(_hp)->forw = &((_vu)->l); (_hp)->back = (struct bu_list *)NULL; }

struct loop {
	long			magic;
	struct loopuse		*lu_p;	/**< @@brief Ptr to one use of this loop */
	struct loop_g		*lg_p;  /**< @@brief Geometry */
	long			index;	/**< @@brief struct # in this model */
};

struct loop_g {
	long			magic;
	point_t			min_pt;	/**< @@brief minimums of bounding box */
	point_t			max_pt;	/**< @@brief maximums of bounding box */
	long			index;	/**< @@brief struct # in this model */
};

struct loopuse {
	struct bu_list		l;	/**< @@brief lu's, in fu's lu_hd, or shell's lu_hd */
	union {
		struct faceuse  *fu_p;	/**< @@brief owning face-use */
		struct shell	*s_p;
		long		*magic_p;
	} up;
	struct loopuse		*lumate_p; /**< @@brief loopuse on other side of face */
	int			orientation;  /**< @@brief OT_SAME=outside loop */
	struct loop		*l_p;	/**< @@brief loop definition and attributes */
	struct bu_list		down_hd; /**< @@brief eu list or vu pointer */
	long			index;	/**< @@brief struct # in this model */
};

/**
 *			E D G E
 *
 *  To find all edgeuses of an edge, use eu_p to get an arbitrary edgeuse,
 *  then wander around either eumate_p or radial_p from there.
 *
 *  Only the first vertex of an edge is kept in an edgeuse (eu->vu_p).
 *  The other vertex can be found by either eu->eumate_p->vu_p or
 *  by BU_LIST_PNEXT_CIRC(edgeuse,eu)->vu_p.  Note that the first
 *  form gives a vertexuse in the faceuse of *opposite* orientation,
 *  while the second form gives a vertexuse in the faceuse of the correct
 *  orientation.  If going on to the vertex (vu_p->v_p), both forms
 *  are identical.
 *
 *  An edge_g_lseg structure represents a line in 3-space.  All edges on that
 *  line should share the same edge_g.
 *
 *  An edge occupies the range eu->param to eu->eumate_p->param in it's
 *  geometry's parameter space.  (cnurbs only)
 */
struct edge {
	long			magic;
	struct edgeuse		*eu_p;	/**< @@brief Ptr to one use of this edge */
	long			is_real;/**< @@brief artifact or modeled edge (from tessellator) */
	long			index;	/**< @@brief struct # in this model */
};

/**
 *  IMPORTANT:  First two items in edge_g_lseg and edge_g_cnurb must be
 *  identical structure, so pointers are puns for both.
 *  eu_hd2 list must be in same place for both.
 */
struct edge_g_lseg {
	struct bu_list		l;	/**< @@brief NOTICE:  l.forw & l.back *not* stored in database.  For alignment only. */
	struct bu_list		eu_hd2;	/**< @@brief heads l2 list of edgeuses on this line */
	point_t			e_pt;	/**< @@brief parametric equation of the line */
	vect_t			e_dir;
	long			index;	/**< @@brief struct # in this model */
};

/*
 *  The ctl_points on this curve are (u,v) values on the face's surface.
 *  As a storage and performance efficiency measure, if order <= 0,
 *  then the cnurb is a straight line segment in parameter space,
 *  and the k.knots and ctl_points pointers will be NULL.
 *  In this case, the vertexuse_a_cnurb's at both ends of the edgeuse define
 *  the path through parameter space.
 */
struct edge_g_cnurb {
	struct bu_list		l;	/**< @@brief NOTICE:  l.forw & l.back *not* stored in database.  For LIBNURB internal use only. */
	struct bu_list		eu_hd2;	/**< @@brief heads l2 list of edgeuses on this curve */
	int			order;	/**< @@brief Curve Order */
	struct knot_vector	k;	/**< @@brief curve knot vector */
	/* curve control polygon */
	int			c_size;	/**< @@brief number of ctl points */
	int			pt_type;/**< @@brief curve point type */
	fastf_t			*ctl_points; /**< @@brief array [c_size] */
	long			index;	/**< @@brief struct # in this model */
};

struct edgeuse {
	struct bu_list		l;	/**< @@brief cw/ccw edges in loop or wire edges in shell */
	struct bu_list		l2;	/**< @@brief member of edge_g's eu_hd2 list */
	union {
		struct loopuse	*lu_p;
		struct shell	*s_p;
		long	        *magic_p; /**< @@brief for those times when we're not sure */
	} up;
	struct edgeuse		*eumate_p;  /**< @@brief eu on other face or other end of wire*/
	struct edgeuse		*radial_p;  /**< @@brief eu on radially adj. fu (null if wire)*/
	struct edge		*e_p;	    /**< @@brief edge definition and attributes */
	int	  		orientation;/**< @@brief compared to geom (null if wire) */
	struct vertexuse	*vu_p;	    /**< @@brief first vu of eu in this orient */
	union {
		long		    *magic_p;
		struct edge_g_lseg  *lseg_p;
		struct edge_g_cnurb *cnurb_p;
	} g;				/**< @@brief geometry */
	/* (u,v,w) param[] of vu is found in vu_p->vua_p->param */
	long			index;	/**< @@brief struct # in this model */
};

/**
 *			V E R T E X
 *
 *  The vertex and vertexuse structures are connected in a way different
 *  from the superior kinds of topology elements.
 *  The vertex structure heads a linked list that all vertexuse's
 *  that use the vertex are linked onto.
 */
struct vertex {
	long			magic;
	struct bu_list		vu_hd;	/**< @@brief heads list of vu's of this vertex */
	struct vertex_g		*vg_p;	/**< @@brief geometry */
	long			index;	/**< @@brief struct # in this model */
};

struct vertex_g {
	long			magic;
	point_t			coord;	/**< @@brief coordinates of vertex in space */
	long			index;	/**< @@brief struct # in this model */
};

struct vertexuse {
	struct bu_list		l;	/**< @@brief list of all vu's on a vertex */
	union {
		struct shell	*s_p;	/**< @@brief no fu's or eu's on shell */
		struct loopuse	*lu_p;	/**< @@brief loopuse contains single vertex */
		struct edgeuse	*eu_p;	/**< @@brief eu causing this vu */
		long		*magic_p; /**< @@brief for those times when we're not sure */
	} up;
	struct vertex		*v_p;	/**< @@brief vertex definition and attributes */
	union {
		long				*magic_p;
		struct vertexuse_a_plane	*plane_p;
		struct vertexuse_a_cnurb	*cnurb_p;
	} a;				/**< @@brief Attributes */
	long			index;	/**< @@brief struct # in this model */
};

struct vertexuse_a_plane {
	long			magic;
	vect_t			N;	/**< @@brief (opt) surface Normal at vertexuse */
	long			index;	/**< @@brief struct # in this model */
};

struct vertexuse_a_cnurb {
	long			magic;
	fastf_t			param[3]; /**< @@brief (u,v,w) of vu on eu's cnurb */
	long			index;	/**< @@brief struct # in this model */
};

/**
 * storage allocation and de-allocation support
 *  Primarily used by nmg_mk.c
 */

#define NMG_GETSTRUCT(p,str)	BU_GETSTRUCT(p,str)


#define NMG_FREESTRUCT(ptr, str) { \
    memset((char *)(ptr), 0, sizeof(struct str)); \
    bu_free((char *)(ptr), "freestruct " #str); \
}


/*
 *  Macros to create and destroy storage for the NMG data structures.
 *  Since nmg_mk.c and g_nmg.c are the only source file which should perform
 *  these most fundamental operations, the macros do not belong in nmg.h
 *  In particular, application code should NEVER do these things.
 *  Any need to do so should be handled by extending nmg_mk.c
 */
#define NMG_INCR_INDEX(_p,_m)	\
	NMG_CK_MODEL(_m); (_p)->index = ((_m)->maxindex)++

#define GET_REGION(p,m)	    {NMG_GETSTRUCT(p, nmgregion); NMG_INCR_INDEX(p,m);}
#define GET_REGION_A(p,m)   {NMG_GETSTRUCT(p, nmgregion_a); NMG_INCR_INDEX(p,m);}
#define GET_SHELL(p,m)	    {NMG_GETSTRUCT(p, shell); NMG_INCR_INDEX(p,m);}
#define GET_SHELL_A(p,m)    {NMG_GETSTRUCT(p, shell_a); NMG_INCR_INDEX(p,m);}
#define GET_FACE(p,m)	    {NMG_GETSTRUCT(p, face); NMG_INCR_INDEX(p,m);}
#define GET_FACE_G_PLANE(p,m) {NMG_GETSTRUCT(p, face_g_plane); NMG_INCR_INDEX(p,m);}
#define GET_FACE_G_SNURB(p,m) {NMG_GETSTRUCT(p, face_g_snurb); NMG_INCR_INDEX(p,m);}
#define GET_FACEUSE(p,m)    {NMG_GETSTRUCT(p, faceuse); NMG_INCR_INDEX(p,m);}
#define GET_LOOP(p,m)	    {NMG_GETSTRUCT(p, loop); NMG_INCR_INDEX(p,m);}
#define GET_LOOP_G(p,m)	    {NMG_GETSTRUCT(p, loop_g); NMG_INCR_INDEX(p,m);}
#define GET_LOOPUSE(p,m)    {NMG_GETSTRUCT(p, loopuse); NMG_INCR_INDEX(p,m);}
#define GET_EDGE(p,m)	    {NMG_GETSTRUCT(p, edge); NMG_INCR_INDEX(p,m);}
#define GET_EDGE_G_LSEG(p,m)  {NMG_GETSTRUCT(p, edge_g_lseg); NMG_INCR_INDEX(p,m);}
#define GET_EDGE_G_CNURB(p,m) {NMG_GETSTRUCT(p, edge_g_cnurb); NMG_INCR_INDEX(p,m);}
#define GET_EDGEUSE(p,m)    {NMG_GETSTRUCT(p, edgeuse); NMG_INCR_INDEX(p,m);}
#define GET_VERTEX(p,m)	    {NMG_GETSTRUCT(p, vertex); NMG_INCR_INDEX(p,m);}
#define GET_VERTEX_G(p,m)   {NMG_GETSTRUCT(p, vertex_g); NMG_INCR_INDEX(p,m);}
#define GET_VERTEXUSE(p,m)  {NMG_GETSTRUCT(p, vertexuse); NMG_INCR_INDEX(p,m);}
#define GET_VERTEXUSE_A_PLANE(p,m) {NMG_GETSTRUCT(p, vertexuse_a_plane); NMG_INCR_INDEX(p,m);}
#define GET_VERTEXUSE_A_CNURB(p,m) {NMG_GETSTRUCT(p, vertexuse_a_cnurb); NMG_INCR_INDEX(p,m);}

#define FREE_MODEL(p)	    NMG_FREESTRUCT(p, model)
#define FREE_REGION(p)	    NMG_FREESTRUCT(p, nmgregion)
#define FREE_REGION_A(p)    NMG_FREESTRUCT(p, nmgregion_a)
#define FREE_SHELL(p)	    NMG_FREESTRUCT(p, shell)
#define FREE_SHELL_A(p)	    NMG_FREESTRUCT(p, shell_a)
#define FREE_FACE(p)	    NMG_FREESTRUCT(p, face)
#define FREE_FACE_G_PLANE(p) NMG_FREESTRUCT(p, face_g_plane)
#define FREE_FACE_G_SNURB(p) NMG_FREESTRUCT(p, face_g_snurb)
#define FREE_FACEUSE(p)	    NMG_FREESTRUCT(p, faceuse)
#define FREE_LOOP(p)	    NMG_FREESTRUCT(p, loop)
#define FREE_LOOP_G(p)	    NMG_FREESTRUCT(p, loop_g)
#define FREE_LOOPUSE(p)	    NMG_FREESTRUCT(p, loopuse)
#define FREE_LOOPUSE_A(p)   NMG_FREESTRUCT(p, loopuse_a)
#define FREE_EDGE(p)	    NMG_FREESTRUCT(p, edge)
#define FREE_EDGE_G_LSEG(p)  NMG_FREESTRUCT(p, edge_g_lseg)
#define FREE_EDGE_G_CNURB(p) NMG_FREESTRUCT(p, edge_g_cnurb)
#define FREE_EDGEUSE(p)	    NMG_FREESTRUCT(p, edgeuse)
#define FREE_VERTEX(p)	    NMG_FREESTRUCT(p, vertex)
#define FREE_VERTEX_G(p)    NMG_FREESTRUCT(p, vertex_g)
#define FREE_VERTEXUSE(p)   NMG_FREESTRUCT(p, vertexuse)
#define FREE_VERTEXUSE_A_PLANE(p) NMG_FREESTRUCT(p, vertexuse_a_plane)
#define FREE_VERTEXUSE_A_CNURB(p) NMG_FREESTRUCT(p, vertexuse_a_cnurb)

/** Do two edgeuses share the same two vertices? If yes, eu's should be joined. */
#define NMG_ARE_EUS_ADJACENT(_eu1,_eu2)	(  \
	( (_eu1)->vu_p->v_p == (_eu2)->vu_p->v_p &&   \
	  (_eu1)->eumate_p->vu_p->v_p == (_eu2)->eumate_p->vu_p->v_p )  ||  \
	( (_eu1)->vu_p->v_p == (_eu2)->eumate_p->vu_p->v_p &&  \
	  (_eu1)->eumate_p->vu_p->v_p == (_eu2)->vu_p->v_p ) )

/** Compat: Used in nmg_misc.c and nmg_mod.c */
#define EDGESADJ(_e1, _e2) NMG_ARE_EUS_ADJACENT(_e1,_e2)

/** Print a plane equation. */
#define PLPRINT(_s, _pl) bu_log("%s %gx + %gy + %gz = %g\n", (_s), \
	(_pl)[0], (_pl)[1], (_pl)[2], (_pl)[3])


/** values for the "allhits" argument to mg_class_pt_fu_except() */
#define NMG_FPI_FIRST	0	/**< @@brief return after finding first touch */
#define NMG_FPI_PERGEOM	1	/**< @@brief find all touches,
				 *  call user funcs once for each
				 * geometry element touched
				 */
#define NMG_FPI_PERUSE	2	/**< @@brief find all touches,
				 *  call user funcs once for each
				 * use of geom elements touched
				 */


struct nmg_boolstruct {
	struct bu_ptbl	ilist;		/**< @@brief vertexuses on intersection line */
	fastf_t		tol;
	point_t		pt;		/**< @@brief line of intersection */
	vect_t		dir;
	int		coplanar;
	char		*vertlist;
	int		vlsize;
	struct model	*model;
};

#define PREEXIST 1
#define NEWEXIST 2


#define VU_PREEXISTS(_bs, _vu) { chkidxlist((_bs), (_vu)); \
	(_bs)->vertlist[(_vu)->index] = PREEXIST; }

#define VU_NEW(_bs, _vu) { chkidxlist((_bs), (_vu)); \
	(_bs)->vertlist[(_vu)->index] = NEWEXIST; }


struct nmg_struct_counts {
	/* Actual structure counts (Xuse, then X) */
	long	model;
	long	region;
	long	region_a;
	long	shell;
	long	shell_a;
	long	faceuse;
	long	face;
	long	face_g_plane;
	long	face_g_snurb;
	long	loopuse;
	long	loop;
	long	loop_g;
	long	edgeuse;
	long	edge;
	long	edge_g_lseg;
	long	edge_g_cnurb;
	long	vertexuse;
	long	vertexuse_a_plane;
	long	vertexuse_a_cnurb;
	long	vertex;
	long	vertex_g;
	/* Abstractions */
	long	max_structs;
	long	face_loops;
	long	face_edges;
	long	face_lone_verts;
	long	wire_loops;
	long	wire_loop_edges;
	long	wire_edges;
	long	wire_lone_verts;
	long	shells_of_lone_vert;
};

/*
 *  For use with tables subscripted by NMG structure "index" values,
 *  traditional test and set macros.
 *  A value of zero indicates unset, a value of one indicates set.
 *  test-and-set returns TRUE if value was unset;  in the process,
 *  value has become set.  This is often used to detect the first
 *  time an item is used, so an alternative name is given, for clarity.
 *  Note that the somewhat simpler auto-increment form
 *	( (tab)[(p)->index]++ == 0 )
 *  is not used, to avoid the possibility of integer overflow from
 *  repeated test-and-set operations on one item.
 */
#define NMG_INDEX_VALUE(_tab,_index)	((_tab)[_index])
#define NMG_INDEX_TEST(_tab,_p)		( (_tab)[(_p)->index] )
#define NMG_INDEX_SET(_tab,_p)		{(_tab)[(_p)->index] = 1;}
#define NMG_INDEX_CLEAR(_tab,_p)	{(_tab)[(_p)->index] = 0;}
#define NMG_INDEX_TEST_AND_SET(_tab,_p)	\
	( (_tab)[(_p)->index] == 0 ? ((_tab)[(_p)->index] = 1) : 0 )
#define NMG_INDEX_IS_SET(_tab,_p)	NMG_INDEX_TEST(_tab,_p)
#define NMG_INDEX_FIRST_TIME(_tab,_p)	NMG_INDEX_TEST_AND_SET(_tab,_p)
#define NMG_INDEX_ASSIGN(_tab,_p,_val)	{(_tab)[(_p)->index] = _val;}
#define NMG_INDEX_GET(_tab,_p)		((_tab)[(_p)->index])
#define NMG_INDEX_GETP(_ty,_tab,_p)	((struct _ty *)((_tab)[(_p)->index]))
#define NMG_INDEX_OR(_tab,_p,_val)	{(_tab)[(_p)->index] |= _val;}
#define NMG_INDEX_AND(_tab,_p,_val)	{(_tab)[(_p)->index] &= _val;}
#define NMG_INDEX_RETURN_IF_SET_ELSE_SET(_tab,_index)	\
	{ if( (_tab)[_index] )  return; \
	  else (_tab)[_index] = 1; }

/* flags for manifold-ness */
#define NMG_3MANIFOLD	16
#define NMG_2MANIFOLD	4
#define NMG_1MANIFOLD	2
#define NMG_0MANIFOLD	1
#if 0
# define NMG_DANGLING	8 /* NMG_2MANIFOLD + 4th bit for special cond */
#endif

#define NMG_SET_MANIFOLD(_t,_p,_v) NMG_INDEX_OR(_t, _p, _v)
#define NMG_MANIFOLDS(_t, _p)	   NMG_INDEX_VALUE(_t, (_p)->index)
#define NMG_CP_MANIFOLD(_t, _p, _q) (_t)[(_p)->index] = (_t)[(_q)->index]

/*
 *  Bit-parameters for nmg_lu_to_vlist() poly_markers code.
 */
#define NMG_VLIST_STYLE_VECTOR			0
#define NMG_VLIST_STYLE_POLYGON			1
#define NMG_VLIST_STYLE_VISUALIZE_NORMALS	2
#define NMG_VLIST_STYLE_USE_VU_NORMALS		4
#define NMG_VLIST_STYLE_NO_SURFACES		8

/**
 *  Function table, for use with nmg_visit()
 *  Indended to have same generally the organization as nmg_struct_counts.
 *  The handler's args are long* to allow generic handlers to be written,
 *  in which case the magic number at long* specifies the object type.
 *
 *  The "vis_" prefix means the handler is visited only once.
 *  The "bef_" and "aft_" prefixes are called (respectively) before
 *  and after recursing into subsidiary structures.
 *  The 3rd arg is 0 for a "bef_" call, and 1 for an "aft_" call,
 *  to allow generic handlers to be written, if desired.
 */
struct nmg_visit_handlers {
	void	(*bef_model) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_model) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_region) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_region) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_region_a) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_shell) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_shell) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_shell_a) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_faceuse) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_faceuse) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_face) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_face_g) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_loopuse) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_loopuse) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_loop) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_loop_g) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_edgeuse) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_edgeuse) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_edge) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_edge_g) NMG_ARGS((long *, genptr_t, int));

	void	(*bef_vertexuse) NMG_ARGS((long *, genptr_t, int));
	void	(*aft_vertexuse) NMG_ARGS((long *, genptr_t, int));

	void	(*vis_vertexuse_a) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_vertex) NMG_ARGS((long *, genptr_t, int));
	void	(*vis_vertex_g) NMG_ARGS((long *, genptr_t, int));
};

#endif /* __NMG_H__ */

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@begin bzero -> memset conversion
@
text
@d589 4
a592 9
#if __STDC__ && !defined(alliant) && !defined(apollo)
# define NMG_FREESTRUCT(ptr, str) \
	{ memset((char *)(ptr), 0, sizeof(struct str)); \
	  bu_free((char *)(ptr), "freestruct " #str); }
#else
# define NMG_FREESTRUCT(ptr, str) \
	{ memset((char *)(ptr), 0, sizeof(struct str)); \
	  bu_free((char *)(ptr), "freestruct str"); }
#endif
@


14.22
log
@tweak debug log messages for consistency
@
text
@d591 1
a591 1
	{ bzero((char *)(ptr), sizeof(struct str)); \
d595 1
a595 1
	{ bzero((char *)(ptr), sizeof(struct str)); \
@


14.21
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d198 1
a198 1
		bu_log("in %s at %d Bad edgeuse member pointer\n",\
d200 1
a200 1
			bu_bomb("Null pointer\n"); \
d202 5
a206 3
	(_p)->eumate_p->vu_p->up.eu_p != (_p)->eumate_p) {\
		bu_log("in %s at %d edgeuse lost vertexuse\n",\
			 __FILE__, __LINE__); bu_bomb("bye");}
@


14.20
log
@clean up the header protections so that they are all now more consistent with one another via use of __HEADER_H__ for the define names.
@
text
@a27 4
 *  @@par Source
 *	The U. S. Army Research Laboratory
 *  @@n	Aberdeen Proving Ground, Maryland  21005-5066
 *
@


14.19
log
@get rid of RCS variables from the public header files.  this is done in part to reduce recompilation during interface changes, but also to move towards not relying on or publishing the information contained in the variables interface-wise. (they're fine for c sources and private headers)
@
text
@d49 3
a51 2
#ifndef NMG_H
#define NMG_H seen
d55 1
a55 3
/* make sure all the prerequisite include files have been included
 */
#ifndef MACHINE_H
a56 3
#endif

#ifndef VMATH_H
a57 3
#endif

#ifndef SEEN_BU_H
a58 1
#endif
d61 1
a61 1
#define NULL 0
d843 2
a844 1
#endif
@


14.18
log
@don't force USE_PROTOTYPES to be necessarily set to get what we usually want anyways (i.e. proper decls with args) -- check for __STDC__ too to determine how to declare.
@
text
@a47 2
 *
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.17 2007/05/18 04:13:43 brlcad Exp $
@


14.17
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.16 2007/05/14 16:53:54 brlcad Exp $
a114 1
 *  The setting of USE_PROTOTYPES is done in machine.h
d116 1
a116 1
#if USE_PROTOTYPES
@


14.16
log
@er, if they're deprecated, then why the heck are we still using them.  remove rtlist.h and compat4.h usage.
@
text
@d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.15 2007/05/14 16:39:14 brlcad Exp $
d215 1
a215 1
			rt_bomb("Null pointer\n"); \
d219 1
a219 1
			 __FILE__, __LINE__); rt_bomb("bye");}
@


14.15
log
@rtlist.h and rtstring.h are no longer relevant -- warn that they are obsolete (to be removed in a future minor rev)
@
text
@d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.14 2007/01/27 01:01:40 brlcad Exp $
a65 8
#ifndef SEEN_RTLIST_H
#include "rtlist.h"
#endif

#ifndef SEEN_COMPAT4_H
#include "compat4.h"
#endif

@


14.14
log
@ws, test three
@
text
@a41 2
 *	# include "rtlist.h"	/_* OPTIONAL, auto-included by raytrace.h *_/
 *	# include "rtstring.h"	/_* OPTIONAL, auto-included by raytrace.h *_/
d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.13 2007/01/23 01:13:20 brlcad Exp $
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d51 1
a51 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.12 2007/01/21 04:45:40 brlcad Exp $
d183 1
a183 1
/** 
d228 2
a229 2
	    	bu_log("in %s at %d edgeuse lost vertexuse\n",\
	    		 __FILE__, __LINE__); rt_bomb("bye");}
a874 1

@


14.12
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d51 1
a51 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.11 2007/01/20 14:36:40 brlcad Exp $
@


14.11
log
@update copyright to 2007
@
text
@d22 1
a22 1
/*@@{*/
d31 1
a31 1
 *@@n	Aberdeen Proving Ground, Maryland  21005-5066
d33 1
a33 1
 *@@brief
d52 1
a52 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.10 2006/09/18 05:24:07 lbutler Exp $
d866 1
a866 1
/*@@}*/
@


14.10
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d52 1
a52 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.9 2006/08/31 04:41:19 lbutler Exp $
@


14.9
log
@miscelaneous changes to support doxygen
@
text
@d21 2
a24 3
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
d26 4
a29 1
 *  Source -
d31 1
a31 1
 *	Aberdeen Proving Ground, Maryland  21005-5066
d33 1
d39 1
a39 1
 *	# include <stdio.h>
d49 1
a49 1
 *  Libraries Used -
d52 1
a52 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.8 2006/07/09 20:51:40 brlcad Exp $
d88 15
a102 15
#define DEBUG_PL_ANIM	0x00000001	/* 1 mged: animated evaluation */
#define DEBUG_PL_SLOW	0x00000002	/* 2 mged: add delays to animation */
#define DEBUG_GRAPHCL	0x00000004	/* 3 mged: graphic classification */
#define DEBUG_PL_LOOP	0x00000008	/* 4 loop class (needs GRAPHCL) */
#define DEBUG_PLOTEM	0x00000010	/* 5 make plots in debugged routines (needs other flags set too) */
#define DEBUG_POLYSECT	0x00000020	/* 6 nmg_inter: face intersection */
#define DEBUG_VERIFY	0x00000040	/* 7 nmg_vshell() frequently, verify health */
#define DEBUG_BOOL	0x00000080	/* 8 nmg_bool:  */
#define DEBUG_CLASSIFY	0x00000100	/* 9 nmg_class: */
#define DEBUG_BOOLEVAL	0x00000200	/* 10 nmg_eval: what to retain */
#define DEBUG_BASIC	0x00000400	/* 013 nmg_mk.c and nmg_mod.c routines */
#define DEBUG_MESH	0x00000800	/* 12 nmg_mesh: describe edge search */
#define DEBUG_MESH_EU	0x00001000	/* 13 nmg_mesh: list edges meshed */
#define DEBUG_POLYTO	0x00002000	/* 14 nmg_misc: polytonmg */
#define DEBUG_LABEL_PTS 0x00004000	/* 15 label points in plot files */
d104 11
a114 11
#define DEBUG_NMGRT	0x00010000	/* 17 ray tracing */
#define DEBUG_FINDEU	0x00020000	/* 18 nmg_mod: nmg_findeu() */
#define DEBUG_CMFACE	0x00040000	/* 19 nmg_mod: nmg_cmface() */
#define DEBUG_CUTLOOP	0x00080000	/* 024 nmg_mod: nmg_cut_loop */
#define DEBUG_VU_SORT	0x00100000	/* 025 nmg_fcut: coincident vu sort */
#define DEBUG_FCUT	0x00200000	/* 026 nmg_fcut: face cutter */
#define DEBUG_RT_SEGS	0x00400000	/* 027 nmg_rt_segs: */
#define DEBUG_RT_ISECT	0x00800000	/* 028 nmg_rt_isect: */
#define DEBUG_TRI	0x01000000	/* 029 nmg_tri */
#define DEBUG_PT_FU	0x02000000	/* 029 nmg_pt_fu */
#define DEBUG_MANIF	0x04000000	/* 029 nmg_manif */
d135 3
a137 3
#define NMG_BOOL_SUB 1		/* subtraction */
#define NMG_BOOL_ADD 2		/* addition/union */
#define NMG_BOOL_ISECT 4	/* intsersection */
d151 5
a155 5
#define OT_NONE     0    /* no orientation (error) */
#define OT_SAME     1    /* orientation same */
#define OT_OPPOSITE 2    /* orientation opposite */
#define OT_UNSPEC   3    /* orientation unspecified */
#define OT_BOOLPLACE 4   /* object is intermediate data for boolean ops */
d163 1
a163 1
#define NMG_SHELL_MAGIC 	0x71077345	/* shell oil */
d167 1
a167 1
#define NMG_FACE_G_SNURB_MAGIC	0x736e7262	/* was RT_SNURB_MAGIC */
d174 1
a174 1
#define NMG_EDGE_G_CNURB_MAGIC	0x636e7262	/* was RT_CNURB_MAGIC */
d176 1
a176 1
#define NMG_EDGEUSE2_MAGIC	0x91919191	/* used in eu->l2.magic */
d182 1
a182 1
#define NMG_KNOT_VECTOR_MAGIC	0x6b6e6f74	/* aka RT_KNOT_VECTOR_MAGIC */
d184 2
a185 1
/* macros to check/validate a structure pointer
d232 1
a232 1
/*
d234 2
a236 1
 *  Definition of a knot vector.
d242 2
a243 2
	int		k_size;		/* knot vector size */
	fastf_t		* knots;	/* pointer to knot vector  */
d245 1
a245 1
#define RT_KNOT_VECTOR_MAGIC	NMG_KNOT_VECTOR_MAGIC	/* nurb.h compat */
d266 1
a266 1
/*
d271 3
a273 3
	struct bu_list		r_hd;	/* list of regions */
	long			index;	/* struct # in this model */
	long			maxindex; /* # of structs so far */
d276 1
a276 1
/*
d280 5
a284 5
	struct bu_list		l;	/* regions, in model's r_hd list */
	struct model   		*m_p;	/* owning model */
	struct nmgregion_a	*ra_p;	/* attributes */
	struct bu_list		s_hd;	/* list of shells in region */
	long			index;	/* struct # in this model */
d289 3
a291 3
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
	long			index;	/* struct # in this model */
d294 1
a294 1
/*
d313 9
a321 9
	struct bu_list		l;	/* shells, in region's s_hd list */
	struct nmgregion	*r_p;	/* owning region */
	struct shell_a		*sa_p;	/* attribs */

	struct bu_list		fu_hd;	/* list of face uses in shell */
	struct bu_list		lu_hd;	/* wire loopuses (edge groups) */
	struct bu_list		eu_hd;	/* wire list (shell has wires) */
	struct vertexuse	*vu_p;	/* internal ptr to single vertexuse */
	long			index;	/* struct # in this model */
d326 3
a328 3
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
	long			index;	/* struct # in this model */
d331 1
a331 1
/*
d338 2
a339 2
	struct bu_list		l;	/* faces in face_g's f_hd list */
	struct faceuse		*fu_p;	/* Ptr up to one use of this face */
d344 2
a345 2
	} g;				/* geometry */
	int			flip;	/* !0 ==> flip normal of fg */
d348 3
a350 3
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
	long			index;	/* struct # in this model */
d355 3
a357 3
	struct bu_list		f_hd;	/* list of faces sharing this surface */
	plane_t			N;	/* Plane equation (incl normal) */
	long			index;	/* struct # in this model */
d363 4
a366 4
	struct bu_list		f_hd;	/* list of faces sharing this surface */
	int			order[2]; /* surface order [0] = u, [1] = v */
	struct knot_vector	u;	/* surface knot vectors */
	struct knot_vector	v;	/* surface knot vectors */
d368 3
a370 3
	int			s_size[2]; /* mesh size, u,v */
	int			pt_type; /* surface point type */
	fastf_t			*ctl_points; /* array [size[0]*size[1]] */
d372 3
a374 3
	int			dir;	/* direction of last refinement */
	point_t			min_pt;	/* min corner of bounding box */
	point_t			max_pt;	/* max corner of bounding box */
d376 1
a376 1
	long			index;	/* struct # in this model */
d380 8
a387 8
	struct bu_list		l;	/* fu's, in shell's fu_hd list */
	struct shell		*s_p;	/* owning shell */
	struct faceuse		*fumate_p;    /* opposite side of face */
	int			orientation;  /* rel to face geom defn */
	int			outside; /* RESERVED for future:  See Lee Butler */
	struct face		*f_p;	/* face definition and attributes */
	struct bu_list		lu_hd;	/* list of loops in face-use */
	long			index;	/* struct # in this model */
d390 1
a390 1
/* Returns a 3-tuple (vect_t), given faceuse and state of flip flags */
d404 1
a404 1
/* Returns a 4-tuple (plane_t), given faceuse and state of flip flags */
d418 1
a418 1
/*
d447 3
a449 3
	struct loopuse		*lu_p;	/* Ptr to one use of this loop */
	struct loop_g		*lg_p;  /* Geometry */
	long			index;	/* struct # in this model */
d454 3
a456 3
	point_t			min_pt;	/* minimums of bounding box */
	point_t			max_pt;	/* maximums of bounding box */
	long			index;	/* struct # in this model */
d460 1
a460 1
	struct bu_list		l;	/* lu's, in fu's lu_hd, or shell's lu_hd */
d462 1
a462 1
		struct faceuse  *fu_p;	/* owning face-use */
d466 5
a470 5
	struct loopuse		*lumate_p; /* loopuse on other side of face */
	int			orientation;  /* OT_SAME=outside loop */
	struct loop		*l_p;	/* loop definition and attributes */
	struct bu_list		down_hd; /* eu list or vu pointer */
	long			index;	/* struct # in this model */
d473 1
a473 1
/*
d495 3
a497 3
	struct edgeuse		*eu_p;	/* Ptr to one use of this edge */
	long			is_real;/* artifact or modeled edge (from tessellator) */
	long			index;	/* struct # in this model */
d500 1
a500 1
/*
d506 3
a508 3
	struct bu_list		l;	/* NOTICE:  l.forw & l.back *not* stored in database.  For alignment only. */
	struct bu_list		eu_hd2;	/* heads l2 list of edgeuses on this line */
	point_t			e_pt;	/* parametric equation of the line */
d510 1
a510 1
	long			index;	/* struct # in this model */
d522 4
a525 4
	struct bu_list		l;	/* NOTICE:  l.forw & l.back *not* stored in database.  For LIBNURB internal use only. */
	struct bu_list		eu_hd2;	/* heads l2 list of edgeuses on this curve */
	int			order;	/* Curve Order */
	struct knot_vector	k;	/* curve knot vector */
d527 4
a530 4
	int			c_size;	/* number of ctl points */
	int			pt_type;/* curve point type */
	fastf_t			*ctl_points; /* array [c_size] */
	long			index;	/* struct # in this model */
d534 2
a535 2
	struct bu_list		l;	/* cw/ccw edges in loop or wire edges in shell */
	struct bu_list		l2;	/* member of edge_g's eu_hd2 list */
d539 1
a539 1
		long	        *magic_p; /* for those times when we're not sure */
d541 5
a545 5
	struct edgeuse		*eumate_p;  /* eu on other face or other end of wire*/
	struct edgeuse		*radial_p;  /* eu on radially adj. fu (null if wire)*/
	struct edge		*e_p;	    /* edge definition and attributes */
	int	  		orientation;/* compared to geom (null if wire) */
	struct vertexuse	*vu_p;	    /* first vu of eu in this orient */
d550 1
a550 1
	} g;				/* geometry */
d552 1
a552 1
	long			index;	/* struct # in this model */
d555 1
a555 1
/*
d565 3
a567 3
	struct bu_list		vu_hd;	/* heads list of vu's of this vertex */
	struct vertex_g		*vg_p;	/* geometry */
	long			index;	/* struct # in this model */
d572 2
a573 2
	point_t			coord;	/* coordinates of vertex in space */
	long			index;	/* struct # in this model */
d577 1
a577 1
	struct bu_list		l;	/* list of all vu's on a vertex */
d579 4
a582 4
		struct shell	*s_p;	/* no fu's or eu's on shell */
		struct loopuse	*lu_p;	/* loopuse contains single vertex */
		struct edgeuse	*eu_p;	/* eu causing this vu */
		long		*magic_p; /* for those times when we're not sure */
d584 1
a584 1
	struct vertex		*v_p;	/* vertex definition and attributes */
d589 2
a590 2
	} a;				/* Attributes */
	long			index;	/* struct # in this model */
d595 2
a596 2
	vect_t			N;	/* (opt) surface Normal at vertexuse */
	long			index;	/* struct # in this model */
d601 2
a602 2
	fastf_t			param[3]; /* (u,v,w) of vu on eu's cnurb */
	long			index;	/* struct # in this model */
d605 1
a605 1
/*
d678 1
a678 1
/* Do two edgeuses share the same two vertices? If yes, eu's should be joined. */
d685 1
a685 1
/* Compat: Used in nmg_misc.c and nmg_mod.c */
d688 1
a688 1
/* Print a plane equation. */
d693 3
a695 3
/* values for the "allhits" argument to mg_class_pt_fu_except() */
#define NMG_FPI_FIRST	0	/* return after finding first touch */
#define NMG_FPI_PERGEOM	1	/* find all touches,
d699 1
a699 1
#define NMG_FPI_PERUSE	2	/* find all touches,
d706 1
a706 1
	struct bu_ptbl	ilist;		/* vertexuses on intersection line */
d708 1
a708 1
	point_t		pt;		/* line of intersection */
d813 1
a813 1
/*
d866 1
a866 1

d876 1
@


14.8
log
@bzero define block is a duplicate of said block in machine.h, removed.
@
text
@d36 9
a44 9
 *	#include <stdio.h>
 *	#include <math.h>
 *	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	#include "vmath.h"	/_* For vect_t definition *_/
 *	#include "rtlist.h"	/_* OPTIONAL, auto-included by raytrace.h *_/
 *	#include "rtstring.h"	/_* OPTIONAL, auto-included by raytrace.h *_/
 *	#include "nmg.h"
 *	#include "raytrace.h"
 *	#include "nurb.h"	/_* OPTIONAL, follows raytrace.h when used *_/
d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.7 2006/01/18 06:46:10 brlcad Exp $
@


14.7
log
@update copyright to 2006
@
text
@d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.6 2005/10/23 04:44:26 brlcad Exp $
d618 1
a618 4
#if defined(SYSV) && !defined(bzero) && !defined(HAVE_BZERO)
#	define bzero(str,n)		memset( str, '\0', n )
#	define bcopy(from,to,count)	memcpy( to, from, count )
#endif
@


14.7.2.1
log
@moved nurbs-related structures back to the nurb.h header. nmg.h now includes nurb.h as a dependency.
@
text
@d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.7 2006/01/18 06:46:10 brlcad Exp $
a77 4
#ifndef NURB_H
#include "nurb.h"
#endif

d179 1
a179 1
#define NMG_KNOT_VECTOR_MAGIC	RT_KNOT_VECTOR_MAGIC	/* aka RT_KNOT_VECTOR_MAGIC */
d228 13
d355 19
d508 19
@


14.6
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.5 2005/09/19 17:38:51 brlcad Exp $
@


14.5
log
@common.h
@
text
@d26 1
a26 1
 *  
d32 1
a32 1
 *  Developed from "Non-Manifold Geometric Boundary Modeling" by 
d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.4 2005/01/30 20:30:10 brlcad Exp $
d336 1
a336 1
		long		    *magic_p;	
@


14.4
log
@update copyright to 2005
@
text
@d49 1
a49 1
 *  $Header: /cvsroot/brlcad/brlcad/include/nmg.h,v 14.3 2004/12/21 06:23:18 morrison Exp $
d54 2
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d26 1
a26 1
 *
d32 1
a32 1
 *  Developed from "Non-Manifold Geometric Boundary Modeling" by
d49 1
a49 1
 *  $Header$
a53 2
#include "common.h"

d334 1
a334 1
		long		    *magic_p;
@


14.3
log
@use perl to M-q format wrapping
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d49 1
a49 1
 *  $Header: /cvs/brlcad/include/nmg.h,v 14.2 2004/12/21 06:06:38 butler Exp $
@


14.2
log
@LGPL license changes
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU Lesser General Public License
 * along with this file; see the file named COPYING for more
d49 1
a49 1
 *  $Header: /cvs/brlcad/include/nmg.h,v 14.1 2004/11/16 19:42:10 morrison Exp $
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			N M G . H
a29 3
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
d49 1
a49 1
 *  $Header: /cvs/brlcad/include/nmg.h,v 1.2 2004/11/08 23:24:20 morrison Exp $
@


1.2
log
@the nmg_visit_handers_null no longer exists, to avoid struct copy usage where callbacks were constant.
@
text
@d33 1
a33 1
 *  $Header: /n/xoff/cvs/brlcad/include/nmg.h,v 1.1 2004/05/24 04:10:50 morrison Exp $
d846 10
@


1.1
log
@moved/renamed from top-level h/ to top-level include/
@
text
@d33 1
a33 1
 *  $Header$
a843 2

extern const struct nmg_visit_handlers nmg_visit_handlers_null;
@

