head	14.23;
access;
symbols
	rel-7-10-4:14.23
	STABLE:14.23.0.2
	stable-branch:14.4
	rel-7-10-2:14.23
	rel-7-10-0:14.19
	rel-7-8-4:14.13
	rel-7-8-2:14.7
	rel-7-8-0:14.7
	trimnurbs-branch:14.7.0.2
	help:14.7
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.5
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.6
	rel-7-6-2:14.5
	rel-7-6-branch:14.5.0.6
	rel-7-6-0:14.5
	rel-7-4-2:14.5
	rel-7-4-branch:14.5.0.4
	bobWinPort:14.5.0.2
	rel-7-4-0:14.5
	rel-7-2-6:14.5
	rel-7-2-4:14.5
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.23
date	2007.07.26.01.13.50;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.05.26.02.12.32;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.05.26.02.08.02;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.05.26.01.45.04;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.02.21.19.21.28;	author jlowenz;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.27.01.01.40;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.23.01.13.20;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.21.04.45.40;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.36.40;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.12.18.58.22;	author jlowenz;	state Exp;
branches;
next	14.13;

14.13
date	2006.09.18.05.24.07;	author lbutler;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.31.04.41.20;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.29.17.13.35;	author erikgreenwald;	state Exp;
branches;
next	14.10;

14.10
date	2006.07.30.12.17.11;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.07.14.19.20.37;	author erikgreenwald;	state Exp;
branches;
next	14.8;

14.8
date	2006.07.14.15.02.44;	author erikgreenwald;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.10;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.23.04.44.26;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.05.08.05.27.59;	author brlcad;	state Exp;
branches
	14.5.6.1;
next	14.4;

14.4
date	2005.01.30.20.30.11;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.23.18;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.06.39;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.10;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.24.04.10.51;	author morrison;	state Exp;
branches;
next	;

14.5.6.1
date	2005.11.13.13.46.10;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.23
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@/*                        R T G E O M . H
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_ */
/** @@{ */
/** @@file rtgeom.h
 *
 * @@brief
 *  Details of the internal forms used by the LIBRT geometry routines
 *  for the different solids.
 *
 *  These structures are what the struct rt_db_internal
 *  generic pointer idb_ptr points at,
 *  based on idb_type indicating a solid id ID_xxx, such as ID_TGC.
 *
 *  Depends on having machine.h, bu.h, vmath.h, and bn.h included first.
 *
 *  The proper order for including them all is:
 *	#  include <stdio.h>
 *	# include <math.h>
 *	# include "machine.h"
 *	# include "bu.h"
 *	# include "vmath.h"
 *	# include "nmg.h"
 *	# include "raytrace.h"
 *	# include "nurb.h"
 *	# include "rtgeom.h"
 *
 *  @@author
 *	Michael John Muuss
 */

#ifndef __RTGEOM_H__
#define __RTGEOM_H__

#include "common.h"

__BEGIN_DECLS

#undef r_a /* defined on alliant in <machine/reg.h> included in signal.h */

#define NAMELEN 16	/* NAMESIZE from db.h (can't call it NAMESIZE!!!!!) */

/*
 *	ID_TOR
 */
struct rt_tor_internal {
	long	magic;
	point_t	v;		/**< @@brief  center point */
	vect_t	h;		/**< @@brief  normal, unit length */
	fastf_t	r_h;		/**< @@brief  radius in H direction (r2) */
	fastf_t	r_a;		/**< @@brief  radius in A direction (r1) */
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	vect_t	a;		/**< @@brief  r_a length */
	vect_t	b;		/**< @@brief  r_b length */
	fastf_t	r_b;		/**< @@brief  radius in B direction (typ == r_a) */
};
#define RT_TOR_INTERNAL_MAGIC	0x9bffed87
#define RT_TOR_CK_MAGIC(_p)	BU_CKMAG(_p,RT_TOR_INTERNAL_MAGIC,"rt_tor_internal")

/**
 *	ID_TGC and ID_REC
 */
struct rt_tgc_internal {
	long	magic;
	vect_t	v;
	vect_t	h;
	vect_t	a;
	vect_t	b;
	vect_t	c;
	vect_t	d;
};
#define RT_TGC_INTERNAL_MAGIC	0xaabbdd87
#define RT_TGC_CK_MAGIC(_p)	BU_CKMAG(_p,RT_TGC_INTERNAL_MAGIC,"rt_tgc_internal")

/*
 *	ID_ELL, and ID_SPH
 */
struct rt_ell_internal  {
	long	magic;
	point_t	v;
	vect_t	a;
	vect_t	b;
	vect_t	c;
};
#define RT_ELL_INTERNAL_MAGIC	0x93bb23ff
#define RT_ELL_CK_MAGIC(_p)	BU_CKMAG(_p,RT_ELL_INTERNAL_MAGIC,"rt_ell_internal")

/*
 *      ID_SUPERELL
 */
struct rt_superell_internal {
	long    magic;
	point_t v;
	vect_t  a;
	vect_t  b;
	vect_t  c;
  double n;
  double e;
};
#define RT_SUPERELL_INTERNAL_MAGIC      0xff93bb23
#define RT_SUPERELL_CK_MAGIC(_p)        BU_CKMAG(_p,RT_SUPERELL_INTERNAL_MAGIC,"rt_superell_internal")

/*
 *      ID_METABALL
 */
struct rt_metaball_internal {
	long    magic;
	int	method;
	fastf_t	threshold;
	struct bu_list	metaball_ctrl_head;
};
#define RT_METABALL_INTERNAL_MAGIC      0x62616c6c	/* ball */
#define RT_METABALL_CK_MAGIC(_p)        BU_CKMAG(_p,RT_METABALL_INTERNAL_MAGIC,"rt_metaball_internal")

/*
 *	ID_ARB8
 *
 *  The internal (in memory) form of an ARB8 -- 8 points in space.
 *  The first 4 form the "bottom" face, the second 4 form the "top" face.
 */
struct rt_arb_internal {
	long	magic;
	point_t	pt[8];
};
#define RT_ARB_INTERNAL_MAGIC	0x9befd010
#define RT_ARB_CK_MAGIC(_p)	BU_CKMAG(_p,RT_ARB_INTERNAL_MAGIC,"rt_arb_internal")

/*
 *	ID_ARS
 */
struct rt_ars_internal {
	long	magic;
	int	ncurves;
	int	pts_per_curve;
	fastf_t	**curves;
};
#define RT_ARS_INTERNAL_MAGIC	0x77ddbbe3
#define RT_ARS_CK_MAGIC(_p)	BU_CKMAG(_p,RT_ARS_INTERNAL_MAGIC,"rt_ars_internal")

/*
 *	ID_HALF
 */
struct rt_half_internal  {
	long	magic;
	plane_t	eqn;
};
#define RT_HALF_INTERNAL_MAGIC	0xaa87bbdd
#define RT_HALF_CK_MAGIC(_p)	BU_CKMAG(_p,RT_HALF_INTERNAL_MAGIC,"rt_half_internal")

/*
 *	ID_GRIP
 */
struct rt_grip_internal {
	long	magic;
	point_t	center;
	/* Remaining elemnts are used for display purposes only */
	vect_t	normal;
	fastf_t	mag;
};
#define RT_GRIP_INTERNAL_MAGIC	0x31196205
#define RT_GRIP_CK_MAGIC(_p)	BU_CKMAG(_p,RT_GRIP_INTERNAL_MAGIC,"rt_grip_internal")

/**
 *	ID_POLY
 */
struct rt_pg_internal {
	long	magic;
	int	npoly;
	struct rt_pg_face_internal {
		int	npts;		/**< @@brief  number of points for this polygon */
		fastf_t	*verts;		/**< @@brief  has 3*npts elements */
		fastf_t	*norms;		/**< @@brief  has 3*npts elements */
	} *poly;			/**< @@brief  has npoly elements */
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	int	max_npts;		/**< @@brief  maximum value of npts in poly[] */
};
#define RT_PG_INTERNAL_MAGIC	0x9bfed887
#define RT_PG_CK_MAGIC(_p)	BU_CKMAG(_p,RT_PG_INTERNAL_MAGIC,"rt_pg_internal")

/* ID_BSPLINE */
struct rt_nurb_internal {
	long		magic;
	int	 	nsrf;		/**< @@brief  number of surfaces */
	struct face_g_snurb **srfs;	/**< @@brief  The surfaces themselves */
};

#define RT_NURB_INTERNAL_MAGIC	0x002b2bdd
#define RT_NURB_CK_MAGIC( _p) BU_CKMAG(_p,RT_NURB_INTERNAL_MAGIC,"rt_nurb_internal");
#define RT_NURB_GET_CONTROL_POINT(_s,_u,_v)	((_s)->ctl_points[ \
	((_v)*(_s)->s_size[0]+(_u))*RT_NURB_EXTRACT_COORDS((_s)->pt_type)])

#include "brep.h"
/*
 * a b-rep solid consists of a
 */
/* ID_BREP */
struct rt_brep_internal {
    long magic;
    ON_Brep* brep; /**< @@brief  An openNURBS brep object containing the solid */
};

#define RT_BREP_INTERNAL_MAGIC 0x42524550 /* BREP */
#define RT_BREP_CK_MAGIC( _p) BU_CKMAG(_p,RT_BREP_INTERNAL_MAGIC,"rt_brep_internal");

/*
 *	ID_NMG
 *
 *  The internal form of the NMG is not rt_nmg_internal, but just
 *  a "struct model", from nmg.h.  e.g.:
 *	if( intern.idb_type == ID_NMG )
 *		m = (struct model *)intern.idb_ptr;
 */

/*
 *	ID_EBM
 */
#define RT_EBM_NAME_LEN 256
struct rt_ebm_internal  {
	long		magic;
	char		file[RT_EBM_NAME_LEN];
	int		xdim;		/**< @@brief  X dimension (w cells) */
	int		ydim;		/**< @@brief  Y dimension (n cells) */
	fastf_t		tallness;	/**< @@brief  Z dimension (mm) */
	mat_t		mat;		/**< @@brief  convert local coords to model space */
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	struct bu_mapped_file	*mp;	/**< @@brief  actual data */
};
#define RT_EBM_INTERNAL_MAGIC	0xf901b231
#define RT_EBM_CK_MAGIC(_p)	BU_CKMAG(_p,RT_EBM_INTERNAL_MAGIC,"rt_ebm_internal")

/*
 *	ID_VOL
 */
#define RT_VOL_NAME_LEN 128
struct rt_vol_internal  {
	long		magic;
	char		file[RT_VOL_NAME_LEN];
	int		xdim;		/**< @@brief  X dimension */
	int		ydim;		/**< @@brief  Y dimension */
	int		zdim;		/**< @@brief  Z dimension */
	int		lo;		/**< @@brief  Low threshold */
	int		hi;		/**< @@brief  High threshold */
	vect_t		cellsize;	/**< @@brief  ideal coords: size of each cell */
	mat_t		mat;		/**< @@brief  convert local coords to model space */
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	unsigned char	*map;
};
#define RT_VOL_INTERNAL_MAGIC	0x987ba1d0
#define RT_VOL_CK_MAGIC(_p)	BU_CKMAG(_p,RT_VOL_INTERNAL_MAGIC,"rt_vol_internal")

/*
 *	ID_HF
 */
struct rt_hf_internal {
	long		magic;
	/* BEGIN USER SETABLE VARIABLES */
	char		cfile[128];	/**< @@brief  name of control file (optional) */
	char		dfile[128];	/**< @@brief  name of data file */
	char		fmt[8];		/**< @@brief  CV style file format descriptor */
	int		w;		/**< @@brief  # samples wide of data file.  ("i", "x") */
	int		n;		/**< @@brief  nlines of data file.  ("j", "y") */
	int		shorts;		/**< @@brief  !0 --> memory array is short, not float */
	fastf_t		file2mm;	/**< @@brief  scale factor to cvt file units to mm */
	vect_t		v;		/**< @@brief  origin of HT in model space */
	vect_t		x;		/**< @@brief  model vect corresponding to "w" dir (will be unitized) */
	vect_t		y;		/**< @@brief  model vect corresponding to "n" dir (will be unitized) */
	fastf_t		xlen;		/**< @@brief  model len of HT rpp in "w" dir */
	fastf_t		ylen;		/**< @@brief  model len of HT rpp in "n" dir */
	fastf_t		zscale;		/**< @@brief  scale of data in ''up'' dir (after file2mm is applied) */
	/* END USER SETABLE VARIABLES, BEGIN INTERNAL STUFF */
	struct bu_mapped_file	*mp;	/**< @@brief  actual data */
};
#define RT_HF_INTERNAL_MAGIC	0x4846494d
#define RT_HF_CK_MAGIC(_p)	BU_CKMAG(_p,RT_HF_INTERNAL_MAGIC,"rt_hf_internal")

/*
 *	ID_ARBN
 */
struct rt_arbn_internal  {
	long	magic;
	int	neqn;
	plane_t	*eqn;
};
#define RT_ARBN_INTERNAL_MAGIC	0x18236461
#define RT_ARBN_CK_MAGIC(_p)	BU_CKMAG(_p,RT_ARBN_INTERNAL_MAGIC,"rt_arbn_internal")

/*
 *	ID_PIPE
 */
struct rt_pipe_internal {
	long		pipe_magic;
	struct bu_list	pipe_segs_head;
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	int		pipe_count;
};
#define RT_PIPE_INTERNAL_MAGIC	0x7dd7bb3e
#define RT_PIPE_CK_MAGIC(_p)	BU_CKMAG(_p,RT_PIPE_INTERNAL_MAGIC,"rt_pipe_internal")

/*
 *	ID_PARTICLE
 */
struct rt_part_internal {
	long	part_magic;
	point_t	part_V;
	vect_t	part_H;
	fastf_t	part_vrad;
	fastf_t	part_hrad;
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	int	part_type;		/**< @@brief  sphere, cylinder, cone */
};
#define RT_PART_INTERNAL_MAGIC	0xaaccee87
#define RT_PART_CK_MAGIC(_p)	BU_CKMAG(_p,RT_PART_INTERNAL_MAGIC,"rt_part_internal")

#define RT_PARTICLE_TYPE_SPHERE		1
#define RT_PARTICLE_TYPE_CYLINDER	2
#define RT_PARTICLE_TYPE_CONE		3

/*
 *	ID_RPC
 */
struct rt_rpc_internal {
	long	rpc_magic;
	point_t	rpc_V;	/**< @@brief  rpc vertex */
	vect_t	rpc_H;	/**< @@brief  height vector */
	vect_t	rpc_B;	/**< @@brief  breadth vector */
	fastf_t	rpc_r;	/**< @@brief  scalar half-width of rectangular face */
};
#define RT_RPC_INTERNAL_MAGIC	0xaaccee88
#define RT_RPC_CK_MAGIC(_p)	BU_CKMAG(_p,RT_RPC_INTERNAL_MAGIC,"rt_rpc_internal")

/*
 *	ID_RHC
 */
struct rt_rhc_internal {
	long	rhc_magic;
	point_t	rhc_V;	/**< @@brief  rhc vertex */
	vect_t	rhc_H;	/**< @@brief  height vector */
	vect_t	rhc_B;	/**< @@brief  breadth vector */
	fastf_t	rhc_r;	/**< @@brief  scalar half-width of rectangular face */
	fastf_t	rhc_c;	/**< @@brief  dist from hyperbola to vertex of asymptotes */
};
#define RT_RHC_INTERNAL_MAGIC	0xaaccee89
#define RT_RHC_CK_MAGIC(_p)	BU_CKMAG(_p,RT_RHC_INTERNAL_MAGIC,"rt_rhc_internal")

/*
 *	ID_EPA
 */
struct rt_epa_internal {
	long	epa_magic;
	point_t	epa_V;	/**< @@brief  epa vertex */
	vect_t	epa_H;	/**< @@brief  height vector */
	vect_t	epa_Au;	/**< @@brief  unit vector along semi-major axis */
	fastf_t	epa_r1;	/**< @@brief  scalar semi-major axis length */
	fastf_t	epa_r2;	/**< @@brief  scalar semi-minor axis length */
};
#define RT_EPA_INTERNAL_MAGIC	0xaaccee90
#define RT_EPA_CK_MAGIC(_p)	BU_CKMAG(_p,RT_EPA_INTERNAL_MAGIC,"rt_epa_internal")

/*
 *	ID_EHY
 */
struct rt_ehy_internal {
	long	ehy_magic;
	point_t	ehy_V;	/**< @@brief  ehy vertex */
	vect_t	ehy_H;	/**< @@brief  height vector */
	vect_t	ehy_Au;	/**< @@brief  unit vector along semi-major axis */
	fastf_t	ehy_r1;	/**< @@brief  scalar semi-major axis length */
	fastf_t	ehy_r2;	/**< @@brief  scalar semi-minor axis length */
	fastf_t	ehy_c;	/**< @@brief  dist from hyperbola to vertex of asymptotes */
};
#define RT_EHY_INTERNAL_MAGIC	0xaaccee91
#define RT_EHY_CK_MAGIC(_p)	BU_CKMAG(_p,RT_EHY_INTERNAL_MAGIC,"rt_ehy_internal")

/*
 *	ID_ETO
 */
struct rt_eto_internal {
	long	eto_magic;
	point_t	eto_V;	/**< @@brief  eto vertex */
	vect_t	eto_N;	/**< @@brief  vector normal to plane of torus */
	vect_t	eto_C;	/**< @@brief  vector along semi-major axis of ellipse */
	fastf_t	eto_r;	/**< @@brief  scalar radius of rotation */
	fastf_t	eto_rd;	/**< @@brief  scalar length of semi-minor of ellipse */
};
#define RT_ETO_INTERNAL_MAGIC	0xaaccee92
#define RT_ETO_CK_MAGIC(_p)	BU_CKMAG(_p,RT_ETO_INTERNAL_MAGIC,"rt_eto_internal")

/*
 *	ID_DSP
 */
#define DSP_NAME_LEN 128
struct rt_dsp_internal{
	long		magic;
#define dsp_file dsp_name /**< @@brief  for backwards compatibility */
	struct bu_vls	dsp_name;		/**< @@brief  name of data file */
	unsigned int	dsp_xcnt;		/**< @@brief  # samples in row of data */
	unsigned int	dsp_ycnt;		/**< @@brief  # of columns in data */
	unsigned short	dsp_smooth;		/**< @@brief  bool: surf normal interp */
#define DSP_CUT_DIR_ADAPT	'a'
#define DSP_CUT_DIR_llUR	'l'
#define DSP_CUT_DIR_ULlr	'L'
    unsigned char   dsp_cuttype;		/**< @@brief  type of cut to make */

	mat_t		dsp_mtos;		/**< @@brief  model to solid space */
	/* END OF USER SETABLE VARIABLES, BEGIN INTERNAL STUFF */
	mat_t		dsp_stom;		/**< @@brief  solid to model space
						 * computed from dsp_mtos */
	unsigned short	*dsp_buf;		/**< @@brief  actual data */
	struct bu_mapped_file *dsp_mp;		/**< @@brief  mapped file for data */
	struct rt_db_internal *dsp_bip;		/**< @@brief  db object for data */
#define RT_DSP_SRC_V4_FILE	'4'
#define RT_DSP_SRC_FILE	'f'
#define RT_DSP_SRC_OBJ	'o'
	char		dsp_datasrc;		/**< @@brief  which type of data source */
};
#define RT_DSP_INTERNAL_MAGIC	0xde6
#define RT_DSP_CK_MAGIC(_p)	BU_CKMAG(_p,RT_DSP_INTERNAL_MAGIC,"rt_dsp_internal")


/*
 *	ID_SKETCH
 */

#define SKETCH_NAME_LEN	16
struct rt_sketch_internal
{
	long		magic;
	point_t		V;		/**< @@brief  default embedding of sketch */
	vect_t		u_vec;		/**< @@brief  u_vec and v_vec are unit vectors defining the plane of */
	vect_t		v_vec;		/**< @@brief  the sketch */
	int		vert_count;	/**< @@brief  number of vertices in this sketch */
	point2d_t	*verts;		/**< @@brief  array of 2D vertices that may be used as
					 * endpoints, centers, or spline control points */
/* XXX this should have a distinctive name, like rt_curve */
	struct curve {
		int		seg_count;	/**< @@brief  number of segments in this curve */
		int		*reverse;	/**< @@brief  array of ints indicating if segment should be reversed */
		genptr_t	*segments;	/**< @@brief  array of pointers to segments in this curve */
	} skt_curve;				/**< @@brief  the curve in this sketch */
};
#define RT_SKETCH_INTERNAL_MAGIC	0x736b6574	/* sket */
#define RT_SKETCH_CK_MAGIC(_p)	BU_CKMAG(_p,RT_SKETCH_INTERNAL_MAGIC,"rt_sketch_internal")

/*
 *	ID_SUBMODEL
 */
struct rt_submodel_internal {
	long		magic;
	struct bu_vls	file;	/**< @@brief  .g filename, 0-len --> this database. */
	struct bu_vls	treetop;	/**< @@brief  one treetop only */
	int		meth;		/**< @@brief  space partitioning method */
	/* other option flags (lazy prep, etc.)?? */
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	mat_t		root2leaf;
	const struct db_i *dbip;
};
#define RT_SUBMODEL_INTERNAL_MAGIC	0x7375626d	/**< @@brief  subm */
#define RT_SUBMODEL_CK_MAGIC(_p)	BU_CKMAG(_p,RT_SUBMODEL_INTERNAL_MAGIC,"rt_submodel_internal")

/*
 *	ID_EXTRUDE
 */

struct rt_extrude_internal
{
	long		magic;
	point_t		V;	/**< @@brief  vertex, start and end point of loop to be extruded */
	vect_t		h;	/**< @@brief  extrusion vector, may not be in (u_vec X v_vec) plane */
	vect_t		u_vec;	/**< @@brief  vector in U parameter direction */
	vect_t		v_vec;	/**< @@brief  vector in V parameter direction */
	int		keypoint;	/**< @@brief  index of keypoint vertex */
	char		*sketch_name;	/**< @@brief  name of sketch object that defines
						 * the curve to be extruded */
	struct rt_sketch_internal	*skt;	/**< @@brief  pointer to referenced sketch */
};

/*	Note that the u_vec and v_vec are not unit vectors, their magnitude and direction are
 *	used for scaling and rotation
 */
#define RT_EXTRUDE_INTERNAL_MAGIC	0x65787472	/* extr */
#define RT_EXTRUDE_CK_MAGIC(_p)	BU_CKMAG(_p,RT_EXTRUDE_INTERNAL_MAGIC,"rt_extrude_internal")

/*
 *	ID_CLINE
 *
 *	Implementation of FASTGEN CLINE element
 */

struct rt_cline_internal
{
	long		magic;
	point_t		v;
	vect_t		h;
	fastf_t		radius;
	fastf_t		thickness; 	/**< @@brief  zero thickness means volume mode */
};
#define	RT_CLINE_INTERNAL_MAGIC		0x43767378	/* CLIN */
#define RT_CLINE_CK_MAGIC(_p)	BU_CKMAG(_p,RT_CLINE_INTERNAL_MAGIC,"rt_cline_internal")

/*
 *	ID_BOT
 */

struct rt_bot_internal
{
	long		magic;
	unsigned char	mode;
	unsigned char	orientation;
	unsigned char	bot_flags;		/**< @@brief  flags, (indicates surface normals available, for example) */
	int		num_vertices;
	int		num_faces;
	int		*faces;			/**< @@brief  array of ints for faces [num_faces*3] */
	fastf_t		*vertices;		/**< @@brief  array of floats for vertices [num_vertices*3] */
	fastf_t		*thickness;		/**< @@brief  array of plate mode thicknesses (corresponds to array of faces)
						 * NULL for modes RT_BOT_SURFACE and RT_BOT_SOLID.
						 */
	struct bu_bitv	*face_mode;		/**< @@brief  a flag for each face indicating thickness is appended to hit point
						 * in ray direction (if bit is set), otherwise thickness is centered
						 * about hit point (NULL for modes RT_BOT_SURFACE and RT_BOT_SOLID).
						 */
	int		num_normals;
	fastf_t		*normals;		/**< @@brief  array of unit surface normals [num_normals*3] */
	int		num_face_normals;	/**< @@brief  current size of the face_normals array below (number of faces in the array) */
	int		*face_normals;		/**< @@brief  array of indices into the "normals" array, one per face vertex [num_face_normals*3] */
};

/* orientationss for BOT */
#define	RT_BOT_UNORIENTED		1	/**< @@brief  unoriented triangles */
#define RT_BOT_CCW			2	/**< @@brief  oriented counter-clockwise */
#define RT_BOT_CW			3	/**< @@brief  oriented clockwise */

/* modes for BOT */
#define RT_BOT_SURFACE			1	/**< @@brief  triangles represent a surface (no volume) */
#define RT_BOT_SOLID			2	/**< @@brief  triangles respresent the boundary of a solid object */
#define	RT_BOT_PLATE			3	/**< @@brief  triangles represent plates. Thicknesses are specified in "thickness" array,
						 * and face mode is specified in "face_mode" bit vector.
						 * This is the FASTGEN "plate" mode. Orientation is ignored. */
#define RT_BOT_PLATE_NOCOS		4	/**< @@brief  same as plate mode, but LOS is set equal to face thickness, not
						 * the thickness divided by the cosine of the obliquity angle */

/* flags for bot_flags */
#define RT_BOT_HAS_SURFACE_NORMALS    0x1     /**< @@brief  This primitive may have surface normals at each face vertex */
#define RT_BOT_USE_NORMALS	      0x2     /**< @@brief  Use the surface normals if they exist */
#define RT_BOT_USE_FLOATS	      0x4     /**< @@brief  Use the single precision version of "tri_specific" during prep */

#define	RT_BOT_INTERNAL_MAGIC		0x626F7472	/* botr */
#define RT_BOT_CK_MAGIC(_p)	BU_CKMAG(_p,RT_BOT_INTERNAL_MAGIC,"rt_bot_internal")

__END_DECLS

#endif /* __RTGEOM_H__ */

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.22
log
@missed the endif
@
text
@a46 5
 *
 *  @@par Source
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
@


14.21
log
@clean up the header protections so that they are all now more consistent with one another via use of __HEADER_H__ for the define names.
@
text
@a210 1
#endif
@


14.20
log
@get rid of RCS variables from the public header files.  this is done in part to reduce recompilation during interface changes, but also to move towards not relying on or publishing the information contained in the variables interface-wise. (they're fine for c sources and private headers)
@
text
@d54 2
a55 2
#ifndef SEEN_RTGEOM_H
#define SEEN_RTGEOM_H seen
a202 3
#ifdef NMG_H				/* Only if we have seen struct face_g_snurb */
#ifndef SEEN_RT_NURB_INTERNAL
#define SEEN_RT_NURB_INTERNAL
a207 1
#endif
d574 2
a575 1
#endif /* SEEN_RTGEOM_H */
@


14.19
log
@Remove ON_BREP conditional, rely on _cplusplus instead
@
text
@a51 2
 *
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.18 2007/01/27 01:01:40 brlcad Exp $
@


14.18
log
@ws, test three
@
text
@d53 1
a53 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.17 2007/01/23 01:13:20 brlcad Exp $
a220 1
#if OBJ_BREP /* are we compiling the b-rep/NURBS support? */
a233 2
#endif

@


14.17
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d53 1
a53 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.16 2007/01/21 04:45:40 brlcad Exp $
d76 1
a76 1
        /* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
d224 1
a224 1
 * a b-rep solid consists of a 
d235 1
a235 1
#endif 
a593 1

@


14.16
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d53 1
a53 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.15 2007/01/20 14:36:40 brlcad Exp $
@


14.15
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 1
/*@@{*/
d24 2
a25 1
 *@@brief
d54 1
a54 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.14 2007/01/12 18:58:22 jlowenz Exp $
d585 1
a585 1
/*@@}*/
@


14.14
log
@Define new b-rep primitive internal structure.
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d54 1
a54 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.13 2006/09/18 05:24:07 lbutler Exp $
@


14.13
log
@Doxygen updates
@
text
@d54 1
a54 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.12 2006/08/31 04:41:20 lbutler Exp $
d222 16
@


14.12
log
@miscelaneous changes to support doxygen
@
text
@d22 2
d25 1
a25 1
 *
d36 1
a36 1
 *	# include <stdio.h>
d46 1
a46 1
 *  Author -
d49 1
a49 1
 *  Source -
d54 1
a54 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.11 2006/08/29 17:13:35 erikgreenwald Exp $
d73 8
a80 8
	point_t	v;		/* center point */
	vect_t	h;		/* normal, unit length */
	fastf_t	r_h;		/* radius in H direction (r2) */
	fastf_t	r_a;		/* radius in A direction (r1) */
	/* REMAINING ELEMENTS PROVIDED BY IMPORT, UNUSED BY EXPORT */
	vect_t	a;		/* r_a length */
	vect_t	b;		/* r_b length */
	fastf_t	r_b;		/* radius in B direction (typ == r_a) */
d85 1
a85 1
/*
d188 1
a188 1
/*
d195 4
a198 4
		int	npts;		/* number of points for this polygon */
		fastf_t	*verts;		/* has 3*npts elements */
		fastf_t	*norms;		/* has 3*npts elements */
	} *poly;			/* has npoly elements */
d200 1
a200 1
	int	max_npts;		/* maximum value of npts in poly[] */
d211 2
a212 2
	int	 	nsrf;		/* number of surfaces */
	struct face_g_snurb **srfs;	/* The surfaces themselves */
d238 4
a241 4
	int		xdim;		/* X dimension (w cells) */
	int		ydim;		/* Y dimension (n cells) */
	fastf_t		tallness;	/* Z dimension (mm) */
	mat_t		mat;		/* convert local coords to model space */
d243 1
a243 1
	struct bu_mapped_file	*mp;	/* actual data */
d255 7
a261 7
	int		xdim;		/* X dimension */
	int		ydim;		/* Y dimension */
	int		zdim;		/* Z dimension */
	int		lo;		/* Low threshold */
	int		hi;		/* High threshold */
	vect_t		cellsize;	/* ideal coords: size of each cell */
	mat_t		mat;		/* convert local coords to model space */
d274 13
a286 13
	char		cfile[128];	/* name of control file (optional) */
	char		dfile[128];	/* name of data file */
	char		fmt[8];		/* CV style file format descriptor */
	int		w;		/* # samples wide of data file.  ("i", "x") */
	int		n;		/* nlines of data file.  ("j", "y") */
	int		shorts;		/* !0 --> memory array is short, not float */
	fastf_t		file2mm;	/* scale factor to cvt file units to mm */
	vect_t		v;		/* origin of HT in model space */
	vect_t		x;		/* model vect corresponding to "w" dir (will be unitized) */
	vect_t		y;		/* model vect corresponding to "n" dir (will be unitized) */
	fastf_t		xlen;		/* model len of HT rpp in "w" dir */
	fastf_t		ylen;		/* model len of HT rpp in "n" dir */
	fastf_t		zscale;		/* scale of data in ''up'' dir (after file2mm is applied) */
d288 1
a288 1
	struct bu_mapped_file	*mp;	/* actual data */
d326 1
a326 1
	int	part_type;		/* sphere, cylinder, cone */
d340 4
a343 4
	point_t	rpc_V;	/* rpc vertex */
	vect_t	rpc_H;	/* height vector */
	vect_t	rpc_B;	/* breadth vector */
	fastf_t	rpc_r;	/* scalar half-width of rectangular face */
d353 5
a357 5
	point_t	rhc_V;	/* rhc vertex */
	vect_t	rhc_H;	/* height vector */
	vect_t	rhc_B;	/* breadth vector */
	fastf_t	rhc_r;	/* scalar half-width of rectangular face */
	fastf_t	rhc_c;	/* dist from hyperbola to vertex of asymptotes */
d367 5
a371 5
	point_t	epa_V;	/* epa vertex */
	vect_t	epa_H;	/* height vector */
	vect_t	epa_Au;	/* unit vector along semi-major axis */
	fastf_t	epa_r1;	/* scalar semi-major axis length */
	fastf_t	epa_r2;	/* scalar semi-minor axis length */
d381 6
a386 6
	point_t	ehy_V;	/* ehy vertex */
	vect_t	ehy_H;	/* height vector */
	vect_t	ehy_Au;	/* unit vector along semi-major axis */
	fastf_t	ehy_r1;	/* scalar semi-major axis length */
	fastf_t	ehy_r2;	/* scalar semi-minor axis length */
	fastf_t	ehy_c;	/* dist from hyperbola to vertex of asymptotes */
d396 5
a400 5
	point_t	eto_V;	/* eto vertex */
	vect_t	eto_N;	/* vector normal to plane of torus */
	vect_t	eto_C;	/* vector along semi-major axis of ellipse */
	fastf_t	eto_r;	/* scalar radius of rotation */
	fastf_t	eto_rd;	/* scalar length of semi-minor of ellipse */
d411 5
a415 5
#define dsp_file dsp_name /* for backwards compatibility */
	struct bu_vls	dsp_name;		/* name of data file */
	unsigned int	dsp_xcnt;		/* # samples in row of data */
	unsigned int	dsp_ycnt;		/* # of columns in data */
	unsigned short	dsp_smooth;		/* bool: surf normal interp */
d419 1
a419 1
    unsigned char   dsp_cuttype;		/* type of cut to make */
d421 1
a421 1
	mat_t		dsp_mtos;		/* model to solid space */
d423 1
a423 1
	mat_t		dsp_stom;		/* solid to model space
d425 3
a427 3
	unsigned short	*dsp_buf;		/* actual data */
	struct bu_mapped_file *dsp_mp;		/* mapped file for data */
	struct rt_db_internal *dsp_bip;		/* db object for data */
d431 1
a431 1
	char		dsp_datasrc;		/* which type of data source */
d445 5
a449 5
	point_t		V;		/* default embedding of sketch */
	vect_t		u_vec;		/* u_vec and v_vec are unit vectors defining the plane of */
	vect_t		v_vec;		/* the sketch */
	int		vert_count;	/* number of vertices in this sketch */
	point2d_t	*verts;		/* array of 2D vertices that may be used as
d453 4
a456 4
		int		seg_count;	/* number of segments in this curve */
		int		*reverse;	/* array of ints indicating if segment should be reversed */
		genptr_t	*segments;	/* array of pointers to segments in this curve */
	} skt_curve;				/* the curve in this sketch */
d466 3
a468 3
	struct bu_vls	file;	/* .g filename, 0-len --> this database. */
	struct bu_vls	treetop;	/* one treetop only */
	int		meth;		/* space partitioning method */
d474 1
a474 1
#define RT_SUBMODEL_INTERNAL_MAGIC	0x7375626d	/* subm */
d484 6
a489 6
	point_t		V;	/* vertex, start and end point of loop to be extruded */
	vect_t		h;	/* extrusion vector, may not be in (u_vec X v_vec) plane */
	vect_t		u_vec;	/* vector in U parameter direction */
	vect_t		v_vec;	/* vector in V parameter direction */
	int		keypoint;	/* index of keypoint vertex */
	char		*sketch_name;	/* name of sketch object that defines
d491 1
a491 1
	struct rt_sketch_internal	*skt;	/* pointer to referenced sketch */
d512 1
a512 1
	fastf_t		thickness; 	/* zero thickness means volume mode */
d526 1
a526 1
	unsigned char	bot_flags;		/* flags, (indicates surface normals available, for example) */
d529 3
a531 3
	int		*faces;			/* array of ints for faces [num_faces*3] */
	fastf_t		*vertices;		/* array of floats for vertices [num_vertices*3] */
	fastf_t		*thickness;		/* array of plate mode thicknesses (corresponds to array of faces)
d534 1
a534 1
	struct bu_bitv	*face_mode;		/* a flag for each face indicating thickness is appended to hit point
d539 3
a541 3
	fastf_t		*normals;		/* array of unit surface normals [num_normals*3] */
	int		num_face_normals;	/* current size of the face_normals array below (number of faces in the array) */
	int		*face_normals;		/* array of indices into the "normals" array, one per face vertex [num_face_normals*3] */
d545 3
a547 3
#define	RT_BOT_UNORIENTED		1	/* unoriented triangles */
#define RT_BOT_CCW			2	/* oriented counter-clockwise */
#define RT_BOT_CW			3	/* oriented clockwise */
d550 3
a552 3
#define RT_BOT_SURFACE			1	/* triangles represent a surface (no volume) */
#define RT_BOT_SOLID			2	/* triangles respresent the boundary of a solid object */
#define	RT_BOT_PLATE			3	/* triangles represent plates. Thicknesses are specified in "thickness" array,
d555 1
a555 1
#define RT_BOT_PLATE_NOCOS		4	/* same as plate mode, but LOS is set equal to face thickness, not
d559 3
a561 3
#define RT_BOT_HAS_SURFACE_NORMALS    0x1     /* This primitive may have surface normals at each face vertex */
#define RT_BOT_USE_NORMALS	      0x2     /* Use the surface normals if they exist */
#define RT_BOT_USE_FLOATS	      0x4     /* Use the single precision version of "tri_specific" during prep */
d569 1
a569 1

d579 1
@


14.11
log
@Added "method" to metaball struct. Changed some language.
@
text
@d34 9
a42 9
 *	#include <stdio.h>
 *	#include <math.h>
 *	#include "machine.h"
 *	#include "bu.h"
 *	#include "vmath.h"
 *	#include "nmg.h"
 *	#include "raytrace.h"
 *	#include "nurb.h"
 *	#include "rtgeom.h"
d52 1
a52 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.10 2006/07/30 12:17:11 brlcad Exp $
@


14.10
log
@can only use 4 bytes, not 5 on the RT_METABALL_INTERNAL_MAGIC .. made it 'ball' instead of 'mball'
@
text
@d52 1
a52 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.9 2006/07/14 19:20:37 erikgreenwald Exp $
d131 3
a133 2
	fastf_t	threshhold;
	struct bu_list	metaball_pt_head;
@


14.9
log
@store metaball control points in a bu_list of structs instead of an array of homogenous vectors
@
text
@d52 1
a52 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.8 2006/07/14 15:02:44 erikgreenwald Exp $
d134 1
a134 1
#define RT_METABALL_INTERNAL_MAGIC      0x6D62616C6C	/* mbal */
@


14.8
log
@claiming a number for metaballs
@
text
@d52 1
a52 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.7 2006/01/18 06:46:10 brlcad Exp $
a130 1
	int	npoints;
d132 1
a132 1
	hvect_t *points;	/* [x,y,z,w] where w is the effectors value */
@


14.7
log
@update copyright to 2006
@
text
@d21 1
d52 1
a52 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.6 2005/10/23 04:44:26 brlcad Exp $
d126 11
@


14.6
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d51 1
a51 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.5 2005/05/08 05:27:59 brlcad Exp $
@


14.5
log
@consolidate the __cplusplus external declaration sections that protect C functions from C++ name mangling by using the same __BEGIN_DECLS and __END_DECLS macros in our headers (3rd party are mostly left alone).  works indentation a little too.
@
text
@d45 1
a45 1
 *  
d51 1
a51 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.4 2005/01/30 20:30:11 brlcad Exp $
d173 1
a173 1
	
d406 1
a406 1
        
d409 1
a409 1
	mat_t		dsp_stom;		/* solid to model space 
@


14.5.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d45 1
a45 1
 *
d51 1
a51 1
 *  $Header$
d173 1
a173 1

d406 1
a406 1

d409 1
a409 1
	mat_t		dsp_stom;		/* solid to model space
@


14.4
log
@update copyright to 2005
@
text
@d51 1
a51 1
 *  $Header: /cvsroot/brlcad/brlcad/include/rtgeom.h,v 14.3 2004/12/21 06:23:18 morrison Exp $
d57 3
a59 3
#ifdef __cplusplus
extern "C" {
#endif
d552 1
a552 4

#ifdef __cplusplus
}
#endif
@


14.3
log
@use perl to M-q format wrapping
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d51 1
a51 1
 *  $Header: /cvs/brlcad/include/rtgeom.h,v 14.2 2004/12/21 06:06:39 butler Exp $
@


14.2
log
@LGPL license changes
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU Lesser General Public License
 * along with this file; see the file named COPYING for more
d51 1
a51 1
 *  $Header: /cvs/brlcad/include/rtgeom.h,v 14.1 2004/11/16 19:42:10 morrison Exp $
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			R T G E O M . H
a49 3
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
d51 1
a51 1
 *  $Header: /cvs/brlcad/include/rtgeom.h,v 1.1 2004/05/24 04:10:51 morrison Exp $
@


1.1
log
@moved/renamed from top-level h/ to top-level include/
@
text
@d35 1
a35 1
 *  $Header$
d542 10
@

