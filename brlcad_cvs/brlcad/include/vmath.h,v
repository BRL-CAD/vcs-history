head	14.28;
access;
symbols
	rel-7-10-4:14.25
	STABLE:14.25.0.2
	stable-branch:14.4
	rel-7-10-2:14.25
	rel-7-10-0:14.22
	rel-7-8-4:14.14
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.8
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.6
	rel-7-6-0:14.6
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.4
	bobWinPort:14.6.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.28
date	2007.12.20.08.47.45;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.12.18.19.41.40;	author bob1961;	state Exp;
branches;
next	14.26;

14.26
date	2007.09.14.23.40.38;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.05.26.02.08.02;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.05.26.01.45.04;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.05.19.00.44.51;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.27.01.01.40;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.26.03.48.24;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.26.03.44.07;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.26.03.35.40;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.26.03.29.42;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.23.01.13.20;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.21.04.45.40;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.36.40;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.09.18.05.24.07;	author lbutler;	state Exp;
branches;
next	14.13;

14.13
date	2006.09.03.15.16.20;	author lbutler;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.31.04.41.20;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.10;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.11.24.07.11.24;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.11.24.05.08.29;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.26;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.09.09.05.07.46;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.05.08.05.27.59;	author brlcad;	state Exp;
branches
	14.6.6.1;
next	14.5;

14.5
date	2005.05.01.23.15.12;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.30.12;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.23.18;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.06.39;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.10;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.24.04.10.51;	author morrison;	state Exp;
branches;
next	;

14.6.6.1
date	2005.11.13.13.46.10;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.28
log
@provide DEG2RAD and RAD2DEG constants for pi/180 and 180/pi; rename the new V3AE2DIR to V3DIR_FROM_AZEL to be more consistent with other vmath macros, similarly making first arg the dir instead of last; implement the complementary AZEL_FROM_V3DIR for setting an az/el from a direction vector as well (untested)
@
text
@/*                         V M A T H . H
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup mat */
/** @@{ */
/** @@file vmath.h
 *
 * @@brief vector/matrix math
 *
 *  This header file defines many commonly used 3D vector math macros,
 *  and operates on vect_t, point_t, mat_t, and quat_t objects.
 *
 *  Note that while many people in the computer graphics field use
 *  post-multiplication with row vectors (ie, vector * matrix * matrix ...)
 *  the BRL-CAD system uses the more traditional representation of
 *  column vectors (ie, ... matrix * matrix * vector).  (The matrices
 *  in these two representations are the transposes of each other). Therefore,
 *  when transforming a vector by a matrix, pre-multiplication is used, ie:
 *
 *		view_vec = model2view_mat * model_vec
 *
 *  Furthermore, additional transformations are multiplied on the left, ie:
 *
<tt> @@code
 *		vec'  =  T1 * vec
 *		vec'' =  T2 * T1 * vec  =  T2 * vec'
@@endcode </tt>
 *
 *  The most notable implication of this is the location of the
 *  "delta" (translation) values in the matrix, ie:
 *
 <tt> @@code
 *        x'     ( R0   R1   R2   Dx )      x
 *        y' =   ( R4   R5   R6   Dy )   *  y
 *        z'     ( R8   R9   R10  Dz )      z
 *        w'     (  0    0    0   1/s)      w
@@endcode </tt>
 *
 *  @@par Note -
 *  	vect_t objects are 3-tuples
 *@@n	hvect_t objects are 4-tuples
 *
 *  Most of these macros require that the result be in
 *  separate storage, distinct from the input parameters,
 *  except where noted.
 *
 *  When writing macros like this, it is very important that any
 *  variables which are declared within code blocks inside a macro
 *  start with an underscore.  This prevents any name conflicts with
 *  user-provided parameters.  For example:
 *	{ register double _f; stuff; }
 *
 *  @@author Michael John Muuss
 *
 *
 *  @@par Source
 *	The U. S. Army Research Laboratory
 * @@n	Aberdeen Proving Ground, Maryland  21005
 *
 *  Include Sequencing -
@@code
	#include <stdio.h>
	#include <math.h>
	#include "machine.h"	/_* For fastf_t definition on this machine *_/
	#include "vmath.h"
@@endcode
 *
 * @@par  Libraries Used
 *	-lm -lc
 */

#ifndef __VMATH_H__
#define __VMATH_H__

#include "common.h"

/* for sqrt(), sin(), cos(), rint(), etc */
#include <math.h>

/* for floating point tolerances and other math constants */
#include <float.h>

__BEGIN_DECLS

#ifndef M_PI
#  define M_E		2.7182818284590452354	/* e */
#  define M_LOG2E	1.4426950408889634074	/* log_2 e */
#  define M_LOG10E	0.43429448190325182765	/* log_10 e */
#  define M_LN2		0.69314718055994530942	/* log_e 2 */
#  define M_LN10	2.30258509299404568402	/* log_e 10 */
#  define M_PI		3.14159265358979323846	/* pi */
#  define M_PI_2	1.57079632679489661923	/* pi/2 */
#  define M_PI_4	0.78539816339744830962	/* pi/4 */
#  define M_1_PI	0.31830988618379067154	/* 1/pi */
#  define M_2_PI	0.63661977236758134308	/* 2/pi */
#  define M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
#  define M_SQRT2	1.41421356237309504880	/* sqrt(2) */
#  define M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */
#  define M_SQRT2_DIV2	0.70710678118654752440  /* 1/sqrt(2) */
#endif
#ifndef PI
#  define PI M_PI
#endif
#ifndef DEG2RAD
#  define DEG2RAD       0.017453292519943295769236907684 /* pi/180 */
#endif
#ifndef RAD2DEG
#  define RAD2DEG      57.295779513082320876798154814105 /* 180/pi */
#endif


/* minimum computation tolerances */
#ifdef vax
#  define VDIVIDE_TOL	( 1.0e-10 )
#  define VUNITIZE_TOL	( 1.0e-7 )
#else
#  ifdef DBL_EPSILON
#    define VDIVIDE_TOL		( DBL_EPSILON )
#  else
#    define VDIVIDE_TOL		( 1.0e-20 )
#  endif
#  ifdef FLT_EPSILON
#    define VUNITIZE_TOL	( FLT_EPSILON )
#  else
#    define VUNITIZE_TOL	( 1.0e-15 )
#  endif
#endif

/** @@brief # of fastf_t's per vect_t */
#define ELEMENTS_PER_VECT	3
#define ELEMENTS_PER_PT         3
/** @@brief # of fastf_t's per hvect_t */
#define HVECT_LEN		4
#define HPT_LEN			4

/** @@brief # of fastf_t's per plane_t */
#define ELEMENTS_PER_PLANE	4
#define ELEMENTS_PER_MAT	(ELEMENTS_PER_PLANE*ELEMENTS_PER_PLANE)

/*
 * Types for matrixes and vectors.
 */
/** @@brief 4x4 matrix */
typedef	fastf_t	mat_t[ELEMENTS_PER_MAT];
typedef	fastf_t	*matp_t;

/** @@brief 3-tuple vector */
typedef	fastf_t	vect_t[ELEMENTS_PER_VECT];
typedef	fastf_t	*vectp_t;

/** @@brief 3-tuple point */
typedef fastf_t	point_t[ELEMENTS_PER_PT];
typedef fastf_t	*pointp_t;

typedef fastf_t point2d_t[2];

/** @@brief 4-tuple vector */
typedef fastf_t hvect_t[HVECT_LEN];

/** @@brief 4-tuple point */
typedef fastf_t hpoint_t[HPT_LEN];

/** @@brief 4-element quaternion */
#define quat_t	hvect_t

/**
 * return truthfully whether a value is within some epsilon from zero
 */
#define NEAR_ZERO(val,epsilon)	( ((val) > -epsilon) && ((val) < epsilon) )

/**
 * clamp a value to a low/high number
 */
#define CLAMP(_v, _l, _h) if ((_v) < (_l)) _v = _l; else if ((_v) > (_h)) _v = _h

/**
 * @@brief
 *  Definition of a plane equation
 *
 *  A plane is defined by a unit-length outward pointing normal vector (N),
 *  and the perpendicular (shortest) distance from the origin to the plane
 *  (in element N[3]).
 *
 *  The plane consists of all points P=(x,y,z) such that
 *@@n	VDOT(P,N) - N[3] == 0
 *@@n  that is,
 *@@n	N[X]*x + N[Y]*y + N[Z]*z - N[3] == 0
 *
 *  The inside of the halfspace bounded by the plane
 *  consists of all points P such that
 *@@n	VDOT(P,N) - N[3] <= 0
 *
 *  A ray with direction D is classified w.r.t. the plane by
 *
 *@@n	VDOT(D,N) < 0	ray enters halfspace defined by plane
 *@@n	VDOT(D,N) == 0	ray is parallel to plane
 *@@n	VDOT(D,N) > 0	ray exits halfspace defined by plane
 */
typedef fastf_t	plane_t[ELEMENTS_PER_PLANE];

/** @@brief Compute distance from a point to a plane */
#define DIST_PT_PLANE(_pt, _pl) (VDOT(_pt, _pl) - (_pl)[H])

/** @@brief Compute distance between two points */
#define DIST_PT_PT(a,b)		sqrt( \
	((a)[X]-(b)[X])*((a)[X]-(b)[X]) + \
	((a)[Y]-(b)[Y])*((a)[Y]-(b)[Y]) + \
	((a)[Z]-(b)[Z])*((a)[Z]-(b)[Z]) )

/* Element names in homogeneous vector (4-tuple) */
#define	X	0
#define	Y	1
#define Z	2
#define H	3
#define W	H

/* Locations of deltas in 4x4 Homogenous Transform matrix */
#define MDX	3
#define MDY	7
#define MDZ	11

/** @@brief set translation values of 4x4 matrix with x, y, z values */
#define MAT_DELTAS(_m,_x,_y,_z)	{ \
			(_m)[MDX] = (_x); \
			(_m)[MDY] = (_y); \
			(_m)[MDZ] = (_z); }

/** @@brief set translation values of 4x4 matrix from a vector */
#define MAT_DELTAS_VEC(_m,_v)	\
			MAT_DELTAS(_m, (_v)[X], (_v)[Y], (_v)[Z] )

/** @@brief set translation values of 4x4 matrix from a reversed vector */
#define MAT_DELTAS_VEC_NEG(_m,_v)	\
			MAT_DELTAS(_m,-(_v)[X],-(_v)[Y],-(_v)[Z] )

/** @@brief get translation values of 4x4 matrix to a vector */
#define MAT_DELTAS_GET(_v,_m) { \
			(_v)[X] = (_m)[MDX]; \
			(_v)[Y] = (_m)[MDY]; \
			(_v)[Z] = (_m)[MDZ]; }

/** @@brief get translation values of 4x4 matrix to a vector, reversed */
#define MAT_DELTAS_GET_NEG(_v,_m) { \
			(_v)[X] = -(_m)[MDX]; \
			(_v)[Y] = -(_m)[MDY]; \
			(_v)[Z] = -(_m)[MDZ]; }

/** @@brief increment translation elements in a 4x4 matrix with x, y, z values */
#define MAT_DELTAS_ADD(_m,_x,_y,_z) { \
			(_m)[MDX] += (_x); \
			(_m)[MDY] += (_y); \
			(_m)[MDZ] += (_z); }

/** @@brief increment translation elements in a 4x4 matrix from a vector */
#define MAT_DELTAS_ADD_VEC(_m,_v) { \
			(_m)[MDX] += (_v)[X]; \
			(_m)[MDY] += (_v)[Y]; \
			(_m)[MDZ] += (_v)[Z]; }

/** @@brief decrement translation elements in a 4x4 matrix with x, y, z values */
#define MAT_DELTAS_SUB(_m,_x,_y,_z) { \
			(_m)[MDX] -= (_x); \
			(_m)[MDY] -= (_y); \
			(_m)[MDZ] -= (_z); }

/** @@brief decrement translation elements in a 4x4 matrix from a vector */
#define MAT_DELTAS_SUB_VEC(_m,_v) { \
			(_m)[MDX] -= (_v)[X]; \
			(_m)[MDY] -= (_v)[Y]; \
			(_m)[MDZ] -= (_v)[Z]; }

/** @@brief decrement translation elements in a 4x4 matrix with x, y, z values */
#define MAT_DELTAS_MUL(_m,_x,_y,_z) { \
			(_m)[MDX] *= (_x); \
			(_m)[MDY] *= (_y); \
			(_m)[MDZ] *= (_z); }

/** @@brief decrement translation elements in a 4x4 matrix from a vector */
#define MAT_DELTAS_MUL_VEC(_m,_v) { \
			(_m)[MDX] *= (_v)[X]; \
			(_m)[MDY] *= (_v)[Y]; \
			(_m)[MDZ] *= (_v)[Z]; }


/* Locations of scaling values in 4x4 Homogenous Transform matrix */
#define MSX	0
#define MSY	5
#define MSZ	10
#define MSA	15

/** @@brief set scale of 4x4 matrix from xyz */
#define MAT_SCALE(_m, _x, _y, _z) { \
	(_m)[MSX] = _x; \
	(_m)[MSY] = _y; \
	(_m)[MSZ] = _z; }

/** @@brief set scale of 4x4 matrix from vector */
#define MAT_SCALE_VEC(_m, _v) {\
	(_m)[MSX] = (_v)[X]; \
	(_m)[MSY] = (_v)[Y]; \
	(_m)[MSZ] = (_v)[Z]; }

/** @@brief set uniform scale of 4x4 matrix from scalar */
#define MAT_SCALE_ALL(_m, _s) (_m)[MSA] = (_s)

/** @@brief add to scaling elements in a 4x4 matrix from xyz */
#define MAT_SCALE_ADD(_m, _x, _y, _z) { \
	(_m)[MSX] += _x; \
	(_m)[MSY] += _y; \
	(_m)[MSZ] += _z; }

/** @@brief add to scaling elements in a 4x4 matrix from vector */
#define MAT_SCALE_ADD_VEC(_m, _v) {\
	(_m)[MSX] += (_v)[X]; \
	(_m)[MSY] += (_v)[Y]; \
	(_m)[MSZ] += (_v)[Z]; }

/** @@brief subtract from scaling elements in a 4x4 matrix from xyz */
#define MAT_SCALE_SUB(_m, _x, _y, _z) { \
	(_m)[MSX] -= _x; \
	(_m)[MSY] -= _y; \
	(_m)[MSZ] -= _z; }

/** @@brief subtract from scaling elements in a 4x4 matrix from vector */
#define MAT_SCALE_SUB_VEC(_m, _v) {\
	(_m)[MSX] -= (_v)[X]; \
	(_m)[MSY] -= (_v)[Y]; \
	(_m)[MSZ] -= (_v)[Z]; }

/** @@brief multipy scaling elements in a 4x4 matrix from xyz */
#define MAT_SCALE_MUL(_m, _x, _y, _z) { \
	(_m)[MSX] *= _x; \
	(_m)[MSY] *= _y; \
	(_m)[MSZ] *= _z; }

/** @@brief multiply scaling elements in a 4x4 matrix from vector */
#define MAT_SCALE_MUL_VEC(_m, _v) {\
	(_m)[MSX] *= (_v)[X]; \
	(_m)[MSY] *= (_v)[Y]; \
	(_m)[MSZ] *= (_v)[Z]; }


/* Macro versions of librt/mat.c functions, for when speed really matters */

/** @@brief zero a matrix */
#define MAT_ZERO(m)	{ \
	(m)[0] = (m)[1] = (m)[2] = (m)[3] = \
	(m)[4] = (m)[5] = (m)[6] = (m)[7] = \
	(m)[8] = (m)[9] = (m)[10] = (m)[11] = \
	(m)[12] = (m)[13] = (m)[14] = (m)[15] = 0.0;}

/* # define MAT_ZERO(m)	{\
	register int _j; \
	for(_j=0; _j<16; _j++) (m)[_j]=0.0; }
  */

/** @@brief set matrix to identity */
#define MAT_IDN(m)	{\
	(m)[1] = (m)[2] = (m)[3] = (m)[4] =\
	(m)[6] = (m)[7] = (m)[8] = (m)[9] = \
	(m)[11] = (m)[12] = (m)[13] = (m)[14] = 0.0;\
	(m)[0] = (m)[5] = (m)[10] = (m)[15] = 1.0;}

/* #define MAT_IDN(m)	{\
	int _j;	for(_j=0;_j<16;_j++) (m)[_j]=0.0;\
	(m)[0] = (m)[5] = (m)[10] = (m)[15] = 1.0;}
  */

/** @@brief copy a matrix */
#define MAT_COPY( d, s )	{ \
	(d)[0] = (s)[0];\
	(d)[1] = (s)[1];\
	(d)[2] = (s)[2];\
	(d)[3] = (s)[3];\
	(d)[4] = (s)[4];\
	(d)[5] = (s)[5];\
	(d)[6] = (s)[6];\
	(d)[7] = (s)[7];\
	(d)[8] = (s)[8];\
	(d)[9] = (s)[9];\
	(d)[10] = (s)[10];\
	(d)[11] = (s)[11];\
	(d)[12] = (s)[12];\
	(d)[13] = (s)[13];\
	(d)[14] = (s)[14];\
	(d)[15] = (s)[15]; }

/* #define MAT_COPY(o,m)   VMOVEN(o,m,16)  */

/** @@brief Set vector at `a' to have coordinates `b', `c', `d' */
#define VSET(a,b,c,d)	{ \
			(a)[X] = (b);\
			(a)[Y] = (c);\
			(a)[Z] = (d); }

/** @@brief Set all elements of vector to same scalar value */
#define VSETALL(a,s)	{ (a)[X] = (a)[Y] = (a)[Z] = (s); }

/** @@brief Set all elements of N-vector to same scalar value */
#define VSETALLN(v,s,n)  {\
	register int _j;\
	for (_j=0; _j<n; _j++) v[_j]=(s);}

/** @@brief Transfer vector at `b' to vector at `a' */
#define VMOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];\
			(a)[Z] = (b)[Z]; }

/** @@brief Transfer vector of length `n' at `b' to vector at `a' */
#define VMOVEN(a,b,n) \
	{ register int _vmove; \
	for(_vmove = 0; _vmove < (n); _vmove++) \
		(a)[_vmove] = (b)[_vmove]; \
	}

/** @@brief Move a homogeneous 4-tuple */
#define HMOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];\
			(a)[Z] = (b)[Z];\
			(a)[W] = (b)[W]; }

/** @@brief move a 2D vector.
 * This naming convention seems better than the VMOVE_2D version below
*/
#define V2MOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y]; }

/** @@brief Reverse the direction of vector b and store it in a */
#define VREVERSE(a,b)	{ \
			(a)[X] = -(b)[X]; \
			(a)[Y] = -(b)[Y]; \
			(a)[Z] = -(b)[Z]; }

/** @@brief Same as VREVERSE, but for a 4-tuple.  Also useful on plane_t objects */
#define HREVERSE(a,b)	{ \
			(a)[X] = -(b)[X]; \
			(a)[Y] = -(b)[Y]; \
			(a)[Z] = -(b)[Z]; \
			(a)[W] = -(b)[W]; }

/** @@brief Add vectors at `b' and `c', store result at `a' */
#ifdef SHORT_VECTORS
#define VADD2(a,b,c) VADD2N(a,b,c, 3)
#else
#define VADD2(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];\
			(a)[Z] = (b)[Z] + (c)[Z]; }
#endif /* SHORT_VECTORS */

/** @@brief Add vectors of length `n' at `b' and `c', store result at `a' */
#define VADD2N(a,b,c,n) \
	{ register int _vadd2; \
	for(_vadd2 = 0; _vadd2 < (n); _vadd2++) \
		(a)[_vadd2] = (b)[_vadd2] + (c)[_vadd2]; \
	}

#define V2ADD2(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];}

/** @@brief Subtract vector at `c' from vector at `b', store result at `a' */
#ifdef SHORT_VECTORS
#define VSUB2(a,b,c) 	VSUB2N(a,b,c, 3)
#else
#define VSUB2(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];\
			(a)[Z] = (b)[Z] - (c)[Z]; }
#endif /* SHORT_VECTORS */

/** @@brief Subtract `n' length vector at `c' from vector at `b', store result at `a' */
#define VSUB2N(a,b,c,n) \
	{ register int _vsub2; \
	for(_vsub2 = 0; _vsub2 < (n); _vsub2++) \
		(a)[_vsub2] = (b)[_vsub2] - (c)[_vsub2]; \
	}

#define V2SUB2(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];}

/** @@brief Vectors:  A = B - C - D */
#ifdef SHORT_VECTORS
#define VSUB3(a,b,c,d) VSUB3(a,b,c,d, 3)
#else
#define VSUB3(a,b,c,d)	{ \
			(a)[X] = (b)[X] - (c)[X] - (d)[X];\
			(a)[Y] = (b)[Y] - (c)[Y] - (d)[Y];\
			(a)[Z] = (b)[Z] - (c)[Z] - (d)[Z]; }
#endif /* SHORT_VECTORS */

/** @@brief Vectors:  A = B - C - D for vectors of length `n' */
#define VSUB3N(a,b,c,d,n) \
	{ register int _vsub3; \
	for(_vsub3 = 0; _vsub3 < (n); _vsub3++) \
		(a)[_vsub3] = (b)[_vsub3] - (c)[_vsub3] - (d)[_vsub3]; \
	}

/** @@brief Add 3 vectors at `b', `c', and `d', store result at `a' */
#ifdef SHORT_VECTORS
#define VADD3(a,b,c,d) VADD3N(a,b,c,d, 3)
#else
#define VADD3(a,b,c,d)	{ \
			(a)[X] = (b)[X] + (c)[X] + (d)[X];\
			(a)[Y] = (b)[Y] + (c)[Y] + (d)[Y];\
			(a)[Z] = (b)[Z] + (c)[Z] + (d)[Z]; }
#endif /* SHORT_VECTORS */

/** @@brief Add 3 vectors of length `n' at `b', `c', and `d', store result at `a' */
#define VADD3N(a,b,c,d,n) \
	{ register int _vadd3; \
	for(_vadd3 = 0; _vadd3 < (n); _vadd3++) \
		(a)[_vadd3] = (b)[_vadd3] + (c)[_vadd3] + (d)[_vadd3]; \
	}

/** @@brief Add 4 vectors at `b', `c', `d', and `e', store result at `a' */
#ifdef SHORT_VECTORS
#define VADD4(a,b,c,d,e) VADD4N(a,b,c,d,e, 3)
#else
#define VADD4(a,b,c,d,e) { \
			(a)[X] = (b)[X] + (c)[X] + (d)[X] + (e)[X];\
			(a)[Y] = (b)[Y] + (c)[Y] + (d)[Y] + (e)[Y];\
			(a)[Z] = (b)[Z] + (c)[Z] + (d)[Z] + (e)[Z]; }
#endif /* SHORT_VECTORS */

/** @@brief Add 4 `n' length vectors at `b', `c', `d', and `e', store result at `a' */
#define VADD4N(a,b,c,d,e,n) \
	{ register int _vadd4; \
	for(_vadd4 = 0; _vadd4 < (n); _vadd4++) \
		(a)[_vadd4] = (b)[_vadd4] + (c)[_vadd4] + (d)[_vadd4] + (e)[_vadd4];\
	}

/** @@brief Scale vector at `b' by scalar `c', store result at `a' */
#ifdef SHORT_VECTORS
#define VSCALE(a,b,c) VSCALEN(a,b,c, 3)
#else
#define VSCALE(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c);\
			(a)[Z] = (b)[Z] * (c); }
#endif /* SHORT_VECTORS */

#define HSCALE(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c);\
			(a)[Z] = (b)[Z] * (c);\
			(a)[W] = (b)[W] * (c); }

/** @@brief Scale vector of length `n' at `b' by scalar `c', store result at `a' */
#define VSCALEN(a,b,c,n) \
	{ register int _vscale; \
	for(_vscale = 0; _vscale < (n); _vscale++) \
		(a)[_vscale] = (b)[_vscale] * (c); \
	}

#define V2SCALE(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c); }

/** @@brief Normalize vector `a' to be a unit vector */
#ifdef SHORT_VECTORS
#define VUNITIZE(a) { \
	register double _f = MAGSQ(a); \
	register int _vunitize; \
	if ( ! NEAR_ZERO( _f-1.0, VUNITIZE_TOL ) ) { \
		_f = sqrt( _f ); \
		if( _f < VDIVIDE_TOL ) { VSETALL( (a), 0.0 ); } else { \
			_f = 1.0/_f; \
			for(_vunitize = 0; _vunitize < 3; _vunitize++) \
				(a)[_vunitize] *= _f; \
		} \
	} \
}
#else
#define VUNITIZE(a)	{ \
	register double _f = MAGSQ(a); \
	if ( ! NEAR_ZERO( _f-1.0, VUNITIZE_TOL ) ) { \
		_f = sqrt( _f ); \
		if( _f < VDIVIDE_TOL ) { VSETALL( (a), 0.0 ); } else { \
			_f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; \
		} \
	} \
}
#endif /* SHORT_VECTORS */

/** @@brief If vector magnitude is too small, return an error code */
#define VUNITIZE_RET(a,ret)	{ \
			register double _f; _f = MAGNITUDE(a); \
			if( _f < VDIVIDE_TOL ) return(ret); \
			_f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; }

/** @@brief
 *  Find the sum of two points, and scale the result.
 *  Often used to find the midpoint.
 */
#ifdef SHORT_VECTORS
#define VADD2SCALE( o, a, b, s )	VADD2SCALEN( o, a, b, s, 3 )
#else
#define VADD2SCALE( o, a, b, s )	{ \
					(o)[X] = ((a)[X] + (b)[X]) * (s); \
					(o)[Y] = ((a)[Y] + (b)[Y]) * (s); \
					(o)[Z] = ((a)[Z] + (b)[Z]) * (s); }
#endif

#define VADD2SCALEN( o, a, b, n ) \
	{ register int _vadd2scale; \
	for( _vadd2scale = 0; _vadd2scale < (n); _vadd2scale++ ) \
		(o)[_vadd2scale] = ((a)[_vadd2scale] + (b)[_vadd2scale]) * (s); \
	}

/** @@brief
 *  Find the difference between two points, and scale result.
 *  Often used to compute bounding sphere radius given rpp points.
 */
#ifdef SHORT_VECTORS
#define VSUB2SCALE( o, a, b, s )	VSUB2SCALEN( o, a, b, s, 3 )
#else
#define VSUB2SCALE( o, a, b, s )	{ \
					(o)[X] = ((a)[X] - (b)[X]) * (s); \
					(o)[Y] = ((a)[Y] - (b)[Y]) * (s); \
					(o)[Z] = ((a)[Z] - (b)[Z]) * (s); }
#endif

#define VSUB2SCALEN( o, a, b, n ) \
	{ register int _vsub2scale; \
	for( _vsub2scale = 0; _vsub2scale < (n); _vsub2scale++ ) \
		(o)[_vsub2scale] = ((a)[_vsub2scale] - (b)[_vsub2scale]) * (s); \
	}


/** @@brief
 *  Combine together several vectors, scaled by a scalar
 */
#ifdef SHORT_VECTORS
#define VCOMB3(o, a,b, c,d, e,f)	VCOMB3N(o, a,b, c,d, e,f, 3)
#else
#define VCOMB3(o, a,b, c,d, e,f)	{\
	(o)[X] = (a) * (b)[X] + (c) * (d)[X] + (e) * (f)[X];\
	(o)[Y] = (a) * (b)[Y] + (c) * (d)[Y] + (e) * (f)[Y];\
	(o)[Z] = (a) * (b)[Z] + (c) * (d)[Z] + (e) * (f)[Z];}
#endif /* SHORT_VECTORS */

#define VCOMB3N(o, a,b, c,d, e,f, n)	{\
	{ register int _vcomb3; \
	for(_vcomb3 = 0; _vcomb3 < (n); _vcomb3++) \
		(o)[_vcomb3] = (a) * (b)[_vcomb3] + (c) * (d)[_vcomb3] + (e) * (f)[_vcomb3]; \
	} }

#ifdef SHORT_VECTORS
#define VCOMB2(o, a,b, c,d)	VCOMB2N(o, a,b, c,d, 3)
#else
#define VCOMB2(o, a,b, c,d)	{\
	(o)[X] = (a) * (b)[X] + (c) * (d)[X];\
	(o)[Y] = (a) * (b)[Y] + (c) * (d)[Y];\
	(o)[Z] = (a) * (b)[Z] + (c) * (d)[Z];}
#endif /* SHORT_VECTORS */

#define VCOMB2N(o, a,b, c,d, n)	{\
	{ register int _vcomb2; \
	for(_vcomb2 = 0; _vcomb2 < (n); _vcomb2++) \
		(o)[_vcomb2] = (a) * (b)[_vcomb2] + (c) * (d)[_vcomb2]; \
	} }

#define VJOIN4(a,b,c,d,e,f,g,h,i,j)	{ \
	(a)[X] = (b)[X] + (c)*(d)[X] + (e)*(f)[X] + (g)*(h)[X] + (i)*(j)[X];\
	(a)[Y] = (b)[Y] + (c)*(d)[Y] + (e)*(f)[Y] + (g)*(h)[Y] + (i)*(j)[Y];\
	(a)[Z] = (b)[Z] + (c)*(d)[Z] + (e)*(f)[Z] + (g)*(h)[Z] + (i)*(j)[Z]; }

#define VJOIN3(a,b,c,d,e,f,g,h)		{ \
	(a)[X] = (b)[X] + (c)*(d)[X] + (e)*(f)[X] + (g)*(h)[X];\
	(a)[Y] = (b)[Y] + (c)*(d)[Y] + (e)*(f)[Y] + (g)*(h)[Y];\
	(a)[Z] = (b)[Z] + (c)*(d)[Z] + (e)*(f)[Z] + (g)*(h)[Z]; }

/** @@brief Compose vector at `a' of:
 *	Vector at `b' plus
 *	scalar `c' times vector at `d' plus
 *	scalar `e' times vector at `f'
 */
#ifdef SHORT_VECTORS
#define VJOIN2(a,b,c,d,e,f)	VJOIN2N(a,b,c,d,e,f,3)
#else
#define VJOIN2(a,b,c,d,e,f)	{ \
	(a)[X] = (b)[X] + (c) * (d)[X] + (e) * (f)[X];\
	(a)[Y] = (b)[Y] + (c) * (d)[Y] + (e) * (f)[Y];\
	(a)[Z] = (b)[Z] + (c) * (d)[Z] + (e) * (f)[Z]; }
#endif /* SHORT_VECTORS */

#define VJOIN2N(a,b,c,d,e,f,n)	\
	{ register int _vjoin2; \
	for(_vjoin2 = 0; _vjoin2 < (n); _vjoin2++) \
		(a)[_vjoin2] = (b)[_vjoin2] + (c) * (d)[_vjoin2] + (e) * (f)[_vjoin2]; \
	}

#ifdef SHORT_VECTORS
#define VJOIN1(a,b,c,d)		VJOIN1N(a,b,c,d,3)
#else
#define VJOIN1(a,b,c,d) 	{ \
	(a)[X] = (b)[X] + (c) * (d)[X];\
	(a)[Y] = (b)[Y] + (c) * (d)[Y];\
	(a)[Z] = (b)[Z] + (c) * (d)[Z]; }
#endif /* SHORT_VECTORS */

#define VJOIN1N(a,b,c,d,n) \
	{ register int _vjoin1; \
	for(_vjoin1 = 0; _vjoin1 < (n); _vjoin1++) \
		(a)[_vjoin1] = (b)[_vjoin1] + (c) * (d)[_vjoin1]; \
	}

#define HJOIN1(a,b,c,d)	{ \
			(a)[X] = (b)[X] + (c) * (d)[X]; \
			(a)[Y] = (b)[Y] + (c) * (d)[Y]; \
			(a)[Z] = (b)[Z] + (c) * (d)[Z]; \
			(a)[W] = (b)[W] + (c) * (d)[W]; }

#define V2JOIN1(a,b,c,d) 	{ \
			(a)[X] = (b)[X] + (c) * (d)[X];\
			(a)[Y] = (b)[Y] + (c) * (d)[Y]; }

/** @@brief
 *  Blend into vector `a'
 *	scalar `b' times vector at `c' plus
 *	scalar `d' times vector at `e'
 */
#ifdef SHORT_VECTORS
#define VBLEND2(a,b,c,d,e)	VBLEND2N(a,b,c,d,e,3)
#else
#define VBLEND2(a,b,c,d,e)	{ \
	(a)[X] = (b) * (c)[X] + (d) * (e)[X];\
	(a)[Y] = (b) * (c)[Y] + (d) * (e)[Y];\
	(a)[Z] = (b) * (c)[Z] + (d) * (e)[Z]; }
#endif /* SHORT_VECTORS */

#define VBLEND2N(a,b,c,d,e,n)	\
	{ register int _vblend2; \
	for(_vblend2 = 0; _vblend2 < (n); _vblend2++) \
		(a)[_vblend2] = (b) * (c)[_vblend2] + (d) * (e)[_vblend2]; \
	}

/** @@brief Return scalar magnitude squared of vector at `a' */
#define MAGSQ(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] + (a)[Z]*(a)[Z] )
#define MAG2SQ(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] )

/** @@brief Return scalar magnitude of vector at `a' */
#define MAGNITUDE(a)	sqrt( MAGSQ( a ) )

/** @@brief
 *  Store cross product of vectors at `b' and `c' in vector at `a'.
 *  Note that the "right hand rule" applies:
 *  If closing your right hand goes from `b' to `c', then your
 *  thumb points in the direction of the cross product.
 *
 *  If the angle from `b' to `c' goes clockwise, then
 *  the result vector points "into" the plane (inward normal).
 *  Example:  b=(0,1,0), c=(1,0,0), then bXc=(0,0,-1).
 *
 *  If the angle from `b' to `c' goes counter-clockwise, then
 *  the result vector points "out" of the plane.
 *  This outward pointing normal is the BRL convention.
 */
#define VCROSS(a,b,c)	{ \
			(a)[X] = (b)[Y] * (c)[Z] - (b)[Z] * (c)[Y];\
			(a)[Y] = (b)[Z] * (c)[X] - (b)[X] * (c)[Z];\
			(a)[Z] = (b)[X] * (c)[Y] - (b)[Y] * (c)[X]; }

/** @@brief Compute dot product of vectors at `a' and `b' */
#define VDOT(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] + (a)[Z]*(b)[Z] )

#define V2DOT(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] )

/** @@brief Subtract two points to make a vector, dot with another vector */
#define VSUB2DOT(_pt2, _pt, _vec)	( \
	((_pt2)[X] - (_pt)[X]) * (_vec)[X] + \
	((_pt2)[Y] - (_pt)[Y]) * (_vec)[Y] + \
	((_pt2)[Z] - (_pt)[Z]) * (_vec)[Z] )

/** @@brief Turn a vector into comma-separated list of elements, for subroutine args */
#define V2ARGS(a)	(a)[X], (a)[Y]
#define V3ARGS(a)	(a)[X], (a)[Y], (a)[Z]
#define V4ARGS(a)	(a)[X], (a)[Y], (a)[Z], (a)[W]

/** @@brief integer clamped versions of the previous arg macros */
#define V2INTCLAMPARGS(a)	INTCLAMP((a)[X]), INTCLAMP((a)[Y])
/** @@brief integer clamped versions of the previous arg macros */
#define V3INTCLAMPARGS(a)	INTCLAMP((a)[X]), INTCLAMP((a)[Y]), INTCLAMP((a)[Z])
/** @@brief integer clamped versions of the previous arg macros */
#define V4INTCLAMPARGS(a)	INTCLAMP((a)[X]), INTCLAMP((a)[Y]), INTCLAMP((a)[Z]), INTCLAMP((a)[W])

/** @@brief Print vector name and components on stderr */
#define V2PRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g)\n", a, V2ARGS(b) );
#define VPRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g, %g)\n", a, V3ARGS(b) );
#define HPRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g, %g, %g)\n", a, V4ARGS(b) );

/** @@brief integer clamped versions of the previous print macros */
#define V2INTCLAMPPRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g)\n", a, V2INTCLAMPARGS(b) );
#define VINTCLAMPPRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g, %g)\n", a, V3INTCLAMPARGS(b) );
#define HINTCLAMPPRINT(a,b)	\
	(void)fprintf(stderr,"%s (%g, %g, %g, %g)\n", a, V4INTCLAMPARGS(b) );

#ifdef __cplusplus
#define CPP_V3PRINT( _os, _title, _p )	(_os) << (_title) << "=(" << \
	(_p)[X] << ", " << (_p)[Y] << ")\n";
#define CPP_VPRINT( _os, _title, _p )	(_os) << (_title) << "=(" << \
	(_p)[X] << ", " << (_p)[Y] << ", " << (_p)[Z] << ")\n";
#define CPP_HPRINT( _os, _title, _p )	(_os) << (_title) << "=(" << \
	(_p)[X] << ", " << (_p)[Y] << ", " << (_p)[Z] << "," << (_p)[W]<< ")\n";
#endif

/**
 * if a value is within computation tolerance of an integer, clamp the
 * value to that integer.  XXX - should use VDIVIDE_TOL here, but
 * cannot yet until floats are replaced universally with fastf_t's
 * since their epsilon is considerably less than that of a double.
 */
#define INTCLAMP(_a)	( NEAR_ZERO((_a) - rint(_a), VUNITIZE_TOL) ? rint(_a) : (_a) )

/** @@brief Vector element multiplication.  Really: diagonal matrix X vect */
#ifdef SHORT_VECTORS
#define VELMUL(a,b,c) \
	{ register int _velmul; \
	for(_velmul = 0; _velmul < 3; _velmul++) \
		(a)[_velmul] = (b)[_velmul] * (c)[_velmul]; \
	}
#else
#define VELMUL(a,b,c) 	{ \
	(a)[X] = (b)[X] * (c)[X];\
	(a)[Y] = (b)[Y] * (c)[Y];\
	(a)[Z] = (b)[Z] * (c)[Z]; }
#endif /* SHORT_VECTORS */

#ifdef SHORT_VECTORS
#define VELMUL3(a,b,c,d) \
	{ register int _velmul; \
	for(_velmul = 0; _velmul < 3; _velmul++) \
		(a)[_velmul] = (b)[_velmul] * (c)[_velmul] * (d)[_velmul]; \
	}
#else
#define VELMUL3(a,b,c,d) 	{ \
	(a)[X] = (b)[X] * (c)[X] * (d)[X];\
	(a)[Y] = (b)[Y] * (c)[Y] * (d)[Y];\
	(a)[Z] = (b)[Z] * (c)[Z] * (d)[Z]; }
#endif /* SHORT_VECTORS */

/** @@brief Similar to VELMUL */
#define VELDIV(a,b,c)	{ \
	(a)[0] = (b)[0] / (c)[0];\
	(a)[1] = (b)[1] / (c)[1];\
	(a)[2] = (b)[2] / (c)[2]; }

/** @@brief Given a direction vector, compute the inverses of each element.
 * When division by zero would have occured, mark inverse as INFINITY. */
#define VINVDIR( _inv, _dir )	{ \
	if( (_dir)[X] < -SQRT_SMALL_FASTF || (_dir)[X] > SQRT_SMALL_FASTF )  { \
		(_inv)[X]=1.0/(_dir)[X]; \
	} else { \
		(_dir)[X] = 0.0; \
		(_inv)[X] = INFINITY; \
	} \
	if( (_dir)[Y] < -SQRT_SMALL_FASTF || (_dir)[Y] > SQRT_SMALL_FASTF )  { \
		(_inv)[Y]=1.0/(_dir)[Y]; \
	} else { \
		(_dir)[Y] = 0.0; \
		(_inv)[Y] = INFINITY; \
	} \
	if( (_dir)[Z] < -SQRT_SMALL_FASTF || (_dir)[Z] > SQRT_SMALL_FASTF )  { \
		(_inv)[Z]=1.0/(_dir)[Z]; \
	} else { \
		(_dir)[Z] = 0.0; \
		(_inv)[Z] = INFINITY; \
	} \
    }

/** @@brief Apply the 3x3 part of a mat_t to a 3-tuple.
 * This rotates a vector without scaling it (changing its length)
 */
#ifdef SHORT_VECTORS
#define MAT3X3VEC(o,mat,vec) \
	{ register int _m3x3v; \
	for(_m3x3v = 0; _m3x3v < 3; _m3x3v++) \
		(o)[_m3x3v] = (mat)[4*_m3x3v+0]*(vec)[X] + \
			  (mat)[4*_m3x3v+1]*(vec)[Y] + \
			  (mat)[4*_m3x3v+2]*(vec)[Z]; \
	}
#else
#define MAT3X3VEC(o,mat,vec) 	{ \
	(o)[X] = (mat)[X]*(vec)[X]+(mat)[Y]*(vec)[Y] + (mat)[ 2]*(vec)[Z]; \
	(o)[Y] = (mat)[4]*(vec)[X]+(mat)[5]*(vec)[Y] + (mat)[ 6]*(vec)[Z]; \
	(o)[Z] = (mat)[8]*(vec)[X]+(mat)[9]*(vec)[Y] + (mat)[10]*(vec)[Z]; }
#endif /* SHORT_VECTORS */

/** @@brief Multiply a 3-tuple by the 3x3 part of a mat_t. */
#ifdef SHORT_VECTORS
#define VEC3X3MAT(o,i,m) \
	{ register int _v3x3m; \
	for(_v3x3m = 0; _v3x3m < 3; _v3x3m++) \
		(o)[_v3x3m] = (i)[X]*(m)[_v3x3m] + \
			(i)[Y]*(m)[_v3x3m+4] + \
			(i)[Z]*(m)[_v3x3m+8]; \
	}
#else
#define VEC3X3MAT(o,i,m) 	{ \
	(o)[X] = (i)[X]*(m)[X] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8]; \
	(o)[Y] = (i)[X]*(m)[1] + (i)[Y]*(m)[5] + (i)[Z]*(m)[9]; \
	(o)[Z] = (i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10]; }
#endif /* SHORT_VECTORS */

/** @@brief Apply the 3x3 part of a mat_t to a 2-tuple (Z part=0). */
#ifdef SHORT_VECTORS
#define MAT3X2VEC(o,mat,vec) \
	{ register int _m3x2v; \
	for(_m3x2v = 0; _m3x2v < 3; _m3x2v++) \
		(o)[_m3x2v] = (mat)[4*_m3x2v]*(vec)[X] + \
			(mat)[4*_m3x2v+1]*(vec)[Y]; \
	}
#else
#define MAT3X2VEC(o,mat,vec) 	{ \
	(o)[X] = (mat)[0]*(vec)[X] + (mat)[Y]*(vec)[Y]; \
	(o)[Y] = (mat)[4]*(vec)[X] + (mat)[5]*(vec)[Y]; \
	(o)[Z] = (mat)[8]*(vec)[X] + (mat)[9]*(vec)[Y]; }
#endif /* SHORT_VECTORS */

/** @@brief Multiply a 2-tuple (Z=0) by the 3x3 part of a mat_t. */
#ifdef SHORT_VECTORS
#define VEC2X3MAT(o,i,m) \
	{ register int _v2x3m; \
	for(_v2x3m = 0; _v2x3m < 3; _v2x3m++) \
		(o)[_v2x3m] = (i)[X]*(m)[_v2x3m] + (i)[Y]*(m)[2*_v2x3m]; \
	}
#else
#define VEC2X3MAT(o,i,m) 	{ \
	(o)[X] = (i)[X]*(m)[0] + (i)[Y]*(m)[4]; \
	(o)[Y] = (i)[X]*(m)[1] + (i)[Y]*(m)[5]; \
	(o)[Z] = (i)[X]*(m)[2] + (i)[Y]*(m)[6]; }
#endif /* SHORT_VECTORS */

/** @@brief Apply a 4x4 matrix to a 3-tuple which is an absolute Point in space */
#ifdef SHORT_VECTORS
#define MAT4X3PNT(o,m,i) \
	{ register double _f; \
	register int _i_m4x3p, _j_m4x3p; \
	_f = 0.0; \
	for(_j_m4x3p = 0; _j_m4x3p < 3; _j_m4x3p++)  \
		_f += (m)[_j_m4x3p+12] * (i)[_j_m4x3p]; \
	_f = 1.0/(_f + (m)[15]); \
	for(_i_m4x3p = 0; _i_m4x3p < 3; _i_m4x3p++) \
		(o)[_i_m4x3p] = 0.0; \
	for(_i_m4x3p = 0; _i_m4x3p < 3; _i_m4x3p++)  { \
		for(_j_m4x3p = 0; _j_m4x3p < 3; _j_m4x3p++) \
			(o)[_i_m4x3p] += (m)[_j_m4x3p+4*_i_m4x3p] * (i)[_j_m4x3p]; \
	} \
	for(_i_m4x3p = 0; _i_m4x3p < 3; _i_m4x3p++)  { \
		(o)[_i_m4x3p] = ((o)[_i_m4x3p] + (m)[4*_i_m4x3p+3]) * _f; \
	} }
#else
#define MAT4X3PNT(o,m,i) \
	{ register double _f; \
	_f = 1.0/((m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]);\
	(o)[X]=((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z] + (m)[3]) * _f;\
	(o)[Y]=((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z] + (m)[7]) * _f;\
	(o)[Z]=((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11])* _f;}
#endif /* SHORT_VECTORS */

/** @@brief Multiply an Absolute 3-Point by a full 4x4 matrix. */
#define PNT3X4MAT(o,i,m) \
	{ register double _f; \
	_f = 1.0/((i)[X]*(m)[3] + (i)[Y]*(m)[7] + (i)[Z]*(m)[11] + (m)[15]);\
	(o)[X]=((i)[X]*(m)[0] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8] + (m)[12]) * _f;\
	(o)[Y]=((i)[X]*(m)[1] + (i)[Y]*(m)[5] + (i)[Z]*(m)[9] + (m)[13]) * _f;\
	(o)[Z]=((i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10] + (m)[14])* _f;}

/** @@brief Multiply an Absolute hvect_t 4-Point by a full 4x4 matrix. */
#ifdef SHORT_VECTORS
#define MAT4X4PNT(o,m,i) \
	{ register int _i_m4x4p, _j_m4x4p; \
	for(_i_m4x4p = 0; _i_m4x4p < 4; _i_m4x4p++) \
		(o)[_i_m4x4p] = 0.0; \
	for(_i_m4x4p = 0; _i_m4x4p < 4; _i_m4x4p++) \
		for(_j_m4x4p = 0; _j_m4x4p < 4; _j_m4x4p++) \
			(o)[_i_m4x4p] += (m)[_j_m4x4p+4*_i_m4x4p] * (i)[_j_m4x4p]; \
	}
#else
#define MAT4X4PNT(o,m,i) 	{ \
	(o)[X]=(m)[ 0]*(i)[X] + (m)[ 1]*(i)[Y] + (m)[ 2]*(i)[Z] + (m)[ 3]*(i)[H];\
	(o)[Y]=(m)[ 4]*(i)[X] + (m)[ 5]*(i)[Y] + (m)[ 6]*(i)[Z] + (m)[ 7]*(i)[H];\
	(o)[Z]=(m)[ 8]*(i)[X] + (m)[ 9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11]*(i)[H];\
	(o)[H]=(m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]*(i)[H]; }
#endif /* SHORT_VECTORS */

/** @@brief Apply a 4x4 matrix to a 3-tuple which is a relative Vector in space
 * This macro can scale the length of the vector if [15] != 1.0
 */
#ifdef SHORT_VECTORS
#define MAT4X3VEC(o,m,i) \
	{ register double _f; \
	register int _i_m4x3v, _j_m4x3v; \
	_f = 1.0/((m)[15]); \
	for(_i_m4x3v = 0; _i_m4x3v < 3; _i_m4x3v++) \
		(o)[_i_m4x3v] = 0.0; \
	for(_i_m4x3v = 0; _i_m4x3v < 3; _i_m4x3v++) { \
		for(_j_m4x3v = 0; _j_m4x3v < 3; _j_m4x3v++) \
			(o)[_i_m4x3v] += (m)[_j_m4x3v+4*_i_m4x3v] * (i)[_j_m4x3v]; \
	} \
	for(_i_m4x3v = 0; _i_m4x3v < 3; _i_m4x3v++) { \
		(o)[_i_m4x3v] *= _f; \
	} }
#else
#define MAT4X3VEC(o,m,i) \
	{ register double _f;	_f = 1.0/((m)[15]);\
	(o)[X] = ((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z]) * _f; \
	(o)[Y] = ((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z]) * _f; \
	(o)[Z] = ((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z]) * _f; }
#endif /* SHORT_VECTORS */

#define MAT4XSCALOR(o,m,i) \
	{(o) = (i) / (m)[15];}

/** @@brief Multiply a Relative 3-Vector by most of a 4x4 matrix */
#define VEC3X4MAT(o,i,m) \
	{ register double _f; 	_f = 1.0/((m)[15]); \
	(o)[X] = ((i)[X]*(m)[0] + (i)[Y]*(m)[4] + (i)[Z]*(m)[8]) * _f; \
	(o)[Y] = ((i)[X]*(m)[1] + (i)[Y]*(m)[5] + (i)[Z]*(m)[9]) * _f; \
	(o)[Z] = ((i)[X]*(m)[2] + (i)[Y]*(m)[6] + (i)[Z]*(m)[10]) * _f; }

/** @@brief Multiply a Relative 2-Vector by most of a 4x4 matrix */
#define VEC2X4MAT(o,i,m) \
	{ register double _f; 	_f = 1.0/((m)[15]); \
	(o)[X] = ((i)[X]*(m)[0] + (i)[Y]*(m)[4]) * _f; \
	(o)[Y] = ((i)[X]*(m)[1] + (i)[Y]*(m)[5]) * _f; \
	(o)[Z] = ((i)[X]*(m)[2] + (i)[Y]*(m)[6]) * _f; }

/** @@brief Test a vector for non-unit length */
#define BN_VEC_NON_UNIT_LEN(_vec)	\
	(fabs(MAGSQ(_vec)) < 0.0001 || fabs(fabs(MAGSQ(_vec))-1) > 0.0001)

/** @@brief Compare two vectors for EXACT equality.  Use carefully. */
#define VEQUAL(a,b)	((a)[X]==(b)[X] && (a)[Y]==(b)[Y] && (a)[Z]==(b)[Z])

/** @@brief
 *  Compare two vectors for approximate equality,
 *  within the specified absolute tolerance.
 */
#define VAPPROXEQUAL(a,b,tol)	( \
	NEAR_ZERO( (a)[X]-(b)[X], tol ) && \
	NEAR_ZERO( (a)[Y]-(b)[Y], tol ) && \
	NEAR_ZERO( (a)[Z]-(b)[Z], tol ) )

/** @@brief Test for all elements of `v' being smaller than `tol' */
#define VNEAR_ZERO(v, tol)	( \
	NEAR_ZERO(v[X],tol) && NEAR_ZERO(v[Y],tol) && NEAR_ZERO(v[Z],tol)  )

/** @@brief Macros to update min and max X,Y,Z values to contain a point */
#define V_MIN(r,s)	if( (s) < (r) ) r = (s)
#define V_MAX(r,s)	if( (s) > (r) ) r = (s)
#define VMIN(r,s)	{ V_MIN((r)[X],(s)[X]); V_MIN((r)[Y],(s)[Y]); V_MIN((r)[Z],(s)[Z]); }
#define VMAX(r,s)	{ V_MAX((r)[X],(s)[X]); V_MAX((r)[Y],(s)[Y]); V_MAX((r)[Z],(s)[Z]); }
#define VMINMAX( min, max, pt )	{ VMIN( (min), (pt) ); VMAX( (max), (pt) ); }

/** @@brief Divide out homogeneous parameter from hvect_t, creating vect_t */
#ifdef SHORT_VECTORS
#define HDIVIDE(a,b)  \
	{ register int _hdivide; \
	for(_hdivide = 0; _hdivide < 3; _hdivide++) \
		(a)[_hdivide] = (b)[_hdivide] / (b)[H]; \
	}
#else
#define HDIVIDE(a,b)  { \
	(a)[X] = (b)[X] / (b)[H];\
	(a)[Y] = (b)[Y] / (b)[H];\
	(a)[Z] = (b)[Z] / (b)[H]; }
#endif /* SHORT_VECTORS */

/** @@brief
 *  Some 2-D versions of the 3-D macros given above.
 *
 *  A better naming convention is V2MOVE() rather than VMOVE_2D().
 *  XXX These xxx_2D names are slated to go away, use the others.
 */
#define VADD2_2D(a,b,c)	V2ADD2(a,b,c)
#define VSUB2_2D(a,b,c)	V2SUB2(a,b,c)
#define MAGSQ_2D(a)	MAG2SQ(a)
#define VDOT_2D(a,b)	V2DOT(a,b)
#define VMOVE_2D(a,b)	V2MOVE(a,b)
#define VSCALE_2D(a,b,c)	V2SCALE(a,b,c)
#define VJOIN1_2D(a,b,c,d) 	V2JOIN1(a,b,c,d)

/** @@brief
 *  Quaternion math definitions.
 *
 *  Note that the W component will be put in the last [3] place
 *  rather than the first [0] place,
 *  so that the X, Y, Z elements will be compatible with vectors.
 *  Only QUAT_FROM_VROT macros depend on component locations, however.
 *
 *  @@author Phillip Dykstra, 26 Sep 1985.
 *  @@author Lee A. Butler, 14 March 1996.
 */

/** @@brief Create Quaternion from Vector and Rotation about vector.
 *
 * To produce a quaternion representing a rotation by PI radians about X-axis:
 *
 *	VSET(axis, 1, 0, 0);
 *	QUAT_FROM_VROT( quat, M_PI, axis);
 *		or
 *	QUAT_FROM_ROT( quat, M_PI, 1.0, 0.0, 0.0, 0.0 );
 *
 *  Alternatively, in degrees:
 *	QUAT_FROM_ROT_DEG( quat, 180.0, 1.0, 0.0, 0.0, 0.0 );
 *
 */
#define QUAT_FROM_ROT(q, r, x, y, z){ \
	register fastf_t _rot = (r) * 0.5; \
	QSET(q, x, y, z, cos(_rot)); \
	VUNITIZE(q); \
	_rot = sin(_rot); /* _rot is really just a temp variable now */ \
	VSCALE(q, q, _rot ); }

#define QUAT_FROM_VROT(q, r, v) { \
	register fastf_t _rot = (r) * 0.5; \
	VMOVE(q, v); \
	VUNITIZE(q); \
	(q)[W] = cos(_rot); \
	_rot = sin(_rot); /* _rot is really just a temp variable now */ \
	VSCALE(q, q, _rot ); }

#define QUAT_FROM_VROT_DEG(q, r, v) \
	QUAT_FROM_VROT(q, ((r)*(M_PI/180.0)), v)

#define QUAT_FROM_ROT_DEG(q, r, x, y, z) \
	QUAT_FROM_ROT(q, ((r)*(M_PI/180.0)), x, y, z)


/** @@brief Set quaternion at `a' to have coordinates `b', `c', `d', `e' */
#define QSET(a,b,c,d,e)	{ \
			(a)[X] = (b);\
			(a)[Y] = (c);\
			(a)[Z] = (d);\
			(a)[W] = (e); }

/** @@brief Transfer quaternion at `b' to quaternion at `a' */
#define QMOVE(a,b)	{ \
			(a)[X] = (b)[X];\
			(a)[Y] = (b)[Y];\
			(a)[Z] = (b)[Z];\
			(a)[W] = (b)[W]; }

/** @@brief Add quaternions at `b' and `c', store result at `a' */
#define QADD2(a,b,c)	{ \
			(a)[X] = (b)[X] + (c)[X];\
			(a)[Y] = (b)[Y] + (c)[Y];\
			(a)[Z] = (b)[Z] + (c)[Z];\
			(a)[W] = (b)[W] + (c)[W]; }

/** @@brief Subtract quaternion at `c' from quaternion at `b', store result at `a' */
#define QSUB2(a,b,c)	{ \
			(a)[X] = (b)[X] - (c)[X];\
			(a)[Y] = (b)[Y] - (c)[Y];\
			(a)[Z] = (b)[Z] - (c)[Z];\
			(a)[W] = (b)[W] - (c)[W]; }

/** @@brief Scale quaternion at `b' by scalar `c', store result at `a' */
#define QSCALE(a,b,c)	{ \
			(a)[X] = (b)[X] * (c);\
			(a)[Y] = (b)[Y] * (c);\
			(a)[Z] = (b)[Z] * (c);\
			(a)[W] = (b)[W] * (c); }

/** @@brief Normalize quaternion 'a' to be a unit quaternion */
#define QUNITIZE(a)	{register double _f; _f = QMAGNITUDE(a); \
			if( _f < VDIVIDE_TOL ) _f = 0.0; else _f = 1.0/_f; \
			(a)[X] *= _f; (a)[Y] *= _f; (a)[Z] *= _f; (a)[W] *= _f; }

/** @@brief Return scalar magnitude squared of quaternion at `a' */
#define QMAGSQ(a)	( (a)[X]*(a)[X] + (a)[Y]*(a)[Y] \
			+ (a)[Z]*(a)[Z] + (a)[W]*(a)[W] )

/** @@brief Return scalar magnitude of quaternion at `a' */
#define QMAGNITUDE(a)	sqrt( QMAGSQ( a ) )

/** @@brief Compute dot product of quaternions at `a' and `b' */
#define QDOT(a,b)	( (a)[X]*(b)[X] + (a)[Y]*(b)[Y] \
			+ (a)[Z]*(b)[Z] + (a)[W]*(b)[W] )

/** @@brief
 *  Compute quaternion product a = b * c
 *	a[W] = b[W]*c[W] - VDOT(b,c);
	VCROSS( temp, b, c );
 *	VJOIN2( a, temp, b[W], c, c[W], b );
 */
#define QMUL(a,b,c)	{ \
    (a)[W] = (b)[W]*(c)[W] - (b)[X]*(c)[X] - (b)[Y]*(c)[Y] - (b)[Z]*(c)[Z]; \
    (a)[X] = (b)[W]*(c)[X] + (b)[X]*(c)[W] + (b)[Y]*(c)[Z] - (b)[Z]*(c)[Y]; \
    (a)[Y] = (b)[W]*(c)[Y] + (b)[Y]*(c)[W] + (b)[Z]*(c)[X] - (b)[X]*(c)[Z]; \
    (a)[Z] = (b)[W]*(c)[Z] + (b)[Z]*(c)[W] + (b)[X]*(c)[Y] - (b)[Y]*(c)[X]; }

/** @@brief Conjugate quaternion */
#define QCONJUGATE(a,b)	{ \
	(a)[X] = -(b)[X]; \
	(a)[Y] = -(b)[Y]; \
	(a)[Z] = -(b)[Z]; \
	(a)[W] =  (b)[W]; }

/** @@brief Multiplicative inverse quaternion */
#define QINVERSE(a,b)	{ register double _f = QMAGSQ(b); \
	if( _f < VDIVIDE_TOL ) _f = 0.0; else _f = 1.0/_f; \
	(a)[X] = -(b)[X] * _f; \
	(a)[Y] = -(b)[Y] * _f; \
	(a)[Z] = -(b)[Z] * _f; \
	(a)[W] =  (b)[W] * _f; }

/** @@brief
 *  Blend into quaternion `a'
 *	scalar `b' times quaternion at `c' plus
 *	scalar `d' times quaternion at `e'
 */
#ifdef SHORT_VECTORS
#define QBLEND2(a,b,c,d,e)	VBLEND2N(a,b,c,d,e,4)
#else
#define QBLEND2(a,b,c,d,e)	{ \
	(a)[X] = (b) * (c)[X] + (d) * (e)[X];\
	(a)[Y] = (b) * (c)[Y] + (d) * (e)[Y];\
	(a)[Z] = (b) * (c)[Z] + (d) * (e)[Z];\
	(a)[W] = (b) * (c)[W] + (d) * (e)[W]; }
#endif /* SHORT_VECTORS */

/**
 *  Macros for dealing with 3-D "extents", aka bounding boxes, that
 *  are represented as axis-aligned right parallelpipeds (RPPs).  This
 *  is stored as two points: a min point, and a max point.  RPP 1 is
 *  defined by lo1, hi1, RPP 2 by lo2, hi2.
 */

/**
 * Compare two bounding boxes and return true if they are disjoint.
 */
#define V3RPP_DISJOINT(_l1, _h1, _l2, _h2) \
      ( (_l1)[X] > (_h2)[X] || (_l1)[Y] > (_h2)[Y] || (_l1)[Z] > (_h2)[Z] || \
	(_l2)[X] > (_h1)[X] || (_l2)[Y] > (_h1)[Y] || (_l2)[Z] > (_h1)[Z] )

/**
 * Compare two bounding boxes and return true If they overlap.
 */
#define V3RPP_OVERLAP(_l1, _h1, _l2, _h2) \
    (! ((_l1)[X] > (_h2)[X] || (_l1)[Y] > (_h2)[Y] || (_l1)[Z] > (_h2)[Z] || \
	(_l2)[X] > (_h1)[X] || (_l2)[Y] > (_h1)[Y] || (_l2)[Z] > (_h1)[Z]) )

/** @@brief If two extents overlap within distance tolerance, return true. */
#define V3RPP_OVERLAP_TOL(_l1, _h1, _l2, _h2, _t) \
    (! ((_l1)[X] > (_h2)[X] + (_t)->dist || \
	(_l1)[Y] > (_h2)[Y] + (_t)->dist || \
	(_l1)[Z] > (_h2)[Z] + (_t)->dist || \
	(_l2)[X] > (_h1)[X] + (_t)->dist || \
	(_l2)[Y] > (_h1)[Y] + (_t)->dist || \
	(_l2)[Z] > (_h1)[Z] + (_t)->dist ) )

/** @@brief Is the point within or on the boundary of the RPP? */
#define V3PT_IN_RPP(_pt, _lo, _hi)	( \
	(_pt)[X] >= (_lo)[X] && (_pt)[X] <= (_hi)[X] && \
	(_pt)[Y] >= (_lo)[Y] && (_pt)[Y] <= (_hi)[Y] && \
	(_pt)[Z] >= (_lo)[Z] && (_pt)[Z] <= (_hi)[Z]  )

/** @@brief Within the distance tolerance, is the point within the RPP? */
#define V3PT_IN_RPP_TOL(_pt, _lo, _hi, _t)	( \
	(_pt)[X] >= (_lo)[X]-(_t)->dist && (_pt)[X] <= (_hi)[X]+(_t)->dist && \
	(_pt)[Y] >= (_lo)[Y]-(_t)->dist && (_pt)[Y] <= (_hi)[Y]+(_t)->dist && \
	(_pt)[Z] >= (_lo)[Z]-(_t)->dist && (_pt)[Z] <= (_hi)[Z]+(_t)->dist  )

/** @@brief
 * Determine if one bounding box is within another.
 * Also returns true if the boxes are the same.
 */
#define V3RPP1_IN_RPP2( _lo1 , _hi1 , _lo2 , _hi2 )	( \
	(_lo1)[X] >= (_lo2)[X] && (_hi1)[X] <= (_hi2)[X] && \
	(_lo1)[Y] >= (_lo2)[Y] && (_hi1)[Y] <= (_hi2)[Y] && \
	(_lo1)[Z] >= (_lo2)[Z] && (_hi1)[Z] <= (_hi2)[Z] )

/**
 * Convert an azimuth/elevation to a direction vector.
 */
#define V3DIR_FROM_AZEL(_d, _a, _e) { \
	register fastf_t _c_e = cos(_e); \
\
	(_d)[X] = cos(_a) * _c_e; \
	(_d)[Y] = sin(_a) * _c_e; \
	(_d)[Z] = sin(_e); \
}

/**
 * Convert a direction vector to azimuth/elevation (in radians)
 */
#define AZEL_FROM_V3DIR(_a, _e, _d) { \
	(_a) = (((_d)[X] == 0) && ((_d)[Y] == 0)) ? 0.0 : atan2( -((_d)[Y]), -((_d)[X]) ) * RAD2DEG; \
	(_e) = atan2( -((_d)[Z]), sqrt((_d)[X]*(_d)[X] + (_d)[Y]*(_d)[Y]) ) * RAD2DEG; \
}

__END_DECLS

#endif /* __VMATH_H__ */

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.27
log
@Added V3AE2DIR.
@
text
@d120 7
d1303 5
a1307 2
#define V3AE2DIR(_az, _el, _dir) { \
	fastf_t c_el = cos(_el); \
d1309 3
a1311 3
	(_dir)[X] = cos(_az) * c_el; \
	(_dir)[Y] = sin(_az) * c_el; \
	(_dir)[Z] = sin(_el); \
d1314 7
@


14.26
log
@math.h and float.h are also fair game, c89 baby
@
text
@d1296 9
@


14.25
log
@clean up the header protections so that they are all now more consistent with one another via use of __HEADER_H__ for the define names.
@
text
@d94 1
a94 3
#ifdef HAVE_MATH_H
#  include <math.h>
#endif
d97 1
a97 3
#ifdef HAVE_FLOAT_H
#  include <float.h>
#endif
@


14.24
log
@get rid of RCS variables from the public header files.  this is done in part to reduce recompilation during interface changes, but also to move towards not relying on or publishing the information contained in the variables interface-wise. (they're fine for c sources and private headers)
@
text
@d88 2
a89 2
#ifndef VMATH_H
#define VMATH_H seen
d1302 2
a1303 1
#endif /* VMATH_H */
@


14.23
log
@bb comment for searching
@
text
@a85 2
 *
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.22 2007/01/27 01:01:40 brlcad Exp $
@


14.22
log
@ws, test three
@
text
@d87 1
a87 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.21 2007/01/26 03:48:24 brlcad Exp $
d1251 5
a1255 5
/** @@brief
 *  Macros for dealing with 3-D "extents" represented as axis-aligned
 *  right parallelpipeds (RPPs).
 *  This is stored as two points:  a min point, and a max point.
 *  RPP 1 is defined by lo1, hi1, RPP 2 by lo2, hi2.
d1258 3
a1260 1
/** @@brief Compare two extents represented as RPPs. If they are disjoint, return true */
d1265 3
a1267 1
/** @@brief Compare two extents represented as RPPs. If they overlap, return true */
@


14.21
log
@elements_per_mat is a square of elements_per_plane
@
text
@d40 1
a40 1
<tt> @@code 
d70 1
a70 1
 *	
d87 1
a87 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.20 2007/01/26 03:44:07 brlcad Exp $
d145 1
a145 1
#define ELEMENTS_PER_VECT	3      
d148 1
a148 1
#define HVECT_LEN		4      
d159 1
a159 1
typedef	fastf_t	mat_t[ELEMENTS_PER_MAT]; 
d163 1
a163 1
typedef	fastf_t	vect_t[ELEMENTS_PER_VECT];  
d167 1
a167 1
typedef fastf_t	point_t[ELEMENTS_PER_PT];  
d173 1
a173 1
typedef fastf_t hvect_t[HVECT_LEN];   
d176 1
a176 1
typedef fastf_t hpoint_t[HPT_LEN];    
d179 1
a179 1
#define quat_t	hvect_t		
d899 1
a899 1
 * This rotates a vector without scaling it (changing its length) 
d1015 1
a1015 1
 * This macro can scale the length of the vector if [15] != 1.0 
a1157 1

a1310 1

@


14.20
log
@add similar MAT_SCALE sibling macros for adding, subtracting, and multiplying the scaling elements just to be consistent
@
text
@d87 1
a87 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.19 2007/01/26 03:35:40 brlcad Exp $
d153 1
a153 1
#define ELEMENTS_PER_MAT	(4*4)
@


14.19
log
@s/NUL/MUL/ typo
@
text
@d87 1
a87 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.18 2007/01/26 03:29:42 brlcad Exp $
d321 36
@


14.18
log
@add additional helper macros MAT_DELTAS_(ADD|SUB|MUL)(_VEC)? for modifying the translation elements (3, 7, 11) in a 4x4 transformation matrix
@
text
@d87 1
a87 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.17 2007/01/23 01:13:20 brlcad Exp $
d294 1
a294 1
#define MAT_DELTAS_NUL_VEC(_m,_v) { \
@


14.17
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d87 1
a87 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.16 2007/01/21 04:45:40 brlcad Exp $
d238 4
a241 4
#define MAT_DELTAS(m,x,y,z)	{ \
			(m)[MDX] = (x); \
			(m)[MDY] = (y); \
			(m)[MDZ] = (z); }
d252 1
a252 1
#define MAT_DELTAS_GET(_v,_m)	{ \
d258 1
a258 1
#define MAT_DELTAS_GET_NEG(_v,_m)	{ \
d263 37
@


14.16
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d87 1
a87 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.15 2007/01/20 14:36:40 brlcad Exp $
@


14.15
log
@update copyright to 2007
@
text
@d22 1
a22 1
/*@@{*/
d25 1
a25 1
 *@@brief vector/matrix math
d88 1
a88 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.14 2006/09/18 05:24:07 lbutler Exp $
d1230 1
a1230 1
/*@@}*/
@


14.14
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d88 1
a88 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.13 2006/09/03 15:16:20 lbutler Exp $
@


14.13
log
@Doxygen updates
@
text
@d88 1
a88 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.12 2006/08/31 04:41:20 lbutler Exp $
d295 1
a295 1
/* #define MAT_ZERO(m)	{\
d1240 1
@


14.12
log
@miscelaneous changes to support doxygen
@
text
@d21 2
d25 2
d41 1
d44 1
d49 1
d54 1
d56 3
a58 3
 *  Note -
 *	vect_t objects are 3-tuples
 *	hvect_t objects are 4-tuples
d70 2
a71 2
 *  Author -
 *	Michael John Muuss
d73 1
a73 1
 *  Source -
d75 1
a75 1
 *	Aberdeen Proving Ground, Maryland  21005
d85 1
a85 1
 *  Libraries Used -
d88 1
a88 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.11 2006/01/18 06:46:10 brlcad Exp $
d145 2
a146 1
#define ELEMENTS_PER_VECT	3	/* # of fastf_t's per vect_t */
d148 2
a149 1
#define HVECT_LEN		4	/* # of fastf_t's per hvect_t */
d151 2
d159 2
a160 1
typedef	fastf_t	mat_t[ELEMENTS_PER_MAT];
d163 2
a164 1
typedef	fastf_t	vect_t[ELEMENTS_PER_VECT];
d167 2
a168 1
typedef fastf_t	point_t[ELEMENTS_PER_PT];
d173 2
a174 2
typedef fastf_t hvect_t[HVECT_LEN];
typedef fastf_t hpoint_t[HPT_LEN];
d176 5
a180 1
#define quat_t	hvect_t		/* 4-element quaternion */
d192 4
a195 2
/*
 *  Definition of a plane equation:
d201 3
a203 3
 *	VDOT(P,N) - N[3] == 0
 *  that is,
 *	N[X]*x + N[Y]*y + N[Z]*z - N[3] == 0
d207 1
a207 1
 *	VDOT(P,N) - N[3] <= 0
d211 3
a213 3
 *	VDOT(D,N) < 0	ray enters halfspace defined by plane
 *	VDOT(D,N) == 0	ray is parallel to plane
 *	VDOT(D,N) > 0	ray exits halfspace defined by plane
d217 1
a217 1
/* Compute distance from a point to a plane */
d220 1
a220 1
/* Compute distance between two points */
d237 2
d244 1
d247 2
d251 2
d257 2
d270 1
d276 1
d282 1
d287 2
d300 1
d312 1
d333 1
a333 1
/* Set vector at `a' to have coordinates `b', `c', `d' */
d339 1
a339 1
/* Set all elements of vector to same scalar value */
d342 1
d347 1
a347 1
/* Transfer vector at `b' to vector at `a' */
d353 1
a353 1
/* Transfer vector of length `n' at `b' to vector at `a' */
d360 1
a360 1
/* Move a homogeneous 4-tuple */
d367 3
a369 1
/* This naming convention seems better than the VMOVE_2D version below */
d374 1
a374 1
/* Reverse the direction of b and store it in a */
d380 1
a380 1
/* Same as VREVERSE, but for a 4-tuple.  Also useful on plane_t objects */
d387 1
a387 1
/* Add vectors at `b' and `c', store result at `a' */
d397 1
a397 1
/* Add vectors of length `n' at `b' and `c', store result at `a' */
d408 1
a408 1
/* Subtract vector at `c' from vector at `b', store result at `a' */
d418 1
a418 1
/* Subtract `n' length vector at `c' from vector at `b', store result at `a' */
d429 1
a429 1
/* Vectors:  A = B - C - D */
d439 1
a439 1
/* Vectors:  A = B - C - D for vectors of length `n' */
d446 1
a446 1
/* Add 3 vectors at `b', `c', and `d', store result at `a' */
d456 1
a456 1
/* Add 3 vectors of length `n' at `b', `c', and `d', store result at `a' */
d463 1
a463 1
/* Add 4 vectors at `b', `c', `d', and `e', store result at `a' */
d473 1
a473 1
/* Add 4 `n' length vectors at `b', `c', `d', and `e', store result at `a' */
d480 1
a480 1
/* Scale vector at `b' by scalar `c', store result at `a' */
d496 1
a496 1
/* Scale vector of length `n' at `b' by scalar `c', store result at `a' */
d507 1
a507 1
/* Normalize vector `a' to be a unit vector */
d534 1
a534 1
/* If vector magnitude is too small, return an error code */
d541 1
a541 1
/*
d560 1
a560 1
/*
d580 1
a580 1
/*
d623 1
a623 1
/* Compose vector at `a' of:
d668 1
a668 1
/*
d688 1
a688 1
/* Return scalar magnitude squared of vector at `a' */
d692 1
a692 1
/* Return scalar magnitude of vector at `a' */
d695 1
a695 1
/*
d714 1
a714 1
/* Compute dot product of vectors at `a' and `b' */
d719 1
a719 1
/* Subtract two points to make a vector, dot with another vector */
d725 1
a725 1
/* Turn a vector into comma-separated list of elements, for subroutine args */
d730 1
a730 1
/* integer clamped versions of the previous arg macros */
d732 1
d734 1
d737 1
a737 1
/* Print vector name and components on stderr */
d745 1
a745 1
/* integer clamped versions of the previous print macros */
d770 1
a770 1
/* Vector element multiplication.  Really: diagonal matrix X vect */
d797 1
a797 1
/* Similar to VELMUL */
d803 2
a804 2
/* Given a direction vector, compute the inverses of each element. */
/* When division by zero would have occured, mark inverse as INFINITY. */
d826 3
a828 2
/* Apply the 3x3 part of a mat_t to a 3-tuple. */
/* This rotates a vector without scaling it (changing its length) */
d844 1
a844 1
/* Multiply a 3-tuple by the 3x3 part of a mat_t. */
d860 1
a860 1
/* Apply the 3x3 part of a mat_t to a 2-tuple (Z part=0). */
d875 1
a875 1
/* Multiply a 2-tuple (Z=0) by the 3x3 part of a mat_t. */
d889 1
a889 1
/* Apply a 4x4 matrix to a 3-tuple which is an absolute Point in space */
d916 1
a916 1
/* Multiply an Absolute 3-Point by a full 4x4 matrix. */
d924 1
a924 1
/* Multiply an Absolute hvect_t 4-Point by a full 4x4 matrix. */
d942 3
a944 2
/* Apply a 4x4 matrix to a 3-tuple which is a relative Vector in space */
/* This macro can scale the length of the vector if [15] != 1.0 */
d970 1
a970 1
/* Multiply a Relative 3-Vector by most of a 4x4 matrix */
d977 1
a977 1
/* Multiply a Relative 2-Vector by most of a 4x4 matrix */
d984 1
a984 1
/* Test a vector for non-unit length */
d988 1
a988 1
/* Compare two vectors for EXACT equality.  Use carefully. */
d991 1
a991 1
/*
d1000 1
a1000 1
/* Test for all elements of `v' being smaller than `tol' */
d1004 1
a1004 1
/* Macros to update min and max X,Y,Z values to contain a point */
d1011 1
a1011 1
/* Divide out homogeneous parameter from hvect_t, creating vect_t */
d1025 1
a1025 1
/*
d1039 1
a1039 1
/*
d1047 2
a1048 2
 *  Phillip Dykstra, 26 Sep 1985.
 *  Lee A. Butler, 14 March 1996.
d1051 1
a1051 1
/* Create Quaternion from Vector and Rotation about vector.
d1087 1
a1087 1
/* Set quaternion at `a' to have coordinates `b', `c', `d', `e' */
d1094 1
a1094 1
/* Transfer quaternion at `b' to quaternion at `a' */
d1101 1
a1101 1
/* Add quaternions at `b' and `c', store result at `a' */
d1108 1
a1108 1
/* Subtract quaternion at `c' from quaternion at `b', store result at `a' */
d1115 1
a1115 1
/* Scale quaternion at `b' by scalar `c', store result at `a' */
d1122 1
a1122 1
/* Normalize quaternion 'a' to be a unit quaternion */
d1127 1
a1127 1
/* Return scalar magnitude squared of quaternion at `a' */
d1131 1
a1131 1
/* Return scalar magnitude of quaternion at `a' */
d1134 1
a1134 1
/* Compute dot product of quaternions at `a' and `b' */
d1138 1
a1138 1
/*
d1150 1
a1150 1
/* Conjugate quaternion */
d1157 1
a1157 1
/* Multiplicative inverse quaternion */
d1165 1
a1165 1
/*
d1180 1
a1180 1
/*
d1187 1
a1187 1
/* Compare two extents represented as RPPs. If they are disjoint, return true */
d1192 1
a1192 1
/* Compare two extents represented as RPPs. If they overlap, return true */
d1197 1
a1197 1
/* If two extents overlap within distance tolerance, return true. */
d1206 1
a1206 1
/* Is the point within or on the boundary of the RPP? */
d1212 1
a1212 1
/* Within the distance tolerance, is the point within the RPP? */
d1218 1
a1218 1
/*
d1230 1
a1230 1

@


14.11
log
@update copyright to 2006
@
text
@d70 6
a75 4
 *	#include <stdio.h>
 *	#include <math.h>
 *	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	#include "vmath.h"
d80 1
a80 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.10 2005/11/24 07:11:24 brlcad Exp $
@


14.10
log
@add V2INTCLAMPARGS, V3INTCLAMPARGS, V4INTCLAMPARGS, V2INTCLAMPPRINT, VINTCLAMPPRINT, HINTCLAMPPRINT macros that utilize INTCLAMP for clean printing.
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d78 1
a78 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.9 2005/11/24 05:08:29 brlcad Exp $
@


14.9
log
@include math.h and float.h since they are required by this header; remove the archaic sqrt() prototyping (should be detected/provided by configure); add comments on NEAR_ZERO and CLAMP; implement INTCLAMP for determining whether a value is within computation tolerance of an integer -- if it is, return the value clamped to the integer.
@
text
@d78 1
a78 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.8 2005/10/23 04:44:26 brlcad Exp $
d688 5
d701 8
@


14.8
log
@trailing ws
@
text
@d78 1
a78 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.7 2005/09/09 05:07:46 brlcad Exp $
d86 10
d99 14
a112 15

# define M_E		2.7182818284590452354	/* e */
# define M_LOG2E	1.4426950408889634074	/* log_2 e */
# define M_LOG10E	0.43429448190325182765	/* log_10 e */
# define M_LN2		0.69314718055994530942	/* log_e 2 */
# define M_LN10		2.30258509299404568402	/* log_e 10 */
# define M_PI		3.14159265358979323846	/* pi */
# define M_PI_2		1.57079632679489661923	/* pi/2 */
# define M_PI_4		0.78539816339744830962	/* pi/4 */
# define M_1_PI		0.31830988618379067154	/* 1/pi */
# define M_2_PI		0.63661977236758134308	/* 2/pi */
# define M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
# define M_SQRT2	1.41421356237309504880	/* sqrt(2) */
# define M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */
# define M_SQRT2_DIV2   0.70710678118654752440  /* 1/sqrt(2) */
d118 1
a118 18
#ifndef sqrt
	/* In case <math.h> has not been included, define sqrt() here */
#	if __STDC__
		extern double sqrt(double);
#	else
#		if (defined(sgi) && defined(mips) && !defined(SGI4D_Rel2))
			/* What could SGI have been thinking of? */
			extern double sqrt(double);
#		else
			extern double sqrt();
#		endif
#	endif
#endif

#define NEAR_ZERO(val,epsilon)	( ((val) > -epsilon) && ((val) < epsilon) )

#define CLAMP(_v, _l, _h) if (_v < _l) _v = _l; else if (_v > _h) _v = _h

d120 2
a121 2
#	define VDIVIDE_TOL	(1.0e-10)
#	define VUNITIZE_TOL	(1.0e-7)
d123 10
a132 2
#	define VDIVIDE_TOL	(1.0e-20)
#	define VUNITIZE_TOL	(1.0e-15)
d161 10
d705 8
@


14.7
log
@consistency, BRL-CAD not BRL CAD
@
text
@d28 1
a28 1
 *  the BRL-CAD system uses the more traditional representation of 
d78 1
a78 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.6 2005/05/08 05:27:59 brlcad Exp $
d649 1
a649 1
 *  If the angle from `b' to `c' goes clockwise, then 
d973 1
a973 1
 
@


14.6
log
@consolidate the __cplusplus external declaration sections that protect C functions from C++ name mangling by using the same __BEGIN_DECLS and __END_DECLS macros in our headers (3rd party are mostly left alone).  works indentation a little too.
@
text
@d28 1
a28 1
 *  the BRL CAD system uses the more traditional representation of 
d78 1
a78 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.5 2005/05/01 23:15:12 brlcad Exp $
@


14.6.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *  the BRL-CAD system uses the more traditional representation of
d78 1
a78 1
 *  $Header$
d649 1
a649 1
 *  If the angle from `b' to `c' goes clockwise, then
d973 1
a973 1

@


14.5
log
@err, that's not right.. maybe it should be stdout
@
text
@d78 1
a78 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.4 2005/01/30 20:30:12 brlcad Exp $
d84 3
a86 3
#ifdef __cplusplus
extern "C" {
#endif
d1150 1
a1150 3
#ifdef __cplusplus
}
#endif
@


14.4
log
@update copyright to 2005
@
text
@d78 1
a78 1
 *  $Header: /cvsroot/brlcad/brlcad/include/vmath.h,v 14.3 2004/12/21 06:23:18 morrison Exp $
d678 1
a678 1
/* Print vector name and components on stdout */
@


14.3
log
@use perl to M-q format wrapping
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d78 1
a78 1
 *  $Header: /cvs/brlcad/include/vmath.h,v 14.2 2004/12/21 06:06:39 butler Exp $
@


14.2
log
@LGPL license changes
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU Lesser General Public License
 * along with this file; see the file named COPYING for more
d78 1
a78 1
 *  $Header: /cvs/brlcad/include/vmath.h,v 14.1 2004/11/16 19:42:10 morrison Exp $
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			V M A T H . H
a67 3
 *  
 *  Distribution Status -
 *	This file is public domain, distribution unlimited.
d78 1
a78 1
 *  $Header: /cvs/brlcad/include/vmath.h,v 1.1 2004/05/24 04:10:51 morrison Exp $
@


1.1
log
@moved/renamed from top-level h/ to top-level include/
@
text
@d62 1
a62 1
 *  $Header$
d1139 10
@

