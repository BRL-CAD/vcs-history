head	14.91;
access;
symbols
	rel-7-10-4:14.71
	STABLE:14.71.0.2
	stable-branch:14.9
	rel-7-10-2:14.69
	rel-7-10-0:14.54
	rel-7-8-4:14.39
	rel-7-8-2:14.30
	rel-7-8-0:14.30
	trimnurbs-branch:14.29.0.2
	help:14.29
	temp_tag:14.24
	bobWinPort-20051223-freeze:14.19.2.1
	postmerge-20051223-bobWinPort:14.24
	premerge-20051223-bobWinPort:14.23
	rel-7-6-6:14.23
	rel-7-6-4:14.23
	rel-7-6-2:14.22
	rel-7-6-branch:14.22.0.2
	rel-7-6-0:14.22
	rel-7-4-2:14.16.2.1
	rel-7-4-branch:14.16.0.2
	bobWinPort:14.19.0.2
	rel-7-4-0:14.16
	rel-7-2-6:14.12
	rel-7-2-4:14.11
	rel-7-2-2:14.8
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.14
	rel-7-0-branch:1.14.0.2
	rel-7-0:1.14;
locks; strict;
comment	@ * @;


14.91
date	2007.12.31.19.16.08;	author brlcad;	state Exp;
branches;
next	14.90;

14.90
date	2007.12.31.17.54.14;	author brlcad;	state Exp;
branches;
next	14.89;

14.89
date	2007.12.16.15.33.49;	author brlcad;	state Exp;
branches;
next	14.88;

14.88
date	2007.12.14.11.04.14;	author brlcad;	state Exp;
branches;
next	14.87;

14.87
date	2007.12.09.21.43.33;	author brlcad;	state Exp;
branches;
next	14.86;

14.86
date	2007.12.09.00.51.43;	author brlcad;	state Exp;
branches;
next	14.85;

14.85
date	2007.12.08.22.42.58;	author brlcad;	state Exp;
branches;
next	14.84;

14.84
date	2007.12.07.04.50.46;	author brlcad;	state Exp;
branches;
next	14.83;

14.83
date	2007.12.04.01.36.14;	author brlcad;	state Exp;
branches;
next	14.82;

14.82
date	2007.11.13.09.41.15;	author d_rossberg;	state Exp;
branches;
next	14.81;

14.81
date	2007.11.08.19.04.09;	author bob1961;	state Exp;
branches;
next	14.80;

14.80
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.79;

14.79
date	2007.10.22.19.23.05;	author erikgreenwald;	state Exp;
branches;
next	14.78;

14.78
date	2007.10.22.19.06.18;	author erikgreenwald;	state Exp;
branches;
next	14.77;

14.77
date	2007.10.22.08.43.48;	author brlcad;	state Exp;
branches;
next	14.76;

14.76
date	2007.10.22.00.58.04;	author brlcad;	state Exp;
branches;
next	14.75;

14.75
date	2007.10.17.01.30.40;	author brlcad;	state Exp;
branches;
next	14.74;

14.74
date	2007.10.16.21.35.47;	author brlcad;	state Exp;
branches;
next	14.73;

14.73
date	2007.09.14.18.08.33;	author erikgreenwald;	state Exp;
branches;
next	14.72;

14.72
date	2007.09.14.15.21.00;	author erikgreenwald;	state Exp;
branches;
next	14.71;

14.71
date	2007.08.30.22.14.31;	author brlcad;	state Exp;
branches;
next	14.70;

14.70
date	2007.08.28.21.30.28;	author erikgreenwald;	state Exp;
branches;
next	14.69;

14.69
date	2007.05.30.14.55.48;	author erikgreenwald;	state Exp;
branches;
next	14.68;

14.68
date	2007.05.26.01.45.02;	author brlcad;	state Exp;
branches;
next	14.67;

14.67
date	2007.05.26.01.30.25;	author brlcad;	state Exp;
branches;
next	14.66;

14.66
date	2007.05.20.20.22.50;	author brlcad;	state Exp;
branches;
next	14.65;

14.65
date	2007.05.19.00.50.03;	author brlcad;	state Exp;
branches;
next	14.64;

14.64
date	2007.05.19.00.30.51;	author brlcad;	state Exp;
branches;
next	14.63;

14.63
date	2007.05.14.16.39.14;	author brlcad;	state Exp;
branches;
next	14.62;

14.62
date	2007.05.13.18.51.44;	author brlcad;	state Exp;
branches;
next	14.61;

14.61
date	2007.05.13.00.05.57;	author brlcad;	state Exp;
branches;
next	14.60;

14.60
date	2007.05.12.21.59.23;	author brlcad;	state Exp;
branches;
next	14.59;

14.59
date	2007.05.12.04.50.22;	author brlcad;	state Exp;
branches;
next	14.58;

14.58
date	2007.05.12.00.09.54;	author brlcad;	state Exp;
branches;
next	14.57;

14.57
date	2007.04.17.14.57.18;	author erikgreenwald;	state Exp;
branches;
next	14.56;

14.56
date	2007.04.16.21.15.35;	author brlcad;	state Exp;
branches;
next	14.55;

14.55
date	2007.04.13.17.03.03;	author erikgreenwald;	state Exp;
branches;
next	14.54;

14.54
date	2007.03.06.20.48.14;	author brlcad;	state Exp;
branches;
next	14.53;

14.53
date	2007.03.01.22.43.17;	author brlcad;	state Exp;
branches;
next	14.52;

14.52
date	2007.02.26.09.37.43;	author brlcad;	state Exp;
branches;
next	14.51;

14.51
date	2007.02.26.09.24.19;	author brlcad;	state Exp;
branches;
next	14.50;

14.50
date	2007.02.20.03.37.37;	author brlcad;	state Exp;
branches;
next	14.49;

14.49
date	2007.02.20.01.14.18;	author brlcad;	state Exp;
branches;
next	14.48;

14.48
date	2007.02.20.00.07.14;	author brlcad;	state Exp;
branches;
next	14.47;

14.47
date	2007.02.01.21.52.15;	author brlcad;	state Exp;
branches;
next	14.46;

14.46
date	2007.01.31.20.56.58;	author brlcad;	state Exp;
branches;
next	14.45;

14.45
date	2007.01.27.01.01.39;	author brlcad;	state Exp;
branches;
next	14.44;

14.44
date	2007.01.23.01.13.19;	author brlcad;	state Exp;
branches;
next	14.43;

14.43
date	2007.01.21.04.45.40;	author brlcad;	state Exp;
branches;
next	14.42;

14.42
date	2007.01.20.14.36.40;	author brlcad;	state Exp;
branches;
next	14.41;

14.41
date	2007.01.17.19.36.49;	author erikgreenwald;	state Exp;
branches;
next	14.40;

14.40
date	2006.12.29.05.12.03;	author lbutler;	state Exp;
branches;
next	14.39;

14.39
date	2006.09.26.00.10.45;	author brlcad;	state Exp;
branches;
next	14.38;

14.38
date	2006.09.18.05.24.07;	author lbutler;	state Exp;
branches;
next	14.37;

14.37
date	2006.09.03.15.16.20;	author lbutler;	state Exp;
branches;
next	14.36;

14.36
date	2006.08.31.04.41.19;	author lbutler;	state Exp;
branches;
next	14.35;

14.35
date	2006.08.28.18.51.28;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2006.08.16.02.25.10;	author johnranderson;	state Exp;
branches;
next	14.33;

14.33
date	2006.07.09.10.02.35;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2006.07.09.09.25.58;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2006.07.06.19.35.17;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2006.03.29.20.02.23;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2006.02.03.02.07.34;	author brlcad;	state Exp;
branches
	14.29.2.1;
next	14.28;

14.28
date	2006.02.03.02.02.05;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2006.01.22.23.44.49;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2006.01.21.00.02.28;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2006.01.18.06.46.10;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2005.12.23.21.26.25;	author bob1961;	state Exp;
branches;
next	14.23;

14.23
date	2005.10.23.04.44.26;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2005.08.25.00.19.10;	author brlcad;	state Exp;
branches
	14.22.2.1;
next	14.21;

14.21
date	2005.08.24.04.16.06;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2005.08.16.20.33.47;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2005.08.15.21.51.10;	author bob1961;	state Exp;
branches
	14.19.2.1;
next	14.18;

14.18
date	2005.07.25.05.46.17;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2005.07.18.05.03.20;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.07.06.23.53.39;	author brlcad;	state Exp;
branches
	14.16.2.1;
next	14.15;

14.15
date	2005.07.06.23.30.24;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.06.21.06.58.58;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.06.21.06.31.55;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.05.28.02.14.49;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.05.11.01.25.24;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.05.08.05.27.57;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.04.11.18.32.26;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.03.24.16.28.24;	author bob1961;	state Exp;
branches;
next	14.7;

14.7
date	2005.03.23.15.52.56;	author lbutler;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.10;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.07.25.29;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.23.18;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.06.38;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.10;	author morrison;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.14.19.19.28;	author morrison;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.04.14.00.44;	author morrison;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.28.13.50.23;	author butler;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.20.19.37.30;	author morrison;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.16.06.24.17;	author morrison;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.15.05.39.13;	author morrison;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.03.19.57.13;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.02.12.09.33;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.03.20.42.29;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.02.23.09.51;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.22.24.40;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.25.04.12.21;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.25.20.39.34;	author butler;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.24.04.10.49;	author morrison;	state Exp;
branches;
next	;

14.16.2.1
date	2005.08.16.21.03.44;	author brlcad;	state Exp;
branches;
next	;

14.19.2.1
date	2005.09.08.16.11.51;	author bob1961;	state Exp;
branches;
next	;

14.22.2.1
date	2005.11.13.13.46.09;	author brlcad;	state Exp;
branches;
next	;

14.29.2.1
date	2006.04.07.19.24.54;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.91
log
@include stddef.h for size_t and declare the new bu_strlcatm() and bu_strlcpym() functions and their associated bu_strlcat/bu_strlcpy macro wrappers.
@
text
@/*                            B U . H
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup libbu */
/** @@{ */
/** @@file bu.h
 *
 * @@brief
 *  Header file for the BRL-CAD Utility Library, LIBBU.
 *
 *  This library provides several layers of low-level utility routines,
 *  providing features that make coding much easier.
 *	Parallel processing support:  threads, sempahores, parallel-malloc.
 *	Consolodated logging support:  bu_log(), bu_exit(), and bu_bomb().
 *
 *  The intention is that these routines are general extensions to
 *  the data types offered by the C language itself, and to the
 *  basic C runtime support provided by the system LIBC.
 *
 *  All of the data types provided by this library are defined in bu.h;
 *  none of the routines in this library will depend on data types defined
 *  in other BRL-CAD header files, such as vmath.h.
 *  Look for those routines in LIBBN.
 *
 *  @@author Michael John Muuss
 *
 *  @@par Source
 *	The U. S. Army Research Laboratory 			@@n
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA	@@n
 *
 *  Proper include Sequencing -
@@code
	#include "common.h"
	#include <stdio.h>
	#include "bu.h"
@@endcode
 *
 *  @@par Libraries Used -
 *	-lm -lc
 */
#ifndef __BU_H__
#define __BU_H__

#include "common.h"

__BEGIN_DECLS

/* system interface headers */
#include <setjmp.h> /* for bu_setjmp */
#include <stddef.h> /* for size_t */

/* common interface headers */
#include "machine.h"	/* required for fastf_t, genptr_t */
#include "tcl.h"	/* Included for Tcl_Interp definition */


#ifndef BU_EXPORT
#  if defined(_WIN32) && !defined(__CYGWIN__) && defined(BRLCAD_DLL)
#    ifdef BU_EXPORT_DLL
#      define BU_EXPORT __declspec(dllexport)
#    else
#      define BU_EXPORT __declspec(dllimport)
#    endif
#  else
#    define BU_EXPORT
#  endif
#endif

/** @@def BU_DIR_SEPARATOR
 * define BU_DIR_SEPARATOR to the directory separator character
 */
#ifdef DIR_SEPARATOR
#  define BU_DIR_SEPARATOR DIR_SEPARATOR
#else
#  ifdef DIR_SEPARATOR_2
#    define BU_DIR_SEPARATOR DIR_SEPARATOR_2
#  else
#    ifdef _WIN32
#      define BU_DIR_SEPARATOR '\\'
#    else
#      define BU_DIR_SEPARATOR '/'
#    endif  /* _WIN32 */
#  endif  /* DIR_SEPARATOR_2 */
#endif  /* DIR_SEPARATOR */

/**
 * Maximum length of a filesystem path.  Typically defined in a system file
 * but if it isn't set, we create it.
 */
#ifndef MAXPATHLEN
#  define MAXPATHLEN 1024
#endif

/**
 * set to the path list separator character
 */
#if defined(PATH_SEPARATOR)
#  define BU_PATH_SEPARATOR PATH_SEPARATOR
#else
#  if defined(_WIN32)
#    define BU_PATH_SEPARATOR ';'
#  else
#    define BU_PATH_SEPARATOR ':'
#  endif  /* _WIN32 */
#endif  /* PATH_SEPARATOR */


/** @@def BU_FLSTR
 *
 * Macro for getting a concatenated string of the current
 * file and line number.  Produces something of the form:
 *   "filename.c"":""1234"
 */
#define bu_cpp_str(s) # s
#define bu_cpp_xstr(s)  bu_cpp_str(s)
#define bu_cpp_glue(a, b) a ## b
#define bu_cpp_xglue(a, b) bu_cpp_glue(a, b)
#define BU_FLSTR __FILE__ ":" bu_cpp_xstr(__LINE__)
#define BU_QFLSTR bu_cpp_xstr(__FILE__ line __LINE__)

/*
 *  Macros for providing function prototypes, regardless of whether
 *  the compiler understands them or not.
 *  It is vital that the argument list given for "args" be enclosed
 *  in parens.
 *  The setting of USE_PROTOTYPES is determined during configure
 */
#if __STDC__ || USE_PROTOTYPES
#	define	BU_EXTERN(type_and_name,args)	extern type_and_name args
#	define	BU_ARGS(args)			args
#else
#	define	BU_EXTERN(type_and_name,args)	extern type_and_name()
#	define	BU_ARGS(args)			()
#endif

/**
 * This is so we can use gcc's "format string vs arguments"-check for
 * various printf-like functions, and still maintain compatability.
 */
#ifndef __attribute__
/* This feature is only available in gcc versions 2.5 and later. */
#  if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
#    define __attribute__(ignore) /* empty */
#  endif
/* The __-protected variants of `format' and `printf' attributes
 * are accepted by gcc versions 2.6.4 (effectively 2.7) and later.
 */
#  if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
#    define __format__ format
#    define __printf__ printf
#    define __noreturn__ noreturn
#  endif
#endif

/**
 * shorthand declaration of a printf-style functions
 */
#define __BU_ATTR_FORMAT12 __attribute__ ((__format__ (__printf__, 1, 2)))
#define __BU_ATTR_FORMAT23 __attribute__ ((__format__ (__printf__, 2, 3)))

/**
 * shorthand declaration of a function that doesn't return
 */
#define __BU_ATTR_NORETURN __attribute__ ((__noreturn__))


/**
 * B U _ F O R T R A N
 *
 * @@def BU_FORTRAN
 *
 * This macro is used to take the 'C' function name, and convert it at
 * compile time to the FORTRAN calling convention.
 *
 * Lower case, with a trailing underscore.
 */
#define BU_FORTRAN(lc,uc)	lc ## _


/**
 * Handy memory allocator macro
 *
 * @@def BU_GETSTRUCT(ptr,struct_type)
 * Acquire storage for a given struct_type.
 * e.g., BU_GETSTRUCT(ptr,structname);
 *
 * @@def BU_GETUNION(ptr,union_type)
 * Allocate storage for a union
*/
#define BU_GETSTRUCT(_p,_str) \
	_p = (struct _str *)bu_calloc(1,sizeof(struct _str), #_str " (getstruct)" BU_FLSTR)
#define BU_GETUNION(_p,_unn) \
	_p = (union _unn *)bu_calloc(1,sizeof(union _unn), #_unn " (getunion)" BU_FLSTR)


/**
 * B U _ G E T T Y P E
 *
 * Acquire storage for a given TYPE, eg, BU_GETTYPE(ptr, typename);
 * Equivalent to BU_GETSTRUCT, except without the 'struct' Useful
 * for typedef'ed objects.
 */
#define BU_GETTYPE(_p,_type) \
	_p = (_type *)bu_calloc(1,sizeof(_type), #_type " (gettype)" )


/**
 * B U _ C K M A G
 *
 * @@def BU_CKMAG(ptr,magic,string)
 *
 * Macros to check and validate a structure pointer, given that the
 * first entry in the structure is a magic number.
 */
#ifdef NO_BOMBING_MACROS
#  define BU_CKMAG(_ptr, _magic, _str)
#  define BU_CKMAG_TCL(_interp, _ptr, _magic, _str)
#else
#  define BU_CKMAG(_ptr, _magic, _str)	\
	if( !(_ptr) || ( ((long)(_ptr)) & (sizeof(long)-1) ) || \
	    *((unsigned long *)(_ptr)) != (unsigned long)(_magic) )  { \
		bu_badmagic( (long *)(_ptr), (unsigned long)_magic, _str, __FILE__, __LINE__ ); \
	}
#  define BU_CKMAG_TCL(_interp, _ptr, _magic, _str)	\
	if( !(_ptr) || ( ((long)(_ptr)) & (sizeof(long)-1) ) || \
	     *((long *)(_ptr)) != (_magic) )  { \
		bu_badmagic_tcl( (_interp), (long *)(_ptr), (unsigned long)_magic, _str, __FILE__, __LINE__ ); \
		return TCL_ERROR; \
	}
#endif


/**
 * B U _ A S S E R T
 *
 * @@def BU_ASSERT(eqn)
 *  Quick and easy macros to generate an informative error message and
 *  abort execution if the specified condition does not hold true.
 * @@def BU_ASSERT_PTR(eqn)
 *  Quick and easy macros to generate an informative error message and
 *  abort execution if the specified condition does not hold true.
 * @@def BU_ASSERT_LONG(eqn)
 *  Quick and easy macros to generate an informative error message and
 *  abort execution if the specified condition does not hold true.
 * @@def BU_ASSERT_DOUBLE(eqn)
 *  Quick and easy macros to generate an informative error message and
 *  abort execution if the specified condition does not hold true.
 *
 *  Example:		BU_ASSERT_LONG( j+7, <, 42 );
 */
#ifdef NO_BOMBING_MACROS
#  define BU_ASSERT(_equation)
#else
#  define BU_ASSERT(_equation)	\
	if( !(_equation) )  { \
		bu_log("BU_ASSERT( " #_equation " ) failed, file %s, line %d\n", \
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT failure\n"); \
	}
#endif

#ifdef NO_BOMBING_MACROS
#  define BU_ASSERT_PTR(_lhs,_relation,_rhs)
#else
#  define BU_ASSERT_PTR(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_PTR( " #_lhs #_relation #_rhs " ) failed, lhs=x%lx, rhs=x%lx, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_PTR failure\n"); \
	}
#endif


#ifdef NO_BOMBING_MACROS
#  define BU_ASSERT_LONG(_lhs,_relation,_rhs)
#else
#  define BU_ASSERT_LONG(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_LONG( " #_lhs #_relation #_rhs " ) failed, lhs=%ld, rhs=%ld, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_LONG failure\n"); \
	}
#endif


#ifdef NO_BOMBING_MACROS
#  define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)
#else
#  define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_DOUBLE( " #_lhs #_relation #_rhs " ) failed, lhs=%lf, rhs=%lf, file %s, line %d\n", \
			(double)(_lhs), (double)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_DOUBLE failure\n"); \
	}
#endif
/** @@} */


/**
 * report version information about LIBBU
 */
BU_EXPORT BU_EXTERN(const char *bu_version, (void));


/*----------------------------------------------------------------------*/
/** @@addtogroup hton */
/** @@{ */
/**
 *  Sizes of "network" format data.
 *  We use the same convention as the TCP/IP specification,
 *  namely, big-Endian, IEEE format, twos compliment.
 *  This is the BRL-CAD external data representation (XDR).
 *  See also the support routines in libbu/xdr.c
 *
 */
#define SIZEOF_NETWORK_SHORT	2	/* htons(), bu_gshort(), bu_pshort() */
#define SIZEOF_NETWORK_LONG	4	/* htonl(), bu_glong(), bu_plong() */
#define SIZEOF_NETWORK_FLOAT	4	/* htonf() */
#define SIZEOF_NETWORK_DOUBLE	8	/* htond() */
/** @@} */

/*----------------------------------------------------------------------*/
/* convert.c
 */
/** @@addtogroup conv */
/**@@{*/
/*
 * Forward declarations.
 */
BU_EXPORT BU_EXTERN(int bu_cv_itemlen,
		    (int cookie));
BU_EXPORT BU_EXTERN(int bu_cv_cookie,
		    (char *in));
BU_EXPORT BU_EXTERN(int bu_cv_optimize,
		    (int cookie));
BU_EXPORT BU_EXTERN(int bu_cv_w_cookie,
		    (genptr_t,
		     int,
		     size_t,
		     genptr_t,
		     int,
		     int));

BU_EXPORT BU_EXTERN(int bu_cv_ntohss,
		    (signed short *,
		     size_t,
		     genptr_t,
		     int));
BU_EXPORT BU_EXTERN(int bu_cv_ntohus,
		    (unsigned short *,
		     size_t,
		     genptr_t,
		     int));
BU_EXPORT BU_EXTERN(int bu_cv_ntohsl,
		    (signed long int *,
		     size_t,
		     genptr_t,
		     int));
BU_EXPORT BU_EXTERN(int bu_cv_ntohul,
		    (unsigned long int *,
		     size_t,
		     genptr_t,
		     int));
BU_EXPORT BU_EXTERN(int bu_cv_htonss,
		    (genptr_t,
		     size_t,
		     signed short *,
		     int));
BU_EXPORT BU_EXTERN(int bu_cv_htonus,
		    (genptr_t,
		     size_t,
		     unsigned short *,
		     int));
BU_EXPORT BU_EXTERN(int bu_cv_htonsl,
		    (genptr_t,
		     size_t,
		     long *,
		     int));
BU_EXPORT BU_EXTERN(int bu_cv_htonul,
		    (genptr_t,
		     size_t,
		     unsigned long *,
		     int));

/*
 * Theses should be moved to a header file soon.
 */
#define CV_CHANNEL_MASK	0x00ff
#define CV_HOST_MASK	0x0100
#define CV_SIGNED_MASK	0x0200
#define CV_TYPE_MASK	0x1c00  /* 0001 1100 0000 0000 */
#define CV_CONVERT_MASK 0x6000  /* 0110 0000 0000 0000 */

#define CV_TYPE_SHIFT	10
#define CV_CONVERT_SHIFT 13

#define CV_8	0x0400
#define	CV_16	0x0800
#define CV_32	0x0c00
#define CV_64	0x1000
#define CV_D	0x1400

#define CV_CLIP		0x0000
#define CV_NORMAL	0x2000
#define CV_LIT		0x4000

#define	IND_NOTSET	0
#define IND_BIG		1
#define IND_LITTLE	2
#define IND_ILL		3		/* PDP-11 */
#define IND_CRAY	4
/**@@}*/

/*----------------------------------------------------------------------*/
/* list.c */

/** @@addtogroup bu_list
 *
 *			     B U _ L I S T
 *
 *			Doubly-linked list support
 *
 *  These macros assume that all user-provided structures will have
 *  a "struct bu_list" as their first element (often named "l" [ell]).
 *  Thus, a pointer to the bu_list struct is a "pun" for the
 *  user-provided structure as well, and the pointers can be converted
 *  back and forth safely with type casts.
 *
 *  Furthermore, the head of the linked list could be
 *  a full instance of the user-provided structure
 *  (although the storage-conscious programmer could make the head
 *  just an bu_list structure, with careful type casting).
 *  This results in a doubly-linked circular list, with the head
 *  having the same shape as all the list members.
 *  The application is free to make use of this symmetry and store
 *  data values in the head, or the extra storage in the head can
 *  be ignored.
 *
 *  Where a macro expects an argument "p", it should be a pointer to
 *  a user-provided structure.
 *
 *  Where a macro expects an argument "hp", it should be a pointer to
 *  a "struct bu_list" located in the list head, e.g., &(head.l).
 *
 *  Where a macro expects an argument "old", "new", or "cur", it should
 *  be a pointer to the "struct bu_list" located either
 *  in a user-provided structure, e.g. &((p)->l),
 *  or for the case of "old" it may also be in the list head, e.g.
 *	BU_LIST_INSERT( &(head.l), &((p)->l) );
 *
 *  Dequeueing the head of a list is a valid and
 *  well defined operation which should be performed with caution.
 *  Unless a pointer to some other element of the list is retained
 *  by the application, the rest of the linked list can no longer be
 *  referred to.
 *
 *  The "magic" field of the list header _must_ be set to the constant
 *  BU_LIST_HEAD_MAGIC, but the "magic" field of all list members
 *  should be established by user code, to identify the type of
 *  structure that the bu_list structure is embedded in.
 *  It is permissible for one list to contain an arbitrarily mixed
 *  set of user "magic" numbers, as long as the head is properly marked.
 *
 *  There is a dual set of terminology used in some of the macros:
 *	FIRST / LAST	from the point of view of the list head
 *	NEXT / PREV	from the point of view of a list member
 *	forw / back	the actual pointer names
 *
 ************************************************************************/
/**@@{*/

struct bu_list {
    long		magic;		/**< @@brief Magic # for mem id/check */
    struct bu_list	*forw;		/**< @@brief "forward", "next" */
    struct bu_list	*back;		/**< @@brief "back", "last" */
};
#define BU_LIST_HEAD_MAGIC	0x01016580	/* Magic num for list head */
#define BU_LIST_NULL	((struct bu_list *)0)

typedef struct bu_list bu_list_t;

BU_EXPORT BU_EXTERN(struct bu_list *bu_list_new, ());
BU_EXPORT BU_EXTERN(struct bu_list *bu_list_pop, (struct bu_list *hp));

#define BU_LIST_CLOSE( hp ) { \
	BU_ASSERT( (hp) != NULL ); \
	if( (hp) == NULL ) \
		return; \
	BU_ASSERT( BU_LIST_IS_EMPTY( (hp) ) ); \
	bu_list_free( (hp) ); \
	bu_free( (char *)(hp), "bu_list head" ); \
}


/*
 *  Insert "new" item in front of "old" item.  Often, "old" is the head.
 *  To put the new item at the tail of the list, insert before the head, e.g.
 *	BU_LIST_INSERT( &(head.l), &((p)->l) );
 */
#define BU_LIST_INSERT(old,new)	{ \
	(new)->back = (old)->back; \
	(old)->back = (new); \
	(new)->forw = (old); \
	(new)->back->forw = (new);  }

/*
 *  Append "new" item after "old" item.  Often, "old" is the head.
 *  To put the new item at the head of the list, append after the head, e.g.
 *	BU_LIST_APPEND( &(head.l), &((p)->l) );
 */
#define BU_LIST_APPEND(old,new)	{ \
	(new)->forw = (old)->forw; \
	(new)->back = (old); \
	(old)->forw = (new); \
	(new)->forw->back = (new);  }

/* Dequeue "cur" item from anywhere in doubly-linked list */
#define BU_LIST_DEQUEUE(cur)	{ \
	(cur)->forw->back = (cur)->back; \
	(cur)->back->forw = (cur)->forw; \
	(cur)->forw = (cur)->back = BU_LIST_NULL;  /* sanity */ }

/* Dequeue "cur" but do not fix its links */
#define BU_LIST_DQ(cur) {\
	(cur)->forw->back = (cur)->back; \
	(cur)->back->forw = (cur)->forw; }

#define BU_LIST_DQ_T(cur, type) (\
	(cur)->forw->back = (cur)->back, \
	(cur)->back->forw = (cur)->forw, \
	(type *)(cur) )

/* This version of BU_LIST_DEQUEUE uses the comma operator
 * inorder to return a typecast version of the dequeued pointer
 */
#define BU_LIST_DEQUEUE_T( cur, type ) (\
	(cur)->forw->back = (cur)->back, \
	(cur)->back->forw = (cur)->forw, \
	(cur)->forw = (cur)->back = BU_LIST_NULL, \
	(type *)(cur) )


/*
 *  The Stack Discipline
 *
 *  BU_LIST_PUSH places p at the tail of hp.
 *  BU_LIST_POP  sets p to last element in hp's list (else NULL)
 *		  and, if p is non-null, dequeues it.
 */
#define BU_LIST_PUSH(hp,p)					\
	BU_LIST_APPEND(hp, (struct bu_list *)(p))

#define BU_LIST_POP(structure,hp,p)				\
	{							\
		if (BU_LIST_NON_EMPTY(hp))				\
		{							\
		    (p) = ((struct structure *)((hp)->forw));		\
		    BU_LIST_DEQUEUE((struct bu_list *)(p));		\
		}							\
		else							\
		     (p) = (struct structure *) 0;			\
	}

#define BU_LIST_POP_T(hp, type )				\
	(type *)bu_list_pop( hp )

/**
 *  "Bulk transfer" all elements from the list headed by src_hd
 *  onto the list headed by dest_hd, without examining every element
 *  in the list.  src_hd is left with a valid but empty list.
 *
 *  BU_LIST_INSERT_LIST places src_hd elements at head of dest_hd list,
 *  BU_LIST_APPEND_LIST places src_hd elements at end of dest_hd list.
 */
#define BU_LIST_INSERT_LIST(dest_hp,src_hp) \
	if( BU_LIST_NON_EMPTY(src_hp) )  { \
		register struct bu_list	*_first = (src_hp)->forw; \
		register struct bu_list	*_last = (src_hp)->back; \
		(dest_hp)->forw->back = _last; \
		_last->forw = (dest_hp)->forw; \
		(dest_hp)->forw = _first; \
		_first->back = (dest_hp); \
		(src_hp)->forw = (src_hp)->back = (src_hp); \
	}

#define BU_LIST_APPEND_LIST(dest_hp,src_hp) \
	if( BU_LIST_NON_EMPTY(src_hp) )  {\
		register struct bu_list	*_first = (src_hp)->forw; \
		register struct bu_list	*_last = (src_hp)->back; \
		_first->back = (dest_hp)->back; \
		(dest_hp)->back->forw = _first; \
		(dest_hp)->back = _last; \
		_last->forw = (dest_hp); \
		(src_hp)->forw = (src_hp)->back = (src_hp); \
	}

/** Test if a doubly linked list is empty, given head pointer */
#define BU_LIST_IS_EMPTY(hp)	((hp)->forw == (hp))
#define BU_LIST_NON_EMPTY(hp)	((hp)->forw != (hp))
#define BU_LIST_NON_EMPTY_P(p,structure,hp)	\
	(((p)=(struct structure *)((hp)->forw)) != (struct structure *)(hp))
#define BU_LIST_IS_CLEAR(hp)	((hp)->magic == 0 && \
			(hp)->forw == BU_LIST_NULL && \
			(hp)->back == BU_LIST_NULL)

/* Handle list initialization */
#define	BU_LIST_UNINITIALIZED(hp)	((hp)->forw == BU_LIST_NULL)
#define	BU_LIST_IS_INITIALIZED(hp)	((hp)->forw != BU_LIST_NULL)
#define BU_LIST_INIT(hp)	{ \
	(hp)->forw = (hp)->back = (hp); \
	(hp)->magic = BU_LIST_HEAD_MAGIC;	/* used by circ. macros */ }
#define BU_LIST_MAGIC_SET(hp,val)	{(hp)->magic = (val);}
#define BU_LIST_MAGIC_OK(hp,val)	((hp)->magic == (val))
#define BU_LIST_MAGIC_WRONG(hp,val)	((hp)->magic != (val))

/* Return re-cast pointer to first element on list.
 * No checking is performed to see if list is empty.
 */
#define BU_LIST_LAST(structure,hp)	\
	((struct structure *)((hp)->back))
#define BU_LIST_BACK(structure,hp)	\
	((struct structure *)((hp)->back))
#define BU_LIST_PREV(structure,hp)	\
	((struct structure *)((hp)->back))
#define BU_LIST_FIRST(structure,hp)	\
	((struct structure *)((hp)->forw))
#define BU_LIST_FORW(structure,hp)	\
	((struct structure *)((hp)->forw))
#define BU_LIST_NEXT(structure,hp)	\
	((struct structure *)((hp)->forw))

/* Boolean test to see if current list element is the head */
#define BU_LIST_IS_HEAD(p,hp)	\
	(((struct bu_list *)(p)) == (hp))
#define BU_LIST_NOT_HEAD(p,hp)	\
	(((struct bu_list *)(p)) != (hp))
#define BU_CK_LIST_HEAD( _p )	BU_CKMAG( (_p), BU_LIST_HEAD_MAGIC, "bu_list")

/* Boolean test to see if previous list element is the head */
#define BU_LIST_PREV_IS_HEAD(p,hp)\
	(((struct bu_list *)(p))->back == (hp))
#define BU_LIST_PREV_NOT_HEAD(p,hp)\
	(((struct bu_list *)(p))->back != (hp))

/* Boolean test to see if the next list element is the head */
#define BU_LIST_NEXT_IS_HEAD(p,hp)	\
	(((struct bu_list *)(p))->forw == (hp))
#define BU_LIST_NEXT_NOT_HEAD(p,hp)	\
	(((struct bu_list *)(p))->forw != (hp))

#define BU_LIST_EACH( hp, p, type ) \
	 for( (p)=(type *)BU_LIST_FIRST(bu_list,hp); \
	      (p) && BU_LIST_NOT_HEAD(p,hp); \
	      (p)=(type *)BU_LIST_PNEXT(bu_list,p) ) \

#define BU_LIST_REVEACH( hp, p, type ) \
	 for( (p)=(type *)BU_LIST_LAST(bu_list,hp); \
	      (p) && BU_LIST_NOT_HEAD(p,hp); \
	      (p)=(type *)BU_LIST_PREV(bu_list,((struct bu_list *)(p))) ) \

#define BU_LIST_TAIL( hp, start, p, type ) \
	 for( (p)=(type *)start ; \
	      (p) && BU_LIST_NOT_HEAD(p,hp); \
	      (p)=(type *)BU_LIST_PNEXT(bu_list,(p)) )

/**
 *  Intended as innards for a for() loop to visit all nodes on list, e.g.:
 *	for( BU_LIST_FOR( p, structure, hp ) )  {
 *		work_on( p );
 *	}
 */
#define BU_LIST_FOR(p,structure,hp)	\
	(p)=BU_LIST_FIRST(structure,hp); \
	(p) && BU_LIST_NOT_HEAD(p,hp); \
	(p)=BU_LIST_PNEXT(structure,p)

#define BU_LIST_FOR_BACKWARDS(p,structure,hp)	\
	(p)=BU_LIST_LAST(structure,hp); \
	(p) && BU_LIST_NOT_HEAD(p,hp); \
	(p)=BU_LIST_PLAST(structure,p)

/**
 *  Process all the list members except hp and the actual head.
 *  Useful when starting somewhere besides the head.
 */
#define BU_LIST_FOR_CIRC(p,structure,hp)	\
	(p)=BU_LIST_PNEXT_CIRC(structure,hp); \
	(p) && (p) != (hp); \
	(p)=BU_LIST_PNEXT_CIRC(structure,p)

/*
 *  Intended as innards for a for() loop to visit elements of two lists
 *	in tandem, e.g.:
 *	    for (BU_LIST_FOR2(p1, p2, structure, hp1, hp2) ) {
 *		    process( p1, p2 );
 *	    }
 */
#define	BU_LIST_FOR2(p1,p2,structure,hp1,hp2)				\
		(p1)=BU_LIST_FIRST(structure,hp1),			\
		(p2)=BU_LIST_FIRST(structure,hp2);			\
		(p1) && BU_LIST_NOT_HEAD((struct bu_list *)(p1),(hp1)) &&	\
		(p2) && BU_LIST_NOT_HEAD((struct bu_list *)(p2),(hp2));		\
		(p1)=BU_LIST_NEXT(structure,(struct bu_list *)(p1)),	\
		(p2)=BU_LIST_NEXT(structure,(struct bu_list *)(p2))

/**
 *  Innards for a while() loop that constantly picks off the first element.
 *  Useful mostly for a loop that will dequeue every list element, e.g.:
 *	while( BU_LIST_WHILE(p, structure, hp) )  {
 *@@n		BU_LIST_DEQUEUE( &(p->l) );
 *@@n		free( (char *)p );
 *@@n	}
 */
#define BU_LIST_WHILE(p,structure,hp)	\
	(((p)=(struct structure *)((hp)->forw)) != (struct structure *)(hp))

/** Return the magic number of the first (or last) item on a list */
#define BU_LIST_FIRST_MAGIC(hp)		((hp)->forw->magic)
#define BU_LIST_LAST_MAGIC(hp)		((hp)->back->magic)

/** Return pointer to next (or previous) element, which may be the head */
#define BU_LIST_PNEXT(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->forw))
#define BU_LIST_PLAST(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->back))

/** Return pointer two links away, which may include the head */
#define BU_LIST_PNEXT_PNEXT(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->forw->forw))
#define BU_LIST_PNEXT_PLAST(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->forw->back))
#define BU_LIST_PLAST_PNEXT(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->back->forw))
#define BU_LIST_PLAST_PLAST(structure,p)	\
	((struct structure *)(((struct bu_list *)(p))->back->back))

/** Return pointer to circular next element; ie, ignoring the list head */
#define BU_LIST_PNEXT_CIRC(structure,p)	\
	((BU_LIST_FIRST_MAGIC((struct bu_list *)(p)) == BU_LIST_HEAD_MAGIC) ? \
		BU_LIST_PNEXT_PNEXT(structure,(struct bu_list *)(p)) : \
		BU_LIST_PNEXT(structure,p) )

/** Return pointer to circular last element; ie, ignoring the list head */
#define BU_LIST_PPREV_CIRC(structure,p)	\
	((BU_LIST_LAST_MAGIC((struct bu_list *)(p)) == BU_LIST_HEAD_MAGIC) ? \
		BU_LIST_PLAST_PLAST(structure,(struct bu_list *)(p)) : \
		BU_LIST_PLAST(structure,p) )

/**
 *  Support for membership on multiple linked lists.
 *
 *  When a structure of type '_type' contains more than one bu_list structure
 *  within it (such as the NMG edgeuse), this macro can be used to convert
 *  a pointer '_ptr2' to a "midway" bu_list structure (an element called
 *  '_name2' in structure '_type') back into a pointer to the overall
 *  enclosing structure.  Examples:
 *
 *  eu = BU_LIST_MAIN_PTR( edgeuse, midway, l2 );
 *
 *  eu1 = BU_LIST_MAIN_PTR(edgeuse, BU_LIST_FIRST(bu_list, &eg1->eu_hd2), l2);
 *
 *  Files using BU_LIST_MAIN_PTR will need to include stddef.h
 */
#define BU_LIST_MAIN_PTR(_type, _ptr2, _name2)	\
	((struct _type *)(((char *)(_ptr2)) - offsetof(struct _type, _name2.magic)))
/** @@} */
/*----------------------------------------------------------------------*/
/* bitv.c */
/*
 *			B U _ B I T V
 */
/** @@addtogroup bitv */
/**@@{*/
/**
 *
 * @@brief
 *  Bit vector data structure.
 *
 *  bu_bitv uses a little-endian encoding, placing bit 0 on the
 *  right side of the 0th word.
 *  This is done only because left-shifting a 1 can be done in an
 *  efficient word-length-independent manner;
 *  going the other way would require a compile-time constant with
 *  only the sign bit set, and an unsigned right shift, which some
 *  machines don't have in hardware, or an extra subtraction.
 *
 *  Application code should *never* peak at the bit-buffer; use the macros.
 *
 *  The external hex form is most signigicant byte first (bit 0 is at the right).
 *  Note that MUVES does it differently
 */
struct bu_bitv {
    struct bu_list	l;		/**< @@brief linked list for caller's use  */
    unsigned int	nbits;		/**< @@brief actual size of bits[], in bits  */
    bitv_t		bits[2];	/**< @@brief variable size array  */
};

#define BU_BITV_MAGIC		0x62697476	/* 'bitv' */
#define BU_CK_BITV(_vp)		BU_CKMAG(_vp, BU_BITV_MAGIC, "bu_bitv")

/*
 *  Bit-string manipulators for arbitrarily long bit strings
 *  stored as an array of bitv_t's.
 */
#define BU_BITS2BYTES(_nb)	(BU_BITS2WORDS(_nb)*sizeof(bitv_t))
#define BU_BITS2WORDS(_nb)	(((_nb)+BITV_MASK)>>BITV_SHIFT)
#define BU_WORDS2BITS(_nw)	((_nw)*sizeof(bitv_t)*8)

#if 1
#define BU_BITTEST(_bv,bit)	\
	(((_bv)->bits[(bit)>>BITV_SHIFT] & (((bitv_t)1)<<((bit)&BITV_MASK)))!=0)
#else
static __inline__ int BU_BITTEST(volatile void * addr, int nr)
{
	int oldbit;

	__asm__ __volatile__(
		"btl %2,%1\n\tsbbl %0,%0"
		:"=r" (oldbit)
		:"m" (addr),"Ir" (nr));
	return oldbit;
}
#endif

#define BU_BITSET(_bv,bit)	\
	((_bv)->bits[(bit)>>BITV_SHIFT] |= (((bitv_t)1)<<((bit)&BITV_MASK)))
#define BU_BITCLR(_bv,bit)	\
	((_bv)->bits[(bit)>>BITV_SHIFT] &= ~(((bitv_t)1)<<((bit)&BITV_MASK)))
#define BU_BITV_ZEROALL(_bv)	\
	{ memset((char *)((_bv)->bits), 0, BU_BITS2BYTES( (_bv)->nbits )); }

/* This is not done by default for performance reasons */
#ifdef NO_BOMBING_MACROS
#  define BU_BITV_BITNUM_CHECK(_bv,_bit)
#else
#  define BU_BITV_BITNUM_CHECK(_bv,_bit)	/* Validate bit number */ \
	if( ((unsigned)(_bit)) >= (_bv)->nbits )  {\
		bu_log("BU_BITV_BITNUM_CHECK bit number (%u) out of range (0..%u)\n", \
			((unsigned)(_bit)), (_bv)->nbits); \
		bu_bomb("process self-terminating\n");\
	}
#endif

#ifdef NO_BOMBING_MACROS
#  define BU_BITV_NBITS_CHECK(_bv,_nbits)
#else
#  define BU_BITV_NBITS_CHECK(_bv,_nbits)	/* Validate number of bits */ \
	if( ((unsigned)(_nbits)) > (_bv)->nbits )  {\
		bu_log("BU_BITV_NBITS_CHECK number of bits (%u) out of range (> %u)", \
			((unsigned)(_nbits)), (_bv)->nbits ); \
		bu_bomb("process self-terminating"); \
		}
#endif


/**
 *  Macros to efficiently find all the ONE bits in a bit vector.
 *  Counts words down, counts bits in words going up, for speed & portability.
 *  It does not matter if the shift causes the sign bit to smear to the right.
 *
 *  @@par Example:
@@code
	BU_BITV_LOOP_START(bv)  {
		fiddle(BU_BITV_LOOP_INDEX);
	} BU_BITV_LOOP_END;
@@endcode
 *
 */
#define BU_BITV_LOOP_START(_bv)	\
{ \
	register int		_wd;	/* Current word number */  \
	BU_CK_BITV(_bv); \
	for( _wd=BU_BITS2WORDS((_bv)->nbits)-1; _wd>=0; _wd-- )  {  \
		register int	_b;	/* Current bit-in-word number */  \
		register bitv_t	_val;	/* Current word value */  \
		if((_val = (_bv)->bits[_wd])==0) continue;  \
		for(_b=0; _b < BITV_MASK+1; _b++, _val >>= 1 ) { \
			if( !(_val & 1) )  continue;

/**
 *  This macro is valid only between a BU_BITV_LOOP_START/LOOP_END pair,
 *  and gives the bit number of the current iteration.
 */
#define BU_BITV_LOOP_INDEX	((_wd << BITV_SHIFT) | _b)

#define BU_BITV_LOOP_END	\
		} /* end for(_b) */ \
	} /* end for(_wd) */ \
} /* end block */
/** @@} */

/*----------------------------------------------------------------------*/
/* hist.c */

/** @@addtogroup bu_hist */
/** @@{ */
/**
 *			B U _ H I S T
 *
 * @@struct bu_hist bu.h
 * @@brief histogram support
 */
struct bu_hist  {
    long		magic;		/**< @@brief magic # for id/check  */
    fastf_t		hg_min;		/**< @@brief minimum value  */
    fastf_t		hg_max;		/**< @@brief maximum value  */
    fastf_t		hg_clumpsize;	/**< @@brief (max-min+1)/nbins+1  */
    long		hg_nsamples;	/**< @@brief total number of samples spread into histogram  */
    long		hg_nbins;	/**< @@brief # of bins in hg_bins[]  */
    long		*hg_bins;	/**< @@brief array of counters  */
};
#define BU_HIST_MAGIC	0x48697374	/* Hist */
#define BU_CK_HIST(_p)	BU_CKMAG(_p, BU_HIST_MAGIC, "struct bu_hist")

#define BU_HIST_TALLY( _hp, _val )	{ \
	if( (_val) <= (_hp)->hg_min )  { \
		(_hp)->hg_bins[0]++; \
	} else if( (_val) >= (_hp)->hg_max )  { \
		(_hp)->hg_bins[(_hp)->hg_nbins]++; \
	} else { \
		(_hp)->hg_bins[(int)(((_val)-(_hp)->hg_min)/(_hp)->hg_clumpsize)]++; \
	} \
	(_hp)->hg_nsamples++;  }

#define BU_HIST_TALLY_MULTIPLE( _hp, _val, _count )	{ \
	register int	__count = (_count); \
	if( (_val) <= (_hp)->hg_min )  { \
		(_hp)->hg_bins[0] += __count; \
	} else if( (_val) >= (_hp)->hg_max )  { \
		(_hp)->hg_bins[(_hp)->hg_nbins] += __count; \
	} else { \
		(_hp)->hg_bins[(int)(((_val)-(_hp)->hg_min)/(_hp)->hg_clumpsize)] += __count; \
	} \
	(_hp)->hg_nsamples += __count;  }

/** @@} */
/*----------------------------------------------------------------------*/
/* ptbl.c */
/**
 * @@addtogroup ptbl
 * @@struct bu_ptbl
 * @@brief
 *  Support for generalized "pointer tables".
 */
/** @@{ */

struct bu_ptbl {
    struct bu_list	l;	/**< @@brief linked list for caller's use  */
    int		end;	/**< @@brief index into buffer of first available location  */
    int		blen;	/**< @@brief # of (long *)'s worth of storage at *buffer  */
    long 		**buffer; /**< @@brief data storage area  */
};
#define BU_PTBL_MAGIC		0x7074626c		/* "ptbl" */
#define BU_CK_PTBL(_p)		BU_CKMAG(_p, BU_PTBL_MAGIC, "bu_ptbl")

#define BU_PTBL_INIT	0	/**< @@brief  initialize table pointer struct & get storage */
#define BU_PTBL_INS	1	/**< @@brief  insert an item (long *) into a table */
#define BU_PTBL_LOC 	2	/**< @@brief  locate a (long *) in an existing table */
#define BU_PTBL_FREE	3	/**< @@brief  deallocate buffer associated with a table */
#define BU_PTBL_RST	4	/**< @@brief  empty a table, but keep storage on hand */
#define BU_PTBL_CAT	5	/**< @@brief  catenate one table onto another */
#define BU_PTBL_RM	6	/**< @@brief  remove all occurrences of an item from a table */
#define BU_PTBL_INS_UNIQUE 7	/**< @@brief  insert item into table, if not present */
#define BU_PTBL_ZERO	8	/**< @@brief  replace all occurrences of an item by 0 */
/*
 *  For those routines that have to "peek" into the ptbl a little bit.
 */
#define BU_PTBL_BASEADDR(ptbl)	((ptbl)->buffer)
#define BU_PTBL_LASTADDR(ptbl)	((ptbl)->buffer + (ptbl)->end - 1)
#define BU_PTBL_END(ptbl)	((ptbl)->end)
#define BU_PTBL_LEN(p)	((p)->end)
#define BU_PTBL_GET(ptbl,i)	((ptbl)->buffer[(i)])
#define BU_PTBL_SET(ptbl,i,val)	((ptbl)->buffer[(i)] = (long*)(val))
#define BU_PTBL_TEST(ptbl)	((ptbl)->l.magic == BU_PTBL_MAGIC)
#define BU_PTBL_CLEAR_I(_ptbl, _i) ((_ptbl)->buffer[(_i)] = (long *)0)

/**
 *  A handy way to visit all the elements of the table is:
 *
 *	struct edgeuse **eup;
 *	for( eup = (struct edgeuse **)BU_PTBL_LASTADDR(&eutab);
 *	     eup >= (struct edgeuse **)BU_PTBL_BASEADDR(&eutab); eup-- )  {
 *		NMG_CK_EDGEUSE(*eup);
 *	}
 *  or
 *	for( BU_PTBL_FOR( eup, (struct edgeuse **), &eutab ) )  {
 *		NMG_CK_EDGEUSE(*eup);
 *	}
 */
#define BU_PTBL_FOR(ip,cast,ptbl)	\
    ip = cast BU_PTBL_LASTADDR(ptbl); ip >= cast BU_PTBL_BASEADDR(ptbl); ip--


/* vlist, vlblock?  But they use vmath.h .. hrm. */
/** @@} */

/*----------------------------------------------------------------------*/
/* mappedfile.c */
/**
 *			B U _ M A P P E D _ F I L E
 * @@addtogroup mf
 * @@struct bu_mapped_file bu.h
 * @@brief
 *  Structure for opening a mapped file.
 *  Each file is opened and mapped only once (per application,
 *  as tagged by the string in "appl" field).
 *  Subsequent opens require an exact match on both strings.
 *
 *  Before allocating apbuf and performing data conversion into it,
 *  openers should check to see if the file has already been opened and
 *  converted previously.
 *
 *  When used in RT, the mapped files are not closed at the end of a frame,
 *  so that subsequent frames may take advantage of the large data files
 *  having already been read and converted.
 *  Examples include EBMs, texture maps, and height fields.
 *
 *  For appl == "db_i", file is a ".g" database & apbuf is (struct db_i *).
 */
/** @@{ */
struct bu_mapped_file {
	struct bu_list	l;
    char		*name;		/**< @@brief bu_strdup() of file name  */
    genptr_t	buf;		/**< @@brief In-memory copy of file (may be mmapped)  */
    long		buflen;		/**< @@brief # bytes in 'buf'  */
    int		is_mapped;	/**< @@brief 1=mmap() used, 0=bu_malloc/fread  */
    char		*appl;		/**< @@brief bu_strdup() of tag for application using 'apbuf'  */
    genptr_t	apbuf;		/**< @@brief opt: application-specific buffer  */
    long		apbuflen;	/**< @@brief opt: application-specific buflen  */
    long		modtime;	/**< @@brief date stamp, in case file is modified  */
    int		uses;		/**< @@brief # ptrs to this struct handed out  */
    int		dont_restat;	/**< @@brief 1=on subsequent opens, don't re-stat()  */
};
#define BU_MAPPED_FILE_MAGIC	0x4d617066	/* Mapf */
#define BU_CK_MAPPED_FILE(_p)	BU_CKMAG(_p, BU_MAPPED_FILE_MAGIC, "bu_mapped_file")

/** @@} */
/*----------------------------------------------------------------------*/

/* formerly rt_g.rtg_logindent, now use bu_log_indent_delta() */
typedef int (*bu_hook_t)BU_ARGS((genptr_t, genptr_t));

struct bu_hook_list {
    struct bu_list	l; /**< @@brief linked list  */
    bu_hook_t	hookfunc; /**< @@brief function to call  */
    genptr_t 	clientdata; /**< @@brief data for caller  */
};

#define BUHOOK_NULL 0
#define BUHOOK_LIST_MAGIC	0x90d5dead	/* Nietzsche? */
#define BUHOOK_LIST_NULL	((struct bu_hook_list *) 0)

BU_EXPORT extern struct bu_hook_list bu_log_hook_list;
BU_EXPORT extern struct bu_hook_list bu_bomb_hook_list;

/*----------------------------------------------------------------------*/
/* avs.c */
/** @@addtogroup avs */
/** @@{ */
/*
 *  Attribute/value sets
 */

/**
 *			B U _ A T T R I B U T E _ V A L U E _ P A I R
 *
 *  These strings may or may not be individually allocated,
 *  it depends on usage.
 */
struct bu_attribute_value_pair {
    const char	*name;	/**< @@brief attribute name  */
    const char	*value; /**< @@brief attribute value  */
};

/**
 *			B U _ A T T R I B U T E _ V A L U E _ S E T
 *
 *  A variable-sized attribute-value-pair array.
 *
 *  avp points to an array of [max] slots.
 *  The interface routines will realloc to extend as needed.
 *
 *  In general,
 *  each of the names and values is a local copy made with bu_strdup(),
 *  and each string needs to be freed individually.
 *  However, if a name or value pointer is between
 *  readonly_min and readonly_max, then it is part of a big malloc
 *  block that is being freed by the caller, and should not be individually
 *  freed.
 */
struct bu_attribute_value_set {
	long				magic;
    unsigned int		count;	/**< @@brief # valid entries in avp  */
    unsigned int		max;	/**< @@brief # allocated slots in avp  */
	genptr_t			readonly_min;
	genptr_t			readonly_max;
    struct bu_attribute_value_pair	*avp;	/**< @@brief array[max]  */
};
#define BU_AVS_MAGIC		0x41765321	/* AvS! */
#define BU_CK_AVS(_avp)		BU_CKMAG(_avp, BU_AVS_MAGIC, "bu_attribute_value_set")

#define BU_AVS_FOR(_pp, _avp)	\
	(_pp) = &(_avp)->avp[(_avp)->count-1]; (_pp) >= (_avp)->avp; (_pp)--

/**
 *  Some (but not all) attribute name and value string pointers are
 *  taken from an on-disk format bu_external block,
 *  while others have been bu_strdup()ed and need to be freed.
 *  This macro indicates whether the pointer needs to be freed or not.
 */
#define AVS_IS_FREEABLE(_avsp, _p)	\
	( (_avsp)->readonly_max == NULL || \
	    ((genptr_t)(_p) < (genptr_t)(_avsp)->readonly_min || (genptr_t)(_p) > (genptr_t)(_avsp)->readonly_max) )

/** @@} */
/*----------------------------------------------------------------------*/
/* vls.c */
/** @@addtogroup vls */
/** @@{ */
/*
 *  Variable Length Strings: bu_vls support
 */
struct bu_vls  {
	long	vls_magic;
    char	*vls_str;	/**< @@brief Dynamic memory for buffer  */
    int	vls_offset;	/**< @@brief Offset into vls_str where data is good  */
    int	vls_len;	/**< @@brief Length, not counting the null  */
	int	vls_max;
};
#define BU_VLS_MAGIC		0x89333bbb
#define BU_CK_VLS(_vp)		BU_CKMAG(_vp, BU_VLS_MAGIC, "bu_vls")
#define BU_VLS_IS_INITIALIZED(_vp)	\
	((_vp) && ((_vp)->vls_magic == BU_VLS_MAGIC))

/*
 *  Section for manifest constants for bu_semaphore_acquire()
 */
#define BU_SEM_SYSCALL	0
#define BU_SEM_LISTS	1
#define BU_SEM_BN_NOISE	2
#define BU_SEM_MAPPEDFILE 3
#define BU_SEM_LAST	(BU_SEM_MAPPEDFILE+1)	/* allocate this many for LIBBU+LIBBN */
/*
 *  Automatic restart capability in bu_bomb().
 *  The return from BU_SETJUMP is the return from the setjmp().
 *  It is 0 on the first pass through, and non-zero when
 *  re-entered via a longjmp() from bu_bomb().
 *  This is only safe to use in non-parallel applications.
 */
#define BU_SETJUMP	setjmp((bu_setjmp_valid=1,bu_jmpbuf))
#define BU_UNSETJUMP	(bu_setjmp_valid=0)
/* These are global because BU_SETJUMP must be macro.  Please don't touch. */
BU_EXPORT extern int	bu_setjmp_valid;		/* !0 = bu_jmpbuf is valid */
BU_EXPORT extern jmp_buf	bu_jmpbuf;			/* for BU_SETJMP() */
/** @@} */
/*-------------------------------------------------------------------------*/
/** @@addtogroup mro */
/** @@{ */
/** 			B U _ M R O
 *
 *	Support for Multiply Represented Objects
 */

struct bu_mro {
	long		magic;
	struct bu_vls	string_rep;
	char		long_rep_is_valid;
	long		long_rep;
	char		double_rep_is_valid;
	double		double_rep;
};

#define BU_MRO_MAGIC	0x4D524F4F	/* MROO */
#define BU_CK_MRO(_vp)		BU_CKMAG(_vp, BU_MRO_MAGIC, "bu_mro")

#define BU_MRO_INVALIDATE(_p ) {\
	_p->long_rep_is_valid = '\0';\
	_p->double_rep_is_valid = '\0';\
}

#define BU_MRO_GETDOUBLE( _p ) ( _p->double_rep_is_valid ? _p->double_rep : \
	(_p->double_rep = strtod( bu_vls_addr( &_p->string_rep ), NULL ), \
	( _p->double_rep_is_valid='y', _p->double_rep ) ) )

#define BU_MRO_GETLONG( _p ) ( _p->long_rep_is_valid ? _p->long_rep : \
	(_p->long_rep = strtol( bu_vls_addr( &_p->string_rep ), NULL, 10 ), \
	( _p->long_rep_is_valid='y', _p->long_rep ) ) )

#define BU_MRO_GETSTRING( _p ) bu_vls_addr( &_p->string_rep )

#define BU_MRO_STRLEN( _p ) bu_vls_strlen( &_p->string_rep )
/** @@} */

/*----------------------------------------------------------------------*/
/** @@addtogroup bu_debug Debugging
 * @@ingroup libbu
 */
/** @@{ */
/*
 * Section for BU_DEBUG values
 *
 * These can be set from the command-line of RT-compatible programs
 * using the "-!" option.
 */
BU_EXPORT extern int	bu_debug;
/* These definitions are each for one bit */
#define BU_DEBUG_OFF		0	/* No debugging */

#define BU_DEBUG_COREDUMP	0x00000001	/* bu_bomb() should dump core on exit */
#define BU_DEBUG_MEM_CHECK	0x00000002	/* Mem barrier & leak checking */
#define BU_DEBUG_MEM_LOG	0x00000004	/* Print all dynamic memory operations */
#define BU_DEBUG_DB		0x00000008	/* Database debug logging */

#define BU_DEBUG_PARALLEL	0x00000010	/* Parallel debug logging */
#define BU_DEBUG_MEM_QCHECK	0x00000020	/* Fast mem leak checking (won't work with corruption) */
#define BU_DEBUG_BACKTRACE	0x00000040	/* Log backtrace details during abnormal exit */
#define BU_DEBUG_ATTACH		0x00000080	/* Waits for a debugger to attach during a crash */

#define BU_DEBUG_MATH		0x00000100	/* Fundamental math routines (plane.c, mat.c) */
#define BU_DEBUG_PTBL		0x00000200	/* bu_ptbl_*() logging */
#define BU_DEBUG_AVS		0x00000400	/* bu_avs_*() logging */
#define BU_DEBUG_MAPPED_FILE	0x00000800	/* bu_mapped_file logging */

#define BU_DEBUG_PATHS		0x00001000	/* File and path debug logging */
#define BU_DEBUG_UNUSED_1	0x00002000	/* unused */
#define BU_DEBUG_UNUSED_2	0x00004000	/* unused */
#define BU_DEBUG_UNUSED_3	0x00008000	/* unused */

#define BU_DEBUG_TABDATA	0x00010000	/* LIBBN: tabdata */
#define BU_DEBUG_UNUSED_4	0x00020000	/* unused */
#define BU_DEBUG_UNUSED_5	0x00040000	/* unused */
#define BU_DEBUG_UNUSED_6	0x00080000	/* unused */

/* Format string for bu_printb() */
#define BU_DEBUG_FORMAT	\
"\020\
\025TABDATA\
\015?\
\014MAPPED_FILE\013AVS\012PTBL\011MATH\010?\7?\6MEM_QCHECK\5PARALLEL\
\4?\3MEM_LOG\2MEM_CHECK\1COREDUMP"

/** @@} */
/*----------------------------------------------------------------------*/
/* parse.c */
/** @@addtogroup parse */
/** @@{ */
/*
 *	Structure parse/print
 *
 *  Definitions and data structures needed for routines that assign values
 *  to elements of arbitrary data structures, the layout of which is
 *  described by tables of "bu_structparse" structures.
 */

/**
 * b u _ o f f s e t o f
 * b u _ o f f s e t o f a r r a y
 *
 * The general problem of word-addressed hardware where (int *) and
 * (char *) have different representations is handled in the parsing
 * routines that use sp_offset, because of the limitations placed on
 * compile-time initializers.
 *
 * Files using bu_offsetof or bu_offsetofarray will need to include
 * stddef.h in order to get offsetof()
 */
#ifndef offsetof
#  define bu_offsetof(_t, _m) (size_t)(&(((_t *)0)->_m))
#  define bu_offsetofarray(_t, _m) (size_t)( (((_t *)0)->_m))
#else
#  define bu_offsetof(_t, _m) offsetof(_t, _m)
#  define bu_offsetofarray(_t, _m) offsetof(_t, _m[0])
#endif


/**
 *  b u _ b y t e o f f s e t
 *
 *  Convert address of global data object into byte "offset" from address 0.
 *
 *  Strictly speaking, the C language only permits initializers of the
 *  form: address +- constant, where here the intent is to measure the
 *  byte address of the indicated variable.
 *  Matching compensation code for the CRAY is located in librt/parse.c
 */
#if defined(CRAY)
#	define bu_byteoffset(_i)	(((size_t)&(_i)))	/* actually a word offset */
#else
#  if defined(IRIX) && IRIX > 5 && _MIPS_SIM != _ABIN32 && _MIPS_SIM != _MIPS_SIM_ABI32
#      define bu_byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if defined(sgi) || defined(__convexc__) || defined(ultrix) || defined(_HPUX_SOURCE)
       /* "Lazy" way.  Works on reasonable machines with byte addressing */
#      define bu_byteoffset(_i)	((size_t)((char *)&(_i)))
#    else
#      if defined(__ia64__) || defined(__x86_64__) || defined(__sparc64__)
#        if defined (__INTEL_COMPILER)
#          define bu_byteoffset(_i)	((size_t)((char *)&(_i)))
#        else
#          define bu_byteoffset(_i)	((size_t)(((void *)&(_i))-((void *)0)))
#        endif
#      else
	 /* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#        define bu_byteoffset(_i)	((size_t)(((char *)&(_i))-((char *)0)))
#      endif
#    endif
#  endif
#endif

/**
 * The "bu_structparse" struct describes one element of a structure.
 * Collections of these are combined to describe entire structures (or at
 * least those portions for which parse/print/import/export support is
 * desired.  For example:
 *@@code
  struct data_structure {
	char	a_char;
	char	str[32];
	short	a_short;
	int	a_int;
	double	a_double;
  }

  struct data_structure data_default =
	{ 'c', "the default string", 32767, 1, 1.0 };

  struct data_structure my_values;

  struct bu_structparse data_sp[] ={

  {"%c", 1,  "a_char",   bu_offsetof(data_structure, a_char),
	BU_STRUCTPARSE_FUNC_NULL,
	"a single character",	(void*)&default.a_char },

  {"%s", 32, "str",      bu_offsetofarray(data_structure, str),
	BU_STRUCTPARSE_FUNC_NULL,
	"This is a full character string", (void*)default.str }, },

  {"%i", 1,  "a_short",  bu_offsetof(data_structure, a_short),
	BU_STRUCTPARSE_FUNC_NULL,
	"A 16bit integer",	(void*)&default.a_short },

  {"%d", 1,  "a_int",    bu_offsetof(data_structure, a_int),
	BU_STRUCTPARSE_FUNC_NULL,
	"A full integer",	(void*)&default.a_int },

  {"%f", 1,  "a_double", bu_offsetof(data_structure, a_double),
	BU_STRUCTPARSE_FUNC_NULL,
	"A double-precision floating point value",  (void*)&default.a_double },

  { "", 0, (char *)NULL, 0,
	BU_STRUCTPARSE_FUNC_NULL,
	(char *)NULL, (void *)NULL }

  };
 @@endcode
 *
 * To parse a string, call:
 *
 *	bu_struct_parse( vls_string, data_sp, (char *)my_values)
 *
 * this will parse the vls string and assign values to the members of the
 * structure my_values
 *
 *  A gross hack:  To set global variables (or others for that matter) you
 *	can store the actual address of the variable in the sp_offset field
 *	and pass a null pointer as the last argument to bu_struct_parse().
 *	If you don't understand why this would work, you probably shouldn't
 *	use this technique.
 */
struct bu_structparse {
    char		sp_fmt[4];		/**< @@brief "i" or "%f", etc  */
    long		sp_count;		/**< @@brief number of elements  */
    char		*sp_name;		/**< @@brief Element's symbolic name  */
    long		sp_offset;		/**< @@brief Byte offset in struct  */
    void		(*sp_hook)();		/**< @@brief Optional hooked function, or indir ptr  */
    char		*sp_desc;		/**< @@brief description of element  */
    void		*sp_default;		/**< @@brief ptr to default value  */
};
#define BU_STRUCTPARSE_FUNC_NULL	((void (*)())0)


/*----------------------------------------------------------------------*/
/**
 *			B U _ E X T E R N A L
 *
 *  An "opaque" handle for holding onto objects,
 *  typically in some kind of external form that is not directly
 *  usable without passing through an "importation" function.
 * A "bu_external" struct holds the "external binary" representation of a
 * structure or other block of arbitrary data.
 */
struct bu_external  {
	long	ext_magic;
	long	ext_nbytes;
	genptr_t ext_buf;
};
#define BU_EXTERNAL_MAGIC	0x768dbbd0
#define BU_INIT_EXTERNAL(_p)	{(_p)->ext_magic = BU_EXTERNAL_MAGIC; \
	(_p)->ext_buf = (genptr_t)NULL; (_p)->ext_nbytes = 0;}
#define BU_CK_EXTERNAL(_p)	BU_CKMAG(_p, BU_EXTERNAL_MAGIC, "bu_external")

/** @@} */
/*----------------------------------------------------------------------*/
/* color.c */
#define	HUE		0
#define	SAT		1
#define	VAL		2
#define	ACHROMATIC	-1.0

struct bu_color
{
    long	buc_magic;
    fastf_t	buc_rgb[3];
};
#define	BU_COLOR_MAGIC		0x6275636c
#define	BU_COLOR_NULL		((struct bu_color *) 0)
#define BU_CK_COLOR(_bp)	BU_CKMAG(_bp, BU_COLOR_MAGIC, "bu_color")

/*----------------------------------------------------------------------*/
/* red-black tree support */
/** @@addtogroup rb */
/** @@{ */
/*
 *	The data structures and constants for red-black trees.
 *
 *	Many of these routines are based on the algorithms in chapter 13
 *	of T. H. Cormen, C. E. Leiserson, and R. L. Rivest,
 *	_Introduction to algorithms_, MIT Press, Cambridge, MA, 1990.
 *
 *	Author:	Paul Tanenbaum
 *
 */

/**
 *			    B U _ R B _ L I S T
 *
 *		    List of nodes or packages
 *
 *	The red-black tree package uses this structure to maintain lists
 *	of all the nodes and all the packages in the tree.  Applications
 *	should not muck with these things.  They are maintained only to
 *	facilitate freeing bu_rb_trees.
 */
struct bu_rb_list
{
    struct bu_list	l;
    union
    {
	struct bu_rb_node    *rbl_n;
	struct bu_rb_package *rbl_p;
    }			rbl_u;
};
#define	rbl_magic	l.magic
#define	rbl_node	rbl_u.rbl_n
#define	rbl_package	rbl_u.rbl_p
#define	BU_RB_LIST_NULL	((struct bu_rb_list *) 0)


/**
 *			B U _ R B _ T R E E
 *
 *	This is the only data structure used in the red-black tree package
 *	to which application software need make any explicit reference.
 *
 *	The members of this structure are grouped into three
 *	classes:
 *	    Class I:	Reading is appropriate, when necessary,
 *			but applications should not modify.
 *	    Class II:	Reading and modifying are both appropriate,
 *			when necessary.
 *	    Class III:	All access should be through routines
 *			provided in the package.  Touch these
 *			at your own risk!
 */
typedef struct
{
    /* CLASS I - Applications may read directly. */
    long	 	rbt_magic;	  /**< @@brief  Magic no. for integrity check */
    int			rbt_nm_nodes;	  /**< @@brief  Number of nodes */
    /* CLASS II - Applications may read/write directly. */
    void		(*rbt_print)();	  /**< @@brief  Data pretty-print function */
    int			rbt_debug;	  /**< @@brief  Debug bits */
    char		*rbt_description; /**< @@brief  Comment for diagnostics */
    /* CLASS III - Applications should not manipulate directly. */
    int		 	rbt_nm_orders;	  /**< @@brief  Number of simultaneous orders */
    int			(**rbt_order)();  /**< @@brief  Comparison functions */
    struct bu_rb_node	**rbt_root;	  /**< @@brief  The actual trees */
    char		*rbt_unique;	  /**< @@brief  Uniqueness flags */
    struct bu_rb_node	*rbt_current;	  /**< @@brief  Current node */
    struct bu_rb_list	rbt_nodes;	  /**< @@brief  All nodes */
    struct bu_rb_list	rbt_packages;	  /**< @@brief  All packages */
    struct bu_rb_node	*rbt_empty_node;  /**< @@brief  Sentinel representing nil */
}	bu_rb_tree;
#define	BU_RB_TREE_NULL	((bu_rb_tree *) 0)
#define	BU_RB_TREE_MAGIC	0x72627472

/*
 *	Debug bit flags for member rbt_debug
 */
#define BU_RB_DEBUG_INSERT	0x00000001	/**< @@brief  Insertion process */
#define BU_RB_DEBUG_UNIQ	0x00000002	/**< @@brief  Uniqueness of inserts */
#define BU_RB_DEBUG_ROTATE	0x00000004	/**< @@brief  Rotation process */
#define BU_RB_DEBUG_OS	0x00000008	/**< @@brief  Order-statistic operations */
#define BU_RB_DEBUG_DELETE	0x00000010	/**< @@brief  Deletion process */

/**
 *			B U _ R B _ P A C K A G E
 *
 *		    Wrapper for application data
 *
 *	This structure provides a level of indirection between
 *	the application software's data and the red-black nodes
 *	in which the data is stored.  It is necessary because of
 *	the algorithm for deletion, which generally shuffles data
 *	among nodes in the tree.  The package structure allows
 *	the application data to remember which node "contains" it
 *	for each order.
 */
struct bu_rb_package
{
    long		rbp_magic;	/**< @@brief Magic no. for integrity check  */
    struct bu_rb_node	**rbp_node;	/**< @@brief Containing nodes  */
    struct bu_rb_list	*rbp_list_pos;	/**< @@brief Place in the list of all pkgs.  */
    void		*rbp_data;	/**< @@brief Application data  */
};
#define	BU_RB_PKG_NULL	((struct bu_rb_package *) 0)

/**
 *			    B U _ R B _ N O D E
 *
 *	For the most part, there is a one-to-one correspondence
 *	between nodes and chunks of application data.  When a
 *	node is created, all of its package pointers (one per
 *	order of the tree) point to the same chunk of data.
 *	However, subsequent deletions usually muddy this tidy
 *	state of affairs.
 */
struct bu_rb_node
{
    long		rbn_magic;	/**< @@brief Magic no. for integrity check  */
    bu_rb_tree		*rbn_tree;	/**< @@brief Tree containing this node  */
    struct bu_rb_node	**rbn_parent;	/**< @@brief Parents  */
    struct bu_rb_node	**rbn_left;	/**< @@brief Left subtrees  */
    struct bu_rb_node	**rbn_right;	/**< @@brief Right subtrees  */
    char		*rbn_color;	/**< @@brief Colors of this node  */
    int			*rbn_size;	/**< @@brief Sizes of subtrees rooted here  */
    struct bu_rb_package **rbn_package;	/**< @@brief Contents of this node  */
    int			rbn_pkg_refs;	/**< @@brief How many orders are being used?  */
    struct bu_rb_list	*rbn_list_pos;	/**< @@brief Place in the list of all nodes  */
};
#define	BU_RB_NODE_NULL	((struct bu_rb_node *) 0)

/*
 *	Applications interface to bu_rb_extreme()
 */
#define	SENSE_MIN	0
#define	SENSE_MAX	1
#define	bu_rb_min(t,o)	bu_rb_extreme((t), (o), SENSE_MIN)
#define	bu_rb_max(t,o)	bu_rb_extreme((t), (o), SENSE_MAX)
#define bu_rb_pred(t,o)	bu_rb_neighbor((t), (o), SENSE_MIN)
#define bu_rb_succ(t,o)	bu_rb_neighbor((t), (o), SENSE_MAX)

/*
 *	Applications interface to bu_rb_walk()
 */
#define	PREORDER	0
#define	INORDER		1
#define	POSTORDER	2


/**
 *			B U _ O B S E R V E R
 *
 */
struct bu_observer {
  struct bu_list	l;
  struct bu_vls		observer;
  struct bu_vls		cmd;
};
#define BU_OBSERVER_NULL	((struct bu_observer *)0)

/**
 *			B U _ C M D T A B
 */
struct bu_cmdtab {
  char *ct_name;
  int (*ct_func)();
};

/*----------------------------------------------------------------------*/
/* Miscellaneous macros */
#define bu_made_it()		bu_log("Made it to %s:%d\n",	\
					__FILE__, __LINE__)
/*----------------------------------------------------------------------*/
/*
 *  Declarations of external functions in LIBBU.
 *  Source file names listed alphabetically.
 */
/**@@}*/

/** @@addtogroup avs */
/** @@{ */
/* avs.c */
BU_EXPORT BU_EXTERN(void bu_avs_init,
		    (struct bu_attribute_value_set *avp,
		     int len,
		     const char *str));
BU_EXPORT BU_EXTERN(void bu_avs_init_empty,
		    (struct bu_attribute_value_set *avp));
BU_EXPORT BU_EXTERN(struct bu_attribute_value_set *bu_avs_new,
		    (int len,
		     const char *str));
BU_EXPORT BU_EXTERN(int bu_avs_add,
		    (struct bu_attribute_value_set *avp,
		     const char *attribute,
		     const char *value));
BU_EXPORT BU_EXTERN(int bu_avs_add_vls,
		    (struct bu_attribute_value_set *avp,
		     const char *attribute,
		     const struct bu_vls *value_vls));
BU_EXPORT BU_EXTERN(void bu_avs_merge,
		    (struct bu_attribute_value_set *dest,
		     const struct bu_attribute_value_set *src));
BU_EXPORT BU_EXTERN(const char *bu_avs_get,
		    (const struct bu_attribute_value_set *avp,
		     const char *attribute));
BU_EXPORT BU_EXTERN(int bu_avs_remove,
		    (struct bu_attribute_value_set *avp,
		     const char *attribute));
BU_EXPORT BU_EXTERN(void bu_avs_free,
		    (struct bu_attribute_value_set *avp));
BU_EXPORT BU_EXTERN(void bu_avs_print,
		    (const struct bu_attribute_value_set *avp,
		     const char *title));
BU_EXPORT BU_EXTERN(void bu_avs_add_nonunique,
		    (struct bu_attribute_value_set *avsp,
		     char *attribute,
		     char *value));
/** @@} */

/** @@addtogroup magic */
/** @@{ */
/* badmagic.c */
BU_EXPORT BU_EXTERN(void bu_badmagic,
		    (const long *ptr,
		     unsigned long magic,
		     const char *str,
		     const char *file,
		     int line));
/** @@} */

/** @@addtogroup bitv */
/** @@{ */
/* bitv.c */
BU_EXPORT BU_EXTERN(struct bu_bitv *bu_bitv_new,
		    (unsigned int nbits));
BU_EXPORT BU_EXTERN(void bu_bitv_clear,
		    (struct bu_bitv *bv));
BU_EXPORT BU_EXTERN(void bu_bitv_or,
		    (struct bu_bitv *ov,
		     const struct bu_bitv *iv));
BU_EXPORT BU_EXTERN(void bu_bitv_and,
		    (struct bu_bitv *ov,
		     const struct bu_bitv *iv));
BU_EXPORT BU_EXTERN(void bu_bitv_vls,
		    (struct bu_vls *v,
		     const struct bu_bitv *bv));
BU_EXPORT BU_EXTERN(void bu_pr_bitv,
		    (const char *str,
		     const struct bu_bitv *bv));
BU_EXPORT BU_EXTERN(void bu_bitv_to_hex,
		    (struct bu_vls *v,
		     const struct bu_bitv *bv));
BU_EXPORT BU_EXTERN(struct bu_bitv *bu_hex_to_bitv,
		    (const char *str));
BU_EXPORT BU_EXTERN(struct bu_bitv *bu_bitv_dup,
		    (const struct bu_bitv *bv));
BU_EXPORT BU_EXTERN(void bu_bitv_free,
		    (struct bu_bitv *bv));

/** @@} */
/** @@addtogroup bu_log */
/** @@{ */

/* backtrace.c */
BU_EXPORT BU_EXTERN(int bu_backtrace, (FILE *fp));

/* bomb.c */
BU_EXPORT BU_EXTERN(void bu_bomb, (const char *str)) __BU_ATTR_NORETURN;
BU_EXPORT BU_EXTERN(void bu_exit, (int status, const char *fmt, ...)) __BU_ATTR_NORETURN __BU_ATTR_FORMAT23;

/* crashreport.c */
BU_EXPORT BU_EXTERN(int bu_crashreport, (const char *filename));

/* fgets.c */
BU_EXPORT BU_EXTERN(char *bu_fgets, ( char *s, int size, FILE *stream));

/** @@} */
/** @@addtogroup color */
/** @@{ */

/* color.c */
BU_EXPORT BU_EXTERN(void bu_rgb_to_hsv,
		    (unsigned char *rgb,
		     fastf_t *hsv));
BU_EXPORT BU_EXTERN(int bu_hsv_to_rgb,
		    (fastf_t *hsv,
		     unsigned char *rgb));
BU_EXPORT BU_EXTERN(int bu_str_to_rgb,
		    (char *str,
		     unsigned char *rgb));
BU_EXPORT BU_EXTERN(void bu_color_of_rgb_chars,
		    (struct bu_color *cp,
		     unsigned char *rgb));
BU_EXPORT BU_EXTERN(int bu_color_to_rgb_chars,
		    (struct bu_color *cp,
		     unsigned char *rgb));
BU_EXPORT BU_EXTERN(int bu_color_of_rgb_floats,
		    (struct bu_color *cp,
		     fastf_t *rgb));
BU_EXPORT BU_EXTERN(int bu_color_to_rgb_floats,
		    (struct bu_color *cp,
		     fastf_t *rgb));
BU_EXPORT BU_EXTERN(int bu_color_of_hsv_floats,
		    (struct bu_color *cp,
		     fastf_t *hsv));
BU_EXPORT BU_EXTERN(int bu_color_to_hsv_floats,
		    (struct bu_color *cp,
		     fastf_t *hsv));
/** @@} */
/** @@addtogroup bu_log */
/** @@{ */

/* stat.c */
BU_EXPORT BU_EXTERN(int	bu_file_exists, (const char *path));
BU_EXPORT BU_EXTERN(int	bu_same_file, (const char *fn1, const char *fn2));
BU_EXPORT BU_EXTERN(int	bu_same_fd, (int fd1, int fd2));
BU_EXPORT BU_EXTERN(int	bu_file_readable, (const char *path));
BU_EXPORT BU_EXTERN(int	bu_file_writable, (const char *path));
BU_EXPORT BU_EXTERN(int	bu_file_executable, (const char *path));

/* brlcad_path.c */
BU_EXPORT BU_EXTERN(const char *bu_argv0, (void));
BU_EXPORT BU_EXTERN(const char *bu_argv0_full_path, (void));
BU_EXPORT BU_EXTERN(const char *bu_getprogname, (void));
BU_EXPORT BU_EXTERN(void bu_setprogname, (const char *path));
BU_EXPORT BU_EXTERN(char *bu_brlcad_root,
		    (const char *rhs, int fail_quietly));
BU_EXPORT BU_EXTERN(char *bu_brlcad_data,
		    (const char *rhs, int fail_quietly));

/* bu_which.c */
BU_EXPORT BU_EXTERN(const char *bu_which, (const char *cmd));

/* bu_whereis.c */
BU_EXPORT BU_EXTERN(const char *bu_whereis, (const char *cmd));

/* fopen_uniq */
BU_EXPORT BU_EXTERN(FILE *bu_fopen_uniq,
		    (const char *outfmt,
		     const char *namefmt,
		     int n));

/* temp.c */
BU_EXPORT BU_EXTERN(FILE *bu_temp_file, (char *filepath, int len));

/** @@} */
/** @@addtogroup getopt */
/** @@{ */

/* getopt.c */
BU_EXPORT extern int			bu_opterr;
BU_EXPORT extern int			bu_optind;
BU_EXPORT extern int			bu_optopt;
BU_EXPORT extern char *			bu_optarg;
BU_EXPORT BU_EXTERN(int	bu_getopt,
		    (int nargc, char * const nargv[],
		     const char *ostr));

/** @@} */
/** @@addtogroup bu_hist */
/** @@{ */

/* hist.c */
BU_EXPORT BU_EXTERN(void bu_hist_free,
		    (struct bu_hist *histp));
BU_EXPORT BU_EXTERN(void bu_hist_init,
		    (struct bu_hist *histp,
		     fastf_t min,
		     fastf_t max,
		     unsigned int nbins));
BU_EXPORT BU_EXTERN(void bu_hist_range,
		    (struct bu_hist *hp,
		     fastf_t low,
		     fastf_t high));
BU_EXPORT BU_EXTERN(void bu_hist_pr,
		    (const struct bu_hist *histp,
		     const char *title));

/** @@} */
/** @@addtogroup hton */
/** @@{ */

/* htond.c */
BU_EXPORT BU_EXTERN(void htond,
		    (unsigned char *out,
		     const unsigned char *in,
		     int count));
BU_EXPORT BU_EXTERN(void ntohd,
		    (unsigned char *out,
		     const unsigned char *in,
		     int count));

/* htonf.c */
BU_EXPORT BU_EXTERN(void htonf,
		    (unsigned char *out,
		     const unsigned char *in,
		     int count));
BU_EXPORT BU_EXTERN(void ntohf,
		    (unsigned char *out,
		     const unsigned char *in,
		     int count));

/** @@} */
/** @@addtogroup thread */
/** @@{ */

/* ispar.c */
BU_EXPORT BU_EXTERN(int	bu_is_parallel,
		    ());
BU_EXPORT BU_EXTERN(void bu_kill_parallel,
		    ());

/** @@} */
/** @@addtogroup bu_log */
/** @@{ */

/* linebuf.c */
BU_EXPORT BU_EXTERN(void bu_setlinebuf,
		    (FILE *fp));

/** @@} */
/** @@addtogroup bu_list */
/** @@{ */

/* list.c */
BU_EXPORT BU_EXTERN(int bu_list_len,
		    (const struct bu_list *hd));
BU_EXPORT BU_EXTERN(void bu_list_reverse,
		    (struct bu_list *hd));
BU_EXPORT BU_EXTERN(void bu_list_free,
		    (struct bu_list *hd));
BU_EXPORT BU_EXTERN(void bu_list_parallel_append,
		    (struct bu_list *headp,
		     struct bu_list *itemp));
BU_EXPORT BU_EXTERN(struct bu_list *bu_list_parallel_dequeue,
		    (struct bu_list *headp));
BU_EXPORT BU_EXTERN(void bu_ck_list,
		    (const struct bu_list *hd,
		     const char *str));
BU_EXPORT BU_EXTERN(void bu_ck_list_magic,
		    (const struct bu_list *hd,
		     const char *str,
		     const long magic));

/** @@} */
/** @@addtogroup bu_log */
/** @@{ */
/* hook.c */
BU_EXPORT BU_EXTERN(void bu_hook_list_init,
		    (struct bu_hook_list *hlp));
BU_EXPORT BU_EXTERN(void bu_add_hook,
		    (struct bu_hook_list *hlp,
		     bu_hook_t func,
		     genptr_t clientdata));
BU_EXPORT BU_EXTERN(void bu_delete_hook,
		    (struct bu_hook_list *hlp,
		     bu_hook_t func,
		     genptr_t clientdata));
BU_EXPORT BU_EXTERN(void bu_call_hook,
		    (struct bu_hook_list *hlp,
		     genptr_t buf));

/** @@} */
/** @@addtogroup bu_log */
/** @@{ */
/* log.c */
BU_EXPORT BU_EXTERN(void bu_log_indent_delta,
		    (int delta));
BU_EXPORT BU_EXTERN(void bu_log_indent_vls,
		    (struct bu_vls *v));
BU_EXPORT BU_EXTERN(void bu_log_add_hook,
		    (bu_hook_t func,
		     genptr_t clientdata));
BU_EXPORT BU_EXTERN(void bu_log_delete_hook,
		    (bu_hook_t func,
		     genptr_t clientdata));
BU_EXPORT BU_EXTERN(void bu_putchar, (int c));
BU_EXPORT BU_EXTERN(void bu_log, (char *, ... )) __BU_ATTR_FORMAT12;
BU_EXPORT BU_EXTERN(void bu_flog, (FILE *, char *, ... )) __BU_ATTR_FORMAT23;

/** @@} */
/** @@addtogroup magic */
/** @@{ */

/* magic.c */
BU_EXPORT BU_EXTERN(const char *bu_identify_magic,
		    (long magic));

/** @@} */
/** @@addtogroup malloc */
/** @@{ */

/* malloc.c */
BU_EXPORT extern long		bu_n_malloc;
BU_EXPORT extern long		bu_n_free;
BU_EXPORT extern long		bu_n_realloc;
BU_EXPORT BU_EXTERN(genptr_t bu_malloc,
		    (size_t siz,
		     const char *str));
BU_EXPORT BU_EXTERN(void bu_free,
		    (genptr_t ptr,
		     const char *str));
BU_EXPORT BU_EXTERN(genptr_t bu_realloc,
		    (genptr_t ptr,
		     size_t cnt,
		     const char *str));
BU_EXPORT BU_EXTERN(genptr_t bu_calloc,
		    (unsigned int nelem,
		     size_t elsize,
		     const char *str));
BU_EXPORT BU_EXTERN(void bu_prmem,
		    (const char *str));

/* don't rely on non-constness of bu_dirname().. will change to const */
BU_EXPORT BU_EXTERN(char *bu_dirname,
		    (const char *cp));
BU_EXPORT BU_EXTERN(const char *bu_basename,
		    (const char *cp));
BU_EXPORT BU_EXTERN(int bu_malloc_len_roundup,
		    (int nbytes));
BU_EXPORT BU_EXTERN(void bu_ck_malloc_ptr,
		    (genptr_t ptr, const char *str));
BU_EXPORT BU_EXTERN(int	bu_mem_barriercheck,
		    ());

/** @@} */
/** @@addtogroup mf */
/** @@{ */

/* mappedfile.c */
BU_EXPORT BU_EXTERN(struct bu_mapped_file *bu_open_mapped_file,
		    (const char *name,
		     const char *appl));
BU_EXPORT BU_EXTERN(void bu_close_mapped_file,
		    (struct bu_mapped_file *mp));
BU_EXPORT BU_EXTERN(void bu_pr_mapped_file,
		    (const char *title,
		     const struct bu_mapped_file *mp));
BU_EXPORT BU_EXTERN(void bu_free_mapped_files,
		    (int verbose));
BU_EXPORT BU_EXTERN(struct bu_mapped_file *bu_open_mapped_file_with_path,
		    (char * const *path,
		     const char *name,
		     const char *appl));


/** @@} */
/** @@addtogroup thread */
/** @@{ */

/* kill.c */
BU_EXPORT BU_EXTERN(int bu_terminate, (int process));

/* process.c */
BU_EXPORT BU_EXTERN(int bu_process_id, ());

/* parallel.c */
BU_EXPORT BU_EXTERN(void bu_nice_set, (int newnice));
BU_EXPORT BU_EXTERN(int bu_cpulimit_get, ());
BU_EXPORT BU_EXTERN(void bu_cpulimit_set, (int sec));
BU_EXPORT BU_EXTERN(int bu_avail_cpus, ());
BU_EXPORT BU_EXTERN(fastf_t bu_get_load_average, ());
BU_EXPORT BU_EXTERN(int bu_get_public_cpus, ());
BU_EXPORT BU_EXTERN(int bu_set_realtime, ());
BU_EXPORT BU_EXTERN(void bu_parallel,
		    (void (*func)BU_ARGS((int ncpu, genptr_t arg)),
		     int ncpu,
		     genptr_t arg));

/** @@} */
/** @@addtogroup parse */
/** @@{ */

/* parse.c */
BU_EXPORT BU_EXTERN(int bu_struct_export,
		    (struct bu_external *ext,
		     const genptr_t base,
		     const struct bu_structparse *imp));
BU_EXPORT BU_EXTERN(int bu_struct_import,
		    (genptr_t base,
		     const struct bu_structparse *imp,
		     const struct bu_external *ext));
BU_EXPORT BU_EXTERN(int bu_struct_put,
		    (FILE *fp,
		     const struct bu_external *ext));
BU_EXPORT BU_EXTERN(int bu_struct_get,
		    (struct bu_external *ext,
		     FILE *fp));
BU_EXPORT BU_EXTERN(void bu_struct_wrap_buf,
		    (struct bu_external *ext,
		     genptr_t buf));
BU_EXPORT BU_EXTERN(int bu_struct_parse,
		    (const struct bu_vls *in_vls,
		     const struct bu_structparse *desc,
		     const char *base));
BU_EXPORT BU_EXTERN(void bu_struct_print,
		    (const char *title,
		     const struct bu_structparse *parsetab,
		     const char *base));
BU_EXPORT BU_EXTERN(void bu_vls_struct_print,
		    (struct bu_vls *vls,
		     const struct bu_structparse *sdp,
		     const char *base));
BU_EXPORT BU_EXTERN(void bu_vls_struct_print2,
		    (struct bu_vls *vls,
		     const char *title,
		     const struct bu_structparse *sdp,
		     const char *base));
BU_EXPORT BU_EXTERN(void bu_vls_struct_item,
		    (struct bu_vls *vp,
		     const struct bu_structparse *sdp,
		     const char *base,
		     int sep_char));
BU_EXPORT BU_EXTERN(int bu_vls_struct_item_named,
		    (struct bu_vls *vp,
		     const struct bu_structparse *sdp,
		     const char *name,
		     const char *base,
		     int sep_char));
BU_EXPORT BU_EXTERN(void bu_parse_mm,
		    (const struct bu_structparse *sdp,
		     const char *name,
		     char *base,
		     const char *value));
BU_EXPORT BU_EXTERN(int bu_key_eq_to_key_val,
		    (char *in,
		     char **next,
		     struct bu_vls *vls));
BU_EXPORT BU_EXTERN(int bu_shader_to_tcl_list,
		    (char *in,
		     struct bu_vls *vls));
BU_EXPORT BU_EXTERN(int bu_key_val_to_key_eq,
		    (char *in));
BU_EXPORT BU_EXTERN(int bu_shader_to_key_eq,
		    (char *in, struct bu_vls *vls));
BU_EXPORT BU_EXTERN(int bu_fwrite_external,
		    (FILE *fp,
		     const struct bu_external *ep));
BU_EXPORT BU_EXTERN(void bu_hexdump_external,
		    (FILE *fp, const struct bu_external *ep,
		     const char *str));
BU_EXPORT BU_EXTERN(void bu_free_external,
		    (struct bu_external *ep));
BU_EXPORT BU_EXTERN(void bu_copy_external,
		    (struct bu_external *op,
		     const struct bu_external *ip));
BU_EXPORT BU_EXTERN(char *bu_next_token,
		    (char *str));

/** @@} */
/** @@addtogroup bitv */
/** @@{ */

/* printb.c */
BU_EXPORT BU_EXTERN(void bu_vls_printb,
		    (struct bu_vls *vls,
		     const char *s, unsigned long v,
		     const char *bits));
BU_EXPORT BU_EXTERN(void bu_printb,
		    (const char *s,
		     unsigned long v,
		     const char *bits));

/* ptbl.c */
BU_EXPORT BU_EXTERN(void bu_ptbl_init,
		    (struct bu_ptbl *b,
		     int len,
		     const char *str));
BU_EXPORT BU_EXTERN(void bu_ptbl_reset,
		    (struct bu_ptbl	*b));
BU_EXPORT BU_EXTERN(int bu_ptbl_ins,
		    (struct bu_ptbl *b,
		     long *p));
BU_EXPORT BU_EXTERN(int bu_ptbl_locate,
		    (const struct bu_ptbl *b,
		     const long *p));
BU_EXPORT BU_EXTERN(void bu_ptbl_zero,
		    (struct bu_ptbl *b,
		     const long *p));
BU_EXPORT BU_EXTERN(int bu_ptbl_ins_unique,
		    (struct bu_ptbl *b, long *p));
BU_EXPORT BU_EXTERN(int bu_ptbl_rm,
		    (struct bu_ptbl *b,
		     const long *p));
BU_EXPORT BU_EXTERN(void bu_ptbl_cat,
		    (struct bu_ptbl *dest,
		     const struct bu_ptbl *src));
BU_EXPORT BU_EXTERN(void bu_ptbl_cat_uniq,
		    (struct bu_ptbl *dest,
		     const struct bu_ptbl *src));
BU_EXPORT BU_EXTERN(void bu_ptbl_free,
		    (struct bu_ptbl	*b));
BU_EXPORT BU_EXTERN(int bu_ptbl,
		    (struct bu_ptbl *b,
		     int func, long *p));
BU_EXPORT BU_EXTERN(void bu_pr_ptbl,
		    (const char *title,
		     const struct bu_ptbl *tbl,
		     int verbose));
BU_EXPORT BU_EXTERN(void bu_ptbl_trunc,
		    (struct bu_ptbl *tbl,
		     int end));

/** @@} */
/** @@addtogroup rb */
/** @@{ */

/* rb_create.c */
BU_EXPORT BU_EXTERN(bu_rb_tree *bu_rb_create,
		    (char		*description,
		     int 		nm_orders,
		     int		(**order_funcs)()));
BU_EXPORT BU_EXTERN(bu_rb_tree *bu_rb_create1,
		    (char		*description,
		     int		(*order_func)()));
/* rb_delete.c */
BU_EXPORT BU_EXTERN(void bu_rb_delete,
		    (bu_rb_tree	*tree,
		     int	order));
#define		bu_rb_delete1(t)	bu_rb_delete((t), 0)

/* rb_diag.c */
BU_EXPORT BU_EXTERN(void bu_rb_diagnose_tree,
		    (bu_rb_tree	*tree,
		     int	order,
		     int	trav_type));
BU_EXPORT BU_EXTERN(void bu_rb_summarize_tree,
		    (bu_rb_tree	*tree));
/* rb_extreme.c */
BU_EXPORT BU_EXTERN(void *bu_rb_curr,
		    (bu_rb_tree	*tree,
		     int		order));
#define		bu_rb_curr1(t)	bu_rb_curr((t), 0)
BU_EXPORT BU_EXTERN(void *bu_rb_extreme,
		    (bu_rb_tree	*tree,
		     int	order,
		     int	sense));
BU_EXPORT BU_EXTERN(void *bu_rb_neighbor,
		    (bu_rb_tree	*tree,
		     int	order,
		     int	sense));
/* rb_free.c */
BU_EXPORT BU_EXTERN(void bu_rb_free,
		    (bu_rb_tree	*tree,
		     void	(*free_data)()));
#define	BU_RB_RETAIN_DATA	((void (*)()) 0)
#define		bu_rb_free1(t,f)					\
		{							\
		    BU_CKMAG((t), BU_RB_TREE_MAGIC, "red-black tree");	\
		    bu_free((char *) ((t) -> rbt_order),		\
				"red-black order function");		\
		    bu_rb_free(t,f);					\
		}
/* rb_insert.c */
BU_EXPORT BU_EXTERN(int bu_rb_insert,
		    (bu_rb_tree	*tree,
		     void	*data));
BU_EXPORT BU_EXTERN(int bu_rb_is_uniq,
		    (bu_rb_tree	*tree,
		     int	order));
#define		bu_rb_is_uniq1(t)	bu_rb_is_uniq((t), 0)
BU_EXPORT BU_EXTERN(void bu_rb_set_uniqv,
		    (bu_rb_tree	*tree,
		     bitv_t	vec));
BU_EXPORT BU_EXTERN(void bu_rb_uniq_all_off,
		    (bu_rb_tree	*tree));
BU_EXPORT BU_EXTERN(void bu_rb_uniq_all_on,
		    (bu_rb_tree	*tree));
BU_EXPORT BU_EXTERN(int bu_rb_uniq_off,
		    (bu_rb_tree	*tree,
		     int	order));
#define		bu_rb_uniq_off1(t)	bu_rb_uniq_off((t), 0)
BU_EXPORT BU_EXTERN(int bu_rb_uniq_on,
		    (bu_rb_tree	*tree,
		     int	order));
#define		bu_rb_uniq_on1(t)	bu_rb_uniq_on((t), 0)

/* rb_order_stats.c */
BU_EXPORT BU_EXTERN(int bu_rb_rank,
		    (bu_rb_tree	*tree,
		     int	order));
#define		bu_rb_rank1(t)	bu_rb_rank1((t), 0)
BU_EXPORT BU_EXTERN(void *bu_rb_select,
		    (bu_rb_tree	*tree,
		     int	order,
		     int	k));
#define		bu_rb_select1(t,k)	bu_rb_select((t), 0, (k))

/* rb_search.c */
BU_EXPORT BU_EXTERN(void *bu_rb_search,
		    (bu_rb_tree	*tree,
		     int	order,
		     void	*data));
#define		bu_rb_search1(t,d)	bu_rb_search((t), 0, (d))

/* rb_walk.c */
BU_EXPORT BU_EXTERN(void bu_rb_walk,
		    (bu_rb_tree	*tree,
		     int	order,
		     void	(*visit)(),
		     int	trav_type));
#define		bu_rb_walk1(t,v,d)	bu_rb_walk((t), 0, (v), (d))

/** @@} */
/** @@addtogroup thread */
/** @@{ */

/* semaphore.c */
BU_EXPORT BU_EXTERN(void bu_semaphore_init,
		    (unsigned int nsemaphores));
BU_EXPORT BU_EXTERN(void bu_semaphore_acquire,
		    (unsigned int i));
BU_EXPORT BU_EXTERN(void bu_semaphore_release,
		    (unsigned int i));

/** @@} */
/** @@addtogroup vls */
/** @@{ */

/* vls.c */
BU_EXPORT BU_EXTERN(void bu_vls_init,
		    (struct bu_vls *vp));
BU_EXPORT BU_EXTERN(void bu_vls_init_if_uninit,
		    (struct bu_vls *vp));
BU_EXPORT BU_EXTERN(struct bu_vls *bu_vls_vlsinit,
		    ());
BU_EXPORT BU_EXTERN(char *bu_vls_addr,
		    (const struct bu_vls *vp));
BU_EXPORT BU_EXTERN(char *bu_vls_strdup,
		    (const struct bu_vls *vp));
BU_EXPORT BU_EXTERN(char *bu_vls_strgrab,
		    (struct bu_vls *vp));
BU_EXPORT BU_EXTERN(void bu_vls_extend,
		    (struct bu_vls *vp,
		     unsigned int extra));
BU_EXPORT BU_EXTERN(void bu_vls_setlen,
		    (struct bu_vls *vp,
		     int newlen));
BU_EXPORT BU_EXTERN(int bu_vls_strlen,
		    (const struct bu_vls *vp));
BU_EXPORT BU_EXTERN(void bu_vls_trunc,
		    (struct bu_vls *vp,
		     int len));
BU_EXPORT BU_EXTERN(void bu_vls_trunc2,
		    (struct bu_vls *vp,
		     int len));
BU_EXPORT BU_EXTERN(void bu_vls_nibble,
		    (struct bu_vls *vp,
		     int len));
BU_EXPORT BU_EXTERN(void bu_vls_free,
		    (struct bu_vls *vp));
BU_EXPORT BU_EXTERN(void bu_vls_vlsfree,
		    (struct bu_vls *vp));
BU_EXPORT BU_EXTERN(void bu_vls_strcpy,
		    (struct bu_vls *vp,
		     const char *s));
BU_EXPORT BU_EXTERN(void bu_vls_strncpy,
		    (struct bu_vls *vp,
		     const char *s,
		     long n));
BU_EXPORT BU_EXTERN(void bu_vls_strcat,
		    (struct bu_vls *vp,
		     const char *s));
BU_EXPORT BU_EXTERN(void bu_vls_strncat,
		    (struct bu_vls *vp,
		     const char *s,
		     long n));
BU_EXPORT BU_EXTERN(void bu_vls_vlscat,
		    (struct bu_vls *dest,
		     const struct bu_vls *src));
BU_EXPORT BU_EXTERN(void bu_vls_vlscatzap,
		    (struct bu_vls *dest,
		     struct bu_vls *src));
BU_EXPORT BU_EXTERN(int bu_vls_strcmp,
		    (struct bu_vls *s1,
		     struct bu_vls *s2));
BU_EXPORT BU_EXTERN(int bu_vls_strncmp,
		    (struct bu_vls *s1,
		     struct bu_vls *s2,
		     long n));
BU_EXPORT BU_EXTERN(void bu_vls_from_argv,
		    (struct bu_vls *vp,
		     int argc,
		     const char *argv[]));
BU_EXPORT BU_EXTERN(int bu_argv_from_string,
		    (char **argv,
		     int lim,
		     char *lp));
BU_EXPORT BU_EXTERN(void bu_vls_fwrite,
		    (FILE *fp,
		     const struct bu_vls *vp));
BU_EXPORT BU_EXTERN(void bu_vls_write,
		    (int fd,
		     const struct bu_vls *vp));
BU_EXPORT BU_EXTERN(int bu_vls_read,
		    (struct bu_vls *vp,
		     int fd));
BU_EXPORT BU_EXTERN(int bu_vls_gets,
		    (struct bu_vls *vp,
		     FILE *fp));
BU_EXPORT BU_EXTERN(void bu_vls_putc,
		    (struct bu_vls *vp,
		     int c));
BU_EXPORT BU_EXTERN(void bu_vls_trimspace,
		    (struct bu_vls *vp));

BU_EXPORT BU_EXTERN(void bu_vls_vprintf,
		    (struct bu_vls *vls,
		     const char *fmt,
		     va_list ap));

BU_EXPORT BU_EXTERN(void bu_vls_printf,
		    (struct bu_vls *vls,
		     char *fmt, ...)) __BU_ATTR_FORMAT23;
BU_EXPORT BU_EXTERN(void bu_vls_sprintf,
		    (struct bu_vls *vls,
		     char *fmt, ...)) __BU_ATTR_FORMAT23;

BU_EXPORT BU_EXTERN(void bu_vls_spaces,
		    (struct bu_vls *vp,
		     int cnt));
BU_EXPORT BU_EXTERN(int bu_vls_print_positions_used,
		    (const struct bu_vls *vp));
BU_EXPORT BU_EXTERN(void bu_vls_detab,
		    (struct bu_vls *vp));
BU_EXPORT BU_EXTERN(void bu_vls_prepend,
		    (struct bu_vls *vp,
		     char *str));

/* str.c */
BU_EXPORT BU_EXTERN(size_t bu_strlcatm, (char *dst, const char *src, size_t size, const char *label));
#define bu_strlcat(dst, src, size) bu_strlcatm(dst, src, size, BU_FLSTR)

BU_EXPORT BU_EXTERN(size_t bu_strlcpym, (char *dst, const char *src, size_t size, const char *label));
#define bu_strlcpy(dst, src, size) bu_strlcpym(dst, src, size, BU_FLSTR)

BU_EXPORT BU_EXTERN(char *bu_strdupm, (const char *cp, const char *label));
#define bu_strdup(s) bu_strdupm(s, BU_FLSTR)


/** @@} */

/** @@addtogroup bu_log */
/** @@{ */
/* units.c */
BU_EXPORT BU_EXTERN(double bu_units_conversion,
		    (const char *str));
BU_EXPORT BU_EXTERN(const char *bu_units_string,
		    (const double mm));
BU_EXPORT BU_EXTERN(double bu_mm_value,
		    (const char *s));
BU_EXPORT BU_EXTERN(void bu_mm_cvt,
		    (register const struct bu_structparse *sdp,
		     register const char *name,
		     char *base,
		     const char *value));

/** @@} */

/** @@addtogroup hton */
/** @@{ */

/* xdr.c */
/* Macro version of library routine bu_glong() */
/* The argument is expected to be of type "unsigned char" */
#define BU_GLONGLONG(_cp)	\
	    ((((long)((_cp)[0])) << 56) |	\
	     (((long)((_cp)[1])) << 48) |	\
	     (((long)((_cp)[2])) << 40) |	\
	     (((long)((_cp)[3])) << 32) |	\
	     (((long)((_cp)[4])) << 24) |	\
	     (((long)((_cp)[5])) << 16) |	\
	     (((long)((_cp)[6])) <<  8) |	\
	      ((long)((_cp)[7])) )
#define BU_GLONG(_cp)	\
	    ((((long)((_cp)[0])) << 24) |	\
	     (((long)((_cp)[1])) << 16) |	\
	     (((long)((_cp)[2])) <<  8) |	\
	      ((long)((_cp)[3])) )
#define BU_GSHORT(_cp)	\
	    ((((short)((_cp)[0])) << 8) | \
		       (_cp)[1] )

BU_EXPORT BU_EXTERN(unsigned short bu_gshort,
		    (const unsigned char *msgp));
BU_EXPORT BU_EXTERN(unsigned long bu_glong,
		    (const unsigned char *msgp));
BU_EXPORT BU_EXTERN(unsigned char *bu_pshort,
		    (register unsigned char *msgp,
		     register int s));
BU_EXPORT BU_EXTERN(unsigned char *bu_plong,
		    (register unsigned char *msgp,
		     register unsigned long l));

/** @@} */

/** @@addtogroup bu_log */
/** @@{ */

/* association.c */
BU_EXPORT BU_EXTERN(struct bu_vls *bu_association,
		    (const char *fname,
		     const char *value,
		     int field_sep));

/** @@} */

/** @@addtogroup butcl */
/** @@{ */

/* Things that live in libbu/observer.c */
BU_EXPORT extern struct bu_cmdtab bu_observer_cmds[];
BU_EXPORT BU_EXTERN(void bu_observer_notify,
		    ());
BU_EXPORT BU_EXTERN(void bu_observer_free,
		    (struct bu_observer *));

/* bu_tcl.c */
/* The presence of Tcl_Interp as an arg prevents giving arg list */
BU_EXPORT BU_EXTERN(void bu_badmagic_tcl,
		    (Tcl_Interp	*interp,
		     const long	*ptr,
		     unsigned long	magic,
		     const char	*str,
		     const char	*file,
		     int	line));

BU_EXPORT BU_EXTERN(void bu_structparse_get_terse_form,
		    (Tcl_Interp	*interp,
		     const struct bu_structparse *sp));

BU_EXPORT BU_EXTERN(int bu_structparse_argv,
		    (Tcl_Interp				*interp,
		     int				argc,
		     char				**argv,
		     const struct bu_structparse	*desc,
		     char				*base));

BU_EXPORT BU_EXTERN(int bu_tcl_mem_barriercheck,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_ck_malloc_ptr,
		    (ClientData		clientData,
		     Tcl_Interp		*interp,
		     int		argc,
		     char		**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_malloc_len_roundup,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_prmem,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_printb,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_get_value_by_keyword,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_get_all_keyword_values,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_rgb_to_hsv,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_hsv_to_rgb,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_key_eq_to_key_val,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_shader_to_key_val,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_key_val_to_key_eq,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_shader_to_key_eq,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_brlcad_root,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	 argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_brlcad_data,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	 argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(int bu_tcl_units_conversion,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	argc,
		     char	**argv));

BU_EXPORT BU_EXTERN(void bu_tcl_setup,
		    (Tcl_Interp *interp));

#ifdef BRLCAD_DEBUG
BU_EXPORT BU_EXTERN(int Bu_d_Init,
		    (Tcl_Interp *interp));
#else
BU_EXPORT BU_EXTERN(int Bu_Init,
		    (Tcl_Interp *interp));
#endif


/** @@} */
/** @@addtogroup bu_log */
/** @@{ */

/* lex.c */
#define BU_LEX_ANY	0	/* pseudo type */
struct bu_lex_t_int {
	int type;
	int value;
};
#define BU_LEX_INT	1
struct bu_lex_t_dbl {
	int	type;
	double	value;
};
#define BU_LEX_DOUBLE	2
struct bu_lex_t_key {
	int	type;
	int	value;
};
#define BU_LEX_SYMBOL	3
#define BU_LEX_KEYWORD	4
struct bu_lex_t_id {
	int	type;
	char 	*value;
};
#define BU_LEX_IDENT	5
#define BU_LEX_NUMBER	6	/* Pseudo type */
union bu_lex_token {
	int			type;
	struct	bu_lex_t_int	t_int;
	struct	bu_lex_t_dbl	t_dbl;
	struct	bu_lex_t_key	t_key;
	struct	bu_lex_t_id	t_id;
};
struct bu_lex_key {
	int	tok_val;
	char	*string;
};
#define BU_LEX_NEED_MORE	0

BU_EXPORT BU_EXTERN(int bu_lex,
		    (union bu_lex_token *token,
		     struct bu_vls *rtstr,
		     struct bu_lex_key *keywords,
		     struct bu_lex_key *symbols));


/* mread.c */
BU_EXPORT BU_EXTERN(long int bu_mread,
		    (int fd, void *bufp, long int n));

/* mro.c */
BU_EXPORT BU_EXTERN(void bu_mro_init_with_string,
		    (struct bu_mro *mrop, const char *string));
BU_EXPORT BU_EXTERN(void bu_mro_set,
		    (struct bu_mro *mrop,
		     const char *string));
BU_EXPORT BU_EXTERN(void bu_mro_init,
		    (struct bu_mro *mrop));
BU_EXPORT BU_EXTERN(void bu_mro_free,
		    (struct bu_mro *mrop));


/** @@} */
/** @@addtogroup bu_hash */
/** @@{ */


/* hash.c */
struct bu_hash_entry {
	long magic;
	unsigned char *key;
	unsigned char *value;
	int key_len;
	struct bu_hash_entry *next;
};

struct bu_hash_tbl {
	long magic;
	unsigned long mask;
	unsigned long num_lists;
	unsigned long num_entries;
	struct bu_hash_entry **lists;
};

struct bu_hash_record {
	long magic;
	struct bu_hash_tbl *tbl;
	unsigned long index;
	struct bu_hash_entry *hsh_entry;
};

#define BU_HASH_TBL_MAGIC	0x48415348	/* "HASH" */
#define BU_HASH_RECORD_MAGIC	0x68617368	/* "hash" */
#define BU_HASH_ENTRY_MAGIC	0x48454E54	/* "HENT" */
#define BU_CK_HASH_TBL(_hp)	BU_CKMAG( _hp, BU_HASH_TBL_MAGIC, "bu_hash_tbl" )
#define BU_CK_HASH_RECORD(_rp)	BU_CKMAG( _rp, BU_HASH_RECORD_MAGIC, "bu_hash_record" )
#define BU_CK_HASH_ENTRY(_ep)	BU_CKMAG( _ep, BU_HASH_ENTRY_MAGIC, "bu_hash_entry" )

BU_EXPORT BU_EXTERN(unsigned long bu_hash,
		    (unsigned char *str,
		     int len));
BU_EXPORT BU_EXTERN(struct bu_hash_tbl *bu_create_hash_tbl,
		    (unsigned long tbl_size));
BU_EXPORT BU_EXTERN(struct bu_hash_entry *bu_find_hash_entry,
		    (struct bu_hash_tbl *hsh_tbl,
		     unsigned char *key,
		     int key_len,
		     struct bu_hash_entry **prev,
		     unsigned long *index2));
BU_EXPORT BU_EXTERN(void bu_set_hash_value,
		    (struct bu_hash_entry *hsh_entry,
		     unsigned char *value));
BU_EXPORT BU_EXTERN(unsigned char *bu_get_hash_value,
		    (struct bu_hash_entry *hsh_entry));
BU_EXPORT BU_EXTERN(unsigned char *bu_get_hash_key,
		    (struct bu_hash_entry *hsh_entry));
BU_EXPORT BU_EXTERN(struct bu_hash_entry *bu_hash_add_entry,
		    (struct bu_hash_tbl *hsh_tbl,
		     unsigned char *key,
		     int key_len,
		     int *new_entry));
BU_EXPORT BU_EXTERN(void bu_hash_tbl_pr,
		    (struct bu_hash_tbl *hsh_tbl,
		     char *str));
BU_EXPORT BU_EXTERN(void bu_hash_tbl_free,
		    (struct bu_hash_tbl *hsh_tbl));
BU_EXPORT BU_EXTERN(struct bu_hash_entry *bu_hash_tbl_first,
		    (struct bu_hash_tbl *hsh_tbl,
		     struct bu_hash_record *rec));
BU_EXPORT BU_EXTERN(struct bu_hash_entry *bu_hash_tbl_next,
		    (struct bu_hash_record *rec));


/* image utilities */

enum {
    BU_IMAGE_AUTO,
    BU_IMAGE_PIX,
    BU_IMAGE_BW,
    BU_IMAGE_ALIAS,
    BU_IMAGE_BMP,
    BU_IMAGE_CI,
    BU_IMAGE_ORLE,
    BU_IMAGE_PNG,
    BU_IMAGE_PPM,
    BU_IMAGE_PS,
    BU_IMAGE_RLE,
    BU_IMAGE_SPM,
    BU_IMAGE_SUN,
    BU_IMAGE_YUV
};


#define BU_IMAGE_FILE_MAGIC 0x6269666d /* bifm */

struct bu_image_file {
    int magic;
    char *filename;
    int fd;
    int format;			/* BU_IMAGE_* */
    int width, height, depth;	/* pixel, pixel, byte */
    char *data;
    unsigned long flags;
};

BU_EXPORT BU_EXTERN(struct bu_image_file *bu_image_save_open,
		    (char *filename,
		     int format,
		     int width,
		     int height,
		     int depth));

BU_EXPORT BU_EXTERN(int bu_image_save_writeline,
		    (struct bu_image_file *bif,
		     int y,
		     unsigned char *data));

BU_EXPORT BU_EXTERN(int bu_image_save_close,
		    (struct bu_image_file *bif));

BU_EXPORT BU_EXTERN(int bu_image_save,
		    (char *data,
		     int width,
		     int height,
		     int depth,
		     char *filename,
		     int filetype));

/* end image utilities */

/* fchmod.c */
BU_EXPORT BU_EXTERN(int bu_fchmod,
		    (const char *filename,
		     FILE	     *fp,
		     int	     pmode));

__END_DECLS

#endif  /* __BU_H__ */
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.90
log
@declare bu_vls_strcmp() and bu_vls_strncmp() as functions instead of macros, remove the plethora of __STDC__ protections on the assertion macros and friends.
@
text
@d64 5
a68 2
/* interface headers */
#include <setjmp.h>
a1954 4
BU_EXPORT BU_EXTERN(char *bu_strdupm,
		    (const char *cp, const char *label));
#define bu_strdup(s) bu_strdupm(s, "bu_strdup " BU_FLSTR)

d2371 11
@


14.89
log
@ws
@
text
@d179 1
d181 2
a182 1
 *			B U _ F O R T R A N
d185 7
a191 19
 *  This macro is used to take the 'C' function name,
 *  and convert it at compile time to the
 *  FORTRAN calling convention used for this particular system.
 *
 *  Both lower-case and upper-case alternatives have to be provided
 *  because there is no way to get the C preprocessor to change the
 *  case of a token.
 */
#if defined(apollo) || defined(mips) || defined(aux) || defined(linux)
	/* Lower case, with a trailing underscore */
#ifdef __STDC__
#	define	BU_FORTRAN(lc,uc)	lc ## _
#else
#	define	BU_FORTRAN(lc,uc)	lc/**/_
#endif
#endif
#if !defined(BU_FORTRAN)
#	define	BU_FORTRAN(lc,uc)	lc
#endif
d197 2
a198 1
 * Allocate storage for a structure
d203 1
a203 3
/* Acquire storage for a given struct, eg, BU_GETSTRUCT(ptr,structname); */
#if __STDC__
#  define BU_GETSTRUCT(_p,_str) \
d205 1
a205 1
#  define BU_GETUNION(_p,_unn) \
d207 1
a207 6
#else
#  define BU_GETSTRUCT(_p,_str) \
	_p = (struct _str *)bu_calloc(1,sizeof(struct _str), "_str (getstruct)" )
#  define BU_GETUNION(_p,_unn) \
	_p = (union _unn *)bu_calloc(1,sizeof(union _unn), "_unn (getunion)" )
#endif
d210 1
a210 2
 *                B U _ G E T T Y P E
 *
d216 1
a216 2
#if __STDC__
#  define BU_GETTYPE(_p,_type) \
a217 4
#else
#  define BU_GETTYPE(_p,_type) \
	_p = (_type *)bu_calloc(1,sizeof(_type), "_type (getstruct)")
#endif
d220 2
a221 1
/*			B U _ C K M A G
d225 2
a226 2
 *  Macros to check and validate a structure pointer, given that
 *  the first entry in the structure is a magic number.
d245 3
a247 1
/**			B U _ A S S E R T
d267 1
a267 2
#  ifdef __STDC__
#    define BU_ASSERT(_equation)	\
a272 8
#  else
#    define BU_ASSERT(_equation)	\
	if( !(_equation) )  { \
		bu_log("BU_ASSERT( _equation ) failed, file %s, line %d\n", \
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT failure\n"); \
	}
#  endif
d278 1
a278 2
#  ifdef __STDC__
#    define BU_ASSERT_PTR(_lhs,_relation,_rhs)	\
a284 9
#  else
#    define BU_ASSERT_PTR(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_PTR( _lhs _relation _rhs ) failed, lhs=x%lx, rhs=x%lx, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_PTR failure\n"); \
	}
#  endif
d291 1
a291 2
#  ifdef __STDC__
#    define BU_ASSERT_LONG(_lhs,_relation,_rhs)	\
a297 9
#  else
#    define BU_ASSERT_LONG(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_LONG( _lhs _relation _rhs ) failed, lhs=%ld, rhs=%ld, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_LONG failure\n"); \
	}
#  endif
d304 1
a304 2
#  ifdef __STDC__
#    define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)	\
a310 9
#  else
#    define BU_ASSERT_DOUBLE(_lhs,_relation,_rhs)	\
	if( !((_lhs) _relation (_rhs)) )  { \
		bu_log("BU_ASSERT_DOUBLE( _lhs _relation _rhs ) failed, lhs=%lf, rhs=%lf, file %s, line %d\n", \
			(long)(_lhs), (long)(_rhs),\
			__FILE__, __LINE__ ); \
		bu_bomb("BU_ASSERT_DOUBLE failure\n"); \
	}
#  endif
d1281 1
a1281 1
 * stddef.h
d1283 3
a1285 2
#if __STDC__ && !defined(ipsc860)
#	define bu_offsetofarray(_t, _m)	offsetof(_t, _m[0])
d1287 2
a1288 6
#	define bu_offsetofarray(_t, _m)	(size_t)( (((_t *)0)->_m))
#endif
#if !defined(offsetof)
#	define bu_offsetof(_t, _m) (size_t)(&(((_t *)0)->_m))
#else
#	define bu_offsetof(_t, _m) offsetof(_t, _m)
d1290 1
a2262 2
#define bu_vls_strcmp(a,b) strcmp(bu_vls_addr(a),bu_vls_addr(b))
#define bu_vls_strncmp(a,b,n) strncmp(bu_vls_addr(a),bu_vls_addr(b),(n))
d2316 7
@


14.88
log
@declare the two parameters to bu_temp_file() for storing the filename
@
text
@d904 1
a904 1
	{ memset( (char *)((_bv)->bits), 0, BU_BITS2BYTES( (_bv)->nbits ) ); }
@


14.87
log
@use BU_ASSERT instead of assert -- though it's questionable as to whether BU_LIST_CLOSE needs to even exist..  it's apparently not used anywhere.
@
text
@d1842 1
a1842 1
BU_EXPORT BU_EXTERN(FILE *bu_temp_file, ());
@


14.86
log
@wow, there are even two copies of the old file.c function decls, and none of them exist any longer.  -1 donut for pjt
@
text
@d560 1
a560 1
	assert( (hp) != NULL ); \
d563 1
a563 1
	assert( BU_LIST_IS_EMPTY( (hp) ) ); \
d1841 3
@


14.85
log
@add new file stat routines to libbu, bu_file_readable() and bu_file_writable() and bu_file_executable(), for determining permissions on a given file name for the current user.  check the appropriate user, group, or other permission, and should work on windows too.  these routines make it easy to completely avoid access() as well as a means to improve error checking throughout.
@
text
@a1810 10
/* file.c */
BU_EXPORT BU_EXTERN(struct bu_file *bu_fopen,
		    (char *fname, char *type));
BU_EXPORT BU_EXTERN(int bu_fclose,
		    (struct bu_file *bfp));
BU_EXPORT BU_EXTERN(int bu_fgetc,
		    (struct bu_file *bfp));
BU_EXPORT BU_EXTERN(void bu_printfile,
		    (struct bu_file *bfp));

a1840 10
/* file.c */
BU_EXPORT BU_EXTERN(struct bu_file *bu_fopen,
		    (char *fname, char *type));
BU_EXPORT BU_EXTERN(int bu_fclose,
		    (struct bu_file *bfp));
BU_EXPORT BU_EXTERN(int bu_fgetc,
		    (struct bu_file *bfp));
BU_EXPORT BU_EXTERN(void bu_printfile,
		    (struct bu_file *bfp));

@


14.84
log
@remove bu_brlcad_path and bu_tcl_brlcad_path decls, they're now obsolete
@
text
@d1825 3
@


14.83
log
@remove the last traces of stdarg/vararg testing.  c89 conformance provides the stdarg interface.
@
text
@a1830 2
BU_EXPORT BU_EXTERN(char *bu_brlcad_path, /* deprecated call */
		    (const char *rhs, int fail_quietly));
a2628 7
/* bu_tcl_brlcad_path is deprecated */
BU_EXPORT BU_EXTERN(int bu_tcl_brlcad_path,
		    (ClientData	clientData,
		     Tcl_Interp	*interp,
		     int	 argc,
		     char	**argv));

@


14.82
log
@protect the vararg function declaration in bu.h with the same defines as used in the definition in libbu/vls.c
remove redundant declaration in libbu/vls.c
@
text
@a2419 1
#if defined(HAVE_VARARGS_H) || defined(HAVE_STDARG_H)
a2423 1
#endif
a2424 1
#if defined(HAVE_STDARG_H)
a2427 11
#else  /* !HAVE_STDARG_H */
#  if defined(HAVE_VARARGS_H)
BU_EXPORT BU_EXTERN(void bu_vls_printf,
		    (va_dcl va_alist));
#  else  /* !HAVE_VARARGS_H */
BU_EXPORT BU_EXTERN(void bu_vls_printf,
		    (struct bu_vls *vls, char *fmt, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j));
#  endif  /* HAVE_VARARGS_H */
#endif  /* HAVE_STDARG_H */

#if defined(HAVE_STDARG_H)
a2430 9
#else  /* !HAVE_STDARG_H */
#  if defined(HAVE_VARARGS_H)
BU_EXPORT BU_EXTERN(void bu_vls_sprintf,
		    (va_dcl va_alist));
#  else  /* !HAVE_VARARGS_H */
BU_EXPORT BU_EXTERN(void bu_vls_sprintf,
		    (struct bu_vls *vls, char *fmt, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j));
#  endif  /* HAVE_VARARGS_H */
#endif  /* HAVE_STDARG_H */
@


14.81
log
@Added declaration for bu_fchmod().
@
text
@d2420 1
a2420 1
#if defined(HAVE_VARARG_H)
@


14.80
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d2871 6
@


14.79
log
@silly coder, semicolons don't go there
@
text
@a190 3
#if defined(CRAY)
#	define	BU_FORTRAN(lc,uc)	uc
#endif
@


14.78
log
@convenience wrappers for comparing vls's
@
text
@d2342 2
a2343 2
#define bu_vls_strcmp(a,b) strcmp(bu_vls_addr(a),bu_vls_addr(b));
#define bu_vls_strncmp(a,b,n) strncmp(bu_vls_addr(a),bu_vls_addr(b),(n));
@


14.77
log
@tweak debug log messages for consistency
@
text
@d2342 2
@


14.76
log
@add a new bu_exit() function that never returns.  this function differs from bu_bomb() in that it supports an error code and printf style arguments.  it should not be used for 'exceptional' exit conditions where stability and validity are in question; it should be used when you simply want to politely exit the application after printing a message (like printing application usage and exiting).
@
text
@d30 1
a30 1
 *	Consolodated logging support:  bu_log(), bu_bomb().
d294 1
a294 1
		bu_bomb("assertion failure\n"); \
d301 1
a301 1
		bu_bomb("assertion failure\n"); \
@


14.75
log
@add GCC attribute declarations (when we're compiling with GCC of course) that help the compiler know that a particular function has printf-style arguments or is a function that never returns.  add the attributes to the likes of bu_log, bu_flog, and bu_bomb.  code inspired from bz, thx.
@
text
@d1770 1
@


14.74
log
@prevent crashing on a whole slew of cases where we end up iterating over either a null, uninitialized, or malformed list item.  the current for loop while condition has to be non-NULL in order to do the next iteration, so make sure of it.  this prevents a crash that was detected in the display geometry object (where it had unitialized data).
@
text
@d150 30
d1071 1
a1071 1
/* vlist, vlblock?  But they use vmath.h... */
d1557 1
a1557 1
    /* CLASS I - Applications may read directly... */
d1560 1
a1560 1
    /* CLASS II - Applications may read/write directly... */
d1564 1
a1564 1
    /* CLASS III - Applications should not manipulate directly... */
d1769 1
a1769 1
BU_EXPORT BU_EXTERN(void bu_bomb, (const char *str));
d1994 2
a1995 2
BU_EXPORT BU_EXTERN(void bu_log, (char *, ... ));
BU_EXPORT BU_EXTERN(void bu_flog, (FILE *, char *, ... ));
d2430 1
a2430 1
		     char *fmt, ...));
d2444 1
a2444 1
		     char *fmt, ...));
@


14.73
log
@change various ints and longs to size_t for pointer/offset stuff
@
text
@d700 1
a700 1
	      BU_LIST_NOT_HEAD(p,hp); \
d705 1
a705 1
	      BU_LIST_NOT_HEAD(p,hp); \
d710 1
a710 1
	      BU_LIST_NOT_HEAD(p,hp); \
d721 1
a721 1
	BU_LIST_NOT_HEAD(p,hp); \
d726 1
a726 1
	BU_LIST_NOT_HEAD(p,hp); \
d735 1
a735 1
	(p) != (hp); \
d748 2
a749 2
		BU_LIST_NOT_HEAD((struct bu_list *)(p1),(hp1)) &&	\
		BU_LIST_NOT_HEAD((struct bu_list *)(p2),(hp2));		\
@


14.72
log
@removed trailing whitespace
@
text
@d1317 1
a1317 1
#	define bu_offsetofarray(_t, _m)	(int)( (((_t *)0)->_m))
d1320 1
a1320 1
#	define bu_offsetof(_t, _m) (int)(&(((_t *)0)->_m))
d1336 1
a1336 1
#	define bu_byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
d1343 1
a1343 1
#      define bu_byteoffset(_i)	((int)((char *)&(_i)))
d1347 1
a1347 1
#          define bu_byteoffset(_i)	((long)((char *)&(_i)))
d1349 1
a1349 1
#          define bu_byteoffset(_i)	((long)(((void *)&(_i))-((void *)0)))
d1353 1
a1353 1
#        define bu_byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
@


14.71
log
@protect the vararg func decl
@
text
@d2824 2
a2825 2
		    (struct bu_image_file *bif, 
		     int y, 
@


14.70
log
@make the RGB data buffers unsigned
@
text
@d2390 1
d2395 1
@


14.69
log
@change image format #define stuff to an enum
@
text
@d2822 3
a2824 1
		    (struct bu_image_file *bif, int y, char *data));
@


14.68
log
@get rid of RCS variables from the public header files.  this is done in part to reduce recompilation during interface changes, but also to move towards not relying on or publishing the information contained in the variables interface-wise. (they're fine for c sources and private headers)
@
text
@d2784 17
a2800 5
#define BU_IMAGE_AUTO	0x00
#define BU_IMAGE_PIX	0x01
#define BU_IMAGE_BW	0x02
#define BU_IMAGE_PNG	0x03
#define BU_IMAGE_BMP	0x04
@


14.67
log
@add BU_DEBUG_ATTACH for the backtrace crash dump routines as a means for them to spin and wait for a debugger to attach.
@
text
@a55 2
 *
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.66 2007/05/20 20:22:50 brlcad Exp $
a81 3
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.66 2007/05/20 20:22:50 brlcad Exp $ (BRL)"


@


14.66
log
@declare bu_argv0_full_path() and remove the bu_argv0() argument
@
text
@d57 1
a57 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.65 2007/05/19 00:50:03 brlcad Exp $
d84 1
a84 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.65 2007/05/19 00:50:03 brlcad Exp $ (BRL)"
d1261 1
a1261 1
#define BU_DEBUG_COREDUMP	0x00000001	/* If set, bu_bomb() will dump core */
d1264 1
a1264 1
#define BU_DEBUG_DB		0x00000008	/* Database debugging */
d1266 1
a1266 1
#define BU_DEBUG_PARALLEL	0x00000010	/* parallel support */
d1268 2
a1269 2
#define BU_DEBUG_BACKTRACE	0x00000040	/* If set, backtrace details will be logged */
#define BU_DEBUG_PATHS		0x00000080	/* debug path searching */
d1276 4
a1279 4
#define BU_DEBUG_UNUSED_1	0x00001000	/* unused */
#define BU_DEBUG_UNUSED_2	0x00002000	/* unused */
#define BU_DEBUG_UNUSED_3	0x00004000	/* unused */
#define BU_DEBUG_UNUSED_4	0x00008000	/* unused */
d1282 3
a1284 3
#define BU_DEBUG_UNUSED_5	0x00020000	/* unused */
#define BU_DEBUG_UNUSED_6	0x00040000	/* unused */
#define BU_DEBUG_UNUSED_7	0x00080000	/* unused */
@


14.65
log
@don't force USE_PROTOTYPES to be necessarily set to get what we usually want anyways (i.e. proper decls with args) -- check for __STDC__ too to determine how to declare.
@
text
@d57 1
a57 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.64 2007/05/19 00:30:51 brlcad Exp $
d84 1
a84 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.64 2007/05/19 00:30:51 brlcad Exp $ (BRL)"
d1804 2
a1805 1
BU_EXPORT BU_EXTERN(const char *bu_argv0, (const char *argv0));
@


14.64
log
@okay to assume c89, remove some of the compat decls for older compilers
@
text
@d57 1
a57 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.63 2007/05/14 16:39:14 brlcad Exp $
d84 1
a84 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.63 2007/05/14 16:39:14 brlcad Exp $ (BRL)"
d146 1
a146 1
#if USE_PROTOTYPES
@


14.63
log
@rtlist.h and rtstring.h are no longer relevant -- warn that they are obsolete (to be removed in a future minor rev)
@
text
@d57 1
a57 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.62 2007/05/13 18:51:44 brlcad Exp $
d84 1
a84 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.62 2007/05/13 18:51:44 brlcad Exp $ (BRL)"
d1967 3
a1969 13
BU_EXPORT BU_EXTERN(void bu_putchar,
		    (int c));
#if defined(HAVE_STDARG_H)
BU_EXPORT BU_EXTERN(void bu_log,
		    (char *, ... ));
BU_EXPORT BU_EXTERN(void bu_flog,
		    (FILE *, char *, ... ));
#else
BU_EXPORT BU_EXTERN(void bu_log,
		    ());
BU_EXPORT BU_EXTERN(void bu_flog,
		    ());
#endif
d2393 1
a2393 1
#if defined(HAVE_VARARGS_H) || defined(HAVE_STDARG_H)
a2397 1
#endif
@


14.62
log
@declare bu_whereis() and bu_which()
@
text
@a50 2
	#include "machine.h"	/_* For fastf_t definition on this machine *_/
	#include "rtlist.h"	/_* OPTIONAL, auto-included by bu.h *_/
d57 1
a57 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.61 2007/05/13 00:05:57 brlcad Exp $
d84 1
a84 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.61 2007/05/13 00:05:57 brlcad Exp $ (BRL)"
d1173 1
a1173 1
 *  Variable Length Strings: bu_vls support (formerly rt_vls in rtstring.h)
@


14.61
log
@declare bu_backtrace()
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.60 2007/05/12 21:59:23 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.60 2007/05/12 21:59:23 brlcad Exp $ (BRL)"
d1742 3
d1748 2
a1749 2
/* backtrace.c */
BU_EXPORT BU_EXTERN(int bu_backtrace, (FILE *fp));
d1816 6
@


14.60
log
@add process.c to libbu for a bu_process_id() wrapper call for getting the pid of the current process
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.59 2007/05/12 04:50:22 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.59 2007/05/12 04:50:22 brlcad Exp $ (BRL)"
d1743 4
a1746 2
BU_EXPORT BU_EXTERN(void bu_bomb,
		    (const char *str));
d1749 2
a1750 2
BU_EXPORT BU_EXTERN(char *bu_fgets,
		    ( char *s, int size, FILE *stream));
a1754 1

@


14.59
log
@declare newly added bu_terminate() call
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.58 2007/05/12 00:09:54 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.58 2007/05/12 00:09:54 brlcad Exp $ (BRL)"
d2050 3
@


14.58
log
@add BU_DEBUG_BACKTRACE, cleanup and slot the unused
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.57 2007/04/17 14:57:18 erikgreenwald Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.57 2007/04/17 14:57:18 erikgreenwald Exp $ (BRL)"
d2047 3
d2051 7
a2057 14
BU_EXPORT BU_EXTERN(void bu_nice_set,
		    (int newnice));
BU_EXPORT BU_EXTERN(int bu_cpulimit_get,
		    ());
BU_EXPORT BU_EXTERN(void bu_cpulimit_set,
		    (int sec));
BU_EXPORT BU_EXTERN(int bu_avail_cpus,
		    ());
BU_EXPORT BU_EXTERN(fastf_t bu_get_load_average,
		    ());
BU_EXPORT BU_EXTERN(int bu_get_public_cpus,
		    ());
BU_EXPORT BU_EXTERN(int bu_set_realtime,
		    ());
@


14.57
log
@change data to char and add a "flags" field to the bu image struct
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.56 2007/04/16 21:15:35 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.56 2007/04/16 21:15:35 brlcad Exp $ (BRL)"
d1257 1
a1257 1
 * using the "-! ###" option.
d1263 24
a1286 14
#define BU_DEBUG_COREDUMP	0x00000001	/* 001 If set, bu_bomb() will dump core */

#define BU_DEBUG_MEM_CHECK	0x00000002	/* 002 Mem barrier & leak checking */
#define BU_DEBUG_MEM_LOG	0x00000004	/* 003 Print all dynamic memory operations */
#define BU_DEBUG_DB		0x00000008	/* 004 Database debugging */

#define BU_DEBUG_PARALLEL	0x00000010	/* 005 parallel support */
#define BU_DEBUG_MEM_QCHECK	0x00000020	/* 006 Fast mem leak checking (won't work with corruption) */
#define BU_DEBUG_MATH		0x00000100	/* 011 Fundamental math routines (plane.c, mat.c) */
#define BU_DEBUG_PTBL		0x00000200	/* 012 bu_ptbl_*() logging */
#define BU_DEBUG_AVS		0x00000400	/* 013 bu_avs_*() logging */
#define BU_DEBUG_MAPPED_FILE	0x00000800	/* 014 bu_mapped_file logging */

#define BU_DEBUG_TABDATA	0x00010000	/* 025 LIBBN: tabdata */
@


14.56
log
@revamp BRL-CAD's versioning setup.  no longer rely upon the vers.sh script, allowing for a more unified cross-platform configuration.  instead of globals, provide per-library functions that return the version string.  the version numbers are now stored in files in include/conf/.
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.55 2007/04/13 17:03:03 erikgreenwald Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.55 2007/04/13 17:03:03 erikgreenwald Exp $ (BRL)"
d2796 2
a2797 1
    void *data;
@


14.55
log
@beginnings of image mgmt
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.54 2007/03/06 20:48:14 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.54 2007/03/06 20:48:14 brlcad Exp $ (BRL)"
d352 7
a2433 4

/* vers.c */
BU_EXPORT extern const char		bu_version[];

d2449 1
a2450 1
/** @@} */
d2486 1
a2487 1
/** @@} */
d2497 1
a2498 1
/** @@} */
@


14.54
log
@declare bu_basename, make note to make dirname return something const
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.53 2007/03/01 22:43:17 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.53 2007/03/01 22:43:17 brlcad Exp $ (BRL)"
d2776 43
@


14.53
log
@s/srtdup/strdup/ typo
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.52 2007/02/26 09:37:43 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.52 2007/02/26 09:37:43 brlcad Exp $ (BRL)"
d1993 1
d1996 2
@


14.52
log
@add the similar routine bu_same_fd() to compare two file descriptors returned by open()
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.51 2007/02/26 09:24:19 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.51 2007/02/26 09:24:19 brlcad Exp $ (BRL)"
d1991 1
a1991 1
#define bu_strdup(s) bu_strdupm(s, "bu_srtdup " BU_FLSTR)
@


14.51
log
@add bu_same_file() declaration so we can use it in places
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.50 2007/02/20 03:37:37 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.50 2007/02/20 03:37:37 brlcad Exp $ (BRL)"
d1782 1
@


14.50
log
@naming consistency, rename bu_fgets.c to fgets.c
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.49 2007/02/20 01:14:18 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.49 2007/02/20 01:14:18 brlcad Exp $ (BRL)"
d1781 1
@


14.49
log
@get rid of the bu_strdup() dead code and comment how it's really an interface macro pass through that provides file:line info when bu debugging is enabled
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.48 2007/02/20 00:07:14 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.48 2007/02/20 00:07:14 brlcad Exp $ (BRL)"
d1729 1
a1729 1
/* bu_fgets.c */
@


14.48
log
@export bu_argv0
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.47 2007/02/01 21:52:15 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.47 2007/02/01 21:52:15 brlcad Exp $ (BRL)"
d1986 1
d1989 1
a1990 5
#define bu_strdup(s) bu_strdupm(s, "bu_srtdup " BU_FLSTR)
#if 0
BU_EXPORT BU_EXTERN(char *bu_strdup,
		    (const char *cp));
#endif
@


14.47
log
@include the same prototype declarations that vls.c uses for bu_vls_printf and bu_vls_sprintf.  remove the non-existant bu_vls_blkset.
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.46 2007/01/31 20:56:58 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.46 2007/01/31 20:56:58 brlcad Exp $ (BRL)"
d1783 1
@


14.46
log
@update comment, USE_PROTOTYPES is set in configure, not machine.h
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.45 2007/01/27 01:01:39 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.45 2007/01/27 01:01:39 brlcad Exp $ (BRL)"
d2376 1
a2376 1
#if 0
d2382 2
d2387 11
d2401 10
a2417 8

#if 0
BU_EXPORT BU_EXTERN(void bu_vls_blkset,
		    (struct bu_vls *vp,
		     int len,
		     int ch));
#endif

@


14.45
log
@ws, test three
@
text
@d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.44 2007/01/23 01:13:19 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.44 2007/01/23 01:13:19 brlcad Exp $ (BRL)"
d146 1
a146 1
 *  The setting of USE_PROTOTYPES is done in machine.h
@


14.44
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d23 1
a23 1
 * 
d44 1
a44 1
 *	The U. S. Army Research Laboratory 			@@n 
d49 5
a53 5
 	#include "common.h"
 	#include <stdio.h>
 	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 	#include "rtlist.h"	/_* OPTIONAL, auto-included by bu.h *_/
 	#include "bu.h"
d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.43 2007/01/21 04:45:40 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.43 2007/01/21 04:45:40 brlcad Exp $ (BRL)"
d106 1
a106 1
/** 
a221 1

a464 2
 *									
 *			     B U _ L I S T				
d466 43
a508 41
 *			Doubly-linked list support			
 *									
 *  These macros assume that all user-provided structures will have	
 *  a "struct bu_list" as their first element (often named "l" [ell]).	
 *  Thus, a pointer to the bu_list struct is a "pun" for the		
 *  user-provided structure as well, and the pointers can be converted	
 *  back and forth safely with type casts.				
 *									
 *  Furthermore, the head of the linked list could be			
 *  a full instance of the user-provided structure			
 *  (although the storage-conscious programmer could make the head	
 *  just an bu_list structure, with careful type casting).		
 *  This results in a doubly-linked circular list, with the head	
 *  having the same shape as all the list members.			
 *  The application is free to make use of this symmetry and store	
 *  data values in the head, or the extra storage in the head can	
 *  be ignored.								
 *									
 *  Where a macro expects an argument "p", it should be a pointer to	
 *  a user-provided structure.						
 *									
 *  Where a macro expects an argument "hp", it should be a pointer to	
 *  a "struct bu_list" located in the list head, e.g., &(head.l).	
 *									
 *  Where a macro expects an argument "old", "new", or "cur", it should	
 *  be a pointer to the "struct bu_list" located either			
 *  in a user-provided structure, e.g. &((p)->l),			
 *  or for the case of "old" it may also be in the list head, e.g.	
 *	BU_LIST_INSERT( &(head.l), &((p)->l) );				
 *									
 *  Dequeueing the head of a list is a valid and			
 *  well defined operation which should be performed with caution.	
 *  Unless a pointer to some other element of the list is retained	
 *  by the application, the rest of the linked list can no longer be	
 *  referred to.							
 *									
 *  The "magic" field of the list header _must_ be set to the constant	
 *  BU_LIST_HEAD_MAGIC, but the "magic" field of all list members	
 *  should be established by user code, to identify the type of		
 *  structure that the bu_list structure is embedded in.		
 *  It is permissible for one list to contain an arbitrarily mixed	
d510 6
a515 6
 *									
 *  There is a dual set of terminology used in some of the macros:	
 *	FIRST / LAST	from the point of view of the list head		
 *	NEXT / PREV	from the point of view of a list member		
 *	forw / back	the actual pointer names			
 *									
d822 1
a822 1
 * 
d862 1
a862 1
        int oldbit;
d864 5
a868 5
        __asm__ __volatile__(
                "btl %2,%1\n\tsbbl %0,%0"
                :"=r" (oldbit)
                :"m" (addr),"Ir" (nr));
        return oldbit;
d910 3
a912 3
 	BU_BITV_LOOP_START(bv)  {
 		fiddle(BU_BITV_LOOP_INDEX);
 	} BU_BITV_LOOP_END;
d1242 1
a1242 1
/** @@addtogroup bu_debug Debugging 
d1342 1
a1342 1
         /* "Conservative" way of finding # bytes as diff of 2 char ptrs */
d1356 5
a1360 5
 	char	a_char;
 	char	str[32];
 	short	a_short;
 	int	a_int;
 	double	a_double;
d1362 1
a1362 1
 
d1364 2
a1365 2
 	{ 'c', "the default string", 32767, 1, 1.0 };
 
d1367 1
a1367 1
 
d1369 1
a1369 1
 
d1371 3
a1373 3
 	BU_STRUCTPARSE_FUNC_NULL,
 	"a single character",	(void*)&default.a_char },
 
d1375 3
a1377 3
 	BU_STRUCTPARSE_FUNC_NULL,
 	"This is a full character string", (void*)default.str }, },
 
d1379 3
a1381 3
 	BU_STRUCTPARSE_FUNC_NULL,
 	"A 16bit integer",	(void*)&default.a_short },
 
d1383 3
a1385 3
 	BU_STRUCTPARSE_FUNC_NULL,
 	"A full integer",	(void*)&default.a_int },
 
d1387 3
a1389 3
 	BU_STRUCTPARSE_FUNC_NULL,
 	"A double-precision floating point value",  (void*)&default.a_double },
 
d1391 3
a1393 3
 	BU_STRUCTPARSE_FUNC_NULL,
 	(char *)NULL, (void *)NULL }
 
a1421 2


a2428 1

d2438 7
a2444 7
             (((long)((_cp)[1])) << 48) |	\
             (((long)((_cp)[2])) << 40) |	\
             (((long)((_cp)[3])) << 32) |	\
             (((long)((_cp)[4])) << 24) |	\
             (((long)((_cp)[5])) << 16) |	\
             (((long)((_cp)[6])) <<  8) |	\
              ((long)((_cp)[7])) )
d2447 3
a2449 3
             (((long)((_cp)[1])) << 16) |	\
             (((long)((_cp)[2])) <<  8) |	\
              ((long)((_cp)[3])) )
d2451 2
a2452 2
            ((((short)((_cp)[0])) << 8) | \
                       (_cp)[1] )
a2465 1

a2770 1

@


14.43
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.42 2007/01/20 14:36:40 brlcad Exp $
d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.42 2007/01/20 14:36:40 brlcad Exp $ (BRL)"
@


14.42
log
@update copyright to 2007
@
text
@d22 1
a22 1
/*@@{*/
d60 1
a60 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.41 2007/01/17 19:36:49 erikgreenwald Exp $
d87 1
a87 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.41 2007/01/17 19:36:49 erikgreenwald Exp $ (BRL)"
d352 1
a352 1
/*@@}*/
d356 1
a356 1
/*@@{*/
d369 1
a369 1
/*@@}*/
d815 1
a815 1
/*@@}*/
d939 1
a939 1
/*@@}*/
d945 1
a945 1
/*@@{*/
d985 1
a985 1
/*@@}*/
d994 1
a994 1
/*@@{*/
d1044 1
a1044 1
/*@@}*/
d1069 1
a1069 1
/*@@{*/
d1086 1
a1086 1
/*@@}*/
d1108 1
a1108 1
/*@@{*/
d1164 1
a1164 1
/*@@}*/
d1168 1
a1168 1
/*@@{*/
d1204 1
a1204 1
/*@@}*/
d1207 1
a1207 1
/*@@{*/
d1241 1
a1241 1
/*@@}*/
d1247 1
a1247 1
/*@@{*/
d1281 1
a1281 1
/*@@}*/
d1285 1
a1285 1
/*@@{*/
d1446 1
a1446 1
/*@@}*/
d1466 1
a1466 1
/*@@{*/
d1646 1
a1646 1
/*@@{*/
d1683 1
a1683 1
/*@@}*/
d1686 1
a1686 1
/*@@{*/
d1694 1
a1694 1
/*@@}*/
d1697 1
a1697 1
/*@@{*/
d1725 1
a1725 1
/*@@}*/
d1727 1
a1727 1
/*@@{*/
d1736 1
a1736 1
/*@@}*/
d1738 1
a1738 1
/*@@{*/
d1769 1
a1769 1
/*@@}*/
d1771 1
a1771 1
/*@@{*/
d1812 1
a1812 1
/*@@}*/
d1814 1
a1814 1
/*@@{*/
d1825 1
a1825 1
/*@@}*/
d1827 1
a1827 1
/*@@{*/
d1845 1
a1845 1
/*@@}*/
d1847 1
a1847 1
/*@@{*/
d1869 1
a1869 1
/*@@}*/
d1871 1
a1871 1
/*@@{*/
d1879 1
a1879 1
/*@@}*/
d1881 1
a1881 1
/*@@{*/
d1887 1
a1887 1
/*@@}*/
d1889 1
a1889 1
/*@@{*/
d1911 1
a1911 1
/*@@}*/
d1913 1
a1913 1
/*@@{*/
d1929 1
a1929 1
/*@@}*/
d1931 1
a1931 1
/*@@{*/
d1957 1
a1957 1
/*@@}*/
d1959 1
a1959 1
/*@@{*/
d1965 1
a1965 1
/*@@}*/
d1967 1
a1967 1
/*@@{*/
d2006 1
a2006 1
/*@@}*/
d2008 1
a2008 1
/*@@{*/
d2027 1
a2027 1
/*@@}*/
d2029 1
a2029 1
/*@@{*/
d2051 1
a2051 1
/*@@}*/
d2053 1
a2053 1
/*@@{*/
d2131 1
a2131 1
/*@@}*/
d2133 1
a2133 1
/*@@{*/
d2185 1
a2185 1
/*@@}*/
d2187 1
a2187 1
/*@@{*/
d2285 1
a2285 1
/*@@}*/
d2287 1
a2287 1
/*@@{*/
d2297 1
a2297 1
/*@@}*/
d2299 1
a2299 1
/*@@{*/
d2411 1
a2411 1
/*@@}*/
d2418 1
a2418 1
/*@@{*/
d2434 1
a2434 1
/*@@}*/
d2436 1
a2436 1
/*@@{*/
d2472 1
a2472 1
/*@@}*/
d2474 1
a2474 1
/*@@{*/
d2483 1
a2483 1
/*@@}*/
d2485 1
a2485 1
/*@@{*/
d2630 1
a2630 1
/*@@}*/
d2632 1
a2632 1
/*@@{*/
d2694 1
a2694 1
/*@@}*/
d2696 1
a2696 1
/*@@{*/
d2767 1
a2767 1
/*@@}*/
@


14.41
log
@type fixes (size_t isn't necessarily unsigned int, signed vs unsigned, etc)
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d60 1
a60 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.40 2006/12/29 05:12:03 lbutler Exp $
d87 1
a87 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.40 2006/12/29 05:12:03 lbutler Exp $ (BRL)"
@


14.40
log
@raytrace and bu got comment updates
machine.h now supports dual cpu's on Intel based Mac machines
@
text
@d60 1
a60 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.39 2006/09/26 00:10:45 brlcad Exp $
d87 1
a87 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.39 2006/09/26 00:10:45 brlcad Exp $ (BRL)"
d1142 2
a1143 2
    int				count;	/**< @@brief # valid entries in avp  */
    int				max;	/**< @@brief # allocated slots in avp  */
d1974 1
a1974 1
		    (unsigned int cnt,
d1981 1
a1981 1
		     unsigned int cnt,
d1985 1
a1985 1
		     unsigned int elsize,
@


14.39
log
@have the headers include the headers they respectively require
@
text
@d42 1
a42 1
 *  @@@@authorMichael John Muuss
d60 1
a60 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.38 2006/09/18 05:24:07 lbutler Exp $
d87 1
a87 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.38 2006/09/18 05:24:07 lbutler Exp $ (BRL)"
@


14.38
log
@Doxygen updates
@
text
@d60 1
a60 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.37 2006/09/03 15:16:20 lbutler Exp $
a61 1

d69 5
a73 2
/* Included for Tcl_Interp definition */
#include "tcl.h"
d87 1
a87 3
#include <setjmp.h>

#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.37 2006/09/03 15:16:20 lbutler Exp $ (BRL)"
@


14.37
log
@Doxygen updates
@
text
@d42 1
a42 1
 *  @@Author Michael John Muuss
d60 1
a60 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.36 2006/08/31 04:41:19 lbutler Exp $
d87 1
a87 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.36 2006/08/31 04:41:19 lbutler Exp $ (BRL)"
d616 1
a616 1
/*
d646 1
a646 1
/* Test if a doubly linked list is empty, given head pointer */
d715 1
a715 1
/*
d731 1
a731 1
/*
d755 1
a755 1
/*
d759 3
a761 3
 *		BU_LIST_DEQUEUE( &(p->l) );
 *		free( (char *)p );
 *	}
d766 1
a766 1
/* Return the magic number of the first (or last) item on a list */
d770 1
a770 1
/* Return pointer to next (or previous) element, which may be the head */
d776 1
a776 1
/* Return pointer two links away, which may include the head */
d786 1
a786 1
/* Return pointer to circular next element; ie, ignoring the list head */
d792 1
a792 1
/* Return pointer to circular last element; ie, ignoring the list head */
d798 1
a798 1
/*
d905 1
a905 1
/*
d910 7
a916 4
 *  Example:
 *	BU_BITV_LOOP_START(bv)  {
 *		fiddle(BU_BITV_LOOP_INDEX);
 *	} BU_BITV_LOOP_END;
d929 1
a929 1
/*
d1005 9
a1013 9
#define BU_PTBL_INIT	0	/* initialize table pointer struct & get storage */
#define BU_PTBL_INS	1	/* insert an item (long *) into a table */
#define BU_PTBL_LOC 	2	/* locate a (long *) in an existing table */
#define BU_PTBL_FREE	3	/* deallocate buffer associated with a table */
#define BU_PTBL_RST	4	/* empty a table, but keep storage on hand */
#define BU_PTBL_CAT	5	/* catenate one table onto another */
#define BU_PTBL_RM	6	/* remove all occurrences of an item from a table */
#define BU_PTBL_INS_UNIQUE 7	/* insert item into table, if not present */
#define BU_PTBL_ZERO	8	/* replace all occurrences of an item by 0 */
d1026 1
a1026 1
/*
d1113 1
a1113 1
/*
d1124 1
a1124 1
/*
d1154 1
a1154 1
/*
d1208 1
a1208 1
/* 			B U _ M R O
d1351 2
a1352 1
/* The "bu_structparse" struct describes one element of a structure.
d1356 42
a1397 42
 *
 * struct data_structure {
 *	char	a_char;
 *	char	str[32];
 *	short	a_short;
 *	int	a_int;
 *	double	a_double;
 * }
 *
 * struct data_structure data_default =
 *	{ 'c', "the default string", 32767, 1, 1.0 };
 *
 * struct data_structure my_values;
 *
 * struct bu_structparse data_sp[] ={
 *
 * {"%c", 1,  "a_char",   bu_offsetof(data_structure, a_char),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"a single character",	(void*)&default.a_char },
 *
 * {"%s", 32, "str",      bu_offsetofarray(data_structure, str),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"This is a full character string", (void*)default.str }, },
 *
 * {"%i", 1,  "a_short",  bu_offsetof(data_structure, a_short),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"A 16bit integer",	(void*)&default.a_short },
 *
 * {"%d", 1,  "a_int",    bu_offsetof(data_structure, a_int),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"A full integer",	(void*)&default.a_int },
 *
 * {"%f", 1,  "a_double", bu_offsetof(data_structure, a_double),
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	"A double-precision floating point value",  (void*)&default.a_double },
 *
 * { "", 0, (char *)NULL, 0,
 *	BU_STRUCTPARSE_FUNC_NULL,
 *	(char *)NULL, (void *)NULL }
 *
 * };
 *
d1427 1
a1427 1
/*
d1478 1
a1478 1
/*
d1503 1
a1503 1
/*
d1522 2
a1523 2
    long	 	rbt_magic;	  /* Magic no. for integrity check */
    int			rbt_nm_nodes;	  /* Number of nodes */
d1525 3
a1527 3
    void		(*rbt_print)();	  /* Data pretty-print function */
    int			rbt_debug;	  /* Debug bits */
    char		*rbt_description; /* Comment for diagnostics */
d1529 8
a1536 8
    int		 	rbt_nm_orders;	  /* Number of simultaneous orders */
    int			(**rbt_order)();  /* Comparison functions */
    struct bu_rb_node	**rbt_root;	  /* The actual trees */
    char		*rbt_unique;	  /* Uniqueness flags */
    struct bu_rb_node	*rbt_current;	  /* Current node */
    struct bu_rb_list	rbt_nodes;	  /* All nodes */
    struct bu_rb_list	rbt_packages;	  /* All packages */
    struct bu_rb_node	*rbt_empty_node;  /* Sentinel representing nil */
d1544 5
a1548 5
#define BU_RB_DEBUG_INSERT	0x00000001	/* Insertion process */
#define BU_RB_DEBUG_UNIQ	0x00000002	/* Uniqueness of inserts */
#define BU_RB_DEBUG_ROTATE	0x00000004	/* Rotation process */
#define BU_RB_DEBUG_OS	0x00000008	/* Order-statistic operations */
#define BU_RB_DEBUG_DELETE	0x00000010	/* Deletion process */
d1550 1
a1550 1
/*
d1572 1
a1572 1
/*
d1615 1
a1615 1
/*
d1626 2
a1627 1
/*			B U _ C M D T A B
d2777 1
@


14.36
log
@miscelaneous changes to support doxygen
@
text
@d21 2
a22 1

d24 1
a24 1
 * @@addtogroup libbu
d60 1
a60 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.35 2006/08/28 18:51:28 brlcad Exp $
d62 1
a62 1
/*@@{*/
d87 1
a87 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.35 2006/08/28 18:51:28 brlcad Exp $ (BRL)"
d107 1
a107 1
/** @@def MAXPATHLEN
d115 1
a115 1
/** @@def BU_PATH_SEPARATOR 
a208 1
 * @@def BU_GETTYPE(ptr,typename)
a363 4
 * @@def SIZEOF_NETWORK_SHORT
 * @@def SIZEOF_NETWORK_LONG
 * @@def SIZEOF_NETWORK_FLOAT
 * @@def SIZEOF_NETWORK_DOUBLE
d824 1
a824 1
 * @@struct bu_bitv bu.h
d1680 2
d1689 1
d1691 2
d1720 4
d1731 3
d1764 4
d1807 4
d1820 4
d1840 4
d1864 4
d1874 4
d1882 4
d1906 3
d1924 3
d1952 4
d1960 4
d2001 4
d2021 5
d2046 4
d2126 4
d2180 4
d2280 4
d2292 4
d2406 2
d2412 2
d2427 6
d2466 5
d2477 5
d2624 5
d2689 5
d2762 1
a2762 1

@


14.35
log
@added new bu_get_hash_key() decl
@
text
@d21 1
d23 2
a24 1
 *
d41 1
a41 2
 *  Author -
 *	Michael John Muuss
d43 12
a54 10
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 *  Include Sequencing -
 *	#include "common.h"
 *	#include <stdio.h>
 *	#include "machine.h"	/_* For fastf_t definition on this machine *_/
 *	#include "rtlist.h"	/_* OPTIONAL, auto-included by bu.h *_/
 *	#include "bu.h"
d56 1
a56 1
 *  Libraries Used -
d59 1
a59 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.34 2006/08/16 02:25:10 johnranderson Exp $
d61 1
a61 1

d86 1
a86 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.34 2006/08/16 02:25:10 johnranderson Exp $ (BRL)"
d89 2
a90 1
/** define BU_DIR_SEPARATOR to the directory separator character
d106 4
d114 2
a115 1
/** define BU_PATH_SEPARATOR to the path list separator character
d128 3
a130 2
/*
 * BU_FLSTR   Macro for getting a concatenated string of the current
d156 1
a156 1
/*
d158 1
d183 1
a183 1
/*
d185 7
a191 2
 */

d195 1
a195 1
	_p = (struct _str *)bu_calloc(1,sizeof(struct _str), #_str " (getstruct)" )
d197 1
a197 1
	_p = (union _unn *)bu_calloc(1,sizeof(union _unn), #_unn " (getunion)")
d200 1
a200 1
	_p = (struct _str *)bu_calloc(1,sizeof(struct _str), "_str (getstruct)")
d202 1
a202 1
	_p = (union _unn *)bu_calloc(1,sizeof(union _unn), "_unn (getunion)")
d205 1
a205 1
/*
d208 2
d224 3
a226 2
/*
 *			B U _ C K M A G
d248 1
a248 2
/*
 *			B U _ A S S E R T
d250 10
d352 1
d355 3
a357 1
/*
d363 5
d373 1
d378 2
d465 1
d469 53
a521 52
/*
 *									*
 *			     B U _ L I S T				*
 *									*
 *			Doubly-linked list support			*
 *									*
 *  These macros assume that all user-provided structures will have	*
 *  a "struct bu_list" as their first element (often named "l" [ell]).	*
 *  Thus, a pointer to the bu_list struct is a "pun" for the		*
 *  user-provided structure as well, and the pointers can be converted	*
 *  back and forth safely with type casts.				*
 *									*
 *  Furthermore, the head of the linked list could be			*
 *  a full instance of the user-provided structure			*
 *  (although the storage-conscious programmer could make the head	*
 *  just an bu_list structure, with careful type casting).		*
 *  This results in a doubly-linked circular list, with the head	*
 *  having the same shape as all the list members.			*
 *  The application is free to make use of this symmetry and store	*
 *  data values in the head, or the extra storage in the head can	*
 *  be ignored.								*
 *									*
 *  Where a macro expects an argument "p", it should be a pointer to	*
 *  a user-provided structure.						*
 *									*
 *  Where a macro expects an argument "hp", it should be a pointer to	*
 *  a "struct bu_list" located in the list head, e.g., &(head.l).	*
 *									*
 *  Where a macro expects an argument "old", "new", or "cur", it should	*
 *  be a pointer to the "struct bu_list" located either			*
 *  in a user-provided structure, e.g. &((p)->l),			*
 *  or for the case of "old" it may also be in the list head, e.g.	*
 *	BU_LIST_INSERT( &(head.l), &((p)->l) );				*
 *									*
 *  Dequeueing the head of a list is a valid and			*
 *  well defined operation which should be performed with caution.	*
 *  Unless a pointer to some other element of the list is retained	*
 *  by the application, the rest of the linked list can no longer be	*
 *  referred to.							*
 *									*
 *  The "magic" field of the list header _must_ be set to the constant	*
 *  BU_LIST_HEAD_MAGIC, but the "magic" field of all list members	*
 *  should be established by user code, to identify the type of		*
 *  structure that the bu_list structure is embedded in.		*
 *  It is permissible for one list to contain an arbitrarily mixed	*
 *  set of user "magic" numbers, as long as the head is properly marked.*
 *									*
 *  There is a dual set of terminology used in some of the macros:	*
 *	FIRST / LAST	from the point of view of the list head		*
 *	NEXT / PREV	from the point of view of a list member		*
 *	forw / back	the actual pointer names			*
 *									*
d523 1
d526 3
a528 3
	long		magic;
	struct bu_list	*forw;		/* "forward", "next" */
	struct bu_list	*back;		/* "back", "last" */
d819 1
a819 1

d824 6
a829 1
 *
d846 3
a848 3
	struct bu_list	l;		/* linked list for caller's use */
	unsigned int	nbits;		/* actual size of bits[], in bits */
	bitv_t		bits[2];	/* variable size array */
d940 1
d945 3
a947 1
/*
d949 3
d954 7
a960 7
	long		magic;
	fastf_t		hg_min;		/* minimum value */
	fastf_t		hg_max;		/* maximum value */
	fastf_t		hg_clumpsize;	/* (max-min+1)/nbins+1 */
	long		hg_nsamples;	/* total number of samples spread into histogram */
	long		hg_nbins;	/* # of bins in hg_bins[] */
	long		*hg_bins;	/* array of counters */
d986 1
a986 1

d989 4
a992 1
/*
d995 11
a1014 10

struct bu_ptbl {
	struct bu_list	l;	/* linked list for caller's use */
	int		end;	/* index into buffer of first available location */
	int		blen;	/* # of (long *)'s worth of storage at *buffer */
	long 		**buffer; /* data storage area */
};
#define BU_PTBL_MAGIC		0x7074626c		/* "ptbl" */
#define BU_CK_PTBL(_p)		BU_CKMAG(_p, BU_PTBL_MAGIC, "bu_ptbl")

d1045 1
d1049 1
a1049 1
/*
d1051 3
a1053 1
 *
d1070 1
d1073 10
a1082 10
	char		*name;		/* bu_strdup() of file name */
	genptr_t	buf;		/* In-memory copy of file (may be mmapped) */
	long		buflen;		/* # bytes in 'buf' */
	int		is_mapped;	/* 1=mmap() used, 0=bu_malloc/fread */
	char		*appl;		/* bu_strdup() of tag for application using 'apbuf' */
	genptr_t	apbuf;		/* opt: application-specific buffer */
	long		apbuflen;	/* opt: application-specific buflen */
	long		modtime;	/* date stamp, in case file is modified */
	int		uses;		/* # ptrs to this struct handed out */
	int		dont_restat;	/* 1=on subsequent opens, don't re-stat() */
d1087 1
d1094 3
a1096 3
	struct bu_list	l;
	bu_hook_t	hookfunc;
	genptr_t 	clientdata;
d1108 2
d1121 2
a1122 2
	const char	*name;
	const char	*value;
d1143 2
a1144 2
	int				count;	/* # valid entries in avp */
	int				max;	/* # allocated slots in avp */
d1147 1
a1147 1
	struct bu_attribute_value_pair	*avp;	/* array[max] */
d1165 1
d1168 2
d1175 3
a1177 3
	char	*vls_str;	/* Dynamic memory for buffer */
	int	vls_offset;	/* Offset into vls_str where data is good */
	int	vls_len;	/* Length, not counting the null */
d1205 1
a1205 1

d1207 2
d1242 1
d1245 4
d1282 1
d1285 2
d1413 7
a1419 7
	char		sp_fmt[4];		/* "i" or "%f", etc */
	long		sp_count;		/* number of elements */
	char		*sp_name;		/* Element's symbolic name */
	long		sp_offset;		/* Byte offset in struct */
	void		(*sp_hook)();		/* Optional hooked function, or indir ptr */
	char		*sp_desc;		/* description of element */
	void		*sp_default;		/* ptr to default value */
d1446 1
d1465 2
d1565 4
a1568 4
    long		rbp_magic;	/* Magic no. for integrity check */
    struct bu_rb_node	**rbp_node;	/* Containing nodes */
    struct bu_rb_list	*rbp_list_pos;	/* Place in the list of all pkgs. */
    void		*rbp_data;	/* Application data */
d1584 10
a1593 10
    long		rbn_magic;	/* Magic no. for integrity check */
    bu_rb_tree		*rbn_tree;	/* Tree containing this node */
    struct bu_rb_node	**rbn_parent;	/* Parents */
    struct bu_rb_node	**rbn_left;	/* Left subtrees */
    struct bu_rb_node	**rbn_right;	/* Right subtrees */
    char		*rbn_color;	/* Colors of this node */
    int			*rbn_size;	/* Sizes of subtrees rooted here */
    struct bu_rb_package **rbn_package;	/* Contents of this node */
    int			rbn_pkg_refs;	/* How many orders are being used? */
    struct bu_rb_list	*rbn_list_pos;	/* Place in the list of all nodes */
d1614 1
d1642 1
d1644 2
d1682 1
d1936 3
d1941 1
@


14.34
log
@Added bu_fgets()
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.33 2006/07/09 10:02:35 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.33 2006/07/09 10:02:35 brlcad Exp $ (BRL)"
d2543 2
@


14.33
log
@change the function signature from using ints to using long ints for the count, take a void* like read(), return a long (fixing the previous bogus void)
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.32 2006/07/09 09:25:58 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.32 2006/07/09 09:25:58 brlcad Exp $ (BRL)"
d1638 5
@


14.32
log
@export the new bu_mread() function call so everyone gets to use it
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.31 2006/07/06 19:35:17 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.31 2006/07/06 19:35:17 brlcad Exp $ (BRL)"
d2476 2
a2477 2
BU_EXPORT BU_EXTERN(void bu_mread,
		    (int fd, char *bufp, int n));
@


14.31
log
@follow erik's lead, obliterate the other references to Cakefiles
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.30 2006/03/29 20:02:23 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.30 2006/03/29 20:02:23 brlcad Exp $ (BRL)"
d2475 4
@


14.30
log
@add support for the intel compiler on altix, i.e. for compiling with icc on ia64.. bu_byteoffset so needs to be dynamically detected by configure or even at run-time.
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.29 2006/02/03 02:07:34 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.29 2006/02/03 02:07:34 brlcad Exp $ (BRL)"
d2234 1
a2234 1
/* vers.c (created by the Cakefile) */
@


14.29
log
@er, bu_argv0() was declared twice.  remove it.
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.28 2006/02/03 02:02:05 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.28 2006/02/03 02:02:05 brlcad Exp $ (BRL)"
d1262 5
a1266 2
#        define bu_byteoffset(_i)	((long)(((void *)&(_i))-((void *)0)))

@


14.29.2.1
log
@update from HEAD
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.29 2006/02/03 02:07:34 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.29 2006/02/03 02:07:34 brlcad Exp $ (BRL)"
d1262 2
a1263 5
#        if defined (__INTEL_COMPILER)
#          define bu_byteoffset(_i)	((long)((char *)&(_i)))
#        else
#          define bu_byteoffset(_i)	((long)(((void *)&(_i))-((void *)0)))
#        endif
@


14.28
log
@bu_argv0 was replaced with bu_setprogname and bu_getprogname rather quickly so no need to deprecate it.  just remove.
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.27 2006/01/22 23:44:49 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.27 2006/01/22 23:44:49 brlcad Exp $ (BRL)"
a1684 2
BU_EXPORT BU_EXTERN(const char *bu_argv0,
		    (const char *path));
@


14.27
log
@remove the need for HAVE_STDLIB_H and need for stdlib.h and stddef.h.  instead, let files that use the offsetof macros include stdlib.h.  don't need decls for malloc,calloc,realloc any more.  provide bu_offsetof() macro
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.26 2006/01/21 00:02:28 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.26 2006/01/21 00:02:28 brlcad Exp $ (BRL)"
d1677 2
a1678 1
BU_EXPORT BU_EXTERN(const char *bu_argv0, (const char *path));
@


14.26
log
@remove the unnecessary time_t type from the public header so that the dependency on time.h may be eliminated
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.25 2006/01/18 06:46:10 brlcad Exp $
d59 2
a60 2
#ifndef SEEN_BU_H
#define SEEN_BU_H seen
d64 2
a68 2
__BEGIN_DECLS

d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.25 2006/01/18 06:46:10 brlcad Exp $ (BRL)"
a118 17
/*----------------------------------------------------------------------*/
/*
 *  System library routines used by LIBBS.
 *  If header files are to be included, this should happen first,
 *  to prevent accidentally redefining important stuff.
 */
#if HAVE_STDLIB_H
/*	NOTE:  Nested includes, gets malloc(), offsetof(), etc */
#	include <stdlib.h>
#	include <stddef.h>
#else
extern char	*malloc();
extern char	*calloc();
extern char	*realloc();
/**extern void	free(); **/
#endif

d772 2
d1216 10
d1227 2
a1228 4
 *  The general problem of word-addressed hardware
 *  where (int *) and (char *) have different representations
 *  is handled in the parsing routines that use sp_offset,
 *  because of the limitations placed on compile-time initializers.
a1232 5
#	if !defined(offsetof)
#		define bu_offsetof(_t, _m)		(int)(&(((_t *)0)->_m))
#	else
#		define bu_offsetof(_t, _m)	offsetof(_t, _m)
#	endif
d1235 5
d1241 3
a1243 1
/*
d2550 1
a2550 1
#endif /* SEEN_BU_H */
@


14.25
log
@update copyright to 2006
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.24 2005/12/23 21:26:25 bob1961 Exp $
d83 1
a83 9
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.24 2005/12/23 21:26:25 bob1961 Exp $ (BRL)"

#ifdef HAVE_TIME_H
# include <time.h>
#endif

#ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
#endif
d1034 1
a1034 1
	time_t		modtime;	/* date stamp, in case file is modified */
@


14.24
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.23 2005/10/23 04:44:26 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.23 2005/10/23 04:44:26 brlcad Exp $ (BRL)"
@


14.23
log
@trailing ws
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.22 2005/08/25 00:19:10 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.22 2005/08/25 00:19:10 brlcad Exp $ (BRL)"
d1697 2
d2222 3
@


14.22
log
@need bu_argv0 to be exported, mged uses it
@
text
@d41 1
a41 1
 *  
d56 1
a56 1
 *  $Header$
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header$ (BRL)"
d144 2
a145 2
/* 
 * BU_FLSTR   Macro for getting a concatenated string of the current 
d607 1
a607 1
 *  
d797 1
a797 1
 */  
d1213 1
a1213 1
	
d1296 1
a1296 1
 * } 
d1298 1
a1298 1
 * struct data_structure data_default = 
d1307 1
a1307 1
 *	"a single character",	(void*)&default.a_char }, 
d1311 1
a1311 1
 *	"This is a full character string", (void*)default.str }, }, 
d1326 1
a1326 1
 *	BU_STRUCTPARSE_FUNC_NULL, 
d1922 1
a1922 1
		     const struct bu_structparse *desc, 
@


14.22.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d41 1
a41 1
 *
d144 2
a145 2
/*
 * BU_FLSTR   Macro for getting a concatenated string of the current
d607 1
a607 1
 *
d797 1
a797 1
 */
d1213 1
a1213 1

d1296 1
a1296 1
 * }
d1298 1
a1298 1
 * struct data_structure data_default =
d1307 1
a1307 1
 *	"a single character",	(void*)&default.a_char },
d1311 1
a1311 1
 *	"This is a full character string", (void*)default.str }, },
d1326 1
a1326 1
 *	BU_STRUCTPARSE_FUNC_NULL,
d1922 1
a1922 1
		     const struct bu_structparse *desc,
@


14.21
log
@port_setlinebuf is deprecated, so remove it from here and move it to src/libbu/linebuf.c where we bu_log a deprecation warning message
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.20 2005/08/16 20:33:47 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.20 2005/08/16 20:33:47 brlcad Exp $ (BRL)"
d1690 1
@


14.20
log
@remove the SNPRINTF define since it should be safe to use snprintf() now that it's properly accounted for in config_win.h as a compat function
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.19 2005/08/15 21:51:10 bob1961 Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.19 2005/08/15 21:51:10 bob1961 Exp $ (BRL)"
a1764 1
#define port_setlinebuf		bu_setlinebuf	/* libsysv compat */
@


14.19
log
@Mods for Windows port
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.18 2005/07/25 05:46:17 brlcad Exp $
a80 6
#if defined(_WIN32) && !defined(__CYGWIN__)
#   define SNPRINTF _snprintf
#else
#   define SNPRINTF snprintf
#endif

d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.18 2005/07/25 05:46:17 brlcad Exp $ (BRL)"
@


14.19.2.1
log
@Mods for windows port
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.19 2005/08/15 21:51:10 bob1961 Exp $
d81 6
d89 1
a89 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.19 2005/08/15 21:51:10 bob1961 Exp $ (BRL)"
a1701 2
BU_EXPORT BU_EXTERN(const char *bu_argv0,
		    (const char *path));
@


14.18
log
@include the new bu_file_exists prototype; include the BU_PATH_SEPARATOR define
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.17 2005/07/18 05:03:20 brlcad Exp $
d81 6
d89 1
a89 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.17 2005/07/18 05:03:20 brlcad Exp $ (BRL)"
@


14.17
log
@add a check for MAXPATHLEN just to be sure it gets set
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.16 2005/07/06 23:53:39 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.16 2005/07/06 23:53:39 brlcad Exp $ (BRL)"
d94 1
a94 1
/** define BU_DIR_SEPARATOR to the directory path separator character
d114 13
d1686 3
a1689 2
BU_EXPORT BU_EXTERN(int	bu_file_exists,
		    (const char *path));
@


14.16
log
@provide a BU_DIR_SEPARATOR define consistently for directory path separator
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.15 2005/07/06 23:30:24 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.15 2005/07/06 23:30:24 brlcad Exp $ (BRL)"
d110 3
@


14.16.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.18 2005/07/25 05:46:17 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.18 2005/07/25 05:46:17 brlcad Exp $ (BRL)"
d94 1
a94 1
/** define BU_DIR_SEPARATOR to the directory separator character
a109 16
#ifndef MAXPATHLEN
#  define MAXPATHLEN 1024
#endif

/** define BU_PATH_SEPARATOR to the path list separator character
 */
#if defined(PATH_SEPARATOR)
#  define BU_PATH_SEPARATOR PATH_SEPARATOR
#else
#  if defined(_WIN32)
#    define BU_PATH_SEPARATOR ';'
#  else
#    define BU_PATH_SEPARATOR ':'
#  endif  /* _WIN32 */
#endif  /* PATH_SEPARATOR */

a1669 3
/* stat.c */
BU_EXPORT BU_EXTERN(int	bu_file_exists, (const char *path));

d1671 2
@


14.15
log
@bu_brlcad_path is deprecated in favor of bu_brlcad_data and bu_brlcad_root depending on whether one is searching for data resources or not
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.14 2005/06/21 06:58:58 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.14 2005/06/21 06:58:58 brlcad Exp $ (BRL)"
d93 18
@


14.14
log
@gcc does not like __INTADDR__ in bu_byteoffset() since it's not necessarily constant
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.13 2005/06/21 06:31:55 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.13 2005/06/21 06:31:55 brlcad Exp $ (BRL)"
d1655 5
a1659 1
BU_EXPORT BU_EXTERN(char *bu_brlcad_path,
a1677 11
/* brlcad_path.c */
BU_EXPORT BU_EXTERN(int bu_file_exists,
		    (const char *path));
BU_EXPORT BU_EXTERN(char *bu_brlcad_path,
		    (const char *rhs, int fail_quietly));

/* fopen_uniq */
BU_EXPORT BU_EXTERN(FILE *bu_fopen_uniq,
		    (const char *outfmt,
		     const char *namefmt,
		     int n));
d2366 13
@


14.13
log
@add the bu_byteoffset comment about constant offsets and cray compensation
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.12 2005/05/28 02:14:49 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.12 2005/05/28 02:14:49 brlcad Exp $ (BRL)"
d1233 1
a1233 1
#  if defined(IRIX) && IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
@


14.12
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.11 2005/05/11 01:25:24 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.11 2005/05/11 01:25:24 brlcad Exp $ (BRL)"
d1224 5
@


14.11
log
@use generic pointers for the avs min/max ranges
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.10 2005/05/08 05:27:57 brlcad Exp $
d70 1
a70 1
#  if defined(WIN32) && !defined(__CYGWIN__) && defined(BRLCAD_DLL)
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.10 2005/05/08 05:27:57 brlcad Exp $ (BRL)"
@


14.10
log
@consolidate the __cplusplus external declaration sections that protect C functions from C++ name mangling by using the same __BEGIN_DECLS and __END_DECLS macros in our headers (3rd party are mostly left alone).  works indentation a little too.
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.9 2005/04/11 18:32:26 brlcad Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.9 2005/04/11 18:32:26 brlcad Exp $ (BRL)"
d1070 2
a1072 2
	char				*readonly_min;
	char				*readonly_max;
d1088 1
a1088 1
	    ((_p) < (_avsp)->readonly_min || (_p) > (_avsp)->readonly_max) )
@


14.9
log
@add explicit build support for sparc64
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.8 2005/03/24 16:28:24 bob1961 Exp $
d67 1
a67 3
#ifdef __cplusplus
extern "C" {
#endif
d70 9
a78 9
#if defined(WIN32) && !defined(__CYGWIN__) && defined(BRLCAD_DLL)
#ifdef BU_EXPORT_DLL
#define BU_EXPORT __declspec(dllexport)
#else
#define BU_EXPORT __declspec(dllimport)
#endif
#else
#define BU_EXPORT
#endif
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.8 2005/03/24 16:28:24 bob1961 Exp $ (BRL)"
d2510 1
a2511 3
#ifdef __cplusplus
}
#endif
@


14.8
log
@Add another condition for deciding how to define BU_EXPORT (allows for static compile); Declare Bu_d_Init
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.7 2005/03/23 15:52:56 lbutler Exp $
d85 1
a85 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.7 2005/03/23 15:52:56 lbutler Exp $ (BRL)"
d1237 1
a1237 1
#      if defined(__ia64__) || defined(__x86_64__)
@


14.7
log
@changes to suport Jim Hunt's fast memory debugging
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.6 2005/01/30 20:30:10 brlcad Exp $
d71 2
a72 1
#if defined(WIN32) && !defined(__CYGWIN__)
d81 1
d85 1
a85 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.6 2005/01/30 20:30:10 brlcad Exp $ (BRL)"
d2385 4
d2391 1
@


14.6
log
@update copyright to 2005
@
text
@d56 1
a56 1
 *  $Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.5 2004/12/21 07:32:29 morrison Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvsroot/brlcad/brlcad/include/bu.h,v 14.5 2004/12/21 07:32:29 morrison Exp $ (BRL)"
d1181 1
a1181 1

d1194 1
a1194 1
\014MAPPED_FILE\013AVS\012PTBL\011MATH\010?\7?\6?\5PARALLEL\
@


14.5
log
@tidy up a lil bit
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d56 1
a56 1
 *  $Header: /cvs/brlcad/include/bu.h,v 14.4 2004/12/21 07:25:29 morrison Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 14.4 2004/12/21 07:25:29 morrison Exp $ (BRL)"
@


14.4
log
@tidy up a lil bit
@
text
@d56 1
a56 1
 *  $Header: /cvs/brlcad/include/bu.h,v 14.3 2004/12/21 06:23:18 morrison Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 14.3 2004/12/21 06:23:18 morrison Exp $ (BRL)"
a1516 2
 *
 *
@


14.3
log
@use perl to M-q format wrapping
@
text
@d56 1
a56 1
 *  $Header: /cvs/brlcad/include/bu.h,v 14.2 2004/12/21 06:06:38 butler Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 14.2 2004/12/21 06:06:38 butler Exp $ (BRL)"
a330 2
 *
 *
@


14.2
log
@LGPL license changes
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU Lesser General Public License
 * along with this file; see the file named COPYING for more
d56 1
a56 1
 *  $Header: /cvs/brlcad/include/bu.h,v 14.1 2004/11/16 19:42:10 morrison Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 14.1 2004/11/16 19:42:10 morrison Exp $ (BRL)"
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *				B U . H
a44 3
 *  
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d56 1
a56 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.14 2004/10/14 19:19:28 morrison Exp $
d83 1
a83 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.14 2004/10/14 19:19:28 morrison Exp $ (BRL)"
@


1.14
log
@add an option to bu_brlcad_path to fail quietly, returning a NULL string instead of gobs of output and bu_bomb'ing
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.13 2004/10/04 14:00:44 morrison Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.13 2004/10/04 14:00:44 morrison Exp $ (BRL)"
d2498 10
@


1.13
log
@lets not talk about the previous h/ header directory any more
@
text
@d40 1
a40 1
 *  $Header: /n/xoff/cvs/brlcad/include/bu.h,v 1.12 2004/09/28 13:50:23 butler Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /n/xoff/cvs/brlcad/include/bu.h,v 1.12 2004/09/28 13:50:23 butler Exp $ (BRL)"
d1639 1
a1639 1
		    (const char *rhs));
d1661 1
a1661 1
		    (const char *rhs));
@


1.12
log
@added bu_strdupm() which has a "purpose" string similar to bu_malloc() and friends.  Am contemplating making this the default, and adjusting code throughout BRL-CAD to reflect the change.
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.11 2004/09/20 19:37:30 morrison Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.11 2004/09/20 19:37:30 morrison Exp $ (BRL)"
d1079 1
a1079 1
 *  Variable Length Strings: bu_vls support (formerly rt_vls in h/rtstring.h)
@


1.11
log
@support byteoffsets for the amd64 opterons too.
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.10 2004/09/16 06:24:17 morrison Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.10 2004/09/16 06:24:17 morrison Exp $ (BRL)"
d1808 2
@


1.10
log
@const char *[]
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.9 2004/09/15 05:39:13 morrison Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.9 2004/09/15 05:39:13 morrison Exp $ (BRL)"
d1221 1
a1221 1
#      if defined(__ia64__)
@


1.9
log
@make bu_structparse_get_terse_form() take a constant pointer to quell warnings
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.8 2004/09/03 19:57:13 morrison Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.8 2004/09/03 19:57:13 morrison Exp $ (BRL)"
d2142 1
a2142 1
		     char **argv));
@


1.8
log
@use ((long)(((void *)&(_i))-((void *)0))) as a byte offset for __ia64__ .. there probably shouldn't be three of these..
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.7 2004/09/02 12:09:33 morrison Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.7 2004/09/02 12:09:33 morrison Exp $ (BRL)"
d2267 1
a2267 1
		     register struct bu_structparse *sp));
@


1.7
log
@fugly addition of __ia64__ to the mix -- pointers are long offsets since it's a 64bit platform.  the whole offsetting needs to be properly checked by configure at some point.
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.6 2004/08/03 20:42:29 morrison Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.6 2004/08/03 20:42:29 morrison Exp $ (BRL)"
d1222 1
a1222 1
#        define bu_byteoffset(_i)	((long)(((char *)&(_i))-((char *)0)))
@


1.6
log
@apply Bob's provided patches from 20040630.  this includes itcl namespace scoping, windows DLL exporting, and wdb arb edit support
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.2 2004/06/25 20:39:34 butler Exp $
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.2 2004/06/25 20:39:34 butler Exp $ (BRL)"
d1215 1
a1215 1
#	define bu_byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
d1218 2
a1219 2
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define bu_byteoffset(_i)	((int)((char *)&(_i)))
d1221 7
a1227 2
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define bu_byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
@


1.5
log
@refer to the common.h header now instead of config.h
@
text
@d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.4 2004/08/02 22:24:40 morrison Exp $
d55 10
d67 1
a67 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.4 2004/08/02 22:24:40 morrison Exp $ (BRL)"
d321 54
a374 13
extern int bu_cv_itemlen(int cookie);
extern int bu_cv_cookie(char *in);
extern int bu_cv_optimize(int cookie);
extern int bu_cv_w_cookie(genptr_t, int, size_t, genptr_t, int, int);

extern int bu_cv_ntohss(signed short *, size_t, genptr_t, int);
extern int bu_cv_ntohus(unsigned short *, size_t, genptr_t, int);
extern int bu_cv_ntohsl(signed long int *, size_t, genptr_t, int);
extern int bu_cv_ntohul(unsigned long int *, size_t, genptr_t, int);
extern int bu_cv_htonss(genptr_t, size_t, signed short *, int);
extern int bu_cv_htonus(genptr_t, size_t, unsigned short *, int);
extern int bu_cv_htonsl(genptr_t, size_t, long *, int);
extern int bu_cv_htonul(genptr_t, size_t, unsigned long *, int);
d470 2
a471 2
struct bu_list *bu_list_new(void);
struct bu_list *bu_list_pop( struct bu_list *hp );
d1016 2
a1017 2
extern struct bu_hook_list bu_log_hook_list;
extern struct bu_hook_list bu_bomb_hook_list;
d1111 2
a1112 2
extern int	bu_setjmp_valid;		/* !0 = bu_jmpbuf is valid */
extern jmp_buf	bu_jmpbuf;			/* for BU_SETJMP() */
d1156 1
a1156 1
extern int	bu_debug;
d1517 35
a1551 19
BU_EXTERN(void			bu_avs_init, (struct bu_attribute_value_set *avp,
				int len, const char *str));
BU_EXTERN(void			bu_avs_init_empty, (struct bu_attribute_value_set *avp ));
BU_EXTERN(struct bu_attribute_value_set	*bu_avs_new, (int len, const char *str));
BU_EXTERN(int			bu_avs_add, (struct bu_attribute_value_set *avp,
				const char *attribute,
				const char *value));
extern int			bu_avs_add_vls(struct bu_attribute_value_set *avp,
				const char *attribute,
				const struct bu_vls *value_vls);
void				bu_avs_merge( struct bu_attribute_value_set *dest,
				const struct bu_attribute_value_set *src );
extern const char *		bu_avs_get( const struct bu_attribute_value_set *avp,
				const char *attribute );
BU_EXTERN(int			bu_avs_remove, (struct bu_attribute_value_set *avp,
				const char *attribute));
BU_EXTERN(void			bu_avs_free, (struct bu_attribute_value_set *avp));
extern void			bu_avs_print( const struct bu_attribute_value_set *avp, const char *title );
extern void bu_avs_add_nonunique( struct bu_attribute_value_set *avsp, char *attribute, char *value );
d1554 6
a1559 2
BU_EXTERN(void			bu_badmagic, (const long *ptr, unsigned long magic,
				const char *str, const char *file, int line));
d1562 25
a1586 15
BU_EXTERN(struct bu_bitv *	bu_bitv_new, (unsigned int nbits));
BU_EXTERN(void			bu_bitv_clear, (struct bu_bitv *bv));
BU_EXTERN(void			bu_bitv_or, (struct bu_bitv *ov,
				const struct bu_bitv *iv));
BU_EXTERN(void			bu_bitv_and, (struct bu_bitv *ov,
				const struct bu_bitv *iv));
BU_EXTERN(void			bu_bitv_vls, (struct bu_vls *v,
				const struct bu_bitv *bv));
BU_EXTERN(void			bu_pr_bitv, (const char *str,
				const struct bu_bitv *bv));
BU_EXTERN(void			bu_bitv_to_hex, (struct bu_vls *v,
				const struct bu_bitv *bv));
BU_EXTERN( struct bu_bitv *	bu_hex_to_bitv, (const char *str));
BU_EXTERN( struct bu_bitv *	bu_bitv_dup, (const struct bu_bitv *bv));
BU_EXTERN( void			bu_bitv_free, (struct bu_bitv *bv));
d1589 2
a1590 1
BU_EXTERN(void			bu_bomb, (const char *str) );
d1593 48
a1640 24
BU_EXTERN(void		bu_rgb_to_hsv,		(unsigned char *rgb,
						    fastf_t *hsv) );
BU_EXTERN(int		bu_hsv_to_rgb,		(fastf_t *hsv,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_str_to_rgb,		(char *str,
						    unsigned char *rgb) );
BU_EXTERN(void		bu_color_of_rgb_chars,	(struct bu_color *cp,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_color_to_rgb_chars,	(struct bu_color *cp,
						    unsigned char *rgb) );
BU_EXTERN(int		bu_color_of_rgb_floats,	(struct bu_color *cp,
						    fastf_t *rgb) );
BU_EXTERN(int		bu_color_to_rgb_floats,	(struct bu_color *cp,
						    fastf_t *rgb) );
BU_EXTERN(int		bu_color_of_hsv_floats,	(struct bu_color *cp,
						    fastf_t *hsv) );
BU_EXTERN(int		bu_color_to_hsv_floats,	(struct bu_color *cp,
						    fastf_t *hsv) );

/* convert.c*/
BU_EXTERN(int bu_cv_cookie, (char *in));
BU_EXTERN(int bu_cv_optimize, (int cookie));
BU_EXTERN(int bu_cv_w_cookie, (genptr_t out, int outcookie, size_t size,
			     genptr_t in,  int incookie,  int count));
d1643 8
a1650 4
BU_EXTERN(struct bu_file	*bu_fopen, (char *fname, char *type) );
BU_EXTERN(int			bu_fclose, (struct bu_file *bfp) );
BU_EXTERN(int			bu_fgetc, (struct bu_file *bfp) );
BU_EXTERN(void			bu_printfile, (struct bu_file *bfp) );
d1653 4
a1656 2
BU_EXTERN(int			bu_file_exists, (const char *path) );
BU_EXTERN(char			*bu_brlcad_path, (const char *rhs) );
d1659 4
a1662 3
BU_EXTERN(FILE *		bu_fopen_uniq, (const char *outfmt,
						const char *namefmt,
						int n) );
d1664 7
a1670 6
extern int			bu_opterr;
extern int			bu_optind;
extern int			bu_optopt;
extern char *			bu_optarg;
BU_EXTERN(int			bu_getopt, (int nargc, char * const nargv[],
				const char *ostr) );
d1673 14
a1686 7
BU_EXTERN(void			bu_hist_free, (struct bu_hist *histp));
BU_EXTERN(void			bu_hist_init, (struct bu_hist *histp,
				fastf_t min, fastf_t max, unsigned int nbins));
BU_EXTERN(void			bu_hist_range, (struct bu_hist *hp,
				fastf_t low, fastf_t high));
BU_EXTERN(void			bu_hist_pr, (const struct bu_hist *histp,
				const char *title));
d1689 8
a1696 4
BU_EXTERN(void			htond, (unsigned char *out,
				const unsigned char *in, int count));
BU_EXTERN(void			ntohd, (unsigned char *out,
				const unsigned char *in, int count));
d1699 8
a1706 4
BU_EXTERN(void			htonf, (unsigned char *out,
				const unsigned char *in, int count));
BU_EXTERN(void			ntohf, (unsigned char *out,
				const unsigned char *in, int count));
d1709 4
a1712 2
BU_EXTERN(int			bu_is_parallel, () );
BU_EXTERN(void			bu_kill_parallel, () );
d1716 2
a1717 1
BU_EXTERN(void			bu_setlinebuf, (FILE *fp) );
d1720 18
a1737 10
BU_EXTERN(int			bu_list_len, (const struct bu_list *hd));
BU_EXTERN(void			bu_list_reverse, (struct bu_list *hd));
BU_EXTERN(void			bu_list_free, (struct bu_list *hd));
BU_EXTERN(void			bu_list_parallel_append, (struct bu_list *headp,
					struct bu_list *itemp));
BU_EXTERN(struct bu_list *	bu_list_parallel_dequeue, (struct bu_list *headp));
BU_EXTERN(void			bu_ck_list, (const struct bu_list *hd,
				const char *str) );
BU_EXTERN(void			bu_ck_list_magic, (const struct bu_list *hd,
				const char *str, const long magic) );
d1740 13
a1752 4
BU_EXTERN(void			bu_hook_list_init, (struct bu_hook_list *hlp));
BU_EXTERN(void			bu_add_hook, (struct bu_hook_list *hlp, bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_delete_hook, (struct bu_hook_list *hlp, bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_call_hook, (struct bu_hook_list *hlp, genptr_t buf));
d1755 12
a1766 5
BU_EXTERN(void			bu_log_indent_delta, (int delta) );
BU_EXTERN(void			bu_log_indent_vls, (struct bu_vls *v) );
BU_EXTERN(void			bu_log_add_hook, (bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_log_delete_hook, (bu_hook_t func, genptr_t clientdata));
BU_EXTERN(void			bu_putchar, (int c) );
d1768 4
a1771 2
 BU_EXTERN(void			bu_log, (char *, ... ) );
 BU_EXTERN(void			bu_flog, (FILE *, char *, ... ) );
d1773 4
a1776 2
 BU_EXTERN(void			bu_log, () );
 BU_EXTERN(void			bu_flog, () );
d1780 2
a1781 1
BU_EXTERN(const char *		bu_identify_magic, (long magic) );
d1784 29
a1812 15
extern long		bu_n_malloc;
extern long		bu_n_free;
extern long		bu_n_realloc;
BU_EXTERN(genptr_t		bu_malloc, (unsigned int cnt, const char *str));
BU_EXTERN(void			bu_free, (genptr_t ptr, const char *str));
BU_EXTERN(genptr_t		bu_realloc, (genptr_t ptr, unsigned int cnt,
				const char *str));
BU_EXTERN(genptr_t		bu_calloc, (unsigned int nelem,
				unsigned int elsize, const char *str));
BU_EXTERN(void			bu_prmem, (const char *str));
BU_EXTERN(char *		bu_strdup, (const char *cp));
BU_EXTERN(char *		bu_dirname, (const char *cp));
BU_EXTERN(int			bu_malloc_len_roundup, (int nbytes));
BU_EXTERN(void			bu_ck_malloc_ptr, (genptr_t ptr, const char *str));
BU_EXTERN(int			bu_mem_barriercheck, ());
d1815 14
a1828 9
BU_EXTERN(struct bu_mapped_file *bu_open_mapped_file, (const char *name,
					const char *appl));
BU_EXTERN(void			bu_close_mapped_file, (struct bu_mapped_file *mp));
BU_EXTERN(void			bu_pr_mapped_file, (const char *title,
					const struct bu_mapped_file *mp));
BU_EXTERN(void			bu_free_mapped_files, (int verbose));
BU_EXTERN(struct bu_mapped_file *bu_open_mapped_file_with_path,
					(char * const *path,
					const char *name, const char *appl));
d1831 18
a1848 9
BU_EXTERN(void			bu_nice_set, (int newnice));
BU_EXTERN(int			bu_cpulimit_get, ());
BU_EXTERN(void			bu_cpulimit_set, (int sec));
BU_EXTERN(int			bu_avail_cpus, ());
BU_EXTERN(fastf_t		bu_get_load_average, ());
BU_EXTERN(int			bu_get_public_cpus, ());
BU_EXTERN(int			bu_set_realtime, ());
BU_EXTERN(void			bu_parallel, (void (*func)BU_ARGS((int ncpu, genptr_t arg)),
				int ncpu, genptr_t arg));
d1851 75
a1925 48
BU_EXTERN(int			bu_struct_export, (struct bu_external *ext,
				const genptr_t base,
				const struct bu_structparse *imp));
BU_EXTERN(int			bu_struct_import, (genptr_t base,
				const struct bu_structparse *imp,
				const struct bu_external *ext));
BU_EXTERN(int			bu_struct_put, (FILE *fp,
				const struct bu_external *ext));
BU_EXTERN(int			bu_struct_get, (struct bu_external *ext,
				FILE *fp));
BU_EXTERN(void			bu_struct_wrap_buf,
				(struct bu_external *ext, genptr_t buf));
BU_EXTERN(int			bu_struct_parse, (const struct bu_vls *in_vls,
				const struct bu_structparse *desc, 
				const char *base));
BU_EXTERN(void			bu_struct_print, ( const char *title,
				const struct bu_structparse *parsetab,
				const char *base));
BU_EXTERN(void			bu_vls_struct_print, (struct bu_vls *vls,
				const struct bu_structparse *sdp,
				const char *base));
BU_EXTERN(void			bu_vls_struct_print2, (struct bu_vls *vls,
						       const char *title,
						       const struct bu_structparse *sdp,
						       const char *base));
BU_EXTERN(void			bu_vls_struct_item, (struct bu_vls *vp,
				const struct bu_structparse *sdp,
				const char *base,
				int sep_char));
BU_EXTERN(int			bu_vls_struct_item_named, (struct bu_vls *vp,
				const struct bu_structparse *sdp,
				const char *name,
				const char *base,
				int sep_char));
BU_EXTERN(void			bu_parse_mm, (const struct bu_structparse *sdp,
				const char *name,
				char *base,
				const char *value));
BU_EXTERN( int                  bu_key_eq_to_key_val, (char *in, char **next, struct bu_vls *vls) );
BU_EXTERN( int                  bu_shader_to_tcl_list, (char *in, struct bu_vls *vls) );
BU_EXTERN( int                  bu_key_val_to_key_eq, (char *in) );
BU_EXTERN( int                  bu_shader_to_key_eq, (char *in, struct bu_vls *vls) );
int				bu_fwrite_external( FILE *fp, const struct bu_external *ep );
void				bu_hexdump_external( FILE *fp, const struct bu_external *ep, const char *str);
void				bu_free_external(struct bu_external *ep);
void				bu_copy_external(struct bu_external *op, const struct bu_external *ip);
char				*bu_next_token( char *str );
				
d1927 8
a1934 5
BU_EXTERN(void			bu_vls_printb, (struct bu_vls *vls,
				const char *s, unsigned long v,
				const char *bits));
BU_EXTERN(void			bu_printb, (const char *s, unsigned long v,
				const char *bits));
d1937 38
a1974 16
BU_EXTERN(void			bu_ptbl_init, (struct bu_ptbl *b, int len, const char *str));
BU_EXTERN(void			bu_ptbl_reset, (struct bu_ptbl	*b));
BU_EXTERN(int			bu_ptbl_ins, (struct bu_ptbl *b, long *p));
BU_EXTERN(int			bu_ptbl_locate, (const struct bu_ptbl *b, const long *p));
BU_EXTERN(void			bu_ptbl_zero, (struct bu_ptbl *b, const long *p));
BU_EXTERN(int			bu_ptbl_ins_unique, (struct bu_ptbl *b, long *p));
BU_EXTERN(int			bu_ptbl_rm, (struct bu_ptbl *b, const long *p));
BU_EXTERN(void			bu_ptbl_cat, (struct bu_ptbl *dest,
				const struct bu_ptbl *src));
BU_EXTERN(void			bu_ptbl_cat_uniq, (struct bu_ptbl *dest,
				const struct bu_ptbl *src));
BU_EXTERN(void			bu_ptbl_free, (struct bu_ptbl	*b));
BU_EXTERN(int			bu_ptbl, (struct bu_ptbl *b, int func, long *p));
BU_EXTERN(void			bu_pr_ptbl, (const char *title,
				const struct bu_ptbl *tbl, int verbose));
BU_EXTERN(void			bu_ptbl_trunc, (struct bu_ptbl *tbl, int end));
d1977 7
a1983 7
BU_EXTERN(bu_rb_tree *bu_rb_create,	(char		*description,
				 int 		nm_orders,
				 int		(**order_funcs)()
				));
BU_EXTERN(bu_rb_tree *bu_rb_create1,	(char		*description,
				 int		(*order_func)()
				));
d1985 3
a1987 3
BU_EXTERN(void bu_rb_delete,	(bu_rb_tree	*tree,
				 int		order
				));
d1991 6
a1996 6
BU_EXTERN(void bu_rb_diagnose_tree,(bu_rb_tree	*tree,
				 int		order,
				 int		trav_type
				));
BU_EXTERN(void bu_rb_summarize_tree,(bu_rb_tree	*tree
				 ));
d1998 3
a2000 3
BU_EXTERN(void *bu_rb_curr,	(bu_rb_tree	*tree,
				 int		order
				));
d2002 8
a2009 8
BU_EXTERN(void *bu_rb_extreme,	(bu_rb_tree	*tree,
				 int		order,
				 int		sense
				));
BU_EXTERN(void *bu_rb_neighbor,	(bu_rb_tree	*tree,
				 int		order,
				 int		sense
				));
d2011 3
a2013 3
BU_EXTERN(void bu_rb_free,		(bu_rb_tree	*tree,
				 void		(*free_data)()
				));
d2023 6
a2028 6
BU_EXTERN(int bu_rb_insert,	(bu_rb_tree	*tree,
				 void		*data
				));
BU_EXTERN(int bu_rb_is_uniq,	(bu_rb_tree	*tree,
				 int		order
				));
d2030 10
a2039 10
BU_EXTERN(void bu_rb_set_uniqv,	(bu_rb_tree	*tree,
				 bitv_t		vec
				));
BU_EXTERN(void bu_rb_uniq_all_off,	(bu_rb_tree	*tree
				));
BU_EXTERN(void bu_rb_uniq_all_on,	(bu_rb_tree	*tree
				));
BU_EXTERN(int bu_rb_uniq_off,	(bu_rb_tree	*tree,
				 int		order
				));
d2041 3
a2043 3
BU_EXTERN(int bu_rb_uniq_on,	(bu_rb_tree	*tree,
				 int		order
				));
d2047 3
a2049 3
BU_EXTERN(int bu_rb_rank,	(bu_rb_tree	*tree,
				 int		order
				));
d2051 4
a2054 4
BU_EXTERN(void *bu_rb_select,	(bu_rb_tree	*tree,
				 int		order,
				 int		k
				));
d2058 4
a2061 4
BU_EXTERN(void *bu_rb_search,	(bu_rb_tree	*tree,
				 int		order,
				 void		*data
				));
d2065 5
a2069 5
BU_EXTERN(void bu_rb_walk,		(bu_rb_tree	*tree,
				 int		order,
				 void		(*visit)(),
				 int		trav_type
				));
d2073 6
a2078 3
BU_EXTERN(void			bu_semaphore_init, (unsigned int nsemaphores));
BU_EXTERN(void			bu_semaphore_acquire, (unsigned int i));
BU_EXTERN(void			bu_semaphore_release, (unsigned int i));
d2081 78
a2158 28
BU_EXTERN(void			bu_vls_init, (struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_init_if_uninit, (struct bu_vls *vp) );
BU_EXTERN(struct bu_vls *	bu_vls_vlsinit, () );
BU_EXTERN(char *		bu_vls_addr, (const struct bu_vls *vp) );
BU_EXTERN(char *		bu_vls_strdup, (const struct bu_vls *vp) );
BU_EXTERN(char *		bu_vls_strgrab, (struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_extend, (struct bu_vls *vp, unsigned int extra) );
BU_EXTERN(void			bu_vls_setlen, (struct bu_vls *vp, int newlen));
BU_EXTERN(int			bu_vls_strlen, (const struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_trunc, (struct bu_vls *vp, int len) );
BU_EXTERN(void			bu_vls_trunc2, (struct bu_vls *vp, int len) );
BU_EXTERN(void			bu_vls_nibble, (struct bu_vls *vp, int len) );
BU_EXTERN(void			bu_vls_free, (struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_vlsfree, (struct bu_vls *vp) );
BU_EXTERN(void			bu_vls_strcpy, (struct bu_vls *vp, const char *s) );
BU_EXTERN(void			bu_vls_strncpy, (struct bu_vls *vp, const char *s, long n) );
BU_EXTERN(void			bu_vls_strcat, (struct bu_vls *vp, const char *s) );
BU_EXTERN(void			bu_vls_strncat, (struct bu_vls *vp, const char *s, long n) );
BU_EXTERN(void			bu_vls_vlscat, (struct bu_vls *dest, const struct bu_vls *src) );
BU_EXTERN(void			bu_vls_vlscatzap, (struct bu_vls *dest, struct bu_vls *src) );
BU_EXTERN(void			bu_vls_from_argv, (struct bu_vls *vp, int argc, char **argv) );
BU_EXTERN(int			bu_argv_from_string, (char **argv, int lim, char *lp));
BU_EXTERN(void			bu_vls_fwrite, (FILE *fp, const struct bu_vls *vp) );
void				bu_vls_write( int fd, const struct bu_vls *vp );
int				bu_vls_read( struct bu_vls *vp, int fd );
BU_EXTERN(int			bu_vls_gets, (struct bu_vls *vp, FILE *fp) );
BU_EXTERN(void			bu_vls_putc, (struct bu_vls *vp, int c) );
void				bu_vls_trimspace( struct bu_vls *vp );
d2160 15
a2174 7
BU_EXTERN(void			bu_vls_vprintf, (struct bu_vls *vls,
				const char *fmt, va_list ap));
#endif
BU_EXTERN(void			bu_vls_printf, (struct bu_vls *vls, char *fmt, ... ) );
BU_EXTERN(void			bu_vls_spaces, (struct bu_vls *vp, int cnt));
BU_EXTERN(int			bu_vls_print_positions_used, (const struct bu_vls *vp));
BU_EXTERN(void			bu_vls_detab, (struct bu_vls *vp));
d2177 4
a2180 1
BU_EXTERN(void			bu_vls_blkset, (struct bu_vls *vp, int len, int ch) );
d2183 3
a2185 1
BU_EXTERN(void			bu_vls_prepend, (struct bu_vls *vp, char *str) );
d2189 1
a2189 1
extern const char		bu_version[];
d2192 11
a2202 5
BU_EXTERN(double bu_units_conversion, (const char *str) );
BU_EXTERN(const char *bu_units_string, (const double mm) );
BU_EXTERN(double bu_mm_value, (const char *s) );
BU_EXTERN(void bu_mm_cvt, (register const struct bu_structparse	*sdp,
		register const char *name,  char *base, const char *value) );
d2225 10
a2234 6
BU_EXTERN(unsigned short	bu_gshort, (const unsigned char *msgp));
BU_EXTERN(unsigned long		bu_glong, (const unsigned char *msgp));
BU_EXTERN(unsigned char *	bu_pshort, (register unsigned char *msgp,
				register int s));
BU_EXTERN(unsigned char *	bu_plong, (register unsigned char *msgp,
				register unsigned long l));
d2238 4
a2241 1
BU_EXTERN(struct bu_vls *bu_association, (const char *fname, const char *value, int field_sep));
d2244 5
a2248 3
extern void bu_observer_notify();
extern struct bu_cmdtab bu_observer_cmds[];
extern void bu_observer_free(struct bu_observer *);
d2252 108
a2359 90
extern void bu_badmagic_tcl(Tcl_Interp	*interp,
			    const long	*ptr,
			    unsigned long	magic,
			    const char	*str,
			    const char	*file,
			    int		line);

extern void bu_structparse_get_terse_form(Tcl_Interp	*interp,
					  register struct bu_structparse *sp);

extern int bu_structparse_argv(Tcl_Interp			*interp,
			       int				argc,
			       char				**argv,
			       const struct bu_structparse	*desc,
			       char				*base);

extern int bu_tcl_mem_barriercheck(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_tcl_ck_malloc_ptr(ClientData		clientData,
				Tcl_Interp		*interp,
				int		argc,
				char		**argv);

extern int bu_tcl_malloc_len_roundup(ClientData	clientData,
				     Tcl_Interp	*interp,
				     int		argc,
				     char		**argv);

extern int bu_tcl_prmem(ClientData	clientData,
			Tcl_Interp	*interp,
			int	argc,
			char	**argv);

extern int bu_tcl_printb(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv);

extern int bu_get_value_by_keyword(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_get_all_keyword_values(ClientData	clientData,
				     Tcl_Interp	*interp,
				     int		argc,
				     char		**argv);

extern int bu_tcl_rgb_to_hsv(ClientData	clientData,
			     Tcl_Interp	*interp,
			     int		argc,
			     char		**argv);

extern int bu_tcl_hsv_to_rgb(ClientData	clientData,
			     Tcl_Interp	*interp,
			     int		argc,
			     char		**argv);

extern int bu_tcl_key_eq_to_key_val(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_shader_to_key_val(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_key_val_to_key_eq(ClientData	clientData,
				    Tcl_Interp	*interp,
				    int		argc,
				    char		**argv);

extern int bu_tcl_shader_to_key_eq(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);

extern int bu_tcl_brlcad_path(ClientData	clientData,
			      Tcl_Interp	*interp,
			      int		 argc,
			      char		**argv);

extern int bu_tcl_units_conversion(ClientData	clientData,
				   Tcl_Interp	*interp,
				   int		argc,
				   char		**argv);
d2361 2
a2362 1
extern void bu_tcl_setup(Tcl_Interp *interp);
d2364 2
a2365 1
extern int Bu_Init(Tcl_Interp *interp);
d2404 5
a2408 5
int bu_lex(
	union bu_lex_token *token,
	struct bu_vls *rtstr,
	struct bu_lex_key *keywords,
	struct bu_lex_key *symbols);
d2412 9
a2420 4
void bu_mro_init_with_string( struct bu_mro *mrop, const char *string );
void bu_mro_set( struct bu_mro *mrop, const char *string );
void bu_mro_init( struct bu_mro *mrop );
void bu_mro_free( struct bu_mro *mrop );
d2454 31
a2484 14
unsigned long bu_hash(unsigned char *str, int len);
struct bu_hash_tbl *bu_create_hash_tbl( unsigned long tbl_size );
struct bu_hash_entry *bu_find_hash_entry( struct bu_hash_tbl *hsh_tbl,
					  unsigned char *key,
					  int key_len,
					  struct bu_hash_entry **prev,
					  unsigned long *index2 );
void bu_set_hash_value( struct bu_hash_entry *hsh_entry, unsigned char *value );
unsigned char *bu_get_hash_value( struct bu_hash_entry *hsh_entry );
struct bu_hash_entry *bu_hash_add_entry( struct bu_hash_tbl *hsh_tbl, unsigned char *key, int key_len, int *new_entry );
void bu_hash_tbl_pr( struct bu_hash_tbl *hsh_tbl, char *str );
void bu_hash_tbl_free( struct bu_hash_tbl *hsh_tbl );
struct bu_hash_entry *bu_hash_tbl_first( struct bu_hash_tbl *hsh_tbl, struct bu_hash_record *rec );
struct bu_hash_entry *bu_hash_tbl_next( struct bu_hash_record *rec );
@


1.4
log
@include common.h instead of the wrapped config.h
@
text
@d31 1
a31 1
 *	#include "config.h"
d40 1
a40 1
 *  $Header: /cvs/brlcad/include/bu.h,v 1.3 2004/07/25 04:12:21 morrison Exp $
d57 1
a57 1
#define BU_H_VERSION	"@@(#)$Header: /cvs/brlcad/include/bu.h,v 1.3 2004/07/25 04:12:21 morrison Exp $ (BRL)"
@


1.3
log
@replace conf.h with config.h
@
text
@d40 1
a40 1
 *  $Header: /n/xoff/cvs/brlcad/include/bu.h,v 1.2 2004/06/25 20:39:34 butler Exp $
d46 1
a46 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
d57 1
a57 1
#define BU_H_VERSION	"@@(#)$Header: /n/xoff/cvs/brlcad/include/bu.h,v 1.2 2004/06/25 20:39:34 butler Exp $ (BRL)"
@


1.2
log
@added linux to the list of hosts which need the underscore in fortran routine
names.
@
text
@d31 1
a31 1
 *	#include "conf.h"
d40 1
a40 1
 *  $Header: /c/CVS/brlcad/include/bu.h,v 1.1 2004/05/24 04:10:49 morrison Exp $
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header: /c/CVS/brlcad/include/bu.h,v 1.1 2004/05/24 04:10:49 morrison Exp $ (BRL)"
@


1.1
log
@moved/renamed from top-level h/ to top-level include/
@
text
@d40 1
a40 1
 *  $Header$
d59 1
a59 1
#define BU_H_VERSION	"@@(#)$Header$ (BRL)"
d127 1
a127 1
#if defined(apollo) || defined(mips) || defined(aux)
@

