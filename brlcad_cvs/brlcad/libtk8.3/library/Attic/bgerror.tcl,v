head	1.2;
access;
symbols
	rel-6-1-DP:1.1.1.1
	rel-6-0-2:1.1.1.1
	rel-6-0-1-branch:1.1.1.1.0.4
	hartley-6-0-post:1.1.1.1
	hartley-6-0-pre:1.1.1.1
	rel-6-0-1:1.1.1.1
	rel-6-0:1.1.1.1
	rel-5-4:1.1.1.1
	offsite-5-3-pre:1.1.1.1
	rel-5-3:1.1.1.1
	rel-5-1-branch:1.1.1.1.0.2
	windows-6-0-branch:1.1.1.1.0.8
	ansi-6-0-branch:1.1.1.1.0.6
	tk8-3:1.1.1.1
	scriptics:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2003.03.13.19.13.37;	author jra;	state dead;
branches;
next	1.1;

1.1
date	2000.12.06.21.34.17;	author bparker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.12.06.21.34.17;	author bparker;	state Exp;
branches
	1.1.1.1.6.1
	1.1.1.1.8.1;
next	;

1.1.1.1.6.1
date	2004.03.17.07.31.28;	author morrison;	state dead;
branches;
next	;

1.1.1.1.8.1
date	2004.03.15.17.37.08;	author morrison;	state dead;
branches;
next	;


desc
@@


1.2
log
@*** empty log message ***
@
text
@# bgerror.tcl --
#
# This file contains a default version of the bgerror procedure.  It
# posts a dialog box with the error message and gives the user a chance
# to see a more detailed stack trace.
#
# RCS: @@(#) $Id: bgerror.tcl,v 1.1 2000/12/06 21:34:17 bparker Exp $
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.


# bgerror --
# This is the default version of bgerror. 
# It tries to execute tkerror, if that fails it posts a dialog box containing
# the error message and gives the user a chance to ask to see a stack
# trace.
# Arguments:
# err -			The error message.

proc bgerror err {
    global errorInfo tcl_platform
    
    # save errorInfo which would be erased in the catch below otherwise.
    set info $errorInfo ;

    # For backward compatibility :
    # Let's try to execute "tkerror" (using catch {tkerror ...} 
    # instead of searching it with info procs so the application gets
    # a chance to auto load it using its favorite "unknown" mecanism.
    # (we do the default dialog only if we get a TCL_ERROR (=1) return
    #  code from the tkerror trial, other ret codes are passed back
    #  to our caller (tcl background error handler) so the called "tkerror"
    #  can still use  return -code break, to skip remaining messages
    #  in the error queue for instance)

    set ret [catch {tkerror $err} msg];
    if {$ret != 1} {return -code $ret $msg}

    # Ok the application's tkerror either failed or was not found
    # we use the default dialog then :
    if {$tcl_platform(platform) == "macintosh"} {
	set ok Ok
    } else {
	set ok OK
    }
    set button [tk_dialog .bgerrorDialog "Error in Tcl Script" \
	    "Error: $err" error 0 $ok "Skip Messages" "Stack Trace"]
    if {$button == 0} {
	return
    } elseif {$button == 1} {
	return -code break
    }

    set w .bgerrorTrace
    catch {destroy $w}
    toplevel $w -class ErrorTrace
    wm minsize $w 1 1
    wm title $w "Stack Trace for Error"
    wm iconname $w "Stack Trace"
    button $w.ok -text OK -command "destroy $w" -default active
    if {![string compare $tcl_platform(platform) "macintosh"]} {
      text $w.text -relief flat -bd 2 -highlightthickness 0 -setgrid true \
	    -yscrollcommand "$w.scroll set" -width 60 -height 20
    } else {
      text $w.text -relief sunken -bd 2 -yscrollcommand "$w.scroll set" \
	    -setgrid true -width 60 -height 20
    }
    scrollbar $w.scroll -relief sunken -command "$w.text yview"
    pack $w.ok -side bottom -padx 3m -pady 2m
    pack $w.scroll -side right -fill y
    pack $w.text -side left -expand yes -fill both
    $w.text insert 0.0 $info
    $w.text mark set insert 0.0

    bind $w <Return> "destroy $w"
    bind $w.text <Return> "destroy $w; break"

    # Center the window on the screen.

    wm withdraw $w
    update idletasks
    set x [expr {[winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 \
	    - [winfo vrootx [winfo parent $w]]}]
    set y [expr {[winfo screenheight $w]/2 - [winfo reqheight $w]/2 \
	    - [winfo vrooty [winfo parent $w]]}]
    wm geom $w +$x+$y
    wm deiconify $w

    # Be sure to release any grabs that might be present on the
    # screen, since they could make it impossible for the user
    # to interact with the stack trace.

    if {[string compare [grab current .] ""]} {
	grab release [grab current .]
    }
}
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: bgerror.tcl,v 1.8 2000/04/18 02:18:33 ericm Exp $
@


1.1.1.1
log
@Import tk8.3
@
text
@@


1.1.1.1.6.1
log
@sync branch with HEAD
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: bgerror.tcl,v 1.1.1.1 2000/12/06 21:34:17 bparker Exp $
@


1.1.1.1.8.1
log
@sync with HEAD -- libtk8.3 is now libtk8.4
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: bgerror.tcl,v 1.1.1.1 2000/12/06 21:34:17 bparker Exp $
@

