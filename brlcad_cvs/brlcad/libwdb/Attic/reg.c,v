head	11.29;
access;
symbols
	ansi-20040405-merged:11.26.4.1
	postmerge-20040405-ansi:11.27
	premerge-20040404-ansi:11.27
	postmerge-autoconf:11.27
	autoconf-freeze:11.26.12.2
	premerge-autoconf:11.27
	postmerge-20040315-windows:11.27
	premerge-20040315-windows:11.27
	windows-20040315-freeze:11.26.6.1
	autoconf-20031203:11.26
	autoconf-20031202:11.26
	autoconf-branch:11.26.0.12
	phong-branch:11.26.0.10
	photonmap-branch:11.26.0.8
	rel-6-1-DP:11.26
	windows-branch:11.26.0.6
	rel-6-0-2:11.26
	ansi-branch:11.26.0.4
	rel-6-0-1-branch:11.26.0.2
	hartley-6-0-post:11.26
	hartley-6-0-pre:11.26
	rel-6-0-1:11.26
	rel-6-0:11.24
	rel-5-4:11.8
	offsite-5-3-pre:11.21
	rel-5-3:11.8
	rel-5-2:11.8
	rel-5-1-branch:11.8.0.2
	rel-5-1:11.8
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.4
	ctj-4-5-pre:11.4
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1;
locks; strict;
comment	@ * @;


11.29
date	2004.05.21.18.07.38;	author morrison;	state dead;
branches;
next	11.28;

11.28
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.27;

11.27
date	2004.02.02.17.39.30;	author morrison;	state Exp;
branches;
next	11.26;

11.26
date	2002.06.20.19.40.28;	author jra;	state Exp;
branches
	11.26.4.1
	11.26.6.1
	11.26.12.1;
next	11.25;

11.25
date	2002.05.17.12.41.07;	author morrison;	state Exp;
branches;
next	11.24;

11.24
date	2001.10.02.18.26.33;	author jra;	state Exp;
branches;
next	11.23;

11.23
date	2001.04.20.22.31.12;	author morrison;	state Exp;
branches;
next	11.22;

11.22
date	2001.03.31.01.57.16;	author morrison;	state Exp;
branches;
next	11.21;

11.21
date	2000.09.08.05.54.48;	author mike;	state Exp;
branches;
next	11.20;

11.20
date	2000.08.31.19.57.16;	author mike;	state Exp;
branches;
next	11.19;

11.19
date	2000.08.24.21.46.36;	author mike;	state Exp;
branches;
next	11.18;

11.18
date	2000.08.24.21.24.06;	author mike;	state Exp;
branches;
next	11.17;

11.17
date	2000.08.24.02.40.25;	author mike;	state Exp;
branches;
next	11.16;

11.16
date	2000.08.23.20.50.43;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.07.26.17.17.57;	author mike;	state Exp;
branches;
next	11.14;

11.14
date	2000.07.12.21.58.03;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	2000.07.12.03.17.06;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	2000.07.11.03.01.16;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	2000.07.11.02.36.50;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	2000.07.08.04.01.11;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	2000.07.08.01.41.21;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	2000.05.23.01.38.03;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	2000.03.17.16.09.10;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	2000.03.04.05.53.03;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.07.02.19.18.32;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.05.20.21.33.12;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	96.08.31.11.12.44;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	95.11.06.21.03.31;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.51.39;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.11.04.04.49.35;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.10.21.19.57.30;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.10.21.19.53.39;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.09.19.46.54;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.50;	author mike;	state Rel4_0;
branches;
next	9.11;

9.11
date	91.07.08.22.32.26;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.07.18.41.24;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.12.05.05.26.56;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.11.01.05.23.13;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.10.17.23.14.50;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	90.10.17.23.11.12;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.10.16.11.19.19;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.10.11.02.16.54;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	90.03.05.20.50.32;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.11.30.02.24.20;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.50.10;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.04.05.13.59.59;	author wm;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.28.59;	author mike;	state Rel3_0;
branches;
next	1.3;

1.3
date	88.08.20.06.50.14;	author phil;	state Exp;
branches;
next	1.2;

1.2
date	88.05.13.22.47.51;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.12.24.02.21.22;	author mike;	state Exp;
branches;
next	;

11.26.4.1
date	2004.03.17.21.21.48;	author morrison;	state Exp;
branches;
next	;

11.26.6.1
date	2004.03.11.23.45.48;	author morrison;	state Exp;
branches;
next	;

11.26.12.1
date	2004.02.12.19.41.24;	author erikg;	state Exp;
branches;
next	11.26.12.2;

11.26.12.2
date	2004.03.15.14.07.33;	author erikg;	state Exp;
branches;
next	;


desc
@Module in libwdb for handling the creation of combinations, regions,
and their members.
@


11.29
log
@moved to src/
@
text
@/*
 *			R E G
 *
 *  Library for writing MGED databases from arbitrary procedures.
 *
 *  This module contains routines to create combinations, and regions.
 *
 *  It is expected that this library will grow as experience is gained.
 *
 *  Authors -
 *	Michael John Muuss
 *	Paul R. Stay
 *	Bill Mermagen Jr.
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libwdb/reg.c,v 11.28 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include "machine.h"
#include "externs.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "wdb.h"

/*
 *			M K _ T R E E _ P U R E
 *
 *  Given a list of wmember structures, build a tree that performs
 *  the boolean operations in the given sequence.
 *  No GIFT semantics or precedence is provided.
 *  For that, use mk_tree_gift().
 */
void
mk_tree_pure( struct rt_comb_internal *comb, struct bu_list *member_hd )
{
	register struct wmember *wp;

	for( BU_LIST_FOR( wp, wmember, member_hd ) )  {
		union tree	*leafp, *nodep;

		WDB_CK_WMEMBER(wp);

		BU_GETUNION( leafp, tree );
		leafp->tr_l.magic = RT_TREE_MAGIC;
		leafp->tr_l.tl_op = OP_DB_LEAF;
		leafp->tr_l.tl_name = bu_strdup( wp->wm_name );
		if( !bn_mat_is_identity( wp->wm_mat ) )  {
			leafp->tr_l.tl_mat = bn_mat_dup( wp->wm_mat );
		}

		if( !comb->tree )  {
			comb->tree = leafp;
			continue;
		}
		/* Build a left-heavy tree */
		BU_GETUNION( nodep, tree );
		nodep->tr_b.magic = RT_TREE_MAGIC;
		switch( wp->wm_op )  {
		case WMOP_UNION:
			nodep->tr_b.tb_op = OP_UNION;
			break;
		case WMOP_INTERSECT:
			nodep->tr_b.tb_op = OP_INTERSECT;
			break;
		case WMOP_SUBTRACT:
			nodep->tr_b.tb_op = OP_SUBTRACT;
			break;
		default:
			bu_bomb("mk_tree_pure() bad wm_op");
		}
		nodep->tr_b.tb_left = comb->tree;
		nodep->tr_b.tb_right = leafp;
		comb->tree = nodep;
	}
}

/*
 *			M K _ T R E E _ G I F T
 *
 *  Add some nodes to a new or existing combination's tree,
 *  with GIFT precedence and semantics.
 *
 *  NON-PARALLEL due to rt_uniresource
 *
 *  Returns -
 *	-1	ERROR
 *	0	OK
 */
int
mk_tree_gift( struct rt_comb_internal *comb, struct bu_list *member_hd )
{
	struct wmember *wp;
	union tree *tp;
	struct rt_tree_array *tree_list;
	int node_count;
	int actual_count;
	int new_nodes;

	if( (new_nodes = bu_list_len( member_hd )) <= 0 )
		return 0;	/* OK, nothing to do */

	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
	{
		db_non_union_push( comb->tree, &rt_uniresource );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			bu_log("mk_tree_gift() Cannot flatten tree for editing\n");
			return -1;
		}
	}

	/* make space for an extra leaf */
	node_count = db_tree_nleaves( comb->tree ) ;
	tree_list = (struct rt_tree_array *)bu_calloc( node_count + new_nodes,
		sizeof( struct rt_tree_array ), "tree list" );

	/* flatten tree */
	if( comb->tree )  {
		/* Release storage for non-leaf nodes, steal leaves */
		actual_count = (struct rt_tree_array *)db_flatten_tree(
			tree_list, comb->tree, OP_UNION,
			1, &rt_uniresource ) - tree_list;
		BU_ASSERT_LONG( actual_count, ==, node_count );
		comb->tree = TREE_NULL;
	} else {
		actual_count = 0;
	}

	/* Add new members to the array */
	for( BU_LIST_FOR( wp, wmember, member_hd ) )  {
		WDB_CK_WMEMBER(wp);

		switch( wp->wm_op )  {
			case WMOP_INTERSECT:
				tree_list[node_count].tl_op = OP_INTERSECT;
				break;
			case WMOP_SUBTRACT:
				tree_list[node_count].tl_op = OP_SUBTRACT;
				break;
			default:
				bu_log("mk_tree_gift() unrecognized relation %c (assuming UNION)\n", wp->wm_op);
				/* Fall through */
			case WMOP_UNION:
				tree_list[node_count].tl_op = OP_UNION;
				break;
		}

		/* make new leaf node, and insert at end of array */
		BU_GETUNION( tp, tree );
		tree_list[node_count++].tl_tree = tp;
		tp->tr_l.magic = RT_TREE_MAGIC;
		tp->tr_l.tl_op = OP_DB_LEAF;
		tp->tr_l.tl_name = bu_strdup( wp->wm_name );
		if( !bn_mat_is_identity( wp->wm_mat ) )  {
			tp->tr_l.tl_mat = bn_mat_dup( wp->wm_mat );
		} else {
			tp->tr_l.tl_mat = (matp_t)NULL;
		}
	}
	BU_ASSERT_LONG( node_count, ==, actual_count + new_nodes );

	/* rebuild the tree with GIFT semantics */
	comb->tree = (union tree *)db_mkgift_tree( tree_list, node_count, &rt_uniresource );

	bu_free( (char *)tree_list, "mk_tree_gift: tree_list" );

	return 0;	/* OK */
}

/*
 *			M K _ A D D M E M B E R
 *
 *  Obtain dynamic storage for a new wmember structure, fill in the
 *  name, default the operation and matrix, and add to doubly linked
 *  list.  In typical use, a one-line call is sufficient.  To change
 *  the defaults, catch the pointer that is returned, and adjust the
 *  structure to taste.
 *
 *  The caller is responsible for initializing the header structures
 *  forward and backward links.
 */
struct wmember *
mk_addmember(
	const char	*name,
	struct bu_list	*headp,
	mat_t mat,
	int		op)
{
	register struct wmember *wp;

	BU_GETSTRUCT( wp, wmember );
	wp->l.magic = WMEMBER_MAGIC;
	wp->wm_name = bu_strdup( name );
	switch( op )  {
	case WMOP_UNION:
	case WMOP_INTERSECT:
	case WMOP_SUBTRACT:
		wp->wm_op = op;
		break;
	default:
		bu_log("mk_addmember() op=x%x is bad\n", op);
		return(WMEMBER_NULL);
	}

	/* if the user gave a matrix, use it.  otherwise use identity matrix*/
	if (mat) {
		MAT_COPY( wp->wm_mat, mat );
	} else {
		MAT_IDN( wp->wm_mat );
	}

	/* Append to end of doubly linked list */
	BU_LIST_INSERT( headp, &wp->l );
	return(wp);
}

/*
 *			M K _ F R E E M E M B E R S
 */
void
mk_freemembers( struct bu_list *headp )
{
	register struct wmember *wp;

	while( BU_LIST_WHILE( wp, wmember, headp ) )  {
		WDB_CK_WMEMBER(wp);
		BU_LIST_DEQUEUE( &wp->l );
		bu_free( (char *)wp->wm_name, "wm_name" );
		bu_free( (char *)wp, "wmember" );
	}
}

/*
 *			M K _ C O M B
 *
 *  Make a combination, where the
 *  members are described by a linked list of wmember structs.
 *
 *  The linked list is freed when it has been output.
 *
 *  Has many operating modes.
 *
 *  Returns -
 *	-1	ERROR
 *	0	OK
 */
int
mk_comb(
	struct rt_wdb		*wdbp,
	const char		*combname,
	struct bu_list		*headp,		/* Made by mk_addmember() */
	int			region_kind,	/* 1 => region.  'P' and 'V' for FASTGEN */
	const char		*shadername,	/* shader name, or NULL */
	const char		*shaderargs,	/* shader args, or NULL */
	const unsigned char	*rgb,		/* NULL => no color */
	int			id,		/* region_id */
	int			air,		/* aircode */
	int			material,	/* GIFTmater */
	int			los,
	int			inherit,
	int			append_ok,	/* 0 = obj must not exit */
	int			gift_semantics)	/* 0 = pure, 1 = gift */
{
	struct rt_db_internal	intern;
	struct rt_comb_internal *comb;
	int fresh_combination;

	RT_CK_WDB(wdbp);

	RT_INIT_DB_INTERNAL(&intern);

	if( append_ok &&
	    wdb_import( wdbp, &intern, combname, (matp_t)NULL ) >= 0 )  {
	    	/* We retrieved an existing object, append to it */
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB( comb );

	    	fresh_combination = 0;
	} else {
		/* Create a fresh new object for export */
		BU_GETSTRUCT( comb, rt_comb_internal );
		comb->magic = RT_COMB_MAGIC;
		bu_vls_init( &comb->shader );
		bu_vls_init( &comb->material );

		intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
		intern.idb_type = ID_COMBINATION;
		intern.idb_ptr = (genptr_t)comb;
		intern.idb_meth = &rt_functab[ID_COMBINATION];

		fresh_combination = 1;
	}

	if( gift_semantics )
		mk_tree_gift( comb, headp );
	else
		mk_tree_pure( comb, headp );

	/* Release the wmember list dynamic storage */
	mk_freemembers( headp );

	/* Don't change these things when appending to existing combination */
	if( fresh_combination )  {
		if( region_kind )  {
			comb->region_flag = 1;
			switch( region_kind )  {
			case 'P':
				comb->is_fastgen = REGION_FASTGEN_PLATE;
				break;
			case 'V':
				comb->is_fastgen = REGION_FASTGEN_VOLUME;
				break;
			case 'R':
			case 1:
				/* Regular non-FASTGEN Region */
				break;
			default:
				bu_log("mk_comb(%s) unknown region_kind=%d (%c), assuming normal non-FASTGEN\n",
					combname, region_kind, region_kind);
			}
		}
		if( shadername )  bu_vls_strcat( &comb->shader, shadername );
		if( shaderargs )  {
			bu_vls_strcat( &comb->shader, " " );
			bu_vls_strcat( &comb->shader, shaderargs );
			/* Convert to Tcl form if necessary.  Use heuristics */
			if( strchr( shaderargs, '=' ) != NULL &&
			    strchr( shaderargs, '{' ) == NULL )
			{
				struct bu_vls old;
				bu_vls_init(&old);
				bu_vls_vlscatzap(&old, &comb->shader);
				if( bu_shader_to_tcl_list( bu_vls_addr(&old), &comb->shader) )
					bu_log("Unable to convert shader string '%s %s'\n", shadername, shaderargs);
				bu_vls_free(&old);
			}
		}

		if( rgb )  {
			comb->rgb_valid = 1;
			comb->rgb[0] = rgb[0];
			comb->rgb[1] = rgb[1];
			comb->rgb[2] = rgb[2];
		}

		comb->region_id = id;
		comb->aircode = air;
		comb->GIFTmater = material;
		comb->los = los;

		comb->inherit = inherit;
	}

	/* The internal representation will be freed */
	return wdb_put_internal( wdbp, combname, &intern, mk_conv2mm );
}

/*
 *			M K _ C O M B 1
 *
 *  Convenience interface to make a combination with a single member.
 */
int
mk_comb1( struct rt_wdb *wdbp,
	const char *combname,
	const char *membname,
	int regflag )
{
	struct bu_list	head;

	BU_LIST_INIT( &head );
	if( mk_addmember( membname, &head, NULL, WMOP_UNION ) == WMEMBER_NULL )
		return -2;
	return mk_comb( wdbp, combname, &head, regflag,
		(char *)NULL, (char *)NULL, (unsigned char *)NULL,
		0, 0, 0, 0,
		0, 0, 0 );
}

/*
 *			M K _ R E G I O N 1
 *
 *  Convenience routine to make a region with shader and rgb possibly set.
 */
int
mk_region1(
	struct rt_wdb *wdbp,
	const char *combname,
	const char *membname,
	const char *shadername,
	const char *shaderargs,
	const unsigned char *rgb )
{
	struct bu_list	head;

	BU_LIST_INIT( &head );
	if( mk_addmember( membname, &head, NULL, WMOP_UNION ) == WMEMBER_NULL )
		return -2;
	return mk_comb( wdbp, combname, &head, 1, shadername, shaderargs,
		rgb, 0, 0, 0, 0, 0, 0, 0 );
}
@


11.28
log
@change conf.h to a wrapped config.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libwdb/reg.c,v 11.27 2004/02/02 17:39:30 morrison Exp $ (BRL)";
@


11.27
log
@update copyright to include span through 2003
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.26 2002/06/20 19:40:28 jra Exp $ (BRL)";
d28 5
a32 1
#include "conf.h"
@


11.26
log
@mk_addmember() now uses bu_strdup() to copy member name (instead of strncpy)
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1987 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.25 2002/05/17 12:41:07 morrison Exp $ (BRL)";
@


11.26.4.1
log
@sync branch with HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.26.6.1
log
@sync to HEAD...
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libwdb/reg.c,v 11.27 2004/02/02 17:39:30 morrison Exp $ (BRL)";
@


11.26.12.1
log
@merge from HEAD
@
text
@d21 1
a21 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.27 2004/02/02 17:39:30 morrison Exp $ (BRL)";
@


11.26.12.2
log
@merge from head
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.26.12.1 2004/02/12 19:41:24 erikg Exp $ (BRL)";
@


11.25
log
@added matrix parameter to mk_addmember()
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.24 2001/10/02 18:26:33 jra Exp $ (BRL)";
d213 1
a213 1
	strncpy( wp->wm_name, name, sizeof(wp->wm_name) );
d248 1
@


11.24
log
@mk_comb() was not setting idb_major_type in internal struct
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.23 2001/04/20 22:31:12 morrison Exp $ (BRL)";
d206 1
d224 7
a230 1
	MAT_IDN( wp->wm_mat );
d391 1
a391 1
	if( mk_addmember( membname, &head, WMOP_UNION ) == WMEMBER_NULL )
d416 1
a416 1
	if( mk_addmember( membname, &head, WMOP_UNION ) == WMEMBER_NULL )
@


11.23
log
@CONST to const
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.22 2001/03/31 01:57:16 morrison Exp $ (BRL)";
d298 1
@


11.22
log
@Deprecated bn_mat_idn() and bn_mat_zero(), updated calls to h/vmath.h's MAT_IDN() and MAT_ZERO() performance improved macros.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.21 2000/09/08 05:54:48 mike Exp $ (BRL)";
d376 2
a377 2
	CONST char *combname,
	CONST char *membname,
@


11.21
log
@
Modified tree routines to take resource pointer.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.20 2000/08/31 19:57:16 mike Exp $ (BRL)";
d223 1
a223 1
	bn_mat_idn( wp->wm_mat );
@


11.20
log
@
Adding 0 members to a combination is easy, don't dump core. :-)
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.19 2000/08/24 21:46:36 mike Exp $ (BRL)";
d103 2
d124 1
a124 1
		db_non_union_push( comb->tree );
d141 2
a142 1
			tree_list, comb->tree, OP_UNION, 1 ) - tree_list;
d183 1
a183 1
	comb->tree = (union tree *)db_mkgift_tree( tree_list, node_count, (struct db_tree_state *)NULL );
@


11.19
log
@
lint
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.18 2000/08/24 21:24:06 mike Exp $ (BRL)";
d117 3
a128 2

	new_nodes = bu_list_len( member_hd );
@


11.18
log
@
Accept 'R' as flag for Regular Region too.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.17 2000/08/24 02:40:25 mike Exp $ (BRL)";
d141 2
@


11.17
log
@
New LIBWDB routine mk_comb(), which encompasses all ways of
making a combination, including appending to an existing one,
with GIFT or pure semantics, and support for FASTGEN.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.16 2000/08/23 20:50:43 mike Exp $ (BRL)";
d318 1
d320 1
@


11.16
log
@
bu_free
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.15 2000/07/26 17:17:57 mike Exp $ (BRL)";
d46 1
a46 1
 *			M K _ C O M B _ I N T E R N A L
d48 4
a51 5
 *  A helper routine to create an rt_comb_internal version of the
 *  combination given a linked list of wmember structures.
 *
 *  Note that this doesn't provide GIFT-like semantics to the op list.
 *  Should it?
d53 2
a54 2
struct rt_comb_internal *
mk_comb_internal( struct wmember *headp )
a55 1
	struct rt_comb_internal	*comb;
a56 1
	union tree	*leafp, *nodep;
d58 5
a62 9
	BU_GETSTRUCT( comb, rt_comb_internal );
	comb->magic = RT_COMB_MAGIC;
	bu_vls_init( &comb->shader );
	bu_vls_init( &comb->material );

	for( BU_LIST_FOR( wp, wmember, &headp->l ) )  {
		if( wp->l.magic != WMEMBER_MAGIC )  {
			bu_bomb("mk_comb_internal:  corrupted linked list\n");
		}
d89 1
a89 1
			bu_bomb("mk_comb_internal() bad wm_op");
d95 87
a181 1
	return comb;
d197 4
a200 4
mk_addmember( name, headp, op )
CONST char	*name;
register struct wmember *headp;
int	op;
d214 1
a214 1
		fprintf(stderr, "mk_addmember() op=x%x is bad\n", op);
d220 1
a220 1
	BU_LIST_INSERT( &headp->l, &wp->l );
a225 4
 *
 *  Returns -
 *	 0	All OK
 *	<0	List was corrupted
d227 2
a228 3
int
mk_freemembers( headp )
register struct wmember *headp;
a230 1
	register int	ret = 0;
d232 2
a233 3
	while( BU_LIST_WHILE( wp, wmember, &headp->l ) )  {
		if( wp->l.magic != WMEMBER_MAGIC )
			ret--;
a234 1
		wp->l.magic = -1;	/* Sanity */
a236 1
	return(ret);
d240 1
a240 1
 *			M K _ L R C O M B
d242 1
a242 1
 *  Make a combination, much like mk_comb(), but where the
d244 1
a244 3
 *  This routine produces the combination and member records
 *  all at once, making it easier and less risky to use than
 *  direct use of the pair of mk_comb() and mk_memb().
a245 1
 *  Like mk_lcomb except for additional region parameters.
d247 5
d254 15
a268 13
mk_lrcomb( fp, name, headp, region, matname, matparm, rgb, id, air, material, los, inherit )
struct rt_wdb		*fp;
CONST char	*name;
register struct wmember *headp;
int		region;
CONST char	*matname;
CONST char	*matparm;
CONST unsigned char	*rgb;
int	id;
int	air;
int	material;
int	los;
int	inherit;
d270 1
d272 3
d276 21
a296 17
	comb = mk_comb_internal( headp );
	if( region )  comb->region_flag = 1;
	if( matname )  bu_vls_strcat( &comb->shader, matname );
	if( matparm )  {
		bu_vls_strcat( &comb->shader, " " );
		bu_vls_strcat( &comb->shader, matparm );
		/* Convert to Tcl form if necessary.  Use heuristics */
		if( strchr( matparm, '=' ) != NULL &&
		    strchr( matparm, '{' ) == NULL )
		{
			struct bu_vls old;
			bu_vls_init(&old);
			bu_vls_vlscatzap(&old, &comb->shader);
			if( bu_shader_to_tcl_list( bu_vls_addr(&old), &comb->shader) )
				bu_log("Unable to convert shader string '%s %s'\n", matname, matparm);
			bu_vls_free(&old);
		}
d299 42
a340 6
	if( rgb )  {
		comb->rgb_valid = 1;
		comb->rgb[0] = rgb[0];
		comb->rgb[1] = rgb[1];
		comb->rgb[2] = rgb[2];
	}
d342 6
a347 4
	comb->region_id = id;
	comb->aircode = air;
	comb->GIFTmater = material;
	comb->los = los;
d349 4
a352 1
	comb->inherit = inherit;
d354 2
a355 2
	/* Release the member structure dynamic storage */
	mk_freemembers( headp );
d357 2
a358 1
	return mk_export_fwrite( fp, name, comb, ID_COMBINATION );
d367 1
a367 1
mk_comb1( struct rt_wdb *fp,
d372 1
a372 1
	struct wmember	head;
d374 1
a374 1
	BU_LIST_INIT( &head.l );
d377 4
a380 2
	return mk_lcomb( fp, combname, &head, regflag,
		(char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
d390 1
a390 1
	struct rt_wdb *fp,
d393 2
a394 2
	const char *matname,
	const char *matparm,
d397 1
a397 1
	struct wmember	head;
d399 1
a399 1
	BU_LIST_INIT( &head.l );
d402 2
a403 73
	return mk_lcomb( fp, combname, &head, 1, matname, matparm, rgb, 0 );
}

/*
 *		M K _ F A S T G E N _ R E G I O N
 *
 *	Code to create a region with the FASTGEN Plate-mode or FASTGEN Volume-mode
 *	flags set
 */
int
mk_fastgen_region(
	struct rt_wdb *fp,
	const char *name,
	struct wmember *headp,
	char mode,
	const char *matname,
	const char *matparm,
	const unsigned char *rgb,
	int id,
	int air,
	int material,
	int los,
	int inherit )
{
	struct rt_comb_internal *comb;

	comb = mk_comb_internal( headp );
	comb->region_flag = 1;
	switch( mode )  {
	case 'P':
		comb->is_fastgen = REGION_FASTGEN_PLATE;
		break;
	case 'V':
		comb->is_fastgen = REGION_FASTGEN_VOLUME;
		break;
	default:
		fprintf( stderr, "ERROR: mk_fastgen_region: Unrecognized mode flag (%c)\n", mode );
		abort();
	}
	if( matname )  bu_vls_strcat( &comb->shader, matname );
	if( matparm )  {
		bu_vls_strcat( &comb->shader, " " );
		bu_vls_strcat( &comb->shader, matparm );
		/* Convert to Tcl form if necessary.  Use heuristics */
		if( strchr( matparm, '=' ) != NULL &&
		    strchr( matparm, '{' ) == NULL )
		{
			struct bu_vls old;
			bu_vls_init(&old);
			bu_vls_vlscatzap(&old, &comb->shader);
			if( bu_shader_to_tcl_list( bu_vls_addr(&old), &comb->shader) )
				bu_log("Unable to convert shader string '%s %s'\n", matname, matparm);
			bu_vls_free(&old);
		}
	}
	if( rgb )  {
		comb->rgb_valid = 1;
		comb->rgb[0] = rgb[0];
		comb->rgb[1] = rgb[1];
		comb->rgb[2] = rgb[2];
	}

	comb->region_id = id;
	comb->aircode = air;
	comb->GIFTmater = material;
	comb->los = los;

	comb->inherit = inherit;

	/* Release the member structure dynamic storage */
	mk_freemembers( headp );

	return mk_export_fwrite( fp, name, comb, ID_COMBINATION );
a404 1

@


11.15
log
@
Improvements in v4->v5 converstion.  Auto conversion of shader strings.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.14 2000/07/12 21:58:03 mike Exp $ (BRL)";
d164 1
a164 1
		free( (char *)wp );
@


11.14
log
@
New version of LIBWDB which takes a (struct rt_wdb *) rather than a
(FILE *) as the first parameter.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.13 2000/07/12 03:17:06 mike Exp $ (BRL)";
a145 47
 *			M K _ L C O M B
 *
 *  Make a combination, much like mk_comb(), but where the
 *  members are described by a linked list of wmember structs.
 *  This routine produces the combination and member records
 *  all at once, making it easier and less risky to use than
 *  direct use of the pair of mk_comb() and mk_memb().
 *  The linked list is freed when it has been output.
 *
 *  A shorthand version is given in wdb.h as a macro.
 */
int
mk_lcomb( fp, name, headp, region, matname, matparm, rgb, inherit )
struct rt_wdb		*fp;
CONST char	*name;
register struct wmember *headp;
int		region;
CONST char	*matname;
CONST char	*matparm;
CONST unsigned char	*rgb;
int		inherit;
{
	struct rt_comb_internal *comb;

	comb = mk_comb_internal( headp );
	if( region )  comb->region_flag = 1;
	if( matname )  bu_vls_strcat( &comb->shader, matname );
	if( matparm )  {
		bu_vls_strcat( &comb->shader, " " );
		bu_vls_strcat( &comb->shader, matparm );
	}
	/* XXX Convert to TCL form? */
	if( rgb )  {
		comb->rgb_valid = 1;
		comb->rgb[0] = rgb[0];
		comb->rgb[1] = rgb[1];
		comb->rgb[2] = rgb[2];
	}
	comb->inherit = inherit;

	/* Release the member structure dynamic storage */
	mk_freemembers( headp );

	return mk_export_fwrite( fp, name, comb, ID_COMBINATION );
}

/*
d204 11
d216 1
a216 1
	/* XXX Convert to TCL form? */
d319 11
a330 1
	/* XXX Convert to TCL form? */
@


11.13
log
@
Added mk_region1()
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.12 2000/07/11 03:01:16 mike Exp $ (BRL)";
d159 1
a159 1
FILE		*fp;
d230 1
a230 1
FILE		*fp;
d279 1
a279 1
mk_comb1( FILE *fp,
d300 1
a300 1
	FILE *fp,
d322 13
a334 13
mk_fastgen_region( fp, name, headp, mode, matname, matparm, rgb, id, air, material, los, inherit )
FILE		*fp;
CONST char	*name;
register struct wmember *headp;
char		mode;
CONST char	*matname;
CONST char	*matparm;
CONST unsigned char	*rgb;
int	id;
int	air;
int	material;
int	los;
int	inherit;
@


11.12
log
@
Eliminated use of v4 "db.h" file.
Moved old v4-only routines out into reg4.c
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.11 2000/07/11 02:36:50 mike Exp $ (BRL)";
d279 4
a282 5
mk_comb1( fp, combname, membname, regflag )
FILE	*fp;
CONST char	*combname;
CONST char	*membname;
int	regflag;
d290 23
a312 1
		(char *)NULL, (char *)NULL, (unsigned char *)NULL, 1 );
@


11.11
log
@
Upgraded to new way of doing business.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.10 2000/07/08 04:01:11 mike Exp $ (BRL)";
a39 1
#include "db.h"
a104 204
/* so we don't have to include mat.o */
static fastf_t ident_mat[16] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
};

/* -------------------- Begin old code, compat only -------------------- */

/*
 *			M K _ C O M B
 *
 *  Make a combination with material properties info.
 *  Must be followed by 'len' mk_memb() calls before any other mk_* routines.
 *
 *  XXX WARNING:  This routine should not be called by new code.
 *  XXX use mk_lcomb() instead.
 */
int
mk_comb( fp, name, len, region, matname, matparm, rgb, inherit )
FILE			*fp;
CONST char		*name;
int			len;
int			region;
CONST char		*matname;
CONST char		*matparm;
CONST unsigned char	*rgb;
int			inherit;
{
	union record rec;

	BU_ASSERT_LONG( mk_version, <=, 4 );

	bzero( (char *)&rec, sizeof(rec) );
	rec.c.c_id = ID_COMB;
	/* XXX What values to pass for FASTGEN plate and volume regions? */
	if( region )
		rec.c.c_flags = DBV4_REGION;
	else
		rec.c.c_flags = DBV4_NON_REGION;
	NAMEMOVE( name, rec.c.c_name );
	rec.c.c_pad1 = len;		/* backwards compat, was c_length */
	if( matname ) {
		strncpy( rec.c.c_matname, matname, sizeof(rec.c.c_matname) );
		if( matparm )
			strncpy( rec.c.c_matparm, matparm,
				sizeof(rec.c.c_matparm) );
	}
	if( rgb )  {
		rec.c.c_override = 1;
		rec.c.c_rgb[0] = rgb[0];
		rec.c.c_rgb[1] = rgb[1];
		rec.c.c_rgb[2] = rgb[2];
	}
	rec.c.c_inherit = inherit;
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);
	return(0);
}

/*
 *			M K _ R C O M B
 *
 *  Make a combination with material properties info.
 *  Must be followed by 'len' mk_memb() calls before any other mk_* routines.
 *  Like mk_comb except for additional region parameters.
 *
 *  XXX WARNING:  This routine should not be called by new code.
 *  XXX use mk_addmember() instead.
 */
int
mk_rcomb( fp, name, len, region, matname, matparm, rgb, id, air, material, los, inherit )
FILE		*fp;
CONST char	*name;
int		len;
int		region;
CONST char	*matname;
CONST char	*matparm;
CONST unsigned char	*rgb;
int		id;
int		air;
int		material;
int		los;
int		inherit;
{
	union record rec;

	BU_ASSERT_LONG( mk_version, <=, 4 );

	bzero( (char *)&rec, sizeof(rec) );
	rec.c.c_id = ID_COMB;
	if( region ){
		switch( region )  {
		case DBV4_NON_REGION:	/* sanity, fixes a non-bool arg */
		case DBV4_REGION:
		case DBV4_REGION_FASTGEN_PLATE:
		case DBV4_REGION_FASTGEN_VOLUME:
			rec.c.c_flags = region;
			break;
		default:
			rec.c.c_flags = DBV4_REGION;
		}
		rec.c.c_inherit = inherit;
		rec.c.c_regionid = id;
		rec.c.c_aircode = air;
		rec.c.c_material = material;
		rec.c.c_los = los;
	}
	else
		rec.c.c_flags = DBV4_NON_REGION;
	NAMEMOVE( name, rec.c.c_name );
	rec.c.c_pad1 = len;		/* backwards compat, was c_length */
	if( matname ) {
		strncpy( rec.c.c_matname, matname, sizeof(rec.c.c_matname) );
		if( matparm )
			strncpy( rec.c.c_matparm, matparm,
				sizeof(rec.c.c_matparm) );
	}
	if( rgb )  {
		rec.c.c_override = 1;
		rec.c.c_rgb[0] = rgb[0];
		rec.c.c_rgb[1] = rgb[1];
		rec.c.c_rgb[2] = rgb[2];
	}

	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);
	return(0);
}


/*
 *			M K _ F C O M B
 *
 *  Make a simple combination header ("fast" version).
 *  Must be followed by 'len' mk_memb() calls before any other mk_* routines.
 *
 *  XXX WARNING:  This routine should not be called by new code.
 */
int
mk_fcomb( fp, name, len, region )
FILE		*fp;
CONST char	*name;
int		len;
int		region;
{
	union record rec;

	BU_ASSERT_LONG( mk_version, <=, 4 );

	bzero( (char *)&rec, sizeof(rec) );
	rec.c.c_id = ID_COMB;
	if( region )
		rec.c.c_flags = DBV4_REGION;
	else
		rec.c.c_flags = DBV4_NON_REGION;
	NAMEMOVE( name, rec.c.c_name );
	rec.c.c_pad1 = len;		/* backwards compat, was c_length */
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);
	return(0);
}

/*
 *			M K _ M E M B
 *
 *  Must be part of combination/member clump of records.
 *
 *  XXX WARNING:  This routine should not be called by new code.
 */
int
mk_memb( fp, name, mat, bool_op )
FILE		*fp;
CONST char	*name;
CONST mat_t	mat;
int		bool_op;
{
	union record rec;
	register int i;

	BU_ASSERT_LONG( mk_version, <=, 4 );

	bzero( (char *)&rec, sizeof(rec) );
	rec.M.m_id = ID_MEMB;
	NAMEMOVE( name, rec.M.m_instname );
	if( bool_op )
		rec.M.m_relation = bool_op;
	else
		rec.M.m_relation = UNION;
	if( mat ) {
		for( i=0; i<16; i++ )
			rec.M.m_mat[i] = mat[i];  /* double -> float */
	} else {
		for( i=0; i<16; i++ )
			rec.M.m_mat[i] = ident_mat[i];
	}
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);
	return(0);
}

/* -------------------- End old code, compat only -------------------- */

a129 2
		wp->wm_op = UNION;
		break;
a130 2
		wp->wm_op = INTERSECT;
		break;
d132 1
a132 1
		wp->wm_op = SUBTRACT;
d138 2
a139 1
	bcopy( ident_mat, wp->wm_mat, sizeof(mat_t) );
d189 1
a189 1
	return mk_export_fwrite( fp, name, comb, ID_COMB );
d270 1
a270 1
	return mk_export_fwrite( fp, name, comb, ID_COMB );
d353 1
a353 1
	return mk_export_fwrite( fp, name, comb, ID_COMB );
@


11.10
log
@
Modified to allow mk_fwrite_internal() to free the objects.
Added flag variable mk_version to indicate what database version to be written.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.9 2000/07/08 01:41:21 mike Exp $ (BRL)";
d451 1
a451 2
	register struct wmember *wp;
	register int len = 0;
d453 13
a465 7
	/* Measure length of list */
	for( BU_LIST_FOR( wp, wmember, &headp->l ) )  {
		if( wp->l.magic != WMEMBER_MAGIC )  {
			fprintf(stderr, "mk_wmcomb:  corrupted linked list\n");
			abort();
		}
		len++;
d468 4
a471 1
	/* Output combination record and member records */
d473 1
a473 10
	if( mk_rcomb( fp, name, len, region, matname, matparm, rgb, id, air, material, los, inherit ) < 0 )  {
		(void)mk_freemembers( headp );
		return(-1);
	}
	for( BU_LIST_FOR( wp, wmember, &headp->l ) )  {
		if( mk_memb( fp, wp->wm_name, wp->wm_mat, wp->wm_op ) < 0 )  {
			(void)mk_freemembers( headp );
			return(-1);
		}
	}
d476 3
a478 1
	return( mk_freemembers( headp ) );
d523 1
a523 3
	register struct wmember *wp;
	register int len = 0;
	union record rec;
d525 10
a534 17
	/* Measure length of list */
	for( BU_LIST_FOR( wp, wmember, &headp->l ) )  {
		if( wp->l.magic != WMEMBER_MAGIC )  {
			fprintf(stderr, "mk_fastgen_region:  corrupted linked list\n");
			abort();
		}
		len++;
	}

	bzero( (char *)&rec, sizeof(rec) );
	rec.c.c_id = ID_COMB;
	if( mode == 'P' )
		rec.c.c_flags = DBV4_REGION_FASTGEN_PLATE;
	else if( mode == 'V' )
		rec.c.c_flags = DBV4_REGION_FASTGEN_VOLUME;
	else
	{
d538 4
a541 12
	rec.c.c_inherit = inherit;
	rec.c.c_regionid = id;
	rec.c.c_aircode = air;
	rec.c.c_material = material;
	rec.c.c_los = los;
	NAMEMOVE( name, rec.c.c_name );
	rec.c.c_pad1 = len;		/* backwards compat, was c_length */
	if( matname ) {
		strncpy( rec.c.c_matname, matname, sizeof(rec.c.c_matname) );
		if( matparm )
			strncpy( rec.c.c_matparm, matparm,
				sizeof(rec.c.c_matparm) );
d543 1
d545 4
a548 4
		rec.c.c_override = 1;
		rec.c.c_rgb[0] = rgb[0];
		rec.c.c_rgb[1] = rgb[1];
		rec.c.c_rgb[2] = rgb[2];
d551 6
a556 9
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);
	
	for( BU_LIST_FOR( wp, wmember, &headp->l ) )  {
		if( mk_memb( fp, wp->wm_name, wp->wm_mat, wp->wm_op ) < 0 )  {
			(void)mk_freemembers( headp );
			return(-1);
		}
	}
d559 3
a561 1
	return( mk_freemembers( headp ) );
@


11.9
log
@
const RCSid
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.8 2000/05/23 01:38:03 mike Exp $ (BRL)";
d32 5
d43 1
d46 60
d138 2
d194 2
d255 2
d287 2
d330 1
a330 4
	if( (wp = (struct wmember *)malloc(sizeof(struct wmember))) == WMEMBER_NULL )  {
		fprintf(stderr,"mk_addmember:  malloc failure\n");
		return(WMEMBER_NULL);
	}
d376 1
a376 2
	register struct wmember *wp;
	register int len = 0;
d378 6
a383 7
	/* Measure length of list */
	for( BU_LIST_FOR( wp, wmember, &headp->l ) )  {
		if( wp->l.magic != WMEMBER_MAGIC )  {
			fprintf(stderr, "mk_wmcomb:  corrupted linked list\n");
			abort();
		}
		len++;
d385 6
a390 11

	/* Output combination record and member records */
	if( mk_comb( fp, name, len, region, matname, matparm, rgb, inherit ) < 0 )  {
		(void)mk_freemembers( headp );
		return(-1);
	}
	for( BU_LIST_FOR( wp, wmember, &headp->l ) )  {
		if( mk_memb( fp, wp->wm_name, wp->wm_mat, wp->wm_op ) < 0 )  {
			(void)mk_freemembers( headp );
			return(-1);
		}
d392 1
d395 3
a397 1
	return( mk_freemembers( headp ) );
@


11.8
log
@
extended the meaning of the 'region' argument to mk_rcomb(), and
thus mk_lrcomb(), to not only be a boolean, but to also recognize
the FASTGEN plate and volume flags.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.7 2000/03/17 16:09:10 jra Exp $ (BRL)";
@


11.7
log
@Added mk_fastgen_region()
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.6 2000/03/04 05:53:03 mike Exp $ (BRL)";
d129 10
a138 1
		rec.c.c_flags = DBV4_REGION;
@


11.6
log
@
Started upgrade for FASTGEN compat.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.5 1999/07/02 19:18:32 mike Exp $ (BRL)";
d424 80
@


11.5
log
@
Eliminated dependency on compat4.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/reg.c,v 11.4 1997/05/20 21:33:12 mike Exp $ (BRL)";
d74 1
d76 1
a76 1
		rec.c.c_flags = 'R';
d78 1
a78 1
		rec.c.c_flags = ' ';
d129 1
a129 1
		rec.c.c_flags = 'R';
d137 1
a137 1
		rec.c.c_flags = ' ';
d179 1
a179 1
		rec.c.c_flags = 'R';
d181 1
a181 1
		rec.c.c_flags = ' ';
@


11.4
log
@externs.h needs to be included before bu.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 11.3 1996/08/31 11:12:44 mike Exp mike $ (BRL)";
d268 1
a268 1
	RT_LIST_INSERT( &headp->l, &wp->l );
d299 1
a299 1
	for( RT_LIST_FOR( wp, wmember, &headp->l ) )  {
d312 1
a312 1
	for( RT_LIST_FOR( wp, wmember, &headp->l ) )  {
d337 1
a337 1
	while( RT_LIST_WHILE( wp, wmember, &headp->l ) )  {
d340 1
a340 1
		RT_LIST_DEQUEUE( &wp->l );
d378 1
a378 1
	for( RT_LIST_FOR( wp, wmember, &headp->l ) )  {
d392 1
a392 1
	for( RT_LIST_FOR( wp, wmember, &headp->l ) )  {
d417 1
a417 1
	RT_LIST_INIT( &head.l );
@


11.3
log
@bu.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 11.2 1995/11/06 21:03:31 pjt Exp mike $ (BRL)";
d33 1
a34 1
#include "externs.h"
@


11.2
log
@Fixed header comment for mk_lrcomb (NOT mk_rlcomb!)
.,
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 11.1 95/01/04 09:51:39 mike Rel4_4 $ (BRL)";
d33 1
d37 1
a37 1
#include "rtlist.h"
@


11.1
log
@Release_4.4
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 10.5 94/11/04 04:49:35 mike Exp $ (BRL)";
d347 1
a347 1
 *			M K _ R L C O M B
@


10.5
log
@Missing header
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 10.4 94/10/21 19:57:30 mike Exp Locker: mike $ (BRL)";
@


10.4
log
@match prototype
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 10.3 94/10/21 19:53:39 mike Exp Locker: mike $ (BRL)";
d33 1
@


10.3
log
@Better arg definitions
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 10.2 94/08/09 19:46:54 gdurf Exp Locker: mike $ (BRL)";
d114 1
a114 1
CONST char	*rgb;
@


10.2
log
@Factored ifdefs
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 10.1 1991/10/12 06:36:50 mike Rel4_0 gdurf $ (BRL)";
d59 8
a66 8
FILE	*fp;
char	*name;
int	len;
int	region;
char	*matname;
char	*matparm;
char	*rgb;
int	inherit;
d108 12
a119 12
FILE	*fp;
char	*name;
int	len;
int	region;
char	*matname;
char	*matparm;
char	*rgb;
int	id;
int	air;
int	material;
int	los;
int	inherit;
d166 4
a169 4
FILE	*fp;
char	*name;
int	len;
int	region;
d195 4
a198 4
FILE	*fp;
char	*name;
mat_t	mat;
int	bool_op;
d238 1
a238 1
char	*name;
d284 2
a285 2
FILE	*fp;
char	*name;
d287 5
a291 5
int	region;
char	*matname;
char	*matparm;
char	*rgb;
int	inherit;
d359 2
a360 2
FILE	*fp;
char	*name;
d362 4
a365 4
int	region;
char	*matname;
char	*matparm;
char	*rgb;
d409 2
a410 2
char	*combname;
char	*membname;
d419 1
a419 1
		(char *)NULL, (char *)NULL, (char *)NULL, 1 );
@


10.1
log
@Release_4.0
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 9.11 91/07/08 22:32:26 mike Exp $ (BRL)";
d28 2
a36 5

#if defined(SYSV) && !defined(bzero)
#define bzero(str,n)		memset( str, '\0', n )
#define bcopy(from,to,count)	memcpy( to, from, count )
#endif
@


9.11
log
@Added mk_comb1() as a convenience routine
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 9.10 90/12/07 18:41:24 mike Exp $ (BRL)";
@


9.10
log
@rec.c.c_length is no longer required by any database reader.
However, for backwards compatability, this field
(now called c_pad1) is still set to the combination length.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 9.10 90/12/07 02:52:23 mike Exp $ (BRL)";
d402 21
@


9.9
log
@Changed static's to automatics.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 9.8 90/11/01 05:23:13 mike Exp $ (BRL)";
d36 1
a36 1
#ifdef SYSV
d49 2
d56 3
d80 1
a80 1
	rec.c.c_length = len;
d105 3
d139 1
a139 1
	rec.c.c_length = len;
d164 2
d183 1
a183 1
	rec.c.c_length = len;
d193 2
d224 2
@


9.8
log
@Added "op" arg to mk_addmember().
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 9.7 90/10/17 23:14:50 mike Exp $ (BRL)";
d66 1
a66 1
	static union record rec;
d116 1
a116 1
	static union record rec;
d164 1
a164 1
	static union record rec;
d191 1
a191 1
	static union record rec;
@


9.7
log
@Changed to use new list loop macro names
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 9.6 90/10/17 23:11:12 mike Exp $ (BRL)";
d226 1
a226 1
mk_addmember( name, headp )
d229 1
d234 1
a234 1
		fprintf(stderr,"mk_wmember:  malloc failure\n");
d239 14
a252 1
	wp->wm_op = UNION;
@


9.6
log
@Fixed to use right macros
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 9.5 90/10/16 11:19:19 mike Exp $ (BRL)";
d272 1
a272 1
	for( RT_LIST( wp, wmember, &headp->l ) )  {
d285 1
a285 1
	for( RT_LIST( wp, wmember, &headp->l ) )  {
d310 1
a310 1
	while( RT_LIST_LOOP( wp, wmember, &headp->l ) )  {
d351 1
a351 1
	for( RT_LIST( wp, wmember, &headp->l ) )  {
d365 1
a365 1
	for( RT_LIST( wp, wmember, &headp->l ) )  {
@


9.5
log
@Changed to using rtlist.h
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/reg.c,v 9.4 90/10/11 02:16:54 mike Exp $ (BRL)";
d351 1
a351 1
	while( RT_LIST_LOOP( wp, wmember, &headp->l ) )  {
d365 1
a365 1
	while( RT_LIST_LOOP( wp, wmember, &headp->l ) )  {
@


9.4
log
@Minor ANSI C nit.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: reg.c,v 9.3 90/03/05 20:50:32 mike Exp $ (BRL)";
d33 1
d236 1
a236 1
	wp->wm_magic = WMEMBER_MAGIC;
d241 1
a241 4
	wp->wm_forw = headp;
	wp->wm_back = headp->wm_back;
	headp->wm_back->wm_forw = wp;
	headp->wm_back = wp;
d272 2
a273 2
	for( wp = headp->wm_forw; wp != headp; wp = wp->wm_forw )  {
		if( wp->wm_magic != WMEMBER_MAGIC )  {
d285 1
a285 1
	for( wp = headp->wm_forw; wp != headp; wp = wp->wm_forw )  {
d310 2
a311 4
	for( wp = headp->wm_forw; wp != headp; )  {
		register struct wmember *next;

		if( wp->wm_magic != WMEMBER_MAGIC )
d313 2
a314 2
		wp->wm_magic = -1;	/* Sanity */
		next = wp->wm_forw;
a315 1
		wp = next;
a316 1
	headp->wm_forw = headp->wm_back = headp;
d351 2
a352 2
	for( wp = headp->wm_forw; wp != headp; wp = wp->wm_forw )  {
		if( wp->wm_magic != WMEMBER_MAGIC )  {
d365 1
a365 1
	for( wp = headp->wm_forw; wp != headp; wp = wp->wm_forw )  {
@


9.3
log
@Fixed some lint
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: reg.c,v 9.2 89/11/30 02:24:20 mike Locked $ (BRL)";
d184 1
a184 1
mk_memb( fp, name, mat, op )
d188 1
a188 1
char	op;
d196 2
a197 2
	if( op )
		rec.M.m_relation = op;
@


9.2
log
@Added "int" declarations for some formal parameters.
Added error checking on output operations.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: reg.c,v 9.1 89/05/19 05:50:10 mike Locked $ (BRL)";
d188 1
a188 1
int	op;
d283 4
a286 1
	mk_comb( fp, name, len, region, matname, matparm, rgb, inherit );
d289 1
a289 1
			fprintf(stderr,"mk_wmcomb: mk_memb() failure\n");
d295 17
d315 2
d323 1
a323 1
	return(0);
d351 1
a351 1
char	inherit;
d367 4
a370 1
	mk_rcomb( fp, name, len, region, matname, matparm, rgb, id, air, material, los, inherit );
d373 1
a373 1
			fprintf(stderr,"mk_lrcomb: mk_memb() failure\n");
d379 1
a379 10
	for( wp = headp->wm_forw; wp != headp; )  {
		register struct wmember *next;

		wp->wm_magic = -1;	/* Sanity */
		next = wp->wm_forw;
		free( (char *)wp );
		wp = next;
	}
	headp->wm_forw = headp->wm_back = headp;
	return(0);
@


9.1
log
@Release_3.5
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: reg.c,v 8.2 89/04/05 13:59:59 wm Exp $ (BRL)";
d58 2
d88 2
a89 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
d104 2
d144 2
a145 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
d160 2
d173 2
a174 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
d207 2
a208 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
d263 2
a268 1
register struct wmember *headp;
d284 6
a289 2
	for( wp = headp->wm_forw; wp != headp; wp = wp->wm_forw )
		mk_memb( fp, wp->wm_name, wp->wm_mat, wp->wm_op );
d320 2
a329 1
register struct wmember *headp;
d346 6
a351 2
	for( wp = headp->wm_forw; wp != headp; wp = wp->wm_forw )
		mk_memb( fp, wp->wm_name, wp->wm_mat, wp->wm_op );
@


8.2
log
@Routines mk_rcomb and mk_lrcomb added to support addtitional region parameters
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: reg.c,v 8.1 88/10/05 00:28:59 wm Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d13 2
a14 1
 *  
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: reg.c,v 1.3 88/08/20 06:50:14 phil Exp $ (BRL)";
d90 21
d112 32
d273 57
@


1.3
log
@mcomb -> comb, comb -> fcomb.  Some param changed as well.
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: reg.c,v 1.2 88/05/13 22:47:51 phil Locked $ (BRL)";
@


1.2
log
@lint fixes
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: reg.c,v 1.1 87/12/24 02:21:22 mike Locked $ (BRL)";
d39 8
d48 1
a48 1
 *			M K _ M C O M B
d50 2
a51 1
 *  Make a combination with material properties info
d54 1
a54 1
mk_mcomb( fp, name, len, region, matname, matparm, override, rgb )
d60 1
d78 1
a78 1
	if( override )  {
d84 1
d91 1
a91 1
 *			M K _ C O M B
d93 2
a94 2
 *  Make a simple combination header.
 * Must be followed by 'len' mk_memb() calls before any other mk_* routines
d97 1
a97 1
mk_comb( fp, name, len, region )
a131 1
	rec.M.m_relation = op;
d133 11
a143 2
	for( i=0; i<16; i++ )
		rec.M.m_mat[i] = mat[i];
d174 1
a174 1
	mat_idn(wp->wm_mat);
d196 1
a196 1
mk_lcomb( fp, name, region, matname, matparm, override, rgb, headp )
d202 1
d218 1
a218 1
	mk_mcomb( fp, name, len, region, matname, matparm, override, rgb );
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.1 87/11/02 23:29:01 mike Rel $ (BRL)";
d44 1
d75 1
d85 1
d101 1
d109 1
d126 1
d176 1
d212 1
@
