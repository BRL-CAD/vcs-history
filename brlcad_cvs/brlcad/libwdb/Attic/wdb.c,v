head	11.14;
access;
symbols
	ansi-20040405-merged:11.10.2.2
	postmerge-20040405-ansi:11.12
	premerge-20040404-ansi:11.11
	postmerge-autoconf:11.11
	autoconf-freeze:11.10.10.2
	premerge-autoconf:11.11
	postmerge-20040315-windows:11.11
	premerge-20040315-windows:11.11
	windows-20040315-freeze:11.10.4.1
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.3
	offsite-5-3-pre:11.7
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:1.1
	rel-1-24:1.1
	rel-1-20:1.1;
locks; strict;
comment	@ * @;


11.14
date	2004.05.21.18.07.38;	author morrison;	state dead;
branches;
next	11.13;

11.13
date	2004.05.10.15.30.47;	author erikg;	state Exp;
branches;
next	11.12;

11.12
date	2004.04.05.07.40.23;	author morrison;	state Exp;
branches;
next	11.11;

11.11
date	2004.02.02.17.39.30;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.08.20;	author jra;	state Exp;
branches
	11.10.2.1
	11.10.4.1
	11.10.10.1;
next	11.9;

11.9
date	2002.08.15.20.55.30;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.20.22.31.12;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.07.24.19.27.31;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.07.12.21.58.04;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	2000.07.08.04.01.11;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.07.08.01.41.22;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.06.19.19.30.43;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.08.31.11.12.44;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.09.51.42;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.10.19.21.39.59;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.09.19.56.53;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	92.02.14.15.37.40;	author mmark;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.36.52;	author mike;	state Rel4_0;
branches;
next	9.19;

9.19
date	91.07.02.02.34.57;	author mike;	state Exp;
branches;
next	9.18;

9.18
date	91.06.23.00.09.59;	author mike;	state Exp;
branches;
next	9.17;

9.17
date	91.06.14.07.41.21;	author mike;	state Exp;
branches;
next	9.16;

9.16
date	91.06.14.07.36.01;	author mike;	state Exp;
branches;
next	9.15;

9.15
date	91.06.13.02.25.53;	author mike;	state Exp;
branches;
next	9.14;

9.14
date	91.06.13.02.01.22;	author mike;	state Exp;
branches;
next	9.13;

9.13
date	91.02.08.22.43.33;	author mike;	state Exp;
branches;
next	9.12;

9.12
date	90.12.05.04.40.59;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	90.12.05.04.34.23;	author mike;	state Exp;
branches;
next	9.10;

9.10
date	90.12.05.04.04.58;	author mike;	state Exp;
branches;
next	9.9;

9.9
date	90.11.01.05.18.31;	author mike;	state Exp;
branches;
next	9.8;

9.8
date	90.11.01.05.02.44;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	90.10.18.13.46.07;	author sue;	state Exp;
branches;
next	9.6;

9.6
date	90.03.05.20.51.10;	author mike;	state Exp;
branches;
next	9.5;

9.5
date	90.02.08.01.17.52;	author mike;	state Exp;
branches;
next	9.4;

9.4
date	90.02.08.00.53.46;	author mike;	state Exp;
branches;
next	9.3;

9.3
date	89.12.08.20.36.07;	author mike;	state Exp;
branches;
next	9.2;

9.2
date	89.11.27.22.44.11;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.05.50.15;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.01.08.23.39.32;	author wm;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.29.02;	author mike;	state Rel3_0;
branches;
next	7.9;

7.9
date	88.08.30.20.26.31;	author phil;	state Exp;
branches;
next	7.8;

7.8
date	88.08.24.10.08.58;	author steveb;	state Exp;
branches;
next	7.7;

7.7
date	88.08.20.06.51.12;	author phil;	state Exp;
branches;
next	7.6;

7.6
date	88.08.19.02.23.16;	author phil;	state Exp;
branches;
next	7.5;

7.5
date	88.08.17.11.50.51;	author steveb;	state Exp;
branches;
next	7.4;

7.4
date	88.05.13.22.47.56;	author mike;	state Exp;
branches;
next	7.3;

7.3
date	87.12.31.03.41.14;	author mike;	state Exp;
branches;
next	7.2;

7.2
date	87.12.24.02.21.16;	author mike;	state Exp;
branches;
next	7.1;

7.1
date	87.11.02.23.29.01;	author mike;	state Rel;
branches;
next	1.8;

1.8
date	87.10.27.21.14.27;	author mike;	state Exp;
branches;
next	1.7;

1.7
date	87.10.13.22.30.10;	author mike;	state Exp;
branches;
next	1.6;

1.6
date	87.09.26.08.05.14;	author mike;	state Exp;
branches;
next	1.5;

1.5
date	87.09.25.23.18.37;	author mike;	state Exp;
branches;
next	1.4;

1.4
date	87.09.20.12.11.08;	author mike;	state Exp;
branches;
next	1.3;

1.3
date	87.09.20.12.05.54;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.09.16.23.00.17;	author mike;	state Exp;
branches;
next	1.1;

1.1
date	87.01.12.14.43.46;	author mike;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.58;	author morrison;	state Exp;
branches;
next	11.10.2.2;

11.10.2.2
date	2004.03.17.21.21.48;	author morrison;	state Exp;
branches;
next	;

11.10.4.1
date	2004.03.11.23.45.48;	author morrison;	state Exp;
branches;
next	;

11.10.10.1
date	2004.02.12.19.41.24;	author erikg;	state Exp;
branches;
next	11.10.10.2;

11.10.10.2
date	2004.03.15.14.07.34;	author erikg;	state Exp;
branches;
next	;


desc
@Library for writing databases
@


11.14
log
@moved to src/
@
text
@/*
 *			W D B . C
 *
 *  Library for writing MGED databases from arbitrary procedures.
 *  Assumes that some of the structure of such databases are known
 *  by the calling routines.
 *
 *  It is expected that this library will grow as experience is gained.
 *  Routines for writing every permissible solid do not yet exist.
 *
 *  Note that routines which are passed point_t or vect_t or mat_t
 *  parameters (which are call-by-address) must be VERY careful to
 *  leave those parameters unmodified (eg, by scaling), so that the
 *  calling routine is not surprised.
 *
 *  Return codes of 0 are OK, -1 signal an error.
 *
 *  Authors -
 *	Michael John Muuss
 *	Paul R. Stay
 *	Susanne Muuss, J.D.
 *  
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/libwdb/wdb.c,v 11.13 2004/05/10 15:30:47 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"

/*
 *			M K _ H A L F
 *
 *  Make a halfspace.  Specified by distance from origin, and
 *  outward pointing normal vector.
 */
int
mk_half(struct rt_wdb *wdbp, const char *name, const fastf_t *norm, double d)
{
	struct rt_half_internal		*half;

	BU_GETSTRUCT( half, rt_half_internal );
	half->magic = RT_HALF_INTERNAL_MAGIC;
	VMOVE( half->eqn, norm );
	half->eqn[3] = d;

	return wdb_export( wdbp, name, (genptr_t)half, ID_HALF, mk_conv2mm );
}

/*
 *			M K _ G R I P
 *
 *  Make a grip psuedo solid.  Specified by a center, normal vector, and
 *  magnitude.
 */
int
mk_grip( 
	struct rt_wdb *wdbp,
	const char *name,
	const point_t center,
	const vect_t normal,
	const fastf_t magnitude )
{
	struct rt_grip_internal		*grip;

	BU_GETSTRUCT( grip, rt_grip_internal );
	grip->magic = RT_GRIP_INTERNAL_MAGIC;
	VMOVE( grip->center, center );
	VMOVE( grip->normal, normal );
	grip->mag = magnitude;

	return wdb_export( wdbp, name, (genptr_t)grip, ID_GRIP, mk_conv2mm );
}

/*
 *			M K _ R P P
 *
 *  Make a right parallelpiped.  Specified by minXYZ, maxXYZ.
 */
int
mk_rpp(struct rt_wdb *wdbp, const char *name, const fastf_t *min, const fastf_t *max)
{
	point_t	pt8[8];

	VSET( pt8[0], min[X], min[Y], min[Z] );
	VSET( pt8[1], max[X], min[Y], min[Z] );
	VSET( pt8[2], max[X], max[Y], min[Z] );
	VSET( pt8[3], min[X], max[Y], min[Z] );

	VSET( pt8[4], min[X], min[Y], max[Z] );
	VSET( pt8[5], max[X], min[Y], max[Z] );
	VSET( pt8[6], max[X], max[Y], max[Z] );
	VSET( pt8[7], min[X], max[Y], max[Z] );

	return( mk_arb8( wdbp, name, &pt8[0][X] ) );
}



/*			M K _ W E D G E
 *
 *  Makes a right angular wedge given a starting vertex located in the, lower
 *  left corner, an x and a z direction vector, x, y, and z lengths, and an
 *  x length for the top.  The y direcion vector is x cross z.
 */
int
mk_wedge(struct rt_wdb *wdbp, const char *name, const fastf_t *vert, const fastf_t *xdirv, const fastf_t *zdirv, fastf_t xlen, fastf_t ylen, fastf_t zlen, fastf_t x_top_len)
{
	point_t		pts[8];		/* vertices for the wedge */
	vect_t		xvec;		/* x_axis vector */
	vect_t		txvec;		/* top x_axis vector */
	vect_t		yvec;		/* y-axis vector */
	vect_t		zvec;		/* z-axix vector */
	vect_t		x_unitv;	/* x-axis unit vector*/
	vect_t		z_unitv;	/* z-axis unit vector */
	vect_t		y_unitv;

	VMOVE( x_unitv, xdirv);
	VUNITIZE(x_unitv);
	VMOVE( z_unitv, zdirv );
	VUNITIZE(z_unitv);
	
	/* Make y_unitv */
	VCROSS(y_unitv, x_unitv, z_unitv);

	/* Scale all vectors. */
	VSCALE(xvec, x_unitv, xlen);
	VSCALE(txvec, x_unitv, x_top_len);
	VSCALE(zvec, z_unitv, zlen);
	VSCALE(yvec, y_unitv, ylen);

	/* Make bottom face */

	VMOVE(pts[0], vert);		/* Move given vertex into pts[0] */
	VADD2(pts[1], pts[0], xvec);	/* second vertex. */
	VADD2(pts[2], pts[1], yvec);	/* third vertex */
	VADD2(pts[3], pts[0], yvec);	/* foruth vertex */

	/* Make top face by extruding bottom face vertices */

	VADD2(pts[4], pts[0], zvec);	/* fifth vertex */
	VADD2(pts[5], pts[4], txvec);	/* sixth vertex */
	VADD2(pts[6], pts[5], yvec);	/* seventh vertex */
	VADD2(pts[7], pts[4], yvec);	/* eighth vertex */

	return( mk_arb8(wdbp, name, &pts[0][X]) );
}


/*
 *			M K _ A R B 4
 */
int
mk_arb4(struct rt_wdb *wdbp, const char *name, const fastf_t *pts)
             		      
          		      
             	     	/* [4*3] */
{
	point_t	pt8[8];

	VMOVE( pt8[0], &pts[0*3] );
	VMOVE( pt8[1], &pts[1*3] );
	VMOVE( pt8[2], &pts[2*3] );
	VMOVE( pt8[3], &pts[2*3] );	/* shared point for base */

	VMOVE( pt8[4], &pts[3*3] );	/* top point */
	VMOVE( pt8[5], &pts[3*3] );
	VMOVE( pt8[6], &pts[3*3] );
	VMOVE( pt8[7], &pts[3*3] );

	return( mk_arb8( wdbp, name, &pt8[0][X] ) );
}

/*
 *			M K _ A R B 8
 *
 *  All plates with 4 points must be co-planar.
 *  If there are degeneracies (i.e., all 8 vertices are not distinct),
 *  then certain requirements must be met.
 *  If we think of the ARB8 as having a top and a bottom plate,
 *  the first four points listed must lie on one plate, and
 *  the second four points listed must lie on the other plate.
 */
int
mk_arb8(struct rt_wdb *wdbp, const char *name, const fastf_t *pts)
             		      
          		      
             	     		/* [24] */
{
	register int i;
	struct rt_arb_internal	*arb;

	BU_GETSTRUCT( arb, rt_arb_internal );
	arb->magic = RT_ARB_INTERNAL_MAGIC;
#	include "noalias.h"
	for( i=0; i < 8; i++ )  {
		VMOVE( arb->pt[i], &pts[i*3] );
	}

	return wdb_export( wdbp, name, (genptr_t)arb, ID_ARB8, mk_conv2mm );
}

/*
 *			M K _ S P H
 *
 *  Make a sphere with the given center point and radius.
 */
int
mk_sph(struct rt_wdb *wdbp, const char *name, const fastf_t *center, fastf_t radius)
{
	struct rt_ell_internal	*ell;

	BU_GETSTRUCT( ell, rt_ell_internal );
	ell->magic = RT_ELL_INTERNAL_MAGIC;
	VMOVE( ell->v, center );
	VSET( ell->a, radius, 0, 0 );
	VSET( ell->b, 0, radius, 0 );
	VSET( ell->c, 0, 0, radius );

	return wdb_export( wdbp, name, (genptr_t)ell, ID_ELL, mk_conv2mm );
}

/*
 *			M K _ E L L
 *
 *  Make an ellipsoid at the given center point with 3 perp. radius vectors.
 *  The eccentricity of the ellipsoid is controlled by the relative
 *  lengths of the three radius vectors.
 */
int
mk_ell(struct rt_wdb *wdbp, const char *name, const fastf_t *center, const fastf_t *a, const fastf_t *b, const fastf_t *c)
{
	struct rt_ell_internal	*ell;

	BU_GETSTRUCT( ell, rt_ell_internal );
	ell->magic = RT_ELL_INTERNAL_MAGIC;
	VMOVE( ell->v, center );
	VMOVE( ell->a, a );
	VMOVE( ell->b, b );
	VMOVE( ell->c, c );

	return wdb_export( wdbp, name, (genptr_t)ell, ID_ELL, mk_conv2mm );
}

/*
 *			M K _ T O R
 *
 *  Make a torus.  Specify center, normal,
 *  r1: distance from center point to center of solid part,
 *  r2: radius of solid part.
 */
int
mk_tor(struct rt_wdb *wdbp, const char *name, const fastf_t *center, const fastf_t *inorm, double r1, double r2)
{
	struct rt_tor_internal	*tor;

	BU_GETSTRUCT( tor, rt_tor_internal );
	tor->magic = RT_TOR_INTERNAL_MAGIC;
	VMOVE( tor->v, center );
	VMOVE( tor->h, inorm );
	tor->r_a = r1;
	tor->r_h = r2;

	return wdb_export( wdbp, name, (genptr_t)tor, ID_TOR, mk_conv2mm );
}

/*
 *			M K _ R C C
 *
 *  Make a Right Circular Cylinder (special case of the TGC).
 */
int
mk_rcc(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, fastf_t radius)
{
	vect_t	cross1, cross2;
	vect_t	a, b;

	if( MAGSQ(height) <= SQRT_SMALL_FASTF )
		return -2;

	/* Create two mutually perpendicular vectors, perpendicular to H */
	mat_vec_ortho( cross1, height );
	VCROSS( cross2, cross1, height );
	VUNITIZE( cross2 );

	VSCALE( a, cross1, radius );
	VSCALE( b, cross2, radius );

	return mk_tgc( wdbp, name, base, height, a, b, a, b );
}

/*
 *			M K _ T G C
 *
 *  Make a Truncated General Cylinder.
 */
int
mk_tgc(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, const fastf_t *a, const fastf_t *b, const fastf_t *c, const fastf_t *d)
{
	struct rt_tgc_internal	*tgc;

	BU_GETSTRUCT( tgc, rt_tgc_internal );
	tgc->magic = RT_TGC_INTERNAL_MAGIC;
	VMOVE( tgc->v, base );
	VMOVE( tgc->h, height );
	VMOVE( tgc->a, a );
	VMOVE( tgc->b, b );
	VMOVE( tgc->c, c );
	VMOVE( tgc->d, d );

	return wdb_export( wdbp, name, (genptr_t)tgc, ID_TGC, mk_conv2mm );
}


/*			M K _ C O N E
 *
 *  Makes a right circular cone given the center point of the base circle,
 *  a direction vector, a scalar height, and the radii at each end of the
 *  cone.
 */
int
mk_cone(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *dirv, fastf_t height, fastf_t rad1, fastf_t rad2)
{
	vect_t		a, avec;	/* one base radius vector */
	vect_t		b, bvec;	/* another base radius vector */
	vect_t		cvec;		/* nose radius vector */
	vect_t		dvec;		/* another nose radius vector */
	vect_t		h_unitv;	/* local copy of dirv */
	vect_t		hgtv;		/* height vector */
	fastf_t		f;

	if( (f = MAGNITUDE(dirv)) <= SQRT_SMALL_FASTF )
		return -2;
	f = 1/f;
	VSCALE( h_unitv, dirv, f );
	VSCALE(hgtv, h_unitv, height);

	/* Now make a, b, c, and d vectors. */

	mat_vec_ortho(a, h_unitv);
	VUNITIZE(a);
	VCROSS(b, h_unitv, a);
	VSCALE(avec, a, rad1);
	VSCALE(bvec, b, rad1);
	VSCALE(cvec, a, rad2);
	VSCALE(dvec, b, rad2);

	return( mk_tgc(wdbp, name, base, hgtv, avec, bvec, cvec, dvec) );
}


/*
 *		M K _ T R C _ H
 *
 *  mk_trc( name, base, height, radius1, radius2 )
 *  Make a truncated right cylinder, with base and height.
 *  Not just called mk_trc() to avoid conflict with a previous routine
 *  of that name with different calling sequence.
 */
int
mk_trc_h(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, fastf_t radbase, fastf_t radtop)
{
	vect_t	cross1, cross2;
	vect_t	a, b, c, d;

	if( MAGSQ(height) <= SQRT_SMALL_FASTF )
		return -2;

	/* Create two mutually perpendicular vectors, perpendicular to H */
	vec_ortho( cross1, height );
	VCROSS( cross2, cross1, height );
	VUNITIZE( cross2 );

	VSCALE( a, cross1, radbase );
	VSCALE( b, cross2, radbase );

	VSCALE( c, cross1, radtop );
	VSCALE( d, cross2, radtop );

	return mk_tgc( wdbp, name, base, height, a, b, c, d );
}

/*
 *			M K _ T R C _ T O P
 *
 *  Convenience wrapper for mk_trc_h().
 */
int
mk_trc_top(struct rt_wdb *wdbp, const char *name, const fastf_t *ibase, const fastf_t *itop, fastf_t radbase, fastf_t radtop)
{
	vect_t	height;

	VSUB2( height, itop, ibase );
	return( mk_trc_h( wdbp, name, ibase, height, radbase, radtop ) );
}

/*
 *			M K _ R P C
 *
 *  Makes a right parabolic cylinder given the origin, or main vertex,
 *  a height vector, a breadth vector (B . H must be 0), and a scalar
 *  rectangular half-width (for the top of the rpc).
 */
int
mk_rpc(
	struct rt_wdb *wdbp,
	const char *name,
	const point_t vert,
	const vect_t height,
	const vect_t breadth,
	double half_w )
{
	struct rt_rpc_internal	*rpc;

	BU_GETSTRUCT( rpc, rt_rpc_internal );
	rpc->rpc_magic = RT_RPC_INTERNAL_MAGIC;

	VMOVE( rpc->rpc_V, vert );
	VMOVE( rpc->rpc_H, height );
	VMOVE( rpc->rpc_B, breadth );
	rpc->rpc_r = half_w;

	return wdb_export( wdbp, name, (genptr_t)rpc, ID_RPC, mk_conv2mm );
}

/*
 *			M K _ R H C
 *
 *  Makes a right hyperbolic cylinder given the origin, or main vertex,
 *  a height vector, a breadth vector (B . H must be 0), a scalar
 *  rectangular half-width (for the top of the rpc), and the scalar
 *  distance from the tip of the hyperbola to the intersection of the
 *  asymptotes.
 */
int
mk_rhc(
	struct rt_wdb *wdbp,
	const char *name,
	const point_t vert,
	const vect_t height,
	const vect_t breadth,
	fastf_t	half_w,
	fastf_t asymp )
{
	struct rt_rhc_internal	*rhc;

	BU_GETSTRUCT( rhc, rt_rhc_internal );
	rhc->rhc_magic = RT_RHC_INTERNAL_MAGIC;

	VMOVE( rhc->rhc_V, vert );
	VMOVE( rhc->rhc_H, height );
	VMOVE( rhc->rhc_B, breadth );
	rhc->rhc_r = half_w;
	rhc->rhc_c = asymp;

	return wdb_export( wdbp, name, (genptr_t)rhc, ID_RHC, mk_conv2mm );
}

/*
 *			M K _ E P A
 *
 *  Makes an elliptical paraboloid given the origin, a height vector H,
 *  a unit vector A along the semi-major axis (A . H must equal 0), and
 *  the scalar lengths, r1 and r2, of the semi-major and -minor axes.
 */
int
mk_epa(
	struct rt_wdb *wdbp,
	const char *name,
	const point_t vert,
	const vect_t height,
	const vect_t breadth,
	fastf_t r1,
	fastf_t r2 )
{
	struct rt_epa_internal	*epa;

	BU_GETSTRUCT( epa, rt_epa_internal );
	epa->epa_magic = RT_EPA_INTERNAL_MAGIC;

	VMOVE( epa->epa_V, vert );
	VMOVE( epa->epa_H, height );
	VMOVE( epa->epa_Au, breadth );
	epa->epa_r1 = r1;
	epa->epa_r2 = r2;

	return wdb_export( wdbp, name, (genptr_t)epa, ID_EPA, mk_conv2mm );
}

/*
 *			M K _ E H Y
 *
 *  Makes an elliptical hyperboloid given the origin, a height vector H,
 *  a unit vector A along the semi-major axis (A . H must equal 0),
 *  the scalar lengths, r1 and r2, of the semi-major and -minor axes,
 *  and the distance c between the tip of the hyperboloid and the vertex
 *  of the asymptotic cone.
 */
int
mk_ehy(
	struct rt_wdb *wdbp,
	const char *name,
	const point_t vert,
	const vect_t height,
	const vect_t breadth,
	fastf_t r1,
	fastf_t r2,
	fastf_t c )
{
	struct rt_ehy_internal	*ehy;

	BU_GETSTRUCT( ehy, rt_ehy_internal );
	ehy->ehy_magic = RT_EHY_INTERNAL_MAGIC;

	VMOVE( ehy->ehy_V, vert );
	VMOVE( ehy->ehy_H, height );
	VMOVE( ehy->ehy_Au, breadth );
	ehy->ehy_r1 = r1;
	ehy->ehy_r2 = r2;
	ehy->ehy_c = c;

	return wdb_export( wdbp, name, (genptr_t)ehy, ID_EHY, mk_conv2mm );
}

/*
 *			M K _ E T O
 *
 *  Makes an elliptical torus given the origin, a plane normal vector N,
 *  a vector C along the semi-major axis of the elliptical cross-section,
 *  the scalar lengths r and rd, of the radius of revolution and length
 *  of semi-minor axis of the elliptical cross section.
 */
int
mk_eto(
	struct rt_wdb *wdbp,
	const char *name,
	const point_t vert,
	const vect_t norm,
	const vect_t smajor,
	fastf_t rrot,
	fastf_t sminor )
{
	struct rt_eto_internal	*eto;

	BU_GETSTRUCT( eto, rt_eto_internal );
	eto->eto_magic = RT_ETO_INTERNAL_MAGIC;

	VMOVE( eto->eto_V, vert );
	VMOVE( eto->eto_N, norm );
	VMOVE( eto->eto_C, smajor );
	eto->eto_r = rrot;
	eto->eto_rd = sminor;

	return wdb_export( wdbp, name, (genptr_t)eto, ID_ETO, mk_conv2mm );
}
@


11.13
log
@change conf.h to a wrapped config.h
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libwdb/wdb.c,v 11.12 2004/04/05 07:40:23 morrison Exp $ (BRL)";
@


11.12
log
@merge of ansi-6-0-branch into HEAD
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d36 5
a40 1
#include "conf.h"
@


11.11
log
@update copyright to include span through 2003
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.10 2002/08/20 17:08:20 jra Exp $ (BRL)";
d55 1
a55 5
mk_half( wdbp, name, norm, d )
struct rt_wdb	*wdbp;
const char		*name;
const vect_t	norm;
double		d;
d98 1
a98 5
mk_rpp( wdbp, name, min, max )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	min;
const point_t	max;
d124 1
a124 10
mk_wedge(wdbp, name, vert, xdirv, zdirv, xlen, ylen, zlen, x_top_len)
struct rt_wdb		*wdbp;
const char		*name;
const point_t	vert;
const vect_t	xdirv;
const vect_t	zdirv;
fastf_t		xlen;
fastf_t		ylen;
fastf_t		zlen;
fastf_t		x_top_len;
d171 4
a174 4
mk_arb4( wdbp, name, pts )
struct rt_wdb		*wdbp;
const char		*name;
const fastf_t	*pts;	/* [4*3] */
d202 4
a205 4
mk_arb8( wdbp, name, pts )
struct rt_wdb		*wdbp;
const char		*name;
const fastf_t	*pts;		/* [24] */
d226 1
a226 5
mk_sph( wdbp, name, center, radius )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	center;
fastf_t		radius;
d248 1
a248 5
mk_ell( wdbp, name, center, a, b, c )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	center;
const vect_t	a, b, c;
d270 1
a270 6
mk_tor( wdbp, name, center, inorm, r1, r2 )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	center;
const vect_t	inorm;
double		r1, r2;
d290 1
a290 6
mk_rcc( wdbp, name, base, height, radius )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	base;
const vect_t	height;
fastf_t		radius;
d315 1
a315 9
mk_tgc( wdbp, name, base, height, a, b, c, d )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	base;
const vect_t	height;
const vect_t	a;
const vect_t	b;
const vect_t	c;
const vect_t	d;
d339 1
a339 8
mk_cone( wdbp, name, base, dirv, height, rad1, rad2)
struct rt_wdb		*wdbp;
const char		*name;
const point_t	base;
const vect_t	dirv;
fastf_t		height;
fastf_t		rad1;
fastf_t		rad2;
d378 1
a378 7
mk_trc_h( wdbp, name, base, height, radbase, radtop )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	base;
const vect_t	height;
fastf_t		radbase;
fastf_t		radtop;
d406 1
a406 7
mk_trc_top( wdbp, name, ibase, itop, radbase, radtop )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	ibase;
const point_t	itop;
fastf_t		radbase;
fastf_t		radtop;
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1987 by the United States Army.
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.8 2001/04/20 22:31:12 morrison Exp $ (BRL)";
@


11.10.4.1
log
@sync to HEAD...
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /n/cad/c/CVS/brlcad/libwdb/wdb.c,v 11.11 2004/02/02 17:39:30 morrison Exp $ (BRL)";
@


11.10.10.1
log
@merge from HEAD
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.11 2004/02/02 17:39:30 morrison Exp $ (BRL)";
@


11.10.10.2
log
@merge from head
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.10.10.1 2004/02/12 19:41:24 erikg Exp $ (BRL)";
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.10 2002/08/20 17:08:20 jra Exp $ (BRL)";
d55 5
a59 1
mk_half(struct rt_wdb *wdbp, const char *name, const fastf_t *norm, double d)
d102 5
a106 1
mk_rpp(struct rt_wdb *wdbp, const char *name, const fastf_t *min, const fastf_t *max)
d132 10
a141 1
mk_wedge(struct rt_wdb *wdbp, const char *name, const fastf_t *vert, const fastf_t *xdirv, const fastf_t *zdirv, fastf_t xlen, fastf_t ylen, fastf_t zlen, fastf_t x_top_len)
d188 4
a191 4
mk_arb4(struct rt_wdb *wdbp, const char *name, const fastf_t *pts)
             		      
          		      
             	     	/* [4*3] */
d219 4
a222 4
mk_arb8(struct rt_wdb *wdbp, const char *name, const fastf_t *pts)
             		      
          		      
             	     		/* [24] */
d243 5
a247 1
mk_sph(struct rt_wdb *wdbp, const char *name, const fastf_t *center, fastf_t radius)
d269 5
a273 1
mk_ell(struct rt_wdb *wdbp, const char *name, const fastf_t *center, const fastf_t *a, const fastf_t *b, const fastf_t *c)
d295 6
a300 1
mk_tor(struct rt_wdb *wdbp, const char *name, const fastf_t *center, const fastf_t *inorm, double r1, double r2)
d320 6
a325 1
mk_rcc(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, fastf_t radius)
d350 9
a358 1
mk_tgc(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, const fastf_t *a, const fastf_t *b, const fastf_t *c, const fastf_t *d)
d382 8
a389 1
mk_cone(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *dirv, fastf_t height, fastf_t rad1, fastf_t rad2)
d428 7
a434 1
mk_trc_h(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, fastf_t radbase, fastf_t radtop)
d462 7
a468 1
mk_trc_top(struct rt_wdb *wdbp, const char *name, const fastf_t *ibase, const fastf_t *itop, fastf_t radbase, fastf_t radtop)
@


11.10.2.2
log
@sync branch with HEAD
@
text
@d29 1
a29 1
 *	This software is Copyright (C) 1987-2004 by the United States Army.
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d55 5
a59 1
mk_half(struct rt_wdb *wdbp, const char *name, const fastf_t *norm, double d)
d102 5
a106 1
mk_rpp(struct rt_wdb *wdbp, const char *name, const fastf_t *min, const fastf_t *max)
d132 10
a141 1
mk_wedge(struct rt_wdb *wdbp, const char *name, const fastf_t *vert, const fastf_t *xdirv, const fastf_t *zdirv, fastf_t xlen, fastf_t ylen, fastf_t zlen, fastf_t x_top_len)
d188 4
a191 4
mk_arb4(struct rt_wdb *wdbp, const char *name, const fastf_t *pts)
             		      
          		      
             	     	/* [4*3] */
d219 4
a222 4
mk_arb8(struct rt_wdb *wdbp, const char *name, const fastf_t *pts)
             		      
          		      
             	     		/* [24] */
d243 5
a247 1
mk_sph(struct rt_wdb *wdbp, const char *name, const fastf_t *center, fastf_t radius)
d269 5
a273 1
mk_ell(struct rt_wdb *wdbp, const char *name, const fastf_t *center, const fastf_t *a, const fastf_t *b, const fastf_t *c)
d295 6
a300 1
mk_tor(struct rt_wdb *wdbp, const char *name, const fastf_t *center, const fastf_t *inorm, double r1, double r2)
d320 6
a325 1
mk_rcc(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, fastf_t radius)
d350 9
a358 1
mk_tgc(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, const fastf_t *a, const fastf_t *b, const fastf_t *c, const fastf_t *d)
d382 8
a389 1
mk_cone(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *dirv, fastf_t height, fastf_t rad1, fastf_t rad2)
d428 7
a434 1
mk_trc_h(struct rt_wdb *wdbp, const char *name, const fastf_t *base, const fastf_t *height, fastf_t radbase, fastf_t radtop)
d462 7
a468 1
mk_trc_top(struct rt_wdb *wdbp, const char *name, const fastf_t *ibase, const fastf_t *itop, fastf_t radbase, fastf_t radtop)
@


11.8
log
@CONST to const
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.7 2000/07/24 19:27:31 mike Exp $ (BRL)";
d55 1
a55 5
mk_half( wdbp, name, norm, d )
struct rt_wdb	*wdbp;
const char		*name;
const vect_t	norm;
double		d;
d98 1
a98 5
mk_rpp( wdbp, name, min, max )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	min;
const point_t	max;
d124 1
a124 10
mk_wedge(wdbp, name, vert, xdirv, zdirv, xlen, ylen, zlen, x_top_len)
struct rt_wdb		*wdbp;
const char		*name;
const point_t	vert;
const vect_t	xdirv;
const vect_t	zdirv;
fastf_t		xlen;
fastf_t		ylen;
fastf_t		zlen;
fastf_t		x_top_len;
d171 4
a174 4
mk_arb4( wdbp, name, pts )
struct rt_wdb		*wdbp;
const char		*name;
const fastf_t	*pts;	/* [4*3] */
d202 4
a205 4
mk_arb8( wdbp, name, pts )
struct rt_wdb		*wdbp;
const char		*name;
const fastf_t	*pts;		/* [24] */
d226 1
a226 5
mk_sph( wdbp, name, center, radius )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	center;
fastf_t		radius;
d248 1
a248 5
mk_ell( wdbp, name, center, a, b, c )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	center;
const vect_t	a, b, c;
d270 1
a270 6
mk_tor( wdbp, name, center, inorm, r1, r2 )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	center;
const vect_t	inorm;
double		r1, r2;
d290 1
a290 6
mk_rcc( wdbp, name, base, height, radius )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	base;
const vect_t	height;
fastf_t		radius;
d315 1
a315 9
mk_tgc( wdbp, name, base, height, a, b, c, d )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	base;
const vect_t	height;
const vect_t	a;
const vect_t	b;
const vect_t	c;
const vect_t	d;
d339 1
a339 8
mk_cone( wdbp, name, base, dirv, height, rad1, rad2)
struct rt_wdb		*wdbp;
const char		*name;
const point_t	base;
const vect_t	dirv;
fastf_t		height;
fastf_t		rad1;
fastf_t		rad2;
d378 1
a378 7
mk_trc_h( wdbp, name, base, height, radbase, radtop )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	base;
const vect_t	height;
fastf_t		radbase;
fastf_t		radtop;
d406 1
a406 7
mk_trc_top( wdbp, name, ibase, itop, radbase, radtop )
struct rt_wdb		*wdbp;
const char		*name;
const point_t	ibase;
const point_t	itop;
fastf_t		radbase;
fastf_t		radtop;
@


11.7
log
@
Changed mged/typin.c to start using libwdb interfaces.
Which means mged/ged.c now also opens a libwdb interface.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.6 2000/07/12 21:58:04 mike Exp $ (BRL)";
d58 1
a58 1
CONST vect_t	norm;
d105 2
a106 2
CONST point_t	min;
CONST point_t	max;
d135 3
a137 3
CONST point_t	vert;
CONST vect_t	xdirv;
CONST vect_t	zdirv;
d191 1
a191 1
CONST fastf_t	*pts;	/* [4*3] */
d222 1
a222 1
CONST fastf_t	*pts;		/* [24] */
d246 1
a246 1
CONST point_t	center;
d272 2
a273 2
CONST point_t	center;
CONST vect_t	a, b, c;
d298 2
a299 2
CONST point_t	center;
CONST vect_t	inorm;
d323 2
a324 2
CONST point_t	base;
CONST vect_t	height;
d353 6
a358 6
CONST point_t	base;
CONST vect_t	height;
CONST vect_t	a;
CONST vect_t	b;
CONST vect_t	c;
CONST vect_t	d;
d385 2
a386 2
CONST point_t	base;
CONST vect_t	dirv;
d431 2
a432 2
CONST point_t	base;
CONST vect_t	height;
d465 2
a466 2
CONST point_t	ibase;
CONST point_t	itop;
@


11.6
log
@
New version of LIBWDB which takes a (struct rt_wdb *) rather than a
(FILE *) as the first parameter.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.5 2000/07/08 04:01:11 mike Exp $ (BRL)";
d57 1
a57 1
char		*name;
d104 1
a104 1
char		*name;
d134 1
a134 1
char		*name;
d190 1
a190 1
char		*name;
d221 1
a221 1
char		*name;
d245 1
a245 1
char		*name;
d271 1
a271 1
char		*name;
d297 1
a297 1
char		*name;
d322 1
a322 1
char		*name;
d352 1
a352 1
char		*name;
d384 1
a384 1
char		*name;
d430 1
a430 1
char		*name;
d464 1
a464 1
char		*name;
@


11.5
log
@
Modified to allow mk_fwrite_internal() to free the objects.
Added flag variable mk_version to indicate what database version to be written.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.4 2000/07/08 01:41:22 mike Exp $ (BRL)";
d55 2
a56 2
mk_half( fp, name, norm, d )
FILE		*fp;
d68 1
a68 1
	return mk_export_fwrite( fp, name, (genptr_t)half, ID_HALF );
d78 6
a83 6
mk_grip( fp, name, center, normal, magnitude )
FILE		*fp;
char		*name;
CONST point_t	center;
CONST vect_t	normal;
CONST fastf_t	magnitude;
d93 1
a93 1
	return mk_export_fwrite( fp, name, (genptr_t)grip, ID_GRIP );
d102 2
a103 2
mk_rpp( fp, name, min, max )
FILE		*fp;
d120 1
a120 1
	return( mk_arb8( fp, name, &pt8[0][X] ) );
d132 2
a133 2
mk_wedge(fp, name, vert, xdirv, zdirv, xlen, ylen, zlen, x_top_len)
FILE		*fp;
d180 1
a180 1
	return( mk_arb8(fp, name, &pts[0][X]) );
d188 2
a189 2
mk_arb4( fp, name, pts )
FILE		*fp;
d205 1
a205 1
	return( mk_arb8( fp, name, &pt8[0][X] ) );
d219 2
a220 2
mk_arb8( fp, name, pts )
FILE		*fp;
d234 1
a234 1
	return mk_export_fwrite( fp, name, (genptr_t)arb, ID_ARB8 );
d243 2
a244 2
mk_sph( fp, name, center, radius )
FILE		*fp;
d258 1
a258 1
	return mk_export_fwrite( fp, name, (genptr_t)ell, ID_ELL );
d269 2
a270 2
mk_ell( fp, name, center, a, b, c )
FILE		*fp;
d284 1
a284 1
	return mk_export_fwrite( fp, name, (genptr_t)ell, ID_ELL );
d295 2
a296 2
mk_tor( fp, name, center, inorm, r1, r2 )
FILE		*fp;
d311 1
a311 1
	return mk_export_fwrite( fp, name, (genptr_t)tor, ID_TOR );
d320 2
a321 2
mk_rcc( fp, name, base, height, radius )
FILE		*fp;
d341 1
a341 1
	return mk_tgc( fp, name, base, height, a, b, a, b );
d350 2
a351 2
mk_tgc( fp, name, base, height, a, b, c, d )
FILE		*fp;
d371 1
a371 1
	return mk_export_fwrite( fp, name, (genptr_t)tgc, ID_TGC );
d382 2
a383 2
mk_cone( fp, name, base, dirv, height, rad1, rad2)
FILE		*fp;
d415 1
a415 1
	return( mk_tgc(fp, name, base, hgtv, avec, bvec, cvec, dvec) );
d428 2
a429 2
mk_trc_h( fp, name, base, height, radbase, radtop )
FILE		*fp;
d453 1
a453 1
	return mk_tgc( fp, name, base, height, a, b, c, d );
d462 2
a463 2
mk_trc_top( fp, name, ibase, itop, radbase, radtop )
FILE		*fp;
d473 1
a473 1
	return( mk_trc_h( fp, name, ibase, height, radbase, radtop ) );
d484 7
a490 6
mk_rpc( fp, name, vert, height, breadth, half_w )
FILE		*fp;
char		*name;
CONST point_t	vert;
CONST vect_t	height, breadth;
double		half_w;
d502 1
a502 1
	return mk_export_fwrite( fp, name, (genptr_t)rpc, ID_RPC );
d515 8
a522 7
mk_rhc( fp, name, vert, height, breadth, half_w, asymp )
FILE		*fp;
char		*name;
CONST point_t	vert;
CONST vect_t	height, breadth;
fastf_t		half_w;
fastf_t		asymp;
d535 1
a535 1
	return mk_export_fwrite( fp, name, (genptr_t)rhc, ID_RHC );
d546 8
a553 6
mk_epa( fp, name, vert, height, breadth, r1, r2 )
FILE		*fp;
char		*name;
CONST point_t	vert;
CONST vect_t	height, breadth;
fastf_t		r1, r2;
d566 1
a566 1
	return mk_export_fwrite( fp, name, (genptr_t)epa, ID_EPA );
d579 9
a587 6
mk_ehy( fp, name, vert, height, breadth, r1, r2, c )
FILE		*fp;
char		*name;
CONST point_t	vert;
CONST vect_t	height, breadth;
fastf_t		r1, r2, c;
d601 1
a601 1
	return mk_export_fwrite( fp, name, (genptr_t)ehy, ID_EHY );
d613 8
a620 6
mk_eto( fp, name, vert, norm, smajor, rrot, sminor )
FILE		*fp;
char		*name;
CONST point_t	vert;
CONST vect_t	norm, smajor;
fastf_t		rrot, sminor;
d633 1
a633 1
	return mk_export_fwrite( fp, name, (genptr_t)eto, ID_ETO );
@


11.4
log
@
const RCSid
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/libwdb/wdb.c,v 11.3 1997/06/19 19:30:43 jra Exp $ (BRL)";
d61 1
a61 1
	struct rt_half_internal		half;
d63 4
a66 3
	half.magic = RT_HALF_INTERNAL_MAGIC;
	VMOVE( half.eqn, norm );
	half.eqn[3] = d;
d68 1
a68 1
	return mk_export_fwrite( fp, name, (genptr_t)&half, ID_HALF );
d85 1
a85 1
	struct rt_grip_internal		grip;
d87 5
a91 4
	grip.magic = RT_GRIP_INTERNAL_MAGIC;
	VMOVE( grip.center, center );
	VMOVE( grip.normal, normal );
	grip.mag = magnitude;
d93 1
a93 1
	return mk_export_fwrite( fp, name, (genptr_t)&grip, ID_GRIP );
d225 1
a225 1
	struct rt_arb_internal	arb;
d227 2
a228 1
	arb.magic = RT_ARB_INTERNAL_MAGIC;
d231 1
a231 1
		VMOVE( arb.pt[i], &pts[i*3] );
d234 1
a234 1
	return mk_export_fwrite( fp, name, (genptr_t)&arb, ID_ARB8 );
d249 1
a249 1
	struct rt_ell_internal	ell;
d251 6
a256 5
	ell.magic = RT_ELL_INTERNAL_MAGIC;
	VMOVE( ell.v, center );
	VSET( ell.a, radius, 0, 0 );
	VSET( ell.b, 0, radius, 0 );
	VSET( ell.c, 0, 0, radius );
d258 1
a258 1
	return mk_export_fwrite( fp, name, (genptr_t)&ell, ID_ELL );
d275 1
a275 1
	struct rt_ell_internal	ell;
d277 6
a282 5
	ell.magic = RT_ELL_INTERNAL_MAGIC;
	VMOVE( ell.v, center );
	VMOVE( ell.a, a );
	VMOVE( ell.b, b );
	VMOVE( ell.c, c );
d284 1
a284 1
	return mk_export_fwrite( fp, name, (genptr_t)&ell, ID_ELL );
d302 1
a302 1
	struct rt_tor_internal	tor;
d304 6
a309 5
	tor.magic = RT_TOR_INTERNAL_MAGIC;
	VMOVE( tor.v, center );
	VMOVE( tor.h, inorm );
	tor.r_a = r1;
	tor.r_h = r2;
d311 1
a311 1
	return mk_export_fwrite( fp, name, (genptr_t)&tor, ID_TOR );
d360 1
a360 1
	struct rt_tgc_internal	tgc;
d362 8
a369 7
	tgc.magic = RT_TGC_INTERNAL_MAGIC;
	VMOVE( tgc.v, base );
	VMOVE( tgc.h, height );
	VMOVE( tgc.a, a );
	VMOVE( tgc.b, b );
	VMOVE( tgc.c, c );
	VMOVE( tgc.d, d );
d371 1
a371 1
	return mk_export_fwrite( fp, name, (genptr_t)&tgc, ID_TGC );
d491 1
a491 1
	struct rt_rpc_internal	rpc;
d493 2
a494 1
	rpc.rpc_magic = RT_RPC_INTERNAL_MAGIC;
d496 4
a499 4
	VMOVE( rpc.rpc_V, vert );
	VMOVE( rpc.rpc_H, height );
	VMOVE( rpc.rpc_B, breadth );
	rpc.rpc_r = half_w;
d501 1
a501 1
	return mk_export_fwrite( fp, name, (genptr_t)&rpc, ID_RPC );
d522 1
a522 1
	struct rt_rhc_internal	rhc;
d524 2
a525 1
	rhc.rhc_magic = RT_RHC_INTERNAL_MAGIC;
d527 5
a531 5
	VMOVE( rhc.rhc_V, vert );
	VMOVE( rhc.rhc_H, height );
	VMOVE( rhc.rhc_B, breadth );
	rhc.rhc_r = half_w;
	rhc.rhc_c = asymp;
d533 1
a533 1
	return mk_export_fwrite( fp, name, (genptr_t)&rhc, ID_RHC );
d551 1
a551 1
	struct rt_epa_internal	epa;
d553 2
a554 1
	epa.epa_magic = RT_EPA_INTERNAL_MAGIC;
d556 5
a560 5
	VMOVE( epa.epa_V, vert );
	VMOVE( epa.epa_H, height );
	VMOVE( epa.epa_Au, breadth );
	epa.epa_r1 = r1;
	epa.epa_r2 = r2;
d562 1
a562 1
	return mk_export_fwrite( fp, name, (genptr_t)&epa, ID_EPA );
d582 1
a582 1
	struct rt_ehy_internal	ehy;
d584 2
a585 1
	ehy.ehy_magic = RT_EHY_INTERNAL_MAGIC;
d587 6
a592 6
	VMOVE( ehy.ehy_V, vert );
	VMOVE( ehy.ehy_H, height );
	VMOVE( ehy.ehy_Au, breadth );
	ehy.ehy_r1 = r1;
	ehy.ehy_r2 = r2;
	ehy.ehy_c = c;
d594 1
a594 1
	return mk_export_fwrite( fp, name, (genptr_t)&ehy, ID_EHY );
d613 1
a613 1
	struct rt_eto_internal	eto;
d615 2
a616 1
	eto.eto_magic = RT_ETO_INTERNAL_MAGIC;
d618 5
a622 5
	VMOVE( eto.eto_V, vert );
	VMOVE( eto.eto_N, norm );
	VMOVE( eto.eto_C, smajor );
	eto.eto_r = rrot;
	eto.eto_rd = sminor;
d624 1
a624 1
	return mk_export_fwrite( fp, name, (genptr_t)&eto, ID_ETO );
@


11.3
log
@Added mk_grip()
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 11.2 1996/08/31 11:12:44 mike Exp jra $ (BRL)";
@


11.2
log
@bu.h
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 11.1 1995/01/04 09:51:42 mike Rel4_4 mike $ (BRL)";
d68 24
@


11.1
log
@Release_4.4
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 10.4 94/10/19 21:39:59 mike Exp $ (BRL)";
d41 1
d43 1
a43 1
#include "rtlist.h"
@


10.4
log
@Matches header file change, to eliminate function prototype
problems on mk_arb4() and mk_arb8().
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 10.3 94/08/09 19:56:53 gdurf Exp Locker: mike $ (BRL)";
@


10.3
log
@Added include of conf.h.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 10.2 1992/02/14 15:37:40 mmark Exp gdurf $ (BRL)";
d93 1
a93 1
	return( mk_arb8( fp, name, (CONST point_t *)pt8 ) );
d153 1
a153 1
	return( mk_arb8(fp, name, (CONST point_t *)pts) );
d164 1
a164 1
CONST point_t	pts[4];
d168 4
a171 4
	VMOVE( pt8[0], pts[0] );
	VMOVE( pt8[1], pts[1] );
	VMOVE( pt8[2], pts[2] );
	VMOVE( pt8[3], pts[2] );	/* shared point for base */
d173 4
a176 4
	VMOVE( pt8[4], pts[3] );	/* top point */
	VMOVE( pt8[5], pts[3] );
	VMOVE( pt8[6], pts[3] );
	VMOVE( pt8[7], pts[3] );
d178 1
a178 1
	return( mk_arb8( fp, name, (CONST point_t *)pt8 ) );
d195 1
a195 1
CONST point_t	pts[8];
d203 1
a203 1
		VMOVE( arb.pt[i], pts[i] );
@


10.2
log
@added erim solids
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.19 91/07/02 02:34:57 mike Exp $ (BRL)";
d35 2
@


10.1
log
@Release_4.0
@
text
@d441 146
@


9.19
log
@ANSI lint
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.18 91/06/23 00:09:59 mike Exp $ (BRL)";
@


9.18
log
@Changed mk_trc() to mk_trc_h() to avoid confusion with old routine
of that name with different calling sequence.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.17 91/06/14 07:41:21 mike Exp $ (BRL)";
d91 1
a91 1
	return( mk_arb8( fp, name, pt8 ) );
d151 1
a151 1
	return( mk_arb8(fp, name, pts) );
d176 1
a176 1
	return( mk_arb8( fp, name, pt8 ) );
@


9.17
log
@More error checking
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.16 91/06/14 07:36:01 mike Exp $ (BRL)";
d385 2
a386 1
/*		M K _ T R C
d389 3
a391 1
 *  Make a truncated right cylinder. 
d394 1
a394 1
mk_trc( fp, name, base, height, radbase, radtop )
d425 1
a425 1
 *  Convenience wrapper for mk_trc().
d439 1
a439 1
	return( mk_trc( fp, name, ibase, height, radbase, radtop ) );
@


9.16
log
@Added error checking.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.15 91/06/13 02:25:53 mike Exp $ (BRL)";
d297 3
d401 3
@


9.15
log
@All converted to use import/export routines.
Many args declared as CONST
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.14 91/06/13 02:01:22 mike Exp $ (BRL)";
d360 1
d362 4
a365 2
	VMOVE(h_unitv, dirv);
	VUNITIZE(h_unitv);
@


9.14
log
@Changed torus to librt import/export
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.13 91/02/08 22:43:33 mike Exp $ (BRL)";
a38 1
#include "db.h"
a45 35
 * Input Vector Fields
 */
#define F(i)	(rec.s.s_values+(i-1)*3)
#define F1	(rec.s.s_values+(1-1)*3)
#define F2	(rec.s.s_values+(2-1)*3)
#define F3	(rec.s.s_values+(3-1)*3)
#define F4	(rec.s.s_values+(4-1)*3)
#define F5	(rec.s.s_values+(5-1)*3)
#define F6	(rec.s.s_values+(6-1)*3)
#define F7	(rec.s.s_values+(7-1)*3)
#define F8	(rec.s.s_values+(8-1)*3)

/*
 *			M K _ I D
 *
 *  Make a database header (ID) record.
 */
int
mk_id( fp, title )
FILE	*fp;
char	*title;
{
	union record rec;

	bzero( (char *)&rec, sizeof(rec) );
	rec.i.i_id = ID_IDENT;
	rec.i.i_units = ID_MM_UNIT;
	strncpy( rec.i.i_version, ID_VERSION, sizeof(rec.i.i_version) );
	strncpy( rec.i.i_title, title, sizeof(rec.i.i_title) );
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);
	return(0);
}

/*
d53 4
a56 4
FILE	*fp;
char	*name;
vect_t	norm;
double	d;
d74 4
a77 3
FILE	*fp;
char	*name;
point_t	min, max;
a101 1

d106 3
a108 3
point_t		vert;
vect_t		xdirv;
vect_t		zdirv;
a113 1

d160 3
a162 3
FILE	*fp;
char	*name;
point_t	pts[];
d191 3
a193 3
FILE	*fp;
char	*name;
point_t	pts[];
d214 4
a217 4
FILE	*fp;
char	*name;
point_t	center;
fastf_t	radius;
d219 1
a219 2
	union record rec;
	fastf_t		nrad = radius * mk_conv2mm;
d221 5
a225 4
	bzero( (char *)&rec, sizeof(rec) );
	rec.s.s_id = ID_SOLID;
	rec.s.s_type = GENELL;
	NAMEMOVE(name,rec.s.s_name);
d227 1
a227 8
	VSCALE( &rec.s.s_values[0], center, mk_conv2mm );
	VSET( &rec.s.s_values[3], nrad, 0, 0 );
	VSET( &rec.s.s_values[6], 0, nrad, 0 );
	VSET( &rec.s.s_values[9], 0, 0, nrad );

	if( fwrite( (char *) &rec, sizeof(rec), 1, fp) != 1 )
		return(-1);
	return(0);
d239 4
a242 4
FILE	*fp;
char	*name;
point_t	center;
vect_t	a, b, c;
d244 1
a244 1
	union record rec;
d246 5
a250 4
	bzero( (char *)&rec, sizeof(rec) );
	rec.s.s_id = ID_SOLID;
	rec.s.s_type = GENELL;
	NAMEMOVE(name,rec.s.s_name);
d252 1
a252 8
	VSCALE( &rec.s.s_values[0], center, mk_conv2mm );
	VSCALE( &rec.s.s_values[3], a, mk_conv2mm );
	VSCALE( &rec.s.s_values[6], b, mk_conv2mm );
	VSCALE( &rec.s.s_values[9], c, mk_conv2mm );

	if( fwrite( (char *) &rec, sizeof(rec), 1, fp) != 1 )
		return(-1);
	return(0);
d264 5
a268 5
FILE	*fp;
char	*name;
point_t	center;
vect_t	inorm;
double	r1, r2;
d288 5
a292 5
FILE	*fp;
char	*name;
point_t	base;
vect_t	height;
fastf_t	radius;
a293 1
	union record rec;
d295 1
a296 10
	bzero( (char *)&rec, sizeof(rec) );
	rec.s.s_id = ID_SOLID;
	rec.s.s_type = GENTGC;
	NAMEMOVE(name, rec.s.s_name);

	/* Units conversion */
	radius *= mk_conv2mm;
	VSCALE( F1, base, mk_conv2mm );
	VSCALE( F2, height, mk_conv2mm  );

d298 1
a298 1
	vec_ortho( cross1, height );
d302 2
a303 4
	VSCALE( F3, cross1, radius );
	VSCALE( F4, cross2, radius );
	VMOVE( F5, F3);
	VMOVE( F6, F4);
d305 1
a305 3
	if( fwrite( (char *)&rec, sizeof( rec), 1, fp) != 1 )
		return(-1);
	return(0);		/* OK */
d315 8
a322 6
FILE	*fp;
char	*name;
point_t	base;
vect_t	height;
vect_t	a, b;
vect_t	c, d;
d324 1
a324 1
	union record rec;
d326 7
a332 4
	bzero( (char *)&rec, sizeof(rec) );
	rec.s.s_id = ID_SOLID;
	rec.s.s_type = GENTGC;
	NAMEMOVE(name, rec.s.s_name);
d334 1
a334 11
	/* Really, converting from fastf_t to dbfloat_t here */
	VSCALE( F1, base, mk_conv2mm );
	VSCALE( F2, height, mk_conv2mm );
	VSCALE( F3, a, mk_conv2mm );
	VSCALE( F4, b, mk_conv2mm );
	VSCALE( F5, c, mk_conv2mm );
	VSCALE( F6, d, mk_conv2mm );

	if( fwrite( (char *)&rec, sizeof( rec), 1, fp) != 1 )
		return(-1);
	return(0);		/* OK */
a343 1

d348 2
a349 2
point_t		base;
vect_t		dirv;
a353 1

d367 1
a367 1
	vec_ortho(a, h_unitv);
d385 7
a391 7
mk_trc( fp, name, ibase, iheight, radbase, radtop )
FILE	*fp;
char	*name;
point_t	ibase;
vect_t	iheight;
fastf_t	radbase;
fastf_t	radtop;
a392 3
	point_t	base;
	vect_t	height;
	union record rec;
d394 1
a395 14
	bzero( (char *)&rec, sizeof(rec) );
	rec.s.s_id = ID_SOLID;
	rec.s.s_type = GENTGC;
	NAMEMOVE(name, rec.s.s_name);

	/* Units conversion */
	radbase *= mk_conv2mm;
	radtop *= mk_conv2mm;
	VSCALE( base, ibase, mk_conv2mm );
	VSCALE( height, iheight, mk_conv2mm );

	VMOVE( F1, base );
	VMOVE( F2, height );

d401 2
a402 2
	VSCALE( F3, cross1, radbase );
	VSCALE( F4, cross2, radbase );
d404 2
a405 2
	VSCALE( F5, cross1, radtop );
	VSCALE( F6, cross2, radtop );
d407 1
a407 3
	if( fwrite( (char *)&rec, sizeof( rec), 1, fp) != 1 )
		return(-1);
	return(0);	/* OK */
d417 6
a422 6
FILE	*fp;
char	*name;
point_t	ibase;
point_t	itop;
fastf_t	radbase;
fastf_t	radtop;
a427 85
}

/*
 *			M K _ P O L Y S O L I D
 *
 *  Make the header record for a polygon solid.
 *  Must be followed by 1 or more mk_poly() or mk_fpoly() calls
 *  before any other mk_* routines.
 */
int
mk_polysolid( fp, name )
FILE	*fp;
char	*name;
{
	union record rec;

	bzero( (char *)&rec, sizeof(rec) );
	rec.p.p_id = ID_P_HEAD;
	NAMEMOVE( name, rec.p.p_name );
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);
	return(0);
}

/*
 *			M K _ P O L Y
 *
 *  Must follow a call to mk_polysolid(), mk_poly(), or mk_fpoly().
 */
int
mk_poly( fp, npts, verts, norms )
FILE	*fp;
int	npts;
fastf_t	verts[][3];
fastf_t	norms[][3];
{
	union record rec;
	register int i,j;

	if( npts < 3 || npts > 5 )  {
		fprintf(stderr,"mk_poly:  npts=%d is bad\n", npts);
		return(-1);
	}

	bzero( (char *)&rec, sizeof(rec) );
	rec.q.q_id = ID_P_DATA;
	rec.q.q_count = npts;
	for( i=0; i<npts; i++ )  {
		for( j=0; j<3; j++ )  {
			rec.q.q_verts[i][j] = verts[i][j] * mk_conv2mm;
			rec.q.q_norms[i][j] = norms[i][j] * mk_conv2mm;
		}
	}
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1)
		return(-1);
	return(0);
}

/*
 *			M K _ F P O L Y
 *
 *  Must follow a call to mk_polysolid(), mk_poly(), or mk_fpoly().
 */
int
mk_fpoly( fp, npts, verts )
FILE	*fp;
int	npts;
fastf_t	verts[][3];
{
	int	i;
	vect_t	v1, v2, norms[5];

	if( npts < 3 || npts > 5 )  {
		fprintf(stderr,"mk_poly:  npts=%d is bad\n", npts);
		return(-1);
	}

	VSUB2( v1, verts[1], verts[0] );
	VSUB2( v2, verts[npts-1], verts[0] );
	VCROSS( norms[0], v1, v2 );
	VUNITIZE( norms[0] );
	for( i = 1; i < npts; i++ ) {
		VMOVE( norms[i], norms[0] );
	}
	return( mk_poly(fp, npts, verts, norms) );
@


9.13
log
@Converted to new LIBRT import/export interface
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.12 90/12/05 04:40:59 mike Exp $ (BRL)";
d320 1
a320 5
	union record rec;
	vect_t	norm;
	vect_t	cross1, cross2;
	double	r3, r4;
	double	m2;
d322 5
a326 4
	bzero( (char *)&rec, sizeof(rec) );
	rec.s.s_id = ID_SOLID;
	rec.s.s_type = TOR;
	NAMEMOVE(name,rec.s.s_name);
d328 1
a328 50
	/* Validate that 0 < r2 <= r1 */
	if( r2 <= 0.0 )  {
		fprintf(stderr, "mk_tor(%s):  illegal r2=%.12e <= 0\n",
			name, r2);
		return(-1);
	}
	if( r2 > r1 )  {
		fprintf(stderr, "mk_tor(%s):  illegal r2=%.12e > r1=%.12e\n",
			name, r2, r1);
		return(-1);
	}

	r1 *= mk_conv2mm;
	r2 *= mk_conv2mm;
	r3=r1-r2;	/* Radius to inner circular edge */
	r4=r1+r2;	/* Radius to outer circular edge */

	VSCALE( F1, center, mk_conv2mm );

	VMOVE( norm, inorm );
	m2 = MAGNITUDE( norm );		/* F2 is NORMAL to torus */
	if( m2 <= SQRT_SMALL_FASTF )  {
		(void)fprintf(stderr, "mk_tor(%s): normal magnitude is zero!\n", name);
		return(-1);		/* failure */
	}
	m2 = 1.0/m2;
	VSCALE( norm, norm, m2 );	/* Give normal unit length */
	VSCALE( F2, norm, r2 );		/* Give F2 normal radius length */

	/* Create two mutually perpendicular vectors, perpendicular to Norm */
	vec_ortho( cross1, norm );
	VCROSS( cross2, cross1, norm );
	VUNITIZE( cross2 );

	/* F3, F4 are perpendicular, goto center of solid part */
	VSCALE( F3, cross1, r1 );
	VSCALE( F4, cross2, r1 );

	/* The rest of these provide no real extra information */
	/* F5, F6 are perpendicular, goto inner edge of ellipse */
	VSCALE( F5, cross1, r3 );
	VSCALE( F6, cross2, r3 );

	/* F7, F8 are perpendicular, goto outer edge of ellipse */
	VSCALE( F7, cross1, r4 );
	VSCALE( F8, cross2, r4 );
	
	if( fwrite( (char *) &rec, sizeof(rec), 1, fp) != 1 )
		return(-1);	/* failure */
	return(0);		/* OK */
@


9.12
log
@Even more specific debugging
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.11 90/12/05 04:34:23 mike Exp $ (BRL)";
a35 1

d41 3
a45 7
#define PI	3.14159265358979323

#ifdef SYSV
#define bzero(str,n)		memset( str, '\0', n )
#define bcopy(from,to,count)	memcpy( to, from, count )
#endif

a57 16
/*
 *			V E C _ O R T H O
 *
 *  Lifted from librt/mat.c
 *
 *  Given a vector, create another vector which is perpendicular to it,
 *  and with unit length.  This algorithm taken from Gift's arvec.f;
 *  a faster algorithm may be possible.
 */
static void
vec_ortho( out, in )
register fastf_t *out, *in;
{
	register int j, k;
	FAST fastf_t	f;
	register int i;
a58 35
	if( NEAR_ZERO(in[X], 0.0001) && NEAR_ZERO(in[Y], 0.0001) &&
	    NEAR_ZERO(in[Z], 0.0001) )  {
		VSETALL( out, 0 );
		VPRINT("vec_ortho: zero-length input", in);
		return;
	}

	/* Find component closest to zero */
	f = fabs(in[X]);
	i = X;
	j = Y;
	k = Z;
	if( fabs(in[Y]) < f )  {
		f = fabs(in[Y]);
		i = Y;
		j = Z;
		k = X;
	}
	if( fabs(in[Z]) < f )  {
		i = Z;
		j = X;
		k = Y;
	}
	f = hypot( in[j], in[k] );
	if( NEAR_ZERO( f, SMALL ) ) {
		VPRINT("vec_ortho: zero hypot on", in);
		VSETALL( out, 0 );
		return;
	}
	f = 1.0/f;
	out[i] = 0.0;
	out[j] = -in[k]*f;
	out[k] =  in[j]*f;
}

d94 1
a94 1
	union record rec;
d96 5
a100 9
	bzero( (char *)&rec, sizeof(rec) );
	rec.s.s_id = ID_SOLID;
	rec.s.s_type = HALFSPACE;
	NAMEMOVE( name, rec.s.s_name );
	VMOVE( rec.s.s_values, norm );
	rec.s.s_values[3] = d * mk_conv2mm;
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);
	return(0);
d233 1
a233 1
	union record rec;
d235 4
a238 7
	bzero( (char *)&rec, sizeof(rec) );
	rec.s.s_id = ID_SOLID;
	rec.s.s_type = GENARB8;
	NAMEMOVE( name, rec.s.s_name );
	VSCALE( &rec.s.s_values[3*0], pts[0], mk_conv2mm );
	for( i=1; i<8; i++ )  {
		VSUB2SCALE( &rec.s.s_values[3*i], pts[i], pts[0], mk_conv2mm );
d240 2
a241 3
	if( fwrite( (char *)&rec, sizeof(rec), 1, fp ) != 1 )
		return(-1);		/* fail */
	return(0);
@


9.11
log
@Allow torus where r1 == r2
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.10 90/12/05 04:04:58 mike Exp $ (BRL)";
d396 8
a403 3
	if( r2 <= 0.0 || r2 > r1 )  {
		fprintf(stderr, "mk_tor(%s):  illegal r1=%g, r2=%g\n",
			name, r1, r2);
@


9.10
log
@Eliminated s.s_cgtype
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.9 90/11/01 05:18:31 mike Exp $ (BRL)";
d395 2
a396 1
	if( r1 <= 0 || r2 <= 0 || r1 < r2 )  {
@


9.9
log
@spelling
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.8 90/11/01 05:02:44 mike Exp $ (BRL)";
a325 1
	rec.s.s_cgtype = SPH;
a392 1
	rec.s.s_cgtype = TOR;
a459 1
	rec.s.s_cgtype = RCC;
a500 1
	rec.s.s_cgtype = TGC;
a581 1
	rec.s.s_cgtype = TRC;
@


9.8
log
@Corrected a few difficulties in mk_wedge().
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /m/cad/libwdb/RCS/wdb.c,v 9.7 90/10/18 13:46:07 sue Exp $ (BRL)";
d547 1
a547 1
	VUNITZE(h_unitv);
@


9.7
log
@Added support for two wrapper routines: a right circular cone that uses
the tgc code, and a right angular wedge that is build over top of an arb8.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 9.6 90/03/05 20:51:10 mike Exp $ (BRL)";
d218 1
d220 1
d222 1
d225 2
a226 2
	/* Make ydirv */
	VCROSS(ydirv, x_unitv, z_unitv);
d232 1
a232 1
	VSCALE(yvec, ydiv, ylen);
@


9.6
log
@Fixed some lint.
Added wrapper routine mk_trc_top().
@
text
@d21 1
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 9.5 90/02/08 01:17:52 mike Locked $ (BRL)";
d189 60
d516 44
@


9.5
log
@Replaced lots of crufty code to make perpendiculars with
stuff that is much easier to understand.
Like, modular.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 9.4 90/02/08 00:53:46 mike Locked $ (BRL)";
a172 1
	register int i;
d185 1
a185 2
	mk_arb8( fp, name, pt8 );
	return(0);
a196 1
	register int i;
a255 1
	register int i;
a288 1
	register int i;
a320 1
	register int i;
a435 1
	fastf_t m1, m2;
d462 1
a462 1
mk_trc( fp, name, ibase, iheight, radbase,radtop )
d504 20
@


9.4
log
@Added units conversion handling.
Changed calling sequence to mk_trc() to the traditional parameters.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 9.3 89/12/08 20:36:07 mike Locked $ (BRL)";
d319 1
a319 1
mk_tor( fp, name, center, norm, r1, r2 )
d323 1
a323 1
vect_t	norm;
d328 2
a329 1
	vect_t	work;
d331 1
a331 1
	double	m1, m2, m3, m4, m5, m6;
d344 1
a350 1
	VSCALE( F2, norm, mk_conv2mm );
d352 3
a354 13
	/*
	 * To allow for V being (0,0,0), for VCROSS purposes only,
	 * we add (PI,PI,PI).  THIS DOES NOT GO OUT INTO THE FILE!!
	 * work[] must NOT be colinear with N[].  We check for this
	 * later.
	 */
	VMOVE(work, center);
	work[0] += PI;
	work[1] += PI;
	work[2] += PI;

	m2 = MAGNITUDE( F2 );		/* F2 is NORMAL to torus */
	if( m2 <= 0.0 )  {
d358 3
a360 1
	VSCALE( F2, F2, r2/m2 );	/* Give it radius length */
d362 4
a365 14
	/* F3, F4 are perpendicular, goto center of Torus (solid part), for top/bottom */
	VCROSS(F3,work,F2);
	m1=MAGNITUDE(F3);
	if( m1 <= 0.0 )  {
		work[1] = 0.0;		/* Vector is colinear, so */
		work[2] = 0.0;		/* make it different */
		VCROSS(F3,work,F2);
		m1=MAGNITUDE(F3);
		if( m1 <= 0.0 )  {
			(void)fprintf(stderr, "mk_tor(%s): cross product vector is zero!\n", name);
			return(-1);	/* failure */
		}
	}
	VSCALE(F3,F3,r1/m1);
d367 3
a369 6
	VCROSS(F4,F3,F2);
	m3=MAGNITUDE(F4);
	if( m3 <= 0.0 )  {
		(void)fprintf(stderr, "mk_tor(%s): magnitude m3 is zero!\n", name);
		return(-1);	 /* failure */
	}
d371 1
a371 8
	VSCALE(F4,F4,r1/m3);
	m5 = MAGNITUDE(F3);
	m6 = MAGNITUDE( F4 );
	if( m5 <= 0.0 || m6 <= 0.0 )  {
		(void)fprintf(stderr, "mk_tor(%s): magnitude m5/m6 is zero!\n", name);
		return(-1);	/* failure */
	}

d373 2
a374 2
	VSCALE( F5, F3, r3/m5 );
	VSCALE( F6, F4, r3/m6 );
d377 2
a378 2
	VSCALE( F7, F3, r4/m5 );
	VSCALE( F8, F4, r4/m6 );
d399 1
a399 2
	fastf_t m1, m2;
	vect_t	tvec;
d407 1
d412 4
a415 23
	VSCALE( tvec, base, mk_conv2mm );
	tvec[0] += PI;
	tvec[1] += PI;
	tvec[2] += PI;
	VCROSS( F3, tvec, F2 );
	m1 = MAGNITUDE( F3 );
	if( m1 == 0.0 )  {
		tvec[1] = 0.0;		/* Vector is colinear, so */
		tvec[2] = 0.0;		/* make it different */
		VCROSS( F3, tvec, F2 );
		m1 = MAGNITUDE( F3 );
		if( m1 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
	}
	VSCALE( F3, F3, radius/m1 );
	VCROSS( F4, F2, F3 );
	m2 = MAGNITUDE( F4 );
	if( m2 == 0.0 )  {
		(void)printf("ERROR, magnitude is zero!\n");
		return(-1);	/* failure */
	}
d417 2
a418 2
	VSCALE( F4, F4, radius/m2 );

d497 1
@


9.3
log
@Fixed arg type.
@
text
@d11 5
d32 1
a32 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 9.2 89/11/27 22:44:11 mike Locked $ (BRL)";
d41 1
d62 16
d79 35
d124 1
a124 1
	static union record rec;
d149 1
a149 1
	static union record rec;
d156 1
a156 1
	rec.s.s_values[3] = d;
d232 1
a232 1
	static union record rec;
d238 1
a238 1
	VMOVE( &rec.s.s_values[3*0], pts[0] );
d240 1
a240 1
		VSUB2( &rec.s.s_values[3*i], pts[i], pts[0] );
d260 2
a261 1
	static union record rec;
d269 5
a273 5
	VMOVE( &rec.s.s_values[0], center );
	VSET( &rec.s.s_values[3], radius, 0, 0 );
	VSET( &rec.s.s_values[6], 0, radius, 0 );
	VSET( &rec.s.s_values[9], 0, 0, radius );
	
d294 1
a294 1
	static union record rec;
d301 5
a305 5
	VMOVE( &rec.s.s_values[0], center );
	VMOVE( &rec.s.s_values[3], a );
	VMOVE( &rec.s.s_values[6], b );
	VMOVE( &rec.s.s_values[9], c );
	
d327 1
a327 1
	static union record rec;
d343 2
d348 2
a349 2
	VMOVE( F1, center );
	VMOVE( F2, norm );
d425 1
a425 1
	static union record rec;
d435 5
a439 3
	VMOVE( F1, base );
	VMOVE( F2, height  );
	VMOVE( tvec, base );
d487 1
a487 1
	static union record rec;
d497 6
a502 6
	VMOVE( F1, base );
	VMOVE( F2, height );
	VMOVE( F3, a );
	VMOVE( F4, b );
	VMOVE( F5, c );
	VMOVE( F6, d );
d511 1
a511 1
 *  mk_trc( name, base, height, radius)
d515 1
a515 1
mk_trc( fp, name, base, top, radbase,radtop )
d518 2
a519 2
point_t	base;
point_t	top;
d523 1
d525 2
a526 3
	static union record rec;
	static float pi = 3.14159265358979323264;
	fastf_t m1, m2;
d534 5
a538 1
	VSUB2(height,top,base);
d541 1
a541 23
	VMOVE( F2, height  );
	base[0] += pi;
	base[1] += pi;
	base[2] += pi;
	VCROSS( F3, base, F2 );
	m1 = MAGNITUDE( F3 );
	if( m1 == 0.0 )  {
		base[1] = 0.0;		/* Vector is colinear, so */
		base[2] = 0.0;		/* make it different */
		VCROSS( F3, base, F2 );
		m1 = MAGNITUDE( F3 );
		if( m1 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
	}
	VSCALE( F3, F3, radbase/m1 );
	VCROSS( F4, F2, F3 );
	m2 = MAGNITUDE( F4 );
	if( m2 == 0.0 )  {
		(void)printf("ERROR, magnitude is zero!\n");
		return(-1);	/* failure */
	}
d543 3
a545 1
	VSCALE( F4, F4, radbase/m2 );
d547 2
a548 2
	VMOVE(F5,F3);
	VMOVE(F6,F4);
d550 2
a551 11
	m1 = MAGNITUDE( F5 );
	if( m1 == 0.0 )  {
		base[1] = 0.0;		/* Vector is colinear, so */
		base[2] = 0.0;		/* make it different */
		VCROSS( F5, F2, top );
		m1 = MAGNITUDE( F5 );
		if( m1 == 0.0 )  {
			(void)printf("ERROR, magnitude is zero!\n");
			return(-1);	/* failure */
		}
	}
a552 10
	VSCALE( F5, F5, radtop/m1 );

	m2 = MAGNITUDE( F6 );
	if( m2 == 0.0 )  {
		(void)printf("ERROR, magnitude is zero!\n");
		return(-1);	/* failure */
	}

	VSCALE( F6, F6, radtop/m2 );

d570 1
a570 1
	static union record rec;
d592 1
a592 1
	static union record rec;
d605 2
a606 2
			rec.q.q_verts[i][j] = verts[i][j];
			rec.q.q_norms[i][j] = norms[i][j];
@


9.2
log
@Now permits torus with r1 == r2.
Added error checking on fwrite().  Detects when disk space is exhausted.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 9.1 89/05/19 05:50:15 mike Locked $ (BRL)";
d89 1
a89 1
point_t	norm;
@


9.1
log
@Release_3.5
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 8.2 89/01/08 23:39:32 wm Exp $ (BRL)";
d74 2
a75 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
d100 2
a101 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
d185 2
a186 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
d216 2
a217 1
	fwrite( (char *) &rec, sizeof(rec), 1, fp);
d248 2
a249 1
	fwrite( (char *) &rec, sizeof(rec), 1, fp);
d280 1
a280 1
	if( r1 <= 0 || r2 <= 0 || r1 <= r2 )  {
d347 2
a348 1
	fwrite( (char *) &rec, sizeof(rec), 1, fp);
d406 2
a407 1
	fwrite( (char *)&rec, sizeof( rec), 1, fp);
d442 2
a443 1
	fwrite( (char *)&rec, sizeof( rec), 1, fp);
d526 2
a527 1
	fwrite( (char *)&rec, sizeof( rec), 1, fp);
d548 2
a549 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
d582 2
a583 1
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
@


8.2
log
@Added mk_trc 
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 8.1 88/10/05 00:29:02 wm Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.9 88/08/30 20:26:31 phil Exp $ (BRL)";
d437 83
@


7.9
log
@don't change the users base vector in mk_rcc
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.8 88/08/24 10:08:58 phil Locked $ (BRL)";
@


7.8
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.7 88/08/20 06:51:12 steveb Locked $ (BRL)";
d361 1
d371 5
a375 4
	base[0] += PI;
	base[1] += PI;
	base[2] += PI;
	VCROSS( F3, base, F2 );
d378 3
a380 3
		base[1] = 0.0;		/* Vector is colinear, so */
		base[2] = 0.0;		/* make it different */
		VCROSS( F3, base, F2 );
@


7.7
log
@a couple of name/parameter changes.  added mk_fpoly().
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.6 88/08/19 02:23:16 phil Locked $ (BRL)";
d370 4
a373 4
	F1[0] += PI;
	F1[1] += PI;
	F1[2] += PI;
	VCROSS( F3, F1, F2 );
d376 3
a378 3
		F1[1] = 0.0;		/* Vector is colinear, so */
		F1[2] = 0.0;		/* make it different */
		VCROSS( F3, F1, F2 );
@


7.6
log
@Protected the F* macros with parentheses.  Misc. cosmetics.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.6 88/08/18 23:30:49 phil Exp $ (BRL)";
d85 1
a85 1
mk_half( fp, name, d, norm )
d88 1
a89 1
point_t	norm;
d441 2
a442 2
 *  Must be followed by 1 or more mk_facet() calls before
 *  any other mk_* routines
d459 1
a459 1
 *			M K _ F A C E T
d461 1
a461 1
 *  Must follow a call to mk_polysolid() or mk_facet()
d464 1
a464 1
mk_facet( fp, npts, vert, norm )
d467 2
a468 2
fastf_t	vert[][3];
fastf_t	norm[][3];
d474 1
a474 1
		fprintf(stderr,"mk_facet:  npts=%d is bad\n", npts);
d483 2
a484 2
			rec.q.q_verts[i][j] = vert[i][j];
			rec.q.q_norms[i][j] = norm[i][j];
d489 29
@


7.5
log
@*** empty log message ***
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.4 88/05/13 22:47:56 mike Exp $ (BRL)";
d47 9
a55 9
#define F(i)	rec.s.s_values+(i-1)*3
#define F1	rec.s.s_values+(1-1)*3
#define F2	rec.s.s_values+(2-1)*3
#define F3	rec.s.s_values+(3-1)*3
#define F4	rec.s.s_values+(4-1)*3
#define F5	rec.s.s_values+(5-1)*3
#define F6	rec.s.s_values+(6-1)*3
#define F7	rec.s.s_values+(7-1)*3
#define F8	rec.s.s_values+(8-1)*3
d59 2
d160 1
a160 1
 *  If there are degeneracies (ie, all 8 vertices are not distinct),
d190 1
a190 1
 * Make a sphere centered at point with radius r.
d193 1
a193 1
mk_sph( fp, name, point, r)
d196 2
a197 2
point_t	point;
fastf_t	r;
d208 4
a211 4
	VMOVE( &rec.s.s_values[0], point );
	VSET( &rec.s.s_values[3], r, 0, 0 );
	VSET( &rec.s.s_values[6], 0, r, 0 );
	VSET( &rec.s.s_values[9], 0, 0, r );
d220 3
a222 3
 * Make an ellipsoid centered at point with 3 perp. radius vectors.
 * The eccentricity of the ellipsoid is controlled by the relative
 * lengths of the three radius vectors.
d225 1
a225 1
mk_ell( fp, name, point, a, b, c)
d228 1
a228 1
point_t	point;
d239 1
a239 1
	VMOVE( &rec.s.s_values[0], point );
d251 3
a253 3
 * Make a torus.  Specify center, normal,
 * r1:  distance from center point to center of solid part,
 * and r2: radius of solid part.
d256 1
a256 1
mk_tor( fp, name, center, n, r1, r2 )
d260 1
a260 1
vect_t	n;
d284 1
a284 1
	VMOVE( F2, n );
d349 1
a349 1
 * Make a Right Circular Cylinder into a generalized truncated cyinder
d405 1
a405 1
 * Make truncated general cylinder
d408 1
a408 1
mk_tgc( fp, name, v, h, a, b, c, d )
d411 2
a412 2
point_t	v;
vect_t	h;
d426 2
a427 2
	VMOVE( F1, v );
	VMOVE( F2, h );
@


7.4
log
@lint fixes
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.3 87/12/31 03:41:14 mike Locked $ (BRL)";
d368 4
a371 4
	base[0] += PI;
	base[1] += PI;
	base[2] += PI;
	VCROSS( F3, base, F2 );
d374 3
a376 3
		base[1] = 0.0;		/* Vector is colinear, so */
		base[2] = 0.0;		/* make it different */
		VCROSS( F3, base, F2 );
@


7.3
log
@Added mk_tgc()
@
text
@d11 2
d27 1
a27 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 7.1 87/11/02 23:29:01 mike Rel $ (BRL)";
d60 1
d73 1
d82 1
d98 1
d106 1
d126 1
d132 1
d151 1
a151 1
	mk_arb8( fp, name, pt8 );
d164 1
d182 1
d190 1
d212 1
d222 1
d243 1
d253 1
d349 1
d405 1
d442 1
d453 1
d461 1
@


7.2
log
@Spline wdb.c into wdb.c and reg.c
@
text
@a327 1

d378 34
@


7.1
log
@Release 2.3
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 1.8 87/10/27 21:14:27 mike Exp $ (BRL)";
a381 84
}

/*
 *			M K _ M C O M B
 *
 *  Make a combination with material properties info
 */
mk_mcomb( fp, name, len, region, matname, matparm, override, rgb )
FILE	*fp;
char	*name;
char	*matname;
char	*matparm;
char	*rgb;
{
	static union record rec;

	bzero( (char *)&rec, sizeof(rec) );
	rec.c.c_id = ID_COMB;
	if( region )
		rec.c.c_flags = 'R';
	else
		rec.c.c_flags = ' ';
	NAMEMOVE( name, rec.c.c_name );
	rec.c.c_length = len;
	if( matname ) {
		strncpy( rec.c.c_matname, matname, sizeof(rec.c.c_matname) );
		if( matparm )
			strncpy( rec.c.c_matparm, matparm,
				sizeof(rec.c.c_matparm) );
	}
	if( override )  {
		rec.c.c_override = 1;
		rec.c.c_rgb[0] = rgb[0];
		rec.c.c_rgb[1] = rgb[1];
		rec.c.c_rgb[2] = rgb[2];
	}
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
}


/*
 *			M K _ C O M B
 *
 *  Make a simple combination header.
 * Must be followed by 'len' mk_memb() calls before any other mk_* routines
 */
mk_comb( fp, name, len, region )
FILE	*fp;
char	*name;
{
	static union record rec;

	bzero( (char *)&rec, sizeof(rec) );
	rec.c.c_id = ID_COMB;
	if( region )
		rec.c.c_flags = 'R';
	else
		rec.c.c_flags = ' ';
	NAMEMOVE( name, rec.c.c_name );
	rec.c.c_length = len;
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
}

/*
 *			M K _ M E M B
 *
 *  Must be part of combination/member clump of records.
 */
mk_memb( fp, name, mat, op )
FILE	*fp;
char	*name;
mat_t	mat;
int	op;
{
	static union record rec;
	register int i;

	bzero( (char *)&rec, sizeof(rec) );
	rec.M.m_id = ID_MEMB;
	rec.M.m_relation = op;
	NAMEMOVE( name, rec.M.m_instname );
	for( i=0; i<16; i++ )
		rec.M.m_mat[i] = mat[i];
	fwrite( (char *)&rec, sizeof(rec), 1, fp );
@


1.8
log
@Added missing return() statements.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 1.7 87/10/13 22:30:10 mike Locked $ (BRL)";
@


1.7
log
@Neatened several comments.
@
text
@d25 1
a25 1
static char RCSid[] = "@@(#)$Header: wdb.c,v 1.6 87/09/26 08:05:14 mike Locked $ (BRL)";
d325 1
d381 1
@


1.6
log
@Added mk_torus
@
text
@d2 1
a2 1
 *			L I B W D B . C
d4 3
a6 1
 * Library for writing databases.
d8 3
d21 1
a21 1
 *	This software is Copyright (C) 1986 by the United States Army.
d25 1
a25 1
static char RCSid[] = "@@(#)$Header: libwdb.c,v 1.5 87/09/25 23:18:37 mike Exp $ (BRL)";
d148 1
a178 1

d206 2
d329 2
a330 1
 * mk_rcc( name, base, height, radius)
@


1.5
log
@Made mk_sph take a center point, rather than x,y,z.
Changed args to mk_memb to be consistent with other routines.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: libwdb.c,v 1.4 87/09/20 12:11:08 mike Locked $ (BRL)";
d30 2
d38 13
d197 13
d211 13
d225 5
a229 1
 * Input Vector Fields
d231 12
a242 9
#define Fi	rec.s.s_values+(i-1)*3
#define F1	rec.s.s_values+(1-1)*3
#define F2	rec.s.s_values+(2-1)*3
#define F3	rec.s.s_values+(3-1)*3
#define F4	rec.s.s_values+(4-1)*3
#define F5	rec.s.s_values+(5-1)*3
#define F6	rec.s.s_values+(6-1)*3
#define F7	rec.s.s_values+(7-1)*3
#define F8	rec.s.s_values+(8-1)*3
d244 77
a332 1
	static float pi = 3.14159265358979323264;
d343 3
a345 3
	base[0] += pi;
	base[1] += pi;
	base[2] += pi;
@


1.4
log
@Added routine for halfspace.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: libwdb.c,v 1.2 87/09/16 23:00:17 mike Locked $ (BRL)";
d156 1
a156 1
 * Make a sphere centered at sx, sy, sz with radius r.
d159 1
a159 1
mk_sph( fp, name, sx, sy, sz, r)
d162 2
a163 1
fastf_t	sx, sy, sz, r;
d174 1
a174 1
	VSET( &rec.s.s_values[0], sx, sy, sz);
d316 1
a316 1
mk_memb( fp, op, name, mat )
a317 1
int	op;
d320 1
@


1.3
log
@Added RPP, and polygon routines.
@
text
@d53 23
@


1.2
log
@Updated to include stdio FILE pointer as first arg to
all mk_*() routines.
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header: libwdb.c,v 1.1 87/01/12 14:43:46 mike Locked $ (BRL)";
d53 26
d308 51
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d38 3
a40 2
mk_id( title )
char *title;
d44 1
d49 1
a49 1
	fwrite( (char *)&rec, sizeof(rec), 1, stdout );
d53 1
a53 1
 *			M K _ A R B
d55 4
a58 4
mk_arb( name, pts, npts )
char *name;
point_t pts[];
int npts;
d61 30
d98 1
a98 1
	for( i=1; i<npts; i++ )  {
d101 1
a101 4
	for( ; i<8; i++ )  {
		VSET( &rec.s.s_values[3*i], 0, 0, 0 );
	}
	fwrite( (char *)&rec, sizeof(rec), 1, stdout );
d110 4
a113 3
mk_sph(name,  sx, sy, sz, r)
char * name;
fastf_t sx, sy, sz, r;
a117 1
#ifdef BSD
a118 2
#endif

d129 1
a129 1
	fwrite( (char *) &rec, sizeof(rec), 1, stdout);
d150 6
a155 7


mk_rcc( name, base, height, radius )
char * name;
point_t base;
vect_t height;
fastf_t radius;
a160 1
#ifdef BSD
a161 3
#endif


d197 1
a197 1
	fwrite( (char *)&rec, sizeof( rec), 1, stdout);
d205 6
a210 5
mk_mcomb( name, len, region, matname, matparm, override, rgb )
char *name;
char *matname;
char *matparm;
char *rgb;
d234 1
a234 1
	fwrite( (char *)&rec, sizeof(rec), 1, stdout );
d244 3
a246 2
mk_comb( name, len, region )
char *name;
d258 1
a258 1
	fwrite( (char *)&rec, sizeof(rec), 1, stdout );
d266 5
a270 4
mk_memb( op, name, mat )
int op;
char *name;
mat_t mat;
d275 1
d281 1
a281 1
	fwrite( (char *)&rec, sizeof(rec), 1, stdout );
@
