head	11.9;
access;
symbols
	rel-4-5:11.8
	ctj-4-5-post:11.8
	ctj-4-5-pre:11.8
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.9
date	98.12.30.04.24.10;	author mike;	state dead;
branches;
next	11.8;

11.8
date	96.08.27.07.10.51;	author mike;	state Exp;
branches;
next	11.7;

11.7
date	95.09.20.16.01.25;	author pjt;	state Exp;
branches;
next	11.6;

11.6
date	95.09.20.12.34.44;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	95.09.18.17.33.57;	author pjt;	state Exp;
branches;
next	11.4;

11.4
date	95.07.10.20.17.51;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.07.07.15.27.21;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.04.19.19.03.36;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.05.53;	author mike;	state Rel4_4;
branches;
next	2.6;

2.6
date	94.12.30.16.41.04;	author stay;	state Exp;
branches;
next	2.5;

2.5
date	94.11.01.10.44.22;	author pjt;	state Exp;
branches;
next	2.4;

2.4
date	94.09.26.12.21.10;	author jra;	state Exp;
branches;
next	2.3;

2.3
date	94.09.22.15.34.43;	author pjt;	state Exp;
branches;
next	2.2;

2.2
date	94.09.22.15.26.59;	author pjt;	state Exp;
branches;
next	2.1;

2.1
date	93.03.25.11.03.15;	author pjt;	state Exp;
branches;
next	1.9;

1.9
date	93.03.25.11.00.21;	author pjt;	state Exp;
branches;
next	1.8;

1.8
date	93.01.21.14.30.35;	author pjt;	state zero_1;
branches;
next	1.7;

1.7
date	93.01.15.14.31.19;	author pjt;	state Exp;
branches;
next	1.6;

1.6
date	93.01.15.13.08.50;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	93.01.15.10.46.17;	author pjt;	state zero_0;
branches;
next	1.4;

1.4
date	93.01.14.15.07.56;	author pjt;	state Exp;
branches;
next	1.3;

1.3
date	93.01.14.10.57.51;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	93.01.14.09.33.35;	author pjt;	state Exp;
branches;
next	1.1;

1.1
date	92.11.06.13.53.22;	author pjt;	state Exp;
branches;
next	;


desc
@
     Diagnostic routines for red-black trees

@


11.9
log
@All moved to libbu
@
text
@/*		R B _ D I A G N O S T I C S . C
 *
 *	Diagnostic routines for red-black tree maintenance
 *
 *	Author:	Paul Tanenbaum
 *
 */
#ifndef lint
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libredblack/rb_diag.c,v 11.8 1996/08/27 07:10:51 mike Exp mike $";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "rtlist.h"
#include "bu.h"
#include "compat4.h"
#include "redblack.h"
#include "./rb_internals.h"

static int d_order;	/* Used by describe_node() */

/*		    D E S C R I B E _ N O D E ( )
 *
 *		Print out the contents of a red-black node
 *
 *	This function has two parameters:  the node to describe and
 *	its depth in the tree.  Describe_node() is intended to be
 *	called by rb_diagnose_tree().
 */
static void describe_node (node, depth)

struct rb_node	*node;
int		depth;

{
    rb_tree		*tree;
    struct rb_package	*package;
    void		(*pp)();	/* Pretty print function */

    RB_CKMAG(node, RB_NODE_MAGIC, "red-black node");
    tree = node -> rbn_tree;
    RB_CKORDER(tree, d_order);

    package = (node -> rbn_package)[d_order];
    pp = tree -> rbt_print;

    rt_log("%*snode <%x>...\n", depth * 2, "", node);
    rt_log("%*s  tree:   <%x>\n", depth * 2, "", node -> rbn_tree);
    rt_log("%*s  parent: <%x>\n", depth * 2, "", rb_parent(node, d_order));
    rt_log("%*s  left:   <%x>\n", depth * 2, "", rb_left_child(node, d_order));
    rt_log("%*s  right:  <%x>\n", depth * 2, "", rb_right_child(node, d_order));
    rt_log("%*s  color:  %s\n",
	    depth * 2, "",
	    (rb_get_color(node, d_order) == RB_RED) ? "RED" :
	    (rb_get_color(node, d_order) == RB_BLACK) ? "BLACK" : "Huhh?");
    rt_log("%*s  package: <%x> ", depth * 2, "", package);

    if ((pp != 0) && (package != RB_PKG_NULL))
	(*pp)(package -> rbp_data);
    else
	rt_log("\n");
}

/*		    R B _ D I A G N O S E _ T R E E ( )
 *
 *	    Produce a diagnostic printout of a red-black tree
 *
 *	This function has three parameters: the root and order of the tree
 *	to print out and the type of traversal (preorder, inorder, or
 *	postorder).
 */
void rb_diagnose_tree (tree, order, trav_type)

rb_tree	*tree;
int	order;
int	trav_type;

{
    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);

    rt_log("-------- Red-black tree <%x> contents --------\n", tree);
    rt_log("Description: '%s'\n", tree -> rbt_description);
    rt_log("Order:       %d of %d\n", order, tree -> rbt_nm_orders);
    rt_log("Current:     <%x>\n", tree -> rbt_current);
    rt_log("Empty node:  <%x>\n", tree -> rbt_empty_node);
    rt_log("Uniqueness:  %d\n", rb_get_uniqueness(tree, order));
    d_order = order;
    _rb_walk(tree, order, describe_node, WALK_NODES, trav_type);
    rt_log("--------------------------------------------------\n");
}

/*		R B _ S U M M A R I Z E _ T R E E ( )
 *
 *		    Describe a red-black tree
 *
 *	This function has one parameter: a pointer to a red-black
 *	tree.  rb_summarize_tree() prints out the header information
 *	for the tree.  It is intended for diagnostic purposes.
 */
void rb_summarize_tree (tree)

rb_tree	*tree;

{
    int		i;

    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");

    rt_log("-------- Red-black tree <%x> summary --------\n", tree);
    rt_log("Description:      '%s'\n", tree -> rbt_description);
    rt_log("Current:          <%x>\n", tree -> rbt_current);
    rt_log("Empty node:       <%x>\n", tree -> rbt_empty_node);
    rt_log("Size (in nodes):  %d\n", tree -> rbt_nm_nodes);
    rt_log("Number of orders: %d\n", tree -> rbt_nm_orders);
    rt_log("Debug bits:       <%x>\n", tree -> rbt_debug);
    if ((tree -> rbt_nm_orders > 0) && (tree -> rbt_nm_nodes > 0))
    {
	rt_log("i    Order[i]   Uniq[i]  Root[i]      Package[i]     Data[i]\n");
	for (i = 0; i < tree -> rbt_nm_orders; ++i)
	{
	    rt_log("%-3d  <%x>    %c      <%x>    <%x>    <%x>\n",
		    i,
		    rb_order_func(tree, i),
		    rb_get_uniqueness(tree, i) ? 'Y' : 'N',
		    rb_root(tree, i),
		    (rb_root(tree, i) == RB_NODE_NULL) ? 0 :
			(rb_root(tree, i) -> rbn_package)[i],
		    (rb_root(tree, i) == RB_NODE_NULL) ? 0 :
			rb_data(rb_root(tree, i), i));
	}
    }
    rt_log("-------------------------------------------------\n");
}
@


11.8
log
@Changed over to bu.h
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 11.7 1995/09/20 16:01:25 pjt Exp pjt $";
@


11.7
log
@1. Shuffled entries in rb_diagnose_tree()
2. Added guard to rb_summarize_tree() so the order info is not
   tabulated if the tree is empty
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 11.6 1995/09/20 12:34:44 pjt Exp pjt $";
d18 2
@


11.6
log
@Tweeked a comment
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 11.5 1995/09/18 17:33:57 pjt Exp pjt $";
a85 1
    rt_log("Uniqueness:  %d\n", rb_get_uniqueness(tree, order));
d88 1
d115 4
a118 4
    rt_log("Size (in nodes):  <%x>\n", tree -> rbt_nm_nodes);
    if (tree -> rbt_nm_orders <= 0)
	rt_log("No orders\n");
    else
@


11.5
log
@Minor nits
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 11.4 1995/07/10 20:17:51 pjt Exp pjt $";
d99 1
a99 1
 *	tree.  Rb_summarize_tree() prints out the header information
@


11.4
log
@Must now include rtlist.h before redblack.h
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 11.3 1995/07/07 15:27:21 pjt Exp $";
d99 1
a99 1
 *	tree.  Rb_describe() prints out the header information
d120 1
a120 1
	rt_log("i    Order[i]   Uniq[i]  Root[i]       Package[i]    Data[i]\n");
d123 1
a123 1
	    rt_log("%-3d  <%x>    %c    <%x>    <%x>    <%x>\n",
@


11.3
log
@Removed a dead branch of code
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 11.2 1995/04/19 19:03:36 pjt Exp $";
d17 1
@


11.2
log
@Added support for rbt_unique member.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 11.1 95/01/04 10:05:53 mike Rel4_4 $";
a46 1
#if 1
d57 1
a57 3
#else
    rt_log("%*s", depth * 8, "");
#endif
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 2.6 94/12/30 16:41:04 stay Exp $";
d16 1
d88 1
d119 1
a119 1
	fputs("No orders\n", stderr);
d122 1
a122 1
	rt_log("i    Order[i]     Root[i]       Package[i]    Data[i]\n");
d125 1
a125 1
	    rt_log("%-3d  <%x>    <%x>    <%x>    <%x>\n",
d128 1
@


2.6
log
@deleted reference to stdlib, it wil be included in conf.h if
it exists or is STDC
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diag.c,v 2.5 1994/11/01 10:44:22 pjt Exp stay $";
@


2.5
log
@Added rbt_nm_nodes to rb_tree
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diagnostics.c,v 2.4 1994/09/26 12:21:10 jra Exp $";
a13 1
#include <stdlib.h>
@


2.4
log
@Added #include "conf.h"
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diagnostics.c,v 2.3 94/09/22 15:34:43 pjt Exp Locker: jra $";
d113 4
a116 3
    rt_log("Description: '%s'\n", tree -> rbt_description);
    rt_log("Current:     <%x>\n", tree -> rbt_current);
    rt_log("Empty node:  <%x>\n", tree -> rbt_empty_node);
@


2.3
log
@Changed "#include "rt_internals.h" to "#include "./rt_internals.h"
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diagnostics.c,v 2.2 94/09/22 15:26:59 pjt Exp Locker: pjt $";
d11 2
@


2.2
log
@Replaced prototype-type definition with K&R type
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diagnostics.c,v 2.1 93/03/25 11:03:15 pjt Exp $";
d16 1
a16 1
#include "rb_internals.h"
@


2.1
log
@Installed into BRL CAD tree
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diagnostics.c,v 1.9 93/03/25 11:00:21 pjt Exp Locker: pjt $";
d28 5
a32 1
static void describe_node (struct rb_node *node, int depth)
d73 6
a78 1
void rb_diagnose_tree (rb_tree *tree, int order, int trav_type)
d101 4
a104 1
void rb_summarize_tree (rb_tree *tree)
@


1.9
log
@Added authorship comment
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_diagnostics.c,v 1.8 93/01/21 14:30:35 pjt zero_1 Locker: pjt $";
@


1.8
log
@More careful check of colors in describe_node()
@
text
@d5 2
d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_diagnostics.c,v 1.7 93/01/15 14:31:19 pjt Exp Locker: pjt $";
@


1.7
log
@Added parameter trav_type to rb_diagnose_tree()
@
text
@d7 1
a7 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_diagnostics.c,v 1.6 93/01/15 13:08:50 pjt Exp Locker: pjt $";
d46 3
a48 2
	    depth * 2, "", (rb_get_color(node, d_order) == RB_RED) ? "RED"
								   : "BLACK");
@


1.6
log
@1. Switched from fprintf(stderr, ) to rt_log()
2. Added comments and general clean up
@
text
@d7 1
a7 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_diagnostics.c,v 1.5 93/01/15 10:46:17 pjt Exp Locker: pjt $";
d60 1
a60 1
 *	Produce an inorder diagnostic printout of a red-black tree
d62 3
a64 2
 *	This function has two parameters: the root and order of the tree
 *	to print out.
d66 1
a66 1
void rb_diagnose_tree (rb_tree *tree, int order)
d77 1
a77 1
    _rb_walk(tree, order, describe_node, WALK_NODES, INORDER);
@


1.5
log
@Canned internal_walk().  Replaced calls to it by calls to _rb_walk()
@
text
@d3 1
a3 1
 *	Written by:	Paul Tanenbaum
d7 1
a7 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_diagnostics.c,v 1.4 93/01/14 15:07:56 pjt Exp Locker: pjt $";
d22 3
a24 2
 *	This function has one parameter:  the node to describe.
 *	Describe_node() is intended to be called by rb_diagnose_tree().
d39 10
a48 17
#if 0
    fprintf(stderr, "%*snode <%x>...\n",
			depth * 2, "", node);
    fprintf(stderr, "%*s  tree:   <%x>\n",
			depth * 2, "", node -> rbn_tree);
    fprintf(stderr, "%*s  parent: <%x>\n",
			depth * 2, "", rb_parent(node, d_order));
    fprintf(stderr, "%*s  left:   <%x>\n",
			depth * 2, "", rb_left_child(node, d_order));
    fprintf(stderr, "%*s  right:  <%x>\n",
			depth * 2, "", rb_right_child(node, d_order));
    fprintf(stderr, "%*s  color:  %s\n",
			depth * 2, "",
			(rb_get_color(node, d_order) == RB_RED) ? "RED"
							      : "BLACK");
    fprintf(stderr, "%*s  package: <%x> ",
			depth * 2, "", package);
d50 1
a50 1
    fprintf(stderr, "%*s", depth * 8, "");
d55 1
a55 1
	fprintf(stderr, "\n");
d70 5
a74 8
    fprintf(stderr, "-------- Red-black tree <%x> contents --------\n", tree);
    fprintf(stderr, "Description: '%s'\n", tree -> rbt_description);
    fprintf(stderr, "Order:       %d of %d\n", order, tree -> rbt_nm_orders);
    fprintf(stderr, "Current:     <%x>\n", tree -> rbt_current);
    fprintf(stderr, "Empty node:  <%x>\n", tree -> rbt_empty_node);
    if (rb_root(tree, order) == rb_null(tree))
	fprintf(stderr, "Empty tree!  %x %x\n",
	    rb_root(tree, order), rb_null(tree));
d77 1
a77 1
    fprintf(stderr, "--------------------------------------------------\n");
d94 4
a97 4
    fprintf(stderr, "-------- Red-black tree <%x> summary --------\n", tree);
    fprintf(stderr, "Description: '%s'\n", tree -> rbt_description);
    fprintf(stderr, "Current:     <%x>\n", tree -> rbt_current);
    fprintf(stderr, "Empty node:  <%x>\n", tree -> rbt_empty_node);
d102 1
a102 2
	fprintf(stderr,
	    "i    Order[i]     Root[i]       Package[i]    Data[i]\n");
d105 1
a105 1
	    fprintf(stderr, "%-3d  <%x>    <%x>    <%x>    <%x>\n",
d115 1
a115 1
    fprintf(stderr, "-------------------------------------------------\n");
@


1.4
log
@1. Added package info to output of describe_node() and rb_summarize_tree()
2. Took advantage of rbt_print in describe_node()
@
text
@a4 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_diagnostics.c,v 1.3 93/01/14 10:57:51 pjt Exp Locker: pjt $
d6 3
d16 2
d22 1
a22 2
 *	This function has three parameters:  the node to describe,
 *	its depth from an ancestor, and the order to describe.
d25 1
a25 1
static void describe_node (struct rb_node *node, int depth, int order)
d33 1
a33 1
    RB_CKORDER(tree, order);
d35 1
a35 1
    package = (node -> rbn_package)[order];
d38 1
d44 1
a44 1
			depth * 2, "", rb_parent(node, order));
d46 1
a46 1
			depth * 2, "", rb_left_child(node, order));
d48 1
a48 1
			depth * 2, "", rb_right_child(node, order));
d51 1
a51 1
			(rb_get_color(node, order) == RB_RED) ? "RED"
d55 3
a63 25
/*		    I N T E R N A L _ W A L K ( )
 *
 *	    Perform an inorder tree walk on a red-black tree
 *
 *	This function has four parameters: the root of the tree
 *	to traverse, the depth of this root from the ancestor at
 *	which we began, the order on which to do the walking, and the
 *	function to apply to each node.  Internal_walk() is entirely
 *	analogous to _rb_walk(), except that instead of visiting
 *	rbn_data in each node, it visits the node itself.
 */
static void internal_walk (struct rb_node *root, int depth,
			   int order, void (*visit)())
{

    RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(root -> rbn_tree, order);

    if (root == rb_null(root -> rbn_tree))
	return;
    visit(root, depth, order);
    internal_walk (rb_left_child(root, order), depth + 1, order, visit);
    internal_walk (rb_right_child(root, order), depth + 1, order, visit);
}

d84 2
a85 1
    internal_walk(rb_root(tree, order), 0, order, describe_node);
@


1.3
log
@Added calls to RB_CKORDER()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_diagnostics.c,v 1.2 93/01/14 09:33:35 pjt Exp Locker: pjt $
d24 4
d29 2
a30 1
    RB_CKORDER(node -> rbn_tree, order);
d32 3
d49 6
a54 2
    fprintf(stderr, "%*s  data:   <%x>\n",
			depth * 2, "", rb_data(node, order));
d97 2
a101 3
    else
	fprintf(stderr, "Non-empty tree!  %x %x\n",
	    rb_root(tree, order), rb_null(tree));
d122 1
d128 2
a129 1
	fprintf(stderr, "i    Order[i]     Root[i]       Data[i]\n");
d132 1
a132 1
	    fprintf(stderr, "%-3d  <%x>    <%x>    <%x>\n",
d137 3
a139 1
			rb_root(tree, i) -> rbn_data[i]);
@


1.2
log
@1. Use rb_null() and rb_data()
2. Improved legibility and organization of printout
   from rb_summarize_tree()
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_diagnostics.c,v 1.1 92/11/06 13:53:22 pjt Exp Locker: pjt $
d25 2
a59 1
    /* Check data type of the parameter "root" */
d61 2
d81 1
d108 1
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_walk.c,v 1.2 92/11/05 11:32:43 pjt Exp Locker: pjt $
d40 1
a40 1
			depth * 2, "", node -> rbn_data);
d59 6
a64 7
    if (root != 0)
    {
	RB_CKMAG(root, RB_NODE_MAGIC, "red-black node");
	visit(root, depth, order);
	internal_walk (rb_left_child(root, order), depth + 1, order, visit);
	internal_walk (rb_right_child(root, order), depth + 1, order, visit);
    }
d81 6
d106 1
d110 2
d114 6
a119 7
	    fprintf(stderr,
		    "Order[%d]:   <%x>\n", i, rb_order_func(tree, i));
	    fprintf(stderr,
		    "Root[%d]:    <%x>\n", i, rb_root(tree, i));
	    if (rb_root(tree, 0) != RB_NODE_NULL)
		fprintf(stderr,
		    "Data[%d]:    <%x>\n", i, rb_root(tree, i) -> rbn_data);
d121 1
@
