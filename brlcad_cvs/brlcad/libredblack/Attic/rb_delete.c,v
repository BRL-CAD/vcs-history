head	11.7;
access;
symbols
	rel-4-5:11.6
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.1;
locks; strict;
comment	@ * @;


11.7
date	98.12.30.04.24.10;	author mike;	state dead;
branches;
next	11.6;

11.6
date	96.11.27.17.43.48;	author pjt;	state Exp;
branches;
next	11.5;

11.5
date	96.08.31.09.39.29;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	95.09.20.16.03.43;	author pjt;	state Exp;
branches;
next	11.3;

11.3
date	95.07.10.20.18.18;	author pjt;	state Exp;
branches;
next	11.2;

11.2
date	95.07.07.15.25.26;	author pjt;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.05.53;	author mike;	state Rel4_4;
branches;
next	2.6;

2.6
date	94.12.30.16.41.04;	author stay;	state Exp;
branches;
next	2.5;

2.5
date	94.11.01.10.44.19;	author pjt;	state Exp;
branches;
next	2.4;

2.4
date	94.09.26.12.21.10;	author jra;	state Exp;
branches;
next	2.3;

2.3
date	94.09.22.15.34.39;	author pjt;	state Exp;
branches;
next	2.2;

2.2
date	94.09.22.15.26.57;	author pjt;	state Exp;
branches;
next	2.1;

2.1
date	93.03.25.11.03.11;	author pjt;	state Exp;
branches;
next	1.5;

1.5
date	93.03.25.11.00.20;	author pjt;	state Exp;
branches;
next	1.4;

1.4
date	93.01.21.14.31.31;	author pjt;	state zero_1;
branches;
next	1.3;

1.3
date	93.01.15.13.07.56;	author pjt;	state Exp;
branches;
next	1.2;

1.2
date	93.01.15.10.45.06;	author pjt;	state zero_0;
branches;
next	1.1;

1.1
date	93.01.14.15.00.03;	author pjt;	state Exp;
branches;
next	;


desc
@
     Routines to delete a node from a red-black tree

@


11.7
log
@All moved to libbu
@
text
@/*			R B _ D E L E T E . C
 *
 *	    Routines to delete a node from a red-black tree
 *
 *	Author:	Paul Tanenbaum
 *
 */
#ifndef lint
static char RCSid[] = "@@(#) $Header: /c/CVS/brlcad/libredblack/rb_delete.c,v 11.6 1996/11/27 17:43:48 pjt Exp mike $";
#endif

#include "conf.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "redblack.h"
#include "./rb_internals.h"

/*			R B _ F I X U P ( )
 *
 *	    Restore the red-black properties of a red-black tree
 *		    after the splicing out of a node
 *
 *	This function has three parameters: the tree to be fixed up,
 *	the node where the trouble occurs, and the order.  rb_fixup()
 *	is an implementation of the routine RB-DELETE-FIXUP on p. 274
 *	of Cormen et al.
 */
static void rb_fixup (tree, node, order)

rb_tree		*tree;
struct rb_node	*node;
int		order;

{
    int			direction;
    struct rb_node	*parent;
    struct rb_node	*w;

    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKMAG(node, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(tree, order);

    while ((node != rb_root(tree, order))
        && (rb_get_color(node, order) == RB_BLACK))
    {
	parent = rb_parent(node, order);
	if (node == rb_left_child(parent, order))
	    direction = RB_LEFT;
	else
	    direction = RB_RIGHT;

	w = rb_other_child(parent, order, direction);
	if (rb_get_color(w, order) == RB_RED)
	{
	    rb_set_color(w, order, RB_BLACK);
	    rb_set_color(parent, order, RB_RED);
	    rb_rotate(parent, order, direction);
	    w = rb_other_child(parent, order, direction);
	}
	if ((rb_get_color(rb_child(w, order, direction), order) == RB_BLACK)
	 && (rb_get_color(rb_other_child(w, order, direction), order)
		 == RB_BLACK))
	{
	    rb_set_color(w, order, RB_RED);
	    node = parent;
	}
	else
	{
	    if (rb_get_color(rb_other_child(w, order, direction), order)
		    == RB_BLACK)
	    {
		rb_set_color(rb_child(w, order, direction), order, RB_BLACK);
		rb_set_color(w, order, RB_RED);
		rb_other_rotate(w, order, direction);
		w = rb_other_child(parent, order, direction);
	    }
	    rb_set_color(w, order, rb_get_color(parent, order));
	    rb_set_color(parent, order, RB_BLACK);
	    rb_set_color(rb_other_child(w, order, direction), order, RB_BLACK);
	    rb_rotate(parent, order, direction);
	    node = rb_root(tree, order);
	}
    }
    rb_set_color(node, order, RB_BLACK);
}

/*		        _ R B _ D E L E T E ( )
 *
 *	        Delete a node from one order of a red-black tree
 *
 *	This function has three parameters: a tree, the node to delete,
 *	and the order from which to delete it.  _rb_delete() is an
 *	implementation of the routine RB-DELETE on p. 273 of Cormen et al.
 */
static void _rb_delete (tree, node, order)

rb_tree		*tree;
struct rb_node	*node;
int		order;

{
    struct rb_node	*y;		/* The node to splice out */
    struct rb_node	*parent;
    struct rb_node	*only_child;

    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKMAG(node, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(tree, order);

    if (tree -> rbt_debug & RB_DEBUG_DELETE)
	bu_log("_rb_delete(%x,%x,%d): data=x%x\n",
	    tree, node, order, rb_data(node, order));

    if ((rb_left_child(node, order) == rb_null(tree))
     || (rb_right_child(node, order) == rb_null(tree)))
	y = node;
    else
	y = _rb_neighbor(node, order, SENSE_MAX);
    
    if (rb_left_child(y, order) == rb_null(tree))
	only_child = rb_right_child(y, order);
    else
	only_child = rb_left_child(y, order);
    
    parent = rb_parent(only_child, order) = rb_parent(y, order);
    if (parent == rb_null(tree))
	rb_root(tree, order) = only_child;
    else if (y == rb_left_child(parent, order))
	rb_left_child(parent, order) = only_child;
    else
	rb_right_child(parent, order) = only_child;
    
    /*
     *	Splice y out if it's not node
     */
    if (y != node)
    {
	(node -> rbn_package)[order] = (y -> rbn_package)[order];
	((node -> rbn_package)[order] -> rbp_node)[order] = node;
    }
    
    if (rb_get_color(y, order) == RB_BLACK)
	rb_fixup(tree, only_child, order);

    if (--(y -> rbn_pkg_refs) == 0)
	rb_free_node(y);
}

/*		        R B _ D E L E T E ( )
 *
 *	        Applications interface to _rb_delete()
 *
 *	This function has two parameters: the tree and order from which
 *	to do the deleting.  rb_delete() removes the data block stored
 *	in the current node (in the position of the specified order)
 *	from every order in the tree.
 */
void rb_delete (tree, order)

rb_tree	*tree;
int	order;

{
    int			nm_orders;
    struct rb_node	**node;		/* Nodes containing data */
    struct rb_package	*package;

    RB_CKMAG(tree, RB_TREE_MAGIC, "red-black tree");
    RB_CKORDER(tree, order);

    if (tree -> rbt_nm_nodes <= 0)
    {
	bu_log("Error: Attempt to delete from tree with %d nodes\n",
		tree -> rbt_nm_nodes);
	exit (0);
    }
    if (rb_current(tree) == rb_null(tree))
    {
	bu_log("Warning: rb_delete(): current node is undefined\n");
	return;
    }

    nm_orders = tree -> rbt_nm_orders;
    package = (rb_current(tree) -> rbn_package)[order];

    node = (struct rb_node **)
	    bu_malloc(nm_orders * sizeof(struct rb_node *), "node list");
	
    for (order = 0; order < nm_orders; ++order)
	node[order] = (package -> rbp_node)[order];

    /*
     *	Do the deletion from each order
     */
    for (order = 0; order < nm_orders; ++order)
	_rb_delete(tree, node[order], order);

    --(tree -> rbt_nm_nodes);
    rb_free_package(package);
    bu_free((genptr_t) node, "node list");
}
@


11.6
log
@Added debug print controlled by rbt_debug
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 11.5 1996/08/31 09:39:29 mike Exp pjt $";
@


11.5
log
@Converted to LIBBU
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 11.4 1995/09/20 16:03:43 pjt Exp mike $";
d112 4
@


11.4
log
@Added a guard in rb_delete() to ensure that
the current node is defined
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 11.3 1995/07/10 20:18:18 pjt Exp pjt $";
d17 1
a17 2
#include "vmath.h"
#include "raytrace.h"
d172 1
a172 1
	rt_log("Error: Attempt to delete from tree with %d nodes\n",
d178 1
a178 1
	rt_log("Warning: rb_delete(): current node is undefined\n");
d186 1
a186 1
	    rt_malloc(nm_orders * sizeof(struct rb_node *), "node list");
d199 1
a199 1
    rt_free((char *) node, "node list");
@


11.3
log
@Moved rb_free_node() and rb_free_package() from rb_delete.c to rb_free.c
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 11.2 1995/07/07 15:25:26 pjt Exp $";
d177 6
@


11.2
log
@Fixed annoying bug... _rb_delete() was freeing y BEFORE checking its color
to decide whethe to call rb_fixup!
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 11.1 1995/01/04 10:05:53 mike Rel4_4 $";
a88 49
}

/*		    R B _ F R E E _ N O D E ( )
 *
 *	    Relinquish memory occupied by a red-black node
 *
 *	This function has one parameter: a node to free.  rb_free_node()
 *	frees the memory allocated for the various members of the node
 *	and then frees the memory allocated for the node itself.
 */
static void rb_free_node (node)

struct rb_node	*node;

{
    rb_tree	*tree;

    RB_CKMAG(node, RB_NODE_MAGIC, "red-black node");

    tree = node -> rbn_tree;
    if (rb_current(tree) == node)
	rb_current(tree) = rb_null(tree);

    rt_free((char *) node -> rbn_parent, "red-black parents");
    rt_free((char *) node -> rbn_left, "red-black left children");
    rt_free((char *) node -> rbn_right, "red-black right children");
    rt_free((char *) node -> rbn_color, "red-black colors");
    rt_free((char *) node -> rbn_package, "red-black packages");
    rt_free((char *) node, "red-black node");
}

/*		    R B _ F R E E _ P A C K A G E ( )
 *
 *	    Relinquish memory occupied by a red-black package
 *
 *	This function has one parameter: a package to free.
 *	rb_free_package() frees the memory allocated to point to the
 *	nodes that contained the package and then frees the memory
 *	allocated for the package itself.
 */
static void rb_free_package (package)

struct rb_package	*package;

{
    RB_CKMAG(package, RB_PKG_MAGIC, "red-black package");

    rt_free((char *) package -> rbp_node, "red-black package nodes");
    rt_free((char *) package, "red-black package");
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 2.6 94/12/30 16:41:04 stay Exp $";
a189 2
    if (--(y -> rbn_pkg_refs) == 0)
	rb_free_node(y);
d193 3
@


2.6
log
@deleted reference to stdlib, it wil be included in conf.h if
it exists or is STDC
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 2.5 1994/11/01 10:44:19 pjt Exp stay $";
@


2.5
log
@Added rbt_nm_nodes to rb_tree
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 2.4 1994/09/26 12:21:10 jra Exp $";
a13 1
#include <stdlib.h>
@


2.4
log
@Added #include "conf.h"
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 2.3 94/09/22 15:34:39 pjt Exp Locker: jra $";
d220 6
d241 1
@


2.3
log
@Changed "#include "rt_internals.h" to "#include "./rt_internals.h"
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 2.2 94/09/22 15:26:57 pjt Exp Locker: pjt $";
d11 2
@


2.2
log
@Replaced prototype-type definition with K&R type
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 2.1 93/03/25 11:03:11 pjt Exp $";
d19 1
a19 1
#include "rb_internals.h"
@


2.1
log
@Installed into BRL CAD tree
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 1.5 93/03/25 11:00:20 pjt Exp Locker: pjt $";
d31 6
a36 1
static void rb_fixup (rb_tree *tree, struct rb_node *node, int order)
d98 4
a101 1
static void rb_free_node (struct rb_node *node)
d128 4
a131 1
static void rb_free_package (struct rb_package *package)
d147 6
a152 1
static void _rb_delete (rb_tree *tree, struct rb_node *node, int order)
d205 5
a209 1
void rb_delete (rb_tree *tree, int order)
@


1.5
log
@Added authorship comment
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /m/cad/libredblack/RCS/rb_delete.c,v 1.4 93/01/21 14:31:31 pjt zero_1 Locker: pjt $";
@


1.4
log
@Moved left_rotate() and right_rotate() back into rb_rotate.c
@
text
@d5 2
d9 1
a9 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_delete.c,v 1.3 93/01/15 13:07:56 pjt Exp Locker: pjt $";
@


1.3
log
@Added comments and performed general clean up
@
text
@d7 1
a7 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_delete.c,v 1.2 93/01/15 10:45:06 pjt Exp Locker: pjt $";
a17 91

/*		    L E F T _ R O T A T E ( )
 *
 *		Perfrom left rotation on a red-black tree
 *
 *	This function has two parameters: the node about which to rotate
 *	and the order to be rotated.  Left_rotate() is an implementation
 *	of the routine called LEFT-ROTATE on p. 266 of Cormen et al.
 */
static void left_rotate (struct rb_node *x, int order)
{
    struct rb_node	*y;		/* x's child to pivot up */
    struct rb_node	*beta;		/* y's child in direction of rot. */
    struct rb_node	*x_parent;	/* x's parent */
    rb_tree		*tree = x -> rbn_tree;	/* Tree where it all happens */

    /*
     *	Set y and check data types of both x and y
     */
    RB_CKMAG(x, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(x -> rbn_tree, order);

    y = rb_right_child(x, order);

    rb_right_child(x, order) = beta = rb_left_child(y, order);
    if (beta != rb_null(tree))
	rb_parent(beta, order) = x;
    rb_parent(y, order) = x_parent = rb_parent(x, order);
    if (x_parent == rb_null(tree))
	rb_root(tree, order) = y;
    else if (x == rb_left_child(x_parent, order))
	rb_left_child(x_parent, order) = y;
    else
	rb_right_child(x_parent, order) = y;
    rb_left_child(y, order) = x;
    rb_parent(x, order) = y;
}

/*		    R I G H T _ R O T A T E ( )
 *
 *		Perfrom right rotation on a red-black tree
 *
 *	This function has two parameters: the node about which to rotate
 *	and the order to be rotated.  Right_rotate() is hacked from
 *	left_rotate() above.
 */
static void right_rotate (struct rb_node *y, int order)
{
    struct rb_node	*x;		/* y's child to pivot up */
    struct rb_node	*beta;		/* x's child in direction of rot. */
    struct rb_node	*y_parent;	/* y's parent */
    rb_tree		*tree = y -> rbn_tree;	/* Tree where it all happens */

    /*
     *	Set x and check data types of both x and y
     */
    RB_CKMAG(y, RB_NODE_MAGIC, "red-black node");
    RB_CKORDER(y -> rbn_tree, order);

    x = rb_left_child(y, order);

    rb_left_child(y, order) = beta = rb_right_child(x, order);
    if (beta != rb_null(tree))
	rb_parent(beta, order) = y;
    rb_parent(x, order) = y_parent = rb_parent(y, order);
    if (y_parent == rb_null(tree))
	rb_root(tree, order) = x;
    else if (y == rb_left_child(y_parent, order))
	rb_left_child(y_parent, order) = x;
    else
	rb_right_child(y_parent, order) = x;
    rb_right_child(x, order) = y;
    rb_parent(y, order) = x;
}

/*		    R B _ R O T A T E ( )
 *			    and
 *		R B _ O T H E R _ R O T A T E ( )
 *
 *	These macros have three parameters: the node about which
 *	to rotate, the order to be rotated, and the direction of
 *	rotation.  They allow indirection in the use of left_rotate()
 *	and right_rotate().  Intended for use only by rb_fixup()
 *	below.
 */
#define	rb_rotate(n, o, d)	(((d) == RB_LEFT)		? 	\
				    left_rotate((n), (o))	:	\
				    right_rotate((n), (o)))
#define	rb_other_rotate(n, o, d) (((d) == RB_LEFT)		? 	\
				    right_rotate((n), (o))	:	\
				    left_rotate((n), (o)))
@


1.2
log
@Added left_rotate() and right_rotate().
They had been in rb_rotate.c, which has been eliminated
@
text
@d3 1
a3 1
 *	Written by:	Paul Tanenbaum
d7 1
a7 1
static char RCSid[] = "@@(#) $Header: /arl/pjt/libredblack/RCS/rb_delete.c,v 1.1 93/01/14 15:00:03 pjt Exp Locker: pjt $";
a16 1
#define		RB_DELETE	1
d24 2
a25 3
 *	and the order to be rotated.  The bulk of this code is from
 *	T. H. Cormen, C. E. Leiserson, and R. L. Rivest.  _Introduction
 *	to Algorithms_.  Cambridge, MA: MIT Press, 1990. p. 266.
d61 1
a61 1
 *	and the order to be rotated.  This function is hacked from
d92 11
d110 10
d174 8
a187 2
    fprintf(stderr, "rb_free_node(%x)...\n", node);

d200 9
a212 2
    fprintf(stderr, "rb_free_package(%x)...\n", package);

d219 1
a219 1
 *	        Delete a node from a red-black tree
d221 3
a234 3
    fprintf(stderr, "_rb_delete(<%x>, <%x>, %d)...\n", tree, node, order);
    fflush(stderr);

a240 3
    fprintf(stderr, "_rb_delete(%x, %d) splicing out <%x>\n",
	node, order, y);

a261 3
    fprintf(stderr,
	"_rb_delete() decrementing refs to <%x>... now equals %d\n",
	y, y -> rbn_pkg_refs - 1);
d273 4
a276 5
 *	This function has one parameter: a tree and the data block
 *	to be deleted.  rb_delete() removes the data block from each
 *	order in the tree.  rb_delete() returns the number of orders
 *	for which the discovered node contains a data pointer that
 *	is not equal to the specified data block pointer.
a285 2

    fprintf(stderr, "rb_delete(<%x>, %d)...\n", tree, order); fflush(stderr);
@


1.1
log
@Initial revision
@
text
@a4 1
 *  $Header: /arl/pjt/libredblack/RCS/rb_search.c,v 1.4 92/12/23 11:11:20 pjt Exp Locker: pjt $
d6 3
d19 81
@
