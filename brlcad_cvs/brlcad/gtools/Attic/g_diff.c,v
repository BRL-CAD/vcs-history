head	1.23;
access;
symbols
	ansi-20040405-merged:1.18.2.2
	postmerge-20040405-ansi:1.21
	premerge-20040404-ansi:1.20
	postmerge-autoconf:1.20
	autoconf-freeze:1.19.6.2
	premerge-autoconf:1.20
	ansi-20040316-freeze:1.18.2.1
	postmerge-20040315-windows:1.20
	premerge-20040315-windows:1.20
	windows-20040315-freeze:1.18.4.1
	autoconf-20031203:1.19
	autoconf-20031202:1.19
	autoconf-branch:1.19.0.6
	phong-branch:1.19.0.4
	photonmap-branch:1.19.0.2
	rel-6-1-DP:1.18
	windows-branch:1.18.0.4
	rel-6-0-2:1.16
	ansi-branch:1.18.0.2
	rel-6-0-1-branch:1.16.0.2
	hartley-6-0-post:1.17
	hartley-6-0-pre:1.16
	rel-6-0-1:1.16
	rel-6-0:1.14
	rel-5-4:1.6
	offsite-5-3-pre:1.7
	rel-5-3:1.6
	rel-5-2:1.6
	rel-5-1-branch:1.6.0.2
	rel-5-1:1.6
	rel-5-0:1.1
	rel-5-0-beta:1.1;
locks; strict;
comment	@ * @;


1.23
date	2004.05.24.04.12.33;	author morrison;	state dead;
branches;
next	1.22;

1.22
date	2004.05.10.15.30.42;	author erikg;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.05.07.48.13;	author morrison;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.02.17.39.02;	author morrison;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.02.15.33.41;	author jra;	state Exp;
branches
	1.19.6.1;
next	1.18;

1.18
date	2002.08.20.17.07.29;	author jra;	state Exp;
branches
	1.18.2.1
	1.18.4.1;
next	1.17;

1.17
date	2002.08.15.20.54.41;	author hartley;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.09.19.48.39;	author jra;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.06.13.02.34;	author jra;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.09.21.53.22;	author jra;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.09.21.15.59;	author bparker;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.09.15.24.31;	author jra;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.09.14.33.37;	author jra;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.19.20.17.48;	author jra;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.28.14.20.33;	author jra;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.21.14.34.20;	author jra;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.01.12.51.02;	author jra;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.16.14.40.42;	author jra;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.15.07.19;	author jra;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.03.21.39.45;	author bparker;	state Exp;
branches;
next	1.3;

1.3
date	99.12.29.23.23.42;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	99.12.21.17.03.38;	author jra;	state Exp;
branches;
next	1.1;

1.1
date	99.02.12.20.44.13;	author jra;	state Exp;
branches;
next	;

1.18.2.1
date	2002.09.19.18.00.52;	author morrison;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2004.03.17.21.16.10;	author morrison;	state Exp;
branches;
next	;

1.18.4.1
date	2004.03.11.23.40.45;	author morrison;	state Exp;
branches;
next	;

1.19.6.1
date	2004.02.12.19.42.00;	author erikg;	state Exp;
branches;
next	1.19.6.2;

1.19.6.2
date	2004.03.15.14.06.09;	author erikg;	state Exp;
branches;
next	;


desc
@@


1.23
log
@moved to src/gtools/
@
text
@/*
 *			G _ D I F F . C
 *
 *	Routine to determine the differences between two BRL-CAD databases (".g" files).
 *	With no options, the output to stdout is an MGED script that may be fed to
 *	MGED to convert the first database to the match the second.
 *	The script uses the MGED "db" command to make the changes. Some solid types
 *	do not yet have support in the "db" command. Such solids that change from
 *	one database to the next, will be noted by a comment in the database as:
 *	"#IMPORT solid_name from database_name"
 *
 *  Author -
 *      John R. Anderson
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5066
 *
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *      This software is Copyright (C) 1998-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/gtools/g_diff.c,v 1.22 2004/05/10 15:30:42 erikg Exp $";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif


#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <sys/stat.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"
#include "tcl.h"
#include "mater.h"

static struct mater *mater_hd1=MATER_NULL, *mater_hd2=MATER_NULL;

extern int optind;
extern int optopt;

#define HUMAN	1
#define MGED	2

/* type of adjustment, for do_compare() */
#define	PARAMS	1
#define	ATTRS	2

static int mode=HUMAN;
static Tcl_Interp *interp = NULL;
static int pre_5_vers=0;
static int use_floats=0;	/* flag to use floats for comparisons */
static int verify_region_attribs=0;	/* flag to verify region attributes */
static struct db_i *dbip1, *dbip2;
static int version2;

void
compare_colors(void)
{
	struct mater *mp1, *mp2;
	int found1=0, found2=0;
	int is_diff=0;

	for( mp1 = mater_hd1; mp1 != MATER_NULL; mp1 = mp1->mt_forw )  {
		found1 = 0;
		mp2 = mater_hd2;
		while( mp2 != MATER_NULL ) {
			if( mp1->mt_low == mp2->mt_low &&
			    mp1->mt_high == mp2->mt_high &&
			    mp1->mt_r == mp2->mt_r &&
			    mp1->mt_g == mp2->mt_g &&
			    mp1->mt_b == mp2->mt_b ) {
				found1 = 1;
				break;
			} else {
				mp2 = mp2->mt_forw;
			}
		}
		if( !found1 )
			break;
	}
	for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
		found1 = 0;
		mp1 = mater_hd1;
		while( mp1 != MATER_NULL ) {
			if( mp1->mt_low == mp2->mt_low &&
			    mp1->mt_high == mp2->mt_high &&
			    mp1->mt_r == mp2->mt_r &&
			    mp1->mt_g == mp2->mt_g &&
			    mp1->mt_b == mp2->mt_b ) {
				found2 = 1;
				break;
			} else {
				mp1 = mp1->mt_forw;
			}
		}
		if( !found2 )
			break;
	}
	if( !found1 && !found2 ) {
		return;
	} else if( !found1 || !found2 ) {
		is_diff = 1;
	} else {
		/* actually compare two color tables */
		mp1 = mater_hd1;
		mp2 = mater_hd2;
		while( mp1 != MATER_NULL && mp2 != MATER_NULL ) {
			if( mp1->mt_low != mp2->mt_low ) {
				is_diff = 1;
				break;
			}
			if( mp1->mt_high != mp2->mt_high ) {
				is_diff = 1;
				break;
			}
			if( mp1->mt_r != mp2->mt_r ) {
				is_diff = 1;
				break;
			}
			if( mp1->mt_g != mp2->mt_g ) {
				is_diff = 1;
				break;
			}
			if( mp1->mt_b != mp2->mt_b ) {
				is_diff = 1;
				break;
			}
			mp1 = mp1->mt_forw;
			mp2 = mp2->mt_forw;
		}
	}

	if( is_diff ) {
		if( mode == HUMAN ) {
			printf( "Color table has changed from:\n" );
			for( mp1 = mater_hd1; mp1 != MATER_NULL; mp1 = mp1->mt_forw )  {
				printf( "\t%d..%d %d %d %d\n", mp1->mt_low, mp1->mt_high,
					mp1->mt_r, mp1->mt_g, mp1->mt_b );
			}
			printf( "\t\tto:\n" );
			for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
				printf( "\t%d..%d %d %d %d\n", mp2->mt_low, mp2->mt_high,
					mp2->mt_r, mp2->mt_g, mp2->mt_b );
			}
		} else {
			if( version2 > 4 )
				printf( "attr rm _GLOBAL regionid_colortable\n" );
			for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
				printf( "color %d %d %d %d %d\n", mp2->mt_low, mp2->mt_high,
					mp2->mt_r, mp2->mt_g, mp2->mt_b );
			}
		}
	}
}

void
Usage(char *str)
{
	fprintf( stderr, "Usage: %s [-m] file1.g file2.g\n", str );
}

void
kill_obj(char *name)
{
	if( mode == HUMAN ) {
		printf( "%s has been killed\n", name );
	} else {
		printf( "kill %s\n", name );
	}
}

void
compare_external(struct directory *dp1, struct directory *dp2)
{
	struct bu_external ext1, ext2;

	if( db_get_external( &ext1, dp1, dbip1 ) )
	{
		fprintf( stderr, "ERROR: db_get_external failed on solid %s in %s\n", dp1->d_namep, dbip1->dbi_filename );
		exit( 1 );
	}
	if( db_get_external( &ext2, dp2, dbip2 ) )
	{
		fprintf( stderr, "ERROR: db_get_external failed on solid %s in %s\n", dp2->d_namep, dbip2->dbi_filename );
		exit( 1 );
	}

	if( ext1.ext_nbytes != ext2.ext_nbytes ||
		bcmp( (void *)ext1.ext_buf, (void *)ext2.ext_buf, ext1.ext_nbytes ) )
	{
		if( mode == HUMAN )
			printf( "kill %s and import it from %s\n", dp1->d_namep, dbip1->dbi_filename );
		else
			printf( "kill %s\n# IMPORT %s from %s\n", dp1->d_namep, dp2->d_namep, dbip2->dbi_filename );
	}
}

int
compare_values( int type, Tcl_Obj *val1, Tcl_Obj *val2 )
{
	int len1, len2;
	int i;
	int str_ret;
	float a, b;
	Tcl_Obj *obj1, *obj2;

	str_ret = strcmp( Tcl_GetStringFromObj( val1, NULL ), Tcl_GetStringFromObj( val2, NULL ) );

	if( str_ret == 0 || type == ATTRS || !use_floats )
		return( str_ret );

	if( Tcl_ListObjLength( interp, val1, &len1 ) == TCL_ERROR )
	{
		fprintf( stderr, "Error getting length of TCL object!!!\n" );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		exit ( 1 );
	}

	if( Tcl_ListObjLength( interp, val2, &len2 ) == TCL_ERROR )
	{
		fprintf( stderr, "Error getting length of TCL object!!!\n" );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		exit ( 1 );
	}

	if( len1 != len2 )
		return 1;

	for( i=0 ; i<len1 ; i++ ) {
		if( Tcl_ListObjIndex( interp, val1, i, &obj1 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( val1, NULL ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}
		if( Tcl_ListObjIndex( interp, val2, i, &obj2 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( val2, NULL ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}
		a = atof( Tcl_GetStringFromObj( obj1, NULL ) );
		b = atof( Tcl_GetStringFromObj( obj2, NULL ) );

		if( a != b ) {
			return 1;
		}
	}

	return 0;
}

void
do_compare(int type, struct bu_vls *vls, Tcl_Obj *obj1, Tcl_Obj *obj2, char *obj_name)
{
	Tcl_Obj *key1, *val1, *key2, *val2;
	int len1, len2, found, junk;
	int i, j;
	int start_index;
	int found_diffs=0;

	if( Tcl_ListObjLength( interp, obj1, &len1 ) == TCL_ERROR )
	{
		fprintf( stderr, "Error getting length of TCL object!!!\n" );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		exit ( 1 );
	}
	if( Tcl_ListObjLength( interp, obj2, &len2 ) == TCL_ERROR )
	{
		fprintf( stderr, "Error getting length of TCL object!!!\n" );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		exit ( 1 );
	}

	if( !len1 && !len2 )
		return;

	if( type == ATTRS ) {
		start_index = 0;
	} else {
		start_index = 1;
	}

	/* check for changed values from object 1 to object2 */
	for( i=start_index ; i<len1 ; i+=2 )
	{
		if( Tcl_ListObjIndex( interp, obj1, i, &key1 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj1, &junk ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}

		if( Tcl_ListObjIndex( interp, obj1, i+1, &val1 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i+1, Tcl_GetStringFromObj( obj1, &junk ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}

		found = 0;
		for( j=start_index ; j<len2 ; j += 2 )
		{
			if( Tcl_ListObjIndex( interp, obj2, j, &key2 ) == TCL_ERROR )
			{
				fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", j, Tcl_GetStringFromObj( obj2, &junk ) );
				fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
				exit ( 1 );
			}
			if( !strcmp( Tcl_GetStringFromObj( key1, &junk ), Tcl_GetStringFromObj( key2, &junk ) ) )
			{
				found = 1;
				if( Tcl_ListObjIndex( interp, obj2, j+1, &val2 ) == TCL_ERROR )
				{
					fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", j+1, Tcl_GetStringFromObj( obj2, &junk ) );
					fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
					exit ( 1 );
				}

				/* check if this value has changed */
				if( compare_values( type, val1, val2 ) )
				{
					if( !found_diffs++ ) {
						if( mode == HUMAN ) {
							printf( "%s has changed:\n", obj_name );
						}
					}
					if( mode == HUMAN )
					{
						if( type == PARAMS ) {
							printf( "\tparameter %s has changed from:\n\t\t%s\n\tto:\n\t\t%s\n",
								Tcl_GetStringFromObj( key1, &junk ),
								Tcl_GetStringFromObj( val1, &junk ),
								Tcl_GetStringFromObj( val2, &junk ) );
						} else {
							printf( "\t%s attribute \"%s\" has changed from:\n\t\t%s\n\tto:\n\t\t%s\n",
								obj_name,
								Tcl_GetStringFromObj( key1, &junk ),
								Tcl_GetStringFromObj( val1, &junk ),
								Tcl_GetStringFromObj( val2, &junk ) );
						}
					}
					else
					{
						int val_len;

						if( type == ATTRS ) {
							bu_vls_printf( vls, "attr set %s ", obj_name );
						} else {
							bu_vls_strcat( vls, " " );
						}
						bu_vls_strcat( vls, Tcl_GetStringFromObj( key1, &junk ) );
						bu_vls_strcat( vls, " " );
						if( Tcl_ListObjLength( interp, val2, &val_len ) == TCL_ERROR )
						{
							fprintf( stderr, "Error getting length of TCL object!!\n" );
							fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
							exit( 1 );
						}
						if( val_len > 1 )
							bu_vls_putc( vls, '{' );
						bu_vls_strcat( vls, Tcl_GetStringFromObj( val2, &junk ) );
						if( val_len > 1 )
							bu_vls_putc( vls, '}' );
						if( type == ATTRS ) {
							bu_vls_putc( vls, '\n' );
						}
					}
				}
				break;
			}
		}
		if( !found )
		{
			/* this keyword value pair has been eliminated */
			if( !found_diffs++ ) {
				if( mode == HUMAN ) {
					printf( "%s has changed:\n", obj_name );
				}
			}
			if( mode == HUMAN )
			{
				if( type == PARAMS ) {
					printf( "\tparameter %s has been eliminated\n",
						Tcl_GetStringFromObj( key1, &junk ) );
				} else {	
					printf( "\tattribute \"%s\" has been eliminated from %s\n",
						Tcl_GetStringFromObj( key1, &junk ), obj_name );
				}
			}
			else
			{
				if( type == ATTRS ) {
					bu_vls_printf( vls, "attr rm %s %s\n", obj_name,
						       Tcl_GetStringFromObj( key1, &junk ) );
				} else {
					bu_vls_strcat( vls, " " );
					bu_vls_strcat( vls, Tcl_GetStringFromObj( key1, &junk ) );
					bu_vls_strcat( vls, " none" );
				}
			}
		}
	}

	/* check for keyword value pairs in object 2 that don't appear in object 1 */
	for( i=start_index ; i<len2 ; i+= 2 )
	{
		/* get keyword/value pairs from object 2 */
		if( Tcl_ListObjIndex( interp, obj2, i, &key2 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj2, &junk ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}

		if( Tcl_ListObjIndex( interp, obj2, i+1, &val2 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i+1, Tcl_GetStringFromObj( obj2, &junk ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}

		found = 0;
		/* look for this keyword in object 1 */
		for( j=start_index ; j<len1 ; j += 2 )
		{
			if( Tcl_ListObjIndex( interp, obj1, j, &key1 ) == TCL_ERROR )
			{
				fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj1, &junk ) );
				fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
				exit ( 1 );
			}
			if( !strcmp( Tcl_GetStringFromObj( key1, &junk ), Tcl_GetStringFromObj( key2, &junk ) ) )
			{
				found = 1;
				break;
			}
		}
		if( found )
			continue;

		/* This keyword/value pair in object 2 is not in object 1 */
		if( !found_diffs++ ) {
			if( mode == HUMAN ) {
				printf( "%s has changed:\n", obj_name );
			}
		}
		if( mode == HUMAN ) {
			if( type == PARAMS ) {
				printf( "\t%s has new parameter \"%s\" with value %s\n",
					obj_name,
					Tcl_GetStringFromObj( key2, &junk ),
					Tcl_GetStringFromObj( val2, &junk ) );
			} else {
				printf( "\t%s has new attribute \"%s\" with value {%s}\n",
					obj_name,
					Tcl_GetStringFromObj( key2, &junk ),
					Tcl_GetStringFromObj( val2, &junk ) );
			}
		}
		else
		{
			int val_len;

			if( type == ATTRS ) {
				bu_vls_printf( vls, "attr set %s ", obj_name );
			} else {
				bu_vls_strcat( vls, " " );
			}
			bu_vls_strcat( vls, Tcl_GetStringFromObj( key2, &junk ) );
			bu_vls_strcat( vls, " " );
			if( Tcl_ListObjLength( interp, val2, &val_len ) == TCL_ERROR )
			{
				fprintf( stderr, "Error getting length of TCL object!!\n" );
				fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
				exit( 1 );
			}
			if( val_len > 1 )
				bu_vls_putc( vls, '{' );
			bu_vls_strcat( vls, Tcl_GetStringFromObj( val2, &junk ) );
			if( val_len > 1 )
				bu_vls_putc( vls, '}' );

			if( type == ATTRS )
				bu_vls_putc( vls, '\n' );
		}
	}
}

void
compare_tcl_solids(char *str1, Tcl_Obj *obj1, struct directory *dp1, char *str2, Tcl_Obj *obj2, struct directory *dp2)
{
	char *c1, *c2;
	struct bu_vls adjust;

	/* check if same solid type */
	c1 = str1;
	c2 = str2;
	while( *c1 != ' ' && *c2 != ' ' && *c1++ == *c2++ );

	if( *c1 != *c2 )
	{
		/* different solid types */
		if( mode == HUMAN )
			printf( "solid %s:\n\twas: %s\n\tis now: %s\n\n", dp1->d_namep, str1, str2 );
		else
			printf( "kill %s\ndb put %s %s\n", dp1->d_namep, dp1->d_namep, str2 );

		return;
	}
	else if( !strcmp( str1, str2 ) )
		return;		/* no difference */

	/* same solid type, can use "db adjust" */

	if( mode == MGED )
	{
		bu_vls_init( &adjust );
		bu_vls_printf( &adjust, "db adjust %s", dp1->d_namep );
	}

	do_compare( PARAMS, &adjust, obj1, obj2, dp1->d_namep );

	if( mode != HUMAN )
	{
		printf( "%s\n", bu_vls_addr( &adjust ) );
		bu_vls_free( &adjust );
	}
}

void
compare_tcl_combs(Tcl_Obj *obj1, struct directory *dp1, Tcl_Obj *obj2, struct directory *dp2)
{
	int junk;
	struct bu_vls adjust;

	/* first check if there is any difference */
	if( !strcmp( Tcl_GetStringFromObj( obj1, &junk ), Tcl_GetStringFromObj( obj2, &junk ) ) )
		return;

	if( mode != HUMAN )
	{
		bu_vls_init( &adjust );
		bu_vls_printf( &adjust, "db adjust %s", dp1->d_namep );
	}

	do_compare( PARAMS, &adjust, obj1, obj2, dp1->d_namep );

	if( mode != HUMAN )
	{
		printf( "%s\n", bu_vls_addr( &adjust ) );
		bu_vls_free( &adjust );
	}
}

void
verify_region_attrs( struct directory *dp, struct db_i *dbip, Tcl_Obj *obj )
{
	Tcl_Obj **objs;
	int len=0;
	int i;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	if( rt_db_get_internal( &intern, dp, dbip, NULL, &rt_uniresource ) < 0 ) {
		fprintf( stderr, "Cannot import %s\n", dp->d_namep );
		exit( 1 );
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CHECK_COMB( comb );

	if( Tcl_ListObjGetElements( interp, obj, &len, &objs ) != TCL_OK ) {
		fprintf( stderr, "Cannot get length of attributes for %s\n", dp->d_namep );
		exit( 1 );
	}

	for( i=1 ; i<len ; i += 2 ) {
		char *key, *value;

		key = Tcl_GetStringFromObj( objs[i-1], NULL );
		value = Tcl_GetStringFromObj( objs[i], NULL );
		if( !strcmp( key, "region_id" ) ) {
			short id;

			id = atoi( value );
			if( id != comb->region_id ) {
				fprintf( stderr, "WARNING: %s in %s: \"region_id\" attribute says %d, while region says %d\n",
					 dp->d_namep, dbip->dbi_filename, id, comb->region_id );
			}
		} else if( !strcmp( key, "giftmater" ) ) {
			short GIFTmater;

			GIFTmater = atoi( value );
			if( GIFTmater != comb->GIFTmater ) {
				fprintf( stderr, "WARNING: %s in %s: \"giftmater\" attribute says %d, while region says %d\n",
					 dp->d_namep, dbip->dbi_filename, GIFTmater, comb->GIFTmater );
			}
		} else if( !strcmp( key, "los" ) ) {
			short los;

			los = atoi( value );
			if( los != comb->los ) {
				fprintf( stderr, "WARNING: %s in %s: \"los\" attribute says %d, while region says %d\n",
					 dp->d_namep, dbip->dbi_filename, los, comb->los );
			}
		} else if( !strcmp( key, "material" ) ) {
			if( !strncmp( value, "gift", 4 ) ) {
				short GIFTmater;

				GIFTmater = atoi( &value[4] );
				if( GIFTmater != comb->GIFTmater ) {
					fprintf( stderr, "WARNING: %s in %s: \"material\" attribute says %s, while region says %d\n",
						 dp->d_namep, dbip->dbi_filename, value, comb->GIFTmater );
				}
			}
		} else if( !strcmp( key, "aircode" ) ) {
			short aircode;

			aircode = atoi( value );
			if( aircode != comb->aircode ) {
				fprintf( stderr, "WARNING: %s in %s: \"aircode\" attribute says %d, while region says %d\n",
					 dp->d_namep, dbip->dbi_filename, aircode, comb->aircode );
			}
		}
	}
	rt_db_free_internal( &intern, &rt_uniresource );
}

static char *region_attrs[] = { "region",
			      "region_id",
			      "giftmater",
			      "los",
			      "aircode",
			      NULL };
void
remove_region_attrs( Tcl_Obj *obj )
{
	int len=0;
	Tcl_Obj **objs;
	char *key;
	int i,j;
	int found_material=0;

	if( Tcl_ListObjGetElements( interp, obj, &len, &objs ) != TCL_OK ) {
		fprintf( stderr, "Cannot get length of attributes for %s\n",
			 Tcl_GetStringFromObj( obj, NULL ) );
		exit( 1 );
	}

	if( len == 0 )
		return;

	for( i=len-1 ; i>0 ; i -= 2 ) {

		key = Tcl_GetStringFromObj( objs[i-1], NULL );
		j = 0;
		while( region_attrs[j] ) {
			if( !strcmp( key, region_attrs[j] ) ) {
				Tcl_ListObjReplace(interp, obj, i-1, 2, 0, NULL);
				break;
			}
			j++;
		}
		if( !found_material && !strcmp( key, "material" ) ) {
			found_material = 1;
			if( !strncmp( Tcl_GetStringFromObj( objs[i], NULL ), "gift", 4 ) ) {
				Tcl_ListObjReplace(interp, obj, i-1, 2, 0, NULL);
			}
		}
	}
}


void
compare_attrs( struct directory *dp1, struct directory *dp2 )
{
	struct bu_vls vls;
	Tcl_Obj *obj1, *obj2;

	bu_vls_init( &vls );

	if( dbip1->dbi_version > 4 ) {
		bu_vls_printf( &vls, "db1 attr get %s", dp1->d_namep );
		if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK ) {
			fprintf( stderr, "Cannot get attributes for %s\n", dp1->d_namep );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit( 1 );
		}

		obj1 = Tcl_DuplicateObj( Tcl_GetObjResult( interp ) );
		Tcl_ResetResult( interp );
		if( dp1->d_flags & DIR_REGION && verify_region_attribs ) {
			verify_region_attrs( dp1, dbip1, obj1 );
		}
	} else {
		obj1 = Tcl_NewObj();
	}

	if( dbip2->dbi_version > 4 ) {
		bu_vls_trunc( &vls, 0 );
		bu_vls_printf( &vls, "db2 attr get %s", dp1->d_namep );
		if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK ) {
			fprintf( stderr, "Cannot get attributes for %s\n", dp1->d_namep );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit( 1 );
		}

		obj2 = Tcl_DuplicateObj( Tcl_GetObjResult( interp ) );
		Tcl_ResetResult( interp );
		if( dp1->d_flags & DIR_REGION && verify_region_attribs ) {
			verify_region_attrs( dp2, dbip2, obj2 );
		}
	} else {
		obj2 = Tcl_NewObj();
	}

	if( (dp1->d_flags & DIR_REGION) && (dp2->d_flags & DIR_REGION) ) {
		/* don't complain about "region" attributes */
		remove_region_attrs( obj1 );
		remove_region_attrs( obj2 );
	}

	bu_vls_trunc( &vls, 0 );
	do_compare( ATTRS, &vls, obj1, obj2, dp1->d_namep );

	printf( "%s", bu_vls_addr( &vls ) );
	bu_vls_free( &vls );
}

void
diff_objs(struct rt_wdb *wdb1, struct rt_wdb *wdb2)
{
	int i;
	struct directory *dp1, *dp2;
	char *argv[4]={NULL, NULL, NULL, NULL};
	struct bu_vls s1_tcl, s2_tcl;
	struct bu_vls vls;

	RT_CK_WDB(wdb1);
	RT_CK_WDB(wdb2);

	bu_vls_init( &s1_tcl );
	bu_vls_init( &s2_tcl );
	bu_vls_init( &vls );

	/* look at all objects in this database */
	for( i = 0; i < RT_DBNHASH; i++)
	{
		for( dp1 = dbip1->dbi_Head[i]; dp1 != DIR_NULL; dp1 = dp1->d_forw )
		{
			char *str1, *str2;
			Tcl_Obj *obj1, *obj2;

			/* check if this object exists in the other database */
			if( (dp2 = db_lookup( dbip2, dp1->d_namep, 0 )) == DIR_NULL )
			{
				kill_obj( dp1->d_namep );
				continue;
			}

			/* skip the _GLOBAL object */
			if( dp1->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
				continue;

			/* try to get the TCL version of this object */
			bu_vls_trunc( &vls, 0 );
			bu_vls_printf( &vls, "db1 get %s", dp1->d_namep );
			if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK )
			{
				/* cannot get TCL version, use bu_external */
				Tcl_ResetResult( interp );
				compare_external( dp1, dp2 );
				continue;
			}

			obj1 = Tcl_NewListObj( 0, NULL );
			Tcl_AppendObjToObj( obj1, Tcl_GetObjResult( interp ) );

			bu_vls_trunc( &s1_tcl, 0 );
			bu_vls_trunc( &s2_tcl, 0 );

			bu_vls_strcpy( &s1_tcl, Tcl_GetStringResult( interp ) );
			str1 = bu_vls_addr( &s1_tcl );
			Tcl_ResetResult( interp );

			/* try to get TCL version of object from the other database */				
			bu_vls_trunc( &vls, 0 );
			bu_vls_printf( &vls, "db2 get %s", dp1->d_namep );
			if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK )
			{
				Tcl_ResetResult( interp );

				/* cannot get it, they MUST be different */
				if( mode == HUMAN )
					printf( "Replace %s with the same object from %s\n",
						dp1->d_namep, dbip2->dbi_filename );
				else
					printf( "kill %s\n# IMPORT %s from %s\n",
						dp1->d_namep, dp2->d_namep, dbip2->dbi_filename );
				continue;
			}

			obj2 = Tcl_NewListObj( 0, NULL );
			Tcl_AppendObjToObj( obj2, Tcl_GetObjResult( interp ) );

			bu_vls_strcpy( &s2_tcl , Tcl_GetStringResult( interp ) );
			str2 = bu_vls_addr( &s2_tcl );
			Tcl_ResetResult( interp );

			/* got TCL versions of both */
			if( (dp1->d_flags & DIR_SOLID) && (dp2->d_flags & DIR_SOLID) )
			{
				/* both are solids */
				compare_tcl_solids( str1, obj1, dp1, str2, obj2, dp2 );
				if( pre_5_vers != 2 )
					compare_attrs( dp1, dp2 );
				continue;
			}

			if( (dp1->d_flags & DIR_COMB) && (dp2->d_flags & DIR_COMB ) )
			{
				/* both are combinations */
				compare_tcl_combs( obj1, dp1, obj2, dp2 );
				if( !pre_5_vers != 2 )
					compare_attrs( dp1, dp2 );
				continue;
			}

			/* the two objects are different types */
			if( strcmp( str1, str2 ) )
			{
				if( mode == HUMAN )
					printf( "%s:\n\twas: %s\n\tis now: %s\n\n",
						dp1->d_namep, str1, str2 );
				else
					printf( "kill %s\ndb put %s %s\n",
						dp1->d_namep, dp2->d_namep, str2 );
			}
		}
	}

	bu_vls_free( &s1_tcl );
	bu_vls_free( &s2_tcl );

	/* now look for objects in the other database that aren't here */
	for( i = 0; i < RT_DBNHASH; i++)
	{
		for( dp2 = dbip2->dbi_Head[i]; dp2 != DIR_NULL; dp2 = dp2->d_forw )
		{
			/* skip the _GLOBAL object */
			if( dp2->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
				continue;

			/* check if this object exists in the other database */
			if( (dp1 = db_lookup( dbip1, dp2->d_namep, 0 )) == DIR_NULL )
			{
				/* need to add this object */
				argv[2] = dp2->d_namep;
				if( wdb_get_tcl( (ClientData)(wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
				{
					/* could not get TCL version */
					if( mode == HUMAN )
						printf( "Import %s from %s\n",
							dp2->d_namep, dbip2->dbi_filename );
					else
						printf( "# IMPORT %s from %s\n",
							dp2->d_namep, dbip2->dbi_filename );
				}
				else
				{
					if( mode == HUMAN )
						printf( "%s does not exist in %s\n",
							dp2->d_namep, dbip1->dbi_filename );
					else
						printf( "db put %s %s\n",
							dp2->d_namep, Tcl_GetStringResult( interp ) );
				}
				Tcl_ResetResult( interp );
				
			}
		}
	}
}

int
main(int argc, char **argv)
{
	char *invoked_as;
	char *file1, *file2;
	struct rt_wdb *wdb1, *wdb2;
	struct stat stat1, stat2;
	int c;

	invoked_as = argv[0];

	while ((c = getopt(argc, argv, "mfv")) != EOF)
	{
	 	switch( c )
		{
			case 'm':	/* mged readable */
				mode = MGED;
				break;
			case 'f':
				use_floats = 1;
				break;
			case 'v':	/* verify region attributes */
				verify_region_attribs = 1;
				break;
		}
	}

	argc -= optind;
	argv+= optind;

	if( argc != 2 )
	{
		Usage( invoked_as );
		exit( 1 );
	}

	file1 = *argv++;
	file2 = *argv;

	if( stat( file1, &stat1 ) ) {
		fprintf( stderr, "Cannot stat file %s\n", file1 );
		perror( file1 );
		exit( 1 );
	}

	if( stat( file2, &stat2 ) ) {
		fprintf( stderr, "Cannot stat file %s\n", file2 );
		perror( file2 );
		exit( 1 );
	}

	if( stat1.st_dev == stat2.st_dev && stat1.st_ino == stat2.st_ino ) {
		fprintf( stderr, "%s and %s are the same file\n", file1, file2 );
		fprintf( stderr, "Cannot compare a file to itself!!\n" );
		exit( 1 );
	}

	interp = Tcl_CreateInterp();
	if( Tcl_Init(interp) == TCL_ERROR )
	{
		fprintf( stderr, "Tcl_Init error %s\n", interp->result);
		exit( 1 );
	}

	Rt_Init( interp );

	if( (dbip1 = db_open( file1, "r" )) == DBI_NULL )
	{
		fprintf( stderr, "Cannot open %s\n", file1 );
		perror( argv[0] );
		exit( 1 );
	}

	RT_CK_DBI(dbip1);

	if( (wdb1 = wdb_dbopen( dbip1, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL )
	{
		fprintf( stderr, "wdb_dbopen failed for %s\n", file1 );
		exit( 1 );
	}

	if( db_dirbuild( dbip1 ) < 0 )
	{
		db_close( dbip1 );
		fprintf( stderr, "db_dirbuild failed on %s\n", file1 );
		exit( 1 );
	}

	if( wdb_init_obj( interp, wdb1, "db1") != TCL_OK ) {
		wdb_close( wdb1 );
		fprintf( stderr, "wdb_init_obj failed on %s\n", file1 );
		exit( 1 );
	}

	/* save regionid colortable */
	mater_hd1 = rt_material_head;
	rt_material_head = MATER_NULL;

	if( dbip1->dbi_version < 5 ) {
		pre_5_vers++;
	}

	if( (dbip2 = db_open( file2, "r" )) == DBI_NULL )
	{
		fprintf( stderr, "Cannot open %s\n", file2 );
		perror( argv[0] );
		exit( 1 );
	}

	RT_CK_DBI(dbip2);

	if( db_dirbuild( dbip2 ) < 0 )
	{
		db_close( dbip1 );
		db_close( dbip2 );
		fprintf( stderr, "db_dirbuild failed on %s\n", file2 );
		exit( 1 );
	}

	if( (wdb2 = wdb_dbopen( dbip2, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL )
	{
		db_close( dbip2 );
		wdb_close( wdb1 );
		fprintf( stderr, "wdb_dbopen failed for %s\n", file2 );
		exit( 1 );
	}

	if( wdb_init_obj( interp, wdb2, "db2") != TCL_OK ) {
		wdb_close( wdb1 );
		wdb_close( wdb2 );
		fprintf( stderr, "wdb_init_obj failed on %s\n", file2 );
		exit( 1 );
	}

	/* save regionid colortable */
	mater_hd2 = rt_material_head;
	rt_material_head = MATER_NULL;

	if( dbip2->dbi_version < 5 ) {
		pre_5_vers++;
		version2 = 4;
	} else {
		version2 = 5;
	}

	if( mode == HUMAN)
		printf( "\nChanges from %s to %s\n\n", dbip1->dbi_filename, dbip2->dbi_filename );

	/* compare titles */
	if( strcmp( dbip1->dbi_title, dbip2->dbi_title ) )
	{
		if( mode == HUMAN )
			printf( "Title has changed from: \"%s\" to: \"%s\"\n\n", dbip1->dbi_title, dbip2->dbi_title );
		else
			printf( "title %s\n", dbip2->dbi_title );
	}

	/* and units */
	if( dbip1->dbi_local2base != dbip2->dbi_local2base )
	{
		if( mode == HUMAN )
			printf( "Units changed from %s to %s\n", rt_units_string(dbip1->dbi_local2base), rt_units_string(dbip2->dbi_local2base) );
		else
			printf( "units %s\n", rt_units_string(dbip2->dbi_local2base) );
	}

	/* and color table */
	compare_colors();

	/* next compare objects */
	diff_objs( wdb1, wdb2 );

	return( 0 );
}
@


1.22
log
@change conf.h to a wrapped config.h
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvs/brlcad/gtools/g_diff.c,v 1.21 2004/04/05 07:48:13 morrison Exp $";
@


1.21
log
@merge of ansi-6-0-branch into HEAD
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header$";
d33 5
a37 1
#include "conf.h"
@


1.20
log
@update copyright to include span through 2003
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.19 2003/04/02 15:33:41 jra Exp $";
d76 1
a76 1
compare_colors()
d176 1
a176 2
Usage( str )
char *str;
d182 1
a182 2
kill_obj( name )
char *name;
d192 1
a192 2
compare_external( dp1, dp2 )
struct directory *dp1, *dp2;
d273 1
a273 5
do_compare( type, vls, obj1, obj2, obj_name )
int type;
struct bu_vls *vls;
Tcl_Obj *obj1, *obj2;
char *obj_name;
d510 1
a510 4
compare_tcl_solids( str1, obj1, dp1, str2, obj2, dp2 )
char *str1, *str2;
Tcl_Obj *obj1, *obj2;
struct directory *dp1, *dp2;
d551 1
a551 3
compare_tcl_combs( obj1, dp1, obj2, dp2 )
Tcl_Obj *obj1, *obj2;
struct directory *dp1, *dp2;
d751 1
a751 2
diff_objs( wdb1, wdb2 )
struct rt_wdb *wdb1, *wdb2;
d906 1
a906 3
main( argc, argv )
int argc;
char *argv[];
@


1.19
log
@Eliminated an unused variable
@
text
@d25 1
a25 1
 *      This software is Copyright (C) 1998 by the United States Army
d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.18 2002/08/20 17:07:29 jra Exp $";
@


1.19.6.1
log
@merge from HEAD
@
text
@d25 1
a25 1
 *      This software is Copyright (C) 1998-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.20 2004/02/02 17:39:02 morrison Exp $";
@


1.19.6.2
log
@merge from head
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.19.6.1 2004/02/12 19:42:00 erikg Exp $";
@


1.18
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.16 2002/05/09 19:48:39 jra Exp $";
a671 1
	Tcl_Obj *new_obj;
a683 2

	new_obj = Tcl_NewObj();
@


1.18.4.1
log
@sync to HEAD...
@
text
@d25 1
a25 1
 *      This software is Copyright (C) 1998-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "$Header: /n/cad/c/CVS/brlcad/gtools/g_diff.c,v 1.20 2004/02/02 17:39:02 morrison Exp $";
d672 1
d685 2
@


1.18.2.1
log
@Initial ANSIfication
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.18 2002/08/20 17:07:29 jra Exp $";
d76 1
a76 1
compare_colors(void)
d176 2
a177 1
Usage(char *str)
d183 2
a184 1
kill_obj(char *name)
d194 2
a195 1
compare_external(struct directory *dp1, struct directory *dp2)
d276 5
a280 1
do_compare(int type, struct bu_vls *vls, Tcl_Obj *obj1, Tcl_Obj *obj2, char *obj_name)
d517 4
a520 1
compare_tcl_solids(char *str1, Tcl_Obj *obj1, struct directory *dp1, char *str2, Tcl_Obj *obj2, struct directory *dp2)
d561 3
a563 1
compare_tcl_combs(Tcl_Obj *obj1, struct directory *dp1, Tcl_Obj *obj2, struct directory *dp2)
d766 2
a767 1
diff_objs(struct rt_wdb *wdb1, struct rt_wdb *wdb2)
d922 3
a924 1
main(int argc, char **argv)
@


1.18.2.2
log
@sync branch with HEAD
@
text
@d25 1
a25 1
 *      This software is Copyright (C) 1998-2004 by the United States Army
d30 1
a30 1
static const char RCSid[] = "$Header$";
d660 1
d673 2
@


1.17
log
@Converted from K&R to ANSI C - RFH
@
text
@d76 1
a76 1
compare_colors(void)
d176 2
a177 1
Usage(char *str)
d183 2
a184 1
kill_obj(char *name)
d194 2
a195 1
compare_external(struct directory *dp1, struct directory *dp2)
d276 5
a280 1
do_compare(int type, struct bu_vls *vls, Tcl_Obj *obj1, Tcl_Obj *obj2, char *obj_name)
d517 4
a520 1
compare_tcl_solids(char *str1, Tcl_Obj *obj1, struct directory *dp1, char *str2, Tcl_Obj *obj2, struct directory *dp2)
d561 3
a563 1
compare_tcl_combs(Tcl_Obj *obj1, struct directory *dp1, Tcl_Obj *obj2, struct directory *dp2)
d766 2
a767 1
diff_objs(struct rt_wdb *wdb1, struct rt_wdb *wdb2)
d922 3
a924 1
main(int argc, char **argv)
@


1.16
log
@Added -v option to verify region attributes and updated man page
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.15 2002/05/06 13:02:34 jra Exp $";
d76 1
a76 1
compare_colors()
d176 1
a176 2
Usage( str )
char *str;
d182 1
a182 2
kill_obj( name )
char *name;
d192 1
a192 2
compare_external( dp1, dp2 )
struct directory *dp1, *dp2;
d273 1
a273 5
do_compare( type, vls, obj1, obj2, obj_name )
int type;
struct bu_vls *vls;
Tcl_Obj *obj1, *obj2;
char *obj_name;
d510 1
a510 4
compare_tcl_solids( str1, obj1, dp1, str2, obj2, dp2 )
char *str1, *str2;
Tcl_Obj *obj1, *obj2;
struct directory *dp1, *dp2;
d551 1
a551 3
compare_tcl_combs( obj1, dp1, obj2, dp2 )
Tcl_Obj *obj1, *obj2;
struct directory *dp1, *dp2;
d754 1
a754 2
diff_objs( wdb1, wdb2 )
struct rt_wdb *wdb1, *wdb2;
d909 1
a909 3
main( argc, argv )
int argc;
char *argv[];
@


1.15
log
@improved comparison of color tables
mods for new syntax of "attr" command
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.14 2001/11/09 21:53:22 jra Exp $";
d71 1
d727 1
a727 1
		if( dp1->d_flags & DIR_REGION ) {
d745 1
a745 1
		if( dp1->d_flags & DIR_REGION ) {
d934 1
a934 1
	while ((c = getopt(argc, argv, "mf")) != EOF)
d943 3
@


1.14
log
@Now handles regionid color table also
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.13 2001/11/09 21:15:59 bparker Exp $";
d79 1
d117 35
a151 1
	if( !found1 || !found2 ) {
d165 1
a165 1
				printf( "attr_rm _GLOBAL regionid_colortable\n" );
d373 1
a373 1
							bu_vls_printf( vls, "attr %s ", obj_name );
d419 1
a419 1
					bu_vls_printf( vls, "attr_rm %s %s\n", obj_name,
d491 1
a491 1
				bu_vls_printf( vls, "attr %s ", obj_name );
d717 1
a717 1
		bu_vls_printf( &vls, "db1 attr %s", dp1->d_namep );
d735 1
a735 1
		bu_vls_printf( &vls, "db2 attr %s", dp1->d_namep );
@


1.13
log
@*- added includes for sys/types.h and sys/stat.h
   to support stat
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.12 2001/11/09 15:24:31 jra Exp $";
a33 1

d36 2
a42 2
#include <sys/types.h>
#include <sys/stat.h>
d53 3
d72 66
d150 1
a150 1
	if( mode == HUMAN )
d152 1
a152 1
	else
d154 1
a154 1

d978 5
a982 1
	if( dbip1->dbi_version < 5 )
d984 1
d1018 5
a1022 1
	if( dbip2->dbi_version < 5 )
d1024 4
d1049 3
@


1.12
log
@Now ignores _GLOBAL object
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.11 2001/11/09 14:33:37 jra Exp $";
d42 2
@


1.11
log
@Now cannot compare a file to itself
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.10 2001/10/19 20:17:48 jra Exp $";
d780 4
@


1.10
log
@Now checks for consistency between region attributes and region parameters in same file
Now will not complain about missing region attributes when comparing v5 to v4
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.9 2001/08/28 14:20:33 jra Exp $";
d819 1
d848 18
@


1.9
log
@Now handles attributes, added the -f flag
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.8 2001/08/21 14:34:20 jra Exp $";
d482 122
d621 3
d639 3
d644 6
@


1.8
log
@g_diff now ignores _GLOBAL object
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.7 2000/08/01 12:51:02 jra Exp $";
d59 4
d65 3
d73 1
a73 1
	bu_log( "Usage: %s [-m] file1.g file2.g\n", str );
d88 1
a88 1
compare_external( dp1, dbip1, dp2, dbip2 )
a89 1
struct db_i *dbip1, *dbip2;
d95 1
a95 1
		bu_log( "ERROR: db_get_external failed on solid %s in %s\n", dp1->d_namep, dbip1->dbi_filename );
d100 1
a100 1
		bu_log( "ERROR: db_get_external failed on solid %s in %s\n", dp2->d_namep, dbip2->dbi_filename );
d114 55
d170 3
a172 1
do_adjusts( adjust, obj1, obj2 )
d174 1
a174 1
struct bu_vls *adjust;
d179 2
d184 2
a185 2
		bu_log( "Error getting length of TCL object!!!\n" );
		bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d190 2
a191 2
		bu_log( "Error getting length of TCL object!!!\n" );
		bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d195 7
a201 5
	if( Tcl_ListObjIndex( interp, obj1, 0, &key1 ) == TCL_ERROR )
	{
		bu_log( "Error getting word #%d in TCL object (%s)!!!\n", 0, Tcl_GetStringFromObj( obj1, &junk ) );
		bu_log( "%s\n", Tcl_GetStringResult( interp ) );
		exit ( 1 );
d205 1
a205 1
	for( i=1 ; i<len1 ; i+=2 )
d209 2
a210 2
			bu_log( "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj1, &junk ) );
			bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d216 2
a217 2
			bu_log( "Error getting word #%d in TCL object!!! (%s)\n", i+1, Tcl_GetStringFromObj( obj1, &junk ) );
			bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d222 1
a222 1
		for( j=1 ; j<len2 ; j += 2 )
d226 2
a227 2
				bu_log( "Error getting word #%d in TCL object!!! (%s)\n", j, Tcl_GetStringFromObj( obj2, &junk ) );
				bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d235 2
a236 2
					bu_log( "Error getting word #%d in TCL object!!! (%s)\n", j+1, Tcl_GetStringFromObj( obj2, &junk ) );
					bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d241 1
a241 1
				if( strcmp( Tcl_GetStringFromObj( val1, &junk ), Tcl_GetStringFromObj( val2, &junk ) ) )
d243 5
d250 12
a261 4
						printf( "\t%s has changed from:\n\t\t%s\n\tto:\n\t\t%s\n",
							Tcl_GetStringFromObj( key1, &junk ),
							Tcl_GetStringFromObj( val1, &junk ),
							Tcl_GetStringFromObj( val2, &junk ) );
d267 7
a273 3
						bu_vls_strcat( adjust, " " );
						bu_vls_strcat( adjust, Tcl_GetStringFromObj( key1, &junk ) );
						bu_vls_strcat( adjust, " " );
d276 2
a277 2
							bu_log( "Error getting length of TCL object!!\n" );
							bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d281 2
a282 2
							bu_vls_putc( adjust, '{' );
						bu_vls_strcat( adjust, Tcl_GetStringFromObj( val2, &junk ) );
d284 4
a287 1
							bu_vls_putc( adjust, '}' );
d296 5
d303 7
a309 2
				printf( "\t%s has been eliminated\n",
					Tcl_GetStringFromObj( key1, &junk ) );
d313 8
a320 3
				bu_vls_strcat( adjust, " " );
				bu_vls_strcat( adjust, Tcl_GetStringFromObj( key1, &junk ) );
				bu_vls_strcat( adjust, " none" );
d326 1
a326 1
	for( i=1 ; i<len2 ; i+= 2 )
d331 2
a332 2
			bu_log( "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj2, &junk ) );
			bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d338 2
a339 2
			bu_log( "Error getting word #%d in TCL object!!! (%s)\n", i+1, Tcl_GetStringFromObj( obj2, &junk ) );
			bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d345 1
a345 1
		for( j=1 ; j<len1 ; j += 2 )
d349 2
a350 2
				bu_log( "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj1, &junk ) );
				bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d363 18
a380 2
		if( mode == HUMAN )
			printf( "\tadd %s %s\n", Tcl_GetStringFromObj( key2, &junk ), Tcl_GetStringFromObj( val2, &junk ) );
d385 7
a391 3
			bu_vls_strcat( adjust, " " );
			bu_vls_strcat( adjust, Tcl_GetStringFromObj( key2, &junk ) );
			bu_vls_strcat( adjust, " " );
d394 2
a395 2
				bu_log( "Error getting length of TCL object!!\n" );
				bu_log( "%s\n", Tcl_GetStringResult( interp ) );
d399 2
a400 2
				bu_vls_putc( adjust, '{' );
			bu_vls_strcat( adjust, Tcl_GetStringFromObj( val2, &junk ) );
d402 4
a405 1
				bu_vls_putc( adjust, '}' );
d411 1
a411 1
compare_tcl_solids( str1, obj1, dp1, dbip1, str2, obj2, dp2, dbip2 )
a414 1
struct db_i *dbip1, *dbip2;
d439 1
a439 3
	if( mode == HUMAN )
		printf( "%s has changed:\n", dp1->d_namep );
	else
d445 1
a445 1
	do_adjusts( &adjust, obj1, obj2 );
d455 1
a455 1
compare_tcl_combs( obj1, dp1, dbip1, obj2, dp2, dbip2 )
a457 1
struct db_i *dbip1, *dbip2;
a470 2
	else
		printf( "%s has changed:\n", dp1->d_namep );
d472 1
a472 1
	do_adjusts( &adjust, obj1, obj2 );
d482 44
a530 1
	struct db_i *dbip1, *dbip2;
d533 1
a536 2
	dbip1 = wdb1->dbip;
	dbip2 = wdb2->dbip;
d540 1
d562 3
a564 3
			argv[2] = dp1->d_namep;
/* XXX Dangerous downcall.  Should invoke Tcl_Eval("db1 get name") */
			if( wdb_get_tcl( (ClientData)(wdb1), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
d568 1
a568 1
				compare_external( dp1, dbip1, dp2, dbip2 );
d573 1
a573 1
			Tcl_AppendToObj( obj1, interp->result, -1 );
d583 3
a585 2
/* XXX Dangerous downcall.  Should invoke Tcl_Eval("db1 get name") */
			if( wdb_get_tcl( (ClientData)(wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
d600 1
a600 1
			Tcl_AppendToObj( obj2, interp->result, -1 );
d610 3
a612 1
				compare_tcl_solids( str1, obj1, dp1, dbip1, str2, obj2, dp2, dbip2 );
d619 3
a621 1
				compare_tcl_combs( obj1, dp1, dbip1, obj2, dp2, dbip2 );
a684 1
	struct db_i *dbip1, *dbip2;
d689 1
a689 1
	while ((c = getopt(argc, argv, "m")) != EOF)
d696 3
d717 1
a717 1
		bu_log( "Tcl_Init error %s\n", interp->result);
d721 2
d725 1
a725 1
		bu_log( "Cannot open %s\n", file1 );
d734 1
a734 1
		bu_log( "wdb_dbopen failed for %s\n", file1 );
d741 1
a741 1
		bu_log( "db_dirbuild failed on %s\n", file1 );
d745 9
d756 1
a756 1
		bu_log( "Cannot open %s\n", file2 );
d767 1
a767 1
		bu_log( "db_dirbuild failed on %s\n", file2 );
d775 1
a775 1
		bu_log( "wdb_dbopen failed for %s\n", file2 );
d778 10
@


1.7
log
@Switch to using dirbuild instead of db_scan
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.6 2000/03/16 14:40:42 jra Exp $";
d395 4
d510 1
d622 2
@


1.6
log
@Fixed a bug in the call to wdb_get_tcl()
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.5 2000/01/07 15:07:19 jra Exp $";
d562 1
a562 1
	if( db_scan( dbip1, (int (*)())db_diradd, 1, NULL ) < 0 )
d565 1
a565 1
		bu_log( "db_scan failed on %s\n", file1 );
d578 1
a578 1
	if( db_scan( dbip2, (int (*)())db_diradd, 1, NULL ) < 0 )
d582 1
a582 1
		bu_log( "db_scan failed on %s\n", file2 );
@


1.5
log
@Eliminated some unused variables
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.4 2000/01/03 21:39:45 bparker Exp $";
d398 1
a398 1
			if( wdb_get_tcl( (ClientData)(&wdb1), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
d418 1
a418 1
			if( wdb_get_tcl( (ClientData)(&wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
d480 1
a480 1
				if( wdb_get_tcl( (ClientData)(&wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
@


1.4
log
@*- wdb_obj merged into rt_wdb
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.3 1999/12/29 23:23:42 mike Exp $";
a292 1
	Tcl_Obj *key1, *val1, *key2, *val2;
@


1.3
log
@
db_scan() got a client_data argument, which
db_diradd() needed to learn to ignore.
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.2 1999/12/21 17:03:38 jra Exp $";
a371 1
	struct wdb_obj wdbobj1, wdbobj2;
a377 3
	wdbobj1.wdb_wp = wdb1;
	wdbobj2.wdb_wp = wdb2;

d399 1
a399 1
			if( wdb_get_tcl( (ClientData)(&wdbobj1), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
d419 1
a419 1
			if( wdb_get_tcl( (ClientData)(&wdbobj2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
d481 1
a481 1
				if( wdb_get_tcl( (ClientData)(&wdbobj2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
@


1.2
log
@Mods to use wdb_get_tcl() instead of rt_db_get()
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /c/CVS/brlcad/gtools/g_diff.c,v 1.1 1999/02/12 20:44:13 jra Exp $";
d402 1
d422 1
d567 1
a567 1
	if( db_scan( dbip1, (int (*)())db_diradd, 1 ) < 0 )
d583 1
a583 1
	if( db_scan( dbip2, (int (*)())db_diradd, 1 ) < 0 )
@


1.1
log
@changed g_lint directry to gtools
@
text
@d30 1
a30 1
static char RCSid[] = "$Header: /c/CVS/brlcad/g_lint/g_diff.c,v 1.1 1999/02/12 20:07:57 jra Exp $";
d372 1
d379 3
d402 1
a402 1
			if( rt_db_get( (ClientData)(wdb1), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
d421 1
a421 1
			if( rt_db_get( (ClientData)(wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
d483 1
a483 1
				if( rt_db_get( (ClientData)(wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
@

