head	14.18;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.9
	rel-7-10-2:14.16
	rel-7-10-0:14.15
	rel-7-8-4:14.12
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.6
	rel-7-6-0:14.9
	rel-7-4-2:14.9
	rel-7-4-branch:14.9.0.4
	bobWinPort:14.9.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.9
	rel-7-2-4:14.9
	rel-7-2-2:14.9
	rel-7-2-0:14.8
	rel-7-0-4:14.7
	rel-7-0-2:14.7
	rel-7-0-1:14.7
	opensource-post:14.7
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.18
date	2007.12.16.18.53.49;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.11;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.05.18.04.13.47;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.38;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.53;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.23.00.35.08;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.03.28.06.31.37;	author bob1961;	state Exp;
branches
	14.9.6.1;
next	14.8;

14.8
date	2005.01.30.20.30.55;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.32.30;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.33;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.03.25;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.51;	author morrison;	state Exp;
branches;
next	;

14.9.6.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.18
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                     S H _ S C L O U D . C
 * BRL-CAD
 *
 * Copyright (c) 1998-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file sh_scloud.c
 *
 *	A 3D "solid" cloud shader
 *
 *  Author -
 *	Lee A. Butler
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.17 2007/09/15 16:23:11 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "light.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
#if !defined(M_PI)
#define M_PI            3.14159265358979323846
#endif

#define FLOOR(x)	(  (int)(x) - (  (x) < 0 && (x) != (int)(x)  )  )
#define CEIL(x)		(  (int)(x) + (  (x) > 0 && (x) != (int)(x)  )  )

struct scloud_specific {
	double	lacunarity;
	double	h_val;
	double	octaves;
	double	scale;	/* scale coordinate space */
	point_t	vscale;
	vect_t	delta;	/* xlatd in noise space (where interesting noise is)*/
	double	max_d_p_mm;	/* maximum density per millimeter */
	double	min_d_p_mm;	/* background density per millimeter */
	mat_t	mtos;		/* model to shader */
	mat_t	stom;		/* shader to model */
};

static struct scloud_specific scloud_defaults = {
	2.1753974,	/* lacunarity */
	1.0,		/* h_val */
	4.0,		/* octaves */
	1.0,		/* scale */
	{ 1.0, 1.0, 1.0 },	/* vscale */
	{ 1000.0, 1200.0, 2100.0 },	/* delta */
	0.01,			/* max_d_p_mm */
	0.0
	};

#define SHDR_NULL	((struct scloud_specific *)0)
#define SHDR_O(m)	bu_offsetof(struct scloud_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct scloud_specific, m)

struct bu_structparse scloud_pr[] = {
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "scale",		SHDR_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "vscale",		SHDR_AO(vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "Max", 		SHDR_O(max_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "min", 		SHDR_O(min_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};
struct bu_structparse scloud_parse[] = {
	{"%f",	1, "lacunarity",	SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 		SHDR_O(h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "scale",		SHDR_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",		SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "l",			SHDR_O(lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "M", 		SHDR_O(max_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "Max", 		SHDR_O(max_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "m", 		SHDR_O(min_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "min", 		SHDR_O(min_d_p_mm),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "o", 		SHDR_O(octaves),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "s",			SHDR_O(scale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "vs",		SHDR_AO(vscale),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "d",			SHDR_AO(delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	scloud_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), scloud_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp), tsplat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	scloud_print(register struct region *rp, char *dp), scloud_free(char *cp);

struct mfuncs scloud_mfuncs[] = {
	{MF_MAGIC,	"scloud",	0,	MFI_HIT, MFF_PROC,
	scloud_setup,	scloud_render,	scloud_print,	scloud_free },

	{MF_MAGIC,	"tsplat",	0,	MFI_HIT, MFF_PROC,
	scloud_setup,	tsplat_render,	scloud_print,	scloud_free },

	{0,		(char *)0,	0,		0, 0,
	0,		0,		0,		0 }
};


/*
 *	S C L O U D _ S E T U P
 */
HIDDEN int
scloud_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)


		/* pointer to reg_udata in *rp */


{
	register struct scloud_specific *scloud;
	struct db_full_path full_path;
	mat_t	region_to_model;
	mat_t	model_to_region;
	mat_t	tmp;

	BU_CK_VLS( matparm );
	BU_GETSTRUCT( scloud, scloud_specific );
	*dpp = (char *)scloud;

	if (rp->reg_aircode == 0) {
		bu_log("WARNING(%s): air shader '%s' applied to non-air region.\n%s\n",
			rp->reg_name,
			mfp->mf_name,
			"  Set air flag with \"edcodes\" in mged");
		bu_bomb("");
	}

	memcpy(scloud, &scloud_defaults, sizeof(struct scloud_specific));
	if (rdebug&RDEBUG_SHADE)
		bu_log("scloud_setup\n");

	if (bu_struct_parse( matparm, scloud_parse, (char *)scloud ) < 0 )
		return(-1);

	if (rdebug&RDEBUG_SHADE)
		(void)bu_struct_print( rp->reg_name, scloud_parse, (char *)scloud );

	/* get transformation between world and "region" coordinates */
	if (db_string_to_path( &full_path, rtip->rti_dbip, rp->reg_name) ) {
		/* bad thing */
		bu_bomb("db_string_to_path() error");
	}
	if(! db_path_to_mat(rtip->rti_dbip, &full_path, region_to_model, 0, &rt_uniresource)) {
		/* bad thing */
		bu_bomb("db_path_to_mat() error");
	}

	/* get matrix to map points from model space to "region" space */
	bn_mat_inv(model_to_region, region_to_model);

	/* add the noise-space scaling */
	MAT_IDN(tmp);
	if (scloud->scale != 1.0) {
		tmp[0] = tmp[5] = tmp[10] = 1.0 / scloud->scale;
	} else {
		tmp[0] = 1.0 / (scloud->vscale[0]);
		tmp[5] = 1.0 / (scloud->vscale[1]);
		tmp[10] = 1.0 / (scloud->vscale[2]);
	}

	bn_mat_mul(scloud->mtos, tmp, model_to_region);

	/* add the translation within noise space */
	MAT_IDN(tmp);
	tmp[MDX] = scloud->delta[0];
	tmp[MDY] = scloud->delta[1];
	tmp[MDZ] = scloud->delta[2];
	bn_mat_mul2(tmp, scloud->mtos);
	bn_mat_inv(scloud->stom, scloud->mtos);

	return(1);
}

/*
 *	S C L O U D _ P R I N T
 */
HIDDEN void
scloud_print(register struct region *rp, char *dp)
{
	(void)bu_struct_print( rp->reg_name, scloud_pr, (char *)dp );
}

/*
 *	S C L O U D _ F R E E
 */
HIDDEN void
scloud_free(char *cp)
{
	bu_free( cp, "scloud_specific" );
}


/*
 *	T S P L A T _ R E N D E R
 *
 *	Sort of a surface spot transparency shader.  Picks transparency
 *	based upon noise value of surface spot.
 */
int
tsplat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct scloud_specific *scloud_sp =
		(struct scloud_specific *)dp;
	point_t in_pt;	/* point where ray enters scloud solid */
	double  val;

	RT_CHECK_PT(pp);
	RT_AP_CHECK(ap);
	RT_CK_REGION(pp->pt_regionp);


	/* just shade the surface with a transparency */
	MAT4X3PNT(in_pt, scloud_sp->mtos, swp->sw_hit.hit_point);
	val = bn_noise_fbm(in_pt, scloud_sp->h_val,
			scloud_sp->lacunarity, scloud_sp->octaves );
	CLAMP(val, 0.0, 1.0);
	swp->sw_transmit = 1.0 - val;


	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return 1;
}


/*
 *	S C L O U D _ R E N D E R
 */
int
scloud_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
	register struct scloud_specific *scloud_sp =
		(struct scloud_specific *)dp;
	point_t in_pt;	/* point where ray enters scloud solid */
	point_t out_pt; /* point where ray leaves scloud solid */
	point_t pt;
	vect_t	v_cloud;/* vector representing ray/solid intersection */
	double	thickness; /* magnitude of v_cloud (distance through solid) */
	int	steps;	   /* # of samples along ray/solid intersection */
	double	step_delta;/* distance between sample points, texture space */
	int	i;
	double  val;
	double	trans;
	point_t	incident_light;
	double	delta_dpmm;
	double density;
	struct shadework sub_sw;
	struct light_specific *lp;

	RT_CHECK_PT(pp);
	RT_AP_CHECK(ap);
	RT_CK_REGION(pp->pt_regionp);

	/* compute the ray/solid in and out points,
	 * and transform them into "shader space" coordinates
	 */
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(in_pt, scloud_sp->mtos, pt);

	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	MAT4X3PNT(out_pt, scloud_sp->mtos, pt);


	/* get ray/solid intersection vector (in noise space)
	 * and compute thickness of solid (in noise space) along ray path
	 */
	VSUB2(v_cloud, out_pt, in_pt);
	thickness = MAGNITUDE(v_cloud);

	/* The noise field used by the bn_noise_turb and bn_noise_fbm routines
	 * has a maximum frequency of about 1 cycle per integer step in
	 * noise space.  Each octave increases this frequency by the
	 * "lacunarity" factor.  To sample this space adequately we need
	 *
	 *	4 samples per integer step for the first octave,
	 *	lacunarity * 4 samples/step for the second octave,
	 * 	lacunarity^2 * 4 samples/step for the third octave,
	 * 	lacunarity^3 * 4 samples/step for the forth octave,
	 *
	 * so for a computation with 4 octaves we need something on the
	 * order of lacunarity^3 * 4 samples per integer step in noise space.
	 */

	steps = pow(scloud_sp->lacunarity, scloud_sp->octaves-1) * 4;
	step_delta = thickness / (double)steps;

	if (rdebug&RDEBUG_SHADE)
		bu_log("steps=%d  delta=%g  thickness=%g\n",
			steps, step_delta, thickness);

	VUNITIZE(v_cloud);
	VMOVE(pt, in_pt);
	trans = 1.0;

	delta_dpmm = scloud_sp->max_d_p_mm - scloud_sp->min_d_p_mm;

	sub_sw = *swp; /* struct copy */
	sub_sw.sw_inputs = MFI_HIT;

	for (i=0 ; i < steps ; i++ ) {
		/* compute the next point in the cloud space */
		VJOIN1(pt, in_pt, i*step_delta, v_cloud);

		/* get turbulence value (0 .. 1) */
		val = bn_noise_turb(pt, scloud_sp->h_val,
			scloud_sp->lacunarity, scloud_sp->octaves );

		density = scloud_sp->min_d_p_mm + val * delta_dpmm;

		val = exp( - density * step_delta);
		trans *= val;

		if (swp->sw_xmitonly) continue;

		/* need to set the hit in our fake shadework structure */
		MAT4X3PNT(sub_sw.sw_hit.hit_point, scloud_sp->stom, pt);
		sub_sw.sw_transmit = trans;

		sub_sw.sw_inputs = MFI_HIT;

		light_obs( ap, &sub_sw, swp->sw_inputs );
		/* now we know how much light has arrived from each
		 * light source to this point
		 */
		for (i=ap->a_rt_i->rti_nlights-1  ; i >= 0 ; i--) {
			lp = (struct light_specific *)swp->sw_visible[i];
			if (lp == LIGHT_NULL ) continue;

			/* compute how much light has arrived at
			 * this location
			 */
			incident_light[0] += sub_sw.sw_intensity[3*i+0] *
				lp->lt_color[0] * sub_sw.sw_lightfract[i];
			incident_light[1] += sub_sw.sw_intensity[3*i+1] *
				lp->lt_color[1] * sub_sw.sw_lightfract[i];
			incident_light[2] += sub_sw.sw_intensity[3*i+2] *
				lp->lt_color[2] * sub_sw.sw_lightfract[i];
		}

		VSCALE(incident_light, incident_light, trans);


	}

	/* scloud is basically a white object with partial transparency */
	swp->sw_transmit = trans;
	if (swp->sw_xmitonly )  return 1;


	/*
	 *  At the point of maximum opacity, check light visibility
	 *  for light color and cloud shadowing.
	 *  OOPS:  Don't use an interior point, or light_visibility()
	 *  will see an attenuated light source.
	 */
	swp->sw_hit.hit_dist = pp->pt_inhit->hit_dist;
	VJOIN1(swp->sw_hit.hit_point, ap->a_ray.r_pt, swp->sw_hit.hit_dist,
		ap->a_ray.r_dir);
	VREVERSE( swp->sw_hit.hit_normal, ap->a_ray.r_dir );
	swp->sw_inputs |= MFI_HIT | MFI_NORMAL;
	light_obs( ap, swp, swp->sw_inputs );
	VSETALL(incident_light, 0 );
	for( i=ap->a_rt_i->rti_nlights-1; i>=0; i-- )  {
		struct light_specific	*lp;
		if ((lp = (struct light_specific *)swp->sw_visible[i]) == LIGHT_NULL )
			continue;
		/* XXX don't have a macro for this */
		incident_light[0] += swp->sw_intensity[3*i+0] * lp->lt_color[0];
		incident_light[1] += swp->sw_intensity[3*i+1] * lp->lt_color[1];
		incident_light[2] += swp->sw_intensity[3*i+2] * lp->lt_color[2];
	}
	VELMUL( swp->sw_color, swp->sw_color, incident_light );


	if (rdebug&RDEBUG_SHADE ) {
		pr_shadework( "scloud: after light vis, before rr_render", swp);
	}

	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.16 2007/05/18 04:13:47 brlcad Exp $ (ARL)";
d159 1
a159 1
	memcpy(scloud, &scloud_defaults, sizeof(struct scloud_specific) );
@


14.16
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.15 2007/01/27 01:41:38 brlcad Exp $ (ARL)";
d39 1
a39 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.14 2007/01/23 01:13:36 brlcad Exp $ (ARL)";
d176 1
a176 1
		rt_bomb("db_string_to_path() error");
d180 1
a180 1
		rt_bomb("db_path_to_mat() error");
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.13 2007/01/20 14:36:53 brlcad Exp $ (ARL)";
a133 1

d141 1
a141 1
    	      	/* pointer to reg_udata in *rp */
a227 1

a261 1

d394 1
a394 1
 		ap->a_ray.r_dir);
a421 3



@


14.13
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.12 2006/01/23 00:35:08 brlcad Exp $ (ARL)";
@


14.12
log
@include stddef.h for bu_offset's usage of offset
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2006 United States Government as represented by
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.11 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
@


14.11
log
@update copyright to 2006
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.10 2005/10/23 04:44:34 brlcad Exp $ (ARL)";
d38 1
a38 2


d41 3
a43 1
#include <string.h>
d46 1
d88 1
a88 1
#define SHDR_O(m)	offsetof(struct scloud_specific, m)
@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1998-2005 United States Government as represented by
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.9 2005/03/28 06:31:37 bob1961 Exp $ (ARL)";
@


14.9
log
@Add code to allow liboptical to be a Windows DLL
@
text
@d27 1
a27 1
 *  
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.8 2005/01/30 20:30:55 brlcad Exp $ (ARL)";
d139 2
a140 2
                           
             	         
d142 2
a143 2
             		     
           		      
d293 1
a293 1
	 * and transform them into "shader space" coordinates 
d311 1
a311 1
	 * "lacunarity" factor.  To sample this space adequately we need 
d343 1
a343 1
		val = bn_noise_turb(pt, scloud_sp->h_val, 
d367 1
a367 1
			/* compute how much light has arrived at 
@


14.9.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d27 1
a27 1
 *
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d139 2
a140 2


d142 2
a143 2


d293 1
a293 1
	 * and transform them into "shader space" coordinates
d311 1
a311 1
	 * "lacunarity" factor.  To sample this space adequately we need
d343 1
a343 1
		val = bn_noise_turb(pt, scloud_sp->h_val,
d367 1
a367 1
			/* compute how much light has arrived at
@


14.8
log
@update copyright to 2005
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_scloud.c,v 14.7 2004/12/21 07:32:30 morrison Exp $ (ARL)";
a47 2
#include "shadefuncs.h"
#include "shadework.h"
@


14.7
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 United States Government as represented by
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_scloud.c,v 14.6 2004/12/21 06:58:42 morrison Exp $ (ARL)";
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a30 2
 *  
 *
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_scloud.c,v 14.5 2004/12/21 06:44:33 morrison Exp $ (ARL)";
@


14.5
log
@remove the old distribution notice section
@
text
@a32 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_scloud.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a31 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_scloud.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_scloud.c,v 14.2 2004/12/21 04:03:25 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_scloud.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *	S H _ S C L O U D . C
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_scloud.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (ARL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_scloud.c,v 1.1 2004/05/20 15:19:51 morrison Exp $ (ARL)";
d418 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_scloud.c,v 1.34 2004/05/10 15:30:45 erikg Exp $ (ARL)";
d26 1
a26 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

