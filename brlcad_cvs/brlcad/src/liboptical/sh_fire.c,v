head	14.17;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.9
	rel-7-10-2:14.15
	rel-7-10-0:14.15
	rel-7-8-4:14.12
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.6
	rel-7-6-0:14.9
	rel-7-4-2:14.9
	rel-7-4-branch:14.9.0.4
	bobWinPort:14.9.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.9
	rel-7-2-4:14.9
	rel-7-2-2:14.9
	rel-7-2-0:14.8
	rel-7-0-4:14.7
	rel-7-0-2:14.7
	rel-7-0-1:14.7
	opensource-post:14.7
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.17
date	2007.12.16.18.53.49;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.09.15.16.23.11;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.53;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.23.00.35.08;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.03.28.06.31.28;	author bob1961;	state Exp;
branches
	14.9.6.1;
next	14.8;

14.8
date	2005.01.30.20.30.54;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.32.30;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.33;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.03.25;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.50;	author morrison;	state Exp;
branches;
next	;

14.9.6.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.17
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                       S H _ F I R E . C
 * BRL-CAD
 *
 * Copyright (c) 1997-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file sh_fire.c
 *
 *  Fire shader
 *
 *  Parameters:
 *
 *	flicker=rate	Specifies rate of translation through noise space
 *			for animation.  swp->frametime * flicker gives a delta
 *			in Z of noise space for animation.  Useful values
 *			probably in range 0 > flicker > 10
 *
 *	stretch=dist	Specifies a scaling of the exponential stretch of the
 *			flames.  flame stretch = e^(pos[Z] * -stretch)
 *
 *
 *  Standard fbm parameters:
 *
 *	lacunarity	Scale between different levels of noise detail
 *
 *	octaves		Number of different levels of noise to add to get
 *				structure of the flames.
 *
 *	h_val		power for frequency (usually 1)
 *
 *	scale		3-tuple which scales noise WRT shader space:
 *			"how big is the largest noise frequency on object"
 *
 *	delta		3-tuple specifying origin delta in noise space:
 *			"what piece of noise space maps to shader origin"
 *
 *  Usage:
 *	mged> shader flame.r {fire {st 1.25}}
 *
 *	Note:  The fire shader provides its own color.  It does not read any
 *		color information from the region definition.
 *
 *  Author -
 *	Lee A. Butler
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.16 2007/09/15 16:23:11 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"

extern int rr_render(struct application	*ap,
		     struct partition	*pp,
		     struct shadework   *swp);
#define fire_MAGIC 0x46697265   /* ``Fire'' */
#define CK_fire_SP(_p) BU_CKMAG(_p, fire_MAGIC, "fire_specific")

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct fire_specific {
	long	magic;	/* magic # for memory validity check, must come 1st */
	int	fire_debug;
	double	fire_flicker;		/* flicker rate */
	double	fire_stretch;
	double	noise_lacunarity;
	double	noise_h_val;
	double	noise_octaves;
	double	noise_size;
	vect_t	noise_vscale;
	vect_t	noise_delta;
				/* the following values are computed */
	point_t fire_min;
	point_t fire_max;
	mat_t	fire_m_to_sh;		/* model to shader space matrix */
	mat_t	fire_sh_to_noise;	/* shader to noise space matrix */
	mat_t	fire_colorspline_mat;
};

/* The default values for the variables in the shader specific structure */
static const
struct fire_specific fire_defaults = {
	fire_MAGIC,
	0,			/* fire_debug */
	1.0,			/* fire flicker rate */
	0.0,			/* fire_stretch */
	2.1753974,		/* noise_lacunarity */
	1.0,			/* noise_h_val */
	2.0,			/* noise_octaves */
	-1.0,			/* noise_size */
	{ 10.0, 10.0, 10.0 },	/* noise_vscale */
	{ 0.0, 0.0, 0.0 },	/* noise_delta */
	{ 0.0, 0.0, 0.0 },	/* fire_min */
	{ 0.0, 0.0, 0.0 },	/* fire_max */

	{	/* fire_m_to_sh */
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0 },
	{	/* fire_sh_to_noise */
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0 },
	{	/* fire_colorspline_mat */
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0,
		0.0, 0.0, 0.0, 0.0 }
	};

#define SHDR_NULL	((struct fire_specific *)0)
#define SHDR_O(m)	bu_offsetof(struct fire_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct fire_specific, m)


/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above
 */
struct bu_structparse fire_print_tab[] = {
	{"%d",  1, "debug",	SHDR_O(fire_debug),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "flicker",	SHDR_O(fire_flicker),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "stretch",	SHDR_O(fire_stretch),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "lacunarity", SHDR_O(noise_lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 	SHDR_O(noise_h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "octaves", 	SHDR_O(noise_octaves),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "scale",	SHDR_O(noise_size),		bu_mm_cvt },
	{"%f",  3, "vscale",	SHDR_AO(noise_vscale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "delta",	SHDR_AO(noise_delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3,  "max",	SHDR_AO(fire_max),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	3,  "min",	SHDR_AO(fire_min),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }

};
struct bu_structparse fire_parse_tab[] = {
	{"i",	bu_byteoffset(fire_print_tab[0]), "fire_print_tab", 0, BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "f",		SHDR_O(fire_flicker),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "st",	SHDR_O(fire_stretch),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "l",		SHDR_O(noise_lacunarity),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "H", 	SHDR_O(noise_h_val),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "o", 	SHDR_O(noise_octaves),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "s",		SHDR_O(noise_size),		bu_mm_cvt },
	{"%f",  3, "v",		SHDR_AO(noise_vscale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "vs",	SHDR_AO(noise_vscale),		BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  3, "d",		SHDR_AO(noise_delta),		BU_STRUCTPARSE_FUNC_NULL },
	{"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
};

HIDDEN int	fire_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), fire_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	fire_print(register struct region *rp, char *dp), fire_free(char *cp);

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs fire_mfuncs[] = {
	{MF_MAGIC,	"fire",		0,		MFI_HIT,	0,
	fire_setup,	fire_render,	fire_print,	fire_free },

	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
};

const double flame_colors[18][3] = {
	{0.0, 0.0, 0.0},
	{0.0, 0.0, 0.0},
	{0.106, 0.0, 0.0},
	{0.212, 0.0, 0.0},
	{0.318, 0.0, 0.0},
	{0.427, 0.0, 0.0},
	{0.533, 0.0, 0.0},
	{0.651, 0.02, 0.0},
	{0.741, 0.118, 0.0},
	{0.827, 0.235, 0.0},
	{0.906, 0.353, 0.0},
	{0.933, 0.500, 0.0},
	{0.957, 0.635, 0.047},
	{0.973, 0.733, 0.227},
	{0.984, 0.820, 0.451},
	{0.990, 0.925, 0.824},
	{1.0, 0.945, 0.902},
	{1.0, 0.945, 0.902}
};

/*	F I R E _ S E T U P
 *
 *	This routine is called (at prep time)
 *	once for each region which uses this shader.
 *	Any shader-specific initialization should be done here.
 */
HIDDEN int
fire_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip)


				/* pointer to reg_udata in *rp */

				/* New since 4.4 release */
{
	register struct fire_specific	*fire_sp;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);


	if (rdebug&RDEBUG_SHADE)
		bu_log("fire_setup(%s)\n", rp->reg_name);

	/* Get memory for the shader parameters and shader-specific data */
	BU_GETSTRUCT( fire_sp, fire_specific );
	*dpp = (char *)fire_sp;

	/* initialize the default values for the shader */
	memcpy(fire_sp, &fire_defaults, sizeof(struct fire_specific));

	/* parse the user's arguments for this use of the shader. */
	if (bu_struct_parse( matparm, fire_parse_tab, (char *)fire_sp ) < 0 )
		return(-1);

	if (fire_sp->noise_size != -1.0) {
		VSETALL(fire_sp->noise_vscale, fire_sp->noise_size);
	}

	/*
	 * The shader needs to operate in a coordinate system which stays
	 * fixed on the region when the region is moved (as in animation).
	 * We need to get a matrix to perform the appropriate transform(s).
	 */

	db_shader_mat(fire_sp->fire_m_to_sh, rtip, rp, fire_sp->fire_min,
		fire_sp->fire_max, &rt_uniresource);

	/* Build matrix to map shader space to noise space.
	 * XXX If only we could get the frametime at this point
	 * we could factor the flicker of flames into this matrix
	 * rather than having to recompute it on a pixel-by-pixel basis.
	 */
	MAT_IDN(fire_sp->fire_sh_to_noise);
	MAT_DELTAS_VEC(fire_sp->fire_sh_to_noise, fire_sp->noise_delta);
	MAT_SCALE_VEC(fire_sp->fire_sh_to_noise, fire_sp->noise_vscale);

	/* get matrix for performing spline of fire colors */
	rt_dspline_matrix(fire_sp->fire_colorspline_mat, "Catmull", 0.5, 0.0);


	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		bu_struct_print( " FIRE Parameters:", fire_print_tab, (char *)fire_sp );
		bn_mat_print( "m_to_sh", fire_sp->fire_m_to_sh );
		bn_mat_print( "sh_to_noise", fire_sp->fire_sh_to_noise );
		bn_mat_print( "colorspline", fire_sp->fire_colorspline_mat );
	}

	return(1);
}

/*
 *	F I R E _ P R I N T
 */
HIDDEN void
fire_print(register struct region *rp, char *dp)
{
	bu_struct_print( rp->reg_name, fire_print_tab, (char *)dp );
}

/*
 *	F I R E _ F R E E
 */
HIDDEN void
fire_free(char *cp)
{
	bu_free( cp, "fire_specific" );
}

/*
 *	F I R E _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 */
int
fire_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)


				/* defined in material.h */
				/* ptr to the shader-specific struct */
{
#define DEBUG_SPACE_PRINT(str, i_pt, o_pt) \
	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) { \
		bu_log("fire_render() %s space \n", str); \
		bu_log("fire_render() i_pt(%g %g %g)\n", V3ARGS(i_pt) ); \
		bu_log("fire_render() o_pt(%g %g %g)\n", V3ARGS(o_pt) ); \
	}

#define	SHADER_TO_NOISE(n_pt, sh_pt, fire_sp, zdelta) { \
	point_t tmp_pt; \
	tmp_pt[X] = sh_pt[X]; \
	tmp_pt[Y] = sh_pt[Y]; \
	if ( ! NEAR_ZERO(fire_sp->fire_stretch, SQRT_SMALL_FASTF) ) \
		tmp_pt[Z] = exp( (sh_pt[Z]+0.125) * -fire_sp->fire_stretch ); \
	else \
		tmp_pt[Z] = sh_pt[Z]; \
	MAT4X3PNT(n_pt, fire_sp->fire_sh_to_noise, tmp_pt); \
	n_pt[Z] += zdelta; \
}

	register struct fire_specific *fire_sp =
		(struct fire_specific *)dp;
	point_t	m_i_pt, m_o_pt;	/* model space in/out points */
	point_t sh_i_pt, sh_o_pt;	/* shader space in/out points */
	point_t noise_i_pt, noise_o_pt;	/* shader space in/out points */
	point_t noise_pt;
	point_t	color;
	vect_t	noise_r_dir;
	double	noise_r_thick;
	int	i;
	double	samples_per_unit_noise;
	double	noise_dist_per_sample;
	point_t	shader_pt;
	vect_t	shader_r_dir;
	double	shader_r_thick;
	double	shader_dist_per_sample;
	double	noise_zdelta;

	int	samples;
	double	dist;
	double	noise_val;
	double	lumens;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_fire_SP(fire_sp);

	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
/*		bu_struct_print( "fire_render Parameters:", fire_print_tab, (char *)fire_sp ); */
		bu_log("fire_render()\n");
	}
	/* If we are performing the shading in "region" space, we must
	 * transform the hit point from "model" space to "region" space.
	 * See the call to db_region_mat in fire_setup().
	 */

	/*
	 * Compute the ray/solid in and out points,
	 */
	VMOVE(m_i_pt, swp->sw_hit.hit_point);
	VJOIN1(m_o_pt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
	DEBUG_SPACE_PRINT("model", m_i_pt, m_o_pt);

	/* map points into shader space */
	MAT4X3PNT(sh_i_pt, fire_sp->fire_m_to_sh, m_i_pt);
	MAT4X3PNT(sh_o_pt, fire_sp->fire_m_to_sh, m_o_pt);
	DEBUG_SPACE_PRINT("shader", sh_i_pt, sh_o_pt);

	noise_zdelta = fire_sp->fire_flicker * swp->sw_frametime;

	SHADER_TO_NOISE(noise_i_pt, sh_i_pt, fire_sp, noise_zdelta);
	SHADER_TO_NOISE(noise_o_pt, sh_o_pt, fire_sp, noise_zdelta);

	VSUB2(noise_r_dir, noise_o_pt, noise_i_pt);

	noise_r_thick = MAGNITUDE(noise_r_dir);

	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		bu_log("fire_render() noise_r_dir (%g %g %g)\n",
			V3ARGS(noise_r_dir) );
		bu_log("fire_render() noise_r_thick %g\n", noise_r_thick);
	}


	/* compute number of samples per unit length in noise space.
	 *
	 * The noise field used by the bn_noise_turb and bn_noise_fbm routines
	 * has a maximum frequency of about 1 cycle per integer step in
	 * noise space.  Each octave increases this frequency by the
	 * "lacunarity" factor.  To sample this space adequately, nyquist
	 * tells us we need at least 4 samples/cycle at the highest octave
	 * rate.
	 */

	samples_per_unit_noise =
		pow(fire_sp->noise_lacunarity, fire_sp->noise_octaves-1) * 4.0;

	noise_dist_per_sample = 1.0 / samples_per_unit_noise;

	samples = samples_per_unit_noise * noise_r_thick;

	if (samples < 1) samples = 1;

	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug ) {
		bu_log("samples:%d\n", samples);
		bu_log("samples_per_unit_noise %g\n", samples_per_unit_noise);
		bu_log("noise_dist_per_sample %g\n", noise_dist_per_sample);
	}

	/* To do the exponential stretch and decay properly we need to
	 * do the computations in shader space, and convert the points
	 * to noise space.  Performance pig.
	 */

	VSUB2(shader_r_dir, sh_o_pt, sh_i_pt);
	shader_r_thick = MAGNITUDE(shader_r_dir);
	VUNITIZE(shader_r_dir);

	shader_dist_per_sample = shader_r_thick / samples;

	lumens = 0.0;
	for (i = 0 ; i < samples ; i++) {
		dist = (double)i * shader_dist_per_sample;
		VJOIN1(shader_pt, sh_i_pt, dist, shader_r_dir);

		SHADER_TO_NOISE(noise_pt, shader_pt, fire_sp, noise_zdelta);

		noise_val = bn_noise_turb(noise_pt, fire_sp->noise_h_val,
			fire_sp->noise_lacunarity, fire_sp->noise_octaves);

		if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
			bu_log("bn_noise_turb(%g %g %g) = %g\n",
				V3ARGS(noise_pt),
				noise_val);

		/* XXX
		 * When doing the exponential stretch, we scale the noise
		 * value by the height in shader space
		 */

		if ( NEAR_ZERO(fire_sp->fire_stretch, SQRT_SMALL_FASTF) )
			lumens += noise_val * 0.025;
		else {
			register double t;
			t = lumens;
			lumens += noise_val * 0.025 *  (1.0 -shader_pt[Z]);
			if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
				bu_log("lumens:%g = %g + %g * %g\n",
					lumens, t, noise_val,
					0.025 * (1.0 - shader_pt[Z]) );

		}
		if (lumens >= 1.0) {
			lumens = 1.0;
			if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
				bu_log("early exit from lumens loop\n");
			break;
		}

	}

	if (rdebug&RDEBUG_SHADE || fire_sp->fire_debug )
		bu_log("lumens = %g\n", lumens);

	if (lumens < 0.0) lumens = 0.0;
	else if (lumens > 1.0) lumens = 1.0;


	rt_dspline_n(color, fire_sp->fire_colorspline_mat, (double *)flame_colors,
		18, 3, lumens);

	VMOVE(swp->sw_color, color);
/*	VSETALL(swp->sw_basecolor, 1.0);*/

	swp->sw_transmit = 1.0 - (lumens * 4.);
	if (swp->sw_reflect > 0 || swp->sw_transmit > 0 )
		(void)rr_render( ap, pp, swp );

	return(1);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d64 1
a64 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.15 2007/01/27 01:41:37 brlcad Exp $ (ARL)";
d249 1
a249 1
	memcpy(fire_sp, &fire_defaults, sizeof(struct fire_specific) );
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d64 1
a64 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.14 2007/01/23 01:13:36 brlcad Exp $ (ARL)";
d71 1
a71 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d64 1
a64 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.13 2007/01/20 14:36:53 brlcad Exp $ (ARL)";
a149 1

d233 1
a233 1
    			      	/* pointer to reg_udata in *rp */
d235 1
a235 1
           		      	/* New since 4.4 release */
a284 1

d324 2
a325 2
                	     	/* defined in material.h */
    			    	/* ptr to the shader-specific struct */
@


14.13
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d64 1
a64 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.12 2006/01/23 00:35:08 brlcad Exp $ (ARL)";
@


14.12
log
@include stddef.h for bu_offset's usage of offset
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2006 United States Government as represented by
d65 1
a65 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.11 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
@


14.11
log
@update copyright to 2006
@
text
@d65 1
a65 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.10 2005/10/23 04:44:34 brlcad Exp $ (ARL)";
d70 1
a70 2


d73 3
a75 1
#include <string.h>
d78 1
d147 1
a147 1
#define SHDR_O(m)	offsetof(struct fire_specific, m)
@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1997-2005 United States Government as represented by
d65 1
a65 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.9 2005/03/28 06:31:28 bob1961 Exp $ (ARL)";
@


14.9
log
@Add code to allow liboptical to be a Windows DLL
@
text
@d59 1
a59 1
 *  
d65 1
a65 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.8 2005/01/30 20:30:54 brlcad Exp $ (ARL)";
d231 2
a232 2
                      	    
             		         
d234 1
a234 1
             		     
d274 1
a274 1
	 * we could factor the flicker of flames into this matrix 
d323 2
a324 2
                  	    
                	    
d379 1
a379 1
	/* If we are performing the shading in "region" space, we must 
d437 1
a437 1
	/* To do the exponential stretch and decay properly we need to 
d488 1
a488 1
	
@


14.9.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d59 1
a59 1
 *
d65 1
a65 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d231 2
a232 2


d234 1
a234 1

d274 1
a274 1
	 * we could factor the flicker of flames into this matrix
d323 2
a324 2


d379 1
a379 1
	/* If we are performing the shading in "region" space, we must
d437 1
a437 1
	/* To do the exponential stretch and decay properly we need to
d488 1
a488 1

@


14.8
log
@update copyright to 2005
@
text
@d65 1
a65 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_fire.c,v 14.7 2004/12/21 07:32:30 morrison Exp $ (ARL)";
a79 2
#include "shadefuncs.h"
#include "shadework.h"
@


14.7
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2004 United States Government as represented by
d65 1
a65 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_fire.c,v 14.6 2004/12/21 06:58:42 morrison Exp $ (ARL)";
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a62 2
 *  
 *
d65 1
a65 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_fire.c,v 14.5 2004/12/21 06:44:33 morrison Exp $ (ARL)";
@


14.5
log
@remove the old distribution notice section
@
text
@a64 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_fire.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a63 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
d70 1
a70 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_fire.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_fire.c,v 14.2 2004/12/21 04:03:25 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_fire.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *	S H _ F I R E . C
d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_fire.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (ARL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_fire.c,v 1.1 2004/05/20 15:19:50 morrison Exp $ (ARL)";
d500 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_fire.c,v 1.34 2004/05/10 15:30:45 erikg Exp $ (ARL)";
d58 1
a58 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

