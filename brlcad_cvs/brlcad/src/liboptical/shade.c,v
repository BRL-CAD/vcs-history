head	14.18;
access;
symbols
	rel-7-10-4:14.17
	STABLE:14.17.0.2
	stable-branch:14.8
	rel-7-10-2:14.17
	rel-7-10-0:14.17
	rel-7-8-4:14.14
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.11
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.11
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.6
	rel-7-6-0:14.8
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.4
	bobWinPort:14.8.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.18
date	2007.12.17.02.16.54;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.27.01.41.38;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.36.53;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.07.31.15.16.40;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.04.06.20.06.48;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2005.10.31.23.41.37;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.09.19.18.34.13;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.03.30.07.14.09;	author brlcad;	state Exp;
branches
	14.8.6.1;
next	14.7;

14.7
date	2005.03.28.06.31.37;	author bob1961;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.56;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.03.25;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.52;	author morrison;	state Exp;
branches;
next	;

14.8.6.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2006.04.07.19.30.22;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.18
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@/*                         S H A D E . C
 * BRL-CAD
 *
 * Copyright (c) 1989-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file shade.c
 *
 *	Ray Tracing program, lighting model shader interface.
 *
 *  Notes -
 *	The normals on all surfaces point OUT of the solid.
 *	The incomming light rays point IN.
 *
 *  Authors -
 *	Michael John Muuss
 *	Phil Dykstra
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#ifndef lint
static const char RCSview[] = "@@(#)$Header:";
#endif

#include "common.h"

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "bu.h"
#include "bn.h"
#include "vmath.h"
#include "raytrace.h"
#include "optical.h"
#include "rtprivate.h"
#include "light.h"
#include "plot3.h"

#ifdef RT_MULTISPECTRAL
#  include "spectrum.h"
#endif


/*
 *			P R _ S H A D E W O R K
 *
 *  Pretty print a shadework structure.
 */
void
pr_shadework( str, swp )
const char *str;
register const struct shadework *swp;
{
	int	i;

	bu_log( "Shadework %s: 0x%x\n", str, swp );
	bu_printb( " sw_inputs", swp->sw_inputs, MFI_FORMAT );
	if (swp->sw_inputs && MFI_HIT)
		bu_log( " sw_hit.dist:%g  sw_hit.point(%g %g %g)\n",
			swp->sw_hit.hit_dist,
			V3ARGS(swp->sw_hit.hit_point));
	else
		bu_log( " sw_hit.dist:%g\n", swp->sw_hit.hit_dist);

	if (swp->sw_inputs && MFI_NORMAL)
		bu_log(" sw_hit.normal(%g %g %g)\n",
			V3ARGS(swp->sw_hit.hit_normal));


	bu_log( " sw_transmit %f\n", swp->sw_transmit );
	bu_log( " sw_reflect %f\n", swp->sw_reflect );
	bu_log( " sw_refract_index %f\n", swp->sw_refrac_index );
	bu_log( " sw_extinction %f\n", swp->sw_extinction );
#ifdef RT_MULTISPECTRAL
	bn_pr_tabdata( "msw_color", swp->msw_color );
	bn_pr_tabdata( "msw_basecolor", swp->msw_basecolor );
#else
	VPRINT( " sw_color", swp->sw_color );
	VPRINT( " sw_basecolor", swp->sw_basecolor );
#endif
	bu_log( " sw_uv  %f %f\n", swp->sw_uv.uv_u, swp->sw_uv.uv_v );
	bu_log( " sw_dudv  %f %f\n", swp->sw_uv.uv_du, swp->sw_uv.uv_dv );
	bu_log( " sw_xmitonly %d\n", swp->sw_xmitonly );
	bu_log( "\n");
	if( swp->sw_inputs & MFI_LIGHT ) for( i=0; i < SW_NLIGHTS; i++ )  {
		if( swp->sw_visible[i] == (struct light_specific *)NULL )  continue;
		RT_CK_LIGHT( swp->sw_visible[i] );
#ifdef RT_MULTISPECTRAL
		bu_log("   light %d visible, dir=(%g,%g,%g)\n",
			i,
			V3ARGS(&swp->sw_tolight[i*3]) );
		BN_CK_TABDATA(swp->msw_intensity[i]);
		bn_pr_tabdata("light intensity", swp->msw_intensity[i] );
#else
		bu_log("   light %d visible, intensity=%g, dir=(%g,%g,%g)\n",
			i,
			swp->sw_intensity[i],
			V3ARGS(&swp->sw_tolight[i*3]) );
#endif
	}
}


/*
 *			S H A D E _ I N P U T S
 *
 *  Compute the necessary fields in the shadework structure.
 *
 *  Note that only hit_dist is valid in pp_inhit.
 *  Must calculate it if hit_norm is needed,
 *  after which pt_inflip must be handled.
 *  RT_HIT_UVCOORD() must have hit_point computed
 *  in advance.
 *
 *  If MFI_LIGHT is not on, the presumption is that the sw_visible[]
 *  array is not needed, or has been handled elsewhere.
 */
void
shade_inputs( struct application *ap, const struct partition *pp, struct shadework *swp, int want )
{
	register int	have;

	RT_CK_RAY( swp->sw_hit.hit_rayp );

	/* These calcuations all have MFI_HIT as a pre-requisite */
	if( want & (MFI_NORMAL|MFI_LIGHT|MFI_UV) )
		want |= MFI_HIT;

	have = swp->sw_inputs;
	want &= ~have;		/* we don't want what we already have */

	if( want & MFI_HIT )  {
		VJOIN1( swp->sw_hit.hit_point, ap->a_ray.r_pt,
			swp->sw_hit.hit_dist, ap->a_ray.r_dir );
		have |= MFI_HIT;
	}

	if( want & MFI_NORMAL )  {
		if( pp->pt_inhit->hit_dist < 0.0 )  {
			/* Eye inside solid, orthoview */
			VREVERSE( swp->sw_hit.hit_normal, ap->a_ray.r_dir );
		} else {
			register fastf_t f;
			/* Get surface normal for hit point */
			/* Stupid SysV CPP needs this on one line */
			RT_HIT_NORMAL( swp->sw_hit.hit_normal, &(swp->sw_hit), pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip );

#ifdef never
			if( swp->sw_hit.hit_normal[X] < -1.01 || swp->sw_hit.hit_normal[X] > 1.01 ||
			    swp->sw_hit.hit_normal[Y] < -1.01 || swp->sw_hit.hit_normal[Y] > 1.01 ||
			    swp->sw_hit.hit_normal[Z] < -1.01 || swp->sw_hit.hit_normal[Z] > 1.01 )  {
				VPRINT("shade_inputs: N", swp->sw_hit.hit_normal);
				VSET( swp->sw_color, 9, 9, 0 );	/* Yellow */
				return;
			}
#endif
			/* Check to make sure normals are OK */
			f = VDOT(ap->a_ray.r_dir,swp->sw_hit.hit_normal);
			if (f > 0.0 &&
			    !BN_VECT_ARE_PERP(f, &(ap->a_rt_i->rti_tol))) {
			    static int counter = 0;
			    if (counter++ < 100 || (R_DEBUG&RDEBUG_SHADE)) {
				bu_log("shade_inputs(%s) flip N xy=%d,%d %s surf=%d dot=%g\n",
				       pp->pt_inseg->seg_stp->st_name,
				       ap->a_x, ap->a_y,
				       rt_functab[pp->pt_inseg->seg_stp->st_id].ft_name,
				       swp->sw_hit.hit_surfno, f);
			    } else {
				if (counter++ == 101) {
				    bu_log("shade_inputs(%s) flipped normals detected, additional reporting suppressed\n",
					   pp->pt_inseg->seg_stp->st_name);
				}
			    }
			    if( R_DEBUG&RDEBUG_SHADE ) {
				VPRINT("Dir ", ap->a_ray.r_dir);
				VPRINT("Norm", swp->sw_hit.hit_normal);
			    }
			    /* reverse the normal so it's lit */
			    VREVERSE(swp->sw_hit.hit_normal, swp->sw_hit.hit_normal);
			}
		}
		if( R_DEBUG&(RDEBUG_RAYPLOT|RDEBUG_SHADE) )  {
			point_t		endpt;
			fastf_t		f;
			/* Plot the surface normal -- green/blue */
			/* plotfp */
			f = ap->a_rt_i->rti_radius * 0.02;
			VJOIN1( endpt, swp->sw_hit.hit_point,
				f, swp->sw_hit.hit_normal );
			if(R_DEBUG&RDEBUG_RAYPLOT)  {
				bu_semaphore_acquire( BU_SEM_SYSCALL );
				pl_color( stdout, 0, 255, 255 );
				pdv_3line( stdout, swp->sw_hit.hit_point, endpt );
				bu_semaphore_release( BU_SEM_SYSCALL );
			}
			bu_log("Surface normal for shader:\n\
hit pt: %g %g %g end pt: %g %g %g\n",
				V3ARGS(swp->sw_hit.hit_point),
				V3ARGS(endpt) );

		}
		have |= MFI_NORMAL;
	}
	if( want & MFI_UV )  {
		if( pp->pt_inhit->hit_dist < 0.0 )  {
			/* Eye inside solid, orthoview */
			swp->sw_uv.uv_u = swp->sw_uv.uv_v = 0.5;
			swp->sw_uv.uv_du = swp->sw_uv.uv_dv = 0;
		} else {
			RT_HIT_UVCOORD(	ap, pp->pt_inseg->seg_stp,
				&(swp->sw_hit), &(swp->sw_uv) );
		}
		if( swp->sw_uv.uv_u < 0 || swp->sw_uv.uv_u > 1 ||
		    swp->sw_uv.uv_v < 0 || swp->sw_uv.uv_v > 1 )  {
			bu_log("shade_inputs:  bad u,v=%e,%e du,dv=%g,%g seg=%s %s surf=%d. xy=%d,%d Making green.\n",
				swp->sw_uv.uv_u, swp->sw_uv.uv_v,
				swp->sw_uv.uv_du, swp->sw_uv.uv_dv,
				pp->pt_inseg->seg_stp->st_name,
				rt_functab[pp->pt_inseg->seg_stp->st_id].ft_name,
				pp->pt_inhit->hit_surfno,
				ap->a_x, ap->a_y );
#ifdef RT_MULTISPECTRAL
			{
				static const float green[3] = {0.0f,9.0f,0.0f};
				rt_spect_reflectance_rgb( swp->msw_color, green );
			}
#else
			VSET( swp->sw_color, 0, 9, 0 );	/* Hyper-Green */
#endif

			return;
		}
		have |= MFI_UV;
	}
	/* NOTE:  Lee has changed the shaders to do light themselves now. */
	/* This isn't where light visibility is determined any more. */
	if( want & MFI_LIGHT )  {
	light_obs(ap, swp, have);
		have |= MFI_LIGHT;
	}

	/* Record which fields were filled in */
	swp->sw_inputs = have;

	if( (want & have) != want )
		bu_log("shade_inputs:  unable to satisfy request for x%x\n", want);
}

/*
 *			V I E W S H A D E
 *
 *  Call the material-specific shading function, after making certain
 *  that all shadework fields desired have been provided.
 *
 *  Returns -
 *	0 on failure
 *	1 on success
 *
 *	But of course, nobody cares what this returns.
 *	Everyone calls us as (void)viewshade()
 */
int
viewshade( struct application *ap, const struct partition *pp, struct shadework *swp )
{
	register const struct mfuncs *mfp;
	register const struct region *rp;
	struct light_specific *lp;
	register int	want;

	RT_AP_CHECK(ap);
	RT_CK_RTI(ap->a_rt_i);
	RT_CK_PT(pp);
	RT_CK_HIT(pp->pt_inhit);
	RT_CK_RAY(pp->pt_inhit->hit_rayp);
	rp = pp->pt_regionp;
	RT_CK_REGION(rp);
	mfp = (struct mfuncs *)pp->pt_regionp->reg_mfuncs;
	RT_CK_MF(mfp);

	want = mfp->mf_inputs;

	if( R_DEBUG&RDEBUG_SHADE ) {
		bu_log("viewshade(%s)\n Using \"%s\" shader, ",
			rp->reg_name, mfp->mf_name);
		bu_printb( "mfp_inputs", want, MFI_FORMAT );
		bu_log( "\n");
	}

	swp->sw_hit = *(pp->pt_inhit);		/* struct copy */

#ifdef RT_MULTISPECTRAL
	/* XXX where does region get reflectance?  Default temperature? */
	BN_CK_TABDATA(swp->msw_color);
	BN_CK_TABDATA(swp->msw_basecolor);
	if( rp->reg_mater.ma_color_valid )  {
		rt_spect_reflectance_rgb( swp->msw_color, rp->reg_mater.ma_color );
	}
	bn_tabdata_copy(swp->msw_basecolor, swp->msw_color);
#else
	/* Default color is white (uncolored) */
	if( rp->reg_mater.ma_color_valid )  {
		VMOVE( swp->sw_color, rp->reg_mater.ma_color );
	}
	VMOVE( swp->sw_basecolor, swp->sw_color );
#endif

	if( swp->sw_hit.hit_dist < 0.0 )
		swp->sw_hit.hit_dist = 0.0;	/* Eye inside solid */
	ap->a_cumlen += swp->sw_hit.hit_dist;

	/* If light information is not needed, set the light
	 * array to "safe" values,
	 * and claim that the light is visible, in case they are used.
	 */
	if( swp->sw_xmitonly )  want &= ~MFI_LIGHT;
	if( !(want & MFI_LIGHT) )  {
		register int	i;

		/* sanity */
		i=0;
		for( BU_LIST_FOR( lp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lp);
			swp->sw_visible[i++] = lp;
		}
		for( ; i < SW_NLIGHTS; i++ )  {
			swp->sw_visible[i] = (struct light_specific *)NULL;
		}
	}

	/* If optional inputs are required, have them computed */
	if( want & (MFI_HIT|MFI_NORMAL|MFI_LIGHT|MFI_UV) )  {
		VJOIN1( swp->sw_hit.hit_point, ap->a_ray.r_pt,
			swp->sw_hit.hit_dist, ap->a_ray.r_dir );
		swp->sw_inputs |= MFI_HIT;
	}
	if( (swp->sw_inputs & want) != want )  {
		shade_inputs( ap, pp, swp, want );
	} else if( !(want & MFI_LIGHT) )  {
		register int	i;

		/* sanity */
		for( i = SW_NLIGHTS-1; i >= 0; i-- )  {
			swp->sw_visible[i] = (struct light_specific *)NULL;
		}
	}

	if( R_DEBUG&RDEBUG_SHADE ) {
		pr_shadework( "before mf_render", swp );
	}


	/* Invoke the actual shader (may be a tree of them) */
	(void)mfp->mf_render( ap, pp, swp, rp->reg_udata );

	if( R_DEBUG&RDEBUG_SHADE ) {
		pr_shadework( "after mf_render", swp );
		bu_log("\n");
	}

	return(1);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.17
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d161 1
a161 1
			FAST fastf_t f;
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a121 1

d170 1
a170 1
			    	VPRINT("shade_inputs: N", swp->sw_hit.hit_normal);
d237 2
a238 2
		    		rt_functab[pp->pt_inseg->seg_stp->st_id].ft_name,
		    		pp->pt_inhit->hit_surfno,
d241 2
a242 2
		    	{
		    		static const float green[3] = {0.0f,9.0f,0.0f};
d244 1
a244 1
		    	}
@


14.15
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.14
log
@quell warning, takes floats not fastf_t's
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2006 United States Government as represented by
@


14.13
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d244 1
a244 1
		    		static const vect_t green = {0,9,0};
@


14.12
log
@update copyright to 2006
@
text
@d58 3
@


14.12.2.1
log
@update from HEAD
@
text
@a57 3
#ifdef RT_MULTISPECTRAL
#  include "spectrum.h"
#endif
@


14.11
log
@if the intersection normal that's returned is knowingly reversed, flip it (while still complaining).  this usually indicates a bug in the underlying primitive or a problem with the geometry itself, but rendering nothing/black is pretty worthless.  also, limit the number of shade_input messages about flipped normals to just 100 so as not to spew unnecessarily to the console and slowing down the raytrace.
@
text
@d4 1
a4 1
 * Copyright (C) 1989-2005 United States Government as represented by
@


14.10
log
@trailing ws
@
text
@d178 2
d183 1
a183 3
				       rt_functab[
                                         pp->pt_inseg->seg_stp->st_id
				       ].ft_name,
d185 4
a188 3
				if( R_DEBUG&RDEBUG_SHADE ) {
					VPRINT("Dir ", ap->a_ray.r_dir);
					VPRINT("Norm", swp->sw_hit.hit_normal);
d190 7
@


14.9
log
@sw_visible is light_specific
@
text
@d32 1
a32 1
 *  
d37 1
a37 1
 *  
d76 1
a76 1
			swp->sw_hit.hit_dist, 
d81 1
a81 1
	if (swp->sw_inputs && MFI_NORMAL) 
@


14.8
log
@consistency on the #ifdef inclusions of RT_MULTISPECTRAL, clean up the spectrum extern declarations now that spectrum is now a liboptical global.
@
text
@d49 2
d53 1
d59 1
d102 1
a102 1
		if( swp->sw_visible[i] == (char *)0 )  continue;
d136 1
a136 5
shade_inputs( ap, pp, swp, want )
struct application *ap;
register const struct partition *pp;
register struct shadework *swp;
register int	want;
d272 1
a272 4
viewshade( ap, pp, swp )
struct application *ap;
register const struct partition *pp;
register struct shadework *swp;
d276 1
a276 1
	register const struct light_specific *lp;
d332 1
a332 1
			swp->sw_visible[i++] = (char *)lp;
d335 1
a335 1
			swp->sw_visible[i] = (char *)NULL;
d352 1
a352 1
			swp->sw_visible[i] = (char *)NULL;
@


14.8.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d37 1
a37 1
 *
a48 2
#include "bu.h"
#include "bn.h"
a50 1
#include "optical.h"
a55 1

d72 1
a72 1
			swp->sw_hit.hit_dist,
d77 1
a77 1
	if (swp->sw_inputs && MFI_NORMAL)
d98 1
a98 1
		if( swp->sw_visible[i] == (struct light_specific *)NULL )  continue;
d132 5
a136 1
shade_inputs( struct application *ap, const struct partition *pp, struct shadework *swp, int want )
a177 2
			    static int counter = 0;
			    if (counter++ < 100 || (R_DEBUG&RDEBUG_SHADE)) {
d181 3
a183 1
				       rt_functab[pp->pt_inseg->seg_stp->st_id].ft_name,
d185 3
a187 4
			    } else {
				if (counter++ == 101) {
				    bu_log("shade_inputs(%s) flipped normals detected, additional reporting suppressed\n",
					   pp->pt_inseg->seg_stp->st_name);
a188 7
			    }
			    if( R_DEBUG&RDEBUG_SHADE ) {
				VPRINT("Dir ", ap->a_ray.r_dir);
				VPRINT("Norm", swp->sw_hit.hit_normal);
			    }
			    /* reverse the normal so it's lit */
			    VREVERSE(swp->sw_hit.hit_normal, swp->sw_hit.hit_normal);
d272 4
a275 1
viewshade( struct application *ap, const struct partition *pp, struct shadework *swp )
d279 1
a279 1
	struct light_specific *lp;
d335 1
a335 1
			swp->sw_visible[i++] = lp;
d338 1
a338 1
			swp->sw_visible[i] = (struct light_specific *)NULL;
d355 1
a355 1
			swp->sw_visible[i] = (struct light_specific *)NULL;
@


14.7
log
@Add code to allow liboptical to be a Windows DLL
@
text
@a44 2


d54 1
a54 1
#include "spectrum.h"
d86 1
a86 1
#if RT_MULTISPECTRAL
d100 1
a100 1
#if RT_MULTISPECTRAL
d231 1
a231 1
#if RT_MULTISPECTRAL
d303 1
a303 1
#if RT_MULTISPECTRAL
@


14.6
log
@update copyright to 2005
@
text
@a52 2
#include "shadefuncs.h"
#include "shadework.h"
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2004 United States Government as represented by
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a37 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			S H A D E . C
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d362 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

