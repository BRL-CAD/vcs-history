head	14.27;
access;
symbols
	rel-7-10-4:14.25
	STABLE:14.25.0.2
	stable-branch:14.11
	rel-7-10-2:14.20
	rel-7-10-0:14.16
	rel-7-8-4:14.13
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.12
	bobWinPort-20051223-freeze:14.11
	postmerge-20051223-bobWinPort:14.12
	premerge-20051223-bobWinPort:14.12
	rel-7-6-6:14.12
	rel-7-6-4:14.12
	rel-7-6-2:14.11
	rel-7-6-branch:14.11.0.6
	rel-7-6-0:14.11
	rel-7-4-2:14.11
	rel-7-4-branch:14.11.0.4
	bobWinPort:14.11.0.2
	rel-7-4-0:14.11
	rel-7-2-6:14.11
	rel-7-2-4:14.11
	rel-7-2-2:14.11
	rel-7-2-0:14.8
	rel-7-0-4:14.7
	rel-7-0-2:14.7
	rel-7-0-1:14.7
	opensource-post:14.7
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.27
date	2007.12.16.18.53.49;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.09.14.15.21.06;	author erikgreenwald;	state Exp;
branches;
next	14.25;

14.25
date	2007.09.11.00.29.40;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.09.10.19.32.41;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.09.04.20.44.47;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.09.04.18.39.42;	author erikgreenwald;	state Exp;
branches;
next	14.21;

14.21
date	2007.08.30.19.40.12;	author erikgreenwald;	state Exp;
branches;
next	14.20;

14.20
date	2007.04.15.03.46.22;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.04.15.03.40.45;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.04.15.03.24.50;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.04.15.03.21.08;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.35;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.53;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.03.28.23.39.17;	author brlcad;	state Exp;
branches
	14.11.6.1;
next	14.10;

14.10
date	2005.03.28.19.34.53;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.03.28.05.46.17;	author bob1961;	state Exp;
branches;
next	14.8;

14.8
date	2005.01.30.20.30.54;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.32.30;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.33;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.03.25;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.49;	author morrison;	state Exp;
branches;
next	;

14.11.6.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.27
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                     P H O T O N M A P . C
 * BRL-CAD
 *
 * Copyright (c) 2002-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file photonmap.c
 *			P H O T O N M A P. C
 *
 *  Implemention of Photon Mapping
 *
 *  Author -
 *	Justin L. Shumaker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#ifndef lint
static const char RCSphotonmap[] = "";
#endif

#include "common.h"

#include <stdlib.h>

#ifdef HAVE_ALARM
#  include <signal.h>
#endif

#include "photonmap.h"


#define	NRoot(x,y) exp(log(x)/y)	/* Not in Use */
int PHit(struct application *ap, struct partition *PartHeadp, struct seg *finished_segs);
void GetEstimate(vect_t irrad, point_t pos, vect_t normal, fastf_t rad, int np, int map, double max_rad, int centog, int min_np);
void Polar2Euclidian(vect_t Dir, vect_t Normal, double Theta, double Phi);
void LocatePhotons(struct PhotonSearch *Search, struct PNode *Root);


int			PM_Activated;
int			PM_Visualize;

struct	PhotonMap	*PMap[PM_MAPS];		/* Photon Map (KD-TREE) */
struct	Photon		*Emit[PM_MAPS];		/* Emitted Photons */
struct	Photon		CurPh;
vect_t			BBMin;			/* Min Bounding Box */
vect_t			BBMax;			/* Max Bounding Box */
int			Depth;			/* Used to determine how many times the photon has propogated */
int			PType;			/* Used to determine the type of Photon: Direct,Indirect,Specular,Caustic */
int			PInit;
int			EPL;			/* Emitted Photons For the Light */
int			EPS[PM_MAPS];		/* Emitted Photons For the Light */
int			ICSize;
double			ScaleFactor;
struct	IrradCache	*IC;			/* Irradiance Cache for Hypersampling */
char			*Map;			/* Used for Irradiance HyperSampling Cache */
int			GPM_IH;			/* Irradiance Hypersampling Toggle, 0=off, 1=on */
int			GPM_WIDTH;
int			GPM_HEIGHT;
int			GPM_RAYS;		/* Number of Sample Rays for each Direction in Irradiance Hemi */
double			GPM_ATOL;		/* Angular Tolerance for Photon Gathering */
struct	resource	*GPM_RTAB;		/* Resource Table for Multi-threading */
int			HitG,HitB;


/* Split so that equal numbers are above and below the splitting plane */
int FindMedian(struct Photon *List, int Num, int Axis) {
    int		i;
    fastf_t	Min,Max,Mean;

    Min= Max= List[0].Pos[Axis];
    for (i= 1; i < Num; i++) {
	if (List[i].Pos[Axis] < Min)
	    Min= List[i].Pos[Axis];
	if (List[i].Pos[Axis] > Max)
	    Max= List[i].Pos[Axis];
    }
    Mean= (Min+Max)/2.0;
    i= 0;
    while (List[i].Pos[Axis] < Mean && i < Num)
	i++;

    return i;
}


/* Generate a KD-Tree from a Flat Array of Photons */
void BuildTree(struct Photon *EList, int ESize, struct PNode *Root) {
    struct	Photon	*LList,*RList;
    vect_t		Min,Max;
    int			i,Axis,MedianIndex,LInd,RInd;


    /* Allocate memory for left and right lists */
    LList= (struct Photon*)bu_calloc(ESize, sizeof(struct Photon), "LList");
    RList= (struct Photon*)bu_calloc(ESize, sizeof(struct Photon), "RList");

    /* Find the Bounding volume of the Current list of photons */
    Min[0]= Max[0]= EList[0].Pos[0];
    Min[1]= Max[1]= EList[0].Pos[1];
    Min[2]= Max[2]= EList[0].Pos[2];
    for (i= 1; i < ESize; i++) {
	if (EList[i].Pos[0] < Min[0]) Min[0]= EList[i].Pos[0];
	if (EList[i].Pos[1] < Min[1]) Min[1]= EList[i].Pos[1];
	if (EList[i].Pos[2] < Min[2]) Min[2]= EList[i].Pos[2];
	if (EList[i].Pos[0] > Max[0]) Max[0]= EList[i].Pos[0];
	if (EList[i].Pos[1] > Max[1]) Max[1]= EList[i].Pos[1];
	if (EList[i].Pos[2] > Max[2]) Max[2]= EList[i].Pos[2];
    }

    /* Obtain splitting Axis, which is the largest dimension of the bounding volume */
    Max[0]-= Min[0];
    Max[1]-= Min[1];
    Max[2]-= Min[2];
    Axis= 0;
    if (Max[1] > Max[0] && Max[1] > Max[2]) Axis= 1;
    if (Max[2] > Max[0] && Max[2] > Max[1]) Axis= 2;

    /* Find Median Photon to splt by. */
    MedianIndex= FindMedian(EList,ESize,Axis);

    /* Build Left and Right Lists and make sure the Median Photon is not included in either list. */
    LInd= RInd= 0;
    for (i= 0; i < ESize; i++) {
	if (i != MedianIndex) {
	    if (EList[i].Pos[Axis] < EList[MedianIndex].Pos[Axis]) {
		LList[LInd++]= EList[i];
	    } else {
		RList[RInd++]= EList[i];
	    }
	    /*
	      if (EList[i].Pos[Axis] < Median.Pos[Axis]) {
	      LList[LInd++]= EList[i];
	      } else {
	      RList[RInd++]= EList[i];
	      }
	    */
	}
    }

    /* Store the Median Photon into the KD-Tree. */
    /*  bu_log("insertKD: %.3f,%.3f,%.3f\n",EList[MedianIndex].Pos[0],EList[MedianIndex].Pos[1],EList[MedianIndex].Pos[2]);*/
    Root->P= EList[MedianIndex];
    Root->P.Axis= Axis;
    Root->C= 0;

    /* With Left and Right if either contain any photons then repeat this process */
    /*  if (LInd) bu_log("Left Branch\n");*/
    if (LInd) {
	Root->L= (struct PNode*)bu_calloc(1, sizeof(struct PNode), "Root left");
	Root->L->L= 0;
	Root->L->R= 0;
	BuildTree(LList,LInd,Root->L);
    }
    /*  if (RInd) bu_log("Right Branch\n");*/
    if (RInd) {
	Root->R= (struct PNode*)bu_calloc(1, sizeof(struct PNode), "Root right");
	Root->R->L= 0;
	Root->R->R= 0;
	BuildTree(RList,RInd,Root->R);
    }

    bu_free(LList, "LList");
    bu_free(RList, "RList");
}


/* Places photon into flat array that wwill form the final kd-tree. */
void Store(point_t Pos, vect_t Dir, vect_t Normal, int Map) {
    struct	PhotonSearch	Search;
    int				i;

    /* If Importance Mapping is enabled, Check to see if the Photon is in an area that is considered important, if not then disregard it */
    if (Map != PM_IMPORTANCE && PMap[PM_IMPORTANCE]->StoredPhotons) {
	/* Do a KD-Tree lookup and if the photon is within a distance of sqrt(ScaleFactor) from the nearest importon then keep it, otherwise discard it */

	Search.RadSq= ScaleFactor;
	Search.Found= 0;
	Search.Max= 1;
	Search.Pos[0]= Pos[0];
	Search.Pos[1]= Pos[1];
	Search.Pos[2]= Pos[2];
	Search.Normal[0]= Normal[0];
	Search.Normal[1]= Normal[1];
	Search.Normal[2]= Normal[2];

	Search.List= (struct PSN*)bu_calloc(Search.Max, sizeof(struct PSN), "Search.List");
	LocatePhotons(&Search,PMap[PM_IMPORTANCE]->Root);
	bu_free(Search.List, "Search.List");

	if (!Search.Found) {
	    HitB++;
	    return;
	}
    }


    if (PMap[Map]->StoredPhotons < PMap[Map]->MaxPhotons) {
	HitG++;
	for (i= 0; i < 3; i++) {
	    /* Store Position, Direction, and Power of Photon */
	    Emit[Map][PMap[Map]->StoredPhotons].Pos[i]= Pos[i];
	    Emit[Map][PMap[Map]->StoredPhotons].Dir[i]= Dir[i];
	    Emit[Map][PMap[Map]->StoredPhotons].Normal[i]= Normal[i];
	    Emit[Map][PMap[Map]->StoredPhotons].Power[i]= CurPh.Power[i];
	}
	PMap[Map]->StoredPhotons++;
	/*
	  if (Map != PM_IMPORTANCE && PMap[PM_IMPORTANCE]->StoredPhotons < PMap[PM_IMPORTANCE]->MaxPhotons)
	  bu_log("Map2: %d, Size: %d\n",Map,PMap[Map]->StoredPhotons);
	*/
	/*
	  if (Map == PM_IMPORTANCE)
	  bu_log("Map: %d, Size: %d, [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",Map,PMap[Map]->StoredPhotons, Pos[0],Pos[1],Pos[2], CurPh.Power[0], CurPh.Power[1], CurPh.Power[2]);
	*/
    }

    /*
      bu_log("[%d][%d][%.3f,%.3f,%.3f]\n",Map,PMap[Map]->StoredPhotons,CurPh.Power[0],CurPh.Power[1],CurPh.Power[2]);
      if (!(PMap[Map]->StoredPhotons % 64))
      bu_log("[%d][%d][%.3f,%.3f,%.3f]\n",Map,PMap[Map]->StoredPhotons,Pos[0],Pos[1],Pos[2]);
    */
}


/* Compute a specular reflection */
void SpecularReflect(vect_t normal, vect_t rdir) {
    vect_t	d;
    fastf_t	dot;

    VSCALE(d,rdir,-1);
    dot= VDOT(d,normal);

    if (dot < 0.0f) {
	rdir[0]= rdir[1]= rdir[2]= 0;
    } else {
	VSCALE(rdir,normal,2*dot);
	VSUB2(rdir,rdir,d);
    }
}


/* Compute a random reflected diffuse direction */
void DiffuseReflect(vect_t normal, vect_t rdir) {
    /* Allow Photons to get a random direction at most 60 degrees to the normal */
    do {
#ifndef HAVE_DRAND48
	rdir[0]= 2.0*rand()/(double)RAND_MAX-1.0;
	rdir[1]= 2.0*rand()/(double)RAND_MAX-1.0;
	rdir[2]= 2.0*rand()/(double)RAND_MAX-1.0;
#else
	rdir[0]= 2.0*drand48()-1.0;
	rdir[1]= 2.0*drand48()-1.0;
	rdir[2]= 2.0*drand48()-1.0;
#endif
	VUNITIZE(rdir);
    } while (VDOT(rdir,normal) < 0.5);
}


/* Compute refracted ray given Incident Ray, Normal, and 2 refraction indices */
int Refract(vect_t I, vect_t N, fastf_t n1, fastf_t n2) {
    fastf_t	n,c1,c2,radicand;
    vect_t	t,r;

    n= n1/n2;
    c1= -VDOT(I,N);
    radicand= 1.0 - (n*n)*(1.0-c1*c1);
    if (radicand < 0) {
	/* Total Internal Reflection */
	I[0]= I[1]= I[2]= 0;
	return(0);
    }
    c2= sqrt(radicand);

    VSCALE(r,I,n);
    VSCALE(t,N,n*c1-c2);
    VADD2(I,r,t);
    return(1);
}


int CheckMaterial(char *cmp, char *MS) {
    int	i;

    if (MS) {
	for (i= 0; i < strlen(cmp) && i < strlen(MS); i++)
	    if (MS[i] != cmp[i])
		return(0);
	return(1);
    } else {
	return(0);
    }
}


/* This function parses the material string to obtain specular and refractive values */
void GetMaterial(char *MS, vect_t spec, fastf_t *refi, fastf_t *transmit) {
    struct	phong_specific	*phong_sp;
    struct	bu_vls		matparm;

    phong_sp= (struct phong_specific*)bu_malloc(sizeof(struct phong_specific), "phong specific");

    /* Initialize spec and refi */
    spec[0]= spec[1]= spec[2]= *refi= *transmit= 0;
    if (CheckMaterial("plastic",MS)) { /* Checks that the first 7 chars match any of the characters found in plastic */
	/* Plastic Shader */
	phong_sp->magic= PL_MAGIC;
	phong_sp->shine= 10;
	phong_sp->wgt_specular= 0.7;
	phong_sp->wgt_diffuse= 0.3;
	phong_sp->transmit= 0.0;
	phong_sp->reflect= 0.0;
	phong_sp->refrac_index= 1.0;
	phong_sp->extinction= 0.0;
	/*
	  BU_GETSTRUCT(phong_sp, phong_specific);
	  memcpy(phong_sp, &phong_defaults, sizeof(struct phong_specific));
	*/
	MS+= 7;
	bu_vls_init(&matparm);
	bu_vls_printf(&matparm,"%s",MS);
	bu_struct_parse(&matparm, phong_parse, (char *)phong_sp);
	bu_vls_free(&matparm);

	/*    bu_log("string: %s\n",MS);*/
	/*    bu_log("info[%d]: sh: %d, spec: %.3f, diff: %.3f, tran: %.3f, refl: %.3f, refr: %.3f\n", PMap->StoredPhotons, phong_sp->shine, phong_sp->wgt_specular, phong_sp->wgt_diffuse, phong_sp->transmit, phong_sp->reflect, phong_sp->refrac_index);*/
	/*    bu_log("spec[%d]: %.3f\n",PMap->StoredPhotons, phong_sp->wgt_specular);*/

	spec[0]= spec[1]= spec[2]= phong_sp->wgt_specular;
	*refi= phong_sp->refrac_index;
	spec[0]= spec[1]= spec[2]= 0.7;
	/*
	 *refi= 1.0;
	 *transmit= 0.0;
	 */
	/*
	  if (phong_sp->refrac_index != 1.0)
	  bu_log("refi: %.3f\n",phong_sp->refrac_index);
	*/
    } else if (CheckMaterial("glass",MS)) {
	/* Glass Shader */
	phong_sp->magic= PL_MAGIC;
	phong_sp->shine= 4;
	phong_sp->wgt_specular= 0.7;
	phong_sp->wgt_diffuse= 0.3;
	phong_sp->transmit= 0.8;
	phong_sp->reflect= 0.1;
	phong_sp->refrac_index= 1.65;
	phong_sp->extinction= 0.0;

	/*
	  BU_GETSTRUCT(phong_sp, phong_specific);
	  memcpy(phong_sp, &phong_defaults, sizeof(struct phong_specific));
	*/
	MS+= 5; /* move pointer past "pm " (3 characters) */
	bu_vls_init(&matparm);
	bu_vls_printf(&matparm,"%s",MS);
	bu_struct_parse(&matparm, phong_parse, (char *)phong_sp);
	bu_vls_free(&matparm);

	/*    bu_log("string: %s\n",MS);*/
	/*    bu_log("info[%d]: sh: %d, spec: %.3f, diff: %.3f, tran: %.3f, refl: %.3f, refr: %.3f\n", PMap->StoredPhotons, phong_sp->shine, phong_sp->wgt_specular, phong_sp->wgt_diffuse, phong_sp->transmit, phong_sp->reflect, phong_sp->refrac_index);*/
	/*    bu_log("spec[%d]: %.3f\n",PMap->StoredPhotons, phong_sp->wgt_specular);*/

	spec[0]= spec[1]= spec[2]= phong_sp->wgt_specular;
	*refi= phong_sp->refrac_index;
	*transmit= phong_sp->transmit;

	/*
	  if (phong_sp->refrac_index != 1.0)
	  bu_log("refi: %.3f\n",phong_sp->refrac_index);
	*/
    }

    bu_free(phong_sp, "phong_specific");
}


static fastf_t MaxFloat(fastf_t a, fastf_t b, fastf_t c) {
    return a > b ? a > c ? a : c : b > c ? b : c;
}


int HitRef(struct application *ap, struct partition *PartHeadp, struct seg *finished_segs) {
    struct	partition	*part;
    vect_t			pt,normal,spec;
    fastf_t			refi,transmit;

    ap->a_hit= PHit;
    part= PartHeadp->pt_forw;

    /* Compute Intersection Point, Pt= o + td */
    VJOIN1(pt, ap->a_ray.r_pt, part->pt_outhit->hit_dist, ap->a_ray.r_dir);

    /* Fetch Intersection Normal */
    RT_HIT_NORMAL(normal, part->pt_inhit, part->pt_inseg->seg_stp, &(ap->a_ray), part->pt_inflip);
    /*  RT_HIT_NORMAL(normal, part->pt_outhit, part->pt_inseg->seg_stp, &(ap->a_ray), part->pt_inflip);*/
    /*  RT_HIT_NORMAL(normal, part->pt_outhit, part->pt_outseg->seg_stp, &(ap->a_ray), part->pt_outflip);*/

    /* Assign pt */
    ap->a_ray.r_pt[0]= pt[0];
    ap->a_ray.r_pt[1]= pt[1];
    ap->a_ray.r_pt[2]= pt[2];


    /* Fetch Material */
    GetMaterial(part->pt_regionp->reg_mater.ma_shader, spec, &refi, &transmit);


    if (Refract(ap->a_ray.r_dir,normal,refi,1.0)) {
	/*
	  bu_log("1D: %d, [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f]\n",Depth,pt[0],pt[1],pt[2],ap->a_ray.r_dir[0], ap->a_ray.r_dir[1], ap->a_ray.r_dir[2],normal[0],normal[1],normal[2]);
	  bu_log("p1: [%.3f,%.3f,%.3f]\n",part->pt_inhit->hit_point[0], part->pt_inhit->hit_point[1], part->pt_inhit->hit_point[2]);
	  bu_log("p2: [%.3f,%.3f,%.3f]\n",part->pt_outhit->hit_point[0], part->pt_outhit->hit_point[1], part->pt_outhit->hit_point[2]);
	*/
	Depth++;
	rt_shootray(ap);
    } else {
	bu_log("TIF\n");
    }

    ap->a_onehit= 0;
    return(1);
}


/* Callback for Photon Hit, The 'current' photon is Emit[PMap->StoredPhotons] */
int PHit(struct application *ap, struct partition *PartHeadp, struct seg *finished_segs) {
    struct	partition	*part;
    vect_t			pt,normal,color,spec,power;
    fastf_t			refi,transmit,prob,prob_diff,prob_spec,prob_ref;
    int				hit;


    /* Move ptr forward to next region and call Hit recursively until reaching a region this is either
       not a light or none at all */
    hit= 0;
    for (BU_LIST_FOR(part, partition, (struct bu_list *)PartHeadp)) {
	if (part != PartHeadp) {
	    hit++;
	    VJOIN1(pt, ap->a_ray.r_pt, part->pt_inhit->hit_dist, ap->a_ray.r_dir);
	    /*    printf("pt[%d][%d]: --- [%.3f,%.3f,%.3f], %s\n",hit,CheckMaterial("light",part->pt_regionp->reg_mater.ma_shader),pt[0],pt[1],pt[2],part->pt_regionp->reg_mater.ma_shader);*/

	    if (!CheckMaterial("light",part->pt_regionp->reg_mater.ma_shader)) {
		/*        bu_log("  Found object!\n");*/
		break;
	    }
	}
    }

    if (part == PartHeadp)
	return 0;


    if (CheckMaterial("light",part->pt_regionp->reg_mater.ma_shader))
	return 0;


    /* Compute Intersection Point, Pt= o + td */
    VJOIN1(pt, ap->a_ray.r_pt, part->pt_inhit->hit_dist, ap->a_ray.r_dir);


    /* Generate Bounding Box for Scaling Phase */
    if (PInit) {
	BBMin[0]= BBMax[0]= pt[0];
	BBMin[1]= BBMax[1]= pt[1];
	BBMin[2]= BBMax[2]= pt[2];
	PInit= 0;
    } else {
	if (pt[0] < BBMin[0])
	    BBMin[0]= pt[0];
	if (pt[0] > BBMax[0])
	    BBMax[0]= pt[0];
	if (pt[1] < BBMin[1])
	    BBMin[1]= pt[1];
	if (pt[1] > BBMax[1])
	    BBMax[1]= pt[1];
	if (pt[2] < BBMin[2])
	    BBMin[2]= pt[2];
	if (pt[2] > BBMax[2])
	    BBMax[2]= pt[2];
    }

    /* Fetch Intersection Normal */
    RT_HIT_NORMAL(normal, part->pt_inhit, part->pt_inseg->seg_stp, &(ap->a_ray), part->pt_inflip);

    /* Fetch Material */
    GetMaterial(part->pt_regionp->reg_mater.ma_shader, spec, &refi, &transmit);
    /*  bu_log("Spec: [%.3f,%.3f,%.3f], Refi: %.3f\n",spec[0],spec[1],spec[2],refi);*/


    /* Compute Diffuse, Specular, and Caustics */
    color[0]= part->pt_regionp->reg_mater.ma_color[0];
    color[1]= part->pt_regionp->reg_mater.ma_color[1];
    color[2]= part->pt_regionp->reg_mater.ma_color[2];

    prob_ref= MaxFloat(color[0]+spec[0],color[1]+spec[1],color[2]+spec[2]);
    prob_diff= ((color[0]+color[1]+color[2])/(color[0]+color[1]+color[2]+spec[0]+spec[1]+spec[2]))*prob_ref;
    prob_spec= prob_ref - prob_diff;
#ifndef HAVE_DRAND48
    prob= rand()/(double)RAND_MAX;
#else
    prob= drand48();
#endif

    /* bu_log("pr: %.3f, pd: %.3f, [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",prob_ref,prob_diff,color[0],color[1],color[2],spec[0],spec[1],spec[2]);*/
    /* bu_log("prob: %.3f, prob_diff: %.3f, pd+ps: %.3f\n",prob,prob_diff,prob_diff+prob_spec);*/

    if (prob < 1.0 - transmit) {
	if (prob < prob_diff) {
	    /* Store power of incident Photon */
	    power[0]= CurPh.Power[0];
	    power[1]= CurPh.Power[1];
	    power[2]= CurPh.Power[2];


	    /* Scale Power of reflected photon */
	    CurPh.Power[0]= power[0]*color[0]/prob_diff;
	    CurPh.Power[1]= power[1]*color[1]/prob_diff;
	    CurPh.Power[2]= power[2]*color[2]/prob_diff;

	    /* Store Photon */
	    Store(pt, ap->a_ray.r_dir, normal, PType);

	    /* Assign diffuse reflection direction */
	    DiffuseReflect(normal,ap->a_ray.r_dir);

	    /* Assign pt */
	    ap->a_ray.r_pt[0]= pt[0];
	    ap->a_ray.r_pt[1]= pt[1];
	    ap->a_ray.r_pt[2]= pt[2];

	    if (PType != PM_CAUSTIC) {
		Depth++;
		rt_shootray(ap);
	    }
	} else if (prob >= prob_diff && prob < prob_diff + prob_spec) {
	    /* Store power of incident Photon */
	    power[0]= CurPh.Power[0];
	    power[1]= CurPh.Power[1];
	    power[2]= CurPh.Power[2];

	    /* Scale power of reflected photon */
	    CurPh.Power[0]= power[0]*spec[0]/prob_spec;
	    CurPh.Power[1]= power[1]*spec[1]/prob_spec;
	    CurPh.Power[2]= power[2]*spec[2]/prob_spec;

	    /* Reflective */
	    SpecularReflect(normal,ap->a_ray.r_dir);

	    /* Assign pt */
	    ap->a_ray.r_pt[0]= pt[0];
	    ap->a_ray.r_pt[1]= pt[1];
	    ap->a_ray.r_pt[2]= pt[2];

	    if (PType != PM_IMPORTANCE)
		PType= PM_CAUSTIC;
	    Depth++;
	    rt_shootray(ap);
	} else {
	    /* Store Photon */
	    Store(pt, ap->a_ray.r_dir, normal, PType);
	}
    } else {
	if (refi > 1.0 && (PType == PM_CAUSTIC || Depth == 0)) {
	    if (PType != PM_IMPORTANCE)
		PType= PM_CAUSTIC;

	    /* Store power of incident Photon */
	    power[0]= CurPh.Power[0];
	    power[1]= CurPh.Power[1];
	    power[2]= CurPh.Power[2];

	    /* Scale power of reflected photon */
	    CurPh.Power[0]= power[0]*spec[0]/prob_spec;
	    CurPh.Power[1]= power[1]*spec[1]/prob_spec;
	    CurPh.Power[2]= power[2]*spec[2]/prob_spec;

	    /* Refractive or Reflective */
	    if (refi > 1.0 && prob < transmit) {
		CurPh.Power[0]= power[0];
		CurPh.Power[1]= power[1];
		CurPh.Power[2]= power[2];

		if (!Refract(ap->a_ray.r_dir,normal,1.0,refi))
		    printf("TIF0\n");

		ap->a_hit= HitRef;

		/*
		  bu_log("dir: [%.3f,%.3f,%.3f]\n",ap->a_ray.r_dir[0],ap->a_ray.r_dir[1],ap->a_ray.r_dir[2]);
		  bu_log("ref: [%.3f,%.3f,%.3f]\n",ap->a_ray.r_dir[0],ap->a_ray.r_dir[1],ap->a_ray.r_dir[2]);
		  bu_log("nor: [%.3f,%.3f,%.3f]\n",normal[0],normal[1],normal[2]);
		  bu_log("p0: [%.3f,%.3f,%.3f],[%.3f,%.3f,%.3f]\n",pt[0],pt[1],pt[2],ap->a_ray.r_dir[0],ap->a_ray.r_dir[1],ap->a_ray.r_dir[2]);
		*/
		ap->a_onehit= 0;
	    } else {
		SpecularReflect(normal,ap->a_ray.r_dir);
	    }

	    /* Assign pt */
	    ap->a_ray.r_pt[0]= pt[0];
	    ap->a_ray.r_pt[1]= pt[1];
	    ap->a_ray.r_pt[2]= pt[2];

	    /*      bu_log("2D: %d, [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f]\n",Depth,pt[0],pt[1],pt[2],ap->a_ray.r_dir[0], ap->a_ray.r_dir[1], ap->a_ray.r_dir[2],normal[0],normal[1],normal[2]);*/
	    Depth++;
	    rt_shootray(ap);
	}
    }
    return 1;
}


/* Callback for Photon Miss */
int PMiss(struct application *ap) {
    return 0;
}


/* ScalePhotonPower() is used to scale the power of all photons once they
 * have been emitted from the light source.  Scale= 1/(#emitted photons).
 * Call this function after each light source is processed.
 * This function also handles setting a default power for the photons based
 * on the size of the scene, i.e power of light source */
void ScalePhotonPower(int Map) {
    int		i;

    for (i= 0; i < PMap[Map]->StoredPhotons; i++) {
	Emit[Map][i].Power[0]*= ScaleFactor/(double)EPS[Map];
	Emit[Map][i].Power[1]*= ScaleFactor/(double)EPS[Map];
	Emit[Map][i].Power[2]*= ScaleFactor/(double)EPS[Map];
    }
}


/* Generate Importons and emit them into the scene from the eye position */
void EmitImportonsRandom(struct application *ap, point_t eye_pos) {
    while (PMap[PM_IMPORTANCE]->StoredPhotons < PMap[PM_IMPORTANCE]->MaxPhotons) {
	do {
	    /* Set Ray Direction to application ptr */
#ifndef HAVE_DRAND48
	    ap->a_ray.r_dir[0]= 2.0*rand()/(double)RAND_MAX-1.0;
	    ap->a_ray.r_dir[1]= 2.0*rand()/(double)RAND_MAX-1.0;
	    ap->a_ray.r_dir[2]= 2.0*rand()/(double)RAND_MAX-1.0;
#else
	    ap->a_ray.r_dir[0]= 2.0*drand48()-1.0;
	    ap->a_ray.r_dir[1]= 2.0*drand48()-1.0;
	    ap->a_ray.r_dir[2]= 2.0*drand48()-1.0;
#endif
	} while (ap->a_ray.r_dir[0]*ap->a_ray.r_dir[0] + ap->a_ray.r_dir[1]*ap->a_ray.r_dir[1] + ap->a_ray.r_dir[2]*ap->a_ray.r_dir[2] > 1);

	/* Normalize Ray Direction */
	VUNITIZE(ap->a_ray.r_dir);

	/* Set Ray Position to application ptr */
	ap->a_ray.r_pt[0]= eye_pos[0];
	ap->a_ray.r_pt[1]= eye_pos[1];
	ap->a_ray.r_pt[2]= eye_pos[2];

	/* Shoot Importon into Scene */
	CurPh.Power[0]= 0;
	CurPh.Power[1]= 100000000;
	CurPh.Power[2]= 0;

	Depth= 0;
	PType= PM_IMPORTANCE;
	rt_shootray(ap);
    }
}


/* Emit a photons in a random direction based on a point light */
void EmitPhotonsRandom(struct application *ap, double ScaleIndirect) {
    struct	light_specific	*lp;
    vect_t			ldir;
    int				i;

    ldir[0]= 0;
    ldir[1]= 0;
    ldir[2]= -1;
    /*
      for (i= 0; i < 8; i++)
      bu_log("sample points: [%.3f,%.3f,%.3f]\n",lp->lt_sample_pts[i].lp_pt[0], lp->lt_sample_pts[i].lp_pt[1], lp->lt_sample_pts[i].lp_pt[2]);
    */
    while (1) {
	for (BU_LIST_FOR(lp, light_specific, &(LightHead.l))) {
	    /* If the Global Photon Map Completes before the Caustics Map, then it probably means there are no caustic objects in the Scene */
	    if (PMap[PM_GLOBAL]->StoredPhotons == PMap[PM_GLOBAL]->MaxPhotons && (!PMap[PM_CAUSTIC]->StoredPhotons || PMap[PM_CAUSTIC]->StoredPhotons == PMap[PM_CAUSTIC]->MaxPhotons))
		return;

	    do {
		/*      do {*/
		/* Set Ray Direction to application ptr */
#ifndef HAVE_DRAND48
		ap->a_ray.r_dir[0]= 2.0*rand()/(double)RAND_MAX-1.0;
		ap->a_ray.r_dir[1]= 2.0*rand()/(double)RAND_MAX-1.0;
		ap->a_ray.r_dir[2]= 2.0*rand()/(double)RAND_MAX-1.0;
#else
		ap->a_ray.r_dir[0]= 2.0*drand48()-1.0;
		ap->a_ray.r_dir[1]= 2.0*drand48()-1.0;
		ap->a_ray.r_dir[2]= 2.0*drand48()-1.0;
#endif
	    } while (ap->a_ray.r_dir[0]*ap->a_ray.r_dir[0] + ap->a_ray.r_dir[1]*ap->a_ray.r_dir[1] + ap->a_ray.r_dir[2]*ap->a_ray.r_dir[2] > 1);
	    /* Normalize Ray Direction */
	    VUNITIZE(ap->a_ray.r_dir);
	    /*    } while (drand48() > VDOT(ap->a_ray.r_dir,ldir));*/ /* we want this to terminate when a rnd# is less than the angle */

	    /* Set Ray Position to application ptr */
	    ap->a_ray.r_pt[0]= lp->lt_pos[0];
	    ap->a_ray.r_pt[1]= lp->lt_pos[1];
	    ap->a_ray.r_pt[2]= lp->lt_pos[2];


	    /* Shoot Photon into Scene, (4.0) is used to align phong's attenuation with photonic energies, it's a heuristic */
	    /*bu_log("Shooting Ray: [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",lp->lt_pos[0], lp->lt_pos[1], lp->lt_pos[2], x,y,z);*/
	    CurPh.Power[0]= 1000.0 * ScaleIndirect * lp->lt_intensity * lp->lt_color[0];
	    CurPh.Power[1]= 1000.0 * ScaleIndirect * lp->lt_intensity * lp->lt_color[1];
	    CurPh.Power[2]= 1000.0 * ScaleIndirect * lp->lt_intensity * lp->lt_color[2];

	    Depth= 0;
	    PType= PM_GLOBAL;

	    EPL++;
	    for (i= 0; i < PM_MAPS; i++)
		if (PMap[i]->StoredPhotons < PMap[i]->MaxPhotons)
		    EPS[i]++;

	    rt_shootray(ap);
	    /*    bu_log("1: %d, 2: %d\n",PMap[PM_GLOBAL]->StoredPhotons, PMap[PM_CAUSTIC]->StoredPhotons);*/
	}
    }
}


void SanityCheck(struct PNode *Root, int LR) {
    if (!Root)
	return;

    bu_log("Pos[%d]: [%.3f,%.3f,%.3f]\n",LR,Root->P.Pos[0], Root->P.Pos[1], Root->P.Pos[2]);
    SanityCheck(Root->L,1);
    SanityCheck(Root->R,2);
}


int ICHit(struct application *ap, struct partition *PartHeadp, struct seg *finished_segs) {
    struct	partition	*part;
    point_t			pt,normal;
    vect_t			C1,C2;

    part= PartHeadp->pt_forw;

    VJOIN1(pt, ap->a_ray.r_pt, part->pt_inhit->hit_dist, ap->a_ray.r_dir);

    RT_HIT_NORMAL(normal, part->pt_inhit, part->pt_inseg->seg_stp, &(ap->a_ray), part->pt_inflip);
    /*  GetEstimate(C1, pt, normal, ScaleFactor/10.0, PMap[PM_GLOBAL]->StoredPhotons / 100, PM_GLOBAL, 5, 1);*/
    /*  GetEstimate(C1, pt, normal, ScaleFactor/1000.0, 10.0*log(PMap[PM_GLOBAL]->StoredPhotons), PM_GLOBAL, ScaleFactor/5.0, 1);*/
    GetEstimate(C1, pt, normal, ScaleFactor/1024.0, 128, PM_GLOBAL, ScaleFactor/8.0, 1, 15);
    /*  GetEstimate(C2 ,pt, normal, (int)(ScaleFactor/pow(2,(log(PMap[PM_CAUSTIC]->MaxPhotons/2)/log(4)))), PMap[PM_CAUSTIC]->MaxPhotons / 50,PM_CAUSTIC, 0, 0);*/
    GetEstimate(C2 ,pt, normal, ScaleFactor/1024.0, PMap[PM_CAUSTIC]->MaxPhotons / 100,PM_CAUSTIC, ScaleFactor/256.0, 1, 15);
    /*    GetEstimate(IMColor2, pt, normal, (int)(ScaleFactor/100.0),PMap[PM_CAUSTIC]->MaxPhotons/50,PM_CAUSTIC,1, 0);*/

    (*(vect_t*)ap->a_purpose)[0]+= C1[0] + C2[0];
    (*(vect_t*)ap->a_purpose)[1]+= C1[1] + C2[1];
    (*(vect_t*)ap->a_purpose)[2]+= C1[2] + C2[2];

    return(1);
}


int ICMiss(struct application *ap) {
    /* Set to Background/Ambient Color later */
    return(0);
}


/* Convert a Polar vector into a euclidian vector:
 * - Requires that an orthogonal basis, so generate one using the photon normal as the first vector.
 * - The Normal passed to this function must be unitized.
 * - This took me almost 3 hours to write, and it's tight.
 */
void Polar2Euclidian(vect_t Dir, vect_t Normal, double Theta, double Phi) {
    int		i;
    vect_t	BasisX,BasisY;


    BasisX[0]= fabs(Normal[0]) < 0.001 ? 1.0 : fabs(Normal[0]) > 0.999 ? 0.0 : -(1.0/Normal[0]);
    BasisX[1]= fabs(Normal[1]) < 0.001 ? 1.0 : fabs(Normal[1]) > 0.999 ? 0.0 :  (1.0/Normal[1]);
    BasisX[2]= 0.0;
    VUNITIZE(BasisX);
    VCROSS(BasisY,Normal,BasisX);

    for (i= 0; i < 3; i++)
	Dir[i]= sin(Theta)*cos(Phi)*BasisX[i] + sin(Theta)*sin(Phi)*BasisY[i] + cos(Theta)*Normal[i];
}


/*
 * Irradiance Calculation for a given position
 */
void Irradiance(int pid, struct Photon *P, struct application *ap) {
    struct	application	*lap;		/* local application instance */
    int		i,j,M,N;
    double	theta,phi,Coef;


    lap = (struct application*)bu_malloc(sizeof(struct application), "app");
    RT_APPLICATION_INIT(lap);
    lap->a_rt_i= ap->a_rt_i;
    lap->a_hit= ap->a_hit;
    lap->a_miss= ap->a_miss;
    lap->a_resource= &GPM_RTAB[pid];
    lap->a_logoverlap = ap->a_logoverlap;

    M= N= GPM_RAYS;
    P->Irrad[0]= P->Irrad[1]= P->Irrad[2]= 0.0;
    for (i= 1; i <= M; i++) {
	for (j= 1; j <= N; j++) {
#ifndef HAVE_DRAND48
	    theta= asin(sqrt((j-rand()/(double)RAND_MAX)/M));
	    phi= (2.0*M_PI)*((i-rand()/(double)RAND_MAX)/N);
#else
	    theta= asin(sqrt((j-drand48())/M));
	    phi= (2.0*M_PI)*((i-drand48())/N);
#endif

	    /* Assign pt */
	    lap->a_ray.r_pt[0]= P->Pos[0];
	    lap->a_ray.r_pt[1]= P->Pos[1];
	    lap->a_ray.r_pt[2]= P->Pos[2];

	    /* Assign Dir */
	    Polar2Euclidian(lap->a_ray.r_dir,P->Normal,theta,phi);

	    /* Utilize the purpose pointer as a pointer to the Irradiance Color */
	    lap->a_purpose= (void*)P->Irrad;

	    /*      bu_log("Vec: [%.3f,%.3f,%.3f]\n",ap->a_ray.r_dir[0],ap->a_ray.r_dir[1],ap->a_ray.r_dir[2]);*/
	    rt_shootray(lap);

	    /*      bu_log("[%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",P.Pos[0],P.Pos[1],P.Pos[2],P.Normal[0],P.Normal[1],P.Normal[2],IMColor[0],IMColor[1],IMColor[2]);*/
	}
    }

    Coef= 1.0/((double)(M*N));
    P->Irrad[0]*= Coef;
    P->Irrad[1]*= Coef;
    P->Irrad[2]*= Coef;

    bu_free(lap, "app");
}


/*
 *  Irradiance Cache for Indirect Illumination
 *  Go through each photon and use it for the position of the hemisphere
 *  and then determine whether that should be included as a Cache Pt.
 */
void BuildIrradianceCache(int pid, struct PNode *Node, struct application *ap) {
    if (!Node)
	return;

    /* Determine if this pt will be used by calculating a weight */
    bu_semaphore_acquire(PM_SEM);
    if (!Node->C) {
	ICSize++;
	Node->C++;
#ifndef HAVE_ALARM
	if (!(ICSize%(PMap[PM_GLOBAL]->MaxPhotons/8)))
	    bu_log("    Irradiance Cache Progress: %d%%\n",(int)(0.5+100.0*ICSize/PMap[PM_GLOBAL]->MaxPhotons));
#endif
	bu_semaphore_release(PM_SEM);
	Irradiance(pid, &Node->P, ap);
    } else {
	bu_semaphore_release(PM_SEM);
    }

    BuildIrradianceCache(pid, Node->L, ap);
    BuildIrradianceCache(pid, Node->R, ap);
}

#ifdef HAVE_ALARM
static int starttime = 0;
void alarmhandler(int sig) {
    int t;
    float p, h, m, d, tl;
    if(sig != SIGALRM)
	bu_bomb("Funky signals\n");
    t = time(NULL) - starttime;
    p = (float)ICSize/PMap[PM_GLOBAL]->MaxPhotons + .015;
    tl = (float)t*1.0/p - t;
    bu_log("    Irradiance Cache Progress: %d%%. Approximate time left: ",
	    (int)(100.0*p), (1.0/p-1.0)*(float)t, (float)t*1.0/p);
#define BAH(s,w) if(tl > (s)) { float d = floor(tl / (float)(s)); \
    tl -= d * (s); bu_log("%d "w, (int)d, d>1?"s":""); }
    BAH(60*60*24, "day%s, ");
    BAH(60*60, "hour%s, ");
    BAH(60, "minute%s, ");
    BAH(0, "second%s.");
#undef BAH
    bu_log("\n");
    alarm(60);
    return;
}
#endif

void IrradianceThread(int pid, genptr_t arg) {
#ifdef HAVE_ALARM
    starttime = time(NULL);
    signal(SIGALRM,alarmhandler);
    alarm(60);
    BuildIrradianceCache(pid, PMap[PM_GLOBAL]->Root, (struct application*)arg);
    alarm(0);
    starttime = 0;
#else
    BuildIrradianceCache(pid, PMap[PM_GLOBAL]->Root, (struct application*)arg);
#endif
}


void Initialize(int MAP, int MapSize) {
    PMap[MAP]= (struct PhotonMap*)bu_malloc(sizeof(struct PhotonMap), "PhotoMap");
    PMap[MAP]->MaxPhotons= MapSize;
    PMap[MAP]->Root= (struct PNode*)bu_malloc(sizeof(struct PNode), "PNode");
    PMap[MAP]->StoredPhotons= 0;
    if(MapSize > 0)
	Emit[MAP] = (struct Photon*)bu_malloc(sizeof(struct Photon)*MapSize, "Photon");
    else
	Emit[MAP] = NULL;
}


int LoadFile(char *pmfile) {
    FILE		*FH;
    int		I1,i;
    short		S1;
    char		C1;


    FH= fopen(pmfile,"rb");
    if (FH) {
	bu_log("  Reading Irradiance Cache File...\n");
	fread(&S1, sizeof(short), 1, FH);
	bu_log("endian: %d\n",S1);

	fread(&S1, sizeof(short), 1, FH);
	bu_log("revision: %d\n",S1);

	fread(&ScaleFactor, sizeof(double),1,FH);
	bu_log("Scale Factor: %.3f\n",ScaleFactor);

	/* Read in Map Type */
	fread(&C1, sizeof(char), 1, FH);
	fread(&I1, sizeof(int), 1, FH);
	Initialize(PM_GLOBAL, I1);
	bu_log("Reading Global: %d\n",I1);
	for (i= 0; i < I1; i++) {
	    fread(&Emit[PM_GLOBAL][i],sizeof(struct Photon),1,FH);
	    /*      bu_log("Pos: [%.3f,%.3f,%.3f], Power: [%.3f,%.3f,%.3f]\n",Emit[PM_GLOBAL][i].Pos[0],Emit[PM_GLOBAL][i].Pos[1],Emit[PM_GLOBAL][i].Pos[2],Emit[PM_GLOBAL][i].Power[0],Emit[PM_GLOBAL][i].Power[1],Emit[PM_GLOBAL][i].Power[2]);*/
	    /*      bu_log("Pos: [%.3f,%.3f,%.3f], Irrad: [%.3f,%.3f,%.3f]\n",Emit[PM_GLOBAL][i].Pos[0],Emit[PM_GLOBAL][i].Pos[1],Emit[PM_GLOBAL][i].Pos[2],Emit[PM_GLOBAL][i].Irrad[0],Emit[PM_GLOBAL][i].Irrad[1],Emit[PM_GLOBAL][i].Irrad[2]);*/
	}

	fread(&C1, sizeof(char), 1, FH);
	fread(&I1, sizeof(int), 1, FH);
	Initialize(PM_CAUSTIC, I1);
	bu_log("Reading Caustic: %d\n",I1);
	for (i= 0; i < I1; i++) {
	    fread(&Emit[PM_CAUSTIC][i],sizeof(struct Photon),1,FH);
	}

	PMap[PM_GLOBAL]->StoredPhotons= PMap[PM_GLOBAL]->MaxPhotons;
	BuildTree(Emit[PM_GLOBAL], PMap[PM_GLOBAL]->StoredPhotons, PMap[PM_GLOBAL]->Root);

	PMap[PM_CAUSTIC]->StoredPhotons= PMap[PM_CAUSTIC]->MaxPhotons;
	BuildTree(Emit[PM_CAUSTIC], PMap[PM_CAUSTIC]->StoredPhotons, PMap[PM_CAUSTIC]->Root);
	fclose(FH);
	return(1);
    }

    return(0);
}


void WritePhotons(struct PNode *Root, FILE *FH) {
    if (!Root)
	return;

    fwrite(&Root->P,sizeof(struct Photon),1,FH);
    WritePhotons(Root->L,FH);
    WritePhotons(Root->R,FH);
}


void WritePhotonFile(char *pmfile) {
    FILE		*FH;
    int		I1;
    short		S1;
    char		C1;


    FH= fopen(pmfile,"wb");
    if (FH) {
	/* Write 2 Byte Endian Code and 2 Byte Revision Code */
	S1= 1;
	fwrite(&S1,sizeof(short),1,FH);
	S1= 0;
	fwrite(&S1,sizeof(short),1,FH);

	/* Write Scale Factor */
	bu_log("writing sf: %.3f\n",ScaleFactor);
	fwrite(&ScaleFactor,sizeof(double),1,FH);

	/* === Write PM_GLOBAL Data === */
	C1= PM_GLOBAL;
	fwrite(&C1,sizeof(char),1,FH);
	/* Write number of Photons */
	I1= PMap[PM_GLOBAL]->StoredPhotons;
	fwrite(&I1,sizeof(int),1,FH);
	/* Write each photon to file */
	if (PMap[PM_GLOBAL]->StoredPhotons)
	    WritePhotons(PMap[PM_GLOBAL]->Root,FH);

	/* === Write PM_CAUSTIC Data === */
	C1= PM_CAUSTIC;
	fwrite(&C1,sizeof(char),1,FH);
	/* Write number of Photons */
	I1= PMap[PM_CAUSTIC]->StoredPhotons;
	fwrite(&I1,sizeof(int),1,FH);
	/* Write each photon to file */
	if (PMap[PM_CAUSTIC]->StoredPhotons)
	    WritePhotons(PMap[PM_CAUSTIC]->Root,FH);

	fclose(FH);
    }
}


/*
 *  Main Photon Mapping Function
 */
void BuildPhotonMap(struct application *ap, point_t eye_pos, int cpus, int width, int height, int Hypersample, int GlobalPhotons, double CausticsPercent, int Rays, double AngularTolerance, int RandomSeed, int ImportanceMapping, int IrradianceHypersampling, int VisualizeIrradiance, double ScaleIndirect, char pmfile[255]) {
    int				i,MapSize[PM_MAPS];
    double			ratio;

    PM_Visualize= VisualizeIrradiance;
    GPM_IH= IrradianceHypersampling;
    GPM_WIDTH= width;
    GPM_HEIGHT= height;

    /* If the user has specified a cache file then first check to see if there is any valid data within it,
       otherwise utilize the file to push the resulting irradiance cache data into for future use. */
    if (!LoadFile(pmfile)) {
	/*
	  bu_log("pos: [%.3f,%.3f,%.3f]\n",eye_pos[0],eye_pos[1],eye_pos[2]);
	  bu_log("I,V,Imp,H: %.3f,%d,%d,%d\n",LightIntensity,VisualizeIrradiance,ImportanceMapping,IrradianceHypersampling);
	*/
	bu_log("Building Photon Map:\n");


	GPM_RAYS= Rays;
	GPM_ATOL= cos(AngularTolerance*bn_degtorad);

	PInit= 1;

#ifndef HAVE_SRAND48
	srand(RandomSeed);
#else
	srand48(RandomSeed);
#endif
	/*  bu_log("Photon Structure Size: %d\n",sizeof(struct PNode));*/

	/*
	  bu_log("Checking application struct\n");
	  RT_CK_APPLICATION(ap);
	*/

	/* Initialize Emitted Photons for each map to 0 */
	EPL= 0;
	for (i= 0; i < PM_MAPS; i++)
	    EPS[i]= 0;

	CausticsPercent/= 100.0;
	MapSize[PM_IMPORTANCE]= GlobalPhotons/8;
	MapSize[PM_GLOBAL]= (int)((1.0-CausticsPercent)*GlobalPhotons);
	MapSize[PM_CAUSTIC]= (int)(CausticsPercent*GlobalPhotons);
	MapSize[PM_SHADOW]= 0;

	/*  bu_log("Caustic Photons: %d\n",MapSize[PM_CAUSTIC]);*/
	/* Allocate Memory for Photon Maps */
	Initialize(PM_GLOBAL,MapSize[PM_GLOBAL]);
	Initialize(PM_CAUSTIC,MapSize[PM_CAUSTIC]);
	Initialize(PM_SHADOW,MapSize[PM_SHADOW]);
	Initialize(PM_IMPORTANCE,MapSize[PM_IMPORTANCE]);

	/* Populate Application Structure */
	/* Set Recursion Level, Magic Number, Hit/Miss Callbacks, and Purpose */
	ap->a_level= 1;
	ap->a_onehit= 0;
	ap->a_ray.magic= RT_RAY_MAGIC;
	ap->a_hit= PHit;
	ap->a_miss= PMiss;
	ap->a_purpose= "Importance Mapping";


	if (ImportanceMapping) {
	    bu_log("  Building Importance Map...\n");
	    EmitImportonsRandom(ap,eye_pos);
	    BuildTree(Emit[PM_IMPORTANCE],PMap[PM_IMPORTANCE]->StoredPhotons,PMap[PM_IMPORTANCE]->Root);
	    ScaleFactor= MaxFloat(BBMax[0]-BBMin[0],BBMax[1]-BBMin[1],BBMax[2]-BBMin[2]);
	}

	HitG= HitB= 0;
	bu_log("  Emitting Photons...\n");
	EmitPhotonsRandom(ap, ScaleIndirect);
	/*      EmitPhotonsRandom(ap, &(LightHead.l), LightIntensity);*/

	/* Generate Scale Factor */
	ScaleFactor= MaxFloat(BBMax[0]-BBMin[0],BBMax[1]-BBMin[1],BBMax[2]-BBMin[2]);

	bu_log("HitGB: %d,%d\n",HitG,HitB);
	bu_log("Scale Factor: %.3f\n",ScaleFactor);
	ratio= (double)HitG/((double)(HitG+HitB));
	bu_log("EPL: %d, Adjusted EPL: %d\n",(int)EPL,(int)(EPL*ratio));
	EPS[PM_GLOBAL]*= ratio;
	EPS[PM_CAUSTIC]*= ratio;

	/* Scale Photon Power */
	ScalePhotonPower(PM_GLOBAL);
	ScalePhotonPower(PM_CAUSTIC);

	/*
	  for (i= 0; i < PMap->StoredPhotons; i++)
	  bu_log("insertLS[%d]: %.3f,%.3f,%.3f\n",i,Emit[i].Pos[0],Emit[i].Pos[1],Emit[i].Pos[2]);
	*/


	bu_log("  Building KD-Tree...\n");
	/* Balance KD-Tree */
	for (i= 0; i < 3; i++)
	    if (PMap[i]->StoredPhotons)
		BuildTree(Emit[i],PMap[i]->StoredPhotons,PMap[i]->Root);


	bu_semaphore_init(PM_SEM_INIT);
	bu_log("  Building Irradiance Cache...\n");
	ap->a_level= 1;
	ap->a_onehit= 0;
	ap->a_ray.magic= RT_RAY_MAGIC;
	ap->a_hit= ICHit;
	ap->a_miss= ICMiss;
	ICSize= 0;

	if (cpus > 1) {
	    GPM_RTAB= (struct resource*)bu_calloc(cpus, sizeof(struct resource), "resource");
	    for (i= 0; i < cpus; i++) {
		GPM_RTAB[i].re_cpu= i;
		GPM_RTAB[i].re_magic= RESOURCE_MAGIC;
		BU_PTBL_SET(&ap->a_rt_i->rti_resources, i, &GPM_RTAB[i]);
		rt_init_resource(&GPM_RTAB[i], GPM_RTAB[i].re_cpu, ap->a_rt_i);
	    }
	    bu_parallel(IrradianceThread, cpus, ap);
	} else {
	    /* This will allow profiling for single threaded rendering */
	    IrradianceThread(0,ap);
	}

	/* Allocate Memory for Irradiance Cache and Initialize Pixel Map */
	/*    bu_log("Image Size: %d,%d\n",width,height);*/
	if (GPM_IH) {
	    Map= (char*)bu_calloc(width*height, sizeof(char), "Map");
	    IC= (struct IrradCache*)bu_malloc(sizeof(struct IrradCache)*width*height, "IrradCache");
	    for (i= 0; i < width*height; i++) {
		IC[i].List= (struct IrradNode*)bu_malloc(sizeof(struct IrradNode), "IrradNode");
		IC[i].Num= 0;
	    }
	}


	/*
	  bu_log("  Sanity Check...\n");
	  SanityCheck(PMap[PM_GLOBAL]->Root,0);
	*/

	WritePhotonFile(pmfile);

	for (i= 0; i < PM_MAPS; i++) {
	    bu_free(Emit[i], "Photons");
	    Emit[i] = NULL;
	}

    }
    bu_free(GPM_RTAB, "resource");
    GPM_RTAB = NULL;
}


void Swap(struct PSN *a, struct PSN *b) {
    struct	PSN	c;

    /*
      c.P= a->P;
      c.Dist= a->Dist;
      a->P= b->P;
      a->Dist= b->Dist;
      b->P= c.P;
      b->Dist= c.Dist;
    */
    /*  bu_log("  SWAP_IN: %.3f,%.3f\n",a->Dist, b->Dist);*/
    memcpy(&c, a, sizeof(struct PSN));
    memcpy(a, b, sizeof(struct PSN));
    memcpy(b, &c, sizeof(struct PSN));
    /*  bu_log("  SWAP_OT: %.3f,%.3f\n",a->Dist, b->Dist);*/
}


/*
  After inserting a new node it must be brought upwards until both children
  are less than it.
*/
void HeapUp(struct PhotonSearch *S, int ind) {
    int	i;

    if (!ind)
	return;

    i= ((ind+1)-(ind+1)%2)/2-1;
    /*  bu_log("  CHECK: %.3f > %.3f :: [%d] > [%d]\n",S->List[ind].Dist,S->List[i].Dist,ind,i);*/
    if (S->List[ind].Dist > S->List[i].Dist) {
	/*    bu_log("SWAP_A: %.3f,%.3f\n",S->List[i].Dist, S->List[ind].Dist);*/
	Swap(&S->List[i],&S->List[ind]);
	/*    bu_log("SWAP_B: %.3f,%.3f\n",S->List[i].Dist, S->List[ind].Dist);*/
    }
    HeapUp(S,i);
}


/*
  Sift the new Root node down, by choosing the child with the highest number
  since choosing a child with the highest number may reduce the number of
  recursions the number will have to propogate
*/
void HeapDown(struct PhotonSearch *S, int ind) {
    int		c;

    if (2*ind+1 > S->Found)
	return;

    c= 2*ind+1 < S->Found ? S->List[2*ind+2].Dist > S->List[2*ind+1].Dist ? 2*ind+2 : 2*ind+1 : 2*ind+1;
    /*  bu_log(" c: %d\n",c);*/

    if (S->List[c].Dist > S->List[ind].Dist) {
	/*    bu_log("SWAP_C: %.3f,%.3f :: %d,%d :: %d\n",S->List[c].Dist, S->List[ind].Dist,c,ind,S->Found);*/
	Swap(&S->List[c],&S->List[ind]);
	/*    bu_log("SWAP_D: %.3f,%.3f :: %d,%d :: %d\n",S->List[c].Dist, S->List[ind].Dist,c,ind,S->Found);*/
    }
    HeapDown(S,c);
}


void Push(struct PhotonSearch *S, struct PSN P) {
    S->List[S->Found]= P;
    HeapUp(S,S->Found++);
    /*
      for (i= 0; i < S->Found; i++)
      bu_log("Push[%d]: %.3f :: %d,%d\n",i,S->List[i].Dist,S->Found, S->Max);
    */
}


void Pop(struct PhotonSearch *S) {
    S->Found--;
    S->List[0]= S->List[S->Found];
    HeapDown(S,0);
    /*
      for (i= 0; i < S->Found; i++)
      bu_log("Pop [%d]: %.3f :: %d,%d\n",i,S->List[i].Dist,S->Found,S->Max);
    */
}


void LocatePhotons(struct PhotonSearch *Search, struct PNode *Root) {
    fastf_t		Dist,TDist,angle,MDist;
    int			i,MaxInd,Axis;

    if (!Root)
	return;

    Axis= Root->P.Axis;
    Dist= Search->Pos[Axis] - Root->P.Pos[Axis];

    if (Dist < 0) {
	/* Left of plane - search left subtree first */
	LocatePhotons(Search,Root->L);
	if (Dist*Dist < Search->RadSq)
	    LocatePhotons(Search,Root->R);
    } else {
	/* Right of plane - search right subtree first */
	LocatePhotons(Search,Root->R);
	if (Dist*Dist < Search->RadSq)
	    LocatePhotons(Search,Root->L);
    }

#if 0
    /* HEAP, Find Distance between Root Photon and Search->Pos */
    angle= VDOT(Search->Normal, Root->P.Normal);
    Node.P= Root->P;
    Node.Dist= (Root->P.Pos[0] - Search->Pos[0])*(Root->P.Pos[0] - Search->Pos[0]) + (Root->P.Pos[1] - Search->Pos[1])*(Root->P.Pos[1] - Search->Pos[1]) + (Root->P.Pos[2] - Search->Pos[2])*(Root->P.Pos[2] - Search->Pos[2]);
    if (Node.Dist < Search->RadSq && angle > GPM_ATOL) { /* Check that Result is within Radius and Angular Tolerance */
	if (Search->Found < Search->Max) {
	    Push(Search, Node);
	} else {
	    if (Node.Dist < Search->List[0].Dist) {
		Pop(Search);
		Push(Search, Node);
	    }
	}
    }

#else

    /* REPLACE, Find Distance between Root Photon and NP->Pos */
    Dist= (Root->P.Pos[0] - Search->Pos[0])*(Root->P.Pos[0] - Search->Pos[0]) + (Root->P.Pos[1] - Search->Pos[1])*(Root->P.Pos[1] - Search->Pos[1]) + (Root->P.Pos[2] - Search->Pos[2])*(Root->P.Pos[2] - Search->Pos[2]);

    angle= VDOT(Search->Normal, Root->P.Normal);
    if (Dist < Search->RadSq && angle > GPM_ATOL) { /* Check that Result is within Radius and Angular Tolerance */
	/*  if (Dist < NP->RadSq) {*/
	if (Search->Found < Search->Max) {
	    Search->List[Search->Found++].P= Root->P;
	} else {
	    MDist= (Search->Pos[0] - Search->List[0].P.Pos[0])*(Search->Pos[0] - Search->List[0].P.Pos[0])+(Search->Pos[1] - Search->List[0].P.Pos[1])*(Search->Pos[1] - Search->List[0].P.Pos[1])+(Search->Pos[2] - Search->List[0].P.Pos[2])*(Search->Pos[2] - Search->List[0].P.Pos[2]);
	    MaxInd= 0;
	    for (i= 1; i < Search->Found; i++) {
		TDist= (Search->Pos[0] - Search->List[i].P.Pos[0])*(Search->Pos[0] - Search->List[i].P.Pos[0])+(Search->Pos[1] - Search->List[i].P.Pos[1])*(Search->Pos[1] - Search->List[i].P.Pos[1])+(Search->Pos[2] - Search->List[i].P.Pos[2])*(Search->Pos[2] - Search->List[i].P.Pos[2]);
		if (TDist > MDist) {
		    MDist= TDist;
		    MaxInd= i;
		}
	    }

	    if (Dist < MDist)
		Search->List[MaxInd].P= Root->P;
	}
    }
#endif
}


fastf_t Dist(point_t a, point_t b) {
    return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]);
}


fastf_t GaussFilter(fastf_t dist, fastf_t rad) {
    return( 0.918 * (1.0 - (1.0 - exp(-1.953*dist*dist/(2.0*rad*rad)))/(1.0 - exp(-1.953))) );
}


fastf_t ConeFilter(fastf_t dist, fastf_t rad) {
    return( 1.0 - dist/rad );
}


void IrradianceEstimate(struct application *ap, vect_t irrad, point_t pos, vect_t normal, fastf_t rad, int np) {
    struct	PhotonSearch	Search;
    int				i,index;
    fastf_t			dist,TotDist;
    vect_t			t,cirrad;


    index= 0;
    if (GPM_IH) {
	index= ap->a_x + ap->a_y*GPM_WIDTH;
	/* See if there is a cached irradiance calculation for this point */
	for (i= 0; i < IC[index].Num; i++) {
	    dist= (pos[0]-IC[index].List[i].Pos[0])*(pos[0]-IC[index].List[i].Pos[0])+(pos[1]-IC[index].List[i].Pos[1])*(pos[1]-IC[index].List[i].Pos[1])+(pos[2]-IC[index].List[i].Pos[2])*(pos[2]-IC[index].List[i].Pos[2]);
	    if (dist < (ScaleFactor/100.0)*(ScaleFactor*100.0)) {
		irrad[0]= IC[index].List[i].RGB[0];
		irrad[1]= IC[index].List[i].RGB[1];
		irrad[2]= IC[index].List[i].RGB[2];
		return;
	    }
	}

	/* There is no precomputed irradiance for this point, allocate space
	   for a new one if neccessary. */
	if (IC[index].Num) {
	    IC[index].List= (struct IrradNode*)bu_realloc(IC[index].List,sizeof(struct IrradNode)*(IC[index].Num+1), "List");
	}
    }

    Search.Pos[0]= pos[0];
    Search.Pos[1]= pos[1];
    Search.Pos[2]= pos[2];

    /*  NP.RadSq= (ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL]->MaxPhotons/2)/log(4))))) * (ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL]->MaxPhotons/2)/log(4)))));*/
    /*  bu_log("SF: %.3f\n",(ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL]->MaxPhotons/2)/log(4))))));*/
    /*  bu_log("SF: %.3f\n",ScaleFactor/pow(PMap[PM_GLOBAL]->MaxPhotons,0.5));*/

    /*
      Search.RadSq= 0.5*ScaleFactor/pow(PMap[PM_GLOBAL]->MaxPhotons,0.5) * ScaleFactor/pow(PMap[PM_GLOBAL]->MaxPhotons,0.5);
      Search.Max= pow(PMap[PM_GLOBAL]->StoredPhotons, 0.5);
    */

    Search.RadSq= (ScaleFactor/2048.0);
    Search.RadSq*= Search.RadSq;
    /*  NP.RadSq= (4.0*ScaleFactor/PMap[PM_GLOBAL]->MaxPhotons) * (4.0*ScaleFactor/PMap[PM_GLOBAL]->MaxPhotons);*/
    /*  NP.Max= 2.0*pow(PMap[PM_GLOBAL]->StoredPhotons, 0.5);*/
    /*  Search.Max= PMap[PM_GLOBAL]->StoredPhotons / 50;*/
    Search.Max= 32;

    Search.Normal[0]= normal[0];
    Search.Normal[1]= normal[1];
    Search.Normal[2]= normal[2];

    Search.List= (struct PSN*)bu_calloc(Search.Max, sizeof(struct PSN), "Search.List");
    do {
	Search.Found= 0;
	Search.RadSq*= 4.0;
	LocatePhotons(&Search,PMap[PM_GLOBAL]->Root);
    } while(Search.Found < Search.Max && Search.RadSq < ScaleFactor * ScaleFactor / 64.0);


    irrad[0]= irrad[1]= irrad[2]= 0;
    TotDist= 0;
    for (i= 0; i < Search.Found; i++) {
	t[0]= Search.List[i].P.Pos[0] - pos[0];
	t[1]= Search.List[i].P.Pos[1] - pos[1];
	t[2]= Search.List[i].P.Pos[2] - pos[2];
	TotDist+= t[0]*t[0] + t[1]*t[1] + t[2]*t[2];
    }


    for (i= 0; i < Search.Found; i++) {
	t[0]= Search.List[i].P.Pos[0] - pos[0];
	t[1]= Search.List[i].P.Pos[1] - pos[1];
	t[2]= Search.List[i].P.Pos[2] - pos[2];

	t[0]= (t[0]*t[0] + t[1]*t[1] + t[2]*t[2])/TotDist;
	/*
	  irrad[0]+= Search.List[i].P.Irrad[0] * t[0];
	  irrad[1]+= Search.List[i].P.Irrad[1] * t[0];
	  irrad[2]+= Search.List[i].P.Irrad[2] * t[0];
	*/
	irrad[0]+= Search.List[i].P.Irrad[0];
	irrad[1]+= Search.List[i].P.Irrad[1];
	irrad[2]+= Search.List[i].P.Irrad[2];
    }
    if (Search.Found) {
	irrad[0]/= (double)Search.Found;
	irrad[1]/= (double)Search.Found;
	irrad[2]/= (double)Search.Found;
    }
    bu_free(Search.List, "Search.List");

    /*  GetEstimate(cirrad, pos, normal, (int)(ScaleFactor/100.0),PMap[PM_CAUSTIC]->MaxPhotons/50,PM_CAUSTIC,1, 0);*/
    /*  GetEstimate(cirrad,pos,normal,(int)(ScaleFactor/pow(2,(log(PMap[PM_CAUSTIC]->MaxPhotons/2)/log(4)))),PMap[PM_CAUSTIC]->MaxPhotons / 50,PM_CAUSTIC,0,0);*/
    GetEstimate(cirrad,pos,normal,ScaleFactor/1024.0,PMap[PM_CAUSTIC]->MaxPhotons / 100,PM_CAUSTIC,ScaleFactor/128.0,1,15);

    irrad[0]+= cirrad[0];
    irrad[1]+= cirrad[1];
    irrad[2]+= cirrad[2];


    /* Visualize Green Importons */
    /*
      GetEstimate(cirrad,pos,normal,ScaleFactor/512.0,1,PM_IMPORTANCE,ScaleFactor/256.0,1,1);

      irrad[0]+= cirrad[0];
      irrad[1]+= cirrad[1];
      irrad[2]+= cirrad[2];
    */

    if (GPM_IH) {
	/* Store Irradiance */
	IC[index].List[IC[index].Num].RGB[0]= irrad[0];
	IC[index].List[IC[index].Num].RGB[1]= irrad[1];
	IC[index].List[IC[index].Num].RGB[2]= irrad[2];

	IC[index].List[IC[index].Num].Pos[0]= pos[0];
	IC[index].List[IC[index].Num].Pos[1]= pos[1];
	IC[index].List[IC[index].Num].Pos[2]= pos[2];

	IC[index].Num++;
    }
}


void GetEstimate(vect_t irrad, point_t pos, vect_t normal, fastf_t rad, int np, int map, double max_rad, int centog, int min_np) {
    struct	PhotonSearch	Search;
    int				i;
    fastf_t			tmp,dist,Filter,ScaleFilter;
    vect_t			t,Centroid;


    irrad[0]= irrad[1]= irrad[2]= 0;
    if (!PMap[map]->StoredPhotons) return;

    Search.Pos[0]= pos[0];
    Search.Pos[1]= pos[1];
    Search.Pos[2]= pos[2];

    Search.RadSq= rad*rad/4.0;
    Search.Max= np < min_np ? min_np : np;
    Search.Normal[0]= normal[0];
    Search.Normal[1]= normal[1];
    Search.Normal[2]= normal[2];

    Search.List= (struct PSN*)bu_calloc(Search.Max, sizeof(struct PSN), "PSN");
    do {
	Search.Found= 0;
	Search.RadSq*= 4.0;
	LocatePhotons(&Search,PMap[map]->Root);
	if (!Search.Found && Search.RadSq > ScaleFactor*ScaleFactor/100.0)
	    break;
    } while(Search.Found < Search.Max && Search.RadSq < max_rad*max_rad);

    /*  bu_log("Found: %d\n",Search.Found);*/
    if (Search.Found < min_np) {
	bu_free(Search.List, "Search.List");
	return;
    }

    /* Calculate Max Distance */
    Search.RadSq= 1;
    Centroid[0]= Centroid[1]= Centroid[2]= 0;

    for (i= 0; i < Search.Found; i++) {
	t[0]= Search.List[i].P.Pos[0] - pos[0];
	t[1]= Search.List[i].P.Pos[1] - pos[1];
	t[2]= Search.List[i].P.Pos[2] - pos[2];

	Centroid[0]+= Search.List[i].P.Pos[0];
	Centroid[1]+= Search.List[i].P.Pos[1];
	Centroid[2]+= Search.List[i].P.Pos[2];

	dist= t[0]*t[0] + t[1]*t[1] + t[2]*t[2];
	if (dist > Search.RadSq)
	    Search.RadSq= dist;
    }

    if (Search.Found) {
	Centroid[0]/= (double)Search.Found;
	Centroid[1]/= (double)Search.Found;
	Centroid[2]/= (double)Search.Found;
    }


    /* This needs a little debugging, splotches in moss cause tmp gets too small, will look at later, ||1 to turn it off */
    if (!centog||1) {
	Centroid[0]= pos[0];
	Centroid[1]= pos[1];
	Centroid[2]= pos[2];
	ScaleFilter= 2.0;
    } else {
	ScaleFilter= 1.0;
    }

    for (i= 0; i < Search.Found; i++) {
	t[0]= Search.List[i].P.Pos[0] - pos[0];
	t[1]= Search.List[i].P.Pos[1] - pos[1];
	t[2]= Search.List[i].P.Pos[2] - pos[2];

	dist= t[0]*t[0] + t[1]*t[1] + t[2]*t[2];
	/*      Filter= 0.50;*/
	/*      Filter= ConeFilter(dist,NP.RadSq);*/
	Filter= 0.5*GaussFilter(dist,Search.RadSq);

	irrad[0]+= Search.List[i].P.Power[0]*Filter*ScaleFilter;
	irrad[1]+= Search.List[i].P.Power[1]*Filter*ScaleFilter;
	irrad[2]+= Search.List[i].P.Power[2]*Filter*ScaleFilter;
    }

    tmp= M_PI*Search.RadSq;
    t[0]= sqrt((Centroid[0] - pos[0])*(Centroid[0] - pos[0])+(Centroid[1] - pos[1])*(Centroid[1] - pos[1])+(Centroid[2] - pos[2])*(Centroid[2] - pos[2]));
    tmp= M_PI*(sqrt(Search.RadSq)-t[0])*(sqrt(Search.RadSq)-t[0]);


    irrad[0]/= tmp;
    irrad[1]/= tmp;
    irrad[2]/= tmp;

    /*
      if (irrad[0] > 10 || irrad[1] > 10 || irrad[2] > 10) {
      bu_log("found: %d, tmp: %.1f\n",Search.Found,tmp);
      }
    */
    if (map == PM_CAUSTIC) {
	tmp= (double)Search.Found/(double)Search.Max;
	irrad[0]*= tmp;
	irrad[1]*= tmp;
	irrad[2]*= tmp;
    }

    /*
      irrad[0]*= (1.0/M_PI)/NP.RadSq;
      irrad[1]*= (1.0/M_PI)/NP.RadSq;
      irrad[2]*= (1.0/M_PI)/NP.RadSq;
    */
    bu_free(Search.List, "Search.List");
    /*  bu_log("Radius: %.3f, Max Phot: %d, Found: %d, Power: [%.4f,%.4f,%.4f], Pos: [%.3f,%.3f,%.3f]\n",sqrt(NP.RadSq), NP.Max,NP.Found,irrad[0],irrad[1],irrad[2],pos[0],pos[1],pos[2]);*/
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.26
log
@removed trailing whitespace
@
text
@d332 1
a332 1
	  memcpy(phong_sp, &phong_defaults, sizeof(struct phong_specific) );
d368 1
a368 1
	  memcpy(phong_sp, &phong_defaults, sizeof(struct phong_specific) );
d1224 3
a1226 3
    memcpy(&c,a,sizeof(struct PSN));
    memcpy(a,b,sizeof(struct PSN));
    memcpy(b,&c,sizeof(struct PSN));
@


14.25
log
@multiply as a double
@
text
@d941 1
a941 1
    if(MapSize > 0) 
@


14.24
log
@should only be using common.h, not brlcad_config.h
@
text
@d836 1
a836 1
	    phi= (2*M_PI)*((i-rand()/(double)RAND_MAX)/N);
d839 1
a839 1
	    phi= (2*M_PI)*((i-drand48())/N);
@


14.23
log
@Timer based progress report on irradiance cache if sigalrm is handy. Also tries to estimate how much time left. PR#1312281.
@
text
@d36 1
a36 2
#include "photonmap.h"
#include "brlcad_config.h"
d41 1
a41 1
# include <signal.h>
d44 3
@


14.22
log
@carry a_logoverlap so -R has the expected behavior when building the irradiance cache
@
text
@d37 2
d41 4
a875 1

d881 1
a881 1
	/*    bu_log("cp:A:%d\n",Node->C);*/
d884 1
a890 1

d895 24
d921 4
d926 5
@


14.21
log
@try not to bu_malloc() 0 bytes. Caused the lighting model to bomb...
@
text
@d820 1
@


14.20
log
@missed a realloc, use calloc where we need it be zero
@
text
@d900 4
a903 1
    Emit[MAP]= (struct Photon*)bu_malloc(sizeof(struct Photon)*MapSize, "Photon");
@


14.19
log
@use libbu memory management.. there's a bug in here somewhere where a right tree node becomes non-null invalid.  also seems to be a massive amount of leakage going on .. stuff not getting free'd..
@
text
@d1141 1
a1141 3
	    Map= (char*)bu_malloc(sizeof(char)*width*height, "Map");
	    for (i= 0; i < width*height; i++)
		Map[i]= 0;
d1357 3
a1359 2
	if (IC[index].Num)
	    IC[index].List= (struct IrradNode*)realloc(IC[index].List,sizeof(struct IrradNode)*(IC[index].Num+1));
@


14.18
log
@ws
@
text
@d101 2
a102 2
    LList= (struct Photon*)malloc(sizeof(struct Photon)*ESize);
    RList= (struct Photon*)malloc(sizeof(struct Photon)*ESize);
d156 1
a156 1
	Root->L= (struct PNode*)malloc(sizeof(struct PNode));
d163 1
a163 1
	Root->R= (struct PNode*)malloc(sizeof(struct PNode));
d169 2
a170 2
    free(LList);
    free(RList);
d193 1
a193 1
	Search.List= (struct PSN*)malloc(sizeof(struct PSN)*Search.Max);
d195 1
a195 1
	free(Search.List);
a200 10
	/*
	  do {
	  Search.RadSq*= 4.0;
	  Search.Found= 0;
	  LocatePhotons(&Search,PMap[map]->Root);
	  if (!Search.Found && Search.RadSq > ScaleFactor*ScaleFactor/100.0)
	  break;
	  } while(Search.Found < Search.Max && Search.RadSq < max_rad*max_rad);
	  free(Search.List);
	*/
d308 1
a308 1
    phong_sp= (struct phong_specific*)malloc(sizeof(struct phong_specific));
d382 1
a382 1
    free(phong_sp);
d814 1
a814 1
    lap= (struct application*)malloc(sizeof(struct application));
d856 1
a856 1
    free(lap);
d896 1
a896 1
    PMap[MAP]= (struct PhotonMap*)malloc(sizeof(struct PhotonMap));
d898 1
a898 1
    PMap[MAP]->Root= (struct PNode*)malloc(sizeof(struct PNode));
d900 1
a900 1
    Emit[MAP]= (struct Photon*)malloc(sizeof(struct Photon)*MapSize);
d1125 1
a1125 2
	    GPM_RTAB= (struct resource*)malloc(sizeof(struct resource)*cpus);
	    bzero(GPM_RTAB,cpus*sizeof(struct resource));
d1141 1
a1141 1
	    Map= (char*)malloc(sizeof(char)*width*height);
d1144 1
a1144 1
	    IC= (struct IrradCache*)malloc(sizeof(struct IrradCache)*width*height);
d1146 1
a1146 1
		IC[i].List= (struct IrradNode*)malloc(sizeof(struct IrradNode));
d1159 4
a1162 2
	for (i= 0; i < PM_MAPS; i++)
	    free(Emit[i]);
d1165 2
a1166 1
    free(GPM_RTAB);
d1387 1
a1387 1
    Search.List= (struct PSN*)malloc(sizeof(struct PSN)*Search.Max);
d1425 1
a1425 1
    free(Search.List);
d1480 1
a1480 1
    Search.List= (struct PSN*)malloc(sizeof(struct PSN)*Search.Max);
d1491 1
a1491 1
	free(Search.List);
d1571 1
a1571 1
    free(Search.List);
@


14.17
log
@removed the spaced out pointer dereference format inconsistencies
@
text
@d74 2
a75 2
  int		i;
  fastf_t	Min,Max,Mean;
d77 11
a87 11
  Min= Max= List[0].Pos[Axis];
  for (i= 1; i < Num; i++) {
    if (List[i].Pos[Axis] < Min)
      Min= List[i].Pos[Axis];
    if (List[i].Pos[Axis] > Max)
      Max= List[i].Pos[Axis];
  }
  Mean= (Min+Max)/2.0;
  i= 0;
  while (List[i].Pos[Axis] < Mean && i < Num)
    i++;
d89 1
a89 1
  return i;
d95 50
a144 49
  struct	Photon	*LList,*RList;
  vect_t		Min,Max;
  int			i,Axis,MedianIndex,LInd,RInd;


  /* Allocate memory for left and right lists */
  LList= (struct Photon*)malloc(sizeof(struct Photon)*ESize);
  RList= (struct Photon*)malloc(sizeof(struct Photon)*ESize);

  /* Find the Bounding volume of the Current list of photons */
  Min[0]= Max[0]= EList[0].Pos[0];
  Min[1]= Max[1]= EList[0].Pos[1];
  Min[2]= Max[2]= EList[0].Pos[2];
  for (i= 1; i < ESize; i++) {
    if (EList[i].Pos[0] < Min[0]) Min[0]= EList[i].Pos[0];
    if (EList[i].Pos[1] < Min[1]) Min[1]= EList[i].Pos[1];
    if (EList[i].Pos[2] < Min[2]) Min[2]= EList[i].Pos[2];
    if (EList[i].Pos[0] > Max[0]) Max[0]= EList[i].Pos[0];
    if (EList[i].Pos[1] > Max[1]) Max[1]= EList[i].Pos[1];
    if (EList[i].Pos[2] > Max[2]) Max[2]= EList[i].Pos[2];
  }

  /* Obtain splitting Axis, which is the largest dimension of the bounding volume */
  Max[0]-= Min[0];
  Max[1]-= Min[1];
  Max[2]-= Min[2];
  Axis= 0;
  if (Max[1] > Max[0] && Max[1] > Max[2]) Axis= 1;
  if (Max[2] > Max[0] && Max[2] > Max[1]) Axis= 2;

  /* Find Median Photon to splt by. */
  MedianIndex= FindMedian(EList,ESize,Axis);

  /* Build Left and Right Lists and make sure the Median Photon is not included in either list. */
  LInd= RInd= 0;
  for (i= 0; i < ESize; i++) {
    if (i != MedianIndex) {
      if (EList[i].Pos[Axis] < EList[MedianIndex].Pos[Axis]) {
	LList[LInd++]= EList[i];
      } else {
	RList[RInd++]= EList[i];
      }
/*
      if (EList[i].Pos[Axis] < Median.Pos[Axis]) {
	LList[LInd++]= EList[i];
      } else {
	RList[RInd++]= EList[i];
      }
*/
a145 1
  }
d147 21
a167 21
  /* Store the Median Photon into the KD-Tree. */
/*  bu_log("insertKD: %.3f,%.3f,%.3f\n",EList[MedianIndex].Pos[0],EList[MedianIndex].Pos[1],EList[MedianIndex].Pos[2]);*/
  Root->P= EList[MedianIndex];
  Root->P.Axis= Axis;
  Root->C= 0;

  /* With Left and Right if either contain any photons then repeat this process */
/*  if (LInd) bu_log("Left Branch\n");*/
  if (LInd) {
    Root->L= (struct PNode*)malloc(sizeof(struct PNode));
    Root->L->L= 0;
    Root->L->R= 0;
    BuildTree(LList,LInd,Root->L);
  }
/*  if (RInd) bu_log("Right Branch\n");*/
  if (RInd) {
    Root->R= (struct PNode*)malloc(sizeof(struct PNode));
    Root->R->L= 0;
    Root->R->R= 0;
    BuildTree(RList,RInd,Root->R);
  }
d169 2
a170 2
  free(LList);
  free(RList);
d176 2
a177 2
  struct	PhotonSearch	Search;
  int				i;
d179 32
a210 21
  /* If Importance Mapping is enabled, Check to see if the Photon is in an area that is considered important, if not then disregard it */
  if (Map != PM_IMPORTANCE && PMap[PM_IMPORTANCE]->StoredPhotons) {
    /* Do a KD-Tree lookup and if the photon is within a distance of sqrt(ScaleFactor) from the nearest importon then keep it, otherwise discard it */

    Search.RadSq= ScaleFactor;
    Search.Found= 0;
    Search.Max= 1;
    Search.Pos[0]= Pos[0];
    Search.Pos[1]= Pos[1];
    Search.Pos[2]= Pos[2];
    Search.Normal[0]= Normal[0];
    Search.Normal[1]= Normal[1];
    Search.Normal[2]= Normal[2];

    Search.List= (struct PSN*)malloc(sizeof(struct PSN)*Search.Max);
    LocatePhotons(&Search,PMap[PM_IMPORTANCE]->Root);
    free(Search.List);

    if (!Search.Found) {
      HitB++;
      return;
a211 11
/*
    do {
      Search.RadSq*= 4.0;
      Search.Found= 0;
      LocatePhotons(&Search,PMap[map]->Root);
      if (!Search.Found && Search.RadSq > ScaleFactor*ScaleFactor/100.0)
	break;
    } while(Search.Found < Search.Max && Search.RadSq < max_rad*max_rad);
    free(Search.List);
*/
  }
d214 18
a231 8
  if (PMap[Map]->StoredPhotons < PMap[Map]->MaxPhotons) {
    HitG++;
    for (i= 0; i < 3; i++) {
      /* Store Position, Direction, and Power of Photon */
      Emit[Map][PMap[Map]->StoredPhotons].Pos[i]= Pos[i];
      Emit[Map][PMap[Map]->StoredPhotons].Dir[i]= Dir[i];
      Emit[Map][PMap[Map]->StoredPhotons].Normal[i]= Normal[i];
      Emit[Map][PMap[Map]->StoredPhotons].Power[i]= CurPh.Power[i];
a232 10
    PMap[Map]->StoredPhotons++;
/*
    if (Map != PM_IMPORTANCE && PMap[PM_IMPORTANCE]->StoredPhotons < PMap[PM_IMPORTANCE]->MaxPhotons)
      bu_log("Map2: %d, Size: %d\n",Map,PMap[Map]->StoredPhotons);
*/
/*
    if (Map == PM_IMPORTANCE)
    bu_log("Map: %d, Size: %d, [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",Map,PMap[Map]->StoredPhotons, Pos[0],Pos[1],Pos[2], CurPh.Power[0], CurPh.Power[1], CurPh.Power[2]);
*/
  }
d234 5
a238 5
/*
  bu_log("[%d][%d][%.3f,%.3f,%.3f]\n",Map,PMap[Map]->StoredPhotons,CurPh.Power[0],CurPh.Power[1],CurPh.Power[2]);
  if (!(PMap[Map]->StoredPhotons % 64))
  bu_log("[%d][%d][%.3f,%.3f,%.3f]\n",Map,PMap[Map]->StoredPhotons,Pos[0],Pos[1],Pos[2]);
*/
d244 2
a245 2
  vect_t	d;
  fastf_t	dot;
d247 2
a248 2
  VSCALE(d,rdir,-1);
  dot= VDOT(d,normal);
d250 6
a255 6
  if (dot < 0.0f) {
    rdir[0]= rdir[1]= rdir[2]= 0;
  } else {
    VSCALE(rdir,normal,2*dot);
    VSUB2(rdir,rdir,d);
  }
d261 2
a262 2
  /* Allow Photons to get a random direction at most 60 degrees to the normal */
  do {
d264 3
a266 3
    rdir[0]= 2.0*rand()/(double)RAND_MAX-1.0;
    rdir[1]= 2.0*rand()/(double)RAND_MAX-1.0;
    rdir[2]= 2.0*rand()/(double)RAND_MAX-1.0;
d268 3
a270 3
    rdir[0]= 2.0*drand48()-1.0;
    rdir[1]= 2.0*drand48()-1.0;
    rdir[2]= 2.0*drand48()-1.0;
d272 2
a273 2
    VUNITIZE(rdir);
  } while (VDOT(rdir,normal) < 0.5);
d279 2
a280 2
  fastf_t	n,c1,c2,radicand;
  vect_t	t,r;
d282 9
a290 9
  n= n1/n2;
  c1= -VDOT(I,N);
  radicand= 1.0 - (n*n)*(1.0-c1*c1);
  if (radicand < 0) {
    /* Total Internal Reflection */
    I[0]= I[1]= I[2]= 0;
    return(0);
  }
  c2= sqrt(radicand);
d292 4
a295 4
  VSCALE(r,I,n);
  VSCALE(t,N,n*c1-c2);
  VADD2(I,r,t);
  return(1);
d300 1
a300 1
  int	i;
d302 6
a307 3
  if (MS) {
    for (i= 0; i < strlen(cmp) && i < strlen(MS); i++)
      if (MS[i] != cmp[i])
d309 1
a309 4
    return(1);
  } else {
    return(0);
  }
d315 2
a316 2
  struct	phong_specific	*phong_sp;
  struct	bu_vls		matparm;
d318 1
a318 1
  phong_sp= (struct phong_specific*)malloc(sizeof(struct phong_specific));
d320 71
a390 47
  /* Initialize spec and refi */
  spec[0]= spec[1]= spec[2]= *refi= *transmit= 0;
  if (CheckMaterial("plastic",MS)) { /* Checks that the first 7 chars match any of the characters found in plastic */
    /* Plastic Shader */
    phong_sp->magic= PL_MAGIC;
    phong_sp->shine= 10;
    phong_sp->wgt_specular= 0.7;
    phong_sp->wgt_diffuse= 0.3;
    phong_sp->transmit= 0.0;
    phong_sp->reflect= 0.0;
    phong_sp->refrac_index= 1.0;
    phong_sp->extinction= 0.0;
/*
    BU_GETSTRUCT(phong_sp, phong_specific);
    memcpy(phong_sp, &phong_defaults, sizeof(struct phong_specific) );
*/
    MS+= 7;
    bu_vls_init(&matparm);
    bu_vls_printf(&matparm,"%s",MS);
    bu_struct_parse(&matparm, phong_parse, (char *)phong_sp);
    bu_vls_free(&matparm);

/*    bu_log("string: %s\n",MS);*/
/*    bu_log("info[%d]: sh: %d, spec: %.3f, diff: %.3f, tran: %.3f, refl: %.3f, refr: %.3f\n", PMap->StoredPhotons, phong_sp->shine, phong_sp->wgt_specular, phong_sp->wgt_diffuse, phong_sp->transmit, phong_sp->reflect, phong_sp->refrac_index);*/
/*    bu_log("spec[%d]: %.3f\n",PMap->StoredPhotons, phong_sp->wgt_specular);*/

    spec[0]= spec[1]= spec[2]= phong_sp->wgt_specular;
    *refi= phong_sp->refrac_index;
    spec[0]= spec[1]= spec[2]= 0.7;
/*
    *refi= 1.0;
    *transmit= 0.0;
*/
/*
    if (phong_sp->refrac_index != 1.0)
    bu_log("refi: %.3f\n",phong_sp->refrac_index);
*/
  } else if (CheckMaterial("glass",MS)) {
    /* Glass Shader */
    phong_sp->magic= PL_MAGIC;
    phong_sp->shine= 4;
    phong_sp->wgt_specular= 0.7;
    phong_sp->wgt_diffuse= 0.3;
    phong_sp->transmit= 0.8;
    phong_sp->reflect= 0.1;
    phong_sp->refrac_index= 1.65;
    phong_sp->extinction= 0.0;
d392 1
a392 25
/*
    BU_GETSTRUCT(phong_sp, phong_specific);
    memcpy(phong_sp, &phong_defaults, sizeof(struct phong_specific) );
*/
    MS+= 5; /* move pointer past "pm " (3 characters) */
    bu_vls_init(&matparm);
    bu_vls_printf(&matparm,"%s",MS);
    bu_struct_parse(&matparm, phong_parse, (char *)phong_sp);
    bu_vls_free(&matparm);

/*    bu_log("string: %s\n",MS);*/
/*    bu_log("info[%d]: sh: %d, spec: %.3f, diff: %.3f, tran: %.3f, refl: %.3f, refr: %.3f\n", PMap->StoredPhotons, phong_sp->shine, phong_sp->wgt_specular, phong_sp->wgt_diffuse, phong_sp->transmit, phong_sp->reflect, phong_sp->refrac_index);*/
/*    bu_log("spec[%d]: %.3f\n",PMap->StoredPhotons, phong_sp->wgt_specular);*/

    spec[0]= spec[1]= spec[2]= phong_sp->wgt_specular;
    *refi= phong_sp->refrac_index;
    *transmit= phong_sp->transmit;

/*
    if (phong_sp->refrac_index != 1.0)
    bu_log("refi: %.3f\n",phong_sp->refrac_index);
*/
  }

  free(phong_sp);
d397 1
a397 1
  return a > b ? a > c ? a : c : b > c ? b : c;
d402 3
a404 3
  struct	partition	*part;
  vect_t			pt,normal,spec;
  fastf_t			refi,transmit;
d406 2
a407 2
  ap->a_hit= PHit;
  part= PartHeadp->pt_forw;
d409 2
a410 2
  /* Compute Intersection Point, Pt= o + td */
  VJOIN1(pt, ap->a_ray.r_pt, part->pt_outhit->hit_dist, ap->a_ray.r_dir);
d412 26
a437 4
  /* Fetch Intersection Normal */
  RT_HIT_NORMAL(normal, part->pt_inhit, part->pt_inseg->seg_stp, &(ap->a_ray), part->pt_inflip);
/*  RT_HIT_NORMAL(normal, part->pt_outhit, part->pt_inseg->seg_stp, &(ap->a_ray), part->pt_inflip);*/
/*  RT_HIT_NORMAL(normal, part->pt_outhit, part->pt_outseg->seg_stp, &(ap->a_ray), part->pt_outflip);*/
d439 2
a440 24
  /* Assign pt */
  ap->a_ray.r_pt[0]= pt[0];
  ap->a_ray.r_pt[1]= pt[1];
  ap->a_ray.r_pt[2]= pt[2];


  /* Fetch Material */
  GetMaterial(part->pt_regionp->reg_mater.ma_shader, spec, &refi, &transmit);


  if (Refract(ap->a_ray.r_dir,normal,refi,1.0)) {
/*
    bu_log("1D: %d, [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f]\n",Depth,pt[0],pt[1],pt[2],ap->a_ray.r_dir[0], ap->a_ray.r_dir[1], ap->a_ray.r_dir[2],normal[0],normal[1],normal[2]);
    bu_log("p1: [%.3f,%.3f,%.3f]\n",part->pt_inhit->hit_point[0], part->pt_inhit->hit_point[1], part->pt_inhit->hit_point[2]);
    bu_log("p2: [%.3f,%.3f,%.3f]\n",part->pt_outhit->hit_point[0], part->pt_outhit->hit_point[1], part->pt_outhit->hit_point[2]);
*/
    Depth++;
    rt_shootray(ap);
  } else {
    bu_log("TIF\n");
  }

  ap->a_onehit= 0;
  return(1);
d446 21
a466 5
  struct	partition	*part;
  vect_t			pt,normal,color,spec,power;
  fastf_t			refi,transmit,prob,prob_diff,prob_spec,prob_ref;
  int				hit;

d468 2
a469 8
  /* Move ptr forward to next region and call Hit recursively until reaching a region this is either
     not a light or none at all */
  hit= 0;
  for (BU_LIST_FOR(part, partition, (struct bu_list *)PartHeadp)) {
    if (part != PartHeadp) {
    hit++;
    VJOIN1(pt, ap->a_ray.r_pt, part->pt_inhit->hit_dist, ap->a_ray.r_dir);
/*    printf("pt[%d][%d]: --- [%.3f,%.3f,%.3f], %s\n",hit,CheckMaterial("light",part->pt_regionp->reg_mater.ma_shader),pt[0],pt[1],pt[2],part->pt_regionp->reg_mater.ma_shader);*/
a470 6
      if (!CheckMaterial("light",part->pt_regionp->reg_mater.ma_shader)) {
/*        bu_log("  Found object!\n");*/
	break;
      }
    }
  }
d472 2
a473 2
  if (part == PartHeadp)
    return 0;
d476 2
a477 2
  if (CheckMaterial("light",part->pt_regionp->reg_mater.ma_shader))
    return 0;
d480 20
a499 2
  /* Compute Intersection Point, Pt= o + td */
  VJOIN1(pt, ap->a_ray.r_pt, part->pt_inhit->hit_dist, ap->a_ray.r_dir);
d501 2
d504 13
a516 37
  /* Generate Bounding Box for Scaling Phase */
  if (PInit) {
    BBMin[0]= BBMax[0]= pt[0];
    BBMin[1]= BBMax[1]= pt[1];
    BBMin[2]= BBMax[2]= pt[2];
    PInit= 0;
  } else {
    if (pt[0] < BBMin[0])
      BBMin[0]= pt[0];
    if (pt[0] > BBMax[0])
      BBMax[0]= pt[0];
    if (pt[1] < BBMin[1])
      BBMin[1]= pt[1];
    if (pt[1] > BBMax[1])
      BBMax[1]= pt[1];
    if (pt[2] < BBMin[2])
      BBMin[2]= pt[2];
    if (pt[2] > BBMax[2])
      BBMax[2]= pt[2];
  }

  /* Fetch Intersection Normal */
  RT_HIT_NORMAL(normal, part->pt_inhit, part->pt_inseg->seg_stp, &(ap->a_ray), part->pt_inflip);

  /* Fetch Material */
  GetMaterial(part->pt_regionp->reg_mater.ma_shader, spec, &refi, &transmit);
/*  bu_log("Spec: [%.3f,%.3f,%.3f], Refi: %.3f\n",spec[0],spec[1],spec[2],refi);*/


  /* Compute Diffuse, Specular, and Caustics */
  color[0]= part->pt_regionp->reg_mater.ma_color[0];
  color[1]= part->pt_regionp->reg_mater.ma_color[1];
  color[2]= part->pt_regionp->reg_mater.ma_color[2];

  prob_ref= MaxFloat(color[0]+spec[0],color[1]+spec[1],color[2]+spec[2]);
  prob_diff= ((color[0]+color[1]+color[2])/(color[0]+color[1]+color[2]+spec[0]+spec[1]+spec[2]))*prob_ref;
  prob_spec= prob_ref - prob_diff;
d518 1
a518 1
  prob= rand()/(double)RAND_MAX;
d520 1
a520 1
  prob= drand48();
d523 2
a524 2
/* bu_log("pr: %.3f, pd: %.3f, [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",prob_ref,prob_diff,color[0],color[1],color[2],spec[0],spec[1],spec[2]);*/
/* bu_log("prob: %.3f, prob_diff: %.3f, pd+ps: %.3f\n",prob,prob_diff,prob_diff+prob_spec);*/
d526 55
a580 51
  if (prob < 1.0 - transmit) {
    if (prob < prob_diff) {
      /* Store power of incident Photon */
      power[0]= CurPh.Power[0];
      power[1]= CurPh.Power[1];
      power[2]= CurPh.Power[2];


      /* Scale Power of reflected photon */
      CurPh.Power[0]= power[0]*color[0]/prob_diff;
      CurPh.Power[1]= power[1]*color[1]/prob_diff;
      CurPh.Power[2]= power[2]*color[2]/prob_diff;

      /* Store Photon */
      Store(pt, ap->a_ray.r_dir, normal, PType);

      /* Assign diffuse reflection direction */
      DiffuseReflect(normal,ap->a_ray.r_dir);

      /* Assign pt */
      ap->a_ray.r_pt[0]= pt[0];
      ap->a_ray.r_pt[1]= pt[1];
      ap->a_ray.r_pt[2]= pt[2];

      if (PType != PM_CAUSTIC) {
	  Depth++;
	  rt_shootray(ap);
      }
    } else if (prob >= prob_diff && prob < prob_diff + prob_spec) {
      /* Store power of incident Photon */
      power[0]= CurPh.Power[0];
      power[1]= CurPh.Power[1];
      power[2]= CurPh.Power[2];

      /* Scale power of reflected photon */
      CurPh.Power[0]= power[0]*spec[0]/prob_spec;
      CurPh.Power[1]= power[1]*spec[1]/prob_spec;
      CurPh.Power[2]= power[2]*spec[2]/prob_spec;

      /* Reflective */
      SpecularReflect(normal,ap->a_ray.r_dir);

      /* Assign pt */
      ap->a_ray.r_pt[0]= pt[0];
      ap->a_ray.r_pt[1]= pt[1];
      ap->a_ray.r_pt[2]= pt[2];

      if (PType != PM_IMPORTANCE)
	PType= PM_CAUSTIC;
      Depth++;
      rt_shootray(ap);
d582 45
a626 48
      /* Store Photon */
      Store(pt, ap->a_ray.r_dir, normal, PType);
    }
  } else {
    if (refi > 1.0 && (PType == PM_CAUSTIC || Depth == 0)) {
      if (PType != PM_IMPORTANCE)
	PType= PM_CAUSTIC;

      /* Store power of incident Photon */
      power[0]= CurPh.Power[0];
      power[1]= CurPh.Power[1];
      power[2]= CurPh.Power[2];

      /* Scale power of reflected photon */
      CurPh.Power[0]= power[0]*spec[0]/prob_spec;
      CurPh.Power[1]= power[1]*spec[1]/prob_spec;
      CurPh.Power[2]= power[2]*spec[2]/prob_spec;

      /* Refractive or Reflective */
      if (refi > 1.0 && prob < transmit) {
	CurPh.Power[0]= power[0];
	CurPh.Power[1]= power[1];
	CurPh.Power[2]= power[2];

	if (!Refract(ap->a_ray.r_dir,normal,1.0,refi))
	  printf("TIF0\n");

	ap->a_hit= HitRef;

/*
	bu_log("dir: [%.3f,%.3f,%.3f]\n",ap->a_ray.r_dir[0],ap->a_ray.r_dir[1],ap->a_ray.r_dir[2]);
	bu_log("ref: [%.3f,%.3f,%.3f]\n",ap->a_ray.r_dir[0],ap->a_ray.r_dir[1],ap->a_ray.r_dir[2]);
	bu_log("nor: [%.3f,%.3f,%.3f]\n",normal[0],normal[1],normal[2]);
	bu_log("p0: [%.3f,%.3f,%.3f],[%.3f,%.3f,%.3f]\n",pt[0],pt[1],pt[2],ap->a_ray.r_dir[0],ap->a_ray.r_dir[1],ap->a_ray.r_dir[2]);
*/
	ap->a_onehit= 0;
      } else {
	SpecularReflect(normal,ap->a_ray.r_dir);
      }

      /* Assign pt */
      ap->a_ray.r_pt[0]= pt[0];
      ap->a_ray.r_pt[1]= pt[1];
      ap->a_ray.r_pt[2]= pt[2];

/*      bu_log("2D: %d, [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f]\n",Depth,pt[0],pt[1],pt[2],ap->a_ray.r_dir[0], ap->a_ray.r_dir[1], ap->a_ray.r_dir[2],normal[0],normal[1],normal[2]);*/
      Depth++;
      rt_shootray(ap);
d628 1
a628 2
  }
  return 1;
d634 1
a634 1
  return 0;
d644 1
a644 1
  int		i;
d646 5
a650 5
  for (i= 0; i < PMap[Map]->StoredPhotons; i++) {
    Emit[Map][i].Power[0]*= ScaleFactor/(double)EPS[Map];
    Emit[Map][i].Power[1]*= ScaleFactor/(double)EPS[Map];
    Emit[Map][i].Power[2]*= ScaleFactor/(double)EPS[Map];
  }
d656 3
a658 3
  while (PMap[PM_IMPORTANCE]->StoredPhotons < PMap[PM_IMPORTANCE]->MaxPhotons) {
    do {
      /* Set Ray Direction to application ptr */
d660 3
a662 3
      ap->a_ray.r_dir[0]= 2.0*rand()/(double)RAND_MAX-1.0;
      ap->a_ray.r_dir[1]= 2.0*rand()/(double)RAND_MAX-1.0;
      ap->a_ray.r_dir[2]= 2.0*rand()/(double)RAND_MAX-1.0;
d664 3
a666 3
      ap->a_ray.r_dir[0]= 2.0*drand48()-1.0;
      ap->a_ray.r_dir[1]= 2.0*drand48()-1.0;
      ap->a_ray.r_dir[2]= 2.0*drand48()-1.0;
d668 1
a668 1
    } while (ap->a_ray.r_dir[0]*ap->a_ray.r_dir[0] + ap->a_ray.r_dir[1]*ap->a_ray.r_dir[1] + ap->a_ray.r_dir[2]*ap->a_ray.r_dir[2] > 1);
d670 2
a671 2
    /* Normalize Ray Direction */
    VUNITIZE(ap->a_ray.r_dir);
d673 14
a686 14
    /* Set Ray Position to application ptr */
    ap->a_ray.r_pt[0]= eye_pos[0];
    ap->a_ray.r_pt[1]= eye_pos[1];
    ap->a_ray.r_pt[2]= eye_pos[2];

    /* Shoot Importon into Scene */
    CurPh.Power[0]= 0;
    CurPh.Power[1]= 100000000;
    CurPh.Power[2]= 0;

    Depth= 0;
    PType= PM_IMPORTANCE;
    rt_shootray(ap);
  }
d692 20
a711 20
  struct	light_specific	*lp;
  vect_t			ldir;
  int				i;

  ldir[0]= 0;
  ldir[1]= 0;
  ldir[2]= -1;
/*
  for (i= 0; i < 8; i++)
    bu_log("sample points: [%.3f,%.3f,%.3f]\n",lp->lt_sample_pts[i].lp_pt[0], lp->lt_sample_pts[i].lp_pt[1], lp->lt_sample_pts[i].lp_pt[2]);
*/
  while (1) {
    for (BU_LIST_FOR(lp, light_specific, &(LightHead.l))) {
      /* If the Global Photon Map Completes before the Caustics Map, then it probably means there are no caustic objects in the Scene */
      if (PMap[PM_GLOBAL]->StoredPhotons == PMap[PM_GLOBAL]->MaxPhotons && (!PMap[PM_CAUSTIC]->StoredPhotons || PMap[PM_CAUSTIC]->StoredPhotons == PMap[PM_CAUSTIC]->MaxPhotons))
	return;

      do {
/*      do {*/
	/* Set Ray Direction to application ptr */
d713 3
a715 3
	ap->a_ray.r_dir[0]= 2.0*rand()/(double)RAND_MAX-1.0;
	ap->a_ray.r_dir[1]= 2.0*rand()/(double)RAND_MAX-1.0;
	ap->a_ray.r_dir[2]= 2.0*rand()/(double)RAND_MAX-1.0;
d717 3
a719 3
	ap->a_ray.r_dir[0]= 2.0*drand48()-1.0;
	ap->a_ray.r_dir[1]= 2.0*drand48()-1.0;
	ap->a_ray.r_dir[2]= 2.0*drand48()-1.0;
d721 24
a744 24
      } while (ap->a_ray.r_dir[0]*ap->a_ray.r_dir[0] + ap->a_ray.r_dir[1]*ap->a_ray.r_dir[1] + ap->a_ray.r_dir[2]*ap->a_ray.r_dir[2] > 1);
      /* Normalize Ray Direction */
      VUNITIZE(ap->a_ray.r_dir);
/*    } while (drand48() > VDOT(ap->a_ray.r_dir,ldir));*/ /* we want this to terminate when a rnd# is less than the angle */

      /* Set Ray Position to application ptr */
      ap->a_ray.r_pt[0]= lp->lt_pos[0];
      ap->a_ray.r_pt[1]= lp->lt_pos[1];
      ap->a_ray.r_pt[2]= lp->lt_pos[2];


      /* Shoot Photon into Scene, (4.0) is used to align phong's attenuation with photonic energies, it's a heuristic */
/*bu_log("Shooting Ray: [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",lp->lt_pos[0], lp->lt_pos[1], lp->lt_pos[2], x,y,z);*/
      CurPh.Power[0]= 1000.0 * ScaleIndirect * lp->lt_intensity * lp->lt_color[0];
      CurPh.Power[1]= 1000.0 * ScaleIndirect * lp->lt_intensity * lp->lt_color[1];
      CurPh.Power[2]= 1000.0 * ScaleIndirect * lp->lt_intensity * lp->lt_color[2];

      Depth= 0;
      PType= PM_GLOBAL;

      EPL++;
      for (i= 0; i < PM_MAPS; i++)
	if (PMap[i]->StoredPhotons < PMap[i]->MaxPhotons)
	  EPS[i]++;
d746 3
a748 2
      rt_shootray(ap);
/*    bu_log("1: %d, 2: %d\n",PMap[PM_GLOBAL]->StoredPhotons, PMap[PM_CAUSTIC]->StoredPhotons);*/
a749 1
  }
d754 2
a755 2
  if (!Root)
    return;
d757 3
a759 3
  bu_log("Pos[%d]: [%.3f,%.3f,%.3f]\n",LR,Root->P.Pos[0], Root->P.Pos[1], Root->P.Pos[2]);
  SanityCheck(Root->L,1);
  SanityCheck(Root->R,2);
d764 7
a770 19
  struct	partition	*part;
  point_t			pt,normal;
  vect_t			C1,C2;

  part= PartHeadp->pt_forw;

  VJOIN1(pt, ap->a_ray.r_pt, part->pt_inhit->hit_dist, ap->a_ray.r_dir);

  RT_HIT_NORMAL(normal, part->pt_inhit, part->pt_inseg->seg_stp, &(ap->a_ray), part->pt_inflip);
/*  GetEstimate(C1, pt, normal, ScaleFactor/10.0, PMap[PM_GLOBAL]->StoredPhotons / 100, PM_GLOBAL, 5, 1);*/
/*  GetEstimate(C1, pt, normal, ScaleFactor/1000.0, 10.0*log(PMap[PM_GLOBAL]->StoredPhotons), PM_GLOBAL, ScaleFactor/5.0, 1);*/
  GetEstimate(C1, pt, normal, ScaleFactor/1024.0, 128, PM_GLOBAL, ScaleFactor/8.0, 1, 15);
/*  GetEstimate(C2 ,pt, normal, (int)(ScaleFactor/pow(2,(log(PMap[PM_CAUSTIC]->MaxPhotons/2)/log(4)))), PMap[PM_CAUSTIC]->MaxPhotons / 50,PM_CAUSTIC, 0, 0);*/
  GetEstimate(C2 ,pt, normal, ScaleFactor/1024.0, PMap[PM_CAUSTIC]->MaxPhotons / 100,PM_CAUSTIC, ScaleFactor/256.0, 1, 15);
/*    GetEstimate(IMColor2, pt, normal, (int)(ScaleFactor/100.0),PMap[PM_CAUSTIC]->MaxPhotons/50,PM_CAUSTIC,1, 0);*/

  (*(vect_t*)ap->a_purpose)[0]+= C1[0] + C2[0];
  (*(vect_t*)ap->a_purpose)[1]+= C1[1] + C2[1];
  (*(vect_t*)ap->a_purpose)[2]+= C1[2] + C2[2];
d772 13
a784 1
  return(1);
d789 2
a790 2
  /* Set to Background/Ambient Color later */
  return(0);
d800 2
a801 2
  int		i;
  vect_t	BasisX,BasisY;
d804 5
a808 5
  BasisX[0]= fabs(Normal[0]) < 0.001 ? 1.0 : fabs(Normal[0]) > 0.999 ? 0.0 : -(1.0/Normal[0]);
  BasisX[1]= fabs(Normal[1]) < 0.001 ? 1.0 : fabs(Normal[1]) > 0.999 ? 0.0 :  (1.0/Normal[1]);
  BasisX[2]= 0.0;
  VUNITIZE(BasisX);
  VCROSS(BasisY,Normal,BasisX);
d810 2
a811 2
  for (i= 0; i < 3; i++)
    Dir[i]= sin(Theta)*cos(Phi)*BasisX[i] + sin(Theta)*sin(Phi)*BasisY[i] + cos(Theta)*Normal[i];
d819 16
a834 16
  struct	application	*lap;		/* local application instance */
  int		i,j,M,N;
  double	theta,phi,Coef;


  lap= (struct application*)malloc(sizeof(struct application));
  RT_APPLICATION_INIT(lap);
  lap->a_rt_i= ap->a_rt_i;
  lap->a_hit= ap->a_hit;
  lap->a_miss= ap->a_miss;
  lap->a_resource= &GPM_RTAB[pid];

  M= N= GPM_RAYS;
  P->Irrad[0]= P->Irrad[1]= P->Irrad[2]= 0.0;
  for (i= 1; i <= M; i++) {
    for (j= 1; j <= N; j++) {
d836 2
a837 2
      theta= asin(sqrt((j-rand()/(double)RAND_MAX)/M));
      phi= (2*M_PI)*((i-rand()/(double)RAND_MAX)/N);
d839 2
a840 2
      theta= asin(sqrt((j-drand48())/M));
      phi= (2*M_PI)*((i-drand48())/N);
d843 4
a846 4
      /* Assign pt */
      lap->a_ray.r_pt[0]= P->Pos[0];
      lap->a_ray.r_pt[1]= P->Pos[1];
      lap->a_ray.r_pt[2]= P->Pos[2];
d848 2
a849 2
      /* Assign Dir */
      Polar2Euclidian(lap->a_ray.r_dir,P->Normal,theta,phi);
d851 2
a852 2
      /* Utilize the purpose pointer as a pointer to the Irradiance Color */
      lap->a_purpose= (void*)P->Irrad;
d854 2
a855 2
/*      bu_log("Vec: [%.3f,%.3f,%.3f]\n",ap->a_ray.r_dir[0],ap->a_ray.r_dir[1],ap->a_ray.r_dir[2]);*/
      rt_shootray(lap);
d857 2
a858 1
/*      bu_log("[%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",P.Pos[0],P.Pos[1],P.Pos[2],P.Normal[0],P.Normal[1],P.Normal[2],IMColor[0],IMColor[1],IMColor[2]);*/
a859 1
  }
d861 4
a864 4
  Coef= 1.0/((double)(M*N));
  P->Irrad[0]*= Coef;
  P->Irrad[1]*= Coef;
  P->Irrad[2]*= Coef;
d866 1
a866 1
  free(lap);
d876 2
a877 2
  if (!Node)
    return;
d880 13
a892 13
  /* Determine if this pt will be used by calculating a weight */
  bu_semaphore_acquire(PM_SEM);
  if (!Node->C) {
    ICSize++;
    Node->C++;
/*    bu_log("cp:A:%d\n",Node->C);*/
    if (!(ICSize%(PMap[PM_GLOBAL]->MaxPhotons/8)))
      bu_log("    Irradiance Cache Progress: %d%%\n",(int)(0.5+100.0*ICSize/PMap[PM_GLOBAL]->MaxPhotons));
    bu_semaphore_release(PM_SEM);
    Irradiance(pid, &Node->P, ap);
  } else {
    bu_semaphore_release(PM_SEM);
  }
d895 2
a896 2
  BuildIrradianceCache(pid, Node->L, ap);
  BuildIrradianceCache(pid, Node->R, ap);
d901 1
a901 1
  BuildIrradianceCache(pid, PMap[PM_GLOBAL]->Root, (struct application*)arg);
d906 5
a910 5
  PMap[MAP]= (struct PhotonMap*)malloc(sizeof(struct PhotonMap));
  PMap[MAP]->MaxPhotons= MapSize;
  PMap[MAP]->Root= (struct PNode*)malloc(sizeof(struct PNode));
  PMap[MAP]->StoredPhotons= 0;
  Emit[MAP]= (struct Photon*)malloc(sizeof(struct Photon)*MapSize);
d915 45
a959 45
  FILE		*FH;
  int		I1,i;
  short		S1;
  char		C1;


  FH= fopen(pmfile,"rb");
  if (FH) {
    bu_log("  Reading Irradiance Cache File...\n");
    fread(&S1, sizeof(short), 1, FH);
    bu_log("endian: %d\n",S1);

    fread(&S1, sizeof(short), 1, FH);
    bu_log("revision: %d\n",S1);

    fread(&ScaleFactor, sizeof(double),1,FH);
    bu_log("Scale Factor: %.3f\n",ScaleFactor);

    /* Read in Map Type */
    fread(&C1, sizeof(char), 1, FH);
    fread(&I1, sizeof(int), 1, FH);
    Initialize(PM_GLOBAL, I1);
    bu_log("Reading Global: %d\n",I1);
    for (i= 0; i < I1; i++) {
      fread(&Emit[PM_GLOBAL][i],sizeof(struct Photon),1,FH);
/*      bu_log("Pos: [%.3f,%.3f,%.3f], Power: [%.3f,%.3f,%.3f]\n",Emit[PM_GLOBAL][i].Pos[0],Emit[PM_GLOBAL][i].Pos[1],Emit[PM_GLOBAL][i].Pos[2],Emit[PM_GLOBAL][i].Power[0],Emit[PM_GLOBAL][i].Power[1],Emit[PM_GLOBAL][i].Power[2]);*/
/*      bu_log("Pos: [%.3f,%.3f,%.3f], Irrad: [%.3f,%.3f,%.3f]\n",Emit[PM_GLOBAL][i].Pos[0],Emit[PM_GLOBAL][i].Pos[1],Emit[PM_GLOBAL][i].Pos[2],Emit[PM_GLOBAL][i].Irrad[0],Emit[PM_GLOBAL][i].Irrad[1],Emit[PM_GLOBAL][i].Irrad[2]);*/
    }

    fread(&C1, sizeof(char), 1, FH);
    fread(&I1, sizeof(int), 1, FH);
    Initialize(PM_CAUSTIC, I1);
    bu_log("Reading Caustic: %d\n",I1);
    for (i= 0; i < I1; i++) {
      fread(&Emit[PM_CAUSTIC][i],sizeof(struct Photon),1,FH);
    }

    PMap[PM_GLOBAL]->StoredPhotons= PMap[PM_GLOBAL]->MaxPhotons;
    BuildTree(Emit[PM_GLOBAL], PMap[PM_GLOBAL]->StoredPhotons, PMap[PM_GLOBAL]->Root);

    PMap[PM_CAUSTIC]->StoredPhotons= PMap[PM_CAUSTIC]->MaxPhotons;
    BuildTree(Emit[PM_CAUSTIC], PMap[PM_CAUSTIC]->StoredPhotons, PMap[PM_CAUSTIC]->Root);
    fclose(FH);
    return(1);
  }
d961 1
a961 1
  return(0);
d966 2
a967 2
  if (!Root)
    return;
d969 3
a971 3
  fwrite(&Root->P,sizeof(struct Photon),1,FH);
  WritePhotons(Root->L,FH);
  WritePhotons(Root->R,FH);
d976 37
a1012 37
  FILE		*FH;
  int		I1;
  short		S1;
  char		C1;


  FH= fopen(pmfile,"wb");
  if (FH) {
    /* Write 2 Byte Endian Code and 2 Byte Revision Code */
    S1= 1;
    fwrite(&S1,sizeof(short),1,FH);
    S1= 0;
    fwrite(&S1,sizeof(short),1,FH);

    /* Write Scale Factor */
    bu_log("writing sf: %.3f\n",ScaleFactor);
    fwrite(&ScaleFactor,sizeof(double),1,FH);

    /* === Write PM_GLOBAL Data === */
    C1= PM_GLOBAL;
    fwrite(&C1,sizeof(char),1,FH);
    /* Write number of Photons */
    I1= PMap[PM_GLOBAL]->StoredPhotons;
    fwrite(&I1,sizeof(int),1,FH);
    /* Write each photon to file */
    if (PMap[PM_GLOBAL]->StoredPhotons)
      WritePhotons(PMap[PM_GLOBAL]->Root,FH);

    /* === Write PM_CAUSTIC Data === */
    C1= PM_CAUSTIC;
    fwrite(&C1,sizeof(char),1,FH);
    /* Write number of Photons */
    I1= PMap[PM_CAUSTIC]->StoredPhotons;
    fwrite(&I1,sizeof(int),1,FH);
    /* Write each photon to file */
    if (PMap[PM_CAUSTIC]->StoredPhotons)
      WritePhotons(PMap[PM_CAUSTIC]->Root,FH);
d1014 2
a1015 2
    fclose(FH);
  }
d1023 2
a1024 2
  int				i,MapSize[PM_MAPS];
  double			ratio;
d1026 13
a1038 13
  PM_Visualize= VisualizeIrradiance;
  GPM_IH= IrradianceHypersampling;
  GPM_WIDTH= width;
  GPM_HEIGHT= height;

  /* If the user has specified a cache file then first check to see if there is any valid data within it,
     otherwise utilize the file to push the resulting irradiance cache data into for future use. */
  if (!LoadFile(pmfile)) {
/*
    bu_log("pos: [%.3f,%.3f,%.3f]\n",eye_pos[0],eye_pos[1],eye_pos[2]);
    bu_log("I,V,Imp,H: %.3f,%d,%d,%d\n",LightIntensity,VisualizeIrradiance,ImportanceMapping,IrradianceHypersampling);
*/
    bu_log("Building Photon Map:\n");
d1041 2
a1042 2
    GPM_RAYS= Rays;
    GPM_ATOL= cos(AngularTolerance*bn_degtorad);
d1044 1
a1044 1
    PInit= 1;
d1047 1
a1047 1
    srand(RandomSeed);
d1049 1
a1049 1
    srand48(RandomSeed);
d1051 1
a1051 1
/*  bu_log("Photon Structure Size: %d\n",sizeof(struct PNode));*/
d1053 31
a1083 4
/*
    bu_log("Checking application struct\n");
    RT_CK_APPLICATION(ap);
*/
a1084 26
    /* Initialize Emitted Photons for each map to 0 */
    EPL= 0;
    for (i= 0; i < PM_MAPS; i++)
      EPS[i]= 0;

    CausticsPercent/= 100.0;
    MapSize[PM_IMPORTANCE]= GlobalPhotons/8;
    MapSize[PM_GLOBAL]= (int)((1.0-CausticsPercent)*GlobalPhotons);
    MapSize[PM_CAUSTIC]= (int)(CausticsPercent*GlobalPhotons);
    MapSize[PM_SHADOW]= 0;

/*  bu_log("Caustic Photons: %d\n",MapSize[PM_CAUSTIC]);*/
    /* Allocate Memory for Photon Maps */
    Initialize(PM_GLOBAL,MapSize[PM_GLOBAL]);
    Initialize(PM_CAUSTIC,MapSize[PM_CAUSTIC]);
    Initialize(PM_SHADOW,MapSize[PM_SHADOW]);
    Initialize(PM_IMPORTANCE,MapSize[PM_IMPORTANCE]);

    /* Populate Application Structure */
    /* Set Recursion Level, Magic Number, Hit/Miss Callbacks, and Purpose */
    ap->a_level= 1;
    ap->a_onehit= 0;
    ap->a_ray.magic= RT_RAY_MAGIC;
    ap->a_hit= PHit;
    ap->a_miss= PMiss;
    ap->a_purpose= "Importance Mapping";
d1086 6
d1093 55
a1147 25
    if (ImportanceMapping) {
      bu_log("  Building Importance Map...\n");
      EmitImportonsRandom(ap,eye_pos);
      BuildTree(Emit[PM_IMPORTANCE],PMap[PM_IMPORTANCE]->StoredPhotons,PMap[PM_IMPORTANCE]->Root);
      ScaleFactor= MaxFloat(BBMax[0]-BBMin[0],BBMax[1]-BBMin[1],BBMax[2]-BBMin[2]);
    }

    HitG= HitB= 0;
    bu_log("  Emitting Photons...\n");
    EmitPhotonsRandom(ap, ScaleIndirect);
/*      EmitPhotonsRandom(ap, &(LightHead.l), LightIntensity);*/

    /* Generate Scale Factor */
    ScaleFactor= MaxFloat(BBMax[0]-BBMin[0],BBMax[1]-BBMin[1],BBMax[2]-BBMin[2]);

bu_log("HitGB: %d,%d\n",HitG,HitB);
bu_log("Scale Factor: %.3f\n",ScaleFactor);
    ratio= (double)HitG/((double)(HitG+HitB));
bu_log("EPL: %d, Adjusted EPL: %d\n",(int)EPL,(int)(EPL*ratio));
    EPS[PM_GLOBAL]*= ratio;
    EPS[PM_CAUSTIC]*= ratio;

    /* Scale Photon Power */
    ScalePhotonPower(PM_GLOBAL);
    ScalePhotonPower(PM_CAUSTIC);
d1149 12
a1160 4
/*
    for (i= 0; i < PMap->StoredPhotons; i++)
      bu_log("insertLS[%d]: %.3f,%.3f,%.3f\n",i,Emit[i].Pos[0],Emit[i].Pos[1],Emit[i].Pos[2]);
*/
d1163 4
a1166 5
    bu_log("  Building KD-Tree...\n");
    /* Balance KD-Tree */
    for (i= 0; i < 3; i++)
      if (PMap[i]->StoredPhotons)
	BuildTree(Emit[i],PMap[i]->StoredPhotons,PMap[i]->Root);
d1168 1
d1170 2
a1171 23
    bu_semaphore_init(PM_SEM_INIT);
    bu_log("  Building Irradiance Cache...\n");
    ap->a_level= 1;
    ap->a_onehit= 0;
    ap->a_ray.magic= RT_RAY_MAGIC;
    ap->a_hit= ICHit;
    ap->a_miss= ICMiss;
    ICSize= 0;

    if (cpus > 1) {
      GPM_RTAB= (struct resource*)malloc(sizeof(struct resource)*cpus);
      bzero(GPM_RTAB,cpus*sizeof(struct resource));
      for (i= 0; i < cpus; i++) {
	GPM_RTAB[i].re_cpu= i;
	GPM_RTAB[i].re_magic= RESOURCE_MAGIC;
	BU_PTBL_SET(&ap->a_rt_i->rti_resources, i, &GPM_RTAB[i]);
	rt_init_resource(&GPM_RTAB[i], GPM_RTAB[i].re_cpu, ap->a_rt_i);
      }
      bu_parallel(IrradianceThread, cpus, ap);
    } else {
      /* This will allow profiling for single threaded rendering */
      IrradianceThread(0,ap);
    }
a1172 11
    /* Allocate Memory for Irradiance Cache and Initialize Pixel Map */
/*    bu_log("Image Size: %d,%d\n",width,height);*/
    if (GPM_IH) {
      Map= (char*)malloc(sizeof(char)*width*height);
      for (i= 0; i < width*height; i++)
	Map[i]= 0;
      IC= (struct IrradCache*)malloc(sizeof(struct IrradCache)*width*height);
      for (i= 0; i < width*height; i++) {
	IC[i].List= (struct IrradNode*)malloc(sizeof(struct IrradNode));
	IC[i].Num= 0;
      }
d1174 1
a1174 14


/*
    bu_log("  Sanity Check...\n");
    SanityCheck(PMap[PM_GLOBAL]->Root,0);
*/

    WritePhotonFile(pmfile);

    for (i= 0; i < PM_MAPS; i++)
      free(Emit[i]);

  }
  free(GPM_RTAB);
d1179 1
a1179 1
  struct	PSN	c;
d1181 13
a1193 13
/*
  c.P= a->P;
  c.Dist= a->Dist;
  a->P= b->P;
  a->Dist= b->Dist;
  b->P= c.P;
  b->Dist= c.Dist;
*/
/*  bu_log("  SWAP_IN: %.3f,%.3f\n",a->Dist, b->Dist);*/
  memcpy(&c,a,sizeof(struct PSN));
  memcpy(a,b,sizeof(struct PSN));
  memcpy(b,&c,sizeof(struct PSN));
/*  bu_log("  SWAP_OT: %.3f,%.3f\n",a->Dist, b->Dist);*/
d1198 2
a1199 2
After inserting a new node it must be brought upwards until both children
are less than it.
d1202 1
a1202 1
  int	i;
d1204 2
a1205 2
  if (!ind)
    return;
d1207 8
a1214 8
  i= ((ind+1)-(ind+1)%2)/2-1;
/*  bu_log("  CHECK: %.3f > %.3f :: [%d] > [%d]\n",S->List[ind].Dist,S->List[i].Dist,ind,i);*/
  if (S->List[ind].Dist > S->List[i].Dist) {
/*    bu_log("SWAP_A: %.3f,%.3f\n",S->List[i].Dist, S->List[ind].Dist);*/
    Swap(&S->List[i],&S->List[ind]);
/*    bu_log("SWAP_B: %.3f,%.3f\n",S->List[i].Dist, S->List[ind].Dist);*/
  }
  HeapUp(S,i);
d1219 3
a1221 3
Sift the new Root node down, by choosing the child with the highest number
since choosing a child with the highest number may reduce the number of
recursions the number will have to propogate
d1224 1
a1224 1
  int		c;
d1226 2
a1227 2
  if (2*ind+1 > S->Found)
    return;
d1229 2
a1230 2
  c= 2*ind+1 < S->Found ? S->List[2*ind+2].Dist > S->List[2*ind+1].Dist ? 2*ind+2 : 2*ind+1 : 2*ind+1;
/*  bu_log(" c: %d\n",c);*/
d1232 6
a1237 6
  if (S->List[c].Dist > S->List[ind].Dist) {
/*    bu_log("SWAP_C: %.3f,%.3f :: %d,%d :: %d\n",S->List[c].Dist, S->List[ind].Dist,c,ind,S->Found);*/
    Swap(&S->List[c],&S->List[ind]);
/*    bu_log("SWAP_D: %.3f,%.3f :: %d,%d :: %d\n",S->List[c].Dist, S->List[ind].Dist,c,ind,S->Found);*/
  }
  HeapDown(S,c);
d1242 6
a1247 6
  S->List[S->Found]= P;
  HeapUp(S,S->Found++);
/*
  for (i= 0; i < S->Found; i++)
    bu_log("Push[%d]: %.3f :: %d,%d\n",i,S->List[i].Dist,S->Found, S->Max);
*/
d1252 7
a1258 7
  S->Found--;
  S->List[0]= S->List[S->Found];
  HeapDown(S,0);
/*
  for (i= 0; i < S->Found; i++)
    bu_log("Pop [%d]: %.3f :: %d,%d\n",i,S->List[i].Dist,S->Found,S->Max);
*/
d1263 2
a1264 2
  fastf_t		Dist,TDist,angle,MDist;
  int			i,MaxInd,Axis;
d1266 2
a1267 2
  if (!Root)
    return;
d1269 2
a1270 2
  Axis= Root->P.Axis;
  Dist= Search->Pos[Axis] - Root->P.Pos[Axis];
d1272 11
a1282 11
  if (Dist < 0) {
    /* Left of plane - search left subtree first */
    LocatePhotons(Search,Root->L);
    if (Dist*Dist < Search->RadSq)
      LocatePhotons(Search,Root->R);
  } else {
    /* Right of plane - search right subtree first */
    LocatePhotons(Search,Root->R);
    if (Dist*Dist < Search->RadSq)
      LocatePhotons(Search,Root->L);
  }
d1285 13
a1297 12
  /* HEAP, Find Distance between Root Photon and Search->Pos */
  angle= VDOT(Search->Normal, Root->P.Normal);
  Node.P= Root->P;
  Node.Dist= (Root->P.Pos[0] - Search->Pos[0])*(Root->P.Pos[0] - Search->Pos[0]) + (Root->P.Pos[1] - Search->Pos[1])*(Root->P.Pos[1] - Search->Pos[1]) + (Root->P.Pos[2] - Search->Pos[2])*(Root->P.Pos[2] - Search->Pos[2]);
  if (Node.Dist < Search->RadSq && angle > GPM_ATOL) { /* Check that Result is within Radius and Angular Tolerance */
    if (Search->Found < Search->Max) {
      Push(Search, Node);
    } else {
      if (Node.Dist < Search->List[0].Dist) {
	Pop(Search);
	Push(Search, Node);
      }
a1298 1
  }
d1302 2
a1303 2
  /* REPLACE, Find Distance between Root Photon and NP->Pos */
  Dist= (Root->P.Pos[0] - Search->Pos[0])*(Root->P.Pos[0] - Search->Pos[0]) + (Root->P.Pos[1] - Search->Pos[1])*(Root->P.Pos[1] - Search->Pos[1]) + (Root->P.Pos[2] - Search->Pos[2])*(Root->P.Pos[2] - Search->Pos[2]);
d1305 18
a1322 13
  angle= VDOT(Search->Normal, Root->P.Normal);
  if (Dist < Search->RadSq && angle > GPM_ATOL) { /* Check that Result is within Radius and Angular Tolerance */
/*  if (Dist < NP->RadSq) {*/
    if (Search->Found < Search->Max) {
      Search->List[Search->Found++].P= Root->P;
    } else {
      MDist= (Search->Pos[0] - Search->List[0].P.Pos[0])*(Search->Pos[0] - Search->List[0].P.Pos[0])+(Search->Pos[1] - Search->List[0].P.Pos[1])*(Search->Pos[1] - Search->List[0].P.Pos[1])+(Search->Pos[2] - Search->List[0].P.Pos[2])*(Search->Pos[2] - Search->List[0].P.Pos[2]);
      MaxInd= 0;
      for (i= 1; i < Search->Found; i++) {
	TDist= (Search->Pos[0] - Search->List[i].P.Pos[0])*(Search->Pos[0] - Search->List[i].P.Pos[0])+(Search->Pos[1] - Search->List[i].P.Pos[1])*(Search->Pos[1] - Search->List[i].P.Pos[1])+(Search->Pos[2] - Search->List[i].P.Pos[2])*(Search->Pos[2] - Search->List[i].P.Pos[2]);
	if (TDist > MDist) {
	  MDist= TDist;
	  MaxInd= i;
a1323 4
      }

      if (Dist < MDist)
	Search->List[MaxInd].P= Root->P;
a1324 1
  }
d1330 1
a1330 1
  return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]);
d1335 1
a1335 1
  return( 0.918 * (1.0 - (1.0 - exp(-1.953*dist*dist/(2.0*rad*rad)))/(1.0 - exp(-1.953))) );
d1340 1
a1340 1
  return( 1.0 - dist/rad );
d1345 24
a1368 18
  struct	PhotonSearch	Search;
  int				i,index;
  fastf_t			dist,TotDist;
  vect_t			t,cirrad;


  index= 0;
  if (GPM_IH) {
    index= ap->a_x + ap->a_y*GPM_WIDTH;
    /* See if there is a cached irradiance calculation for this point */
    for (i= 0; i < IC[index].Num; i++) {
      dist= (pos[0]-IC[index].List[i].Pos[0])*(pos[0]-IC[index].List[i].Pos[0])+(pos[1]-IC[index].List[i].Pos[1])*(pos[1]-IC[index].List[i].Pos[1])+(pos[2]-IC[index].List[i].Pos[2])*(pos[2]-IC[index].List[i].Pos[2]);
      if (dist < (ScaleFactor/100.0)*(ScaleFactor*100.0)) {
	irrad[0]= IC[index].List[i].RGB[0];
	irrad[1]= IC[index].List[i].RGB[1];
	irrad[2]= IC[index].List[i].RGB[2];
	return;
      }
d1371 23
a1393 13
    /* There is no precomputed irradiance for this point, allocate space
       for a new one if neccessary. */
    if (IC[index].Num)
      IC[index].List= (struct IrradNode*)realloc(IC[index].List,sizeof(struct IrradNode)*(IC[index].Num+1));
  }

  Search.Pos[0]= pos[0];
  Search.Pos[1]= pos[1];
  Search.Pos[2]= pos[2];

/*  NP.RadSq= (ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL]->MaxPhotons/2)/log(4))))) * (ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL]->MaxPhotons/2)/log(4)))));*/
/*  bu_log("SF: %.3f\n",(ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL]->MaxPhotons/2)/log(4))))));*/
/*  bu_log("SF: %.3f\n",ScaleFactor/pow(PMap[PM_GLOBAL]->MaxPhotons,0.5));*/
d1395 6
a1400 4
/*
  Search.RadSq= 0.5*ScaleFactor/pow(PMap[PM_GLOBAL]->MaxPhotons,0.5) * ScaleFactor/pow(PMap[PM_GLOBAL]->MaxPhotons,0.5);
  Search.Max= pow(PMap[PM_GLOBAL]->StoredPhotons, 0.5);
*/
a1401 33
  Search.RadSq= (ScaleFactor/2048.0);
  Search.RadSq*= Search.RadSq;
/*  NP.RadSq= (4.0*ScaleFactor/PMap[PM_GLOBAL]->MaxPhotons) * (4.0*ScaleFactor/PMap[PM_GLOBAL]->MaxPhotons);*/
/*  NP.Max= 2.0*pow(PMap[PM_GLOBAL]->StoredPhotons, 0.5);*/
/*  Search.Max= PMap[PM_GLOBAL]->StoredPhotons / 50;*/
  Search.Max= 32;

  Search.Normal[0]= normal[0];
  Search.Normal[1]= normal[1];
  Search.Normal[2]= normal[2];

  Search.List= (struct PSN*)malloc(sizeof(struct PSN)*Search.Max);
  do {
    Search.Found= 0;
    Search.RadSq*= 4.0;
    LocatePhotons(&Search,PMap[PM_GLOBAL]->Root);
  } while(Search.Found < Search.Max && Search.RadSq < ScaleFactor * ScaleFactor / 64.0);


  irrad[0]= irrad[1]= irrad[2]= 0;
  TotDist= 0;
  for (i= 0; i < Search.Found; i++) {
    t[0]= Search.List[i].P.Pos[0] - pos[0];
    t[1]= Search.List[i].P.Pos[1] - pos[1];
    t[2]= Search.List[i].P.Pos[2] - pos[2];
    TotDist+= t[0]*t[0] + t[1]*t[1] + t[2]*t[2];
  }


  for (i= 0; i < Search.Found; i++) {
    t[0]= Search.List[i].P.Pos[0] - pos[0];
    t[1]= Search.List[i].P.Pos[1] - pos[1];
    t[2]= Search.List[i].P.Pos[2] - pos[2];
d1403 8
a1410 24
    t[0]= (t[0]*t[0] + t[1]*t[1] + t[2]*t[2])/TotDist;
/*
    irrad[0]+= Search.List[i].P.Irrad[0] * t[0];
    irrad[1]+= Search.List[i].P.Irrad[1] * t[0];
    irrad[2]+= Search.List[i].P.Irrad[2] * t[0];
*/
    irrad[0]+= Search.List[i].P.Irrad[0];
    irrad[1]+= Search.List[i].P.Irrad[1];
    irrad[2]+= Search.List[i].P.Irrad[2];
  }
  if (Search.Found) {
    irrad[0]/= (double)Search.Found;
    irrad[1]/= (double)Search.Found;
    irrad[2]/= (double)Search.Found;
  }
  free(Search.List);

/*  GetEstimate(cirrad, pos, normal, (int)(ScaleFactor/100.0),PMap[PM_CAUSTIC]->MaxPhotons/50,PM_CAUSTIC,1, 0);*/
/*  GetEstimate(cirrad,pos,normal,(int)(ScaleFactor/pow(2,(log(PMap[PM_CAUSTIC]->MaxPhotons/2)/log(4)))),PMap[PM_CAUSTIC]->MaxPhotons / 50,PM_CAUSTIC,0,0);*/
  GetEstimate(cirrad,pos,normal,ScaleFactor/1024.0,PMap[PM_CAUSTIC]->MaxPhotons / 100,PM_CAUSTIC,ScaleFactor/128.0,1,15);

  irrad[0]+= cirrad[0];
  irrad[1]+= cirrad[1];
  irrad[2]+= cirrad[2];
d1413 21
a1433 3
  /* Visualize Green Importons */
/*
  GetEstimate(cirrad,pos,normal,ScaleFactor/512.0,1,PM_IMPORTANCE,ScaleFactor/256.0,1,1);
d1435 17
a1451 4
  irrad[0]+= cirrad[0];
  irrad[1]+= cirrad[1];
  irrad[2]+= cirrad[2];
*/
d1453 9
a1461 9
  if (GPM_IH) {
    /* Store Irradiance */
    IC[index].List[IC[index].Num].RGB[0]= irrad[0];
    IC[index].List[IC[index].Num].RGB[1]= irrad[1];
    IC[index].List[IC[index].Num].RGB[2]= irrad[2];

    IC[index].List[IC[index].Num].Pos[0]= pos[0];
    IC[index].List[IC[index].Num].Pos[1]= pos[1];
    IC[index].List[IC[index].Num].Pos[2]= pos[2];
d1463 2
a1464 2
    IC[index].Num++;
  }
d1469 58
a1526 27
  struct	PhotonSearch	Search;
  int				i;
  fastf_t			tmp,dist,Filter,ScaleFilter;
  vect_t			t,Centroid;


  irrad[0]= irrad[1]= irrad[2]= 0;
  if (!PMap[map]->StoredPhotons) return;

  Search.Pos[0]= pos[0];
  Search.Pos[1]= pos[1];
  Search.Pos[2]= pos[2];

  Search.RadSq= rad*rad/4.0;
  Search.Max= np < min_np ? min_np : np;
  Search.Normal[0]= normal[0];
  Search.Normal[1]= normal[1];
  Search.Normal[2]= normal[2];

  Search.List= (struct PSN*)malloc(sizeof(struct PSN)*Search.Max);
  do {
    Search.Found= 0;
    Search.RadSq*= 4.0;
    LocatePhotons(&Search,PMap[map]->Root);
    if (!Search.Found && Search.RadSq > ScaleFactor*ScaleFactor/100.0)
      break;
  } while(Search.Found < Search.Max && Search.RadSq < max_rad*max_rad);
d1528 28
a1555 5
/*  bu_log("Found: %d\n",Search.Found);*/
  if (Search.Found < min_np) {
    free(Search.List);
    return;
  }
a1556 58
  /* Calculate Max Distance */
  Search.RadSq= 1;
  Centroid[0]= Centroid[1]= Centroid[2]= 0;

  for (i= 0; i < Search.Found; i++) {
    t[0]= Search.List[i].P.Pos[0] - pos[0];
    t[1]= Search.List[i].P.Pos[1] - pos[1];
    t[2]= Search.List[i].P.Pos[2] - pos[2];

    Centroid[0]+= Search.List[i].P.Pos[0];
    Centroid[1]+= Search.List[i].P.Pos[1];
    Centroid[2]+= Search.List[i].P.Pos[2];

    dist= t[0]*t[0] + t[1]*t[1] + t[2]*t[2];
    if (dist > Search.RadSq)
      Search.RadSq= dist;
  }

  if (Search.Found) {
    Centroid[0]/= (double)Search.Found;
    Centroid[1]/= (double)Search.Found;
    Centroid[2]/= (double)Search.Found;
  }


  /* This needs a little debugging, splotches in moss cause tmp gets too small, will look at later, ||1 to turn it off */
  if (!centog||1) {
    Centroid[0]= pos[0];
    Centroid[1]= pos[1];
    Centroid[2]= pos[2];
    ScaleFilter= 2.0;
  } else {
    ScaleFilter= 1.0;
  }

  for (i= 0; i < Search.Found; i++) {
      t[0]= Search.List[i].P.Pos[0] - pos[0];
      t[1]= Search.List[i].P.Pos[1] - pos[1];
      t[2]= Search.List[i].P.Pos[2] - pos[2];

      dist= t[0]*t[0] + t[1]*t[1] + t[2]*t[2];
/*      Filter= 0.50;*/
/*      Filter= ConeFilter(dist,NP.RadSq);*/
      Filter= 0.5*GaussFilter(dist,Search.RadSq);

      irrad[0]+= Search.List[i].P.Power[0]*Filter*ScaleFilter;
      irrad[1]+= Search.List[i].P.Power[1]*Filter*ScaleFilter;
      irrad[2]+= Search.List[i].P.Power[2]*Filter*ScaleFilter;
  }

  tmp= M_PI*Search.RadSq;
  t[0]= sqrt((Centroid[0] - pos[0])*(Centroid[0] - pos[0])+(Centroid[1] - pos[1])*(Centroid[1] - pos[1])+(Centroid[2] - pos[2])*(Centroid[2] - pos[2]));
  tmp= M_PI*(sqrt(Search.RadSq)-t[0])*(sqrt(Search.RadSq)-t[0]);


  irrad[0]/= tmp;
  irrad[1]/= tmp;
  irrad[2]/= tmp;
d1558 15
a1572 11
/*
  if (irrad[0] > 10 || irrad[1] > 10 || irrad[2] > 10) {
    bu_log("found: %d, tmp: %.1f\n",Search.Found,tmp);
  }
*/
  if (map == PM_CAUSTIC) {
    tmp= (double)Search.Found/(double)Search.Max;
    irrad[0]*= tmp;
    irrad[1]*= tmp;
    irrad[2]*= tmp;
  }
d1574 7
a1580 7
/*
  irrad[0]*= (1.0/M_PI)/NP.RadSq;
  irrad[1]*= (1.0/M_PI)/NP.RadSq;
  irrad[2]*= (1.0/M_PI)/NP.RadSq;
*/
  free(Search.List);
/*  bu_log("Radius: %.3f, Max Phot: %d, Found: %d, Power: [%.4f,%.4f,%.4f], Pos: [%.3f,%.3f,%.3f]\n",sqrt(NP.RadSq), NP.Max,NP.Found,irrad[0],irrad[1],irrad[2],pos[0],pos[1],pos[2]);*/
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d149 3
a151 3
  Root -> P= EList[MedianIndex];
  Root -> P.Axis= Axis;
  Root -> C= 0;
d156 4
a159 4
    Root -> L= (struct PNode*)malloc(sizeof(struct PNode));
    Root -> L -> L= 0;
    Root -> L -> R= 0;
    BuildTree(LList,LInd,Root -> L);
d163 4
a166 4
    Root -> R= (struct PNode*)malloc(sizeof(struct PNode));
    Root -> R -> L= 0;
    Root -> R -> R= 0;
    BuildTree(RList,RInd,Root -> R);
d180 1
a180 1
  if (Map != PM_IMPORTANCE && PMap[PM_IMPORTANCE] -> StoredPhotons) {
d194 1
a194 1
    LocatePhotons(&Search,PMap[PM_IMPORTANCE] -> Root);
d205 1
a205 1
      LocatePhotons(&Search,PMap[map] -> Root);
d214 1
a214 1
  if (PMap[Map] -> StoredPhotons < PMap[Map] -> MaxPhotons) {
d218 4
a221 4
      Emit[Map][PMap[Map] -> StoredPhotons].Pos[i]= Pos[i];
      Emit[Map][PMap[Map] -> StoredPhotons].Dir[i]= Dir[i];
      Emit[Map][PMap[Map] -> StoredPhotons].Normal[i]= Normal[i];
      Emit[Map][PMap[Map] -> StoredPhotons].Power[i]= CurPh.Power[i];
d223 1
a223 1
    PMap[Map] -> StoredPhotons++;
d225 2
a226 2
    if (Map != PM_IMPORTANCE && PMap[PM_IMPORTANCE] -> StoredPhotons < PMap[PM_IMPORTANCE] -> MaxPhotons)
      bu_log("Map2: %d, Size: %d\n",Map,PMap[Map] -> StoredPhotons);
d230 1
a230 1
    bu_log("Map: %d, Size: %d, [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",Map,PMap[Map] -> StoredPhotons, Pos[0],Pos[1],Pos[2], CurPh.Power[0], CurPh.Power[1], CurPh.Power[2]);
d235 3
a237 3
  bu_log("[%d][%d][%.3f,%.3f,%.3f]\n",Map,PMap[Map] -> StoredPhotons,CurPh.Power[0],CurPh.Power[1],CurPh.Power[2]);
  if (!(PMap[Map] -> StoredPhotons % 64))
  bu_log("[%d][%d][%.3f,%.3f,%.3f]\n",Map,PMap[Map] -> StoredPhotons,Pos[0],Pos[1],Pos[2]);
d324 8
a331 8
    phong_sp -> magic= PL_MAGIC;
    phong_sp -> shine= 10;
    phong_sp -> wgt_specular= 0.7;
    phong_sp -> wgt_diffuse= 0.3;
    phong_sp -> transmit= 0.0;
    phong_sp -> reflect= 0.0;
    phong_sp -> refrac_index= 1.0;
    phong_sp -> extinction= 0.0;
d343 2
a344 2
/*    bu_log("info[%d]: sh: %d, spec: %.3f, diff: %.3f, tran: %.3f, refl: %.3f, refr: %.3f\n", PMap -> StoredPhotons, phong_sp -> shine, phong_sp -> wgt_specular, phong_sp -> wgt_diffuse, phong_sp -> transmit, phong_sp -> reflect, phong_sp -> refrac_index);*/
/*    bu_log("spec[%d]: %.3f\n",PMap -> StoredPhotons, phong_sp -> wgt_specular);*/
d346 2
a347 2
    spec[0]= spec[1]= spec[2]= phong_sp -> wgt_specular;
    *refi= phong_sp -> refrac_index;
d354 2
a355 2
    if (phong_sp -> refrac_index != 1.0)
    bu_log("refi: %.3f\n",phong_sp -> refrac_index);
d359 8
a366 8
    phong_sp -> magic= PL_MAGIC;
    phong_sp -> shine= 4;
    phong_sp -> wgt_specular= 0.7;
    phong_sp -> wgt_diffuse= 0.3;
    phong_sp -> transmit= 0.8;
    phong_sp -> reflect= 0.1;
    phong_sp -> refrac_index= 1.65;
    phong_sp -> extinction= 0.0;
d379 2
a380 2
/*    bu_log("info[%d]: sh: %d, spec: %.3f, diff: %.3f, tran: %.3f, refl: %.3f, refr: %.3f\n", PMap -> StoredPhotons, phong_sp -> shine, phong_sp -> wgt_specular, phong_sp -> wgt_diffuse, phong_sp -> transmit, phong_sp -> reflect, phong_sp -> refrac_index);*/
/*    bu_log("spec[%d]: %.3f\n",PMap -> StoredPhotons, phong_sp -> wgt_specular);*/
d382 3
a384 3
    spec[0]= spec[1]= spec[2]= phong_sp -> wgt_specular;
    *refi= phong_sp -> refrac_index;
    *transmit= phong_sp -> transmit;
d387 2
a388 2
    if (phong_sp -> refrac_index != 1.0)
    bu_log("refi: %.3f\n",phong_sp -> refrac_index);
d406 2
a407 2
  ap -> a_hit= PHit;
  part= PartHeadp -> pt_forw;
d410 1
a410 1
  VJOIN1(pt, ap -> a_ray.r_pt, part -> pt_outhit -> hit_dist, ap -> a_ray.r_dir);
d413 3
a415 3
  RT_HIT_NORMAL(normal, part -> pt_inhit, part -> pt_inseg -> seg_stp, &(ap->a_ray), part -> pt_inflip);
/*  RT_HIT_NORMAL(normal, part -> pt_outhit, part -> pt_inseg -> seg_stp, &(ap->a_ray), part -> pt_inflip);*/
/*  RT_HIT_NORMAL(normal, part -> pt_outhit, part -> pt_outseg -> seg_stp, &(ap->a_ray), part -> pt_outflip);*/
d418 3
a420 3
  ap -> a_ray.r_pt[0]= pt[0];
  ap -> a_ray.r_pt[1]= pt[1];
  ap -> a_ray.r_pt[2]= pt[2];
d424 1
a424 1
  GetMaterial(part -> pt_regionp -> reg_mater.ma_shader, spec, &refi, &transmit);
d427 1
a427 1
  if (Refract(ap -> a_ray.r_dir,normal,refi,1.0)) {
d429 3
a431 3
    bu_log("1D: %d, [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f]\n",Depth,pt[0],pt[1],pt[2],ap -> a_ray.r_dir[0], ap -> a_ray.r_dir[1], ap -> a_ray.r_dir[2],normal[0],normal[1],normal[2]);
    bu_log("p1: [%.3f,%.3f,%.3f]\n",part -> pt_inhit -> hit_point[0], part -> pt_inhit -> hit_point[1], part -> pt_inhit -> hit_point[2]);
    bu_log("p2: [%.3f,%.3f,%.3f]\n",part -> pt_outhit -> hit_point[0], part -> pt_outhit -> hit_point[1], part -> pt_outhit -> hit_point[2]);
d439 1
a439 1
  ap -> a_onehit= 0;
d444 1
a444 1
/* Callback for Photon Hit, The 'current' photon is Emit[PMap -> StoredPhotons] */
d458 2
a459 2
    VJOIN1(pt, ap -> a_ray.r_pt, part -> pt_inhit -> hit_dist, ap -> a_ray.r_dir);
/*    printf("pt[%d][%d]: --- [%.3f,%.3f,%.3f], %s\n",hit,CheckMaterial("light",part -> pt_regionp -> reg_mater.ma_shader),pt[0],pt[1],pt[2],part -> pt_regionp -> reg_mater.ma_shader);*/
d461 1
a461 1
      if (!CheckMaterial("light",part -> pt_regionp -> reg_mater.ma_shader)) {
d472 1
a472 1
  if (CheckMaterial("light",part -> pt_regionp -> reg_mater.ma_shader))
d477 1
a477 1
  VJOIN1(pt, ap -> a_ray.r_pt, part -> pt_inhit -> hit_dist, ap -> a_ray.r_dir);
d502 1
a502 1
  RT_HIT_NORMAL(normal, part -> pt_inhit, part -> pt_inseg -> seg_stp, &(ap->a_ray), part -> pt_inflip);
d505 1
a505 1
  GetMaterial(part -> pt_regionp -> reg_mater.ma_shader, spec, &refi, &transmit);
d510 3
a512 3
  color[0]= part -> pt_regionp -> reg_mater.ma_color[0];
  color[1]= part -> pt_regionp -> reg_mater.ma_color[1];
  color[2]= part -> pt_regionp -> reg_mater.ma_color[2];
d540 1
a540 1
      Store(pt, ap -> a_ray.r_dir, normal, PType);
d543 1
a543 1
      DiffuseReflect(normal,ap -> a_ray.r_dir);
d546 3
a548 3
      ap -> a_ray.r_pt[0]= pt[0];
      ap -> a_ray.r_pt[1]= pt[1];
      ap -> a_ray.r_pt[2]= pt[2];
d566 1
a566 1
      SpecularReflect(normal,ap -> a_ray.r_dir);
d569 3
a571 3
      ap -> a_ray.r_pt[0]= pt[0];
      ap -> a_ray.r_pt[1]= pt[1];
      ap -> a_ray.r_pt[2]= pt[2];
d579 1
a579 1
      Store(pt, ap -> a_ray.r_dir, normal, PType);
d602 1
a602 1
	if (!Refract(ap -> a_ray.r_dir,normal,1.0,refi))
d605 1
a605 1
	ap -> a_hit= HitRef;
d608 2
a609 2
	bu_log("dir: [%.3f,%.3f,%.3f]\n",ap -> a_ray.r_dir[0],ap -> a_ray.r_dir[1],ap -> a_ray.r_dir[2]);
	bu_log("ref: [%.3f,%.3f,%.3f]\n",ap -> a_ray.r_dir[0],ap -> a_ray.r_dir[1],ap -> a_ray.r_dir[2]);
d611 1
a611 1
	bu_log("p0: [%.3f,%.3f,%.3f],[%.3f,%.3f,%.3f]\n",pt[0],pt[1],pt[2],ap -> a_ray.r_dir[0],ap -> a_ray.r_dir[1],ap -> a_ray.r_dir[2]);
d613 1
a613 1
	ap -> a_onehit= 0;
d615 1
a615 1
	SpecularReflect(normal,ap -> a_ray.r_dir);
d619 3
a621 3
      ap -> a_ray.r_pt[0]= pt[0];
      ap -> a_ray.r_pt[1]= pt[1];
      ap -> a_ray.r_pt[2]= pt[2];
d623 1
a623 1
/*      bu_log("2D: %d, [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f]\n",Depth,pt[0],pt[1],pt[2],ap -> a_ray.r_dir[0], ap -> a_ray.r_dir[1], ap -> a_ray.r_dir[2],normal[0],normal[1],normal[2]);*/
d646 1
a646 1
  for (i= 0; i < PMap[Map] -> StoredPhotons; i++) {
d656 1
a656 1
  while (PMap[PM_IMPORTANCE] -> StoredPhotons < PMap[PM_IMPORTANCE] -> MaxPhotons) {
d660 3
a662 3
      ap -> a_ray.r_dir[0]= 2.0*rand()/(double)RAND_MAX-1.0;
      ap -> a_ray.r_dir[1]= 2.0*rand()/(double)RAND_MAX-1.0;
      ap -> a_ray.r_dir[2]= 2.0*rand()/(double)RAND_MAX-1.0;
d664 3
a666 3
      ap -> a_ray.r_dir[0]= 2.0*drand48()-1.0;
      ap -> a_ray.r_dir[1]= 2.0*drand48()-1.0;
      ap -> a_ray.r_dir[2]= 2.0*drand48()-1.0;
d668 1
a668 1
    } while (ap -> a_ray.r_dir[0]*ap -> a_ray.r_dir[0] + ap -> a_ray.r_dir[1]*ap -> a_ray.r_dir[1] + ap -> a_ray.r_dir[2]*ap -> a_ray.r_dir[2] > 1);
d671 1
a671 1
    VUNITIZE(ap -> a_ray.r_dir);
d674 3
a676 3
    ap -> a_ray.r_pt[0]= eye_pos[0];
    ap -> a_ray.r_pt[1]= eye_pos[1];
    ap -> a_ray.r_pt[2]= eye_pos[2];
d701 1
a701 1
    bu_log("sample points: [%.3f,%.3f,%.3f]\n",lp -> lt_sample_pts[i].lp_pt[0], lp -> lt_sample_pts[i].lp_pt[1], lp -> lt_sample_pts[i].lp_pt[2]);
d706 1
a706 1
      if (PMap[PM_GLOBAL] -> StoredPhotons == PMap[PM_GLOBAL] -> MaxPhotons && (!PMap[PM_CAUSTIC] -> StoredPhotons || PMap[PM_CAUSTIC] -> StoredPhotons == PMap[PM_CAUSTIC] -> MaxPhotons))
d713 3
a715 3
	ap -> a_ray.r_dir[0]= 2.0*rand()/(double)RAND_MAX-1.0;
	ap -> a_ray.r_dir[1]= 2.0*rand()/(double)RAND_MAX-1.0;
	ap -> a_ray.r_dir[2]= 2.0*rand()/(double)RAND_MAX-1.0;
d717 3
a719 3
	ap -> a_ray.r_dir[0]= 2.0*drand48()-1.0;
	ap -> a_ray.r_dir[1]= 2.0*drand48()-1.0;
	ap -> a_ray.r_dir[2]= 2.0*drand48()-1.0;
d721 1
a721 1
      } while (ap -> a_ray.r_dir[0]*ap -> a_ray.r_dir[0] + ap -> a_ray.r_dir[1]*ap -> a_ray.r_dir[1] + ap -> a_ray.r_dir[2]*ap -> a_ray.r_dir[2] > 1);
d723 2
a724 2
      VUNITIZE(ap -> a_ray.r_dir);
/*    } while (drand48() > VDOT(ap -> a_ray.r_dir,ldir));*/ /* we want this to terminate when a rnd# is less than the angle */
d727 3
a729 3
      ap -> a_ray.r_pt[0]= lp -> lt_pos[0];
      ap -> a_ray.r_pt[1]= lp -> lt_pos[1];
      ap -> a_ray.r_pt[2]= lp -> lt_pos[2];
d733 4
a736 4
/*bu_log("Shooting Ray: [%.3f,%.3f,%.3f] [%.3f,%.3f,%.3f]\n",lp -> lt_pos[0], lp -> lt_pos[1], lp -> lt_pos[2], x,y,z);*/
      CurPh.Power[0]= 1000.0 * ScaleIndirect * lp -> lt_intensity * lp -> lt_color[0];
      CurPh.Power[1]= 1000.0 * ScaleIndirect * lp -> lt_intensity * lp -> lt_color[1];
      CurPh.Power[2]= 1000.0 * ScaleIndirect * lp -> lt_intensity * lp -> lt_color[2];
d743 1
a743 1
	if (PMap[i] -> StoredPhotons < PMap[i] -> MaxPhotons)
d747 1
a747 1
/*    bu_log("1: %d, 2: %d\n",PMap[PM_GLOBAL] -> StoredPhotons, PMap[PM_CAUSTIC] -> StoredPhotons);*/
d757 3
a759 3
  bu_log("Pos[%d]: [%.3f,%.3f,%.3f]\n",LR,Root -> P.Pos[0], Root -> P.Pos[1], Root -> P.Pos[2]);
  SanityCheck(Root -> L,1);
  SanityCheck(Root -> R,2);
d768 1
a768 1
  part= PartHeadp -> pt_forw;
d770 1
a770 1
  VJOIN1(pt, ap -> a_ray.r_pt, part -> pt_inhit -> hit_dist, ap -> a_ray.r_dir);
d772 3
a774 3
  RT_HIT_NORMAL(normal, part -> pt_inhit, part -> pt_inseg -> seg_stp, &(ap->a_ray), part -> pt_inflip);
/*  GetEstimate(C1, pt, normal, ScaleFactor/10.0, PMap[PM_GLOBAL] -> StoredPhotons / 100, PM_GLOBAL, 5, 1);*/
/*  GetEstimate(C1, pt, normal, ScaleFactor/1000.0, 10.0*log(PMap[PM_GLOBAL] -> StoredPhotons), PM_GLOBAL, ScaleFactor/5.0, 1);*/
d776 7
a782 7
/*  GetEstimate(C2 ,pt, normal, (int)(ScaleFactor/pow(2,(log(PMap[PM_CAUSTIC] -> MaxPhotons/2)/log(4)))), PMap[PM_CAUSTIC] -> MaxPhotons / 50,PM_CAUSTIC, 0, 0);*/
  GetEstimate(C2 ,pt, normal, ScaleFactor/1024.0, PMap[PM_CAUSTIC] -> MaxPhotons / 100,PM_CAUSTIC, ScaleFactor/256.0, 1, 15);
/*    GetEstimate(IMColor2, pt, normal, (int)(ScaleFactor/100.0),PMap[PM_CAUSTIC] -> MaxPhotons/50,PM_CAUSTIC,1, 0);*/

  (*(vect_t*)ap -> a_purpose)[0]+= C1[0] + C2[0];
  (*(vect_t*)ap -> a_purpose)[1]+= C1[1] + C2[1];
  (*(vect_t*)ap -> a_purpose)[2]+= C1[2] + C2[2];
d826 4
a829 4
  lap -> a_rt_i= ap -> a_rt_i;
  lap -> a_hit= ap -> a_hit;
  lap -> a_miss= ap -> a_miss;
  lap -> a_resource= &GPM_RTAB[pid];
d832 1
a832 1
  P -> Irrad[0]= P -> Irrad[1]= P -> Irrad[2]= 0.0;
d844 3
a846 3
      lap -> a_ray.r_pt[0]= P -> Pos[0];
      lap -> a_ray.r_pt[1]= P -> Pos[1];
      lap -> a_ray.r_pt[2]= P -> Pos[2];
d849 1
a849 1
      Polar2Euclidian(lap -> a_ray.r_dir,P -> Normal,theta,phi);
d852 1
a852 1
      lap -> a_purpose= (void*)P -> Irrad;
d854 1
a854 1
/*      bu_log("Vec: [%.3f,%.3f,%.3f]\n",ap -> a_ray.r_dir[0],ap -> a_ray.r_dir[1],ap -> a_ray.r_dir[2]);*/
d862 3
a864 3
  P -> Irrad[0]*= Coef;
  P -> Irrad[1]*= Coef;
  P -> Irrad[2]*= Coef;
d882 1
a882 1
  if (!Node -> C) {
d884 4
a887 4
    Node -> C++;
/*    bu_log("cp:A:%d\n",Node -> C);*/
    if (!(ICSize%(PMap[PM_GLOBAL] -> MaxPhotons/8)))
      bu_log("    Irradiance Cache Progress: %d%%\n",(int)(0.5+100.0*ICSize/PMap[PM_GLOBAL] -> MaxPhotons));
d889 1
a889 1
    Irradiance(pid, &Node -> P, ap);
d895 2
a896 2
  BuildIrradianceCache(pid, Node -> L, ap);
  BuildIrradianceCache(pid, Node -> R, ap);
d901 1
a901 1
  BuildIrradianceCache(pid, PMap[PM_GLOBAL] -> Root, (struct application*)arg);
d907 3
a909 3
  PMap[MAP] -> MaxPhotons= MapSize;
  PMap[MAP] -> Root= (struct PNode*)malloc(sizeof(struct PNode));
  PMap[MAP] -> StoredPhotons= 0;
d952 2
a953 2
    PMap[PM_GLOBAL] -> StoredPhotons= PMap[PM_GLOBAL] -> MaxPhotons;
    BuildTree(Emit[PM_GLOBAL], PMap[PM_GLOBAL] -> StoredPhotons, PMap[PM_GLOBAL] -> Root);
d955 2
a956 2
    PMap[PM_CAUSTIC] -> StoredPhotons= PMap[PM_CAUSTIC] -> MaxPhotons;
    BuildTree(Emit[PM_CAUSTIC], PMap[PM_CAUSTIC] -> StoredPhotons, PMap[PM_CAUSTIC] -> Root);
d969 3
a971 3
  fwrite(&Root -> P,sizeof(struct Photon),1,FH);
  WritePhotons(Root -> L,FH);
  WritePhotons(Root -> R,FH);
d998 1
a998 1
    I1= PMap[PM_GLOBAL] -> StoredPhotons;
d1001 2
a1002 2
    if (PMap[PM_GLOBAL] -> StoredPhotons)
      WritePhotons(PMap[PM_GLOBAL] -> Root,FH);
d1008 1
a1008 1
    I1= PMap[PM_CAUSTIC] -> StoredPhotons;
d1011 2
a1012 2
    if (PMap[PM_CAUSTIC] -> StoredPhotons)
      WritePhotons(PMap[PM_CAUSTIC] -> Root,FH);
d1078 6
a1083 6
    ap -> a_level= 1;
    ap -> a_onehit= 0;
    ap -> a_ray.magic= RT_RAY_MAGIC;
    ap -> a_hit= PHit;
    ap -> a_miss= PMiss;
    ap -> a_purpose= "Importance Mapping";
d1089 1
a1089 1
      BuildTree(Emit[PM_IMPORTANCE],PMap[PM_IMPORTANCE] -> StoredPhotons,PMap[PM_IMPORTANCE] -> Root);
d1113 1
a1113 1
    for (i= 0; i < PMap -> StoredPhotons; i++)
d1121 2
a1122 2
      if (PMap[i] -> StoredPhotons)
	BuildTree(Emit[i],PMap[i] -> StoredPhotons,PMap[i] -> Root);
d1127 5
a1131 5
    ap -> a_level= 1;
    ap -> a_onehit= 0;
    ap -> a_ray.magic= RT_RAY_MAGIC;
    ap -> a_hit= ICHit;
    ap -> a_miss= ICMiss;
d1140 2
a1141 2
	BU_PTBL_SET(&ap -> a_rt_i -> rti_resources, i, &GPM_RTAB[i]);
	rt_init_resource(&GPM_RTAB[i], GPM_RTAB[i].re_cpu, ap -> a_rt_i);
d1165 1
a1165 1
    SanityCheck(PMap[PM_GLOBAL] -> Root,0);
d1182 6
a1187 6
  c.P= a -> P;
  c.Dist= a -> Dist;
  a -> P= b -> P;
  a -> Dist= b -> Dist;
  b -> P= c.P;
  b -> Dist= c.Dist;
d1189 1
a1189 1
/*  bu_log("  SWAP_IN: %.3f,%.3f\n",a -> Dist, b -> Dist);*/
d1193 1
a1193 1
/*  bu_log("  SWAP_OT: %.3f,%.3f\n",a -> Dist, b -> Dist);*/
d1208 5
a1212 5
/*  bu_log("  CHECK: %.3f > %.3f :: [%d] > [%d]\n",S -> List[ind].Dist,S -> List[i].Dist,ind,i);*/
  if (S -> List[ind].Dist > S -> List[i].Dist) {
/*    bu_log("SWAP_A: %.3f,%.3f\n",S -> List[i].Dist, S -> List[ind].Dist);*/
    Swap(&S -> List[i],&S -> List[ind]);
/*    bu_log("SWAP_B: %.3f,%.3f\n",S -> List[i].Dist, S -> List[ind].Dist);*/
d1226 1
a1226 1
  if (2*ind+1 > S -> Found)
d1229 1
a1229 1
  c= 2*ind+1 < S -> Found ? S -> List[2*ind+2].Dist > S -> List[2*ind+1].Dist ? 2*ind+2 : 2*ind+1 : 2*ind+1;
d1232 4
a1235 4
  if (S -> List[c].Dist > S -> List[ind].Dist) {
/*    bu_log("SWAP_C: %.3f,%.3f :: %d,%d :: %d\n",S -> List[c].Dist, S -> List[ind].Dist,c,ind,S -> Found);*/
    Swap(&S -> List[c],&S -> List[ind]);
/*    bu_log("SWAP_D: %.3f,%.3f :: %d,%d :: %d\n",S -> List[c].Dist, S -> List[ind].Dist,c,ind,S -> Found);*/
d1242 2
a1243 2
  S -> List[S -> Found]= P;
  HeapUp(S,S -> Found++);
d1245 2
a1246 2
  for (i= 0; i < S -> Found; i++)
    bu_log("Push[%d]: %.3f :: %d,%d\n",i,S -> List[i].Dist,S -> Found, S -> Max);
d1252 2
a1253 2
  S -> Found--;
  S -> List[0]= S -> List[S -> Found];
d1256 2
a1257 2
  for (i= 0; i < S -> Found; i++)
    bu_log("Pop [%d]: %.3f :: %d,%d\n",i,S -> List[i].Dist,S -> Found,S -> Max);
d1269 2
a1270 2
  Axis= Root -> P.Axis;
  Dist= Search -> Pos[Axis] - Root -> P.Pos[Axis];
d1274 3
a1276 3
    LocatePhotons(Search,Root -> L);
    if (Dist*Dist < Search -> RadSq)
      LocatePhotons(Search,Root -> R);
d1279 3
a1281 3
    LocatePhotons(Search,Root -> R);
    if (Dist*Dist < Search -> RadSq)
      LocatePhotons(Search,Root -> L);
d1285 6
a1290 6
  /* HEAP, Find Distance between Root Photon and Search -> Pos */
  angle= VDOT(Search -> Normal, Root -> P.Normal);
  Node.P= Root -> P;
  Node.Dist= (Root -> P.Pos[0] - Search -> Pos[0])*(Root -> P.Pos[0] - Search -> Pos[0]) + (Root -> P.Pos[1] - Search -> Pos[1])*(Root -> P.Pos[1] - Search -> Pos[1]) + (Root -> P.Pos[2] - Search -> Pos[2])*(Root -> P.Pos[2] - Search -> Pos[2]);
  if (Node.Dist < Search -> RadSq && angle > GPM_ATOL) { /* Check that Result is within Radius and Angular Tolerance */
    if (Search -> Found < Search -> Max) {
d1293 1
a1293 1
      if (Node.Dist < Search -> List[0].Dist) {
d1302 2
a1303 2
  /* REPLACE, Find Distance between Root Photon and NP -> Pos */
  Dist= (Root -> P.Pos[0] - Search -> Pos[0])*(Root -> P.Pos[0] - Search -> Pos[0]) + (Root -> P.Pos[1] - Search -> Pos[1])*(Root -> P.Pos[1] - Search -> Pos[1]) + (Root -> P.Pos[2] - Search -> Pos[2])*(Root -> P.Pos[2] - Search -> Pos[2]);
d1305 5
a1309 5
  angle= VDOT(Search -> Normal, Root -> P.Normal);
  if (Dist < Search -> RadSq && angle > GPM_ATOL) { /* Check that Result is within Radius and Angular Tolerance */
/*  if (Dist < NP -> RadSq) {*/
    if (Search -> Found < Search -> Max) {
      Search -> List[Search -> Found++].P= Root -> P;
d1311 1
a1311 1
      MDist= (Search -> Pos[0] - Search -> List[0].P.Pos[0])*(Search -> Pos[0] - Search -> List[0].P.Pos[0])+(Search -> Pos[1] - Search -> List[0].P.Pos[1])*(Search -> Pos[1] - Search -> List[0].P.Pos[1])+(Search -> Pos[2] - Search -> List[0].P.Pos[2])*(Search -> Pos[2] - Search -> List[0].P.Pos[2]);
d1313 2
a1314 2
      for (i= 1; i < Search -> Found; i++) {
	TDist= (Search -> Pos[0] - Search -> List[i].P.Pos[0])*(Search -> Pos[0] - Search -> List[i].P.Pos[0])+(Search -> Pos[1] - Search -> List[i].P.Pos[1])*(Search -> Pos[1] - Search -> List[i].P.Pos[1])+(Search -> Pos[2] - Search -> List[i].P.Pos[2])*(Search -> Pos[2] - Search -> List[i].P.Pos[2]);
d1322 1
a1322 1
	Search -> List[MaxInd].P= Root -> P;
d1353 1
a1353 1
    index= ap -> a_x + ap -> a_y*GPM_WIDTH;
d1375 3
a1377 3
/*  NP.RadSq= (ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL] -> MaxPhotons/2)/log(4))))) * (ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL] -> MaxPhotons/2)/log(4)))));*/
/*  bu_log("SF: %.3f\n",(ScaleFactor/(10.0*pow(2,(log(PMap[PM_GLOBAL] -> MaxPhotons/2)/log(4))))));*/
/*  bu_log("SF: %.3f\n",ScaleFactor/pow(PMap[PM_GLOBAL] -> MaxPhotons,0.5));*/
d1380 2
a1381 2
  Search.RadSq= 0.5*ScaleFactor/pow(PMap[PM_GLOBAL] -> MaxPhotons,0.5) * ScaleFactor/pow(PMap[PM_GLOBAL] -> MaxPhotons,0.5);
  Search.Max= pow(PMap[PM_GLOBAL] -> StoredPhotons, 0.5);
d1386 3
a1388 3
/*  NP.RadSq= (4.0*ScaleFactor/PMap[PM_GLOBAL] -> MaxPhotons) * (4.0*ScaleFactor/PMap[PM_GLOBAL] -> MaxPhotons);*/
/*  NP.Max= 2.0*pow(PMap[PM_GLOBAL] -> StoredPhotons, 0.5);*/
/*  Search.Max= PMap[PM_GLOBAL] -> StoredPhotons / 50;*/
d1399 1
a1399 1
    LocatePhotons(&Search,PMap[PM_GLOBAL] -> Root);
d1435 3
a1437 3
/*  GetEstimate(cirrad, pos, normal, (int)(ScaleFactor/100.0),PMap[PM_CAUSTIC] -> MaxPhotons/50,PM_CAUSTIC,1, 0);*/
/*  GetEstimate(cirrad,pos,normal,(int)(ScaleFactor/pow(2,(log(PMap[PM_CAUSTIC] -> MaxPhotons/2)/log(4)))),PMap[PM_CAUSTIC] -> MaxPhotons / 50,PM_CAUSTIC,0,0);*/
  GetEstimate(cirrad,pos,normal,ScaleFactor/1024.0,PMap[PM_CAUSTIC] -> MaxPhotons / 100,PM_CAUSTIC,ScaleFactor/128.0,1,15);
d1476 1
a1476 1
  if (!PMap[map] -> StoredPhotons) return;
d1492 1
a1492 1
    LocatePhotons(&Search,PMap[map] -> Root);
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d133 1
a133 1
        LList[LInd++]= EList[i];
d135 1
a135 1
        RList[RInd++]= EList[i];
d139 1
a139 1
        LList[LInd++]= EList[i];
d141 1
a141 1
        RList[RInd++]= EList[i];
d207 1
a207 1
        break;
d305 1
a305 1
        return(0);
a312 1

d463 1
a463 1
        break;
d551 2
a552 2
          Depth++;
          rt_shootray(ap);
d574 1
a574 1
        PType= PM_CAUSTIC;
d584 1
a584 1
        PType= PM_CAUSTIC;
d598 3
a600 3
        CurPh.Power[0]= power[0];
        CurPh.Power[1]= power[1];
        CurPh.Power[2]= power[2];
d602 2
a603 2
        if (!Refract(ap -> a_ray.r_dir,normal,1.0,refi))
          printf("TIF0\n");
d605 1
a605 1
        ap -> a_hit= HitRef;
d608 4
a611 4
        bu_log("dir: [%.3f,%.3f,%.3f]\n",ap -> a_ray.r_dir[0],ap -> a_ray.r_dir[1],ap -> a_ray.r_dir[2]);
        bu_log("ref: [%.3f,%.3f,%.3f]\n",ap -> a_ray.r_dir[0],ap -> a_ray.r_dir[1],ap -> a_ray.r_dir[2]);
        bu_log("nor: [%.3f,%.3f,%.3f]\n",normal[0],normal[1],normal[2]);
        bu_log("p0: [%.3f,%.3f,%.3f],[%.3f,%.3f,%.3f]\n",pt[0],pt[1],pt[2],ap -> a_ray.r_dir[0],ap -> a_ray.r_dir[1],ap -> a_ray.r_dir[2]);
d613 1
a613 1
        ap -> a_onehit= 0;
d615 1
a615 1
        SpecularReflect(normal,ap -> a_ray.r_dir);
a653 1

d707 1
a707 1
        return;
d711 1
a711 1
        /* Set Ray Direction to application ptr */
d717 3
a719 3
        ap -> a_ray.r_dir[0]= 2.0*drand48()-1.0;
        ap -> a_ray.r_dir[1]= 2.0*drand48()-1.0;
        ap -> a_ray.r_dir[2]= 2.0*drand48()-1.0;
d743 2
a744 2
        if (PMap[i] -> StoredPhotons < PMap[i] -> MaxPhotons)
          EPS[i]++;
d1122 1
a1122 1
        BuildTree(Emit[i],PMap[i] -> StoredPhotons,PMap[i] -> Root);
d1138 4
a1141 4
        GPM_RTAB[i].re_cpu= i;
        GPM_RTAB[i].re_magic= RESOURCE_MAGIC;
        BU_PTBL_SET(&ap -> a_rt_i -> rti_resources, i, &GPM_RTAB[i]);
        rt_init_resource(&GPM_RTAB[i], GPM_RTAB[i].re_cpu, ap -> a_rt_i);
d1154 1
a1154 1
        Map[i]= 0;
d1157 2
a1158 2
        IC[i].List= (struct IrradNode*)malloc(sizeof(struct IrradNode));
        IC[i].Num= 0;
a1196 1

d1294 2
a1295 2
        Pop(Search);
        Push(Search, Node);
d1314 5
a1318 5
        TDist= (Search -> Pos[0] - Search -> List[i].P.Pos[0])*(Search -> Pos[0] - Search -> List[i].P.Pos[0])+(Search -> Pos[1] - Search -> List[i].P.Pos[1])*(Search -> Pos[1] - Search -> List[i].P.Pos[1])+(Search -> Pos[2] - Search -> List[i].P.Pos[2])*(Search -> Pos[2] - Search -> List[i].P.Pos[2]);
        if (TDist > MDist) {
          MDist= TDist;
          MaxInd= i;
        }
d1322 1
a1322 1
        Search -> List[MaxInd].P= Root -> P;
d1358 4
a1361 4
        irrad[0]= IC[index].List[i].RGB[0];
        irrad[1]= IC[index].List[i].RGB[1];
        irrad[2]= IC[index].List[i].RGB[2];
        return;
@


14.14
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.13
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2006 United States Government as represented by
@


14.12
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2002-2005 United States Government as represented by
@


14.11
log
@oop, missed a few win32 defs, using HAVE_DRAND48 and HAVE_SRAND48 instead
@
text
@d28 1
a28 1
 *  
d84 1
a84 1
  } 
d619 1
a619 1
 
d642 1
a642 1
 * Call this function after each light source is processed. 
d703 1
a703 1
  for (i= 0; i < 8; i++) 
d812 1
a812 1
	
d858 1
a858 1
      rt_shootray(lap);	
d882 1
a882 1
  
d1308 1
a1308 1
                                                                                                                                                                                                                                                                   
@


14.11.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d84 1
a84 1
  }
d619 1
a619 1

d642 1
a642 1
 * Call this function after each light source is processed.
d703 1
a703 1
  for (i= 0; i < 8; i++)
d812 1
a812 1

d858 1
a858 1
      rt_shootray(lap);
d882 1
a882 1

d1308 1
a1308 1

@


14.10
log
@if drand48 isn't available, use the win32 rand() alternative
@
text
@d519 1
a519 1
#ifdef WIN32
d662 1
a662 1
#ifdef WIN32
d715 1
a715 1
#ifdef WIN32
d838 1
a838 1
#ifdef WIN32
d1049 1
a1049 1
#ifdef WIN32
@


14.9
log
@Add mods for Windows port
@
text
@d264 1
a264 1
#ifdef WIN32
@


14.8
log
@update copyright to 2005
@
text
@a36 1

a37 2
#include "plastic.h"
#include "light.h"
d264 5
d272 1
d398 1
a398 1
fastf_t max(fastf_t a, fastf_t b, fastf_t c) {
d516 1
a516 1
  prob_ref= max(color[0]+spec[0],color[1]+spec[1],color[2]+spec[2]);
d519 3
d523 1
d662 5
d670 1
d715 5
a719 5
/*
        ap -> a_ray.r_dir[0]= 2.0*rand()/RAND_MAX-1.0;
        ap -> a_ray.r_dir[1]= 2.0*rand()/RAND_MAX-1.0;
        ap -> a_ray.r_dir[2]= 2.0*rand()/RAND_MAX-1.0;
*/
d723 1
d838 4
d844 1
d978 1
a978 1
void WriteFile(char *pmfile) {
d1049 3
d1053 1
d1093 1
a1093 1
      ScaleFactor= max(BBMax[0]-BBMin[0],BBMax[1]-BBMin[1],BBMax[2]-BBMin[2]);
d1102 1
a1102 1
    ScaleFactor= max(BBMax[0]-BBMin[0],BBMax[1]-BBMin[1],BBMax[2]-BBMin[2]);
d1171 1
a1171 1
    WriteFile(pmfile);
@


14.7
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2004 United States Government as represented by
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a31 2
 *  
 *
@


14.5
log
@remove the old distribution notice section
@
text
@a33 3
 *  Copyright Notice -
 *	This software is Copyright (C) 2002-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a32 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d1552 10
@

