head	14.14;
access;
symbols
	rel-7-10-4:14.11
	STABLE:14.11.0.2
	stable-branch:14.6
	rel-7-10-2:14.11
	rel-7-10-0:14.11
	rel-7-8-4:14.9
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.7
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.6
	rel-7-6-0:14.6
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.4
	bobWinPort:14.6.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.14
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.12.16.18.53.49;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.11.28.14.11.25;	author erikgreenwald;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.36.53;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.23.00.35.08;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.03.28.06.31.28;	author bob1961;	state Exp;
branches
	14.6.6.1;
next	14.5;

14.5
date	2005.01.30.20.30.54;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.03.25;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.50;	author morrison;	state Exp;
branches;
next	;

14.6.6.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.14
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                       S H _ F L A T . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file sh_flat.c
 *
 * Notes -
 * This is a basic flat shader.  It will display an object with a set color
 * without taking any effects such as curvature, emission, reflection, etc
 * into consideration.  It simply shades an object constantly with either
 * (in order of reverse priority) 1) the default flat color (white),
 * 2) it's set region color, 2) the specified flat shader color (given via
 * the color attribute).
 *
 * Optionally a transparency value may be shown as well.  With transparency
 * turned on, the background objects will blend through depending on the
 * transparency attribute.  Masking may be specified for each RGB color
 * channel (e.g. perhaps only lets red light through).  This is potentially
 * useful to see background objects through foreground objects, as well as
 * in certain signal analyses as a filter.
 *
 * See the flat_parse_tab structure for details on the symantics of other
 * attribute shorthands/alternatives.
 *
 * Author -
 * Christopher Sean Morrison
 *
 * Source -
 * The U.S. Army Research Laboratory
 * Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#include "common.h"

#include <stddef.h>
#include <stdio.h>
#include <math.h>
#include <string.h> /* for memcpy */

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"

extern int rr_render(struct application	*ap, struct partition *pp, struct shadework *swp);

HIDDEN int	flat_setup(register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip), flat_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	flat_print(register struct region *rp, char *dp), flat_free(char *cp);

/* these are two helper functions to process input color and transparency values */
void normalizedInput_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value);
void singleNormalizedInput_hook(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value);

/*
 * the shader specific structure contains all variables which are unique
 * to any particular use of the shader.
 */
struct flat_specific {
	long	magic;	/* magic # for memory validity check, must come 1st */
	point_t color;  /* overriding flat color */
	point_t transparency; /* how transparent the object is per rgb channel*/
};
#define FLAT_MAGIC 0x464c4154   /* magic number is "FLAT" in hex */
#define CK_FLAT_SP(_p) BU_CKMAG(_p, FLAT_MAGIC, "flat_specific")

/* The default values for the variables in the shader specific structure */
const static
struct flat_specific flat_defaults = {
	FLAT_MAGIC,
	{ 1.0, 1.0, 1.0 }, /* full white */
	{ 0.0, 0.0, 0.0 }  /* completely opaque (no transparency)*/
};

#define SHDR_FLAT	((struct flat_specific *)0)
#define SHDR_O(m)	bu_offsetof(struct flat_specific, m)
#define SHDR_AO(m)	bu_offsetofarray(struct flat_specific, m)


/* description of how to parse/print the arguments to the shader
 * There is at least one line here for each variable in the shader specific
 * structure above.
 *
 * color := is a 0.0 to 1.0 or 0.0 to 255.0 color intensity triplet
 *          representing the RGB color values.
 * rgb := the same as color, just shorter (and implies 0 to 255)
 * bright := sets all three color channels to the same single given intensity.
 *           e.g. a grey value (bright==.2 => color=={.2 .2 .2}==rgb
 * transparency := a color intensity triplet mask to indicate how much of
 *                 background object light are visible through this object.
 * alpha := similar to bright, sets this object's alpha transparency to a
 *          single mask value that gets set for each channel.  e.g 40% opaque
 *          is alpha==.4 which is equiv to transparency=={.4 .4 .4}).
 */
struct bu_structparse flat_parse_tab[] = {
	{ "%f", 3, "color", SHDR_O(color), normalizedInput_hook}, /* for 0->1 color values */
	{ "%f", 3, "rgb", SHDR_O(color), normalizedInput_hook}, /* for 0->255 color values */
	{ "%f", 1, "bright", SHDR_O(color), singleNormalizedInput_hook}, /* for luminosity gray value */
	{ "%f", 3, "transparency", SHDR_O(transparency), normalizedInput_hook}, /* for rgb 0->1 transparency */
	{ "%f", 1, "alpha", SHDR_O(transparency), singleNormalizedInput_hook}, /* for single channel alpha transparency */
	{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

/* The "mfuncs" structure defines the external interface to the shader.
 * Note that more than one shader "name" can be associated with a given
 * shader by defining more than one mfuncs struct in this array.
 * See sh_phong.c for an example of building more than one shader "name"
 * from a set of source functions.  There you will find that "glass" "mirror"
 * and "plastic" are all names for the same shader with different default
 * values for the parameters.
 */
struct mfuncs flat_mfuncs[] = {
	{MF_MAGIC,	"flat",		0,		MFI_HIT,	0, /* !!! try to set to 0 */
	 flat_setup,	flat_render,	flat_print,	flat_free },
	{0,		(char *)0,	0,		0,		0,
	 0,		0,		0,		0 }
};


/* normalizedInput_hook
 *
 * Used as a hooked function for input of values normalized to 1.0.
 *
 * sdp == structure description
 * name == struct member name
 * base == begining of structure
 * value == string containing value
 */
void
normalizedInput_hook( register const struct bu_structparse *sdp, register const char *name, char *base, const char *value ) {

	register double *p = (double *)(base+sdp->sp_offset);
	register int i;
	int ok;

	/* if all the values are in the range [0..1] there's nothing to do */
	for (ok=1, i=0 ; i < sdp->sp_count ; i++, p++) {
		if ( (*p > 1.0) || (*p < 0.0) ) ok = 0;
	}
	if (ok) return;

	/* user specified colors in the range [0..255] (or negative) so we need to
	 * map those into [0..1]
	 */
	p = (double *)(base+sdp->sp_offset);
	for (i=0 ; i < sdp->sp_count ; i++, p++) {
		*p /= 255.0;
	}

	for (ok=1, i=0 ; i < sdp->sp_count ; i++, p++) {
		if ( (*p > 1.0) || (*p < 0.0) ) ok = 0;
	}
	if (ok) bu_log ("User specified values are out of range (0.0 to either 1.0 or 255.0)");
}


/* singleNormalizedInput_hook
 *
 * same as normalizedInput_hook (in fact it calls it) except that only one input
 * is expected from user input.  the hook takes the single input value, and sets
 * it three times.  the value is normalized from 0.0 to 1.0
 */
void
singleNormalizedInput_hook( register const struct bu_structparse *sdp, register const char *name, char *base, const char *value ) {

	register double *p = (double *)(base+sdp->sp_offset);

	normalizedInput_hook(sdp, name, base, value);

	/* copy the first value into the next two locations */
	*(p+1) = *p;
	*(p+2) = *p;
}


/*	F L A T _ S E T U P
 *
 * This routine is called (at prep time) once for each region which uses this
 * shader.  The shader specific flat_specific structure is allocated and
 * default values are set.  Then any user-given values override.
 */
HIDDEN int
flat_setup( register struct region *rp, struct bu_vls *matparm, char **dpp, struct mfuncs *mfp, struct rt_i *rtip) {

	register struct flat_specific	*flat_sp;

	/* check the arguments */
	RT_CHECK_RTI(rtip);
	BU_CK_VLS( matparm );
	RT_CK_REGION(rp);

	if (rdebug&RDEBUG_SHADE)
		bu_log("flat_setup(%s)\n", rp->reg_name);

	/* Get memory for the shader parameters and shader-specific data */
	BU_GETSTRUCT( flat_sp, flat_specific );
	*dpp = (char *)flat_sp;

	/* color priority:
	 *
	 * priority goes first to the flat shader's color parameter
	 * second priority is to the material color value
	 * third  priority is to the flat shader's default color (white)
	 */

	/* initialize the default values for the shader */
	memcpy(flat_sp, &flat_defaults, sizeof(struct flat_specific));

	/* load the material color if it was set */
	if (rp->reg_mater.ma_color_valid) {
		VMOVE(flat_sp->color, rp->reg_mater.ma_color);
	}

	/* parse the user's arguments for this use of the shader. */
	if (bu_struct_parse( matparm, flat_parse_tab, (char *)flat_sp ) < 0 )
		return(-1);

	if (rdebug&RDEBUG_SHADE) {
		bu_struct_print( " Parameters:", flat_parse_tab, (char *)flat_sp );
	}

	return(1);
}


/*
 *	F L A T _ R E N D E R
 *
 *	This is called (from viewshade() in shade.c) once for each hit point
 *	to be shaded.  The purpose here is to fill in values in the shadework
 *	structure.
 *
 *  The flat shader is probably the second most simple shader (second to
 *  the null/invisible shader -- it does nothing).  It shades an object
 *  a constant color.  The only complexity comes into play when a
 *  transparency value is set.  Then we get the color value behind the
 *  one we are shading and blend accordingly with the flat color.
 */
int
flat_render( struct application *ap, struct partition *pp, struct shadework *swp, char *dp ) {

	register struct flat_specific *flat_sp = (struct flat_specific *)dp;
	const point_t unit = {1.0, 1.0, 1.0};
	point_t intensity;

	/* check the validity of the arguments we got */
	RT_AP_CHECK(ap);
	RT_CHECK_PT(pp);
	CK_FLAT_SP(flat_sp);

	if (rdebug&RDEBUG_SHADE)
		bu_struct_print( "flat_render Parameters:", flat_parse_tab, (char *)flat_sp );

	/* do the actual flat color shading for the flat object. if the object is
	 * not transparent, just put the color.  if the object is transparent, do
	 * a little more work determining the background pixel, and then blend with
	 * the flat foreground object.
	 */
	if (VNEAR_ZERO(flat_sp->transparency, SMALL_FASTF)) {

		/* just put the flat value */
		VMOVE(swp->sw_color, flat_sp->color);
	} else {

		/* this gets the background pixel value, if the transparency is not 0 */
		swp->sw_transmit=1.0; /*!!! try to remove */
		VMOVE(swp->sw_basecolor, flat_sp->transparency);
		(void)rr_render( ap, pp, swp );

		/* now blend with the foreground object being shaded */
		VSUB2(intensity, unit, flat_sp->transparency);  /* inverse transparency is how much we want */
		VELMUL(intensity, intensity, flat_sp->color); /* ??? is there a way to merge this mul->add step? */
		VADD2(swp->sw_color, swp->sw_color, intensity);
	}

	return(1);
}


/*
 *	F L A T _ P R I N T
 */
HIDDEN void
flat_print( register struct region *rp, char *dp ) {
	bu_struct_print( rp->reg_name, flat_parse_tab, (char *)dp );
}


/*
 *	F L A T _ F R E E
 */
HIDDEN void
flat_free( char *cp ) {
	bu_free( cp, "flat_specific" );
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.13
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@d47 1
d257 1
a257 1
	static const point_t unit = {1.0, 1.0, 1.0};
@


14.12
log
@LOCAL->static, per machine.h deprecation list
@
text
@d220 1
a220 1
	memcpy(flat_sp, &flat_defaults, sizeof(struct flat_specific) );
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d256 1
a256 1
	LOCAL const point_t unit = {1.0, 1.0, 1.0};
@


14.10
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.9
log
@include stddef.h for bu_offset's usage of offset
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


14.8
log
@update copyright to 2006
@
text
@d50 1
a50 2


d54 1
d90 1
a90 1
#define SHDR_O(m)	offsetof(struct flat_specific, m)
@


14.7
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


14.6
log
@Add code to allow liboptical to be a Windows DLL
@
text
@d23 1
a23 1
 * Notes - 
d27 1
a27 1
 * (in order of reverse priority) 1) the default flat color (white), 
d141 1
a141 1
 * value == string containing value 
d163 1
a163 1
	
d174 1
a174 1
 * is expected from user input.  the hook takes the single input value, and sets 
d179 1
a179 1
	
d227 1
a227 1
	
d269 2
a270 2
	 * not transparent, just put the color.  if the object is transparent, do 
	 * a little more work determining the background pixel, and then blend with 
d289 1
a289 1
 
@


14.6.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d23 1
a23 1
 * Notes -
d27 1
a27 1
 * (in order of reverse priority) 1) the default flat color (white),
d141 1
a141 1
 * value == string containing value
d163 1
a163 1

d174 1
a174 1
 * is expected from user input.  the hook takes the single input value, and sets
d179 1
a179 1

d227 1
a227 1

d269 2
a270 2
	 * not transparent, just put the color.  if the object is transparent, do
	 * a little more work determining the background pixel, and then blend with
d289 1
a289 1

@


14.5
log
@update copyright to 2005
@
text
@a57 2
#include "shadefuncs.h"
#include "shadework.h"
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *	S H _ F L A T . C
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d294 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d29 1
a29 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

