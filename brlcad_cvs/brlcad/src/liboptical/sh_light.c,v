head	14.32;
access;
symbols
	rel-7-10-4:14.29
	STABLE:14.29.0.2
	stable-branch:14.10
	rel-7-10-2:14.29
	rel-7-10-0:14.24
	rel-7-8-4:14.21
	rel-7-8-2:14.16
	rel-7-8-0:14.16
	trimnurbs-branch:14.15.0.2
	help:14.15
	temp_tag:14.13
	bobWinPort-20051223-freeze:14.10
	postmerge-20051223-bobWinPort:14.13
	premerge-20051223-bobWinPort:14.13
	rel-7-6-6:14.13
	rel-7-6-4:14.13
	rel-7-6-2:14.10
	rel-7-6-branch:14.10.0.6
	rel-7-6-0:14.10
	rel-7-4-2:14.10
	rel-7-4-branch:14.10.0.4
	bobWinPort:14.10.0.2
	rel-7-4-0:14.10
	rel-7-2-6:14.10
	rel-7-2-4:14.10
	rel-7-2-2:14.10
	rel-7-2-0:14.8
	rel-7-0-4:14.7
	rel-7-0-2:14.7
	rel-7-0-1:14.7
	opensource-post:14.7
	opensource-pre:1.7
	rel-7-0-branch:1.7.0.2
	rel-7-0:1.7;
locks; strict;
comment	@ * @;


14.32
date	2007.12.16.18.53.49;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2007.09.15.16.23.11;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.09.14.15.21.07;	author erikgreenwald;	state Exp;
branches;
next	14.29;

14.29
date	2007.08.16.17.10.29;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.08.16.07.44.13;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.07.10.02.17.32;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.07.09.17.35.45;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.07.02.05.02.09;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.20.14.36.53;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2006.08.08.22.06.45;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.08.08.18.28.29;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.08.08.18.02.20;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.08.07.10.16.30;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.08.01.15.37.33;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.04.06.20.06.47;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.01.23.00.35.08;	author brlcad;	state Exp;
branches
	14.15.2.1;
next	14.14;

14.14
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.09.19.21.14.08;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.09.19.18.57.48;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.03.30.07.14.09;	author brlcad;	state Exp;
branches
	14.10.6.1;
next	14.9;

14.9
date	2005.03.28.06.31.28;	author bob1961;	state Exp;
branches;
next	14.8;

14.8
date	2005.01.30.20.30.55;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.32.30;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.33;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.03.25;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.19.14.36.02;	author butler;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.19.04.20.19;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.18.20.41.03;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.10.19.49.33;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.09.19.52.43;	author erikg;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.50;	author morrison;	state Exp;
branches;
next	;

14.10.6.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.15.2.1
date	2006.04.07.19.30.21;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.32
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                      S H _ L I G H T . C
 * BRL-CAD
 *
 * Copyright (c) 1998-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file sh_light.c
 *			L I G H T . C
 *
 *  Implement simple isotropic light sources as a material property.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#ifndef lint
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.31 2007/09/15 16:23:11 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "plot3.h"
#include "light.h"
#include "photonmap.h"

#ifdef RT_MULTISPECTRAL
#  include "spectrum.h"
extern const struct bn_table	*spectrum;
#endif


#define LIGHT_O(m)	bu_offsetof(struct light_specific, m)
#define LIGHT_OA(m)	bu_offsetofarray(struct light_specific, m)


/** Heads linked list of lights */
struct light_specific LightHead;


/* for light_print_tab and light_parse callbacks */
HIDDEN void aim_set(const struct bu_structparse *sdp, const char *name, const char *base, char *value);
HIDDEN void light_cvt_visible(const struct bu_structparse *sdp, const char *name, char *base, const char *value);
HIDDEN void light_pt_set(const struct bu_structparse *sdp, const char *name, char *base, const char *value);

HIDDEN int light_setup(struct region *rp, struct bu_vls *matparm, genptr_t *dpp, struct mfuncs *mfp, struct rt_i *rtip);
HIDDEN int light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void light_print(register struct region *rp, char *dp);
HIDDEN void light_free(char *cp);


/** callback registration table for this shader in optical_shader_init() */
struct mfuncs light_mfuncs[] = {
    {MF_MAGIC,	"light",	0,		MFI_NORMAL,	0,     light_setup,	light_render,	light_print,	light_free },
    {0,		(char *)0,	0,		0,		0,     0,		0,		0,		0 }
};

/** for printing out light values */
struct bu_structparse light_print_tab[] = {
    {"%f",	1, "bright",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	1, "angle",	LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	1, "fract",	LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	3, "target",	LIGHT_OA(lt_target),	aim_set },
    {"%d",	1, "shadows",	LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "infinite",	LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "visible",	LIGHT_O(lt_visible),	BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "invisible",	LIGHT_O(lt_invisible),	BU_STRUCTPARSE_FUNC_NULL },
    {"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

/** for actually parsing light values */
struct bu_structparse light_parse[] = {

    {"%f",	1, "bright",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	1, "b",		LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	1, "inten",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },

    {"%f",	1, "angle",	LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	1, "a",		LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },

    {"%f",	1, "fract",	LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },
    {"%f",	1, "f",		LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },

    {"%f",	3, "target",	LIGHT_OA(lt_target),	aim_set },
    {"%f",	3, "t",		LIGHT_OA(lt_target),	aim_set },
    {"%f",	3, "aim",	LIGHT_OA(lt_target),	aim_set },

    {"%d",	1, "shadows",	LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "s",		LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },

    {"%d",	1, "infinite",	LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },
    {"%d",	1, "i",		LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },

    {"%d",	1, "visible",	LIGHT_O(lt_visible),	light_cvt_visible },
    {"%d",	1, "v",		LIGHT_O(lt_visible),	light_cvt_visible },

    {"%d",	1, "invisible",	LIGHT_O(lt_invisible),	light_cvt_visible },

    {"%f",	3, "pt",	LIGHT_OA(lt_parse_pt), light_pt_set },
    {"%f",	6, "pn",	LIGHT_OA(lt_parse_pt), light_pt_set },

    {"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
};

/**
 * This is a container for all the stuff that must be carried around when
 * doing the light obscuration/visibility calculations.
 */
struct light_obs_stuff {
    struct application *ap;
    struct shadework *swp;
    struct light_specific *lsp;
    int *rand_idx;

#ifdef RT_MULTISPECTRAL
    struct bn_tabdata **inten;
#else
    fastf_t *inten;
#endif
    int iter;
    vect_t to_light_center;	/* coordinate system on light */
    vect_t light_x;
    vect_t light_y;
};


/**
 *			A I M _ S E T
 *
 *  This routine is called by bu_struct_parse() if the "aim"
 *  qualifier is encountered, and causes lt_exaim to be set.
 */
HIDDEN void
aim_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
{
    register struct light_specific *lsp = (struct light_specific *)base;
    if (rdebug & RDEBUG_LIGHT )  {
	VPRINT("lt_target: ", lsp->lt_target);
    }
    lsp->lt_exaim = 1;
}


/**
 *  light_cvt_visible()
 *
 *  Convert "visible" flag to "invisible" variable
 */
HIDDEN void
light_cvt_visible(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
     /* structure description */
     /* struct member name */
     /* begining of structure */
     /* string containing value */
{
    struct light_specific *lsp = (struct light_specific *)base;

    if (rdebug & RDEBUG_LIGHT) {
	bu_log("light_cvt_visible(%s, %d)\n", name, sdp->sp_offset);
	bu_log("visible: %d invisible: %d\n",
	       LIGHT_O(lt_visible),
	       LIGHT_O(lt_invisible));
    }
    switch (sdp->sp_offset) {
	case LIGHT_O(lt_invisible):
	    lsp->lt_visible = !lsp->lt_invisible;
	    break;
	case LIGHT_O(lt_visible):
	    lsp->lt_invisible = !lsp->lt_visible;
	    break;
    }
}

/**
 * ensure that there are sufficient light samples, allocate more if
 * necessary in batches.
 */
HIDDEN void
light_pt_allocate(register struct light_specific *lsp)
{
    /* make sure we have enough room, allocate in batches of SOME_LIGHT_SAMPLES */
    if ( lsp->lt_pt_count % SOME_LIGHT_SAMPLES == 0) {
	if (lsp->lt_pt_count < 1) {
	    /* assumes initialized to NULL */
	    if (lsp->lt_sample_pts) {
		bu_free(lsp->lt_sample_pts, "free light samples array");
	    }
	    lsp->lt_sample_pts = (struct light_pt *)bu_calloc(lsp->lt_pt_count + SOME_LIGHT_SAMPLES, sizeof(struct light_pt), "callocate light sample points");
	} else {
	    lsp->lt_sample_pts = (struct light_pt *)bu_realloc(lsp->lt_sample_pts, (lsp->lt_pt_count + SOME_LIGHT_SAMPLES) * sizeof(struct light_pt), "reallocate light sample points");
	}
    }
}


/**
 * create a set of light point samples for specified pt/pn arguments
 * (for points and points with normals respectively)
 */
HIDDEN void
light_pt_set(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
     /* structure description */
     /* struct member name */
     /* begining of structure */
     /* string containing value */
{
    struct light_specific *lsp = (struct light_specific *)base;
    fastf_t *p = (fastf_t *)(base+sdp->sp_offset);

    if (! strcmp("pt", name) ) {
	/* user just specified point, set normal to zeros */
	p[3] = p[4] = p[5] = 0.0;
    } else if ( strcmp("pn", name) ) {
	bu_log("*********** unknown option in light_pt_set %s:%d\n", __FILE__, __LINE__);
	return;
    }

    light_pt_allocate(lsp);
    memcpy(&lsp->lt_sample_pts[ lsp->lt_pt_count++ ], p, sizeof( struct light_pt ));

    if (rdebug & RDEBUG_LIGHT ) {
	bu_log("set light point %g %g %g   N %g %g %g\n", p[0], p[1], p[2], p[3], p[4], p[5]);
    }
}


/**
 *  L I G H T _ R E N D E R
 *
 *  If we have a direct view of the light, return it's color.  A
 *  cosine term is needed in the shading of the light source, to make
 *  it have dimension and shape.  However, just a simple cosine of the
 *  angle between the normal and the direction vector leads to a
 *  pretty dim looking light.  Therefore, a cos/2 + 0.5 term is used
 *  when the viewer is within the beam, and a cos/2 term when the beam
 *  points away.
 */
HIDDEN int
light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp)
{
    register struct light_specific *lsp = (struct light_specific *)dp;
    register fastf_t f;

    RT_CK_LIGHT(lsp);

    /* Provide cosine/2 shading, to make light look round */
    if ((f = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )*0.5) < 0 )
	f = 0;

    /* See if surface normal falls in light beam direction */
    if (VDOT( lsp->lt_aim, swp->sw_hit.hit_normal) < lsp->lt_cosangle )  {
	/* dark, outside of light beam area */
	f *= lsp->lt_fraction;
    } else {
	/* within beam area */
	f = (f+0.5) * lsp->lt_fraction;
    }
#ifdef RT_MULTISPECTRAL
    /* Support a shader having modified the temperature of the source */
    if (swp->sw_temperature > 0 )  {
	rt_spect_black_body( swp->msw_color, swp->sw_temperature, 5 );
	bn_tabdata_scale( swp->msw_color, swp->msw_color, f );
	if (rdebug & RDEBUG_LIGHT )  {
	    bu_log("light %s xy=%d,%d temp=%g\n",
		   pp->pt_regionp->reg_name, ap->a_x, ap->a_y,
		   swp->sw_temperature );
	}
    } else {
	bn_tabdata_scale( swp->msw_color, lsp->lt_spectrum, f );
    }
#else
    if (!PM_Activated) {
	VSCALE( swp->sw_color, lsp->lt_color, f );
    }
#endif
    return(1);
}


/**
 * preparation routine for light_gen_sample_pts() that sets up a
 * sample point ray.
 */
static void
ray_setup(struct application *ap,
	  point_t tree_min,
	  point_t tree_max,
	  point_t span)
{
    int face;
    point_t pt;
    static int idx = 0;

    /* pick a face of the bounding RPP at which we will start the ray */
    face = BN_RANDOM(idx) * 2.9999;

    switch (face) {
    case 0: /* XMIN */
	VSET(ap->a_ray.r_pt,
	     tree_min[X] - 10.0,
	     tree_min[Y] + BN_RANDOM(idx) * span[Y],
	     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
	VSET(pt,
	     tree_max[X],
	     tree_min[Y] + BN_RANDOM(idx) * span[Y],
	     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
	break;

    case 1: /* YMIN */
	VSET(ap->a_ray.r_pt,
	     tree_min[X] + BN_RANDOM(idx) * span[X],
	     tree_min[Y] - 10.0,
	     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
	VSET(pt,
	     tree_min[X] + BN_RANDOM(idx) * span[X],
	     tree_max[Y],
	     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
	break;

    case 2: /* ZMIN */
	VSET(ap->a_ray.r_pt,
	     tree_min[X] +
	     BN_RANDOM(idx) * span[X],

	     tree_min[Y] +
	     BN_RANDOM(idx) * span[Y],

	     tree_min[Z] - 10.0);
	VSET(pt,
	     tree_min[X] +
	     BN_RANDOM(idx) * span[X],

	     tree_min[Y] +
	     BN_RANDOM(idx) * span[Y],

	     tree_max[Z]);
	break;
    }
    VSUB2(ap->a_ray.r_dir, pt, ap->a_ray.r_pt);
    VUNITIZE(ap->a_ray.r_dir);

}


/**
 * this is the hit callback function when shooting grids of rays to
 * generate the points on the light (in light_gen_sample_pts()), we
 * add the hit point(s) to the list of points on the light.
 */
static int
light_gen_sample_pts_hit(register struct application *ap, struct partition *PartHeadp, struct seg *sp)
{
    struct light_specific *lsp = (struct light_specific *)ap->a_uptr;
    struct soltab *stp;
    struct light_pt *lpt;
    struct partition *pp, *prev, *next;

    RT_CK_LIGHT(lsp);

    if ((pp=PartHeadp->pt_forw) == PartHeadp) return 0;

    for( ; pp != PartHeadp; pp = pp->pt_forw )  {

	if (pp->pt_regionp != lsp->lt_rp) continue;

	prev = pp->pt_back;
	/* check to make sure the light hit point isn't against some
	 * other object
	 */
	if (prev != PartHeadp) {
	    double delta;
	    delta = prev->pt_outhit->hit_dist -
		pp->pt_inhit->hit_dist;

	    /* XXX This really should compare to see if adj
	     * object is air
	     */
	    if (delta < 5.0 && delta > -5.0) {
		continue;
	    }
	}

	/* The inbound point is not against another object, so
	 * light will be emitted in this direction
	 */
	if (&lsp->lt_sample_pts) {
	    light_pt_allocate(lsp);
	    lpt = &lsp->lt_sample_pts[lsp->lt_pt_count++];
	} else {
	    /* no sample points? */
	    break;
	}

	stp = pp->pt_inseg->seg_stp;

	if (!lpt || !stp) {
	    break;
	}

	VJOIN1( lpt->lp_pt, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir );

	RT_HIT_NORMAL( lpt->lp_norm, pp->pt_inhit, stp,
		       &(ap->a_ray), pp->pt_inflip );

	/* check to make sure the light out hit point isn't against
	 * some other object
	 */
	next = pp->pt_forw;
	if (next != PartHeadp) {
	    double delta;
	    delta = next->pt_inhit->hit_dist -
		pp->pt_outhit->hit_dist;

	    /* XXX This really should compare to see if adj
	     * object is air
	     */
	    if (delta < 5.0 && delta > -5.0) {
		continue;
	    }
	}
	/* The out point isn't against another object, so light
	 * will be emitted in this direction
	 */
	if (&lsp->lt_sample_pts) {
	    light_pt_allocate(lsp);
	    lpt = &lsp->lt_sample_pts[lsp->lt_pt_count++];
	} else {
	    /* no sample points? */
	    break;
	}

	stp = pp->pt_outseg->seg_stp;

	if (!lpt || !stp) {
	    break;
	}

	VJOIN1( lpt->lp_pt, ap->a_ray.r_pt,
		pp->pt_outhit->hit_dist, ap->a_ray.r_dir );

	RT_HIT_NORMAL( lpt->lp_norm, pp->pt_outhit, stp,
		       &(ap->a_ray), pp->pt_outflip );
    }
    return 1;
}


/**
 * this is the callback miss function when shooting the grids for
 * building light pts (in light_gen_sample_pts()). if we miss the
 * light, then do nothing.
 */
static int
light_gen_sample_pts_miss(register struct application *ap)
{
    return 0;
}


/**
 * L I G H T _ G E N _ S A M P L E _ P T S
 *
 * Generate a set of sample points on the surface of the light with
 * surface normals.  calling during shader init to generate samples
 * for all lights.
 */
void
light_gen_sample_pts(struct application    *upap,
		     struct light_specific  *lsp)
{
    struct application ap;
    point_t tree_min;
    point_t tree_max;
    vect_t  span;
    int total_samples;

    RT_CK_LIGHT(lsp);

    if (rdebug & RDEBUG_LIGHT )
	bu_log("light_gen_sample_pts(%s)\n", lsp->lt_name);


    memset(&ap, 0, sizeof(ap));
    ap.a_rt_i = upap->a_rt_i;
    ap.a_onehit = 0;
    ap.a_hit = light_gen_sample_pts_hit;
    ap.a_miss = light_gen_sample_pts_miss;
    ap.a_uptr = (genptr_t)lsp;

    /* get the bounding box of the light source */
    rt_bound_tree(lsp->lt_rp->reg_treetop, tree_min, tree_max);

    if (rdebug & RDEBUG_LIGHT ) {
	bu_log("\tlight bb (%g %g %g), (%g %g %g)\n",
	       V3ARGS(tree_min), V3ARGS(tree_max) );
    }

    /* if there is no space occupied by the light source, then
     * just give up
     */
    VSUB2(span, tree_max, tree_min);
    if (rdebug & RDEBUG_LIGHT ) {
	bu_log("\tspan %g %g %g\n", V3ARGS(span));
    }
    if (span[X] <= 0.0 && span[Y] <= 0.0 && span[Z] <= 0.0) {
	bu_log("\tSmall light. (treating as point source)\n");
	return;
    }

    /* need enough samples points to avoid shadow patterns */
    total_samples = SOME_LIGHT_SAMPLES * lsp->lt_shadows;
    while ( lsp->lt_pt_count < total_samples ) {
	ray_setup(&ap, tree_min, tree_max, span);
	(void)rt_shootray( &ap );
    }

    /* debugging for the light sample points. output a plot line for
     * each sample point.
     */
    if (rdebug & RDEBUG_LIGHT ) {
	int l;
	point_t p;
	struct light_pt *lpt = &lsp->lt_sample_pts[0];

	bu_log("\t%d light sample points\n", lsp->lt_pt_count);

	for (l=0 ; l < lsp->lt_pt_count ; l++, lpt++) {

	    VJOIN1(p, lpt->lp_pt, 100.0, lpt->lp_norm);

	    bu_log("\tV %g %g %g  %g %g %g\n",
		   V3ARGS(lpt->lp_pt), V3ARGS(p));
	}
    }
}


/**
 *			L I G H T _ P R I N T
 */
HIDDEN void
light_print(register struct region *rp, char *dp)
{
    bu_struct_print(rp->reg_name, light_print_tab, (char *)dp);
}


/**
 *			L I G H T _ F R E E
 */
void
light_free(char *cp)
{
    register struct light_specific *lsp = (struct light_specific *)cp;

    RT_CK_LIGHT(lsp);
    BU_LIST_DEQUEUE( &(lsp->l) );
    if (lsp->lt_name )  {
	bu_free( lsp->lt_name, "light name" );
	lsp->lt_name = (char *)0;
    }
    if (lsp->lt_sample_pts) {
	bu_free(lsp->lt_sample_pts, "free light samples array");
    }
    lsp->l.magic = 0;	/* sanity */
    bu_free( (char *)lsp, "light_specific" );
}


/**
 *			L I G H T _ S E T U P
 *
 *  Called once for each light-emitting region.
 */
HIDDEN int
light_setup(register struct region *rp,
	    struct bu_vls	   *matparm,
	    genptr_t		   *dpp,
	    struct mfuncs          *mfp,
	    struct rt_i            *rtip)
{
    register struct light_specific *lsp;
    register struct soltab *stp;
    vect_t	work;
    fastf_t	f;

    BU_CK_VLS( matparm );
    BU_GETSTRUCT( lsp, light_specific );

    BU_LIST_MAGIC_SET( &(lsp->l), LIGHT_MAGIC );
    lsp->lt_intensity = 1.0;	/* Lumens */
    lsp->lt_fraction = -1.0;	/* Recomputed later */
    lsp->lt_visible = 1;	/* explicitly modeled */
    lsp->lt_invisible = 0;	/* explicitly modeled */
    lsp->lt_shadows = 1;	/* by default, casts shadows */
    lsp->lt_angle = 180;	/* spherical emission by default */
    lsp->lt_exaim = 0;		/* use default aiming mechanism */
    lsp->lt_infinite = 0;
    lsp->lt_rp = rp;
    lsp->lt_pt_count = 0;
    lsp->lt_sample_pts = (struct light_pt *)NULL;
    lsp->lt_name = bu_strdup( rp->reg_name );

    if (bu_struct_parse( matparm, light_parse, (char *)lsp ) < 0 )  {
	light_free((char *)lsp);
	return(-1);
    }

    if (lsp->lt_angle > 180 )  lsp->lt_angle = 180;
    lsp->lt_cosangle = cos( (double) lsp->lt_angle * 0.0174532925199433 );

    /* Determine position and size */
    if (rp->reg_treetop->tr_op == OP_SOLID )  {

	stp = rp->reg_treetop->tr_a.tu_stp;
	VMOVE( lsp->lt_pos, stp->st_center );
	lsp->lt_radius = stp->st_aradius;
    } else {
	vect_t	min_rpp, max_rpp;
	vect_t	rad;
	register union tree *tp;

	if (rt_bound_tree( rp->reg_treetop, min_rpp, max_rpp ) < 0 )
	    return(-1);

	if (max_rpp[X] >= INFINITY )  {
	    bu_log("light_setup(%s) Infinitely large light sources not supported\n",
		   lsp->lt_name );
	    return(-1);
	}

	VADD2SCALE( lsp->lt_pos, min_rpp, max_rpp, 0.5 );
	VSUB2( rad, max_rpp, lsp->lt_pos );
	/* Use smallest radius from center to max as light radius */
	/* Having the radius too large can give very poor lighting */
	if (rad[X] < rad[Y] )
	    lsp->lt_radius = rad[X];
	else
	    lsp->lt_radius = rad[Y];
	if (rad[Z] < lsp->lt_radius )
	    lsp->lt_radius = rad[Z];

	/* Find first leaf node on left of tree */
	tp = rp->reg_treetop;
	while( tp->tr_op != OP_SOLID )
	    tp = tp->tr_b.tb_left;
	stp = tp->tr_a.tu_stp;
    }

    /* Light is aimed down -Z in it's local coordinate system */
    {
	register matp_t	matp;
	if ((matp = stp->st_matp) == (matp_t)0 )
	    matp = (matp_t)bn_mat_identity;
	if (lsp->lt_exaim) {
	    VSUB2 (work, lsp->lt_target, lsp->lt_pos);
	    VUNITIZE (work);
	}
	else VSET( work, 0, 0, -1 );
	MAT4X3VEC( lsp->lt_aim, matp, work );
	VUNITIZE( lsp->lt_aim );
    }

#ifdef RT_MULTISPECTRAL
    BN_GET_TABDATA(lsp->lt_spectrum, spectrum);
    if (rp->reg_mater.ma_temperature > 0 )  {
	rt_spect_black_body( lsp->lt_spectrum,
			     rp->reg_mater.ma_temperature, 5 );
	if (rdebug & RDEBUG_LIGHT )  {
	    bu_log("Light %s temp is %g degK, emission is pure black-body\n",
		   rp->reg_name, rp->reg_mater.ma_temperature);
	}
    } else if (rp->reg_mater.ma_color_valid )  {
	rt_spect_reflectance_rgb( lsp->lt_spectrum,
				  rp->reg_mater.ma_color );
	/* XXX Need to convert units of lumens (candela-sr) to ??
	 * mw/sr?  Use any old numbers to get started.
	 */
	bn_tabdata_scale( lsp->lt_spectrum, lsp->lt_spectrum,
			  lsp->lt_intensity * 0.001 ); /* XXX */
    } else {
	/* Default: Perfectly even emission across whole spectrum */
	bn_tabdata_constval( lsp->lt_spectrum, 0.001 );
    }
#else
    if (rp->reg_mater.ma_color_valid )  {
	VMOVE( lsp->lt_color, rp->reg_mater.ma_color );
    } else {
	VSETALL( lsp->lt_color, 1 );
    }
#endif

    VMOVE( lsp->lt_vec, lsp->lt_pos );
    f = MAGNITUDE( lsp->lt_vec );
    if (f < SQRT_SMALL_FASTF ) {
	/* light at the origin, make its direction vector up */
	VSET( lsp->lt_vec, 0, 0, 1 );
    } else {
	VSCALE( lsp->lt_vec, lsp->lt_vec, f );
    }

    /* Add to linked list of lights */
    if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
	BU_LIST_INIT( &(LightHead.l) );
    }
    BU_LIST_INSERT( &(LightHead.l), &(lsp->l) );

    if (rdebug&RDEBUG_LIGHT) {
	light_print(rp, (char *)lsp);
    }
    if (lsp->lt_invisible )  {
	return(2);	/* don't show light, destroy it later */
    }

    *dpp = (genptr_t)lsp;	/* Associate lsp with reg_udata */
    return(1);
}


/**
 *			L I G H T _ I N I T
 *
 *  Special routine called by view_2init() to determine the relative
 *  intensities of each light source.
 *
 *  Because of the limited dynamic range of RGB space (0..255),
 *  the strategy used here is a bit risky.  We find the brightest
 *  single light source in the model, and assume that the energy from
 *  multiple lights will not shine on a single location in such a way
 *  as to add up to an overload condition.
 *  We then account for the effect of ambient light, because it always
 *  adds it's contribution.  Even here we only expect 50% of the ambient
 *  intensity, to keep the pictures reasonably bright.
 */
int
light_init(struct application *ap)
{
    register struct light_specific *lsp;
    register int		nlights = 0;
    register fastf_t	inten = 0.0;

    if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
	BU_LIST_INIT( &(LightHead.l) );
    }


    for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
	nlights++;
	if (lsp->lt_fraction > 0 )  continue;	/* overridden */
	if (lsp->lt_intensity <= 0 )
	    lsp->lt_intensity = 1;		/* keep non-neg */
	if (lsp->lt_intensity > inten )
	    inten = lsp->lt_intensity;
    }

    /* Compute total emitted energy, including ambient */
    /**	inten *= (1 + AmbientIntensity); **/
    /* This is non-physical and risky, but gives nicer pictures for now */
    inten *= (1 + AmbientIntensity*0.5);

    for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
	RT_CK_LIGHT(lsp);
	if (lsp->lt_fraction > 0 )  continue;	/* overridden */
#ifdef RT_MULTISPECTRAL
	lsp->lt_fraction = 1.0;	/* always use honest intensity values */
#else
	lsp->lt_fraction = lsp->lt_intensity / inten;
#endif
    }

    /*
     * Make sure we have sample points for all light sources in the scene
     */
    for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
	RT_CK_LIGHT(lsp);
	if (lsp->lt_shadows > 1 && ! lsp->lt_infinite && lsp->lt_pt_count < 1)
	    light_gen_sample_pts(ap, lsp);
    }


    if (R_DEBUG) {
	bu_log("Lighting: Ambient = %d%%\n",
	       (int)(AmbientIntensity*100));

	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
	    RT_CK_LIGHT(lsp);
	    bu_log( "  %s: (%g, %g, %g), aimed at (%g, %g, %g)\n",
		    lsp->lt_name,
		    lsp->lt_pos[X], lsp->lt_pos[Y], lsp->lt_pos[Z],
		    lsp->lt_aim[X], lsp->lt_aim[Y], lsp->lt_aim[Z] );
	    bu_log( "  %s: %s, %s, %g lumens (%d%%), halfang=%g\n",
		    lsp->lt_name,
		    lsp->lt_visible ? "visible":"invisible",
		    lsp->lt_shadows ? "casts shadows":"no shadows",
		    lsp->lt_intensity,
		    (int)(lsp->lt_fraction*100),
		    lsp->lt_angle );

	    if ( lsp->lt_pt_count > 0) {
		int samp;

		bu_log( "  %d sample points\n", lsp->lt_pt_count);
		for (samp = 0 ; samp < lsp->lt_pt_count ; samp++) {
		    bu_log("     pt %g %g %g N %g %g %g\n",
			   V3ARGS(lsp->lt_sample_pts[samp].lp_pt),
			   V3ARGS(lsp->lt_sample_pts[samp].lp_norm) );
		}
	    }
	}
    }
    if (nlights > SW_NLIGHTS )  {
	bu_log("Number of lights limited to %d\n", SW_NLIGHTS);
	nlights = SW_NLIGHTS;
    }
    return(nlights);
}


/**
 *			L I G H T _ C L E A N U P
 *
 *  Called from view_end().
 *  Take care of releasing storage for any lights which will not
 *  be cleaned up by mlib_free():
 *	implicitly created lights, because they have no associated region, and
 *	invisible lights, because their region was destroyed.
 */
void
light_cleanup(void)
{
    register struct light_specific *lsp, *zaplsp;

    if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
	BU_LIST_INIT( &(LightHead.l) );
	return;
    }
    for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
	RT_CK_LIGHT(lsp);
	if (lsp->lt_rp != REGION_NULL && lsp->lt_visible )  {
	    /* Will be cleaned up by mlib_free() */
	    continue;
	}
	zaplsp = lsp;
	lsp = BU_LIST_PREV( light_specific, &(lsp->l) );
	light_free( (genptr_t)zaplsp );
    }
}


/**
 *			L I G H T _ H I T
 *
 *  A light visibility test ray hit something.  Determine what this means.
 *
 *  Input -
 *	a_color[] contains the fraction of a the light that will be
 *	propagated back along the ray, so far.  If this gets too small,
 *	recursion through lots of glass ought to stop.
 *  Output -
 *	a_color[] contains the fraction of light that can be seen.
 *	RGB transmissions are separately indicated, to allow simplistic
 *	colored glass (with apologies to Roy Hall).
 *
 *  a_spectrum is used in place of a_color for multispectral renderings.
 *
 *  These shadow functions return a boolean "light_visible".
 *
 *  This is a simplified algorithm, and could be improved.
 *  Reflected light can't be dealt with at all.
 *
 *  Would also be nice to return an actual energy level, rather than
 *  a boolean, which could account for distance, etc.
 */
int
light_hit(struct application *ap, struct partition *PartHeadp, struct seg *finished_segs)
{
    register struct partition *pp;
    register struct region	*regp = NULL;
    struct application	sub_ap;
    struct shadework	sw;
    const struct light_specific	*lsp;

    int	light_visible = 0;
    int	air_sols_seen = 0;
    int 	is_proc;
    char	*reason = "???";

#ifdef RT_MULTISPECTRAL
    struct bn_tabdata	*ms_filter_color = BN_TABDATA_NULL;
#else
    vect_t	filter_color;
#endif

    RT_CK_PT_HD(PartHeadp);

    memset(&sw, 0, sizeof(sw));		/* make sure nothing nasty on the stack */
    if (rdebug&RDEBUG_LIGHT)
	bu_log("light_hit level %d %d\n", ap->a_level, __LINE__);

#ifdef RT_MULTISPECTRAL
    sub_ap.a_spectrum = BN_TABDATA_NULL;	/* sanity */
    BN_CK_TABDATA(ap->a_spectrum);
#endif

    BU_CK_LIST_HEAD(&finished_segs->l);

    lsp = (struct light_specific *)(ap->a_uptr);
    RT_CK_LIGHT(lsp);

#ifdef RT_MULTISPECTRAL
    ms_filter_color = bn_tabdata_get_constval( 1.0, spectrum );
    BN_GET_TABDATA( sw.msw_color, spectrum );
    BN_GET_TABDATA( sw.msw_basecolor, spectrum );
#else
    VSETALL( filter_color, 1 );
#endif

    /* anything to do? */
    if (PartHeadp->pt_forw == PartHeadp) {
	bu_log("light_hit:  ERROR, EMPTY PARTITION sxy=(%d, %d)\n", ap->a_x, ap->a_y);
	light_visible = 0;
	reason = "ERROR: EMPTY PARTITION";
	goto out;
    }

    /*XXX Bogus with Air.  We should check to see if it is the same
     * surface.
     *
     *  Since the light visibility ray started at the surface of a solid,
     *  it is likely that the solid will be the first partition on
     *  the list, with pt_outhit->hit_dist being roughly zero.
     *  Don't start using partitions until pt_inhit->hit_dist is
     *  slightly larger than zero, i.e., that the partition is not
     *  including the start point.
     *  The outhit distance needs to be checked too, so that if the
     *  partition is heading through the solid toward the light
     *  e.g. (-1,+50), then the fact that the light is obscured will
     *  not be missed.
     */
    for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
	if (pp->pt_regionp->reg_aircode != 0 )  {
	    /* Accumulate transmission through each air lump */
	    air_sols_seen++;

	    /* Obtain opacity of this region, multiply */
	    sw.sw_inputs = 0;
	    sw.sw_transmit = sw.sw_reflect = 0.0;
	    sw.sw_refrac_index = 1.0;
	    sw.sw_xmitonly = 1;	/* only want sw_transmit */
	    sw.sw_segs = finished_segs;
#ifdef RT_MULTISPECTRAL
	    bn_tabdata_constval( sw.msw_color, 1.0 );
	    bn_tabdata_constval( sw.msw_basecolor, 1.0 );
#else
	    VSETALL( sw.sw_color, 1 );
	    VSETALL( sw.sw_basecolor, 1 );
#endif
	    if (rdebug&RDEBUG_LIGHT) bu_log("calling viewshade\n");
	    (void)viewshade( ap, pp, &sw );
	    if (rdebug&RDEBUG_LIGHT) bu_log("viewshade returns\n");
	    /* sw_transmit is only return */

	    /* XXX Clouds don't yet attenuate differently based on freq */
#ifdef RT_MULTISPECTRAL
	    bn_tabdata_scale( ms_filter_color, ms_filter_color,
			      sw.sw_transmit );
#else
	    VSCALE( filter_color, filter_color, sw.sw_transmit );
#endif
	    continue;
	}
	if (pp->pt_inhit->hit_dist >= ap->a_rt_i->rti_tol.dist )
	    break;
	if (pp->pt_outhit->hit_dist >= ap->a_rt_i->rti_tol.dist*10 )
	    break;
    }


    if (pp == PartHeadp )  {
	if (rdebug&RDEBUG_LIGHT) bu_log("pp == PartHeadp\n");

	pp=PartHeadp->pt_forw;
	RT_CK_PT(pp);

	if (lsp->lt_invisible || lsp->lt_infinite )  {
	    light_visible = 1;
#ifdef RT_MULTISPECTRAL
	    bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
	    VMOVE( ap->a_color, filter_color );
#endif
	    reason = "Unobstructed invisible/infinite light";
	    goto out;
	}

	if (air_sols_seen > 0 )  {
	    light_visible = 1;
#ifdef RT_MULTISPECTRAL
	    bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
	    VMOVE( ap->a_color, filter_color );
#endif
	    /* XXXXXXX This seems to happen with *every*
	     * light vis ray through air
	     */
	    reason = "Off end of partition list, air was seen";
	    goto out;
	}

	if (pp->pt_inhit->hit_dist <= ap->a_rt_i->rti_tol.dist) {
	    int retval;
	    /* XXX This is bogus if air is being used */
	    /* What has probably happened is that the shadow ray
	     * has produced an Out-hit from the current solid
	     * which looks valid, but is in fact an intersection
	     * with the current hit point.
	     */

	    sub_ap = *ap;	/* struct copy */
	    sub_ap.a_level++;
#ifdef RT_MULTISPECTRAL
	    sub_ap.a_spectrum = bn_tabdata_dup( ap->a_spectrum );
#endif
	    /* pt_outhit->hit_point has not been calculated */
	    VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt,
		   pp->pt_outhit->hit_dist, ap->a_ray.r_dir);

	    if (rdebug&RDEBUG_LIGHT) bu_log("hit_dist < tol\n");
	    retval = rt_shootray( &sub_ap );

	    ap->a_user = sub_ap.a_user;
	    ap->a_uptr = sub_ap.a_uptr;
#ifdef RT_MULTISPECTRAL
	    bn_tabdata_copy( ap->a_spectrum, sub_ap.a_spectrum );
#else
	    ap->a_color[0] = sub_ap.a_color[0];
	    ap->a_color[1] = sub_ap.a_color[1];
	    ap->a_color[2] = sub_ap.a_color[2];
#endif
	    VMOVE(ap->a_uvec, sub_ap.a_uvec);
	    VMOVE(ap->a_vvec, sub_ap.a_vvec);
	    ap->a_refrac_index = sub_ap.a_refrac_index;
	    ap->a_cumlen = sub_ap.a_cumlen;
	    ap->a_return = sub_ap.a_return;

	    light_visible = retval;
	    reason = "pressed on past start point";
	    goto out;
	}


	bu_log("light_hit:  ERROR, nothing hit, sxy=%d,%d, dtol=%e\n",
	       ap->a_x, ap->a_y,
	       ap->a_rt_i->rti_tol.dist);
	rt_pr_partitions(ap->a_rt_i, PartHeadp, "light_hit pt list");
	light_visible = 0;
	reason = "error, nothing hit";
	goto out;
    }

    regp = pp->pt_regionp;

    /* Check to see if we hit the light source */
    if (lsp->lt_rp == regp )  {
#ifdef RT_MULTISPECTRAL
	bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
	VMOVE( ap->a_color, filter_color );
#endif
	light_visible = 1;
	reason = "hit light";
	goto out;
    }

    /* if the region we hit is a light source be generous */
#if 1
    {
	struct light_specific *lsp;
	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
	    if (lsp->lt_rp == regp) {
#ifdef RT_MULTISPECTRAL
		bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
		VMOVE( ap->a_color, filter_color );
#endif
		light_visible = 1;
		reason = "hit light";
		goto out;

	    }
	}
    }
#endif
    /* or something futher away than a finite invisible light */
    if (lsp->lt_invisible && !(lsp->lt_infinite) ) {
	vect_t	tolight;
	VSUB2( tolight, lsp->lt_pos, ap->a_ray.r_pt );
	if (pp->pt_inhit->hit_dist >= MAGNITUDE(tolight) ) {
#ifdef RT_MULTISPECTRAL
	    bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
#else
	    VMOVE( ap->a_color, filter_color );
#endif
	    light_visible = 1;
	    reason = "hit behind invisible light ==> hit light";
	    goto out;
	}
    }

    /* If we hit an entirely opaque object, this light is invisible */
    is_proc = ((struct mfuncs *)regp->reg_mfuncs)->mf_flags|MFF_PROC;


    if (pp->pt_outhit->hit_dist >= INFINITY ||
	(regp->reg_transmit == 0 &&
	 ! is_proc /* procedural shader */) ) {

#ifdef RT_MULTISPECTRAL
	bn_tabdata_constval( ap->a_spectrum, 0.0 );
#else
	VSETALL( ap->a_color, 0 );
#endif
	light_visible = 0;
	reason = "hit opaque object";
	goto out;
    }

#ifdef RT_MULTISPECTRAL
    /* XXX Check area under spectral curve?  What power level for thresh? */
#else
    /*  See if any further contributions will mater */
    if (ap->a_color[0] + ap->a_color[1] + ap->a_color[2] < 0.01 )  {
	/* Any light energy is "fully" attenuated by here */
	VSETALL( ap->a_color, 0 );
	light_visible = 0;
	reason = "light fully attenuated before shading";
	goto out;
    }
#endif

    /*
     *  Determine transparency parameters of this object.
     *  All we really need here is the opacity information;
     *  full shading is not required.
     */
    sw.sw_inputs = 0;
    sw.sw_transmit = sw.sw_reflect = 0.0;
    sw.sw_refrac_index = 1.0;
    sw.sw_xmitonly = 1;		/* only want sw_transmit */
    sw.sw_segs = finished_segs;
#ifdef RT_MULTISPECTRAL
    bn_tabdata_constval( sw.msw_color, 1.0 );
    bn_tabdata_constval( sw.msw_basecolor, 1.0 );
#else
    VSETALL( sw.sw_color, 1 );
    VSETALL( sw.sw_basecolor, 1 );
#endif

    if (rdebug&RDEBUG_LIGHT) bu_log("calling viewshade\n");
    (void)viewshade( ap, pp, &sw );
    if (rdebug&RDEBUG_LIGHT) bu_log("viewshade back\n");
    /* sw_transmit is output */

#ifdef RT_MULTISPECTRAL
    bn_tabdata_scale( ms_filter_color, ms_filter_color, sw.sw_transmit );
    /* XXX Power level check again? */
#else
    VSCALE( filter_color, filter_color, sw.sw_transmit );
    if (filter_color[0] + filter_color[1] + filter_color[2] < 0.01 )  {
	/* Any recursion won't be significant */
	VSETALL( ap->a_color, 0 );
	light_visible = 0;
	reason = "light fully attenuated after shading";
	goto out;
    }
#endif
    /*
     * Push on to exit point, and trace on from there.
     * Transmission so far is passed along in sub_ap.a_color[];
     * Don't even think of trying to refract, or we will miss the light!
     */
    sub_ap = *ap;			/* struct copy */
    sub_ap.a_level = ap->a_level+1;
#ifdef RT_MULTISPECTRAL
    sub_ap.a_spectrum = bn_tabdata_dup( ap->a_spectrum );
#endif
    {
	register fastf_t f;
	f = pp->pt_outhit->hit_dist + ap->a_rt_i->rti_tol.dist;
	VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt, f, ap->a_ray.r_dir);
    }
    sub_ap.a_purpose = "light transmission after filtering";
    if (rdebug&RDEBUG_LIGHT)
	bu_log("shooting level %d from %d\n",
	       sub_ap.a_level, __LINE__);
    light_visible = rt_shootray( &sub_ap );
    if (rdebug&RDEBUG_LIGHT)
	if (light_visible < 0)
	    bu_log("%s:%d\n", __FILE__, __LINE__);

#ifdef RT_MULTISPECTRAL
    bn_tabdata_mul( ap->a_spectrum, sub_ap.a_spectrum, ms_filter_color );
#else
    VELMUL( ap->a_color, sub_ap.a_color, filter_color );
#endif
    reason = "after filtering";
 out:

#ifdef RT_MULTISPECTRAL
    if (ms_filter_color ) bn_tabdata_free( ms_filter_color );
    if (sw.msw_color )  bn_tabdata_free( sw.msw_color );
    if (sw.msw_basecolor ) bn_tabdata_free( sw.msw_basecolor );
    if (sub_ap.a_spectrum )  bn_tabdata_free( sub_ap.a_spectrum );
    if (rdebug & RDEBUG_LIGHT )  {
	bu_log("light vis=%d %s %s %s  ",
	       light_visible,
	       lsp->lt_name,
	       reason,
	       regp ? regp->reg_name : "" );
	bn_pr_tabdata("light spectrum", ap->a_spectrum);
    }
#else
    if (rdebug & RDEBUG_LIGHT ) bu_log("light vis=%d %s (%4.2f, %4.2f, %4.2f) %s %s\n",
				       light_visible,
				       lsp->lt_name,
				       V3ARGS(ap->a_color), reason,
				       regp ? regp->reg_name : "" );
#endif
    return(light_visible);
}


/**
 *  			L I G H T _ M I S S
 *
 *  If there is no explicit light solid in the model, we will always "miss"
 *  the light, so return light_visible = TRUE.
 */
int
light_miss(register struct application *ap)
{
    struct light_specific *lsp = (struct light_specific *)(ap->a_uptr);

    RT_CK_LIGHT(lsp);
    if (lsp->lt_invisible || lsp->lt_infinite ) {
	VSETALL( ap->a_color, 1 );
	if (rdebug & RDEBUG_LIGHT ) bu_log("light_miss vis=1\n");
	return(1);		/* light_visible = 1 */
    }

    if (rdebug & RDEBUG_LIGHT) {
	bu_log("light ray missed non-infinite, visible light source\n");
	bu_log("on pixel: %d %d\n", ap->a_x, ap->a_y);
	bu_log("ray: (%g %g %g) -> %g %g %g\n", V3ARGS(ap->a_ray.r_pt), V3ARGS(ap->a_ray.r_dir) );
	bu_log("a_level: %d\n", ap->a_level);
    }

    /* Missed light, either via blockage or dither.  Return black */
    VSETALL( ap->a_color, 0 );
    if (rdebug & RDEBUG_LIGHT ) bu_log("light_miss vis=0\n");
    return(-1);			/* light_visible = 0 */
}


#define VF_SEEN 1
#define VF_BACKFACE 2
/**
 * l i g h t _ v i s
 *
 * Compute 1 light visibility ray from a hit point to the light.
 * Called by light_obs() to determine light visibility.
 */
static int
light_vis(struct light_obs_stuff *los, char *flags)
{
    const double cosine89_99deg = 0.0001745329;
    struct application sub_ap;
    double radius = 0.0;
    double angle = 0.0;
    double cos_angle, x, y;
    point_t shoot_pt;
    vect_t shoot_dir;
    int shot_status;
    vect_t dir, rdir;
    int idx;
    int k = 0;
    struct light_pt *lpt;
    int tryagain = 0;
    double VisRayvsLightN;
    double VisRayvsSurfN;

    if (rdebug & RDEBUG_LIGHT ) bu_log("light_vis\n");

 retry:

    /* compute the light direction */
    if (los->lsp->lt_infinite ) {
	/* Infinite lights are point sources, no fuzzy penumbra */
	VMOVE( shoot_dir, los->lsp->lt_vec );

    } else if (los->lsp->lt_pt_count > 0) {
	static const vect_t zero = { 0.0, 0.0, 0.0 };

	/* pick a point at random from the list of points on
	 * the surface of the light.  If the normals indicate
	 * inter-visibility, then shoot at that point
	 */

	idx = los->lsp->lt_pt_count *
	    fabs(bn_rand_half(los->ap->a_resource->re_randptr)) *
	    2.0;
	if (idx == los->lsp->lt_pt_count) idx--;

    reusept:

	for (k=idx ; ((k+1) % los->lsp->lt_pt_count) != idx ;
	     k = (k+1) % los->lsp->lt_pt_count) {
	    if (rdebug & RDEBUG_LIGHT )
		bu_log("checking sample pt %d\n", k);

	    if (flags[k] & VF_SEEN ) continue;
	    if (flags[k] & VF_BACKFACE ) continue;

	    /* we've got a candidate, check for backfacing */
	    if (rdebug & RDEBUG_LIGHT )
		bu_log("\tpossible sample pt %d\n", k);

	    lpt = &los->lsp->lt_sample_pts[k];

	    VSUB2(dir, lpt->lp_pt, los->swp->sw_hit.hit_point);
	    VUNITIZE(dir);
	    VREVERSE(rdir, dir);


	    /* if the surface normals of the light and hit point
	     * indicate that light could pass between the two
	     * points, then we have a good choice
	     *
	     * If the light point has no surface normal, then
	     * this is a general point usable from any angle
	     * so again we can shoot at this point
	     *
	     * We tolerance this down so that light points which
	     * are in the plane of the hit point are not candidates
	     * (since the light on the surface from such would be
	     * very small).  We also tolerance the normal on the
	     * light to the visibility ray so that points on the
	     * perimiter of the presented area of the light source
	     * are not chosen.  This helps avoid shooting at points
	     * on the light source which machine floating-point
	     * inaccuracies would cause the ray to miss.
	     */

	    VisRayvsSurfN
		= VDOT(los->swp->sw_hit.hit_normal, dir);

	    if ( VEQUAL(lpt->lp_norm, zero) ) {
		VisRayvsLightN = 1.0;
	    } else {
		VisRayvsLightN = VDOT(lpt->lp_norm, rdir);
	    }


	    if ( VisRayvsLightN > cosine89_99deg &&
		   VisRayvsSurfN > cosine89_99deg ) {

		/* ok, we can shoot at this sample point */
		if (rdebug & RDEBUG_LIGHT )
		    bu_log("\tPt %d selected... OK normal %g %g %g\n",
			   k, V3ARGS(lpt->lp_norm));

		flags[k] |= VF_SEEN;

		goto done;
	    }

	    if (rdebug & RDEBUG_LIGHT ) {
		bu_log("\tbackfacing\n");
		bu_log("VisRayvsLightN %g\n", VisRayvsLightN);
		bu_log("VisRayvsSurfN %g\n", VisRayvsSurfN);
		VPRINT("norm", lpt->lp_norm);
		VPRINT("zero", zero);
	    }
	    /* the sample point is backfacing to the location
	     * we want to test from
	     */
	    flags[k] |= VF_BACKFACE;
	}

	/* if we get here, then everything is used or backfacing */

	if (rdebug & RDEBUG_LIGHT ) {
	    bu_log("all light sample pts used.  trying to recycle\n");
	}

	tryagain = 0;
	for (k=0 ; k < los->lsp->lt_pt_count ; k++) {
	    if (flags[k] & VF_SEEN ) {
		/* this one was used, we can re-use it */
		tryagain = 1;
		flags[k] &= VF_BACKFACE;
	    }
	}
	if (tryagain) {
	    if (rdebug & RDEBUG_LIGHT ) {
		bu_log("recycling\n");
	    }
	    goto reusept;
	}
	/* at this point, we have no candidate points available to
	 * shoot at
	 */
	if (rdebug & RDEBUG_LIGHT ) {
	    bu_log("can't find point to shoot at\n");
	}
	return 0;
    done:
	/* we've got a point on the surface of the light to shoot at */
	VMOVE(shoot_pt, lpt->lp_pt);
	VSUB2(shoot_dir, shoot_pt, los->swp->sw_hit.hit_point);

    } else {

	if (rdebug & RDEBUG_LIGHT )
	    bu_log("shooting at approximating sphere\n");
	/* We're going to shoot at a point on the apporximating
	 * sphere for the light source.  We pick a point on the
	 * circle (presented area) for the light source from this
	 * angle.  This is done by picking random radius and angle
	 * values on the disc.
	 */
	radius = los->lsp->lt_radius *
	    /*			drand48(); */
	    fabs(bn_rand_half(los->ap->a_resource->re_randptr)
		 * 2.0);
	angle =  M_PI * 2.0 *
	    /*			drand48(); */
	    (bn_rand_half(los->ap->a_resource->re_randptr) + 0.5);

	y = radius * bn_tab_sin(angle);

	/* by adding 90 degrees to the angle, the sin of the new
	 * angle becomes the cosine of the old angle.  Thus we
	 * can use the sine table to compute the value, and avoid
	 * the expensive actual computation.  So the next 3 lines
	 * replace:
	 *		x = radius * cos(angle);
	 */
	cos_angle = M_PI_2 + angle;
	if (cos_angle > (2.0*M_PI)) cos_angle -= (2.0*M_PI);
	x = radius * bn_tab_sin(cos_angle);

	VJOIN2(shoot_pt, los->lsp->lt_pos,
	       x, los->light_x,
	       y, los->light_y);

	if (rdebug & RDEBUG_LIGHT) {
	    bu_log("light at (%g %g %g) radius %g\n",
		   V3ARGS(los->lsp->lt_pos),
		   los->lsp->lt_radius);

	    bu_log("\tshooting at radius %g\n", radius);

	    bu_log("\ttarget light point %g %g %g\n",
		   V3ARGS(shoot_pt));
	}
	VSUB2(shoot_dir, shoot_pt, los->swp->sw_hit.hit_point);
    }

    if (rdebug & RDEBUG_LIGHT) {
	VPRINT("shoot_dir", shoot_dir);
    }

    if (rdebug& RDEBUG_RAYPLOT) {
	point_t ray_endpt;

	/* Yelow -- light visibility ray */
	VADD2(ray_endpt, los->swp->sw_hit.hit_point, shoot_dir);
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	pl_color(stdout, 200, 200, 0);
	pdv_3line(stdout, los->swp->sw_hit.hit_point, ray_endpt);
	bu_semaphore_release( BU_SEM_SYSCALL );
    }

    VUNITIZE( shoot_dir );

    /*
     * See if ray from hit point to light lies within light beam
     * Note: this is should always be true for infinite lights!
     */
    if (-VDOT(shoot_dir, los->lsp->lt_aim) < los->lsp->lt_cosangle )  {
	/* dark (outside of light beam) */
	if (rdebug & RDEBUG_LIGHT)
	    bu_log("point outside beam, obscured: %s\n",
		   los->lsp->lt_name);
	return 0;
    }


    if (!(los->lsp->lt_shadows) )  {
	/* "fill light" in beam, don't care about shadows */
	if (rdebug & RDEBUG_LIGHT)
	    bu_log("fill light, no shadow, visible: %s\n",
		   los->lsp->lt_name);

#ifdef RT_MULTISPECTRAL
	/* XXX Need a power level for this! */
	bn_tabdata_constval( ((struct bn_tabdata *)los->inten), 1.0);
#else
	VSETALL( ((vectp_t)los->inten), 1 );
#endif

	return -1;
    }


    /*
     *  Fire ray at light source to check for shadowing.
     *  (This SHOULD actually return an energy spectrum).
     *  Advance start point slightly off surface.
     */
    sub_ap = *los->ap;			/* struct copy */
    RT_CK_AP(&sub_ap);

    VMOVE( sub_ap.a_ray.r_dir, shoot_dir );
    {
	register fastf_t f;
	f = los->ap->a_rt_i->rti_tol.dist;
	VJOIN1( sub_ap.a_ray.r_pt, los->swp->sw_hit.hit_point, f,
		shoot_dir);
    }
    sub_ap.a_rbeam = los->ap->a_rbeam +
	los->swp->sw_hit.hit_dist *
	los->ap->a_diverge;
    sub_ap.a_diverge = los->ap->a_diverge;

    sub_ap.a_hit = light_hit;
    sub_ap.a_miss = light_miss;
    sub_ap.a_user = -1;		/* sanity */
    sub_ap.a_uptr = (genptr_t)los->lsp;	/* so we can tell.. */
    sub_ap.a_level = 0;
    /* Will need entry & exit pts, for filter glass ==> 2 */
    /* Continue going through air ==> negative */
    sub_ap.a_onehit = -2;

    VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
    sub_ap.a_purpose = los->lsp->lt_name;	/* name of light shot at */

    RT_CK_LIGHT((struct light_specific *)(sub_ap.a_uptr));
    RT_CK_AP(&sub_ap);

    if (rdebug & RDEBUG_LIGHT)
	bu_log("shooting level %d from %d\n",
	       sub_ap.a_level, __LINE__);
    shot_status = rt_shootray( &sub_ap );
    if (rdebug & RDEBUG_LIGHT)
	bu_log("shot_status: %d\n", shot_status);

    if (shot_status < 0) {
	if (los->lsp->lt_infinite) {
	}  else if (los->lsp->lt_pt_count > 0) {
	    if (rdebug & RDEBUG_LIGHT) {
		bu_log("was pt %d\n (%g %g %g) normal %g %g %g\n", k,
		       V3ARGS(los->lsp->lt_sample_pts[k].lp_pt),
		       V3ARGS(los->lsp->lt_sample_pts[k].lp_norm) );
	    }
	} else {
	    if (rdebug & RDEBUG_LIGHT) {
		bu_log("was radius: %g of (%g) angle: %g\n",
		       radius, los->lsp->lt_radius, angle);

		bu_log("re-shooting\n");
	    }
	    goto retry;
	}
    }

    if (shot_status > 0 )  {
	/* light visible */
	if (rdebug & RDEBUG_LIGHT)
	    bu_log("light visible: %s\n", los->lsp->lt_name);

#ifdef RT_MULTISPECTRAL
	BN_CK_TABDATA(sub_ap.a_spectrum);
	if (*(los->inten) == BN_TABDATA_NULL) {
	    *(los->inten) = sub_ap.a_spectrum;
	} else {
	    BN_CK_TABDATA(*(los->inten));
	    bn_tabdata_add(*(los->inten),
			   *(los->inten),
			   sub_ap.a_spectrum);

	    bn_tabdata_free(sub_ap.a_spectrum);
	}
	sub_ap.a_spectrum = BN_TABDATA_NULL;
#else
	VMOVE( los->inten, sub_ap.a_color );
#endif

	return 1;
    }

    /* dark (light obscured) */
    if (rdebug & RDEBUG_LIGHT)
	bu_log("light obscured: %s\n", los->lsp->lt_name);

    return 0;
}


/**
 *	L I G H T _ O B S C U R A T I O N
 *
 *	Determine the visibility of each light source in the scene from a
 *	particular location.
 *	It is up to the caller to apply sw_lightfract[] to lp_color, etc.
 *
 *	Sets
 *	swp:	sw_tolight[]
 *		sw_intensity[]  or msw_intensity[]
 *		sw_visible[]
 *		sw_lightfract[]
 *
 *	References
 *	ap:	a_resource
 *		a_rti_i->rti_tol
 *		a_rbeam
 *		a_diverge
 */
void
light_obs(struct application *ap, struct shadework *swp, int have)
{
    register struct light_specific *lsp;
    register int	i;
    register fastf_t *tl_p;
    int vis_ray;
    int tot_vis_rays;
    int visibility;
    struct light_obs_stuff los;
    static int rand_idx;
    int flag_size = 0;

    /* use a constant buffer to minimize number of malloc/free calls per ray */
    char static_flags[SOME_LIGHT_SAMPLES] = {0};
    char *flags = static_flags;

    if (rdebug & RDEBUG_LIGHT ) {
	bu_log("computing Light obscuration: start\n");
    }

    RT_CK_AP(ap);
    los.rand_idx = &rand_idx;
    los.ap = ap;
    los.swp = swp;

    /* find largest sampled light */
    for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
	if (lsp->lt_pt_count > flag_size) {
	    flag_size = lsp->lt_pt_count;
	}
    }
    if (flag_size > SOME_LIGHT_SAMPLES) {
	flags = (char *)bu_calloc(flag_size, sizeof(char), "callocate flags array");
    }

    /*
     *  Determine light visibility
     *
     *  The sw_intensity field does NOT include the light's
     *  emission spectrum (color), only path attenuation.
     *  sw_intensity=(1,1,1) for no attenuation.
     */
    tl_p = swp->sw_tolight;

    i = 0;
    for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
	RT_CK_LIGHT(lsp);

	if (rdebug & RDEBUG_LIGHT)
	    bu_log("computing for light %d\n", i);
	swp->sw_lightfract[i] = 0.0;

	if (lsp->lt_infinite || lsp->lt_shadows == 0) tot_vis_rays = 1;
	else			tot_vis_rays = lsp->lt_shadows;

	los.lsp = lsp;
#ifdef RT_MULTISPECTRAL
	if(swp->msw_intensity[i]) BN_CK_TABDATA(swp->msw_intensity[i]);
	los.inten = &swp->msw_intensity[i];
#else
	los.inten = &swp->sw_intensity[3*i];
#endif

	/* create a coordinate system about the light center
	 * with the hitpoint->light ray as one of the axes
	 */
	if (lsp->lt_infinite) {
	    VMOVE(los.to_light_center, lsp->lt_vec);
	} else {
	    VSUB2(los.to_light_center, lsp->lt_pos, swp->sw_hit.hit_point);
	}
	VUNITIZE(los.to_light_center);
	bn_vec_ortho( los.light_x, los.to_light_center);
	VCROSS(los.light_y, los.to_light_center, los.light_x);

	/*
	 *  If we have a normal, test against light direction
	 */
	if ((have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
	    if (VDOT(swp->sw_hit.hit_normal,
		     los.to_light_center)      < 0 ) {
		/* backfacing, opaque */
		if (rdebug & RDEBUG_LIGHT)
		    bu_log("norm backfacing, opaque surf:%s\n",
			   lsp->lt_name);
		continue;
	    }
	}

	visibility = 0;
	if (flag_size > 0) {
	    memset(flags, 0, flag_size * sizeof(char));
	}
	for (vis_ray = 0 ; vis_ray < tot_vis_rays ; vis_ray ++) {
	    int lv;
	    los.iter = vis_ray;

	    if (rdebug & RDEBUG_LIGHT)
		bu_log("----------vis_ray %d---------\n",
		       vis_ray);

	    switch (lv = light_vis(&los, flags)) {
	    case 1:
		/* remember the last ray that hit */
		VMOVE(tl_p, los.to_light_center);
		visibility++;
		break;
	    case -1:
		/* this is our clue to give up on
		 * this light source.
		 */
		VMOVE(tl_p, los.to_light_center);
		visibility = vis_ray = tot_vis_rays;
		break;
	    case 0:	/* light not visible */
		if (rdebug & RDEBUG_LIGHT)
		    bu_log("light not visible\n");
		break;
	    default:
		bu_log("light_vis = %d\n", lv);
	    }
	}
	if (visibility) {
	    swp->sw_visible[i] = lsp;
	    swp->sw_lightfract[i] =
		(fastf_t)visibility / (fastf_t)tot_vis_rays;
	} else {
	    swp->sw_visible[i] = (struct light_specific *)NULL;
	}

	/* Advance to next light */
	tl_p += 3;
	i++;
    }
    if (flags && flags != static_flags) {
	bu_free(flags, "free flags array");
    }

    if (rdebug & RDEBUG_LIGHT ) bu_log("computing Light obscruration: end\n");
}


/**
 * L I G H T _ M A K E R
 *
 * Special hook called by view_2init to build 1 or 3 debugging lights.
 */
void
light_maker(int num, mat_t v2m)
{
    register struct light_specific *lsp;
    register int i;
    vect_t	temp;
    vect_t	color;
    char	name[64];
#ifdef RT_MULTISPECTRAL
    float	fcolor[3];
#endif

    /* Determine the Light location(s) in view space */
    for( i=0; i<num; i++ )  {
	switch(i)  {
	case 0:
	    /* 0:  At left edge, 1/2 high */
	    VSET( color, 1,  1,  1 );	/* White */
	    VSET( temp, -1, 0, 1 );
	    break;

	case 1:
	    /* 1: At right edge, 1/2 high */
	    VSET( color,  1, 1, 1 );
	    VSET( temp, 1, 0, 1 );
	    break;

	case 2:
	    /* 2:  Behind, and overhead */
	    VSET( color, 1, 1,  1 );
	    VSET( temp, 0, 1, -0.5 );
	    break;

	default:
	    return;
	}

	if (rdebug & RDEBUG_LIGHT) {
	    /* debugging ascii plot commands drawing from point location to origin */
	    vect_t tmp;
	    static vect_t pt = {0.0, 0.0, 0.0};
	    MAT4X3PNT(tmp, v2m, temp); bu_log("C 0 255 255\nO %g %g %g\n", V3ARGS(tmp));
	    MAT4X3PNT(tmp, v2m, pt); bu_log("Q %g %g %g\n", V3ARGS(tmp));
	}

	BU_GETSTRUCT( lsp, light_specific );
	lsp->l.magic = LIGHT_MAGIC;

#ifdef RT_MULTISPECTRAL
	BN_GET_TABDATA(lsp->lt_spectrum, spectrum);
	VMOVE(fcolor, color);
	rt_spect_reflectance_rgb( lsp->lt_spectrum, fcolor );
	bn_tabdata_scale( lsp->lt_spectrum, lsp->lt_spectrum, 1000.0 );
#else
	VMOVE( lsp->lt_color, color );
#endif

	MAT4X3PNT( lsp->lt_pos, v2m, temp );
	VMOVE( lsp->lt_vec, lsp->lt_pos );
	VUNITIZE( lsp->lt_vec );

	sprintf(name, "Implicit light %d", i);
	lsp->lt_name = bu_strdup(name);

	/* XXX Is it bogus to set lt_aim? */
	VSET( lsp->lt_aim, 0, 0, -1 );	/* any direction: spherical */
	lsp->lt_intensity = 1.0;
	lsp->lt_radius = 0.1;		/* mm, "point" source */
	lsp->lt_visible = 0;		/* NOT explicitly modeled */
	lsp->lt_invisible = 1;		/* NOT explicitly modeled */
	lsp->lt_shadows = 0;		/* no shadows for speed */
	lsp->lt_angle = 180;		/* spherical emission */
	lsp->lt_cosangle = -1;		/* cos(180) */
	lsp->lt_infinite = 0;
	lsp->lt_rp = REGION_NULL;
	if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
	    BU_LIST_INIT( &(LightHead.l) );
	}
	BU_LIST_INSERT( &(LightHead.l), &(lsp->l) );
    }
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.31
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.30 2007/09/14 15:21:07 erikgreenwald Exp $ (ARL)";
d243 1
a243 1
    memcpy( &lsp->lt_sample_pts[ lsp->lt_pt_count++ ], p, sizeof( struct light_pt ) );
@


14.30
log
@removed trailing whitespace
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.29 2007/08/16 17:10:29 brlcad Exp $ (ARL)";
d40 1
a40 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.29
log
@the number of light sample points needs to be considerably bigger than the number of shadow rays otherwise we end up with sample patterns in the shadow.
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.28 2007/08/16 07:44:13 brlcad Exp $ (ARL)";
d161 1
a161 1
HIDDEN void 
d1844 1
a1844 1
	if (rdebug & RDEBUG_LIGHT) {  
@


14.28
log
@aha, finally realized what is going awry... since the samples were previously already allocated to the hard-coded max, the sample generator just used the slots as needed, keeping track of them with lt_pt_count as new ones were needed.  what that means, though, is that we need to ensure an allocation before ALL of the places that lt_pt_count is incremented since that is when we need/make a new point.  this (finally) fixes the crashes I was seeing when multiple shadow rays were requested and it actually makes sense why.  .. and now users can actually request ten thousand shadow rays if they really want it, and it'll actually work
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.27 2007/07/10 02:17:32 brlcad Exp $ (ARL)";
d504 1
d539 3
a541 1
    while ( lsp->lt_pt_count < SOME_LIGHT_SAMPLES ) {
@


14.27
log
@more cleanup, reorder based on call order, remove dead code, add comments
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.26 2007/07/09 17:35:45 brlcad Exp $ (ARL)";
a201 1

d203 2
a204 1
 * allocate a set of light point samples
d207 1
a207 5
light_pt_set(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
     /* structure description */
     /* struct member name */
     /* begining of structure */
     /* string containing value */
a208 3
    struct light_specific *lsp = (struct light_specific *)base;
    fastf_t *p = (fastf_t *)(base+sdp->sp_offset);

d211 1
a211 1
	if (lsp->lt_pt_count == 0) {
d221 16
d246 1
d415 1
d454 1
a538 1

@


14.26
log
@general cleanup
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.25 2007/07/02 05:02:09 brlcad Exp $ (ARL)";
d80 7
d98 2
a122 1
    {"%d",  1, "invisible",	LIGHT_O(lt_invisible),	light_cvt_visible },
d125 2
a131 4
struct mfuncs light_mfuncs[] = {
    {MF_MAGIC,	"light",	0,		MFI_NORMAL,	0,     light_setup,	light_render,	light_print,	light_free },
    {0,		(char *)0,	0,		0,		0,     0,		0,		0,		0 }
};
d246 1
a246 1
 *			L I G H T _ R E N D E R
d248 7
a254 7
 *  If we have a direct view of the light, return it's color.
 *  A cosine term is needed in the shading of the light source,
 *  to make it have dimension and shape.  However, just a simple
 *  cosine of the angle between the normal and the direction vector
 *  leads to a pretty dim looking light.  Therefore, a cos/2 + 0.5
 *  term is used when the viewer is within the beam, and a cos/2 term
 *  when the beam points away.
d299 67
a365 1
 * When shooting grids of rays to generate the points on the light, we
d369 1
a369 1
gen_hit(register struct application *ap, struct partition *PartHeadp, struct seg *sp)
d466 3
a468 2
 * When shooting the grids for building light pts, if we miss the
 * light then do nothing.
d471 1
a471 1
gen_miss(register struct application *ap)
a476 137
#if 0
/**
 *  Shoot rays in each of the axis directions looking for hit points
 *  on a light.
 */
static void
shoot_grids(struct application *ap,
	    vect_t step,
	    point_t tree_min,
	    point_t tree_max)
{
    double x, y, z;
    struct light_specific *lsp = (struct light_specific *)ap->a_uptr;

    if (rdebug & RDEBUG_LIGHT )
	bu_log("shoot_grids Z, step=(%g, %g, %g)\n", V3ARGS(step) );

    /* shoot through the X,Y plane */
#define MIN_GRID_STEP_MM	0.1		/* had been 10.0 */

    if (step[Y] > MIN_GRID_STEP_MM && step[X] > MIN_GRID_STEP_MM) {
	z = tree_min[Z];

	VSET(ap->a_ray.r_dir, 0.0, 0.0, 1.0);
	z = tree_min[Z];

	for (y = tree_min[Y] + step[Y] * 0.5;
	     y < tree_max[Y] ; y += step[Y])

	    for (x = tree_min[X] + step[X] * 0.5;
		 x < tree_max[X] ; x += step[X]) {
		VSET(ap->a_ray.r_pt, x, y, z);
		(void)rt_shootray( ap );
	    }
    }

    if (rdebug & RDEBUG_LIGHT )
	bu_log("shoot_grids Y\n");

    /* shoot through the X, Z plane */
    if (step[Z] > MIN_GRID_STEP_MM && step[X] > MIN_GRID_STEP_MM) {
	y = tree_min[Y];

	VSET(ap->a_ray.r_dir, 0.0, 1.0, 0.0);
	z = tree_min[Z];

	for (z = tree_min[Z] + step[Z] * 0.5;
	     z < tree_max[Z] ; z += step[Z])

	    for (x = tree_min[X] + step[X] * 0.5;
		 x < tree_max[X] ; x += step[X]) {
		VSET(ap->a_ray.r_pt, x, y, z);
		(void)rt_shootray( ap );
	    }
    }

    /* shoot through the Y, Z plane */
    if (rdebug & RDEBUG_LIGHT )
	bu_log("shoot_grids X\n");
    if (step[Z] > MIN_GRID_STEP_MM && step[Y] > MIN_GRID_STEP_MM) {
	VSET(ap->a_ray.r_dir, 1.0, 0.0, 0.0);
	x = tree_min[X];

	for (z = tree_min[Z] + step[Z] * 0.5;
	     z < tree_max[Z] ; z += step[Z])

	    for (y = tree_min[Y] + step[Y] * 0.5;
		 y < tree_max[Y] ; y += step[Y]) {
		VSET(ap->a_ray.r_pt, x, y, z);
		(void)rt_shootray( ap );
	    }
    }

}
#endif

static void
ray_setup(struct application *ap,
	  point_t tree_min,
	  point_t tree_max,
	  point_t span)
{
    int face;
    point_t pt;
    static int idx = 0;

    /* pick a face of the bounding RPP at which we will start the ray */
    face = BN_RANDOM(idx) * 2.9999;

    switch (face) {
    case 0: /* XMIN */
	VSET(ap->a_ray.r_pt,
	     tree_min[X] - 10.0,
	     tree_min[Y] + BN_RANDOM(idx) * span[Y],
	     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
	VSET(pt,
	     tree_max[X],
	     tree_min[Y] + BN_RANDOM(idx) * span[Y],
	     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
	break;

    case 1: /* YMIN */
	VSET(ap->a_ray.r_pt,
	     tree_min[X] + BN_RANDOM(idx) * span[X],
	     tree_min[Y] - 10.0,
	     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
	VSET(pt,
	     tree_min[X] + BN_RANDOM(idx) * span[X],
	     tree_max[Y],
	     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
	break;

    case 2: /* ZMIN */
	VSET(ap->a_ray.r_pt,
	     tree_min[X] +
	     BN_RANDOM(idx) * span[X],

	     tree_min[Y] +
	     BN_RANDOM(idx) * span[Y],

	     tree_min[Z] - 10.0);
	VSET(pt,
	     tree_min[X] +
	     BN_RANDOM(idx) * span[X],

	     tree_min[Y] +
	     BN_RANDOM(idx) * span[Y],

	     tree_max[Z]);
	break;
    }
    VSUB2(ap->a_ray.r_dir, pt, ap->a_ray.r_pt);
    VUNITIZE(ap->a_ray.r_dir);

}


d481 2
a482 1
 * surface normals.
d502 2
a503 2
    ap.a_hit = gen_hit;
    ap.a_miss = gen_miss;
d531 4
a534 1
#if 0
d550 32
a581 1
#endif
d607 5
a611 5
    lsp->lt_fraction = -1.0;		/* Recomputed later */
    lsp->lt_visible = 1;		/* explicitly modeled */
    lsp->lt_invisible = 0;		/* explicitly modeled */
    lsp->lt_shadows = 1;		/* by default, casts shadows */
    lsp->lt_angle = 180;		/* spherical emission by default */
d646 1
a735 119
 *			L I G H T _ P R I N T
 */
HIDDEN void
light_print(register struct region *rp, char *dp)
{
    bu_struct_print(rp->reg_name, light_print_tab, (char *)dp);
}


/**
 *			L I G H T _ F R E E
 */
void
light_free(char *cp)
{
    register struct light_specific *lsp = (struct light_specific *)cp;

    RT_CK_LIGHT(lsp);
    BU_LIST_DEQUEUE( &(lsp->l) );
    if (lsp->lt_name )  {
	bu_free( lsp->lt_name, "light name" );
	lsp->lt_name = (char *)0;
    }
    if (lsp->lt_sample_pts) {
	bu_free(lsp->lt_sample_pts, "free light samples array");
    }
    lsp->l.magic = 0;	/* sanity */
    bu_free( (char *)lsp, "light_specific" );
}


/**
 *			L I G H T _ M A K E R
 *
 *  Special hook called by view_2init to build 1 or 3 debugging lights.
 */
void
light_maker(int num, mat_t v2m)
{
    register struct light_specific *lsp;
    register int i;
    vect_t	temp;
    vect_t	color;
    char	name[64];
#ifdef RT_MULTISPECTRAL
    float	fcolor[3];
#endif
    /* Determine the Light location(s) in view space */
    for( i=0; i<num; i++ )  {
	switch(i)  {
	case 0:
	    /* 0:  At left edge, 1/2 high */
	    VSET( color, 1,  1,  1 );	/* White */
	    VSET( temp, -1, 0, 1 );
	    break;

	case 1:
	    /* 1: At right edge, 1/2 high */
	    VSET( color,  1, 1, 1 );
	    VSET( temp, 1, 0, 1 );
	    break;

	case 2:
	    /* 2:  Behind, and overhead */
	    VSET( color, 1, 1,  1 );
	    VSET( temp, 0, 1, -0.5 );
	    break;

	default:
	    return;
	}
#if 0
	{  /* debugging ascii plot commands drawing from point location to origin */
	    vect_t tmp;
	    static vect_t pt = {0.0, 0.0, 0.0};
	    MAT4X3PNT(tmp, v2m, temp); bu_log("C 0 255 255\nO %g %g %g\n", V3ARGS(tmp));
	    MAT4X3PNT(tmp, v2m, pt); bu_log("Q %g %g %g\n", V3ARGS(tmp));
	}
#endif

	BU_GETSTRUCT( lsp, light_specific );
	lsp->l.magic = LIGHT_MAGIC;

#ifdef RT_MULTISPECTRAL
	BN_GET_TABDATA(lsp->lt_spectrum, spectrum);
	VMOVE(fcolor, color);
	rt_spect_reflectance_rgb( lsp->lt_spectrum, fcolor );
	bn_tabdata_scale( lsp->lt_spectrum, lsp->lt_spectrum, 1000.0 );
#else
	VMOVE( lsp->lt_color, color );
#endif

	MAT4X3PNT( lsp->lt_pos, v2m, temp );
	VMOVE( lsp->lt_vec, lsp->lt_pos );
	VUNITIZE( lsp->lt_vec );

	sprintf(name, "Implicit light %d", i);
	lsp->lt_name = bu_strdup(name);

	/* XXX Is it bogus to set lt_aim? */
	VSET( lsp->lt_aim, 0, 0, -1 );	/* any direction: spherical */
	lsp->lt_intensity = 1.0;
	lsp->lt_radius = 0.1;		/* mm, "point" source */
	lsp->lt_visible = 0;		/* NOT explicitly modeled */
	lsp->lt_invisible = 1;		/* NOT explicitly modeled */
	lsp->lt_shadows = 0;		/* no shadows for speed */
	lsp->lt_angle = 180;		/* spherical emission */
	lsp->lt_cosangle = -1;		/* cos(180) */
	lsp->lt_infinite = 0;
	lsp->lt_rp = REGION_NULL;
	if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
	    BU_LIST_INIT( &(LightHead.l) );
	}
	BU_LIST_INSERT( &(LightHead.l), &(lsp->l) );
    }
}


/**
d1283 1
a1283 1
 *	light_vis
d1285 2
a1286 1
 *	Compute 1 light visibility ray from a hit point to the light.
d1627 1
a1627 1
 *			L I G H T _ O B S C U R A T I O N
d1788 88
@


14.25
log
@doxygenify, check for null dereferencing
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.24 2007/01/27 01:41:37 brlcad Exp $ (ARL)";
a60 6
#if !defined(M_PI)
#define M_PI            3.14159265358979323846
#define	M_PI_2		1.57079632679489661923
#endif


a63 2
BU_EXTERN(void	aim_set, (const struct bu_structparse *sdp, const char *name,
			  const char *base, char *value));
d65 2
a66 13
/**
 *  light_cvt_visible()
 *
 *  Convert "visible" flag to "invisible" variable
 */
void
light_cvt_visible(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
     /* structure description */
     /* struct member name */
     /* begining of structure */
     /* string containing value */
{
    struct light_specific *lsp = (struct light_specific *)base;
a67 15
    if (rdebug & RDEBUG_LIGHT) {
	bu_log("light_cvt_visible(%s, %d)\n", name, sdp->sp_offset);
	bu_log("visible: %d invisible: %d\n",
	       LIGHT_O(lt_visible),
	       LIGHT_O(lt_invisible));
    }
    switch (sdp->sp_offset) {
    case LIGHT_O(lt_invisible):
	lsp->lt_visible = !lsp->lt_invisible;
	break;
    case LIGHT_O(lt_visible):
	lsp->lt_invisible = !lsp->lt_visible;
	break;
    }
}
d69 9
a77 12
/**
 * allocate a set of light point samples
 */
static void
light_pt_set(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
     /* structure description */
     /* struct member name */
     /* begining of structure */
     /* string containing value */
{
    struct light_specific *lsp = (struct light_specific *)base;
    fastf_t *p = (fastf_t *)(base+sdp->sp_offset);
a78 27
    /* make sure we have enough room, allocate in batches of SOME_LIGHT_SAMPLES */
    if ( lsp->lt_pt_count % SOME_LIGHT_SAMPLES == 0) {
	if (lsp->lt_pt_count == 0) {
	    /* assumes initialized to NULL */
	    if (lsp->lt_sample_pts) {
		bu_free(lsp->lt_sample_pts, "free light samples array");
	    }
	    lsp->lt_sample_pts = (struct light_pt *)bu_calloc(lsp->lt_pt_count + SOME_LIGHT_SAMPLES, sizeof(struct light_pt), "callocate light sample points");
	} else {
	    lsp->lt_sample_pts = (struct light_pt *)bu_realloc(lsp->lt_sample_pts, (lsp->lt_pt_count + SOME_LIGHT_SAMPLES) * sizeof(struct light_pt), "reallocate light sample points");
	}
    }

    if (! strcmp("pt", name) ) {
	/* user just specified point, set normal to zeros */
	p[3] = p[4] = p[5] = 0.0;
    } else if ( strcmp("pn", name) ) {
	bu_log("*********** unknown option in light_pt_set %s:%d\n", __FILE__, __LINE__);
	return;
    }

    memcpy( &lsp->lt_sample_pts[ lsp->lt_pt_count++ ], p, sizeof( struct light_pt ) );

    if (rdebug & RDEBUG_LIGHT ) {
	bu_log("set light point %g %g %g   N %g %g %g\n", p[0], p[1], p[2], p[3], p[4], p[5]);
    }
}
a121 9


struct light_specific	LightHead;	/* Heads linked list of lights */


HIDDEN int	light_setup(register struct region *rp, struct bu_vls *matparm, genptr_t *dpp, struct mfuncs *mfp, struct rt_i *rtip), light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
HIDDEN void	light_print(register struct region *rp, char *dp);
void		light_free(char *cp);

d123 2
a124 4
    {MF_MAGIC,	"light",	0,		MFI_NORMAL,	0,
     light_setup,	light_render,	light_print,	light_free },
    {0,		(char *)0,	0,		0,		0,
     0,		0,		0,		0 }
a126 1

d155 2
a156 2

HIDDEN void aim_set (const struct bu_structparse *sdp, const char *name, const char *base, char *value)
d165 74
d297 1
a297 3
gen_hit(register struct application *ap,
	struct partition	    *PartHeadp,
	struct seg		    *sp)
d394 2
a395 2
 * When shooting the grids for building light pts, if we miss the light just
 * return;
d479 1
d624 1
a624 1
	    struct rt_i            *rtip)  /* New since 4.4 release */
d846 1
a847 1

a851 1

d855 1
d1044 6
a1049 1
    extern int	light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
a1054 4
    int	light_visible = 0;
    int	air_sols_seen = 0;
    int 	is_proc;
    char	*reason = "???";
d1437 1
a1513 1
#define COSINE89_99DEG 0.0001745329
d1525 2
a1526 2
	    if ( VisRayvsLightN > COSINE89_99DEG &&
		   VisRayvsSurfN > COSINE89_99DEG ) {
d1537 1
a1537 1
#undef COSINE89DEG
a1628 1

a1634 1

a1647 1

d1666 1
d1760 1
d1763 1
@


14.24
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.23 2007/01/23 01:13:36 brlcad Exp $ (ARL)";
d73 1
a73 2
/***********************************************************************
 *
d103 2
a104 2
/*
 *
d203 1
a203 1
/*
d225 1
a225 1
/*
d241 1
a241 1
/*
d293 2
a294 1
/*
a296 1
 *
d308 2
d336 6
a341 1
	lpt = &lsp->lt_sample_pts[lsp->lt_pt_count++];
d345 4
d374 6
a379 1
	lpt = &lsp->lt_sample_pts[lsp->lt_pt_count++];
d383 4
d396 2
a397 1
/*
d407 1
d409 1
a409 2
/*
 *
d544 2
a545 1
/*	L I G H T _ G E N _ S A M P L E _ P T S
d547 2
a548 2
 *  Generate a set of sample points on the surface of the light with surface
 *  normals.
a574 1

a579 1

d616 2
a617 1
/*
d765 2
a766 1
/*
d775 2
a776 1
/*
d797 2
a798 1
/*
d884 2
a885 1
/*
d984 1
a984 1
/*
d1013 3
a1015 2
/**********************************************************************/
/*
a1038 1

d1396 2
a1397 1
/*
a1402 1
/* ARGSUSED */
d1428 1
d1431 1
a1431 2
/***********************************************************************
 *
a1434 1
 *
d1773 2
a1774 1
/*
@


14.23
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.22 2007/01/20 14:36:53 brlcad Exp $ (ARL)";
a1118 1

a1658 1

@


14.22
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d33 1
a33 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.21 2006/08/08 22:06:45 brlcad Exp $ (ARL)";
@


14.21
log
@final mod to allow for arbitrary counts of light point samples.  the point sample array is allocated in batches of SOME_LIGHT_SAMPLES.
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2006 United States Government as represented by
d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.20 2006/08/08 18:28:29 brlcad Exp $ (ARL)";
@


14.20
log
@next step in the incremental update, dynamically allocate the light sample points array instead of using a fixed size.
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.19 2006/08/08 18:02:20 brlcad Exp $ (ARL)";
d118 12
a129 1
    if ( lsp->lt_pt_count >= SOME_LIGHT_SAMPLES ) return;
d135 1
a135 2
	bu_log("*********** unknown option in light_pt_set %s:%d\n",
	       __FILE__, __LINE__);
d139 1
a139 2
    memcpy( &lsp->lt_sample_pts[ lsp->lt_pt_count++ ], p,
	    sizeof( struct light_pt ) );
d141 1
a141 1
    if (rdebug & RDEBUG_LIGHT )
d143 1
a143 1

a345 2
	if (lsp->lt_pt_count >= SOME_LIGHT_SAMPLES) return 1;

a373 3

	if (lsp->lt_pt_count >= SOME_LIGHT_SAMPLES) return 1;

a421 2
		if (lsp->lt_pt_count >= SOME_LIGHT_SAMPLES)
		    return;
a441 2
		if (lsp->lt_pt_count >= SOME_LIGHT_SAMPLES)
		    return;
a458 2
		if (lsp->lt_pt_count >= SOME_LIGHT_SAMPLES)
		    return;
d629 1
a629 1
    lsp->lt_sample_pts = (struct light_pt *)bu_calloc(SOME_LIGHT_SAMPLES, sizeof(struct light_pt), "callocate light samples array");
d1783 1
a1783 1
    char flags[SOME_LIGHT_SAMPLES] = {0};
d1785 5
a1789 1
    if (rdebug & RDEBUG_LIGHT )
d1791 1
d1798 10
d1863 3
a1865 1
	memset(flags, 0, sizeof(flags));
d1907 3
@


14.19
log
@incremental update this time.. change MAX_LIGHT_SAMPLES to SOME_LIGHT_SAMPLES
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.18 2006/08/07 10:16:30 brlcad Exp $ (ARL)";
d631 1
a631 1
    memset(lsp->lt_sample_pts, 0, sizeof(lsp->lt_sample_pts));
d635 1
a635 1
	bu_free( (char *)lsp, "light_specific" );
d771 3
@


14.18
log
@revert the unlimited lights change briefly until it is determined why they are not working for area light sources
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.16 2006/04/06 20:06:47 brlcad Exp $ (ARL)";
d118 1
a118 1
    if ( lsp->lt_pt_count >= MAX_LIGHT_SAMPLES ) return;
d337 1
a337 1
	if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES) return 1;
d368 1
a368 1
	if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES) return 1;
d418 1
a418 1
		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
d440 1
a440 1
		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
d459 1
a459 1
		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
d576 1
a576 1
    while ( lsp->lt_pt_count < MAX_LIGHT_SAMPLES ) {
d1782 1
a1782 1
    char flags[MAX_LIGHT_SAMPLES] = {0};
@


14.17
log
@allow unlimited light samples during ray-tracing instead of a fixed compile-time count (was 128)
@
text
@d118 1
a118 6
    if ( lsp->lt_pt_count == 0 || !lsp->lt_sample_pts) {
	lsp->lt_pt_count = 0;
	lsp->lt_sample_pts = (struct light_pt *)bu_malloc(sizeof(struct light_pt) * SOME_LIGHT_POINTS, "allocate some light points");
    } else if ( lsp->lt_pt_count % SOME_LIGHT_POINTS == 0 ) {
	lsp->lt_sample_pts = (struct light_pt *)bu_realloc(lsp->lt_sample_pts, sizeof(struct light_pt) * (lsp->lt_pt_count + SOME_LIGHT_POINTS), "reallocate some light points");
    }
d124 2
a125 1
	bu_log("*********** unknown option in light_pt_set %s:%d\n", __FILE__, __LINE__);
d129 4
a132 3
    memcpy( &lsp->lt_sample_pts[ lsp->lt_pt_count++ ], p, sizeof( struct light_pt ) );
    
    if (rdebug & RDEBUG_LIGHT ) {
a133 1
    }
a134 1
    return;
d337 1
a337 6
	if ( lsp->lt_pt_count == 0 || !lsp->lt_sample_pts) {
	    lsp->lt_pt_count = 0;
	    lsp->lt_sample_pts = (struct light_pt *)bu_malloc(sizeof(struct light_pt) * SOME_LIGHT_POINTS, "allocate some light points");
	} else if ( lsp->lt_pt_count % SOME_LIGHT_POINTS == 0 ) {
	    lsp->lt_sample_pts = (struct light_pt *)bu_realloc(lsp->lt_sample_pts, sizeof(struct light_pt) * (lsp->lt_pt_count + SOME_LIGHT_POINTS), "reallocate some light points");
	}
d368 2
a369 6
	if ( lsp->lt_pt_count == 0 || !lsp->lt_sample_pts) {
	    lsp->lt_pt_count = 0;
	    lsp->lt_sample_pts = (struct light_pt *)bu_malloc(sizeof(struct light_pt) * SOME_LIGHT_POINTS, "allocate some light points");
	} else if ( lsp->lt_pt_count % SOME_LIGHT_POINTS == 0 ) {
	    lsp->lt_sample_pts = (struct light_pt *)bu_realloc(lsp->lt_sample_pts, sizeof(struct light_pt) * (lsp->lt_pt_count + SOME_LIGHT_POINTS), "reallocate some light points");
	}
a383 1

d411 5
a415 2
	for (y = tree_min[Y] + step[Y] * 0.5; y < tree_max[Y]; y += step[Y]) {
	    for (x = tree_min[X] + step[X] * 0.5; x < tree_max[X]; x += step[X]) {
d418 2
a419 7
		
		if ( lsp->lt_pt_count == 0 || !lsp->lt_sample_pts) {
		    lsp->lt_pt_count = 0;
		    lsp->lt_sample_pts = (struct light_pt *)bu_malloc(sizeof(struct light_pt) * SOME_LIGHT_POINTS, "allocate some light points");
		} else if ( lsp->lt_pt_count % SOME_LIGHT_POINTS == 0 ) {
		    lsp->lt_sample_pts = (struct light_pt *)bu_realloc(lsp->lt_sample_pts, sizeof(struct light_pt) * (lsp->lt_pt_count + SOME_LIGHT_POINTS), "reallocate some light points");
		}
a420 1
	}
d433 5
a437 2
	for (z = tree_min[Z] + step[Z] * 0.5; z < tree_max[Z]; z += step[Z]) {
	    for (x = tree_min[X] + step[X] * 0.5; x < tree_max[X]; x += step[X]) {
d440 2
a441 6
		if ( lsp->lt_pt_count == 0 || !lsp->lt_sample_pts) {
		    lsp->lt_pt_count = 0;
		    lsp->lt_sample_pts = (struct light_pt *)bu_malloc(sizeof(struct light_pt) * SOME_LIGHT_POINTS, "allocate some light points");
		} else if ( lsp->lt_pt_count % SOME_LIGHT_POINTS == 0 ) {
		    lsp->lt_sample_pts = (struct light_pt *)bu_realloc(lsp->lt_sample_pts, sizeof(struct light_pt) * (lsp->lt_pt_count + SOME_LIGHT_POINTS), "reallocate some light points");
		}
a442 1
	}
d452 5
a456 2
	for (z = tree_min[Z] + step[Z] * 0.5; z < tree_max[Z]; z += step[Z]) {
	    for (y = tree_min[Y] + step[Y] * 0.5; y < tree_max[Y]; y += step[Y]) {
d459 2
a460 6
		if ( lsp->lt_pt_count == 0 || !lsp->lt_sample_pts) {
		    lsp->lt_pt_count = 0;
		    lsp->lt_sample_pts = (struct light_pt *)bu_malloc(sizeof(struct light_pt) * SOME_LIGHT_POINTS, "allocate some light points");
		} else if ( lsp->lt_pt_count % SOME_LIGHT_POINTS == 0 ) {
		    lsp->lt_sample_pts = (struct light_pt *)bu_realloc(lsp->lt_sample_pts, sizeof(struct light_pt) * (lsp->lt_pt_count + SOME_LIGHT_POINTS), "reallocate some light points");
		}
a461 1
	}
d576 2
a577 2
    /* take a few samples treating as an area light */
    while ( lsp->lt_pt_count < SOME_LIGHT_POINTS ) {
a580 1

a597 1

d631 1
a631 1
    lsp->lt_sample_pts = (struct light_pt *)NULL;
a770 6

    /* done with the light points */
    if ((lsp->lt_pt_count > 0) && lsp->lt_sample_pts) {
	bu_free(lsp->lt_sample_pts, "free sample points");
    }

d1415 1
a1415 1
light_vis(struct light_obs_stuff *los)
a1430 1
    char *flags = (char *)NULL;
a1433 8
    /* allocate our flags array based on the number of points */
    if (los->lsp->lt_pt_count > 0) {
	flags = (char *)bu_calloc(los->lsp->lt_pt_count, sizeof(char *), "allocating flags");
    } else {
	/* just so free code works */
	flags = (char *)bu_calloc(SOME_LIGHT_POINTS, sizeof(char *), "allocating flags");
    }

a1556 1
	bu_free(flags, "free of flags array");
a1557 1

d1637 3
a1639 4
	if (rdebug & RDEBUG_LIGHT) {
	    bu_log("point outside beam, obscured: %s\n", los->lsp->lt_name);
	}
	bu_free(flags, "free of flags array");
d1646 3
a1648 4
	if (rdebug & RDEBUG_LIGHT) {
	    bu_log("fill light, no shadow, visible: %s\n", los->lsp->lt_name);
	}

a1655 1
	bu_free(flags, "free of flags array");
a1721 5
    /* conceivably, we are done with the flags array now.  no more
     * potential jumps back up to the top.
     */
    bu_free(flags, "free of flags array");

d1782 1
d1847 1
d1856 1
a1856 1
	    switch (lv = light_vis(&los)) {
@


14.16
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.15 2006/01/23 00:35:08 brlcad Exp $ (ARL)";
d118 6
a123 1
    if ( lsp->lt_pt_count >= MAX_LIGHT_SAMPLES ) return;
d129 1
a129 2
	bu_log("*********** unknown option in light_pt_set %s:%d\n",
	       __FILE__, __LINE__);
d133 3
a135 4
    memcpy( &lsp->lt_sample_pts[ lsp->lt_pt_count++ ], p,
	    sizeof( struct light_pt ) );

    if (rdebug & RDEBUG_LIGHT )
d137 1
d139 1
d342 6
a347 1
	if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES) return 1;
d378 6
a383 2
	if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES) return 1;

d398 1
d426 2
a427 5
	for (y = tree_min[Y] + step[Y] * 0.5;
	     y < tree_max[Y] ; y += step[Y])

	    for (x = tree_min[X] + step[X] * 0.5;
		 x < tree_max[X] ; x += step[X]) {
d430 7
a436 2
		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
		    return;
d438 1
d451 2
a452 5
	for (z = tree_min[Z] + step[Z] * 0.5;
	     z < tree_max[Z] ; z += step[Z])

	    for (x = tree_min[X] + step[X] * 0.5;
		 x < tree_max[X] ; x += step[X]) {
d455 6
a460 2
		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
		    return;
d462 1
d472 2
a473 5
	for (z = tree_min[Z] + step[Z] * 0.5;
	     z < tree_max[Z] ; z += step[Z])

	    for (y = tree_min[Y] + step[Y] * 0.5;
		 y < tree_max[Y] ; y += step[Y]) {
d476 6
a481 2
		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
		    return;
d483 1
d598 2
a599 2
    while ( lsp->lt_pt_count < MAX_LIGHT_SAMPLES ) {

d603 1
d621 1
d655 1
a655 1
    memset(lsp->lt_sample_pts, 0, sizeof(lsp->lt_sample_pts));
d795 6
d1445 1
a1445 1
light_vis(struct light_obs_stuff *los, char *flags)
d1461 1
d1465 8
d1596 1
d1598 1
d1678 4
a1681 3
	if (rdebug & RDEBUG_LIGHT)
	    bu_log("point outside beam, obscured: %s\n",
		   los->lsp->lt_name);
d1688 4
a1691 3
	if (rdebug & RDEBUG_LIGHT)
	    bu_log("fill light, no shadow, visible: %s\n",
		   los->lsp->lt_name);
d1699 1
d1766 5
a1830 1
    char flags[MAX_LIGHT_SAMPLES] = {0};
a1894 1
	memset(flags, 0, sizeof(flags));
d1903 1
a1903 1
	    switch (lv = light_vis(&los, flags)) {
@


14.15
log
@include stddef.h for bu_offset's usage of offset
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.14 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d57 1
@


14.15.2.1
log
@update from HEAD
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.15 2006/01/23 00:35:08 brlcad Exp $ (ARL)";
a56 1
#  include "spectrum.h"
@


14.14
log
@update copyright to 2006
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.13 2005/10/23 04:44:34 brlcad Exp $ (ARL)";
d39 1
d43 2
d67 1
a67 1
#define LIGHT_O(m)	offsetof(struct light_specific, m)
@


14.13
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1998-2005 United States Government as represented by
d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.12 2005/09/19 21:14:08 brlcad Exp $ (ARL)";
@


14.12
log
@s/RT_EXTERN/BU_EXTERN/
@
text
@d28 1
a28 1
 *  
d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.11 2005/09/19 18:57:48 brlcad Exp $ (ARL)";
d74 1
a74 1
 *  Convert "visible" flag to "invisible" variable 
d87 1
a87 1
	bu_log("visible: %d invisible: %d\n", 
d309 1
a309 1
	    delta = prev->pt_outhit->hit_dist - 
d320 1
a320 1
	/* The inbound point is not against another object, so 
d327 1
a327 1
	VJOIN1( lpt->lp_pt, ap->a_ray.r_pt, 
d330 1
a330 1
	RT_HIT_NORMAL( lpt->lp_norm, pp->pt_inhit, stp, 
d341 1
a341 1
	    delta = next->pt_inhit->hit_dist - 
d358 1
a358 1
	VJOIN1( lpt->lp_pt, ap->a_ray.r_pt, 
d361 1
a361 1
	RT_HIT_NORMAL( lpt->lp_norm, pp->pt_outhit, stp, 
d365 1
a365 1
 
d462 1
a462 1
static void 
d478 1
a478 1
	     tree_min[X] - 10.0, 
d482 1
a482 1
	     tree_max[X], 
d500 1
a500 1
	     tree_min[X] + 
d503 1
a503 1
	     tree_min[Y] + 
d508 1
a508 1
	     tree_min[X] + 
d511 1
a511 1
	     tree_min[Y] + 
d555 1
a555 1
	bu_log("\tlight bb (%g %g %g), (%g %g %g)\n", 
d701 1
a701 1
	/* XXX Need to convert units of lumens (candela-sr) to ?? 
d908 1
a908 1
    /* 
d986 1
a986 1
/* 
d1003 1
a1003 1
 * 
d1031 1
a1031 1
    
d1062 1
a1062 1
    /*XXX Bogus with Air.  We should check to see if it is the same 
d1140 1
a1140 1
	    /* XXXXXXX This seems to happen with *every* 
d1330 1
a1330 1
    if (rdebug&RDEBUG_LIGHT) 
d1334 1
a1334 1
    if (rdebug&RDEBUG_LIGHT) 
d1371 1
a1371 1
 *  
d1410 1
a1410 1
static int 
d1416 1
a1416 1
    double cos_angle, x, y; 
d1442 1
a1442 1
	 * inter-visibility, then shoot at that point 
d1445 1
a1445 1
	idx = los->lsp->lt_pt_count * 
d1452 1
a1452 1
	for (k=idx ; ((k+1) % los->lsp->lt_pt_count) != idx ; 
d1505 1
a1505 1
		if (rdebug & RDEBUG_LIGHT ) 
d1537 1
a1537 1
		tryagain = 1; 
d1547 1
a1547 1
	/* at this point, we have no candidate points available to 
d1558 1
a1558 1
		
d1561 1
a1561 1
	if (rdebug & RDEBUG_LIGHT ) 
d1564 1
a1564 1
	 * sphere for the light source.  We pick a point on the 
d1566 1
a1566 1
	 * angle.  This is done by picking random radius and angle 
d1569 1
a1569 1
	radius = los->lsp->lt_radius * 
d1571 1
a1571 1
	    fabs(bn_rand_half(los->ap->a_resource->re_randptr) 
d1573 1
a1573 1
	angle =  M_PI * 2.0 * 
d1590 1
a1590 1
	VJOIN2(shoot_pt, los->lsp->lt_pos, 
d1595 2
a1596 2
	    bu_log("light at (%g %g %g) radius %g\n", 
		   V3ARGS(los->lsp->lt_pos), 
d1669 1
a1669 1
	VJOIN1( sub_ap.a_ray.r_pt, los->swp->sw_hit.hit_point, f, 
d1672 2
a1673 2
    sub_ap.a_rbeam = los->ap->a_rbeam + 
	los->swp->sw_hit.hit_dist * 
d1755 1
a1755 1
 *	Sets 
@


14.11
log
@if the partition list is empty, break out early; sw_visible is a light_specific now
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.10 2005/03/30 07:14:09 brlcad Exp $ (ARL)";
d67 1
a67 1
RT_EXTERN(void	aim_set, (const struct bu_structparse *sdp, const char *name,
@


14.10
log
@consistency on the #ifdef inclusions of RT_MULTISPECTRAL, clean up the spectrum extern declarations now that spectrum is now a liboptical global.
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.9 2005/03/28 06:31:28 bob1961 Exp $ (ARL)";
a38 2


d41 1
a41 1
# include <string.h>
d44 1
d1025 1
a1025 1
    int	light_visible;
d1030 2
d1053 9
d1778 1
a1778 1
    char flags[MAX_LIGHT_SAMPLES];
d1874 1
a1874 1
	    swp->sw_visible[i] = (char *)lsp;
d1878 1
a1878 1
	    swp->sw_visible[i] = (char *)0;
@


14.10.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header$ (ARL)";
d39 2
d43 1
a43 1
#  include <string.h>
a45 1

d68 1
a68 1
BU_EXTERN(void	aim_set, (const struct bu_structparse *sdp, const char *name,
d75 1
a75 1
 *  Convert "visible" flag to "invisible" variable
d88 1
a88 1
	bu_log("visible: %d invisible: %d\n",
d310 1
a310 1
	    delta = prev->pt_outhit->hit_dist -
d321 1
a321 1
	/* The inbound point is not against another object, so
d328 1
a328 1
	VJOIN1( lpt->lp_pt, ap->a_ray.r_pt,
d331 1
a331 1
	RT_HIT_NORMAL( lpt->lp_norm, pp->pt_inhit, stp,
d342 1
a342 1
	    delta = next->pt_inhit->hit_dist -
d359 1
a359 1
	VJOIN1( lpt->lp_pt, ap->a_ray.r_pt,
d362 1
a362 1
	RT_HIT_NORMAL( lpt->lp_norm, pp->pt_outhit, stp,
d366 1
a366 1

d463 1
a463 1
static void
d479 1
a479 1
	     tree_min[X] - 10.0,
d483 1
a483 1
	     tree_max[X],
d501 1
a501 1
	     tree_min[X] +
d504 1
a504 1
	     tree_min[Y] +
d509 1
a509 1
	     tree_min[X] +
d512 1
a512 1
	     tree_min[Y] +
d556 1
a556 1
	bu_log("\tlight bb (%g %g %g), (%g %g %g)\n",
d702 1
a702 1
	/* XXX Need to convert units of lumens (candela-sr) to ??
d909 1
a909 1
    /*
d987 1
a987 1
/*
d1004 1
a1004 1
 *
d1026 1
a1026 1
    int	light_visible = 0;
a1030 2
    RT_CK_PT_HD(PartHeadp);

d1052 1
a1052 10

    /* anything to do? */
    if (PartHeadp->pt_forw == PartHeadp) {
	bu_log("light_hit:  ERROR, EMPTY PARTITION sxy=(%d, %d)\n", ap->a_x, ap->a_y);
	light_visible = 0;
	reason = "ERROR: EMPTY PARTITION";
	goto out;
    }

    /*XXX Bogus with Air.  We should check to see if it is the same
d1130 1
a1130 1
	    /* XXXXXXX This seems to happen with *every*
d1320 1
a1320 1
    if (rdebug&RDEBUG_LIGHT)
d1324 1
a1324 1
    if (rdebug&RDEBUG_LIGHT)
d1361 1
a1361 1
 *
d1400 1
a1400 1
static int
d1406 1
a1406 1
    double cos_angle, x, y;
d1432 1
a1432 1
	 * inter-visibility, then shoot at that point
d1435 1
a1435 1
	idx = los->lsp->lt_pt_count *
d1442 1
a1442 1
	for (k=idx ; ((k+1) % los->lsp->lt_pt_count) != idx ;
d1495 1
a1495 1
		if (rdebug & RDEBUG_LIGHT )
d1527 1
a1527 1
		tryagain = 1;
d1537 1
a1537 1
	/* at this point, we have no candidate points available to
d1548 1
a1548 1

d1551 1
a1551 1
	if (rdebug & RDEBUG_LIGHT )
d1554 1
a1554 1
	 * sphere for the light source.  We pick a point on the
d1556 1
a1556 1
	 * angle.  This is done by picking random radius and angle
d1559 1
a1559 1
	radius = los->lsp->lt_radius *
d1561 1
a1561 1
	    fabs(bn_rand_half(los->ap->a_resource->re_randptr)
d1563 1
a1563 1
	angle =  M_PI * 2.0 *
d1580 1
a1580 1
	VJOIN2(shoot_pt, los->lsp->lt_pos,
d1585 2
a1586 2
	    bu_log("light at (%g %g %g) radius %g\n",
		   V3ARGS(los->lsp->lt_pos),
d1659 1
a1659 1
	VJOIN1( sub_ap.a_ray.r_pt, los->swp->sw_hit.hit_point, f,
d1662 2
a1663 2
    sub_ap.a_rbeam = los->ap->a_rbeam +
	los->swp->sw_hit.hit_dist *
d1745 1
a1745 1
 *	Sets
d1768 1
a1768 1
    char flags[MAX_LIGHT_SAMPLES] = {0};
d1864 1
a1864 1
	    swp->sw_visible[i] = lsp;
d1868 1
a1868 1
	    swp->sw_visible[i] = (struct light_specific *)NULL;
@


14.9
log
@Add code to allow liboptical to be a Windows DLL
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.8 2005/01/30 20:30:55 brlcad Exp $ (ARL)";
d54 2
a55 2
#if RT_MULTISPECTRAL
#include "spectrum.h"
a179 3
#if RT_MULTISPECTRAL
extern const struct bn_table	*spectrum;	/* from rttherm/viewtherm.c */
#endif
d203 1
a203 1
#if RT_MULTISPECTRAL
d262 1
a262 1
#if RT_MULTISPECTRAL
d690 1
a690 1
#if RT_MULTISPECTRAL
d785 1
a785 1
#if RT_MULTISPECTRAL
d823 1
a823 1
#if RT_MULTISPECTRAL
d902 1
a902 1
#if RT_MULTISPECTRAL
d1021 1
a1021 1
#if RT_MULTISPECTRAL
d1035 1
a1035 1
#if RT_MULTISPECTRAL
d1045 1
a1045 1
#if RT_MULTISPECTRAL
d1077 1
a1077 1
#if RT_MULTISPECTRAL
d1090 1
a1090 1
#if RT_MULTISPECTRAL
d1114 1
a1114 1
#if RT_MULTISPECTRAL
d1125 1
a1125 1
#if RT_MULTISPECTRAL
d1148 1
a1148 1
#if RT_MULTISPECTRAL
d1160 1
a1160 1
#if RT_MULTISPECTRAL
d1192 1
a1192 1
#if RT_MULTISPECTRAL
d1208 1
a1208 1
#if RT_MULTISPECTRAL
d1226 1
a1226 1
#if RT_MULTISPECTRAL
d1245 1
a1245 1
#if RT_MULTISPECTRAL
d1255 1
a1255 1
#if RT_MULTISPECTRAL
d1278 1
a1278 1
#if RT_MULTISPECTRAL
d1291 1
a1291 1
#if RT_MULTISPECTRAL
d1311 1
a1311 1
#if RT_MULTISPECTRAL
d1328 1
a1328 1
#if RT_MULTISPECTRAL
d1336 1
a1336 1
#if RT_MULTISPECTRAL
d1635 1
a1635 1
#if RT_MULTISPECTRAL
d1713 1
a1713 1
#if RT_MULTISPECTRAL
d1799 1
a1799 1
#if RT_MULTISPECTRAL
@


14.8
log
@update copyright to 2005
@
text
@d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/liboptical/sh_light.c,v 14.7 2004/12/21 07:32:30 morrison Exp $ (ARL)";
a47 1
#include "bu.h"
d49 1
a49 2
#include "shadefuncs.h"
#include "shadework.h"
a50 1
#include "rtprivate.h"
a57 5
extern int
viewshade(struct application *ap,
	  register const struct partition *pp,
	  register struct shadework *swp);

a179 2
extern double AmbientIntensity;

@


14.7
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 United States Government as represented by
d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 14.6 2004/12/21 06:58:42 morrison Exp $ (ARL)";
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a31 2
 *  
 *
d34 1
a34 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 14.5 2004/12/21 06:44:33 morrison Exp $ (ARL)";
@


14.5
log
@remove the old distribution notice section
@
text
@a33 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d36 1
a36 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a32 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
d39 1
a39 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d43 1
a43 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 14.2 2004/12/21 04:03:25 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d43 1
a43 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
d43 1
a43 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 1.7 2004/10/19 14:36:02 butler Exp $ (ARL)";
@


1.7
log
@More bogons in the lighting calculations eliminated.  Lights with sample points specified weren't working right.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 1.6 2004/10/19 04:20:19 butler Exp $ (ARL)";
d1881 10
@


1.6
log
@I can't believe I committed the wrong version last time.  OK, *HERE* is the fix for infinite light sources.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 1.5 2004/10/18 20:41:03 butler Exp $ (ARL)";
d125 4
d558 1
a558 1
	bu_log("light bb (%g %g %g), (%g %g %g)\n", 
d568 1
a568 1
	bu_log("span %g %g %g\n", V3ARGS(span));
d571 1
a571 1
	bu_log("Small light. (treating as point source)\n");
d580 1
a580 1

d586 1
a586 1
	bu_log("%d light sample points\n", lsp->lt_pt_count);
d592 1
a592 1
	    bu_log("V %g %g %g  %g %g %g\n",
d596 1
d632 1
d736 1
a736 1
    if (rdebug&RDEBUG_LIGHT)
d738 1
a738 1

d916 1
a916 2
	if (lsp->lt_shadows > 1 && 
	    lsp->lt_pt_count < 1)
d938 11
d1485 7
a1491 2
	    VisRayvsLightN
		= VDOT(lpt->lp_norm, rdir);
d1494 1
a1494 2
		 ( VEQUAL(lpt->lp_norm, zero) ||
		   VisRayvsSurfN > COSINE89_99DEG ) ) {
d1506 1
a1506 1
	    if (rdebug & RDEBUG_LIGHT ) 
d1508 5
@


1.5
log
@Fixed problem with infinite light sources that caused specular highlights to be
int the wrong place (as if the light source were not infinite).  Of course, the shadows
were in the right place, so this looked very odd.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 1.4 2004/09/10 19:49:33 butler Exp $ (ARL)";
d1786 5
a1790 2
	VSUB2(los.to_light_center, lsp->lt_pos, swp->sw_hit.hit_point);

d1827 1
a1827 2
		 * this light source.  Probably an infinite
		 * point light source.
a1830 4
		break;
	    case -2:
		visibility = 0;
		vis_ray = tot_vis_rays;
@


1.4
log
@Light positions were being transformed from view space to model space as though they were viectors instead of points.
This meant that the would regularly end up in the "wrong" position.

I left a little debugging code #ifdef'd out so that it will be easier to visualize light positions in the future if needed.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 1.3 2004/08/02 23:01:49 morrison Exp $ (ARL)";
d66 1
a66 1
const char *base, char *value));
d76 4
a79 4
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d81 1
a81 1
	struct light_specific *lsp = (struct light_specific *)base;
d83 14
a96 14
	if (rdebug & RDEBUG_LIGHT) {
		bu_log("light_cvt_visible(%s, %d)\n", name, sdp->sp_offset);
		bu_log("visible: %d invisible: %d\n", 
		       LIGHT_O(lt_visible),
		       LIGHT_O(lt_invisible));
	}
	switch (sdp->sp_offset) {
	case LIGHT_O(lt_invisible):
		lsp->lt_visible = !lsp->lt_invisible;
		break;
	case LIGHT_O(lt_visible):
		lsp->lt_invisible = !lsp->lt_visible;
		break;
	}
d104 4
a107 4
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
d109 2
a110 2
	struct light_specific *lsp = (struct light_specific *)base;
	fastf_t *p = (fastf_t *)(base+sdp->sp_offset);
d112 1
a112 1
	if ( lsp->lt_pt_count >= MAX_LIGHT_SAMPLES ) return;
d114 8
a121 8
	if (! strcmp("pt", name) ) {
		/* user just specified point, set normal to zeros */
		p[3] = p[4] = p[5] = 0.0;
	} else if ( strcmp("pn", name) ) {
		bu_log("*********** unknown option in light_pt_set %s:%d\n",
		       __FILE__, __LINE__);
		return;
	}
d123 2
a124 2
	memcpy( &lsp->lt_sample_pts[ lsp->lt_pt_count++ ], p,
		sizeof( struct light_pt ) );
d128 9
a136 9
{"%f",	1, "bright",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "angle",	LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "fract",	LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	3, "target",	LIGHT_OA(lt_target),	aim_set },
{"%d",	1, "shadows",	LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "infinite",	LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "visible",	LIGHT_O(lt_visible),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "invisible",	LIGHT_O(lt_invisible),	BU_STRUCTPARSE_FUNC_NULL },
{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
d140 3
a142 3
{"%f",	1, "bright",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "b",		LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "inten",	LIGHT_O(lt_intensity),	BU_STRUCTPARSE_FUNC_NULL },
d144 2
a145 2
{"%f",	1, "angle",	LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "a",		LIGHT_O(lt_angle),	BU_STRUCTPARSE_FUNC_NULL },
d147 2
a148 2
{"%f",	1, "fract",	LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },
{"%f",	1, "f",		LIGHT_O(lt_fraction),	BU_STRUCTPARSE_FUNC_NULL },
d150 3
a152 3
{"%f",	3, "target",	LIGHT_OA(lt_target),	aim_set },
{"%f",	3, "t",		LIGHT_OA(lt_target),	aim_set },
{"%f",	3, "aim",	LIGHT_OA(lt_target),	aim_set },
d154 2
a155 2
{"%d",	1, "shadows",	LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "s",		LIGHT_O(lt_shadows),	BU_STRUCTPARSE_FUNC_NULL },
d157 2
a158 2
{"%d",	1, "infinite",	LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },
{"%d",	1, "i",		LIGHT_O(lt_infinite),	BU_STRUCTPARSE_FUNC_NULL },
d160 3
a162 3
{"%d",	1, "visible",	LIGHT_O(lt_visible),	light_cvt_visible },
{"%d",  1, "invisible",	LIGHT_O(lt_invisible),	light_cvt_visible },
{"%d",	1, "v",		LIGHT_O(lt_visible),	light_cvt_visible },
d164 2
a165 2
{"%f",	3, "pt",	LIGHT_OA(lt_parse_pt), light_pt_set },
{"%f",	6, "pn",	LIGHT_OA(lt_parse_pt), light_pt_set },
d167 1
a167 1
{"",	0, (char *)0,	0,			BU_STRUCTPARSE_FUNC_NULL }
d184 4
a187 4
	{MF_MAGIC,	"light",	0,		MFI_NORMAL,	0,
	light_setup,	light_render,	light_print,	light_free },
	{0,		(char *)0,	0,		0,		0,
	0,		0,		0,		0 }
d196 4
a199 4
	struct application *ap;
	struct shadework *swp;
	struct light_specific *lsp;
	int *rand_idx;
d202 1
a202 1
	struct bn_tabdata **inten;
d204 1
a204 1
	fastf_t *inten;
d206 4
a209 4
	int iter;
	vect_t to_light_center;	/* coordinate system on light */
	vect_t light_x;
	vect_t light_y;
d222 5
a226 5
	register struct light_specific *lsp = (struct light_specific *)base;
	if (rdebug & RDEBUG_LIGHT )  {
		VPRINT("lt_target: ", lsp->lt_target);
	}
	lsp->lt_exaim = 1;
d243 2
a244 2
	register struct light_specific *lsp = (struct light_specific *)dp;
	register fastf_t f;
d246 1
a246 1
	RT_CK_LIGHT(lsp);
d248 29
a276 29
	/* Provide cosine/2 shading, to make light look round */
	if ((f = -VDOT( swp->sw_hit.hit_normal, ap->a_ray.r_dir )*0.5) < 0 )
		f = 0;

	/* See if surface normal falls in light beam direction */
	if (VDOT( lsp->lt_aim, swp->sw_hit.hit_normal) < lsp->lt_cosangle )  {
		/* dark, outside of light beam area */
		f *= lsp->lt_fraction;
	} else {
		/* within beam area */
		f = (f+0.5) * lsp->lt_fraction;
	}
#if RT_MULTISPECTRAL
	/* Support a shader having modified the temperature of the source */
	if (swp->sw_temperature > 0 )  {
		rt_spect_black_body( swp->msw_color, swp->sw_temperature, 5 );
		bn_tabdata_scale( swp->msw_color, swp->msw_color, f );
		if (rdebug & RDEBUG_LIGHT )  {
			bu_log("light %s xy=%d,%d temp=%g\n",
			pp->pt_regionp->reg_name, ap->a_x, ap->a_y,
			swp->sw_temperature );
		}
	} else {
		bn_tabdata_scale( swp->msw_color, lsp->lt_spectrum, f );
	}
#else
	if (!PM_Activated) {
	  VSCALE( swp->sw_color, lsp->lt_color, f );
	}
d278 1
a278 1
	return(1);
d291 4
a294 4
	struct light_specific *lsp = (struct light_specific *)ap->a_uptr;
	struct soltab *stp;
	struct light_pt *lpt;
	struct partition *pp, *prev, *next;
d296 1
a296 1
	if ((pp=PartHeadp->pt_forw) == PartHeadp) return 0;
d298 1
a298 1
	for( ; pp != PartHeadp; pp = pp->pt_forw )  {
d300 1
a300 1
		if (pp->pt_regionp != lsp->lt_rp) continue;
d302 16
a317 16
		prev = pp->pt_back;
		/* check to make sure the light hit point isn't against some
		 * other object
		 */
		if (prev != PartHeadp) {
			double delta;
			delta = prev->pt_outhit->hit_dist - 
				pp->pt_inhit->hit_dist;

			/* XXX This really should compare to see if adj
			 * object is air
			 */
			if (delta < 5.0 && delta > -5.0) {
				continue;
			}
		}
d319 4
a322 4
		/* The inbound point is not against another object, so 
		 * light will be emitted in this direction
		 */
		lpt = &lsp->lt_sample_pts[lsp->lt_pt_count++];
d324 1
a324 1
		stp = pp->pt_inseg->seg_stp;
d326 2
a327 2
		VJOIN1( lpt->lp_pt, ap->a_ray.r_pt, 
			pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
d329 2
a330 2
		RT_HIT_NORMAL( lpt->lp_norm, pp->pt_inhit, stp, 
			       &(ap->a_ray), pp->pt_inflip );
d332 1
a332 1
		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES) return 1;
d334 20
a353 20
		/* check to make sure the light out hit point isn't against
		 * some other object
		 */
		next = pp->pt_forw;
		if (next != PartHeadp) {
			double delta;
			delta = next->pt_inhit->hit_dist - 
				pp->pt_outhit->hit_dist;

			/* XXX This really should compare to see if adj
			 * object is air
			 */
			if (delta < 5.0 && delta > -5.0) {
				continue;
			}
		}
		/* The out point isn't against another object, so light
		 * will be emitted in this direction
		 */
		lpt = &lsp->lt_sample_pts[lsp->lt_pt_count++];
d355 1
a355 1
		stp = pp->pt_outseg->seg_stp;
d357 2
a358 2
		VJOIN1( lpt->lp_pt, ap->a_ray.r_pt, 
			pp->pt_outhit->hit_dist, ap->a_ray.r_dir );
d360 2
a361 2
		RT_HIT_NORMAL( lpt->lp_norm, pp->pt_outhit, stp, 
			       &(ap->a_ray), pp->pt_outflip );
d363 1
a363 1
		if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES) return 1;
d365 2
a366 2
	}
	return 1;
d376 1
a376 1
	return 0;
d391 2
a392 2
	double x, y, z;
	struct light_specific *lsp = (struct light_specific *)ap->a_uptr;
d394 2
a395 2
	if (rdebug & RDEBUG_LIGHT )
		bu_log("shoot_grids Z, step=(%g, %g, %g)\n", V3ARGS(step) );
d397 1
a397 1
	/* shoot through the X,Y plane */
d400 2
a401 2
	if (step[Y] > MIN_GRID_STEP_MM && step[X] > MIN_GRID_STEP_MM) {
		z = tree_min[Z];
d403 2
a404 2
		VSET(ap->a_ray.r_dir, 0.0, 0.0, 1.0);
		z = tree_min[Z];
d406 2
a407 2
		for (y = tree_min[Y] + step[Y] * 0.5;
		     y < tree_max[Y] ; y += step[Y])
d409 49
a457 49
			for (x = tree_min[X] + step[X] * 0.5;
			     x < tree_max[X] ; x += step[X]) {
				VSET(ap->a_ray.r_pt, x, y, z);
				(void)rt_shootray( ap );
				if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
					return;
			}
	}

	if (rdebug & RDEBUG_LIGHT )
		bu_log("shoot_grids Y\n");

	/* shoot through the X, Z plane */
	if (step[Z] > MIN_GRID_STEP_MM && step[X] > MIN_GRID_STEP_MM) {
		y = tree_min[Y];

		VSET(ap->a_ray.r_dir, 0.0, 1.0, 0.0);
		z = tree_min[Z];

		for (z = tree_min[Z] + step[Z] * 0.5;
		     z < tree_max[Z] ; z += step[Z])

			for (x = tree_min[X] + step[X] * 0.5;
			     x < tree_max[X] ; x += step[X]) {
				VSET(ap->a_ray.r_pt, x, y, z);
				(void)rt_shootray( ap );
				if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
					return;
			}
	}

	/* shoot through the Y, Z plane */
	if (rdebug & RDEBUG_LIGHT )
		bu_log("shoot_grids X\n");
	if (step[Z] > MIN_GRID_STEP_MM && step[Y] > MIN_GRID_STEP_MM) {
		VSET(ap->a_ray.r_dir, 1.0, 0.0, 0.0);
		x = tree_min[X];

		for (z = tree_min[Z] + step[Z] * 0.5;
		     z < tree_max[Z] ; z += step[Z])

			for (y = tree_min[Y] + step[Y] * 0.5;
			     y < tree_max[Y] ; y += step[Y]) {
				VSET(ap->a_ray.r_pt, x, y, z);
				(void)rt_shootray( ap );
				if (lsp->lt_pt_count >= MAX_LIGHT_SAMPLES)
					return;
			}
	}
d463 3
a465 3
		      point_t tree_min,
		      point_t tree_max,
		      point_t span)
d467 51
a517 51
	int face;
	point_t pt;
	static int idx = 0;

	/* pick a face of the bounding RPP at which we will start the ray */
	face = BN_RANDOM(idx) * 2.9999;

	switch (face) {
	case 0: /* XMIN */
		VSET(ap->a_ray.r_pt,
		     tree_min[X] - 10.0, 
		     tree_min[Y] + BN_RANDOM(idx) * span[Y],
		     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
		VSET(pt,
		     tree_max[X], 
		     tree_min[Y] + BN_RANDOM(idx) * span[Y],
		     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
		break;

	case 1: /* YMIN */
		VSET(ap->a_ray.r_pt,
		     tree_min[X] + BN_RANDOM(idx) * span[X],
		     tree_min[Y] - 10.0,
		     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
		VSET(pt,
		     tree_min[X] + BN_RANDOM(idx) * span[X],
		     tree_max[Y],
		     tree_min[Z] + BN_RANDOM(idx) * span[Z]);
		break;

	case 2: /* ZMIN */
		VSET(ap->a_ray.r_pt,
		     tree_min[X] + 
		     BN_RANDOM(idx) * span[X],

		     tree_min[Y] + 
		     BN_RANDOM(idx) * span[Y],

		     tree_min[Z] - 10.0);
		VSET(pt,
		     tree_min[X] + 
		     BN_RANDOM(idx) * span[X],

		     tree_min[Y] + 
		     BN_RANDOM(idx) * span[Y],

		     tree_max[Z]);
		break;
	}
	VSUB2(ap->a_ray.r_dir, pt, ap->a_ray.r_pt);
	VUNITIZE(ap->a_ray.r_dir);
d531 4
a534 4
	struct application ap;
	point_t tree_min;
	point_t tree_max;
	vect_t  span;
d536 1
a536 1
	RT_CK_LIGHT(lsp);
d538 2
a539 2
	if (rdebug & RDEBUG_LIGHT )
		bu_log("light_gen_sample_pts(%s)\n", lsp->lt_name);
d542 6
a547 6
	memset(&ap, 0, sizeof(ap));
	ap.a_rt_i = upap->a_rt_i;
	ap.a_onehit = 0;
	ap.a_hit = gen_hit;
	ap.a_miss = gen_miss;
	ap.a_uptr = (genptr_t)lsp;
d549 2
a550 2
	/* get the bounding box of the light source */
	rt_bound_tree(lsp->lt_rp->reg_treetop, tree_min, tree_max);
d553 4
a556 4
	if (rdebug & RDEBUG_LIGHT ) {
		bu_log("light bb (%g %g %g), (%g %g %g)\n", 
		       V3ARGS(tree_min), V3ARGS(tree_max) );
	}
d559 11
a569 11
	/* if there is no space occupied by the light source, then
	 * just give up
	 */
	VSUB2(span, tree_max, tree_min);
	if (rdebug & RDEBUG_LIGHT ) {
		bu_log("span %g %g %g\n", V3ARGS(span));
	}
	if (span[X] <= 0.0 && span[Y] <= 0.0 && span[Z] <= 0.0) {
		bu_log("Small light. (treating as point source)\n");
		return;
	}
d571 1
a571 1
	while ( lsp->lt_pt_count < MAX_LIGHT_SAMPLES ) {
d573 3
a575 3
		ray_setup(&ap, tree_min, tree_max, span);
		(void)rt_shootray( &ap );
	}
d577 4
a580 4
	if (rdebug & RDEBUG_LIGHT ) {
		int l;
		point_t p;
		struct light_pt *lpt = &lsp->lt_sample_pts[0];
d582 1
a582 1
		bu_log("%d light sample points\n", lsp->lt_pt_count);
d584 1
a584 1
		for (l=0 ; l < lsp->lt_pt_count ; l++, lpt++) {
d586 1
a586 1
			VJOIN1(p, lpt->lp_pt, 100.0, lpt->lp_norm);
d588 2
a589 3
			bu_log("V %g %g %g  %g %g %g\n",
			       V3ARGS(lpt->lp_pt), V3ARGS(p));
		}
d591 1
d606 25
a630 4
	register struct light_specific *lsp;
	register struct soltab *stp;
	vect_t	work;
	fastf_t	f;
d632 2
a633 2
	BU_CK_VLS( matparm );
	BU_GETSTRUCT( lsp, light_specific );
d635 2
a636 71
	BU_LIST_MAGIC_SET( &(lsp->l), LIGHT_MAGIC );
	lsp->lt_intensity = 1.0;	/* Lumens */
	lsp->lt_fraction = -1.0;		/* Recomputed later */
	lsp->lt_visible = 1;		/* explicitly modeled */
	lsp->lt_invisible = 0;		/* explicitly modeled */
	lsp->lt_shadows = 1;		/* by default, casts shadows */
	lsp->lt_angle = 180;		/* spherical emission by default */
	lsp->lt_exaim = 0;		/* use default aiming mechanism */
	lsp->lt_infinite = 0;
	lsp->lt_rp = rp;
	lsp->lt_pt_count = 0;
	memset(lsp->lt_sample_pts, 0, sizeof(lsp->lt_sample_pts));
	lsp->lt_name = bu_strdup( rp->reg_name );
	if (bu_struct_parse( matparm, light_parse, (char *)lsp ) < 0 )  {
		bu_free( (char *)lsp, "light_specific" );
		return(-1);
	}

	if (lsp->lt_angle > 180 )  lsp->lt_angle = 180;
	lsp->lt_cosangle = cos( (double) lsp->lt_angle * 0.0174532925199433 );

	/* Determine position and size */
	if (rp->reg_treetop->tr_op == OP_SOLID )  {

		stp = rp->reg_treetop->tr_a.tu_stp;
		VMOVE( lsp->lt_pos, stp->st_center );
		lsp->lt_radius = stp->st_aradius;
	} else {
		vect_t	min_rpp, max_rpp;
		vect_t	rad;
		register union tree *tp;

		if (rt_bound_tree( rp->reg_treetop, min_rpp, max_rpp ) < 0 )
			return(-1);

		if (max_rpp[X] >= INFINITY )  {
			bu_log("light_setup(%s) Infinitely large light sources not supported\n",
			    lsp->lt_name );
			return(-1);
		}
		VADD2SCALE( lsp->lt_pos, min_rpp, max_rpp, 0.5 );
		VSUB2( rad, max_rpp, lsp->lt_pos );
		/* Use smallest radius from center to max as light radius */
		/* Having the radius too large can give very poor lighting */
		if (rad[X] < rad[Y] )
			lsp->lt_radius = rad[X];
		else
			lsp->lt_radius = rad[Y];
		if (rad[Z] < lsp->lt_radius )
			lsp->lt_radius = rad[Z];

		/* Find first leaf node on left of tree */
		tp = rp->reg_treetop;
		while( tp->tr_op != OP_SOLID )
			tp = tp->tr_b.tb_left;
		stp = tp->tr_a.tu_stp;
	}

	/* Light is aimed down -Z in it's local coordinate system */
	{
		register matp_t	matp;
		if ((matp = stp->st_matp) == (matp_t)0 )
			matp = (matp_t)bn_mat_identity;
		if (lsp->lt_exaim) {
			VSUB2 (work, lsp->lt_target, lsp->lt_pos);
			VUNITIZE (work);
		}
		else VSET( work, 0, 0, -1 );
		MAT4X3VEC( lsp->lt_aim, matp, work );
		VUNITIZE( lsp->lt_aim );
	}
d638 56
a693 49
#if RT_MULTISPECTRAL
	BN_GET_TABDATA(lsp->lt_spectrum, spectrum);
	if (rp->reg_mater.ma_temperature > 0 )  {
		rt_spect_black_body( lsp->lt_spectrum,
			rp->reg_mater.ma_temperature, 5 );
		if (rdebug & RDEBUG_LIGHT )  {
			bu_log("Light %s temp is %g degK, emission is pure black-body\n",
				rp->reg_name, rp->reg_mater.ma_temperature);
		}
	} else if (rp->reg_mater.ma_color_valid )  {
		rt_spect_reflectance_rgb( lsp->lt_spectrum,
					  rp->reg_mater.ma_color );
		/* XXX Need to convert units of lumens (candela-sr) to ?? 
		 * mw/sr?  Use any old numbers to get started.
		 */
		bn_tabdata_scale( lsp->lt_spectrum, lsp->lt_spectrum,
			lsp->lt_intensity * 0.001 ); /* XXX */
	} else {
		/* Default: Perfectly even emission across whole spectrum */
		bn_tabdata_constval( lsp->lt_spectrum, 0.001 );
	}
#else
	if (rp->reg_mater.ma_color_valid )  {
		VMOVE( lsp->lt_color, rp->reg_mater.ma_color );
	} else {
		VSETALL( lsp->lt_color, 1 );
	}
#endif

	VMOVE( lsp->lt_vec, lsp->lt_pos );
	f = MAGNITUDE( lsp->lt_vec );
	if (f < SQRT_SMALL_FASTF ) {
		/* light at the origin, make its direction vector up */
		VSET( lsp->lt_vec, 0, 0, 1 );
	} else {
		VSCALE( lsp->lt_vec, lsp->lt_vec, f );
	}

	/* Add to linked list of lights */
	if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		BU_LIST_INIT( &(LightHead.l) );
	}
	BU_LIST_INSERT( &(LightHead.l), &(lsp->l) );

	if (rdebug&RDEBUG_LIGHT)
		light_print(rp, (char *)lsp);

	if (lsp->lt_invisible )  {
		return(2);	/* don't show light, destroy it later */
d695 41
d737 2
a738 2
	*dpp = (genptr_t)lsp;	/* Associate lsp with reg_udata */
	return(1);
d747 1
a747 1
	bu_struct_print(rp->reg_name, light_print_tab, (char *)dp);
d756 1
a756 1
	register struct light_specific *lsp = (struct light_specific *)cp;
d758 8
a765 8
	RT_CK_LIGHT(lsp);
	BU_LIST_DEQUEUE( &(lsp->l) );
	if (lsp->lt_name )  {
		bu_free( lsp->lt_name, "light name" );
		lsp->lt_name = (char *)0;
	}
	lsp->l.magic = 0;	/* sanity */
	bu_free( (char *)lsp, "light_specific" );
d776 32
a807 32
	register struct light_specific *lsp;
	register int i;
	vect_t	temp;
	vect_t	color;
	char	name[64];
#if RT_MULTISPECTRAL
	float	fcolor[3];
#endif
	/* Determine the Light location(s) in view space */
	for( i=0; i<num; i++ )  {
		switch(i)  {
		case 0:
			/* 0:  At left edge, 1/2 high */
			VSET( color, 1,  1,  1 );	/* White */
			VSET( temp, -1, 0, 1 );
			break;

		case 1:
			/* 1: At right edge, 1/2 high */
			VSET( color,  1, 1, 1 );
			VSET( temp, 1, 0, 1 );
			break;

		case 2:
			/* 2:  Behind, and overhead */
			VSET( color, 1, 1,  1 );
			VSET( temp, 0, 1, -0.5 );
			break;

		default:
			return;
		}
d809 5
a813 42
		{  /* debugging ascii plot commands drawing from point location to origin */
		    vect_t tmp;
		    static vect_t pt = {0.0, 0.0, 0.0};
		    MAT4X3PNT(tmp, v2m, temp); bu_log("C 0 255 255\nO %g %g %g\n", V3ARGS(tmp));
		    MAT4X3PNT(tmp, v2m, pt); bu_log("Q %g %g %g\n", V3ARGS(tmp));
		}
#endif

		BU_GETSTRUCT( lsp, light_specific );
		lsp->l.magic = LIGHT_MAGIC;
#if RT_MULTISPECTRAL

		BN_GET_TABDATA(lsp->lt_spectrum, spectrum);
		VMOVE(fcolor, color);
		rt_spect_reflectance_rgb( lsp->lt_spectrum, fcolor );
		bn_tabdata_scale( lsp->lt_spectrum, lsp->lt_spectrum, 1000.0 );

#else
		VMOVE( lsp->lt_color, color );
#endif
		MAT4X3PNT( lsp->lt_pos, v2m, temp );
		VMOVE( lsp->lt_vec, lsp->lt_pos );
		VUNITIZE( lsp->lt_vec );

		sprintf(name, "Implicit light %d", i);
		lsp->lt_name = bu_strdup(name);

		/* XXX Is it bogus to set lt_aim? */
		VSET( lsp->lt_aim, 0, 0, -1 );	/* any direction: spherical */
		lsp->lt_intensity = 1.0;
		lsp->lt_radius = 0.1;		/* mm, "point" source */
		lsp->lt_visible = 0;		/* NOT explicitly modeled */
		lsp->lt_invisible = 1;		/* NOT explicitly modeled */
		lsp->lt_shadows = 0;		/* no shadows for speed */
		lsp->lt_angle = 180;		/* spherical emission */
		lsp->lt_cosangle = -1;		/* cos(180) */
		lsp->lt_infinite = 0;
		lsp->lt_rp = REGION_NULL;
		if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
			BU_LIST_INIT( &(LightHead.l) );
		}
		BU_LIST_INSERT( &(LightHead.l), &(lsp->l) );
d815 37
d872 22
a893 3
	register struct light_specific *lsp;
	register int		nlights = 0;
	register fastf_t	inten = 0.0;
d895 3
a897 22
	if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		BU_LIST_INIT( &(LightHead.l) );
	}


	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		nlights++;
		if (lsp->lt_fraction > 0 )  continue;	/* overridden */
		if (lsp->lt_intensity <= 0 )
			lsp->lt_intensity = 1;		/* keep non-neg */
		if (lsp->lt_intensity > inten )
			inten = lsp->lt_intensity;
	}

	/* Compute total emitted energy, including ambient */
	/**	inten *= (1 + AmbientIntensity); **/
	/* This is non-physical and risky, but gives nicer pictures for now */
	inten *= (1 + AmbientIntensity*0.5);

	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lsp);
		if (lsp->lt_fraction > 0 )  continue;	/* overridden */
d899 1
a899 1
		lsp->lt_fraction = 1.0;	/* always use honest intensity values */
d901 1
a901 1
		lsp->lt_fraction = lsp->lt_intensity / inten;
d903 11
a913 1
	}
a914 9
	/* 
	 * Make sure we have sample points for all light sources in the scene
	 */
	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lsp);
		if (lsp->lt_shadows > 1 && 
		    lsp->lt_pt_count < 1)
			light_gen_sample_pts(ap, lsp);
	}
d916 3
d920 20
a939 24
	if (R_DEBUG) {
		bu_log("Lighting: Ambient = %d%%\n",
		       (int)(AmbientIntensity*100));

		for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
			RT_CK_LIGHT(lsp);
			bu_log( "  %s: (%g, %g, %g), aimed at (%g, %g, %g)\n",
			    lsp->lt_name,
			    lsp->lt_pos[X], lsp->lt_pos[Y], lsp->lt_pos[Z],
			    lsp->lt_aim[X], lsp->lt_aim[Y], lsp->lt_aim[Z] );
			bu_log( "  %s: %s, %s, %g lumens (%d%%), halfang=%g\n",
			    lsp->lt_name,
			    lsp->lt_visible ? "visible":"invisible",
			    lsp->lt_shadows ? "casts shadows":"no shadows",
			    lsp->lt_intensity,
			    (int)(lsp->lt_fraction*100),
			    lsp->lt_angle );
		}
	}
	if (nlights > SW_NLIGHTS )  {
		bu_log("Number of lights limited to %d\n", SW_NLIGHTS);
		nlights = SW_NLIGHTS;
	}
	return(nlights);
d955 1
a955 1
	register struct light_specific *lsp, *zaplsp;
d957 14
a970 14
	if (BU_LIST_UNINITIALIZED( &(LightHead.l ) ) )  {
		BU_LIST_INIT( &(LightHead.l) );
		return;
	}
	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lsp);
		if (lsp->lt_rp != REGION_NULL && lsp->lt_visible )  {
			/* Will be cleaned up by mlib_free() */
			continue;
		}
		zaplsp = lsp;
		lsp = BU_LIST_PREV( light_specific, &(lsp->l) );
		light_free( (genptr_t)zaplsp );
	}
d1001 6
a1006 6
	register struct partition *pp;
	register struct region	*regp = NULL;
	struct application	sub_ap;
	struct shadework	sw;
	const struct light_specific	*lsp;
	extern int	light_render(struct application *ap, struct partition *pp, struct shadework *swp, char *dp);
d1008 1
a1008 1
	struct bn_tabdata	*ms_filter_color = BN_TABDATA_NULL;
d1010 1
a1010 1
	vect_t	filter_color;
d1012 4
a1015 4
	int	light_visible;
	int	air_sols_seen = 0;
	int 	is_proc;
	char	*reason = "???";
d1017 3
a1019 3
	memset(&sw, 0, sizeof(sw));		/* make sure nothing nasty on the stack */
	if (rdebug&RDEBUG_LIGHT)
		bu_log("light_hit level %d %d\n", ap->a_level, __LINE__);
d1022 2
a1023 2
	sub_ap.a_spectrum = BN_TABDATA_NULL;	/* sanity */
	BN_CK_TABDATA(ap->a_spectrum);
d1026 1
a1026 1
	BU_CK_LIST_HEAD(&finished_segs->l);
d1028 2
a1029 2
	lsp = (struct light_specific *)(ap->a_uptr);
	RT_CK_LIGHT(lsp);
d1032 24
a1055 24
	ms_filter_color = bn_tabdata_get_constval( 1.0, spectrum );
	BN_GET_TABDATA( sw.msw_color, spectrum );
	BN_GET_TABDATA( sw.msw_basecolor, spectrum );
#else
	VSETALL( filter_color, 1 );
#endif
	/*XXX Bogus with Air.  We should check to see if it is the same 
	 * surface.
	 *
	 *  Since the light visibility ray started at the surface of a solid,
	 *  it is likely that the solid will be the first partition on
	 *  the list, with pt_outhit->hit_dist being roughly zero.
	 *  Don't start using partitions until pt_inhit->hit_dist is
	 *  slightly larger than zero, i.e., that the partition is not
	 *  including the start point.
	 *  The outhit distance needs to be checked too, so that if the
	 *  partition is heading through the solid toward the light
	 *  e.g. (-1,+50), then the fact that the light is obscured will
	 *  not be missed.
	 */
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
		if (pp->pt_regionp->reg_aircode != 0 )  {
			/* Accumulate transmission through each air lump */
			air_sols_seen++;
d1057 6
a1062 6
			/* Obtain opacity of this region, multiply */
			sw.sw_inputs = 0;
			sw.sw_transmit = sw.sw_reflect = 0.0;
			sw.sw_refrac_index = 1.0;
			sw.sw_xmitonly = 1;	/* only want sw_transmit */
			sw.sw_segs = finished_segs;
d1064 2
a1065 2
			bn_tabdata_constval( sw.msw_color, 1.0 );
			bn_tabdata_constval( sw.msw_basecolor, 1.0 );
d1067 2
a1068 2
			VSETALL( sw.sw_color, 1 );
			VSETALL( sw.sw_basecolor, 1 );
d1070 4
a1073 4
			if (rdebug&RDEBUG_LIGHT) bu_log("calling viewshade\n");
			(void)viewshade( ap, pp, &sw );
			if (rdebug&RDEBUG_LIGHT) bu_log("viewshade returns\n");
			/* sw_transmit is only return */
d1075 1
a1075 1
			/* XXX Clouds don't yet attenuate differently based on freq */
d1077 2
a1078 2
			bn_tabdata_scale( ms_filter_color, ms_filter_color,
			    sw.sw_transmit );
d1080 1
a1080 1
			VSCALE( filter_color, filter_color, sw.sw_transmit );
d1082 1
a1082 6
			continue;
		}
		if (pp->pt_inhit->hit_dist >= ap->a_rt_i->rti_tol.dist )
			break;
		if (pp->pt_outhit->hit_dist >= ap->a_rt_i->rti_tol.dist*10 )
			break;
d1084 5
d1092 2
a1093 2
	if (pp == PartHeadp )  {
		if (rdebug&RDEBUG_LIGHT) bu_log("pp == PartHeadp\n");
d1095 2
a1096 2
		pp=PartHeadp->pt_forw;
		RT_CK_PT(pp);
d1098 2
a1099 2
		if (lsp->lt_invisible || lsp->lt_infinite )  {
			light_visible = 1;
d1101 1
a1101 1
			bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
d1103 1
a1103 1
			VMOVE( ap->a_color, filter_color );
d1105 3
a1107 3
			reason = "Unobstructed invisible/infinite light";
			goto out;
		}
d1109 2
a1110 2
		if (air_sols_seen > 0 )  {
			light_visible = 1;
d1112 1
a1112 1
			bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
d1114 1
a1114 1
			VMOVE( ap->a_color, filter_color );
d1116 6
a1121 6
			/* XXXXXXX This seems to happen with *every* 
			 * light vis ray through air
			 */
			reason = "Off end of partition list, air was seen";
			goto out;
		}
d1123 8
a1130 8
		if (pp->pt_inhit->hit_dist <= ap->a_rt_i->rti_tol.dist) {
			int retval;
			/* XXX This is bogus if air is being used */
			/* What has probably happened is that the shadow ray
			 * has produced an Out-hit from the current solid
			 * which looks valid, but is in fact an intersection
			 * with the current hit point.
			 */
d1132 2
a1133 2
			sub_ap = *ap;	/* struct copy */
			sub_ap.a_level++;
d1135 1
a1135 1
			sub_ap.a_spectrum = bn_tabdata_dup( ap->a_spectrum );
d1137 3
a1139 3
			/* pt_outhit->hit_point has not been calculated */
			VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt,
			    pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
d1141 2
a1142 2
			if (rdebug&RDEBUG_LIGHT) bu_log("hit_dist < tol\n");
			retval = rt_shootray( &sub_ap );
d1144 2
a1145 2
			ap->a_user = sub_ap.a_user;
			ap->a_uptr = sub_ap.a_uptr;
d1147 1
a1147 1
			bn_tabdata_copy( ap->a_spectrum, sub_ap.a_spectrum );
d1149 3
a1151 3
			ap->a_color[0] = sub_ap.a_color[0];
			ap->a_color[1] = sub_ap.a_color[1];
			ap->a_color[2] = sub_ap.a_color[2];
d1153 5
a1157 5
			VMOVE(ap->a_uvec, sub_ap.a_uvec);
			VMOVE(ap->a_vvec, sub_ap.a_vvec);
			ap->a_refrac_index = sub_ap.a_refrac_index;
			ap->a_cumlen = sub_ap.a_cumlen;
			ap->a_return = sub_ap.a_return;
d1159 4
a1162 4
			light_visible = retval;
			reason = "pressed on past start point";
			goto out;
		}
d1165 8
a1172 8
		bu_log("light_hit:  ERROR, nothing hit, sxy=%d,%d, dtol=%e\n",
		    ap->a_x, ap->a_y,
		    ap->a_rt_i->rti_tol.dist);
		rt_pr_partitions(ap->a_rt_i, PartHeadp, "light_hit pt list");
		light_visible = 0;
		reason = "error, nothing hit";
		goto out;
	}
d1174 1
a1174 1
	regp = pp->pt_regionp;
d1176 2
a1177 2
	/* Check to see if we hit the light source */
	if (lsp->lt_rp == regp )  {
d1179 1
a1179 1
		bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
d1181 1
a1181 1
		VMOVE( ap->a_color, filter_color );
d1183 4
a1186 4
		light_visible = 1;
		reason = "hit light";
		goto out;
	}
d1188 1
a1188 1
	/* if the region we hit is a light source be generous */
d1190 4
a1193 4
	{
		struct light_specific *lsp;
		for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
			if (lsp->lt_rp == regp) {
d1203 1
a1203 2
			}
		}
d1205 1
d1207 5
a1211 5
	/* or something futher away than a finite invisible light */
	if (lsp->lt_invisible && !(lsp->lt_infinite) ) {
		vect_t	tolight;
		VSUB2( tolight, lsp->lt_pos, ap->a_ray.r_pt );
		if (pp->pt_inhit->hit_dist >= MAGNITUDE(tolight) ) {
d1213 1
a1213 1
			bn_tabdata_copy( ap->a_spectrum, ms_filter_color );
d1215 1
a1215 1
			VMOVE( ap->a_color, filter_color );
d1217 3
a1219 4
			light_visible = 1;
			reason = "hit behind invisible light ==> hit light";
			goto out;
		}
d1221 1
d1223 2
a1224 2
	/* If we hit an entirely opaque object, this light is invisible */
	is_proc = ((struct mfuncs *)regp->reg_mfuncs)->mf_flags|MFF_PROC;
d1227 3
a1229 3
	if (pp->pt_outhit->hit_dist >= INFINITY ||
	    (regp->reg_transmit == 0 &&
	     ! is_proc /* procedural shader */) ) {
d1232 1
a1232 1
		bn_tabdata_constval( ap->a_spectrum, 0.0 );
d1234 1
a1234 1
		VSETALL( ap->a_color, 0 );
d1236 4
a1239 4
		light_visible = 0;
		reason = "hit opaque object";
		goto out;
	}
d1242 1
a1242 1
	/* XXX Check area under spectral curve?  What power level for thresh? */
d1244 53
a1296 53
	/*  See if any further contributions will mater */
	if (ap->a_color[0] + ap->a_color[1] + ap->a_color[2] < 0.01 )  {
		/* Any light energy is "fully" attenuated by here */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		reason = "light fully attenuated before shading";
		goto out;
	}
#endif

	/*
	 *  Determine transparency parameters of this object.
	 *  All we really need here is the opacity information;
	 *  full shading is not required.
	 */
	sw.sw_inputs = 0;
	sw.sw_transmit = sw.sw_reflect = 0.0;
	sw.sw_refrac_index = 1.0;
	sw.sw_xmitonly = 1;		/* only want sw_transmit */
	sw.sw_segs = finished_segs;
#if RT_MULTISPECTRAL
	bn_tabdata_constval( sw.msw_color, 1.0 );
	bn_tabdata_constval( sw.msw_basecolor, 1.0 );
#else
	VSETALL( sw.sw_color, 1 );
	VSETALL( sw.sw_basecolor, 1 );
#endif

	if (rdebug&RDEBUG_LIGHT) bu_log("calling viewshade\n");
	(void)viewshade( ap, pp, &sw );
	if (rdebug&RDEBUG_LIGHT) bu_log("viewshade back\n");
	/* sw_transmit is output */

#if RT_MULTISPECTRAL
	bn_tabdata_scale( ms_filter_color, ms_filter_color, sw.sw_transmit );
	/* XXX Power level check again? */
#else
	VSCALE( filter_color, filter_color, sw.sw_transmit );
	if (filter_color[0] + filter_color[1] + filter_color[2] < 0.01 )  {
		/* Any recursion won't be significant */
		VSETALL( ap->a_color, 0 );
		light_visible = 0;
		reason = "light fully attenuated after shading";
		goto out;
	}
#endif
	/*
	 * Push on to exit point, and trace on from there.
	 * Transmission so far is passed along in sub_ap.a_color[];
	 * Don't even think of trying to refract, or we will miss the light!
	 */
	sub_ap = *ap;			/* struct copy */
	sub_ap.a_level = ap->a_level+1;
d1298 1
a1298 1
	sub_ap.a_spectrum = bn_tabdata_dup( ap->a_spectrum );
d1300 41
a1340 18
	{
		register fastf_t f;
		f = pp->pt_outhit->hit_dist + ap->a_rt_i->rti_tol.dist;
		VJOIN1(sub_ap.a_ray.r_pt, ap->a_ray.r_pt, f, ap->a_ray.r_dir);
	}
	sub_ap.a_purpose = "light transmission after filtering";
	if (rdebug&RDEBUG_LIGHT) 
		bu_log("shooting level %d from %d\n",
		       sub_ap.a_level, __LINE__);
	light_visible = rt_shootray( &sub_ap );
	if (rdebug&RDEBUG_LIGHT) 
		if (light_visible < 0)
			bu_log("%s:%d\n", __FILE__, __LINE__);

#if RT_MULTISPECTRAL
	bn_tabdata_mul( ap->a_spectrum, sub_ap.a_spectrum, ms_filter_color );
#else
	VELMUL( ap->a_color, sub_ap.a_color, filter_color );
d1342 1
a1342 24
	reason = "after filtering";
out:

#if RT_MULTISPECTRAL
	if (ms_filter_color ) bn_tabdata_free( ms_filter_color );
	if (sw.msw_color )  bn_tabdata_free( sw.msw_color );
	if (sw.msw_basecolor ) bn_tabdata_free( sw.msw_basecolor );
	if (sub_ap.a_spectrum )  bn_tabdata_free( sub_ap.a_spectrum );
	if (rdebug & RDEBUG_LIGHT )  {
		bu_log("light vis=%d %s %s %s  ",
		    light_visible,
		    lsp->lt_name,
		    reason,
		    regp ? regp->reg_name : "" );
		bn_pr_tabdata("light spectrum", ap->a_spectrum);
	}
#else
	if (rdebug & RDEBUG_LIGHT ) bu_log("light vis=%d %s (%4.2f, %4.2f, %4.2f) %s %s\n",
	    light_visible,
	    lsp->lt_name,
	    V3ARGS(ap->a_color), reason,
	    regp ? regp->reg_name : "" );
#endif
	return(light_visible);
d1355 1
a1355 8
	struct light_specific *lsp = (struct light_specific *)(ap->a_uptr);

	RT_CK_LIGHT(lsp);
	if (lsp->lt_invisible || lsp->lt_infinite ) {
		VSETALL( ap->a_color, 1 );
		if (rdebug & RDEBUG_LIGHT ) bu_log("light_miss vis=1\n");
		return(1);		/* light_visible = 1 */
	}
d1357 18
a1374 11
	if (rdebug & RDEBUG_LIGHT) {
		bu_log("light ray missed non-infinite, visible light source\n");
		bu_log("on pixel: %d %d\n", ap->a_x, ap->a_y);
		bu_log("ray: (%g %g %g) -> %g %g %g\n", V3ARGS(ap->a_ray.r_pt), V3ARGS(ap->a_ray.r_dir) );
		bu_log("a_level: %d\n", ap->a_level);
	}

	/* Missed light, either via blockage or dither.  Return black */
	VSETALL( ap->a_color, 0 );
	if (rdebug & RDEBUG_LIGHT ) bu_log("light_miss vis=0\n");
	return(-1);			/* light_visible = 0 */
d1389 31
a1419 31
	struct application sub_ap;
	double radius = 0.0;
	double angle = 0.0;
	double cos_angle, x, y; 
	point_t shoot_pt;
	vect_t shoot_dir;
	int shot_status;
	vect_t dir, rdir;
	int idx;
	int k = 0;
	struct light_pt *lpt;
	int tryagain = 0;
	double VisRayvsLightN;
	double VisRayvsSurfN;

	if (rdebug & RDEBUG_LIGHT ) bu_log("light_vis\n");

retry:

	/* compute the light direction */
	if (los->lsp->lt_infinite ) {
		/* Infinite lights are point sources, no fuzzy penumbra */
		VMOVE( shoot_dir, los->lsp->lt_vec );

	} else if (los->lsp->lt_pt_count > 0) {
		static const vect_t zero = { 0.0, 0.0, 0.0 };

		/* pick a point at random from the list of points on
		 * the surface of the light.  If the normals indicate
		 * inter-visibility, then shoot at that point 
		 */
d1421 44
a1464 44
		idx = los->lsp->lt_pt_count * 
			fabs(bn_rand_half(los->ap->a_resource->re_randptr)) *
			2.0;
		if (idx == los->lsp->lt_pt_count) idx--;

	reusept:

		for (k=idx ; ((k+1) % los->lsp->lt_pt_count) != idx ; 
		     k = (k+1) % los->lsp->lt_pt_count) {
			if (rdebug & RDEBUG_LIGHT )
				bu_log("checking sample pt %d\n", k);

			if (flags[k] & VF_SEEN ) continue;
			if (flags[k] & VF_BACKFACE ) continue;

			/* we've got a candidate, check for backfacing */
			if (rdebug & RDEBUG_LIGHT )
				bu_log("\tpossible sample pt %d\n", k);

			lpt = &los->lsp->lt_sample_pts[k];

			VSUB2(dir, lpt->lp_pt, los->swp->sw_hit.hit_point);
			VUNITIZE(dir);
			VREVERSE(rdir, dir);


			/* if the surface normals of the light and hit point
			 * indicate that light could pass between the two
			 * points, then we have a good choice
			 *
			 * If the light point has no surface normal, then
			 * this is a general point usable from any angle
			 * so again we can shoot at this point
			 *
			 * We tolerance this down so that light points which
			 * are in the plane of the hit point are not candidates
			 * (since the light on the surface from such would be
			 * very small).  We also tolerance the normal on the
			 * light to the visibility ray so that points on the
			 * perimiter of the presented area of the light source
			 * are not chosen.  This helps avoid shooting at points
			 * on the light source which machine floating-point
			 * inaccuracies would cause the ray to miss.
			 */
d1467 13
a1479 13
			VisRayvsSurfN
			    = VDOT(los->swp->sw_hit.hit_normal, dir);
			VisRayvsLightN
			    = VDOT(lpt->lp_norm, rdir);

			if ( VisRayvsLightN > COSINE89_99DEG &&
			     ( VEQUAL(lpt->lp_norm, zero) ||
			       VisRayvsSurfN > COSINE89_99DEG ) ) {

				/* ok, we can shoot at this sample point */
				if (rdebug & RDEBUG_LIGHT ) 
					bu_log("\tPt %d selected... OK normal %g %g %g\n",
					       k, V3ARGS(lpt->lp_norm));
d1481 1
a1481 1
				flags[k] |= VF_SEEN;
d1483 2
a1484 2
				goto done;
			}
d1486 7
a1492 41
			if (rdebug & RDEBUG_LIGHT ) 
				bu_log("\tbackfacing\n");
			/* the sample point is backfacing to the location
			 * we want to test from
			 */
			flags[k] |= VF_BACKFACE;
		}

		/* if we get here, then everything is used or backfacing */

		if (rdebug & RDEBUG_LIGHT ) {
			bu_log("all light sample pts used.  trying to recycle\n");
		}

		tryagain = 0;
		for (k=0 ; k < los->lsp->lt_pt_count ; k++) {
			if (flags[k] & VF_SEEN ) {
				/* this one was used, we can re-use it */
				tryagain = 1; 
				flags[k] &= VF_BACKFACE;
			}
		}
		if (tryagain) {
			if (rdebug & RDEBUG_LIGHT ) {
				bu_log("recycling\n");
			}
			goto reusept;
		}
		/* at this point, we have no candidate points available to 
		 * shoot at
		 */
		if (rdebug & RDEBUG_LIGHT ) {
			bu_log("can't find point to shoot at\n");
		}
		return 0;
	done:
		/* we've got a point on the surface of the light to shoot at */
		VMOVE(shoot_pt, lpt->lp_pt);
		VSUB2(shoot_dir, shoot_pt, los->swp->sw_hit.hit_point);
		
	} else {
d1494 1
a1494 44
		if (rdebug & RDEBUG_LIGHT ) 
			bu_log("shooting at approximating sphere\n");
		/* We're going to shoot at a point on the apporximating
		 * sphere for the light source.  We pick a point on the 
		 * circle (presented area) for the light source from this
		 * angle.  This is done by picking random radius and angle 
		 * values on the disc.
		 */
		radius = los->lsp->lt_radius * 
		/*			drand48(); */
			fabs(bn_rand_half(los->ap->a_resource->re_randptr) 
			     * 2.0);
		angle =  M_PI * 2.0 * 
		/*			drand48(); */
			(bn_rand_half(los->ap->a_resource->re_randptr) + 0.5);

		y = radius * bn_tab_sin(angle);

		/* by adding 90 degrees to the angle, the sin of the new
		 * angle becomes the cosine of the old angle.  Thus we
		 * can use the sine table to compute the value, and avoid
		 * the expensive actual computation.  So the next 3 lines
		 * replace:
		 *		x = radius * cos(angle);
		 */
		cos_angle = M_PI_2 + angle;
		if (cos_angle > (2.0*M_PI)) cos_angle -= (2.0*M_PI);
		x = radius * bn_tab_sin(cos_angle);

		VJOIN2(shoot_pt, los->lsp->lt_pos, 
		       x, los->light_x,
		       y, los->light_y);

		if (rdebug & RDEBUG_LIGHT) {
			bu_log("light at (%g %g %g) radius %g\n", 
			       V3ARGS(los->lsp->lt_pos), 
			       los->lsp->lt_radius);

			bu_log("\tshooting at radius %g\n", radius);

			bu_log("\ttarget light point %g %g %g\n",
			       V3ARGS(shoot_pt));
		}
		VSUB2(shoot_dir, shoot_pt, los->swp->sw_hit.hit_point);
d1496 2
d1500 19
a1518 2
	if (rdebug & RDEBUG_LIGHT) {
		VPRINT("shoot_dir", shoot_dir);
d1520 40
d1561 4
d1566 1
a1566 2
	if (rdebug& RDEBUG_RAYPLOT) {
		point_t ray_endpt;
d1568 2
a1569 6
 /* Yelow -- light visibility ray */
		VADD2(ray_endpt, los->swp->sw_hit.hit_point, shoot_dir);
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		pl_color(stdout, 200, 200, 0);
		pdv_3line(stdout, los->swp->sw_hit.hit_point, ray_endpt);
		bu_semaphore_release( BU_SEM_SYSCALL );
d1571 3
d1575 3
a1577 1
	VUNITIZE( shoot_dir );
d1580 2
a1581 11
	/*
	 * See if ray from hit point to light lies within light beam
	 * Note: this is should always be true for infinite lights!
	 */
	if (-VDOT(shoot_dir, los->lsp->lt_aim) < los->lsp->lt_cosangle )  {
		/* dark (outside of light beam) */
		if (rdebug & RDEBUG_LIGHT)
			bu_log("point outside beam, obscured: %s\n",
			       los->lsp->lt_name);
		return 0;
	}
d1583 7
d1591 1
a1591 11
	if (!(los->lsp->lt_shadows) )  {
	       /* "fill light" in beam, don't care about shadows */
		if (rdebug & RDEBUG_LIGHT)
			bu_log("fill light, no shadow, visible: %s\n",
			       los->lsp->lt_name);
#if RT_MULTISPECTRAL
		/* XXX Need a power level for this! */
		bn_tabdata_constval( ((struct bn_tabdata *)los->inten), 1.0);
#else
		VSETALL( ((vectp_t)los->inten), 1 );
#endif
a1592 2
		return -1;
	}
d1594 11
d1607 11
a1617 7
	/*
	 *  Fire ray at light source to check for shadowing.
	 *  (This SHOULD actually return an energy spectrum).
	 *  Advance start point slightly off surface.
	 */
	sub_ap = *los->ap;			/* struct copy */
	RT_CK_AP(&sub_ap);
d1619 2
a1620 20
	VMOVE( sub_ap.a_ray.r_dir, shoot_dir );
	{
		register fastf_t f;
		f = los->ap->a_rt_i->rti_tol.dist;
		VJOIN1( sub_ap.a_ray.r_pt, los->swp->sw_hit.hit_point, f, 
			shoot_dir);
	}
	sub_ap.a_rbeam = los->ap->a_rbeam + 
		los->swp->sw_hit.hit_dist * 
		los->ap->a_diverge;
	sub_ap.a_diverge = los->ap->a_diverge;

	sub_ap.a_hit = light_hit;
	sub_ap.a_miss = light_miss;
	sub_ap.a_user = -1;		/* sanity */
	sub_ap.a_uptr = (genptr_t)los->lsp;	/* so we can tell.. */
	sub_ap.a_level = 0;
	/* Will need entry & exit pts, for filter glass ==> 2 */
	/* Continue going through air ==> negative */
	sub_ap.a_onehit = -2;
a1621 2
	VSETALL( sub_ap.a_color, 1 );	/* vis intens so far */
	sub_ap.a_purpose = los->lsp->lt_name;	/* name of light shot at */
a1622 2
	RT_CK_LIGHT((struct light_specific *)(sub_ap.a_uptr));
	RT_CK_AP(&sub_ap);
d1624 7
a1630 6
	if (rdebug & RDEBUG_LIGHT)
		bu_log("shooting level %d from %d\n",
		       sub_ap.a_level, __LINE__);
	shot_status = rt_shootray( &sub_ap );
	if (rdebug & RDEBUG_LIGHT)
		bu_log("shot_status: %d\n", shot_status);
d1632 50
a1681 17
	if (shot_status < 0) {
		if (los->lsp->lt_infinite) {
		}  else if (los->lsp->lt_pt_count > 0) {
			if (rdebug & RDEBUG_LIGHT) {
				bu_log("was pt %d\n (%g %g %g) normal %g %g %g\n", k,
				       V3ARGS(los->lsp->lt_sample_pts[k].lp_pt),
				       V3ARGS(los->lsp->lt_sample_pts[k].lp_norm) );
			}
		} else {
			if (rdebug & RDEBUG_LIGHT) {
				bu_log("was radius: %g of (%g) angle: %g\n",
				       radius, los->lsp->lt_radius, angle);

				bu_log("re-shooting\n");
			}
			goto retry;
		}
d1683 1
d1685 4
a1688 4
	if (shot_status > 0 )  {
		/* light visible */
		if (rdebug & RDEBUG_LIGHT)
			bu_log("light visible: %s\n", los->lsp->lt_name);
d1691 8
a1698 8
		BN_CK_TABDATA(sub_ap.a_spectrum);
		if (*(los->inten) == BN_TABDATA_NULL) {
			*(los->inten) = sub_ap.a_spectrum;
		} else {
			BN_CK_TABDATA(*(los->inten));
			bn_tabdata_add(*(los->inten),
				       *(los->inten),
				       sub_ap.a_spectrum);
d1700 3
a1702 3
			bn_tabdata_free(sub_ap.a_spectrum);
		}
		sub_ap.a_spectrum = BN_TABDATA_NULL;
d1704 1
a1704 1
		VMOVE( los->inten, sub_ap.a_color );
d1706 5
a1710 5
		return 1;
	}
	/* dark (light obscured) */
	if (rdebug & RDEBUG_LIGHT)
		bu_log("light obscured: %s\n", los->lsp->lt_name);
d1712 1
a1712 1
	return 0;
d1737 26
a1762 17
	register struct light_specific *lsp;
	register int	i;
	register fastf_t *tl_p;
	int vis_ray;
	int tot_vis_rays;
	int visibility;
	struct light_obs_stuff los;
	static int rand_idx;
	char flags[MAX_LIGHT_SAMPLES];

	if (rdebug & RDEBUG_LIGHT )
		bu_log("computing Light obscuration: start\n");

	RT_CK_AP(ap);
	los.rand_idx = &rand_idx;
	los.ap = ap;
	los.swp = swp;
d1764 3
a1766 8
	/*
	 *  Determine light visibility
	 *
	 *  The sw_intensity field does NOT include the light's
	 *  emission spectrum (color), only path attenuation.
	 *  sw_intensity=(1,1,1) for no attenuation.
	 */
	tl_p = swp->sw_tolight;
d1768 3
a1770 3
	i = 0;
	for( BU_LIST_FOR( lsp, light_specific, &(LightHead.l) ) )  {
		RT_CK_LIGHT(lsp);
d1772 2
a1773 6
		if (rdebug & RDEBUG_LIGHT)
			bu_log("computing for light %d\n", i);
		swp->sw_lightfract[i] = 0.0;

		if (lsp->lt_infinite || lsp->lt_shadows == 0) tot_vis_rays = 1;
		else			tot_vis_rays = lsp->lt_shadows;
d1775 1
a1775 1
		los.lsp = lsp;
d1777 2
a1778 2
		if(swp->msw_intensity[i]) BN_CK_TABDATA(swp->msw_intensity[i]);
		los.inten = &swp->msw_intensity[i];
d1780 1
a1780 1
		los.inten = &swp->sw_intensity[3*i];
d1783 4
a1786 4
		/* create a coordinate system about the light center
		 * with the hitpoint->light ray as one of the axes
		 */
		VSUB2(los.to_light_center, lsp->lt_pos, swp->sw_hit.hit_point);
d1788 3
a1790 3
		VUNITIZE(los.to_light_center);
		bn_vec_ortho( los.light_x, los.to_light_center);
		VCROSS(los.light_y, los.to_light_center, los.light_x);
d1792 34
a1825 2
		/*
		 *  If we have a normal, test against light direction
d1827 4
a1830 11
		if ((have & MFI_NORMAL) && (swp->sw_transmit <= 0) )  {
			if (VDOT(swp->sw_hit.hit_normal,
				 los.to_light_center)      < 0 ) {
				/* backfacing, opaque */
				if (rdebug & RDEBUG_LIGHT)
				    bu_log("norm backfacing, opaque surf:%s\n",
					   lsp->lt_name);
				continue;
			}
		}

d1832 16
a1847 46
		memset(flags, 0, sizeof(flags));
		for (vis_ray = 0 ; vis_ray < tot_vis_rays ; vis_ray ++) {
			int lv;
			los.iter = vis_ray;

			if (rdebug & RDEBUG_LIGHT)
				bu_log("----------vis_ray %d---------\n",
				       vis_ray);

			switch (lv = light_vis(&los, flags)) {
			case 1:
				/* remember the last ray that hit */
				VMOVE(tl_p, los.to_light_center);
				visibility++;
				break;
			case -1:
				/* this is our clue to give up on
				 * this light source.  Probably an infinite
				 * point light source.
				 */
				VMOVE(tl_p, los.to_light_center);
				visibility = vis_ray = tot_vis_rays;
				break;
			case -2:
				visibility = 0;
				vis_ray = tot_vis_rays;
				break;
			case 0:	/* light not visible */
				if (rdebug & RDEBUG_LIGHT)
					bu_log("light not visible\n");
				break;
			default:
				bu_log("light_vis = %d\n", lv);
			}
		}
		if (visibility) {
			swp->sw_visible[i] = (char *)lsp;
			swp->sw_lightfract[i] =
				(fastf_t)visibility / (fastf_t)tot_vis_rays;
		} else {
			swp->sw_visible[i] = (char *)0;
		}

		/* Advance to next light */
		tl_p += 3;
		i++;
d1850 6
a1855 1
	if (rdebug & RDEBUG_LIGHT ) bu_log("computing Light obscruration: end\n");
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 1.2 2004/06/09 19:52:43 erikg Exp $ (ARL)";
d808 9
d829 1
a829 1
		MAT4X3VEC( lsp->lt_pos, v2m, temp );
@


1.2
log
@fix some warnings
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/src/liboptical/sh_light.c,v 1.1 2004/05/20 15:19:50 morrison Exp $ (ARL)";
d26 1
a26 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d23 1
a23 1
static const char RCSsh_light[] = "@@(#)$Header: /cvs/brlcad/liboptical/sh_light.c,v 11.86 2004/05/10 15:30:45 erikg Exp $ (ARL)";
d733 1
a733 1
		light_print(rp, lsp);
@

