head	1.28;
access;
symbols
	rel-7-10-4:1.22
	STABLE:1.22.0.2
	rel-7-10-2:1.22
	rel-7-10-0:1.17
	rel-7-8-4:1.9
	rel-7-8-2:1.9
	rel-7-8-0:1.9
	trimnurbs-branch:1.9.0.2
	help:1.9
	temp_tag:1.6
	bobWinPort-20051223-freeze:1.2.2.1
	postmerge-20051223-bobWinPort:1.6
	premerge-20051223-bobWinPort:1.5
	rel-7-6-6:1.5
	rel-7-6-4:1.3
	rel-7-6-2:1.2
	rel-7-6-branch:1.2.0.6
	rel-7-6-0:1.2
	rel-7-4-2:1.2.4.2
	rel-7-4-branch:1.2.0.4
	bobWinPort:1.2.0.2;
locks; strict;
comment	@ * @;


1.28
date	2007.12.04.21.45.24;	author erikgreenwald;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.13.16.21.39;	author bob1961;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.10.15.10.55;	author brlcad;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.04.16.46.52;	author bob1961;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.19.03.54.11;	author brlcad;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.14.15.21.08;	author erikgreenwald;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.18.04.48.12;	author johnranderson;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.20.20.27.37;	author brlcad;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.13.18.51.12;	author brlcad;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.13.07.10.11;	author brlcad;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.07.04.02.23;	author brlcad;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.09.12.54.27;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.02.02.35.32;	author brlcad;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.06.22.28.01;	author brlcad;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.04.21.02.22;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.02.21.13.10;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.27.01.41.43;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.23.01.13.40;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.20.14.36.56;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.18.06.46.18;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.17.06.30.42;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.17.05.54.48;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.17.21.43.16;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.17.20.29.49;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.23.04.44.36;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.25.05.53.06;	author brlcad;	state Exp;
branches
	1.2.2.1
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2005.07.18.05.01.10;	author brlcad;	state Exp;
branches;
next	;

1.2.2.1
date	2005.09.08.16.23.20;	author bob1961;	state Exp;
branches;
next	;

1.2.4.1
date	2005.07.25.05.53.06;	author brlcad;	state dead;
branches;
next	1.2.4.2;

1.2.4.2
date	2005.08.16.21.03.49;	author brlcad;	state Exp;
branches;
next	;

1.2.6.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.28
log
@remove garbage in preprocessor line
@
text
@/*                T C L C A D A U T O P A T H . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file tclcadAutoPath.c
 *
 * Locate the BRL-CAD tclscripts
 *
 * Author --
 *   Christopher Sean Morrison
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>

#include "tcl.h"
#include "tk.h"
#include "itcl.h"

#if !defined(_WIN32) || defined(__CYGWIN__)
#include "itk.h"
#endif

#include "blt.h"

/* incrTcl prior to 3.3 doesn't provide ITK_VERSION */
#ifndef ITK_VERSION
#  define ITK_VERSION ITCL_VERSION
#endif

#include "machine.h"
#include "bu.h"
#include "tclcad.h"

#if defined(_WIN32) && !defined(__CYGWIN__)
#ifdef BU_DIR_SEPARATOR
#undef BU_DIR_SEPARATOR
#endif
#define BU_DIR_SEPARATOR '/'
#endif

#define MAX_BUF 2048


/* helper routine to determine whether the full 'path' includes a
 * directory named 'src'.  this is used to determine whether a
 * particular invocation is being run from the BRL-CAD source
 * directories or from some install directory.
 *
 * returns a pointer to the subpath that contains the 'src' directory.
 * e.g. provided /some/path/to/src/dir/blah will return /some/path/to
 */
static const char *
path_to_src(const char *path)
{
    int i;
    static char buffer[MAX_BUF] = {0};
    char *match = NULL;

    if (!path) {
	return NULL;
    }
    if (strlen(path)+2 > MAX_BUF) {
	/* path won't fit */
	return NULL;
    }

    snprintf(buffer, MAX_BUF, "%s%c", path, BU_DIR_SEPARATOR);

    match = strstr(buffer, "/src/");
    if (match) {
	*(match) = '\0';
	return buffer;
    }
    return NULL;
}


/**
 * debug printing routine for printing out the tcl_library value(s)
 */
void
tclcad_tcl_library(Tcl_Interp *interp)
{
    int cnt = 0;
    int pathcount = 0;
    Tcl_Obj *dir = NULL;
    Tcl_Obj *tclpath = NULL;
    char buffer[MAX_BUF] = {0};

    tclpath = TclGetLibraryPath();
    if (!tclpath) {
	bu_log("WARNING: Unable to get the library path\n");
	return;
    }

    Tcl_IncrRefCount(tclpath);
    Tcl_ListObjLength(NULL, tclpath, &pathcount);
    if (pathcount > 1) {
	bu_log("WARNING: tcl_library is set to multiple paths?\n");
    } else if (pathcount <= 0) {
	if (interp) {
	    const char *setting;
	    snprintf(buffer, MAX_BUF, "set tcl_library");
	    Tcl_Eval(interp, buffer);
	    setting = Tcl_GetStringResult(interp);
	    if (setting && (strlen(setting) > 0)) {
		Tcl_Obj *tcllib = Tcl_NewStringObj(setting, -1);
		Tcl_Obj *listtl = Tcl_NewListObj(1, &tcllib);
		TclSetLibraryPath(listtl);
	    }
	}
	Tcl_DecrRefCount(tclpath);
	tclpath = TclGetLibraryPath();
	Tcl_IncrRefCount(tclpath);
	Tcl_ListObjLength(NULL, tclpath, &pathcount);
	if (pathcount <= 0) {
	    bu_log("WARNING: tcl_library is unset (unexpected)\n");
	}
    }

    for (cnt=0; cnt < pathcount; cnt++) {
	Tcl_ListObjIndex(NULL, tclpath, cnt, &dir);
	Tcl_IncrRefCount(dir);
	if (dir) {
#ifdef DEBUG
	    bu_log("Using Tcl library at %s\n", Tcl_GetString(dir));
#endif
	}
	Tcl_DecrRefCount(dir);
    }
    Tcl_DecrRefCount(tclpath);
}


/**
 * Set up the Tcl auto_path for locating various necessary BRL-CAD
 * scripting resources. Detect whether the current invocation is from
 * an installed binary or not and append to the auto_path accordingly
 * for where the needed tclscript resources should be found.
 *
 ** installed invocation paths
 * BRLCAD_ROOT/lib/tclTCL_VERSION/init.tcl
 * BRLCAD_ROOT/lib/tclTK_VERSION/tk.tcl
 * BRLCAD_ROOT/lib/itclITCL_VERSION/itcl.tcl
 * BRLCAD_ROOT/lib/itkITK_VERSION/itk.tcl
 * BRLCAD_ROOT/lib/iwidgetsIWIDGETS_VERSION/iwidgets.tcl
 * BRLCAD_ROOT/lib/bltBLT_VERSION/pkgIndex.tcl
 * BRLCAD_DATA/tclscripts/pkgIndex.tcl and subdirs
 *
 ** source invocation paths
 * src/other/tcl/library/init.tcl
 * src/other/tk/library/tk.tcl
 * src/other/incrTcl/itcl/library/itcl.tcl
 * src/other/incrTcl/itk/library/itk.tcl
 * src/other/iwidgets/library/iwidgets.tcl
 * src/other/blt/pkgIndex.tcl
 * src/tclscripts/pkgIndex.tcl and subdirs
 *
 * if TCLCAD_LIBRARY_PATH is set
 *   append to search path
 * get installation directory and invocation path
 * if being run from installation directory
 *   add installation paths to search path
 * if being run from source directory
 *   add source paths to search path
 * add installation paths to search path
 */
void
tclcad_auto_path(Tcl_Interp *interp)
{
    struct bu_vls auto_path;
    struct bu_vls lappend;
    const char *library_path = NULL;

    const char *root = NULL;
    const char *data = NULL;
    char buffer[MAX_BUF] = {0};

    const char *which_argv = NULL;
    const char *srcpath = NULL;
    int from_installed = 0;

    Tcl_Obj *tclpath = NULL;

    int found_init_tcl = 0;
    int found_tk_tcl = 0;

    char pathsep[2] = { BU_PATH_SEPARATOR, '\0' };

    if (!interp) {
	/* nothing to do */
	return;
    }

    root = bu_brlcad_root("", 1);
    data = bu_brlcad_data("", 1);


#ifdef _WIN32
    {
	char *cp;

	if (root != (char *)0) {
	    for (cp = root; *cp != '\0'; ++cp)
		if (*cp == '\\') 
		    *cp = '/';
 	}

	if (data != (char *)0) {
	    for (cp = data; *cp != '\0'; ++cp)
		if (*cp == '\\') 
		    *cp = '/';
 	}
     }
#endif

    bu_vls_init(&auto_path);
    bu_vls_init(&lappend);

    /* determine if TCLCAD_LIBRARY_PATH is set */
    library_path = getenv("TCLCAD_LIBRARY_PATH");
    if (library_path) {
	/* it is set, set auto_path. limit buf just because. */
	bu_vls_strncat(&auto_path, library_path, MAX_BUF);
    }

    /* make sure tcl_library path is in the auto_path */
    snprintf(buffer, MAX_BUF, "set tcl_library");
    Tcl_Eval(interp, buffer);
    bu_vls_strncat(&auto_path, Tcl_GetStringResult(interp), MAX_BUF);

    /* get string of invocation binary */
    which_argv = bu_which(bu_argv0_full_path());
    if (!which_argv) {
	which_argv = bu_argv0_full_path();
    }

    /* get name of installation binary */
    snprintf(buffer, MAX_BUF, "%s%cbin%c%s", root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, bu_getprogname());

    /* are we running from an installed binary? if so add to path */
    if (bu_file_exists(buffer) && bu_same_file(buffer, which_argv)) {
	from_installed = 1;
	bu_vls_printf(&auto_path, "%c%s%clib",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%clib%ctcl%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, TCL_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%ctk%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, TK_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%citcl%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, ITCL_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%citk%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, ITK_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%ciwidgets%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, IWIDGETS_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%cblt%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BLT_VERSION);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%clib",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%cutil",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%cmged",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%cgeometree",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%crtwizard",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%carcher",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
    }

    /* are we running uninstalled? */
    srcpath = path_to_src(which_argv);

    /* add search paths for source invocation */
    if (srcpath) {
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%ctcl%cunix",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%ctcl%clibrary",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%ctk%cunix",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%ctk%clibrary",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%cincrTcl",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%cincrTcl%citcl%clibrary",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%cincrTcl%citk%clibrary",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%ciwidgets",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%cother%cblt%clibrary",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%ctclscripts",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%ctclscripts%clib",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%ctclscripts%cutil",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%ctclscripts%cmged",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%ctclscripts%cgeometree",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%ctclscripts%crtwizard",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%csrc%ctclscripts%carcher",
		      BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
    }

    /* add search paths for dist invocation */
    if (srcpath) {
	snprintf(buffer, MAX_BUF, "%s%c..%csrc%cother%ctcl%cunix",
		 srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	if (bu_file_exists(buffer)) {
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%ctcl%cunix",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%ctcl%clibrary",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%ctk%cunix",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%ctk%clibrary",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%cincrTcl",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%cincrTcl%citcl%clibrary",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%cincrTcl%citk%clibrary",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%ciwidgets",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%cblt%clibrary",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%ctclscripts",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%ctclscripts%clib",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%ctclscripts%cutil",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%ctclscripts%cmged",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%ctclscripts%cgeometree",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%ctclscripts%crtwizard",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	    bu_vls_printf(&auto_path, "%c%s%c..%csrc%ctclscripts%carcher",
			  BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	}
    }

    /* be sure to check installation paths even if we aren't running from there */
    if (!from_installed) {
	bu_vls_printf(&auto_path, "%c%s%clib",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%clib%ctcl%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, TCL_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%ctk%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, TK_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%citcl%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, ITCL_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%citk%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, ITK_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%ciwidgets%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, IWIDGETS_VERSION);
	bu_vls_printf(&auto_path, "%c%s%clib%cblt%s",
		      BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BLT_VERSION);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%clib",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%cutil",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%cmged",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%cgeometree",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%crtwizard",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
	bu_vls_printf(&auto_path, "%c%s%ctclscripts%carcher",
		      BU_PATH_SEPARATOR, data, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR);
    }

    /*    printf("AUTO_PATH IS %s\n", bu_vls_addr(&auto_path)); */

    /* iterate over the auto_path list and modify the real Tcl auto_path */
    for (srcpath = strtok(bu_vls_addr(&auto_path), pathsep);
	 srcpath;
	 srcpath = strtok(NULL, pathsep)) {

	/* make sure it exists before appending */
	if (bu_file_exists(srcpath)) {
	    /*		printf("APPENDING: %s\n", srcpath); */
	    bu_vls_sprintf(&lappend, "lappend auto_path \"%s\"", srcpath);
	    (void)Tcl_Eval(interp, bu_vls_addr(&lappend));
	} else {
	    /*		printf("NOT APPENDING: %s\n", srcpath); */
	    continue;
	}

	/* specifically look for init.tcl so we can set tcl_library */
	if (!found_init_tcl) {
	    snprintf(buffer, MAX_BUF, "%s%cinit.tcl", srcpath, BU_DIR_SEPARATOR);
	    if (bu_file_exists(buffer)) {
		/* these doesn't seem to do what one might expect
		 * here, but call it anyways.
		 */
		Tcl_Obj *newpath = Tcl_NewStringObj(srcpath,-1);
		Tcl_IncrRefCount(newpath);
		TclSetLibraryPath(newpath);
		Tcl_DecrRefCount(newpath);

		/* this really sets it */
		snprintf(buffer, MAX_BUF, "set tcl_library \"%s\"", srcpath);
		if (Tcl_Eval(interp, buffer)) {
		    bu_log("Tcl_Eval ERROR:\n%s\n", Tcl_GetStringResult(interp));
		} else {
		    found_init_tcl=1;
		}
	    }
	}

	/* specifically look for tk.tcl so we can set tk_library */
	if (!found_tk_tcl) {
	    snprintf(buffer, MAX_BUF, "%s%ctk.tcl", srcpath, BU_DIR_SEPARATOR);
	    if (bu_file_exists(buffer)) {
		/* this really sets it */
		snprintf(buffer, MAX_BUF, "set tk_library \"%s\"", srcpath);
		if (Tcl_Eval(interp, buffer)) {
		    bu_log("Tcl_Eval ERROR:\n%s\n", Tcl_GetStringResult(interp));
		} else {
		    found_tk_tcl=1;
		}
	    }
	}
    }

    which_argv = NULL;
    bu_vls_free(&auto_path);
    bu_vls_free(&lappend);

    return;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.27
log
@No longer need SEARCH_ARCHER.
@
text
@d218 1
a218 1
#ifdef _WIN32 */
@


1.26
log
@make tclcad_tcl_library() print the path if we're in debug mode, otherwise have it ensure that the library path is actually set (via TclSetLibraryPath() if needed). clean up and remove some of the win32ness
@
text
@d40 1
d42 1
a42 5
#define SEARCH_ARCHER 1
#ifdef SEARCH_ARCHER
#  include "blt.h"
#endif
#endif
a274 1
#ifdef SEARCH_ARCHER
a276 1
#endif
a288 1
#ifdef SEARCH_ARCHER
a290 1
#endif
a313 1
#ifdef SEARCH_ARCHER
a315 1
#endif
a327 1
#ifdef SEARCH_ARCHER
a329 1
#endif
a352 1
#ifdef SEARCH_ARCHER
a354 1
#endif
a366 1
#ifdef SEARCH_ARCHER
a368 1
#endif
a385 1
#ifdef SEARCH_ARCHER
a387 1
#endif
a399 1
#ifdef SEARCH_ARCHER
a401 1
#endif
@


1.25
log
@Mods to get things working on Windows.
@
text
@a64 13
/* #ifdef _WIN32 */
/*     { */
/* 	/\* XXX - nasty little hack to convert paths *\/ */
/* 	int i; */

/* 	strcat(pathname,"/"); */
/* 	for (i = 0; i < strlen(pathname); i++) { */
/* 	    if (pathname[i]=='\\') */
/* 		pathname[i]='/'; */
/* 	} */
/*     } */
/* #endif */

d100 2
a101 1
/** debug printing routine for printing out the tcl_library value(s)
d104 1
a104 1
tclcad_tcl_library(void)
d110 1
d113 5
d123 18
a140 1
	bu_log("WARNING: tcl_library is unset\n");
d142 1
d147 3
a149 1
	    bu_log("tcl_library is %s\n", Tcl_GetString(dir));
a203 1
    char *stp = NULL;
d220 1
d249 5
a425 1
#if defined(_WIN32) && !defined(__CYGWIN__)
a428 5
#else
    for (srcpath = strtok_r(bu_vls_addr(&auto_path), pathsep, &stp);
	 srcpath;
	 srcpath = strtok_r(NULL, pathsep, &stp)) {
#endif
@


1.24
log
@search the archer paths for blt and the archer tclscripts
@
text
@d37 2
d45 1
d54 8
d207 18
d407 5
d415 1
@


1.23
log
@removed trailing whitespace
@
text
@d38 5
a42 1
/*#include "blt.h"*/
d230 4
a233 2
	/*	bu_vls_printf(&auto_path, "%c%s%clib%cblt%s",
		BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BLT_VERSION); */
d246 4
d273 4
a276 2
	/*	bu_vls_printf(&auto_path, "%c%s%csrc%cother%cblt%clibrary",
		BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR); */
d289 4
d316 4
a319 2
	    /*	bu_vls_printf(&auto_path, "%c%s%c..%csrc%cother%cblt%clibrary",
		BU_PATH_SEPARATOR, srcpath, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR); */
d332 4
d353 4
a356 2
	/*	bu_vls_printf(&auto_path, "%c%s%clib%cblt%s",
		BU_PATH_SEPARATOR, root, BU_DIR_SEPARATOR, BU_DIR_SEPARATOR, BLT_VERSION); */
d369 4
@


1.22
log
@Eliminated more instances of direct access of interp->result (not allowed
since tcl 8.0)
@
text
@d176 1
a176 1
    
d375 1
a375 1
		
@


1.21
log
@massive refactoring of the src path handling including avoiding the dynamic atexit memory fugliness.  improve the actual searching for a src dir to not require allocations.  actually only check for init.tcl/tk.tcl one now.  make the entire routine more cross-platform, using BU_DIR_SEPARATOR and BU_PATH_SEPARATOR respectively when building up and searching for paths.
@
text
@d379 1
a379 1
		    bu_log("Tcl_Eval ERROR:\n%s\n", interp->result);
d393 1
a393 1
		    bu_log("Tcl_Eval ERROR:\n%s\n", interp->result);
@


1.20
log
@whereis/which now just take one parameter, the command name, returning the matched result.  no longer need to free anything.
@
text
@d48 1
a48 1
#define MAX_BUF 1024
d64 7
a70 15
static char *path_to_src_buf = NULL;

static void
free_pts_buf()
{
    if (path_to_src_buf) {
	bu_free(path_to_src_buf, "deallocate path_to_src_buf");
	path_to_src_buf = NULL;
    }
}


/* helper routine to determine whether 'path' includes a directory
 * named 'src'.  this is used to determine whether a particular
 * invocation is being run from the BRL-CAD source directories.
d75 3
a77 2
    const char *name = NULL;
    const char *subpath = NULL;
d82 4
a85 1
    free_pts_buf();
d87 1
a87 2
    path_to_src_buf = bu_strdupm(path, "allocate path_to_src_buf");
    atexit(free_pts_buf);
d89 4
a92 13
    subpath = path_to_src_buf;

    do {
	char *temp = bu_strdup(subpath);
	name = bu_basename(temp);
	bu_free(temp, "bu_strdup temp");
	subpath = bu_dirname(subpath);
    } while (name &&
	     (strlen(subpath) > 1) &&
	     (strcmp(name, "src") != 0));

    if (strcmp(name, "src") == 0) {
	return subpath;
d168 2
a169 2
    const char *root = bu_brlcad_root("", 1);
    const char *data = bu_brlcad_data("", 1);
d173 1
a174 1
    const char *srcpath = NULL;
d179 13
d203 4
a206 1
    which_argv = bu_which(bu_argv0(NULL));
d209 1
a209 1
    snprintf(buffer, MAX_BUF, "%s/bin/%s", root, bu_getprogname());
d214 26
a239 13
	bu_vls_printf(&auto_path, ":%s/lib", root);
	bu_vls_printf(&auto_path, ":%s/lib/tcl%s", root, TCL_VERSION);
	bu_vls_printf(&auto_path, ":%s/lib/tk%s", root, TK_VERSION);
	bu_vls_printf(&auto_path, ":%s/lib/itcl%s", root, ITCL_VERSION);
	bu_vls_printf(&auto_path, ":%s/lib/itk%s", root, ITK_VERSION);
	bu_vls_printf(&auto_path, ":%s/lib/iwidgets%s", root, IWIDGETS_VERSION);
	/*	bu_vls_printf(&auto_path, ":%s/lib/blt%s", root, BLT_VERSION); */
	bu_vls_printf(&auto_path, ":%s/tclscripts", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/lib", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/util", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/mged", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/geometree", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/rtwizard", data);
d242 3
a245 1
    srcpath = path_to_src(which_argv);
d247 30
a276 15
	bu_vls_printf(&auto_path, ":%s/src/other/tcl/unix", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/other/tcl/library", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/other/tk/unix", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/other/tk/library", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/other/incrTcl", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/other/incrTcl/itcl/library", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/other/incrTcl/itk/library", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/other/iwidgets", srcpath);
	/*	bu_vls_printf(&auto_path, ":%s/src/other/blt/library", srcpath); */
	bu_vls_printf(&auto_path, ":%s/src/tclscripts", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/tclscripts/lib", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/tclscripts/util", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/tclscripts/mged", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/tclscripts/geometree", srcpath);
	bu_vls_printf(&auto_path, ":%s/src/tclscripts/rtwizard", srcpath);
a279 1
    srcpath = path_to_src(which_argv);
d281 2
a282 1
	snprintf(buffer, MAX_BUF, "%s/../src/other/tcl/unix", srcpath);
d284 30
a313 15
	    bu_vls_printf(&auto_path, ":%s/../src/other/tcl/unix", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/other/tcl/library", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/other/tk/unix", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/other/tk/library", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/other/incrTcl", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/other/incrTcl/itcl/library", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/other/incrTcl/itk/library", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/other/iwidgets", srcpath);
	    /*	bu_vls_printf(&auto_path, ":%s/../src/other/blt/library", srcpath); */
	    bu_vls_printf(&auto_path, ":%s/../src/tclscripts", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/tclscripts/lib", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/tclscripts/util", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/tclscripts/mged", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/tclscripts/geometree", srcpath);
	    bu_vls_printf(&auto_path, ":%s/../src/tclscripts/rtwizard", srcpath);
d319 26
a344 13
	bu_vls_printf(&auto_path, ":%s/lib", root);
	bu_vls_printf(&auto_path, ":%s/lib/tcl%s", root, TCL_VERSION);
	bu_vls_printf(&auto_path, ":%s/lib/tk%s", root, TK_VERSION);
	bu_vls_printf(&auto_path, ":%s/lib/itcl%s", root, ITCL_VERSION);
	bu_vls_printf(&auto_path, ":%s/lib/itk%s", root, ITK_VERSION);
	bu_vls_printf(&auto_path, ":%s/lib/iwidgets%s", root, IWIDGETS_VERSION);
	/*	bu_vls_printf(&auto_path, ":%s/lib/blt%s", root, BLT_VERSION); */
	bu_vls_printf(&auto_path, ":%s/tclscripts", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/lib", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/util", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/mged", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/geometree", data);
	bu_vls_printf(&auto_path, ":%s/tclscripts/rtwizard", data);
d350 1
a350 1
    for (srcpath = strtok_r(bu_vls_addr(&auto_path), ":", &stp);
d352 1
a352 3
	 srcpath = strtok_r(NULL, ":", &stp)) {
	int found_init_tcl = 0;
	int found_tk_tcl = 0;
d366 1
a366 1
	    snprintf(buffer, MAX_BUF, "%s/init.tcl", srcpath);
d388 1
a388 1
	    snprintf(buffer, MAX_BUF, "%s/tk.tcl", srcpath);
@


1.19
log
@only want/need the first, so avoid a two-element array
@
text
@d186 1
a186 1
    char *which_argv = NULL;
d204 1
a204 1
    (void)bu_which(&which_argv, 1, bu_argv0(NULL));
a342 1
    bu_free(which_argv, "which_argv");
a343 1

@


1.18
log
@iwidgets had the wrong auto_path dir being set for build dir invocation.  specifically set tcl_library and tk_library if we find init.tcl and/or tk.tcl respectively in order to further encourage build dir invocation.
@
text
@d186 1
a186 1
    char *which_argv[2] = {NULL, NULL};
d204 1
a204 1
    (void)bu_which(which_argv, 2, bu_argv0(NULL));
d210 1
a210 1
    if (bu_file_exists(buffer) && bu_same_file(buffer, which_argv[0])) {
d228 1
a228 1
    srcpath = path_to_src(which_argv[0]);
d248 1
a248 1
    srcpath = path_to_src(which_argv[0]);
d343 3
@


1.17
log
@use bu_file_exists() instead of Tcl_FSStat() to avoid getting header define/symbol mixups in tcl headers (that seem to be causing a crash at least on some linux due to Tcl_StatBuf getting written past, wrong size)
@
text
@d237 1
a237 1
	bu_vls_printf(&auto_path, ":%s/src/other/iwidgets/library", srcpath);
d259 1
a259 1
	    bu_vls_printf(&auto_path, ":%s/../src/other/iwidgets/library", srcpath);
d293 2
d307 32
a338 14
	snprintf(buffer, MAX_BUF, "%s/init.tcl", srcpath);
	if (bu_file_exists(buffer)) {
	    /* these doesn't seem to do what one might expect
	     * here, but call it anyways.
	     */
	    Tcl_Obj *newpath = Tcl_NewStringObj(srcpath,-1);
	    Tcl_IncrRefCount(newpath);
	    TclSetLibraryPath(newpath);
	    Tcl_DecrRefCount(newpath);

	    /* this really sets it */
	    snprintf(buffer, MAX_BUF, "set tcl_library \"%s\"", srcpath);
	    if (Tcl_Eval(interp, buffer)) {
		bu_log("Tcl_Eval ERROR:\n%s\n", interp->result);
@


1.16
log
@add support for running successfully from a distcheck and identifying the tcl resources.  also set tcl_library so that init.tcl is identified.  add a tclcad_tcl_library() routine for debug printing of what tcl_library is set to.  now only appends to auto_path if the dirs exist.
@
text
@a292 3
	Tcl_StatBuf stat;
	Tcl_Obj *newpath = Tcl_NewStringObj(srcpath,-1);
	Tcl_IncrRefCount(newpath);
d294 2
a295 2
	/* make sure it exists as a directory before appending */
	if ((0 == Tcl_FSStat(newpath, &stat)) && S_ISDIR(stat.st_mode)) {
d310 2
d313 1
a320 1
	Tcl_DecrRefCount(newpath);
@


1.15
log
@use bu_basename(), no longer need libgen.h
@
text
@d83 2
a84 2
    const char *name;
    const char *subpath;
d95 1
d112 30
d190 2
d247 23
d287 2
d293 29
a321 2
	bu_vls_sprintf(&lappend, "lappend auto_path \"%s\"", srcpath);
	(void)Tcl_Eval(interp, bu_vls_addr(&lappend));
@


1.14
log
@incrTcl prior to 3.3 apparently didn't provide ITK_VERSION, so accommodate.  also quell warning about basename() taking non-const paths on linux.
@
text
@a32 3
#ifdef HAVE_LIBGEN_H
#  include <libgen.h>
#endif
d97 1
a97 1
	name = basename(temp);
@


1.13
log
@complete rewrite of the auto_path handling code in support of the forthcoming tcl/tk upgrade (8.5a5).  the logic is entirely changed so that less arbitrary searching is performed.  now the routine attempts to detect whether it's being run from a source directory or from an installed location, and allowing TCLCAD_LIBRARY_PATH to be obeyed for additional paths.  this needs tweaking/testing on other platforms, but the overall approach is a vast improvement to the previous.
@
text
@d43 5
d97 1
a97 1
    subpath = path;
d99 3
a101 1
	name = basename(subpath);
@


1.12
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d31 1
d33 10
a44 2
#include "tclcad.h"
#include "tk.h"
d46 1
d48 12
a59 26
void
tclcad_auto_path(Tcl_Interp *interp)
{
    static const int SEARCH_DEPTH = 7;
    struct bu_vls str;
    char *pathname;

    /****************************************************/
    /* Locate the BRL-CAD-specific Tcl scripts quietly. */
    /****************************************************/
    pathname = bu_brlcad_data( "tclscripts", 1 );

    bu_vls_init(&str);
    if (pathname) {
#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	register int i;

	strcat(pathname,"/");
	for (i = 0; i < strlen(pathname); i++) {
	    if (pathname[i]=='\\')
		pathname[i]='/';
	}
    }
#endif
a60 40
	bu_vls_sprintf(&str, "lappend auto_path \"%s\" \"%s/lib\" \"%s/util\" \"%s/mged\" \"%s/geometree\"",
		      pathname, pathname, pathname, pathname, pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
    } else {
	int i, j;
	struct bu_vls prefix, base;

	/* hunt for the tclscripts since we're probably just not
	 * installed yet.  must go at least as many levels deep as the
	 * src/tclscripts hierarchy.
	 */
	bu_log("WARNING: BRL-CAD %s is apparently not installed yet.\n", BRLCAD_VERSION);

	bu_vls_init(&prefix);
	bu_vls_init(&base);

	/* go up to SEARCH_DEPTH levels deep */
	bu_vls_sprintf(&base, "src/tclscripts");
	for (i = 0; i < SEARCH_DEPTH; i++) {
	    bu_vls_trunc(&prefix, 0);
	    for (j=0; j < i; j++) {
		bu_vls_printf(&prefix, "../");
	    }
	    bu_vls_sprintf(&str, "%S%S", &prefix, &base);
	    if (bu_file_exists(bu_vls_addr(&str))) {
		bu_vls_sprintf(&str, "lappend auto_path \"%S%S\" \"%S%S/lib\" \"%S%S/util\" \"%S%S/mged\" \"%S%S/geometree\" \"%S%S/rtwizard\"",
			      &prefix, &base, &prefix, &base, &prefix, &base, &prefix, &base, &prefix, &base, &prefix, &base);
		/* make sure tcl's scripts are in the path */
		(void)Tcl_Eval(interp, bu_vls_addr(&str));
		break;
	    }
	}

	if (i >= SEARCH_DEPTH) {
	    /* fail noisily */
	    (void)bu_brlcad_data("tclscripts", 0);
	}
	bu_vls_free(&prefix);
	bu_vls_free(&base);
    }
d62 1
d64 6
a69 17
    /*******************************************/
    /* make sure tcl's scripts are in the path */
    /*******************************************/
    bu_vls_sprintf(&str, "lib/tcl%s", TCL_VERSION);
    pathname = bu_brlcad_root( bu_vls_addr(&str), 1 );

    if (pathname) {
#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	register int i;

	strcat(pathname,"/");
	for (i = 0; i < strlen(pathname); i++) {
	    if (pathname[i]=='\\')
		pathname[i]='/';
	}
d71 1
a71 1
#endif
a72 42
	bu_vls_sprintf(&str, "lappend auto_path \"%s\"", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
	bu_vls_sprintf(&str, "set tcl_library %s", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
    } else {
	int i, j;
	struct bu_vls prefix, base;

	/* hunt for the tcl library since we're probably just not
	 * installed yet.
	 */

	bu_vls_init(&prefix);
	bu_vls_init(&base);

	/* go up to SEARCH_DEPTH levels deep */
	bu_vls_sprintf(&base, "src/other/libtcl/library");
	for (i = 0; i < SEARCH_DEPTH; i++) {
	    bu_vls_trunc(&prefix, 0);
	    for (j=0; j < i; j++) {
		bu_vls_printf(&prefix, "../");
	    }
	    bu_vls_sprintf(&str, "%S%S", &prefix, &base);
	    if (bu_file_exists(bu_vls_addr(&str))) {
		bu_vls_sprintf(&str, "lappend auto_path \"%S%S\"", &prefix, &base);
		(void)Tcl_Eval(interp, bu_vls_addr(&str));
		bu_vls_sprintf(&str, "set tcl_library \"%S%S\"", &prefix, &base);
		(void)Tcl_Eval(interp, bu_vls_addr(&str));
		break;
	    }
	}

	if (i >= SEARCH_DEPTH) {
	    /* fail noisily */
	    bu_vls_sprintf(&str, "lib/tcl%s", TCL_VERSION);
	    (void)bu_brlcad_data(bu_vls_addr(&str), 0);
	}
	bu_vls_free(&prefix);
	bu_vls_free(&base);
    }
    bu_vls_sprintf(&str, "set tcl_version %s", TCL_VERSION);
    (void)Tcl_Eval(interp, bu_vls_addr(&str));
d74 9
d84 2
a85 16
    /******************************************/
    /* make sure tk's scripts are in the path */
    /******************************************/
    bu_vls_sprintf(&str, "lib/tk%s", TK_VERSION);
    pathname = bu_brlcad_root( bu_vls_addr(&str), 1 );
    if (pathname) {
#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	int i;

	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
	    if(pathname[i]=='\\')
		pathname[i]='/';
	}
d87 1
a87 1
#endif
d89 2
a90 42
	bu_vls_sprintf(&str, "lappend auto_path \"%s\"", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
	bu_vls_sprintf(&str, "set tk_library %s", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
    } else {
	int i, j;
	struct bu_vls prefix, base;

	/* hunt for the tk library since we're probably just not
	 * installed yet.
	 */

	bu_vls_init(&prefix);
	bu_vls_init(&base);

	/* go up to SEARCH_DEPTH levels deep */
	bu_vls_sprintf(&base, "src/other/libtk/library");
	for (i = 0; i < SEARCH_DEPTH; i++) {
	    bu_vls_trunc(&prefix, 0);
	    for (j=0; j < i; j++) {
		bu_vls_printf(&prefix, "../");
	    }
	    bu_vls_sprintf(&str, "%S%S", &prefix, &base);
	    if (bu_file_exists(bu_vls_addr(&str))) {
		bu_vls_sprintf(&str, "lappend auto_path \"%S%S\"", &prefix, &base);
		(void)Tcl_Eval(interp, bu_vls_addr(&str));
		bu_vls_sprintf(&str, "set tk_library \"%S%S\"", &prefix, &base);
		(void)Tcl_Eval(interp, bu_vls_addr(&str));
		break;
	    }
	}

	if (i >= SEARCH_DEPTH) {
	    /* fail noisily */
	    bu_vls_sprintf(&str, "lib/tk%s", TK_VERSION);
	    (void)bu_brlcad_data(bu_vls_addr(&str), 0);
	}
	bu_vls_free(&prefix);
	bu_vls_free(&base);
    }
    bu_vls_sprintf(&str, "set tk_version %s", TK_VERSION);
    (void)Tcl_Eval(interp, bu_vls_addr(&str));
d92 7
d100 2
a101 16
    /***********************************************/
    /* make sure iwidget's scripts are in the path */
    /***********************************************/
    bu_vls_sprintf(&str, "lib/iwidgets%s", IWIDGETS_VERSION);
    pathname = bu_brlcad_root( bu_vls_addr(&str), 1 );
    if (pathname) {
#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	int i;

	strcat(pathname,"/");
	for (i = 0; i < strlen(pathname); i++) {
	    if (pathname[i]=='\\')
		pathname[i]='/';
	}
d103 3
a105 1
#endif
d107 126
a232 39
	bu_vls_sprintf(&str, "lappend auto_path \"%s\"", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
	bu_vls_sprintf(&str, "set iwidgets_library %s", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
    } else {
	int i, j;
	struct bu_vls prefix, base;

	/* hunt for the tk library since we're probably just not
	 * installed yet.
	 */

	bu_vls_init(&prefix);
	bu_vls_init(&base);

	/* go up to SEARCH_DEPTH levels deep */
	bu_vls_sprintf(&base, "src/other/iwidgets");
	for (i = 0; i < SEARCH_DEPTH; i++) {
	    bu_vls_trunc(&prefix, 0);
	    for (j=0; j < i; j++) {
		bu_vls_printf(&prefix, "../");
	    }
	    bu_vls_sprintf(&str, "%S%S", &prefix, &base);
	    if (bu_file_exists(bu_vls_addr(&str))) {
		bu_vls_sprintf(&str, "lappend auto_path \"%S%S\"", &prefix, &base);
		(void)Tcl_Eval(interp, bu_vls_addr(&str));
		bu_vls_sprintf(&str, "set iwidgets_library \"%S%S\"", &prefix, &base);
		(void)Tcl_Eval(interp, bu_vls_addr(&str));
		break;
	    }
	}

	if (i >= SEARCH_DEPTH) {
	    /* fail noisily */
	    bu_vls_sprintf(&str, "lib/iwidgets%s", IWIDGETS_VERSION);
	    (void)bu_brlcad_data(bu_vls_addr(&str), 0);
	}
	bu_vls_free(&prefix);
	bu_vls_free(&base);
a233 2
    bu_vls_sprintf(&str, "set iwidgets_version %s", IWIDGETS_VERSION);
    (void)Tcl_Eval(interp, bu_vls_addr(&str));
d235 2
a236 1
    bu_vls_free(&str);
@


1.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d49 1
a49 1
    
d59 1
a59 1
	    if (pathname[i]=='\\') 
d93 1
a93 1
		(void)Tcl_Eval(interp, bu_vls_addr(&str)); 
d121 1
a121 1
	    if (pathname[i]=='\\') 
d152 1
a152 1
		(void)Tcl_Eval(interp, bu_vls_addr(&str)); 
d154 1
a154 1
		(void)Tcl_Eval(interp, bu_vls_addr(&str)); 
d184 1
a184 1
	    if(pathname[i]=='\\') 
d215 1
a215 1
		(void)Tcl_Eval(interp, bu_vls_addr(&str)); 
d217 1
a217 1
		(void)Tcl_Eval(interp, bu_vls_addr(&str)); 
d247 1
a247 1
	    if (pathname[i]=='\\') 
d278 1
a278 1
		(void)Tcl_Eval(interp, bu_vls_addr(&str)); 
d280 1
a280 1
		(void)Tcl_Eval(interp, bu_vls_addr(&str)); 
@


1.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


1.9
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


1.8
log
@revert
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


1.7
log
@fix the manpage commments via s/\.\/"/.\\\"/g
@
text
@d87 1
a87 1
		bu_vls_printf(&prefix, "..\");
d148 1
a148 1
		bu_vls_printf(&prefix, "..\");
d211 1
a211 1
		bu_vls_printf(&prefix, "..\");
d274 1
a274 1
		bu_vls_printf(&prefix, "..\");
@


1.6
log
@Merge of bobWinPort
@
text
@d87 1
a87 1
		bu_vls_printf(&prefix, "../");
d148 1
a148 1
		bu_vls_printf(&prefix, "../");
d211 1
a211 1
		bu_vls_printf(&prefix, "../");
d274 1
a274 1
		bu_vls_printf(&prefix, "../");
@


1.5
log
@s/not apparently/apparently not/
@
text
@d32 1
d35 2
a45 2
    bu_vls_init(&str);

d50 2
d53 13
d113 1
d115 13
d178 13
d241 13
@


1.4
log
@rewrite tclcad_auto_path() to search somewhat more intelligently and consistently when brl-cad hasn't been installed yet.  search up to SEARCH_DEPTH levels (currently 7) so deep tclscript paths will ami.tcl correctly (presently 4 or 5 levels required)
@
text
@d61 1
a61 1
	bu_log("WARNING: BRL-CAD %s is not apparently installed yet.\n", BRLCAD_VERSION);
@


1.3
log
@trailing ws
@
text
@d39 1
d43 3
d47 1
a48 13

#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	int i;
	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
	    if(pathname[i]=='\\')
		pathname[i]='/'; }
    }
#endif

    bu_vls_init(&str);
d50 1
a50 1
	bu_vls_printf(&str, "lappend auto_path \"%s\" \"%s/lib\" \"%s/util\" \"%s/mged\" \"%s/geometree\"",
d54 7
a60 1
	/* hunt for the tclscripts since we're probably just not installed yet */
d62 22
a83 13
	if (bu_file_exists("./tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path tclscripts tclscripts/lib tclscripts/util tclscripts/mged tclscripts/geometree");
	} else if (bu_file_exists("../tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../tclscripts ../tclscripts/lib ../tclscripts/util ../tclscripts/mged ../tclscripts/geometree");
	} else if (bu_file_exists("src/tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path src/tclscripts src/tclscripts/lib src/tclscripts/util src/tclscripts/mged src/tclscripts/geometree");
	} else if (bu_file_exists("../src/tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../src/tclscripts ../src/tclscripts/lib ../src/tclscripts/util ../src/tclscripts/mged ../src/tclscripts/geometree");
	} else if (bu_file_exists("../../src/tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../src/tclscripts ../../src/tclscripts/lib ../../src/tclscripts/util ../../src/tclscripts/mged ../../src/tclscripts/geometree");
	} else if (bu_file_exists("../../../src/tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../../src/tclscripts ../../../src/tclscripts/lib ../../../src/tclscripts/util ../../../src/tclscripts/mged ../../../src/tclscripts/geometree");
	} else {
d87 2
d91 2
d94 2
a95 2
    bu_vls_trunc(&str, 0);
    bu_vls_printf(&str, "lib/tcl%s", TCL_VERSION);
d98 1
a98 1
	bu_vls_printf(&str, "lappend auto_path \"%s\"", pathname);
d100 1
a100 1
	bu_vls_printf(&str, "set tcl_library %s", pathname);
d103 28
a130 20
	/* hunt for the tclscripts since we're probably just not installed yet */
	if (bu_file_exists("./other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ./other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ./other/libtcl/library");
	} else if (bu_file_exists("../other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ../other/libtcl/library");
	} else if (bu_file_exists("src/other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path src/other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library src/other/libtcl/library");
	} else if (bu_file_exists("../src/other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../src/other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ../src/other/libtcl/library");
	} else if (bu_file_exists("../../src/other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../src/other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ../../src/other/libtcl/library");
	} else if (bu_file_exists("../../../src/other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../../src/other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ../../../src/other/libtcl/library");
	} else {
d132 1
a132 1
	    bu_vls_printf(&str, "lib/tcl%s", TCL_VERSION);
d135 2
d138 1
a138 1
    bu_vls_printf(&str, "set tcl_version %s", TCL_VERSION);
d142 1
d144 2
a145 2
    bu_vls_trunc(&str, 0);
    bu_vls_printf(&str, "lib/tk%s", TK_VERSION);
d148 1
a148 1
	bu_vls_printf(&str, "lappend auto_path \"%s\"", pathname);
d150 1
a150 1
	bu_vls_printf(&str, "set tk_library %s", pathname);
d153 28
a180 20
	/* hunt for the tclscripts since we're probably just not installed yet */
	if (bu_file_exists("./other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ./other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ./other/libtk/library");
	} else if (bu_file_exists("../other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ../other/libtk/library");
	} else if (bu_file_exists("src/other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path src/other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library src/other/libtk/library");
	} else if (bu_file_exists("../src/other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../src/other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ../src/other/libtk/library");
	} else if (bu_file_exists("../../src/other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../src/other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ../../src/other/libtk/library");
	} else if (bu_file_exists("../../../src/other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../../src/other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ../../../src/other/libtk/library");
	} else {
d182 1
a182 1
	    bu_vls_printf(&str, "lib/tk%s", TK_VERSION);
d185 2
d188 1
a188 1
    bu_vls_printf(&str, "set tk_version %s", TK_VERSION);
d191 2
d194 2
a195 2
    bu_vls_trunc(&str, 0);
    bu_vls_printf(&str, "lib/iwidgets%s", IWIDGETS_VERSION);
d198 1
a198 1
	bu_vls_printf(&str, "lappend auto_path \"%s\"", pathname);
d200 1
a200 1
	bu_vls_printf(&str, "set iwidgets_library %s", pathname);
d203 28
a230 20
	/* hunt for the tclscripts since we're probably just not installed yet */
	if (bu_file_exists("./other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ./other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ./other/iwidgets");
	} else if (bu_file_exists("../other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ../other/iwidgets");
	} else if (bu_file_exists("src/other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path src/other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library src/other/iwidgets");
	} else if (bu_file_exists("../src/other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../src/other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ../src/other/iwidgets");
	} else if (bu_file_exists("../../src/other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../src/other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ../../src/other/iwidgets");
	} else if (bu_file_exists("../../../src/other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../../src/other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ../../../src/other/iwidgets");
	} else {
d232 1
a232 1
	    bu_vls_printf(&str, "lib/iwidgets%s", IWIDGETS_VERSION);
d235 2
d238 1
a238 1
    bu_vls_printf(&str, "set iwidgets_version %s", IWIDGETS_VERSION);
@


1.2
log
@set the tcl_library, tk_library, and iwidgets_library variables both to continue the quest of a relocateable mged/bwish.  fix an oversight on tclscripts searching while we're at it.
@
text
@d2 1
a2 1
 * BRL-CAD            
d44 1
a44 1
    
d51 1
a51 1
	    if(pathname[i]=='\\') 
d58 1
a58 1
	bu_vls_printf(&str, "lappend auto_path \"%s\" \"%s/lib\" \"%s/util\" \"%s/mged\" \"%s/geometree\"", 
d119 1
a119 1
    
@


1.2.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d2 1
a2 1
 * BRL-CAD
d44 1
a44 1

d51 1
a51 1
	    if(pathname[i]=='\\')
d58 1
a58 1
	bu_vls_printf(&str, "lappend auto_path \"%s\" \"%s/lib\" \"%s/util\" \"%s/mged\" \"%s/geometree\"",
d119 1
a119 1

@


1.2.2.1
log
@Mods for windows port
@
text
@a31 1
#include <stdio.h>
a33 2
#include "tclcad.h"
#include "tk.h"
a44 2
    bu_vls_init(&str);
    if (pathname) {
a48 1

d52 1
a52 2
		pathname[i]='/';
	}
d56 2
a86 13
#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	int i;

	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
	    if(pathname[i]=='\\') 
		pathname[i]='/';
	}
    }
#endif

a125 13
#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	int i;

	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
	    if(pathname[i]=='\\') 
		pathname[i]='/';
	}
    }
#endif

a163 13
#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	int i;

	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
	    if(pathname[i]=='\\') 
		pathname[i]='/';
	}
    }
#endif

@


1.2.4.1
log
@file tclcadAutoPath.c was added on branch rel-7-4-branch on 2005-08-16 21:03:49 +0000
@
text
@d1 210
@


1.2.4.2
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@a0 210
/*                T C L C A D A U T O P A T H . C
 * BRL-CAD            
 *
 * Copyright (C) 2004-2005 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file tclcadAutoPath.c
 *
 * Locate the BRL-CAD tclscripts
 *
 * Author --
 *   Christopher Sean Morrison
 */

#include "common.h"

#include "machine.h"
#include "bu.h"


void
tclcad_auto_path(Tcl_Interp *interp)
{
    struct bu_vls str;
    char *pathname;

    /* Locate the BRL-CAD-specific Tcl scripts quietly. */
    pathname = bu_brlcad_data( "tclscripts", 1 );
    
#ifdef _WIN32
    {
	/* XXX - nasty little hack to convert paths */
	int i;
	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
	    if(pathname[i]=='\\') 
		pathname[i]='/'; }
    }
#endif

    bu_vls_init(&str);
    if (pathname) {
	bu_vls_printf(&str, "lappend auto_path \"%s\" \"%s/lib\" \"%s/util\" \"%s/mged\" \"%s/geometree\"", 
		      pathname, pathname, pathname, pathname, pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
    } else {
	/* hunt for the tclscripts since we're probably just not installed yet */
	bu_log("WARNING: BRL-CAD %s is not apparently installed yet.\n", BRLCAD_VERSION);
	if (bu_file_exists("./tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path tclscripts tclscripts/lib tclscripts/util tclscripts/mged tclscripts/geometree");
	} else if (bu_file_exists("../tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../tclscripts ../tclscripts/lib ../tclscripts/util ../tclscripts/mged ../tclscripts/geometree");
	} else if (bu_file_exists("src/tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path src/tclscripts src/tclscripts/lib src/tclscripts/util src/tclscripts/mged src/tclscripts/geometree");
	} else if (bu_file_exists("../src/tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../src/tclscripts ../src/tclscripts/lib ../src/tclscripts/util ../src/tclscripts/mged ../src/tclscripts/geometree");
	} else if (bu_file_exists("../../src/tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../src/tclscripts ../../src/tclscripts/lib ../../src/tclscripts/util ../../src/tclscripts/mged ../../src/tclscripts/geometree");
	} else if (bu_file_exists("../../../src/tclscripts")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../../src/tclscripts ../../../src/tclscripts/lib ../../../src/tclscripts/util ../../../src/tclscripts/mged ../../../src/tclscripts/geometree");
	} else {
	    /* fail noisily */
	    (void)bu_brlcad_data("tclscripts", 0);
	}
    }

    /* make sure tcl's scripts are in the path */
    bu_vls_trunc(&str, 0);
    bu_vls_printf(&str, "lib/tcl%s", TCL_VERSION);
    pathname = bu_brlcad_root( bu_vls_addr(&str), 1 );
    if (pathname) {
	bu_vls_printf(&str, "lappend auto_path \"%s\"", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
	bu_vls_printf(&str, "set tcl_library %s", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
    } else {
	/* hunt for the tclscripts since we're probably just not installed yet */
	if (bu_file_exists("./other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ./other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ./other/libtcl/library");
	} else if (bu_file_exists("../other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ../other/libtcl/library");
	} else if (bu_file_exists("src/other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path src/other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library src/other/libtcl/library");
	} else if (bu_file_exists("../src/other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../src/other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ../src/other/libtcl/library");
	} else if (bu_file_exists("../../src/other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../src/other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ../../src/other/libtcl/library");
	} else if (bu_file_exists("../../../src/other/libtcl/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../../src/other/libtcl/library");
	    (void)Tcl_Eval(interp, "set tcl_library ../../../src/other/libtcl/library");
	} else {
	    /* fail noisily */
	    bu_vls_printf(&str, "lib/tcl%s", TCL_VERSION);
	    (void)bu_brlcad_data(bu_vls_addr(&str), 0);
	}
    }
    bu_vls_printf(&str, "set tcl_version %s", TCL_VERSION);
    (void)Tcl_Eval(interp, bu_vls_addr(&str));
    

    /* make sure tk's scripts are in the path */
    bu_vls_trunc(&str, 0);
    bu_vls_printf(&str, "lib/tk%s", TK_VERSION);
    pathname = bu_brlcad_root( bu_vls_addr(&str), 1 );
    if (pathname) {
	bu_vls_printf(&str, "lappend auto_path \"%s\"", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
	bu_vls_printf(&str, "set tk_library %s", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
    } else {
	/* hunt for the tclscripts since we're probably just not installed yet */
	if (bu_file_exists("./other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ./other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ./other/libtk/library");
	} else if (bu_file_exists("../other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ../other/libtk/library");
	} else if (bu_file_exists("src/other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path src/other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library src/other/libtk/library");
	} else if (bu_file_exists("../src/other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../src/other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ../src/other/libtk/library");
	} else if (bu_file_exists("../../src/other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../src/other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ../../src/other/libtk/library");
	} else if (bu_file_exists("../../../src/other/libtk/library")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../../src/other/libtk/library");
	    (void)Tcl_Eval(interp, "set tk_library ../../../src/other/libtk/library");
	} else {
	    /* fail noisily */
	    bu_vls_printf(&str, "lib/tk%s", TK_VERSION);
	    (void)bu_brlcad_data(bu_vls_addr(&str), 0);
	}
    }
    bu_vls_printf(&str, "set tk_version %s", TK_VERSION);
    (void)Tcl_Eval(interp, bu_vls_addr(&str));

    /* make sure iwidget's scripts are in the path */
    bu_vls_trunc(&str, 0);
    bu_vls_printf(&str, "lib/iwidgets%s", IWIDGETS_VERSION);
    pathname = bu_brlcad_root( bu_vls_addr(&str), 1 );
    if (pathname) {
	bu_vls_printf(&str, "lappend auto_path \"%s\"", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
	bu_vls_printf(&str, "set iwidgets_library %s", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
    } else {
	/* hunt for the tclscripts since we're probably just not installed yet */
	if (bu_file_exists("./other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ./other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ./other/iwidgets");
	} else if (bu_file_exists("../other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ../other/iwidgets");
	} else if (bu_file_exists("src/other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path src/other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library src/other/iwidgets");
	} else if (bu_file_exists("../src/other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../src/other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ../src/other/iwidgets");
	} else if (bu_file_exists("../../src/other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../src/other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ../../src/other/iwidgets");
	} else if (bu_file_exists("../../../src/other/iwidgets")) {
	    (void)Tcl_Eval(interp, "lappend auto_path ../../../src/other/iwidgets");
	    (void)Tcl_Eval(interp, "set iwidgets_library ../../../src/other/iwidgets");
	} else {
	    /* fail noisily */
	    bu_vls_printf(&str, "lib/iwidgets%s", IWIDGETS_VERSION);
	    (void)bu_brlcad_data(bu_vls_addr(&str), 0);
	}
    }
    bu_vls_printf(&str, "set iwidgets_version %s", IWIDGETS_VERSION);
    (void)Tcl_Eval(interp, bu_vls_addr(&str));

    bu_vls_free(&str);

    return;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.1
log
@add tclcadAutoPath.c which includes a routine for adding the brl-cad tclscripts to the tcl auto_path.
@
text
@d65 1
a65 1
	    (void)Tcl_Eval(interp, "lappend auto_path tclscripts tclscripts/lib tclscripts/util tclscripts/mged tclscripts/geometree src/tclscripts src/tclscripts/lib src/tclscripts/util src/tclscripts/mged src/tclscripts/geometree ../tclscripts ../tclscripts/lib ../tclscripts/util ../tclscripts/mged ../tclscripts/geometree ../src/tclscripts ../src/tclscripts/lib ../src/tclscripts/util ../src/tclscripts/mged ../src/tclscripts/geometree ../../tclscripts ../../tclscripts/lib ../../tclscripts/util ../../tclscripts/mged ../../tclscripts/geometree ../../src/tclscripts ../../src/tclscripts/lib ../../src/tclscripts/util ../../src/tclscripts/mged ../../src/tclscripts/geometree");
d81 116
@

