head	1.14;
access;
symbols
	rel-7-10-4:1.9
	STABLE:1.9.0.2
	rel-7-10-2:1.9
	rel-7-10-0:1.7;
locks; strict;
comment	@// @;


1.14
date	2007.10.29.05.25.44;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.18.09.11.56;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.16.17.04.36;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.15.16.23.05;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.14.15.21.03;	author erikgreenwald;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.26.01.13.52;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.18.04.13.47;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.22.21.19.19;	author mjgillich;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.02.08.48.29;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.27.01.41.33;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.23.01.13.27;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.20.14.36.48;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.07.23.13.48;	author mjgillich;	state Exp;
branches;
next	;


desc
@@


1.14
log
@more flawfinding quellage and bu_exiting
@
text
@/*                         G - S A T . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file g-sat.cxx
 *
 *      C++ code for converting BRL-CAD models to the ACIS SAT format for importing into CUBIT.
 *      This code assumes that your receiving format can handle CSG primitives
 *      and Boolean trees with transformation matrices
 *
 *  Author -
 *	Michael J. Gillich
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.13 2007/10/18 09:11:56 brlcad Exp $";
#endif

#include "common.h"

// system headers
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <map>
#include <vector>
#include <stack>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

// CGM headers
#include "NoAcisQueryEngine.hpp"
#include "NoAcisModifyEngine.hpp"
#include "GeometryQueryTool.hpp"
#include "GeometryModifyTool.hpp"
#include "AppUtil.hpp"
#include "CGMApp.hpp"
#include "CastTo.hpp"
#include "Body.hpp"
#include "RefEntity.hpp"
#include "RefEntityName.hpp"
#include "CubitAttrib.hpp"
#include "CubitAttribManager.hpp"

// interface headers
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "bu.h"
#include "raytrace.h"
#include "wdb.h"
//#include "../librt/debug.h"

using namespace std;


const int NUM_OF_CPUS_TO_USE = 1;

const int DEBUG_NAMES = 1;
const int DEBUG_STATS = 2;

const long debug = 1;
int verbose = 0;

static  db_i		*dbip;

static  rt_tess_tol     ttol;   /* tesselation tolerance in mm */
static  bn_tol          tol;    /* calculation tolerance */

// Global map for bodies names in the CGM global list
map<string, int> g_body_id_map;
map<string, int>::iterator g_itr;

int g_body_cnt = 0;

vector <string> g_CsgBoolExp;

// Function prototypes for access of the global map above.
void set_body_id( string body_name, int body_id );
int get_body_id( string body_name );

void usage( char* s);
int parse_args( int ac, char *av[]);
int region_start ( db_tree_state *tsp,  db_full_path *pathp, const  rt_comb_internal * combp, genptr_t client_data );
tree *region_end ( db_tree_state *tsp,  db_full_path *pathp, tree *curtree, genptr_t client_data );
tree *primitive_func( db_tree_state *tsp,  db_full_path *pathp, rt_db_internal *ip, genptr_t client_data);
void describe_tree( tree *tree,  bu_vls *str);
void output_triangles( nmgregion *r, model *m, shell *s);
bool make_bot( nmgregion *r, model *m, shell *s);
tree *booltree_evaluate(tree *tp, resource *resp);

string infix_to_postfix(string str);
void tokenize(const string& str, vector<string>& tokens, const string& delimiters);

/* declarations to support use of getopt() system call */
extern char *optarg;
extern int optind, opterr, getopt(int, char *const *, const char *);

char *usage_msg = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
char *options = "t:a:n:o:r:vx:X:";
char *prog_name = NULL;
char *output_file = NULL;

/*
 *			M A I N
 */
int
main(int argc, char *argv[])
{
    struct user_data {
	int info;
    } user_data;

    int		i;
    register int	c;
    char idbuf[132];

    int arg_count;
    const int MIN_NUM_OF_ARGS = 2;

    bu_setlinebuf( stderr );

    rt_init_resource(&rt_uniresource, 0, NULL);

    rt_i *rtip;
    db_tree_state init_state;

    /* calculational tolerances mostly used by NMG routines */
    tol.magic = BN_TOL_MAGIC;
    tol.dist = 0.005;
    tol.dist_sq = tol.dist * tol.dist;
    tol.perp =1e-6;
    tol.para = 1 - tol.perp;

    /* Defaults, updated by command line options. */
    ttol.abs = 0.0;
    ttol.rel = 0.01;
    ttol.norm = 0.0;


    /* parse command line arguments. */
    arg_count = parse_args( argc, argv );

    if ( (argc - arg_count) < MIN_NUM_OF_ARGS ) {
	usage("Error: Must specify model and objects on the command line\n");
    }

    // ***********************************************************************************
    // Setup Cubit Routines
    // ***********************************************************************************

    // CGM Initialization
    const char* ACIS_SAT = "ACIS_SAT";
    const char* OUTPUT_FILE = "test.sat";

    int dummy_argc = 0;
    char **dummy_argv =NULL;

    // Initialize the application
    AppUtil::instance()->startup(dummy_argc, dummy_argv);
    CGMApp::instance()->startup(dummy_argc, dummy_argv);

    CGMApp::instance()->attrib_manager()->auto_flag(true);

    // Create the geometry modify and query tool
    GeometryModifyTool *gmt = GeometryModifyTool::instance();
    GeometryQueryTool *gqt = GeometryQueryTool::instance();

    // Create the  ACIS engines
    AcisQueryEngine::instance();
    AcisModifyEngine::instance();

    // Get version number of the geometry engine.
    CubitString version = gqt->get_engine_version_string();
    cout << "ACIS Engine: " << version << endl;

    CubitStatus status;

    /* Open BRL-CAD database */
    /* Scan all the records in the database and build a directory */
    rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf));

    if ( rtip == RTI_NULL) {
	usage( "rt_dirbuild failure\n" );
    }

    init_state = rt_initial_tree_state;
    init_state.ts_dbip = rtip->rti_dbip;
    init_state.ts_rtip = rtip;
    init_state.ts_resp = NULL;
    init_state.ts_tol = &tol;
    init_state.ts_ttol = &ttol;
    bu_avs_init(&init_state.ts_attrs, 1, "avs in tree_state");

    optind++;

    /* Walk the trees named on the command line
     * outputting combinations and primitives
     */
    int walk_tree_status;
    for ( i = optind ; i < argc ; i++ ) {
	struct directory *dp;

	dp = db_lookup( rtip->rti_dbip, argv[i], LOOKUP_QUIET );
	if ( dp == DIR_NULL ) {
	    bu_log( "Cannot find %s\n", argv[i] );
	    continue;
	}

	db_walk_tree(rtip->rti_dbip, argc - i, (const char **)&argv[i], NUM_OF_CPUS_TO_USE,
		     &init_state ,region_start, region_end, primitive_func, (genptr_t) &user_data);
    }

    // *************************************************************************************
    // Write SAT file
    // *************************************************************************************

    // Make bodies list.
    DLIList<Body*> all_bodies, old_bodies, new_bodies, tools_bodies;
    Body* tool_body;

    // Export geometry
    if (g_body_cnt == 0) {
	usage( "No geometry to convert.\n" );
    }

    cout << "*** CSG DEBUG BEGIN ***" << endl;
    DLIList<Body*> all_region_bodies, region_bodies, from_bodies;
    Body* region_body;

    for (int i=0; i < g_CsgBoolExp.size(); i++) {
	cout << " R" << i << " = " << g_CsgBoolExp[i] << ": " << get_body_id(g_CsgBoolExp[i]) << endl;

	int body_id = get_body_id(g_CsgBoolExp[i]);

	if (body_id  >= 0) {
	    all_region_bodies.append(gqt->get_body(body_id));
	}
	else if (body_id == -1) { // {empty}
	    cout << "DEBUG: {empty}" << endl;
	}
	else {
	    //tokenize
	    vector <string> csgTokens;
	    char csgOp;

	    tokenize(g_CsgBoolExp[i],csgTokens," ");

	    cout << "DEBUG " << csgTokens.size() << endl;

	    for (int j = 0; j < csgTokens.size(); j++) {
		cout <<"    T" << j << " = " << csgTokens[j] << ": " << get_body_id(csgTokens[j]) << endl;

		if (get_body_id(csgTokens[j]) >= 0) {
		    region_bodies.append(gqt->get_body(get_body_id(csgTokens[j])));
		}
		else {
		    csgOp = csgTokens[j].at(0);
		    cout << "*DEBUG*  csgOp = " << csgOp << endl;
		    switch (csgOp) {
		    case '+':
			cout << "*** DEBUG INTERSECT ***" << endl;
			tool_body = region_bodies.pop();
			from_bodies.append(region_bodies.pop());
			gmt->intersect(tool_body, from_bodies, region_bodies, CUBIT_TRUE);
			break;
		    case '-':
			cout << "*** DEBUG SUBTRACT ***" << endl;
			tool_body = region_bodies.pop();
			from_bodies.append(region_bodies.pop());
			gmt->subtract(tool_body, from_bodies, region_bodies, CUBIT_TRUE);
			break;
		    case 'u':
			cout << "*** DEBUG UNION ***" << endl;
			if (region_bodies.size() >= 2) {
			    from_bodies.append(region_bodies.pop());
			    from_bodies.append(region_bodies.pop());
			    if (!gmt->unite(from_bodies, region_bodies, CUBIT_TRUE)) {
				region_bodies+=from_bodies;
			    }
			}
			else {
			    region_bodies+=from_bodies;
			}
			break;
		    default:
			// do nothing -- should get here
			break;
		    }

		    from_bodies.clean_out();
		} // end if on get_body_id

	    } // end for loop over csgTokens

	    csgTokens.clear();

	    if (region_bodies.size() != 0) {
		all_region_bodies+=region_bodies;
		region_bodies.clean_out();
	    }
	} // end if/else on body_id
    } // end for loop over g_CsgBoolExp

    cout << "*** CSG DEBUG END ***" << endl;

    // Make entities list.
    DLIList<RefEntity*> parent_entities;

    CAST_LIST_TO_PARENT(all_region_bodies, parent_entities);

    int size = parent_entities.size();
    cout << "Number of bodies to be exported: " << size << endl;

    // Export geometry
    if (size != 0) {
	status = gqt->export_solid_model(parent_entities, output_file, ACIS_SAT, size, version);
    }
    else {
	usage( "No geometry to convert.\n" );
    }

    CGMApp::instance()->shutdown();

    cout << "Number of primitives processed: " << g_body_cnt << endl;
    cout << "GOT HERE!" << endl;
    abort(); /* !!! should not need this */

    return 0;
}


/*
 *      U S A G E --- tell user how to invoke this program, then exit
 */
void usage(char *s)
{
    if ( s ) {
	fputs( s, stderr );
    }

    bu_exit(1, usage_msg, prog_name);
}


/*
 *      P A R S E _ A R G S --- Parse through command line flags
 */
int parse_args( int ac, char **av )
{
    int  c;

    if (  ! (prog_name=strrchr(*av, '/'))  )
	prog_name = *av;
    else
	++prog_name;

    /* Turn off getopt's error messages */
    opterr = 0;

    /* get all the option flags from the command line */
    while ( (c = getopt( ac, av, options ) ) != EOF ) {

	switch (c) {
	case 't':               /* calculational tolerance */
	    tol.dist = atof( optarg );
	    tol.dist_sq = tol.dist * tol.dist;
	case 'o':               /* Output file name */
	    /* grab output file name */
	    output_file = optarg;
	    break;
	case 'v':               /* verbosity */
	    verbose++;
	    break;
	case 'x':               /* librt debug flag (see librt/debug.h) */
	    sscanf( optarg, "%x", &rt_g.debug );
	    bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
	    bu_log("\n");
	    break;
	case 'X':               /* NMG debug flag (see h/nmg.h) */
	    sscanf( optarg, "%x", &rt_g.NMG_debug );
	    bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
	    bu_log("\n");
	    break;
	default:
	    usage("Bad or help flag specified\n");
	    break;
	}

    }

    return optind;
}


/**
 *      R E G I O N _ S T A R T
 *
 * @@brief This routine is called when a region is first encountered in the
 * heirarchy when processing a tree
 *
 *      @@param tsp tree state (for parsing the tree)
 *      @@param pathp A listing of all the nodes traversed to get to this node in the database
 *      @@param combp the combination record for this region
 *      @@param client_data pointer that was passed as last argument to db_walk_tree()
 *
 */
int
region_start ( db_tree_state *tsp,
	       db_full_path *pathp,
	       const  rt_comb_internal *combp,
	       genptr_t client_data )
{
    rt_comb_internal *comb;
    directory *dp;
    bu_vls str;
    ostringstream ostr;
    string infix, postfix;

    if (debug&DEBUG_NAMES) {
	char *name = db_path_to_string(pathp);
	bu_log("region_start %s\n", name);
	bu_free(name, "reg_start name");
    }

    dp = DB_FULL_PATH_CUR_DIR(pathp);

    /* here is where the conversion should be done */
    cout << "* Here is where the conversion should be done *" << endl;
    printf( "Write this region (name=%s) as a part in your format:\n", dp->d_namep );

    bu_vls_init( &str );

    describe_tree( combp->tree, &str );

    printf( "\t%s\n\n", bu_vls_addr( &str ) );
    ostr <<  bu_vls_addr( &str );

    bu_vls_free( &str );

    infix = ostr.str();
    postfix = infix_to_postfix(infix);
    cout << "\tIn postfix: "<< postfix << endl << endl;
    g_CsgBoolExp.push_back(postfix);

    return 0;
}


/**
 *      R E G I O N _ E N D
 *
 *
 * @@brief This is called when all sub-elements of a region have been processed by leaf_func.
 *
 *      @@param tsp
 *      @@param pathp
 *      @@param curtree
 *      @@param client_data
 *
 *      @@return TREE_NULL if data in curtree was "stolen", otherwise db_walk_tree will
 *      clean up the data in the  tree * that is returned
 *
 * If it wants to retain the data in curtree it can by returning TREE_NULL.  Otherwise
 * db_walk_tree will clean up the data in the  tree * that is returned.
 *
 */
tree *
region_end ( db_tree_state *tsp,
	     db_full_path *pathp,
	     tree *curtree,
	     genptr_t client_data )
{
    if (debug&DEBUG_NAMES) {
	char *name = db_path_to_string(pathp);
	bu_log("region_end   %s\n", name);
	bu_free(name, "region_end name");
    }

    return curtree;
}


/* This routine just produces an ascii description of the Boolean tree.
 * In a real converter, this would output the tree in the desired format.
 */
void
describe_tree(  tree *tree,
		bu_vls *str)
{
    bu_vls left, right;
    char *union_op = " u ";
    char *subtract_op = " - ";
    char *intersect_op = " + ";
    char *xor_op = " ^ ";
    char *op = NULL;

    BU_CK_VLS(str);

    if( !tree )
	{
	    /* this tree has no members */
	    bu_vls_strcat( str, "{empty}" );
	    set_body_id("{empty}", -1);
	    return;
	}

    RT_CK_TREE(tree);

    /* Handle all the possible node types.
     * the first four are the most common types, and are typically
     * the only ones found in a BRL-CAD database.
     */
    switch( tree->tr_op )
	{
	case OP_DB_LEAF:	/* leaf node, this is a member */
	    /* Note: tree->tr_l.tl_mat is a pointer to a
	     * transformation matrix to apply to this member
	     */
	    bu_vls_strcat( str,  tree->tr_l.tl_name );
	    break;
	case OP_UNION:		/*  operator node */
	    op = union_op;
	    goto binary;
	case OP_INTERSECT:	/* intersection operator node */
	    op = intersect_op;
	    goto binary;
	case OP_SUBTRACT:	/* subtraction operator node */
	    op = subtract_op;
	    goto binary;
	case OP_XOR:		/* exclusive "or" operator node */
	    op = xor_op;
	binary:				/* common for all binary nodes */
	    bu_vls_init( &left );
	    bu_vls_init( &right );
	    describe_tree( tree->tr_b.tb_left, &left );
	    describe_tree( tree->tr_b.tb_right, &right );
	    bu_vls_putc( str, '(' );
	    bu_vls_vlscatzap( str, &left );
	    bu_vls_strcat( str, op );
	    bu_vls_vlscatzap( str, &right );
	    bu_vls_putc( str, ')' );
	    break;
	case OP_NOT:
	    bu_vls_strcat( str, "(!" );
	    describe_tree( tree->tr_b.tb_left, str );
	    bu_vls_putc( str, ')' );
	    break;
	case OP_GUARD:
	    bu_vls_strcat( str, "(G" );
	    describe_tree( tree->tr_b.tb_left, str );
	    bu_vls_putc( str, ')' );
	    break;
	case OP_XNOP:
	    bu_vls_strcat( str, "(X" );
	    describe_tree( tree->tr_b.tb_left, str );
	    bu_vls_putc( str, ')' );
	    break;
	case OP_NOP:
	    bu_vls_strcat( str, "NOP" );
	    break;
	default:
	    bu_exit(2, "ERROR: describe_tree() got unrecognized op (%d)\n", tree->tr_op );
	}
}


/* This routine is called by the tree walker (db_walk_tree)
 * for every primitive encountered in the trees specified on the command line */
tree *
primitive_func( db_tree_state *tsp,
		db_full_path *pathp,
		rt_db_internal *ip,
		genptr_t client_data)
{
    const double NEARZERO = 0.0001;

    int i;
    ostringstream ostr;
    string name;

    directory *dp;

    // Create the geometry modify and query tool
    GeometryModifyTool *gmt = GeometryModifyTool::instance();
    GeometryQueryTool *gqt = GeometryQueryTool::instance();

    dp = DB_FULL_PATH_CUR_DIR(pathp);

    if (debug&DEBUG_NAMES) {
	char *name = db_path_to_string(pathp);
	bu_log("leaf_func    %s\n", name);
	bu_free(name, "region_end name");
    }

    /* handle each type of primitive (see h/rtgeom.h) */
    if( ip->idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
	switch( ip->idb_minor_type )
	    {
		/* most commonly used primitives */
	    case ID_TOR:	/* torus */
		{
		    CubitVector x_axis(1.0, 0.0, 0.0);
		    CubitVector y_axis(0.0, 1.0, 0.0);
		    CubitVector z_axis(0.0, 0.0, 1.0);

		    rt_tor_internal *tor = ( rt_tor_internal *)ip->idb_ptr;

		    if (debug&DEBUG_NAMES) {
			printf( "Write this torus (name=%s) in your format:\n", dp->d_namep );
			printf( "\tV=(%g %g %g)\n", V3ARGS( tor->v ) );
			printf( "\tnormal=(%g %g %g)\n", V3ARGS( tor->h ) );
			printf( "\tradius1 = %g\n", tor->r_a );
			printf( "\tradius2 = %g\n", tor->r_h );
		    }

		    CubitVector tor_v( V3ARGS( tor->v ) );
		    CubitVector tor_h( V3ARGS( tor->h ) );

		    double tor_ra = tor->r_a;
		    double tor_rh = tor->r_h;

		    if (gmt->torus(tor_ra, tor_rh)) {
			g_body_cnt++;
			ostr << dp->d_namep;
			name = ostr.str();
			set_body_id(name, g_body_cnt);
			ostr.flush();

			CubitVector raxis = z_axis * tor_h;
			double rangle = z_axis.interior_angle(tor_h);

			gqt->rotate(gqt->get_last_body(), raxis, rangle);
			gqt->translate(gqt->get_last_body(), tor_v);
		    }

		    break;
		}
	    case ID_TGC: /* truncated general cone frustum */
	    case ID_REC: /* right elliptical cylinder */
		{
		    /* This primitive includes circular cross-section
		     * cones and cylinders
		     */
		    CubitVector x_axis(1.0, 0.0, 0.0);
		    CubitVector y_axis(0.0, 1.0, 0.0);
		    CubitVector z_axis(0.0, 0.0, 1.0);

		    bool direct_convert = false;

		    fastf_t maxb, ma, mb, mc, md, mh;
		    vect_t axb;

		    CubitVector bbc[8];  // bounding box corners
		    CubitVector center_of_base;

		    rt_tgc_internal *tgc = ( rt_tgc_internal *)ip->idb_ptr;

		    if (debug&DEBUG_NAMES) {
			printf( "Write this TGC (name=%s) in your format:\n", dp->d_namep );
			printf( "\tV=(%g %g %g)\n", V3ARGS( tgc->v ) );
			printf( "\tH=(%g %g %g)\n", V3ARGS( tgc->h ) );
			printf( "\tA=(%g %g %g)\n", V3ARGS( tgc->a ) );
			printf( "\tB=(%g %g %g)\n", V3ARGS( tgc->b ) );
			printf( "\tC=(%g %g %g)\n", V3ARGS( tgc->c ) );
			printf( "\tD=(%g %g %g)\n", V3ARGS( tgc->d ) );
		    }

		    CubitVector tgc_v( V3ARGS( tgc->v ) );
		    CubitVector tgc_h( V3ARGS( tgc->h ) );
		    CubitVector tgc_a( V3ARGS( tgc->a ) );
		    CubitVector tgc_b( V3ARGS( tgc->b ) );
		    CubitVector tgc_c( V3ARGS( tgc->c ) );
		    CubitVector tgc_d( V3ARGS( tgc->d ) );

		    VCROSS(axb, tgc->a, tgc->b);
		    maxb = MAGNITUDE(axb);
		    ma = MAGNITUDE( tgc->a );
		    mb = MAGNITUDE( tgc->b );
		    mc = MAGNITUDE( tgc->c );
		    md = MAGNITUDE( tgc->d );
		    mh = MAGNITUDE( tgc->h );

		    // check for right cone or cylinder
		    if ( fabs(fabs(VDOT(tgc->h,axb))-(mh*maxb) ) < NEARZERO ) {
			// have a right cylinder or cone
			if (( fabs(ma - mb) < NEARZERO) && (fabs(mc - md)  < NEARZERO )) {
			    cout << "DEBUG: This TGC is a rcc or trc" << endl;
			    direct_convert = true;
			}
			else if (( fabs(ma - mc) < NEARZERO) && (fabs(mb - md)  < NEARZERO )) {
			    cout << "DEBUG: This TGC is a rec" << endl;
			    direct_convert = true;
			}
			else if (( fabs(ma/mc) - fabs(mb/md) ) < NEARZERO ) {
			    cout << "DEBUG: This TGC is a tec" << endl;
			    direct_convert = true;
			}
			else {
			    cout << "DEBUG: This TGC is a right tgc" << endl;
			    direct_convert = false;
			}
		    }

		    if (direct_convert) {
			if (gmt->cylinder(mh, ma, mb, mc)) {
			    g_body_cnt++;
			    ostr << dp->d_namep;
			    name = ostr.str();
			    set_body_id(name, g_body_cnt);
			    ostr.flush();

			    if ( (fabs(ma - mb) > NEARZERO )) {
				double axbangle = x_axis.interior_angle(tgc_a);
				cout << "axbangle = " << axbangle << endl;
				if ( axbangle > NEARZERO ) {
				    gqt->rotate(gqt->get_last_body(), z_axis, axbangle);
				}
			    }

			    CubitVector raxis = z_axis * tgc_h;
			    double rangle = z_axis.interior_angle(tgc_h);
			    cout << "rangle = " << rangle << endl;
			    if ( rangle > NEARZERO ) {
				gqt->rotate(gqt->get_last_body(), raxis, rangle);
			    }

			    CubitVector tgc_cp = tgc_v + (tgc_h / 2.0);
			    gqt->translate(gqt->get_last_body(), tgc_cp);
			}
		    }
		    else {
			goto TESS_CASE;
		    }

		    break;
		}
	    case ID_ELL:
	    case ID_SPH:
		{
		    CubitVector x_axis(1.0, 0.0, 0.0);
		    CubitVector y_axis(0.0, 1.0, 0.0);
		    CubitVector z_axis(0.0, 0.0, 1.0);

		    /* spheres and ellipsoids */
		    rt_ell_internal *ell = ( rt_ell_internal *)ip->idb_ptr;

		    if (debug&DEBUG_NAMES) {
			printf( "Write this ellipsoid (name=%s) in your format:\n", dp->d_namep );
			printf( "\tV=(%g %g %g)\n", V3ARGS( ell->v ) );
			printf( "\tA=(%g %g %g)\n", V3ARGS( ell->a ) );
			printf( "\tB=(%g %g %g)\n", V3ARGS( ell->b ) );
			printf( "\tC=(%g %g %g)\n", V3ARGS( ell->c ) );
		    }

		    CubitVector ell_v( V3ARGS( ell->v ) );

		    double magsq_a = MAGSQ ( ell->a );
		    double magsq_b = MAGSQ ( ell->b );
		    double magsq_c = MAGSQ ( ell->c );

		    if ( ( fabs(magsq_a - magsq_b) < NEARZERO ) && ( fabs(magsq_a - magsq_c) < NEARZERO ) ) {
			if (gmt->sphere( sqrt( magsq_a ) )) {
			    g_body_cnt++;
			    ostr << dp->d_namep;
			    name = ostr.str();
			    set_body_id(name, g_body_cnt);
			    ostr.flush();

			    gqt->translate(gqt->get_last_body(), ell_v);
			}
		    }
		    else {
			vect_t unitv;
			double angles[5];
			CubitVector rot_axis;

			CubitVector ell_a( V3ARGS( ell->a ) );
			CubitVector ell_b( V3ARGS( ell->b ) );
			CubitVector ell_c( V3ARGS( ell->c ) );

			double mag_a = sqrt( magsq_a );
			double mag_b = sqrt( magsq_b );
			double mag_c = sqrt( magsq_c );

			if (gmt->sphere(1.0)) {
			    g_body_cnt++;
			    ostr << dp->d_namep;
			    name = ostr.str();
			    set_body_id(name, g_body_cnt);
			    ostr.flush();

			    CubitVector scale_vector(mag_a, mag_b, mag_c);
			    gqt->scale(gqt->get_last_body(), scale_vector, true);

			    if ( (fabs(mag_a - mag_b) > NEARZERO )) {
				double axbangle = x_axis.interior_angle(ell_a);
				gqt->rotate(gqt->get_last_body(), z_axis, axbangle);
			    }

			    CubitVector raxis = z_axis * ell_c;
			    double hangle = z_axis.interior_angle(ell_c);
			    gqt->rotate(gqt->get_last_body(), raxis, hangle);
			    gqt->translate(gqt->get_last_body(), ell_v);
			}

		    }

		    break;
		}
	    case ID_ARB8:	/* convex primitive with from four to six faces */
		{
		    /* this primitive may have degenerate faces
		     * faces are: 0123, 7654, 0347, 1562, 0451, 3267
		     * (points listed above in counter-clockwise order)
		     */
		    rt_arb_internal *arb = ( rt_arb_internal *)ip->idb_ptr;

		    if (debug&DEBUG_NAMES) {
			printf( "Write this ARB (name=%s) in your format:\n", dp->d_namep );
			for( i=0 ; i<8 ; i++ ) {
			    printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
			}
		    }

		    goto TESS_CASE;
		}

	    case ID_BOT:	/* Bag O' Triangles */
		{
		    rt_bot_internal *bot = (rt_bot_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}

		/* less commonly used primitives */
	    case ID_ARS:
		{
		    /* series of curves
		     * each with the same number of points
		     */
		    rt_ars_internal *ars = ( rt_ars_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_HALF:
		{
		    /* half universe defined by a plane */
		    rt_half_internal *half = ( rt_half_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_POLY:
		{
		    /* polygons (up to 5 vertices per) */
		    rt_pg_internal *pg = ( rt_pg_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_BSPLINE:
		{
		    /* NURB surfaces */
		    rt_nurb_internal *nurb = ( rt_nurb_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_NMG:
		{
		    nmgregion *r;
		    shell *s;

		    /* N-manifold geometry */
		    model *m = ( model *)ip->idb_ptr;

		    NMG_CK_MODEL(m);

		    /* walk the nmg to convert it to triangular facets */
		    nmg_triangulate_model(m, tsp->ts_tol);

		    if (make_bot(r, m, s)) {
			g_body_cnt++;
			ostr << dp->d_namep;
			name = ostr.str();
			set_body_id(name, g_body_cnt);
			ostr.flush();
		    }

		    break;
		}
	    case ID_ARBN:
		{
		    rt_arbn_internal *arbn = ( rt_arbn_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}

	    case ID_DSP:
		{
		    /* Displacement map (terrain primitive) */
		    /* normally used for terrain only */
		    /* the DSP primitive may reference an external file */
		    rt_dsp_internal *dsp = ( rt_dsp_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_HF:
		{
		    /* height field (terrain primitive) */
		    /* the HF primitive references an external file */
		    rt_hf_internal *hf = ( rt_hf_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}

		/* rarely used primitives */
	    case ID_EBM:
		{
		    /* extruded bit-map */
		    /* the EBM primitive references an external file */
		    rt_ebm_internal *ebm = ( rt_ebm_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_VOL:
		{
		    /* the VOL primitive references an external file */
		    rt_vol_internal *vol = ( rt_vol_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_PIPE:
		{
		    rt_pipe_internal *pipe = ( rt_pipe_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_PARTICLE:
		{
		    rt_part_internal *part = ( rt_part_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_RPC:
		{
		    rt_rpc_internal *rpc = ( rt_rpc_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_RHC:
		{
		    rt_rhc_internal *rhc = ( rt_rhc_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_EPA:
		{
		    rt_epa_internal *epa = ( rt_epa_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_EHY:
		{
		    rt_ehy_internal *ehy = ( rt_ehy_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_ETO:
		{
		    rt_eto_internal *eto = ( rt_eto_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_GRIP:
		{
		    rt_grip_internal *grip = ( rt_grip_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}

	    case ID_SKETCH:
		{
		    rt_sketch_internal *sketch = ( rt_sketch_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}
	    case ID_EXTRUDE:
		{
		    /* note that an extrusion references a sketch, make sure you convert
		     * the sketch also
		     */
		    rt_extrude_internal *extrude = ( rt_extrude_internal *)ip->idb_ptr;

		    goto TESS_CASE;

		    break;
		}

	    default:    TESS_CASE:
		// bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_type );
		// break;
		{
		    /* This section is for primitives which cannot be directly represented in the
		     * format we are going to.  So we convert it to triangles
		     */
		    nmgregion *r;
		    model *m = nmg_mm();
		    shell *s;

		    NMG_CK_MODEL(m);

		    if (rt_functab[ip->idb_type].ft_tessellate(&r, m, ip, tsp->ts_ttol, tsp->ts_tol) != 0) {
			bu_exit(1, "Failed to tessellate!\n");
		    }

		    //bu_log("triangulate %d\n", ip->idb_minor_type);
		    /* walk the nmg to convert it to triangular facets */
		    nmg_triangulate_model(m, tsp->ts_tol);

		    if (make_bot(r, m, s)) {
			g_body_cnt++;
			ostr << dp->d_namep;
			name = ostr.str();
			set_body_id(name, g_body_cnt);
			ostr.flush();
		    }


		    break;
		}


	    }
    }
    else {
	switch( ip->idb_major_type ) {
	case DB5_MAJORTYPE_BINARY_UNIF:
	    {
		/* not actually a primitive, just a block of storage for data
		 * a uniform array of chars, ints, floats, doubles, ...
		 */
		rt_binunif_internal *bin = ( rt_binunif_internal *)ip->idb_ptr;

		printf( "Found a binary object (%s)\n\n", dp->d_namep );
		break;
	    }
	default:
	    bu_log( "Major type of %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_major_type );
	    break;
	}
    }

    return ( tree *) NULL;
}


/* routine to output the facetted NMG representation of a BRL-CAD region */
void
output_triangles( nmgregion *r,
		  model *m,
		  shell *s )
{
    vertex *v;

    for( BU_LIST_FOR( s, shell, &r->s_hd ) ) {
	faceuse *fu;

	NMG_CK_SHELL( s );

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) ) {
	    loopuse *lu;
	    vect_t facet_normal;

	    NMG_CK_FACEUSE( fu );

	    if( fu->orientation != OT_SAME )
		continue;

	    /* Grab the face normal if needed */
	    NMG_GET_FU_NORMAL( facet_normal, fu);

	    for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) ) {
		edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		    continue;

		/* loop through the edges in this loop (facet) */
		printf( "\tfacet:\n" );
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) ) {
		    NMG_CK_EDGEUSE( eu );

		    v = eu->vu_p->v_p;
		    NMG_CK_VERTEX( v );
		    printf( "\t\t(%g %g %g)\n", V3ARGS( v->vg_p->coord ) );
		}
	    }
	}
    }
}


/* routine to output the facetted NMG representation of a BRL-CAD region */
bool
make_bot( nmgregion *r,
	  model *m,
	  shell *s )
{
    // Create the geometry modify and query tool
    GeometryModifyTool *gmt = GeometryModifyTool::instance();
    GeometryQueryTool *gqt = GeometryQueryTool::instance();

    vertex *v;

    CubitVector cv;
    DLIList <RefVertex*> VertexList;
    DLIList <RefEdge*> EdgeList;
    DLIList <RefFace*> FaceList;

    point_t bot_min, bot_max;  // bounding box points
    point_t bot_cp;

    // initialize  bot_min and bot_max
    VSETALL( bot_min, MAX_FASTF );
    VSETALL( bot_max, -MAX_FASTF );

    for( BU_LIST_FOR( s, shell, &r->s_hd ) ) {
	faceuse *fu;

	NMG_CK_SHELL( s );

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) ) {
	    loopuse *lu;
	    vect_t facet_normal;

	    NMG_CK_FACEUSE( fu );

	    if( fu->orientation != OT_SAME )
		continue;

	    /* Grab the face normal if needed */
	    NMG_GET_FU_NORMAL( facet_normal, fu);

	    for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) ) {
		edgeuse *eu;

		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		    continue;

		/* loop through the edges in this loop (facet) */
		// printf( "\tfacet:\n" );
		for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) ) {
		    NMG_CK_EDGEUSE( eu );

		    v = eu->vu_p->v_p;
		    NMG_CK_VERTEX( v );
		    VMINMAX( bot_min, bot_max, v->vg_p->coord );
		    // printf( "\t\t(%g %g %g)\n", V3ARGS( v->vg_p->coord ) );
		    cv.set(V3ARGS( v->vg_p->coord ));
		    VertexList.append(gmt->make_RefVertex(cv));
		}
		const int MAX_VERTICES = 3;
		for (int i=0; i <= MAX_VERTICES-1; i++) {
		    EdgeList.append(gmt->make_RefEdge(STRAIGHT_CURVE_TYPE,
						      VertexList[i], VertexList[(i+1)%MAX_VERTICES]));
		}

		RefFace *face = gmt->make_RefFace(PLANE_SURFACE_TYPE, EdgeList);

		EdgeList.clean_out();
		VertexList.clean_out();

		FaceList.append(face);
	    }

	}

    }
    DLIList <Body*> BodyList;

    CubitStatus status;

    status = gmt->create_solid_bodies_from_surfs(FaceList, BodyList);
    // status = gmt->create_body_from_surfs(FaceList, BotBody);

    Body *BotBody, *RegBotBody;
    for (int i=0; i < BodyList.size(); i++) {
	BotBody = BodyList[i];

	if (status != CUBIT_FAILURE) {
	    cout << "make_bot made a Body!" << endl;
	    gmt->regularize_body(BotBody, RegBotBody);
	}
	else {
	    cout << "make_bot did not made a Body! Substituted bounding box instead of Body." << endl;
	    
	    double bb_width = fabs(bot_max[0] - bot_min[0]);
	    double bb_depth = fabs(bot_max[1] - bot_min[1]);
	    double bb_height = fabs(bot_max[2] - bot_min[2]);
	    
	    gmt->brick(bb_width, bb_depth, bb_height);
	    
	    VSUB2SCALE(bot_cp, bot_max, bot_min, 0.5);
	    VADD2(bot_cp, bot_cp, bot_min);
	    CubitVector bbox_cp( V3ARGS(bot_cp) );
	    
	    status = gqt->translate(gqt->get_last_body(), bbox_cp);
	}
    }

    FaceList.clean_out();

    return status;
}

// set_body_id function
void set_body_id(string body_name, int body_id)
{
    g_body_id_map[body_name] = body_id;
}

// get_body_id function
int get_body_id(string body_name)
{
    const int ERR_FLAG = -99;
    int rVal;

    map<string, int>::iterator iter;
    iter = g_body_id_map.find(body_name);

    if (iter != g_body_id_map.end()) {
	rVal = iter->second;
    }
    else {
	rVal = ERR_FLAG;
    }

    return rVal;
}

tree *
booltree_evaluate( tree *tp, resource *resp )
{
    union tree              *tl;
    union tree              *tr;
    int                     op;
    const char              *op_str;
    char                    *name;
    int			     namelen;

    enum BOOL_ENUM_TYPE { ADD, ISECT, SUBTR };

    RT_CK_TREE(tp);

    switch(tp->tr_op) {
    case OP_NOP:
	return(0);
    case OP_DB_LEAF:
	/* Hit a tree leaf */
	return tp;
    case OP_UNION:
	op = ADD;
	op_str = " u ";
	break;
    case OP_INTERSECT:
	op = ISECT;
	op_str = " + ";
	break;
    case OP_SUBTRACT:
	op = SUBTR;
	op_str = " - ";
	break;
    default:
	bu_log("booltree_evaluate: bad op %d\n", tp->tr_op);
	return(0);
    }
    /* Handle a boolean operation node.  First get it's leaves. */
    tl = booltree_evaluate(tp->tr_b.tb_left, resp);
    tr = booltree_evaluate(tp->tr_b.tb_right, resp);

    if (tl == 0 || !tl->tr_d.td_r) {
	if (tr == 0 || !tr->tr_d.td_r)
	    return 0;
	if( op == ADD )
	    return tr;
	/* For sub and intersect, if lhs is 0, result is null */
	//db_free_tree(tr);
	tp->tr_b.tb_right = TREE_NULL;
	tp->tr_op = OP_NOP;
	return 0;
    }
    if (tr == 0 || !tr->tr_d.td_r) {
	if (tl == 0 || !tl->tr_d.td_r)
	    return 0;
	if( op == ISECT )  {
	    db_free_tree(tl, resp);
	    tp->tr_b.tb_left = TREE_NULL;
	    tp->tr_op = OP_NOP;
	    return 0;
	}
	/* For sub and add, if rhs is 0, result is lhs */
	return tl;
    }
    if( tl->tr_op != OP_DB_LEAF )  bu_exit(2, "booltree_evaluate() bad left tree\n");
    if( tr->tr_op != OP_DB_LEAF )  bu_exit(2, "booltree_evaluate() bad right tree\n");

    bu_log(" {%s}%s{%s}\n", tl->tr_d.td_name, op_str, tr->tr_d.td_name );
    cout << "******" << tl->tr_d.td_name << op_str << tr->tr_d.td_name << "***********" << endl;

    /* Build string of result name */
    namelen = strlen(tl->tr_d.td_name)+strlen(op_str)+strlen(tr->tr_d.td_name)+3;
    name = (char *)bu_malloc( namelen, "booltree_evaluate name");

    snprintf(name, namelen, "(%s%s%s)", tl->tr_d.td_name, op_str, tr->tr_d.td_name );

    /* Clean up child tree nodes (and their names) */
    db_free_tree(tl, resp);
    db_free_tree(tr, resp);

    /* Convert argument binary node into a result node */
    tp->tr_op = OP_DB_LEAF;
    tp->tr_d.td_name = name;
    return tp;
}

string infix_to_postfix(string str)
{

    stack <char> s;
    ostringstream ostr;
    char c;

    for (int i = 0; i < strlen(str.c_str()); i++) {
	c = str[i];
	if ( c == '(' ) {
	    s.push(c);
	}
	else if ( c == ')' ) {
	    while ( (c = s.top()) != '(' ) {
		ostr << ' ' << c;
		s.pop();
	    }
	    s.pop();
	}
	else if (((c == 'u') || (c == '+') || (c == '-')) && (str[i+1] == ' ')) {
	    s.push(c);
	    i++;
	}
	else {
	    ostr << c ;
	}
    }

    if (!s.empty()) {
	ostr << s.top();
	s.pop();
    }

    return ostr.str();
}

void tokenize(const string& str, vector<string>& tokens, const string& delimiters)
{
    // Skip delimiters at beginning.
    string::size_type lastPos = str.find_first_not_of(delimiters, 0);

    // Find first "non-delimiter".
    string::size_type pos     = str.find_first_of(delimiters, lastPos);

    while (string::npos != pos || string::npos != lastPos) {
	// Found a token, add it to the vector.
	tokens.push_back(str.substr(lastPos, pos - lastPos));

	// Skip delimiters.  Note the "not_of"
	lastPos = str.find_first_not_of(delimiters, pos);

	// Find next "non-delimiter"
	pos = str.find_first_of(delimiters, lastPos);
    }
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.13
log
@more quellings of level 4 flawfinder issues
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.12 2007/10/16 17:04:36 brlcad Exp $";
d349 1
a349 1
    abort();
d364 1
a364 2
    fprintf(stderr, usage_msg, prog_name);
    exit(1);
d585 1
a585 2
	    bu_log( "ERROR: describe_tree() got unrecognized op (%d)\n", tree->tr_op );
	    bu_bomb( "ERROR: bad op\n" );
d1072 1
a1072 1
			exit(-1);
d1367 2
a1368 2
    if( tl->tr_op != OP_DB_LEAF )  bu_bomb("booltree_evaluate() bad left tree\n");
    if( tr->tr_op != OP_DB_LEAF )  bu_bomb("booltree_evaluate() bad right tree\n");
@


1.12
log
@update to the latest API changes where create_body_from_surfs() seems to have chnaged to create_solid_bodies_from_surfs() in the GeometryModifyTool class.  looks like it just changed to return a list of bodies instead of one body, so we iterate over the bodies.  this is entirely untested, but seems right according to the docs at https://svn.mcs.anl.gov/repos/ITAPS/cgm/trunk/geom/
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.11 2007/09/15 16:23:05 brlcad Exp $";
d1314 1
d1376 4
a1379 7
    name = (char *)bu_malloc( strlen(tl->tr_d.td_name)+3+strlen(tr->tr_d.td_name)+2+1,
			      "booltree_evaluate name");
    name[0] = '(';
    strcpy( name+1, tl->tr_d.td_name );
    strcat( name+1, op_str );
    strcat( name+1, tr->tr_d.td_name );
    strcat( name+1, ")" );
@


1.11
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.10 2007/09/14 15:21:03 erikgreenwald Exp $";
d1244 1
a1244 1
    Body *BotBody, *RegBotBody;
d1248 2
a1249 1
    status = gmt->create_body_from_surfs(FaceList, BotBody);
d1251 3
a1253 6
    if (status != CUBIT_FAILURE) {
	cout << "make_bot made a Body!" << endl;
	gmt->regularize_body(BotBody, RegBotBody);
    }
    else {
	cout << "make_bot did not made a Body! Substituted bounding box instead of Body." << endl;
d1255 19
a1273 11
	double bb_width = fabs(bot_max[0] - bot_min[0]);
	double bb_depth = fabs(bot_max[1] - bot_min[1]);
	double bb_height = fabs(bot_max[2] - bot_min[2]);

	gmt->brick(bb_width, bb_depth, bb_height);

	VSUB2SCALE(bot_cp, bot_max, bot_min, 0.5);
	VADD2(bot_cp, bot_cp, bot_min);
	CubitVector bbox_cp( V3ARGS(bot_cp) );

	status = gqt->translate(gqt->get_last_body(), bbox_cp);
@


1.10
log
@removed trailing whitespace
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.9 2007/07/26 01:13:52 brlcad Exp $";
d35 3
d46 1
a46 9

#include "common.h"

// system headers
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


1.9
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.8 2007/05/18 04:13:47 brlcad Exp $";
d147 1
a147 1
    
d221 1
a221 1
    
d275 1
a275 1
               
d311 1
a311 1
			} 
d334 1
a334 1
    // Make entities list. 
d336 1
a336 1
    
d338 1
a338 1
    
d341 1
a341 1
    
d349 1
a349 1
    
d351 1
a351 1
    
d355 1
a355 1
    
d1257 1
a1257 1
	gmt->regularize_body(BotBody, RegBotBody); 
d1265 1
a1265 1
 
d1267 1
a1267 1
           
@


1.8
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@a28 4
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.7 2007/03/22 21:19:19 mjgillich Exp $";
@


1.7
log
@first production version with some cleanup. Works with most tested inputs including complex geometry. uses BBs when tessellation fail.  still has some shutdown issue, maybe some other minor issues.  requires Cubit libraries/headers to compile.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.6 2007/02/02 08:48:29 brlcad Exp $";
d1371 2
a1372 2
    if( tl->tr_op != OP_DB_LEAF )  rt_bomb("booltree_evaluate() bad left tree\n");
    if( tr->tr_op != OP_DB_LEAF )  rt_bomb("booltree_evaluate() bad right tree\n");
@


1.6
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.5 2007/01/27 01:41:33 brlcad Exp $";
a100 2
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";

d113 2
d126 8
d141 48
a188 3
	struct user_data {
	   int info;
	} user_data;
d190 3
a192 3
	int		i;
	register int	c;
	char idbuf[132];
d194 1
a194 1
	char *output_file = NULL;
d196 3
a198 1
	bu_setlinebuf( stderr );
d200 13
a212 47
	rt_init_resource(&rt_uniresource, 0, NULL);
/*
	 rt_db_internal intern;
	 directory *dp;
*/
	 rt_i *rtip;
	 db_tree_state init_state;


	/* calculational tolerances
	 * mostly used by NMG routines
	 */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp =1e-6;
	tol.para = 1 - tol.perp;

	/* Get command line arguments. */
	while ((c = bu_getopt(argc, argv, "t:a:n:o:r:vx:X:")) != EOF) {
		switch (c) {
		case 't':		/* calculational tolerance */
			tol.dist = atof( bu_optarg );
			tol.dist_sq = tol.dist * tol.dist;
		case 'o':		/* Output file name */
			/* grab output file name */
			output_file = bu_optarg;
			break;
		case 'v':		/* verbosity */
			verbose++;
			break;
		case 'x':		/* librt debug flag (see librt/debug.h) */
			sscanf( bu_optarg, "%x", &rt_g.debug );
			bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
			bu_log("\n");
			break;
		case 'X':		/* NMG debug flag (see h/nmg.h) */
			sscanf( bu_optarg, "%x", &rt_g.NMG_debug );
			bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
			bu_log("\n");
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
	}
d214 3
a216 4
	if (bu_optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}
d218 21
a238 38
	// ***********************************************************************************
	// Setup Cubit Routines
	// ***********************************************************************************

	// CGM Initialization
	const char* ACIS_SAT = "ACIS_SAT";
	const char* OUTPUT_FILE = "test.sat";

	int dummy_argc = 0;
	char **dummy_argv =NULL;

	// Initialize the application
	AppUtil::instance()->startup(dummy_argc, dummy_argv);
	CGMApp::instance()->startup(dummy_argc, dummy_argv);

	CGMApp::instance()->attrib_manager()->auto_flag(true);

	// Create the geometry modify and query tool
	GeometryModifyTool *gmt = GeometryModifyTool::instance();
	GeometryQueryTool *gqt = GeometryQueryTool::instance();

	// Create the  ACIS engines
	AcisQueryEngine::instance();
	AcisModifyEngine::instance();

	// Get version number of the geometry engine.
	CubitString version = gqt->get_engine_version_string();
	cout << "ACIS Engine: " << version << endl;

	CubitStatus status;

	/* Open BRL-CAD database */
	/* Scan all the records in the database and build a directory */
	/* rtip=rt_dirbuild(argv[bu_optind], idbuf, sizeof(idbuf)); */
	rtip=rt_dirbuild(argv[bu_optind], idbuf, sizeof(idbuf));
	if ( rtip == RTI_NULL) {
	   fprintf(stderr,"g-xxx: rt_dirbuild failure\n");
	   exit(1);
d241 3
a243 27
	init_state = rt_initial_tree_state;
	init_state.ts_dbip = rtip->rti_dbip;
	init_state.ts_rtip = rtip;
	init_state.ts_resp = NULL;
	init_state.ts_tol = &tol;
	init_state.ts_ttol = &ttol;
	bu_avs_init(&init_state.ts_attrs, 1, "avs in tree_state");

	/* Set up tesselation tolerance defaults */
	ttol.magic = RT_TESS_TOL_MAGIC;

	/* Defaults, updated by command line options. */
	ttol.abs = 0.0;
	ttol.rel = 0.01;
	ttol.norm = 0.0;


	bu_optind++;

	/* Walk the trees named on the command line
	 * outputting combinations and primitives
	 */
	for( i=bu_optind ; i<argc ; i++ )
	{
	    db_walk_tree(rtip->rti_dbip, argc - i, (const char **)&argv[i], NUM_OF_CPUS_TO_USE,
			 &init_state ,region_start, region_end, primitive_func, (genptr_t) &user_data);
	}
d245 12
a256 7
	// *************************************************************************************
	// Write SAT file
	// *************************************************************************************

	// Make bodies list.
	DLIList<Body*> all_bodies, old_bodies, new_bodies, tools_bodies;
	Body* tool_body;
d258 3
a260 2
	// Get the global list
	//gqt->bodies(all_bodies);
d262 2
a263 2
/*
	tools_bodies.append(gqt->get_body(get_body_id("cone.s")));
d265 1
a265 2
	gmt->unite(all_bodies, new_bodies);
*/
d267 5
a271 4
/*
	cout << "*** STL MAP DEBUG BEGIN ***" << endl;
	for(g_itr = g_body_id_map.begin(); g_itr != g_body_id_map.end(); g_itr++) {
	   cout << g_itr->first << '\t' << g_itr->second << endl;
d273 53
a325 2
	cout << "*** STL MAP DEBUG END ***" << endl;
*/
d327 1
a327 77
	cout << "*** CSG DEBUG BEGIN ***" << endl;
	DLIList<Body*> all_region_bodies, region_bodies, from_bodies;
	Body* region_body;

	for (int i=0; i < g_CsgBoolExp.size(); i++) {
	   cout << " R" << i << " = " << g_CsgBoolExp[i] << ": " << get_body_id(g_CsgBoolExp[i]) << endl;
	   //if (i == 4) continue;

	   int body_id = get_body_id(g_CsgBoolExp[i]);

	   if (body_id  >= 0) {
	       //region_bodies.append(gqt->get_body(get_body_id(g_CsgBoolExp[i])));
	       all_region_bodies.append(gqt->get_body(body_id));
	   }
	   else if (body_id == -1) { // {empty}
	       cout << "DEBUG: {empty}" << endl;
	   }
	   else {
	       //tokenize
	       vector <string> csgTokens;
	       char csgOp;

	       tokenize(g_CsgBoolExp[i],csgTokens," ");

	       cout << "DEBUG " << csgTokens.size() << endl;
	       for (int j = 0; j < csgTokens.size(); j++) {
		  cout <<"    T" << j << " = " << csgTokens[j] << ": " << get_body_id(csgTokens[j]) << endl;

		  if (get_body_id(csgTokens[j]) >= 0) {
		     region_bodies.append(gqt->get_body(get_body_id(csgTokens[j])));
		  }
		  else {
		     csgOp = csgTokens[j].at(0);
		     cout << "*DEBUG*  csgOp = " << csgOp << endl;
		     switch (csgOp) {
			case '+':
			   cout << "*** DEBUG INTERSECT ***" << endl;
			   tool_body = region_bodies.pop();
			   from_bodies.append(region_bodies.pop());
			   gmt->intersect(tool_body, from_bodies, region_bodies, CUBIT_TRUE);
			   break;
			case '-':
			   cout << "*** DEBUG SUBTRACT ***" << endl;
			   tool_body = region_bodies.pop();
			   from_bodies.append(region_bodies.pop());
			   gmt->subtract(tool_body, from_bodies, region_bodies, CUBIT_TRUE);
			   break;
			case 'u':
			   cout << "*** DEBUG UNION ***" << endl;
			   if (region_bodies.size() >= 2) {
			      from_bodies.append(region_bodies.pop());
			      from_bodies.append(region_bodies.pop());
			      if (!gmt->unite(from_bodies, region_bodies, CUBIT_TRUE)) {
				 cout << "GOT HERE!" << endl;
				 region_bodies+=from_bodies;
			      }
			   }
			   else {
			      region_bodies+=from_bodies;
			   }
			   break;
			default:
			   // do nothing -- should get here
			   break;
		     }

		     from_bodies.clean_out();
		  }

	       }

	       csgTokens.clear();

	       if (region_bodies.size() != 0) {
		  all_region_bodies+=region_bodies;
		  region_bodies.clean_out();
	       }
d329 6
a334 1
	   }
d336 1
a336 5
	}
/*
	from_bodies.append(gqt->get_body(get_body_id("narb8.s")));
	gmt->subtract(gqt->get_body(get_body_id("sph.s")),from_bodies, region_bodies, CUBIT_TRUE);
*/
d338 24
a361 1
	//gmt->imprint(all_bodies, region_bodies);
d365 7
a371 7
	vector<string>::const_iterator ci;
	for (ci=g_CsgBoolExp.begin(); ci!=g_CsgBoolExp.end(); ci++) {
	   cout << *ci << endl;
	   region_bodies.append(gqt->get_body(get_body_id(*ci)));
	}
*/
	cout << "*** CSG DEBUG END ***" << endl;
d373 3
a375 1
	//gmt->imprint(old_bodies, all_bodies);
a376 6
	/*
	if (status == CUBIT_FAILURE) {
	   cout << "Failure" << endl;
	   exit(1);
	}
	*/
d378 6
a383 2
	// Make entities list.
	DLIList<RefEntity*> parent_entities;
d385 35
a419 18
	// Cast boddies list to entities list
	//CAST_LIST_TO_PARENT(new_bodies, parent_entities);

	//gqt->bodies(all_bodies);
	//cout << "The size is " << all_bodies.size() << endl;
	//CAST_LIST_TO_PARENT(all_bodies, parent_entities);
	CAST_LIST_TO_PARENT(all_region_bodies, parent_entities);

	int size = parent_entities.size();
	cout << "The size is " << size << endl;

	 // Export geometry
	 if (size != 0) {
	    status = gqt->export_solid_model(parent_entities, output_file, ACIS_SAT, size, version);
	 }
	 else {
	   cout << "Failure: No geometry to convert!" << endl;
	   exit(1);
d422 1
a422 5
	CGMApp::instance()->shutdown();

	cout << "PRINT BODY COUNT: " << g_body_cnt << endl;
	cout << "GOT HERE!" << endl;
	abort();
d424 1
a424 1
	return 0;
d443 2
a444 2
	      const  rt_comb_internal *combp,
	      genptr_t client_data )
d446 5
a450 5
     rt_comb_internal *comb;
     directory *dp;
     bu_vls str;
     ostringstream ostr;
     string infix, postfix;
d504 1
a504 1
	    genptr_t client_data )
d523 6
a528 6
	 bu_vls left, right;
	char *union_op = " u ";
	char *subtract_op = " - ";
	char *intersect_op = " + ";
	char *xor_op = " ^ ";
	char *op = NULL;
d530 1
a530 1
	BU_CK_VLS(str);
d532 1
a532 1
	if( !tree )
d534 4
a537 4
		/* this tree has no members */
		bu_vls_strcat( str, "{empty}" );
		set_body_id("{empty}", -1);
		return;
d540 7
a546 7
	RT_CK_TREE(tree);

	/* Handle all the possible node types.
	 * the first four are the most common types, and are typically
	 * the only ones found in a BRL-CAD database.
	 */
	switch( tree->tr_op )
d548 49
a596 49
		case OP_DB_LEAF:	/* leaf node, this is a member */
			/* Note: tree->tr_l.tl_mat is a pointer to a
			 * transformation matrix to apply to this member
			 */
			bu_vls_strcat( str,  tree->tr_l.tl_name );
			break;
		case OP_UNION:		/*  operator node */
			op = union_op;
			goto binary;
		case OP_INTERSECT:	/* intersection operator node */
			op = intersect_op;
			goto binary;
		case OP_SUBTRACT:	/* subtraction operator node */
			op = subtract_op;
			goto binary;
		case OP_XOR:		/* exclusive "or" operator node */
			op = xor_op;
binary:				/* common for all binary nodes */
			bu_vls_init( &left );
			bu_vls_init( &right );
			describe_tree( tree->tr_b.tb_left, &left );
			describe_tree( tree->tr_b.tb_right, &right );
			bu_vls_putc( str, '(' );
			bu_vls_vlscatzap( str, &left );
			bu_vls_strcat( str, op );
			bu_vls_vlscatzap( str, &right );
			bu_vls_putc( str, ')' );
			break;
		case OP_NOT:
			bu_vls_strcat( str, "(!" );
			describe_tree( tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_GUARD:
			bu_vls_strcat( str, "(G" );
			describe_tree( tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_XNOP:
			bu_vls_strcat( str, "(X" );
			describe_tree( tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_NOP:
			bu_vls_strcat( str, "NOP" );
			break;
		default:
			bu_log( "ERROR: describe_tree() got unrecognized op (%d)\n", tree->tr_op );
			bu_bomb( "ERROR: bad op\n" );
d611 17
a627 17
	int i;
	ostringstream ostr;
	string name;

	directory *dp;

	// Create the geometry modify and query tool
	GeometryModifyTool *gmt = GeometryModifyTool::instance();
	GeometryQueryTool *gqt = GeometryQueryTool::instance();

	dp = DB_FULL_PATH_CUR_DIR(pathp);

	if (debug&DEBUG_NAMES) {
	    char *name = db_path_to_string(pathp);
	    bu_log("leaf_func    %s\n", name);
	    bu_free(name, "region_end name");
	}
d629 40
a668 40
	/* handle each type of primitive (see h/rtgeom.h) */
	if( ip->idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
		switch( ip->idb_minor_type )
			{
			/* most commonly used primitives */
			case ID_TOR:	/* torus */
				{
					CubitVector x_axis(1.0, 0.0, 0.0);
					CubitVector y_axis(0.0, 1.0, 0.0);
					CubitVector z_axis(0.0, 0.0, 1.0);

					rt_tor_internal *tor = ( rt_tor_internal *)ip->idb_ptr;

					if (debug&DEBUG_NAMES) {
					    printf( "Write this torus (name=%s) in your format:\n", dp->d_namep );
					    printf( "\tV=(%g %g %g)\n", V3ARGS( tor->v ) );
					    printf( "\tnormal=(%g %g %g)\n", V3ARGS( tor->h ) );
					    printf( "\tradius1 = %g\n", tor->r_a );
					    printf( "\tradius2 = %g\n", tor->r_h );
					}

					CubitVector tor_v( V3ARGS( tor->v ) );
					CubitVector tor_h( V3ARGS( tor->h ) );

					double tor_ra = tor->r_a;
					double tor_rh = tor->r_h;

					if (gmt->torus(tor_ra, tor_rh)) {
					    g_body_cnt++;
					    ostr << dp->d_namep;
					    name = ostr.str();
					    set_body_id(name, g_body_cnt);
					    ostr.flush();

					    CubitVector raxis = z_axis * tor_h;
					    double rangle = z_axis.interior_angle(tor_h);

					    gqt->rotate(gqt->get_last_body(), raxis, rangle);
					    gqt->translate(gqt->get_last_body(), tor_v);
					}
d670 67
a736 80
					break;
				}
			case ID_TGC: /* truncated general cone frustum */
			case ID_REC: /* right elliptical cylinder */
				{
					/* This primitive includes circular cross-section
					 * cones and cylinders
					 */
					CubitVector x_axis(1.0, 0.0, 0.0);
					CubitVector y_axis(0.0, 1.0, 0.0);
					CubitVector z_axis(0.0, 0.0, 1.0);

					bool direct_convert = false;

					fastf_t maxb, ma, mb, mc, md, mh;
					vect_t axb;

					CubitVector bbc[8];  // bounding box corners
					CubitVector center_of_base;

					rt_tgc_internal *tgc = ( rt_tgc_internal *)ip->idb_ptr;

					if (debug&DEBUG_NAMES) {
					    printf( "Write this TGC (name=%s) in your format:\n", dp->d_namep );
					    printf( "\tV=(%g %g %g)\n", V3ARGS( tgc->v ) );
					    printf( "\tH=(%g %g %g)\n", V3ARGS( tgc->h ) );
					    printf( "\tA=(%g %g %g)\n", V3ARGS( tgc->a ) );
					    printf( "\tB=(%g %g %g)\n", V3ARGS( tgc->b ) );
					    printf( "\tC=(%g %g %g)\n", V3ARGS( tgc->c ) );
					    printf( "\tD=(%g %g %g)\n", V3ARGS( tgc->d ) );
					}

					CubitVector tgc_v( V3ARGS( tgc->v ) );
					CubitVector tgc_h( V3ARGS( tgc->h ) );
					CubitVector tgc_a( V3ARGS( tgc->a ) );
					CubitVector tgc_b( V3ARGS( tgc->b ) );
					CubitVector tgc_c( V3ARGS( tgc->c ) );
					CubitVector tgc_d( V3ARGS( tgc->d ) );

					VCROSS(axb, tgc->a, tgc->b);
					maxb = MAGNITUDE(axb);
					ma = MAGNITUDE( tgc->a );
					mb = MAGNITUDE( tgc->b );
					mc = MAGNITUDE( tgc->c );
					md = MAGNITUDE( tgc->d );
					mh = MAGNITUDE( tgc->h );

					// check for right cone or cylinder
					if ( fabs(fabs(VDOT(tgc->h,axb)) - (mh*maxb)) < NEARZERO ) {
					   // have a right cylinder or cone
					   if ( fabs((ma - mc) - (mb - md))  < NEARZERO ) {
					      // have similar and aligned base and top
					      direct_convert = true;
					   }
					}

					if (direct_convert) {
					   if (gmt->cylinder(mh, ma, mb, mc)) {
					      g_body_cnt++;
					      ostr << dp->d_namep;
					      name = ostr.str();
					      set_body_id(name, g_body_cnt);
					      ostr.flush();

					      if ( (fabs(ma - mb) > NEARZERO )) {
						 double axbangle = x_axis.interior_angle(tgc_a);
						 gqt->rotate(gqt->get_last_body(), z_axis, axbangle);
					      }

					      CubitVector raxis = z_axis * tgc_h;
					      double hangle = z_axis.interior_angle(tgc_h);
					      gqt->rotate(gqt->get_last_body(), raxis, hangle);

					      CubitVector tgc_cp = tgc_v + (tgc_h / 2);
					      gqt->translate(gqt->get_last_body(), tgc_cp);
					      }
					}
					else {
					   goto TESS_CASE;
					}
d738 22
a759 70
				break;
				}
			case ID_ELL:
			case ID_SPH:
				{
					CubitVector x_axis(1.0, 0.0, 0.0);
					CubitVector y_axis(0.0, 1.0, 0.0);
					CubitVector z_axis(0.0, 0.0, 1.0);

					/* spheres and ellipsoids */
					rt_ell_internal *ell = ( rt_ell_internal *)ip->idb_ptr;

					if (debug&DEBUG_NAMES) {
					   printf( "Write this ellipsoid (name=%s) in your format:\n", dp->d_namep );
					   printf( "\tV=(%g %g %g)\n", V3ARGS( ell->v ) );
					   printf( "\tA=(%g %g %g)\n", V3ARGS( ell->a ) );
					   printf( "\tB=(%g %g %g)\n", V3ARGS( ell->b ) );
					   printf( "\tC=(%g %g %g)\n", V3ARGS( ell->c ) );
					}

					CubitVector ell_v( V3ARGS( ell->v ) );

					double magsq_a = MAGSQ ( ell->a );
					double magsq_b = MAGSQ ( ell->b );
					double magsq_c = MAGSQ ( ell->c );

					if ( ( fabs(magsq_a - magsq_b) < NEARZERO ) && ( fabs(magsq_a - magsq_c) < NEARZERO ) ) {
					   if (gmt->sphere( sqrt( magsq_a ) )) {
					      g_body_cnt++;
					      ostr << dp->d_namep;
					      name = ostr.str();
					      set_body_id(name, g_body_cnt);
					      ostr.flush();

					      gqt->translate(gqt->get_last_body(), ell_v);
					   }
					}
					else {
					   vect_t unitv;
					   double angles[5];
					   CubitVector rot_axis;

					   CubitVector ell_a( V3ARGS( ell->a ) );
					   CubitVector ell_b( V3ARGS( ell->b ) );
					   CubitVector ell_c( V3ARGS( ell->c ) );

					   double mag_a = sqrt( magsq_a );
					   double mag_b = sqrt( magsq_b );
					   double mag_c = sqrt( magsq_c );

					   if (gmt->sphere(1.0)) {
					      g_body_cnt++;
					      ostr << dp->d_namep;
					      name = ostr.str();
					      set_body_id(name, g_body_cnt);
					      ostr.flush();

					      CubitVector scale_vector(mag_a, mag_b, mag_c);
					      gqt->scale(gqt->get_last_body(), scale_vector, true);

					      if ( (fabs(mag_a - mag_b) > NEARZERO )) {
						 double axbangle = x_axis.interior_angle(ell_a);
						 gqt->rotate(gqt->get_last_body(), z_axis, axbangle);
					      }

					      CubitVector raxis = z_axis * ell_c;
					      double hangle = z_axis.interior_angle(ell_c);
					      gqt->rotate(gqt->get_last_body(), raxis, hangle);
					      gqt->translate(gqt->get_last_body(), ell_v);
					   }
d761 7
a767 1
					}
d769 33
a801 16
					break;
				}
			case ID_ARB8:	/* convex primitive with from four to six faces */
				{
					/* this primitive may have degenerate faces
					 * faces are: 0123, 7654, 0347, 1562, 0451, 3267
					 * (points listed above in counter-clockwise order)
					 */
					rt_arb_internal *arb = ( rt_arb_internal *)ip->idb_ptr;

					if (debug&DEBUG_NAMES) {
					    printf( "Write this ARB (name=%s) in your format:\n", dp->d_namep );
					    for( i=0 ; i<8 ; i++ ) {
						printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
					    }
					}
d803 36
a838 2
					goto TESS_CASE;
				}
d840 1
a840 3
			case ID_BOT:	/* Bag O' Triangles */
				{
					rt_bot_internal *bot = (rt_bot_internal *)ip->idb_ptr;
d842 16
a857 1
					goto TESS_CASE;
d859 2
a860 2
					break;
				}
d862 3
a864 7
				/* less commonly used primitives */
			case ID_ARS:
				{
					/* series of curves
					 * each with the same number of points
					 */
					rt_ars_internal *ars = ( rt_ars_internal *)ip->idb_ptr;
d866 1
a866 1
					goto TESS_CASE;
d868 2
a869 6
					break;
				}
			case ID_HALF:
				{
					/* half universe defined by a plane */
					 rt_half_internal *half = ( rt_half_internal *)ip->idb_ptr;
d871 7
a877 1
					goto TESS_CASE;
d879 1
a879 6
					break;
				}
			case ID_POLY:
				{
					/* polygons (up to 5 vertices per) */
					rt_pg_internal *pg = ( rt_pg_internal *)ip->idb_ptr;
d881 6
a886 1
					goto TESS_CASE;
d888 1
a888 6
					break;
				}
			case ID_BSPLINE:
				{
					/* NURB surfaces */
					rt_nurb_internal *nurb = ( rt_nurb_internal *)ip->idb_ptr;
d890 6
a895 1
					goto TESS_CASE;
d897 1
a897 22
					break;
				}
			case ID_NMG:
				{
					nmgregion *r;
					shell *s;

					/* N-manifold geometry */
					model *m = ( model *)ip->idb_ptr;

					NMG_CK_MODEL(m);

					/* walk the nmg to convert it to triangular facets */
					nmg_triangulate_model(m, tsp->ts_tol);

					if (make_bot(r, m, s)) {
					   g_body_cnt++;
					   ostr << dp->d_namep;
					   name = ostr.str();
					   set_body_id(name, g_body_cnt);
					   ostr.flush();
					}
d899 6
a904 5
					break;
				}
			case ID_ARBN:
				{
					rt_arbn_internal *arbn = ( rt_arbn_internal *)ip->idb_ptr;
d906 1
a906 1
					goto TESS_CASE;
d908 6
a913 2
					break;
				}
d915 2
a916 6
			case ID_DSP:
				{
					/* Displacement map (terrain primitive) */
					/* normally used for terrain only */
					/* the DSP primitive may reference an external file */
					rt_dsp_internal *dsp = ( rt_dsp_internal *)ip->idb_ptr;
d918 1
a918 1
					goto TESS_CASE;
d920 10
a929 7
					break;
				}
			case ID_HF:
				{
					/* height field (terrain primitive) */
					/* the HF primitive references an external file */
					rt_hf_internal *hf = ( rt_hf_internal *)ip->idb_ptr;
d931 5
a935 1
					goto TESS_CASE;
d937 1
a937 2
					break;
				}
d939 2
a940 6
				/* rarely used primitives */
			case ID_EBM:
				{
					/* extruded bit-map */
					/* the EBM primitive references an external file */
					rt_ebm_internal *ebm = ( rt_ebm_internal *)ip->idb_ptr;
d942 6
a947 1
					goto TESS_CASE;
d949 1
a949 6
					break;
				}
			case ID_VOL:
				{
					/* the VOL primitive references an external file */
					rt_vol_internal *vol = ( rt_vol_internal *)ip->idb_ptr;
d951 7
a957 1
					goto TESS_CASE;
d959 1
a959 5
					break;
				}
			case ID_PIPE:
				{
					rt_pipe_internal *pipe = ( rt_pipe_internal *)ip->idb_ptr;
d961 2
a962 1
					goto TESS_CASE;
d964 6
a969 5
					break;
				}
			case ID_PARTICLE:
				{
					rt_part_internal *part = ( rt_part_internal *)ip->idb_ptr;
d971 1
a971 1
					goto TESS_CASE;
d973 6
a978 5
					break;
				}
			case ID_RPC:
				{
					rt_rpc_internal *rpc = ( rt_rpc_internal *)ip->idb_ptr;
d980 1
a980 1
					goto TESS_CASE;
d982 5
a986 5
					break;
				}
			case ID_RHC:
				{
					rt_rhc_internal *rhc = ( rt_rhc_internal *)ip->idb_ptr;
d988 1
a988 1
					goto TESS_CASE;
d990 5
a994 5
					break;
				}
			case ID_EPA:
				{
					rt_epa_internal *epa = ( rt_epa_internal *)ip->idb_ptr;
d996 1
a996 1
					goto TESS_CASE;
d998 5
a1002 5
					break;
				}
			case ID_EHY:
				{
					rt_ehy_internal *ehy = ( rt_ehy_internal *)ip->idb_ptr;
d1004 1
a1004 1
					goto TESS_CASE;
d1006 5
a1010 5
					break;
				}
			case ID_ETO:
				{
					rt_eto_internal *eto = ( rt_eto_internal *)ip->idb_ptr;
d1012 1
a1012 1
					goto TESS_CASE;
d1014 5
a1018 5
					break;
				}
			case ID_GRIP:
				{
					rt_grip_internal *grip = ( rt_grip_internal *)ip->idb_ptr;
d1020 1
a1020 1
					goto TESS_CASE;
d1022 5
a1026 2
					break;
				}
d1028 1
a1028 3
			case ID_SKETCH:
				{
					rt_sketch_internal *sketch = ( rt_sketch_internal *)ip->idb_ptr;
d1030 5
a1034 1
					goto TESS_CASE;
d1036 1
a1036 8
					break;
				}
			case ID_EXTRUDE:
				{
					/* note that an extrusion references a sketch, make sure you convert
					 * the sketch also
					 */
					rt_extrude_internal *extrude = ( rt_extrude_internal *)ip->idb_ptr;
d1038 5
a1042 1
					goto TESS_CASE;
d1044 1
a1044 2
					break;
				}
d1046 2
a1047 10
			default:    TESS_CASE:
				// bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_type );
				// break;
	{
	    /* This section is for primitives which cannot be directly represented in the
	     * format we are going to.  So we convert it to triangles
	     */
	    nmgregion *r;
	    model *m = nmg_mm();
	    shell *s;
d1049 3
a1051 1
	    NMG_CK_MODEL(m);
d1053 1
a1053 3
	    if (rt_functab[ip->idb_type].ft_tessellate(&r, m, ip, tsp->ts_ttol, tsp->ts_tol) != 0) {
	       exit(-1);
	    }
d1055 8
a1062 11
	    //bu_log("triangulate %d\n", ip->idb_minor_type);
	    /* walk the nmg to convert it to triangular facets */
	    nmg_triangulate_model(m, tsp->ts_tol);

	    if (make_bot(r, m, s)) {
	       g_body_cnt++;
	       ostr << dp->d_namep;
	       name = ostr.str();
	       set_body_id(name, g_body_cnt);
	       ostr.flush();
	    }
d1064 1
d1066 2
a1067 2
	    break;
	}
d1069 28
a1097 10
		 }
	}
	else {
		switch( ip->idb_major_type ) {
			case DB5_MAJORTYPE_BINARY_UNIF:
				{
					/* not actually a primitive, just a block of storage for data
					 * a uniform array of chars, ints, floats, doubles, ...
					 */
					rt_binunif_internal *bin = ( rt_binunif_internal *)ip->idb_ptr;
d1099 1
a1099 6
					printf( "Found a binary object (%s)\n\n", dp->d_namep );
					break;
				}
			default:
				bu_log( "Major type of %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_major_type );
				break;
d1101 19
d1121 1
d1123 1
a1123 1
	return ( tree *) NULL;
d1133 1
a1133 1
	vertex *v;
d1135 2
a1136 3
	for( BU_LIST_FOR( s, shell, &r->s_hd ) )
	{
		faceuse *fu;
d1138 1
a1138 1
		NMG_CK_SHELL( s );
d1140 3
a1142 4
		for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
		{
			loopuse *lu;
			vect_t facet_normal;
d1144 1
a1144 1
			NMG_CK_FACEUSE( fu );
d1146 2
a1147 2
			if( fu->orientation != OT_SAME )
				continue;
d1149 2
a1150 2
			/* Grab the face normal if needed */
			NMG_GET_FU_NORMAL( facet_normal, fu);
d1152 2
a1153 3
			for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
			{
				edgeuse *eu;
d1155 1
a1155 1
				NMG_CK_LOOPUSE( lu );
d1157 2
a1158 2
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;
d1160 4
a1163 5
				/* loop through the edges in this loop (facet) */
				printf( "\tfacet:\n" );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );
d1165 3
a1167 5
					v = eu->vu_p->v_p;
					NMG_CK_VERTEX( v );
					printf( "\t\t(%g %g %g)\n", V3ARGS( v->vg_p->coord ) );
				}
			}
d1169 1
d1171 1
d1181 3
a1183 10
	// Create the geometry modify and query tool
	GeometryModifyTool *gmt = GeometryModifyTool::instance();
	GeometryQueryTool *gqt = GeometryQueryTool::instance();

	vertex *v;

	CubitVector cv;
	DLIList <RefVertex*> VertexList;
	DLIList <RefEdge*> EdgeList;
	DLIList <RefFace*> FaceList;
d1185 1
a1185 3
	for( BU_LIST_FOR( s, shell, &r->s_hd ) )
	{
		faceuse *fu;
d1187 4
a1190 1
		NMG_CK_SHELL( s );
d1192 2
a1193 4
		for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
		{
			loopuse *lu;
			vect_t facet_normal;
d1195 3
a1197 1
			NMG_CK_FACEUSE( fu );
d1199 2
a1200 2
			if( fu->orientation != OT_SAME )
				continue;
d1202 1
a1202 2
			/* Grab the face normal if needed */
			NMG_GET_FU_NORMAL( facet_normal, fu);
d1204 3
a1206 3
			for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
			{
				edgeuse *eu;
d1208 1
a1208 1
				NMG_CK_LOOPUSE( lu );
d1210 2
a1211 2
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;
d1213 2
a1214 5
				/* loop through the edges in this loop (facet) */
				// printf( "\tfacet:\n" );
				for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
				{
					NMG_CK_EDGEUSE( eu );
d1216 2
a1217 11
					v = eu->vu_p->v_p;
					NMG_CK_VERTEX( v );
					// printf( "\t\t(%g %g %g)\n", V3ARGS( v->vg_p->coord ) );
					cv.set(V3ARGS( v->vg_p->coord ));
					VertexList.append(gmt->make_RefVertex(cv));
				}
				const int MAX_VERTICES = 3;
				for (int i=0; i <= MAX_VERTICES-1; i++) {
				    EdgeList.append(gmt->make_RefEdge(STRAIGHT_CURVE_TYPE,
						    VertexList[i], VertexList[(i+1)%MAX_VERTICES]));
				}
d1219 1
a1219 1
				RefFace *face = gmt->make_RefFace(PLANE_SURFACE_TYPE, EdgeList);
d1221 2
a1222 2
				EdgeList.clean_out();
				VertexList.clean_out();
d1224 4
a1227 2
				FaceList.append(face);
			}
d1229 11
d1242 8
a1250 1
	Body *BotBody, *RegBotBody;
d1252 4
a1255 1
	CubitStatus status;
d1257 1
a1257 1
	status = gmt->create_body_from_surfs(FaceList, BotBody);
d1259 19
a1277 7
	if (status != CUBIT_FAILURE) {
	   cout << "make_bot made a Body!" << endl;
	   gmt->regularize_body(BotBody, RegBotBody);
	}
	else {
	   cout << "make_bot did not made a Body!" << endl;
	}
d1279 1
a1279 1
	FaceList.clean_out();
d1281 1
a1281 1
	return status;
d1287 1
a1287 1
   g_body_id_map[body_name] = body_id;
d1293 2
a1294 2
   const int ERR_FLAG = -99;
   int rVal;
d1296 2
a1297 2
   map<string, int>::iterator iter;
   iter = g_body_id_map.find(body_name);
d1299 6
a1304 6
   if (iter != g_body_id_map.end()) {
      rVal = iter->second;
   }
   else {
      rVal = ERR_FLAG;
   }
d1306 1
a1306 1
   return rVal;
d1312 55
a1366 31
	union tree              *tl;
	union tree              *tr;
	int                     op;
	const char              *op_str;
	char                    *name;

	enum BOOL_ENUM_TYPE { ADD, ISECT, SUBTR };

	RT_CK_TREE(tp);

	switch(tp->tr_op) {
	case OP_NOP:
		return(0);
	case OP_DB_LEAF:
		/* Hit a tree leaf */
		return tp;
	case OP_UNION:
		op = ADD;
		op_str = " u ";
		break;
	case OP_INTERSECT:
		op = ISECT;
		op_str = " + ";
		break;
	case OP_SUBTRACT:
		op = SUBTR;
		op_str = " - ";
		break;
	default:
		bu_log("booltree_evaluate: bad op %d\n", tp->tr_op);
		return(0);
d1368 5
a1372 29
	/* Handle a boolean operation node.  First get it's leaves. */
	tl = booltree_evaluate(tp->tr_b.tb_left, resp);
	tr = booltree_evaluate(tp->tr_b.tb_right, resp);

	if (tl == 0 || !tl->tr_d.td_r) {
		if (tr == 0 || !tr->tr_d.td_r)
			return 0;
		if( op == ADD )
			return tr;
		/* For sub and intersect, if lhs is 0, result is null */
		//db_free_tree(tr);
		tp->tr_b.tb_right = TREE_NULL;
		tp->tr_op = OP_NOP;
		return 0;
	}
	if (tr == 0 || !tr->tr_d.td_r) {
		if (tl == 0 || !tl->tr_d.td_r)
			return 0;
		if( op == ISECT )  {
			db_free_tree(tl, resp);
			tp->tr_b.tb_left = TREE_NULL;
			tp->tr_op = OP_NOP;
			return 0;
		}
		/* For sub and add, if rhs is 0, result is lhs */
		return tl;
	}
	if( tl->tr_op != OP_DB_LEAF )  rt_bomb("booltree_evaluate() bad left tree\n");
	if( tr->tr_op != OP_DB_LEAF )  rt_bomb("booltree_evaluate() bad right tree\n");
d1374 2
a1375 2
	bu_log(" {%s}%s{%s}\n", tl->tr_d.td_name, op_str, tr->tr_d.td_name );
	cout << "******" << tl->tr_d.td_name << op_str << tr->tr_d.td_name << "***********" << endl;
d1377 17
a1393 17
	/* Build string of result name */
	name = (char *)bu_malloc( strlen(tl->tr_d.td_name)+3+strlen(tr->tr_d.td_name)+2+1,
		"booltree_evaluate name");
	name[0] = '(';
	strcpy( name+1, tl->tr_d.td_name );
	strcat( name+1, op_str );
	strcat( name+1, tr->tr_d.td_name );
	strcat( name+1, ")" );

	/* Clean up child tree nodes (and their names) */
	db_free_tree(tl, resp);
	db_free_tree(tr, resp);

	/* Convert argument binary node into a result node */
	tp->tr_op = OP_DB_LEAF;
	tp->tr_d.td_name = name;
	return tp;
d1399 14
a1412 12
   stack <char> s;
   ostringstream ostr;
   char c;

   for (int i = 0; i < strlen(str.c_str()); i++) {
      c = str[i];
      if ( c == '(' ) {
	 s.push(c);
      }
      else if ( c == ')' ) {
	 while ( (c = s.top()) != '(' ) {
	    ostr << ' ' << c;
d1414 14
a1427 16
	 }
	 s.pop();
      }
      else if (((c == 'u') || (c == '+') || (c == '-')) && (str[i+1] == ' ')) {
	 s.push(c);
	 i++;
      }
      else {
	 ostr << c ;
      }
   }

   if (!s.empty()) {
      ostr << s.top();
      s.pop();
   }
d1429 1
a1429 1
   return ostr.str();
d1434 2
a1435 2
   // Skip delimiters at beginning.
   string::size_type lastPos = str.find_first_not_of(delimiters, 0);
d1437 2
a1438 2
   // Find first "non-delimiter".
   string::size_type pos     = str.find_first_of(delimiters, lastPos);
d1440 10
a1449 10
   while (string::npos != pos || string::npos != lastPos) {
       // Found a token, add it to the vector.
       tokens.push_back(str.substr(lastPos, pos - lastPos));

       // Skip delimiters.  Note the "not_of"
       lastPos = str.find_first_not_of(delimiters, pos);

       // Find next "non-delimiter"
       pos = str.find_first_of(delimiters, lastPos);
   }
@


1.5
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.4 2007/01/23 01:13:27 brlcad Exp $";
a86 4
/*
extern char *optarg;
extern int optind, opterr, getopt();
*/
d164 1
a164 1
	while ((c = getopt(argc, argv, "t:a:n:o:r:vx:X:")) != EOF) {
d167 1
a167 1
			tol.dist = atof( optarg );
d171 1
a171 1
			output_file = optarg;
d177 1
a177 1
			sscanf( optarg, "%x", &rt_g.debug );
d182 1
a182 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
d193 1
a193 1
	if (optind+1 >= argc) {
d231 2
a232 2
	/* rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf)); */
	rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf));
d255 1
a255 1
	optind++;
d260 1
a260 1
	for( i=optind ; i<argc ; i++ )
@


1.4
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.3 2007/01/21 04:45:41 brlcad Exp $";
d137 3
a139 3
        struct user_data {
           int info;
        } user_data;
d143 1
a143 1
        char idbuf[132];
d145 1
a145 1
        char *output_file = NULL;
d151 2
a152 2
         rt_db_internal intern;
         directory *dp;
d154 2
a155 2
         rt_i *rtip;
         db_tree_state init_state;
d175 1
a175 1
                        output_file = optarg;
d202 3
a204 3
        // ***********************************************************************************
        // Setup Cubit Routines
        // ***********************************************************************************
d206 3
a208 3
        // CGM Initialization
        const char* ACIS_SAT = "ACIS_SAT";
        const char* OUTPUT_FILE = "test.sat";
d210 2
a211 2
        int dummy_argc = 0;
        char **dummy_argv =NULL;
d213 3
a215 3
        // Initialize the application
        AppUtil::instance()->startup(dummy_argc, dummy_argv);
        CGMApp::instance()->startup(dummy_argc, dummy_argv);
d217 1
a217 1
        CGMApp::instance()->attrib_manager()->auto_flag(true);
d219 3
a221 3
        // Create the geometry modify and query tool
        GeometryModifyTool *gmt = GeometryModifyTool::instance();
        GeometryQueryTool *gqt = GeometryQueryTool::instance();
d223 3
a225 3
        // Create the  ACIS engines
        AcisQueryEngine::instance();
        AcisModifyEngine::instance();
d227 3
a229 3
        // Get version number of the geometry engine.
        CubitString version = gqt->get_engine_version_string();
        cout << "ACIS Engine: " << version << endl;
d231 1
a231 1
        CubitStatus status;
d235 22
a256 22
        /* rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf)); */
        rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf));
        if ( rtip == RTI_NULL) {
           fprintf(stderr,"g-xxx: rt_dirbuild failure\n");
           exit(1);
        }

        init_state = rt_initial_tree_state;
        init_state.ts_dbip = rtip->rti_dbip;
        init_state.ts_rtip = rtip;
        init_state.ts_resp = NULL;
        init_state.ts_tol = &tol;
        init_state.ts_ttol = &ttol;
        bu_avs_init(&init_state.ts_attrs, 1, "avs in tree_state");
    
        /* Set up tesselation tolerance defaults */
        ttol.magic = RT_TESS_TOL_MAGIC;

        /* Defaults, updated by command line options. */
        ttol.abs = 0.0;
        ttol.rel = 0.01;
        ttol.norm = 0.0;
d266 2
a267 2
            db_walk_tree(rtip->rti_dbip, argc - i, (const char **)&argv[i], NUM_OF_CPUS_TO_USE,
                         &init_state ,region_start, region_end, primitive_func, (genptr_t) &user_data);
d270 7
a276 3
        // *************************************************************************************
        // Write SAT file
        // *************************************************************************************
d278 2
a279 6
        // Make bodies list.
        DLIList<Body*> all_bodies, old_bodies, new_bodies, tools_bodies;
        Body* tool_body;

        // Get the global list
        //gqt->bodies(all_bodies);
d282 1
a282 1
        tools_bodies.append(gqt->get_body(get_body_id("cone.s")));
d284 1
a284 1
        gmt->unite(all_bodies, new_bodies);
d288 5
a292 5
        cout << "*** STL MAP DEBUG BEGIN ***" << endl;
        for(g_itr = g_body_id_map.begin(); g_itr != g_body_id_map.end(); g_itr++) {
           cout << g_itr->first << '\t' << g_itr->second << endl;
        }
        cout << "*** STL MAP DEBUG END ***" << endl;
a293 78
 
        cout << "*** CSG DEBUG BEGIN ***" << endl;
        DLIList<Body*> all_region_bodies, region_bodies, from_bodies;
        Body* region_body;

        for (int i=0; i < g_CsgBoolExp.size(); i++) {
           cout << " R" << i << " = " << g_CsgBoolExp[i] << ": " << get_body_id(g_CsgBoolExp[i]) << endl;
           //if (i == 4) continue;

           int body_id = get_body_id(g_CsgBoolExp[i]);

           if (body_id  >= 0) {
               //region_bodies.append(gqt->get_body(get_body_id(g_CsgBoolExp[i])));
               all_region_bodies.append(gqt->get_body(body_id));
           }
           else if (body_id == -1) { // {empty}
               cout << "DEBUG: {empty}" << endl;
           }
           else {
               //tokenize
               vector <string> csgTokens;
               char csgOp;

               tokenize(g_CsgBoolExp[i],csgTokens," ");
               
               cout << "DEBUG " << csgTokens.size() << endl;
               for (int j = 0; j < csgTokens.size(); j++) {
                  cout <<"    T" << j << " = " << csgTokens[j] << ": " << get_body_id(csgTokens[j]) << endl;

                  if (get_body_id(csgTokens[j]) >= 0) {
                     region_bodies.append(gqt->get_body(get_body_id(csgTokens[j])));
                  }
                  else {
                     csgOp = csgTokens[j].at(0);
                     cout << "*DEBUG*  csgOp = " << csgOp << endl;
                     switch (csgOp) {
                        case '+':
                           cout << "*** DEBUG INTERSECT ***" << endl;
                           tool_body = region_bodies.pop();
                           from_bodies.append(region_bodies.pop());
                           gmt->intersect(tool_body, from_bodies, region_bodies, CUBIT_TRUE);
                           break;
                        case '-':
                           cout << "*** DEBUG SUBTRACT ***" << endl;
                           tool_body = region_bodies.pop();
                           from_bodies.append(region_bodies.pop());
                           gmt->subtract(tool_body, from_bodies, region_bodies, CUBIT_TRUE);
                           break;
                        case 'u':
                           cout << "*** DEBUG UNION ***" << endl;
                           if (region_bodies.size() >= 2) {
                              from_bodies.append(region_bodies.pop());
                              from_bodies.append(region_bodies.pop());
                              if (!gmt->unite(from_bodies, region_bodies, CUBIT_TRUE)) {
                                 cout << "GOT HERE!" << endl;
                                 region_bodies+=from_bodies;
                              }
                           }
                           else {
                              region_bodies+=from_bodies;
                           } 
                           break;
                        default:
                           // do nothing -- should get here
                           break;
                     }

                     from_bodies.clean_out();
                  }

               }               

               csgTokens.clear();

               if (region_bodies.size() != 0) {
                  all_region_bodies+=region_bodies;
                  region_bodies.clean_out();
               }
d295 72
a366 1
           }
d368 8
a375 1
        }
d377 2
a378 2
        from_bodies.append(gqt->get_body(get_body_id("narb8.s")));
        gmt->subtract(gqt->get_body(get_body_id("sph.s")),from_bodies, region_bodies, CUBIT_TRUE);
d381 1
a381 1
        //gmt->imprint(all_bodies, region_bodies);
d385 5
a389 5
        vector<string>::const_iterator ci;
        for (ci=g_CsgBoolExp.begin(); ci!=g_CsgBoolExp.end(); ci++) {
           cout << *ci << endl;
           region_bodies.append(gqt->get_body(get_body_id(*ci)));
        }
d391 1
a391 1
        cout << "*** CSG DEBUG END ***" << endl;
d393 1
a393 1
        //gmt->imprint(old_bodies, all_bodies);
d395 35
a429 35
        /*
        if (status == CUBIT_FAILURE) {
           cout << "Failure" << endl;
           exit(1);
        }
        */

        // Make entities list.
        DLIList<RefEntity*> parent_entities;

        // Cast boddies list to entities list
        //CAST_LIST_TO_PARENT(new_bodies, parent_entities);
        
        //gqt->bodies(all_bodies);
        //cout << "The size is " << all_bodies.size() << endl;
        //CAST_LIST_TO_PARENT(all_bodies, parent_entities);
        CAST_LIST_TO_PARENT(all_region_bodies, parent_entities);

        int size = parent_entities.size();
        cout << "The size is " << size << endl;

         // Export geometry
         if (size != 0) {
            status = gqt->export_solid_model(parent_entities, output_file, ACIS_SAT, size, version);
         }
         else {
           cout << "Failure: No geometry to convert!" << endl;
           exit(1);
        }

        CGMApp::instance()->shutdown();

        cout << "PRINT BODY COUNT: " << g_body_cnt << endl;
        cout << "GOT HERE!" << endl;
        abort();
d449 3
a451 3
               db_full_path *pathp,
              const  rt_comb_internal *combp,
              genptr_t client_data )
d460 3
a462 3
        char *name = db_path_to_string(pathp);
        bu_log("region_start %s\n", name);
        bu_free(name, "reg_start name");
d509 3
a511 3
             db_full_path *pathp,
             tree *curtree,
            genptr_t client_data )
d514 3
a516 3
        char *name = db_path_to_string(pathp);
        bu_log("region_end   %s\n", name);
        bu_free(name, "region_end name");
d528 1
a528 1
                bu_vls *str)
d543 1
a543 1
                set_body_id("{empty}", -1);
a607 1

d612 3
a614 3
                db_full_path *pathp,
                rt_db_internal *ip,
                genptr_t client_data)
d618 17
a634 17
        int i;
        ostringstream ostr;
        string name;

        directory *dp;

        // Create the geometry modify and query tool
        GeometryModifyTool *gmt = GeometryModifyTool::instance();
        GeometryQueryTool *gqt = GeometryQueryTool::instance();

        dp = DB_FULL_PATH_CUR_DIR(pathp);

        if (debug&DEBUG_NAMES) {
            char *name = db_path_to_string(pathp);
            bu_log("leaf_func    %s\n", name);
            bu_free(name, "region_end name");
        }
d643 3
a645 3
                                        CubitVector x_axis(1.0, 0.0, 0.0);
                                        CubitVector y_axis(0.0, 1.0, 0.0);
                                        CubitVector z_axis(0.0, 0.0, 1.0);
d649 1
a649 1
                                        if (debug&DEBUG_NAMES) {
d655 1
a655 1
                                        }
d657 2
a658 2
                                        CubitVector tor_v( V3ARGS( tor->v ) );
                                        CubitVector tor_h( V3ARGS( tor->h ) );
d660 2
a661 2
                                        double tor_ra = tor->r_a;
                                        double tor_rh = tor->r_h;
d663 13
a675 13
                                        if (gmt->torus(tor_ra, tor_rh)) {
                                            g_body_cnt++;
                                            ostr << dp->d_namep;
                                            name = ostr.str();
                                            set_body_id(name, g_body_cnt);
                                            ostr.flush();

                                            CubitVector raxis = z_axis * tor_h;
                                            double rangle = z_axis.interior_angle(tor_h);

                                            gqt->rotate(gqt->get_last_body(), raxis, rangle);
                                            gqt->translate(gqt->get_last_body(), tor_v);
                                        }
d685 3
a687 3
                                        CubitVector x_axis(1.0, 0.0, 0.0);
                                        CubitVector y_axis(0.0, 1.0, 0.0);
                                        CubitVector z_axis(0.0, 0.0, 1.0);
d689 1
a689 1
                                        bool direct_convert = false;
d691 2
a692 2
                                        fastf_t maxb, ma, mb, mc, md, mh;
                                        vect_t axb;
d694 2
a695 2
                                        CubitVector bbc[8];  // bounding box corners
                                        CubitVector center_of_base;
d699 1
a699 1
                                        if (debug&DEBUG_NAMES) {
d707 1
a707 1
                                        }
d709 48
a756 48
                                        CubitVector tgc_v( V3ARGS( tgc->v ) );
                                        CubitVector tgc_h( V3ARGS( tgc->h ) );
                                        CubitVector tgc_a( V3ARGS( tgc->a ) );
                                        CubitVector tgc_b( V3ARGS( tgc->b ) );
                                        CubitVector tgc_c( V3ARGS( tgc->c ) );
                                        CubitVector tgc_d( V3ARGS( tgc->d ) );

                                        VCROSS(axb, tgc->a, tgc->b);
                                        maxb = MAGNITUDE(axb);
                                        ma = MAGNITUDE( tgc->a );
                                        mb = MAGNITUDE( tgc->b );
                                        mc = MAGNITUDE( tgc->c );
                                        md = MAGNITUDE( tgc->d );
                                        mh = MAGNITUDE( tgc->h );

                                        // check for right cone or cylinder
                                        if ( fabs(fabs(VDOT(tgc->h,axb)) - (mh*maxb)) < NEARZERO ) {
                                           // have a right cylinder or cone
                                           if ( fabs((ma - mc) - (mb - md))  < NEARZERO ) {
                                              // have similar and aligned base and top
                                              direct_convert = true;
                                           }
                                        }

                                        if (direct_convert) {
                                           if (gmt->cylinder(mh, ma, mb, mc)) {
                                              g_body_cnt++;
                                              ostr << dp->d_namep;
                                              name = ostr.str();
                                              set_body_id(name, g_body_cnt);
                                              ostr.flush();

                                              if ( (fabs(ma - mb) > NEARZERO )) {
                                                 double axbangle = x_axis.interior_angle(tgc_a);
                                                 gqt->rotate(gqt->get_last_body(), z_axis, axbangle);
                                              }

                                              CubitVector raxis = z_axis * tgc_h;
                                              double hangle = z_axis.interior_angle(tgc_h);
                                              gqt->rotate(gqt->get_last_body(), raxis, hangle);

                                              CubitVector tgc_cp = tgc_v + (tgc_h / 2);
                                              gqt->translate(gqt->get_last_body(), tgc_cp);
                                              }
                                        }
                                        else {
                                           goto TESS_CASE;
                                        }
d758 1
a758 1
                                break;
d763 3
a765 3
                                        CubitVector x_axis(1.0, 0.0, 0.0);
                                        CubitVector y_axis(0.0, 1.0, 0.0);
                                        CubitVector z_axis(0.0, 0.0, 1.0);
d770 1
a770 1
                                        if (debug&DEBUG_NAMES) {
d776 1
a776 1
                                        }
d778 1
a778 1
                                        CubitVector ell_v( V3ARGS( ell->v ) );
d780 48
a827 48
                                        double magsq_a = MAGSQ ( ell->a );
                                        double magsq_b = MAGSQ ( ell->b );
                                        double magsq_c = MAGSQ ( ell->c );
                                            
                                        if ( ( fabs(magsq_a - magsq_b) < NEARZERO ) && ( fabs(magsq_a - magsq_c) < NEARZERO ) ) {
                                           if (gmt->sphere( sqrt( magsq_a ) )) {
                                              g_body_cnt++;
                                              ostr << dp->d_namep;
                                              name = ostr.str();
                                              set_body_id(name, g_body_cnt);
                                              ostr.flush();

                                              gqt->translate(gqt->get_last_body(), ell_v);
                                           }
                                        }
                                        else {
                                           vect_t unitv;
                                           double angles[5];
                                           CubitVector rot_axis;

                                           CubitVector ell_a( V3ARGS( ell->a ) );
                                           CubitVector ell_b( V3ARGS( ell->b ) );
                                           CubitVector ell_c( V3ARGS( ell->c ) );

                                           double mag_a = sqrt( magsq_a );
                                           double mag_b = sqrt( magsq_b );
                                           double mag_c = sqrt( magsq_c );

                                           if (gmt->sphere(1.0)) {
                                              g_body_cnt++;
                                              ostr << dp->d_namep;
                                              name = ostr.str();
                                              set_body_id(name, g_body_cnt);
                                              ostr.flush();

                                              CubitVector scale_vector(mag_a, mag_b, mag_c);
                                              gqt->scale(gqt->get_last_body(), scale_vector, true);

                                              if ( (fabs(mag_a - mag_b) > NEARZERO )) {
                                                 double axbangle = x_axis.interior_angle(ell_a);
                                                 gqt->rotate(gqt->get_last_body(), z_axis, axbangle);
                                              }

                                              CubitVector raxis = z_axis * ell_c;
                                              double hangle = z_axis.interior_angle(ell_c);
                                              gqt->rotate(gqt->get_last_body(), raxis, hangle);
                                              gqt->translate(gqt->get_last_body(), ell_v);
                                           }
d829 1
a829 1
                                        }
d841 1
a841 1
                                        if (debug&DEBUG_NAMES) {
d844 3
a846 3
					        printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
                                            }
                                        }
d848 1
a848 1
                                        goto TESS_CASE;
d853 1
a853 1
                                        rt_bot_internal *bot = (rt_bot_internal *)ip->idb_ptr;
d855 1
a855 1
                                        goto TESS_CASE;
d868 1
a868 1
                                        goto TESS_CASE;
d877 1
a877 1
                                        goto TESS_CASE;
d886 1
a886 1
                                        goto TESS_CASE;
d895 1
a895 1
                                        goto TESS_CASE;
d901 2
a902 2
                                        nmgregion *r;
                                        shell *s;
d907 1
a907 1
                                        NMG_CK_MODEL(m);
d909 2
a910 2
                                        /* walk the nmg to convert it to triangular facets */
                                        nmg_triangulate_model(m, tsp->ts_tol);
d912 7
a918 7
                                        if (make_bot(r, m, s)) {
                                           g_body_cnt++;
                                           ostr << dp->d_namep;
                                           name = ostr.str();
                                           set_body_id(name, g_body_cnt);
                                           ostr.flush();
                                        }
d926 1
a926 1
                                        goto TESS_CASE;
d938 1
a938 1
                                        goto TESS_CASE;
d948 1
a948 1
                                        goto TESS_CASE;
d960 1
a960 1
                                        goto TESS_CASE;
d969 1
a969 1
                                        goto TESS_CASE;
d977 1
a977 1
                                        goto TESS_CASE;
d985 1
a985 1
                                        goto TESS_CASE;
d993 1
a993 1
                                        goto TESS_CASE;
d1001 1
a1001 1
                                        goto TESS_CASE;
d1009 1
a1009 1
                                        goto TESS_CASE;
d1017 1
a1017 1
                                        goto TESS_CASE;
d1025 1
a1025 1
                                        goto TESS_CASE;
d1033 1
a1033 1
                                        goto TESS_CASE;
d1042 1
a1042 1
                                        goto TESS_CASE;
d1053 1
a1053 1
                                        goto TESS_CASE;
d1059 27
a1085 27
			        // bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_type );
                                // break;
        {
            /* This section is for primitives which cannot be directly represented in the
             * format we are going to.  So we convert it to triangles
             */
            nmgregion *r;
            model *m = nmg_mm();
            shell *s;

            NMG_CK_MODEL(m);

            if (rt_functab[ip->idb_type].ft_tessellate(&r, m, ip, tsp->ts_ttol, tsp->ts_tol) != 0) {
               exit(-1);
            }

            //bu_log("triangulate %d\n", ip->idb_minor_type);
            /* walk the nmg to convert it to triangular facets */
            nmg_triangulate_model(m, tsp->ts_tol);

            if (make_bot(r, m, s)) {
               g_body_cnt++;
               ostr << dp->d_namep;
               name = ostr.str();
               set_body_id(name, g_body_cnt);
               ostr.flush();
            }
d1088 2
a1089 2
            break;
        }
d1092 1
a1092 1
	         }
d1094 1
a1094 1
        else {
d1112 1
a1112 1
        return ( tree *) NULL;
d1119 2
a1120 2
                  model *m,
                  shell *s )
d1124 1
a1124 1
 	for( BU_LIST_FOR( s, shell, &r->s_hd ) )
d1171 2
a1172 2
          model *m,
          shell *s )
d1174 3
a1176 3
        // Create the geometry modify and query tool
        GeometryModifyTool *gmt = GeometryModifyTool::instance();
        GeometryQueryTool *gqt = GeometryQueryTool::instance();
d1178 1
a1178 1
        vertex *v;
d1180 4
a1183 4
        CubitVector cv;
        DLIList <RefVertex*> VertexList;
        DLIList <RefEdge*> EdgeList;
        DLIList <RefFace*> FaceList;
d1185 3
a1187 3
        for( BU_LIST_FOR( s, shell, &r->s_hd ) )
        {
                faceuse *fu;
d1189 1
a1189 1
                NMG_CK_SHELL( s );
d1191 4
a1194 4
                for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
                {
                        loopuse *lu;
                        vect_t facet_normal;
d1196 1
a1196 1
                        NMG_CK_FACEUSE( fu );
d1198 2
a1199 2
                        if( fu->orientation != OT_SAME )
                                continue;
d1201 2
a1202 2
                        /* Grab the face normal if needed */
                        NMG_GET_FU_NORMAL( facet_normal, fu);
d1204 3
a1206 3
                        for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
                        {
                                edgeuse *eu;
d1208 1
a1208 1
                                NMG_CK_LOOPUSE( lu );
d1210 2
a1211 2
                                if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
                                        continue;
d1213 5
a1217 5
                                /* loop through the edges in this loop (facet) */
                                // printf( "\tfacet:\n" );
                                for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
                                {
                                        NMG_CK_EDGEUSE( eu );
d1219 11
a1229 11
                                        v = eu->vu_p->v_p;
                                        NMG_CK_VERTEX( v );
                                        // printf( "\t\t(%g %g %g)\n", V3ARGS( v->vg_p->coord ) );
                                        cv.set(V3ARGS( v->vg_p->coord ));
                                        VertexList.append(gmt->make_RefVertex(cv));
                                }
                                const int MAX_VERTICES = 3;
                                for (int i=0; i <= MAX_VERTICES-1; i++) {
                                    EdgeList.append(gmt->make_RefEdge(STRAIGHT_CURVE_TYPE,
                                                    VertexList[i], VertexList[(i+1)%MAX_VERTICES]));
                                }
d1231 1
a1231 1
                                RefFace *face = gmt->make_RefFace(PLANE_SURFACE_TYPE, EdgeList);
d1233 2
a1234 2
                                EdgeList.clean_out();
                                VertexList.clean_out();
d1236 2
a1237 2
                                FaceList.append(face);
                        }
d1239 1
a1239 1
                }
d1241 2
a1242 2
        }
        Body *BotBody, *RegBotBody;
d1244 1
a1244 1
        CubitStatus status;
d1246 1
a1246 1
        status = gmt->create_body_from_surfs(FaceList, BotBody);
d1248 7
a1254 7
        if (status != CUBIT_FAILURE) {
           cout << "make_bot made a Body!" << endl;
           gmt->regularize_body(BotBody, RegBotBody); 
        } 
        else {
           cout << "make_bot did not made a Body!" << endl;
        }
d1256 1
a1256 1
        FaceList.clean_out();
d1258 1
a1258 1
        return status;
d1289 82
a1370 82
        union tree              *tl;
        union tree              *tr;
        int                     op;
        const char              *op_str;
        char                    *name;

        enum BOOL_ENUM_TYPE { ADD, ISECT, SUBTR };

        RT_CK_TREE(tp);

        switch(tp->tr_op) {
        case OP_NOP:
                return(0);
        case OP_DB_LEAF:
                /* Hit a tree leaf */
                return tp;
        case OP_UNION:
                op = ADD;
                op_str = " u ";
                break;
        case OP_INTERSECT:
                op = ISECT;
                op_str = " + ";
                break;
        case OP_SUBTRACT:
                op = SUBTR;
                op_str = " - ";
                break;
        default:
                bu_log("booltree_evaluate: bad op %d\n", tp->tr_op);
                return(0);
        }
        /* Handle a boolean operation node.  First get it's leaves. */
        tl = booltree_evaluate(tp->tr_b.tb_left, resp);
        tr = booltree_evaluate(tp->tr_b.tb_right, resp);

        if (tl == 0 || !tl->tr_d.td_r) {
                if (tr == 0 || !tr->tr_d.td_r)
                        return 0;
                if( op == ADD )
                        return tr;
                /* For sub and intersect, if lhs is 0, result is null */
                //db_free_tree(tr);
                tp->tr_b.tb_right = TREE_NULL;
                tp->tr_op = OP_NOP;
                return 0;
        }
        if (tr == 0 || !tr->tr_d.td_r) {
                if (tl == 0 || !tl->tr_d.td_r)
                        return 0;
                if( op == ISECT )  {
                        db_free_tree(tl, resp);
                        tp->tr_b.tb_left = TREE_NULL;
                        tp->tr_op = OP_NOP;
                        return 0;
                }
                /* For sub and add, if rhs is 0, result is lhs */
                return tl;
        }
        if( tl->tr_op != OP_DB_LEAF )  rt_bomb("booltree_evaluate() bad left tree\n");
        if( tr->tr_op != OP_DB_LEAF )  rt_bomb("booltree_evaluate() bad right tree\n");

        bu_log(" {%s}%s{%s}\n", tl->tr_d.td_name, op_str, tr->tr_d.td_name );
        cout << "******" << tl->tr_d.td_name << op_str << tr->tr_d.td_name << "***********" << endl;

        /* Build string of result name */
        name = (char *)bu_malloc( strlen(tl->tr_d.td_name)+3+strlen(tr->tr_d.td_name)+2+1,
                "booltree_evaluate name");
        name[0] = '(';
        strcpy( name+1, tl->tr_d.td_name );
        strcat( name+1, op_str );
        strcat( name+1, tr->tr_d.td_name );
        strcat( name+1, ")" );

        /* Clean up child tree nodes (and their names) */
        db_free_tree(tl, resp);
        db_free_tree(tr, resp);

        /* Convert argument binary node into a result node */
        tp->tr_op = OP_DB_LEAF;
        tp->tr_d.td_name = name;
        return tp;
d1383 1
a1383 1
         s.push(c);
d1386 5
a1390 5
         while ( (c = s.top()) != '(' ) {
            ostr << ' ' << c;
            s.pop();
         }
         s.pop();
d1393 2
a1394 2
         s.push(c);
         i++;
d1397 1
a1397 1
         ostr << c ;
@


1.3
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.2 2007/01/20 14:36:48 brlcad Exp $";
@


1.2
log
@update copyright to 2007
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/external/Cubit/g-sat.cxx,v 1.1 2006/12/07 23:13:48 mjgillich Exp $";
d439 1
a439 1
 * \brief This routine is called when a region is first encountered in the
d442 4
a445 4
 *      \param tsp tree state (for parsing the tree)
 *      \param pathp A listing of all the nodes traversed to get to this node in the database
 *      \param combp the combination record for this region
 *      \param client_data pointer that was passed as last argument to db_walk_tree()
d494 1
a494 1
 * \brief This is called when all sub-elements of a region have been processed by leaf_func.
d496 4
a499 4
 *      \param tsp
 *      \param pathp
 *      \param curtree
 *      \param client_data
d501 1
a501 1
 *      \return TREE_NULL if data in curtree was "stolen", otherwise db_walk_tree will
@


1.1
log
@BRL-CAD to ACIS (export) convertor for importing to CUBIT (1st version) -- needs review and cleanup but fully functional
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2006 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "$Header: $";
@

