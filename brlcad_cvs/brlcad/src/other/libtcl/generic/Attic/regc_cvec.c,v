head	14.2;
access;
symbols
	stable-branch:14.1
	rel-7-8-4:14.1
	rel-7-8-2:14.1
	rel-7-8-0:14.1
	trimnurbs-branch:14.1.0.8
	help:14.1
	temp_tag:14.1
	bobWinPort-20051223-freeze:14.1
	postmerge-20051223-bobWinPort:14.1
	premerge-20051223-bobWinPort:14.1
	rel-7-6-6:14.1
	rel-7-6-4:14.1
	rel-7-6-2:14.1
	rel-7-6-branch:14.1.0.6
	rel-7-6-0:14.1
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.4
	bobWinPort:14.1.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.2
date	2007.03.02.21.46.40;	author brlcad;	state dead;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.21;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.14.51.12;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.2
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@/*
 * Utility functions for handling cvecs
 * This file is #included by regcomp.c.
 *
 * Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
 * 
 * Development of this software was funded, in part, by Cray Research Inc.,
 * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
 * Corporation, none of whom are responsible for the results.  The author
 * thanks all of them. 
 * 
 * Redistribution and use in source and binary forms -- with or without
 * modification -- are permitted for any purpose, provided that
 * redistributions in source form retain this entire copyright notice and
 * indicate the origin and nature of any modifications.
 * 
 * I'd appreciate being given credit for this package in the documentation
 * of software which uses it, but that is not a requirement.
 * 
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 - newcvec - allocate a new cvec
 ^ static struct cvec *newcvec(int, int, int);
 */
static struct cvec *
newcvec(nchrs, nranges, nmcces)
    int nchrs;				/* to hold this many chrs... */
    int nranges;			/* ... and this many ranges... */
    int nmcces;				/* ... and this many MCCEs */
{
    size_t n;
    size_t nc;
    struct cvec *cv;

    nc = (size_t)nchrs + (size_t)nmcces*(MAXMCCE+1) + (size_t)nranges*2;
    n = sizeof(struct cvec) + (size_t)(nmcces-1)*sizeof(chr *)
	    + nc*sizeof(chr);
    cv = (struct cvec *)MALLOC(n);
    if (cv == NULL) {
	return NULL;
    }
    cv->chrspace = nchrs;
    cv->chrs = (chr *)&cv->mcces[nmcces];	/* chrs just after MCCE ptrs */
    cv->mccespace = nmcces;
    cv->ranges = cv->chrs + nchrs + nmcces*(MAXMCCE+1);
    cv->rangespace = nranges;
    return clearcvec(cv);
}

/*
 - clearcvec - clear a possibly-new cvec
 * Returns pointer as convenience.
 ^ static struct cvec *clearcvec(struct cvec *);
 */
static struct cvec *
clearcvec(cv)
    struct cvec *cv;			/* character vector */
{
    int i;

    assert(cv != NULL);
    cv->nchrs = 0;
    assert(cv->chrs == (chr *)&cv->mcces[cv->mccespace]);
    cv->nmcces = 0;
    cv->nmccechrs = 0;
    cv->nranges = 0;
    for (i = 0; i < cv->mccespace; i++) {
	cv->mcces[i] = NULL;
    }

    return cv;
}

/*
 - addchr - add a chr to a cvec
 ^ static VOID addchr(struct cvec *, pchr);
 */
static VOID
addchr(cv, c)
    struct cvec *cv;			/* character vector */
    pchr c;				/* character to add */
{
    assert(cv->nchrs < cv->chrspace - cv->nmccechrs);
    cv->chrs[cv->nchrs++] = (chr)c;
}

/*
 - addrange - add a range to a cvec
 ^ static VOID addrange(struct cvec *, pchr, pchr);
 */
static VOID
addrange(cv, from, to)
    struct cvec *cv;			/* character vector */
    pchr from;				/* first character of range */
    pchr to;				/* last character of range */
{
    assert(cv->nranges < cv->rangespace);
    cv->ranges[cv->nranges*2] = (chr)from;
    cv->ranges[cv->nranges*2 + 1] = (chr)to;
    cv->nranges++;
}

/*
 - addmcce - add an MCCE to a cvec
 ^ static VOID addmcce(struct cvec *, chr *, chr *);
 */
static VOID
addmcce(cv, startp, endp)
    struct cvec *cv;			/* character vector */
    chr *startp;			/* beginning of text */
    chr *endp;				/* just past end of text */
{
    int len;
    int i;
    chr *s;
    chr *d;

    if (startp == NULL && endp == NULL) {
	return;
    }
    len = endp - startp;
    assert(len > 0);
    assert(cv->nchrs + len < cv->chrspace - cv->nmccechrs);
    assert(cv->nmcces < cv->mccespace);
    d = &cv->chrs[cv->chrspace - cv->nmccechrs - len - 1];
    cv->mcces[cv->nmcces++] = d;
    for (s = startp, i = len; i > 0; s++, i--) {
	*d++ = *s;
    }
    *d++ = 0;				/* endmarker */
    assert(d == &cv->chrs[cv->chrspace - cv->nmccechrs]);
    cv->nmccechrs += len + 1;
}

/*
 - haschr - does a cvec contain this chr?
 ^ static int haschr(struct cvec *, pchr);
 */
static int				/* predicate */
haschr(cv, c)
    struct cvec *cv;			/* character vector */
    pchr c;				/* character to test for */
{
    int i;
    chr *p;

    for (p = cv->chrs, i = cv->nchrs; i > 0; p++, i--) {
	if (*p == c) {
	    return 1;
	}
    }
    for (p = cv->ranges, i = cv->nranges; i > 0; p += 2, i--) {
	if ((*p <= c) && (c <= *(p+1))) {
	    return 1;
	}
    }
    return 0;
}

/*
 - getcvec - get a cvec, remembering it as v->cv
 ^ static struct cvec *getcvec(struct vars *, int, int, int);
 */
static struct cvec *
getcvec(v, nchrs, nranges, nmcces)
    struct vars *v;			/* context */
    int nchrs;				/* to hold this many chrs... */
    int nranges;			/* ... and this many ranges... */
    int nmcces;				/* ... and this many MCCEs */
{
    if (v->cv != NULL && nchrs <= v->cv->chrspace &&
	    nranges <= v->cv->rangespace && nmcces <= v->cv->mccespace) {
	return clearcvec(v->cv);
    }

    if (v->cv != NULL) {
	freecvec(v->cv);
    }
    v->cv = newcvec(nchrs, nranges, nmcces);
    if (v->cv == NULL) {
	ERR(REG_ESPACE);
    }

    return v->cv;
}

/*
 - freecvec - free a cvec
 ^ static VOID freecvec(struct cvec *);
 */
static VOID
freecvec(cv)
    struct cvec *cv;			/* character vector */
{
    FREE(cv);
}
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@@


1.1
log
@Sources that are external to BRL-CAD are moved from the top level to src/other/.
@
text
@@

