head	14.2;
access;
symbols
	stable-branch:14.1
	rel-7-8-4:14.1
	rel-7-8-2:14.1
	rel-7-8-0:14.1
	trimnurbs-branch:14.1.0.8
	help:14.1
	temp_tag:14.1
	bobWinPort-20051223-freeze:14.1
	postmerge-20051223-bobWinPort:14.1
	premerge-20051223-bobWinPort:14.1
	rel-7-6-6:14.1
	rel-7-6-4:14.1
	rel-7-6-2:14.1
	rel-7-6-branch:14.1.0.6
	rel-7-6-0:14.1
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.4
	bobWinPort:14.1.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@# @;


14.2
date	2007.03.02.21.47.11;	author brlcad;	state dead;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.23;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.14.51.56;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.2
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@#
# The httpd_ procedures implement a stub http server.
#
# Copyright (c) 1997-1998 Sun Microsystems, Inc.
# Copyright (c) 1999-2000 Scriptics Corporation
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# SCCS: @@(#) httpd 1.2 98/02/20 14:51:59

#set httpLog 1

proc httpd_init {{port 8015}} {
    socket -server httpdAccept $port
}
proc httpd_log {args} {
    global httpLog
    if {[info exists httpLog] && $httpLog} {
	puts stderr "httpd: [join $args { }]"
    }
}
array set httpdErrors {
    204 {No Content}
    400 {Bad Request}
    401 {Authorization Required}
    404 {Not Found}
    503 {Service Unavailable}
    504 {Service Temporarily Unavailable}
    }

proc httpdError {sock code args} {
    global httpdErrors
    puts $sock "$code $httpdErrors($code)"
    httpd_log "error: [join $args { }]"
}
proc httpdAccept {newsock ipaddr port} {
    global httpd
    upvar #0 httpd$newsock data

    fconfigure $newsock -blocking 0 -translation {auto crlf}
    httpd_log $newsock Connect $ipaddr $port
    set data(ipaddr) $ipaddr
    fileevent $newsock readable [list httpdRead $newsock]
}

# read data from a client request

proc httpdRead { sock } {
    upvar #0 httpd$sock data

    if {[eof $sock]} {
	set readCount -1
    } elseif {![info exists data(state)]} {

	# Read the protocol line and parse out the URL and query

	set readCount [gets $sock line]
	if [regexp {(POST|GET|HEAD) ([^?]+)\??([^ ]*) HTTP/(1.[01])} \
		$line x data(proto) data(url) data(query) data(httpversion)] {
	    set data(state) mime
	    httpd_log $sock Query $line
	} else {
	    httpdError $sock 400
	    httpd_log $sock Error "bad first line:$line"
	    httpdSockDone $sock
	}
	return
    } elseif {$data(state) == "mime"} {

	# Read the HTTP headers

	set readCount [gets $sock line]
    } elseif {$data(state) == "query"} {

	# Read the query data

	if {![info exists data(length_orig)]} {
	    set data(length_orig) $data(length)
	}
	set line [read $sock $data(length)]
	set readCount [string length $line]
	incr data(length) -$readCount
    }

    # string compare $readCount 0 maps -1 to -1, 0 to 0, and > 0 to 1

    set state [string compare $readCount 0],$data(state),$data(proto)
    httpd_log $sock $state
    switch -- $state {
	-1,mime,HEAD	-
	-1,mime,GET	-
	-1,mime,POST	{
	    # gets would block
	    return
	}
	0,mime,HEAD	-
	0,mime,GET	-
	0,query,POST	{ 
	    # Empty line at end of headers,
	    # or eof after query data
	    httpdRespond $sock
	}
	0,mime,POST	{
	    # Empty line between headers and query data
	    if {![info exists data(mime,content-length)]} {
		httpd_log $sock Error "No Content-Length for POST"
		httpdError $sock 400
		httpdSockDone $sock
	    } else {
		set data(state) query
		set data(length) $data(mime,content-length)

		# Special case to simulate servers that respond
		# without reading the post data.

		if {[string match *droppost* $data(url)]} {
		    fileevent $sock readable {}
		    httpdRespond $sock
		}
	    }
	}
	1,mime,HEAD	-
	1,mime,POST	-
	1,mime,GET	{
	    # A line of HTTP headers
	    if {[regexp {([^:]+):[ 	]*(.*)}  $line dummy key value]} {
		set data(mime,[string tolower $key]) $value
	    }
	}
	-1,query,POST	{
	    httpd_log $sock Error "unexpected eof on <$data(url)> request"
	    httpdError $sock 400
	    httpdSockDone $sock
	}
	1,query,POST	{
	    append data(query) $line
	    if {$data(length) <= 0} {
		set data(length) $data(length_orig)
		httpdRespond $sock
	    }
	}
	default {
	    if {[eof $sock]} {
		httpd_log $sock Error "unexpected eof on <$data(url)> request"
	    } else {
		httpd_log $sock Error "unhandled state <$state> fetching <$data(url)>"
	    }
	    httpdError $sock 404
	    httpdSockDone $sock
	}
    }
}
proc httpdSockDone { sock } {
    upvar #0 httpd$sock data
    unset data
    catch {close $sock}
}

# Respond to the query.

proc httpdRespond { sock } {
    global httpd bindata port
    upvar #0 httpd$sock data

    switch -glob -- $data(url) {
	*binary* {
	    set html "$bindata[info hostname]:$port$data(url)"
	    set type application/octet-stream
	}
	*post* {
	    set html "Got [string length $data(query)] bytes"
	    set type text/plain
	}
	default {
	    set type text/html

	    set html "<html><head><title>HTTP/1.0 TEST</title></head><body>
<h1>Hello, World!</h1>
<h2>$data(proto) $data(url)</h2>
"
	    if {[info exists data(query)] && [string length $data(query)]} {
		append html "<h2>Query</h2>\n<dl>\n"
		foreach {key value} [split $data(query) &=] {
		    append html "<dt>$key<dd>$value\n"
		    if {$key == "timeout"} {
			after $value	;# pause
		    }
		}
		append html </dl>\n
	    }
	    append html </body></html>
	}
    }
    
    # Catch errors from premature client closes

    catch {
	if {$data(proto) == "HEAD"} {
	    puts $sock "HTTP/1.0 200 OK"
	} else {
	    puts $sock "HTTP/1.0 200 Data follows"
	}
	puts $sock "Date: [clock format [clock clicks]]"
	puts $sock "Content-Type: $type"
	puts $sock "Content-Length: [string length $html]"
	puts $sock ""
	flush $sock
	if {$data(proto) != "HEAD"} {
	    fconfigure $sock -translation binary
	    puts -nonewline $sock $html
	}
    }
    httpd_log $sock Done ""
    httpdSockDone $sock
}


@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@@


1.1
log
@Sources that are external to BRL-CAD are moved from the top level to src/other/.
@
text
@@

