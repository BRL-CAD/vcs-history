head	14.2;
access;
symbols
	stable-branch:14.1
	rel-7-8-4:14.1
	rel-7-8-2:14.1
	rel-7-8-0:14.1
	trimnurbs-branch:14.1.0.8
	help:14.1
	temp_tag:14.1
	bobWinPort-20051223-freeze:14.1
	postmerge-20051223-bobWinPort:14.1
	premerge-20051223-bobWinPort:14.1
	rel-7-6-6:14.1
	rel-7-6-4:14.1
	rel-7-6-2:14.1
	rel-7-6-branch:14.1.0.6
	rel-7-6-0:14.1
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.4
	bobWinPort:14.1.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.2
date	2007.03.02.21.47.02;	author brlcad;	state dead;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.22;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.14.51.49;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.2
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@/* 
 * tclMacExit.c --
 *
 *	This file contains routines that deal with cleaning up various state
 *	when Tcl/Tk applications quit.  Unfortunantly, not all state is cleaned
 *	up by the process when an application quites or crashes.  Also you
 *	need to do different things depending on wether you are running as
 *	68k code, PowerPC, or a code resource.  The Exit handler code was 
 *	adapted from code posted on alt.sources.mac by Dave Nebinger.
 *
 * Copyright (c) 1995 Dave Nebinger.
 * Copyright (c) 1995-1996 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclMacExit.c,v 14.1 2004/11/16 19:42:22 morrison Exp $
 */

#include "tclInt.h"
#include "tclMacInt.h"
#include <SegLoad.h>
#include <Traps.h>
#include <Processes.h>

/*
 * Various typedefs and defines needed to patch ExitToShell.
 */
 
enum {
        uppExitToShellProcInfo = kPascalStackBased
};

#if GENERATINGCFM
typedef UniversalProcPtr ExitToShellUPP;

#define CallExitToShellProc(userRoutine)        \
        CallUniversalProc((UniversalProcPtr)(userRoutine),uppExitToShellProcInfo)
#define NewExitToShellProc(userRoutine) \
        (ExitToShellUPP)NewRoutineDescriptor((ProcPtr)(userRoutine), \
		uppExitToShellProcInfo, GetCurrentArchitecture())

#else
typedef ExitToShellProcPtr ExitToShellUPP;

#define CallExitToShellProc(userRoutine)        \
        (*(userRoutine))()
#define NewExitToShellProc(userRoutine) \
        (ExitToShellUPP)(userRoutine)
#endif

#define DisposeExitToShellProc(userRoutine) \
        DisposeRoutineDescriptor(userRoutine)

#if defined(powerc)||defined(__powerc)
#pragma options align=mac68k
#endif
struct ExitToShellUPPList{
        struct ExitToShellUPPList* nextProc;
        ExitToShellUPP userProc;
};
#if defined(powerc)||defined(__powerc)
#pragma options align=reset
#endif

typedef struct ExitToShellDataStruct ExitToShellDataRec,* ExitToShellDataPtr,** ExitToShellDataHdl;

typedef struct ExitToShellUPPList ExitToShellUPPList,* ExitToShellUPPListPtr,** ExitToShellUPPHdl;

#if defined(powerc)||defined(__powerc)
#pragma options align=mac68k
#endif
struct ExitToShellDataStruct{
    unsigned long a5;
    ExitToShellUPPList* userProcs;
    ExitToShellUPP oldProc;
};
#if defined(powerc)||defined(__powerc)
#pragma options align=reset
#endif

/*
 * Static globals used within this file.
 */
static ExitToShellDataPtr gExitToShellData = (ExitToShellDataPtr) NULL;


/*
 *----------------------------------------------------------------------
 *
 * TclPlatformExit --
 *
 *	This procedure implements the Macintosh specific exit routine.
 *	We explicitly callthe ExitHandler function to do various clean
 *	up.  
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	We exit the process.
 *
 *----------------------------------------------------------------------
 */

void
TclpExit(
    int status)		/* Ignored. */
{
    TclMacExitHandler();

/* 
 * If we are using the Metrowerks Standard Library, then we will call its exit so that it
 * will get a chance to clean up temp files, and so forth.  It always calls the standard 
 * ExitToShell, so the Tcl handlers will also get called.
 *   
 * If you have another exit, make sure that it does not patch ExitToShell, and does
 * call it.  If so, it will probably work as well.
 *
 */
 
#ifdef __MSL__    
    exit(status);
#else
    ExitToShell();
#endif

}

/*
 *----------------------------------------------------------------------
 *
 * TclMacExitHandler --
 *
 *	This procedure is invoked after Tcl at the last possible moment
 *	to clean up any state Tcl has left around that may cause other
 *	applications to crash.  For example, this function can be used
 *	as the termination routine for CFM applications.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Various cleanup occurs.
 *
 *----------------------------------------------------------------------
 */

void
TclMacExitHandler()
{
    ExitToShellUPPListPtr curProc;

    /*
     * Loop through all installed Exit handlers
     * and call them.  Always make sure we are in
     * a clean state in case we are recursivly called.
     */
    if ((gExitToShellData) != NULL && (gExitToShellData->userProcs != NULL)){
    
	/*
	 * Call the installed exit to shell routines.
	 */
	curProc = gExitToShellData->userProcs;
	do {
	    gExitToShellData->userProcs = curProc->nextProc;
	    CallExitToShellProc(curProc->userProc);
	    DisposeExitToShellProc(curProc->userProc);
	    DisposePtr((Ptr) curProc);
	    curProc = gExitToShellData->userProcs;
	} while (curProc != (ExitToShellUPPListPtr) NULL);
    }

    return;
}

/*
 *----------------------------------------------------------------------
 *
 * TclMacInstallExitToShellPatch --
 *
 *	This procedure installs a way to clean up state at the latest
 *	possible moment before we exit.  These are things that must
 *	be cleaned up or the system will crash.  The exact way in which
 *	this is implemented depends on the architecture in which we are
 *	running.  For 68k applications we patch the ExitToShell call.
 *	For PowerPC applications we just create a list of procs to call.
 *	The function ExitHandler should be installed in the Code 
 *	Fragments terminiation routine.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Installs the new routine.
 *
 *----------------------------------------------------------------------
 */

OSErr 
TclMacInstallExitToShellPatch(
    ExitToShellProcPtr newProc)		/* Function pointer. */
{
    ExitToShellUPP exitHandler;
    ExitToShellUPPListPtr listPtr;

    if (gExitToShellData == (ExitToShellDataPtr) NULL){
	TclMacInitExitToShell(true);
    }

    /*
     * Add the passed in function pointer to the list of functions
     * to be called when ExitToShell is called.
     */
    exitHandler = NewExitToShellProc(newProc);
    listPtr = (ExitToShellUPPListPtr) NewPtrClear(sizeof(ExitToShellUPPList));
    listPtr->userProc = exitHandler;
    listPtr->nextProc = gExitToShellData->userProcs;
    gExitToShellData->userProcs = listPtr;

    return noErr;
}

/*
 *----------------------------------------------------------------------
 *
 * ExitToShellPatchRoutine --
 *
 *	This procedure is invoked when someone calls ExitToShell for
 *	this application.  This function performs some last miniute
 *	clean up and then calls the real ExitToShell routine.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Various cleanup occurs.
 *
 *----------------------------------------------------------------------
 */

static pascal void
ExitToShellPatchRoutine()
{
    ExitToShellUPP oldETS;
    long oldA5;

    /*
     * Set up our A5 world.  This allows us to have
     * access to our global variables in the 68k world.
     */
    oldA5 = SetCurrentA5();
    SetA5(gExitToShellData->a5);

    /*
     * Call the function that invokes all
     * of the handlers.
     */
    TclMacExitHandler();

    /*
     * Call the origional ExitToShell routine.
     */
    oldETS = gExitToShellData->oldProc;
    DisposePtr((Ptr) gExitToShellData);
    SetA5(oldA5);
    CallExitToShellProc(oldETS);
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * TclMacInitExitToShell --
 *
 *	This procedure initializes the ExitToShell clean up machanism.
 *	Generally, this is handled automatically when users make a call
 *	to InstallExitToShellPatch.  However, it can be called 
 *	explicitly at startup time to turn off the patching mechanism.
 *	This can be used by code resources which could be removed from
 *	the application before ExitToShell is called.
 *
 *	Note, if we are running from CFM code we never install the
 *	patch.  Instead, the function ExitHandler should be installed
 *	as the terminiation routine for the code fragment.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Creates global state.
 *
 *----------------------------------------------------------------------
 */

void 
TclMacInitExitToShell(
    int usePatch)	/* True if on 68k. */
{
    if (gExitToShellData == (ExitToShellDataPtr) NULL){
#if GENERATINGCFM
	gExitToShellData = (ExitToShellDataPtr)
	  NewPtr(sizeof(ExitToShellDataRec));
	gExitToShellData->a5 = SetCurrentA5();
	gExitToShellData->userProcs = (ExitToShellUPPList*) NULL;
#else
	ExitToShellUPP oldExitToShell, newExitToShellPatch;
	short exitToShellTrap;
	
	/*
	 * Initialize patch mechanism.
	 */
	 
	gExitToShellData = (ExitToShellDataPtr) NewPtr(sizeof(ExitToShellDataRec));
	gExitToShellData->a5 = SetCurrentA5();
	gExitToShellData->userProcs = (ExitToShellUPPList*) NULL;

	/*
	 * Save state needed to call origional ExitToShell routine.  Install
	 * the new ExitToShell code in it's place.
	 */
	if (usePatch) {
	    exitToShellTrap = _ExitToShell & 0x3ff;
	    newExitToShellPatch = NewExitToShellProc(ExitToShellPatchRoutine);
	    oldExitToShell = (ExitToShellUPP)
	      NGetTrapAddress(exitToShellTrap, ToolTrap);
	    NSetTrapAddress((UniversalProcPtr) newExitToShellPatch,
		    exitToShellTrap, ToolTrap);
	    gExitToShellData->oldProc = oldExitToShell;
	}
#endif
    }
}
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d17 1
a17 1
 * RCS: @@(#) $Id: tclMacExit.c,v 1.1 2004/05/20 14:51:49 morrison Exp $
@


1.1
log
@Sources that are external to BRL-CAD are moved from the top level to src/other/.
@
text
@d17 1
a17 1
 * RCS: @@(#) $Id: tclMacExit.c,v 1.3 2004/03/04 19:47:12 morrison Exp $
@

