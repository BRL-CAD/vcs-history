head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.43;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.41;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.48;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkUndo.h --
 *
 *	Declarations shared among the files that implement an undo stack.
 *
 * Copyright (c) 2002 Ludwig Callewaert.
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkUndo.h,v 1.7 2007/06/25 19:07:15 dgp Exp $
 */

#ifndef _TKUNDO
#define _TKUNDO

#ifndef _TKINT
#include "tkInt.h"
#endif

#ifdef BUILD_tk
# undef TCL_STORAGE_CLASS
# define TCL_STORAGE_CLASS DLLEXPORT
#endif

/*
 * Enum definining the types used in an undo stack.
 */

typedef enum {
    TK_UNDO_SEPARATOR,		/* Marker */
    TK_UNDO_ACTION		/* Command */
} TkUndoAtomType;

/*
 * Callback proc type to carry out an undo or redo action via C code. (Actions
 * can also be defined by Tcl scripts).
 */

typedef int (TkUndoProc)(Tcl_Interp *interp, ClientData clientData,
			Tcl_Obj *objPtr);

/*
 * Struct defining a single action, one or more of which may be defined (and
 * stored in a linked list) separately for each undo and redo action of an
 * undo atom.
 */

typedef struct TkUndoSubAtom {
    Tcl_Command command;	/* Tcl token used to get the current Tcl
				 * command name which will be used to execute
				 * apply/revert scripts. If NULL then it is
				 * assumed the apply/revert scripts already
				 * contain everything. */
    TkUndoProc *funcPtr;	/* Function pointer for callback to perform
				 * undo/redo actions. */
    ClientData clientData;	/* Data for 'funcPtr'. */
    Tcl_Obj *action;		/* Command to apply the action that was
				 * taken. */
    struct TkUndoSubAtom *next;	/* Pointer to the next element in the linked
				 * list. */
} TkUndoSubAtom;

/*
 * Struct representing a single undo+redo atom to be placed in the stack.
 */

typedef struct TkUndoAtom {
    TkUndoAtomType type;	/* The type that will trigger the required
				 * action. */
    TkUndoSubAtom *apply;	/* Linked list of 'apply' actions to perform
				 * for this operation. */
    TkUndoSubAtom *revert;	/* Linked list of 'revert' actions to perform
				 * for this operation. */
    struct TkUndoAtom *next;	/* Pointer to the next element in the
				 * stack. */
} TkUndoAtom;

/*
 * Struct defining a single undo+redo stack.
 */

typedef struct TkUndoRedoStack {
    TkUndoAtom *undoStack;	/* The undo stack. */
    TkUndoAtom *redoStack;	/* The redo stack. */
    Tcl_Interp *interp;		/* The interpreter in which to execute the
				 * revert and apply scripts. */
    int maxdepth;
    int depth;
} TkUndoRedoStack;

/*
 * Basic functions.
 */

MODULE_SCOPE void	TkUndoPushStack(TkUndoAtom **stack, TkUndoAtom *elem);
MODULE_SCOPE TkUndoAtom *TkUndoPopStack(TkUndoAtom **stack);
MODULE_SCOPE int	TkUndoInsertSeparator(TkUndoAtom **stack);
MODULE_SCOPE void	TkUndoClearStack(TkUndoAtom **stack);

/*
 * Functions for working on an undo/redo stack.
 */

MODULE_SCOPE TkUndoRedoStack *TkUndoInitStack(Tcl_Interp *interp, int maxdepth);
MODULE_SCOPE void	TkUndoSetDepth(TkUndoRedoStack *stack, int maxdepth);
MODULE_SCOPE void	TkUndoClearStacks(TkUndoRedoStack *stack);
MODULE_SCOPE void	TkUndoFreeStack(TkUndoRedoStack *stack);
MODULE_SCOPE void	TkUndoInsertUndoSeparator(TkUndoRedoStack *stack);
MODULE_SCOPE TkUndoSubAtom *TkUndoMakeCmdSubAtom(Tcl_Command command,
			    Tcl_Obj *actionScript, TkUndoSubAtom *subAtomList);
MODULE_SCOPE TkUndoSubAtom *TkUndoMakeSubAtom(TkUndoProc *funcPtr,
			    ClientData clientData, Tcl_Obj *actionScript,
			    TkUndoSubAtom *subAtomList);
MODULE_SCOPE void	TkUndoPushAction(TkUndoRedoStack *stack,
			    TkUndoSubAtom *apply, TkUndoSubAtom *revert);
MODULE_SCOPE int	TkUndoRevert(TkUndoRedoStack *stack);
MODULE_SCOPE int	TkUndoApply(TkUndoRedoStack *stack);

# undef TCL_STORAGE_CLASS
# define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TKUNDO */
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tkUndo.h,v 1.5 2005/11/27 02:36:14 das Exp $
d55 1
a55 1
    TkUndoProc *funcPtr;        /* Function pointer for callback to perform
d57 1
a57 1
    ClientData clientData;      /* data for 'funcPtr' */
d59 3
a61 3
				 * taken */
    struct TkUndoSubAtom *next; /* Pointer to the next element in the linked
				 * list */
d71 6
a76 5
    TkUndoSubAtom *apply;       /* Linked list of 'apply' actions to perform
                                 * for this operation. */
    TkUndoSubAtom *revert;      /* Linked list of 'revert' actions to perform
                                 * for this operation. */
    struct TkUndoAtom *next;	/* Pointer to the next element in the stack */
d84 2
a85 2
    TkUndoAtom *undoStack;	/* The undo stack */
    TkUndoAtom *redoStack;	/* The redo stack */
d87 1
a87 1
				 * revert and apply scripts */
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@@

