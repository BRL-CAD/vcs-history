head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.49;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.45;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXCarbonEvents.c --
 *
 *	This file implements functions that register for and handle
 *	various Carbon Events and Timers. Most carbon events of interest
 *	to TkAqua are processed in a handler registered on the dispatcher
 *	event target so that we get first crack at them before HIToolbox
 *	dispatchers/processes them further.
 *	As some events are sent directly to the focus or app event target
 *	and not dispatched normally, we also register a handler on the
 *	application event target.
 *
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 *	The following terms apply to all files originating from Apple
 *	Computer, Inc. ("Apple") and associated with the software
 *	unless explicitly disclaimed in individual files.
 *
 *
 *	Apple hereby grants permission to use, copy, modify,
 *	distribute, and license this software and its documentation
 *	for any purpose, provided that existing copyright notices are
 *	retained in all copies and that this notice is included
 *	verbatim in any distributions. No written agreement, license,
 *	or royalty fee is required for any of the authorized
 *	uses. Modifications to this software may be copyrighted by
 *	their authors and need not follow the licensing terms
 *	described here, provided that the new terms are clearly
 *	indicated on the first page of each file where they apply.
 *
 *
 *	IN NO EVENT SHALL APPLE, THE AUTHORS OR DISTRIBUTORS OF THE
 *	SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 *	INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
 *	THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 *	EVEN IF APPLE OR THE AUTHORS HAVE BEEN ADVISED OF THE
 *	POSSIBILITY OF SUCH DAMAGE.  APPLE, THE AUTHORS AND
 *	DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES, INCLUDING,
 *	BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.	 THIS
 *	SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, AND APPLE,THE
 *	AUTHORS AND DISTRIBUTORS HAVE NO OBLIGATION TO PROVIDE
 *	MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 *	GOVERNMENT USE: If you are acquiring this software on behalf
 *	of the U.S. government, the Government shall have only
 *	"Restricted Rights" in the software and related documentation
 *	as defined in the Federal Acquisition Regulations (FARs) in
 *	Clause 52.227.19 (c) (2).  If you are acquiring the software
 *	on behalf of the Department of Defense, the software shall be
 *	classified as "Commercial Computer Software" and the
 *	Government shall have only "Restricted Rights" as defined in
 *	Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the
 *	foregoing, the authors grant the U.S. Government and others
 *	acting in its behalf permission to use and distribute the
 *	software in accordance with the terms specified in this
 *	license.
 *
 * RCS: @@(#) $Id: tkMacOSXCarbonEvents.c,v 1.17 2007/06/29 03:20:00 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkMacOSXEvent.h"
#include "tkMacOSXDebug.h"

/*
#ifdef TK_MAC_DEBUG
#define TK_MAC_DEBUG_CARBON_EVENTS
#endif
*/

/*
 * Declarations of functions used only in this file:
 */

static OSStatus CarbonEventHandlerProc(EventHandlerCallRef callRef,
	EventRef event, void *userData);
static OSStatus InstallStandardApplicationEventHandler(void);
static void ExitRaelEventHandlerProc(EventHandlerCallRef callRef,
	EventRef event, void *userData) __attribute__ ((__noreturn__));
static void CarbonTimerProc(EventLoopTimerRef timer, void *userData);

/*
 * Static data used by several functions in this file:
 */

static jmp_buf exitRaelJmpBuf;
static EventLoopTimerRef carbonTimer = NULL;
static int carbonTimerEnabled = 0;
static EventHandlerUPP carbonEventHandlerUPP = NULL;
static Tcl_Interp *carbonEventInterp = NULL;
static int inTrackingLoop = 0;


/*
 *----------------------------------------------------------------------
 *
 * CarbonEventHandlerProc --
 *
 *	This procedure is the handler for all registered CarbonEvents.
 *
 * Results:
 *	OS status code.
 *
 * Side effects:
 *	Dispatches CarbonEvents.
 *
 *----------------------------------------------------------------------
 */

static OSStatus
CarbonEventHandlerProc(
    EventHandlerCallRef callRef,
    EventRef event,
    void *userData)
{
    OSStatus err = eventNotHandledErr;
    TkMacOSXEvent macEvent;
    MacEventStatus eventStatus;

    macEvent.eventRef = event;
    macEvent.eClass = GetEventClass(event);
    macEvent.eKind = GetEventKind(event);
    macEvent.interp = (Tcl_Interp *) userData;
    macEvent.callRef = callRef;
    bzero(&eventStatus, sizeof(eventStatus));

#ifdef TK_MAC_DEBUG_CARBON_EVENTS
    if (macEvent.eKind != kEventMouseMoved &&
	    macEvent.eKind != kEventMouseDragged) {
	TkMacOSXDbgMsg("Started handling %s",
		TkMacOSXCarbonEventToAscii(event));
	TkMacOSXInitNamedDebugSymbol(HIToolbox, void, _DebugPrintEvent,
		EventRef inEvent);
	if (_DebugPrintEvent) {
	    /*
	     * Carbon-internal event debugging (c.f. Technote 2124)
	     */

	    _DebugPrintEvent(event);
	}
    }
#endif /* TK_MAC_DEBUG_CARBON_EVENTS */

    TkMacOSXProcessEvent(&macEvent,&eventStatus);
    if (eventStatus.stopProcessing) {
	err = noErr;
    }

#ifdef TK_MAC_DEBUG_CARBON_EVENTS
    if (macEvent.eKind != kEventMouseMoved &&
	    macEvent.eKind != kEventMouseDragged) {
	TkMacOSXDbgMsg("Finished handling %s: %s handled",
		TkMacOSXCarbonEventToAscii(event),
		eventStatus.stopProcessing ? "   " : "not");
    }
#endif /* TK_MAC_DEBUG_CARBON_EVENTS */
    return err;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXInitCarbonEvents --
 *
 *	This procedure initializes all CarbonEvent handlers.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Handlers for Carbon Events are registered.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE void
TkMacOSXInitCarbonEvents(
    Tcl_Interp *interp)
{
    const EventTypeSpec dispatcherEventTypes[] = {
	{kEventClassKeyboard,	 kEventRawKeyDown},
	{kEventClassKeyboard,	 kEventRawKeyRepeat},
	{kEventClassKeyboard,	 kEventRawKeyUp},
	{kEventClassKeyboard,	 kEventRawKeyModifiersChanged},
	{kEventClassKeyboard,	 kEventRawKeyRepeat},
    };
    const EventTypeSpec applicationEventTypes[] = {
	{kEventClassMenu,	 kEventMenuBeginTracking},
	{kEventClassMenu,	 kEventMenuEndTracking},
	{kEventClassMenu,	 kEventMenuOpening},
	{kEventClassMenu,	 kEventMenuTargetItem},
	{kEventClassCommand,	 kEventCommandProcess},
	{kEventClassCommand,	 kEventCommandUpdateStatus},
	{kEventClassApplication, kEventAppActivated},
	{kEventClassApplication, kEventAppDeactivated},
	{kEventClassApplication, kEventAppQuit},
	{kEventClassApplication, kEventAppHidden},
	{kEventClassApplication, kEventAppShown},
	{kEventClassApplication, kEventAppAvailableWindowBoundsChanged},
	{kEventClassAppearance,	 kEventAppearanceScrollBarVariantChanged},
    };

    carbonEventHandlerUPP = NewEventHandlerUPP(CarbonEventHandlerProc);
    carbonEventInterp = interp;
    ChkErr(InstallStandardApplicationEventHandler);
    ChkErr(InstallEventHandler, GetEventDispatcherTarget(),
	    carbonEventHandlerUPP, GetEventTypeCount(dispatcherEventTypes),
	    dispatcherEventTypes, (void *) carbonEventInterp, NULL);
    ChkErr(InstallEventHandler, GetApplicationEventTarget(),
	    carbonEventHandlerUPP, GetEventTypeCount(applicationEventTypes),
	    applicationEventTypes, (void *) carbonEventInterp, NULL);

#ifdef TK_MAC_DEBUG_CARBON_EVENTS
    TkMacOSXInitNamedDebugSymbol(HIToolbox, void, _TraceEventByName,
	    CFStringRef);
    if (_TraceEventByName) {
	/* Carbon-internal event debugging (c.f. Technote 2124) */
	_TraceEventByName(CFSTR("kEventRawKeyDown"));
	_TraceEventByName(CFSTR("kEventRawKeyRepeat"));
	_TraceEventByName(CFSTR("kEventRawKeyUp"));
	_TraceEventByName(CFSTR("kEventRawKeyModifiersChanged"));
	_TraceEventByName(CFSTR("kEventRawKeyRepeat"));
	_TraceEventByName(CFSTR("kEventMenuBeginTracking"));
	_TraceEventByName(CFSTR("kEventMenuEndTracking"));
	_TraceEventByName(CFSTR("kEventMenuOpening"));
	_TraceEventByName(CFSTR("kEventMenuTargetItem"));
	_TraceEventByName(CFSTR("kEventCommandProcess"));
	_TraceEventByName(CFSTR("kEventCommandUpdateStatus"));
	_TraceEventByName(CFSTR("kEventAppActivated"));
	_TraceEventByName(CFSTR("kEventAppDeactivated"));
	_TraceEventByName(CFSTR("kEventAppQuit"));
	_TraceEventByName(CFSTR("kEventAppHidden"));
	_TraceEventByName(CFSTR("kEventAppShown"));
	_TraceEventByName(CFSTR("kEventAppAvailableWindowBoundsChanged"));
	_TraceEventByName(CFSTR("kEventAppearanceScrollBarVariantChanged"));
	_TraceEventByName(CFSTR("kEventMouseDown"));
	_TraceEventByName(CFSTR("kEventMouseUp"));
#if 0
	_TraceEventByName(CFSTR("kEventMouseMoved"));
	_TraceEventByName(CFSTR("kEventMouseDragged"));
#endif
	_TraceEventByName(CFSTR("kEventMouseWheelMoved"));
	_TraceEventByName(CFSTR("kEventMouseScroll"));
	_TraceEventByName(CFSTR("kEventWindowActivated"));
	_TraceEventByName(CFSTR("kEventWindowDeactivated"));
	_TraceEventByName(CFSTR("kEventWindowUpdate"));
	_TraceEventByName(CFSTR("kEventWindowExpanded"));
	_TraceEventByName(CFSTR("kEventWindowBoundsChanged"));
	_TraceEventByName(CFSTR("kEventWindowDragStarted"));
	_TraceEventByName(CFSTR("kEventWindowDragCompleted"));
	_TraceEventByName(CFSTR("kEventWindowConstrain"));
	_TraceEventByName(CFSTR("kEventWindowGetRegion"));
	_TraceEventByName(CFSTR("kEventWindowDrawContent"));
    }
#endif /* TK_MAC_DEBUG_CARBON_EVENTS */
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXInstallWindowCarbonEventHandler --
 *
 *	This procedure installs our window CarbonEvent handler.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Handler for Carbon Events is registered.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE void
TkMacOSXInstallWindowCarbonEventHandler(
	Tcl_Interp *interp, WindowRef window)
{
    const EventTypeSpec windowEventTypes[] = {
	{kEventClassMouse,	 kEventMouseDown},
	{kEventClassMouse,	 kEventMouseUp},
	{kEventClassMouse,	 kEventMouseMoved},
	{kEventClassMouse,	 kEventMouseDragged},
	{kEventClassMouse,	 kEventMouseWheelMoved},
	{kEventClassWindow,	 kEventWindowActivated},
	{kEventClassWindow,	 kEventWindowDeactivated},
	{kEventClassWindow,	 kEventWindowUpdate},
	{kEventClassWindow,	 kEventWindowExpanded},
	{kEventClassWindow,	 kEventWindowBoundsChanged},
	{kEventClassWindow,	 kEventWindowDragStarted},
	{kEventClassWindow,	 kEventWindowDragCompleted},
	{kEventClassWindow,	 kEventWindowConstrain},
	{kEventClassWindow,	 kEventWindowGetRegion},
	{kEventClassWindow,	 kEventWindowDrawContent},
    };

    ChkErr(InstallEventHandler, GetWindowEventTarget(window),
	    carbonEventHandlerUPP, GetEventTypeCount(windowEventTypes),
	    windowEventTypes, (void *) (interp ? interp : carbonEventInterp),
	    NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * InstallStandardApplicationEventHandler --
 *
 *	This procedure installs the carbon standard application event
 *	handler.
 *
 * Results:
 *	OS status code.
 *
 * Side effects:
 *	Standard handlers for application Carbon Events are registered.
 *
 *----------------------------------------------------------------------
 */

static OSStatus
InstallStandardApplicationEventHandler(void)
{
   /*
    * This is a hack to workaround missing Carbon API to install the standard
    * application event handler (InstallStandardEventHandler() does not work
    * on the application target). The only way to install the standard app
    * handler is to call RunApplicationEventLoop(), but since we are running
    * our own event loop, we'll immediately need to break out of RAEL again:
    * we do this via longjmp out of the ExitRaelEventHandlerProc event handler
    * called first off from RAEL by posting a high priority dummy event.
    * This workaround is derived from a similar approach in Technical Q&A 1061.
    */
    enum {
	kExitRaelEvent = 'ExiT'
    };
    const EventTypeSpec exitRaelEventType = {
	kExitRaelEvent, kExitRaelEvent
    };
    EventHandlerUPP exitRaelEventHandler;
    EventHandlerRef exitRaelEventHandlerRef = NULL;
    EventRef exitRaelEvent = NULL;
    OSStatus err = memFullErr;

    exitRaelEventHandler = NewEventHandlerUPP(
	    (EventHandlerProcPtr) ExitRaelEventHandlerProc);
    if (exitRaelEventHandler) {
	err = ChkErr(InstallEventHandler, GetEventDispatcherTarget(),
		exitRaelEventHandler, 1, &exitRaelEventType, NULL,
		&exitRaelEventHandlerRef);
    }
    if (err == noErr) {
	err = ChkErr(CreateEvent, NULL, kExitRaelEvent, kExitRaelEvent,
		GetCurrentEventTime(), kEventAttributeNone, &exitRaelEvent);
    }
    if (err == noErr) {
	err = ChkErr(PostEventToQueue, GetMainEventQueue(), exitRaelEvent,
		kEventPriorityHigh);
    }
    if (err == noErr) {
	if (!setjmp(exitRaelJmpBuf)) {
	    RunApplicationEventLoop();

	    /*
	     * This point should never be reached!
	     */

	    Tcl_Panic("RunApplicationEventLoop exited !");
	}
    }
    if (exitRaelEvent) {
	ReleaseEvent(exitRaelEvent);
    }
    if (exitRaelEventHandlerRef) {
	RemoveEventHandler(exitRaelEventHandlerRef);
    }
    if (exitRaelEventHandler) {
	DisposeEventHandlerUPP(exitRaelEventHandler);
    }
    return err;
}

/*
 *----------------------------------------------------------------------
 *
 * ExitRaelEventHandlerProc --
 *
 *	This procedure is the dummy event handler used to break out of
 *	RAEL via longjmp, it is called as the first ever event handler
 *	in RAEL by posting a high priority dummy event.
 *
 * Results:
 *	None. Never returns !
 *
 * Side effects:
 *	longjmp back to InstallStandardApplicationEventHandler().
 *
 *----------------------------------------------------------------------
 */

static void
ExitRaelEventHandlerProc(
    EventHandlerCallRef callRef,
    EventRef event,
    void *userData)
{
    longjmp(exitRaelJmpBuf, 1);
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXRunTclEventLoop --
 *
 *	Process a limited number of tcl events.
 *
 * Results:
 *	Returns 1 if events were handled and 0 otherwise.
 *
 * Side effects:
 *	Runs the Tcl event loop.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE int
TkMacOSXRunTclEventLoop(void)
{
    int i = 4, result = 0;

    /* Avoid starving main event loop: process at most 4 events. */
    while(--i && Tcl_ServiceAll()) {
	result = 1;
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * CarbonTimerProc --
 *
 *	This procedure is the carbon timer handler that runs the tcl
 *	event loop periodically.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Runs the Tcl event loop.
 *
 *----------------------------------------------------------------------
 */

static void
CarbonTimerProc(
    EventLoopTimerRef timer,
    void *userData)
{
    if(carbonTimerEnabled > 0 && TkMacOSXRunTclEventLoop()) {
#ifdef TK_MAC_DEBUG_CARBON_EVENTS
	TkMacOSXDbgMsg("Processed tcl events from carbon timer");
#endif /* TK_MAC_DEBUG_CARBON_EVENTS */
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXStartTclEventLoopCarbonTimer --
 *
 *	This procedure installs (if necessary) and starts a carbon
 *	event timer that runs the tcl event loop periodically.
 *	It should be called whenever a nested carbon event loop might
 *	run by HIToolbox (e.g. during mouse tracking) to ensure that
 *	tcl events continue to be processed.
 *
 * Results:
 *	OS status code.
 *
 * Side effects:
 *	Carbon event timer is installed and started.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE OSStatus
TkMacOSXStartTclEventLoopCarbonTimer(void)
{
    OSStatus err = noErr;

    if (++carbonTimerEnabled > 0) {
	if(!carbonTimer) {
	    EventLoopTimerUPP timerUPP = NewEventLoopTimerUPP(CarbonTimerProc);

	    err = ChkErr(InstallEventLoopTimer, GetMainEventLoop(),
		    5 * kEventDurationMillisecond,
		    5 * kEventDurationMillisecond,
		    timerUPP, NULL, &carbonTimer);
	} else {
	    err = ChkErr(SetEventLoopTimerNextFireTime, carbonTimer,
		    5 * kEventDurationMillisecond);
	}
    }
    return err;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXStopTclEventLoopCarbonTimer --
 *
 *	This procedure stops the carbon event timer started by
 *	TkMacOSXStartTclEventLoopCarbonTimer().
 *
 * Results:
 *	OS status code.
 *
 * Side effects:
 *	Carbon event timer is stopped.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE OSStatus
TkMacOSXStopTclEventLoopCarbonTimer(void)
{
    OSStatus err = noErr;

    if (--carbonTimerEnabled == 0) {
	if(carbonTimer) {
	    err = ChkErr(SetEventLoopTimerNextFireTime, carbonTimer,
		    kEventDurationForever);
	}
    }
    return err;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXTrackingLoop --
 *
 *	Call with 1 before entering a mouse tracking loop (e.g. window
 *	resizing or menu tracking) to enable tcl event processing but
 *	disable  carbon event processing (except for update events)
 *	during the loop, and with 0 after exiting the loop to reset.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE void
TkMacOSXTrackingLoop(int tracking)
{
    static int previousServiceMode = TCL_SERVICE_NONE;

    if (tracking) {
	inTrackingLoop++;
	previousServiceMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
	TkMacOSXStartTclEventLoopCarbonTimer();
#ifdef TK_MAC_DEBUG_CARBON_EVENTS
	TkMacOSXDbgMsg("Entering tracking loop");
#endif /* TK_MAC_DEBUG_CARBON_EVENTS */
    } else {
	TkMacOSXStopTclEventLoopCarbonTimer();
	previousServiceMode = Tcl_SetServiceMode(previousServiceMode);
	inTrackingLoop--;
#ifdef TK_MAC_DEBUG_CARBON_EVENTS
	TkMacOSXDbgMsg("Exiting tracking loop");
#endif /* TK_MAC_DEBUG_CARBON_EVENTS */
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXReceiveAndDispatchEvent --
 *
 *	This receives a carbon event and sends it to the carbon event
 *	dispatcher.
 *
 * Results:
 *	Mac OS status
 *
 * Side effects:
 *	This receives and dispatches the next Carbon event.
 *
 *----------------------------------------------------------------------
 */
MODULE_SCOPE OSStatus
TkMacOSXReceiveAndDispatchEvent(void)
{
    static EventTargetRef targetRef = NULL;
    int numEventTypes = 0;
    const EventTypeSpec *eventTypes = NULL;
    EventRef eventRef;
    OSStatus err;
    const EventTypeSpec trackingEventTypes[] = {
	{'dniw',		 kEventWindowUpdate},
	{kEventClassWindow,	 kEventWindowUpdate},
    };

    if (inTrackingLoop > 0) {
	eventTypes = trackingEventTypes;
	numEventTypes = GetEventTypeCount(trackingEventTypes);
    }

    /*
     * This is a poll, since we have already counted the events coming
     * into this routine, and are guaranteed to have one waiting.
     */

    err = ReceiveNextEvent(numEventTypes, eventTypes,
	    kEventDurationNoWait, true, &eventRef);
    if (err == noErr) {
#ifdef TK_MAC_DEBUG_CARBON_EVENTS
	UInt32 kind = GetEventKind(eventRef);

	if (kind != kEventMouseMoved && kind != kEventMouseDragged) {
	    TkMacOSXDbgMsg("Dispatching %s", TkMacOSXCarbonEventToAscii(eventRef));
	    TkMacOSXInitNamedDebugSymbol(HIToolbox, void, _DebugPrintEvent,
		    EventRef inEvent);
	    if (_DebugPrintEvent) {
		/* Carbon-internal event debugging (c.f. Technote 2124) */
		_DebugPrintEvent(eventRef);
	    }
	}
#endif /* TK_MAC_DEBUG_CARBON_EVENTS */
	if (!targetRef) {
	    targetRef = GetEventDispatcherTarget();
	}
	TkMacOSXStartTclEventLoopCarbonTimer();
	err = SendEventToEventTarget(eventRef, targetRef);
	TkMacOSXStopTclEventLoopCarbonTimer();
	if (err != noErr && err != eventLoopTimedOutErr
		&& err != eventNotHandledErr) {
	    TkMacOSXDbgMsg("SendEventToEventTarget(%s) failed: %ld",
		    TkMacOSXCarbonEventToAscii(eventRef), err);
	}
	ReleaseEvent(eventRef);
    } else if (err != eventLoopTimedOutErr) {
	TkMacOSXDbgMsg("ReceiveNextEvent failed: %ld", err);
    }
    return err;
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d63 1
a63 1
 * RCS: @@(#) $Id: tkMacOSXCarbonEvents.c,v 1.16 2007/04/23 21:24:33 das Exp $
d66 1
a66 1
#include "tkMacOSXInt.h"
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d14 1
a14 1
 * Copyright (c) 2005 Daniel A. Steffen <das@@users.sourceforge.net>
d19 43
a61 43
 *      The following terms apply to all files originating from Apple
 *      Computer, Inc. ("Apple") and associated with the software
 *      unless explicitly disclaimed in individual files.
 *
 *
 *      Apple hereby grants permission to use, copy, modify,
 *      distribute, and license this software and its documentation
 *      for any purpose, provided that existing copyright notices are
 *      retained in all copies and that this notice is included
 *      verbatim in any distributions. No written agreement, license,
 *      or royalty fee is required for any of the authorized
 *      uses. Modifications to this software may be copyrighted by
 *      their authors and need not follow the licensing terms
 *      described here, provided that the new terms are clearly
 *      indicated on the first page of each file where they apply.
 *
 *
 *      IN NO EVENT SHALL APPLE, THE AUTHORS OR DISTRIBUTORS OF THE
 *      SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 *      INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
 *      THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 *      EVEN IF APPLE OR THE AUTHORS HAVE BEEN ADVISED OF THE
 *      POSSIBILITY OF SUCH DAMAGE.  APPLE, THE AUTHORS AND
 *      DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES, INCLUDING,
 *      BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 *      FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS
 *      SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, AND APPLE,THE
 *      AUTHORS AND DISTRIBUTORS HAVE NO OBLIGATION TO PROVIDE
 *      MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 *      GOVERNMENT USE: If you are acquiring this software on behalf
 *      of the U.S. government, the Government shall have only
 *      "Restricted Rights" in the software and related documentation
 *      as defined in the Federal Acquisition Regulations (FARs) in
 *      Clause 52.227.19 (c) (2).  If you are acquiring the software
 *      on behalf of the Department of Defense, the software shall be
 *      classified as "Commercial Computer Software" and the
 *      Government shall have only "Restricted Rights" as defined in
 *      Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the
 *      foregoing, the authors grant the U.S. Government and others
 *      acting in its behalf permission to use and distribute the
 *      software in accordance with the terms specified in this
 *      license.
d63 1
a63 1
 * RCS: @@(#) $Id: tkMacOSXCarbonEvents.c,v 1.12 2006/08/21 01:09:23 das Exp $
d71 1
a71 1
#ifdef	TK_MAC_DEBUG
d76 4
a79 1
/* Declarations of functions used only in this file */
d81 4
a84 4
			      EventRef event, void *userData);
static OSStatus InstallStandardApplicationEventHandler();
static void ExitRaelEventHandlerProc (EventHandlerCallRef, EventRef, void*)
	__attribute__ ((__noreturn__));
d87 4
a90 1
/* Static data used by several functions in this file */
d94 3
d98 1
d104 1
a104 1
 *	  This procedure is the handler for all registered CarbonEvents.
d107 1
a107 1
 *	  OS status code.
d110 1
a110 1
 *	  Dispatches CarbonEvents.
d116 8
a123 8
CarbonEventHandlerProc (
	EventHandlerCallRef callRef,
	EventRef event,
	void *userData)
{
    OSStatus	     result = eventNotHandledErr;
    TkMacOSXEvent    macEvent;
    MacEventStatus   eventStatus;
d126 2
a127 2
    macEvent.eClass = GetEventClass(macEvent.eventRef);
    macEvent.eKind = GetEventKind(macEvent.eventRef);
d129 1
d132 1
a132 2
#if defined(TK_MAC_DEBUG) && defined(TK_MAC_DEBUG_CARBON_EVENTS)
    char buf [256];
d135 2
a136 2
	CarbonEventToAscii(event, buf);
	fprintf(stderr, "CarbonEventHandlerProc started handling %s\n", buf);
d140 4
a143 1
	    /* Carbon-internal event debugging (c.f. Technote 2124) */
d151 1
a151 1
	result = noErr;
d154 1
a154 1
#if defined(TK_MAC_DEBUG) && defined(TK_MAC_DEBUG_CARBON_EVENTS)
d157 3
a159 3
	fprintf(stderr,
		"CarbonEventHandlerProc finished handling %s: %s handled\n",
		buf, eventStatus.stopProcessing ? "   " : "not");
d162 1
a162 1
    return result;
d170 1
a170 1
 *	  This procedure initializes all CarbonEvent handlers.
d173 1
a173 1
 *	  None.
d176 1
a176 1
 *	  Handlers for Carbon Events are registered.
d182 2
a183 2
TkMacOSXInitCarbonEvents (
	Tcl_Interp *interp)
a184 1
    OSStatus err;
d186 5
a190 16
	    {kEventClassMouse,		kEventMouseDown},
	    {kEventClassMouse,		kEventMouseUp},
	    {kEventClassMouse,		kEventMouseMoved},
	    {kEventClassMouse,		kEventMouseDragged},
	    {kEventClassMouse,		kEventMouseWheelMoved},
	    {kEventClassWindow,		kEventWindowUpdate},
	    {kEventClassWindow,		kEventWindowActivated},
	    {kEventClassWindow,		kEventWindowDeactivated},
	    {kEventClassKeyboard,	kEventRawKeyDown},
	    {kEventClassKeyboard,	kEventRawKeyRepeat},
	    {kEventClassKeyboard,	kEventRawKeyUp},
	    {kEventClassKeyboard,	kEventRawKeyModifiersChanged},
	    {kEventClassKeyboard,	kEventRawKeyRepeat},
	    {kEventClassApplication,	kEventAppActivated},
	    {kEventClassApplication,	kEventAppDeactivated},
	    {kEventClassApplication,	kEventAppQuit},
d193 13
a205 9
	    {kEventClassMenu,		kEventMenuBeginTracking},
	    {kEventClassMenu,		kEventMenuEndTracking},
	    {kEventClassCommand,	kEventCommandProcess},
	    {kEventClassCommand,	kEventCommandUpdateStatus},
	    {kEventClassMouse,		kEventMouseWheelMoved},
	    {kEventClassWindow,		kEventWindowExpanded},
	    {kEventClassApplication,	kEventAppHidden},
	    {kEventClassApplication,	kEventAppShown},
	    {kEventClassApplication,    kEventAppAvailableWindowBoundsChanged},
a206 1
    EventHandlerUPP handler = NewEventHandlerUPP(CarbonEventHandlerProc);
d208 38
a245 21
    err = InstallStandardApplicationEventHandler();
    if (err != noErr) {
#ifdef TK_MAC_DEBUG
	fprintf(stderr, "InstallStandardApplicationEventHandler failed, %d\n",
		(int) err);
#endif
    }
    err = InstallEventHandler(GetEventDispatcherTarget(), handler,
	    GetEventTypeCount(dispatcherEventTypes), dispatcherEventTypes,
	    (void *) interp, NULL);
    if (err != noErr) {
#ifdef TK_MAC_DEBUG
	fprintf(stderr, "InstallEventHandler failed, %d\n", (int) err);
#endif
    }
    err = InstallEventHandler(GetApplicationEventTarget(), handler,
	    GetEventTypeCount(applicationEventTypes), applicationEventTypes,
	    (void *) interp, NULL);
    if (err != noErr) {
#ifdef TK_MAC_DEBUG
	fprintf(stderr, "InstallEventHandler failed, %d\n", (int) err);
d247 12
d260 40
d301 4
a304 29
#if defined(TK_MAC_DEBUG) && defined(TK_MAC_DEBUG_CARBON_EVENTS)
    TkMacOSXInitNamedDebugSymbol(HIToolbox, void, TraceEventByName, char*);
    if (TraceEventByName) {
	/* Carbon-internal event debugging (c.f. Technote 2124) */
	TraceEventByName("kEventMouseDown");
	TraceEventByName("kEventMouseUp");
	TraceEventByName("kEventMouseWheelMoved");
	TraceEventByName("kEventMouseScroll");
	TraceEventByName("kEventWindowUpdate");
	TraceEventByName("kEventWindowActivated");
	TraceEventByName("kEventWindowDeactivated");
	TraceEventByName("kEventRawKeyDown");
	TraceEventByName("kEventRawKeyRepeat");
	TraceEventByName("kEventRawKeyUp");
	TraceEventByName("kEventRawKeyModifiersChanged");
	TraceEventByName("kEventRawKeyRepeat");
	TraceEventByName("kEventAppActivated");
	TraceEventByName("kEventAppDeactivated");
	TraceEventByName("kEventAppQuit");
	TraceEventByName("kEventMenuBeginTracking");
	TraceEventByName("kEventMenuEndTracking");
	TraceEventByName("kEventCommandProcess");
	TraceEventByName("kEventCommandUpdateStatus");
	TraceEventByName("kEventWindowExpanded");
	TraceEventByName("kEventAppHidden");
	TraceEventByName("kEventAppShown");
	TraceEventByName("kEventAppAvailableWindowBoundsChanged");
    }
#endif /* TK_MAC_DEBUG_CARBON_EVENTS */
d312 2
a313 2
 *	  This procedure installs the carbon standard application event
 *	  handler.
d316 1
a316 1
 *	  OS status code.
d319 1
a319 1
 *	  Standard handlers for application Carbon Events are registered.
d325 1
a325 1
InstallStandardApplicationEventHandler()
d337 6
a342 3
    enum { kExitRaelEvent = 'ExiT' };
    const EventTypeSpec exitRaelEventType =
	    { kExitRaelEvent,		kExitRaelEvent};
d351 1
a351 1
	err = InstallEventHandler(GetEventDispatcherTarget(),
d356 1
a356 1
	err = CreateEvent(NULL, kExitRaelEvent, kExitRaelEvent, 
d360 1
a360 1
	err = PostEventToQueue(GetMainEventQueue(), exitRaelEvent,
d366 5
a370 1
	    /* This point should never be reached ! */
d391 3
a393 3
 *	  This procedure is the dummy event handler used to break out of
 *	  RAEL via longjmp, it is called as the first ever event handler
 *	  in RAEL by posting a high priority dummy event.
d396 1
a396 1
 *	  None. Never returns !
d399 1
a399 1
 *	  longjmp back to InstallStandardApplicationEventHandler().
d405 4
a408 3
ExitRaelEventHandlerProc (
	EventHandlerCallRef callRef,
	EventRef event, void *userData)
d416 28
d446 2
a447 5
 *	  This procedure is the carbon timer handler that runs the tcl
 *	  event loop periodically. It does not process TCL_WINDOW_EVENTS
 *	  to avoid reentry issues with Carbon, nor TCL_IDLE_EVENTS since
 *	  it is only intended to be called during short periods of busy
 *	  time such as during menu tracking.
d450 1
a450 1
 *	  None.
d453 1
a453 1
 *	  Runs the Tcl event loop.
d459 7
a465 11
CarbonTimerProc (
	EventLoopTimerRef timer,
	void *userData)
{
    if(carbonTimerEnabled) {
	/* Avoid starving main event loop: process at most 4 events. */
	int i = 4;
	while(--i && Tcl_DoOneEvent(
		TCL_FILE_EVENTS|TCL_TIMER_EVENTS|TCL_DONT_WAIT)) {
#if defined(TK_MAC_DEBUG) && defined(TK_MAC_DEBUG_CARBON_EVENTS)
	    fprintf(stderr, "Processed tcl event from carbon timer\n");
a466 1
	}
d475 5
a479 5
 *	  This procedure installs (if necessary) and starts a carbon
 *	  event timer that runs the tcl event loop periodically.
 *	  It should be called whenever a nested carbon event loop is
 *	  run by HIToolbox (e.g. during menutracking) to ensure that
 *	  non-window non-idle tcl events are processed.
d482 1
a482 1
 *	  OS status code.
d485 1
a485 1
 *	  Carbon event timer is installed and started.
d491 1
a491 1
TkMacOSXStartTclEventLoopCarbonTimer()
d493 1
a493 1
    OSStatus err;
d495 11
a505 16
    if(!carbonTimer) {
	EventLoopTimerUPP timerUPP = NewEventLoopTimerUPP(CarbonTimerProc);
	err = InstallEventLoopTimer(GetMainEventLoop(), kEventDurationNoWait,
		5 * kEventDurationMillisecond, timerUPP, NULL, &carbonTimer);
	if (err != noErr) {
#ifdef TK_MAC_DEBUG
	    fprintf(stderr, "InstallEventLoopTimer failed, %d\n", (int) err);
#endif
	}
    } else {
	err = SetEventLoopTimerNextFireTime(carbonTimer, kEventDurationNoWait);
	if (err != noErr) {
#ifdef TK_MAC_DEBUG
	    fprintf(stderr, "SetEventLoopTimerNextFireTime failed, %d\n",
		    (int) err);
#endif
a507 1
    carbonTimerEnabled = 1;
d510 1
a510 1

d516 2
a517 2
 *	  This procedure stops the carbon event timer started by
 *	  TkMacOSXStartTclEventLoopCarbonTimer().
d520 1
a520 1
 *	  OS status code.
d523 1
a523 1
 *	 Carbon event timer is stopped.
d529 1
a529 1
TkMacOSXStopTclEventLoopCarbonTimer()
d533 4
a536 7
    if(carbonTimer) {
	err = SetEventLoopTimerNextFireTime(carbonTimer, kEventDurationForever);
	if (err != noErr) {
#ifdef TK_MAC_DEBUG
	    fprintf(stderr, "SetEventLoopTimerNextFireTime failed, %d\n",
		    (int) err);
#endif
a538 1
    carbonTimerEnabled = 0;
d542 113
@

