head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.46;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXNotify.c --
 *
 *	This file contains the implementation of a tcl event source
 *	for the Carbon event loop.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXNotify.c,v 1.19 2007/06/29 03:20:02 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkMacOSXEvent.h"
#include <pthread.h>

/*
 * The following static indicates whether this module has been initialized
 * in the current thread.
 */

typedef struct ThreadSpecificData {
    int initialized;
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

static void TkMacOSXNotifyExitHandler(ClientData clientData);
static void CarbonEventsSetupProc(ClientData clientData, int flags);
static void CarbonEventsCheckProc(ClientData clientData, int flags);

/*
 *----------------------------------------------------------------------
 *
 * Tk_MacOSXSetupTkNotifier --
 *
 *	This procedure is called during Tk initialization to create
 *	the event source for Carbon events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A new event source is created.
 *
 *----------------------------------------------------------------------
 */

void
Tk_MacOSXSetupTkNotifier(void)
{
    ThreadSpecificData *tsdPtr = Tcl_GetThreadData(&dataKey,
	    sizeof(ThreadSpecificData));

    if (!tsdPtr->initialized) {
	/* HACK ALERT: There is a bug in Jaguar where when it goes to make
	 * the event queue for the Main Event Loop, it stores the Current
	 * event loop rather than the Main Event Loop in the Queue structure.
	 * So we have to make sure that the Main Event Queue gets set up on
	 * the main thread. Calling GetMainEventQueue will force this to
	 * happen.
	 */
	GetMainEventQueue();

	tsdPtr->initialized = 1;
	/* Install Carbon events event source in main event loop thread. */
	if (GetCurrentEventLoop() == GetMainEventLoop()) {
	    if (!pthread_main_np()) {
		/*
		 * Panic if the Carbon main event loop thread (i.e. the
		 * thread  where HIToolbox was first loaded) is not the
		 * main application thread, as Carbon does not support
		 * this properly.
		 */
		Tcl_Panic("Tk_MacOSXSetupTkNotifier: %s",
		    "first [load] of TkAqua has to occur in the main thread!");
	    }
	    Tcl_CreateEventSource(CarbonEventsSetupProc,
		    CarbonEventsCheckProc, GetMainEventQueue());
	    TkCreateExitHandler(TkMacOSXNotifyExitHandler, NULL);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXNotifyExitHandler --
 *
 *	This function is called during finalization to clean up the
 *	TkMacOSXNotify module.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
TkMacOSXNotifyExitHandler(clientData)
    ClientData clientData;	/* Not used. */
{
    ThreadSpecificData *tsdPtr = Tcl_GetThreadData(&dataKey,
	    sizeof(ThreadSpecificData));

    Tcl_DeleteEventSource(CarbonEventsSetupProc,
	    CarbonEventsCheckProc, GetMainEventQueue());
    tsdPtr->initialized = 0;
}

/*
 *----------------------------------------------------------------------
 *
 * CarbonEventsSetupProc --
 *
 *	This procedure implements the setup part of the Carbon Events
 *	event source. It is invoked by Tcl_DoOneEvent before entering
 *	the notifier to check for events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If Carbon events are queued, then the maximum block time will be
 *	set to 0 to ensure that the notifier returns control to Tcl.
 *
 *----------------------------------------------------------------------
 */

static void
CarbonEventsSetupProc(clientData, flags)
    ClientData clientData;
    int flags;
{
    static Tcl_Time blockTime = { 0, 0 };

    if (!(flags & TCL_WINDOW_EVENTS)) {
	return;
    }

    if (GetNumEventsInQueue((EventQueueRef)clientData)) {
	Tcl_SetMaxBlockTime(&blockTime);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CarbonEventsCheckProc --
 *
 *	This procedure processes events sitting in the Carbon event
 *	queue.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Moves applicable queued Carbon events onto the Tcl event queue.
 *
 *----------------------------------------------------------------------
 */

static void
CarbonEventsCheckProc(clientData, flags)
    ClientData clientData;
    int flags;
{
    int numFound;
    OSStatus err = noErr;

    if (!(flags & TCL_WINDOW_EVENTS)) {
	return;
    }

    numFound = GetNumEventsInQueue((EventQueueRef)clientData);

    /* Avoid starving other event sources: */
    if (numFound > 4) {
	numFound = 4;
    }
    while (numFound > 0 && err == noErr) {
	err = TkMacOSXReceiveAndDispatchEvent();
	numFound--;
    }
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkMacOSXNotify.c,v 1.18 2007/04/23 21:24:34 das Exp $
d17 1
a17 1
#include "tkMacOSXInt.h"
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d4 1
a4 1
 *	This file contains the implementation of a tcl event source 
d9 1
a9 2
 * Copyright 2005, Tcl Core Team.
 * Copyright (c) 2005 Daniel A. Steffen <das@@users.sourceforge.net>
d14 1
a14 1
 * RCS: @@(#) $Id: tkMacOSXNotify.c,v 1.16 2006/03/28 02:43:24 das Exp $
d53 1
a53 1
Tk_MacOSXSetupTkNotifier()
d57 1
a57 1
    
d59 25
a83 25
        /* HACK ALERT: There is a bug in Jaguar where when it goes to make
         * the event queue for the Main Event Loop, it stores the Current
         * event loop rather than the Main Event Loop in the Queue structure.
         * So we have to make sure that the Main Event Queue gets set up on
         * the main thread.  Calling GetMainEventQueue will force this to
         * happen.
         */
        GetMainEventQueue();

        tsdPtr->initialized = 1;
        /* Install Carbon events event source in main event loop thread. */
        if (GetCurrentEventLoop() == GetMainEventLoop()) {
            if (!pthread_main_np()) {
                /* 
                 * Panic if the Carbon main event loop thread (i.e. the 
                 * thread  where HIToolbox was first loaded) is not the
                 * main application thread, as Carbon does not support
                 * this properly.
                 */
                Tcl_Panic("Tk_MacOSXSetupTkNotifier: %s",
                    "first [load] of TkAqua has to occur in the main thread!");
            }
            Tcl_CreateEventSource(CarbonEventsSetupProc, 
                    CarbonEventsCheckProc, GetMainEventQueue());
            TkCreateExitHandler(TkMacOSXNotifyExitHandler, NULL);
d87 1
a87 1

d112 2
a113 2
    Tcl_DeleteEventSource(CarbonEventsSetupProc, 
            CarbonEventsCheckProc, GetMainEventQueue());
d123 1
a123 1
 *	event source.  It is invoked by Tcl_DoOneEvent before entering
d148 1
a148 1
        Tcl_SetMaxBlockTime(&blockTime);
d151 1
a151 1

d176 1
a176 1
    
d182 1
a182 1
    
d185 1
a185 1
        numFound = 4;
d188 2
a189 2
        err = TkMacOSXReceiveAndProcessEvent();
        numFound--;
@

