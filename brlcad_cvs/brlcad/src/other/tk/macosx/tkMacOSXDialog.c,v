head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.49;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.45;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXDialog.c --
 *
 *	Contains the Mac implementation of the common dialog boxes.
 *
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXDialog.c,v 1.30 2007/09/11 05:24:13 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkFileFilter.h"

#ifndef StrLength
#define StrLength(s)	(*((unsigned char *) (s)))
#endif
#ifndef StrBody
#define StrBody(s)	((char *) (s) + 1)
#endif

#define OPEN_POPUP_ITEM 10

#define SAVE_FILE	0
#define OPEN_FILE	1
#define CHOOSE_FOLDER	2

#define MATCHED		0
#define UNMATCHED	1

#define TK_DEFAULT_ABOUT 128

/*
 * The following structures are used in the GetFileName() function. They store
 * information about the file dialog and the file filters.
 */

typedef struct OpenFileData {
    FileFilterList fl;		/* List of file filters. */
    SInt16 curType;		/* The filetype currently being listed. */
    short popupItem;		/* Item number of the popup in the dialog. */
    int usePopup;		/* True if we show the popup menu (this is
				 * an open operation and the -filetypes
				 * option is set). */
} OpenFileData;

typedef struct NavHandlerUserData {
    OpenFileData *ofdPtr;
    NavReplyRecord reply;
    OSStatus err;
    CFStringRef saveNameRef;
    int sheet;
    WindowRef dialogWindow, origUnavailWindow;
    WindowModality origModality;
} NavHandlerUserData;

/*
 * The following structure is used in the tk_messageBox implementation.
 */

typedef struct {
    int buttonIndex;
    WindowRef dialogWindow, origUnavailWindow;
    WindowModality origModality;
    EventHandlerRef handlerRef;
} AlertHandlerUserData;


static OSStatus		AlertHandler(EventHandlerCallRef callRef,
			    EventRef eventRef, void *userData);
static Boolean		MatchOneType(StringPtr fileNamePtr, OSType fileType,
			    OpenFileData *myofdPtr, FileFilter *filterPtr);
static pascal Boolean	OpenFileFilterProc(AEDesc* theItem, void* info,
			    NavCallBackUserData callBackUD,
			    NavFilterModes filterMode);
static pascal void	OpenEventProc(NavEventCallbackMessage callBackSelector,
			    NavCBRecPtr callBackParms,
			    NavCallBackUserData callBackUD);
static void		InitFileDialogs(void);
static int		NavServicesGetFile(Tcl_Interp *interp,
			    OpenFileData *ofd, AEDesc *initialDescPtr,
			    char *initialFile, AEDescList *selectDescPtr,
			    CFStringRef title, CFStringRef message,
			    int multiple, int isOpen, Tk_Window parent);
static int		HandleInitialDirectory(Tcl_Interp *interp,
			    char *initialFile, char *initialDir, FSRef *dirRef,
			    AEDescList *selectDescPtr, AEDesc *dirDescPtr);

/*
 * Have we initialized the file dialog subsystem
 */

static int fileDlgInited = 0;

/*
 * Filter and hook functions used by the tk_getOpenFile and tk_getSaveFile
 * commands.
 */

static NavObjectFilterUPP openFileFilterUPP;
static NavEventUPP openFileEventUPP;


/*
 *----------------------------------------------------------------------
 *
 * Tk_ChooseColorObjCmd --
 *
 *	This procedure implements the color dialog box for the Mac
 *	platform. See the user documentation for details on what it
 *	does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tk_ChooseColorObjCmd(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
{
    OSStatus err;
    int result = TCL_ERROR;
    Tk_Window parent, tkwin = (Tk_Window) clientData;
    const char *title;
    int i, srcRead, dstWrote;
    CMError cmerr;
    CMProfileRef prof;
    NColorPickerInfo cpinfo;
    static RGBColor color = {0xffff, 0xffff, 0xffff};
    static const char *optionStrings[] = {
	"-initialcolor", "-parent", "-title", NULL
    };
    enum options {
	COLOR_INITIAL, COLOR_PARENT, COLOR_TITLE
    };

    title = "Choose a color:";
    bzero(&cpinfo, sizeof(cpinfo));
    cpinfo.theColor.color.rgb.red   = color.red;
    cpinfo.theColor.color.rgb.green = color.green;
    cpinfo.theColor.color.rgb.blue  = color.blue;

    for (i = 1; i < objc; i += 2) {
	int index;
	const char *option, *value;

	if (Tcl_GetIndexFromObj(interp, objv[i], optionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    goto end;
	}
	if (i + 1 == objc) {
	    option = Tcl_GetString(objv[i]);
	    Tcl_AppendResult(interp, "value for \"", option, "\" missing",
		    NULL);
	    goto end;
	}
	value = Tcl_GetString(objv[i + 1]);

	switch ((enum options) index) {
	    case COLOR_INITIAL: {
		XColor *colorPtr;

		colorPtr = Tk_GetColor(interp, tkwin, value);
		if (colorPtr == NULL) {
		    goto end;
		}
		cpinfo.theColor.color.rgb.red   = colorPtr->red;
		cpinfo.theColor.color.rgb.green = colorPtr->green;
		cpinfo.theColor.color.rgb.blue  = colorPtr->blue;
		Tk_FreeColor(colorPtr);
		break;
	    }
	    case COLOR_PARENT: {
		parent = Tk_NameToWindow(interp, value, tkwin);
		if (parent == NULL) {
		    goto end;
		}
		break;
	    }
	    case COLOR_TITLE: {
		title = value;
		break;
	    }
	}
    }

    cmerr = CMGetDefaultProfileBySpace(cmRGBData, &prof);
    cpinfo.theColor.profile = prof;
    cpinfo.dstProfile = prof;
    cpinfo.flags = kColorPickerDialogIsMoveable | kColorPickerDialogIsModal;
    cpinfo.placeWhere = kCenterOnMainScreen;
    /* Currently, this does not actually change the colorpicker title */
    Tcl_UtfToExternal(NULL, TkMacOSXCarbonEncoding, title, -1, 0, NULL,
	StrBody(cpinfo.prompt), 255, &srcRead, &dstWrote, NULL);
    StrLength(cpinfo.prompt) = (unsigned char) dstWrote;

    TkMacOSXTrackingLoop(1);
    err = ChkErr(NPickColor, &cpinfo);
    TkMacOSXTrackingLoop(0);
    cmerr = CMCloseProfile(prof);
    if ((err == noErr) && (cpinfo.newColorChosen != 0)) {
	char colorstr[8];

	color.red   = cpinfo.theColor.color.rgb.red;
	color.green = cpinfo.theColor.color.rgb.green;
	color.blue  = cpinfo.theColor.color.rgb.blue;
	snprintf(colorstr, 8, "#%02x%02x%02x", color.red >> 8,
		color.green >> 8, color.blue >> 8);
	Tcl_SetObjResult(interp, Tcl_NewStringObj(colorstr, 7));
    } else {
	Tcl_ResetResult(interp);
    }
    result = TCL_OK;

end:
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetOpenFileObjCmd --
 *
 *	This procedure implements the "open file" dialog box for the
 *	Mac platform. See the user documentation for details on what
 *	it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See user documentation.
 *----------------------------------------------------------------------
 */

int
Tk_GetOpenFileObjCmd(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
{
    int i, result = TCL_ERROR, multiple = 0;
    OpenFileData ofd;
    Tk_Window parent = NULL;
    CFStringRef message = NULL, title = NULL;
    AEDesc initialDesc = {typeNull, NULL};
    FSRef dirRef;
    AEDesc *initialPtr = NULL;
    AEDescList selectDesc = {typeNull, NULL};
    char *initialFile = NULL, *initialDir = NULL;
    static const char *openOptionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-message", "-multiple", "-parent", "-title", NULL
    };
    enum openOptions {
	OPEN_DEFAULT, OPEN_FILETYPES, OPEN_INITDIR, OPEN_INITFILE,
	OPEN_MESSAGE, OPEN_MULTIPLE, OPEN_PARENT, OPEN_TITLE
    };

    if (!fileDlgInited) {
	InitFileDialogs();
    }
    TkInitFileFilters(&ofd.fl);
    ofd.curType = 0;
    ofd.popupItem = OPEN_POPUP_ITEM;
    ofd.usePopup = 1;

    for (i = 1; i < objc; i += 2) {
	char *choice;
	int index, choiceLen;
	char *string;
	Tcl_Obj *types;

	if (Tcl_GetIndexFromObj(interp, objv[i], openOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    goto end;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetString(objv[i]);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing",
		    NULL);
	    goto end;
	}

	switch (index) {
	    case OPEN_DEFAULT:
		break;
	    case OPEN_FILETYPES:
		types = objv[i + 1];
		if (TkGetFileFilters(interp, &ofd.fl, types, 0) != TCL_OK) {
		    goto end;
		}
		break;
	    case OPEN_INITDIR:
		initialDir = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		/* empty strings should be like no selection given */
		if (choiceLen == 0) { initialDir = NULL; }
		break;
	    case OPEN_INITFILE:
		initialFile = Tcl_GetString(objv[i + 1]);
		/* empty strings should be like no selection given */
		if (choiceLen == 0) { initialFile = NULL; }
		break;
	    case OPEN_MESSAGE:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		message = CFStringCreateWithBytes(NULL, (unsigned char*)
			choice, choiceLen, kCFStringEncodingUTF8, false);
		break;
	    case OPEN_MULTIPLE:
		if (Tcl_GetBooleanFromObj(interp, objv[i + 1], &multiple)
			!= TCL_OK) {
		    goto end;
		}
		break;
	    case OPEN_PARENT:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		parent = Tk_NameToWindow(interp, choice,
			(Tk_Window) clientData);
		if (parent == NULL) {
		    goto end;
		}
		break;
	    case OPEN_TITLE:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		title = CFStringCreateWithBytes(NULL, (unsigned char*)
			choice, choiceLen, kCFStringEncodingUTF8, false);
		break;
	}
    }

    if (HandleInitialDirectory(interp, initialFile, initialDir, &dirRef,
	    &selectDesc, &initialDesc) != TCL_OK) {
	goto end;
    }

    if (initialDesc.descriptorType == typeFSRef) {
	initialPtr = &initialDesc;
    }
    result = NavServicesGetFile(interp, &ofd, initialPtr, NULL, &selectDesc,
	    title, message, multiple, OPEN_FILE, parent);
end:
    TkFreeFileFilters(&ofd.fl);
    if (initialDesc.dataHandle) {
	ChkErr(AEDisposeDesc, &initialDesc);
    }
    if (selectDesc.dataHandle) {
	ChkErr(AEDisposeDesc, &selectDesc);
    }
    if (title) {
	CFRelease(title);
    }
    if (message) {
	CFRelease(message);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetSaveFileObjCmd --
 *
 *	Same as Tk_GetOpenFileCmd but opens a "save file" dialog box
 *	instead
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See user documentation.
 *----------------------------------------------------------------------
 */

int
Tk_GetSaveFileObjCmd(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
{
    int i, result = TCL_ERROR;
    char *initialFile = NULL;
    Tk_Window parent = NULL;
    AEDesc initialDesc = {typeNull, NULL};
    AEDesc *initialPtr = NULL;
    FSRef dirRef;
    CFStringRef title = NULL, message = NULL;
    OpenFileData ofd;
    static const char *saveOptionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-message", "-parent", "-title", NULL
    };
    enum saveOptions {
	SAVE_DEFAULT, SAVE_FILETYPES, SAVE_INITDIR, SAVE_INITFILE,
	SAVE_MESSAGE, SAVE_PARENT, SAVE_TITLE
    };

    if (!fileDlgInited) {
	InitFileDialogs();
    }

    TkInitFileFilters(&ofd.fl);
    ofd.curType = 0;
    ofd.usePopup = 0;

    for (i = 1; i < objc; i += 2) {
	char *choice, *string;
	int index, choiceLen;
	Tcl_Obj *types;

	if (Tcl_GetIndexFromObj(interp, objv[i], saveOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    goto end;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetString(objv[i]);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing",
		    NULL);
	    goto end;
	}
	switch (index) {
	    case SAVE_DEFAULT:
		break;
	    case SAVE_FILETYPES:
		types = objv[i + 1];
		if (TkGetFileFilters(interp, &ofd.fl, types, 0) != TCL_OK) {
		    goto end;
		}
		break;
	    case SAVE_INITDIR:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		/* empty strings should be like no selection given */
		if (choiceLen && HandleInitialDirectory(interp, NULL, choice,
			&dirRef, NULL, &initialDesc) != TCL_OK) {
		    goto end;
		}
		break;
	    case SAVE_INITFILE:
		initialFile = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		/* empty strings should be like no selection given */
		if (choiceLen == 0) {
		    initialFile = NULL;
		}
		break;
	    case SAVE_MESSAGE:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		message = CFStringCreateWithBytes(NULL, (unsigned char*)
			choice, choiceLen, kCFStringEncodingUTF8, false);
		break;
	    case SAVE_PARENT:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		parent = Tk_NameToWindow(interp, choice,
			(Tk_Window) clientData);
		if (parent == NULL) {
		    goto end;
		}
		break;
	    case SAVE_TITLE:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		title = CFStringCreateWithBytes(NULL, (unsigned char*)
			choice, choiceLen, kCFStringEncodingUTF8, false);
		break;
	}
    }

    if (initialDesc.descriptorType == typeFSRef) {
	initialPtr = &initialDesc;
    }
    result = NavServicesGetFile(interp, &ofd, initialPtr, initialFile, NULL,
	    title, message, false, SAVE_FILE, parent);
    TkFreeFileFilters(&ofd.fl);
end:
    if (initialDesc.dataHandle) {
	ChkErr(AEDisposeDesc, &initialDesc);
    }
    if (title) {
	CFRelease(title);
    }
    if (message) {
	CFRelease(message);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_ChooseDirectoryObjCmd --
 *
 *	This procedure implements the "tk_chooseDirectory" dialog box
 *	for the Windows platform. See the user documentation for details
 *	on what it does.
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	A modal dialog window is created.
 *
 *----------------------------------------------------------------------
 */

int
Tk_ChooseDirectoryObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int i, result = TCL_ERROR;
    Tk_Window parent = NULL;
    AEDesc initialDesc = {typeNull, NULL}, *initialPtr = NULL;
    FSRef dirRef;
    CFStringRef message = NULL, title = NULL;
    OpenFileData ofd;
    static const char *chooseOptionStrings[] = {
	"-initialdir", "-message", "-mustexist", "-parent", "-title", NULL
    };
    enum chooseOptions {
	CHOOSE_INITDIR, CHOOSE_MESSAGE, CHOOSE_MUSTEXIST, CHOOSE_PARENT,
	CHOOSE_TITLE
    };

    if (!fileDlgInited) {
	InitFileDialogs();
    }

    for (i = 1; i < objc; i += 2) {
	char *choice;
	int index, choiceLen;
	char *string;

	if (Tcl_GetIndexFromObj(interp, objv[i], chooseOptionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    goto end;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetString(objv[i]);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing",
		    NULL);
	    goto end;
	}
	switch (index) {
	    case CHOOSE_INITDIR:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		if (choiceLen && HandleInitialDirectory(interp, NULL, choice,
			&dirRef, NULL, &initialDesc) != TCL_OK) {
		    goto end;
		}
		break;
	    case CHOOSE_MESSAGE:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		message = CFStringCreateWithBytes(NULL, (unsigned char*)
			choice, choiceLen, kCFStringEncodingUTF8, false);
		break;
	    case CHOOSE_PARENT:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		parent = Tk_NameToWindow(interp, choice,
			(Tk_Window) clientData);
		if (parent == NULL) {
		    goto end;
		}
		break;
	    case CHOOSE_TITLE:
		choice = Tcl_GetStringFromObj(objv[i + 1], &choiceLen);
		title = CFStringCreateWithBytes(NULL, (unsigned char*) choice,
			choiceLen, kCFStringEncodingUTF8, false);
		break;
	}
    }

    TkInitFileFilters(&ofd.fl);
    ofd.usePopup = 0;
    if (initialDesc.descriptorType == typeFSRef) {
	initialPtr = &initialDesc;
    }
    result = NavServicesGetFile(interp, &ofd, initialPtr, NULL, NULL, title,
	    message, false, CHOOSE_FOLDER, parent);
    TkFreeFileFilters(&ofd.fl);
end:
    if (initialDesc.dataHandle) {
	ChkErr(AEDisposeDesc, &initialDesc);
    }
    if (title) {
	CFRelease(title);
    }
    if (message) {
	CFRelease(message);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * HandleInitialDirectory --
 *
 *	Helper for -initialdir setup.
 *
 * Results:
 *	Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
HandleInitialDirectory(
    Tcl_Interp *interp,
    char *initialFile,
    char *initialDir,
    FSRef *dirRef,
    AEDescList *selectDescPtr,
    AEDesc *dirDescPtr)
{
    Tcl_DString ds;
    OSStatus err;
    Boolean isDirectory;
    char *dirName = NULL;
    int result = TCL_ERROR;

    if (initialDir) {
	dirName = Tcl_TranslateFileName(interp, initialDir, &ds);
	if (dirName == NULL) {
	    goto end;
	}
	err = ChkErr(FSPathMakeRef, (unsigned char*) dirName,
		dirRef, &isDirectory);
	if (err != noErr) {
	    Tcl_AppendResult(interp, "bad directory \"", initialDir, "\"",
		    NULL);
	    goto end;
	}
	if (!isDirectory) {
	    Tcl_AppendResult(interp, "-intialdir \"",
		    initialDir, " is a file, not a directory.\"", NULL);
	    goto end;
	}
	ChkErr(AECreateDesc, typeFSRef, dirRef, sizeof(*dirRef), dirDescPtr);
    }

    if (initialFile && selectDescPtr) {
	FSRef fileRef;
	AEDesc fileDesc;
	char *namePtr;

	if (initialDir) {
	    Tcl_DStringAppend(&ds, "/", 1);
	    Tcl_DStringAppend(&ds, initialFile, -1);
	    namePtr = Tcl_DStringValue(&ds);
	} else {
	    namePtr = initialFile;
	}

	ChkErr(AECreateList, NULL, 0, false, selectDescPtr);

	err = ChkErr(FSPathMakeRef, (unsigned char*) namePtr, &fileRef,
		&isDirectory);
	if (err != noErr) {
	    Tcl_AppendResult(interp, "bad initialfile \"", initialFile,
		    "\" file does not exist.", NULL);
	    goto end;
	}
	ChkErr(AECreateDesc, typeFSRef, &fileRef, sizeof(fileRef), &fileDesc);
	ChkErr(AEPutDesc, selectDescPtr, 1, &fileDesc);
	ChkErr(AEDisposeDesc, &fileDesc);
    }
    result = TCL_OK;
end:
    if (dirName) {
	Tcl_DStringFree(&ds);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * InitFileDialogs --
 *
 *	Initialize file dialog subsystem.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
InitFileDialogs(void)
{
    fileDlgInited = 1;
    openFileFilterUPP = NewNavObjectFilterUPP(OpenFileFilterProc);
    openFileEventUPP = NewNavEventUPP(OpenEventProc);
}

/*
 *----------------------------------------------------------------------
 *
 * NavServicesGetFile --
 *
 *	Common wrapper for NavServices API.
 *
 * Results:
 *	Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
NavServicesGetFile(
    Tcl_Interp *interp,
    OpenFileData *ofdPtr,
    AEDesc *initialDescPtr,
    char *initialFile,
    AEDescList *selectDescPtr,
    CFStringRef title,
    CFStringRef message,
    int multiple,
    int isOpen,
    Tk_Window parent)
{
    NavHandlerUserData data;
    NavDialogCreationOptions options;
    NavDialogRef dialogRef = NULL;
    CFStringRef * menuItemNames = NULL;
    OSStatus err;
    Tcl_Obj *theResult = NULL;
    int result = TCL_ERROR;

    bzero(&data, sizeof(data));
    err = NavGetDefaultDialogCreationOptions(&options);
    if (err != noErr) {
	return result;
    }
    options.optionFlags = kNavDontAutoTranslate | kNavDontAddTranslateItems
	    | kNavSupportPackages | kNavAllFilesInPopup;
    if (multiple) {
	options.optionFlags |= kNavAllowMultipleFiles;
    }
    options.modality = kWindowModalityAppModal;
    if (parent && ((TkWindow*)parent)->window != None &&
	    TkMacOSXHostToplevelExists(parent)) {
	options.parentWindow = TkMacOSXDrawableWindow(Tk_WindowId(parent));
	TK_IF_HI_TOOLBOX (5,
	    /*
	     * Impossible to modify dialog modality with the Cocoa-based
	     * NavServices implementation.
	     */
	) TK_ELSE_HI_TOOLBOX (5,
	    if (options.parentWindow) {
		options.modality = kWindowModalityWindowModal;
		data.sheet = 1;
	    }
	) TK_ENDIF
    }

    /*
     * Now process the selection list. We have to use the popupExtension
     * to fill the menu.
     */
    if (ofdPtr && ofdPtr->usePopup) {
	FileFilter *filterPtr;

	filterPtr = ofdPtr->fl.filters;
	if (filterPtr == NULL) {
	    ofdPtr->usePopup = 0;
	}
    }
    if (ofdPtr && ofdPtr->usePopup) {
	FileFilter *filterPtr;
	int index = 0;
	ofdPtr->curType = 0;

	menuItemNames = (CFStringRef *) ckalloc(ofdPtr->fl.numFilters
	    * sizeof(CFStringRef));

	for (filterPtr = ofdPtr->fl.filters; filterPtr != NULL;
		filterPtr = filterPtr->next, index++) {
	    menuItemNames[index] = CFStringCreateWithCString(NULL,
		    filterPtr->name, kCFStringEncodingUTF8);
	}
	options.popupExtension = CFArrayCreate(NULL,
		(const void **) menuItemNames, ofdPtr->fl.numFilters, NULL);
    } else {
	options.optionFlags |= kNavNoTypePopup;
	options.popupExtension = NULL;
    }
    options.clientName = CFSTR("Wish");
    options.message = message;
    options.windowTitle = title;
    if (initialFile) {
	options.saveFileName = CFStringCreateWithCString(NULL,
		initialFile, kCFStringEncodingUTF8);
    } else {
	options.saveFileName = NULL;
    }
    if (isOpen == OPEN_FILE) {
	data.ofdPtr = ofdPtr;
	err = ChkErr(NavCreateGetFileDialog, &options, NULL,
		openFileEventUPP, NULL, openFileFilterUPP, &data, &dialogRef);
    } else if (isOpen == SAVE_FILE) {
	err = ChkErr(NavCreatePutFileDialog, &options, 'TEXT', 'WIsH',
		openFileEventUPP, &data, &dialogRef);
    } else if (isOpen == CHOOSE_FOLDER) {
	err = ChkErr(NavCreateChooseFolderDialog, &options,
		openFileEventUPP, openFileFilterUPP, &data, &dialogRef);
    }
    if (err == noErr && dialogRef) {
	if (initialDescPtr) {
	    ChkErr(NavCustomControl, dialogRef, kNavCtlSetLocation,
		initialDescPtr);
	}
	if (selectDescPtr && selectDescPtr->descriptorType != typeNull) {
	    ChkErr(NavCustomControl, dialogRef, kNavCtlSetSelection,
		    selectDescPtr);
	}
	TkMacOSXTrackingLoop(1);
	err = ChkErr(NavDialogRun, dialogRef);
	if (err == noErr) {
	    if (data.sheet) {
		data.dialogWindow = NavDialogGetWindow(dialogRef);
		ChkErr(GetWindowModality, data.dialogWindow,
			&data.origModality, &data.origUnavailWindow);
		ChkErr(SetWindowModality, data.dialogWindow,
			kWindowModalityAppModal, NULL);
		ChkErr(RunAppModalLoopForWindow, data.dialogWindow);
	    }
	    err = data.err;
	}
	TkMacOSXTrackingLoop(0);
    }

    /*
     * Most commands assume that the file dialogs return a single
     * item, not a list. So only build a list if multiple is true...
     */
    if (err == noErr) {
	if (multiple) {
	    theResult = Tcl_NewListObj(0, NULL);
	} else {
	    theResult = Tcl_NewObj();
	}
	if (!theResult) {
	    err = memFullErr;
	}
    }
    if (err == noErr && data.reply.validRecord) {
	AEDesc resultDesc;
	long count;
	FSRef fsRef;
	char pathPtr[PATH_MAX + 1];

	err = ChkErr(AECountItems, &data.reply.selection, &count);
	if (err == noErr) {
	    long i;

	    for (i = 1; i <= count; i++) {
		err = ChkErr(AEGetNthDesc, &data.reply.selection, i,
			typeFSRef, NULL, &resultDesc);
		if (err == noErr) {
		    err = ChkErr(AEGetDescData, &resultDesc, &fsRef,
			    sizeof(fsRef));
		    if (err == noErr) {
			err = ChkErr(FSRefMakePath, &fsRef, (unsigned char*)
				pathPtr, PATH_MAX + 1);
			if (err == noErr) {
			    int pathValid = 0;

			    if (isOpen == SAVE_FILE) {
				if (data.saveNameRef) {
				    char saveName [PATH_MAX + 1];

				    if (CFStringGetCString(data.saveNameRef,
					    saveName, PATH_MAX + 1,
					    kCFStringEncodingUTF8)) {
					if (strlen(pathPtr) + strlen(saveName)
						< PATH_MAX) {
					    strcat(pathPtr, "/");
					    strcat(pathPtr, saveName);
					    pathValid = 1;
					} else {
					    TkMacOSXDbgMsg("Path name too "
						    "long");
					}
				    } else {
					TkMacOSXDbgMsg("CFStringGetCString "
						"failed");
				    }
				} else {
				    TkMacOSXDbgMsg("NavDialogGetSaveFileName "
					    "failed");
				}
			    } else {
				pathValid = 1;
			    }
			    if (pathValid) {
				if (multiple) {
				    Tcl_ListObjAppendElement(interp, theResult,
					Tcl_NewStringObj(pathPtr, -1));
				} else {
				    Tcl_SetStringObj(theResult, pathPtr, -1);
				}
			    }
			}
		    }
		    ChkErr(AEDisposeDesc, &resultDesc);
		}
	    }
	}
	Tcl_SetObjResult(interp, theResult);
	result = TCL_OK;
    } else if (err == userCanceledErr) {
	Tcl_ResetResult(interp);
	result = TCL_OK;
    }

    /*
     * Clean up any allocated memory.
     */

    if (data.reply.validRecord) {
	ChkErr(NavDisposeReply, &data.reply);
    }
    if (data.saveNameRef) {
	CFRelease(data.saveNameRef);
    }
    if (options.saveFileName) {
	CFRelease(options.saveFileName);
    }
    if (options.clientName) {
	CFRelease(options.clientName);
    }
    if (menuItemNames) {
	int i;
	for (i = 0; i < ofdPtr->fl.numFilters; i++) {
	    CFRelease(menuItemNames[i]);
	}
	ckfree((void *)menuItemNames);
    }
    if (options.popupExtension) {
	CFRelease(options.popupExtension);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * OpenEventProc --
 *
 *	NavServices event handling callback.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

pascal void
OpenEventProc(
    NavEventCallbackMessage callBackSelector,
    NavCBRecPtr callBackParams,
    NavCallBackUserData callBackUD)
{
    NavHandlerUserData *data = (NavHandlerUserData*) callBackUD;

    switch (callBackSelector) {
	case kNavCBPopupMenuSelect:
	    data->ofdPtr->curType = ((NavMenuItemSpec *)
		    callBackParams->eventData.eventDataParms.param)->menuType;
	    break;
	case kNavCBAccept:
	case kNavCBCancel:
	    if (data->sheet) {
		ChkErr(QuitAppModalLoopForWindow, data->dialogWindow);
		ChkErr(SetWindowModality, data->dialogWindow,
			data->origModality, data->origUnavailWindow);
	    }
	    break;
	case kNavCBUserAction:
	    if (data->reply.validRecord) {
		ChkErr(NavDisposeReply, &data->reply);
		data->reply.validRecord = 0;
	    }
	    data->err = NavDialogGetReply(callBackParams->context,
		    &data->reply);
	    if (callBackParams->userAction == kNavUserActionSaveAs) {
		data->saveNameRef = NavDialogGetSaveFileName(
			callBackParams->context);
		if (data->saveNameRef) {
		    CFRetain(data->saveNameRef);
		}
	    }
	    break;
	case kNavCBTerminate:
	    NavDialogDispose(callBackParams->context);
	    break;
	case kNavCBEvent:
	    TkMacOSXRunTclEventLoop();
	    break;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * OpenFileFilterProc --
 *
 *	NavServices file filter callback.
 *
 * Results:
 *	Whether to use the file in question.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

pascal Boolean
OpenFileFilterProc(
    AEDesc* theItem, void* info,
    NavCallBackUserData callBackUD,
    NavFilterModes filterMode)
{
    OpenFileData *ofdPtr = ((NavHandlerUserData*) callBackUD)->ofdPtr;
    int result = MATCHED;

    if (ofdPtr && ofdPtr->usePopup) {
	if (ofdPtr->fl.numFilters > 0) {
	    if ((theItem->descriptorType == typeFSS)
		    || (theItem->descriptorType == typeFSRef)) {
		NavFileOrFolderInfo* theInfo = (NavFileOrFolderInfo *) info;
		char fileName[256];

		if (!theInfo->isFolder) {
		    OSType fileType;
		    StringPtr fileNamePtr;
		    Tcl_DString fileNameDString;
		    int i;
		    FileFilter *filterPtr;

		    fileType =
			    theInfo->fileAndFolder.fileInfo.finderInfo.fdType;
		    Tcl_DStringInit (&fileNameDString);

		    if (theItem->descriptorType == typeFSS) {
			int len;
			fileNamePtr = ((FSSpec *) *theItem->dataHandle)->name;
			len = fileNamePtr[0];
			strncpy(fileName, (char*) fileNamePtr + 1, len);
			fileName[len] = '\0';
			fileNamePtr = (unsigned char*) fileName;

		    } else if ((theItem->descriptorType = typeFSRef)) {
			OSStatus err;
			FSRef *theRef = (FSRef *) *theItem->dataHandle;
			HFSUniStr255 uniFileName;
			err = ChkErr(FSGetCatalogInfo, theRef, kFSCatInfoNone,
				NULL, &uniFileName, NULL, NULL);

			if (err == noErr) {
			    Tcl_UniCharToUtfDString (
				    (Tcl_UniChar *) uniFileName.unicode,
				    uniFileName.length, &fileNameDString);
			    fileNamePtr = (unsigned char*)
				    Tcl_DStringValue(&fileNameDString);
			} else {
			    fileNamePtr = NULL;
			}
		    }
		    if (ofdPtr->usePopup) {
			i = ofdPtr->curType;
			for (filterPtr = ofdPtr->fl.filters;
				filterPtr && i > 0; i--) {
			    filterPtr = filterPtr->next;
			}
			if (filterPtr) {
			    result = MatchOneType(fileNamePtr, fileType,
				    ofdPtr, filterPtr);
			} else {
			    result = UNMATCHED;
			}
		    } else {
			/*
			 * We are not using the popup menu. In this case, the
			 * file is considered matched if it matches any of
			 * the file filters.
			 */

			result = UNMATCHED;
			for (filterPtr = ofdPtr->fl.filters; filterPtr;
				filterPtr = filterPtr->next) {
			    if (MatchOneType(fileNamePtr, fileType,
				    ofdPtr, filterPtr) == MATCHED) {
				result = MATCHED;
				break;
			    }
			}
		    }
		    Tcl_DStringFree (&fileNameDString);
		}
	    }
	}
    }
    return (result == MATCHED);
}

/*
 *----------------------------------------------------------------------
 *
 * MatchOneType --
 *
 *	Match a file with one file type in the list of file types.
 *
 * Results:
 *	Returns MATCHED if the file matches with the file type; returns
 *	UNMATCHED otherwise.
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

Boolean
MatchOneType(
    StringPtr fileNamePtr,	/* Name of the file */
    OSType fileType,		/* Type of the file, 0 means there was no
				 * specified type. */
    OpenFileData *ofdPtr,	/* Information about this file dialog */
    FileFilter *filterPtr)	/* Match the file described by pb against this
				 * filter */
{
    FileFilterClause *clausePtr;

    /*
     * A file matches with a file type if it matches with at least one
     * clause of the type.
     *
     * If the clause has both glob patterns and ostypes, the file must
     * match with at least one pattern AND at least one ostype.
     *
     * If the clause has glob patterns only, the file must match with at least
     * one pattern.
     *
     * If the clause has mac types only, the file must match with at least
     * one mac type.
     *
     * If the clause has neither glob patterns nor mac types, it's
     * considered an error.
     */

    for (clausePtr = filterPtr->clauses; clausePtr;
	    clausePtr = clausePtr->next) {
	int macMatched = 0;
	int globMatched = 0;
	GlobPattern *globPtr;
	MacFileType *mfPtr;

	if (clausePtr->patterns == NULL) {
	    globMatched = 1;
	}
	if (clausePtr->macTypes == NULL) {
	    macMatched = 1;
	}

	for (globPtr = clausePtr->patterns; globPtr;
		globPtr = globPtr->next) {
	    char *q, *ext;

	    if (fileNamePtr == NULL) {
		continue;
	    }
	    ext = globPtr->pattern;

	    if (ext[0] == '\0') {
		/*
		 * We don't want any extensions: OK if the filename doesn't
		 * have "." in it
		 */

		for (q = (char*) fileNamePtr; *q; q++) {
		    if (*q == '.') {
			goto glob_unmatched;
		    }
		}
		goto glob_matched;
	    }

	    if (Tcl_StringMatch((char*) fileNamePtr, ext)) {
		goto glob_matched;
	    } else {
		goto glob_unmatched;
	    }

	glob_unmatched:
	    continue;

	glob_matched:
	    globMatched = 1;
	    break;
	}

	for (mfPtr = clausePtr->macTypes; mfPtr; mfPtr = mfPtr->next) {
	    if (fileType == mfPtr->type) {
		macMatched = 1;
		break;
	    }
	}

	/*
	 * On Mac OS X, it is not uncommon for files to have NO
	 * file type. But folks with Tcl code on Classic MacOS pretty
	 * much assume that a generic file will have type TEXT. So
	 * if we were strict about matching types when the source file
	 * had NO type set, they would have to add another rule always
	 * with no fileType. To avoid that, we pass the macMatch side
	 * of the test if no fileType is set.
	 */

	if (globMatched && (macMatched || (fileType == 0))) {
	    return MATCHED;
	}
    }

    return UNMATCHED;
}

/*
 *----------------------------------------------------------------------
 *
 * TkAboutDlg --
 *
 *	Displays the default Tk About box. This code uses Macintosh
 *	resources to define the content of the About Box.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkAboutDlg(void)
{
    DialogPtr aboutDlog;
    WindowRef windowRef;
    short itemHit = -9;

    aboutDlog = GetNewDialog(TK_DEFAULT_ABOUT, NULL, (void *) (-1));
    if (!aboutDlog) {
	return;
    }
    windowRef = GetDialogWindow(aboutDlog);
    SelectWindow(windowRef);
    TkMacOSXTrackingLoop(1);
    while (itemHit != 1) {
	ModalDialog(NULL, &itemHit);
    }
    TkMacOSXTrackingLoop(0);
    DisposeDialog(aboutDlog);
    SelectWindow(ActiveNonFloatingWindow());
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_MessageBoxObjCmd --
 *
 *	Implements the tk_messageBox in native Mac OS X style.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	none
 *
 *----------------------------------------------------------------------
 */

int
Tk_MessageBoxObjCmd(
    ClientData clientData,	/* Main window associated with interpreter. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST objv[])	/* Argument objects. */
{
    Tk_Window tkwin = (Tk_Window) clientData;
    AlertStdCFStringAlertParamRec paramCFStringRec;
    AlertType alertType;
    DialogRef dialogRef;
    CFStringRef messageTextCF = NULL, finemessageTextCF = NULL;
    OSStatus err;
    SInt16 itemHit;
    Boolean haveDefaultOption = false, haveParentOption = false;
    char *str;
    int index, defaultButtonIndex;
    int defaultNativeButtonIndex; /* 1, 2, 3: right to left */
    int typeIndex, i, indexDefaultOption = 0, result = TCL_ERROR;

    static const char *movableAlertStrings[] = {
	"-default", "-detail", "-icon", "-message", "-parent", "-title",
	"-type", NULL
    };
    static const char *movableTypeStrings[] = {
	"abortretryignore", "ok", "okcancel", "retrycancel", "yesno",
	"yesnocancel", NULL
    };
    static const char *movableButtonStrings[] = {
	"abort", "retry", "ignore", "ok", "cancel", "yes", "no", NULL
    };
    static const char *movableIconStrings[] = {
	"error", "info", "question", "warning", NULL
    };
    enum movableAlertOptions {
	ALERT_DEFAULT, ALERT_DETAIL, ALERT_ICON, ALERT_MESSAGE, ALERT_PARENT,
	ALERT_TITLE, ALERT_TYPE
    };
    enum movableTypeOptions {
	TYPE_ABORTRETRYIGNORE, TYPE_OK, TYPE_OKCANCEL, TYPE_RETRYCANCEL,
	TYPE_YESNO, TYPE_YESNOCANCEL
    };
    enum movableButtonOptions {
	TEXT_ABORT, TEXT_RETRY, TEXT_IGNORE, TEXT_OK, TEXT_CANCEL, TEXT_YES,
	TEXT_NO
    };
    enum movableIconOptions {
	ICON_ERROR, ICON_INFO, ICON_QUESTION, ICON_WARNING
    };

    /*
     * Need to map from 'movableButtonStrings' and its corresponding integer,
     * index to the native button index, which is 1, 2, 3, from right to left.
     * This is necessary to do for each separate '-type' of button sets.
     */

    short buttonIndexAndTypeToNativeButtonIndex[][7] = {
    /*	abort retry ignore ok	cancel yes   no */
	{1,    2,    3,	   0,	 0,    0,    0},	/* abortretryignore */
	{0,    0,    0,	   1,	 0,    0,    0},	/* ok */
	{0,    0,    0,	   1,	 2,    0,    0},	/* okcancel */
	{0,    1,    0,	   0,	 2,    0,    0},	/* retrycancel */
	{0,    0,    0,	   0,	 0,    1,    2},	/* yesno */
	{0,    0,    0,	   0,	 3,    1,    2},	/* yesnocancel */
    };

    /*
     * Need also the inverse mapping, from native button (1, 2, 3) to the
     * descriptive button text string index.
     */

    short nativeButtonIndexAndTypeToButtonIndex[][4] = {
	{-1, 0, 1, 2},	/* abortretryignore */
	{-1, 3, 0, 0},	/* ok */
	{-1, 3, 4, 0},	/* okcancel */
	{-1, 1, 4, 0},	/* retrycancel */
	{-1, 5, 6, 0},	/* yesno */
	{-1, 5, 6, 4},	/* yesnocancel */
    };

    alertType = kAlertPlainAlert;
    typeIndex = TYPE_OK;

    ChkErr(GetStandardAlertDefaultParams, &paramCFStringRec,
	    kStdCFStringAlertVersionOne);
    paramCFStringRec.movable = true;
    paramCFStringRec.helpButton = false;
    paramCFStringRec.defaultButton = kAlertStdAlertOKButton;
    paramCFStringRec.cancelButton = kAlertStdAlertCancelButton;

    for (i = 1; i < objc; i += 2) {
	int iconIndex;
	char *string;

	if (Tcl_GetIndexFromObj(interp, objv[i], movableAlertStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    goto end;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetString(objv[i]);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing",
		    NULL);
	    goto end;
	}

	switch (index) {
	    case ALERT_DEFAULT:
		/*
		 * Need to postpone processing of this option until we are
		 * sure to know the '-type' as well.
		 */
		haveDefaultOption = true;
		indexDefaultOption = i;
		break;

	    case ALERT_DETAIL:
		str = Tcl_GetString(objv[i + 1]);
		finemessageTextCF = CFStringCreateWithCString(NULL, str,
			kCFStringEncodingUTF8);
		break;

	    case ALERT_ICON:
		if (Tcl_GetIndexFromObj(interp, objv[i + 1],
			movableIconStrings, "value", TCL_EXACT, &iconIndex)
			!= TCL_OK) {
		    goto end;
		}
		switch (iconIndex) {
		    case ICON_ERROR:
			alertType = kAlertStopAlert;
			break;
		    case ICON_INFO:
			alertType = kAlertNoteAlert;
			break;
		    case ICON_QUESTION:
			alertType = kAlertCautionAlert;
			break;
		    case ICON_WARNING:
			alertType = kAlertCautionAlert;
			break;
		}
		break;

	    case ALERT_MESSAGE:
		str = Tcl_GetString(objv[i + 1]);
		messageTextCF = CFStringCreateWithCString(NULL, str,
			kCFStringEncodingUTF8);
		break;

	    case ALERT_PARENT:
		str = Tcl_GetString(objv[i + 1]);
		tkwin = Tk_NameToWindow(interp, str, tkwin);
		if (tkwin == NULL) {
		    goto end;
		}
		if (((TkWindow*)tkwin)->window != None &&
			TkMacOSXHostToplevelExists(tkwin)) {
		    haveParentOption = true;
		}
		break;

	    case ALERT_TITLE:
		break;

	    case ALERT_TYPE:
		if (Tcl_GetIndexFromObj(interp, objv[i + 1],\
			movableTypeStrings, "value", TCL_EXACT, &typeIndex)
			!= TCL_OK) {
		    goto end;
		}
		switch (typeIndex) {
		    case TYPE_ABORTRETRYIGNORE:
			paramCFStringRec.defaultText = CFSTR("Abort");
			paramCFStringRec.cancelText = CFSTR("Retry");
			paramCFStringRec.otherText = CFSTR("Ignore");
			paramCFStringRec.cancelButton =
				kAlertStdAlertOtherButton;
			break;
		    case TYPE_OK:
			paramCFStringRec.defaultText = CFSTR("OK");
			break;
		    case TYPE_OKCANCEL:
			paramCFStringRec.defaultText = CFSTR("OK");
			paramCFStringRec.cancelText = CFSTR("Cancel");
			break;
		    case TYPE_RETRYCANCEL:
			paramCFStringRec.defaultText = CFSTR("Retry");
			paramCFStringRec.cancelText = CFSTR("Cancel");
			break;
		    case TYPE_YESNO:
			paramCFStringRec.defaultText = CFSTR("Yes");
			paramCFStringRec.cancelText = CFSTR("No");
			break;
		    case TYPE_YESNOCANCEL:
			paramCFStringRec.defaultText = CFSTR("Yes");
			paramCFStringRec.cancelText = CFSTR("No");
			paramCFStringRec.otherText = CFSTR("Cancel");
			paramCFStringRec.cancelButton =
				kAlertStdAlertOtherButton;
			break;
		}
		break;
	}
    }

    if (haveDefaultOption) {

	/*
	 * Any '-default' option needs to know the '-type' option, which is why
	 * we do this here.
	 */

	str = Tcl_GetString(objv[indexDefaultOption + 1]);
	if (Tcl_GetIndexFromObj(interp, objv[indexDefaultOption + 1],
		movableButtonStrings, "value", TCL_EXACT, &defaultButtonIndex)
		!= TCL_OK) {
	    goto end;
	}

	/*
	 * Need to map from "ok" etc. to 1, 2, 3, right to left.
	 */

	defaultNativeButtonIndex =
	buttonIndexAndTypeToNativeButtonIndex[typeIndex][defaultButtonIndex];
	if (defaultNativeButtonIndex == 0) {
	    Tcl_SetObjResult(interp,
		    Tcl_NewStringObj("Illegal default option", -1));
	    goto end;
	}
	paramCFStringRec.defaultButton = defaultNativeButtonIndex;
	if (paramCFStringRec.cancelButton == defaultNativeButtonIndex) {
	    paramCFStringRec.cancelButton = 0;
	}
    }
    ChkErr(SetThemeCursor, kThemeArrowCursor);

    if (haveParentOption) {
	AlertHandlerUserData data;
	static EventHandlerUPP handler = NULL;
	WindowRef windowRef;
	const EventTypeSpec kEvents[] = {
	    {kEventClassCommand, kEventProcessCommand}
	};

	bzero(&data, sizeof(data));
	if (!handler) {
	    handler = NewEventHandlerUPP(AlertHandler);
	}
	windowRef = TkMacOSXDrawableWindow(Tk_WindowId(tkwin));
	if (!windowRef) {
	    goto end;
	}
	err = ChkErr(CreateStandardSheet, alertType, messageTextCF,
		finemessageTextCF, &paramCFStringRec, NULL, &dialogRef);
	if(err != noErr) {
	    goto end;
	}
	data.dialogWindow = GetDialogWindow(dialogRef);
	err = ChkErr(ShowSheetWindow, data.dialogWindow, windowRef);
	if(err != noErr) {
	    DisposeDialog(dialogRef);
	    goto end;
	}
	ChkErr(GetWindowModality, data.dialogWindow, &data.origModality,
		&data.origUnavailWindow);
	ChkErr(SetWindowModality, data.dialogWindow, kWindowModalityAppModal,
		NULL);
	ChkErr(InstallEventHandler, GetWindowEventTarget(data.dialogWindow),
		handler, GetEventTypeCount(kEvents), kEvents, &data,
		&data.handlerRef);
	TkMacOSXTrackingLoop(1);
	ChkErr(RunAppModalLoopForWindow, data.dialogWindow);
	TkMacOSXTrackingLoop(0);
	itemHit = data.buttonIndex;
    } else {
	err = ChkErr(CreateStandardAlert, alertType, messageTextCF,
		finemessageTextCF, &paramCFStringRec, &dialogRef);
	if(err != noErr) {
	    goto end;
	}
	TkMacOSXTrackingLoop(1);
	err = ChkErr(RunStandardAlert, dialogRef, NULL, &itemHit);
	TkMacOSXTrackingLoop(0);
	if (err != noErr) {
	    goto end;
	}
    }
    if (err == noErr) {
	int ind;

	/*
	 * Map 'itemHit' (1, 2, 3) to descriptive text string.
	 */

	ind = nativeButtonIndexAndTypeToButtonIndex[typeIndex][itemHit];
	Tcl_SetObjResult(interp, Tcl_NewStringObj(movableButtonStrings[ind],
		-1));
	result = TCL_OK;
    }

end:
    if (finemessageTextCF) {
	CFRelease(finemessageTextCF);
    }
    if (messageTextCF) {
	CFRelease(messageTextCF);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * AlertHandler --
 *
 *	Carbon event handler for the Standard Sheet dialog.
 *
 * Results:
 *	OSStatus if event handled or not.
 *
 * Side effects:
 *	May set userData.
 *
 *----------------------------------------------------------------------
 */

OSStatus
AlertHandler(
    EventHandlerCallRef callRef,
    EventRef eventRef,
    void *userData)
{
    AlertHandlerUserData *data = (AlertHandlerUserData *) userData;
    HICommand cmd;

    ChkErr(GetEventParameter,eventRef, kEventParamDirectObject, typeHICommand,
	    NULL, sizeof(cmd), NULL, &cmd);
    switch (cmd.commandID) {
	case kHICommandOK:
	    data->buttonIndex = 1;
	    break;
	case kHICommandCancel:
	    data->buttonIndex = 2;
	    break;
	case kHICommandOther:
	    data->buttonIndex = 3;
	    break;
    }
    if (data->buttonIndex) {
	ChkErr(QuitAppModalLoopForWindow, data->dialogWindow);
	ChkErr(RemoveEventHandler, data->handlerRef);
	ChkErr(SetWindowModality, data->dialogWindow,
		data->origModality, data->origUnavailWindow);
    }
    return eventNotHandledErr;
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXDialog.c,v 1.24 2007/04/23 21:24:33 das Exp $
d16 1
a16 1
#include "tkMacOSXInt.h"
d134 1
d137 1
a137 1
    int i, picked = 0, srcRead, dstWrote;
d141 1
a141 2
    static int inited = 0;
    static RGBColor in;
a148 11
    if (inited == 0) {
	/*
	 * 'in' stores the last color picked. The next time the color
	 * dialog pops up, the last color will remain in the dialog.
	 */

	in.red = 0xffff;
	in.green = 0xffff;
	in.blue = 0xffff;
	inited = 1;
    }
d150 4
d161 1
a161 1
	    return TCL_ERROR;
d167 1
a167 1
	    return TCL_ERROR;
d177 1
a177 1
		    return TCL_ERROR;
d179 3
a181 3
		in.red	 = colorPtr->red;
		in.green = colorPtr->green;
		in.blue	 = colorPtr->blue;
d188 1
a188 1
		    return TCL_ERROR;
a199 1
    bzero(&cpinfo, sizeof(cpinfo));
a200 3
    cpinfo.theColor.color.rgb.red   = in.red;
    cpinfo.theColor.color.rgb.green = in.green;
    cpinfo.theColor.color.rgb.blue  = in.blue;
d202 1
a202 2
    cpinfo.flags = kColorPickerDialogIsMoveable
	    | kColorPickerCanAnimatePalette;
d212 1
d214 1
a214 6
	in.red	 = cpinfo.theColor.color.rgb.red;
	in.green = cpinfo.theColor.color.rgb.green;
	in.blue	 = cpinfo.theColor.color.rgb.blue;
	picked = 1;
    }
    cmerr = CMCloseProfile(prof);
d216 8
a223 6
    if (picked != 0) {
	char result[32];

	sprintf(result, "#%02x%02x%02x", in.red >> 8, in.green >> 8,
		in.blue >> 8);
	Tcl_AppendResult(interp, result, NULL);
d225 1
d227 2
a228 1
    return TCL_OK;
d415 4
d422 1
d438 4
a441 1
		/* Currently unimplemented - what would we do here anyway? */
a478 2
    TkInitFileFilters(&ofd.fl);
    ofd.usePopup = 0;
d765 12
a776 6
	options.parentWindow = GetWindowFromPort(TkMacOSXGetDrawablePort(
		Tk_WindowId(parent)));
	if (options.parentWindow) {
	    options.modality = kWindowModalityWindowModal;
	    data.sheet = 1;
	}
d935 1
d1559 1
a1559 2
	windowRef = GetWindowFromPort(TkMacOSXGetDrawablePort(
		Tk_WindowId(tkwin)));
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d4 1
a4 1
 *        Contains the Mac implementation of the common dialog boxes.
d8 1
d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXDialog.c,v 1.20 2006/04/11 12:05:50 das Exp $
a25 6
/*
 * The following are ID's for resources that are defined in tkMacOSXResource.r
 */
#define OPEN_BOX        130
#define OPEN_POPUP      131
#define OPEN_MENU       132
d28 3
a30 3
#define SAVE_FILE        0
#define OPEN_FILE        1
#define CHOOSE_FOLDER    2
d32 2
a33 2
#define MATCHED          0
#define UNMATCHED        1
d38 1
a38 1
 * The following structure is used in the GetFileName() function. It stored
d41 2
a42 1
typedef struct _OpenFileData {
d51 9
d62 1
a62 2
 * The following structure is used in the tk_messageBox
 * implementation.
d64 1
d66 5
a70 3
    WindowRef	windowRef;
    int		buttonIndex;
} CallbackUserData;
d75 1
a75 1
static Boolean                MatchOneType(StringPtr fileNamePtr, OSType fileType,
d77 1
a77 1
static pascal Boolean   OpenFileFilterProc(AEDesc* theItem, void* info,
d80 1
a80 1
static pascal void      OpenEventProc(NavEventCallbackMessage callBackSelector,
d83 3
a85 3
static void             InitFileDialogs();
static int              NavServicesGetFile(Tcl_Interp *interp, OpenFileData *ofd,
			    AEDesc *initialDescPtr,
d87 5
a91 6
			    CFStringRef title, CFStringRef message, int multiple, int isOpen);
static int              HandleInitialDirectory (Tcl_Interp *interp,
						char *initialFile, char *initialDir,
						FSRef *dirRef,
						AEDescList *selectDescPtr,
						AEDesc *dirDescPtr);
d113 3
a115 3
 *        This procedure implements the color dialog box for the Mac
 *        platform. See the user documentation for details on what it
 *        does.
d118 1
a118 1
 *      A standard Tcl result.
d121 1
a121 1
 *      See the user documentation.
d128 4
a131 4
    ClientData clientData,        /* Main window associated with interpreter. */
    Tcl_Interp *interp,                /* Current interpreter. */
    int objc,                        /* Number of arguments. */
    Tcl_Obj *CONST objv[])        /* Argument objects. */
d133 7
a139 4
    Tk_Window parent;
    char *title;
    int i, picked, srcRead, dstWrote;
    ColorPickerInfo cpinfo;
d142 2
a143 2
    static CONST char *optionStrings[] = {
	"-initialcolor",    "-parent",            "-title",            NULL
d146 1
a146 1
	COLOR_INITIAL,            COLOR_PARENT,   COLOR_TITLE
d150 4
a153 4
	    /*
	     * 'in' stores the last color picked.  The next time the color dialog
	     * pops up, the last color will remain in the dialog.
	     */
a159 2

    parent = (Tk_Window) clientData;
a160 1
    picked = 0;
d163 2
a164 2
	    int index;
	    char *option, *value;
d171 1
a171 1
	    option = Tcl_GetStringFromObj(objv[i], NULL);
d173 1
a173 1
		    (char *) NULL);
d176 1
a176 1
	value = Tcl_GetStringFromObj(objv[i + 1], NULL);
d182 1
a182 1
		colorPtr = Tk_GetColor(interp, parent, value);
d186 1
a186 1
		in.red   = colorPtr->red;
d188 1
a188 1
		in.blue  = colorPtr->blue;
d193 1
a193 1
		parent = Tk_NameToWindow(interp, value, parent);
d206 3
a208 2

    cpinfo.theColor.profile = 0L;
d212 6
a217 11
    cpinfo.dstProfile = 0L;
    cpinfo.flags = kColorPickerCanModifyPalette
	    |  kColorPickerCanAnimatePalette;
    cpinfo.placeWhere = kDeepestColorScreen;
    cpinfo.pickerType = 0L;
    cpinfo.eventProc = NULL;
    cpinfo.colorProc = NULL;
    cpinfo.colorProcData = 0;

    /* This doesn't seem to actually set the title! */
    Tcl_UtfToExternal(NULL, NULL, title, -1, 0, NULL,
d221 7
a227 4
    if ((PickColor(&cpinfo) == noErr) && (cpinfo.newColorChosen != 0)) {
	in.red    = cpinfo.theColor.color.rgb.red;
	in.green  = cpinfo.theColor.color.rgb.green;
	in.blue   = cpinfo.theColor.color.rgb.blue;
d230 1
d248 3
a250 3
 *        This procedure implements the "open file" dialog box for the
 *        Mac platform. See the user documentation for details on what
 *        it does.
d253 1
a253 1
 *      A standard Tcl result.
d256 1
a256 1
 *        See user documentation.
d262 4
a265 4
    ClientData clientData,        /* Main window associated with interpreter. */
    Tcl_Interp *interp,                /* Current interpreter. */
    int objc,                        /* Number of arguments. */
    Tcl_Obj *CONST objv[])        /* Argument objects. */
d267 1
a267 1
    int i, result, multiple;
d269 2
a270 2
    Tk_Window parent;
    CFStringRef message, title;
d276 3
a278 5
    static CONST char *openOptionStrings[] = {
	    "-defaultextension", "-filetypes",
	    "-initialdir", "-initialfile",
	    "-message", "-multiple",
	    "-parent", "-title", NULL
d281 2
a282 4
	    OPEN_DEFAULT, OPEN_FILETYPES,
	    OPEN_INITDIR, OPEN_INITFILE,
	    OPEN_MESSAGE, OPEN_MULTIPLE,
	    OPEN_PARENT, OPEN_TITLE
a287 7

    result = TCL_ERROR;
    parent = (Tk_Window) clientData;
    multiple = false;
    title = NULL;
    message = NULL;

d289 3
a291 4

    ofd.curType                = 0;
    ofd.popupItem        = OPEN_POPUP_ITEM;
    ofd.usePopup         = 1;
d297 1
a300 1
	    result = TCL_ERROR;
d304 1
a304 1
	    string = Tcl_GetStringFromObj(objv[i], NULL);
d306 1
a306 2
		    (char *) NULL);
	    result = TCL_ERROR;
d314 2
a315 3
		if (TkGetFileFilters(interp, &ofd.fl, objv[i + 1], 0)
			!= TCL_OK) {
		    result = TCL_ERROR;
d325 1
a325 1
		initialFile = Tcl_GetStringFromObj(objv[i + 1], NULL);
d331 2
a332 2
		message = CFStringCreateWithBytes(NULL, (unsigned char*) choice, choiceLen,
			kCFStringEncodingUTF8, false);
a336 1
		    result = TCL_ERROR;
d342 2
a343 1
		parent = Tk_NameToWindow(interp, choice, parent);
a344 1
		    result = TCL_ERROR;
d350 2
a351 2
		title = CFStringCreateWithBytes(NULL, (unsigned char*) choice, choiceLen,
			kCFStringEncodingUTF8, false);
d357 1
a357 2
			       &selectDesc, &initialDesc) != TCL_OK) {
	result = TCL_ERROR;
d364 3
a366 4
    result = NavServicesGetFile(interp, &ofd, initialPtr,
	    NULL, &selectDesc, title, message, multiple, OPEN_FILE);

    end:
d368 7
a374 3
    AEDisposeDesc(&initialDesc);
    AEDisposeDesc(&selectDesc);
    if (title != NULL) {
d377 1
a377 1
    if (message != NULL) {
a379 1

d388 2
a389 2
 *        Same as Tk_GetOpenFileCmd but opens a "save file" dialog box
 *        instead
d392 1
a392 1
 *      A standard Tcl result.
d395 1
a395 1
 *        See user documentation.
d401 4
a404 4
    ClientData clientData,     /* Main window associated with interpreter. */
    Tcl_Interp *interp,        /* Current interpreter. */
    int objc,                  /* Number of arguments. */
    Tcl_Obj *CONST objv[])     /* Argument objects. */
d406 1
a406 1
    int i, result;
d408 1
a408 1
    Tk_Window parent;
d412 1
a412 1
    CFStringRef title, message;
d414 3
a416 3
    static CONST char *saveOptionStrings[] = {
	    "-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	    "-message", "-parent",        "-title",         NULL
d419 2
a420 2
	    SAVE_DEFAULT, SAVE_FILETYPES, SAVE_INITDIR, SAVE_INITFILE,
	    SAVE_MESSAGE, SAVE_PARENT, SAVE_TITLE
a426 5
    result = TCL_ERROR;
    parent = (Tk_Window) clientData;
    title = NULL;
    message = NULL;

d428 1
a428 1
	char *choice;
a429 1
	char *string;
d433 1
a433 1
	    return TCL_ERROR;
d436 1
a436 1
	    string = Tcl_GetStringFromObj(objv[i], NULL);
d438 2
a439 2
		    (char *) NULL);
	    return TCL_ERROR;
d450 2
a451 4
		if (choiceLen &&
			HandleInitialDirectory(interp, NULL, choice, &dirRef,
				NULL, &initialDesc) != TCL_OK) {
		    result = TCL_ERROR;
d458 3
a460 1
		if (choiceLen == 0) { initialFile = NULL; }
d464 2
a465 2
		message = CFStringCreateWithBytes(NULL, (unsigned char*) choice, choiceLen,
			kCFStringEncodingUTF8, false);
d469 2
a470 1
		parent = Tk_NameToWindow(interp, choice, parent);
a471 1
		    result = TCL_ERROR;
d477 2
a478 2
		title = CFStringCreateWithBytes(NULL, (unsigned char*) choice, choiceLen,
			kCFStringEncodingUTF8, false);
a484 1

d489 7
a495 6
	title, message, false, SAVE_FILE);

    end:

    AEDisposeDesc(&initialDesc);
    if (title != NULL) {
d498 1
a498 1
    if (message != NULL) {
a500 1

d509 3
a511 3
 *        This procedure implements the "tk_chooseDirectory" dialog box
 *        for the Windows platform. See the user documentation for details
 *        on what it does.
d514 1
a514 1
 *        See user documentation.
d517 1
a517 2
 *        A modal dialog window is created.  Tcl_SetServiceMode() is
 *        called to allow background events to be processed
d524 4
a527 4
    ClientData clientData;        /* Main window associated with interpreter. */
    Tcl_Interp *interp;                /* Current interpreter. */
    int objc;                        /* Number of arguments. */
    Tcl_Obj *CONST objv[];        /* Argument objects. */
d529 3
a531 4
    int i, result;
    Tk_Window parent;
    AEDesc initialDesc = {typeNull, NULL};
    AEDesc *initialPtr = NULL;
d533 1
a533 1
    CFStringRef message, title;
d535 1
a535 1
    static CONST char *chooseOptionStrings[] = {
d539 2
a540 2
	CHOOSE_INITDIR, CHOOSE_MESSAGE, CHOOSE_MUSTEXIST,
	CHOOSE_PARENT, CHOOSE_TITLE
a542 4
    if (!NavServicesAvailable()) {
	return TCL_ERROR;
    }

a545 4
    result = TCL_ERROR;
    parent = (Tk_Window) clientData;
    title = NULL;
    message = NULL;
d554 1
a554 1
	    return TCL_ERROR;
d557 1
a557 1
	    string = Tcl_GetStringFromObj(objv[i], NULL);
d559 2
a560 2
		    (char *) NULL);
	    return TCL_ERROR;
d565 2
a566 4
		if (choiceLen &&
			HandleInitialDirectory(interp, NULL, choice, &dirRef,
				NULL, &initialDesc) != TCL_OK) {
		    result = TCL_ERROR;
d572 2
a573 2
		message = CFStringCreateWithBytes(NULL, (unsigned char*) choice, choiceLen,
			kCFStringEncodingUTF8, false);
d577 2
a578 1
		parent = Tk_NameToWindow(interp, choice, parent);
a579 1
		    result = TCL_ERROR;
d585 2
a586 2
		title = CFStringCreateWithBytes(NULL, (unsigned char*) choice, choiceLen,
			kCFStringEncodingUTF8, false);
a592 1

d596 8
a603 6
    result = NavServicesGetFile(interp, &ofd, initialPtr, NULL, NULL,
	title, message, false, CHOOSE_FOLDER);

    end:
    AEDisposeDesc(&initialDesc);
    if (title != NULL) {
d606 1
a606 1
    if (message != NULL) {
a608 1

d611 16
d629 1
a629 1
HandleInitialDirectory (
d638 1
a638 1
    OSErr err;
d641 1
a641 1
    int result = TCL_OK;
d643 1
a643 1
    if (initialDir != NULL) {
d646 1
a646 1
	    return TCL_ERROR;
d648 1
a648 2

	err = FSPathMakeRef((unsigned char*) dirName,
a649 1

d651 2
a652 3
	    Tcl_AppendResult(interp, "bad directory \"",
			     initialDir, "\"", NULL);
	    result = TCL_ERROR;
a657 1
	    result = TCL_ERROR;
d660 1
a660 2

	AECreateDesc(typeFSRef, dirRef, sizeof(*dirRef), dirDescPtr);
d663 1
a663 1
    if (initialFile != NULL && selectDescPtr != NULL) {
d668 1
a668 1
	if (initialDir != NULL) {
d676 1
a676 1
	AECreateList(NULL, 0, false, selectDescPtr);
d678 2
a679 1
	err = FSPathMakeRef((unsigned char*) namePtr, &fileRef, &isDirectory);
d683 1
a683 1
	    return TCL_ERROR;
d685 3
a687 3
	AECreateDesc(typeFSRef, &fileRef, sizeof(fileRef), &fileDesc);
	AEPutDesc(selectDescPtr, 1, &fileDesc);
	AEDisposeDesc(&fileDesc);
d689 1
a689 1

d691 1
a691 1
    if (dirName != NULL) {
d696 16
d713 2
a714 2
static void
InitFileDialogs()
d720 16
d737 1
a737 1
static int
d747 2
a748 1
    int isOpen)
d750 2
a751 2
    NavReplyRecord theReply;
    NavDialogCreationOptions diagOptions;
d754 1
a754 1
    OSErr err;
d756 1
a756 1
    int result;
d758 7
a764 8
    err = NavGetDefaultDialogCreationOptions(&diagOptions);
    if (err!=noErr) {
	return TCL_ERROR;
    }
    diagOptions.location.h = -1;
    diagOptions.location.v = -1;
    diagOptions.optionFlags = kNavDontAutoTranslate
	+ kNavDontAddTranslateItems;
d766 11
a776 1
	diagOptions.optionFlags += kNavAllowMultipleFiles;
a777 1
    diagOptions.modality = kWindowModalityAppModal;
d779 5
a783 1
    if (ofdPtr != NULL && ofdPtr->usePopup) {
d791 1
a791 2

    if (ofdPtr != NULL && ofdPtr->usePopup) {
d796 1
a796 1
	menuItemNames = (CFStringRef *)ckalloc(ofdPtr->fl.numFilters
d804 1
a804 1
	diagOptions.popupExtension = CFArrayCreate(NULL,
d807 2
a808 2
	diagOptions.optionFlags += kNavNoTypePopup;
	diagOptions.popupExtension = NULL;
d810 3
a812 11

    /*
     * This is required to allow App packages to be selectable in the
     * file dialogs...
     */

    diagOptions.optionFlags += kNavSupportPackages;

    diagOptions.clientName = CFStringCreateWithCString(NULL, "Wish", kCFStringEncodingUTF8);
    diagOptions.message = message;
    diagOptions.windowTitle = title;
d814 1
a814 1
	diagOptions.saveFileName = CFStringCreateWithCString(NULL,
d817 1
a817 1
	diagOptions.saveFileName = NULL;
a818 10

    diagOptions.actionButtonLabel = NULL;
    diagOptions.cancelButtonLabel = NULL;
    diagOptions.preferenceKey = 0;

    /*
     * Now process the selection list.  We have to use the popupExtension
     * to fill the menu.
     */

d820 3
a822 13
	err = NavCreateGetFileDialog(&diagOptions,
	    NULL,
	    openFileEventUPP,
	    NULL,
	    openFileFilterUPP,
	    ofdPtr,
	    &dialogRef);
	if (err != noErr) {
#ifdef TK_MAC_DEBUG
	    fprintf(stderr,"NavCreateGetFileDialog failed, %d\n", err);
#endif
	    dialogRef = NULL;
	}
d824 2
a825 8
	err = NavCreatePutFileDialog(&diagOptions, 'TEXT', 'WIsH',
		openFileEventUPP, NULL, &dialogRef);
	if (err!=noErr){
#ifdef TK_MAC_DEBUG
	    fprintf(stderr,"NavCreatePutFileDialog failed, %d\n", err);
#endif
	    dialogRef = NULL;
	}
d827 2
a828 8
	err = NavCreateChooseFolderDialog(&diagOptions, openFileEventUPP,
		openFileFilterUPP, NULL, &dialogRef);
	if (err!=noErr){
#ifdef TK_MAC_DEBUG
	    fprintf(stderr,"NavCreateChooseFolderDialog failed, %d\n", err);
#endif
	    dialogRef = NULL;
	}
d830 8
a837 4

    if (dialogRef) {
	if (initialDescPtr != NULL) {
	    NavCustomControl (dialogRef, kNavCtlSetLocation, initialDescPtr);
d839 10
a848 14
	if ((selectDescPtr != NULL)
		&& (selectDescPtr->descriptorType != typeNull)) {
	    NavCustomControl(dialogRef, kNavCtlSetSelection, selectDescPtr);
	}

	if ((err = NavDialogRun(dialogRef)) != noErr){
#ifdef TK_MAC_DEBUG
	    fprintf(stderr,"NavDialogRun failed, %d\n", err);
#endif
	} else {
	    if ((err = NavDialogGetReply(dialogRef, &theReply)) != noErr) {
#ifdef TK_MAC_DEBUG
		fprintf(stderr,"NavGetReply failed, %d\n", err);
#endif
d850 1
d852 1
d857 1
a857 1
     * item, not a list.  So only build a list if multiple is true...
d869 1
a869 1
    if (theReply.validRecord && err == noErr) {
d872 4
a875 4
	FSRef  fsRef;
	char   pathPtr[1024];
	int    pathValid = 0;
	err = AECountItems(&theReply.selection, &count);
d878 1
d880 2
a881 3
		err = AEGetNthDesc(&theReply.selection,
		    i, typeFSRef, NULL, &resultDesc);
		pathValid = 0;
d883 8
a890 11
		    if ((err = AEGetDescData(&resultDesc, &fsRef, sizeof(fsRef)))
			    != noErr) {
#ifdef TK_MAC_DEBUG
			fprintf(stderr,"AEGetDescData failed %d\n", err);
#endif
		    } else {
			if ((err = FSRefMakePath(&fsRef, (unsigned char*) pathPtr, 1024))) {
#ifdef TK_MAC_DEBUG
			    fprintf(stderr,"FSRefMakePath failed, %d\n", err);
#endif
			} else {
d892 8
a899 6
				CFStringRef saveNameRef;
				char saveName [1024];
				if ((saveNameRef = NavDialogGetSaveFileName(dialogRef))) {
				    if (CFStringGetCString(saveNameRef, saveName,
					    1024, kCFStringEncodingUTF8)) {
					if (strlen(pathPtr) + strlen(saveName) < 1023) {
d904 2
a905 3
#ifdef TK_MAC_DEBUG
					    fprintf(stderr, "Path name too long\n");
#endif
d908 2
a909 3
#ifdef TK_MAC_DEBUG
					fprintf(stderr, "CFStringGetCString failed\n");
#endif
d912 2
a913 3
#ifdef TK_MAC_DEBUG
				    fprintf(stderr, "NavDialogGetSaveFileName failed\n");
#endif
d928 1
a928 1
		    AEDisposeDesc(&resultDesc);
d931 3
a933 4
	 }
	 err = NavDisposeReply(&theReply);
	 Tcl_SetObjResult(interp, theResult);
	 result = TCL_OK;
a935 2
    } else {
	result = TCL_ERROR;
d939 1
a939 2
     * Clean up any allocated strings
     * dispose of things in reverse order of creation
d942 2
a943 2
    if (diagOptions.windowTitle) {
	CFRelease(diagOptions.windowTitle);
d945 2
a946 2
    if (diagOptions.saveFileName) {
	CFRelease(diagOptions.saveFileName);
d948 2
a949 2
    if (diagOptions.message) {
	CFRelease(diagOptions.message);
d951 2
a952 2
    if (diagOptions.clientName) {
	CFRelease(diagOptions.clientName);
a953 4
    /*
     * dispose of the CFArray diagOptions.popupExtension
     */

d956 1
a956 1
	for (i = 0;i < ofdPtr->fl.numFilters; i++) {
d961 2
a962 2
    if (diagOptions.popupExtension != NULL) {
	CFRelease(diagOptions.popupExtension);
d964 18
d983 43
a1025 1
    return result;
d1027 16
d1044 1
a1044 1
static pascal Boolean
d1050 2
a1051 1
    OpenFileData *ofdPtr = (OpenFileData *) callBackUD;
d1053 2
a1054 6
    if (!ofdPtr || !ofdPtr->usePopup) {
	return true;
    } else {
	if (ofdPtr->fl.numFilters == 0) {
	    return true;
	} else {
d1056 1
a1056 1
		    || (theItem->descriptorType = typeFSRef)) {
a1058 1
		int result;
d1073 1
a1073 1
			fileNamePtr = (((FSSpec *) *theItem->dataHandle)->name);
d1083 2
a1084 2
			err = FSGetCatalogInfo (theRef, kFSCatInfoNone, NULL,
				&uniFileName, NULL, NULL);
d1089 3
a1091 3
				    uniFileName.length,
				    &fileNameDString);
			    fileNamePtr = (unsigned char*) Tcl_DStringValue(&fileNameDString);
d1106 1
a1106 1
			    result = false;
a1124 1

a1125 3
		    return (result == MATCHED);
		} else {
		    return true;
a1128 27

	return true;
    }
}

pascal void
OpenEventProc(
    NavEventCallbackMessage callBackSelector,
    NavCBRecPtr callBackParams,
    NavCallBackUserData callBackUD)
{
    NavMenuItemSpec *chosenItem;
    OpenFileData *ofd = (OpenFileData *) callBackUD;
    static SInt32 otherEvent = ~(kNavCBCustomize|kNavCBStart|kNavCBTerminate
	    |kNavCBNewLocation|kNavCBShowDesktop|kNavCBSelectEntry|kNavCBAccept
	    |kNavCBCancel|kNavCBAdjustPreview);

    if (callBackSelector ==  kNavCBPopupMenuSelect) {
	chosenItem = (NavMenuItemSpec *) callBackParams->eventData.eventDataParms.param;
	ofd->curType = chosenItem->menuType;
    } else if (callBackSelector == kNavCBAdjustRect
	    || (callBackSelector & otherEvent) != 0) {
	while (Tcl_DoOneEvent(TCL_IDLE_EVENTS
		| TCL_DONT_WAIT
		| TCL_WINDOW_EVENTS)) {
	    /* Empty Body */
	}
d1130 1
d1138 1
a1138 1
 *        Match a file with one file type in the list of file types.
d1141 2
a1142 2
 *        Returns MATCHED if the file matches with the file type; returns
 *        UNMATCHED otherwise.
d1145 1
a1145 1
 *        None
d1150 1
a1150 1
static Boolean
d1152 6
a1157 5
    StringPtr fileNamePtr,        /* Name of the file */
    OSType    fileType,         /* Type of the file, 0 means there was no specified type.  */
    OpenFileData * ofdPtr,        /* Information about this file dialog */
    FileFilter * filterPtr)        /* Match the file described by pb against
				 * this filter */
d1159 1
a1159 1
    FileFilterClause * clausePtr;
d1180 1
a1180 1
	int macMatched  = 0;
d1182 2
a1183 2
	GlobPattern * globPtr;
	MacFileType * mfPtr;
d1221 1
a1221 1
	  glob_unmatched:
d1224 1
a1224 1
	  glob_matched:
d1238 2
a1239 2
	 * file type.  But folks with Tcl code on Classic MacOS pretty
	 * much assume that a generic file will have type TEXT.  So
d1242 1
a1242 1
	 * with no fileType.  To avoid that, we pass the macMatch side
d1253 1
a1253 1

d1259 2
a1260 2
 *        Displays the default Tk About box.  This code uses Macintosh
 *        resources to define the content of the About Box.
d1263 1
a1263 1
 *        None.
d1266 1
a1266 1
 *        None.
d1272 1
a1272 1
TkAboutDlg()
d1278 1
a1278 2
    aboutDlog = GetNewDialog(128, NULL, (void *) (-1));

a1281 1

d1284 1
a1284 1

d1288 1
a1289 2
    aboutDlog = NULL;

a1290 2

    return;
d1292 1
a1292 1

d1298 1
a1298 1
 *		Implements the tk_messageBox in native Mac OS X style.
d1301 1
a1301 1
 *		A standard Tcl result.
d1304 1
a1304 1
 *		none
d1311 4
a1314 4
    ClientData  clientData,	    /* Main window associated with interpreter. */
    Tcl_Interp  *interp,		/* Current interpreter. */
    int         objc,		    /* Number of arguments. */
    Tcl_Obj     *CONST objv[])	/* Argument objects. */
d1316 1
a1316 1
    Tk_Window   	    tkwin = (Tk_Window) clientData;
d1318 14
a1331 22
    AlertType               alertType;
    DialogRef				dialogRef;
    CFStringRef 			messageTextCF = NULL;
    CFStringRef 			finemessageTextCF = NULL;
    OSErr                   osError;
    SInt16                  itemHit;
    Boolean                 haveDefaultOption = false;
    Boolean                 haveParentOption = false;
    char                    *str;
    int                     index;
    int                     defaultButtonIndex;
    int                     defaultNativeButtonIndex;    /* 1, 2, 3: right to left. */
    int                     typeIndex;
    int                     i;
    int                     indexDefaultOption = 0;
    int                     result = TCL_OK;

    static CONST char *movableAlertStrings[] = {
	"-default", "-detail", "-icon",
	"-message", "-parent",
	"-title", "-type",
	(char *)NULL
d1333 3
a1335 5
    static CONST char *movableTypeStrings[] = {
	"abortretryignore", "ok",
	"okcancel", "retrycancel",
	"yesno", "yesnocancel",
	(char *)NULL
d1337 2
a1338 4
    static CONST char *movableButtonStrings[] = {
	"abort", "retry", "ignore",
	"ok", "cancel", "yes", "no",
	(char *)NULL
d1340 2
a1341 3
    static CONST char *movableIconStrings[] = {
	"error", "info", "question", "warning",
	(char *)NULL
d1344 1
a1344 2
	ALERT_DEFAULT, ALERT_DETAIL, ALERT_ICON,
	ALERT_MESSAGE, ALERT_PARENT,
d1348 1
a1348 2
	TYPE_ABORTRETRYIGNORE, TYPE_OK,
	TYPE_OKCANCEL, TYPE_RETRYCANCEL,
d1352 2
a1353 2
	TEXT_ABORT, TEXT_RETRY, TEXT_IGNORE,
	TEXT_OK, TEXT_CANCEL, TEXT_YES, TEXT_NO
d1360 2
a1361 2
     * Need to map from 'movableButtonStrings' and its corresponding integer index,
     * to the native button index, which is 1, 2, 3, from right to left.
d1365 8
a1372 8
    short   buttonIndexAndTypeToNativeButtonIndex[][7] = {
	/*  abort retry ignore ok   cancel yes   no    */
	{1,    2,    3,    0,    0,    0,    0},        /*  abortretryignore */
	{0,    0,    0,    1,    0,    0,    0},        /*  ok */
	{0,    0,    0,    1,    2,    0,    0},        /*  okcancel */
	{0,    1,    0,    0,    2,    0,    0},        /*  retrycancel */
	{0,    0,    0,    0,    0,    1,    2},        /*  yesno */
	{0,    0,    0,    0,    3,    1,    2},        /*  yesnocancel */
d1380 7
a1386 7
    short   nativeButtonIndexAndTypeToButtonIndex[][4] = {
	{-1, 0, 1, 2},        /*  abortretryignore */
	{-1, 3, 0, 0},        /*  ok */
	{-1, 3, 4, 0},        /*  okcancel */
	{-1, 1, 4, 0},        /*  retrycancel */
	{-1, 5, 6, 0},        /*  yesno */
	{-1, 5, 6, 4},        /*  yesnocancel */
d1392 2
a1393 1
    GetStandardAlertDefaultParams(&paramCFStringRec, kStdCFStringAlertVersionOne);
d1400 2
a1401 2
	int     iconIndex;
	char    *string;
d1404 1
a1404 2
				TCL_EXACT, &index) != TCL_OK) {
	    result = TCL_ERROR;
d1408 1
a1408 1
	    string = Tcl_GetStringFromObj(objv[i], NULL);
d1410 1
a1410 2
			     (char *) NULL);
	    result = TCL_ERROR;
a1414 1

d1416 7
a1422 9

	    /*
	     * Need to postpone processing of this option until we are
	     * sure to know the '-type' as well.
	     */

	    haveDefaultOption = true;
	    indexDefaultOption = i;
	    break;
d1425 4
a1428 3
	    str = Tcl_GetStringFromObj(objv[i + 1], NULL);
	    finemessageTextCF = CFStringCreateWithCString(NULL, str, kCFStringEncodingUTF8);
	    break;
d1431 19
a1449 18
	    /*  not sure about UTF translation here... */
	    if (Tcl_GetIndexFromObj(interp, objv[i + 1], movableIconStrings,
				    "value", TCL_EXACT, &iconIndex) != TCL_OK) {
		result = TCL_ERROR;
		goto end;
	    }
	    switch (iconIndex) {
		case ICON_ERROR:
		alertType = kAlertStopAlert;
		break;
		case ICON_INFO:
		alertType = kAlertNoteAlert;
		break;
		case ICON_QUESTION:
		alertType = kAlertCautionAlert;
		break;
		case ICON_WARNING:
		alertType = kAlertCautionAlert;
a1450 2
	    }
	    break;
d1453 4
a1456 3
	    str = Tcl_GetStringFromObj(objv[i + 1], NULL);
	    messageTextCF = CFStringCreateWithCString(NULL, str, kCFStringEncodingUTF8);
	    break;
d1459 10
a1468 8
	    str = Tcl_GetStringFromObj(objv[i + 1], NULL);
	    tkwin = Tk_NameToWindow(interp, str, tkwin);
	    if (tkwin == NULL) {
		result = TCL_ERROR;
		goto end;
	    }
	    haveParentOption = true;
	    break;
d1471 1
a1471 1
	    break;
d1474 36
a1509 33
	    /*  not sure about UTF translation here... */
	    if (Tcl_GetIndexFromObj(interp, objv[i + 1], movableTypeStrings,
				    "value", TCL_EXACT, &typeIndex) != TCL_OK) {
		result = TCL_ERROR;
		goto end;
	    }
	    switch (typeIndex) {
		case TYPE_ABORTRETRYIGNORE:
		paramCFStringRec.defaultText = CFSTR("Abort");
		paramCFStringRec.cancelText = CFSTR("Retry");
		paramCFStringRec.otherText = CFSTR("Ignore");
		paramCFStringRec.cancelButton = kAlertStdAlertOtherButton;
		break;
		case TYPE_OK:
		paramCFStringRec.defaultText = CFSTR("OK");
		break;
		case TYPE_OKCANCEL:
		paramCFStringRec.defaultText = CFSTR("OK");
		paramCFStringRec.cancelText = CFSTR("Cancel");
		break;
		case TYPE_RETRYCANCEL:
		paramCFStringRec.defaultText = CFSTR("Retry");
		paramCFStringRec.cancelText = CFSTR("Cancel");
		break;
		case TYPE_YESNO:
		paramCFStringRec.defaultText = CFSTR("Yes");
		paramCFStringRec.cancelText = CFSTR("No");
		break;
		case TYPE_YESNOCANCEL:
		paramCFStringRec.defaultText = CFSTR("Yes");
		paramCFStringRec.cancelText = CFSTR("No");
		paramCFStringRec.otherText = CFSTR("Cancel");
		paramCFStringRec.cancelButton = kAlertStdAlertOtherButton;
a1510 2
	    }
	    break;
d1521 1
a1521 1
	str = Tcl_GetStringFromObj(objv[indexDefaultOption + 1], NULL);
d1523 2
a1524 3
				movableButtonStrings, "value", TCL_EXACT,
				&defaultButtonIndex) != TCL_OK) {
	    result = TCL_ERROR;
d1528 3
a1530 1
	/* Need to map from "ok" etc. to 1, 2, 3, right to left. */
d1536 1
a1536 2
			     Tcl_NewStringObj("Illegal default option", -1));
	    result = TCL_ERROR;
d1540 3
d1544 1
a1544 1
    SetThemeCursor(kThemeArrowCursor);
d1547 3
a1549 5
	TkWindow 			*winPtr;
	WindowRef			windowRef;
	EventTargetRef 		notifyTarget;
	EventHandlerUPP		handler;
	CallbackUserData	data;
d1554 7
a1560 14
	winPtr = (TkWindow *) tkwin;

	/*
	 * Create the underlying Mac window for this Tk window.
	 */

	windowRef = GetWindowFromPort(
			TkMacOSXGetDrawablePort(Tk_WindowId(tkwin)));
	notifyTarget = GetWindowEventTarget(windowRef);
	osError = CreateStandardSheet(alertType, messageTextCF,
				      finemessageTextCF, &paramCFStringRec,
				      notifyTarget, &dialogRef);
	if(osError != noErr) {
	    result = TCL_ERROR;
d1563 3
a1565 9
	data.windowRef = windowRef;
	data.buttonIndex = 1;
	handler = NewEventHandlerUPP(AlertHandler);
	InstallEventHandler(notifyTarget, handler,
		GetEventTypeCount(kEvents),
		kEvents, &data, NULL);
	osError = ShowSheetWindow(GetDialogWindow(dialogRef), windowRef);
	if(osError != noErr) {
	    result = TCL_ERROR;
d1568 4
a1571 3
	osError = RunAppModalLoopForWindow(windowRef);
	if (osError != noErr) {
	    result = TCL_ERROR;
d1574 10
a1584 1
	DisposeEventHandlerUPP(handler);
d1586 3
a1588 4
	osError = CreateStandardAlert(alertType, messageTextCF,
				      finemessageTextCF, &paramCFStringRec, &dialogRef);
	if(osError != noErr) {
	    result = TCL_ERROR;
d1591 4
a1594 3
	osError = RunStandardAlert(dialogRef, NULL, &itemHit);
	if (osError != noErr) {
	    result = TCL_ERROR;
d1598 2
a1599 2
    if(osError == noErr) {
	int     ind;
d1606 3
a1608 4
	Tcl_SetObjResult(interp,
			 Tcl_NewStringObj(movableButtonStrings[ind], -1));
    } else {
	result = TCL_ERROR;
d1611 2
a1612 2
    end:
    if (finemessageTextCF != NULL) {
d1615 1
a1615 1
    if (messageTextCF != NULL) {
d1620 1
a1620 1

d1637 5
a1641 2
static OSStatus
AlertHandler(EventHandlerCallRef callRef, EventRef eventRef, void *userData)
d1643 2
a1644 3
    OSStatus		result = eventNotHandledErr;
    HICommand		cmd;
    CallbackUserData	*dataPtr = (CallbackUserData *) userData;
d1646 2
a1647 2
    GetEventParameter(eventRef, kEventParamDirectObject, typeHICommand,
		      NULL, sizeof(cmd), NULL, &cmd);
d1650 2
a1651 3
	dataPtr->buttonIndex = 1;
	result = noErr;
	break;
d1653 2
a1654 3
	dataPtr->buttonIndex = 2;
	result = noErr;
	break;
d1656 2
a1657 3
	dataPtr->buttonIndex = 3;
	result = noErr;
	break;
d1659 5
a1663 2
    if (result == noErr) {
	result = QuitAppModalLoopForWindow(dataPtr->windowRef);
d1665 1
a1665 1
    return result;
@

