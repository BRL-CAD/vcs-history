head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.49;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.45;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.54;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXBitmap.c --
 *
 *	This file handles the implementation of native bitmaps.
 *
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXBitmap.c,v 1.7 2007/04/23 21:24:32 das Exp $
 */

#include "tkMacOSXInt.h"

/*
 * Depending on the resource type there are different ways to
 * draw native icons.
 */
#define TYPE1	0		/* Family icon suite. */
#define TYPE2	1		/* ICON resource. */
#define TYPE3	2		/* cicn resource. */

/*
 * This data structure describes the id and type of a given icon.
 * It is used as the source for native icons.
 */
typedef struct {
    int id;			/* Resource Id for Icon. */
    long int type;		/* Type of icon. */
} NativeIcon;

/*
 * This structure holds information about native bitmaps.
 */

typedef struct {
    const char *name;		/* Name of icon. */
    long int type;		/* Type of icon. */
    int id;			/* Id of icon. */
    int size;			/* Size of icon. */
} BuiltInIcon;

/*
 * This array mapps a string name to the supported builtin icons
 * on the Macintosh.
 */

static BuiltInIcon builtInIcons[] = {
    {"document",	TYPE1,	kGenericDocumentIconResource,		32},
    {"stationery",	TYPE1,	kGenericStationeryIconResource,		32},
    {"edition",		TYPE1,	kGenericEditionFileIconResource,	32},
    {"application",	TYPE1,	kGenericApplicationIconResource,	32},
    {"accessory",	TYPE1,	kGenericDeskAccessoryIconResource,	32},
    {"folder",		TYPE1,	kGenericFolderIconResource,		32},
    {"pfolder",		TYPE1,	kPrivateFolderIconResource,		32},
    {"trash",		TYPE1,	kTrashIconResource,			32},
    {"floppy",		TYPE1,	kFloppyIconResource,			32},
    {"ramdisk",		TYPE1,	kGenericRAMDiskIconResource,		32},
    {"cdrom",		TYPE1,	kGenericCDROMIconResource,		32},
    {"preferences",	TYPE1,	kGenericPreferencesIconResource,	32},
    {"querydoc",	TYPE1,	kGenericQueryDocumentIconResource,	32},
    {"stop",		TYPE2,	kStopIcon,				32},
    {"note",		TYPE2,	kNoteIcon,				32},
    {"caution",		TYPE2,	kCautionIcon,				32},
    {NULL,		0,	0,					0}
};

/*
 *----------------------------------------------------------------------
 *
 * TkpDefineNativeBitmaps --
 *
 *	Add native bitmaps.
 *
 * Results:
 *	A standard Tcl result. If an error occurs then TCL_ERROR is
 *	returned and a message is left in the interp's result.
 *
 * Side effects:
 *	"Name" is entered into the bitmap table and may be used from
 *	here on to refer to the given bitmap.
 *
 *----------------------------------------------------------------------
 */

void
TkpDefineNativeBitmaps(void)
{
    Tcl_HashTable *tablePtr = TkGetBitmapPredefTable();
    BuiltInIcon *builtInPtr;

    for (builtInPtr = builtInIcons; builtInPtr->name != NULL; builtInPtr++) {
	Tcl_HashEntry *predefHashPtr;
	const char * name;
	int isNew;

	name = Tk_GetUid(builtInPtr->name);
	predefHashPtr = Tcl_CreateHashEntry(tablePtr, name, &isNew);
	if (isNew) {
	    TkPredefBitmap *predefPtr = (TkPredefBitmap *)
		    ckalloc(sizeof(TkPredefBitmap));
	    NativeIcon *nativeIconPtr = (NativeIcon *)
		    ckalloc(sizeof(NativeIcon));

	    nativeIconPtr->id = builtInPtr->id;
	    nativeIconPtr->type = builtInPtr->type;
	    predefPtr->source = (char *) nativeIconPtr;
	    predefPtr->width = builtInPtr->size;
	    predefPtr->height = builtInPtr->size;
	    predefPtr->native = 1;
	    Tcl_SetHashValue(predefHashPtr, predefPtr);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpCreateNativeBitmap --
 *
 *	Add native bitmaps.
 *
 * Results:
 *	A standard Tcl result. If an error occurs then TCL_ERROR is
 *	returned and a message is left in the interp's result.
 *
 * Side effects:
 *	"Name" is entered into the bitmap table and may be used from
 *	here on to refer to the given bitmap.
 *
 *----------------------------------------------------------------------
 */

Pixmap
TkpCreateNativeBitmap(
    Display *display,
    CONST char *source)		/* Info about the icon to build. */
{
    Pixmap pix;
    Rect destRect;
    CGrafPtr savePort;
    Boolean portChanged;
    const NativeIcon *nativeIconPtr;

    pix = Tk_GetPixmap(display, None, 32, 32, 0);
    portChanged = QDSwapPort(TkMacOSXGetDrawablePort(pix), &savePort);

    nativeIconPtr = (const NativeIcon *) source;
    SetRect(&destRect, 0, 0, 32, 32);
    if (nativeIconPtr->type == TYPE1) {
	RGBColor white = {0xFFFF, 0xFFFF, 0xFFFF};

	RGBForeColor(&white);
	PaintRect(&destRect);
	PlotIconID(&destRect, atAbsoluteCenter, ttNone, nativeIconPtr->id);
    } else if (nativeIconPtr->type == TYPE2) {
	Handle icon = GetIcon(nativeIconPtr->id);

	if (icon != NULL) {
	    RGBColor black = {0, 0, 0};

	    RGBForeColor(&black);
	    PlotIcon(&destRect, icon);
	    ReleaseResource(icon);
	}
    }

    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
    return pix;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpGetNativeAppBitmap --
 *
 *	Add native bitmaps.
 *
 * Results:
 *	A standard Tcl result. If an error occurs then TCL_ERROR is
 *	returned and a message is left in the interp's result.
 *
 * Side effects:
 *	"Name" is entered into the bitmap table and may be used from
 *	here on to refer to the given bitmap.
 *
 *----------------------------------------------------------------------
 */

Pixmap
TkpGetNativeAppBitmap(
    Display *display,		/* The display. */
    CONST char *name,		/* The name of the bitmap. */
    int *width,			/* The width & height of the bitmap. */
    int *height)
{
    Pixmap pix;
    CGrafPtr savePort;
    Boolean portChanged;
    Rect destRect;
    Handle resource;
    int type = -1, destWrote;
    Str255 nativeName;
    Tcl_Encoding encoding;

    /*
     * macRoman is the encoding that the resource fork uses.
     */

    encoding = Tcl_GetEncoding(NULL, "macRoman");
    Tcl_UtfToExternal(NULL, encoding, name, strlen(name), 0, NULL,
	    (char *) &nativeName[1], 255, NULL, &destWrote, NULL);
    nativeName[0] = destWrote;
    Tcl_FreeEncoding(encoding);

    resource = GetNamedResource('cicn', nativeName);
    if (resource != NULL) {
	type = TYPE3;
    } else {
	resource = GetNamedResource('ICON', nativeName);
	if (resource != NULL) {
	    type = TYPE2;
	}
    }

    if (resource == NULL) {
	return (Pixmap) NULL;
    }

    pix = Tk_GetPixmap(display, None, 32, 32, 0);
    portChanged = QDSwapPort(TkMacOSXGetDrawablePort(pix), &savePort);

    SetRect(&destRect, 0, 0, 32, 32);
    if (type == TYPE2) {
	RGBColor black = {0, 0, 0};

	RGBForeColor(&black);
	PlotIcon(&destRect, resource);
	ReleaseResource(resource);
    } else if (type == TYPE3) {
	RGBColor white = {0xFFFF, 0xFFFF, 0xFFFF};
	short id;
	ResType theType;
	Str255 dummy;

	/*
	 * We need to first paint the background white. Also, for
	 * some reason we *must* use GetCIcon instead of GetNamedResource
	 * for PlotCIcon to work - so we use GetResInfo to get the id.
	 */

	RGBForeColor(&white);
	PaintRect(&destRect);
	GetResInfo(resource, &id, &theType, dummy);
	ReleaseResource(resource);
	resource = (Handle) GetCIcon(id);
	PlotCIcon(&destRect, (CIconHandle) resource);
	DisposeCIcon((CIconHandle) resource);
    }

    *width = 32;
    *height = 32;
    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
    return pix;
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d1 1
a1 1
/* 
d4 1
a4 1
 *        This file handles the implementation of native bitmaps.
d8 1
d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXBitmap.c,v 1.4 2006/03/24 14:58:01 das Exp $
d22 3
a24 3
#define TYPE1        0        /* Family icon suite. */
#define TYPE2        1        /* ICON resource. */
#define TYPE3        2        /* cicn resource. */
d31 2
a32 2
    int id;                /* Resource Id for Icon. */
    long int type;        /* Type of icon. */
d40 4
a43 4
    char *name;                        /* Name of icon. */
    long int type;                /* Type of icon. */
    int id;                        /* Id of icon. */
    int size;                        /* Size of icon. */
d52 17
a68 17
    {"document",        TYPE1,        kGenericDocumentIconResource,           32},
    {"stationery",      TYPE1,        kGenericStationeryIconResource,         32},
    {"edition",         TYPE1,        kGenericEditionFileIconResource,        32},
    {"application",     TYPE1,        kGenericApplicationIconResource,        32},
    {"accessory",       TYPE1,        kGenericDeskAccessoryIconResource,      32},
    {"folder",          TYPE1,        kGenericFolderIconResource,             32},
    {"pfolder",         TYPE1,        kPrivateFolderIconResource,             32},
    {"trash",           TYPE1,        kTrashIconResource,                     32},
    {"floppy",          TYPE1,        kFloppyIconResource,                    32},
    {"ramdisk",         TYPE1,        kGenericRAMDiskIconResource,            32},
    {"cdrom",           TYPE1,        kGenericCDROMIconResource,              32},
    {"preferences",     TYPE1,        kGenericPreferencesIconResource,        32},
    {"querydoc",        TYPE1,        kGenericQueryDocumentIconResource,      32},
    {"stop",            TYPE2,        kStopIcon,                              32},
    {"note",            TYPE2,        kNoteIcon,                              32},
    {"caution",         TYPE2,        kCautionIcon,                           32},
    {(char *) NULL,        0,        0,                                        0}
d76 1
a76 1
 *        Add native bitmaps.
d79 2
a80 2
 *        A standard Tcl result.  If an error occurs then TCL_ERROR is
 *        returned and a message is left in the interp's result.
d83 2
a84 2
 *        "Name" is entered into the bitmap table and may be used from
 *        here on to refer to the given bitmap.
d90 1
a90 1
TkpDefineNativeBitmaps()
d92 1
a92 4
    int new;
    Tcl_HashEntry *predefHashPtr;
    TkPredefBitmap *predefPtr;
    CONST char * name;
d94 1
a94 3
    NativeIcon *nativeIconPtr;
    Tcl_HashTable *tablePtr;
    
d96 20
a115 15
        name = Tk_GetUid(builtInPtr->name);
        tablePtr = TkGetBitmapPredefTable();
        predefHashPtr = Tcl_CreateHashEntry(tablePtr, name, &new);
        if (!new) {
            continue;
        }
        predefPtr = (TkPredefBitmap *) ckalloc(sizeof(TkPredefBitmap));
        nativeIconPtr = (NativeIcon *) ckalloc(sizeof(NativeIcon));
        nativeIconPtr->id = builtInPtr->id;
        nativeIconPtr->type = builtInPtr->type;
        predefPtr->source = (char *) nativeIconPtr;
        predefPtr->width = builtInPtr->size;
        predefPtr->height = builtInPtr->size;
        predefPtr->native = 1;
        Tcl_SetHashValue(predefHashPtr, predefPtr);
d124 1
a124 1
 *        Add native bitmaps.
d127 2
a128 2
 *        A standard Tcl result.  If an error occurs then TCL_ERROR is
 *        returned and a message is left in the interp's result.
d131 2
a132 2
 *        "Name" is entered into the bitmap table and may be used from
 *        here on to refer to the given bitmap.
d140 1
a140 1
    CONST char * source)                /* Info about the icon to build. */
a142 1
    GWorldPtr destPort;
d144 4
a147 5
    Handle icon;
    CGrafPtr saveWorld;
    GDHandle saveDevice;
    NativeIcon *nativeIconPtr;
    
d149 1
a149 4
    destPort = TkMacOSXGetDrawablePort(pix);

    GetGWorld(&saveWorld, &saveDevice);
    SetGWorld(destPort, NULL);
d151 1
a151 1
    nativeIconPtr = (NativeIcon *) source;
d154 1
a154 1
        RGBColor white = {0xFFFF, 0xFFFF, 0xFFFF};
d156 3
a158 3
        RGBForeColor(&white);
        PaintRect(&destRect);
        PlotIconID(&destRect, atAbsoluteCenter, ttNone, nativeIconPtr->id);
d160 9
a168 8
        icon = GetIcon(nativeIconPtr->id);
        if (icon != NULL) {
            RGBColor black = {0, 0, 0};
        
            RGBForeColor(&black);
            PlotIcon(&destRect, icon);
            ReleaseResource(icon);
        }
d171 3
a173 1
    SetGWorld(saveWorld, saveDevice);
d182 1
a182 1
 *        Add native bitmaps.
d185 2
a186 2
 *        A standard Tcl result.  If an error occurs then TCL_ERROR is
 *        returned and a message is left in the interp's result.
d189 2
a190 2
 *        "Name" is entered into the bitmap table and may be used from
 *        here on to refer to the given bitmap.
d197 3
a199 3
    Display *display,        /* The display. */
    CONST char *name,        /* The name of the bitmap. */
    int *width,                /* The width & height of the bitmap. */
d203 2
a204 3
    CGrafPtr saveWorld;
    GDHandle saveDevice;
    GWorldPtr destPort;
d209 2
a210 1
    
d215 3
a217 4
    Tcl_UtfToExternal(NULL, Tcl_GetEncoding(NULL, "macRoman"), name,
            strlen(name), 0, NULL, 
            (char *) &nativeName[1],
            255, NULL, &destWrote, NULL); /* Internalize native */
d219 1
d223 1
a223 1
        type = TYPE3;
d225 4
a228 4
        resource = GetNamedResource('ICON', nativeName);
        if (resource != NULL) {
            type = TYPE2;
        }
d230 1
a230 1
    
d232 1
a232 1
        return (Pixmap) NULL;
d234 1
a234 1
    
d236 1
a236 1
    destPort = TkMacOSXGetDrawablePort(pix);
a237 3
    GetGWorld(&saveWorld, &saveDevice);
    SetGWorld(destPort, NULL);
    
d240 5
a244 5
        RGBColor black = {0, 0, 0};
        
        RGBForeColor(&black);
        PlotIcon(&destRect, resource);
        ReleaseResource(resource);
d246 18
a263 17
        RGBColor white = {0xFFFF, 0xFFFF, 0xFFFF};
        short id;
        ResType theType;
        Str255 dummy;
        
        /*
         * We need to first paint the background white.  Also, for
         * some reason we *must* use GetCIcon instead of GetNamedResource
         * for PlotCIcon to work - so we use GetResInfo to get the id.
         */
        RGBForeColor(&white);
        PaintRect(&destRect);
        GetResInfo(resource, &id, &theType, dummy);
        ReleaseResource(resource);
        resource = (Handle) GetCIcon(id);
        PlotCIcon(&destRect, (CIconHandle) resource);
        DisposeCIcon((CIconHandle) resource);
d265 1
a265 1
    
d268 3
a270 1
    SetGWorld(saveWorld, saveDevice);
@

