head	1.5;
access;
symbols
	rel-7-10-4:1.3
	STABLE:1.3.0.2
	rel-7-10-2:1.3
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.5
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.14.15.22.00;	author erikgreenwald;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.07.04.17.45;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.20.17.22.25;	author joevalleyfield;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.5
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXMenu.c --
 *
 *	This module implements the Mac-platform specific features of menus.
 *
 * Copyright (c) 1996-1997 by Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXMenu.c,v 1.42 2007/06/29 03:20:01 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkMenubutton.h"
#include "tkMenu.h"
#include "tkColor.h"
#include "tkFont.h"
#include "tkMacOSXDebug.h"

/*
#ifdef TK_MAC_DEBUG
#define TK_MAC_DEBUG_MENUS
#endif
*/

#define USE_TK_MDEF

typedef struct MacMenu {
    MenuRef menuHdl;		/* The Menu Manager data structure. */
#ifdef USE_TK_MDEF
    int useMDEF;		/* true if this menu uses the MDEF */
#endif
} MacMenu;

typedef struct MenuEntryUserData {
    Drawable mdefDrawable;
    TkMenuEntry *mePtr;
    Tk_Font tkfont;
    Tk_FontMetrics *fmPtr;
} MenuEntryUserData;

/*
 * Platform specific flags for menu entries
 *
 * ENTRY_COMMAND_ACCEL		Indicates the entry has the command key
 *				in its accelerator string.
 * ENTRY_OPTION_ACCEL		Indicates the entry has the option key
 *				in its accelerator string.
 * ENTRY_SHIFT_ACCEL		Indicates the entry has the shift key
 *				in its accelerator string.
 * ENTRY_CONTROL_ACCEL		Indicates the entry has the control key
 *				in its accelerator string.
 */

#define ENTRY_COMMAND_ACCEL	ENTRY_PLATFORM_FLAG1
#define ENTRY_OPTION_ACCEL	ENTRY_PLATFORM_FLAG2
#define ENTRY_SHIFT_ACCEL	ENTRY_PLATFORM_FLAG3
#define ENTRY_CONTROL_ACCEL	ENTRY_PLATFORM_FLAG4
#define ENTRY_ACCEL_MASK	(ENTRY_COMMAND_ACCEL | ENTRY_OPTION_ACCEL \
				| ENTRY_SHIFT_ACCEL | ENTRY_CONTROL_ACCEL)
#define MODIFIER_NUM 4

/*
 * This structure is used to keep track of subfields within Macintosh menu
 * items.
 */

typedef struct EntryGeometry {
    int accelTextStart;		/* Offset into the accel string where
				 * the text starts. Everything before
				 * this is modifier key descriptions.
				 */
    int modifierWidth;		/* Width of modifier symbols. */
    int accelTextWidth;		/* Width of the text after the modifier
				 * keys. */
    int nonAccelMargin;		/* The width of the margin for entries
				 * without accelerators. */
    int modifierNum;		/* Number of modifiers */
    Tcl_UniChar modifierUniChars[MODIFIER_NUM];
				/* Modifiers in unicode */
    char accelGlyph;		/* Accelerator glyph, if any */
} EntryGeometry;

/*
 * Structure to keep track of toplevel windows and their menubars.
 */

typedef struct TopLevelMenubarList {
    struct TopLevelMenubarList *nextPtr;
				/* The next window in the list. */
    Tk_Window tkwin;		/* The toplevel window. */
    TkMenu *menuPtr;		/* The menu associated with this
				 * toplevel. */
} TopLevelMenubarList;

/*
 * Platform-specific flags for menus.
 *
 * MENU_APPLE_MENU		0 indicates a custom Apple menu has
 *				not been installed; 1 a custom Apple
 *				menu has been installed.
 * MENU_HELP_MENU		0 indicates a custom Help menu has
 *				not been installed; 1 a custom Help
 *				menu has been installed.
 * MENU_RECONFIGURE_PENDING	1 indicates that an idle handler has
 *				been scheduled to reconfigure the
 *				Macintosh MenuHandle.
 */

#define MENU_APPLE_MENU			MENU_PLATFORM_FLAG1
#define MENU_HELP_MENU			MENU_PLATFORM_FLAG2
#define MENU_RECONFIGURE_PENDING	MENU_PLATFORM_FLAG3

#define CASCADE_CMD (0x1b)	/* The special command char for cascade
				 * menus. */
#define MENUBAR_REDRAW_PENDING 1

static int gNoTkMenus = 0;	/* This is used by Tk_MacOSXTurnOffMenus as the
				 * flag that Tk is not to draw any menus. */

static Tcl_HashTable commandTable;
				/* The list of menuInstancePtrs associated with
				 * menu ids */
static short currentAppleMenuID;
				/* The id of the current Apple menu. 0 for
				 * none. */
static short currentHelpMenuID; /* The id of the current Help menu. 0 for
				 * none. */
static Tcl_Interp *currentMenuBarInterp;
				/* The interpreter of the window that owns
				 * the current menubar. */
static char *currentMenuBarName;
				/* Malloced. Name of current menu in menu bar.
				 * NULL if no menu set. TO DO: make this a
				 * DString. */
static Tk_Window currentMenuBarOwner;
				/* Which window owns the current menu bar. */
static int inPostMenu;		/* We cannot be re-entrant like X
				 * windows. */
static short lastMenuID;	/* To pass to NewMenu; need to figure out
				 * a good way to do this. */
static short lastCascadeID;
				/* Cascades have to have ids that are
				 * less than 256. */
static int menuBarFlags;	/* Used for whether the menu bar needs
				 * redrawing or not. */

struct MenuCommandHandlerData { /* This is the ClientData we pass to */
    TkMenu *menuPtr;		/* Tcl_DoWhenIdle to move handling */
    int index;			/* menu commands to the event loop. */
};

static TopLevelMenubarList *windowListPtr;
				/* A list of windows that have menubars set. */

/*
 * Array of unicode, charcode and utf representations of the most common
 * special menu symbols.
 */
typedef struct MenuSymbol {
    const Tcl_UniChar unicode;
    const char charCode;
    /* char padding; */
    int utfLen, width;
    char utf[TCL_UTF_MAX + 1];
} MenuSymbol;

static MenuSymbol menuSymbols[] = {
    {kCommandUnicode,	kCommandCharCode},
    {kOptionUnicode,	kMenuOptionGlyph},
    {kControlUnicode,	kMenuControlGlyph},
    {kShiftUnicode,	kMenuShiftGlyph},
    {kCheckUnicode,	kCheckCharCode},
    {kDiamondUnicode,	kDiamondCharCode},
    {kBulletUnicode,	kBulletCharCode},
    {0x2026,		kNullCharCode},
    {0,			0},
};

enum MenuSymbolIdx {
    COMMAND_SYMBOL,
    OPTION_SYMBOL,
    CONTROL_SYMBOL,
    SHIFT_SYMBOL,
    CHECK_SYMBOL,
    DIAMDOND_SYMBOL,
    BULLET_SYMBOL,
    ELLIPSIS_SYMBOL,
};

MenuRef tkCurrentAppleMenu = NULL;

static SInt32 menuMarkColumnWidth = 0, menuMarkIndent = 0;
static SInt32 menuTextLeadingEdgeMargin = 0, menuTextTrailingEdgeMargin = 0;
static SInt16 menuItemExtraHeight = 0, menuItemExtraWidth = 0;
static SInt16 menuSeparatorHeight = 0;

/*
 * Forward declarations for procedures defined later in this file:
 */

MODULE_SCOPE int TkMacOSXGetNewMenuID(Tcl_Interp *interp, TkMenu *menuInstPtr,
	int cascade, short *menuIDPtr);
MODULE_SCOPE void TkMacOSXFreeMenuID(short menuID);

static void CompleteIdlers(TkMenu *menuPtr);
static void DrawMenuBarWhenIdle(ClientData clientData);
static void DrawMenuEntryAccelerator(TkMenu *menuPtr, TkMenuEntry *mePtr,
	Drawable d, GC gc, Tk_Font tkfont, const Tk_FontMetrics *fmPtr,
	Tk_3DBorder activeBorder, int x, int y, int width, int height,
	int drawArrow);
static void DrawMenuEntryBackground(TkMenu *menuPtr, TkMenuEntry *mePtr,
	Drawable d, Tk_3DBorder activeBorder, Tk_3DBorder bgBorder, int x,
	int y, int width, int heigth);
static void DrawMenuEntryIndicator(TkMenu *menuPtr, TkMenuEntry *mePtr,
	Drawable d, GC gc, GC indicatorGC, Tk_Font tkfont,
	const Tk_FontMetrics *fmPtr, int x, int y, int width, int height);
static void DrawMenuEntryLabel(TkMenu * menuPtr, TkMenuEntry *mePtr,
	Drawable d, GC gc, Tk_Font tkfont, const Tk_FontMetrics *fmPtr, int x,
	int y, int width, int height);
static void DrawMenuSeparator(TkMenu *menuPtr, TkMenuEntry *mePtr, Drawable d,
	GC gc, Tk_Font tkfont, const Tk_FontMetrics *fmPtr, int x, int y,
	int width, int height);
static void DrawTearoffEntry(TkMenu *menuPtr, TkMenuEntry *mePtr, Drawable d,
	GC gc, Tk_Font tkfont, const Tk_FontMetrics *fmPtr, int x, int y,
	int width, int height);
static void EventuallyInvokeMenu(ClientData data);
static void GetEntryText(TkMenuEntry *mePtr, Tcl_DString *dStringPtr);
static void GetMenuAccelGeometry(TkMenu *menuPtr, TkMenuEntry *mePtr,
	Tk_Font tkfont, const Tk_FontMetrics *fmPtr, int *modWidthPtr,
	int *textWidthPtr, int *heightPtr);
static void GetMenuLabelGeometry(TkMenuEntry *mePtr, Tk_Font tkfont,
	const Tk_FontMetrics *fmPtr, int *widthPtr, int *heightPtr);
static void GetMenuIndicatorGeometry(TkMenu *menuPtr, TkMenuEntry *mePtr,
	Tk_Font tkfont, const Tk_FontMetrics *fmPtr, int *widthPtr,
	int *heightPtr);
static void GetMenuSeparatorGeometry(TkMenu *menuPtr, TkMenuEntry *mePtr,
	Tk_Font tkfont, const Tk_FontMetrics *fmPtr, int *widthPtr,
	int *heightPtr);
static TkMenuEntry* GetParentMenuEntry(TkMenu *menuPtr);
static void GetTearoffEntryGeometry(TkMenu *menuPtr, TkMenuEntry *mePtr,
	Tk_Font tkfont, const Tk_FontMetrics *fmPtr, int *widthPtr,
	int *heightPtr);
static char FindMarkCharacter(TkMenuEntry *mePtr);
static int GetUtfMarkCharacter(char markChar, const char **markUtfPtr);
static TkMenu* MenuPtrForMenuRef(MenuRef menu);
static int ParseAccelerators(const char **accelStringPtr, int *modifierNumPtr,
	Tcl_UniChar *modifierUniChars, int *modifierWidth);
static void MenuSelectEvent(TkMenu *menuPtr);
static void ReconfigureIndividualMenu(TkMenu *menuPtr, MenuHandle macMenuHdl,
	int base);
static void ReconfigureMacintoshMenu(ClientData clientData);
static void RecursivelyClearActiveMenu(TkMenu *menuPtr);
static void RecursivelyDeleteMenu(TkMenu *menuPtr);
static void RecursivelyInsertMenu(TkMenu *menuPtr);
static void SetDefaultMenubar(void);
static int SetMenuCascade(TkMenu *menuPtr);

#ifdef USE_TK_MDEF
#define SCREEN_MARGIN 5
static MacDrawable macMDEFDrawable;
				/* Drawable for use by MDEF code */
static int MDEFScrollFlag = 0;	/* Used so that popups don't scroll too soon.*/
static MenuItemDrawingUPP tkThemeMenuItemDrawingUPP;
				/* Points to the UPP for theme Item drawing. */
static Tcl_Obj *useMDEFVar;

static void  DrawMenuBackground(TkMenu *menuPtr, Rect *menuRectPtr,
	Drawable d);
static void MenuDefProc(short message, MenuHandle menu, Rect *menuRectPtr,
	Point hitPt, short *whichItem );
static void HandleMenuHiliteMsg(MenuRef menu, Rect *menuRectPtr, Point hitPt,
	SInt16 *whichItem, TkMenu *menuPtr);
static void HandleMenuDrawMsg(MenuRef menu, Rect *menuRectPtr, Point hitPt,
	SInt16 *whichItem, TkMenu *menuPtr);
static void HandleMenuFindItemMsg(MenuRef menu, Rect *menuRectPtr,
	Point hitPt, SInt16 *whichItem, TkMenu *menuPtr);
static void HandleMenuPopUpMsg(MenuRef menu, Rect *menuRectPtr, Point hitPt,
	SInt16 *whichItem, TkMenu *menuPtr);
static void HandleMenuCalcItemMsg(MenuRef menu, Rect *menuRectPtr, Point hitPt,
	SInt16 *whichItem, TkMenu *menuPtr);
static void AppearanceEntryDrawWrapper(TkMenuEntry *mePtr, Rect * menuRectPtr,
	MenuTrackingData *mtdPtr, Drawable d, Tk_FontMetrics *fmPtr,
	Tk_Font tkfont, int erase);
static pascal void ThemeMenuItemDrawingProc(const Rect *inBounds,
	SInt16 inDepth, Boolean inIsColorDevice, SInt32 inUserData);
#else /* USE_TK_MDEF */
#   define useMDEF 0
#endif /* USE_TK_MDEF */

#define IS_THEME_MENU_FONT(tkfont) (strcmp(Tk_NameOfFont(tkfont), "menu") == 0)


/*
 *----------------------------------------------------------------------
 *
 * DrawThemeText --
 *
 *	Wrapper for DrawThemeTextBox API.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
DrawThemeText(
    Drawable d,
    GC gc,
    CFStringRef string,
    ThemeFontID font,
    ThemeDrawState drawState,
    const Rect* bounds,
    int baseline,
    int just)
{
    TkMacOSXDrawingContext dc;
    Rect adjustedBounds;

    /*
     * Menu item text drawn with the .Keyboard font (used for
     * kThemeMenuItemCmdKeyFont) won't always have the same ascent and
     * baseline as text drawn with the regular menu item font, since the
     * glyphs in the .Keyboard font may have a different height. Therefore, we
     * first determine the baseline of the text and then adjust the bounds
     * rect so the baseline aligns with the overall baseline of the menu item.
     */
    if (font == kThemeMenuItemCmdKeyFont) {
	Point size;
	SInt16 cmdKeyBaseline;

	GetThemeTextDimensions(string, font, drawState, false, &size,
		&cmdKeyBaseline);
	adjustedBounds = *bounds;
	OffsetRect(&adjustedBounds, 0, baseline - bounds->top - size.v -
		cmdKeyBaseline);
	bounds = &adjustedBounds;
    }
    TkMacOSXSetupDrawingContext(d, gc, 1, &dc);
    ChkErr(DrawThemeTextBox, string, font, drawState, false, bounds, just,
	    dc.context);
    TkMacOSXRestoreDrawingContext(&dc);
}

/*
 *----------------------------------------------------------------------
 *
 * MeasureThemeText --
 *
 *	Wrapper for GetThemeTextDimensions API.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
MeasureThemeText(
    CFStringRef string,
    ThemeFontID font)
{
    Point pt;

    ChkErr(GetThemeTextDimensions, string, font, kThemeStateActive, false, &pt,
	NULL);
    return pt.h;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXUseID --
 *
 *	Take the ID out of the available list for new menus. Used by the
 *	default menu bar's menus so that they do not get created at the tk
 *	level. See TkMacOSXGetNewMenuID for more information.
 *
 * Results:
 *	Returns TCL_OK if the id was not in use. Returns TCL_ERROR if the
 *	id was in use.
 *
 * Side effects:
 *	A hash table entry in the command table is created with a NULL
 *	value.
 *
 *----------------------------------------------------------------------
 */

int
TkMacOSXUseMenuID(
    short macID)		/* The id to take out of the table */
{
    Tcl_HashEntry *commandEntryPtr;
    int newEntry;
    int iMacID = macID; /* Do this to remove compiler warning */

    TkMenuInit();
    commandEntryPtr = Tcl_CreateHashEntry(&commandTable, (char *) iMacID,
	    &newEntry);
    if (!newEntry) {
	return TCL_ERROR;
    }
    Tcl_SetHashValue(commandEntryPtr, NULL);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGetNewMenuID --
 *
 *	Allocates a new menu id and marks it in use. Each menu on the
 *	mac must be designated by a unique id, which is a short. In
 *	addition, some ids are reserved by the system. Since Tk uses
 *	mostly dynamic menus, we must allocate and free these ids on
 *	the fly. We use the id as a key into a hash table; if there
 *	is no hash entry, we know that we can use the id.
 *
 *	Carbon allows a much larger number of menus than the old APIs.
 *	I believe this is 32768, but am not sure. This code just uses
 *	2000 as the upper limit. Unfortunately tk leaks menus when
 *	cloning, under some circumstances (see bug on sourceforge).
 *
 * Results:
 *	Returns TCL_OK if succesful; TCL_ERROR if there are no more
 *	ids of the appropriate type to allocate. menuIDPtr contains
 *	the new id if succesful.
 *
 * Side effects:
 *	An entry is created for the menu in the command hash table,
 *	and the hash entry is stored in the appropriate field in the
 *	menu data structure.
 *
 *----------------------------------------------------------------------
 */

int
 TkMacOSXGetNewMenuID(
    Tcl_Interp *interp,		/* Used for error reporting */
    TkMenu *menuPtr,		/* The menu we are working with */
    int cascade,		/* 0 if we are working with a normal menu;
				 * 1 if we are working with a cascade */
    short *menuIDPtr)		/* The resulting id */
{
    int found = 0;
    int newEntry;
    Tcl_HashEntry *commandEntryPtr = NULL;
    short returnID = *menuIDPtr;

    /*
     * The following code relies on shorts and unsigned chars wrapping
     * when the highest value is incremented. Also, the values between
     * 236 and 255 inclusive are reserved for DA's by the Mac OS.
     */

    if (!cascade) {
	short curID = lastMenuID + 1;

	if (curID == 236) {
	    curID = 256;
	}

	while (curID != lastMenuID) {
	    int iCurID = curID;
	    commandEntryPtr = Tcl_CreateHashEntry(&commandTable,
		    (char *) iCurID, &newEntry);
	    if (newEntry == 1) {
		found = 1;
		lastMenuID = returnID = curID;
		break;
	    }
	    curID++;
	    if (curID == 236) {
		curID = 256;
	    }
	}
    } else {
	/*
	 * Cascade ids must be between 0 and 235 only, so they must be
	 * dealt with separately.
	 */

	short curID = lastCascadeID + 1;

	if (curID == 2000) {
	    curID = 0;
	}

	while (curID != lastCascadeID) {
	    int iCurID = curID;
	    commandEntryPtr = Tcl_CreateHashEntry(&commandTable,
		    (char *) iCurID, &newEntry);
	    if (newEntry == 1) {
		found = 1;
		lastCascadeID = returnID = curID;
		break;
	    }
	    curID++;
	    if (curID == 2000) {
		curID = 0;
	    }
	}
    }

    if (!found) {
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, "No more menus can be allocated.", NULL);
	return TCL_ERROR;
    }
    Tcl_SetHashValue(commandEntryPtr, (char *) menuPtr);
    *menuIDPtr = returnID;
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXFreeMenuID --
 *
 *	Marks the id as free.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The hash table entry for the ID is cleared.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXFreeMenuID(
    short menuID)		/* The id to free */
{
    Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(&commandTable,
	    (char*)(intptr_t)menuID);

    if (entryPtr != NULL) {
	 Tcl_DeleteHashEntry(entryPtr);
    }
    if (menuID == currentAppleMenuID) {
	currentAppleMenuID = 0;
    }
    if (menuID == currentHelpMenuID) {
	currentHelpMenuID = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * MenuPtrForMenuRef --
 *
 *	Returns a pointer to the TkMenu corresponding to a given
 *	Carbon MenuRef.
 *
 * Results:
 *	Returns a pointer to a TkMenu or NULL.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TkMenu*
MenuPtrForMenuRef(
    MenuRef menu)
{
    TkMenu *menuPtr = NULL;
    MenuID menuID = GetMenuID(menu);
    Tcl_HashEntry *commandEntryPtr = Tcl_FindHashEntry(&commandTable,
	    (char*)(intptr_t)menuID);

    if (commandEntryPtr) {
	menuPtr = (TkMenu *) Tcl_GetHashValue(commandEntryPtr);
    }
    return menuPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * GetParentMenuEntry --
 *
 *	Returns a pointer to the parent's TkMenuEntry of a given TkMenu.
 *
 * Results:
 *	Returns a pointer to a TkMenuEntry or NULL.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TkMenuEntry*
GetParentMenuEntry(
    TkMenu *menuPtr)
{
    TkMenuEntry *cascadeEntryPtr;

    for (cascadeEntryPtr = menuPtr->menuRefPtr->parentEntryPtr;
	    cascadeEntryPtr != NULL;
	    cascadeEntryPtr = cascadeEntryPtr->nextCascadePtr) {
	const char *name = (cascadeEntryPtr->namePtr == NULL) ? ""
		: Tcl_GetString(cascadeEntryPtr->namePtr);

	if (strcmp(name, Tk_PathName(menuPtr->tkwin)) == 0) {
	    break;
	}
    }
    return cascadeEntryPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpNewMenu --
 *
 *	Gets a new blank menu. Only the platform specific options are filled
 *	in.
 *
 * Results:
 *	Returns a standard TCL error.
 *
 * Side effects:
 *	Allocates a Macintosh menu handle and puts in the platformData
 *	field of the menuPtr.
 *
 *----------------------------------------------------------------------
 */

int
TkpNewMenu(
    TkMenu *menuPtr)		/* The common structure we are making the
				 * platform structure for. */
{
    short menuID;
    MenuRef macMenuHdl;
#ifdef USE_TK_MDEF
    MenuDefSpec menuDefSpec;
    Tcl_Obj *useMDEFObjPtr;
    int useMDEF = 1;
#endif
    int error = TCL_OK;
    OSStatus err;
    CFStringRef cfStr;

    error = TkMacOSXGetNewMenuID(menuPtr->interp, menuPtr, 0, &menuID);
    if (error != TCL_OK) {
	return error;
    }
    err = ChkErr(CreateNewMenu, menuID, kMenuAttrDoNotUseUserCommandKeys,
	    &macMenuHdl);
    if (err != noErr) {
	Tcl_AppendResult(menuPtr->interp, "CreateNewMenu failed.", NULL);
	return TCL_ERROR;
    }
    cfStr = CFStringCreateWithCString(NULL, Tk_PathName(menuPtr->tkwin),
	    kCFStringEncodingUTF8);
    if (!cfStr) {
	Tcl_AppendResult(menuPtr->interp, "CFStringCreateWithCString failed.",
		NULL);
	return TCL_ERROR;
    }
    err = ChkErr(SetMenuTitleWithCFString, macMenuHdl, cfStr);
    CFRelease(cfStr);
    if (err != noErr) {
	Tcl_AppendResult(menuPtr->interp, "SetMenuTitleWithCFString failed.",
		NULL);
	return TCL_ERROR;
    }

    menuPtr->platformData = (TkMenuPlatformData) ckalloc(sizeof(MacMenu));
    ((MacMenu *) menuPtr->platformData)->menuHdl = macMenuHdl;

#ifdef USE_TK_MDEF
    /*
     * Check whether we want to use the custom mdef or not. For now
     * the default is to use it unless the variable is explicitly
     * set to no.
     */

    useMDEFObjPtr = Tcl_ObjGetVar2(menuPtr->interp, useMDEFVar, NULL,
	    TCL_GLOBAL_ONLY);
    if (useMDEFObjPtr == NULL || Tcl_GetBooleanFromObj(NULL, useMDEFObjPtr,
	    &useMDEF) == TCL_ERROR || useMDEF) {
	menuDefSpec.defType = kMenuDefProcPtr;
	menuDefSpec.u.defProc = MenuDefProc;
	ChkErr(SetMenuDefinition, macMenuHdl, &menuDefSpec);
    }
    ((MacMenu *) menuPtr->platformData)->useMDEF = useMDEF;
#endif /* USE_TK_MDEF */

    if ((currentMenuBarInterp == menuPtr->interp)
	    && (currentMenuBarName != NULL)) {
	Tk_Window parentWin = Tk_Parent(menuPtr->tkwin);

	if (strcmp(currentMenuBarName, Tk_PathName(parentWin)) == 0) {
	    if ((strcmp(Tk_PathName(menuPtr->tkwin)
		    + strlen(Tk_PathName(parentWin)), ".apple") == 0)
		    || (strcmp(Tk_PathName(menuPtr->tkwin)
		    + strlen(Tk_PathName(parentWin)), ".help") == 0)) {
		if (!(menuBarFlags & MENUBAR_REDRAW_PENDING)) {
		    Tcl_DoWhenIdle(DrawMenuBarWhenIdle, NULL);
		    menuBarFlags |= MENUBAR_REDRAW_PENDING;
		}
	    }
	}
    }

    menuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
    Tcl_DoWhenIdle(ReconfigureMacintoshMenu, (ClientData) menuPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDestroyMenu --
 *
 *	Destroys platform-specific menu structures.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All platform-specific allocations are freed up.
 *
 *----------------------------------------------------------------------
 */

void
TkpDestroyMenu(
    TkMenu *menuPtr)		/* The common menu structure */
{
    MenuRef macMenuHdl = ((MacMenu *) menuPtr->platformData)->menuHdl;

    if (menuPtr->menuFlags & MENU_RECONFIGURE_PENDING) {
	Tcl_CancelIdleCall(ReconfigureMacintoshMenu, (ClientData) menuPtr);
	menuPtr->menuFlags &= ~MENU_RECONFIGURE_PENDING;
    }
    if (GetMenuID(macMenuHdl) == currentHelpMenuID) {
	MenuRef helpMenuHdl;
	MenuItemIndex helpIndex;

	if ((HMGetHelpMenu(&helpMenuHdl,&helpIndex) == noErr)
		&& (helpMenuHdl != NULL)) {
	    int i, count = CountMenuItems(helpMenuHdl);

	    for (i = helpIndex; i <= count; i++) {
		DeleteMenuItem(helpMenuHdl, helpIndex);
	    }
	}
	currentHelpMenuID = 0;
    }
    if (menuPtr->platformData != NULL) {
	MenuID menuID = GetMenuID(macMenuHdl);

	DeleteMenu(menuID);
	TkMacOSXFreeMenuID(menuID);
	DisposeMenu(macMenuHdl);
	ckfree((char *) menuPtr->platformData);
	menuPtr->platformData = NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * SetMenuCascade --
 *
 *	Does any cleanup to change a menu from a normal to a cascade.
 *
 * Results:
 *	Standard Tcl error.
 *
 * Side effects:
 *	The mac menu id is reset.
 *
 *----------------------------------------------------------------------
 */

int
SetMenuCascade(
    TkMenu* menuPtr)		/* The menu we are setting up to be a
				 * cascade. */
{
    MenuHandle macMenuHdl = ((MacMenu *) menuPtr->platformData)->menuHdl;
    MenuID newMenuID, menuID = GetMenuID(macMenuHdl);
    int error = TCL_OK;

    if (menuID >= 256) {
	error = TkMacOSXGetNewMenuID(menuPtr->interp, menuPtr, 1, &newMenuID);
	if (error == TCL_OK) {
	    TkMacOSXFreeMenuID(menuID);
	    SetMenuID(macMenuHdl,newMenuID);
	}
    }
    return error;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDestroyMenuEntry --
 *
 *	Cleans up platform-specific menu entry items.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	All platform-specific allocations are freed up.
 *
 *----------------------------------------------------------------------
 */

void
TkpDestroyMenuEntry(
    TkMenuEntry *mePtr)		/* The common structure for the menu entry. */
{
    TkMenu *menuPtr = mePtr->menuPtr;

    ckfree((char *) mePtr->platformEntryData);
    if ((menuPtr->platformData != NULL)
	    && !(menuPtr->menuFlags & MENU_RECONFIGURE_PENDING)) {
	menuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, (ClientData) menuPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetEntryText --
 *
 *	Given a menu entry, gives back the text that should go in it.
 *	Separators should be done by the caller, as they have to be
 *	handled specially. This is primarily used to do a substitution
 *	between "..." and the ellipsis character which looks nicer.
 *
 * Results:
 *	itemText points to the new text for the item.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
GetEntryText(
    TkMenuEntry *mePtr,		/* A pointer to the menu entry. */
    Tcl_DString *dStringPtr)	/* The DString to put the text into. This
				 * will be initialized by this routine. */
{
#ifdef USE_TK_MDEF
    const int useMDEF = ((MacMenu *) mePtr->menuPtr->platformData)->useMDEF;
#endif
    int noLabel = (mePtr->labelPtr == NULL || mePtr->labelLength == 0);

    Tcl_DStringInit(dStringPtr);
    if (mePtr->type == TEAROFF_ENTRY && (useMDEF || noLabel)) {
	Tcl_DStringAppend(dStringPtr, "(Tear-off)", -1);
    } else if (mePtr->imagePtr != NULL && (useMDEF || noLabel) &&
	    mePtr->compound == COMPOUND_NONE) {
	Tcl_DStringAppend(dStringPtr, "(Image)", -1);
    } else if (mePtr->bitmapPtr != NULL && (useMDEF || noLabel) &&
	    mePtr->compound == COMPOUND_NONE) {
	Tcl_DStringAppend(dStringPtr, "(Pixmap)", -1);
    } else if (noLabel) {
	/*
	 * The Mac menu manager does not like null strings.
	 */

	Tcl_DStringAppend(dStringPtr, " ", -1);
    } else {
	int length;
	char *text = Tcl_GetStringFromObj(mePtr->labelPtr, &length);
	char *dStringText;
	int i;

	for (i = 0; *text; text++, i++) {
	    if ((*text == '.') && (*(text+1) == '.') && (*(text+2) == '.')) {
		Tcl_DStringAppend(dStringPtr, menuSymbols[ELLIPSIS_SYMBOL].utf,
			menuSymbols[ELLIPSIS_SYMBOL].utfLen);
		i += menuSymbols[ELLIPSIS_SYMBOL].utfLen - 1;
		text += 2;
	    } else {
		Tcl_DStringSetLength(dStringPtr,
			Tcl_DStringLength(dStringPtr) + 1);
		dStringText = Tcl_DStringValue(dStringPtr);
		dStringText[i] = *text;
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FindMarkCharacter --
 *
 *	Finds the Macintosh mark character based on the font of the
 *	item. We calculate a good mark character based on the font
 *	that this item is rendered in.
 *
 * Results:
 *	Mark char.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char
FindMarkCharacter(
    TkMenuEntry *mePtr)		/* The entry we are finding the character
				 * for. */
{
    static const char markChars[] = {kCheckCharCode, kDiamondCharCode,
	    kBulletCharCode, '-', kCheckCharCode};
    const char *markChar = markChars;
    int i = sizeof(markChars);
    Tk_Font tkfont;

    tkfont = Tk_GetFontFromObj(mePtr->menuPtr->tkwin,
	    (mePtr->fontPtr == NULL) ? mePtr->menuPtr->fontPtr
	    : mePtr->fontPtr);

    while (--i) {
	if (!TkMacOSXIsCharacterMissing(tkfont, *markChar)) {
	    break;
	}
	markChar++;
    }
    return *markChar;
}

/*
 *----------------------------------------------------------------------
 *
 * GetUtfMarkCharacter --
 *
 *	Get the utf8 string for the given mark character, taking into
 *	account the special menu font char codes.
 *
 * Results:
 *	Length of returned utf8 string.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
GetUtfMarkCharacter(
    char markChar,
    const char **markUtfPtr)
{
    const MenuSymbol *ms = menuSymbols;
    int len = 0;

    while (ms->unicode) {
	if (ms->charCode && ms->charCode == markChar) {
	    *markUtfPtr = ms->utf;
	    len = ms->utfLen;
	    break;
	}
	ms++;
    }
    if (!len) {
	static char markUtf[TCL_UTF_MAX + 1];

	Tcl_ExternalToUtf(NULL, TkMacOSXCarbonEncoding, &markChar, 1, 0, NULL,
		markUtf, TCL_UTF_MAX + 1, NULL, &len, NULL);
	*markUtfPtr = markUtf;
    }
    return len;
}

/*
 *----------------------------------------------------------------------
 *
 * ParseAccelerators --
 *
 *	Parse menu accelerator string.
 *
 * Results:
 *	Accelerator flags.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
ParseAccelerators(
    const char **accelStringPtr,
    int *modifierNumPtr,
    Tcl_UniChar *modifierUniChars,
    int *modifierWidth)
{
    struct Modif {
	const char *name;
	const size_t len;
	const int flag, symbol;
    };
#define MODIF(n, f) { #n, sizeof(#n)-1, ENTRY_##f##_ACCEL, f##_SYMBOL }
    static const struct Modif modifs[] = {
	MODIF(Control,	CONTROL),
	MODIF(Ctrl,	CONTROL),
	MODIF(Option,	OPTION),
	MODIF(Opt,	OPTION),
	MODIF(Alt,	OPTION),
	MODIF(Shift,	SHIFT),
	MODIF(Command,	COMMAND),
	MODIF(Cmd,	COMMAND),
	MODIF(Meta,	COMMAND),
	{ NULL, 0, 0, 0}
    };
#undef MODIF
    const char *accelString = *accelStringPtr;
    int flags = 0, num = 0, seen = 0, width = 0;
    const struct Modif *m;

    while (1) {
	m = modifs;
	while (m->name) {
	    int l = m->len;

	    if (!strncasecmp(accelString, m->name, l) &&
		    (accelString[l] == '-' || accelString[l] == '+')) {
		flags |= m->flag;
		accelString += l+1;
		break;
	    }
	    m++;
	}
	if (!m->name || !*accelString) {
	    break;
	}
    }
    m = modifs;
    while (m->name && num < MODIFIER_NUM) {
	if (flags & m->flag && !(seen & m->flag)) {
	    modifierUniChars[num++] = menuSymbols[m->symbol].unicode;
	    width += menuSymbols[m->symbol].width;
	    seen |= m->flag;
	}
	m++;
    }
    *accelStringPtr = accelString;
    *modifierNumPtr = num;
    *modifierWidth = width;
    return flags;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpConfigureMenuEntry --
 *
 *	Processes configurations for menu entries.
 *
 * Results:
 *	Returns standard TCL result. If TCL_ERROR is returned, then
 *	the interp's result contains an error message.
 *
 * Side effects:
 *	Configuration information get set for mePtr; old resources
 *	get freed, if any need it.
 *
 *----------------------------------------------------------------------
 */

int
TkpConfigureMenuEntry(
    TkMenuEntry *mePtr) 	/* Information about menu entry; may
				 * or may not already have values for
				 * some fields. */
{
    TkMenu *menuPtr = mePtr->menuPtr;
    EntryGeometry *geometryPtr = (EntryGeometry *) mePtr->platformEntryData;

    /*
     * Cascade menus have to have menu IDs of less than 256. So
     * we need to change the child menu if this has been configured
     * for a cascade item.
     */

    if (mePtr->type == CASCADE_ENTRY) {
	if ((mePtr->childMenuRefPtr != NULL)
		&& (mePtr->childMenuRefPtr->menuPtr != NULL)) {
	    MenuHandle childMenuHdl = ((MacMenu *) mePtr
		    ->childMenuRefPtr->menuPtr->platformData)->menuHdl;

	    if (childMenuHdl != NULL) {
		int error = SetMenuCascade(mePtr->childMenuRefPtr->menuPtr);

		if (error != TCL_OK) {
		    return error;
		}

		if (menuPtr->menuType == MENUBAR) {
		    CFStringRef cfStr = CFStringCreateWithCString(NULL,
			    (!(mePtr->labelPtr) ? "" :
			    Tcl_GetString(mePtr->labelPtr)),
			    kCFStringEncodingUTF8);

		    if (cfStr) {
			SetMenuTitleWithCFString(childMenuHdl, cfStr);
			CFRelease(cfStr);
		    }
		}
	    }
	}
    }

    /*
     * We need to parse the accelerator string. If it has the strings
     * for Command, Control, Shift or Option, we need to flag it
     * so we can draw the symbols for it. We also need to precalcuate
     * the position of the first real character we are drawing.
     */

    if (0 == mePtr->accelLength) {
	geometryPtr->accelTextStart = -1;
    } else {
	const char *accelString = (mePtr->accelPtr == NULL) ? ""
		: Tcl_GetString(mePtr->accelPtr);
	const char *accelStart = accelString;

	mePtr->entryFlags &= ~ENTRY_ACCEL_MASK;
	mePtr->entryFlags |= ParseAccelerators(&accelString,
		&geometryPtr->modifierNum, geometryPtr->modifierUniChars,
		&geometryPtr->modifierWidth);
	geometryPtr->accelTextStart = (ptrdiff_t)(accelString - accelStart);
    }

    if (!(menuPtr->menuFlags & MENU_RECONFIGURE_PENDING)) {
	menuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, (ClientData) menuPtr);
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ReconfigureIndividualMenu --
 *
 *	This routine redoes the guts of the menu. It works from
 *	a base item and offset, so that a regular menu will
 *	just have all of its items added, but the help menu will
 *	have all of its items appended after the apple-defined
 *	items.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The Macintosh menu handle is updated
 *
 *----------------------------------------------------------------------
 */

void
ReconfigureIndividualMenu(
    TkMenu *menuPtr,		/* The menu we are affecting. */
    MenuHandle macMenuHdl,	/* The macintosh menu we are affecting.
				 * Will not necessarily be
				 * menuPtr->platformData because this could
				 * be the help menu. */
    int base)			/* The last index that we do not want
				 * touched. 0 for normal menus;
				 * # of system help menu items
				 * for help menus. */
{
    int count;
    int index;
    TkMenuEntry *mePtr;
    int parentDisabled = 0;

#ifdef TK_MAC_DEBUG_MENUS
    /*
     * Carbon-internal menu debugging (c.f. Technote 2124)
     */

    TkMacOSXInitNamedDebugSymbol(HIToolbox, void, DebugPrintMenu,
	MenuRef menu);
    if (DebugPrintMenu) {
	DebugPrintMenu(macMenuHdl);
    }
#endif

    mePtr = GetParentMenuEntry(menuPtr);
    if (mePtr && mePtr->state == ENTRY_DISABLED) {
	parentDisabled = 1;
    }

    /*
     * First, we get rid of all of the old items.
     */

    count = CountMenuItems(macMenuHdl);
    for (index = base; index < count; index++) {
	DeleteMenuItem(macMenuHdl, base + 1);
    }

    count = menuPtr->numEntries;

    for (index = 1; index <= count; index++) {
	mePtr = menuPtr->entries[index - 1];

	/*
	 * We have to do separators separately because SetMenuItemText
	 * does not parse meta-characters.
	 */

	if (mePtr->type == SEPARATOR_ENTRY) {
	    AppendMenuItemTextWithCFString(macMenuHdl, NULL,
		    kMenuItemAttrSeparator | kMenuItemAttrDisabled, 0, NULL);
	} else {
	    Tcl_DString itemTextDString;
	    CFStringRef cfStr;

	    GetEntryText(mePtr, &itemTextDString);
	    cfStr = CFStringCreateWithCString(NULL,
		    Tcl_DStringValue(&itemTextDString), kCFStringEncodingUTF8);
	    if (cfStr) {
		AppendMenuItemTextWithCFString(macMenuHdl, cfStr, 0, 0, NULL);
		CFRelease(cfStr);
	    } else {
		AppendMenuItemTextWithCFString(macMenuHdl, CFSTR ("<Error>"),
		    0, 0, NULL);
	    }
	    Tcl_DStringFree(&itemTextDString);

	    /*
	     * Set enabling and disabling correctly.
	     */

	    if (parentDisabled || (mePtr->state == ENTRY_DISABLED)) {
		DisableMenuItem(macMenuHdl, base + index);
	    } else {
		EnableMenuItem(macMenuHdl, base + index);
	    }

	    /*
	     * Set the check mark for check entries and radio entries.
	     */

	    SetItemMark(macMenuHdl, base + index, 0);
	    if ((mePtr->type == CHECK_BUTTON_ENTRY)
		    || (mePtr->type == RADIO_BUTTON_ENTRY)) {
		CheckMenuItem(macMenuHdl, base + index, (mePtr->entryFlags
		& ENTRY_SELECTED) && mePtr->indicatorOn);
		if (mePtr->indicatorOn
			&& (mePtr->entryFlags & ENTRY_SELECTED)) {
		    SetItemMark(macMenuHdl, base + index,
			    FindMarkCharacter(mePtr));
		}
	    }

	    if (mePtr->type == CASCADE_ENTRY) {
		if ((mePtr->childMenuRefPtr != NULL)
			&& (mePtr->childMenuRefPtr->menuPtr != NULL)) {
		    MenuHandle childMenuHdl =
			    ((MacMenu *) mePtr->childMenuRefPtr
			    ->menuPtr->platformData)->menuHdl;

		    if (childMenuHdl != NULL) {
			ChkErr(SetMenuItemHierarchicalID, macMenuHdl,
				base + index, GetMenuID(childMenuHdl));
		    }
		    /*
		     * If we changed the highligthing of this menu, its
		     * children all have to be reconfigured so that
		     * their state will be reflected in the menubar.
		     */

		    if (!(mePtr->childMenuRefPtr->menuPtr->menuFlags
				& MENU_RECONFIGURE_PENDING)) {
			mePtr->childMenuRefPtr->menuPtr->menuFlags
				|= MENU_RECONFIGURE_PENDING;
			Tcl_DoWhenIdle(ReconfigureMacintoshMenu,
				(ClientData) mePtr->childMenuRefPtr->menuPtr);
		    }
		}
	    }

	    if ((mePtr->type != CASCADE_ENTRY) && (mePtr->accelPtr != NULL)) {
		int accelLen, modifiers = 0, hasCmd = 0;
		EntryGeometry *geometryPtr =
			(EntryGeometry*)mePtr->platformEntryData;
		int offset = geometryPtr->accelTextStart;
		char *accel = Tcl_GetStringFromObj(mePtr->accelPtr, &accelLen);

		accelLen -= offset;
		accel += offset;
		if (mePtr->entryFlags & ENTRY_OPTION_ACCEL) {
		    modifiers |= kMenuOptionModifier;
		}
		if (mePtr->entryFlags & ENTRY_SHIFT_ACCEL) {
		    modifiers |= kMenuShiftModifier;
		}
		if (mePtr->entryFlags & ENTRY_CONTROL_ACCEL) {
		    modifiers |= kMenuControlModifier;
		}
		if (mePtr->entryFlags & ENTRY_COMMAND_ACCEL) {
		    hasCmd = 1;
		}
		if (accelLen == 1) {
		    if (hasCmd || (modifiers != 0 && modifiers !=
			    kMenuShiftModifier)) {
			SetItemCmd(macMenuHdl, base + index, accel[0]);
			if (!hasCmd) {
			    modifiers |= kMenuNoCommandModifier;
			}
		    }
		} else {
		    /*
		     * Convert from accelerator names to Carbon menu glyphs.
		     */
		    struct Glyph {
			const char *name;
			const size_t len;
			const char glyph;
		    };
#define GLYPH(n, g) { #n, sizeof(#n)-1, kMenu##g##Glyph }
		    static const struct Glyph glyphs[] = {
			GLYPH(PageUp,	PageUp),
			GLYPH(PageDown, PageDown),
			GLYPH(Left,	LeftArrow),
			GLYPH(Right,	RightArrow),
			GLYPH(Up,	UpArrow),
			GLYPH(Down,	DownArrow),
			GLYPH(Escape,	Escape),
			GLYPH(Clear,	Clear),
			GLYPH(Enter,	Enter),
			GLYPH(Backspace,DeleteLeft),
			GLYPH(Space,	Space),
			GLYPH(Tab,	TabRight),
			GLYPH(Delete,	DeleteRight),
			GLYPH(Home,	NorthwestArrow),
			GLYPH(End,	SoutheastArrow),
			GLYPH(Return,	Return),
			GLYPH(Help,	Help),
			GLYPH(Power,	Power),
			{ NULL, 0, 0}
		    };
#undef GLYPH
		    const struct Glyph *g = glyphs;
		    char glyph = 0;

		    if (accel[0] == 'F' && accelLen < 4 &&
			    (accel[1] > '0' && accel[1] <= '9')) {
			int fkey = accel[1] - '0';

			if (accelLen == 3) {
			    if (accel[2] >= '0' && accel[2] <= '9') {
				fkey = 10 * fkey + (accel[2] - '0');
			    } else {
				fkey = 0;
			    }
			}
			if (fkey >= 1 && fkey <= 12) {
			    glyph = kMenuF1Glyph + fkey - 1;
			} else if (fkey >= 13 && fkey <= 15) {
			    glyph = kMenuF13Glyph + fkey - 13;
			}
		    } else while (g->name) {
			if (accel[0] == g->name[0] &&
				(size_t)accelLen == g->len &&
				!strncasecmp(accel, g->name, g->len)) {
			    glyph = g->glyph;
			    break;
			}
			g++;
		    }
		    if (glyph) {
			ChkErr(SetMenuItemKeyGlyph, macMenuHdl, base + index,
				glyph);
			if (!hasCmd) {
			    modifiers |= kMenuNoCommandModifier;
			}
			geometryPtr->accelGlyph = glyph;
		    }
		}
		ChkErr(SetMenuItemModifiers, macMenuHdl, base + index,
			modifiers);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ReconfigureMacintoshMenu --
 *
 *	Rebuilds the Macintosh MenuHandle items from the menu. Called
 *	usually as an idle handler, but can be called synchronously
 *	if the menu is about to be posted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Configuration information get set for mePtr; old resources
 *	get freed, if any need it.
 *
 *----------------------------------------------------------------------
 */

void
ReconfigureMacintoshMenu(
    ClientData clientData)	/* Information about menu entry; may
				 * or may not already have values for
				 * some fields. */
{
    TkMenu *menuPtr = (TkMenu *) clientData;
    MenuHandle macMenuHdl = ((MacMenu *) menuPtr->platformData)->menuHdl;
    MenuHandle helpMenuHdl = NULL;

    menuPtr->menuFlags &= ~MENU_RECONFIGURE_PENDING;

    if (NULL == macMenuHdl) {
	return;
    }

    ReconfigureIndividualMenu(menuPtr, macMenuHdl, 0);

    if (GetMenuID(macMenuHdl) == currentHelpMenuID) {
	MenuItemIndex helpIndex;
	HMGetHelpMenu(&helpMenuHdl,&helpIndex);
	if (helpMenuHdl != NULL) {
	    ReconfigureIndividualMenu(menuPtr, helpMenuHdl, helpIndex - 1);
	}
    }

    if (menuPtr->menuType == MENUBAR) {
	if (!(menuBarFlags & MENUBAR_REDRAW_PENDING)) {
	    Tcl_DoWhenIdle(DrawMenuBarWhenIdle, NULL);
	    menuBarFlags |= MENUBAR_REDRAW_PENDING;
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CompleteIdlers --
 *
 *	Completes all idle handling so that the menus are in sync when
 *	the user invokes them with the mouse.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The Macintosh menu handles are flushed out.
 *
 *----------------------------------------------------------------------
 */

void
CompleteIdlers(
    TkMenu *menuPtr)		/* The menu we are completing. */
{
    int i;

    if (menuPtr->menuFlags & MENU_RECONFIGURE_PENDING) {
	Tcl_CancelIdleCall(ReconfigureMacintoshMenu, (ClientData) menuPtr);
	ReconfigureMacintoshMenu((ClientData) menuPtr);
    }

    for (i = 0; i < menuPtr->numEntries; i++) {
	if ((menuPtr->entries[i]->type == CASCADE_ENTRY) &&
		(menuPtr->entries[i]->childMenuRefPtr != NULL) &&
		(menuPtr->entries[i]->childMenuRefPtr->menuPtr != NULL)) {
	    CompleteIdlers(menuPtr->entries[i]->childMenuRefPtr->menuPtr);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpPostMenu --
 *
 *	Posts a menu on the screen
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The menu is posted and handled.
 *
 *----------------------------------------------------------------------
 */

int
TkpPostMenu(
    Tcl_Interp *interp,		/* The interpreter this menu lives in */
    TkMenu *menuPtr,		/* The menu we are posting */
    int x,			/* The global x-coordinate of the top, left-
				 * hand corner of where the menu is supposed
				 * to be posted. */
    int y)			/* The global y-coordinate */
{
    MenuHandle macMenuHdl = ((MacMenu *) menuPtr->platformData)->menuHdl;
    long popUpResult;
    int result;

    if (inPostMenu > 0) {
	Tcl_AppendResult(interp,
		"Cannot call post menu while already posting menu", NULL);
	result = TCL_ERROR;
    } else {
	short menuID;
	Window window;
	int oldWidth = menuPtr->totalWidth;

	inPostMenu++;
	result = TkPreprocessMenu(menuPtr);
	/*
	 * The post commands could have deleted the menu, which means
	 * we are dead and should go away.
	 */

	if (result != TCL_OK || !menuPtr->tkwin) {
	    goto endPostMenu;
	}

	CompleteIdlers(menuPtr);
	if (menuBarFlags & MENUBAR_REDRAW_PENDING) {
	    Tcl_CancelIdleCall(DrawMenuBarWhenIdle, NULL);
	    DrawMenuBarWhenIdle(NULL);
	}
	RecursivelyInsertMenu(menuPtr);

	TkMacOSXTrackingLoop(1);
	popUpResult = PopUpMenuSelect(macMenuHdl, y, x, menuPtr->active);
	TkMacOSXTrackingLoop(0);
	menuPtr->totalWidth = oldWidth;

	/*
	 * Simulate the mouse up.
	 */

	window = Tk_WindowId(menuPtr->tkwin);
	TkGenerateButtonEventForXPointer(window);

	/*
	 * Dispatch the command.
	 */

	menuID = HiWord(popUpResult);
	if (menuID != 0) {
	    result = TkMacOSXDispatchMenuEvent(menuID, LoWord(popUpResult));
	}

endPostMenu:
	inPostMenu--;
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMenuNewEntry --
 *
 *	Adds a pointer to a new menu entry structure with the platform-
 *	specific fields filled in. The Macintosh uses the
 *	platformEntryData field of the TkMenuEntry record to store
 *	geometry information.
 *
 * Results:
 *	Standard TCL error.
 *
 * Side effects:
 *	Storage gets allocated. New menu entry data is put into the
 *	platformEntryData field of the mePtr.
 *
 *----------------------------------------------------------------------
 */

int
TkpMenuNewEntry(
    TkMenuEntry *mePtr)		/* The menu we are adding an entry to */
{
    EntryGeometry *geometryPtr =
	    (EntryGeometry *) ckalloc(sizeof(EntryGeometry));
    TkMenu *menuPtr = mePtr->menuPtr;

    geometryPtr->accelTextStart = 0;
    geometryPtr->accelTextWidth = 0;
    geometryPtr->nonAccelMargin = 0;
    geometryPtr->modifierWidth = 0;
    geometryPtr->modifierNum = 0;
    geometryPtr->accelGlyph = 0;
    mePtr->platformEntryData = (TkMenuPlatformEntryData) geometryPtr;
    if (!(menuPtr->menuFlags & MENU_RECONFIGURE_PENDING)) {
	menuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, (ClientData) menuPtr);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_MacOSXTurnOffMenus --
 *
 *	Turns off all the menu drawing code. This is more than just disabling
 *	the "menu" command, this means that Tk will NEVER touch the menubar.
 *	It is needed in the Plugin, where Tk does not own the menubar.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A flag is set which will disable all menu drawing.
 *
 *----------------------------------------------------------------------
 */

void
Tk_MacOSXTurnOffMenus(void)
{
    gNoTkMenus = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuBarWhenIdle --
 *
 *	Update the menu bar next time there is an idle event.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Menu bar is redrawn.
 *
 *----------------------------------------------------------------------
 */

void
DrawMenuBarWhenIdle(
    ClientData clientData)	/* ignored here */
{
    TkMenuReferences *menuRefPtr;
    TkMenu *appleMenuPtr, *helpMenuPtr, *menuBarPtr = NULL;
    MenuHandle macMenuHdl;
    Tcl_HashEntry *hashEntryPtr;

    /*
     * If we have been turned off, exit.
     */

    if (gNoTkMenus) {
	return;
    }

    /*
     * We need to clear the apple and help menus of any extra items.
     */

    if (currentAppleMenuID != 0) {
	hashEntryPtr = Tcl_FindHashEntry(&commandTable,
		(char*)(intptr_t)currentAppleMenuID);
	appleMenuPtr = (TkMenu *) Tcl_GetHashValue(hashEntryPtr);
	TkpDestroyMenu(appleMenuPtr);
	TkpNewMenu(appleMenuPtr);
	appleMenuPtr->menuFlags &= ~MENU_APPLE_MENU;
	appleMenuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, (ClientData) appleMenuPtr);
    }

    if (currentHelpMenuID != 0) {
	hashEntryPtr = Tcl_FindHashEntry(&commandTable,
		(char*)(intptr_t)currentHelpMenuID);
	helpMenuPtr = (TkMenu *) Tcl_GetHashValue(hashEntryPtr);
	TkpDestroyMenu(helpMenuPtr);
	TkpNewMenu(helpMenuPtr);
	helpMenuPtr->menuFlags &= ~MENU_HELP_MENU;
	helpMenuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
	Tcl_DoWhenIdle(ReconfigureMacintoshMenu,
		(ClientData) helpMenuPtr);
    }

    /*
     * We need to find the clone of this menu that is the menubar.
     * Once we do that, for every cascade in the menu, we need to
     * insert the Mac menu in the Mac menubar. Finally, we need
     * to redraw the menubar.
     */

    menuRefPtr = NULL;
    if (currentMenuBarName != NULL) {
	menuRefPtr = TkFindMenuReferences(currentMenuBarInterp,
		currentMenuBarName);
    }
    if (menuRefPtr) {
	TkMenu *menuPtr;
	TkMenu *cascadeMenuPtr;
	char *appleMenuName, *helpMenuName;
	int appleIndex = -1, helpIndex = -1, i;

	menuPtr = menuRefPtr->menuPtr;
	if (menuPtr != NULL) {
	    TkMenuReferences *specialMenuRefPtr;
	    TkMenuEntry *specialEntryPtr;

	    appleMenuName = ckalloc(strlen(currentMenuBarName) + 1 +
		    strlen(".apple") + 1);
	    sprintf(appleMenuName, "%s.apple", Tk_PathName(menuPtr->tkwin));
	    specialMenuRefPtr = TkFindMenuReferences(currentMenuBarInterp,
		    appleMenuName);
	    if ((specialMenuRefPtr != NULL)
		    && (specialMenuRefPtr->menuPtr != NULL)) {
		for (specialEntryPtr = specialMenuRefPtr->parentEntryPtr;
			specialEntryPtr != NULL;
			specialEntryPtr = specialEntryPtr->nextCascadePtr) {
		    if (specialEntryPtr->menuPtr == menuPtr) {
			appleIndex = specialEntryPtr->index;
			break;
		    }
		}
	    }
	    ckfree(appleMenuName);

	    helpMenuName = ckalloc(strlen(currentMenuBarName) + 1 +
		    strlen(".help") + 1);
	    sprintf(helpMenuName, "%s.help", Tk_PathName(menuPtr->tkwin));
	    specialMenuRefPtr = TkFindMenuReferences(currentMenuBarInterp,
		    helpMenuName);
	    if ((specialMenuRefPtr != NULL)
		    && (specialMenuRefPtr->menuPtr != NULL)) {
		for (specialEntryPtr = specialMenuRefPtr->parentEntryPtr;
			specialEntryPtr != NULL;
			specialEntryPtr = specialEntryPtr->nextCascadePtr) {
		    if (specialEntryPtr->menuPtr == menuPtr) {
			helpIndex = specialEntryPtr->index;
			break;
		    }
		}
	    }
	    ckfree(helpMenuName);
	}

	for (menuBarPtr = menuPtr;
		(menuBarPtr != NULL) && (menuBarPtr->menuType != MENUBAR);
		menuBarPtr = menuBarPtr->nextInstancePtr) {
	    /*
	     * Null loop body.
	     */
	}

	if (menuBarPtr) {
	    if (menuBarPtr->tearoff != menuPtr->tearoff) {
		if (menuBarPtr->tearoff) {
		    appleIndex = (-1 == appleIndex) ? appleIndex
			    : appleIndex + 1;
		    helpIndex = (-1 == helpIndex) ? helpIndex
			    : helpIndex + 1;
		} else {
		    appleIndex = (-1 == appleIndex) ? appleIndex
			    : appleIndex - 1;
		    helpIndex = (-1 == helpIndex) ? helpIndex
			    : helpIndex - 1;
		}
	    }
	    ClearMenuBar();

	    if (appleIndex == -1) {
		InsertMenu(tkAppleMenu, 0);
		currentAppleMenuID = 0;
		tkCurrentAppleMenu = tkAppleMenu;
	    } else {
		short appleID;

		appleMenuPtr = menuBarPtr->entries[appleIndex]
			->childMenuRefPtr->menuPtr;
		TkpDestroyMenu(appleMenuPtr);
		TkMacOSXGetNewMenuID(appleMenuPtr->interp, appleMenuPtr, 0,
			&appleID);
		macMenuHdl = NewMenu(appleID, "\p\024");
		appleMenuPtr->platformData =
			(TkMenuPlatformData) ckalloc(sizeof(MacMenu));
		((MacMenu *)appleMenuPtr->platformData)->menuHdl
			= macMenuHdl;
		appleMenuPtr->menuFlags |= MENU_APPLE_MENU;
		if (!(appleMenuPtr->menuFlags
			& MENU_RECONFIGURE_PENDING)) {
		    appleMenuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
		    Tcl_DoWhenIdle(ReconfigureMacintoshMenu,
			    (ClientData) appleMenuPtr);
		}
		InsertMenu(macMenuHdl, 0);
		RecursivelyInsertMenu(appleMenuPtr);
		currentAppleMenuID = appleID;
		tkCurrentAppleMenu = macMenuHdl;
	    }
	    if (helpIndex == -1) {
		currentHelpMenuID = 0;
	    }

	    for (i = 0; i < menuBarPtr->numEntries; i++) {
		if (i == appleIndex) {
		    if (menuBarPtr->entries[i]->state == ENTRY_DISABLED) {
			DisableMenuItem(((MacMenu *) menuBarPtr->entries[i]
				->childMenuRefPtr->menuPtr
				->platformData)->menuHdl, 0);
		    } else {
			EnableMenuItem(((MacMenu *) menuBarPtr->entries[i]
				->childMenuRefPtr->menuPtr
				->platformData)->menuHdl, 0);
		    }
		    continue;
		} else if (i == helpIndex) {
		    TkMenu *helpMenuPtr = menuBarPtr->entries[i]
			    ->childMenuRefPtr->menuPtr;

		    if (helpMenuPtr == NULL) {
			continue;
		    }
		    helpMenuPtr->menuFlags |= MENU_HELP_MENU;
		    if (!(helpMenuPtr->menuFlags
			    & MENU_RECONFIGURE_PENDING)) {
			helpMenuPtr->menuFlags
				|= MENU_RECONFIGURE_PENDING;
			Tcl_DoWhenIdle(ReconfigureMacintoshMenu,
				(ClientData) helpMenuPtr);
		    }
		    macMenuHdl =
			    ((MacMenu *) helpMenuPtr->platformData)->menuHdl;
		    currentHelpMenuID = GetMenuID(macMenuHdl);
		} else if (menuBarPtr->entries[i]->type
			== CASCADE_ENTRY) {
		    if ((menuBarPtr->entries[i]->childMenuRefPtr != NULL)
			    && menuBarPtr->entries[i]->childMenuRefPtr
			    ->menuPtr != NULL) {
			cascadeMenuPtr = menuBarPtr->entries[i]
				->childMenuRefPtr->menuPtr;
			macMenuHdl = ((MacMenu *) cascadeMenuPtr
				->platformData)->menuHdl;
			DeleteMenu(GetMenuID(macMenuHdl));
			InsertMenu(macMenuHdl, 0);
			RecursivelyInsertMenu(cascadeMenuPtr);
			if (menuBarPtr->entries[i]->state == ENTRY_DISABLED) {
			    DisableMenuItem(((MacMenu *) menuBarPtr->entries[i]
				    ->childMenuRefPtr->menuPtr
				    ->platformData)->menuHdl, 0);
			} else {
			    EnableMenuItem(((MacMenu *) menuBarPtr->entries[i]
				    ->childMenuRefPtr->menuPtr
				    ->platformData)->menuHdl, 0);
			 }
		    }
		}
	    }
	}
    }
    if (!menuRefPtr || !menuBarPtr) {
	SetDefaultMenubar();
    }
    DrawMenuBar();
    menuBarFlags &= ~MENUBAR_REDRAW_PENDING;
}

/*
 *----------------------------------------------------------------------
 *
 * RecursivelyInsertMenu --
 *
 *	Puts all of the cascades of this menu in the Mac hierarchical list.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The menubar is changed.
 *
 *----------------------------------------------------------------------
 */

void
RecursivelyInsertMenu(
    TkMenu *menuPtr)		/* All of the cascade items in this menu
				 * will be inserted into the mac menubar. */
{
    int i;
    TkMenu *cascadeMenuPtr;
    MenuHandle macMenuHdl;

    for (i = 0; i < menuPtr->numEntries; i++) {
	if (menuPtr->entries[i]->type == CASCADE_ENTRY) {
	    if ((menuPtr->entries[i]->childMenuRefPtr != NULL) &&
		    (menuPtr->entries[i]->childMenuRefPtr->menuPtr != NULL)) {
		cascadeMenuPtr = menuPtr->entries[i]->childMenuRefPtr->menuPtr;
		macMenuHdl =
			((MacMenu *) cascadeMenuPtr->platformData)->menuHdl;
		InsertMenu(macMenuHdl, -1);
		RecursivelyInsertMenu(cascadeMenuPtr);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * RecursivelyDeleteMenu --
 *
 *	Takes all of the cascades of this menu out of the Mac hierarchical
 *	list.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The menubar is changed.
 *
 *----------------------------------------------------------------------
 */

void
RecursivelyDeleteMenu(
    TkMenu *menuPtr)		/* All of the cascade items in this menu
				 * will be deleted from the mac menubar. */
{
    int i;
    TkMenu *cascadeMenuPtr;
    MenuHandle macMenuHdl;

    for (i = 0; i < menuPtr->numEntries; i++) {
	if (menuPtr->entries[i]->type == CASCADE_ENTRY) {
	    if ((menuPtr->entries[i]->childMenuRefPtr != NULL) &&
		    (menuPtr->entries[i]->childMenuRefPtr->menuPtr != NULL)) {
		cascadeMenuPtr = menuPtr->entries[i]->childMenuRefPtr->menuPtr;
		macMenuHdl =
			((MacMenu *) cascadeMenuPtr->platformData)->menuHdl;
		DeleteMenu(GetMenuID(macMenuHdl));
		RecursivelyDeleteMenu(cascadeMenuPtr);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * SetDefaultMenubar --
 *
 *	Puts the Apple, File and Edit menus into the Macintosh menubar.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The menubar is changed.
 *
 *----------------------------------------------------------------------
 */

void
SetDefaultMenubar(void)
{
    if (currentMenuBarName != NULL) {
	ckfree(currentMenuBarName);
	currentMenuBarName = NULL;
    }
    currentMenuBarOwner = NULL;
    ClearMenuBar();
    InsertMenu(tkAppleMenu, 0);
    InsertMenu(tkFileMenu, 0);
    InsertMenu(tkEditMenu, 0);
    if (!(menuBarFlags & MENUBAR_REDRAW_PENDING)) {
	Tcl_DoWhenIdle(DrawMenuBarWhenIdle, NULL);
	menuBarFlags |= MENUBAR_REDRAW_PENDING;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpSetMainMenubar --
 *
 *	Puts the menu associated with a window into the menubar. Should
 *	only be called when the window is in front.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The menubar is changed.
 *
 *----------------------------------------------------------------------
 */

void
TkpSetMainMenubar(
    Tcl_Interp *interp,		/* The interpreter of the application */
    Tk_Window tkwin,		/* The frame we are setting up */
    char *menuName)		/* The name of the menu to put in front.
				 * If NULL, use the default menu bar.
				 */
{
    TkWindow *winPtr = (TkWindow *) tkwin;
    WindowRef macWindowPtr;
    WindowRef frontNonFloating;

    macWindowPtr = TkMacOSXDrawableWindow(winPtr->window);

    frontNonFloating = ActiveNonFloatingWindow();
    if ((macWindowPtr == NULL) || (macWindowPtr != frontNonFloating)) {
	return;
    }

    if ((currentMenuBarInterp != interp) || (currentMenuBarOwner != tkwin)
	    || (currentMenuBarName == NULL) || (menuName == NULL)
	    || (strcmp(menuName, currentMenuBarName) != 0)) {
	Tk_Window searchWindow;
	TopLevelMenubarList *listPtr;

	if (currentMenuBarName != NULL) {
	    ckfree(currentMenuBarName);
	}

	if (menuName == NULL) {
	    searchWindow = tkwin;
	    if (strcmp(Tk_Class(searchWindow), "Menu") == 0) {
		TkMenuReferences *menuRefPtr;

		menuRefPtr = TkFindMenuReferences(interp, Tk_PathName(tkwin));
		if (menuRefPtr != NULL) {
		    TkMenu *menuPtr = menuRefPtr->menuPtr;

		    if (menuPtr != NULL) {
			searchWindow = menuPtr->masterMenuPtr->tkwin;
		    }
		}
	    }
	    for (; searchWindow != NULL;
		    searchWindow = Tk_Parent(searchWindow)) {
		for (listPtr = windowListPtr; listPtr != NULL;
			listPtr = listPtr->nextPtr) {
		    if (listPtr->tkwin == searchWindow) {
			break;
		    }
		}
		if (listPtr != NULL) {
		    menuName = Tk_PathName(
			    listPtr->menuPtr->masterMenuPtr->tkwin);
		    break;
		}
	    }
	}

	if (menuName == NULL) {
	    currentMenuBarName = NULL;
	} else {
	    currentMenuBarName = ckalloc(strlen(menuName) + 1);
	    strcpy(currentMenuBarName, menuName);
	}
	currentMenuBarOwner = tkwin;
	currentMenuBarInterp = interp;
    }
    if (!(menuBarFlags & MENUBAR_REDRAW_PENDING)) {
	Tcl_DoWhenIdle(DrawMenuBarWhenIdle, NULL);
	menuBarFlags |= MENUBAR_REDRAW_PENDING;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpSetWindowMenuBar --
 *
 *	Associates a given menu with a window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	On Windows and UNIX, associates the platform menu with the
 *	platform window.
 *
 *----------------------------------------------------------------------
 */

void
TkpSetWindowMenuBar(
    Tk_Window tkwin,		/* The window we are setting the menu in */
    TkMenu *menuPtr)		/* The menu we are setting */
{
    TopLevelMenubarList *listPtr, *prevPtr;

    /*
     * Remove any existing reference to this window.
     */

    for (prevPtr = NULL, listPtr = windowListPtr;
	    listPtr != NULL;
	    prevPtr = listPtr, listPtr = listPtr->nextPtr) {
	if (listPtr->tkwin == tkwin) {
	    break;
	}
    }

    if (listPtr != NULL) {
	if (prevPtr != NULL) {
	    prevPtr->nextPtr = listPtr->nextPtr;
	} else {
	    windowListPtr = listPtr->nextPtr;
	}
	ckfree((char *) listPtr);
    }

    if (menuPtr != NULL) {
	listPtr = (TopLevelMenubarList *) ckalloc(sizeof(TopLevelMenubarList));
	listPtr->nextPtr = windowListPtr;
	windowListPtr = listPtr;
	listPtr->tkwin = tkwin;
	listPtr->menuPtr = menuPtr;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * EventuallyInvokeMenu --
 *
 *	This IdleTime callback actually invokes the menu command
 *	scheduled in TkMacOSXDispatchMenuEvent.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands get executed.
 *
 *----------------------------------------------------------------------
 */

void
EventuallyInvokeMenu (
    ClientData data)
{
    struct MenuCommandHandlerData *realData =
	    (struct MenuCommandHandlerData *) data;
    int code;

    code = TkInvokeMenu(realData->menuPtr->interp, realData->menuPtr,
	    realData->index);

    if (code != TCL_OK && code != TCL_CONTINUE && code != TCL_BREAK) {
	Tcl_AddErrorInfo(realData->menuPtr->interp, "\n    (menu invoke)");
	Tcl_BackgroundError(realData->menuPtr->interp);
    }

    if (realData->menuPtr->tkwin) {
	RecursivelyClearActiveMenu(realData->menuPtr);
    }
    TkMacOSXClearMenubarActive();

    Tcl_Release(realData->menuPtr->interp);
    Tcl_Release(realData->menuPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXDispatchMenuEvent --
 *
 *	Given a menu id and an item, dispatches the command associated
 *	with it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands for the event are scheduled for execution at idle time.
 *
 *----------------------------------------------------------------------
 */

int
TkMacOSXDispatchMenuEvent(
    int menuID,			/* The menu id of the menu we are invoking */
    int index)			/* The one-based index of the item that was
				 * selected. */
{
    int result = TCL_OK;

    if (menuID != 0) {
	if (menuID == kHMHelpMenuID) {
	    if (currentMenuBarOwner != NULL) {
		TkMenuReferences *helpMenuRef;
		char *helpMenuName = ckalloc(strlen(currentMenuBarName)
			+ strlen(".help") + 1);

		sprintf(helpMenuName, "%s.help", currentMenuBarName);
		helpMenuRef = TkFindMenuReferences(currentMenuBarInterp,
			helpMenuName);
		ckfree(helpMenuName);
		if ((helpMenuRef != NULL) && (helpMenuRef->menuPtr != NULL)) {
		    MenuRef outHelpMenu;
		    MenuItemIndex itemIndex;
		    int newIndex;

		    HMGetHelpMenu(&outHelpMenu, &itemIndex);
		    newIndex = index - itemIndex;
		    result = TkInvokeMenu(currentMenuBarInterp,
			    helpMenuRef->menuPtr, newIndex);
		}
	    }
	} else {
	    Tcl_HashEntry *commandEntryPtr =
		    Tcl_FindHashEntry(&commandTable, (char*)(intptr_t)menuID);
	    if (commandEntryPtr != NULL) {
		TkMenu *menuPtr = (TkMenu *) Tcl_GetHashValue(commandEntryPtr);

		if ((currentAppleMenuID == menuID)
			&& (index > menuPtr->numEntries + 1)) {
		    /*
		     * We don't need to do anything here, the standard
		     * Application event handler will open the built-in
		     * Apple menu item for us.
		     */
		    result = TCL_OK;
		} else {
		    struct MenuCommandHandlerData *data
			    = (struct MenuCommandHandlerData *)
			    ckalloc(sizeof(struct MenuCommandHandlerData));

		    Tcl_Preserve(menuPtr->interp);
		    Tcl_Preserve(menuPtr);
		    data->menuPtr = menuPtr;
		    data->index = index - 1;
		    Tcl_DoWhenIdle(EventuallyInvokeMenu,
			    (ClientData) data);
		    /* result = TkInvokeMenu(menuPtr->interp, menuPtr, index - 1); */
		}
	    } else {
		return TCL_ERROR;
	    }
	}
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * GetMenuIndicatorGeometry --
 *
 *	Gets the width and height of the indicator area of a menu.
 *
 * Results:
 *	widthPtr and heightPtr are set.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
GetMenuIndicatorGeometry (
    TkMenu *menuPtr,		/* The menu we are drawing */
    TkMenuEntry *mePtr,		/* The entry we are measuring */
    Tk_Font tkfont,		/* Precalculated font */
    const Tk_FontMetrics *fmPtr,/* Precalculated font metrics */
    int *widthPtr,		/* The resulting width */
    int *heightPtr)		/* The resulting height */
{
    *heightPtr = fmPtr->linespace + menuItemExtraHeight;
    if (IS_THEME_MENU_FONT(tkfont)) {
	*widthPtr = menuMarkColumnWidth;
    } else {
	const char markChar = FindMarkCharacter(mePtr);
	const char *markUtf = NULL;
	int len;

	len = GetUtfMarkCharacter(markChar, &markUtf);
	*widthPtr = Tk_TextWidth(tkfont, markUtf, len) + 2*menuMarkIndent;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetMenuAccelGeometry --
 *
 *	Gets the width and height of the accelerator area of a menu.
 *
 * Results:
 *	widthPtr and heightPtr are set.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
GetMenuAccelGeometry (
    TkMenu *menuPtr,		/* The menu we are measuring */
    TkMenuEntry *mePtr,		/* The entry we are measuring */
    Tk_Font tkfont,		/* The precalculated font */
    const Tk_FontMetrics *fmPtr,/* The precalculated font metrics */
    int *modWidthPtr,		/* The width of all of the key
				 * modifier symbols. */
    int *textWidthPtr,		/* The resulting width */
    int *heightPtr)		/* The resulting height */
{
    *heightPtr = fmPtr->linespace + menuItemExtraHeight;
    *modWidthPtr = menuSymbols[COMMAND_SYMBOL].width;
    *textWidthPtr = 0;
    if (mePtr->type != CASCADE_ENTRY && mePtr->accelLength > 0) {
	const char *accel = (mePtr->accelPtr == NULL) ? ""
		: Tcl_GetString(mePtr->accelPtr);
	EntryGeometry *geometryPtr = (EntryGeometry*)mePtr->platformEntryData;

	if (IS_THEME_MENU_FONT(tkfont)) {
	    CFStringRef cfStr;
	    int width = 0;
	    int maxWidth = ((TkFont *)tkfont)->fm.maxWidth;

	    if (geometryPtr->accelGlyph) {
		cfStr = CFStringCreateWithBytes(NULL,
			(UInt8*)&geometryPtr->accelGlyph, 1,
			kTextEncodingMacKeyboardGlyphs, false);
		if (cfStr) {
		    width = MeasureThemeText(cfStr, kThemeMenuItemCmdKeyFont);
		    CFRelease(cfStr);
		}
	    }
	    if ((mePtr->entryFlags & ENTRY_ACCEL_MASK) == 0) {
		if (!geometryPtr->accelGlyph) {
		     width = Tk_TextWidth(tkfont, accel, mePtr->accelLength);
		 }
		*textWidthPtr = maxWidth;
		if (width < maxWidth) {
		    *modWidthPtr = 0;
		} else {
		    *modWidthPtr = width - maxWidth;
		}
	    } else {
		if (!geometryPtr->accelGlyph) {
		    width = Tk_TextWidth(tkfont, accel +
			    geometryPtr->accelTextStart, mePtr->accelLength -
			    geometryPtr->accelTextStart);
		}
		if (width < maxWidth) {
		    *textWidthPtr = maxWidth;
		} else {
		    *textWidthPtr = width;
		}
		if (geometryPtr->modifierNum) {
		    *modWidthPtr = geometryPtr->modifierWidth;
		}
	    }
	} else {
	    *textWidthPtr = Tk_TextWidth(tkfont, accel, mePtr->accelLength);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetTearoffEntryGeometry --
 *
 *	Gets the width and height of of a tearoff entry.
 *
 * Results:
 *	widthPtr and heightPtr are set.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
GetTearoffEntryGeometry (
    TkMenu *menuPtr,		/* The menu we are drawing */
    TkMenuEntry *mePtr,		/* The entry we are measuring */
    Tk_Font tkfont,		/* The precalculated font */
    const Tk_FontMetrics *fmPtr,/* The precalculated font metrics */
    int *widthPtr,		/* The resulting width */
    int *heightPtr)		/* The resulting height */
{
#ifdef USE_TK_MDEF
    const int useMDEF = ((MacMenu *) menuPtr->platformData)->useMDEF;
#endif
    if (useMDEF && menuPtr->menuType != TEAROFF_MENU) {
	*heightPtr = fmPtr->linespace + menuItemExtraHeight;
	*widthPtr = menuPtr->totalWidth;
    } else {
	*widthPtr = *heightPtr = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetMenuSeparatorGeometry --
 *
 *	Gets the width and height of menu separator.
 *
 * Results:
 *	widthPtr and heightPtr are set.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
GetMenuSeparatorGeometry(
    TkMenu *menuPtr,		/* The menu we are drawing */
    TkMenuEntry *mePtr,		/* The entry we are measuring */
    Tk_Font tkfont,		/* The precalculated font */
    const Tk_FontMetrics *fmPtr,/* The precalcualted font metrics */
    int *widthPtr,		/* The resulting width */
    int *heightPtr)		/* The resulting height */
{
    *widthPtr = 0;
    *heightPtr = menuSeparatorHeight;
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuEntryIndicator --
 *
 *	This procedure draws the indicator part of a menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

void
DrawMenuEntryIndicator(
    TkMenu *menuPtr,		/* The menu we are drawing */
    TkMenuEntry *mePtr,		/* The entry we are drawing */
    Drawable d,			/* The drawable we are drawing */
    GC gc,			/* The GC we are drawing with */
    GC indicatorGC,		/* The GC to use for the indicator */
    Tk_Font tkfont,		/* The precalculated font */
    const Tk_FontMetrics *fmPtr,/* The precalculated font metrics */
    int x,			/* topleft hand corner of entry */
    int y,			/* topleft hand corner of entry */
    int width,			/* width of entry */
    int height)			/* height of entry */
{
    if ((mePtr->type == CHECK_BUTTON_ENTRY) ||
	    (mePtr->type == RADIO_BUTTON_ENTRY)) {
	if (mePtr->indicatorOn && (mePtr->entryFlags & ENTRY_SELECTED)) {
	    short mark;
	    int baseline = y + (height + fmPtr->ascent - fmPtr->descent)/2;

	    GetItemMark(((MacMenu *) menuPtr->platformData)->menuHdl,
		    mePtr->index + 1, &mark);
	    if (IS_THEME_MENU_FONT(tkfont)) {
		ThemeFontID font = kThemeMenuItemMarkFont;
		TextEncoding encoding = GetApplicationTextEncoding();
		CFStringRef cfStr;
		ThemeDrawState drawState;
		Rect bounds = {y, x + menuMarkIndent, y + height, x + width};

		if (mark < kSpaceCharCode) {
		    font = kThemeMenuItemCmdKeyFont;
		    encoding = kTextEncodingMacKeyboardGlyphs;
		}
		switch (mePtr->state) {
		    case ENTRY_ACTIVE:
			drawState = kThemeStatePressed;
			break;
		    case ENTRY_DISABLED:
			drawState = kThemeStateInactive;
			break;
		    default:
			drawState = kThemeStateActive;
			break;
		}
		cfStr = CFStringCreateWithBytes(NULL, (UInt8*)&mark, 1,
			encoding, false);
		if (cfStr) {
		    DrawThemeText(d, gc, cfStr, font, drawState, &bounds,
			    baseline, teFlushDefault);
		    CFRelease(cfStr);
		}
	    } else if (mark != 0) {
		const char *markUtf = NULL;
		int len;

		len = GetUtfMarkCharacter(mark, &markUtf);
		Tk_DrawChars(menuPtr->display, d, gc, tkfont, markUtf, len,
		    x + menuMarkIndent, baseline);
	    }
	}
    }
}

#ifdef USE_TK_MDEF
/*
 *----------------------------------------------------------------------
 *
 * DrawMenuBackground --
 *
 *	If Appearance is present, draws the Appearance background
 *
 * Results:
 *	Nothing
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */
void
DrawMenuBackground(
    TkMenu *menuPtr,
    Rect     *menuRectPtr,	/* The menu rect */
    Drawable d)			/* What we are drawing into */
{
    Tk_3DBorder border;

    EraseMenuBackground(((MacMenu *) menuPtr->platformData)->menuHdl,
	    menuRectPtr, ((MacDrawable*)d)->context);
    border = Tk_Get3DBorderFromObj(menuPtr->tkwin, menuPtr->borderPtr);
    Tk_Fill3DRectangle(menuPtr->tkwin, d, border,
	    menuRectPtr->left, menuRectPtr->top,
	    menuRectPtr->right - menuRectPtr->left,
	    menuRectPtr->bottom - menuRectPtr->top, 0, TK_RELIEF_FLAT);
}
#endif /* USE_TK_MDEF */

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuEntryAccelerator --
 *
 *	This procedure draws the accelerator part of a menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

void
DrawMenuEntryAccelerator(
    TkMenu *menuPtr,		/* The menu we are drawing */
    TkMenuEntry *mePtr,		/* The entry we are drawing */
    Drawable d,			/* The drawable we are drawing in */
    GC gc,			/* The gc to draw into */
    Tk_Font tkfont,		/* The precalculated font */
    const Tk_FontMetrics *fmPtr,/* The precalculated font metrics */
    Tk_3DBorder activeBorder,	/* border for menu background */
    int x,			/* The left side of the entry */
    int y,			/* The top of the entry */
    int width,			/* The width of the entry */
    int height,			/* The height of the entry */
    int drawArrow)		/* Whether or not to draw cascade arrow */
{
    if (mePtr->type != CASCADE_ENTRY && mePtr->accelLength > 0) {
	const char *accel = (mePtr->accelPtr == NULL) ? ""
		: Tcl_GetString(mePtr->accelPtr);
	EntryGeometry *geometryPtr = (EntryGeometry*)mePtr->platformEntryData;
	int leftEdge = x + width - geometryPtr->accelTextWidth;
	int baseline = y + (height + fmPtr->ascent - fmPtr->descent) / 2;

	if (IS_THEME_MENU_FONT(tkfont)) {
	    CFStringRef cfStr;
	    ThemeDrawState drawState;

	    switch (mePtr->state) {
		case ENTRY_ACTIVE:
		    drawState = kThemeStatePressed;
		    break;
		case ENTRY_DISABLED:
		    drawState = kThemeStateInactive;
		    break;
		default:
		    drawState = kThemeStateActive;
		    break;
	    }
	    if ((mePtr->entryFlags & ENTRY_ACCEL_MASK) == 0) {
		leftEdge -= geometryPtr->modifierWidth;
	    }
	    if (geometryPtr->accelGlyph) {
		Rect bounds = {y, leftEdge, y + height, leftEdge +
			geometryPtr->accelTextWidth};

		cfStr = CFStringCreateWithBytes(NULL,
			(UInt8*)&geometryPtr->accelGlyph, 1,
			kTextEncodingMacKeyboardGlyphs, false);
		if (cfStr) {
		    DrawThemeText(d, gc, cfStr, kThemeMenuItemCmdKeyFont,
			    drawState, &bounds, baseline, teFlushDefault);
		    CFRelease(cfStr);
		}
	    } else {
		Tk_DrawChars(menuPtr->display, d, gc, tkfont, accel + 
			geometryPtr->accelTextStart, mePtr->accelLength -
			geometryPtr->accelTextStart, leftEdge, baseline);
	    }
	    if (geometryPtr->modifierNum) {
		Rect bounds = {y, leftEdge - geometryPtr->modifierWidth,
			y + height, leftEdge};

		cfStr = CFStringCreateWithCharacters(NULL,
			geometryPtr->modifierUniChars,
			geometryPtr->modifierNum);
		if (cfStr) {
		    DrawThemeText(d, gc, cfStr, kThemeMenuItemCmdKeyFont,
			    drawState, &bounds, baseline, teFlushDefault);
		    CFRelease(cfStr);
		}
	    }
	} else {
	    Tk_DrawChars(menuPtr->display, d, gc, tkfont, accel,
		    mePtr->accelLength, leftEdge, baseline);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuSeparator --
 *
 *	The menu separator is drawn.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

void
DrawMenuSeparator(
    TkMenu *menuPtr,		/* The menu we are drawing */
    TkMenuEntry *mePtr,		/* The entry we are drawing */
    Drawable d,			/* The drawable we are drawing into */
    GC gc,			/* The gc we are drawing with */
    Tk_Font tkfont,		/* The precalculated font */
    const Tk_FontMetrics *fmPtr,/* The precalculated font metrics */
    int x,			/* left coordinate of entry */
    int y,			/* top coordinate of entry */
    int width,			/* width of entry */
    int height)			/* height of entry */
{
    TkMacOSXDrawingContext dc;
    Rect r;

    r.top = y;
    r.left = x;
    r.bottom = y + height;
    r.right = x + width;
    TkMacOSXSetupDrawingContext(d, gc, 1, &dc);
    ChkErr(DrawThemeMenuSeparator, &r);
    TkMacOSXRestoreDrawingContext(&dc);
}

#ifdef USE_TK_MDEF
/*
 *----------------------------------------------------------------------
 *
 * AppearanceEntryDrawWrapper --
 *
 *	It routes to the Appearance Managers DrawThemeEntry, which will
 *	then call us back after setting up the drawing context.
 *
 * Results:
 *	A menu entry is drawn
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */
void
AppearanceEntryDrawWrapper(
    TkMenuEntry *mePtr,
    Rect *menuRectPtr,
    MenuTrackingData *mtdPtr,
    Drawable d,
    Tk_FontMetrics *fmPtr,
    Tk_Font tkfont,
    int erase)
{
    MenuEntryUserData meData;
    Rect itemRect;
    ThemeMenuState theState;
    ThemeMenuItemType theType;
    Tk_FontMetrics entryMetrics;

    meData.mePtr = mePtr;
    meData.mdefDrawable = d;
    if (mePtr->fontPtr == NULL) {
	meData.fmPtr = fmPtr;
	meData.tkfont = tkfont;
    } else {
	meData.tkfont = Tk_GetFontFromObj(mePtr->menuPtr->tkwin,
		mePtr->fontPtr);
	Tk_GetFontMetrics(meData.tkfont, &entryMetrics);
	fmPtr = &entryMetrics;
    }
    itemRect.left = menuRectPtr->left + mePtr->x;
    itemRect.top = mtdPtr->virtualMenuTop + mePtr->y;
    itemRect.right = mePtr->entryFlags & ENTRY_LAST_COLUMN ?
	    menuRectPtr->right : itemRect.left + mePtr->width;
    itemRect.bottom = itemRect.top + mePtr->height;

    if (mePtr->state == ENTRY_ACTIVE) {
	theState = kThemeMenuSelected;
    } else if (mePtr->state == ENTRY_DISABLED) {
	theState = kThemeMenuDisabled;
    } else {
	theState = kThemeMenuActive;
    }
    if (mePtr->type == CASCADE_ENTRY) {
	theType = kThemeMenuItemHierarchical;
    } else {
	theType = kThemeMenuItemPlain;
    }
    if (erase) {
	DisableScreenUpdates();
	DrawMenuBackground(mePtr->menuPtr, &itemRect, d);
    }
    DrawThemeMenuItem(menuRectPtr, &itemRect,
	mtdPtr->virtualMenuTop, mtdPtr->virtualMenuBottom, theState,
	theType | kThemeMenuItemNoBackground, tkThemeMenuItemDrawingUPP,
	(unsigned long) &meData);
    if (erase) {
	EnableScreenUpdates();
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ThemeMenuItemDrawingProc --
 *
 *	This routine is called from the Appearance DrawThemeMenuEntry
 *
 * Results:
 *	A menu entry is drawn
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */
pascal void
ThemeMenuItemDrawingProc(
    const Rect *inBounds,
    SInt16 inDepth,
    Boolean inIsColorDevice,
    SInt32 inUserData)
{
    MenuEntryUserData *meData = (MenuEntryUserData *) inUserData;

    TkpDrawMenuEntry(meData->mePtr, meData->mdefDrawable, meData->tkfont,
	    meData->fmPtr, inBounds->left, inBounds->top, inBounds->right -
	    inBounds->left + menuItemExtraWidth, inBounds->bottom -
	    inBounds->top + menuItemExtraHeight, 0, 1);
}
#endif /* USE_TK_MDEF */

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXHandleTearoffMenu() --
 *
 *	This routine sees if the MDEF has set a menu and a mouse position
 *	for tearing off and makes a tearoff menu if it has.
 *
 * Results:
 *	menuPtr->interp will have the result of the tearoff command.
 *
 * Side effects:
 *	A new tearoff menu is created if it is supposed to be.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXHandleTearoffMenu(void)
{
    /*
     * Obsolete: Nothing to do.
     */
}

/*
 *--------------------------------------------------------------
 *
 * TkpInitializeMenuBindings --
 *
 *	For every interp, initializes the bindings for Windows
 *	menus. Does nothing on Mac or XWindows.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	C-level bindings are setup for the interp which will
 *	handle Alt-key sequences for menus without beeping
 *	or interfering with user-defined Alt-key bindings.
 *
 *--------------------------------------------------------------
 */

void
TkpInitializeMenuBindings(
    Tcl_Interp *interp,		/* The interpreter to set. */
    Tk_BindingTable bindingTable)
				/* The table to add to. */
{
    /*
     * Nothing to do.
     */
}

/*
 *--------------------------------------------------------------
 *
 * TkpComputeMenubarGeometry --
 *
 *	This procedure is invoked to recompute the size and
 *	layout of a menu that is a menubar clone.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Fields of menu entries are changed to reflect their
 *	current positions, and the size of the menu window
 *	itself may be changed.
 *
 *--------------------------------------------------------------
 */

void
TkpComputeMenubarGeometry(
    TkMenu *menuPtr)		/* Structure describing menu. */
{
    TkpComputeStandardMenuGeometry(menuPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DrawTearoffEntry --
 *
 *	This procedure draws a tearoff entry.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

void
DrawTearoffEntry(
    TkMenu *menuPtr,		/* The menu we are drawing */
    TkMenuEntry *mePtr,		/* The entry we are drawing */
    Drawable d,			/* The drawable we are drawing into */
    GC gc,			/* The gc we are drawing with */
    Tk_Font tkfont,		/* The font we are drawing with */
    const Tk_FontMetrics *fmPtr,/* The metrics we are drawing with */
    int x,			/* Left edge of entry. */
    int y,			/* Top edge of entry. */
    int width,			/* Width of entry. */
    int height)			/* Height of entry. */
{
    XPoint points[2];
    int margin, segmentWidth, maxX;
    Tk_3DBorder border;

    if (menuPtr->menuType != MASTER_MENU ) {
	return;
    }

    margin = fmPtr->linespace/2;
    points[0].x = x;
    points[0].y = y + height/2;
    points[1].y = points[0].y;
    segmentWidth = 6;
    maxX  = x + menuPtr->totalWidth - 1;
    border = Tk_Get3DBorderFromObj(menuPtr->tkwin, menuPtr->borderPtr);

    while (points[0].x < maxX) {
	points[1].x = points[0].x + segmentWidth;
	if (points[1].x > maxX) {
	    points[1].x = maxX;
	}
	Tk_Draw3DPolygon(menuPtr->tkwin, d, border, points, 2, 1,
		TK_RELIEF_RAISED);
	points[0].x += 2*segmentWidth;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXSetHelpMenuItemCount --
 *
 *	Has to be called after the first call to InsertMenu. Sets
 *	up the global variable for the number of items in the
 *	unmodified help menu.
 *	NB. Nobody uses this any more, since you can get the number
 *	of system help items from HMGetHelpMenu trivially.
 *	But it is in the stubs table...
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Nothing.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXSetHelpMenuItemCount(void)
{
    /*
     * Obsolete: Nothing to do.
     */
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXMenuClick --
 *
 *	Prepares a menubar for MenuSelect or MenuKey.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Any pending configurations of the menubar are completed.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXMenuClick(void)
{
    TkMenu *menuPtr;
    TkMenuReferences *menuRefPtr;

    if ((currentMenuBarInterp != NULL) && (currentMenuBarName != NULL)) {
	menuRefPtr = TkFindMenuReferences(currentMenuBarInterp,
		currentMenuBarName);
	for (menuPtr = menuRefPtr->menuPtr->masterMenuPtr;
		menuPtr != NULL; menuPtr = menuPtr->nextInstancePtr) {
	    if (menuPtr->menuType == MENUBAR) {
		CompleteIdlers(menuPtr);
		break;
	    }
	}
    }

    if (menuBarFlags & MENUBAR_REDRAW_PENDING) {
	Tcl_CancelIdleCall(DrawMenuBarWhenIdle, NULL);
	DrawMenuBarWhenIdle(NULL);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDrawMenuEntry --
 *
 *	Draws the given menu entry at the given coordinates with the
 *	given attributes.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	X Server commands are executed to display the menu entry.
 *
 *----------------------------------------------------------------------
 */

void
TkpDrawMenuEntry(
    TkMenuEntry *mePtr,		/* The entry to draw */
    Drawable d,			/* What to draw into */
    Tk_Font tkfont,		/* Precalculated font for menu */
    const Tk_FontMetrics *menuMetricsPtr,
				/* Precalculated metrics for menu */
    int x,			/* X-coordinate of topleft of entry */
    int y,			/* Y-coordinate of topleft of entry */
    int width,			/* Width of the entry rectangle */
    int height,			/* Height of the current rectangle */
    int strictMotif,		/* Boolean flag */
    int drawArrow)		/* Whether or not to draw the cascade
				 * arrow for cascade items. Only applies
				 * to Windows. */
{
    GC gc;
    TkMenu *menuPtr = mePtr->menuPtr;
    int padY = (menuPtr->menuType == MENUBAR) ? 3 : 0;
    GC indicatorGC;
    Tk_3DBorder bgBorder, activeBorder;
    const Tk_FontMetrics *fmPtr;
    Tk_FontMetrics entryMetrics;
    int adjustedY = y + padY;
    int adjustedHeight = height - 2 * padY;

    /*
     * Choose the gc for drawing the foreground part of the entry.
     * Under Appearance, we pass a null (appearanceGC) to tell
     * ourselves not to change whatever color the appearance manager has set.
     */

    if ((mePtr->state == ENTRY_ACTIVE) && !strictMotif) {
	gc = mePtr->activeGC;
	if (gc == NULL) {
	    gc = menuPtr->activeGC;
	}
    } else {
	TkMenuEntry *parentEntryPtr = GetParentMenuEntry(menuPtr);

	if (((parentEntryPtr && parentEntryPtr->state == ENTRY_DISABLED) ||
		(mePtr->state == ENTRY_DISABLED)) &&
		(menuPtr->disabledFgPtr != NULL)) {
	    gc = mePtr->disabledGC;
	    if (gc == NULL) {
		gc = menuPtr->disabledGC;
	    }
	} else {
	    gc = mePtr->textGC;
	    if (gc == NULL) {
		gc = menuPtr->textGC;
	    }
	}
    }

    indicatorGC = mePtr->indicatorGC;
    if (indicatorGC == NULL) {
	indicatorGC = menuPtr->indicatorGC;
    }

    bgBorder = Tk_Get3DBorderFromObj(menuPtr->tkwin,
	    (mePtr->borderPtr == NULL)
	    ? menuPtr->borderPtr : mePtr->borderPtr);
    if (strictMotif) {
	activeBorder = bgBorder;
    } else {
	activeBorder = Tk_Get3DBorderFromObj(menuPtr->tkwin,
	    (mePtr->activeBorderPtr == NULL)
	    ? menuPtr->activeBorderPtr : mePtr->activeBorderPtr);
    }

    if (mePtr->fontPtr == NULL) {
	fmPtr = menuMetricsPtr;
    } else {
	tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
	Tk_GetFontMetrics(tkfont, &entryMetrics);
	fmPtr = &entryMetrics;
    }

    /*
     * Need to draw the entire background, including padding. On Unix,
     * for menubars, we have to draw the rest of the entry taking
     * into account the padding.
     */

    DrawMenuEntryBackground(menuPtr, mePtr, d, activeBorder, bgBorder, x, y,
	    width, height);

    if (mePtr->type == SEPARATOR_ENTRY) {
	DrawMenuSeparator(menuPtr, mePtr, d, gc, tkfont,
		fmPtr, x, adjustedY, width, adjustedHeight);
    } else if (mePtr->type == TEAROFF_ENTRY) {
	DrawTearoffEntry(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, adjustedY,
		width, adjustedHeight);
    } else {
	DrawMenuEntryLabel(menuPtr, mePtr, d, gc, tkfont, fmPtr, x,
		adjustedY, width, adjustedHeight);
	DrawMenuEntryAccelerator(menuPtr, mePtr, d, gc, tkfont, fmPtr,
		activeBorder, x, adjustedY, width, adjustedHeight, drawArrow);
	if (!mePtr->hideMargin) {
	    DrawMenuEntryIndicator(menuPtr, mePtr, d, gc, indicatorGC, tkfont,
		    fmPtr, x, adjustedY, width, adjustedHeight);
	}
    }
}

/*
 *--------------------------------------------------------------
 *
 * TkpComputeStandardMenuGeometry --
 *
 *	This procedure is invoked to recompute the size and
 *	layout of a menu that is not a menubar clone.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Fields of menu entries are changed to reflect their
 *	current positions, and the size of the menu window
 *	itself may be changed.
 *
 *--------------------------------------------------------------
 */

void
TkpComputeStandardMenuGeometry(
    TkMenu *menuPtr)		/* Structure describing menu. */
{
    Tk_Font tkfont, menuFont;
    Tk_FontMetrics menuMetrics, entryMetrics, *fmPtr;
    int x, y, height, modifierWidth, labelWidth, indicatorSpace;
    int windowWidth, windowHeight, accelWidth, maxAccelTextWidth;
    int i, j, lastColumnBreak, maxModifierWidth, maxWidth, nonAccelMargin;
    int maxNonAccelMargin, maxEntryWithAccelWidth, maxEntryWithoutAccelWidth;
    int entryWidth, maxIndicatorSpace, borderWidth, activeBorderWidth;
    TkMenuEntry *mePtr, *columnEntryPtr;
    EntryGeometry *geometryPtr;
    int haveAccel = 0;

    if (menuPtr->tkwin == NULL) {
	return;
    }

    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
	    &borderWidth);
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
    x = y = borderWidth;
    indicatorSpace = labelWidth = accelWidth = maxAccelTextWidth = 0;
    windowHeight = windowWidth = maxWidth = lastColumnBreak = 0;
    maxModifierWidth = nonAccelMargin = maxNonAccelMargin = 0;
    maxEntryWithAccelWidth = maxEntryWithoutAccelWidth = 0;
    maxIndicatorSpace = 0;

    /*
     * On the Mac especially, getting font metrics can be quite slow,
     * so we want to do it intelligently. We are going to precalculate
     * them and pass them down to all of the measuring and drawing
     * routines. We will measure the font metrics of the menu once.
     * If an entry does not have its own font set, then we give
     * the geometry/drawing routines the menu's font and metrics.
     * If an entry has its own font, we will measure that font and
     * give all of the geometry/drawing the entry's font and metrics.
     */

    menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
    Tk_GetFontMetrics(menuFont, &menuMetrics);

    for (i = 0; i < menuPtr->numEntries; i++) {
	mePtr = menuPtr->entries[i];
	if (mePtr->type == CASCADE_ENTRY || mePtr->accelLength > 0) {
	    haveAccel = 1;
	    break;
	}
    }

    for (i = 0; i < menuPtr->numEntries; i++) {
	mePtr = menuPtr->entries[i];
	if (mePtr->fontPtr == NULL) {
	    tkfont = menuFont;
	    fmPtr = &menuMetrics;
	} else {
	    tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
	    Tk_GetFontMetrics(tkfont, &entryMetrics);
	    fmPtr = &entryMetrics;
	}

	if ((i > 0) && mePtr->columnBreak) {
	    if (maxIndicatorSpace != 0) {
		maxIndicatorSpace += 2;
	    }
	    for (j = lastColumnBreak; j < i; j++) {
		columnEntryPtr = menuPtr->entries[j];
		geometryPtr =
			(EntryGeometry *) columnEntryPtr->platformEntryData;

		columnEntryPtr->indicatorSpace = maxIndicatorSpace;
		columnEntryPtr->width = maxIndicatorSpace + maxWidth
			+ 2 * activeBorderWidth;
		geometryPtr->accelTextWidth = maxAccelTextWidth;
		geometryPtr->modifierWidth = maxModifierWidth;
		columnEntryPtr->x = x;
		columnEntryPtr->entryFlags &= ~ENTRY_LAST_COLUMN;
		if (maxEntryWithoutAccelWidth > maxEntryWithAccelWidth) {
		    geometryPtr->nonAccelMargin = maxEntryWithoutAccelWidth
			    - maxEntryWithAccelWidth;
		    if (geometryPtr->nonAccelMargin > maxNonAccelMargin) {
			geometryPtr->nonAccelMargin = maxNonAccelMargin;
		    }
		} else {
		    geometryPtr->nonAccelMargin = 0;
		}
	    }
	    x += maxIndicatorSpace + maxWidth + 2 * borderWidth;
	    windowWidth = x;
	    maxWidth = maxIndicatorSpace = maxAccelTextWidth = 0;
	    maxModifierWidth = maxNonAccelMargin = maxEntryWithAccelWidth = 0;
	    maxEntryWithoutAccelWidth = 0;
	    lastColumnBreak = i;
	    y = borderWidth;
	}
	geometryPtr = (EntryGeometry *) mePtr->platformEntryData;

	if (mePtr->type == SEPARATOR_ENTRY) {
	    GetMenuSeparatorGeometry(menuPtr, mePtr, tkfont,
		    fmPtr, &entryWidth, &height);
	    mePtr->height = height;
	} else if (mePtr->type == TEAROFF_ENTRY) {
	    GetTearoffEntryGeometry(menuPtr, mePtr, tkfont,
		    fmPtr, &entryWidth, &height);
	    mePtr->height = height;
	} else {
	    /*
	     * For each entry, compute the height required by that
	     * particular entry, plus three widths:  the width of the
	     * label, the width to allow for an indicator to be displayed
	     * to the left of the label (if any), and the width of the
	     * accelerator to be displayed to the right of the label
	     * (if any). These sizes depend, of course, on the type
	     * of the entry.
	     */

	    GetMenuLabelGeometry(mePtr, tkfont, fmPtr, &labelWidth, &height);
	    mePtr->height = height;

	    nonAccelMargin = 0;
	    if (mePtr->type == CASCADE_ENTRY) {
		GetMenuAccelGeometry(menuPtr, mePtr, tkfont, fmPtr,
			&modifierWidth, &accelWidth, &height);
	    } else if (mePtr->accelLength == 0) {
		if (haveAccel && !mePtr->hideMargin) {
		    if (IS_THEME_MENU_FONT(tkfont)) {
			nonAccelMargin = menuSymbols[COMMAND_SYMBOL].width;
		    } else {
			nonAccelMargin = Tk_TextWidth(tkfont,
				menuSymbols[COMMAND_SYMBOL].utf,
				menuSymbols[COMMAND_SYMBOL].utfLen);
		    }
		}
		accelWidth = modifierWidth = 0;
	    } else {
		GetMenuAccelGeometry(menuPtr, mePtr, tkfont,
			fmPtr, &modifierWidth, &accelWidth, &height);
		if (height > mePtr->height) {
		    mePtr->height = height;
		}
	    }

	    if (!(mePtr->hideMargin)) {
		GetMenuIndicatorGeometry(menuPtr, mePtr, tkfont,
			fmPtr, &indicatorSpace, &height);
		if (height > mePtr->height) {
		    mePtr->height = height;
		}
	    } else {
		indicatorSpace = 0;
	    }

	    if (nonAccelMargin > maxNonAccelMargin) {
		maxNonAccelMargin = nonAccelMargin;
	    }
	    if (accelWidth > maxAccelTextWidth) {
		maxAccelTextWidth = accelWidth;
	    }
	    if (modifierWidth > maxModifierWidth) {
		maxModifierWidth = modifierWidth;
	    }
	    if (indicatorSpace > maxIndicatorSpace) {
		maxIndicatorSpace = indicatorSpace;
	    }

	    entryWidth = labelWidth + modifierWidth + accelWidth
		    + nonAccelMargin;

	    if (entryWidth > maxWidth) {
		maxWidth = entryWidth;
	    }

	    if (mePtr->accelLength > 0) {
		if (entryWidth > maxEntryWithAccelWidth) {
		    maxEntryWithAccelWidth = entryWidth;
		}
	    } else {
		if (entryWidth > maxEntryWithoutAccelWidth) {
		    maxEntryWithoutAccelWidth = entryWidth;
		}
	    }
	    mePtr->height += 2 * activeBorderWidth;
	}
	mePtr->y = y;
	y += menuPtr->entries[i]->height + borderWidth;
	if (y > windowHeight) {
	    windowHeight = y;
	}
    }

    for (j = lastColumnBreak; j < menuPtr->numEntries; j++) {
	columnEntryPtr = menuPtr->entries[j];
	geometryPtr = (EntryGeometry *) columnEntryPtr->platformEntryData;

	columnEntryPtr->indicatorSpace = maxIndicatorSpace;
	columnEntryPtr->width = maxIndicatorSpace + maxWidth
		+ 2 * activeBorderWidth;
	geometryPtr->accelTextWidth = maxAccelTextWidth;
	columnEntryPtr->x = x;
	columnEntryPtr->entryFlags |= ENTRY_LAST_COLUMN;
	if (maxEntryWithoutAccelWidth > maxEntryWithAccelWidth) {
	    geometryPtr->nonAccelMargin = maxEntryWithoutAccelWidth
		    - maxEntryWithAccelWidth;
	    if (geometryPtr->nonAccelMargin > maxNonAccelMargin) {
		geometryPtr->nonAccelMargin = maxNonAccelMargin;
	    }
	} else {
	    geometryPtr->nonAccelMargin = 0;
	}
    }
    windowWidth = x + maxIndicatorSpace + maxWidth
	    + 2 * activeBorderWidth + borderWidth;
    windowHeight += borderWidth;

    /*
     * The X server doesn't like zero dimensions, so round up to at least
     * 1 (a zero-sized menu should never really occur, anyway).
     */

    if (windowWidth <= 0) {
	windowWidth = 1;
    }
    if (windowHeight <= 0) {
	windowHeight = 1;
    }
    menuPtr->totalWidth = windowWidth;
    menuPtr->totalHeight = windowHeight;
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuEntryLabel --
 *
 *	This procedure draws the label part of a menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

void
DrawMenuEntryLabel(
    TkMenu *menuPtr,		/* The menu we are drawing */
    TkMenuEntry *mePtr,		/* The entry we are drawing */
    Drawable d,			/* What we are drawing into */
    GC gc,			/* The gc we are drawing into */
    Tk_Font tkfont,		/* The precalculated font */
    const Tk_FontMetrics *fmPtr,/* The precalculated font metrics */
    int x,			/* left edge */
    int y,			/* right edge */
    int width,			/* width of entry */
    int height)			/* height of entry */
{
    int imageWidth, imageHeight, textWidth = 0, textHeight = 0;
    int indicatorSpace =  mePtr->indicatorSpace;
    int leftEdge = x + indicatorSpace;
    int haveImage = 0, haveText = 0;
    int imageXOffset = 0, imageYOffset = 0;
    int textXOffset = 0, textYOffset = 0;
    Pixmap bitmap = (Pixmap) NULL;
    Tcl_DString itemTextDString;

    /*
     * Work out what we will need to draw first.
     */

    if (mePtr->image != NULL) {
	Tk_SizeOfImage(mePtr->image, &imageWidth, &imageHeight);
	haveImage = 1;
    } else if (mePtr->bitmapPtr != NULL) {
	bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
	Tk_SizeOfBitmap(menuPtr->display, bitmap, &imageWidth, &imageHeight);
	haveImage = 1;
    }
    if (!haveImage || (mePtr->compound != COMPOUND_NONE)) {
	if (mePtr->labelLength > 0) {
	    GetEntryText(mePtr, &itemTextDString);
	    if (mePtr->compound != COMPOUND_NONE) {
		textWidth = Tk_TextWidth(tkfont,
			Tcl_DStringValue(&itemTextDString),
			Tcl_DStringLength(&itemTextDString)) +
			menuTextLeadingEdgeMargin + menuTextTrailingEdgeMargin;
		textHeight = fmPtr->linespace;
	    }
	    haveText = 1;
	}
    }

    /*
     * Now work out what the relative positions are.
     */

    if (haveImage && haveText && (mePtr->compound != COMPOUND_NONE)) {
	int fullWidth = (imageWidth > textWidth ? imageWidth : textWidth);

	switch ((enum compound) mePtr->compound) {
	    case COMPOUND_TOP:
		textXOffset = (fullWidth - textWidth)/2;
		textYOffset = imageHeight/2 + 2;
		imageXOffset = (fullWidth - imageWidth)/2;
		imageYOffset = -textHeight/2;
		break;
	    case COMPOUND_BOTTOM:
		textXOffset = (fullWidth - textWidth)/2;
		textYOffset = -imageHeight/2;
		imageXOffset = (fullWidth - imageWidth)/2;
		imageYOffset = textHeight/2 + 2;
		break;
	    case COMPOUND_LEFT:
		/*
		 * Position image in the indicator space to the left of the
		 * entries, unless this entry is a radio|check button because
		 * then the indicator space will be used.
		 */

		textXOffset = imageWidth + 2 - menuTextLeadingEdgeMargin;
		if ((mePtr->type != CHECK_BUTTON_ENTRY)
			&& (mePtr->type != RADIO_BUTTON_ENTRY)) {
		    textXOffset -= indicatorSpace;
		    imageXOffset = -indicatorSpace;
		}
		if (textXOffset < 0) {
		    textXOffset = 0;
		}
		break;
	    case COMPOUND_RIGHT:
		imageXOffset = textWidth + 2 - menuTextTrailingEdgeMargin;
		break;
	    case COMPOUND_CENTER:
		textXOffset = (fullWidth - textWidth)/2;
		imageXOffset = (fullWidth - imageWidth)/2;
		break;
	    case COMPOUND_NONE:
	    	/*
	    	 * Never reached.
	    	 */
		break;
	}
    }

    /*
     * Draw label and/or bitmap or image for entry.
     */

    if (mePtr->image != NULL) {
	if ((mePtr->selectImage != NULL)
		&& (mePtr->entryFlags & ENTRY_SELECTED)) {
	    Tk_RedrawImage(mePtr->selectImage, 0, 0, imageWidth, imageHeight,
		    d, leftEdge + imageXOffset,
		    y + (mePtr->height - imageHeight)/2 + imageYOffset);
	} else {
	    Tk_RedrawImage(mePtr->image, 0, 0, imageWidth, imageHeight,
		    d, leftEdge + imageXOffset,
		    y + (mePtr->height - imageHeight)/2 + imageYOffset);
	}
    } else if (mePtr->bitmapPtr != NULL) {
	XCopyPlane(menuPtr->display, bitmap, d, gc, 0, 0, imageWidth,
		imageHeight, leftEdge + imageXOffset,
		y + (mePtr->height - imageHeight)/2  + imageYOffset, 1);
    }
    if (haveText) {
	int baseline = y + (height + fmPtr->ascent - fmPtr->descent)/2;

	Tk_DrawChars(menuPtr->display, d, gc, tkfont,
		Tcl_DStringValue(&itemTextDString),
		Tcl_DStringLength(&itemTextDString),
		leftEdge + menuTextLeadingEdgeMargin + textXOffset,
		baseline + textYOffset);
	Tcl_DStringFree(&itemTextDString);
    }

    if (mePtr->state == ENTRY_DISABLED) {
	if (menuPtr->disabledFgPtr == NULL) {
	    /* XFillRectangle(menuPtr->display, d, menuPtr->disabledGC, x, y,
		    width, height); */
	} else if ((mePtr->image != NULL)
		&& (menuPtr->disabledImageGC != None)) {
	    XFillRectangle(menuPtr->display, d, menuPtr->disabledImageGC,
		    leftEdge + imageXOffset,
		    y + (mePtr->height - imageHeight)/2 + imageYOffset,
		    imageWidth, imageHeight);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuEntryBackground --
 *
 *	This procedure draws the background part of a menu entry.
 *	Under Appearance, we only draw the background if the entry's
 *	border is set, we DO NOT inherit it from the menu...
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

void
DrawMenuEntryBackground(
    TkMenu *menuPtr,		/* The menu we are drawing. */
    TkMenuEntry *mePtr,		/* The entry we are drawing. */
    Drawable d,			/* What we are drawing into */
    Tk_3DBorder activeBorder,	/* Border for active items */
    Tk_3DBorder bgBorder,	/* Border for the background */
    int x,			/* left edge */
    int y,			/* top edge */
    int width,			/* width of rectangle to draw */
    int height)			/* height of rectangle to draw */
{
    if ((menuPtr->menuType == TEAROFF_MENU)
	    || ((mePtr->state == ENTRY_ACTIVE)
		    && (mePtr->activeBorderPtr != None))
	    || ((mePtr->state != ENTRY_ACTIVE) && (mePtr->borderPtr != None))) {
	if (mePtr->state == ENTRY_ACTIVE) {
	    bgBorder = activeBorder;
	}
	Tk_Fill3DRectangle(menuPtr->tkwin, d, bgBorder,
		x, y, width, height, 0, TK_RELIEF_FLAT);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetMenuLabelGeometry --
 *
 *	Figures out the size of the label portion of a menu item.
 *
 * Results:
 *	widthPtr and heightPtr are filled in with the correct geometry
 *	information.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
GetMenuLabelGeometry(
    TkMenuEntry *mePtr,		/* The entry we are computing */
    Tk_Font tkfont,		/* The precalculated font */
    const Tk_FontMetrics *fmPtr,/* The precalculated metrics */
    int *widthPtr,		/* The resulting width of the label portion */
    int *heightPtr)		/* The resulting height of the label portion */
{
    TkMenu *menuPtr = mePtr->menuPtr;
    int haveImage = 0, tornOff = (menuPtr->menuType == TEAROFF_MENU);
#ifdef USE_TK_MDEF
    const int useMDEF = ((MacMenu *) menuPtr->platformData)->useMDEF;
#endif

    if (mePtr->image != NULL && (useMDEF || tornOff)) {
	Tk_SizeOfImage(mePtr->image, widthPtr, heightPtr);
	haveImage = 1;
    } else if (mePtr->bitmapPtr != NULL && (useMDEF || tornOff)) {
	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
	Tk_SizeOfBitmap(menuPtr->display, bitmap, widthPtr, heightPtr);
	haveImage = 1;
    }
    if (!haveImage || (mePtr->compound != COMPOUND_NONE)) {
	int textWidth = 0, textHeight = fmPtr->linespace;

	if (mePtr->labelPtr != NULL) {
	    Tcl_DString itemTextDString;

	    GetEntryText(mePtr, &itemTextDString);
	    textWidth = Tk_TextWidth(tkfont,
		    Tcl_DStringValue(&itemTextDString),
		    Tcl_DStringLength(&itemTextDString)) +
		    menuTextLeadingEdgeMargin + menuTextTrailingEdgeMargin;
	    Tcl_DStringFree(&itemTextDString);

	    if (haveImage && (mePtr->compound != COMPOUND_NONE)) {
		switch ((enum compound) mePtr->compound) {
		    int margin;

		    case COMPOUND_TOP:
		    case COMPOUND_BOTTOM:
			if (textWidth > *widthPtr) {
			    *widthPtr = textWidth;
			}
			*heightPtr += textHeight + 2;
			break;
		    case COMPOUND_LEFT:
			margin = *widthPtr + 2;
			if (margin > menuTextLeadingEdgeMargin) {
			    margin = menuTextLeadingEdgeMargin;
			}
			*widthPtr += textWidth + 2 - margin;
			if (textHeight > *heightPtr) {
			    *heightPtr = textHeight;
			}
			break;
		    case COMPOUND_RIGHT:
			margin = menuTextTrailingEdgeMargin;
			*widthPtr += textWidth + 2 - margin;
			if (textHeight > *heightPtr) {
			    *heightPtr = textHeight;
			}
			break;
		    case COMPOUND_CENTER:
			if (textWidth > *widthPtr) {
			    *widthPtr = textWidth;
			}
			if (textHeight > *heightPtr) {
			    *heightPtr = textHeight;
			}
			break;
		    case COMPOUND_NONE:
			/*
			 * Never reached.
			 */
			break;
		}
		goto labelGeomDone;
	    }
	}
	*widthPtr = textWidth;
	*heightPtr = textHeight;
    }

labelGeomDone:
    *heightPtr += menuItemExtraHeight;
    *widthPtr += menuItemExtraWidth;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGenerateParentMenuSelectEvent --
 *
 *	Respond to a hierarchical menu being opened.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Places a virtual event on the event queue.
 *
 *----------------------------------------------------------------------
 */

int
TkMacOSXGenerateParentMenuSelectEvent(
    MenuRef menu)
{
    TkMenu *menuPtr = MenuPtrForMenuRef(menu);

    if (menuPtr) {
	TkMenuEntry *parentEntryPtr = GetParentMenuEntry(menuPtr);

	if (parentEntryPtr && (menuPtr = parentEntryPtr->menuPtr)) {
	    TkActivateMenuEntry(menuPtr, parentEntryPtr->index);
	    MenuSelectEvent(menuPtr);
	    Tcl_ServiceAll();
	    return true;
	}
    }
    return false;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGenerateMenuSelectEvent --
 *
 *	Respond to a menu item being selected.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Places a virtual event on the event queue.
 *
 *----------------------------------------------------------------------
 */

int
TkMacOSXGenerateMenuSelectEvent(
    MenuRef menu,
    MenuItemIndex index)
{
    TkMenu *menuPtr = MenuPtrForMenuRef(menu);
    int item = index - 1;

    if (menuPtr) {
	if (item < 0 || item >= menuPtr->numEntries ||
		(menuPtr->entries[item])->state == ENTRY_DISABLED) {
	    TkActivateMenuEntry(menuPtr, -1);
	} else {
	    TkActivateMenuEntry(menuPtr, item);
	    MenuSelectEvent(menuPtr);
	    Tcl_ServiceAll();
	    return true;
	}
    }
    return false;
}

/*
 *----------------------------------------------------------------------
 *
 * MenuSelectEvent --
 *
 *	Generates a "MenuSelect" virtual event. This can be used to
 *	do context-sensitive menu help.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Places a virtual event on the event queue.
 *
 *----------------------------------------------------------------------
 */

void
MenuSelectEvent(
    TkMenu *menuPtr)		/* the menu we have selected. */
{
    XVirtualEvent event;

    bzero(&event, sizeof(XVirtualEvent));
    event.type = VirtualEvent;
    event.serial = menuPtr->display->request;
    event.send_event = false;
    event.display = menuPtr->display;
    Tk_MakeWindowExist(menuPtr->tkwin);
    event.event = Tk_WindowId(menuPtr->tkwin);
    event.root = XRootWindow(menuPtr->display, 0);
    event.subwindow = None;
    event.time = TkpGetMS();

    XQueryPointer(NULL, None, NULL, NULL, &event.x_root, &event.y_root, NULL,
	    NULL, &event.state);
    event.same_screen = true;
    event.name = Tk_GetUid("MenuSelect");
    Tk_QueueWindowEvent((XEvent *) &event, TCL_QUEUE_TAIL);
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXClearActiveMenu --
 *
 *	Clears Tk's active entry for the given MenuRef.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Generates <<MenuSelect>> virtual events.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXClearActiveMenu(
    MenuRef menu)
{
    TkMenu *menuPtr = MenuPtrForMenuRef(menu);

    if (menuPtr) {
	RecursivelyClearActiveMenu(menuPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * RecursivelyClearActiveMenu --
 *
 *	Recursively clears the active entry in the menu's cascade hierarchy.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Generates <<MenuSelect>> virtual events.
 *
 *----------------------------------------------------------------------
 */

void
RecursivelyClearActiveMenu(
    TkMenu *menuPtr)		/* The menu to reset. */
{
    int i;
    TkMenuEntry *mePtr;

    TkActivateMenuEntry(menuPtr, -1);
    for (i = 0; i < menuPtr->numEntries; i++) {
	mePtr = menuPtr->entries[i];
	if (mePtr->type == CASCADE_ENTRY) {
	    if ((mePtr->childMenuRefPtr != NULL)
		    && (mePtr->childMenuRefPtr->menuPtr != NULL)) {
		RecursivelyClearActiveMenu(mePtr->childMenuRefPtr->menuPtr);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXClearMenubarActive --
 *
 *	Recursively clears the active entry in the current menubar hierarchy.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Generates <<MenuSelect>> virtual events.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXClearMenubarActive(void)
{
    TkMenuReferences *menuBarRefPtr;

    if (currentMenuBarName != NULL) {
	menuBarRefPtr = TkFindMenuReferences(currentMenuBarInterp,
		currentMenuBarName);
	if ((menuBarRefPtr != NULL) && (menuBarRefPtr->menuPtr != NULL)) {
	    TkMenu *menuPtr;

	    for (menuPtr = menuBarRefPtr->menuPtr->masterMenuPtr;
		    menuPtr != NULL; menuPtr = menuPtr->nextInstancePtr) {
		if (menuPtr->menuType == MENUBAR) {
		    RecursivelyClearActiveMenu(menuPtr);
		}
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMenuNotifyToplevelCreate --
 *
 *	This routine reconfigures the menu and the clones indicated by
 *	menuName becuase a toplevel has been created and any system
 *	menus need to be created. Only applicable to Windows.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	An idle handler is set up to do the reconfiguration.
 *
 *----------------------------------------------------------------------
 */

void
TkpMenuNotifyToplevelCreate(
    Tcl_Interp *interp,		/* The interp the menu lives in. */
    char *menuName)		/* The name of the menu to reconfigure. */
{
    /*
     * Nothing to do.
     */
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMenuInit --
 *
 *	Initializes Mac-specific menu data.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Allocates a hash table.
 *
 *----------------------------------------------------------------------
 */

void
TkpMenuInit(void)
{
    MenuSymbol *ms = menuSymbols;
    CFStringRef cfStr;

    lastMenuID = 256;
    Tcl_InitHashTable(&commandTable, TCL_ONE_WORD_KEYS);
    currentMenuBarOwner = NULL;
    currentAppleMenuID = 0;
    currentHelpMenuID = 0;
    currentMenuBarInterp = NULL;
    currentMenuBarName = NULL;
    windowListPtr = NULL;

#ifdef USE_TK_MDEF
    tkThemeMenuItemDrawingUPP
	    = NewMenuItemDrawingUPP(ThemeMenuItemDrawingProc);
    useMDEFVar = Tcl_NewStringObj("::tk::mac::useCustomMDEF", -1);
    macMDEFDrawable.winPtr = NULL;
    macMDEFDrawable.xOff = 0;
    macMDEFDrawable.yOff = 0;
    macMDEFDrawable.clipRgn = NULL;
    macMDEFDrawable.aboveClipRgn = NULL;
    macMDEFDrawable.drawRgn = NewRgn();
    macMDEFDrawable.referenceCount = 0;
    macMDEFDrawable.toplevel = NULL;
    macMDEFDrawable.flags = 0;
    macMDEFDrawable.grafPtr = NULL;
    macMDEFDrawable.context = NULL;
#endif

    ChkErr(GetThemeMetric, kThemeMetricMenuMarkColumnWidth,
	    &menuMarkColumnWidth);
    ChkErr(GetThemeMetric, kThemeMetricMenuMarkIndent, &menuMarkIndent);
    ChkErr(GetThemeMetric, kThemeMetricMenuTextLeadingEdgeMargin,
	    &menuTextLeadingEdgeMargin);
    ChkErr(GetThemeMetric, kThemeMetricMenuTextTrailingEdgeMargin,
	    &menuTextTrailingEdgeMargin);
    ChkErr(GetThemeMenuItemExtra, kThemeMenuItemPlain, &menuItemExtraHeight,
	    &menuItemExtraWidth);
    ChkErr(GetThemeMenuSeparatorHeight, &menuSeparatorHeight);

    while (ms->unicode) {
	ms->utfLen = Tcl_UniCharToUtf(ms->unicode, ms->utf);
	ms->utf[ms->utfLen] = 0;
	cfStr = CFStringCreateWithCharacters(NULL, &ms->unicode, 1);
	if (cfStr) {
	    ms->width = MeasureThemeText(cfStr, kThemeMenuItemCmdKeyFont);
	    CFRelease(cfStr);
	}
	ms++;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMenuThreadInit --
 *
 *	Does platform-specific initialization of thread-specific
 *	menu state.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkpMenuThreadInit(void)
{
    /*
     * Nothing to do.
     */
}

/*
 *----------------------------------------------------------------------
 *
 * TkpPreprocessMacMenu --
 *
 *    Handle preprocessing of menubar if it exists.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    All post commands for the current menubar get executed.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXPreprocessMenu(void)
{
    if ((currentMenuBarName != NULL) && (currentMenuBarInterp != NULL)) {
	TkMenuReferences *mbRefPtr =
		TkFindMenuReferences(currentMenuBarInterp,currentMenuBarName);

	if ((mbRefPtr != NULL) && (mbRefPtr->menuPtr != NULL)) {
	    int code;

	    Tcl_Preserve((ClientData) currentMenuBarInterp);
	    code = TkPreprocessMenu(mbRefPtr->menuPtr->masterMenuPtr);
	    if ((code != TCL_OK) && (code != TCL_CONTINUE)
		    && (code != TCL_BREAK)) {
		Tcl_AddErrorInfo(currentMenuBarInterp,
			"\n    (menu preprocess)");
		Tcl_BackgroundError(currentMenuBarInterp);
	    }
	    Tcl_Release((ClientData) currentMenuBarInterp);
	}
    }
}

#ifdef USE_TK_MDEF
#pragma mark MDEF
/*
 *----------------------------------------------------------------------
 *
 * MenuDefProc --
 *
 *	This routine is the MDEF handler for Tk. It receives all messages
 *	for the menu and dispatches them.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	This routine causes menus to be drawn and will certainly allocate
 *	memory as a result. Also, the menu can scroll up and down, and
 *	various other interface actions can take place.
 *
 *----------------------------------------------------------------------
 */

void
MenuDefProc(
    SInt16 message,		/* What action are we taking? */
    MenuRef menu,		/* The menu we are working with */
    Rect *menuRectPtr,		/* A pointer to the rect for the
				 * whole menu. */
    Point hitPt,		/* Where the mouse was clicked for
				 * the appropriate messages. */
    SInt16 *whichItem)		/* Output result. Which item was
				 * hit by the user? */
{
    TkMenu *menuPtr;
    Tcl_HashEntry *commandEntryPtr;
    MenuID menuID;

    menuID = GetMenuID(menu);
    commandEntryPtr = Tcl_FindHashEntry(&commandTable, (char*)(intptr_t)menuID);

    if (commandEntryPtr) {
	menuPtr = (TkMenu *) Tcl_GetHashValue(commandEntryPtr);
    } else {
	menuPtr = NULL;
    }

    switch (message) {
	case kMenuInitMsg:
	    *whichItem = noErr;
	    break;
	case kMenuDisposeMsg:
	    break;
	case kMenuHiliteItemMsg:
	    HandleMenuHiliteMsg(menu, menuRectPtr, hitPt, whichItem, menuPtr);
	    break;
	case kMenuCalcItemMsg:
	    HandleMenuCalcItemMsg(menu, menuRectPtr, hitPt, whichItem,
		    menuPtr);
	    break;
	case kMenuDrawItemsMsg:
#ifdef TK_MAC_DEBUG_MENUS
	    TkMacOSXDbgMsg("MDEF: DrawItemsMsg");
#endif
	    /*
	     * We do nothing  here, because we don't support the Menu Managers
	     * dynamic item groups
	     */
	    break;
	case kMenuThemeSavvyMsg:
	    *whichItem = kThemeSavvyMenuResponse;
	    break;
	case kMenuSizeMsg:
#ifdef TK_MAC_DEBUG_MENUS
	    TkMacOSXDbgMsg("MDEF: SizeMsg %d, %d", hitPt.h, hitPt.v);
#endif
	    SetMenuWidth(menu, hitPt.h < menuPtr->totalWidth ?	hitPt.h :
		    menuPtr->totalWidth);
	    SetMenuHeight(menu, hitPt.v < menuPtr->totalHeight ? hitPt.v :
		    menuPtr->totalHeight);
	    break;
	case kMenuDrawMsg:
	    HandleMenuDrawMsg(menu, menuRectPtr, hitPt, whichItem, menuPtr);
	    break;
	case kMenuFindItemMsg:
	    HandleMenuFindItemMsg(menu, menuRectPtr, hitPt, whichItem,
		    menuPtr);
	    break;
	case kMenuPopUpMsg:
	    HandleMenuPopUpMsg(menu, menuRectPtr, hitPt, whichItem, menuPtr);
	    break;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * HandleMenuHiliteMsg --
 *
 *	Handles the MenuDefProc's hilite message.
 *
 * Results:
 *	A menu entry is drawn
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
HandleMenuHiliteMsg(
    MenuRef menu,
    Rect *menuRectPtr,
    Point hitPt,
    SInt16 *whichItem,
    TkMenu *menuPtr)
{
    OSStatus err;
    Tk_Font tkfont;
    Tk_FontMetrics fontMetrics;
    MDEFHiliteItemData *hidPtr = (MDEFHiliteItemData *)whichItem;
    int oldItem = hidPtr->previousItem - 1;
    int newItem = hidPtr->newItem - 1;
    MenuTrackingData mtd, *mtdPtr = &mtd;

#ifdef TK_MAC_DEBUG_MENUS
    TkMacOSXDbgMsg("MDEF: HiliteMsg %d -> %d", hidPtr->previousItem,
	    hidPtr->newItem);
#endif
    GetPort(&macMDEFDrawable.grafPtr);
    macMDEFDrawable.context = (CGContextRef) hidPtr->context;

    err = ChkErr(GetMenuTrackingData, menu, mtdPtr);
    if (err != noErr) {
	return;
    }

    tkfont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
    Tk_GetFontMetrics(tkfont, &fontMetrics);
    if (oldItem >= 0) {
	AppearanceEntryDrawWrapper(menuPtr->entries[oldItem], menuRectPtr,
		mtdPtr, (Drawable) &macMDEFDrawable, &fontMetrics, tkfont, 1);
    }
    if (newItem >= 0) {
	AppearanceEntryDrawWrapper(menuPtr->entries[newItem], menuRectPtr,
		mtdPtr, (Drawable) &macMDEFDrawable, &fontMetrics, tkfont, 0);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * HandleMenuDrawMsg --
 *
 *	Handles the MenuDefProc's draw message.
 *
 * Results:
 *	A menu entry is drawn
 *
 * Side effects:
 *	None
 *
 *----------------------------------------------------------------------
 */

void
HandleMenuDrawMsg(
    MenuRef menu,
    Rect *menuRectPtr,
    Point hitPt,
    SInt16 *whichItem,
    TkMenu *menuPtr)
{
    Tk_Font menuFont;
    Tk_FontMetrics fontMetrics;
    TkMenuEntry *mePtr;
    int i;
    Rect menuClipRect, bounds;
    MDEFDrawData *ddPtr = (MDEFDrawData*)whichItem;
    MenuTrackingData *mtdPtr = &(ddPtr->trackingData);
    TkWindow *winPtr = (TkWindow*)menuPtr->tkwin;

    GetPort(&macMDEFDrawable.grafPtr);
    GetPortBounds(macMDEFDrawable.grafPtr, &bounds);
    macMDEFDrawable.context = (CGContextRef) ddPtr->context;
#ifdef TK_MAC_DEBUG_MENUS
    TkMacOSXDbgMsg("MDEF: DrawMsg %d - %d; %d - %d", menuRectPtr->top,
	    menuRectPtr->bottom, bounds.top, bounds.bottom);
#endif
    winPtr->changes.x = menuRectPtr->left;
    winPtr->changes.y = menuRectPtr->top;
    winPtr->changes.width = menuRectPtr->right - menuRectPtr->left;
    winPtr->changes.height = menuRectPtr->bottom - menuRectPtr->top;
    TkpClipDrawableToRect(menuPtr->display, (Drawable) &macMDEFDrawable,
	    0, 0, -1, -1);
#if 0
    if (menuPtr->menuRefPtr->topLevelListPtr != NULL) {
	menuType = kThemeMenuTypePullDown;
    } else if (menuPtr->menuRefPtr->parentEntryPtr != NULL) {
	menuType = kThemeMenuTypeHierarchical;
    } else {
	menuType = kThemeMenuTypePopUp;
    }
#endif
    DrawMenuBackground(menuPtr, menuRectPtr, (Drawable) &macMDEFDrawable);
    menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
    Tk_GetFontMetrics(menuFont, &fontMetrics);
    menuClipRect = *menuRectPtr;
    mtdPtr->virtualMenuBottom = mtdPtr->virtualMenuTop + menuPtr->totalHeight;

    /*
     * Next, figure out scrolling information.
     */

    if ((menuRectPtr->bottom - menuRectPtr->top) < menuPtr->totalHeight) {
	short arrowHeight = fontMetrics.linespace + 1;
	Rect arrowRect, eraseRect;
	ThemeMenuState menuState = IsMenuItemEnabled(menu, 0) ?
		kThemeMenuActive : kThemeMenuDisabled;

	if (mtdPtr->virtualMenuTop < menuRectPtr->top) {
	    arrowRect = bounds;
	    /*arrowRect.top += 1;*/
	    arrowRect.bottom = arrowRect.top + arrowHeight;
	    eraseRect = arrowRect;
	    eraseRect.top = menuRectPtr->top;
	    menuClipRect.top = arrowRect.bottom;
	    ChkErr(EraseMenuBackground, menu, &eraseRect,
		    macMDEFDrawable.context);
	    ChkErr(DrawThemeMenuItem, menuRectPtr, &arrowRect,
		    mtdPtr->virtualMenuTop, mtdPtr->virtualMenuBottom,
		    menuState, kThemeMenuItemScrollUpArrow, NULL, 0);
#ifdef TK_MAC_DEBUG_MENUS
	    TkMacOSXDbgMsg("upArrow:   %d - %d, %d - %d", arrowRect.top,
		    arrowRect.bottom, arrowRect.left, arrowRect.right);
#endif
	}
	if (mtdPtr->virtualMenuBottom > menuRectPtr->bottom) {
	    arrowRect = bounds;
	    arrowRect.bottom -= 1;
	    arrowRect.top = arrowRect.bottom - arrowHeight;
	    eraseRect = arrowRect;
	    eraseRect.bottom = menuRectPtr->bottom;
	    menuClipRect.bottom = arrowRect.top;
	    ChkErr(EraseMenuBackground, menu, &eraseRect,
		    macMDEFDrawable.context);
	    ChkErr(DrawThemeMenuItem, menuRectPtr, &arrowRect,
		    mtdPtr->virtualMenuTop, mtdPtr->virtualMenuBottom,
		    menuState, kThemeMenuItemScrollDownArrow, NULL, 0);
#ifdef TK_MAC_DEBUG_MENUS
	    TkMacOSXDbgMsg("downArrow: %d - %d, %d - %d", arrowRect.top,
		    arrowRect.bottom, arrowRect.left, arrowRect.right);
#endif
	}
	TkpClipDrawableToRect(menuPtr->display, (Drawable) &macMDEFDrawable,
		menuClipRect.left, menuClipRect.top, menuClipRect.right -
		menuClipRect.left, menuClipRect.bottom - menuClipRect.top);
    }

    /*
     * Now, actually draw the menu. Don't draw entries that
     * are higher than the top arrow, and don't draw entries
     * that are lower than the bottom.
     */

    for (i = 0; i < menuPtr->numEntries; i++) {
	mePtr = menuPtr->entries[i];
	if (mtdPtr->virtualMenuTop + mePtr->y + mePtr->height <
		menuClipRect.top || mtdPtr->virtualMenuTop + mePtr->y >
		menuClipRect.bottom) {
	    continue;
	}
	AppearanceEntryDrawWrapper(mePtr, menuRectPtr, mtdPtr,
		(Drawable) &macMDEFDrawable, &fontMetrics, menuFont, 0);
    }
    MDEFScrollFlag = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * HandleMenuFindItemMsg --
 *
 *	Handles the MenuDefProc's FindItems message. We have to
 *	respond by filling in the itemSelected, itemUnderMouse and
 *	itemRect fields. This is also the time to scroll the menu if
 *	it is too long to fit on the screen.
 *
 * Results:
 *	The Menu system is informed of the selected item & the item
 *	under the mouse.
 *
 * Side effects:
 *	The menu might get scrolled.
 *
 *----------------------------------------------------------------------
 */
void
HandleMenuFindItemMsg(
    MenuRef menu,
    Rect *menuRectPtr,
    Point hitPt,
    SInt16 *whichItem,
    TkMenu *menuPtr)
{
    Tk_Font menuFont;
    Tk_FontMetrics fontMetrics;
    TkMenuEntry *mePtr;
    int i, newItem = -1, itemUnderMouse = -1;
    Rect itemRect = {0, 0, 0, 0}, menuClipRect, bounds;
    int hasTopScroll, hasBottomScroll;
    MDEFFindItemData *fiPtr = (MDEFFindItemData *)whichItem;
    MenuTrackingData *mtdPtr = &(fiPtr->trackingData), topMtd;
    enum {
	DONT_SCROLL, DOWN_SCROLL, UP_SCROLL
    } scrollDirection;
    short arrowHeight;

#ifdef TK_MAC_DEBUG_MENUS
    static Point lastHitPt = {0, 0};
    if (hitPt.h != lastHitPt.h || hitPt.v != lastHitPt.v) {
	lastHitPt = hitPt;
	TkMacOSXDbgMsg("MDEF: FindItemMsg: %d, %d", hitPt.h, hitPt.v);
    }
#endif

    GetPort(&macMDEFDrawable.grafPtr);
    GetPortBounds(macMDEFDrawable.grafPtr, &bounds);
    macMDEFDrawable.context = (CGContextRef) fiPtr->context;

    /*
     * Now we need to take care of scrolling the menu.
     */

    menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
    Tk_GetFontMetrics(menuFont, &fontMetrics);
    arrowHeight = fontMetrics.linespace + 1;
    menuClipRect = *menuRectPtr;
    hasTopScroll = mtdPtr->virtualMenuTop < menuRectPtr->top;
    hasBottomScroll = mtdPtr->virtualMenuBottom > menuRectPtr->bottom;
    scrollDirection = DONT_SCROLL;
    if (hasTopScroll) {
	menuClipRect.top = bounds.top + arrowHeight;
	if (hitPt.v < menuClipRect.top) {
	    newItem = -1;
	    scrollDirection = DOWN_SCROLL;
	}
    }
    if (hasBottomScroll) {
	menuClipRect.bottom = bounds.bottom - 1 - arrowHeight;
	if (hitPt.v > menuClipRect.bottom) {
	    newItem = -1;
	    scrollDirection = UP_SCROLL;
	}
    }
    if (MDEFScrollFlag) {
	scrollDirection = DONT_SCROLL;
	MDEFScrollFlag = 0;
    }
    /*
     * Don't scroll if there are other menus open above us
     */
    ChkErr(GetMenuTrackingData, NULL, &topMtd);
    if (menu != topMtd.menu) {
	scrollDirection = DONT_SCROLL;
    }
    if (scrollDirection == DONT_SCROLL) {
	/*
	 * Find out which item was hit. If it is the same as the old item,
	 * we don't need to do anything.
	 */

	if (PtInRect(hitPt, menuRectPtr)) {
	    for (i = 0; i < menuPtr->numEntries; i++) {
		mePtr = menuPtr->entries[i];
		itemRect.left = menuRectPtr->left + mePtr->x;
		itemRect.top = mtdPtr->virtualMenuTop + mePtr->y;
		itemRect.right = mePtr->entryFlags & ENTRY_LAST_COLUMN ?
			menuRectPtr->right : itemRect.left + mePtr->width;
		itemRect.bottom = itemRect.top + mePtr->height;
		if (PtInRect(hitPt, &itemRect)) {
		    if ((mePtr->type == SEPARATOR_ENTRY)
			    || (mePtr->state == ENTRY_DISABLED)) {
			newItem = -1;
			itemUnderMouse = i;
		    } else {
			TkMenuEntry *parentEntryPtr =
				GetParentMenuEntry(menuPtr);

			if (parentEntryPtr &&
				parentEntryPtr->state == ENTRY_DISABLED) {
			    newItem = -1;
			    itemUnderMouse = i;
			} else {
			    newItem = i;
			    itemUnderMouse = i;
			}
		    }
		    break;
		}
	    }
	}
    } else {
	short scrollAmt;
	unsigned long scrollDelay;
	Rect arrowRect, eraseRect, scrolledMenuClipRect;
	ThemeMenuState menuState = IsMenuItemEnabled(menu, 0) ?
		kThemeMenuActive : kThemeMenuDisabled;
	int oldItem = mtdPtr->itemSelected - 1;
	short d;

	TkpClipDrawableToRect(menuPtr->display, (Drawable) &macMDEFDrawable,
		0, 0, -1, -1);
	scrollAmt = fontMetrics.linespace + menuItemExtraHeight;
	if (scrollDirection == UP_SCROLL) {
	    scrollAmt = -scrollAmt;
	    d = hitPt.v - bounds.bottom;
	} else {
	    d = bounds.top - hitPt.v;
	}
	scrollDelay = (d >= scrollAmt/2) ? 1 : 10;
	menuClipRect = *menuRectPtr;
	if (mtdPtr->virtualMenuTop + scrollAmt < menuRectPtr->top) {
	    arrowRect = bounds;
	    /*arrowRect.top += 1;*/
	    arrowRect.bottom = arrowRect.top + arrowHeight;
	    eraseRect = arrowRect;
	    eraseRect.top = menuRectPtr->top;
	    menuClipRect.top = arrowRect.bottom;
	    if (!hasTopScroll) {
		ChkErr(EraseMenuBackground, menu, &eraseRect,
			macMDEFDrawable.context);
		ChkErr(DrawThemeMenuItem, menuRectPtr, &arrowRect,
			mtdPtr->virtualMenuTop + scrollAmt,
			mtdPtr->virtualMenuBottom + scrollAmt,
			menuState, kThemeMenuItemScrollUpArrow, NULL, 0);
#ifdef TK_MAC_DEBUG_MENUS
		TkMacOSXDbgMsg("upArrow:   %d - %d, %d - %d", arrowRect.top,
			arrowRect.bottom, arrowRect.left, arrowRect.right);
#endif
	    }
	}
	if (mtdPtr->virtualMenuBottom + scrollAmt > menuRectPtr->bottom) {
	    arrowRect = bounds;
	    arrowRect.bottom -= 1;
	    arrowRect.top = arrowRect.bottom - arrowHeight;
	    eraseRect = arrowRect;
	    eraseRect.bottom = menuRectPtr->bottom;
	    menuClipRect.bottom = arrowRect.top;
	    if (!hasBottomScroll) {
		ChkErr(EraseMenuBackground, menu, &eraseRect,
			macMDEFDrawable.context);
		ChkErr(DrawThemeMenuItem, menuRectPtr, &arrowRect,
			mtdPtr->virtualMenuTop + scrollAmt,
			mtdPtr->virtualMenuBottom + scrollAmt,
			menuState, kThemeMenuItemScrollDownArrow, NULL, 0);
#ifdef TK_MAC_DEBUG_MENUS
		TkMacOSXDbgMsg("downArrow: %d - %d, %d - %d", arrowRect.top,
			arrowRect.bottom, arrowRect.left, arrowRect.right);
#endif
	    }
	}
	TkpClipDrawableToRect(menuPtr->display, (Drawable) &macMDEFDrawable,
		menuClipRect.left, menuClipRect.top, menuClipRect.right -
		menuClipRect.left, menuClipRect.bottom - menuClipRect.top);
	TkActivateMenuEntry(menuPtr, -1);
	if (oldItem >= 0) {
	    AppearanceEntryDrawWrapper(menuPtr->entries[oldItem], menuRectPtr,
		    mtdPtr, (Drawable) &macMDEFDrawable, &fontMetrics,
		    menuFont, 1);
	}
	ChkErr(ScrollMenuImage, menu, &menuClipRect, 0, scrollAmt,
		macMDEFDrawable.context);
	mtdPtr->virtualMenuTop += scrollAmt;
	mtdPtr->virtualMenuBottom += scrollAmt;
	scrolledMenuClipRect = menuClipRect;
	OffsetRect(&scrolledMenuClipRect, 0, scrollAmt);
	menuClipRect = bounds;
	if (mtdPtr->virtualMenuTop < menuRectPtr->top) {
	    menuClipRect.top += arrowHeight;
	}
	if (mtdPtr->virtualMenuBottom > menuRectPtr->bottom) {
	    menuClipRect.bottom -= arrowHeight;
	}
	TkpClipDrawableToRect(menuPtr->display, (Drawable) &macMDEFDrawable,
		menuClipRect.left, menuClipRect.top, menuClipRect.right -
		menuClipRect.left, menuClipRect.bottom - menuClipRect.top);
	if (scrolledMenuClipRect.bottom < menuClipRect.bottom) {
	    menuClipRect.top = scrolledMenuClipRect.bottom;
	} else if (scrolledMenuClipRect.top < menuClipRect.top) {
	    menuClipRect.bottom = scrolledMenuClipRect.top;
	}
	for (i = 0; i < menuPtr->numEntries; i++) {
	    mePtr = menuPtr->entries[i];
	    if (mtdPtr->virtualMenuTop + mePtr->y + mePtr->height <
		    menuClipRect.top || mtdPtr->virtualMenuTop + mePtr->y >
		    menuClipRect.bottom) {
		continue;
	    }
#ifdef TK_MAC_DEBUG_MENUS
	    TkMacOSXDbgMsg("Drawing item %i", i);
#endif
	    AppearanceEntryDrawWrapper(mePtr, menuRectPtr, mtdPtr,
		    (Drawable) &macMDEFDrawable, &fontMetrics, menuFont, 1);
	}
	Delay(scrollDelay, NULL);
    }
    mtdPtr->itemSelected = newItem + 1;
    mtdPtr->itemUnderMouse = itemUnderMouse + 1;
    mtdPtr->itemRect = itemRect;
}

/*
 *----------------------------------------------------------------------
 *
 * HandleMenuPopUpMsg --
 *
 *	Handles the MenuDefProc's PopUp message. The menu is
 *	posted with the selected item at the point given in hitPt.
 *
 * Results:
 *	A menu is posted.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
void
HandleMenuPopUpMsg(
    MenuRef menu,
    Rect *menuRectPtr,
    Point hitPt,
    SInt16 *whichItem,
    TkMenu *menuPtr)
{
    int maxMenuHeight;
    int oldItem;
    Rect portRect;
    BitMap screenBits;
    static SInt16 menuBarHeight = 0;

#ifdef TK_MAC_DEBUG_MENUS
    TkMacOSXDbgMsg("MDEF: PopUpMsg");
#endif

    if (!menuBarHeight) {
	ChkErr(GetThemeMenuBarHeight, &menuBarHeight);
    }
    GetQDGlobalsScreenBits(&screenBits);

    /*
     * Note that for some oddball reason, h and v are reversed in the
     * point given to us by the MDEF.
     */

    oldItem = *whichItem;
    if (oldItem >= menuPtr->numEntries) {
	oldItem = -1;
    }
    portRect.top = 0;
    portRect.bottom = 1280;
    maxMenuHeight = screenBits.bounds.bottom - screenBits.bounds.top
	    - menuBarHeight - SCREEN_MARGIN;
    if (menuPtr->totalHeight > maxMenuHeight) {
	menuRectPtr->top = menuBarHeight;
    } else {
	int delta;

	menuRectPtr->top = hitPt.h;
	if (oldItem >= 0) {
	    menuRectPtr->top -= menuPtr->entries[oldItem]->y;
	}

	if (menuRectPtr->top < menuBarHeight) {
	    /*
	     * Displace downward if the menu would stick off the top of the
	     * screen.
	     */

	    menuRectPtr->top = menuBarHeight + SCREEN_MARGIN;
	} else {
	    /*
	     * Or upward if the menu sticks off the bottom end...
	     */

	    delta = menuRectPtr->top + menuPtr->totalHeight - maxMenuHeight;
	    if (delta > 0) {
		menuRectPtr->top -= delta;
	    }
	}
    }
    menuRectPtr->left = hitPt.v;
    menuRectPtr->right = menuRectPtr->left + menuPtr->totalWidth;
    menuRectPtr->bottom = menuRectPtr->top +
	    ((maxMenuHeight < menuPtr->totalHeight)
	    ? maxMenuHeight : menuPtr->totalHeight);
    if (menuRectPtr->top == menuBarHeight) {
	*whichItem = hitPt.h;
    } else {
	*whichItem = menuRectPtr->top;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * HandleMenuCalcItemMsg --
 *
 *	Handles the MenuDefProc's CalcItem message. It is supposed
 *	to calculate the Rect of the menu entry in whichItem in the
 *	menu, and put that in menuRectPtr. I assume this works, but I
 *	have never seen the MenuManager send this message.
 *
 * Results:
 *	The Menu Manager is informed of the bounding rect of a
 *	menu rect.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
HandleMenuCalcItemMsg(
    MenuRef menu,
    Rect *menuRectPtr,
    Point hitPt,
    SInt16 *whichItem,
    TkMenu *menuPtr)
{
    TkMenuEntry *mePtr;
    MenuTrackingData mtd, *mtdPtr = &mtd;
    OSStatus err;
    int virtualTop, item = *whichItem-1;

    err = ChkErr(GetMenuTrackingData, menu, mtdPtr);
    if (err == noErr) {
	virtualTop = mtdPtr->virtualMenuTop;
    } else {
	virtualTop = 0;
    }

    if (item >= 0 && item < menuPtr->numEntries) {
	mePtr = menuPtr->entries[item];
	menuRectPtr->left = mePtr->x;
	menuRectPtr->top = mePtr->y + virtualTop;
	if (mePtr->entryFlags & ENTRY_LAST_COLUMN) {
	    menuRectPtr->right = menuPtr->totalWidth;
	} else {
	    menuRectPtr->right = mePtr->x + mePtr->width;
	}
	menuRectPtr->bottom = menuRectPtr->top + mePtr->height;
    }
#ifdef TK_MAC_DEBUG_MENUS
    TkMacOSXDbgMsg("MDEF: CalcItemMsg %d: %d, %d", *whichItem,
	    menuRectPtr->left, menuRectPtr->top);
#endif
}
#endif /* USE_TK_MDEF */
@


1.4
log
@removed trailing whitespace
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXMenu.c,v 1.3 2007/05/07 04:17:45 brlcad Exp $
d16 1
a16 1
#include "tkMacOSXInt.h"
d1291 2
a1292 2
			SetMenuItemHierarchicalID(macMenuHdl, base + index,
				GetMenuID(childMenuHdl));
d1559 1
d1675 1
a1675 1
    TkMenu *appleMenuPtr, *helpMenuPtr, *menuBarPtr;
a2032 1
    CGrafPtr winPort;
d2036 1
a2036 5
    winPort = TkMacOSXGetDrawablePort(winPtr->window);
    if (!winPort) {
	return;
    }
    macWindowPtr = GetWindowFromPort(winPort);
d2644 1
a2644 1
		Tk_DrawChars(menuPtr->display, d, gc, tkfont, accel +
d2698 1
a2698 2
    CGrafPtr destPort, savePort;
    Boolean portChanged;
a2700 3
    destPort = TkMacOSXGetDrawablePort(d);
    portChanged = QDSwapPort(destPort, &savePort);
    TkMacOSXSetUpClippingRgn(d);
d2705 3
a2707 4
    DrawThemeMenuSeparator(&r);
    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
d3983 5
d3989 5
d4212 1
a4212 1
    macMDEFDrawable.context = (CGContextRef)hidPtr->context;
d4266 1
a4266 1
    macMDEFDrawable.context = (CGContextRef)ddPtr->context;
d4410 1
a4410 1
    macMDEFDrawable.context = (CGContextRef)fiPtr->context;
@


1.3
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXMenu.c,v 1.37 2007/04/23 21:24:33 das Exp $
d2648 1
a2648 1
		Tk_DrawChars(menuPtr->display, d, gc, tkfont, accel + 
@


1.2
log
@remove dependency on -fpascal-strings when building for aqua
@
text
@d1 1
a1 1
/* 
d8 1
a8 1
 * Copyright (c) 2005-2006 Daniel A. Steffen <das@@users.sourceforge.net>
d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXMenu.c,v 1.1 2007/03/02 21:49:55 brlcad Exp $
d20 1
a22 3
#define USE_TK_MDEF
//#define USE_ATSU

d24 1
a24 1
#ifdef	TK_MAC_DEBUG
d29 1
a29 4
#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
    /* Define constants only available on Mac OS X 10.3 or later */
    #define kMenuAttrDoNotUseUserCommandKeys (1 << 7)
#endif
d33 3
a35 5
    Rect menuRect;		/* The rectangle as calculated in the
    				 * MDEF. This is used to figure ou the
    				 * clipping rgn before we push
    				 * the <<MenuSelect>> virtual binding
    				 * through. */
a43 30
/*
 * Various geometry definitions:
 */

#define CASCADE_ARROW_HEIGHT 	10
#define CASCADE_ARROW_WIDTH 	8
#define DECORATION_BORDER_WIDTH 2
#define MAC_MARGIN_WIDTH 	8

/*
 * The following are constants relating to the SICNs used for drawing the MDEF.
 */

#define SICN_RESOURCE_NUMBER	128

#define SICN_HEIGHT 		16
#define SICN_ROWS 		2
#define CASCADE_ICON_WIDTH	7
#define	SHIFT_ICON_WIDTH	10
#define	OPTION_ICON_WIDTH	16
#define CONTROL_ICON_WIDTH	12
#define COMMAND_ICON_WIDTH	10

#define CASCADE_ARROW		0
#define SHIFT_ICON		1
#define OPTION_ICON		2
#define CONTROL_ICON		3
#define COMMAND_ICON		4
#define DOWN_ARROW		5
#define UP_ARROW		6
d64 1
d73 3
a75 3
    				 * the text starts. Everything before
    				 * this is modifier key descriptions.
    				 */
d77 2
a78 2
    int accelTextWidth;		/* Width of the text after the modifier 
    				 * keys. */
d80 5
a84 1
    				 * without accelerators. */
d93 1
a93 1
    				/* The next window in the list. */
d96 1
a96 1
    				 * toplevel. */
d117 2
a118 3
#define CASCADE_CMD (0x1b)    	
				/* The special command char for cascade
			         * menus. */
a119 1
#define SCREEN_MARGIN 5
d121 2
a122 12
static int gNoTkMenus = 0;      /* This is used by Tk_MacOSXTurnOffMenus as the
                                 * flag that Tk is not to draw any menus. */
                                 
RgnHandle tkMenuCascadeRgn = NULL;
				/* The region to clip drawing to when the
				 * MDEF is up. */
int tkUseMenuCascadeRgn = 0;	/* If this is 1, clipping code
				 * should intersect tkMenuCascadeRgn
				 * before drawing occurs.
				 * tkMenuCascadeRgn will only
				 * be valid when the value of this
				 * variable is 1. */
a140 3
static char elipsisString[TCL_UTF_MAX + 1];
				/* The UTF representation of the elipsis (...) 
				 * character. */
a147 3
static MacDrawable macMDEFDrawable;
				/* Drawable for use by MDEF code */
static int MDEFScrollFlag = 0;	/* Used so that popups don't scroll too soon. */
a149 7
                                 
static struct TearoffSelect {
    TkMenu *menuPtr;		/* The menu that is torn off */
    Point point;		/* The point to place the new menu */
    Rect excludeRect;		/* We don't want to drag tearoff highlights
    				 * when we are in this menu */
} tearoffStruct;
d152 2
a153 2
    TkMenu *menuPtr;            /* Tcl_DoWhenIdle to move handling */
    int index;                  /* menu commands to the event loop. */
a155 6
static RgnHandle totalMenuRgn = NULL;
				/* Used to update windows which have been
				 * obscured by menus. */
static RgnHandle utilRgn = NULL;/* Used when creating the region that is to
				 * be clipped out while the MDEF is active. */

d158 110
a267 1
static MenuItemDrawingUPP tkThemeMenuItemDrawingUPP; 
d271 26
a296 2
MenuRef tkCurrentAppleMenu = NULL;
			
d298 13
a310 1
 * Forward declarations for procedures defined later in this file:
d313 54
a366 118
MODULE_SCOPE int TkMacOSXGetNewMenuID _ANSI_ARGS_((Tcl_Interp *interp, 
        TkMenu *menuInstPtr, 
        int cascade, 
        short *menuIDPtr));
MODULE_SCOPE void TkMacOSXFreeMenuID _ANSI_ARGS_((short menuID));
 
static void CompleteIdlers _ANSI_ARGS_((TkMenu *menuPtr));
static void DrawMenuBarWhenIdle _ANSI_ARGS_((
    ClientData clientData));
static void  DrawMenuBackground _ANSI_ARGS_((
    Rect *menuRectPtr, Drawable d, ThemeMenuType type));
static void DrawMenuEntryAccelerator _ANSI_ARGS_((
    TkMenu *menuPtr, TkMenuEntry *mePtr, 
    Drawable d, GC gc, Tk_Font tkfont,
    CONST Tk_FontMetrics *fmPtr,
    Tk_3DBorder activeBorder, int x, int y,
    int width, int height, int drawArrow));
static void		DrawMenuEntryBackground _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr,
			    Drawable d, Tk_3DBorder activeBorder,
			    Tk_3DBorder bgBorder, int x, int y,
			    int width, int heigth));
static void		DrawMenuEntryIndicator _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr,
			    Drawable d, GC gc, GC indicatorGC, 
			    Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr, int x, int y,
			    int width, int height));
static void		DrawMenuEntryLabel _ANSI_ARGS_((
			    TkMenu * menuPtr, TkMenuEntry *mePtr, Drawable d,
			    GC gc, Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr, int x, int y,
			    int width, int height));
static void		DrawMenuSeparator _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Drawable d, GC gc, 
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr, 
			    int x, int y, int width, int height));
static void		DrawTearoffEntry _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Drawable d, GC gc, 
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr, 
			    int x, int y, int width, int height));
static void             EventuallyInvokeMenu (ClientData data);
static void		GetEntryText _ANSI_ARGS_((TkMenuEntry *mePtr,
			    Tcl_DString *dStringPtr));
static void		GetMenuAccelGeometry _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr, int *modWidthPtr,
			    int *textWidthPtr, int *heightPtr));
static void		GetMenuLabelGeometry _ANSI_ARGS_((TkMenuEntry *mePtr,
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr,
			    int *widthPtr, int *heightPtr));
static void		GetMenuIndicatorGeometry _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr, 
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr, 
			    int *widthPtr, int *heightPtr));
static void		GetMenuSeparatorGeometry _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr,
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr,
			    int *widthPtr, int *heightPtr));
static void		GetTearoffEntryGeometry _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr, int *widthPtr,
			    int *heightPtr));
static char		FindMarkCharacter _ANSI_ARGS_((TkMenuEntry *mePtr));
static void		InvalidateMDEFRgns _ANSI_ARGS_((void));

static void             MenuDefProc _ANSI_ARGS_((short message,
                            MenuHandle menu, Rect *menuRectPtr,
                            Point hitPt, short *whichItem ));
static void             HandleMenuHiliteMsg (MenuRef menu, 
                            Rect *menuRectPtr, 
                            Point hitPt, 
                            SInt16 *whichItem,
                            TkMenu *menuPtr);
static void             HandleMenuDrawMsg (MenuRef menu, 
                            Rect *menuRectPtr, 
                            Point hitPt, 
                            SInt16 *whichItem,
                            TkMenu *menuPtr);
static void             HandleMenuFindItemsMsg (MenuRef menu, 
                            Rect *menuRectPtr, 
                            Point hitPt, 
                            SInt16 *whichItem,
                            TkMenu *menuPtr);
static void             HandleMenuPopUpMsg (MenuRef menu, 
                            Rect *menuRectPtr, 
                            Point hitPt, 
                            SInt16 *whichItem,
                            TkMenu *menuPtr);
static void             HandleMenuCalcItemMsg (MenuRef menu, 
                            Rect *menuRectPtr, 
                            Point hitPt, 
                            SInt16 *whichItem,
                            TkMenu *menuPtr);

static void		MenuSelectEvent _ANSI_ARGS_((TkMenu *menuPtr));
static void		ReconfigureIndividualMenu _ANSI_ARGS_((
    			    TkMenu *menuPtr, MenuHandle macMenuHdl, 
    			    int base));
static void		ReconfigureMacintoshMenu _ANSI_ARGS_ ((
			    ClientData clientData));
static void		RecursivelyClearActiveMenu _ANSI_ARGS_((
			    TkMenu *menuPtr));
static void		RecursivelyDeleteMenu _ANSI_ARGS_((
			    TkMenu *menuPtr));
static void		RecursivelyInsertMenu _ANSI_ARGS_((
			    TkMenu *menuPtr));
static void		SetDefaultMenubar _ANSI_ARGS_((void));
static int		SetMenuCascade _ANSI_ARGS_((TkMenu *menuPtr));
static void		mySetMenuTitle _ANSI_ARGS_((MenuHandle menuHdl,
			    Tcl_Obj *titlePtr));
static void		AppearanceEntryDrawWrapper _ANSI_ARGS_((TkMenuEntry *mePtr, 
			    Rect * menuRectPtr, MenuTrackingData *mtdPtr,     
			    Drawable d, Tk_FontMetrics *fmPtr, Tk_Font tkfont,
			    int x, int y, int width, int height));
static pascal void 	ThemeMenuItemDrawingProc _ANSI_ARGS_ ((const Rect *inBounds,
			    SInt16 inDepth, Boolean inIsColorDevice, 
			    SInt32 inUserData));
d368 11
d407 1
a407 1
    
d410 3
a412 6
        &newEntry);
    if (newEntry == 1) {
    	Tcl_SetHashValue(commandEntryPtr, NULL);
    	return TCL_OK;
    } else {
    	return TCL_ERROR;
d414 2
d431 2
a432 2
 *	I believe this is 32768, but am not sure.  This code just uses
 *	2000 as the upper limit.  Unfortunately tk leaks menus when
d447 1
d453 1
a453 1
    				   1 if we are working with a cascade */
d466 1
a466 1
    
d468 9
a476 8
    	short curID = lastMenuID + 1;
        if (curID == 236) {
    	    curID = 256;
    	}

    	while (curID != lastMenuID) {
            int iCurID = curID;
    	    commandEntryPtr = Tcl_CreateHashEntry(&commandTable,
d478 10
a487 10
    	    if (newEntry == 1) {
    	        found = 1;
    	        lastMenuID = returnID = curID;
    	        break;
    	    }
    	    curID++;
    	    if (curID == 236) {
    	    	curID = 256;
    	    }
    	}
d489 14
a502 14
    
    	/*
    	 * Cascade ids must be between 0 and 235 only, so they must be
    	 * dealt with separately.
    	 */
    
    	short curID = lastCascadeID + 1;
        if (curID == 2000) {
    	    curID = 0;
    	}
    	
    	while (curID != lastCascadeID) {
            int iCurID = curID;
    	    commandEntryPtr = Tcl_CreateHashEntry(&commandTable,
d504 16
a519 21
    	    if (newEntry == 1) {
    	    	found = 1;
    	    	lastCascadeID = returnID = curID;
    	    	break;
    	    }
    	    curID++;
    	    if (curID == 2000) {
    	    	curID = 0;
    	    }
    	}
    }

    if (found) {
    	Tcl_SetHashValue(commandEntryPtr, (char *) menuPtr);
    	*menuIDPtr = returnID;
    	return TCL_OK;
    } else {
    	Tcl_ResetResult(interp);
        Tcl_AppendResult(interp, "No more menus can be allocated.", 
        	(char *) NULL);
    	return TCL_ERROR;
d521 3
d544 1
a544 1
    short menuID)			/* The id to free */
d547 2
a548 2
	    (char *) ((int)menuID));
    
d550 1
a550 1
    	 Tcl_DeleteHashEntry(entryPtr);
d553 1
a553 1
    	currentAppleMenuID = 0;
d556 67
a622 1
    	currentHelpMenuID = 0;
d624 1
d648 1
a648 1
    				 * platform structure for. */
d652 1
d655 2
a656 1
    int useMDEF;
d660 1
a660 1
    
d663 1
a663 1
    	return error;
d665 2
a666 1
    err = CreateNewMenu(menuID, kMenuAttrDoNotUseUserCommandKeys, &macMenuHdl);
d668 2
a669 3
        Tcl_AppendResult(menuPtr->interp, "CreateNewMenu failed.",
                (char *) NULL);
        return TCL_ERROR;
d672 1
a672 1
            kCFStringEncodingUTF8);
d674 3
a676 3
        Tcl_AppendResult(menuPtr->interp, "CFStringCreateWithCString failed.",
                (char *) NULL);
        return TCL_ERROR;
d678 1
a678 1
    err = SetMenuTitleWithCFString(macMenuHdl, cfStr);
d681 3
a683 3
        Tcl_AppendResult(menuPtr->interp, "SetMenuTitleWithCFString failed.",
                (char *) NULL);
        return TCL_ERROR;
d685 5
a689 1
    
d691 1
a691 1
     * Check whether we want to use the custom mdef or not.  For now
d695 8
a702 12
     
    useMDEFObjPtr = Tcl_ObjGetVar2(menuPtr->interp, useMDEFVar, NULL, TCL_GLOBAL_ONLY);
    if (useMDEFObjPtr == NULL
            || Tcl_GetBooleanFromObj(NULL, useMDEFObjPtr, &useMDEF) == TCL_ERROR
            || useMDEF) { 
        menuDefSpec.defType = kMenuDefProcPtr;
        menuDefSpec.u.defProc = MenuDefProc;
        if ((err = SetMenuDefinition(macMenuHdl, &menuDefSpec)) != noErr) {
#ifdef TK_MAC_DEBUG
            fprintf(stderr, "SetMenuDefinition failed %d\n", (int) err);
#endif
        }
d704 2
a705 3
    menuPtr->platformData = (TkMenuPlatformData) ckalloc(sizeof(MacMenu));
    ((MacMenu *) menuPtr->platformData)->menuHdl = macMenuHdl;
    SetRect(&((MacMenu *) menuPtr->platformData)->menuRect, 0, 0, 0, 0);
d708 14
a721 14
    	    && (currentMenuBarName != NULL)) {
    	Tk_Window parentWin = Tk_Parent(menuPtr->tkwin);
    	
    	if (strcmp(currentMenuBarName, Tk_PathName(parentWin)) == 0) {
    	    if ((strcmp(Tk_PathName(menuPtr->tkwin)
    	    	    + strlen(Tk_PathName(parentWin)), ".apple") == 0)
    	    	    || (strcmp(Tk_PathName(menuPtr->tkwin)
    	    	    + strlen(Tk_PathName(parentWin)), ".help") == 0)) {
	    	if (!(menuBarFlags & MENUBAR_REDRAW_PENDING)) {
	    	    Tcl_DoWhenIdle(DrawMenuBarWhenIdle, (ClientData *) NULL);
	    	    menuBarFlags |= MENUBAR_REDRAW_PENDING;
	    	}
	    }   	    		
    	}
d723 1
a723 1
    
d752 2
a753 2
    	Tcl_CancelIdleCall(ReconfigureMacintoshMenu, (ClientData) menuPtr);
    	menuPtr->menuFlags &= ~MENU_RECONFIGURE_PENDING;
d756 12
a767 12
    	MenuRef helpMenuHdl;
        MenuItemIndex helpIndex;
    	
    	if ((HMGetHelpMenu(&helpMenuHdl,&helpIndex) == noErr) 
    		&& (helpMenuHdl != NULL)) {
    	    int i, count = CountMenuItems(helpMenuHdl);
    	    
    	    for (i = helpIndex; i <= count; i++) {
    	    	DeleteMenuItem(helpMenuHdl, helpIndex);
    	    }
    	}
    	currentHelpMenuID = 0;
d770 6
a775 6
        MenuID menuID;
        menuID = GetMenuID(macMenuHdl);
        DeleteMenu(menuID);
        TkMacOSXFreeMenuID(menuID);
        DisposeMenu(macMenuHdl);
        ckfree((char *) menuPtr->platformData);
d779 1
a779 2


d796 1
a796 1
static int
d804 1
d806 5
a810 5
    	error = TkMacOSXGetNewMenuID(menuPtr->interp, menuPtr, 1, &newMenuID);
    	if (error == TCL_OK) {
    	    TkMacOSXFreeMenuID(menuID);
    	    SetMenuID (macMenuHdl,newMenuID);
    	}
d833 1
a833 2
    TkMenuEntry *mePtr)		/* The common structure for the menu 
    				 * entry. */
d835 2
a836 2
    TkMenu *menuPtr = mePtr->menuPtr;    
  
d838 4
a841 4
    if ((menuPtr->platformData != NULL) 
    	    && !(menuPtr->menuFlags & MENU_RECONFIGURE_PENDING)) {
    	menuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
    	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, (ClientData) menuPtr);
d864 1
a864 1
static void
d868 1
a868 1
    				 * will be initialized by this routine. */
d870 5
d876 9
a884 7
    if (mePtr->type == TEAROFF_ENTRY) {
    	Tcl_DStringAppend(dStringPtr, "(Tear-off)", -1);
    } else if (mePtr->imagePtr != NULL) {
    	Tcl_DStringAppend(dStringPtr, "(Image)", -1);
    } else if (mePtr->bitmapPtr != NULL) {
    	Tcl_DStringAppend(dStringPtr, "(Pixmap)", -1);
    } else if (mePtr->labelPtr == NULL || mePtr->labelLength == 0) {
d891 4
a894 4
    	int length;
    	char *text = Tcl_GetStringFromObj(mePtr->labelPtr, &length);
    	char *dStringText;
    	int i;
d897 4
a900 5
    	    if ((*text == '.')
    	    	    && (*(text + 1) != '\0') && (*(text + 1) == '.')
    	    	    && (*(text + 2) != '\0') && (*(text + 2) == '.')) {
    	    	Tcl_DStringAppend(dStringPtr, elipsisString, -1);
    	    	i += strlen(elipsisString) - 1;
d902 2
a903 2
   	    } else {
    	    	Tcl_DStringSetLength(dStringPtr,
d905 4
a908 4
    	    	dStringText = Tcl_DStringValue(dStringPtr);
    	    	dStringText[i] = *text;
    	    }
    	}
d919 1
a919 10
 * 	that this item is rendered in.
 *
 * 	We try the following special mac characters. If none of them
 * 	are present, just use the check mark.
 * 	'' - Check mark character		(\022)
 * 	'¥' - Mac Bullet character		(\245)
 * 	'' - Filled diamond			(\023)
 * 	'' - Hollow diamond			(\327)
 * 	'' = Mac Long dash ("em dash")	(\321)
 * 	'-' = short dash (minus, "en dash");
d922 1
a922 1
 *	None.
d925 1
a925 1
 *	New item is added to platform menu
d930 1
a930 1
static char
d933 1
a933 1
    				 * for. */
d935 4
a938 1
    char markChar;
d942 1
a942 1
    	    (mePtr->fontPtr == NULL) ? mePtr->menuPtr->fontPtr
d944 6
a949 15
    	    
    if (!TkMacOSXIsCharacterMissing(tkfont, '\022')) {
    	markChar = '\022';	/* Check mark */
    } else if (!TkMacOSXIsCharacterMissing(tkfont, '\245')) {
    	markChar = '\245';	/* Bullet */
    } else if (!TkMacOSXIsCharacterMissing(tkfont, '\023')) {
    	markChar = '\023';	/* Filled Diamond */
    } else if (!TkMacOSXIsCharacterMissing(tkfont, '\327')) {
    	markChar = '\327';	/* Hollow Diamond */
    } else if (!TkMacOSXIsCharacterMissing(tkfont, '\321')) {
    	markChar = '\321';	/* Long Dash */
    } else if (!TkMacOSXIsCharacterMissing(tkfont, '-')) {
    	markChar = '-';		/* Short Dash */
    } else {
    	markChar = '\022';	/* Check mark */
d951 1
a951 1
    return markChar;
d957 1
a957 1
 * SetMenuTitle --
d959 2
a960 3
 *	Sets title of menu so that the text displays correctly in menubar.
 *	This code directly manipulates menu handle data. This code
 *	was originally part of an ancient Apple Developer Response mail.
d963 3
d968 39
d1008 1
a1008 2
 *	The menu handle will change size depending on the length of the
 *	title
d1013 30
a1042 17
static void
mySetMenuTitle(
    MenuRef menuHdl,		/* The menu we are setting the title of. */
    Tcl_Obj *titlePtr)	        /* The C string to set the title to. */
{
    char *title = (titlePtr == NULL) ? ""
	    : Tcl_GetStringFromObj(titlePtr, NULL);
    CFStringRef cf = CFStringCreateWithCString(NULL,
			    title, kCFStringEncodingUTF8);

    SetMenuTitleWithCFString(menuHdl, cf);
    CFRelease(cf);
}

static int ParseAccelerators(char **accelStringPtr) {
    char *accelString = *accelStringPtr;
    int flags = 0;
d1044 13
a1056 37
	if ((0 == strncasecmp("Control", accelString, 6))
		&& (('-' == accelString[6]) || ('+' == accelString[6]))) {
	    flags |= ENTRY_CONTROL_ACCEL;
	    accelString += 7;
	} else if ((0 == strncasecmp("Ctrl", accelString, 4))
		&& (('-' == accelString[4]) || ('+' == accelString[4]))) {
	    flags |= ENTRY_CONTROL_ACCEL;
	    accelString += 5;
	} else if ((0 == strncasecmp("Shift", accelString, 5))
		&& (('-' == accelString[5]) || ('+' == accelString[5]))) {
	    flags |= ENTRY_SHIFT_ACCEL;
	    accelString += 6;
	} else if ((0 == strncasecmp("Option", accelString, 6))
		&& (('-' == accelString[6]) || ('+' == accelString[6]))) {
	    flags |= ENTRY_OPTION_ACCEL;
	    accelString += 7;
	} else if ((0 == strncasecmp("Opt", accelString, 3))
		&& (('-' == accelString[3]) || ('+' == accelString[3]))) {
	    flags |= ENTRY_OPTION_ACCEL;
	    accelString += 4;
	} else if ((0 == strncasecmp("Command", accelString, 7))
		&& (('-' == accelString[7]) || ('+' == accelString[7]))) {
	    flags |= ENTRY_COMMAND_ACCEL;
	    accelString += 8;
	} else if ((0 == strncasecmp("Cmd", accelString, 3))
		&& (('-' == accelString[3]) || ('+' == accelString[3]))) {
	    flags |= ENTRY_COMMAND_ACCEL;
	    accelString += 4;
	} else if ((0 == strncasecmp("Alt", accelString, 3))
		&& (('-' == accelString[3]) || ('+' == accelString[3]))) {
	    flags |= ENTRY_OPTION_ACCEL;
	    accelString += 4;
	} else if ((0 == strncasecmp("Meta", accelString, 4))
		&& (('-' == accelString[4]) || ('+' == accelString[4]))) {
	    flags |= ENTRY_COMMAND_ACCEL;
	    accelString += 5;
	} else {
d1060 9
d1070 2
d1095 3
a1097 3
    TkMenuEntry *mePtr)	/* Information about menu entry;  may
		         * or may not already have values for
			 * some fields. */
d1100 1
a1100 5
#if 0 /* Unused */ 
    int index = mePtr->index;
    MenuHandle macMenuHdl = ((MacMenu *) menuPtr->platformData)->menuHdl;
    MenuHandle helpMenuHdl = NULL;
#endif
d1107 1
a1107 1
    
d1109 25
a1133 17
    	if ((mePtr->childMenuRefPtr != NULL)
    		&& (mePtr->childMenuRefPtr->menuPtr != NULL)) {
    	    MenuHandle childMenuHdl = ((MacMenu *) mePtr
    	    	    ->childMenuRefPtr->menuPtr->platformData)->menuHdl;
    	    
    	    if (childMenuHdl != NULL) {
    	    	int error = SetMenuCascade(mePtr->childMenuRefPtr->menuPtr);
    	    	
    	    	if (error != TCL_OK) {
    	    	    return error;
    	    	}
    	    	
    	    	if (menuPtr->menuType == MENUBAR) {
    	    	    mySetMenuTitle(childMenuHdl, mePtr->labelPtr);
    	    	}
    	    }
    	}
d1135 1
a1135 1
	
d1142 1
a1142 1
	
d1144 1
a1144 1
    	((EntryGeometry *)mePtr->platformEntryData)->accelTextStart = -1;
d1146 4
a1149 3
	char *accelString = (mePtr->accelPtr == NULL) ? ""
		: Tcl_GetStringFromObj(mePtr->accelPtr, NULL);
	char *accel = accelString;
d1151 4
a1154 5
	    
	mePtr->entryFlags |= ParseAccelerators(&accelString);
	
	((EntryGeometry *)mePtr->platformEntryData)->accelTextStart 
		= ((long) accelString - (long) accel);
d1156 1
a1156 1
    
d1158 2
a1159 2
    	menuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
    	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, (ClientData) menuPtr);
d1161 1
a1161 1
    
a1163 1

d1185 1
a1185 1
static void
d1189 3
a1191 3
    				 * Will not necessarily be
    				 * menuPtr->platformData because this could
    				 * be the help menu. */
d1193 3
a1195 3
    				 * touched. 0 for normal menus;
    				 * # of system help menu items
                                 * for help menus. */
d1202 7
a1208 3
#if defined(TK_MAC_DEBUG) && defined(TK_MAC_DEBUG_MENUS)
    /* Carbon-internal menu debugging (c.f. Technote 2124) */
    TkMacOSXInitNamedDebugSymbol(HIToolbox, void, DebugPrintMenu, MenuRef menu);
d1210 1
a1210 1
        DebugPrintMenu(macMenuHdl);
d1214 3
a1216 11
    for (mePtr = menuPtr->menuRefPtr->parentEntryPtr; mePtr != NULL;
    	    mePtr = mePtr->nextCascadePtr) {
    	char *name = (mePtr->namePtr == NULL) ? ""
    		: Tcl_GetStringFromObj(mePtr->namePtr, NULL);
    	
    	if (strcmp(Tk_PathName(menuPtr->tkwin), name) == 0) {
    	    if (mePtr->state == ENTRY_DISABLED) {
    	    	parentDisabled = 1;
    	    }
    	    break;
    	}
d1218 1
a1218 1
    
d1222 1
a1222 1
    
d1225 1
a1225 1
    	DeleteMenuItem(macMenuHdl, base + 1);
d1229 1
a1229 1
    
d1231 14
a1244 14
    	mePtr = menuPtr->entries[index - 1];
    
    	/*
    	 * We have to do separators separately because SetMenuItemText
    	 * does not parse meta-characters.
    	 */
    
    	if (mePtr->type == SEPARATOR_ENTRY) {
    	    AppendMenuItemTextWithCFString (macMenuHdl, NULL, 
                    kMenuItemAttrSeparator | kMenuItemAttrDisabled,
                    0, NULL);
    	} else {
    	    Tcl_DString itemTextDString;
            CFStringRef cf;    	    
d1246 5
a1250 5
            cf = CFStringCreateWithCString(NULL,
                  Tcl_DStringValue(&itemTextDString), kCFStringEncodingUTF8);
	    if (cf != NULL) {
              AppendMenuItemTextWithCFString (macMenuHdl, cf, 0, 0, NULL);
	      CFRelease(cf);
d1252 2
a1253 2
	      cf = CFSTR ("<Error>");
              AppendMenuItemTextWithCFString (macMenuHdl, cf, 0, 0, NULL);
d1256 4
a1259 4
	
    	    /*
    	     * Set enabling and disabling correctly.
    	     */
d1262 1
a1262 1
	    	DisableMenuItem(macMenuHdl, base + index);
d1264 1
a1264 1
	    	EnableMenuItem(macMenuHdl, base + index);
d1266 6
a1271 6
    	
    	    /*
    	     * Set the check mark for check entries and radio entries.
    	     */
	
	    SetItemMark(macMenuHdl, base + index, 0);		
d1274 2
a1275 2
	    	CheckMenuItem(macMenuHdl, base + index, (mePtr->entryFlags
                & ENTRY_SELECTED) && mePtr->indicatorOn);
d1279 2
a1280 2
		    	    FindMarkCharacter(mePtr));
	    	}
d1282 1
a1282 1
	
d1284 4
a1287 4
	    	if ((mePtr->childMenuRefPtr != NULL) 
	    	    	&& (mePtr->childMenuRefPtr->menuPtr != NULL)) {
	    	    MenuHandle childMenuHdl = 
	    	    	    ((MacMenu *) mePtr->childMenuRefPtr
d1291 28
a1318 30
		        {
		            SetMenuItemHierarchicalID(macMenuHdl, base + index,
				    GetMenuID(childMenuHdl));
		        }                     
	    	    }
	    	    /*
	    	     * If we changed the highligthing of this menu, its
	    	     * children all have to be reconfigured so that
	    	     * their state will be reflected in the menubar.
	    	     */
	    
	    	    if (!(mePtr->childMenuRefPtr->menuPtr->menuFlags 
	    	    	    	& MENU_RECONFIGURE_PENDING)) {
	    	    	mePtr->childMenuRefPtr->menuPtr->menuFlags
	    	    		|= MENU_RECONFIGURE_PENDING;
	    	    	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, 
	    	    		(ClientData) mePtr->childMenuRefPtr->menuPtr);
	    	    }
	    	}
	    }
	    
    	    if ((mePtr->type != CASCADE_ENTRY) && (mePtr->accelPtr != NULL)) {
                int accelLen;
		int modifiers = 0;
                int hasCmd = 0;
		int offset = ((EntryGeometry *)mePtr->platformEntryData)->accelTextStart;
    	    	char *accel = Tcl_GetStringFromObj(mePtr->accelPtr, &accelLen);
                accelLen -= offset;
		accel+= offset;
		
d1331 4
a1334 3
                if (accelLen == 1) {
		    if (hasCmd || (modifiers != 0 && modifiers != kMenuShiftModifier)) {
                        SetItemCmd(macMenuHdl, base + index, accel[0]);
d1339 3
a1341 4
                } else {
		    /* 
		     * Now we need to convert from various textual names
		     * to Carbon codes
d1343 33
a1375 3
		    char glyph = 0x0;
                    char first = UCHAR(accel[0]);
		    if (first == 'F' && (accel[1] > '0' && accel[1] <= '9')) {
d1377 7
a1383 2
			if (accel[2] > '0' && accel[2] <= '9') {
			    fkey = 10*fkey + (accel[2] - '0');
d1385 1
a1385 1
			if (fkey > 0 && fkey < 16) {
d1387 2
d1390 12
a1401 37
		    } else if (first == 'P' && 0 ==strcasecmp(accel,"pageup")) {
                        glyph = kMenuPageUpGlyph;
		    } else if (first == 'P' && 0 ==strcasecmp(accel,"pagedown")) {
                        glyph = kMenuPageDownGlyph;
		    } else if (first == 'L' && 0 ==strcasecmp(accel,"left")) {
                        glyph = kMenuLeftArrowGlyph;
		    } else if (first == 'R' && 0 ==strcasecmp(accel,"right")) {
                        glyph = kMenuRightArrowGlyph;
		    } else if (first == 'U' && 0 ==strcasecmp(accel,"up")) {
                        glyph = kMenuUpArrowGlyph;
		    } else if (first == 'D' && 0 ==strcasecmp(accel,"down")) {
                        glyph = kMenuDownArrowGlyph;
		    } else if (first == 'E' && 0 ==strcasecmp(accel,"escape")) {
                        glyph = kMenuEscapeGlyph;
		    } else if (first == 'C' && 0 ==strcasecmp(accel,"clear")) {
                        glyph = kMenuClearGlyph;
		    } else if (first == 'E' && 0 ==strcasecmp(accel,"enter")) {
                        glyph = kMenuEnterGlyph;
		    } else if (first == 'D' && 0 ==strcasecmp(accel,"backspace")) {
                        glyph = kMenuDeleteLeftGlyph;
		    } else if (first == 'S' && 0 ==strcasecmp(accel,"space")) {
                        glyph = kMenuSpaceGlyph;
		    } else if (first == 'T' && 0 ==strcasecmp(accel,"tab")) {
                        glyph = kMenuTabRightGlyph;
		    } else if (first == 'F' && 0 ==strcasecmp(accel,"delete")) {
                        glyph = kMenuDeleteRightGlyph;
		    } else if (first == 'H' && 0 ==strcasecmp(accel,"home")) {
                        glyph = kMenuNorthwestArrowGlyph;
		    } else if (first == 'R' && 0 ==strcasecmp(accel,"return")) {
                        glyph = kMenuReturnGlyph;
		    } else if (first == 'H' && 0 ==strcasecmp(accel,"help")) {
                        glyph = kMenuHelpGlyph;
		    } else if (first == 'P' && 0 ==strcasecmp(accel,"power")) {
                        glyph = kMenuPowerGlyph;
                    }
		    if (glyph != 0x0) {
			SetMenuItemKeyGlyph(macMenuHdl, base + index, glyph);
d1405 1
d1407 3
a1409 3
                }
		
		SetMenuItemModifiers(macMenuHdl, base + index, modifiers);
d1411 1
a1411 1
    	}
d1434 1
a1434 1
static void
d1436 3
a1438 3
    ClientData clientData)		/* Information about menu entry;  may
					 * or may not already have values for
					 * some fields. */
d1447 1
a1447 1
    	return;
a1451 5
    /* Not necessary in Carbon:
    if (menuPtr->menuFlags & MENU_APPLE_MENU) {
    	AppendResMenu(macMenuHdl, 'DRVR');
    }
    */
d1453 5
a1457 6
        MenuItemIndex helpIndex;
    	HMGetHelpMenu(&helpMenuHdl,&helpIndex);
    	if (helpMenuHdl != NULL) {
    	    ReconfigureIndividualMenu(menuPtr, helpMenuHdl, 
	            helpIndex - 1);
    	}
d1461 4
a1464 4
        if (!(menuBarFlags & MENUBAR_REDRAW_PENDING)) {
    	    Tcl_DoWhenIdle(DrawMenuBarWhenIdle, (ClientData *) NULL);
    	    menuBarFlags |= MENUBAR_REDRAW_PENDING;
    	}
d1485 1
a1485 1
static void
d1487 1
a1487 1
    TkMenu *menuPtr)			/* The menu we are completing. */
d1492 2
a1493 2
    	Tcl_CancelIdleCall(ReconfigureMacintoshMenu, (ClientData) menuPtr);
    	ReconfigureMacintoshMenu((ClientData) menuPtr);
d1495 1
a1495 1
    
d1497 5
a1501 8
        if (menuPtr->entries[i]->type == CASCADE_ENTRY) {
            if ((menuPtr->entries[i]->childMenuRefPtr != NULL)
            	    && (menuPtr->entries[i]->childMenuRefPtr->menuPtr
		    != NULL)) {
		CompleteIdlers(menuPtr->entries[i]->childMenuRefPtr
			->menuPtr);
	    }
        }
d1526 2
a1527 2
    				 * hand corner of where the menu is supposed
    				 * to be posted. */
a1532 1
    int oldMode;
d1534 4
a1537 5
    if (inPostMenu) {
        Tcl_AppendResult(interp,
		"Cannot call post menu while already posting menu",
		(char *) NULL);
    	result = TCL_ERROR;
d1539 1
a1539 1
    	short menuID;
d1542 19
a1560 54
	Tk_Window parentWindow = Tk_Parent(menuPtr->tkwin);
    
    	inPostMenu++;
    	
    	result = TkPreprocessMenu(menuPtr);
    	if (result != TCL_OK) {
    	    inPostMenu--;
    	    return result;
    	}

    	/*
    	 * The post commands could have deleted the menu, which means
    	 * we are dead and should go away.
    	 */
    	
    	if (menuPtr->tkwin == NULL) {
    	    inPostMenu--;
    	    return TCL_OK;
    	}

    	CompleteIdlers(menuPtr);
    	if (menuBarFlags & MENUBAR_REDRAW_PENDING) {
    	    Tcl_CancelIdleCall(DrawMenuBarWhenIdle, (ClientData *) NULL);
    	    DrawMenuBarWhenIdle((ClientData *) NULL);
        }
    	
	if (NULL == parentWindow) {
	    tearoffStruct.excludeRect.top = tearoffStruct.excludeRect.left
	    	    = tearoffStruct.excludeRect.bottom
		    = tearoffStruct.excludeRect.right = SHRT_MAX;
	} else {
	    int left, top;
	
	    Tk_GetRootCoords(parentWindow, &left, &top);
	    tearoffStruct.excludeRect.left = left;
	    tearoffStruct.excludeRect.top = top;
	    tearoffStruct.excludeRect.right = left + Tk_Width(parentWindow);
	    tearoffStruct.excludeRect.bottom = top + Tk_Height(parentWindow);
	    if (Tk_Class(parentWindow) == Tk_GetUid("Menubutton")) {
	    	TkWindow *parentWinPtr = (TkWindow *) parentWindow;
	    	TkMenuButton *mbPtr = 
	    		(TkMenuButton *) parentWinPtr->instanceData;
	    	int menuButtonWidth = Tk_Width(parentWindow)
	    		- 2 * (mbPtr->highlightWidth + mbPtr->borderWidth + 1);
	    	menuPtr->totalWidth = menuButtonWidth > menuPtr->totalWidth
	    		? menuButtonWidth : menuPtr->totalWidth;
	    }
	}
    	 
    	InsertMenu(macMenuHdl, -1);
    	RecursivelyInsertMenu(menuPtr);
    	CountMenuItems(macMenuHdl);
    	
	oldMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
d1562 2
a1563 1
	Tcl_SetServiceMode(oldMode);
a1564 4
	menuPtr->totalWidth = oldWidth;
	RecursivelyDeleteMenu(menuPtr);
	DeleteMenu(GetMenuID(macMenuHdl));
	
d1568 1
a1568 1
	 
d1571 1
a1571 1
	
d1575 1
a1575 1
	 
a1578 3
	} else {
	    TkMacOSXHandleTearoffMenu();
	    result = TCL_OK;
d1581 1
a1581 9
        /*
         * Be careful, here.  The command executed in handling the menu event
         * could destroy the window.  Don't try to do anything with it then.
         */
        
        if (menuPtr->tkwin) {
	    InvalidateMDEFRgns();
	    RecursivelyClearActiveMenu(menuPtr);
        }
d1614 1
a1614 1
    
d1619 2
d1623 2
a1624 2
    	menuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
    	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, (ClientData) menuPtr);
a1631 1
 * 
d1634 3
a1636 3
 *	Turns off all the menu drawing code.  This is more than just disabling
 *      the "menu" command, this means that Tk will NEVER touch the menubar.
 *      It is needed in the Plugin, where Tk does not own the menubar.
d1648 1
a1648 1
Tk_MacOSXTurnOffMenus()
a1655 1
 * 
d1669 1
a1669 1
static void
d1674 1
a1674 1
    TkMenu *appleMenuPtr, *helpMenuPtr;
d1677 1
a1677 1
    
d1681 1
a1681 1
     
d1683 1
a1683 1
        return;
d1685 1
a1685 1
    
d1689 1
a1689 1
 
d1691 8
a1698 9
    	hashEntryPtr = Tcl_FindHashEntry(&commandTable,
    		(char *) ((int)currentAppleMenuID));
    	appleMenuPtr = (TkMenu *) Tcl_GetHashValue(hashEntryPtr);
    	TkpDestroyMenu(appleMenuPtr);
    	TkpNewMenu(appleMenuPtr);
    	appleMenuPtr->menuFlags &= ~MENU_APPLE_MENU;
    	appleMenuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
    	Tcl_DoWhenIdle(ReconfigureMacintoshMenu, 
    		(ClientData) appleMenuPtr);
d1702 9
a1710 9
    	hashEntryPtr = Tcl_FindHashEntry(&commandTable,
    		(char *) ((int)currentHelpMenuID));
    	helpMenuPtr = (TkMenu *) Tcl_GetHashValue(hashEntryPtr);
    	TkpDestroyMenu(helpMenuPtr);
    	TkpNewMenu(helpMenuPtr);
    	helpMenuPtr->menuFlags &= ~MENU_HELP_MENU;
    	helpMenuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
    	Tcl_DoWhenIdle(ReconfigureMacintoshMenu,
    		(ClientData) helpMenuPtr);
d1712 1
a1712 1
    
d1715 1
a1715 1
     * Once we do that, for every cascade in the menu, we need to 
d1722 2
a1723 2
    	menuRefPtr = TkFindMenuReferences(currentMenuBarInterp,
    		currentMenuBarName);
d1725 21
a1745 25
    if (menuRefPtr != NULL) {
    	TkMenu *menuPtr, *menuBarPtr;
    	TkMenu *cascadeMenuPtr;
        char *appleMenuName, *helpMenuName;
        int appleIndex = -1, helpIndex = -1;
    	int i;
        
        menuPtr = menuRefPtr->menuPtr;
        if (menuPtr != NULL) {
            TkMenuReferences *specialMenuRefPtr;
            TkMenuEntry *specialEntryPtr;
            
            appleMenuName = ckalloc(strlen(currentMenuBarName)
            	    + 1 + strlen(".apple") + 1);
            sprintf(appleMenuName, "%s.apple", 
            	    Tk_PathName(menuPtr->tkwin));
            specialMenuRefPtr = TkFindMenuReferences(currentMenuBarInterp, 
            	    appleMenuName);
            if ((specialMenuRefPtr != NULL) 
            	    && (specialMenuRefPtr->menuPtr != NULL)) {
            	for (specialEntryPtr 
            		= specialMenuRefPtr->parentEntryPtr;
            		specialEntryPtr != NULL;
            		specialEntryPtr 
            		= specialEntryPtr->nextCascadePtr) {
d1747 2
a1748 2
		    	appleIndex = specialEntryPtr->index;
		    	break;
d1751 13
a1763 16
	    }	            	    	            
            ckfree(appleMenuName);
            
            helpMenuName = ckalloc(strlen(currentMenuBarName)
            	    + 1 + strlen(".help") + 1);
            sprintf(helpMenuName, "%s.help", 
            	    Tk_PathName(menuPtr->tkwin));
            specialMenuRefPtr = TkFindMenuReferences(currentMenuBarInterp, 
            	    helpMenuName);
            if ((specialMenuRefPtr != NULL)
            	    && (specialMenuRefPtr->menuPtr != NULL)) {
            	for (specialEntryPtr 
            		= specialMenuRefPtr->parentEntryPtr;
            		specialEntryPtr != NULL;
            		specialEntryPtr 
            		= specialEntryPtr->nextCascadePtr) {
d1765 2
a1766 2
		    	helpIndex = specialEntryPtr->index;
		    	break;
d1770 12
a1781 18
	    ckfree(helpMenuName);  
                
        }
        
        for (menuBarPtr = menuPtr; 
        	(menuBarPtr != NULL) 
        	&& (menuBarPtr->menuType != MENUBAR);
        	menuBarPtr = menuBarPtr->nextInstancePtr) {
        
            /*
             * Null loop body.
             */
             
        }
        
        if (menuBarPtr == NULL) {
            SetDefaultMenubar();
        } else {
d1783 11
a1793 11
	    	if (menuBarPtr->tearoff) {
	    	    appleIndex = (-1 == appleIndex) ? appleIndex
	    	    	    : appleIndex + 1;
	    	    helpIndex = (-1 == helpIndex) ? helpIndex
	    	    	    : helpIndex + 1;
	    	} else {
	    	    appleIndex = (-1 == appleIndex) ? appleIndex
	    	            : appleIndex - 1;
	    	    helpIndex = (-1 == helpIndex) ? helpIndex
	    	    	    : helpIndex - 1;
	    	}
d1796 1
a1796 1
	    
d1798 2
a1799 2
	    	InsertMenu(tkAppleMenu, 0);
	    	currentAppleMenuID = 0;
d1802 4
a1805 4
    		short appleID;
		OSStatus err;
    	    	appleMenuPtr = menuBarPtr->entries[appleIndex]
    	    	    	->childMenuRefPtr->menuPtr;
d1807 17
a1823 24
    		TkMacOSXGetNewMenuID(appleMenuPtr->interp, appleMenuPtr, 0, 
    			&appleID);
    		err = CreateNewMenu(appleID, kMenuAttrDoNotUseUserCommandKeys, 
			&macMenuHdl );
		if (err != noErr) {
		    Tcl_Panic("CreateNewMenu failed !");
		}
		SetMenuTitleWithCFString(tkAppleMenu, CFSTR("\024"));
    		appleMenuPtr->platformData = 
    			(TkMenuPlatformData) ckalloc(sizeof(MacMenu));
    		((MacMenu *)appleMenuPtr->platformData)->menuHdl
    			= macMenuHdl;
    		SetRect(&((MacMenu *) appleMenuPtr->platformData)->menuRect,
    			0, 0, 0, 0);
    	    	appleMenuPtr->menuFlags |= MENU_APPLE_MENU;
    	    	if (!(appleMenuPtr->menuFlags 
    	    		& MENU_RECONFIGURE_PENDING)) {
    	    	    appleMenuPtr->menuFlags |= MENU_RECONFIGURE_PENDING;
    	    	    Tcl_DoWhenIdle(ReconfigureMacintoshMenu,
    	    	    	    (ClientData) appleMenuPtr);
    	    	}
    	    	InsertMenu(macMenuHdl, 0);
    	    	RecursivelyInsertMenu(appleMenuPtr);
    	    	currentAppleMenuID = appleID;
d1827 1
a1827 1
	    	currentHelpMenuID = 0;
d1829 1
a1829 1
	    
d1831 9
a1839 11
	    	if (i == appleIndex) {
	    	    if (menuBarPtr->entries[i]->state == ENTRY_DISABLED) {
	    	    	DisableMenuItem(((MacMenu *) menuBarPtr->entries[i]
	    	    		->childMenuRefPtr->menuPtr
	    	    		->platformData)->menuHdl,
	    	    		0);
	    	    } else {
	    	    	EnableMenuItem(((MacMenu *) menuBarPtr->entries[i]
	    	    		->childMenuRefPtr->menuPtr
	    	    		->platformData)->menuHdl,
	    	    		0);
d1841 23
a1863 23
	    	    continue;
	    	} else if (i == helpIndex) {
	    	    TkMenu *helpMenuPtr = menuBarPtr->entries[i]
	    	    	    ->childMenuRefPtr->menuPtr;
	    	    
	    	    if (helpMenuPtr == NULL) {
	    	    	continue;
	    	    }
	    	    helpMenuPtr->menuFlags |= MENU_HELP_MENU;
	    	    if (!(helpMenuPtr->menuFlags
	    	    	    & MENU_RECONFIGURE_PENDING)) {
	    	    	helpMenuPtr->menuFlags 
	    	    		|= MENU_RECONFIGURE_PENDING;
	    	    	Tcl_DoWhenIdle(ReconfigureMacintoshMenu,
	    	    		(ClientData) helpMenuPtr);
	    	    }
	    	    macMenuHdl = 
	    	    	    ((MacMenu *) helpMenuPtr->platformData)->menuHdl;
	    	    currentHelpMenuID = GetMenuID(macMenuHdl);
	    	} else if (menuBarPtr->entries[i]->type 
	    		== CASCADE_ENTRY) {
	    	    if ((menuBarPtr->entries[i]->childMenuRefPtr != NULL)
	    		    && menuBarPtr->entries[i]->childMenuRefPtr
d1865 18
a1882 20
	    	    	cascadeMenuPtr = menuBarPtr->entries[i]
			    	->childMenuRefPtr->menuPtr;
	    	    	macMenuHdl = ((MacMenu *) cascadeMenuPtr
	    	    		->platformData)->menuHdl;
		    	DeleteMenu(GetMenuID(macMenuHdl));
	    	    	InsertMenu(macMenuHdl, 0);
	    	    	RecursivelyInsertMenu(cascadeMenuPtr);
	    	    	if (menuBarPtr->entries[i]->state == ENTRY_DISABLED) {
	    	    	    DisableMenuItem(((MacMenu *) menuBarPtr->entries[i]
	    	    	    	    ->childMenuRefPtr->menuPtr
	    	    	    	    ->platformData)->menuHdl,
				    0);
	    	    	} else {
	    	    	    EnableMenuItem(((MacMenu *) menuBarPtr->entries[i]
	    	    	    	    ->childMenuRefPtr->menuPtr
	    	    	    	    ->platformData)->menuHdl,
				    0);
	    	    	 }
	    	    }
	    	}
d1885 3
a1887 2
    } else {
    	SetDefaultMenubar();
a1891 1

a1899 1
 *
d1909 1
a1909 1
static void
d1912 1
a1912 1
    				 * will be inserted into the mac menubar. */
d1917 1
a1917 1
    
d1919 8
a1926 9
        if (menuPtr->entries[i]->type == CASCADE_ENTRY) {
            if ((menuPtr->entries[i]->childMenuRefPtr != NULL)
            	    && (menuPtr->entries[i]->childMenuRefPtr->menuPtr
		    != NULL)) {
            	cascadeMenuPtr = menuPtr->entries[i]->childMenuRefPtr->menuPtr;
	    	macMenuHdl =
		        ((MacMenu *) cascadeMenuPtr->platformData)->menuHdl;
	    	InsertMenu(macMenuHdl, -1);
	    	RecursivelyInsertMenu(cascadeMenuPtr);
d1928 1
a1928 1
        }
a1939 1
 *
d1949 1
a1949 1
static void
d1952 1
a1952 1
    				 * will be inserted into the mac menubar. */
d1957 1
a1957 1
    
d1959 8
a1966 9
        if (menuPtr->entries[i]->type == CASCADE_ENTRY) {
            if ((menuPtr->entries[i]->childMenuRefPtr != NULL)
            	    && (menuPtr->entries[i]->childMenuRefPtr->menuPtr
		    != NULL)) {
            	cascadeMenuPtr = menuPtr->entries[i]->childMenuRefPtr->menuPtr;
	    	macMenuHdl =
		        ((MacMenu *) cascadeMenuPtr->platformData)->menuHdl;
	    	DeleteMenu(GetMenuID(macMenuHdl));
	    	RecursivelyInsertMenu(cascadeMenuPtr);
d1968 1
a1968 1
        }
d1988 2
a1989 2
static void
SetDefaultMenubar()
d1992 2
a1993 2
    	ckfree(currentMenuBarName);
    	currentMenuBarName = NULL;
d2001 2
a2002 2
    	Tcl_DoWhenIdle(DrawMenuBarWhenIdle, (ClientData *) NULL);
    	menuBarFlags |= MENUBAR_REDRAW_PENDING;
d2028 2
a2029 2
    				 * If NULL, use the default menu bar.
    				 */
d2032 1
a2032 1
    CGrafPtr  winPort;
d2038 1
a2038 1
        return;
d2041 2
a2042 2
    
    frontNonFloating = ActiveNonFloatingWindow();    
d2044 1
a2044 1
    	return;
d2047 3
a2049 5
    if ((currentMenuBarInterp != interp) 
            || (currentMenuBarOwner != tkwin) 
            || (currentMenuBarName == NULL)
            || (menuName == NULL) 
            || (strcmp(menuName, currentMenuBarName) != 0)) {        
d2051 5
a2055 5
    	TopLevelMenubarList *listPtr;
	    		    
        if (currentMenuBarName != NULL) {
            ckfree(currentMenuBarName);
        }
d2060 11
a2070 11
	    	TkMenuReferences *menuRefPtr;
	    	    
	    	menuRefPtr = TkFindMenuReferences(interp, Tk_PathName(tkwin));
	    	if (menuRefPtr != NULL) {
	    	    TkMenu *menuPtr = menuRefPtr->menuPtr;
	    	    if (menuPtr != NULL) {
	    	    	menuPtr = menuPtr->masterMenuPtr;
	    	    	searchWindow = menuPtr->tkwin;
	    	    }
	    	}
	    } 
d2073 11
a2083 12
	    	
	    	for (listPtr = windowListPtr; listPtr != NULL;
	    		listPtr = listPtr->nextPtr) {
	    	    if (listPtr->tkwin == searchWindow) {
	    	    	break;
	    	    }
	    	}
	    	if (listPtr != NULL) {
	    	    menuName = Tk_PathName(listPtr->menuPtr->masterMenuPtr
			    ->tkwin);
	    	    break;
	    	}
d2086 1
a2086 1
	
d2089 2
a2090 2
	} else {            
            currentMenuBarName = ckalloc(strlen(menuName) + 1);
d2092 3
a2094 3
        }
        currentMenuBarOwner = tkwin;
        currentMenuBarInterp = interp;
d2097 2
a2098 2
    	Tcl_DoWhenIdle(DrawMenuBarWhenIdle, (ClientData *) NULL);
    	menuBarFlags |= MENUBAR_REDRAW_PENDING;
d2125 1
a2125 1
    
d2129 4
a2132 4
    
    for (prevPtr = NULL, listPtr = windowListPtr; 
    	    listPtr != NULL; 
    	    prevPtr = listPtr, listPtr = listPtr->nextPtr) {
d2135 1
a2135 1
	}    	 
d2137 1
a2137 1
    
d2139 6
a2144 6
    	if (prevPtr != NULL) {
    	    prevPtr->nextPtr = listPtr->nextPtr;
    	} else {
    	    windowListPtr = listPtr->nextPtr;
    	}
    	ckfree((char *) listPtr);
d2146 1
a2146 1
    
d2148 5
a2152 5
    	listPtr = (TopLevelMenubarList *) ckalloc(sizeof(TopLevelMenubarList));
    	listPtr->nextPtr = windowListPtr;
    	windowListPtr = listPtr;
    	listPtr->tkwin = tkwin;
    	listPtr->menuPtr = menuPtr;
d2155 1
a2155 2

static void 
d2162 1
a2162 1
 *      scheduled in TkMacOSXDispatchMenuEvent.
d2173 3
a2175 1
EventuallyInvokeMenu (ClientData data)
d2177 2
a2178 2
    struct MenuCommandHandlerData *realData
            = (struct MenuCommandHandlerData *) data;
d2182 9
a2190 6
            realData->index);
            
    if (code != TCL_OK && code != TCL_CONTINUE
            && code != TCL_BREAK) {
        Tcl_AddErrorInfo(realData->menuPtr->interp, "\n    (menu invoke)");
        Tcl_BackgroundError(realData->menuPtr->interp);
d2192 2
a2193 1
    
d2197 1
a2197 1

d2217 3
a2219 3
    int menuID,		/* The menu id of the menu we are invoking */
    int index)		/* The one-based index of the item that was 
                         * selected. */
d2222 1
d2224 11
a2234 10
    	if (menuID == kHMHelpMenuID) {
    	    if (currentMenuBarOwner != NULL) {
    	    	TkMenuReferences *helpMenuRef;
    	    	char *helpMenuName = ckalloc(strlen(currentMenuBarName)
    	    		+ strlen(".help") + 1);
    	    	sprintf(helpMenuName, "%s.help", currentMenuBarName);
    	    	helpMenuRef = TkFindMenuReferences(currentMenuBarInterp,
    	    		helpMenuName);
    	    	ckfree(helpMenuName);
    	    	if ((helpMenuRef != NULL) && (helpMenuRef->menuPtr != NULL)) {
d2238 1
d2240 35
a2274 33
    	    	    newIndex = index - itemIndex;
    	    	    result = TkInvokeMenu(currentMenuBarInterp,
    	    	    	    helpMenuRef->menuPtr, newIndex);
    	    	}
    	    }
    	} else {
	    Tcl_HashEntry *commandEntryPtr = 
	    	    Tcl_FindHashEntry(&commandTable, (char *) ((int)menuID));
            if (commandEntryPtr != NULL) {
                TkMenu *menuPtr = (TkMenu *) Tcl_GetHashValue(commandEntryPtr);
                if ((currentAppleMenuID == menuID)
                    && (index > menuPtr->numEntries + 1)) {
                    /* 
                     * We don't need to do anything here, the standard
                     * Application event handler will open the built-in
                     * Apple menu item for us.
                     */
                    result = TCL_OK;
                } else {
                    struct MenuCommandHandlerData *data
                            = (struct MenuCommandHandlerData *)
                            ckalloc(sizeof(struct MenuCommandHandlerData));
                    Tcl_Preserve(menuPtr->interp);
                    Tcl_Preserve(menuPtr);
                    data->menuPtr = menuPtr;
                    data->index = index - 1;
                    Tcl_DoWhenIdle (EventuallyInvokeMenu,
                            (ClientData) data);
                    /* result = TkInvokeMenu(menuPtr->interp, menuPtr, index - 1); */
                }
            } else {
                return TCL_ERROR;
            }
d2279 1
a2279 1

d2296 1
a2296 1
static void
d2298 18
a2315 13
    TkMenu *menuPtr,			/* The menu we are drawing */
    TkMenuEntry *mePtr,			/* The entry we are measuring */
    Tk_Font tkfont,			/* Precalculated font */
    CONST Tk_FontMetrics *fmPtr,	/* Precalculated font metrics */
    int *widthPtr,			/* The resulting width */
    int *heightPtr)			/* The resulting height */
{
    char markChar;
    
    *heightPtr = fmPtr->linespace;
 
    markChar = (char) FindMarkCharacter(mePtr);
    *widthPtr = Tk_TextWidth(tkfont, &markChar, 1) + 4;
d2334 1
a2334 1
static void
d2336 59
a2394 55
    TkMenu *menuPtr,			/* The menu we are measuring */
    TkMenuEntry *mePtr,			/* The entry we are measuring */
    Tk_Font tkfont,			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr,	/* The precalculated font metrics */
    int *modWidthPtr,			/* The width of all of the key
    					 * modifier symbols. */
    int *textWidthPtr,			/* The resulting width */
    int *heightPtr)			/* The resulting height */
{
    *heightPtr = fmPtr->linespace;
    *modWidthPtr = 0;
    if (mePtr->type == CASCADE_ENTRY) {
        *textWidthPtr = SICN_HEIGHT;
    	*modWidthPtr = Tk_TextWidth(tkfont, "W", 1);
    } else if (0 == mePtr->accelLength) {
    	*textWidthPtr = 0;
    } else {
    	char *accel = (mePtr->accelPtr == NULL) ? ""
    		: Tcl_GetStringFromObj(mePtr->accelPtr, NULL);
    	
    	if (NULL == GetResource('SICN', SICN_RESOURCE_NUMBER)) {
    	    *textWidthPtr = Tk_TextWidth(tkfont, accel, mePtr->accelLength);
    	} else {
    	    int emWidth = Tk_TextWidth(tkfont, "W", 1) + 1;
    	    if ((mePtr->entryFlags & ENTRY_ACCEL_MASK) == 0) {
    	    	int width = Tk_TextWidth(tkfont, accel,	mePtr->accelLength);
    	    	*textWidthPtr = emWidth;
    	    	if (width < emWidth) {
    	    	    *modWidthPtr = 0;
    	    	} else {
    	    	    *modWidthPtr = width - emWidth;
    	    	}   
    	    } else {
    	        int length = ((EntryGeometry *)mePtr->platformEntryData)
    	    	    	->accelTextStart;
    	    	if (mePtr->entryFlags & ENTRY_CONTROL_ACCEL) {
    	    	    *modWidthPtr += CONTROL_ICON_WIDTH;
    	    	}
    	    	if (mePtr->entryFlags & ENTRY_SHIFT_ACCEL) {
    	    	    *modWidthPtr += SHIFT_ICON_WIDTH;
    	    	}
    	    	if (mePtr->entryFlags & ENTRY_OPTION_ACCEL) {
    	    	    *modWidthPtr += OPTION_ICON_WIDTH;
    	    	}
    	    	if (mePtr->entryFlags & ENTRY_COMMAND_ACCEL) {
    	    	    *modWidthPtr += COMMAND_ICON_WIDTH;
    	    	}
    	    	if (1 == (mePtr->accelLength - length)) {
    	    	    *textWidthPtr = emWidth;
    	    	} else {
    	    	    *textWidthPtr += Tk_TextWidth(tkfont, accel 
    		    	    + length, mePtr->accelLength - length);
    		}
    	    }
    	}
d2414 1
a2414 1
static void
d2416 13
a2428 11
    TkMenu *menuPtr,			/* The menu we are drawing */
    TkMenuEntry *mePtr,			/* The entry we are measuring */
    Tk_Font tkfont,			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr,	/* The precalculated font metrics */
    int *widthPtr,			/* The resulting width */
    int *heightPtr)			/* The resulting height */
{
    if ((GetResource('MDEF', 591) == NULL) &&
	    (menuPtr->menuType == MASTER_MENU)) {
    	*heightPtr = fmPtr->linespace;
    	*widthPtr = 0;
d2450 1
a2450 1
static void
d2452 9
a2460 12
    TkMenu *menuPtr,			/* The menu we are drawing */
    TkMenuEntry *mePtr,			/* The entry we are measuring */
    Tk_Font tkfont,			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr,	/* The precalcualted font metrics */
    int *widthPtr,			/* The resulting width */
    int *heightPtr)			/* The resulting height */
{
        SInt16 outHeight;
        
        GetThemeMenuSeparatorHeight(&outHeight);
        *widthPtr = 0;
        *heightPtr = outHeight;
d2480 1
a2480 1
static void
d2482 57
a2538 38
    TkMenu *menuPtr,			/* The menu we are drawing */
    TkMenuEntry *mePtr,			/* The entry we are drawing */
    Drawable d,				/* The drawable we are drawing */
    GC gc,				/* The GC we are drawing with */
    GC indicatorGC,			/* The GC to use for the indicator */
    Tk_Font tkfont,			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr,	/* The precalculated font metrics */
    int x,				/* topleft hand corner of entry */
    int y,				/* topleft hand corner of entry */
    int width,				/* width of entry */
    int height)				/* height of entry */
{
    if ((mePtr->type == CHECK_BUTTON_ENTRY) || 
    	    (mePtr->type == RADIO_BUTTON_ENTRY)) {
    	if (mePtr->indicatorOn
    	    	&& (mePtr->entryFlags & ENTRY_SELECTED)) {
	    int baseline;
	    short markShort;
    
    	    baseline = y + (height + fmPtr->ascent - fmPtr->descent) / 2;
    	    GetItemMark(((MacMenu *) menuPtr->platformData)->menuHdl,
    		    mePtr->index + 1, &markShort);
            if (markShort != 0) {
	    	char markChar;
	    	char markCharUTF[TCL_UTF_MAX + 1];
	    	int dstWrote;
	    	
            	markChar = (char) markShort;
                /* 
                 * Not sure if this is the correct encoding, but this function
                 * doesn't appear to be used at all in, since the Carbon Menus
                 * draw themselves
                 */
            	Tcl_ExternalToUtf(NULL, NULL, &markChar, 1, 0, NULL,
			markCharUTF, TCL_UTF_MAX + 1, NULL, &dstWrote, NULL);
		Tk_DrawChars(menuPtr->display, d, gc, tkfont, markCharUTF,
			dstWrote, x + 2, baseline);
            }
d2540 1
a2540 1
    }    
d2543 1
d2560 1
a2560 1
static void
d2562 1
d2564 1
a2564 3
    Drawable d,			/* What we are drawing into */
    ThemeMenuType type			/* Type of menu */    
    )
d2566 1
a2566 3
    CGrafPtr saveWorld;
    GDHandle saveDevice;
    GWorldPtr destPort;
d2568 7
a2574 79
    destPort = TkMacOSXGetDrawablePort(d);
    GetGWorld(&saveWorld, &saveDevice);
    SetGWorld(destPort, NULL);
    TkMacOSXSetUpClippingRgn(d);
    DrawThemeMenuBackground (menuRectPtr, type);
    SetGWorld(saveWorld, saveDevice);    
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * DrawSICN --
 *
 *	Given a resource id and an index, loads the appropriate SICN
 *	and draws it into a given drawable using the given gc.
 *
 * Results:
 *	Returns 1 if the SICN was found, 0 if not found.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */
static int
DrawSICN(
    int resourceID,		    /* The resource # of the SICN table */
    int index,			    /* The index into the SICN table of the
    				     * icon we want. */
    Drawable d,			    /* What we are drawing into */
    GC gc,			    /* The GC to draw with */
    int x,			    /* The left hand coord of the SICN */
    int y)			    /* The top coord of the SICN */
{
    Handle sicnHandle = (Handle) GetResource('SICN', SICN_RESOURCE_NUMBER);
    
    if (NULL == sicnHandle) {
    	return 0;
    } else {
    	BitMap sicnBitmap;
	Rect destRect;
	CGrafPtr saveWorld;
	GDHandle saveDevice;
	GWorldPtr destPort;
	const BitMap *destBitMap;
	RGBColor origForeColor, origBackColor, foreColor, backColor;

	HLock(sicnHandle);
	destPort = TkMacOSXGetDrawablePort(d);
	GetGWorld(&saveWorld, &saveDevice);
	SetGWorld(destPort, NULL);
	TkMacOSXSetUpClippingRgn(d);
	TkMacOSXSetUpGraphicsPort(gc, destPort);
	GetForeColor(&origForeColor);
	GetBackColor(&origBackColor);
	
	if (TkSetMacColor(gc->foreground, &foreColor)) {
	    RGBForeColor(&foreColor);
	}
	
	if (TkSetMacColor(gc->background, &backColor)) {
	    RGBBackColor(&backColor);
	}

	SetRect(&destRect, x, y, x + SICN_HEIGHT, y + SICN_HEIGHT);
	sicnBitmap.baseAddr = (Ptr) (*sicnHandle) + index * SICN_HEIGHT
	    * SICN_ROWS;
	sicnBitmap.rowBytes = SICN_ROWS;
	SetRect(&sicnBitmap.bounds, 0, 0, 16, 16);
	destBitMap = GetPortBitMapForCopyBits(destPort);
	CopyBits(&sicnBitmap, destBitMap, &sicnBitmap.bounds, &destRect, GetPortTextMode(destPort), NULL);
	HUnlock(sicnHandle);
	RGBForeColor(&origForeColor);
	RGBBackColor(&origBackColor);
	SetGWorld(saveWorld, saveDevice);    
    	return 1;
    }
d2576 1
d2583 1
a2583 3
 *	This procedure draws the accelerator part of a menu. We
 *	need to decide what to draw here. Should we replace strings
 *	like "Control", "Command", etc?
d2595 1
a2595 1
static void
d2597 35
a2631 40
    TkMenu *menuPtr,		    /* The menu we are drawing */
    TkMenuEntry *mePtr,		    /* The entry we are drawing */
    Drawable d,			    /* The drawable we are drawing in */
    GC gc,			    /* The gc to draw into */
    Tk_Font tkfont,		    /* The precalculated font */
    CONST Tk_FontMetrics *fmPtr,    /* The precalculated font metrics */
    Tk_3DBorder activeBorder,	    /* border for menu background */
    int x,			    /* The left side of the entry */
    int y,			    /* The top of the entry */
    int width,			    /* The width of the entry */
    int height,			    /* The height of the entry */
    int drawArrow)		    /* Whether or not to draw cascade arrow */
{
    int activeBorderWidth;
    
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
    	    &activeBorderWidth);
    if (mePtr->type == CASCADE_ENTRY) {
        /*
         * Under Appearance, we let the Appearance Manager draw the icon
         */
         
    } else if (mePtr->accelLength != 0) {
    	int leftEdge = x + width;
    	int baseline = y + (height + fmPtr->ascent - fmPtr->descent) / 2;
    	char *accel;
    	
    	accel = Tcl_GetStringFromObj(mePtr->accelPtr, NULL);

	if (NULL == GetResource('SICN', SICN_RESOURCE_NUMBER)) {
	    leftEdge -= ((EntryGeometry *) mePtr->platformEntryData)
	    	    ->accelTextWidth;
	    Tk_DrawChars(menuPtr->display, d, gc, tkfont, accel,
	    	    mePtr->accelLength, leftEdge, baseline);
	} else {
	    EntryGeometry *geometryPtr = 
	    	    (EntryGeometry *) mePtr->platformEntryData;
	    int length = mePtr->accelLength - geometryPtr->accelTextStart;
	    
	    leftEdge -= geometryPtr->accelTextWidth;
d2633 1
a2633 1
	    	leftEdge -= geometryPtr->modifierWidth;
d2635 16
a2650 8
	    
	    Tk_DrawChars(menuPtr->display, d, gc, tkfont, accel 
		    + geometryPtr->accelTextStart, length, leftEdge, baseline);

	    if (mePtr->entryFlags & ENTRY_COMMAND_ACCEL) {
	    	leftEdge -= COMMAND_ICON_WIDTH;
	    	DrawSICN(SICN_RESOURCE_NUMBER, COMMAND_ICON, d, gc,
	    		leftEdge, (y + (height / 2)) - (SICN_HEIGHT / 2) - 1);
d2652 12
a2663 5

	    if (mePtr->entryFlags & ENTRY_OPTION_ACCEL) {
	    	leftEdge -= OPTION_ICON_WIDTH;
	    	DrawSICN(SICN_RESOURCE_NUMBER, OPTION_ICON, d, gc,
	    		leftEdge, (y + (height / 2)) - (SICN_HEIGHT / 2) - 1);
d2665 4
a2668 13

	    if (mePtr->entryFlags & ENTRY_SHIFT_ACCEL) {
	    	leftEdge -= SHIFT_ICON_WIDTH;
	    	DrawSICN(SICN_RESOURCE_NUMBER, SHIFT_ICON, d, gc,
	    		leftEdge, (y + (height / 2)) - (SICN_HEIGHT / 2) - 1);
	    }

	    if (mePtr->entryFlags & ENTRY_CONTROL_ACCEL) {
	    	leftEdge -= CONTROL_ICON_WIDTH;
	    	DrawSICN(SICN_RESOURCE_NUMBER, CONTROL_ICON, d, gc,
	    		leftEdge, (y + (height / 2)) - (SICN_HEIGHT / 2) - 1);
	    }
    	}
d2689 1
a2689 1
static void
d2691 13
a2703 14
    TkMenu *menuPtr,			/* The menu we are drawing */
    TkMenuEntry *mePtr,			/* The entry we are drawing */
    Drawable d,				/* The drawable we are drawing into */
    GC gc,				/* The gc we are drawing with */
    Tk_Font tkfont,			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr,	/* The precalculated font metrics */
    int x,				/* left coordinate of entry */
    int y,				/* top coordinate of entry */
    int width,				/* width of entry */
    int height)				/* height of entry */
{
    CGrafPtr saveWorld;
    GDHandle saveDevice;
    GWorldPtr destPort;
d2705 1
a2705 1
   
d2707 1
a2707 2
    GetGWorld(&saveWorld, &saveDevice);
    SetGWorld(destPort, NULL);
a2712 1
         
d2714 3
d2719 1
d2723 1
a2723 1
 *   AppearanceEntryDrawWrapper --
d2725 2
a2726 2
 *      It routes to the Appearance Managers DrawThemeEntry, which will
 *      then call us back after setting up the drawing context.
d2736 1
a2736 1
static void 
d2740 1
a2740 1
    MenuTrackingData *mtdPtr,     
d2742 3
a2744 6
    Tk_FontMetrics *fmPtr, 
    Tk_Font tkfont, 
    int x, 
    int y, 
    int width, 
    int height)
d2750 1
d2754 14
a2767 2
    meData.fmPtr = fmPtr;
    meData.tkfont = tkfont;
a2768 5
    itemRect.top = y;
    itemRect.left = x;
    itemRect.bottom = itemRect.top + height;
    itemRect.right = itemRect.left + width;
                
d2770 1
a2770 1
        theState = kThemeMenuSelected;
d2772 1
a2772 1
        theState = kThemeMenuDisabled;
d2774 1
a2774 1
        theState = kThemeMenuActive;
a2775 1
    
d2777 1
a2777 1
        theType = kThemeMenuItemHierarchical;
d2779 12
a2790 1
        theType = kThemeMenuItemPlain;
a2791 6
    
    DrawThemeMenuItem (menuRectPtr, &itemRect,
        mtdPtr->virtualMenuTop, mtdPtr->virtualMenuBottom, theState,
        theType, tkThemeMenuItemDrawingUPP, 
        (unsigned long) &meData);
    
d2797 1
a2797 1
 *  ThemeMenuItemDrawingProc --
d2809 2
a2810 2
static pascal void
ThemeMenuItemDrawingProc (
d2812 2
a2813 2
    SInt16 inDepth, 
    Boolean inIsColorDevice, 
d2817 5
a2821 4
    TkpDrawMenuEntry(meData->mePtr, meData->mdefDrawable,
    	 meData->tkfont, meData->fmPtr, inBounds->left, 
    	 inBounds->top, inBounds->right - inBounds->left,
    	 inBounds->bottom - inBounds->top, 0, 1);
d2823 1
d2845 3
a2847 23
    if (tearoffStruct.menuPtr != NULL) {
    	Tcl_DString tearoffCmdStr;
    	char intString[TCL_INTEGER_SPACE];
    	short windowPart;
    	WindowRef whichWindow;
    	
    	windowPart = FindWindow(tearoffStruct.point, &whichWindow);
    	
    	if (windowPart != inMenuBar) {
    	    Tcl_DStringInit(&tearoffCmdStr);
    	    Tcl_DStringAppendElement(&tearoffCmdStr, "tkTearOffMenu");
    	    Tcl_DStringAppendElement(&tearoffCmdStr, 
    		    Tk_PathName(tearoffStruct.menuPtr->tkwin));
	    sprintf(intString, "%d", tearoffStruct.point.h);
	    Tcl_DStringAppendElement(&tearoffCmdStr, intString);
	    sprintf(intString, "%d", tearoffStruct.point.v);
	    Tcl_DStringAppendElement(&tearoffCmdStr, intString);
	    Tcl_Eval(tearoffStruct.menuPtr->interp,
		    Tcl_DStringValue(&tearoffCmdStr));
	    Tcl_DStringFree(&tearoffCmdStr);
	    tearoffStruct.menuPtr = NULL;
	}
    }
d2870 4
a2873 3
TkpInitializeMenuBindings(interp, bindingTable)
    Tcl_Interp *interp;		    /* The interpreter to set. */
    Tk_BindingTable bindingTable;   /* The table to add to. */
d2900 2
a2901 2
TkpComputeMenubarGeometry(menuPtr)
    TkMenu *menuPtr;		/* Structure describing menu. */
d2911 1
a2911 1
 *	This procedure draws the background part of a menu.
d2925 10
a2934 10
    TkMenu *menuPtr,			/* The menu we are drawing */
    TkMenuEntry *mePtr,			/* The entry we are drawing */
    Drawable d,				/* The drawable we are drawing into */
    GC gc,				/* The gc we are drawing with */
    Tk_Font tkfont,			/* The font we are drawing with */
    CONST Tk_FontMetrics *fmPtr,	/* The metrics we are drawing with */
    int x,				/* Left edge of entry. */
    int y,				/* Top edge of entry. */
    int width,				/* Width of entry. */
    int height)				/* Height of entry. */
d2943 2
a2944 2
    
    margin = (fmPtr->ascent + fmPtr->descent)/2;
d2949 1
a2949 1
    maxX  = width - 1;
d2971 3
a2973 3
 *      NB. Nobody uses this any more, since you can get the number
 *      of system help items from HMGetHelpMenu trivially.
 *      But it is in the stubs table...
d2984 2
a2985 2
void 
TkMacOSXSetHelpMenuItemCount()
d2987 3
d3009 1
a3009 1
TkMacOSXMenuClick()
d3013 1
a3013 1
    
d3015 9
a3023 9
    	menuRefPtr = TkFindMenuReferences(currentMenuBarInterp,
    		currentMenuBarName);
    	for (menuPtr = menuRefPtr->menuPtr->masterMenuPtr;
    		menuPtr != NULL; menuPtr = menuPtr->nextInstancePtr) {
    	    if (menuPtr->menuType == MENUBAR) {
    	        CompleteIdlers(menuPtr);
    	        break;
    	    }
    	}
d3025 1
a3025 1
    
d3027 2
a3028 2
    	Tcl_CancelIdleCall(DrawMenuBarWhenIdle, (ClientData *) NULL);
    	DrawMenuBarWhenIdle((ClientData *) NULL);
d3051 13
a3063 13
    TkMenuEntry *mePtr,		    /* The entry to draw */
    Drawable d,			    /* What to draw into */
    Tk_Font tkfont,		    /* Precalculated font for menu */
    CONST Tk_FontMetrics *menuMetricsPtr,
				    /* Precalculated metrics for menu */
    int x,			    /* X-coordinate of topleft of entry */
    int y,			    /* Y-coordinate of topleft of entry */
    int width,			    /* Width of the entry rectangle */
    int height,			    /* Height of the current rectangle */
    int strictMotif,		    /* Boolean flag */
    int drawArrow)		    /* Whether or not to draw the cascade
				     * arrow for cascade items. Only applies
				     * to Windows. */
d3077 1
a3077 1
     * Under Appearance, we pass a null (appearanceGC) to tell 
d3084 1
a3084 1
            gc = menuPtr->activeGC;
d3087 1
a3087 16
    	TkMenuEntry *cascadeEntryPtr;
    	int parentDisabled = 0;
    	
    	for (cascadeEntryPtr = menuPtr->menuRefPtr->parentEntryPtr;
    		cascadeEntryPtr != NULL;
    		cascadeEntryPtr = cascadeEntryPtr->nextCascadePtr) {
    	    char *name = (cascadeEntryPtr->namePtr == NULL) ? ""
    	    	    : Tcl_GetStringFromObj(cascadeEntryPtr->namePtr, NULL);
    	 
    	    if (strcmp(name, Tk_PathName(menuPtr->tkwin)) == 0) {
    	    	if (cascadeEntryPtr->state == ENTRY_DISABLED) {
    	    	    parentDisabled = 1;
    	    	}
    	    	break;
    	    }
    	}
d3089 3
a3091 2
	if (((parentDisabled || (mePtr->state == ENTRY_DISABLED)))
		&& (menuPtr->disabledFgPtr != NULL)) {
d3101 1
a3101 1
        }
d3103 1
a3103 1
    
d3133 4
a3136 4
    
    DrawMenuEntryBackground(menuPtr, mePtr, d, activeBorder, 
	    bgBorder, x, y, width, height);
    
d3138 1
a3138 1
	DrawMenuSeparator(menuPtr, mePtr, d, gc, tkfont, 
d3144 1
a3144 1
	DrawMenuEntryLabel(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, 
a3151 1
    
d3187 2
a3188 1
    
d3194 1
a3194 1
    	    &borderWidth);
d3196 1
a3196 1
    	    &activeBorderWidth);
d3219 10
a3228 2
    	mePtr = menuPtr->entries[i];
    	if (mePtr->fontPtr == NULL) {
d3231 1
a3231 1
    	} else {
d3233 4
a3236 4
    	    Tk_GetFontMetrics(tkfont, &entryMetrics);
    	    fmPtr = &entryMetrics;
    	}
    	
d3242 6
a3247 6
	    	columnEntryPtr = menuPtr->entries[j];
	    	geometryPtr =
		        (EntryGeometry *) columnEntryPtr->platformEntryData;
	    	
	    	columnEntryPtr->indicatorSpace = maxIndicatorSpace;
		columnEntryPtr->width = maxIndicatorSpace + maxWidth 
d3255 1
a3255 1
		    	    - maxEntryWithAccelWidth;
d3257 1
a3257 1
		    	geometryPtr->nonAccelMargin = maxNonAccelMargin;
d3261 1
a3261 1
		}		
d3271 1
d3275 1
a3275 1
	    	    fmPtr, &entryWidth, &height);
d3278 2
a3279 2
	    GetTearoffEntryGeometry(menuPtr, mePtr, tkfont, 
	    	    fmPtr, &entryWidth, &height);
d3288 1
a3288 1
	     * (if any).  These sizes depend, of course, on the type
d3291 2
a3292 3
	    
	    GetMenuLabelGeometry(mePtr, tkfont, fmPtr, &labelWidth,
	    	    &height);
d3294 2
a3295 1
	
d3297 2
a3298 3
	    	GetMenuAccelGeometry(menuPtr, mePtr, tkfont, fmPtr,
	    		&modifierWidth, &accelWidth, &height);
	    	nonAccelMargin = 0;
d3300 10
a3309 3
	    	nonAccelMargin = mePtr->hideMargin ? 0
		    : Tk_TextWidth(tkfont, "m", 1);
	    	accelWidth = modifierWidth = 0;
d3311 5
a3315 7
	    	labelWidth += Tk_TextWidth(tkfont, "m", 1);
	    	GetMenuAccelGeometry(menuPtr, mePtr, tkfont,
		    	fmPtr, &modifierWidth, &accelWidth, &height);
	        if (height > mePtr->height) {
	    	    mePtr->height = height;
	    	}
	    	nonAccelMargin = 0;
d3319 5
a3323 5
	    	GetMenuIndicatorGeometry(menuPtr, mePtr, tkfont, 
	    	    	fmPtr, &indicatorSpace, &height);
	    	if (height > mePtr->height) {
	    	    mePtr->height = height;
	    	}
d3325 1
a3325 1
	    	indicatorSpace = 0;
d3329 1
a3329 1
	    	maxNonAccelMargin = nonAccelMargin;
d3332 1
a3332 1
	    	maxAccelTextWidth = accelWidth;
d3335 1
a3335 1
	    	maxModifierWidth = modifierWidth;
d3338 1
a3338 1
	    	maxIndicatorSpace = indicatorSpace;
d3345 1
a3345 1
	    	maxWidth = entryWidth;
d3347 1
a3347 1
	    
d3349 3
a3351 3
	    	if (entryWidth > maxEntryWithAccelWidth) {
	    	    maxEntryWithAccelWidth = entryWidth;
	    	}
d3353 3
a3355 3
	    	if (entryWidth > maxEntryWithoutAccelWidth) {
	    	    maxEntryWithoutAccelWidth = entryWidth;
	    	}
a3356 1
	    
d3358 2
a3359 2
    	}
        mePtr->y = y;
d3367 5
a3371 5
    	columnEntryPtr = menuPtr->entries[j];
    	geometryPtr = (EntryGeometry *) columnEntryPtr->platformEntryData;
    	
    	columnEntryPtr->indicatorSpace = maxIndicatorSpace;
	columnEntryPtr->width = maxIndicatorSpace + maxWidth 
a3373 1
	geometryPtr->modifierWidth = maxModifierWidth;
d3378 1
a3378 1
	    	    - maxEntryWithAccelWidth;
d3380 1
a3380 1
	    	geometryPtr->nonAccelMargin = maxNonAccelMargin;
d3384 1
a3384 1
	}		
d3389 1
a3389 1
    
d3422 1
a3422 1
static void
d3424 10
a3433 10
    TkMenu *menuPtr,			/* The menu we are drawing */
    TkMenuEntry *mePtr,			/* The entry we are drawing */
    Drawable d,				/* What we are drawing into */
    GC gc,				/* The gc we are drawing into */
    Tk_Font tkfont,			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr,	/* The precalculated font metrics */
    int x,				/* left edge */
    int y,				/* right edge */
    int width,				/* width of entry */
    int height)				/* height of entry */
d3435 1
a3435 1
    int baseline;
d3438 6
a3443 2
    int imageHeight, imageWidth;
    
d3445 1
a3445 1
     * Draw label or bitmap or image for entry.
a3447 1
    baseline = y + (height + fmPtr->ascent - fmPtr->descent) / 2;
d3449 2
a3450 11
    	Tk_SizeOfImage(mePtr->image, &imageWidth, &imageHeight);
    	if ((mePtr->selectImage != NULL)
	    	&& (mePtr->entryFlags & ENTRY_SELECTED)) {
	    Tk_RedrawImage(mePtr->selectImage, 0, 0,
		    imageWidth, imageHeight, d, leftEdge,
	            (int) (y + (mePtr->height - imageHeight)/2));
    	} else {
	    Tk_RedrawImage(mePtr->image, 0, 0, imageWidth,
		    imageHeight, d, leftEdge,
		    (int) (y + (mePtr->height - imageHeight)/2));
    	}
d3452 69
a3520 50
    	int width, height;
    	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
        Tk_SizeOfBitmap(menuPtr->display,
	        bitmap, &width, &height);
    	XCopyPlane(menuPtr->display, bitmap, d, gc, 0, 0, 
    		(unsigned) width, (unsigned) height, leftEdge,
	    	(int) (y + (mePtr->height - height)/2), 1);
    } else {
    	if (mePtr->labelLength > 0) {
    	    Tcl_DString itemTextDString, convertedTextDString;
            CGrafPtr saveWorld;
            GDHandle saveDevice;
            GWorldPtr destPort;
#ifdef USE_ATSU
            int xLocation;
            int yLocation;
            int runLengths;
            CFStringRef stringRef;
            ATSUTextLayout textLayout;
            UniCharCount runLength;
            ATSUStyle        style;
            int              length;
            int err;
            Str255 fontName;
            SInt16 fontSize;
            Style  fontStyle;
            ATSUAttributeValuePtr valuePtr;
            ByteCount valueSize;
            Fixed fixedSize;
            short iFONDNumber;
            ATSUFontID fontID;
            ATSUAttributeTag tag;
            
            GetThemeFont (kThemeMenuItemFont, smSystemScript, fontName, &fontSize, &fontStyle);
            if ((err = ATSUCreateStyle(&style)) != noErr) {
#ifdef TK_MAC_DEBUG
                fprintf(stderr,"ATSUCreateStyle failed, %d\n", err);
#endif
                return;
            }
            fixedSize = fontSize<<16;
            tag = kATSUSizeTag;
            valueSize = sizeof(fixedSize);
            valuePtr = &fixedSize;
	    err = ATSUSetAttributes(style, 1, &tag, &valueSize, &valuePtr);
            if (err != noErr) {
#ifdef TK_MAC_DEBUG
                fprintf(stderr,"ATSUSetAttributes failed,%d\n", err );
#endif
            }
d3522 3
a3524 11
	    GetFNum(fontName, &iFONDNumber);
            ATSUFONDtoFontID(iFONDNumber, NULL, &fontID);
            tag = kATSUFontTag;
            valueSize = sizeof(fontID);
            valuePtr = &fontID;
	    err = ATSUSetAttributes(style, 1, &tag, &valueSize, &valuePtr);
            if (err != noErr) {
#ifdef TK_MAC_DEBUG
                fprintf(stderr,"ATSUSetAttributes failed,%d\n", err );
#endif
            }
d3526 25
a3550 56
#endif
    	    
    	    GetEntryText(mePtr, &itemTextDString);
#ifdef USE_ATSU
            runLengths = 1;
            length = Tcl_DStringLength(&itemTextDString);
            stringRef = CFStringCreateWithCString(NULL, Tcl_DStringValue(&itemTextDString), 
						  kCFStringEncodingUTF8);
            if (!stringRef) {
#ifdef TK_MAC_DEBUG
                fprintf(stderr,"CFStringCreateWithCString failed\n");
#endif
            }
	    err = ATSUCreateTextLayoutWithTextPtr(CFStringGetCharactersPtr(stringRef), 
                    0, length, length,
		    1, &runLengths, &style, &textLayout)
            if (err != noErr) {
#ifdef TK_MAC_DEBUG
                fprintf(stderr,"ATSUCreateTextLayoutWithTextPtr failed, %d\n", err);
#endif
                return;
            }
#endif
    	    
    	    /* Somehow DrawChars is changing the colors, it is odd, since
    	       it works for the Apple Platinum Appearance, but not for
    	       some Kaleidoscope Themes...  Untill I can figure out what
    	       exactly is going on, this will have to do: */

            destPort = TkMacOSXGetDrawablePort(d);
            GetGWorld(&saveWorld, &saveDevice);
            SetGWorld(destPort, NULL);
            TkMacOSXSetUpGraphicsPort(gc, destPort);

	    MoveTo((short) leftEdge, (short) baseline);
	    Tcl_UtfToExternalDString(TkMacOSXCarbonEncoding, Tcl_DStringValue(&itemTextDString), 
	            Tcl_DStringLength(&itemTextDString), &convertedTextDString);
#ifdef USE_ATSU
            xLocation = leftEdge << 16;
            yLocation = baseline << 16;
            ATSUDrawText(textLayout,kATSUFromTextBeginning, kATSUToTextEnd, xLocation, yLocation);
            ATSUDisposeTextLayout(textLayout);
            CFRelease(stringRef);
#else
	    DrawText(Tcl_DStringValue(&convertedTextDString), 0, 
	            Tcl_DStringLength(&convertedTextDString));
#endif
           
	    /* Tk_DrawChars(menuPtr->display, d, gc,
		    tkfont, Tcl_DStringValue(&itemTextDString), 
		    Tcl_DStringLength(&itemTextDString),
		    leftEdge, baseline); */
		    
	    Tcl_DStringFree(&convertedTextDString);
	    Tcl_DStringFree(&itemTextDString);
    	}
d3555 3
a3557 1
	} else if ((mePtr->image != NULL) 
d3560 3
a3562 3
		    leftEdge,
		    (int) (y + (mePtr->height - imageHeight)/2),
		    (unsigned) imageWidth, (unsigned) imageHeight);
d3573 2
a3574 2
 *      Under Appearance, we only draw the background if the entry's
 *      border is set, we DO NOT inherit it from the menu...
d3586 1
a3586 1
static void
d3588 9
a3596 9
    TkMenu *menuPtr,			/* The menu we are drawing. */
    TkMenuEntry *mePtr,			/* The entry we are drawing. */
    Drawable d,				/* What we are drawing into */
    Tk_3DBorder activeBorder,		/* Border for active items */
    Tk_3DBorder bgBorder,		/* Border for the background */
    int x,				/* left edge */
    int y,				/* top edge */
    int width,				/* width of rectangle to draw */
    int height)				/* height of rectangle to draw */
d3599 4
a3602 4
            || ((mePtr->state == ENTRY_ACTIVE)
		    && (mePtr->activeBorderPtr != None)) 
            || ((mePtr->state != ENTRY_ACTIVE) && (mePtr->borderPtr != None))) {
        if (mePtr->state == ENTRY_ACTIVE) {
d3604 3
a3606 3
        }
        Tk_Fill3DRectangle(menuPtr->tkwin, d, bgBorder,
    	        x, y, width, height, 0, TK_RELIEF_FLAT);
d3627 1
a3627 1
static void
d3629 5
a3633 7
    TkMenuEntry *mePtr,			/* The entry we are computing */
    Tk_Font tkfont,			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr,	/* The precalculated metrics */
    int *widthPtr,			/* The resulting width of the label
					 * portion */
    int *heightPtr)			/* The resulting height of the label
					 * portion */
d3636 73
a3708 20
 
    if (mePtr->image != NULL) {
    	Tk_SizeOfImage(mePtr->image, widthPtr, heightPtr);
    } else if (mePtr->bitmapPtr != NULL) {
    	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
    	Tk_SizeOfBitmap(menuPtr->display, bitmap, widthPtr, heightPtr);
    } else {
    	*heightPtr = fmPtr->linespace;
    	
    	if (mePtr->labelPtr != NULL) {
    	    Tcl_DString itemTextDString;
    	    
    	    GetEntryText(mePtr, &itemTextDString);
    	    *widthPtr = Tk_TextWidth(tkfont, 
    	    	    Tcl_DStringValue(&itemTextDString),
    	    	    Tcl_DStringLength(&itemTextDString));
    	    Tcl_DStringFree(&itemTextDString);
    	} else {
    	    *widthPtr = 0;
    	}
d3710 4
a3713 1
    *heightPtr += 1;
d3719 73
d3806 1
a3806 1
static void
d3811 1
a3811 1
   
d3822 3
a3824 3
    
    XQueryPointer(NULL, None, NULL, NULL,
            &event.x_root, &event.y_root, NULL, NULL, &event.state);
d3833 1
a3833 1
 * RecursivelyClearActiveMenu --
d3835 1
a3835 1
 *	Recursively clears the active entry in the menu's cascade hierarchy.
d3847 2
a3848 2
RecursivelyClearActiveMenu(
    TkMenu *menuPtr)		/* The menu to reset. */
d3850 4
a3853 13
    int i;
    TkMenuEntry *mePtr;
    
    TkActivateMenuEntry(menuPtr, -1);
    MenuSelectEvent(menuPtr);
    for (i = 0; i < menuPtr->numEntries; i++) {
    	mePtr = menuPtr->entries[i];
    	if (mePtr->type == CASCADE_ENTRY) {
    	    if ((mePtr->childMenuRefPtr != NULL)
    	    	    && (mePtr->childMenuRefPtr->menuPtr != NULL)) {
    	    	RecursivelyClearActiveMenu(mePtr->childMenuRefPtr->menuPtr);
    	    }
    	}
d3860 1
a3860 1
 * InvalidateMDEFRgns --
d3862 1
a3862 2
 *	Invalidates the regions covered by menus that did redrawing and
 *	might be damaged.
d3868 1
a3868 1
 *	Generates Mac update events for affected windows.
d3874 2
a3875 1
InvalidateMDEFRgns(void)
d3877 12
a3888 8
    GDHandle saveDevice;
    GWorldPtr saveWorld, destPort;
    Point scratch;
    MacDrawable *macDraw;
    TkMacOSXWindowList *listPtr;
    
    if (totalMenuRgn == NULL) {
    	return;
a3889 19
    
    GetGWorld(&saveWorld, &saveDevice);
    for (listPtr = tkMacOSXWindowListPtr ; listPtr != NULL; 
    	    listPtr = listPtr->nextPtr) {
    	macDraw = (MacDrawable *) Tk_WindowId(listPtr->winPtr);
    	if (macDraw->flags & TK_DRAWN_UNDER_MENU) {
    	    destPort = TkMacOSXGetDrawablePort(Tk_WindowId(listPtr->winPtr));
    	    SetGWorld(destPort, NULL);
    	    scratch.h = scratch.v = 0;
    	    GlobalToLocal(&scratch);
    	    OffsetRgn(totalMenuRgn, scratch.v, scratch.h);
    	    InvalWindowRgn(GetWindowFromPort(destPort),totalMenuRgn);
    	    OffsetRgn(totalMenuRgn, -scratch.v, -scratch.h);
    	    macDraw->flags &= ~TK_DRAWN_UNDER_MENU;
    	}
    }
    
    SetGWorld(saveWorld, saveDevice);
    SetEmptyRgn(totalMenuRgn);
d3912 1
a3912 1
    
d3914 12
a3925 12
    	menuBarRefPtr = TkFindMenuReferences(currentMenuBarInterp,
    		currentMenuBarName);
    	if ((menuBarRefPtr != NULL) && (menuBarRefPtr->menuPtr != NULL)) {
    	    TkMenu *menuPtr;
    	    
    	    for (menuPtr = menuBarRefPtr->menuPtr->masterMenuPtr; menuPtr != NULL;
    	    	    menuPtr = menuPtr->nextInstancePtr) {
    	    	if (menuPtr->menuType == MENUBAR) {
    	    	    RecursivelyClearActiveMenu(menuPtr);
    	    	}
    	    }
    	}
a3926 1
    InvalidateMDEFRgns();
d3949 2
a3950 3
    Tcl_Interp *interp,			/* The interp the menu lives in. */
    char *menuName)			/* The name of the menu to 
					 * reconfigure. */
d3975 4
a3978 1
{        
a3981 1
    tearoffStruct.menuPtr = NULL;
d3988 3
a3990 12
    tkThemeMenuItemDrawingUPP 
            = NewMenuItemDrawingUPP(ThemeMenuItemDrawingProc);
            				
    /* 
     * We should just hardcode the utf-8 ellipsis character into 
     * 'elipsisString' here 
     */
    Tcl_ExternalToUtf(NULL, Tcl_GetEncoding(NULL, "macRoman"), 
		      "\311", /* ellipsis character */
		      -1, 0, NULL, elipsisString,
		      TCL_UTF_MAX + 1, NULL, NULL, NULL);
        
d3992 24
d4024 1
a4024 1
 *      menu state.
d4036 1
a4036 1
TkpMenuThreadInit()
d4060 1
a4060 1
TkMacOSXPreprocessMenu()
d4062 6
a4067 2
    TkMenuReferences *mbRefPtr;
    int code;
d4069 1
a4069 5
    if ((currentMenuBarName != NULL) && (currentMenuBarInterp != NULL)) {
        mbRefPtr = TkFindMenuReferences(currentMenuBarInterp,
		currentMenuBarName);
        if ((mbRefPtr != NULL) && (mbRefPtr->menuPtr != NULL)) {
	    Tcl_Preserve((ClientData)currentMenuBarInterp);
d4077 2
a4078 2
	    Tcl_Release((ClientData)currentMenuBarInterp);
        }
d4082 2
d4103 1
a4103 1
static void
d4105 8
a4112 8
    SInt16 message,	/* What action are we taking? */
    MenuRef menu,	/* The menu we are working with */
    Rect *menuRectPtr,	/* A pointer to the rect for the
    			* whole menu. */
    Point hitPt,	/* Where the mouse was clicked for
    			* the appropriate messages. */
    SInt16 *whichItem)	/* Output result. Which item was
			 * hit by the user? */
a4115 1
    int maxMenuHeight;
d4117 1
a4117 2
    BitMap screenBits;
    
d4119 2
a4120 2
    commandEntryPtr = Tcl_FindHashEntry(&commandTable, (char *) ((int)menuID));
    
d4122 1
a4122 1
        menuPtr = (TkMenu *) Tcl_GetHashValue(commandEntryPtr);
d4124 1
a4124 1
        menuPtr = NULL;
d4128 43
a4170 40
        case kMenuInitMsg:
            *whichItem = noErr;
            break;
        case kMenuDisposeMsg:
            break;
        case kMenuHiliteItemMsg: {
            HandleMenuHiliteMsg (menu, menuRectPtr, hitPt, whichItem, menuPtr);
            break;
        }
        case kMenuCalcItemMsg:
            HandleMenuCalcItemMsg (menu, menuRectPtr, hitPt, whichItem, menuPtr);
            break;
        case kMenuDrawItemsMsg: {
            /*
             * We do nothing  here, because we don't support the Menu Managers
             * dynamic item groups
             */
             
            break;
        }
        case kMenuThemeSavvyMsg:
            *whichItem = kThemeSavvyMenuResponse;
            break;
    	case kMenuSizeMsg:
            GetQDGlobalsScreenBits(&screenBits);
    	    maxMenuHeight = screenBits.bounds.bottom
    	    	    - screenBits.bounds.top
    	    	    - GetMBarHeight() - SCREEN_MARGIN;
    	    SetMenuWidth(menu, menuPtr->totalWidth );
    	    SetMenuHeight(menu,maxMenuHeight < menuPtr->totalHeight ? maxMenuHeight : menuPtr->totalHeight );
       	    break;
    	case kMenuDrawMsg:
            HandleMenuDrawMsg (menu, menuRectPtr, hitPt, whichItem, menuPtr);
            break;
    	case kMenuFindItemMsg:
            HandleMenuFindItemsMsg (menu, menuRectPtr, hitPt, whichItem, menuPtr);
            break;
    	case kMenuPopUpMsg:
            HandleMenuPopUpMsg (menu, menuRectPtr, hitPt, whichItem, menuPtr);
    	    break;
d4173 16
d4191 6
a4196 5
HandleMenuHiliteMsg (MenuRef menu, 
        Rect *menuRectPtr, 
        Point hitPt, 
        SInt16 *whichItem,
        TkMenu *menuPtr)
d4198 1
a4198 1
    TkMenuEntry *mePtr = NULL;
d4201 8
a4208 12
    int oldItem;
    int newItem = -1;
    MDEFHiliteItemData * hidPtr = ( MDEFHiliteItemData *)whichItem;
    MenuTrackingData   mtd, *mtdPtr = &mtd;
    int err;
    oldItem = hidPtr->previousItem - 1;
    newItem = hidPtr->newItem - 1;
    
    err = GetMenuTrackingData(menu, mtdPtr);
    if (err !=noErr) {
#ifdef TK_MAC_DEBUG
        fprintf(stderr,"GetMenuTrackingData failed : %d\n", err );
d4210 6
a4215 1
        return;
d4217 3
a4219 1
    
d4221 6
a4226 61
        Rect oldItemRect;
        int width;
        
        mePtr = menuPtr->entries[oldItem];
        if (mePtr->fontPtr == NULL) {
                tkfont = Tk_GetFontFromObj(menuPtr->tkwin, 
                        menuPtr->fontPtr);
        } else {
                tkfont = Tk_GetFontFromObj(menuPtr->tkwin,
                        mePtr->fontPtr);
        }
        Tk_GetFontMetrics(tkfont, &fontMetrics);
        
        width = (mePtr->entryFlags & ENTRY_LAST_COLUMN)
                ? menuPtr->totalWidth - mePtr->x : mePtr->width;
                
        /*
            * In Aqua, have to call EraseMenuBackground when you overdraw
            * a previously selected menu item, otherwise you will see the 
            * old select highlight under the transparency of the new menu item.
            */
            
        oldItemRect.left = menuRectPtr->left + mePtr->x;
        oldItemRect.right = oldItemRect.left +width; 
        oldItemRect.top = mtdPtr->virtualMenuTop + mePtr->y;
        oldItemRect.bottom = oldItemRect.top + mePtr->height;
        
        EraseMenuBackground(menu, & oldItemRect, NULL);
        
        AppearanceEntryDrawWrapper(mePtr, menuRectPtr, mtdPtr,
                (Drawable) &macMDEFDrawable, &fontMetrics, tkfont, 
                oldItemRect.left,
                oldItemRect.top,
                width,
                mePtr->height);
    }
    if (newItem != -1) {        
        mePtr = menuPtr->entries[newItem];
        if (mePtr->state != ENTRY_DISABLED) {
            TkActivateMenuEntry(menuPtr, newItem);
        }
        if (mePtr->fontPtr == NULL) {  
            tkfont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
        } else {
            tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
        }
        Tk_GetFontMetrics(tkfont, &fontMetrics);
        AppearanceEntryDrawWrapper(mePtr, menuRectPtr, mtdPtr,
            (Drawable) &macMDEFDrawable, &fontMetrics, tkfont,
            menuRectPtr->left + mePtr->x,
            mtdPtr->virtualMenuTop + mePtr->y,
            (mePtr->entryFlags & ENTRY_LAST_COLUMN) ?
            menuPtr->totalWidth - mePtr->x : mePtr->width,
            mePtr->height);
    }
    tkUseMenuCascadeRgn = 1;
    MenuSelectEvent(menuPtr);
    Tcl_ServiceAll();
    tkUseMenuCascadeRgn = 0;
    if (newItem!=-1 && mePtr->state != ENTRY_DISABLED) {
        TkActivateMenuEntry(menuPtr, -1);
a4227 1

d4229 1
a4229 1

d4233 1
a4233 1
 *   HandleMenuDrawMsg --
d4235 1
a4235 1
 *      It handles the MenuDefProc's draw message.
d4245 1
d4247 6
a4252 5
HandleMenuDrawMsg(MenuRef menu, 
        Rect *menuRectPtr, 
        Point hitPt, 
        SInt16 *whichItem,
        TkMenu *menuPtr)
d4254 2
a4255 3
    Tk_Font tkfont, menuFont;
    Tk_FontMetrics fontMetrics, entryMetrics;
    Tk_FontMetrics *fmPtr;
d4258 19
a4276 48
    GDHandle device;
    TkMenu *searchMenuPtr;
    Rect menuClipRect;
    ThemeMenuType menuType;
    MenuTrackingData * mtdPtr = (MenuTrackingData *)whichItem;
    /*
        * Store away the menu rectangle so we can keep track of the
        * different regions that the menu obscures.
        */
    
    ((MacMenu *) menuPtr->platformData)->menuRect = *menuRectPtr;
    if (tkMenuCascadeRgn == NULL) {
        tkMenuCascadeRgn = NewRgn();
    }
    if (utilRgn == NULL) {
        utilRgn = NewRgn();
    }
    if (totalMenuRgn == NULL) {
        totalMenuRgn = NewRgn();
    }
    SetEmptyRgn(tkMenuCascadeRgn);
    for (searchMenuPtr = menuPtr; searchMenuPtr != NULL; ) {
        RectRgn(utilRgn, 
                &((MacMenu *) searchMenuPtr->platformData)->menuRect);
        InsetRgn(utilRgn, -1, -1);
        UnionRgn(tkMenuCascadeRgn, utilRgn, tkMenuCascadeRgn);
        OffsetRgn(utilRgn, 1, 1);
        UnionRgn(tkMenuCascadeRgn, utilRgn, tkMenuCascadeRgn);
        
        if (searchMenuPtr->menuRefPtr->parentEntryPtr != NULL) {
            searchMenuPtr = searchMenuPtr->menuRefPtr
                    ->parentEntryPtr->menuPtr;
        } else {
            break;
        }
        if (searchMenuPtr->menuType == MENUBAR) {
            break;
        }
    }
    UnionRgn(totalMenuRgn, tkMenuCascadeRgn, totalMenuRgn);
    SetEmptyRgn(utilRgn);
    
    /*
        * Now draw the background if Appearance is present...
        */
        
    GetGWorld(&macMDEFDrawable.grafPtr, &device);
        
d4278 1
a4278 1
        menuType = kThemeMenuTypePullDown;
d4280 1
a4280 1
        menuType = kThemeMenuTypeHierarchical;
d4282 1
a4282 1
        menuType = kThemeMenuTypePopUp;
d4284 7
a4290 3
            
    DrawMenuBackground(menuRectPtr, (Drawable) &macMDEFDrawable, menuType);
    
d4292 46
a4337 24
        * Next, figure out scrolling information.
        */
    
    menuClipRect = *menuRectPtr;
    if ((menuClipRect.bottom - menuClipRect.top) 
            < menuPtr->totalHeight) {
        if (mtdPtr->virtualMenuTop < menuRectPtr->top) {
            DrawSICN(SICN_RESOURCE_NUMBER, UP_ARROW, 
                (Drawable) &macMDEFDrawable,
                menuPtr->textGC, 
                menuRectPtr->left + menuPtr->entries[1]->indicatorSpace,
                menuRectPtr->top);
            menuClipRect.top += SICN_HEIGHT;
        }
        if ((mtdPtr->virtualMenuTop + menuPtr->totalHeight)
                > menuRectPtr->bottom) {
            DrawSICN(SICN_RESOURCE_NUMBER, DOWN_ARROW,
                (Drawable) &macMDEFDrawable,
                menuPtr->textGC, 
                menuRectPtr->left + menuPtr->entries[1]->indicatorSpace,
                menuRectPtr->bottom - SICN_HEIGHT);
            menuClipRect.bottom -= SICN_HEIGHT;
        }
        GetClip(utilRgn);
d4339 1
a4339 1
    
d4341 5
a4345 7
        * Now, actually draw the menu. Don't draw entries that
        * are higher than the top arrow, and don't draw entries
        * that are lower than the bottom.
        */
    
    menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
    Tk_GetFontMetrics(menuFont, &fontMetrics);    	    
d4347 8
a4354 30
        mePtr = menuPtr->entries[i];
        if (mtdPtr->virtualMenuTop + mePtr->y + mePtr->height
                < menuClipRect.top) {
            continue;
        } else if (mtdPtr->virtualMenuTop + mePtr->y
                > menuClipRect.bottom) {
            continue;
        }
        ClipRect(&menuClipRect);
        if (mePtr->fontPtr == NULL) {
            fmPtr = &fontMetrics;
            tkfont = menuFont;
        } else {
            tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
            Tk_GetFontMetrics(tkfont, &entryMetrics);
            fmPtr = &entryMetrics;
        }
        AppearanceEntryDrawWrapper(mePtr, menuRectPtr, mtdPtr,
            (Drawable) &macMDEFDrawable, fmPtr, tkfont, 
            menuRectPtr->left + mePtr->x,
            mtdPtr->virtualMenuTop + mePtr->y,
            (mePtr->entryFlags & ENTRY_LAST_COLUMN) ?
                menuPtr->totalWidth - mePtr->x : mePtr->width,
            menuPtr->entries[i]->height);
    }
    mtdPtr->virtualMenuBottom = mtdPtr->virtualMenuTop 
            + menuPtr->totalHeight;
    if (!EmptyRgn(utilRgn)) {
        SetClip(utilRgn);
        SetEmptyRgn(utilRgn);
d4358 1
a4358 1

d4362 1
a4362 1
 *   HandleMenuFindItemsMsg --
d4364 4
a4367 4
 *      It handles the MenuDefProc's FindItems message.  We have to
 *      respond by filling in the itemSelected, itemUnderMouse and
 *      itemRect fields.  This is also the time to scroll the menu if
 *      it is too long to fit on the screen.
d4371 1
a4371 1
 *      under the mouse.
d4379 6
a4384 5
HandleMenuFindItemsMsg (MenuRef menu, 
        Rect *menuRectPtr, 
        Point hitPt, 
        SInt16 *whichItem,
        TkMenu *menuPtr)
d4386 2
a4387 6
    TkMenuEntry *parentEntryPtr;
#if 0 /* Unused */ 
    Tk_Font tkfont;
    Tk_FontMetrics fontMetrics, entryMetrics;
    Tk_FontMetrics *fmPtr;
#endif
d4389 2
a4390 16
    int i;
    int newItem = -1;
    GDHandle device;
    Rect itemRect;
    short windowPart;
    WindowRef whichWindow;
    RGBColor bgColor;
    RGBColor fgColor;
    RGBColor origFgColor;
    PenState origPenState;
    Rect dragRect;
    Rect scratchRect = {-32768, -32768, 32767, 32767};
    RgnHandle oldClipRgn;
    TkMenuReferences *menuRefPtr;
    Rect menuClipRect;

d4392 2
a4393 2
    MenuTrackingData * mtdPtr = (MenuTrackingData *)whichItem;
    int                itemUnderMouse = -1;
d4395 1
a4395 1
        DONT_SCROLL, DOWN_SCROLL, UP_SCROLL
d4397 1
a4397 8
    Rect updateRect;
    short scrollAmt = 0;
    RGBColor origForeColor, origBackColor;
    
    /*
     * Find out which item was hit. If it is the same as the old item,
     * we don't need to do anything.
     */
d4399 5
a4403 52
    if (PtInRect(hitPt, menuRectPtr)) {
        for (i = 0; i < menuPtr->numEntries; i++) {
            mePtr = menuPtr->entries[i];
            itemRect.left = menuRectPtr->left + mePtr->x;
            itemRect.top = mtdPtr->virtualMenuTop + mePtr->y;
            if (mePtr->entryFlags & ENTRY_LAST_COLUMN) {
                itemRect.right = itemRect.left + menuPtr->totalWidth
                        - mePtr->x;
            } else {
                itemRect.right = itemRect.left + mePtr->width;
            }
            itemRect.bottom = itemRect.top
                    + mePtr->height;
            if (PtInRect(hitPt, &itemRect)) {
                if ((mePtr->type == SEPARATOR_ENTRY)
                        || (mePtr->state == ENTRY_DISABLED)) {
                    newItem = -1;
                    itemUnderMouse = i;
                } else {
                    TkMenuEntry *cascadeEntryPtr;
                    int parentDisabled = 0;
                    
                    for (cascadeEntryPtr
                            = menuPtr->menuRefPtr->parentEntryPtr;
                            cascadeEntryPtr != NULL;
                            cascadeEntryPtr 
                            = cascadeEntryPtr->nextCascadePtr) {
                        char *name;
                        
                        name = Tcl_GetStringFromObj(
                                cascadeEntryPtr->namePtr, NULL);
                        if (strcmp(name, Tk_PathName(menuPtr->tkwin)) 
                                == 0) {
                            if (cascadeEntryPtr->state == ENTRY_DISABLED) {
                                parentDisabled = 1;
                            }
                            break;
                        }
                    }
                    
                    if (parentDisabled) {
                        newItem = -1;
                        itemUnderMouse = i;
                    } else {         	    
                        newItem = i;
                        itemUnderMouse = i;
                    }
                }
                break;
            }
        }
    } else {
d4405 5
d4414 5
a4418 1
    
a4421 9
    if (hasTopScroll && (hitPt.v < menuRectPtr->top + SICN_HEIGHT)) {
        newItem = -1;
        scrollDirection = DOWN_SCROLL;
    } else if (hasBottomScroll && (hitPt.v > (menuRectPtr->bottom - SICN_HEIGHT))) {
        newItem = -1;
        scrollDirection = UP_SCROLL;
    }
    
    menuClipRect = *menuRectPtr;
d4423 5
a4427 1
        menuClipRect.top += SICN_HEIGHT;
d4430 5
a4434 1
        menuClipRect.bottom -= SICN_HEIGHT;
d4437 2
a4438 2
        scrollDirection = DONT_SCROLL;
        MDEFScrollFlag = 0;
d4440 12
a4451 2
    GetClip(utilRgn);
    ClipRect(&menuClipRect);
d4453 135
a4590 183
    
    GetGWorld(&macMDEFDrawable.grafPtr, &device);
    GetForeColor(&origForeColor);
    GetBackColor(&origBackColor);

    if (scrollDirection == UP_SCROLL) {
        scrollAmt = menuClipRect.bottom - hitPt.v;
        if (scrollAmt < menuRectPtr->bottom 
                - mtdPtr->virtualMenuBottom) {
            scrollAmt = menuRectPtr->bottom - mtdPtr->virtualMenuBottom;
        }
        if (!hasTopScroll && ((mtdPtr->virtualMenuTop + scrollAmt)
                < menuRectPtr->top)) {
            SetRect(&updateRect, menuRectPtr->left,
                    mtdPtr->virtualMenuTop, menuRectPtr->right,
                    mtdPtr->virtualMenuTop + SICN_HEIGHT);
            EraseRect(&updateRect);
            DrawSICN(SICN_RESOURCE_NUMBER, UP_ARROW,
                    (Drawable) &macMDEFDrawable,
                    menuPtr->textGC, menuRectPtr->left
                    + menuPtr->entries[1]->indicatorSpace,
                    menuRectPtr->top);
            menuClipRect.top += SICN_HEIGHT;
        }
    } else if (scrollDirection == DOWN_SCROLL) {

        scrollAmt = menuClipRect.top - hitPt.v;
        if (scrollAmt > menuRectPtr->top - mtdPtr->virtualMenuTop) {
            scrollAmt = menuRectPtr->top - mtdPtr->virtualMenuTop;
        }

        if (!hasBottomScroll && ((mtdPtr->virtualMenuBottom + scrollAmt)
                > menuRectPtr->bottom)) {
            SetRect(&updateRect, menuRectPtr->left, 
                    mtdPtr->virtualMenuBottom - SICN_HEIGHT,
                    menuRectPtr->right, mtdPtr->virtualMenuBottom);
            EraseRect(&updateRect);
            DrawSICN(SICN_RESOURCE_NUMBER, DOWN_ARROW,
                    (Drawable) &macMDEFDrawable,
                    menuPtr->textGC, menuRectPtr->left
                    + menuPtr->entries[1]->indicatorSpace,
                    menuRectPtr->bottom - SICN_HEIGHT);
            menuClipRect.bottom -= SICN_HEIGHT;
        }
    }
    
    if (scrollDirection != DONT_SCROLL) {
#if 0
        Tk_Font menuFont;
        RgnHandle updateRgn = NewRgn();
#endif
        
        ScrollMenuImage(menu, menuRectPtr, 0, scrollAmt, NULL);
        mtdPtr->virtualMenuTop += scrollAmt;
        mtdPtr->virtualMenuBottom += scrollAmt;
#if 0
        GetRegionBounds(updateRgn,&updateRect);
        DisposeRgn(updateRgn);
        if (mtdPtr->virtualMenuTop == menuRectPtr->top) {
            updateRect.top -= SICN_HEIGHT;
        }
        if (mtdPtr->virtualMenuBottom == menuRectPtr->bottom) {
            updateRect.bottom += SICN_HEIGHT;
        }
        ClipRect(&updateRect);
        EraseRect(&updateRect);
        menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
        Tk_GetFontMetrics(menuFont, &fontMetrics);    	    
        for (i = 0; i < menuPtr->numEntries; i++) {
            mePtr = menuPtr->entries[i];
            if (mtdPtr->virtualMenuTop + mePtr->y + mePtr->height
                    < updateRect.top) {
                continue;
            } else if (mtdPtr->virtualMenuTop + mePtr->y
                    > updateRect.bottom) {
                continue;
            }
            if (mePtr->fontPtr == NULL) {
                fmPtr = &fontMetrics;
                tkfont = menuFont;
            } else {
                tkfont = Tk_GetFontFromObj(menuPtr->tkwin,
                        mePtr->fontPtr);
                Tk_GetFontMetrics(tkfont, &entryMetrics);
                fmPtr = &entryMetrics;
            }
            AppearanceEntryDrawWrapper(mePtr, menuRectPtr, mtdPtr,
                (Drawable) &macMDEFDrawable, fmPtr, tkfont, 
                menuRectPtr->left + mePtr->x,
                mtdPtr->virtualMenuTop + mePtr->y,
                (mePtr->entryFlags & ENTRY_LAST_COLUMN) ?
                    menuPtr->totalWidth - mePtr->x : mePtr->width,
                menuPtr->entries[i]->height);
        }	    	
#endif
    }

    SetClip(utilRgn);
    SetEmptyRgn(utilRgn);
    RGBForeColor(&origForeColor);
    RGBBackColor(&origBackColor);

    /*
        * If the menu is a tearoff, and the mouse is outside the menu,
        * we need to draw the drag rectangle.
        *
        * In order for tearoffs to work properly, we need to set
        * the active member of the containing menubar.
        */
    
    menuRefPtr = TkFindMenuReferences(menuPtr->interp,
            Tk_PathName(menuPtr->tkwin));
            
    if ((menuRefPtr != NULL) && (menuRefPtr->parentEntryPtr != NULL)) {
        char *name;
        for (parentEntryPtr = menuRefPtr->parentEntryPtr;
                parentEntryPtr != NULL
                ; parentEntryPtr = parentEntryPtr->nextCascadePtr) {
            name = Tcl_GetStringFromObj(parentEntryPtr->namePtr,
                    NULL);
            if (strcmp(name, Tk_PathName(menuPtr->tkwin)) != 0) {
                break;
            }
        }
        if (parentEntryPtr != NULL) {
            TkActivateMenuEntry(parentEntryPtr->menuPtr,
                    parentEntryPtr->index);
        }
    }
    
    if (menuPtr->tearoff) {
        scratchRect = *menuRectPtr;
        if (tearoffStruct.menuPtr == NULL) {
            scratchRect.top -= 10;
            scratchRect.bottom += 10;
            scratchRect.left -= 10;
            scratchRect.right += 10;
        }

        windowPart = FindWindow(hitPt, &whichWindow);
        if ((windowPart != inMenuBar) && (newItem == -1)
                && (hitPt.v != 0) && (hitPt.h != 0)
                && (!PtInRect(hitPt, &scratchRect))
                && (!PtInRect(hitPt, &tearoffStruct.excludeRect))) {
            unsigned long dummy;
            oldClipRgn = NewRgn();
            GetClip(oldClipRgn);
            GetForeColor(&origFgColor);
            GetPenState(&origPenState);
            GetForeColor(&fgColor);
            GetBackColor(&bgColor);
            GetGray(device, &bgColor, &fgColor);
            RGBForeColor(&fgColor);
            SetRect(&scratchRect, -32768, -32768, 32767, 32767);
            ClipRect(&scratchRect);
            
            dragRect = *menuRectPtr;
            tearoffStruct.menuPtr = menuPtr;

            PenMode(srcXor);
            dragRect = *menuRectPtr;
            OffsetRect(&dragRect, -dragRect.left, -dragRect.top);
            OffsetRect(&dragRect, tearoffStruct.point.h,
                tearoffStruct.point.v);
            if ((dragRect.top != 0) && (dragRect.left != 0)) {
                FrameRect(&dragRect);
                Delay(1, &dummy);
                FrameRect(&dragRect);
            }
            tearoffStruct.point = hitPt;

            SetClip(oldClipRgn);
            DisposeRgn(oldClipRgn);
            RGBForeColor(&origFgColor);
            SetPenState(&origPenState);    
        } else {
            tearoffStruct.menuPtr = NULL;
            tearoffStruct.point.h = tearoffStruct.point.v = 0;
        }
    } else {
        tearoffStruct.menuPtr = NULL;
        tearoffStruct.point.h = tearoffStruct.point.v = 0;
    }	    
d4592 1
a4592 1

d4596 1
a4596 1
 *   HandleMenuPopUpMsg --
d4598 1
a4598 1
 *      It handles the MenuDefProc's PopUp message.  The menu is
d4610 6
a4615 5
HandleMenuPopUpMsg (MenuRef menu, 
        Rect *menuRectPtr, 
        Point hitPt, 
        SInt16 *whichItem,
        TkMenu *menuPtr)
d4621 10
d4633 3
a4635 4
        * Note that for some oddball reason, h and v are reversed in the
        * point given to us by the MDEF.
        */
    GetQDGlobalsScreenBits(&screenBits);
d4639 1
a4639 1
        oldItem = -1;
d4643 2
a4644 3
    maxMenuHeight = screenBits.bounds.bottom
            - screenBits.bounds.top
            - GetMBarHeight() - SCREEN_MARGIN;
d4646 1
a4646 1
        menuRectPtr->top = GetMBarHeight();
d4648 24
a4671 24
        int delta;
        menuRectPtr->top = hitPt.h;
        if (oldItem >= 0) {
            menuRectPtr->top -= menuPtr->entries[oldItem]->y;
        }
        
        if (menuRectPtr->top < GetMBarHeight()) {
            /* Displace downward if the menu would stick off the
                * top of the screen.
                */
                
            menuRectPtr->top = GetMBarHeight() + SCREEN_MARGIN;
        } else {
            /*
                * Or upward if the menu sticks off the 
                * bottom end...
                */
                
            delta = menuRectPtr->top + menuPtr->totalHeight 
                    - maxMenuHeight;
            if (delta > 0) {
                menuRectPtr->top -= delta;
            }
        }
d4675 5
a4679 5
    menuRectPtr->bottom = menuRectPtr->top + 
            ((maxMenuHeight < menuPtr->totalHeight) 
            ? maxMenuHeight : menuPtr->totalHeight);
    if (menuRectPtr->top == GetMBarHeight()) {
        *whichItem = hitPt.h;
d4681 1
a4681 1
        *whichItem = menuRectPtr->top;
d4684 1
a4684 1

d4688 1
a4688 1
 *   HandleMenuCalcItemMsg --
d4690 4
a4693 4
 *      It handles the MenuDefProc's CalcItem message.  It is supposed
 *      to calculate the Rect of the menu entry in whichItem in the
 *      menu, and put that in menuRectPtr.  I assume this works, but I
 *      have never seen the MenuManager send this message.
d4696 1
a4696 1
 *	The Menu Manager is informed of the bounding rect of a 
d4704 1
d4706 6
a4711 5
HandleMenuCalcItemMsg(MenuRef menu, 
        Rect *menuRectPtr, 
        Point hitPt, 
        SInt16 *whichItem,
        TkMenu *menuPtr)
d4714 5
a4718 4
    MenuTrackingData   mtd, *mtdPtr = &mtd;
    int err, virtualTop;
    
    err = GetMenuTrackingData(menu, mtdPtr);
d4720 1
a4720 1
        virtualTop = mtdPtr->virtualMenuTop;
d4722 1
a4722 1
        virtualTop = 0;
d4724 11
a4734 8
    
    mePtr = menuPtr->entries[*whichItem];
    menuRectPtr->left = mePtr->x;
    menuRectPtr->top = mePtr->y - virtualTop;
    if (mePtr->entryFlags & ENTRY_LAST_COLUMN) {
        menuRectPtr->right = menuPtr->totalWidth;
    } else {
        menuRectPtr->right = mePtr->x + mePtr->width;
d4736 4
a4739 2
    menuRectPtr->bottom = menuRectPtr->top
            + mePtr->height;
d4741 1
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXMenu.c,v 1.33 2006/09/11 14:41:04 das Exp $
d1741 1
d1747 6
a1752 1
    		macMenuHdl = NewMenu(appleID, "\p\024");
@

