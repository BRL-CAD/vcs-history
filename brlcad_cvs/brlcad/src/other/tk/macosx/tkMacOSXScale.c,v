head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.46;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXScale.c --
 *
 *	This file implements the Macintosh specific portion of the
 *	scale widget.
 *
 * Copyright (c) 1996 by Sun Microsystems, Inc.
 * Copyright (c) 1998-2000 by Scriptics Corporation.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXScale.c,v 1.14 2007/06/29 03:20:02 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkScale.h"

/*
#ifdef TK_MAC_DEBUG
#define TK_MAC_DEBUG_SCALE
#endif
*/

/*
 * Defines used in this file.
 */

#define slider		1110
#define inSlider	1
#define inInc		2
#define inDecr		3

/*
 * Declaration of Macintosh specific scale structure.
 */

typedef struct MacScale {
    TkScale info;		/* Generic scale info. */
    int flags;			/* Flags. */
    ControlRef scaleHandle;	/* Handle to the Scale control struct. */
} MacScale;

/*
 * Globals uses locally in this file.
 */
static ControlActionUPP scaleActionProc = NULL; /* Pointer to func. */

/*
 * Forward declarations for procedures defined later in this file:
 */

static void MacScaleEventProc(ClientData clientData, XEvent *eventPtr);
static pascal void ScaleActionProc(ControlRef theControl,
	ControlPartCode partCode);


/*
 *----------------------------------------------------------------------
 *
 * TkpCreateScale --
 *
 *	Allocate a new TkScale structure.
 *
 * Results:
 *	Returns a newly allocated TkScale structure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TkScale *
TkpCreateScale(
    Tk_Window tkwin)
{
    MacScale *macScalePtr = (MacScale *) ckalloc(sizeof(MacScale));

    macScalePtr->scaleHandle = NULL;
    if (scaleActionProc == NULL) {
	scaleActionProc = NewControlActionUPP(ScaleActionProc);
    }

    Tk_CreateEventHandler(tkwin, ButtonPressMask,
	    MacScaleEventProc, (ClientData) macScalePtr);

    return (TkScale *) macScalePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDestroyScale --
 *
 *	Free Macintosh specific resources.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	The slider control is destroyed.
 *
 *----------------------------------------------------------------------
 */

void
TkpDestroyScale(
    TkScale *scalePtr)
{
    MacScale *macScalePtr = (MacScale *) scalePtr;

    /*
     * Free Macintosh control.
     */

    if (macScalePtr->scaleHandle != NULL) {
	DisposeControl(macScalePtr->scaleHandle);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDisplayScale --
 *
 *	This procedure is invoked as an idle handler to redisplay
 *	the contents of a scale widget.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The scale gets redisplayed.
 *
 *----------------------------------------------------------------------
 */

void
TkpDisplayScale(
    ClientData clientData)	/* Widget record for scale. */
{
    TkScale *scalePtr = (TkScale *) clientData;
    Tk_Window tkwin = scalePtr->tkwin;
    Tcl_Interp *interp = scalePtr->interp;
    int result;
    char string[PRINT_CHARS];
    MacScale *macScalePtr = (MacScale *) clientData;
    Rect r;
    WindowRef windowRef;
    CGrafPtr destPort, savePort;
    Boolean portChanged;
    MacDrawable *macDraw;
    SInt32 initialValue, minValue, maxValue;
    UInt16 numTicks;

#ifdef TK_MAC_DEBUG_SCALE
    TkMacOSXDbgMsg("TkpDisplayScale");
#endif
    scalePtr->flags &= ~REDRAW_PENDING;
    if ((scalePtr->tkwin == NULL) || !Tk_IsMapped(scalePtr->tkwin)) {
	goto done;
    }

    /*
     * Invoke the scale's command if needed.
     */

    Tcl_Preserve((ClientData) scalePtr);
    if ((scalePtr->flags & INVOKE_COMMAND) && (scalePtr->command != NULL)) {
	Tcl_Preserve((ClientData) interp);
	sprintf(string, scalePtr->format, scalePtr->value);
	result = Tcl_VarEval(interp, scalePtr->command, " ", string, NULL);
	if (result != TCL_OK) {
	    Tcl_AddErrorInfo(interp, "\n    (command executed by scale)");
	    Tcl_BackgroundError(interp);
	}
	Tcl_Release((ClientData) interp);
    }
    scalePtr->flags &= ~INVOKE_COMMAND;
    if (scalePtr->flags & SCALE_DELETED) {
	Tcl_Release((ClientData) scalePtr);
	return;
    }
    Tcl_Release((ClientData) scalePtr);

    /*
     * Now handle the part of redisplay that is the same for
     * horizontal and vertical scales: border and traversal
     * highlight.
     */

    if (scalePtr->highlightWidth != 0) {
	GC gc = Tk_GCForColor(scalePtr->highlightColorPtr, Tk_WindowId(tkwin));

	Tk_DrawFocusHighlight(tkwin, gc, scalePtr->highlightWidth,
		Tk_WindowId(tkwin));
    }
    Tk_Draw3DRectangle(tkwin, Tk_WindowId(tkwin), scalePtr->bgBorder,
	    scalePtr->highlightWidth, scalePtr->highlightWidth,
	    Tk_Width(tkwin) - 2*scalePtr->highlightWidth,
	    Tk_Height(tkwin) - 2*scalePtr->highlightWidth,
	    scalePtr->borderWidth, scalePtr->relief);

    /*
     * Set up port for drawing Macintosh control.
     */

    macDraw = (MacDrawable *) Tk_WindowId(tkwin);
    destPort = TkMacOSXGetDrawablePort(Tk_WindowId(tkwin));
    windowRef = TkMacOSXDrawableWindow(Tk_WindowId(tkwin));
    portChanged = QDSwapPort(destPort, &savePort);
    TkMacOSXSetUpClippingRgn(Tk_WindowId(tkwin));

    /*
     * Create Macintosh control.
     */

#define MAC_OSX_SCROLL_WIDTH 10

    if (scalePtr->orient == ORIENT_HORIZONTAL) {
	int offset = (Tk_Height(tkwin) - MAC_OSX_SCROLL_WIDTH)/2;

	if (offset < 0) {
	    offset = 0;
	}

	r.left = macDraw->xOff + scalePtr->inset;
	r.top = macDraw->yOff + offset;
	r.right = macDraw->xOff+Tk_Width(tkwin) - scalePtr->inset;
	r.bottom = macDraw->yOff + offset + MAC_OSX_SCROLL_WIDTH/2;
    } else {
	int offset = (Tk_Width(tkwin) - MAC_OSX_SCROLL_WIDTH)/2;

	if (offset < 0) {
	    offset = 0;
	}

	r.left = macDraw->xOff + offset;
	r.top = macDraw->yOff + scalePtr->inset;
	r.right = macDraw->xOff + offset + MAC_OSX_SCROLL_WIDTH/2;
	r.bottom = macDraw->yOff+Tk_Height(tkwin) - scalePtr->inset;
    }

    if (macScalePtr->scaleHandle == NULL) {
#ifdef TK_MAC_DEBUG_SCALE
	TkMacOSXDbgMsg("Initialising scale");
#endif
	initialValue = scalePtr->value;
	if (scalePtr->orient == ORIENT_HORIZONTAL) {
	    minValue = scalePtr->fromValue;
	    maxValue = scalePtr->toValue;
	} else {
	    minValue = scalePtr->fromValue;
	    maxValue = scalePtr->toValue;
	}

	if (scalePtr->tickInterval == 0) {
	    numTicks = 0;
	} else {
	    numTicks = (maxValue - minValue)/scalePtr->tickInterval;
	}

	CreateSliderControl(windowRef, &r, initialValue, minValue, maxValue,
		kControlSliderPointsDownOrRight, numTicks, 1, scaleActionProc,
		&(macScalePtr->scaleHandle));
	SetControlReference(macScalePtr->scaleHandle, (UInt32) scalePtr);

	if (IsWindowActive(windowRef)) {
	    macScalePtr->flags |= ACTIVE;
	}
    } else {
	SetControlBounds(macScalePtr->scaleHandle, &r);
	SetControl32BitValue(macScalePtr->scaleHandle, scalePtr->value);
	SetControl32BitMinimum(macScalePtr->scaleHandle, scalePtr->fromValue);
	SetControl32BitMaximum(macScalePtr->scaleHandle, scalePtr->toValue);
    }

    /*
     * Finally draw the control.
     */

    SetControlVisibility(macScalePtr->scaleHandle,true,true);
    HiliteControl(macScalePtr->scaleHandle,0);
    Draw1Control(macScalePtr->scaleHandle);

    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
done:
    scalePtr->flags &= ~REDRAW_ALL;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpScaleElement --
 *
 *	Determine which part of a scale widget lies under a given
 *	point.
 *
 * Results:
 *	The return value is either TROUGH1, SLIDER, TROUGH2, or
 *	OTHER, depending on which of the scale's active elements
 *	(if any) is under the point at (x,y).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkpScaleElement(
    TkScale *scalePtr,		/* Widget record for scale. */
    int x, int y)		/* Coordinates within scalePtr's window. */
{
    MacScale *macScalePtr = (MacScale *) scalePtr;
    ControlPartCode part;
    Point where;
    Rect bounds;
    CGrafPtr destPort, savePort;
    Boolean portChanged;

#ifdef TK_MAC_DEBUG_SCALE
    TkMacOSXDbgMsg("TkpScaleElement");
#endif
    destPort = TkMacOSXGetDrawablePort(Tk_WindowId(scalePtr->tkwin));
    portChanged = QDSwapPort(destPort, &savePort);

    /*
     * All of the calculations in this procedure mirror those in
     * DisplayScrollbar. Be sure to keep the two consistent.
     */

    TkMacOSXWinBounds((TkWindow *) scalePtr->tkwin, &bounds);
    where.h = x + bounds.left;
    where.v = y + bounds.top;
    part = TestControl(macScalePtr->scaleHandle, where);

    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }

#ifdef TK_MAC_DEBUG_SCALE
    fprintf (stderr,"ScalePart %d, pos ( %d %d )\n", part, where.h, where.v );
#endif

    switch (part) {
	case inSlider:
	    return SLIDER;
	case inInc:
	    if (scalePtr->orient == ORIENT_VERTICAL) {
		return TROUGH1;
	    } else {
		return TROUGH2;
	    }
	case inDecr:
	    if (scalePtr->orient == ORIENT_VERTICAL) {
		return TROUGH2;
	    } else {
		return TROUGH1;
	    }
	default:
	    return OTHER;
    }
}

/*
 *--------------------------------------------------------------
 *
 * MacScaleEventProc --
 *
 *	This procedure is invoked by the Tk dispatcher for
 *	ButtonPress events on scales.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	When the window gets deleted, internal structures get
 *	cleaned up. When it gets exposed, it is redisplayed.
 *
 *--------------------------------------------------------------
 */

static void
MacScaleEventProc(
    ClientData clientData,	/* Information about window. */
    XEvent *eventPtr)		/* Information about event. */
{
    MacScale *macScalePtr = (MacScale *) clientData;
    Point where;
    Rect bounds;
    int part;
    CGrafPtr destPort, savePort;
    Boolean portChanged;

#ifdef TK_MAC_DEBUG_SCALE
    fprintf(stderr,"MacScaleEventProc\n" );
#endif

    /*
     * To call Macintosh control routines we must have the port
     * set to the window containing the control. We will then test
     * which part of the control was hit and act accordingly.
     */

    destPort = TkMacOSXGetDrawablePort(Tk_WindowId(macScalePtr->info.tkwin));
    portChanged = QDSwapPort(destPort, &savePort);
    TkMacOSXSetUpClippingRgn(Tk_WindowId(macScalePtr->info.tkwin));

    TkMacOSXWinBounds((TkWindow *) macScalePtr->info.tkwin, &bounds);
    where.h = eventPtr->xbutton.x + bounds.left;
    where.v = eventPtr->xbutton.y + bounds.top;
#ifdef TK_MAC_DEBUG_SCALE
    TkMacOSXDbgMsg("calling TestControl");
#endif
    part = TestControl(macScalePtr->scaleHandle, where);
    if (part == 0) {
	return;
    }

    TkMacOSXTrackingLoop(1);
    part = HandleControlClick(macScalePtr->scaleHandle, where,
	    TkMacOSXModifierState(), scaleActionProc);
    TkMacOSXTrackingLoop(0);

    /*
     * Update the value for the widget.
     */

    macScalePtr->info.value = GetControlValue(macScalePtr->scaleHandle);
    /* TkScaleSetValue(&macScalePtr->info, macScalePtr->info.value, 1, 0); */

    /*
     * The HandleControlClick call will "eat" the ButtonUp event. We now
     * generate a ButtonUp event so Tk will unset implicit grabs etc.
     */

    TkGenerateButtonEventForXPointer(Tk_WindowId(macScalePtr->info.tkwin));

    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
}

/*
 *--------------------------------------------------------------
 *
 * ScaleActionProc --
 *
 *	Callback procedure used by the Macintosh toolbox call
 *	HandleControlClick. This call will update the display
 *	while the scrollbar is being manipulated by the user.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May change the display.
 *
 *--------------------------------------------------------------
 */

static pascal void
ScaleActionProc(
    ControlRef theControl,	/* Handle to scrollbat control */
    ControlPartCode partCode)	/* Part of scrollbar that was "hit" */
{
    int value;
    TkScale *scalePtr = (TkScale *) GetControlReference(theControl);

#ifdef TK_MAC_DEBUG_SCALE
    TkMacOSXDbgMsg("ScaleActionProc");
#endif
    value = GetControlValue(theControl);
    TkScaleSetValue(scalePtr, value, 1, 1);
    Tcl_Preserve((ClientData) scalePtr);
    TkMacOSXRunTclEventLoop();
    Tcl_Release((ClientData) scalePtr);
}

@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkMacOSXScale.c,v 1.11 2007/04/23 21:24:34 das Exp $
d17 1
a17 1
#include "tkMacOSXInt.h"
d212 2
a213 2
    windowRef = GetWindowFromPort(destPort);
    portChanged = QDSwapPort(dstPort, &savePort);
d270 1
a270 5
	/*
	 * If we are foremost than make us active.
	 */

	if (windowRef == FrontWindow()) {
d330 1
a330 1
    portChanged = QDSwapPort(dstPort, &savePort);
d411 1
a411 1
    portChanged = QDSwapPort(dstPort, &savePort);
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d1 1
a1 1
/* 
d4 1
a4 1
 *	This file implements the Macintosh specific portion of the 
d9 1
d14 1
a14 1
 * RCS: @@(#) $Id: tkMacOSXScale.c,v 1.8 2006/04/28 06:02:49 das Exp $
d21 6
d29 1
d54 4
a57 4
static void		MacScaleEventProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static pascal void	ScaleActionProc _ANSI_ARGS_((ControlRef theControl,
			    ControlPartCode partCode));
d76 2
a77 2
TkpCreateScale(tkwin)
    Tk_Window tkwin;
d79 2
a80 3
    MacScale *macScalePtr;
    
    macScalePtr = (MacScale *) ckalloc(sizeof(MacScale));
d85 1
a85 1
    
d88 1
a88 1
	    
d109 2
a110 2
TkpDestroyScale(scalePtr)
    TkScale *scalePtr;
d113 1
a113 1
    
d117 1
d119 1
a119 1
        DisposeControl(macScalePtr->scaleHandle);
d141 2
a142 2
TkpDisplayScale(clientData)
    ClientData clientData;	/* Widget record for scale. */
d152 2
a153 3
    CGrafPtr destPort;        
    CGrafPtr saveWorld;
    GDHandle saveDevice;
d155 2
a156 5
    SInt32       initialValue;
    SInt32       minValue;
    SInt32       maxValue;
    UInt16       numTicks;
    
d158 2
a159 2
#ifdef TK_MAC_DEBUG
    fprintf(stderr,"TkpDisplayScale\n");
d174 1
a174 2
	result = Tcl_VarEval(interp, scalePtr->command, " ", string,
		(char *) NULL);
d190 1
a190 1
     * horizontal and vertical scales:  border and traversal
d195 2
a196 3
	GC gc;
    
	gc = Tk_GCForColor(scalePtr->highlightColorPtr, Tk_WindowId(tkwin));
d209 1
d213 1
a213 2
    GetGWorld(&saveWorld, &saveDevice);
    SetGWorld(destPort, NULL);
d223 10
a232 10
        int offset;
        offset = (Tk_Height(tkwin) - MAC_OSX_SCROLL_WIDTH)/2;
        if (offset < 0) {
            offset = 0;
        }
        
        r.left = macDraw->xOff + scalePtr->inset;
        r.top = macDraw->yOff + offset;
        r.right = macDraw->xOff+Tk_Width(tkwin) - scalePtr->inset;
        r.bottom = macDraw->yOff + offset + MAC_OSX_SCROLL_WIDTH/2;
d234 10
a243 11
        int offset;
    
        offset = (Tk_Width(tkwin) - MAC_OSX_SCROLL_WIDTH)/2;
        if (offset < 0) {
            offset = 0;
        }
        
        r.left = macDraw->xOff + offset;
        r.top = macDraw->yOff + scalePtr->inset;
        r.right = macDraw->xOff + offset + MAC_OSX_SCROLL_WIDTH/2;
        r.bottom = macDraw->yOff+Tk_Height(tkwin) - scalePtr->inset;
d247 2
a248 3
        
#ifdef TK_MAC_DEBUG
        fprintf(stderr,"Initialising scale\n");
d250 8
d259 10
a268 20
        initialValue = scalePtr->value;
        if (scalePtr->orient == ORIENT_HORIZONTAL) {
            minValue = scalePtr->fromValue;
            maxValue = scalePtr->toValue;
        } else {
            minValue = scalePtr->fromValue;
            maxValue = scalePtr->toValue;
        }
        
        if (scalePtr->tickInterval == 0) {
            numTicks = 0;
        } else {
            numTicks = (maxValue - minValue)/scalePtr->tickInterval;
        }
                
        CreateSliderControl(windowRef, &r, initialValue, minValue, maxValue,
                kControlSliderPointsDownOrRight, numTicks, 
                1, scaleActionProc, 
                &(macScalePtr->scaleHandle));
        SetControlReference(macScalePtr->scaleHandle, (UInt32) scalePtr);
d273 1
d278 4
a281 4
        SetControlBounds(macScalePtr->scaleHandle, &r);
        SetControl32BitValue(macScalePtr->scaleHandle, scalePtr->value);
        SetControl32BitMinimum(macScalePtr->scaleHandle, scalePtr->fromValue);
        SetControl32BitMaximum(macScalePtr->scaleHandle, scalePtr->toValue);
d287 1
d292 3
a294 1
    SetGWorld(saveWorld, saveDevice);
d319 3
a321 3
TkpScaleElement(scalePtr, x, y)
    TkScale *scalePtr;		/* Widget record for scale. */
    int x, y;			/* Coordinates within scalePtr's window. */
d327 5
a331 5
    CGrafPtr saveWorld;
    GDHandle saveDevice;
    GWorldPtr destPort;        
#ifdef TK_MAC_DEBUG
    fprintf(stderr,"TkpScaleElement\n");
a332 1

d334 1
a334 2
    GetGWorld(&saveWorld, &saveDevice);
    SetGWorld(destPort, NULL);
d338 1
a338 1
     * DisplayScrollbar.  Be sure to keep the two consistent.
d341 1
a341 1
    TkMacOSXWinBounds((TkWindow *) scalePtr->tkwin, &bounds);		
a344 2
    
    SetGWorld(saveWorld, saveDevice);
d346 5
a350 1
#ifdef TK_MAC_DEBUG
d353 1
a353 1
    
d355 1
a355 1
    	case inSlider:
d357 1
a357 1
    	case inInc:
d363 1
a363 1
    	case inDecr:
d369 1
a369 1
    	default:
d379 1
a379 1
 *	This procedure is invoked by the Tk dispatcher for 
d387 1
a387 1
 *	cleaned up.  When it gets exposed, it is redisplayed.
d393 3
a395 3
MacScaleEventProc(clientData, eventPtr)
    ClientData clientData;	/* Information about window. */
    XEvent *eventPtr;		/* Information about event. */
d401 2
a402 3
    CGrafPtr saveWorld;
    GDHandle saveDevice;
    GWorldPtr destPort;
d404 1
a404 1
#ifdef TK_MAC_DEBUG
d407 1
d410 1
a410 1
     * set to the window containing the control.  We will then test
d413 1
d415 1
a415 2
    GetGWorld(&saveWorld, &saveDevice);
    SetGWorld(destPort, NULL);
d418 1
a418 1
    TkMacOSXWinBounds((TkWindow *) macScalePtr->info.tkwin, &bounds);		
d421 2
a422 2
#ifdef TK_MAC_DEBUG
    fprintf(stderr,"calling TestControl\n");
d428 6
a433 3
    
    part = TrackControl(macScalePtr->scaleHandle, where, scaleActionProc);
    
d437 1
d442 1
a442 1
     * The TrackControl call will "eat" the ButtonUp event.  We now
d445 1
d448 3
a450 1
    SetGWorld(saveWorld, saveDevice);
d459 2
a460 2
 *	TrackControl.  This call will update the display while
 *	the scrollbar is being manipulated by the user.
d479 2
a480 2
#ifdef TK_MAC_DEBUG
    fprintf(stderr,"ScaleActionProc\n");
d482 1
a482 1
    value =  GetControlValue(theControl);
d485 1
a485 1
    Tcl_DoOneEvent(TCL_IDLE_EVENTS);
@

