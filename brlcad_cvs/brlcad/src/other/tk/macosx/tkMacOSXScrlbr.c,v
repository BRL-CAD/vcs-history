head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.46;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXScrollbar.c --
 *
 *	This file implements the Macintosh specific portion of the scrollbar
 *	widget. The Macintosh scrollbar may also draw a windows grow
 *	region under certain cases.
 *
 * Copyright (c) 1996 by Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXScrlbr.c,v 1.25 2007/06/29 03:20:02 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkScrollbar.h"
#include "tkMacOSXDebug.h"

#define MIN_SCROLLBAR_VALUE		0
#define SCROLLBAR_SCALING_VALUE		((double)(LONG_MAX>>1))

/*
 * Declaration of Mac specific scrollbar structure.
 */

typedef struct MacScrollbar {
    TkScrollbar info;		/* Generic scrollbar info */
    ControlRef	sbHandle;	/* Scrollbar control */
    int		macFlags;	/* Various flags; see below */
    Rect	eraseRect;	/* Rect to erase before drawing control */
} MacScrollbar;

/*
 * Flag bits for scrollbars on the Mac:
 *
 * ALREADY_DEAD:		Non-zero means this scrollbar has been
 *				destroyed, but has not been cleaned up.
 * IN_MODAL_LOOP:		Non-zero means this scrollbar is in the middle
 *				of a modal loop.
 * ACTIVE:			Non-zero means this window is currently
 *				active (in the foreground).
 */

#define ALREADY_DEAD		1
#define IN_MODAL_LOOP		2
#define ACTIVE			4

/*
 * Globals uses locally in this file.
 */
static ControlActionUPP scrollActionProc = NULL;	/* Pointer to func. */
static ControlActionUPP thumbActionProc = NULL;		/* Pointer to func. */
static Point mouseDownPoint;	/* Used to store the coordinates where the  */
				/* mouse was first pressed to begin	    */
				/* dragging the thumb, because		    */
				/* ThumbActionProc can't take any args.	    */

typedef struct ScrollbarMetrics {
    SInt32 width, minHeight, minThumbHeight;
    short topArrowHeight, bottomArrowHeight;
    ControlSize size;
} ScrollbarMetrics;

static ScrollbarMetrics metrics[2] = {
    {15, 54, 26, 14, 14, kControlSizeNormal}, /* kThemeScrollBarMedium */
    {11, 40, 20, 10, 10, kControlSizeSmall},  /* kThemeScrollBarSmall  */
};

/*
 * This variable holds the default width for a scrollbar in string form for
 * use in a Tk_ConfigSpec.
 */

static char defWidth[TCL_INTEGER_SPACE];

/*
 * Forward declarations for procedures defined later in this file:
 */

static pascal void ScrollbarActionProc(ControlRef theControl,
	ControlPartCode partCode);
static pascal void ThumbActionProc(ControlRef theControl,
	ControlPartCode partCode);
static int ScrollbarBindProc(ClientData clientData, Tcl_Interp *interp,
	XEvent *eventPtr, Tk_Window tkwin, KeySym keySym);
static void ScrollbarEventProc(ClientData clientData, XEvent *eventPtr);
static void UpdateControlValues(MacScrollbar *macScrollPtr);

/*
 * The class procedure table for the scrollbar widget. Leave the proc fields
 * initialized to NULL, which should happen automatically because of the scope
 * at which the variable is declared.
 */

Tk_ClassProcs tkpScrollbarProcs = {
    sizeof(Tk_ClassProcs)	/* size */
};

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXInitScrollbarMetrics --
 *
 *	This function initializes the current system metrics for a
 *	scrollbar.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Updates the geometry cache info for all scrollbars.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXInitScrollbarMetrics(void)
{
    const short height = 100, width = 50;
    ThemeTrackDrawInfo info = {0, {0, 0, height, width}, 0, 1, 0, 0,
	    kThemeTrackShowThumb, kThemeTrackActive, 0, {{1, 0}}};
    Rect bounds;
    Tk_ConfigSpec *specPtr;

    ChkErr(GetThemeMetric, kThemeMetricScrollBarWidth, &metrics[0].width);
    ChkErr(GetThemeMetric, kThemeMetricScrollBarMinThumbHeight,
	    &metrics[0].minThumbHeight);
    info.kind = kThemeScrollBarMedium;
    ChkErr(GetThemeTrackDragRect, &info, &bounds);
    metrics[0].topArrowHeight = bounds.top;
    metrics[0].bottomArrowHeight = height - bounds.bottom;
    metrics[0].minHeight = metrics[0].minThumbHeight +
	    metrics[0].topArrowHeight + metrics[0].bottomArrowHeight;
    ChkErr(GetThemeMetric, kThemeMetricSmallScrollBarWidth, &metrics[1].width);
    ChkErr(GetThemeMetric, kThemeMetricSmallScrollBarMinThumbHeight,
	    &metrics[1].minThumbHeight);
    info.kind = kThemeScrollBarSmall;
    ChkErr(GetThemeTrackDragRect, &info, &bounds);
    metrics[1].topArrowHeight = bounds.top;
    metrics[1].bottomArrowHeight = height - bounds.bottom;
    metrics[1].minHeight = metrics[1].minThumbHeight +
	    metrics[1].topArrowHeight + metrics[1].bottomArrowHeight;

    sprintf(defWidth, "%ld", metrics[0].width);
    for (specPtr = tkpScrollbarConfigSpecs; specPtr->type != TK_CONFIG_END;
	    specPtr++) {
	if (specPtr->offset == Tk_Offset(TkScrollbar, width)) {
	    specPtr->defValue = defWidth;
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpCreateScrollbar --
 *
 *	Allocate a new TkScrollbar structure.
 *
 * Results:
 *	Returns a newly allocated TkScrollbar structure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TkScrollbar *
TkpCreateScrollbar(
    Tk_Window tkwin)	/* New Tk Window. */
{
    static int initialized = 0;
    MacScrollbar * macScrollPtr;
    TkWindow *winPtr = (TkWindow *)tkwin;

    if (scrollActionProc == NULL) {
	scrollActionProc = NewControlActionUPP(ScrollbarActionProc);
	thumbActionProc =  NewControlActionUPP(ThumbActionProc);
    }
    if (!initialized) {
	TkMacOSXInitScrollbarMetrics();
	initialized = 1;
    }
    macScrollPtr = (MacScrollbar *) ckalloc(sizeof(MacScrollbar));
    macScrollPtr->sbHandle = NULL;
    macScrollPtr->macFlags = 0;
    SetRect(&macScrollPtr->eraseRect, 0, 0, 0, 0);

    Tk_CreateEventHandler(tkwin, ActivateMask|ExposureMask|
	StructureNotifyMask|FocusChangeMask,
	ScrollbarEventProc, (ClientData) macScrollPtr);

    if (!Tcl_GetAssocData(winPtr->mainPtr->interp, "TkScrollbar", NULL)) {
	Tcl_SetAssocData(winPtr->mainPtr->interp, "TkScrollbar", NULL,
		(ClientData)1);
	TkCreateBindingProcedure(winPtr->mainPtr->interp,
	    winPtr->mainPtr->bindingTable,
	    (ClientData)Tk_GetUid("Scrollbar"), "<ButtonPress>",
	    ScrollbarBindProc, NULL, NULL);
    }
    return (TkScrollbar *) macScrollPtr;
}

/*
 *--------------------------------------------------------------
 *
 * TkpDisplayScrollbar --
 *
 *	This procedure redraws the contents of a scrollbar window.
 *	It is invoked as a do-when-idle handler, so it only runs
 *	when there's nothing else for the application to do.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Information appears on the screen.
 *
 *--------------------------------------------------------------
 */

void
TkpDisplayScrollbar(
    ClientData clientData)	/* Information about window. */
{
    TkScrollbar *scrollPtr = (TkScrollbar *) clientData;
    MacScrollbar *macScrollPtr = (MacScrollbar *) clientData;
    Tk_Window tkwin = scrollPtr->tkwin;
    CGrafPtr destPort, savePort;
    Boolean portChanged;
    WindowRef windowRef;

    if ((scrollPtr->tkwin == NULL) || !Tk_IsMapped(tkwin)) {
	goto done;
    }

    /*
     * Draw the focus or any 3D relief we may have.
     */
    if (scrollPtr->highlightWidth != 0) {
	GC fgGC, bgGC;

	bgGC = Tk_GCForColor(scrollPtr->highlightBgColorPtr,
	    Tk_WindowId(tkwin));

	if (scrollPtr->flags & GOT_FOCUS) {
	    fgGC = Tk_GCForColor(scrollPtr->highlightColorPtr,
		Tk_WindowId(tkwin));
	    TkpDrawHighlightBorder(tkwin, fgGC, bgGC, scrollPtr->highlightWidth,
		Tk_WindowId(tkwin));
	} else {
	    TkpDrawHighlightBorder(tkwin, bgGC, bgGC, scrollPtr->highlightWidth,
		Tk_WindowId(tkwin));
	}
    }
    Tk_Draw3DRectangle(tkwin, Tk_WindowId(tkwin), scrollPtr->bgBorder,
	scrollPtr->highlightWidth, scrollPtr->highlightWidth,
	Tk_Width(tkwin) - 2*scrollPtr->highlightWidth,
	Tk_Height(tkwin) - 2*scrollPtr->highlightWidth,
	scrollPtr->borderWidth, scrollPtr->relief);

    if (macScrollPtr->sbHandle == NULL) {
	Rect r = {0, 0, 1, 1};

	windowRef = TkMacOSXDrawableWindow(Tk_WindowId(tkwin));
	CreateScrollBarControl(windowRef, &r, 0, 0, 0, 0, true, NULL,
		&(macScrollPtr->sbHandle));
	SetControlReference(macScrollPtr->sbHandle, (SInt32) scrollPtr);

	if (IsWindowActive(windowRef)) {
	    macScrollPtr->macFlags |= ACTIVE;
	}
    }

    /*
     * Update the control values before we draw.
     */

    UpdateControlValues(macScrollPtr);

    /*
     * Set up port for drawing Macintosh control.
     */
    destPort = TkMacOSXGetDrawablePort(Tk_WindowId(tkwin));
    portChanged = QDSwapPort(destPort, &savePort);
    TkMacOSXSetUpClippingRgn(Tk_WindowId(tkwin));

    /*
     * Scrollbars do not erase the complete control bounds if they are wider
     * than the standard width, so manually erase the extra space.
     */

    if (!EmptyRect(&macScrollPtr->eraseRect)) {
	EraseRect(&macScrollPtr->eraseRect);
    }

    Draw1Control(macScrollPtr->sbHandle);

    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }

    done:
    scrollPtr->flags &= ~REDRAW_PENDING;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpConfigureScrollbar --
 *
 *	This procedure is called after the generic code has finished
 *	processing configuration options, in order to configure
 *	platform specific options.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkpConfigureScrollbar(scrollPtr)
    register TkScrollbar *scrollPtr;	/* Information about widget; may or
					 * may not already have values for
					 * some fields. */
{
}

/*
 *----------------------------------------------------------------------
 *
 * TkpComputeScrollbarGeometry --
 *
 *	After changes in a scrollbar's size or configuration, this
 *	procedure recomputes various geometry information used in
 *	displaying the scrollbar.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The scrollbar will be displayed differently.
 *
 *----------------------------------------------------------------------
 */

void
TkpComputeScrollbarGeometry(
    register TkScrollbar *scrollPtr)	/* Scrollbar whose geometry may
					 * have changed. */
{
    int variant, fieldLength;

    if (scrollPtr->highlightWidth < 0) {
	scrollPtr->highlightWidth = 0;
    }
    scrollPtr->inset = scrollPtr->highlightWidth + scrollPtr->borderWidth;
    variant = ((scrollPtr->vertical ? Tk_Width(scrollPtr->tkwin) :
	    Tk_Height(scrollPtr->tkwin)) - 2 * scrollPtr->inset
	    < metrics[0].width) ? 1 : 0;
    scrollPtr->arrowLength = (metrics[variant].topArrowHeight +
	    metrics[variant].bottomArrowHeight) / 2;
    fieldLength = (scrollPtr->vertical ? Tk_Height(scrollPtr->tkwin)
	    : Tk_Width(scrollPtr->tkwin))
	    - 2 * (scrollPtr->arrowLength + scrollPtr->inset);
    if (fieldLength < 0) {
	fieldLength = 0;
    }
    scrollPtr->sliderFirst = fieldLength * scrollPtr->firstFraction;
    scrollPtr->sliderLast = fieldLength * scrollPtr->lastFraction;

    /*
     * Adjust the slider so that some piece of it is always
     * displayed in the scrollbar and so that it has at least
     * a minimal width (so it can be grabbed with the mouse).
     */

    if (scrollPtr->sliderFirst > (fieldLength - 2*scrollPtr->borderWidth)) {
	scrollPtr->sliderFirst = fieldLength - 2*scrollPtr->borderWidth;
    }
    if (scrollPtr->sliderFirst < 0) {
	scrollPtr->sliderFirst = 0;
    }
    if (scrollPtr->sliderLast < (scrollPtr->sliderFirst +
	    metrics[variant].minThumbHeight)) {
	scrollPtr->sliderLast = scrollPtr->sliderFirst +
		metrics[variant].minThumbHeight;
    }
    if (scrollPtr->sliderLast > fieldLength) {
	scrollPtr->sliderLast = fieldLength;
    }
    scrollPtr->sliderFirst += scrollPtr->inset +
	    metrics[variant].topArrowHeight;
    scrollPtr->sliderLast += scrollPtr->inset +
	    metrics[variant].bottomArrowHeight;

    /*
     * Register the desired geometry for the window (leave enough space
     * for the two arrows plus a minimum-size slider, plus border around
     * the whole window, if any). Then arrange for the window to be
     * redisplayed.
     */

    if (scrollPtr->vertical) {
	Tk_GeometryRequest(scrollPtr->tkwin, scrollPtr->width +
		2 * scrollPtr->inset, 2 * (scrollPtr->arrowLength +
		scrollPtr->borderWidth + scrollPtr->inset) +
		metrics[variant].minThumbHeight);
    } else {
	Tk_GeometryRequest(scrollPtr->tkwin, 2 * (scrollPtr->arrowLength +
		scrollPtr->borderWidth + scrollPtr->inset) +
		metrics[variant].minThumbHeight, scrollPtr->width +
		2 * scrollPtr->inset);
    }
    Tk_SetInternalBorder(scrollPtr->tkwin, scrollPtr->inset);
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDestroyScrollbar --
 *
 *	Free data structures associated with the scrollbar control.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkpDestroyScrollbar(
    TkScrollbar *scrollPtr)	/* Scrollbar to destroy. */
{
    MacScrollbar *macScrollPtr = (MacScrollbar *)scrollPtr;

    if (macScrollPtr->sbHandle != NULL) {
	if (!(macScrollPtr->macFlags & IN_MODAL_LOOP)) {
	    DisposeControl(macScrollPtr->sbHandle);
	    macScrollPtr->sbHandle = NULL;
	}
    }
    macScrollPtr->macFlags |= ALREADY_DEAD;
}

/*
 *--------------------------------------------------------------
 *
 * TkpScrollbarPosition --
 *
 *	Determine the scrollbar element corresponding to a
 *	given position.
 *
 * Results:
 *	One of TOP_ARROW, TOP_GAP, etc., indicating which element
 *	of the scrollbar covers the position given by (x, y). If
 *	(x,y) is outside the scrollbar entirely, then OUTSIDE is
 *	returned.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
TkpScrollbarPosition(
    TkScrollbar *scrollPtr,	/* Scrollbar widget record. */
    int x, int y)		/* Coordinates within scrollPtr's
				 * window. */
{
    MacScrollbar *macScrollPtr = (MacScrollbar *) scrollPtr;
    CGrafPtr destPort, savePort;
    Boolean portChanged;
    int inactive = 0;
    ControlPartCode part;
    Point where = {y, x};
    Rect bounds;

    if ((x < scrollPtr->inset) || (x >= (Tk_Width(scrollPtr->tkwin) -
	    scrollPtr->inset)) || (y < scrollPtr->inset) ||
	    (y >= (Tk_Height(scrollPtr->tkwin) - scrollPtr->inset))) {
	return OUTSIDE;
    }

    /*
     * All of the calculations in this procedure mirror those in
     * DisplayScrollbar. Be sure to keep the two consistent. On the
     * Macintosh we use the OS call TestControl to do this mapping.
     * For TestControl to work, the scrollbar must be active and must
     * be in the current port.
     */

    destPort = TkMacOSXGetDrawablePort(Tk_WindowId(scrollPtr->tkwin));
    portChanged = QDSwapPort(destPort, &savePort);
    UpdateControlValues(macScrollPtr);
    if (!IsControlActive(macScrollPtr->sbHandle)) {
	inactive = true;
	ActivateControl(macScrollPtr->sbHandle);
    }
    TkMacOSXWinBounds((TkWindow *) scrollPtr->tkwin, &bounds);
    where.h += bounds.left;
    where.v += bounds.top;
    part = TestControl(((MacScrollbar *) scrollPtr)->sbHandle, where);
    if (inactive) {
	DeactivateControl(macScrollPtr->sbHandle);
    }
    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
    switch (part) {
	case kAppearancePartUpButton:
	    return TOP_ARROW;
	case kAppearancePartPageUpArea:
	    return TOP_GAP;
	case kAppearancePartIndicator:
	    return SLIDER;
	case kAppearancePartPageDownArea:
	    return BOTTOM_GAP;
	case kAppearancePartDownButton:
	    return BOTTOM_ARROW;
	default:
	    return OUTSIDE;
    }
}

/*
 *--------------------------------------------------------------
 *
 * ThumbActionProc --
 *
 *	Callback procedure used by the Macintosh toolbox call
 *	HandleControlClick. This call is used to track the
 *	thumb of the scrollbar. Unlike the
 *	ScrollbarActionProc function this function is called
 *	once and basically takes over tracking the scrollbar
 *	from the control. This is done to avoid conflicts with
 *	what the control plans to draw.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May change the display.
 *
 *--------------------------------------------------------------
 */

static pascal void
ThumbActionProc(ControlRef theControl, ControlPartCode partCode)
{
    TkScrollbar *scrollPtr = (TkScrollbar *)(intptr_t)GetControlReference(
	    theControl);
    MacScrollbar *macScrollPtr = (MacScrollbar *) scrollPtr;
    Tcl_DString cmdString;
    int origValue, variant;
    short trackBarSize;
    double oldFirstFraction, newFirstFraction;
    char valueString[40];
    Point currentPoint = { 0, 0 };
    Rect trackRect;
    Tcl_Interp *interp;
    MouseTrackingResult trackingResult;
    OSStatus err;

    if (scrollPtr == NULL) {
	return;
    }

    Tcl_DStringInit(&cmdString);
    origValue = GetControl32BitValue(macScrollPtr->sbHandle);
    GetControlBounds(macScrollPtr->sbHandle, &trackRect);

    if (scrollPtr->vertical) {
	variant = (trackRect.right - trackRect.left) < metrics[0].width ? 1 : 0;
	trackBarSize = trackRect.bottom - trackRect.top -
		metrics[variant].topArrowHeight -
		metrics[variant].bottomArrowHeight;
	InsetRect(&trackRect, -25, -113);
    } else {
	variant = (trackRect.bottom - trackRect.top) < metrics[0].width ? 1 : 0;
	trackBarSize = trackRect.right - trackRect.left -
		metrics[variant].topArrowHeight -
		metrics[variant].bottomArrowHeight;
	InsetRect(&trackRect, -113, -25);
    }

    /*
     * Track the mouse while the button is held down. If the mouse is moved,
     * we calculate the value that should be passed to the "command" part of
     * the scrollbar. Since the mouse may move a distance too small to
     * cause a change to the first fraction, each calculation must be done
     * versus what the first fraction was when the mouse button was
     * initially pressed. Otherwise, moving the mouse too slowly will
     * cause the calculated fraction delta to be zero and the scrollbar
     * won't respond.
     */

    oldFirstFraction = scrollPtr->firstFraction;

    TkMacOSXTrackingLoop(1);
    do {
	err = ChkErr(TrackMouseLocationWithOptions, NULL,
		kTrackMouseLocationOptionDontConsumeMouseUp,
		kEventDurationForever, &currentPoint, NULL, &trackingResult);
	if ((err == noErr) && ((trackingResult == kMouseTrackingMouseDragged)
		|| (trackingResult == kMouseTrackingMouseMoved))) {

	   /*
	    * Calculate where the scrollbar should move to, based on
	    * where the mouse button was pressed and where the scrollbar
	    * initially was at that time. Note that PtInRect() will
	    * return false if currentPoint or trackRect are not in
	    * is not in current graphics port, which may happen if any
	    * of the waiting idle events change the port (e.g. with
	    * SetPort()) but fail to restore it before returning and the
	    * scrollbar will lock in place.
	    */
	    newFirstFraction = oldFirstFraction;
	    if (PtInRect(currentPoint, &trackRect)) {
		short pixDiff;

		if (scrollPtr->vertical) {
		    pixDiff = currentPoint.v - mouseDownPoint.v;
		} else {
		    pixDiff = currentPoint.h - mouseDownPoint.h;
		}
		newFirstFraction += (double)pixDiff / trackBarSize;
		if (newFirstFraction > 1.0) {
		    newFirstFraction = 1.0;
		} else if (newFirstFraction < 0.0) {
		    newFirstFraction = 0.0;
		}
	    }

	    /*
	     * Move the scrollbar thumb to the new first fraction given
	     * its position when initially pressed and how far the mouse
	     * has moved. Process waiting idle tasks afterward to allow
	     * for the display to update.
	     */

	    sprintf(valueString, "%g", newFirstFraction);
	    Tcl_DStringSetLength(&cmdString, 0);
	    Tcl_DStringAppend(&cmdString, scrollPtr->command,
		scrollPtr->commandSize);
	    Tcl_DStringAppendElement(&cmdString, "moveto");
	    Tcl_DStringAppendElement(&cmdString, valueString);
	    interp = scrollPtr->interp;
	    Tcl_Preserve((ClientData) interp);
	    Tcl_EvalEx(interp, Tcl_DStringValue(&cmdString),
		    Tcl_DStringLength(&cmdString), TCL_EVAL_GLOBAL);
	    Tcl_Release((ClientData) interp);
	    TkMacOSXRunTclEventLoop();
	}
    } while ((err == noErr) && trackingResult != kMouseTrackingMouseReleased);
    TkMacOSXTrackingLoop(0);
    Tcl_DStringFree(&cmdString);
    return;
}

/*
 *--------------------------------------------------------------
 *
 * ScrollbarActionProc --
 *
 *	Callback procedure used by the Macintosh toolbox call
 *	HandleControlClick. This call will update the display
 *	while the scrollbar is being manipulated by the user.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May change the display.
 *
 *--------------------------------------------------------------
 */

static pascal void
ScrollbarActionProc(
    ControlRef theControl,	/* Handle to scrollbat control */
    ControlPartCode partCode)	/* Part of scrollbar that was "hit" */
{
    TkScrollbar *scrollPtr = (TkScrollbar *)(intptr_t)GetControlReference(
	    theControl);
    MacScrollbar *macScrollPtr = (MacScrollbar *) scrollPtr;
    Tcl_DString cmdString;

    Tcl_DStringInit(&cmdString);
    Tcl_DStringAppend(&cmdString, scrollPtr->command,
	    scrollPtr->commandSize);

    if ( partCode == kAppearancePartUpButton ||
	    partCode == kAppearancePartDownButton ) {
	Tcl_DStringAppendElement(&cmdString, "scroll");
	Tcl_DStringAppendElement(&cmdString,
		(partCode == kAppearancePartUpButton) ? "-1" : "1");
	Tcl_DStringAppendElement(&cmdString, "unit");
    } else if (partCode == kAppearancePartPageUpArea ||
	    partCode == kAppearancePartPageDownArea ) {
	Tcl_DStringAppendElement(&cmdString, "scroll");
	Tcl_DStringAppendElement(&cmdString,
		(partCode == kAppearancePartPageUpArea) ? "-1" : "1");
	Tcl_DStringAppendElement(&cmdString, "page");
    } else if (partCode == kAppearancePartIndicator) {
	char valueString[TCL_DOUBLE_SPACE];

	sprintf(valueString, "%g",
		(GetControl32BitValue(macScrollPtr->sbHandle) -
		MIN_SCROLLBAR_VALUE) / SCROLLBAR_SCALING_VALUE);
	Tcl_DStringAppendElement(&cmdString, "moveto");
	Tcl_DStringAppendElement(&cmdString, valueString);
    }
    Tcl_Preserve((ClientData) scrollPtr->interp);
    Tcl_EvalEx(scrollPtr->interp, Tcl_DStringValue(&cmdString),
	    Tcl_DStringLength(&cmdString), TCL_EVAL_GLOBAL);
    Tcl_Release((ClientData) scrollPtr->interp);
    Tcl_DStringFree(&cmdString);
    TkMacOSXRunTclEventLoop();
}

/*
 *--------------------------------------------------------------
 *
 * ScrollbarBindProc --
 *
 *	This procedure is invoked when the default <ButtonPress>
 *	binding on the Scrollbar bind tag fires.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The event enters a modal loop.
 *
 *--------------------------------------------------------------
 */

static int
ScrollbarBindProc(
    ClientData clientData,	/* Not used. */
    Tcl_Interp *interp,		/* Interp with binding. */
    XEvent *eventPtr,		/* X event that triggered binding. */
    Tk_Window tkwin,		/* Target window for event. */
    KeySym keySym)		/* The KeySym if a key event. */
{
    TkWindow *winPtr = (TkWindow*)tkwin;
    TkScrollbar *scrollPtr = (TkScrollbar *) winPtr->instanceData;
    MacScrollbar *macScrollPtr = (MacScrollbar *) winPtr->instanceData;

    Tcl_Preserve((ClientData)scrollPtr);
    macScrollPtr->macFlags |= IN_MODAL_LOOP;

    if (eventPtr->type == ButtonPress) {
	Point where;
	Rect bounds;
	ControlPartCode part;
	CGrafPtr destPort, savePort;
	Boolean portChanged;
	Window window;

	/*
	 * To call Macintosh control routines we must have the port
	 * set to the window containing the control. We will then test
	 * which part of the control was hit and act accordingly.
	 */
	destPort = TkMacOSXGetDrawablePort(Tk_WindowId(scrollPtr->tkwin));
	portChanged = QDSwapPort(destPort, &savePort);
	TkMacOSXSetUpClippingRgn(Tk_WindowId(scrollPtr->tkwin));

	TkMacOSXWinBounds((TkWindow *) scrollPtr->tkwin, &bounds);
	where.h = eventPtr->xbutton.x + bounds.left;
	where.v = eventPtr->xbutton.y + bounds.top;
	part = TestControl(macScrollPtr->sbHandle, where);
	TkMacOSXTrackingLoop(1);
	if (part == kAppearancePartIndicator && scrollPtr->jump == false) {
	    /*
	     * Case 1: In thumb, no jump scrolling. Call track control
	     * with the thumb action proc which will do most of the work.
	     */
	    mouseDownPoint.h = where.h;
	    mouseDownPoint.v = where.v;
	    part = HandleControlClick(macScrollPtr->sbHandle, where,
		    TkMacOSXModifierState(), thumbActionProc);
	} else if (part == kAppearancePartIndicator) {
	    /*
	     * Case 2: in thumb with jump scrolling. Call HandleControlClick
	     * with a NULL action proc. Use the new value of the control
	     * to set update the control.
	     */
	    part = HandleControlClick(macScrollPtr->sbHandle, where,
		    TkMacOSXModifierState(), NULL);
	    if (part == kAppearancePartIndicator) {
		Tcl_DString cmdString;
		char valueString[TCL_DOUBLE_SPACE];

		sprintf(valueString, "%g",
			(GetControl32BitValue(macScrollPtr->sbHandle) -
			MIN_SCROLLBAR_VALUE) / SCROLLBAR_SCALING_VALUE);
		Tcl_DStringInit(&cmdString);
		Tcl_DStringAppend(&cmdString, scrollPtr->command,
			strlen(scrollPtr->command));
		Tcl_DStringAppendElement(&cmdString, "moveto");
		Tcl_DStringAppendElement(&cmdString, valueString);

		interp = scrollPtr->interp;
		Tcl_Preserve((ClientData) interp);
		Tcl_EvalEx(interp, Tcl_DStringValue(&cmdString),
			Tcl_DStringLength(&cmdString), TCL_EVAL_GLOBAL);
		Tcl_Release((ClientData) interp);
		Tcl_DStringFree(&cmdString);
		TkMacOSXRunTclEventLoop();
	    }
	} else if (part != 0) {
	    /*
	     * Case 3: in any other part of the scrollbar. We call
	     * HandleControlClick with the scrollActionProc which will do
	     * most all the work.
	     */
	    HandleControlClick(macScrollPtr->sbHandle, where,
		    TkMacOSXModifierState(), scrollActionProc);
	    /*
	     * Workaround for Carbon bug where the scrollbar down arrow
	     * sometimes gets "stuck" after the mousebutton has been released.
	     */
	    if (scrollPtr->tkwin) {
		TkMacOSXSetUpClippingRgn(Tk_WindowId(scrollPtr->tkwin));
	    }
	    Draw1Control(macScrollPtr->sbHandle);
	}
	TkMacOSXTrackingLoop(0);

	/*
	 * The HandleControlClick call will "eat" the ButtonUp event. We now
	 * generate a ButtonUp event so Tk will unset implicit grabs etc.
	 */

	if (scrollPtr->tkwin) {
	    window = Tk_WindowId(scrollPtr->tkwin);
	    TkGenerateButtonEventForXPointer(window);
	}

	if (portChanged) {
	    QDSwapPort(savePort, NULL);
	}
    }

    if (macScrollPtr->sbHandle && (macScrollPtr->macFlags & ALREADY_DEAD)) {
	DisposeControl(macScrollPtr->sbHandle);
	macScrollPtr->sbHandle = NULL;
    }
    macScrollPtr->macFlags &= ~IN_MODAL_LOOP;
    Tcl_Release((ClientData)scrollPtr);

    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * ScrollbarEventProc --
 *
 *	This procedure is invoked by the Tk dispatcher for various
 *	events on scrollbars.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	When the window gets deleted, internal structures get
 *	cleaned up. When it gets exposed, it is redisplayed.
 *
 *--------------------------------------------------------------
 */

static void
ScrollbarEventProc(
    ClientData clientData,	/* Information about window. */
    XEvent *eventPtr)		/* Information about event. */
{
    TkScrollbar *scrollPtr = (TkScrollbar *) clientData;
    MacScrollbar *macScrollPtr = (MacScrollbar *) clientData;

    if (eventPtr->type == UnmapNotify) {
	TkMacOSXSetScrollbarGrow((TkWindow *) scrollPtr->tkwin, false);
    } else if (eventPtr->type == ActivateNotify) {
	macScrollPtr->macFlags |= ACTIVE;
	TkScrollbarEventuallyRedraw((ClientData) scrollPtr);
    } else if (eventPtr->type == DeactivateNotify) {
	macScrollPtr->macFlags &= ~ACTIVE;
	TkScrollbarEventuallyRedraw((ClientData) scrollPtr);
    } else {
	TkScrollbarEventProc(clientData, eventPtr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * UpdateControlValues --
 *
 *	This procedure updates the Macintosh scrollbar control
 *	to display the values defined by the Tk scrollbar.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The Macintosh control is updated.
 *
 *--------------------------------------------------------------
 */

static void
UpdateControlValues(
    MacScrollbar *macScrollPtr)		/* Scrollbar data struct. */
{
    TkScrollbar *scrollPtr = (TkScrollbar *) macScrollPtr;
    Tk_Window tkwin = scrollPtr->tkwin;
    MacDrawable * macDraw = (MacDrawable *) Tk_WindowId(scrollPtr->tkwin);
    double dViewSize;
    Rect contrlRect, portRect;
    int variant, active;
    short width, height;

    contrlRect.left   = macDraw->xOff + scrollPtr->inset;
    contrlRect.top    = macDraw->yOff + scrollPtr->inset;
    contrlRect.right  = macDraw->xOff + Tk_Width(tkwin) - scrollPtr->inset;
    contrlRect.bottom = macDraw->yOff + Tk_Height(tkwin) - scrollPtr->inset;

    GetPortBounds (GetWindowPort(GetControlOwner(macScrollPtr->sbHandle)),
	    &portRect);

    /*
     * If the scrollbar is flush against the bottom right hand corner then
     * we leave space to draw the grow region for the window.
     */
    if (portRect.bottom == contrlRect.bottom &&
	    portRect.right == contrlRect.right) {
	TkMacOSXSetScrollbarGrow((TkWindow *) tkwin, true);
	if (macDraw->toplevel &&
		TkMacOSXResizable(macDraw->toplevel->winPtr)) {
	    int growSize;

	    switch (TkMacOSXWindowClass(macDraw->toplevel->winPtr)) {
		case kFloatingWindowClass:
		case kUtilityWindowClass:
		    growSize = metrics[1].width - 1;
		    break;
		case kDocumentWindowClass:
		case kMovableAlertWindowClass:
		case kMovableModalWindowClass:
		default:
		    growSize = metrics[0].width - 1;
		    break;
	    }
	    if (scrollPtr->vertical) {
		contrlRect.bottom -= growSize;
	    } else {
		contrlRect.right -= growSize;
	    }
	}
    } else {
	TkMacOSXSetScrollbarGrow((TkWindow *) tkwin, false);
    }

    if (IsControlVisible (macScrollPtr->sbHandle)) {
	SetControlVisibility(macScrollPtr->sbHandle, false, false);
    }

    if (scrollPtr->vertical) {
	width  = contrlRect.right - contrlRect.left;
	height = contrlRect.bottom - contrlRect.top;
    } else {
	width  = contrlRect.bottom - contrlRect.top;
	height = contrlRect.right - contrlRect.left;
    }
    variant = width < metrics[0].width ? 1 : 0;
    SetControlData(macScrollPtr->sbHandle, kControlEntireControl,
	    kControlSizeTag, sizeof(ControlSize),
	    &(metrics[variant].size));

    macScrollPtr->eraseRect = contrlRect;
    if (scrollPtr->vertical) {
	macScrollPtr->eraseRect.left += metrics[variant].width;
    } else {
	macScrollPtr->eraseRect.top  += metrics[variant].width;
    }

    /*
     * Ensure we set scrollbar control bounds only once all size
     * adjustments have been computed.
     */

    SetControlBounds(macScrollPtr->sbHandle, &contrlRect);

    /*
     * Given the Tk parameters for the fractions of the start and
     * end of the thumb, the following calculation determines the
     * location for the Macintosh thumb.
     * The Aqua scroll control works as follows.
     * The scrollbar's value is the position of the left (or top) side of
     * the view area in the content area being scrolled.
     * The maximum value of the control is therefore the dimension of
     * the content area less the size of the view area.
     * Since these values are all integers, and Tk gives the thumb position
     * as fractions, we have introduced a scaling factor.
     */

    dViewSize = (scrollPtr->lastFraction - scrollPtr->firstFraction)
	    * SCROLLBAR_SCALING_VALUE;
    SetControl32BitMinimum(macScrollPtr->sbHandle, MIN_SCROLLBAR_VALUE);
    SetControl32BitMaximum(macScrollPtr->sbHandle, MIN_SCROLLBAR_VALUE +
	    SCROLLBAR_SCALING_VALUE - dViewSize);
    SetControlViewSize(macScrollPtr->sbHandle, dViewSize);
    SetControl32BitValue(macScrollPtr->sbHandle, MIN_SCROLLBAR_VALUE +
	    SCROLLBAR_SCALING_VALUE * scrollPtr->firstFraction);

    if((scrollPtr->firstFraction <= 0.0 && scrollPtr->lastFraction >= 1.0)
	    || height <= metrics[variant].minHeight) {
	/* Disable scrollbar */
	SetControl32BitMaximum(macScrollPtr->sbHandle, MIN_SCROLLBAR_VALUE);
    }
    active = ((macScrollPtr->macFlags & ACTIVE) != 0);
    if (active != IsControlActive(macScrollPtr->sbHandle)) {
	if (active) {
	    ActivateControl(macScrollPtr->sbHandle);
	} else {
	    DeactivateControl(macScrollPtr->sbHandle);
	}
    }
    SetControlVisibility(macScrollPtr->sbHandle, true, false);
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tkMacOSXScrlbr.c,v 1.21 2007/04/23 21:24:34 das Exp $
d18 1
a18 1
#include "tkMacOSXInt.h"
d23 1
a23 1
#define SCROLLBAR_SCALING_VALUE		((float)LONG_MAX)
a232 1
    MacDrawable *macDraw;
a265 8
    /*
     * Set up port for drawing Macintosh control.
     */
    macDraw = (MacDrawable *) Tk_WindowId(tkwin);
    destPort = TkMacOSXGetDrawablePort(Tk_WindowId(tkwin));
    portChanged = QDSwapPort(destPort, &savePort);
    TkMacOSXSetUpClippingRgn(Tk_WindowId(tkwin));

a267 1
	WindowRef frontNonFloating;
d269 3
a271 5
	windowRef = GetWindowFromPort(destPort);
	CreateScrollBarControl(windowRef, &r, MIN_SCROLLBAR_VALUE +
		SCROLLBAR_SCALING_VALUE/2, MIN_SCROLLBAR_VALUE,
		SCROLLBAR_SCALING_VALUE, SCROLLBAR_SCALING_VALUE -
		MIN_SCROLLBAR_VALUE, true, NULL, &(macScrollPtr->sbHandle));
d274 1
a274 7
	/*
	 * If we are foremost then make us active.
	 */

	frontNonFloating = ActiveNonFloatingWindow();

	if ((windowRef == FrontWindow()) || TkpIsWindowFloating(windowRef)) {
d286 7
d769 1
a769 1
	int part;
d838 3
a840 1
	    TkMacOSXSetUpClippingRgn(Tk_WindowId(scrollPtr->tkwin));
d849 5
a853 2
	window = Tk_WindowId(scrollPtr->tkwin);
	TkGenerateButtonEventForXPointer(window);
d953 2
a954 1
	if (TkMacOSXResizable(macDraw->toplevel->winPtr)) {
a1023 1
    SetControlViewSize(macScrollPtr->sbHandle, dViewSize);
d1027 1
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d1 1
a1 1
/* 
d4 3
a6 3
 *        This file implements the Macintosh specific portion of the scrollbar
 *        widget.  The Macintosh scrollbar may also draw a windows grow
 *        region under certain cases.
d10 1
d15 1
a15 1
 * RCS: @@(#) $Id: tkMacOSXScrlbr.c,v 1.20 2006/08/24 05:22:27 das Exp $
d22 2
a23 1
#include "tclInt.h" /* for TclServiceIdle() */
d26 1
a26 3
 * The following definitions should really be in MacOS
 * header files.  They are included here as this is the only
 * file that needs the declarations.
a27 1
typedef pascal void (*ThumbActionFunc)(void);
d29 6
a34 7
typedef ThumbActionFunc ThumbActionUPP;

enum {
    uppThumbActionProcInfo = kPascalStackBased
};

#define NewThumbActionProc(userRoutine) ((ThumbActionUPP) (userRoutine))
d37 8
a44 2
 * Minimum slider length, in pixels (designed to make sure that the slider
 * is always easy to grab with the mouse).
d47 3
a49 4
#define MIN_SLIDER_LENGTH       5
#define MIN_SCROLLBAR_VALUE     0
#define SCROLLBAR_SCALING_VALUE     100000
#define SCROLLBAR_SCALING_DVALUE    100000.0
d52 1
a52 1
 * Declaration of Windows specific scrollbar structure.
d54 17
a70 9

typedef struct MacScrollbar {
    TkScrollbar info;            /* Generic scrollbar info */
    ControlRef  sbHandle;        /* Opaque handle to the Scrollbar contol struct */
    int         macFlags;        /* Various flags; see below */
} MacScrollbar;

/* Handle to the Scrollbar control structure */
        
d73 2
a74 18
 * Flag bits for scrollbars on the Mac:
 * 
 * ALREADY_DEAD:                Non-zero means this scrollbar has been
 *                                destroyed, but has not been cleaned up.
 * IN_MODAL_LOOP:                Non-zero means this scrollbar is in the middle
 *                                of a modal loop.
 * ACTIVE:                        Non-zero means this window is currently
 *                                active (in the foreground).
 * FLUSH_TOP:                        Flush with top of Mac window.
 * FLUSH_BOTTOM:                Flush with bottom of Mac window.
 * FLUSH_RIGHT:                        Flush with right of Mac window.
 * FLUSH_LEFT:                        Flush with left of Mac window.
 * SCROLLBAR_GROW:                Non-zero means this window draws the grow
 *                                region for the toplevel window.
 * AUTO_ADJUST:                        Non-zero means we automatically adjust
 *                                the size of the widget to align correctly
 *                                along a Mac window.
 * DRAW_GROW:                        Non-zero means we draw the grow region.
d77 1
a77 10
#define ALREADY_DEAD             1
#define IN_MODAL_LOOP            2
#define ACTIVE                   4
#define FLUSH_TOP                8
#define FLUSH_BOTTOM             16
#define FLUSH_RIGHT              32
#define FLUSH_LEFT               64
#define SCROLLBAR_GROW           128
#define AUTO_ADJUST              256
#define DRAW_GROW                512
a79 13
 * Globals uses locally in this file.
 */
static ControlActionUPP scrollActionProc = NULL; /* Pointer to func. */
static ThumbActionUPP thumbActionProc = NULL;    /* Pointer to func. */
static TkScrollbar *activeScrollPtr = NULL;      /* Non-null when in thumb */
                                                 /* proc. */
static Point mouseDownPoint;	/* Used when activeScrollPtr is non-NULL   */
				/* to store the coordinates where the      */
				/* mouse was first pressed to begin        */
				/* dragging the thumb, because             */
				/* ThumbActionProc can't take any args.    */
						 
/*
d83 9
a91 8
static pascal void ScrollbarActionProc _ANSI_ARGS_((ControlRef theControl, ControlPartCode partCode));
static int         ScrollbarBindProc _ANSI_ARGS_((ClientData clientData,
    Tcl_Interp *interp, XEvent *eventPtr,
    Tk_Window tkwin, KeySym keySym));
static void        ScrollbarEventProc _ANSI_ARGS_(( ClientData clientData, XEvent *eventPtr));
static pascal void ThumbActionProc _ANSI_ARGS_((void));
static void        UpdateControlValues _ANSI_ARGS_((MacScrollbar *macScrollPtr));
                    
d93 1
a93 1
 * The class procedure table for the scrollbar widget.  Leave the proc fields
d99 1
a99 1
    sizeof(Tk_ClassProcs)        /* size */
d101 54
d161 1
a161 1
 *        Allocate a new TkScrollbar structure.
d164 1
a164 1
 *        Returns a newly allocated TkScrollbar structure.
d167 1
a167 1
 *        None.
d174 1
a174 1
    Tk_Window tkwin)        /* New Tk Window. */
d176 1
d179 1
a179 1
    
d181 6
a186 2
        scrollActionProc = NewControlActionUPP (ScrollbarActionProc);
        thumbActionProc = NewThumbActionProc(ThumbActionProc);
a187 1

d191 1
d194 2
a195 2
        StructureNotifyMask|FocusChangeMask,
        ScrollbarEventProc, (ClientData) macScrollPtr);
d198 6
a203 5
        Tcl_SetAssocData(winPtr->mainPtr->interp, "TkScrollbar", NULL, (ClientData)1);
        TkCreateBindingProcedure(winPtr->mainPtr->interp,
            winPtr->mainPtr->bindingTable,
            (ClientData)Tk_GetUid("Scrollbar"), "<ButtonPress>",
            ScrollbarBindProc, NULL, NULL);
d213 3
a215 3
 *        This procedure redraws the contents of a scrollbar window.
 *        It is invoked as a do-when-idle handler, so it only runs
 *        when there's nothing else for the application to do.
d218 1
a218 1
 *        None.
d221 1
a221 1
 *        Information appears on the screen.
d228 1
a228 1
    ClientData clientData)        /* Information about window. */
a232 1
    
d234 2
a235 3
    CGrafPtr saveWorld;
    GDHandle saveDevice;
    GWorldPtr destPort;
d237 1
a237 1
    
d239 1
a239 1
        goto done;
d246 1
a246 1
        GC fgGC, bgGC;
d248 2
a249 2
        bgGC = Tk_GCForColor(scrollPtr->highlightBgColorPtr,
            Tk_WindowId(tkwin));
d251 9
a259 9
        if (scrollPtr->flags & GOT_FOCUS) {
            fgGC = Tk_GCForColor(scrollPtr->highlightColorPtr,
                Tk_WindowId(tkwin));
            TkpDrawHighlightBorder(tkwin, fgGC, bgGC, scrollPtr->highlightWidth,
                Tk_WindowId(tkwin));
        } else {
            TkpDrawHighlightBorder(tkwin, bgGC, bgGC, scrollPtr->highlightWidth,
                Tk_WindowId(tkwin));
        }
d262 4
a265 4
        scrollPtr->highlightWidth, scrollPtr->highlightWidth,
        Tk_Width(tkwin) - 2*scrollPtr->highlightWidth,
        Tk_Height(tkwin) - 2*scrollPtr->highlightWidth,
        scrollPtr->borderWidth, scrollPtr->relief);
d272 1
a272 2
    GetGWorld(&saveWorld, &saveDevice);
    SetGWorld(destPort, NULL);
d276 19
a294 31
        Rect r;
        SInt32 initialValue;
        SInt32 minValue;
        SInt32 maxValue;
        SInt16 procID;
        WindowRef frontNonFloating;
        
        r.left = r.top = 0;
        r.right = r.bottom = 1;

        minValue = MIN_SCROLLBAR_VALUE;
        maxValue = SCROLLBAR_SCALING_VALUE;
        initialValue = (minValue + maxValue)/2;
        procID = kControlScrollBarLiveProc;

        windowRef = GetWindowFromPort(destPort);
        CreateScrollBarControl(windowRef, &r, initialValue,
                                minValue, maxValue,
                                maxValue - minValue, true,
                                NULL, &(macScrollPtr->sbHandle));
        SetControlReference(macScrollPtr->sbHandle, (SInt32) scrollPtr);
        
        /*
         * If we are foremost then make us active.
         */
        
        frontNonFloating = ActiveNonFloatingWindow();
        
        if ((windowRef == FrontWindow()) || TkpIsWindowFloating(windowRef)) {
            macScrollPtr->macFlags |= ACTIVE;
        }
d298 1
a298 1
     * Adjust the control size based on its width...
d301 2
a302 8
    if (macScrollPtr->info.width < 13) {
        SetControlData(macScrollPtr->sbHandle, kControlNoPart, kControlSizeTag,
                sizeof(kControlSizeSmall), (void *) kControlSizeSmall);
    } else {
        SetControlData(macScrollPtr->sbHandle, kControlNoPart, kControlSizeTag,
                sizeof(kControlSizeSmall), (void *) kControlSizeLarge);
    }        
    
d304 2
a305 1
     * Update the control values before we draw.
d307 11
a317 22
    windowRef  = GetControlOwner (macScrollPtr->sbHandle);
    UpdateControlValues(macScrollPtr);
    
    if (macScrollPtr->macFlags & ACTIVE) {
        Draw1Control(macScrollPtr->sbHandle);
        if (macScrollPtr->macFlags & DRAW_GROW) {
            DrawGrowIcon(windowRef);
        }
    } else {
        HiliteControl (macScrollPtr->sbHandle, 255 );
        Draw1Control(macScrollPtr->sbHandle);
        if (macScrollPtr->macFlags & DRAW_GROW) {
            DrawGrowIcon(windowRef);
            Tk_Fill3DRectangle(tkwin, Tk_WindowId(tkwin), scrollPtr->bgBorder,
                Tk_Width(tkwin) - 13, Tk_Height(tkwin) - 13,
                Tk_Width(tkwin), Tk_Height(tkwin),
                0, TK_RELIEF_FLAT);
        }
    }
    
    SetGWorld(saveWorld, saveDevice);
     
d327 3
a329 3
 *        This procedure is called after the generic code has finished
 *        processing configuration options, in order to configure
 *        platform specific options.
d332 1
a332 1
 *        None.
d335 1
a335 1
 *        None.
d342 3
a344 3
    register TkScrollbar *scrollPtr;        /* Information about widget;  may or
                                             * may not already have values for
                                             * some fields. */
d353 3
a355 3
 *        After changes in a scrollbar's size or configuration, this
 *        procedure recomputes various geometry information used in
 *        displaying the scrollbar.
d358 1
a358 1
 *        None.
d361 1
a361 1
 *        The scrollbar will be displayed differently.
d368 2
a369 2
    register TkScrollbar *scrollPtr)        /* Scrollbar whose geometry may
                                             * have changed. */
d371 1
a371 2
    MacScrollbar *macScrollPtr = (MacScrollbar *) scrollPtr;
    int width, fieldLength, adjust = 0;
d374 1
a374 1
        scrollPtr->highlightWidth = 0;
d377 5
a381 3
    width = (scrollPtr->vertical) ? Tk_Width(scrollPtr->tkwin)
            : Tk_Height(scrollPtr->tkwin);
    scrollPtr->arrowLength = width - 2*scrollPtr->inset + 1;
d383 2
a384 2
            : Tk_Width(scrollPtr->tkwin))
            - 2*(scrollPtr->arrowLength + scrollPtr->inset);
d386 1
a386 1
        fieldLength = 0;
d398 1
a398 1
        scrollPtr->sliderFirst = fieldLength - 2*scrollPtr->borderWidth;
d401 1
a401 1
        scrollPtr->sliderFirst = 0;
d403 4
a406 3
    if (scrollPtr->sliderLast < (scrollPtr->sliderFirst
            + MIN_SLIDER_LENGTH)) {
        scrollPtr->sliderLast = scrollPtr->sliderFirst + MIN_SLIDER_LENGTH;
d409 1
a409 1
        scrollPtr->sliderLast = fieldLength;
d411 4
a414 2
    scrollPtr->sliderFirst += scrollPtr->arrowLength + scrollPtr->inset;
    scrollPtr->sliderLast += scrollPtr->arrowLength + scrollPtr->inset;
d419 1
a419 1
     * the whole window, if any).  Then arrange for the window to be
d424 4
a427 8
        if ((macScrollPtr->macFlags & AUTO_ADJUST) &&
            (macScrollPtr->macFlags & (FLUSH_RIGHT|FLUSH_LEFT))) {
            adjust--;
        }
        Tk_GeometryRequest(scrollPtr->tkwin,
            scrollPtr->width + 2*scrollPtr->inset + adjust,
            2*(scrollPtr->arrowLength + scrollPtr->borderWidth
            + scrollPtr->inset));
d429 4
a432 7
        if ((macScrollPtr->macFlags & AUTO_ADJUST) &&
            (macScrollPtr->macFlags & (FLUSH_TOP|FLUSH_BOTTOM))) {
            adjust--;
        }
        Tk_GeometryRequest(scrollPtr->tkwin,
            2*(scrollPtr->arrowLength + scrollPtr->borderWidth
            + scrollPtr->inset), scrollPtr->width + 2*scrollPtr->inset + adjust);
d442 1
a442 1
 *        Free data structures associated with the scrollbar control.
d445 1
a445 1
 *        None.
d448 1
a448 1
 *        None.
d455 1
a455 1
    TkScrollbar *scrollPtr)        /* Scrollbar to destroy. */
d460 4
a463 4
        if (!(macScrollPtr->macFlags & IN_MODAL_LOOP)) {
            DisposeControl(macScrollPtr->sbHandle);
            macScrollPtr->sbHandle = NULL;
        }
d473 2
a474 2
 *        Determine the scrollbar element corresponding to a
 *        given position.
d477 4
a480 4
 *        One of TOP_ARROW, TOP_GAP, etc., indicating which element
 *        of the scrollbar covers the position given by (x, y).  If
 *        (x,y) is outside the scrollbar entirely, then OUTSIDE is
 *        returned.
d483 1
a483 1
 *        None.
d490 3
a492 3
    TkScrollbar *scrollPtr,        /* Scrollbar widget record. */
    int x, int y)                /* Coordinates within scrollPtr's
                                 * window. */
d495 3
a497 2
    GWorldPtr destPort;
    int length, width, tmp, inactive = false;
d499 1
a499 1
    Point where;
a500 15
    int  x0, y0;

    x0 = x;
    y0 = y;

    if (scrollPtr->vertical) {
        length = Tk_Height(scrollPtr->tkwin);
        width = Tk_Width(scrollPtr->tkwin);
    } else {
        tmp = x;
        x = y;
        y = tmp;
        length = Tk_Width(scrollPtr->tkwin);
        width = Tk_Height(scrollPtr->tkwin);
    }
d502 4
a505 3
    if ((x < scrollPtr->inset) || (x >= (width - scrollPtr->inset))
            || (y < scrollPtr->inset) || (y >= (length - scrollPtr->inset))) {
        return OUTSIDE;
d510 1
a510 1
     * DisplayScrollbar.  Be sure to keep the two consistent.  On the 
d517 1
a517 1
    SetGWorld(destPort, NULL);
d519 7
a525 8
    if ( GetControlHilite(macScrollPtr->sbHandle) == 255 ) {
        inactive = true;
        HiliteControl(macScrollPtr->sbHandle, 0 );
    }

    TkMacOSXWinBounds((TkWindow *) scrollPtr->tkwin, &bounds);                
    where.h = x0 + bounds.left;
    where.v = y0 + bounds.top;
d528 4
a531 1
        HiliteControl(macScrollPtr->sbHandle, 255 );
d534 12
a545 12
        case kControlUpButtonPart:
            return TOP_ARROW;
        case kControlPageUpPart:
            return TOP_GAP;
        case kControlIndicatorPart:
            return SLIDER;
        case kControlPageDownPart:
            return BOTTOM_GAP;
        case kControlDownButtonPart:
            return BOTTOM_ARROW;
        default:
            return OUTSIDE;
d554 7
a560 6
 *        Callback procedure used by the Macintosh toolbox call
 *        TrackControl.  This call is used to track the thumb of
 *        the scrollbar.  Unlike the ScrollbarActionProc function
 *        this function is called once and basically takes over
 *        tracking the scrollbar from the control.  This is done
 *        to avoid conflicts with what the control plans to draw.
d563 1
a563 1
 *        None.
d566 1
a566 1
 *        May change the display.
d572 1
a572 1
ThumbActionProc()
d574 3
a576 2
    register TkScrollbar *scrollPtr = activeScrollPtr;
    register MacScrollbar *macScrollPtr = (MacScrollbar *) activeScrollPtr;
d578 3
a580 2
    int origValue;
    double thumbWidth, oldFirstFraction, newFirstFraction, trackBarSize;
d586 2
a587 2
    OSErr err;
    
d589 1
a589 1
        return;
a592 11
    
    /*
     * First compute values that will remain constant during the tracking
     * of the thumb.  The variable trackBarSize is the length of the scrollbar
     * minus the 2 arrows and half the width of the thumb on both sides
     * (3 * arrowLength).  The variable trackBarPin is the lower starting point
     * of the drag region.
     *
     * Note: the arrowLength is equal to the thumb width of a Mac scrollbar.
     */

d595 7
a601 8
    
    thumbWidth = scrollPtr->lastFraction - scrollPtr->firstFraction;
    
    if (scrollPtr->vertical == true) {
        trackBarSize = (double) (trackRect.bottom - trackRect.top
                - (scrollPtr->arrowLength * 3));
        InsetRect(&trackRect, -50, -226);
        
d603 5
a607 3
        trackBarSize = (double) (trackRect.right - trackRect.left
                - (scrollPtr->arrowLength * 3));
        InsetRect(&trackRect, -226, -50);
d611 1
a611 1
     * Track the mouse while the button is held down.  If the mouse is moved,
d613 1
a613 1
     * the scrollbar.  Since the mouse may move a distance too small to
d616 1
a616 1
     * initially pressed.  Otherwise, moving the mouse too slowly will
d623 1
d625 5
a629 10
        err = TrackMouseLocationWithOptions(NULL,
                kTrackMouseLocationOptionDontConsumeMouseUp,
                kEventDurationForever,
                &currentPoint,
                NULL,
                &trackingResult);
            
        if ((err == noErr) 
                && ((trackingResult == kMouseTrackingMouseDragged)
                || (trackingResult == kMouseTrackingMouseMoved))) {
d632 3
a634 3
            * Calculate where the scrollbar should move to, based on
            * where the mouse button was pressed and where the scrollbar
	    * initially was at that time.  Note that PtInRect() will
d637 1
a637 1
            * of the waiting idle events change the port (e.g. with
d640 1
a640 1
            */
d642 9
a650 10
            if (PtInRect(currentPoint, &trackRect)) {
		double pixDiff;
		double fracDelta;
                if (scrollPtr->vertical == true) {
		    pixDiff = (double)(currentPoint.v - mouseDownPoint.v);
                } else {
		    pixDiff = (double)(currentPoint.h - mouseDownPoint.h);
                }
		fracDelta = pixDiff/(trackBarSize);
		newFirstFraction += fracDelta;
d657 1
a657 1
            
d661 1
a661 1
	     * has moved.  Process waiting idle tasks afterward to allow
d665 13
a677 13
            sprintf(valueString, "%g", newFirstFraction);
            Tcl_DStringSetLength(&cmdString, 0);
            Tcl_DStringAppend(&cmdString, scrollPtr->command,
                scrollPtr->commandSize);
            Tcl_DStringAppendElement(&cmdString, "moveto");
            Tcl_DStringAppendElement(&cmdString, valueString);
            interp = scrollPtr->interp;
            Tcl_Preserve((ClientData) interp);
            Tcl_GlobalEval(interp, cmdString.string);
            Tcl_Release((ClientData) interp);

	    TclServiceIdle();
        }
d679 1
a679 1

d689 3
a691 3
 *        Callback procedure used by the Macintosh toolbox call
 *        TrackControl.  This call will update the display while
 *        the scrollbar is being manipulated by the user.
d694 1
a694 1
 *        None.
d697 1
a697 1
 *        May change the display.
d704 2
a705 2
    ControlRef theControl,         /* Handle to scrollbat control */
    ControlPartCode partCode)        /* Part of scrollbar that was "hit" */
d707 3
a709 1
    TkScrollbar *scrollPtr = (TkScrollbar *) GetControlReference(theControl);
d711 1
a711 1
    
d714 1
a714 1
            scrollPtr->commandSize);
d716 20
a735 11
    if ( partCode == kControlUpButtonPart ||
         partCode == kControlDownButtonPart ) {
        Tcl_DStringAppendElement(&cmdString, "scroll");
        Tcl_DStringAppendElement(&cmdString,
                (partCode == kControlUpButtonPart ) ? "-1" : "1");
        Tcl_DStringAppendElement(&cmdString, "unit");
    } else if (partCode == kControlPageUpPart || partCode == kControlPageDownPart ) {
        Tcl_DStringAppendElement(&cmdString, "scroll");
        Tcl_DStringAppendElement(&cmdString,
                (partCode == kControlPageUpPart ) ? "-1" : "1");
        Tcl_DStringAppendElement(&cmdString, "page");
d738 2
a739 3
    Tcl_DStringAppend(&cmdString, "; update idletasks",
        strlen("; update idletasks"));
    Tcl_GlobalEval(scrollPtr->interp, cmdString.string);
a740 1

d742 1
d750 2
a751 2
 *        This procedure is invoked when the default <ButtonPress>
 *        binding on the Scrollbar bind tag fires.
d754 1
a754 1
 *        None.
d757 1
a757 1
 *        The event enters a modal loop.
d764 5
a768 5
    ClientData clientData,        /* Not used. */
    Tcl_Interp *interp,           /* Interp with binding. */
    XEvent *eventPtr,             /* X event that triggered binding. */
    Tk_Window tkwin,              /* Target window for event. */
    KeySym keySym)                /* The KeySym if a key event. */
d776 1
a776 1
    
d781 12
a792 14
        CGrafPtr saveWorld;
        GDHandle saveDevice;
        GWorldPtr destPort;
        Window window;

        /*
         * To call Macintosh control routines we must have the port
         * set to the window containing the control.  We will then test
         * which part of the control was hit and act accordingly.
         */
        destPort = TkMacOSXGetDrawablePort(Tk_WindowId(scrollPtr->tkwin));
        GetGWorld(&saveWorld, &saveDevice);
        SetGWorld(destPort, NULL);
        TkMacOSXSetUpClippingRgn(Tk_WindowId(scrollPtr->tkwin));
d794 1
a794 1
        TkMacOSXWinBounds((TkWindow *) scrollPtr->tkwin, &bounds);                
d797 7
a803 9
        part = TestControl(macScrollPtr->sbHandle, where);
        if (part == kControlIndicatorPart && scrollPtr->jump == false) {
            /*
             * Case 1: In thumb, no jump scrolling.  Call track control
             * with the thumb action proc which will do most of the work.
             * Set the global activeScrollPtr to the current control
             * so the callback may have access to it.
             */
            activeScrollPtr = scrollPtr;
d806 58
a863 59
            part = TrackControl(macScrollPtr->sbHandle, where,
                    (ControlActionUPP) thumbActionProc);
            activeScrollPtr = NULL;
        } else if (part == kControlIndicatorPart) {
            /*
             * Case 2: in thumb with jump scrolling.  Call TrackControl
             * with a NULL action proc.  Use the new value of the control
             * to set update the control.
             */
            part = TrackControl(macScrollPtr->sbHandle, where, NULL);
            if (part == kControlIndicatorPart) {
                    double newFirstFraction, thumbWidth;
                Tcl_DString cmdString;
                char valueString[TCL_DOUBLE_SPACE];

                /*
                 * The following calculation takes the new control
                 * value and maps it to what Tk needs for its variable
                 * thumb size representation.
                 */
                thumbWidth = scrollPtr->lastFraction
                     - scrollPtr->firstFraction;
		 newFirstFraction = (1.0 - thumbWidth) *
		((double) GetControl32BitValue(macScrollPtr->sbHandle) / SCROLLBAR_SCALING_DVALUE);

                sprintf(valueString, "%g", newFirstFraction);

                Tcl_DStringInit(&cmdString);
                Tcl_DStringAppend(&cmdString, scrollPtr->command,
                        strlen(scrollPtr->command));
                Tcl_DStringAppendElement(&cmdString, "moveto");
                Tcl_DStringAppendElement(&cmdString, valueString);
                Tcl_DStringAppend(&cmdString, "; update idletasks",
                        strlen("; update idletasks"));
                
                interp = scrollPtr->interp;
                Tcl_Preserve((ClientData) interp);
                Tcl_GlobalEval(interp, cmdString.string);
                Tcl_Release((ClientData) interp);
                Tcl_DStringFree(&cmdString);                
            }
        } else if (part != 0) {
            /*
             * Case 3: in any other part of the scrollbar.  We call
             * TrackControl with the scrollActionProc which will do
             * most all the work.
             */
            TrackControl(macScrollPtr->sbHandle, where, scrollActionProc);
            HiliteControl(macScrollPtr->sbHandle, 0);
        }
        
        /*
         * The TrackControl call will "eat" the ButtonUp event.  We now
         * generate a ButtonUp event so Tk will unset implicit grabs etc.
         */
        window = Tk_WindowId(scrollPtr->tkwin);
        TkGenerateButtonEventForXPointer(window);

        SetGWorld(saveWorld, saveDevice);
d867 2
a868 2
        DisposeControl(macScrollPtr->sbHandle);
        macScrollPtr->sbHandle = NULL;
d872 1
a872 1
    
d881 2
a882 2
 *        This procedure is invoked by the Tk dispatcher for various
 *        events on scrollbars.
d885 1
a885 1
 *        None.
d888 2
a889 2
 *        When the window gets deleted, internal structures get
 *        cleaned up.  When it gets exposed, it is redisplayed.
d896 2
a897 2
    ClientData clientData,        /* Information about window. */
    XEvent *eventPtr)             /* Information about event. */
d903 1
a903 1
        TkMacOSXSetScrollbarGrow((TkWindow *) scrollPtr->tkwin, false);
d905 2
a906 2
        macScrollPtr->macFlags |= ACTIVE;
        TkScrollbarEventuallyRedraw((ClientData) scrollPtr);
d908 2
a909 2
        macScrollPtr->macFlags &= ~ACTIVE;
        TkScrollbarEventuallyRedraw((ClientData) scrollPtr);
d911 1
a911 1
        TkScrollbarEventProc(clientData, eventPtr);
d920 2
a921 2
 *        This procedure updates the Macintosh scrollbar control
 *        to display the values defined by the Tk scrollbar.
d924 1
a924 1
 *        None.
d927 1
a927 1
 *        The Macintosh control is updated.
d934 1
a934 1
    MacScrollbar *macScrollPtr)                /* Scrollbar data struct. */
a938 1
    WindowRef windowRef  = GetControlOwner(macScrollPtr->sbHandle);
a939 3
    SInt32 viewSize, controlMax, controlValue;
    int flushRight = false;
    int flushBottom = false;
d941 2
a942 9
    UInt8 contrlHilite;

    /*
     * We can't use the Macintosh commands SizeControl and MoveControl as these
     * calls will also cause a redraw which in our case will also cause
     * flicker.  To avoid this we adjust the control record directly.  The
     * Draw1Control command appears to just draw where ever the control says to
     * draw so this seems right.
     */
d949 3
d953 2
a954 7
     * To make Tk applications look more like Macintosh applications without 
     * requiring additional work by the Tk developer we do some cute tricks.
     * The first trick plays with the size of the widget to get it to overlap
     * with the side of the window by one pixel (we don't do this if the placer
     * is the geometry manager).  The second trick shrinks the scrollbar if it
     * it covers the area of the grow region ao the scrollbar can also draw
     * the grow region if need be.
d956 24
a979 3
    if ((macDraw->winPtr->geomMgrPtr != NULL)
	    && !strcmp(macDraw->winPtr->geomMgrPtr->name, "place")) {
        macScrollPtr->macFlags &= ~AUTO_ADJUST;
d981 5
a985 1
        macScrollPtr->macFlags |= AUTO_ADJUST;
d987 7
a993 69
    GetPortBounds ( GetWindowPort ( windowRef ), &portRect );
    if ( portRect.left == contrlRect.left ) {
        if (macScrollPtr->macFlags & AUTO_ADJUST) {
            contrlRect.left--;
        }
        if (!(macScrollPtr->macFlags & FLUSH_LEFT)) {
            macScrollPtr->macFlags |= FLUSH_LEFT;
            if (scrollPtr->vertical) {
                TkpComputeScrollbarGeometry(scrollPtr);
            }
        }
    } else if (macScrollPtr->macFlags & FLUSH_LEFT) {
        macScrollPtr->macFlags &= ~FLUSH_LEFT;
        if (scrollPtr->vertical) {
            TkpComputeScrollbarGeometry(scrollPtr);
        }
    }

    if (portRect.top == contrlRect.top) {
        if (macScrollPtr->macFlags & AUTO_ADJUST) {
            contrlRect.top--;
        }
        if (!(macScrollPtr->macFlags & FLUSH_TOP)) {
            macScrollPtr->macFlags |= FLUSH_TOP;
            if (! scrollPtr->vertical) {
                TkpComputeScrollbarGeometry(scrollPtr);
            }
        }
    } else if (macScrollPtr->macFlags & FLUSH_TOP) {
        macScrollPtr->macFlags &= ~FLUSH_TOP;
        if (! scrollPtr->vertical) {
            TkpComputeScrollbarGeometry(scrollPtr);
        }
    }

    if (portRect.right == contrlRect.right) {
        flushRight = true;
        if (macScrollPtr->macFlags & AUTO_ADJUST) {
            contrlRect.right++;
        }
        if (!(macScrollPtr->macFlags & FLUSH_RIGHT)) {
            macScrollPtr->macFlags |= FLUSH_RIGHT;
            if (scrollPtr->vertical) {
                TkpComputeScrollbarGeometry(scrollPtr);
            }
        }
    } else if (macScrollPtr->macFlags & FLUSH_RIGHT) {
        macScrollPtr->macFlags &= ~FLUSH_RIGHT;
        if (scrollPtr->vertical) {
            TkpComputeScrollbarGeometry(scrollPtr);
        }
    }

    if (portRect.bottom == contrlRect.bottom) {
        flushBottom = true;
        if (macScrollPtr->macFlags & AUTO_ADJUST) {
            contrlRect.bottom++;
        }
        if (!(macScrollPtr->macFlags & FLUSH_BOTTOM)) {
            macScrollPtr->macFlags |= FLUSH_BOTTOM;
            if (! scrollPtr->vertical) {
                TkpComputeScrollbarGeometry(scrollPtr);
            }
        }
    } else if (macScrollPtr->macFlags & FLUSH_BOTTOM) {
        macScrollPtr->macFlags &= ~FLUSH_BOTTOM;
        if (! scrollPtr->vertical) {
            TkpComputeScrollbarGeometry(scrollPtr);
        }
d995 4
d1000 3
a1002 17
    /*
     * If the scrollbar is flush against the bottom right hand corner then
     * it may need to draw the grow region for the window so we let the
     * wm code know about this scrollbar.  We don't actually draw the grow
     * region, however, unless we are currently resizable.
     */
    macScrollPtr->macFlags &= ~DRAW_GROW;
    if (flushBottom && flushRight) {
        TkMacOSXSetScrollbarGrow((TkWindow *) tkwin, true);
        if (TkMacOSXResizable(macDraw->toplevel->winPtr)) {
            if (scrollPtr->vertical) {
                contrlRect.bottom -= 14;
            } else {
                contrlRect.right -= 14;
            }
            macScrollPtr->macFlags |= DRAW_GROW;
        }
d1004 1
a1004 1
        TkMacOSXSetScrollbarGrow((TkWindow *) tkwin, false);
d1017 1
a1017 1
     * location for the Macintosh thumb.  
d1019 3
a1021 3
     * The scrollbar's value is the position of the left (or top) side of 
     * the view area in the content area being scrolled.  
     * The maximum value of the control is therefore the dimension of 
a1025 33
    dViewSize =  (scrollPtr->lastFraction - scrollPtr->firstFraction)
            * SCROLLBAR_SCALING_DVALUE;

    viewSize = (SInt32) dViewSize;
    controlMax = (SInt32) (SCROLLBAR_SCALING_DVALUE - dViewSize);
    controlValue = (SInt32) (SCROLLBAR_SCALING_DVALUE * scrollPtr->firstFraction);

    SetControlViewSize(macScrollPtr->sbHandle,viewSize);
    SetControl32BitMaximum(macScrollPtr->sbHandle, controlMax);

#if 0
    middle = scrollPtr->firstFraction /
	    (1.0 - (scrollPtr->lastFraction - scrollPtr->firstFraction));

    viewSize = (SInt32) ((scrollPtr->lastFraction - scrollPtr->firstFraction) 
            * SCROLLBAR_SCALING_DVALUE
	    / (1.0 - (scrollPtr->lastFraction - scrollPtr->firstFraction)));

    SetControlViewSize(macScrollPtr->sbHandle,viewSize);
    SetControl32BitValue(macScrollPtr->sbHandle,
			 (middle) );
#endif
    contrlHilite = GetControlHilite(macScrollPtr->sbHandle);
    SetControl32BitMinimum(macScrollPtr->sbHandle, 0);
    if ( contrlHilite == 0 || contrlHilite == 255) {
        if (scrollPtr->firstFraction == 0.0 &&
                scrollPtr->lastFraction == 1.0) {
            SetControl32BitMinimum(macScrollPtr->sbHandle, SCROLLBAR_SCALING_VALUE);
        } else {
            HiliteControl(macScrollPtr->sbHandle, 0);
        }
    }
    SetControl32BitValue(macScrollPtr->sbHandle, controlValue);
d1027 21
a1047 2
    if ( !IsControlVisible (macScrollPtr -> sbHandle) ) {
        SetControlVisibility(macScrollPtr->sbHandle,TRUE,FALSE);
d1049 1
@

