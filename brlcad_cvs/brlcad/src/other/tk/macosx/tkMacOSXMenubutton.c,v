head	1.4;
access;
symbols
	rel-7-10-4:1.3
	STABLE:1.3.0.2
	rel-7-10-2:1.3
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.4
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.07.04.17.45;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.20.17.22.25;	author joevalleyfield;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXMenubutton.c --
 *
 *	This file implements the Macintosh specific portion of the
 *	menubutton widget.
 *
 * Copyright (c) 1996 by Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXMenubutton.c,v 1.15 2007/06/29 03:20:02 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkMenu.h"
#include "tkMenubutton.h"
#include "tkMacOSXFont.h"
#include "tkMacOSXDebug.h"

#define kShadowOffset	(3)	/* amount to offset shadow from frame */
#define kTriangleWidth	(11)	/* width of the triangle */
#define kTriangleHeight (6)	/* height of the triangle */
#define kTriangleMargin (5)	/* margin around triangle */

#define TK_POPUP_OFFSET 32	/* size of popup marker */

MODULE_SCOPE int TkMacOSXGetNewMenuID(Tcl_Interp *interp, TkMenu *menuInstPtr,
	int cascade, short *menuIDPtr);
MODULE_SCOPE void TkMacOSXFreeMenuID(short menuID);

typedef struct {
    SInt16 initialValue;
    SInt16 minValue;
    SInt16 maxValue;
    SInt16 procID;
    int isBevel;
} MenuButtonControlParams;

typedef struct {
    int len;
    Str255 title;
    ControlFontStyleRec style;
} ControlTitleParams;

/*
 * Declaration of Mac specific button structure.
 */

typedef struct MacMenuButton {
    TkMenuButton info;		/* Generic button info. */
    WindowRef windowRef;
    ControlRef userPane;
    ControlRef control;
    MenuRef menuRef;
    unsigned long userPaneBackground;
    int flags;
    MenuButtonControlParams params;
    ControlTitleParams titleParams;
    ControlButtonContentInfo bevelButtonContent;
    OpenCPicParams picParams;
} MacMenuButton;

/*
 * Forward declarations for procedures defined later in this file:
 */

static OSStatus SetUserPaneDrawProc(ControlRef control,
	ControlUserPaneDrawProcPtr upp);
static OSStatus SetUserPaneSetUpSpecialBackgroundProc(ControlRef control,
	ControlUserPaneBackgroundProcPtr upp);
static void UserPaneDraw(ControlRef control, ControlPartCode cpc);
static void UserPaneBackgroundProc(ControlHandle,
	ControlBackgroundPtr info);
static int MenuButtonInitControl (MacMenuButton *mbPtr, Rect *paneRect,
	Rect *cntrRect );
static int UpdateControlColors(MacMenuButton *mbPtr);
static void ComputeMenuButtonControlParams(TkMenuButton *mbPtr,
	MenuButtonControlParams * paramsPtr);
static void ComputeControlTitleParams(TkMenuButton *mbPtr,
	ControlTitleParams *paramsPtr);
static void CompareControlTitleParams(ControlTitleParams *p1Ptr,
	ControlTitleParams *p2Ptr, int *titleChanged, int *styleChanged);

/*
 * The structure below defines menubutton class behavior by means of
 * procedures that can be invoked from generic window code.
 */

Tk_ClassProcs tkpMenubuttonClass = {
    sizeof(Tk_ClassProcs),	/* size */
    TkMenuButtonWorldChanged,	/* worldChangedProc */
};


/*
 *----------------------------------------------------------------------
 *
 * TkpCreateMenuButton --
 *
 *	Allocate a new TkMenuButton structure.
 *
 * Results:
 *	Returns a newly allocated TkMenuButton structure.
 *
 * Side effects:
 *	Registers an event handler for the widget.
 *
 *----------------------------------------------------------------------
 */

TkMenuButton *
TkpCreateMenuButton(
    Tk_Window tkwin)
{
    MacMenuButton *mbPtr = (MacMenuButton *) ckalloc(sizeof(MacMenuButton));
    mbPtr->userPaneBackground = PIXEL_MAGIC << 24;
    mbPtr->flags = 0;
    mbPtr->userPane = NULL;
    mbPtr->control = NULL;
    mbPtr->picParams.version = -2;
    mbPtr->picParams.hRes = 0x00480000;
    mbPtr->picParams.vRes = 0x00480000;
    mbPtr->picParams.srcRect.top = 0;
    mbPtr->picParams.srcRect.left = 0;
    mbPtr->picParams.reserved1 = 0;
    mbPtr->picParams.reserved2 = 0;
    mbPtr->bevelButtonContent.contentType = kControlContentPictHandle;
    mbPtr->menuRef = NULL;

    bzero(&mbPtr->params, sizeof(mbPtr->params));
    bzero(&mbPtr->titleParams,sizeof(mbPtr->titleParams));
    return (TkMenuButton *) mbPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDisplayMenuButton --
 *
 *	This procedure is invoked to display a menubutton widget.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menubutton in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

void
TkpDisplayMenuButton(
    ClientData clientData)	/* Information about widget. */
{
    TkMenuButton *butPtr = (TkMenuButton *) clientData;
    Tk_Window tkwin = butPtr->tkwin;
    TkWindow *winPtr;
    Pixmap pixmap;
    MacMenuButton *mbPtr = (MacMenuButton *) butPtr;
    CGrafPtr destPort, savePort;
    Boolean portChanged;
    int hasImageOrBitmap = 0, width, height;
    OSStatus err;
    ControlButtonGraphicAlignment theAlignment;
    Rect paneRect, cntrRect;

    butPtr->flags &= ~REDRAW_PENDING;
    if ((butPtr->tkwin == NULL) || !Tk_IsMapped(tkwin)) {
	return;
    }
    pixmap = (Pixmap) Tk_WindowId(tkwin);
    destPort = TkMacOSXGetDrawablePort(Tk_WindowId(tkwin));
    portChanged = QDSwapPort(destPort, &savePort);
    TkMacOSXSetUpClippingRgn(Tk_WindowId(tkwin));

    winPtr = (TkWindow *)butPtr->tkwin;
    paneRect.left = winPtr->privatePtr->xOff;
    paneRect.top = winPtr->privatePtr->yOff;
    paneRect.right = paneRect.left+Tk_Width(butPtr->tkwin)-1;
    paneRect.bottom = paneRect.top+Tk_Height(butPtr->tkwin)-1;

    cntrRect = paneRect;

    cntrRect.left += butPtr->inset;
    cntrRect.top += butPtr->inset;
    cntrRect.right -= butPtr->inset;
    cntrRect.bottom -= butPtr->inset;

    if (mbPtr->userPane) {
	MenuButtonControlParams params;
	bzero(&params, sizeof(params));
	ComputeMenuButtonControlParams(butPtr, &params );
	if (bcmp(&params,&mbPtr->params,sizeof(params))) {
	    if (mbPtr->userPane) {
		DisposeControl(mbPtr->userPane);
		mbPtr->userPane = NULL;
		mbPtr->control = NULL;
	    }
	}
    }
    if (!mbPtr->userPane) {
	if (MenuButtonInitControl(mbPtr, &paneRect, &cntrRect)) {
	    TkMacOSXDbgMsg("Init Control failed");
	    return;
	}
    }
    SetControlBounds(mbPtr->userPane,&paneRect);
    SetControlBounds(mbPtr->control,&cntrRect);

    /*
     * We need to cache the title and its style
     */

    if (!(mbPtr->flags & 2)) {
	ControlTitleParams titleParams;
	int titleChanged;
	int styleChanged;

	ComputeControlTitleParams(butPtr,&titleParams);
	CompareControlTitleParams(&titleParams,&mbPtr->titleParams,
		&titleChanged,&styleChanged);
	if (titleChanged) {
	    CFStringRef cf = CFStringCreateWithCString(NULL,
		  (char*) titleParams.title, kCFStringEncodingUTF8);

	    if (hasImageOrBitmap) {
		SetControlTitleWithCFString(mbPtr->control, cf);
	    } else {
		SetMenuItemTextWithCFString(mbPtr->menuRef, 1, cf);
	    }
	    CFRelease(cf);
	    bcopy(titleParams.title, mbPtr->titleParams.title,
		    titleParams.len + 1);
	    mbPtr->titleParams.len = titleParams.len;
	}
	if ((titleChanged||styleChanged) && titleParams .len) {
	    if (hasImageOrBitmap) {
		err = ChkErr(SetControlFontStyle, mbPtr->control,
			&titleParams.style);
		if (err != noErr) {
		    return;
		}
	    }
	    bcopy(&titleParams.style, &mbPtr->titleParams.style,
		    sizeof(titleParams.style));
	}
    }
    if (butPtr->image != None) {
	Tk_SizeOfImage(butPtr->image, &width, &height);
	hasImageOrBitmap = 1;
    } else if (butPtr->bitmap != None) {
	Tk_SizeOfBitmap(butPtr->display, butPtr->bitmap, &width, &height);
	hasImageOrBitmap = 1;
    }
    if (hasImageOrBitmap) {
	mbPtr->picParams.srcRect.right = width;
	mbPtr->picParams.srcRect.bottom = height;

	/*
	 * Set the flag to circumvent clipping and bounds problems with OS
	 * 10.0.4
	 */

	tkPictureIsOpen = 1;
	mbPtr->bevelButtonContent.u.picture = OpenCPicture(&mbPtr->picParams);
	if (!mbPtr->bevelButtonContent.u.picture) {
	    TkMacOSXDbgMsg("OpenCPicture failed");
	}

	/*
	 * TO DO - There is one case where XCopyPlane calls CopyDeepMask,
	 * which does not get recorded in the picture. So the bitmap code
	 * will fail in that case.
	 */

	if (butPtr->image != NULL) {
	    Tk_RedrawImage(butPtr->image, 0, 0, width, height, pixmap, 0, 0);
	} else {
	    XCopyPlane(butPtr->display, butPtr->bitmap, pixmap, NULL, 0, 0,
		    width, height, 0, 0, 1);
	}
	ClosePicture();

	tkPictureIsOpen = 0;
	ChkErr(SetControlData, mbPtr->control, kControlButtonPart,
		kControlBevelButtonContentTag,
		sizeof(ControlButtonContentInfo),
		(char *) &mbPtr->bevelButtonContent);
	switch (butPtr->anchor) {
	    case TK_ANCHOR_N:
		theAlignment = kControlBevelButtonAlignTop;
		break;
	    case TK_ANCHOR_NE:
		theAlignment = kControlBevelButtonAlignTopRight;
		break;
	    case TK_ANCHOR_E:
		theAlignment = kControlBevelButtonAlignRight;
		break;
	    case TK_ANCHOR_SE:
		theAlignment = kControlBevelButtonAlignBottomRight;
		break;
	    case TK_ANCHOR_S:
		theAlignment = kControlBevelButtonAlignBottom;
		break;
	    case TK_ANCHOR_SW:
		theAlignment = kControlBevelButtonAlignBottomLeft;
		break;
	    case TK_ANCHOR_W:
		theAlignment = kControlBevelButtonAlignLeft;
		break;
	    case TK_ANCHOR_NW:
		theAlignment = kControlBevelButtonAlignTopLeft;
		break;
	    case TK_ANCHOR_CENTER:
		theAlignment = kControlBevelButtonAlignCenter;
		break;
	}

	ChkErr(SetControlData, mbPtr->control, kControlButtonPart,
		kControlBevelButtonGraphicAlignTag,
		sizeof(ControlButtonGraphicAlignment), (char *) &theAlignment);
    }
    if (butPtr->flags & GOT_FOCUS) {
	HiliteControl(mbPtr->control,kControlButtonPart);
    } else {
	HiliteControl(mbPtr->control,kControlNoPart);
    }
    UpdateControlColors(mbPtr);
    if (mbPtr->flags&2) {
	ShowControl(mbPtr->control);
	ShowControl(mbPtr->userPane);
	mbPtr->flags ^= 2;
    } else {
	Draw1Control(mbPtr->userPane);
	SetControlVisibility(mbPtr->control, true, true);
    }
    if (hasImageOrBitmap) {
	KillPicture(mbPtr->bevelButtonContent.u.picture);
    }
    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDestroyMenuButton --
 *
 *	Free data structures associated with the menubutton control.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Restores the default control state.
 *
 *----------------------------------------------------------------------
 */

void
TkpDestroyMenuButton(
    TkMenuButton *mbPtr)
{
    MacMenuButton *macMbPtr = (MacMenuButton *) mbPtr;

    if (macMbPtr->userPane) {
	DisposeControl(macMbPtr->userPane);
	macMbPtr->userPane = NULL;
    }
    if (macMbPtr->menuRef) {
	short menuID = GetMenuID(macMbPtr->menuRef);

	TkMacOSXFreeMenuID(menuID);
	DisposeMenu(macMbPtr->menuRef);
	macMbPtr->menuRef = NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpComputeMenuButtonGeometry --
 *
 *	After changes in a menu button's text or bitmap, this procedure
 *	recomputes the menu button's geometry and passes this information
 *	along to the geometry manager for the window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The menu button's window may change size.
 *
 *----------------------------------------------------------------------
 */

void
TkpComputeMenuButtonGeometry(mbPtr)
    register TkMenuButton *mbPtr;	/* Widget record for menu button. */
{
    int width, height, mm, pixels;
    int hasImageOrBitmap = 0;

    mbPtr->inset = mbPtr->highlightWidth + mbPtr->borderWidth;
    if (mbPtr->image != None) {
	Tk_SizeOfImage(mbPtr->image, &width, &height);
	if (mbPtr->width > 0) {
	    width = mbPtr->width;
	}
	if (mbPtr->height > 0) {
	    height = mbPtr->height;
	}
	hasImageOrBitmap = 1;
    } else if (mbPtr->bitmap != None) {
	Tk_SizeOfBitmap(mbPtr->display, mbPtr->bitmap, &width, &height);
	if (mbPtr->width > 0) {
	    width = mbPtr->width;
	}
	if (mbPtr->height > 0) {
	    height = mbPtr->height;
	}
	hasImageOrBitmap = 1;
    } else {
	hasImageOrBitmap = 0;
	Tk_FreeTextLayout(mbPtr->textLayout);
	mbPtr->textLayout = Tk_ComputeTextLayout(mbPtr->tkfont, mbPtr->text,
		-1, mbPtr->wrapLength, mbPtr->justify, 0, &mbPtr->textWidth,
		&mbPtr->textHeight);
	width = mbPtr->textWidth;
	height = mbPtr->textHeight;
	if (mbPtr->width > 0) {
	    width = mbPtr->width * Tk_TextWidth(mbPtr->tkfont, "0", 1);
	}
	if (mbPtr->height > 0) {
	    Tk_FontMetrics fm;

	    Tk_GetFontMetrics(mbPtr->tkfont, &fm);
	    height = mbPtr->height * fm.linespace;
	}
	width += 2*mbPtr->padX;
	height += 2*mbPtr->padY;
    }

    if (mbPtr->indicatorOn) {
	mm = WidthMMOfScreen(Tk_Screen(mbPtr->tkwin));
	pixels = WidthOfScreen(Tk_Screen(mbPtr->tkwin));
	mbPtr->indicatorHeight = kTriangleHeight;
	mbPtr->indicatorWidth = kTriangleWidth + kTriangleMargin;
	width += mbPtr->indicatorWidth;
    } else {
	mbPtr->indicatorHeight = 0;
	mbPtr->indicatorWidth = 0;
    }
    if (!hasImageOrBitmap) {
	width += TK_POPUP_OFFSET;
    }

    Tk_GeometryRequest(mbPtr->tkwin, (int) (width + 2*mbPtr->inset),
	    (int) (height + 2*mbPtr->inset));
    Tk_SetInternalBorder(mbPtr->tkwin, mbPtr->inset);
}

/*
 *----------------------------------------------------------------------
 *
 * ComputeMenuButtonControlParams --
 *
 *	This procedure computes the various parameters used
 *	when creating a Carbon control (NewControl)
 *	These are determined by the various tk menu button parameters
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets the control initialisation parameters
 *
 *----------------------------------------------------------------------
 */

static void
ComputeMenuButtonControlParams(
    TkMenuButton *mbPtr,
    MenuButtonControlParams *paramsPtr)
{
    int fakeMenuID = 256;

    /*
     * Determine ProcID based on button type and dimensions
     *
     * We need to set minValue to some non-zero value,
     * Otherwise, the markers do not show up
     */

    paramsPtr->minValue = kControlBehaviorMultiValueMenu;
    paramsPtr->maxValue = 0;
    if (mbPtr->image || mbPtr->bitmap) {
	paramsPtr->isBevel = 1;
	if (mbPtr->borderWidth <= 2) {
	    paramsPtr->procID = kControlBevelButtonSmallBevelProc;
	} else if (mbPtr->borderWidth == 3) {
	    paramsPtr->procID = kControlBevelButtonNormalBevelProc;
	} else {
	    paramsPtr->procID = kControlBevelButtonLargeBevelProc;
	}
	if (mbPtr->indicatorOn) {
	    paramsPtr->initialValue = fakeMenuID;
	} else {
	    paramsPtr->initialValue = 0;
	}
    } else {
	paramsPtr->isBevel = 0;
	paramsPtr->procID = kControlPopupButtonProc
		+ kControlPopupVariableWidthVariant;
	paramsPtr->minValue = -12345;
	paramsPtr->maxValue = -1;
	paramsPtr->initialValue = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * returns 0 if same, 1 otherwise
 *
 *----------------------------------------------------------------------
 */

static void
CompareControlTitleParams(
    ControlTitleParams *p1Ptr,
    ControlTitleParams *p2Ptr,
    int *titleChanged,
    int *styleChanged)
{
    if (p1Ptr->len != p2Ptr->len) {
	*titleChanged = 1;
    } else if (bcmp(p1Ptr->title,p2Ptr->title,p1Ptr->len)) {
	*titleChanged = 1;
    } else {
	*titleChanged = 0;
    }

    if (p1Ptr->len && p2Ptr->len) {
	*styleChanged = bcmp(&p1Ptr->style, &p2Ptr->style,
		sizeof(p2Ptr->style));
    } else {
	*styleChanged = p1Ptr->len||p2Ptr->len;
    }
}

static void
ComputeControlTitleParams(
    TkMenuButton *butPtr,
    ControlTitleParams *paramsPtr)
{
    Tk_Font font;

    paramsPtr->len = TkFontGetFirstTextLayout(butPtr->textLayout, &font,
	    (char*) paramsPtr->title);
    paramsPtr->title[paramsPtr->len] = 0;
    if (paramsPtr->len) {
	TkMacOSXInitControlFontStyle(font,&paramsPtr->style);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * MenuButtonInitControl --
 *
 *	This procedure initialises a Carbon control
 *
 * Results:
 *	0 on success, 1 on failure.
 *
 * Side effects:
 *	A background pane control and the control itself is created
 *	The contol is embedded in the background control
 *	The background control is embedded in the root control
 *	of the containing window
 *	The creation parameters for the control are also computed
 *
 *----------------------------------------------------------------------
 */
int
MenuButtonInitControl(
    MacMenuButton *mbPtr,	/* Mac button. */
    Rect *paneRect,
    Rect *cntrRect)
{
    OSStatus err;
    TkMenuButton *butPtr = (TkMenuButton *) mbPtr;
    SInt16 procID, initialValue, minValue, maxValue;
    Boolean initiallyVisible;
    SInt32 controlReference;
    short menuID;
    ControlRef rootControl =
	    TkMacOSXGetRootControl(Tk_WindowId(butPtr->tkwin));

    mbPtr->windowRef = TkMacOSXDrawableWindow(Tk_WindowId(butPtr->tkwin));

    /*
     * Set up the user pane
     */

    initiallyVisible = false;
    initialValue = kControlSupportsEmbedding | kControlHasSpecialBackground;
    minValue = 0;
    maxValue = 1;
    procID = kControlUserPaneProc;
    controlReference = (SInt32)mbPtr;
    mbPtr->userPane = NewControl(mbPtr->windowRef, paneRect, "\p",
	    initiallyVisible, initialValue, minValue, maxValue, procID,
	    controlReference);
    if (!mbPtr->userPane) {
	TkMacOSXDbgMsg("Failed to create user pane control");
	return 1;
    }
    err = ChkErr(EmbedControl, mbPtr->userPane, rootControl);
    if (err != noErr) {
	return 1;
    }
    SetUserPaneSetUpSpecialBackgroundProc(mbPtr->userPane,
	    UserPaneBackgroundProc);
    SetUserPaneDrawProc(mbPtr->userPane,UserPaneDraw);
    initiallyVisible = false;
    ComputeMenuButtonControlParams(butPtr,&mbPtr->params);

    /*
     * Do this only if we are using bevel buttons.
     */

    ComputeControlTitleParams(butPtr,&mbPtr->titleParams);
    mbPtr->control = NewControl(mbPtr->windowRef,
	    cntrRect, "\p" /* mbPtr->titleParams.title */,
	    initiallyVisible, mbPtr->params.initialValue,
	    mbPtr->params.minValue, mbPtr->params.maxValue,
	    mbPtr->params.procID, controlReference);
    if (!mbPtr->control) {
	TkMacOSXDbgMsg("Failed to create control of type %d",
		mbPtr->params.procID);
	return 1;
    }
    err = ChkErr(EmbedControl, mbPtr->control, mbPtr->userPane);
    if (err != noErr ) {
	return 1;
    }
    if (mbPtr->params.isBevel) {
	CFStringRef cf = CFStringCreateWithCString(NULL,
		(char*) mbPtr->titleParams.title, kCFStringEncodingUTF8);

	SetControlTitleWithCFString(mbPtr->control, cf);
	CFRelease(cf);
	if (mbPtr->titleParams.len) {
	    err = ChkErr(SetControlFontStyle, mbPtr->control,
		    &mbPtr->titleParams.style);
	    if (err != noErr) {
		return 1;
	    }
	}
    } else {
	CFStringRef cfStr;

	err = TkMacOSXGetNewMenuID(mbPtr->info.interp, (TkMenu *) mbPtr, 0,
		&menuID);
	if (err != TCL_OK) {
	    return 1;
	}
	err = ChkErr(CreateNewMenu, menuID, kMenuAttrDoNotUseUserCommandKeys,
		&(mbPtr->menuRef));
	if (err != noErr) {
	    return 1;
	}
	cfStr = CFStringCreateWithCString(NULL, Tk_PathName(mbPtr->info.tkwin),
		kCFStringEncodingUTF8);
	if (!cfStr) {
	    TkMacOSXDbgMsg("CFStringCreateWithCString failed");
	    return 1;
	}
	err = ChkErr(SetMenuTitleWithCFString, mbPtr->menuRef, cfStr);
	CFRelease(cfStr);
	if (err != noErr) {
	    return 1;
	}
	cfStr = CFStringCreateWithCString(NULL,
		(char*) mbPtr->titleParams.title, kCFStringEncodingUTF8);
	AppendMenuItemText(mbPtr->menuRef, "\px");
	if (cfStr) {
	    SetMenuItemTextWithCFString(mbPtr->menuRef, 1, cfStr);
	    CFRelease(cfStr);
	}
	ChkErr(SetControlData, mbPtr->control, kControlNoPart,
		kControlPopupButtonMenuRefTag, sizeof(mbPtr->menuRef),
		&mbPtr->menuRef);
	SetControlMinimum(mbPtr->control, 1);
	SetControlMaximum(mbPtr->control, 1);
	SetControlValue(mbPtr->control, 1);
    }
    mbPtr->flags |= 2;
    return 0;
}

/*
 *--------------------------------------------------------------
 *
 * SetUserPane
 *
 *	Utility function to add a UserPaneDrawProc
 *	to a userPane control. From MoreControls code
 *	from Apple DTS.
 *
 * Results:
 *	MacOS system error.
 *
 * Side effects:
 *	The user pane gets a new UserPaneDrawProc.
 *
 *--------------------------------------------------------------
 */
OSStatus
SetUserPaneDrawProc(
    ControlRef control,
    ControlUserPaneDrawProcPtr upp)
{
    ControlUserPaneDrawUPP myControlUserPaneDrawUPP =
	    NewControlUserPaneDrawUPP(upp);

    return SetControlData(control, kControlNoPart,kControlUserPaneDrawProcTag,
	    sizeof(myControlUserPaneDrawUPP), (Ptr)&myControlUserPaneDrawUPP);
}

/*
 *--------------------------------------------------------------
 *
 * SetUserPaneSetUpSpecialBackgroundProc --
 *
 *	Utility function to add a UserPaneBackgroundProc
 *	to a userPane control
 *
 * Results:
 *	MacOS system error.
 *
 * Side effects:
 *	The user pane gets a new UserPaneBackgroundProc.
 *
 *--------------------------------------------------------------
 */

OSStatus
SetUserPaneSetUpSpecialBackgroundProc(
    ControlRef control,
    ControlUserPaneBackgroundProcPtr upp)
{
    ControlUserPaneBackgroundUPP myControlUserPaneBackgroundUPP =
	    NewControlUserPaneBackgroundUPP(upp);

    return SetControlData(control, kControlNoPart,
	kControlUserPaneBackgroundProcTag,
	sizeof(myControlUserPaneBackgroundUPP),
	(Ptr) &myControlUserPaneBackgroundUPP);
}

/*
 *--------------------------------------------------------------
 *
 * UserPaneDraw --
 *
 *	This function draws the background of the user pane that will
 *	lie under checkboxes and radiobuttons.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The user pane gets updated to the current color.
 *
 *--------------------------------------------------------------
 */

void
UserPaneDraw(
    ControlRef control,
    ControlPartCode cpc)
{
    Rect contrlRect;
    MacMenuButton * mbPtr =
	    (MacMenuButton *)(intptr_t)GetControlReference(control);
    CGrafPtr port;

    GetPort(&port);
    GetControlBounds(control,&contrlRect);
    TkMacOSXSetColorInPort(mbPtr->userPaneBackground, 0, NULL, port);
    EraseRect (&contrlRect);
}

/*
 *--------------------------------------------------------------
 *
 * UserPaneBackgroundProc --
 *
 *	This function sets up the background of the user pane that will
 *	lie under checkboxes and radiobuttons.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The user pane background gets set to the current color.
 *
 *--------------------------------------------------------------
 */

void
UserPaneBackgroundProc(
    ControlHandle control,
    ControlBackgroundPtr info)
{
    MacMenuButton *mbPtr =
	    (MacMenuButton *)(intptr_t)GetControlReference(control);

    if (info->colorDevice) {
	CGrafPtr port;

	GetPort(&port);
	TkMacOSXSetColorInPort(mbPtr->userPaneBackground, 0, NULL, port);
    }
}

/*
 *--------------------------------------------------------------
 *
 * UpdateControlColors --
 *
 *	This function will review the colors used to display
 *	a Macintosh button. If any non-standard colors are
 *	used we create a custom palette for the button, populate
 *	with the colors for the button and install the palette.
 *
 *	Under Appearance, we just set the pointer that will be
 *	used by the UserPaneDrawProc.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The Macintosh control may get a custom palette installed.
 *
 *--------------------------------------------------------------
 */

static int
UpdateControlColors(
    MacMenuButton *mbPtr)
{
    XColor *xcolor;
    TkMenuButton * butPtr = ( TkMenuButton * )mbPtr;

    /*
     * Under Appearance we cannot change the background of the
     * button itself. However, the color we are setting is the color
     * of the containing userPane. This will be the color that peeks
     * around the rounded corners of the button.
     * We make this the highlightbackground rather than the background,
     * because if you color the background of a frame containing a
     * button, you usually also color the highlightbackground as well,
     * or you will get a thin grey ring around the button.
     */

    xcolor = Tk_3DBorderColor(butPtr->normalBorder);
    mbPtr->userPaneBackground = xcolor->pixel;

    return false;
}
@


1.3
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkMacOSXMenubutton.c,v 1.14 2007/04/23 21:24:33 das Exp $
d17 1
a17 1
#include "tkMacOSXInt.h"
d606 1
a606 2
    mbPtr->windowRef = GetWindowFromPort(
	    TkMacOSXGetDrawablePort(Tk_WindowId(butPtr->tkwin)));
d794 1
d796 1
d798 1
a798 1
    TkMacOSXSetColorInPort(mbPtr->userPaneBackground, 0, NULL);
d828 4
a831 1
	TkMacOSXSetColorInPort(mbPtr->userPaneBackground, 0, NULL);
@


1.2
log
@remove dependency on -fpascal-strings when building for aqua
@
text
@d1 1
a1 1
/* 
d4 2
a5 2
 *        This file implements the Macintosh specific portion of the
 *        menubutton widget.
d9 1
d14 1
a14 1
 * RCS: @@(#) $Id: tkMacOSXMenubutton.c,v 1.1 2007/03/02 21:49:55 brlcad Exp $
d23 10
a32 14
#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030
    /* Define constants only available on Mac OS X 10.3 or later */
    #define kMenuAttrDoNotUseUserCommandKeys (1 << 7)
#endif

#define kShadowOffset   (3)     /* amount to offset shadow from frame */
#define kTriangleWidth  (11)    /* width of the triangle */
#define kTriangleHeight (6)     /* height of the triangle */
#define kTriangleMargin (5)     /* margin around triangle */

#define TK_POPUP_OFFSET 32      /* size of popup marker */

MODULE_SCOPE int TkMacOSXGetNewMenuID _ANSI_ARGS_((Tcl_Interp *interp, TkMenu *menuInstPtr, int cascade, short *menuIDPtr));
MODULE_SCOPE void TkMacOSXFreeMenuID _ANSI_ARGS_((short menuID));
d39 1
a39 1
    int    isBevel;
d43 3
a45 3
    int                     len;
    Str255                  title;
    ControlFontStyleRec     style;
d53 9
a61 8
    TkMenuButton info;         /* Generic button info. */
    WindowRef    windowRef;
    ControlRef   userPane;
    ControlRef   control;
    MenuRef      menuRef;
    RGBColor     userPaneBackground;
    MenuButtonControlParams  params;
    ControlTitleParams       titleParams;
d63 1
a63 2
    OpenCPicParams           picParams;
    int                      flags;
d70 4
a73 4
static OSErr SetUserPaneDrawProc(ControlRef control,
        ControlUserPaneDrawProcPtr upp);
static OSErr SetUserPaneSetUpSpecialBackgroundProc(ControlRef control,
        ControlUserPaneBackgroundProcPtr upp);
d76 10
a85 12
        ControlBackgroundPtr info);
static int MenuButtonInitControl ( MacMenuButton *mbPtr, Rect *paneRect, Rect *cntrRect );

static int UpdateControlColors _ANSI_ARGS_((MacMenuButton *mbPtr ));
static void ComputeMenuButtonControlParams _ANSI_ARGS_((TkMenuButton * mbPtr, MenuButtonControlParams * paramsPtr));
static void ComputeControlTitleParams _ANSI_ARGS_((TkMenuButton * mbPtr, ControlTitleParams * paramsPtr));
static void CompareControlTitleParams(
    ControlTitleParams * p1Ptr,
    ControlTitleParams * p2Ptr,
    int * titleChanged,
    int * styleChanged
);
d93 2
a94 2
    sizeof(Tk_ClassProcs),        /* size */
    TkMenuButtonWorldChanged,        /* worldChangedProc */
d96 1
d103 1
a103 1
 *        Allocate a new TkMenuButton structure.
d106 1
a106 1
 *        Returns a newly allocated TkMenuButton structure.
d109 1
a109 1
 *        Registers an event handler for the widget.
d119 1
a119 3
    mbPtr->userPaneBackground.red = 0;
    mbPtr->userPaneBackground.green = 0;
    mbPtr->userPaneBackground.blue = ~0;
d143 1
a143 1
 *        This procedure is invoked to display a menubutton widget.
d146 1
a146 1
 *        None.
d149 2
a150 2
 *        Commands are output to X to display the menubutton in its
 *        current mode.
d157 1
a157 1
    ClientData clientData)        /* Information about widget. */
d161 7
a167 9
    TkWindow *  winPtr;
    Pixmap      pixmap;
    MacMenuButton * mbPtr = (MacMenuButton *) butPtr;
    GWorldPtr dstPort;
    CGrafPtr saveWorld;
    GDHandle saveDevice;
    int      hasImageOrBitmap = 0;
    int      width, height;
    int      err;
a168 1

d173 1
a173 1
        return;
d175 3
a177 4
    pixmap = ( Pixmap )Tk_WindowId(tkwin);
    GetGWorld(&saveWorld, &saveDevice);
    dstPort = TkMacOSXGetDrawablePort(Tk_WindowId(tkwin));
    SetGWorld(dstPort, NULL);
d185 1
a185 1
    
d187 1
a187 1
        
d194 17
a210 19
        MenuButtonControlParams params;
        bzero(&params, sizeof(params));
        ComputeMenuButtonControlParams(butPtr, &params );
        if (bcmp(&params,&mbPtr->params,sizeof(params))) {
            if (mbPtr->userPane) {
                DisposeControl(mbPtr->userPane);
                mbPtr->userPane = NULL;
                mbPtr->control = NULL;
            }
        }
     }
     if (!mbPtr->userPane) {
         if (MenuButtonInitControl(mbPtr,&paneRect,&cntrRect ) ) {
#ifdef TK_MAC_DEBUG
             fprintf(stderr,"Init Control failed\n" );
#endif
             return;
         }
     }
d212 1
a212 1
    SetControlBounds(mbPtr->control,&cntrRect); 
d217 34
a250 32
    if (!(mbPtr->flags&2)) {
        ControlTitleParams titleParams;
        int                titleChanged;
        int                styleChanged;
        ComputeControlTitleParams(butPtr,&titleParams);
        CompareControlTitleParams(&titleParams,&mbPtr->titleParams,
            &titleChanged,&styleChanged);
        if (titleChanged) {
            CFStringRef cf;    	    
            cf = CFStringCreateWithCString(NULL,
                  (char*) titleParams.title, kCFStringEncodingUTF8);
            if (hasImageOrBitmap) {
                SetControlTitleWithCFString(mbPtr->control, cf);
            } else {
                SetMenuItemTextWithCFString(mbPtr->menuRef, 1, cf);
            }
            CFRelease(cf);
            bcopy(titleParams.title,mbPtr->titleParams.title,titleParams.len+1);
            mbPtr->titleParams.len = titleParams.len;
        }
        if ((titleChanged||styleChanged) && titleParams .len) {
            if (hasImageOrBitmap) {
	      err = SetControlFontStyle(mbPtr->control,&titleParams.style);
                if (err !=noErr) {
#ifdef TK_MAC_DEBUG
                    fprintf(stderr,"SetControlFontStyle failed %d\n", err);
#endif
                    return;
                }
            }
            bcopy(&titleParams.style,&mbPtr->titleParams.style,sizeof(titleParams.style));
        }
d253 2
a254 2
        Tk_SizeOfImage(butPtr->image, &width, &height);
        hasImageOrBitmap = 1;
d256 2
a257 2
        Tk_SizeOfBitmap(butPtr->display, butPtr->bitmap, &width, &height);
        hasImageOrBitmap = 1;
d260 66
a325 72
        mbPtr->picParams.srcRect.right = width;
        mbPtr->picParams.srcRect.bottom = height; 
        /* Set the flag to circumvent clipping and bounds problems with OS 10.0.4 */
        tkPictureIsOpen = 1;
        if (!(mbPtr->bevelButtonContent.u.picture = OpenCPicture(&mbPtr->picParams)) ) {
#ifdef TK_MAC_DEBUG
            fprintf(stderr,"OpenCPicture failed\n");
#endif
        }
        /*
         * TO DO - There is one case where XCopyPlane calls CopyDeepMask,
         * which does not get recorded in the picture.  So the bitmap code
         * will fail in that case.
         */
        if (butPtr->image != NULL) {
            Tk_RedrawImage(butPtr->image, 0, 0, width,
                height, pixmap, 0, 0);
        } else {   
            XCopyPlane(butPtr->display, butPtr->bitmap, pixmap, NULL, 0, 0,
                (unsigned int) width, (unsigned int) height, 0, 0, 1);
        }
        ClosePicture();
        
        tkPictureIsOpen = 0;
	err = SetControlData(mbPtr->control, kControlButtonPart,
                    kControlBevelButtonContentTag,
                    sizeof(ControlButtonContentInfo),
			   (char *) &mbPtr->bevelButtonContent);
        if (err != noErr) {
#ifdef TK_MAC_DEBUG
                fprintf(stderr,"SetControlData BevelButtonContent failed, %d\n", err );
#endif
        }
        switch (butPtr->anchor) {
            case TK_ANCHOR_N:
                theAlignment = kControlBevelButtonAlignTop;
                break;
            case TK_ANCHOR_NE:
                theAlignment = kControlBevelButtonAlignTopRight;
                break;
            case TK_ANCHOR_E:
                theAlignment = kControlBevelButtonAlignRight;
                break;
            case TK_ANCHOR_SE:
                theAlignment = kControlBevelButtonAlignBottomRight;
                break;
            case TK_ANCHOR_S:
                theAlignment = kControlBevelButtonAlignBottom;
                break;
            case TK_ANCHOR_SW:
                theAlignment = kControlBevelButtonAlignBottomLeft;
                break;
            case TK_ANCHOR_W:
                theAlignment = kControlBevelButtonAlignLeft;
                break;
            case TK_ANCHOR_NW:
                theAlignment = kControlBevelButtonAlignTopLeft;
                break;
            case TK_ANCHOR_CENTER:
                theAlignment = kControlBevelButtonAlignCenter;
                break;
        }
    
	err = SetControlData(mbPtr->control, kControlButtonPart,
                kControlBevelButtonGraphicAlignTag,
                sizeof(ControlButtonGraphicAlignment),
		(char *) &theAlignment);
        if (err != noErr ) {
#ifdef TK_MAC_DEBUG
            fprintf(stderr,"SetControlData BevelButtonGraphicAlign failed, %d\n", err );
#endif
        }
d328 1
a328 1
        HiliteControl(mbPtr->control,kControlButtonPart);
d330 1
a330 1
        HiliteControl(mbPtr->control,kControlNoPart);
d334 3
a336 3
        ShowControl(mbPtr->control);
        ShowControl(mbPtr->userPane);
        mbPtr->flags ^= 2;
d338 2
a339 2
        Draw1Control(mbPtr->userPane);
        SetControlVisibility(mbPtr->control, true, true);
d342 4
a345 1
        KillPicture(mbPtr->bevelButtonContent.u.picture);
a346 1
    SetGWorld(saveWorld, saveDevice);
d354 1
a354 1
 *        Free data structures associated with the menubutton control.
d357 1
a357 1
 *        None.
d360 1
a360 1
 *        Restores the default control state.
d369 2
a370 1
    MacMenuButton * macMbPtr = (MacMenuButton *)mbPtr;
d372 2
a373 2
        DisposeControl(macMbPtr->userPane);
        macMbPtr->userPane = NULL;
d376 5
a380 5
        short menuID;
        menuID = GetMenuID(macMbPtr->menuRef);
        TkMacOSXFreeMenuID(menuID);
        DisposeMenu(macMbPtr->menuRef);
        macMbPtr->menuRef = NULL;
d389 3
a391 3
 *        After changes in a menu button's text or bitmap, this procedure
 *        recomputes the menu button's geometry and passes this information
 *        along to the geometry manager for the window.
d394 1
a394 1
 *        None.
d397 1
a397 1
 *        The menu button's window may change size.
d404 1
a404 1
    register TkMenuButton *mbPtr;                /* Widget record for menu button. */
d411 8
a418 8
        Tk_SizeOfImage(mbPtr->image, &width, &height);
        if (mbPtr->width > 0) {
            width = mbPtr->width;
        }
        if (mbPtr->height > 0) {
            height = mbPtr->height;
        }
        hasImageOrBitmap = 1;
d420 8
a427 8
        Tk_SizeOfBitmap(mbPtr->display, mbPtr->bitmap, &width, &height);
        if (mbPtr->width > 0) {
            width = mbPtr->width;
        }
        if (mbPtr->height > 0) {
            height = mbPtr->height;
        }
        hasImageOrBitmap = 1;
d429 18
a446 18
        hasImageOrBitmap = 0;
        Tk_FreeTextLayout(mbPtr->textLayout);
        mbPtr->textLayout = Tk_ComputeTextLayout(mbPtr->tkfont, mbPtr->text,
                -1, mbPtr->wrapLength, mbPtr->justify, 0, &mbPtr->textWidth,
                &mbPtr->textHeight);
        width = mbPtr->textWidth;
        height = mbPtr->textHeight;
        if (mbPtr->width > 0) {
            width = mbPtr->width * Tk_TextWidth(mbPtr->tkfont, "0", 1);
        }
        if (mbPtr->height > 0) {
            Tk_FontMetrics fm;

            Tk_GetFontMetrics(mbPtr->tkfont, &fm);
            height = mbPtr->height * fm.linespace;
        }
        width += 2*mbPtr->padX;
        height += 2*mbPtr->padY;
d450 5
a454 5
        mm = WidthMMOfScreen(Tk_Screen(mbPtr->tkwin));
        pixels = WidthOfScreen(Tk_Screen(mbPtr->tkwin));
        mbPtr->indicatorHeight = kTriangleHeight;
        mbPtr->indicatorWidth = kTriangleWidth + kTriangleMargin;
        width += mbPtr->indicatorWidth;
d456 2
a457 2
        mbPtr->indicatorHeight = 0;
        mbPtr->indicatorWidth = 0;
d460 1
a460 1
        width += TK_POPUP_OFFSET;
d464 1
a464 1
            (int) (height + 2*mbPtr->inset));
d473 3
a475 3
 *        This procedure computes the various parameters used
 *        when creating a Carbon control (NewControl)
 *      These are determined by the various tk menu button parameters
d478 1
a478 1
 *        None.
d481 1
a481 1
 *        Sets the control initialisation parameters
d487 3
a489 2
ComputeMenuButtonControlParams(TkMenuButton * mbPtr, 
        MenuButtonControlParams * paramsPtr )
d493 1
a493 1
    /* 
d503 13
a515 13
        paramsPtr->isBevel = 1;
        if (mbPtr->borderWidth <= 2) {
            paramsPtr->procID = kControlBevelButtonSmallBevelProc;
        } else if (mbPtr->borderWidth == 3) {
            paramsPtr->procID = kControlBevelButtonNormalBevelProc;
        } else {
            paramsPtr->procID = kControlBevelButtonLargeBevelProc;
        }
        if (mbPtr->indicatorOn) {
            paramsPtr->initialValue = fakeMenuID;
        } else {
            paramsPtr->initialValue = 0;
        }
d517 6
a522 6
        paramsPtr->isBevel = 0;
        paramsPtr->procID = kControlPopupButtonProc
                + kControlPopupVariableWidthVariant;
        paramsPtr->minValue = -12345;
        paramsPtr->maxValue = -1;
        paramsPtr->initialValue = 0;
d530 1
d533 1
d535 5
a539 6
CompareControlTitleParams( 
    ControlTitleParams * p1Ptr,
    ControlTitleParams * p2Ptr,
    int * titleChanged,
    int * styleChanged
)
d542 3
a544 1
         *titleChanged = 1;
d546 1
a546 5
        if (bcmp(p1Ptr->title,p2Ptr->title,p1Ptr->len)) {
            *titleChanged = 1;
        } else {
            *titleChanged = 0;
        }
d548 1
d550 2
a551 1
        *styleChanged = bcmp(&p1Ptr->style, &p2Ptr->style, sizeof(p2Ptr->style));
d553 1
a553 1
        *styleChanged = p1Ptr->len||p2Ptr->len;
d556 1
a556 1

d558 3
a560 1
ComputeControlTitleParams(TkMenuButton * butPtr, ControlTitleParams * paramsPtr )
d563 4
a566 2
    paramsPtr->len =TkFontGetFirstTextLayout(butPtr->textLayout,&font, (char*) paramsPtr->title);
    paramsPtr->title [paramsPtr->len] = 0;
d568 1
a568 1
        TkMacOSXInitControlFontStyle(font,&paramsPtr->style);
a570 1

d577 1
a577 1
 *        This procedure initialises a Carbon control
d580 1
a580 1
 *        0 on success, 1 on failure.
d583 5
a587 5
 *        A background pane control and the control itself is created
 *      The contol is embedded in the background control
 *      The background control is embedded in the root control
 *      of the containing window
 *      The creation parameters for the control are also computed
d592 18
a609 20
MenuButtonInitControl (
    MacMenuButton *mbPtr,                /* Mac button. */
    Rect      *paneRect,
    Rect      *cntrRect
)
{
    OSStatus   err;
    TkMenuButton * butPtr = ( TkMenuButton * )mbPtr;
    ControlRef rootControl;
    SInt16     procID;
    Boolean    initiallyVisible;
    SInt16     initialValue;
    SInt16     minValue;
    SInt16     maxValue;
    SInt32     controlReference;
    short      menuID;

    rootControl = TkMacOSXGetRootControl(Tk_WindowId(butPtr->tkwin));
    mbPtr->windowRef = GetWindowFromPort(TkMacOSXGetDrawablePort(Tk_WindowId(butPtr->tkwin)));
    /* 
d612 1
d614 1
a614 2
    initialValue = kControlSupportsEmbedding|
            kControlHasSpecialBackground;
d619 3
a621 8
    mbPtr->userPane = NewControl(mbPtr->windowRef,
            paneRect, "\0",
            initiallyVisible,
            initialValue,
            minValue,
            maxValue,
            procID,
            controlReference );
d623 2
a624 4
#ifdef TK_MAC_DEBUG
        fprintf(stderr,"Failed to create user pane control\n");
#endif
        return 1;
d626 1
a626 1
    err = EmbedControl(mbPtr->userPane,rootControl);
d628 1
a628 4
#ifdef TK_MAC_DEBUG
        fprintf(stderr,"Failed to embed user pane control %d\n", (int) err);
#endif
        return 1;
d631 1
a631 1
        UserPaneBackgroundProc);
d635 5
a639 1
    /* Do this only if we are using bevel buttons */
d642 4
a645 7
        cntrRect, "\0", //mbPtr->titleParams.title,
        initiallyVisible,
        mbPtr->params.initialValue,
        mbPtr->params.minValue,
        mbPtr->params.maxValue,
        mbPtr->params.procID,
        controlReference );
d647 3
a649 4
#ifdef TK_MAC_DEBUG
        fprintf(stderr,"failed to create control of type %d : line %d\n",mbPtr->params.procID, __LINE__);
#endif
        return 1;
d651 1
a651 1
    err = EmbedControl(mbPtr->control,mbPtr->userPane);
d653 1
a653 4
#ifdef TK_MAC_DEBUG
        fprintf(stderr,"failed to embed control of type %d,%d\n",procID, (int) err);
#endif
        return 1;
d656 12
a667 14
            CFStringRef cf;    	    
            cf = CFStringCreateWithCString(NULL,
                  (char*) mbPtr->titleParams.title, kCFStringEncodingUTF8);
        SetControlTitleWithCFString(mbPtr->control, cf);
        CFRelease(cf);
        if (mbPtr->titleParams.len) {
	  err = SetControlFontStyle(mbPtr->control,&mbPtr->titleParams.style);
            if (err !=noErr) {
#ifdef TK_MAC_DEBUG
                fprintf(stderr,"SetControlFontStyle failed %d\n", (int) err);
#endif
                return 1;
             }
        }
d669 36
a704 43
        CFStringRef cfStr;
        err = TkMacOSXGetNewMenuID(mbPtr->info.interp, (TkMenu *)mbPtr, 0, &menuID);
        if (err != TCL_OK) {
            return 1;
        }       
        err = CreateNewMenu(menuID, kMenuAttrDoNotUseUserCommandKeys,
                &(mbPtr->menuRef));
        if (err != noErr) {
#ifdef TK_MAC_DEBUG
            fprintf(stderr,"CreateNewMenu failed, %d.\n", (int) err);
#endif
            return 1;
        }
        cfStr = CFStringCreateWithCString(NULL, Tk_PathName(mbPtr->info.tkwin),
                kCFStringEncodingUTF8);
        if (!cfStr) {
#ifdef TK_MAC_DEBUG
            fprintf(stderr,"CFStringCreateWithCString failed.\n");
#endif
            return 1;
        }
        err = SetMenuTitleWithCFString(mbPtr->menuRef, cfStr);
        CFRelease(cfStr);
        if (err != noErr) {
#ifdef TK_MAC_DEBUG
            fprintf(stderr,"SetMenuTitleWithCFString failed, %d.\n", (int) err);
#endif
            return 1;
        }
        cfStr = CFStringCreateWithCString(NULL,
                (char*) mbPtr->titleParams.title, kCFStringEncodingUTF8);
	AppendMenuItemTextWithCFString(mbPtr->menuRef, CFSTR("x"), 0, 0, 0);
        if (cfStr) {
            SetMenuItemTextWithCFString(mbPtr->menuRef, 1, cfStr);
            CFRelease(cfStr);
        }
        err = SetControlData(mbPtr->control,
                kControlNoPart,
                kControlPopupButtonMenuRefTag,
                sizeof(mbPtr->menuRef), &mbPtr->menuRef);
        SetControlMinimum(mbPtr->control, 1);
        SetControlMaximum(mbPtr->control, 1);
        SetControlValue(mbPtr->control, 1);
d715 3
a717 3
 *        Utility function to add a UserPaneDrawProc
 *        to a userPane control.        From MoreControls code
 *        from Apple DTS.
d720 1
a720 1
 *        MacOS system error.
d723 1
a723 1
 *        The user pane gets a new UserPaneDrawProc.
d727 2
a728 1
OSErr SetUserPaneDrawProc (
d732 5
a736 6
    ControlUserPaneDrawUPP myControlUserPaneDrawUPP;
    myControlUserPaneDrawUPP = NewControlUserPaneDrawUPP(upp);        
    return SetControlData (control, 
            kControlNoPart, kControlUserPaneDrawProcTag, 
            sizeof(myControlUserPaneDrawUPP), 
            (Ptr) &myControlUserPaneDrawUPP);
d744 2
a745 2
 *        Utility function to add a UserPaneBackgroundProc
 *        to a userPane control
d748 1
a748 1
 *        MacOS system error.
d751 1
a751 1
 *        The user pane gets a new UserPaneBackgroundProc.
d755 2
a756 1
OSErr
d758 1
a758 1
    ControlRef control, 
d761 7
a767 6
    ControlUserPaneBackgroundUPP myControlUserPaneBackgroundUPP;
    myControlUserPaneBackgroundUPP = NewControlUserPaneBackgroundUPP(upp);
    return SetControlData (control, kControlNoPart, 
        kControlUserPaneBackgroundProcTag, 
        sizeof(myControlUserPaneBackgroundUPP), 
        (Ptr) &myControlUserPaneBackgroundUPP);
d775 2
a776 2
 *        This function draws the background of the user pane that will 
 *        lie under checkboxes and radiobuttons.
d779 1
a779 1
 *        None.
d782 1
a782 1
 *        The user pane gets updated to the current color.
d786 1
d793 3
a795 2
    MacMenuButton * mbPtr;
    mbPtr = ( MacMenuButton *)GetControlReference(control);
d797 1
a797 1
    RGBBackColor (&mbPtr->userPaneBackground);
d806 2
a807 2
 *        This function sets up the background of the user pane that will 
 *        lie under checkboxes and radiobuttons.
d810 1
a810 1
 *        None.
d813 1
a813 1
 *        The user pane background gets set to the current color.
d823 3
a825 2
    MacMenuButton * mbPtr;
    mbPtr = (MacMenuButton *)GetControlReference(control);
d827 1
a827 1
        RGBBackColor (&mbPtr->userPaneBackground);
d831 1
a831 1
/*   
d833 1
a833 1
 *  
d835 9
a843 9
 *      
 *      This function will review the colors used to display
 *      a Macintosh button.  If any non-standard colors are
 *      used we create a custom palette for the button, populate
 *      with the colors for the button and install the palette.
 *   
 *      Under Appearance, we just set the pointer that will be
 *      used by the UserPaneDrawProc.
 *      
d845 2
a846 2
 *      None.
 *  
d848 1
a848 1
 *      The Macintosh control may get a custom palette installed.
d854 2
a855 1
UpdateControlColors(MacMenuButton * mbPtr)
d859 1
a859 1
   
d862 2
a863 2
     * button itself.  However, the color we are setting is the color
     *  of the containing userPane.  This will be the color that peeks
d872 2
a873 2
    TkSetMacColor(xcolor->pixel, &mbPtr->userPaneBackground);
   
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXMenubutton.c,v 1.11 2006/07/20 06:25:19 das Exp $
d630 1
a630 1
            paneRect, "\p",
d658 1
a658 1
        cntrRect, "\p", //mbPtr->titleParams.title,
d725 1
a725 1
        AppendMenuItemText(mbPtr->menuRef, "\px");
@

