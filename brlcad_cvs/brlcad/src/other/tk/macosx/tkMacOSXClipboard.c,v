head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.49;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.45;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXClipboard.c --
 *
 *	This file manages the clipboard for the Tk toolkit.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXClipboard.c,v 1.11 2007/06/29 03:20:00 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkSelect.h"


/*
 *----------------------------------------------------------------------
 *
 * TkSelGetSelection --
 *
 *	Retrieve the specified selection from another process. For
 *	now, only fetching XA_STRING from CLIPBOARD is supported.
 *	Eventually other types should be allowed.
 *
 * Results:
 *	The return value is a standard Tcl return value.
 *	If an error occurs (such as no selection exists)
 *	then an error message is left in the interp's result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkSelGetSelection(
    Tcl_Interp *interp,		/* Interpreter to use for reporting errors. */
    Tk_Window tkwin,		/* Window on whose behalf to retrieve the
				 * selection (determines display from which to
				 * retrieve). */
    Atom selection,		/* Selection to retrieve. */
    Atom target,		/* Desired form in which selection is to be
				 * returned. */
    Tk_GetSelProc *proc,	/* Procedure to call to process the selection,
				 * once it has been retrieved. */
    ClientData clientData)	/* Arbitrary value to pass to proc. */
{
    int result;
    OSStatus err;
    long length;
    ScrapRef scrapRef;
    char *buf;

    if ((selection == Tk_InternAtom(tkwin, "CLIPBOARD"))
	    && (target == XA_STRING)) {
	/*
	 * Get the scrap from the Macintosh global clipboard.
	 */

	err = ChkErr(GetCurrentScrap, &scrapRef);
	if (err != noErr) {
	    Tcl_AppendResult(interp, Tk_GetAtomName(tkwin, selection),
		    " GetCurrentScrap failed.", NULL);
	    return TCL_ERROR;
	}

	/*
	 * Try UNICODE first
	 */
	err = ChkErr(GetScrapFlavorSize, scrapRef, kScrapFlavorTypeUnicode,
		&length);
	if (err == noErr && length > 0) {
	    Tcl_DString ds;
	    char *data;

	    buf = (char *) ckalloc(length + 2);
	    buf[length] = 0;
	    buf[length+1] = 0; /* 2-byte unicode null */
	    err = ChkErr(GetScrapFlavorData, scrapRef, kScrapFlavorTypeUnicode,
		    &length, buf);
	    if (err == noErr) {
		Tcl_DStringInit(&ds);
		Tcl_UniCharToUtfDString((Tcl_UniChar *)buf,
			Tcl_UniCharLen((Tcl_UniChar *)buf), &ds);
		for (data = Tcl_DStringValue(&ds); *data != '\0'; data++) {
		    if (*data == '\r') {
			*data = '\n';
		    }
		}
		result = (*proc)(clientData, interp, Tcl_DStringValue(&ds));
		Tcl_DStringFree(&ds);
		ckfree(buf);
		return result;
	    }
	}

	err = ChkErr(GetScrapFlavorSize, scrapRef, 'TEXT', &length);
	if (err != noErr) {
	    Tcl_AppendResult(interp, Tk_GetAtomName(tkwin, selection),
		    " GetScrapFlavorSize failed.", NULL);
	    return TCL_ERROR;
	}
	if (length > 0) {
	    Tcl_DString encodedText;
	    char *data;

	    buf = (char *) ckalloc(length + 1);
	    buf[length] = 0;
	    err = ChkErr(GetScrapFlavorData, scrapRef, 'TEXT', &length, buf);
	    if (err != noErr) {
		    Tcl_AppendResult(interp, Tk_GetAtomName(tkwin, selection),
			" GetScrapFlavorData failed.", NULL);
		    return TCL_ERROR;
	    }

	    /*
	     * Tcl expects '\n' not '\r' as the line break character.
	     */

	    for (data = buf; *data != '\0'; data++) {
		if (*data == '\r') {
		    *data = '\n';
		}
	    }

	    Tcl_ExternalToUtfDString(TkMacOSXCarbonEncoding, buf, length,
		    &encodedText);
	    result = (*proc)(clientData, interp,
		    Tcl_DStringValue(&encodedText));
	    Tcl_DStringFree(&encodedText);

	    ckfree(buf);
	    return result;
	}
    }

    Tcl_AppendResult(interp, Tk_GetAtomName(tkwin, selection),
	    " selection doesn't exist or form \"",
	    Tk_GetAtomName(tkwin, target), "\" not defined", NULL);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * TkSetSelectionOwner --
 *
 *	This function claims ownership of the specified selection.
 *	If the selection is CLIPBOARD, then we empty the system
 *	clipboard.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
XSetSelectionOwner(
    Display *display,		/* X Display. */
    Atom selection,		/* What selection to own. */
    Window owner,		/* Window to be the owner. */
    Time time)			/* The current time? */
{
    Tk_Window tkwin;
    TkDisplay *dispPtr;

    /*
     * This is a gross hack because the Tk_InternAtom interface is broken.
     * It expects a Tk_Window, even though it only needs a Tk_Display.
     */

    tkwin = (Tk_Window) TkGetMainInfoList()->winPtr;

    if (selection == Tk_InternAtom(tkwin, "CLIPBOARD")) {
	/*
	 * Only claim and empty the clipboard if we aren't already the
	 * owner of the clipboard.
	 */

	dispPtr = TkGetMainInfoList()->winPtr->dispPtr;
	if (dispPtr->clipboardActive) {
	    return;
	}
	ClearCurrentScrap();
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkSelUpdateClipboard --
 *
 *	This function is called to force the clipboard to be updated
 *	after new data is added. On the Mac we don't need to do
 *	anything.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkSelUpdateClipboard(
    TkWindow *winPtr,		/* Window associated with clipboard. */
    TkClipboardTarget *targetPtr)
				/* Info about the content. */
{
}

/*
 *--------------------------------------------------------------
 *
 * TkSelEventProc --
 *
 *	This procedure is invoked whenever a selection-related
 *	event occurs.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Lots: depends on the type of event.
 *
 *--------------------------------------------------------------
 */

void
TkSelEventProc(
    Tk_Window tkwin,		/* Window for which event was targeted. */
    register XEvent *eventPtr)	/* X event: either SelectionClear,
				 * SelectionRequest, or SelectionNotify. */
{
    if (eventPtr->type == SelectionClear) {
	TkSelClearSelection(tkwin, eventPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkSelPropProc --
 *
 *	This procedure is invoked when property-change events
 *	occur on windows not known to the toolkit. This is a stub
 *	function under Windows.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkSelPropProc(
    register XEvent *eventPtr)	/* X PropertyChange event. */
{
}

/*
 *----------------------------------------------------------------------
 *
 * TkSuspendClipboard --
 *
 *	Handle clipboard conversion as required by the suppend event.
 *	This function is also called on exit.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The local scrap is moved to the global scrap.
 *
 *----------------------------------------------------------------------
 */

void
TkSuspendClipboard(void)
{
    TkClipboardTarget *targetPtr;
    TkClipboardBuffer *cbPtr;
    TkDisplay *dispPtr;
    char *buffer, *p, *endPtr, *buffPtr;
    long length;
    ScrapRef scrapRef;

    dispPtr = TkGetDisplayList();
    if ((dispPtr == NULL) || !dispPtr->clipboardActive) {
	return;
    }

    for (targetPtr = dispPtr->clipTargetPtr; targetPtr != NULL;
	    targetPtr = targetPtr->nextPtr) {
	if (targetPtr->type == XA_STRING) {
	    break;
	}
    }
    if (targetPtr != NULL) {
	Tcl_DString encodedText, unicodedText;

	length = 0;
	for (cbPtr = targetPtr->firstBufferPtr; cbPtr != NULL;
		cbPtr = cbPtr->nextPtr) {
	    length += cbPtr->length;
	}

	buffer = ckalloc(length);
	buffPtr = buffer;
	for (cbPtr = targetPtr->firstBufferPtr; cbPtr != NULL;
		cbPtr = cbPtr->nextPtr) {
	    for (p = cbPtr->buffer, endPtr = p + cbPtr->length;
		    p < endPtr; p++) {
		if (*p == '\n') {
		    *buffPtr++ = '\r';
		} else {
		    *buffPtr++ = *p;
		}
	    }
	}

	ClearCurrentScrap();
	GetCurrentScrap(&scrapRef);
	Tcl_UtfToExternalDString(TkMacOSXCarbonEncoding, buffer, length,
		&encodedText);
	PutScrapFlavor(scrapRef, 'TEXT', 0, Tcl_DStringLength(&encodedText),
		Tcl_DStringValue(&encodedText));
	Tcl_DStringFree(&encodedText);

	/*
	 * Also put unicode data on scrap.
	 */

	Tcl_DStringInit(&unicodedText);
	Tcl_UtfToUniCharDString(buffer, length, &unicodedText);
	PutScrapFlavor(scrapRef, kScrapFlavorTypeUnicode, 0,
		Tcl_DStringLength(&unicodedText),
		Tcl_DStringValue(&unicodedText));
	Tcl_DStringFree(&unicodedText);

	ckfree(buffer);
    }

    /*
     * The system now owns the scrap. We tell Tk that it has
     * lost the selection so that it will look for it the next time
     * it needs it. (Window list NULL if quiting.)
     */

    if (TkGetMainInfoList() != NULL) {
	Tk_ClearSelection((Tk_Window) TkGetMainInfoList()->winPtr,
		Tk_InternAtom((Tk_Window) TkGetMainInfoList()->winPtr,
		"CLIPBOARD"));
    }

    return;
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXClipboard.c,v 1.10 2007/04/23 21:24:33 das Exp $
d16 1
a16 1
#include "tkMacOSXInt.h"
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d4 1
a4 1
 *         This file manages the clipboard for the Tk toolkit.
d8 1
d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXClipboard.c,v 1.6 2006/03/24 14:58:01 das Exp $
d19 1
a19 1

d25 4
a28 4
 *        Retrieve the specified selection from another process.  For
 *        now, only fetching XA_STRING from CLIPBOARD is supported.
 *        Eventually other types should be allowed.
 * 
d30 3
a32 3
 *        The return value is a standard Tcl return value.
 *        If an error occurs (such as no selection exists)
 *        then an error message is left in the interp's result.
d35 1
a35 1
 *        None.
d42 10
a51 11
    Tcl_Interp *interp,                /* Interpreter to use for reporting
                                 * errors. */
    Tk_Window tkwin,                /* Window on whose behalf to retrieve
                                 * the selection (determines display
                                 * from which to retrieve). */
    Atom selection,                /* Selection to retrieve. */
    Atom target,                /* Desired form in which selection
                                 * is to be returned. */
    Tk_GetSelProc *proc,        /* Procedure to call to process the
                                 * selection, once it has been retrieved. */
    ClientData clientData)        /* Arbitrary value to pass to proc. */
d54 1
a54 1
    int err;
d57 1
a57 1
    char * buf;
d60 11
a70 11
            && (target == XA_STRING)) {
        /* 
         * Get the scrap from the Macintosh global clipboard.
         */
         
        err = GetCurrentScrap(&scrapRef);
        if (err != noErr) {
            Tcl_AppendResult(interp, Tk_GetAtomName(tkwin, selection),
                " GetCurrentScrap failed.", (char *) NULL);
            return TCL_ERROR;
        }
d75 3
a77 2
        err = GetScrapFlavorSize(scrapRef, kScrapFlavorTypeUnicode, &length);
        if (err == noErr && length > 0) {
d84 1
a84 1
	    err = GetScrapFlavorData(scrapRef, kScrapFlavorTypeUnicode,
d102 9
a110 9
        err = GetScrapFlavorSize(scrapRef, 'TEXT', &length);
        if (err != noErr) {
            Tcl_AppendResult(interp, Tk_GetAtomName(tkwin, selection),
                " GetScrapFlavorSize failed.", (char *) NULL);
            return TCL_ERROR;
        }
        if (length > 0) {
            Tcl_DString encodedText;
            char *data;
d112 1
a112 1
            buf = (char *) ckalloc(length + 1);
d114 26
a139 26
	    err = GetScrapFlavorData(scrapRef, 'TEXT', &length, buf);
            if (err != noErr) {
                    Tcl_AppendResult(interp, Tk_GetAtomName(tkwin, selection),
                        " GetScrapFlavorData failed.", (char *) NULL);
                    return TCL_ERROR;
            }
            
            /* 
             * Tcl expects '\n' not '\r' as the line break character.
             */

            for (data = buf; *data != '\0'; data++) {
                if (*data == '\r') {
                    *data = '\n';
                }
            }
            
            Tcl_ExternalToUtfDString(TkMacOSXCarbonEncoding, buf, length, 
				     &encodedText);
            result = (*proc)(clientData, interp,
                    Tcl_DStringValue(&encodedText));
            Tcl_DStringFree(&encodedText);

            ckfree(buf);
            return result;
        }
d141 1
a141 1
    
d143 2
a144 2
        " selection doesn't exist or form \"", Tk_GetAtomName(tkwin, target),
        "\" not defined", (char *) NULL);
d153 3
a155 3
 *        This function claims ownership of the specified selection.
 *        If the selection is CLIPBOARD, then we empty the system
 *        clipboard.
d158 1
a158 1
 *        None.
d161 1
a161 1
 *        None.
d168 4
a171 4
    Display* display,        /* X Display. */
    Atom selection,        /* What selection to own. */
    Window owner,        /* Window to be the owner. */
    Time time)                /* The current time? */
d184 4
d189 5
a193 10
        /*
         * Only claim and empty the clipboard if we aren't already the
         * owner of the clipboard.
         */

        dispPtr = TkGetMainInfoList()->winPtr->dispPtr;
        if (dispPtr->clipboardActive) {
            return;
        }
        ClearCurrentScrap();
d202 3
a204 3
 *        This function is called to force the clipboard to be updated
 *        after new data is added.  On the Mac we don't need to do
 *        anything.
d207 1
a207 1
 *        None.
d210 1
a210 1
 *        None.
d217 3
a219 2
    TkWindow *winPtr,                        /* Window associated with clipboard. */
    TkClipboardTarget *targetPtr)        /* Info about the content. */
d228 2
a229 2
 *        This procedure is invoked whenever a selection-related
 *        event occurs. 
d232 1
a232 1
 *        None.
d235 1
a235 1
 *        Lots:  depends on the type of event.
d242 3
a244 5
    Tk_Window tkwin,                /* Window for which event was
                                 * targeted. */
    register XEvent *eventPtr)        /* X event:  either SelectionClear,
                                 * SelectionRequest, or
                                 * SelectionNotify. */
d247 1
a247 1
        TkSelClearSelection(tkwin, eventPtr);
d256 3
a258 3
 *        This procedure is invoked when property-change events
 *        occur on windows not known to the toolkit.  This is a stub
 *        function under Windows.
d261 1
a261 1
 *        None.
d264 1
a264 1
 *        None.
d271 1
a271 1
    register XEvent *eventPtr)                /* X PropertyChange event. */
d280 2
a281 2
 *        Handle clipboard conversion as required by the suppend event.
 *        This function is also called on exit.
d284 1
a284 1
 *        None.
d287 1
a287 1
 *        The local scrap is moved to the global scrap.
d293 1
a293 1
TkSuspendClipboard()
d304 1
a304 1
        return;
d308 4
a311 3
            targetPtr = targetPtr->nextPtr) {
        if (targetPtr->type == XA_STRING)
            break;
d314 1
a314 2
        Tcl_DString encodedText;
	Tcl_DString unicodedText;	  
d316 27
a342 28
        length = 0;
        for (cbPtr = targetPtr->firstBufferPtr; cbPtr != NULL;
                cbPtr = cbPtr->nextPtr) {
            length += cbPtr->length;
        }

        buffer = ckalloc(length);
        buffPtr = buffer;
        for (cbPtr = targetPtr->firstBufferPtr; cbPtr != NULL;
                cbPtr = cbPtr->nextPtr) {
            for (p = cbPtr->buffer, endPtr = p + cbPtr->length;
                    p < endPtr; p++) {
                if (*p == '\n') {
                    *buffPtr++ = '\r';
                } else {
                    *buffPtr++ = *p;
                }
            }
        }

        ClearCurrentScrap();
        GetCurrentScrap(&scrapRef);
        Tcl_UtfToExternalDString(TkMacOSXCarbonEncoding, buffer, 
                length, &encodedText);
        PutScrapFlavor(scrapRef, 'TEXT', 0, 
                Tcl_DStringLength(&encodedText), 
                Tcl_DStringValue(&encodedText) );
        Tcl_DStringFree(&encodedText);
d345 1
a345 1
	 * Also put unicode data on scrap
d347 1
d355 1
a355 1
        ckfree(buffer);
d359 1
a359 1
     * The system now owns the scrap.  We tell Tk that it has
d361 1
a361 1
     * it needs it.  (Window list NULL if quiting.)
d365 3
a367 3
        Tk_ClearSelection((Tk_Window) TkGetMainInfoList()->winPtr, 
                Tk_InternAtom((Tk_Window) TkGetMainInfoList()->winPtr,
                        "CLIPBOARD"));
@

