head	1.4;
access;
symbols
	rel-7-10-4:1.3
	STABLE:1.3.0.2
	rel-7-10-2:1.3
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.4
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.07.04.17.46;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.20.17.22.25;	author joevalleyfield;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.56;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXSubwindows.c --
 *
 *	Implements subwindows for the macintosh version of Tk.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXSubwindows.c,v 1.23 2007/06/29 03:20:02 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkMacOSXDebug.h"
#include "tkMacOSXWm.h"

/*
#ifdef TK_MAC_DEBUG
#define TK_MAC_DEBUG_CLIP_REGIONS
#endif
*/

/*
 * Prototypes for functions used only in this file.
 */

static void MoveResizeWindow(MacDrawable *macWin);
static void GenerateConfigureNotify(TkWindow *winPtr, int includeWin);
static void UpdateOffsets(TkWindow *winPtr, int deltaX, int deltaY);


/*
 *----------------------------------------------------------------------
 *
 * XDestroyWindow --
 *
 *	Dealocates the given X Window.
 *
 * Results:
 *	The window id is returned.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
XDestroyWindow(
    Display* display,		/* Display. */
    Window window)		/* Window. */
{
    MacDrawable *macWin = (MacDrawable *) window;

    /*
     * Remove any dangling pointers that may exist if
     * the window we are deleting is being tracked by
     * the grab code.
     */

    TkPointerDeadWindow(macWin->winPtr);
    macWin->toplevel->referenceCount--;

    if (Tk_IsTopLevel(macWin->winPtr)) {
	WindowRef winRef;
	/*
	 * We are relying on the Activate Mac OS event to pass the
	 * focus away from a window that is getting Destroyed to the
	 * Front non-floating window. BUT we don't get activate events
	 * when a floating window is destroyed - since the front non-floating
	 * window doesn't in fact get activated... So maybe we can check here
	 * and if we are destroying a floating window, we can pass the focus
	 * back to the front non-floating window...
	 */

	if (macWin->grafPtr != NULL) {
	    TkWindow *focusPtr = TkGetFocusWin(macWin->winPtr);
	    if (focusPtr == NULL || (focusPtr->mainPtr->winPtr == macWin->winPtr)) {
		winRef = TkMacOSXDrawableWindow(window);
		if (TkpIsWindowFloating (winRef)) {
		    Window window;

		    window = TkMacOSXGetXWindow(ActiveNonFloatingWindow());
		    if (window != None) {
			TkMacOSXGenerateFocusEvent(window, 1);
		    }
		}
	    }
	}
	DisposeRgn(macWin->clipRgn);
	DisposeRgn(macWin->aboveClipRgn);
	DisposeRgn(macWin->drawRgn);

	/*
	 * Delete the Mac window and remove it from the windowTable.
	 * The window could be NULL if the window was never mapped.
	 * However, we don't do this for embedded windows, they don't
	 * go in the window list, and they do not own their portPtr's.
	 */

	if (!(Tk_IsEmbedded(macWin->winPtr))) {
	    WindowRef winRef = TkMacOSXDrawableWindow(window);

	    if (winRef) {
		TkMacOSXWindowList *listPtr, *prevPtr;

		TkMacOSXUnregisterMacWindow(winRef);
		DisposeWindow(winRef);

		for (listPtr = tkMacOSXWindowListPtr, prevPtr = NULL;
			tkMacOSXWindowListPtr != NULL;
			prevPtr = listPtr, listPtr = listPtr->nextPtr) {
		    if (listPtr->winPtr == macWin->winPtr) {
			if (prevPtr == NULL) {
			    tkMacOSXWindowListPtr = listPtr->nextPtr;
			} else {
			    prevPtr->nextPtr = listPtr->nextPtr;
			}
			ckfree((char *) listPtr);
			break;
		    }
		}
	    }
	}

	macWin->grafPtr = NULL;

	/*
	 * Delay deletion of a toplevel data structure untill all
	 * children have been deleted.
	 */
	if (macWin->toplevel->referenceCount == 0) {
	    ckfree((char *) macWin->toplevel);
	}
    } else {
	TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
	if (macWin->winPtr->parentPtr != NULL) {
	    TkMacOSXInvalClipRgns((Tk_Window) macWin->winPtr->parentPtr);
	}
	DisposeRgn(macWin->clipRgn);
	DisposeRgn(macWin->aboveClipRgn);
	DisposeRgn(macWin->drawRgn);

	if (macWin->toplevel->referenceCount == 0) {
	    ckfree((char *) macWin->toplevel);
	}
	ckfree((char *) macWin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * XMapWindow --
 *
 *	Map the given X Window to the screen. See X window documentation
 *  for more details.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The subwindow or toplevel may appear on the screen.
 *
 *----------------------------------------------------------------------
 */

void
XMapWindow(
    Display* display,		/* Display. */
    Window window)		/* Window. */
{
    MacDrawable *macWin = (MacDrawable *) window;
    XEvent event;

    /*
     * Under certain situations it's possible for this function to be
     * called before the toplevel window it's associated with has actually
     * been mapped. In that case we need to create the real Macintosh
     * window now as this function as well as other X functions assume that
     * the portPtr is valid.
     */
    if (!TkMacOSXHostToplevelExists(macWin->toplevel->winPtr)) {
	TkMacOSXMakeRealWindowExist(macWin->toplevel->winPtr);
    }

    display->request++;
    macWin->winPtr->flags |= TK_MAPPED;
    if (Tk_IsTopLevel(macWin->winPtr)) {
	if (!Tk_IsEmbedded(macWin->winPtr)) {
	    /*
	     * XXX This should be ShowSheetWindow for kSheetWindowClass
	     * XXX windows that have a wmPtr->master parent set.
	     */
	    WindowRef wRef = TkMacOSXDrawableWindow(window);

	    if ((macWin->winPtr->wmInfoPtr->macClass == kSheetWindowClass)
		    && (macWin->winPtr->wmInfoPtr->master != None)) {
		ShowSheetWindow(wRef, TkMacOSXDrawableWindow(
			macWin->winPtr->wmInfoPtr->master));
	    } else {
		ShowWindow(wRef);
	    }
	}
	TkMacOSXInvalClipRgns((Tk_Window) macWin->winPtr);

	/*
	 * We only need to send the MapNotify event
	 * for toplevel windows.
	 */
	event.xany.serial = display->request;
	event.xany.send_event = False;
	event.xany.display = display;

	event.xmap.window = window;
	event.xmap.type = MapNotify;
	event.xmap.event = window;
	event.xmap.override_redirect = macWin->winPtr->atts.override_redirect;
	Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
    } else {
	/*
	 * Generate damage for that area of the window
	 */

	TkMacOSXInvalClipRgns((Tk_Window) macWin->winPtr->parentPtr);
	TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * XUnmapWindow --
 *
 *	Unmap the given X Window to the screen. See X window
 *	documentation for more details.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The subwindow or toplevel may be removed from the screen.
 *
 *----------------------------------------------------------------------
 */

void
XUnmapWindow(
    Display* display,		/* Display. */
    Window window)		/* Window. */
{
    MacDrawable *macWin = (MacDrawable *) window;
    XEvent event;

    display->request++;
    macWin->winPtr->flags &= ~TK_MAPPED;
    if (Tk_IsTopLevel(macWin->winPtr)) {
	if (!Tk_IsEmbedded(macWin->winPtr)
		&& macWin->winPtr->wmInfoPtr->hints.initial_state != IconicState) {
	    /*
	     * XXX This should be HideSheetWindow for kSheetWindowClass
	     * XXX windows that have a wmPtr->master parent set.
	     */
	    WindowRef wref = TkMacOSXDrawableWindow(window);

	    if ((macWin->winPtr->wmInfoPtr->macClass == kSheetWindowClass)
		    && (macWin->winPtr->wmInfoPtr->master != None)) {
		HideSheetWindow(wref);
	    } else {
		HideWindow(wref);
	    }
	}
	TkMacOSXInvalClipRgns((Tk_Window) macWin->winPtr);

	/*
	 * We only need to send the UnmapNotify event
	 * for toplevel windows.
	 */
	event.xany.serial = display->request;
	event.xany.send_event = False;
	event.xany.display = display;

	event.xunmap.type = UnmapNotify;
	event.xunmap.window = window;
	event.xunmap.event = window;
	event.xunmap.from_configure = false;
	Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
    } else {
	/*
	 * Generate damage for that area of the window.
	 */

	TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
	TkMacOSXInvalClipRgns((Tk_Window) macWin->winPtr->parentPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * XResizeWindow --
 *
 *	Resize a given X window. See X windows documentation for
 *	further details.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
XResizeWindow(
    Display* display,		/* Display. */
    Window window,		/* Window. */
    unsigned int width,
    unsigned int height)
{
    MacDrawable *macWin = (MacDrawable *) window;

    display->request++;
    if (Tk_IsTopLevel(macWin->winPtr) && !Tk_IsEmbedded(macWin->winPtr)) {
	WindowRef w = TkMacOSXDrawableWindow(window);

	if (w) {
	    Rect bounds;

	    ChkErr(GetWindowBounds, w, kWindowContentRgn, &bounds);
	    bounds.right = bounds.left + width;
	    bounds.bottom = bounds.top + height;
	    ChkErr(SetWindowBounds, w, kWindowContentRgn, &bounds);
	}
    } else {
	MoveResizeWindow(macWin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * XMoveResizeWindow --
 *
 *	Move or resize a given X window. See X windows documentation
 *	for further details.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
XMoveResizeWindow(
    Display* display,		/* Display. */
    Window window,		/* Window. */
    int x, int y,
    unsigned int width,
    unsigned int height)
{
    MacDrawable * macWin = (MacDrawable *) window;

    display->request++;
    if (Tk_IsTopLevel(macWin->winPtr) && !Tk_IsEmbedded(macWin->winPtr)) {
	WindowRef w = TkMacOSXDrawableWindow(window);

	if (w) {
	    Rect bounds;

	    bounds.left = x + macWin->winPtr->wmInfoPtr->xInParent;
	    bounds.right = bounds.left + width;
	    bounds.top = y + macWin->winPtr->wmInfoPtr->yInParent;
	    bounds.bottom = bounds.top + height;
	    ChkErr(SetWindowBounds, w, kWindowContentRgn, &bounds);
	}
    } else {
	MoveResizeWindow(macWin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * XMoveWindow --
 *
 *	Move a given X window. See X windows documentation for further
 *	details.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
XMoveWindow(
    Display* display,		/* Display. */
    Window window,		/* Window. */
    int x,
    int y)
{
    MacDrawable *macWin = (MacDrawable *) window;

    display->request++;
    if (Tk_IsTopLevel(macWin->winPtr) && !Tk_IsEmbedded(macWin->winPtr)) {
	WindowRef w = TkMacOSXDrawableWindow(window);

	if (w) {
	    ChkErr(MoveWindowStructure, w, x, y);
	}
    } else {
	MoveResizeWindow(macWin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * MoveResizeWindow --
 *
 *	Helper proc for XResizeWindow, XMoveResizeWindow and XMoveWindow.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
MoveResizeWindow(
    MacDrawable *macWin)
{
    int deltaX = 0, deltaY = 0, parentBorderwidth = 0;
    MacDrawable *macParent = NULL;
    CGrafPtr destPort = TkMacOSXGetDrawablePort((Drawable) macWin);

    /*
     * Find the Parent window, for an embedded window it will be its container.
     */
    if (Tk_IsEmbedded(macWin->winPtr)) {
	TkWindow *contWinPtr = TkpGetOtherWindow(macWin->winPtr);

	if (contWinPtr) {
	    macParent = contWinPtr->privatePtr;
	} else {
	    /*
	     * Here we should handle out of process embedding.
	     * At this point, we are assuming that the changes.x,y is not
	     * maintained, if you need the info get it from Tk_GetRootCoords,
	     * and that the toplevel sits at 0,0 when it is drawn.
	     */
	}
    } else {
	/*
	 * TODO: update all xOff & yOffs
	 */

	macParent = macWin->winPtr->parentPtr->privatePtr;
	parentBorderwidth = macWin->winPtr->parentPtr->changes.border_width;
    }
    if (macParent) {
	deltaX = macParent->xOff + parentBorderwidth +
		macWin->winPtr->changes.x - macWin->xOff;
	deltaY = macParent->yOff + parentBorderwidth +
		macWin->winPtr->changes.y - macWin->yOff;
    }
    if (destPort) {
	TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
	if (macParent) {
	    TkMacOSXInvalClipRgns((Tk_Window) macParent->winPtr);
	}
    }
    UpdateOffsets(macWin->winPtr, deltaX, deltaY);
    if (destPort) {
	TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
    }
    GenerateConfigureNotify(macWin->winPtr, 0);
}

/*
 *----------------------------------------------------------------------
 *
 * GenerateConfigureNotify --
 *
 *	Generates ConfigureNotify events for all the child widgets
 *	of the widget passed in the winPtr parameter. If includeWin
 *	is true, also generates ConfigureNotify event for the
 *	widget itself.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	ConfigureNotify events will be posted.
 *
 *----------------------------------------------------------------------
 */

static void
GenerateConfigureNotify (TkWindow *winPtr, int includeWin)
{
    TkWindow *childPtr;

    for (childPtr = winPtr->childList; childPtr != NULL;
			       childPtr = childPtr->nextPtr) {
	if (!Tk_IsMapped(childPtr) || Tk_IsTopLevel(childPtr)) {
	    continue;
	}
	GenerateConfigureNotify(childPtr, 1);
    }
    if (includeWin) {
	TkDoConfigureNotify(winPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * XRaiseWindow --
 *
 *	Change the stacking order of a window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Changes the stacking order of the specified window.
 *
 *----------------------------------------------------------------------
 */

void
XRaiseWindow(
    Display* display,		/* Display. */
    Window window)		/* Window. */
{
    MacDrawable *macWin = (MacDrawable *) window;

    display->request++;
    if (Tk_IsTopLevel(macWin->winPtr) && !Tk_IsEmbedded(macWin->winPtr)) {
	TkWmRestackToplevel(macWin->winPtr, Above, NULL);
    } else {
	/*
	 * TODO: this should generate damage
	 */
    }
}

#if 0
/*
 *----------------------------------------------------------------------
 *
 * XLowerWindow --
 *
 *	Change the stacking order of a window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Changes the stacking order of the specified window.
 *
 *----------------------------------------------------------------------
 */

void
XLowerWindow(
    Display* display,		/* Display. */
    Window window)		/* Window. */
{
    MacDrawable *macWin = (MacDrawable *) window;

    display->request++;
    if (Tk_IsTopLevel(macWin->winPtr) && !Tk_IsEmbedded(macWin->winPtr)) {
	TkWmRestackToplevel(macWin->winPtr, Below, NULL);
    } else {
	/*
	 * TODO: this should generate damage
	 */
    }
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * XConfigureWindow --
 *
 *	Change the size, position, stacking, or border of the specified
 *	window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Changes the attributes of the specified window. Note that we
 *	ignore the passed in values and use the values stored in the
 *	TkWindow data structure.
 *
 *----------------------------------------------------------------------
 */

void
XConfigureWindow(
    Display* display,		/* Display. */
    Window w,			/* Window. */
    unsigned int value_mask,
    XWindowChanges* values)
{
    MacDrawable *macWin = (MacDrawable *) w;
    TkWindow *winPtr = macWin->winPtr;

    display->request++;

    /*
     * Change the shape and/or position of the window.
     */

    if (value_mask & (CWX|CWY|CWWidth|CWHeight)) {
	XMoveResizeWindow(display, w, winPtr->changes.x, winPtr->changes.y,
		winPtr->changes.width, winPtr->changes.height);
    }

    /*
     * Change the stacking order of the window. Tk actuall keeps all
     * the information we need for stacking order. All we need to do
     * is make sure the clipping regions get updated and generate damage
     * that will ensure things get drawn correctly.
     */

    if (value_mask & CWStackMode) {
	Rect bounds;
	WindowRef wRef = TkMacOSXDrawableWindow(w);

	if (wRef) {
	    TkMacOSXInvalClipRgns((Tk_Window) winPtr->parentPtr);
	    TkMacOSXWinBounds(winPtr, &bounds);
	    InvalWindowRect(wRef, &bounds);
	}
    }

    /* TkGenWMMoveRequestEvent(macWin->winPtr,
	    macWin->winPtr->changes.x, macWin->winPtr->changes.y); */
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXUpdateClipRgn --
 *
 *	This function updates the cliping regions for a given window
 *	and all of its children. Once updated the TK_CLIP_INVALID flag
 *	in the subwindow data structure is unset. The TK_CLIP_INVALID
 *	flag should always be unset before any drawing is attempted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The clip regions for the window and its children are updated.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXUpdateClipRgn(
    TkWindow *winPtr)
{
    MacDrawable *macWin;

    if (winPtr == NULL) {
	return;
    }
    macWin = winPtr->privatePtr;
    if (macWin && macWin->flags & TK_CLIP_INVALID) {
	TkWindow *win2Ptr;

	if (Tk_IsMapped(winPtr)) {
	    Rect bounds;
	    RgnHandle rgn = macWin->aboveClipRgn;

	    /*
	     * Start with a region defined by the window bounds.
	     */

	    TkMacOSXWinBounds(winPtr, &bounds);
	    RectRgn(rgn, &bounds);

	    /*
	     * Clip away the area of any windows that may obscure this
	     * window.
	     * For a non-toplevel window, first, clip to the parents visible
	     * clip region.
	     * Second, clip away any siblings that are higher in the
	     * stacking order.
	     * For an embedded toplevel, just clip to the container's visible
	     * clip region. Remember, we only allow one contained window
	     * in a frame, and don't support any other widgets in the frame
	     * either. This is not currently enforced, however.
	     */

	    if (!Tk_IsTopLevel(winPtr)) {
		TkMacOSXUpdateClipRgn(winPtr->parentPtr);
		TkMacOSXCheckTmpQdRgnEmpty();
		if (winPtr->parentPtr) {
		    SectRgn(rgn, winPtr->parentPtr->privatePtr->aboveClipRgn,
			    rgn);
		}
		win2Ptr = winPtr;
		while ((win2Ptr = win2Ptr->nextPtr)) {
		    if (Tk_IsTopLevel(win2Ptr) || !Tk_IsMapped(win2Ptr)) {
			continue;
		    }
		    TkMacOSXWinBounds(win2Ptr, &bounds);
		    RectRgn(tkMacOSXtmpQdRgn, &bounds);
		    DiffRgn(rgn, tkMacOSXtmpQdRgn, rgn);
		}
	    } else if (Tk_IsEmbedded(winPtr)) {
		win2Ptr = TkpGetOtherWindow(winPtr);
		if (win2Ptr) {
		    TkMacOSXUpdateClipRgn(win2Ptr);
		    TkMacOSXCheckTmpQdRgnEmpty();
		    SectRgn(rgn, win2Ptr->privatePtr->aboveClipRgn, rgn);
		} else if (tkMacOSXEmbedHandler != NULL) {
		    TkMacOSXCheckTmpQdRgnEmpty();
		    tkMacOSXEmbedHandler->getClipProc((Tk_Window) winPtr,
			    tkMacOSXtmpQdRgn);
		    SectRgn(rgn, tkMacOSXtmpQdRgn, rgn);
		}

		/*
		 * TODO: Here we should handle out of process embedding.
		 */
	    }

	    /*
	     * The final clip region is the aboveClip region (or visible
	     * region) minus all the children of this window.
	     * If the window is a container, we must also subtract the region
	     * of the embedded window.
	     */

	    rgn = macWin->clipRgn;
	    CopyRgn(macWin->aboveClipRgn, rgn);
	    win2Ptr = winPtr->childList;
	    while (win2Ptr) {
		if (Tk_IsTopLevel(win2Ptr) || !Tk_IsMapped(win2Ptr)) {
		    win2Ptr = win2Ptr->nextPtr;
		    continue;
		}
		TkMacOSXWinBounds(win2Ptr, &bounds);
		RectRgn(tkMacOSXtmpQdRgn, &bounds);
		DiffRgn(rgn, tkMacOSXtmpQdRgn, rgn);
		win2Ptr = win2Ptr->nextPtr;
	    }

	    if (Tk_IsContainer(winPtr)) {
		win2Ptr = TkpGetOtherWindow(winPtr);
		if (win2Ptr) {
		    if (Tk_IsMapped(win2Ptr)) {
			TkMacOSXWinBounds(win2Ptr, &bounds);
			RectRgn(tkMacOSXtmpQdRgn, &bounds);
			DiffRgn(rgn, tkMacOSXtmpQdRgn, rgn);
		    }
		}

		/*
		 * TODO: Here we should handle out of process embedding.
		 */
	    }
	    SetEmptyRgn(tkMacOSXtmpQdRgn);
	} else {
	    /*
	     * An unmapped window has empty clip regions to prevent any
	     * (erroneous) drawing into it or its children from becoming
	     * visible. [Bug 940117]
	     */

	    if (!Tk_IsTopLevel(winPtr)) {
		TkMacOSXUpdateClipRgn(winPtr->parentPtr);
	    } else if (Tk_IsEmbedded(winPtr)) {
		win2Ptr = TkpGetOtherWindow(winPtr);
		if (win2Ptr) {
		    TkMacOSXUpdateClipRgn(win2Ptr);
		}
	    }
	    SetEmptyRgn(macWin->aboveClipRgn);
	    SetEmptyRgn(macWin->clipRgn);
	}
	macWin->flags &= ~TK_CLIP_INVALID;

#ifdef TK_MAC_DEBUG_CLIP_REGIONS
	TkMacOSXDebugFlashRegion((Drawable) macWin, macWin->clipRgn);
#endif /* TK_MAC_DEBUG_CLIP_REGIONS */
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXVisableClipRgn --
 *
 *	This function returnd the Macintosh cliping region for the
 *	given window. A NULL Rgn means the window is not visible.
 *
 * Results:
 *	The region.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

RgnHandle
TkMacOSXVisableClipRgn(
    TkWindow *winPtr)
{
    if (winPtr->privatePtr->flags & TK_CLIP_INVALID) {
	TkMacOSXUpdateClipRgn(winPtr);
    }
    return winPtr->privatePtr->clipRgn;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXInvalidateWindow --
 *
 *	This function makes the window as invalid will generate damage
 *	for the window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Damage is created.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXInvalidateWindow(
    MacDrawable *macWin,	/* Make window that's causing damage. */
    int flag)			/* Should be TK_WINDOW_ONLY or
				 * TK_PARENT_WINDOW */
{
    WindowRef windowRef;
    RgnHandle rgn;

    windowRef = TkMacOSXDrawableWindow((Drawable)macWin);
    if (macWin->flags & TK_CLIP_INVALID) {
	TkMacOSXUpdateClipRgn(macWin->winPtr);
    }
    rgn = (flag == TK_WINDOW_ONLY) ? macWin->clipRgn : macWin->aboveClipRgn;
    if (!EmptyRgn(rgn)) {
	InvalWindowRgn(windowRef, rgn);
    }
#ifdef TK_MAC_DEBUG_CLIP_REGIONS
    TkMacOSXDebugFlashRegion((Drawable) macWin, rgn);
#endif /* TK_MAC_DEBUG_CLIP_REGIONS */
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGetDrawableWindow --
 *
 *	This function returns the WindowRef for a given X drawable.
 *
 * Results:
 *	A WindowRef, or NULL for off screen pixmaps.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

WindowRef
TkMacOSXDrawableWindow(
    Drawable drawable)
{
    MacDrawable *macWin = (MacDrawable *) drawable;
    WindowRef result = NULL;

    if (!macWin || !macWin->clipRgn) {
	result = NULL;
    } else {
	result = GetWindowFromPort(TkMacOSXGetDrawablePort(drawable));
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGetDrawablePort --
 *
 *	This function returns the Graphics Port for a given X drawable.
 *
 * Results:
 *	A CGrafPort . Either an off screen pixmap or a Window.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

CGrafPtr
TkMacOSXGetDrawablePort(
    Drawable drawable)
{
    MacDrawable *macWin = (MacDrawable *) drawable;
    CGrafPtr resultPort = NULL;

    if (macWin) {
	resultPort = macWin->grafPtr;
	if (macWin->toplevel && macWin->clipRgn) {
	    /*
	     * If the Drawable is in an embedded window, use the Port of its
	     * container.
	     *
	     * TRICKY POINT: we can have cases when a toplevel is being
	     * destroyed where the winPtr for the toplevel has been freed, but
	     * the children are not all the way destroyed. The children will
	     * call this function as they are being destroyed, but
	     * Tk_IsEmbedded will return garbage. So we check the copy of the
	     * TK_EMBEDDED flag we put into the toplevel's macWin flags.
	     */

	    if (macWin->toplevel->flags & TK_EMBEDDED) {
		TkWindow *contWinPtr;

		contWinPtr = TkpGetOtherWindow(macWin->toplevel->winPtr);

		if (contWinPtr != NULL) {
		    resultPort = TkMacOSXGetDrawablePort(
			(Drawable) contWinPtr->privatePtr);
		} else if (tkMacOSXEmbedHandler != NULL) {
		    resultPort = tkMacOSXEmbedHandler->getPortProc(
			    (Tk_Window) macWin->winPtr);
		}

		if (resultPort == NULL) {
		    /*
		     * FIXME: So far as I can tell, the only time that this
		     * happens is when we are tearing down an embedded child
		     * interpreter, and most of the time, this is harmless...
		     * However, we really need to find why the embedding loses.
		     */
		    TkMacOSXDbgMsg("Couldn't find container");
		}

		/*
		 * TODO: Here we should handle out of process embedding.
		 */
	    } else {
		resultPort = macWin->toplevel->grafPtr;
	    }
	}
    }

    return resultPort;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGetRootControl --
 *
 *	This function returns the Root Control for a given X drawable.
 *
 * Results:
 *	A ControlRef .
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ControlRef
TkMacOSXGetRootControl(
    Drawable drawable)
{
    /*
     * will probably need to fix this up for embedding
     */
    MacDrawable *macWin = (MacDrawable *) drawable;
    ControlRef result = NULL;

    if (macWin == NULL) {
	return NULL;
    }
    if (!(macWin->toplevel->flags & TK_EMBEDDED)) {
	return macWin->toplevel->rootControl;
    } else {
	TkWindow *contWinPtr;

	contWinPtr = TkpGetOtherWindow(macWin->toplevel->winPtr);

	if (contWinPtr != NULL) {
	    result = TkMacOSXGetRootControl(
		(Drawable) contWinPtr->privatePtr);
	} else if (tkMacOSXEmbedHandler != NULL) {
	    result = NULL;
	}
   }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXInvalClipRgns --
 *
 *	This function invalidates the clipping regions for a given
 *	window and all of its children. This function should be
 *	called whenever changes are made to subwindows that would
 *	affect the size or position of windows.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The cliping regions for the window and its children are
 *	mark invalid. (Make sure they are valid before drawing.)
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXInvalClipRgns(
    Tk_Window tkwin)
{
    TkWindow *winPtr = (TkWindow *) tkwin;
    TkWindow *childPtr;
    MacDrawable *macWin = winPtr->privatePtr;

    /*
     * If already marked we can stop because all
     * decendants will also already be marked.
     */
    if (!macWin || macWin->flags & TK_CLIP_INVALID) {
	return;
    }

    macWin->flags |= TK_CLIP_INVALID;
    SetEmptyRgn(macWin->aboveClipRgn);
    SetEmptyRgn(macWin->clipRgn);

    /*
     * Invalidate clip regions for all children &
     * their decendants - unless the child is a toplevel.
     */
    childPtr = winPtr->childList;
    while (childPtr) {
	if (!Tk_IsTopLevel(childPtr)) {
	    TkMacOSXInvalClipRgns((Tk_Window) childPtr);
	}
	childPtr = childPtr->nextPtr;
    }

    /*
     * Also, if the window is a container, mark its embedded window
     */

    if (Tk_IsContainer(winPtr)) {
	childPtr = TkpGetOtherWindow(winPtr);

	if (childPtr) {
	    TkMacOSXInvalClipRgns((Tk_Window) childPtr);
	}

	/*
	 * TODO: Here we should handle out of process embedding.
	 */
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXWinBounds --
 *
 *	Given a Tk window this function determines the windows
 *	bounds in relation to the Macintosh window's coordinate
 *	system. This is also the same coordinate system as the
 *	Tk toplevel window in which this window is contained.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXWinBounds(
    TkWindow *winPtr,
    Rect *bounds)
{
    bounds->left = winPtr->privatePtr->xOff;
    bounds->top = winPtr->privatePtr->yOff;
    bounds->right = bounds->left + winPtr->changes.width;
    bounds->bottom = bounds->top + winPtr->changes.height;
}

/*
 *----------------------------------------------------------------------
 *
 * UpdateOffsets --
 *
 *	Updates the X & Y offsets of the given TkWindow from the
 *	TopLevel it is a decendant of.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The xOff & yOff fields for the Mac window datastructure
 *	is updated to the proper offset.
 *
 *----------------------------------------------------------------------
 */

static void
UpdateOffsets(
    TkWindow *winPtr,
    int deltaX,
    int deltaY)
{
    TkWindow *childPtr;

    if (winPtr->privatePtr == NULL) {
	/*
	 * We haven't called Tk_MakeWindowExist for this window yet. The
	 * offset information will be postponed and calulated at that
	 * time. (This will usually only happen when a mapped parent is
	 * being moved but has child windows that have yet to be mapped.)
	 */
	return;
    }

    winPtr->privatePtr->xOff += deltaX;
    winPtr->privatePtr->yOff += deltaY;

    childPtr = winPtr->childList;
    while (childPtr != NULL) {
	if (!Tk_IsTopLevel(childPtr)) {
	    UpdateOffsets(childPtr, deltaX, deltaY);
	}
	childPtr = childPtr->nextPtr;
    }

    if (Tk_IsContainer(winPtr)) {
	childPtr = TkpGetOtherWindow(winPtr);
	if (childPtr != NULL) {
	    UpdateOffsets(childPtr,deltaX,deltaY);
	}

	/*
	 * TODO: Here we should handle out of process embedding.
	 */
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetPixmap --
 *
 *	Creates an in memory drawing surface.
 *
 * Results:
 *	Returns a handle to a new pixmap.
 *
 * Side effects:
 *	Allocates a new Macintosh GWorld.
 *
 *----------------------------------------------------------------------
 */

Pixmap
Tk_GetPixmap(
    Display *display,	/* Display for new pixmap (can be null). */
    Drawable d,		/* Drawable where pixmap will be used (ignored). */
    int width,		/* Dimensions of pixmap. */
    int height,
    int depth)		/* Bits per pixel for pixmap. */
{
    QDErr err;
    GWorldPtr gWorld;
    Rect bounds = {0, 0, height, width};
    MacDrawable *macPix;

    if (display != NULL) {
	display->request++;
    }
    macPix = (MacDrawable *) ckalloc(sizeof(MacDrawable));
    macPix->winPtr = NULL;
    macPix->xOff = 0;
    macPix->yOff = 0;
    macPix->clipRgn = NULL;
    macPix->aboveClipRgn = NULL;
    macPix->drawRgn = NULL;
    macPix->referenceCount = 0;
    macPix->toplevel = NULL;
    macPix->flags = 0;
    macPix->grafPtr = NULL;
    macPix->context = NULL;

    err = ChkErr(NewGWorld, &gWorld, depth == 1 ? 1 : 0, &bounds, NULL, NULL, 0
#ifdef __LITTLE_ENDIAN__
	    | kNativeEndianPixMap
#endif
	    );
    if (err != noErr) {
	Tcl_Panic("Out of memory: NewGWorld failed in Tk_GetPixmap");
    }
    macPix->grafPtr = gWorld;

    return (Pixmap) macPix;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_FreePixmap --
 *
 *	Release the resources associated with a pixmap.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deletes the Macintosh GWorld created by Tk_GetPixmap.
 *
 *----------------------------------------------------------------------
 */

void
Tk_FreePixmap(
    Display *display,		/* Display. */
    Pixmap pixmap)		/* Pixmap to destroy */
{
    MacDrawable *macPix = (MacDrawable *) pixmap;

    display->request++;
    if (macPix->grafPtr) {
	DisposeGWorld(macPix->grafPtr);
    }
    ckfree((char *) macPix);
}
@


1.3
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXSubwindows.c,v 1.17 2007/04/23 21:24:34 das Exp $
d16 1
a16 1
#include "tkMacOSXInt.h"
d30 3
a32 2
static void GenerateConfigureNotify (TkWindow *winPtr, int includeWin);
static void UpdateOffsets (TkWindow *winPtr, int deltaX, int deltaY);
d57 1
a57 1
    CGrafPtr destPort;
d82 1
a82 1
		winRef = GetWindowFromPort(macWin->grafPtr);
d105 3
a107 2
	    destPort = TkMacOSXGetDrawablePort(window);
	    if (destPort != NULL) {
d109 1
a109 2
		WindowRef winRef;
		winRef = GetWindowFromPort(destPort);
a177 1
    CGrafPtr  destPort;
a191 1
    destPort = TkMacOSXGetDrawablePort (window);
d198 2
a199 1
	    WindowRef wRef = GetWindowFromPort(destPort);
d202 2
a203 2
		ShowSheetWindow(wRef,
			GetWindowFromPort(TkMacOSXGetDrawablePort(macWin->winPtr->wmInfoPtr->master)));
d227 1
a256 1
    CGrafPtr destPort;
a259 1
    destPort = TkMacOSXGetDrawablePort(window);
d267 2
a268 1
	    WindowRef wref = GetWindowFromPort(destPort);
d295 1
a325 1
    CGrafPtr	 destPort;
a326 1
    destPort = TkMacOSXGetDrawablePort(window);
d328 2
a329 19
    if (Tk_IsTopLevel(macWin->winPtr)) {
	if (!Tk_IsEmbedded(macWin->winPtr)) {
	    /*
	     * NOTE: we are not adding the new space to the update
	     * region. It is currently assumed that Tk will need
	     * to completely redraw anway.
	     */
	    if (destPort) {
		WindowRef w = GetWindowFromPort(destPort);
		Rect bounds;

		ChkErr(GetWindowBounds, w, kWindowContentRgn, &bounds);
		bounds.right = bounds.left + width;
		bounds.bottom = bounds.top + height;
		ChkErr(SetWindowBounds, w, kWindowContentRgn, &bounds);
		TkMacOSXInvalidateWindow(macWin, TK_WINDOW_ONLY);
	    }
	} else {
	    int deltaX, deltaY;
d331 2
a332 33
	    /*
	     * Find the Parent window -
	     * For an embedded window this will be its container.
	     */
	    TkWindow *contWinPtr;

	    contWinPtr = TkpGetOtherWindow(macWin->winPtr);

	    if (contWinPtr != NULL) {
		MacDrawable *macParent = contWinPtr->privatePtr;

		if (destPort) {
		    TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
		    TkMacOSXInvalClipRgns((Tk_Window) macParent->winPtr);
		}
		deltaX = macParent->xOff +
		    macWin->winPtr->changes.x - macWin->xOff;
		deltaY = macParent->yOff +
		    macWin->winPtr->changes.y - macWin->yOff;

		UpdateOffsets(macWin->winPtr, deltaX, deltaY);
	    } else {
		/*
		 * This is the case where we are embedded in
		 * another app. At this point, we are assuming that
		 * the changes.x,y is not maintained, if you need
		 * the info get it from Tk_GetRootCoords,
		 * and that the toplevel sits at 0,0 when it is drawn.
		 */

		TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
		UpdateOffsets(macWin->winPtr, 0, 0);
	    }
d334 4
d340 1
a340 59
	/* TODO: update all xOff & yOffs */
	int deltaX, deltaY, parentBorderwidth;
	MacDrawable *macParent = macWin->winPtr->parentPtr->privatePtr;

	if (macParent == NULL) {
	    return; /* TODO: Probably should be a panic */
	}

	if (destPort) {
	    TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
	    TkMacOSXInvalClipRgns((Tk_Window) macParent->winPtr);
	}
	deltaX = - macWin->xOff;
	deltaY = - macWin->yOff;

	parentBorderwidth = macWin->winPtr->parentPtr->changes.border_width;

	deltaX += macParent->xOff + parentBorderwidth +
	    macWin->winPtr->changes.x;
	deltaY += macParent->yOff + parentBorderwidth +
	    macWin->winPtr->changes.y;

	UpdateOffsets(macWin->winPtr, deltaX, deltaY);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GenerateConfigureNotify --
 *
 *	Generates ConfigureNotify events for all the child widgets
 *	of the widget passed in the winPtr parameter. If includeWin
 *	is true, also generates ConfigureNotify event for the
 *	widget itself.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	ConfigureNotify events will be posted.
 *
 *----------------------------------------------------------------------
 */

static void
GenerateConfigureNotify (TkWindow *winPtr, int includeWin)
{
    TkWindow *childPtr;

    for (childPtr = winPtr->childList; childPtr != NULL;
			       childPtr = childPtr->nextPtr) {
	if (!Tk_IsMapped(childPtr) || Tk_IsTopLevel(childPtr)) {
	    continue;
	}
	GenerateConfigureNotify(childPtr, 1);
    }
    if (includeWin) {
	TkDoConfigureNotify(winPtr);
a369 1
    CGrafPtr	  destPort;
d371 1
a371 1
    destPort   = TkMacOSXGetDrawablePort(window);
d373 3
a375 6
	/*
	 * NOTE: we are not adding the new space to the update
	 * region. It is currently assumed that Tk will need
	 * to completely redraw anway.
	 */
	if (destPort) {
d382 1
a382 3
	    ChkErr(SetWindowBounds, GetWindowFromPort(destPort),
		    kWindowContentRgn, &bounds);
	    TkMacOSXInvalidateWindow(macWin, TK_WINDOW_ONLY);
d385 1
a385 59
	int deltaX, deltaY, parentBorderwidth;
	Rect bounds;
	MacDrawable *macParent;

	/*
	 * Find the Parent window -
	 *    For an embedded window this will be its container.
	 */

	if (Tk_IsEmbedded(macWin->winPtr)) {
	    TkWindow *contWinPtr;

	    contWinPtr = TkpGetOtherWindow(macWin->winPtr);
	    if (contWinPtr == NULL) {
		Tcl_Panic("XMoveResizeWindow could not find container");
	    }
	    macParent = contWinPtr->privatePtr;

	    /*
	     * NOTE: Here we should handle out of process embedding.
	     */


	} else {
	    macParent = macWin->winPtr->parentPtr->privatePtr;
	    if (macParent == NULL) {
		return; /* TODO: Probably should be a panic */
	    }
	}

	if (destPort) {
	    TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
	    TkMacOSXInvalClipRgns((Tk_Window) macParent->winPtr);
	}

	deltaX = - macWin->xOff;
	deltaY = - macWin->yOff;

	/*
	 * If macWin->winPtr is an embedded window, don't offset by its
	 *  parent's borderwidth...
	 */

	if (!Tk_IsEmbedded(macWin->winPtr)) {
	    parentBorderwidth = macWin->winPtr->parentPtr->changes.border_width;
	} else {
	    parentBorderwidth = 0;
	}
	deltaX += macParent->xOff + parentBorderwidth +
	    macWin->winPtr->changes.x;
	deltaY += macParent->yOff + parentBorderwidth +
	    macWin->winPtr->changes.y;

	UpdateOffsets(macWin->winPtr, deltaX, deltaY);
	if (destPort) {
	    TkMacOSXWinBounds(macWin->winPtr, &bounds);
	    InvalWindowRect(GetWindowFromPort(destPort),&bounds);
	}
	GenerateConfigureNotify(macWin->winPtr, 0);
d395 1
a395 1
 *  details.
a413 3
    CGrafPtr  destPort;

    destPort   = TkMacOSXGetDrawablePort(window);
d415 1
d417 1
a417 7
	/*
	 * NOTE: we are not adding the new space to the update
	 * region. It is currently assumed that Tk will need
	 * to completely redraw anway.
	 */
	if (destPort) {
	    WindowRef w = GetWindowFromPort(destPort);
d419 2
a420 2
	    MoveWindowStructure(w, x, y);
	    TkMacOSXInvalidateWindow(macWin, TK_WINDOW_ONLY);
d423 19
a441 3
	int deltaX, deltaY, parentBorderwidth;
	Rect bounds;
	MacDrawable *macParent;
d443 7
a449 4
	/*
	 * Find the Parent window -
	 * For an embedded window this will be its container.
	 */
d451 5
a455 2
	if (Tk_IsEmbedded(macWin->winPtr)) {
	    TkWindow *contWinPtr;
d457 1
a457 4
	    contWinPtr = TkpGetOtherWindow(macWin->winPtr);
	    if (contWinPtr == NULL) {
		Tcl_Panic("XMoveWindow could not find container");
	    }
d459 1
a459 1

d461 4
a464 1
	     * NOTE: Here we should handle out of process embedding.
a465 6

	} else {
	    macParent = macWin->winPtr->parentPtr->privatePtr;
	    if (macParent == NULL) {
		return; /* TODO: Probably should be a panic */
	    }
d467 4
d472 12
a483 2
	if (destPort) {
	    TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
d486 26
d513 4
a516 2
	deltaX = - macWin->xOff;
	deltaY = - macWin->yOff;
d518 4
a521 9
	/*
	 * If macWin->winPtr is an embedded window, don't offset by its
	 *  parent's borderwidth...
	 */

	if (!Tk_IsEmbedded(macWin->winPtr)) {
	    parentBorderwidth = macWin->winPtr->parentPtr->changes.border_width;
	} else {
	    parentBorderwidth = 0;
d523 4
a526 11
	deltaX += macParent->xOff + parentBorderwidth +
	    macWin->winPtr->changes.x;
	deltaY += macParent->yOff + parentBorderwidth +
	    macWin->winPtr->changes.y;

	UpdateOffsets(macWin->winPtr, deltaX, deltaY);
	if (destPort) {
	    TkMacOSXWinBounds(macWin->winPtr, &bounds);
	    InvalWindowRect(GetWindowFromPort(destPort),&bounds);
	}
	GenerateConfigureNotify(macWin->winPtr, 0);
d557 3
a559 1
	/* TODO: this should generate damage */
d591 3
a593 1
	/* TODO: this should generate damage */
d647 1
a647 1
	CGrafPtr destPort;
d649 1
a649 2
	destPort = TkMacOSXGetDrawablePort(w);
	if (destPort != NULL) {
d652 1
a652 1
	    InvalWindowRect(GetWindowFromPort(destPort),&bounds);
d683 1
a683 3
    RgnHandle rgn;
    int x, y;
    TkWindow *win2Ptr;
d688 3
a691 1
    if (winPtr->privatePtr && winPtr->privatePtr->flags & TK_CLIP_INVALID) {
d693 2
a694 1
	    rgn = winPtr->privatePtr->aboveClipRgn;
d700 2
a701 5
	    x = winPtr->privatePtr->xOff;
	    y = winPtr->privatePtr->yOff;
	    SetRectRgn(rgn, (short) x, (short) y,
		(short) (winPtr->changes.width	+ x),
		(short) (winPtr->changes.height + y));
d718 7
a724 6
		TkMacOSXCheckTmpRgnEmpty(1);
		SectRgn(rgn,
			winPtr->parentPtr->privatePtr->aboveClipRgn, rgn);

		win2Ptr = winPtr->nextPtr;
		while (win2Ptr != NULL) {
a725 1
			win2Ptr = win2Ptr->nextPtr;
d728 3
a730 8
		    x = win2Ptr->privatePtr->xOff;
		    y = win2Ptr->privatePtr->yOff;
		    SetRectRgn(tkMacOSXtmpRgn1, (short) x, (short) y,
			    (short) (win2Ptr->changes.width  + x),
			    (short) (win2Ptr->changes.height + y));
		    DiffRgn(rgn, tkMacOSXtmpRgn1, rgn);

		    win2Ptr = win2Ptr->nextPtr;
d733 5
a737 7
		TkWindow *contWinPtr = TkpGetOtherWindow(winPtr);

		if (contWinPtr != NULL) {
		    TkMacOSXUpdateClipRgn(contWinPtr);
		    TkMacOSXCheckTmpRgnEmpty(1);
		    SectRgn(rgn,
			    contWinPtr->privatePtr->aboveClipRgn, rgn);
d739 1
a739 1
		    TkMacOSXCheckTmpRgnEmpty(1);
d741 2
a742 2
			    tkMacOSXtmpRgn1);
		    SectRgn(rgn, tkMacOSXtmpRgn1, rgn);
d746 1
a746 1
		 * NOTE: Here we should handle out of process embedding.
a747 1

d753 2
a754 2
	     * Alternatively, if the window is a container, we must also
	     * subtract the region of the embedded window.
d757 2
a758 3
	    rgn = winPtr->privatePtr->clipRgn;
	    CopyRgn(winPtr->privatePtr->aboveClipRgn, rgn);

d760 1
a760 1
	    while (win2Ptr != NULL) {
d765 3
a767 7
		x = win2Ptr->privatePtr->xOff;
		y = win2Ptr->privatePtr->yOff;
		SetRectRgn(tkMacOSXtmpRgn1, (short) x, (short) y,
			(short) (win2Ptr->changes.width	 + x),
			(short) (win2Ptr->changes.height + y));
		DiffRgn(rgn, tkMacOSXtmpRgn1, rgn);

d773 1
a773 1
		if (win2Ptr != NULL) {
d775 3
a777 6
			x = win2Ptr->privatePtr->xOff;
			y = win2Ptr->privatePtr->yOff;
			SetRectRgn(tkMacOSXtmpRgn1, (short) x, (short) y,
				(short) (win2Ptr->changes.width	 + x),
				(short) (win2Ptr->changes.height + y));
			DiffRgn(rgn, tkMacOSXtmpRgn1, rgn);
d782 1
a782 1
		 * NOTE: Here we should handle out of process embedding.
a783 1

d785 1
a785 1
	    SetEmptyRgn(tkMacOSXtmpRgn1);
d796 3
a798 4
		TkWindow *contWinPtr = TkpGetOtherWindow(winPtr);

		if (contWinPtr != NULL) {
		    TkMacOSXUpdateClipRgn(contWinPtr);
d801 2
a802 2
	    SetEmptyRgn(winPtr->privatePtr->aboveClipRgn);
	    SetEmptyRgn(winPtr->privatePtr->clipRgn);
d804 1
a804 2

	winPtr->privatePtr->flags &= ~TK_CLIP_INVALID;
d807 1
a807 8
	TkMacOSXInitNamedDebugSymbol(HIToolbox, int, QDDebugFlashRegion,
				     CGrafPtr port, RgnHandle region);
	if (QDDebugFlashRegion) {
	    MacDrawable *macDraw = (MacDrawable *) winPtr->privatePtr;
	    CGrafPtr grafPtr = TkMacOSXGetDrawablePort((Drawable) macDraw);
	    /* Carbon-internal region flashing SPI (c.f. Technote 2124) */
	    QDDebugFlashRegion(grafPtr, macDraw->clipRgn);
	}
a808 1

a835 1

d863 1
a863 4
    CGrafPtr  grafPtr;

    grafPtr = TkMacOSXGetDrawablePort((Drawable)macWin);
    windowRef = GetWindowFromPort(grafPtr);
d865 1
d869 4
a872 7
    if (flag == TK_WINDOW_ONLY) {
	InvalWindowRgn(windowRef, macWin->clipRgn);
    } else {
	if (!EmptyRgn(macWin->aboveClipRgn)) {
	    InvalWindowRgn(windowRef, macWin->aboveClipRgn);
	}

d874 1
a874 6
	TkMacOSXInitNamedDebugSymbol(HIToolbox, int, QDDebugFlashRegion,
				     CGrafPtr port, RgnHandle region);
	if (QDDebugFlashRegion) {
	    /* Carbon-internal region flashing SPI (c.f. Technote 2124) */
	    QDDebugFlashRegion(grafPtr, macWin->aboveClipRgn);
	}
d876 17
d894 11
d906 1
d932 14
a945 3
    if (macWin == NULL) {
	return NULL;
    }
d947 2
a948 5
    /*
     * This is NULL for off-screen pixmaps. Then the portPtr
     * always points to the off-screen port, and we don't
     * have to worry about containment
     */
d950 1
a950 3
    if (macWin->clipRgn == NULL) {
	return macWin->grafPtr;
    }
d952 7
a958 10
    /*
     * If the Drawable is in an embedded window, use the Port of its container.
     *
     * TRICKY POINT: we can have cases when a toplevel is being destroyed
     * where the winPtr for the toplevel has been freed, but the children
     * are not all the way destroyed. The children will call this function
     * as they are being destroyed, but Tk_IsEmbedded will return garbage.
     * So we check the copy of the TK_EMBEDDED flag we put into the
     * toplevel's macWin flags.
     */
d960 9
a968 4
    if (!(macWin->toplevel->flags & TK_EMBEDDED)) {
	return macWin->toplevel->grafPtr;
    } else {
	TkWindow *contWinPtr;
d970 6
a975 8
	contWinPtr = TkpGetOtherWindow(macWin->toplevel->winPtr);

	if (contWinPtr != NULL) {
	    resultPort = TkMacOSXGetDrawablePort(
		(Drawable) contWinPtr->privatePtr);
	} else if (tkMacOSXEmbedHandler != NULL) {
	    resultPort = tkMacOSXEmbedHandler->getPortProc(
		    (Tk_Window) macWin->winPtr);
d977 1
a978 18
	if (resultPort == NULL) {
	    /*
	     * FIXME:
	     *
	     * So far as I can tell, the only time that this happens is when
	     * we are tearing down an embedded child interpreter, and most
	     * of the time, this is harmless... However, we really need to
	     * find why the embedding loses.
	     */
	    DebugStr("\pTkMacOSXGetDrawablePort couldn't find container");
	    return NULL;
	}

	/*
	 * NOTE: Here we should handle out of process embedding.
	 */

    }
d1054 1
d1060 1
a1060 1
    if (!winPtr->privatePtr || winPtr->privatePtr->flags & TK_CLIP_INVALID) {
d1064 3
a1066 3
    winPtr->privatePtr->flags |= TK_CLIP_INVALID;
    SetEmptyRgn(winPtr->privatePtr->aboveClipRgn);
    SetEmptyRgn(winPtr->privatePtr->clipRgn);
d1092 1
a1092 1
	 * NOTE: Here we should handle out of process embedding.
a1093 1

d1121 4
a1124 6
    bounds->left = (short) winPtr->privatePtr->xOff;
    bounds->top = (short) winPtr->privatePtr->yOff;
    bounds->right = (short) (winPtr->privatePtr->xOff +
	    winPtr->changes.width);
    bounds->bottom = (short) (winPtr->privatePtr->yOff +
	    winPtr->changes.height);
d1155 1
a1155 1
	 * We havn't called Tk_MakeWindowExist for this window yet. The
d1181 1
a1181 1
	 * NOTE: Here we should handle out of process embedding.
a1182 1

d1212 1
a1212 1
    Rect bounds;
d1228 2
d1231 1
a1231 12
    bounds.top = bounds.left = 0;
    bounds.right = (short) width;
    bounds.bottom = (short) height;
    if (depth != 1) {
	depth = 0;
    }
    /*
     * Allocate memory for the off screen pixmap. If we fail
     * try again from system memory. Eventually, we may have
     * to panic.
     */
    err = ChkErr(NewGWorld, &gWorld, depth, &bounds, NULL, NULL, 0
a1239 1
    macPix->context = NULL;
d1268 3
a1270 1
    DisposeGWorld(macPix->grafPtr);
@


1.2
log
@remove dependency on -fpascal-strings when building for aqua
@
text
@d1 1
a1 1
/* 
d8 1
a8 1
 * Copyright (c) 2006 Daniel A. Steffen <das@@users.sourceforge.net>
d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXSubwindows.c,v 1.1 2007/03/02 21:49:56 brlcad Exp $
d21 1
a21 1
#ifdef	TK_MAC_DEBUG
a26 5
 * Temporary region that can be reused.
 */
static RgnHandle tmpRgn = NULL;

/*
d33 1
d50 1
a50 1
void 
d56 1
a56 1
    CGrafPtr     destPort;
d67 25
a91 25
        WindowRef winRef;
        /*
         * We are relying on the Activate Mac OS event to pass the
         * focus away from a window that is getting Destroyed to the
         * Front non-floating window.  BUT we don't get activate events
         * when a floating window is destroyed - since the front non-floating
         * window doesn't in fact get activated...  So maybe we can check here
         * and if we are destroying a floating window, we can pass the focus
         * back to the front non-floating window...
         */
         
        if (macWin->grafPtr != NULL) {
            TkWindow *focusPtr = TkGetFocusWin(macWin->winPtr);
            if (focusPtr == NULL || (focusPtr->mainPtr->winPtr == macWin->winPtr)) {
                winRef = GetWindowFromPort(macWin->grafPtr);
                if (TkpIsWindowFloating (winRef)) {
                    Window window;
                    
                    window = TkMacOSXGetXWindow(ActiveNonFloatingWindow());
                    if (window != None) {
                        TkMacOSXGenerateFocusEvent(window, 1);
                    }
                }
            }
        }
d94 2
a95 1
	
d102 1
a102 1
	 
d104 1
a104 1
            destPort = TkMacOSXGetDrawablePort(window);
d106 19
a124 19
	        TkMacOSXWindowList *listPtr, *prevPtr;
                WindowRef        winRef;
                winRef = GetWindowFromPort(destPort);
	        TkMacOSXUnregisterMacWindow(winRef);
	        DisposeWindow(winRef);
	    
	        for (listPtr = tkMacOSXWindowListPtr, prevPtr = NULL;
	    	        tkMacOSXWindowListPtr != NULL;
	    	        prevPtr = listPtr, listPtr = listPtr->nextPtr) {
	            if (listPtr->winPtr == macWin->winPtr) {
	                if (prevPtr == NULL) {
	            	    tkMacOSXWindowListPtr = listPtr->nextPtr;
	                } else {
	            	    prevPtr->nextPtr = listPtr->nextPtr;
	                }
	                ckfree((char *) listPtr);
	                break;
	            }
	        }
d127 1
a127 1
	
d129 1
a129 1
	
d138 1
a138 6
        CGrafPtr destPort;
        destPort = TkMacOSXGetDrawablePort(window);
	if (destPort != NULL) {
	    SetGWorld(destPort, NULL);
	    TkMacOSXInvalidateWindow(macWin, TK_PARENT_WINDOW);
	}
d144 2
a145 1
	
d158 1
a158 1
 *	Map the given X Window to the screen.  See X window documentation 
d170 1
a170 1
void 
d182 1
a182 1
     * been mapped.  In that case we need to create the real Macintosh
d200 1
a200 1
	    if ((TkMacOSXWindowClass(macWin->winPtr) == kSheetWindowClass)
d208 1
d210 1
a210 1
	/* 
d217 1
a217 1
	
d224 2
a225 2
	/* 
	 * Generate damage for that area of the window 
a226 1
	SetGWorld(destPort, NULL);
d237 1
a237 1
 *	Unmap the given X Window to the screen.  See X window
d249 1
a249 1
void 
d269 1
a269 1
	    if ((TkMacOSXWindowClass(macWin->winPtr) == kSheetWindowClass)
d276 1
d278 1
a278 1
	/* 
d292 1
a292 1
	/* 
a294 1
	SetGWorld(destPort, NULL);
d305 1
a305 1
 *	Resize a given X window.  See X windows documentation for
d317 1
a317 1
void 
d320 1
a320 1
    Window window, 		/* Window. */
d325 1
a325 2
    CGrafPtr     destPort;
    int havePort = 1;
a327 4
    if (destPort == NULL) {
	havePort = 0;
    }

d331 1
a331 1
	    /* 
d333 1
a333 1
	     * region.  It is currently assumed that Tk will need
d336 10
a345 7
            if (havePort) {
                SetPort(destPort);
	        SizeWindow(GetWindowFromPort(destPort),
		        (short) width, (short) height, false);
	        TkMacOSXInvalidateWindow(macWin, TK_WINDOW_ONLY);
	        TkMacOSXInvalClipRgns((Tk_Window) macWin->winPtr);
            }
d348 1
a348 1
	    
d351 1
a351 1
	     *    For an embedded window this will be its container.
d354 1
a354 1
	    
d356 1
a356 1
	    
d358 1
a358 1
	        MacDrawable *macParent = contWinPtr->privatePtr;
d360 1
a360 2
                if (havePort) {
                    SetPort(destPort);
d362 1
a362 1
		    TkMacOSXInvalClipRgns((Tk_Window) macParent->winPtr);	
d368 1
a368 1
		
d371 4
a374 4
	        /*
	         * This is the case where we are embedded in
	         * another app.  At this point, we are assuming that
	         * the changes.x,y is not maintained, if you need
d376 3
a378 3
	         * and that the toplevel sits at 0,0 when it is drawn.
	         */
		
d382 2
a383 2
	         
	}   
d388 1
a388 1
	
d392 2
a393 3
	
        if (havePort) {
            SetPort(destPort);
d395 2
a396 2
	    TkMacOSXInvalClipRgns((Tk_Window) macParent->winPtr);	
        }
d401 1
a401 1
	
d406 1
a406 1
        
a409 1

d417 3
a419 3
 *      of the widget passed in the winPtr parameter.  If includeWin
 *      is true, also generates ConfigureNotify event for the 
 *      widget itself.
d436 5
a440 5
                               childPtr = childPtr->nextPtr) {
        if (!Tk_IsMapped(childPtr) || Tk_IsTopLevel(childPtr)) {
            continue;
        }
        GenerateConfigureNotify(childPtr, 1);
d443 1
a443 1
        TkDoConfigureNotify(winPtr);
d445 2
a446 3
}    


d452 1
a452 1
 *	Move or resize a given X window.  See X windows documentation
d464 1
a464 1
void 
d467 1
a467 1
    Window window, 		/* Window. */
d471 1
a471 1
{	
d473 1
a473 2
    CGrafPtr      destPort;
    int havePort = 1;
d476 2
a477 6
    if (destPort == NULL) {
	havePort = 0;
    }

    if (Tk_IsTopLevel(macWin->winPtr) && !Tk_IsEmbedded(macWin->winPtr)) {	
	/* 
d479 1
a479 1
	 * region.  It is currently assumed that Tk will need
d482 9
a490 6
        if (havePort) {
            SetPort( destPort);
	    SizeWindow(GetWindowFromPort(destPort),
		    (short) width, (short) height, false);
	    MoveWindowStructure(GetWindowFromPort(destPort), x, y);
	
d492 1
a492 2
	    TkMacOSXInvalClipRgns((Tk_Window) macWin->winPtr);
        }
d497 6
a502 6
	
        /*
         * Find the Parent window -
         *    For an embedded window this will be its container.
         */
         
d505 1
a505 1
	    
d511 1
a511 1
	    
d515 2
a516 2
	
	    
d518 1
a518 1
	    macParent = macWin->winPtr->parentPtr->privatePtr;   
d520 1
a520 1
	        return; /* TODO: Probably should be a panic */
d524 1
a524 2
	if (havePort) {
	    SetPort( destPort);
d531 2
a532 2
	
        /*
d536 1
a536 1
	 
d546 1
a546 1
		
d548 1
a548 1
        if (havePort) {
d551 2
a552 2
        }
        GenerateConfigureNotify(macWin->winPtr, 0);
d561 1
a561 1
 *	Move a given X window.  See X windows documentation for further
d573 1
a573 1
void 
a581 1
    int havePort = 1;
a583 3
    if (destPort == NULL) {
	havePort = 0;
    }
d586 1
a586 1
	/* 
d588 1
a588 1
	 * region.  It is currently assumed that Tk will need
d591 2
a592 3
        if (havePort) { 
            SetPort(destPort);
	    MoveWindowStructure( GetWindowFromPort(destPort), x, y);
d594 1
d596 1
a596 2
	    TkMacOSXInvalClipRgns((Tk_Window) macWin->winPtr);
        }
d601 6
a606 6
	
        /*
         * Find the Parent window -
         * For an embedded window this will be its container.
         */
         
d609 1
a609 1
	    
d615 1
a615 1
	    
d619 1
a619 1
		    
d621 1
a621 1
	    macParent = macWin->winPtr->parentPtr->privatePtr;   
d623 1
a623 1
	        return; /* TODO: Probably should be a panic */
d627 1
a627 2
        if (havePort) {
            SetPort(destPort);
d630 2
a631 2
        }
        
d634 2
a635 2
	
        /*
d639 1
a639 1
	 
d649 1
a649 1
		
d651 2
a652 2
	if (havePort) {
            TkMacOSXWinBounds(macWin->winPtr, &bounds);
d654 1
a654 1
        }
d675 1
a675 1
void 
d681 1
a681 1
    
d686 1
a686 1
    	/* TODO: this should generate damage */
d707 1
a707 1
void 
d713 1
a713 1
    
d718 1
a718 1
    	/* TODO: this should generate damage */
d735 1
a735 1
 *	Changes the attributes of the specified window.  Note that we
d764 2
a765 2
     * Change the stacking order of the window.  Tk actuall keeps all
     * the information we need for stacking order.  All we need to do
d773 1
a773 1
	
a775 1
	    SetPort( destPort);
d780 1
a780 1
    } 
d782 1
a782 1
    /* TkGenWMMoveRequestEvent(macWin->winPtr, 
d789 1
a789 1
 *  TkMacOSXUpdateClipRgn --
d792 2
a793 2
 *	and all of its children.  Once updated the TK_CLIP_INVALID flag
 *	in the subwindow data structure is unset.  The TK_CLIP_INVALID 
a819 3
	    if (tmpRgn == NULL) {
		tmpRgn = NewRgn();
	    }
d821 1
a821 1
	    /* 
d828 1
a828 1
		(short) (winPtr->changes.width  + x), 
d831 1
a831 1
	    /* 
d839 1
a839 1
	     * clip region.  Remember, we only allow one contained window
d844 1
a844 1
	    if (!Tk_IsTopLevel(winPtr)) { 
d846 2
a847 1
		SectRgn(rgn, 
d858 2
a859 2
		    SetRectRgn(tmpRgn, (short) x, (short) y,
			    (short) (win2Ptr->changes.width  + x), 
d861 1
a861 1
		    DiffRgn(rgn, tmpRgn, rgn);
d870 2
a871 1
		    SectRgn(rgn, 
d873 5
a877 3
		} else if (gMacEmbedHandler != NULL) {
		    gMacEmbedHandler->getClipProc((Tk_Window) winPtr, tmpRgn);
		    SectRgn(rgn, tmpRgn, rgn);
d886 1
a886 1
	    /* 
d889 1
a889 1
	     * Alternatively, if the window is a container, we must also 
d904 2
a905 2
		SetRectRgn(tmpRgn, (short) x, (short) y,
			(short) (win2Ptr->changes.width  + x), 
d907 1
a907 1
		DiffRgn(rgn, tmpRgn, rgn);
d918 2
a919 2
			SetRectRgn(tmpRgn, (short) x, (short) y,
				(short) (win2Ptr->changes.width  + x), 
d921 1
a921 1
			DiffRgn(rgn, tmpRgn, rgn);
d923 1
a923 1
		} 
d930 1
d938 1
a938 1
	    if (!Tk_IsTopLevel(winPtr)) { 
d953 1
a953 1
#if defined(TK_MAC_DEBUG) && defined(TK_MAC_DEBUG_CLIP_REGIONS)
d972 2
a973 2
 *	This function returnd the Macintosh cliping region for the 
 *	given window.  A NULL Rgn means the window is not visible.
d1014 1
a1014 1
    MacDrawable *macWin,        /* Make window that's causing damage. */
d1034 1
a1034 1
#if defined(TK_MAC_DEBUG) && defined(TK_MAC_DEBUG_CLIP_REGIONS)
d1054 1
a1054 1
 *	A CGrafPort .  Either an off screen pixmap or a Window.
d1067 2
a1068 2
    GWorldPtr resultPort = NULL;
    
d1070 1
a1070 1
        return NULL;
d1072 1
a1072 1
    
d1074 1
a1074 1
     * This is NULL for off-screen pixmaps.  Then the portPtr
d1078 1
a1078 1
     
d1082 1
a1082 1
    
d1085 1
a1085 1
     *  
d1087 2
a1088 2
     * where the winPtr for the toplevel has been freed, but the children 
     * are not all the way destroyed.  The children will call this function
d1090 1
a1090 1
     * So we check the copy of the TK_EMBEDDED flag we put into the 
d1093 1
a1093 4
     
     
     
    
d1095 1
a1095 1
        return macWin->toplevel->grafPtr;
d1097 1
a1097 1
    	TkWindow *contWinPtr;
d1100 3
a1102 3
	
    	if (contWinPtr != NULL) {
    	    resultPort = TkMacOSXGetDrawablePort(
d1104 5
a1108 5
    	} else if (gMacEmbedHandler != NULL) {
	    resultPort = gMacEmbedHandler->getPortProc(
                    (Tk_Window) macWin->winPtr);
    	} 
	
d1115 1
a1115 1
	     * of the time, this is harmless...  However, we really need to
d1118 4
a1121 4
	    fprintf(stderr, "TkMacOSXGetDrawablePort couldn't find container");
    	    return NULL;
    	}	
	    
d1125 1
a1125 1
		    
d1155 1
a1155 1
    
d1157 1
a1157 1
        return NULL;
d1160 1
a1160 1
        return macWin->toplevel->rootControl;
d1162 1
a1162 1
        TkWindow *contWinPtr;
d1164 1
a1164 1
        contWinPtr = TkpGetOtherWindow(macWin->toplevel->winPtr);
d1166 6
a1171 6
        if (contWinPtr != NULL) {
            result = TkMacOSXGetRootControl(
                (Drawable) contWinPtr->privatePtr);
        } else if (gMacEmbedHandler != NULL) {
            result = NULL;
        }
d1182 1
a1182 1
 *	window and all of its children.  This function should be
d1191 1
a1191 1
 *	mark invalid.  (Make sure they are valid before drawing.)
d1203 2
a1204 2
    /* 
     * If already marked we can stop because all 
d1215 2
a1216 2
    /* 
     * Invalidate clip regions for all children & 
d1252 1
a1252 1
 *	system.  This is also the same coordinate system as the
d1305 3
a1307 3
	 * We havn't called Tk_MakeWindowExist for this window yet.  The
	 * offset information will be postponed and calulated at that 
	 * time.  (This will usually only happen when a mapped parent is
d1312 1
a1312 1
    
d1323 1
a1323 1
    
d1329 1
a1329 1
	    
d1333 1
a1333 1
		    
d1365 1
a1365 2
    PixMapHandle pixels;
    
d1375 1
d1387 2
a1388 2
     * Allocate memory for the off screen pixmap.  If we fail
     * try again from system memory.  Eventually, we may have
d1391 5
a1395 4
    err = NewGWorld(&gWorld, depth, &bounds, NULL, NULL, 0);
    if (err != noErr) {
	err = NewGWorld(&gWorld, depth, &bounds, NULL, NULL, useTempMem);
    }
d1397 1
a1397 1
        Tcl_Panic("Out of memory: NewGWorld failed in Tk_GetPixmap");
a1398 6

    /*
     * Lock down the pixels so they don't move out from under us.
     */
    pixels = GetGWorldPixMap(gWorld);
    LockPixels(pixels);
d1400 1
d1421 1
a1421 1
void 
d1424 1
a1424 1
    Pixmap pixmap)     		/* Pixmap to destroy */
a1426 1
    PixMapHandle pixels;
a1428 2
    pixels = GetGWorldPixMap(macPix->grafPtr);
    UnlockPixels(pixels);
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXSubwindows.c,v 1.15 2006/07/24 04:45:23 das Exp $
d1143 1
a1143 1
	    DebugStr("\pTkMacOSXGetDrawablePort couldn't find container");
@

