head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.46;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.56;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXWindowEvent.c --
 *
 *	This file defines the routines for both creating and handling
 *	Window Manager class events for Tk.
 *
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 *	The following terms apply to all files originating from Apple
 *	Computer, Inc. ("Apple") and associated with the software
 *	unless explicitly disclaimed in individual files.
 *
 *
 *	Apple hereby grants permission to use, copy, modify,
 *	distribute, and license this software and its documentation
 *	for any purpose, provided that existing copyright notices are
 *	retained in all copies and that this notice is included
 *	verbatim in any distributions. No written agreement, license,
 *	or royalty fee is required for any of the authorized
 *	uses. Modifications to this software may be copyrighted by
 *	their authors and need not follow the licensing terms
 *	described here, provided that the new terms are clearly
 *	indicated on the first page of each file where they apply.
 *
 *
 *	IN NO EVENT SHALL APPLE, THE AUTHORS OR DISTRIBUTORS OF THE
 *	SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 *	INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
 *	THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 *	EVEN IF APPLE OR THE AUTHORS HAVE BEEN ADVISED OF THE
 *	POSSIBILITY OF SUCH DAMAGE.  APPLE, THE AUTHORS AND
 *	DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES, INCLUDING,
 *	BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.	 THIS
 *	SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, AND APPLE,THE
 *	AUTHORS AND DISTRIBUTORS HAVE NO OBLIGATION TO PROVIDE
 *	MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 *	GOVERNMENT USE: If you are acquiring this software on behalf
 *	of the U.S. government, the Government shall have only
 *	"Restricted Rights" in the software and related documentation
 *	as defined in the Federal Acquisition Regulations (FARs) in
 *	Clause 52.227.19 (c) (2).  If you are acquiring the software
 *	on behalf of the Department of Defense, the software shall be
 *	classified as "Commercial Computer Software" and the
 *	Government shall have only "Restricted Rights" as defined in
 *	Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the
 *	foregoing, the authors grant the U.S. Government and others
 *	acting in its behalf permission to use and distribute the
 *	software in accordance with the terms specified in this
 *	license.
 *
 * RCS: @@(#) $Id: tkMacOSXWindowEvent.c,v 1.28 2007/07/09 08:31:55 das Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkMacOSXWm.h"
#include "tkMacOSXEvent.h"
#include "tkMacOSXDebug.h"

/*
#ifdef TK_MAC_DEBUG
#define TK_MAC_DEBUG_CLIP_REGIONS
#endif
*/

/*
 * Declaration of functions used only in this file
 */

static int GenerateUpdateEvent(Window window);
static int GenerateUpdates(RgnHandle updateRgn, Rect *updateBounds,
	TkWindow *winPtr);
static int GenerateActivateEvents(Window window, int activeFlag);
static void ClearPort(CGrafPtr port, RgnHandle updateRgn);


/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXProcessApplicationEvent --
 *
 *	This processes Application level events, mainly activate
 *	and deactivate.
 *
 * Results:
 *	0.
 *
 * Side effects:
 *	Hide or reveal floating windows.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE int
TkMacOSXProcessApplicationEvent(
	TkMacOSXEvent *eventPtr,
	MacEventStatus *statusPtr)
{
    Tcl_CmdInfo dummy;

    /*
     * This is a bit of a hack. We get "show" events both when we come back
     * from being hidden, and whenever we are activated. I only want to run
     * the "show" proc when we have been hidden already, not as a substitute
     * for <Activate>. So I use this toggle...
     */
    static int toggleHide = 0;

    switch (eventPtr->eKind) {
	case kEventAppActivated:
	    ShowFloatingWindows();
	    break;
	case kEventAppDeactivated:
	    TkSuspendClipboard();
	    HideFloatingWindows();
	    break;
	case kEventAppQuit:
	    statusPtr->stopProcessing = 1;
	    break;
	case kEventAppHidden:
	    if (toggleHide == 0) {
		toggleHide = 1;
		if (eventPtr->interp && Tcl_GetCommandInfo(eventPtr->interp,
			"::tk::mac::OnHide", &dummy)) {
		    Tcl_GlobalEval(eventPtr->interp, "::tk::mac::OnHide");
		}
	    }
	    statusPtr->stopProcessing = 1;
	    break;
	case kEventAppShown:
	    if (toggleHide == 1) {
		toggleHide = 0;
		if (eventPtr->interp && Tcl_GetCommandInfo(eventPtr->interp,
			"::tk::mac::OnShow", &dummy)) {
		    Tcl_GlobalEval(eventPtr->interp, "::tk::mac::OnShow");
		}
	    }
	    statusPtr->stopProcessing = 1;
	    break;
	case kEventAppAvailableWindowBoundsChanged: {
	    static UInt32 prevId = 0;
	    UInt32 id;
	    OSStatus err;

	    err = ChkErr(GetEventParameter, eventPtr->eventRef,
		    kEventParamTransactionID, typeUInt32,
		    NULL, sizeof(id), NULL, &id);
	    if (err != noErr || id != prevId) {
		TkDisplay *dispPtr = TkGetDisplayList();

		prevId = id;
		TkMacOSXDisplayChanged(dispPtr->display);
	    }
	    /*
	     * Should we call ::tk::mac::OnDisplayChanged?
	     */
	    break;
	}
	default:
	    break;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXProcessAppearanceEvent --
 *
 *	This processes Appearance events.
 *
 * Results:
 *	0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE int
TkMacOSXProcessAppearanceEvent(
	TkMacOSXEvent *eventPtr,
	MacEventStatus *statusPtr)
{
    switch (eventPtr->eKind) {
	case kEventAppearanceScrollBarVariantChanged:
	    TkMacOSXInitScrollbarMetrics();
	    break;
	default:
	    break;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXProcessWindowEvent --
 *
 *	This processes Window level events, mainly activate
 *	and deactivate.
 *
 * Results:
 *	0.
 *
 * Side effects:
 *	Cause Windows to be moved forward or backward in the
 *	window stack.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE int
TkMacOSXProcessWindowEvent(
	TkMacOSXEvent * eventPtr,
	MacEventStatus * statusPtr)
{
    OSStatus err;
    WindowRef whichWindow;
    Window window;
    int eventFound = false;
    TkDisplay *dispPtr;
    TkWindow *winPtr;

    switch (eventPtr->eKind) {
	case kEventWindowActivated:
	case kEventWindowDeactivated:
	case kEventWindowUpdate:
	case kEventWindowExpanded:
	case kEventWindowBoundsChanged:
	case kEventWindowDragStarted:
	case kEventWindowDragCompleted:
	case kEventWindowConstrain:
	case kEventWindowGetRegion:
	case kEventWindowDrawContent:
	    break;
	default:
	    return 0;
	    break;
    }
    err = ChkErr(GetEventParameter, eventPtr->eventRef,
	    kEventParamDirectObject, typeWindowRef, NULL, sizeof(whichWindow),
	    NULL, &whichWindow);
    if (err != noErr) {
	return 0;
    }

    window = TkMacOSXGetXWindow(whichWindow);
    dispPtr = TkGetDisplayList();
    winPtr = (TkWindow *)Tk_IdToWindow(dispPtr->display, window);

    switch (eventPtr->eKind) {
	case kEventWindowActivated:
	case kEventWindowDeactivated:
	    if (window != None) {
		int activate = (eventPtr->eKind == kEventWindowActivated);

		eventFound |= GenerateActivateEvents(window, activate);
		eventFound |= TkMacOSXGenerateFocusEvent(window, activate);
		if (winPtr) {
		    TkMacOSXEnterExitFullscreen(winPtr, activate);
		}
		statusPtr->stopProcessing = 1;
	    }
	    break;
	case kEventWindowUpdate:
	    if (window != None && GenerateUpdateEvent(window)) {
		eventFound = true;
		statusPtr->stopProcessing = 1;
	    }
	    break;
	case kEventWindowExpanded:
	    if (winPtr) {
		TkpWmSetState(winPtr, TkMacOSXIsWindowZoomed(winPtr) ?
			ZoomState : NormalState);
	    }
	    break;
	case kEventWindowBoundsChanged:
	    if (winPtr) {
		WmInfo *wmPtr = winPtr->wmInfoPtr;
		UInt32 attr;
		Rect bounds;
		int x = -1, y = -1, width = -1, height = -1, flags = 0;

		ChkErr(GetEventParameter, eventPtr->eventRef,
			kEventParamAttributes, typeUInt32,
			NULL, sizeof(attr), NULL, &attr);
		ChkErr(GetEventParameter, eventPtr->eventRef,
			kEventParamCurrentBounds, typeQDRectangle,
			NULL, sizeof(bounds), NULL, &bounds);
		if (attr & kWindowBoundsChangeOriginChanged) {
		    x = bounds.left - wmPtr->xInParent;
		    y = bounds.top	- wmPtr->yInParent;
		    flags |= TK_LOCATION_CHANGED;
		}
		if (attr & kWindowBoundsChangeSizeChanged) {
		    width = bounds.right  - bounds.left;
		    height = bounds.bottom - bounds.top;
		    flags |= TK_SIZE_CHANGED;
		}
		TkMacOSXInvalClipRgns((Tk_Window) winPtr);
		TkMacOSXInvalidateWindow((MacDrawable *) window,
			TK_PARENT_WINDOW);
		TkGenWMConfigureEvent((Tk_Window)winPtr, x, y, width,
			height, flags);
		if (attr & kWindowBoundsChangeUserResize ||
			attr & kWindowBoundsChangeUserDrag) {
		    TkMacOSXRunTclEventLoop();
		}
		if (wmPtr->attributes & kWindowResizableAttribute) {
		    HIViewRef growBoxView;

		    err = HIViewFindByID(HIViewGetRoot(whichWindow),
			    kHIViewWindowGrowBoxID, &growBoxView);
		    if (err == noErr) {
			ChkErr(HIViewSetNeedsDisplay, growBoxView, true);
		    }
		}
	    }
	    break;
	case kEventWindowDragStarted:
	    if (!(TkMacOSXModifierState() & cmdKey)) { 
		TkMacOSXBringWindowForward(whichWindow);
	    }
	    TkMacOSXTrackingLoop(1);
	    break;
	case kEventWindowDragCompleted: {
	    Rect maxBounds, bounds, strWidths;
	    int h = 0, v = 0;

	    TkMacOSXTrackingLoop(0);
	    ChkErr(GetWindowGreatestAreaDevice, whichWindow,
		    kWindowDragRgn, NULL, &maxBounds);
	    ChkErr(GetWindowBounds, whichWindow, kWindowStructureRgn,
		    &bounds);
	    ChkErr(GetWindowStructureWidths, whichWindow, &strWidths);
	    if (bounds.left > maxBounds.right - strWidths.left) {
		h = maxBounds.right
			- (strWidths.left ? strWidths.left : 40)
			- bounds.left;
	    } else if (bounds.right < maxBounds.left
		    + strWidths.right) {
		h = maxBounds.left
			+ (strWidths.right ? strWidths.right : 40)
			- bounds.right;
	    }
	    if (bounds.top > maxBounds.bottom - strWidths.top) {
		v = maxBounds.bottom
			- (strWidths.top ? strWidths.top : 40)
			- bounds.top;
	    } else if (bounds.bottom < maxBounds.top
		    + strWidths.bottom) {
		v = maxBounds.top
			+ (strWidths.bottom ? strWidths.bottom : 40)
			- bounds.bottom;
	    } else if (strWidths.top && bounds.top < maxBounds.top) {
		v = maxBounds.top - bounds.top;
	    }
	    if (h || v) {
		OffsetRect(&bounds, h, v);
		ChkErr(SetWindowBounds, whichWindow,
		    kWindowStructureRgn, &bounds);
	    }
	    break;
	}
	case kEventWindowConstrain:
	    if (winPtr && (winPtr->wmInfoPtr->flags & WM_FULLSCREEN) &&
		    TkMacOSXMakeFullscreen(winPtr, whichWindow, 1,
		    NULL) == TCL_OK) {
		statusPtr->stopProcessing = 1;
	    }
	    break;
	case kEventWindowGetRegion:
	    if (winPtr && (winPtr->wmInfoPtr->flags & WM_TRANSPARENT)) {
		WindowRegionCode code;

		statusPtr->stopProcessing = (CallNextEventHandler(
			eventPtr->callRef, eventPtr->eventRef) == noErr);
		err = ChkErr(GetEventParameter, eventPtr->eventRef,
			kEventParamWindowRegionCode, typeWindowRegionCode,
			NULL, sizeof(code), NULL, &code);
		if (err == noErr && code == kWindowOpaqueRgn) {
		    RgnHandle rgn;

		    err = ChkErr(GetEventParameter, eventPtr->eventRef,
			    kEventParamRgnHandle, typeQDRgnHandle, NULL,
			    sizeof(rgn), NULL, &rgn);
		    if (err == noErr) {
			SetEmptyRgn(rgn);
			statusPtr->stopProcessing = 1;
		    }
		}
	    }
	    break;
	case kEventWindowDrawContent:
	    if (winPtr && (winPtr->wmInfoPtr->flags & WM_TRANSPARENT)) {
		CGrafPtr port;

		GetPort(&port);
		ClearPort(port, NULL);
	    }
	    break;
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * GenerateUpdateEvent --
 *
 *	Given a Macintosh window update event this function generates
 *	all the Expose XEvents needed by Tk.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Additional events may be place on the Tk event queue.
 *
 *----------------------------------------------------------------------
 */
static int
GenerateUpdateEvent(Window window)
{
    CGrafPtr destPort;
    WindowRef macWindow;
    TkDisplay *dispPtr;
    TkWindow  *winPtr;
    int result = 0;
    Rect updateBounds, bounds;

    dispPtr = TkGetDisplayList();
    winPtr = (TkWindow *)Tk_IdToWindow(dispPtr->display, window);

    if (winPtr ==NULL ){
	return result;
    }
    TkMacOSXCheckTmpQdRgnEmpty();
    destPort = TkMacOSXGetDrawablePort(window);
    macWindow = GetWindowFromPort(destPort);
    ChkErr(GetWindowRegion, macWindow, kWindowUpdateRgn, tkMacOSXtmpQdRgn);
    ChkErr(GetWindowBounds, macWindow, kWindowContentRgn, &bounds);
    OffsetRgn(tkMacOSXtmpQdRgn, -bounds.left, -bounds.top);
    SectRegionWithPortVisibleRegion(destPort, tkMacOSXtmpQdRgn);
    GetRegionBounds(tkMacOSXtmpQdRgn, &updateBounds);
#ifdef TK_MAC_DEBUG_CLIP_REGIONS
    TkMacOSXDebugFlashRegion(window, tkMacOSXtmpQdRgn);
#endif /* TK_MAC_DEBUG_CLIP_REGIONS */
    BeginUpdate(macWindow);
    if (winPtr->wmInfoPtr->flags & WM_TRANSPARENT) {
	ClearPort(destPort, tkMacOSXtmpQdRgn);
    }
    result = GenerateUpdates(tkMacOSXtmpQdRgn, &updateBounds, winPtr);
    EndUpdate(macWindow);
    SetEmptyRgn(tkMacOSXtmpQdRgn);
    if (result) {
	/*
	 * Ensure there are no pending idle-time redraws that could prevent
	 * the just posted Expose events from generating new redraws.
	 */

	Tcl_DoOneEvent(TCL_IDLE_EVENTS|TCL_DONT_WAIT);
    }
    return result;
 }

/*
 *----------------------------------------------------------------------
 *
 * GenerateUpdates --
 *
 *	Given a Macintosh update region and a Tk window this function
 *	geneates a X Expose event for the window if it is within the
 *	update region. The function will then recursivly have each
 *	damaged window generate Expose events for its child windows.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Additional events may be place on the Tk event queue.
 *
 *----------------------------------------------------------------------
 */

static int
GenerateUpdates(
    RgnHandle updateRgn,
    Rect *updateBounds,
    TkWindow *winPtr)
{
    TkWindow *childPtr;
    XEvent event;
    Rect bounds, damageBounds;
    static RgnHandle damageRgn = NULL;

    TkMacOSXWinBounds(winPtr, &bounds);
    if (bounds.top > updateBounds->bottom ||
	updateBounds->top > bounds.bottom ||
	bounds.left > updateBounds->right ||
	updateBounds->left > bounds.right) {
	return 0;
    }
    if (!RectInRgn(&bounds, updateRgn)) {
	return 0;
    }

    /*
     * Compute the bounding box of the area that the damage occured in.
     */

    if (damageRgn == NULL) {
	damageRgn = NewRgn();
    }
    RectRgn(damageRgn, &bounds);
    SectRgn(damageRgn, updateRgn, damageRgn);
    GetRegionBounds(damageRgn, &damageBounds);
    RectRgn(damageRgn, &bounds);
    UnionRgn(damageRgn, updateRgn, updateRgn);
    GetRegionBounds(updateRgn, updateBounds);
    SetEmptyRgn(damageRgn);

    event.xany.serial = Tk_Display(winPtr)->request;
    event.xany.send_event = false;
    event.xany.window = Tk_WindowId(winPtr);
    event.xany.display = Tk_Display(winPtr);
    event.type = Expose;
    event.xexpose.x = damageBounds.left - bounds.left;
    event.xexpose.y = damageBounds.top - bounds.top;
    event.xexpose.width = damageBounds.right - damageBounds.left;
    event.xexpose.height = damageBounds.bottom - damageBounds.top;
    event.xexpose.count = 0;
    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);

    /*
     * Generate updates for the children of this window
     */

    for (childPtr = winPtr->childList; childPtr != NULL;
	    childPtr = childPtr->nextPtr) {
	if (!Tk_IsMapped(childPtr) || Tk_IsTopLevel(childPtr)) {
	    continue;
	}
	GenerateUpdates(updateRgn, updateBounds, childPtr);
    }

    /*
     * Generate updates for any contained windows
     */

    if (Tk_IsContainer(winPtr)) {
	childPtr = TkpGetOtherWindow(winPtr);
	if (childPtr != NULL && Tk_IsMapped(childPtr)) {
	    GenerateUpdates(updateRgn, updateBounds, childPtr);
	}

	/*
	 * TODO: Here we should handle out of process embedding.
	 */
    }

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * GenerateActivateEvents --
 *
 *	Given a Macintosh window activate event this function generates all the
 *	X Activate events needed by Tk.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Additional events may be place on the Tk event queue.
 *
 *----------------------------------------------------------------------
 */

int
GenerateActivateEvents(
    Window window,		  /* Root X window for event. */
    int activeFlag )
{
    TkWindow *winPtr;
    TkDisplay *dispPtr;

    dispPtr = TkGetDisplayList();
    winPtr = (TkWindow *) Tk_IdToWindow(dispPtr->display, window);
    if (winPtr == NULL || winPtr->window == None) {
	return false;
    }

    TkGenerateActivateEvents(winPtr,activeFlag);
    return true;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGenerateFocusEvent --
 *
 *	Given a Macintosh window activate event this function generates all the
 *	X Focus events needed by Tk.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Additional events may be place on the Tk event queue.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE int
TkMacOSXGenerateFocusEvent(
    Window window,		/* Root X window for event. */
    int activeFlag )
{
    XEvent event;
    Tk_Window tkwin;
    TkDisplay *dispPtr;

    dispPtr = TkGetDisplayList();
    tkwin = Tk_IdToWindow(dispPtr->display, window);
    if (tkwin == NULL) {
	return false;
    }

    /*
     * Don't send focus events to windows of class help or to
     * windows with the kWindowNoActivatesAttribute.
     */
    if (((TkWindow *)tkwin)->wmInfoPtr->macClass == kHelpWindowClass ||
	    ((TkWindow *)tkwin)->wmInfoPtr->attributes &
		    kWindowNoActivatesAttribute) {
	return false;
    }

    /*
     * Generate FocusIn and FocusOut events. This event
     * is only sent to the toplevel window.
     */

    if (activeFlag) {
	event.xany.type = FocusIn;
    } else {
	event.xany.type = FocusOut;
    }

    event.xany.serial = dispPtr->display->request;
    event.xany.send_event = False;
    event.xfocus.display = dispPtr->display;
    event.xfocus.window = window;
    event.xfocus.mode = NotifyNormal;
    event.xfocus.detail = NotifyDetailNone;

    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
    return true;
}

/*
 *----------------------------------------------------------------------
 *
 * TkGenWMConfigureEvent --
 *
 *	Generate a ConfigureNotify event for Tk. Depending on the
 *	value of flag the values of width/height, x/y, or both may
 *	be changed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A ConfigureNotify event is sent to Tk.
 *
 *----------------------------------------------------------------------
 */

void
TkGenWMConfigureEvent(
    Tk_Window tkwin,
    int x,
    int y,
    int width,
    int height,
    int flags)
{
    XEvent event;
    WmInfo *wmPtr;
    TkWindow *winPtr = (TkWindow *) tkwin;

    if (tkwin == NULL) {
	return;
    }

    event.type = ConfigureNotify;
    event.xconfigure.serial = Tk_Display(tkwin)->request;
    event.xconfigure.send_event = False;
    event.xconfigure.display = Tk_Display(tkwin);
    event.xconfigure.event = Tk_WindowId(tkwin);
    event.xconfigure.window = Tk_WindowId(tkwin);
    event.xconfigure.border_width = winPtr->changes.border_width;
    event.xconfigure.override_redirect = winPtr->atts.override_redirect;
    if (winPtr->changes.stack_mode == Above) {
	event.xconfigure.above = winPtr->changes.sibling;
    } else {
	event.xconfigure.above = None;
    }

    if (!(flags & TK_LOCATION_CHANGED)) {
	x = Tk_X(tkwin);
	y = Tk_Y(tkwin);
    }
    if (!(flags & TK_SIZE_CHANGED)) {
	width = Tk_Width(tkwin);
	height = Tk_Height(tkwin);
    }
    event.xconfigure.x = x;
    event.xconfigure.y = y;
    event.xconfigure.width = width;
    event.xconfigure.height = height;

    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);

    /*
     * Update window manager information.
     */
    if (Tk_IsTopLevel(winPtr)) {
	wmPtr = winPtr->wmInfoPtr;
	if (flags & TK_LOCATION_CHANGED) {
	    wmPtr->x = x;
	    wmPtr->y = y;
	    wmPtr->flags &= ~(WM_NEGATIVE_X | WM_NEGATIVE_Y);
	}
	if ((flags & TK_SIZE_CHANGED) && !(wmPtr->flags & WM_SYNC_PENDING) &&
		((width != Tk_Width(tkwin)) || (height != Tk_Height(tkwin)))) {
	    if ((wmPtr->width == -1) && (width == winPtr->reqWidth)) {
		/*
		 * Don't set external width, since the user didn't change it
		 * from what the widgets asked for.
		 */
	    } else {
		if (wmPtr->gridWin != NULL) {
		    wmPtr->width = wmPtr->reqGridWidth
			+ (width - winPtr->reqWidth)/wmPtr->widthInc;
		    if (wmPtr->width < 0) {
			wmPtr->width = 0;
		    }
		} else {
		    wmPtr->width = width;
		}
	    }
	    if ((wmPtr->height == -1) && (height == winPtr->reqHeight)) {
		/*
		 * Don't set external height, since the user didn't change it
		 * from what the widgets asked for.
		 */
	    } else {
		if (wmPtr->gridWin != NULL) {
		    wmPtr->height = wmPtr->reqGridHeight
			+ (height - winPtr->reqHeight)/wmPtr->heightInc;
		    if (wmPtr->height < 0) {
			wmPtr->height = 0;
		    }
		} else {
		    wmPtr->height = height;
		}
	    }
	    wmPtr->configWidth = width;
	    wmPtr->configHeight = height;
	}
    }

    /*
     * Now set up the changes structure. Under X we wait for the
     * ConfigureNotify to set these values. On the Mac we know imediatly that
     * this is what we want - so we just set them. However, we need to
     * make sure the windows clipping region is marked invalid so the
     * change is visible to the subwindow.
     */
    winPtr->changes.x = x;
    winPtr->changes.y = y;
    winPtr->changes.width = width;
    winPtr->changes.height = height;
    TkMacOSXInvalClipRgns(tkwin);
}

/*
 *----------------------------------------------------------------------
 *
 * TkGenWMDestroyEvent --
 *
 *	Generate a WM Destroy event for Tk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A WM_PROTOCOL/WM_DELETE_WINDOW event is sent to Tk.
 *
 *----------------------------------------------------------------------
 */

void
TkGenWMDestroyEvent(
    Tk_Window tkwin)
{
    XEvent event;

    event.xany.serial = Tk_Display(tkwin)->request;
    event.xany.send_event = False;
    event.xany.display = Tk_Display(tkwin);

    event.xclient.window = Tk_WindowId(tkwin);
    event.xclient.type = ClientMessage;
    event.xclient.message_type = Tk_InternAtom(tkwin, "WM_PROTOCOLS");
    event.xclient.format = 32;
    event.xclient.data.l[0] = Tk_InternAtom(tkwin, "WM_DELETE_WINDOW");
    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
}

/*
 *----------------------------------------------------------------------
 *
 * TkWmProtocolEventProc --
 *
 *	This procedure is called by the Tk_HandleEvent whenever a
 *	ClientMessage event arrives whose type is "WM_PROTOCOLS".
 *	This procedure handles the message from the window manager
 *	in an appropriate fashion.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on what sort of handler, if any, was set up for the
 *	protocol.
 *
 *----------------------------------------------------------------------
 */

void
TkWmProtocolEventProc(
    TkWindow *winPtr,		/* Window to which the event was sent. */
    XEvent *eventPtr)		/* X event. */
{
    WmInfo *wmPtr;
    ProtocolHandler *protPtr;
    Tcl_Interp *interp;
    Atom protocol;
    int result;

    wmPtr = winPtr->wmInfoPtr;
    if (wmPtr == NULL) {
	return;
    }
    protocol = (Atom) eventPtr->xclient.data.l[0];
    for (protPtr = wmPtr->protPtr; protPtr != NULL;
		protPtr = protPtr->nextPtr) {
	if (protocol == protPtr->protocol) {
	    Tcl_Preserve((ClientData) protPtr);
	    interp = protPtr->interp;
	    Tcl_Preserve((ClientData) interp);
	    result = Tcl_GlobalEval(interp, protPtr->command);
	    if (result != TCL_OK) {
		Tcl_AddErrorInfo(interp, "\n    (command for \"");
		Tcl_AddErrorInfo(interp,
			Tk_GetAtomName((Tk_Window) winPtr, protocol));
		Tcl_AddErrorInfo(interp, "\" window manager protocol)");
		Tk_BackgroundError(interp);
	    }
	    Tcl_Release((ClientData) interp);
	    Tcl_Release((ClientData) protPtr);
	    return;
	}
    }

    /*
     * No handler was present for this protocol. If this is a
     * WM_DELETE_WINDOW message then just destroy the window.
     */

    if (protocol == Tk_InternAtom((Tk_Window) winPtr, "WM_DELETE_WINDOW")) {
	Tk_DestroyWindow((Tk_Window) winPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_MacOSXIsAppInFront --
 *
 *	Returns 1 if this app is the foreground app.
 *
 * Results:
 *	1 if app is in front, 0 otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tk_MacOSXIsAppInFront(void)
{
    OSStatus err;
    ProcessSerialNumber frontPsn, ourPsn = {0, kCurrentProcess};
    Boolean isFrontProcess = true;

    err = ChkErr(GetFrontProcess, &frontPsn);
    if (err == noErr) {
	ChkErr(SameProcess, &frontPsn, &ourPsn, &isFrontProcess);
    }
    
    return (isFrontProcess == true);
}

/*
 *----------------------------------------------------------------------
 *
 * ClearPort --
 *
 *	Clear (i.e. fill with transparent color) the given port.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
static void
ClearPort(
    CGrafPtr port,
    RgnHandle updateRgn)
{
    CGContextRef context;
    Rect bounds;
    CGRect rect;

    GetPortBounds(port, &bounds);
    QDBeginCGContext(port, &context);
    SyncCGContextOriginWithPort(context, port);
    CGContextConcatCTM(context, CGAffineTransformMake(1.0, 0.0, 0.0, -1.0, 0.0,
	    bounds.bottom - bounds.top));
    if (updateRgn) {
	ClipCGContextToRegion(context, &bounds, updateRgn);
    }
    rect = CGRectMake(0, 0, bounds.right, bounds.bottom);
    CGContextClearRect(context, rect);
    QDEndCGContext(port, &context);
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d57 1
a57 1
 * RCS: @@(#) $Id: tkMacOSXWindowEvent.c,v 1.21 2007/04/23 21:24:34 das Exp $
d60 1
a60 1
#include "tkMacOSXInt.h"
a71 10
 * Declarations of global variables defined in this file.
 */

static int tkMacOSXAppInFront = true;	/* Boolean variable for determining if
					 * we are the frontmost app. Only set
					 * in TkMacOSXProcessApplicationEvent
					 */
static RgnHandle gDamageRgn = NULL;

/*
d75 5
a79 4
static int GenerateUpdateEvent( Window window);
static int GenerateUpdates( RgnHandle updateRgn, TkWindow *winPtr);
static int GenerateActivateEvents( Window window, int activeFlag);
static void ClearPort(CGrafPtr port);
d94 1
a94 1
 *	Hide or reveal floating windows, and set tkMacOSXAppInFront.
a115 1
	    tkMacOSXAppInFront = true;
a119 1
	    tkMacOSXAppInFront = false;
d258 4
a261 4
    if (window != None) {
	switch (eventPtr->eKind) {
	    case kEventWindowActivated:
	    case kEventWindowDeactivated: {
a269 1
		break;
d271 52
a322 49
	    case kEventWindowUpdate:
		if (GenerateUpdateEvent(window)) {
		    eventFound = true;
		    statusPtr->stopProcessing = 1;
		}
		break;
	    case kEventWindowExpanded:
		if (winPtr) {
		    TkpWmSetState(winPtr, TkMacOSXIsWindowZoomed(winPtr) ?
			    ZoomState : NormalState);
		}
		break;
	    case kEventWindowBoundsChanged:
		if (winPtr) {
		    WmInfo *wmPtr = winPtr->wmInfoPtr;
		    UInt32 attr;
		    Rect bounds;
		    int x = -1, y = -1, width = -1, height = -1, flags = 0;

		    ChkErr(GetEventParameter, eventPtr->eventRef,
			    kEventParamAttributes, typeUInt32,
			    NULL, sizeof(attr), NULL, &attr);
		    ChkErr(GetEventParameter, eventPtr->eventRef,
			    kEventParamCurrentBounds, typeQDRectangle,
			    NULL, sizeof(bounds), NULL, &bounds);
		    if (attr & kWindowBoundsChangeOriginChanged) {
			x = bounds.left - wmPtr->xInParent;
			y = bounds.top	- wmPtr->yInParent;
			flags |= TK_LOCATION_CHANGED;
		    }
		    if (attr & kWindowBoundsChangeSizeChanged) {
			width = bounds.right  - bounds.left;
			height = bounds.bottom - bounds.top;
			flags |= TK_SIZE_CHANGED;
		    }
		    TkGenWMConfigureEvent((Tk_Window)winPtr, x, y, width,
			    height, flags);
		    if (attr & kWindowBoundsChangeUserResize ||
			    attr & kWindowBoundsChangeUserDrag) {
			TkMacOSXRunTclEventLoop();
		    }
		    if (wmPtr->attributes & kWindowResizableAttribute) {
			HIViewRef growBoxView;

			err = HIViewFindByID(HIViewGetRoot(whichWindow),
				kHIViewWindowGrowBoxID, &growBoxView);
			if (err == noErr) {
			    ChkErr(HIViewSetNeedsDisplay, growBoxView, true);
			}
d325 57
a381 10
		break;
	    case kEventWindowDragStarted:
		if (winPtr) {
		    TkMacOSXTrackingLoop(1);
		}
		break;
	    case kEventWindowDragCompleted:
		if (winPtr) {
		    Rect maxBounds, bounds, strWidths;
		    int h = 0, v = 0;
d383 7
a389 47
		    TkMacOSXTrackingLoop(0);
		    ChkErr(GetWindowGreatestAreaDevice, whichWindow,
			    kWindowDragRgn, NULL, &maxBounds);
		    ChkErr(GetWindowBounds, whichWindow, kWindowStructureRgn,
			    &bounds);
		    ChkErr(GetWindowStructureWidths, whichWindow, &strWidths);
		    if (bounds.left > maxBounds.right - strWidths.left) {
			h = maxBounds.right
				- (strWidths.left ? strWidths.left : 40)
				- bounds.left;
		    } else if (bounds.right < maxBounds.left
			    + strWidths.right) {
			h = maxBounds.left
				+ (strWidths.right ? strWidths.right : 40)
				- bounds.right;
		    }
		    if (bounds.top > maxBounds.bottom - strWidths.top) {
			v = maxBounds.bottom
				- (strWidths.top ? strWidths.top : 40)
				- bounds.top;
		    } else if (bounds.bottom < maxBounds.top
			    + strWidths.bottom) {
			v = maxBounds.top
				+ (strWidths.bottom ? strWidths.bottom : 40)
				- bounds.bottom;
		    } else if (strWidths.top && bounds.top < maxBounds.top) {
			v = maxBounds.top - bounds.top;
		    }
		    if (h || v) {
			OffsetRect(&bounds, h, v);
			ChkErr(SetWindowBounds, whichWindow,
			    kWindowStructureRgn, &bounds);
		    }
		}
		break;
	    case kEventWindowConstrain:
		if (winPtr) {
		    if (winPtr->wmInfoPtr->flags & WM_FULLSCREEN &&
			    TkMacOSXMakeFullscreen(winPtr, whichWindow, 1,
			    NULL) == TCL_OK) {
			statusPtr->stopProcessing = 1;
		    }
		}
		break;
	    case kEventWindowGetRegion:
		if (winPtr && (winPtr->wmInfoPtr->flags & WM_TRANSPARENT)) {
		    WindowRegionCode code;
a390 2
		    statusPtr->stopProcessing = (CallNextEventHandler(
			    eventPtr->callRef, eventPtr->eventRef) == noErr);
d392 5
a396 12
			    kEventParamWindowRegionCode, typeWindowRegionCode,
			    NULL, sizeof(code), NULL, &code);
		    if (err == noErr && code == kWindowOpaqueRgn) {
			RgnHandle rgn;

			err = ChkErr(GetEventParameter, eventPtr->eventRef,
				kEventParamRgnHandle, typeQDRgnHandle, NULL,
				sizeof(rgn), NULL, &rgn);
			if (err == noErr) {
			    SetEmptyRgn(rgn);
			    statusPtr->stopProcessing = 1;
			}
d399 5
a403 4
		break;
	    case kEventWindowDrawContent:
		if (winPtr && (winPtr->wmInfoPtr->flags & WM_TRANSPARENT)) {
		    CGrafPtr port;
d405 4
a408 5
		    GetPort(&port);
		    ClearPort(port);
		}
		break;
	}
d410 1
d433 6
a438 5
    CGrafPtr	destPort;
    WindowRef	macWindow;
    TkDisplay * dispPtr;
    TkWindow  * winPtr;
    int		result = 0;
d446 1
a446 4
    if (gDamageRgn == NULL) {
	gDamageRgn = NewRgn();
    }
    TkMacOSXCheckTmpRgnEmpty(1);
d449 5
a453 3
    GetWindowRegion(macWindow, kWindowUpdateRgn, tkMacOSXtmpRgn1);
    QDGlobalToLocalRegion(destPort, tkMacOSXtmpRgn1);
    SectRegionWithPortVisibleRegion(destPort, tkMacOSXtmpRgn1);
d455 1
a455 6
    TkMacOSXInitNamedDebugSymbol(HIToolbox, int, QDDebugFlashRegion,
				CGrafPtr port, RgnHandle region);
    if (QDDebugFlashRegion) {
	/* Carbon-internal region flashing SPI (c.f. Technote 2124) */
	QDDebugFlashRegion(destPort, tkMacOSXtmpRgn1);
    }
d459 1
a459 1
	ClearPort(destPort);
d461 1
a461 1
    result = GenerateUpdates(tkMacOSXtmpRgn1, winPtr);
d463 9
a471 2
    SetEmptyRgn(tkMacOSXtmpRgn1);
    SetEmptyRgn(gDamageRgn);
d497 1
d502 2
a503 1
    Rect bounds, updateBounds, damageBounds;
d506 4
a509 7
    GetRegionBounds(updateRgn,&updateBounds);

    if (bounds.top > updateBounds.bottom ||
	updateBounds.top > bounds.bottom ||
	bounds.left > updateBounds.right ||
	updateBounds.left > bounds.right ||
	!RectInRgn(&bounds, updateRgn)) {
d516 15
a534 1

d536 4
a539 17

    /*
     * Compute the bounding box of the area that the damage occured in.
     */

    /*
     * CopyRgn(TkMacOSXVisableClipRgn(winPtr), rgn);
     * TODO: this call doesn't work doing resizes!!!
     */
    RectRgn(gDamageRgn, &bounds);
    SectRgn(gDamageRgn, updateRgn, gDamageRgn);
    OffsetRgn(gDamageRgn, -bounds.left, -bounds.top);
    GetRegionBounds(gDamageRgn,&damageBounds);
    event.xexpose.x = damageBounds.left;
    event.xexpose.y = damageBounds.top;
    event.xexpose.width = damageBounds.right-damageBounds.left;
    event.xexpose.height = damageBounds.bottom-damageBounds.top;
a540 1

d548 1
a548 1
				       childPtr = childPtr->nextPtr) {
d552 1
a552 2

	GenerateUpdates(updateRgn, childPtr);
d562 1
a562 1
	    GenerateUpdates(updateRgn, childPtr);
d566 1
a566 1
	 * NOTE: Here we should handle out of process embedding.
a567 1

d916 1
a916 1
Tk_MacOSXIsAppInFront (void)
d918 10
a927 1
    return tkMacOSXAppInFront;
d946 4
a949 1
ClearPort(CGrafPtr port) {
d956 6
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d5 1
a5 1
 *      Window Manager class events for Tk.
d8 1
a8 1
 * Copyright (c) 2005 Daniel A. Steffen <das@@users.sourceforge.net>
d13 43
a55 43
 *      The following terms apply to all files originating from Apple
 *      Computer, Inc. ("Apple") and associated with the software
 *      unless explicitly disclaimed in individual files.
 *
 *
 *      Apple hereby grants permission to use, copy, modify,
 *      distribute, and license this software and its documentation
 *      for any purpose, provided that existing copyright notices are
 *      retained in all copies and that this notice is included
 *      verbatim in any distributions. No written agreement, license,
 *      or royalty fee is required for any of the authorized
 *      uses. Modifications to this software may be copyrighted by
 *      their authors and need not follow the licensing terms
 *      described here, provided that the new terms are clearly
 *      indicated on the first page of each file where they apply.
 *
 *
 *      IN NO EVENT SHALL APPLE, THE AUTHORS OR DISTRIBUTORS OF THE
 *      SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 *      INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
 *      THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 *      EVEN IF APPLE OR THE AUTHORS HAVE BEEN ADVISED OF THE
 *      POSSIBILITY OF SUCH DAMAGE.  APPLE, THE AUTHORS AND
 *      DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES, INCLUDING,
 *      BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 *      FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS
 *      SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, AND APPLE,THE
 *      AUTHORS AND DISTRIBUTORS HAVE NO OBLIGATION TO PROVIDE
 *      MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 *      GOVERNMENT USE: If you are acquiring this software on behalf
 *      of the U.S. government, the Government shall have only
 *      "Restricted Rights" in the software and related documentation
 *      as defined in the Federal Acquisition Regulations (FARs) in
 *      Clause 52.227.19 (c) (2).  If you are acquiring the software
 *      on behalf of the Department of Defense, the software shall be
 *      classified as "Commercial Computer Software" and the
 *      Government shall have only "Restricted Rights" as defined in
 *      Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the
 *      foregoing, the authors grant the U.S. Government and others
 *      acting in its behalf permission to use and distribute the
 *      software in accordance with the terms specified in this
 *      license.
d57 1
a57 1
 * RCS: @@(#) $Id: tkMacOSXWindowEvent.c,v 1.16 2006/09/10 17:06:32 das Exp $
d66 6
d75 2
a76 2
static int tkMacOSXAppInFront = true;	/* Boolean variable for determining if 
					 * we are the frontmost app.  Only set 
d79 1
a79 2
static RgnHandle gDamageRgn;
static RgnHandle visRgn;
d84 1
a84 1
 
d86 1
a86 1
static void GenerateUpdates( RgnHandle updateRgn, TkWindow *winPtr);
d88 1
d90 1
a90 1

d96 2
a97 2
 *        This processes Application level events, mainly activate
 *        and deactivate.
d100 1
a100 1
 *        o.
d103 1
a103 1
 *        Hide or reveal floating windows, and set tkMacOSXAppInFront.
d107 1
a107 1
 
d110 2
a111 2
        TkMacOSXEvent *eventPtr, 
        MacEventStatus *statusPtr)
d116 2
a117 2
     * This is a bit of a hack.  We get "show" events both when we come back
     * from being hidden, and whenever we are activated.  I only want to run
d119 1
a119 1
     * for <Activate>.  So I use this toggle...
d124 32
a155 32
        case kEventAppActivated:
            tkMacOSXAppInFront = true;
            ShowFloatingWindows();
            break;
        case kEventAppDeactivated:
            TkSuspendClipboard();
            tkMacOSXAppInFront = false;
            HideFloatingWindows();
            break;
        case kEventAppQuit:
            statusPtr->stopProcessing = 1;
            break;
        case kEventAppHidden:
            if (toggleHide == 0) {
                toggleHide = 1;
                if (eventPtr->interp && Tcl_GetCommandInfo(eventPtr->interp, 
                        "::tk::mac::OnHide", &dummy)) {
                    Tcl_GlobalEval(eventPtr->interp, "::tk::mac::OnHide");
                }
            }
            statusPtr->stopProcessing = 1;
            break;
        case kEventAppShown:
            if (toggleHide == 1) {
                toggleHide = 0;
                if (eventPtr->interp && Tcl_GetCommandInfo(eventPtr->interp, 
                        "::tk::mac::OnShow", &dummy)) {
                    Tcl_GlobalEval(eventPtr->interp, "::tk::mac::OnShow");
                }
            }
            statusPtr->stopProcessing = 1;
            break;
d157 13
a169 2
            TkDisplay *dispPtr = TkGetDisplayList();
            TkMacOSXDisplayChanged(dispPtr->display);
d175 33
a207 2
        default:
            break;
d211 2
a212 1
/*
d217 2
a218 2
 *        This processes Window level events, mainly activate
 *        and deactivate.
d221 1
a221 1
 *        0.
d224 2
a225 2
 *        Cause Windows to be moved forward or backward in the 
 *        window stack.
d232 4
a235 4
        TkMacOSXEvent * eventPtr, 
        MacEventStatus * statusPtr)
{ 
    OSStatus  status;
d237 26
a262 23
    Window    window;
    int       eventFound = false;
    
    switch (eventPtr->eKind) { 
        case kEventWindowActivated:
        case kEventWindowDeactivated:
        case kEventWindowUpdate:
        case kEventWindowExpanded:
            break;
        default:
            return 0;
            break;
    }
    status = GetEventParameter(eventPtr->eventRef,
            kEventParamDirectObject,
            typeWindowRef, NULL,
            sizeof(whichWindow), NULL,
            &whichWindow);
    if (status != noErr) {
#ifdef TK_MAC_DEBUG
        fprintf ( stderr, "TkMacOSXHandleWindowEvent:Failed to retrieve window" );
#endif
        return 0;
d264 1
a264 1
    
d266 2
d269 151
a419 25
    switch (eventPtr->eKind) {
        case kEventWindowActivated:
            eventFound |= GenerateActivateEvents(window, 1);
            eventFound |= TkMacOSXGenerateFocusEvent(window, 1);
            break;
        case kEventWindowDeactivated:
            eventFound |= GenerateActivateEvents(window, 0);
            eventFound |= TkMacOSXGenerateFocusEvent(window, 0);
            break;
        case kEventWindowUpdate:
            if (GenerateUpdateEvent(window)) {
                eventFound = true;
            }
            break;
        case kEventWindowExpanded: {
            TkDisplay *dispPtr;
            TkWindow  *winPtr;
            dispPtr = TkGetDisplayList();
            winPtr = (TkWindow *)Tk_IdToWindow(dispPtr->display, window);
            if (winPtr) {
		TkpWmSetState(winPtr, TkMacOSXIsWindowZoomed(winPtr) ?
			ZoomState : NormalState);
            }
            break;
        }
d429 2
a430 2
 *      Given a Macintosh window update event this function generates all the
 *      X update events needed by Tk.
d432 2
a433 2
 * Results:     
 *      True if event(s) are generated - false otherwise.
d436 2
a437 2
 *      Additional events may be place on the Tk event queue.
 *          
d439 1
a439 1
 */     
d443 2
a444 1
    WindowRef   macWindow;
d447 2
a448 2
    Rect        bounds;
    
d451 1
a451 1
 
d453 1
a453 1
        return false;
d456 1
a456 1
        gDamageRgn = NewRgn();
d458 12
a469 2
    if (visRgn == NULL) {
        visRgn = NewRgn();
d471 1
a471 1
    macWindow = GetWindowFromPort(TkMacOSXGetDrawablePort(window));
d473 4
a476 14
    /*
     * In the Classic version of the code, this was the "visRgn" field of the WindowRec
     * This no longer exists in OS X, so retrieve the content region instead
     * Note that this is in screen coordinates
     * We therefore convert it to window relative coordinates
     */
    GetWindowRegion (macWindow, kWindowContentRgn, visRgn );
    GetRegionBounds(visRgn,&bounds);
    bounds.right -= bounds.left;
    bounds.bottom -= bounds.top;
    bounds.left = 0;
    bounds.top=0;
    RectRgn(visRgn, &bounds);
    GenerateUpdates(visRgn, winPtr);
d478 3
a480 1
    return true;
d488 4
a491 4
 *        Given a Macintosh update region and a Tk window this function
 *        geneates a X damage event for the window if it is within the
 *        update region.  The function will then recursivly have each
 *        damaged window generate damage events for its child windows.
d494 1
a494 1
 *        None.
d497 1
a497 1
 *        Additional events may be place on the Tk event queue.
d502 1
a502 1
static void
d513 1
a513 1
        
d515 5
a519 5
        updateBounds.top > bounds.bottom ||
        bounds.left > updateBounds.right ||
        updateBounds.left > bounds.right ||
        !RectInRgn(&bounds, updateRgn)) {
        return;
d522 1
a522 1
        return;
d529 1
a529 1
        
d532 1
a532 1
    /* 
d549 1
a549 1
    
d555 1
a555 1
     
d557 4
a560 4
                                       childPtr = childPtr->nextPtr) {
        if (!Tk_IsMapped(childPtr) || Tk_IsTopLevel(childPtr)) {
            continue;
        }
d562 1
a562 1
        GenerateUpdates(updateRgn, childPtr);
d564 1
a564 1
    
d570 8
a577 10
        childPtr = TkpGetOtherWindow(winPtr);
        if (childPtr != NULL && Tk_IsMapped(childPtr)) {
            GenerateUpdates(updateRgn, childPtr);
        }
            
        /*
         * NOTE: Here we should handle out of process embedding.
         */
                    
    }        
d579 3
a581 1
    return;
d584 1
a584 1
/*         
d586 1
a586 1
 *                      
a587 3
 *                      
 *      Given a Macintosh window activate event this function generates all the
 *      X Activate events needed by Tk.
d589 5
a593 2
 * Results:     
 *      True if event(s) are generated - false otherwise.
d596 2
a597 2
 *      Additional events may be place on the Tk event queue.
 *          
d600 1
a600 1
    
d603 2
a604 2
    Window window,                /* Root X window for event. */
    int    activeFlag )
d608 1
a608 1
    
d612 1
a612 1
        return false;
d619 1
a619 1
/*         
d621 1
a621 1
 *                      
a622 3
 *                      
 *      Given a Macintosh window activate event this function generates all the
 *      X Focus events needed by Tk.
d624 5
a628 2
 * Results:     
 *      True if event(s) are generated - false otherwise.
d631 2
a632 2
 *      Additional events may be place on the Tk event queue.
 *          
d634 1
a634 1
 */     
d638 2
a639 2
    Window window,              /* Root X window for event. */
    int    activeFlag )
d648 1
a648 1
        return false;
d662 1
a662 1
     * Generate FocusIn and FocusOut events.  This event
d667 1
a667 1
        event.xany.type = FocusIn;
d669 1
a669 1
        event.xany.type = FocusOut;
d682 1
a682 1

d688 1
a688 1
 *	Generate a ConfigureNotify event for Tk.  Depending on the 
d713 1
a713 1
    
d717 1
a717 1
    
d732 1
a732 6
    if (flags & TK_LOCATION_CHANGED) {
	event.xconfigure.x = x;
	event.xconfigure.y = y;
    } else {
	event.xconfigure.x = Tk_X(tkwin);
	event.xconfigure.y = Tk_Y(tkwin);
d736 1
a736 6
    if (flags & TK_SIZE_CHANGED) {
	event.xconfigure.width = width;
	event.xconfigure.height = height;
    } else {
	event.xconfigure.width = Tk_Width(tkwin);
	event.xconfigure.height = Tk_Height(tkwin);
d740 5
a744 1
    
d746 1
a746 1
    
d757 1
a757 1
	if ((flags & TK_SIZE_CHANGED) && 
d795 1
a795 1
    
d797 3
a799 3
     * Now set up the changes structure.  Under X we wait for the
     * ConfigureNotify to set these values.  On the Mac we know imediatly that
     * this is what we want - so we just set them.  However, we need to
d809 1
a809 1

d815 2
a816 1
 *	Generate a WM Destroy event for Tk.   *
d831 1
a831 1
    
d835 1
a835 1
	
d843 1
a843 1

d881 1
a881 1
				   protPtr = protPtr->nextPtr) {
d884 2
a885 2
            interp = protPtr->interp;
            Tcl_Preserve((ClientData) interp);
d894 1
a894 1
            Tcl_Release((ClientData) interp);
d901 1
a901 1
     * No handler was present for this protocol.  If this is a
d909 1
a909 1

d915 1
a915 1
 *	Returns 1 if this app is the foreground app. 
d931 28
@

