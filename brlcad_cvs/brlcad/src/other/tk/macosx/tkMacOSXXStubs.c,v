head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.46;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.56;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXXStubs.c --
 *
 *	This file contains most of the X calls called by Tk. Many of
 *	these calls are just stubs and either don't make sense on the
 *	Macintosh or thier implamentation just doesn't do anything. Other
 *	calls will eventually be moved into other files.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXXStubs.c,v 1.23 2007/07/04 17:32:39 andreas_kupries Exp $
 */

#include "tkMacOSXPrivate.h"
#include "tkMacOSXEvent.h"

#include <IOKit/IOKitLib.h>

/*
 * Because this file is still under major development Debugger statements are
 * used through out this file. The define TCL_DEBUG will decide whether
 * the debugger statements actually call the debugger or not.
 */

#ifndef TCL_DEBUG
#   define Debugger()
#endif

#define ROOT_ID 10

/*
 * Declarations of static variables used in this file.
 */

static TkDisplay *gMacDisplay = NULL; /* Macintosh display. */
static const char *macScreenName = ":0"; /* Default name of macintosh display. */

/*
 * Forward declarations of procedures used in this file.
 */

static XID MacXIdAlloc(Display *display);
static int DefaultErrorHandler(Display* display, XErrorEvent* err_evt);

/*
 * Other declarations
 */

static int DestroyImage(XImage *image);
static unsigned long ImageGetPixel(XImage *image, int x, int y);
static int PutPixel(XImage *image, int x, int y, unsigned long pixel);
#if 0
static XImage *SubImage(XImage *image, int x, int y,
	unsigned int width, unsigned int height);
static int AddPixel(XImage *image, long value);
#endif


/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXDisplayChanged --
 *
 *	Called to set up initial screen info or when an event indicated
 *	display (screen) change.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May change info regarding the screen.
 *
 *----------------------------------------------------------------------
 */

void
TkMacOSXDisplayChanged(Display *display)
{
    GDHandle graphicsDevice;
    Screen *screen;
    Rect bounds = {0, 0, 0, 0}, *maxBounds;

    if (display == NULL || display->screens == NULL) {
	return;
    }
    screen = display->screens;

    graphicsDevice = GetMainDevice();
    screen->root_depth	= (*(*graphicsDevice)->gdPMap)->cmpSize *
			       (*(*graphicsDevice)->gdPMap)->cmpCount;
    screen->height	= (*graphicsDevice)->gdRect.bottom -
	(*graphicsDevice)->gdRect.top;
    screen->width	= (*graphicsDevice)->gdRect.right -
	(*graphicsDevice)->gdRect.left;

    screen->mwidth	= (screen->width * 254 + 360) / 720;
    screen->mheight	= (screen->height * 254 + 360) / 720;

    maxBounds = (Rect*) screen->ext_data;
    *maxBounds = bounds;
    graphicsDevice = GetDeviceList();
    while (graphicsDevice) {
	OSStatus err;

	err = ChkErr(GetAvailableWindowPositioningBounds, graphicsDevice,
		&bounds);
	if (err == noErr) {
	    UnionRect(&bounds, maxBounds, maxBounds);
	}
	graphicsDevice = GetNextDevice(graphicsDevice);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpOpenDisplay --
 *
 *	Create the Display structure and fill it with device
 *	specific information.
 *
 * Results:
 *	Returns a Display structure on success or NULL on failure.
 *
 * Side effects:
 *	Allocates a new Display structure.
 *
 *----------------------------------------------------------------------
 */

TkDisplay *
TkpOpenDisplay(
    CONST char *display_name)
{
    Display *display;
    Screen *screen;
    int fd = 0;
    static Rect maxBounds = {0, 0, 0, 0};

    if (gMacDisplay != NULL) {
	if (strcmp(gMacDisplay->display->display_name, display_name) == 0) {
	    return gMacDisplay;
	} else {
	    return NULL;
	}
    }

    display = (Display *) ckalloc(sizeof(Display));
    screen  = (Screen *) ckalloc(sizeof(Screen));
    bzero(display, sizeof(Display));
    bzero(screen, sizeof(Screen));

    display->resource_alloc = MacXIdAlloc;
    display->request	    = 0;
    display->qlen	    = 0;
    display->fd		    = fd;
    display->screens	    = screen;
    display->nscreens	    = 1;
    display->default_screen = 0;
    display->display_name   = (char*)macScreenName;

    Gestalt(gestaltQuickdrawVersion, (long*)&display->proto_minor_version);
    display->proto_major_version = 10;
    display->proto_minor_version -= gestaltMacOSXQD;
    display->vendor = "Apple";
    Gestalt(gestaltSystemVersion, (long*)&display->release);

    /*
     * These screen bits never change
     */
    screen->root	= ROOT_ID;
    screen->display	= display;
    screen->black_pixel = 0x00000000 | PIXEL_MAGIC << 24;
    screen->white_pixel = 0x00FFFFFF | PIXEL_MAGIC << 24;
    screen->ext_data	= (XExtData*) &maxBounds;

    screen->root_visual = (Visual *) ckalloc(sizeof(Visual));
    screen->root_visual->visualid     = 0;
    screen->root_visual->class	      = TrueColor;
    screen->root_visual->red_mask     = 0x00FF0000;
    screen->root_visual->green_mask   = 0x0000FF00;
    screen->root_visual->blue_mask    = 0x000000FF;
    screen->root_visual->bits_per_rgb = 24;
    screen->root_visual->map_entries  = 256;

    /*
     * Initialize screen bits that may change
     */
    TkMacOSXDisplayChanged(display);

    gMacDisplay = (TkDisplay *) ckalloc(sizeof(TkDisplay));

    /*
     * This is the quickest way to make sure that all the *Init
     * flags get properly initialized
     */

    bzero(gMacDisplay, sizeof(TkDisplay));
    gMacDisplay->display = display;
    return gMacDisplay;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpCloseDisplay --
 *
 *	Deallocates a display structure created by TkpOpenDisplay.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees memory.
 *
 *----------------------------------------------------------------------
 */

void
TkpCloseDisplay(
    TkDisplay *displayPtr)
{
    Display *display = displayPtr->display;
    if (gMacDisplay != displayPtr) {
	Tcl_Panic("TkpCloseDisplay: tried to call TkpCloseDisplay on bad display");
    }

    gMacDisplay = NULL;
    if (display->screens != (Screen *) NULL) {
	if (display->screens->root_visual != (Visual *) NULL) {
	    ckfree((char *) display->screens->root_visual);
	}
	ckfree((char *) display->screens);
    }
    ckfree((char *) display);
}

/*
 *----------------------------------------------------------------------
 *
 * TkClipCleanup --
 *
 *	This procedure is called to cleanup resources associated with
 *	claiming clipboard ownership and for receiving selection get
 *	results. This function is called in tkWindow.c. This has to be
 *	called by the display cleanup function because we still need the
 *	access display elements.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Resources are freed - the clipboard may no longer be used.
 *
 *----------------------------------------------------------------------
 */

void
TkClipCleanup(dispPtr)
    TkDisplay *dispPtr; /* display associated with clipboard */
{
    /*
     * Make sure that the local scrap is transfered to the global
     * scrap if needed.
     */

    TkSuspendClipboard();

    if (dispPtr->clipWindow != NULL) {
	Tk_DeleteSelHandler(dispPtr->clipWindow, dispPtr->clipboardAtom,
		dispPtr->applicationAtom);
	Tk_DeleteSelHandler(dispPtr->clipWindow, dispPtr->clipboardAtom,
		dispPtr->windowAtom);

	Tk_DestroyWindow(dispPtr->clipWindow);
	Tcl_Release((ClientData) dispPtr->clipWindow);
	dispPtr->clipWindow = NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * MacXIdAlloc --
 *
 *	This procedure is invoked by Xlib as the resource allocator
 *	for a display.
 *
 * Results:
 *	The return value is an X resource identifier that isn't currently
 *	in use.
 *
 * Side effects:
 *	The identifier is removed from the stack of free identifiers,
 *	if it was previously on the stack.
 *
 *----------------------------------------------------------------------
 */

static XID
MacXIdAlloc(
    Display *display)			/* Display for which to allocate. */
{
	static long int cur_id = 100;
	/*
	 * Some special XIds are reserved
	 *   - this is why we start at 100
	 */

	return ++cur_id;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpWindowWasRecentlyDeleted --
 *
 *	Tries to determine whether the given window was recently deleted.
 *	Called from the generic code error handler to attempt to deal with
 *	async BadWindow errors under some circumstances.
 *
 * Results:
 *	Always 0, we do not keep this information on the Mac, so we do not
 *	know whether the window was destroyed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkpWindowWasRecentlyDeleted(
    Window win,
    TkDisplay *dispPtr)
{
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * DefaultErrorHandler --
 *
 *	This procedure is the default X error handler. Tk uses it's
 *	own error handler so this call should never be called.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	This function will call panic and exit.
 *
 *----------------------------------------------------------------------
 */

static int
DefaultErrorHandler(
    Display* display,
    XErrorEvent* err_evt)
{
    /*
     * This call should never be called. Tk replaces
     * it with its own error handler.
     */
    Tcl_Panic("Warning hit bogus error handler!");
    return 0;
}


char *
XGetAtomName(
    Display * display,
    Atom atom)
{
    display->request++;
    return NULL;
}

int
_XInitImageFuncPtrs(XImage *image)
{
    return 0;
}

XErrorHandler
XSetErrorHandler(
    XErrorHandler handler)
{
    return DefaultErrorHandler;
}

Window
XRootWindow(Display *display, int screen_number)
{
    display->request++;
    return ROOT_ID;
}

int
XGetGeometry(display, d, root_return, x_return, y_return, width_return,
	height_return, border_width_return, depth_return)
    Display* display;
    Drawable d;
    Window* root_return;
    int* x_return;
    int* y_return;
    unsigned int* width_return;
    unsigned int* height_return;
    unsigned int* border_width_return;
    unsigned int* depth_return;
{
    TkWindow *winPtr = ((MacDrawable *) d)->winPtr;

    display->request++;
    *root_return = ROOT_ID;
    if (winPtr) {
	*x_return = Tk_X(winPtr);
	*y_return = Tk_Y(winPtr);
	*width_return = Tk_Width(winPtr);
	*height_return = Tk_Height(winPtr);
	*border_width_return = winPtr->changes.border_width;
	*depth_return = Tk_Depth(winPtr);
    } else {
	Rect boundsRect;
	CGrafPtr destPort = TkMacOSXGetDrawablePort(d);

	GetPortBounds(destPort, &boundsRect);
	*x_return = boundsRect.left;
	*y_return =  boundsRect.top;
	*width_return = boundsRect.right - boundsRect.left;
	*height_return = boundsRect.bottom - boundsRect.top;
	*border_width_return = 0;
	*depth_return = 32;
    }
    return 1;
}

void
XChangeProperty(
    Display* display,
    Window w,
    Atom property,
    Atom type,
    int format,
    int mode,
    _Xconst unsigned char* data,
    int nelements)
{
    Debugger();
}

void
XSelectInput(
    Display* display,
    Window w,
    long event_mask)
{
    Debugger();
}

void
XBell(
    Display* display,
    int percent)
{
    SysBeep(percent);
}

#if 0
void
XSetWMNormalHints(
    Display* display,
    Window w,
    XSizeHints* hints)
{
    /*
     * Do nothing. Shouldn't even be called.
     */
}

XSizeHints *
XAllocSizeHints(void)
{
    /*
     * Always return NULL. Tk code checks to see if NULL
     * is returned & does nothing if it is.
     */

    return NULL;
}
#endif

GContext
XGContextFromGC(
    GC gc)
{
    /*
     * TODO: currently a no-op
     */

    return 0;
}

Status
XSendEvent(
    Display* display,
    Window w,
    Bool propagate,
    long event_mask,
    XEvent* event_send)
{
    Debugger();
    return 0;
}

void
XClearWindow(
    Display* display,
    Window w)
{
}

/*
void
XDrawPoint(
    Display* display,
    Drawable d,
    GC gc,
    int x,
    int y)
{
}

void
XDrawPoints(
    Display* display,
    Drawable d,
    GC gc,
    XPoint* points,
    int npoints,
    int mode)
{
}
*/

void
XWarpPointer(
    Display* display,
    Window src_w,
    Window dest_w,
    int src_x,
    int src_y,
    unsigned int src_width,
    unsigned int src_height,
    int dest_x,
    int dest_y)
{
}

void
XQueryColor(
    Display* display,
    Colormap colormap,
    XColor* def_in_out)
{
    unsigned long p;
    unsigned char r, g, b;
    XColor *d = def_in_out;

    p		= d->pixel;
    r		= (p & 0x00FF0000) >> 16;
    g		= (p & 0x0000FF00) >> 8;
    b		= (p & 0x000000FF);
    d->red	= (r << 8) | r;
    d->green	= (g << 8) | g;
    d->blue	= (b << 8) | b;
    d->flags	= DoRed|DoGreen|DoBlue;
    d->pad	= 0;
}

void
XQueryColors(
    Display* display,
    Colormap colormap,
    XColor* defs_in_out,
    int ncolors)
{
    int i;
    unsigned long p;
    unsigned char r, g, b;
    XColor *d = defs_in_out;

    for (i = 0; i < ncolors; i++, d++) {
	p		= d->pixel;
	r		= (p & 0x00FF0000) >> 16;
	g		= (p & 0x0000FF00) >> 8;
	b		= (p & 0x000000FF);
	d->red		= (r << 8) | r;
	d->green	= (g << 8) | g;
	d->blue		= (b << 8) | b;
	d->flags	= DoRed|DoGreen|DoBlue;
	d->pad		= 0;
    }
}

int
XQueryTree(display, w, root_return, parent_return, children_return,
	nchildren_return)
    Display* display;
    Window w;
    Window* root_return;
    Window* parent_return;
    Window** children_return;
    unsigned int* nchildren_return;
{
    return 0;
}


int
XGetWindowProperty(
    Display *display,
    Window w,
    Atom property,
    long long_offset,
    long long_length,
    Bool delete,
    Atom req_type,
    Atom *actual_type_return,
    int *actual_format_return,
    unsigned long *nitems_return,
    unsigned long *bytes_after_return,
    unsigned char ** prop_return)
{
    display->request++;
    *actual_type_return = None;
    *actual_format_return = *bytes_after_return = 0;
    *nitems_return = 0;
    return 0;
}

void
XRefreshKeyboardMapping( XMappingEvent* x)
{
    /* used by tkXEvent.c */
    Debugger();
}

void
XSetIconName(
    Display* display,
    Window w,
    const char *icon_name)
{
    /*
     * This is a no-op, no icon name for Macs.
     */
    display->request++;
}

void
XForceScreenSaver(
    Display* display,
    int mode)
{
    /*
     * This function is just a no-op. It is defined to
     * reset the screen saver. However, there is no real
     * way to do this on a Mac. Let me know if there is!
     */
    display->request++;
}

void
Tk_FreeXId(
    Display *display,
    XID xid)
{
    /* no-op function needed for stubs implementation. */
}

int
XSync(
    Display *display,
    Bool flag)
{
    TkMacOSXFlushWindows();
    display->request++;
    return 0;
}

#if 0
int
XSetClipRectangles(
    Display *d,
    GC gc,
    int clip_x_origin,
    int clip_y_origin,
    XRectangle* rectangles,
    int n,
    int ordering)
{
    TkRegion clipRgn;

    if (gc->clip_mask && ((TkpClipMask*)gc->clip_mask)->type
	    == TKP_CLIP_REGION) {
	clipRgn = ((TkpClipMask*)gc->clip_mask)->value.region;
	SetEmptyRgn((RgnHandle) clipRgn);
    } else {
	clipRgn = TkCreateRegion(); /* LEAK! */
    }

    while (n--) {
	XRectangle rect = *rectangles;
	
	rect.x += clip_x_origin;
	rect.y += clip_y_origin;
	TkUnionRectWithRegion(&rect, clipRgn, clipRgn);
	rectangles++;
    }
    TkSetRegion(d, gc, clipRgn);
    return 1;
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * TkGetServerInfo --
 *
 *	Given a window, this procedure returns information about
 *	the window server for that window. This procedure provides
 *	the guts of the "winfo server" command.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkGetServerInfo(
    Tcl_Interp *interp,		/* The server information is returned in
				 * this interpreter's result. */
    Tk_Window tkwin)		/* Token for window; this selects a
				 * particular display and server. */
{
    char buffer[8 + TCL_INTEGER_SPACE * 2];
    char buffer2[TCL_INTEGER_SPACE];

    sprintf(buffer, "QD%dR%x ", ProtocolVersion(Tk_Display(tkwin)),
	    ProtocolRevision(Tk_Display(tkwin)));
    sprintf(buffer2, " %x", VendorRelease(Tk_Display(tkwin)));
    Tcl_AppendResult(interp, buffer, ServerVendor(Tk_Display(tkwin)),
	    buffer2, NULL);
}

#pragma mark XImage handling
/*
 *----------------------------------------------------------------------
 *
 * XCreateImage --
 *
 *	Allocates storage for a new XImage.
 *
 * Results:
 *	Returns a newly allocated XImage.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

XImage *
XCreateImage(
    Display* display,
    Visual* visual,
    unsigned int depth,
    int format,
    int offset,
    char* data,
    unsigned int width,
    unsigned int height,
    int bitmap_pad,
    int bytes_per_line)
{
    XImage *ximage;

    display->request++;
    ximage = (XImage *) ckalloc(sizeof(XImage));

    ximage->height = height;
    ximage->width = width;
    ximage->depth = depth;
    ximage->xoffset = offset;
    ximage->format = format;
    ximage->data = data;

    if (format == ZPixmap) {
	ximage->bits_per_pixel = 32;
	ximage->bitmap_unit = 32;
    } else {
	ximage->bits_per_pixel = 1;
	ximage->bitmap_unit = 8;
    }
    if (bitmap_pad) {
	ximage->bitmap_pad = bitmap_pad;
    } else {
	/* Use 16 byte alignment for best Quartz perfomance */
	ximage->bitmap_pad = 128;
    }
    if (bytes_per_line) {
	ximage->bytes_per_line = bytes_per_line;
    } else {
	ximage->bytes_per_line = ((width * ximage->bits_per_pixel +
		(ximage->bitmap_pad - 1)) >> 3) &
		~((ximage->bitmap_pad >> 3) - 1);
    }
#ifdef WORDS_BIGENDIAN
    ximage->byte_order = MSBFirst;
    ximage->bitmap_bit_order = MSBFirst;
#else
    ximage->byte_order = LSBFirst;
    ximage->bitmap_bit_order = LSBFirst;
#endif
    ximage->red_mask = 0x00FF0000;
    ximage->green_mask = 0x0000FF00;
    ximage->blue_mask = 0x000000FF;
    ximage->obdata = NULL;
    ximage->f.create_image = NULL;
    ximage->f.destroy_image = DestroyImage;
    ximage->f.get_pixel = ImageGetPixel;
    ximage->f.put_pixel = PutPixel;
    ximage->f.sub_image = NULL;
    ximage->f.add_pixel = NULL;

    return ximage;
}

/*
 *----------------------------------------------------------------------
 *
 * XGetImage --
 *
 *	This function copies data from a pixmap or window into an XImage.
 *
 * Results:
 *	Returns a newly allocated image containing the data from the given
 *	rectangle of the given drawable.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

XImage *
XGetImage(
    Display *display,
    Drawable d,
    int x,
    int y,
    unsigned int width,
    unsigned int height,
    unsigned long plane_mask,
    int format)
{
    XImage *   imagePtr = NULL;
    Pixmap     pixmap = (Pixmap) NULL;
    Tk_Window  win = (Tk_Window) ((MacDrawable *) d)->winPtr;
    GC	       gc;
    int	       depth = 32;
    int	       offset = 0;
    int	       bitmap_pad = 32;
    int	       bytes_per_line = 0;

    if (TkMacOSXGetDrawablePort(d)) {
	if (format == ZPixmap) {
	    if (width > 0 && height > 0) {
		/* Tk_GetPixmap fails for zero width or height */
		pixmap = Tk_GetPixmap(display, d, width, height, depth);
	    }
	    if (win) {
		XGCValues values;
		gc = Tk_GetGC(win, 0, &values);
	    } else {
		gc = XCreateGC(display, pixmap, 0, NULL);
	    }
	    if (pixmap) {
		XCopyArea(display, d, pixmap, gc, x, y, width, height, 0, 0);
	    }
	    imagePtr = XCreateImage(display, NULL, depth, format, offset,
		(char*)TkMacOSXGetDrawablePort(pixmap),
		width, height, bitmap_pad, bytes_per_line);
	    /* Track Pixmap underlying the XImage in the unused obdata field *
	     * so that we can treat XImages coming from XGetImage specially. */
	    imagePtr->obdata = (XPointer) pixmap;
	    if (!win) {
		XFreeGC(display, gc);
	    }
	} else {
	    TkpDisplayWarning(
		"XGetImage: only ZPixmap types are implemented",
		"XGetImage Failure");
	}
    }
    return imagePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyImage --
 *
 *	Destroys storage associated with an image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deallocates the image.
 *
 *----------------------------------------------------------------------
 */

static int
DestroyImage(
    XImage *image)
{
    if (image) {
	if (image->obdata) {
	    Tk_FreePixmap((Display*) gMacDisplay, (Pixmap) image->obdata);
	} else if (image->data) {
	    ckfree(image->data);
	}
	ckfree((char*) image);
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * ImageGetPixel --
 *
 *	Get a single pixel from an image.
 *
 * Results:
 *	Returns the 32 bit pixel value.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static unsigned long
ImageGetPixel(
    XImage *image,
    int x,
    int y)
{
    CGrafPtr destPort, savePort;
    Boolean portChanged;
    RGBColor cPix;
    unsigned long r, g, b, c;

    destPort = (CGrafPtr)image->data;
    portChanged = QDSwapPort(destPort, &savePort);
    GetCPixel(x, y, &cPix);
    if (image->obdata) {
	/* Image from XGetImage, 16 bit color values */
	r = (cPix . red) >> 8;
	g = (cPix . green) >> 8;
	b = (cPix . blue) >> 8;
    } else {
	r = cPix . red;
	g = cPix . green;
	b = cPix . blue;
    }
    c = (r<<16)|(g<<8)|(b);
    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
    return c;
}

/*
 *----------------------------------------------------------------------
 *
 * PutPixel --
 *
 *	Set a single pixel in an image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
PutPixel(
    XImage *image,
    int x,
    int y,
    unsigned long pixel)
{
    CGrafPtr destPort, savePort;
    Boolean portChanged;
    RGBColor cPix;
    unsigned long r, g, b;

    destPort = (CGrafPtr)image->data;
    portChanged = QDSwapPort(destPort, &savePort);
    r  = (pixel & image->red_mask)>>16;
    g  = (pixel & image->green_mask)>>8;
    b  = (pixel & image->blue_mask);
    if (image->obdata) {
	/* Image from XGetImage, 16 bit color values */
	cPix . red = r << 8;
	cPix . green = g << 8;
	cPix . blue = b << 8;
    } else {
	cPix . red = r;
	cPix . green = g;
	cPix . blue = b;
    }
    SetCPixel(x, y, &cPix);
    if (portChanged) {
	QDSwapPort(savePort, NULL);
    }
    return 0;
}

#if 0
static XImage *
SubImage(
    XImage *image,
    int x,
    int y,
    unsigned int width,
    unsigned int height)
{
    Debugger();
    return NULL;
}

static int
AddPixel(
    XImage *image,
    long value)
{
    Debugger();
    return 0;
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * XChangeWindowAttributes, XSetWindowBackground,
 * XSetWindowBackgroundPixmap, XSetWindowBorder, XSetWindowBorderPixmap,
 * XSetWindowBorderWidth, XSetWindowColormap
 *
 *	These functions are all no-ops. They all have equivilent
 *	Tk calls that should always be used instead.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
XChangeWindowAttributes(
    Display* display,
    Window w,
    unsigned long value_mask,
    XSetWindowAttributes* attributes)
{
}

void
XSetWindowBackground(
	Display *display,
	Window window,
	unsigned long value)
{
}

void
XSetWindowBackgroundPixmap(
    Display* display,
    Window w,
    Pixmap background_pixmap)
{
}

void
XSetWindowBorder(
    Display* display,
    Window w,
    unsigned long border_pixel)
{
}

void
XSetWindowBorderPixmap(
    Display* display,
    Window w,
    Pixmap border_pixmap)
{
}

void
XSetWindowBorderWidth(
    Display* display,
    Window w,
    unsigned int width)
{
}

void
XSetWindowColormap(
    Display* display,
    Window w,
    Colormap colormap)
{
    Debugger();
}

Status
XStringListToTextProperty(
    char** list,
    int count,
    XTextProperty* text_prop_return)
{
    Debugger();
    return (Status) 0;
}
void
XSetWMClientMachine(
    Display* display,
    Window w,
    XTextProperty* text_prop)
{
    Debugger();
}
XIC
XCreateIC(
    void)
{
    Debugger();
    return (XIC) 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkGetDefaultScreenName --
 *
 *	Returns the name of the screen that Tk should use during
 *	initialization.
 *
 * Results:
 *	Returns a statically allocated string.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

CONST char *
TkGetDefaultScreenName(
    Tcl_Interp *interp,		/* Not used. */
    CONST char *screenName)		/* If NULL, use default string. */
{
#if 0
    if ((screenName == NULL) || (screenName[0] == '\0')) {
	screenName = macScreenName;
    }
    return screenName;
#endif
    return macScreenName;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetUserInactiveTime --
 *
 *	Return the number of milliseconds the user was inactive.
 *
 * Results:
 *	The number of milliseconds the user has been inactive,
 *	or -1 if querying the inactive time is not supported.
 *
 * Side effects:
 *	None.
 *----------------------------------------------------------------------
 */

long
Tk_GetUserInactiveTime(Display *dpy)
{
    io_registry_entry_t regEntry;
    CFMutableDictionaryRef props = NULL;
    CFTypeRef timeObj;
    long ret = -1l;
    uint64_t time;

    regEntry = IOServiceGetMatchingService(kIOMasterPortDefault,
	    IOServiceMatching("IOHIDSystem"));

    if (regEntry == 0) {
	return -1l;
    }

    IOReturn result = IORegistryEntryCreateCFProperties(regEntry, &props,
	    kCFAllocatorDefault, 0);
    IOObjectRelease(regEntry);

    if (result != KERN_SUCCESS || props == NULL) {
	return -1l;
    }

    timeObj = CFDictionaryGetValue(props, CFSTR("HIDIdleTime"));

    if (timeObj) {
	CFTypeID type = CFGetTypeID(timeObj);

	if (type == CFDataGetTypeID()) { /* Jaguar */
	    CFDataGetBytes((CFDataRef) timeObj,
		    CFRangeMake(0, sizeof(time)), (UInt8 *) &time);
	    /* Convert nanoseconds to milliseconds. */
	    /* ret /= kMillisecondScale; */
	    ret = (long)(time/kMillisecondScale);
	} else if (type == CFNumberGetTypeID()) { /* Panther+ */
	    CFNumberGetValue((CFNumberRef)timeObj,
		    kCFNumberSInt64Type, &time);
	    /* Convert nanoseconds to milliseconds. */
	    /* ret /= kMillisecondScale; */
	    ret = (long)(time/kMillisecondScale);
	} else {
	    ret = -1l;
	}
    }
    /* Cleanup */
    CFRelease(props);

    return ret;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_ResetUserInactiveTime --
 *
 *	Reset the user inactivity timer
 *
 * Results:
 *	none
 *
 * Side effects:
 *	The user inactivity timer of the underlaying windowing system
 *	is reset to zero.
 *
 *----------------------------------------------------------------------
 */

void
Tk_ResetUserInactiveTime(Display *dpy)
{
    UpdateSystemActivity(OverallAct);
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d16 1
a16 1
 * RCS: @@(#) $Id: tkMacOSXXStubs.c,v 1.17 2007/04/23 21:24:34 das Exp $
d19 1
a19 1
#include "tkMacOSXInt.h"
d54 5
a58 4
static int TkMacOSXXDestroyImage(XImage *image);
static unsigned long TkMacOSXXGetPixel(XImage *image, int x, int y);
static int TkMacOSXXPutPixel(XImage *image, int x, int y, unsigned long pixel);
static XImage *TkMacOSXXSubImage(XImage *image, int x, int y,
d60 2
a61 1
static int TkMacOSXXAddPixel(XImage *image, long value);
a404 53
XImage *
XGetImage(display, d, x, y, width, height, plane_mask, format)
    Display *display;
    Drawable d;
    int x;
    int y;
    unsigned int width;
    unsigned int height;
    unsigned long plane_mask;
    int format;
{
    XImage *   imagePtr = NULL;
    Pixmap     pixmap = (Pixmap) NULL;
    Tk_Window  win = (Tk_Window) ((MacDrawable *) d)->winPtr;
    GC	       gc;
    int	       depth = 32;
    int	       offset = 0;
    int	       bitmap_pad = 32;
    int	       bytes_per_line = 0;

    if (TkMacOSXGetDrawablePort(d)) {
	if (format == ZPixmap) {
	    if (width > 0 && height > 0) {
		/* Tk_GetPixmap fails for zero width or height */
		pixmap = Tk_GetPixmap(display, d, width, height, depth);
	    }
	    if (win) {
		XGCValues values;
		gc = Tk_GetGC(win, 0, &values);
	    } else {
		gc = XCreateGC(display, pixmap, 0, NULL);
	    }
	    if (pixmap) {
		XCopyArea(display, d, pixmap, gc, x, y, width, height, 0, 0);
	    }
	    imagePtr = XCreateImage(display, NULL, depth, format, offset,
		(char*)TkMacOSXGetDrawablePort(pixmap),
		width, height, bitmap_pad, bytes_per_line);
	    /* Track Pixmap underlying the XImage in the unused obdata field *
	     * so that we can treat XImages coming from XGetImage specially. */
	    imagePtr->obdata = (XPointer) pixmap;
	    if (!win) {
		XFreeGC(display, gc);
	    }
	} else {
	    TkpDisplayWarning(
		"XGetImage: only ZPixmap types are implemented",
		"XGetImage Failure");
	}
    }
    return imagePtr;
}

a498 54
XImage *
XCreateImage(
    Display* display,
    Visual* visual,
    unsigned int depth,
    int format,
    int offset,
    char* data,
    unsigned int width,
    unsigned int height,
    int bitmap_pad,
    int bytes_per_line)
{
    XImage *ximage;

    display->request++;
    ximage = (XImage *) ckalloc(sizeof(XImage));

    ximage->height = height;
    ximage->width = width;
    ximage->depth = depth;
    ximage->xoffset = offset;
    ximage->format = format;
    ximage->data = data;
    ximage->bitmap_pad = bitmap_pad;
    if (bytes_per_line == 0) {
	ximage->bytes_per_line = width * 4;  /* assuming 32 bits per pixel */
    } else {
	ximage->bytes_per_line = bytes_per_line;
    }

    if (format == ZPixmap) {
	ximage->bits_per_pixel = 32;
	ximage->bitmap_unit = 32;
    } else {
	ximage->bits_per_pixel = 1;
	ximage->bitmap_unit = 8;
    }
    ximage->byte_order = LSBFirst;
    ximage->bitmap_bit_order = LSBFirst;
    ximage->red_mask = 0x00FF0000;
    ximage->green_mask = 0x0000FF00;
    ximage->blue_mask = 0x000000FF;

    ximage->obdata = NULL;
    ximage->f.destroy_image = TkMacOSXXDestroyImage;
    ximage->f.get_pixel = TkMacOSXXGetPixel;
    ximage->f.put_pixel = TkMacOSXXPutPixel;
    ximage->f.sub_image = TkMacOSXXSubImage;
    ximage->f.add_pixel = TkMacOSXXAddPixel;

    return ximage;
}

d503 4
a506 1
    /* TODO - currently a no-op */
d681 1
a681 1
Tk_FreeXId (
d689 3
a691 1
XSync (Display *display, Bool flag)
d697 34
d766 154
d921 13
a933 1
 * Image stuff
d937 1
a937 1
TkMacOSXXDestroyImage(
d940 8
a947 2
    if (image->obdata)
	Tk_FreePixmap((Display*)gMacDisplay,(Pixmap)image->obdata);
d950 16
d968 1
a968 1
TkMacOSXXGetPixel(
d997 16
d1015 1
a1015 1
TkMacOSXXPutPixel(
d1048 1
d1050 1
a1050 1
TkMacOSXXSubImage(
d1062 1
a1062 1
TkMacOSXXAddPixel(
d1069 1
a1246 1
	CFRetain(timeObj);
a1263 2

	CFRelease(timeObj);
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d1 1
a1 1
/* 
d4 4
a7 4
 *	This file contains most of the X calls called by Tk.  Many of
 * these calls are just stubs and either don't make sense on the
 * Macintosh or thier implamentation just doesn't do anything.  Other
 * calls will eventually be moved into other files.
d11 1
d16 1
a16 1
 * RCS: @@(#) $Id: tkMacOSXXStubs.c,v 1.16 2006/09/10 17:06:32 das Exp $
d26 1
a26 1
 * used through out this file.  The define TCL_DEBUG will decide whether
d33 1
a33 1
 
d41 1
a41 1
static char *macScreenName = ":0"; /* Default name of macintosh display. */
d47 2
a48 3
static XID MacXIdAlloc _ANSI_ARGS_((Display *display));
static int DefaultErrorHandler _ANSI_ARGS_((Display* display,
	XErrorEvent* err_evt));
d54 7
a60 8
static int TkMacOSXXDestroyImage _ANSI_ARGS_((XImage *image));
static unsigned long TkMacOSXXGetPixel _ANSI_ARGS_((XImage *image, int x, int y));
static int TkMacOSXXPutPixel _ANSI_ARGS_((XImage *image, int x, int y,
	unsigned long pixel));
static XImage *TkMacOSXXSubImage _ANSI_ARGS_((XImage *image, int x, int y, 
	unsigned int width, unsigned int height));
static int TkMacOSXXAddPixel _ANSI_ARGS_((XImage *image, long value));
int _XInitImageFuncPtrs _ANSI_ARGS_((XImage *image));
a61 1

d84 1
d92 3
a94 3
    screen->root_depth  = (*(*graphicsDevice)->gdPMap)->cmpSize *
                               (*(*graphicsDevice)->gdPMap)->cmpCount;
    screen->height      = (*graphicsDevice)->gdRect.bottom -
d96 1
a96 1
    screen->width       = (*graphicsDevice)->gdRect.right -
d99 16
a114 2
    screen->mwidth      = (screen->width * 254 + 360) / 720;
    screen->mheight     = (screen->height * 254 + 360) / 720;
d140 2
a141 1
    int      fd = 0;
a149 1
    InitCursor();
d157 5
a161 5
    display->request        = 0;
    display->qlen           = 0;
    display->fd             = fd;
    display->screens        = screen;
    display->nscreens       = 1;
d163 1
a163 1
    display->display_name   = macScreenName;
d174 5
a178 4
    screen->root        = ROOT_ID;
    screen->display     = display;
    screen->black_pixel = 0x00000000;
    screen->white_pixel = 0x00FFFFFF;
d182 1
a182 1
    screen->root_visual->class        = TrueColor;
d228 1
a228 1
        Tcl_Panic("TkpCloseDisplay: tried to call TkpCloseDisplay on bad display");
d233 4
a236 4
        if (display->screens->root_visual != (Visual *) NULL) {
            ckfree((char *) display->screens->root_visual);
        }
        ckfree((char *) display->screens);
d248 1
a248 1
 *	results.  This function is called in tkWindow.c.  This has to be
d263 1
a263 1
    TkDisplay *dispPtr;	/* display associated with clipboard */
d348 1
a348 1
 *	This procedure is the default X error handler.  Tk uses it's
d366 1
a366 1
     * This call should never be called.  Tk replaces
d413 1
a413 1
{ 
d417 6
a422 6
    GC         gc;
    int        depth = 32;
    int        offset = 0;
    int        bitmap_pad = 32;
    int        bytes_per_line = 0;
    
d424 28
a451 28
        if (format == ZPixmap) {
            if (width > 0 && height > 0) {
                /* Tk_GetPixmap fails for zero width or height */
                pixmap = Tk_GetPixmap(display, d, width, height, depth);
            }
            if (win) {
                XGCValues values;
                gc = Tk_GetGC(win, 0, &values);
            } else {
                gc = XCreateGC(display, pixmap, 0, NULL);
            }
            if (pixmap) {
                XCopyArea(display, d, pixmap, gc, x, y, width, height, 0, 0);
            }
            imagePtr = XCreateImage(display, NULL, depth, format, offset,
                (char*)TkMacOSXGetDrawablePort(pixmap), 
                width, height, bitmap_pad, bytes_per_line);
            /* Track Pixmap underlying the XImage in the unused obdata field *
             * so that we can treat XImages coming from XGetImage specially. */
            imagePtr->obdata = (XPointer) pixmap;
            if (!win) {
                XFreeGC(display, gc);
            }
        } else {
            TkpDisplayWarning(
                "XGetImage: only ZPixmap types are implemented",
                "XGetImage Failure");
        }
d479 1
a479 1
        *depth_return = Tk_Depth(winPtr);
d483 2
a484 1
	GetPortBounds(destPort,&boundsRect);
d489 2
a490 2
    	*border_width_return = 0;
        *depth_return = 32;
d534 1
a534 1
     * Do nothing.  Shouldn't even be called.
d539 1
a539 1
XAllocSizeHints()
d542 1
a542 1
     * Always return NULL.  Tk code checks to see if NULL
d545 1
a545 1
    
d550 1
a550 1
XImage * 
d562 1
a562 1
{ 
d678 5
a682 5
    p       	= d->pixel;
    r       	= (p & 0x00FF0000) >> 16;
    g       	= (p & 0x0000FF00) >> 8;
    b       	= (p & 0x000000FF);
    d->red  	= (r << 8) | r;
d684 1
a684 1
    d->blue 	= (b << 8) | b;
d686 1
a686 1
    d->pad  	= 0;
d702 5
a706 5
	p       	= d->pixel;
	r       	= (p & 0x00FF0000) >> 16;
	g       	= (p & 0x0000FF00) >> 8;
	b       	= (p & 0x000000FF);
	d->red  	= (r << 8) | r;
d708 1
a708 1
	d->blue 	= (b << 8) | b;
d710 1
a710 1
	d->pad  	= 0;
d714 1
a714 1
int   
d716 1
a716 1
        nchildren_return)
d757 1
a757 1
void 
d769 1
a769 1
void 
d774 4
a777 4
    /* 
     * This function is just a no-op.  It is defined to 
     * reset the screen saver.  However, there is no real
     * way to do this on a Mac.  Let me know if there is!
d804 1
a804 1
 *	the window server for that window.  This procedure provides
d820 1
a820 1
    Tk_Window tkwin)		/* Token for window;  this selects a
d830 1
a830 1
	    buffer2, (char *) NULL);
d833 1
a833 1
 * Image stuff 
d836 1
a836 1
static int 
d841 1
a841 1
        Tk_FreePixmap((Display*)gMacDisplay,(Pixmap)image->obdata);
d845 1
a845 1
static unsigned long 
d851 2
a852 1
    CGrafPtr grafPtr, oldPort;
d855 4
a858 4
    grafPtr = (CGrafPtr)image->data;
    GetPort(&oldPort);
    SetPort(grafPtr);
    GetCPixel(x,y,&cPix);
d860 4
a863 4
        /* Image from XGetImage, 16 bit color values */
        r = (cPix . red) >> 8;
        g = (cPix . green) >> 8;
        b = (cPix . blue) >> 8;
d865 3
a867 3
        r = cPix . red;
        g = cPix . green;
        b = cPix . blue;
d870 3
a872 1
    SetPort(oldPort);
d876 1
a876 1
static int 
d883 2
a884 1
    CGrafPtr grafPtr, oldPort;
d887 3
a889 3
    grafPtr = (CGrafPtr)image->data;
    GetPort(&oldPort);
    SetPort(grafPtr);
d894 4
a897 4
        /* Image from XGetImage, 16 bit color values */
        cPix . red = r << 8;
        cPix . green = g << 8;
        cPix . blue = b << 8;
d899 7
a905 3
        cPix . red = r;
        cPix . green = g;
        cPix . blue = b;
a906 2
    SetCPixel(x,y,&cPix);
    SetPort(oldPort);
d922 1
a922 1
static int 
d938 1
a938 1
 *	These functions are all no-ops.  They all have equivilent
d959 1
a959 1
void 
d1010 2
a1011 2
    char** list, 
    int count, 
d1019 2
a1020 2
    Display* display, 
    Window w, 
d1066 1
a1066 1
 * 
@

