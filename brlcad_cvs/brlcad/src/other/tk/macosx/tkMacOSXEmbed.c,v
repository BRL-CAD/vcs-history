head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.11.06.21.38.50;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.45;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.55;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@tk 8.5a6->8.5b1
@
text
@/*
 * tkMacOSXEmbed.c --
 *
 *	This file contains platform-specific procedures for theMac to provide
 *	basic operations needed for application embedding (where one
 *	application can use as its main window an internal window from
 *	some other application).
 *	Currently only Toplevel embedding within the same Tk application is
 *	allowed on the Macintosh.
 *
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2006-2007 Daniel A. Steffen <das@@users.sourceforge.net>
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 *  RCS: @@(#) $Id: tkMacOSXEmbed.c,v 1.13 2007/06/03 13:44:39 das Exp $
 */

#include "tkMacOSXInt.h"

/*
 * One of the following structures exists for each container in this
 * application. It keeps track of the container window and its
 * associated embedded window.
 */

typedef struct Container {
    Window parent;		/* The Mac Drawable for the parent of
				 * the pair (the container). */
    TkWindow *parentPtr;	/* Tk's information about the container,
				 * or NULL if the container isn't
				 * in this process. */
    Window embedded;		/* The MacDrawable for the embedded
				 * window. Starts off as None, but
				 * gets filled in when the window is
				 * eventually created. */
    TkWindow *embeddedPtr;	/* Tk's information about the embedded
				 * window, or NULL if the
				 * embedded application isn't in
				 * this process. */
    struct Container *nextPtr;	/* Next in list of all containers in
				 * this process. */
} Container;

static Container *firstContainerPtr = NULL;
					/* First in list of all containers
					 * managed by this process. */
/*
 * Globals defined in this file
 */

TkMacOSXEmbedHandler *tkMacOSXEmbedHandler = NULL;

/*
 * Prototypes for static procedures defined in this file:
 */

static void ContainerEventProc(ClientData clientData, XEvent *eventPtr);
static void EmbeddedEventProc(ClientData clientData, XEvent *eventPtr);
static void EmbedActivateProc(ClientData clientData, XEvent *eventPtr);
static void EmbedFocusProc(ClientData clientData, XEvent *eventPtr);
static void EmbedGeometryRequest(Container * containerPtr, int width,
	int height);
static void EmbedSendConfigure(Container *containerPtr);
static void EmbedStructureProc(ClientData clientData, XEvent *eventPtr);
static void EmbedWindowDeleted(TkWindow *winPtr);


/*
 *----------------------------------------------------------------------
 *
 * Tk_MacOSXSetEmbedHandler --
 *
 *	Registers a handler for an in process form of embedding, like
 *	Netscape plugins, where Tk is loaded into the process, but does
 *	not control the main window
 *
 * Results:
 *	None
 *
 * Side effects:
 *	The embed handler is set.
 *
 *----------------------------------------------------------------------
 */

void
Tk_MacOSXSetEmbedHandler(
    Tk_MacOSXEmbedRegisterWinProc *registerWinProc,
    Tk_MacOSXEmbedGetGrafPortProc *getPortProc,
    Tk_MacOSXEmbedMakeContainerExistProc *containerExistProc,
    Tk_MacOSXEmbedGetClipProc *getClipProc,
    Tk_MacOSXEmbedGetOffsetInParentProc *getOffsetProc)
{
    if (tkMacOSXEmbedHandler == NULL) {
	    tkMacOSXEmbedHandler = (TkMacOSXEmbedHandler *) ckalloc(sizeof(TkMacOSXEmbedHandler));
    }
    tkMacOSXEmbedHandler->registerWinProc = registerWinProc;
    tkMacOSXEmbedHandler->getPortProc = getPortProc;
    tkMacOSXEmbedHandler->containerExistProc = containerExistProc;
    tkMacOSXEmbedHandler->getClipProc = getClipProc;
    tkMacOSXEmbedHandler->getOffsetProc = getOffsetProc;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMakeWindow --
 *
 *	Creates an X Window (Mac subwindow).
 *
 * Results:
 *	The window id is returned.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Window
TkpMakeWindow(
    TkWindow *winPtr,
    Window parent)
{
    MacDrawable *macWin;
    XEvent event;

    /*
     * If this window is marked as embedded then
     * the window structure should have already been
     * created in the TkpUseWindow function.
     */

    if (Tk_IsEmbedded(winPtr)) {
	macWin = winPtr->privatePtr;
    } else {
	/*
	 * Allocate sub window
	 */

	macWin = (MacDrawable *) ckalloc(sizeof(MacDrawable));
	if (macWin == NULL) {
	    winPtr->privatePtr = NULL;
	    return None;
	}
	macWin->winPtr = winPtr;
	winPtr->privatePtr = macWin;
	macWin->clipRgn = NewRgn();
	macWin->aboveClipRgn = NewRgn();
	macWin->drawRgn = NewRgn();
	macWin->referenceCount = 0;
	macWin->flags = TK_CLIP_INVALID;

	macWin->grafPtr = NULL;
	macWin->context = NULL;
	if (Tk_IsTopLevel(macWin->winPtr)) {
	    /*
	     *This will be set when we are mapped.
	     */
	    macWin->xOff = 0;
	    macWin->yOff = 0;
	    macWin->toplevel = macWin;
	} else {
	    macWin->xOff = winPtr->parentPtr->privatePtr->xOff +
		winPtr->parentPtr->changes.border_width +
		winPtr->changes.x;
	    macWin->yOff = winPtr->parentPtr->privatePtr->yOff +
		winPtr->parentPtr->changes.border_width +
		winPtr->changes.y;
	    macWin->toplevel = winPtr->parentPtr->privatePtr->toplevel;
	}
	macWin->toplevel->referenceCount++;
    }
    /*
     * TODO: need general solution for visibility events.
     */

    event.xany.serial = Tk_Display(winPtr)->request;
    event.xany.send_event = False;
    event.xany.display = Tk_Display(winPtr);

    event.xvisibility.type = VisibilityNotify;
    event.xvisibility.window = (Window) macWin;
    event.xvisibility.state = VisibilityUnobscured;
    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);

    return (Window) macWin;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpUseWindow --
 *
 *	This procedure causes a Tk window to use a given X window as
 *	its parent window, rather than the root window for the screen.
 *	It is invoked by an embedded application to specify the window
 *	in which it is embedded.
 *
 * Results:
 *	The return value is normally TCL_OK. If an error occurs (such
 *	as string not being a valid window spec), then the return value
 *	is TCL_ERROR and an error message is left in the interp's result if
 *	interp is non-NULL.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkpUseWindow(
    Tcl_Interp *interp,		/* If not NULL, used for error reporting
				 * if string is bogus. */
    Tk_Window tkwin,		/* Tk window that does not yet have an
				 * associated X window. */
    CONST char *string)		/* String identifying an X window to use
				 * for tkwin; must be an integer value. */
{
    TkWindow *winPtr = (TkWindow *) tkwin;
    TkWindow *usePtr;
    MacDrawable *parent, *macWin;
    Container *containerPtr;

    if (winPtr->window != None) {
	Tcl_AppendResult(interp, "can't modify container after widget is "
		"created", NULL);
	return TCL_ERROR;
    }

    /*
     * Decode the container pointer, and look for it among the
     * list of available containers.
     *
     * N.B. For now, we are limiting the containers to be in the same Tk
     * application as tkwin, since otherwise they would not be in our list
     * of containers.
     *
     */

    if (Tcl_GetInt(interp, string, (int*) &parent) != TCL_OK) {
	return TCL_ERROR;
    }

    usePtr = (TkWindow *) Tk_IdToWindow(winPtr->display, (Window) parent);
    if (usePtr != NULL) {
	if (!(usePtr->flags & TK_CONTAINER)) {
	    Tcl_AppendResult(interp, "window \"", usePtr->pathName,
		    "\" doesn't have -container option set", NULL);
	    return TCL_ERROR;
	}
    }

    /*
     * The code below can probably be simplified given we have already
     * discovered 'usePtr' above.
     */

    /*
     * Save information about the container and the embedded window
     * in a Container structure. Currently, there must already be an existing
     * Container structure, since we only allow the case where both container
     * and embedded app. are in the same process.
     */

    for (containerPtr = firstContainerPtr; containerPtr != NULL;
	    containerPtr = containerPtr->nextPtr) {
	if (containerPtr->parent == (Window) parent) {
	    winPtr->flags |= TK_BOTH_HALVES;
	    containerPtr->parentPtr->flags |= TK_BOTH_HALVES;
	    break;
	}
    }

    /*
     * Make the embedded window.
     */

    macWin = (MacDrawable *) ckalloc(sizeof(MacDrawable));
    if (macWin == NULL) {
	winPtr->privatePtr = NULL;
	return TCL_ERROR;
    }

    macWin->winPtr = winPtr;
    winPtr->privatePtr = macWin;

    /*
     * The grafPtr will be NULL for a Tk in Tk embedded window.
     * It is none of our business what it is for a Tk not in Tk embedded window,
     * but we will initialize it to NULL, and let the registerWinProc
     * set it. In any case, you must always use TkMacOSXGetDrawablePort
     * to get the portPtr. It will correctly find the container's port.
     */

    macWin->grafPtr = NULL;
    macWin->context = NULL;

    macWin->clipRgn = NewRgn();
    macWin->aboveClipRgn = NewRgn();
    macWin->drawRgn = NewRgn();
    macWin->referenceCount = 0;
    macWin->flags = TK_CLIP_INVALID;
    macWin->toplevel = macWin;
    macWin->toplevel->referenceCount++;

    winPtr->flags |= TK_EMBEDDED;


    /*
     * Make a copy of the TK_EMBEDDED flag, since sometimes
     * we need this to get the port after the TkWindow structure
     * has been freed.
     */

    macWin->flags |= TK_EMBEDDED;

    /*
     * Now check whether it is embedded in another Tk widget. If not (the first
     * case below) we see if there is an in-process embedding handler registered,
     * and if so, let that fill in the rest of the macWin.
     */

    if (containerPtr == NULL) {
	/*
	 * If someone has registered an in process embedding handler, then
	 * see if it can handle this window...
	 */

	if (tkMacOSXEmbedHandler == NULL ||
		tkMacOSXEmbedHandler->registerWinProc((int) parent,
		(Tk_Window) winPtr) != TCL_OK) {
	    Tcl_AppendResult(interp, "The window ID ", string,
		    " does not correspond to a valid Tk Window.", NULL);
	    return TCL_ERROR;
	} else {
	    containerPtr = (Container *) ckalloc(sizeof(Container));

	    containerPtr->parentPtr = NULL;
	    containerPtr->embedded = (Window) macWin;
	    containerPtr->embeddedPtr = macWin->winPtr;
	    containerPtr->nextPtr = firstContainerPtr;
	    firstContainerPtr = containerPtr;

	}
    } else {

	/*
	 * The window is embedded in another Tk window.
	 */

	macWin->xOff = parent->winPtr->privatePtr->xOff +
		parent->winPtr->changes.border_width +
		winPtr->changes.x;
	macWin->yOff = parent->winPtr->privatePtr->yOff +
		parent->winPtr->changes.border_width +
		winPtr->changes.y;


	/*
	 * Finish filling up the container structure with the embedded window's
	 * information.
	 */

	containerPtr->embedded = (Window) macWin;
	containerPtr->embeddedPtr = macWin->winPtr;

	/*
	 * Create an event handler to clean up the Container structure when
	 * tkwin is eventually deleted.
	 */

	Tk_CreateEventHandler(tkwin, StructureNotifyMask, EmbeddedEventProc,
		(ClientData) winPtr);

    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMakeContainer --
 *
 *	This procedure is called to indicate that a particular window
 *	will be a container for an embedded application. This changes
 *	certain aspects of the window's behavior, such as whether it
 *	will receive events anymore.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkpMakeContainer(
    Tk_Window tkwin)		/* Token for a window that is about to
				 * become a container. */
{
    TkWindow *winPtr = (TkWindow *) tkwin;
    Container *containerPtr;

    /*
     * Register the window as a container so that, for example, we can
     * make sure the argument to -use is valid.
     */


    Tk_MakeWindowExist(tkwin);
    containerPtr = (Container *) ckalloc(sizeof(Container));
    containerPtr->parent = Tk_WindowId(tkwin);
    containerPtr->parentPtr = winPtr;
    containerPtr->embedded = None;
    containerPtr->embeddedPtr = NULL;
    containerPtr->nextPtr = firstContainerPtr;
    firstContainerPtr = containerPtr;
    winPtr->flags |= TK_CONTAINER;

    /*
     * Request SubstructureNotify events so that we can find out when
     * the embedded application creates its window or attempts to
     * resize it. Also watch Configure events on the container so that
     * we can resize the child to match. Also, pass activate events from
     * the container down to the embedded toplevel.
     */

    Tk_CreateEventHandler(tkwin,
	    SubstructureNotifyMask|SubstructureRedirectMask,
	    ContainerEventProc, (ClientData) winPtr);
    Tk_CreateEventHandler(tkwin, StructureNotifyMask, EmbedStructureProc,
	    (ClientData) containerPtr);
    Tk_CreateEventHandler(tkwin, ActivateMask, EmbedActivateProc,
	    (ClientData) containerPtr);
    Tk_CreateEventHandler(tkwin, FocusChangeMask, EmbedFocusProc,
	    (ClientData) containerPtr);

}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXContainerId --
 *
 *	Given an embedded window, this procedure returns the MacDrawable
 *	identifier for the associated container window.
 *
 * Results:
 *	The return value is the MacDrawable for winPtr's
 *	container window.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

MacDrawable *
TkMacOSXContainerId(winPtr)
    TkWindow *winPtr;		/* Tk's structure for an embedded window. */
{
    Container *containerPtr;

    for (containerPtr = firstContainerPtr; containerPtr != NULL;
	    containerPtr = containerPtr->nextPtr) {
	if (containerPtr->embeddedPtr == winPtr) {
	    return (MacDrawable *) containerPtr->parent;
	}
    }
    Tcl_Panic("TkMacOSXContainerId couldn't find window");
    return None;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGetHostToplevel --
 *
 *	Given the TkWindow, return the MacDrawable for the outermost
 *	toplevel containing it. This will be a real Macintosh window.
 *
 * Results:
 *	Returns a MacDrawable corresponding to a Macintosh Toplevel
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

MacDrawable *
TkMacOSXGetHostToplevel(
    TkWindow *winPtr)		/* Tk's structure for a window. */
{
    TkWindow *contWinPtr, *topWinPtr;

    topWinPtr = winPtr->privatePtr->toplevel->winPtr;
    if (!Tk_IsEmbedded(topWinPtr)) {
	    return winPtr->privatePtr->toplevel;
    } else {
	contWinPtr = TkpGetOtherWindow(topWinPtr);

	/*
	 * TODO: Here we should handle out of process embedding.
	 */

	if (contWinPtr != NULL) {
	    return TkMacOSXGetHostToplevel(contWinPtr);
	} else {
	    return None;
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpClaimFocus --
 *
 *	This procedure is invoked when someone asks for the input focus
 *	to be put on a window in an embedded application, but the
 *	application doesn't currently have the focus. It requests the
 *	input focus from the container application.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The input focus may change.
 *
 *----------------------------------------------------------------------
 */

void
TkpClaimFocus(
    TkWindow *topLevelPtr,	/* Top-level window containing desired
				 * focus window; should be embedded. */
    int force)			/* One means that the container should
				 * claim the focus if it doesn't
				 * currently have it. */
{
    XEvent event;
    Container *containerPtr;

    if (!(topLevelPtr->flags & TK_EMBEDDED)) {
	return;
    }

    for (containerPtr = firstContainerPtr;
	    containerPtr->embeddedPtr != topLevelPtr;
	    containerPtr = containerPtr->nextPtr) {
	/* Empty loop body. */
    }


    event.xfocus.type = FocusIn;
    event.xfocus.serial = LastKnownRequestProcessed(topLevelPtr->display);
    event.xfocus.send_event = 1;
    event.xfocus.display = topLevelPtr->display;
    event.xfocus.window = containerPtr->parent;
    event.xfocus.mode = EMBEDDED_APP_WANTS_FOCUS;
    event.xfocus.detail = force;
    Tk_QueueWindowEvent(&event,TCL_QUEUE_TAIL);
}

/*
 *----------------------------------------------------------------------
 *
 * TkpTestembedCmd --
 *
 *	This procedure implements the "testembed" command. It returns
 *	some or all of the information in the list pointed to by
 *	firstContainerPtr.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkpTestembedCmd(
    ClientData clientData,	/* Main window for application. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int argc,			/* Number of arguments. */
    CONST char **argv)		/* Argument strings. */
{
    int all;
    Container *containerPtr;
    Tcl_DString dString;
    char buffer[50];

    if ((argc > 1) && (strcmp(argv[1], "all") == 0)) {
	all = 1;
    } else {
	all = 0;
    }
    Tcl_DStringInit(&dString);
    for (containerPtr = firstContainerPtr; containerPtr != NULL;
	    containerPtr = containerPtr->nextPtr) {
	Tcl_DStringStartSublist(&dString);
	if (containerPtr->parent == None) {
	    Tcl_DStringAppendElement(&dString, "");
	} else {
	    if (all) {
		sprintf(buffer, "0x%x", (int) containerPtr->parent);
		Tcl_DStringAppendElement(&dString, buffer);
	    } else {
		Tcl_DStringAppendElement(&dString, "XXX");
	    }
	}
	if (containerPtr->parentPtr == NULL) {
	    Tcl_DStringAppendElement(&dString, "");
	} else {
	    Tcl_DStringAppendElement(&dString,
		    containerPtr->parentPtr->pathName);
	}
	if (containerPtr->embedded == None) {
	    Tcl_DStringAppendElement(&dString, "");
	} else {
	    if (all) {
		sprintf(buffer, "0x%x", (int) containerPtr->embedded);
		Tcl_DStringAppendElement(&dString, buffer);
	    } else {
		Tcl_DStringAppendElement(&dString, "XXX");
	    }
	}
	if (containerPtr->embeddedPtr == NULL) {
	    Tcl_DStringAppendElement(&dString, "");
	} else {
	    Tcl_DStringAppendElement(&dString,
		    containerPtr->embeddedPtr->pathName);
	}
	Tcl_DStringEndSublist(&dString);
    }
    Tcl_DStringResult(interp, &dString);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpRedirectKeyEvent --
 *
 *	This procedure is invoked when a key press or release event
 *	arrives for an application that does not believe it owns the
 *	input focus. This can happen because of embedding; for example,
 *	X can send an event to an embedded application when the real
 *	focus window is in the container application and is an ancestor
 *	of the container. This procedure's job is to forward the event
 *	back to the application where it really belongs.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The event may get sent to a different application.
 *
 *----------------------------------------------------------------------
 */

void
TkpRedirectKeyEvent(
    TkWindow *winPtr,		/* Window to which the event was originally
				 * reported. */
    XEvent *eventPtr)		/* X event to redirect (should be KeyPress
				 * or KeyRelease). */
{
}

/*
 *----------------------------------------------------------------------
 *
 * TkpGetOtherWindow --
 *
 *	If both the container and embedded window are in the same
 *	process, this procedure will return either one, given the other.
 *
 * Results:
 *	If winPtr is a container, the return value is the token for the
 *	embedded window, and vice versa. If the "other" window isn't in
 *	this process, NULL is returned.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TkWindow *
TkpGetOtherWindow(
    TkWindow *winPtr)		/* Tk's structure for a container or
				 * embedded window. */
{
    Container *containerPtr;

    /*
     * TkpGetOtherWindow returns NULL if both windows are not
     * in the same process...
     */

    if (!(winPtr->flags & TK_BOTH_HALVES)) {
	return NULL;
    }

    for (containerPtr = firstContainerPtr; containerPtr != NULL;
	    containerPtr = containerPtr->nextPtr) {
	if (containerPtr->embeddedPtr == winPtr) {
	    return containerPtr->parentPtr;
	} else if (containerPtr->parentPtr == winPtr) {
	    return containerPtr->embeddedPtr;
	}
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * EmbeddedEventProc --
 *
 *	This procedure is invoked by the Tk event dispatcher when various
 *	useful events are received for a window that is embedded in
 *	another application.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Our internal state gets cleaned up when an embedded window is
 *	destroyed.
 *
 *----------------------------------------------------------------------
 */

static void
EmbeddedEventProc(
    ClientData clientData,	/* Token for container window. */
    XEvent *eventPtr)		/* ResizeRequest event. */
{
    TkWindow *winPtr = (TkWindow *) clientData;

    if (eventPtr->type == DestroyNotify) {
	EmbedWindowDeleted(winPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ContainerEventProc --
 *
 *	This procedure is invoked by the Tk event dispatcher when various
 *	useful events are received for the children of a container
 *	window. It forwards relevant information, such as geometry
 *	requests, from the events into the container's application.
 *
 *	NOTE: on the Mac, only the DestroyNotify branch is ever taken.
 *	We don't synthesize the other events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on the event. For example, when ConfigureRequest events
 *	occur, geometry information gets set for the container window.
 *
 *----------------------------------------------------------------------
 */

static void
ContainerEventProc(
    ClientData clientData,	/* Token for container window. */
    XEvent *eventPtr)		/* ResizeRequest event. */
{
    TkWindow *winPtr = (TkWindow *) clientData;
    Container *containerPtr;
    Tk_ErrorHandler errHandler;

    /*
     * Ignore any X protocol errors that happen in this procedure
     * (almost any operation could fail, for example, if the embedded
     * application has deleted its window).
     */

    errHandler = Tk_CreateErrorHandler(eventPtr->xfocus.display, -1,
	    -1, -1, (Tk_ErrorProc *) NULL, (ClientData) NULL);

    /*
     * Find the Container structure associated with the parent window.
     */

    for (containerPtr = firstContainerPtr;
	    containerPtr->parent != eventPtr->xmaprequest.parent;
	    containerPtr = containerPtr->nextPtr) {
	if (containerPtr == NULL) {
	    Tcl_Panic("ContainerEventProc couldn't find Container record");
	}
    }

    if (eventPtr->type == CreateNotify) {
	/*
	 * A new child window has been created in the container. Record
	 * its id in the Container structure (if more than one child is
	 * created, just remember the last one and ignore the earlier
	 * ones).
	 */

	containerPtr->embedded = eventPtr->xcreatewindow.window;
    } else if (eventPtr->type == ConfigureRequest) {
	if ((eventPtr->xconfigurerequest.x != 0)
		|| (eventPtr->xconfigurerequest.y != 0)) {
	    /*
	     * The embedded application is trying to move itself, which
	     * isn't legal. At this point, the window hasn't actually
	     * moved, but we need to send it a ConfigureNotify event to
	     * let it know that its request has been denied. If the
	     * embedded application was also trying to resize itself, a
	     * ConfigureNotify will be sent by the geometry management
	     * code below, so we don't need to do anything. Otherwise,
	     * generate a synthetic event.
	     */

	    if ((eventPtr->xconfigurerequest.width == winPtr->changes.width)
		    && (eventPtr->xconfigurerequest.height
		    == winPtr->changes.height)) {
		EmbedSendConfigure(containerPtr);
	    }
	}
	EmbedGeometryRequest(containerPtr,
		eventPtr->xconfigurerequest.width,
		eventPtr->xconfigurerequest.height);
    } else if (eventPtr->type == MapRequest) {
	/*
	 * The embedded application's map request was ignored and simply
	 * passed on to us, so we have to map the window for it to appear
	 * on the screen.
	 */

	XMapWindow(eventPtr->xmaprequest.display,
		eventPtr->xmaprequest.window);
    } else if (eventPtr->type == DestroyNotify) {
	/*
	 * The embedded application is gone. Destroy the container window.
	 */

	Tk_DestroyWindow((Tk_Window) winPtr);
    }
    Tk_DeleteErrorHandler(errHandler);
}

/*
 *----------------------------------------------------------------------
 *
 * EmbedStructureProc --
 *
 *	This procedure is invoked by the Tk event dispatcher when
 *	a container window owned by this application gets resized
 *	(and also at several other times that we don't care about).
 *	This procedure reflects the size change in the embedded
 *	window that corresponds to the container.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The embedded window gets resized to match the container.
 *
 *----------------------------------------------------------------------
 */

static void
EmbedStructureProc(
    ClientData clientData,	/* Token for container window. */
    XEvent *eventPtr)		/* ResizeRequest event. */
{
    Container *containerPtr = (Container *) clientData;
    Tk_ErrorHandler errHandler;

    if (eventPtr->type == ConfigureNotify) {
	if (containerPtr->embedded != None) {
	    /*
	     * Ignore errors, since the embedded application could have
	     * deleted its window.
	     */

	    errHandler = Tk_CreateErrorHandler(eventPtr->xfocus.display, -1,
		    -1, -1, (Tk_ErrorProc *) NULL, (ClientData) NULL);
	    Tk_MoveResizeWindow((Tk_Window) containerPtr->embeddedPtr, 0, 0,
		    (unsigned int) Tk_Width(
			    (Tk_Window) containerPtr->parentPtr),
		    (unsigned int) Tk_Height(
			    (Tk_Window) containerPtr->parentPtr));
	    Tk_DeleteErrorHandler(errHandler);
	}
    } else if (eventPtr->type == DestroyNotify) {
	EmbedWindowDeleted(containerPtr->parentPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * EmbedActivateProc --
 *
 *	This procedure is invoked by the Tk event dispatcher when
 *	Activate and Deactivate events occur for a container window owned
 *	by this application. It is responsible for forwarding an activate
 *	event down into the embedded toplevel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The X focus may change.
 *
 *----------------------------------------------------------------------
 */

static void
EmbedActivateProc(
    ClientData clientData,	/* Token for container window. */
    XEvent *eventPtr)		/* ResizeRequest event. */
{
    Container *containerPtr = (Container *) clientData;

    if (containerPtr->embeddedPtr != NULL) {
	if (eventPtr->type == ActivateNotify) {
	    TkGenerateActivateEvents(containerPtr->embeddedPtr,1);
	} else if (eventPtr->type == DeactivateNotify) {
	    TkGenerateActivateEvents(containerPtr->embeddedPtr,0);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * EmbedFocusProc --
 *
 *	This procedure is invoked by the Tk event dispatcher when
 *	FocusIn and FocusOut events occur for a container window owned
 *	by this application. It is responsible for moving the focus
 *	back and forth between a container application and an embedded
 *	application.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The X focus may change.
 *
 *----------------------------------------------------------------------
 */

static void
EmbedFocusProc(
    ClientData clientData,	/* Token for container window. */
    XEvent *eventPtr)		/* ResizeRequest event. */
{
    Container *containerPtr = (Container *) clientData;
    Display *display;
    XEvent event;

    if (containerPtr->embeddedPtr != NULL) {
    display = Tk_Display(containerPtr->parentPtr);
	event.xfocus.serial = LastKnownRequestProcessed(display);
	event.xfocus.send_event = false;
	event.xfocus.display = display;
	event.xfocus.mode = NotifyNormal;
	event.xfocus.window = containerPtr->embedded;

    if (eventPtr->type == FocusIn) {
	/*
	 * The focus just arrived at the container. Change the X focus
	 * to move it to the embedded application, if there is one.
	 * Ignore X errors that occur during this operation (it's
	 * possible that the new focus window isn't mapped).
	 */

	    event.xfocus.detail = NotifyNonlinear;
	    event.xfocus.type = FocusIn;

	} else if (eventPtr->type == FocusOut) {
	/* When the container gets a FocusOut event, it has to	tell the embedded app
	 * that it has lost the focus.
	 */

	    event.xfocus.type = FocusOut;
	    event.xfocus.detail = NotifyNonlinear;
	 }

	Tk_QueueWindowEvent(&event, TCL_QUEUE_MARK);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * EmbedGeometryRequest --
 *
 *	This procedure is invoked when an embedded application requests
 *	a particular size. It processes the request (which may or may
 *	not actually honor the request) and reflects the results back
 *	to the embedded application.
 *
 *	NOTE: On the Mac, this is a stub, since we don't synthesize
 *	ConfigureRequest events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If we deny the child's size change request, a Configure event
 *	is synthesized to let the child know how big it ought to be.
 *	Events get processed while we're waiting for the geometry
 *	managers to do their thing.
 *
 *----------------------------------------------------------------------
 */

static void
EmbedGeometryRequest(
    Container *containerPtr,	/* Information about the embedding. */
    int width, int height)	/* Size that the child has requested. */
{
    TkWindow *winPtr = containerPtr->parentPtr;

    /*
     * Forward the requested size into our geometry management hierarchy
     * via the container window. We need to send a Configure event back
     * to the embedded application if we decide not to honor its
     * request; to make this happen, process all idle event handlers
     * synchronously here (so that the geometry managers have had a
     * chance to do whatever they want to do), and if the window's size
     * didn't change then generate a configure event.
     */

    Tk_GeometryRequest((Tk_Window) winPtr, width, height);
    while (Tcl_DoOneEvent(TCL_IDLE_EVENTS)) {
	/* Empty loop body. */
    }
    if ((winPtr->changes.width != width)
	    || (winPtr->changes.height != height)) {
	EmbedSendConfigure(containerPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * EmbedSendConfigure --
 *
 *	This is currently a stub. It is called to notify an
 *	embedded application of its current size and location. This
 *	procedure is called when the embedded application made a
 *	geometry request that we did not grant, so that the embedded
 *	application knows that its geometry didn't change after all.
 *	It is a response to ConfigureRequest events, which we do not
 *	currently synthesize on the Mac
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
EmbedSendConfigure(
    Container *containerPtr)	/* Information about the embedding. */
{
}

/*
 *----------------------------------------------------------------------
 *
 * EmbedWindowDeleted --
 *
 *	This procedure is invoked when a window involved in embedding
 *	(as either the container or the embedded application) is
 *	destroyed. It cleans up the Container structure for the window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A Container structure may be freed.
 *
 *----------------------------------------------------------------------
 */

static void
EmbedWindowDeleted(
    TkWindow *winPtr)		/* Tk's information about window that
				 * was deleted. */
{
    Container *containerPtr, *prevPtr;

    /*
     * Find the Container structure for this window. Delete the
     * information about the embedded application and free the container's
     * record.
     */

    prevPtr = NULL;
    containerPtr = firstContainerPtr;
    while (1) {
	if (containerPtr->embeddedPtr == winPtr) {

	    /*
	     * We also have to destroy our parent, to clean up the container.
	     * Fabricate an event to do this.
	     */

	    if (containerPtr->parentPtr != NULL &&
		    containerPtr->parentPtr->flags & TK_BOTH_HALVES) {
		XEvent event;

		event.xany.serial =
		    Tk_Display(containerPtr->parentPtr)->request;
		    event.xany.send_event = False;
		    event.xany.display = Tk_Display(containerPtr->parentPtr);

		    event.xany.type = DestroyNotify;
		    event.xany.window = containerPtr->parent;
		    event.xdestroywindow.event = containerPtr->parent;
		    Tk_QueueWindowEvent(&event, TCL_QUEUE_HEAD);

	    }

	    containerPtr->embedded = None;
	    containerPtr->embeddedPtr = NULL;

	    break;
	}
	if (containerPtr->parentPtr == winPtr) {
	    containerPtr->parentPtr = NULL;
	    break;
	}
	prevPtr = containerPtr;
	containerPtr = containerPtr->nextPtr;
    }
    if ((containerPtr->embeddedPtr == NULL)
	    && (containerPtr->parentPtr == NULL)) {
	if (prevPtr == NULL) {
	    firstContainerPtr = containerPtr->nextPtr;
	} else {
	    prevPtr->nextPtr = containerPtr->nextPtr;
	}
	ckfree((char *) containerPtr);
    }
}
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d18 1
a18 1
 *  RCS: @@(#) $Id: tkMacOSXEmbed.c,v 1.11 2007/04/25 00:02:04 das Exp $
d138 2
a139 23
	return (Window) winPtr->privatePtr;
    }

    /*
     * Allocate sub window
     */

    macWin = (MacDrawable *) ckalloc(sizeof(MacDrawable));
    if (macWin == NULL) {
	winPtr->privatePtr = NULL;
	return None;
    }
    macWin->winPtr = winPtr;
    winPtr->privatePtr = macWin;
    macWin->clipRgn = NewRgn();
    macWin->aboveClipRgn = NewRgn();
    macWin->drawRgn = NewRgn();
    macWin->referenceCount = 0;
    macWin->flags = TK_CLIP_INVALID;

    macWin->grafPtr = NULL;
    macWin->context = NULL;
    if (Tk_IsTopLevel(macWin->winPtr)) {
d141 1
a141 1
	 *This will be set when we are mapped.
d143 33
a175 11
	macWin->xOff = 0;
	macWin->yOff = 0;
	macWin->toplevel = macWin;
    } else {
	macWin->xOff = winPtr->parentPtr->privatePtr->xOff +
	    winPtr->parentPtr->changes.border_width +
	    winPtr->changes.x;
	macWin->yOff = winPtr->parentPtr->privatePtr->yOff +
	    winPtr->parentPtr->changes.border_width +
	    winPtr->changes.y;
	macWin->toplevel = winPtr->parentPtr->privatePtr->toplevel;
a176 2
    macWin->toplevel->referenceCount++;

d180 1
a227 1
    XEvent event;
d237 1
a237 1
     *list of available containers.
a381 28
   /*
     * TODO: need general solution for visibility events.
     */


    event.xany.serial = Tk_Display(winPtr)->request;
    event.xany.send_event = False;
    event.xany.display = Tk_Display(winPtr);

    event.xvisibility.type = VisibilityNotify;
    event.xvisibility.window = (Window) macWin;;
    event.xvisibility.state = VisibilityUnobscured;
    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);


    /*
     * TODO: need general solution for visibility events.
     */

    event.xany.serial = Tk_Display(winPtr)->request;
    event.xany.send_event = False;
    event.xany.display = Tk_Display(winPtr);

    event.xvisibility.type = VisibilityNotify;
    event.xvisibility.window = (Window) macWin;;
    event.xvisibility.state = VisibilityUnobscured;
    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);

d512 1
a512 1
	 * NOTE: Here we should handle out of process embedding.
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d1 1
a1 1
/* 
d4 6
a9 6
 *        This file contains platform-specific procedures for theMac to provide
 *        basic operations needed for application embedding (where one
 *        application can use as its main window an internal window from
 *        some other application).
 *        Currently only Toplevel embedding within the same Tk application is
 *      allowed on the Macintosh.
d13 1
d18 1
a18 1
 *  RCS: @@(#) $Id: tkMacOSXEmbed.c,v 1.7 2006/04/22 04:12:02 das Exp $
d25 1
a25 1
 * application.  It keeps track of the container window and its
d30 15
a44 15
    Window parent;                /* The Mac Drawable for the parent of
                                 * the pair (the container). */
    TkWindow *parentPtr;        /* Tk's information about the container,
                                 * or NULL if the container isn't
                                 * in this process. */
    Window embedded;                /* The MacDrawable for the embedded
                                 * window.  Starts off as None, but
                                 * gets filled in when the window is
                                 * eventually created. */
    TkWindow *embeddedPtr;        /* Tk's information about the embedded
                                 * window, or NULL if the
                                 * embedded application isn't in
                                 * this process. */
    struct Container *nextPtr;        /* Next in list of all containers in
                                 * this process. */
d48 2
a49 2
                                        /* First in list of all containers
                                         * managed by this process.  */
d54 1
a54 1
TkMacOSXEmbedHandler *gMacEmbedHandler = NULL;
d60 9
a68 15
static void                ContainerEventProc _ANSI_ARGS_((
                            ClientData clientData, XEvent *eventPtr));
static void                EmbeddedEventProc _ANSI_ARGS_((
                            ClientData clientData, XEvent *eventPtr));
static void                EmbedActivateProc _ANSI_ARGS_((ClientData clientData, 
                            XEvent *eventPtr));
static void                EmbedFocusProc _ANSI_ARGS_((ClientData clientData,
                            XEvent *eventPtr));
static void                EmbedGeometryRequest _ANSI_ARGS_((
                            Container * containerPtr, int width, int height));
static void                EmbedSendConfigure _ANSI_ARGS_((
                            Container *containerPtr));
static void                EmbedStructureProc _ANSI_ARGS_((ClientData clientData,
                            XEvent *eventPtr));
static void                EmbedWindowDeleted _ANSI_ARGS_((TkWindow *winPtr));
d76 3
a78 3
 *        Registers a handler for an in process form of embedding, like 
 *        Netscape plugins, where Tk is loaded into the process, but does
 *        not control the main window
d81 1
a81 1
 *        None
d84 1
a84 1
 *        The embed handler is set.
d88 1
d97 2
a98 2
    if (gMacEmbedHandler == NULL) {
            gMacEmbedHandler = (TkMacOSXEmbedHandler *) ckalloc(sizeof(TkMacOSXEmbedHandler));
d100 5
a104 5
    gMacEmbedHandler->registerWinProc = registerWinProc;
    gMacEmbedHandler->getPortProc = getPortProc;
    gMacEmbedHandler->containerExistProc = containerExistProc;
    gMacEmbedHandler->getClipProc = getClipProc;
    gMacEmbedHandler->getOffsetProc = getOffsetProc;    
a105 1

d112 1
a112 1
 *        Creates an X Window (Mac subwindow).
d115 1
a115 1
 *        The window id is returned.
d118 1
a118 1
 *        None.
d136 1
a136 1
    
d138 1
a138 1
        return (Window) winPtr->privatePtr;
d140 1
a140 1
    
d144 1
a144 1
    
d147 2
a148 2
        winPtr->privatePtr = NULL;
        return None;
d154 1
d158 2
d161 6
a166 9
        
        /*
         *This will be set when we are mapped.
         */
        
        macWin->grafPtr  = NULL;  
        macWin->toplevel = macWin;
        macWin->xOff = 0;
        macWin->yOff = 0;
d168 7
a174 8
        macWin->grafPtr = NULL;
        macWin->xOff = winPtr->parentPtr->privatePtr->xOff +
            winPtr->parentPtr->changes.border_width +
            winPtr->changes.x;
        macWin->yOff = winPtr->parentPtr->privatePtr->yOff +
            winPtr->parentPtr->changes.border_width +
            winPtr->changes.y;
        macWin->toplevel = winPtr->parentPtr->privatePtr->toplevel;
d176 1
d178 1
a178 3
    macWin->toplevel->referenceCount++;
    
    /* 
d184 1
a184 1
        
d198 4
a201 4
 *        This procedure causes a Tk window to use a given X window as
 *        its parent window, rather than the root window for the screen.
 *        It is invoked by an embedded application to specify the window
 *        in which it is embedded.
d204 4
a207 4
 *        The return value is normally TCL_OK.  If an error occurs (such
 *        as string not being a valid window spec), then the return value
 *        is TCL_ERROR and an error message is left in the interp's result if
 *        interp is non-NULL.
d210 1
a210 1
 *        None.
d217 6
a222 6
    Tcl_Interp *interp,                /* If not NULL, used for error reporting
                                 * if string is bogus. */
    Tk_Window tkwin,                /* Tk window that does not yet have an
                                 * associated X window. */
    CONST char *string)                /* String identifying an X window to use
                                 * for tkwin;  must be an integer value. */
d231 2
a232 1
	Tcl_AppendResult(interp, "can't modify container after widget is created", (char *) NULL);
d235 1
a235 1
    
d237 1
a237 1
     * Decode the container pointer, and look for it among the 
d245 1
a245 1
     
d247 1
a247 1
        return TCL_ERROR;
d258 2
a259 2
    
    /* 
d266 2
a267 2
     * in a Container structure.  Currently, there must already be an existing
     * Container structure, since we only allow the case where both container 
d272 6
a277 6
            containerPtr = containerPtr->nextPtr) {
        if (containerPtr->parent == (Window) parent) {
            winPtr->flags |= TK_BOTH_HALVES;
            containerPtr->parentPtr->flags |= TK_BOTH_HALVES;
            break;
        }
d279 1
a279 1
    
d281 1
a281 1
     * Make the embedded window.  
d286 2
a287 2
        winPtr->privatePtr = NULL;
        return TCL_ERROR;
d289 1
a289 1
    
d296 3
a298 3
     * but we will initialize it to NULL, and let the registerWinProc 
     * set it.  In any case, you must always use TkMacOSXGetDrawablePort 
     * to get the portPtr.  It will correctly find the container's port.
d302 1
d306 1
d311 1
a311 1
   
d313 2
a314 2
    
    
d320 1
a320 1
     
d322 1
a322 1
    
d324 1
a324 1
     * Now check whether it is embedded in another Tk widget.  If not (the first
d328 1
a328 1
    
d330 21
a350 22
        /*
         * If someone has registered an in process embedding handler, then 
         * see if it can handle this window...
         */
        
        if (gMacEmbedHandler == NULL ||
                gMacEmbedHandler->registerWinProc((int) parent,
                (Tk_Window) winPtr) != TCL_OK) {
            Tcl_AppendResult(interp, "The window ID ", string,
                    " does not correspond to a valid Tk Window.",
                     (char *) NULL);
            return TCL_ERROR;        
        } else {
            containerPtr = (Container *) ckalloc(sizeof(Container));

            containerPtr->parentPtr = NULL;
            containerPtr->embedded = (Window) macWin;
            containerPtr->embeddedPtr = macWin->winPtr;
            containerPtr->nextPtr = firstContainerPtr;
            firstContainerPtr = containerPtr;
            
        }    
a351 25
        
        /* 
         * The window is embedded in another Tk window.
         */ 
        
        macWin->xOff = parent->winPtr->privatePtr->xOff +
                parent->winPtr->changes.border_width +
                winPtr->changes.x;
        macWin->yOff = parent->winPtr->privatePtr->yOff +
                parent->winPtr->changes.border_width +
                winPtr->changes.y;
    
    
        /*
         * Finish filling up the container structure with the embedded window's 
         * information.
         */
     
        containerPtr->embedded = (Window) macWin;
        containerPtr->embeddedPtr = macWin->winPtr;

        /*
         * Create an event handler to clean up the Container structure when
         * tkwin is eventually deleted.
         */
d353 27
a379 2
        Tk_CreateEventHandler(tkwin, StructureNotifyMask, EmbeddedEventProc,
                (ClientData) winPtr);
d383 1
a383 1
   /* 
d386 1
a386 1
     
d391 1
a391 1
        
d397 2
a398 2
    
    /* 
d401 1
a401 1
     
d405 1
a405 1
        
d410 1
a410 1
     
d419 4
a422 4
 *        This procedure is called to indicate that a particular window
 *        will be a container for an embedded application.  This changes
 *        certain aspects of the window's behavior, such as whether it
 *        will receive events anymore.
d425 1
a425 1
 *        None.
d428 1
a428 1
 *        None.
d435 2
a436 2
    Tk_Window tkwin)                /* Token for a window that is about to
                                 * become a container. */
d456 1
a456 1
    
d460 2
a461 2
     * resize it.  Also watch Configure events on the container so that
     * we can resize the child to match.  Also, pass activate events from
d466 2
a467 2
            SubstructureNotifyMask|SubstructureRedirectMask,
            ContainerEventProc, (ClientData) winPtr);
d469 1
a469 1
            (ClientData) containerPtr);
d471 1
a471 1
            (ClientData) containerPtr);
d473 2
a474 2
            (ClientData) containerPtr);
         
d482 2
a483 2
 *        Given an embedded window, this procedure returns the MacDrawable
 *        identifier for the associated container window.
d486 2
a487 2
 *        The return value is the MacDrawable for winPtr's
 *        container window.
d490 1
a490 1
 *        None.
d497 1
a497 1
    TkWindow *winPtr;                /* Tk's structure for an embedded window. */
d502 4
a505 4
            containerPtr = containerPtr->nextPtr) {
        if (containerPtr->embeddedPtr == winPtr) {
            return (MacDrawable *) containerPtr->parent;
        }
d516 2
a517 2
 *        Given the TkWindow, return the MacDrawable for the outermost
 *      toplevel containing it.  This will be a real Macintosh window.
d520 1
a520 1
 *        Returns a MacDrawable corresponding to a Macintosh Toplevel
d523 1
a523 1
 *        None.
d530 1
a530 1
    TkWindow *winPtr)                /* Tk's structure for a window. */
d536 1
a536 1
            return winPtr->privatePtr->toplevel;
d538 1
a538 1
        contWinPtr = TkpGetOtherWindow(topWinPtr);
d540 9
a548 9
        /*
         * NOTE: Here we should handle out of process embedding.
         */
        
        if (contWinPtr != NULL) {
            return TkMacOSXGetHostToplevel(contWinPtr);
        } else {
            return None;
        }
d557 4
a560 4
 *        This procedure is invoked when someone asks for the input focus
 *        to be put on a window in an embedded application, but the
 *        application doesn't currently have the focus.  It requests the
 *        input focus from the container application.
d563 1
a563 1
 *        None.
d566 1
a566 1
 *        The input focus may change.
d573 5
a577 5
    TkWindow *topLevelPtr,                /* Top-level window containing desired
                                         * focus window; should be embedded. */
    int force)                                /* One means that the container should
                                         * claim the focus if it doesn't
                                         * currently have it. */
d583 1
a583 1
        return;
d587 3
a589 3
            containerPtr->embeddedPtr != topLevelPtr;
            containerPtr = containerPtr->nextPtr) {
        /* Empty loop body. */
d591 1
a591 1
    
d608 3
a610 3
 *        This procedure implements the "testembed" command.  It returns
 *        some or all of the information in the list pointed to by
 *        firstContainerPtr.
d613 1
a613 1
 *        A standard Tcl result.
d616 1
a616 1
 *        None.
d623 4
a626 4
    ClientData clientData,                /* Main window for application. */
    Tcl_Interp *interp,                        /* Current interpreter. */
    int argc,                                /* Number of arguments. */
    CONST char **argv)                        /* Argument strings. */
d634 1
a634 1
        all = 1;
d636 1
a636 1
        all = 0;
d640 35
a674 35
            containerPtr = containerPtr->nextPtr) {
        Tcl_DStringStartSublist(&dString);
        if (containerPtr->parent == None) {
            Tcl_DStringAppendElement(&dString, "");
        } else {
            if (all) {
                sprintf(buffer, "0x%x", (int) containerPtr->parent);
                Tcl_DStringAppendElement(&dString, buffer);
            } else {
                Tcl_DStringAppendElement(&dString, "XXX");
            }
        }
        if (containerPtr->parentPtr == NULL) {
            Tcl_DStringAppendElement(&dString, "");
        } else {
            Tcl_DStringAppendElement(&dString,
                    containerPtr->parentPtr->pathName);
        }
        if (containerPtr->embedded == None) {
            Tcl_DStringAppendElement(&dString, "");
        } else {
            if (all) {
                sprintf(buffer, "0x%x", (int) containerPtr->embedded);
                Tcl_DStringAppendElement(&dString, buffer);
            } else {
                Tcl_DStringAppendElement(&dString, "XXX");
            }
        }
        if (containerPtr->embeddedPtr == NULL) {
            Tcl_DStringAppendElement(&dString, "");
        } else {
            Tcl_DStringAppendElement(&dString,
                    containerPtr->embeddedPtr->pathName);
        }
        Tcl_DStringEndSublist(&dString);
d685 7
a691 7
 *        This procedure is invoked when a key press or release event
 *        arrives for an application that does not believe it owns the
 *        input focus.  This can happen because of embedding; for example,
 *        X can send an event to an embedded application when the real
 *        focus window is in the container application and is an ancestor
 *        of the container.  This procedure's job is to forward the event
 *        back to the application where it really belongs.
d694 1
a694 1
 *        None.
d697 1
a697 1
 *        The event may get sent to a different application.
d704 4
a707 4
    TkWindow *winPtr,                /* Window to which the event was originally
                                 * reported. */
    XEvent *eventPtr)                /* X event to redirect (should be KeyPress
                                 * or KeyRelease). */
d716 2
a717 2
 *        If both the container and embedded window are in the same
 *        process, this procedure will return either one, given the other.
d720 3
a722 3
 *        If winPtr is a container, the return value is the token for the
 *        embedded window, and vice versa.  If the "other" window isn't in
 *        this process, NULL is returned.
d725 1
a725 1
 *        None.
d732 2
a733 2
    TkWindow *winPtr)                /* Tk's structure for a container or
                                 * embedded window. */
d743 1
a743 1
        return NULL;
d745 1
a745 1
    
d747 6
a752 6
            containerPtr = containerPtr->nextPtr) {
        if (containerPtr->embeddedPtr == winPtr) {
            return containerPtr->parentPtr;
        } else if (containerPtr->parentPtr == winPtr) {
            return containerPtr->embeddedPtr;
        }
d756 1
d762 3
a764 3
 *        This procedure is invoked by the Tk event dispatcher when various
 *        useful events are received for a window that is embedded in
 *        another application.
d767 1
a767 1
 *        None.
d770 2
a771 2
 *        Our internal state gets cleaned up when an embedded window is
 *        destroyed.
d777 3
a779 3
EmbeddedEventProc(clientData, eventPtr)
    ClientData clientData;                /* Token for container window. */
    XEvent *eventPtr;                        /* ResizeRequest event. */
d784 1
a784 1
        EmbedWindowDeleted(winPtr);
d793 4
a796 4
 *        This procedure is invoked by the Tk event dispatcher when various
 *        useful events are received for the children of a container
 *        window.  It forwards relevant information, such as geometry
 *        requests, from the events into the container's application.
d798 2
a799 2
 *        NOTE: on the Mac, only the DestroyNotify branch is ever taken.
 *      We don't synthesize the other events.
d802 1
a802 1
 *        None.
d805 2
a806 2
 *        Depends on the event.  For example, when ConfigureRequest events
 *        occur, geometry information gets set for the container window.
d812 3
a814 3
ContainerEventProc(clientData, eventPtr)
    ClientData clientData;                /* Token for container window. */
    XEvent *eventPtr;                        /* ResizeRequest event. */
d827 1
a827 1
            -1, -1, (Tk_ErrorProc *) NULL, (ClientData) NULL);
d834 5
a838 5
            containerPtr->parent != eventPtr->xmaprequest.parent;
            containerPtr = containerPtr->nextPtr) {
        if (containerPtr == NULL) {
            Tcl_Panic("ContainerEventProc couldn't find Container record");
        }
d842 6
a847 6
        /*
         * A new child window has been created in the container. Record
         * its id in the Container structure (if more than one child is
         * created, just remember the last one and ignore the earlier
         * ones).
         */
d849 1
a849 1
        containerPtr->embedded = eventPtr->xcreatewindow.window;
d851 22
a872 22
        if ((eventPtr->xconfigurerequest.x != 0)
                || (eventPtr->xconfigurerequest.y != 0)) {
            /*
             * The embedded application is trying to move itself, which
             * isn't legal.  At this point, the window hasn't actually
             * moved, but we need to send it a ConfigureNotify event to
             * let it know that its request has been denied.  If the
             * embedded application was also trying to resize itself, a
             * ConfigureNotify will be sent by the geometry management
             * code below, so we don't need to do anything.  Otherwise,
             * generate a synthetic event.
             */

            if ((eventPtr->xconfigurerequest.width == winPtr->changes.width)
                    && (eventPtr->xconfigurerequest.height
                    == winPtr->changes.height)) {
                EmbedSendConfigure(containerPtr);
            }
        }
        EmbedGeometryRequest(containerPtr,
                eventPtr->xconfigurerequest.width,
                eventPtr->xconfigurerequest.height);
d874 5
a878 5
        /*
         * The embedded application's map request was ignored and simply
         * passed on to us, so we have to map the window for it to appear
         * on the screen.
         */
d880 2
a881 2
        XMapWindow(eventPtr->xmaprequest.display,
                eventPtr->xmaprequest.window);
d883 3
a885 3
        /*
         * The embedded application is gone.  Destroy the container window.
         */
d887 1
a887 1
        Tk_DestroyWindow((Tk_Window) winPtr);
d897 5
a901 5
 *        This procedure is invoked by the Tk event dispatcher when
 *        a container window owned by this application gets resized
 *        (and also at several other times that we don't care about).
 *        This procedure reflects the size change in the embedded
 *        window that corresponds to the container.
d904 1
a904 1
 *        None.
d907 1
a907 1
 *        The embedded window gets resized to match the container.
d913 3
a915 3
EmbedStructureProc(clientData, eventPtr)
    ClientData clientData;                /* Token for container window. */
    XEvent *eventPtr;                        /* ResizeRequest event. */
d921 15
a935 15
        if (containerPtr->embedded != None) {
            /*
             * Ignore errors, since the embedded application could have
             * deleted its window.
             */

            errHandler = Tk_CreateErrorHandler(eventPtr->xfocus.display, -1,
                    -1, -1, (Tk_ErrorProc *) NULL, (ClientData) NULL);
            Tk_MoveResizeWindow((Tk_Window) containerPtr->embeddedPtr, 0, 0,
                    (unsigned int) Tk_Width(
                            (Tk_Window) containerPtr->parentPtr),
                    (unsigned int) Tk_Height(
                            (Tk_Window) containerPtr->parentPtr));
            Tk_DeleteErrorHandler(errHandler);
        }
d937 1
a937 1
        EmbedWindowDeleted(containerPtr->parentPtr);
d946 4
a949 4
 *        This procedure is invoked by the Tk event dispatcher when
 *        Activate and Deactivate events occur for a container window owned
 *        by this application.  It is responsible for forwarding an activate 
 *      event down into the embedded toplevel.
d952 1
a952 1
 *        None.
d955 1
a955 1
 *        The X focus may change.
d961 3
a963 3
EmbedActivateProc(clientData, eventPtr)
    ClientData clientData;                /* Token for container window. */
    XEvent *eventPtr;                        /* ResizeRequest event. */
d966 1
a966 1
    
d968 5
a972 5
        if (eventPtr->type == ActivateNotify) {
            TkGenerateActivateEvents(containerPtr->embeddedPtr,1);
        } else if (eventPtr->type == DeactivateNotify) {
            TkGenerateActivateEvents(containerPtr->embeddedPtr,0);
        }        
d981 5
a985 5
 *        This procedure is invoked by the Tk event dispatcher when
 *        FocusIn and FocusOut events occur for a container window owned
 *        by this application.  It is responsible for moving the focus
 *        back and forth between a container application and an embedded
 *        application.
d988 1
a988 1
 *        None.
d991 1
a991 1
 *        The X focus may change.
d997 3
a999 3
EmbedFocusProc(clientData, eventPtr)
    ClientData clientData;                /* Token for container window. */
    XEvent *eventPtr;                        /* ResizeRequest event. */
d1007 6
a1012 6
        event.xfocus.serial = LastKnownRequestProcessed(display);
        event.xfocus.send_event = false;
        event.xfocus.display = display;
        event.xfocus.mode = NotifyNormal;
        event.xfocus.window = containerPtr->embedded; 
        
d1014 21
a1034 21
        /*
         * The focus just arrived at the container.  Change the X focus
         * to move it to the embedded application, if there is one. 
         * Ignore X errors that occur during this operation (it's
         * possible that the new focus window isn't mapped).
         */
    
            event.xfocus.detail = NotifyNonlinear;
            event.xfocus.type = FocusIn;

        } else if (eventPtr->type == FocusOut) {
        /* When the container gets a FocusOut event, it has to  tell the embedded app
         * that it has lost the focus.
         */
         
            event.xfocus.type = FocusOut;
            event.xfocus.detail = NotifyNonlinear;
         }
         
        Tk_QueueWindowEvent(&event, TCL_QUEUE_MARK);
    } 
d1042 4
a1045 4
 *        This procedure is invoked when an embedded application requests
 *        a particular size.  It processes the request (which may or may
 *        not actually honor the request) and reflects the results back
 *        to the embedded application.
d1047 2
a1048 2
 *      NOTE: On the Mac, this is a stub, since we don't synthesize
 *      ConfigureRequest events.
d1051 1
a1051 1
 *        None.
d1054 4
a1057 4
 *        If we deny the child's size change request, a Configure event
 *        is synthesized to let the child know how big it ought to be.
 *        Events get processed while we're waiting for the geometry
 *        managers to do their thing.
d1063 3
a1065 3
EmbedGeometryRequest(containerPtr, width, height)
    Container *containerPtr;        /* Information about the embedding. */
    int width, height;                /* Size that the child has requested. */
d1071 1
a1071 1
     * via the container window.  We need to send a Configure event back
d1081 1
a1081 1
        /* Empty loop body. */
d1084 2
a1085 2
            || (winPtr->changes.height != height)) {
        EmbedSendConfigure(containerPtr);
d1094 7
a1100 7
 *        This is currently a stub.  It is called to notify an
 *        embedded application of its current size and location.  This
 *        procedure is called when the embedded application made a
 *        geometry request that we did not grant, so that the embedded
 *        application knows that its geometry didn't change after all.
 *      It is a response to ConfigureRequest events, which we do not
 *      currently synthesize on the Mac
d1103 1
a1103 1
 *        None.
d1106 1
a1106 1
 *        None.
d1112 2
a1113 2
EmbedSendConfigure(containerPtr)
    Container *containerPtr;        /* Information about the embedding. */
d1122 3
a1124 3
 *        This procedure is invoked when a window involved in embedding
 *        (as either the container or the embedded application) is
 *        destroyed.  It cleans up the Container structure for the window.
d1127 1
a1127 1
 *        None.
d1130 1
a1130 1
 *        A Container structure may be freed.
d1136 3
a1138 3
EmbedWindowDeleted(winPtr)
    TkWindow *winPtr;                /* Tk's information about window that
                                 * was deleted. */
d1143 1
a1143 1
     * Find the Container structure for this window.  Delete the
d1151 6
a1156 1
        if (containerPtr->embeddedPtr == winPtr) {
d1158 27
a1184 32
            /*
             * We also have to destroy our parent, to clean up the container.
             * Fabricate an event to do this.
             */
             
            if (containerPtr->parentPtr != NULL &&
                    containerPtr->parentPtr->flags & TK_BOTH_HALVES) {
                XEvent event;
                
                event.xany.serial = 
                    Tk_Display(containerPtr->parentPtr)->request;
                    event.xany.send_event = False;
                    event.xany.display = Tk_Display(containerPtr->parentPtr);
        
                    event.xany.type = DestroyNotify;
                    event.xany.window = containerPtr->parent;
                    event.xdestroywindow.event = containerPtr->parent;
                    Tk_QueueWindowEvent(&event, TCL_QUEUE_HEAD);

            }
            
            containerPtr->embedded = None;
            containerPtr->embeddedPtr = NULL;
            
            break;
        }
        if (containerPtr->parentPtr == winPtr) {
            containerPtr->parentPtr = NULL;
            break;
        }
        prevPtr = containerPtr;
        containerPtr = containerPtr->nextPtr;
d1187 7
a1193 7
            && (containerPtr->parentPtr == NULL)) {
        if (prevPtr == NULL) {
            firstContainerPtr = containerPtr->nextPtr;
        } else {
            prevPtr->nextPtr = containerPtr->nextPtr;
        }
        ckfree((char *) containerPtr);
a1195 1

@

