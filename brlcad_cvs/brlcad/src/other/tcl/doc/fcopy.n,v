head	1.4;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@# @;


1.4
date	2007.11.06.21.35.18;	author erikgreenwald;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.14.15.21.50;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.21;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.48.04;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@tcl 8.5a6->8.5b1
@
text
@'\"
'\" Copyright (c) 1993 The Regents of the University of California.
'\" Copyright (c) 1994-1997 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @@(#) $Id: fcopy.n,v 1.10 2007/07/04 14:45:19 dkf Exp $
'\" 
.so man.macros
.TH fcopy n 8.0 Tcl "Tcl Built-In Commands"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
fcopy \- Copy data from one channel to another
.SH SYNOPSIS
\fBfcopy \fIinchan\fR \fIoutchan\fR ?\fB\-size \fIsize\fR? ?\fB\-command \fIcallback\fR?
.BE

.SH DESCRIPTION
.PP
The \fBfcopy\fR command copies data from one I/O channel, \fIinchan\fR to another I/O channel, \fIoutchan\fR.
The \fBfcopy\fR command leverages the buffering in the Tcl I/O system to
avoid extra copies and to avoid buffering too much data in
main memory when copying large files to slow destinations like
network sockets.
.PP
The \fBfcopy\fR 
command transfers data from \fIinchan\fR until end of file
or \fIsize\fR bytes have been 
transferred. If no \fB\-size\fR argument is given,
then the copy goes until end of file.
All the data read from \fIinchan\fR is copied to \fIoutchan\fR.
Without the \fB\-command\fR option, \fBfcopy\fR blocks until the copy is complete
and returns the number of bytes written to \fIoutchan\fR.
.PP
The \fB\-command\fR argument makes \fBfcopy\fR work in the background.
In this case it returns immediately and the \fIcallback\fR is invoked
later when the copy completes.
The \fIcallback\fR is called with
one or two additional 
arguments that indicates how many bytes were written to \fIoutchan\fR.
If an error occurred during the background copy, the second argument is the
error string associated with the error.
With a background copy,
it is not necessary to put \fIinchan\fR or \fIoutchan\fR into
non-blocking mode; the \fBfcopy\fR command takes care of that automatically.
However, it is necessary to enter the event loop by using
the \fBvwait\fR command or by using Tk.
.PP
You are not allowed to do other I/O operations with
\fIinchan\fR or \fIoutchan\fR during a background \fBfcopy\fR.
If either \fIinchan\fR or \fIoutchan\fR get closed
while the copy is in progress, the current copy is stopped
and the command callback is \fInot\fR made.
If \fIinchan\fR is closed,
then all data already queued for \fIoutchan\fR is written out.
.PP
Note that \fIinchan\fR can become readable during a background copy.
You should turn off any \fBfileevent\fR handlers during a background
copy so those handlers do not interfere with the copy.
Any I/O attempted by a \fBfileevent\fR handler will get a "channel busy" error.
.PP
\fBFcopy\fR translates end-of-line sequences in \fIinchan\fR and \fIoutchan\fR
according to the \fB\-translation\fR option
for these channels.
See the manual entry for \fBfconfigure\fR for details on the
\fB\-translation\fR option.
The translations mean that the number of bytes read from \fIinchan\fR
can be different than the number of bytes written to \fIoutchan\fR.
Only the number of bytes written to \fIoutchan\fR is reported,
either as the return value of a synchronous \fBfcopy\fR or
as the argument to the callback for an asynchronous \fBfcopy\fR.
.PP
\fBFcopy\fR obeys the encodings and character translations configured
for the channels. This
means that the incoming characters are converted internally first
UTF-8 and then into the encoding of the channel \fBfcopy\fR writes
to. See the manual entry for \fBfconfigure\fR for details on the
\fB\-encoding\fR and \fB\-translation\fR options. No conversion is
done if both channels are
set to encoding "binary" and have matching translations. If only the
output channel is set to
encoding "binary" the system will write the internal UTF-8
representation of the incoming characters. If only the input channel
is set to encoding "binary" the system will assume that the incoming
bytes are valid UTF-8 characters and convert them according to the
output encoding. The behaviour of the system for bytes which are not
valid UTF-8 characters is undefined in this case.

.SH EXAMPLES
.PP
The first example transfers the contents of one channel exactly to
another. Note that when copying one file to another, it is better to
use \fBfile copy\fR which also copies file metadata (e.g. the file
access permissions) where possible.
.DS
fconfigure $in -translation binary
fconfigure $out -translation binary
\fBfcopy\fR $in $out
.DE
.PP
This second example shows how the callback gets
passed the number of bytes transferred.
It also uses vwait to put the application into the event loop.
Of course, this simplified example could be done without the command 
callback.
.DS
proc Cleanup {in out bytes {error {}}} {
    global total
    set total $bytes
    close $in
    close $out
    if {[string length $error] != 0} {
	# error occurred during the copy
    }
}
set in [open $file1]
set out [socket $server $port]
\fBfcopy\fR $in $out -command [list Cleanup $in $out]
vwait total
.DE
.PP
The third example copies in chunks and tests for end of file
in the command callback
.DS
proc CopyMore {in out chunk bytes {error {}}} {
    global total done
    incr total $bytes
    if {([string length $error] != 0) || [eof $in]} {
	set done $total
	close $in
	close $out
    } else {
	\fBfcopy\fR $in $out -size $chunk \\
                -command [list CopyMore $in $out $chunk]
    }
}
set in [open $file1]
set out [socket $server $port]
set chunk 1024
set total 0
\fBfcopy\fR $in $out -size $chunk \\
        -command [list CopyMore $in $out $chunk]
vwait done
.DE

.SH "SEE ALSO"
eof(n), fblocked(n), fconfigure(n), file(n)

.SH KEYWORDS
blocking, channel, end of line, end of file, nonblocking, read, translation
@


1.3
log
@removed trailing whitespace
@
text
@d7 3
a9 3
'\"
'\" RCS: @@(#) $Id: fcopy.n,v 1.2 2007/05/07 04:17:21 brlcad Exp $
'\"
d28 1
a28 1
The \fBfcopy\fR
d30 1
a30 1
or \fIsize\fR bytes have been
d41 1
a41 1
one or two additional
d106 1
a106 1
Of course, this simplified example could be done without the command
d135 2
a136 2
	\fBfcopy\fR $in $out -command [list CopyMore $in $out $chunk] \\
	    -size $chunk
d143 2
a144 1
\fBfcopy\fR $in $out -command [list CopyMore $in $out $chunk] -size $chunk
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d7 3
a9 3
'\" 
'\" RCS: @@(#) $Id: fcopy.n,v 1.9 2007/01/29 16:51:38 dgp Exp $
'\" 
d28 1
a28 1
The \fBfcopy\fR 
d30 1
a30 1
or \fIsize\fR bytes have been 
d41 1
a41 1
one or two additional 
d106 1
a106 1
Of course, this simplified example could be done without the command 
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: fcopy.n,v 1.6 2005/05/10 18:33:59 kennykb Exp $
d22 2
a23 2
The \fBfcopy\fP command copies data from one I/O channel, \fIinchan\fR to another I/O channel, \fIoutchan\fR.
The \fBfcopy\fP command leverages the buffering in the Tcl I/O system to
d28 1
a28 1
The \fBfcopy\fP 
d30 2
a31 2
or \fIsize\fP bytes have been 
transferred. If no \fB\-size\fP argument is given,
d34 1
a34 1
Without the \fB\-command\fP option, \fBfcopy\fP blocks until the copy is complete
d37 2
a38 2
The \fB\-command\fP argument makes \fBfcopy\fP work in the background.
In this case it returns immediately and the \fIcallback\fP is invoked
d40 1
a40 1
The \fIcallback\fP is called with
d47 1
a47 1
non-blocking mode; the \fBfcopy\fP command takes care of that automatically.
d49 1
a49 1
the \fBvwait\fP command or by using Tk.
d52 1
a52 1
\fIinchan\fR or \fIoutchan\fR during a background fcopy.
d55 1
a55 1
and the command callback is \fInot\fP made.
d60 1
a60 1
You should turn off any \fBfileevent\fP handlers during a background
d62 1
a62 1
Any I/O attempted by a \fBfileevent\fP handler will get a "channel busy" error.
d72 2
a73 2
either as the return value of a synchronous \fBfcopy\fP or
as the argument to the callback for an asynchronous \fBfcopy\fP.
d130 1
a130 1
    if {([string length $error] != 0) || [eof $in] {
@

