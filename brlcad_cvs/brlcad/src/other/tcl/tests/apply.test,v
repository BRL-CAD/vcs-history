head	1.4;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@# @;


1.4
date	2007.11.06.21.35.25;	author erikgreenwald;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.14.15.21.53;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.07.04.17.32;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.02.21.49.20;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.4
log
@tcl 8.5a6->8.5b1
@
text
@# Commands covered:  apply
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1993 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# Copyright (c) 2005-2006 Miguel Sofer
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: apply.test,v 1.11 2007/09/09 19:28:31 dgp Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.2
    namespace import -force ::tcltest::*
}

if {[info commands ::apply] eq {}} {
    return
}

testConstraint memory [llength [info commands memory]]

# Tests for wrong number of arguments

test apply-1.1 {too few arguments} {
    set res [catch apply msg]
    list $res $msg
} {1 {wrong # args: should be "apply lambdaExpr ?arg1 arg2 ...?"}}

# Tests for malformed lambda

test apply-2.0 {malformed lambda} {
    set lambda a
    set res [catch {apply $lambda} msg]
    list $res $msg
} {1 {can't interpret "a" as a lambda expression}}
test apply-2.1 {malformed lambda} {
    set lambda [list a b c d]
    set res [catch {apply $lambda} msg]
    list $res $msg
} {1 {can't interpret "a b c d" as a lambda expression}}
test apply-2.2 {malformed lambda} {
    set lambda [list {{}} boo]
    set res [catch {apply $lambda} msg]
    list $res $msg $::errorInfo
} {1 {argument with no name} {argument with no name
    (parsing lambda expression "{{}} boo")
    invoked from within
"apply $lambda"}}
test apply-2.3 {malformed lambda} {
    set lambda [list {{a b c}} boo]
    set res [catch {apply $lambda} msg]
    list $res $msg $::errorInfo
} {1 {too many fields in argument specifier "a b c"} {too many fields in argument specifier "a b c"
    (parsing lambda expression "{{a b c}} boo")
    invoked from within
"apply $lambda"}}
test apply-2.4 {malformed lambda} {
    set lambda [list a(1) boo]
    set res [catch {apply $lambda} msg]
    list $res $msg $::errorInfo
} {1 {formal parameter "a(1)" is an array element} {formal parameter "a(1)" is an array element
    (parsing lambda expression "a(1) boo")
    invoked from within
"apply $lambda"}}
test apply-2.5 {malformed lambda} {
    set lambda [list a::b boo]
    set res [catch {apply $lambda} msg]
    list $res $msg $::errorInfo
} {1 {formal parameter "a::b" is not a simple name} {formal parameter "a::b" is not a simple name
    (parsing lambda expression "a::b boo")
    invoked from within
"apply $lambda"}}

# Tests for runtime errors in the lambda expression

test apply-3.1 {non-existing namespace} -body {
    apply [list x {set x 1} ::NONEXIST::FOR::SURE] x
} -returnCodes error -result {namespace "::NONEXIST::FOR::SURE" not found}
test apply-3.2 {non-existing namespace} -body {
    namespace eval ::NONEXIST::FOR::SURE {}
    set lambda [list x {set x 1} ::NONEXIST::FOR::SURE]
    apply $lambda x
    namespace delete ::NONEXIST
    apply $lambda x
} -returnCodes error -result {namespace "::NONEXIST::FOR::SURE" not found}
test apply-3.3 {non-existing namespace} -body {
    apply [list x {set x 1} NONEXIST::FOR::SURE] x
} -returnCodes error -result {namespace "::NONEXIST::FOR::SURE" not found}
test apply-3.4 {non-existing namespace} -body {
    namespace eval ::NONEXIST::FOR::SURE {}
    set lambda [list x {set x 1} NONEXIST::FOR::SURE]
    apply $lambda x
    namespace delete ::NONEXIST
    apply $lambda x
} -returnCodes error -result {namespace "::NONEXIST::FOR::SURE" not found}

test apply-4.1 {error in arguments to lambda expression} {
    set lambda [list x {set x 1}]
    set res [catch {apply $lambda} msg]
    list $res $msg
} {1 {wrong # args: should be "apply {x {set x 1}} x"}}
test apply-4.2 {error in arguments to lambda expression} {
    set lambda [list x {set x 1}]
    set res [catch {apply $lambda a b} msg]
    list $res $msg
} {1 {wrong # args: should be "apply {x {set x 1}} x"}}
test apply-4.3 {error in arguments to lambda expression} {
    set lambda [list x {set x 1}]
    interp alias {} foo {} ::apply $lambda
    set res [catch {foo a b} msg]
    list $res $msg [rename foo {}]
} {1 {wrong # args: should be "foo x"} {}}
test apply-4.4 {error in arguments to lambda expression} {
    set lambda [list x {set x 1}]
    interp alias {} foo {} ::apply $lambda a
    set res [catch {foo b} msg]
    list $res $msg [rename foo {}]
} {1 {wrong # args: should be "foo"} {}}
test apply-4.5 {error in arguments to lambda expression} {
    set lambda [list x {set x 1}]
    namespace eval a {
	namespace ensemble create -command ::bar -map {id {::a::const foo}}
	proc const val { return $val }
	proc alias {object slot = command args} {
	    set map [namespace ensemble configure $object -map]
	    dict set map $slot [linsert $args 0 $command]
	    namespace ensemble configure $object -map $map
	}
	proc method {object name params body} {
	    set params [linsert $params 0 self]
	    alias $object $name = ::apply [list $params $body] $object
	}
	method ::bar boo x {return "[expr {$x*$x}] - $self"}
    }
    set res [catch {bar boo} msg]
    list $res $msg [namespace delete ::a]
} {1 {wrong # args: should be "bar boo x"} {}}

test apply-5.1 {runtime error in lambda expression} {
    set lambda [list {} {error foo}]
    set res [catch {apply $lambda}]
    list $res $::errorInfo
} {1 {foo
    while executing
"error foo"
    (lambda term "{} {error foo}" line 1)
    invoked from within
"apply $lambda"}}

# Tests for correct execution; as the implementation is the same as that for
# procs, the general functionality is mostly tested elsewhere

test apply-6.1 {info level} {
    set lev [info level]
    set lambda [list {} {info level}]
    expr {[apply $lambda] - $lev}
} 1
test apply-6.2 {info level} {
    set lambda [list {} {info level 0}]
    apply $lambda
} {apply {{} {info level 0}}}
test apply-6.3 {info level} {
    set lambda [list args {info level 0}]
    apply $lambda x y
} {apply {args {info level 0}} x y}

# Tests for correct namespace scope

namespace eval ::testApply {
    proc testApply args {return testApply}
}

test apply-7.1 {namespace access} {
    set ::testApply::x 0
    set body {set x 1; set x}
    list [apply [list args $body ::testApply]] $::testApply::x
} {1 0}
test apply-7.2 {namespace access} {
    set ::testApply::x 0
    set body {variable x; set x}
    list [apply [list args $body ::testApply]] $::testApply::x
} {0 0}
test apply-7.3 {namespace access} {
    set ::testApply::x 0
    set body {variable x; set x 1}
    list [apply [list args $body ::testApply]] $::testApply::x
} {1 1}
test apply-7.4 {namespace access} {
    set ::testApply::x 0
    set body {testApply}
    apply [list args $body ::testApply]
} testApply
test apply-7.5 {namespace access} {
    set ::testApply::x 0
    set body {set x 1; set x}
    list [apply [list args $body testApply]] $::testApply::x
} {1 0}
test apply-7.6 {namespace access} {
    set ::testApply::x 0
    set body {variable x; set x}
    list [apply [list args $body testApply]] $::testApply::x
} {0 0}
test apply-7.7 {namespace access} {
    set ::testApply::x 0
    set body {variable x; set x 1}
    list [apply [list args $body testApply]] $::testApply::x
} {1 1}
test apply-7.8 {namespace access} {
    set ::testApply::x 0
    set body {testApply}
    apply [list args $body testApply]
} testApply

# Tests for correct argument treatment

set applyBody {
    set res {}
    foreach v [info locals] {
	if {$v eq "res"} continue
	lappend res [list $v [set $v]]
    }
    set res
}

test apply-8.1 {args treatment} {
    apply [list args $applyBody] 1 2 3
} {{args {1 2 3}}}
test apply-8.2 {args treatment} {
    apply [list {x args} $applyBody] 1 2
} {{x 1} {args 2}}
test apply-8.3 {args treatment} {
    apply [list {x args} $applyBody] 1 2 3
} {{x 1} {args {2 3}}}
test apply-8.4 {default values} {
    apply [list {{x 1} {y 2}} $applyBody] 
} {{x 1} {y 2}}
test apply-8.5 {default values} {
    apply [list {{x 1} {y 2}} $applyBody] 3 4
} {{x 3} {y 4}}
test apply-8.6 {default values} {
    apply [list {{x 1} {y 2}} $applyBody] 3
} {{x 3} {y 2}}
test apply-8.7 {default values} {
    apply [list {x {y 2}} $applyBody] 1
} {{x 1} {y 2}}
test apply-8.8 {default values} {
    apply [list {x {y 2}} $applyBody] 1 3
} {{x 1} {y 3}}
test apply-8.9 {default values} {
    apply [list {x {y 2} args} $applyBody] 1
} {{x 1} {y 2} {args {}}}
test apply-8.10 {default values} {
    apply [list {x {y 2} args} $applyBody] 1 3
} {{x 1} {y 3} {args {}}}

# Tests for leaks

test apply-9.1 {leaking internal rep} -setup {
    proc getbytes {} {
	set lines [split [memory info] "\n"]
	lindex $lines 3 3
    }
    set lam [list {} {set a 1}]
} -constraints memory -body {
    set end [getbytes]
    for {set i 0} {$i < 5} {incr i} {
	::apply [lrange $lam 0 end]
	set tmp $end
	set end [getbytes]
    }
    set leakedBytes [expr {$end - $tmp}]
} -cleanup {
    rename getbytes {}
    unset lam
} -result 0
test apply-9.2 {leaking internal rep} -setup {
    proc getbytes {} {
	set lines [split [memory info] "\n"]
	lindex $lines 3 3
    }
} -constraints memory -body {
    set end [getbytes]
    for {set i 0} {$i < 5} {incr i} {
	::apply [list {} {set a 1}]
	set tmp $end
	set end [getbytes]
    }
    set leakedBytes [expr {$end - $tmp}]
} -cleanup {
    rename getbytes {}
} -result 0
test apply-9.3 {leaking internal rep} -setup {
    proc getbytes {} {
	set lines [split [memory info] "\n"]
	lindex $lines 3 3
    }
} -constraints memory -body {
    set end [getbytes]
    for {set i 0} {$i < 5} {incr i} {
	set x [list {} {set a 1} ::NS::THAT::DOES::NOT::EXIST]
	catch {::apply $x}
	set x {}
	set tmp $end
	set end [getbytes]
    }
    set leakedBytes [expr {$end - $tmp}]
} -cleanup {
    rename getbytes {}
} -result 0

# Tests for the avoidance of recompilation

# cleanup

namespace delete testApply

::tcltest::cleanupTests
return
@


1.3
log
@removed trailing whitespace
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: apply.test,v 1.2 2007/05/07 04:17:32 brlcad Exp $
d18 1
a18 1
    package require tcltest
d82 4
a85 6
test apply-3.1 {non-existing namespace} {
    set lambda [list x {set x 1} ::NONEXIST::FOR::SURE]
    set res [catch {apply $lambda x} msg]
    list $res $msg
} {1 {cannot find namespace "::NONEXIST::FOR::SURE"}}
test apply-3.2 {non-existing namespace} {
d90 6
a95 9
    set res [catch {apply $lambda x} msg]
    list $res $msg
} {1 {cannot find namespace "::NONEXIST::FOR::SURE"}}
test apply-3.3 {non-existing namespace} {
    set lambda [list x {set x 1} NONEXIST::FOR::SURE]
    set res [catch {apply $lambda x} msg]
    list $res $msg
} {1 {cannot find namespace "::NONEXIST::FOR::SURE"}}
test apply-3.4 {non-existing namespace} {
d100 2
a101 3
    set res [catch {apply $lambda x} msg]
    list $res $msg
} {1 {cannot find namespace "::NONEXIST::FOR::SURE"}}
d241 1
a241 1
    apply [list {{x 1} {y 2}} $applyBody]
@


1.2
log
@upgrade to tcl/tk 8.5a6 (from 8.5a5) .. includes even more (extensive) aquatk fixes/enhancements
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: apply.test,v 1.10 2007/03/29 19:22:08 msofer Exp $
d247 1
a247 1
    apply [list {{x 1} {y 2}} $applyBody] 
@


1.1
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: apply.test,v 1.7 2006/10/16 20:36:19 msofer Exp $
d26 1
a26 1
testConstraint memory     [llength [info commands memory]]
a41 1

a46 1

a54 1

a62 1

a70 1

a79 1

a86 1

a94 1

a99 1

a113 1

d116 1
a116 1
    set res [catch {apply $lambda x y} msg]
d119 31
d158 1
a158 1
    (procedure "apply {{} {error foo}}" line 1)
a169 1

a173 1

a189 1

a194 1

a199 1

a204 1

a209 1

a214 1

a219 1

a225 1

a239 1

a242 1

a245 1

a248 1

a251 1

a254 1

a257 1

a260 1

a263 1

d304 18
@

