head	1.2;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.4
	rel-7-10-2:1.2
	rel-7-10-0:1.2
	rel-7-8-4:1.2
	rel-7-8-2:1.2
	rel-7-8-0:1.2
	trimnurbs-branch:1.2.0.2
	help:1.2
	temp_tag:1.2
	bobWinPort-20051223-freeze:1.1.2.3
	postmerge-20051223-bobWinPort:1.2
	bobWinPort:1.1.0.2;
locks; strict;
comment	@ * @;


1.2
date	2005.12.23.21.26.45;	author bob1961;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.08.20.50.35;	author bob1961;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.09.08.20.50.35;	author bob1961;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.09.21.13.00.21;	author bob1961;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2005.09.26.12.38.57;	author bob1961;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge of bobWinPort
@
text
@/*
 * init.c --
 *
 *  Generic photo image type initialization, Tcl/Tk package
 *
 * Copyright (c) 2002 Andreas Kupries <andreas_kupries@@users.sourceforge.net>
 *
 * $Id: init.c,v 1.1.2.3 2005/09/26 12:38:57 bob1961 Exp $
 *
 */

#include "tk.h"
#include "tkimg.h"

#ifndef MORE_INITIALIZATION
#define MORE_INITIALIZATION /* Nothing */
#endif

/*
 * Declarations of internal functions.
 */

static int ChnMatch _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, int *widthPtr,
	int *heightPtr));

static int ObjMatch _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
	Tcl_Obj *format, int *widthPtr, int *heightPtr));

static int ChnRead _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));

static int ObjRead _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
	Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));

static int ChnWrite _ANSI_ARGS_((Tcl_Interp *interp, CONST char *filename,
	Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));

static int StringWrite _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_DString *data, Tcl_Obj *format,
	Tk_PhotoImageBlock *blockPtr));

static Tk_PhotoImageFormat format = {
    "png",					/* name */
    (Tk_ImageFileMatchProc *)   ChnMatch,	/* fileMatchProc */
    (Tk_ImageStringMatchProc *) ObjMatch,	/* stringMatchProc */
    (Tk_ImageFileReadProc *)    ChnRead,	/* fileReadProc */
    (Tk_ImageStringReadProc *)  ObjRead,	/* stringReadProc */
    (Tk_ImageFileWriteProc *)   ChnWrite,	/* fileWriteProc */
    (Tk_ImageStringWriteProc *) StringWrite	/* stringWriteProc */
};

#ifdef SECOND_FORMAT
/*
 * Declare procedures of the second format as needed. The macro we
 * check for allow us to share code between first and second
 * format. Current user of this feature: The PS/PDF combo handler
 */

#ifndef SECOND_CHNMATCH
#define SECOND_CHNMATCH ChnMatchBeta
static int ChnMatchBeta _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, int *widthPtr,
	int *heightPtr));
#endif
#ifndef SECOND_OBJMATCH
#define SECOND_OBJMATCH ObjMatchBeta
static int ObjMatchBeta _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
	Tcl_Obj *format, int *widthPtr, int *heightPtr));
#endif
#ifndef SECOND_CHNREAD
#define SECOND_CHNREAD ChnReadBeta
static int ChnReadBeta _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));
#endif
#ifndef SECOND_OBJREAD
#define SECOND_OBJREAD ChnObjReadBeta
static int ObjReadBeta _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
	Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));
#endif
#ifndef SECOND_CHNWRITE
#define SECOND_CHNWRITE ChnWriteBeta
static int ChnWriteBeta _ANSI_ARGS_((Tcl_Interp *interp, CONST char *filename,
	Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));
#endif
#ifndef SECOND_STRWRITE
#define SECOND_STRWRITE StringWriteBeta
static int StringWriteBeta _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_DString *data, Tcl_Obj *format,
	Tk_PhotoImageBlock *blockPtr));
#endif

static Tk_PhotoImageFormat format_beta = {
    %PHIMGTYPE_BETA%,					/* name */
    (Tk_ImageFileMatchProc *)   SECOND_CHNMATCH,	/* fileMatchProc */
    (Tk_ImageStringMatchProc *) SECOND_OBJMATCH,	/* stringMatchProc */
    (Tk_ImageFileReadProc *)    SECOND_CHNREAD,		/* fileReadProc */
    (Tk_ImageStringReadProc *)  SECOND_OBJREAD,		/* stringReadProc */
    (Tk_ImageFileWriteProc *)   SECOND_CHNWRITE,	/* fileWriteProc */
    (Tk_ImageStringWriteProc *) SECOND_STRWRITE		/* stringWriteProc */
};

#endif /* SECOND_FORMAT */


/*
 *----------------------------------------------------------------------------
 *
 * Tkimgpng_Init --
 *
 *  Initialisation routine for loadable module
 *
 * Results:
 *  None.
 *
 * Side effects:
 *  Creates commands in the interpreter, loads package.
 *
 *----------------------------------------------------------------------------
 */

int
#ifdef _DEBUG
Tkimgpng_d_Init (interp)
#else
Tkimgpng_Init (interp)
#endif
      Tcl_Interp *interp; /* Interpreter to initialise. */
{
#if 0
#ifdef USE_TCL_STUBS
    if (Tcl_InitStubs(interp, "8.1", 0) == NULL) {
        return TCL_ERROR;
    }
#endif
#ifdef USE_TK_STUBS
    if (Tk_InitStubs(interp, "8.1", 0) == NULL) {
        return TCL_ERROR;
    }
#endif
#endif

#ifdef USE_TKIMG_STUBS
    if (Tkimg_InitStubs(interp, "1.3", 0) == NULL) {
        return TCL_ERROR;
    }
#endif

    MORE_INITIALIZATION;

    /*
     * Register the new photo image type.
     */

    Tk_CreatePhotoImageFormat (&format);
#ifdef SECOND_FORMAT
    Tk_CreatePhotoImageFormat (&format_beta);
#endif /* SECOND_FORMAT */

    /*
     * At last provide the package ...
     */

    if (Tcl_PkgProvide(interp, TKIMG_PNG_PACKAGE_NAME, TKIMG_VERSION) != TCL_OK) {
        return TCL_ERROR;
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------------
 *
 * Tkimgpng_SafeInit --
 *
 *  Initialisation routine for loadable module in a safe interpreter.
 *
 * Results:
 *  None.
 *
 * Side effects:
 *  Creates commands in the interpreter,
 *  loads xml package.
 *
 *----------------------------------------------------------------------------
 */

int
#ifdef _DEBUG
Tkimgpng_d_SafeInit (interp)
#else
Tkimgpng_SafeInit (interp)
#endif
      Tcl_Interp *interp; /* Interpreter to initialise. */
{
#ifdef _DEBUG
    return Tkimgpng_d_Init (interp);
#else
    return Tkimgpng_Init (interp);
#endif
}

@


1.1
log
@file init.c was initially added on branch bobWinPort.
@
text
@d1 206
@


1.1.2.1
log
@Initial check-in
@
text
@a0 224
/*
 * init.c --
 *
 *  Generic photo image type initialization, Tcl/Tk package
 *
 * Copyright (c) 2002 Andreas Kupries <andreas_kupries@@users.sourceforge.net>
 *
 * $Id: init.c,v 1.4 2002/12/07 00:11:37 andreas_kupries Exp $
 *
 */

#include "tk.h"
#include "tkimg.h"

#ifndef MORE_INITIALIZATION
#define MORE_INITIALIZATION /* Nothing */
#endif

#undef TCL_STORAGE_CLASS
#ifdef BUILD_tkimgpng
# define TCL_STORAGE_CLASS DLLEXPORT
#else
# ifdef USE_TKIMGPNG_STUBS
#  define TCL_STORAGE_CLASS
# else
#  define TCL_STORAGE_CLASS DLLIMPORT
# endif
#endif

/*
 * Functions exported for package management.
 */


#ifdef _DEBUG
EXTERN int Tkimgpng_d_Init     _ANSI_ARGS_((Tcl_Interp *interp));
#else
EXTERN int Tkimgpng_Init     _ANSI_ARGS_((Tcl_Interp *interp));
#endif
EXTERN int Tkimgpng_SafeInit _ANSI_ARGS_((Tcl_Interp *interp));

#undef  TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

/*
 * Declarations of internal functions.
 */

static int ChnMatch _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, int *widthPtr,
	int *heightPtr));

static int ObjMatch _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
	Tcl_Obj *format, int *widthPtr, int *heightPtr));

static int ChnRead _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));

static int ObjRead _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
	Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));

static int ChnWrite _ANSI_ARGS_((Tcl_Interp *interp, CONST char *filename,
	Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));

static int StringWrite _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_DString *data, Tcl_Obj *format,
	Tk_PhotoImageBlock *blockPtr));

static Tk_PhotoImageFormat format = {
    "png",					/* name */
    (Tk_ImageFileMatchProc *)   ChnMatch,	/* fileMatchProc */
    (Tk_ImageStringMatchProc *) ObjMatch,	/* stringMatchProc */
    (Tk_ImageFileReadProc *)    ChnRead,	/* fileReadProc */
    (Tk_ImageStringReadProc *)  ObjRead,	/* stringReadProc */
    (Tk_ImageFileWriteProc *)   ChnWrite,	/* fileWriteProc */
    (Tk_ImageStringWriteProc *) StringWrite	/* stringWriteProc */
};

#ifdef SECOND_FORMAT
/*
 * Declare procedures of the second format as needed. The macro we
 * check for allow us to share code between first and second
 * format. Current user of this feature: The PS/PDF combo handler
 */

#ifndef SECOND_CHNMATCH
#define SECOND_CHNMATCH ChnMatchBeta
static int ChnMatchBeta _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, int *widthPtr,
	int *heightPtr));
#endif
#ifndef SECOND_OBJMATCH
#define SECOND_OBJMATCH ObjMatchBeta
static int ObjMatchBeta _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
	Tcl_Obj *format, int *widthPtr, int *heightPtr));
#endif
#ifndef SECOND_CHNREAD
#define SECOND_CHNREAD ChnReadBeta
static int ChnReadBeta _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Channel chan,
	CONST char *fileName, Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));
#endif
#ifndef SECOND_OBJREAD
#define SECOND_OBJREAD ChnObjReadBeta
static int ObjReadBeta _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
	Tcl_Obj *format, Tk_PhotoHandle imageHandle,
	int destX, int destY, int width, int height, int srcX, int srcY));
#endif
#ifndef SECOND_CHNWRITE
#define SECOND_CHNWRITE ChnWriteBeta
static int ChnWriteBeta _ANSI_ARGS_((Tcl_Interp *interp, CONST char *filename,
	Tcl_Obj *format, Tk_PhotoImageBlock *blockPtr));
#endif
#ifndef SECOND_STRWRITE
#define SECOND_STRWRITE StringWriteBeta
static int StringWriteBeta _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_DString *data, Tcl_Obj *format,
	Tk_PhotoImageBlock *blockPtr));
#endif

static Tk_PhotoImageFormat format_beta = {
    %PHIMGTYPE_BETA%,					/* name */
    (Tk_ImageFileMatchProc *)   SECOND_CHNMATCH,	/* fileMatchProc */
    (Tk_ImageStringMatchProc *) SECOND_OBJMATCH,	/* stringMatchProc */
    (Tk_ImageFileReadProc *)    SECOND_CHNREAD,		/* fileReadProc */
    (Tk_ImageStringReadProc *)  SECOND_OBJREAD,		/* stringReadProc */
    (Tk_ImageFileWriteProc *)   SECOND_CHNWRITE,	/* fileWriteProc */
    (Tk_ImageStringWriteProc *) SECOND_STRWRITE		/* stringWriteProc */
};

#endif /* SECOND_FORMAT */


/*
 *----------------------------------------------------------------------------
 *
 * Tkimgpng_Init --
 *
 *  Initialisation routine for loadable module
 *
 * Results:
 *  None.
 *
 * Side effects:
 *  Creates commands in the interpreter, loads package.
 *
 *----------------------------------------------------------------------------
 */

int
#ifdef _DEBUG
Tkimgpng_d_Init (interp)
#else
Tkimgpng_Init (interp)
#endif
      Tcl_Interp *interp; /* Interpreter to initialise. */
{
#ifdef USE_TCL_STUBS
    if (Tcl_InitStubs(interp, "8.1", 0) == NULL) {
        return TCL_ERROR;
    }
#endif
#ifdef USE_TK_STUBS
    if (Tk_InitStubs(interp, "8.1", 0) == NULL) {
        return TCL_ERROR;
    }
#endif
#ifdef USE_TKIMG_STUBS
    if (Tkimg_InitStubs(interp, "1.3", 0) == NULL) {
        return TCL_ERROR;
    }
#endif

    MORE_INITIALIZATION;

    /*
     * Register the new photo image type.
     */

    Tk_CreatePhotoImageFormat (&format);
#ifdef SECOND_FORMAT
    Tk_CreatePhotoImageFormat (&format_beta);
#endif /* SECOND_FORMAT */

    /*
     * At last provide the package ...
     */

    if (Tcl_PkgProvide(interp, PACKAGE_NAME, VERSION) != TCL_OK) {
        return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------------
 *
 * Tkimgpng_SafeInit --
 *
 *  Initialisation routine for loadable module in a safe interpreter.
 *
 * Results:
 *  None.
 *
 * Side effects:
 *  Creates commands in the interpreter,
 *  loads xml package.
 *
 *----------------------------------------------------------------------------
 */

int
Tkimgpng_SafeInit (interp)
      Tcl_Interp *interp; /* Interpreter to initialise. */
{
#ifdef _DEBUG
    return Tkimgpng_d_Init (interp);
#else
    return Tkimgpng_Init (interp);
#endif
}

@


1.1.2.2
log
@Use TKIMG_PNG_PACKAGE_NAME instead of PACKAGE_NAME
@
text
@d8 1
a8 1
 * $Id: init.c,v 1.1.2.1 2005/09/08 20:50:35 bob1961 Exp $
a159 1
#if 0
a169 2
#endif

d191 1
a191 1
    if (Tcl_PkgProvide(interp, TKIMG_PNG_PACKAGE_NAME, TKIMG_VERSION) != TCL_OK) {
a193 1

@


1.1.2.3
log
@Not exporting Tkimgpng_Init
@
text
@d8 1
a8 1
 * $Id: init.c,v 1.1.2.2 2005/09/21 13:00:21 bob1961 Exp $
d19 26
a218 3
#ifdef _DEBUG
Tkimgpng_d_SafeInit (interp)
#else
a219 1
#endif
@


