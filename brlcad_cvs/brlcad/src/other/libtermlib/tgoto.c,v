head	1.7;
access;
symbols
	rel-7-10-4:1.6
	STABLE:1.6.0.2
	rel-7-10-2:1.6
	rel-7-10-0:1.6
	rel-7-8-4:1.1
	rel-7-8-2:1.1
	rel-7-8-0:1.1
	trimnurbs-branch:1.1.0.8
	help:1.1
	temp_tag:1.1
	bobWinPort-20051223-freeze:1.1
	postmerge-20051223-bobWinPort:1.1
	premerge-20051223-bobWinPort:1.1
	rel-7-6-6:1.1
	rel-7-6-4:1.1
	rel-7-6-2:1.1
	rel-7-6-branch:1.1.0.6
	rel-7-6-0:1.1
	rel-7-4-2:1.1
	rel-7-4-branch:1.1.0.4
	bobWinPort:1.1.0.2
	rel-7-4-0:1.1
	rel-7-2-6:1.1
	rel-7-2-4:1.1;
locks; strict;
comment	@ * @;


1.7
date	2007.09.14.15.21.38;	author erikgreenwald;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.14.23.54.17;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.14.20.31.59;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.14.07.54.57;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.15.06.30.51;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.15.06.26.12;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.22.07.03.33;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.7
log
@removed trailing whitespace
@
text
@/*
 * This code contains changes by
 *      Gunnar Ritter, Freiburg i. Br., Germany, 2002. All rights reserved.
 *
 * The conditions and no-warranty notice below apply to these changes.
 *
 *
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef	lint
#ifdef	DOSCCS
static char *sccsid = "@@(#)tgoto.c	1.3 (gritter) 11/23/04";
#endif
#endif

/* from tgoto.c	5.1 (Berkeley) 6/5/85 */

#include "termcap.h"

#define	CTRL(c)	(c & 037)

#define MAXRETURNSIZE 64

#ifdef	__STDC__
#include <string.h>
#endif

char	*UP;
char	*BC;

/*
 * Routine to perform cursor addressing.
 * CM is a string containing printf type escapes to allow
 * cursor addressing.  We start out ready to print the destination
 * line, and switch each time we print row or column.
 * The following escapes are defined for substituting row/column:
 *
 *	%d	as in printf
 *	%2	like %2d
 *	%3	like %3d
 *	%.	gives %c hacking special case characters
 *	%+x	like %c but adding x first
 *
 *	The codes below affect the state but don't use up a value.
 *
 *	%>xy	if value > x add y
 *	%r	reverses row/column
 *	%i	increments row/column (for one origin indexing)
 *	%%	gives %
 *	%B	BCD (2 decimal digits encoded in one byte)
 *	%D	Delta Data (backwards bcd)
 *
 * all other characters are ``self-inserting''.
 */
char *
tgoto(char *CM, int destcol, int destline)
{
	static char result[MAXRETURNSIZE];
	static char added[10];
	char *cp = CM;
	register char *dp = result;
	register int c;
	int oncol = 0;
	register int which = destline;

	if (cp == 0) {
toohard:
		/*
		 * ``We don't do that under BOZO's big top''
		 */
		return ("OOPS");
	}
	added[0] = 0;
	while (c = *cp++) {
		if (c != '%') {
			*dp++ = c;
			continue;
		}
		switch (c = *cp++) {

#ifdef CM_N
		case 'n':
			destcol ^= 0140;
			destline ^= 0140;
			goto setwhich;
#endif

		case 'd':
			if (which < 10)
				goto one;
			if (which < 100)
				goto two;
			/* fall into... */

		case '3':
			*dp++ = (which / 100) | '0';
			which %= 100;
			/* fall into... */

		case '2':
two:
			*dp++ = which / 10 | '0';
one:
			*dp++ = which % 10 | '0';
swap:
			oncol = 1 - oncol;
setwhich:
			which = oncol ? destcol : destline;
			continue;

#ifdef CM_GT
		case '>':
			if (which > *cp++)
				which += *cp++;
			else
				cp++;
			continue;
#endif

		case '+':
			which += *cp++;
			/* fall into... */

		case '.':
/* casedot: */
			/*
			 * This code is worth scratching your head at for a
			 * while.  The idea is that various weird things can
			 * happen to nulls, EOT's, tabs, and newlines by the
			 * tty driver, arpanet, and so on, so we don't send
			 * them if we can help it.
			 *
			 * Tab is taken out to get Ann Arbors to work, otherwise
			 * when they go to column 9 we increment which is wrong
			 * because bcd isn't continuous.  We should take out
			 * the rest too, or run the thing through more than
			 * once until it doesn't make any of these, but that
			 * would make termlib (and hence pdp-11 ex) bigger,
			 * and also somewhat slower.  This requires all
			 * programs which use termlib to stty tabs so they
			 * don't get expanded.  They should do this anyway
			 * because some terminals use ^I for other things,
			 * like nondestructive space.
			 */
			if (which == 0 || which == CTRL('d') || /* which == '\t' || */ which == '\n') {
				if (oncol || UP) /* Assumption: backspace works */
					/*
					 * Loop needed because newline happens
					 * to be the successor of tab.
					 */
					do {
						strcat(added, oncol ? (BC ? BC : "\b") : UP);
						which++;
					} while (which == '\n');
			}
			*dp++ = which;
			goto swap;

		case 'r':
			oncol = 1;
			goto setwhich;

		case 'i':
			destcol++;
			destline++;
			which++;
			continue;

		case '%':
			*dp++ = c;
			continue;

#ifdef CM_B
		case 'B':
			which = (which/10 << 4) + which%10;
			continue;
#endif

#ifdef CM_D
		case 'D':
			which = which - 2 * (which%16);
			continue;
#endif

		default:
			goto toohard;
		}
	}
	strcpy(dp, added);
	return (result);
}
@


1.6
log
@revert the NetBSD libtermcap library.  there are too many dependency woes (getcap, db, fgetln, strlcpy) to make it work cleanly without bringing in all of db too.  it was only working well under the osx/bsd's because everything happened to be available.
@
text
@d127 1
a127 1
two:	
@


1.5
log
@we don't provide the __RCSID macro that netbsd provided, comment it out.
@
text
@a0 2
/*	$NetBSD: tgoto.c,v 1.25 2006/08/27 08:47:40 christos Exp $	*/

d2 6
d14 1
a14 1
 * 1. Redistributions of source code must retain the above copyright
d16 1
a16 1
 * 2. Redistributions in binary form must reproduce the above copyright
d19 1
a19 1
 * 3. Neither the name of the University nor the names of its contributors
d36 4
a39 6
#include <sys/cdefs.h>
#ifndef lint
#if 0
static char sccsid[] = "@@(#)tgoto.c	8.1 (Berkeley) 6/4/93";
#else
/* __RCSID("$NetBSD: tgoto.c,v 1.25 2006/08/27 08:47:40 christos Exp $"); */
a40 1
#endif /* not lint */
d42 5
a46 7
#include <assert.h>
#include <errno.h>
#include <termcap.h>
#include <termcap_private.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
d48 1
a48 1
#define	CTRL(c)	((c) & 037)
d50 3
a52 1
#define MAXRETURNSIZE 128
d82 1
a82 1
tgoto(const char *CM, int destcol, int destline)
d85 4
a88 20

	(void)t_goto(NULL, CM, destcol, destline, result, sizeof(result));
	return result;
}

/*
 * New interface.  Functionally the same as tgoto but uses the tinfo struct
 * to set UP and BC.  The arg buffer is filled with the result string, limit
 * defines the maximum number of chars allowed in buffer.  The function
 * returns 0 on success, -1 otherwise, the result string contains an error
 * string on failure.
 */
int
t_goto(struct tinfo *info, const char *CM, int destcol, int destline,
    char *buffer, size_t limit)
{
	char added[32];
	const char *cp = CM;
	char *dp = buffer;
	int c;
d90 1
a90 16
	int which = destline;
	char *buf_lim = buffer + limit;
	char dig_buf[64];
	char *ap = added;
	char *eap = &added[sizeof(added) / sizeof(added[0])];
	int k;

	/* CM is checked below */
	_DIAGASSERT(buffer != NULL);

	if (info != NULL) {
		if (!UP)
			UP = info->up;
		if (!BC)
			BC = info->bc;
	}
d93 5
a97 3
		(void)strlcpy(buffer, "no fmt", limit);
		errno = EINVAL;
		return -1;
d99 3
a101 3
	added[0] = '\0';
	while ((c = *cp++) != '\0') {
		if (c != '%' || ((c = *cp++) == '%')) {
a102 6
			if (dp >= buf_lim) {
				(void)strlcpy(buffer, "no space copying %",
				    limit);
				errno = E2BIG;
				return -1;
			}
d105 1
a105 1
		switch (c) {
d111 1
a111 3
			/* flip oncol here so it doesn't actually change */
			oncol = 1 - oncol;
			break;
d114 7
d122 4
d127 9
a135 30
		case 'd':
			/* Generate digits into temp buffer in reverse order */
			k = 0;
			do
				dig_buf[k++] = which % 10 | '0';
			while ((which /= 10) != 0);

			if (c != 'd') {
				c -= '0';
				if (k > c) {
					(void)snprintf(buffer, limit,
					    "digit buf overflow %d %d",
					    k, c);
					errno = EINVAL;
					return -1;
				}
				while (k < c)
					dig_buf[k++] = '0';
			}

			if (dp + k >= buf_lim) {
				(void)strlcpy(buffer, "digit buf copy", limit);
				errno = E2BIG;
				return -1;
			}
			/* then unwind into callers buffer */
			do
				*dp++ = dig_buf[--k];
			while (k);
			break;
d148 1
a148 1
			/* FALLTHROUGH */
d151 1
d171 2
a172 5
			if (which == 0 || which == CTRL('d') || 
			    /* which == '\t' || */ which == '\n') {
				if (oncol || UP) { /* Assumption: backspace works */
					char *add = oncol ? (BC ? BC : "\b") : UP;

d178 1
a178 11
						char *as = add;

						while ((*ap++ = *as++) != '\0')
							if (ap >= eap) {
								(void)strlcpy(
								    buffer,
								    "add ovfl",
								    limit);
								errno = E2BIG;
								return -1;
							}
a180 1
				}
d183 1
a183 6
			if (dp >= buf_lim) {
				(void)strlcpy(buffer, "dot copy", limit);
				errno = E2BIG;
				return -1;
			}
			break;
d186 2
a187 2
			oncol = 0;
			break;
d195 4
d201 1
a201 1
			which = (which / 10 << 4) + which % 10;
d207 1
a207 1
			which = which - 2 * (which % 16);
d212 1
a212 3
			(void)snprintf(buffer, limit, "bad format `%c'", c);
			errno = EINVAL;
			return -1;
a213 9

		/* flip to other number... */
		oncol = 1 - oncol;
		which = oncol ? destcol : destline;
	}
	if (dp + (ap - added) >= buf_lim) {
		(void)strlcpy(buffer, "big added", limit);
		errno = E2BIG;
		return -1;
d215 2
a216 6

	*ap = '\0';
	for (ap = added; (*dp++ = *ap++) != '\0';)
		continue;

	return 0;
@


1.4
log
@update from the old vi termcap sources to the more modern NetBSD implementation.  this version doesn't suffer the assumption that there needs to be an /etc/termcap among many other improvements.  it's under 3-clause BSD and seems to be version 0.6 dated December 17, 2006.
@
text
@d37 1
a37 1
__RCSID("$NetBSD: tgoto.c,v 1.25 2006/08/27 08:47:40 christos Exp $");
@


1.3
log
@the clauses are no longer numbered, so the author's original exemption of the advertising clause is no longer relevant.  reword correspondingly.
@
text
@d1 2
a3 6
 * This code contains changes by
 *      Gunnar Ritter, Freiburg i. Br., Germany, 2002. All rights reserved.
 *
 * The conditions and no-warranty notice below apply to these changes.
 *
 *
d10 1
a10 1
 *  * Redistributions of source code must retain the above copyright
d12 1
a12 1
 *  * Redistributions in binary form must reproduce the above copyright
d15 1
a15 1
 *  * Neither the name of the University nor the names of its contributors
d32 6
a37 4
#ifndef	lint
#ifdef	DOSCCS
static char *sccsid = "@@(#)tgoto.c	1.3 (gritter) 11/23/04";
#endif
d39 1
d41 7
a47 5
/* from tgoto.c	5.1 (Berkeley) 6/5/85 */

#include "libterm.h"

#define	CTRL(c)	(c & 037)
d49 1
a49 1
#define MAXRETURNSIZE 64
d51 1
a51 3
#ifdef	__STDC__
#include <string.h>
#endif
d81 1
a81 1
tgoto(char *CM, int destcol, int destline)
d84 20
a103 4
	static char added[10];
	char *cp = CM;
	register char *dp = result;
	register int c;
d105 16
a120 1
	register int which = destline;
d123 3
a125 5
toohard:
		/*
		 * ``We don't do that under BOZO's big top''
		 */
		return ("OOPS");
d127 3
a129 3
	added[0] = 0;
	while (c = *cp++) {
		if (c != '%') {
d131 6
d139 1
a139 1
		switch (c = *cp++) {
d145 3
a147 1
			goto setwhich;
d150 2
d153 18
a170 5
			if (which < 10)
				goto one;
			if (which < 100)
				goto two;
			/* fall into... */
d172 10
a181 15
		case '3':
			*dp++ = (which / 100) | '0';
			which %= 100;
			/* fall into... */

		case '2':
two:	
			*dp++ = which / 10 | '0';
one:
			*dp++ = which % 10 | '0';
swap:
			oncol = 1 - oncol;
setwhich:
			which = oncol ? destcol : destline;
			continue;
d194 1
a194 1
			/* fall into... */
a196 1
/* casedot: */
d216 5
a220 2
			if (which == 0 || which == CTRL('d') || /* which == '\t' || */ which == '\n') {
				if (oncol || UP) /* Assumption: backspace works */
d226 11
a236 1
						strcat(added, oncol ? (BC ? BC : "\b") : UP);
d239 1
d242 6
a247 1
			goto swap;
d250 2
a251 2
			oncol = 1;
			goto setwhich;
a258 4
		case '%':
			*dp++ = c;
			continue;

d261 1
a261 1
			which = (which/10 << 4) + which%10;
d267 1
a267 1
			which = which - 2 * (which%16);
d272 3
a274 1
			goto toohard;
d276 9
d286 6
a291 2
	strcpy(dp, added);
	return (result);
@


1.2
log
@Pedantic licensing update to retract the "BSD Advertising Clause", i.e. clause 3 of the original 4-clause BSD license.  As granted by William Hoskins, Director to the Office of Technology Licensing at the University of California, Berkeley, update the license on code copyrighted by Berkeley to retract the advertising clause.  See ftp://ftp.cs.berkeley.edu/pub/4bsd/README.Impt.License.Change for details.
@
text
@d5 1
a5 2
 * Conditions 1, 2, and 4 and the no-warranty notice below apply
 * to these changes.
@


1.1
log
@initial termlib library from an early original bsd implementation (that predated the name change to libtermcap).  preserve the name termlib instead of termcap to reduce confusion with the gnu termcap library implementation.  these particular sources were originally taken from the traditional vi project, though they have already been patched.
@
text
@d15 1
a15 1
 * 1. Redistributions of source code must retain the above copyright
d17 1
a17 1
 * 2. Redistributions in binary form must reproduce the above copyright
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@

