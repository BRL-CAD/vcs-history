head	1.6;
access;
symbols
	rel-7-10-4:1.6
	STABLE:1.6.0.2
	rel-7-10-2:1.6
	rel-7-10-0:1.6
	rel-7-8-4:1.1
	rel-7-8-2:1.1
	rel-7-8-0:1.1
	trimnurbs-branch:1.1.0.8
	help:1.1
	temp_tag:1.1
	bobWinPort-20051223-freeze:1.1
	postmerge-20051223-bobWinPort:1.1
	premerge-20051223-bobWinPort:1.1
	rel-7-6-6:1.1
	rel-7-6-4:1.1
	rel-7-6-2:1.1
	rel-7-6-branch:1.1.0.6
	rel-7-6-0:1.1
	rel-7-4-2:1.1
	rel-7-4-branch:1.1.0.4
	bobWinPort:1.1.0.2
	rel-7-4-0:1.1
	rel-7-2-6:1.1
	rel-7-2-4:1.1;
locks; strict;
comment	@ * @;


1.6
date	2007.03.14.23.54.17;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.14.20.31.59;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.14.07.54.57;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.15.06.30.51;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.15.06.26.12;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.22.07.03.33;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.6
log
@revert the NetBSD libtermcap library.  there are too many dependency woes (getcap, db, fgetln, strlcpy) to make it work cleanly without bringing in all of db too.  it was only working well under the osx/bsd's because everything happened to be available.
@
text
@/*
 * This code contains changes by
 *      Gunnar Ritter, Freiburg i. Br., Germany, 2002. All rights reserved.
 *
 * The conditions and no-warranty notice below apply to these changes.
 *
 *
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef	lint
#ifdef	DOSCCS
static char *sccsid = "@@(#)tputs.c	1.4 (gritter) 11/23/04";
#endif
#endif

/* from tputs.c	5.1 (Berkeley) 6/5/85 */

#include <ctype.h>

#include "termcap.h"

/*
 * The following array gives the number of tens of milliseconds per
 * character for each speed as returned by gtty.  Thus since 300
 * baud returns a 7, there are 33.3 milliseconds per char at 300 baud.
 */
static
short	tmspc10[] = {
	0, 2000, 1333, 909, 743, 666, 500, 333, 166, 83, 55, 41, 20, 10, 5
};

short	ospeed;
char	PC;

/*
 * Put the character string cp out, with padding.
 * The number of affected lines is affcnt, and the routine
 * used to output one character is outc.
 */
int
tputs(const char *cp, int affcnt, int (*outc)(int))
{
	register int i = 0;
	register int mspc10;

	if (cp == 0)
		return 1;

	/*
	 * Convert the number representing the delay.
	 */
	if (isdigit(*cp & 0377)) {
		do
			i = i * 10 + *cp++ - '0';
		while (isdigit(*cp & 0377));
	}
	i *= 10;
	if (*cp == '.') {
		cp++;
		if (isdigit(*cp & 0377))
			i += *cp - '0';
		/*
		 * Only one digit to the right of the decimal point.
		 */
		while (isdigit(*cp & 0377))
			cp++;
	}

	/*
	 * If the delay is followed by a `*', then
	 * multiply by the affected lines count.
	 */
	if (*cp == '*')
		cp++, i *= affcnt;

	/*
	 * The guts of the string.
	 */
	while (*cp)
		(*outc)(*cp++);

	/*
	 * If no delay needed, or output speed is
	 * not comprehensible, then don't try to delay.
	 */
	if (i == 0)
		return 1;
	if (ospeed <= 0 || ospeed >= (sizeof tmspc10 / sizeof tmspc10[0]))
		return 1;

	/*
	 * Round up by a half a character frame,
	 * and then do the delay.
	 * Too bad there are no user program accessible programmed delays.
	 * Transmitting pad characters slows many
	 * terminals down and also loads the system.
	 */
	mspc10 = tmspc10[ospeed];
	i += mspc10 / 2;
	for (i /= mspc10; i > 0; i--)
		(*outc)(PC);
	return 1;
}
@


1.5
log
@we don't provide the __RCSID macro that netbsd provided, comment it out.
@
text
@a0 2
/*	$NetBSD: tputs.c,v 1.23 2005/05/15 21:11:13 christos Exp $	*/

d2 6
d14 1
a14 1
 * 1. Redistributions of source code must retain the above copyright
d16 1
a16 1
 * 2. Redistributions in binary form must reproduce the above copyright
d19 1
a19 1
 * 3. Neither the name of the University nor the names of its contributors
d36 3
a38 6
#include <sys/cdefs.h>
#ifndef lint
#if 0
static char sccsid[] = "@@(#)tputs.c	8.1 (Berkeley) 6/4/93";
#else
/* __RCSID("$NetBSD: tputs.c,v 1.23 2005/05/15 21:11:13 christos Exp $"); */
d40 3
a42 1
#endif /* not lint */
a43 1
#include <assert.h>
a44 5
#include <termcap.h>
#include <stdio.h>
#include <stdlib.h>
#include "termcap_private.h"
#undef ospeed
d46 1
a46 2
/* internal functions */
int _tputs_convert(const char **, int);
d53 2
a54 1
const short __tmspc10[TMSPC10SIZE] = {
d61 5
d67 1
a67 1
_tputs_convert(const char **ptr, int affcnt)
d69 2
a70 1
	int i = 0;
d72 2
a73 2
	_DIAGASSERT(ptr != NULL);
	_DIAGASSERT(*ptr != NULL);
d78 1
a78 1
	if (isdigit(*(const unsigned char *)(*ptr))) {
d80 2
a81 2
			i = i * 10 + *(*ptr)++ - '0';
		while (isdigit(*(const unsigned char *)(*ptr)));
d84 4
a87 4
	if (*(*ptr) == '.') {
		(*ptr)++;
		if (isdigit(*(const unsigned char *)(*ptr)))
			i += *(*ptr) - '0';
d91 2
a92 2
		while (isdigit(*(const unsigned char *)(*ptr)))
			(*ptr)++;
d99 2
a100 24
	if (*(*ptr) == '*')
		(*ptr)++, i *= affcnt;

	return i;
}

/*
 * Put the character string cp out, with padding.
 * The number of affected lines is affcnt, and the routine
 * used to output one character is outc.
 */
void
tputs(const char *cp, int affcnt, int (*outc)(int))
{
	int i = 0;
	int mspc10;

	_DIAGASSERT(outc != 0);

	if (cp == 0)
		return;

	/* scan and convert delay digits (if any) */
	i = _tputs_convert(&cp, affcnt);
d106 1
a106 1
		(void)(*outc)(*cp++);
d113 3
a115 3
		return;
	if (ospeed <= 0 || ospeed >= TMSPC10SIZE)
		return;
d124 1
a124 1
	mspc10 = __tmspc10[ospeed];
d127 2
a128 68
		(void)(*outc)(PC);
}


int
t_puts(struct tinfo *info, const char *cp, int affcnt,
    void (*outc)(char, void *), void *args)
{
	int i = 0;
	size_t limit;
	int mspc10;
	char pad[2], *pptr;
	char *pc;

	/* XXX: info may be NULL ? */
	/* cp is handled below */
	_DIAGASSERT(outc != NULL);
	_DIAGASSERT(args != NULL);

	if (info != NULL) {
		/*
		 * if we have info then get the pad char from the
		 * termcap entry if it exists, otherwise use the
		 * default NUL char.
		 */
		pptr = pad;
		limit = sizeof(pad);
		pc = t_getstr(info, "pc", &pptr, &limit);
		if (pc == NULL)
			pad[0] = '\0';
		else
			free(pc);
	}

	if (cp == 0)
		return -1;

	/* scan and convert delay digits (if any) */
	i = _tputs_convert(&cp, affcnt);

	/*
	 * The guts of the string.
	 */
	while (*cp)
		(*outc)(*cp++, args);

	/*
	 * If no delay needed, or output speed is
	 * not comprehensible, then don't try to delay.
	 */
	if (i == 0)
		return 0;
	if (ospeed <= 0 || ospeed >= TMSPC10SIZE)
		return 0;

	/*
	 * Round up by a half a character frame,
	 * and then do the delay.
	 * Too bad there are no user program accessible programmed delays.
	 * Transmitting pad characters slows many
	 * terminals down and also loads the system.
	 */
	mspc10 = __tmspc10[ospeed];
	i += mspc10 / 2;
	for (i /= mspc10; i > 0; i--)
		(*outc)(pad[0], args);

	return 0;
@


1.4
log
@update from the old vi termcap sources to the more modern NetBSD implementation.  this version doesn't suffer the assumption that there needs to be an /etc/termcap among many other improvements.  it's under 3-clause BSD and seems to be version 0.6 dated December 17, 2006.
@
text
@d37 1
a37 1
__RCSID("$NetBSD: tputs.c,v 1.23 2005/05/15 21:11:13 christos Exp $");
@


1.3
log
@the clauses are no longer numbered, so the author's original exemption of the advertising clause is no longer relevant.  reword correspondingly.
@
text
@d1 2
a3 6
 * This code contains changes by
 *      Gunnar Ritter, Freiburg i. Br., Germany, 2002. All rights reserved.
 *
 * The conditions and no-warranty notice below apply to these changes.
 *
 *
d10 1
a10 1
 *  * Redistributions of source code must retain the above copyright
d12 1
a12 1
 *  * Redistributions in binary form must reproduce the above copyright
d15 1
a15 1
 *  * Neither the name of the University nor the names of its contributors
d32 6
a37 3
#ifndef	lint
#ifdef	DOSCCS
static char *sccsid = "@@(#)tputs.c	1.4 (gritter) 11/23/04";
d39 1
a39 3
#endif

/* from tputs.c	5.1 (Berkeley) 6/5/85 */
d41 1
d43 5
d49 2
a50 1
#include "libterm.h"
d57 1
a57 2
static
short	tmspc10[] = {
a63 5
/*
 * Put the character string cp out, with padding.
 * The number of affected lines is affcnt, and the routine
 * used to output one character is outc.
 */
d65 1
a65 1
tputs(const char *cp, int affcnt, int (*outc)(int))
d67 1
a67 2
	register int i = 0;
	register int mspc10;
d69 2
a70 2
	if (cp == 0)
		return 1;
d75 1
a75 1
	if (isdigit(*cp & 0377)) {
d77 2
a78 2
			i = i * 10 + *cp++ - '0';
		while (isdigit(*cp & 0377));
d81 4
a84 4
	if (*cp == '.') {
		cp++;
		if (isdigit(*cp & 0377))
			i += *cp - '0';
d88 2
a89 2
		while (isdigit(*cp & 0377))
			cp++;
d96 24
a119 2
	if (*cp == '*')
		cp++, i *= affcnt;
d125 1
a125 1
		(*outc)(*cp++);
d132 3
a134 3
		return 1;
	if (ospeed <= 0 || ospeed >= (sizeof tmspc10 / sizeof tmspc10[0]))
		return 1;
d143 1
a143 1
	mspc10 = tmspc10[ospeed];
d146 68
a213 2
		(*outc)(PC);
	return 1;
@


1.2
log
@Pedantic licensing update to retract the "BSD Advertising Clause", i.e. clause 3 of the original 4-clause BSD license.  As granted by William Hoskins, Director to the Office of Technology Licensing at the University of California, Berkeley, update the license on code copyrighted by Berkeley to retract the advertising clause.  See ftp://ftp.cs.berkeley.edu/pub/4bsd/README.Impt.License.Change for details.
@
text
@d5 1
a5 2
 * Conditions 1, 2, and 4 and the no-warranty notice below apply
 * to these changes.
@


1.1
log
@initial termlib library from an early original bsd implementation (that predated the name change to libtermcap).  preserve the name termlib instead of termcap to reduce confusion with the gnu termcap library implementation.  these particular sources were originally taken from the traditional vi project, though they have already been patched.
@
text
@d15 1
a15 1
 * 1. Redistributions of source code must retain the above copyright
d17 1
a17 1
 * 2. Redistributions in binary form must reproduce the above copyright
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@

