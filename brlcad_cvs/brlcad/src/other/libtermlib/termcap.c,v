head	1.10;
access;
symbols
	rel-7-10-4:1.10
	STABLE:1.10.0.2
	rel-7-10-2:1.10
	rel-7-10-0:1.10
	rel-7-8-4:1.1
	rel-7-8-2:1.1
	rel-7-8-0:1.1
	trimnurbs-branch:1.1.0.8
	help:1.1
	temp_tag:1.1
	bobWinPort-20051223-freeze:1.1
	postmerge-20051223-bobWinPort:1.1
	premerge-20051223-bobWinPort:1.1
	rel-7-6-6:1.1
	rel-7-6-4:1.1
	rel-7-6-2:1.1
	rel-7-6-branch:1.1.0.6
	rel-7-6-0:1.1
	rel-7-4-2:1.1
	rel-7-4-branch:1.1.0.4
	bobWinPort:1.1.0.2
	rel-7-4-0:1.1
	rel-7-2-6:1.1
	rel-7-2-4:1.1;
locks; strict;
comment	@ * @;


1.10
date	2007.03.15.00.21.22;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.14.23.54.17;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.14.20.31.59;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.14.08.35.58;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.14.07.54.57;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.02.21.47.19;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.27.00.09.48;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.15.06.30.51;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.15.06.26.12;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.22.07.03.32;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.10
log
@make it look for our installed termcap file before it uses the one in etc, since enabling termlib compilation implies functioning independent.  if they want their termcap file, they can still set TERMCAP or link against their system terminfo/termcap/curses
@
text
@/*
 * This code contains changes by
 *      Gunnar Ritter, Freiburg i. Br., Germany, 2002. All rights reserved.
 *
 * The conditions and no-warranty notice below apply to these changes.
 *
 *
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef	lint
#ifdef	DOSCCS
static char *sccsid = "@@(#)termcap.c	1.7 (gritter) 11/23/04";
#endif
#endif

#include "common.h"

/* from termcap.c	5.1 (Berkeley) 6/5/85 */

#if 0	/* GR */
#define	TCBUFSIZE		1024
#else
#include "termcap.h"
#endif

#define	E_TERMCAP	"/etc/termcap"
#define B_TERMCAP BRLCAD_DATA "/etc/termcap"

#define MAXHOP		32	/* max number of tc= indirections */

#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

/*
 * termcap - routines for dealing with the terminal capability data base
 *
 * BUG:		Should use a "last" pointer in tbuf, so that searching
 *		for capabilities alphabetically would not be a n**2/2
 *		process when large numbers of capabilities are given.
 * Note:	If we add a last pointer now we will screw up the
 *		tc capability. We really should compile termcap.
 *
 * Essentially all the work here is scanning and decoding escapes
 * in string capabilities.  We don't use stdio because the editor
 * doesn't, and because living w/o it is not hard.
 */

static	char *tbuf;
static	int hopcount;	/* detect infinite loops in termcap, init 0 */

static int tnamatch(const char *);
static int tnchktc(void);
static char *tskip(register const char *);
static char *tdecode(register char *, char **);

/*
 * Tnamatch deals with name matching.  The first field of the termcap
 * entry is a sequence of names separated by |'s, so we compare
 * against each such name.  The normal : terminator after the last
 * name (before the first field) stops us.
 */
static int
tnamatch(const char *np)
{
	register const char *Np;
	register char *Bp;

	Bp = tbuf;
	if (*Bp == '#')
		return(0);
	for (;;) {
		for (Np = np; *Np && *Bp == *Np; Bp++, Np++)
			continue;
		if (*Np == 0 && (*Bp == '|' || *Bp == ':' || *Bp == 0))
			return (1);
		while (*Bp && *Bp != ':' && *Bp != '|')
			Bp++;
		if (*Bp == 0 || *Bp == ':')
			return (0);
		Bp++;
	}
}

/*
 * tnchktc: check the last entry, see if it's tc=xxx. If so,
 * recursively find xxx and append that entry (minus the names)
 * to take the place of the tc=xxx entry. This allows termcap
 * entries to say "like an HP2621 but doesn't turn on the labels".
 * Note that this works because of the left to right scan.
 */
static int
tnchktc(void)
{
	register char *p, *q;
	char tcname[16];	/* name of similar terminal */
	char tcbuf[TCBUFSIZE];
	char rmbuf[TCBUFSIZE];
	char *holdtbuf = tbuf, *holdtc;
	int l;

	p = tbuf;
	while (*p) {
		holdtc = p = tskip(p);
		if (!p)
		  return (0);
		if (!*p)
			break;
		if (*p++ != 't' || *p == 0 || *p++ != 'c')
			continue;
		if (*p++ != '=') {
		bad:	write(2, "Bad termcap entry\n", 18);
			return (0);
		}
		for (q = tcname; *p && *p != ':'; p++) {
			if (q >= &tcname[sizeof tcname - 1])
				goto bad;
			*q++ = *p;
		}
		*q = '\0';
		if (++hopcount > MAXHOP) {
			write(2, "Infinite tc= loop\n", 18);
			return (0);
		}
		if (tgetent(tcbuf, tcname) != 1) {
			hopcount = 0;		/* unwind recursion */
			return(0);
		}
		hopcount--;
		tbuf = holdtbuf;
		strcpy(rmbuf, &p[1]);
		for (q=tcbuf; *q != ':'; q++)
			;
		l = holdtc - holdtbuf + strlen(rmbuf) + strlen(q);
		if (l > TCBUFSIZE) {
			write(2, "Termcap entry too long\n", 23);
			break;
		}
		q++;
		for (p = holdtc; *q; q++)
			*p++ = *q;
		strcpy(p, rmbuf);
		p = holdtc;
	}
	return(1);
}

/*
 * Get an entry for terminal name in buffer bp,
 * from the termcap file.  Parse is very rudimentary;
 * we just notice escaped newlines.
 */
int
tgetent(char *bp, const char *name)
{
	register char *cp;
	register int c;
	register int i = 0, cnt = 0;
	char ibuf[TCBUFSIZE];
	int tf;

	tbuf = bp;
	tf = -1;

	cp = getenv("TERMCAP");
	/*
	 * TERMCAP can have one of two things in it. It can be the
	 * name of a file to use instead of /etc/termcap. In this
	 * case it better start with a "/". Or it can be an entry to
	 * use so we don't have to read the file. In this case it
	 * has to already have the newlines crunched out.
	 */
	if (cp && *cp) {
		if (*cp == '/') {
			tf = open(cp, 0);
		} else {
			tbuf = cp;
			c = tnamatch(name);
			tbuf = bp;
			if (c) {
				strcpy(bp,cp);
				return(tnchktc());
			}
		}
	}

	if (tf < 0)
	  tf = open(B_TERMCAP, 0);
	if (tf < 0)
	  tf = open(E_TERMCAP, 0);

	if (tf < 0)
		return (-1);
	for (;;) {
		cp = bp;
		for (;;) {
			if (i == cnt) {
				cnt = read(tf, ibuf, TCBUFSIZE);
				if (cnt <= 0) {
					close(tf);
					return (0);
				}
				i = 0;
			}
			c = ibuf[i++];
			if (c == '\n') {
				if (cp > bp && cp[-1] == '\\'){
					cp--;
					continue;
				}
				break;
			}
			if (cp >= bp+TCBUFSIZE) {
				write(2,"Termcap entry too long\n", 23);
				break;
			} else
				*cp++ = c;
		}
		*cp = 0;

		/*
		 * The real work for the match.
		 */
		if (tnamatch(name)) {
			close(tf);
			return(tnchktc());
		}
	}
}

/*
 * Skip to the next field.  Notice that this is very dumb, not
 * knowing about \: escapes or any such.  If necessary, :'s can be put
 * into the termcap file in octal.
 */
static char *
tskip(register const char *bp)
{
  if (!bp) {
    return NULL;
  }

  while (*bp && *bp != ':')
    bp++;
  if (*bp == ':')
    bp++;
  return (char *)bp;
}

/*
 * Return the (numeric) option id.
 * Numeric options look like
 *	li#80
 * i.e. the option string is separated from the numeric value by
 * a # character.  If the option is not found we return -1.
 * Note that we handle octal numbers beginning with 0.
 */
int
tgetnum(char *id)
{
	register int i, base;
	register char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (!bp)
		  return -1;
		if (*bp == 0)
			return (-1);
		if (*bp++ != id[0] || *bp == 0 || *bp++ != id[1])
			continue;
		if (*bp == '@@')
			return(-1);
		if (*bp != '#')
			continue;
		bp++;
		base = 10;
		if (*bp == '0')
			base = 8;
		i = 0;
		while (isdigit((*bp & 0377)))
			i *= base, i += *bp++ - '0';
		return (i);
	}
}

/*
 * Handle a flag option.
 * Flag options are given "naked", i.e. followed by a : or the end
 * of the buffer.  Return 1 if we find the option, or 0 if it is
 * not given.
 */
int
tgetflag(char *id)
{
	register char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (!bp)
		  return 0;
		if (!*bp)
			return (0);
		if (*bp++ == id[0] && *bp != 0 && *bp++ == id[1]) {
			if (!*bp || *bp == ':')
				return (1);
			else if (*bp == '@@')
				return(0);
		}
	}
}

/*
 * Get a string valued option.
 * These are given as
 *	cl=^Z
 * Much decoding is done on the strings, and the strings are
 * placed in area, which is a ref parameter which is updated.
 * No checking on area overflow.
 */
char *
tgetstr(char *id, char **area)
{
	register char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (!bp)
		  return 0;
		if (!*bp)
			return (0);
		if (*bp++ != id[0] || *bp == 0 || *bp++ != id[1])
			continue;
		if (*bp == '@@')
			return(0);
		if (*bp != '=')
			continue;
		bp++;
		return (tdecode(bp, area));
	}
}

/*
 * Tdecode does the grung work to decode the
 * string capability escapes.
 */
static char *
tdecode(register char *str, char **area)
{
	register char *cp;
	register int c;
	register char *dp;
	int i;

	cp = *area;
	while ((c = *str++) && c != ':') {
		switch (c) {

		case '^':
			c = *str++ & 037;
			break;

		case '\\':
			dp = "E\033^^\\\\::n\nr\rt\tb\bf\f";
			c = *str++;
nextc:
			if (*dp++ == c) {
				c = *dp++;
				break;
			}
			dp++;
			if (*dp)
				goto nextc;
			if (isdigit(c)) {
				c -= '0', i = 2;
				do
					c <<= 3, c |= *str++ - '0';
				while (--i && isdigit(*str & 0377));
			}
			break;
		}
		*cp++ = c;
	}
	*cp++ = 0;
	str = *area;
	*area = cp;
	return (str);
}

/*
*/
static const char sccssl[] = "@@(#)libterm.sl	1.7 (gritter) 11/23/04";
@


1.9
log
@revert the NetBSD libtermcap library.  there are too many dependency woes (getcap, db, fgetln, strlcpy) to make it work cleanly without bringing in all of db too.  it was only working well under the osx/bsd's because everything happened to be available.
@
text
@d42 2
d51 1
d53 2
d216 3
d220 1
a220 1
		tf = open(E_TERMCAP, 0);
@


1.8
log
@we don't provide the __RCSID macro that netbsd provided, comment it out.
@
text
@a0 2
/*	$NetBSD: termcap.c,v 1.54 2006/12/19 02:02:03 uwe Exp $	*/

d2 6
d14 1
a14 1
 * 1. Redistributions of source code must retain the above copyright
d16 1
a16 1
 * 2. Redistributions in binary form must reproduce the above copyright
d19 1
a19 1
 * 3. Neither the name of the University nor the names of its contributors
d36 7
a42 1
#include "common.h"
d44 2
a45 4
#include <sys/cdefs.h>
#ifndef lint
#if 0
static char sccsid[] = "@@(#)termcap.c	8.1 (Berkeley) 6/4/93";
d47 1
a47 1
/* __RCSID("$NetBSD: termcap.c,v 1.54 2006/12/19 02:02:03 uwe Exp $"); */
d49 2
a50 1
#endif /* not lint */
d52 2
d55 3
a57 4
#include <sys/param.h>
#include <assert.h>
#include <ctype.h>
#include <stdio.h>
a58 9
#include <string.h>
#include <termcap.h>
#include <errno.h>
#include "pathnames.h"
#include "termcap_private.h"

#define	PBUFSIZ		MAXPATHLEN	/* max length of filename path */
#define	PVECSIZ		32		/* max number of names in path */
#define CAPSIZ		256		/* max capability size */
d74 2
a75 2
static char *tbuf = NULL;		/* termcap buffer */
static struct tinfo *fbuf = NULL;	/* untruncated termcap buffer */
d77 94
a170 36
/*
 * Set the termcap entry to the arbitrary string passed in, this can
 * be used to provide a "dummy" termcap entry if a real one does not
 * exist.  This function will malloc the buffer and space for the
 * string.  If an error occurs return -1 otherwise return 0.
 */
int
t_setinfo(struct tinfo **bp, const char *entry)
{
	char capability[CAPSIZ], *cap_ptr;
	size_t limit;

	_DIAGASSERT(bp != NULL);
	_DIAGASSERT(entry != NULL);

	if ((*bp = malloc(sizeof(struct tinfo))) == NULL)
		return -1;

	if (((*bp)->info = (char *) malloc(strlen(entry) + 1)) == NULL)
		return -1;

	strcpy((*bp)->info, entry);

	cap_ptr = capability;
	limit = sizeof(capability) - 1;
	(*bp)->up = t_getstr(*bp, "up", &cap_ptr, &limit);
	if ((*bp)->up)
		(*bp)->up = strdup((*bp)->up);
	cap_ptr = capability;
	limit = sizeof(capability) - 1;
	(*bp)->bc = t_getstr(*bp, "bc", &cap_ptr, &limit);
	if ((*bp)->bc)
		(*bp)->bc = strdup((*bp)->bc);
	(*bp)->tbuf = NULL;

	return 0;
d174 3
a176 3
 * Get an extended entry for the terminal name.  This differs from
 * tgetent only in a) the buffer is malloc'ed for the caller and
 * b) the termcap entry is not truncated to 1023 characters.
a177 1

d179 1
a179 1
t_getent(struct tinfo **bp, const char *name)
d181 5
a185 11
	char  *p;
	char  *cp;
	char **fname;
	char  *home;
	int    i, did_getset;
	size_t limit;
	char   pathbuf[PBUFSIZ];	/* holds raw path of filenames */
	char  *pathvec[PVECSIZ];	/* to point to names in pathbuf */
	char  *termpath;
	char  capability[CAPSIZ], *cap_ptr;
	int error;
d187 2
a189 8
	_DIAGASSERT(bp != NULL);
	_DIAGASSERT(name != NULL);

	if ((*bp = malloc(sizeof(struct tinfo))) == NULL)
		return 0;

	fname = pathvec;
	p = pathbuf;
d193 4
a196 8
	 * name of a file to use instead of
	 * /usr/share/misc/termcap. In this case it better start with
	 * a "/". Or it can be an entry to use so we don't have to
	 * read the file. In this case cgetset() withh crunch out the
	 * newlines.  If TERMCAP does not hold a file name then a path
	 * of names is searched instead.  The path is found in the
	 * TERMPATH variable, or becomes _PATH_DEF ("$HOME/.termcap
	 * /usr/share/misc/termcap") if no TERMPATH exists.
d198 10
a207 21
	if (!cp || *cp != '/') {	/* no TERMCAP or it holds an entry */
		if ((termpath = getenv("TERMPATH")) != NULL)
			(void)strlcpy(pathbuf, termpath, sizeof(pathbuf));
		else {
			if ((home = getenv("HOME")) != NULL) {
				/* set up default */
				p += strlen(home);	/* path, looking in */
				(void)strlcpy(pathbuf, home,
				    sizeof(pathbuf)); /* $HOME first */
				if ((size_t)(p - pathbuf) < sizeof(pathbuf) - 1)
				    *p++ = '/';
			}	/* if no $HOME look in current directory */
			if ((size_t)(p - pathbuf) < sizeof(pathbuf) - 1) {
			    /* Added for BRL-CAD, search BRLCAD_DATA/etc dir too */
#ifdef BRLCAD_DATA
			    (void)strlcpy(p, _PATH_DEF " " BRLCAD_DATA "/etc",
				sizeof(pathbuf) - (p - pathbuf));
#else
			    (void)strlcpy(p, _PATH_DEF,
				sizeof(pathbuf) - (p - pathbuf));
#endif
d211 2
a212 4
	else {
		/* user-defined name in TERMCAP; still can be tokenized */
		(void)strlcpy(pathbuf, cp, sizeof(pathbuf));
	}
d214 19
a232 8
	*fname++ = pathbuf;	/* tokenize path into vector of names */
	while (*++p)
		if (*p == ' ' || *p == ':') {
			*p = '\0';
			while (*++p)
				if (*p != ' ' && *p != ':')
					break;
			if (*p == '\0')
d234 3
a236 3
			*fname++ = p;
			if (fname >= pathvec + PVECSIZ) {
				fname--;
d238 2
a239 1
			}
d241 1
a241 1
	*fname = NULL;			/* mark end of vector */
d243 6
a248 17
	/*
	 * try ignoring TERMCAP if it has a ZZ in it, we do this
	 * because a TERMCAP with ZZ in it indicates the entry has been
	 * exported by another program using the "old" interface, the
	 * termcap entry has been truncated and ZZ points to an address
	 * in the exporting programs memory space which is of no use
	 * here - anyone who is exporting the termcap entry and then
	 * reading it back again in the same program deserves to be
	 * taken out, beaten up, dragged about, shot and then hurt some
	 * more.
	 */
	did_getset = 0;
	if (cp && *cp && *cp != '/' && strstr(cp, ":ZZ") == NULL) {
		did_getset = 1;
		if (cgetset(cp) < 0) {
			error = -2;
			goto out;
a250 56

	/*
	 * XXX potential security hole here in a set-id program if the
	 * user had setup name to be built from a path they can not
	 * normally read.
	 */
 	(*bp)->info = NULL;
 	i = cgetent(&((*bp)->info), pathvec, name);

	/*
	 * if we get an error and we skipped doing the cgetset before
	 * we try with TERMCAP in place - we may be using a truncated
	 * termcap entry but what else can one do?
	 */
	if ((i < 0) && (did_getset == 0)) {
		if (cp && *cp && *cp != '/')
			if (cgetset(cp) < 0) {
				error = -2;
				goto out;
			}
		i = cgetent(&((*bp)->info), pathvec, name);
	}

	/* no tc reference loop return code in libterm XXX */
	if (i == -3) {
		error = -1;
		goto out;
	}

	/*
	 * fill in t_goto capabilities - this prevents memory leaks
	 * and is more efficient than fetching these capabilities
	 * every time t_goto is called.
	 */
	if (i >= 0) {
		cap_ptr = capability;
		limit = sizeof(capability) - 1;
		(*bp)->up = t_getstr(*bp, "up", &cap_ptr, &limit);
		if ((*bp)->up)
			(*bp)->up = strdup((*bp)->up);
		cap_ptr = capability;
		limit = sizeof(capability) - 1;
		(*bp)->bc = t_getstr(*bp, "bc", &cap_ptr, &limit);
		if ((*bp)->bc)
			(*bp)->bc = strdup((*bp)->bc);
		(*bp)->tbuf = NULL;
	} else {
		error = i + 1;
		goto out;
	}

	return (i + 1);
out:
	free(*bp);
	*bp = NULL;
	return error;
d254 16
a269 39
 * Get an entry for terminal name in buffer bp from the termcap file.
 */
int
tgetent(char *bp, const char *name)
{
	int i, plen, elen, c;
        char *ptrbuf = NULL;

	i = t_getent(&fbuf, name);

	if (i == 1) {
		/*
		 * stash the full buffer pointer as the ZZ capability
		 * in the termcap buffer passed.
		 */
                plen = asprintf(&ptrbuf, ":ZZ=%p", fbuf->info);
		(void)strlcpy(bp, fbuf->info, 1024);
                elen = strlen(bp);
		/*
		 * backup over the entry if the addition of the full
		 * buffer pointer will overflow the buffer passed.  We
		 * want to truncate the termcap entry on a capability
		 * boundary.
		 */
                if ((elen + plen) > 1023) {
			bp[1023 - plen] = '\0';
			for (c = (elen - plen); c > 0; c--) {
				if (bp[c] == ':') {
					bp[c] = '\0';
					break;
				}
			}
		}

		strcat(bp, ptrbuf);
                tbuf = bp;
	}

	return i;
d281 1
a281 1
t_getnum(struct tinfo *info, const char *id)
d283 2
a284 1
	long num;
d286 21
a306 13
	_DIAGASSERT(info != NULL);
	_DIAGASSERT(id != NULL);

	if (cgetnum(info->info, id, &num) == 0)
		return (int)(num);
	else
		return (-1);
}

int
tgetnum(const char *id)
{
	return fbuf ? t_getnum(fbuf, id) : -1;
a314 8
int t_getflag(struct tinfo *info, const char *id)
{
	_DIAGASSERT(info != NULL);
	_DIAGASSERT(id != NULL);

	return (cgetcap(info->info, id, ':') != NULL);
}

d316 1
a316 1
tgetflag(const char *id)
d318 1
a318 2
	return fbuf ? t_getflag(fbuf, id) : 0;
}
d320 11
a330 36
/*
 * Get a string valued option.
 * These are given as
 *	cl=^Z
 * Much decoding is done on the strings, and the strings are
 * placed in area, which is a ref parameter which is updated.
 * limit is the number of characters allowed to be put into
 * area, this is updated.
 */
char *
t_getstr(struct tinfo *info, const char *id, char **area, size_t *limit)
{
	char *s;
	int i;

	_DIAGASSERT(info != NULL);
	_DIAGASSERT(id != NULL);
	/* area may be NULL */


	if ((i = cgetstr(info->info, id, &s)) < 0) {
		errno = ENOENT;
		if ((area == NULL) && (limit != NULL))
			*limit = 0;
		return NULL;
	}

	if (area != NULL) {
		/*
		 * check if there is room for the new entry to be put into
		 * area
		 */
		if (limit != NULL && (*limit < (size_t) i)) {
			errno = E2BIG;
			free(s);
			return NULL;
a331 13

		(void)strcpy(*area, s);
		free(s);
		s = *area;
		*area += i + 1;
		if (limit != NULL)
			*limit -= i;
		return (s);
	} else {
		_DIAGASSERT(limit != NULL);
		*limit = i;
		free(s);
		return NULL;
d344 1
a344 1
tgetstr(const char *id, char **area)
d346 1
a346 2
	struct tinfo dummy, *ti;
	char ids[3];
d348 15
a362 29
	_DIAGASSERT(id != NULL);

	if (fbuf == NULL)
		return NULL;

	/*
	 * XXX
	 * This is for all the boneheaded programs that relied on tgetstr
	 * to look only at the first 2 characters of the string passed...
	 */
	ids[0] = id[0];
	ids[1] = id[1];
	ids[2] = '\0';

	if ((id[0] == 'Z') && (id[1] == 'Z')) {
		ti = &dummy;
		dummy.info = tbuf;
	} else
		ti = fbuf;

	if (area == NULL || *area == NULL) {
		static char capability[CAPSIZ];
		size_t limit = sizeof(capability) - 1;
		char *ptr;

		ptr = capability;
		return t_getstr(ti, ids, &ptr, &limit);
	} else
		return t_getstr(ti, ids, area, NULL);
d366 2
a367 6
 * Return a string valued option specified by id, allocating memory to
 * an internal buffer as necessary. The memory allocated can be
 * free'd by a call to t_freent().
 *
 * If the string is not found or memory allocation fails then NULL
 * is returned.
d369 2
a370 2
char *
t_agetstr(struct tinfo *info, const char *id)
d372 4
a375 2
	size_t new_size;
	struct tbuf *tb;
d377 26
a402 23
	_DIAGASSERT(info != NULL);
	_DIAGASSERT(id != NULL);

	t_getstr(info, id, NULL, &new_size);

	/* either the string is empty or the capability does not exist. */
	if (new_size == 0)
		return NULL;

	if ((tb = info->tbuf) == NULL ||
	    (size_t) (tb->eptr - tb->ptr) < (new_size + 1)) {
		if (new_size < CAPSIZ)
			new_size = CAPSIZ;
		else
			new_size++;

		if ((tb = malloc(sizeof(*info->tbuf))) == NULL)
			return NULL;

		if ((tb->data = tb->ptr = tb->eptr = malloc(new_size))
		    == NULL) {
			free(tb);
			return NULL;
d404 1
a404 32

		tb->eptr += new_size;

		if (info->tbuf != NULL)
			tb->next = info->tbuf;
		else
			tb->next = NULL;

		info->tbuf = tb;
	}
	return t_getstr(info, id, &tb->ptr, NULL);
}

/*
 * Free the buffer allocated by t_getent
 *
 */
void
t_freent(struct tinfo *info)
{
	struct tbuf *tb, *wb;
	_DIAGASSERT(info != NULL);
	free(info->info);
	if (info->up != NULL)
		free(info->up);
	if (info->bc != NULL)
		free(info->bc);
	for (tb = info->tbuf; tb;) {
		wb = tb;
		tb = tb->next;
		free(wb->data);
		free(wb);
d406 4
a409 1
	free(info);
d413 2
a414 34
 * Get the terminal name string from the termcap entry.
 *
 */
int
t_getterm(struct tinfo *info, char **area, size_t *limit)
{
	char *endp;
	size_t count;

	_DIAGASSERT(info != NULL);
	if ((endp = strchr(info->info, ':')) == NULL) {
		errno = EINVAL;
		return -1;
	}


	count = endp - info->info + 1;
	if (area == NULL) {
		_DIAGASSERT(limit != NULL);
		*limit = count;
		return 0;
	} else {
		if ((limit != NULL) && (count > *limit)) {
			errno = E2BIG;
			return -1;
		}

		(void)strlcpy(*area, info->info, count);
		if (limit != NULL)
			*limit -= count;
	}

	return 0;
}
@


1.7
log
@also search in BRLCAD_DATA/etc for a termcap file.  quell warning on cgetent() constness.
@
text
@d39 1
a39 1
__RCSID("$NetBSD: termcap.c,v 1.54 2006/12/19 02:02:03 uwe Exp $");
@


1.6
log
@update from the old vi termcap sources to the more modern NetBSD implementation.  this version doesn't suffer the assumption that there needs to be an /etc/termcap among many other improvements.  it's under 3-clause BSD and seems to be version 0.6 dated December 17, 2006.
@
text
@d32 2
d169 5
d176 1
d228 1
a228 1
 	i = cgetent(&((*bp)->info), (const char *const *)pathvec, name);
d241 1
a241 1
		i = cgetent(&((*bp)->info), (const char *const *)pathvec, name);
@


1.5
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@d1 2
a3 6
 * This code contains changes by
 *      Gunnar Ritter, Freiburg i. Br., Germany, 2002. All rights reserved.
 *
 * The conditions and no-warranty notice below apply to these changes.
 *
 *
d10 1
a10 1
 *  * Redistributions of source code must retain the above copyright
d12 1
a12 1
 *  * Redistributions in binary form must reproduce the above copyright
d15 1
a15 1
 *  * Neither the name of the University nor the names of its contributors
d32 4
a35 10
#ifndef	lint
#ifdef	DOSCCS
static char *sccsid = "@@(#)termcap.c	1.7 (gritter) 11/23/04";
#endif
#endif

/* from termcap.c	5.1 (Berkeley) 6/5/85 */

#if 0	/* GR */
#define	TCBUFSIZE		1024
d37 1
a37 1
#include "libterm.h"
d39 1
a39 2
#define	E_TERMCAP	"/etc/termcap"
#define MAXHOP		32	/* max number of tc= indirections */
d41 3
d45 2
d48 8
a55 5
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
d71 17
a87 2
static	char *tbuf;
static	int hopcount;	/* detect infinite loops in termcap, init 0 */
d89 21
a109 94
static int tnamatch(const char *);
static int tnchktc(void);
static char *tskip(register const char *);
static char *tdecode(register char *, char **);

/*
 * Tnamatch deals with name matching.  The first field of the termcap
 * entry is a sequence of names separated by |'s, so we compare
 * against each such name.  The normal : terminator after the last
 * name (before the first field) stops us.
 */
static int
tnamatch(const char *np)
{
	register const char *Np;
	register char *Bp;

	Bp = tbuf;
	if (*Bp == '#')
		return(0);
	for (;;) {
		for (Np = np; *Np && *Bp == *Np; Bp++, Np++)
			continue;
		if (*Np == 0 && (*Bp == '|' || *Bp == ':' || *Bp == 0))
			return (1);
		while (*Bp && *Bp != ':' && *Bp != '|')
			Bp++;
		if (*Bp == 0 || *Bp == ':')
			return (0);
		Bp++;
	}
}

/*
 * tnchktc: check the last entry, see if it's tc=xxx. If so,
 * recursively find xxx and append that entry (minus the names)
 * to take the place of the tc=xxx entry. This allows termcap
 * entries to say "like an HP2621 but doesn't turn on the labels".
 * Note that this works because of the left to right scan.
 */
static int
tnchktc(void)
{
	register char *p, *q;
	char tcname[16];	/* name of similar terminal */
	char tcbuf[TCBUFSIZE];
	char rmbuf[TCBUFSIZE];
	char *holdtbuf = tbuf, *holdtc;
	int l;

	p = tbuf;
	while (*p) {
		holdtc = p = tskip(p);
		if (!p)
		  return (0);
		if (!*p)
			break;
		if (*p++ != 't' || *p == 0 || *p++ != 'c')
			continue;
		if (*p++ != '=') {
		bad:	write(2, "Bad termcap entry\n", 18);
			return (0);
		}
		for (q = tcname; *p && *p != ':'; p++) {
			if (q >= &tcname[sizeof tcname - 1])
				goto bad;
			*q++ = *p;
		}
		*q = '\0';
		if (++hopcount > MAXHOP) {
			write(2, "Infinite tc= loop\n", 18);
			return (0);
		}
		if (tgetent(tcbuf, tcname) != 1) {
			hopcount = 0;		/* unwind recursion */
			return(0);
		}
		hopcount--;
		tbuf = holdtbuf;
		strcpy(rmbuf, &p[1]);
		for (q=tcbuf; *q != ':'; q++)
			;
		l = holdtc - holdtbuf + strlen(rmbuf) + strlen(q);
		if (l > TCBUFSIZE) {
			write(2, "Termcap entry too long\n", 23);
			break;
		}
		q++;
		for (p = holdtc; *q; q++)
			*p++ = *q;
		strcpy(p, rmbuf);
		p = holdtc;
	}
	return(1);
d113 3
a115 3
 * Get an entry for terminal name in buffer bp,
 * from the termcap file.  Parse is very rudimentary;
 * we just notice escaped newlines.
d117 1
d119 1
a119 1
tgetent(char *bp, const char *name)
d121 12
a132 5
	register char *cp;
	register int c;
	register int i = 0, cnt = 0;
	char ibuf[TCBUFSIZE];
	int tf;
d134 2
a135 2
	tbuf = bp;
	tf = -1;
d137 5
d145 8
a152 4
	 * name of a file to use instead of /etc/termcap. In this
	 * case it better start with a "/". Or it can be an entry to
	 * use so we don't have to read the file. In this case it
	 * has to already have the newlines crunched out.
d154 15
a168 10
	if (cp && *cp) {
		if (*cp == '/') {
			tf = open(cp, 0);
		} else {
			tbuf = cp;
			c = tnamatch(name);
			tbuf = bp;
			if (c) {
				strcpy(bp,cp);
				return(tnchktc());
d172 4
a175 2
	if (tf < 0)
		tf = open(E_TERMCAP, 0);
d177 12
a188 19
	if (tf < 0)
		return (-1);
	for (;;) {
		cp = bp;
		for (;;) {
			if (i == cnt) {
				cnt = read(tf, ibuf, TCBUFSIZE);
				if (cnt <= 0) {
					close(tf);
					return (0);
				}
				i = 0;
			}
			c = ibuf[i++];
			if (c == '\n') {
				if (cp > bp && cp[-1] == '\\'){
					cp--;
					continue;
				}
a190 5
			if (cp >= bp+TCBUFSIZE) {
				write(2,"Termcap entry too long\n", 23);
				break;
			} else
				*cp++ = c;
d192 49
a240 1
		*cp = 0;
d242 41
d284 2
a285 1
		 * The real work for the match.
d287 17
a303 3
		if (tnamatch(name)) {
			close(tf);
			return(tnchktc());
d305 3
a308 1
}
d310 1
a310 17
/*
 * Skip to the next field.  Notice that this is very dumb, not
 * knowing about \: escapes or any such.  If necessary, :'s can be put
 * into the termcap file in octal.
 */
static char *
tskip(register const char *bp)
{
  if (!bp) {
    return NULL;
  }

  while (*bp && *bp != ':')
    bp++;
  if (*bp == ':')
    bp++;
  return (char *)bp;
d322 1
a322 1
tgetnum(char *id)
d324 1
a324 2
	register int i, base;
	register char *bp = tbuf;
d326 13
a338 21
	for (;;) {
		bp = tskip(bp);
		if (!bp)
		  return -1;
		if (*bp == 0)
			return (-1);
		if (*bp++ != id[0] || *bp == 0 || *bp++ != id[1])
			continue;
		if (*bp == '@@')
			return(-1);
		if (*bp != '#')
			continue;
		bp++;
		base = 10;
		if (*bp == '0')
			base = 8;
		i = 0;
		while (isdigit((*bp & 0377)))
			i *= base, i += *bp++ - '0';
		return (i);
	}
d347 8
d356 1
a356 1
tgetflag(char *id)
d358 2
a359 1
	register char *bp = tbuf;
d361 36
a396 11
	for (;;) {
		bp = tskip(bp);
		if (!bp)
		  return 0;
		if (!*bp)
			return (0);
		if (*bp++ == id[0] && *bp != 0 && *bp++ == id[1]) {
			if (!*bp || *bp == ':')
				return (1);
			else if (*bp == '@@')
				return(0);
d398 13
d423 1
a423 1
tgetstr(char *id, char **area)
d425 7
a431 1
	register char *bp = tbuf;
d433 24
a456 15
	for (;;) {
		bp = tskip(bp);
		if (!bp)
		  return 0;
		if (!*bp)
			return (0);
		if (*bp++ != id[0] || *bp == 0 || *bp++ != id[1])
			continue;
		if (*bp == '@@')
			return(0);
		if (*bp != '=')
			continue;
		bp++;
		return (tdecode(bp, area));
	}
d460 6
a465 2
 * Tdecode does the grung work to decode the
 * string capability escapes.
d467 2
a468 2
static char *
tdecode(register char *str, char **area)
d470 7
a476 4
	register char *cp;
	register int c;
	register char *dp;
	int i;
d478 18
a495 26
	cp = *area;
	while ((c = *str++) && c != ':') {
		switch (c) {

		case '^':
			c = *str++ & 037;
			break;

		case '\\':
			dp = "E\033^^\\\\::n\nr\rt\tb\bf\f";
			c = *str++;
nextc:
			if (*dp++ == c) {
				c = *dp++;
				break;
			}
			dp++;
			if (*dp)
				goto nextc;
			if (isdigit(c)) {
				c -= '0', i = 2;
				do
					c <<= 3, c |= *str++ - '0';
				while (--i && isdigit(*str & 0377));
			}
			break;
d497 32
a528 1
		*cp++ = c;
d530 1
a530 4
	*cp++ = 0;
	str = *area;
	*area = cp;
	return (str);
d534 34
a567 2
*/
static const char sccssl[] = "@@(#)libterm.sl	1.7 (gritter) 11/23/04";
@


1.4
log
@prevent crashes if termcap is asked to perform a tgetnum() after a tgetent() fails
@
text
@d189 1
a189 1
#ifndef V6
d213 1
a213 3
#else
	tf = open(E_TERMCAP, 0);
#endif
@


1.3
log
@the clauses are no longer numbered, so the author's original exemption of the advertising clause is no longer relevant.  reword correspondingly.
@
text
@d130 2
d263 9
a271 6

	while (*bp && *bp != ':')
		bp++;
	if (*bp == ':')
		bp++;
	return (char *)bp;
d290 2
d324 2
d352 2
@


1.2
log
@Pedantic licensing update to retract the "BSD Advertising Clause", i.e. clause 3 of the original 4-clause BSD license.  As granted by William Hoskins, Director to the Office of Technology Licensing at the University of California, Berkeley, update the license on code copyrighted by Berkeley to retract the advertising clause.  See ftp://ftp.cs.berkeley.edu/pub/4bsd/README.Impt.License.Change for details.
@
text
@d5 1
a5 2
 * Conditions 1, 2, and 4 and the no-warranty notice below apply
 * to these changes.
@


1.1
log
@initial termlib library from an early original bsd implementation (that predated the name change to libtermcap).  preserve the name termlib instead of termcap to reduce confusion with the gnu termcap library implementation.  these particular sources were originally taken from the traditional vi project, though they have already been patched.
@
text
@d15 1
a15 1
 * 1. Redistributions of source code must retain the above copyright
d17 1
a17 1
 * 2. Redistributions in binary form must reproduce the above copyright
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@

