head	14.2;
access;
symbols
	rel-7-10-4:14.1
	STABLE:14.1.0.10
	stable-branch:14.1
	rel-7-10-2:14.1
	rel-7-10-0:14.1
	rel-7-8-4:14.1
	rel-7-8-2:14.1
	rel-7-8-0:14.1
	trimnurbs-branch:14.1.0.8
	help:14.1
	temp_tag:14.1
	bobWinPort-20051223-freeze:14.1
	postmerge-20051223-bobWinPort:14.1
	premerge-20051223-bobWinPort:14.1
	rel-7-6-6:14.1
	rel-7-6-4:14.1
	rel-7-6-2:14.1
	rel-7-6-branch:14.1.0.6
	rel-7-6-0:14.1
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.4
	bobWinPort:14.1.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@# @;


14.2
date	2007.09.14.15.21.35;	author erikgreenwald;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.18;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.14.49.41;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.2
log
@removed trailing whitespace
@
text
@#
# colors
# ----------------------------------------------------------------------
# The colors class encapsulates several color related utility functions.
# Class level scope resolution must be used inorder to access the static
# member functions.
#
#   USAGE:
#     set hsb [colors::rgbToHsb [winfo rgb . bisque]]
#
# ----------------------------------------------------------------------
#  AUTHOR: Mark L. Ulferts               EMAIL: mulferts@@spd.dsccc.com
#
#  @@(#) $Id: colors.itcl,v 14.1 2004/11/16 19:42:18 morrison Exp $
# ----------------------------------------------------------------------
#                   Copyright (c) 1995  Mark L. Ulferts
# ======================================================================
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in
# all copies of this software.
#
# IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
# IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.
#
# THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
# ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
# ======================================================================

namespace eval iwidgets::colors {

    # ------------------------------------------------------------------
    # PROCEDURE: rgbToNumeric
    #
    # Returns the numeric value for a list of red, green, and blue.
    # ------------------------------------------------------------------
    proc rgbToNumeric {rgb} {
	if {[llength $rgb] != 3} {
	    error "bad arg: \"$rgb\", should be list of red, green, and blue"
	}

	return [format "#%04x%04x%04x" \
		[lindex $rgb 0] [lindex $rgb 1] [lindex $rgb 2]]
    }

    # ------------------------------------------------------------------
    # PROCEDURE: rgbToHsb
    #
    # The procedure below converts an RGB value to HSB.  It takes red,
    # green, and blue components (0-65535) as arguments, and returns a
    # list containing HSB components (floating-point, 0-1) as result.
    # The code here is a copy of the code on page 615 of "Fundamentals
    # of Interactive Computer Graphics" by Foley and Van Dam.
    # ------------------------------------------------------------------
    proc rgbToHsb {rgb} {
        if {[llength $rgb] != 3} {
            error "bad arg: \"$rgb\", should be list of red, green, and blue"
        }

        set r [expr {[lindex $rgb 0]/65535.0}]
        set g [expr {[lindex $rgb 1]/65535.0}]
        set b [expr {[lindex $rgb 2]/65535.0}]

        set max 0
        if {$r > $max} {set max $r}
        if {$g > $max} {set max $g}
        if {$b > $max} {set max $b}

        set min 65535
        if {$r < $min} {set min $r}
        if {$g < $min} {set min $g}
        if {$b < $min} {set min $b}

        if {$max != 0} {
            set sat  [expr {($max-$min)/$max}]
        } else {
            set sat 0
        }
        if {$sat == 0} {
            set hue 0
        } else {
            set rc [expr {($max-$r)/($max-$min)}]
            set gc [expr {($max-$g)/($max-$min)}]
            set bc [expr {($max-$b)/($max-$min)}]

            if {$r == $max} {
                set hue [expr {$bc-$gc}]
            } elseif {$g == $max} {
                set hue [expr {2+$rc-$bc}]
            } elseif {$b == $max} {
                set hue [expr {4+$gc-$rc}]
            }
            set hue [expr {$hue*0.1666667}]
            if {$hue < 0} {set hue [expr {$hue+1.0}]}
        }
        return [list $hue $sat $max]
    }

    # ------------------------------------------------------------------
    # PROCEDURE: hsbToRgb
    #
    # The procedure below converts an HSB value to RGB.  It takes hue,
    # saturation, and value components (floating-point, 0-1.0) as
    # arguments, and returns a list containing RGB components (integers,
    # 0-65535) as result.  The code here is a copy of the code on page
    # 616 of "Fundamentals of Interactive Computer Graphics" by Foley
    # and Van Dam.
    # ------------------------------------------------------------------
    proc hsbToRgb {hsb} {

	if {[llength $hsb] != 3} {
	    error "bad arg: \"$hsb\", should be list of hue, saturation, and brightness"
	}

	set hue [lindex $hsb 0]
	set sat [lindex $hsb 1]
	set value [lindex $hsb 2]

	set v [format %.0f [expr {65535.0*$value}]]
	if {$sat == 0} {
	    return "$v $v $v"
	} else {
	    set hue [expr {$hue*6.0}]
	    if {$hue >= 6.0} {
		set hue 0.0
	    }
	    scan $hue. %d i
	    set f [expr {$hue-$i}]
	    set p [format %.0f [expr {65535.0*$value*(1 - $sat)}]]
	    set q [format %.0f [expr {65535.0*$value*(1 - ($sat*$f))}]]
	    set t [format %.0f [expr {65535.0*$value*(1 - ($sat*(1 - $f)))}]]
	    case $i \
		    0 {return "$v $t $p"} \
		    1 {return "$q $v $p"} \
		    2 {return "$p $v $t"} \
		    3 {return "$p $q $v"} \
		    4 {return "$t $p $v"} \
		    5 {return "$v $p $q"}
	    error "i value $i is out of range"
	}
    }

    # ------------------------------------------------------------------
	#
	# PROCEDURE: topShadow bgColor
	#
	# This method computes a lighter shadow variant of bgColor.
	# It wants to decrease the saturation to 25%. But if there is
	# no saturation (as in gray colors) it tries to turn the
	# brightness up by 10%. It maxes the brightness at 1.0 to
	# avoid bogus colors...
	#
	# bgColor is converted to HSB where the calculations are
	# made. Then converted back to an rgb color number (hex fmt)
	#
    # ------------------------------------------------------------------
	proc topShadow { bgColor } {

		set hsb [rgbToHsb [winfo rgb . $bgColor]]

		set saturation [lindex $hsb 1]
		set brightness [lindex $hsb 2]

		if { $brightness < 0.9 } {
			# try turning the brightness up first.
			set brightness [expr {$brightness * 1.1}]
		} else {
			# otherwise fiddle with saturation
			set saturation [expr {$saturation * 0.25}]
		}

		set hsb [lreplace $hsb 1 1 [set saturation]]
		set hsb [lreplace $hsb 2 2 [set brightness]]

		set rgb [hsbToRgb $hsb]
		set color [rgbToNumeric $rgb]
		return $color
	}


    # ------------------------------------------------------------------
	#
	# PROC: bottomShadow bgColor
	#
	#
	# This method computes a darker shadow variant of bg color.
	# It takes the brightness and decreases it to 80% of its
	# original value.
	#
	# bgColor is converted to HSB where the calculations are
	# made. Then converted back to an rgb color number (hex fmt)
	#
    # ------------------------------------------------------------------
	proc bottomShadow { bgColor } {

		set hsb [rgbToHsb [winfo rgb . $bgColor]]
		set hsb [lreplace $hsb 2 2 [expr {[lindex $hsb 2] * 0.8}]]
		set rgb [hsbToRgb $hsb]
		set color [rgbToNumeric $rgb]
		return $color
	}
}
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d14 1
a14 1
#  @@(#) $Id: colors.itcl,v 1.1 2004/05/20 14:49:41 morrison Exp $
d23 1
a23 1
# 
d25 3
a27 3
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES 
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN 
# IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
d30 2
a31 2
# THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, 
# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
d56 3
a58 3
    # The procedure below converts an RGB value to HSB.  It takes red, 
    # green, and blue components (0-65535) as arguments, and returns a 
    # list containing HSB components (floating-point, 0-1) as result.  
d109 5
a113 5
    # The procedure below converts an HSB value to RGB.  It takes hue, 
    # saturation, and value components (floating-point, 0-1.0) as 
    # arguments, and returns a list containing RGB components (integers, 
    # 0-65535) as result.  The code here is a copy of the code on page 
    # 616 of "Fundamentals of Interactive Computer Graphics" by Foley 
d156 1
a156 1
	# no saturation (as in gray colors) it tries to turn the 
d160 1
a160 1
	# bgColor is converted to HSB where the calculations are 
d187 1
a187 1
	
d197 1
a197 1
	# bgColor is converted to HSB where the calculations are 
@


1.1
log
@Sources that are external to BRL-CAD are moved from the top level to src/other/.
@
text
@d14 1
a14 1
#  @@(#) $Id: colors.itcl,v 1.1 2003/03/13 13:20:32 jra Exp $
@

