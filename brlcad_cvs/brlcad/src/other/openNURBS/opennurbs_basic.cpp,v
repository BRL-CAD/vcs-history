head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@// @;


1.2
date	2007.09.14.15.21.40;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_basic.cpp,v 1.1 2007/01/05 15:20:16 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#include "opennurbs.h"

ON__m__GetLocalClosestPointOnBezierCurve   ON_BezierCurve::m__GetLocalClosestPointOnBezierCurve = 0;
ON__m__GetLocalBezierCurveSurfaceIntersection ON_BezierCurve::m__GetLocalBezierCurveSurfaceIntersection = 0;
ON__m__GetLocalBezierCurveCurveIntersection ON_BezierCurve::m__GetLocalBezierCurveCurveIntersection = 0;
ON__m__GetBezierCurveTightBoundingBox ON_BezierCurve::m__GetBezierCurveTightBoundingBox = 0;

ON__m__GetClosestPointOnBezierSurface ON_BezierSurface::m__GetClosestPointOnBezierSurface = 0;

int ON_ArcCurve::IntersectSelf(
        ON_SimpleArray<ON_X_EVENT>& x,
        double intersection_tolerance,
        const ON_Interval* curve_domain
        ) const
{
  return 0;
}

int ON_LineCurve::IntersectSelf(
        ON_SimpleArray<ON_X_EVENT>& x,
        double intersection_tolerance,
        const ON_Interval* curve_domain
        ) const
{
  return 0;
}

#if !defined(OPENNURBS_PLUS_INC_)

////////////////////////////////////////////////////////////////
//
// Basic ON_Line functions
//

int ON_Line::IntersectSurface(
          const ON_Surface* surfaceB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance,
          double overlap_tolerance,
          const ON_Interval* line_domain,
          const ON_Interval* surfaceB_udomain,
          const ON_Interval* surfaceB_vdomain
          ) const
{
  return 0;
}

////////////////////////////////////////////////////////////////
//
// Basic ON_PlaneEquation functions
//

double ON_PlaneEquation::MinimumValueAt(const ON_SurfaceLeafBox& srfleafbox) const
{
  return 0.0;
}

double ON_PlaneEquation::MaximumValueAt(const ON_SurfaceLeafBox& srfleafbox) const
{
  return 0.0;
}

double ON_PlaneEquation::MinimumValueAt(const class ON_CurveLeafBox& crvleafbox) const
{
  return 0.0;
}

double ON_PlaneEquation::MaximumValueAt(const class ON_CurveLeafBox& crvleafbox) const
{
  return 0.0;
}

////////////////////////////////////////////////////////////////
//
// Basic ON_BezierCurve functions
//

int ON_BezierCurve::IntersectSelf(
        ON_SimpleArray<ON_X_EVENT>& x,
        double intersection_tolerance
        ) const
{
  return 0;
}

int ON_BezierCurve::IntersectCurve(
        const ON_BezierCurve* bezierB,
        ON_SimpleArray<ON_X_EVENT>& x,
        double intersection_tolerance,
        double overlap_tolerance,
        const ON_Interval* bezierA_domain,
        const ON_Interval* bezierB_domain
        ) const
{
  return 0;
}

int ON_BezierCurve::IntersectSurface(
          const ON_BezierSurface* bezsrfB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance,
          double overlap_tolerance,
          const ON_Interval* bezierA_domain,
          const ON_Interval* bezsrfB_udomain,
          const ON_Interval* bezsrfB_vdomain
          ) const
{
  return 0;
}

bool ON_BezierCurve::GetLocalClosestPoint(
        ON_3dPoint P,
        double seed_parameter,
        double* t,
        const ON_Interval* sub_domain
        ) const
{
  return false;
}

bool ON_BezierCurve::GetClosestPoint(
        ON_3dPoint P,
        double* t,
        double maximum_distance,
        const ON_Interval* sub_domain
        ) const
{
  return false;
}

bool ON_BezierCurve::GetLocalCurveIntersection(
        const ON_BezierCurve* other_bezcrv,
        double this_seed_t,
        double other_seed_t,
        double* this_t,
        double* other_t,
        const ON_Interval* this_domain,
        const ON_Interval* other_domain
        ) const
{
  return false;
}


bool ON_BezierCurve::GetLocalSurfaceIntersection(
          const ON_BezierSurface* bezsrf,
          double seed_t,
          double seed_u,
          double seed_v,
          double* t,
          double* u,
          double* v,
          const ON_Interval* tdomain,
          const ON_Interval* udomain,
          const ON_Interval* vdomain
          ) const
{
  return false;
}


////////////////////////////////////////////////////////////////
//
// Basic ON_BezierSurface functions
//

bool ON_BezierSurface::GetLocalClosestPoint(
        ON_3dPoint P,
        double s_seed,
        double t_seed,
        double* s,
        double* t,
        const ON_Interval* sub_domain0,
        const ON_Interval* sub_domain1
        ) const
{
  return false;
}

bool ON_BezierSurface::GetClosestPoint(
        ON_3dPoint P,
        double* s,
        double* t,
        double maximum_distance,
        const ON_Interval* sub_domain0,
        const ON_Interval* sub_domain1
        ) const
{
  return false;
}


////////////////////////////////////////////////////////////////
//
// Basic ON_X_EVENT functions
//

bool ON_X_EVENT::IsValid(ON_TextLog* text_log,
                          double intersection_tolerance,
                          double overlap_tolerance,
                          const ON_Curve* curveA,
                          const ON_Interval* curveA_domain,
                          const ON_Curve* curveB,
                          const ON_Interval* curveB_domain,
                          const ON_Surface* surfaceB,
                          const ON_Interval* surfaceB_domain0,
                          const ON_Interval* surfaceB_domain1
                          ) const
{
  return true;
}

void ON_X_EVENT::CopyEventPart(
      const ON_X_EVENT& src,
      int i,
      ON_X_EVENT& dst,
      int j
      )
{
}

bool ON_X_EVENT::IsValidList(
        int xevent_count,
        const ON_X_EVENT* xevent,
        ON_TextLog* text_log,
        double intersection_tolerance,
        double overlap_tolerance,
        const class ON_Curve* curveA,
        const class ON_Interval* curveA_domain,
        const class ON_Curve* curveB,
        const class ON_Interval* curveB_domain,
        const class ON_Surface* surfaceB,
        const class ON_Interval* surfaceB_domain0,
        const class ON_Interval* surfaceB_domain1
        )
{
  return true;
}

int ON_X_EVENT::CleanList(
        double event_tolerance,
        double overlap_tolerance,
        int xevent_count,
        ON_X_EVENT* xevent
        )
{
  return xevent_count;
}

bool ON_X_EVENT::IsValidCurveCurveOverlap(
          ON_Interval curveA_domain,
          int sample_count,
          double overlap_tolerance,
          const class ON_CurveTreeNode* cnodeA,
          const class ON_CurveTreeNode* cnodeB,
          const ON_Interval* curveB_domain
          )
{
  return true;
}

bool ON_X_EVENT::IsValidCurveSurfaceOverlap(
                      ON_Interval curveA_domain,
                      int sample_count,
                      double overlap_tolerance,
                      const class ON_CurveTreeNode* cnodeA,
                      const class ON_SurfaceTreeNode* snodeB,
                      const ON_Interval* surfaceB_udomain,
                      const ON_Interval* surfaceB_vdomain
                      )
{
  return true;
}

bool ON_X_EVENT::IsValidCurvePlaneOverlap(
          ON_Interval curveA_domain,
          int sample_count,
          double endpoint_tolerance,
          double overlap_tolerance,
          const class ON_CurveTreeNode* cnodeA,
          const ON_PlaneEquation* plane_equation
          )
{
  return true;
}


////////////////////////////////////////////////////////////////
//
// Basic ON_Curve functions
//

ON_CurveTree* ON_Curve::CreateCurveTree() const
{
  return 0;
}

bool ON_Curve::GetClosestPoint(
        const ON_3dPoint& test_point,
        double* t,       // parameter of local closest point returned here
        double maximum_distance,
        const ON_Interval* sub_domain
        ) const
{
  return false;
}

bool ON_Curve::GetTightBoundingBox(
		ON_BoundingBox& tight_bbox,
    int bGrowBox,
		const ON_Xform* xform
    ) const
{
  return false;
}

int ON_Curve::IntersectSelf(
        ON_SimpleArray<ON_X_EVENT>& x,
        double intersection_tolerance,
        const ON_Interval* curve_domain
        ) const
{
  return 0;
}

int ON_Curve::IntersectCurve(
          const ON_Curve* curveB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance,
          double overlap_tolerance,
          const ON_Interval* curveA_domain,
          const ON_Interval* curveB_domain
          ) const
{
  return 0;
}

int ON_Curve::IntersectSurface(
          const ON_Surface* surfaceB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance,
          double overlap_tolerance,
          const ON_Interval* curveA_domain,
          const ON_Interval* surfaceB_udomain,
          const ON_Interval* surfaceB_vdomain
          ) const
{
  return 0;
}

#endif
@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src4/opennurbs/opennurbs_basic.cpp 2     9/01/06 11:33a Dalelear $ */
d11 1
a11 1
//				
d26 1
a26 1
int ON_ArcCurve::IntersectSelf( 
d35 1
a35 1
int ON_LineCurve::IntersectSelf( 
d51 1
a51 1
int ON_Line::IntersectSurface( 
d94 1
a94 1
int ON_BezierCurve::IntersectSelf( 
d102 1
a102 1
int ON_BezierCurve::IntersectCurve( 
d114 1
a114 1
int ON_BezierCurve::IntersectSurface( 
d127 1
a127 1
bool ON_BezierCurve::GetLocalClosestPoint( 
d137 1
a137 1
bool ON_BezierCurve::GetClosestPoint( 
d147 1
a147 1
bool ON_BezierCurve::GetLocalCurveIntersection( 
d161 1
a161 1
bool ON_BezierCurve::GetLocalSurfaceIntersection( 
d183 1
a183 1
bool ON_BezierSurface::GetLocalClosestPoint( 
d196 1
a196 1
bool ON_BezierSurface::GetClosestPoint( 
d230 1
a230 1
      const ON_X_EVENT& src, 
d232 2
a233 2
      ON_X_EVENT& dst, 
      int j 
d266 1
a266 1
bool ON_X_EVENT::IsValidCurveCurveOverlap( 
d270 1
a270 1
          const class ON_CurveTreeNode* cnodeA, 
d278 1
a278 1
bool ON_X_EVENT::IsValidCurveSurfaceOverlap( 
d282 1
a282 1
                      const class ON_CurveTreeNode* cnodeA, 
d291 1
a291 1
bool ON_X_EVENT::IsValidCurvePlaneOverlap( 
d314 1
a314 1
bool ON_Curve::GetClosestPoint( 
d324 2
a325 2
bool ON_Curve::GetTightBoundingBox( 
		ON_BoundingBox& tight_bbox, 
d333 1
a333 1
int ON_Curve::IntersectSelf( 
d342 1
a342 1
int ON_Curve::IntersectCurve( 
d354 1
a354 1
int ON_Curve::IntersectSurface( 
@

