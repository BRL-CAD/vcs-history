head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.09.14.15.21.41;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.26;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_fpoint.h,v 1.1 2007/01/05 15:20:26 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines float precision point, vector, and array classes
//
////////////////////////////////////////////////////////////////
#if !defined(ON_FPOINT_INC_)
#define ON_FPOINT_INC_

class ON_Xform;

class ON_2fPoint;
class ON_3fPoint;
class ON_4fPoint;

class ON_2fVector;
class ON_3fVector;

////////////////////////////////////////////////////////////////
//
//   ON_2fPoint
//
class ON_CLASS ON_2fPoint
{
public:
  float x, y;

  // use implicit destructor, copy constructor
  ON_2fPoint();                         // not initialized
  ON_2fPoint(const float*);             // from array of 2 floats
  ON_2fPoint(const double*);            // from array of 2 doubles
  ON_2fPoint(float,float);
  ON_2fPoint(const ON_3fPoint& );     // from 3d point
  ON_2fPoint(const ON_4fPoint& );     // from homogeneous 4d point
  ON_2fPoint(const ON_2fVector& );    // from 2d vector

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_2fPoint&)
  ON_2fPoint& operator=(const float*);  // point = float[2] support
  ON_2fPoint& operator=(const double*); // point = double[2] support
  ON_2fPoint& operator=(const ON_3fPoint&);
  ON_2fPoint& operator=(const ON_4fPoint&);
  ON_2fPoint& operator=(const ON_2fVector&);

  ON_2fPoint& operator*=(float);
  ON_2fPoint& operator/=(float);
  ON_2fPoint& operator+=(const ON_2fPoint&);
  ON_2fPoint& operator+=(const ON_2fVector&);
  ON_2fPoint& operator-=(const ON_2fPoint&);
  ON_2fPoint& operator-=(const ON_2fVector&);

  ON_2fPoint  operator*(float) const;
  ON_2fPoint  operator/(float) const;
  ON_2fPoint  operator+(const ON_2fPoint&) const;
  ON_2fPoint  operator+(const ON_2fVector&) const;
  ON_2fVector operator-(const ON_2fPoint&) const;
  ON_2fPoint  operator-(const ON_2fVector&) const;

  float operator*(const ON_2fPoint&) const; // for points acting as vectors
  float operator*(const ON_2fVector&) const; // for points acting as vectors
  float operator*(const ON_4fPoint&) const;

  bool operator==(const ON_2fPoint&) const;
  bool operator!=(const ON_2fPoint&) const;

  // dictionary order comparisons
  bool operator<=(const ON_2fPoint&) const;
  bool operator>=(const ON_2fPoint&) const;
  bool operator<(const ON_2fPoint&) const;
  bool operator>(const ON_2fPoint&) const;

  // index operators mimic float[2] behavior
  float& operator[](int);
  float operator[](int) const;

  // set 2d point value
  void Set(float,float);

  double DistanceTo( const ON_2fPoint& ) const;

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  void Zero(); // set all coordinates to zero;

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform(
        const ON_Xform&
        );

  void Rotate( // rotatation in XY plane
        double,              // angle in radians
        const ON_2fPoint&   // center of rotation
        );

  void Rotate( // rotatation in XY plane
        double,              // sin(angle)
        double,              // cos(angle)
        const ON_2fPoint&   // center of rotation
        );
};

ON_DECL
ON_2fPoint operator*(float, const ON_2fPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_3fPoint
//
class ON_CLASS ON_3fPoint
{
public:
  float x, y, z;

  // use implicit destructor, copy constructor
  ON_3fPoint();                        // not initialized
  ON_3fPoint(const float*);            // from array of 3 floats
  ON_3fPoint(const double*);           // from array of 3 doubles
  ON_3fPoint(float,float,float);
  ON_3fPoint(const ON_2fPoint& );     // from 2d point
  ON_3fPoint(const ON_4fPoint& );     // from homogeneous 4d point
  ON_3fPoint(const ON_3fVector& );    // from 3d vector

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_3fPoint&)
  ON_3fPoint& operator=(const float*);  // point = float[3] support
  ON_3fPoint& operator=(const double*); // point = double[3] support
  ON_3fPoint& operator=(const ON_2fPoint&);
  ON_3fPoint& operator=(const ON_4fPoint&);
  ON_3fPoint& operator=(const ON_3fVector&);

  ON_3fPoint& operator*=(float);
  ON_3fPoint& operator/=(float);
  ON_3fPoint& operator+=(const ON_3fPoint&);
  ON_3fPoint& operator+=(const ON_3fVector&);
  ON_3fPoint& operator-=(const ON_3fPoint&);
  ON_3fPoint& operator-=(const ON_3fVector&);

  ON_3fPoint  operator*(float) const;
  ON_3fPoint  operator/(float) const;
  ON_3fPoint  operator+(const ON_3fPoint&) const;
  ON_3fPoint  operator+(const ON_3fVector&) const;
  ON_3fVector operator-(const ON_3fPoint&) const;
  ON_3fPoint  operator-(const ON_3fVector&) const;

  float operator*(const ON_3fPoint&) const; // for points acting as vectors
  float operator*(const ON_3fVector&) const; // for points acting as vectors
  float operator*(const ON_4fPoint&) const;

  bool operator==(const ON_3fPoint&) const;
  bool operator!=(const ON_3fPoint&) const;

  // dictionary order comparisons
  bool operator<=(const ON_3fPoint&) const;
  bool operator>=(const ON_3fPoint&) const;
  bool operator<(const ON_3fPoint&) const;
  bool operator>(const ON_3fPoint&) const;

  // index operators mimic float[3] behavior
  float& operator[](int);
  float operator[](int) const;

  // set 3d point value
  void Set(float,float,float);

  double DistanceTo( const ON_3fPoint& ) const;

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate
  double Fuzz( double = ON_ZERO_TOLERANCE ) const; // tolerance to use when comparing 3d points

  void Zero(); // set all coordinates to zero;

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform(
        const ON_Xform&
        );

  void Rotate(
        double,               // angle in radians
        const ON_3fVector&, // axis of rotation
        const ON_3fPoint&   // center of rotation
        );

  void Rotate(
        double,               // sin(angle)
        double,               // cos(angle)
        const ON_3fVector&, // axis of rotation
        const ON_3fPoint&   // center of rotation
        );
};

ON_DECL
ON_3fPoint operator*(float, const ON_3fPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_4fPoint (homogeneous coordinates)
//
class ON_CLASS ON_4fPoint
{
public:
  float x, y, z, w;

  // use implicit destructor, copy constructor
  ON_4fPoint();                         // not initialized
  ON_4fPoint(const float*);             // from array of 4 doubles
  ON_4fPoint(const double*);            // from array of 4 doubles
  ON_4fPoint(float,float,float,float);
  ON_4fPoint(const ON_2fPoint& );     // from 2d point
  ON_4fPoint(const ON_3fPoint& );     // from 3d point
  ON_4fPoint(const ON_2fVector& );    // from 2d vector
  ON_4fPoint(const ON_3fVector& );    // from 3d vector

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_4fPoint&)
  ON_4fPoint& operator=(const float*);  // point = float[4] support
  ON_4fPoint& operator=(const double*); // point = double[4] support
  ON_4fPoint& operator=(const ON_2fPoint&);
  ON_4fPoint& operator=(const ON_3fPoint&);
  ON_4fPoint& operator=(const ON_2fVector&);
  ON_4fPoint& operator=(const ON_3fVector&);

  ON_4fPoint& operator*=(float);
  ON_4fPoint& operator/=(float);
  ON_4fPoint& operator+=(const ON_4fPoint&);
  ON_4fPoint& operator-=(const ON_4fPoint&);

  ON_4fPoint  operator*(float) const;
  ON_4fPoint  operator/(float) const;
  ON_4fPoint  operator+(const ON_4fPoint&) const; // sum w = sqrt(w1*w2)
  ON_4fPoint  operator-(const ON_4fPoint&) const; // difference w = sqrt(w1*w2)

  float operator*(const ON_4fPoint&) const;

  // projective comparison
  // (i.e., [x,y,z,w] == [c*x,c*y,c*z,c*w] is true for nonzero c)
  bool operator==(ON_4fPoint) const;
  bool operator!=(const ON_4fPoint&) const;

  // index operators mimic float[4] behavior
  float& operator[](int);
  float operator[](int) const;

  // set 4d point value
  void Set(float,float,float,float);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  void Zero();      // set all 4 coordinates to zero;
  bool Normalize(); // set so x^2 + y^2 + z^2 + w^2 = 1

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform(
        const ON_Xform&
        );
};

ON_DECL
ON_4fPoint operator*(float, const ON_4fPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_2fVector
//
class ON_CLASS ON_2fVector
{
public:
  float x, y;

  // Description:
  //   A index driven function to get unit axis vectors.
  // Parameters:
  //   index - [in] 0 returns (1,0), 1 returns (0,1)
  // Returns:
  //   Unit 3d vector with vector[i] = (i==index)?1:0;
  static const ON_2fVector& UnitVector(
    int // index
    );

  // use implicit destructor, copy constructor
  ON_2fVector();                     // not initialized
  ON_2fVector(const float*);         // from array of 2 floats
  ON_2fVector(const double*);        // from array of 2 doubles
  ON_2fVector(float,float);
  ON_2fVector(const ON_3fVector& ); // from 3d vector
  ON_2fVector(const ON_2fPoint& );  // from 2d point

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_2fVector&)
  ON_2fVector& operator=(const float*);  // vector = float[2] support
  ON_2fVector& operator=(const double*); // vector = double[2] support
  ON_2fVector& operator=(const ON_3fVector&);
  ON_2fVector& operator=(const ON_2fPoint&);

  ON_2fVector  operator-() const;

  ON_2fVector& operator*=(float);
  ON_2fVector& operator/=(float);
  ON_2fVector& operator+=(const ON_2fVector&);
  ON_2fVector& operator-=(const ON_2fVector&);

  ON_2fVector  operator*(float) const;
  float operator*(const ON_2fVector&) const; // inner (dot) product
  float operator*(const ON_2fPoint&) const; // inner (dot) product point acting as a vector
  double operator*(const ON_2dVector&) const; // inner (dot) product
  ON_2fVector  operator/(float) const;
  ON_2fVector  operator+(const ON_2fVector&) const;
  ON_2fPoint   operator+(const ON_2fPoint&) const;
  ON_2fVector  operator-(const ON_2fVector&) const;

  float operator*(const ON_4fPoint&) const;

  bool operator==(const ON_2fVector&) const;
  bool operator!=(const ON_2fVector&) const;

  // dictionary order comparisons
  bool operator<=(const ON_2fVector&) const;
  bool operator>=(const ON_2fVector&) const;
  bool operator<(const ON_2fVector&) const;
  bool operator>(const ON_2fVector&) const;

  // index operators mimic float[2] behavior
  float& operator[](int);
  float operator[](int) const;

  // set 2d vector value
  void Set(float,float);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  double LengthSquared() const;
  double Length() const;

  bool Decompose( // Computes a, b such that this vector = a*X + b*Y
         // Returns false if unable to solve for a,b.  This happens
         // when X,Y is not really a basis.
         //
         // If X,Y is known to be an orthonormal frame,
         // then a = V*X, b = V*Y will compute
         // the same result more quickly.
         const ON_2fVector&, // X
         const ON_2fVector&, // Y
         double*, // a
         double*  // b
         ) const;

  int IsParallelTo(
        // returns  1: this and other vectors are parallel
        //         -1: this and other vectors are anti-parallel
        //          0: this and other vectors are not parallel
        //             or at least one of the vectors is zero
        const ON_2fVector&,                 // other vector
        double = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  bool IsPerpendicularTo(
        // returns true:  this and other vectors are perpendicular
        //         false: this and other vectors are not perpendicular
        //                or at least one of the vectors is zero
        const ON_2fVector&,                 // other vector
        double = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  void Zero(); // set all coordinates to zero;
  void Reverse(); // negate all coordinates
  bool Unitize();  // returns false if vector has zero length

  // Description:
  //   Test a vector to see if it is very short
  //
  // Parameters:
  //   tiny_tol - [in] (default = ON_ZERO_TOLERANCE) a nonzero
  //              value used as the coordinate zero tolerance.
  //
  // Returns:
  //   ( fabs(x) <= tiny_tol && fabs(y) <= tiny_tol )
  //
  bool IsTiny(
         double = ON_ZERO_TOLERANCE // tiny_tol
         ) const;

  // Returns:
  //   true if vector is the zero vector.
  bool IsZero() const;

  // set this vector to be perpendicular to another vector
  bool PerpendicularTo( // Result is not unitized.
                        // returns false if input vector is zero
        const ON_2fVector&
        );

  // set this vector to be perpendicular to a line defined by 2 points
  bool PerpendicularTo(
        const ON_2fPoint&,
        const ON_2fPoint&
        );
};

ON_DECL
ON_2fVector operator*(float, const ON_2fVector&);

///////////////////////////////////////////////////////////////
//
// ON_2fVector utilities
//

ON_DECL
float
ON_DotProduct(
    const ON_2fVector&,
    const ON_2fVector&
    );

ON_DECL
ON_3fVector
ON_CrossProduct(
    const ON_2fVector&,
    const ON_2fVector&
    );

ON_DECL
bool
ON_IsOrthogonalFrame( // true if X, Y are nonzero and mutually perpindicular
    const ON_2fVector&, // X
    const ON_2fVector&  // Y
    );

ON_DECL
bool
ON_IsOrthonormalFrame( // true if X, Y are orthogonal and unit length
    const ON_2fVector&, // X
    const ON_2fVector&  // Y
    );

ON_DECL
bool
ON_IsRightHandFrame( // true if X, Y are orthonormal and right handed
    const ON_2fVector&, // X
    const ON_2fVector&  // Y
    );

////////////////////////////////////////////////////////////////
//
//   ON_3fVector
//
class ON_CLASS ON_3fVector
{
public:
  float x, y, z;

  // Description:
  //   A index driven function to get unit axis vectors.
  // Parameters:
  //   index - [in] 0 returns (1,0,0), 1 returns (0,1,0)
  //                2 returns (0,0,1)
  // Returns:
  //   Unit 3d vector with vector[i] = (i==index)?1:0;
  static const ON_3fVector& UnitVector(
    int // index
    );

  // use implicit destructor, copy constructor
  ON_3fVector();                     // not initialized
  ON_3fVector(const float*);         // from array of 3 floats
  ON_3fVector(const double*);        // from array of 3 doubles
  ON_3fVector(float,float,float);
  ON_3fVector(const ON_2fVector& ); // from 2d vector
  ON_3fVector(const ON_3fPoint& );  // from 3d point

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_3fVector&)
  ON_3fVector& operator=(const float*);  // vector = float[3] support
  ON_3fVector& operator=(const double*); // vector = double[3] support
  ON_3fVector& operator=(const ON_2fVector&);
  ON_3fVector& operator=(const ON_3fPoint&);

  ON_3fVector  operator-() const;

  ON_3fVector& operator*=(float);
  ON_3fVector& operator/=(float);
  ON_3fVector& operator+=(const ON_3fVector&);
  ON_3fVector& operator-=(const ON_3fVector&);

  ON_3fVector  operator*(float) const;
  float operator*(const ON_3fVector&) const; // inner (dot) product
  float operator*(const ON_3fPoint&) const; // inner (dot) product (point acting as a vector)
  double operator*(const ON_3dVector&) const; // inner (dot) product
  ON_3fVector  operator/(float) const;
  ON_3fVector  operator+(const ON_3fVector&) const;
  ON_3fPoint   operator+(const ON_3fPoint&) const;
  ON_3fVector  operator-(const ON_3fVector&) const;

  float operator*(const ON_4fPoint&) const;

  bool operator==(const ON_3fVector&) const;
  bool operator!=(const ON_3fVector&) const;

  // dictionary order comparisons
  bool operator<=(const ON_3fVector&) const;
  bool operator>=(const ON_3fVector&) const;
  bool operator<(const ON_3fVector&) const;
  bool operator>(const ON_3fVector&) const;

  // index operators mimic float[3] behavior
  float& operator[](int);
  float operator[](int) const;

  // set 3d vector value
  void Set(float,float,float);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  double LengthSquared() const;
  double Length() const;

  bool IsPerpendicularTo(
        // returns true:  this and other vectors are perpendicular
        //         false: this and other vectors are not perpendicular
        //                or at least one of the vectors is zero
        const ON_3fVector&,                 // other vector
        double = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  double Fuzz( double = ON_ZERO_TOLERANCE ) const; // tolerance to use when comparing 3d vectors

  void Zero(); // set all coordinates to zero
  void Reverse(); // negate all coordinates
  bool Unitize();  // returns false if vector has zero length

  // Description:
  //   Test a vector to see if it is very short
  //
  // Parameters:
  //   tiny_tol - [in] (default = ON_ZERO_TOLERANCE) a nonzero
  //              value used as the coordinate zero tolerance.
  //
  // Returns:
  //   ( fabs(x) <= tiny_tol && fabs(y) <= tiny_tol && fabs(z) <= tiny_tol )
  //
  bool IsTiny(
         double = ON_ZERO_TOLERANCE // tiny_tol
         ) const;

  // Returns:
  //   true if vector is the zero vector.
  bool IsZero() const;

  // set this vector to be perpendicular to another vector
  bool PerpendicularTo( // Result is not unitized.
                        // returns false if input vector is zero
        const ON_3fVector&
        );

  // These transform the vector in place. The transformation matrix acts on
  // the left of the vector; i.e., result = transformation*vector
  void Transform(
        const ON_Xform& // can use ON_Xform here
        );

  void Rotate(
        double,             // angle in radians
        const ON_3fVector&  // axis of rotation
        );

  void Rotate(
        double,             // sin(angle)
        double,             // cos(angle)
        const ON_3fVector&  // axis of rotation
        );
};

ON_DECL
ON_3fVector operator*(float, const ON_3fVector&);

///////////////////////////////////////////////////////////////
//
// ON_3fVector utilities
//

ON_DECL
float
ON_DotProduct(
    const ON_3fVector&,
    const ON_3fVector&
    );


ON_DECL
ON_3fVector
ON_CrossProduct(
    const ON_3fVector&,
    const ON_3fVector&
    );

ON_DECL
ON_3fVector
ON_CrossProduct( // 3d cross product for old fashioned arrays
    const float*, // array of 3d floats
    const float*  // array of 3d floats
    );

ON_DECL
float
ON_TripleProduct(
    const ON_3fVector&,
    const ON_3fVector&,
    const ON_3fVector&
    );

ON_DECL
float
ON_TripleProduct(  // 3d triple product for old fashioned arrays
    const float*, // array of 3d floats
    const float*, // array of 3d floats
    const float*  // array of 3d floats
    );

ON_DECL
bool
ON_IsOrthogonalFrame( // true if X, Y, Z are nonzero and mutually perpindicular
    const ON_3fVector&, // X
    const ON_3fVector&, // Y
    const ON_3fVector&  // Z
    );

ON_DECL
bool
ON_IsOrthonormalFrame( // true if X, Y, Z are orthogonal and unit length
    const ON_3fVector&, // X
    const ON_3fVector&, // Y
    const ON_3fVector&  // Z
    );

ON_DECL
bool
ON_IsRightHandFrame( // true if X, Y, Z are orthonormal and right handed
    const ON_3fVector&, // X
    const ON_3fVector&, // Y
    const ON_3fVector&  // Z
    );

///////////////////////////////////////////////////////////////
//
// common points and vectors
//

extern ON_EXTERN_DECL const ON_3fPoint ON_forigin; // (0.0, 0.0, 0.0)
extern ON_EXTERN_DECL const ON_3fVector ON_fxaxis; // (1.0, 0.0, 0.0)
extern ON_EXTERN_DECL const ON_3fVector ON_fyaxis; // (0.0, 1.0, 0.0)
extern ON_EXTERN_DECL const ON_3fVector ON_fzaxis; // (0.0, 0.0, 1.0)


#endif
@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src4/opennurbs/opennurbs_fpoint.h 4     8/15/06 3:01p A-steve $ */
d11 1
a11 1
//				
d106 1
a106 1
  void Transform( 
d198 1
a198 1
  void Transform( 
d202 1
a202 1
  void Rotate( 
d208 1
a208 1
  void Rotate( 
d262 1
a262 1
  // projective comparison 
d282 1
a282 1
  void Transform( 
d380 1
a380 1
  int IsParallelTo( 
d385 1
a385 1
        const ON_2fVector&,                 // other vector     
d393 1
a393 1
        const ON_2fVector&,                 // other vector     
d420 1
a420 1
  bool PerpendicularTo( // Result is not unitized. 
d422 1
a422 1
        const ON_2fVector& 
d426 3
a428 3
  bool PerpendicularTo( 
        const ON_2fPoint&, 
        const ON_2fPoint& 
d441 4
a444 4
float 
ON_DotProduct( 
    const ON_2fVector&, 
    const ON_2fVector& 
d448 1
a448 1
ON_3fVector 
d450 2
a451 2
    const ON_2fVector&, 
    const ON_2fVector& 
d455 1
a455 1
bool 
d462 1
a462 1
bool 
d469 1
a469 1
bool 
d512 1
a512 1
  
d557 1
a557 1
        const ON_3fVector&,                 // other vector     
d586 1
a586 1
  bool PerpendicularTo( // Result is not unitized. 
d588 1
a588 1
        const ON_3fVector& 
d593 1
a593 1
  void Transform( 
d597 1
a597 1
  void Rotate( 
d602 1
a602 1
  void Rotate( 
d618 4
a621 4
float 
ON_DotProduct( 
    const ON_3fVector&, 
    const ON_3fVector& 
d626 1
a626 1
ON_3fVector 
d628 2
a629 2
    const ON_3fVector&, 
    const ON_3fVector& 
d633 1
a633 1
ON_3fVector 
d640 2
a641 2
float 
ON_TripleProduct( 
d648 1
a648 1
float 
d656 1
a656 1
bool 
d660 1
a660 1
    const ON_3fVector&  // Z 
d664 1
a664 1
bool 
d668 1
a668 1
    const ON_3fVector&  // Z 
d672 1
a672 1
bool 
d676 1
a676 1
    const ON_3fVector&  // Z 
@

