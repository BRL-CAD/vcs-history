head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.09.14.15.21.40;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_array.h,v 1.1 2007/01/05 15:20:16 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_ARRAY_INC_)
#define ON_ARRAY_INC_

class ON_2dPointArray;
class ON_3dPointArray;
class ON_4dPointArray;

class ON_2dVectorArray;
class ON_3dVectorArray;

class ON_2fPointArray;
class ON_3fPointArray;
class ON_4fPointArray;

class ON_2fVectorArray;
class ON_3fVectorArray;

////////////////////////////////////////////////////////////////
//
// The ON_SimpleArray<> template is more efficient than the
// ON_ClassArray<> template, but ON_SimpleArray<> should not
// be used for arrays of classes that require explicit
// construction, destruction, or copy operators.
//
// By default, ON_SimpleArray<> uses onrealloc() to manage
// the dynamic array memory. If you want to use something
// besides onrealloc() to manage the array memory, then override
// ON_SimpleArray::Realloc().

template <class T> class ON_SimpleArray
{
public:
  // construction ////////////////////////////////////////////////////////

  // These constructors create an array that uses onrealloc() to manage
  // the array memory.
  ON_SimpleArray();
  ON_SimpleArray( int ); // int = initial capacity

  // Copy constructor
  ON_SimpleArray( const ON_SimpleArray<T>& );

  virtual
  ~ON_SimpleArray();

  // Assignment operator
  virtual
  ON_SimpleArray<T>& operator=( const ON_SimpleArray<T>& );

  // emergency bailout ///////////////////////////////////////////////////
  void EmergencyDestroy(void); // call only when memory used by this array
                               // may have become invalid for reasons beyond
                               // your control. EmergencyDestroy() zeros
                               // anything that could possibly cause
                               // ~ON_SimpleArray() to crash.

  // query ///////////////////////////////////////////////////////////////

	int Count() const;      // number of elements in array

	int Capacity() const;  // capacity of array

  unsigned int SizeOfArray() const; // amount of memory in the m_a[] array

  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  T& operator[]( int );              // grows array if index >= Capacity()

  const T& operator[]( int ) const;  // The const operator[] does not
                                     // check for a valid index.  Caller
                                     // is responsible for making sure
                                     // that the index is > 0 and < Capacity().

  operator T*();                     // The cast operators return a pointer
  operator const T*() const;         // to the array.  If Count() is zero,
                                     // this pointer is NULL.

  T* First();
  const T* First() const;             // returns NULL if count = 0

  T* At( int );
  const T* At( int ) const;          // returns NULL if index < 0 or index >= count

  T* Last();
  const T* Last() const;             // returns NULL if count = 0


  // array operations ////////////////////////////////////////////////////

  T& AppendNew();                    // Most efficient way to add a new element
                                     // to the array.  Increases count by 1.

  void Append( const T& );           // Append copy of element.
                                     // Increments count by 1.

  void Append( int, const T* );      // Append copy of an array T[count]


  void Insert( int, const T& );      // Insert copy of element. Uses
                                     // memmove() to perform any
                                     // necessary moving.
                                     // Increases count by 1.

  void Remove();                     // Removes last element.  Decrements
                                     // count by 1.  Does not change capacity.

  virtual
  void Remove( int );                // Removes element. Uses memmove() to
                                     // perform any necessary shifting.
                                     // Decrements count by 1.  Does not change
                                     // capacity

  void Empty();           // Sets count to 0, leaves capacity untouched.

  void Reverse();         // reverse order

  void Swap(int,int);     // swap elements i and j

  //////////
  // Search( e ) does a SLOW search of the array starting at array[0]
  // and returns the index "i" of the first element that satisfies
  // e == array[i]. (== is really memcmp()).  If the search is not
  // successful, then Search() returns -1.  For Search(T) to work
  // correctly, T must be a simple type.  Use Search(p,compare())
  // for Ts that are structs/classes that contain pointers.  Search()
  // is only suitable for performing infrequent searchs of small
  // arrays.  Sort the array and use BinarySearch() for performing
  // efficient searches.
  int Search( const T& ) const;

  //////////
  // Search( p, compare ) does a SLOW search of the array starting
  // at array[0] and returns the index "i" of the first element
  // that satisfies  compare(p,&array[i])==0.  If the search is not
  // successful, then Search() returns -1.  Search() is only suitable
  // for performing infrequent searches of small arrays.  Sort the
  // array and use BinarySearch() for performing efficient searches.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  int Search( const T*, int (*)(const T*,const T*) ) const;

  //////////
  // BinarySearch( p, compare ) does a fast search of a sorted array
  // and returns the smallest index "i" of the element that satisifies
  // 0==compare(p,&array[i]).  If the search is successful,
  // BinarySearch() returns the index of the element (>=0).
  // If the search is not successful, BinarySearch() returns -1.  Use
  // HeapSort( compare ) or QuickSort( compare ) to sort the array.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  int BinarySearch( const T*, int (*)(const T*,const T*) ) const;

  //////////
  // Sorts the array using the heap sort algorithm.
  bool HeapSort( int (*)(const T*,const T*) );

  //////////
  // Sorts the array using the quick sort algorithm.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  bool QuickSort( int (*)(const T*,const T*) );

  //////////
  // Sort() computes fills in the index[] array so that
  // array[index[i]] <= array[index[i+1]].  The array is not
  // modified
  bool Sort( ON::sort_algorithm, int* /* index[] */ , int (*)(const T*,const T*) ) const;

  /*
  Description:
    Sort() fills in the index[] array so that
    array[index[i]] <= array[index[i+1]].
    The array is not modified.

  Parameters:
    sa - [in] ON::heap_sort or  ON::quick_sort
    index - [out] an array of length Count() that is returned with
        some permutation of (0,1,...,Count()-1).
    compare - [in] compare function compare(a,b,p) should return
        <0 if a<b, 0, if a==b, and >0 if a>b.
    p - [in] pointer passed as third argument to compare.

  Returns:
    true if successful
  */
  bool Sort(
    ON::sort_algorithm, // sa
    int*, // index[]
    int (*)(const T*,const T*,void*), // int compare(const T*,const T*,void* p)
    void* // p
    ) const;

  //////////
  // Permutes the array so that output[i] = input[index[i]].
  // The index[] array should be a permutation of (0,...,Count()-1).
  bool Permute( const int* /*index[]*/ );

  //////////
  // Zeros all array memory.
  // Count and capacity are not changed.
  void Zero();

  //////////
  // Sets all bytes in array memory to value.
  // Count and capacity are not changed.
  void MemSet(unsigned char);

  // memory managment ////////////////////////////////////////////////////

  void Reserve( int );    // increase capacity to at least the requested value

  void Shrink();          // remove unused capacity

  void Destroy();         // onfree any memory and set count and capacity to zero

  // low level memory managment //////////////////////////////////////////

  // By default, ON_SimpleArray<> uses onrealloc() to manage
  // the dynamic array memory. If you want to use something
  // besides onrealloc() to manage the array memory, then override
  // Realloc(). The T* Realloc(ptr, capacity) should do the following:
  //
  // 1) If ptr and capacity are zero, return NULL.
  // 2) If ptr is NULL, an capacity > 0, allocate a memory block of
  //    capacity*sizeof(T) bytes and return a pointer to this block.
  //    If the allocation request fails, return NULL.
  // 3) If ptr is not NULL and capacity is 0, free the memory block
  //    pointed to by ptr and return NULL.
  // 4) If ptr is not NULL and capacity > 0, then reallocate the memory
  //    block and return a pointer to the reallocated block.  If the
  //    reallocation request fails, return NULL.
  //
  // NOTE WELL:
  //    Microsoft's VC 6.0 realloc() contains a bug that can cause
  //    crashes and should be avoided. See MSDN Knowledge Base article
  //    ID Q225099 for more information.
  virtual
  T* Realloc(T*,int); // (re)allocated capacity*sizeof(T) bytes

  T* Array();                         // The Array() function return the

  const T* Array() const;             // m_a pointer value.

  void SetCount( int );               // If value is <= Capacity(), then
                                      // sets count to specified value.

  void SetCapacity( int );            // Shrink/grows capacity.  If value
                                      // is < current Count(), then count
                                      // is reduced to value.
                                      //

  /*
  Returns:
     A pointer to the array and zeros out this class.
     The returned pointer is on the heap and must be
     deallocated by calling onfree().
  */
  T* KeepArray();

  /*
  Description:
    Expert user tool to set m_a = T.
  Parameters:
    T* pointer - [in]
       m_a is set to T*.  It is critical that the pointer
       be one returned by onmalloc(sz), where
       sz >= Capacity()*sizeof(T[0]);
  */
  void SetArray(T*);

protected:
  // implimentation //////////////////////////////////////////////////////
  void Move( int /* dest index*/, int /* src index */, int /* element count*/ );
	T*   m_a;        // pointer to array memory
	int  m_count;    // 0 <= m_count <= m_capacity
	int  m_capacity; // actual length of m_a[]
};


////////////////////////////////////////////////////////////////
//

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<bool>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<char>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned char>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<short>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned short>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<int>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned int>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<float>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<double>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<bool*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<char*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned char*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<short*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned short*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<int*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned int*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<float*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<double*>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2dPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3dPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_4dPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2dVector>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3dVector>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2fPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3fPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_4fPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2fVector>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3fVector>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Color>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_SurfaceCurvature>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Interval>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2dex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3dex>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_COMPONENT_INDEX>;

#pragma warning( pop )
#endif


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_2dPointArray : public ON_SimpleArray<ON_2dPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_2dPointArray();
  ON_2dPointArray(int);
  ON_2dPointArray( const ON_2dPointArray& );
  ON_2dPointArray& operator=( const ON_2dPointArray& );

  bool GetBBox( // returns true if successful
         double boxmin[2],
         double boxmax[2],
         int bGrowBox = false  // true means grow box
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_2fPointArray : public ON_SimpleArray<ON_2fPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_2fPointArray();
  ON_2fPointArray(int);
  ON_2fPointArray(const ON_2fPointArray&);
  ON_2fPointArray& operator=( const ON_2fPointArray& );

  bool GetBBox( // returns true if successful
         float boxmin[2],
         float boxmax[2],
         int bGrowBox = false  // true means grow box
         ) const;
  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_3dPointArray : public ON_SimpleArray<ON_3dPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_3dPointArray();
  ON_3dPointArray(int);
  ON_3dPointArray(const ON_SimpleArray<ON_3dPoint>&);
  ON_3dPointArray& operator=( const ON_3dPointArray& );
  ON_3dPointArray(const ON_SimpleArray<ON_3fPoint>&);
  ON_3dPointArray& operator=( const ON_SimpleArray<ON_3fPoint>& );

  // Description:
  //   Create 3d point list
  // Parameters:
  //   point_dimension - [in] dimension of input points (2 or 3)
  //   bRational - [in] true if points are in homogenous rational form
  //   point_count - [in] number of points
  //   point_stride - [in] number of doubles to skip between points
  //   points - [in] array of point coordinates
  bool Create(
    int point_dimension,
    int bRational,
    int point_count,
    int point_stride,
    const double* points
    );

  // Description:
  //   Create 3d point list
  // Parameters:
  //   point_dimension - [in] dimension of input points (2 or 3)
  //   bRational - [in] true if points are in homogenous rational form
  //   point_count - [in] number of points
  //   point_stride - [in] number of doubles to skip between points
  //   points - [in] array of point coordinates
  bool Create(
    int point_dimension,
    int bRational,
    int point_count,
    int point_stride,
    const float* points
    );

  // Description:
  //   Get 3d axis aligned bounding box.
  // Returns:
  //   3d bounding box of point list.
  ON_BoundingBox BoundingBox() const;

  // Description:
  //   Get 3d axis aligned bounding box or the union
  //   of the input box with the point list's bounding box.
  // Parameters:
  //   bbox - [in/out] 3d axis aligned bounding box
  //   bGrowBox - [in] (default=false)
  //     If true, then the union of the input bbox and the
  //     point list's bounding box is returned in bbox.
  //     If false, the point list's bounding box is returned in bbox.
  // Returns:
  //   true if successful.
  bool GetBoundingBox(
    ON_BoundingBox& bbox,
    int bGrowBox = false
    ) const;

  // Description:
  //   Get axis aligned bounding box.
  // Parameters:
  //   boxmin - [in/out] array of 3 doubles
  //   boxmax - [in/out] array of 3 doubles
  //   bGrowBox - [in] (default=false)
  //     If true, then the union of the input bounding box and the
  //     object's bounding box is returned.
  //     If false, the object's bounding box is returned.
  // Returns:
  //   true if object has bounding box and calculation was successful
  bool GetBBox(
         double boxmin[3],
         double boxmax[3],
         int bGrowBox = false
         ) const;

  /*
	Description:
    Get tight bounding box of the point list.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the
      tight bounding box of the point list.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      point list is calculated.  The point list is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid
    bounding box.
  */
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  // Description:
  //   Transform points by applying xform to each point.
  // Parameters:
  //   xform - [in] transformation matrix
  // Returns:
  //   true if successful.
  bool Transform(
    const ON_Xform& xform
    );

  // Description:
  //   Swaps point coordinate values with indices i and j.
  // Parameters:
  //   i - [in] coordinate index
  //   j - [in] coordinate index
  // Returns:
  //   true if successful.
  // Example:
  //   The call SwapCoordinates(0,2) would swap the x and z
  //   coordinates of each point in the array.
  bool SwapCoordinates(
    int i,
    int j
    );

  // Description:
  //   Rotate points about a center and axis.  A positive angle
  //   results in a counter-clockwise rotation about the axis
  //   of rotation.
  // Parameters:
  //   sin_angle - [in] sine of rotation angle
  //   cos_angle - [in] cosine of rotation angle
  //   axis_of_rotation - [in] axis of rotation
  //   center_of_rotation - [in] center (fixed point) of rotation
  // Returns:
  //   true if successful.
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  // Description:
  //   Rotate points about a center and axis.  A positive angle
  //   results in a counter-clockwise rotation about the axis
  //   of rotation.
  // Parameters:
  //   angle - [in] angle in radians.  Polsine of rotation angle
  //   cos_angle - [in] cosine of rotation angle
  //   axis_of_rotation - [in] axis of rotation
  //   center_of_rotation - [in] center (fixed point) of rotation
  // Returns:
  //   true if successful.
  bool Rotate(
        double angle_in_radians,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  // Description:
  //   Translate a polyline
  // Parameters:
  //   delta - [in] translation vectorsine of rotation angle
  // Returns:
  //   true if successful.
  bool Translate(
        const ON_3dVector& delta
        );

  /*
  Description:
    Get the index of the point in the array that is closest
    to P.
  Parameters:
    P - [in]
    closest_point_index - [out]
    maximum_distance - [in] optional distance constraint.
        If maximum_distance > 0, then only points Q with
        |P-Q| <= maximum_distance are returned.
  Returns:
    True if a point is found; in which case *closest_point_index
    is the index of the point.  False if no point is found
    or the input is not valid.
  See Also:
    ON_GetClosestPointInPointList
    ON_PointCloud::GetClosestPoint
  */
  bool GetClosestPoint(
          ON_3dPoint P,
          int* closest_point_index,
          double maximum_distance = 0.0
          ) const;

};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_3fPointArray : public ON_SimpleArray<ON_3fPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_3fPointArray();
  ON_3fPointArray(int);
  ON_3fPointArray(const ON_3fPointArray&);
  ON_3fPointArray& operator=( const ON_3fPointArray& );

  bool GetBBox(
         float boxmin[3],
         float boxmax[3],
         int bGrowBox = false
         ) const;

  bool Transform( const ON_Xform& );

  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_4dPointArray : public ON_SimpleArray<ON_4dPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_4dPointArray();
  ON_4dPointArray(int);
  ON_4dPointArray(const ON_4dPointArray&);
  ON_4dPointArray& operator=( const ON_4dPointArray& );

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_4fPointArray : public ON_SimpleArray<ON_4fPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_4fPointArray();
  ON_4fPointArray(int);
  ON_4fPointArray(const ON_4fPointArray&);
  ON_4fPointArray& operator=( const ON_4fPointArray& );

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_2dVectorArray : public ON_SimpleArray<ON_2dVector>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_2dVectorArray();
  ON_2dVectorArray(int);
  ON_2dVectorArray(const ON_2dVectorArray&);
  ON_2dVectorArray& operator=( const ON_2dVectorArray& );

  bool GetBBox(
         double boxmin[2],
         double boxmax[2],
         int bGrowBox = false
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_2fVectorArray : public ON_SimpleArray<ON_2fVector>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_2fVectorArray();
  ON_2fVectorArray(int);
  ON_2fVectorArray(const ON_2fVectorArray&);
  ON_2fVectorArray& operator=( const ON_2fVectorArray& );

  bool GetBBox(
         float boxmin[2],
         float boxmax[2],
         bool = false
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_3dVectorArray : public ON_SimpleArray<ON_3dVector>
{
public:
  ON_3dVectorArray();
  ON_3dVectorArray(int);
  ON_3dVectorArray(const ON_3dVectorArray&);
  ON_3dVectorArray& operator=( const ON_3dVectorArray& );

  bool GetBBox(
         double boxmin[3],
         double boxmax[3],
         bool bGrowBow = false
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};

/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_3fVectorArray : public ON_SimpleArray<ON_3fVector>
{
public:
  ON_3fVectorArray();
  ON_3fVectorArray(int);
  ON_3fVectorArray(const ON_3fVectorArray&);
  ON_3fVectorArray& operator=( const ON_3fVectorArray& );

  bool GetBBox(
         float boxmin[3],
         float boxmax[3],
         int bGrowBox = false
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};

////////////////////////////////////////////////////////////////
//
// The ON_ClassArray<> template is designed to be used with
// classes that require non-trivial construction or destruction.
// Any class used with the ON_ClassArray<> template must have a
// robust operator=().
//
// By default, ON_ClassArray<> uses onrealloc() to manage
// the dynamic array memory. If you want to use something
// besides onrealloc() to manage the array memory, then override
// ON_ClassArray::Realloc().  In practice this means that if your
// class has members with back-pointers, then you cannot use
// it in the defaule ON_ClassArray.  See ON_ObjectArray
// for an example.
//
template <class T> class ON_ClassArray
{
public:
  // construction ////////////////////////////////////////////////////////
  ON_ClassArray();
  ON_ClassArray( int ); // int = initial capacity

  // Copy constructor
  ON_ClassArray( const ON_ClassArray<T>& );

  virtual
  ~ON_ClassArray(); // override for struct member deallocation, etc.

  // Assignment operator
  ON_ClassArray<T>& operator=( const ON_ClassArray<T>& );

  // emergency bailout ///////////////////////////////////////////////////
  void EmergencyDestroy(void); // call only when memory used by this array
                               // may have become invalid for reasons beyond
                               // your control. EmergencyDestroy() zeros
                               // anything that could possibly cause
                               // ~ON_ClassArray() to crash.

  // query ///////////////////////////////////////////////////////////////

	int Count() const;      // number of elements in array

	int Capacity() const;  // capacity of array

  unsigned int SizeOfArray() const; // amount of memory in the m_a[] array

  T& operator[]( int );              // grows array if index >= Capacity()

  const T& operator[]( int ) const;  // The const operator[] does not
                                     // check for a valid index.  Caller
                                     // is responsible for making sure
                                     // that the index is > 0 and < Capacity().

  operator T*();                     // The cast operators return a pointer
  operator const T*() const;         // to the array.  If Count() is zero,
                                     // this pointer is NULL.
  T* First();
  const T* First() const;             // returns NULL if count = 0

  T* At( int );
  const T* At( int ) const;          // returns NULL if index < 0 or index >= count

  T* Last();
  const T* Last() const;             // returns NULL if count = 0


  // array operations ////////////////////////////////////////////////////

  T& AppendNew();                    // Most efficient way to add a new class
                                     // to the array.  Increases count by 1.

  void Append( const T& );           // Append copy of element.
                                     // Increments count by 1.

  void Append( int, const T*);       // Append copy of an array T[count]

  void Insert( int, const T& );      // Insert copy of element. Uses
                                     // memmove() to perform any
                                     // necessary moving.
                                     // Increases count by 1.

  void Remove();                     // Removes last element.  Decrements
                                     // count by 1.  Does not change capacity.

  void Remove( int );                // Removes element. Uses memmove() to
                                     // perform any necessary shifting.
                                     // Decrements count by 1.  Does not change
                                     // capacity

  void Empty();           // Sets count to 0, leaves capacity untouched.

  void Reverse();         // reverse order

  void Swap(int,int);     // swap elements i and j

  //////////
  // Search( p, compare ) does a SLOW search of the array starting
  // at array[0] and returns the index "i" of the first element
  // that satisfies  compare(p,&array[i])==0.  If the search is not
  // successful, then Search() returns -1.  Search() is only suitable
  // for performing infrequent searches of small arrays.  Sort the
  // array and use BinarySearch() for performing efficient searches.
  int Search( const T*, int (*)(const T*,const T*) ) const;

  //////////
  // BinarySearch( p, compare ) does a fast search of a sorted array
  // and returns the smallest index "i" of the element that satisifies
  // 0==compare(p,&array[i]).  If the search is successful,
  // BinarySearch() returns the index of the element (>=0).
  // If the search is not successful, BinarySearch() returns -1.  Use
  // HeapSort( compare ) or QuickSort( compare ) to sort the array.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  int BinarySearch( const T*, int (*)(const T*,const T*) ) const;

  //////////
  // Sorts the array using the heap sort algorithm.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  virtual
  bool HeapSort( int (*)(const T*,const T*) );

  //////////
  // Sorts the array using the heap sort algorithm.
  virtual
  bool QuickSort( int (*)(const T*,const T*) );

  //////////
  // Sort() computes fills in the index[] array so that
  // array[index[i]] <= array[index[i+1]].  The array is not
  // modified
  bool Sort( ON::sort_algorithm, int* /* index[] */ , int (*)(const T*,const T*) ) const;

  /*
  Description:
    Sort() fills in the index[] array so that
    array[index[i]] <= array[index[i+1]].
    The array is not modified.

  Parameters:
    sa - [in] ON::heap_sort or  ON::quick_sort
    index - [out] an array of length Count() that is returned with
        some permutation of (0,1,...,Count()-1).
    compare - [in] compare function compare(a,b,p) should return
        <0 if a<b, 0, if a==b, and >0 if a>b.
    p - [in] pointer passed as third argument to compare.

  Returns:
    true if successful
  */
  bool Sort(
    ON::sort_algorithm, // sa
    int*, // index[]
    int (*)(const T*,const T*,void*), // int compare(const T*,const T*,void* p)
    void* // p
    ) const;

  //////////
  // Permutes the array so that output[i] = input[index[i]].
  // The index[] array should be a permutation of (0,...,Count()-1).
  bool Permute( const int* /*index[]*/ );

  //////////
  // Destroys all elements and fills them with values
  // set by the defualt constructor.
  // Count and capacity are not changed.
  void Zero();

  // memory managment /////////////////////////////////////////////////

  void Reserve( int ); // increase capacity to at least the requested value

  void Shrink();       // remove unused capacity

  void Destroy();      // onfree any memory and set count and capacity to zero

  // low level memory managment ///////////////////////////////////////

  // By default, ON_ClassArray<> uses onrealloc() to manage
  // the dynamic array memory. If you want to use something
  // besides onrealloc() to manage the array memory, then override
  // Realloc(). The T* Realloc(ptr, capacity) should do the following:
  //
  // 1) If ptr and capacity are zero, return NULL.
  // 2) If ptr is NULL, an capacity > 0, allocate a memory block of
  //    capacity*sizeof(T) bytes and return a pointer to this block.
  //    If the allocation request fails, return NULL.
  // 3) If ptr is not NULL and capacity is 0, free the memory block
  //    pointed to by ptr and return NULL.
  // 4) If ptr is not NULL and capacity > 0, then reallocate the memory
  //    block and return a pointer to the reallocated block.  If the
  //    reallocation request fails, return NULL.
  //
  // NOTE WELL:
  //    Microsoft's VC 6.0 realloc() contains a bug that can cause
  //    crashes and should be avoided. See MSDN Knowledge Base article
  //    ID Q225099 for more information.
  virtual
  T* Realloc(T*,int); // (re)allocated capacity*sizeof(T) bytes

  T* Array();                         // The Array() function return the

  const T* Array() const;             // m_a pointer value.

  void SetCount( int );               // If value is <= Capacity(), then
                                      // sets count to specified value.

  void SetCapacity( int );            // Shrink/grows capacity.  If value
                                      // is < current Count(), then count
                                      // is reduced to value.

  T* KeepArray();                     // returns pointer to array and zeros
                                      // out this class.  Caller is responsible
                                      // for calling destructor on each element
                                      // and then using onfree() to release array
                                      // memory.  E.g.,
                                      //
                                      //   for (int i=capacity;i>=0;i--) {
                                      //     array[i].~T();
                                      //   }
                                      //   onfree(array);

  /*
  Description:
    Expert user tool to set m_a = T.
  Parameters:
    T* pointer - [in]
       m_a is set to T*.  It is critical that the pointer
       be one returned by onmalloc(sz), where
       sz >= Capacity()*sizeof(T[0]);
  */
  void SetArray(T*);

protected:
  // implimentation //////////////////////////////////////////////////////
  void Move( int /* dest index*/, int /* src index */, int /* element count*/ );
  void ConstructDefaultElement(T*);
  void DestroyElement(T&);
	T*   m_a;        // pointer to array memory
	int  m_count;    // 0 <= m_count <= m_capacity
	int  m_capacity; // actual length of m_a[]
};


/*
Description:
  ON_Object array is used to store lists of classes that are
  derived from ON_Object.  It differs from ON_ClassArray in
  that the virtual ON_Object::MemoryRelocate function is called
  when growing the dynamic array requires changing the location
  of the memory buffer used to store the elements in the array.
*/
template <class T> class ON_ObjectArray : public ON_ClassArray<T>
{
public:
  ON_ObjectArray();
  ~ON_ObjectArray(); // override for struct member deallocation, etc.
  ON_ObjectArray( int ); // int = initial capacity
  ON_ObjectArray( const ON_ObjectArray<T>& );
  ON_ObjectArray<T>& operator=( const ON_ObjectArray<T>& );

  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  // virtual ON_ClassArray<T> override that
  // calls MemoryRelocate on each element after
  // the reallocation.
  T* Realloc(T*,int);

  // virtual ON_ClassArray<T> override that
  // calls MemoryRelocate on each element after
  // the heap sort.
  bool HeapSort( int (*)(const T*,const T*) );

  // virtual ON_ClassArray<T> override that
  // calls MemoryRelocate on each element after
  // the quick sort.
  bool QuickSort( int (*)(const T*,const T*) );
};

class ON_CLASS ON_UuidPair
{
public:
  /*
  Description:
    Compares m_uuid[0] and ignores m_uuid[1]
  */
  static
  int CompareFirstUuid(const class ON_UuidPair*,const class ON_UuidPair*);

  /*
  Description:
    Compares m_uuid[1] and ignores m_uuid[0]
  */
  static
  int CompareSecondUuid(const class ON_UuidPair*,const class ON_UuidPair*);

  /*
  Description:
    Compares m_uuid[0] first and then m_uuid[1].
  */
  static
  int Compare(const class ON_UuidPair*,const class ON_UuidPair*);

  ON_UuidPair();
  ON_UUID m_uuid[2];
};

#if defined(ON_DLL_TEMPLATE)

// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_UUID>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_UuidIndex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_DisplayMaterialRef>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_LinetypeSegment>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_UuidPair>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_PlaneEquation>;
#pragma warning( pop )

#endif


/*
Description:
  The ON_UuidList class provides a tool to efficiently
  maintain a list of uuids and determine if a uuid is
  in the list. This class is based on the premise that
  there are no duplicate uuids in the list.
*/
class ON_CLASS ON_UuidList : private ON_SimpleArray<ON_UUID>
{
public:
  ON_UuidList();
  ON_UuidList(int capacity);
  ~ON_UuidList();
  ON_UuidList(const ON_UuidList& src);
  ON_UuidList& operator=(const ON_UuidList& src);

  /*
  Description:
    Fast uuid compare.  Not necessarily the same
    as ON_UuidCompare().
  */
  static
  int CompareUuid( const ON_UUID* a, const ON_UUID* b );

  /*
  Returns:
    Number of active uuids in the list.
  */
  int Count() const;

  /*
  Returns:
    Array of uuids in the list.  Sorted with
    respect to ON_UuidList::CompareUuid().
  Remarks:
    Calling AddUuid() may grow the dynamic array
    and make the pointer invalid.
  */
  const ON_UUID* Array() const;

  /*
  Description:
    Provides an efficient way to empty a list so that it
    can be used again.
  */
  void Empty();

  /*
  Description:
    Destroy list.  If list will be reused, Empty() is more
    efficient.
  */
  void Destroy();

  void Reserve(int capacity);

  /*
  Description:
    Makes the uuid list as efficent as possible in both search
    speed and memory usage.  Use Compact() when a uuid list
    will be in use but is not likely to be modifed.  A list
    that has been compacted can still be modified.
  */
  void Compact();

  /*
  Description:
    Adds a uuid to the list.
  Parameters:
    uuid - [in] id to add.
    bCheckForDupicates - [in] if true, then the uuid
       is not added if it is already in the list.
       If you are certain that the uuid is not in the
       list and you are going to have a large list of uuids,
       then setting bCheckForDupicates=false will
       speed up the addition of uuids.
  Returns:
    True if uuid was added.  False if uuid was not added
    because it is already in the collection.
  */
  bool AddUuid(ON_UUID uuid, bool bCheckForDupicates=true);

  /*
  Description:
    Removes a uuid from the list.
  Parameters:
    uuid - [in] id to remove
  Returns:
    True if uuid was in the list and was removed.
    False if uuid was not in the list.
  */
  bool RemoveUuid(ON_UUID uuid);

  /*
  Description:
    Determine if a uuid is in the list.
  Returns:
    True if uuid is in the list.
  */
  bool FindUuid(ON_UUID uuid) const;

  /*
  Description:
    Saves the uuid list in an archive.
  Parameters:
    archive - [in] archive to write to.
  Returns:
    true if write was successful.
  */
  bool Write(
    class ON_BinaryArchive& archive
    ) const;

  /*
  Description:
    Read the uuid list from an archive.
  Parameters:
    archive - [in] archive to read from.
  Returns:
    true if the read was successful.
  */
  bool Read(
    class ON_BinaryArchive& archive
    );

  /*
  Description:
    Append the uuids in this class to uuid_list.
  Parameters:
    uuid_list - [in/out]
  Returns:
    Number of uuids added to uuid_list.
  */
  int GetUuids(
     ON_SimpleArray<ON_UUID>& uuid_list
     ) const;

  /*
  Description:
    This tool is used in rare situations when the object ids
    stored in the uuid list need to be remapped.
  Parameters:
    uuid_remap - [in]
      Is it critical that uuid_remap[] be sorted with respect
      to ON_UuidPair::CompareFirstUuid.
  */
  void RemapUuids(
    const ON_SimpleArray<ON_UuidPair>& uuid_remap
    );

private:
  void SortHelper();
  ON_UUID* SearchHelper(const ON_UUID*) const;
  int m_sorted_count;
  int m_removed_count;
};

/*
Description:
  The ON_UuidList class provides a tool
  to efficiently maintain a list of uuid-index
  pairs and determine if a uuid is in the list.
  This class is based on the premise that there are
  no duplicate uuids in the list.
*/
class ON_CLASS ON_UuidIndexList : private ON_SimpleArray<ON_UuidIndex>
{
public:
  ON_UuidIndexList();
  ON_UuidIndexList(int capacity);
  ~ON_UuidIndexList();
  ON_UuidIndexList(const ON_UuidIndexList& src);
  ON_UuidIndexList& operator=(const ON_UuidIndexList& src);

  /*
  Returns:
    Number of active uuids in the list.
  */
  int Count() const;

  /*
  Description:
    Provides an efficient way to empty a list so that it
    can be used again.
  */
  void Empty();

  void Reserve( int capacity );

  /*
  Description:
    Adds a uuid-index pair to the list.
  Parameters:
    uuid - [in] id to add.
    bCheckForDupicates - [in] if true, then the uuid
       is not added if it is already in the list.
       If you are certain that the uuid is not in the list
       and you have a have a large collection of uuids,
       then setting bCheckForDupicates=false will
       speed up the addition of uuids.
  Returns:
    True if uuid was added.  False if uuid was not added
    because it is already in the collection.
  */
  bool AddUuidIndex(
    ON_UUID uuid,
    int index,
    bool bCheckForDupicates=true);

  /*
  Description:
    Removes an element with a matching uuid from the list.
  Parameters:
    uuid - [in] id to remove
  Returns:
    True if an element was removed.  False if the uuid
    was not in the list.
  */
  bool RemoveUuid(
    ON_UUID uuid
    );

  /*
  Description:
    Removes every element with a matching uuid-index pair from
    the list.
  Parameters:
    uuid - [in] id to remove
    index - [in] index value
  Returns:
    True if an element was removed.  False if the uuid-index
    pair does not appear in the list.
  */
  bool RemoveUuidIndex(
    ON_UUID uuid,
    int index
    );

  /*
  Description:
    Determine if an element with a uuid is in the list.
  Parameters:
    index - [out] if not NULL and a matching uuid is found,
       then *index is set to the value of the index.
  Returns:
    True if an element was found.  Returns false if
    the uuid is not in the list.
  */
  bool FindUuid(ON_UUID uuid, int* index=NULL) const;

  /*
  Description:
    Determine if a uuid-index pair is in the list.
  Returns:
    True if the uuid-index pair is in the list.
    Returns false if the uuid-index pair is not
    in the list.
  */
  bool FindUuidIndex(ON_UUID uuid, int index) const;

  /*
  Description:
    Saves the uuid-index list in an archive.
  Parameters:
    archive - [in] archive to write to.
  Returns:
    true if write was successful.
  */
  bool Write(
    class ON_BinaryArchive& archive
    ) const;

  /*
  Description:
    Read the uuid-index list from an archive.
  Parameters:
    archive - [in] archive to read from.
  Returns:
    true if the read was successful.
  */
  bool Read(
    class ON_BinaryArchive& archive
    );

  /*
  Description:
    Append the uuids in this class to uuid_list.
  Parameters:
    uuid_list - [in/out]
  Returns:
    Number of uuids added to uuid_list.
  */
  int GetUuids(
     ON_SimpleArray<ON_UUID>& uuid_list
     ) const;


private:
  ON_UuidIndex* SearchHelper(const ON_UUID*) const;
  int m_sorted_count;
  int m_removed_count;
};

class ON_CLASS ON_2dexMap : private ON_SimpleArray<ON_2dex>
{
public:
  ON_2dexMap();
  ON_2dexMap(int capacity);
  ~ON_2dexMap();

  int Count() const;

  void Reserve(int capacity);

  const ON_2dex* Array() const;

  ON_2dex operator[](int i) const;

  /*
  Description:
    Creates an index map with the values
    (i0,j),...,(i0+count-1,j)
  Parameters:
    count - [in]
       number of elements
    i0 - [in]
       i value of first element
    j - [in]
       j value for all elements
  */
  void Create(int count, int i0, int j);

  /*
  Description:
    Searches for an element with a matching i
    and returns its j value.  If no matching
    element is found, then not_found_rc is returned.
  Parameters:
    i - [in]
       value of i to search for
    not_found_rc - [in]
       value to return if there is not a match.
  Returns:
    j value
  */
  int FindIndex(
          int i,
          int not_found_rc
          ) const;

  /*
  Description:
    Adds and element (i,j).  If there is already an entry with
    value (i,*), then no element is added.
  Parameters:
    i - [in]
    i - [in]
  Returns:
    True if and element it added.
  */
  bool AddIndex(
          int i,
          int j
          );

  /*
  Description:
    Searches for an element (i,*) and sets its j value to j.
    If there is no element with a matching i, then false
    is returned.
  Parameters:
    i - [in]
    j - [in]
  Returns:
    True if and element exists and was set.
  */
  bool SetIndex(
          int i,
          int j
          );

  /*
  Description:
    If an element (i,*) exists, its j value is set.  Otherwise
    a new element with value (i,j) is added.
  Parameters:
    i - [in]
    j - [in]
  */
  void SetOrAddIndex(
          int i,
          int j
          );

  /*
  Description:
    If an element (i,*) exists, it is removed.  If there is
    not an element with a matching i value, then false
    is returned.
  Parameters:
    i - [in]
  Returns:
    True if the element was removed
  */
  bool RemoveIndex(
          int i
          );

  const ON_2dex* Find2dex(int i) const;

private:
  bool m_bSorted;
};

/*
Description:
	Compare function for Sort and Search methods.
Returns:
   -1 if *a < *b is true
    1 if *b < *a is true
    0 if niether *a <*b nor *b<*a is true
Details:
	Use this template functions to sort ON_SimpleArray and
  ON_ClassArray objects into increasing order.  The elements
  of the arrays must be a type with an operator < defined.
	In particular it works with built in types like double,
  int and pointers.
Example:

          ON_SimpleArray<int> A;
          A = ...;
          // Sort A in increasing order
          A.QuickSort( ON_CompareIncreasing<double> );

See Also:
  ON_CompareDecreasing
*/
template< class T>
int ON_CompareIncreasing( const T* a, const T* b);

/*
Description:
	Compare function for Sort and Search methods.
Returns:
   -1 if *b < *a is true
    1 if *a < *b is true
    0 if niether *a < *b nor *b < *a is true
Details:
	Use this template functions to sort ON_SimpleArray and
  ON_ClassArray objects into decreasing order.  The elements
  of the arrays must be a type with an operator < defined.
	In particular it works with built in types like double,
  int and pointers.
Example:

          class C
          {
          public:
            ...
            bool operator<(const C&) const;
          };
          ...
          ON_ClassArray<C> A;
          A = ...;
          // Sort A in descrasing order
          A.QuickSort( ON_CompareDecreasing<C> );

See Also:
  ON_CompareIncreasing
*/
template< class T>
int ON_CompareDecreasing( const T* a, const T* b);


// definitions of the template functions are in a different file
// so that Microsoft's developer studio's autocomplete utility
// will work on the template functions.
#include "opennurbs_array_defs.h"


#endif
@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src4/opennurbs/opennurbs_array.h 24    12/06/06 8:49a Dalelear $ */
d11 1
a11 1
//				
d42 1
a42 1
// the dynamic array memory. If you want to use something 
d65 1
a65 1
  
d74 1
a74 1
  
d76 1
a76 1
	
d103 1
a103 1
  
d106 1
a106 1
  T& AppendNew();                    // Most efficient way to add a new element 
d137 3
a139 3
  // and returns the index "i" of the first element that satisfies 
  // e == array[i]. (== is really memcmp()).  If the search is not 
  // successful, then Search() returns -1.  For Search(T) to work 
d142 1
a142 1
  // is only suitable for performing infrequent searchs of small 
d149 1
a149 1
  // at array[0] and returns the index "i" of the first element 
d160 1
a160 1
  // 0==compare(p,&array[i]).  If the search is successful, 
d180 1
a180 1
  bool Sort( ON::sort_algorithm, int* /* index[] */ , int (*)(const T*,const T*) ) const; 
d184 3
a186 3
    Sort() fills in the index[] array so that 
    array[index[i]] <= array[index[i+1]].  
    The array is not modified.  
d191 1
a191 1
        some permutation of (0,1,...,Count()-1). 
d199 1
a199 1
  bool Sort( 
d201 1
a201 1
    int*, // index[] 
d204 1
a204 1
    ) const; 
d212 1
a212 1
  // Zeros all array memory. 
d217 1
a217 1
  // Sets all bytes in array memory to value. 
d219 2
a220 2
  void MemSet(unsigned char); 
  
d228 1
a228 1
    
d232 2
a233 2
  // the dynamic array memory. If you want to use something 
  // besides onrealloc() to manage the array memory, then override 
d237 1
a237 1
  // 2) If ptr is NULL, an capacity > 0, allocate a memory block of 
d243 1
a243 1
  //    block and return a pointer to the reallocated block.  If the 
d246 1
a246 1
  // NOTE WELL: 
d253 2
a254 2
  T* Array();                         // The Array() function return the 
  
d275 1
a275 1
    Expert user tool to set m_a = T. 
d298 1
a298 1
// handles templates and DLLs.  See Microsoft's knowledge base 
d439 1
a439 1
  // Description: 
d450 3
a452 3
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bbox and the 
  //     point list's bounding box is returned in bbox.  
d456 1
a456 1
  bool GetBoundingBox( 
d466 2
a467 2
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bounding box and the 
d483 1
a483 1
		bGrowBox -[in]	(default=false)			
d485 1
a485 1
      tight_bbox is the union of the input tight_bbox and the 
d491 1
a491 1
    True if the returned tight_bbox is set to a valid 
d494 2
a495 2
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
d506 2
a507 2
  bool Transform( 
    const ON_Xform& xform 
d588 1
a588 1
  bool GetClosestPoint( 
d751 1
a751 1
// the dynamic array memory. If you want to use something 
d762 1
a762 1
  ON_ClassArray(); 
d773 1
a773 1
  
d782 1
a782 1
  
d784 1
a784 1
	
d808 1
a808 1
  
d811 1
a811 1
  T& AppendNew();                    // Most efficient way to add a new class 
d840 1
a840 1
  // at array[0] and returns the index "i" of the first element 
d850 1
a850 1
  // 0==compare(p,&array[i]).  If the search is successful, 
d872 1
a872 1
  bool Sort( ON::sort_algorithm, int* /* index[] */ , int (*)(const T*,const T*) ) const; 
d876 3
a878 3
    Sort() fills in the index[] array so that 
    array[index[i]] <= array[index[i+1]].  
    The array is not modified.  
d883 1
a883 1
        some permutation of (0,1,...,Count()-1). 
d891 1
a891 1
  bool Sort( 
d893 1
a893 1
    int*, // index[] 
d896 1
a896 1
    ) const; 
d916 1
a916 1
    
d920 2
a921 2
  // the dynamic array memory. If you want to use something 
  // besides onrealloc() to manage the array memory, then override 
d925 1
a925 1
  // 2) If ptr is NULL, an capacity > 0, allocate a memory block of 
d931 1
a931 1
  //    block and return a pointer to the reallocated block.  If the 
d934 1
a934 1
  // NOTE WELL: 
d941 2
a942 2
  T* Array();                         // The Array() function return the 
  
d965 1
a965 1
    Expert user tool to set m_a = T. 
d996 1
a996 1
  ON_ObjectArray(); 
d1004 1
a1004 1
  // virtual ON_ClassArray<T> override that 
d1009 1
a1009 1
  // virtual ON_ClassArray<T> override that 
d1014 1
a1014 1
  // virtual ON_ClassArray<T> override that 
d1027 1
a1027 1
  static 
d1034 1
a1034 1
  static 
d1041 1
a1041 1
  static 
d1051 1
a1051 1
// handles templates and DLLs.  See Microsoft's knowledge base 
d1068 3
a1070 3
  The ON_UuidList class provides a tool to efficiently 
  maintain a list of uuids and determine if a uuid is 
  in the list. This class is based on the premise that 
d1126 1
a1126 1
    will be in use but is not likely to be modifed.  A list 
d1175 2
a1176 2
  bool Write( 
    class ON_BinaryArchive& archive 
d1187 2
a1188 2
  bool Read( 
    class ON_BinaryArchive& archive 
d1205 1
a1205 1
    This tool is used in rare situations when the object ids 
d1212 2
a1213 2
  void RemapUuids( 
    const ON_SimpleArray<ON_UuidPair>& uuid_remap 
d1271 2
a1272 2
    ON_UUID uuid, 
    int index, 
d1334 2
a1335 2
  bool Write( 
    class ON_BinaryArchive& archive 
d1346 2
a1347 2
  bool Read( 
    class ON_BinaryArchive& archive 
d1402 1
a1402 1
    element is found, then not_found_rc is returned. 
d1411 2
a1412 2
  int FindIndex( 
          int i, 
d1426 2
a1427 2
  bool AddIndex( 
          int i, 
d1442 2
a1443 2
  bool SetIndex( 
          int i, 
d1455 2
a1456 2
  void SetOrAddIndex( 
          int i, 
d1470 1
a1470 1
  bool RemoveIndex( 
d1480 1
a1480 1
/* 
d1486 1
a1486 1
    0 if niether *a <*b nor *b<*a is true 
d1491 1
a1491 1
	In particular it works with built in types like double, 
d1498 1
a1498 1
          A.QuickSort( ON_CompareIncreasing<double> );		
d1506 1
a1506 1
/* 
d1512 1
a1512 1
    0 if niether *a < *b nor *b < *a is true 
d1517 1
a1517 1
	In particular it works with built in types like double, 
d1531 1
a1531 1
          A.QuickSort( ON_CompareDecreasing<C> );		
@

