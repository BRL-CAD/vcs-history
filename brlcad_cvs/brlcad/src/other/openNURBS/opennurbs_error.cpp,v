head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@// @;


1.2
date	2007.09.14.15.21.40;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.24;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_error.cpp,v 1.1 2007/01/05 15:20:24 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#include "opennurbs.h"

// openNURBS Geometry Library Errors and Warnings
//
//   If an error condition occurs during a openNURBS Geometry Library
//   computation, the ON_Error() function is called, the computation is
//   stopped, and an error code (negative integer ) is returned.  If a
//   warning condition occurs during a Trout Lake Geometry Library
//   computation, the ON_Warning() function is called and the computation
//   continues.
//
//   ON_GetErrorCount()
//   ON_GetWarningCount()
//   ON_Error()
//   ON_Warning()
//

static int ON_ERROR_COUNT = 0;
static int ON_WARNING_COUNT = 0;

// 0 = no break
// 1 = break on errors, warnings, and asserts
#if defined(ON_DEBUG)

// debug build defaults
static int ON_DEBUG_BREAK_OPTION = 0;
static int ON_DEBUG_ERROR_MESSAGE_OPTION = 1;

#else

// release build defaults
static int ON_DEBUG_BREAK_OPTION = 0;
static int ON_DEBUG_ERROR_MESSAGE_OPTION = 0;

#endif


int ON_GetErrorCount(void)
{
  return ON_ERROR_COUNT;
}


int ON_GetWarningCount(void)
{
  return ON_WARNING_COUNT;
}


int ON_GetDebugBreak(void)
{
  return ON_DEBUG_BREAK_OPTION?true:false;
}


void ON_EnableDebugBreak( int bEnableDebugBreak )
{
  ON_DEBUG_BREAK_OPTION = bEnableDebugBreak ? 1 : 0;
}


int ON_GetDebugErrorMessage(void)
{
  return ON_DEBUG_ERROR_MESSAGE_OPTION?true:false;
}


void ON_EnableDebugErrorMessage( int bEnableDebugErrorMessage )
{
  ON_DEBUG_ERROR_MESSAGE_OPTION = bEnableDebugErrorMessage ? 1 : 0;
}

// The sMessage[] string is used by ON_Error()
// and ON_Warning() to hold the message.  The static function
// ON_FormatMessage() is used to do most of the actual formatting.
// When ON_DEBUG is defined, the "PRINT_STRING" macro is used to
// print the formatted string.

#define MAX_MSG_LENGTH 2048
static char sMessage[MAX_MSG_LENGTH];
static int FormatMessage(const char*, va_list );


void ON_DebugBreak()
{
  if ( ON_DEBUG_BREAK_OPTION )
  {
    // Dear Rhino Developer:
    //   If you find this annoying, then look at the call stack,
    //   figure out why this happening, create an RR item,
    //   and then run the TestErrorCheck DebugBreak=No.
#if defined(ON_COMPILER_MSC)
    ::DebugBreak(); // Windows debug break
#endif
  }
}


void ON_Error(const char* sFileName, int line_number,
              const char* sFormat, ...)
{
  int bPrintMessage = FALSE;
  int rc = 0;
  ON_ERROR_COUNT++; // <- Good location for a debugger breakpoint.
  sMessage[0] = 0;

  if (ON_DEBUG_ERROR_MESSAGE_OPTION)
  {
    // put file and line number info for debug mode
    sprintf(sMessage,"openNURBS ERROR # %d %s:%d ",ON_ERROR_COUNT,sFileName,line_number);
    bPrintMessage = TRUE;
  }

  if ( bPrintMessage ) {
    if (sFormat)  {
      // append formatted error message to sMessage[]
      va_list args;
      va_start(args, sFormat);
      rc = FormatMessage(sFormat,args);
      va_end(args);
    }
    if (!rc && bPrintMessage ) {
      ON_ErrorMessage(1,sMessage);
    }
  }

  ON_DebugBreak();
}


void ON_Warning(const char* sFileName, int line_number,
                const char* sFormat, ...)
{
  int bPrintMessage = FALSE;
  int rc = 0;
  ON_WARNING_COUNT++; // <- Good location for a debugger breakpoint.
  sMessage[0] = 0;

  if (ON_DEBUG_ERROR_MESSAGE_OPTION)
  {
    // put file and line number info for debug mode
    sprintf(sMessage,"openNURBS WARNING # %d %s:%d ",ON_ERROR_COUNT,sFileName,line_number);
    bPrintMessage = TRUE;
  }

  if ( bPrintMessage ) {
    if (sFormat)  {
      // append formatted error message to sMessage[]
      va_list args;
      va_start(args, sFormat);
      rc = FormatMessage(sFormat,args);
      va_end(args);
    }
    if (!rc && bPrintMessage ) {
      ON_ErrorMessage(0,sMessage);
    }
  }

  ON_DebugBreak();
}


void ON_Assert(int bCondition,
               const char* sFileName, int line_number,
               const char* sFormat, ...)
{
  if ( !bCondition )
  {
    int bPrintMessage = FALSE;
    int rc = 0;
    ON_ERROR_COUNT++; // <- Good location for a debugger breakpoint.
    sMessage[0] = 0;

    if (ON_DEBUG_ERROR_MESSAGE_OPTION)
    {
      // put file and line number info for debug mode
      sprintf(sMessage,"openNURBS ON_Assert ERROR # %d %s:%d ",ON_ERROR_COUNT,sFileName,line_number);
      bPrintMessage = TRUE;
    }

    if ( bPrintMessage ) {
      if (sFormat)  {
        // append formatted error message to sMessage[]
        va_list args;
        va_start(args, sFormat);
        rc = FormatMessage(sFormat,args);
        va_end(args);
      }
      if (!rc && bPrintMessage ) {
        ON_ErrorMessage(2,sMessage);
      }
    }

    ON_DebugBreak();
  }
}


static int FormatMessage(const char* format, va_list args)
{
  // appends formatted message to sMessage[]
  int len = ((int)strlen(sMessage));
  if (len < 0 )
    return -1;
  if (MAX_MSG_LENGTH-1-len < 2)
    return -1;
  sMessage[MAX_MSG_LENGTH-1] = 0;
  on_vsnprintf(sMessage+len, MAX_MSG_LENGTH-1-len, format, args);
  return 0;
}

@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src4/opennurbs/opennurbs_error.cpp 9     9/06/06 1:54p Dalelear $ */
d11 1
a11 1
//				
d24 1
a24 1
//   warning condition occurs during a Trout Lake Geometry Library 
d42 2
a43 2
static int ON_DEBUG_BREAK_OPTION = 0; 
static int ON_DEBUG_ERROR_MESSAGE_OPTION = 1; 
d48 2
a49 2
static int ON_DEBUG_BREAK_OPTION = 0; 
static int ON_DEBUG_ERROR_MESSAGE_OPTION = 0; 
d56 2
a57 2
  return ON_ERROR_COUNT;	
}	
d62 2
a63 2
  return ON_WARNING_COUNT;	
}	
d90 3
a92 3
// and ON_Warning() to hold the message.  The static function 
// ON_FormatMessage() is used to do most of the actual formatting.  
// When ON_DEBUG is defined, the "PRINT_STRING" macro is used to 
d115 1
a115 1
void ON_Error(const char* sFileName, int line_number, 
d138 1
a138 1
    if (!rc && bPrintMessage ) { 
d147 1
a147 1
void ON_Warning(const char* sFileName, int line_number, 
d180 1
a180 1
               const char* sFileName, int line_number, 
d183 1
a183 1
  if ( !bCondition ) 
d205 1
a205 1
      if (!rc && bPrintMessage ) { 
d226 1
a226 1
}	
@

