head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.09.14.15.21.44;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.27;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_intersect.h,v 1.1 2007/01/05 15:20:27 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_INTERSECT_INC_)
#define ON_INTERSECT_INC_

// These simple intersectors are fast and detect transverse intersections.
// If the intersection is not a simple transverse case, then they
// return FALSE and you will have to use one of the slower but fancier
// models.


/*
Description:
  Intersect two lines.
Parameters:
  lineA - [in]
  lineB - [in]
  double* a - [out]
  double* b - [out] The shortest distance between the lines is the
                   chord from lineA.PointAt(*a) to lineB.PointAt(*b).
  tolerance - [in] If > 0.0, then an intersection is reported only
                   if the distance between the points is <= tolerance.
                   If <= 0.0, then the closest point between the lines
                   is reported.
  bIntersectSegments - [in] if true, the input lines are treated
                           as finite segments.  If false, the
                           input lines are treated as infinite lines.
Returns:
  True if a closest point can be calculated and the result passes
  the tolerance parameter test.
See Also:
  ON_Intersect( const ON_Line& lineA, const ON_Line& line B)
Remarks:
  If the lines are exactly parallel, meaning the system of equations
  used to find a and b has no numerical solution, then false is returned.
  If the lines are nearly parallel, which is often numerically true
  even if you think the lines look exactly parallel, then the
  closest points are found and true is returned.  So, if you
  care about weeding out "parallel" lines, then you need to
  do something like the following.

          bool rc = ON_IntersectLineLine(lineA,lineB,
                                         &a,&b,
                                         tolerance,
                                         bIntersectSegments);
          if (rc)
          {
            double angle_tolerance_radians = 0.5*ON_PI/180.0; // or whatever
            double parallel_tol = cos(angle_tolerance_radians);
            if ( fabs(lineA.Tangent()*lineB.Tangent()) >= parallel_tol )
            {
              ... do whatever you think is appropriate
            }
          }
*/
ON_DECL
bool ON_IntersectLineLine(
          const ON_Line& lineA,
          const ON_Line& lineB,
          double* a,
          double* b,
          double tolerance,
          bool bIntersectSegments
          );

/*
Description:
  Find the closest point between two infinte lines.
Parameters:
  lineA - [in]
  lineB - [in]
  double* a - [out]
  double* b - [out] The shortest distance between the lines is the
                   chord from lineA.PointAt(*a) to lineB.PointAt(*b).
Returns:
  True if points are found and false if the lines are numerically parallel.
  Numerically parallel means the 2x2 matrix

            AoA  -AoB
           -AoB   BoB

 is numerically singluar, where A = lineA.to-lineA.from
 and B = lineB.to-lineB.from.
See Also:
  ON_IntersectLineLine
*/
ON_DECL
bool ON_Intersect(
          const ON_Line& lineA,
          const ON_Line& lineB,
          double* a,
          double* b
          );

ON_DECL
bool ON_Intersect( // Returns FALSE unless intersection is a single point
                   // If returned parameter is < 0 or > 1, then the line
                   // segment between line.m_point[0] and line.m_point[1]
                   // does not intersect the plane
          const ON_Line&,
          const ON_Plane&,
          double* // parameter on line
          );

ON_DECL
bool ON_Intersect( const ON_Plane&,
                  const ON_Plane&,
                   ON_Line& // intersection line is returned here
                   );

ON_DECL
bool ON_Intersect( const ON_Plane&,
                  const ON_Plane&,
                  const ON_Plane&,
                  ON_3dPoint& // intersection point is returned here
                  );

ON_DECL
int ON_Intersect( // returns 0 = no intersections,
                  // 1 = intersection = single point,
                  // 2 = intersection = circle
                  // If 0 is returned, returned circle has radius=0
                  // and center = point on sphere closest to plane.
                  // If 1 is returned, intersection is a single
                  // point and returned circle has radius=0
                  // and center = intersection point on sphere.
                 const ON_Plane&, const ON_Sphere&, ON_Circle&
                  );

ON_DECL
int ON_Intersect( // returns 0 = no intersections,
                  // 1 = one intersection,
                  // 2 = 2 intersections
                  // If 0 is returned, first point is point
                  // on line closest to sphere and 2nd point is the point
                  // on the sphere closest to the line.
                  // If 1 is returned, first point is obtained by evaluating
                  // the line and the second point is obtained by evaluating
                  // the sphere.
                 const ON_Line&, const ON_Sphere&,
                  ON_3dPoint&, ON_3dPoint& // intersection point(s) returned here
                  );

ON_DECL
int ON_Intersect( // returns 0 = no intersections,
                  // 1 = one intersection,
                  // 2 = 2 intersections
                  // 3 = line lies on cylinder
                  // If 0 is returned, first point is point
                  // on line closest to cylinder and 2nd point is the point
                  // on the sphere closest to the line.
                  // If 1 is returned, first point is obtained by evaluating
                  // the line and the second point is obtained by evaluating
                  // the sphere.
                  const ON_Line&, const ON_Cylinder&,
                  ON_3dPoint&, ON_3dPoint& // intersection point(s) returned here
                  );

/*
Description:
  Intersect an infinite line and an axis aligned bounding box.
Parameters:
  bbox - [in]
  line - [in]
  tolerance - [in]  If tolerance > 0.0, then the intersection is
                   performed against a box that has each side
                   moved out by tolerance.
  line_parameters - [out] The chord from line.PointAt(line_parameters[0])
     to line.PointAt(line_parameters[1]) is the intersection.
Returns:
  True if the line intersects the box and false otherwise.
*/
ON_DECL
bool ON_Intersect( const ON_BoundingBox& bbox,
                   const ON_Line& line,
                   double tolerance,
                   ON_Interval* line_parameters
                   );
#endif
@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src4/opennurbs/opennurbs_intersect.h 3     2/10/05 10:09a Dalelear $ */
d11 1
a11 1
//				
d72 2
a73 2
          const ON_Line& lineA, 
          const ON_Line& lineB, 
d96 1
a96 1
 is numerically singluar, where A = lineA.to-lineA.from 
d103 2
a104 2
          const ON_Line& lineA, 
          const ON_Line& lineB, 
d114 2
a115 2
          const ON_Line&, 
          const ON_Plane&, 
d120 2
a121 2
bool ON_Intersect( const ON_Plane&, 
                  const ON_Plane&, 
d126 2
a127 2
bool ON_Intersect( const ON_Plane&, 
                  const ON_Plane&, 
d133 2
a134 2
int ON_Intersect( // returns 0 = no intersections, 
                  // 1 = intersection = single point, 
d145 2
a146 2
int ON_Intersect( // returns 0 = no intersections, 
                  // 1 = one intersection, 
d148 1
a148 1
                  // If 0 is returned, first point is point 
d159 2
a160 2
int ON_Intersect( // returns 0 = no intersections, 
                  // 1 = one intersection, 
d163 1
a163 1
                  // If 0 is returned, first point is point 
d188 2
a189 2
bool ON_Intersect( const ON_BoundingBox& bbox, 
                   const ON_Line& line, 
@

