head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.09.14.15.21.44;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.35;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_optimize.h,v 1.1 2007/01/05 15:20:35 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_OPTIMIZE_INC_)
#define OPENNURBS_OPTIMIZE_INC_

// find a local minimum of a 1 parameter function
BOOL ON_FindLocalMinimum( // returns 0 - failed to converge, 1 - success, 2 - failed to converge to requested tolerances
        int (*)(void*,double,double*,double*), // f(void*, double t, double* value, double* derivative );
        void*, // passed as the void* argument to the above function
        double, double, double, // ax,bx,cx, 3 abcissa  ax<bx<cx or ax>bx>cx, and
                                // f(bx) < f(ax), and f(bx) < f(cx)
        double, // tol > 0 (minimum relative step size (use ON_EPSILON when in doubt)
        double, // zeps > 0 (minimum absolute step size (use 1/2*(desired absolute precision))
        int,     // maximum number of iterations ( use 100 when in doubt)
        double*  // abcissa of local minimum returned here
        );

// find a local zero of a 1 parameter function
class ON_LocalZero1
{
public:
  ON_LocalZero1();
  virtual ~ON_LocalZero1();

  virtual
  BOOL Evaluate( // returns TRUE if successful
     double,  // evaluation parameter
     double*, // f(t) returned here - NULL never passed
     double*, // If not NULL, then f'(t) returned here
     int      // <  0: evaluate from below
              // >= 0: evaluate from above
  ) = 0;


  BOOL FindZero( double* );  // Searches domain between m_to and m_t1
                             // domain for a root.  Returns TRUE if
                             // a root is found.

  // m_t0 and m_t1 specify the domain to search and must satisfy
  //
  //          1) m_t0 != m_t1
  //          2) f(m_t0) and f(m_t1) must have different signs
  //             or one must have absolute value <= m_f_tolerance
  double m_t0, m_t1;

  double m_f_tolerance; // (>= 0.0)  If this value is > 0.0, then
                        // the search is terminated when a parameter
                        // "t" is found where |f(t)| <= m_f_tolerance.

  double m_t_tolerance; // (>= 0.0)  If this value is > 0.0, then
                        // the search is terminated when a parameter
                        // the root is bracketed in a domain with width
                        // <= m_t_tolerance.

  // m_k[] is either NULL or monotone increasing array of length m_k_count.
  //
  // This zero finder works on continuous piecewise c2 functions.
  // If the function is c2 on the interior of the domain
  //
  //          [min(t0,t1), max(m_t0,m_t1)]
  //
  // then there is no need to initialize m_k[].  If the function
  // is not c2 on the domain in question, then the m_k[m_count] array
  // is a list of parameters that define the c2 domains.  When m_k[]
  // is not NULL, m_count must be >= 2 and m_k[] must be monotone
  // increasing and satisfy
  //
  //          m_k[0] <= min(m_t0,m_t1)
  //          and
  //          m_k[m_count-1] >= max(m_t0,m_t1).
  //
  // Duplicate values in m_k[] are permitted so that NURBS knot
  // vector arrays may be used directly.
  const double* m_k;

  // length of m_k[] array ( 0 or >= 2 ).
  int m_k_count;

private:
  double m_s0, m_f0, m_s1, m_f1;
  BOOL BracketZero(double,double,double,double,int=0);
  BOOL BracketSpan(double,double,double,double);
  BOOL NewtonRaphson( double, double, double, double, int, double* );
};

#endif

@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src3/opennurbs/opennurbs_optimize.h 2     9/17/01 4:21p Dalelear $ */
d11 1
a11 1
//				
d53 1
a53 1
  // m_t0 and m_t1 specify the domain to search and must satisfy 
d58 1
a58 1
  double m_t0, m_t1; 
d72 1
a72 1
  // If the function is c2 on the interior of the domain 
d78 3
a80 3
  // is a list of parameters that define the c2 domains.  When m_k[] 
  // is not NULL, m_count must be >= 2 and m_k[] must be monotone 
  // increasing and satisfy 
d82 1
a82 1
  //          m_k[0] <= min(m_t0,m_t1) 
d89 1
a89 1
  
d91 1
a91 1
  int m_k_count;     
@

