head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@// @;


1.2
date	2007.09.14.15.21.45;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.36;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_pointgrid.cpp,v 1.1 2007/01/05 15:20:36 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#include "opennurbs.h"

ON_OBJECT_IMPLEMENT(ON_PointGrid,ON_Geometry,"4ED7D4E5-E947-11d3-BFE5-0010830122F0");

ON_3dPoint ON_PointGrid::m_no_point(0.0,0.0,0.0);

ON_PointGrid::ON_PointGrid()
{
  Initialize();
}

ON_PointGrid::ON_PointGrid( int c0, int c1 )
{
  Initialize();
  Create(c0,c1);
}

ON_PointGrid::ON_PointGrid( const ON_PointGrid& src )
{
  *this = src;
}

ON_PointGrid::~ON_PointGrid()
{
  Destroy();
}

int ON_PointGrid::Dimension() const
{
  return 3;
}

int ON_PointGrid::PointCount( int dir ) const
{
  return m_point_count[dir?1:0];
}

int ON_PointGrid::PointCount( void ) const
{
  return m_point_count[0]*m_point_count[1];
}

ON_3dPoint& ON_PointGrid::Point( int i, int j )
{
  return (0 <= i && i < m_point_count[0] && 0 <= j && j < m_point_count[1])
         ? m_point[i*m_point_stride0 + j]
         : m_no_point;
}

ON_3dPoint ON_PointGrid::Point( int i, int j ) const
{
  return (0 <= i && i < m_point_count[0] && 0 <= j && j < m_point_count[1])
         ? m_point[i*m_point_stride0 + j]
         : m_no_point;
}

double* ON_PointGrid::PointArray()
{
  return (m_point_count[0]>0&&m_point_count[1]>0) ? &m_point[0].x : NULL;
}

const double* ON_PointGrid::PointArray() const
{
  return (m_point_count[0]>0&&m_point_count[1]>0) ? &m_point[0].x : NULL;
}

int ON_PointGrid::PointArrayStride(  // point stride in grid direction
      int dir        // dir 0 = "s", 1 = "t"
      ) const
{
  return ((dir) ? 3 : 3*m_point_stride0);
}


BOOL ON_PointGrid::SetPoint( int i, int j, const ON_3dPoint& point )
{
  BOOL rc = false;
  if ( 0 <= i && i < m_point_count[0] && 0 <= j && j < m_point_count[1] ) {
    m_point[i*m_point_stride0+j] = point;
    rc = true;
  }
  return rc;
}

BOOL ON_PointGrid::GetPoint( int i, int j, ON_3dPoint& point ) const
{
  BOOL rc = false;
  if ( 0 <= i && i < m_point_count[0] && 0 <= j && j < m_point_count[1] ) {
    point = m_point[i*m_point_stride0+j];
    rc = true;
  }
  return rc;
}

ON_3dPoint* ON_PointGrid::operator[](int i)
{
  return ( 0 <= i && i < m_point_count[0] )
         ? m_point.Array() + i*m_point_stride0 : 0;
}

const ON_3dPoint* ON_PointGrid::operator[](int i) const
{
  return ( 0 <= i && i < m_point_count[0] )
         ? m_point.Array() + i*m_point_stride0 : 0;
}

BOOL
ON_PointGrid::Create(
        int point_count0,  // cv count0 (>= order0)
        int point_count1   // cv count1 (>= order1)
        )
{
  if ( point_count0 < 1 )
    return false;
  if ( point_count1 < 1 )
    return false;
  m_point_count[0] = point_count0;
  m_point_count[1] = point_count1;
  m_point_stride0 = m_point_count[1];
  m_point.Reserve(m_point_count[0]*m_point_count[1]);
  return true;
}

void ON_PointGrid::Destroy()
{
  Initialize();
  m_point.SetCapacity(0);
}

void ON_PointGrid::EmergencyDestroy()
{
  // call if memory used by point grid becomes invalid
  m_point_count[0] = 0;
  m_point_count[1] = 0;
  m_point_stride0 = 0;
  m_point.EmergencyDestroy();
}

void ON_PointGrid::Initialize()
{
  m_point_count[0] = 0;
  m_point_count[1] = 0;
  m_point_stride0 = 0;
  m_point.SetCount(0);
}

ON_PointGrid& ON_PointGrid::operator=( const ON_PointGrid& src )
{
  if ( this != &src ) {
    ON_Geometry::operator=(src);
    m_point_count[0] = src.m_point_count[0];
    m_point_count[1] = src.m_point_count[1];
    m_point_stride0 = m_point_count[1];
    m_point.Reserve(PointCount());
    m_point.SetCount(PointCount());
    if ( PointCount() > 0 ) {
      // copy cv array
      if ( m_point_stride0 == src.m_point_stride0 ) {
        memcpy( m_point.Array(), src.m_point.Array(), PointCount()*sizeof(ON_3dPoint) );
      }
      else {
        int i, j;
        for ( i = 0; i < m_point_count[0]; i++ ) for ( j = 0; j < m_point_count[1]; j++ ) {
          m_point[i*m_point_stride0+j] = src[i][j];
        }
      }
    }
  }
  return *this;
}

void ON_PointGrid::Dump( ON_TextLog& dump ) const
{
  dump.Print( "ON_PointGrid size = %d X %d\n",
               m_point_count[0], m_point_count[1] );
  if ( m_point.Count() < 1 ) {
    dump.Print("  NO point array\n");
  }
  else {
    dump.PrintPointGrid( 3, false, m_point_count[0], m_point_count[1],
                         3*m_point_stride0, 3,
                         &m_point[0].x,
                         "  point"
                         );
  }
}

BOOL ON_PointGrid::IsValid( ON_TextLog* text_log ) const
{
  BOOL rc = false;
  if ( ON_IsValidPointGrid( 3, false,
                            m_point_count[0], m_point_count[1],
                            m_point_stride0*3, 3,
                            &m_point[0].x ) )
  {
    if ( m_point.Count() >= m_point_stride0*m_point_count[0] )
      rc = true;
  }
  return rc;
}

BOOL ON_PointGrid::GetBBox( // returns true if successful
       double* boxmin,    // minimum
       double* boxmax,    // maximum
       BOOL bGrowBox  // true means grow box
       ) const
{
  return ON_GetPointGridBoundingBox( 3, 0,
            m_point_count[0], m_point_count[1],
            m_point_stride0*3, 3, &m_point[0].x,
            boxmin, boxmax, bGrowBox?true:false );
}

bool ON_PointGrid::GetTightBoundingBox(
         ON_BoundingBox& tight_bbox,
         int bGrowBox,
				 const ON_Xform* xform
         ) const
{
  if ( bGrowBox && !tight_bbox.IsValid() )
  {
    bGrowBox = false;
  }
  if ( !bGrowBox )
  {
    tight_bbox.Destroy();
  }

  int i;
  for ( i = 0; i < m_point_count[0]; i++ )
  {
    if ( ON_GetPointListBoundingBox( 3, 0, m_point_count[1], 3, &m_point[i].x, tight_bbox, bGrowBox, xform ) )
      bGrowBox = true;
  }
  return bGrowBox?true:false;
}

BOOL ON_PointGrid::Transform( const ON_Xform& xform )
{
  TransformUserData(xform);
  return ON_TransformPointGrid( 3, false,
            m_point_count[0], m_point_count[1],
            m_point_stride0*3, 3,
            Point(0,0),
            xform );
}

// virtual ON_Geometry::IsDeformable() override
bool ON_PointGrid::IsDeformable() const
{
  return true;
}

// virtual ON_Geometry::MakeDeformable() override
bool ON_PointGrid::MakeDeformable()
{
  return true;
}

BOOL ON_PointGrid::SwapCoordinates(
      int i, int j // indices of coords to swap
      )
{
  return ON_SwapPointGridCoordinates(
            m_point_count[0], m_point_count[1],
            m_point_stride0*3, 3,
            Point(0,0),
            i, j );

}


BOOL ON_PointGrid::Write(
       ON_BinaryArchive&  // open binary file
     ) const
{
  // TODO
  return false;
}

BOOL ON_PointGrid::Read(
       ON_BinaryArchive&  // open binary file
     )
{
  // TODO
  return false;
}

ON::object_type ON_PointGrid::ObjectType() const
{
  return ON::pointset_object;
}

BOOL
ON_PointGrid::IsClosed( int dir ) const
{
  return ON_IsPointGridClosed( 3, 0,
                    m_point_count[0], m_point_count[1],
                    m_point_stride0*3, 3,
                    &m_point[0].x, dir );
}

BOOL
ON_PointGrid::Reverse(int dir)
{
  return ON_ReversePointGrid( 3, false, m_point_count[0], m_point_count[1], m_point_stride0*3, 3, Point(0,0), dir );
}

BOOL
ON_PointGrid::Transpose()
{
  int i, j;
  BOOL rc = false;
  if ( IsValid() ) {
    // slow stupid way - can be imporved if necessary
    ON_PointGrid t(m_point_count[1],m_point_count[0]);
    for ( i = 0; i < m_point_count[0]; i++ ) for ( j = 0; j < m_point_count[1]; j++ ) {
      t[j][i] = Point(i,j);
    }
    *this = t;
    rc = true;
  }
  return rc;
}


@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src4/opennurbs/opennurbs_pointgrid.cpp 3     7/20/05 9:58a Dalelear $ */
d11 1
a11 1
//				
d61 2
a62 2
  return (0 <= i && i < m_point_count[0] && 0 <= j && j < m_point_count[1]) 
         ? m_point[i*m_point_stride0 + j] 
d68 2
a69 2
  return (0 <= i && i < m_point_count[0] && 0 <= j && j < m_point_count[1]) 
         ? m_point[i*m_point_stride0 + j] 
d113 1
a113 1
  return ( 0 <= i && i < m_point_count[0] ) 
d119 1
a119 1
  return ( 0 <= i && i < m_point_count[0] ) 
d196 2
a197 2
    dump.PrintPointGrid( 3, false, m_point_count[0], m_point_count[1], 
                         3*m_point_stride0, 3, 
d199 1
a199 1
                         "  point" 
d207 4
a210 4
  if ( ON_IsValidPointGrid( 3, false, 
                            m_point_count[0], m_point_count[1], 
                            m_point_stride0*3, 3, 
                            &m_point[0].x ) ) 
d224 3
a226 3
  return ON_GetPointGridBoundingBox( 3, 0, 
            m_point_count[0], m_point_count[1], 
            m_point_stride0*3, 3, &m_point[0].x, 
d233 1
a233 1
				 const ON_Xform* xform 
d244 1
a244 1
  
d257 1
a257 1
  return ON_TransformPointGrid( 3, false, 
d260 1
a260 1
            Point(0,0), 
d280 4
a283 4
  return ON_SwapPointGridCoordinates( 
            m_point_count[0], m_point_count[1], 
            m_point_stride0*3, 3, 
            Point(0,0), 
d310 1
a310 1
BOOL 
d313 3
a315 3
  return ON_IsPointGridClosed( 3, 0, 
                    m_point_count[0], m_point_count[1], 
                    m_point_stride0*3, 3, 
@

