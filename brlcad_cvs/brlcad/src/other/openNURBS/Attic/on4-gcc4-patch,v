head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2007.01.05.15.28.05;	author brlcad;	state dead;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.06;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@the user-provided gcc4 patch that fixes compilation was applied (basically added a lot of explicit this-> designations), no need to keep the file around though
@
text
@Index: opennurbs_array_defs.h
===================================================================
--- opennurbs_array_defs.h	(revision 4518)
+++ opennurbs_array_defs.h	(revision 4524)
@@@@ -617,7 +617,7 @@@@
   if ( ptr && reptr && reptr != ptr )
   {
     int i;
-    for ( i = 0; i < m_count; i++ )
+    for ( i = 0; i < this->m_count; i++ )
     {
       reptr[i].MemoryRelocate();
     }
@@@@ -638,9 +638,9 @@@@
 ON__UINT32 ON_ObjectArray<T>::DataCRC(ON__UINT32 current_remainder) const
 {
   int i;
-  for ( i = 0; i < m_count; i++ )
+  for ( i = 0; i < this->m_count; i++ )
   {
-    current_remainder = m_a[i].DataCRC(current_remainder);
+    current_remainder = this->m_a[i].DataCRC(current_remainder);
   }
   return current_remainder;
 }
@@@@ -1023,8 +1023,8 @@@@
 int ON_ClassArray<T>::BinarySearch( const T* key, int (*compar)(const T*,const T*) ) const
 {
   const T* found = (key&&m_a&&m_count>0) ? (const T*)bsearch( key, m_a, m_count, sizeof(T), (int(*)(const void*,const void*))compar ) : 0;
-#if defined(ON_COMPILER_MSC1300)
-  // for 32 and 64 bit compilers - the (int) converts 64 bit size_t
+#if defined(ON_COMPILER_MSC1300) || defined(ON_COMPILER_GNU)
+  // for 32 and 64 bit compilers - the (int) converts 64 bit size_t
   return found ? ((int)(found - m_a)) : -1;
 #else
   // for lamer 64 bit compilers
@@@@ -1064,18 +1064,18 @@@@
 bool ON_ObjectArray<T>::HeapSort( int (*compar)(const T*,const T*) )
 {
   bool rc = false;
-  if ( m_a && m_count > 0 && compar ) 
+  if ( this->m_a && this->m_count > 0 && compar ) 
   {
-    if ( m_count > 1 )
+    if ( this->m_count > 1 )
     {
-      ON_hsort( m_a, m_count, sizeof(T), (int(*)(const void*,const void*))compar );
+      ON_hsort( this->m_a, this->m_count, sizeof(T), (int(*)(const void*,const void*))compar );
       
       // The MemoryRelocate step is required to synch userdata back pointers
       // so the user data destructor will work correctly.
       int i;
-      for ( i = 0; i < m_count; i++ )
+      for ( i = 0; i < this->m_count; i++ )
       {
-        m_a[i].MemoryRelocate();
+        this->m_a[i].MemoryRelocate();
       }
     }
     rc = true;
@@@@ -1087,18 +1087,18 @@@@
 bool ON_ObjectArray<T>::QuickSort( int (*compar)(const T*,const T*) )
 {
   bool rc = false;
-  if ( m_a && m_count > 0 && compar ) 
+  if ( this->m_a && this->m_count > 0 && compar ) 
   {
-    if ( m_count > 1 )
+    if ( this->m_count > 1 )
     {
-      qsort( m_a, m_count, sizeof(T), (int(*)(const void*,const void*))compar );
+      qsort( this->m_a, this->m_count, sizeof(T), (int(*)(const void*,const void*))compar );
 
       // The MemoryRelocate step is required to synch userdata back pointers
       // so the user data destructor will work correctly.
       int i;
-      for ( i = 0; i < m_count; i++ )
+      for ( i = 0; i < this->m_count; i++ )
       {
-        m_a[i].MemoryRelocate();
+        this->m_a[i].MemoryRelocate();
       }
     }
     rc = true;
Index: opennurbs_brep_io.cpp
===================================================================
--- opennurbs_brep_io.cpp	(revision 4518)
+++ opennurbs_brep_io.cpp	(revision 4524)
@@@@ -1255,7 +1255,8 @@@@
   file.ReadInt( &sz );
   m_V.Reserve(sz);
   for ( i = 0; i < sz; i++ ) {
-    m_V.Append(ON_BrepVertex());
+ ON_BrepVertex empty_vertex; 
+    m_V.Append(empty_vertex);
     m_V[i].Read(file);
   }
 

@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@@

