head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.09.14.15.21.40;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.25;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_evaluate_nurbs.h,v 1.1 2007/01/05 15:20:25 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_EVALUATE_NURBS_INC_)
#define ON_EVALUATE_NURBS_INC_

ON_DECL
bool ON_IncreaseBezierDegree(
        int,    // dimension
        BOOL,   // TRUE if Bezier is rational
        int,    // order (>=2)
        int,    // cv_stride (>=dim+1)
        double* // cv[(order+1)*cv_stride] array
        );

ON_DECL
bool ON_RemoveBezierSingAt0( // input bezier is rational with 0/0 at start
        int,    // dimension
        int,    // order (>=2)
        int,    // cv_stride (>=dim+1)
        double* // cv[order*cv_stride] array
        );

ON_DECL
bool ON_RemoveBezierSingAt1( // input bezier is rational with 0/0 at end
        int,    // dimension
        int,    // order (>=2)
        int,    // cv_stride (>=dim+1)
        double* // cv[order*cv_stride] array
        );

ON_DECL
double ON_EvaluateBernsteinBasis( // returns (i choose d)*(1-t)^(d-i)*t^i
        int, // degree,
        int, // 0 <= i <= degree
        double //  t
        );

ON_DECL
void ON_EvaluatedeCasteljau(
        int,     //  dim
        int,     //  order
        int,     //  side <= 0  return left side of bezier in cv array
                 //       >  0  return right side of bezier in cv array
        int,     //  cv_stride
        double*, //  cv
        double   //  t 0 <= t <= 1
        );

ON_DECL
bool ON_EvaluateBezier(
        int,            // dimension
        BOOL,           // TRUE if Bezier is rational
        int,            // order (>=2)
        int,            // cv_stride >= (is_rat)?dim+1:dim
        const double*,  // cv[order*cv_stride] array
        double, double, // t0,t1 = domain of bezier
        int,            // number of derivatives to compute (>=0)
        double,         // evaluation parameter
        int,            // v_stride (>=dimension)
        double*         // v[(der_count+1)*v_stride] array
        );

ON_DECL
bool ON_EvaluateNurbsBasis(
                  int,           // order (>=1)
                  const double*, // knot[] array of 2*(order-1) knots
                  double,        // evaluation parameter
                  double*        // basis_values[] array of length order*order
                  );

ON_DECL
bool ON_EvaluateNurbsBasisDerivatives(
                  int,           // order (>=1)
                  const double*, // knot[] array of 2*(order-1) knots
                  int,           // number of derivatives
                  double*        // basis_values[] array of length order*order
                  );




/*
int dim,             // dimension
                  BOOL is_rat,         // TRUE if NURBS is rational
                  int order,           // order
                  const double* knot,  // knot[] array of (2*order-2) doubles
                  int cv_stride,       // cv_stride >= (is_rat)?dim+1:dim
                  const double* cv,    // cv[order*cv_stride] array
                  int der_count,       // number of derivatives to compute
                  double t,            // evaluation parameter
                  int v_stride,        // v_stride (>=dimension)
                  double* v            // v[(der_count+1)*v_stride] array
                  )
        int,           // dimension
        BOOL,          // TRUE if NURBS is rational
        int,           // order
        const double*, // knot[] array of (2*order-2) doubles
        int,           // cv_stride
        const double*, // cv[] array of order*cv_stride  doubles
        int,           // number of derivatives to compute (>=0)
        double,        // evaluation parameter
        int,           // answer_stride (>=dimension)
        double*        // answer[] array of length (ndir+1)*answer_stride
*/


ON_DECL

/*
Description:
  Evaluate a NURBS curve span.
Parameters:
  dim - [in]
    dimension (> 0).
  is_rat - [in]
    true or false.
  order - [in]
    order=degree+1 (order>=2)
  knot - [in] NURBS knot vector.
    NURBS knot vector with 2*(order-1) knots, knot[order-2] != knot[order-1]
  cv_stride - [in]
  cv - [in]
    For 0 <= i < order the i-th control vertex is

          cv[n],...,cv[n+(is_rat?dim:dim+1)],

    where n = i*cv_stride.  If is_rat is true the cv is
    in homogeneous form.
  der_count - [in]
    number of derivatives to evaluate (>=0)
  t - [in]
    evaluation parameter
  v_stride - [in]
  v - [out]
    An array of length v_stride*(der_count+1). The evaluation
    results are returned in this array.

              P = v[0],...,v[m_dim-1]
              Dt = v[v_stride],...
              Dtt = v[2*v_stride],...
              ...

            In general, Dt^i returned in v[n],...,v[n+m_dim-1], where

              n = v_stride*i.

Returns:
  True if successful.
See Also:
  ON_NurbsCurve::Evaluate
  ON_EvaluateNurbsSurfaceSpan
  ON_EvaluateNurbsCageSpan
*/
bool ON_EvaluateNurbsSpan(
        int dim,
        int is_rat,
        int order,
        const double* knot,
        int cv_stride,
        const double* cv,
        int der_count,
        double t,
        int v_stride,
        double* v
        );

/*
Description:
  Evaluate a NURBS surface bispan.
Parameters:
  dim - [in] >0
  is_rat - [in] true of false
  order0 - [in] >= 2
  order1 - [in] >= 2
  knot0 - [in]
    NURBS knot vector with 2*(order0-1) knots, knot0[order0-2] != knot0[order0-1]
  knot1 - [in]
    NURBS knot vector with 2*(order1-1) knots, knot1[order1-2] != knot1[order1-1]
  cv_stride0 - [in]
  cv_stride1 - [in]
  cv - [in]
    For 0 <= i < order0 and  0 <= j < order1, the (i,j) control vertex is

          cv[n],...,cv[n+(is_rat?dim:dim+1)],

    where n = i*cv_stride0 + j*cv_stride1.  If is_rat is true the cv is
    in homogeneous form.

  der_count - [in] (>=0)
  s - [in]
  t - [in] (s,t) is the evaluation parameter
  v_stride - [in] (>=dim)
  v - [out] An array of length v_stride*(der_count+1)*(der_count+2)/2.
            The evaluation results are stored in this array.

              P = v[0],...,v[m_dim-1]
              Ds = v[v_stride],...
              Dt = v[2*v_stride],...
              Dss = v[3*v_stride],...
              Dst = v[4*v_stride],...
              Dtt = v[5*v_stride],...

            In general, Ds^i Dt^j is returned in v[n],...,v[n+m_dim-1], where

              n = v_stride*( (i+j)*(i+j+1)/2 + j).

Returns:
  True if succcessful.
See Also:
  ON_NurbsSurface::Evaluate
  ON_EvaluateNurbsSpan
  ON_EvaluateNurbsCageSpan
*/
ON_DECL
bool ON_EvaluateNurbsSurfaceSpan(
        int dim,
        int is_rat,
        int order0,
        int order1,
        const double* knot0,
        const double* knot1,
        int cv_stride0,
        int cv_stride1,
        const double* cv,
        int der_count,
        double s,
        double t,
        int v_stride,
        double* v
        );



/*
Description:
  Evaluate a NURBS cage trispan.
Parameters:
  dim - [in] >0
  is_rat - [in] true of false
  order0 - [in] >= 2
  order1 - [in] >= 2
  order2 - [in] >= 2
  knot0 - [in]
    NURBS knot vector with 2*(order0-1) knots, knot0[order0-2] != knot0[order0-1]
  knot1 - [in]
    NURBS knot vector with 2*(order1-1) knots, knot1[order1-2] != knot1[order1-1]
  knot2 - [in]
    NURBS knot vector with 2*(order1-1) knots, knot2[order2-2] != knot2[order2-1]
  cv_stride0 - [in]
  cv_stride1 - [in]
  cv_stride2 - [in]
  cv - [in]
    For 0 <= i < order0, 0 <= j < order1, and 0 <= k < order2,
    the (i,j,k)-th control vertex is

          cv[n],...,cv[n+(is_rat?dim:dim+1)],

    where n = i*cv_stride0 + j*cv_stride1 *k*cv_stride2.
    If is_rat is true the cv is in homogeneous form.

  der_count - [in] (>=0)
  r - [in]
  s - [in]
  t - [in] (r,s,t) is the evaluation parameter
  v_stride - [in] (>=dim)
  v - [out] An array of length v_stride*(der_count+1)*(der_count+2)*(der_count+3)/6.
            The evaluation results are stored in this array.

              P = v[0],...,v[m_dim-1]
              Dr = v[v_stride],...
              Ds = v[2*v_stride],...
              Dt = v[3*v_stride],...
              Drr = v[4*v_stride],...
              Drs = v[5*v_stride],...
              Drt = v[6*v_stride],...
              Dss = v[7*v_stride],...
              Dst = v[8*v_stride],...
              Dtt = v[9*v_stride],...

            In general, Dr^i Ds^j Dt^k is returned in v[n],...,v[n+dim-1], where

               d = (i+j+k)
               n = v_stride*( d*(d+1)*(d+2)/6 + (j+k)*(j+k+1)/2 + k)

Returns:
  True if succcessful.
See Also:
  ON_NurbsCage::Evaluate
  ON_EvaluateNurbsSpan
  ON_EvaluateNurbsSurfaceSpan
*/
ON_DECL
bool ON_EvaluateNurbsCageSpan(
        int dim,
        int is_rat,
        int order0, int order1, int order2,
        const double* knot0,
        const double* knot1,
        const double* knot2,
        int cv_stride0, int cv_stride1, int cv_stride2,
        const double* cv,
        int der_count,
        double t0, double t1, double t2,
        int v_stride,
        double* v
        );


ON_DECL
bool ON_EvaluateNurbsDeBoor( // for expert users only - no support available
        int,            // cv_dim ( dim+1 for rational cvs )
        int,            // order (>=2)
        int,            // cv_stride (>=cv_dim)
        double*,        // cv array - values changed to result of applying De Boor's algorithm
        const double*,  // knot array
        int,            // side,
                        //    -1  return left side of B-spline span in cv array
                        //    +1  return right side of B-spline span in cv array
                        //    -2  return left side of B-spline span in cv array
                        //        Ignore values of knots[0,...,order-3] and assume
                        //        left end of span has a fully multiple knot with
                        //        value "mult_k".
                        //    +2  return right side of B-spline span in cv array
                        //        Ignore values of knots[order,...,2*order-2] and
                        //        assume right end of span has a fully multiple
                        //        knot with value "mult_k".
        double,         // mult_k - used when side is +2 or -2.  See above for usage.
        double          // t
                        //    If side < 0, then the cv's for the portion of the NURB span to
                        //    the LEFT of t are computed.  If side > 0, then the cv's for the
                        //    portion the span to the RIGHT of t are computed.  The following
                        //    table summarizes the restrictions on t:
                        //
                        //     value of side         condition t must satisfy
                        //        -2                    mult_k < t and mult_k < knots[order-1]
                        //        -1                    knots[order-2] < t
                        //        +1                    t < knots[order-1]
                        //        +2                    t < mult_k and knots[order-2] < mult_k
        );


ON_DECL
bool ON_EvaluateNurbsBlossom(int, // cvdim,
                             int, // order,
                             int, // cv_stride,
                             const double*, //CV, size cv_stride*order
                             const double*, //knot, nondecreasing, size 2*(order-1)
                             // knot[order-2] != knot[order-1]
                             const double*, //t, input parameters size order-1
                             double* // P

                             // DeBoor algorithm with different input at each step.
                             // returns FALSE for bad input.
                            );


ON_DECL
void ON_ConvertNurbSpanToBezier(
        int,       // cvdim (dim+1 for rational curves)
        int,       // order,
        int,       // cvstride (>=cvdim)
        double*,   // cv array - input has NURBS cvs, output has Bezier cvs
        const double*, // (2*order-2) knots for the NURBS span
        double,        // t0, NURBS span parameter of start point
        double         // t1, NURBS span parameter of end point
        );
#endif
@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src4/opennurbs/opennurbs_evaluate_nurbs.h 2     1/18/05 4:52p Dalelear $ */
d11 1
a11 1
//				
d22 1
a22 1
        int,    // dimension 
d31 1
a31 1
        int,    // dimension 
d39 1
a39 1
        int,    // dimension 
d47 1
a47 1
        int, // degree, 
d76 1
a76 1
                                      
d78 1
a78 1
bool ON_EvaluateNurbsBasis( 
d86 1
a86 1
bool ON_EvaluateNurbsBasisDerivatives( 
d91 1
a91 1
                  );                      
d129 1
a129 1
  is_rat - [in] 
d139 1
a139 1
          cv[n],...,cv[n+(is_rat?dim:dim+1)], 
d143 1
a143 1
  der_count - [in] 
d145 1
a145 1
  t - [in] 
d149 1
a149 1
    An array of length v_stride*(der_count+1). The evaluation 
d160 1
a160 1
    
d168 1
a168 1
bool ON_EvaluateNurbsSpan( 
d189 1
a189 1
  knot0 - [in] 
d198 1
a198 1
          cv[n],...,cv[n+(is_rat?dim:dim+1)], 
d202 1
a202 1
   
d232 1
a232 1
        int order0, 
d245 1
a245 1
            
d257 1
a257 1
  knot0 - [in] 
d267 1
a267 1
    For 0 <= i < order0, 0 <= j < order1, and 0 <= k < order2, 
d270 1
a270 1
          cv[n],...,cv[n+(is_rat?dim:dim+1)], 
d272 1
a272 1
    where n = i*cv_stride0 + j*cv_stride1 *k*cv_stride2.  
d274 1
a274 1
   
d297 1
a297 1
               n = v_stride*( d*(d+1)*(d+2)/6 + (j+k)*(j+k+1)/2 + k) 
d318 1
a318 1
        int v_stride, 
d358 1
a358 1
                             int, // order, 
d374 1
a374 1
        int,       // order, 
@

