head	1.2;
access;
symbols
	rel-7-10-4:1.1
	STABLE:1.1.0.2
	rel-7-10-2:1.1
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.09.14.15.21.44;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.26;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_gl.h,v 1.1 2007/01/05 15:20:26 brlcad Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//  Definitions of ON_GL() functions that demonstrate how to
//  use GL to display OpenNURBS objects.
//
////////////////////////////////////////////////////////////////

#include "opennurbs.h"

#if defined(ON_OS_WINDOWS)
// Windows Open GL files require windows.h to be included before the
// Open GL header files.
#include <windows.h>
#endif

#include <GL/gl.h>      // Open GL basic definitions
#include <GL/glu.h>     // Open GL utilities (for GL NURBS stuff)

#if !defined(OPENNURBS_GL_INC_)
#define OPENNURBS_GL_INC_


// Use ON_GL( const ON_Point, ...) to render single points.
void ON_GL(
      const ON_Point&
      );

// Use ON_GL( const ON_PointCloud, ...) to render Rhino point sets.
void ON_GL(
      const ON_PointCloud&
      );

// Use ON_GL( const ON_Mesh&, ...) to render OpenNURBS meshes.
void ON_GL(
      const ON_Mesh&
      );

// Use ON_GL( const ON_Brep&, ...) to render OpenNURBS b-reps.
void ON_GL(
      const ON_Brep&,
      GLUnurbsObj*
      );

// must be bracketed by calls to glBegin(GL_POINTS) / glEnd()
void ON_GL(
      const ON_3dPoint&
      );

void ON_GL(
      const ON_Curve&,   //
      GLUnurbsObj*,      // created with gluNewNurbsRenderer
      GLenum = 0,        // type of curve (if 0, type is automatically set)
      double[][4] = NULL // optional transformation applied to curve
      );

// must be bracketed by calls to gluBeginSurface( nobj )/gluEndSurface( nobj )
void ON_GL(
      const ON_Surface&,   //
      GLUnurbsObj*         // created with gluNewNurbsRenderer
      );

// Use ON_GL( const ON_NurbsCurve&,...) in place of
// gluNurbsCurve().  See your system's gluNurbsCurve() documentation
// for details.  In particular, for 3d curves the call to
// ON_GL( const ON_NurbsCurve&, nobj,...) should appear inside
// of a gluBeginCurve( nobj )/gluEndCurve( nobj ) pair.
// Generally, the GL "type" should be set using the formula
//   ON_NurbsCurve:IsRational()
//   ? GL_MAP1_VERTEX_4
//   : GL_MAP1_VERTEX_3;
void ON_GL(
      const ON_NurbsCurve&,   //
      GLUnurbsObj*,              // created with gluNewNurbsRenderer
      GLenum = 0,                // type of curve (if 0, type is automatically set)
      int = 1,           // bPermitKnotScaling - If TRUE, curve knots may
                         // be rescaled to avoid knot vectors GL cannot handle.
      double* = NULL,    // knot_scale[2] - If not NULL and bPermitKnotScaling,
                         // the scaling applied to the knot vector is
                         // returned here.
      double[][4] = NULL // optional transformation applied to curve
      );

void ON_GL( // low level NURBS curve render
      int, int, int, int, // dim, is_rat, cv_count, order
      const double*,      // knot_vector[]
      int,                // cv_stride
      const double*,      // cv
      GLUnurbsObj*,              // created with gluNewNurbsRenderer
      GLenum = 0,                // type of curve (if 0, type is automatically set)
      int = 1,           // bPermitKnotScaling - If TRUE, curve knots may
                         // be rescaled to avoid knot vectors GL cannot handle.
      double* = NULL,    // knot_scale[2] - If not NULL and bPermitKnotScaling,
                         // the scaling applied to the knot vector is
                         // returned here.
      double[][4] = NULL // optional transformation applied to curve
      );


// Use ON_GL( const ON_NurbsSurface&,...) in place of
// gluNurbsSurface().  See your system's gluNurbsSurface() documentation
// for details.  In particular, the call to
// ON_GL( const ON_NurbsSurface&, nobj, ...) should appear inside
// of a gluBeginSurface( nobj )/gluEndSurface( nobj ) pair.
// Generally, the GL "type" should be set using the formula
//   ON_NurbsSurface:IsRational()
//   ? GL_MAP2_VERTEX_4
//   : GL_MAP2_VERTEX_3;
void ON_GL(
      const ON_NurbsSurface&, //
      GLUnurbsObj*,              // created with gluNewNurbsRenderer
      GLenum = 0,                // type of surface
                                 // (if 0, type is automatically set)
      int = 1,           // bPermitKnotScaling - If TRUE, surface knots may
                         // be rescaled to avoid knot vectors GL cannot handle.
      double* = NULL,    // knot_scale0[2] - If not NULL and bPermitKnotScaling,
                         // the scaleing applied to the first parameter is
                         // returned here.
      double* = NULL     // knot_scale0[2] - If not NULL and bPermitKnotScaling,
                         // the scaleing applied to the second parameter is
                         // returned here.
      );


// Use ON_GL( const ON_BrepFace&, nobj ) to render
// the trimmed NURBS surface that defines a ON_Brep face's geometry.
// The call to ON_GL( const ON_BrepFace&, nobj ) should
// appear inside of a gluBeginSurface( nobj )/gluEndSurface( nobj )
// pair.
void ON_GL(
      const ON_BrepFace&, //
      GLUnurbsObj*       // created with gluNewNurbsRenderer
      );

// Use ON_GL( const ON_Color ...) to set GL color to OpenNURBS color
void ON_GL( const ON_Color&,
              GLfloat[4]
              );
void ON_GL( const ON_Color&,
              double, // alpha
              GLfloat[4]
              );

// Use ON_GL( const ON_Material ...) to set GL material to OpenNURBS material
void ON_GL(
      const ON_Material&
      );

void ON_GL(
      const ON_Material* // pass NULL to get OpenNURBS's default material
      );

// Use ON_GL( const ON_Light, ...) to add OpenNURBS spotlights to
// GL lighting model
void ON_GL(
      const ON_Light*, // pass NULL to disable the light
      GLenum                  // GL_LIGHTi where 0 <= i <= GL_MAX_LIGHTS
                              // See glLight*() documentation for details
      );
void ON_GL(
      const ON_Light&,
      GLenum                  // GL_LIGHTi where 0 <= i <= GL_MAX_LIGHTS
                              // See glLight*() documentation for details
      );

//////////////////////////////////////////////////////////////////////////
// Use ON_GL( ON_Viewport& ... ) to set the GL projections to match
// those used in the OpenNURBS viewport.

////////////
//
// Use ON_GL( ON_Viewport&, in, int, int, int ) to specify the size of the
// GL window and loads the GL projection matrix (camera to clip
// transformation). If the aspect ratio of the GL window and
// ON_Viewport's frustum do not match, the viewport's frustum is
// adjusted to get things back to 1:1.
//
// For systems where the upper left corner of a window has
// coordinates (0,0) use:
//   port_left   = 0
//   port_right  = width-1
//   port_bottom = height-1
//   port_top    = 0
void ON_GL( ON_Viewport&,
            int, int, // port_left, port_right (port_left != port_right)
            int, int  // port_bottom, port_top (port_bottom != port_top)
            );

////////////
//
// Use ON_GL( ON_Viewport& ) to load the GL model view matrix (world to
// camera transformation).
void ON_GL( const ON_Viewport& );

// Use ON_GL( order, cv_count, knot, bPermitScaling, glknot )
// to create knot vectors suitable for GL NURBS rendering.
void ON_GL(
          const int,     // order, ON_NurbsCurve... order
          const int,     // cv_count, ON_NurbsCurve... cv count
          const double*, // knot, ON_NurbsCurve... knot vector
          GLfloat*,      // glknot[] - GL knot vector
          int = 0,       // bPermitScaling - TRUE if re-scaling is allowed
          double* = NULL // scale[2] - If not NULL and bPermitScaling is TRUE,
                         // then the scaling parameters are returned here.
                         // ( glknot = (knot = scale[0])*scale[1] )
          );

#endif
@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src3/opennurbs/opennurbs_gl.h 2     9/17/01 4:21p Dalelear $ */
d11 1
a11 1
//				
d18 1
a18 1
//				
d20 2
a21 2
//  use GL to display OpenNURBS objects.			
//				
d40 1
a40 1
void ON_GL( 
d45 1
a45 1
void ON_GL( 
d50 1
a50 1
void ON_GL( 
d55 1
a55 1
void ON_GL( 
d65 2
a66 2
void ON_GL( 
      const ON_Curve&,   // 
d73 2
a74 2
void ON_GL( 
      const ON_Surface&,   // 
d80 1
a80 1
// for details.  In particular, for 3d curves the call to 
d85 1
a85 1
//   ? GL_MAP1_VERTEX_4 
d87 2
a88 2
void ON_GL( 
      const ON_NurbsCurve&,   // 
d117 1
a117 1
// for details.  In particular, the call to 
d122 1
a122 1
//   ? GL_MAP2_VERTEX_4 
d124 2
a125 2
void ON_GL( 
      const ON_NurbsSurface&, // 
d127 1
a127 1
      GLenum = 0,                // type of surface 
d145 2
a146 2
void ON_GL( 
      const ON_BrepFace&, // 
d152 1
a152 1
              GLfloat[4] 
d156 1
a156 1
              GLfloat[4] 
d160 1
a160 1
void ON_GL( 
d164 1
a164 1
void ON_GL( 
d170 1
a170 1
void ON_GL( 
d175 1
a175 1
void ON_GL( 
d188 4
a191 4
// GL window and loads the GL projection matrix (camera to clip 
// transformation). If the aspect ratio of the GL window and 
// ON_Viewport's frustum do not match, the viewport's frustum is 
// adjusted to get things back to 1:1.  
d193 1
a193 1
// For systems where the upper left corner of a window has 
d206 1
a206 1
// Use ON_GL( ON_Viewport& ) to load the GL model view matrix (world to 
d212 1
a212 1
void ON_GL( 
@

