head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.2
	rel-7-10-2:1.2
	rel-7-10-0:1.1;
locks; strict;
comment	@ * @;


1.3
date	2007.09.14.15.21.44;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.28.17.20.35;	author jlowenz;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.05.15.20.35;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@removed trailing whitespace
@
text
@/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_point.h,v 1.2 2007/06/28 17:20:35 jlowenz Exp $ */
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2001 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines double precision point, vector, and array classes
//
////////////////////////////////////////////////////////////////
#if !defined(ON_POINT_INC_)
#define ON_POINT_INC_

class ON_BoundingBox;
class ON_Xform;
class ON_Line;
class ON_Plane;

class ON_2dPoint;
class ON_3dPoint;
class ON_4dPoint;

class ON_2dVector;
class ON_3dVector;

class ON_2fVector;
class ON_3fVector;

class ON_Interval;

////////////////////////////////////////////////////////////////
//
//   ON_Interval
//
class ON_CLASS ON_Interval
{
public:
  ////////
  // The default constructor creates the empty set interval (ON_UNSET_VALUE,ON_UNSET_VALUE)
  ON_Interval();

  ON_Interval(double t0,double t1);

  ~ON_Interval();

  bool operator!=(const ON_Interval&) const;
  bool operator==(const ON_Interval&) const;

  // Interval = [m_t[0], m_t[1]]
  double m_t[2];

  /*
  Description:
    Sets interval to (ON_UNSET_VALUE,ON_UNSET_VALUE)
  See Also:
    ON_Interval::Set
  */
  void Destroy();

  /*
  Description:
    Sets interval to [t0,t1]
  Parameters:
    t0 - [in]
    t1 - [in]
  See Also:
    ON_Interval::ON_Interval( double, double )
  */
  void Set(
    double t0,
    double t1
    );

  /*
  Description:
    Convert normalized parameter to interval value, or pair of values.
  Parameters:
    normalized_parameter - [in]
  Returns:
    Interval parameter
    min*(1.0-normalized_parameter) + max*normalized_parameter
  See Also:
    ON_Interval::NormalizedParameterAt
  */
  double ParameterAt (
    double normalized_parameter
    ) const;
  ON_Interval ParameterAt (
    ON_Interval normalized_interval
    ) const;

  /*
  Description:
    Convert interval value, or pair of values, to normalized parameter.
  Parameters:
    interval_parameter - [in] value in interval
  Returns:
    Normalized parameter x so that
    min*(1.0-x) + max*x = interval_parameter.
  See Also:
    ON_Interval::ParameterAt
  */
  double NormalizedParameterAt (
    double interval_parameter
    ) const;
  ON_Interval NormalizedParameterAt (
    ON_Interval interval_parameter
    ) const;

  double& operator[](int); // returns (index<=0) ? m_t[0] : m_t[1]
  double operator[](int) const; // returns (index<=0) ? m_t[0] : m_t[1]

  double Min() const; // returns smaller of m_t[0] and m_t[1]
  double Max() const; // returns larger of m_t[0] and m_t[1]
  double Mid() const; // returns 0.5*(m_t[0] + m_t[1])
  double Length() const;

  bool IsIncreasing() const; // returns true if m_t[0] < m_t[1]
  bool IsDecreasing() const; // returns true if m_t[0] > m_t[0];
  bool IsInterval() const;   // returns truc if m_t[0] != m_t[1]
  bool IsSingleton() const;  // returns true if m_t[0] == m_t[1] != ON_UNSET_VALUE
  bool IsEmptySet() const;   // returns true if m_t[0] == m_t[1] == ON_UNSET_VALUE
  bool IsValid() const;      // returns ON_IsValid(m_t[0]) && ON_IsValid(m_t[1])

	bool MakeIncreasing();		// returns true if resulting interval IsIncreasing()

  /*
  Returns:
    @@untitled table
     0      this is idential to other
    -1      this[0] < other[0]
    +1      this[0] > other[0]
    -1      this[0] == other[0] and this[1] < other[1]
    +1      this[0] == other[0] and this[1] > other[1]
  */
  int Compare( const ON_Interval& other ) const;

  /*
  Description:
    Test a value t to see if it is inside the interval.
  Parameters:
    t - [in] value to test
    bTestOpenInterval - [in]
        If false, t is tested to see if it satisfies min <= t <= max.
        If true, t is tested to see if it satisfies min < t < max.
  Returns:
    true if t is in the interval and false if t is not
    in the interval.
  */
  bool Includes(
    double t,
    bool bTestOpenInterval = false
    ) const;

  /*
  Description:
    Test an interval to see if it is contained in this interval.
  Parameters:
    other - [in] interval to test
    bProperSubSet - [in] if true, then the test is for a proper subinterval.
  Returns:
    If bProperSubSet is false, then the result is true when
    this->Min() <= other.Min() and other.Max() <= this->Max().
    If bProperSubSet is true, then the result is true when
    this->Min() <= other.Min() and other.Max() <= this->Max()
    and at least one of the inequalites is strict.
  */
  bool Includes(
    const ON_Interval& other,
    bool bProperSubSet = false
    ) const;

  /*
  Description:
    Changes interval to [-m_t[1],-m_t[0]].
  */
  void Reverse();

  /*
  Description:
    Swaps m_t[0] and m_t[1].
  */
  void Swap();

  //////////
  // If the intersection is not empty, then
  // intersection = [max(this.Min(),arg.Min()), min(this.Max(),arg.Max())]
  // Intersection() returns true if the intersection is not empty.
  // The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
  // the empty set interval.  The result of any intersection involving an
  // empty set interval or disjoint intervals is the empty set interval.
  bool Intersection( // this = this intersect arg
         const ON_Interval&
         );

  //////////
  // If the intersection is not empty, then
  // intersection = [max(argA.Min(),argB.Min()), min(argA.Max(),argB.Max())]
  // Intersection() returns true if the intersection is not empty.
  // The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
  // the empty set interval.  The result of any intersection involving an
  // empty set interval or disjoint intervals is the empty set interval.
  bool Intersection( // this = intersection of two args
         const ON_Interval&,
         const ON_Interval&
         );

  //////////
  // The union of an empty set and an increasing interval is the increasing
  // interval.  The union of two empty sets is empty. The union of an empty
  // set an a non-empty interval is the non-empty interval.
  // The union of two non-empty intervals is
  // union = [min(this.Min(),arg.Min()), max(this.Max(),arg.Max()),]
  // Union() returns true if the union is not empty.
  bool Union( // this = this union arg
         const ON_Interval&
         );

  //////////
  // The union of an empty set and an increasing interval is the increasing
  // interval.  The union of two empty sets is empty. The union of an empty
  // set an a non-empty interval is the non-empty interval.
  // The union of two non-empty intervals is
  // union = [min(argA.Min(),argB.Min()), max(argA.Max(),argB.Max()),]
  // Union() returns true if the union is not empty.
  bool Union( // this = union of two args
         const ON_Interval&,
         const ON_Interval&
         );

  void Bound(double& val) const;

};

////////////////////////////////////////////////////////////////
//
//   ON_2dPoint
//
class ON_CLASS ON_2dPoint
{
public:
  double x, y;

  // use implicit destructor, copy constructor
  ON_2dPoint();                         // not initialized
  ON_2dPoint(const float*);             // from array of 2 floats
  ON_2dPoint(const double*);            // from array of 2 doubles
  ON_2dPoint(double x,double y);
  ON_2dPoint(const ON_3dPoint& );     // from 3d point
  ON_2dPoint(const ON_4dPoint& );     // from homogeneous 4d point
  ON_2dPoint(const ON_2dVector& );    // from 2d vector

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_2dPoint&)
  ON_2dPoint& operator=(const float*);  // point = float[2] support
  ON_2dPoint& operator=(const double*); // point = double[2] support
  ON_2dPoint& operator=(const ON_3dPoint&);
  ON_2dPoint& operator=(const ON_4dPoint&);
  ON_2dPoint& operator=(const ON_2dVector&);

  ON_2dPoint& operator*=(double);
  ON_2dPoint& operator/=(double);
  ON_2dPoint& operator+=(const ON_2dPoint&);
  ON_2dPoint& operator+=(const ON_2dVector&);
  ON_2dPoint& operator-=(const ON_2dPoint&);
  ON_2dPoint& operator-=(const ON_2dVector&);

  ON_2dPoint  operator*(double) const;
  ON_2dPoint  operator/(double) const;
  ON_2dPoint  operator+(const ON_2dPoint&) const;
  ON_2dPoint  operator+(const ON_2dVector&) const;
  ON_2dVector operator-(const ON_2dPoint&) const;
  ON_2dPoint  operator-(const ON_2dVector&) const;

  double operator*(const ON_2dPoint&) const; // dot product for points acting as vectors
  double operator*(const ON_2dVector&) const; // dot product for points acting as vectors
  double operator*(const ON_4dPoint&) const;
  ON_2dPoint operator*(const ON_Xform&) const;

  bool operator==(const ON_2dPoint&) const;
  bool operator!=(const ON_2dPoint&) const;

  // dictionary order comparisons
  bool operator<=(const ON_2dPoint&) const;
  bool operator>=(const ON_2dPoint&) const;
  bool operator<(const ON_2dPoint&) const;
  bool operator>(const ON_2dPoint&) const;

  // index operators mimic double[2] behavior
  double& operator[](int);
  double operator[](int) const;

  /*
  Description
    If any coordinate of a point is ON_UNSET_VALUE,
    then the point is not valid.
  Returns:
    true if the point is valid.
  */
  bool IsValid() const;

  // set 2d point value
  void Set(double x,double y);

  double DistanceTo( const ON_2dPoint& ) const;

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  void Zero(); // set all coordinates to zero;

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform(
        const ON_Xform&
        );

  void Rotate( // rotatation in XY plane
        double angle,              // angle in radians
        const ON_2dPoint& center   // center of rotation
        );

  void Rotate( // rotatation in XY plane
        double sin_angle,          // sin(angle)
        double cos_angle,          // cos(angle)
        const ON_2dPoint& center   // center of rotation
        );
};

ON_DECL
ON_2dPoint operator*(double, const ON_2dPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_3dPoint
//
class ON_CLASS ON_3dPoint
{
public:
  double x, y, z;

  // use implicit destructor, copy constructor
  ON_3dPoint();                        // not initialized
  ON_3dPoint(const float*);            // from array of 3 floats
  ON_3dPoint(const double*);           // from array of 3 doubles
  ON_3dPoint(double x,double y,double z);
  ON_3dPoint(const ON_2dPoint& );     // from 2d point
  ON_3dPoint(const ON_4dPoint& );     // from homogeneous 4d point
  ON_3dPoint(const ON_3dVector& );    // from 3d vector

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_3dPoint&)
  ON_3dPoint& operator=(const float*);  // point = float[3] support
  ON_3dPoint& operator=(const double*); // point = double[3] support
  ON_3dPoint& operator=(const ON_2dPoint&);
  ON_3dPoint& operator=(const ON_4dPoint&);
  ON_3dPoint& operator=(const ON_3dVector&);

  ON_3dPoint& operator*=(double);
  ON_3dPoint& operator/=(double);
  ON_3dPoint& operator+=(const ON_3dPoint&);
  ON_3dPoint& operator+=(const ON_3dVector&);
  ON_3dPoint& operator-=(const ON_3dPoint&);
  ON_3dPoint& operator-=(const ON_3dVector&);

  ON_3dPoint  operator*(double) const;
  ON_3dPoint  operator/(double) const;
  ON_3dPoint  operator+(const ON_3dPoint&) const;
  ON_3dPoint  operator+(const ON_3dVector&) const;
  ON_3dVector operator-(const ON_3dPoint&) const;
  ON_3dPoint  operator-(const ON_3dVector&) const;

  double operator*(const ON_3dPoint&) const; // dot product for points acting as vectors
  double operator*(const ON_3dVector&) const; // dot product for points acting as vectors
  double operator*(const ON_4dPoint&) const;
  ON_3dPoint operator*(const ON_Xform&) const;

  bool operator==(const ON_3dPoint&) const;
  bool operator!=(const ON_3dPoint&) const;

  // dictionary order comparisons
  bool operator<=(const ON_3dPoint&) const;
  bool operator>=(const ON_3dPoint&) const;
  bool operator<(const ON_3dPoint&) const;
  bool operator>(const ON_3dPoint&) const;

  // index operators mimic double[3] behavior
  double& operator[](int);
  double operator[](int) const;

  /*
  Description
    If any coordinate of a point is ON_UNSET_VALUE,
    then the point is not valid.
  Returns:
    true if the point is valid.
  */
  bool IsValid() const;

  // set 3d point value
  void Set(double x,double y,double z);

  double DistanceTo( const ON_3dPoint& ) const;

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  double Fuzz( double tolerance = ON_ZERO_TOLERANCE ) const; // tolerance to use when comparing 3d points

  void Zero(); // set all coordinates to zero;

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform(
        const ON_Xform&
        );

  void Rotate(
        double angle,             // angle in radians
        const ON_3dVector& axis,  // axis of rotation
        const ON_3dPoint& center  // center of rotation
        );

  void Rotate(
        double sin_angle,         // sin(angle)
        double cos_angle,         // cos(angle)
        const ON_3dVector& axis,  // axis of rotation
        const ON_3dPoint& center  // center of rotation
        );
};

ON_DECL
ON_3dPoint operator*(double, const ON_3dPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_4dPoint (homogeneous coordinates)
//
class ON_CLASS ON_4dPoint
{
public:
  double x, y, z, w;

  // use implicit destructor, copy constructor
  ON_4dPoint();                         // not initialized
  ON_4dPoint(const float*);             // from array of 4 doubles
  ON_4dPoint(const double*);            // from array of 4 doubles
  ON_4dPoint(double x,double y,double z,double w);
  ON_4dPoint(const ON_2dPoint& );     // from 2d point
  ON_4dPoint(const ON_3dPoint& );     // from 3d point
  ON_4dPoint(const ON_2dVector& );    // from 2d vector
  ON_4dPoint(const ON_3dVector& );    // from 3d vector

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_4dPoint&)
  ON_4dPoint& operator=(const float*);  // point = float[4] support
  ON_4dPoint& operator=(const class ON_2fPoint&);
  ON_4dPoint& operator=(const class ON_3fPoint&);
  ON_4dPoint& operator=(const class ON_2fVector&);
  ON_4dPoint& operator=(const class ON_3fVector&);

  ON_4dPoint& operator=(const double*); // point = double[4] support
  ON_4dPoint& operator=(const ON_2dPoint&);
  ON_4dPoint& operator=(const ON_3dPoint&);
  ON_4dPoint& operator=(const ON_2dVector&);
  ON_4dPoint& operator=(const ON_3dVector&);

  ON_4dPoint& operator*=(double);
  ON_4dPoint& operator/=(double);
  ON_4dPoint& operator+=(const ON_4dPoint&); // sum w = sqrt(|w1*w2|)
  ON_4dPoint& operator-=(const ON_4dPoint&); // difference w = sqrt(|w1*w2|)

  ON_4dPoint  operator*(double) const;
  ON_4dPoint  operator/(double) const;
  ON_4dPoint  operator+(const ON_4dPoint&) const; // sum w = sqrt(|w1*w2|)
  ON_4dPoint  operator-(const ON_4dPoint&) const; // difference w = sqrt(|w1*w2|)

  double operator*(const ON_4dPoint&) const;
  ON_4dPoint operator*(const ON_Xform&) const;

  // projective comparison
  // (i.e., [x,y,z,w] == [c*x,c*y,c*z,c*w] is true for nonzero c)
  bool operator==(ON_4dPoint) const;
  bool operator!=(const ON_4dPoint&) const;

  // index operators mimic double[4] behavior
  double& operator[](int);
  double operator[](int) const;

  /*
  Description
    If any coordinate of a point is ON_UNSET_VALUE,
    then the point is not valid.
  Returns:
    true if the point is valid.
  */
  bool IsValid() const;

  // set 4d point value
  void Set(double x,double y,double z,double w);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  void Zero();      // set all 4 coordinates to zero;
  bool Normalize(); // set so x^2 + y^2 + z^2 + w^2 = 1

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform(
        const ON_Xform&
        );
};

ON_DECL
ON_4dPoint operator*(double, const ON_4dPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_2dVector
//
class ON_CLASS ON_2dVector
{
public:
  double x, y;

  // Description:
  //   A index driven function to get unit axis vectors.
  // Parameters:
  //   index - [in] 0 returns (1,0), 1 returns (0,1)
  // Returns:
  //   Unit 2d vector with vector[i] = (i==index)?1:0;
  static const ON_2dVector& UnitVector(
    int // index
    );

  // use implicit destructor, copy constructor
  ON_2dVector();                     // not initialized
  ON_2dVector(const float*);         // from array of 2 floats
  ON_2dVector(const double*);        // from array of 2 doubles
  ON_2dVector(double x,double y);
  ON_2dVector(const ON_3dVector& ); // from 3d vector
  ON_2dVector(const ON_2dPoint& );  // from 2d point

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_2dVector&)
  ON_2dVector& operator=(const float*);  // vector = float[2] support
  ON_2dVector& operator=(const double*); // vector = double[2] support
  ON_2dVector& operator=(const ON_3dVector&);
  ON_2dVector& operator=(const ON_2dPoint&);

  ON_2dVector  operator-() const;

  ON_2dVector& operator*=(double);
  ON_2dVector& operator/=(double);
  ON_2dVector& operator+=(const ON_2dVector&);
  ON_2dVector& operator-=(const ON_2dVector&);

  ON_2dVector  operator*(double) const;
  double operator*(const ON_2dVector&) const; // inner (dot) product
  double operator*(const ON_2dPoint&) const; // inner (dot) product (point acting as vector)
  double operator*(const ON_2fVector&) const; // inner (dot) product
	ON_2dVector  operator/(double) const;
  ON_2dVector  operator+(const ON_2dVector&) const;
  ON_2dPoint   operator+(const ON_2dPoint&) const;
  ON_2dVector  operator-(const ON_2dVector&) const;

  double operator*(const ON_4dPoint&) const;
  ON_2dVector operator*(const ON_Xform&) const;

  bool operator==(const ON_2dVector&) const;
  bool operator!=(const ON_2dVector&) const;

  // dictionary order comparisons
  bool operator<=(const ON_2dVector&) const;
  bool operator>=(const ON_2dVector&) const;
  bool operator<(const ON_2dVector&) const;
  bool operator>(const ON_2dVector&) const;

  // index operators mimic double[2] behavior
  double& operator[](int);
  double operator[](int) const;

  /*
  Description
    If any coordinate of a point is ON_UNSET_VALUE,
    then the point is not valid.
  Returns:
    true if the point is valid.
  */
  bool IsValid() const;

  // set 2d vector value
  void Set(double x,double y);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  double LengthSquared() const;
  double Length() const;

	// Signed area of the parallelagram.  The volume element.
	// returns x*B.y - y*B.x
	double WedgeProduct(const ON_2dVector& B) const;

  bool Decompose( // Computes a, b such that this vector = a*X + b*Y
         // Returns false if unable to solve for a,b.  This happens
         // when X,Y is not really a basis.
         //
         // If X,Y is known to be an orthonormal frame,
         // then a = V*X, b = V*Y will compute
         // the same result more quickly.
         const ON_2dVector&, // X
         const ON_2dVector&, // Y
         double*, // a
         double*  // b
         ) const;

  int IsParallelTo(
        // returns  1: this and other vectors are parallel
        //         -1: this and other vectors are anti-parallel
        //          0: this and other vectors are not parallel
        //             or at least one of the vectors is zero
        const ON_2dVector& other,                           // other vector
        double angle_tolerance = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  bool IsPerpendicularTo(
        // returns true:  this and other vectors are perpendicular
        //         false: this and other vectors are not perpendicular
        //                or at least one of the vectors is zero
        const ON_2dVector& other,                           // other vector
        double angle_tolerance = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  void Zero(); // set all coordinates to zero;
  void Reverse(); // negate all coordinates
  bool Unitize();  // returns false if vector has zero length

  // Description:
  //   Test a vector to see if it is very short
  //
  // Parameters:
  //   tiny_tol - [in] (default = ON_ZERO_TOLERANCE) a nonzero
  //              value used as the coordinate zero tolerance.
  //
  // Returns:
  //   ( fabs(x) <= tiny_tol && fabs(y) <= tiny_tol )
  //
  bool IsTiny(
         double tiny_tol = ON_ZERO_TOLERANCE // tiny_tol
         ) const;

  // Returns:
  //   true if vector is the zero vector.
  bool IsZero() const;

  // set this vector to be perpendicular to another vector
  bool PerpendicularTo( // Result is not unitized.
                        // returns false if input vector is zero
        const ON_2dVector&
        );

  // set this vector to be perpendicular to a line defined by 2 points
  bool PerpendicularTo(
        const ON_2dPoint&,
        const ON_2dPoint&
        );

  // These transform the vector in place. The transformation matrix acts on
  // the left of the vector; i.e., result = transformation*vector
  void Transform(
        const ON_Xform& // can use ON_Xform here
        );

  void Rotate(
        double angle            // angle in radians
        );

  void Rotate(
        double sin_angle,       // sin(angle)
        double cos_angle        // cos(angle)
        );
};

ON_DECL
ON_2dVector operator*(double, const ON_2dVector&);

///////////////////////////////////////////////////////////////
//
// ON_2dVector utilities
//

ON_DECL
double
ON_DotProduct(
    const ON_2dVector&,
    const ON_2dVector&
    );

ON_DECL
ON_3dVector
ON_CrossProduct(
    const ON_2dVector&,
    const ON_2dVector&
    );

ON_DECL
double
ON_WedgeProduct(		// signed area of the parallelagram.  Volume element.
    const ON_2dVector& A, // returns A.x * B.y - A.y * B.x
    const ON_2dVector& B
    );

ON_DECL
bool
ON_IsOrthogonalFrame( // true if X, Y are nonzero and mutually perpindicular
    const ON_2dVector&, // X
    const ON_2dVector&  // Y
    );

ON_DECL
bool
ON_IsOrthonormalFrame( // true if X, Y are orthogonal and unit length
    const ON_2dVector&, // X
    const ON_2dVector&  // Y
    );

ON_DECL
bool
ON_IsRightHandFrame( // true if X, Y are orthonormal and right handed
    const ON_2dVector&, // X
    const ON_2dVector&  // Y
    );

////////////////////////////////////////////////////////////////
//
//   ON_3dVector
//
class ON_CLASS ON_3dVector
{
public:
  double x, y, z;

  // Description:
  //   A index driven function to get unit axis vectors.
  // Parameters:
  //   index - [in] 0 returns (1,0,0), 1 returns (0,1,0),
  //                2 returns (0,0,1)
  // Returns:
  //   Unit 3d vector with vector[i] = (i==index)?1:0;
  static const ON_3dVector& UnitVector(
    int // index
    );

  // use implicit destructor, copy constructor
  ON_3dVector();                     // not initialized
  ON_3dVector(const float*);         // from array of 3 floats
  ON_3dVector(const double*);        // from array of 3 doubles
  ON_3dVector(double x,double y,double z);
  ON_3dVector(const ON_2dVector& ); // from 2d vector
  ON_3dVector(const ON_3dPoint& );  // from 3d point

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_3dVector&)
  ON_3dVector& operator=(const float*);  // vector = float[3] support
  ON_3dVector& operator=(const double*); // vector = double[3] support
  ON_3dVector& operator=(const ON_2dVector&);
  ON_3dVector& operator=(const ON_3dPoint&);

  ON_3dVector  operator-() const;

  ON_3dVector& operator*=(double);
  ON_3dVector& operator/=(double);
  ON_3dVector& operator+=(const ON_3dVector&);
  ON_3dVector& operator-=(const ON_3dVector&);

  ON_3dVector  operator*(double) const;
  double operator*(const ON_3dVector&) const; // inner (dot) product
  double operator*(const ON_3dPoint&) const; // inner (dot) product
  double operator*(const ON_3fVector&) const; // inner (dot) product
  ON_3dVector  operator/(double) const;
  ON_3dVector  operator+(const ON_3dVector&) const;
  ON_3dPoint   operator+(const ON_3dPoint&) const;
  ON_3dVector  operator-(const ON_3dVector&) const;

  double operator*(const ON_4dPoint&) const;
  ON_3dVector operator*(const ON_Xform&) const;

  bool operator==(const ON_3dVector&) const;
  bool operator!=(const ON_3dVector&) const;

  // dictionary order comparisons
  bool operator<=(const ON_3dVector&) const;
  bool operator>=(const ON_3dVector&) const;
  bool operator<(const ON_3dVector&) const;
  bool operator>(const ON_3dVector&) const;

  // index operators mimic double[3] behavior
  double& operator[](int);
  double operator[](int) const;

  /*
  Description
    If any coordinate of a point is ON_UNSET_VALUE,
    then the point is not valid.
  Returns:
    true if the point is valid.
  */
  bool IsValid() const;

  // set 3d vector value
  void Set(double x,double y,double z);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  double LengthSquared() const;
  double Length() const;

  bool Decompose( // Computes a, b, c such that this vector = a*X + b*Y + c*Z
         // Returns false if unable to solve for a,b,c.  This happens
         // when X,Y,Z is not really a basis.
         //
         // If X,Y,Z is known to be an orthonormal frame,
         // then a = V*X, b = V*Y, c = V*Z will compute
         // the same result more quickly.
         const ON_3dVector&, // X
         const ON_3dVector&, // Y
         const ON_3dVector&, // Z
         double*, // a
         double*, // b
         double*  // c
         ) const;

  int IsParallelTo(
        // returns  1: this and other vectors are parallel
        //         -1: this and other vectors are anti-parallel
        //          0: this and other vectors are not parallel
        //             or at least one of the vectors is zero
        const ON_3dVector& other,                           // other vector
        double angle_tolerance = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  bool IsPerpendicularTo(
        // returns true:  this and other vectors are perpendicular
        //         false: this and other vectors are not perpendicular
        //                or at least one of the vectors is zero
        const ON_3dVector& other,                           // other vector
        double angle_tolerance = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  double Fuzz( double tolerance = ON_ZERO_TOLERANCE ) const; // tolerance to use when comparing 3d vectors

  void Zero(); // set all coordinates to zero;
  void Reverse(); // negate all coordinates
  bool Unitize();  // returns false if vector has zero length

  // Description:
  //   Test a vector to see if it is very short
  //
  // Parameters:
  //   tiny_tol - [in] (default = ON_ZERO_TOLERANCE) a nonzero
  //              value used as the coordinate zero tolerance.
  //
  // Returns:
  //   ( fabs(x) <= tiny_tol && fabs(y) <= tiny_tol && fabs(z) <= tiny_tol )
  //
  bool IsTiny(
         double tiny_tol = ON_ZERO_TOLERANCE // tiny_tol
         ) const;

  // Returns:
  //   true if vector is the zero vector.
  bool IsZero() const;

  // set this vector to be perpendicular to another vector
  bool PerpendicularTo( // Result is not unitized.
                        // returns false if input vector is zero
        const ON_3dVector&
        );

  // set this vector to be perpendicular to a plane defined by 3 points
  bool PerpendicularTo(
               // about 3 times slower than
               //    ON_3dVector N = ON_CrossProduct(P1-P0,P2-P0);
               //    N.Unitize();
               // returns false if points are coincident or colinear
         const ON_3dPoint&, const ON_3dPoint&, const ON_3dPoint&
         );

  // These transform the vector in place. The transformation matrix acts on
  // the left of the vector; i.e., result = transformation*vector
  void Transform(
        const ON_Xform& // can use ON_Xform here
        );

  void Rotate(
        double angle,           // angle in radians
        const ON_3dVector& axis // axis of rotation
        );

  void Rotate(
        double sin_angle,        // sin(angle)
        double cos_angle,        // cos(angle)
        const ON_3dVector& axis  // axis of rotation
        );
};

class ON_CLASS ON_3dRay
{
public:
  ON_3dRay();
  ~ON_3dRay();

  ON_3dPoint  m_P;
  ON_3dVector m_V;
};

/*
Description:
  Typically the vector portion is a unit vector and
  m_d = -(x*P.x + y*P.y + z*P.z) for a point P on the plane.
*/
class ON_CLASS ON_PlaneEquation : public ON_3dVector
{
public:
  // C++ defaults for construction, destruction, copys, and operator=
  // work fine.

  bool IsValid() const;

  /*
  Description:
    Sets (x,y,z) to a unitized N and then sets
    d = -(x*P.x + y*P.y + z*P.z).
  Parameters:
    P - [in] point on the plane
    N - [in] vector perpindicular to the plane
  Returns:
     true if input is valid.
  */
  bool Create( ON_3dPoint P, ON_3dVector N );

  /*
  Description:
    Evaluate the plane at a point.
  Parameters:
    P - [in]
  Returns:
    x*P.x + y*P.y + z*P.z + d;
  */
  double ValueAt(ON_3dPoint P) const;
  double ValueAt(ON_4dPoint P) const;
  double ValueAt(ON_3dVector P) const;
  double ValueAt(double x, double y, double z) const;

  /*
  Description:
    Transform the plane equation so that, if e0 is the initial
    equation, e1 is transformed equation and P is a point,
    then e0.ValueAt(P) = e1.ValueAt(xform*P).
  Parameters:
    xform - [in]
      Invertable transformation.
  Returns:
    True if the plane equation was successfully transformed.
    False if xform is not invertable or the equation is not
    valid.
  Remarks:
    This function has to invert xform.  If you have apply the
    same transformation to a bunch of planes, then it will be
    more efficient to calculate xform's inverse transpose
    and apply the resultingt transformation to the equation's
    coefficients as if they were 4d point coordinates.
  */
  bool Transform( const ON_Xform& xform );

  /*
  Description:
    Get point on plane that is closest to a given point.
  Parameters:
    point - [in]
  Returns:
    A 3d point on the plane that is closest to the input point.
  */
  ON_3dPoint ClosestPointTo( ON_3dPoint point ) const;

  /*
  Description:
    Get the minimum value of the plane equation
    on a bounding box.
  Parameters:
    bbox - [in]
  Returns:
    Minimum value of the plane equation on the bounding box.
  */
  double MinimumValueAt(const ON_BoundingBox& bbox) const;

  /*
  Description:
    Get the maximum value of the plane equation
    on a bounding box.
  Parameters:
    bbox - [in]
  Returns:
    Maximum value of the plane equation on the bounding box.
  */
  double MaximumValueAt(const ON_BoundingBox& bbox) const;


  /*
  Description:
    Get the minimum value of the plane equation
    on a bounding box.
  Parameters:
    crvleafbox - [in]
  Returns:
    Minimum value of the plane equation on the curve leaf box.
  */
  double MinimumValueAt(const class ON_CurveLeafBox& crvleafbox) const;

  /*
  Description:
    Get the maximum value of the plane equation
    on a bounding box.
  Parameters:
    crvleafbox - [in]
  Returns:
    Maximum value of the plane equation on the curve leaf box.
  */
  double MaximumValueAt(const class ON_CurveLeafBox& crvleafbox) const;

  /*
  Description:
    Get the minimum value of the plane equation
    on a bounding box.
  Parameters:
    bbox - [in]
  Returns:
    Minimum value of the plane equation on the bounding box.
  */
  double MinimumValueAt(const class ON_SurfaceLeafBox& srfleafbox) const;

  /*
  Description:
    Get the maximum value of the plane equation
    on a bounding box.
  Parameters:
    bbox - [in]
  Returns:
    Maximum value of the plane equation on the bounding box.
  */
  double MaximumValueAt(const class ON_SurfaceLeafBox& srfleafbox) const;


  /*
  Description:
    Test points on a bezier curve to see if they are near the plane.
  Parameters:
    bezcrv - [in]
    s0 - [in]
    s1 - [in] the interval from s0 to s1 is tested (s0 < s1)
    sample_count - [in] number of interior points to test.
                Numbers like 1, 3, 7, 15, ... work best.
    endpoint_tolerance - [in] If >= 0, then the end points are
              tested to see if the distance from the endpoints
              is <= endpoint_tolerance.
    interior_tolerance - [in] (>=0 and >=endpoint_tolerance)
              This tolerance is used to test the interior sample points.
    smin - [put]  If not NULL, *smin = bezier parameter of nearest
                  test point.
    smax - [put]  If not NULL, *smax = bezier parameter of farthest
                  test point.  If false is returned, this is the
                  parameter of the test point that failed.
  Returns:
    True if all the tested points passed the tolerance test.
    False if at least one tested point failed the tolerance test.
    (The test terminates when the first failure is encountered.)
  */
  bool IsNearerThan(
          const class ON_BezierCurve& bezcrv,
          double s0,
          double s1,
          int sample_count,
          double endpoint_tolerance,
          double interior_tolerance,
          double* smin,
          double* smax
          ) const;

  double d; // 4th coefficient of the plane equation.
};

ON_DECL
ON_3dVector operator*(double, const ON_3dVector&);

///////////////////////////////////////////////////////////////
//
// ON_3dVector utilities
//

ON_DECL
double
ON_DotProduct(
    const ON_3dVector&,
    const ON_3dVector&
    );


ON_DECL
ON_3dVector
ON_CrossProduct(
    const ON_3dVector&,
    const ON_3dVector&
    );

ON_DECL
ON_3dVector
ON_CrossProduct( // 3d cross product for old fashioned arrays
    const double*, // array of 3d doubles
    const double*  // array of 3d doubles
    );

ON_DECL
double
ON_TripleProduct(
    const ON_3dVector&,
    const ON_3dVector&,
    const ON_3dVector&
    );

ON_DECL
double
ON_TripleProduct(  // 3d triple product for old fashioned arrays
    const double*, // array of 3d doubles
    const double*, // array of 3d doubles
    const double*  // array of 3d doubles
    );

ON_DECL
bool
ON_IsOrthogonalFrame( // true if X, Y, Z are nonzero and mutually perpindicular
    const ON_3dVector&, // X
    const ON_3dVector&, // Y
    const ON_3dVector&  // Z
    );

ON_DECL
bool
ON_IsOrthonormalFrame( // true if X, Y, Z are orthogonal and unit length
    const ON_3dVector&, // X
    const ON_3dVector&, // Y
    const ON_3dVector&  // Z
    );

ON_DECL
bool
ON_IsRightHandFrame( // true if X, Y, Z are orthonormal and right handed
    const ON_3dVector&, // X
    const ON_3dVector&, // Y
    const ON_3dVector&  // Z
    );

///////////////////////////////////////////////////////////////
//
// common points and vectors
//
// ON_unset_point is obsolete - use ON_UNSET_POINT
#define ON_unset_point ON_UNSET_POINT

extern ON_EXTERN_DECL const ON_3dPoint  ON_UNSET_POINT; // (ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)
extern ON_EXTERN_DECL const ON_3dVector ON_UNSET_VECTOR; // (ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)
extern ON_EXTERN_DECL const ON_3dPoint  ON_origin; // (0.0, 0.0, 0.0)
extern ON_EXTERN_DECL const ON_3dVector ON_xaxis; // (1.0, 0.0, 0.0)
extern ON_EXTERN_DECL const ON_3dVector ON_yaxis; // (0.0, 1.0, 0.0)
extern ON_EXTERN_DECL const ON_3dVector ON_zaxis; // (0.0, 0.0, 1.0)

#include "opennurbs_fpoint.h"

////////////////////////////////////////////////////////////////
//
//   ON_SurfaceCurvature
//
class ON_CLASS ON_SurfaceCurvature
{
public:
  double k1, k2; // principal curvatures

  double GaussianCurvature() const;
  double MeanCurvature() const;
  double MinimumRadius() const;
  double MaximumRadius() const;
};

#endif

@


1.2
log
@Bound method prototype
@
text
@d1 1
a1 1
/* $Header: /cvsroot/brlcad/brlcad/src/other/openNURBS/opennurbs_point.h,v 1.1 2007/01/05 15:20:35 brlcad Exp $ */
d11 1
a11 1
//				
d81 1
a81 1
    double t0, 
d89 1
a89 1
    normalized_parameter - [in] 
d98 1
a98 1
    ) const; 
d101 2
a102 2
    ) const; 
  
d109 1
a109 1
    Normalized parameter x so that 
d136 1
a136 1
	bool MakeIncreasing();		// returns true if resulting interval IsIncreasing() 
d149 1
a149 1
  /* 
d154 1
a154 1
    bTestOpenInterval - [in] 
d166 1
a166 1
  /* 
d179 1
a179 1
  bool Includes( 
d197 1
a197 1
  // If the intersection is not empty, then 
d208 1
a208 1
  // If the intersection is not empty, then 
d215 1
a215 1
         const ON_Interval&, 
d238 1
a238 1
         const ON_Interval&, 
d331 1
a331 1
  void Transform( 
d427 1
a427 1
  
d437 1
a437 1
  void Transform( 
d441 1
a441 1
  void Rotate( 
d447 1
a447 1
  void Rotate( 
d507 1
a507 1
  // projective comparison 
d539 1
a539 1
  void Transform( 
d594 1
a594 1
  double operator*(const ON_2fVector&) const; // inner (dot) product	
d654 1
a654 1
  int IsParallelTo( 
d659 1
a659 1
        const ON_2dVector& other,                           // other vector     
d667 1
a667 1
        const ON_2dVector& other,                           // other vector     
d694 1
a694 1
  bool PerpendicularTo( // Result is not unitized. 
d696 1
a696 1
        const ON_2dVector& 
d700 3
a702 3
  bool PerpendicularTo( 
        const ON_2dPoint&, 
        const ON_2dPoint& 
d707 1
a707 1
  void Transform( 
d711 1
a711 1
  void Rotate( 
d715 1
a715 1
  void Rotate( 
d730 4
a733 4
double 
ON_DotProduct( 
    const ON_2dVector&, 
    const ON_2dVector& 
d737 1
a737 1
ON_3dVector 
d739 2
a740 2
    const ON_2dVector&, 
    const ON_2dVector& 
d744 1
a744 1
double			 
d746 2
a747 2
    const ON_2dVector& A, // returns A.x * B.y - A.y * B.x 
    const ON_2dVector& B 
d751 1
a751 1
bool 
d758 1
a758 1
bool 
d765 1
a765 1
bool 
d783 1
a783 1
  //   index - [in] 0 returns (1,0,0), 1 returns (0,1,0), 
d808 1
a808 1
  
d877 1
a877 1
  int IsParallelTo( 
d882 1
a882 1
        const ON_3dVector& other,                           // other vector     
d890 1
a890 1
        const ON_3dVector& other,                           // other vector     
d919 1
a919 1
  bool PerpendicularTo( // Result is not unitized. 
d921 1
a921 1
        const ON_3dVector& 
d927 1
a927 1
               //    ON_3dVector N = ON_CrossProduct(P1-P0,P2-P0); 
d930 1
a930 1
         const ON_3dPoint&, const ON_3dPoint&, const ON_3dPoint& 
d935 1
a935 1
  void Transform( 
d939 1
a939 1
  void Rotate( 
d944 1
a944 1
  void Rotate( 
d1035 1
a1035 1
    bbox - [in] 
d1046 1
a1046 1
    bbox - [in] 
d1058 1
a1058 1
    crvleafbox - [in] 
d1069 1
a1069 1
    crvleafbox - [in] 
d1080 1
a1080 1
    bbox - [in] 
d1091 1
a1091 1
    bbox - [in] 
d1105 1
a1105 1
    sample_count - [in] number of interior points to test.  
d1107 2
a1108 2
    endpoint_tolerance - [in] If >= 0, then the end points are 
              tested to see if the distance from the endpoints 
d1110 1
a1110 1
    interior_tolerance - [in] (>=0 and >=endpoint_tolerance) 
d1122 1
a1122 1
  bool IsNearerThan( 
d1145 4
a1148 4
double 
ON_DotProduct( 
    const ON_3dVector&, 
    const ON_3dVector& 
d1153 1
a1153 1
ON_3dVector 
d1155 2
a1156 2
    const ON_3dVector&, 
    const ON_3dVector& 
d1160 1
a1160 1
ON_3dVector 
d1167 2
a1168 2
double 
ON_TripleProduct( 
d1175 1
a1175 1
double 
d1183 1
a1183 1
bool 
d1187 1
a1187 1
    const ON_3dVector&  // Z 
d1191 1
a1191 1
bool 
d1195 1
a1195 1
    const ON_3dVector&  // Z 
d1199 1
a1199 1
bool 
d1203 1
a1203 1
    const ON_3dVector&  // Z 
@


1.1
log
@initial import of the openNURBS initiative's nurbs toolkit.  the toolkit consists of code for reading/writing .3dm files used by Rhino as well as nurbs evaluation and other geometry processing facilities.  the library is being evaluated for .3dm support as well as potentially gutting the existing nurbs primitive and using openNURBS evaluation routines instead (still probably need to implement ray shot evaluation).  this is version 200612050 (aka 4.0).

this is also a C++ library, the first integration of an external C++ dependency into BRL-CAD.  additional support/infrastructure will be needed to support this in configure.  there's still, however, a policy/convention of "containment" so that C++ does not propagate into the existing BRL-CAD libraries.  any additions that utilize c++ still have to be entirely modular (and optional) for the time being.
@
text
@d1 1
a1 1
/* $Header: /src4/opennurbs/opennurbs_point.h 19    6/08/06 11:01p A-steve $ */
d241 3
@

