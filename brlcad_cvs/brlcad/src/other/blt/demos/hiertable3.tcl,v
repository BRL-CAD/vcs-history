head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.4
	rel-7-10-2:1.2
	rel-7-10-0:1.2
	rel-7-8-4:1.2
	rel-7-8-2:1.2
	rel-7-8-0:1.2
	trimnurbs-branch:1.2.0.2
	help:1.2
	temp_tag:1.2
	bobWinPort-20051223-freeze:1.1.2.1
	postmerge-20051223-bobWinPort:1.2
	bobWinPort:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2007.09.14.15.21.19;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.23.21.26.36;	author bob1961;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.08.19.38.47;	author bob1961;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.09.08.19.38.47;	author bob1961;	state Exp;
branches;
next	;


desc
@@


1.3
log
@removed trailing whitespace
@
text
@#!../src/bltwish

package require BLT
# --------------------------------------------------------------------------
# Starting with Tcl 8.x, the BLT commands are stored in their own
# namespace called "blt".  The idea is to prevent name clashes with
# Tcl commands and variables from other packages, such as a "table"
# command in two different packages.
#
# You can access the BLT commands in a couple of ways.  You can prefix
# all the BLT commands with the namespace qualifier "blt::"
#
#    blt::graph .g
#    blt::table . .g -resize both
#
# or you can import all the command into the global namespace.
#
#    namespace import blt::*
#    graph .g
#    table . .g -resize both
#
# --------------------------------------------------------------------------
if { $tcl_version >= 8.0 } {
    namespace import blt::*
    namespace import -force blt::tile::*
}
source scripts/demo.tcl

set saved [pwd]

#blt::bltdebug 100

image create photo bgTexture -file ./images/rain.gif

set imageList {}
foreach f [glob ./images/mini-*.gif] {
    lappend imageList [image create photo -file $f]
}

#option add *Hiertable.Tile	bgTexture
option add *Hiertable.ScrollTile  yes
#option add *Hiertable.Column.background grey90
option add *Hiertable.titleShadow { grey80 }
option add *Hiertable.titleFont {*-helvetica-bold-r-*-*-11-*-*-*-*-*-*-*}

hiertable .h  -width 0\
    -yscrollcommand { .vs set } \
    -xscrollcommand { .hs set }  \
    -selectmode multiple \
    -hideroot yes

#.h configure -icons "" -activeicons ""

.h column configure treeView -text "View"
.h column insert 0 mtime atime gid
.h column insert end nlink mode type ctime uid ino size dev
.h column configure uid -background \#eaeaff -style text
.h column configure mtime -hide no -bg \#ffeaea -style text
.h column configure size gid nlink uid ino dev -justify right -style text
.h column configure treeView -hide no -edit no -style text

scrollbar .vs -orient vertical -command { .h yview }
scrollbar .hs -orient horizontal -command { .h xview }
table . \
    0,0 .h  -fill both \
    0,1 .vs -fill y \
    1,0 .hs -fill x

proc FormatSize { size } {
   set string ""
   while { $size > 0 } {
       set rem [expr $size % 1000]
       set size [expr $size / 1000]
       if { $size > 0 } {
           set rem [format "%03d" $rem]
       }
       if { $string != "" } {
           set string "$rem,$string"
       } else {
           set string "$rem"
       }
   }
   return $string
}

array set modes {
   0	---
   1    --x
   2    -w-
   3    -wx
   4    r--
   5    r-x
   6    rw-
   7    rwx
}

proc FormatMode { mode } {
   global modes

   set mode [format %o [expr $mode & 07777]]
   set owner $modes([string index $mode 0])
   set group $modes([string index $mode 1])
   set world $modes([string index $mode 2])

   return "${owner}${group}${world}"
}

table configure . c1 r1 -resize none
image create photo fileImage -file images/stopsign.gif

proc DoFind { dir parent } {
    global count
    set saved [pwd]

    cd $dir
    foreach f [lsort [glob -nocomplain *]] {
	set node [tree0 insert $parent -label $f]
	if { [catch { file stat $f info }] == 0 } {
	    if 0 {
	    if { $info(type) == "file" } {
		set info(type) @@fileImage
	    } else {
		set info(type) ""
	    }
	    }
	    set info(mtime) [clock format $info(mtime) -format "%b %d, %Y"]
	    set info(atime) [clock format $info(atime) -format "%b %d, %Y"]
	    set info(ctime) [clock format $info(ctime) -format "%b %d, %Y"]
            set info(size)  [FormatSize $info(size)]
	    set info(mode)  [FormatMode $info(mode)]
	    eval tree0 set $node [array get info]
	}
	incr count
	if { [file isdirectory $f] } {
	    DoFind $f $node
	}
    }
    cd $saved
}

proc Find { dir } {
    global count
    set count 0
    catch { file stat $dir info }
    incr count
    tree create tree0
    tree0 label root [file tail $dir]
    eval tree0 set root [array get info]
    DoFind $dir root
    puts "$count entries"
}

proc GetAbsolutePath { dir } {
    set saved [pwd]
    cd $dir
    set path [pwd]
    cd $saved
    return $path
}

set top [GetAbsolutePath ..]
Find $top

focus .h

.h configure -tree tree0 -separator /

set nodes [.h find -glob -name *.c]
eval .h entry configure $nodes -foreground green4
set nodes [.h find -glob -name *.h]
eval .h entry configure $nodes -foreground cyan4
set nodes [.h find -glob -name *.o]
eval .h entry configure $nodes -foreground red4

cd $saved

.h column bind all <ButtonRelease-3> {
    %W configure -flat no
}

proc SortColumn { column } {
    set old [.h sort cget -column]
    set decreasing 0
    if { "$old" == "$column" } {
	set decreasing [.h sort cget -decreasing]
	set decreasing [expr !$decreasing]
    }
    .h sort configure -decreasing $decreasing -column $column
    .h configure -flat yes
    .h sort auto yes
    blt::busy hold .h
    update
    blt::busy release .h
}

foreach column [.h column names] {
    .h column configure $column -command [list SortColumn $column]
}
@


1.2
log
@Merge of bobWinPort
@
text
@d5 1
a5 1
# Starting with Tcl 8.x, the BLT commands are stored in their own 
d8 1
a8 1
# command in two different packages.  
d12 1
a12 1
#  
d15 1
a15 1
# 
d50 1
a50 1
    -hideroot yes 
d55 4
a58 4
.h column insert 0 mtime atime gid 
.h column insert end nlink mode type ctime uid ino size dev 
.h column configure uid -background \#eaeaff -style text 
.h column configure mtime -hide no -bg \#ffeaea -style text 
d60 1
a60 1
.h column configure treeView -hide no -edit no -style text 
d76 1
a76 1
       } 
d82 1
a82 1
   } 
d91 1
a91 1
   4    r-- 
d112 1
a112 1
    global count 
d156 1
a156 1
    set path [pwd] 
d173 1
a173 1
eval .h entry configure $nodes -foreground red4 
d182 1
a182 1
    set old [.h sort cget -column] 
d188 1
a188 1
    .h sort configure -decreasing $decreasing -column $column 
@


1.1
log
@file hiertable3.tcl was initially added on branch bobWinPort.
@
text
@d1 198
@


1.1.2.1
log
@Initial check-in
@
text
@a0 198
#!../src/bltwish

package require BLT
# --------------------------------------------------------------------------
# Starting with Tcl 8.x, the BLT commands are stored in their own 
# namespace called "blt".  The idea is to prevent name clashes with
# Tcl commands and variables from other packages, such as a "table"
# command in two different packages.  
#
# You can access the BLT commands in a couple of ways.  You can prefix
# all the BLT commands with the namespace qualifier "blt::"
#  
#    blt::graph .g
#    blt::table . .g -resize both
# 
# or you can import all the command into the global namespace.
#
#    namespace import blt::*
#    graph .g
#    table . .g -resize both
#
# --------------------------------------------------------------------------
if { $tcl_version >= 8.0 } {
    namespace import blt::*
    namespace import -force blt::tile::*
}
source scripts/demo.tcl

set saved [pwd]

#blt::bltdebug 100

image create photo bgTexture -file ./images/rain.gif

set imageList {}
foreach f [glob ./images/mini-*.gif] {
    lappend imageList [image create photo -file $f]
}

#option add *Hiertable.Tile	bgTexture
option add *Hiertable.ScrollTile  yes
#option add *Hiertable.Column.background grey90
option add *Hiertable.titleShadow { grey80 }
option add *Hiertable.titleFont {*-helvetica-bold-r-*-*-11-*-*-*-*-*-*-*}

hiertable .h  -width 0\
    -yscrollcommand { .vs set } \
    -xscrollcommand { .hs set }  \
    -selectmode multiple \
    -hideroot yes 

#.h configure -icons "" -activeicons ""

.h column configure treeView -text "View"
.h column insert 0 mtime atime gid 
.h column insert end nlink mode type ctime uid ino size dev 
.h column configure uid -background \#eaeaff -style text 
.h column configure mtime -hide no -bg \#ffeaea -style text 
.h column configure size gid nlink uid ino dev -justify right -style text
.h column configure treeView -hide no -edit no -style text 

scrollbar .vs -orient vertical -command { .h yview }
scrollbar .hs -orient horizontal -command { .h xview }
table . \
    0,0 .h  -fill both \
    0,1 .vs -fill y \
    1,0 .hs -fill x

proc FormatSize { size } {
   set string ""
   while { $size > 0 } {
       set rem [expr $size % 1000]
       set size [expr $size / 1000]
       if { $size > 0 } {
           set rem [format "%03d" $rem]
       } 
       if { $string != "" } {
           set string "$rem,$string"
       } else {
           set string "$rem"
       }
   } 
   return $string
}

array set modes {
   0	---
   1    --x
   2    -w-
   3    -wx
   4    r-- 
   5    r-x
   6    rw-
   7    rwx
}

proc FormatMode { mode } {
   global modes

   set mode [format %o [expr $mode & 07777]]
   set owner $modes([string index $mode 0])
   set group $modes([string index $mode 1])
   set world $modes([string index $mode 2])

   return "${owner}${group}${world}"
}

table configure . c1 r1 -resize none
image create photo fileImage -file images/stopsign.gif

proc DoFind { dir parent } {
    global count 
    set saved [pwd]

    cd $dir
    foreach f [lsort [glob -nocomplain *]] {
	set node [tree0 insert $parent -label $f]
	if { [catch { file stat $f info }] == 0 } {
	    if 0 {
	    if { $info(type) == "file" } {
		set info(type) @@fileImage
	    } else {
		set info(type) ""
	    }
	    }
	    set info(mtime) [clock format $info(mtime) -format "%b %d, %Y"]
	    set info(atime) [clock format $info(atime) -format "%b %d, %Y"]
	    set info(ctime) [clock format $info(ctime) -format "%b %d, %Y"]
            set info(size)  [FormatSize $info(size)]
	    set info(mode)  [FormatMode $info(mode)]
	    eval tree0 set $node [array get info]
	}
	incr count
	if { [file isdirectory $f] } {
	    DoFind $f $node
	}
    }
    cd $saved
}

proc Find { dir } {
    global count
    set count 0
    catch { file stat $dir info }
    incr count
    tree create tree0
    tree0 label root [file tail $dir]
    eval tree0 set root [array get info]
    DoFind $dir root
    puts "$count entries"
}

proc GetAbsolutePath { dir } {
    set saved [pwd]
    cd $dir
    set path [pwd] 
    cd $saved
    return $path
}

set top [GetAbsolutePath ..]
Find $top

focus .h

.h configure -tree tree0 -separator /

set nodes [.h find -glob -name *.c]
eval .h entry configure $nodes -foreground green4
set nodes [.h find -glob -name *.h]
eval .h entry configure $nodes -foreground cyan4
set nodes [.h find -glob -name *.o]
eval .h entry configure $nodes -foreground red4 

cd $saved

.h column bind all <ButtonRelease-3> {
    %W configure -flat no
}

proc SortColumn { column } {
    set old [.h sort cget -column] 
    set decreasing 0
    if { "$old" == "$column" } {
	set decreasing [.h sort cget -decreasing]
	set decreasing [expr !$decreasing]
    }
    .h sort configure -decreasing $decreasing -column $column 
    .h configure -flat yes
    .h sort auto yes
    blt::busy hold .h
    update
    blt::busy release .h
}

foreach column [.h column names] {
    .h column configure $column -command [list SortColumn $column]
}
@

