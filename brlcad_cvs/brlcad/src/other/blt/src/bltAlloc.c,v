head	1.3;
access;
symbols
	rel-7-10-4:1.2
	STABLE:1.2.0.4
	rel-7-10-2:1.2
	rel-7-10-0:1.2
	rel-7-8-4:1.2
	rel-7-8-2:1.2
	rel-7-8-0:1.2
	trimnurbs-branch:1.2.0.2
	help:1.2
	temp_tag:1.2
	bobWinPort-20051223-freeze:1.1.2.1
	postmerge-20051223-bobWinPort:1.2
	bobWinPort:1.1.0.2;
locks; strict;
comment	@ * @;


1.3
date	2007.09.14.15.21.25;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.23.21.26.41;	author bob1961;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.08.19.38.48;	author bob1961;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.09.08.19.38.48;	author bob1961;	state Exp;
branches;
next	;


desc
@@


1.3
log
@removed trailing whitespace
@
text
@#include "bltInt.h"

#ifndef linux
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif /* HAVE_MALLOC_H */
#endif

/*
 * Blt_MallocProcPtr, Blt_FreeProcPtr --
 *
 *	These global variables allow you to override the default
 *	memory allocation/deallocation routines, simply by setting the
 *	pointers to your own C functions.  By default, we try to use
 *	the same memory allocation scheme that Tcl is using: generally
 *	that's Tcl_Alloc and Tcl_Free.
 */
#ifdef WIN32

#ifdef __GNUC__
extern char *Tcl_Alloc _ANSI_ARGS_((unsigned int size));
extern void Tcl_Free _ANSI_ARGS_((char * ptr));
extern char *Tcl_Realloc _ANSI_ARGS_((char *ptr, unsigned int size));
#endif /*__GNUC__*/

Blt_MallocProc *Blt_MallocProcPtr = (Blt_MallocProc *)Tcl_Alloc;
Blt_FreeProc *Blt_FreeProcPtr = (Blt_FreeProc *)Tcl_Free;
Blt_ReallocProc *Blt_ReallocProcPtr = (Blt_ReallocProc *)Tcl_Realloc;

#else

/*
 * Try to use the same memory allocator/deallocator that Tcl is
 * using. Before 8.1 it used malloc/free.
 */

#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0))
/*
 * We're pointing to the private TclpAlloc/TclpFree instead of public
 * Tcl_Alloc/Tcl_Free routines because they don't automatically cause
 * a panic when not enough memory is available. There are cases (such
 * as allocating a very large vector) where it's recoverable.
 */
EXTERN Blt_MallocProc TclpAlloc;
EXTERN Blt_FreeProc TclpFree;
EXTERN Blt_ReallocProc TclpRealloc;

Blt_MallocProc *Blt_MallocProcPtr = TclpAlloc;
Blt_FreeProc *Blt_FreeProcPtr = TclpFree;
Blt_ReallocProc *Blt_ReallocProcPtr = TclpRealloc;
#else

Blt_MallocProc *Blt_MallocProcPtr = malloc;
Blt_FreeProc *Blt_FreeProcPtr = free;
Blt_ReallocProc *Blt_ReallocProcPtr = realloc;

#endif /* >= 8.1.0 */
#endif /* WIN32 */

void *
Blt_Calloc(nElems, sizeOfElem)
    unsigned int nElems;
    size_t sizeOfElem;
{
    char *ptr;
    size_t size;

    size = nElems * sizeOfElem;
    ptr = Blt_Malloc(size);
    if (ptr != NULL) {
	memset(ptr, 0, size);
    }
    return ptr;
}

/*
 *----------------------------------------------------------------------
 *
 * Blt_Strdup --
 *
 *      Create a copy of the string from heap storage.
 *
 * Results:
 *      Returns a pointer to the need string copy.
 *
 *----------------------------------------------------------------------
 */
char *
Blt_Strdup(string)
    CONST char *string;
{
    size_t size;
    char *ptr;

    size = strlen(string) + 1;
    ptr = Blt_Malloc(size * sizeof(char));
    if (ptr != NULL) {
	strcpy(ptr, string);
    }
    return ptr;
}

@


1.2
log
@Merge of bobWinPort
@
text
@d27 2
a28 2
Blt_FreeProc *Blt_FreeProcPtr = (Blt_FreeProc *)Tcl_Free; 
Blt_ReallocProc *Blt_ReallocProcPtr = (Blt_ReallocProc *)Tcl_Realloc; 
d32 1
a32 1
/* 
d37 2
a38 2
#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0)) 
/* 
d41 1
a41 1
 * a panic when not enough memory is available. There are cases (such 
d49 2
a50 2
Blt_FreeProc *Blt_FreeProcPtr = TclpFree; 
Blt_ReallocProc *Blt_ReallocProcPtr = TclpRealloc; 
d54 1
a54 1
Blt_FreeProc *Blt_FreeProcPtr = free; 
d62 1
a62 1
    unsigned int nElems; 
@


1.1
log
@file bltAlloc.c was initially added on branch bobWinPort.
@
text
@d1 102
@


1.1.2.1
log
@Initial check-in
@
text
@a0 102
#include "bltInt.h"

#ifndef linux
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif /* HAVE_MALLOC_H */
#endif

/*
 * Blt_MallocProcPtr, Blt_FreeProcPtr --
 *
 *	These global variables allow you to override the default
 *	memory allocation/deallocation routines, simply by setting the
 *	pointers to your own C functions.  By default, we try to use
 *	the same memory allocation scheme that Tcl is using: generally
 *	that's Tcl_Alloc and Tcl_Free.
 */
#ifdef WIN32

#ifdef __GNUC__
extern char *Tcl_Alloc _ANSI_ARGS_((unsigned int size));
extern void Tcl_Free _ANSI_ARGS_((char * ptr));
extern char *Tcl_Realloc _ANSI_ARGS_((char *ptr, unsigned int size));
#endif /*__GNUC__*/

Blt_MallocProc *Blt_MallocProcPtr = (Blt_MallocProc *)Tcl_Alloc;
Blt_FreeProc *Blt_FreeProcPtr = (Blt_FreeProc *)Tcl_Free; 
Blt_ReallocProc *Blt_ReallocProcPtr = (Blt_ReallocProc *)Tcl_Realloc; 

#else

/* 
 * Try to use the same memory allocator/deallocator that Tcl is
 * using. Before 8.1 it used malloc/free.
 */

#if (TCL_VERSION_NUMBER >= _VERSION(8,1,0)) 
/* 
 * We're pointing to the private TclpAlloc/TclpFree instead of public
 * Tcl_Alloc/Tcl_Free routines because they don't automatically cause
 * a panic when not enough memory is available. There are cases (such 
 * as allocating a very large vector) where it's recoverable.
 */
EXTERN Blt_MallocProc TclpAlloc;
EXTERN Blt_FreeProc TclpFree;
EXTERN Blt_ReallocProc TclpRealloc;

Blt_MallocProc *Blt_MallocProcPtr = TclpAlloc;
Blt_FreeProc *Blt_FreeProcPtr = TclpFree; 
Blt_ReallocProc *Blt_ReallocProcPtr = TclpRealloc; 
#else

Blt_MallocProc *Blt_MallocProcPtr = malloc;
Blt_FreeProc *Blt_FreeProcPtr = free; 
Blt_ReallocProc *Blt_ReallocProcPtr = realloc;

#endif /* >= 8.1.0 */
#endif /* WIN32 */

void *
Blt_Calloc(nElems, sizeOfElem)
    unsigned int nElems; 
    size_t sizeOfElem;
{
    char *ptr;
    size_t size;

    size = nElems * sizeOfElem;
    ptr = Blt_Malloc(size);
    if (ptr != NULL) {
	memset(ptr, 0, size);
    }
    return ptr;
}

/*
 *----------------------------------------------------------------------
 *
 * Blt_Strdup --
 *
 *      Create a copy of the string from heap storage.
 *
 * Results:
 *      Returns a pointer to the need string copy.
 *
 *----------------------------------------------------------------------
 */
char *
Blt_Strdup(string)
    CONST char *string;
{
    size_t size;
    char *ptr;

    size = strlen(string) + 1;
    ptr = Blt_Malloc(size * sizeof(char));
    if (ptr != NULL) {
	strcpy(ptr, string);
    }
    return ptr;
}

@

