head	14.3;
access;
symbols
	rel-7-10-4:14.2
	STABLE:14.2.0.10
	stable-branch:14.2
	rel-7-10-2:14.2
	rel-7-10-0:14.2
	rel-7-8-4:14.2
	rel-7-8-2:14.2
	rel-7-8-0:14.2
	trimnurbs-branch:14.2.0.8
	help:14.2
	temp_tag:14.2
	bobWinPort-20051223-freeze:14.2
	postmerge-20051223-bobWinPort:14.2
	premerge-20051223-bobWinPort:14.2
	rel-7-6-6:14.2
	rel-7-6-4:14.2
	rel-7-6-2:14.2
	rel-7-6-branch:14.2.0.6
	rel-7-6-0:14.2
	rel-7-4-2:14.2
	rel-7-4-branch:14.2.0.4
	bobWinPort:14.2.0.2
	rel-7-4-0:14.2
	rel-7-2-6:14.2
	rel-7-2-4:14.2
	rel-7-2-2:14.2
	rel-7-2-0:14.2
	rel-7-0-4:14.2
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.3
date	2007.09.14.15.21.38;	author erikgreenwald;	state Exp;
branches;
next	14.2;

14.2
date	2005.01.23.14.29.55;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.30;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.14.54.04;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.3
log
@removed trailing whitespace
@
text
@/*
 * This software is copyrighted as noted below.  It may be freely copied,
 * modified, and redistributed, provided that the copyright notice is
 * preserved on all copies.
 *
 * There is no warranty or other guarantee of fitness for this software,
 * it is provided solely "as is".  Bug reports or fixes may be sent
 * to the author, who may or may not act on them as he desires.
 *
 * You may not include this software in a program or other software product
 * without supplying the source, or without informing the end-user that the
 * source is available for no extra charge.
 *
 * If you modify this software, you should include a notice giving the
 * name of the person performing the modification, the date of modification,
 * and the reason for such modification.
 *
 *  Modified at BRL 16-May-88 by Mike Muuss to avoid Alliant STDC desire
 *  to have all "void" functions so declared.
 */
/*
 * dither.c - Functions for RGB color dithering.
 *
 * Author:	Spencer W. Thomas
 * 		Computer Science Dept.
 * 		University of Utah
 * Date:	Mon Feb  2 1987
 * Copyright (c) 1987, University of Utah
 */
static char rcsid[] = "$Header: /cvsroot/brlcad/brlcad/src/other/libutahrle/dither.c,v 14.2 2005/01/23 14:29:55 brlcad Exp $";

#include <math.h>

#ifdef USE_PROTOTYPES
void	make_square( double, int [256], int [256], int [16][16] );
#else
void	make_square();
#endif

static int magic4x4[4][4] =  {
 	 0, 14,  3, 13,
	11,  5,  8,  6,
	12,  2, 15,  1,
	 7,  9,  4, 10
};

/* basic dithering macro */
#define DMAP(v,x,y)	(modN[v]>magic[x][y] ? divN[v] + 1 : divN[v])


/*****************************************************************
 * TAG( dithermap )
 *
 * Create a color dithering map with a specified number of intensity levels.
 * Inputs:
 * 	levels:		Intensity levels per primary.
 *	gamma:		Display gamma value.
 * Outputs:
 * 	rgbmap:		Generated color map.
 *	divN:		"div" function for dithering.
 *	modN:		"mod" function for dithering.
 * Assumptions:
 * 	rgbmap will hold levels^3 entries.
 * Algorithm:
 *	Compute gamma compensation map.
 *	N = 255.0 / (levels - 1) is number of pixel values per level.
 *	Compute rgbmap with red ramping fastest, green slower, and blue
 *	slowest (treat it as if it were rgbmap[levels][levels][levels][3]).
 *	Call make_square to get divN, modN, and magic
 *
 * Note:
 *	Call dithergb( x, y, r, g, b, levels, divN, modN, magic ) to get index
 *	into rgbmap for a given color/location pair, or use
 *	    row = y % 16; col = x % 16;
 *	    DMAP(v,col,row) =def (divN[v] + (modN[v]>magic[col][row] ? 1 : 0))
 *	    DMAP(r,col,row) + DMAP(g,col,row)*levels + DMAP(b,col,row)*levels^2
 *	if you don't want function call overhead.
 */
void
dithermap( levels, gamma, rgbmap, divN, modN, magic )
int levels;
double gamma;
int rgbmap[][3];
int divN[256];
int modN[256];
int magic[16][16];
{
    double N;
    register int i;
    int levelsq, levelsc;
    int gammamap[256];

    for ( i = 0; i < 256; i++ )
	gammamap[i] = (int)(0.5 + 255 * pow( i / 255.0, 1.0/gamma ));

    levelsq = levels*levels;	/* squared */
    levelsc = levels*levelsq;	/* and cubed */

    N = 255.0 / (levels - 1);    /* Get size of each step */

    /*
     * Set up the color map entries.
     */
    for(i = 0; i < levelsc; i++) {
	rgbmap[i][0] = gammamap[(int)(0.5 + (i%levels) * N)];
	rgbmap[i][1] = gammamap[(int)(0.5 + ((i/levels)%levels) * N)];
	rgbmap[i][2] = gammamap[(int)(0.5 + ((i/levelsq)%levels) * N)];
    }

    make_square( N, divN, modN, magic );
}


/*****************************************************************
 * TAG( bwdithermap )
 *
 * Create a color dithering map with a specified number of intensity levels.
 * Inputs:
 * 	levels:		Intensity levels.
 *	gamma:		Display gamma value.
 * Outputs:
 * 	bwmap:		Generated black & white map.
 *	divN:		"div" function for dithering.
 *	modN:		"mod" function for dithering.
 * Assumptions:
 * 	bwmap will hold levels entries.
 * Algorithm:
 *	Compute gamma compensation map.
 *	N = 255.0 / (levels - 1) is number of pixel values per level.
 *	Compute bwmap for levels entries.
 *	Call make_square to get divN, modN, and magic.
 * Note:
 *	Call ditherbw( x, y, val, divN, modN, magic ) to get index into
 *	bwmap for a given color/location pair, or use
 *	    row = y % 16; col = x % 16;
 *	    divN[val] + (modN[val]>magic[col][row] ? 1 : 0)
 *	if you don't want function call overhead.
 *	On a 1-bit display, use
 *	    divN[val] > magic[col][row] ? 1 : 0
 */
void
bwdithermap( levels, gamma, bwmap, divN, modN, magic )
int levels;
double gamma;
int bwmap[];
int divN[256];
int modN[256];
int magic[16][16];
{
    double N;
    register int i;
    int gammamap[256];

    for ( i = 0; i < 256; i++ )
	gammamap[i] = (int)(0.5 + 255 * pow( i / 255.0, 1.0/gamma ));

    N = 255.0 / (levels - 1);    /* Get size of each step */

    /*
     * Set up the color map entries.
     */
    for(i = 0; i < levels; i++)
	bwmap[i] = gammamap[(int)(0.5 + i * N)];

    make_square( N, divN, modN, magic );
}


/*****************************************************************
 * TAG( make_square )
 *
 * Build the magic square for a given number of levels.
 * Inputs:
 * 	N:		Pixel values per level (255.0 / levels).
 * Outputs:
 * 	divN:		Integer value of pixval / N
 *	modN:		Integer remainder between pixval and divN[pixval]*N
 *	magic:		Magic square for dithering to N sublevels.
 * Assumptions:
 *
 * Algorithm:
 *	divN[pixval] = (int)(pixval / N) maps pixval to its appropriate level.
 *	modN[pixval] = pixval - (int)(N * divN[pixval]) maps pixval to
 *	its sublevel, and is used in the dithering computation.
 *	The magic square is computed as the (modified) outer product of
 *	a 4x4 magic square with itself.
 *	magic[4*k + i][4*l + j] = (magic4x4[i][j] + magic4x4[k][l]/16.0)
 *	multiplied by an appropriate factor to get the correct dithering
 *	range.
 */
void
make_square( N, divN, modN, magic )
double N;
int divN[256];
int modN[256];
int magic[16][16] ;
{
    register int i, j, k, l;
    double magicfact;

    for ( i = 0; i < 256; i++ )
    {
	divN[i] = (int)(i / N);
	modN[i] = i - (int)(N * divN[i]);
    }
    modN[255] = 0;		/* always */

    /*
     * Expand 4x4 dither pattern to 16x16.  4x4 leaves obvious patterning,
     * and doesn't give us full intensity range (only 17 sublevels).
     *
     * magicfact is (N - 1)/16 so that we get numbers in the matrix from 0 to
     * N - 1: mod N gives numbers in 0 to N - 1, don't ever want all
     * pixels incremented to the next level (this is reserved for the
     * pixel value with mod N == 0 at the next level).
     */
    magicfact = (N - 1) / 16.;
    for ( i = 0; i < 4; i++ )
	for ( j = 0; j < 4; j++ )
	    for ( k = 0; k < 4; k++ )
		for ( l = 0; l < 4; l++ )
		    magic[4*k+i][4*l+j] =
			(int)(0.5 + magic4x4[i][j] * magicfact +
			      (magic4x4[k][l] / 16.) * magicfact);
}


/*****************************************************************
 * TAG( dithergb )
 *
 * Return dithered RGB value.
 * Inputs:
 * 	x:		X location on screen of this pixel.
 *	y:		Y location on screen of this pixel.
 *	r, g, b:	Color at this pixel (0 - 255 range).
 *	levels:		Number of levels in this map.
 *	divN, modN:	From dithermap.
 *	magic:		Magic square from dithermap.
 * Outputs:
 * 	Returns color map index for dithered pixelv value.
 * Assumptions:
 * 	divN, modN, magic were set up properly.
 * Algorithm:
 * 	see "Note:" in dithermap comment.
 */
int
dithergb( x, y, r, g, b, levels, divN, modN, magic )
int x, y, r, g, b, levels;
int divN[256];
int modN[256];
int magic[16][16];
{
    int col = x % 16, row = y % 16;

    return DMAP(r, col, row) +
	DMAP(g, col, row) * levels +
	    DMAP(b, col, row) * levels*levels;
}


/*****************************************************************
 * TAG( ditherbw )
 *
 * Return dithered black & white value.
 * Inputs:
 * 	x:		X location on screen of this pixel.
 *	y:		Y location on screen of this pixel.
 *	val:		Intensity at this pixel (0 - 255 range).
 *	divN, modN:	From dithermap.
 *	magic:		Magic square from dithermap.
 * Outputs:
 * 	Returns color map index for dithered pixel value.
 * Assumptions:
 * 	divN, modN, magic were set up properly.
 * Algorithm:
 * 	see "Note:" in bwdithermap comment.
 */
int
ditherbw( x, y, val, divN, modN, magic )
int x, y, val;
int divN[256];
int modN[256];
int magic[16][16];
{
    int col = x % 16, row = y % 16;

    return DMAP(val, col, row);
}
@


14.2
log
@update from a patched 3.0 to urt 3.1b1 (library)
@
text
@d3 1
a3 1
 * modified, and redistributed, provided that the copyright notice is 
d5 1
a5 1
 * 
d11 1
a11 1
 * without supplying the source, or without informing the end-user that the 
d21 1
a21 1
/* 
d23 1
a23 1
 * 
d30 1
a30 1
static char rcsid[] = "$Header: /l/spencer/src/urt/lib/RCS/dither.c,v 3.0.1.2 1992/04/30 14:07:02 spencer Exp $";
d53 1
a53 1
 * 
d92 1
a92 1
    
d101 1
a101 1
    /* 
d116 1
a116 1
 * 
d133 1
a133 1
 *	Call ditherbw( x, y, val, divN, modN, magic ) to get index into 
d153 1
a153 1
    
d159 1
a159 1
    /* 
d171 1
a171 1
 * 
d180 1
a180 1
 * 	
d211 1
a211 1
     * 
d230 1
a230 1
 * 
d263 1
a263 1
 * 
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d30 1
a30 4

#include "common.h"


d41 4
a44 4
 	{ 0, 14,  3, 13},
	{11,  5,  8,  6},
	{12,  2, 15,  1},
	{ 7,  9,  4, 10}
d80 7
a86 1
dithermap(int levels, double gamma, int (*rgbmap)[3], int *divN, int *modN, int (*magic)[16])
d142 7
a148 1
bwdithermap(int levels, double gamma, int *bwmap, int *divN, int *modN, int (*magic)[16])
d192 5
a196 1
make_square(double N, int *divN, int *modN, int (*magic)[16])
d247 5
a251 1
dithergb(int x, int y, int r, int g, int b, int levels, int *divN, int *modN, int (*magic)[16])
d279 5
a283 1
ditherbw(int x, int y, int val, int *divN, int *modN, int (*magic)[16])
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@@


1.1
log
@Sources that are external to BRL-CAD are moved from the top level to src/other/.
@
text
@d31 1
a31 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

