head	14.7;
access;
symbols
	rel-7-10-4:14.5
	STABLE:14.5.0.2
	stable-branch:14.3
	rel-7-10-2:14.5
	rel-7-10-0:14.5
	rel-7-8-4:14.5
	rel-7-8-2:14.5
	rel-7-8-0:14.5
	trimnurbs-branch:14.4.0.8
	help:14.4
	temp_tag:14.4
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.4
	premerge-20051223-bobWinPort:14.4
	rel-7-6-6:14.4
	rel-7-6-4:14.4
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.3
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.7
date	2007.12.20.20.36.39;	author bob1961;	state Exp;
branches;
next	14.6;

14.6
date	2007.09.14.15.21.39;	author erikgreenwald;	state Exp;
branches;
next	14.5;

14.5
date	2006.03.24.19.36.13;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.06.15.04.34.53;	author brlcad;	state Exp;
branches
	14.4.8.1;
next	14.3;

14.3
date	2005.01.25.06.54.18;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2005.01.23.14.29.55;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.30;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.07.22.19.56;	author kermit;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.59;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.18.30.55;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.14.54.08;	author morrison;	state Exp;
branches;
next	;

14.4.8.1
date	2006.04.07.19.34.19;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.7
log
@Mods to get things compiling on windows.
@
text
@/*
 * rle_open_f.c - Open a file with defaults.
 *
 * Author : 	Jerry Winters
 * 		EECS Dept.
 * 		University of Michigan
 * Date:	11/14/89
 * Copyright (c) 1990, University of Michigan
 */

#include "rle_config.h"
#include <stdio.h>
#include <stdlib.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#ifndef NO_OPEN_PIPES
/* Need to have a SIGCLD signal catcher. */
#include <signal.h>
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
#include <errno.h>

/* Count outstanding children.  Assume no more than 100 possible. */
#define MAX_CHILDREN 100
static int catching_children = 0;
static int pids[MAX_CHILDREN];

static FILE *my_popen();
#endif /* !NO_OPEN_PIPES */


/*
 *  Purpose : Open a file for input or ouput as controlled by the mode
 *  parameter.  If no file name is specified (ie. file_name is null) then
 *  a pointer to stdin or stdout will be returned.  The calling routine may
 *  call this routine with a file name of "-".  For this case rle_open_f
 *  will return a pointer to stdin or stdout depending on the mode.
 *    If the user specifies a non-null file name and an I/O error occurs
 *  when trying to open the file, rle_open_f will terminate execution with
 *  an appropiate error message.
 *
 *  parameters
 *   input:
 *     prog_name: 	name of the calling program.
 *     file_name : 	name of the file to open
 *     mode : 		either "r" for read or input file or "w" for write or
 *            		output file
 *
 *   output:
 *     a file pointer
 *
 */
FILE *
rle_open_f_noexit( prog_name, file_name, mode )
char *prog_name, *file_name, *mode;
{
    FILE *fp;
    void perror();
    CONST_DECL char *err_str;
    register char *cp;
    char *combuf;
    size_t combuf_size;

#ifdef STDIO_NEEDS_BINARY
    char mode_string[32];	/* Should be enough. */

    /* Concatenate a 'b' onto the mode. */
    mode_string[0] = mode[0];
    mode_string[1] = 'b';
    strncpy( mode_string + 2, mode + 1, sizeof(mode_string + 2) );
    mode = mode_string;
#endif

    if ( *mode == 'w' || *mode == 'a' )
	fp = stdout;     /* Set the default value */
    else
	fp = stdin;

    if ( file_name != NULL && strcmp( file_name, "-" ) != 0 )
    {
#ifndef	NO_OPEN_PIPES
	/* Check for dead children. */
	if ( catching_children > 0 )
	{
	    int i, j;

	    /* Check all children to see if any are dead, reap them if so. */
	    for ( i = 0; i < catching_children; i++ )
	    {
		/* The assumption here is that if it's dead, the kill
		 * will fail, but, because we haven't waited for
		 * it yet, it's a zombie.
		 */
		if (kill(pids[i], 0) < 0) {
		    int opid = pids[i], pid = 0;
		    /* Wait for processes & delete them from the list,
		     * until we get the one we know is dead.
		     * When removing one earlier in the list than
		     * the one we found, decrement our loop index.
		     */
		    while (pid != opid) {
			pid = wait( NULL );
			for ( j = 0;
			      j < catching_children && pids[j] != pid;
			      j++ )
			    ;
#ifdef DEBUG
			fprintf( stderr, "Reaping %d at %d for %d at %d\n",
				 pid, j, opid, i );
			fflush( stderr );
#endif
			if ( pid < 0 )
			    break;
			if ( j < catching_children ) {
			    if ( i >= j )
				i--;
			    for ( j++; j < catching_children; j++ )
				pids[j-1] = pids[j];
			    catching_children--;
			}
		    }
		}
	    }
	}

	/*  Real file, not stdin or stdout.  If name ends in ".Z",
	 *  pipe from/to un/compress (depending on r/w mode).
	 *
	 *  If it starts with "|", popen that command.
	 */

	cp = file_name + strlen( file_name ) - 2;
	/* Pipe case. */
	if ( *file_name == '|' )
	{
	    int thepid;		/* PID from my_popen */
	    if ( (fp = my_popen( file_name + 1, mode, &thepid )) == NULL )
	    {
		err_str = "%s: can't invoke <<%s>> for %s: ";
		goto err;
	    }
	    /* One more child to catch, eventually. */
	    if (catching_children < MAX_CHILDREN) {
#ifdef DEBUG
		fprintf( stderr, "Forking %d at %d\n",
			 thepid, catching_children );
		fflush( stderr );
#endif
		pids[catching_children++] = thepid;
	    }
	}

	/* Compress case. */
	else if ( cp > file_name && *cp == '.' && *(cp + 1) == 'Z' )
	{
	    int thepid;		/* PID from my_popen. */
	    combuf_size = 20 + strlen( file_name );
	    combuf = (char *)malloc( combuf_size );
	    if ( combuf == NULL )
	    {
		err_str = "%s: out of memory opening (compressed) %s for %s";
		goto err;
	    }

	    if ( *mode == 'w' )
		snprintf( combuf, combuf_size, "compress > %s", file_name );
	    else if ( *mode == 'a' )
		snprintf( combuf, combuf_size, "compress >> %s", file_name );
	    else
		snprintf( combuf, combuf_size, "compress -d < %s", file_name );

	    fp = my_popen( combuf, mode, &thepid );
	    free( combuf );

	    if ( fp == NULL )
	    {
		err_str =
    "%s: can't invoke 'compress' program, trying to open %s for %s";
		goto err;
	    }
	    /* One more child to catch, eventually. */
	    if (catching_children < MAX_CHILDREN) {
#ifdef DEBUG
		fprintf( stderr, "Forking %d at %d\n", thepid, catching_children );
		fflush( stderr );
#endif
		pids[catching_children++] = thepid;
	    }
	}

	/* Ordinary, boring file case. */
	else
#endif /* !NO_OPEN_PIPES */
	    if ( (fp = fopen(file_name, mode)) == NULL )
	    {
		err_str = "%s: can't open %s for %s: ";
		goto err;
	    }
    }

    return fp;

err:
	fprintf( stderr, err_str,
		 prog_name, file_name,
		 (*mode == 'w') ? "output" :
		 (*mode == 'a') ? "append" :
		 "input" );
	perror( "" );
	return NULL;

}

FILE *
rle_open_f( prog_name, file_name, mode )
char *prog_name, *file_name, *mode;
{
    FILE *fp;

    if ( (fp = rle_open_f_noexit( prog_name, file_name, mode )) == NULL )
	exit( -1 );

    return fp;
}


/*****************************************************************
 * TAG( rle_close_f )
 *
 * Close a file opened by rle_open_f.  If the file is stdin or stdout,
 * it will not be closed.
 * Inputs:
 * 	fd:	File to close.
 * Outputs:
 * 	None.
 * Assumptions:
 * 	fd is open.
 * Algorithm:
 * 	If fd is NULL, just return.
 * 	If fd is stdin or stdout, don't close it.  Otherwise, call fclose.
 */
void
rle_close_f( fd )
FILE *fd;
{
    if ( fd == NULL || fd == stdin || fd == stdout )
	return;
    else
	fclose( fd );
}


#ifndef NO_OPEN_PIPES
static FILE *
my_popen( cmd, mode, pid )
char *cmd, *mode;
int *pid;
{
    FILE *retfile;
    int thepid = 0;
    int pipefd[2];
    int i;
    char *argv[4];
    extern int errno;

    /* Check args. */
    if ( *mode != 'r' && *mode != 'w' )
    {
	errno = EINVAL;
	return NULL;
    }

    if ( pipe(pipefd) < 0 )
	return NULL;

    /* Flush known files. */
    fflush(stdout);
    fflush(stderr);
    if ( (thepid = fork()) < 0 )
    {
	close(pipefd[0]);
	close(pipefd[1]);
	return NULL;
    }
    else if (thepid == 0) {
	/* In child. */
	/* Rearrange file descriptors. */
	if ( *mode == 'r' )
	{
	    /* Parent reads from pipe, so reset stdout. */
	    close(1);
	    dup2(pipefd[1],1);
	} else {
	    /* Parent writing to pipe. */
	    close(0);
	    dup2(pipefd[0],0);
	}
	/* Close anything above fd 2. (64 is an arbitrary magic number). */
	for ( i = 3; i < 64; i++ )
	    close(i);

	/* Finally, invoke the program. */
	if ( execl("/bin/sh", "sh", "-c", cmd, NULL) < 0 )
	    exit(127);
	/* NOTREACHED */
    }

    /* Close file descriptors, and gen up a FILE ptr */
    if ( *mode == 'r' )
    {
	/* Parent reads from pipe. */
	close(pipefd[1]);
	retfile = fdopen( pipefd[0], mode );
    } else {
	/* Parent writing to pipe. */
	close(pipefd[0]);
	retfile = fdopen( pipefd[1], mode );
    }

    /* Return the PID. */
    *pid = thepid;

    return retfile;
}
#endif /* !NO_OPEN_PIPES */
@


14.6
log
@removed trailing whitespace
@
text
@d14 4
a17 1
#include <unistd.h>
@


14.5
log
@quell compiler warnings
@
text
@d1 1
a1 1
/* 
d3 2
a4 2
 * 
 * Author : 	Jerry Winters 
d33 1
a33 1
/* 
d52 1
a52 1
 * 
d55 1
a55 1
rle_open_f_noexit( prog_name, file_name, mode ) 
d79 1
a79 1
    
d129 1
a129 1
	 *  
d132 1
a132 1
	    
d230 1
a230 1
 * 
d276 1
a276 1
    
d307 1
a307 1
    }	
@


14.4
log
@protect the sys/wait.h headers with HAVE_SYS_WAIT_H since not all systems (e.g. mingw) have it.
@
text
@d13 2
@


14.4.8.1
log
@update from HEAD
@
text
@a12 2
#include <stdlib.h>
#include <unistd.h>
@


14.3
log
@apply sf patch 1108755 from giffunip that provides  snprintf's to address apparent CERT/ICANN vulnerability.
@
text
@d17 3
a19 1
#include <sys/wait.h>
@


14.2
log
@update from a patched 3.0 to urt 3.1b1 (library)
@
text
@d59 1
d67 1
a67 1
    strcpy( mode_string + 2, mode + 1 );
d154 2
a155 1
	    combuf = (char *)malloc( 20 + strlen( file_name ) );
d163 1
a163 1
		sprintf( combuf, "compress > %s", file_name );
d165 1
a165 1
		sprintf( combuf, "compress >> %s", file_name );
d167 1
a167 1
		sprintf( combuf, "compress -d < %s", file_name );
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d11 2
a12 1
#include "common.h"
d14 10
a23 7
#include <stdlib.h>
#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
d25 2
a26 1
#include "machine.h"
d30 1
a30 1
 *  Purpose : Open a file for input or ouput as controled by the mode
d51 2
a52 1
rle_open_f_noexit(char *prog_name, char *file_name, char *mode)
d55 2
a56 1
    char *err_str;
d78 44
d127 1
a127 1

d132 2
a133 1
	    if ( (fp = popen( file_name + 1, mode )) == NULL )
d138 9
d152 1
d167 1
a167 1
	    fp = popen( combuf, mode );
d176 8
d210 2
a211 1
rle_open_f(char *prog_name, char *file_name, char *mode)
d221 100
@


1.5
log
@Added missing <stdlib.h> headers for malloc, calloc (for IA64 architecture).
@
text
@@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d13 1
a13 2


@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d16 1
a16 1
#ifdef USE_STRING_H
@


1.2
log
@externs.h is no longer needed and is going away .. config.h can be used instead if needed
@
text
@d11 1
a11 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Sources that are external to BRL-CAD are moved from the top level to src/other/.
@
text
@a24 1
#include "externs.h"
@

