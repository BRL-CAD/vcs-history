head	14.2;
access;
symbols
	rel-7-10-4:14.1
	STABLE:14.1.0.10
	stable-branch:14.1
	rel-7-10-2:14.1
	rel-7-10-0:14.1
	rel-7-8-4:14.1
	rel-7-8-2:14.1
	rel-7-8-0:14.1
	trimnurbs-branch:14.1.0.8
	help:14.1
	temp_tag:14.1
	bobWinPort-20051223-freeze:14.1
	postmerge-20051223-bobWinPort:14.1
	premerge-20051223-bobWinPort:14.1
	rel-7-6-6:14.1
	rel-7-6-4:14.1
	rel-7-6-2:14.1
	rel-7-6-branch:14.1.0.6
	rel-7-6-0:14.1
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.4
	bobWinPort:14.1.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@.\" @;


14.2
date	2007.09.14.15.21.38;	author erikgreenwald;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.30;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.14.54.07;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.2
log
@removed trailing whitespace
@
text
@.\" Copyright (c) 1986, 1987, University of Utah
.TH RLE_GETRAW 3 2/2/87 3
.UC 4

.SH NAME
rle_getraw \- Read run length encoded data from an RLE file.
.br
rle_freeraw \- Free pixel storage allocated by rle_getraw.
.SH SYNOPSIS
.B
#include <rle.h>
.br
.B
#include <rle_raw.h>
.sp
.B
unsigned int rle_getraw( the_hdr, scanraw, nraw )
.br
.B
rle_hdr * the_hdr;
.br
.B
rle_op ** scanraw;
.br
.B
int * nraw;
.sp
.B
void rle_freeraw( the_hdr, scanraw, nraw );
.br
.B
rle_hdr * the_hdr;
.br
.B
rle_op ** scanraw;
.br
.B
int * nraw;
.SH DESCRIPTION
.I Rle_getraw
can be used to read information from an RLE file in the "raw" form.

The
.IR scanraw
argument is an array of pointers to arrays of
.IR rle_op (3)
structures.  Each
.I rle_op
structure specifies a run or sequence of pixel values.  The array
.I nraw
gives the number of
.I rle_op
structures for each channel.  I.e.,
.I nraw[i]
is the length of the array pointed to by
.IR scanraw[i] .
.PP
Return value is the current scanline number.  Returns 32768 at EOF.
.PP
Sufficient space must be allocated in the arrays of
.I rle_op
structures to hold the data read from the file.  A function,
.IR rle_raw_alloc (3),
is provided to make this easier.  The storage required by any pixel
sequences in the input will be dynamically allocated by
.IR rle_getraw .

The pixel storage allocated dynamically by
.IR rle_getraw (3)
must be freed to avoid memory leaks.  This is most easily accomplished
by calling
.IR rle_freeraw .
The argument
.I scanraw
points to an array of
.I rle_op
structures, with
.I nraw
indicating the number of structures in each channel.  All pixel data
arrays will be freed by the call to
.IR rle_freeraw .
.SH EXAMPLE
The usual code looks something like
.nf
	rle_hdr in_hdr, out_hdr;
	rle_op **raw;
	int *nraw;
	while ( rle_getraw( &in_hdr, raw, nraw ) != 32768 )
	{
		/* Process data. */
		rle_putraw( &out_hdr, raw, nraw );
		rle_freeraw( &in_hdr, raw, nraw );
	}
.fi
.SH SEE ALSO
.na
.IR rle_hdr (3),
.IR rle_op (3),
.IR rle_putraw (3),
.IR rle_raw_alloc (3),
.IR rle_raw_free (3),
.IR rle_getrow (3),
.IR rle_getskip (3),
.IR librle (3),
.IR RLE (5).
.ad b
.SH AUTHOR
Spencer W. Thomas
.br
University of Utah

@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d3 1
a3 1
.UC 4 
d45 1
a45 1
argument is an array of pointers to arrays of 
d51 1
a51 1
gives the number of 
d60 1
a60 1
Sufficient space must be allocated in the arrays of 
d71 1
a71 1
by calling 
d75 1
a75 1
points to an array of 
d81 1
a81 1
.IR rle_freeraw .  
@


1.1
log
@Sources that are external to BRL-CAD are moved from the top level to src/other/.
@
text
@@

