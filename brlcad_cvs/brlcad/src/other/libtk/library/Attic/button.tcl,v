head	14.2;
access;
symbols
	stable-branch:14.1
	rel-7-8-4:14.1
	rel-7-8-2:14.1
	rel-7-8-0:14.1
	trimnurbs-branch:14.1.0.8
	help:14.1
	temp_tag:14.1
	bobWinPort-20051223-freeze:14.1
	postmerge-20051223-bobWinPort:14.1
	premerge-20051223-bobWinPort:14.1
	rel-7-6-6:14.1
	rel-7-6-4:14.1
	rel-7-6-2:14.1
	rel-7-6-branch:14.1.0.6
	rel-7-6-0:14.1
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.4
	bobWinPort:14.1.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@# @;


14.2
date	2007.03.02.21.47.36;	author brlcad;	state dead;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.26;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.14.52.59;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.2
log
@upgrade tcl/tk from 8.4.6 to 8.5a5; also move to a recursive configure, using AC_CONFIG_SUBDIRS to call upon tcl, tk, and enigma's configure scripts as needed instead of redoing their build systems for our purpose.  this has a rather drastic impact on the way the libraries are linked together, including the need to compile tcl/tk static so as to avoid libtool portability issues as well as letting us take advantage of their build system for reduced maintenance and easing future upgrades.  undoubtedly more build issues to be worked out with other platforms given the extent of this change.  this does move us one step closer towards correctly linking against system tcl/tk installations too.
@
text
@# button.tcl --
#
# This file defines the default bindings for Tk label, button,
# checkbutton, and radiobutton widgets and provides procedures
# that help in implementing those bindings.
#
# RCS: @@(#) $Id: button.tcl,v 14.1 2004/11/16 19:42:26 morrison Exp $
#
# Copyright (c) 1992-1994 The Regents of the University of California.
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 2002 ActiveState Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#-------------------------------------------------------------------------
# The code below creates the default class bindings for buttons.
#-------------------------------------------------------------------------

if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {
    bind Radiobutton <Enter> {
	tk::ButtonEnter %W
    }
    bind Radiobutton <1> {
	tk::ButtonDown %W
    }
    bind Radiobutton <ButtonRelease-1> {
	tk::ButtonUp %W
    }
    bind Checkbutton <Enter> {
	tk::ButtonEnter %W
    }
    bind Checkbutton <1> {
	tk::ButtonDown %W
    }
    bind Checkbutton <ButtonRelease-1> {
	tk::ButtonUp %W
    }
}
if {[string equal "windows" $tcl_platform(platform)]} {
    bind Checkbutton <equal> {
	tk::CheckRadioInvoke %W select
    }
    bind Checkbutton <plus> {
	tk::CheckRadioInvoke %W select
    }
    bind Checkbutton <minus> {
	tk::CheckRadioInvoke %W deselect
    }
    bind Checkbutton <1> {
	tk::CheckRadioDown %W
    }
    bind Checkbutton <ButtonRelease-1> {
	tk::ButtonUp %W
    }
    bind Checkbutton <Enter> {
	tk::CheckRadioEnter %W
    }

    bind Radiobutton <1> {
	tk::CheckRadioDown %W
    }
    bind Radiobutton <ButtonRelease-1> {
	tk::ButtonUp %W
    }
    bind Radiobutton <Enter> {
	tk::CheckRadioEnter %W
    }
}
if {[string equal "x11" [tk windowingsystem]]} {
    bind Checkbutton <Return> {
	if {!$tk_strictMotif} {
	    tk::CheckRadioInvoke %W
	}
    }
    bind Radiobutton <Return> {
	if {!$tk_strictMotif} {
	    tk::CheckRadioInvoke %W
	}
    }
    bind Checkbutton <1> {
	tk::CheckRadioInvoke %W
    }
    bind Radiobutton <1> {
	tk::CheckRadioInvoke %W
    }
    bind Checkbutton <Enter> {
	tk::ButtonEnter %W
    }
    bind Radiobutton <Enter> {
	tk::ButtonEnter %W
    }
}

bind Button <space> {
    tk::ButtonInvoke %W
}
bind Checkbutton <space> {
    tk::CheckRadioInvoke %W
}
bind Radiobutton <space> {
    tk::CheckRadioInvoke %W
}

bind Button <FocusIn> {}
bind Button <Enter> {
    tk::ButtonEnter %W
}
bind Button <Leave> {
    tk::ButtonLeave %W
}
bind Button <1> {
    tk::ButtonDown %W
}
bind Button <ButtonRelease-1> {
    tk::ButtonUp %W
}

bind Checkbutton <FocusIn> {}
bind Checkbutton <Leave> {
    tk::ButtonLeave %W
}

bind Radiobutton <FocusIn> {}
bind Radiobutton <Leave> {
    tk::ButtonLeave %W
}

if {[string equal "windows" $tcl_platform(platform)]} {

#########################
# Windows implementation 
#########################

# ::tk::ButtonEnter --
# The procedure below is invoked when the mouse pointer enters a
# button widget.  It records the button we're in and changes the
# state of the button to active unless the button is disabled.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonEnter w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {

	# If the mouse button is down, set the relief to sunken on entry.
	# Overwise, if there's an -overrelief value, set the relief to that.

	set Priv($w,relief) [$w cget -relief]
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -relief sunken -state active
	    set Priv($w,prelief) sunken
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    $w configure -relief $over
	    set Priv($w,prelief) $over
	}
    }
    set Priv(window) $w
}

# ::tk::ButtonLeave --
# The procedure below is invoked when the mouse pointer leaves a
# button widget.  It changes the state of the button back to inactive.
# Restore any modified relief too.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	$w configure -state normal
    }

    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).

    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
    }

    set Priv(window) ""
}

# ::tk::ButtonDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonDown w {
    variable ::tk::Priv

    # Only save the button's relief if it does not yet exist.  If there
    # is an overrelief setting, Priv($w,relief) will already have been set,
    # and the current value of the -relief option will be incorrect.

    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	$w configure -relief sunken -state active
	set Priv($w,prelief) sunken

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set delay [$w cget -repeatdelay]
	set Priv(repeated) 0
	if {$delay > 0} {
	    set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	}
    }
}

# ::tk::ButtonUp --
# The procedure below is invoked when the mouse button is released
# in a button widget.  It restores the button's relief and invokes
# the command as long as the mouse hasn't left the button.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {$Priv(buttonWindow) eq $w} {
	set Priv(buttonWindow) ""

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    $w configure -state normal

	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
	}
    }
}

# ::tk::CheckRadioEnter --
# The procedure below is invoked when the mouse pointer enters a
# checkbutton or radiobutton widget.  It records the button we're in
# and changes the state of the button to active unless the button is
# disabled.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::CheckRadioEnter w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -state active
	}
	if {[set over [$w cget -overrelief]] ne ""} {
	    set Priv($w,relief)  [$w cget -relief]
	    set Priv($w,prelief) $over
	    $w configure -relief $over
	}
    }
    set Priv(window) $w
}

# ::tk::CheckRadioDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::CheckRadioDown w {
    variable ::tk::Priv
    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }
    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	set Priv(repeated) 0
	$w configure -state active
    }
}

}

if {[string equal "x11" [tk windowingsystem]]} {

#####################
# Unix implementation
#####################

# ::tk::ButtonEnter --
# The procedure below is invoked when the mouse pointer enters a
# button widget.  It records the button we're in and changes the
# state of the button to active unless the button is disabled.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonEnter {w} {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	# On unix the state is active just with mouse-over
	$w configure -state active

	# If the mouse button is down, set the relief to sunken on entry.
	# Overwise, if there's an -overrelief value, set the relief to that.

	set Priv($w,relief) [$w cget -relief]
	if {$Priv(buttonWindow) eq $w} {
	    $w configure -relief sunken
	    set Priv($w,prelief) sunken
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    $w configure -relief $over
	    set Priv($w,prelief) $over
	}
    }
    set Priv(window) $w
}

# ::tk::ButtonLeave --
# The procedure below is invoked when the mouse pointer leaves a
# button widget.  It changes the state of the button back to inactive.
# Restore any modified relief too.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {
	$w configure -state normal
    }

    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).

    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
    }

    set Priv(window) ""
}

# ::tk::ButtonDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonDown w {
    variable ::tk::Priv

    # Only save the button's relief if it does not yet exist.  If there
    # is an overrelief setting, Priv($w,relief) will already have been set,
    # and the current value of the -relief option will be incorrect.

    if {![info exists Priv($w,relief)]} {
	set Priv($w,relief) [$w cget -relief]
    }

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	$w configure -relief sunken
	set Priv($w,prelief) sunken

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set delay [$w cget -repeatdelay]
	set Priv(repeated) 0
	if {$delay > 0} {
	    set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	}
    }
}

# ::tk::ButtonUp --
# The procedure below is invoked when the mouse button is released
# in a button widget.  It restores the button's relief and invokes
# the command as long as the mouse hasn't left the button.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {[string equal $w $Priv(buttonWindow)]} {
	set Priv(buttonWindow) ""

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
	}
    }
}

}

if {[string equal [tk windowingsystem] "classic"]
	|| [string equal [tk windowingsystem] "aqua"]} {

####################
# Mac implementation
####################

# ::tk::ButtonEnter --
# The procedure below is invoked when the mouse pointer enters a
# button widget.  It records the button we're in and changes the
# state of the button to active unless the button is disabled.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonEnter {w} {
    variable ::tk::Priv
    if {[$w cget -state] ne "disabled"} {

	# If there's an -overrelief value, set the relief to that.

	if {$Priv(buttonWindow) eq $w} {
	    $w configure -state active
	} elseif {[set over [$w cget -overrelief]] ne ""} {
	    set Priv($w,relief)  [$w cget -relief]
	    set Priv($w,prelief) $over
	    $w configure -relief $over
	}
    }
    set Priv(window) $w
}

# ::tk::ButtonLeave --
# The procedure below is invoked when the mouse pointer leaves a
# button widget.  It changes the state of the button back to
# inactive.  If we're leaving the button window with a mouse button
# pressed (Priv(buttonWindow) == $w), restore the relief of the
# button too.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonLeave w {
    variable ::tk::Priv
    if {$w eq $Priv(buttonWindow)} {
	$w configure -state normal
    }

    # Restore the original button relief if it was changed by Tk.
    # That is signaled by the existence of Priv($w,prelief).

    if {[info exists Priv($w,relief)]} {
	if {[info exists Priv($w,prelief)] && \
		$Priv($w,prelief) eq [$w cget -relief]} {
	    $w configure -relief $Priv($w,relief)
	}
	unset -nocomplain Priv($w,relief) Priv($w,prelief)
    }

    set Priv(window) ""
}

# ::tk::ButtonDown --
# The procedure below is invoked when the mouse button is pressed in
# a button widget.  It records the fact that the mouse is in the button,
# saves the button's relief so it can be restored later, and changes
# the relief to sunken.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonDown w {
    variable ::tk::Priv

    if {[$w cget -state] ne "disabled"} {
	set Priv(buttonWindow) $w
	$w configure -state active

	# If this button has a repeatdelay set up, get it going with an after
	after cancel $Priv(afterId)
	set Priv(repeated) 0
	if { ![catch {$w cget -repeatdelay} delay] } {
	    if {$delay > 0} {
		set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
	    }
	}
    }
}

# ::tk::ButtonUp --
# The procedure below is invoked when the mouse button is released
# in a button widget.  It restores the button's relief and invokes
# the command as long as the mouse hasn't left the button.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonUp w {
    variable ::tk::Priv
    if {$Priv(buttonWindow) eq $w} {
	set Priv(buttonWindow) ""
	$w configure -state normal

	# Restore the button's relief if it was cached.

	if {[info exists Priv($w,relief)]} {
	    if {[info exists Priv($w,prelief)] && \
		    $Priv($w,prelief) eq [$w cget -relief]} {
		$w configure -relief $Priv($w,relief)
	    }
	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
	}

	# Clean up the after event from the auto-repeater
	after cancel $Priv(afterId)

	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
	    # Only invoke the command if it wasn't already invoked by the
	    # auto-repeater functionality
	    if { $Priv(repeated) == 0 } {
		uplevel #0 [list $w invoke]
	    }
	}
    }
}

}

##################
# Shared routines
##################

# ::tk::ButtonInvoke --
# The procedure below is called when a button is invoked through
# the keyboard.  It simulate a press of the button via the mouse.
#
# Arguments:
# w -		The name of the widget.

proc ::tk::ButtonInvoke w {
    if {[$w cget -state] ne "disabled"} {
	set oldRelief [$w cget -relief]
	set oldState [$w cget -state]
	$w configure -state active -relief sunken
	update idletasks
	after 100
	$w configure -state $oldState -relief $oldRelief
	uplevel #0 [list $w invoke]
    }
}

# ::tk::ButtonAutoInvoke --
#
#	Invoke an auto-repeating button, and set it up to continue to repeat.
#
# Arguments:
#	w	button to invoke.
#
# Results:
#	None.
#
# Side effects:
#	May create an after event to call ::tk::ButtonAutoInvoke.

proc ::tk::ButtonAutoInvoke {w} {
    variable ::tk::Priv
    after cancel $Priv(afterId)
    set delay [$w cget -repeatinterval]
    if {$Priv(window) eq $w} {
	incr Priv(repeated)
	uplevel #0 [list $w invoke]
    }
    if {$delay > 0} {
	set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
    }
}

# ::tk::CheckRadioInvoke --
# The procedure below is invoked when the mouse button is pressed in
# a checkbutton or radiobutton widget, or when the widget is invoked
# through the keyboard.  It invokes the widget if it
# isn't disabled.
#
# Arguments:
# w -		The name of the widget.
# cmd -		The subcommand to invoke (one of invoke, select, or deselect).

proc ::tk::CheckRadioInvoke {w {cmd invoke}} {
    if {[$w cget -state] ne "disabled"} {
	uplevel #0 [list $w $cmd]
    }
}
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: button.tcl,v 1.1 2004/05/20 14:52:59 morrison Exp $
@


1.1
log
@Sources that are external to BRL-CAD are moved from the top level to src/other/.
@
text
@d7 1
a7 1
# RCS: @@(#) $Id: button.tcl,v 1.3 2004/03/04 19:49:16 morrison Exp $
@

