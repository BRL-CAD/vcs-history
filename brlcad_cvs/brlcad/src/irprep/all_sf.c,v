head	14.18;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.5
	rel-7-10-2:14.15
	rel-7-10-0:14.13
	rel-7-8-4:14.10
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.5
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.6
	rel-7-6-2:14.5
	rel-7-6-branch:14.5.0.6
	rel-7-6-0:14.5
	rel-7-4-2:14.5
	rel-7-4-branch:14.5.0.4
	bobWinPort:14.5.0.2
	rel-7-4-0:14.5
	rel-7-2-6:14.5
	rel-7-2-4:14.5
	rel-7-2-2:14.5
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.18
date	2007.12.14.20.58.54;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.10.26.21.51.26;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.07.26.01.13.54;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.05.14.21.04.31;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.27.01.41.35;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.23.01.13.32;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.50;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.04.05.19.17.57;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.23.07.15.53;	author brlcad;	state Exp;
branches
	14.9.2.1;
next	14.8;

14.8
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.12.02.21.13.52;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.23.04.44.31;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.03.28.23.39.56;	author brlcad;	state Exp;
branches
	14.5.6.1;
next	14.4;

14.4
date	2005.01.30.20.30.40;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.38.19;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.01.08.03;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.16.03.21.41;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.16;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.19;	author morrison;	state Exp;
branches;
next	;

14.5.6.1
date	2005.11.13.13.46.14;	author brlcad;	state Exp;
branches;
next	;

14.9.2.1
date	2006.04.07.19.26.28;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.18
log
@quell warnings
@
text
@/*                        A L L _ S F . C
 * BRL-CAD
 *
 * Copyright (c) 1990-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file all_sf.c
 *
 *  Program to find shape factors for an entire vehicle by firing
 *  one set of rays & tracking hits along the entire ray.
 *
 *  Author -
 *      S.Coates - 22 February 1993
 *
 */

/*	22 February 1993 - Original copy.  */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.17 2007/10/26 21:51:26 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

/*  Need the following for rt_shootray.  */
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"


extern int hit(register struct application *ap_p, struct partition *PartHeadp, struct seg *segp);       /*  User supplied hit function.  */
extern int miss(struct application *ap);      /*  User supplied miss function.  */
extern int overlap(struct application *ap, struct partition *pp, struct region *r1, struct region *r2, struct partition *hp);   /*  User supplied overlap function.  */

struct table
{
   const char *name;	/*  Region name.  */
   double lvrays;	/*  Number of rays that leave a region &  */
			/*  hit air or nothing.  */
   double *intrays;	/*  Number of rays that leave a region &  */
			/*  hit air or nothing & then hit another  */
			/*  region.  */
   double regarea;	/*  Surface area of region.  */
   double *sf;		/*  Shape factor of each region.  */
};
struct table *info;	/*  Structure that contains all info.  */

FILE *fpw1;		/*  Allows file to be written to from all func.  */

#ifndef HAVE_DRAND48
/* simulate drand48() --  using 31-bit random() -- assumed to exist */
double drand48() {
  extern long random();
  return (double)random() / 2147483648.0; /* range [0,1) */
}
#endif

int main(int argc, char **argv)
{							/*  START # 99  */
   struct application ap;  /*  Structure passed between functions.  */
   struct rt_i *rtip;	/*  Used to build directory.  */
   int index;		/*  Index for rt_dirbuild & rt_gettree.  */
   char idbuf[32];	/*  Contains data base info.  */
   struct region *pr;   /*  Used in finding region names.  */

   int numreg;		/*  Number of regions.  */
   double centall[3];	/*  Center of entire model.  */
   double minall[3];	/*  Minimum of entire model.  */
   double maxall[3];	/*  Maximum of entire model.  */
   double areaall;	/*  Surface area of bounding sphere.  */
   double radall;	/*  Radius of bounding sphere.  */
   long seed;		/*  Seed for random number generator.  */
   double rayfir;	/*  Number of rays to be fired.  */
   double rho,phi,theta;/*  Spherical coordinates for starting point.  */
   double elev,az,rds;	/*  Elevation, azimuth, & radius for finding vector  */
			/*  in yz-plane.  */
   double strtpt[3];	/*  Starting point.  */
   double strtdir[3];	/*  Starting direction.  */
   double denom;	/*  Denominator.  */

   int ians;		/*  Answer to question.  */
   int i,j,k,m;		/*  Loop counters.  */
   double r;		/*  Loop counter.  */
   double q;		/*  Temporary variable.  */
   double s[3],t[3];	/*  Temporary variables.  */

   FILE *fpw;		/*  Allows a file to be written.  */
   char outfile[26];	/*  Output file name.  */
   char errfile[26];	/*  Error file name.  */
   FILE *fpw2;		/*  Allows a file to be written.  */
   char lwxfile[26];	/*  Longwave radiation exchange file for PRISM  */
			/*  (not quite PRISM ready).  */

   struct bn_unif *msr = NULL;

   /*  Check to see if arguments are implimented correctly.  */
   if( (argv[1] == NULL) || (argv[2] == NULL) )
   {
	(void)fprintf(stderr,"\nusage:  %s file.g objects\n\n", *argv);
   }

   else
   {							/*  START # 100  */

	/*  Find name of output file.  */
	(void)printf("Enter name of output file (25 char max).\n\t");
	(void)fflush(stdout);
	(void)scanf("%25s",outfile);

	/*  Find name of longwave radiation exchange (lwx) file  */
	/*  for use with PRISM (not quite PRISM ready).  */
	(void)printf("Enter name of longwave radiation exchange");
	(void)printf(" file (25 char max).\n\t");
	(void)fflush(stdout);
	(void)scanf("%25s",lwxfile);

	/*  Find name of error file.  */
	(void)printf("Enter name of error file (25 char max).\n\t");
	(void)fflush(stdout);
	(void)scanf("%25s",errfile);

	/*  Open files.  */
	fpw = fopen(outfile,"w");
	fpw1 = fopen(errfile,"w");
	fpw2 = fopen(lwxfile,"w");

	/*  Write info to output & error file.  */
	(void)fprintf(fpw,"\n.g file used:  %s\n",argv[1]);
	(void)fprintf(fpw,"regions used:\n");
	(void)fprintf(fpw1,"\n.g file used:  %s\n",argv[1]);
	(void)fprintf(fpw1,"regions used:\n");
	i = 2;
	while(argv[i] != NULL)
	{
	   (void)fprintf(fpw,"\t%s\n",argv[i]);
	   (void)fprintf(fpw1,"\t%s\n",argv[i]);
	   i++;
	}
	(void)fprintf(fpw,"output file created:  %s\n",outfile);
	(void)fprintf(fpw,"error file created:  %s\n",errfile);
	(void)fprintf(fpw,"lwx file created:  %s\n",errfile);
	(void)fflush(fpw);
	(void)fprintf(fpw1,"output file created:  %s\n",outfile);
	(void)fprintf(fpw1,"error file created:  %s\n",errfile);
	(void)fprintf(fpw1,"lwx file created:  %s\n",errfile);
	(void)fflush(fpw1);

	/*  Build directory.  */
	index = 1;      /*  Set index for rt_dirbuild.  */
	rtip = rt_dirbuild(argv[index],idbuf,sizeof(idbuf));
	(void)printf("Database Title:  %s\n",idbuf);
	(void)fflush(stdout);

	/*  Set useair to 0 to show no hits of air.  */
	rtip->useair = 0;

	/*  Load desired objects.  */
	index = 2;      /*  Set index.  */
	while(argv[index] != NULL)
	{
		rt_gettree(rtip,argv[index]);
		index += 1;
	}

	/*  Find number of regions.  */
	numreg = (int)rtip->nregions;

	(void)fprintf(stderr,"Number of regions:  %d\n",numreg);
	(void)fflush(stderr);

	/*  Malloc everything now that the number of regions is known.  */
	info = (struct table *)bu_malloc(numreg * sizeof(*info), "info");
	for(i=0; i<numreg; i++)
	{
	   info[i].intrays = (double *)bu_malloc(numreg * sizeof(double), "info[i].intrays");
	   info[i].sf = (double *)bu_malloc(numreg * sizeof(double), "info[i].sf");
	}

	/*  Zero all arrays.  */
	for(i=0; i<numreg; i++)
	{						/*  START # 110  */
	   info[i].name = "\0";
	   info[i].lvrays = 0.;
	   for(j=0; j<numreg; j++)
	   {
		info[i].intrays[j] = 0.;
		info[i].sf[j] = 0.;
	   }
	   info[i].regarea = 0.;
	}						/*  END # 110  */

	/*  Get database ready by starting prep.  */
	rt_prep(rtip);

	/*  Find the center of the bounding rpp of entire model.  */
	centall[X] = rtip->mdl_min[X] +
		(rtip->mdl_max[X] - rtip->mdl_min[X]) / 2.;
	centall[Y] = rtip->mdl_min[Y] +
		(rtip->mdl_max[Y] - rtip->mdl_min[Y]) / 2.;
	centall[Z] = rtip->mdl_min[Z] +
		(rtip->mdl_max[Z] - rtip->mdl_min[Z]) / 2.;

	/*  Find minimum and maximum of entire model.  */
	minall[X] = rtip->mdl_min[X];
	minall[Y] = rtip->mdl_min[Y];
	minall[Z] = rtip->mdl_min[Z];
	maxall[X] = rtip->mdl_max[X];
	maxall[Y] = rtip->mdl_max[Y];
	maxall[Z] = rtip->mdl_max[Z];

	/*  Find radius of bounding sphere.  */
	radall = (maxall[X] - minall[X]) * (maxall[X] - minall[X])
	       + (maxall[Y] - minall[Y]) * (maxall[Y] - minall[Y])
	       + (maxall[Z] - minall[Z]) * (maxall[Z] - minall[Z]);
	/*  Add .5 to make sure completely outside the rpp.  */
	radall = sqrt(radall) / 2. + .5;

	/*  Find surface area of bounding sphere.  */
	areaall = 4 * M_PI * radall * radall;

	/*  Print info on min, max, center, radius, & surface area  */
	/*  of entire model.  */
	(void)printf("Min & max for entire model.\n");
	(void)printf("\tX:  %f - %f\n",minall[X],maxall[X]);
	(void)printf("\tY:  %f - %f\n",minall[Y],maxall[Y]);
	(void)printf("\tZ:  %f - %f\n",minall[Z],maxall[Z]);
	(void)printf("Center:  %f, %f, %f\n\n",centall[X],centall[Y],
		centall[Z]);
	(void)printf("Radius:  %f\n",radall);
	(void)printf("Surface Area:  %f\n\n",areaall);
	(void)fflush(stdout);

	/*  Find number of rays to fire.  */
	(void)printf("Enter the number of rays to be fired.\n\t");
	(void)fflush(stdout);
	(void)scanf("%lf",&rayfir);

	/*  Write info to files.  */
	(void)fprintf(fpw,"Min & max for entire region:\n");
	(void)fprintf(fpw,"\tX:  %f - %f\n",minall[X],maxall[X]);
	(void)fprintf(fpw,"\tY:  %f - %f\n",minall[Y],maxall[Y]);
	(void)fprintf(fpw,"\tZ:  %f - %f\n",minall[Z],maxall[Z]);
	(void)fprintf(fpw,"Center:  %f, %f, %f\n",centall[X],
		centall[Y],centall[Z]);
	(void)fprintf(fpw,"Radius:  %f\n",radall);
	(void)fprintf(fpw,"Surface area:  %f\n",areaall);
	(void)fprintf(fpw,"Number of rays fired:  %f\n\n",rayfir);
	(void)fflush(fpw);

	(void)fprintf(fpw1,"Min & max for entire region:\n");
	(void)fprintf(fpw1,"\tX:  %f - %f\n",minall[X],maxall[X]);
	(void)fprintf(fpw1,"\tY:  %f - %f\n",minall[Y],maxall[Y]);
	(void)fprintf(fpw1,"\tZ:  %f - %f\n",minall[Z],maxall[Z]);
	(void)fprintf(fpw1,"Center:  %f, %f, %f\n",centall[X],
		centall[Y],centall[Z]);
	(void)fprintf(fpw1,"Radius:  %f\n",radall);
	(void)fprintf(fpw1,"Surface area:  %f\n",areaall);
	(void)fprintf(fpw1,"Number of rays fired:  %f\n\n",rayfir);
	(void)fflush(fpw1);

	/*  Put region names into structure.  */
	pr = BU_LIST_FIRST(region, &rtip->HeadRegion);
	for(i=0; i<numreg; i++)
	{
	   info[(int)(pr->reg_bit)].name = pr->reg_name;
	   pr = BU_LIST_FORW(region, &(pr->l) );
	}

	(void)printf("Region names in structure.\n");
	(void)fflush(stdout);

	/*  Write region names to error file.  */
	for(i=0; i<numreg; i++)
	{
	   (void)fprintf(fpw1,"region %d:  %s\n",(i + 1),info[i].name);
	   (void)fflush(fpw1);
	}
	(void)fprintf(fpw1,"\n");
	(void)fflush(fpw1);

	/*  Set seed for random number generator.  */
	seed = 1;
	(void)printf("Do you wish to enter your own seed (0) or ");
	(void)printf("use the default of 1 (1)?\n\t");
	(void)fflush(stdout);
	(void)scanf("%d",&ians);
	if(ians == 0)
	{
	   (void)printf("Enter unsigned integer seed.\n\t");
	   (void)fflush(stdout);
	   (void)scanf("%ld",&seed);
	}
	msr = bn_unif_init(seed,0);

	(void)printf("Seed initialized\n");
	(void)fflush(stdout);

	/*  Set up parameters for rt_shootray.  */
	RT_APPLICATION_INIT(&ap);
	ap.a_hit = hit;			/*  User supplied hit func.  */
	ap.a_miss = miss;		/*  User supplied miss func.  */
	ap.a_overlap = overlap;		/*  User supplied overlap func.  */
	ap.a_rt_i = rtip;		/*  Pointer from rt_dirbuild.  */
	ap.a_onehit = 0;		/*  Look at all hits.  */
	ap.a_level = 0;			/*  Recursion level for diagnostics.  */
	ap.a_resource = 0;		/*  Address for resource struct.  */
/*
 *	(void)printf("Parameters for rt_shootray set.\n");
 *	(void)fflush(stdout);
 */

	   /*  Loop through for each ray fired.  */
	   for(r=0; r<rayfir; r++)
	   {						/*  START # 150  */
/*
 *		(void)printf("In loop - %f\n",r);
 *		(void)fflush(stdout);
 */

		/*  Find point on the bounding sphere.  The negative  */
		/*  of the unit vector of this point will be the  */
		/*  firing direction.  */
	        q = BN_UNIF_DOUBLE(msr) + 0.5;
		theta = q * 2. * M_PI;

		q = BN_UNIF_DOUBLE(msr) + 0.5;
		phi = (q * 2.) - 1.;
		phi = acos(phi);

		rho = radall;

		strtdir[X] = rho * sin(phi) * cos(theta);
		strtdir[Y] = rho * sin(phi) * sin(theta);
		strtdir[Z] = rho * cos(phi);

		/*  Elevation & azimuth for finding a vector in a plane.  */
		elev = M_PI / 2. - phi;
		az = theta;

		/*  Find vector in yz-plane.  */
		q = BN_UNIF_DOUBLE(msr) + 0.5;
		theta = q * 2. * M_PI;

		q = BN_UNIF_DOUBLE(msr) + 0.5;
		rds = rho * sqrt(q);
		s[X] = 0.;
		s[Y] = rds * cos(theta);
		s[Z] = rds * sin(theta);

		/*  Rotate vector.  */
		t[X] = s[X] * cos(elev) * cos(az) - s[Z] * sin(elev) * cos(az)
				- s[Y] * sin(az);
		t[Y] = s[X] * cos(elev) * sin(az) - s[Z] * sin(elev) * sin(az)
				+ s[Y] * cos(az);
		t[Z] = s[X] * sin(elev) + s[Z] * cos(elev);

		/*  Translate the point.  This is the starting point.  */
		strtpt[X] = t[X] + strtdir[X];
		strtpt[Y] = t[Y] + strtdir[Y];
		strtpt[Z] = t[Z] + strtdir[Z];

		/*  Now transfer the starting point so that it is in the  */
		/*  absolute coordinates not the origin's.  */
		strtpt[X] += centall[X];
		strtpt[Y] += centall[Y];
		strtpt[Z] += centall[Z];

		/*  Normalize starting direction & make negative.  */
		denom = strtdir[X] *strtdir[X] +
			strtdir[Y] *strtdir[Y] +
			strtdir[Z] *strtdir[Z];
		denom = sqrt(denom);
		strtdir[X] /= (-denom);
		strtdir[Y] /= (-denom);
		strtdir[Z] /= (-denom);

		/*  Set up firing point & direction.  */
		ap.a_ray.r_pt[X] = strtpt[X];
		ap.a_ray.r_pt[Y] = strtpt[Y];
		ap.a_ray.r_pt[Z] = strtpt[Z];
		ap.a_ray.r_dir[X] = strtdir[X];
		ap.a_ray.r_dir[Y] = strtdir[Y];
		ap.a_ray.r_dir[Z] = strtdir[Z];

/*
 *		(void)printf("Calling rt_shootray.\n");
 *		(void)fflush(stdout);
 */

		/*  Call rt_shootray.  */
		(void)rt_shootray(&ap);

/*
 *		(void)printf("Rt_shootray finished.\n");
 *		(void)fflush(stdout);
 */

	   }						/*  END # 150  */

/*
 *	   (void)printf("Finished loop.\n");
 *	   (void)fflush(stdout);
 */

	   for(i=0; i<numreg; i++)
	   {						/*  START # 160  */
	   /*  Write region names to output file.  */
	   (void)fprintf(fpw,"Region %d:  %s\n",(i+1),info[i].name);
	   (void)fflush(fpw);

	   /*  Find shape factors & print.  */
	   if(info[i].lvrays == 0)
	   {						/*  START # 1060  */
		(void)fprintf(fpw1,"**  ERROR - # or rays hitting region ");
		(void)fprintf(fpw1,"%d is 0.  **\n",i);
		(void)fflush(fpw1);
	   }						/*  END # 1060  */

	   else
	   {						/*  START # 1070  */
		/*  Must divide by 2. since looking forwards & backwards.  */
		info[i].regarea = info[i].lvrays / rayfir * areaall / 2.;
		for(j=0; j<numreg; j++)
		{					/*  START # 1080  */
			info[i].sf[j] = info[i].intrays[j] / info[i].lvrays;
			(void)fprintf(fpw,"\t%d   %d   %f\n",
				(i + 1),(j + 1),info[i].sf[j]);
			(void)fflush(fpw);

			(void)fprintf(fpw1,"reg %d - reg %d - rays leave ",
				(i + 1),(j + 1));
			(void)fprintf(fpw1,"& int %f - rays leave %f ",
				info[i].intrays[j],info[i].lvrays);
			(void)fprintf(fpw1,"- sf %f - area %f\n",
				info[i].sf[j],info[i].regarea);
			(void)fflush(fpw1);
		}					/*  END # 1080  */
	   }						/*  END # 1070  */
	   }						/*  END # 160  */

	   /*  Write lwx file.  */
	   (void)fprintf(fpw2,"Longwave Radiation Exchange Factors ");
	   (void)fprintf(fpw2,"for %s\n",argv[1]);
	   (void)fprintf(fpw2,"Number of Regions = %4d\n",numreg);
	   (void)fprintf(fpw2,"TEMIS\n\n");

	   for(i=0; i<numreg; i++)
	   {						/*  START # 1090  */
		(void)fprintf(fpw2,"Region\tArea\tEmissivity\n");
		/*  Area is put into square meters.  */
		(void)fprintf(fpw2,"%d\t%f\n",(i + 1),
			(info[i].regarea / 1000. / 1000.));

		/*  Count the number of shape factors.  */
		k = 0;
		for(j=0; j<numreg; j++)
		{
		   if(info[i].sf[j] != 0.) k++;
		}
		(void)fprintf(fpw2,"Bij\t%d\n",k);

		/*  Print shape factors.  */
		m = 0;
		for(j=0; j<numreg; j++)
		{					/*  START # 1100  */
		   if(info[i].sf[j] != 0.)
		   {					/*  START # 1110  */
			(void)fprintf(fpw2,"%4d   %.4f   ",(j + 1),
				info[i].sf[j]);
			m++;
			if(m == 5)
			{				/*  START # 1120  */
			   m = 0;
			   (void)fprintf(fpw2,"\n");
			}				/*  END # 1120  */
		   }					/*  END # 1110  */
		}					/*  END # 1100  */
		if(m != 0) (void)fprintf(fpw2,"\n");
		(void)fprintf(fpw2," Gnd         Sky\n\n");
		(void)fflush(fpw2);
	   }						/*  END # 1090  */


	/* free memory */
	for(i=0; i<numreg; i++)
	{
	   bu_free(info[i].intrays, "info[i].intrays");
	   bu_free(info[i].sf, "info[i].sf");
	}
	bu_free(info, "info");

	/*  Close files.  */
	(void)fclose(fpw);
	(void)fclose(fpw1);
	(void)fclose(fpw2);
   }							/*  END # 100  */
   return 0;
}							/*  END # 99  */


/***************************************************************************/
/*		Hit, miss, & overlap functions.                            */
/***************************************************************************/
/*  User supplied hit function.  */
int
hit(register struct application *ap_p, struct partition *PartHeadp, struct seg *segp)
{							/*  START # 1000  */
   register struct partition *pp;
   register struct hit *hitp;
   register struct soltab *stp;

   int rh1;		/*  1st region hit (leaving region).  */
   int rh2;		/*  2nd region hit (entering region).  */
   double lvpt[3];	/*  Leaving point of 1st region.  */
   double entpt[3];	/*  Entering point of 2nd region.  */
   double tol[3];	/*  Used to check tolerance of equal numbers.  */

/*
 * (void)fprintf(fpw1,"In function hit.\n");
 * (void)fflush(fpw1);
 */

   /*  Set regions hit to -1 to show no regions hit yet.  */
   rh1 = (-1);
   rh2 = (-1);

   /*  Set leave & enter points to show no hits yet.  */
   lvpt[X] = (-999.);
   lvpt[Y] = (-999.);
   lvpt[Z] = (-999.);
   entpt[X] = (-999.);
   entpt[Y] = (-999.);
   entpt[Z] = (-999.);

   /*  Set for first region.  */
   pp = PartHeadp->pt_forw;

   for(; pp != PartHeadp; pp=pp->pt_forw)
   {							/*  START # 1010  */
	if( (rh1 == (-1)) && (rh2 == (-1)) )
	{						/*  START # 1020  */
	   /*  First time through; therefore, find the region hit for  */
	   /*  the first region.  */

	   rh1 = (int)pp->pt_regionp->reg_bit;

	   /*  Find the leave point of the first region.  */
	   hitp = pp->pt_outhit;
	   stp = pp->pt_outseg->seg_stp;
	   RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
	   /*  Flip normal if needed.  */
	   if(pp->pt_outflip)
	   {
		VREVERSE(hitp->hit_normal,hitp->hit_normal);
		pp->pt_outflip = 0;
	   }
	   lvpt[X] = hitp->hit_point[X];
	   lvpt[Y] = hitp->hit_point[Y];
	   lvpt[Z] = hitp->hit_point[Z];

	   /*  Increment backwards for hitting ray.  */
	   info[rh1].lvrays += 1.;

	}						/*  END # 1020  */

	else
	{						/*  START # 1030  */
	   /*  Any time but the first time through.  Find the region hit  */
	   /*  for the second region.  */
	   rh2 = (int)pp->pt_regionp->reg_bit;

	   /*  Find the enter point for the second region.  */
	   hitp = pp->pt_inhit;
	   stp = pp->pt_inseg->seg_stp;
	   RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
	   /*  Flip normal if needed.  */
	   if(pp->pt_inflip)
	   {
		VREVERSE(hitp->hit_normal,hitp->hit_normal);
		pp->pt_inflip = 0;
	   }
	   entpt[X] = hitp->hit_point[X];
	   entpt[Y] = hitp->hit_point[Y];
	   entpt[Z] = hitp->hit_point[Z];

	   /*  Check if the leave & enter point are the same.  */
	   tol[X] = lvpt[X] - entpt[X];
	   tol[Y] = lvpt[Y] - entpt[Y];
	   tol[Z] = lvpt[Z] - entpt[Z];
	   if(tol[X] < 0.) tol[X] = (-tol[X]);
	   if(tol[Y] < 0.) tol[Y] = (-tol[Y]);
	   if(tol[Z] < 0.) tol[Z] = (-tol[Z]);

	   if( (tol[X] < VDIVIDE_TOL) && (tol[Y] < VDIVIDE_TOL) && (tol[Z] < VDIVIDE_TOL) )
	   {
		/*  Nothing happens since the points are the same.  */
	   }

	   else
	   {						/*  START # 1040  */
		/*  The points are not the same; therefore, increment  */
		/*  appropriately.  */
		info[rh1].lvrays += 1.;
		info[rh1].intrays[rh2] += 1.;

		/*  Increment backwards also.  */
		info[rh2].lvrays += 1.;
		info[rh2].intrays[rh1] += 1.;
	   }						/*  END # 1040  */

	   /*  Find info for 1st region.  */
	   rh1 = rh2;
	   /*  Find leaving point.  */
	   hitp = pp->pt_outhit;
	   stp = pp->pt_outseg->seg_stp;
	   RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
	   /*  Flip normal if needed.  */
	   if(pp->pt_outflip)
	   {
		VREVERSE(hitp->hit_normal,hitp->hit_normal);
		pp->pt_outflip = 0;
	   }
	   lvpt[X] = hitp->hit_point[X];
	   lvpt[Y] = hitp->hit_point[Y];
	   lvpt[Z] = hitp->hit_point[Z];

	}						/*  END # 1030  */
   }							/*  END # 1010  */

   /*  Increment the leaving ray since it leaves & doesn't hit anything.  */
   info[rh1].lvrays += 1.;

   return(0);
}							/*  END # 1000  */

/***************************************************************************/
/*  User supplied hit function.  */
int
miss(struct application *ap)
{							/*  START # 2000  */
   return(1);
}							/*  END # 2000  */

/***************************************************************************/
/*  User supplied overlap function.  */
int
overlap(struct application *ap, struct partition *pp, struct region *r1, struct region *r2, struct partition *hp)
{							/*  START # 3000  */
   return(2);
}							/*  END # 3000  */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.17
log
@yet another surge of level 4 flawfinder string length checks. somewhere around 30-40% done.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.16 2007/09/15 16:23:06 brlcad Exp $ (BRL)";
d51 1
a51 1
extern int overlap(void);   /*  User supplied overlap function.  */
d665 1
a665 1
overlap(void)
@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.15 2007/07/26 01:13:54 brlcad Exp $ (BRL)";
d126 1
a126 1
	(void)scanf("%s",outfile);
d133 1
a133 1
	(void)scanf("%s",lwxfile);
d138 1
a138 1
	(void)scanf("%s",errfile);
@


14.15
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.14 2007/05/14 21:04:31 brlcad Exp $ (BRL)";
d40 1
a40 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.14
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@a27 5
 *  Source -
 *      SECAD/VLD Computing Consortium, Bldg 394
 *      The U. S. Army Ballistic Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5066
 *
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.13 2007/01/27 01:41:35 brlcad Exp $ (BRL)";
@


14.13
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.12 2007/01/23 01:13:32 brlcad Exp $ (BRL)";
a55 1
#include "msr.h"
d121 2
d320 2
a321 9
#ifdef MSRMAXTBL
	   msr = msr_unif_init(seed,0);
#else
#  ifndef HAVE_SRAND48
	   (void)srandom(seed);
#  else
	   (void)srand48(seed);
#  endif
#endif
d350 1
a350 5
#		ifdef MSRMAXTBL
		   q = MSR_UNIF_DOUBLE(msr) + 0.5;
#		else
		   q = drand48();
#		endif
d353 1
a353 5
#		ifdef MSRMAXTBL
		   q = MSR_UNIF_DOUBLE(msr) + 0.5;
#		else
		   q = drand48();
#		endif
d368 1
a368 5
#		ifdef MSRMAXTBL
		   q = MSR_UNIF_DOUBLE(msr) + 0.5;
#		else
		   q = drand48();
#		endif
d371 1
a371 5
#		ifdef MSRMAXTBL
		   q = MSR_UNIF_DOUBLE(msr) + 0.5;
#		else
		   q = drand48();
#		endif
@


14.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.11 2007/01/20 14:36:50 brlcad Exp $ (BRL)";
d125 1
a125 1
        (void)fprintf(stderr,"\nusage:  %s file.g objects\n\n", *argv);
d174 16
a189 16
        /*  Build directory.  */
        index = 1;      /*  Set index for rt_dirbuild.  */
        rtip = rt_dirbuild(argv[index],idbuf,sizeof(idbuf));
        (void)printf("Database Title:  %s\n",idbuf);
        (void)fflush(stdout);

        /*  Set useair to 0 to show no hits of air.  */
        rtip->useair = 0;

        /*  Load desired objects.  */
        index = 2;      /*  Set index.  */
        while(argv[index] != NULL)
        {
                rt_gettree(rtip,argv[index]);
                index += 1;
        }
d191 2
a192 2
        /*  Find number of regions.  */
        numreg = (int)rtip->nregions;
d194 2
a195 2
        (void)fprintf(stderr,"Number of regions:  %d\n",numreg);
        (void)fflush(stderr);
d218 2
a219 2
        /*  Get database ready by starting prep.  */
        rt_prep(rtip);
d221 7
a227 7
        /*  Find the center of the bounding rpp of entire model.  */
        centall[X] = rtip->mdl_min[X] +
                (rtip->mdl_max[X] - rtip->mdl_min[X]) / 2.;
        centall[Y] = rtip->mdl_min[Y] +
                (rtip->mdl_max[Y] - rtip->mdl_min[Y]) / 2.;
        centall[Z] = rtip->mdl_min[Z] +
                (rtip->mdl_max[Z] - rtip->mdl_min[Z]) / 2.;
d287 7
a293 7
        /*  Put region names into structure.  */
        pr = BU_LIST_FIRST(region, &rtip->HeadRegion);
        for(i=0; i<numreg; i++)
        {
           info[(int)(pr->reg_bit)].name = pr->reg_name;
           pr = BU_LIST_FORW(region, &(pr->l) );
        }
d419 2
a420 2
		        strtdir[Y] *strtdir[Y] +
		        strtdir[Z] *strtdir[Z];
@


14.11
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.10 2006/04/05 19:17:57 brlcad Exp $ (BRL)";
@


14.10
log
@more header/warning cleanup from Intel compiler warnings on Altix
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2006 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.9 2006/01/23 07:15:53 brlcad Exp $ (BRL)";
@


14.9
log
@use M_PI instead of PI, VDIVIDE_TOL instead of ZTOL, and libbu memory management
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.8 2006/01/18 06:46:15 brlcad Exp $ (BRL)";
d44 1
@


14.9.2.1
log
@update from HEAD
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.9 2006/01/23 07:15:53 brlcad Exp $ (BRL)";
a43 1
#include <stdlib.h>
@


14.8
log
@update copyright to 2006
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.7 2005/12/02 21:13:52 brlcad Exp $ (BRL)";
a58 6
#if !defined(PI)
#  define PI 3.14159265358979323846262    /*  Pi.  */
#endif
#define ZTOL 1.e-20	/*  Zero tolerance.  */


d198 1
a198 1
	info = (struct table *)malloc(numreg * sizeof(*info));
d201 2
a202 2
	   info[i].intrays = (double *)malloc(numreg * sizeof(double));
	   info[i].sf = (double *)malloc(numreg * sizeof(double));
d245 1
a245 1
	areaall = 4 * PI * radall * radall;
d361 1
a361 1
		theta = q * 2. * PI;
d378 1
a378 1
		elev = PI / 2. - phi;
d387 1
a387 1
		theta = q * 2. * PI;
d532 9
d643 1
a643 1
	   if( (tol[X] < ZTOL) && (tol[Y] < ZTOL) && (tol[Z] < ZTOL) )
@


14.7
log
@use RT_APPLICATION_INIT and deglobal the unnecessarily global ap structure
@
text
@d4 1
a4 1
 * Copyright (C) 1990-2005 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.6 2005/10/23 04:44:31 brlcad Exp $ (BRL)";
@


14.6
log
@trailing ws
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.5 2005/03/28 23:39:56 brlcad Exp $ (BRL)";
a63 1
struct application ap;  /*  Structure passed between functions.  */
d94 1
d338 1
@


14.5
log
@use HAVE_SRAND48 symbol check
@
text
@d28 1
a28 1
 *  
d33 1
a33 1
 *  
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.4 2005/01/30 20:30:40 brlcad Exp $ (BRL)";
@


14.5.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d33 1
a33 1
 *
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


14.4
log
@update copyright to 2005
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/all_sf.c,v 14.3 2004/12/21 06:38:19 morrison Exp $ (BRL)";
d328 1
a328 1
#  ifndef HAVE_DRAND48
@


14.3
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2004 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/all_sf.c,v 14.2 2004/12/21 01:08:03 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL license
@
text
@a33 3
 *  Copyright Notice -
 *      This software is Copyright (C) 1990-2004 by the United States Army.
 *      All rights reserved.
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/all_sf.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *                      A L L _ S F . C
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/all_sf.c,v 1.5 2004/09/16 03:21:41 morrison Exp $ (BRL)";
@


1.5
log
@match the a_hit and a_miss prototypes
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/all_sf.c,v 1.4 2004/09/03 23:30:57 morrison Exp $ (BRL)";
d680 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/all_sf.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
a27 2


d30 1
a30 1
#include <string.h>
d32 1
a32 1
#include <strings.h>
d42 1
d44 1
a44 1
#define PI 3.14159265358979323846262    /*  Pi.  */
d50 2
a51 2
extern int hit(register struct application *ap_p, struct partition *PartHeadp);       /*  User supplied hit function.  */
extern int miss(void);      /*  User supplied miss function.  */
d533 1
d535 1
a535 6
hit(register struct application *ap_p, struct partition *PartHeadp)

/*  User supplied hit function.  */

                                  
                            
d666 1
d668 1
a668 4
miss(void)

/*  User supplied hit function.  */

a669 1

d674 1
a676 3

/*  User supplied overlap function.  */

a677 1

a679 1

@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/all_sf.c,v 1.2 2004/06/08 22:04:16 morrison Exp $ (BRL)";
d31 1
a31 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 1
a26 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/irprep/all_sf.c,v 11.12 2004/05/10 15:30:42 erikg Exp $ (BRL)";
a41 1
#include "externs.h"
@

