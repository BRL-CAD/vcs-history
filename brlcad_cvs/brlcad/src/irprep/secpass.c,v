head	14.15;
access;
symbols
	rel-7-10-4:14.12
	STABLE:14.12.0.2
	stable-branch:14.4
	rel-7-10-2:14.12
	rel-7-10-0:14.11
	rel-7-8-4:14.8
	rel-7-8-2:14.8
	rel-7-8-0:14.8
	trimnurbs-branch:14.8.0.2
	help:14.8
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.5
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.15
date	2007.12.14.20.58.54;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.10.26.21.51.26;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.07.26.01.13.54;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.02.20.07.53.37;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.23.01.13.32;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.20.14.36.50;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.23.07.14.49;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.12.02.21.17.05;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.31;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.30.41;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.21.06.38.19;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.01.08.03;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.16.03.36.31;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.16;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.20;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.14;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.15
log
@quell warnings
@
text
@/*                       S E C P A S S . C
 * BRL-CAD
 *
 * Copyright (c) 1990-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file secpass.c
 *
 *  Author -
 *	S.Coates - 11 February 1993
 *
 *  Notes -
 *	This version ONLY shoots down x-axis.
 */

/*	To compile:  cc -c secpass.c  */
/*		     cake  */

/*	CHANGES		*/
/*	11 December 1990 - 'Dimension' arrays using malloc.  */
/*	18 December 1990 - Incorperates subroutines rotate and radians.  */
/*	19 February 1991 - No defaults for material properties, thermal  */
/*			   conductivity is zero if one is zero.  */
/*	25 February 1991 - Print triangular conductivity file (still  */
/*			   computes entire matrix).  */
/*	14 March 1991    - Creates a generic file if needed.  */
/*	13 May 1991      - Remove some write statements.  */
/*	24 October 1991  - Put in appropriate include statements so that  */
/*			   I can compile.  */
/*	30 October 1991  - Make region numbering scheme the same through-  */
/*			   out, i.e. region numbers start at 1.  */
/*	15 November 1991 - Make a change to printing of conductivity table.  */
/*	11 February 1992 - Reverse order of regions in writing conductivity  */
/*			   file.  The largest number must come first.  */
/*	13 February 1992 - Change format for writing PRISM 3.0 files.  */
/*	10 March 1992    - Print out PRISM release being used.  */
/*	11 February 1993 - Add option to fire from three orthogonal  */
/*			   directions.  */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.14 2007/10/26 21:51:26 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"


#define ADJTOL 1.e-1	/*  Tolerance for adjacent regions.  */
#define ZEROTOL 1.e-20	/*  Tolerance for dividing by zero.  */
#define MINCAL 10	/*  Minimum number of calculations for length.  */
#define ALPHA 25.	/*  Rotation about z-axis.  */
#define BETA 50.	/*  Rotation about y-axis.  */
#define GAMMA 35.	/*  Rotation about x-axis.  */


extern int hit(register struct application *ap_p, struct partition *PartHeadp, struct seg *segp);	/*  User defined hit function.  */
extern int miss(register struct application *ap_p);	/*  User defined miss function.  */
extern int ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2, struct partition *hp);	/*  User defined overlap function.  */
extern void rotate(double *p, double *a, double *np);	/*  Subroutine to rotate a point.  */
extern double radians(double a);/*  Subroutine to put an angle into radians.  */

/*  Define structure.  */
/*  Make arrays into pointers such that malloc may be used  */
/*  later.  */
struct table
{
  double centroid[3];	/*  centroid of region  */
  double *shrarea;	/*  shared surface area between adjacent  */
  /*  regions  */
  int mat;		/*  material id  */
  double *avglen;		/*  average length between centroid &  */
				/*  shared surface area  */
  double *rmslen;		/*  root mean squared length between  */
				/*  centroid & shared surface area  */
  double *minlen;		/*  minimum length between centroid &  */
				/*  shared surface area  */
  double *maxlen;		/*  maximum length between centroid &  */
				/*  shared surface area  */
  double *numcal;		/*  number of length calculations  */
  double *rkavg;		/*  rk value using average length  */
  double *rkrms;		/*  rk value using root mean squared length  */
  double *rkmin;		/*  rk value using minimum length  */
  double *rkmax;		/*  rk value using maximum length  */
};

struct table *cond;		/*  name of table structure  */

int iprev;			/*  previous region hit  */
int icur;			/*  current region hit  */
double enterpt[3];		/*  point where ray enters  */
double leavept[3];		/*  point where ray leaves  */

int main(int argc, char **argv)
{	/*  START # 1  */
  struct application ap;	/*  Structure passed between functions.  */

  static struct rt_i *rtip;	/*  *rtip pointer to structure of  */
				/*  type rt_i  */
  char idbuf[132];	/*  first ID record info, used in  */
			/*  rt_dirbuild  */
  int index;		/*  index for rt_dirbuild & rt_gettree  */

  FILE *fp;		/*  used in opening file for second pass  */
  char spfile[16];	/*  second pass file name  */
  FILE *fp1=NULL;		/*  conductivity file  */
  char confile[16];	/*  conductivity file  */
  FILE *fp2;		/*  conductivity table file  */
  char tblfile[16];	/*  conductivity table file  */

  int i,j;		/*  integers used in loops  */
  int numreg;		/*  number of regions  */
  int nmged;		/*  number of regions in mged file  */
  double gridspace;	/*  spacing between fired rays  */
  int iwrite;		/*  0 => write to standard out, 1 => write  */
			/*  to file  */
  int typeout;		/*  Type of file to be written, 0 => PRISM file,  */
			/*  1 => generic file.  */
  FILE *fp6;		/*  Used in writing generic file.  */
  char genfile[16];	/*  Generic file name.  */
  FILE *fp3=NULL;		/*  used for writing output to file  */
  char filename[16];	/*  output file name  */

  FILE *fp5;		/*  material file  */
  char filemat[16];	/*  material file  */
  char line[150];	/*  used for reading a line from a file  */
  double k[41];	/*  thermal conductivity  */
  int itype;		/*  type of length measurement to use for  */
			/*  rk calculations  */
  double rki,rkj;	/*  used in finding rk  */
  double ki,kj;	/*  thermal conductivity of region  */
  double leni,lenj;	/*  lengths used in finding rk  */
  double areai;	/*  areas used in finding rk  */
  double a1;		/*  area used in writing conductivity table  */
  double l1,l2,l3,l4;	/*  lengths used in writing conductivity table  */
  FILE *fp4;		/*  error file  */
  char fileerr[16];	/*  error file  */

  double angle[3];	/*  Angles of rotation.  angle[0]-rotation about  */
			/*  x-axis, angle[1]-rotation about y-axis, &  */
			/*  angle[2]-rotation about z-axis.  */
  double strtpt[3];	/*  Starting point of fired ray.  */
  double strtdir[3];	/*  Starting direction of fired ray.  */
  double r[3],t[3];	/*  Used in computing rotations.  */
  double center[3];	/*  Center point of bounding rpp.  */
  double diagonal;	/*  Length of diagonal of bounding rpp.  */
  double xmin,xmax;	/*  Maximum & minimum x of grid.  */
  double ymin,ymax;	/*  Maximum & minimum y of grid.  */
  double zmin,zmax;	/*  Maximum & minimum z of grid.  */
  int nadjreg;		/*  Number of adjacent regions.  */
  int prmrel;		/*  PRISM release number, 2=>2.0, 3=>3.0.  */
  int ifire;		/*  Number of sets of rays to be fired, 0=>  */
			/*  fire from 3 orthogonal postions, 1=>fire  */
			/*  from 1 position.  */

  /*  Check to see if arguments implimented correctly.  */
  if(argv[1] == NULL || argv[2] == NULL)
    {
      (void)fprintf(stderr,"\nusage:  secpass file.g objects\n\n");
    }

  else
    {	/*  START # 2  */

	/*  Ask if output goes to standard out or to a file.  */
      (void)fprintf(stdout,"Write output to standard out (0) or a file(1) ");
      (void)fprintf(stdout,"not at all (2)?  ");
      (void)fflush(stdout);
      (void)scanf("%d",&iwrite);
      if((iwrite != 0) && (iwrite != 1)) iwrite=2;
      if(iwrite == 1)
	{
	  (void)fprintf(stdout,"Enter name of output file (15 char max).  ");
	  (void)fflush(stdout);
	  (void)scanf("%15s",filename);
	  fp3 = fopen(filename,"w");
	}

      /*  Which file that has second pass information in it?  */
      (void)fprintf(stdout,"Enter name of file that has second pass ");
      (void)fprintf(stdout,"information\nin it (15 char max).  ");
      (void)fflush(stdout);
      (void)scanf("%15s",spfile);

      /*  Ask for type of output file to be generated.  */
      (void)printf("Enter type of output file to be generated.\n");
      (void)printf("\t 0 - PRISM File\n");
      (void)printf("\t 1 - Generic File\n");
      (void)fflush(stdout);
      (void)scanf("%d",&typeout);

      /*  Read name of file to write conductivity information  */
      /*  to for use in PRISM.  */
      if(typeout == 0)
	{
	  (void)fprintf(stdout,"Enter name of file to be created for PRISM ");
	  (void)fprintf(stdout,"conductivity\ninformation (15 char max).  ");
	  (void)fflush(stdout);
	  (void)scanf("%15s",confile);

	  /*  Find which release of PRISM is being used.  The format  */
	  /*  for writing region numbers is I3 for PRISM 2.0 & I6 for  */
	  /*  PRISM 3.0.  */
	  prmrel = 2;
	  (void)printf("Which release of PRISM is being used, 2.0 (2) ");
	  (void)printf("or 3.0 (3)?  ");
	  (void)fflush(stdout);
	  (void)scanf("%d",&prmrel);
	  if(prmrel != 3) prmrel = 2;
	}

      /*  Read generic file name if necessary.  */
      if(typeout == 1)
	{
	  (void)printf("Enter name of generic file to be created (15 char ");
	  (void)printf("max).  ");
	  (void)fflush(stdout);
	  (void)scanf("%15s",genfile);
	}

      /*  Which calculated length should be used when writing to  */
      /*  this file:  1 -> average length, 2 -> rms length, 3 ->  */
      /*  minimum length, and 4 -> maximum length.  */
      (void)fprintf(stdout,"Which length calculation should be used when\n");
      (void)fprintf(stdout,"computing conduction\nbetween regions?\n");
      (void)fprintf(stdout,"\t1 - average length\n");
      (void)fprintf(stdout,"\t2 - rms length\n");
      (void)fprintf(stdout,"\t3 - minimum length\n");
      (void)fprintf(stdout,"\t4 - maximum length\n");
      (void)fflush(stdout);
      (void)scanf("%d",&itype);

      /*  Read name of file to write conductivity information to  */
      /*  in table format.  */
      (void)fprintf(stdout,"Enter name of file to be created for ");
      (void)fprintf(stdout,"conductivity\ntable (15 char max).  ");
      (void)fflush(stdout);
      (void)scanf("%15s",tblfile);

      /*  Read name of material file that contains thermal  */
      /*  conductivity information.  */
      (void)fprintf(stdout,"Enter name of material file (15 char max).  ");
      (void)fflush(stdout);
      (void)scanf("%15s",filemat);

      /*  Read name of error file.  */
      (void)fprintf(stdout,"Enter name of error file to be created ");
      (void)fprintf(stdout,"(15 char max).  ");
      (void)fflush(stdout);
      (void)scanf("%15s",fileerr);

      /*  Choose whether 3 orthogonal sets of rays are to be fired  */
      /*  or 1 set of rays is to be fired.  */
      (void)printf("Should there be 3 sets of orhogonal rays fired ");
      (void)printf("(0) or 1 set (1)?\n\t");
      (void)fflush(stdout);
      (void)scanf("%d",&ifire);
      if(ifire != 0) ifire = 1;
      if(ifire == 0)
	{
	  (void)printf("3 sets of orthogonal rays will be fired.\n");
	}
      if(ifire == 1)
	{
	  (void)printf("1 set of rays will be fired.\n");
	}
      (void)fflush(stdout);

      /*  Write out file information.  */
      if(iwrite ==1)
	{
	  (void)fprintf(fp3,"\nsecond pass file:  %s\n",spfile);
	  (void)fprintf(fp3,"material file:  %s\n",filemat);
	  if(typeout == 0)
	    {
	      (void)fprintf(fp3,"conductivity file for use ");
	      (void)fprintf(fp3,"with PRISM:  %s\n",confile);
	      (void)fprintf(fp3,"  (format is PRISM %d.0)\n",prmrel);
	    }
	  if(typeout == 1) (void)fprintf(fp3,"generic file:  %s\n",genfile);
	  (void)fflush(fp3);
	  if(itype == 1) (void)fprintf(fp3,"\taverage length being used\n");
	  if(itype == 2) (void)fprintf(fp3,"\trms length being used\n");
	  if(itype == 3) (void)fprintf(fp3,"\tminimum length being used\n");
	  if(itype == 4) (void)fprintf(fp3,"\tmaximum length being used\n");
	  (void)fprintf(fp3,"conductivity table file:  %s\n",tblfile);
	  (void)fprintf(fp3,"error file:  %s\n\n",fileerr);
	  (void)fflush(fp3);
	}

      /*  Read thermal conductivity file.  */
      fp5 = fopen(filemat,"r");
      for(i=0; i<41; i++)
	{
	  (void)bu_fgets(line,151,fp5);
	  (void)sscanf(line,"%*d%*f%*f%*f%*f%lf",&k[i]);
	}

      /*  Print out the thermal conductivity.  */
      /*
       *	for(i=0; i<41; i++)
       *	{
       *	   (void)fprintf(stdout,"  thermal conductivity %d = %f\n",i,k[i]);
       *	   (void)fflush(stdout);
       *	}
       */

      /*  Build the directory.  */
      index = 1;	/*  Set index for rt_dirbuild.  */
      rtip=rt_dirbuild(argv[index],idbuf,sizeof(idbuf));
      (void)fprintf(stdout,"Database title:  %s\n",idbuf);
      (void)fflush(stdout);

      /*  Set useair to 1, to show hits of air.  */
      rtip->useair = 1;

      /*  Load desired objects.  */
      index = 2;	/*  Set index for rt_gettree.  */
      while(argv[index] != NULL)
	{
	  rt_gettree(rtip,argv[index]);
	  index += 1;
	}

      /*  Find total number of regions in mged file.  */
      nmged = (int)rtip->nregions;

      (void)fprintf(stdout,"Number of regions in mged file:  %d\n",nmged);
      (void)fflush(stdout);

      if(iwrite == 1)
	{
	  (void)fprintf(fp3,"Number of regions in mged file:  %d\n",nmged);
	  (void)fflush(fp3);
	}

      /*  Number of regions known, everything can be malloced.  */
      (void)fprintf(stdout,"Mallocing arrays.\n");
      (void)fflush(stdout);

      cond = (struct table *)bu_malloc( nmged * sizeof(struct table), "cond" );
      (void)fprintf(stdout,"cond malloced\n");
      (void)fflush(stdout);
      for(i=0; i<nmged; i++)
	{
	  cond[i].shrarea = (double *)bu_malloc( nmged * sizeof(double), "cond[i].shrarea" );
	  cond[i].avglen = (double *)bu_malloc( nmged * sizeof(double), "cond[i].avglen" );
	  cond[i].rmslen = (double *)bu_malloc( nmged * sizeof(double), "cond[i].rmslen" );
	  cond[i].minlen = (double *)bu_malloc( nmged * sizeof(double), "cond[i].minlen" );
	  cond[i].maxlen = (double *)bu_malloc( nmged * sizeof(double), "cond[i].maxlen" );
	  cond[i].numcal = (double *)bu_malloc( nmged * sizeof(double), "cond[i].numcal" );
	  cond[i].rkavg = (double *)bu_malloc( nmged * sizeof(double), "cond[i].rkavg" );
	  cond[i].rkrms = (double *)bu_malloc( nmged * sizeof(double), "cond[i].rkrms" );
	  cond[i].rkmin = (double *)bu_malloc( nmged * sizeof(double), "cond[i].rkmin" );
	  cond[i].rkmax = (double *)bu_malloc( nmged * sizeof(double), "cond[i].rkmax" );
	}
      (void)fprintf(stdout,"loop malloced\n");
      (void)fflush(stdout);

      /*  All variables 'dimensioned', now zero all variables.  */
      for(i=0; i<nmged; i++)
	{
	  cond[i].centroid[0] = (double)0.;
	  cond[i].centroid[1] = (double)0.;
	  cond[i].centroid[2] = (double)0.;
	  cond[i].mat = (int)0;
	  for(j=0; j<nmged; j++)
	    {
	      cond[i].shrarea[j] = (double)0.;
	      cond[i].avglen[j] = (double)0.;
	      cond[i].rmslen[j] = (double)0.;
	      cond[i].minlen[j] = (double)0.;
	      cond[i].maxlen[j] = (double)0.;
	      cond[i].numcal[j] = (double)0.;
	      cond[i].rkavg[j] = (double)0.;
	      cond[i].rkrms[j] = (double)0.;
	      cond[i].rkmin[j] = (double)0.;
	      cond[i].rkmax[j] = (double)0.;
	    }
	}
      (void)fprintf(stdout,"All variables zeroed.\n");
      (void)fflush(stdout);

      /*  Now open file with second pass information in it.  */
      fp = fopen(spfile,"r");
      (void)fprintf(stdout,"second pass file opened\n");
      (void)fflush(stdout);

      /*  Read number of regions in file.  */
      (void)fscanf(fp,"%d\n",&numreg);
      (void)fprintf(stdout,"The number of regions read was %d\n",numreg);
      (void)fflush(stdout);

      if(iwrite == 1)
	{
	  (void)fprintf(fp3,"number of regions read from second ");
	  (void)fprintf(fp3,"pass file:  %d\n",numreg);
	  (void)fflush(fp3);
	}

      /*  Read all information in file.  */
      for(i=0; i<numreg; i++)
	{
	  (void)fscanf(fp,"%*d%le%le%le%d\n",&cond[i].centroid[0],
		       &cond[i].centroid[1],
		       &cond[i].centroid[2],&cond[i].mat);
	  /*
	   *	   (void)fprintf(stdout,"reg=%8d, centroid:  %10.0f, %10.0f, %10.0f\n",
	   *		i,cond[i].centroid[0],cond[i].centroid[1],cond[i].centroid[2]);
	   *	   (void)fflush(stdout);
	   */

	  for(j=0; j<numreg; j++)
	    {
	      (void)fscanf(fp,"%*d%le\n",&cond[i].shrarea[j]);
	      /*
	       *		(void)fprintf(stdout,"\treg=%8d, area=%10.0f\n",
	       *		   j,cond[i].shrarea[j]);
	       *		(void)fflush(stdout);
	       */
	    }
	}

      (void)fclose(fp);

      /*  Check that the number of regions in the mged file  */
      /*  and the second pass file are equal.  */
      if(nmged != numreg)
	{
	  (void)fprintf(stdout,"ERROR -- The number of regions in the mged\n");
	  (void)fprintf(stdout,"file (%d) does not equal the number of\n",
			nmged);
	  (void)fprintf(stdout,"regions in the second pass file (%d).\n",
			numreg);
	  (void)fprintf(stdout,"Watch for unexplained errors.\n");
	  (void)fflush(stdout);

	  if(iwrite == 1)
	    {
	      (void)fprintf(fp3,"ERROR -- The number of regions in the mged\n");
	      (void)fprintf(fp3,"file (%d) does not equal the number of\n",
			    nmged);
	      (void)fprintf(fp3,"regions in the second pass file (%d).\n",
			    numreg);
	      (void)fprintf(fp3,"Watch for unexplained errors.\n");
	      (void)fflush(fp3);
	    }
	}

      /*  Get database ready by starting preparation.  */
      rt_prep(rtip);

      /*  Find center of bounding rpp.  */
      center[X] = rtip->mdl_min[X] + (rtip->mdl_max[X] -
				      rtip->mdl_min[X]) / 2.;
      center[Y] = rtip->mdl_min[Y] + (rtip->mdl_max[Y] -
				      rtip->mdl_min[Y]) / 2.;
      center[Z] = rtip->mdl_min[Z] + (rtip->mdl_max[Z] -
				      rtip->mdl_min[Z]) / 2.;

      /*  Find length of diagonal.  */
      diagonal = (rtip->mdl_max[X] - rtip->mdl_min[X])
	* (rtip->mdl_max[X] - rtip->mdl_min[X])
	+ (rtip->mdl_max[Y] - rtip->mdl_min[Y])
	* (rtip->mdl_max[Y] - rtip->mdl_min[Y])
	+ (rtip->mdl_max[Z] - rtip->mdl_min[Z])
	* (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
      diagonal = sqrt(diagonal) / 2. + .5;

      /*  Find minimum & maximum of grid.  */
      xmin = center[X] - diagonal;
      xmax = center[X] + diagonal;
      ymin = center[Y] - diagonal;
      ymax = center[Y] + diagonal;
      zmin = center[Z] - diagonal;
      zmax = center[Z] + diagonal;

      /*  Print center of bounding rpp, diagonal, & maximum  */
      /*  & minimum of grid.  */
      (void)fprintf(stdout,"Center of bounding rpp ( %f, %f, %f )\n",
		    center[X],center[Y],center[Z]);
      (void)fprintf(stdout,"Length of diagonal of bounding rpp:  %f\n",
		    diagonal);
      (void)fprintf(stdout,"Minimums & maximums of grid:\n");
      (void)fprintf(stdout,"  %f - %f\n",xmin,xmax);
      (void)fprintf(stdout,"  %f - %f\n",ymin,ymax);
      (void)fprintf(stdout,"  %f - %f\n\n",zmin,zmax);
      (void)fflush(stdout);

      /*  Write model minimum & maximum.  */
      (void)fprintf(stdout,"Model minimum & maximum.\n");
      (void)fprintf(stdout,"\tX:  %f to %f\n\tY:  %f to %f\n\tZ:  %f to %f\n\n",
		    rtip->mdl_min[X],rtip->mdl_max[X],
		    rtip->mdl_min[Y],rtip->mdl_max[Y],
		    rtip->mdl_min[Z],rtip->mdl_max[Z]);
      (void)fflush(stdout);

      if(iwrite == 1)
	{
	  (void)fprintf(fp3,"Model minimum & maximum.\n");
	  (void)fprintf(fp3,"\tX:  %f to %f\n\tY:  %f kto %f\n",
			rtip->mdl_min[X],rtip->mdl_max[X],
			rtip->mdl_min[Y],rtip->mdl_max[Y]);
	  (void)fprintf(fp3,"\tZ:  %f to %f\n\n",
			rtip->mdl_min[Z],rtip->mdl_max[Z]);
	  (void)fflush(fp3);
	}

      /*  User enters grid spacing.  All units are in mm.  */
      (void)fprintf(stdout,"Enter spacing (mm) between fired rays.  ");
      (void)fflush(stdout);
      (void)scanf("%lf",&gridspace);

      (void)fprintf(stdout,"\ngrid spacing:  %f\n",gridspace);
      (void)fflush(stdout);

      if(iwrite == 1)
	{
	  (void)fprintf(fp3,"gridspacing:  %f\n\n",gridspace);
	  (void)fflush(fp3);
	}

      /*  Set up parameters for rt_shootray.  */
      RT_APPLICATION_INIT(&ap);
      ap.a_hit = hit;		/*  User supplied hit function.  */
      ap.a_miss = miss;	/*  User supplied miss function.  */
      ap.a_overlap = ovrlap;	/*  user supplied overlap function.  */
      ap.a_rt_i = rtip;	/*  Pointer from rt_dirbuild.  */
      ap.a_onehit = 0;	/*  Hit flag (returns all hits).  */
      ap.a_level = 0;		/*  Recursion level for diagnostics.  */
      ap.a_resource = 0;	/*  Address of resource structure (NULL).  */

      /*  Put angles for rotation into radians.  */
      angle[X] = radians((double)GAMMA);
      angle[Y] = radians((double)BETA);
      angle[Z] = radians((double)ALPHA);

      /*  Set up and shoot down the 1st axis, positive to negative  */
      /*  (x-axis).  */

      (void)fprintf(stdout,"\nShooting down 1st axis.\n");
      (void)fflush(stdout);

      strtpt[X] = xmax;
      strtpt[Y] = ymin + gridspace / 2.;
      strtpt[Z] = zmin + gridspace / 2.;
      strtdir[X] = (-1);
      strtdir[Y] = 0;
      strtdir[Z] = 0;

      /*  Rotate starting point.  (new pt = C + R[P -C])  */
      t[X] = strtpt[X] - center[X];
      t[Y] = strtpt[Y] - center[Y];
      t[Z] = strtpt[Z] - center[Z];

      (void)rotate(t,angle,r);

      ap.a_ray.r_pt[X] = center[X] + r[X];
      ap.a_ray.r_pt[Y] = center[Y] + r[Y];
      ap.a_ray.r_pt[Z] = center[Z] + r[Z];

      /*  Rotate firing direction.  (new dir = R[D])  */
      (void)rotate(strtdir,angle,r);
      ap.a_ray.r_dir[X] = r[X];
      ap.a_ray.r_dir[Y] = r[Y];
      ap.a_ray.r_dir[Z] = r[Z];

      while(strtpt[Z] <= zmax)
	{	/*  START # 3  */

	  iprev = (-1);	/*  No previous shots.  */

	  /*  Call rt_shootray.  */
	  (void)rt_shootray ( &ap );

	  strtpt[Y] += gridspace;
	  if(strtpt[Y] > ymax)
	    {
	      strtpt[Y] = ymin + gridspace / 2.;
	      strtpt[Z] += gridspace;
	    }

	  t[X] = strtpt[X] - center[X];
	  t[Y] = strtpt[Y] - center[Y];
	  t[Z] = strtpt[Z] - center[Z];

	  (void)rotate(t,angle,r);

	  ap.a_ray.r_pt[X] = center[X] + r[X];
	  ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	  ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	}	/*  END # 3  */

      /*  Shoot down 2nd & 3rd axes if necessary.  */
      if(ifire == 0)
	{						/*  START # 1000  */
	  /*  Set up & shoot down the 2nd axis (y-axis).  */
	  (void)printf("\nShooting down the 2nd axis.\n");
	  (void)fflush(stdout);

	  strtpt[X] = xmin + gridspace / 2.;
	  strtpt[Y] = ymax;
	  strtpt[Z] = zmin + gridspace / 2.;
	  strtdir[X] = 0.;
	  strtdir[Y] = (-1.);
	  strtdir[X] = 0.;

	  /*  Rotate starting point (new pt = C + R[P - C]).  */
	  t[X] = strtpt[X] - center [X];
	  t[Y] = strtpt[Y] - center [Y];
	  t[Z] = strtpt[Z] - center [Z];

	  (void)rotate(t,angle,r);

	  ap.a_ray.r_pt[X] = center[X] + r[X];
	  ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	  ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	  /*  Rotate firing direction (new dir = R[D])  */
	  (void)rotate(strtdir,angle,r);

	  ap.a_ray.r_dir[X] = r[X];
	  ap.a_ray.r_dir[Y] = r[Y];
	  ap.a_ray.r_dir[Z] = r[Z];

	  while(strtpt[Z] <= zmax)
	    {						/*  START # 1010  */
	      iprev = (-1);		/*  No previous shots.  */

	      /*  Call rt_shootray.  */
	      (void)rt_shootray(&ap);

	      strtpt[X] += gridspace;
	      if(strtpt[X] > xmax)
		{
		  strtpt[X] = xmin + gridspace / 2.;
		  strtpt[Z] += gridspace;
		}

	      t[X] = strtpt[X] - center[X];
	      t[Y] = strtpt[Y] - center[Y];
	      t[Z] = strtpt[Z] - center[Z];

	      (void)rotate(t,angle,r);

	      ap.a_ray.r_pt[X] = center[X] + r[X];
	      ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	      ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	    }						/*  END # 1010  */

	  /*  Set up & shoot down the 3rd axis (z-axis).  */
	  (void)printf("\nShooting down the 3rd axis.\n");
	  (void)fflush(stdout);

	  strtpt[X] = xmin + gridspace / 2.;
	  strtpt[Y] = ymin + gridspace / 2.;
	  strtpt[Z] = zmax;
	  strtdir[X] = 0.;
	  strtdir[Y] = 0.;
	  strtdir[Z] = (-1.);

	  /*  Rotate starting points (new pt = C + R[P - C]).  */
	  t[X] = strtpt[X] - center[X];
	  t[Y] = strtpt[Y] - center[Y];
	  t[Z] = strtpt[Z] - center[Z];

	  (void)rotate(t,angle,r);

	  ap.a_ray.r_pt[X] = r[X];
	  ap.a_ray.r_pt[Y] = r[Y];
	  ap.a_ray.r_pt[Z] = r[Z];

	  while(strtpt[Y] <= ymax)
	    {						/*  START # 1020  */
	      iprev = (-1);		/*  No previous shots.  */

	      /*  Call rt_shootray.  */
	      (void)rt_shootray(&ap);

	      strtpt[X] += gridspace;
	      if(strtpt[X] > xmax)
		{
		  strtpt[X] = xmin + gridspace / 2.;
		  strtpt[Y] += gridspace;
		}

	      t[X] = strtpt[X] - center[X];
	      t[Y] = strtpt[Y] - center[Y];
	      t[Z] = strtpt[Z] - center[Z];

	      (void)rotate(t,angle,r);

	      ap.a_ray.r_pt[X] = center[X] + r[X];
	      ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	      ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	    }						/*  END # 1020  */
	}						/*  END # 1000  */

      /*  Calculate final length between centroid & shared surface area.  */
      if(iwrite == 0)
	{
	  (void)fprintf(stdout,"\n\nFinal numbers.\n");
	  (void)fflush(stdout);
	}

      for(i=0; i<numreg; i++)
	{

	  if(iwrite == 0)
	    {
	      (void)fprintf(stdout,"reg#=%d, matid=%d\n",(i+1),cond[i].mat);
	      (void)fflush(stdout);
	    }

	  if(iwrite == 1)
	    {
	      (void)fprintf(fp3,"reg#=%d, matid=%d\n",(i+1),cond[i].mat);
	      (void)fflush(fp3);
	    }

	  for(j=0; j<numreg; j++)
	    {
	      if(cond[i].numcal[j] > ZEROTOL)
		{
		  cond[i].avglen[j] /= cond[i].numcal[j];
		  cond[i].rmslen[j] /= cond[i].numcal[j];
		  cond[i].rmslen[j] = sqrt(cond[i].rmslen[j]);

		  if(iwrite == 0)
		    {
		      (void)fprintf(stdout,"\tadjreg=%d, numcal=%f, shrarea=%f, ",
				    (j+1),cond[i].numcal[j],cond[i].shrarea[j]);
		      (void)fprintf(stdout,"avglen=%f\n",cond[i].avglen[j]);
		      (void)fprintf(stdout,"\t\trmslen=%f, ",cond[i].rmslen[j]);
		      (void)fprintf(stdout,"minlen=%f, maxlen=%f\n",
				    cond[i].minlen[j],cond[i].maxlen[j]);
		      (void)fflush(stdout);
		    }

		  if(iwrite == 1)
		    {
		      (void)fprintf(fp3,"\tadjreg=%d, numcal=%f, shrarea=%f, ",
				    (j+1),cond[i].numcal[j],cond[i].shrarea[j]);
		      (void)fprintf(fp3,"avglen=%f\n",cond[i].avglen[j]);
		      (void)fprintf(fp3,"\t\trmslen=%f, ",cond[i].rmslen[j]);
		      (void)fprintf(fp3,"minlen=%f, maxlen=%f\n",
				    cond[i].minlen[j],cond[i].maxlen[j]);
		      (void)fflush(fp3);
		    }

		}
	      else
		{
		  cond[i].avglen[j] = 0.;
		  cond[i].rmslen[j] = 0.;
		}
	    }
	}

      if(iwrite == 1)
	{
	  /*  Print summary of all files used.  */
	  (void)fprintf(fp3,"\n\nSUMMARY OF FILES USED & CREATED\n");
	  (void)fprintf(fp3,"\t.g file used:  %s\n",argv[1]);
	  (void)fprintf(fp3,"\tregions used:\n");
	  (void)fflush(fp3);
	  i=2;
	  while(argv[i] != NULL)
	    {
	      (void)fprintf(fp3,"\t\t%s\n",argv[i]);
	      (void)fflush(fp3);
	      i++;
	    }
	  (void)fprintf(fp3,"\tfile containing second pass information:  %s\n",
			spfile);
	  (void)fprintf(fp3,"\tmaterial file used:  %s\n",filemat);
	  (void)fprintf(fp3,"\toutput file created:  %s\n",filename);
	  if(typeout == 0)
	    {
	      (void)fprintf(fp3,"\tconductivity file created:  %s\n",confile);
	      (void)fprintf(fp3,"\t  (format is PRISM %d.0)\n",prmrel);
	    }
	  if(typeout == 1) (void)fprintf(fp3,"\tgeneric file created:  %s\n"
					 ,genfile);
	  (void)fprintf(fp3,"\tconductivity table file created:  %s\n",
			tblfile);
	  (void)fprintf(fp3,"\terror file created:  %s\n\n\n",fileerr);
	  (void)fflush(fp3);

	  (void)fclose(fp3);
	}

      /*------------------------------------------------------------------*/

      /*  Open conductivity file to be used with PRISM if needed.  */
      if(typeout == 0)
	{
	  fp1=fopen(confile,"w");
	  (void)fprintf(fp1,"Conductivity file for use with PRISM.\n");
	  (void)fflush(fp1);
	}

      /*  Make calculations & write to conductivity file.  */
      for(i=0; i<numreg; i++)
	{	/*  START # 6  */

	  /*  Make conductivity file triangular.  This program still  */
	  /*  computes the ENTIRE matrix.  */

	  for(j=(i+1); j<numreg; j++)
	    {	/*  START # 7  */

	      if( (cond[i].avglen[j] != 0) )
		{	/*  START # 8  */
		  /*  Find correct thermal conductivity.  */
		  /*  If ki or kj = 0 => rk = 0.  */
		  ki = k[cond[i].mat];
		  kj = k[cond[j].mat];

		  /*  All calculations will be in meters &  */
		  /*  square meters.  */

		  areai = cond[i].shrarea[j] * 1.e-6;

		  /*  average length  */
		  leni = cond[i].avglen[j] * 1.e-3;
		  lenj = cond[j].avglen[i] * 1.e-3;
		  if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		     ((-ZEROTOL < kj) && (kj < ZEROTOL)))
		    cond[i].rkavg[j] = 0.;
		  else
		    {
		      rki = leni / (ki * areai);
		      rkj = lenj / (kj * areai);
		      cond[i].rkavg[j] = 1. / (rki + rkj);
		    }

		  /*  rms length  */
		  leni = cond[i].rmslen[j] * 1.e-3;
		  lenj = cond[j].rmslen[i] * 1.e-3;
		  if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		     ((-ZEROTOL < kj) && (kj < ZEROTOL)))
		    cond[i].rkrms[j] = 0.;
		  else
		    {
		      rki = leni / (ki * areai);
		      rkj = lenj / (kj * areai);
		      cond[i].rkrms[j] = 1. / (rki + rkj);
		    }

		  /*  minimum length  */
		  leni = cond[i].minlen[j] * 1.e-3;
		  lenj = cond[j].minlen[i] * 1.e-3;
		  if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		     ((-ZEROTOL < kj) && (kj < ZEROTOL)))
		    cond[i].rkmin[j] = 0.;
		  else
		    {
		      rki = leni / (ki * areai);
		      rkj = lenj / (kj * areai);
		      cond[i].rkmin[j] = 1. / (rki + rkj);
		    }

		  /*  maximum length  */
		  leni = cond[i].maxlen[j] * 1.e-3;
		  lenj = cond[j].maxlen[i] * 1.e-3;
		  if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		     ((-ZEROTOL < kj) && (kj < ZEROTOL)))
		    cond[i].rkmax[j] = 0.;
		  else
		    {
		      rki = leni / (ki * areai);
		      rkj = lenj / (kj * areai);
		      cond[i].rkmax[j] = 1. / (rki + rkj);
		    }

		  /*  Print if had adjacent regions, conductivity  */
		  /*  may be zero.  */

		  /*  Print only if PRISM file is to be created.  */
		  if(typeout == 0) {		/*  START # 8A  */
		    if( (itype == 1) && (cond[i].shrarea[j] > ZEROTOL) )
		      {
			if(prmrel == 2)
			  (void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
					(j+1),(i+1),cond[i].rkavg[j],
					(cond[i].shrarea[j] * 1.0e-6));
			if(prmrel == 3)
			  (void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
					(j+1),(i+1),cond[i].rkavg[j],
					(cond[i].shrarea[j] * 1.0e-6));
		      }

		    if( (itype == 2) && (cond[i].shrarea[j] > ZEROTOL) )
		      {
			if(prmrel == 2)
			  (void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
					(j+1),(i+1),cond[i].rkrms[j],
					(cond[i].shrarea[j] * 1.0e-6));
			if(prmrel == 3)
			  (void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
					(j+1),(i+1),cond[i].rkrms[j],
					(cond[i].shrarea[j] * 1.0e-6));
		      }

		    if( (itype == 3) && (cond[i].shrarea[j] > ZEROTOL) )
		      {
			if(prmrel == 2)
			  (void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
					(j+1),(i+1),cond[i].rkmin[j],
					(cond[i].shrarea[j] * 1.0e-6));
			if(prmrel == 3)
			  (void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
					(j+1),(i+1),cond[i].rkmin[j],
					(cond[i].shrarea[j] * 1.0e-6));
		      }

		    if( (itype == 4) && (cond[i].shrarea[j] > ZEROTOL) )
		      {
			if(prmrel == 2)
			  (void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
					(j+1),(i+1),cond[i].rkmax[j],
					(cond[i].shrarea[j] * 1.0e-6));
			if(prmrel == 3)
			  (void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
					(j+1),(i+1),cond[i].rkmax[j],
					(cond[i].shrarea[j] * 1.0e-6));
		      }

		    (void)fflush(fp1);
		  }				/*  END of # 8A  */
		}	/*  END # 8  */
	    }	/*  END # 7  */
	}	/*  END # 6  */

      if(typeout == 0) (void)fclose(fp1);

      /*------------------------------------------------------------------*/

      /*  Open and write to generic file if necessary. */
      /*  The format follows.  */
      /*  4  region number  number of adjacent regions  */
      /*     adjacent region  shared area  conduction distance  */

      if(typeout == 1)
	{
	  /*  Open file.  */
	  fp6 = fopen(genfile,"w");
	  (void)printf("Opened generic file.\n");
	  (void)fflush(stdout);

	  for(i=0; i<numreg; i++)
	    {
	      /*  Find number of adjacent regions.  */
	      /*
	       *		(void)printf("Ready to find number of adjacent areas.\n");
	       *		(void)fflush(stdout);
	       */
	      nadjreg = 0;
	      /*
	       *		(void)printf("nadjreg = %d\n",nadjreg);
	       *		(void)fflush(stdout);
	       */
	      for(j=0; j<numreg; j++)
		{
		  /*
		   *		   (void)printf("%d, %d, %f\n",i,j,cond[i].shrarea[j]);
		   *		   (void)fflush(stdout);
		   */
		  if(cond[i].shrarea[j] > ZEROTOL) nadjreg += 1;
		}
	      /*
	       *		(void)printf("Found number of adjacent areas.\n");
	       *		(void)fflush(stdout);
	       */

	      (void)fprintf(fp6,"4  %5d  %5d\n",(i+1),nadjreg);
	      (void)fflush(fp6);

	      for(j=0; j<numreg; j++)
		{
		  if(cond[i].shrarea[j] > ZEROTOL)
		    {
		      (void)fprintf(fp6,"   %5d  %.3e  ",(j+1),
				    (cond[i].shrarea[j] * 1.e-6));
		      if(itype == 1) (void)fprintf(fp6,"%.3e\n",
						   (cond[i].avglen[j] * 1.e-3));
		      if(itype == 2) (void)fprintf(fp6,"%.3e\n",
						   (cond[i].rmslen[j] * 1.e-3));
		      if(itype == 3) (void)fprintf(fp6,"%.3e\n",
						   (cond[i].minlen[j] * 1.e-3));
		      if(itype == 4) (void)fprintf(fp6,"%.3e\n",
						   (cond[i].maxlen[j] * 1.e-3));
		    }
		  (void)fflush(fp6);
		}
	    }
	  (void)fclose(fp6);
	}

      /*------------------------------------------------------------------*/

      /*  Open conductivity table file and write information to  */
      /*  it.  All units will be in meters or square meters.  */
      fp2=fopen(tblfile,"w");
      (void)fprintf(fp2,"Conductivity table.  Units are in meters or ");
      (void)fprintf(fp2,"square meters.\n");

      (void)fprintf(fp2," reg, mat, adj,   shrarea,");
      (void)fprintf(fp2,"    avglen,     rkavg,");
      (void)fprintf(fp2,"    rmslen,     rkrms,");
      (void)fprintf(fp2,"    minlen,     rkmin,");
      (void)fprintf(fp2,"    maxlen,     rkmax\n");

      (void)fflush(fp2);

      for(i=0; i<numreg; i++)
	{	/*  START # 9  */
	  for(j=0; j<numreg; j++)
	    {	/*  START # 10  */
	      if(cond[i].shrarea[j] != 0)
		{	/*  START # 11  */
		  a1 = cond[i].shrarea[j] * 1.e-6;
		  l1 = cond[i].avglen[j] * 1.e-3;
		  l2 = cond[i].rmslen[j] * 1.e-3;
		  l3 = cond[i].minlen[j] * 1.e-3;
		  l4 = cond[i].maxlen[j] * 1.e-3;

		  (void)fprintf(fp2,"%4d,%4d,%4d, %.3e,",
				(i+1),cond[i].mat,(j+1),a1);
		  if(j > i)
		    {
		      (void)fprintf(fp2," %.3e, %.3e,",l1,cond[i].rkavg[j]);
		      (void)fprintf(fp2," %.3e, %.3e,",l2,cond[i].rkrms[j]);
		      (void)fprintf(fp2," %.3e, %.3e,",l3,cond[i].rkmin[j]);
		      (void)fprintf(fp2," %.3e, %.3e\n",l4,cond[i].rkmax[j]);
		    }
		  else
		    {
		      (void)fprintf(fp2," %.3e, %.3e,",l1,cond[j].rkavg[i]);
		      (void)fprintf(fp2," %.3e, %.3e,",l2,cond[j].rkrms[i]);
		      (void)fprintf(fp2," %.3e, %.3e,",l3,cond[j].rkmin[i]);
		      (void)fprintf(fp2," %.3e, %.3e\n",l4,cond[j].rkmax[i]);
		    }

		  (void)fflush(fp2);
		}	/*  END # 11  */
	    }	/*  END # 10  */
	}	/*  END # 9  */

      (void)fclose(fp2);

      /*------------------------------------------------------------------*/

      /*  Print summary of all files used.  */
      (void)fprintf(stdout,"\n\nSUMMARY OF FILES USED & CREATED\n");
      (void)fprintf(stdout,"\t.g file used:  %s\n",argv[1]);
      (void)fprintf(stdout,"\tregions used:\n");
      (void)fflush(stdout);
      i=2;
      while(argv[i] != NULL)
	{
	  (void)fprintf(stdout,"\t\t%s\n",argv[i]);
	  (void)fflush(stdout);
	  i++;
	}
      (void)fprintf(stdout,"\tfile containing second pass information:  %s\n",
		    spfile);
      (void)fprintf(stdout,"\tmaterial file used:  %s\n",filemat);
      if(iwrite == 1)
	{
	  (void)fprintf(stdout,"\toutput file created:  %s\n",filename);
	}
      if(typeout == 0)
	{
	  (void)fprintf(stdout,"\tconductivity file created:  %s\n",confile);
	  (void)fprintf(stdout,"\t  (format is PRISM %d.0)\n",prmrel);
	}
      if(typeout == 1) (void)printf("\tgeneric file created:  %s\n",genfile);
      (void)fprintf(stdout,"\tconductivity table file created:  %s\n",tblfile);
      (void)fprintf(stdout,"\terror file created:  %s\n\n\n",fileerr);
      (void)fflush(stdout);

      /*------------------------------------------------------------------*/

      /*  Open error file.  */
      fp4 = fopen(fileerr,"w");

      /*  Write errors to error file.  */
      (void)fprintf(fp4,"\nERRORS from secpass\n\n");
      /*  Write type of file created to error file.  */
      if(typeout == 0)
	{
	  (void)fprintf(fp4,"PRISM %d.0 conductivity file, %s, created.\n\n",
			prmrel,confile);
	}
      if(typeout == 1) (void)fprintf(fp4,"Generic file, %s, created.\n\n",
				     genfile);
      (void)fflush(fp4);
      for(i=0; i<numreg; i++)
	{
	  for(j=0; j<numreg;  j++)
	    {
	      if( (cond[i].numcal[j] > ZEROTOL) &&
		  ( cond[i].numcal[j] < MINCAL ) )
		{
		  (void)fprintf(fp4,"region %d, adjacent region %d:\n",
				(i+1),(j+1));
		  (void)fprintf(fp4,"\tnumber of length calculations ");
		  (void)fprintf(fp4,"below minimum of %d\n",MINCAL);
		  (void)fflush(fp4);
		}
	    }
	}
      (void)fclose(fp4);

      /*------------------------------------------------------------------*/

      /*  Everything completed, free memory.  */
      (void)fprintf(stdout,"Freeing memory.\n");
      (void)fflush(stdout);
      for(i=0; i<nmged; i++)
	{
	  bu_free(cond[i].shrarea, "cond[i].shrarea");
	  bu_free(cond[i].avglen, "cond[i].avglen");
	  bu_free(cond[i].rmslen, "cond[i].rmslen");
	  bu_free(cond[i].minlen, "cond[i].minlen");
	  bu_free(cond[i].maxlen, "cond[i].maxlen");
	  bu_free(cond[i].numcal, "cond[i].numcal");
	  bu_free(cond[i].rkavg, "cond[i].rkavg");
	  bu_free(cond[i].rkrms, "cond[i].rkrms");
	  bu_free(cond[i].rkmin, "cond[i].rkmin");
	  bu_free(cond[i].rkmax, "cond[i].rkmax");
	}
      bu_free(cond, "cond");

    }	/*  END # 2  */
  return(0);
}	/*  END # 1  */


/*  User supplied hit function.  */
int
hit(register struct application *ap_p, struct partition *PartHeadp, struct seg *segp)
{	/*  START # 1H  */

  register struct partition *pp;
  register struct hit *hitp;
  register struct soltab *stp;

  double d[3];		/*  used for checking tolerance of  */
			/*  adjacent regions  */
  double dist;		/*  used for finding lenght between  */
			/*  centroid & adjacent surface area  */

  /*
   * (void)fprintf(stdout,"In hit function.\n");
   * (void)fflush(stdout);
   */

  pp = PartHeadp->pt_forw;
  for( ; pp != PartHeadp; pp = pp->pt_forw)
    {	/*  START # 2H  */
      icur = pp->pt_regionp->reg_bit;	/*  Number of region hit.  */

      /*  Find hit point of entering ray.  */
      hitp = pp->pt_inhit;
      stp = pp->pt_inseg->seg_stp;
      RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
      enterpt[X] = hitp->hit_point[X];
      enterpt[Y] = hitp->hit_point[Y];
      enterpt[Z] = hitp->hit_point[Z];

      /*  Find lengths between centroids and adjacent surface areas.  */

      if(iprev >= 0)
	{	/*  START # 3H  */
	  d[X] = enterpt[X] - leavept[X];
	  if(d[X] < 0) d[X] = (-d[X]);
	  d[Y] = enterpt[Y] - leavept[Y];
	  if(d[Y] < 0) d[Y] = (-d[Y]);
	  d[Z] = enterpt[Z] - leavept[Z];
	  if(d[Z] < 0) d[Z] = (-d[Z]);

	  if( (d[X] < ADJTOL) && (d[Y] < ADJTOL) && (d[Z] < ADJTOL) )
	    {	/*  START # 4H  */
		/*  Find length for previous region. */
	      dist = ( (cond[iprev].centroid[X] - enterpt[X])
		       * (cond[iprev].centroid[X] - enterpt[X]) ) +
		( (cond[iprev].centroid[Y] - enterpt[Y])
		  * (cond[iprev].centroid[Y] - enterpt[Y]) ) +
		( (cond[iprev].centroid[Z] - enterpt[Z])
		  * (cond[iprev].centroid[Z] - enterpt[Z]) );
	      dist = sqrt(dist);
	      cond[iprev].avglen[icur] += dist;
	      cond[iprev].rmslen[icur] += (dist * dist);
	      cond[iprev].numcal[icur] += 1.;

	      if( (-ZEROTOL < cond[iprev].minlen[icur]) &&
		  (cond[iprev].minlen[icur] < ZEROTOL) )
		{
		  cond[iprev].minlen[icur] = dist;
		}
	      else if( dist < cond[iprev].minlen[icur] )
		{
		  cond[iprev].minlen[icur] = dist;
		}

	      if( (-ZEROTOL < cond[iprev].maxlen[icur]) &&
		  (cond[iprev].maxlen[icur] < ZEROTOL) )
		{
		  cond[iprev].maxlen[icur] = dist;
		}
	      else if( cond[iprev].maxlen[icur] < dist )
		{
		  cond[iprev].maxlen[icur] = dist;
		}

	      /*
	       *		(void)fprintf(stdout,"\treg#:  %d, length:  %f\n",iprev,dist);
	       *		(void)fflush(stdout);
	       */

	      /*  Find lenght for current region.  */
	      dist = ( (cond[icur].centroid[X] - enterpt[X])
		       * (cond[icur].centroid[X] - enterpt[X]) ) +
		( (cond[icur].centroid[Y] - enterpt[Y])
		  * (cond[icur].centroid[Y] - enterpt[Y]) ) +
		( (cond[icur].centroid[Z] - enterpt[Z])
		  * (cond[icur].centroid[Z] - enterpt[Z]) );
	      dist = sqrt(dist);
	      cond[icur].avglen[iprev] += dist;
	      cond[icur].rmslen[iprev] += (dist * dist);
	      cond[icur].numcal[iprev] += 1.;

	      if( (-ZEROTOL < cond[icur].minlen[iprev]) &&
		  (cond[icur].minlen[iprev] < ZEROTOL) )
		{
		  cond[icur].minlen[iprev] = dist;
		}
	      else if( dist < cond[icur].minlen[iprev] )
		{
		  cond[icur].minlen[iprev] = dist;
		}

	      if( (-ZEROTOL < cond[icur].maxlen[iprev]) &&
		  (cond[icur].maxlen[iprev] < ZEROTOL) )
		{
		  cond[icur].maxlen[iprev] = dist;
		}
	      else if( cond[icur].maxlen[iprev] < dist )
		{
		  cond[icur].maxlen[iprev] = dist;
		}

	      /*
	       *		(void)fprintf(stdout,"\treg#:  %d, length:  %f\n",icur,dist);
	       *		(void)fflush(stdout);
	       */

	    }	/*  END # 4H  */
	}	/*  END # 3H  */

      /*  Find hit point of leaving ray.  */
      hitp = pp->pt_outhit;
      stp = pp->pt_outseg->seg_stp;
      RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
      leavept[X] = hitp->hit_point[X];
      leavept[Y] = hitp->hit_point[Y];
      leavept[Z] = hitp->hit_point[Z];

      /*
       *	(void)fprintf(stdout,"current region:  %d, previous region:  %d\n",icur,iprev);
       *	(void)fprintf(stdout,"   entering pt:  %f, %f, %f\n",enterpt[X],enterpt[Y],
       *		enterpt[Z]);
       *	(void)fprintf(stdout,"   leaving pt:   %f, %f, %f\n",leavept[X],leavept[Y],
       *		leavept[Z]);
       */

      /*  Set previous region to current region.  */
      iprev = icur;
    }	/*  END # 2H  */

  return(1);

}	/*  END # 1H  */


/*  User supplied miss function.  */
int
miss(register struct application *ap_p)
{	/*  START # 1M  */

  /*
   * (void)fprintf(stdout,"In miss function.\n");
   * (void)fflush(stdout);
   */

  return(0);
}	/*  END # 1M */

/*  User supplied overlap function that does nothing.  */
int
ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2, struct partition *hp)
{
  return(1);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.14
log
@yet another surge of level 4 flawfinder string length checks. somewhere around 30-40% done.
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.13 2007/09/15 16:23:06 brlcad Exp $ (BRL)";
d77 1
a77 1
extern int ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2);	/*  User defined overlap function.  */
d1323 1
a1323 1
ovrlap(register struct application *ap_p, struct partition *PartHeadp, struct region *reg1, struct region *reg2)
@


14.13
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.12 2007/07/26 01:13:54 brlcad Exp $ (BRL)";
d193 1
a193 1
	  (void)scanf("%s",filename);
d201 1
a201 1
      (void)scanf("%s",spfile);
d217 1
a217 1
	  (void)scanf("%s",confile);
d236 1
a236 1
	  (void)scanf("%s",genfile);
d256 1
a256 1
      (void)scanf("%s",tblfile);
d262 1
a262 1
      (void)scanf("%s",filemat);
d268 1
a268 1
      (void)scanf("%s",fileerr);
@


14.12
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.11 2007/02/20 07:53:37 brlcad Exp $ (BRL)";
d59 1
a59 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.11
log
@convert to bu_fgets(), which of course adds a libbu dependency if there wasn't one already.  this allows processing of foreign text files with different line endings more consistently.
@
text
@a24 5
 *  Source -
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
 *
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.10 2007/01/23 01:13:32 brlcad Exp $ (BRL)";
@


14.10
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.9 2007/01/20 14:36:50 brlcad Exp $ (BRL)";
d322 1
a322 1
	  (void)fgets(line,151,fp5);
@


14.9
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d58 1
a58 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.8 2006/01/23 07:14:49 brlcad Exp $ (BRL)";
@


14.8
log
@libbu memory allocation management
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2006 United States Government as represented by
d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.7 2006/01/18 06:46:15 brlcad Exp $ (BRL)";
@


14.7
log
@update copyright to 2006
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.6 2005/12/02 21:17:05 brlcad Exp $ (BRL)";
d369 1
a369 1
      cond = (struct table *)malloc( nmged * sizeof(struct table) );
d374 10
a383 10
	  cond[i].shrarea = (double *)malloc( nmged * sizeof(double) );
	  cond[i].avglen = (double *)malloc( nmged * sizeof(double) );
	  cond[i].rmslen = (double *)malloc( nmged * sizeof(double) );
	  cond[i].minlen = (double *)malloc( nmged * sizeof(double) );
	  cond[i].maxlen = (double *)malloc( nmged * sizeof(double) );
	  cond[i].numcal = (double *)malloc( nmged * sizeof(double) );
	  cond[i].rkavg = (double *)malloc( nmged * sizeof(double) );
	  cond[i].rkrms = (double *)malloc( nmged * sizeof(double) );
	  cond[i].rkmin = (double *)malloc( nmged * sizeof(double) );
	  cond[i].rkmax = (double *)malloc( nmged * sizeof(double) );
d1153 10
a1162 10
	  free(cond[i].shrarea);
	  free(cond[i].avglen);
	  free(cond[i].rmslen);
	  free(cond[i].minlen);
	  free(cond[i].maxlen);
	  free(cond[i].numcal);
	  free(cond[i].rkavg);
	  free(cond[i].rkrms);
	  free(cond[i].rkmin);
	  free(cond[i].rkmax);
d1164 1
a1164 1
      free(cond);
@


14.6
log
@use RT_APPLICATION_INIT and deglobal the unnecessarily global ap structure
@
text
@d4 1
a4 1
 * Copyright (C) 1990-2005 United States Government as represented by
d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.5 2005/10/23 04:44:31 brlcad Exp $ (BRL)";
@


14.5
log
@trailing ws
@
text
@d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.4 2005/01/30 20:30:41 brlcad Exp $ (BRL)";
a84 1
struct application ap;	/*  Structure passed between functions.  */
d124 1
d552 1
@


14.4
log
@update copyright to 2005
@
text
@d25 1
a25 1
 *  
d29 1
a29 1
 *  
d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/irprep/secpass.c,v 14.3 2004/12/21 06:38:19 morrison Exp $ (BRL)";
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d25 1
a25 1
 *
d29 1
a29 1
 *
d59 1
a59 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


14.3
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2004 United States Government as represented by
d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/secpass.c,v 14.2 2004/12/21 01:08:03 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL license
@
text
@a29 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
d59 1
a59 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/secpass.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			S E C P A S S . C
d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/secpass.c,v 1.5 2004/09/16 03:36:31 morrison Exp $ (BRL)";
@


1.5
log
@match the a_hit and a_miss prototypes; ws too
@
text
@d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/secpass.c,v 1.4 2004/09/03 23:30:57 morrison Exp $ (BRL)";
d1320 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@a41 1

d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/secpass.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
a47 2


d50 1
a50 1
#include <string.h>
d52 1
a52 1
#include <strings.h>
d60 1
d68 1
d70 1
a70 1
extern int hit(register struct application *ap_p, struct partition *PartHeadp);	/*  User defined hit function.  */
d81 5
a85 5
	double centroid[3];	/*  centroid of region  */
	double *shrarea;	/*  shared surface area between adjacent  */
				/*  regions  */
	int mat;		/*  material id  */
	double *avglen;		/*  average length between centroid &  */
d87 1
a87 1
	double *rmslen;		/*  root mean squared length between  */
d89 1
a89 1
	double *minlen;		/*  minimum length between centroid &  */
d91 1
a91 1
	double *maxlen;		/*  maximum length between centroid &  */
d93 5
a97 5
	double *numcal;		/*  number of length calculations  */
	double *rkavg;		/*  rk value using average length  */
	double *rkrms;		/*  rk value using root mean squared length  */
	double *rkmin;		/*  rk value using minimum length  */
	double *rkmax;		/*  rk value using maximum length  */
d110 1
a110 1
   static struct rt_i *rtip;	/*  *rtip pointer to structure of  */
d112 1
a112 1
   char idbuf[132];	/*  first ID record info, used in  */
d114 1
a114 1
   int index;		/*  index for rt_dirbuild & rt_gettree  */
d116 12
a127 12
   FILE *fp;		/*  used in opening file for second pass  */
   char spfile[16];	/*  second pass file name  */
   FILE *fp1=NULL;		/*  conductivity file  */
   char confile[16];	/*  conductivity file  */
   FILE *fp2;		/*  conductivity table file  */
   char tblfile[16];	/*  conductivity table file  */

   int i,j;		/*  integers used in loops  */
   int numreg;		/*  number of regions  */
   int nmged;		/*  number of regions in mged file  */
   double gridspace;	/*  spacing between fired rays  */
   int iwrite;		/*  0 => write to standard out, 1 => write  */
d129 1
a129 1
   int typeout;		/*  Type of file to be written, 0 => PRISM file,  */
d131 10
a140 10
   FILE *fp6;		/*  Used in writing generic file.  */
   char genfile[16];	/*  Generic file name.  */
   FILE *fp3=NULL;		/*  used for writing output to file  */
   char filename[16];	/*  output file name  */

   FILE *fp5;		/*  material file  */
   char filemat[16];	/*  material file  */
   char line[150];	/*  used for reading a line from a file  */
   double k[41];	/*  thermal conductivity  */
   int itype;		/*  type of length measurement to use for  */
d142 8
a149 8
   double rki,rkj;	/*  used in finding rk  */
   double ki,kj;	/*  thermal conductivity of region  */
   double leni,lenj;	/*  lengths used in finding rk  */
   double areai;	/*  areas used in finding rk  */
   double a1;		/*  area used in writing conductivity table  */
   double l1,l2,l3,l4;	/*  lengths used in writing conductivity table  */
   FILE *fp4;		/*  error file  */
   char fileerr[16];	/*  error file  */
d151 1
a151 1
   double angle[3];	/*  Angles of rotation.  angle[0]-rotation about  */
d154 11
a164 11
   double strtpt[3];	/*  Starting point of fired ray.  */
   double strtdir[3];	/*  Starting direction of fired ray.  */
   double r[3],t[3];	/*  Used in computing rotations.  */
   double center[3];	/*  Center point of bounding rpp.  */
   double diagonal;	/*  Length of diagonal of bounding rpp.  */
   double xmin,xmax;	/*  Maximum & minimum x of grid.  */
   double ymin,ymax;	/*  Maximum & minimum y of grid.  */
   double zmin,zmax;	/*  Maximum & minimum z of grid.  */
   int nadjreg;		/*  Number of adjacent regions.  */
   int prmrel;		/*  PRISM release number, 2=>2.0, 3=>3.0.  */
   int ifire;		/*  Number of sets of rays to be fired, 0=>  */
d168 5
a172 5
   /*  Check to see if arguments implimented correctly.  */
   if(argv[1] == NULL || argv[2] == NULL)
   {
   	(void)fprintf(stderr,"\nusage:  secpass file.g objects\n\n");
   }
d174 2
a175 2
   else
   {	/*  START # 2  */
d178 44
a221 157
	(void)fprintf(stdout,"Write output to standard out (0) or a file(1) ");
	(void)fprintf(stdout,"not at all (2)?  ");
	(void)fflush(stdout);
	(void)scanf("%d",&iwrite);
	if((iwrite != 0) && (iwrite != 1)) iwrite=2;
	if(iwrite == 1)
	{
	   (void)fprintf(stdout,"Enter name of output file (15 char max).  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",filename);
	   fp3 = fopen(filename,"w");
	}

	/*  Which file that has second pass information in it?  */
	(void)fprintf(stdout,"Enter name of file that has second pass ");
	(void)fprintf(stdout,"information\nin it (15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",spfile);

	/*  Ask for type of output file to be generated.  */
	(void)printf("Enter type of output file to be generated.\n");
	(void)printf("\t 0 - PRISM File\n");
	(void)printf("\t 1 - Generic File\n");
	(void)fflush(stdout);
	(void)scanf("%d",&typeout);

	/*  Read name of file to write conductivity information  */
	/*  to for use in PRISM.  */
	if(typeout == 0)
	{
	   (void)fprintf(stdout,"Enter name of file to be created for PRISM ");
	   (void)fprintf(stdout,"conductivity\ninformation (15 char max).  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",confile);

	   /*  Find which release of PRISM is being used.  The format  */
	   /*  for writing region numbers is I3 for PRISM 2.0 & I6 for  */
	   /*  PRISM 3.0.  */
	   prmrel = 2;
	   (void)printf("Which release of PRISM is being used, 2.0 (2) ");
	   (void)printf("or 3.0 (3)?  ");
	   (void)fflush(stdout);
	   (void)scanf("%d",&prmrel);
	   if(prmrel != 3) prmrel = 2;
	}

	/*  Read generic file name if necessary.  */
	if(typeout == 1)
	{
	   (void)printf("Enter name of generic file to be created (15 char ");
	   (void)printf("max).  ");
	   (void)fflush(stdout);
	   (void)scanf("%s",genfile);
	}

	/*  Which calculated length should be used when writing to  */
	/*  this file:  1 -> average length, 2 -> rms length, 3 ->  */
	/*  minimum length, and 4 -> maximum length.  */
	(void)fprintf(stdout,"Which length calculation should be used when\n");
	(void)fprintf(stdout,"computing conduction\nbetween regions?\n");
	(void)fprintf(stdout,"\t1 - average length\n");
	(void)fprintf(stdout,"\t2 - rms length\n");
	(void)fprintf(stdout,"\t3 - minimum length\n");
	(void)fprintf(stdout,"\t4 - maximum length\n");
	(void)fflush(stdout);
	(void)scanf("%d",&itype);

	/*  Read name of file to write conductivity information to  */
	/*  in table format.  */
	(void)fprintf(stdout,"Enter name of file to be created for ");
	(void)fprintf(stdout,"conductivity\ntable (15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",tblfile);

	/*  Read name of material file that contains thermal  */
	/*  conductivity information.  */
	(void)fprintf(stdout,"Enter name of material file (15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",filemat);

	/*  Read name of error file.  */
	(void)fprintf(stdout,"Enter name of error file to be created ");
	(void)fprintf(stdout,"(15 char max).  ");
	(void)fflush(stdout);
	(void)scanf("%s",fileerr);

	/*  Choose whether 3 orthogonal sets of rays are to be fired  */
	/*  or 1 set of rays is to be fired.  */
	(void)printf("Should there be 3 sets of orhogonal rays fired ");
	(void)printf("(0) or 1 set (1)?\n\t");
	(void)fflush(stdout);
	(void)scanf("%d",&ifire);
	if(ifire != 0) ifire = 1;
	if(ifire == 0)
	{
	   (void)printf("3 sets of orthogonal rays will be fired.\n");
	}
	if(ifire == 1)
	{
	   (void)printf("1 set of rays will be fired.\n");
	}
	(void)fflush(stdout);

	/*  Write out file information.  */
	if(iwrite ==1)
	{
	   (void)fprintf(fp3,"\nsecond pass file:  %s\n",spfile);
	   (void)fprintf(fp3,"material file:  %s\n",filemat);
	   if(typeout == 0)
	   {
		(void)fprintf(fp3,"conductivity file for use ");
	   	(void)fprintf(fp3,"with PRISM:  %s\n",confile);
	   	(void)fprintf(fp3,"  (format is PRISM %d.0)\n",prmrel);
	   }
	   if(typeout == 1) (void)fprintf(fp3,"generic file:  %s\n",genfile);
	   (void)fflush(fp3);
	   if(itype == 1) (void)fprintf(fp3,"\taverage length being used\n");
	   if(itype == 2) (void)fprintf(fp3,"\trms length being used\n");
	   if(itype == 3) (void)fprintf(fp3,"\tminimum length being used\n");
	   if(itype == 4) (void)fprintf(fp3,"\tmaximum length being used\n");
	   (void)fprintf(fp3,"conductivity table file:  %s\n",tblfile);
	   (void)fprintf(fp3,"error file:  %s\n\n",fileerr);
	   (void)fflush(fp3);
	}

	/*  Read thermal conductivity file.  */
	fp5 = fopen(filemat,"r");
	for(i=0; i<41; i++)
	{
	   (void)fgets(line,151,fp5);
	   (void)sscanf(line,"%*d%*f%*f%*f%*f%lf",&k[i]);
	}

	/*  Print out the thermal conductivity.  */
/*
 *	for(i=0; i<41; i++)
 *	{
 *	   (void)fprintf(stdout,"  thermal conductivity %d = %f\n",i,k[i]);
 *	   (void)fflush(stdout);
 *	}
 */

	/*  Build the directory.  */
	index = 1;	/*  Set index for rt_dirbuild.  */
	rtip=rt_dirbuild(argv[index],idbuf,sizeof(idbuf));
	(void)fprintf(stdout,"Database title:  %s\n",idbuf);
	(void)fflush(stdout);

	/*  Set useair to 1, to show hits of air.  */
	rtip->useair = 1;

	/*  Load desired objects.  */
	index = 2;	/*  Set index for rt_gettree.  */
	while(argv[index] != NULL)
	{
	   rt_gettree(rtip,argv[index]);
	   index += 1;
d224 8
a231 2
	/*  Find total number of regions in mged file.  */
	nmged = (int)rtip->nregions;
d233 69
a301 2
	(void)fprintf(stdout,"Number of regions in mged file:  %d\n",nmged);
	(void)fflush(stdout);
d303 41
a343 1
	if(iwrite == 1)
d349 62
a410 43
	/*  Number of regions known, everything can be malloced.  */
	(void)fprintf(stdout,"Mallocing arrays.\n");
	(void)fflush(stdout);

	cond = (struct table *)malloc( nmged * sizeof(struct table) );
	(void)fprintf(stdout,"cond malloced\n");
	(void)fflush(stdout);
	for(i=0; i<nmged; i++)
	{
		cond[i].shrarea = (double *)malloc( nmged * sizeof(double) );
		cond[i].avglen = (double *)malloc( nmged * sizeof(double) );
		cond[i].rmslen = (double *)malloc( nmged * sizeof(double) );
		cond[i].minlen = (double *)malloc( nmged * sizeof(double) );
		cond[i].maxlen = (double *)malloc( nmged * sizeof(double) );
		cond[i].numcal = (double *)malloc( nmged * sizeof(double) );
		cond[i].rkavg = (double *)malloc( nmged * sizeof(double) );
		cond[i].rkrms = (double *)malloc( nmged * sizeof(double) );
		cond[i].rkmin = (double *)malloc( nmged * sizeof(double) );
		cond[i].rkmax = (double *)malloc( nmged * sizeof(double) );
	}
	(void)fprintf(stdout,"loop malloced\n");
	(void)fflush(stdout);

	/*  All variables 'dimensioned', now zero all variables.  */
	for(i=0; i<nmged; i++)
	{
		cond[i].centroid[0] = (double)0.;
		cond[i].centroid[1] = (double)0.;
		cond[i].centroid[2] = (double)0.;
		cond[i].mat = (int)0;
		for(j=0; j<nmged; j++)
		{
		   cond[i].shrarea[j] = (double)0.;
		   cond[i].avglen[j] = (double)0.;
		   cond[i].rmslen[j] = (double)0.;
		   cond[i].minlen[j] = (double)0.;
		   cond[i].maxlen[j] = (double)0.;
		   cond[i].numcal[j] = (double)0.;
		   cond[i].rkavg[j] = (double)0.;
		   cond[i].rkrms[j] = (double)0.;
		   cond[i].rkmin[j] = (double)0.;
		   cond[i].rkmax[j] = (double)0.;
		}
a411 2
	(void)fprintf(stdout,"All variables zeroed.\n");
	(void)fflush(stdout);
d413 28
a440 45
	/*  Now open file with second pass information in it.  */
	fp = fopen(spfile,"r");
	(void)fprintf(stdout,"second pass file opened\n");
	(void)fflush(stdout);

	/*  Read number of regions in file.  */
	(void)fscanf(fp,"%d\n",&numreg);
	(void)fprintf(stdout,"The number of regions read was %d\n",numreg);
	(void)fflush(stdout);

	if(iwrite == 1)
	{
	   (void)fprintf(fp3,"number of regions read from second ");
	   (void)fprintf(fp3,"pass file:  %d\n",numreg);
	   (void)fflush(fp3);
	}

	/*  Read all information in file.  */
	for(i=0; i<numreg; i++)
	{
	   (void)fscanf(fp,"%*d%le%le%le%d\n",&cond[i].centroid[0],
	                              &cond[i].centroid[1],
	                              &cond[i].centroid[2],&cond[i].mat);
/*
 *	   (void)fprintf(stdout,"reg=%8d, centroid:  %10.0f, %10.0f, %10.0f\n",
 *		i,cond[i].centroid[0],cond[i].centroid[1],cond[i].centroid[2]);
 *	   (void)fflush(stdout);
 */

	   for(j=0; j<numreg; j++)
	   {
		(void)fscanf(fp,"%*d%le\n",&cond[i].shrarea[j]);
/*
 *		(void)fprintf(stdout,"\treg=%8d, area=%10.0f\n",
 *		   j,cond[i].shrarea[j]);
 *		(void)fflush(stdout);
 */
	   }
	}

	(void)fclose(fp);

	/*  Check that the number of regions in the mged file  */
	/*  and the second pass file are equal.  */
	if(nmged != numreg)
d444 1
a444 1
		nmged);
d446 1
a446 1
		numreg);
d451 13
a463 127
	  {
	    (void)fprintf(fp3,"ERROR -- The number of regions in the mged\n");
	    (void)fprintf(fp3,"file (%d) does not equal the number of\n",
		nmged);
	    (void)fprintf(fp3,"regions in the second pass file (%d).\n",
		numreg);
	    (void)fprintf(fp3,"Watch for unexplained errors.\n");
	    (void)fflush(fp3);
	  }
	}

	/*  Get database ready by starting preparation.  */
	rt_prep(rtip);

        /*  Find center of bounding rpp.  */
        center[X] = rtip->mdl_min[X] + (rtip->mdl_max[X] -
		rtip->mdl_min[X]) / 2.;
        center[Y] = rtip->mdl_min[Y] + (rtip->mdl_max[Y] -
		rtip->mdl_min[Y]) / 2.;
        center[Z] = rtip->mdl_min[Z] + (rtip->mdl_max[Z] -
		rtip->mdl_min[Z]) / 2.;

        /*  Find length of diagonal.  */
        diagonal = (rtip->mdl_max[X] - rtip->mdl_min[X])
                     * (rtip->mdl_max[X] - rtip->mdl_min[X])
                 + (rtip->mdl_max[Y] - rtip->mdl_min[Y])
                     * (rtip->mdl_max[Y] - rtip->mdl_min[Y])
                 + (rtip->mdl_max[Z] - rtip->mdl_min[Z])
                     * (rtip->mdl_max[Z] - rtip->mdl_min[Z]);
        diagonal = sqrt(diagonal) / 2. + .5;

        /*  Find minimum & maximum of grid.  */
        xmin = center[X] - diagonal;
        xmax = center[X] + diagonal;
        ymin = center[Y] - diagonal;
        ymax = center[Y] + diagonal;
        zmin = center[Z] - diagonal;
        zmax = center[Z] + diagonal;

        /*  Print center of bounding rpp, diagonal, & maximum  */
        /*  & minimum of grid.  */
        (void)fprintf(stdout,"Center of bounding rpp ( %f, %f, %f )\n",
		center[X],center[Y],center[Z]);
        (void)fprintf(stdout,"Length of diagonal of bounding rpp:  %f\n",
		diagonal);
        (void)fprintf(stdout,"Minimums & maximums of grid:\n");
        (void)fprintf(stdout,"  %f - %f\n",xmin,xmax);
        (void)fprintf(stdout,"  %f - %f\n",ymin,ymax);
        (void)fprintf(stdout,"  %f - %f\n\n",zmin,zmax);
        (void)fflush(stdout);

	/*  Write model minimum & maximum.  */
	(void)fprintf(stdout,"Model minimum & maximum.\n");
	(void)fprintf(stdout,"\tX:  %f to %f\n\tY:  %f to %f\n\tZ:  %f to %f\n\n",
	   rtip->mdl_min[X],rtip->mdl_max[X],
	   rtip->mdl_min[Y],rtip->mdl_max[Y],
	   rtip->mdl_min[Z],rtip->mdl_max[Z]);
	(void)fflush(stdout);

	if(iwrite == 1)
	{
	   (void)fprintf(fp3,"Model minimum & maximum.\n");
	   (void)fprintf(fp3,"\tX:  %f to %f\n\tY:  %f kto %f\n",
	      rtip->mdl_min[X],rtip->mdl_max[X],
	      rtip->mdl_min[Y],rtip->mdl_max[Y]);
	   (void)fprintf(fp3,"\tZ:  %f to %f\n\n",
	      rtip->mdl_min[Z],rtip->mdl_max[Z]);
	   (void)fflush(fp3);
	}

	/*  User enters grid spacing.  All units are in mm.  */
	(void)fprintf(stdout,"Enter spacing (mm) between fired rays.  ");
	(void)fflush(stdout);
	(void)scanf("%lf",&gridspace);

	(void)fprintf(stdout,"\ngrid spacing:  %f\n",gridspace);
	(void)fflush(stdout);

	if(iwrite == 1)
	{
	   (void)fprintf(fp3,"gridspacing:  %f\n\n",gridspace);
	   (void)fflush(fp3);
	}

	/*  Set up parameters for rt_shootray.  */
	ap.a_hit = hit;		/*  User supplied hit function.  */
	ap.a_miss = miss;	/*  User supplied miss function.  */
	ap.a_overlap = ovrlap;	/*  user supplied overlap function.  */
	ap.a_rt_i = rtip;	/*  Pointer from rt_dirbuild.  */
	ap.a_onehit = 0;	/*  Hit flag (returns all hits).  */
	ap.a_level = 0;		/*  Recursion level for diagnostics.  */
	ap.a_resource = 0;	/*  Address of resource structure (NULL).  */

	/*  Put angles for rotation into radians.  */
	angle[X] = radians((double)GAMMA);
	angle[Y] = radians((double)BETA);
	angle[Z] = radians((double)ALPHA);

	/*  Set up and shoot down the 1st axis, positive to negative  */
	/*  (x-axis).  */

	(void)fprintf(stdout,"\nShooting down 1st axis.\n");
	(void)fflush(stdout);

	strtpt[X] = xmax;
	strtpt[Y] = ymin + gridspace / 2.;
	strtpt[Z] = zmin + gridspace / 2.;
	strtdir[X] = (-1);
	strtdir[Y] = 0;
	strtdir[Z] = 0;

	/*  Rotate starting point.  (new pt = C + R[P -C])  */
	t[X] = strtpt[X] - center[X];
	t[Y] = strtpt[Y] - center[Y];
	t[Z] = strtpt[Z] - center[Z];

	(void)rotate(t,angle,r);

	ap.a_ray.r_pt[X] = center[X] + r[X];
	ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	/*  Rotate firing direction.  (new dir = R[D])  */
	(void)rotate(strtdir,angle,r);
	ap.a_ray.r_dir[X] = r[X];
	ap.a_ray.r_dir[Y] = r[Y];
	ap.a_ray.r_dir[Z] = r[Z];
d465 115
a579 1
	while(strtpt[Z] <= zmax)
d582 1
a582 1
	   iprev = (-1);	/*  No previous shots.  */
d584 2
a585 2
	   /*  Call rt_shootray.  */
	   (void)rt_shootray ( &ap );
d587 16
a602 16
	   strtpt[Y] += gridspace;
	   if(strtpt[Y] > ymax)
	   {
		strtpt[Y] = ymin + gridspace / 2.;
		strtpt[Z] += gridspace;
	   }

	   t[X] = strtpt[X] - center[X];
	   t[Y] = strtpt[Y] - center[Y];
	   t[Z] = strtpt[Z] - center[Z];

	   (void)rotate(t,angle,r);

	   ap.a_ray.r_pt[X] = center[X] + r[X];
	   ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	   ap.a_ray.r_pt[Z] = center[Z] + r[Z];
d606 2
a607 2
	/*  Shoot down 2nd & 3rd axes if necessary.  */
	if(ifire == 0)
d609 32
a640 32
	   /*  Set up & shoot down the 2nd axis (y-axis).  */
	   (void)printf("\nShooting down the 2nd axis.\n");
	   (void)fflush(stdout);

	   strtpt[X] = xmin + gridspace / 2.;
	   strtpt[Y] = ymax;
	   strtpt[Z] = zmin + gridspace / 2.;
	   strtdir[X] = 0.;
	   strtdir[Y] = (-1.);
	   strtdir[X] = 0.;

	   /*  Rotate starting point (new pt = C + R[P - C]).  */
	   t[X] = strtpt[X] - center [X];
	   t[Y] = strtpt[Y] - center [Y];
	   t[Z] = strtpt[Z] - center [Z];

	   (void)rotate(t,angle,r);

	   ap.a_ray.r_pt[X] = center[X] + r[X];
	   ap.a_ray.r_pt[Y] = center[Y] + r[Y];
	   ap.a_ray.r_pt[Z] = center[Z] + r[Z];

	   /*  Rotate firing direction (new dir = R[D])  */
	   (void)rotate(strtdir,angle,r);

	   ap.a_ray.r_dir[X] = r[X];
	   ap.a_ray.r_dir[Y] = r[Y];
	   ap.a_ray.r_dir[Z] = r[Z];

	   while(strtpt[Z] <= zmax)
	   {						/*  START # 1010  */
		iprev = (-1);		/*  No previous shots.  */
d642 2
a643 2
		/*  Call rt_shootray.  */
		(void)rt_shootray(&ap);
d645 2
a646 2
		strtpt[X] += gridspace;
		if(strtpt[X] > xmax)
d648 2
a649 2
		   strtpt[X] = xmin + gridspace / 2.;
		   strtpt[Z] += gridspace;
d652 36
a687 36
		t[X] = strtpt[X] - center[X];
		t[Y] = strtpt[Y] - center[Y];
		t[Z] = strtpt[Z] - center[Z];

		(void)rotate(t,angle,r);

		ap.a_ray.r_pt[X] = center[X] + r[X];
		ap.a_ray.r_pt[Y] = center[Y] + r[Y];
		ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	   }						/*  END # 1010  */

	   /*  Set up & shoot down the 3rd axis (z-axis).  */
	   (void)printf("\nShooting down the 3rd axis.\n");
	   (void)fflush(stdout);

	   strtpt[X] = xmin + gridspace / 2.;
	   strtpt[Y] = ymin + gridspace / 2.;
	   strtpt[Z] = zmax;
	   strtdir[X] = 0.;
	   strtdir[Y] = 0.;
	   strtdir[Z] = (-1.);

	   /*  Rotate starting points (new pt = C + R[P - C]).  */
	   t[X] = strtpt[X] - center[X];
	   t[Y] = strtpt[Y] - center[Y];
	   t[Z] = strtpt[Z] - center[Z];

	   (void)rotate(t,angle,r);

	   ap.a_ray.r_pt[X] = r[X];
	   ap.a_ray.r_pt[Y] = r[Y];
	   ap.a_ray.r_pt[Z] = r[Z];

	   while(strtpt[Y] <= ymax)
	   {						/*  START # 1020  */
		iprev = (-1);		/*  No previous shots.  */
d689 2
a690 2
		/*  Call rt_shootray.  */
		(void)rt_shootray(&ap);
d692 2
a693 2
		strtpt[X] += gridspace;
		if(strtpt[X] > xmax)
d695 2
a696 2
		   strtpt[X] = xmin + gridspace / 2.;
		   strtpt[Y] += gridspace;
d699 10
a708 10
		t[X] = strtpt[X] - center[X];
		t[Y] = strtpt[Y] - center[Y];
		t[Z] = strtpt[Z] - center[Z];

		(void)rotate(t,angle,r);

		ap.a_ray.r_pt[X] = center[X] + r[X];
		ap.a_ray.r_pt[Y] = center[Y] + r[Y];
		ap.a_ray.r_pt[Z] = center[Z] + r[Z];
	   }						/*  END # 1020  */
d711 2
a712 2
	/*  Calculate final length between centroid & shared surface area.  */
	if(iwrite == 0)
d714 2
a715 2
		(void)fprintf(stdout,"\n\nFinal numbers.\n");
		(void)fflush(stdout);
d718 1
a718 1
	for(i=0; i<numreg; i++)
d721 5
a725 5
	   if(iwrite == 0)
	   {
	   	(void)fprintf(stdout,"reg#=%d, matid=%d\n",(i+1),cond[i].mat);
	   	(void)fflush(stdout);
	   }
d727 5
a731 5
	   if(iwrite == 1)
	   {
		(void)fprintf(fp3,"reg#=%d, matid=%d\n",(i+1),cond[i].mat);
		(void)fflush(fp3);
	   }
d733 3
a735 3
	   for(j=0; j<numreg; j++)
	   {
		if(cond[i].numcal[j] > ZEROTOL)
d737 3
a739 3
		   cond[i].avglen[j] /= cond[i].numcal[j];
		   cond[i].rmslen[j] /= cond[i].numcal[j];
		   cond[i].rmslen[j] = sqrt(cond[i].rmslen[j]);
d741 2
a742 2
		   if(iwrite == 0)
		   {
d744 1
a744 1
		         (j+1),cond[i].numcal[j],cond[i].shrarea[j]);
d748 1
a748 1
		         cond[i].minlen[j],cond[i].maxlen[j]);
d750 1
a750 1
		   }
d752 2
a753 2
		   if(iwrite == 1)
		   {
d755 1
a755 1
		         (j+1),cond[i].numcal[j],cond[i].shrarea[j]);
d759 1
a759 1
		         cond[i].minlen[j],cond[i].maxlen[j]);
d761 1
a761 1
		   }
d764 1
a764 1
		else
d766 2
a767 2
		   cond[i].avglen[j] = 0.;
		   cond[i].rmslen[j] = 0.;
d769 1
a769 1
	   }
d772 1
a772 1
	if(iwrite == 1)
d774 8
a781 8
	   /*  Print summary of all files used.  */
	   (void)fprintf(fp3,"\n\nSUMMARY OF FILES USED & CREATED\n");
	   (void)fprintf(fp3,"\t.g file used:  %s\n",argv[1]);
	   (void)fprintf(fp3,"\tregions used:\n");
	   (void)fflush(fp3);
	   i=2;
	   while(argv[i] != NULL)
	   {
d785 28
a812 28
	   }
	   (void)fprintf(fp3,"\tfile containing second pass information:  %s\n",
		spfile);
	   (void)fprintf(fp3,"\tmaterial file used:  %s\n",filemat);
	   (void)fprintf(fp3,"\toutput file created:  %s\n",filename);
	   if(typeout == 0)
	   {
		(void)fprintf(fp3,"\tconductivity file created:  %s\n",confile);
		(void)fprintf(fp3,"\t  (format is PRISM %d.0)\n",prmrel);
	   }
	   if(typeout == 1) (void)fprintf(fp3,"\tgeneric file created:  %s\n"
		,genfile);
	   (void)fprintf(fp3,"\tconductivity table file created:  %s\n",
		tblfile);
	   (void)fprintf(fp3,"\terror file created:  %s\n\n\n",fileerr);
	   (void)fflush(fp3);

	   (void)fclose(fp3);
	}

	/*------------------------------------------------------------------*/

	/*  Open conductivity file to be used with PRISM if needed.  */
	if(typeout == 0)
	{
	   fp1=fopen(confile,"w");
	   (void)fprintf(fp1,"Conductivity file for use with PRISM.\n");
	   (void)fflush(fp1);
d815 2
a816 2
	/*  Make calculations & write to conductivity file.  */
	for(i=0; i<numreg; i++)
d819 2
a820 2
	/*  Make conductivity file triangular.  This program still  */
	/*  computes the ENTIRE matrix.  */
d822 2
a823 2
	   for(j=(i+1); j<numreg; j++)
	   {	/*  START # 7  */
d825 1
a825 1
		if( (cond[i].avglen[j] != 0) )
d827 114
a940 114
		   /*  Find correct thermal conductivity.  */
		   /*  If ki or kj = 0 => rk = 0.  */
		   ki = k[cond[i].mat];
		   kj = k[cond[j].mat];

		   /*  All calculations will be in meters &  */
		   /*  square meters.  */

		   areai = cond[i].shrarea[j] * 1.e-6;

		   /*  average length  */
		   leni = cond[i].avglen[j] * 1.e-3;
		   lenj = cond[j].avglen[i] * 1.e-3;
		   if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		      ((-ZEROTOL < kj) && (kj < ZEROTOL)))
			cond[i].rkavg[j] = 0.;
		   else
		   {
			rki = leni / (ki * areai);
			rkj = lenj / (kj * areai);
		        cond[i].rkavg[j] = 1. / (rki + rkj);
		   }

		   /*  rms length  */
		   leni = cond[i].rmslen[j] * 1.e-3;
		   lenj = cond[j].rmslen[i] * 1.e-3;
		   if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		      ((-ZEROTOL < kj) && (kj < ZEROTOL)))
			cond[i].rkrms[j] = 0.;
		   else
		   {
		        rki = leni / (ki * areai);
		        rkj = lenj / (kj * areai);
		        cond[i].rkrms[j] = 1. / (rki + rkj);
		   }

		   /*  minimum length  */
		   leni = cond[i].minlen[j] * 1.e-3;
		   lenj = cond[j].minlen[i] * 1.e-3;
		   if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		      ((-ZEROTOL < kj) && (kj < ZEROTOL)))
			cond[i].rkmin[j] = 0.;
		   else
		   {
		        rki = leni / (ki * areai);
		        rkj = lenj / (kj * areai);
		        cond[i].rkmin[j] = 1. / (rki + rkj);
		   }

		   /*  maximum length  */
		   leni = cond[i].maxlen[j] * 1.e-3;
		   lenj = cond[j].maxlen[i] * 1.e-3;
		   if(((-ZEROTOL < ki) && (ki < ZEROTOL)) ||
		      ((-ZEROTOL < kj) && (kj < ZEROTOL)))
			cond[i].rkmax[j] = 0.;
		   else
		   {
		        rki = leni / (ki * areai);
		        rkj = lenj / (kj * areai);
		        cond[i].rkmax[j] = 1. / (rki + rkj);
		   }

		   /*  Print if had adjacent regions, conductivity  */
		   /*  may be zero.  */

		   /*  Print only if PRISM file is to be created.  */
		   if(typeout == 0) {		/*  START # 8A  */
		   if( (itype == 1) && (cond[i].shrarea[j] > ZEROTOL) )
		   {
		     if(prmrel == 2)
			(void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkavg[j],
			(cond[i].shrarea[j] * 1.0e-6));
		     if(prmrel == 3)
			(void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkavg[j],
			(cond[i].shrarea[j] * 1.0e-6));
		   }

		   if( (itype == 2) && (cond[i].shrarea[j] > ZEROTOL) )
		   {
		     if(prmrel == 2)
			(void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkrms[j],
			(cond[i].shrarea[j] * 1.0e-6));
		     if(prmrel == 3)
			(void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkrms[j],
			(cond[i].shrarea[j] * 1.0e-6));
		   }

		   if( (itype == 3) && (cond[i].shrarea[j] > ZEROTOL) )
		   {
		     if(prmrel == 2)
			(void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkmin[j],
			(cond[i].shrarea[j] * 1.0e-6));
		     if(prmrel == 3)
			(void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkmin[j],
			(cond[i].shrarea[j] * 1.0e-6));
		   }

		   if( (itype == 4) && (cond[i].shrarea[j] > ZEROTOL) )
		   {
		     if(prmrel == 2)
			(void)fprintf(fp1,"%3d %3d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkmax[j],
			(cond[i].shrarea[j] * 1.0e-6));
		     if(prmrel == 3)
			(void)fprintf(fp1,"%6d %6d %7.3f %.3e\n",
			(j+1),(i+1),cond[i].rkmax[j],
			(cond[i].shrarea[j] * 1.0e-6));
		   }
d942 2
a943 2
		   (void)fflush(fp1);
		   }				/*  END of # 8A  */
d945 1
a945 1
	   }	/*  END # 7  */
d948 8
a955 1
	if(typeout == 0) (void)fclose(fp1);
d957 6
a962 1
	/*------------------------------------------------------------------*/
d964 13
a976 25
	/*  Open and write to generic file if necessary. */
	/*  The format follows.  */
	/*  4  region number  number of adjacent regions  */
	/*     adjacent region  shared area  conduction distance  */

	if(typeout == 1)
	{
	   /*  Open file.  */
	   fp6 = fopen(genfile,"w");
	   (void)printf("Opened generic file.\n");
	   (void)fflush(stdout);

	   for(i=0; i<numreg; i++)
	   {
		/*  Find number of adjacent regions.  */
/*
 *		(void)printf("Ready to find number of adjacent areas.\n");
 *		(void)fflush(stdout);
 */
		nadjreg = 0;
/*
 *		(void)printf("nadjreg = %d\n",nadjreg);
 *		(void)fflush(stdout);
 */
		for(j=0; j<numreg; j++)
d978 5
a982 5
/*
 *		   (void)printf("%d, %d, %f\n",i,j,cond[i].shrarea[j]);
 *		   (void)fflush(stdout);
 */
		   if(cond[i].shrarea[j] > ZEROTOL) nadjreg += 1;
d984 4
a987 4
/*
 *		(void)printf("Found number of adjacent areas.\n");
 *		(void)fflush(stdout);
 */
d989 2
a990 2
		(void)fprintf(fp6,"4  %5d  %5d\n",(i+1),nadjreg);
		(void)fflush(fp6);
d992 1
a992 1
		for(j=0; j<numreg; j++)
d994 14
a1007 14
		   if(cond[i].shrarea[j] > ZEROTOL)
		   {
			(void)fprintf(fp6,"   %5d  %.3e  ",(j+1),
			   (cond[i].shrarea[j] * 1.e-6));
			if(itype == 1) (void)fprintf(fp6,"%.3e\n",
			   (cond[i].avglen[j] * 1.e-3));
			if(itype == 2) (void)fprintf(fp6,"%.3e\n",
			   (cond[i].rmslen[j] * 1.e-3));
			if(itype == 3) (void)fprintf(fp6,"%.3e\n",
			   (cond[i].minlen[j] * 1.e-3));
			if(itype == 4) (void)fprintf(fp6,"%.3e\n",
			   (cond[i].maxlen[j] * 1.e-3));
		   }
		   (void)fflush(fp6);
d1009 2
a1010 2
	   }
	   (void)fclose(fp6);
d1013 1
a1013 1
	/*------------------------------------------------------------------*/
d1015 5
a1019 5
	/*  Open conductivity table file and write information to  */
	/*  it.  All units will be in meters or square meters.  */
	fp2=fopen(tblfile,"w");
	(void)fprintf(fp2,"Conductivity table.  Units are in meters or ");
	(void)fprintf(fp2,"square meters.\n");
d1021 5
a1025 5
	(void)fprintf(fp2," reg, mat, adj,   shrarea,");
	(void)fprintf(fp2,"    avglen,     rkavg,");
	(void)fprintf(fp2,"    rmslen,     rkrms,");
	(void)fprintf(fp2,"    minlen,     rkmin,");
	(void)fprintf(fp2,"    maxlen,     rkmax\n");
d1027 1
a1027 1
	(void)fflush(fp2);
d1029 1
a1029 1
	for(i=0; i<numreg; i++)
d1031 3
a1033 3
	   for(j=0; j<numreg; j++)
	   {	/*  START # 10  */
		if(cond[i].shrarea[j] != 0)
d1035 22
a1056 22
		   a1 = cond[i].shrarea[j] * 1.e-6;
		   l1 = cond[i].avglen[j] * 1.e-3;
		   l2 = cond[i].rmslen[j] * 1.e-3;
		   l3 = cond[i].minlen[j] * 1.e-3;
		   l4 = cond[i].maxlen[j] * 1.e-3;

		   (void)fprintf(fp2,"%4d,%4d,%4d, %.3e,",
			(i+1),cond[i].mat,(j+1),a1);
		   if(j > i)
		   {
		     (void)fprintf(fp2," %.3e, %.3e,",l1,cond[i].rkavg[j]);
		     (void)fprintf(fp2," %.3e, %.3e,",l2,cond[i].rkrms[j]);
		     (void)fprintf(fp2," %.3e, %.3e,",l3,cond[i].rkmin[j]);
		     (void)fprintf(fp2," %.3e, %.3e\n",l4,cond[i].rkmax[j]);
		   }
		   else
		   {
		     (void)fprintf(fp2," %.3e, %.3e,",l1,cond[j].rkavg[i]);
		     (void)fprintf(fp2," %.3e, %.3e,",l2,cond[j].rkrms[i]);
		     (void)fprintf(fp2," %.3e, %.3e,",l3,cond[j].rkmin[i]);
		     (void)fprintf(fp2," %.3e, %.3e\n",l4,cond[j].rkmax[i]);
		   }
d1058 1
a1058 1
		   (void)fflush(fp2);
d1060 1
a1060 1
	   }	/*  END # 10  */
d1063 1
a1063 1
	(void)fclose(fp2);
d1065 1
a1065 1
	/*------------------------------------------------------------------*/
d1067 7
a1073 7
	/*  Print summary of all files used.  */
	(void)fprintf(stdout,"\n\nSUMMARY OF FILES USED & CREATED\n");
	(void)fprintf(stdout,"\t.g file used:  %s\n",argv[1]);
	(void)fprintf(stdout,"\tregions used:\n");
	(void)fflush(stdout);
	i=2;
	while(argv[i] != NULL)
d1075 3
a1077 3
	   (void)fprintf(stdout,"\t\t%s\n",argv[i]);
	   (void)fflush(stdout);
	   i++;
d1079 4
a1082 4
	(void)fprintf(stdout,"\tfile containing second pass information:  %s\n",
		spfile);
	(void)fprintf(stdout,"\tmaterial file used:  %s\n",filemat);
	if(iwrite == 1)
d1084 1
a1084 1
	   (void)fprintf(stdout,"\toutput file created:  %s\n",filename);
d1086 1
a1086 1
	if(typeout == 0)
d1088 2
a1089 2
	   (void)fprintf(stdout,"\tconductivity file created:  %s\n",confile);
	   (void)fprintf(stdout,"\t  (format is PRISM %d.0)\n",prmrel);
d1091 4
a1094 4
	if(typeout == 1) (void)printf("\tgeneric file created:  %s\n",genfile);
	(void)fprintf(stdout,"\tconductivity table file created:  %s\n",tblfile);
	(void)fprintf(stdout,"\terror file created:  %s\n\n\n",fileerr);
	(void)fflush(stdout);
d1096 1
a1096 1
	/*------------------------------------------------------------------*/
d1098 2
a1099 2
	/*  Open error file.  */
	fp4 = fopen(fileerr,"w");
d1101 4
a1104 4
	/*  Write errors to error file.  */
	(void)fprintf(fp4,"\nERRORS from secpass\n\n");
	/*  Write type of file created to error file.  */
	if(typeout == 0)
d1106 2
a1107 2
	   (void)fprintf(fp4,"PRISM %d.0 conductivity file, %s, created.\n\n",
		prmrel,confile);
d1109 4
a1112 4
	if(typeout == 1) (void)fprintf(fp4,"Generic file, %s, created.\n\n",
		genfile);
	(void)fflush(fp4);
	for(i=0; i<numreg; i++)
d1114 4
a1117 4
	   for(j=0; j<numreg;  j++)
	   {
		if( (cond[i].numcal[j] > ZEROTOL) &&
		   ( cond[i].numcal[j] < MINCAL ) )
d1119 5
a1123 5
		   (void)fprintf(fp4,"region %d, adjacent region %d:\n",
			(i+1),(j+1));
		   (void)fprintf(fp4,"\tnumber of length calculations ");
		   (void)fprintf(fp4,"below minimum of %d\n",MINCAL);
		   (void)fflush(fp4);
d1125 1
a1125 1
	   }
d1127 1
a1127 1
	(void)fclose(fp4);
d1129 1
a1129 1
	/*------------------------------------------------------------------*/
d1131 17
a1147 17
   /*  Everything completed, free memory.  */
   (void)fprintf(stdout,"Freeing memory.\n");
   (void)fflush(stdout);
   for(i=0; i<nmged; i++)
   {
	free(cond[i].shrarea);
	free(cond[i].avglen);
	free(cond[i].rmslen);
	free(cond[i].minlen);
	free(cond[i].maxlen);
	free(cond[i].numcal);
	free(cond[i].rkavg);
	free(cond[i].rkrms);
	free(cond[i].rkmin);
	free(cond[i].rkmax);
   }
   free(cond);
d1149 2
a1150 2
   }	/*  END # 2  */
   return(0);
d1156 1
a1156 1
hit(register struct application *ap_p, struct partition *PartHeadp)
d1159 3
a1161 3
   register struct partition *pp;
   register struct hit *hitp;
   register struct soltab *stp;
d1163 1
a1163 1
   double d[3];		/*  used for checking tolerance of  */
d1165 1
a1165 1
   double dist;		/*  used for finding lenght between  */
d1168 17
a1184 17
/*
 * (void)fprintf(stdout,"In hit function.\n");
 * (void)fflush(stdout);
 */

   pp = PartHeadp->pt_forw;
   for( ; pp != PartHeadp; pp = pp->pt_forw)
   {	/*  START # 2H  */
	icur = pp->pt_regionp->reg_bit;	/*  Number of region hit.  */

	/*  Find hit point of entering ray.  */
	hitp = pp->pt_inhit;
	stp = pp->pt_inseg->seg_stp;
	RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
	enterpt[X] = hitp->hit_point[X];
	enterpt[Y] = hitp->hit_point[Y];
	enterpt[Z] = hitp->hit_point[Z];
d1186 1
a1186 1
	/*  Find lengths between centroids and adjacent surface areas.  */
d1188 1
a1188 1
	if(iprev >= 0)
d1190 6
a1195 6
	   d[X] = enterpt[X] - leavept[X];
	   if(d[X] < 0) d[X] = (-d[X]);
	   d[Y] = enterpt[Y] - leavept[Y];
	   if(d[Y] < 0) d[Y] = (-d[Y]);
	   d[Z] = enterpt[Z] - leavept[Z];
	   if(d[Z] < 0) d[Z] = (-d[Z]);
d1197 2
a1198 2
	   if( (d[X] < ADJTOL) && (d[Y] < ADJTOL) && (d[Z] < ADJTOL) )
	   {	/*  START # 4H  */
d1200 10
a1209 10
		dist = ( (cond[iprev].centroid[X] - enterpt[X])
		         * (cond[iprev].centroid[X] - enterpt[X]) ) +
		       ( (cond[iprev].centroid[Y] - enterpt[Y])
		         * (cond[iprev].centroid[Y] - enterpt[Y]) ) +
		       ( (cond[iprev].centroid[Z] - enterpt[Z])
		         * (cond[iprev].centroid[Z] - enterpt[Z]) );
		dist = sqrt(dist);
		cond[iprev].avglen[icur] += dist;
		cond[iprev].rmslen[icur] += (dist * dist);
		cond[iprev].numcal[icur] += 1.;
d1211 2
a1212 2
		if( (-ZEROTOL < cond[iprev].minlen[icur]) &&
		    (cond[iprev].minlen[icur] < ZEROTOL) )
d1214 1
a1214 1
			cond[iprev].minlen[icur] = dist;
d1216 1
a1216 1
		else if( dist < cond[iprev].minlen[icur] )
d1218 1
a1218 1
			cond[iprev].minlen[icur] = dist;
d1221 2
a1222 2
		if( (-ZEROTOL < cond[iprev].maxlen[icur]) &&
		    (cond[iprev].maxlen[icur] < ZEROTOL) )
d1224 1
a1224 1
			cond[iprev].maxlen[icur] = dist;
d1226 1
a1226 1
		else if( cond[iprev].maxlen[icur] < dist )
d1228 1
a1228 1
			cond[iprev].maxlen[icur] = dist;
d1231 16
a1246 16
/*
 *		(void)fprintf(stdout,"\treg#:  %d, length:  %f\n",iprev,dist);
 *		(void)fflush(stdout);
 */

		/*  Find lenght for current region.  */
		dist = ( (cond[icur].centroid[X] - enterpt[X])
		         * (cond[icur].centroid[X] - enterpt[X]) ) +
		       ( (cond[icur].centroid[Y] - enterpt[Y])
		         * (cond[icur].centroid[Y] - enterpt[Y]) ) +
		       ( (cond[icur].centroid[Z] - enterpt[Z])
		         * (cond[icur].centroid[Z] - enterpt[Z]) );
		dist = sqrt(dist);
		cond[icur].avglen[iprev] += dist;
		cond[icur].rmslen[iprev] += (dist * dist);
		cond[icur].numcal[iprev] += 1.;
d1248 2
a1249 2
		if( (-ZEROTOL < cond[icur].minlen[iprev]) &&
		    (cond[icur].minlen[iprev] < ZEROTOL) )
d1251 1
a1251 1
			cond[icur].minlen[iprev] = dist;
d1253 1
a1253 1
		else if( dist < cond[icur].minlen[iprev] )
d1255 1
a1255 1
			cond[icur].minlen[iprev] = dist;
d1258 2
a1259 2
		if( (-ZEROTOL < cond[icur].maxlen[iprev]) &&
		    (cond[icur].maxlen[iprev] < ZEROTOL) )
d1261 1
a1261 1
			cond[icur].maxlen[iprev] = dist;
d1263 1
a1263 1
		else if( cond[icur].maxlen[iprev] < dist )
d1265 1
a1265 1
			cond[icur].maxlen[iprev] = dist;
d1268 4
a1271 4
/*
 *		(void)fprintf(stdout,"\treg#:  %d, length:  %f\n",icur,dist);
 *		(void)fflush(stdout);
 */
d1273 1
a1273 1
	   }	/*  END # 4H  */
d1276 19
a1294 19
	/*  Find hit point of leaving ray.  */
	hitp = pp->pt_outhit;
	stp = pp->pt_outseg->seg_stp;
	RT_HIT_NORM(hitp,stp,&(ap_p->a_ray));
	leavept[X] = hitp->hit_point[X];
	leavept[Y] = hitp->hit_point[Y];
	leavept[Z] = hitp->hit_point[Z];

/*
 *	(void)fprintf(stdout,"current region:  %d, previous region:  %d\n",icur,iprev);
 *	(void)fprintf(stdout,"   entering pt:  %f, %f, %f\n",enterpt[X],enterpt[Y],
 *		enterpt[Z]);
 *	(void)fprintf(stdout,"   leaving pt:   %f, %f, %f\n",leavept[X],leavept[Y],
 *		leavept[Z]);
 */

	/*  Set previous region to current region.  */
	iprev = icur;
   }	/*  END # 2H  */
d1296 1
a1296 1
   return(1);
d1306 4
a1309 6
/*
 * (void)fprintf(stdout,"In miss function.\n");
 * (void)fflush(stdout);
 */

   return(0);
d1311 1
d1314 1
a1316 6

/*  User supplied overlap function that does nothing.  */

                                  
                            
                          
d1318 1
a1318 1
	return(1);
a1319 2


@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/irprep/secpass.c,v 1.2 2004/06/08 22:04:16 morrison Exp $ (BRL)";
d52 1
a52 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d47 1
a47 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/irprep/secpass.c,v 11.9 2004/05/10 15:30:43 erikg Exp $ (BRL)";
a61 1
#include "externs.h"
@

