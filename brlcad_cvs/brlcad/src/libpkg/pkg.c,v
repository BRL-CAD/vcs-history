head	14.53;
access;
symbols
	rel-7-10-4:14.42
	STABLE:14.42.0.2
	stable-branch:14.10
	rel-7-10-2:14.42
	rel-7-10-0:14.41
	rel-7-8-4:14.36
	rel-7-8-2:14.24
	rel-7-8-0:14.23
	trimnurbs-branch:14.22.0.2
	help:14.22
	temp_tag:14.19
	bobWinPort-20051223-freeze:14.16.2.1
	postmerge-20051223-bobWinPort:14.19
	premerge-20051223-bobWinPort:14.18
	rel-7-6-6:14.18
	rel-7-6-4:14.18
	rel-7-6-2:14.16
	rel-7-6-branch:14.16.0.6
	rel-7-6-0:14.16
	rel-7-4-2:14.16
	rel-7-4-branch:14.16.0.4
	bobWinPort:14.16.0.2
	rel-7-4-0:14.16
	rel-7-2-6:14.16
	rel-7-2-4:14.15
	rel-7-2-2:14.10
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.53
date	2007.12.16.18.53.49;	author brlcad;	state Exp;
branches;
next	14.52;

14.52
date	2007.12.16.15.59.39;	author brlcad;	state Exp;
branches;
next	14.51;

14.51
date	2007.12.15.20.13.58;	author brlcad;	state Exp;
branches;
next	14.50;

14.50
date	2007.12.15.08.44.39;	author brlcad;	state Exp;
branches;
next	14.49;

14.49
date	2007.12.07.07.03.19;	author brlcad;	state Exp;
branches;
next	14.48;

14.48
date	2007.12.01.21.47.12;	author brlcad;	state Exp;
branches;
next	14.47;

14.47
date	2007.11.08.19.48.43;	author bob1961;	state Exp;
branches;
next	14.46;

14.46
date	2007.11.05.04.38.18;	author brlcad;	state Exp;
branches;
next	14.45;

14.45
date	2007.09.18.15.02.32;	author erikgreenwald;	state Exp;
branches;
next	14.44;

14.44
date	2007.09.15.16.23.11;	author brlcad;	state Exp;
branches;
next	14.43;

14.43
date	2007.09.15.03.41.58;	author brlcad;	state Exp;
branches;
next	14.42;

14.42
date	2007.05.12.22.24.26;	author brlcad;	state Exp;
branches;
next	14.41;

14.41
date	2007.03.02.20.51.05;	author erikgreenwald;	state Exp;
branches;
next	14.40;

14.40
date	2007.01.27.01.41.38;	author brlcad;	state Exp;
branches;
next	14.39;

14.39
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.38;

14.38
date	2007.01.20.14.36.53;	author brlcad;	state Exp;
branches;
next	14.37;

14.37
date	2006.10.30.16.33.03;	author jlowenz;	state Exp;
branches;
next	14.36;

14.36
date	2006.08.29.21.32.56;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2006.08.29.21.27.25;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2006.08.29.20.55.13;	author brlcad;	state Exp;
branches;
next	14.33;

14.33
date	2006.08.29.20.06.30;	author bob1961;	state Exp;
branches;
next	14.32;

14.32
date	2006.08.28.00.52.48;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2006.08.24.17.05.19;	author jlowenz;	state Exp;
branches;
next	14.30;

14.30
date	2006.08.17.20.32.20;	author jlowenz;	state Exp;
branches;
next	14.29;

14.29
date	2006.07.13.21.10.22;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2006.07.10.17.07.11;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2006.07.09.19.17.16;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2006.07.09.10.53.15;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2006.07.09.09.44.11;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2006.06.03.01.37.52;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2006.03.24.23.45.16;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2006.01.22.09.53.17;	author brlcad;	state Exp;
branches
	14.22.2.1;
next	14.21;

14.21
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.01.12.01.34.02;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2005.12.23.21.26.30;	author bob1961;	state Exp;
branches;
next	14.18;

14.18
date	2005.11.04.20.19.47;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.05.28.02.14.51;	author brlcad;	state Exp;
branches
	14.16.2.1
	14.16.6.1;
next	14.15;

14.15
date	2005.05.11.21.44.53;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.05.01.20.16.24;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.04.27.03.08.35;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.04.27.02.50.20;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.04.27.02.02.13;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.03.28.16.47.37;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.03.28.05.52.27;	author bob1961;	state Exp;
branches;
next	14.8;

14.8
date	2005.03.24.16.20.12;	author bob1961;	state Exp;
branches;
next	14.7;

14.7
date	2005.03.16.07.25.05;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.56;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.58;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.02.32.07;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.15.05.53.08;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.08.19.15.09;	author kermit;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.24;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.54;	author morrison;	state Exp;
branches;
next	;

14.16.2.1
date	2005.09.08.15.27.21;	author bob1961;	state Exp;
branches;
next	;

14.16.6.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;

14.22.2.1
date	2006.04.07.19.30.23;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.53
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                           P K G . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file pkg.c
 *
 *  Routines to manage multiplexing and de-multiplexing synchronous
 *  and asynchronous messages across stream connections.
 *
 *  Functions -
 *	pkg_gshort	Get a 16-bit short from a char[2] array
 *	pkg_glong	Get a 32-bit long from a char[4] array
 *	pkg_pshort	Put a 16-bit short into a char[2] array
 *	pkg_plong	Put a 32-bit long into a char[4] array
 *	pkg_open	Open a network connection to a host/server
 *	pkg_transerver	Become a transient network server
 *	pkg_permserver	Create a network server, and listen for connection
 *	pkg_getclient	As permanent network server, accept a new connection
 *	pkg_close	Close a network connection
 *	pkg_send	Send a message on the connection
 *	pkg_2send	Send a two part message on the connection
 *	pkg_stream	Send a message that doesn't need a push
 *	pkg_flush	Empty the stream buffer of any queued messages
 *	pkg_waitfor	Wait for a specific msg, user buf, processing others
 *	pkg_bwaitfor	Wait for specific msg, malloc buf, processing others
 *	pkg_block	Wait until a full message has been read
 *
 *  Authors -
 *	Michael John Muuss
 *	Charles M. Kennedy
 *	Phillip Dykstra
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.52 2007/12/16 15:59:39 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>		/* used by inet_addr() routine, below */
#include <time.h>
#include <string.h>

#ifdef HAVE_SYS_PARAM_H
#  include <sys/param.h>
#endif
#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_STAT_H
#  include <sys/stat.h>
#endif

#ifdef HAVE_WINSOCK_H
#  include <process.h>
#  include <winsock.h>
#  include <fcntl.h>
#else
#  include <sys/socket.h>
#  include <sys/ioctl.h>		/* for FIONBIO */
#  include <netinet/in.h>		/* for htons(), etc */
#  include <netdb.h>
#  include <netinet/tcp.h>	/* for TCP_NODELAY sockopt */
#  include <arpa/inet.h>		/* for inet_addr() */
#  undef LITTLE_ENDIAN		/* defined in netinet/{ip.h,tcp.h} */
#endif

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"


/* Not all systems with "BSD Networking" include UNIX Domain sockets */
#ifdef HAVE_SYS_UN_H
#  include <sys/un.h>		/* UNIX Domain sockets */
#endif

#ifdef n16
/* Encore multimax */
#  include <sys/h/socket.h>
#  include <sys/ioctl.h>
#  include <sys/netinet/in.h>
#  include <sys/aux/netdb.h>
#  include <sys/netinet/tcp.h>
#endif

#ifdef HAVE_WRITEV
#  include <sys/uio.h>		/* for struct iovec (writev) */
#endif

#include <errno.h>
#include "pkg.h"


/* XXX is this really necessary?  the _read() and _write()
 * compatibility macros should take care of this.
 */
#ifdef HAVE_WINSOCK_H
#  define PKG_READ(d, buf, nbytes) recv((d), (buf), (nbytes), 0)
#  define PKG_SEND(d, buf, nbytes) send((d), (buf), (nbytes), 0)
#else
#  define PKG_READ(d, buf, nbytes) read((d), (buf), (nbytes))
#  define PKG_SEND(d, buf, nbytes) write((d), (buf), (nbytes))
#endif

#if defined(__stardent)
/* <sys/byteorder.h> seems to be wrong, and this is a LITTLE_ENDIAN machine */
#  undef	htons
#  define	htons(x)	((((x)&0xFF)<<8)|(((x)>>8)&0xFF))
#  undef	htonl
#  define	htonl(x)	( \
	((((x)    )&0xFF)<<24) | \
	((((x)>> 8)&0xFF)<<16) | \
	((((x)>>16)&0xFF)<< 8) | \
	((((x)>>24)&0xFF)    )   )
#endif


int pkg_nochecking = 0;	/* set to disable extra checking for input */
int pkg_permport = 0;	/* TCP port that pkg_permserver() is listening on XXX */

/* Internal Functions */
static struct pkg_conn *pkg_makeconn(int fd, const struct pkg_switch *switchp, void (*errlog) (char *msg));
static void pkg_errlog(char *msg);
static void pkg_perror(void (*errlog) (char *msg), char *s);
static int pkg_dispatch(register struct pkg_conn *pc);
static int pkg_gethdr(register struct pkg_conn *pc, char *buf);

#define MAX_ERRBUF_SIZE 80
static char errbuf[MAX_ERRBUF_SIZE] = {0};
static FILE	*pkg_debug = (FILE*)NULL;
static void	pkg_ck_debug(void);
static void	pkg_timestamp(void);
static void	pkg_checkin(register struct pkg_conn *pc, int nodelay);


#define PKG_CK(p)	{if(p==PKC_NULL||p->pkc_magic!=PKG_MAGIC) {\
			snprintf(errbuf, MAX_ERRBUF_SIZE, "%s: bad pointer x%lx line %d\n",__FILE__, (long)(p), __LINE__);\
			pkg_errlog(errbuf);abort();}}

#define	MAXQLEN	512	/* largest packet we will queue on stream */

/* A macro for logging a string message when the debug file is open */
#ifndef NO_DEBUG_CHECKING
#  define DMSG(s) if(pkg_debug) {pkg_timestamp(); fprintf(pkg_debug,"%s",s); fflush(pkg_debug);}
#else
#  define DMSG(s) /**/
#endif

int
pkg_init() {
#ifdef _WIN32
    WORD wVersionRequested;
    WSADATA wsaData;

    wVersionRequested = MAKEWORD(1, 1);
    if (WSAStartup(wVersionRequested, &wsaData) != 0) {
	fprintf(stderr, "pkg_startup:  could not find a usable WinSock DLL" );
	return(-1);
    }
#endif

    return 0; /* good */
}

void
pkg_terminate() {
#ifdef _WIN32
    WSACleanup();
#endif
}

/*
 * Routines to insert/extract short/long's into char arrays,
 * independend of machine byte order and word-alignment.
 */

/*
 *			P K G _ G S H O R T
 */
unsigned short
pkg_gshort(char *buf)
{
    register unsigned char *p = (unsigned char *)buf;
    register unsigned short u;

    u = *p++ << 8;
    return ((unsigned short)(u | *p));
}

/*
 *			P K G _ G L O N G
 */
unsigned long
pkg_glong(char *buf)
{
    register unsigned char *p = (unsigned char *)buf;
    register unsigned long u;

    u = *p++; u <<= 8;
    u |= *p++; u <<= 8;
    u |= *p++; u <<= 8;
    return (u | *p);
}

/*
 *			P K G _ P S H O R T
 */
char *
pkg_pshort(char *buf, short unsigned int s)
{
    buf[1] = s;
    buf[0] = s >> 8;
    return((char *)buf+2);
}

/*
 *			P K G _ P L O N G
 */
char *
pkg_plong(char *buf, long unsigned int l)
{
    buf[3] = l;
    buf[2] = (l >>= 8);
    buf[1] = (l >>= 8);
    buf[0] = l >> 8;
    return((char *)buf+4);
}

/*
 *			P K G _ O P E N
 *
 *  We are a client.  Make a connection to the server.
 *
 *  Returns PKC_ERROR on error.
 */
struct pkg_conn *
pkg_open(const char *host, const char *service, const char *protocol, const char *uname, const char *passwd, const struct pkg_switch *switchp, void (*errlog) (char *msg))
{
#ifdef _WIN32
    LPHOSTENT lpHostEntry;
    register SOCKET netfd;
    SOCKADDR_IN saServer;
#else
    struct sockaddr_in sinme;		/* Client */
    struct sockaddr_in sinhim;		/* Server */
#ifdef HAVE_SYS_UN_H
    struct sockaddr_un sunhim;		/* Server, UNIX Domain */
#endif
    register struct hostent *hp;
    register int netfd;
    struct	sockaddr *addr;			/* UNIX or INET addr */
    int	addrlen;			/* length of address */
#endif

    pkg_ck_debug();
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_open(%s, %s, %s, %s, (passwd), switchp=x%lx, errlog=x%lx)\n",
		 host, service, protocol, uname,
		 (long)switchp, (long)errlog );
	fflush(pkg_debug);
    }

    /* Check for default error handler */
    if( errlog == NULL )
	errlog = pkg_errlog;

#ifdef _WIN32
    if ((lpHostEntry = gethostbyname(host)) == NULL) {
	pkg_perror(errlog, "pkg_open:  gethostbyname");
	return(PKC_ERROR);
    }

    if ((netfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
	pkg_perror(errlog, "pkg_open:  socket");
	return(PKC_ERROR);
    }

#if 0
    _setmode(netfd, _O_BINARY);
#endif

    memset((char *)&saServer, 0, sizeof(saServer));

    if (atoi(service) > 0) {
	saServer.sin_port = htons((unsigned short)atoi(service));
    } else {
	register struct servent *sp;
	if ((sp = getservbyname(service, "tcp")) == NULL) {
	    snprintf(errbuf, MAX_ERRBUF_SIZE, "pkg_open(%s,%s): unknown service\n",
		    host, service );
	    errlog(errbuf);
	    return(PKC_ERROR);
	}
	saServer.sin_port = sp->s_port;
    }
    saServer.sin_family = AF_INET;
    saServer.sin_addr = *((LPIN_ADDR)*lpHostEntry->h_addr_list);

    if (connect(netfd, (LPSOCKADDR)&saServer, sizeof(struct sockaddr)) == SOCKET_ERROR) {
	pkg_perror(errlog, "pkg_open:  client connect");
	closesocket(netfd);
	return(PKC_ERROR);
    }

    return(pkg_makeconn(netfd, switchp, errlog));
#else
    memset((char *)&sinhim, 0, sizeof(sinhim));
    memset((char *)&sinme, 0, sizeof(sinme));

#ifdef HAVE_SYS_UN_H
    if( host == NULL || strlen(host) == 0 || strcmp(host,"unix") == 0 ) {
	/* UNIX Domain socket, port = pathname */
	sunhim.sun_family = AF_UNIX;
	strncpy( sunhim.sun_path, service, sizeof(sunhim.sun_path) );
	addr = (struct sockaddr *) &sunhim;
	addrlen = strlen(sunhim.sun_path) + 2;
	goto ready;
    }
#endif

    /* Determine port for service */
    if( atoi(service) > 0 )  {
	sinhim.sin_port = htons((unsigned short)atoi(service));
    } else {
	register struct servent *sp;
	if( (sp = getservbyname( service, "tcp" )) == NULL )  {
	    snprintf(errbuf, MAX_ERRBUF_SIZE, "pkg_open(%s,%s): unknown service\n",
		    host, service );
	    errlog(errbuf);
	    return(PKC_ERROR);
	}
	sinhim.sin_port = sp->s_port;
    }

    /* Get InterNet address */
    if( atoi( host ) > 0 )  {
	/* Numeric */
	sinhim.sin_family = AF_INET;
	sinhim.sin_addr.s_addr = inet_addr(host);
    } else {
	if( (hp = gethostbyname(host)) == NULL )  {
	    snprintf(errbuf, MAX_ERRBUF_SIZE, "pkg_open(%s,%s): unknown host\n",
		    host, service );
	    errlog(errbuf);
	    return(PKC_ERROR);
	}
	sinhim.sin_family = hp->h_addrtype;
	memcpy((char *)&sinhim.sin_addr, hp->h_addr, hp->h_length);
    }
    addr = (struct sockaddr *) &sinhim;
    addrlen = sizeof(struct sockaddr_in);

#ifdef HAVE_SYS_UN_H
 ready:
#endif

    if( (netfd = socket(addr->sa_family, SOCK_STREAM, 0)) < 0 )  {
	pkg_perror( errlog, "pkg_open:  client socket" );
	return(PKC_ERROR);
    }

#if defined(TCP_NODELAY)
    /* SunOS 3.x defines it but doesn't support it! */
    if( addr->sa_family == AF_INET ) {
	int	on = 1;
	if( setsockopt( netfd, IPPROTO_TCP, TCP_NODELAY,
			(char *)&on, sizeof(on) ) < 0 )  {
	    pkg_perror( errlog, "pkg_open: setsockopt TCP_NODELAY" );
	}
    }
#endif

    if( connect(netfd, addr, addrlen) < 0 )  {
	pkg_perror( errlog, "pkg_open: client connect" );
#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)closesocket(netfd);
#else
	(void)close(netfd);
#endif
	return(PKC_ERROR);
    }
    return( pkg_makeconn(netfd, switchp, errlog) );
#endif
}

/*
 *  			P K G _ T R A N S E R V E R
 *
 *  Become a one-time server on the open connection.
 *  A client has already called and we have already answered.
 *  This will be a servers starting condition if he was created
 *  by a process like the UNIX inetd.
 *
 *  Returns PKC_ERROR or a pointer to a pkg_conn structure.
 */
struct pkg_conn *
pkg_transerver(const struct pkg_switch *switchp, void (*errlog) (/* ??? */))
{
    pkg_ck_debug();
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_transerver(switchp=x%lx, errlog=x%lx)\n",
		 (long)switchp, (long)errlog );
	fflush(pkg_debug);
    }

    /*
     * XXX - Somehow the system has to know what connection
     * was accepted, it's protocol, etc.  For UNIX/inetd
     * we use stdin.
     */
    return( pkg_makeconn( fileno(stdin), switchp, errlog ) );
}

/*
 *
 * Private implementation
 *
 */
int
_pkg_permserver_impl(struct in_addr iface, const char *service, const char *protocol, int backlog, void (*errlog)(char *msg))
{
    register struct servent *sp;
    int	pkg_listenfd;
#ifdef _WIN32
    SOCKADDR_IN saServer;
#else
    struct sockaddr_in sinme;
#ifdef HAVE_SYS_UN_H
    struct sockaddr_un sunme;		/* UNIX Domain */
#endif
    struct sockaddr *addr;			/* UNIX or INET addr */
    int	addrlen;			/* length of address */
    int	on = 1;
#endif

    pkg_ck_debug();
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_permserver(%s, %s, backlog=%d, errlog=x%lx\n",
		 service, protocol, backlog, (long)errlog );
	fflush(pkg_debug);
    }

    /* Check for default error handler */
    if( errlog == NULL )
	errlog = pkg_errlog;

    /* WIN32 STUFF ========================= */
#ifdef _WIN32
    memset((char *)&saServer, 0, sizeof(saServer));

    if (atoi(service) > 0) {
	saServer.sin_port = htons((unsigned short)atoi(service));
    } else {
	if ((sp = getservbyname(service, "tcp")) == NULL) {
	    snprintf(errbuf, MAX_ERRBUF_SIZE,
		    "pkg_permserver(%s,%d): unknown service\n",
		    service, backlog );
	    errlog(errbuf);
	    return(-1);
	}
	saServer.sin_port = sp->s_port;
    }

    if ((pkg_listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
	pkg_perror(errlog, "pkg_permserver:  socket");
	return(-1);
    }

#if 0
    _setmode(pkg_listenfd, _O_BINARY);
#endif

    saServer.sin_family = AF_INET;
    saServer.sin_addr = iface;

    if (bind(pkg_listenfd, (LPSOCKADDR)&saServer, sizeof(struct sockaddr)) == SOCKET_ERROR) {
	pkg_perror(errlog, "pkg_permserver: bind");
	closesocket(pkg_listenfd);

	return(-1);
    }

    if (backlog > 5)
	backlog = 5;

    if (listen(pkg_listenfd, backlog) == SOCKET_ERROR) {
	pkg_perror(errlog, "pkg_permserver:  listen");
	closesocket(pkg_listenfd);

	return(-1);
    }

    return(pkg_listenfd);
    /* END WIN32 STUFF ========================= */
#else
    memset((char *)&sinme, 0, sizeof(sinme));

#ifdef HAVE_SYS_UN_H
    if( service != NULL && service[0] == '/' ) {
	/* UNIX Domain socket */
	strncpy( sunme.sun_path, service, sizeof(sunme.sun_path) );
	sunme.sun_family = AF_UNIX;
	addr = (struct sockaddr *) &sunme;
	addrlen = strlen(sunme.sun_path) + 2;
	goto ready;
    }
#endif
    /* Determine port for service */
    if( atoi(service) > 0 )  {
	sinme.sin_port = htons((unsigned short)atoi(service));
    } else {
	if( (sp = getservbyname( service, "tcp" )) == NULL )  {
	    snprintf(errbuf, MAX_ERRBUF_SIZE,
		    "pkg_permserver(%s,%d): unknown service\n",
		    service, backlog );
	    errlog(errbuf);
	    return(-1);
	}
	sinme.sin_port = sp->s_port;
    }
    pkg_permport = sinme.sin_port;		/* XXX -- needs formal I/F */
    sinme.sin_family = AF_INET;
    sinme.sin_addr = iface;
    addr = (struct sockaddr *) &sinme;
    addrlen = sizeof(struct sockaddr_in);

#ifdef HAVE_SYS_UN_H
 ready:
#endif

    if( (pkg_listenfd = socket(addr->sa_family, SOCK_STREAM, 0)) < 0 )  {
	pkg_perror( errlog, "pkg_permserver:  socket" );
	return(-1);
    }

    if( addr->sa_family == AF_INET ) {
	if( setsockopt( pkg_listenfd, SOL_SOCKET, SO_REUSEADDR,
			(char *)&on, sizeof(on) ) < 0 )  {
	    pkg_perror( errlog, "pkg_permserver: setsockopt SO_REUSEADDR" );
	}
#if defined(TCP_NODELAY)
	/* SunOS 3.x defines it but doesn't support it! */
	if( setsockopt( pkg_listenfd, IPPROTO_TCP, TCP_NODELAY,
			(char *)&on, sizeof(on) ) < 0 )  {
	    pkg_perror( errlog, "pkg_permserver: setsockopt TCP_NODELAY" );
	}
#endif
    }

    if( bind(pkg_listenfd, addr, addrlen) < 0 )  {
	pkg_perror( errlog, "pkg_permserver: bind" );
#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)closesocket(pkg_listenfd);
#else
	close(pkg_listenfd);
#endif
	return(-1);
    }

    if( backlog > 5 )  backlog = 5;
    if( listen(pkg_listenfd, backlog) < 0 )  {
	pkg_perror( errlog, "pkg_permserver:  listen" );
#if defined(_WIN32) && !defined(__CYGWIN__)
	(void)closesocket(pkg_listenfd);
#else
	close(pkg_listenfd);
#endif
	return(-1);
    }
    return(pkg_listenfd);
#endif
}

/*
 *  			P K G _ P E R M S E R V E R
 *
 *  We are now going to be a server for the indicated service.
 *  Hang a LISTEN, and return the fd to select() on waiting for
 *  new connections.
 *
 *  Returns fd to listen on (>=0), -1 on error.
 */
int
pkg_permserver(const char *service, const char *protocol, int backlog, void (*errlog) (char *msg))
{
    struct in_addr iface;
    iface.s_addr = INADDR_ANY;
    return _pkg_permserver_impl(iface, service, protocol, backlog, errlog);
}

/*
 *  			P K G _ P E R M S E R V E R _ I P
 *
 *  We are now going to be a server for the indicated service.
 *  Hang a LISTEN, and return the fd to select() on waiting for
 *  new connections.
 *
 *  Returns fd to listen on (>=0), -1 on error.
 */
int
pkg_permserver_ip(const char *ipOrHostname, const char *service, const char *protocol, int backlog, void (*errlog)(char *msg))
{
    struct hostent* host;
    struct in_addr iface;
    /* if ipOrHostname starts with a number, it's an IP */
    if (ipOrHostname) {
	if (ipOrHostname[0] >= '0' && ipOrHostname[0] <= '9') {
	    iface.s_addr = inet_addr(ipOrHostname);
	} else {
	    /* XXX gethostbyname is deprecated on Windows */
	    host = gethostbyname(ipOrHostname);
	    iface = *(struct in_addr*)host->h_addr;
	}
	return _pkg_permserver_impl(iface, service, protocol, backlog, errlog);
    } else {
	pkg_perror(errlog, "pkg: ipOrHostname cannot be NULL");
	return -1;
    }
}


/*
 *			P K G _ G E T C L I E N T
 *
 *  Given an fd with a listen outstanding, accept the connection.
 *  When poll == 0, accept is allowed to block.
 *  When poll != 0, accept will not block.
 *
 *  Returns -
 *	>0		ptr to pkg_conn block of new connection
 *	PKC_NULL	accept would block, try again later
 *	PKC_ERROR	fatal error
 */
struct pkg_conn *
pkg_getclient(int fd, const struct pkg_switch *switchp, void (*errlog) (char *msg), int nodelay)
{
    struct sockaddr_in from;
    register int s2;
    unsigned int fromlen = sizeof (from);
    auto int onoff;

    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_getclient(fd=%d, switchp=x%lx, errlog=x%lx, nodelay=%d)\n",
		 fd, (long)switchp, (long)errlog, nodelay );
	fflush(pkg_debug);
    }

    /* Check for default error handler */
    if( errlog == NULL )
	errlog = pkg_errlog;

#ifdef FIONBIO
    if(nodelay)  {
	onoff = 1;
	if( ioctl(fd, FIONBIO, &onoff) < 0 )
	    pkg_perror( errlog, "pkg_getclient: FIONBIO 1" );
    }
#endif
    do  {
#ifdef _WIN32
	s2 = accept(fd, (struct sockaddr *)NULL, NULL);
#else
	s2 = accept(fd, (struct sockaddr *)&from, &fromlen);
#endif
	if (s2 < 0) {
	    if(errno == EINTR)
		continue;
#ifdef _WIN32
	    if(errno == WSAEWOULDBLOCK)
		return(PKC_NULL);
#else
	    if(errno == EWOULDBLOCK)
		return(PKC_NULL);
#endif
	    pkg_perror( errlog, "pkg_getclient: accept" );
	    return(PKC_ERROR);
	}
    }  while( s2 < 0);
#ifdef FIONBIO
    if(nodelay)  {
	onoff = 0;
	if( ioctl(fd, FIONBIO, &onoff) < 0 )
	    pkg_perror( errlog, "pkg_getclient: FIONBIO 2" );
	if( ioctl(s2, FIONBIO, &onoff) < 0 )
	    pkg_perror( errlog, "pkg_getclient: FIONBIO 3");
    }
#endif

    return( pkg_makeconn(s2, switchp, errlog) );
}

/*
 *			P K G _ M A K E C O N N
 *
 *  Internal.
 *  Malloc and initialize a pkg_conn structure.
 *  We have already connected to a client or server on the given
 *  file descriptor.
 *
 *  Returns -
 *	>0		ptr to pkg_conn block of new connection
 *	PKC_ERROR	fatal error
 */
static
struct pkg_conn *
pkg_makeconn(int fd, const struct pkg_switch *switchp, void (*errlog) (char *msg))
{
    register struct pkg_conn *pc;

    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_makeconn(fd=%d, switchp=x%lx, errlog=x%lx)\n",
		 fd, (long)switchp, (long)errlog );
	fflush(pkg_debug);
    }

    /* Check for default error handler */
    if( errlog == NULL )
	errlog = pkg_errlog;

    if( (pc = (struct pkg_conn *)malloc(sizeof(struct pkg_conn)))==PKC_NULL )  {
	pkg_perror(errlog, "pkg_makeconn: malloc failure\n" );
	return(PKC_ERROR);
    }
    memset((char *)pc, 0, sizeof(struct pkg_conn));
    pc->pkc_magic = PKG_MAGIC;
    pc->pkc_fd = fd;
    pc->pkc_switch = switchp;
    pc->pkc_errlog = errlog;
    pc->pkc_left = -1;
    pc->pkc_buf = (char *)0;
    pc->pkc_curpos = (char *)0;
    pc->pkc_strpos = 0;
    pc->pkc_incur = pc->pkc_inend = 0;
    return(pc);
}

/*
 *  			P K G _ C L O S E
 *
 *  Gracefully release the connection block and close the connection.
 */
void
pkg_close(register struct pkg_conn *pc)
{
    PKG_CK(pc);
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_close(pc=x%lx) fd=%d\n",
		 (long)pc, pc->pkc_fd );
	fflush(pkg_debug);
    }

    /* Flush any queued stream output first. */
    if( pc->pkc_strpos > 0 )  {
	(void)pkg_flush( pc );
    }

    if( pc->pkc_buf != (char *)0 )  {
	sprintf(errbuf,"pkg_close(x%lx):  partial input pkg discarded, buf=x%lx\n",
		(long)pc, (long)(pc->pkc_buf));
	pc->pkc_errlog(errbuf);
	(void)free( pc->pkc_buf );
    }
    if( pc->pkc_inbuf != (char *)0 )  {
	(void)free( pc->pkc_inbuf );
	pc->pkc_inbuf = (char *)0;
	pc->pkc_inlen = 0;
    }
#if defined(_WIN32) && !defined(__CYGWIN__)
    (void)closesocket(pc->pkc_fd);
#else
    (void)close(pc->pkc_fd);
#endif
    pc->pkc_fd = -1;		/* safety */
    pc->pkc_buf = (char *)0;	/* safety */
    pc->pkc_magic = 0;		/* safety */
    (void)free( (char *)pc );
}


/*
 *			P K G _ I N G E T
 *
 *  A functional replacement for bu_mread() through the first level
 *  input buffer.
 *
 *  This will block if the required number of bytes are not available.
 *  The number of bytes actually transferred is returned.
 */
int
pkg_inget(register struct pkg_conn *pc, char *buf, int count)
{
    register int	len;
    register int	todo = count;

    while( todo > 0 )  {

	while( (len = pc->pkc_inend - pc->pkc_incur) <= 0 )  {
	    /* This can block */
	    if( pkg_suckin( pc ) < 1 )
		return( count - todo );
	}
	/* Input Buffer has some data in it, move to caller's buffer */
	if( len > todo )  len = todo;
	memcpy(buf, &pc->pkc_inbuf[pc->pkc_incur], len);
	pc->pkc_incur += len;
	buf += len;
	todo -= len;
    }
    return( count );
}


/*
 *  			P K G _ S E N D
 *
 *  Send the user's data, prefaced with an identifying header which
 *  contains a message type value.  All header fields are exchanged
 *  in "network order".
 *
 *  Note that the whole message (header + data) should be transmitted
 *  by TCP with only one TCP_PUSH at the end, due to the use of writev().
 *
 *  Returns number of bytes of user data actually sent.
 */
int
pkg_send(int type, const char *buf, int len, register struct pkg_conn *pc)
{
#ifdef HAVE_WRITEV
    static struct iovec cmdvec[2];
#endif
    static struct pkg_header hdr;
    register int i;

    PKG_CK(pc);
    if( len < 0 )  len=0;

    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_send(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
		 type, (long)buf, len, (long)pc );
	fflush(pkg_debug);
    }

    /* Check for any pending input, no delay */
    /* Input may be read, but not acted upon, to prevent deep recursion */
    pkg_checkin( pc, 1 );

    /* Flush any queued stream output first. */
    if( pc->pkc_strpos > 0 )  {
	/*
	 * Buffered output is already queued, and needs to be
	 * flushed before sending this one.  If this pkg will
	 * also fit in the buffer, add it to the stream, and
	 * then send the whole thing with one flush.
	 * Otherwise, just flush, and proceed.
	 */
	if( len <= MAXQLEN && len <= PKG_STREAMLEN -
	    sizeof(struct pkg_header) - pc->pkc_strpos )  {
	    (void)pkg_stream( type, buf, len, pc );
	    return( (pkg_flush(pc) < 0) ? -1 : len );
	}
	if( pkg_flush( pc ) < 0 )
	    return(-1);	/* assumes 2nd write would fail too */
    }

    pkg_pshort( (char *)hdr.pkh_magic, PKG_MAGIC );
    pkg_pshort( (char *)hdr.pkh_type, type );	/* should see if valid type */
    pkg_plong( (char *)hdr.pkh_len, (unsigned long)len );

#ifdef HAVE_WRITEV
    cmdvec[0].iov_base = (caddr_t)&hdr;
    cmdvec[0].iov_len = sizeof(hdr);
    cmdvec[1].iov_base = (caddr_t)buf;
    cmdvec[1].iov_len = len;

    /*
     * TODO:  set this FD to NONBIO.  If not all output got sent,
     * loop in select() waiting for capacity to go out, and
     * reading input as well.  Prevents deadlocking.
     */
    if( (i = writev( pc->pkc_fd, cmdvec, (len>0)?2:1 )) != len+sizeof(hdr) )  {
	if( i < 0 )  {
	    pkg_perror(pc->pkc_errlog, "pkg_send: writev");
	    return(-1);
	}
	sprintf(errbuf,"pkg_send of %d+%d, wrote %d\n",
		(int)sizeof(hdr), len, i);
	(pc->pkc_errlog)(errbuf);
	return(i-sizeof(hdr));	/* amount of user data sent */
    }
#else
    /*
     *  On the assumption that buffer copying is less expensive than
     *  having this transmission broken into two network packets
     *  (with TCP, each with a "push" bit set),
     *  merge it all into one buffer here, unless size is enormous.
     */
    if( len + sizeof(hdr) <= 16*1024 )  {
	char	tbuf[16*1024] = {0};

	memcpy(tbuf, (char *)&hdr, sizeof(hdr));
	if( len > 0 )
	    memcpy(tbuf+sizeof(hdr), buf, len);
	if( (i = PKG_SEND( pc->pkc_fd, tbuf, len+sizeof(hdr) )) != len+sizeof(hdr) )  {
	    if( i < 0 )  {
		if( errno == EBADF )  return(-1);
		pkg_perror(pc->pkc_errlog, "pkg_send: tbuf write");
		return(-1);
	    }
	    sprintf(errbuf,"pkg_send of %d, wrote %d\n",
		    len, i-(int)sizeof(hdr) );
	    (pc->pkc_errlog)(errbuf);
	    return(i-sizeof(hdr));	/* amount of user data sent */
	}
	return(len);
    }
    /* Send them separately */
    if ((i = PKG_SEND(pc->pkc_fd, (char *)&hdr, sizeof(hdr))) != sizeof(hdr)) {
	if( i < 0 )  {
	    if( errno == EBADF )  return(-1);
	    pkg_perror(pc->pkc_errlog, "pkg_send: header write");
	    return(-1);
	}
	sprintf(errbuf,"pkg_send header of %d, wrote %d\n",
		(int)sizeof(hdr), i);
	(pc->pkc_errlog)(errbuf);
	return(-1);		/* amount of user data sent */
    }
    if( len <= 0 )  return(0);
    if ((i = PKG_SEND(pc->pkc_fd, buf, len)) != len) {
	if( i < 0 )  {
	    if( errno == EBADF )  return(-1);
	    pkg_perror(pc->pkc_errlog, "pkg_send: write");
	    return(-1);
	}
	sprintf(errbuf,"pkg_send of %d, wrote %d\n", len, i);
	(pc->pkc_errlog)(errbuf);
	return(i);		/* amount of user data sent */
    }
#endif
    return(len);
}

/*
 *			P K G _ 2 S E N D
 *
 *  Exactly like pkg_send, except user's data is located in
 *  two disjoint buffers, rather than one.
 *  Fiendishly useful!
 */
int
pkg_2send(int type, char *buf1, int len1, char *buf2, int len2, register struct pkg_conn *pc)
{
#ifdef HAVE_WRITEV
    static struct iovec cmdvec[3];
#endif
    static struct pkg_header hdr;
    register int i;

    PKG_CK(pc);
    if( len1 < 0 )  len1=0;
    if( len2 < 0 )  len2=0;

    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_send2(type=%d, buf1=x%lx, len1=%d, buf2=x%lx, len2=%d, pc=x%lx)\n",
		 type, (long)buf1, len1, (long)buf2, len2, (long)pc );
	fflush(pkg_debug);
    }

    /* Check for any pending input, no delay */
    /* Input may be read, but not acted upon, to prevent deep recursion */
    pkg_checkin( pc, 1 );

    /* Flush any queued stream output first. */
    if( pc->pkc_strpos > 0 )  {
	if( pkg_flush( pc ) < 0 )
	    return(-1);	/* assumes 2nd write would fail too */
    }

    pkg_pshort( (char *)hdr.pkh_magic, PKG_MAGIC );
    pkg_pshort( (char *)hdr.pkh_type, type );	/* should see if valid type */
    pkg_plong( (char *)hdr.pkh_len, (unsigned long)(len1+len2) );

#ifdef HAVE_WRITEV
    cmdvec[0].iov_base = (caddr_t)&hdr;
    cmdvec[0].iov_len = sizeof(hdr);
    cmdvec[1].iov_base = (caddr_t)buf1;
    cmdvec[1].iov_len = len1;
    cmdvec[2].iov_base = (caddr_t)buf2;
    cmdvec[2].iov_len = len2;

    /*
     * TODO:  set this FD to NONBIO.  If not all output got sent,
     * loop in select() waiting for capacity to go out, and
     * reading input as well.  Prevents deadlocking.
     */
    if( (i = writev(pc->pkc_fd, cmdvec, 3)) != len1+len2+sizeof(hdr) )  {
	if( i < 0 )  {
	    pkg_perror(pc->pkc_errlog, "pkg_2send: writev");
	    sprintf( errbuf,
		     "pkg_send2(type=%d, buf1=x%lx, len1=%d, buf2=x%lx, len2=%d, pc=x%lx)\n",
		     type, (unsigned long int)buf1, len1,
		     (unsigned long int)buf2, len2, (unsigned long int)pc );
	    (pc->pkc_errlog)(errbuf);
	    return(-1);
	}
	sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote %d\n",
		(int)sizeof(hdr), len1, len2, i);
	(pc->pkc_errlog)(errbuf);
	return(i-sizeof(hdr));	/* amount of user data sent */
    }
#else
    /*
     *  On the assumption that buffer copying is less expensive than
     *  having this transmission broken into two network packets
     *  (with TCP, each with a "push" bit set),
     *  merge it all into one buffer here, unless size is enormous.
     */
    if( len1 + len2 + sizeof(hdr) <= 16*1024 )  {
	char	tbuf[16*1024] = {0};

	memcpy(tbuf, (char *)&hdr, sizeof(hdr));
	if( len1 > 0 )
	    memcpy(tbuf+sizeof(hdr), buf1, len1);
	if( len2 > 0 )
	    memcpy(tbuf+sizeof(hdr)+len1, buf2, len2);
	if ((i = PKG_SEND(pc->pkc_fd, tbuf, len1+len2+sizeof(hdr))) != len1+len2+sizeof(hdr)) {
	    if( i < 0 )  {
		if( errno == EBADF )  return(-1);
		pkg_perror(pc->pkc_errlog, "pkg_2send: tbuf write");
		return(-1);
	    }
	    sprintf(errbuf,"pkg_2send of %d+%d, wrote %d\n",
		    len1, len2, i-(int)sizeof(hdr) );
	    (pc->pkc_errlog)(errbuf);
	    return(i-sizeof(hdr));	/* amount of user data sent */
	}
	return(len1+len2);
    }
    /* Send it in three pieces */
    if ((i = PKG_SEND(pc->pkc_fd, (char *)&hdr, sizeof(hdr))) != sizeof(hdr)) {
	if( i < 0 )  {
	    if( errno == EBADF )  return(-1);
	    pkg_perror(pc->pkc_errlog, "pkg_2send: header write");
	    sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
		    pc->pkc_fd, (long)&hdr, (int)sizeof(hdr), i );
	    (pc->pkc_errlog)(errbuf);
	    return(-1);
	}
	sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote header=%d\n",
		(int)sizeof(hdr), len1, len2, i );
	(pc->pkc_errlog)(errbuf);
	return(-1);		/* amount of user data sent */
    }
    if ((i = PKG_SEND(pc->pkc_fd, buf1, len1)) != len1) {
	if( i < 0 )  {
	    if( errno == EBADF )  return(-1);
	    pkg_perror(pc->pkc_errlog, "pkg_2send: write buf1");
	    sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
		    pc->pkc_fd, (long)buf1, len1, i );
	    (pc->pkc_errlog)(errbuf);
	    return(-1);
	}
	sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote len1=%d\n",
		(int)sizeof(hdr), len1, len2, i );
	(pc->pkc_errlog)(errbuf);
	return(i);		/* amount of user data sent */
    }
    if( len2 <= 0 )  return(i);
    if ((i = PKG_SEND(pc->pkc_fd, buf2, len2)) != len2) {
	if( i < 0 )  {
	    if( errno == EBADF )  return(-1);
	    pkg_perror(pc->pkc_errlog, "pkg_2send: write buf2");
	    sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
		    pc->pkc_fd, (long)buf2, len2, i );
	    (pc->pkc_errlog)(errbuf);
	    return(-1);
	}
	sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote len2=%d\n",
		(int)sizeof(hdr), len1, len2, i );
	(pc->pkc_errlog)(errbuf);
	return(len1+i);		/* amount of user data sent */
    }
#endif
    return(len1+len2);
}

/*
 *  			P K G _ S T R E A M
 *
 *  Exactly like pkg_send except no "push" is necessary here.
 *  If the packet is sufficiently small (MAXQLEN) it will be placed
 *  in the pkc_stream buffer (after flushing this buffer if there
 *  insufficient room).  If it is larger than this limit, it is sent
 *  via pkg_send (who will do a pkg_flush if there is already data in
 *  the stream queue).
 *
 *  Returns number of bytes of user data actually sent (or queued).
 */
int
pkg_stream(int type, const char *buf, int len, register struct pkg_conn *pc)
{
    static struct pkg_header hdr;

    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_stream(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
		 type, (long)buf, len, (long)pc );
	fflush(pkg_debug);
    }

    if( len > MAXQLEN )
	return( pkg_send(type, buf, len, pc) );

    if( len > PKG_STREAMLEN - sizeof(struct pkg_header) - pc->pkc_strpos )
	pkg_flush( pc );

    /* Queue it */
    pkg_pshort( (char *)hdr.pkh_magic, PKG_MAGIC );
    pkg_pshort( (char *)hdr.pkh_type, type );	/* should see if valid type */
    pkg_plong( (char *)hdr.pkh_len, (unsigned long)len );

    memcpy(&(pc->pkc_stream[pc->pkc_strpos]), (char *)&hdr, sizeof(struct pkg_header));
    pc->pkc_strpos += sizeof(struct pkg_header);
    memcpy(&(pc->pkc_stream[pc->pkc_strpos]), buf, len);
    pc->pkc_strpos += len;

    return( len + sizeof(struct pkg_header) );
}

/*
 *  			P K G _ F L U S H
 *
 *  Flush any pending data in the pkc_stream buffer.
 *
 *  Returns < 0 on failure, else number of bytes sent.
 */
int
pkg_flush(register struct pkg_conn *pc)
{
    register int	i;

    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_flush( pc=x%lx )\n",
		 (long)pc );
	fflush(pkg_debug);
    }

    if( pc->pkc_strpos <= 0 ) {
	pc->pkc_strpos = 0;	/* sanity for < 0 */
	return( 0 );
    }

    if( (i = write(pc->pkc_fd,pc->pkc_stream,pc->pkc_strpos)) != pc->pkc_strpos )  {
	if( i < 0 ) {
	    if( errno == EBADF )  return(-1);
	    pkg_perror(pc->pkc_errlog, "pkg_flush: write");
	    return(-1);
	}
	sprintf(errbuf,"pkg_flush of %d, wrote %d\n",
		pc->pkc_strpos, i);
	(pc->pkc_errlog)(errbuf);
	pc->pkc_strpos -= i;
	/* copy leftovers to front of stream */
	memmove(pc->pkc_stream, pc->pkc_stream + i, pc->pkc_strpos);
	return( i );	/* amount of user data sent */
    }
    pc->pkc_strpos = 0;
    return( i );
}

/*
 *  			P K G _ W A I T F O R
 *
 *  This routine implements a blocking read on the network connection
 *  until a message of 'type' type is received.  This can be useful for
 *  implementing the synchronous portions of a query/reply exchange.
 *  All messages of any other type are processed by pkg_block().
 *
 *  Returns the length of the message actually received, or -1 on error.
 */
int
pkg_waitfor(int type, char *buf, int len, register struct pkg_conn *pc)
{
    register int i;

    PKG_CK(pc);
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_waitfor(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
		 type, (long)buf, len, (long)pc );
	fflush(pkg_debug);
    }
 again:
    if( pc->pkc_left >= 0 )  {
	/* Finish up remainder of partially received message */
	if( pkg_block( pc ) < 0 )
	    return(-1);
    }

    if( pc->pkc_buf != (char *)0 )  {
	pc->pkc_errlog("pkg_waitfor:  buffer clash\n");
	return(-1);
    }
    if( pkg_gethdr( pc, buf ) < 0 )  return(-1);
    if( pc->pkc_type != type )  {
	/* A message of some other type has unexpectedly arrived. */
	if( pc->pkc_len > 0 )  {
	    if( (pc->pkc_buf = (char *)malloc(pc->pkc_len+2)) == NULL )  {
		pkg_perror(pc->pkc_errlog, "pkg_waitfor: malloc failed");
		return(-1);
	    }
	    pc->pkc_curpos = pc->pkc_buf;
	}
	goto again;
    }
    pc->pkc_left = -1;
    if( pc->pkc_len == 0 )
	return(0);

    /* See if incomming message is larger than user's buffer */
    if( pc->pkc_len > len )  {
	register char *bp;
	int excess;
	sprintf(errbuf,
		"pkg_waitfor:  message %ld exceeds buffer %d\n",
		pc->pkc_len, len );
	(pc->pkc_errlog)(errbuf);
	if( (i = pkg_inget( pc, buf, len )) != len )  {
	    sprintf(errbuf,
		    "pkg_waitfor:  pkg_inget %d gave %d\n", len, i );
	    (pc->pkc_errlog)(errbuf);
	    return(-1);
	}
	excess = pc->pkc_len - len;	/* size of excess message */
	if( (bp = (char *)malloc(excess)) == NULL )  {
	    pkg_perror(pc->pkc_errlog, "pkg_waitfor: excess message, malloc failed");
	    return(-1);
	}
	if( (i = pkg_inget( pc, bp, excess )) != excess )  {
	    sprintf(errbuf,
		    "pkg_waitfor: pkg_inget of excess, %d gave %d\n",
		    excess, i );
	    (pc->pkc_errlog)(errbuf);
	    (void)free(bp);
	    return(-1);
	}
	(void)free(bp);
	return(len);		/* truncated, but OK */
    }

    /* Read the whole message into the users buffer */
    if( (i = pkg_inget( pc, buf, pc->pkc_len )) != pc->pkc_len )  {
	sprintf(errbuf,
		"pkg_waitfor:  pkg_inget %ld gave %d\n",
		pc->pkc_len, i );
	(pc->pkc_errlog)(errbuf);
	return(-1);
    }
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_waitfor() message type=%d arrived\n", type);
	fflush(pkg_debug);
    }
    pc->pkc_buf = (char *)0;
    pc->pkc_curpos = (char *)0;
    pc->pkc_left = -1;		/* safety */
    return( pc->pkc_len );
}

/*
 *  			P K G _ B W A I T F O R
 *
 *  This routine implements a blocking read on the network connection
 *  until a message of 'type' type is received.  This can be useful for
 *  implementing the synchronous portions of a query/reply exchange.
 *  All messages of any other type are processed by pkg_block().
 *
 *  The buffer to contain the actual message is acquired via malloc(),
 *  and the caller must free it.
 *
 *  Returns pointer to message buffer, or NULL.
 */
char *
pkg_bwaitfor(int type, register struct pkg_conn *pc)
{
    register int i;
    register char *tmpbuf;

    PKG_CK(pc);
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_bwaitfor(type=%d, pc=x%lx)\n",
		 type, (long)pc );
	fflush(pkg_debug);
    }
    do  {
	/* Finish any unsolicited msg */
	if( pc->pkc_left >= 0 )
	    if( pkg_block(pc) < 0 )
		return((char *)0);
	if( pc->pkc_buf != (char *)0 )  {
	    pc->pkc_errlog("pkg_bwaitfor:  buffer clash\n");
	    return((char *)0);
	}
	if( pkg_gethdr( pc, (char *)0 ) < 0 )
	    return((char *)0);
    }  while( pc->pkc_type != type );

    pc->pkc_left = -1;
    if( pc->pkc_len == 0 )
	return((char *)0);

    /* Read the whole message into the dynamic buffer */
    if( (i = pkg_inget( pc, pc->pkc_buf, pc->pkc_len )) != pc->pkc_len )  {
	sprintf(errbuf,
		"pkg_bwaitfor:  pkg_inget %ld gave %d\n", pc->pkc_len, i );
	(pc->pkc_errlog)(errbuf);
    }
    tmpbuf = pc->pkc_buf;
    pc->pkc_buf = (char *)0;
    pc->pkc_curpos = (char *)0;
    pc->pkc_left = -1;		/* safety */
    /* User must free the buffer */
    return( tmpbuf );
}

/*
 *  			P K G _ P R O C E S S
 *
 *
 *  This routine should be called to process all PKGs that are
 *  stored in the internal buffer pkc_inbuf.  This routine does
 *  no I/O, and is used in a "polling" paradigm.
 *
 *  Only after pkg_process() has been called on all PKG connections
 *  should the user process suspend itself in a select() operation,
 *  otherwise packages that have been read into the internal buffer
 *  will remain unprocessed, potentially forever.
 *
 *  If an error code is returned, then select() must NOT be called
 *  until pkg_process has been called again.
 *
 *  A plausable code sample might be:
 *
 *	for(;;)  {
 *		if( pkg_process( pc ) < 0 )  {
 *			printf("pkg_process error encountered\n");
 *			continue;
 *		}
 *		if( bsdselect( pc->pkc_fd, 99, 0 ) != 0 )  {
 *			if( pkg_suckin( pc ) <= 0 )  {
 *				printf("pkg_suckin error or EOF\n");
 *				break;
 *			}
 *		}
 *		if( pkg_process( pc ) < 0 )  {
 *			printf("pkg_process error encountered\n");
 *			continue;
 *		}
 *		do_other_stuff();
 *	}
 *
 *  Note that the first call to pkg_process() handles all buffered packages
 *  before a potentially long delay in select().
 *  The second call to pkg_process() handles any new packages obtained
 *  either directly by pkg_suckin() or as a byproduct of a handler.
 *  This double checking is absolutely necessary, because
 *  the use of pkg_send() or other pkg routines either in the actual
 *  handlers or in do_other_stuff() can cause pkg_suckin() to be
 *  called to bring in more packages.
 *
 *  Returns -
 *	<0	some internal error encountered; DO NOT call select() next.
 *	 0	All ok, no packages processed
 *	>0	All ok, return is # of packages processed (for the curious)
 */
int
pkg_process(register struct pkg_conn *pc)
{
    register int	len;
    register int	available;
    register int	errcnt;
    register int	ret;
    int		goodcnt;

    goodcnt = 0;

    PKG_CK(pc);
    /* This loop exists only to cut off "hard" errors */
    for( errcnt=0; errcnt < 500; )  {
	available = pc->pkc_inend - pc->pkc_incur;	/* amt in input buf */
	if( pkg_debug )  {
	    if( pc->pkc_left < 0 )  {
		sprintf(errbuf, "awaiting new header");
	    } else if( pc->pkc_left > 0 )  {
		sprintf(errbuf, "need more data");
	    } else {
		sprintf(errbuf, "pkg is all here");
	    }
	    pkg_timestamp();
	    fprintf( pkg_debug,
		     "pkg_process(pc=x%lx) pkc_left=%d %s (avail=%d)\n",
		     (long)pc, pc->pkc_left, errbuf, available );
	    fflush(pkg_debug);
	}
	if( pc->pkc_left < 0 )  {
	    /*
	     *  Need to get a new PKG header.
	     *  Do so ONLY if the full header is already in the
	     *  internal buffer, to prevent blocking in pkg_gethdr().
	     */
	    if( available < sizeof(struct pkg_header) )
		break;

	    if( pkg_gethdr( pc, (char *)0 ) < 0 )  {
		DMSG("pkg_gethdr < 0\n");
		errcnt++;
		continue;
	    }

	    if( pc->pkc_left < 0 )  {
		/* pkg_gethdr() didn't get a header */
		DMSG("pkc_left still < 0 after pkg_gethdr()\n");
		errcnt++;
		continue;
	    }
	}
	/*
	 *  Now pkc_left >= 0, implying header has been obtained.
	 *  Find amount still available in input buffer.
	 */
	available = pc->pkc_inend - pc->pkc_incur;

	/* copy what is here already, and dispatch when all here */
	if( pc->pkc_left > 0 )  {
	    if( available <= 0 )  break;

	    /* Sanity check -- buffer must be allocated by now */
	    if( pc->pkc_curpos == 0 )  {
		DMSG("curpos=0\n");
		errcnt++;
		continue;
	    }

	    if( available > pc->pkc_left )  {
		/* There is more in input buf than just this pkg */
		len = pc->pkc_left; /* trim to amt needed */
	    } else {
		/* Take all that there is */
		len = available;
	    }
	    len = pkg_inget( pc, pc->pkc_curpos, len );
	    pc->pkc_curpos += len;
	    pc->pkc_left -= len;
	    if( pc->pkc_left > 0 )  {
		/*
		 *  Input buffer is exhausted, but more
		 *  data is needed to finish this package.
		 */
		break;
	    }
	}

	if( pc->pkc_left != 0 )  {
	    /* Somehow, a full PKG has not yet been obtained */
	    DMSG("pkc_left != 0\n");
	    errcnt++;
	    continue;
	}

	/* Now, pkc_left == 0, dispatch the message */
	if( pkg_dispatch(pc) <= 0 )  {
	    /* something bad happened */
	    DMSG("pkg_dispatch failed\n");
	    errcnt++;
	} else {
	    /* it worked */
	    goodcnt++;
	}
    }

    if( errcnt > 0 )  {
	ret = -errcnt;
    } else {
	ret = goodcnt;
    }

    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_process() ret=%d, pkc_left=%d, errcnt=%d, goodcnt=%d\n",
		 ret, pc->pkc_left, errcnt, goodcnt);
	fflush(pkg_debug);
    }
    return( ret );
}

/*
 *			P K G _ D I S P A T C H
 *
 *  Internal.
 *  Given that a whole message has arrived, send it to the appropriate
 *  User Handler, or else grouse.
 *  Returns -1 on fatal error, 0 on no handler, 1 if all's well.
 */
static int
pkg_dispatch(register struct pkg_conn *pc)
{
    register int i;

    PKG_CK(pc);
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_dispatch(pc=x%lx) type=%d, buf=x%lx, len=%ld\n",
		 (long)pc, pc->pkc_type, (long)(pc->pkc_buf), pc->pkc_len );
	fflush(pkg_debug);
    }
    if( pc->pkc_left != 0 )  return(-1);

    /* Whole message received, process it via switchout table */
    for( i=0; pc->pkc_switch[i].pks_handler != NULL; i++ )  {
	register char *tempbuf;

	if( pc->pkc_switch[i].pks_type != pc->pkc_type )
	    continue;
	/*
	 * NOTICE:  User Handler must free() message buffer!
	 * WARNING:  Handler may recurse back to pkg_suckin() --
	 * reset all connection state variables first!
	 */
	tempbuf = pc->pkc_buf;
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
	pc->pkc_left = -1;		/* safety */
	/* pc->pkc_type, pc->pkc_len are preserved for handler */
	pc->pkc_switch[i].pks_handler(pc, tempbuf);
	return(1);
    }
    sprintf(errbuf,"pkg_dispatch:  no handler for message type %d, len %ld\n",
	    pc->pkc_type, pc->pkc_len );
    (pc->pkc_errlog)(errbuf);
    (void)free(pc->pkc_buf);
    pc->pkc_buf = (char *)0;
    pc->pkc_curpos = (char *)0;
    pc->pkc_left = -1;		/* safety */
    return(0);
}
/*
 *			P K G _ G E T H D R
 *
 *  Internal.
 *  Get header from a new message.
 *  Returns:
 *	1	when there is some message to go look at
 *	-1	on fatal errors
 */
static int
pkg_gethdr(register struct pkg_conn *pc, char *buf)
{
    register int i;

    PKG_CK(pc);
    if( pc->pkc_left >= 0 )  return(1);	/* go get it! */

    /*
     *  At message boundary, read new header.
     *  This will block until the new header arrives (feature).
     */
    if( (i = pkg_inget( pc, (char *)&(pc->pkc_hdr),
			sizeof(struct pkg_header) )) != sizeof(struct pkg_header) )  {
	if(i > 0) {
	    sprintf(errbuf,"pkg_gethdr: header read of %d?\n", i);
	    (pc->pkc_errlog)(errbuf);
	}
	return(-1);
    }
    while( pkg_gshort((char *)pc->pkc_hdr.pkh_magic) != PKG_MAGIC )  {
	int	c;
	c = *((unsigned char *)&pc->pkc_hdr);
	if( isascii(c) && isprint(c) )  {
	    sprintf(errbuf,
		    "pkg_gethdr: skipping noise x%x %c\n",
		    c, c );
	} else {
	    sprintf(errbuf,
		    "pkg_gethdr: skipping noise x%x\n",
		    c );
	}
	(pc->pkc_errlog)(errbuf);
	/* Slide over one byte and try again */
	memmove((char *)&pc->pkc_hdr, ((char *)&pc->pkc_hdr)+1, sizeof(struct pkg_header)-1);
	if( (i=pkg_inget( pc,
			  ((char *)&pc->pkc_hdr)+sizeof(struct pkg_header)-1,
			  1 )) != 1 )  {
	    sprintf(errbuf,"pkg_gethdr: hdr read=%d?\n",i);
	    (pc->pkc_errlog)(errbuf);
	    return(-1);
	}
    }
    pc->pkc_type = pkg_gshort((char *)pc->pkc_hdr.pkh_type);	/* host order */
    pc->pkc_len = pkg_glong((char *)pc->pkc_hdr.pkh_len);
    if( pc->pkc_len < 0 )  pc->pkc_len = 0;
    pc->pkc_buf = (char *)0;
    pc->pkc_left = pc->pkc_len;
    if( pc->pkc_left == 0 )  return(1);		/* msg here, no data */

    if( buf )  {
	pc->pkc_buf = buf;
    } else {
	/* Prepare to read message into dynamic buffer */
	if( (pc->pkc_buf = (char *)malloc(pc->pkc_len+2)) == NULL )  {
	    pkg_perror(pc->pkc_errlog, "pkg_gethdr: malloc fail");
	    return(-1);
	}
    }
    pc->pkc_curpos = pc->pkc_buf;
    return(1);			/* something ready */
}

/*
 *  			P K G _ B L O C K
 *
 *  This routine blocks, waiting for one complete message to arrive from
 *  the network.  The actual handling of the message is done with
 *  pkg_dispatch(), which invokes the user-supplied message handler.
 *
 *  This routine can be used in a loop to pass the time while waiting
 *  for a flag to be changed by the arrival of an asynchronous message,
 *  or for the arrival of a message of uncertain type.
 *
 *  The companion routine is pkg_process(), which does not block.
 *
 *  Control returns to the caller after one full message is processed.
 *  Returns -1 on error, etc.
 */
int
pkg_block(register struct pkg_conn *pc)
{
    PKG_CK(pc);
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_block(pc=x%lx)\n",
		 (long)pc );
	fflush(pkg_debug);
    }

    /* If no read operation going now, start one. */
    if( pc->pkc_left < 0 )  {
	if( pkg_gethdr( pc, (char *)0 ) < 0 )  return(-1);
	/* Now pkc_left >= 0 */
    }

    /* Read the rest of the message, blocking if necessary */
    if( pc->pkc_left > 0 )  {
	if( pkg_inget( pc, pc->pkc_curpos, pc->pkc_left ) != pc->pkc_left )  {
	    pc->pkc_left = -1;
	    return(-1);
	}
	pc->pkc_left = 0;
    }

    /* Now, pkc_left == 0, dispatch the message */
    return( pkg_dispatch(pc) );
}


/*
 *			P K G _ P E R R O R
 *
 *  Produce a perror on the error logging output.
 */
static void
pkg_perror(void (*errlog) (char *msg), char *s)
{
    snprintf( errbuf, MAX_ERRBUF_SIZE, "%s: ", s);

    if ( errno >= 0 || strlen(errbuf) >= MAX_ERRBUF_SIZE) {
	snprintf( errbuf, MAX_ERRBUF_SIZE, "%s: errno=%d\n", s, errno );
	errlog( errbuf );
	return;
    }

    snprintf( errbuf, MAX_ERRBUF_SIZE, "%s: %s\n", s, strerror(errno) );
    errlog( errbuf );
}

/*
 *			P K G _ E R R L O G
 *
 *  Default error logger.  Writes to stderr.
 */
static void
pkg_errlog(char *s)
{
    if( pkg_debug )  {
	pkg_timestamp();
	fputs( s, pkg_debug );
	fflush(pkg_debug);
    }
    fputs( s, stderr );
}

/*
 *			P K G _ C K _ D E B U G
 */
static void
pkg_ck_debug(void)
{
    char	*place;
    char	buf[128] = {0};
    struct stat sbuf;

    if( pkg_debug )  return;
    if( (place = (char *)getenv("LIBPKG_DEBUG")) == (char *)0 )  {
	sprintf( buf, "/tmp/pkg.log" );
	place = buf;
    }
    /* Named file must exist and be writeable */
    if( stat( place, &sbuf ) != 0 ) return;
    if( (pkg_debug = fopen( place, "a" )) == NULL )  return;

    /* Log version number of this code */
    pkg_timestamp();
#ifndef lint
    fprintf( pkg_debug, "pkg_ck_debug %s\n", RCSid );
#endif
}

/*
 *			P K G _ T I M E S T A M P
 *
 *  Output a timestamp to the log, suitable for starting each line with.
 */
static void
pkg_timestamp(void)
{
    time_t		now;
    struct tm	*tmp;

    if( !pkg_debug )  return;
    (void)time( &now );
    tmp = localtime( &now );
    fprintf(pkg_debug, "%2.2d/%2.2d %2.2d:%2.2d:%2.2d [%5d] ",
	    tmp->tm_mon+1, tmp->tm_mday,
	    tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
	    /* avoid libbu dependency */
#ifdef HAVE_UNISTD_H
	    getpid()
#else
	    (int)GetCurrentProcessId()
#endif
	    );
    /* Don't fflush here, wait for rest of line */
}

/*
 *			P K G _ S U C K I N
 *
 *  Suck all data from the operating system into the internal buffer.
 *  This is done with large buffers, to maximize the efficiency of the
 *  data transfer from kernel to user.
 *
 *  It is expected that the read() system call will return as much
 *  data as the kernel has, UP TO the size indicated.
 *  The only time the read() may be expected to block is when the
 *  kernel does not have any data at all.
 *  Thus, it is wise to call call this routine only if:
 *	a)  select() has indicated the presence of data, or
 *	b)  blocking is acceptable.
 *
 *  This routine is the only place where data is taken off the network.
 *  All input is appended to the internal buffer for later processing.
 *
 *  Subscripting was used for pkc_incur/pkc_inend to avoid having to
 *  recompute pointers after a realloc().
 *
 *  Returns -
 *	-1	on error
 *	 0	on EOF
 *	 1	success
 */
int
pkg_suckin(register struct pkg_conn *pc)
{
    int	avail;
    int	got;
    int	ret;

    got = 0;
    PKG_CK(pc);

    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_suckin() incur=%d, inend=%d, inlen=%d\n",
		 pc->pkc_incur, pc->pkc_inend, pc->pkc_inlen );
	fflush(pkg_debug);
    }

    /* If no buffer allocated yet, get one */
    if( pc->pkc_inbuf == (char *)0 || pc->pkc_inlen <= 0 )  {
	pc->pkc_inlen = PKG_STREAMLEN;
	if( (pc->pkc_inbuf = (char *)malloc(pc->pkc_inlen)) == (char *)0 )  {
	    pc->pkc_errlog("pkg_suckin malloc failure\n");
	    pc->pkc_inlen = 0;
	    ret = -1;
	    goto out;
	}
	pc->pkc_incur = pc->pkc_inend = 0;
    }

    if( pc->pkc_incur >= pc->pkc_inend )  {
	/* Reset to beginning of buffer */
	pc->pkc_incur = pc->pkc_inend = 0;
    }

    /* If cur point is near end of buffer, recopy data to buffer front */
    if( pc->pkc_incur >= (pc->pkc_inlen * 7) / 8 )  {
	register int	ammount;

	ammount = pc->pkc_inend - pc->pkc_incur;
	/* This copy can not overlap itself, because of 7/8 above */
	memcpy(pc->pkc_inbuf, &pc->pkc_inbuf[pc->pkc_incur], ammount);
	pc->pkc_incur = 0;
	pc->pkc_inend = ammount;
    }

    /* If remaining buffer space is small, make buffer bigger */
    avail = pc->pkc_inlen - pc->pkc_inend;
    if( avail < 10 * sizeof(struct pkg_header) )  {
	pc->pkc_inlen <<= 1;
	if( pkg_debug)  {
	    pkg_timestamp();
	    fprintf(pkg_debug,
		    "pkg_suckin: realloc inbuf to %d\n",
		    pc->pkc_inlen );
	    fflush(pkg_debug);
	}
	if( (pc->pkc_inbuf = (char *)realloc(pc->pkc_inbuf, pc->pkc_inlen)) == (char *)0 )  {
	    pc->pkc_errlog("pkg_suckin realloc failure\n");
	    pc->pkc_inlen = 0;
	    ret = -1;
	    goto out;
	}
	/* since the input buffer has grown, lets update avail */
	avail = pc->pkc_inlen - pc->pkc_inend;
    }

    /* Take as much as the system will give us, up to buffer size */
    if( (got = PKG_READ( pc->pkc_fd, &pc->pkc_inbuf[pc->pkc_inend], avail )) <= 0 )  {
#if defined(_WIN32) && !defined(__CYGWIN__)
	int ecode = WSAGetLastError();
	
#endif
	if( got == 0 )  {
	    if( pkg_debug )  {
		pkg_timestamp();
		fprintf(pkg_debug,
			"pkg_suckin: fd=%d, read for %d returned 0\n",
			avail, pc->pkc_fd );
		fflush(pkg_debug);
	    }
	    ret = 0;	/* EOF */
	    goto out;
	}
#ifndef _WIN32
	pkg_perror(pc->pkc_errlog, "pkg_suckin: read");
	sprintf(errbuf, "pkg_suckin: read(%d, x%lx, %d) ret=%d inbuf=x%lx, inend=%d\n",
		pc->pkc_fd, (long)(&pc->pkc_inbuf[pc->pkc_inend]), avail,
		got,
		(long)(pc->pkc_inbuf), pc->pkc_inend );
	(pc->pkc_errlog)(errbuf);
#endif
	ret = -1;
	goto out;
    }
    if( got > avail )  {
	pc->pkc_errlog("pkg_suckin:  read more bytes than desired\n");
	got = avail;
    }
    pc->pkc_inend += got;
    ret = 1;
 out:
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf( pkg_debug,
		 "pkg_suckin() ret=%d, got %d, total=%d\n",
		 ret, got, pc->pkc_inend - pc->pkc_incur );
	fflush(pkg_debug);
    }
    return(ret);
}

/*
 *			P K G _ C H E C K I N
 *
 *  This routine is called whenever it is necessary to see if there
 *  is more input that can be read.
 *  If input is available, it is read into pkc_inbuf[].
 *  If nodelay is set, poll without waiting.
 */
static void
pkg_checkin(register struct pkg_conn *pc, int nodelay)
{
    struct timeval	tv;
    fd_set		bits;
    register int	i, j;
    extern int	errno;

    /* Check socket for unexpected input */
    tv.tv_sec = 0;
    if( nodelay )
	tv.tv_usec = 0;		/* poll -- no waiting */
    else
	tv.tv_usec = 20000;	/* 20 ms */

    FD_ZERO(&bits);
    FD_SET(pc->pkc_fd, &bits);
    i = select( pc->pkc_fd+1, &bits, (fd_set *)0, (fd_set *)0, &tv );
    if( pkg_debug )  {
	pkg_timestamp();
	fprintf(pkg_debug,
		"pkg_checkin: select on fd %d returned %d\n",
		pc->pkc_fd,
		i );
	fflush(pkg_debug);
    }
    if( i > 0 )  {
	for( j = 0; j < FD_SETSIZE; j++ )
	    if( FD_ISSET( j, &bits ) ) break;

	if( j < FD_SETSIZE )  {
	    /* Some fd is ready for I/O */
	    (void)pkg_suckin(pc);
	} else {
	    /* Odd condition, bits! */
	    sprintf(errbuf,
		    "pkg_checkin: select returned %d, bits=0\n",
		    i );
	    (pc->pkc_errlog)(errbuf);
	}
    } else if( i < 0 )  {
	/* Error condition */
	if( errno != EINTR && errno != EBADF )
	    pkg_perror(pc->pkc_errlog, "pkg_checkin: select");
    }
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.52
log
@convert all bzero calls to memset
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.51 2007/12/15 20:13:58 brlcad Exp $ (BRL)";
d378 1
a378 1
	bcopy(hp->h_addr, (char *)&sinhim.sin_addr, hp->h_length);
d844 1
a844 1
	bcopy( &pc->pkc_inbuf[pc->pkc_incur], buf, len );
d942 1
a942 1
	bcopy( (char *)&hdr, tbuf, sizeof(hdr) );
d944 1
a944 1
	    bcopy( buf, tbuf+sizeof(hdr), len );
d1065 1
a1065 1
	bcopy( (char *)&hdr, tbuf, sizeof(hdr) );
d1067 1
a1067 1
	    bcopy( buf1, tbuf+sizeof(hdr), len1 );
d1069 1
a1069 1
	    bcopy( buf2, tbuf+sizeof(hdr)+len1, len2 );
d1167 1
a1167 2
    bcopy( (char *)&hdr, &(pc->pkc_stream[pc->pkc_strpos]),
	   sizeof(struct pkg_header) );
d1169 1
a1169 1
    bcopy( buf, &(pc->pkc_stream[pc->pkc_strpos]), len );
d1211 1
a1211 1
	bcopy(pc->pkc_stream + i, pc->pkc_stream, pc->pkc_strpos);
d1642 1
a1642 1
	bcopy( ((char *)&pc->pkc_hdr)+1, (char *)&pc->pkc_hdr, sizeof(struct pkg_header)-1);
d1875 1
a1875 2
	bcopy( &pc->pkc_inbuf[pc->pkc_incur],
	       pc->pkc_inbuf, ammount );
@


14.51
log
@get rid of our single use of strerror_r, minimize checks
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.50 2007/12/15 08:44:39 brlcad Exp $ (BRL)";
d312 1
a312 1
    bzero((char *)&saServer, sizeof(saServer));
d337 2
a338 2
    bzero((char *)&sinhim, sizeof(sinhim));
    bzero((char *)&sinme, sizeof(sinme));
d483 1
a483 1
    bzero((char *)&saServer, sizeof(saServer));
d530 1
a530 1
    bzero((char *)&sinme, sizeof(sinme));
d762 1
a762 1
    bzero( (char *)pc, sizeof(struct pkg_conn) );
@


14.50
log
@strerror is c89, and does work on windows at least with vc8 so drop the obsolete and error-prone sys_errlist array alternates and configure check
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.49 2007/12/07 07:03:19 brlcad Exp $ (BRL)";
a1735 5
#if HAVE_STRERROR_R
    if (strerror_r(errno, errbuf+strlen(errbuf), MAX_ERRBUF_SIZE-strlen(errbuf)) != 0) {
	snprintf(errbuf, MAX_ERRBUF_SIZE, "%s: errno=%d\n", s, errno);
    }
#else
a1736 1
#endif
@


14.49
log
@use stat() instead of access() (and it's a c89 function)
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.48 2007/12/01 21:47:12 brlcad Exp $ (BRL)";
a1740 1
#  if HAVE_STRERROR
a1741 3
#  else
    snprintf( errbuf, MAX_ERRBUF_SIZE, "%s: %s\n", s, sys_errlist[errno] );
#  endif
@


14.48
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.47 2007/11/08 19:48:43 bob1961 Exp $ (BRL)";
d72 6
d1774 1
d1782 1
a1782 1
    if( access( place, 2 ) < 0 )  return;
@


14.47
log
@If windows call closesocket() instead of close(). Mods to use PKG_SEND with the proper number of parameters. Mods to have pkg_open() return the correct type on error.
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.46 2007/11/05 04:38:18 brlcad Exp $ (BRL)";
d159 1
a159 1
			sprintf(errbuf,"%s: bad pointer x%lx line %d\n",__FILE__, (long)(p), __LINE__);\
d166 1
a166 1
#  define DMSG(s) if(pkg_debug) {pkg_timestamp(); fprintf(pkg_debug,s); fflush(pkg_debug);}
d313 1
a313 1
	    sprintf(errbuf,"pkg_open(%s,%s): unknown service\n",
d351 1
a351 1
	    sprintf(errbuf,"pkg_open(%s,%s): unknown service\n",
d366 1
a366 1
	    sprintf(errbuf,"pkg_open(%s,%s): unknown host\n",
d483 1
a483 1
	    sprintf(errbuf,
d541 1
a541 1
	    sprintf(errbuf,
d1722 1
a1722 1
    sprintf( errbuf, "%s: ", s);
d1725 1
a1725 1
	sprintf( errbuf, "%s: errno=%d\n", s, errno );
d1732 1
a1732 1
	sprintf(errbuf, "%s: errno=%d\n", s, errno);
d1736 1
a1736 1
    sprintf( errbuf, "%s: %s\n", s, strerror(errno) );
d1738 1
a1738 1
    sprintf( errbuf, "%s: %s\n", s, sys_errlist[errno] );
@


14.46
log
@use the feature-specific HAVE_WINSOCK_H header define instead of platform-specific defines
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.45 2007/09/18 15:02:32 erikgreenwald Exp $ (BRL)";
d294 1
a294 1
	return(-1);
d299 1
a299 1
	return(-1);
d326 1
a326 1
	return(-1);
d399 5
a403 1
	close(netfd);
d580 3
d584 1
d591 3
d595 1
d802 3
d806 1
d953 1
a953 1
    if ((i = PKG_SEND(pc->pkc_fd, (char *)&hdr, sizeof(hdr), 0)) != sizeof(hdr)) {
d965 1
a965 1
    if ((i = PKG_SEND(pc->pkc_fd, buf, len, 0)) != len) {
d1064 1
a1064 1
	if ((i = PKG_SEND(pc->pkc_fd, tbuf, len1+len2+sizeof(hdr), 0)) != len1+len2+sizeof(hdr)) {
d1078 1
a1078 1
    if ((i = PKG_SEND(pc->pkc_fd, (char *)&hdr, sizeof(hdr), 0)) != sizeof(hdr)) {
d1092 1
a1092 1
    if ((i = PKG_SEND(pc->pkc_fd, buf1, len1, 0)) != len1) {
d1107 1
a1107 1
    if ((i = PKG_SEND(pc->pkc_fd, buf2, len2, 0)) != len2) {
d1908 4
@


14.45
log
@mark the send buffers as const
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.44 2007/09/15 16:23:11 brlcad Exp $ (BRL)";
d73 1
a73 1
#if defined(HAVE_WINSOCK_H) && !defined(__CYGWIN__)
@


14.44
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.43 2007/09/15 03:41:58 brlcad Exp $ (BRL)";
d844 1
a844 1
pkg_send(int type, char *buf, int len, register struct pkg_conn *pc)
d1122 1
a1122 1
pkg_stream(int type, char *buf, int len, register struct pkg_conn *pc)
@


14.43
log
@no longer need to conditionally check for time.h (or stddef.h) prior to use per c89
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.42 2007/05/12 22:24:26 brlcad Exp $ (BRL)";
d64 1
a86 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.42
log
@add GetCurrentProcessId() towards having the right value on windows, while avoiding making libbu a dependency still
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.41 2007/03/02 20:51:05 erikgreenwald Exp $ (BRL)";
d63 1
a71 4
#ifdef HAVE_TIME_H
#  include <time.h>
#endif

@


14.41
log
@don't use winsock if building on cygwin, stick with UNIX style
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.40 2007/01/27 01:41:38 brlcad Exp $ (BRL)";
d1793 7
a1799 1
	    getpid() );
@


14.40
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.39 2007/01/23 01:13:36 brlcad Exp $ (BRL)";
d75 1
a75 1
#ifdef HAVE_WINSOCK_H
@


14.39
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.38 2007/01/20 14:36:53 brlcad Exp $ (BRL)";
d183 1
a183 1
    
d464 1
a464 1
    
d473 1
a473 1
    
d477 1
a477 1
    
d481 1
a481 1
    
d503 1
a503 1
    
d506 1
a506 1
    
d510 1
a510 1
	
d513 1
a513 1
    
d516 1
a516 1
    
d520 1
a520 1
	
d523 1
a523 1
    
d526 1
a526 1
#else 
d528 1
a528 1
	
d623 1
a623 1
int 
@


14.38
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d55 1
a55 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.37 2006/10/30 16:33:03 jlowenz Exp $ (BRL)";
@


14.37
log
@added const string parameters (because they should be const)
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.36 2006/08/29 21:32:56 brlcad Exp $ (BRL)";
@


14.36
log
@forgot to enclose macro params in parens
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.35 2006/08/29 21:27:25 brlcad Exp $ (BRL)";
d450 1
a450 1
_pkg_permserver_impl(struct in_addr iface, char *service, char *protocol, int backlog, void (*errlog)(char *msg))
d608 1
a608 1
pkg_permserver(char *service, char *protocol, int backlog, void (*errlog) (char *msg))
d625 1
a625 1
pkg_permserver_ip(char *ipOrHostname, char *service, char *protocol, int backlog, void (*errlog)(char *msg))
@


14.35
log
@get rid of the _WIN32 sections for recv/send instead of read/write .. this really shouldn't be necessary if the compatibility macros in the config_win.h header are specified correctly, but for now keep it as it is just without all the repetition by using macros that call the corresponding routine.  oh yeah, and M-x indent-region ws too.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.34 2006/08/29 20:55:13 brlcad Exp $ (BRL)";
d128 2
a129 2
#  define PKG_READ(d, buf, nbytes) recv(d, buf, nbytes, 0)
#  define PKG_SEND(d, buf, nbytes) send(d, buf, nbytes, 0)
d131 2
a132 2
#  define PKG_READ(d, buf, nbytes) read(d, buf, nbytes)
#  define PKG_SEND(d, buf, nbytes) write(d, buf, nbytes)
@


14.34
log
@minor, consolidate return
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.33 2006/08/29 20:06:30 bob1961 Exp $ (BRL)";
d124 11
d213 2
a214 2
	register unsigned char *p = (unsigned char *)buf;
	register unsigned short u;
d216 2
a217 2
	u = *p++ << 8;
	return ((unsigned short)(u | *p));
d226 2
a227 2
	register unsigned char *p = (unsigned char *)buf;
	register unsigned long u;
d229 4
a232 4
	u = *p++; u <<= 8;
	u |= *p++; u <<= 8;
	u |= *p++; u <<= 8;
	return (u | *p);
d241 3
a243 3
	buf[1] = s;
	buf[0] = s >> 8;
	return((char *)buf+2);
d252 5
a256 5
	buf[3] = l;
	buf[2] = (l >>= 8);
	buf[1] = (l >>= 8);
	buf[0] = l >> 8;
	return((char *)buf+4);
d270 3
a272 3
	LPHOSTENT lpHostEntry;
	register SOCKET netfd;
	SOCKADDR_IN saServer;
d274 2
a275 2
	struct sockaddr_in sinme;		/* Client */
	struct sockaddr_in sinhim;		/* Server */
d277 1
a277 1
	struct sockaddr_un sunhim;		/* Server, UNIX Domain */
d279 4
a282 4
	register struct hostent *hp;
	register int netfd;
	struct	sockaddr *addr;			/* UNIX or INET addr */
	int	addrlen;			/* length of address */
d285 9
a293 9
	pkg_ck_debug();
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_open(%s, %s, %s, %s, (passwd), switchp=x%lx, errlog=x%lx)\n",
			host, service, protocol, uname,
			(long)switchp, (long)errlog );
		fflush(pkg_debug);
	}
d295 3
a297 3
	/* Check for default error handler */
	if( errlog == NULL )
		errlog = pkg_errlog;
d300 4
a303 4
	if ((lpHostEntry = gethostbyname(host)) == NULL) {
	    pkg_perror(errlog, "pkg_open:  gethostbyname");
	    return(-1);
	}
d305 4
a308 4
	if ((netfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
	    pkg_perror(errlog, "pkg_open:  socket");
	    return(-1);
	}
d311 1
a311 1
	_setmode(netfd, _O_BINARY);
d314 1
a314 1
	bzero((char *)&saServer, sizeof(saServer));
d316 9
a324 11
	if (atoi(service) > 0) {
	    saServer.sin_port = htons((unsigned short)atoi(service));
	} else {
	    register struct servent *sp;
	    if ((sp = getservbyname(service, "tcp")) == NULL) {
		sprintf(errbuf,"pkg_open(%s,%s): unknown service\n",
			host, service );
		errlog(errbuf);
		return(PKC_ERROR);
	    }
	    saServer.sin_port = sp->s_port;
d326 4
a329 2
	saServer.sin_family = AF_INET;
	saServer.sin_addr = *((LPIN_ADDR)*lpHostEntry->h_addr_list);
d331 5
a335 5
	if (connect(netfd, (LPSOCKADDR)&saServer, sizeof(struct sockaddr)) == SOCKET_ERROR) {
	    pkg_perror(errlog, "pkg_open:  client connect");
	    closesocket(netfd);
	    return(-1);
	}
d337 1
a337 1
	return(pkg_makeconn(netfd, switchp, errlog));
d339 2
a340 2
	bzero((char *)&sinhim, sizeof(sinhim));
	bzero((char *)&sinme, sizeof(sinme));
d343 8
a350 8
	if( host == NULL || strlen(host) == 0 || strcmp(host,"unix") == 0 ) {
		/* UNIX Domain socket, port = pathname */
		sunhim.sun_family = AF_UNIX;
		strncpy( sunhim.sun_path, service, sizeof(sunhim.sun_path) );
		addr = (struct sockaddr *) &sunhim;
		addrlen = strlen(sunhim.sun_path) + 2;
		goto ready;
	}
d353 10
a362 12
	/* Determine port for service */
	if( atoi(service) > 0 )  {
		sinhim.sin_port = htons((unsigned short)atoi(service));
	} else {
		register struct servent *sp;
		if( (sp = getservbyname( service, "tcp" )) == NULL )  {
			sprintf(errbuf,"pkg_open(%s,%s): unknown service\n",
				host, service );
			errlog(errbuf);
			return(PKC_ERROR);
		}
		sinhim.sin_port = sp->s_port;
d364 2
d367 11
a377 14
	/* Get InterNet address */
	if( atoi( host ) > 0 )  {
		/* Numeric */
		sinhim.sin_family = AF_INET;
		sinhim.sin_addr.s_addr = inet_addr(host);
	} else {
		if( (hp = gethostbyname(host)) == NULL )  {
			sprintf(errbuf,"pkg_open(%s,%s): unknown host\n",
				host, service );
			errlog(errbuf);
			return(PKC_ERROR);
		}
		sinhim.sin_family = hp->h_addrtype;
		bcopy(hp->h_addr, (char *)&sinhim.sin_addr, hp->h_length);
d379 5
a383 2
	addr = (struct sockaddr *) &sinhim;
	addrlen = sizeof(struct sockaddr_in);
d386 1
a386 1
ready:
d389 4
a392 4
	if( (netfd = socket(addr->sa_family, SOCK_STREAM, 0)) < 0 )  {
		pkg_perror( errlog, "pkg_open:  client socket" );
		return(PKC_ERROR);
	}
d395 6
a400 7
	/* SunOS 3.x defines it but doesn't support it! */
	if( addr->sa_family == AF_INET ) {
		int	on = 1;
		if( setsockopt( netfd, IPPROTO_TCP, TCP_NODELAY,
		    (char *)&on, sizeof(on) ) < 0 )  {
			pkg_perror( errlog, "pkg_open: setsockopt TCP_NODELAY" );
		}
d402 1
d405 6
a410 6
	if( connect(netfd, addr, addrlen) < 0 )  {
		pkg_perror( errlog, "pkg_open: client connect" );
		close(netfd);
		return(PKC_ERROR);
	}
	return( pkg_makeconn(netfd, switchp, errlog) );
d427 8
a434 8
	pkg_ck_debug();
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_transerver(switchp=x%lx, errlog=x%lx)\n",
			(long)switchp, (long)errlog );
		fflush(pkg_debug);
	}
d436 6
a441 6
	/*
	 * XXX - Somehow the system has to know what connection
	 * was accepted, it's protocol, etc.  For UNIX/inetd
	 * we use stdin.
	 */
	return( pkg_makeconn( fileno(stdin), switchp, errlog ) );
d540 18
a557 18
	/* Determine port for service */
	if( atoi(service) > 0 )  {
		sinme.sin_port = htons((unsigned short)atoi(service));
	} else {
		if( (sp = getservbyname( service, "tcp" )) == NULL )  {
			sprintf(errbuf,
				"pkg_permserver(%s,%d): unknown service\n",
				service, backlog );
			errlog(errbuf);
			return(-1);
		}
		sinme.sin_port = sp->s_port;
	}
	pkg_permport = sinme.sin_port;		/* XXX -- needs formal I/F */
	sinme.sin_family = AF_INET;
	sinme.sin_addr = iface;
	addr = (struct sockaddr *) &sinme;
	addrlen = sizeof(struct sockaddr_in);
d560 1
a560 1
ready:
d563 9
a571 3
	if( (pkg_listenfd = socket(addr->sa_family, SOCK_STREAM, 0)) < 0 )  {
		pkg_perror( errlog, "pkg_permserver:  socket" );
		return(-1);
a572 6

	if( addr->sa_family == AF_INET ) {
		if( setsockopt( pkg_listenfd, SOL_SOCKET, SO_REUSEADDR,
		    (char *)&on, sizeof(on) ) < 0 )  {
			pkg_perror( errlog, "pkg_permserver: setsockopt SO_REUSEADDR" );
		}
d574 5
a578 5
		/* SunOS 3.x defines it but doesn't support it! */
		if( setsockopt( pkg_listenfd, IPPROTO_TCP, TCP_NODELAY,
		    (char *)&on, sizeof(on) ) < 0 )  {
			pkg_perror( errlog, "pkg_permserver: setsockopt TCP_NODELAY" );
		}
d580 1
a580 1
	}
d582 5
a586 5
	if( bind(pkg_listenfd, addr, addrlen) < 0 )  {
		pkg_perror( errlog, "pkg_permserver: bind" );
		close(pkg_listenfd);
		return(-1);
	}
d588 7
a594 7
	if( backlog > 5 )  backlog = 5;
	if( listen(pkg_listenfd, backlog) < 0 )  {
		pkg_perror( errlog, "pkg_permserver:  listen" );
		close(pkg_listenfd);
		return(-1);
	}
	return(pkg_listenfd);
d661 4
a664 4
	struct sockaddr_in from;
	register int s2;
	unsigned int fromlen = sizeof (from);
	auto int onoff;
d666 7
a672 7
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_getclient(fd=%d, switchp=x%lx, errlog=x%lx, nodelay=%d)\n",
			fd, (long)switchp, (long)errlog, nodelay );
		fflush(pkg_debug);
	}
d674 3
a676 3
	/* Check for default error handler */
	if( errlog == NULL )
		errlog = pkg_errlog;
d679 5
a683 5
	if(nodelay)  {
		onoff = 1;
		if( ioctl(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 1" );
	}
d685 1
a685 1
	do  {
d687 1
a687 1
		s2 = accept(fd, (struct sockaddr *)NULL, NULL);
d689 1
a689 1
		s2 = accept(fd, (struct sockaddr *)&from, &fromlen);
d691 3
a693 3
		if (s2 < 0) {
			if(errno == EINTR)
				continue;
d695 2
a696 2
			if(errno == WSAEWOULDBLOCK)
				return(PKC_NULL);
d698 2
a699 2
			if(errno == EWOULDBLOCK)
				return(PKC_NULL);
d701 4
a704 4
			pkg_perror( errlog, "pkg_getclient: accept" );
			return(PKC_ERROR);
		}
	}  while( s2 < 0);
d706 7
a712 7
	if(nodelay)  {
		onoff = 0;
		if( ioctl(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 2" );
		if( ioctl(s2, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 3");
	}
d715 1
a715 1
	return( pkg_makeconn(s2, switchp, errlog) );
d734 1
a734 1
	register struct pkg_conn *pc;
d736 11
a746 7
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_makeconn(fd=%d, switchp=x%lx, errlog=x%lx)\n",
			fd, (long)switchp, (long)errlog );
		fflush(pkg_debug);
	}
d748 15
a762 19
	/* Check for default error handler */
	if( errlog == NULL )
		errlog = pkg_errlog;

	if( (pc = (struct pkg_conn *)malloc(sizeof(struct pkg_conn)))==PKC_NULL )  {
		pkg_perror(errlog, "pkg_makeconn: malloc failure\n" );
		return(PKC_ERROR);
	}
	bzero( (char *)pc, sizeof(struct pkg_conn) );
	pc->pkc_magic = PKG_MAGIC;
	pc->pkc_fd = fd;
	pc->pkc_switch = switchp;
	pc->pkc_errlog = errlog;
	pc->pkc_left = -1;
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
	pc->pkc_strpos = 0;
	pc->pkc_incur = pc->pkc_inend = 0;
	return(pc);
d773 8
a780 8
	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_close(pc=x%lx) fd=%d\n",
			(long)pc, pc->pkc_fd );
		fflush(pkg_debug);
	}
d782 4
a785 4
	/* Flush any queued stream output first. */
	if( pc->pkc_strpos > 0 )  {
		(void)pkg_flush( pc );
	}
d787 16
a802 16
	if( pc->pkc_buf != (char *)0 )  {
		sprintf(errbuf,"pkg_close(x%lx):  partial input pkg discarded, buf=x%lx\n",
			(long)pc, (long)(pc->pkc_buf));
		pc->pkc_errlog(errbuf);
		(void)free( pc->pkc_buf );
	}
	if( pc->pkc_inbuf != (char *)0 )  {
		(void)free( pc->pkc_inbuf );
		pc->pkc_inbuf = (char *)0;
		pc->pkc_inlen = 0;
	}
	(void)close(pc->pkc_fd);
	pc->pkc_fd = -1;		/* safety */
	pc->pkc_buf = (char *)0;	/* safety */
	pc->pkc_magic = 0;		/* safety */
	(void)free( (char *)pc );
d818 2
a819 2
	register int	len;
	register int	todo = count;
d821 1
a821 1
	while( todo > 0 )  {
d823 13
a835 13
		while( (len = pc->pkc_inend - pc->pkc_incur) <= 0 )  {
			/* This can block */
			if( pkg_suckin( pc ) < 1 )
				return( count - todo );
		}
		/* Input Buffer has some data in it, move to caller's buffer */
		if( len > todo )  len = todo;
		bcopy( &pc->pkc_inbuf[pc->pkc_incur], buf, len );
		pc->pkc_incur += len;
		buf += len;
		todo -= len;
	}
	return( count );
d855 1
a855 1
	static struct iovec cmdvec[2];
d857 2
a858 2
	static struct pkg_header hdr;
	register int i;
d860 2
a861 2
	PKG_CK(pc);
	if( len < 0 )  len=0;
d863 7
a869 7
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_send(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
			 type, (long)buf, len, (long)pc );
		fflush(pkg_debug);
	}
d871 3
a873 3
	/* Check for any pending input, no delay */
	/* Input may be read, but not acted upon, to prevent deep recursion */
	pkg_checkin( pc, 1 );
d875 13
a887 16
	/* Flush any queued stream output first. */
	if( pc->pkc_strpos > 0 )  {
		/*
		 * Buffered output is already queued, and needs to be
		 * flushed before sending this one.  If this pkg will
		 * also fit in the buffer, add it to the stream, and
		 * then send the whole thing with one flush.
		 * Otherwise, just flush, and proceed.
		 */
		if( len <= MAXQLEN && len <= PKG_STREAMLEN -
		    sizeof(struct pkg_header) - pc->pkc_strpos )  {
			(void)pkg_stream( type, buf, len, pc );
			return( (pkg_flush(pc) < 0) ? -1 : len );
		}
		if( pkg_flush( pc ) < 0 )
			return(-1);	/* assumes 2nd write would fail too */
d889 3
d893 3
a895 3
	pkg_pshort( (char *)hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( (char *)hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( (char *)hdr.pkh_len, (unsigned long)len );
d898 14
a911 19
	cmdvec[0].iov_base = (caddr_t)&hdr;
	cmdvec[0].iov_len = sizeof(hdr);
	cmdvec[1].iov_base = (caddr_t)buf;
	cmdvec[1].iov_len = len;

	/*
	 * TODO:  set this FD to NONBIO.  If not all output got sent,
	 * loop in select() waiting for capacity to go out, and
	 * reading input as well.  Prevents deadlocking.
	 */
	if( (i = writev( pc->pkc_fd, cmdvec, (len>0)?2:1 )) != len+sizeof(hdr) )  {
		if( i < 0 )  {
			pkg_perror(pc->pkc_errlog, "pkg_send: writev");
			return(-1);
		}
		sprintf(errbuf,"pkg_send of %d+%d, wrote %d\n",
			(int)sizeof(hdr), len, i);
		(pc->pkc_errlog)(errbuf);
		return(i-sizeof(hdr));	/* amount of user data sent */
d913 5
d919 22
a940 28
	/*
	 *  On the assumption that buffer copying is less expensive than
	 *  having this transmission broken into two network packets
	 *  (with TCP, each with a "push" bit set),
	 *  merge it all into one buffer here, unless size is enormous.
	 */
	if( len + sizeof(hdr) <= 16*1024 )  {
		char	tbuf[16*1024] = {0};

		bcopy( (char *)&hdr, tbuf, sizeof(hdr) );
		if( len > 0 )
			bcopy( buf, tbuf+sizeof(hdr), len );
#ifdef _WIN32
		if ((i = send(pc->pkc_fd, tbuf, len+sizeof(hdr), 0)) != len+sizeof(hdr)) {
#else
		if( (i = write( pc->pkc_fd, tbuf, len+sizeof(hdr) )) != len+sizeof(hdr) )  {
#endif
			if( i < 0 )  {
				if( errno == EBADF )  return(-1);
				pkg_perror(pc->pkc_errlog, "pkg_send: tbuf write");
				return(-1);
			}
			sprintf(errbuf,"pkg_send of %d, wrote %d\n",
				len, i-(int)sizeof(hdr) );
			(pc->pkc_errlog)(errbuf);
			return(i-sizeof(hdr));	/* amount of user data sent */
		}
		return(len);
d942 8
a949 15
	/* Send them separately */
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, (char *)&hdr, sizeof(hdr), 0)) != sizeof(hdr)) {
#else
	if( (i = write( pc->pkc_fd, (char *)&hdr, sizeof(hdr) )) != sizeof(hdr) )  {
#endif
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_send: header write");
			return(-1);
		}
		sprintf(errbuf,"pkg_send header of %d, wrote %d\n",
			(int)sizeof(hdr), i);
		(pc->pkc_errlog)(errbuf);
		return(-1);		/* amount of user data sent */
d951 11
a961 14
	if( len <= 0 )  return(0);
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, buf, len, 0)) != len) {
#else
	if( (i = write( pc->pkc_fd, buf, len )) != len )  {
#endif
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_send: write");
			return(-1);
		}
		sprintf(errbuf,"pkg_send of %d, wrote %d\n", len, i);
		(pc->pkc_errlog)(errbuf);
		return(i);		/* amount of user data sent */
d963 4
d968 1
a968 1
	return(len);
d982 1
a982 1
	static struct iovec cmdvec[3];
d984 2
a985 2
	static struct pkg_header hdr;
	register int i;
d987 3
a989 3
	PKG_CK(pc);
	if( len1 < 0 )  len1=0;
	if( len2 < 0 )  len2=0;
d991 7
a997 7
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_send2(type=%d, buf1=x%lx, len1=%d, buf2=x%lx, len2=%d, pc=x%lx)\n",
			 type, (long)buf1, len1, (long)buf2, len2, (long)pc );
		fflush(pkg_debug);
	}
d999 9
a1007 9
	/* Check for any pending input, no delay */
	/* Input may be read, but not acted upon, to prevent deep recursion */
	pkg_checkin( pc, 1 );

	/* Flush any queued stream output first. */
	if( pc->pkc_strpos > 0 )  {
		if( pkg_flush( pc ) < 0 )
			return(-1);	/* assumes 2nd write would fail too */
	}
d1009 3
a1011 3
	pkg_pshort( (char *)hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( (char *)hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( (char *)hdr.pkh_len, (unsigned long)(len1+len2) );
d1014 21
a1034 26
	cmdvec[0].iov_base = (caddr_t)&hdr;
	cmdvec[0].iov_len = sizeof(hdr);
	cmdvec[1].iov_base = (caddr_t)buf1;
	cmdvec[1].iov_len = len1;
	cmdvec[2].iov_base = (caddr_t)buf2;
	cmdvec[2].iov_len = len2;

	/*
	 * TODO:  set this FD to NONBIO.  If not all output got sent,
	 * loop in select() waiting for capacity to go out, and
	 * reading input as well.  Prevents deadlocking.
	 */
	if( (i = writev(pc->pkc_fd, cmdvec, 3)) != len1+len2+sizeof(hdr) )  {
		if( i < 0 )  {
			pkg_perror(pc->pkc_errlog, "pkg_2send: writev");
			sprintf( errbuf,
				"pkg_send2(type=%d, buf1=x%lx, len1=%d, buf2=x%lx, len2=%d, pc=x%lx)\n",
				 type, (unsigned long int)buf1, len1,
				 (unsigned long int)buf2, len2, (unsigned long int)pc );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote %d\n",
			(int)sizeof(hdr), len1, len2, i);
		(pc->pkc_errlog)(errbuf);
		return(i-sizeof(hdr));	/* amount of user data sent */
d1036 5
d1042 24
a1065 30
	/*
	 *  On the assumption that buffer copying is less expensive than
	 *  having this transmission broken into two network packets
	 *  (with TCP, each with a "push" bit set),
	 *  merge it all into one buffer here, unless size is enormous.
	 */
	if( len1 + len2 + sizeof(hdr) <= 16*1024 )  {
		char	tbuf[16*1024] = {0};

		bcopy( (char *)&hdr, tbuf, sizeof(hdr) );
		if( len1 > 0 )
			bcopy( buf1, tbuf+sizeof(hdr), len1 );
		if( len2 > 0 )
			bcopy( buf2, tbuf+sizeof(hdr)+len1, len2 );
#ifdef _WIN32
		if ((i = send(pc->pkc_fd, tbuf, len1+len2+sizeof(hdr), 0)) != len1+len2+sizeof(hdr)) {
#else
		if( (i = write( pc->pkc_fd, tbuf, len1+len2+sizeof(hdr) )) != len1+len2+sizeof(hdr) )  {
#endif
			if( i < 0 )  {
				if( errno == EBADF )  return(-1);
				pkg_perror(pc->pkc_errlog, "pkg_2send: tbuf write");
				return(-1);
			}
			sprintf(errbuf,"pkg_2send of %d+%d, wrote %d\n",
				len1, len2, i-(int)sizeof(hdr) );
			(pc->pkc_errlog)(errbuf);
			return(i-sizeof(hdr));	/* amount of user data sent */
		}
		return(len1+len2);
d1067 11
a1077 18
	/* Send it in three pieces */
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, (char *)&hdr, sizeof(hdr), 0)) != sizeof(hdr)) {
#else
	if( (i = write( pc->pkc_fd, (char *)&hdr, sizeof(hdr) )) != sizeof(hdr) )  {
#endif
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_2send: header write");
			sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
				pc->pkc_fd, (long)&hdr, (int)sizeof(hdr), i );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote header=%d\n",
			(int)sizeof(hdr), len1, len2, i );
		(pc->pkc_errlog)(errbuf);
		return(-1);		/* amount of user data sent */
d1079 13
a1091 17
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, buf1, len1, 0)) != len1) {
#else
	if( (i = write( pc->pkc_fd, buf1, len1 )) != len1 )  {
#endif
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_2send: write buf1");
			sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
				pc->pkc_fd, (long)buf1, len1, i );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote len1=%d\n",
			(int)sizeof(hdr), len1, len2, i );
		(pc->pkc_errlog)(errbuf);
		return(i);		/* amount of user data sent */
d1093 14
a1106 18
	if( len2 <= 0 )  return(i);
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, buf2, len2, 0)) != len2) {
#else
	if( (i = write( pc->pkc_fd, buf2, len2 )) != len2 )  {
#endif
		if( i < 0 )  {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_2send: write buf2");
			sprintf(errbuf, "pkg_2send write(%d, x%lx, %d) ret=%d\n",
				pc->pkc_fd, (long)buf2, len2, i );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		sprintf(errbuf,"pkg_2send of %d+%d+%d, wrote len2=%d\n",
			(int)sizeof(hdr), len1, len2, i );
		(pc->pkc_errlog)(errbuf);
		return(len1+i);		/* amount of user data sent */
d1108 5
d1114 1
a1114 1
	return(len1+len2);
d1132 1
a1132 1
	static struct pkg_header hdr;
d1134 7
a1140 7
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_stream(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
			 type, (long)buf, len, (long)pc );
		fflush(pkg_debug);
	}
d1142 2
a1143 2
	if( len > MAXQLEN )
		return( pkg_send(type, buf, len, pc) );
d1145 2
a1146 2
	if( len > PKG_STREAMLEN - sizeof(struct pkg_header) - pc->pkc_strpos )
		pkg_flush( pc );
d1148 10
a1157 10
	/* Queue it */
	pkg_pshort( (char *)hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( (char *)hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( (char *)hdr.pkh_len, (unsigned long)len );

	bcopy( (char *)&hdr, &(pc->pkc_stream[pc->pkc_strpos]),
		sizeof(struct pkg_header) );
	pc->pkc_strpos += sizeof(struct pkg_header);
	bcopy( buf, &(pc->pkc_stream[pc->pkc_strpos]), len );
	pc->pkc_strpos += len;
d1159 1
a1159 1
	return( len + sizeof(struct pkg_header) );
d1172 9
a1180 1
	register int	i;
d1182 4
a1185 7
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_flush( pc=x%lx )\n",
			(long)pc );
		fflush(pkg_debug);
	}
d1187 5
a1191 18
	if( pc->pkc_strpos <= 0 ) {
		pc->pkc_strpos = 0;	/* sanity for < 0 */
		return( 0 );
	}

	if( (i = write(pc->pkc_fd,pc->pkc_stream,pc->pkc_strpos)) != pc->pkc_strpos )  {
		if( i < 0 ) {
			if( errno == EBADF )  return(-1);
			pkg_perror(pc->pkc_errlog, "pkg_flush: write");
			return(-1);
		}
		sprintf(errbuf,"pkg_flush of %d, wrote %d\n",
			pc->pkc_strpos, i);
		(pc->pkc_errlog)(errbuf);
		pc->pkc_strpos -= i;
		/* copy leftovers to front of stream */
		bcopy(pc->pkc_stream + i, pc->pkc_stream, pc->pkc_strpos);
		return( i );	/* amount of user data sent */
d1193 10
a1202 2
	pc->pkc_strpos = 0;
	return( i );
d1218 1
a1218 1
	register int i;
d1220 28
a1247 13
	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_waitfor(type=%d, buf=x%lx, len=%d, pc=x%lx)\n",
			type, (long)buf, len, (long)pc );
		fflush(pkg_debug);
	}
again:
	if( pc->pkc_left >= 0 )  {
		/* Finish up remainder of partially received message */
		if( pkg_block( pc ) < 0 )
			return(-1);
d1249 5
d1255 13
a1267 3
	if( pc->pkc_buf != (char *)0 )  {
		pc->pkc_errlog("pkg_waitfor:  buffer clash\n");
		return(-1);
d1269 4
a1272 54
	if( pkg_gethdr( pc, buf ) < 0 )  return(-1);
	if( pc->pkc_type != type )  {
		/* A message of some other type has unexpectedly arrived. */
		if( pc->pkc_len > 0 )  {
			if( (pc->pkc_buf = (char *)malloc(pc->pkc_len+2)) == NULL )  {
				pkg_perror(pc->pkc_errlog, "pkg_waitfor: malloc failed");
				return(-1);
			}
			pc->pkc_curpos = pc->pkc_buf;
		}
		goto again;
	}
	pc->pkc_left = -1;
	if( pc->pkc_len == 0 )
		return(0);

	/* See if incomming message is larger than user's buffer */
	if( pc->pkc_len > len )  {
		register char *bp;
		int excess;
		sprintf(errbuf,
			"pkg_waitfor:  message %ld exceeds buffer %d\n",
			pc->pkc_len, len );
		(pc->pkc_errlog)(errbuf);
		if( (i = pkg_inget( pc, buf, len )) != len )  {
			sprintf(errbuf,
				"pkg_waitfor:  pkg_inget %d gave %d\n", len, i );
			(pc->pkc_errlog)(errbuf);
			return(-1);
		}
		excess = pc->pkc_len - len;	/* size of excess message */
		if( (bp = (char *)malloc(excess)) == NULL )  {
			pkg_perror(pc->pkc_errlog, "pkg_waitfor: excess message, malloc failed");
			return(-1);
		}
		if( (i = pkg_inget( pc, bp, excess )) != excess )  {
			sprintf(errbuf,
				"pkg_waitfor: pkg_inget of excess, %d gave %d\n",
				excess, i );
			(pc->pkc_errlog)(errbuf);
			(void)free(bp);
			return(-1);
		}
		(void)free(bp);
		return(len);		/* truncated, but OK */
	}

	/* Read the whole message into the users buffer */
	if( (i = pkg_inget( pc, buf, pc->pkc_len )) != pc->pkc_len )  {
		sprintf(errbuf,
			"pkg_waitfor:  pkg_inget %ld gave %d\n",
			pc->pkc_len, i );
		(pc->pkc_errlog)(errbuf);
		return(-1);
d1274 7
a1280 5
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_waitfor() message type=%d arrived\n", type);
		fflush(pkg_debug);
d1282 22
a1303 4
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
	pc->pkc_left = -1;		/* safety */
	return( pc->pkc_len );
d1322 2
a1323 2
	register int i;
	register char *tmpbuf;
d1325 12
a1336 23
	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_bwaitfor(type=%d, pc=x%lx)\n",
			type, (long)pc );
		fflush(pkg_debug);
	}
	do  {
		/* Finish any unsolicited msg */
		if( pc->pkc_left >= 0 )
			if( pkg_block(pc) < 0 )
				return((char *)0);
		if( pc->pkc_buf != (char *)0 )  {
			pc->pkc_errlog("pkg_bwaitfor:  buffer clash\n");
			return((char *)0);
		}
		if( pkg_gethdr( pc, (char *)0 ) < 0 )
			return((char *)0);
	}  while( pc->pkc_type != type );

	pc->pkc_left = -1;
	if( pc->pkc_len == 0 )
d1338 3
a1340 6

	/* Read the whole message into the dynamic buffer */
	if( (i = pkg_inget( pc, pc->pkc_buf, pc->pkc_len )) != pc->pkc_len )  {
		sprintf(errbuf,
			"pkg_bwaitfor:  pkg_inget %ld gave %d\n", pc->pkc_len, i );
		(pc->pkc_errlog)(errbuf);
d1342 20
a1361 6
	tmpbuf = pc->pkc_buf;
	pc->pkc_buf = (char *)0;
	pc->pkc_curpos = (char *)0;
	pc->pkc_left = -1;		/* safety */
	/* User must free the buffer */
	return( tmpbuf );
d1417 76
a1492 48
	register int	len;
	register int	available;
	register int	errcnt;
	register int	ret;
	int		goodcnt;

	goodcnt = 0;

	PKG_CK(pc);
	/* This loop exists only to cut off "hard" errors */
	for( errcnt=0; errcnt < 500; )  {
		available = pc->pkc_inend - pc->pkc_incur;	/* amt in input buf */
		if( pkg_debug )  {
			if( pc->pkc_left < 0 )  {
				sprintf(errbuf, "awaiting new header");
			} else if( pc->pkc_left > 0 )  {
				sprintf(errbuf, "need more data");
			} else {
				sprintf(errbuf, "pkg is all here");
			}
			pkg_timestamp();
			fprintf( pkg_debug,
				"pkg_process(pc=x%lx) pkc_left=%d %s (avail=%d)\n",
				(long)pc, pc->pkc_left, errbuf, available );
			fflush(pkg_debug);
		}
		if( pc->pkc_left < 0 )  {
			/*
			 *  Need to get a new PKG header.
			 *  Do so ONLY if the full header is already in the
			 *  internal buffer, to prevent blocking in pkg_gethdr().
			 */
			if( available < sizeof(struct pkg_header) )
				break;

			if( pkg_gethdr( pc, (char *)0 ) < 0 )  {
				DMSG("pkg_gethdr < 0\n");
				errcnt++;
				continue;
			}

			if( pc->pkc_left < 0 )  {
				/* pkg_gethdr() didn't get a header */
				DMSG("pkc_left still < 0 after pkg_gethdr()\n");
				errcnt++;
				continue;
			}
		}
d1494 2
a1495 2
		 *  Now pkc_left >= 0, implying header has been obtained.
		 *  Find amount still available in input buffer.
d1497 3
a1499 1
		available = pc->pkc_inend - pc->pkc_incur;
d1501 5
a1505 46
		/* copy what is here already, and dispatch when all here */
		if( pc->pkc_left > 0 )  {
			if( available <= 0 )  break;

			/* Sanity check -- buffer must be allocated by now */
			if( pc->pkc_curpos == 0 )  {
				DMSG("curpos=0\n");
				errcnt++;
				continue;
			}

			if( available > pc->pkc_left )  {
				/* There is more in input buf than just this pkg */
				len = pc->pkc_left; /* trim to amt needed */
			} else {
				/* Take all that there is */
				len = available;
			}
			len = pkg_inget( pc, pc->pkc_curpos, len );
			pc->pkc_curpos += len;
			pc->pkc_left -= len;
			if( pc->pkc_left > 0 )  {
				/*
				 *  Input buffer is exhausted, but more
				 *  data is needed to finish this package.
				 */
				break;
			}
		}

		if( pc->pkc_left != 0 )  {
			/* Somehow, a full PKG has not yet been obtained */
			DMSG("pkc_left != 0\n");
			errcnt++;
			continue;
		}

		/* Now, pkc_left == 0, dispatch the message */
		if( pkg_dispatch(pc) <= 0 )  {
			/* something bad happened */
			DMSG("pkg_dispatch failed\n");
			errcnt++;
		} else {
			/* it worked */
			goodcnt++;
		}
d1508 5
a1512 2
	if( errcnt > 0 )  {
		ret = -errcnt;
d1514 2
a1515 1
		ret = goodcnt;
d1517 1
d1519 14
a1532 8
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_process() ret=%d, pkc_left=%d, errcnt=%d, goodcnt=%d\n",
			ret, pc->pkc_left, errcnt, goodcnt);
		fflush(pkg_debug);
	}
	return( ret );
d1546 1
a1546 1
	register int i;
d1548 9
a1556 9
	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_dispatch(pc=x%lx) type=%d, buf=x%lx, len=%ld\n",
			(long)pc, pc->pkc_type, (long)(pc->pkc_buf), pc->pkc_len );
		fflush(pkg_debug);
	}
	if( pc->pkc_left != 0 )  return(-1);
d1558 3
a1560 3
	/* Whole message received, process it via switchout table */
	for( i=0; pc->pkc_switch[i].pks_handler != NULL; i++ )  {
		register char *tempbuf;
d1562 8
a1569 19
		if( pc->pkc_switch[i].pks_type != pc->pkc_type )
			continue;
		/*
		 * NOTICE:  User Handler must free() message buffer!
		 * WARNING:  Handler may recurse back to pkg_suckin() --
		 * reset all connection state variables first!
		 */
		tempbuf = pc->pkc_buf;
		pc->pkc_buf = (char *)0;
		pc->pkc_curpos = (char *)0;
		pc->pkc_left = -1;		/* safety */
		/* pc->pkc_type, pc->pkc_len are preserved for handler */
		pc->pkc_switch[i].pks_handler(pc, tempbuf);
		return(1);
	}
	sprintf(errbuf,"pkg_dispatch:  no handler for message type %d, len %ld\n",
		pc->pkc_type, pc->pkc_len );
	(pc->pkc_errlog)(errbuf);
	(void)free(pc->pkc_buf);
d1573 12
a1584 1
	return(0);
d1598 1
a1598 1
	register int i;
d1600 2
a1601 2
	PKG_CK(pc);
	if( pc->pkc_left >= 0 )  return(1);	/* go get it! */
d1603 33
a1635 11
	/*
	 *  At message boundary, read new header.
	 *  This will block until the new header arrives (feature).
	 */
	if( (i = pkg_inget( pc, (char *)&(pc->pkc_hdr),
	    sizeof(struct pkg_header) )) != sizeof(struct pkg_header) )  {
		if(i > 0) {
			sprintf(errbuf,"pkg_gethdr: header read of %d?\n", i);
			(pc->pkc_errlog)(errbuf);
		}
		return(-1);
d1637 7
a1643 29
	while( pkg_gshort((char *)pc->pkc_hdr.pkh_magic) != PKG_MAGIC )  {
		int	c;
		c = *((unsigned char *)&pc->pkc_hdr);
		if( isascii(c) && isprint(c) )  {
			sprintf(errbuf,
				"pkg_gethdr: skipping noise x%x %c\n",
				c, c );
		} else {
			sprintf(errbuf,
				"pkg_gethdr: skipping noise x%x\n",
				c );
		}
		(pc->pkc_errlog)(errbuf);
		/* Slide over one byte and try again */
		bcopy( ((char *)&pc->pkc_hdr)+1, (char *)&pc->pkc_hdr, sizeof(struct pkg_header)-1);
		if( (i=pkg_inget( pc,
		    ((char *)&pc->pkc_hdr)+sizeof(struct pkg_header)-1,
		    1 )) != 1 )  {
			sprintf(errbuf,"pkg_gethdr: hdr read=%d?\n",i);
		    	(pc->pkc_errlog)(errbuf);
			return(-1);
		}
	}
	pc->pkc_type = pkg_gshort((char *)pc->pkc_hdr.pkh_type);	/* host order */
	pc->pkc_len = pkg_glong((char *)pc->pkc_hdr.pkh_len);
	if( pc->pkc_len < 0 )  pc->pkc_len = 0;
	pc->pkc_buf = (char *)0;
	pc->pkc_left = pc->pkc_len;
	if( pc->pkc_left == 0 )  return(1);		/* msg here, no data */
d1645 7
a1651 8
	if( buf )  {
		pc->pkc_buf = buf;
	} else {
		/* Prepare to read message into dynamic buffer */
		if( (pc->pkc_buf = (char *)malloc(pc->pkc_len+2)) == NULL )  {
			pkg_perror(pc->pkc_errlog, "pkg_gethdr: malloc fail");
			return(-1);
		}
d1653 3
a1655 2
	pc->pkc_curpos = pc->pkc_buf;
	return(1);			/* something ready */
d1677 8
a1684 8
	PKG_CK(pc);
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_block(pc=x%lx)\n",
			(long)pc );
		fflush(pkg_debug);
	}
d1686 5
a1690 5
	/* If no read operation going now, start one. */
	if( pc->pkc_left < 0 )  {
		if( pkg_gethdr( pc, (char *)0 ) < 0 )  return(-1);
		/* Now pkc_left >= 0 */
	}
d1692 5
a1696 7
	/* Read the rest of the message, blocking if necessary */
	if( pc->pkc_left > 0 )  {
		if( pkg_inget( pc, pc->pkc_curpos, pc->pkc_left ) != pc->pkc_left )  {
			pc->pkc_left = -1;
			return(-1);
		}
		pc->pkc_left = 0;
d1698 2
d1701 2
a1702 2
	/* Now, pkc_left == 0, dispatch the message */
	return( pkg_dispatch(pc) );
d1714 1
a1714 1
	sprintf( errbuf, "%s: ", s);
d1716 5
a1720 5
	if ( errno >= 0 || strlen(errbuf) >= MAX_ERRBUF_SIZE) {
		sprintf( errbuf, "%s: errno=%d\n", s, errno );
		errlog( errbuf );
		return;
	}
d1723 3
a1725 3
       	if (strerror_r(errno, errbuf+strlen(errbuf), MAX_ERRBUF_SIZE-strlen(errbuf)) != 0) {
		sprintf(errbuf, "%s: errno=%d\n", s, errno);
	}
d1728 1
a1728 1
	sprintf( errbuf, "%s: %s\n", s, strerror(errno) );
d1730 1
a1730 1
	sprintf( errbuf, "%s: %s\n", s, sys_errlist[errno] );
d1733 1
a1733 1
	errlog( errbuf );
d1744 6
a1749 6
	if( pkg_debug )  {
		pkg_timestamp();
		fputs( s, pkg_debug );
		fflush(pkg_debug);
	}
	fputs( s, stderr );
d1758 2
a1759 2
	char	*place;
	char	buf[128] = {0};
d1761 8
a1768 8
	if( pkg_debug )  return;
	if( (place = (char *)getenv("LIBPKG_DEBUG")) == (char *)0 )  {
		sprintf( buf, "/tmp/pkg.log" );
		place = buf;
	}
	/* Named file must exist and be writeable */
	if( access( place, 2 ) < 0 )  return;
	if( (pkg_debug = fopen( place, "a" )) == NULL )  return;
d1770 2
a1771 2
	/* Log version number of this code */
	pkg_timestamp();
d1773 1
a1773 1
	fprintf( pkg_debug, "pkg_ck_debug %s\n", RCSid );
d1785 2
a1786 2
	time_t		now;
	struct tm	*tmp;
d1788 8
a1795 8
	if( !pkg_debug )  return;
	(void)time( &now );
	tmp = localtime( &now );
	fprintf(pkg_debug, "%2.2d/%2.2d %2.2d:%2.2d:%2.2d [%5d] ",
		tmp->tm_mon+1, tmp->tm_mday,
		tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
		getpid() );
	/* Don't fflush here, wait for rest of line */
d1827 6
a1832 3
	int	avail;
	int	got;
	int	ret;
d1834 7
a1840 2
	got = 0;
	PKG_CK(pc);
d1842 8
a1849 6
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_suckin() incur=%d, inend=%d, inlen=%d\n",
			pc->pkc_incur, pc->pkc_inend, pc->pkc_inlen );
		fflush(pkg_debug);
d1851 19
d1871 16
a1886 27
	/* If no buffer allocated yet, get one */
	if( pc->pkc_inbuf == (char *)0 || pc->pkc_inlen <= 0 )  {
		pc->pkc_inlen = PKG_STREAMLEN;
		if( (pc->pkc_inbuf = (char *)malloc(pc->pkc_inlen)) == (char *)0 )  {
			pc->pkc_errlog("pkg_suckin malloc failure\n");
			pc->pkc_inlen = 0;
			ret = -1;
			goto out;
		}
		pc->pkc_incur = pc->pkc_inend = 0;
	}

	if( pc->pkc_incur >= pc->pkc_inend )  {
		/* Reset to beginning of buffer */
		pc->pkc_incur = pc->pkc_inend = 0;
	}

	/* If cur point is near end of buffer, recopy data to buffer front */
	if( pc->pkc_incur >= (pc->pkc_inlen * 7) / 8 )  {
		register int	ammount;

		ammount = pc->pkc_inend - pc->pkc_incur;
		/* This copy can not overlap itself, because of 7/8 above */
		bcopy( &pc->pkc_inbuf[pc->pkc_incur],
			pc->pkc_inbuf, ammount );
		pc->pkc_incur = 0;
		pc->pkc_inend = ammount;
d1888 1
a1888 2

	/* If remaining buffer space is small, make buffer bigger */
d1890 1
a1890 18
	if( avail < 10 * sizeof(struct pkg_header) )  {
		pc->pkc_inlen <<= 1;
		if( pkg_debug)  {
			pkg_timestamp();
			fprintf(pkg_debug,
				"pkg_suckin: realloc inbuf to %d\n",
				pc->pkc_inlen );
			fflush(pkg_debug);
		}
		if( (pc->pkc_inbuf = (char *)realloc(pc->pkc_inbuf, pc->pkc_inlen)) == (char *)0 )  {
			pc->pkc_errlog("pkg_suckin realloc failure\n");
			pc->pkc_inlen = 0;
			ret = -1;
			goto out;
		}
		/* since the input buffer has grown, lets update avail */
		avail = pc->pkc_inlen - pc->pkc_inend;
	}
d1892 4
a1895 36
	/* Take as much as the system will give us, up to buffer size */
#ifdef _WIN32
	if ((got = recv(pc->pkc_fd, &pc->pkc_inbuf[pc->pkc_inend], avail, 0)) <= 0) {
#else
	if( (got = read( pc->pkc_fd, &pc->pkc_inbuf[pc->pkc_inend], avail )) <= 0 )  {
#endif
		if( got == 0 )  {
			if( pkg_debug )  {
				pkg_timestamp();
				fprintf(pkg_debug,
					"pkg_suckin: fd=%d, read for %d returned 0\n",
					avail, pc->pkc_fd );
				fflush(pkg_debug);
			}
			ret = 0;	/* EOF */
			goto out;
		}
#ifndef _WIN32
		pkg_perror(pc->pkc_errlog, "pkg_suckin: read");
		sprintf(errbuf, "pkg_suckin: read(%d, x%lx, %d) ret=%d inbuf=x%lx, inend=%d\n",
			pc->pkc_fd, (long)(&pc->pkc_inbuf[pc->pkc_inend]), avail,
			got,
			(long)(pc->pkc_inbuf), pc->pkc_inend );
		(pc->pkc_errlog)(errbuf);
#endif
		ret = -1;
		goto out;
	}
	if( got > avail )  {
		pc->pkc_errlog("pkg_suckin:  read more bytes than desired\n");
		got = avail;
	}
	pc->pkc_inend += got;
	ret = 1;
out:
	if( pkg_debug )  {
d1897 3
a1899 3
		fprintf( pkg_debug,
			"pkg_suckin() ret=%d, got %d, total=%d\n",
			ret, got, pc->pkc_inend - pc->pkc_incur );
d1901 3
d1905 26
a1930 1
	return(ret);
d1944 42
a1985 42
	struct timeval	tv;
	fd_set		bits;
	register int	i, j;
	extern int	errno;

	/* Check socket for unexpected input */
	tv.tv_sec = 0;
	if( nodelay )
		tv.tv_usec = 0;		/* poll -- no waiting */
	else
		tv.tv_usec = 20000;	/* 20 ms */

	FD_ZERO(&bits);
	FD_SET(pc->pkc_fd, &bits);
	i = select( pc->pkc_fd+1, &bits, (fd_set *)0, (fd_set *)0, &tv );
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf(pkg_debug,
			"pkg_checkin: select on fd %d returned %d\n",
			pc->pkc_fd,
			i );
		fflush(pkg_debug);
	}
	if( i > 0 )  {
		for( j = 0; j < FD_SETSIZE; j++ )
			if( FD_ISSET( j, &bits ) ) break;

		if( j < FD_SETSIZE )  {
			/* Some fd is ready for I/O */
			(void)pkg_suckin(pc);
		} else {
			/* Odd condition, bits! */
			sprintf(errbuf,
				"pkg_checkin: select returned %d, bits=0\n",
				i );
			(pc->pkc_errlog)(errbuf);
		}
	} else if( i < 0 )  {
		/* Error condition */
		if( errno != EINTR && errno != EBADF )
			pkg_perror(pc->pkc_errlog, "pkg_checkin: select");
	}
@


14.33
log
@It looks like the intent was to struct copy a "struct in_addr" in the _pkg_permserver_impl function.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.32 2006/08/28 00:52:48 brlcad Exp $ (BRL)";
a621 1
	    return _pkg_permserver_impl(iface, service, protocol, backlog, errlog);
a625 1
	    return _pkg_permserver_impl(iface, service, protocol, backlog, errlog);
d627 1
@


14.32
log
@consistently use char * buffers (instead of unsigned) and be more specific on the errlog callbacks
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.31 2006/08/24 17:05:19 jlowenz Exp $ (BRL)";
d495 1
a495 1
    saServer.sin_addr.s_addr = iface;
@


14.31
log
@added return from pkg_permserver_ip (oops); made strings const for pkg_open - since they should be...
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.30 2006/08/17 20:32:20 jlowenz Exp $ (BRL)";
d141 3
a143 3
static struct pkg_conn *pkg_makeconn(int fd, const struct pkg_switch *switchp, void (*errlog) (/* ??? */));
static void pkg_errlog(char *s);
static void pkg_perror(void (*errlog) (/* ??? */), char *s);
d148 2
a149 2
static char errbuf[MAX_ERRBUF_SIZE];
static FILE	*pkg_debug;
d162 2
a163 3
#if 1
#define DMSG(s) if(pkg_debug) { \
	pkg_timestamp(); fprintf(pkg_debug,s); fflush(pkg_debug);}
d165 1
a165 1
#define DMSG(s)	/**/
d200 1
a200 1
pkg_gshort(unsigned char *msgp)
d202 1
a202 7
	register unsigned char *p = (unsigned char *) msgp;
#ifdef vax
	/*
	 * vax compiler doesn't put shorts in registers
	 */
	register unsigned long u;
#else
a203 1
#endif
d213 1
a213 1
pkg_glong(unsigned char *msgp)
d215 1
a215 1
	register unsigned char *p = (unsigned char *) msgp;
d228 1
a228 1
pkg_pshort(unsigned char *msgp, short unsigned int s)
d230 3
a232 4

	msgp[1] = s;
	msgp[0] = s >> 8;
	return((char *)msgp+2);
d239 1
a239 1
pkg_plong(unsigned char *msgp, long unsigned int l)
d241 5
a245 6

	msgp[3] = l;
	msgp[2] = (l >>= 8);
	msgp[1] = (l >>= 8);
	msgp[0] = l >> 8;
	return((char *)msgp+4);
d256 1
a256 1
pkg_open(const char *host, const char *service, const char *protocol, const char *uname, const char *passwd, const struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d439 1
a439 1
_pkg_permserver_impl(struct in_addr iface, char* service, char* protocol, int backlog, void (*errlog)(char *msg))
d597 1
a597 1
pkg_permserver(char *service, char *protocol, int backlog, void (*errlog) (/* ??? */))
d614 1
a614 1
pkg_permserver_ip(char* ipOrHostname, char* service, char* protocol, int backlog, void (*errlog)(char* buf))
d649 1
a649 1
pkg_getclient(int fd, const struct pkg_switch *switchp, void (*errlog) (/* ??? */), int nodelay)
d722 1
a722 1
pkg_makeconn(int fd, const struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d883 3
a885 3
	pkg_pshort( hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( hdr.pkh_len, (unsigned long)len );
d1011 3
a1013 3
	pkg_pshort( hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( hdr.pkh_len, (unsigned long)(len1+len2) );
d1167 3
a1169 3
	pkg_pshort( hdr.pkh_magic, PKG_MAGIC );
	pkg_pshort( hdr.pkh_type, type );	/* should see if valid type */
	pkg_plong( hdr.pkh_len, (unsigned long)len );
d1633 1
a1633 1
	while( pkg_gshort(pc->pkc_hdr.pkh_magic) != PKG_MAGIC )  {
d1656 2
a1657 2
	pc->pkc_type = pkg_gshort(pc->pkc_hdr.pkh_type);	/* host order */
	pc->pkc_len = pkg_glong(pc->pkc_hdr.pkh_len);
d1730 1
a1730 1
pkg_perror(void (*errlog) (/* ??? */), char *s)
@


14.30
log
@added a new function: pkg_permserver_ip to support connecting to the loopback interface. involved some refactoring. not completely tested yet.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.29 2006/07/13 21:10:22 brlcad Exp $ (BRL)";
d266 1
a266 1
pkg_open(char *host, char *service, char *protocol, char *uname, char *passwd, const struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d632 1
@


14.29
log
@s/HAVE_UNIX_DOMAIN_SOCKETS/HAVE_SYS_UN_H/g now that there is a new check in configure.ac
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.28 2006/07/10 17:07:11 brlcad Exp $ (BRL)";
d174 1
a174 1

a443 1
 *  			P K G _ P E R M S E R V E R
d445 1
a445 3
 *  We are now going to be a server for the indicated service.
 *  Hang a LISTEN, and return the fd to select() on waiting for
 *  new connections.
a446 1
 *  Returns fd to listen on (>=0), -1 on error.
d449 1
a449 1
pkg_permserver(char *service, char *protocol, int backlog, void (*errlog) (/* ??? */))
d451 2
a452 2
	register struct servent *sp;
	int	pkg_listenfd;
d454 1
a454 1
	SOCKADDR_IN saServer;
d456 1
a456 1
	struct sockaddr_in sinme;
d458 1
a458 1
	struct sockaddr_un sunme;		/* UNIX Domain */
d460 19
a478 18
	struct	sockaddr *addr;			/* UNIX or INET addr */
	int	addrlen;			/* length of address */
	int	on = 1;
#endif

	pkg_ck_debug();
	if( pkg_debug )  {
		pkg_timestamp();
		fprintf( pkg_debug,
			"pkg_permserver(%s, %s, backlog=%d, errlog=x%lx\n",
			service, protocol, backlog, (long)errlog );
		fflush(pkg_debug);
	}

	/* Check for default error handler */
	if( errlog == NULL )
		errlog = pkg_errlog;

d480 11
a490 13
	bzero((char *)&saServer, sizeof(saServer));

	if (atoi(service) > 0) {
	    saServer.sin_port = htons((unsigned short)atoi(service));
	} else {
	    if ((sp = getservbyname(service, "tcp")) == NULL) {
		sprintf(errbuf,
			"pkg_permserver(%s,%d): unknown service\n",
			service, backlog );
		errlog(errbuf);
		return(-1);
	    }
	    saServer.sin_port = sp->s_port;
d492 2
d495 4
a498 4
	if ((pkg_listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
	    pkg_perror(errlog, "pkg_permserver:  socket");
	    return(-1);
	}
d501 1
a501 1
	_setmode(pkg_listenfd, _O_BINARY);
d503 26
a528 25

	saServer.sin_family = AF_INET;
	saServer.sin_addr.s_addr = INADDR_ANY;

	if (bind(pkg_listenfd, (LPSOCKADDR)&saServer, sizeof(struct sockaddr)) == SOCKET_ERROR) {
	    pkg_perror(errlog, "pkg_permserver: bind");
	    closesocket(pkg_listenfd);

	    return(-1);
	}

	if (backlog > 5)
	    backlog = 5;

	if (listen(pkg_listenfd, backlog) == SOCKET_ERROR) {
	    pkg_perror(errlog, "pkg_permserver:  listen");
	    closesocket(pkg_listenfd);

	    return(-1);
	}

	return(pkg_listenfd);
#else
	bzero((char *)&sinme, sizeof(sinme));

d530 8
a537 8
	if( service != NULL && service[0] == '/' ) {
		/* UNIX Domain socket */
		strncpy( sunme.sun_path, service, sizeof(sunme.sun_path) );
		sunme.sun_family = AF_UNIX;
		addr = (struct sockaddr *) &sunme;
		addrlen = strlen(sunme.sun_path) + 2;
		goto ready;
	}
d554 1
d598 48
@


14.28
log
@get rid of the now unused BSD define hack. use the configure check header symbols instead of platform foo including the new HAVE_WINSOCK_H
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.27 2006/07/09 19:17:16 brlcad Exp $ (BRL)";
d103 1
a103 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
d275 1
a275 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
d341 1
a341 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
d384 1
a384 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
d461 1
a461 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
d531 1
a531 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
d559 1
a559 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
@


14.27
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.26 2006/07/09 10:53:15 brlcad Exp $ (BRL)";
d65 1
a65 2
#ifndef _WIN32
#  undef BSD	/* /usr/include/sys/param.h redefines this */
d67 2
d72 1
a72 1
#if !defined(vax)
d76 5
a80 1
#ifndef _WIN32
a87 4
#else
#  include <process.h>
#  include <winsock.h>
#  include <fcntl.h>
@


14.26
log
@more mread() cleanup.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.25 2006/07/09 09:44:11 brlcad Exp $ (BRL)";
d877 1
a877 1
		char	tbuf[16*1024];
d1012 1
a1012 1
		char	tbuf[16*1024];
d1738 1
a1738 1
	char	buf[128];
@


14.25
log
@remove the useful 'example' mread code that was replaced by pkg_inget since mread is now available in libbu as bu_mread.  reorder pkg_inget so a decl is unnecessary.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.24 2006/06/03 01:37:52 brlcad Exp $ (BRL)";
d760 3
a762 2
 *  A functional replacement for mread(), through the
 *  first level input buffer.
@


14.24
log
@quell unused variable warning
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.23 2006/03/24 23:45:16 brlcad Exp $ (BRL)";
a152 1
int pkg_inget(register struct pkg_conn *, char *, int);
d756 1
a756 1
#if 0
d758 1
a758 1
 *			P K G _ M R E A D
d760 4
a763 9
 * Internal.
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because pipes
 * and network connections don't deliver data with the same
 * grouping as it is written with.  Written by Robert S. Miles, BRL.
 *
 *  Superceeded by pkg_inget() in this version.
 *  This code is retained because of it's general usefulness.
d765 12
a776 16
static int
pkg_mread(pc, bufp, n)
struct pkg_conn *pc;
register char	*bufp;
int	n;
{
	int fd;
	register int	count = 0;
	register int	nread;

	fd = pc->pkc_fd;
	do {
		nread = read(fd, bufp, (unsigned)n-count);
		if(nread < 0)  {
			pkg_perror(pc->pkc_errlog, "pkg_mread");
			return(-1);
d778 9
a786 5
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);
a787 3
	return((int)count);
}
#endif
a1970 31
 *			P K G _ I N G E T
 *
 *  A functional replacement for mread(), through the
 *  first level input buffer.
 *  This will block if the required number of bytes are not available.
 *  The number of bytes actually transferred is returned.
 */
int
pkg_inget(register struct pkg_conn *pc, char *buf, int count)
{
	register int	len;
	register int	todo = count;

	while( todo > 0 )  {

		while( (len = pc->pkc_inend - pc->pkc_incur) <= 0 )  {
			/* This can block */
			if( pkg_suckin( pc ) < 1 )
				return( count - todo );
		}
		/* Input Buffer has some data in it, move to caller's buffer */
		if( len > todo )  len = todo;
		bcopy( &pc->pkc_inbuf[pc->pkc_incur], buf, len );
		pc->pkc_incur += len;
		buf += len;
		todo -= len;
	}
	return( count );
}

/*
@


14.23
log
@quell intel 9 on altix compiler warnings
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.22 2006/01/22 09:53:17 brlcad Exp $ (BRL)";
a1700 1
	long int ret = 0;
d1710 1
a1710 2
       	ret = (long)strerror_r(errno, errbuf+strlen(errbuf), MAX_ERRBUF_SIZE-strlen(errbuf));
	if (ret != 0) {
@


14.22
log
@there is no need/intent to modify the pkg_switch callback structure, so make it const
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.21 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
d94 3
d100 1
d122 1
d384 1
d386 2
d559 1
d561 2
@


14.22.2.1
log
@update from HEAD
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.22 2006/01/22 09:53:17 brlcad Exp $ (BRL)";
a93 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
a96 1

a117 1

a378 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
a379 2
#endif

a550 1
#ifdef HAVE_UNIX_DOMAIN_SOCKETS
a551 2
#endif

@


14.21
log
@update copyright to 2006
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.20 2006/01/12 01:34:02 brlcad Exp $ (BRL)";
d135 1
a135 1
static struct pkg_conn *pkg_makeconn(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */));
d261 1
a261 1
pkg_open(char *host, char *service, char *protocol, char *uname, char *passwd, struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d416 1
a416 1
pkg_transerver(struct pkg_switch *switchp, void (*errlog) (/* ??? */))
d600 1
a600 1
pkg_getclient(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */), int nodelay)
d673 1
a673 1
pkg_makeconn(int fd, struct pkg_switch *switchp, void (*errlog) (/* ??? */))
@


14.20
log
@quell braindead compiler warning on altix where strerror_r is declared to return a char * (gnu glibc extension) instead of an int (posix, bsd, c89, svid3) like it's supposed to.
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.19 2005/12/23 21:26:30 bob1961 Exp $ (BRL)";
@


14.19
log
@Merge of bobWinPort
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.18 2005/11/04 20:19:47 brlcad Exp $ (BRL)";
d1690 1
a1690 1
	int ret = 0;
d1700 1
a1700 1
       	ret = strerror_r(errno, errbuf+strlen(errbuf), MAX_ERRBUF_SIZE-strlen(errbuf));
@


14.18
log
@strerror section is in the wrong section
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.17 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
d86 1
d164 23
d263 5
d277 1
d293 40
d402 1
d447 5
a455 1
	register struct servent *sp;
a457 1
	int	pkg_listenfd;
d459 1
d474 47
d584 1
d627 3
d631 1
d879 3
d883 1
d897 3
d901 1
d913 3
d917 1
d1016 3
d1020 1
d1034 3
d1038 1
d1052 3
d1056 1
d1071 3
d1075 1
d1871 3
d1875 1
d1887 1
d1894 1
@


14.17
log
@trailing ws
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.16 2005/05/28 02:14:51 brlcad Exp $ (BRL)";
d1551 1
a1552 1
	sprintf( errbuf, "%s: %s\n", s, strerror(errno) );
@


14.16
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d48 1
a48 1
 *  
d53 1
a53 1
 *  
d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.15 2005/05/11 21:44:53 brlcad Exp $ (BRL)";
d336 1
a336 1
 *  
d366 1
a366 1
 *  
d520 1
a520 1
	if(nodelay)  {		
d581 1
a581 1
 *  
d852 1
a852 1
				 type, (unsigned long int)buf1, len1, 
d1481 1
a1481 1
 *  
d1491 1
a1491 1
 *  
d1789 1
a1789 1
		for( j = 0; j < FD_SETSIZE; j++ ) 
d1791 1
a1791 1
			
d1824 1
a1824 1
		
@


14.16.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d48 1
a48 1
 *
d53 1
a53 1
 *
d56 1
a56 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d336 1
a336 1
 *
d366 1
a366 1
 *
d520 1
a520 1
	if(nodelay)  {
d581 1
a581 1
 *
d852 1
a852 1
				 type, (unsigned long int)buf1, len1,
d1481 1
a1481 1
 *
d1491 1
a1491 1
 *
d1551 1
a1552 1
#  else
d1789 1
a1789 1
		for( j = 0; j < FD_SETSIZE; j++ )
d1791 1
a1791 1

d1824 1
a1824 1

@


14.16.2.1
log
@Mods for windows port
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.16 2005/05/28 02:14:51 brlcad Exp $ (BRL)";
a85 1
#  include <fcntl.h>
a162 23
int
pkg_init() {
#ifdef _WIN32
    WORD wVersionRequested;
    WSADATA wsaData;

    wVersionRequested = MAKEWORD(1, 1);
    if (WSAStartup(wVersionRequested, &wsaData) != 0) {
	fprintf(stderr, "pkg_startup:  could not find a usable WinSock DLL" );
	return(-1);
    }
#endif

    return 0; /* good */
}

void
pkg_terminate() {
#ifdef _WIN32
    WSACleanup();
#endif
}

a238 5
#ifdef _WIN32
	LPHOSTENT lpHostEntry;
	register SOCKET netfd;
	SOCKADDR_IN saServer;
#else
a247 1
#endif
a262 40
#ifdef _WIN32
	if ((lpHostEntry = gethostbyname(host)) == NULL) {
	    pkg_perror(errlog, "pkg_open:  gethostbyname");
	    return(-1);
	}

	if ((netfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
	    pkg_perror(errlog, "pkg_open:  socket");
	    return(-1);
	}

#if 0
	_setmode(netfd, _O_BINARY);
#endif

	bzero((char *)&saServer, sizeof(saServer));

	if (atoi(service) > 0) {
	    saServer.sin_port = htons((unsigned short)atoi(service));
	} else {
	    register struct servent *sp;
	    if ((sp = getservbyname(service, "tcp")) == NULL) {
		sprintf(errbuf,"pkg_open(%s,%s): unknown service\n",
			host, service );
		errlog(errbuf);
		return(PKC_ERROR);
	    }
	    saServer.sin_port = sp->s_port;
	}
	saServer.sin_family = AF_INET;
	saServer.sin_addr = *((LPIN_ADDR)*lpHostEntry->h_addr_list);

	if (connect(netfd, (LPSOCKADDR)&saServer, sizeof(struct sockaddr)) == SOCKET_ERROR) {
	    pkg_perror(errlog, "pkg_open:  client connect");
	    closesocket(netfd);
	    return(-1);
	}

	return(pkg_makeconn(netfd, switchp, errlog));
#else
a331 1
#endif
a375 5
	register struct servent *sp;
	int	pkg_listenfd;
#ifdef _WIN32
	SOCKADDR_IN saServer;
#else
d380 1
d383 1
a384 1
#endif
a398 47
#ifdef _WIN32
	bzero((char *)&saServer, sizeof(saServer));

	if (atoi(service) > 0) {
	    saServer.sin_port = htons((unsigned short)atoi(service));
	} else {
	    if ((sp = getservbyname(service, "tcp")) == NULL) {
		sprintf(errbuf,
			"pkg_permserver(%s,%d): unknown service\n",
			service, backlog );
		errlog(errbuf);
		return(-1);
	    }
	    saServer.sin_port = sp->s_port;
	}

	if ((pkg_listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) {
	    pkg_perror(errlog, "pkg_permserver:  socket");
	    return(-1);
	}

#if 0
	_setmode(pkg_listenfd, _O_BINARY);
#endif

	saServer.sin_family = AF_INET;
	saServer.sin_addr.s_addr = INADDR_ANY;

	if (bind(pkg_listenfd, (LPSOCKADDR)&saServer, sizeof(struct sockaddr)) == SOCKET_ERROR) {
	    pkg_perror(errlog, "pkg_permserver: bind");
	    closesocket(pkg_listenfd);

	    return(-1);
	}

	if (backlog > 5)
	    backlog = 5;

	if (listen(pkg_listenfd, backlog) == SOCKET_ERROR) {
	    pkg_perror(errlog, "pkg_permserver:  listen");
	    closesocket(pkg_listenfd);

	    return(-1);
	}

	return(pkg_listenfd);
#else
a461 1
#endif
a503 3
#ifdef _WIN32
		s2 = accept(fd, (struct sockaddr *)NULL, NULL);
#else
a504 1
#endif
a751 3
#ifdef _WIN32
		if ((i = send(pc->pkc_fd, tbuf, len+sizeof(hdr), 0)) != len+sizeof(hdr)) {
#else
a752 1
#endif
a765 3
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, (char *)&hdr, sizeof(hdr), 0)) != sizeof(hdr)) {
#else
a766 1
#endif
a777 3
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, buf, len, 0)) != len) {
#else
a778 1
#endif
a876 3
#ifdef _WIN32
		if ((i = send(pc->pkc_fd, tbuf, len1+len2+sizeof(hdr), 0)) != len1+len2+sizeof(hdr)) {
#else
a877 1
#endif
a890 3
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, (char *)&hdr, sizeof(hdr), 0)) != sizeof(hdr)) {
#else
a891 1
#endif
a904 3
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, buf1, len1, 0)) != len1) {
#else
a905 1
#endif
a919 3
#ifdef _WIN32
	if ((i = send(pc->pkc_fd, buf2, len2, 0)) != len2) {
#else
a920 1
#endif
a1715 3
#ifdef _WIN32
	if ((got = recv(pc->pkc_fd, &pc->pkc_inbuf[pc->pkc_inend], avail, 0)) <= 0) {
#else
a1716 1
#endif
a1727 1
#ifndef _WIN32
a1733 1
#endif
@


14.15
log
@s/syserr/strerror/
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.14 2005/05/01 20:16:24 brlcad Exp $ (BRL)";
d65 1
a65 1
#ifndef WIN32
d75 1
a75 1
#ifndef WIN32
a498 4
#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 1" );
#else
a500 1
#endif
d508 1
a508 1
#ifdef WIN32
a521 6
		#ifdef WIN32
		if( ioctlsocket(fd, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 2" );
		if( ioctlsocket(s2, FIONBIO, &onoff) < 0 )
			pkg_perror( errlog, "pkg_getclient: FIONBIO 3");
#else
a525 1
#endif
a1552 3
#    ifdef WIN32
	sprintf( errbuf, "%s: %s\n", s, _sys_errlist[errno] );
#    else
a1553 1
#    endif
@


14.14
log
@io.h not explicitly needed right now since it's being added by config_win.h
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.13 2005/04/27 03:08:35 brlcad Exp $ (BRL)";
a1562 1
	sprintf( errbuf, "%s: %s\n", s, syserr(errno) );
d1564 1
@


14.13
log
@simplify the strerror junk even more with a little reordering
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.12 2005/04/27 02:50:20 brlcad Exp $ (BRL)";
d64 1
d66 3
a68 3
#undef BSD	/* /usr/include/sys/param.h redefines this */
#include <sys/param.h>
#include <sys/time.h>
d70 1
d72 1
a72 1
#include <time.h>
d74 1
d76 7
a82 7
#include <sys/socket.h>
#include <sys/ioctl.h>		/* for FIONBIO */
#include <netinet/in.h>		/* for htons(), etc */
#include <netdb.h>
#include <netinet/tcp.h>	/* for TCP_NODELAY sockopt */
#include <arpa/inet.h>		/* for inet_addr() */
#undef LITTLE_ENDIAN		/* defined in netinet/{ip.h,tcp.h} */
d84 2
a85 3
#include <io.h>
#include <process.h>
#include <winsock.h>
d89 1
a89 1
#include <string.h>
d91 1
a91 1
#include <strings.h>
d98 1
a98 1
# include <sys/un.h>		/* UNIX Domain sockets */
d103 5
a107 5
# include <sys/h/socket.h>
# include <sys/ioctl.h>
# include <sys/netinet/in.h>
# include <sys/aux/netdb.h>
# include <sys/netinet/tcp.h>
d111 1
a111 1
# include <sys/uio.h>		/* for struct iovec (writev) */
d119 4
a122 4
#	undef	htons
#	define	htons(x)	((((x)&0xFF)<<8)|(((x)>>8)&0xFF))
#	undef	htonl
#	define	htonl(x)	( \
@


14.12
log
@reformat in a way that lets m-x indentation work.. yes, this really should be a bu_strerror or something, ugh.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.11 2005/04/27 02:02:13 brlcad Exp $ (BRL)";
a1544 16

#if HAVE_STRERROR_R
#  define VALID_ERRNO (strlen(errbuf) < MAX_ERRBUF_SIZE)
#else
#  if HAVE_STRERROR
#    define VALID_ERRNO errno < sys_nerr
#  else
#    ifdef WIN32
#      define VALID_ERRNO errno < _sys_nerr
#    else
#      define VALID_ERRNO errno < sys_nerr
#    endif
#  endif
#endif

#if HAVE_STRERROR_R
a1546 1
#endif
d1548 5
a1552 1
	if ( errno >= 0 && VALID_ERRNO ) {
d1555 4
a1558 4
	       	ret = strerror_r(errno, errbuf+strlen(errbuf), MAX_ERRBUF_SIZE-strlen(errbuf));
		if (ret != 0) {
			sprintf(errbuf, "%s: errno=%d\n", s, errno);
		}
d1561 1
a1561 1
		sprintf( errbuf, "%s: %s\n", s, syserr(errno) );
d1564 1
a1564 1
		sprintf( errbuf, "%s: %s\n", s, _sys_errlist[errno] );
d1566 1
a1566 1
		sprintf( errbuf, "%s: %s\n", s, sys_errlist[errno] );
d1570 1
a1570 5
		errlog( errbuf );
	} else {
		sprintf( errbuf, "%s: errno=%d\n", s, errno );
		errlog( errbuf );
	}
@


14.11
log
@and sure enough, solaris sneaks back into the picture so it's time to refix the sys_errlist problem.  solaris wants strerror, win32 can use _sys_errlist.  these should eventually get refactored into some sort of libbu facility/macro some day.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.10 2005/03/28 16:47:37 brlcad Exp $ (BRL)";
d1547 14
d1563 5
a1567 1
	if ((errno >= 0) && (strlen(errbuf) < MAX_ERRBUF_SIZE)) {
d1573 4
a1576 2
#  ifdef WIN32
	if ( errno >= 0 && errno < _sys_nerr ) {
d1578 1
a1578 2
#  else
	if ( errno >= 0 && errno < sys_nerr ) {
d1580 1
@


14.10
log
@make HAVE_SYS_ERRLIST_DECL go away.  there's a better way to check for it, so fix when solaris returns to the rotation (where it'll probably be a problem).  windows gets _sys_errlist from stdlib.h so make sure that's included too.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.9 2005/03/28 05:52:27 bob1961 Exp $ (BRL)";
d1555 1
a1555 1
#ifdef WIN32
d1558 1
a1558 1
#else
d1561 1
a1561 1
#endif
@


14.9
log
@If Windows, use _sys_nerr and _sys_errlist
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.8 2005/03/24 16:20:12 bob1961 Exp $ (BRL)";
a60 1

a126 6
#if !HAVE_SYS_ERRLIST_DECL
#ifndef WIN32
extern int      sys_nerr;
extern char     *sys_errlist[];
#endif
#endif
@


14.8
log
@If Windows, use _sys_nerr, and _sys_errlist
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.7 2005/03/16 07:25:05 brlcad Exp $ (BRL)";
d129 1
a129 4
#ifdef WIN32
extern int      _sys_nerr;
extern char     *_sys_errlist[];
#else
@


14.7
log
@potentially requires sys_errlist, so need optional extern declarations.
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.6 2005/01/30 20:30:56 brlcad Exp $ (BRL)";
d129 4
d136 1
d1565 4
d1572 1
@


14.6
log
@update copyright to 2005
@
text
@d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libpkg/pkg.c,v 14.5 2004/12/21 07:18:58 morrison Exp $ (BRL)";
d128 5
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libpkg/pkg.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a53 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
d56 1
a56 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libpkg/pkg.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libpkg/pkg.c,v 14.2 2004/12/21 02:32:07 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libpkg/pkg.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			P K G . C
d58 1
a58 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libpkg/pkg.c,v 1.5 2004/09/15 05:53:08 morrison Exp $ (BRL)";
@


1.5
log
@print out address value with %lx instead to preserve potentially 64-bit addresses (ia64 quell)
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libpkg/pkg.c,v 1.4 2004/09/08 19:15:09 kermit Exp $ (BRL)";
d1828 10
@


1.4
log
@Added missing <stdlib.h>.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libpkg/pkg.c,v 1.3 2004/08/02 23:01:49 morrison Exp $ (BRL)";
d844 3
a846 3
				"pkg_send2(type=%d, buf1=x%x, len1=%d, buf2=x%x, len2=%d, pc=x%x)\n",
				 type, (unsigned int)buf1, len1, 
				 (unsigned int)buf2, len2, (unsigned int)pc );
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libpkg/pkg.c,v 1.2 2004/06/08 22:04:24 morrison Exp $ (BRL)";
d45 1
a45 1

@


1.2
log
@obliterate externs.h
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d42 1
a42 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libpkg/pkg.c,v 11.14 2004/05/10 15:30:45 erikg Exp $ (BRL)";
a78 1
#include "externs.h"
@

