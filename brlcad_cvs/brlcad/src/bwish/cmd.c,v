head	14.16;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.8
	rel-7-10-2:14.15
	rel-7-10-0:14.15
	rel-7-8-4:14.13
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.11
	bobWinPort-20051223-freeze:14.10
	postmerge-20051223-bobWinPort:14.11
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.10
	rel-7-6-branch:14.10.0.6
	rel-7-6-0:14.10
	rel-7-4-2:14.10
	rel-7-4-branch:14.10.0.4
	bobWinPort:14.10.0.2
	rel-7-4-0:14.10
	rel-7-2-6:14.10
	rel-7-2-4:14.10
	rel-7-2-2:14.8
	rel-7-2-0:14.8
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.16
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.24;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.04.06.19.21.06;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.05.03.05.18.31;	author brlcad;	state Exp;
branches
	14.10.6.1;
next	14.9;

14.9
date	2005.04.25.07.05.00;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.02.14.03.41.36;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.01.30.20.30.17;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.07.25.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.44.31;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.49;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.01.54.48;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.24.21.33.38;	author erikg;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.07;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.45;	author morrison;	state Exp;
branches;
next	;

14.10.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2006.04.07.19.26.25;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                           C M D . C
 * BRL-CAD
 *
 * Copyright (c) 1998-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file cmd.c
 *
 * This is the place where BWISH/BTCLSH's commands live.
 * The history routines were borrowed from mged/history.c
 * and modified for use in this application.
 *
 *  Author -
 *	   Robert G. Parker
 *
 *  Authors of mged/history.c -
 *	   Glenn Durfee
 *	   Bob Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */

#include "common.h"

#include <stdlib.h>
#include <string.h>

#ifdef BWISH
#  include "tk.h"
#else
#  include "tcl.h"
#endif

#include "machine.h"
#include "cmd.h"
#include "libtermio.h"


/* defined in tcl.c */
extern void Cad_Exit(int status);

HIDDEN void historyInit(void);
HIDDEN int cmd_history(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
HIDDEN int cmd_hist(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
HIDDEN int cmd_quit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

HIDDEN struct bu_cmdhist histHead;
HIDDEN struct bu_cmdhist *currHist;

HIDDEN struct bu_cmdtab bwish_cmds[] =
    {
	{"exit",		cmd_quit},
	{"history",		cmd_history},
	{"hist",		cmd_hist},
	{"q",			cmd_quit},
	{(char *)NULL,		CMD_NULL}
    };

#ifdef BWISH
extern Tk_PhotoImageFormat tkImgFmtPIX;
#endif

int
cmdInit(Tcl_Interp *interp)
{
    /* Register bwish/btclsh commands */
    bu_register_cmds(interp, bwish_cmds);

#ifdef BWISH
    /* Add pix format for images */
    Tk_CreatePhotoImageFormat(&tkImgFmtPIX);
#endif

    /* initialize command history */
    historyInit();
    return TCL_OK;
}

/***************************** BWISH/BTCLSH COMMANDS *****************************/

HIDDEN int
cmd_quit(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
    int status;

    if (argc == 2)
	status = atoi(argv[1]);
    else
	status = 0;

    Cad_Exit(status);

    /* NOT REACHED */
    return TCL_OK;
}

/***************************** BWISH/BTCLSH COMMAND HISTORY *****************************/

HIDDEN int historyInitialized=0;
HIDDEN void
historyInit(void)
{
    BU_LIST_INIT(&(histHead.l));
    bu_vls_init(&(histHead.h_command));
    histHead.h_start.tv_sec = histHead.h_start.tv_usec =
	histHead.h_finish.tv_sec = histHead.h_finish.tv_usec = 0L;
    histHead.h_status = TCL_OK;
    currHist = &histHead;
#if 0
    journalfp = NULL;
#endif
    historyInitialized=1;
}

/*
 *	H I S T O R Y _ R E C O R D
 *
 *	Stores the given command with start and finish times in the
 *	history vls'es.
 */
void
history_record(struct bu_vls *cmdp, struct timeval *start, struct timeval *finish, int status)


     /* Either TCL_OK or TCL_ERROR */
{
    struct bu_cmdhist *new_hist;

    if (strcmp(bu_vls_addr(cmdp), "\n") == 0)
	return;

    new_hist = (struct bu_cmdhist *)bu_malloc(sizeof(struct bu_cmdhist),
					      "mged history");
    bu_vls_init(&(new_hist->h_command));
    bu_vls_vlscat(&(new_hist->h_command), cmdp);
    new_hist->h_start = *start;
    new_hist->h_finish = *finish;
    new_hist->h_status = status;

    /* make sure the list is initialized before attempting to add this entry */
    if (!historyInitialized) {
	historyInit();
    }

    BU_LIST_INSERT(&(histHead.l), &(new_hist->l));

    /* As long as this isn't our first command to record after setting
       up the journal (which would be "journal", which we don't want
       recorded!)... */

#if 0
    if (journalfp != NULL && !firstjournal)
	history_journalize(new_hist);
#endif

    currHist = &histHead;
#if 0
    firstjournal = 0;
#endif
}

HIDDEN int
timediff(struct timeval *tvdiff, struct timeval *start, struct timeval *finish)
{
    if (finish->tv_sec == 0 && finish->tv_usec == 0)
	return -1;
    if (start->tv_sec == 0 && start->tv_usec == 0)
	return -1;

    tvdiff->tv_sec = finish->tv_sec - start->tv_sec;
    tvdiff->tv_usec = finish->tv_usec - start->tv_usec;
    if (tvdiff->tv_usec < 0) {
	--tvdiff->tv_sec;
	tvdiff->tv_usec += 1000000L;
    }

    return 0;
}

#if 0
void
history_journalize(hptr)
     struct bu_cmdhist *hptr;
{
    struct timeval tvdiff;
    struct bu_cmdhist *lasthptr;

    lasthptr = BU_LIST_PREV(bu_cmdhist, &(hptr->l));

    if (journal_delay && timediff(&tvdiff, &(lasthptr->h_finish), &(hptr->h_start)) >= 0)
	fprintf(journalfp, "delay %d %ld\n", tvdiff.tv_sec, tvdiff.tv_usec);

    if (hptr->h_status == TCL_ERROR)
	fprintf(journalfp, "# ");
    fprintf(journalfp, "%s", bu_vls_addr(&hptr->h_command));

    if (journal_delay)
	fprintf(journalfp, "mged_update 1\n");
}

/*
 *	F _ J O U R N A L
 *
 *	Opens the journal file, so each command and the time since the previous
 *	  one will be recorded.  Or, if called with no arguments, closes the
 *	  journal file.
 */
int
cmd_journal(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
{
    if(argc < 1 || 3 < argc){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help journal");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    /* close previously open journal file */
    if (journalfp != NULL) {
	fclose(journalfp);
	journalfp = NULL;
    }
    journal_delay = 0;

    if (argc < 2)
	return TCL_OK;

    if(argv[1][0] == '-' && argv[1][1] == 'd'){
	journal_delay = 1;
	++argv;
	--argc;
    }

    if (argc < 2) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help journal");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    journalfp = fopen(argv[1], "a+");
    if (journalfp == NULL) {
	Tcl_AppendResult(interp, "Error opening ", argv[1],
			 " for appending\n", (char *)NULL);
	return TCL_ERROR;
    }
    firstjournal = 1;

    return TCL_OK;
}

/*
 *	F _ D E L A Y
 *
 * 	Uses select to delay for the specified amount of seconds and
 *	  microseconds.
 */

int
f_delay(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
{
    struct timeval tv;

    if(argc < 3 || 3 < argc){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help delay");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    tv.tv_sec = atoi(argv[1]);
    tv.tv_usec = atoi(argv[2]);
    select(0, NULL, NULL, NULL, &tv);

    return TCL_OK;
}
#endif

/*
 *	F _ H I S T O R Y
 *
 *	Prints out the command history, either to bu_log or to a file.
 */

int
cmd_history(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    FILE *fp;
    int with_delays = 0;
    struct bu_cmdhist *hp, *hp_prev;
    struct bu_vls str;
    struct timeval tvdiff;

    if (argc < 1 || 4 < argc) {
	Tcl_AppendResult(interp, "history [-delays] [-outfile file]\n\tlist command history", (char *)0);
	return TCL_ERROR;
    }

    fp = NULL;
    while (argc > 1) {
	if (strcmp(argv[1], "-delays") == 0)
	    with_delays = 1;
	else if (strcmp(argv[1], "-outfile") == 0) {
	    if (fp != NULL) {
		fclose(fp);
		Tcl_AppendResult(interp, "history: -outfile option given more than once\n",
				 (char *)NULL);
		return TCL_ERROR;
	    } else if (argc < 3 || strcmp(argv[2], "-delays") == 0) {
		Tcl_AppendResult(interp, "history: I need a file name\n", (char *)NULL);
		return TCL_ERROR;
	    } else {
		fp = fopen( argv[2], "a+" );
		if (fp == NULL) {
		    Tcl_AppendResult(interp, "history: error opening file", (char *)NULL);
		    return TCL_ERROR;
		}
		--argc;
		++argv;
	    }
	} else {
	    Tcl_AppendResult(interp, "Invalid option ", argv[1], "\n", (char *)NULL);
	}

	--argc;
	++argv;
    }

    bu_vls_init(&str);
    for (BU_LIST_FOR(hp, bu_cmdhist, &(histHead.l))) {
	bu_vls_trunc(&str, 0);
	hp_prev = BU_LIST_PREV(bu_cmdhist, &(hp->l));
	if (with_delays && BU_LIST_NOT_HEAD(hp_prev, &(histHead.l))) {
	    if (timediff(&tvdiff, &(hp_prev->h_finish), &(hp->h_start)) >= 0)
		bu_vls_printf(&str, "delay %ld %ld\n", (long)tvdiff.tv_sec,
			      (long)tvdiff.tv_usec);
	}

	if (hp->h_status == TCL_ERROR)
	    bu_vls_printf(&str, "# ");
	bu_vls_vlscat(&str, &(hp->h_command));

	if (fp != NULL)
	    bu_vls_fwrite(fp, &str);
	else
	    Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
    }

    if (fp != NULL)
	fclose(fp);

    return TCL_OK;
}

/*
 *      H I S T O R Y _ P R E V
 */
struct bu_vls *
history_prev(void)
{
    struct bu_cmdhist *hp;

    hp = BU_LIST_PREV(bu_cmdhist, &(currHist->l));
    if (BU_LIST_IS_HEAD(hp, &(histHead.l)))
	return NULL;
    else {
	currHist = hp;
	return &(hp->h_command);
    }
}

/*
 *      H I S T O R Y _ C U R
 */
struct bu_vls *
history_cur(void)
{
    if (BU_LIST_IS_HEAD(currHist, &(histHead.l)))
	return NULL;
    else
	return &(currHist->h_command);
}

/*
 *      H I S T O R Y _ N E X T
 */
struct bu_vls *
history_next(void)
{
    struct bu_cmdhist *hp;

    if (BU_LIST_IS_HEAD(currHist, &(histHead.l))) {
	return 0;
    }

    hp = BU_LIST_NEXT(bu_cmdhist, &(currHist->l));
    if (BU_LIST_IS_HEAD(hp, &(histHead.l))) {
	currHist = hp;
	return 0;
    } else {
	currHist = hp;
	return &(hp->h_command);
    }
}

int
cmd_hist(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    struct bu_vls *vp;
    struct bu_vls vls;

    bu_vls_init(&vls);

    if(argc < 2){
	Tcl_AppendResult(interp, "hist command\n\troutine for maintaining command history", (char *)0);
	return TCL_ERROR;
    }

    if(strcmp(argv[1], "add") == 0){
	struct timeval zero;

	if(argc != 3){
	    Tcl_AppendResult(interp, "hist add command\n\tadd command to history", (char *)0);
	    return TCL_ERROR;
	}

	if (argv[2][0] == '\n' || argv[2][0] == '\0')
	    return TCL_OK;

	bu_vls_strcpy(&vls, argv[2]);
	if (argv[2][strlen(argv[2])-1] != '\n')
	    bu_vls_putc(&vls, '\n');

	zero.tv_sec = zero.tv_usec = 0L;
	history_record(&vls, &zero, &zero, TCL_OK);

	bu_vls_free(&vls);
	return TCL_OK;
    }

    if(strcmp(argv[1], "next") == 0){
	if(argc != 2){
	    Tcl_AppendResult(interp, "hist next\n\treturn next command in history", (char *)0);
	    return TCL_ERROR;
	}

	vp = history_next();
	if (vp == NULL)
	    return TCL_ERROR;

	Tcl_AppendResult(interp, bu_vls_addr(vp), (char *)NULL);
	bu_vls_free(&vls);
	return TCL_OK;
    }

    if(strcmp(argv[1], "prev") == 0){
	if(argc != 2){
	    Tcl_AppendResult(interp, "hist prev\n\treturn previous command in history", (char *)0);
	    return TCL_ERROR;
	}

	vp = history_prev();
	if (vp == NULL)
	    return TCL_ERROR;

	Tcl_AppendResult(interp, bu_vls_addr(vp), (char *)NULL);
	bu_vls_free(&vls);
	return TCL_OK;
    }

    Tcl_AppendResult(interp, "hist command\n\troutine for maintaining command history", (char *)0);
    return TCL_ERROR;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d43 1
a43 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.14
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.13
log
@quell warnings from intel compiler, use long type
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2006 United States Government as represented by
@


14.12
log
@update copyright to 2006
@
text
@d43 1
d377 2
a378 2
		bu_vls_printf(&str, "delay %d %d\n", tvdiff.tv_sec,
			      tvdiff.tv_usec);
@


14.12.2.1
log
@update from HEAD
@
text
@a42 1
#include <stdlib.h>
d376 2
a377 2
		bu_vls_printf(&str, "delay %ld %ld\n", (long)tvdiff.tv_sec,
			      (long)tvdiff.tv_usec);
@


14.11
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1998-2005 United States Government as represented by
@


14.10
log
@more config.h references converted to brlcad_config.h (or common.h where appropriate) that apparently slipped under the radar
@
text
@d38 1
a38 1
 *  
d147 2
a148 2
                         
                                    
d193 1
a193 1
    
d289 1
a289 1
 * 	Uses select to delay for the specified amount of seconds and 
d436 1
a436 1
    
@


14.10.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d38 1
a38 1
 *
d147 2
a148 2


d193 1
a193 1

d289 1
a289 1
 * 	Uses select to delay for the specified amount of seconds and
d436 1
a436 1

@


14.9
log
@make sure the command list is initialized before attempting to add an entry.  if cmdInit() has some step that fails for any particular reason, it returns early.  this was causing the crash (for example when incrtcl or incrtk failed to locate their startup script) and probably should be rethought, though the 'broken install' case is rather abnormal and unsupported.
@
text
@a40 4
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

@


14.8
log
@M-x indent-region
@
text
@d48 1
a48 1
#include <string.h>
d50 1
a50 1
#include <strings.h>
d54 1
a54 1
#include "tk.h"
d56 1
a56 1
#include "tcl.h"
d63 1
d127 1
d140 1
d167 6
@


14.7
log
@update copyright to 2005
@
text
@d75 1
a75 1
{
d81 1
a81 1
};
d90 2
a91 2
	/* Register bwish/btclsh commands */
	bu_register_cmds(interp, bwish_cmds);
d94 2
a95 2
	/* Add pix format for images */
	Tk_CreatePhotoImageFormat(&tkImgFmtPIX);
d98 3
a100 3
	/* initialize command history */
	historyInit();
	return TCL_OK;
d111 1
a111 1
	int status;
d113 4
a116 4
	if (argc == 2)
		status = atoi(argv[1]);
	else
		status = 0;
d118 1
a118 1
	Cad_Exit(status);
d120 2
a121 2
	/* NOT REACHED */
	return TCL_OK;
d129 6
a134 6
	BU_LIST_INIT(&(histHead.l));
	bu_vls_init(&(histHead.h_command));
	histHead.h_start.tv_sec = histHead.h_start.tv_usec =
		histHead.h_finish.tv_sec = histHead.h_finish.tv_usec = 0L;
	histHead.h_status = TCL_OK;
	currHist = &histHead;
d136 1
a136 1
	journalfp = NULL;
d150 1
a150 1
                   /* Either TCL_OK or TCL_ERROR */
d152 1
a152 1
	struct bu_cmdhist *new_hist;
d154 2
a155 2
	if (strcmp(bu_vls_addr(cmdp), "\n") == 0)
		return;
d157 12
a168 12
	new_hist = (struct bu_cmdhist *)bu_malloc(sizeof(struct bu_cmdhist),
					       "mged history");
	bu_vls_init(&(new_hist->h_command));
	bu_vls_vlscat(&(new_hist->h_command), cmdp);
	new_hist->h_start = *start;
	new_hist->h_finish = *finish;
	new_hist->h_status = status;
	BU_LIST_INSERT(&(histHead.l), &(new_hist->l));

	/* As long as this isn't our first command to record after setting
	   up the journal (which would be "journal", which we don't want
	   recorded!)... */
d171 2
a172 2
	if (journalfp != NULL && !firstjournal)
		history_journalize(new_hist);
d175 1
a175 1
	currHist = &histHead;
d177 1
a177 1
	firstjournal = 0;
d184 4
a187 4
	if (finish->tv_sec == 0 && finish->tv_usec == 0)
		return -1;
	if (start->tv_sec == 0 && start->tv_usec == 0)
		return -1;
d189 6
a194 6
	tvdiff->tv_sec = finish->tv_sec - start->tv_sec;
	tvdiff->tv_usec = finish->tv_usec - start->tv_usec;
	if (tvdiff->tv_usec < 0) {
		--tvdiff->tv_sec;
		tvdiff->tv_usec += 1000000L;
	}
d196 1
a196 1
	return 0;
d204 2
a205 2
	struct timeval tvdiff;
	struct bu_cmdhist *lasthptr;
d207 1
a207 1
	lasthptr = BU_LIST_PREV(bu_cmdhist, &(hptr->l));
d209 2
a210 2
	if (journal_delay && timediff(&tvdiff, &(lasthptr->h_finish), &(hptr->h_start)) >= 0)
		fprintf(journalfp, "delay %d %ld\n", tvdiff.tv_sec, tvdiff.tv_usec);
d212 3
a214 3
	if (hptr->h_status == TCL_ERROR)
		fprintf(journalfp, "# ");
	fprintf(journalfp, "%s", bu_vls_addr(&hptr->h_command));
d216 2
a217 2
	if (journal_delay)
		fprintf(journalfp, "mged_update 1\n");
d234 2
a235 2
	if(argc < 1 || 3 < argc){
		struct bu_vls vls;
d237 6
a242 6
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help journal");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d244 6
a249 6
	/* close previously open journal file */
	if (journalfp != NULL) {
		fclose(journalfp);
		journalfp = NULL;
	}
	journal_delay = 0;
d251 2
a252 2
	if (argc < 2)
		return TCL_OK;
d254 5
a258 5
	if(argv[1][0] == '-' && argv[1][1] == 'd'){
		journal_delay = 1;
		++argv;
		--argc;
	}
d260 2
a261 2
	if (argc < 2) {
		struct bu_vls vls;
d263 6
a268 6
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help journal");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d270 7
a276 7
	journalfp = fopen(argv[1], "a+");
	if (journalfp == NULL) {
		Tcl_AppendResult(interp, "Error opening ", argv[1],
				 " for appending\n", (char *)NULL);
		return TCL_ERROR;
	}
	firstjournal = 1;
d278 1
a278 1
	return TCL_OK;
d295 1
a295 1
	struct timeval tv;
d297 2
a298 2
	if(argc < 3 || 3 < argc){
		struct bu_vls vls;
d300 6
a305 6
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help delay");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}
d307 3
a309 3
	tv.tv_sec = atoi(argv[1]);
	tv.tv_usec = atoi(argv[2]);
	select(0, NULL, NULL, NULL, &tv);
d311 1
a311 1
	return TCL_OK;
d324 5
a328 5
	FILE *fp;
	int with_delays = 0;
	struct bu_cmdhist *hp, *hp_prev;
	struct bu_vls str;
	struct timeval tvdiff;
d330 17
a346 2
	if (argc < 1 || 4 < argc) {
		Tcl_AppendResult(interp, "history [-delays] [-outfile file]\n\tlist command history", (char *)0);
d348 5
a352 26
	}

	fp = NULL;
	while (argc > 1) {
		if (strcmp(argv[1], "-delays") == 0)
			with_delays = 1;
		else if (strcmp(argv[1], "-outfile") == 0) {
			if (fp != NULL) {
				fclose(fp);
				Tcl_AppendResult(interp, "history: -outfile option given more than once\n",
						 (char *)NULL);
				return TCL_ERROR;
			} else if (argc < 3 || strcmp(argv[2], "-delays") == 0) {
				Tcl_AppendResult(interp, "history: I need a file name\n", (char *)NULL);
				return TCL_ERROR;
			} else {
				fp = fopen( argv[2], "a+" );
				if (fp == NULL) {
					Tcl_AppendResult(interp, "history: error opening file", (char *)NULL);
					return TCL_ERROR;
				}
				--argc;
				++argv;
			}
		} else {
			Tcl_AppendResult(interp, "Invalid option ", argv[1], "\n", (char *)NULL);
a353 1

d356 3
d361 17
a377 9
	bu_vls_init(&str);
	for (BU_LIST_FOR(hp, bu_cmdhist, &(histHead.l))) {
		bu_vls_trunc(&str, 0);
		hp_prev = BU_LIST_PREV(bu_cmdhist, &(hp->l));
		if (with_delays && BU_LIST_NOT_HEAD(hp_prev, &(histHead.l))) {
			if (timediff(&tvdiff, &(hp_prev->h_finish), &(hp->h_start)) >= 0)
				bu_vls_printf(&str, "delay %d %d\n", tvdiff.tv_sec,
					      tvdiff.tv_usec);
		}
d379 5
a383 9
		if (hp->h_status == TCL_ERROR)
			bu_vls_printf(&str, "# ");
		bu_vls_vlscat(&str, &(hp->h_command));

		if (fp != NULL)
			bu_vls_fwrite(fp, &str);
		else
			Tcl_AppendResult(interp, bu_vls_addr(&str), (char *)NULL);
	}
d385 2
a386 2
	if (fp != NULL)
		fclose(fp);
d388 1
a388 1
	return TCL_OK;
d397 1
a397 1
	struct bu_cmdhist *hp;
d399 7
a405 7
	hp = BU_LIST_PREV(bu_cmdhist, &(currHist->l));
	if (BU_LIST_IS_HEAD(hp, &(histHead.l)))
		return NULL;
	else {
		currHist = hp;
		return &(hp->h_command);
	}
d414 4
a417 4
	if (BU_LIST_IS_HEAD(currHist, &(histHead.l)))
		return NULL;
	else
		return &(currHist->h_command);
d426 1
a426 1
	struct bu_cmdhist *hp;
d428 3
a430 3
	if (BU_LIST_IS_HEAD(currHist, &(histHead.l))) {
		return 0;
	}
d432 8
a439 8
	hp = BU_LIST_NEXT(bu_cmdhist, &(currHist->l));
	if (BU_LIST_IS_HEAD(hp, &(histHead.l))) {
		currHist = hp;
		return 0;
	} else {
		currHist = hp;
		return &(hp->h_command);
	}
d445 9
a453 2
	struct bu_vls *vp;
	struct bu_vls vls;
d455 2
a456 1
	bu_vls_init(&vls);
d458 3
a460 3
	if(argc < 2){
		Tcl_AppendResult(interp, "hist command\n\troutine for maintaining command history", (char *)0);
		return TCL_ERROR;
d463 2
a464 2
	if(strcmp(argv[1], "add") == 0){
		struct timeval zero;
d466 3
a468 4
		if(argc != 3){
			Tcl_AppendResult(interp, "hist add command\n\tadd command to history", (char *)0);
			return TCL_ERROR;
		}
d470 2
a471 2
		if (argv[2][0] == '\n' || argv[2][0] == '\0')
			return TCL_OK;
d473 3
a475 3
		bu_vls_strcpy(&vls, argv[2]);
		if (argv[2][strlen(argv[2])-1] != '\n')
			bu_vls_putc(&vls, '\n');
d477 5
a481 2
		zero.tv_sec = zero.tv_usec = 0L;
		history_record(&vls, &zero, &zero, TCL_OK);
d483 3
a485 3
		bu_vls_free(&vls);
		return TCL_OK;
	}
d487 4
a490 5
	if(strcmp(argv[1], "next") == 0){
		if(argc != 2){
			Tcl_AppendResult(interp, "hist next\n\treturn next command in history", (char *)0);
			return TCL_ERROR;
		}
d492 4
a495 7
		vp = history_next();
		if (vp == NULL)
			return TCL_ERROR;

		Tcl_AppendResult(interp, bu_vls_addr(vp), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
d498 3
a500 5
	if(strcmp(argv[1], "prev") == 0){
		if(argc != 2){
			Tcl_AppendResult(interp, "hist prev\n\treturn previous command in history", (char *)0);
			return TCL_ERROR;
		}
d502 4
a505 8
		vp = history_prev();
		if (vp == NULL)
			return TCL_ERROR;

		Tcl_AppendResult(interp, bu_vls_addr(vp), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}
d507 2
a508 2
	Tcl_AppendResult(interp, "hist command\n\troutine for maintaining command history", (char *)0);
	return TCL_ERROR;
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 United States Government as represented by
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a38 2
 *
 *
@


14.4
log
@remove the old distribution notice section
@
text
@a39 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a38 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file cmd.c
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *				C M D . C
@


1.5
log
@use config.h
@
text
@d499 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d30 4
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d32 1
a32 2

#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d30 1
a30 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a47 1
#include "externs.h"
@

