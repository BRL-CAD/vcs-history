head	14.16;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.8
	rel-7-10-2:14.15
	rel-7-10-0:14.14
	rel-7-8-4:14.12
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.6
	rel-7-6-0:14.9
	rel-7-4-2:14.9
	rel-7-4-branch:14.9.0.4
	bobWinPort:14.9.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.9
	rel-7-2-4:14.9
	rel-7-2-2:14.8
	rel-7-2-0:14.8
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.7
	rel-7-0-branch:1.7.0.2
	rel-7-0:1.7;
locks; strict;
comment	@ * @;


14.16
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.06.18.04.48.11;	author johnranderson;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.24;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.07.09.09.12.16;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.05.03.05.18.31;	author brlcad;	state Exp;
branches
	14.9.6.1;
next	14.8;

14.8
date	2005.02.14.03.41.36;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.01.30.20.30.17;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.07.25.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.44.31;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.49;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.01.54.48;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.24.21.33.38;	author erikg;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.09.19.26.29;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.17.40.09;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.07;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.45;	author morrison;	state Exp;
branches;
next	;

14.9.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                         I N P U T . C
 * BRL-CAD
 *
 * Copyright (c) 1998-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file input.c
 *
 * Input handling routines. Some of this code was borrowed from mged/ged.c
 * and modified for use in this application.
 *
 *  Author -
 *	  Robert G. Parker
 *
 *  Authors of mged/ged.c -
 *	Michael John Muuss
 *	Charles M Kennedy
 *	Douglas A Gwyn
 *	Bob Suckling
 *	Gary Steven Moss
 *	Earl P Weaver
 *	Phil Dykstra
 *	Bob Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */

#include "common.h"

/* system headers */
#include <string.h>
#include <ctype.h>
#include <time.h>
#if defined(IRIX) && IRIX == 5
#  define _BSD_COMPAT
#endif
#include <sys/time.h>
#if defined(HAVE_UNISTD_H)
#  include <unistd.h>
#else
#  if defined(HAVE_SYS_UNISTD_H)
#    include <sys/unistd.h>
#  endif
#endif

/* interface headers */
#include "tcl.h"
#include "machine.h"
#include "bu.h"
#include "libtermio.h"


#define CTRL_A      1
#define CTRL_B      2
#define CTRL_D      4
#define CTRL_E      5
#define CTRL_F      6
#define CTRL_K      11
#define CTRL_L      12
#define CTRL_N      14
#define CTRL_P      16
#define CTRL_T      20
#define CTRL_U      21
#define CTRL_W      '\027'
#define ESC         27
#define BACKSPACE   '\b'
#define DELETE      127
#ifdef BWISH
#define PROMPT "\rbwish> "
#else
#define PROMPT "\rbtclsh> "
#endif

#define SPACES "                                                                                                                                                                                                                                                                                                           "

/* defined in tcl.c */
extern void Cad_Exit(int status);

/* defined in cmd.c */
extern struct bu_vls *history_prev(void);
extern struct bu_vls *history_next(void);
extern void history_record(struct bu_vls *cmdp, struct timeval *start, struct timeval *finish, int status);

/* defined in main.c */
extern Tcl_Interp *interp;

HIDDEN void inputHandler(ClientData clientData, int mask);
HIDDEN void processChar(char ch);
HIDDEN void insert_prompt(void);
HIDDEN void insert_char(char ch);
HIDDEN void insert_beep(void);

HIDDEN struct bu_vls input_str;
HIDDEN struct bu_vls input_str_prefix;
HIDDEN int input_str_index;
HIDDEN struct bu_vls scratchline;
HIDDEN struct bu_vls prompt;

void
initInput(void)
{
    bu_vls_init(&input_str);
    bu_vls_init(&input_str_prefix);
    bu_vls_init(&scratchline);
    bu_vls_init(&prompt);
    input_str_index = 0;

    Tcl_CreateFileHandler(STDIN_FILENO, TCL_READABLE,
			  inputHandler, (ClientData)STDIN_FILENO);

    bu_vls_strcpy(&prompt, PROMPT);
    save_Tty(fileno(stdin));
    set_Cbreak(fileno(stdin));
    clr_Echo(fileno(stdin));
    insert_prompt();
}

HIDDEN void
inputHandler(ClientData clientData, int mask)
{
    int count;
    char ch;
    long fd;
    char buf[4096];
    int index;

    fd = (long)clientData;

    count = read((int)fd, (void *)buf, 4096);

    if (count < 0) {
	perror("READ ERROR");
    }
    if (count <= 0 && feof(stdin)) {
	Cad_Exit(TCL_OK);
    }

    /* Process everything in buf */
    for (index = 0, ch = buf[index]; index < count; ch = buf[++index])
	processChar(ch);
}

/* Process character */
HIDDEN void
processChar(char ch)
{
    struct bu_vls *vp;
    struct bu_vls temp;
    static int escaped = 0;
    static int bracketed = 0;
    static int freshline = 1;

    /* ANSI arrow keys */
    if (escaped && bracketed) {
	if (ch == 'A') ch = CTRL_P;
	if (ch == 'B') ch = CTRL_N;
	if (ch == 'C') ch = CTRL_F;
	if (ch == 'D') ch = CTRL_B;
	escaped = bracketed = 0;
    }

    switch (ch) {
    case ESC:           /* Used for building up ANSI arrow keys */
	escaped = 1;
	break;
    case '\n':          /* Carriage return or line feed */
    case '\r':
	bu_log("\n");   /* Display newline */

	bu_vls_printf(&input_str_prefix, "%s%S\n",
		      bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		      &input_str);

	/* If this forms a complete command (as far as the Tcl parser is
	   concerned) then execute it. */
	if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
	    int status;
	    struct timeval start, finish;
	    const char *result;

	    reset_Tty(fileno(stdin));
	    gettimeofday(&start, (struct timezone *)NULL);
	    status = Tcl_Eval(interp, bu_vls_addr(&input_str_prefix));
	    gettimeofday(&finish, (struct timezone *)NULL);
	    result = Tcl_GetStringResult(interp);
	    if (strlen(result))
		bu_log("%s\n", result);

	    history_record(&input_str_prefix, &start, &finish, status);
	    bu_vls_trunc(&input_str_prefix, 0);
	    bu_vls_trunc(&input_str, 0);
	    set_Cbreak(fileno(stdin)); /* Back to single-character mode */
	    clr_Echo(fileno(stdin));

	    /* reset prompt */
	    bu_vls_strcpy(&prompt, PROMPT);

	} else {
	    bu_vls_trunc(&input_str, 0);
	    bu_vls_strcpy(&prompt, "\r? ");
	}
	insert_prompt();
	input_str_index = 0;
	freshline = 1;
	escaped = bracketed = 0;
	break;
    case BACKSPACE:
    case DELETE:
	if (input_str_index <= 0) {
	    insert_beep();
	    break;
	}

	if (input_str_index == bu_vls_strlen(&input_str)) {
	    bu_log("\b \b");
	    bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1);
	} else {
	    bu_vls_init(&temp);
	    bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
	    bu_vls_trunc(&input_str, input_str_index-1);
	    bu_log("\b%S ", &temp);
	    insert_prompt();
	    bu_log("%S", &input_str);
	    bu_vls_vlscat(&input_str, &temp);
	    bu_vls_free(&temp);
	}
	--input_str_index;
	escaped = bracketed = 0;
	break;
    case CTRL_A:                    /* Go to beginning of line */
	insert_prompt();
	input_str_index = 0;
	escaped = bracketed = 0;
	break;
    case CTRL_E:                    /* Go to end of line */
	if (input_str_index < bu_vls_strlen(&input_str)) {
	    bu_log("%s", bu_vls_addr(&input_str)+input_str_index);
	    input_str_index = bu_vls_strlen(&input_str);
	}
	escaped = bracketed = 0;
	break;
    case CTRL_D:                    /* Delete character at cursor */
	if (input_str_index == bu_vls_strlen(&input_str)) {
	    insert_beep(); /* Beep if at end of input string */
	    break;
	}
	bu_vls_init(&temp);
	bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index+1);
	bu_vls_trunc(&input_str, input_str_index);
	bu_log("%S ", &temp);
	insert_prompt();
	bu_log("%S", &input_str);
	bu_vls_vlscat(&input_str, &temp);
	bu_vls_free(&temp);
	escaped = bracketed = 0;
	break;
    case CTRL_U:                   /* Delete whole line */
	insert_prompt();
	bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
	insert_prompt();
	bu_vls_trunc(&input_str, 0);
	input_str_index = 0;
	escaped = bracketed = 0;
	break;
    case CTRL_K:                    /* Delete to end of line */
	bu_log("%*s", bu_vls_strlen(&input_str)-input_str_index, SPACES);
	bu_vls_trunc(&input_str, input_str_index);
	insert_prompt();
	bu_log("%S", &input_str);
	escaped = bracketed = 0;
	break;
    case CTRL_L:                   /* Redraw line */
	bu_log("\n");
	insert_prompt();
	bu_log("%S", &input_str);
	if (input_str_index == bu_vls_strlen(&input_str))
	    break;
	insert_prompt();
	bu_log("%*S", input_str_index, &input_str);
	escaped = bracketed = 0;
	break;
    case CTRL_B:                   /* Back one character */
	if (input_str_index == 0) {
	    insert_beep();
	    break;
	}
	--input_str_index;
	bu_log("\b"); /* hopefully non-destructive! */
	escaped = bracketed = 0;
	break;
    case CTRL_F:                   /* Forward one character */
	if (input_str_index == bu_vls_strlen(&input_str)) {
	    insert_beep();
	    break;
	}

	bu_log("%c", bu_vls_addr(&input_str)[input_str_index]);
	++input_str_index;
	escaped = bracketed = 0;
	break;
    case CTRL_T:                  /* Transpose characters */
	if (input_str_index == 0) {
	    insert_beep();
	    break;
	}
	if (input_str_index == bu_vls_strlen(&input_str)) {
	    bu_log("\b");
	    --input_str_index;
	}
	ch = bu_vls_addr(&input_str)[input_str_index];
	bu_vls_addr(&input_str)[input_str_index] =
	    bu_vls_addr(&input_str)[input_str_index - 1];
	bu_vls_addr(&input_str)[input_str_index - 1] = ch;
	bu_log("\b%*s", 2, bu_vls_addr(&input_str)+input_str_index-1);
	++input_str_index;
	escaped = bracketed = 0;
	break;
    case CTRL_N:                  /* Next history command */
    case CTRL_P:                  /* Last history command */
#if 1
	/* Work the history routines to get the right string */
	if (freshline) {
	    if (ch == CTRL_P) {
		vp = history_prev();
		if (vp == NULL) {
		    insert_beep();
		    break;
		}
		bu_vls_trunc(&scratchline, 0);
		bu_vls_vlscat(&scratchline, &input_str);
		freshline = 0;
	    } else {
		insert_beep();
		break;
	    }
	} else {
	    if (ch == CTRL_P) {
		vp = history_prev();
		if (vp == NULL) {
		    insert_beep();
		    break;
		}
	    } else {
		vp = history_next();
		if (vp == NULL) {
		    vp = &scratchline;
		    freshline = 1;
		}
	    }
	}
	insert_prompt();
	bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
	insert_prompt();
	bu_vls_trunc(&input_str, 0);
	bu_vls_vlscat(&input_str, vp);
	if (bu_vls_addr(&input_str)[bu_vls_strlen(&input_str)-1] == '\n')
	    bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1); /* del \n */
	bu_log("%S", &input_str);
	input_str_index = bu_vls_strlen(&input_str);
	escaped = bracketed = 0;
#endif
	break;
    case CTRL_W:                   /* backward-delete-word */
	{
	    char *start;
	    char *curr;
	    int len;

	    start = bu_vls_addr(&input_str);
	    curr = start + input_str_index - 1;

	    /* skip spaces */
	    while(curr > start && *curr == ' ')
		--curr;

	    /* find next space */
	    while(curr > start && *curr != ' ')
		--curr;

	    bu_vls_init(&temp);
	    bu_vls_strcat(&temp, start+input_str_index);

	    if(curr == start)
		input_str_index = 0;
	    else
		input_str_index = curr - start + 1;

	    len = bu_vls_strlen(&input_str);
	    bu_vls_trunc(&input_str, input_str_index);
	    insert_prompt();
	    bu_log("%S%S%*s", &input_str, &temp, len - input_str_index, SPACES);
	    insert_prompt();
	    bu_log("%S", &input_str);
	    bu_vls_vlscat(&input_str, &temp);
	    bu_vls_free(&temp);
	}

	escaped = bracketed = 0;
	break;
    case 'd':
	if (escaped) {                /* delete-word */
	    char *start;
	    char *curr;
	    int i;

	    start = bu_vls_addr(&input_str);
	    curr = start + input_str_index;

	    /* skip spaces */
	    while(*curr != '\0' && *curr == ' ')
		++curr;

	    /* find next space */
	    while(*curr != '\0' && *curr != ' ')
		++curr;

	    i = curr - start;
	    bu_vls_init(&temp);
	    bu_vls_strcat(&temp, curr);
	    bu_vls_trunc(&input_str, input_str_index);
	    insert_prompt();
	    bu_log("%S%S%*s", &input_str, &temp, i - input_str_index, SPACES);
	    insert_prompt();
	    bu_log("%S", &input_str);
	    bu_vls_vlscat(&input_str, &temp);
	    bu_vls_free(&temp);
	}else
	    insert_char(ch);

	escaped = bracketed = 0;
	break;
    case 'f':
	if (escaped) {                /* forward-word */
	    char *start;
	    char *curr;

	    start = bu_vls_addr(&input_str);
	    curr = start + input_str_index;

	    /* skip spaces */
	    while(*curr != '\0' && *curr == ' ')
		++curr;

	    /* find next space */
	    while(*curr != '\0' && *curr != ' ')
		++curr;

	    input_str_index = curr - start;
	    bu_vls_init(&temp);
	    bu_vls_strcat(&temp, start+input_str_index);
	    bu_vls_trunc(&input_str, input_str_index);
	    insert_prompt();
	    bu_log("%S", &input_str);
	    bu_vls_vlscat(&input_str, &temp);
	    bu_vls_free(&temp);
	}else
	    insert_char(ch);

	escaped = bracketed = 0;
	break;
    case 'b':
	if (escaped) {                /* backward-word */
	    char *start;
	    char *curr;

	    start = bu_vls_addr(&input_str);
	    curr = start + input_str_index - 1;

	    /* skip spaces */
	    while(curr > start && *curr == ' ')
		--curr;

	    /* find next space */
	    while(curr > start && *curr != ' ')
		--curr;

	    if(curr == start)
		input_str_index = 0;
	    else
		input_str_index = curr - start + 1;

	    bu_vls_init(&temp);
	    bu_vls_strcat(&temp, start+input_str_index);
	    bu_vls_trunc(&input_str, input_str_index);
	    insert_prompt();
	    bu_log("%S", &input_str);
	    bu_vls_vlscat(&input_str, &temp);
	    bu_vls_free(&temp);
	}else
	    insert_char(ch);

	escaped = bracketed = 0;
	break;
    case '[':
	if (escaped) {
	    bracketed = 1;
	    break;
	}
	/* Fall through if not escaped! */
    default:
	if (!isprint(ch))
	    break;

	insert_char(ch);
	escaped = bracketed = 0;
	break;
    }
}

HIDDEN void
insert_prompt(void)
{
    bu_log("%S", &prompt);
}

HIDDEN void
insert_char(char ch)
{
    if (input_str_index == bu_vls_strlen(&input_str)) {
	bu_log("%c", (int)ch);
	bu_vls_putc(&input_str, (int)ch);
	++input_str_index;
    } else {
	struct bu_vls temp;

	bu_vls_init(&temp);
	bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
	bu_vls_trunc(&input_str, input_str_index);
	bu_log("%c%S", (int)ch, &temp);
	insert_prompt();
	bu_vls_putc(&input_str, (int)ch);
	bu_log("%S", &input_str);
	bu_vls_vlscat(&input_str, &temp);
	++input_str_index;
	bu_vls_free(&temp);
    }
}

HIDDEN void
insert_beep(void)
{
    bu_log("%c", 7);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@Eliminated more instances of direct access of interp->result (not allowed
since tcl 8.0)
@
text
@d48 2
a61 6
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
#include <ctype.h>
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d200 1
d206 3
a208 2
	    if (strlen(interp->result))
		bu_log("%s\n", interp->result);
@


14.13
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.12
log
@add error checking to various read() calls where a potential -1 result read error was not being taken into account
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2006 United States Government as represented by
@


14.11
log
@update copyright to 2006
@
text
@d153 4
a156 1
    if (count <= 0 && feof(stdin))
d158 1
@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1998-2005 United States Government as represented by
@


14.9
log
@more config.h references converted to brlcad_config.h (or common.h where appropriate) that apparently slipped under the radar
@
text
@d43 1
a43 1
 *  
d312 1
a312 1
    
d384 1
a384 1
      
d387 1
a387 1
      
d391 1
a391 1
      
d395 1
a395 1
      
d398 1
a398 1
      
d403 1
a403 1
      
d413 1
a413 1
  
@


14.9.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d43 1
a43 1
 *
d312 1
a312 1

d384 1
a384 1

d387 1
a387 1

d391 1
a391 1

d395 1
a395 1

d398 1
a398 1

d403 1
a403 1

d413 1
a413 1

@


14.8
log
@M-x indent-region
@
text
@a45 4
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

d51 1
a51 1
#define _BSD_COMPAT
@


14.7
log
@update copyright to 2005
@
text
@d128 14
a141 14
	bu_vls_init(&input_str);
	bu_vls_init(&input_str_prefix);
	bu_vls_init(&scratchline);
	bu_vls_init(&prompt);
	input_str_index = 0;

	Tcl_CreateFileHandler(STDIN_FILENO, TCL_READABLE,
			      inputHandler, (ClientData)STDIN_FILENO);

	bu_vls_strcpy(&prompt, PROMPT);
	save_Tty(fileno(stdin));
	set_Cbreak(fileno(stdin));
	clr_Echo(fileno(stdin));
	insert_prompt();
d147 16
a162 16
	int count;
	char ch;
	long fd;
	char buf[4096];
	int index;

	fd = (long)clientData;

	count = read((int)fd, (void *)buf, 4096);

	if (count <= 0 && feof(stdin))
		Cad_Exit(TCL_OK);

	/* Process everything in buf */
	for (index = 0, ch = buf[index]; index < count; ch = buf[++index])
		processChar(ch);
d169 64
a232 64
	struct bu_vls *vp;
	struct bu_vls temp;
	static int escaped = 0;
	static int bracketed = 0;
	static int freshline = 1;

	/* ANSI arrow keys */
	if (escaped && bracketed) {
		if (ch == 'A') ch = CTRL_P;
		if (ch == 'B') ch = CTRL_N;
		if (ch == 'C') ch = CTRL_F;
		if (ch == 'D') ch = CTRL_B;
		escaped = bracketed = 0;
	}

	switch (ch) {
	case ESC:           /* Used for building up ANSI arrow keys */
		escaped = 1;
		break;
	case '\n':          /* Carriage return or line feed */
	case '\r':
		bu_log("\n");   /* Display newline */

		bu_vls_printf(&input_str_prefix, "%s%S\n",
			      bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			      &input_str);

		/* If this forms a complete command (as far as the Tcl parser is
		   concerned) then execute it. */
		if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
			int status;
			struct timeval start, finish;

			reset_Tty(fileno(stdin));
			gettimeofday(&start, (struct timezone *)NULL);
			status = Tcl_Eval(interp, bu_vls_addr(&input_str_prefix));
			gettimeofday(&finish, (struct timezone *)NULL);
			if (strlen(interp->result))
				bu_log("%s\n", interp->result);

			history_record(&input_str_prefix, &start, &finish, status);
			bu_vls_trunc(&input_str_prefix, 0);
			bu_vls_trunc(&input_str, 0);
			set_Cbreak(fileno(stdin)); /* Back to single-character mode */
			clr_Echo(fileno(stdin));

			/* reset prompt */
			bu_vls_strcpy(&prompt, PROMPT);

		} else {
			bu_vls_trunc(&input_str, 0);
			bu_vls_strcpy(&prompt, "\r? ");
		}
		insert_prompt();
		input_str_index = 0;
		freshline = 1;
		escaped = bracketed = 0;
		break;
	case BACKSPACE:
	case DELETE:
		if (input_str_index <= 0) {
			insert_beep();
			break;
		}
d234 82
a315 82
		if (input_str_index == bu_vls_strlen(&input_str)) {
			bu_log("\b \b");
			bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1);
		} else {
			bu_vls_init(&temp);
			bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
			bu_vls_trunc(&input_str, input_str_index-1);
			bu_log("\b%S ", &temp);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}
		--input_str_index;
		escaped = bracketed = 0;
		break;
	case CTRL_A:                    /* Go to beginning of line */
		insert_prompt();
		input_str_index = 0;
		escaped = bracketed = 0;
		break;
	case CTRL_E:                    /* Go to end of line */
		if (input_str_index < bu_vls_strlen(&input_str)) {
			bu_log("%s", bu_vls_addr(&input_str)+input_str_index);
			input_str_index = bu_vls_strlen(&input_str);
		}
		escaped = bracketed = 0;
		break;
	case CTRL_D:                    /* Delete character at cursor */
		if (input_str_index == bu_vls_strlen(&input_str)) {
			insert_beep(); /* Beep if at end of input string */
			break;
		}
		bu_vls_init(&temp);
		bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index+1);
		bu_vls_trunc(&input_str, input_str_index);
		bu_log("%S ", &temp);
		insert_prompt();
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		bu_vls_free(&temp);
		escaped = bracketed = 0;
		break;
	case CTRL_U:                   /* Delete whole line */
		insert_prompt();
		bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
		insert_prompt();
		bu_vls_trunc(&input_str, 0);
		input_str_index = 0;
		escaped = bracketed = 0;
		break;
	case CTRL_K:                    /* Delete to end of line */
		bu_log("%*s", bu_vls_strlen(&input_str)-input_str_index, SPACES);
		bu_vls_trunc(&input_str, input_str_index);
		insert_prompt();
		bu_log("%S", &input_str);
		escaped = bracketed = 0;
		break;
	case CTRL_L:                   /* Redraw line */
		bu_log("\n");
		insert_prompt();
		bu_log("%S", &input_str);
		if (input_str_index == bu_vls_strlen(&input_str))
			break;
		insert_prompt();
		bu_log("%*S", input_str_index, &input_str);
		escaped = bracketed = 0;
		break;
	case CTRL_B:                   /* Back one character */
		if (input_str_index == 0) {
			insert_beep();
			break;
		}
		--input_str_index;
		bu_log("\b"); /* hopefully non-destructive! */
		escaped = bracketed = 0;
		break;
	case CTRL_F:                   /* Forward one character */
		if (input_str_index == bu_vls_strlen(&input_str)) {
			insert_beep();
			break;
		}
d317 37
a353 3
		bu_log("%c", bu_vls_addr(&input_str)[input_str_index]);
		++input_str_index;
		escaped = bracketed = 0;
d355 13
a367 4
	case CTRL_T:                  /* Transpose characters */
		if (input_str_index == 0) {
			insert_beep();
			break;
d369 12
a380 55
		if (input_str_index == bu_vls_strlen(&input_str)) {
			bu_log("\b");
			--input_str_index;
		}
		ch = bu_vls_addr(&input_str)[input_str_index];
		bu_vls_addr(&input_str)[input_str_index] =
			bu_vls_addr(&input_str)[input_str_index - 1];
		bu_vls_addr(&input_str)[input_str_index - 1] = ch;
		bu_log("\b%*s", 2, bu_vls_addr(&input_str)+input_str_index-1);
		++input_str_index;
		escaped = bracketed = 0;
		break;
	case CTRL_N:                  /* Next history command */
	case CTRL_P:                  /* Last history command */
#if 1
		/* Work the history routines to get the right string */
		if (freshline) {
			if (ch == CTRL_P) {
				vp = history_prev();
				if (vp == NULL) {
					insert_beep();
					break;
				}
				bu_vls_trunc(&scratchline, 0);
				bu_vls_vlscat(&scratchline, &input_str);
				freshline = 0;
			} else {
				insert_beep();
				break;
			}
		} else {
			if (ch == CTRL_P) {
				vp = history_prev();
				if (vp == NULL) {
					insert_beep();
					break;
				}
			} else {
				vp = history_next();
				if (vp == NULL) {
					vp = &scratchline;
					freshline = 1;
				}
			}
		}
		insert_prompt();
		bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
		insert_prompt();
		bu_vls_trunc(&input_str, 0);
		bu_vls_vlscat(&input_str, vp);
		if (bu_vls_addr(&input_str)[bu_vls_strlen(&input_str)-1] == '\n')
			bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1); /* del \n */
		bu_log("%S", &input_str);
		input_str_index = bu_vls_strlen(&input_str);
		escaped = bracketed = 0;
d382 6
a387 6
		break;
	case CTRL_W:                   /* backward-delete-word */
		{
			char *start;
			char *curr;
			int len;
d389 2
a390 2
			start = bu_vls_addr(&input_str);
			curr = start + input_str_index - 1;
d392 3
a394 3
			/* skip spaces */
			while(curr > start && *curr == ' ')
				--curr;
d396 3
a398 3
			/* find next space */
			while(curr > start && *curr != ' ')
				--curr;
d400 2
a401 2
			bu_vls_init(&temp);
			bu_vls_strcat(&temp, start+input_str_index);
d403 4
a406 4
			if(curr == start)
				input_str_index = 0;
			else
				input_str_index = curr - start + 1;
d408 9
a416 9
			len = bu_vls_strlen(&input_str);
			bu_vls_trunc(&input_str, input_str_index);
			insert_prompt();
			bu_log("%S%S%*s", &input_str, &temp, len - input_str_index, SPACES);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}
d418 78
a495 31
		escaped = bracketed = 0;
		break;
	case 'd':
		if (escaped) {                /* delete-word */
			char *start;
			char *curr;
			int i;

			start = bu_vls_addr(&input_str);
			curr = start + input_str_index;

			/* skip spaces */
			while(*curr != '\0' && *curr == ' ')
				++curr;

			/* find next space */
			while(*curr != '\0' && *curr != ' ')
				++curr;

			i = curr - start;
			bu_vls_init(&temp);
			bu_vls_strcat(&temp, curr);
			bu_vls_trunc(&input_str, input_str_index);
			insert_prompt();
			bu_log("%S%S%*s", &input_str, &temp, i - input_str_index, SPACES);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}else
			insert_char(ch);
d497 4
a500 61
		escaped = bracketed = 0;
		break;
	case 'f':
		if (escaped) {                /* forward-word */
			char *start;
			char *curr;

			start = bu_vls_addr(&input_str);
			curr = start + input_str_index;

			/* skip spaces */
			while(*curr != '\0' && *curr == ' ')
				++curr;

			/* find next space */
			while(*curr != '\0' && *curr != ' ')
				++curr;

			input_str_index = curr - start;
			bu_vls_init(&temp);
			bu_vls_strcat(&temp, start+input_str_index);
			bu_vls_trunc(&input_str, input_str_index);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}else
			insert_char(ch);

		escaped = bracketed = 0;
		break;
	case 'b':
		if (escaped) {                /* backward-word */
			char *start;
			char *curr;

			start = bu_vls_addr(&input_str);
			curr = start + input_str_index - 1;

			/* skip spaces */
			while(curr > start && *curr == ' ')
				--curr;

			/* find next space */
			while(curr > start && *curr != ' ')
				--curr;

			if(curr == start)
				input_str_index = 0;
			else
				input_str_index = curr - start + 1;

			bu_vls_init(&temp);
			bu_vls_strcat(&temp, start+input_str_index);
			bu_vls_trunc(&input_str, input_str_index);
			insert_prompt();
			bu_log("%S", &input_str);
			bu_vls_vlscat(&input_str, &temp);
			bu_vls_free(&temp);
		}else
			insert_char(ch);
d502 16
a517 15
		escaped = bracketed = 0;
		break;
	case '[':
		if (escaped) {
			bracketed = 1;
			break;
		}
		/* Fall through if not escaped! */
	default:
		if (!isprint(ch))
			break;

		insert_char(ch);
		escaped = bracketed = 0;
		break;
d519 9
d533 1
a533 1
	bu_log("%S", &prompt);
d539 6
a544 6
	if (input_str_index == bu_vls_strlen(&input_str)) {
		bu_log("%c", (int)ch);
		bu_vls_putc(&input_str, (int)ch);
		++input_str_index;
	} else {
		struct bu_vls temp;
d546 11
a556 11
		bu_vls_init(&temp);
		bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
		bu_vls_trunc(&input_str, input_str_index);
		bu_log("%c%S", (int)ch, &temp);
		insert_prompt();
		bu_vls_putc(&input_str, (int)ch);
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		++input_str_index;
		bu_vls_free(&temp);
	}
d562 1
a562 1
	bu_log("%c", 7);
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 United States Government as represented by
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a43 2
 *
 *
@


14.4
log
@remove the old distribution notice section
@
text
@a44 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a43 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" license agreement.
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file input.c
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *				I N P U T . C
@


1.7
log
@use config.h
@
text
@d553 10
@


1.6
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d35 4
@


1.5
log
@replace the wrapped config.h block with common.h
@
text
@d50 1
a50 1
#ifdef USE_STRING_H
@


1.4
log
@conflict resolved
@
text
@d35 1
a35 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.3
log
@include unistd.h for STDOUT_FILENO
@
text
@d39 1
a39 4
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

d45 7
a51 3

#include "tcl.h"

d53 1
a53 1
#include <string.h>
d55 1
a55 1
#include <strings.h>
d59 2
d64 1
@


1.2
log
@obliterate externs.h
@
text
@d35 8
a47 4
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a54 1
#include "externs.h"
@

