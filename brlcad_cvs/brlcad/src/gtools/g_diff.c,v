head	14.24;
access;
symbols
	rel-7-10-4:14.21
	STABLE:14.21.0.2
	stable-branch:14.6
	rel-7-10-2:14.21
	rel-7-10-0:14.18
	rel-7-8-4:14.13
	rel-7-8-2:14.13
	rel-7-8-0:14.12
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.24
date	2007.11.21.20.49.08;	author erikgreenwald;	state Exp;
branches;
next	14.23;

14.23
date	2007.11.21.19.28.06;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.07.26.01.13.54;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.06.18.04.38.56;	author johnranderson;	state Exp;
branches;
next	14.19;

14.19
date	2007.05.14.21.04.30;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.03.02.21.24.33;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.02.02.08.48.29;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.34;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.32;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.49;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.04.29.03.10.07;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.04.05.19.15.42;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.28.00.36.28;	author brlcad;	state Exp;
branches
	14.11.2.1;
next	14.10;

14.10
date	2006.01.24.04.30.46;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.05.04.02.56.57;	author brlcad;	state Exp;
branches
	14.7.6.1;
next	14.6;

14.6
date	2005.01.30.20.30.37;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.25.29;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.20.20.21.31;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.14;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.09;	author morrison;	state Exp;
branches;
next	;

14.7.6.1
date	2005.11.13.13.46.14;	author brlcad;	state Exp;
branches;
next	;

14.11.2.1
date	2006.04.07.19.26.27;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.24
log
@pass bu_exit a NULL instead of an empty string
@
text
@/*                        G _ D I F F . C
 * BRL-CAD
 *
 * Copyright (c) 1998-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file g_diff.c
 *
 *	Routine to determine the differences between two BRL-CAD databases (".g" files).
 *	With no options, the output to stdout is an MGED script that may be fed to
 *	MGED to convert the first database to the match the second.
 *	The script uses the MGED "db" command to make the changes. Some solid types
 *	do not yet have support in the "db" command. Such solids that change from
 *	one database to the next, will be noted by a comment in the database as:
 *	"#IMPORT solid_name from database_name"
 *
 *  Author -
 *      John R. Anderson
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.23 2007/11/21 19:28:06 erikgreenwald Exp $";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"
#include "tcl.h"
#include "mater.h"


static struct mater *mater_hd1=MATER_NULL, *mater_hd2=MATER_NULL;

extern int bu_optind;
extern int optopt;

#define HUMAN	1
#define MGED	2

/* type of adjustment, for do_compare() */
#define	PARAMS	1
#define	ATTRS	2

static int mode=HUMAN;
static Tcl_Interp *interp = NULL;
static int pre_5_vers=0;
static int use_floats=0;	/* flag to use floats for comparisons */
static int verify_region_attribs=0;	/* flag to verify region attributes */
static struct db_i *dbip1, *dbip2;
static int version2;


void
Usage(char *str)
{
    fprintf( stderr, "Usage: %s [-m] file1.g file2.g\n", str );
}


int
compare_colors(void)
{
    struct mater *mp1, *mp2;
    int found1=0, found2=0;
    int is_diff=0;

    for( mp1 = mater_hd1; mp1 != MATER_NULL; mp1 = mp1->mt_forw )  {
	found1 = 0;
	mp2 = mater_hd2;
	while( mp2 != MATER_NULL ) {
	    if( mp1->mt_low == mp2->mt_low &&
		mp1->mt_high == mp2->mt_high &&
		mp1->mt_r == mp2->mt_r &&
		mp1->mt_g == mp2->mt_g &&
		mp1->mt_b == mp2->mt_b ) {
		found1 = 1;
		break;
	    } else {
		mp2 = mp2->mt_forw;
	    }
	}
	if( !found1 )
	    break;
    }
    for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
	found1 = 0;
	mp1 = mater_hd1;
	while( mp1 != MATER_NULL ) {
	    if( mp1->mt_low == mp2->mt_low &&
		mp1->mt_high == mp2->mt_high &&
		mp1->mt_r == mp2->mt_r &&
		mp1->mt_g == mp2->mt_g &&
		mp1->mt_b == mp2->mt_b ) {
		found2 = 1;
		break;
	    } else {
		mp1 = mp1->mt_forw;
	    }
	}
	if( !found2 )
	    break;
    }
    if( !found1 && !found2 ) {
	return 0;
    } else if( !found1 || !found2 ) {
	is_diff = 1;
    } else {
	/* actually compare two color tables */
	mp1 = mater_hd1;
	mp2 = mater_hd2;
	while( mp1 != MATER_NULL && mp2 != MATER_NULL ) {
	    if( mp1->mt_low != mp2->mt_low ) {
		is_diff = 1;
		break;
	    }
	    if( mp1->mt_high != mp2->mt_high ) {
		is_diff = 1;
		break;
	    }
	    if( mp1->mt_r != mp2->mt_r ) {
		is_diff = 1;
		break;
	    }
	    if( mp1->mt_g != mp2->mt_g ) {
		is_diff = 1;
		break;
	    }
	    if( mp1->mt_b != mp2->mt_b ) {
		is_diff = 1;
		break;
	    }
	    mp1 = mp1->mt_forw;
	    mp2 = mp2->mt_forw;
	}
    }

    if( is_diff ) {
	if( mode == HUMAN ) {
	    printf( "Color table has changed from:\n" );
	    for( mp1 = mater_hd1; mp1 != MATER_NULL; mp1 = mp1->mt_forw )  {
		printf( "\t%d..%d %d %d %d\n", mp1->mt_low, mp1->mt_high,
			mp1->mt_r, mp1->mt_g, mp1->mt_b );
	    }
	    printf( "\t\tto:\n" );
	    for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
		printf( "\t%d..%d %d %d %d\n", mp2->mt_low, mp2->mt_high,
			mp2->mt_r, mp2->mt_g, mp2->mt_b );
	    }
	} else {
	    if( version2 > 4 )
		printf( "attr rm _GLOBAL regionid_colortable\n" );
	    for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
		printf( "color %d %d %d %d %d\n", mp2->mt_low, mp2->mt_high,
			mp2->mt_r, mp2->mt_g, mp2->mt_b );
	    }
	}
	return 1;
    }
    return 0;
}

void
kill_obj(char *name)
{
    if( mode == HUMAN ) {
	printf( "%s has been killed\n", name );
    } else {
	printf( "kill %s\n", name );
    }
}

int
compare_external(struct directory *dp1, struct directory *dp2)
{
    int kill = 0;
    struct bu_external ext1, ext2;

    if( db_get_external( &ext1, dp1, dbip1 ) ) {
	fprintf( stderr, "ERROR: db_get_external failed on solid %s in %s\n", dp1->d_namep, dbip1->dbi_filename );
	bu_exit( 1, NULL );
    }
    if( db_get_external( &ext2, dp2, dbip2 ) ) {
	fprintf( stderr, "ERROR: db_get_external failed on solid %s in %s\n", dp2->d_namep, dbip2->dbi_filename );
	bu_exit( 1, NULL );
    }

    if( ext1.ext_nbytes != ext2.ext_nbytes ) {
	printf("Byte counts are different on %s (%ld != %ld)\n", dp1->d_namep, ext1.ext_nbytes, ext2.ext_nbytes);
	kill = 1;
    }

    if (bcmp( (void *)ext1.ext_buf, (void *)ext2.ext_buf, ext1.ext_nbytes )) {
	printf("Byte value(s) are different on %s (has no Tcl list representation)\n", dp1->d_namep);
	kill = 1;
    }

    if (kill) {
	if( mode == HUMAN ) {
	    printf( "kill %s and import it from %s\n", dp1->d_namep, dbip1->dbi_filename );
	} else {
	    printf( "kill %s\n# IMPORT %s from %s\n", dp1->d_namep, dp2->d_namep, dbip2->dbi_filename );
	}
	return 1;
    }
    return 0;
}

int
isNumber( char *s )
{
    while( *s != '\0' ) {
	if( isdigit( *s ) || *s == '.' || *s == '-' || *s == '+' || *s == 'e' || *s == 'E' ) {
	    s++;
	} else {
	    return 0;
	}
    }

    return 1;
}

int
compare_values( int type, Tcl_Obj *val1, Tcl_Obj *val2 )
{
    int len1, len2;
    int i;
    int str_ret;
    float a, b;
    Tcl_Obj *obj1, *obj2;

    str_ret = strcmp( Tcl_GetStringFromObj( val1, NULL ), Tcl_GetStringFromObj( val2, NULL ) );

    if( str_ret == 0 || type == ATTRS ) {
	return 0;
    }

    if( Tcl_ListObjLength( interp, val1, &len1 ) == TCL_ERROR ) {
	fprintf( stderr, "Error getting length of TCL object!!!\n" );
	fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	bu_exit ( 1, NULL );
    }

    if( Tcl_ListObjLength( interp, val2, &len2 ) == TCL_ERROR ) {
	fprintf( stderr, "Error getting length of TCL object!!!\n" );
	fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	bu_exit ( 1, NULL );
    }

    if( len1 != len2 ) {
	return 1;
    }

    for( i=0 ; i<len1 ; i++ ) {
	char *str1;
	char *str2;

	if( Tcl_ListObjIndex( interp, val1, i, &obj1 ) == TCL_ERROR ) {
	    fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( val1, NULL ) );
	    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	    bu_exit ( 1, NULL );
	}
	if( Tcl_ListObjIndex( interp, val2, i, &obj2 ) == TCL_ERROR ) {
	    fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( val2, NULL ) );
	    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	    bu_exit ( 1, NULL );
	}
	str1 = Tcl_GetString( obj1 );
	str2 = Tcl_GetString( obj2 );

	if( use_floats && (isNumber(str1) && isNumber(str2)) ) {
	    a = atof( str1 );
	    b = atof( str2 );

	    if( a != b ) {
		return 1;
	    }
	} else {
	    if( !strcmp( str1, str2 ) ) {
		return 1;
	    }
	}
    }

    return 0;
}

int
do_compare(int type, struct bu_vls *vls, Tcl_Obj *obj1, Tcl_Obj *obj2, char *obj_name)
{
    Tcl_Obj *key1, *val1, *key2, *val2;
    int len1, len2, found, junk;
    int i, j;
    int start_index;
    int found_diffs=0;

    if( Tcl_ListObjLength( interp, obj1, &len1 ) == TCL_ERROR ) {
	fprintf( stderr, "Error getting length of TCL object!!!\n" );
	fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	bu_exit ( 1, NULL );
    }
    if( Tcl_ListObjLength( interp, obj2, &len2 ) == TCL_ERROR ) {
	fprintf( stderr, "Error getting length of TCL object!!!\n" );
	fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	bu_exit ( 1, NULL );
    }

    if( !len1 && !len2 )
	return 0;

    if( type == ATTRS ) {
	start_index = 0;
    } else {
	start_index = 1;
    }

    /* check for changed values from object 1 to object2 */
    for( i=start_index ; i<len1 ; i+=2 ) {
	if( Tcl_ListObjIndex( interp, obj1, i, &key1 ) == TCL_ERROR ) {
	    fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj1, &junk ) );
	    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	    bu_exit ( 1, NULL );
	}

	if( Tcl_ListObjIndex( interp, obj1, i+1, &val1 ) == TCL_ERROR ) {
	    fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i+1, Tcl_GetStringFromObj( obj1, &junk ) );
	    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	    bu_exit ( 1, NULL );
	}

	found = 0;
	for( j=start_index ; j<len2 ; j += 2 ) {
	    if( Tcl_ListObjIndex( interp, obj2, j, &key2 ) == TCL_ERROR ) {
		fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", j, Tcl_GetStringFromObj( obj2, &junk ) );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		bu_exit ( 1, NULL );
	    }
	    if( !strcmp( Tcl_GetStringFromObj( key1, &junk ), Tcl_GetStringFromObj( key2, &junk ) ) ) {
		found = 1;
		if( Tcl_ListObjIndex( interp, obj2, j+1, &val2 ) == TCL_ERROR ) {
		    fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", j+1, Tcl_GetStringFromObj( obj2, &junk ) );
		    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		    bu_exit ( 1, NULL );
		}

		/* check if this value has changed */
		if( compare_values( type, val1, val2 ) ) {
		    if( !found_diffs++ ) {
			if( mode == HUMAN ) {
			    printf( "%s has changed:\n", obj_name );
			}
		    }
		    if( mode == HUMAN ) {
			if( type == PARAMS ) {
			    printf( "\tparameter %s has changed from:\n\t\t%s\n\tto:\n\t\t%s\n",
				    Tcl_GetStringFromObj( key1, &junk ),
				    Tcl_GetStringFromObj( val1, &junk ),
				    Tcl_GetStringFromObj( val2, &junk ) );
			} else {
			    printf( "\t%s attribute \"%s\" has changed from:\n\t\t%s\n\tto:\n\t\t%s\n",
				    obj_name,
				    Tcl_GetStringFromObj( key1, &junk ),
				    Tcl_GetStringFromObj( val1, &junk ),
				    Tcl_GetStringFromObj( val2, &junk ) );
			}
		    } else {
			int val_len;

			if( type == ATTRS ) {
			    bu_vls_printf( vls, "attr set %s ", obj_name );
			} else {
			    bu_vls_strcat( vls, " " );
			}
			bu_vls_strcat( vls, Tcl_GetStringFromObj( key1, &junk ) );
			bu_vls_strcat( vls, " " );
			if( Tcl_ListObjLength( interp, val2, &val_len ) == TCL_ERROR ) {
			    fprintf( stderr, "Error getting length of TCL object!!\n" );
			    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			    bu_exit( 1, NULL );
			}
			if( val_len > 1 )
			    bu_vls_putc( vls, '{' );
			bu_vls_strcat( vls, Tcl_GetStringFromObj( val2, &junk ) );
			if( val_len > 1 )
			    bu_vls_putc( vls, '}' );
			if( type == ATTRS ) {
			    bu_vls_putc( vls, '\n' );
			}
		    }
		}
		break;
	    }
	}
	if( !found ) {
	    /* this keyword value pair has been eliminated */
	    if( !found_diffs++ ) {
		if( mode == HUMAN ) {
		    printf( "%s has changed:\n", obj_name );
		}
	    }
	    if( mode == HUMAN ) {
		if( type == PARAMS ) {
		    printf( "\tparameter %s has been eliminated\n",
			    Tcl_GetStringFromObj( key1, &junk ) );
		} else {
		    printf( "\tattribute \"%s\" has been eliminated from %s\n",
			    Tcl_GetStringFromObj( key1, &junk ), obj_name );
		}
	    } else {
		if( type == ATTRS ) {
		    bu_vls_printf( vls, "attr rm %s %s\n", obj_name,
				   Tcl_GetStringFromObj( key1, &junk ) );
		} else {
		    bu_vls_strcat( vls, " " );
		    bu_vls_strcat( vls, Tcl_GetStringFromObj( key1, &junk ) );
		    bu_vls_strcat( vls, " none" );
		}
	    }
	}
    }

    /* check for keyword value pairs in object 2 that don't appear in object 1 */
    for( i=start_index ; i<len2 ; i+= 2 ) {
	/* get keyword/value pairs from object 2 */
	if( Tcl_ListObjIndex( interp, obj2, i, &key2 ) == TCL_ERROR ) {
	    fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj2, &junk ) );
	    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	    bu_exit ( 1, NULL );
	}

	if( Tcl_ListObjIndex( interp, obj2, i+1, &val2 ) == TCL_ERROR ) {
	    fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i+1, Tcl_GetStringFromObj( obj2, &junk ) );
	    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	    bu_exit ( 1, NULL );
	}

	found = 0;
	/* look for this keyword in object 1 */
	for( j=start_index ; j<len1 ; j += 2 ) {
	    if( Tcl_ListObjIndex( interp, obj1, j, &key1 ) == TCL_ERROR ) {
		fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj1, &junk ) );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		bu_exit ( 1, NULL );
	    }
	    if( !strcmp( Tcl_GetStringFromObj( key1, &junk ), Tcl_GetStringFromObj( key2, &junk ) ) ) {
		found = 1;
		break;
	    }
	}
	if( found )
	    continue;

	/* This keyword/value pair in object 2 is not in object 1 */
	if( !found_diffs++ ) {
	    if( mode == HUMAN ) {
		printf( "%s has changed:\n", obj_name );
	    }
	}
	if( mode == HUMAN ) {
	    if( type == PARAMS ) {
		printf( "\t%s has new parameter \"%s\" with value %s\n",
			obj_name,
			Tcl_GetStringFromObj( key2, &junk ),
			Tcl_GetStringFromObj( val2, &junk ) );
	    } else {
		printf( "\t%s has new attribute \"%s\" with value {%s}\n",
			obj_name,
			Tcl_GetStringFromObj( key2, &junk ),
			Tcl_GetStringFromObj( val2, &junk ) );
	    }
	} else {
	    int val_len;

	    if( type == ATTRS ) {
		bu_vls_printf( vls, "attr set %s ", obj_name );
	    } else {
		bu_vls_strcat( vls, " " );
	    }
	    bu_vls_strcat( vls, Tcl_GetStringFromObj( key2, &junk ) );
	    bu_vls_strcat( vls, " " );
	    if( Tcl_ListObjLength( interp, val2, &val_len ) == TCL_ERROR ) {
		fprintf( stderr, "Error getting length of TCL object!!\n" );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		bu_exit( 1, NULL );
	    }
	    if( val_len > 1 )
		bu_vls_putc( vls, '{' );
	    bu_vls_strcat( vls, Tcl_GetStringFromObj( val2, &junk ) );
	    if( val_len > 1 )
		bu_vls_putc( vls, '}' );

	    if( type == ATTRS )
		bu_vls_putc( vls, '\n' );
	}
    }
    return found_diffs;
}

int
compare_tcl_solids(char *str1, Tcl_Obj *obj1, struct directory *dp1, char *str2, Tcl_Obj *obj2, struct directory *dp2)
{
    char *c1, *c2;
    struct bu_vls adjust;
    int different = 0;

    /* check if same solid type */
    c1 = str1;
    c2 = str2;
    while( *c1 != ' ' && *c2 != ' ' && *c1++ == *c2++ );

    if( *c1 != *c2 ) {
	/* different solid types */
	if( mode == HUMAN )
	    printf( "solid %s:\n\twas: %s\n\tis now: %s\n\n", dp1->d_namep, str1, str2 );
	else
	    printf( "kill %s\ndb put %s %s\n", dp1->d_namep, dp1->d_namep, str2 );

	return 1;
    } else if( !strcmp( str1, str2 ) ) {
	return 0;		/* no difference */
    }

    /* same solid type, can use "db adjust" */

    if( mode == MGED ) {
	bu_vls_init( &adjust );
	bu_vls_printf( &adjust, "db adjust %s", dp1->d_namep );
    }

    different = do_compare( PARAMS, &adjust, obj1, obj2, dp1->d_namep );

    if( mode != HUMAN ) {
	printf( "%s\n", bu_vls_addr( &adjust ) );
	bu_vls_free( &adjust );
    }

    return different;
}

int
compare_tcl_combs(Tcl_Obj *obj1, struct directory *dp1, Tcl_Obj *obj2, struct directory *dp2)
{
    int junk;
    struct bu_vls adjust;
    int different = 0;

    /* first check if there is any difference */
    if( !strcmp( Tcl_GetStringFromObj( obj1, &junk ), Tcl_GetStringFromObj( obj2, &junk ) ) )
	return 0;

    if( mode != HUMAN ) {
	bu_vls_init( &adjust );
	bu_vls_printf( &adjust, "db adjust %s", dp1->d_namep );
    }

    different = do_compare( PARAMS, &adjust, obj1, obj2, dp1->d_namep );

    if( mode != HUMAN ) {
	printf( "%s\n", bu_vls_addr( &adjust ) );
	bu_vls_free( &adjust );
    }

    return different;
}

void
verify_region_attrs( struct directory *dp, struct db_i *dbip, Tcl_Obj *obj )
{
    Tcl_Obj **objs;
    int len=0;
    int i;
    struct rt_db_internal intern;
    struct rt_comb_internal *comb;

    if( rt_db_get_internal( &intern, dp, dbip, NULL, &rt_uniresource ) < 0 ) {
	fprintf( stderr, "Cannot import %s\n", dp->d_namep );
	bu_exit( 1, NULL );
    }

    comb = (struct rt_comb_internal *)intern.idb_ptr;
    RT_CHECK_COMB( comb );

    if( Tcl_ListObjGetElements( interp, obj, &len, &objs ) != TCL_OK ) {
	fprintf( stderr, "Cannot get length of attributes for %s\n", dp->d_namep );
	bu_exit( 1, NULL );
    }

    for( i=1 ; i<len ; i += 2 ) {
	char *key, *value;

	key = Tcl_GetStringFromObj( objs[i-1], NULL );
	value = Tcl_GetStringFromObj( objs[i], NULL );
	if( !strcmp( key, "region_id" ) ) {
	    short id;

	    id = atoi( value );
	    if( id != comb->region_id ) {
		fprintf( stderr, "WARNING: %s in %s: \"region_id\" attribute says %d, while region says %d\n",
			 dp->d_namep, dbip->dbi_filename, id, comb->region_id );
	    }
	} else if( !strcmp( key, "giftmater" ) ) {
	    short GIFTmater;

	    GIFTmater = atoi( value );
	    if( GIFTmater != comb->GIFTmater ) {
		fprintf( stderr, "WARNING: %s in %s: \"giftmater\" attribute says %d, while region says %d\n",
			 dp->d_namep, dbip->dbi_filename, GIFTmater, comb->GIFTmater );
	    }
	} else if( !strcmp( key, "los" ) ) {
	    short los;

	    los = atoi( value );
	    if( los != comb->los ) {
		fprintf( stderr, "WARNING: %s in %s: \"los\" attribute says %d, while region says %d\n",
			 dp->d_namep, dbip->dbi_filename, los, comb->los );
	    }
	} else if( !strcmp( key, "material" ) ) {
	    if( !strncmp( value, "gift", 4 ) ) {
		short GIFTmater;

		GIFTmater = atoi( &value[4] );
		if( GIFTmater != comb->GIFTmater ) {
		    fprintf( stderr, "WARNING: %s in %s: \"material\" attribute says %s, while region says %d\n",
			     dp->d_namep, dbip->dbi_filename, value, comb->GIFTmater );
		}
	    }
	} else if( !strcmp( key, "aircode" ) ) {
	    short aircode;

	    aircode = atoi( value );
	    if( aircode != comb->aircode ) {
		fprintf( stderr, "WARNING: %s in %s: \"aircode\" attribute says %d, while region says %d\n",
			 dp->d_namep, dbip->dbi_filename, aircode, comb->aircode );
	    }
	}
    }
    rt_db_free_internal( &intern, &rt_uniresource );
}

static char *region_attrs[] = { "region",
				"region_id",
				"giftmater",
				"los",
				"aircode",
				NULL };
void
remove_region_attrs( Tcl_Obj *obj )
{
    int len=0;
    Tcl_Obj **objs;
    char *key;
    int i,j;
    int found_material=0;

    if( Tcl_ListObjGetElements( interp, obj, &len, &objs ) != TCL_OK ) {
	fprintf( stderr, "Cannot get length of attributes for %s\n",
		 Tcl_GetStringFromObj( obj, NULL ) );
	bu_exit( 1, NULL );
    }

    if( len == 0 )
	return;

    for( i=len-1 ; i>0 ; i -= 2 ) {

	key = Tcl_GetStringFromObj( objs[i-1], NULL );
	j = 0;
	while( region_attrs[j] ) {
	    if( !strcmp( key, region_attrs[j] ) ) {
		Tcl_ListObjReplace(interp, obj, i-1, 2, 0, NULL);
		break;
	    }
	    j++;
	}
	if( !found_material && !strcmp( key, "material" ) ) {
	    found_material = 1;
	    if( !strncmp( Tcl_GetStringFromObj( objs[i], NULL ), "gift", 4 ) ) {
		Tcl_ListObjReplace(interp, obj, i-1, 2, 0, NULL);
	    }
	}
    }
}


int
compare_attrs( struct directory *dp1, struct directory *dp2 )
{
    struct bu_vls vls;
    Tcl_Obj *obj1, *obj2;
    int different = 0;

    bu_vls_init( &vls );

    if( dbip1->dbi_version > 4 ) {
	bu_vls_printf( &vls, "_db1 attr get %s", dp1->d_namep );
	if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK ) {
	    fprintf( stderr, "Cannot get attributes for %s\n", dp1->d_namep );
	    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	    bu_exit( 1, NULL );
	}

	obj1 = Tcl_DuplicateObj( Tcl_GetObjResult( interp ) );
	Tcl_ResetResult( interp );
	if( dp1->d_flags & DIR_REGION && verify_region_attribs ) {
	    verify_region_attrs( dp1, dbip1, obj1 );
	}
    } else {
	obj1 = Tcl_NewObj();
    }

    if( dbip2->dbi_version > 4 ) {
	bu_vls_trunc( &vls, 0 );
	bu_vls_printf( &vls, "_db2 attr get %s", dp1->d_namep );
	if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK ) {
	    fprintf( stderr, "Cannot get attributes for %s\n", dp1->d_namep );
	    fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
	    bu_exit( 1, NULL );
	}

	obj2 = Tcl_DuplicateObj( Tcl_GetObjResult( interp ) );
	Tcl_ResetResult( interp );
	if( dp1->d_flags & DIR_REGION && verify_region_attribs ) {
	    verify_region_attrs( dp2, dbip2, obj2 );
	}
    } else {
	obj2 = Tcl_NewObj();
    }

    if( (dp1->d_flags & DIR_REGION) && (dp2->d_flags & DIR_REGION) ) {
	/* don't complain about "region" attributes */
	remove_region_attrs( obj1 );
	remove_region_attrs( obj2 );
    }

    bu_vls_trunc( &vls, 0 );
    different = do_compare( ATTRS, &vls, obj1, obj2, dp1->d_namep );

    printf( "%s", bu_vls_addr( &vls ) );
    bu_vls_free( &vls );

    return different;
}

int
diff_objs(struct rt_wdb *wdb1, struct rt_wdb *wdb2)
{
    struct directory *dp1, *dp2;
    char *argv[4]={NULL, NULL, NULL, NULL};
    struct bu_vls s1_tcl, s2_tcl;
    struct bu_vls vls;
    int has_diff = 0;

    RT_CK_WDB(wdb1);
    RT_CK_WDB(wdb2);

    bu_vls_init( &s1_tcl );
    bu_vls_init( &s2_tcl );
    bu_vls_init( &vls );

    /* look at all objects in this database */
    FOR_ALL_DIRECTORY_START(dp1, dbip1) {
	char *str1, *str2;
	Tcl_Obj *obj1, *obj2;

	/* check if this object exists in the other database */
	if( (dp2 = db_lookup( dbip2, dp1->d_namep, 0 )) == DIR_NULL ) {
	    kill_obj( dp1->d_namep );
	    continue;
	}

	/* skip the _GLOBAL object */
	if( dp1->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
	    continue;

	/* try to get the TCL version of this object */
	bu_vls_trunc( &vls, 0 );
	bu_vls_printf( &vls, "_db1 get %s", dp1->d_namep );
	if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK ) {
	    /* cannot get TCL version, use bu_external */
	    Tcl_ResetResult( interp );
	    has_diff += compare_external( dp1, dp2 );
	    continue;
	}

	obj1 = Tcl_NewListObj( 0, NULL );
	Tcl_AppendObjToObj( obj1, Tcl_GetObjResult( interp ) );

	bu_vls_trunc( &s1_tcl, 0 );
	bu_vls_trunc( &s2_tcl, 0 );

	bu_vls_strcpy( &s1_tcl, Tcl_GetStringResult( interp ) );
	str1 = bu_vls_addr( &s1_tcl );
	Tcl_ResetResult( interp );

	/* try to get TCL version of object from the other database */
	bu_vls_trunc( &vls, 0 );
	bu_vls_printf( &vls, "_db2 get %s", dp1->d_namep );
	if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK ) {
	    Tcl_ResetResult( interp );

	    /* cannot get it, they MUST be different */
	    if( mode == HUMAN )
		printf( "Replace %s with the same object from %s\n",
			dp1->d_namep, dbip2->dbi_filename );
	    else
		printf( "kill %s\n# IMPORT %s from %s\n",
			dp1->d_namep, dp2->d_namep, dbip2->dbi_filename );
	    continue;
	}

	obj2 = Tcl_NewListObj( 0, NULL );
	Tcl_AppendObjToObj( obj2, Tcl_GetObjResult( interp ) );

	bu_vls_strcpy( &s2_tcl , Tcl_GetStringResult( interp ) );
	str2 = bu_vls_addr( &s2_tcl );
	Tcl_ResetResult( interp );

	/* got TCL versions of both */
	if( (dp1->d_flags & DIR_SOLID) && (dp2->d_flags & DIR_SOLID) ) {
	    /* both are solids */
	    compare_tcl_solids( str1, obj1, dp1, str2, obj2, dp2 );
	    if( pre_5_vers != 2 ) {
		has_diff += compare_attrs( dp1, dp2 );
	    }
	    continue;
	}

	if( (dp1->d_flags & DIR_COMB) && (dp2->d_flags & DIR_COMB ) ) {
	    /* both are combinations */
	    int len;
	    compare_tcl_combs( obj1, dp1, obj2, dp2 );
	    if( pre_5_vers != 2 ) {
		has_diff += compare_attrs( dp1, dp2 );
	    }
	    continue;
	}

	/* the two objects are different types */
	if( strcmp( str1, str2 ) ) {
	    has_diff += 1;
	    if( mode == HUMAN )
		printf( "%s:\n\twas: %s\n\tis now: %s\n\n",
			dp1->d_namep, str1, str2 );
	    else
		printf( "kill %s\ndb put %s %s\n",
			dp1->d_namep, dp2->d_namep, str2 );
	}
    } FOR_ALL_DIRECTORY_END;

    bu_vls_free( &s1_tcl );
    bu_vls_free( &s2_tcl );

    /* now look for objects in the other database that aren't here */
    FOR_ALL_DIRECTORY_START(dp2, dbip2) {
	/* skip the _GLOBAL object */
	if( dp2->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
	    continue;

	/* check if this object exists in the other database */
	if( (dp1 = db_lookup( dbip1, dp2->d_namep, 0 )) == DIR_NULL ) {
	    /* need to add this object */
	    has_diff += 1;
	    argv[2] = dp2->d_namep;
	    if( wdb_get_tcl( (ClientData)(wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( Tcl_GetStringResult(interp), "invalid", 7 ) ) {
		/* could not get TCL version */
		if( mode == HUMAN )
		    printf( "Import %s from %s\n",
			    dp2->d_namep, dbip2->dbi_filename );
		else
		    printf( "# IMPORT %s from %s\n",
			    dp2->d_namep, dbip2->dbi_filename );
	    } else {
		if( mode == HUMAN )
		    printf( "%s does not exist in %s\n",
			    dp2->d_namep, dbip1->dbi_filename );
		else
		    printf( "db put %s %s\n",
			    dp2->d_namep, Tcl_GetStringResult( interp ) );
	    }
	    Tcl_ResetResult( interp );
	}
    } FOR_ALL_DIRECTORY_END;

    return has_diff;
}

int
main(int argc, char **argv)
{
    char *invoked_as;
    char *file1, *file2;
    struct rt_wdb *wdb1, *wdb2;
    struct stat stat1, stat2;
    int c;
    int different = 0;

    invoked_as = argv[0];

    while ((c = bu_getopt(argc, argv, "mfv")) != EOF) {
	switch( c ) {
	    case 'm':	/* mged readable */
		mode = MGED;
		break;
	    case 'f':
		use_floats = 1;
		break;
	    case 'v':	/* verify region attributes */
		verify_region_attribs = 1;
		break;
	}
    }

    argc -= bu_optind;
    argv+= bu_optind;

    if( argc != 2 ) {
	Usage( invoked_as );
	bu_exit( 1, NULL );
    }

    file1 = *argv++;
    file2 = *argv;

    if (!bu_file_exists(file1)) {
	fprintf( stderr, "Cannot stat file %s\n", file1 );
	perror( file1 );
	bu_exit( 1, NULL );
    }

    if (!bu_file_exists(file2)) {
	fprintf( stderr, "Cannot stat file %s\n", file2 );
	perror( file2 );
	bu_exit( 1, NULL );
    }

    if (bu_same_file(file1, file2)) {
	fprintf( stderr, "%s and %s are the same file\n", file1, file2 );
	bu_exit( 1, NULL );
    }

    interp = Tcl_CreateInterp();
    if( Tcl_Init(interp) == TCL_ERROR ) {
	fprintf( stderr, "Tcl_Init error %s\n", Tcl_GetStringResult(interp));
	bu_exit( 1, NULL );
    }

    Rt_Init( interp );

    if( (dbip1 = db_open( file1, "r" )) == DBI_NULL ) {
	fprintf( stderr, "Cannot open %s\n", file1 );
	perror( argv[0] );
	bu_exit( 1, NULL );
    }

    RT_CK_DBI(dbip1);

    if( (wdb1 = wdb_dbopen( dbip1, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL ) {
	fprintf( stderr, "wdb_dbopen failed for %s\n", file1 );
	bu_exit( 1, NULL );
    }

    if( db_dirbuild( dbip1 ) < 0 ) {
	db_close( dbip1 );
	fprintf( stderr, "db_dirbuild failed on %s\n", file1 );
	bu_exit( 1, NULL );
    }

    if( wdb_init_obj( interp, wdb1, "_db1") != TCL_OK ) {
	wdb_close( wdb1 );
	fprintf( stderr, "wdb_init_obj failed on %s\n", file1 );
	bu_exit( 1, NULL );
    }

    if( wdb_create_cmd( interp, wdb1, "_db1" ) != TCL_OK ) {
	wdb_close( wdb1 );
	fprintf( stderr, "wdb_create_cmd failed on %s\n", file1 );
	bu_exit( 1, NULL );
    }

    /* save regionid colortable */
    mater_hd1 = rt_material_head;
    rt_material_head = MATER_NULL;

    if( dbip1->dbi_version < 5 ) {
	pre_5_vers++;
    }

    if( (dbip2 = db_open( file2, "r" )) == DBI_NULL ) {
	fprintf( stderr, "Cannot open %s\n", file2 );
	perror( argv[0] );
	bu_exit( 1, NULL );
    }

    RT_CK_DBI(dbip2);

    if( db_dirbuild( dbip2 ) < 0 ) {
	db_close( dbip1 );
	db_close( dbip2 );
	fprintf( stderr, "db_dirbuild failed on %s\n", file2 );
	bu_exit( 1, NULL );
    }

    if( (wdb2 = wdb_dbopen( dbip2, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL ) {
	db_close( dbip2 );
	wdb_close( wdb1 );
	fprintf( stderr, "wdb_dbopen failed for %s\n", file2 );
	bu_exit( 1, NULL );
    }

    if( wdb_init_obj( interp, wdb2, "_db2") != TCL_OK ) {
	wdb_close( wdb1 );
	wdb_close( wdb2 );
	fprintf( stderr, "wdb_init_obj failed on %s\n", file2 );
	bu_exit( 1, NULL );
    }

    if( wdb_create_cmd( interp, wdb2, "_db2" ) != TCL_OK ) {
	wdb_close( wdb1 );
	fprintf( stderr, "wdb_create_cmd failed on %s\n", file2 );
	bu_exit( 1, NULL );
    }

    /* save regionid colortable */
    mater_hd2 = rt_material_head;
    rt_material_head = MATER_NULL;

    if( dbip2->dbi_version < 5 ) {
	pre_5_vers++;
	version2 = 4;
    } else {
	version2 = 5;
    }

    if( mode == HUMAN) {
	printf( "\nChanges from %s to %s\n\n", dbip1->dbi_filename, dbip2->dbi_filename );
    }

    /* compare titles */
    if( strcmp( dbip1->dbi_title, dbip2->dbi_title ) ) {
	different = 1;
	if( mode == HUMAN ) {
	    printf( "Title has changed from: \"%s\" to: \"%s\"\n\n", dbip1->dbi_title, dbip2->dbi_title );
	} else {
	    printf( "title %s\n", dbip2->dbi_title );
	}
    }

    /* and units */
    if( dbip1->dbi_local2base != dbip2->dbi_local2base ) {
	different = 1;
	if( mode == HUMAN ) {
	    printf( "Units changed from %s to %s\n", bu_units_string(dbip1->dbi_local2base), bu_units_string(dbip2->dbi_local2base) );
	} else {
	    printf( "units %s\n", bu_units_string(dbip2->dbi_local2base) );
	}
    }

    /* and color table */
    if (compare_colors()) {
	different = 1;
    }

    /* finally, compare all the objects */
    if (diff_objs( wdb1, wdb2 )) {
	different = 1;
    }

    /* let the user know if there are no differences */
    if (different == 0) {
	printf("No differences.\n");
    }

    return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@exit->bu_exit where applicable
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.22 2007/09/15 16:23:06 brlcad Exp $";
d210 1
a210 1
	bu_exit( 1, "" );
d214 1
a214 1
	bu_exit( 1, "" );
d270 1
a270 1
	bu_exit ( 1, "" );
d276 1
a276 1
	bu_exit ( 1, "" );
d290 1
a290 1
	    bu_exit ( 1, "" );
d295 1
a295 1
	    bu_exit ( 1, "" );
d329 1
a329 1
	bu_exit ( 1, "" );
d334 1
a334 1
	bu_exit ( 1, "" );
d351 1
a351 1
	    bu_exit ( 1, "" );
d357 1
a357 1
	    bu_exit ( 1, "" );
d365 1
a365 1
		bu_exit ( 1, "" );
d372 1
a372 1
		    bu_exit ( 1, "" );
d408 1
a408 1
			    bu_exit( 1, "" );
d457 1
a457 1
	    bu_exit ( 1, "" );
d463 1
a463 1
	    bu_exit ( 1, "" );
d472 1
a472 1
		bu_exit ( 1, "" );
d513 1
a513 1
		bu_exit( 1, "" );
d606 1
a606 1
	bu_exit( 1, "" );
d614 1
a614 1
	bu_exit( 1, "" );
d687 1
a687 1
	bu_exit( 1, "" );
d728 1
a728 1
	    bu_exit( 1, "" );
d746 1
a746 1
	    bu_exit( 1, "" );
d947 1
a947 1
	bu_exit( 1, "" );
d956 1
a956 1
	bu_exit( 1, "" );
d962 1
a962 1
	bu_exit( 1, "" );
d967 1
a967 1
	bu_exit( 1, "" );
d973 1
a973 1
	bu_exit( 1, "" );
d981 1
a981 1
	bu_exit( 1, "" );
d988 1
a988 1
	bu_exit( 1, "" );
d994 1
a994 1
	bu_exit( 1, "" );
d1000 1
a1000 1
	bu_exit( 1, "" );
d1006 1
a1006 1
	bu_exit( 1, "" );
d1020 1
a1020 1
	bu_exit( 1, "" );
d1029 1
a1029 1
	bu_exit( 1, "" );
d1036 1
a1036 1
	bu_exit( 1, "" );
d1043 1
a1043 1
	bu_exit( 1, "" );
d1049 1
a1049 1
	bu_exit( 1, "" );
@


14.22
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.21 2007/07/26 01:13:54 brlcad Exp $";
d210 1
a210 1
	exit( 1 );
d214 1
a214 1
	exit( 1 );
d270 1
a270 1
	exit ( 1 );
d276 1
a276 1
	exit ( 1 );
d290 1
a290 1
	    exit ( 1 );
d295 1
a295 1
	    exit ( 1 );
d329 1
a329 1
	exit ( 1 );
d334 1
a334 1
	exit ( 1 );
d351 1
a351 1
	    exit ( 1 );
d357 1
a357 1
	    exit ( 1 );
d365 1
a365 1
		exit ( 1 );
d372 1
a372 1
		    exit ( 1 );
d408 1
a408 1
			    exit( 1 );
d457 1
a457 1
	    exit ( 1 );
d463 1
a463 1
	    exit ( 1 );
d472 1
a472 1
		exit ( 1 );
d513 1
a513 1
		exit( 1 );
d606 1
a606 1
	exit( 1 );
d614 1
a614 1
	exit( 1 );
d687 1
a687 1
	exit( 1 );
d728 1
a728 1
	    exit( 1 );
d746 1
a746 1
	    exit( 1 );
d947 1
a947 1
	exit( 1 );
d956 1
a956 1
	exit( 1 );
d962 1
a962 1
	exit( 1 );
d967 1
a967 1
	exit( 1 );
d973 1
a973 1
	exit( 1 );
d981 1
a981 1
	exit( 1 );
d988 1
a988 1
	exit( 1 );
d994 1
a994 1
	exit( 1 );
d1000 1
a1000 1
	exit( 1 );
d1006 1
a1006 1
	exit( 1 );
d1020 1
a1020 1
	exit( 1 );
d1029 1
a1029 1
	exit( 1 );
d1036 1
a1036 1
	exit( 1 );
d1043 1
a1043 1
	exit( 1 );
d1049 1
a1049 1
	exit( 1 );
@


14.21
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.20 2007/06/18 04:38:56 johnranderson Exp $";
d45 2
a46 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.20
log
@Added calls to wdb_create_command() since it had been removed from wdb_obj_init().
Also fixed a small bug where -f option would miss differences.
@
text
@a31 4
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5066
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.19 2007/05/14 21:04:30 brlcad Exp $";
@


14.19
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.18 2007/03/02 21:24:33 brlcad Exp $";
d246 14
d270 1
a270 1
    if( str_ret == 0 || type == ATTRS || !use_floats )
d272 1
d286 1
a286 1
    if( len1 != len2 )
d288 1
d291 3
d304 6
a309 2
	a = atof( Tcl_GetStringFromObj( obj1, NULL ) );
	b = atof( Tcl_GetStringFromObj( obj2, NULL ) );
d311 7
a317 2
	if( a != b ) {
	    return 1;
d866 1
d868 1
a868 1
	    if( !pre_5_vers != 2 ) {
d900 1
a900 1
	    if( wdb_get_tcl( (ClientData)(wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) ) {
d979 1
a979 1
	fprintf( stderr, "Tcl_Init error %s\n", interp->result);
d1010 6
d1053 6
@


14.18
log
@use bu_file_exists() instead of stat() to see if the file exists
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.17 2007/02/02 08:48:29 brlcad Exp $";
d1047 1
a1047 1
	    printf( "Units changed from %s to %s\n", rt_units_string(dbip1->dbi_local2base), rt_units_string(dbip2->dbi_local2base) );
d1049 1
a1049 1
	    printf( "units %s\n", rt_units_string(dbip2->dbi_local2base) );
@


14.17
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.16 2007/01/27 01:41:34 brlcad Exp $";
d931 1
a931 1
    if( stat( file1, &stat1 ) ) {
d937 1
a937 1
    if( stat( file2, &stat2 ) ) {
d943 1
a943 1
    if( stat1.st_dev == stat2.st_dev && stat1.st_ino == stat2.st_ino ) {
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.15 2007/01/23 01:13:32 brlcad Exp $";
d71 1
a71 1
extern int optind;
d906 1
a906 1
    while ((c = getopt(argc, argv, "mfv")) != EOF) {
d920 2
a921 2
    argc -= optind;
    argv+= optind;
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.14 2007/01/20 14:36:49 brlcad Exp $";
d214 1
a214 1
    
d223 1
a223 1
    
d228 1
a228 1
    
d233 1
a233 1
    
d1062 1
a1062 1
    
d1067 1
a1067 1
    
@


14.14
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.13 2006/04/29 03:10:07 brlcad Exp $";
@


14.13
log
@let the user know if there are no differences and be more specific on difference when external representations differ.
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2006 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.12 2006/04/05 19:15:42 brlcad Exp $";
@


14.12
log
@more header/warning cleanup from Intel compiler warnings on Altix
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.11 2006/01/28 00:36:28 brlcad Exp $";
d90 1
d92 7
d101 66
a166 43
	struct mater *mp1, *mp2;
	int found1=0, found2=0;
	int is_diff=0;

	for( mp1 = mater_hd1; mp1 != MATER_NULL; mp1 = mp1->mt_forw )  {
		found1 = 0;
		mp2 = mater_hd2;
		while( mp2 != MATER_NULL ) {
			if( mp1->mt_low == mp2->mt_low &&
			    mp1->mt_high == mp2->mt_high &&
			    mp1->mt_r == mp2->mt_r &&
			    mp1->mt_g == mp2->mt_g &&
			    mp1->mt_b == mp2->mt_b ) {
				found1 = 1;
				break;
			} else {
				mp2 = mp2->mt_forw;
			}
		}
		if( !found1 )
			break;
	}
	for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
		found1 = 0;
		mp1 = mater_hd1;
		while( mp1 != MATER_NULL ) {
			if( mp1->mt_low == mp2->mt_low &&
			    mp1->mt_high == mp2->mt_high &&
			    mp1->mt_r == mp2->mt_r &&
			    mp1->mt_g == mp2->mt_g &&
			    mp1->mt_b == mp2->mt_b ) {
				found2 = 1;
				break;
			} else {
				mp1 = mp1->mt_forw;
			}
		}
		if( !found2 )
			break;
	}
	if( !found1 && !found2 ) {
		return;
	} else if( !found1 || !found2 ) {
d168 4
a171 28
	} else {
		/* actually compare two color tables */
		mp1 = mater_hd1;
		mp2 = mater_hd2;
		while( mp1 != MATER_NULL && mp2 != MATER_NULL ) {
			if( mp1->mt_low != mp2->mt_low ) {
				is_diff = 1;
				break;
			}
			if( mp1->mt_high != mp2->mt_high ) {
				is_diff = 1;
				break;
			}
			if( mp1->mt_r != mp2->mt_r ) {
				is_diff = 1;
				break;
			}
			if( mp1->mt_g != mp2->mt_g ) {
				is_diff = 1;
				break;
			}
			if( mp1->mt_b != mp2->mt_b ) {
				is_diff = 1;
				break;
			}
			mp1 = mp1->mt_forw;
			mp2 = mp2->mt_forw;
		}
d173 1
d175 23
a197 21
	if( is_diff ) {
		if( mode == HUMAN ) {
			printf( "Color table has changed from:\n" );
			for( mp1 = mater_hd1; mp1 != MATER_NULL; mp1 = mp1->mt_forw )  {
				printf( "\t%d..%d %d %d %d\n", mp1->mt_low, mp1->mt_high,
					mp1->mt_r, mp1->mt_g, mp1->mt_b );
			}
			printf( "\t\tto:\n" );
			for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
				printf( "\t%d..%d %d %d %d\n", mp2->mt_low, mp2->mt_high,
					mp2->mt_r, mp2->mt_g, mp2->mt_b );
			}
		} else {
			if( version2 > 4 )
				printf( "attr rm _GLOBAL regionid_colortable\n" );
			for( mp2 = mater_hd2; mp2 != MATER_NULL; mp2 = mp2->mt_forw )  {
				printf( "color %d %d %d %d %d\n", mp2->mt_low, mp2->mt_high,
					mp2->mt_r, mp2->mt_g, mp2->mt_b );
			}
		}
	}
d201 1
a201 1
Usage(char *str)
d203 5
a207 1
	fprintf( stderr, "Usage: %s [-m] file1.g file2.g\n", str );
d210 2
a211 2
void
kill_obj(char *name)
d213 23
d237 1
a237 1
		printf( "%s has been killed\n", name );
d239 1
a239 27
		printf( "kill %s\n", name );
	}
}

void
compare_external(struct directory *dp1, struct directory *dp2)
{
	struct bu_external ext1, ext2;

	if( db_get_external( &ext1, dp1, dbip1 ) )
	{
		fprintf( stderr, "ERROR: db_get_external failed on solid %s in %s\n", dp1->d_namep, dbip1->dbi_filename );
		exit( 1 );
	}
	if( db_get_external( &ext2, dp2, dbip2 ) )
	{
		fprintf( stderr, "ERROR: db_get_external failed on solid %s in %s\n", dp2->d_namep, dbip2->dbi_filename );
		exit( 1 );
	}

	if( ext1.ext_nbytes != ext2.ext_nbytes ||
		bcmp( (void *)ext1.ext_buf, (void *)ext2.ext_buf, ext1.ext_nbytes ) )
	{
		if( mode == HUMAN )
			printf( "kill %s and import it from %s\n", dp1->d_namep, dbip1->dbi_filename );
		else
			printf( "kill %s\n# IMPORT %s from %s\n", dp1->d_namep, dp2->d_namep, dbip2->dbi_filename );
d241 3
d249 5
a253 5
	int len1, len2;
	int i;
	int str_ret;
	float a, b;
	Tcl_Obj *obj1, *obj2;
d255 1
a255 1
	str_ret = strcmp( Tcl_GetStringFromObj( val1, NULL ), Tcl_GetStringFromObj( val2, NULL ) );
d257 2
a258 2
	if( str_ret == 0 || type == ATTRS || !use_floats )
		return( str_ret );
d260 28
a287 6
	if( Tcl_ListObjLength( interp, val1, &len1 ) == TCL_ERROR )
	{
		fprintf( stderr, "Error getting length of TCL object!!!\n" );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		exit ( 1 );
	}
d289 2
a290 5
	if( Tcl_ListObjLength( interp, val2, &len2 ) == TCL_ERROR )
	{
		fprintf( stderr, "Error getting length of TCL object!!!\n" );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		exit ( 1 );
d292 1
d294 2
a295 2
	if( len1 != len2 )
		return 1;
d297 19
a315 20
	for( i=0 ; i<len1 ; i++ ) {
		if( Tcl_ListObjIndex( interp, val1, i, &obj1 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( val1, NULL ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}
		if( Tcl_ListObjIndex( interp, val2, i, &obj2 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( val2, NULL ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}
		a = atof( Tcl_GetStringFromObj( obj1, NULL ) );
		b = atof( Tcl_GetStringFromObj( obj2, NULL ) );

		if( a != b ) {
			return 1;
		}
	}
d317 1
a318 1
}
d320 24
a343 12
void
do_compare(int type, struct bu_vls *vls, Tcl_Obj *obj1, Tcl_Obj *obj2, char *obj_name)
{
	Tcl_Obj *key1, *val1, *key2, *val2;
	int len1, len2, found, junk;
	int i, j;
	int start_index;
	int found_diffs=0;

	if( Tcl_ListObjLength( interp, obj1, &len1 ) == TCL_ERROR )
	{
		fprintf( stderr, "Error getting length of TCL object!!!\n" );
d346 7
a352 171
	}
	if( Tcl_ListObjLength( interp, obj2, &len2 ) == TCL_ERROR )
	{
		fprintf( stderr, "Error getting length of TCL object!!!\n" );
		fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
		exit ( 1 );
	}

	if( !len1 && !len2 )
		return;

	if( type == ATTRS ) {
		start_index = 0;
	} else {
		start_index = 1;
	}

	/* check for changed values from object 1 to object2 */
	for( i=start_index ; i<len1 ; i+=2 )
	{
		if( Tcl_ListObjIndex( interp, obj1, i, &key1 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj1, &junk ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}

		if( Tcl_ListObjIndex( interp, obj1, i+1, &val1 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i+1, Tcl_GetStringFromObj( obj1, &junk ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}

		found = 0;
		for( j=start_index ; j<len2 ; j += 2 )
		{
			if( Tcl_ListObjIndex( interp, obj2, j, &key2 ) == TCL_ERROR )
			{
				fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", j, Tcl_GetStringFromObj( obj2, &junk ) );
				fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
				exit ( 1 );
			}
			if( !strcmp( Tcl_GetStringFromObj( key1, &junk ), Tcl_GetStringFromObj( key2, &junk ) ) )
			{
				found = 1;
				if( Tcl_ListObjIndex( interp, obj2, j+1, &val2 ) == TCL_ERROR )
				{
					fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", j+1, Tcl_GetStringFromObj( obj2, &junk ) );
					fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
					exit ( 1 );
				}

				/* check if this value has changed */
				if( compare_values( type, val1, val2 ) )
				{
					if( !found_diffs++ ) {
						if( mode == HUMAN ) {
							printf( "%s has changed:\n", obj_name );
						}
					}
					if( mode == HUMAN )
					{
						if( type == PARAMS ) {
							printf( "\tparameter %s has changed from:\n\t\t%s\n\tto:\n\t\t%s\n",
								Tcl_GetStringFromObj( key1, &junk ),
								Tcl_GetStringFromObj( val1, &junk ),
								Tcl_GetStringFromObj( val2, &junk ) );
						} else {
							printf( "\t%s attribute \"%s\" has changed from:\n\t\t%s\n\tto:\n\t\t%s\n",
								obj_name,
								Tcl_GetStringFromObj( key1, &junk ),
								Tcl_GetStringFromObj( val1, &junk ),
								Tcl_GetStringFromObj( val2, &junk ) );
						}
					}
					else
					{
						int val_len;

						if( type == ATTRS ) {
							bu_vls_printf( vls, "attr set %s ", obj_name );
						} else {
							bu_vls_strcat( vls, " " );
						}
						bu_vls_strcat( vls, Tcl_GetStringFromObj( key1, &junk ) );
						bu_vls_strcat( vls, " " );
						if( Tcl_ListObjLength( interp, val2, &val_len ) == TCL_ERROR )
						{
							fprintf( stderr, "Error getting length of TCL object!!\n" );
							fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
							exit( 1 );
						}
						if( val_len > 1 )
							bu_vls_putc( vls, '{' );
						bu_vls_strcat( vls, Tcl_GetStringFromObj( val2, &junk ) );
						if( val_len > 1 )
							bu_vls_putc( vls, '}' );
						if( type == ATTRS ) {
							bu_vls_putc( vls, '\n' );
						}
					}
				}
				break;
			}
		}
		if( !found )
		{
			/* this keyword value pair has been eliminated */
			if( !found_diffs++ ) {
				if( mode == HUMAN ) {
					printf( "%s has changed:\n", obj_name );
				}
			}
			if( mode == HUMAN )
			{
				if( type == PARAMS ) {
					printf( "\tparameter %s has been eliminated\n",
						Tcl_GetStringFromObj( key1, &junk ) );
				} else {
					printf( "\tattribute \"%s\" has been eliminated from %s\n",
						Tcl_GetStringFromObj( key1, &junk ), obj_name );
				}
			}
			else
			{
				if( type == ATTRS ) {
					bu_vls_printf( vls, "attr rm %s %s\n", obj_name,
						       Tcl_GetStringFromObj( key1, &junk ) );
				} else {
					bu_vls_strcat( vls, " " );
					bu_vls_strcat( vls, Tcl_GetStringFromObj( key1, &junk ) );
					bu_vls_strcat( vls, " none" );
				}
			}
		}
	}

	/* check for keyword value pairs in object 2 that don't appear in object 1 */
	for( i=start_index ; i<len2 ; i+= 2 )
	{
		/* get keyword/value pairs from object 2 */
		if( Tcl_ListObjIndex( interp, obj2, i, &key2 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj2, &junk ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}

		if( Tcl_ListObjIndex( interp, obj2, i+1, &val2 ) == TCL_ERROR )
		{
			fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i+1, Tcl_GetStringFromObj( obj2, &junk ) );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit ( 1 );
		}

		found = 0;
		/* look for this keyword in object 1 */
		for( j=start_index ; j<len1 ; j += 2 )
		{
			if( Tcl_ListObjIndex( interp, obj1, j, &key1 ) == TCL_ERROR )
			{
				fprintf( stderr, "Error getting word #%d in TCL object!!! (%s)\n", i, Tcl_GetStringFromObj( obj1, &junk ) );
				fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
				exit ( 1 );
			}
			if( !strcmp( Tcl_GetStringFromObj( key1, &junk ), Tcl_GetStringFromObj( key2, &junk ) ) )
			{
				found = 1;
				break;
			}
a353 2
		if( found )
			continue;
d355 3
a357 2
		/* This keyword/value pair in object 2 is not in object 1 */
		if( !found_diffs++ ) {
d359 1
a359 1
				printf( "%s has changed:\n", obj_name );
d361 2
a362 2
		}
		if( mode == HUMAN ) {
d364 4
a367 4
				printf( "\t%s has new parameter \"%s\" with value %s\n",
					obj_name,
					Tcl_GetStringFromObj( key2, &junk ),
					Tcl_GetStringFromObj( val2, &junk ) );
d369 5
a373 4
				printf( "\t%s has new attribute \"%s\" with value {%s}\n",
					obj_name,
					Tcl_GetStringFromObj( key2, &junk ),
					Tcl_GetStringFromObj( val2, &junk ) );
d375 1
a375 3
		}
		else
		{
d379 1
a379 1
				bu_vls_printf( vls, "attr set %s ", obj_name );
d381 1
a381 1
				bu_vls_strcat( vls, " " );
d383 1
a383 1
			bu_vls_strcat( vls, Tcl_GetStringFromObj( key2, &junk ) );
d385 4
a388 5
			if( Tcl_ListObjLength( interp, val2, &val_len ) == TCL_ERROR )
			{
				fprintf( stderr, "Error getting length of TCL object!!\n" );
				fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
				exit( 1 );
d391 1
a391 1
				bu_vls_putc( vls, '{' );
d394 5
a398 4
				bu_vls_putc( vls, '}' );

			if( type == ATTRS )
				bu_vls_putc( vls, '\n' );
d400 2
d403 64
a466 22
}

void
compare_tcl_solids(char *str1, Tcl_Obj *obj1, struct directory *dp1, char *str2, Tcl_Obj *obj2, struct directory *dp2)
{
	char *c1, *c2;
	struct bu_vls adjust;

	/* check if same solid type */
	c1 = str1;
	c2 = str2;
	while( *c1 != ' ' && *c2 != ' ' && *c1++ == *c2++ );

	if( *c1 != *c2 )
	{
		/* different solid types */
		if( mode == HUMAN )
			printf( "solid %s:\n\twas: %s\n\tis now: %s\n\n", dp1->d_namep, str1, str2 );
		else
			printf( "kill %s\ndb put %s %s\n", dp1->d_namep, dp1->d_namep, str2 );

		return;
d468 14
a481 2
	else if( !strcmp( str1, str2 ) )
		return;		/* no difference */
d483 17
a499 1
	/* same solid type, can use "db adjust" */
d501 2
a502 4
	if( mode == MGED )
	{
		bu_vls_init( &adjust );
		bu_vls_printf( &adjust, "db adjust %s", dp1->d_namep );
d504 3
d508 37
a544 1
	do_compare( PARAMS, &adjust, obj1, obj2, dp1->d_namep );
d546 1
a546 5
	if( mode != HUMAN )
	{
		printf( "%s\n", bu_vls_addr( &adjust ) );
		bu_vls_free( &adjust );
	}
d549 1
a549 1
void
d552 3
a554 2
	int junk;
	struct bu_vls adjust;
d556 3
a558 9
	/* first check if there is any difference */
	if( !strcmp( Tcl_GetStringFromObj( obj1, &junk ), Tcl_GetStringFromObj( obj2, &junk ) ) )
		return;

	if( mode != HUMAN )
	{
		bu_vls_init( &adjust );
		bu_vls_printf( &adjust, "db adjust %s", dp1->d_namep );
	}
d560 11
a570 1
	do_compare( PARAMS, &adjust, obj1, obj2, dp1->d_namep );
d572 1
a572 5
	if( mode != HUMAN )
	{
		printf( "%s\n", bu_vls_addr( &adjust ) );
		bu_vls_free( &adjust );
	}
d578 66
a643 67
	Tcl_Obj **objs;
	int len=0;
	int i;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;

	if( rt_db_get_internal( &intern, dp, dbip, NULL, &rt_uniresource ) < 0 ) {
		fprintf( stderr, "Cannot import %s\n", dp->d_namep );
		exit( 1 );
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CHECK_COMB( comb );

	if( Tcl_ListObjGetElements( interp, obj, &len, &objs ) != TCL_OK ) {
		fprintf( stderr, "Cannot get length of attributes for %s\n", dp->d_namep );
		exit( 1 );
	}

	for( i=1 ; i<len ; i += 2 ) {
		char *key, *value;

		key = Tcl_GetStringFromObj( objs[i-1], NULL );
		value = Tcl_GetStringFromObj( objs[i], NULL );
		if( !strcmp( key, "region_id" ) ) {
			short id;

			id = atoi( value );
			if( id != comb->region_id ) {
				fprintf( stderr, "WARNING: %s in %s: \"region_id\" attribute says %d, while region says %d\n",
					 dp->d_namep, dbip->dbi_filename, id, comb->region_id );
			}
		} else if( !strcmp( key, "giftmater" ) ) {
			short GIFTmater;

			GIFTmater = atoi( value );
			if( GIFTmater != comb->GIFTmater ) {
				fprintf( stderr, "WARNING: %s in %s: \"giftmater\" attribute says %d, while region says %d\n",
					 dp->d_namep, dbip->dbi_filename, GIFTmater, comb->GIFTmater );
			}
		} else if( !strcmp( key, "los" ) ) {
			short los;

			los = atoi( value );
			if( los != comb->los ) {
				fprintf( stderr, "WARNING: %s in %s: \"los\" attribute says %d, while region says %d\n",
					 dp->d_namep, dbip->dbi_filename, los, comb->los );
			}
		} else if( !strcmp( key, "material" ) ) {
			if( !strncmp( value, "gift", 4 ) ) {
				short GIFTmater;

				GIFTmater = atoi( &value[4] );
				if( GIFTmater != comb->GIFTmater ) {
					fprintf( stderr, "WARNING: %s in %s: \"material\" attribute says %s, while region says %d\n",
						 dp->d_namep, dbip->dbi_filename, value, comb->GIFTmater );
				}
			}
		} else if( !strcmp( key, "aircode" ) ) {
			short aircode;

			aircode = atoi( value );
			if( aircode != comb->aircode ) {
				fprintf( stderr, "WARNING: %s in %s: \"aircode\" attribute says %d, while region says %d\n",
					 dp->d_namep, dbip->dbi_filename, aircode, comb->aircode );
			}
		}
d645 2
a646 1
	rt_db_free_internal( &intern, &rt_uniresource );
d650 5
a654 5
			      "region_id",
			      "giftmater",
			      "los",
			      "aircode",
			      NULL };
d658 31
a688 32
	int len=0;
	Tcl_Obj **objs;
	char *key;
	int i,j;
	int found_material=0;

	if( Tcl_ListObjGetElements( interp, obj, &len, &objs ) != TCL_OK ) {
		fprintf( stderr, "Cannot get length of attributes for %s\n",
			 Tcl_GetStringFromObj( obj, NULL ) );
		exit( 1 );
	}

	if( len == 0 )
		return;

	for( i=len-1 ; i>0 ; i -= 2 ) {

		key = Tcl_GetStringFromObj( objs[i-1], NULL );
		j = 0;
		while( region_attrs[j] ) {
			if( !strcmp( key, region_attrs[j] ) ) {
				Tcl_ListObjReplace(interp, obj, i-1, 2, 0, NULL);
				break;
			}
			j++;
		}
		if( !found_material && !strcmp( key, "material" ) ) {
			found_material = 1;
			if( !strncmp( Tcl_GetStringFromObj( objs[i], NULL ), "gift", 4 ) ) {
				Tcl_ListObjReplace(interp, obj, i-1, 2, 0, NULL);
			}
		}
d690 1
d694 1
a694 1
void
d697 22
a718 2
	struct bu_vls vls;
	Tcl_Obj *obj1, *obj2;
d720 23
a742 1
	bu_vls_init( &vls );
d744 2
a745 7
	if( dbip1->dbi_version > 4 ) {
		bu_vls_printf( &vls, "db1 attr get %s", dp1->d_namep );
		if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK ) {
			fprintf( stderr, "Cannot get attributes for %s\n", dp1->d_namep );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit( 1 );
		}
d747 2
a748 35
		obj1 = Tcl_DuplicateObj( Tcl_GetObjResult( interp ) );
		Tcl_ResetResult( interp );
		if( dp1->d_flags & DIR_REGION && verify_region_attribs ) {
			verify_region_attrs( dp1, dbip1, obj1 );
		}
	} else {
		obj1 = Tcl_NewObj();
	}

	if( dbip2->dbi_version > 4 ) {
		bu_vls_trunc( &vls, 0 );
		bu_vls_printf( &vls, "db2 attr get %s", dp1->d_namep );
		if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK ) {
			fprintf( stderr, "Cannot get attributes for %s\n", dp1->d_namep );
			fprintf( stderr, "%s\n", Tcl_GetStringResult( interp ) );
			exit( 1 );
		}

		obj2 = Tcl_DuplicateObj( Tcl_GetObjResult( interp ) );
		Tcl_ResetResult( interp );
		if( dp1->d_flags & DIR_REGION && verify_region_attribs ) {
			verify_region_attrs( dp2, dbip2, obj2 );
		}
	} else {
		obj2 = Tcl_NewObj();
	}

	if( (dp1->d_flags & DIR_REGION) && (dp2->d_flags & DIR_REGION) ) {
		/* don't complain about "region" attributes */
		remove_region_attrs( obj1 );
		remove_region_attrs( obj2 );
	}

	bu_vls_trunc( &vls, 0 );
	do_compare( ATTRS, &vls, obj1, obj2, dp1->d_namep );
d750 1
a750 2
	printf( "%s", bu_vls_addr( &vls ) );
	bu_vls_free( &vls );
d753 1
a753 1
void
d756 17
a772 24
	int i;
	struct directory *dp1, *dp2;
	char *argv[4]={NULL, NULL, NULL, NULL};
	struct bu_vls s1_tcl, s2_tcl;
	struct bu_vls vls;

	RT_CK_WDB(wdb1);
	RT_CK_WDB(wdb2);

	bu_vls_init( &s1_tcl );
	bu_vls_init( &s2_tcl );
	bu_vls_init( &vls );

	/* look at all objects in this database */
	FOR_ALL_DIRECTORY_START(dp1, dbip1) {
		char *str1, *str2;
		Tcl_Obj *obj1, *obj2;

		/* check if this object exists in the other database */
		if( (dp2 = db_lookup( dbip2, dp1->d_namep, 0 )) == DIR_NULL )
		{
			kill_obj( dp1->d_namep );
			continue;
		}
d774 5
a778 14
		/* skip the _GLOBAL object */
		if( dp1->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
			continue;

		/* try to get the TCL version of this object */
		bu_vls_trunc( &vls, 0 );
		bu_vls_printf( &vls, "db1 get %s", dp1->d_namep );
		if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK )
		{
			/* cannot get TCL version, use bu_external */
			Tcl_ResetResult( interp );
			compare_external( dp1, dp2 );
			continue;
		}
d780 3
a782 2
		obj1 = Tcl_NewListObj( 0, NULL );
		Tcl_AppendObjToObj( obj1, Tcl_GetObjResult( interp ) );
d784 9
a792 2
		bu_vls_trunc( &s1_tcl, 0 );
		bu_vls_trunc( &s2_tcl, 0 );
d794 2
a795 20
		bu_vls_strcpy( &s1_tcl, Tcl_GetStringResult( interp ) );
		str1 = bu_vls_addr( &s1_tcl );
		Tcl_ResetResult( interp );

		/* try to get TCL version of object from the other database */
		bu_vls_trunc( &vls, 0 );
		bu_vls_printf( &vls, "db2 get %s", dp1->d_namep );
		if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK )
		{
			Tcl_ResetResult( interp );

			/* cannot get it, they MUST be different */
			if( mode == HUMAN )
				printf( "Replace %s with the same object from %s\n",
					dp1->d_namep, dbip2->dbi_filename );
			else
				printf( "kill %s\n# IMPORT %s from %s\n",
					dp1->d_namep, dp2->d_namep, dbip2->dbi_filename );
			continue;
		}
d797 2
a798 2
		obj2 = Tcl_NewListObj( 0, NULL );
		Tcl_AppendObjToObj( obj2, Tcl_GetObjResult( interp ) );
d800 3
a802 13
		bu_vls_strcpy( &s2_tcl , Tcl_GetStringResult( interp ) );
		str2 = bu_vls_addr( &s2_tcl );
		Tcl_ResetResult( interp );

		/* got TCL versions of both */
		if( (dp1->d_flags & DIR_SOLID) && (dp2->d_flags & DIR_SOLID) )
		{
			/* both are solids */
			compare_tcl_solids( str1, obj1, dp1, str2, obj2, dp2 );
			if( pre_5_vers != 2 )
				compare_attrs( dp1, dp2 );
			continue;
		}
d804 87
a890 8
		if( (dp1->d_flags & DIR_COMB) && (dp2->d_flags & DIR_COMB ) )
		{
			/* both are combinations */
			compare_tcl_combs( obj1, dp1, obj2, dp2 );
			if( !pre_5_vers != 2 )
				compare_attrs( dp1, dp2 );
			continue;
		}
d892 1
a892 48
		/* the two objects are different types */
		if( strcmp( str1, str2 ) )
		{
			if( mode == HUMAN )
				printf( "%s:\n\twas: %s\n\tis now: %s\n\n",
					dp1->d_namep, str1, str2 );
			else
				printf( "kill %s\ndb put %s %s\n",
					dp1->d_namep, dp2->d_namep, str2 );
		}
	} FOR_ALL_DIRECTORY_END;

	bu_vls_free( &s1_tcl );
	bu_vls_free( &s2_tcl );

	/* now look for objects in the other database that aren't here */
	FOR_ALL_DIRECTORY_START(dp2, dbip2) {
		/* skip the _GLOBAL object */
		if( dp2->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
			continue;

		/* check if this object exists in the other database */
		if( (dp1 = db_lookup( dbip1, dp2->d_namep, 0 )) == DIR_NULL )
		{
			/* need to add this object */
			argv[2] = dp2->d_namep;
			if( wdb_get_tcl( (ClientData)(wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
			{
				/* could not get TCL version */
				if( mode == HUMAN )
					printf( "Import %s from %s\n",
						dp2->d_namep, dbip2->dbi_filename );
				else
					printf( "# IMPORT %s from %s\n",
						dp2->d_namep, dbip2->dbi_filename );
			}
			else
			{
				if( mode == HUMAN )
					printf( "%s does not exist in %s\n",
						dp2->d_namep, dbip1->dbi_filename );
				else
					printf( "db put %s %s\n",
						dp2->d_namep, Tcl_GetStringResult( interp ) );
			}
			Tcl_ResetResult( interp );
		}
	} FOR_ALL_DIRECTORY_END;
d898 143
a1040 22
	char *invoked_as;
	char *file1, *file2;
	struct rt_wdb *wdb1, *wdb2;
	struct stat stat1, stat2;
	int c;

	invoked_as = argv[0];

	while ((c = getopt(argc, argv, "mfv")) != EOF)
	{
	 	switch( c )
		{
			case 'm':	/* mged readable */
				mode = MGED;
				break;
			case 'f':
				use_floats = 1;
				break;
			case 'v':	/* verify region attributes */
				verify_region_attribs = 1;
				break;
		}
d1042 1
d1044 5
a1048 114
	argc -= optind;
	argv+= optind;

	if( argc != 2 )
	{
		Usage( invoked_as );
		exit( 1 );
	}

	file1 = *argv++;
	file2 = *argv;

	if( stat( file1, &stat1 ) ) {
		fprintf( stderr, "Cannot stat file %s\n", file1 );
		perror( file1 );
		exit( 1 );
	}

	if( stat( file2, &stat2 ) ) {
		fprintf( stderr, "Cannot stat file %s\n", file2 );
		perror( file2 );
		exit( 1 );
	}

	if( stat1.st_dev == stat2.st_dev && stat1.st_ino == stat2.st_ino ) {
		fprintf( stderr, "%s and %s are the same file\n", file1, file2 );
		fprintf( stderr, "Cannot compare a file to itself!!\n" );
		exit( 1 );
	}

	interp = Tcl_CreateInterp();
	if( Tcl_Init(interp) == TCL_ERROR )
	{
		fprintf( stderr, "Tcl_Init error %s\n", interp->result);
		exit( 1 );
	}

	Rt_Init( interp );

	if( (dbip1 = db_open( file1, "r" )) == DBI_NULL )
	{
		fprintf( stderr, "Cannot open %s\n", file1 );
		perror( argv[0] );
		exit( 1 );
	}

	RT_CK_DBI(dbip1);

	if( (wdb1 = wdb_dbopen( dbip1, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL )
	{
		fprintf( stderr, "wdb_dbopen failed for %s\n", file1 );
		exit( 1 );
	}

	if( db_dirbuild( dbip1 ) < 0 )
	{
		db_close( dbip1 );
		fprintf( stderr, "db_dirbuild failed on %s\n", file1 );
		exit( 1 );
	}

	if( wdb_init_obj( interp, wdb1, "db1") != TCL_OK ) {
		wdb_close( wdb1 );
		fprintf( stderr, "wdb_init_obj failed on %s\n", file1 );
		exit( 1 );
	}

	/* save regionid colortable */
	mater_hd1 = rt_material_head;
	rt_material_head = MATER_NULL;

	if( dbip1->dbi_version < 5 ) {
		pre_5_vers++;
	}

	if( (dbip2 = db_open( file2, "r" )) == DBI_NULL )
	{
		fprintf( stderr, "Cannot open %s\n", file2 );
		perror( argv[0] );
		exit( 1 );
	}

	RT_CK_DBI(dbip2);

	if( db_dirbuild( dbip2 ) < 0 )
	{
		db_close( dbip1 );
		db_close( dbip2 );
		fprintf( stderr, "db_dirbuild failed on %s\n", file2 );
		exit( 1 );
	}

	if( (wdb2 = wdb_dbopen( dbip2, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL )
	{
		db_close( dbip2 );
		wdb_close( wdb1 );
		fprintf( stderr, "wdb_dbopen failed for %s\n", file2 );
		exit( 1 );
	}

	if( wdb_init_obj( interp, wdb2, "db2") != TCL_OK ) {
		wdb_close( wdb1 );
		wdb_close( wdb2 );
		fprintf( stderr, "wdb_init_obj failed on %s\n", file2 );
		exit( 1 );
	}

	/* save regionid colortable */
	mater_hd2 = rt_material_head;
	rt_material_head = MATER_NULL;

	if( dbip2->dbi_version < 5 ) {
		pre_5_vers++;
		version2 = 4;
d1050 1
a1050 22
		version2 = 5;
	}

	if( mode == HUMAN)
		printf( "\nChanges from %s to %s\n\n", dbip1->dbi_filename, dbip2->dbi_filename );

	/* compare titles */
	if( strcmp( dbip1->dbi_title, dbip2->dbi_title ) )
	{
		if( mode == HUMAN )
			printf( "Title has changed from: \"%s\" to: \"%s\"\n\n", dbip1->dbi_title, dbip2->dbi_title );
		else
			printf( "title %s\n", dbip2->dbi_title );
	}

	/* and units */
	if( dbip1->dbi_local2base != dbip2->dbi_local2base )
	{
		if( mode == HUMAN )
			printf( "Units changed from %s to %s\n", rt_units_string(dbip1->dbi_local2base), rt_units_string(dbip2->dbi_local2base) );
		else
			printf( "units %s\n", rt_units_string(dbip2->dbi_local2base) );
d1052 1
d1054 16
a1069 7
	/* and color table */
	compare_colors();

	/* next compare objects */
	diff_objs( wdb1, wdb2 );

	return( 0 );
@


14.11
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.10 2006/01/24 04:30:46 brlcad Exp $";
d55 3
@


14.11.2.1
log
@update from HEAD
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.11 2006/01/28 00:36:28 brlcad Exp $";
a54 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
@


14.10
log
@convert iteration over the array of linked lists to FOR_ALL_DIRECTORY_START/FOR_ALL_DIRECTORY_END instead
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.9 2006/01/18 06:46:15 brlcad Exp $";
d45 1
@


14.9
log
@update copyright to 2006
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.8 2005/10/23 04:44:30 brlcad Exp $";
d778 6
a783 3
	for( i = 0; i < RT_DBNHASH; i++)
	{
		for( dp1 = dbip1->dbi_Head[i]; dp1 != DIR_NULL; dp1 = dp1->d_forw )
d785 3
a787 2
			char *str1, *str2;
			Tcl_Obj *obj1, *obj2;
d789 14
a802 6
			/* check if this object exists in the other database */
			if( (dp2 = db_lookup( dbip2, dp1->d_namep, 0 )) == DIR_NULL )
			{
				kill_obj( dp1->d_namep );
				continue;
			}
d804 2
a805 14
			/* skip the _GLOBAL object */
			if( dp1->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
				continue;

			/* try to get the TCL version of this object */
			bu_vls_trunc( &vls, 0 );
			bu_vls_printf( &vls, "db1 get %s", dp1->d_namep );
			if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK )
			{
				/* cannot get TCL version, use bu_external */
				Tcl_ResetResult( interp );
				compare_external( dp1, dp2 );
				continue;
			}
d807 2
a808 2
			obj1 = Tcl_NewListObj( 0, NULL );
			Tcl_AppendObjToObj( obj1, Tcl_GetObjResult( interp ) );
d810 3
a812 2
			bu_vls_trunc( &s1_tcl, 0 );
			bu_vls_trunc( &s2_tcl, 0 );
d814 5
a818 2
			bu_vls_strcpy( &s1_tcl, Tcl_GetStringResult( interp ) );
			str1 = bu_vls_addr( &s1_tcl );
d821 9
a829 6
			/* try to get TCL version of object from the other database */
			bu_vls_trunc( &vls, 0 );
			bu_vls_printf( &vls, "db2 get %s", dp1->d_namep );
			if( Tcl_Eval( interp, bu_vls_addr( &vls ) ) != TCL_OK )
			{
				Tcl_ResetResult( interp );
d831 2
a832 9
				/* cannot get it, they MUST be different */
				if( mode == HUMAN )
					printf( "Replace %s with the same object from %s\n",
						dp1->d_namep, dbip2->dbi_filename );
				else
					printf( "kill %s\n# IMPORT %s from %s\n",
						dp1->d_namep, dp2->d_namep, dbip2->dbi_filename );
				continue;
			}
d834 3
a836 2
			obj2 = Tcl_NewListObj( 0, NULL );
			Tcl_AppendObjToObj( obj2, Tcl_GetObjResult( interp ) );
d838 9
a846 3
			bu_vls_strcpy( &s2_tcl , Tcl_GetStringResult( interp ) );
			str2 = bu_vls_addr( &s2_tcl );
			Tcl_ResetResult( interp );
d848 8
a855 9
			/* got TCL versions of both */
			if( (dp1->d_flags & DIR_SOLID) && (dp2->d_flags & DIR_SOLID) )
			{
				/* both are solids */
				compare_tcl_solids( str1, obj1, dp1, str2, obj2, dp2 );
				if( pre_5_vers != 2 )
					compare_attrs( dp1, dp2 );
				continue;
			}
d857 9
a865 19
			if( (dp1->d_flags & DIR_COMB) && (dp2->d_flags & DIR_COMB ) )
			{
				/* both are combinations */
				compare_tcl_combs( obj1, dp1, obj2, dp2 );
				if( !pre_5_vers != 2 )
					compare_attrs( dp1, dp2 );
				continue;
			}

			/* the two objects are different types */
			if( strcmp( str1, str2 ) )
			{
				if( mode == HUMAN )
					printf( "%s:\n\twas: %s\n\tis now: %s\n\n",
						dp1->d_namep, str1, str2 );
				else
					printf( "kill %s\ndb put %s %s\n",
						dp1->d_namep, dp2->d_namep, str2 );
			}
d867 1
a867 1
	}
d873 7
a879 3
	for( i = 0; i < RT_DBNHASH; i++)
	{
		for( dp2 = dbip2->dbi_Head[i]; dp2 != DIR_NULL; dp2 = dp2->d_forw )
d881 13
a893 6
			/* skip the _GLOBAL object */
			if( dp2->d_major_type == DB5_MAJORTYPE_ATTRIBUTE_ONLY )
				continue;

			/* check if this object exists in the other database */
			if( (dp1 = db_lookup( dbip1, dp2->d_namep, 0 )) == DIR_NULL )
d895 3
a897 12
				/* need to add this object */
				argv[2] = dp2->d_namep;
				if( wdb_get_tcl( (ClientData)(wdb2), interp, 3, argv ) == TCL_ERROR || !strncmp( interp->result, "invalid", 7 ) )
				{
					/* could not get TCL version */
					if( mode == HUMAN )
						printf( "Import %s from %s\n",
							dp2->d_namep, dbip2->dbi_filename );
					else
						printf( "# IMPORT %s from %s\n",
							dp2->d_namep, dbip2->dbi_filename );
				}
d899 2
a900 10
				{
					if( mode == HUMAN )
						printf( "%s does not exist in %s\n",
							dp2->d_namep, dbip1->dbi_filename );
					else
						printf( "db put %s %s\n",
							dp2->d_namep, Tcl_GetStringResult( interp ) );
				}
				Tcl_ResetResult( interp );

d902 1
d904 1
a904 1
	}
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1998-2005 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.7 2005/05/04 02:56:57 brlcad Exp $";
@


14.7
log
@ws
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.6 2005/01/30 20:30:37 brlcad Exp $";
d416 1
a416 1
				} else {	
d817 1
a817 1
			/* try to get TCL version of object from the other database */				
d910 1
a910 1
				
@


14.7.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header$";
d416 1
a416 1
				} else {
d817 1
a817 1
			/* try to get TCL version of object from the other database */
d910 1
a910 1

@


14.6
log
@update copyright to 2005
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/gtools/g_diff.c,v 14.5 2004/12/21 07:25:29 morrison Exp $";
a44 1

d50 1
a50 1
#include <string.h>
d52 1
a52 1
#include <strings.h>
d65 1
@


14.5
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/gtools/g_diff.c,v 14.4 2004/12/21 06:58:42 morrison Exp $";
@


14.4
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a36 2
 *
 *
d40 1
a40 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/gtools/g_diff.c,v 14.3 2004/12/21 06:50:58 morrison Exp $";
@


14.3
log
@remove the old distribution notice section
@
text
@a38 3
 *  Copyright Notice -
 *      This software is Copyright (C) 1998-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
d42 1
a42 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/gtools/g_diff.c,v 14.2 2004/12/20 20:21:31 morrison Exp $";
@


14.2
log
@assign copyright and GPL license
@
text
@a37 4
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
d45 1
a45 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/gtools/g_diff.c,v 14.1 2004/11/16 19:42:13 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ D I F F . C
d49 1
a49 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/gtools/g_diff.c,v 1.4 2004/09/03 23:30:56 morrison Exp $";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/gtools/g_diff.c,v 1.3 2004/08/02 23:01:47 morrison Exp $";
d1080 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/gtools/g_diff.c,v 1.2 2004/06/08 22:04:14 morrison Exp $";
d40 1
a40 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header$";
d33 1
a33 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvs/brlcad/gtools/g_diff.c,v 1.22 2004/05/10 15:30:42 erikg Exp $";
a48 1
#include "externs.h"
@

