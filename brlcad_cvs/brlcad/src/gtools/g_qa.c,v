head	1.48;
access;
symbols
	rel-7-10-4:1.37
	STABLE:1.37.0.2
	rel-7-10-2:1.37
	rel-7-10-0:1.37
	rel-7-8-4:1.34
	rel-7-8-2:1.33
	rel-7-8-0:1.33
	trimnurbs-branch:1.33.0.2
	help:1.33
	temp_tag:1.30
	bobWinPort-20051223-freeze:1.14
	postmerge-20051223-bobWinPort:1.30
	premerge-20051223-bobWinPort:1.30
	rel-7-6-6:1.30
	rel-7-6-4:1.26
	rel-7-6-2:1.21
	rel-7-6-branch:1.21.0.2
	rel-7-6-0:1.21
	rel-7-4-2:1.1.2.1
	rel-7-4-branch:1.1.0.2
	bobWinPort:1.14.0.2
	rel-7-4-0:1.1;
locks; strict;
comment	@ * @;


1.48
date	2007.12.14.20.53.28;	author brlcad;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.06.14.53.21;	author brlcad;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.01.21.47.12;	author brlcad;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.21.20.49.08;	author erikgreenwald;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.21.20.38.22;	author erikgreenwald;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.21.19.28.06;	author erikgreenwald;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.21.18.19.45;	author erikgreenwald;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.21.18.17.09;	author erikgreenwald;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.21.16.10.11;	author erikgreenwald;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.18.09.11.58;	author brlcad;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	1.37;

1.37
date	2007.01.27.01.41.34;	author brlcad;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.23.01.13.32;	author brlcad;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.20.14.36.49;	author brlcad;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.25.19.25.54;	author brlcad;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.30.21.12.11;	author brlcad;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.30.21.10.40;	author brlcad;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.13.13.17.38;	author brlcad;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.06.17.13.00;	author lbutler;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.06.16.20.21;	author lbutler;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.02.21.12.00;	author brlcad;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.08.14.36.32;	author lbutler;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.27.06.32.52;	author brlcad;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.27.06.23.54;	author brlcad;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.19.19.13.01;	author brlcad;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.08.20.17.29;	author lbutler;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2005.09.08.15.11.36;	author lbutler;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.24.04.44.49;	author brlcad;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.22.23.25.54;	author lbutler;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.16.19.43.38;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.16.18.53.18;	author lbutler;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.15.22.37.25;	author lbutler;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.12.22.41.57;	author lbutler;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.08.12.07.39;	author lbutler;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.03.21.13.56;	author lbutler;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.02.22.57.08;	author lbutler;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.30.04.11.53;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.28.19.51.48;	author lbutler;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.27.22.51.18;	author lbutler;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.25.22.27.19;	author lbutler;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.21.19.42.05;	author lbutler;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.20.22.37.26;	author lbutler;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.20.21.55.26;	author lbutler;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.19.20.55.46;	author lbutler;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.18.22.40.43;	author lbutler;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.01.21.47.42;	author lbutler;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.08.16.21.03.48;	author brlcad;	state Exp;
branches;
next	;

1.21.2.1
date	2005.11.13.13.46.14;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.48
log
@quell decl mismatch warnings
@
text
@/*                          G _ Q A . C
 * BRL-CAD
 *
 * Copyright (c) 2005-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file g_qa.c
 *
 * Author: Lee Butler
 *
 * perform quantitative analysis checks on geometry
 *
 * XXX need to look at gap computation
 *
 * plot the points where overlaps start/stop
 *
 *	Designed to be a framework for 3d sampling of the geometry volume.
 */

#include "common.h"

#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <math.h>
#include <limits.h>			/* home of INT_MAX aka MAXINT */

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "plot3.h"


#define SEM_WORK RT_SEM_LAST
#define SEM_SHOTS RT_SEM_LAST+1
#define SEM_STATS RT_SEM_LAST+2 /* semaphore for statistics */
#define SEM_LIST RT_SEM_LAST+3
#define TOTAL_SEMAPHORES SEM_LIST+1

/* bu_getopt() options */
char *options = "A:a:de:f:g:Gn:N:pP:rS:s:t:U:u:vV:W:";

#define ANALYSIS_VOLUME 1
#define ANALYSIS_WEIGHT 2
#define ANALYSIS_OVERLAPS 4
#define ANALYSIS_ADJ_AIR 8
#define ANALYSIS_GAP	16
#define ANALYSIS_EXP_AIR 32 /* exposed air */
#define ANALYSIS_BOX 64
#define ANALYSIS_INTERFACES 128

#ifndef HUGE
#  ifdef MAXFLT
#    define HUGE MAXFLOAT
#  else
#    ifdef DBL_MAX
#      define HUGE DBL_MAX
#    else
#      define HUGE ((float)3.40282346638528860e+38)
#    endif
#  endif
#endif

int analysis_flags = ANALYSIS_VOLUME | ANALYSIS_OVERLAPS | ANALYSIS_WEIGHT | \
	ANALYSIS_EXP_AIR | ANALYSIS_ADJ_AIR | ANALYSIS_GAP ;
int multiple_analyses = 1;


double azimuth_deg;
double elevation_deg;
char *densityFileName;
double gridSpacing = 50.0;
double gridSpacingLimit = 0.25; /* limit to 1/4 mm */
char makeOverlapAssemblies;
int require_num_hits = 1;
int ncpu = 1;
double Samples_per_model_axis = 2.0;
double overlap_tolerance;
double volume_tolerance = -1.0;
double weight_tolerance = -1.0;

int print_per_region_stats;
int max_region_name_len;
int use_air = 1;
int num_objects; /* number of objects specified on command line */
int max_cpus;
int num_views = 3;
int verbose;

int plot_files;	/* Boolean: Should we produce plot files? */
FILE *plot_weight;
FILE *plot_volume;
FILE *plot_overlaps;
FILE *plot_adjair;
FILE *plot_gaps;
FILE *plot_expair;

int overlap_color[3] = { 255, 255, 0 };	 /* yellow */
int gap_color[3] = { 128, 192, 255 };    /* cyan */
int adjAir_color[3] = { 128, 255, 192 }; /* pale green */
int expAir_color[3] = { 255, 128, 255 }; /* magenta */

int debug;
#define DLOG if (debug) bu_log

/* Some defines for re-using the values from the application structure
 * for other purposes
 */
#define A_LENDEN a_color[0]
#define A_LEN a_color[1]
#define A_STATE a_uptr


struct resource	resource[MAX_PSW];	/* memory resources for multi-cpu processing */

struct cstate {
    int curr_view;	/* the "view" number we are shooting */
    int u_axis; /* these 3 are in the range 0..2 inclusive and indicate which axis (X,Y,or Z) */
    int v_axis; /* is being used for the U, V, or invariant vector direction */
    int i_axis;

    /* SEM_WORK protects this */
    int v;	/* indicates how many "grid_size" steps in the v direction have been taken */

    /* SEM_STATS protects this */
    double	*m_lenDensity;
    double	*m_len;
    double	*m_volume;
    double	*m_weight;
    unsigned long *shots;
    int first;		/* this is the first time we've computed a set of views */

    vect_t u_dir;		/* direction of U vector for "current view" */
    vect_t v_dir;		/* direction of V vector for "current view" */
    struct rt_i *rtip;
    long steps[3];	/* this is per-dimension, not per-view */
    vect_t span;	/* How much space does the geometry span in each of X,Y,Z directions */
    vect_t area;	/* area of the view for view with invariant at index */

};

/* the entries in the density table */
struct density_entry {
    long	magic;
    double	grams_per_cu_mm;
    char	*name;
} *densities;
int num_densities;
#define DENSITY_MAGIC 0xaf0127


/* summary data structure for objects specified on command line */
struct per_obj_data {
    char *o_name;
    double *o_len;
    double *o_lenDensity;
    double *o_volume;
    double *o_weight;
} *obj_tbl;

/* this is the data we track for each region
 */
struct per_region_data {
    unsigned long hits;
    double	*r_lenDensity; /* for per-region per-view weight computation */
    double	*r_len; /* for per-region, per-veiew computation */
    double	*r_weight;
    double	*r_volume;
    struct per_obj_data *optr;
} *reg_tbl;


struct region_pair {
    struct bu_list 	l;
    union {
	char *name;
	struct region 	*r1;
    } r;
    struct region 	*r2;
    unsigned long	count;
    double		max_dist;
    vect_t		coord;
};

/* Access to these lists should be in sections
 * of code protected by SEM_LIST
 */

static struct region_pair gapList = { /* list of gaps */
    {
	BU_LIST_HEAD_MAGIC,
	(struct bu_list *)&gapList,
	(struct bu_list *)&gapList
    },
    { "Gaps" },
    (struct region *)NULL,
    (unsigned long)0,
    (double)0.0,
    {0.0, 0.0, 0.0,}
};
static struct region_pair adjAirList = { /* list of adjacent air */
    {
	BU_LIST_HEAD_MAGIC,
	(struct bu_list *)&adjAirList,
	(struct bu_list *)&adjAirList
    },
    { (char *)"Adjacent Air" },
    (struct region *)NULL,
    (unsigned long)0,
    (double)0.0,
    {0.0, 0.0, 0.0,}
};
static struct region_pair exposedAirList = { /* list of exposed air */
    {
	BU_LIST_HEAD_MAGIC,
	(struct bu_list *)&exposedAirList,
	(struct bu_list *)&exposedAirList
    },
    { "Exposed Air" },
    (struct region *)NULL,
    (unsigned long)0,
    (double)0.0,
    {0.0, 0.0, 0.0,}
};
static struct region_pair overlapList = { /* list of overlaps */
    {
	BU_LIST_HEAD_MAGIC,
	(struct bu_list *)&overlapList,
	(struct bu_list *)&overlapList
    },
    { "Overlaps" },
    (struct region *)NULL,
    (unsigned long)0,
    (double)0.0,
    {0.0, 0.0, 0.0,}
};


/* XXX this section should be extracted to libbu/units.c */

/* This structure holds the name of a unit value, and the conversion
 * factor necessary to convert from/to BRL-CAD statndard units.
 *
 * The standard units are millimeters, cubic millimeters, and grams.
 */
struct cvt_tab {
    double val;
    char name[32];
};

static const struct cvt_tab units_tab[3][40] = {
    { /* length, stolen from bu/units.c with the  "none" value removed
       * Values for converting from given units to mm
       */
	{1.0,		"mm"}, /* default */
	/*	{0.0,		"none"},*/ /* this is removed to force a certain
					    * amount of error checking for the user
					    */
	{1.0e-7,	"angstrom"},
	{1.0e-7,	"decinanometer"},
	{1.0e-6,	"nm"},
	{1.0e-6,	"nanometer"},
	{1.0e-3,	"um"},
	{1.0e-3,	"micrometer"},
	{1.0e-3,	"micron"},
	{1.0,		"millimeter"},
	{10.0,		"cm"},
	{10.0,		"centimeter"},
	{1000.0,	"m"},
	{1000.0,	"meter"},
	{1000000.0,	"km"},
	{1000000.0,	"kilometer"},
	{25.4,		"in"},
	{25.4,		"inch"},
	{25.4,		"inche"},		/* for plural */
	{304.8,		"ft"},
	{304.8,		"foot"},
	{304.8,		"feet"},
	{456.2,		"cubit"},
	{914.4,		"yd"},
	{914.4,		"yard"},
	{5029.2,	"rd"},
	{5029.2,	"rod"},
	{1609344.0,	"mi"},
	{1609344.0,	"mile"},
	{1852000.0,	"nmile"},
	{1852000.0,	"nautical mile"},
	{1.495979e+14,	"AU"},
	{1.495979e+14,	"astronomical unit"},
	{9.460730e+18,	"lightyear"},
	{3.085678e+19,	"pc"},
	{3.085678e+19,	"parsec"},
	{0.0,		""}			/* LAST ENTRY */
    },
    {/* volume
      * Values for converting from given units to mm^3
      */
	{1.0, "cu mm"}, /* default */

	{1.0, "mm"},
	{1.0, "mm^3"},

	{1.0e3, "cm"},
	{1.0e3, "cm^3"},
	{1.0e3, "cu cm"},
	{1.0e3, "cc"},

	{1.0e6, "l"},
	{1.0e6, "liter"},
	{1.0e6, "litre"},

	{1.0e9, "m"},
	{1.0e9, "m^3"},
	{1.0e9, "cu m"},

	{16387.064, "in"},
	{16387.064, "in^3"},
	{16387.064, "cu in"},

	{28316846.592, "ft"},

	{28316846.592, "ft^3"},
	{28316846.592, "cu ft"},

	{764554857.984, "yds"},
	{764554857.984, "yards"},
	{764554857.984, "cu yards"},

	{0.0,		""}			/* LAST ENTRY */
    },
    { /* weight
       * Values for converting given units to grams
       */
	{1.0, "grams"}, /* default */

	{1.0, "g"},
	{0.0648, "gr"},
	{0.0648, "grains"},

	{1.0e3, "kg"},
	{1.0e3, "kilos"},
	{1.0e3, "kilograms"},

	{28.35, "oz"},
	{28.35, "ounce"},

	{453.6, "lb"},
	{453.6, "lbs"},
	{0.0,		""}			/* LAST ENTRY */
    }
};

/* this table keeps track of the "current" or "user selected units and the
 * associated conversion values
 */
#define LINE 0
#define VOL 1
#define WGT 2
static const struct cvt_tab *units[3] = {
    &units_tab[0][0],	/* linear */
    &units_tab[1][0],	/* volume */
    &units_tab[2][0]	/* weight */
};


/*
 *	read_units_double
 *
 *	Read a non-negative floating point value with optional units
 *
 *	Return
 *		1 Failure
 *		0 Success
 */
int
read_units_double(double *val, char *buf, const struct cvt_tab *cvt)
{
    double a;
    char units_string[256] = {0};
    int i;


    i = sscanf(buf, "%lg%256s", &a, units_string);

    if (i < 0) return 1;

    if (i == 1) {
	*val = a;

	return 0;
    }
    if (i == 2) {
	*val = a;
	for ( ; cvt->name[0] != '\0' ; ) {
	    if (!strncmp(cvt->name, units_string, 256)) {
		goto found_units;
	    } else {
		cvt++;
	    }
	}
	bu_log("Bad units specifier \"%s\" on value \"%s\"\n", units_string, buf);
	return 1;

    found_units:
	*val = a * cvt->val;
	return 0;
    }
    bu_log("%s sscanf problem on \"%s\"  got %d\n", BU_FLSTR, buf, i);
    return 1;
}

/* the above should be extracted to libbu/units.c */


/*
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void
usage(const char *s)
{
    if (s) {
	fputs(s, stderr);
    }

    fprintf(stderr, "Usage: %s [options] model object [object...]\n", bu_getprogname());

    bu_exit(1, NULL);
}


/*
 *	P A R S E _ A R G S --- Parse through command line flags
 */
int
parse_args(int ac, char *av[])
{
    int  c;
    int i;
    double a;
    char *p;

    /* Turn off getopt's error messages */
    bu_opterr = 0;

    /* get all the option flags from the command line */
    while ((c=bu_getopt(ac,av,options)) != EOF) {
	switch (c) {
	case 'A'	:
	    {
		char *p;
		analysis_flags = 0;
		multiple_analyses = 0;
		for (p = bu_optarg; *p ; p++) {
		    switch (*p) {
		    case 'A' :
			analysis_flags = ANALYSIS_VOLUME | ANALYSIS_WEIGHT | \
			    ANALYSIS_OVERLAPS | ANALYSIS_ADJ_AIR | ANALYSIS_GAP | \
			    ANALYSIS_EXP_AIR;
			multiple_analyses = 1;
			break;
		    case 'a' :
			if (analysis_flags)
			    multiple_analyses = 1;

			    analysis_flags |= ANALYSIS_ADJ_AIR;

			break;
		    case 'b' :
			if (analysis_flags)
			    multiple_analyses = 1;

			analysis_flags |= ANALYSIS_BOX;

			break;
		    case 'e' :
			if (analysis_flags)
			    multiple_analyses = 1;

			analysis_flags |= ANALYSIS_EXP_AIR;
			break;
		    case 'g' :
			if (analysis_flags)
			    multiple_analyses = 1;

			analysis_flags |= ANALYSIS_GAP;
			break;
		    case 'o' :
			if (analysis_flags)
			    multiple_analyses = 1;

			analysis_flags |= ANALYSIS_OVERLAPS;
			break;
		    case 'v' :
			if (analysis_flags)
			    multiple_analyses = 1;

			analysis_flags |= ANALYSIS_VOLUME;
			break;
		    case 'w' :
			if (analysis_flags)
			    multiple_analyses = 1;

			analysis_flags |= ANALYSIS_WEIGHT;
			break;
		    default:
			bu_exit(EXIT_FAILURE, "Unknown analysis type \"%c\" requested.\n", *p);
			break;
		    }
		}
		break;
	    }
	case 'a'	:
	    bu_log("azimuth not implemented\n");
	    if (sscanf(bu_optarg, "%lg", &azimuth_deg) != 1)
		bu_exit(EXIT_FAILURE, "error parsing azimuth \"%s\"\n", bu_optarg);
	    break;
	case 'e'	:
	    bu_log("elevation not implemented\n");
	    if (sscanf(bu_optarg, "%lg", &elevation_deg) != 1)
		bu_exit(EXIT_FAILURE, "error parsing elevation \"%s\"\n", bu_optarg);
	    break;
	case 'd'	: debug = 1; break;

	case 'f'	: densityFileName = bu_optarg; break;

	case 'g'	:
	    {
		double value1, value2;
		i = 0;


		/* find out if we have two or one args
		 * user can separate them with , or - delimiter
		 */
		if (p = strchr(bu_optarg, ','))  	 *p++ = '\0';
		else if (p = strchr(bu_optarg, '-')) *p++ = '\0';


		if (read_units_double(&value1, bu_optarg, units_tab[0]))
		    bu_exit(EXIT_FAILURE, "error parsing grid spacing value \"%s\"\n", bu_optarg);
		if (p) {
		    /* we've got 2 values, they are upper limit and lower limit */
		    if (read_units_double(&value2, p, units_tab[0]))
			bu_exit(EXIT_FAILURE, "error parsing grid spacing limit value \"%s\"\n", p);
		    gridSpacing = value1;
		    gridSpacingLimit = value2;
		} else {
		    gridSpacingLimit = value1;

		    gridSpacing = 0.0; /* flag it */
		}

		bu_log("set grid spacing:%g %s limit:%g %s\n",
		       gridSpacing / units[LINE]->val, units[LINE]->name,
		       gridSpacingLimit / units[LINE]->val, units[LINE]->name);
		break;
	    }
	case 'G'	:
	    makeOverlapAssemblies = 1;
	    bu_exit(EXIT_FAILURE, "-G option unimplemented\n");
	    break;
	case 'n'	:
	    if (sscanf(bu_optarg, "%d", &c) != 1 || c < 0)
		bu_exit(EXIT_FAILURE, "num_hits must be integer value >= 0, not \"%s\"\n", bu_optarg);
	    require_num_hits = c;
	    break;

	case 'N'	:
	    num_views = atoi(bu_optarg);
	    break;
	case 'p'	:
	    plot_files = ! plot_files;
	    break;
	case 'P'	:
	    /* cannot ask for more cpu's than the machine has */
	    if ((c=atoi(bu_optarg)) > 0 && c <= max_cpus ) ncpu = c;
	    break;
	case 'r'	:
	    print_per_region_stats = 1;
	    break;
	case 'S'	:
	    if (sscanf(bu_optarg, "%lg", &a) != 1 || a <= 1.0) {
		bu_log("error in specifying minimum samples per model axis: \"%s\"\n", bu_optarg);
		break;
	    }
	    Samples_per_model_axis = a + 1;
	    break;
	case 't'	:
	    if (read_units_double(&overlap_tolerance, bu_optarg, units_tab[0]))
		bu_exit(EXIT_FAILURE, "error in overlap tolerance distance \"%s\"\n", bu_optarg);
	    break;
	case 'v'	:
	    verbose = 1;
	    break;
	case 'V'	:
	    if (read_units_double(&volume_tolerance, bu_optarg, units_tab[1]))
		bu_exit(-1, "error in volume tolerance \"%s\"\n", bu_optarg);
	    break;
	case 'W'	:
	    if (read_units_double(&weight_tolerance, bu_optarg, units_tab[2]))
		bu_exit(-1, "error in weight tolerance \"%s\"\n", bu_optarg);
	    break;

	case 'U'	:
	    use_air = strtol(bu_optarg, (char **)NULL, 10);
	    if (errno == ERANGE || errno == EINVAL) {
		perror("-U argument");
		bu_exit(EXIT_FAILURE, NULL);	/* left blank due to use of perror() */
	    }
	    break;
	case 'u'	:
	    {
		char *ptr = bu_optarg;
		const struct cvt_tab *cv;
		static const char *dim[3] = {"length", "volume", "weight"};
		char *units_name[3];

		for (i=0 ; i < 3 && ptr; i++) {
		    units_name[i] = strsep(&ptr, ",");

		    /* make sure the unit value is in the table */
		    if (*units_name[i] != '\0') {
			for (cv= &units_tab[i][0] ; cv->name[0] != '\0' ; cv++) {
			    if (!strcmp(cv->name, units_name[i])) {
				goto found_cv;
			    }
			}
			bu_exit(EXIT_FAILURE, "Units \"%s\" not found in coversion table\n", units_name[i]);
		    found_cv:
			units[i] = cv;
		    }
		}

		bu_log("Units: ");
		for (i=0 ; i < 3 ; i++) {
		    bu_log(" %s: %s", dim[i], units[i]->name);
		}
		bu_log("\n");
		break;
	    }

	case '?'	:
	case 'h'	:
	default		:
	    fprintf(stderr, "Bad or help flag '%c' specified\n", c);
	    usage("");
	    break;
	}
    }

    return(bu_optind);
}


/*
 *	parse_densities_buffer
 *
 */
void
parse_densities_buffer(char *buf, unsigned long len)
{
    char *p, *q, *last;
    long idx;
    double density;

    buf[len] = '\0';
    last = &buf[len];

    p = buf;

    densities = bu_malloc(sizeof(struct density_entry)*128, "density entries");
    num_densities = 128;

    while (*p) {
	idx = strtol(p, &q, 10);
	if (q == (char *)NULL) {
	    bu_exit(EXIT_FAILURE, "could not convert idx\n");
	}

	if (idx < 0)
	    bu_exit(EXIT_FAILURE, "bad density index (< 0) %d\n", idx);

	density = strtod(q, &p);
	if (q == p)
	    bu_exit(EXIT_FAILURE, "could not convert density\n");

	if (density < 0.0)
	    bu_exit(EXIT_FAILURE, "bad density (< 0) %g\n", density);

	while ((*p == '\t') || (*p == ' ')) p++;

	if ((q = strchr(p, '\n')))
	    *q++ = '\0';
	else
	    q = last;

	while (idx >= num_densities) {
	    densities = bu_realloc(densities, sizeof(struct density_entry)*num_densities*2,
				   "density entries");
	    num_densities *= 2;
	}

	densities[idx].magic = DENSITY_MAGIC;
	/* since BRL-CAD does computation in mm, but the table is
	 * in grams / (cm^3) we convert the table on input
	 */
	densities[idx].grams_per_cu_mm = density / 1000.0;
	densities[idx].name = bu_strdup(p);

	p = q;
    } while (p && p < last);

#ifdef PRINT_DENSITIES
    for (idx=0 ; idx < num_densities ; idx++)
	if (densities[idx].magic == DENSITY_MAGIC)
	    bu_log("%4d %6g %s\n",
		   idx,
		   densities[idx].density,
		   densities[idx].name
		   );
#endif
}
/*	g e t _ d e n s i t i e s _ f r o m _ f i l e
 *
 * Returns
 *	 0 on success
 *	!0 on failure
 */
int
get_densities_from_file(char *name)
{
    FILE *fp;
    struct stat sb;
    char *buf;

    if ((fp=fopen(name, "r")) == (FILE *)NULL) {
	perror(name);
	return 1;
    }

    if (fstat(fileno(fp), &sb)) {
	perror(name);
	return 1;
    }

    buf = bu_malloc(sb.st_size, "density buffer");
    fread(buf, sb.st_size, 1, fp);
    parse_densities_buffer(buf, (unsigned long)sb.st_size);
    bu_free(buf, "density buffer");
    fclose(fp);
    return 0;
}

/*
 *	g e t _ d e n s i t i e s _ f r o m _ d a t a b a s e
 *
 * Returns
 *	 0 on success
 *	!0 on failure
 */
int
get_densities_from_database(struct rt_i *rtip)
{
    struct directory *dp;
    struct rt_db_internal intern;
    struct rt_binunif_internal *bu;

    dp = db_lookup(rtip->rti_dbip, "_DENSITIES", LOOKUP_QUIET);
    if (dp == (struct directory *)NULL) {
	bu_log("No \"_DENSITIES\" density table object in database\n");
	return -1;
    }

    if (rt_db_get_internal(&intern, dp, rtip->rti_dbip, NULL, &rt_uniresource) < 0) {
	bu_log("could not import %s\n", dp->d_namep);
	return 1;
    }

    if ((intern.idb_major_type & DB5_MAJORTYPE_BINARY_MASK) == 0)
	return 1;

    bu = (struct rt_binunif_internal *)intern.idb_ptr;

    RT_CHECK_BINUNIF(bu);

    parse_densities_buffer(bu->u.int8, bu->count);
    return 0;
}

/*
 *	add_unique_pair
 *
 *	This routine must be prepared to run in parallel
 *
 *
 *
 */
struct region_pair *
add_unique_pair(struct region_pair *list, /* list to add into */
		struct region *r1,	/* first region involved */
		struct region *r2,	/* second region involved */
		double dist,		/* distance/thickness metric value */
		point_t pt)		/* location where this takes place */
{
    struct region_pair *rp, *rpair;

    /* look for it in our list */
    bu_semaphore_acquire( SEM_LIST );
    for( BU_LIST_FOR(rp, region_pair, &list->l) ) {

	if ( (r1 == rp->r.r1 && r2 == rp->r2) || (r1 == rp->r2 && r2 == rp->r.r1) ) {
	    /* we already have an entry for this region pair,
	     * we increase the counter, check the depth and
	     * update thickness maximum and entry point if need be
	     * and return.
	     */
	    rp->count++;

	    if (dist > rp->max_dist) {
		rp->max_dist = dist;
		VMOVE(rp->coord, pt);
	    }
	    rpair = rp;
	    goto found;
	}
    }
    /* didn't find it in the list.  Add it */
    rpair = bu_malloc(sizeof(struct region_pair), "region_pair");
    rpair->r.r1 = r1;
    rpair->r2 = r2;
    rpair->count = 1;
    rpair->max_dist = dist;
    VMOVE(rpair->coord, pt);
    list->max_dist ++; /* really a count */

    /* insert in the list at the "nice" place */
    for( BU_LIST_FOR(rp, region_pair, &list->l) ) {
	if (strcmp(rp->r.r1->reg_name, r1->reg_name) <= 0 )
	    break;
    }
    BU_LIST_INSERT(&rp->l, &rpair->l);
 found:
    bu_semaphore_release( SEM_LIST );
    return rpair;
}


/*
 *			O V E R L A P
 *
 *  Write end points of partition to the standard output.
 *  If this routine return !0, this partition will be dropped
 *  from the boolean evaluation.
 *
 *	Returns:
 *	 0	to eliminate partition with overlap entirely
 *	 1	to retain partition in output list, claimed by reg1
 *	 2	to retain partition in output list, claimed by reg2
 *
 *	This routine must be prepared to run in parallel
 *
 */
int
overlap(struct application *ap,
	struct partition *pp,
	struct region *reg1,
	struct region *reg2,
	struct partition *hp)
{

    register struct xray	*rp = &ap->a_ray;
    register struct hit	*ihitp = pp->pt_inhit;
    register struct hit	*ohitp = pp->pt_outhit;
    point_t ihit;
    point_t ohit;
    double depth;

    /* if one of the regions is air, let it loose */
    if (reg1->reg_aircode && ! reg2->reg_aircode)
	return 2;
    if (reg2->reg_aircode && ! reg1->reg_aircode)
	return 1;

    depth = ohitp->hit_dist - ihitp->hit_dist;

    if( depth < overlap_tolerance )
	/* too small to matter, pick one or none */
	return(1);

    VJOIN1( ihit, rp->r_pt, ihitp->hit_dist, rp->r_dir );
    VJOIN1( ohit, rp->r_pt, ohitp->hit_dist, rp->r_dir );

    if (plot_overlaps) {
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	pl_color(plot_overlaps, V3ARGS(overlap_color));
	pdv_3line(plot_overlaps, ihit, ohit);
	bu_semaphore_release(BU_SEM_SYSCALL);
    }

    if (analysis_flags & ANALYSIS_OVERLAPS) {
#if 0
	struct region_pair *rp =
#endif
	    add_unique_pair(&overlapList, reg1, reg2, depth, ihit);

	if (plot_overlaps) {
	    bu_semaphore_acquire(BU_SEM_SYSCALL);
	    pl_color(plot_overlaps, V3ARGS(overlap_color));
	    pdv_3line(plot_overlaps, ihit, ohit);
#if 0
	    pdv_3line(plot_overlaps, ihit, rp->coord);
	    pdv_3line(plot_overlaps, ihit, rp->coord);
#endif
	    bu_semaphore_release(BU_SEM_SYSCALL);
	}
    } else
	bu_log("overlap %s %s\n", reg1->reg_name, reg2->reg_name);

    /* XXX We should somehow flag the volume/weight calculations as invalid */

    /* since we have no basis to pick one over the other, just pick */
    return(1);	/* No further consideration to this partition */
}

/*
 *	logoverlap
 *
 */
void
logoverlap(struct application *ap,
	   const struct partition *pp,
	   const struct bu_ptbl *regiontable,
	   const struct partition *InputHdp)
{
    RT_CK_AP(ap);
    RT_CK_PT(pp);
    BU_CK_PTBL(regiontable);
    return;
}

void exposed_air(struct partition *pp,
		 point_t last_out_point,
		 point_t pt,
		 point_t opt)
{
    /* this shouldn't be air */

    add_unique_pair(&exposedAirList,
		    pp->pt_regionp,
		    (struct region *)NULL,
		    pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist, /* thickness */
		    last_out_point); /* location */

    if (plot_expair) {
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	pl_color(plot_expair, V3ARGS(expAir_color));
	pdv_3line(plot_expair, pt, opt);
	bu_semaphore_release(BU_SEM_SYSCALL);
    }


}


/*
 *  rt_shootray() was told to call this on a hit.  It passes the
 *  application structure which describes the state of the world
 *  (see raytrace.h), and a circular linked list of partitions,
 *  each one describing one in and out segment of one region.
 *
 *	This routine must be prepared to run in parallel
 *
 */
int
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
{
    /* see raytrace.h for all of these guys */
    register struct partition *pp;
    point_t		pt, opt, last_out_point;
    int			last_air = 0; /* what was the aircode of the last item */
    int			air_first = 1; /* are we in an air before a solid */
    double	dist;	/* the thickness of the partition */
    double	gap_dist;
    double	last_out_dist = -1.0;
    double	val;
    struct cstate *state = ap->A_STATE;

    if (PartHeadp->pt_forw == PartHeadp) return 1;


    /* examine each partition until we get back to the head */
    for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
	struct density_entry *de;

	/* inhit info */
	dist = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);
	VJOIN1(opt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);

	DLOG("%s %g->%g\n",
			  pp->pt_regionp->reg_name,
			  pp->pt_inhit->hit_dist,
			  pp->pt_outhit->hit_dist);

	/* checking for air sticking out of the model .
	 * This is done here because there may be any number of air
	 * regions sticking out of the model along the ray.
	 */
	if (analysis_flags & ANALYSIS_EXP_AIR) {

	    gap_dist = (pp->pt_inhit->hit_dist - last_out_dist);

	    /* if air is first on the ray, or we're moving from void/gap to air
	     * then this is exposed air
	     */
	    if (pp->pt_regionp->reg_aircode &&
		(air_first || gap_dist > overlap_tolerance)) {
		exposed_air(pp, last_out_point, pt, opt);
	    } else {
		air_first = 0;
	    }
	}

	/* looking for voids in the model */
	if (analysis_flags & ANALYSIS_GAP) {
	    if (pp->pt_back != PartHeadp) {
		/* if this entry point is further than the previous exit point
		 * then we have a void
		 */
		gap_dist = pp->pt_inhit->hit_dist - last_out_dist;

		if (gap_dist > overlap_tolerance) {

		    /* like overlaps, we only want to report unique pairs */
		    add_unique_pair(&gapList,
				    pp->pt_regionp,
				    pp->pt_back->pt_regionp,
				    gap_dist,
				    pt);

		    /* like overlaps, let's plot */
		    if (plot_gaps) {
			vect_t gapEnd;
			VJOIN1(gapEnd, pt, -gap_dist, ap->a_ray.r_dir);

			bu_semaphore_acquire(BU_SEM_SYSCALL);
			pl_color(plot_gaps, V3ARGS(gap_color));
			pdv_3line(plot_gaps, pt, gapEnd);
			bu_semaphore_release(BU_SEM_SYSCALL);
		    }
		}
	    }
	}

	/* computing the weight of the objects */
	if (analysis_flags & ANALYSIS_WEIGHT) {
	    DLOG("Hit %s doing weight\n", pp->pt_regionp->reg_name);
	    /* make sure mater index is within range of densities */
	    if (pp->pt_regionp->reg_gmater >= num_densities)
		bu_exit(EXIT_FAILURE, "density index %d on region %s is outside of range of table [1..%d]\nSet GIFTmater on region or add entry to density table\n",
		       pp->pt_regionp->reg_gmater,
		       pp->pt_regionp->reg_name,
		       num_densities); /* XXX this should do something else */
	    else {

		/* make sure the density index has been set */
		de = &densities[pp->pt_regionp->reg_gmater];
		if (de->magic == DENSITY_MAGIC) {
		    struct per_region_data *prd;

		    /* factor in the density of this object
		     * weight computation, factoring in the LOS
		     * percentage material of the object
		     */
		    int los = pp->pt_regionp->reg_los;

		    if (los < 1) {
			bu_log("bad LOS (%d) on %s\n", los, pp->pt_regionp->reg_name );
		    }

		    /* accumulate the total weight values */
		    val = de->grams_per_cu_mm * dist * (pp->pt_regionp->reg_los * 0.01);
		    ap->A_LENDEN += val;

		    prd = ((struct per_region_data *)pp->pt_regionp->reg_udata);
		    /* accumulate the per-region per-view weight values */
		    bu_semaphore_acquire(SEM_STATS);
		    prd->r_lenDensity[state->i_axis] += val;

		    /* accumulate the per-object per-view weight values */
		    prd->optr->o_lenDensity[state->i_axis] += val;
		    bu_semaphore_release(SEM_STATS);

		} else
		    bu_exit(EXIT_FAILURE, "density index %d from region %s is not set.\nAdd entry to density table\n",
			   pp->pt_regionp->reg_gmater, pp->pt_regionp->reg_name);
	    }
	}

	/* compute the volume of the object */
	if (analysis_flags & ANALYSIS_VOLUME) {
	    struct per_region_data *prd = ((struct per_region_data *)pp->pt_regionp->reg_udata);
	    ap->A_LEN += dist; /* add to total volume */
	    {
		bu_semaphore_acquire(SEM_STATS);

		/* add to region volume */
		prd->r_len[state->curr_view] += dist;

		/* add to object volume */
		prd->optr->o_len[state->curr_view] += dist;

		bu_semaphore_release(SEM_STATS);
	    }

	    DLOG("\t\tvol hit %s oDist:%g objVol:%g %s\n",
		     pp->pt_regionp->reg_name,
		     dist,
		     prd->optr->o_len[state->curr_view],
		     prd->optr->o_name);

	    if (plot_volume) {
		point_t opt;

		VJOIN1(opt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);

		bu_semaphore_acquire(BU_SEM_SYSCALL);
		if (ap->a_user & 1) {
		    pl_color(plot_volume, V3ARGS(gap_color));
		} else {
		    pl_color(plot_volume, V3ARGS(adjAir_color));
		}

		pdv_3line(plot_volume, pt, opt);
		bu_semaphore_release(BU_SEM_SYSCALL);
	    }
	}


	/* look for two adjacent air regions */
	if (analysis_flags & ANALYSIS_ADJ_AIR) {
	    if (last_air && pp->pt_regionp->reg_aircode &&
		pp->pt_regionp->reg_aircode != last_air) {

		double d = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
		point_t aapt;

		add_unique_pair(&adjAirList, pp->pt_back->pt_regionp, pp->pt_regionp, 0.0, pt);


		d *= 0.25;
		VJOIN1(aapt, pt, d, ap->a_ray.r_dir);

		bu_semaphore_acquire(BU_SEM_SYSCALL);
		pl_color(plot_adjair, V3ARGS(adjAir_color));
		pdv_3line(plot_adjair, pt, aapt);
		bu_semaphore_release(BU_SEM_SYSCALL);

	    }
	}

	/* note that this region has been seen */
	((struct per_region_data *)pp->pt_regionp->reg_udata)->hits++;

	last_air = pp->pt_regionp->reg_aircode;
	last_out_dist = pp->pt_outhit->hit_dist;
	VJOIN1(last_out_point, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
    }


    if (analysis_flags & ANALYSIS_EXP_AIR && last_air) {
	/* the last thing we hit was air.  Make a note of that */
	pp = PartHeadp->pt_back;

	exposed_air(pp, last_out_point, pt, opt);
    }


    /*
     * This value is returned by rt_shootray
     * a hit usually returns 1, miss 0.
     */
    return(1);
}

/*
 * rt_shootray() was told to call this on a miss.
 *
 *	This routine must be prepared to run in parallel
 *
 */
int
miss(register struct application *ap)
{
#if 0
    bu_log("missed\n");
#endif
    return(0);
}

/*
 *	get_next_row
 *
 *
 *	This routine must be prepared to run in parallel
 *
 */
int
get_next_row(struct cstate *state)
{
    int v;
    /* look for more work */
    bu_semaphore_acquire(SEM_WORK);

    if (state->v < state->steps[state->v_axis])
	v = state->v++;	/* get a row to work on */
    else
	v = 0; /* signal end of work */

    bu_semaphore_release(SEM_WORK);

    return v;
}
/*
 *	plane_worker
 *
 *
 *	This routine must be prepared to run in parallel
 *
 */
void
plane_worker (int cpu, genptr_t ptr)
{
    struct application ap;
    int u, v;
    double v_coord;
    struct cstate *state = (struct cstate *)ptr;

    RT_APPLICATION_INIT(&ap);
    ap.a_rt_i = (struct rt_i *)state->rtip;	/* application uses this instance */
    ap.a_hit = hit;			/* where to go on a hit */
    ap.a_miss = miss;		/* where to go on a miss */
    ap.a_logoverlap = logoverlap;
    ap.a_overlap = overlap;
    ap.a_resource = &resource[cpu];
    ap.A_LENDEN = 0.0; /* really the cumulative length*density  for weight computation*/
    ap.A_LEN = 0.0; /* really the cumulative length for volume computation */

    /* gross hack */
    ap.a_ray.r_dir[state->u_axis] = ap.a_ray.r_dir[state->v_axis] = 0.0;
    ap.a_ray.r_dir[state->i_axis] = 1.0;

    ap.A_STATE = ptr; /* really copying the state ptr to the a_uptr */

    u = -1;

    while ((v = get_next_row(state))) {

	v_coord = v * gridSpacing;
	DLOG("  v = %d v_coord=%g\n", v, v_coord);

	if ( (v&1) || state->first) {
	    /* shoot all the rays in this row.
	     * This is either the first time a view has been computed
	     * or it is an odd numbered row in a grid refinement
	     */
	    for (u=1 ; u < state->steps[state->u_axis]; u++) {
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u*gridSpacing;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v*gridSpacing;
		ap.a_ray.r_pt[state->i_axis] = ap.a_rt_i->mdl_min[state->i_axis];

		DLOG("%5g %5g %5g -> %g %g %g\n", V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));
		ap.a_user = v;
		(void)rt_shootray( &ap );

		bu_semaphore_acquire(SEM_STATS);
		state->shots[state->curr_view]++;
		bu_semaphore_release(SEM_STATS);
	    }
	} else {
	    /* shoot only the rays we need to on this row.
	     * Some of them have been computed in a previous iteration.
	     */
	    for (u=1 ; u < state->steps[state->u_axis]; u+=2) {
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u*gridSpacing;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v*gridSpacing;
		ap.a_ray.r_pt[state->i_axis] = ap.a_rt_i->mdl_min[state->i_axis];

		DLOG("%5g %5g %5g -> %g %g %g\n", V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));
		ap.a_user = v;
		(void)rt_shootray( &ap );

		bu_semaphore_acquire(SEM_STATS);
		state->shots[state->curr_view]++;
		bu_semaphore_release(SEM_STATS);

		if (debug)
		    if (u+1 <  state->steps[state->u_axis])
			bu_log("  ---\n");
	    }
	}
    }

    if (u == -1) {
	DLOG("didn't shoot any rays\n");
    }

    /* There's nothing else left to work on in this view.
     * It's time to add the values we have accumulated
     * to the totals for the view and return.  When all
     * threads have been through here, we'll have returned
     * to serial computation.
     */
    bu_semaphore_acquire(SEM_STATS);
    state->m_lenDensity[state->curr_view] += ap.A_LENDEN; /* add our length*density value */
    state->m_len[state->curr_view] += ap.A_LEN; /* add our volume value */
    bu_semaphore_release(SEM_STATS);
}

/*
 *
 */
int
find_cmd_line_obj(struct per_obj_data *obj_rpt, const char *name)
{
    int i;
    char *str = strdup(name);
    char *p;

    if ((p=strchr(str, '/'))) {
	*p = '\0';
    }

    for (i=0 ; i < num_objects ; i++) {
	if (!strcmp(obj_rpt[i].o_name, str)) {
	    bu_free(str, "");
	    return i;
	}
    }
    bu_exit(EXIT_FAILURE, "%s Didn't find object named \"%s\" in %d entries\n", BU_FLSTR, name, num_objects);
    /* NOTREACHED */
    return -1; /* stupid compiler */
}

/*
 * allocate_per_region_data
 *
 *	Allocate data structures for tracking statistics on a per-view basis
 *	for each of the view, object and region levels.
 */
void
allocate_per_region_data(struct cstate *state, int start, int ac, char *av[])
{
    struct region *regp;
    struct rt_i *rtip = state->rtip;
    int i;
    int m;

    state->m_lenDensity = bu_calloc(sizeof(double), num_views, "densityLen");
    state->m_len = bu_calloc(sizeof(double), num_views, "volume");
    state->m_volume = bu_calloc(sizeof(double), num_views, "volume");
    state->m_weight = bu_calloc(sizeof(double), num_views, "volume");
    state->shots = bu_calloc(sizeof(unsigned long), num_views, "volume");

    /* build data structures for the list of
     * objects the user specified on the command line
     */
    obj_tbl = bu_calloc(sizeof(struct per_obj_data), num_objects, "report tables");
    for (i=0 ; i < num_objects ; i++) {
	obj_tbl[i].o_name = av[start+i];
	obj_tbl[i].o_len = bu_calloc(sizeof(double), num_views, "o_len");
	obj_tbl[i].o_lenDensity = bu_calloc(sizeof(double), num_views, "o_lenDensity");
	obj_tbl[i].o_volume = bu_calloc(sizeof(double), num_views, "o_volume");
	obj_tbl[i].o_weight = bu_calloc(sizeof(double), num_views, "o_weight");
    }

    /* build objects for each region */
    reg_tbl = bu_calloc(rtip->nregions, sizeof(struct per_region_data), "per_region_data");


    for( i=0 , BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) , i++)  {
	regp->reg_udata = &reg_tbl[i];

	reg_tbl[i].r_lenDensity = bu_calloc(sizeof(double), num_views, "r_lenDensity");
	reg_tbl[i].r_len = bu_calloc(sizeof(double), num_views, "r_len");
	reg_tbl[i].r_volume = bu_calloc(sizeof(double), num_views, "len");
	reg_tbl[i].r_weight = bu_calloc(sizeof(double), num_views, "len");

	m = strlen(regp->reg_name);
	if (m > max_region_name_len) max_region_name_len = m;
	reg_tbl[i].optr = &obj_tbl[ find_cmd_line_obj(obj_tbl, &regp->reg_name[1]) ];

    }
}


/*
 *	list_report
 *
 */
void
list_report(struct region_pair *list)
{
    struct region_pair *rp;

    if (BU_LIST_IS_EMPTY(&list->l)) {
	bu_log("No %s\n", (char *)list->r.name);
	return;
    }

    bu_log("list %s:\n", (char *)list->r.name);

    for (BU_LIST_FOR(rp, region_pair, &(list->l))) {
	if (rp->r2) {
	    bu_log("%s %s count:%lu dist:%g%s @@ (%g %g %g)\n",
	       rp->r.r1->reg_name, rp->r2->reg_name, rp->count,
	       rp->max_dist / units[LINE]->val, units[LINE]->name, V3ARGS(rp->coord));
	} else {
	    bu_log("%s count:%lu dist:%g%s @@ (%g %g %g)\n",
	       rp->r.r1->reg_name, rp->count,
	       rp->max_dist / units[LINE]->val, units[LINE]->name, V3ARGS(rp->coord));
	}
    }
}


/*
 *	options_prep
 *
 *	Do some computations prior to raytracing based upon
 *	options the user has specified
 *
 *	Returns:
 *		0	continue, ready to go
 *		!0	error encountered, terminate processing
 */
int
options_prep(struct rt_i *rtip, vect_t span)
{
    double newGridSpacing = gridSpacing;
    int axis;

    /* figure out where the density values are comming from and get them */
    if (analysis_flags & ANALYSIS_WEIGHT) {
	if (densityFileName) {
	    DLOG("density from file\n");
	    if (get_densities_from_file(densityFileName)) {
		return -1;
	    }
	} else {
	    DLOG("density from db\n");
	    if (get_densities_from_database(rtip)) {
		return -1;
	    }
	}
    }
    /* refine the grid spacing if the user has set a
     * lower bound on the number of rays per model axis
     */
    for (axis=0 ; axis < 3 ; axis++) {
	if (span[axis] < newGridSpacing*Samples_per_model_axis) {
	    /* along this axis, the gridSpacing is
	     * larger than the model span.  We need to refine.
	     */
	    newGridSpacing = span[axis] / Samples_per_model_axis;
	}
    }

    if (newGridSpacing != gridSpacing) {
	bu_log("Grid spacing %g %s is does not allow %g samples per axis\n",
	       gridSpacing / units[LINE]->val, units[LINE]->name, Samples_per_model_axis - 1);

	bu_log("Adjusted to %g %s to get %g samples per model axis\n",
	       newGridSpacing / units[LINE]->val, units[LINE]->name, Samples_per_model_axis);

	gridSpacing = newGridSpacing;
    }

    /* if the vol/weight tolerances are not set, pick something */
    if (analysis_flags & ANALYSIS_VOLUME) {
	char *name = "volume.pl";
	if (volume_tolerance == -1.0) {
	    volume_tolerance = span[X] * span[Y] * span[Z] * 0.001;
	    bu_log("setting volume tolerance to %g %s\n",
		   volume_tolerance / units[VOL]->val, units[VOL]->name);
	} else
	    bu_log("volume tolerance   %g\n", volume_tolerance);
	if ( plot_files )
	    if ( (plot_volume=fopen(name, "w")) == (FILE *)NULL)
		bu_exit(EXIT_FAILURE, "cannot open plot file %s\n", name);
    }
    if (analysis_flags & ANALYSIS_WEIGHT) {
	if (weight_tolerance == -1.0) {
	    double max_den = 0.0;
	    int i;
	    for (i=0 ; i < num_densities ; i++) {
		if (densities[i].grams_per_cu_mm > max_den)
		    max_den = densities[i].grams_per_cu_mm;
	    }
	    weight_tolerance = span[X] * span[Y] * span[Z] * 0.1 * max_den;
	    bu_log("setting weight tolerance to %g %s\n",
		   weight_tolerance / units[WGT]->val,
		   units[WGT]->name);
	} else {
	    bu_log("weight tolerance   %g\n", weight_tolerance);
	}
    }
    if (analysis_flags & ANALYSIS_GAP) {
	char *name = "gaps.pl";
	if ( plot_files )
	    if ( (plot_gaps=fopen(name, "w")) == (FILE *)NULL)
		bu_exit(EXIT_FAILURE, "cannot open plot file %s\n", name);
    }
    if (analysis_flags & ANALYSIS_OVERLAPS) {
	if (overlap_tolerance != 0.0)
	    bu_log("overlap tolerance to %g\n", overlap_tolerance);
	if ( plot_files ) {
	    char *name = "overlaps.pl";
	    if ((plot_overlaps=fopen(name, "w")) == (FILE *)NULL)
		bu_exit(EXIT_FAILURE, "cannot open plot file %s\n", name);
	}
    }

    if (print_per_region_stats)
	if ( (analysis_flags & (ANALYSIS_VOLUME|ANALYSIS_WEIGHT)) == 0)
	    bu_log("Note: -r option ignored: neither volume or weight options requested\n");

    if ( analysis_flags & ANALYSIS_ADJ_AIR)
	if (plot_files) {
	    char *name = "adj_air.pl";
	    if ( (plot_adjair=fopen(name, "w")) == (FILE *)NULL)
		bu_exit(EXIT_FAILURE, "cannot open plot file %s\n", name);
	}

    if ( analysis_flags & ANALYSIS_EXP_AIR)
	if (plot_files) {
	    char *name = "exp_air.pl";
	    if ( (plot_expair=fopen(name, "w")) == (FILE *)NULL)
		bu_exit(EXIT_FAILURE, "cannot open plot file %s\n", name);
	}

    if ( (analysis_flags & (ANALYSIS_ADJ_AIR|ANALYSIS_EXP_AIR)) && ! use_air )
	bu_exit(EXIT_FAILURE, "Error:  Air regions discarded but air analysis requested!\nSet use_air non-zero or eliminate air analysis\n");

    return 0;
}

/*
 *	view_reports
 *
 */
void
view_reports(struct cstate *state)
{
    if (analysis_flags & ANALYSIS_VOLUME) {
	int obj;
	int view;

	/* for each object, compute the volume for all views */
	for (obj=0 ; obj < num_objects ; obj++) {
	    double val;
	    /* compute volume of object for given view */
	    view = state->curr_view;

	    /* compute the per-view volume of this object */

	    if (state->shots[view] > 0) {
		val = obj_tbl[obj].o_volume[view] =
		    obj_tbl[obj].o_len[view] * (state->area[view] / state->shots[view]);

		if (verbose)
		    bu_log("\t%s volume %g %s\n",
		       obj_tbl[obj].o_name,
		       val / units[VOL]->val,
		       units[VOL]->name);
	    }
	}
    }
    if (analysis_flags & ANALYSIS_WEIGHT) {
	int obj;
	int view = state->curr_view;

	for (obj=0 ; obj < num_objects ; obj++) {
	    double grams_per_cu_mm = obj_tbl[obj].o_lenDensity[view] *
		(state->area[view] / state->shots[view]);


		if (verbose)
		    bu_log("\t%s %g %s\n",
			   obj_tbl[obj].o_name,
			   grams_per_cu_mm / units[WGT]->val,
			   units[WGT]->name);
	}
    }
}

/*	w e i g h t _ v o l u m e _ t e r m i n a t e
 *
 * These checks are unique because they must both be completed.
 * Early termination before they are done is not an option.
 * The results computed here are used later
 *
 * Returns:
 *	0 terminate
 *	1 continue processing
 */
static int
weight_volume_terminate(struct cstate *state)
{
    /* Both weight and volume computations rely on this routine to compute values
     * that are printed in summaries.  Hence, both checks must always be done before
     * this routine exits.  So we store the status (can we terminate processing?)
     * in this variable and act on it once both volume and weight computations are done
     */
    int can_terminate = 1;

    double low, hi, val, delta;

    if (analysis_flags & ANALYSIS_WEIGHT) {
	/* for each object, compute the weight for all views */
	int obj;

	for (obj=0 ; obj < num_objects ; obj++) {
	    int view = 0;
	    if (verbose)
		bu_log("object %d\n", obj);
	    /* compute weight of object for given view */
	    val = obj_tbl[obj].o_weight[view] =
		obj_tbl[obj].o_lenDensity[view] * (state->area[view] / state->shots[view]);

	    low = hi = 0.0;

	    /* compute the per-view weight of this object */
	    for (view=1 ; view < num_views ; view++) {
		obj_tbl[obj].o_weight[view] =
		    obj_tbl[obj].o_lenDensity[view] *
		    (state->area[view] / state->shots[view]);

		delta = val - obj_tbl[obj].o_weight[view];
		if (delta < low) low = delta;
		if (delta > hi) hi = delta;
	    }
	    delta = hi - low;

	    if (verbose)
		bu_log("\t%s weight %g %s +%g -%g\n",
		       obj_tbl[obj].o_name,
		       val / units[WGT]->val,
		       units[WGT]->name,
		       fabs(hi / units[WGT]->val),
		       fabs(low / units[WGT]->val));

	    if (delta > weight_tolerance) {
		/* this object differs too much in each view, so we need to refine the grid */
		/* signal that we cannot terminate */
		can_terminate = 0;
		if (verbose)
		    bu_log("\t%s differs too much in weight per view.\n",
			   obj_tbl[obj].o_name);
	    }
	}
	if (can_terminate) {
	    if (verbose)
		bu_log("all objects within tolerance on weight calculation\n");
	}
    }

    if (analysis_flags & ANALYSIS_VOLUME) {
	/* find the range of values for object volumes */
	int obj;

	/* for each object, compute the volume for all views */
	for (obj=0 ; obj < num_objects ; obj++) {

	    /* compute volume of object for given view */
	    int view = 0;
	    val = obj_tbl[obj].o_volume[view] =
		obj_tbl[obj].o_len[view] * (state->area[view] / state->shots[view]);

	    low = hi = 0.0;
	    /* compute the per-view volume of this object */
	    for (view=1 ; view < num_views ; view++) {
		obj_tbl[obj].o_volume[view] =
		    obj_tbl[obj].o_len[view] * (state->area[view] / state->shots[view]);

		delta = val - obj_tbl[obj].o_volume[view];
		if (delta < low) low = delta;
		if (delta > hi) hi = delta;
	    }
	    delta = hi - low;

	    if (verbose)
		bu_log("\t%s volume %g %s +(%g) -(%g)\n",
		       obj_tbl[obj].o_name,
		       val / units[VOL]->val, units[VOL]->name,
		       hi / units[VOL]->val,
		       fabs(low / units[VOL]->val));

	    if (delta > volume_tolerance) {
		/* this object differs too much in each view, so we need to refine the grid */
		can_terminate = 0;
		if (verbose)
		    bu_log("\tvolume tol not met on %s.  Refine grid\n",
			   obj_tbl[obj].o_name);
		break;
	    }
	}
    }

    if (can_terminate) {
	return 0; /* signal we don't want to go onward */
    }
    return 1;
}


/*
 *	t e r m i n a t e _ c h e c k
 *
 *	Check to see if we are done processing due to
 *	some user specified limit being achieved.
 *
 *	Returns:
 *	0	Terminate
 *	1	Continue processing
 */
int
terminate_check(struct cstate *state)
{
    int wv_status;

    DLOG("terminate_check\n");
    RT_CK_RTI(state->rtip);

    if (plot_overlaps) fflush(plot_overlaps);
    if (plot_weight) fflush(plot_weight);
    if (plot_volume) fflush(plot_volume);
    if (plot_adjair) fflush(plot_adjair);
    if (plot_gaps) fflush(plot_gaps);
    if (plot_expair) fflush(plot_expair);


    /* this computation is done first, because there are
     * side effects that must be obtained whether we terminate or not
     */
    wv_status = weight_volume_terminate(state);


    /* if we've reached the grid limit, we're done, no matter what */
    if (gridSpacing < gridSpacingLimit) {
	if (verbose)
	    bu_log("grid spacing refined to %g (below lower limit %g)\n",
		   gridSpacing, gridSpacingLimit);
	return 0;
    }

    /* if we are doing one of the "Error" checking operations:
     * Overlap, gap, adj_air, exp_air, then we ALWAYS go to the
     * grid spacing limit and we ALWAYS terminate on first
     * error/list-entry
     */
    if ( (analysis_flags & ANALYSIS_OVERLAPS)) {
	if (BU_LIST_NON_EMPTY(&overlapList.l)) {
	    /* since we've found an overlap, we can quit */
	    return 0;
	} else {
	    bu_log("overlaps list is empty\n");
	}
    }
    if ( (analysis_flags & ANALYSIS_GAP)) {
	if (BU_LIST_NON_EMPTY(&gapList.l)) {
	    /* since we've found a gap, we can quit */
	    return 0;
	}
    }
    if ( (analysis_flags & ANALYSIS_ADJ_AIR)) {
	if (BU_LIST_NON_EMPTY(&adjAirList.l)) {
	    /* since we've found adjacent air, we can quit */
	    return 0;
	}
    }
    if ( (analysis_flags & ANALYSIS_EXP_AIR)) {
	if (BU_LIST_NON_EMPTY(&exposedAirList.l)) {
	    /* since we've found exposed air, we can quit */
	    return 0;
	}
    }


    if (analysis_flags & (ANALYSIS_WEIGHT|ANALYSIS_VOLUME)) {
	/* volume/weight checks only get to terminate processing if there
	 * are no "error" check computations being done
	 */
	if (analysis_flags & (ANALYSIS_GAP|ANALYSIS_ADJ_AIR|ANALYSIS_OVERLAPS|ANALYSIS_EXP_AIR)) {
	    if (verbose)
		bu_log("Volume/Weight tolerance met.  Cannot terminate calculation due to error computations\n");
	} else {
	    struct region *regp;
	    int all_hit = 1;
	    unsigned long hits;

	    if (require_num_hits > 0) {
		/* check to make sure every region was hit at least once */
		for( BU_LIST_FOR( regp, region, &(state->rtip->HeadRegion) ) )  {
		    RT_CK_REGION(regp);

		    hits = ((struct per_region_data *)regp->reg_udata)->hits;
		    if ( hits < require_num_hits) {
			all_hit = 0;
			if (verbose) {
			    if (hits == 0) {
				bu_log("%s was not hit\n", regp->reg_name);
			    } else {
				bu_log("%s hit only %u times (< %u)\n",
				       regp->reg_name, hits, require_num_hits);
			    }
			}
		    }
		}

		if (all_hit && wv_status == 0) {
		    if (verbose)
			bu_log("%s: Volume/Weight tolerance met. Terminate\n", BU_FLSTR);
		    return 0; /* terminate */
		}
	    } else {
		if (wv_status == 0) {
		    if (verbose)
			bu_log("%s: Volume/Weight tolerance met. Terminate\n", BU_FLSTR);
		    return 0; /* terminate */
		}
	    }
	}
    }
    return 1;
}


/*
 *	summary_reports
 *
 */
void
summary_reports(struct cstate *state, int start, int ac, char *av[])
{
    int view;
    int obj;
    double avg;
    struct region *regp;

    if (multiple_analyses)
	bu_log("Summaries:\n");
    else
	bu_log("Summary:\n");

    if (analysis_flags & ANALYSIS_WEIGHT) {
	bu_log("Weight:\n");
	for (obj=0 ; obj < num_objects ; obj++) {
	    avg = 0.0;

	    for (view=0 ; view < num_views ; view++) {
		/* computed in terminate_check() */
		avg += obj_tbl[obj].o_weight[view];
	    }
	    avg /= num_views;
	    bu_log("\t%*s %g %s\n", -max_region_name_len, obj_tbl[obj].o_name,
		   avg / units[WGT]->val, units[WGT]->name);
	}


	if (print_per_region_stats) {
	    double *wv;
	    bu_log("\tregions:\n");
	    for( BU_LIST_FOR( regp, region, &(state->rtip->HeadRegion) ))  {
		double low = HUGE;
		double hi = -HUGE;

		avg = 0.0;

		for (view=0 ; view < num_views ; view++) {
		    wv = &((struct per_region_data *)regp->reg_udata)->r_weight[view];

		    *wv = ((struct per_region_data *)regp->reg_udata)->r_lenDensity[view] *
			(state->area[view]/state->shots[view]);

		    *wv /= units[WGT]->val;

		    avg += *wv;

		    if (*wv < low) low = *wv;
		    if (*wv > hi) hi = *wv;
		}

		avg /= num_views;
		bu_log("\t%s %g %s +(%g) -(%g)\n",
		       regp->reg_name,
		       avg,
		       units[WGT]->name,
		       hi - avg,
		       avg - low);
	    }
	}


	/* print grand totals */
	avg = 0.0;
	for (view=0 ; view < num_views ; view++) {
	    avg += state->m_weight[view] =
		state->m_lenDensity[view] *
		( state->area[view] / state->shots[view]);
	}

	avg /= num_views;
	bu_log("  Average total weight: %g %s\n", avg / units[WGT]->val, units[WGT]->name);
    }


    if (analysis_flags & ANALYSIS_VOLUME) {
	bu_log("Volume:\n");

	/* print per-object */
	for (obj=0 ; obj < num_objects ; obj++) {
	    avg = 0.0;

	    for (view=0 ; view < num_views ; view++)
		avg += obj_tbl[obj].o_volume[view];

	    avg /= num_views;
	    bu_log("\t%*s %g %s\n", -max_region_name_len, obj_tbl[obj].o_name,
		   avg / units[VOL]->val, units[VOL]->name);
	}

	if (print_per_region_stats) {
	    double *vv;

	    bu_log("\tregions:\n");
	    for( BU_LIST_FOR( regp, region, &(state->rtip->HeadRegion) ))  {
		double low = HUGE;
		double hi = -HUGE;
		avg = 0.0;

		for (view=0 ; view < num_views ; view++) {
		    vv = &((struct per_region_data *)regp->reg_udata)->r_volume[view];

		    /* convert view length to a volume */
		    *vv = ((struct per_region_data *)regp->reg_udata)->r_len[view] *
			(state->area[view] / state->shots[view]);

		    /* convert to user's units */
		    *vv /= units[VOL]->val;

		    /* find limits of values */
		    if (*vv < low) low = *vv;
		    if (*vv > hi) hi = *vv;

		    avg += *vv;
		}

		avg /= num_views;

		bu_log("\t%s volume:%g %s +(%g) -(%g)\n",
		       regp->reg_name,
		       avg,
		       units[VOL]->name,
		       hi - avg,
		       avg - low);
	    }
	}


	/* print grand totals */
	avg = 0.0;
	for (view=0 ; view < num_views ; view++) {
	    avg += state->m_volume[view] =
		state->m_len[view] * ( state->area[view] / state->shots[view]);
	}

	avg /= num_views;
	bu_log("  Average total volume: %g %s\n", avg / units[VOL]->val, units[VOL]->name);
    }
    if (analysis_flags & ANALYSIS_OVERLAPS) list_report(&overlapList);
    if (analysis_flags & ANALYSIS_ADJ_AIR)  list_report(&adjAirList);
    if (analysis_flags & ANALYSIS_GAP) list_report(&gapList);
    if (analysis_flags & ANALYSIS_EXP_AIR) list_report(&exposedAirList);

    for( BU_LIST_FOR( regp, region, &(state->rtip->HeadRegion) ) )  {
	unsigned long hits;

	RT_CK_REGION(regp);
	hits = ((struct per_region_data *)regp->reg_udata)->hits;
	if ( hits < require_num_hits) {
	    if (hits == 0) {
		bu_log("%s was not hit\n", regp->reg_name);
	    } else {
		bu_log("%s hit only %u times (< %u)\n",
		       regp->reg_name, hits, require_num_hits);
	    }

	    return;
	}
    }
}

/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int
main(int ac, char *av[])
{
    int arg_count;
    struct rt_i *rtip;
#define IDBUFSIZE 2048
    char idbuf[IDBUFSIZE];
    int i;
    struct cstate state;
    int start_objs; /* index in command line args where geom object list starts */

    bu_setprogname(av[0]);

    max_cpus = ncpu = bu_avail_cpus();

    /* parse command line arguments */
    arg_count = parse_args(ac, av);

    if ((ac-arg_count) < 2) {
	usage("Error: Must specify model and objects on command line\n");
    }

    bu_semaphore_init(TOTAL_SEMAPHORES);

    rt_init_resource( &rt_uniresource, max_cpus, NULL );
    bn_rand_init( rt_uniresource.re_randptr, 0 );

    /*
     *  Load database.
     *  rt_dirbuild() returns an "instance" pointer which describes
     *  the database to be ray traced.  It also gives back the
     *  title string in the header (ID) record.
     */
    if( (rtip=rt_dirbuild(av[arg_count], idbuf, IDBUFSIZE)) == RTI_NULL ) {
	fprintf(stderr,"g_qa: rt_dirbuild failure on %s\n", av[arg_count]);
	bu_exit(2, NULL);
    }
    rtip->useair = use_air;

    start_objs = ++arg_count;
    num_objects = ac - arg_count;


    /* Walk trees.
     * Here we identify any object trees in the database that the user
     * wants included in the ray trace.
     */
    for ( ; arg_count < ac ; arg_count++ )  {
	if( rt_gettree(rtip, av[arg_count]) < 0 )
	    fprintf(stderr,"rt_gettree(%s) FAILED\n", av[arg_count]);
    }

    /*
     *  Initialize all the per-CPU memory resources.
     *  The number of processors can change at runtime, init them all.
     */
    for( i=0; i < max_cpus; i++ )  {
	rt_init_resource( &resource[i], i, rtip );
	bn_rand_init( resource[i].re_randptr, i );
    }

    /*
     * This gets the database ready for ray tracing.
     * (it precomputes some values, sets up space partitioning, etc.)
     */
    rt_prep_parallel(rtip,ncpu);

    /* we now have to subdivide space
     *
     */
    VSUB2(state.span, rtip->mdl_max, rtip->mdl_min);
    state.area[0] = state.span[1] * state.span[2];
    state.area[1] = state.span[2] * state.span[0];
    state.area[2] = state.span[0] * state.span[1];

    if (analysis_flags & ANALYSIS_BOX) {
	bu_log("bounding box: %g %g %g  %g %g %g\n",
	       V3ARGS(rtip->mdl_min), V3ARGS(rtip->mdl_max));

	VPRINT("Area:", state.area);
    }
    if (verbose) bu_log("ncpu: %d\n", ncpu);

    /* if the user did not specify the initial grid spacing limit, we need
     * to compute a reasonable one for them.
     */
    if (gridSpacing == 0.0) {
	double min_span = MAX_FASTF;
	VPRINT("span", state.span);

	V_MIN(min_span, state.span[X]);
	V_MIN(min_span, state.span[Y]);
	V_MIN(min_span, state.span[Z]);

	gridSpacing = gridSpacingLimit;
	do {
	    gridSpacing *= 2.0;
	} while (gridSpacing < min_span);
	gridSpacing *= 0.25;
	if (gridSpacing < gridSpacingLimit) gridSpacing = gridSpacingLimit;
	bu_log("initial spacing %g\n", gridSpacing);

    }

    if (options_prep(rtip, state.span)) return -1;


    /* initialize some stuff */
    state.rtip = rtip;
    state.first = 1;
    allocate_per_region_data(&state, start_objs, ac, av);

    /* compute */
    do {
	double inv_spacing = 1.0/gridSpacing;
	int view;

	VSCALE(state.steps, state.span, inv_spacing);

	bu_log("grid spacing %g %s %d x %d x %d\n",
	       gridSpacing / units[LINE]->val,
	       units[LINE]->name,
	       state.steps[0]-1,
	       state.steps[1]-1,
	       state.steps[2]-1);


	for (view=0 ; view < num_views ; view++) {

	    if (verbose)
		bu_log("  view %d\n", view);

	    /* gross hack
	     * By assuming we have <= 3 views, we can let the view # indicate
	     * a coordinate axis.
	     *  Note this is used as an index into state.area[]
	     */
	    state.i_axis = state.curr_view = view;
	    state.u_axis = (state.curr_view+1) % 3;
	    state.v_axis = (state.curr_view+2) % 3;

	    state.u_dir[state.u_axis] = 1;
	    state.u_dir[state.v_axis] = 0;
	    state.u_dir[state.i_axis] = 0;

	    state.v_dir[state.u_axis] = 0;
	    state.v_dir[state.v_axis] = 1;
	    state.v_dir[state.i_axis] = 0;
	    state.v = 1;

	    bu_parallel(plane_worker, ncpu, (genptr_t)&state);
	    view_reports(&state);

	}

	state.first = 0;
	gridSpacing *= 0.5;

    } while (terminate_check(&state));

    if (plot_overlaps) fclose(plot_overlaps);
    if (plot_weight) fclose(plot_weight);
    if (plot_volume) fclose(plot_volume);
    if (plot_adjair) fclose(plot_adjair);
    if (plot_gaps) fclose(plot_gaps);
    if (plot_expair) fclose(plot_expair);


    if (verbose)
	bu_log("Computation Done\n");
    summary_reports(&state, start_objs, ac, av);

    return(0);
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.47
log
@put the usage string into the usage func, don't need a progname var when there's a bu_getprogname()
@
text
@d885 2
a886 1
	struct region *reg2)
@


1.46
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@a60 6
/* variables set by command line flags */
char *progname = "(noname)";
const char *usage_msg = "Usage: %s [options] model object [object...]\n\
";


d437 1
a437 2
usage(s)
     char *s;
d439 3
a441 1
    if (s) (void)fputs(s, stderr);
d443 1
a443 1
    (void) fprintf(stderr, usage_msg, progname);
a459 5
    if (  ! (progname=strrchr(*av, '/'))  )
	progname = *av;
    else
	++progname;

d2038 2
@


1.45
log
@pass bu_exit a NULL instead of an empty string
@
text
@d63 1
a63 1
char *usage_msg = "Usage: %s [options] model object [object...]\n\
@


1.44
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d450 1
a450 1
    bu_exit(1, "");
d636 1
a636 1
		bu_exit(EXIT_FAILURE, "");	/* left blank due to use of perror() */
d2070 1
a2070 1
	bu_exit(2, "");
@


1.43
log
@exit->bu_exit where applicable
@
text
@d624 2
a625 4
	    if (read_units_double(&volume_tolerance, bu_optarg, units_tab[1])) {
		bu_log("error in volume tolerance \"%s\"\n", bu_optarg);
		bu_exit(-1, "");
	    }
d628 2
a629 4
	    if (read_units_double(&weight_tolerance, bu_optarg, units_tab[2])) {
		bu_log("error in weight tolerance \"%s\"\n", bu_optarg);
		bu_exit(-1, "");
	    }
@


1.42
log
@print using bu_exit instead of bu_log
@
text
@d450 1
a450 1
    exit(1);
d626 1
a626 1
		exit(-1);
d632 1
a632 1
		exit(-1);
d2074 1
a2074 1
	exit(2);
@


1.41
log
@print using bu_exit instead of bu_log
@
text
@d571 2
a572 4
		    if (read_units_double(&value2, p, units_tab[0])) {
			bu_log("error parsing grid spacing limit value \"%s\"\n", p);
			bu_exit(EXIT_FAILURE, "");
		    }
d640 1
a640 1
		bu_exit(EXIT_FAILURE, "");
d1091 1
a1091 1
		bu_exit(EXIT_FAILURE, "density index %d on region %s is outside of range of table [1..%d]\nSet GIFTmater on region or add entry to density table\n"
d1126 1
a1126 1
		    bu_exit(EXIT_FAILURE, "density index %d from region %s is not set.\nAdd entry to density table\n"
@


1.40
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d534 1
a534 2
			bu_log("Unknown analysis type \"%c\" requested.\n", *p);
			bu_exit(EXIT_FAILURE, "");
d542 2
a543 4
	    if (sscanf(bu_optarg, "%lg", &azimuth_deg) != 1) {
		bu_log("error parsing azimuth \"%s\"\n", bu_optarg);
		bu_exit(EXIT_FAILURE, "");
	    }
d547 2
a548 4
	    if (sscanf(bu_optarg, "%lg", &elevation_deg) != 1) {
		bu_log("error parsing elevation \"%s\"\n", bu_optarg);
		bu_exit(EXIT_FAILURE, "");
	    }
d567 2
a568 4
		if (read_units_double(&value1, bu_optarg, units_tab[0])) {
		    bu_log("error parsing grid spacing value \"%s\"\n", bu_optarg);
		    bu_exit(EXIT_FAILURE, "");
		}
d590 1
a590 2
	    bu_log("-G option unimplemented\n");
	    bu_exit(EXIT_FAILURE, "");
d593 2
a594 4
	    if (sscanf(bu_optarg, "%d", &c) != 1 || c < 0) {
		bu_log("num_hits must be integer value >= 0, not \"%s\"\n", bu_optarg);
		bu_exit(EXIT_FAILURE, "");
	    }
d619 2
a620 4
	    if (read_units_double(&overlap_tolerance, bu_optarg, units_tab[0])) {
		bu_log("error in overlap tolerance distance \"%s\"\n", bu_optarg);
		bu_exit(EXIT_FAILURE, "");
	    }
d662 1
a662 2
			bu_log("Units \"%s\" not found in coversion table\n", units_name[i]);
			bu_exit(EXIT_FAILURE, "");
d714 2
a715 4
	if (idx < 0) {
	    bu_log("bad density index (< 0) %d\n", idx);
	    bu_exit(EXIT_FAILURE, "");
	}
d718 1
a718 1
	if (q == p) {
a719 1
	}
d721 2
a722 4
	if (density < 0.0) {
	    bu_log("bad density (< 0) %g\n", density);
	    bu_exit(EXIT_FAILURE, "");
	}
d726 1
a726 1
	if ((q = strchr(p, '\n'))) {
d728 1
a728 1
	} else {
a729 1
	}
d748 2
a749 2
    for (idx=0 ; idx < num_densities ; idx++) {
	if (densities[idx].magic == DENSITY_MAGIC) {
a754 2
	}
    }
d813 1
a813 1
    if ((intern.idb_major_type & DB5_MAJORTYPE_BINARY_MASK) == 0) {
a814 2
    }

d919 1
a919 1
    if( depth < overlap_tolerance ) {
a921 1
    }
d949 1
a949 1
    } else {
a950 1
    }
d1092 2
a1093 2
	    if (pp->pt_regionp->reg_gmater >= num_densities) {
		bu_log("density index %d on region %s is outside of range of table [1..%d]\n",
d1096 2
a1097 4
		       num_densities);
		bu_log("Set GIFTmater on region or add entry to density table\n");
		bu_exit(EXIT_FAILURE, ""); /* XXX this should do something else */
	    } else {
d1127 2
a1128 2
		} else {
		    bu_log("density index %d from region %s is not set.\n",
a1129 3
		    bu_log("Add entry to density table\n");
		    bu_exit(EXIT_FAILURE, "");
		}
d1373 1
a1373 2
    bu_log("%s Didn't find object named \"%s\" in %d entries\n", BU_FLSTR, name, num_objects);
    bu_exit(EXIT_FAILURE, "");
d1519 1
a1519 1
	} else {
d1521 3
a1523 7
	}
	if ( plot_files ) {
	    if ( (plot_volume=fopen(name, "w")) == (FILE *)NULL) {
		bu_log("cannot open plot file %s\n", name);
		bu_exit(EXIT_FAILURE, "");
	    }
	}
d1543 3
a1545 6
	if ( plot_files ) {
	    if ( (plot_gaps=fopen(name, "w")) == (FILE *)NULL) {
		bu_log("cannot open plot file %s\n", name);
		bu_exit(EXIT_FAILURE, "");
	    }
	}
d1548 1
a1548 1
	if (overlap_tolerance != 0.0) {
a1549 1
	}
d1552 2
a1553 4
	    if ((plot_overlaps=fopen(name, "w")) == (FILE *)NULL) {
		bu_log("cannot open plot file %s\n", name);
		bu_exit(EXIT_FAILURE, "");
	    }
d1557 2
a1558 2
    if (print_per_region_stats) {
	if ( (analysis_flags & (ANALYSIS_VOLUME|ANALYSIS_WEIGHT)) == 0) {
a1559 2
	}
    }
d1561 1
a1561 2

    if ( analysis_flags & ANALYSIS_ADJ_AIR) {
d1564 2
a1565 4
	    if ( (plot_adjair=fopen(name, "w")) == (FILE *)NULL) {
		bu_log("cannot open plot file %s\n", name);
		bu_exit(EXIT_FAILURE, "");
	    }
a1566 2
    }

d1568 1
a1568 1
    if ( analysis_flags & ANALYSIS_EXP_AIR) {
d1571 2
a1572 4
	    if ( (plot_expair=fopen(name, "w")) == (FILE *)NULL) {
		bu_log("cannot open plot file %s\n", name);
		bu_exit(EXIT_FAILURE, "");
	    }
a1573 1
    }
d1575 2
a1576 4
    if ( (analysis_flags & (ANALYSIS_ADJ_AIR|ANALYSIS_EXP_AIR)) && ! use_air ) {
	bu_log("Error:  Air regions discarded but air analysis requested!\n");
	bu_exit(EXIT_FAILURE, "Set use_air non-zero or eliminate air analysis\n");
    }
@


1.39
log
@more quellings of level 4 flawfinder issues
@
text
@d535 1
a535 1
			bu_bomb("");
d545 1
a545 1
		bu_bomb("");
d552 1
a552 1
		bu_bomb("");
d574 1
a574 1
		    bu_bomb("");
d580 1
a580 1
			bu_bomb("");
d598 1
a598 1
	    bu_bomb("");
d603 1
a603 1
		bu_bomb("");
d631 1
a631 1
		bu_bomb("");
d654 1
a654 1
		bu_bomb("");
d675 1
a675 1
			bu_bomb("");
d724 1
a724 1
	    bu_bomb("could not convert idx\n");
d729 1
a729 1
	    bu_bomb("");
d734 1
a734 1
	    bu_bomb("could not convert density\n");
d739 1
a739 1
	    bu_bomb("");
d1123 1
a1123 1
		bu_bomb(""); /* XXX this should do something else */
d1158 1
a1158 1
		    bu_bomb("");
d1404 1
a1404 1
    bu_bomb("");
d1556 1
a1556 1
		bu_bomb("");
d1581 1
a1581 1
		bu_bomb("");
d1593 1
a1593 1
		bu_bomb("");
d1610 1
a1610 1
		bu_bomb("");
d1621 1
a1621 1
		bu_bomb("");
d1628 1
a1628 1
	bu_bomb("Set use_air non-zero or eliminate air analysis\n");
@


1.38
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d407 1
a407 1
    i = sscanf(buf, "%lg%s", &a, units_string);
@


1.37
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a34 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d36 1
@


1.36
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a141 1

a200 1

d221 1
a221 1
	(struct bu_list *)&gapList 
a442 2


a457 1

d569 1
a569 1
		/* find out if we have two or one args 
d590 1
a590 1
		    
a908 1

a1052 1

a1464 2


a1494 4




d1848 2
a1849 2
     * Overlap, gap, adj_air, exp_air, then we ALWAYS go to the 
     * grid spacing limit and we ALWAYS terminate on first 
a2007 1

a2060 1

a2273 1

@


1.35
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


1.34
log
@solaris doesn't have isblank()
@
text
@d4 1
a4 1
 * Copyright (c) 2005-2006 United States Government as represented by
@


1.33
log
@update copyright to 2006
@
text
@a48 1
#include <ctype.h>			/* for isblank */
d752 1
a752 1
	while (isblank(*p)) p++;
@


1.32
log
@quantitative analysis instead of quality assurance
@
text
@d4 1
a4 1
 * Copyright (c) 2005 United States Government as represented by
@


1.31
log
@added standard legalese file header, converted to bu_getopt for portability, increased max title length stored
@
text
@d25 1
a25 1
 * perform quality assurance checks on geometry
@


1.30
log
@irix fix, can only declare variables at the start of a scope block in c89
@
text
@d1 2
a2 1
/*	G _ Q A . C --- perform quality assurance checks on geometry
d4 22
d28 3
a30 3

 plot the points where overlaps start/stop

d37 1
a37 1
#include <string.h>
d39 1
a39 1
#include <strings.h>
a40 1

d64 1
a64 1
/* declarations to support use of getopt() system call */
a65 2
extern char *optarg;
extern int optind, opterr, getopt();
d482 1
a482 1
    opterr = 0;
d485 1
a485 1
    while ((c=getopt(ac,av,options)) != EOF) {
d492 1
a492 1
		for (p = optarg; *p ; p++) {
d554 2
a555 2
	    if (sscanf(optarg, "%lg", &azimuth_deg) != 1) {
		bu_log("error parsing azimuth \"%s\"\n", optarg);
d561 2
a562 2
	    if (sscanf(optarg, "%lg", &elevation_deg) != 1) {
		bu_log("error parsing elevation \"%s\"\n", optarg);
d568 1
a568 1
	case 'f'	: densityFileName = optarg; break;
d579 2
a580 2
		if (p = strchr(optarg, ','))  	 *p++ = '\0';
		else if (p = strchr(optarg, '-')) *p++ = '\0';
d583 2
a584 2
		if (read_units_double(&value1, optarg, units_tab[0])) {
		    bu_log("error parsing grid spacing value \"%s\"\n", optarg);
d612 2
a613 2
	    if (sscanf(optarg, "%d", &c) != 1 || c < 0) {
		bu_log("num_hits must be integer value >= 0, not \"%s\"\n", optarg);
d620 1
a620 1
	    num_views = atoi(optarg);
d627 1
a627 1
	    if ((c=atoi(optarg)) > 0 && c <= max_cpus ) ncpu = c;
d633 2
a634 2
	    if (sscanf(optarg, "%lg", &a) != 1 || a <= 1.0) {
		bu_log("error in specifying minimum samples per model axis: \"%s\"\n", optarg);
d640 2
a641 2
	    if (read_units_double(&overlap_tolerance, optarg, units_tab[0])) {
		bu_log("error in overlap tolerance distance \"%s\"\n", optarg);
d649 2
a650 2
	    if (read_units_double(&volume_tolerance, optarg, units_tab[1])) {
		bu_log("error in volume tolerance \"%s\"\n", optarg);
d655 2
a656 2
	    if (read_units_double(&weight_tolerance, optarg, units_tab[2])) {
		bu_log("error in weight tolerance \"%s\"\n", optarg);
d662 1
a662 1
	    use_air = strtol(optarg, (char **)NULL, 10);
d670 1
a670 1
		char *ptr = optarg;
d709 1
a709 1
    return(optind);
d2122 1
a2122 1
#define IDBUFSIZE 132
@


1.29
log
@Changed handling of -g option.  If user specifies only 1 value, it is now the
LIMIT on how small to let the gridspacing get, not the initial spacing.
@
text
@d552 1
a553 1
		double value1, value2;
@


1.28
log
@Updated termination check so that "vol/weight" tests cannot cause early
termination when "error checks" are being done.  The -n required_hits flag
now only applies to vol/weight calculations.  This fixes a behavioral bug
where analysis could run past the "lower" limit on the grid spacing.
Since interface checking is not implemented, it was removed it from the manpage.
Updated manpage with new syntax for -g option.  This is not implemented, but it
snuck in.  I'll commit the changes to g_qa.c RSN.
@
text
@d553 2
d563 1
a563 1
		if (read_units_double(&gridSpacing, optarg, units_tab[0])) {
d568 2
a569 1
		    if (read_units_double(&gridSpacingLimit, p, units_tab[0])) {
d573 6
d2178 20
@


1.27
log
@ws
@
text
@d60 1
d91 1
a91 1
/*double *grams;*/
d465 1
a465 1
    while ((c=getopt(ac,av,options)) != EOF)
d678 1
a1786 2
	if (verbose)
	    bu_log("Volume/Weight tolerance met. Terminate\n", BU_FLSTR);
d1806 1
a1806 2
    struct region *regp;
    unsigned long hits;
a1817 15
    if (require_num_hits > 0) {
	/* check to make sure every region was hit at least once */
	for( BU_LIST_FOR( regp, region, &(state->rtip->HeadRegion) ) )  {
	    RT_CK_REGION(regp);

	    hits = ((struct per_region_data *)regp->reg_udata)->hits;
	    if ( hits < require_num_hits) {
		if (verbose) {
		    if (hits == 0) {
			bu_log("%s was not hit\n", regp->reg_name);
		    } else {
			bu_log("%s hit only %u times (< %u)\n",
			       regp->reg_name, hits, require_num_hits);
		    }
		}
d1819 4
a1822 4
		return 1;
	    }
	}
    }
a1823 3
    if (analysis_flags & (ANALYSIS_WEIGHT|ANALYSIS_VOLUME))
	if (weight_volume_terminate(state) == 0)
	    return 0; /* terminate */
d1825 7
d1833 5
d1864 46
a1909 6
    /* refine the gridSpacing and try again */
    if (gridSpacing < gridSpacingLimit) {
	if (verbose)
	    bu_log("grid spacing refined to %g (below lower limit %g)\n",
		   gridSpacing, gridSpacingLimit);
	return 0;
a1910 1

@


1.26
log
@The -g command line option can now have its arguments separated by either
a comma or a hyphen now, based upon user request.
@
text
@a1283 2


@


1.25
log
@delimit on comma like the docs state, not on dash -- looks like a negative
@
text
@d553 6
a558 3
		if ((p = strchr(optarg, ','))) {
		    *p++ = '\0';
		}
@


1.24
log
@squash a ton of compiler warnings, fix a bug related to printing "" as the invalid units on -g, still doesn't parse the units/values correctly though
@
text
@d553 1
a553 1
		if ((p = strchr(optarg, '-'))) {
@


1.23
log
@trailing ws
@
text
@a9 1
#include <stdlib.h>
d19 1
d27 2
d35 1
d201 6
a206 4
    { BU_LIST_HEAD_MAGIC,
      (struct bu_list *)&gapList,
      (struct bu_list *)&gapList },
    "Gaps",
d213 6
a218 4
    { BU_LIST_HEAD_MAGIC,
      (struct bu_list *)&adjAirList,
      (struct bu_list *)&adjAirList },
    (char *)"Adjacent Air",
d225 6
a230 4
    { BU_LIST_HEAD_MAGIC,
      (struct bu_list *)&exposedAirList,
      (struct bu_list *)&exposedAirList },
    "Exposed Air",
d237 6
a242 4
    { BU_LIST_HEAD_MAGIC,
      (struct bu_list *)&overlapList,
      (struct bu_list *)&overlapList },
    "Overlaps",
d390 1
a390 1
    char units_string[256];
d406 1
a406 1
	    if (!strcmp(cvt->name, units_string)) {
d412 1
a412 1
	bu_log("Bad units specifier \"%s\" on value \"%s\"\n", units, buf);
d553 1
a553 1
		if (p = strchr(optarg, '-')) {
d557 1
a557 1
		if (read_units_double(&gridSpacing, optarg, &units_tab[0][0])) {
d721 1
a721 1
	if (q = strchr(p, '\n')) {
d811 1
a811 1
    if (intern.idb_major_type&DB5_MAJORTYPE_BINARY_MASK == 0) {
d936 1
d938 1
d1301 1
a1301 1
    while (v = get_next_row(state)) {
d1374 3
a1376 1
    if (p=strchr(str, '/')) *p = '\0';
d1683 5
d1689 1
a1800 3
 *
 *	These return values are potentially confusing when reading the "can_terminate"
 *	variable name
a1806 10
    int obj;
    int view;

    /* Both weight and volume computations rely on this routine to compute values
     * that are printed in summaries.  Hence, both checks must always be done before
     * this routine exits.  So we store the status (can we terminate processing?)
     * in this variable and act on it once both volume and weight computations are done
     */
    int can_terminate;

@


1.22
log
@HUGE is not portably available, provide alternatives (fixes sf bug 1328013)
@
text
@d137 1
a137 1
    unsigned long *shots; 
d193 1
a193 1
/* Access to these lists should be in sections 
d237 1
a237 1
    
d253 1
a253 1
       * Values for converting from given units to mm 
d295 1
a295 1
    {/* volume 
d331 1
a331 1
    { /* weight 
d354 1
a354 1
 * associated conversion values 
d359 1
a359 1
static const struct cvt_tab *units[3] = { 
d558 1
a558 1
		       gridSpacing / units[LINE]->val, units[LINE]->name, 
d584 1
a584 1
	    break;	
d595 1
a595 1
	case 't'	: 
d604 1
a604 1
	case 'V'	: 
d610 1
a610 1
	case 'W'	: 
d617 1
a617 1
	case 'U'	: 
d633 1
a633 1
		
d658 1
a658 1
	default		: 
d707 1
a707 1
	
d717 1
a717 1
	    densities = bu_realloc(densities, sizeof(struct density_entry)*num_densities*2, 
d735 1
a735 1
	    bu_log("%4d %6g %s\n", 
d744 1
a744 1
/*	g e t _ d e n s i t i e s _ f r o m _ f i l e 
d762 1
a762 1
    if (fstat(fileno(fp), &sb)) { 
d775 1
a775 1
/* 
d818 1
a818 1
 *	
d841 1
a841 1
	    
d892 1
a892 1
{	
d925 1
a925 1
	struct region_pair *rp = 
d973 1
a973 1
		    (struct region *)NULL, 
d1025 1
a1025 1
			  pp->pt_regionp->reg_name, 
d1034 1
a1034 1
	    
d1052 1
a1052 1
		 * then we have a void 
d1061 1
a1061 1
				    pp->pt_back->pt_regionp, 
d1098 1
a1098 1
		     * weight computation, factoring in the LOS 
d1171 1
a1171 1
	    if (last_air && pp->pt_regionp->reg_aircode && 
d1246 1
a1246 1
    else 
d1254 1
a1254 1
 *	plane_worker 
d1290 1
a1290 1
	v_coord = v * gridSpacing; 
d1340 2
a1341 2
     * It's time to add the values we have accumulated 
     * to the totals for the view and return.  When all 
d1375 1
a1375 1
/* 
d1410 1
a1410 1
    
d1493 2
a1494 2
    /* refine the grid spacing if the user has set a 
     * lower bound on the number of rays per model axis 
d1498 1
a1498 1
	    /* along this axis, the gridSpacing is 
d1626 1
a1626 1
		val = obj_tbl[obj].o_volume[view] = 
d1630 1
a1630 1
		    bu_log("\t%s volume %g %s\n", 
d1655 1
a1655 1
/*	w e i g h t _ v o l u m e _ t e r m i n a t e 
d1657 2
a1658 2
 * These checks are unique because they must both be completed.  
 * Early termination before they are done is not an option.  
d1678 1
a1678 1
		bu_log("object %d\n", obj); 
d1688 1
a1688 1
		    obj_tbl[obj].o_lenDensity[view] * 
d1710 1
a1710 1
		    bu_log("\t%s differs too much in weight per view.\n", 
d1729 1
a1729 1
	    val = obj_tbl[obj].o_volume[view] = 
d1735 1
a1735 1
		obj_tbl[obj].o_volume[view] = 
d1774 1
a1774 1
 *	Check to see if we are done processing due to 
d1784 1
a1784 1
int 
d1797 1
a1797 1
    int can_terminate; 
d1865 1
a1865 1
	    bu_log("grid spacing refined to %g (below lower limit %g)\n", 
d1871 1
a1871 1
}	
d1890 1
a1890 1
	
d1898 1
a1898 1
		avg += obj_tbl[obj].o_weight[view]; 
d1930 1
a1930 1
		bu_log("\t%s %g %s +(%g) -(%g)\n", 
d1932 1
a1932 1
		       avg, 
d1934 1
a1934 1
		       hi - avg, 
d1943 2
a1944 2
	    avg += state->m_weight[view] = 
		state->m_lenDensity[view] * 
d1999 1
a1999 1
		       avg, 
d2011 1
a2011 1
	    avg += state->m_volume[view] = 
d2062 1
a2062 1
	
d2121 1
a2121 1
	bu_log("bounding box: %g %g %g  %g %g %g\n", 
d2144 2
a2145 2
	bu_log("grid spacing %g %s %d x %d x %d\n", 
	       gridSpacing / units[LINE]->val, 
d2160 1
a2160 1
	     *  Note this is used as an index into state.area[] 
@


1.21
log
@Stop refining grid if overlaps have been found.
@
text
@d58 12
@


1.21.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d10 1
a19 1
#include <stdlib.h>
a26 2
#include <ctype.h>			/* for isblank */

a32 1

a57 12
#ifndef HUGE
#  ifdef MAXFLT
#    define HUGE MAXFLOAT
#  else
#    ifdef DBL_MAX
#      define HUGE DBL_MAX
#    else
#      define HUGE ((float)3.40282346638528860e+38)
#    endif
#  endif
#endif

d125 1
a125 1
    unsigned long *shots;
d181 1
a181 1
/* Access to these lists should be in sections
d186 4
a189 6
    {
	BU_LIST_HEAD_MAGIC,
	(struct bu_list *)&gapList,
	(struct bu_list *)&gapList 
    },
    { "Gaps" },
d196 4
a199 6
    {
	BU_LIST_HEAD_MAGIC,
	(struct bu_list *)&adjAirList,
	(struct bu_list *)&adjAirList
    },
    { (char *)"Adjacent Air" },
d206 4
a209 6
    {
	BU_LIST_HEAD_MAGIC,
	(struct bu_list *)&exposedAirList,
	(struct bu_list *)&exposedAirList
    },
    { "Exposed Air" },
d216 4
a219 6
    {
	BU_LIST_HEAD_MAGIC,
	(struct bu_list *)&overlapList,
	(struct bu_list *)&overlapList
    },
    { "Overlaps" },
d225 1
a225 1

d241 1
a241 1
       * Values for converting from given units to mm
d283 1
a283 1
    {/* volume
d319 1
a319 1
    { /* weight
d342 1
a342 1
 * associated conversion values
d347 1
a347 1
static const struct cvt_tab *units[3] = {
d367 1
a367 1
    char units_string[256] = {0};
d383 1
a383 1
	    if (!strncmp(cvt->name, units_string, 256)) {
d389 1
a389 1
	bu_log("Bad units specifier \"%s\" on value \"%s\"\n", units_string, buf);
d530 3
a532 5
		/* find out if we have two or one args 
		 * user can separate them with , or - delimiter
		 */
		if (p = strchr(optarg, ','))  	 *p++ = '\0';
		else if (p = strchr(optarg, '-')) *p++ = '\0';
d534 1
a534 2

		if (read_units_double(&gridSpacing, optarg, units_tab[0])) {
d546 1
a546 1
		       gridSpacing / units[LINE]->val, units[LINE]->name,
d572 1
a572 1
	    break;
d583 1
a583 1
	case 't'	:
d592 1
a592 1
	case 'V'	:
d598 1
a598 1
	case 'W'	:
d605 1
a605 1
	case 'U'	:
d621 1
a621 1

d646 1
a646 1
	default		:
d695 1
a695 1

d698 1
a698 1
	if ((q = strchr(p, '\n'))) {
d705 1
a705 1
	    densities = bu_realloc(densities, sizeof(struct density_entry)*num_densities*2,
d723 1
a723 1
	    bu_log("%4d %6g %s\n",
d732 1
a732 1
/*	g e t _ d e n s i t i e s _ f r o m _ f i l e
d750 1
a750 1
    if (fstat(fileno(fp), &sb)) {
d763 1
a763 1
/*
d788 1
a788 1
    if ((intern.idb_major_type & DB5_MAJORTYPE_BINARY_MASK) == 0) {
d806 1
a806 1
 *
d829 1
a829 1

d880 1
a880 1
{
d913 1
a913 3
#if 0
	struct region_pair *rp =
#endif
d961 1
a961 1
		    (struct region *)NULL,
d1013 1
a1013 1
			  pp->pt_regionp->reg_name,
d1022 1
a1022 1

d1040 1
a1040 1
		 * then we have a void
d1049 1
a1049 1
				    pp->pt_back->pt_regionp,
d1086 1
a1086 1
		     * weight computation, factoring in the LOS
d1159 1
a1159 1
	    if (last_air && pp->pt_regionp->reg_aircode &&
d1234 1
a1234 1
    else
d1242 1
a1242 1
 *	plane_worker
d1276 1
a1276 1
    while ((v = get_next_row(state))) {
d1278 1
a1278 1
	v_coord = v * gridSpacing;
d1328 2
a1329 2
     * It's time to add the values we have accumulated
     * to the totals for the view and return.  When all
d1349 1
a1349 3
    if ((p=strchr(str, '/'))) {
	*p = '\0';
    }
d1363 1
a1363 1
/*
d1398 1
a1398 1

d1481 2
a1482 2
    /* refine the grid spacing if the user has set a
     * lower bound on the number of rays per model axis
d1486 1
a1486 1
	    /* along this axis, the gridSpacing is
d1614 1
a1614 1
		val = obj_tbl[obj].o_volume[view] =
d1618 1
a1618 1
		    bu_log("\t%s volume %g %s\n",
d1643 1
a1643 1
/*	w e i g h t _ v o l u m e _ t e r m i n a t e
d1645 2
a1646 2
 * These checks are unique because they must both be completed.
 * Early termination before they are done is not an option.
a1655 5
    /* Both weight and volume computations rely on this routine to compute values
     * that are printed in summaries.  Hence, both checks must always be done before
     * this routine exits.  So we store the status (can we terminate processing?)
     * in this variable and act on it once both volume and weight computations are done
     */
a1656 1

d1666 1
a1666 1
		bu_log("object %d\n", obj);
d1676 1
a1676 1
		    obj_tbl[obj].o_lenDensity[view] *
d1698 1
a1698 1
		    bu_log("\t%s differs too much in weight per view.\n",
d1717 1
a1717 1
	    val = obj_tbl[obj].o_volume[view] =
d1723 1
a1723 1
		obj_tbl[obj].o_volume[view] =
d1762 1
a1762 1
 *	Check to see if we are done processing due to
d1768 3
d1772 1
a1772 1
int
d1777 10
d1853 1
a1853 1
	    bu_log("grid spacing refined to %g (below lower limit %g)\n",
d1859 1
a1859 1
}
d1878 1
a1878 1

d1886 1
a1886 1
		avg += obj_tbl[obj].o_weight[view];
d1918 1
a1918 1
		bu_log("\t%s %g %s +(%g) -(%g)\n",
d1920 1
a1920 1
		       avg,
d1922 1
a1922 1
		       hi - avg,
d1931 2
a1932 2
	    avg += state->m_weight[view] =
		state->m_lenDensity[view] *
d1987 1
a1987 1
		       avg,
d1999 1
a1999 1
	    avg += state->m_volume[view] =
d2050 1
a2050 1

d2109 1
a2109 1
	bu_log("bounding box: %g %g %g  %g %g %g\n",
d2132 2
a2133 2
	bu_log("grid spacing %g %s %d x %d x %d\n",
	       gridSpacing / units[LINE]->val,
d2148 1
a2148 1
	     *  Note this is used as an index into state.area[]
@


1.20
log
@Fixes for overlap-only calculations.  Improvements to the man page.
@
text
@d1643 1
a1643 3

/*
 *	t e r m i n a t e _ c h e c k
d1645 3
a1647 2
 *	Check to see if we are done processing due to 
 *	some user specified limit being achieved.
d1649 3
a1651 6
 *	Returns:
 *	0	Terminate
 *	1	Continue processing
 *
 *	These return values are potentially confusing when reading the "can_terminate"
 *	variable name
d1653 2
a1654 2
int 
terminate_check(struct cstate *state)
d1656 1
a1657 46
    struct region *regp;
    unsigned long hits;
    int obj;
    int view;

    /* Both weight and volume computations rely on this routine to compute values
     * that are printed in summaries.  Hence, both checks must always be done before
     * this routine exits.  So we store the status (can we terminate processing?)
     * in this variable and act on it once both volume and weight computations are done
     */
    int can_terminate; 


    DLOG("terminate_check\n");
    RT_CK_RTI(state->rtip);

    if (plot_overlaps) fflush(plot_overlaps);
    if (plot_weight) fflush(plot_weight);
    if (plot_volume) fflush(plot_volume);
    if (plot_adjair) fflush(plot_adjair);
    if (plot_gaps) fflush(plot_gaps);
    if (plot_expair) fflush(plot_expair);

    /* check to make sure every region was hit at least once */
    for( BU_LIST_FOR( regp, region, &(state->rtip->HeadRegion) ) )  {
	RT_CK_REGION(regp);

	hits = ((struct per_region_data *)regp->reg_udata)->hits;
	if ( hits < require_num_hits) {
	    if (verbose) {
		if (hits == 0) {
		    bu_log("%s was not hit\n", regp->reg_name);
		} else {
		    bu_log("%s hit only %u times (< %u)\n",
			   regp->reg_name, hits, require_num_hits);
		}
	    }

	    return 1;
	}
    }

    if (analysis_flags & (ANALYSIS_WEIGHT|ANALYSIS_VOLUME))
	can_terminate = 1;
    else
	can_terminate = 0; /* weight/volume limits don't apply */
d1661 1
d1664 1
a1667 1
	    view = 0;
d1687 5
a1691 5
		   obj_tbl[obj].o_name,
		   val / units[WGT]->val,
		   units[WGT]->name,
		   fabs(hi / units[WGT]->val),
		   fabs(low / units[WGT]->val));
d1695 1
d1699 1
a1699 1
		       obj_tbl[obj].o_name);
d1707 1
d1710 1
d1716 1
a1716 1
	    view = 0;
d1734 4
a1737 4
		   obj_tbl[obj].o_name,
		   val / units[VOL]->val, units[VOL]->name,
		   hi / units[VOL]->val,
		   fabs(low / units[VOL]->val));
a1747 1

d1752 1
a1752 1
	    bu_log("%s terminate\n", BU_FLSTR);
d1755 68
d1825 1
a1825 1
	if (BU_LIST_NON_EMPTY(&overlapList.l) && gridSpacing < gridSpacingLimit*4) {
d1828 2
@


1.19
log
@separate sections for strsep and strtok are no longer necessary since strsep is provided via libsysv now
@
text
@d545 3
a547 1
		bu_log("grid spacing:%gmm limit:%gmm\n", gridSpacing, gridSpacingLimit);
d1671 1
a1671 1
    int can_terminate = 1; /* assume everyone is within tolerance */
d1703 5
d1798 1
a1798 1
	    bu_log("terminate\n");
@


1.18
log
@updates based upon code review
@
text
@a617 1
#ifdef HAVE_STRSEP
a618 3
#else
		    units_name[i] = strtok(&ptr, ",");
#endif
@


1.17
log
@how about just using strtok() instead like we do elsewhere when strsep() isn't available
@
text
@d20 1
d60 1
a60 1
int multiple_analysis = 1;
d98 1
a98 1
#define dlog if (debug) bu_log
d171 4
a174 1
    struct region 	*r1;
d189 1
a189 1
    (struct region *)"Gaps",
d199 1
a199 1
    (struct region *)"Adjacent Air",
d209 1
a209 1
    (struct region *)"Exposed Air",
d219 1
a219 1
    (struct region *)"Overlaps",
a427 1
    char *strrchr();
d447 1
a447 1
		multiple_analysis = 0;
d454 1
a454 1
			multiple_analysis = 1;
d458 1
a458 1
			    multiple_analysis = 1;
d465 1
a465 1
			    multiple_analysis = 1;
d472 1
a472 1
			    multiple_analysis = 1;
d478 1
a478 1
			    multiple_analysis = 1;
d484 1
a484 1
			    multiple_analysis = 1;
d490 1
a490 1
			    multiple_analysis = 1;
d496 1
a496 1
			    multiple_analysis = 1;
d512 1
d519 1
d522 1
a522 1
	case 'd'	: debug = !debug; break;
d530 1
a530 1
		if (p = strchr(optarg, ',')) {
d536 1
a536 1
		    exit(-1);
d541 1
a541 1
			exit(-1);
d551 1
d556 1
a556 1
		break;
d582 1
a582 1
	    if (read_units_double(&overlap_tolerance, optarg, &units_tab[0][0])) {
d584 1
a584 1
		exit(-1);
d603 6
a608 1
	case 'U'	: use_air = atoi(optarg); 
d824 1
a824 1
	if ( (r1 == rp->r1 && r2 == rp->r2) || (r1 == rp->r2 && r2 == rp->r1) ) {
d842 1
a842 1
    rpair->r1 = r1;
d851 1
a851 1
	if (strcmp(rp->r1->reg_name, r1->reg_name) <= 0 )
d932 2
d979 1
a979 1
 *  rt_shootray() was told to call this on a hit.  He gives up the
d1014 1
a1014 1
	dlog("%s %g->%g\n",
d1071 1
a1071 1
	    dlog("Hit %s doing weight\n", pp->pt_regionp->reg_name);
d1135 1
a1135 1
	    dlog("\t\tvol hit %s oDist:%g objVol:%g %s\n",
d1281 1
a1281 1
	dlog("  v = %d v_coord=%g\n", v, v_coord);
d1293 1
a1293 1
		dlog("%5g %5g %5g -> %g %g %g\n", V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));
d1310 1
a1310 1
		dlog("%5g %5g %5g -> %g %g %g\n", V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));
d1326 1
a1326 1
	dlog("didn't shoot any rays\n");
d1366 1
a1366 1
 * allocate_per_reigon_data
d1372 1
a1372 1
allocate_per_reigon_data(struct cstate *state, int start, int ac, char *av[])
d1429 1
a1429 1
	bu_log("No %s\n", (char *)list->r1);
d1433 1
a1433 1
    bu_log("list %s:\n", (char *)list->r1);
d1437 2
a1438 2
	    bu_log("%s %s count:%lu dist:%g%s (%g %g %g)\n",
	       rp->r1->reg_name, rp->r2->reg_name, rp->count,
d1441 2
a1442 2
	    bu_log("%s count:%lu dist:%g%s (%g %g %g)\n",
	       rp->r1->reg_name, rp->count,
d1472 1
a1472 1
	    dlog("density from file\n");
d1477 1
a1477 1
	    dlog("density from db\n");
d1676 1
a1676 1
    dlog("terminate_check\n");
d1847 1
a1847 1
    if (multiple_analysis)
d2009 1
a2009 3
main(ac,av)
     int ac;
     char *av[];
d2013 2
a2014 1
    char idbuf[132];
d2039 1
a2039 1
    if( (rtip=rt_dirbuild(av[arg_count], idbuf, sizeof(idbuf))) == RTI_NULL ) {
a2044 3
    /* XXX set the default linear units if the user hasn't specified them on the command line */


d2096 1
a2096 1
    allocate_per_reigon_data(&state, start_objs, ac, av);
@


1.16
log
@Modifications to suppress warnings on IRIX.
included own copy of strsep for those occasions (IRIX) where the system doesn't provide
@
text
@a19 72

#ifndef HAVE_STRSEP
/*-
 * Copyright (c) 1990, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


/*
 * Get next token from string *stringp, where tokens are possibly-empty
 * strings separated by characters from delim.
 *
 * Writes NULs into the string at *stringp to end tokens.
 * delim need not remain constant from call to call.
 * On return, *stringp points past the last NUL written (if there might
 * be further tokens), or is NULL (if there are definitely no more tokens).
 *
 * If *stringp is NULL, strsep returns NULL.
 */
char *
strsep(char **stringp,
       const char *delim)
{
        char *s;
        const char *spanp;
        int c, sc;
        char *tok;

        if ((s = *stringp) == NULL)
                return (NULL);
        for (tok = s;;) {
                c = *s++;
                spanp = delim;
                do {
                        if ((sc = *spanp++) == c) {
                                if (c == 0)
                                        s = NULL;
                                else
                                        s[-1] = 0;
                                *stringp = s;
                                return (tok);
                        }
                } while (sc != 0);
        }
        /* NOTREACHED */
}
#endif

d607 1
d609 3
@


1.15
log
@Refined production of plot output into individual files.
Built test cases for each analysis type.
Added -p command line option to suppress (default) or produce plot files.
Banged head against keyboard until units were reported correctly.
Gave up on making floating point values average correctly.
Cleaned up output to always (I think) report the user specified units.
@
text
@d20 72
d434 1
a434 1
    double a, conv;
d497 2
a498 2
    int i, j;
    double a, b;
d595 1
a595 1
		i = j = 0;
d705 4
a708 1
	default		: usage("Bad or help flag '%c' specified\n", c); break;
a724 1
    char name[128];
a1046 3
    register struct hit *hitp;
    register struct soltab *stp;
    struct curvature cur;
a1047 2
    vect_t		inormal;
    vect_t		onormal;
d1143 1
a1143 1
		    /* weight computation, factoring in the LOS 
d1198 1
a1198 1
		int v;
a1310 1
    double z_coord;
d1314 1
d1340 1
a1340 1
	    /* This is either the first time a view has been computed
d1416 2
a1578 1
	    struct density_entry *de;
a1657 1
    state->curr_view;
a1717 1
    int axis;
a1897 1
    double v;
a1957 1
	v = 0.0;
a2025 1
	v = 0.0;
a2068 2
    FILE *inp;
    int status;
a2069 2
    int u_axis, v_axis, i_axis;
    long u, v;
a2070 2
    vect_t origin;
    vect_t dir;
a2071 1
    struct directory *dp;
a2072 2
    double lim, val;
    int crv;
@


1.14
log
@Fixed paralell bug
@
text
@d39 1
a39 1
char *options = "A:a:de:f:g:Gn:N:P:rS:s:t:U:u:vV:W:";
d83 1
d91 4
a94 4
int overlap_color[3] = { 255, 255, 0 };
int gap_color[3] = { 128, 128, 255 };
int adjAir_color[3] = { 255, 0, 0 };
int expAir_color[3] = { 255, 128, 255 };
d112 1
a112 1
    int u_axis; /* these three are in the range 0..2 inclusive and indicate which axis (X,Y,or Z) */
d117 1
a117 1
    int v;	/* this indicates how many "grid_size" steps in the v direction have been taken */
d177 5
a181 1
static struct region_pair gapList = { 
d191 1
a191 1
static struct region_pair adjAirList = { 
d201 1
a201 1
static struct region_pair exposedAirList = { 
d211 1
a211 1
static struct region_pair overlapList = { 
d224 6
d240 3
a242 1
	/*	{0.0,		"none"},*/
d337 3
a349 7

const struct cvt_tab *vol_tab;
const struct cvt_tab *wgt_tab;
const struct cvt_tab *ovl_tab;



d448 3
a450 2
			analysis_flags = ANALYSIS_VOLUME | ANALYSIS_WEIGHT | ANALYSIS_OVERLAPS |\
			    ANALYSIS_ADJ_AIR | ANALYSIS_GAP | ANALYSIS_EXP_AIR;
d558 3
d623 1
a623 1
		bu_log("Units:\n");
d791 2
d795 5
a799 1
add_unique_pair(struct region_pair *list, struct region *r1, struct region *r2, double dist, point_t pt)
d861 4
a864 1
overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
d905 1
d907 2
a908 1
	    pdv_3line(plot_overlaps, ohit, rp->coord);
d924 4
a927 1
logoverlap(struct application *ap, const struct partition *pp, const struct bu_ptbl *regiontable, const struct partition *InputHdp)
d935 23
d976 1
a976 1
    point_t		pt, last_out_point;
d982 2
a983 1
    double	last_out_dist;
d998 1
d1000 4
a1003 1

d1009 3
a1011 1
	if (analysis_flags & ANALYSIS_EXP_AIR && air_first) {
d1013 6
a1018 6
	    if (pp->pt_regionp->reg_aircode) {
		/* this shouldn't be air */

		add_unique_pair(&exposedAirList, pp->pt_regionp, (struct region *)NULL, 
				pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist, 
				last_out_point);
d1030 2
a1031 1
		double gap_dist = pp->pt_inhit->hit_dist - last_out_dist;
d1044 1
a1045 1
			VJOIN1(gapEnd, pt, gap_dist, ap->a_ray.r_dir);
d1097 1
a1097 1
		    bu_log("density index %d from region %s is not set.\nAdd entry to density table\n",
d1099 1
a1108 1

a1118 1

d1147 5
a1151 1
	    if (last_air && pp->pt_regionp->reg_aircode && pp->pt_regionp->reg_aircode != last_air) {
d1154 10
d1180 1
a1180 3
	add_unique_pair(&exposedAirList, pp->pt_regionp, (struct region *)NULL, 
			pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist, 
			last_out_point);
d1275 2
a1276 2
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u * gridSpacing;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v * gridSpacing;
d1292 2
a1293 2
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u * gridSpacing;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v * gridSpacing;
d1499 5
a1503 3
	if ( (plot_volume=fopen(name, "w")) == (FILE *)NULL) {
	    bu_log("cannot open plot file %s\n", name);
	    bu_bomb("");
d1525 5
a1529 3
	if ( (plot_gaps=fopen(name, "w")) == (FILE *)NULL) {
	    bu_log("cannot open plot file %s\n", name);
	    bu_bomb("");
d1536 6
a1541 3
	if ( (plot_overlaps=fopen("overlaps.pl", "w")) == (FILE *)NULL) {
	    bu_log("cannot open plot file\n");
	    bu_bomb("");
d1552 21
d1574 2
a1575 1
	bu_bomb("Error:  Air regions discarded but air analysis requested!\nSet use_air non-zero or eliminate air analysis\n");
d1641 3
a1651 1
    int can_terminate = 1; /* assume everyone is within tolerance */
d1655 8
a1739 1
	can_terminate = 1; /* assume everyone is within tolerance */
d1746 2
a1747 1
	    val = obj_tbl[obj].o_volume[view] = obj_tbl[obj].o_len[view] * (state->area[view] / state->shots[view]);
d1782 2
a1783 2
	    bu_log("refining estimates\n");
	return 0;
d1856 2
d1859 21
a1879 1
		bu_log("%s lenDensity:%g  weight:%g\n",
d1881 4
a1884 2
		       ((struct per_region_data *)regp->reg_udata)->r_lenDensity,
		       ((struct per_region_data *)regp->reg_udata)->r_weight);
d1905 1
d1920 3
d1924 24
a1947 1
		bu_log("%s len:%g  vol:%g\n",
d1949 4
a1952 2
		       ((struct per_region_data *)regp->reg_udata)->r_len,
		       ((struct per_region_data *)regp->reg_udata)->r_volume);
d1962 2
a1963 1
	    avg += state->m_volume[view] = state->m_len[view] * ( state->area[view] / state->shots[view]);
d2040 1
a2040 1
	fprintf(stderr,"rtexample: rt_dirbuild failure\n");
d2085 2
a2086 1
	bu_log("bounding box: %g %g %g  %g %g %g\n", V3ARGS(rtip->mdl_min), V3ARGS(rtip->mdl_max));
d2108 3
a2110 1
	bu_log("grid spacing %g %s %d x %d x %d\n", gridSpacing / units[LINE]->val, units[LINE]->name,
@


1.13
log
@Changes from the plane ride back to Baltimore from SIGGraph
@
text
@d33 4
a36 2
#define SEM_LIST RT_SEM_LAST+1

d83 7
a89 1
FILE *plot_fp;
d98 9
d114 2
d117 2
d123 3
a125 1
    unsigned long *shots;
d132 1
a132 1
    int first;		/* this is the first time we've computed a set of views */
d584 2
a585 1
	case 'U'	: use_air = atoi(optarg); break;
d751 1
a751 1
	bu_log("No density table object in database\n");
a772 1

d775 3
d837 3
d868 5
a872 3
    if (plot_fp) {
	pl_color(plot_fp, V3ARGS(overlap_color));
	pdv_3line(plot_fp, ihit, ohit);
d879 7
a885 5
	if (plot_fp) {
	    pl_color(plot_fp, V3ARGS(overlap_color));
	    pdv_3line(plot_fp, ihit, ohit);
	    pdv_3line(plot_fp, ihit, rp->coord);
	    pdv_3line(plot_fp, ohit, rp->coord);
d914 3
d934 5
a938 1
    struct cstate *state = ap->a_uptr;
d949 5
a953 1
	/* checking for air sticking out of the model */
d955 1
d958 4
a961 2
		bu_log("air %s before solid material on ray at %g %g %g\n",
		       pp->pt_regionp->reg_name, V3ARGS(pt) );
d984 1
a984 1
		    if (plot_fp) {
a986 1
			pl_color(plot_fp, V3ARGS(gap_color));
d988 4
a991 1
			pdv_3line(plot_fp, pt, gapEnd);
a1014 1

d1027 1
a1027 1
		    ap->a_color[0] += val;
d1031 1
d1036 1
d1049 7
a1055 1
	    ap->a_color[1] += dist; /* add to total volume */
d1057 2
a1058 2
	    /* add to region volume */
	    prd->r_len[state->curr_view] += dist;
d1060 3
a1062 2
	    /* add to object volume */
	    prd->optr->o_len[state->curr_view] += dist;
d1065 20
a1084 3
		 pp->pt_regionp->reg_name,
		 dist,
		 prd->optr->o_len[state->curr_view], prd->optr->o_name);
d1106 6
a1111 3
	bu_log("Air %s was last on ray at %g %g %g)\n",
	       PartHeadp->pt_back->pt_regionp->reg_name,
	       V3ARGS(last_out_point));
d1124 3
d1140 3
d1163 3
d1184 2
a1185 2
    ap.a_color[0] = 0.0; /* really the cumulative length*density */
    ap.a_color[1] = 0.0; /* really the cumulative length*density */
d1191 1
a1191 1
    ap.a_uptr = ptr; /* really copying the state ptr to the a_uptr */
d1200 4
a1203 4
	if ( state->first || (v&1) ) {
	    /* shoot all the rays in this row */
	    /* this is either the first time a view has been computed
	     * or it is an even numbered row in a grid refinement
d1211 1
d1213 2
d1216 1
d1228 1
d1230 2
d1233 1
d1252 4
a1255 4
    bu_semaphore_acquire(SEM_WORK);
    state->m_lenDensity[state->curr_view] += ap.a_color[0]; /* add our length*density value */
    state->m_len[state->curr_view] += ap.a_color[1]; /* add our volume value */
    bu_semaphore_release(SEM_WORK);
d1350 1
a1350 1
    for (BU_LIST_FOR(rp, region_pair, &overlapList.l)) {
d1352 1
a1352 1
	    bu_log("%s %s %lu %g (%g %g %g)\n",
d1354 1
a1354 1
	       rp->max_dist, V3ARGS(rp->coord));
d1356 1
a1356 1
	    bu_log("%s %lu %g (%g %g %g)\n",
d1358 1
a1358 1
	       rp->max_dist, V3ARGS(rp->coord));
d1422 1
d1425 2
a1426 1
	    bu_log("setting volume tolerance to %g %s\n", volume_tolerance / units[VOL]->val, units[VOL]->name);
d1430 4
d1452 7
d1463 1
a1463 1
	if ( (plot_fp=fopen("overlaps.pl", "w")) == (FILE *)NULL) {
d1468 12
d1557 8
d1658 1
a1658 1
		   low / units[VOL]->val);
d1725 1
a1725 1

d1745 12
d1769 3
d1785 12
d1811 17
d1866 1
a1866 1
    bu_semaphore_init(RT_SEM_LAST+2);
d1927 1
a1927 1
    bu_log("ncpu: %d\n", ncpu);
a1932 4
    if ( (analysis_flags & (ANALYSIS_ADJ_AIR|ANALYSIS_EXP_AIR)) && ! use_air ) {
	bu_bomb("Error:  Air regions discarded but air analysis requested!\nSet use_air non-zero or eliminate air analysis\n");
    }

d1945 1
a1945 1
	bu_log("grid spacing %gmm  %d x %d x %d\n", gridSpacing,
d1984 8
@


1.12
log
@Since the user community didn't ask for the -s option I've deleted it for now.
It can be implemented, but doesn't seem worth the time right now.  Given the
existence of the -g and -n options, I suspect the -s option isn't necessary.
@
text
@d4 1
d37 1
a37 1
char *options = "A:a:de:f:g:Gn:N:P:rS:s:t:U:u:V:W:";
d55 3
a57 1
int analysis_flags = ANALYSIS_VOLUME | ANALYSIS_OVERLAPS | ANALYSIS_WEIGHT | ANALYSIS_EXP_AIR | ANALYSIS_ADJ_AIR | ANALYSIS_GAP ;
d68 1
a68 1
double Samples_per_model_axis = 4.0;
d79 1
d177 1
a177 1
    (struct region *)"Overlaps",
d412 1
d418 1
d421 5
a425 1
			analysis_flags |= ANALYSIS_ADJ_AIR;
d428 3
d432 1
d435 3
d441 3
d447 3
d453 3
d459 3
d464 4
d533 1
a533 1
	    if (sscanf(optarg, "%lg", &a) != 1 || a <= 0.0) {
d537 1
a537 1
	    Samples_per_model_axis = a;
d545 3
d555 1
a555 1
	    if (read_units_double(&volume_tolerance, optarg, units_tab[2])) {
d579 1
a579 1
			bu_log("Did not find units \"%s\" in coversion table\n", units_name[i]);
d823 6
d844 1
a844 1
    {
d854 2
d858 2
a859 3
    

    return(0);	/* No further consideration to this partition */
d950 1
a950 1

d966 5
a970 2
		    /* factor in the density of this object */
		    /* weight computation, factoring in the LOS percentage material of the object */
d998 1
d1002 1
a1002 1
	    ((struct per_region_data *)pp->pt_regionp->reg_udata)->r_len[state->i_axis] += dist;
d1005 1
a1005 1
	    ((struct per_region_data *)pp->pt_regionp->reg_udata)->optr->o_len[state->i_axis] += dist;
d1007 4
a1010 6

	    dlog("\t\thit %g %g %g %g\n",
		   dist,
		   ap->a_color[1],
		   ((struct per_region_data *)pp->pt_regionp->reg_udata)->r_len[state->i_axis],
		   ((struct per_region_data *)pp->pt_regionp->reg_udata)->optr->o_len[state->i_axis]);
d1107 2
d1148 4
d1221 2
a1222 2
    i = 0;
    for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
d1233 1
a1238 35
/*
 *	compute_view_results
 *
 *	Report the results of a particular view computation
 *	for one iteration.
 */
#if 0
void
compute_view_results(struct cstate *state)
{
    struct region *regp;
    double v = state->volume[state->i_axis] * gss;

    if (analysis_flags & ANALYSIS_VOLUME) {
	bu_log("\tvolume  %lg %s on axis %d\n",
	       v / units[VOL]->val, units[VOL]->name, state->i_axis );

	for( BU_LIST_FOR( regp, region, &(state->rtip->HeadRegion) ) )  {
	    bu_log("\t\t%s %g %g %g %g\n", regp->reg_name,
		   state->volume[state->i_axis],
		   ((struct per_region_data *)regp->reg_udata)->len[0],
		   ((struct per_region_data *)regp->reg_udata)->len[1],
		   ((struct per_region_data *)regp->reg_udata)->len[2]);
	}
    }

    if (analysis_flags & ANALYSIS_WEIGHT) {
	grams[state->i_axis] = state->densityLen[state->i_axis]*gridSpacing*gridSpacing;

	bu_log("\tWeight %lg %s\n",
	       grams[state->i_axis] / units[WGT]->val,
	       units[WGT]->name);
    }
}
#endif
d1307 6
a1312 8
    if (Samples_per_model_axis) {
	for (axis=0 ; axis < 3 ; axis++) {
	    if (span[axis] < newGridSpacing*Samples_per_model_axis) {
		/* along this axis, the gridSpacing is 
		 * larger than the model span.  We need to refine.
		 */
		newGridSpacing = span[axis] / Samples_per_model_axis;
	    }
d1314 1
d1316 3
a1318 3
	if (newGridSpacing != gridSpacing) {
	    bu_log("Grid spacing %g %s is does not allow %g samples per axis\n",
		   gridSpacing / units[LINE]->val, units[LINE]->name, Samples_per_model_axis);
d1320 2
a1321 2
	    bu_log("Adjusted to %g %s to get %g samples per model axis\n",
		   newGridSpacing / units[LINE]->val, units[LINE]->name, Samples_per_model_axis);
d1323 1
a1323 2
	    gridSpacing = newGridSpacing;
	}
d1329 1
a1329 1
	    volume_tolerance = span[X] * span[Y] * span[Z] * 0.0001;
d1344 4
a1347 2
	    weight_tolerance = span[X] * span[Y] * span[Z] * 0.00000001 * max_den;
	    bu_log("setting weight tolerance to %g\n", weight_tolerance);
d1384 20
a1403 2
	    val = obj_tbl[obj].o_volume[view] = 
		obj_tbl[obj].o_len[view] * (state->area[view] / state->shots[view]);
d1405 5
a1409 1
	    bu_log("\t%s volume %g %s\n", obj_tbl[obj].o_name,  val / units[VOL]->val, units[VOL]->name);
d1432 3
d1436 1
a1436 2

    bu_log("terminate_check\n");
d1444 8
a1451 4
	    if (hits == 0)	
		bu_log("%s was not hit\n", regp->reg_name);
	    else
		bu_log("%s hit only %u times (< %u)\n", regp->reg_name, hits, require_num_hits);
d1458 43
a1500 15
#if 0
	/* find the range of the mass estimates */
	low = hi = 0.0;
	val = grams[0];
	for (axis=1 ; axis < NUM_VIEWS ; axis++) {
	    delta = val - grams[axis];

	    if (delta < low) low = delta;
	    if (delta > hi) hi = delta;
	}
	delta = hi - low;
	/* compare values to tolerance */
	if (delta < weight_tolerance) {
	    bu_log("weight computations agree within %g g which is within tolerance %g g\n", delta, weight_tolerance);
	    return 0;
a1501 1
#endif
d1505 1
a1505 3
	int can_terminate = 1; /* assume everyone is within tolerance */
	int obj;
	int view;
a1514 1

d1525 8
d1536 3
a1540 9
	    bu_log("%s volume %g %s +%g -%g\n",
		   obj_tbl[obj].o_name,
		   val / units[VOL]->val, units[VOL]->name,
		   hi / units[VOL]->val,
		   low / units[VOL]->val);
	}
	if (can_terminate) {
	    bu_log("all objects within tolerance on volume calculation\n");
	    return 0;
d1542 7
d1577 3
a1579 1
	bu_log("grid spacing refined to %g which is below lower limit %g\n", gridSpacing, gridSpacingLimit);
d1594 36
a1629 1
    bu_log("Summary:\n");
a1630 4
	double avg;
	int obj;
	int view;
	double v;
d1640 1
a1640 1
	    bu_log("%*s %g %s\n", -max_region_name_len, obj_tbl[obj].o_name,
a1657 88
#if 0

void
summary_reports(struct cstate *state, int start, int ac, char *av[])
{
    int i;
    struct region *regp;
   char *p;
#define BSIZE 1024
    char region_name[BSIZE];
    vect_t u;
    int region_number;
    struct rt_i *rtip = state->rtip;

    /* pre-compute some values for units conversion */
    u[LINE] = 1.0/units[LINE]->val;
    u[VOL] = 1.0/units[VOL]->val;
    u[WGT] = 1.0/units[WGT]->val;


    /* Find out what the longest region name is */
    for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
    }


    if (analysis_flags & ANALYSIS_VOLUME) {
	
	bu_log("--- Volume  ---\n");
	/* print per-region */
	if (print_per_region_stats) {
	    bu_log("regions:\n\t%*s  Volume (per view) in %s\n", -max_region_name_len, "Name", units[VOL]->name );
	    for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		double *v =  ((struct per_region_data *)regp->reg_udata)->r_len;

		RT_CK_REGION(regp);

		/* XXX		VSCALE(v, v, gss);	/* convert linear to volume estimate */
		VSCALE(v, v, u[VOL]); /* convert to user units */

		bu_log("%*s %g %g %g", -max_region_name_len, regp->reg_name, V3ARGS(v));
	    }
	}
	/* print per-object */
	for (i=0 ; i < num_objects ; i++) {

	    /*	XXX    VSCALE(obj_tbl[i].volume, obj_tbl[i].volume, gss); */
	    VSCALE(obj_tbl[i].volume, obj_tbl[i].volume, u[VOL]);

	    bu_log("%*s %g %g %g\n", -max_region_name_len, obj_tbl[i].name, V3ARGS(obj_tbl[i].volume));

	}
	/* print grand totals */
	double avg_vol = (state->volume[0] + state->volume[1] + state->volume[2]) / 3.0;
	bu_log("  Average total volume: %g %s\n", avg_vol / units[VOL]->val, units[VOL]->name);
    }


    if (analysis_flags & ANALYSIS_WEIGHT) {
	bu_log("--- Weight ---\n");

	if (print_per_region_stats) {
	    bu_log("regions:\n\t%*s  Weight (per view) %s\n", -max_region_name_len, "Name", units[WGT]->name );

	    for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
		double *w =  ((struct per_region_data *)regp->reg_udata)->lenDensity;
		RT_CK_REGION(regp);

		/* XXX		VSCALE(w, w, gss);	/* convert linear to volume estimate */
		VSCALE(w, w, u[WGT]);	/* compute weight in user units */

		bu_log("%*s %g %g %g", -max_region_name_len, regp->reg_name, V3ARGS(w));
	    }
	}
	/* print per-object data */
	for (i=0 ; i < num_objects ; i++) {
	    /* XXX	    VSCALE(obj_tbl[i].weight, obj_tbl[i].weight, gss); */
	    VSCALE(obj_tbl[i].weight, obj_tbl[i].weight, u[WGT]);

	    bu_log("%*s %g %g %g", -max_region_name_len, regp->reg_name, V3ARGS(obj_tbl[i].weight));
	}

	double avg_densityLen = (state->densityLen[0] + state->densityLen[1] + state->densityLen[2]) / 3.0;
	/* XXX 	double weight = avg_densityLen * gss; */
	bu_log("  Average total weight: %g %s\n", weight / units[WGT]->val);
    }

}
#endif
d1778 4
a1781 1
	bu_log("grid spacing %gmm  %d x %d x %d\n", gridSpacing, V3ARGS(state.steps));
d1786 2
a1787 1
	    bu_log("  view %d\n", view);
d1817 2
a1818 1
    bu_log("Computation Done\n");
@


1.11
log
@Massive changes
@
text
@a65 1
double Samples_per_prim_axis;
a505 8
	case 's'	:
	    if (sscanf(optarg, "%lg", &a) != 1 || a <= 0.0) {
		bu_log("error in specifying minimum samples per primitive axis: \"%s\"\n", optarg);
		break;
	    }
	    Samples_per_prim_axis = a;
	    bu_log("option -s samples_per_axis_min not implemented\n");
	    break;
d1290 8
a1297 6
    for (axis=0 ; axis < 3 ; axis++) {
	if (span[axis] < newGridSpacing*Samples_per_model_axis) {
	    /* along this axis, the gridSpacing is 
	     * larger than the model span.  We need to refine.
	     */
	    newGridSpacing = span[axis] / Samples_per_model_axis;
a1298 1
    }
d1300 3
a1302 3
    if (newGridSpacing != gridSpacing) {
	bu_log("Grid spacing %g %s is does not allow %g samples per axis\n",
	       gridSpacing / units[LINE]->val, units[LINE]->name, Samples_per_model_axis);
d1304 2
a1305 2
	bu_log("Adjusted to %g %s to get %g samples per model axis\n",
	       newGridSpacing / units[LINE]->val, units[LINE]->name, Samples_per_model_axis);
d1307 2
a1308 1
	gridSpacing = newGridSpacing;
@


1.10
log
@region was spelled wrong lee.
@
text
@d32 2
d36 1
a36 1
char *options = "A:a:de:f:g:Gn:P:rS:s:t:U:u:V:W:";
a44 2
#define NUM_VIEWS 3

d51 1
a51 1
#define ANALYSIS_EXT_AIR 32
d54 1
a54 1
int analysis_flags = ANALYSIS_VOLUME | ANALYSIS_OVERLAPS | ANALYSIS_WEIGHT | ANALYSIS_EXT_AIR | ANALYSIS_ADJ_AIR | ANALYSIS_GAP ;
d70 1
a70 1
vect_t grams;
d72 1
a72 1

d74 3
d78 5
a82 1
int max_cpus;
a86 6
static long	noverlaps;		/* Number of overlaps seen */
static long	overlap_count;		/* Number of overlap pairs seen */
static long	unique_overlap_count;	/* Number of unique overlap pairs seen */



d89 1
a89 1
struct state {
d95 5
a99 2
    double densityLen[NUM_VIEWS];	/* per-view values */
    double volume[NUM_VIEWS];	/* per-vew computation of volume */
d103 4
a107 8
/* # of "grid_size" steps to take along each axis (X,Y,Z) 
 * to cover the face of the bounding rpp?
 */
long steps[3]; 


/* How much space does the geometry span in each of X,Y,Z directions */
vect_t span; 
d119 9
d132 6
a137 3
    double	lenDensity[NUM_VIEWS]; /* for per-region per-view weight computation */
    double	len[NUM_VIEWS]; /* for per-region, per-veiew computation */
};
d141 7
a147 12
/*
 *  For each unique pair of regions that we find an overlap for
 *  we build up one of these structures.
 *  Note that we could also discriminate at the solid pair level.
 */
struct overlap_list {
    struct overlap_list *next;	/* next one */
    const char 	*reg1;		/* overlapping region 1 */
    const char	*reg2;		/* overlapping region 2 */
    long	count;			/* number of time reported */
    double max_thickness;
    vect_t coord;
a148 1
static struct overlap_list *olist=NULL;	/* root of the list */
d150 41
d335 1
d413 1
a413 1
			    ANALYSIS_ADJ_AIR | ANALYSIS_GAP | ANALYSIS_EXT_AIR;
d422 1
a422 1
			analysis_flags |= ANALYSIS_EXT_AIR;
d490 3
d611 1
d626 2
a627 1
	    densities = bu_realloc(densities, sizeof(struct density_entry)*num_densities*2, "density entries");
d641 1
a641 1
#if 0
d723 7
d731 39
d788 1
d792 2
a793 2
    vect_t	ihit;
    vect_t	ohit;
d796 6
a801 1
	
a804 3
    depth = ohitp->hit_dist - ihitp->hit_dist;
    if( depth < overlap_tolerance )
	return(0);
d806 4
a809 38
    bu_semaphore_acquire( BU_SEM_SYSCALL );
    //	pdv_3line( outfp, ihit, ohit );
    noverlaps++;
    bu_semaphore_release( BU_SEM_SYSCALL );

    if( !(analysis_flags&ANALYSIS_OVERLAPS) ) {
	bu_log("\nOVERLAP %d: %s\nOVERLAP %d: %s\nOVERLAP %d: depth %gmm\nOVERLAP %d: in_hit_point (%g,%g,%g)mm\nOVERLAP %d: out_hit_point (%g,%g,%g) mm\n------------------------------------------------------------\n",
	       noverlaps,reg1->reg_name,
	       noverlaps,reg2->reg_name,
	       noverlaps,depth,
	       noverlaps,ihit[X],ihit[Y],ihit[Z],
	       noverlaps,ohit[X],ohit[Y],ohit[Z]);

	/* If we report overlaps, don't print if already noted once.
	 * Build up a linked list of known overlapping regions and compare 
	 * againt it.
	 */
    } else {
	struct overlap_list	*prev_ol = (struct overlap_list *)0;
	struct overlap_list	*op;		/* overlap list */
	struct overlap_list     *new_op;
	new_op =(struct overlap_list *)bu_malloc(sizeof(struct overlap_list),"overlap list");

	/* look for it in our list */
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	for( op=olist; op; prev_ol=op, op=op->next ) {

	    /* if we already have an entry for this region pair, 
	     * we increase the counter, check the depth and 
	     * update thickness maximum and entry point if need be
	     * and return 
	     */
	    if( (strcmp(reg1->reg_name,op->reg1) == 0) && (strcmp(reg2->reg_name,op->reg2) == 0) ) {
		op->count++;
		if (depth > op->max_thickness) {
		    op->max_thickness = depth;
		    VMOVE(op->coord, ihit);
		}
d811 3
d815 5
a819 38
		bu_semaphore_release( BU_SEM_SYSCALL );
		bu_free( (char *) new_op, "overlap list");
		return	0;	/* already on list */
	    } 
	}
		
	for( op=olist; op; prev_ol=op, op=op->next ) {
	    /* if this pair was seen in reverse, decrease the unique counter */
	    if ((strcmp(reg1->reg_name, op->reg2) == 0) && (strcmp(reg2->reg_name, op->reg1) == 0)) {
		unique_overlap_count--;
		break;
	    }
	}
		
	/* we have a new overlapping region pair */
	overlap_count++;
	unique_overlap_count++;
		
	op = new_op;
	if( olist )		/* previous entry exists */
	    prev_ol->next = op;
	else
	    olist = op;	/* finally initialize root */
	op->reg1 = reg1->reg_name;
	op->reg2 = reg2->reg_name;
	op->next = NULL;
	op->count = 1;
	op->max_thickness = depth;
	VMOVE(op->coord, ihit);
	bu_semaphore_release( BU_SEM_SYSCALL );
    }

    /* useful debugging */
    if (0) {
	struct overlap_list	*op;		/* overlap list */
	bu_log("PRINTING LIST::reg1==%s, reg2==%s\n", reg1->reg_name, reg2->reg_name);
	for (op=olist; op; op=op->next) {
	    bu_log("\tpair: %s  %s  %d matches\n", op->reg1, op->reg2, op->count);
d822 3
a824 1
	
d864 1
a864 1
    struct state *state = ap->a_uptr;
d876 1
a876 1
	if (analysis_flags & ANALYSIS_EXT_AIR && air_first) {
d892 18
a909 4
		if ((pp->pt_inhit->hit_dist - last_out_dist) > overlap_tolerance) {
		    bu_log("Void found between %s (%g %g %g) and %s (%g %g %g)\n",
			   pp->pt_back->pt_regionp->reg_name, V3ARGS(last_out_point),
			   pp->pt_regionp->reg_name, V3ARGS(pt) );
d926 1
d930 2
d944 1
d946 5
a950 1
		    ((struct per_region_data *)pp->pt_regionp->reg_udata)->lenDensity[state->i_axis] += val;
d962 13
a974 1
	    ((struct per_region_data *)pp->pt_regionp->reg_udata)->len[state->i_axis] += dist; /* add to region volume */
d981 2
a982 4
		bu_log("air contiguous between %s and %s at (%g %g %g)",
		       pp->pt_back->pt_regionp->reg_name,
		       pp->pt_regionp->reg_name, V3ARGS(pt)
		       );
d995 1
a995 1
    if (analysis_flags & ANALYSIS_EXT_AIR && last_air) {
d1021 15
d1037 4
d1052 1
a1052 1
    struct state *state = (struct state *)ptr;
d1065 1
d1069 1
a1069 25
    ap.a_uptr = ptr;

    while (1) {

	/* look for more work */
	bu_semaphore_acquire(SEM_WORK);
	if (state->v >= steps[state->v_axis]) {
	    /* There's nothing else left to work on in this view.
	     * It's time to add the values we have accumulated 
	     * to the totals for the view and return.  When all 
	     * threads have been through here, we'll have returned
	     * to serial computation.
	     */
	    state->densityLen[state->i_axis] += ap.a_color[0]; /* add our length*density value */
	    state->volume[state->i_axis] += ap.a_color[1]; /* add our volume value */
	    bu_semaphore_release(SEM_WORK);

	    return;
	}

	/* get a row to work on */
	v = state->v++;
	bu_semaphore_release(SEM_WORK);

	v_coord = gridSpacing * 0.5 + v * gridSpacing; 
d1071 1
a1071 2
	state->densityLen[state->i_axis] = 0.0;
	state->volume[state->i_axis] = 0.0;
d1073 2
d1076 1
a1076 1
	if (state->densityLen[state->i_axis] == 0.0 || (v&1) == 0) {
d1081 3
a1083 3
	    for (u=0 ; u < steps[state->u_axis]; u++) {
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u * gridSpacing + 0.5 * gridSpacing;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v * gridSpacing + 0.5 * gridSpacing;
d1086 1
a1086 1
		/* bu_log("%g %g %g -> %g %g %g\n", V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));*/
d1088 1
d1094 3
a1096 3
	    for (u=1 ; u < steps[state->u_axis]; u+=2) {
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u * gridSpacing + 0.5 * gridSpacing;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v * gridSpacing + 0.5 * gridSpacing;
d1099 1
a1099 1
		/* bu_log("%g %g %g -> %g %g %g\n", V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));*/
d1101 5
d1109 33
d1147 2
a1148 1
 *	Allocate data structures for tracking statistics on a per-region basis
d1151 1
a1151 1
allocate_per_reigon_data(struct rt_i *rtip)
d1154 1
a1154 1
    struct per_region_data *ptr;
d1156 1
d1158 20
a1177 1
    ptr = bu_calloc(rtip->nregions, sizeof(struct per_region_data), "per_region_data");
d1181 10
a1190 1
	regp->reg_udata = &ptr[i++];
d1197 1
a1197 1
 *	compute_results
d1200 1
a1200 1
 *
d1202 1
d1204 1
a1204 1
compute_results(struct state *state)
d1206 2
a1207 1
    state->volume[state->i_axis] *= gridSpacing*gridSpacing;
a1208 1
    bu_log("\t");
d1210 10
a1219 4
	bu_log(" volume %lg %s",
	       state->volume[state->i_axis] / units[VOL]->val,
	       units[VOL]->name
	       );
d1225 1
a1225 1
	bu_log(" Weight %lg %s",
a1228 1
    bu_log("\n");
d1230 1
a1230 2


d1233 1
a1233 1
 *	report_overlaps
d1237 1
a1237 1
report_overlaps()
d1239 1
a1239 1
    struct overlap_list *op, *prev_ol;
d1241 2
a1242 2
    if (olist == (struct overlap_list *)NULL) {
	bu_log("No overlaps\n");
d1246 12
a1257 4
    bu_log("Overlaps\ttotal encountered:%d  total pairs:%d  unique pairs:%d\n", noverlaps, overlap_count, unique_overlap_count);
    for( op=olist; op; prev_ol=op, op=op->next ) {
	bu_log("%s %s  %d times, max_thickness %gmm at %g %g %g\n", op->reg1, op->reg2, op->count,
	       op->max_thickness, V3ARGS(op->coord));
d1283 11
a1293 9
    if (densityFileName) {
	dlog("density from file\n");
	if (get_densities_from_file(densityFileName)) {
	    return -1;
	}
    } else {
	dlog("density from db\n");
	if (get_densities_from_database(rtip)) {
	    return -1;
a1295 1

d1309 2
a1310 2
	bu_log("Grid spacing %g %s is larger than model bounding box axis\n",
	       gridSpacing / units[LINE]->val, units[LINE]->name);
a1317 1

d1346 4
d1355 1
a1355 1
 *	compute_views
d1358 2
a1359 2
void 
compute_views(struct state *state)
d1361 4
a1364 3
    int axis;
    int num_axes = 3;
    double inv_spacing = 1.0/gridSpacing;
d1366 5
a1370 1
    VSCALE(steps, span, inv_spacing);
d1372 1
a1372 1
    bu_log("grid spacing %gmm  %d x %d x %d\n", gridSpacing, V3ARGS(steps));
d1374 2
a1375 2
    for (axis=0 ; axis < num_axes ; axis++) {
	state->curr_view = axis;
d1377 2
a1378 17
	state->v = 0;
	/* xy, yz, zx */
	state->u_axis = axis;
	state->v_axis = (axis+1) % 3;
	state->i_axis = (axis+2) % 3;


	state->u_dir[state->u_axis] = 1;
	state->u_dir[state->v_axis] = 0;
	state->u_dir[state->i_axis] = 0;

	state->v_dir[state->u_axis] = 0;
	state->v_dir[state->v_axis] = 1;
	state->v_dir[state->i_axis] = 0;

	bu_parallel(plane_worker, ncpu, (genptr_t)state); /* xy plane */
	compute_results(state);
d1382 1
d1394 1
a1394 1
terminate_check(struct state *state)
d1402 1
d1404 1
d1408 6
a1413 1
	hits =((struct per_region_data *)regp->reg_udata)->hits;
a1414 5
	if (hits == 0) {
	    bu_log("%s was not hit\n", regp->reg_name);
	    return 1;
	} else if ( hits < require_num_hits) {
	    bu_log("%s hit only %u times (< %u)\n", regp->reg_name, hits, require_num_hits);
a1418 4

    /* since the weight computation sets a global variable, it must
     * come first before the volume and gridspacing checks.
     */
d1420 1
a1420 4
	/* XXX we rely on the fact that report_results() has been called
	 * to compute the values for the global array grams[]
	 */

d1436 1
d1439 40
a1478 5
	/* find the range of values for volume */
	low = hi = 0.0;
	val = state->volume[0];
	for (axis=1 ; axis < NUM_VIEWS ; axis++) {
	    delta = val - state->volume[axis];
d1480 16
a1495 2
	    if (delta < low) low = delta;
	    if (delta > hi) hi = delta;
d1497 4
a1500 5
	delta = hi - low;

	if (delta < volume_tolerance) {
	    bu_log("volume computations agree within %g mm^3\nwhich is within tolerance %g mm^3\n",
		   delta, volume_tolerance);
a1503 1

a1504 1
    gridSpacing *= 0.5;
a1512 20
/* summary data structure for objects specified on command line */
struct rpt_tab {
    char *name;
    double volume[3];
    double weight[3];
};

int
find_cmd_line_obj(struct rpt_tab *obj_rpt, int tot, char *name)
{
    int i;

    for (i=0 ; i < tot ; i++) {
	if (!strcmp(obj_rpt[i].name, name)) {
	    return i;
	}
    }
    bu_log("%s Didn't find object named \"%s\"\n", BU_FLSTR, name);
    bu_bomb("");
}
d1519 39
a1557 1
summary_reports(struct state *state, int start, int ac, char *av[])
d1559 1
a1559 1
    int i, tot;
a1560 1
    struct rpt_tab  *obj_rpt;
a1563 1
    double gss = gridSpacing * gridSpacing;
a1565 1
    int max_name_len = 0;
a1567 11
    /* build data structures for the list of
     * objects the user specified on the command line
     */
    obj_rpt = bu_calloc(sizeof(struct rpt_tab), ac-start, "report tables");
    start++;
    tot = ac - start;
    for (i=0 ; i < tot ; i++) {
	obj_rpt[i].name = av[start+i];
    } 


d1573 1
a1575 2
	int m = strlen(regp->reg_name);
	if (m > max_name_len) max_name_len = m;
d1581 6
a1586 4
	bu_log("--- Volume  ---\n  regions:\n");
	bu_log("\t%*s  Volume (per view) in %s\n", -max_name_len, "Name", units[VOL]->name );
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
	    double *v =  ((struct per_region_data *)regp->reg_udata)->len;
d1588 1
a1588 1
	    RT_CK_REGION(regp);
d1590 2
a1591 11
	    /* extract the top-level object for the given region from the name
	     * ensure null termination of the copied string
	     */
	    strncpy(region_name, &regp->reg_name[1], sizeof(region_name)-1);
	    region_name[sizeof(region_name)-1] = '\0';
	    if (p = strchr(region_name, '/'))   *p = '\0';
	    region_number = find_cmd_line_obj(obj_rpt, tot, region_name);

	    /* convert linear to volume estimate */
	    VSCALE(v, v, gss);
	    VSCALE(v, v, u[VOL]); /* convert to user units */
d1593 5
a1597 5
	    /* find the top level object for this region, and add the volume to
	     * the accumulated volume for that object
	     */

	    VADD2(obj_rpt[region_number].volume, obj_rpt[region_number].volume, v);
d1599 2
a1600 3
	    if (print_per_region_stats)
		bu_log("\t%*s (%g %g %g)\n", -max_name_len, regp->reg_name, V3ARGS(v));
	}
d1602 1
a1602 7
	/* print the volume summary */
	bu_log("  objects:\n");
	bu_log("\t%*s  Volume (per view) in %s\n", -max_name_len, "Name", units[VOL]->name );
	for (i=0 ; i < tot ; i++) {
	    bu_log("\t%*s %g %g %g\n", -max_name_len,
		   obj_rpt[i].name,
		   V3ARGS(obj_rpt[i].volume));
d1605 2
a1606 2

	double avg_vol = state->volume[0] + state->volume[1] + state->volume[2] / 3.0;
d1609 2
d1612 4
a1615 4
	bu_log("--- Weight ---\n  regions:\n");
	bu_log("\t%*s  Weight (per view) %s\n", -max_name_len, "Name", units[WGT]->name );
	for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
	    double *w = ((struct per_region_data *)regp->reg_udata)->lenDensity;
d1617 3
a1619 1
	    RT_CK_REGION(regp);
d1621 5
a1625 25
	    /* extract the top-level object for the given region from the name
	     * ensure null termination of the copied string
	     */
	    strncpy(region_name, &regp->reg_name[1], sizeof(region_name)-1);
	    region_name[sizeof(region_name)-1] = '\0';
	    if (p = strchr(region_name, '/'))   *p = '\0';
	    region_number = find_cmd_line_obj(obj_rpt, tot, region_name);

	    /* convert linear to volume estimate */
	    VSCALE(w, w, gss);
	    VSCALE(w, w, u[WGT]); /* compute weight in user units */

	    VADD2(obj_rpt[region_number].weight, obj_rpt[region_number].weight, w);

	    if (print_per_region_stats)
		bu_log("\t%*s Weight (%g %g %g)\n", -max_name_len, regp->reg_name, V3ARGS(w));
	}
	/* print the weight summary */
	bu_log("  objects:\n");
	bu_log("\t%*s  Weight (per view) %s\n", -max_name_len, "Name", units[WGT]->name );
	for (i=0 ; i < tot ; i++) {
	    bu_log("\t%*s %g %g %g  %s\n", -max_name_len,
		   obj_rpt[i].name,
		   V3ARGS(obj_rpt[i].weight),
		   units[WGT]->name);
d1627 4
d1632 2
a1633 2
	double avg_densityLen = state->densityLen[0] + state->densityLen[1] + state->densityLen[2] / 3.0;
	double weight = avg_densityLen * gridSpacing * gridSpacing;
d1635 2
a1639 4
    if (analysis_flags & ANALYSIS_OVERLAPS) report_overlaps();
    if (analysis_flags & ANALYSIS_ADJ_AIR) { }
    if (analysis_flags & ANALYSIS_GAP) { }
    if (analysis_flags & ANALYSIS_EXT_AIR) { }
d1641 1
a1641 1

d1665 1
a1665 1
    struct state state;
d1668 1
a1668 1
    int start_objs;
d1699 4
d1707 1
a1707 3
    start_objs = arg_count;

    for ( arg_count++ ; arg_count < ac ; arg_count++ )  {
d1730 5
d1737 2
d1740 1
a1741 1
    VSUB2(span, rtip->mdl_max, rtip->mdl_min);
d1743 1
a1743 6
    if (options_prep(rtip, span)) return -1;

    /* initialize some stuff */
    VSETALL(state.densityLen, 0.0);
    VSETALL(state.volume, 0.0);
    state.rtip = rtip;
d1746 1
a1746 1
    if ( (analysis_flags & (ANALYSIS_ADJ_AIR|ANALYSIS_EXT_AIR)) && ! use_air ) {
d1750 4
a1753 1
    allocate_per_reigon_data(rtip);
d1757 34
d1792 2
a1793 1
	compute_views(&state);
d1797 1
@


1.9
log
@results formatting for volume/weight
@
text
@d447 1
a447 1
	    print_per_reigon_stats = 1;
@


1.8
log
@Many changes, including incorporation of units
@
text
@d34 1
a34 1
char *options = "A:a:de:f:g:Gn:P:r:S:s:t:U:u:V:W:";
d71 1
d100 8
a107 2
long steps[3]; /* # of "grid_size" steps to take along each axis (X,Y,Z) to cover the face of the bounding rpp? */
vect_t span; /* How much space does the geometry span in each of X,Y,Z directions */
d251 3
d446 3
d510 1
a510 1
		    bu_log("\t%s: %s\n", dim[i], units[i]->name);
d512 1
d1072 2
a1073 2
	       state->volume[state->i_axis] / units[1]->val,
	       units[1]->name
d1081 2
a1082 2
	       grams[state->i_axis] / units[2]->val,
	       units[2]->name);
d1158 1
a1158 1
	       gridSpacing / units[0]->val, units[0]->name);
d1161 1
a1161 1
	       newGridSpacing / units[0]->val, units[0]->name, Samples_per_model_axis);
d1171 1
a1171 1
	    bu_log("setting volume tolerance to %g %s\n", volume_tolerance / units[2]->val, units[2]->name);
d1309 2
a1310 1
	    bu_log("volume computations agree within %g mm^3 which is within tolerance %g mm^3\n", delta, volume_tolerance);
d1325 21
d1351 1
a1351 1
summary_reports(struct state *state, int start, int ac, char *av[], struct rt_i *rtip)
d1353 1
a1353 1
    int i;
d1355 9
d1365 15
d1381 1
a1381 3
    /* just some checking on names */
    bu_log("regions:\n");
    RT_CK_RTI(rtip);
d1383 2
a1384 3
	RT_CK_REGION(regp);

	bu_log("\t%s\n", regp->reg_name);
d1389 40
d1430 1
a1430 2
	
	bu_log("average total volume: %g %s\n", avg_vol / units[1]->val, units[1]->name);
d1433 34
d1468 1
a1468 1
	double volume = avg_densityLen * gridSpacing * gridSpacing;
d1470 1
a1470 1
	bu_log("average total weight: %g %s\n", volume * units[2]->val, units[2]->name);
d1472 1
d1592 1
a1592 1
    summary_reports(&state, start_objs, ac, av, rtip);
@


1.7
log
@Checkpoint.
@
text
@d43 2
d54 1
a54 2
int analysis_flags = ANALYSIS_VOLUME | ANALYSIS_OVERLAPS | ANALYSIS_WEIGHT | 
ANALYSIS_EXT_AIR | ANALYSIS_ADJ_AIR | ANALYSIS_GAP ;
d68 4
a71 1
double volume_tolerance;
a72 3
char *units;
double weight_tolerance;

d74 1
a78 11
#if 0
int npsw = 1;
double grid_size = 50.0; /* 50.0mm grid default */
double tol = 0.5;
int rpt_overlap = 1;



double overlap_tol = 0.1;
#endif

d93 4
a96 4
    vect_t lenDensity;
    vect_t volume;
    vect_t u_dir;
    vect_t v_dir;
a101 1

d105 1
a105 1
    double	density;
d112 7
d143 99
a241 8
static const struct cvt_tab units_volume[] = {
    {0.0, "cmm"},
    {0.0, "mm^3"},
    {1.0e3, "cc"},
    {1.0e3, "cm^3"},
    {1.0e9, "cm"},
    {1.0e9, "m^3"},
    {0.0, ""}
d243 5
a247 47
static const struct cvt_tab units_weight[] = {
    {10.0, "g"},
    {1.0, "grams"},
    {1.0e3, "kg"},
    {1.0e3, "lb"},
    {1.0e9, "lbs"},
    {1.0e9, "kg"},
    {0.0, ""}
};
static const struct cvt_tab units_length[] = { /* stolen from bu/units.c */
    {0.0,		"none"},
    {1.0e-7,	"angstrom"},
    {1.0e-7,	"decinanometer"},
    {1.0e-6,	"nm"},
    {1.0e-6,	"nanometer"},
    {1.0e-3,	"um"},
    {1.0e-3,	"micrometer"},
    {1.0e-3,	"micron"},
    {1.0,		"mm"},
    {1.0,		"millimeter"},
    {10.0,		"cm"},
    {10.0,		"centimeter"},
    {1000.0,	"m"},
    {1000.0,	"meter"},
    {1000000.0,	"km"},
    {1000000.0,	"kilometer"},
    {25.4,		"in"},
    {25.4,		"inch"},
    {25.4,		"inche"},		/* for plural */
    {304.8,		"ft"},
    {304.8,		"foot"},
    {304.8,		"feet"},
    {456.2,		"cubit"},
    {914.4,		"yd"},
    {914.4,		"yard"},
    {5029.2,	"rd"},
    {5029.2,	"rod"},
    {1609344.0,	"mi"},
    {1609344.0,	"mile"},
    {1852000.0,	"nmile"},
    {1852000.0,	"nautical mile"},
    {1.495979e+14,	"AU"},
    {1.495979e+14,	"astronomical unit"},
    {9.460730e+18,	"lightyear"},
    {3.085678e+19,	"pc"},
    {3.085678e+19,	"parsec"},
    {0.0,		""}			/* LAST ENTRY */
d249 8
d259 1
d261 5
d268 1
a268 1
read_units_double(double *val, char *buf, const struct cvt_tab tbl[])
d271 1
a271 1
    char units[256];
a272 1
    const struct cvt_tab *cvt;
d274 2
a275 1
    i = sscanf(buf, "%lg%s", &a, units);
d280 1
d285 2
a286 2
	for (cvt = tbl ; cvt->name[0] != '\0' ; cvt++) {
	    if (strcmp(cvt->name, units)) {
d288 2
a291 5
    found_units:
	if (cvt->val != 0.0) {
	    *val = a * cvt->val;
	    return 0;
	} 
d294 4
d299 1
a299 1
    bu_log("%s sscanf problem on \"%s\"\n", BU_FLSTR, buf);
a331 2
#define LEN_UNITS 64
    char unitstr[LEN_UNITS];
d347 32
a378 30
	case 'A'	: {
	    char *p;
	    analysis_flags = 0;
	    for (p = optarg; *p ; p++) {
		switch (*p) {
		case 'A' :
		    analysis_flags = ANALYSIS_VOLUME | ANALYSIS_WEIGHT | ANALYSIS_OVERLAPS |\
			ANALYSIS_ADJ_AIR | ANALYSIS_GAP | ANALYSIS_EXT_AIR;
		    break;
		case 'a' :
		    analysis_flags |= ANALYSIS_ADJ_AIR;
		    break;
		case 'b' :
		    analysis_flags |= ANALYSIS_BOX;
		    break;
		case 'e' :
		    analysis_flags |= ANALYSIS_EXT_AIR;
		    break;
		case 'g' :
		    analysis_flags |= ANALYSIS_GAP;
		    break;
		case 'o' :
		    analysis_flags |= ANALYSIS_OVERLAPS;
		    break;
		case 'v' :
		    analysis_flags |= ANALYSIS_VOLUME;
		    break;
		case 'w' :
		    analysis_flags |= ANALYSIS_WEIGHT;
		    break;
d380 1
a381 2
	    break;
	}
d398 3
a400 2
	case 'g'	: {
	    i = j = 0;
d402 3
a404 5
	    if (p = strchr(optarg, ',')) {
		*p++ = '\0';
	    }

	    bu_log("\"%s\"  \"%s\"\n", optarg, p);
d406 2
a407 7
	    if (read_units_double(&gridSpacing, optarg, units_length)) {
		bu_log("error parsing grid spacing value \"%s\"\n", optarg);
		exit(-1);
	    }
	    if (p) {
		if (read_units_double(&gridSpacingLimit, p, units_length)) {
		    bu_log("error parsing grid spacing limit value \"%s\"\n", p);
d410 9
a419 3

	    bu_log("grid spacing:%gmm limit:%gmm\n", gridSpacing, gridSpacingLimit);
	    break;
d426 1
a426 1
		bu_log("num_hits must be >= 0, not \"%s\"\n", optarg);
d434 1
a434 1
	    if ((c=atoi(optarg)) > 0 && ncpu > c) ncpu = c;
d452 1
a452 1
	    if (read_units_double(&overlap_tolerance, optarg, units_length))
d454 2
a455 2
	    exit(-1);
	}
d458 1
a458 1
	    if (read_units_double(&volume_tolerance, optarg, units_volume)) {
d464 1
a464 1
	    if (read_units_double(&volume_tolerance, optarg, units_weight)) {
d471 31
a501 1
	case 'u'	: units = optarg; break;
d504 1
a504 1
	default		: usage("Bad or help flag specified\n"); break;
d511 147
d666 5
a773 26

/*
 *	multioverlap
 *
 */
void
multioverlap(struct application *ap, struct partition *pp, struct bu_ptbl *regiontable, struct partition *InputHdp)
{
    int n_regions;

    RT_CK_AP(ap);
    RT_CK_PARTITION(pp);
    BU_CK_PTBL(regiontable);
    RT_CK_PT_HD(InputHdp);
    struct region **reg;

    /* just blow em away for now */
    for( BU_PTBL_FOR( reg, (struct region **), regiontable ) )  {
	if (*reg == REGION_NULL) continue;
	
	
	*reg = REGION_NULL;
    }
}


d809 2
a810 1

d849 1
a849 1
	    /* factor in the density of this object */
d858 1
d861 14
a874 1
		    ap->a_color[0] += de->density * dist; /* weight computation */
d885 2
a886 1
	    ap->a_color[1] += dist;
d900 2
a901 2
	((unsigned)pp->pt_regionp->reg_udata)++;

a954 1
    //    ap.a_multioverlap = multioverlap;
d963 2
d966 2
a967 1
	/* get a row to work on */
a968 1
	/* bu_log("stateV: %d  steps %d\n", state->v, steps[state->v_axis]); */
d970 8
a977 2
	    state->lenDensity[state->i_axis] += ap.a_color[0]; /* add our length*density value */
	    state->volume[state->i_axis] += ap.a_color[1]; /* add our length*density value */
d979 1
d982 2
d989 1
a989 1
	state->lenDensity[state->i_axis] = 0.0;
d993 1
a993 1
	if (state->lenDensity[state->i_axis] == 0.0 || (v&1) == 0) {
d995 3
d1007 3
a1009 1
	    /* shoot only the rays we need to on this row */
d1021 3
a1023 2
/*
 *	clear_region_values
d1025 1
d1028 1
a1028 1
clear_region_values(struct rt_i *rtip)
d1031 6
a1036 1
    RT_CK_RTI(rtip);
d1038 1
a1038 2
	RT_CK_REGION(regp);
	regp->reg_udata = (genptr_t)0;	
a1041 20
/*
 *	check_region_values
 *
 */
int
check_region_values(struct rt_i *rtip)
{
    struct region *regp;
    int r = 0;
    RT_CK_RTI(rtip);
    for( BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) )  {
	RT_CK_REGION(regp);
	if (regp->reg_udata == (genptr_t)0) {
	    bu_log("%s was not hit\n", regp->reg_name);
	    r = 1;
	} else if (((unsigned)regp->reg_udata) < require_num_hits) {
	    dlog("%s hit only %u times (< %u)\n", regp->reg_name, (unsigned)regp->reg_udata, require_num_hits);
	    r = 1;
	}
    }
a1042 2
    return r;
}
d1045 3
a1047 1
 *	report_results
d1051 1
a1051 1
report_results(struct state *state)
d1057 4
a1060 2
	bu_log(" volume %lg cu mm",
	       state->volume[state->i_axis]);
d1064 5
a1068 2
	bu_log(" Weight %lg\n",
	       state->lenDensity[state->i_axis]*gridSpacing*gridSpacing);
d1071 2
a1073 1
}
a1097 140
/*
 *	parse_densities_buffer
 *
 */
void
parse_densities_buffer(char *buf, unsigned long len)
{
    char *p, *q, *last;
    long idx;
    double density;
    char name[128];

    buf[len] = '\0';
    last = &buf[len];

    p = buf;

    densities = bu_malloc(sizeof(struct density_entry)*128, "density entries");
    num_densities = 128;

    while (*p) {
	idx = strtol(p, &q, 10);
	if (q == (char *)NULL) {
	    bu_bomb("could not convert idx\n");
	}

	if (idx < 0) {
	    bu_log("bad density index (< 0) %d\n", idx);
	    bu_bomb("");
	}

	density = strtod(q, &p);
	if (q == p) {
	    bu_bomb("could not convert density\n");
	}
	if (density < 0.0) {
	    bu_log("bad density (< 0) %g\n", density);
	    bu_bomb("");
	}
	
	while (isblank(*p)) p++;

	if (q = strchr(p, '\n')) {
	    *q++ = '\0';
	} else {
	    q = last;
	}

	while (idx >= num_densities) {
	    densities = bu_realloc(densities, sizeof(struct density_entry)*num_densities*2, "density entries");
	    num_densities *= 2;
	}

	densities[idx].magic = DENSITY_MAGIC;
	densities[idx].density = density;
	densities[idx].name = bu_strdup(p);

	p = q;
    } while (p && p < last);

#if 0
    for (idx=0 ; idx < num_densities ; idx++) {
	if (densities[idx].magic == DENSITY_MAGIC) {
	    bu_log("%4d %6g %s\n", 
		   idx,
		   densities[idx].density,
		   densities[idx].name
		   );
	}
    }
#endif
}
/*	g e t _ d e n s i t i e s _ f r o m _ f i l e 
 *
 * Returns
 *	 0 on success
 *	!0 on failure
 */
int
get_densities_from_file(char *name)
{
    FILE *fp;
    struct stat sb;
    char *buf;

    if ((fp=fopen(name, "r")) == (FILE *)NULL) {
	perror(name);
	return 1;
    }

    if (fstat(fileno(fp), &sb)) { 
	perror(name);
	return 1;
    }

    buf = bu_malloc(sb.st_size, "density buffer");
    fread(buf, sb.st_size, 1, fp);
    parse_densities_buffer(buf, (unsigned long)sb.st_size);
    bu_free(buf, "density buffer");
    fclose(fp);
    return 0;
}

/* 
 *	g e t _ d e n s i t i e s _ f r o m _ d a t a b a s e
 *
 * Returns
 *	 0 on success
 *	!0 on failure
 */
int
get_densities_from_database(struct rt_i *rtip)
{
    struct directory *dp;
    struct rt_db_internal intern;
    struct rt_binunif_internal *bu;

    dp = db_lookup(rtip->rti_dbip, "_DENSITIES", LOOKUP_QUIET);
    if (dp == (struct directory *)NULL) {
	bu_log("No density table object in database\n");
	return -1;
    }

    if (rt_db_get_internal(&intern, dp, rtip->rti_dbip, NULL, &rt_uniresource) < 0) {
	bu_log("could not import %s\n", dp->d_namep);
	return 1;
    }

    if (intern.idb_major_type&DB5_MAJORTYPE_BINARY_MASK == 0) {
	return 1;
    }


    bu = (struct rt_binunif_internal *)intern.idb_ptr;

    RT_CHECK_BINUNIF(bu);

    parse_densities_buffer(bu->u.int8, bu->count);
    return 0;
}
d1143 6
a1148 2
	bu_log("Grid spacing %gmm is larger than model bounding box axis\n", gridSpacing);
	bu_log("Adjusted to %gmm to get %g samples per model axis\n", newGridSpacing, Samples_per_model_axis);
d1152 30
a1217 1

d1219 1
a1219 1
	report_results(state);
d1237 28
a1264 2
    int i;
    int axis_count = 3;
d1266 1
a1266 2
    if (volume_tolerance) {
	/* find the range of values for volume */
d1268 3
a1270 3
	val = state->volume[0];
	for (i=1 ; i < axis_count ; i++) {
	    delta = val - state->volume[i];
d1276 3
a1278 3

	if (delta < volume_tolerance) {
	    bu_log("vol tol %g delta %g\n", volume_tolerance, delta);
d1282 2
a1283 2
    if (weight_tolerance) {

d1285 3
a1287 3
	val = state->lenDensity[0];
	for (i=1 ; i < axis_count ; i++) {
	    delta = val - state->lenDensity[i];
d1294 2
a1295 1
	if (delta < weight_tolerance)
d1297 1
a1297 1

d1309 40
d1374 1
d1376 1
a1376 1
    ncpu = bu_avail_cpus();
d1387 1
a1387 1
    rt_init_resource( &rt_uniresource, ncpu, NULL );
d1402 3
d1409 2
d1420 1
a1420 1
    for( i=0; i < ncpu; i++ )  {
d1434 3
a1436 1
    dlog("bounds %g %g %g  %g %g %g\n", V3ARGS(rtip->mdl_min), V3ARGS(rtip->mdl_max));
d1443 1
a1443 1
    VSETALL(state.lenDensity, 0.0);
a1446 3
    if (analysis_flags & ANALYSIS_VOLUME)  bu_log("volume tolerance   %g\n", volume_tolerance);
    if (analysis_flags & ANALYSIS_WEIGHT)  bu_log("weight tolerance   %g\n", weight_tolerance);
    if (analysis_flags & ANALYSIS_OVERLAPS) bu_log("overlap tolerance %g\n", overlap_tolerance);
d1452 2
d1460 2
a1461 1
    report_overlaps();
@


1.6
log
@Checkpoint:  Refinements on man page, and output reporting from program.
@
text
@d1 2
a2 1
/*
d5 1
a5 1
plot the points where overlaps start/stop
a40 16
Options:\n\
\t-A analysis_type (aowv)\n\
\t-a azimuth_degrees\n\
\t-a elevation_degrees\n\
\t-f density_table_filename\n\
\t-g grid_spacing[,limit]\n\
\t-n num_hits_required\n\
\t-P ncpu\n\
\t-r report_bits\n\
\t-S samples_per_model_axis\n\
\t-s samples_per_primitive_axis\n\
\t-t overlap_tolerance_dist \n\
\t-U use_air\n\
\t-u units\n\
\t-V volume_tolerance\n\
\t-W weight_tolerance\n\
d47 8
a54 1
int analysis_flags = ANALYSIS_VOLUME|ANALYSIS_OVERLAPS|ANALYSIS_WEIGHT;
d60 1
a60 1
double gridSpacingLimit = 0.25;
a63 1
int report_bits;
d68 1
a68 1
int use_air;
d112 1
a112 2


d141 62
a202 14

/*
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void
usage(s)
     char *s;
{
    if (s) (void)fputs(s, stderr);

    (void) fprintf(stderr, usage_msg, progname);

    exit(1);
}
d208 1
a208 1
read_units_double(char *buf, double *val)
d213 1
d224 8
a231 3
	conv = bu_units_conversion(units);
	if (conv != 0.0) {
	    *val = a * conv;
d234 1
a234 1
	bu_log("Bad units specifier on value \"%s\"\n", buf);
d241 20
d266 1
a266 3
parse_args(ac, av)
     int ac;
     char *av[];
d270 2
a271 2
    char unitstr[64];
#define LEN_UNITS 32
d292 4
d297 10
a306 1
		    analysis_flags = ANALYSIS_VOLUME|ANALYSIS_WEIGHT|ANALYSIS_OVERLAPS;
d311 3
a316 3
		case 'v' :
		    analysis_flags |= ANALYSIS_VOLUME;
		    break;
d319 1
a337 2

	    /* NOTE:  The 32 in this string must match LEN_UNITS  */
d346 1
a346 1
	    if (read_units_double(optarg, &gridSpacing)) {
d351 1
a351 1
		if (read_units_double(p, &gridSpacingLimit)) {
a374 4
	case 'r'	:
	    sscanf(optarg, "%i", &report_bits);
	    bu_log("-r option not implemented yet\n");
	    break;
d391 1
a391 1
	    if (read_units_double(optarg, &overlap_tolerance))
d393 2
a394 2
		exit(-1);
	    }
d397 1
a397 1
	    if (read_units_double(optarg, &volume_tolerance)) {
d403 1
a403 1
	    if (read_units_double(optarg, &volume_tolerance)) {
d432 6
a437 6
	register struct xray	*rp = &ap->a_ray;
	register struct hit	*ihitp = pp->pt_inhit;
	register struct hit	*ohitp = pp->pt_outhit;
	vect_t	ihit;
	vect_t	ohit;
	double depth;
d441 18
a458 18
	VJOIN1( ihit, rp->r_pt, ihitp->hit_dist, rp->r_dir );
	VJOIN1( ohit, rp->r_pt, ohitp->hit_dist, rp->r_dir );
	depth = ohitp->hit_dist - ihitp->hit_dist;
	if( depth < overlap_tolerance )
		return(0);

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	//	pdv_3line( outfp, ihit, ohit );
	noverlaps++;
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( !(analysis_flags&ANALYSIS_OVERLAPS) ) {
		bu_log("\nOVERLAP %d: %s\nOVERLAP %d: %s\nOVERLAP %d: depth %gmm\nOVERLAP %d: in_hit_point (%g,%g,%g)mm\nOVERLAP %d: out_hit_point (%g,%g,%g) mm\n------------------------------------------------------------\n",
			noverlaps,reg1->reg_name,
			noverlaps,reg2->reg_name,
			noverlaps,depth,
			noverlaps,ihit[X],ihit[Y],ihit[Z],
			noverlaps,ohit[X],ohit[Y],ohit[Z]);
d464 20
a483 27
	} else {
		struct overlap_list	*prev_ol = (struct overlap_list *)0;
		struct overlap_list	*op;		/* overlap list */
		struct overlap_list     *new_op;
		new_op =(struct overlap_list *)bu_malloc(sizeof(struct overlap_list),"overlap list");

		/* look for it in our list */
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		for( op=olist; op; prev_ol=op, op=op->next ) {

			/* if we already have an entry for this region pair, 
			 * we increase the counter, check the depth and 
			 * update thickness maximum and entry point if need be
			 * and return 
			 */
			if( (strcmp(reg1->reg_name,op->reg1) == 0) && (strcmp(reg2->reg_name,op->reg2) == 0) ) {
				op->count++;
				if (depth > op->max_thickness) {
				    op->max_thickness = depth;
				    VMOVE(op->coord, ihit);
				}


				bu_semaphore_release( BU_SEM_SYSCALL );
				bu_free( (char *) new_op, "overlap list");
				return	0;	/* already on list */
			} 
d485 7
d493 7
a499 7
		for( op=olist; op; prev_ol=op, op=op->next ) {
			/* if this pair was seen in reverse, decrease the unique counter */
			if ((strcmp(reg1->reg_name, op->reg2) == 0) && (strcmp(reg2->reg_name, op->reg1) == 0)) {
				unique_overlap_count--;
				break;
			}
		}
d501 3
a503 3
		/* we have a new overlapping region pair */
		overlap_count++;
		unique_overlap_count++;
d505 13
a517 13
		op = new_op;
		if( olist )		/* previous entry exists */
			prev_ol->next = op;
		else
			olist = op;	/* finally initialize root */
		op->reg1 = reg1->reg_name;
		op->reg2 = reg2->reg_name;
		op->next = NULL;
		op->count = 1;
		op->max_thickness = depth;
		VMOVE(op->coord, ihit);
		bu_semaphore_release( BU_SEM_SYSCALL );
	}
d519 6
a524 7
	/* useful debugging */
	if (0) {
		struct overlap_list	*op;		/* overlap list */
		bu_log("PRINTING LIST::reg1==%s, reg2==%s\n", reg1->reg_name, reg2->reg_name);
		for (op=olist; op; op=op->next) {
			bu_log("\tpair: %s  %s  %d matches\n", op->reg1, op->reg2, op->count);
		}
d526 1
d528 1
a528 1
	return(0);	/* No further consideration to this partition */
d585 1
a585 1
    point_t		pt;
d588 4
a595 1
	double dist;
d600 2
d603 36
a638 12
	/* try to factor in the density of this object */
	if (pp->pt_regionp->reg_gmater >= num_densities) {
	    bu_log("density index %d on region %s is outside of range of table [1..%d]\nSet GIFTmater on region or add entry to density table\n",
		   pp->pt_regionp->reg_gmater,
		   pp->pt_regionp->reg_name,
		   num_densities);
	    bu_bomb("");
	} else {
	    de = &densities[pp->pt_regionp->reg_gmater];
	    if (de->magic == DENSITY_MAGIC) {
		ap->a_color[0] += de->density * dist;
		ap->a_color[1] += dist;
d640 24
a663 3
		bu_log("density index %d from region %s is not set.\nAdd entry to density table\n",
		       pp->pt_regionp->reg_gmater, pp->pt_regionp->reg_name);
		bu_bomb("");
d666 1
d668 5
d675 8
d821 12
a832 3
    bu_log("\tvolume %lg cu mm  Weight %lg\n",
	   state->volume[state->i_axis],
	   state->lenDensity[state->i_axis]*gridSpacing*gridSpacing);
d930 2
a931 1
/* 
d960 1
d962 2
a999 9
/*
 *	get_densities
 *
 */
int
get_densities( struct rt_i * rtip)
{
    struct directory *dp;
}
d1004 6
d1066 2
a1067 2
	for (axis=0 ; axis < num_axes ; axis++) {
	    state->curr_view = axis;
d1069 5
a1073 5
	    state->v = 0;
	    /* xy, yz, zx */
	    state->u_axis = axis;
	    state->v_axis = (axis+1) % 3;
	    state->i_axis = (axis+2) % 3;
d1076 3
a1078 12
	    state->u_dir[state->u_axis] = 1;
	    state->u_dir[state->v_axis] = 0;
	    state->u_dir[state->i_axis] = 0;

	    state->v_dir[state->u_axis] = 0;
	    state->v_dir[state->v_axis] = 1;
	    state->v_dir[state->i_axis] = 0;


	    bu_parallel(plane_worker, ncpu, (genptr_t)state); /* xy plane */
	    report_results(state);
	}
d1080 3
d1085 3
d1092 7
a1099 1

d1107 6
a1112 6
	if (volume_tolerance) {
	    /* find the range of values for volume */
	    low = hi = 0.0;
	    val = state->volume[0];
	    for (i=1 ; i < axis_count ; i++) {
		delta = val - state->volume[i];
d1114 4
a1117 4
		if (delta < low) low = delta;
		if (delta > hi) hi = delta;
	    }
	    delta = hi - low;
d1119 3
a1121 4
	    if (delta < volume_tolerance) {
		bu_log("vol tol %g delta %g\n", volume_tolerance, delta);
		return 0;
	    }
d1123 2
a1124 1
	if (weight_tolerance) {
d1126 4
a1129 4
	    low = hi = 0.0;
	    val = state->lenDensity[0];
	    for (i=1 ; i < axis_count ; i++) {
		delta = val - state->lenDensity[i];
d1131 4
a1134 4
		if (delta < low) low = delta;
		if (delta > hi) hi = delta;
	    }
	    delta = hi - low;
d1136 2
a1137 2
	    if (delta < weight_tolerance)
		return 0;
d1139 1
a1139 1
	}
d1141 6
a1146 6
	/* refine the gridSpacing and try again */
	gridSpacing *= 0.5;
	if (gridSpacing < gridSpacingLimit) {
	    bu_log("grid spacing refined to %g which is below lower limit %g\n", gridSpacing, gridSpacingLimit);
	    return 0;
	}
d1148 1
a1148 1
	return 1;
d1200 1
d1240 8
@


1.5
log
@Fixed a few bugs.  Added some reporting when options are not implemented (yet)
@
text
@a6 19
 *	Options
 *	-A flags	Analysis types
 * 	-a azimuth	
 *	-e elevation
 *	-f filename
 *	-g gridspacing[,lim]
 *	-G		create groups
 *	-m min_samples
 *	-n numhits
 *	-s samples_per_smallest_bbox
 *	-S samples_per_model_bbox
 *	-P ncpu
 *	-r bits		report types
 *	-t tol_dist	overlap tolerance
 *	-V volume_tolerance
 *	-U aircode	use_air
 *	-u units	
 *	-W weight_tolerance
 *	-h		help
d39 19
d141 6
a146 4
	struct overlap_list *next;	/* next one */
	const char 	*reg1;		/* overlapping region 1 */
	const char	*reg2;		/* overlapping region 2 */
	long	count;			/* number of time reported */
d161 2
a162 2
    (void) fprintf(stderr, "Usage: %s [-P #processors] [-g initial_gridsize] [-t vol_tolerance] [-f density_table_file] [-d(ebug)] geom.g obj [obj...]\n",
		   progname);
d167 32
d209 4
a212 1
    double conv;
a261 6
#define LEN_UNITS 32
	    int i, j;
	    char unit1[LEN_UNITS];
	    char unit2[LEN_UNITS];
	    double a, b;
	    char *p;
d272 3
a274 19
	    i = sscanf(optarg, "%lg%s", &a, unit1);

	    if (i > 0) {
		if (a <= 0.0) {
		    bu_log("gridSpacing must be a positive value > 0.0, not \"%s\"\n", unit1);
		    break;
		}
		if (i > 1) {
		    conv = bu_units_conversion(unit1);
		    if (conv != 0.0)
			gridSpacing = a * conv;
		    else {
			bu_log("bad units specification \"%s\" for %s\n", unit1, optarg);
			gridSpacing = a;
		    }
		} else {
		    gridSpacing = a;
		}

a275 2


d277 3
a279 18
		j = sscanf(p, "%lg%s", &b, unit2);
		if (j > 0)
		    if (b <= 0.0) {
			bu_log("gridSpacing must be a positive value > 0.0, not \"%s\"\n", unit1);
			break;
		    }
		    if (j > 1) {
			conv = bu_units_conversion(unit2);
			if (conv != 0.0)
			    gridSpacingLimit = b * conv;
			else {
			    bu_log("bad units specification \"%s\" for %s\n", unit2, p);
			    gridSpacingLimit = b;
			}
		    } else {
			gridSpacingLimit = b;
		    }

d282 1
d301 4
d306 1
a306 1
	    if (sscanf(optarg, "%lg", &conv) != 1 || conv <= 0.0) {
d310 1
a310 1
	    Samples_per_model_axis = conv;
d313 1
a313 1
	    if (sscanf(optarg, "%lg", &conv) != 1 || conv <= 0.0) {
d317 1
a317 1
	    Samples_per_prim_axis = conv;
d321 1
a321 1
	    if (sscanf(optarg, "%lg", &conv) != 1 || conv <= 0.0 ) {
d323 1
a323 1
		break;
a324 1
	    overlap_tolerance = conv;
d327 1
a327 1
	    if (sscanf(optarg, "%lg", &conv) != 1 || conv <= 0.0 ) {
d329 1
a329 1
		break;
a330 2
	    volume_tolerance = conv;

d333 1
a333 1
	    if (sscanf(optarg, "%lg", &conv) != 1 || conv <= 0.0 ) {
d335 1
a335 1
		break;
a336 1
	    weight_tolerance = conv;
d405 3
a407 1
			 * we increase the counter and return 
d411 6
d425 1
a425 1
			if ( (strcmp(reg1->reg_name, op->reg2) == 0) && (strcmp(reg2->reg_name, op->reg1) == 0) ) {
d444 2
d462 4
d487 4
a490 1

d507 1
d559 1
d569 4
d639 4
d654 4
d678 4
d692 4
d706 1
a706 1
    bu_log("Overlaps\ntotal encountered:%d  total pairs:%d  unique pairs:%d\n", noverlaps, overlap_count, unique_overlap_count);
d708 2
a709 1
	bu_log("%s %s\n", op->reg1, op->reg2);
d715 4
d851 2
d854 2
d863 4
d907 4
d997 1
a997 1
	    bu_log("grid spacing refined to %g which is below lower limit %g\n", gridSpacingLimit, gridSpacing);
d1035 1
a1035 1
	usage("oops\n");
@


1.4
log
@checkpoint
@
text
@d52 1
a52 1
char *options = "A:a:de:f:g:Gn:P:r:S:s:t:T:U:u:W:";
d284 1
a284 1
	    bu_log("spacing:%g limit:%g\n", gridSpacing, gridSpacingLimit);
d288 1
d303 1
a303 1
	    if (sscanf(optarg, "%g", &conv) != 1 || conv <= 0.0) {
d310 1
a310 1
	    if (sscanf(optarg, "%g", &conv) != 1 || conv <= 0.0) {
d330 1
d384 1
a384 1
		bu_log("\nOVERLAP %d: %s\nOVERLAP %d: %s\nOVERLAP %d: depth %gmm\nOVERLAP %d: in_hit_point (%g,%g,%g) mm\nOVERLAP %d: out_hit_point (%g,%g,%g) mm\n------------------------------------------------------------\n",
d865 1
a865 1
    bu_log("grid spacing %g mm  %d x %d x %d steps\n", gridSpacing, V3ARGS(steps));
d917 2
a918 1
	    if (delta < volume_tolerance)
d920 1
a1030 1
    bu_log("flags %0x\n", analysis_flags);
@


1.3
log
@Modifications following first user community design review.
@
text
@d21 1
a21 1
 *	-T volume_tolerance
d52 1
a52 1
char *options = "hP:g:df:t:m:";
d58 29
a88 4
char user_set_grid_size;
int debug;
#define dlog if (debug) bu_log
char *densityFileName;
d91 1
a91 1
unsigned minimum_region_hits = 1; /* number of times a region must be hit to be considered sampled */
d95 2
d106 1
d113 2
d117 2
a120 3
long steps[3]; /* # of "grid_size" steps to take along each axis (X,Y,Z) to cover the face of the bounding rpp? */

vect_t span; /* How much space does the geometry span in each of X,Y,Z directions */
d149 202
d373 1
a373 1
	if( depth < overlap_tol )
d381 1
a381 1
	if( !rpt_overlap ) {
a449 63
/*
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void
usage(s)
     char *s;
{
    if (s) (void)fputs(s, stderr);

    (void) fprintf(stderr, "Usage: %s [-P #processors] [-g initial_gridsize] [-t vol_tolerance] [-f density_table_file] [-d(ebug)] geom.g obj [obj...]\n",
		   progname);
    exit(1);
}

/*
 *	P A R S E _ A R G S --- Parse through command line flags
 */
int
parse_args(ac, av)
     int ac;
     char *av[];
{
    int  c;
    char *strrchr();
    char unitstr[64];
    double conv;

    if (  ! (progname=strrchr(*av, '/'))  )
	progname = *av;
    else
	++progname;

    /* Turn off getopt's error messages */
    opterr = 0;

    /* get all the option flags from the command line */
    while ((c=getopt(ac,av,options)) != EOF)
	switch (c) {
	case 'd'	: debug = !debug; break;
	case 'f'	: densityFileName = optarg; break;
	case 'g'	:
	    sscanf(optarg, "%lg%60s", &grid_size, unitstr); 
	    user_set_grid_size = 1;
	    conv = bu_units_conversion(unitstr);
	    if (conv != 0.0) grid_size *= conv;
	    break;
	case 'm'	:
	    if (sscanf(optarg, "%u", &minimum_region_hits) != 1) {
		bu_log("scan error reading minimum region hit count \"%s\"\n", optarg);
	    }
	    break;
	case 'P'	:
	    /* cannot ask for more cpu's than the machine has */
	    if ((c=atoi(optarg)) > 0 && npsw > c) npsw = c;
	    break;	
	case 't'	: tol = strtod(optarg, (char **)NULL); break;
	case '?'	:
	case 'h'	:
	default		: usage("Bad or help flag specified\n"); break;
	}

    return(optind);
}
d576 1
d586 1
a586 1
	v_coord = grid_size * 0.5 + v * grid_size; 
d595 2
a596 2
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u * grid_size + 0.5 * grid_size;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v * grid_size + 0.5 * grid_size;
d599 1
d605 2
a606 2
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u * grid_size + 0.5 * grid_size;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v * grid_size + 0.5 * grid_size;
d609 1
d637 2
a638 2
	} else if (((unsigned)regp->reg_udata) < minimum_region_hits) {
	    dlog("%s hit only %u times (< %u)\n", regp->reg_name, (unsigned)regp->reg_udata, minimum_region_hits);
d649 1
a649 1
    state->volume[state->i_axis] *= grid_size*grid_size;
d653 1
a653 1
	   state->lenDensity[state->i_axis]*grid_size*grid_size);
d814 127
d942 2
d970 1
d972 1
a972 2
    npsw = bu_avail_cpus();

d981 1
a981 1
    rt_init_resource( &rt_uniresource, npsw, NULL );
a982 1
	
a994 12
    if ( densityFileName) {
	dlog("density from file\n");
	if (get_densities_from_file(densityFileName)) {
	    return -1;
	}
    } else {
	dlog("density from db\n");
	if (get_densities_from_database(rtip)) {
	    return -1;
	}
    }

d1008 1
a1008 1
    for( i=0; i < npsw; i++ )  {
d1017 1
a1017 2
    rt_prep_parallel(rtip,npsw);

d1026 2
d1029 1
a1029 27
    double set = 0.0;
    int axis = -1;
    for (i=0 ; i < 3 ; i++) {
	if (span[i] < grid_size) {
	    if (axis != -1) {
		if (span[i] < span[axis]) {
		    set = span[i];
		    axis = i;
		}
	    } else {
		    set = span[i];
		    axis = i;
	    }
	}
    }
    if (set != 0.0) {
	if (user_set_grid_size) {
		bu_log("Grid size %gmm is larger than bounding box axis.\n", grid_size);
		bu_log("Consider setting grid size to at least %g\n", span[i]/10.0);
	} else {
		bu_log("grid size %gmm is larger than bounding box axis %s.\n", grid_size, 
		       (axis == 0 ? "X" : (axis == 1 ? "Y" : "Z")));
		grid_size = set / 10.0;
		bu_log("Adjusted to %gmm to make at least 10 grid cells per axis\n", set);
	}
    }

d1034 2
a1035 6
    lim = tol+1.0;
    dlog("tol: %g\n", tol);

    crv = 1;
    clear_region_values(rtip);
    while (lim > tol || crv) {
d1037 1
a1037 45
	VSCALE(steps, span, 1.0/grid_size);

	bu_log("grid size %g mm  %d x %d x %d steps\n", grid_size, V3ARGS(steps));

	state.u_axis = 0;
	state.v_axis = 1;
	state.i_axis = 2;
	state.v = 0;
	
	dlog("\txy %ld x %ld samples.  ", steps[X], steps[Y]);
	bu_parallel(plane_worker, npsw, (genptr_t)&state); /* xy plane */
	report_results(&state);


	state.u_axis = 0;
	state.v_axis = 2;
	state.i_axis = 1;
	state.v = 0;

	dlog("\txz %d x %d samples.  ", steps[X], steps[Z]);
	bu_parallel(plane_worker, npsw, (genptr_t)&state); /* xz plane */
	report_results(&state);

	state.u_axis = 1;
	state.v_axis = 2;
	state.i_axis = 0;
	state.v = 0;

	dlog("\tyz %d x %d samples.  ", steps[Y], steps[Z]);
	bu_parallel(plane_worker, npsw, (genptr_t)&state); /* yz plane */
	report_results(&state);

	crv = check_region_values(rtip);

	lim = fabs(state.volume[0] - state.volume[1]);
	val = fabs(state.volume[0] - state.volume[2]);
	if (lim > val) lim = val;

	val = fabs(state.volume[1] - state.volume[2]);
	if (lim < val) lim = val;

	dlog("lim %g\n", lim);
	grid_size *= 0.5;

    }
d1039 1
d1042 1
a1042 2

	return(0);
@


1.2
log
@Just a checkpoint.  added support for minimum rays required per region.
@
text
@d8 18
a25 1
 *	h	help
@


1.1
log
@This is an initial cut at a 3-axis variant of rtweight.  It is designed to get a better
quality result for the user based upon near-infinite grid resolution, and multiple-axis
raycasting.
@
text
@d3 3
d35 1
a35 1
char *options = "hP:g:df:t:";
d43 1
d48 9
d85 117
d240 1
a240 1
	case 't'	: tol = strtod(optarg, (char **)NULL); break;
a241 4
	case 'd'	: debug = !debug; break;
	case 'P'	:
	    if ((c=atoi(optarg)) > 0) npsw = c;
	    break;	
d244 1
d248 10
d281 1
a321 1

d342 1
d379 2
a380 1
    ap.a_multioverlap = multioverlap;
a412 1
		dlog("%g %g %g\n", V3ARGS(ap.a_ray.r_pt));
a421 1
		dlog("%g %g %g\n", V3ARGS(ap.a_ray.r_pt));
d428 1
a428 1
clear_region_values()
d430 26
d463 3
a465 1
    bu_log("volume %lg  Weight %lg\n", state->volume[state->i_axis], state->lenDensity[state->i_axis]*grid_size*grid_size);
d469 18
d651 1
d680 1
a680 1
	bu_log("density from file\n");
d685 1
a685 1
	bu_log("density from db\n");
d719 1
a719 1
    bu_log("bounds %g %g %g  %g %g %g\n", V3ARGS(rtip->mdl_min), V3ARGS(rtip->mdl_max));
d722 29
d756 1
a756 1
    bu_log("tol: %g\n", tol);
d758 3
a760 1
    while (lim > tol) {
d764 1
a764 1
	bu_log("grid size %g mm\n", grid_size);
d771 1
a771 2
	bu_log("\txy %d x %d samples ", steps[X], steps[Y]);
	clear_region_values();
d775 1
d781 1
a781 2
	bu_log("\txz %d x %d samples ", steps[X], steps[Z]);
	clear_region_values();
d790 1
a790 2
	bu_log("\tyz %d x %d samples ", steps[Y], steps[Z]);
	clear_region_values();
d794 2
d803 1
a803 1
	bu_log("lim %g\n", lim);
d808 3
@


1.1.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d1 1
a1 2
/*	G _ Q A . C --- perform quality assurance checks on geometry
 *
a2 4
 * XXX need to look at gap computation

 plot the points where overlaps start/stop

d4 2
a29 2
#define SEM_LIST RT_SEM_LAST+1

d32 1
a32 1
char *options = "A:a:de:f:g:Gn:N:P:rS:s:t:U:u:vV:W:";
d38 4
a41 19
char *usage_msg = "Usage: %s [options] model object [object...]\n\
";


#define ANALYSIS_VOLUME 1
#define ANALYSIS_WEIGHT 2
#define ANALYSIS_OVERLAPS 4
#define ANALYSIS_ADJ_AIR 8
#define ANALYSIS_GAP	16
#define ANALYSIS_EXP_AIR 32 /* exposed air */
#define ANALYSIS_BOX 64

int analysis_flags = ANALYSIS_VOLUME | ANALYSIS_OVERLAPS | ANALYSIS_WEIGHT | \
	ANALYSIS_EXP_AIR | ANALYSIS_ADJ_AIR | ANALYSIS_GAP ;
int multiple_analysis = 1;


double azimuth_deg;
double elevation_deg;
d43 1
a43 23
double gridSpacing = 50.0;
double gridSpacingLimit = 0.25; /* limit to 1/4 mm */
char makeOverlapAssemblies;
int require_num_hits = 1;
int ncpu = 1;
double Samples_per_model_axis = 2.0;
double overlap_tolerance;
double volume_tolerance = -1.0;
double weight_tolerance = -1.0;
/*double *grams;*/
int print_per_region_stats;
int max_region_name_len;
int use_air = 1;
int num_objects; /* number of objects specified on command line */
int max_cpus;
int num_views = 3;
int verbose;

FILE *plot_fp;
int overlap_color[3] = { 255, 255, 0 };
int gap_color[3] = { 128, 128, 255 };
int adjAir_color[3] = { 255, 0, 0 };
int expAir_color[3] = { 255, 128, 255 };
a44 2
int debug;
#define dlog if (debug) bu_log
d48 1
a48 2
struct cstate {
    int curr_view;	/* the "view" number we are shooting */
d53 2
a54 7
    double	*m_lenDensity;
    double	*m_len;
    double	*m_volume;
    double	*m_weight;
    unsigned long *shots;
    vect_t u_dir;		/* direction of U vector for "current view" */
    vect_t v_dir;		/* direction of V vector for "current view" */
a55 4
    long steps[3];	/* this is per-dimension, not per-view */
    vect_t span;	/* How much space does the geometry span in each of X,Y,Z directions */
    vect_t area;	/* area of the view for view with invariant at index */
    int first;		/* this is the first time we've computed a set of views */
d58 6
a63 1
/* the entries in the density table */
d66 1
a66 1
    double	grams_per_cu_mm;
d72 8
d81 4
a84 8
/* summary data structure for objects specified on command line */
struct per_obj_data {
    char *o_name;
    double *o_len;
    double *o_lenDensity;
    double *o_volume;
    double *o_weight;
} *obj_tbl;
d86 2
a87 1
/* this is the data we track for each region
d89 14
a102 8
struct per_region_data {
    unsigned long hits;
    double	*r_lenDensity; /* for per-region per-view weight computation */
    double	*r_len; /* for per-region, per-veiew computation */
    double	*r_weight;
    double	*r_volume;
    struct per_obj_data *optr;
} *reg_tbl;
d104 2
d107 18
d126 2
a127 8
struct region_pair {
    struct bu_list 	l;
    struct region 	*r1;
    struct region 	*r2;
    unsigned long	count;
    double		max_dist;
    vect_t		coord;
};
d129 4
a132 41
static struct region_pair gapList = { 
    { BU_LIST_HEAD_MAGIC,
      (struct bu_list *)&gapList,
      (struct bu_list *)&gapList },
    (struct region *)"Gaps",
    (struct region *)NULL,
    (unsigned long)0,
    (double)0.0,
    {0.0, 0.0, 0.0,}
};
static struct region_pair adjAirList = { 
    { BU_LIST_HEAD_MAGIC,
      (struct bu_list *)&adjAirList,
      (struct bu_list *)&adjAirList },
    (struct region *)"Adjacent Air",
    (struct region *)NULL,
    (unsigned long)0,
    (double)0.0,
    {0.0, 0.0, 0.0,}
};
static struct region_pair exposedAirList = { 
    { BU_LIST_HEAD_MAGIC,
      (struct bu_list *)&exposedAirList,
      (struct bu_list *)&exposedAirList },
    (struct region *)"Exposed Air",
    (struct region *)NULL,
    (unsigned long)0,
    (double)0.0,
    {0.0, 0.0, 0.0,}
};
static struct region_pair overlapList = { 
    { BU_LIST_HEAD_MAGIC,
      (struct bu_list *)&overlapList,
      (struct bu_list *)&overlapList },
    (struct region *)"Overlaps",
    (struct region *)NULL,
    (unsigned long)0,
    (double)0.0,
    {0.0, 0.0, 0.0,}
};
    
d134 5
a138 5
/* XXX this section should be extracted to libbu/units.c */
struct cvt_tab {
    double val;
    char name[32];
};
d140 5
a144 97
static const struct cvt_tab units_tab[3][40] = {
    { /* length, stolen from bu/units.c with the  "none" value removed
       * Values for converting from given units to mm 
       */
	{1.0,		"mm"}, /* default */
	/*	{0.0,		"none"},*/
	{1.0e-7,	"angstrom"},
	{1.0e-7,	"decinanometer"},
	{1.0e-6,	"nm"},
	{1.0e-6,	"nanometer"},
	{1.0e-3,	"um"},
	{1.0e-3,	"micrometer"},
	{1.0e-3,	"micron"},
	{1.0,		"millimeter"},
	{10.0,		"cm"},
	{10.0,		"centimeter"},
	{1000.0,	"m"},
	{1000.0,	"meter"},
	{1000000.0,	"km"},
	{1000000.0,	"kilometer"},
	{25.4,		"in"},
	{25.4,		"inch"},
	{25.4,		"inche"},		/* for plural */
	{304.8,		"ft"},
	{304.8,		"foot"},
	{304.8,		"feet"},
	{456.2,		"cubit"},
	{914.4,		"yd"},
	{914.4,		"yard"},
	{5029.2,	"rd"},
	{5029.2,	"rod"},
	{1609344.0,	"mi"},
	{1609344.0,	"mile"},
	{1852000.0,	"nmile"},
	{1852000.0,	"nautical mile"},
	{1.495979e+14,	"AU"},
	{1.495979e+14,	"astronomical unit"},
	{9.460730e+18,	"lightyear"},
	{3.085678e+19,	"pc"},
	{3.085678e+19,	"parsec"},
	{0.0,		""}			/* LAST ENTRY */
    },
    {/* volume 
      * Values for converting from given units to mm^3
      */
	{1.0, "cu mm"}, /* default */

	{1.0, "mm"},
	{1.0, "mm^3"},

	{1.0e3, "cm"},
	{1.0e3, "cm^3"},
	{1.0e3, "cu cm"},
	{1.0e3, "cc"},

	{1.0e6, "l"},
	{1.0e6, "liter"},
	{1.0e6, "litre"},

	{1.0e9, "m"},
	{1.0e9, "m^3"},
	{1.0e9, "cu m"},

	{16387.064, "in"},
	{16387.064, "in^3"},
	{16387.064, "cu in"},

	{28316846.592, "ft"},

	{28316846.592, "ft^3"},
	{28316846.592, "cu ft"},

	{764554857.984, "yds"},
	{764554857.984, "yards"},
	{764554857.984, "cu yards"},

	{0.0,		""}			/* LAST ENTRY */
    },
    { /* weight 
       * Values for converting given units to grams
       */
	{1.0, "grams"}, /* default */

	{1.0, "g"},
	{0.0648, "gr"},
	{0.0648, "grains"},

	{1.0e3, "kg"},
	{1.0e3, "kilos"},
	{1.0e3, "kilograms"},

	{28.35, "oz"},
	{28.35, "ounce"},

	{453.6, "lb"},
	{453.6, "lbs"},
	{0.0,		""}			/* LAST ENTRY */
d146 1
a146 1
};
a147 8
#define LINE 0
#define VOL 1
#define WGT 2
static const struct cvt_tab *units[3] = { 
    &units_tab[0][0],	/* linear */
    &units_tab[1][0],	/* volume */
    &units_tab[2][0]	/* weight */
};
d150 8
a157 5

const struct cvt_tab *vol_tab;
const struct cvt_tab *wgt_tab;
const struct cvt_tab *ovl_tab;

d161 4
a164 7
 *	read_units_double
 *
 *	Read a non-negative floating point value with optional units
 *
 *	Return
 *		1 Failure
 *		0 Success
d166 1
a166 2
int
read_units_double(double *val, char *buf, const struct cvt_tab *cvt)
d168 8
a175 3
    double a, conv;
    char units_string[256];
    int i;
d178 4
a181 1
    i = sscanf(buf, "%lg%s", &a, units_string);
d183 1
a183 1
    if (i < 0) return 1;
d185 1
a185 2
    if (i == 1) {
	*val = a;
d187 12
a198 7
	return 0;
    }
    if (i == 2) {
	*val = a;
	for ( ; cvt->name[0] != '\0' ; ) {
	    if (!strcmp(cvt->name, units_string)) {
		goto found_units;
d200 3
a202 1
		cvt++;
d205 1
a205 2
	bu_log("Bad units specifier \"%s\" on value \"%s\"\n", units, buf);
	return 1;
d207 5
a211 6
    found_units:
	*val = a * cvt->val;
	return 0;
    }
    bu_log("%s sscanf problem on \"%s\"  got %d\n", BU_FLSTR, buf, i);
    return 1;
a213 5
/* the above should be extracted to libbu/units.c */




d215 1
a215 1
 *	U S A G E --- tell user how to invoke this program, then exit
d217 1
a217 3
void
usage(s)
     char *s;
d219 4
a222 5
    if (s) (void)fputs(s, stderr);

    (void) fprintf(stderr, usage_msg, progname);

    exit(1);
d226 8
a234 11
/*
 *	P A R S E _ A R G S --- Parse through command line flags
 */
int
parse_args(int ac, char *av[])
{
    int  c;
    char *strrchr();
    int i, j;
    double a, b;
    char *p;
d236 9
a244 4
    if (  ! (progname=strrchr(*av, '/'))  )
	progname = *av;
    else
	++progname;
d246 2
a247 2
    /* Turn off getopt's error messages */
    opterr = 0;
d249 11
a259 80
    /* get all the option flags from the command line */
    while ((c=getopt(ac,av,options)) != EOF)
	switch (c) {
	case 'A'	:
	    {
		char *p;
		analysis_flags = 0;
		multiple_analysis = 0;
		for (p = optarg; *p ; p++) {
		    switch (*p) {
		    case 'A' :
			analysis_flags = ANALYSIS_VOLUME | ANALYSIS_WEIGHT | ANALYSIS_OVERLAPS |\
			    ANALYSIS_ADJ_AIR | ANALYSIS_GAP | ANALYSIS_EXP_AIR;
			multiple_analysis = 1;
			break;
		    case 'a' :
			if (analysis_flags)
			    multiple_analysis = 1;

			    analysis_flags |= ANALYSIS_ADJ_AIR;

			break;
		    case 'b' :
			if (analysis_flags)
			    multiple_analysis = 1;

			analysis_flags |= ANALYSIS_BOX;

			break;
		    case 'e' :
			if (analysis_flags)
			    multiple_analysis = 1;

			analysis_flags |= ANALYSIS_EXP_AIR;
			break;
		    case 'g' :
			if (analysis_flags)
			    multiple_analysis = 1;

			analysis_flags |= ANALYSIS_GAP;
			break;
		    case 'o' :
			if (analysis_flags)
			    multiple_analysis = 1;

			analysis_flags |= ANALYSIS_OVERLAPS;
			break;
		    case 'v' :
			if (analysis_flags)
			    multiple_analysis = 1;

			analysis_flags |= ANALYSIS_VOLUME;
			break;
		    case 'w' :
			if (analysis_flags)
			    multiple_analysis = 1;

			analysis_flags |= ANALYSIS_WEIGHT;
			break;
		    default:
			bu_log("Unknown analysis type \"%c\" requested.\n", *p);
			bu_bomb("");
			break;
		    }
		}
		break;
	    }
	case 'a'	:
	    bu_log("azimuth not implemented\n");
	    if (sscanf(optarg, "%lg", &azimuth_deg) != 1) {
		bu_log("error parsing azimuth \"%s\"\n", optarg);
	    }
	    break;
	case 'e'	:
	    bu_log("elevation not implemented\n");
	    if (sscanf(optarg, "%lg", &elevation_deg) != 1) {
		bu_log("error parsing elevation \"%s\"\n", optarg);
	    }
	    break;
	case 'd'	: debug = !debug; break;
d261 1
a261 1
	case 'f'	: densityFileName = optarg; break;
d263 2
a264 3
	case 'g'	:
	    {
		i = j = 0;
a265 14
		if (p = strchr(optarg, ',')) {
		    *p++ = '\0';
		}

		if (read_units_double(&gridSpacing, optarg, &units_tab[0][0])) {
		    bu_log("error parsing grid spacing value \"%s\"\n", optarg);
		    exit(-1);
		}
		if (p) {
		    if (read_units_double(&gridSpacingLimit, p, units_tab[0])) {
			bu_log("error parsing grid spacing limit value \"%s\"\n", p);
			exit(-1);
		    }
		}
d267 6
a272 14
		bu_log("grid spacing:%gmm limit:%gmm\n", gridSpacing, gridSpacingLimit);
		break;
	    }
	case 'G'	:
	    makeOverlapAssemblies = 1;
	    bu_log("-G option unimplemented\n");
	    break;
	case 'n'	:
	    if (sscanf(optarg, "%d", &c) != 1 || c < 0) {
		bu_log("num_hits must be integer value >= 0, not \"%s\"\n", optarg);
		break;
	    }
	    require_num_hits = c;
	    break;
d274 2
a275 14
	case 'N'	:
	    num_views = atoi(optarg);
	    break;
	case 'P'	:
	    /* cannot ask for more cpu's than the machine has */
	    if ((c=atoi(optarg)) > 0 && c <= max_cpus ) ncpu = c;
	    break;	
	case 'r'	:
	    print_per_region_stats = 1;
	    break;
	case 'S'	:
	    if (sscanf(optarg, "%lg", &a) != 1 || a <= 1.0) {
		bu_log("error in specifying minimum samples per model axis: \"%s\"\n", optarg);
		break;
d277 6
a282 23
	    Samples_per_model_axis = a + 1;
	    break;
	case 't'	: 
	    if (read_units_double(&overlap_tolerance, optarg, &units_tab[0][0])) {
		bu_log("error in overlap tolerance distance \"%s\"\n", optarg);
		exit(-1);
	    }
	    break;
	case 'v'	:
	    verbose = 1;
	    break;
	case 'V'	: 
	    if (read_units_double(&volume_tolerance, optarg, units_tab[1])) {
		bu_log("error in volume tolerance \"%s\"\n", optarg);
		exit(-1);
	    }
	    break;
	case 'W'	: 
	    if (read_units_double(&weight_tolerance, optarg, units_tab[2])) {
		bu_log("error in weight tolerance \"%s\"\n", optarg);
		exit(-1);
	    }
	    break;
d284 2
a285 31
	case 'U'	: use_air = atoi(optarg); break;
	case 'u'	:
	    {
		char *ptr = optarg;
		const struct cvt_tab *cv;
		static const char *dim[3] = {"length", "volume", "weight"};
		char *units_name[3];

		for (i=0 ; i < 3 && ptr; i++) {
		    units_name[i] = strsep(&ptr, ",");
		
		    /* make sure the unit value is in the table */
		    if (*units_name[i] != '\0') {
			for (cv= &units_tab[i][0] ; cv->name[0] != '\0' ; cv++) {
			    if (!strcmp(cv->name, units_name[i])) {
				goto found_cv;
			    }
			}
			bu_log("Units \"%s\" not found in coversion table\n", units_name[i]);
			bu_bomb("");
		    found_cv:
			units[i] = cv;
		    }
		}

		bu_log("Units:\n");
		for (i=0 ; i < 3 ; i++) {
		    bu_log(" %s: %s", dim[i], units[i]->name);
		}
		bu_log("\n");
		break;
d287 7
d295 4
a298 4
	case '?'	:
	case 'h'	:
	default		: usage("Bad or help flag '%c' specified\n", c); break;
	}
d300 1
a300 1
    return(optind);
a302 5

/*
 *	parse_densities_buffer
 *
 */
a333 1

d348 1
a348 2
	    densities = bu_realloc(densities, sizeof(struct density_entry)*num_densities*2, 
				   "density entries");
d353 1
a353 4
	/* since BRL-CAD does computation in mm, but the table is
	 * in grams / (cm^3) we convert the table on input
	 */
	densities[idx].grams_per_cu_mm = density / 1000.0;
d359 1
a359 1
#ifdef PRINT_DENSITIES
d371 1
a371 2
/*	g e t _ d e n s i t i e s _ f r o m _ f i l e 
 *
a399 1

a400 2
 *	g e t _ d e n s i t i e s _ f r o m _ d a t a b a s e
 *
a434 2


a435 1
 *	add_unique_pair
d437 2
a438 2
struct region_pair *
add_unique_pair(struct region_pair *list, struct region *r1, struct region *r2, double dist, point_t pt)
d440 1
a440 40
    struct region_pair *rp, *rpair;

    /* look for it in our list */
    bu_semaphore_acquire( SEM_LIST );
    for( BU_LIST_FOR(rp, region_pair, &list->l) ) {

	if ( (r1 == rp->r1 && r2 == rp->r2) || (r1 == rp->r2 && r2 == rp->r1) ) {
	    /* we already have an entry for this region pair,
	     * we increase the counter, check the depth and
	     * update thickness maximum and entry point if need be
	     * and return.
	     */
	    rp->count++;
	    
	    if (dist > rp->max_dist) {
		rp->max_dist = dist;
		VMOVE(rp->coord, pt);
	    }
	    rpair = rp;
	    goto found;
	}
    }
    /* didn't find it in the list.  Add it */
    rpair = bu_malloc(sizeof(struct region_pair), "region_pair");
    rpair->r1 = r1;
    rpair->r2 = r2;
    rpair->count = 1;
    rpair->max_dist = dist;
    VMOVE(rpair->coord, pt);
    list->max_dist ++; /* really a count */

    /* insert in the list at the "nice" place */
    for( BU_LIST_FOR(rp, region_pair, &list->l) ) {
	if (strcmp(rp->r1->reg_name, r1->reg_name) <= 0 )
	    break;
    }
    BU_LIST_INSERT(&rp->l, &rpair->l);
 found:
    bu_semaphore_release( SEM_LIST );
    return rpair;
a443 1

d445 1
a445 1
 *			O V E R L A P
d447 2
a448 8
 *  Write end points of partition to the standard output.
 *  If this routine return !0, this partition will be dropped
 *  from the boolean evaluation.
 *
 *	Returns:
 *	 0	to eliminate partition with overlap entirely
 *	 1	to retain partition in output list, claimed by reg1
 *	 2	to retain partition in output list, claimed by reg2
d451 17
a467 2
overlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
{	
a468 12
    register struct xray	*rp = &ap->a_ray;
    register struct hit	*ihitp = pp->pt_inhit;
    register struct hit	*ohitp = pp->pt_outhit;
    point_t ihit;
    point_t ohit;
    double depth;

    /* if one of the regions is air, let it loose */
    if (reg1->reg_aircode && ! reg2->reg_aircode)
	return 2;
    if (reg2->reg_aircode && ! reg1->reg_aircode)
	return 1;
d470 1
a470 1
    depth = ohitp->hit_dist - ihitp->hit_dist;
d472 4
a475 3
    if( depth < overlap_tolerance ) {
	/* too small to matter, pick one or none */
	return(1);
d478 1
a478 200
    VJOIN1( ihit, rp->r_pt, ihitp->hit_dist, rp->r_dir );
    VJOIN1( ohit, rp->r_pt, ohitp->hit_dist, rp->r_dir );

    if (plot_fp) {
	pl_color(plot_fp, V3ARGS(overlap_color));
	pdv_3line(plot_fp, ihit, ohit);
    }

    if (analysis_flags & ANALYSIS_OVERLAPS) {
	struct region_pair *rp = 
	    add_unique_pair(&overlapList, reg1, reg2, depth, ihit);

	if (plot_fp) {
	    pl_color(plot_fp, V3ARGS(overlap_color));
	    pdv_3line(plot_fp, ihit, ohit);
	    pdv_3line(plot_fp, ihit, rp->coord);
	    pdv_3line(plot_fp, ohit, rp->coord);
	}
    } else {
	bu_log("overlap %s %s\n", reg1->reg_name, reg2->reg_name);
    }

    /* since we have no basis to pick one over the other, just pick */
    return(1);	/* No further consideration to this partition */
}

/*
 *	logoverlap
 *
 */
void
logoverlap(struct application *ap, const struct partition *pp, const struct bu_ptbl *regiontable, const struct partition *InputHdp)
{
    RT_CK_AP(ap);
    RT_CK_PT(pp);
    BU_CK_PTBL(regiontable);
    return;
}


/*
 *  rt_shootray() was told to call this on a hit.  He gives up the
 *  application structure which describes the state of the world
 *  (see raytrace.h), and a circular linked list of partitions,
 *  each one describing one in and out segment of one region.
 */
int
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
{
    /* see raytrace.h for all of these guys */
    register struct partition *pp;
    register struct hit *hitp;
    register struct soltab *stp;
    struct curvature cur;
    point_t		pt, last_out_point;
    vect_t		inormal;
    vect_t		onormal;
    int			last_air = 0; /* what was the aircode of the last item */
    int			air_first = 1; /* are we in an air before a solid */
    double	dist;	/* the thickness of the partition */
    double	last_out_dist;
    double	val;
    struct cstate *state = ap->a_uptr;

    /* examine each partition until we get back to the head */
    for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
	struct density_entry *de;

	/* inhit info */
	dist = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);


	/* checking for air sticking out of the model */
	if (analysis_flags & ANALYSIS_EXP_AIR && air_first) {
	    if (pp->pt_regionp->reg_aircode) {
		/* this shouldn't be air */
		bu_log("air %s before solid material on ray at %g %g %g\n",
		       pp->pt_regionp->reg_name, V3ARGS(pt) );
	    } else {
		air_first = 0;
	    }
	}

	/* looking for voids in the model */
	if (analysis_flags & ANALYSIS_GAP) {
	    if (pp->pt_back != PartHeadp) {
		/* if this entry point is further than the previous exit point
		 * then we have a void 
		 */
		double gap_dist = pp->pt_inhit->hit_dist - last_out_dist;
		if (gap_dist > overlap_tolerance) {

		    /* like overlaps, we only want to report unique pairs */
		    add_unique_pair(&gapList,
				    pp->pt_regionp,
				    pp->pt_back->pt_regionp, 
				    gap_dist,
				    pt);

		    /* like overlaps, let's plot */
		    if (plot_fp) {
			vect_t gapEnd;

			pl_color(plot_fp, V3ARGS(gap_color));
			VJOIN1(gapEnd, pt, gap_dist, ap->a_ray.r_dir);
			pdv_3line(plot_fp, pt, gapEnd);
		    }
		}
	    }
	}

	/* computing the weight of the objects */
	if (analysis_flags & ANALYSIS_WEIGHT) {
	    dlog("Hit %s doing weight\n", pp->pt_regionp->reg_name);
	    /* make sure mater index is within range of densities */
	    if (pp->pt_regionp->reg_gmater >= num_densities) {
		bu_log("density index %d on region %s is outside of range of table [1..%d]\n",
		       pp->pt_regionp->reg_gmater,
		       pp->pt_regionp->reg_name,
		       num_densities);
		bu_log("Set GIFTmater on region or add entry to density table\n");
		bu_bomb(""); /* XXX this should do something else */
	    } else {

		/* make sure the density index has been set */
		de = &densities[pp->pt_regionp->reg_gmater];
		if (de->magic == DENSITY_MAGIC) {
		    struct per_region_data *prd;


		    /* factor in the density of this object
		    /* weight computation, factoring in the LOS 
		     * percentage material of the object
		     */
		    int los = pp->pt_regionp->reg_los;

		    if (los < 1) {
			bu_log("bad LOS (%d) on %s\n", los, pp->pt_regionp->reg_name );
		    }

		    /* accumulate the total weight values */
		    val = de->grams_per_cu_mm * dist * (pp->pt_regionp->reg_los * 0.01);
		    ap->a_color[0] += val;

		    prd = ((struct per_region_data *)pp->pt_regionp->reg_udata);
		    /* accumulate the per-region per-view weight values */
		    prd->r_lenDensity[state->i_axis] += val;

		    /* accumulate the per-object per-view weight values */
		    prd->optr->o_lenDensity[state->i_axis] += val;

		} else {
		    bu_log("density index %d from region %s is not set.\nAdd entry to density table\n",
			   pp->pt_regionp->reg_gmater, pp->pt_regionp->reg_name);
		    bu_bomb("");
		}
	    }
	}

	/* compute the volume of the object */
	if (analysis_flags & ANALYSIS_VOLUME) {
	    struct per_region_data *prd = ((struct per_region_data *)pp->pt_regionp->reg_udata);
	    ap->a_color[1] += dist; /* add to total volume */

	    /* add to region volume */
	    prd->r_len[state->curr_view] += dist;

	    /* add to object volume */
	    prd->optr->o_len[state->curr_view] += dist;

	    dlog("\t\tvol hit %s oDist:%g objVol:%g %s\n",
		 pp->pt_regionp->reg_name,
		 dist,
		 prd->optr->o_len[state->curr_view], prd->optr->o_name);
	}


	/* look for two adjacent air regions */
	if (analysis_flags & ANALYSIS_ADJ_AIR) {
	    if (last_air && pp->pt_regionp->reg_aircode && pp->pt_regionp->reg_aircode != last_air) {

		add_unique_pair(&adjAirList, pp->pt_back->pt_regionp, pp->pt_regionp, 0.0, pt);
	    }
	}

	/* note that this region has been seen */
	((struct per_region_data *)pp->pt_regionp->reg_udata)->hits++;

	last_air = pp->pt_regionp->reg_aircode;
	last_out_dist = pp->pt_outhit->hit_dist;
	VJOIN1(last_out_point, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir);
    }


    if (analysis_flags & ANALYSIS_EXP_AIR && last_air) {
	bu_log("Air %s was last on ray at %g %g %g)\n",
	       PartHeadp->pt_back->pt_regionp->reg_name,
	       V3ARGS(last_out_point));
    }
d480 3
a482 662

    /*
     * This value is returned by rt_shootray
     * a hit usually returns 1, miss 0.
     */
    return(1);
}

/*
 * rt_shootray() was told to call this on a miss.
 */
int
miss(register struct application *ap)
{
#if 0
    bu_log("missed\n");
#endif
    return(0);
}

/*
 *	get_next_row
 *
 */
int
get_next_row(struct cstate *state)
{
    int v;
    /* look for more work */
    bu_semaphore_acquire(SEM_WORK);

    if (state->v < state->steps[state->v_axis])
	v = state->v++;	/* get a row to work on */
    else 
	v = 0; /* signal end of work */

    bu_semaphore_release(SEM_WORK);

    return v;
}
/*
 *	plane_worker 
 *
 */
void
plane_worker (int cpu, genptr_t ptr)
{
    struct application ap;
    int u, v;
    double v_coord;
    double z_coord;
    struct cstate *state = (struct cstate *)ptr;


    RT_APPLICATION_INIT(&ap);
    ap.a_rt_i = (struct rt_i *)state->rtip;	/* application uses this instance */
    ap.a_hit = hit;			/* where to go on a hit */
    ap.a_miss = miss;		/* where to go on a miss */
    ap.a_logoverlap = logoverlap;
    ap.a_overlap = overlap;
    ap.a_resource = &resource[cpu];
    ap.a_color[0] = 0.0; /* really the cumulative length*density */
    ap.a_color[1] = 0.0; /* really the cumulative length*density */

    /* gross hack */
    ap.a_ray.r_dir[state->u_axis] = ap.a_ray.r_dir[state->v_axis] = 0.0;
    ap.a_ray.r_dir[state->i_axis] = 1.0;

    ap.a_uptr = ptr; /* really copying the state ptr to the a_uptr */

    u = -1;

    while (v = get_next_row(state)) {

	v_coord = v * gridSpacing; 
	dlog("  v = %d v_coord=%g\n", v, v_coord);

	if ( state->first || (v&1) ) {
	    /* shoot all the rays in this row */
	    /* this is either the first time a view has been computed
	     * or it is an even numbered row in a grid refinement
	     */
	    for (u=1 ; u < state->steps[state->u_axis]; u++) {
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u * gridSpacing;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v * gridSpacing;
		ap.a_ray.r_pt[state->i_axis] = ap.a_rt_i->mdl_min[state->i_axis];

		dlog("%5g %5g %5g -> %g %g %g\n", V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));
		(void)rt_shootray( &ap );
		state->shots[state->curr_view]++;
	    }
	} else {
	    /* shoot only the rays we need to on this row.
	     * Some of them have been computed in a previous iteration.
	     */
	    for (u=1 ; u < state->steps[state->u_axis]; u+=2) {
		ap.a_ray.r_pt[state->u_axis] = ap.a_rt_i->mdl_min[state->u_axis] + u * gridSpacing;
		ap.a_ray.r_pt[state->v_axis] = ap.a_rt_i->mdl_min[state->v_axis] + v * gridSpacing;
		ap.a_ray.r_pt[state->i_axis] = ap.a_rt_i->mdl_min[state->i_axis];

		dlog("%5g %5g %5g -> %g %g %g\n", V3ARGS(ap.a_ray.r_pt), V3ARGS(ap.a_ray.r_dir));
		(void)rt_shootray( &ap );
		state->shots[state->curr_view]++;

		if (debug)
		    if (u+1 <  state->steps[state->u_axis])
			bu_log("  ---\n");
	    }
	}
    }

    if (u == -1) {
	dlog("didn't shoot any rays\n");
    }

    /* There's nothing else left to work on in this view.
     * It's time to add the values we have accumulated 
     * to the totals for the view and return.  When all 
     * threads have been through here, we'll have returned
     * to serial computation.
     */
    bu_semaphore_acquire(SEM_WORK);
    state->m_lenDensity[state->curr_view] += ap.a_color[0]; /* add our length*density value */
    state->m_len[state->curr_view] += ap.a_color[1]; /* add our volume value */
    bu_semaphore_release(SEM_WORK);
}

/*
 *
 */
int
find_cmd_line_obj(struct per_obj_data *obj_rpt, const char *name)
{
    int i;
    char *str = strdup(name);
    char *p;

    if (p=strchr(str, '/')) *p = '\0';

    for (i=0 ; i < num_objects ; i++) {
	if (!strcmp(obj_rpt[i].o_name, str)) {
	    bu_free(str, "");
	    return i;
	}
    }
    bu_log("%s Didn't find object named \"%s\" in %d entries\n", BU_FLSTR, name, num_objects);
    bu_bomb("");
}

/* 
 * allocate_per_reigon_data
 *
 *	Allocate data structures for tracking statistics on a per-view basis
 *	for each of the view, object and region levels.
 */
void
allocate_per_reigon_data(struct cstate *state, int start, int ac, char *av[])
{
    struct region *regp;
    struct rt_i *rtip = state->rtip;
    int i;
    int m;

    state->m_lenDensity = bu_calloc(sizeof(double), num_views, "densityLen");
    state->m_len = bu_calloc(sizeof(double), num_views, "volume");
    state->m_volume = bu_calloc(sizeof(double), num_views, "volume");
    state->m_weight = bu_calloc(sizeof(double), num_views, "volume");
    state->shots = bu_calloc(sizeof(unsigned long), num_views, "volume");

    /* build data structures for the list of
     * objects the user specified on the command line
     */
    obj_tbl = bu_calloc(sizeof(struct per_obj_data), num_objects, "report tables");
    for (i=0 ; i < num_objects ; i++) {
	obj_tbl[i].o_name = av[start+i];
	obj_tbl[i].o_len = bu_calloc(sizeof(double), num_views, "o_len");
	obj_tbl[i].o_lenDensity = bu_calloc(sizeof(double), num_views, "o_lenDensity");
	obj_tbl[i].o_volume = bu_calloc(sizeof(double), num_views, "o_volume");
	obj_tbl[i].o_weight = bu_calloc(sizeof(double), num_views, "o_weight");
    }

    /* build objects for each region */
    reg_tbl = bu_calloc(rtip->nregions, sizeof(struct per_region_data), "per_region_data");

    
    for( i=0 , BU_LIST_FOR( regp, region, &(rtip->HeadRegion) ) , i++)  {
	regp->reg_udata = &reg_tbl[i];

	reg_tbl[i].r_lenDensity = bu_calloc(sizeof(double), num_views, "r_lenDensity");
	reg_tbl[i].r_len = bu_calloc(sizeof(double), num_views, "r_len");
	reg_tbl[i].r_volume = bu_calloc(sizeof(double), num_views, "len");
	reg_tbl[i].r_weight = bu_calloc(sizeof(double), num_views, "len");

	m = strlen(regp->reg_name);
	if (m > max_region_name_len) max_region_name_len = m;
	reg_tbl[i].optr = &obj_tbl[ find_cmd_line_obj(obj_tbl, &regp->reg_name[1]) ];

    }
}




/*
 *	list_report
 *
 */
void
list_report(struct region_pair *list)
{
    struct region_pair *rp;

    if (BU_LIST_IS_EMPTY(&list->l)) {
	bu_log("No %s\n", (char *)list->r1);
	return;
    }

    bu_log("list %s:\n", (char *)list->r1);

    for (BU_LIST_FOR(rp, region_pair, &overlapList.l)) {
	if (rp->r2) {
	    bu_log("%s %s %lu %g (%g %g %g)\n",
	       rp->r1->reg_name, rp->r2->reg_name, rp->count,
	       rp->max_dist, V3ARGS(rp->coord));
	} else {
	    bu_log("%s %lu %g (%g %g %g)\n",
	       rp->r1->reg_name, rp->count,
	       rp->max_dist, V3ARGS(rp->coord));
	}
    }
}






/*
 *	options_prep
 *
 *	Do some computations prior to raytracing based upon
 *	options the user has specified
 *
 *	Returns:
 *		0	continue, ready to go
 *		!0	error encountered, terminate processing
 */
int
options_prep(struct rt_i *rtip, vect_t span)
{
    double newGridSpacing = gridSpacing;
    int axis;

    /* figure out where the density values are comming from and get them */
    if (analysis_flags & ANALYSIS_WEIGHT) {
	if (densityFileName) {
	    dlog("density from file\n");
	    if (get_densities_from_file(densityFileName)) {
		return -1;
	    }
	} else {
	    dlog("density from db\n");
	    if (get_densities_from_database(rtip)) {
		return -1;
	    }
	}
    }
    /* refine the grid spacing if the user has set a 
     * lower bound on the number of rays per model axis 
     */
    for (axis=0 ; axis < 3 ; axis++) {
	if (span[axis] < newGridSpacing*Samples_per_model_axis) {
	    /* along this axis, the gridSpacing is 
	     * larger than the model span.  We need to refine.
	     */
	    newGridSpacing = span[axis] / Samples_per_model_axis;
	}
    }

    if (newGridSpacing != gridSpacing) {
	bu_log("Grid spacing %g %s is does not allow %g samples per axis\n",
	       gridSpacing / units[LINE]->val, units[LINE]->name, Samples_per_model_axis - 1);

	bu_log("Adjusted to %g %s to get %g samples per model axis\n",
	       newGridSpacing / units[LINE]->val, units[LINE]->name, Samples_per_model_axis);

	gridSpacing = newGridSpacing;
    }

    /* if the vol/weight tolerances are not set, pick something */
    if (analysis_flags & ANALYSIS_VOLUME) {
	if (volume_tolerance == -1.0) {
	    volume_tolerance = span[X] * span[Y] * span[Z] * 0.001;
	    bu_log("setting volume tolerance to %g %s\n", volume_tolerance / units[VOL]->val, units[VOL]->name);
	} else {
	    bu_log("volume tolerance   %g\n", volume_tolerance);
	}
    }
    if (analysis_flags & ANALYSIS_WEIGHT) {
	if (weight_tolerance == -1.0) {
	    struct density_entry *de;
	    double max_den = 0.0;
	    int i;
	    for (i=0 ; i < num_densities ; i++) {
		if (densities[i].grams_per_cu_mm > max_den)
		    max_den = densities[i].grams_per_cu_mm;
	    }
	    weight_tolerance = span[X] * span[Y] * span[Z] * 0.1 * max_den;
	    bu_log("setting weight tolerance to %g %s\n",
		   weight_tolerance / units[WGT]->val,
		   units[WGT]->name);
	} else {
	    bu_log("weight tolerance   %g\n", weight_tolerance);
	}
    }
    if (analysis_flags & ANALYSIS_OVERLAPS) {
	if (overlap_tolerance != 0.0) {
	    bu_log("overlap tolerance to %g\n", overlap_tolerance);
	}
	if ( (plot_fp=fopen("overlaps.pl", "w")) == (FILE *)NULL) {
	    bu_log("cannot open plot file\n");
	    bu_bomb("");
	}
    }
    return 0;
}

/*
 *	view_reports
 *
 */
void
view_reports(struct cstate *state)
{
    state->curr_view;
    if (analysis_flags & ANALYSIS_VOLUME) {
	int obj;
	int view;

	/* for each object, compute the volume for all views */
	for (obj=0 ; obj < num_objects ; obj++) {
	    double val;
	    /* compute volume of object for given view */
	    view = state->curr_view;

	    /* compute the per-view volume of this object */

	    if (state->shots[view] > 0) {
		val = obj_tbl[obj].o_volume[view] = 
		    obj_tbl[obj].o_len[view] * (state->area[view] / state->shots[view]);

		if (verbose)
		    bu_log("\t%s volume %g %s\n", 
		       obj_tbl[obj].o_name,
		       val / units[VOL]->val,
		       units[VOL]->name);
	    }
	}
    }
    if (analysis_flags & ANALYSIS_WEIGHT) {
	int obj;
	int view = state->curr_view;

	for (obj=0 ; obj < num_objects ; obj++) {
	    double grams_per_cu_mm = obj_tbl[obj].o_lenDensity[view] *
		(state->area[view] / state->shots[view]);


		if (verbose)
		    bu_log("\t%s %g %s\n",
			   obj_tbl[obj].o_name,
			   grams_per_cu_mm / units[WGT]->val,
			   units[WGT]->name);
	}
    }
}


/*
 *	t e r m i n a t e _ c h e c k
 *
 *	Check to see if we are done processing due to 
 *	some user specified limit being achieved.
 *
 *	Returns:
 *	0	Terminate
 *	1	Continue processing
 */
int 
terminate_check(struct cstate *state)
{
    double low, hi, val, delta;
    int axis;
    struct region *regp;
    unsigned long hits;
    int can_terminate = 1; /* assume everyone is within tolerance */
    int obj;
    int view;

    dlog("terminate_check\n");
    RT_CK_RTI(state->rtip);
    /* check to make sure every region was hit at least once */
    for( BU_LIST_FOR( regp, region, &(state->rtip->HeadRegion) ) )  {
	RT_CK_REGION(regp);

	hits = ((struct per_region_data *)regp->reg_udata)->hits;
	if ( hits < require_num_hits) {
	    if (verbose) {
		if (hits == 0) {
		    bu_log("%s was not hit\n", regp->reg_name);
		} else {
		    bu_log("%s hit only %u times (< %u)\n",
			   regp->reg_name, hits, require_num_hits);
		}
	    }

	    return 1;
	}
    }

    if (analysis_flags & ANALYSIS_WEIGHT) {
	/* for each object, compute the weight for all views */

	for (obj=0 ; obj < num_objects ; obj++) {
	    if (verbose)
		bu_log("object %d\n", obj); 
	    /* compute weight of object for given view */
	    view = 0;
	    val = obj_tbl[obj].o_weight[view] =
		obj_tbl[obj].o_lenDensity[view] * (state->area[view] / state->shots[view]);

	    low = hi = 0.0;

	    /* compute the per-view weight of this object */
	    for (view=1 ; view < num_views ; view++) {
		obj_tbl[obj].o_weight[view] =
		    obj_tbl[obj].o_lenDensity[view] * 
		    (state->area[view] / state->shots[view]);

		delta = val - obj_tbl[obj].o_weight[view];
		if (delta < low) low = delta;
		if (delta > hi) hi = delta;
	    }
	    delta = hi - low;

	    if (verbose)
		bu_log("\t%s weight %g %s +%g -%g\n",
		   obj_tbl[obj].o_name,
		   val / units[WGT]->val,
		   units[WGT]->name,
		   fabs(hi / units[WGT]->val),
		   fabs(low / units[WGT]->val));

	    if (delta > weight_tolerance) {
		/* this object differs too much in each view, so we need to refine the grid */
		can_terminate = 0;
		if (verbose)
		    bu_log("\t%s differs too much in weight per view.\n", 
		       obj_tbl[obj].o_name);
	    }
	}
	if (can_terminate) {
	    if (verbose)
		bu_log("all objects within tolerance on weight calculation\n");
	}
    }
    if (analysis_flags & ANALYSIS_VOLUME) {
	/* find the range of values for object volumes */
	can_terminate = 1; /* assume everyone is within tolerance */

	/* for each object, compute the volume for all views */
	for (obj=0 ; obj < num_objects ; obj++) {

	    /* compute volume of object for given view */
	    view = 0;
	    val = obj_tbl[obj].o_volume[view] = obj_tbl[obj].o_len[view] * (state->area[view] / state->shots[view]);

	    low = hi = 0.0;
	    /* compute the per-view volume of this object */
	    for (view=1 ; view < num_views ; view++) {
		obj_tbl[obj].o_volume[view] = 
		    obj_tbl[obj].o_len[view] * (state->area[view] / state->shots[view]);

		delta = val - obj_tbl[obj].o_volume[view];
		if (delta < low) low = delta;
		if (delta > hi) hi = delta;
	    }
	    delta = hi - low;

	    if (verbose)
		bu_log("\t%s volume %g %s +(%g) -(%g)\n",
		   obj_tbl[obj].o_name,
		   val / units[VOL]->val, units[VOL]->name,
		   hi / units[VOL]->val,
		   low / units[VOL]->val);

	    if (delta > volume_tolerance) {
		/* this object differs too much in each view, so we need to refine the grid */
		can_terminate = 0;
		if (verbose)
		    bu_log("\tvolume tol not met on %s.  Refine grid\n",
			   obj_tbl[obj].o_name);
		break;
	    }
	}

    }

    if (can_terminate) {
	if (verbose)
	    bu_log("refining estimates\n");
	return 0;
    }

    if ( (analysis_flags & ANALYSIS_OVERLAPS)) {
	if (BU_LIST_NON_EMPTY(&overlapList.l) && gridSpacing < gridSpacingLimit*4) {
	    /* since we've found an overlap, we can quit */
	    return 0;
	}
    }
    if ( (analysis_flags & ANALYSIS_GAP)) {
	if (BU_LIST_NON_EMPTY(&gapList.l)) {
	    /* since we've found a gap, we can quit */
	    return 0;
	}
    }
    if ( (analysis_flags & ANALYSIS_ADJ_AIR)) {
	if (BU_LIST_NON_EMPTY(&adjAirList.l)) {
	    /* since we've found adjacent air, we can quit */
	    return 0;
	}
    }
    if ( (analysis_flags & ANALYSIS_EXP_AIR)) {
	if (BU_LIST_NON_EMPTY(&exposedAirList.l)) {
	    /* since we've found exposed air, we can quit */
	    return 0;
	}
    }
    /* refine the gridSpacing and try again */
    if (gridSpacing < gridSpacingLimit) {
	if (verbose)
	    bu_log("grid spacing refined to %g (below lower limit %g)\n", 
		   gridSpacing, gridSpacingLimit);
	return 0;
    }

    return 1;
}	


/*
 *	summary_reports
 *
 */
void
summary_reports(struct cstate *state, int start, int ac, char *av[])
{
    int view;
    double v;
    int obj;
    double avg;


    if (multiple_analysis)
	bu_log("Summaries:\n");
    else
	bu_log("Summary:\n");
	
    if (analysis_flags & ANALYSIS_WEIGHT) {
	bu_log("Weight:\n");
	for (obj=0 ; obj < num_objects ; obj++) {
	    avg = 0.0;

	    for (view=0 ; view < num_views ; view++) {
		/* computed in terminate_check() */
		avg += obj_tbl[obj].o_weight[view]; 
	    }
	    avg /= num_views;
	    bu_log("\t%*s %g %s\n", -max_region_name_len, obj_tbl[obj].o_name,
		   avg / units[WGT]->val, units[WGT]->name);
	}
	/* print grand totals */
	avg = 0.0;
	v = 0.0;
	for (view=0 ; view < num_views ; view++) {
	    avg += state->m_weight[view] = 
		state->m_lenDensity[view] * 
		( state->area[view] / state->shots[view]);
	}

	avg /= num_views;
	bu_log("  Average total weight: %g %s\n", avg / units[WGT]->val, units[WGT]->name);
    }
    if (analysis_flags & ANALYSIS_VOLUME) {

	/* print per-object */
	for (obj=0 ; obj < num_objects ; obj++) {
	    avg = 0.0;

	    for (view=0 ; view < num_views ; view++)
		avg += obj_tbl[obj].o_volume[view];

	    avg /= num_views;
	    bu_log("\t%*s %g %s\n", -max_region_name_len, obj_tbl[obj].o_name,
		   avg / units[VOL]->val, units[VOL]->name);
	}
	/* print grand totals */
	avg = 0.0;
	v = 0.0;
	for (view=0 ; view < num_views ; view++) {
	    avg += state->m_volume[view] = state->m_len[view] * ( state->area[view] / state->shots[view]);
	}

	avg /= num_views;
	bu_log("  Average total volume: %g %s\n", avg / units[VOL]->val, units[VOL]->name);
    }
    if (analysis_flags & ANALYSIS_OVERLAPS) list_report(&overlapList);
    if (analysis_flags & ANALYSIS_ADJ_AIR)  list_report(&adjAirList);
    if (analysis_flags & ANALYSIS_GAP) list_report(&gapList);
    if (analysis_flags & ANALYSIS_EXP_AIR) list_report(&exposedAirList);
}

/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int
main(ac,av)
     int ac;
     char *av[];
{
    int arg_count;
    FILE *inp;
    int status;
    struct rt_i *rtip;
    int u_axis, v_axis, i_axis;
    long u, v;
    char idbuf[132];
    vect_t origin;
    vect_t dir;
    int i;
    struct directory *dp;
    struct cstate state;
    double lim, val;
    int crv;
    int start_objs; /* index in command line args where geom object list starts */

    max_cpus = ncpu = bu_avail_cpus();

    /* parse command line arguments */
    arg_count = parse_args(ac, av);
	
    if ((ac-arg_count) < 2) {
	usage("Error: Must specify model and objects on command line\n");
    }

    bu_semaphore_init(RT_SEM_LAST+2);

    rt_init_resource( &rt_uniresource, max_cpus, NULL );
    bn_rand_init( rt_uniresource.re_randptr, 0 );
a493 7
    rtip->useair = use_air;

    /* XXX set the default linear units if the user hasn't specified them on the command line */


    start_objs = ++arg_count;
    num_objects = ac - arg_count;
d495 11
d511 1
a511 1
    for ( ; arg_count < ac ; arg_count++ )  {
d520 1
a520 1
    for( i=0; i < max_cpus; i++ )  {
d529 2
a530 1
    rt_prep_parallel(rtip,ncpu);
d535 6
a540 4
    VSUB2(state.span, rtip->mdl_max, rtip->mdl_min);
    state.area[0] = state.span[1] * state.span[2];
    state.area[1] = state.span[2] * state.span[0];
    state.area[2] = state.span[0] * state.span[1];
d542 2
a543 2
    if (analysis_flags & ANALYSIS_BOX) {
	bu_log("bounding box: %g %g %g  %g %g %g\n", V3ARGS(rtip->mdl_min), V3ARGS(rtip->mdl_max));
d545 1
a545 3
	VPRINT("Area:", state.area);
    }
    bu_log("ncpu: %d\n", ncpu);
d547 1
d549 1
a549 1
    if (options_prep(rtip, state.span)) return -1;
d551 9
d561 4
a564 3
    if ( (analysis_flags & (ANALYSIS_ADJ_AIR|ANALYSIS_EXP_AIR)) && ! use_air ) {
	bu_bomb("Error:  Air regions discarded but air analysis requested!\nSet use_air non-zero or eliminate air analysis\n");
    }
d566 4
a569 4
    /* initialize some stuff */
    state.rtip = rtip;
    state.first = 1;
    allocate_per_reigon_data(&state, start_objs, ac, av);
d571 4
a574 35
    /* compute */
    do {
	double inv_spacing = 1.0/gridSpacing;
	int view;

	VSCALE(state.steps, state.span, inv_spacing);

	bu_log("grid spacing %gmm  %d x %d x %d\n", gridSpacing,
	       state.steps[0]-1,
	       state.steps[1]-1,
	       state.steps[2]-1);


	for (view=0 ; view < num_views ; view++) {

	    if (verbose)
		bu_log("  view %d\n", view);

	    /* gross hack
	     * By assuming we have <= 3 views, we can let the view # indicate
	     * a coordinate axis.
	     *  Note this is used as an index into state.area[] 
	     */
	    state.i_axis = state.curr_view = view;
	    state.u_axis = (state.curr_view+1) % 3;
	    state.v_axis = (state.curr_view+2) % 3;

	    state.u_dir[state.u_axis] = 1;
	    state.u_dir[state.v_axis] = 0;
	    state.u_dir[state.i_axis] = 0;

	    state.v_dir[state.u_axis] = 0;
	    state.v_dir[state.v_axis] = 1;
	    state.v_dir[state.i_axis] = 0;
	    state.v = 1;
d576 4
a579 2
	    bu_parallel(plane_worker, ncpu, (genptr_t)&state);
	    view_reports(&state);
d581 3
a583 1
	}
d585 2
a586 2
	state.first = 0;
	gridSpacing *= 0.5;
d588 2
a589 1
    } while (terminate_check(&state));
d591 1
a591 3
    if (verbose)
	bu_log("Computation Done\n");
    summary_reports(&state, start_objs, ac, av);
d593 1
a593 1
    return(0);
@


