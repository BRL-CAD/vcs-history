head	14.21;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.6
	rel-7-10-2:14.15
	rel-7-10-0:14.13
	rel-7-8-4:14.9
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.7
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.6
	rel-7-6-0:14.6
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.4
	bobWinPort:14.6.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.21
date	2007.12.16.15.59.37;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.12.14.20.53.28;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.11.21.20.49.08;	author erikgreenwald;	state Exp;
branches;
next	14.18;

14.18
date	2007.11.21.20.38.22;	author erikgreenwald;	state Exp;
branches;
next	14.17;

14.17
date	2007.11.21.19.28.06;	author erikgreenwald;	state Exp;
branches;
next	14.16;

14.16
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.05.14.21.04.30;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.04.16.21.15.36;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.02.02.08.48.29;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.27.01.41.34;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.32;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.36.49;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.12.02.21.08.20;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.37;	author brlcad;	state Exp;
branches
	14.6.6.1;
next	14.5;

14.5
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.44.32;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.20.20.21.31;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.09;	author morrison;	state Exp;
branches;
next	;

14.6.6.1
date	2005.11.13.13.46.14;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.21
log
@convert all bzero calls to memset
@
text
@/*                        G _ L I N T . C
 * BRL-CAD
 *
 * Copyright (c) 1995-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file g_lint.c
 *
 *	Sample some BRL-CAD geometry, reporting overlaps
 *	and potential problems with air regions.
 *
 *  Author -
 *	Paul Tanenbaum
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.20 2007/12/14 20:53:28 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <limits.h>			/* home of INT_MAX aka MAXINT */

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "plot3.h"

#define made_it()	bu_log("Made it to %s:%d\n", __FILE__, __LINE__);

#define	OPT_STRING	"a:ce:g:opr:st:ux:?"
#define	RAND_NUM	((fastf_t)random()/INT_MAX)
#define	RAND_OFFSET	((1 - cell_center) *		\
			 (RAND_NUM * celsiz - celsiz / 2))
#define	TITLE_LEN	80

/*
 *			G _ L I N T _ C T R L
 *
 *	Specification of what an how to report results
 */
struct g_lint_ctrl
{
    long		glc_magic;	/* Magic no. for integrity check */
    long		glc_debug;	/* Bits to tailor diagnostics */
    fastf_t		glc_tol;	/* Overlap/void tolerance */
    unsigned long	glc_what_to_report;	/* Bits to tailor the output */
    unsigned long	glc_how_to_report;	/* Nature of the output */
    FILE		*glc_fp;	/* The output stream */
    unsigned char	*glc_color;	/* RGB for plot3(5) output */
};
#define G_LINT_CTRL_NULL	((struct g_lint_ctrl *) 0)
#define G_LINT_CTRL_MAGIC	0x676c6374
/*
 *	The meanings of the bits in the what-to-report
 *	member of the g_lint_ctrl structure
 */
#define	G_LINT_OVLP	0x001
#define	G_LINT_A_CONT	0x002
#define	G_LINT_A_UNCONF	0x004
#define	G_LINT_A_1ST	0x008
#define	G_LINT_A_LAST	0x010
#define	G_LINT_A_ANY	(G_LINT_A_CONT | G_LINT_A_UNCONF |	\
			 G_LINT_A_1ST  | G_LINT_A_LAST)
#define	G_LINT_VAC	0x020
#define	G_LINT_ALL	(G_LINT_OVLP | G_LINT_A_ANY | G_LINT_VAC)
/*
 *	The possible values of the how-to-report flag
 */
#define	G_LINT_ASCII			0
#define	G_LINT_ASCII_WITH_ORIGIN	1
#define	G_LINT_PLOT3			2

/*
 *			G _ L I N T _ S E G
 *
 *	The critical information about a particular overlap
 *	found on one ray
 */
struct g_lint_seg
{
    long		gls_magic;	/* Magic no. for integrity check */
    double		gls_length;
    point_t		gls_origin;
    point_t		gls_entry;
    point_t		gls_exit;
    struct g_lint_seg	*gls_next;
};
#define	G_LINT_SEG_NULL		((struct g_lint_seg *) 0)
#define G_LINT_SEG_MAGIC	0x676c7367

/*
 *			G _ L I N T _ O V L P
 *
 *	A pair of overlapping regions and a list of all the
 *	offending ray intervals
 */
struct g_lint_ovlp
{
    long		glo_magic;	/* Magic no. for integrity check */
    struct region	*glo_r1;
    struct region	*glo_r2;
    struct g_lint_seg	*glo_segs;
    struct g_lint_seg	*glo_seg_last;
    double		glo_cum_length;
};
#define	G_LINT_OVLP_NULL	((struct g_lint_ovlp *) 0)
#define G_LINT_OVLP_MAGIC	0x676c6f76

static unsigned char	dflt_plot_rgb[] =
			{
			    255,   0,   0,	/* overlap */
			    255, 255,   0,	/* air_contiguous */
			      0, 255,   0,	/* air_unconfined */
			    255,   0, 255,	/* air_first */
			      0, 255, 255,	/* air_last */
			    128, 128, 128	/* vacuum */
			};

bu_rb_tree		*ovlp_log = 0;		/* Log of previous overlaps */
bu_rb_tree		*ovlps_by_vol;		/* For sorting by volume */

int log_2 (unsigned long x)
{
    int	result;

    for (result = 0; x > 1; ++result)
	x >>= 1;
    return (result);
}

/*
 *	The usage message -- it's a long 'un
 */
static char	*usage[] = {
    "Usage: 'g_lint [options] model.g object ...'\n",
    "Options:\n",
    "  -a azim      View target from azimuth of azim (0.0 degrees)\n",
    "  -c           Fire rays from center of grid cell (random point)\n",
    "  -e elev      View target from elevation of elev (0.0 degrees)\n",
    "  -g gridsize  Use grid-cell spacing of gridsize (100.0 mm)\n",
    "  -o           Include ray-origin on each line\n",
    "  -p           Produce plot3(5) output\n",
    "  -r bits      Set report-specification flag=bits...\n",
    "                  1  overlaps\n",
    "                  2  contiguous unlike airs\n",
    "                  4  unconfined airs\n",
    "                  8  air first on shotlines\n",
    "                 16  air last on shotlines\n",
    "                 32  vacuums\n",
    "  -s           Sort overlaps (report without sorting)\n",
    "  -t tol       Ignore overlaps/voids of length < tol (0.0 mm)\n",
    "  -u           Report on air (overlaps only)\n",
    "  -x bits      Set diagnostic flag=bits\n",
    0
};

/*			P R I N T U S A G E ( )
 *
 *	Reports a usage message on stderr.
 */
void printusage (void)
{
    char	**u;

    for (u = usage; *u != 0; ++u)
	bu_log("%s", *u);
}

/*
 *		C R E A T E _ S E G M E N T ( )
 */
struct g_lint_seg *create_segment (void)
{
    struct g_lint_seg	*sp;

    sp = bu_malloc(sizeof(struct g_lint_seg), "g_lint segment structure");
    sp -> gls_magic = G_LINT_SEG_MAGIC;
    sp -> gls_length = -1.0;
    sp -> gls_next = G_LINT_SEG_NULL;

    return (sp);
}

/*
 *		P R I N T _ S E G M E N T ( )
 *
 *	This routine writes one overlap segent to stdout.
 *	It's the workhorse of the reporting process for overlaps.
 */
void print_segment (const char *r1name, const char *r2name, double seg_length, point_t origin, point_t entrypt, point_t exitpt)
{
    printf("overlap ");
    if (origin)
	printf("%g %g %g ", V3ARGS(origin));
    printf("%s %s %g    %g %g %g    %g %g %g\n",
	r1name, r2name, seg_length, V3ARGS(entrypt), V3ARGS(exitpt));
}

/*
 *		C R E A T E _ O V E R L A P ( )
 */
struct g_lint_ovlp *create_overlap (struct region *r1, struct region *r2)
{
    struct g_lint_ovlp	*op;

    BU_CKMAG(r1, RT_REGION_MAGIC, "region structure");
    BU_CKMAG(r2, RT_REGION_MAGIC, "region structure");

    op = bu_malloc(sizeof(struct g_lint_ovlp), "g_lint overlap structure");
    op -> glo_magic = G_LINT_OVLP_MAGIC;
    op -> glo_cum_length = 0.0;
    op -> glo_segs = op -> glo_seg_last = G_LINT_SEG_NULL;

    if (r1 < r2)
    {
	op -> glo_r1 = r1;
	op -> glo_r2 = r2;
    }
    else if (r1 > r2)
    {
	op -> glo_r1 = r2;
	op -> glo_r2 = r1;
    }
    else
    {
	bu_log("%s:%d: Self-overlap of region '%s' (ox%x)\n",
	    __FILE__, __LINE__, r1 -> reg_name, r1);
	bu_exit (1, "This shouldn't happen\n");
    }

    return (op);
}

/*
 *		F R E E _ O V E R L A P ( )
 */
void free_overlap (struct g_lint_ovlp *op)
{
    BU_CKMAG(op, G_LINT_OVLP_MAGIC, "g_lint overlap structure");

    /*
     *		XXX	Oughta do something cleaner than what follows...
     */
    if (op -> glo_segs != G_LINT_SEG_NULL)
	bu_log("%s:%d: Memory Leak!\n", __FILE__, __LINE__);

    memset((void *) op, 0, sizeof(struct g_lint_ovlp));
    bu_free((genptr_t) op, "g_lint overlap structure");
}

/*
 *		_ P R I N T _ O V E R L A P ( )
 *
 *	The call-back for finally outputting data
 *	for all the overlap segments between any two regions.
 */
void _print_overlap (void *v, int show_origin)
{
    const char		*r1name, *r2name;
    struct g_lint_ovlp	*op = (struct g_lint_ovlp *) v;
    struct g_lint_seg	*sp;

    BU_CKMAG(op, G_LINT_OVLP_MAGIC, "g_lint overlap structure");
    BU_CKMAG(op -> glo_r1, RT_REGION_MAGIC, "region structure");
    BU_CKMAG(op -> glo_r2, RT_REGION_MAGIC, "region structure");

    r1name = op -> glo_r1 -> reg_name;
    r2name = op -> glo_r2 -> reg_name;
    for (sp = op -> glo_segs; sp != G_LINT_SEG_NULL; sp = sp -> gls_next)
	print_segment(r1name, r2name,
	    sp -> gls_length,
	    show_origin ?  sp -> gls_origin : 0,
	    sp -> gls_entry, sp -> gls_exit);
}

/*
 *		P R I N T _ O V E R L A P ( )
 *
 *	A wrapper for _print_overlap()
 *	for use when you don't want to print the ray origin.
 */
void print_overlap (void *v, int depth)
{
    _print_overlap(v, 0);
}

/*
 *		P R I N T _ O V E R L A P _ O ( )
 *
 *	A wrapper for _print_overlap()
 *	for use when you do want to print the ray origin.
 */
void print_overlap_o (void *v, int depth)
{
    _print_overlap(v, 1);
}

/*
 *		C O M P A R E _ O V E R L A P S ( )
 *
 *	    The red-black-tree comparison callback for the overlap log
 */
int compare_overlaps (void *v1, void *v2)
{
    struct g_lint_ovlp	*o1 = (struct g_lint_ovlp *) v1;
    struct g_lint_ovlp	*o2 = (struct g_lint_ovlp *) v2;

    BU_CKMAG(o1, G_LINT_OVLP_MAGIC, "g_lint overlap structure");
    BU_CKMAG(o2, G_LINT_OVLP_MAGIC, "g_lint overlap structure");

    if (o1 -> glo_r1 < o2 -> glo_r1)
	return (-1);
    else if (o1 -> glo_r1 > o2 -> glo_r1)
	return (1);
    else if (o1 -> glo_r2 < o2 -> glo_r2)
	return (-1);
    else if (o1 -> glo_r2 > o2 -> glo_r2)
	return (1);
    else
	return (0);
}

/*
 *		C O M P A R E _ B Y _ V O L ( )
 *
 *	    The red-black-tree comparison callback for
 *	    the final re-sorting of the overlaps by volume
 */
int compare_by_vol (void *v1, void *v2)
{
    struct g_lint_ovlp	*o1 = (struct g_lint_ovlp *) v1;
    struct g_lint_ovlp	*o2 = (struct g_lint_ovlp *) v2;

    BU_CKMAG(o1, G_LINT_OVLP_MAGIC, "g_lint overlap structure");
    BU_CKMAG(o2, G_LINT_OVLP_MAGIC, "g_lint overlap structure");

    if (o1 -> glo_cum_length < o2 -> glo_cum_length)
	return (1);
    else if (o1 -> glo_cum_length > o2 -> glo_cum_length)
	return (-1);
    else
	return (0);
}

/*
 *		I N S E R T _ B Y _ V O L ( )
 *
 *	The call-back, used in traversing the overlap log,
 *	to insert overlaps into the sorted-by-volume tree.
 */
void insert_by_vol (void *v, int depth)
{
    int			rc;	/* Return code from bu_rb_insert() */
    struct g_lint_ovlp	*op = (struct g_lint_ovlp *) v;

    if( (rc = bu_rb_insert(ovlps_by_vol, (void *) op)))
	bu_exit (1, "%s:%d: bu_rb_insert() returns %d:  This should not happen\n",
	    __FILE__, __LINE__, rc);
}

/*
 *		U P D A T E _ O V L P _ L O G ( )
 *
 *		Log an overlap found along a ray.
 *
 *	If regions r1 and r2 were not already known to overlap,
 *	this routine creates a new entry in the overlap log.
 *	Either way, it then modifies their entry to record this
 *	particular find.
 */
void update_ovlp_log (struct region *r1, struct region *r2, double seg_length, fastf_t *origin, fastf_t *entrypt, fastf_t *exitpt)
{
    int			rc;	/* Return code from bu_rb_insert() */
    struct g_lint_ovlp	*op;
    struct g_lint_seg	*sp;

    /*
     *	Prepare an overlap query
     */
    op = create_overlap (r1, r2);

    /*
     *	Add this overlap, if necessary.
     *	Either way, op will end up pointing to the unique
     *	(struct g_lint_ovlp) for regions r1 and r2.
     */
    if ((rc = bu_rb_insert(ovlp_log, (void *) op)) < 0)
    {
	free_overlap(op);
	op = (struct g_lint_ovlp *) bu_rb_curr1(ovlp_log);
    }
    else if (rc > 0)
	bu_exit (1, "%s:%d: bu_rb_insert() returns %d:  This should not happen\n",
	    __FILE__, __LINE__, rc);

    /*
     *	Fill in a new segment structure and add it to the overlap
     */
    sp = create_segment();
    op -> glo_cum_length += (sp -> gls_length = seg_length);
    VMOVE(sp -> gls_origin, origin);
    VMOVE(sp -> gls_entry, entrypt);
    VMOVE(sp -> gls_exit, exitpt);
    if (op -> glo_segs == G_LINT_SEG_NULL)
	op -> glo_segs = sp;
    else
	op -> glo_seg_last -> gls_next = sp;
    op -> glo_seg_last = sp;
}

unsigned char *get_color (unsigned char *ucp, unsigned long x)
{
    int	index;

    for (index = 0; x > 1; ++index)
	x >>= 1;

    return (ucp + (index * 3));
}

/*			R P T _ H I T
 *
 *	Ray-hit handler for use by rt_shootray().
 *
 *	Checks every partition along the ray, reporting on stdout
 *	possible problems with modeled air.  Conditions reported
 *	are:
 *	    - Contiguous partitions with differing non-zero air codes,
 *	    - First partition along a ray with a non-zero air code,
 *	    - Last partition along a ray with a non-zero air code, and
 *	    - Void between successive partitions (exit point from one
 *		not equal to entry point of next), if it is longer
 *		than tolerance, and either of the partitions is air;
 *		and
 *	    - Void between successive partitions (exit point from one
 *		not equal to entry point of next), if it is longer
 *		than tolerance.
 *	The function returns the number of possible problems it
 *	discovers.
 */
static int rpt_hit (struct application *ap, struct partition *ph, struct seg *dummy)
{
    struct partition	*pp;
    vect_t		delta;
    fastf_t		mag_del;
    int			problems = 0;
    int			last_air = 0;
    struct g_lint_ctrl	*cp = (struct g_lint_ctrl *) ap -> a_uptr;
    int			show_origin;
    int			do_plot3;
    fastf_t		tolerance;
    unsigned long	what_to_report;
    unsigned long	debug;
    unsigned char	*color;

    RT_AP_CHECK(ap);
    BU_CKMAG(ph, PT_HD_MAGIC, "partition-list head");
    BU_CKMAG(cp, G_LINT_CTRL_MAGIC, "g_lint control structure");

    show_origin = (cp -> glc_how_to_report == G_LINT_ASCII_WITH_ORIGIN);
    do_plot3 = (cp -> glc_how_to_report == G_LINT_PLOT3);
    tolerance = cp -> glc_tol;
    what_to_report = cp -> glc_what_to_report;
    debug = cp -> glc_debug;

    /*
     *	Before we do anything else,
     *	compute all the hit points along this partition
     */
    for (pp = ph -> pt_forw; pp != ph; pp = pp -> pt_forw)
    {
	BU_CKMAG(pp, PT_MAGIC, "partition structure");

	RT_HIT_NORM(pp -> pt_inhit, pp -> pt_inseg -> seg_stp,
	    &ap -> a_ray);
	RT_HIT_NORM(pp -> pt_outhit, pp -> pt_outseg -> seg_stp,
	    &ap -> a_ray);
    }

    /*
     *	Now, do the real work of checking the partitions...
     */
    for (pp = ph -> pt_forw; pp != ph; pp = pp -> pt_forw)
    {
	/* Check air partitions */
	if (what_to_report & G_LINT_A_ANY)
	{
	    if (pp -> pt_regionp -> reg_regionid <= 0)
	    {
		if ((what_to_report & G_LINT_A_CONT)
		 && last_air && (pp -> pt_regionp -> reg_aircode != last_air))
		{
		    VSUB2(delta, pp -> pt_inhit -> hit_point,
			pp -> pt_back -> pt_outhit -> hit_point);
		    if ((mag_del = MAGNITUDE(delta)) < tolerance)
		    {
			if (do_plot3)
			{
			    color = get_color(cp -> glc_color, G_LINT_A_CONT);
			    pl_color(cp -> glc_fp, V3ARGS(color));
			    pdv_3point(cp -> glc_fp,
				    pp -> pt_inhit -> hit_point);
			}
			else
			{
			    printf("air_contiguous ");
			    if (show_origin)
				printf("%g %g %g ",
				    V3ARGS(ap -> a_ray.r_pt));
			    printf("%s %d %s %d %g %g %g\n",
				pp -> pt_back -> pt_regionp -> reg_name,
				last_air,
				pp -> pt_regionp -> reg_name,
				pp -> pt_regionp -> reg_aircode,
				pp -> pt_inhit -> hit_point[X],
				pp -> pt_inhit -> hit_point[Y],
				pp -> pt_inhit -> hit_point[Z]);
			}
			++problems;
		    }
		}

		if (pp -> pt_back == ph)
		{
		    if (what_to_report & G_LINT_A_1ST)
		    {
			if (do_plot3)
			{
			    color = get_color(cp -> glc_color, G_LINT_A_1ST);
			    pl_color(cp -> glc_fp, V3ARGS(color));
			    pdv_3point(cp -> glc_fp,
				    pp -> pt_inhit -> hit_point);
			}
			else
			{
			    printf("air_first ");
			    if (show_origin)
				printf("%g %g %g ", V3ARGS(ap -> a_ray.r_pt));
			    printf("%s %d %g %g %g\n",
				pp -> pt_regionp -> reg_name,
				pp -> pt_regionp -> reg_aircode,
				pp -> pt_inhit -> hit_point[X],
				pp -> pt_inhit -> hit_point[Y],
				pp -> pt_inhit -> hit_point[Z]);
			}
			++problems;
		    }
		}
		else if (what_to_report & G_LINT_A_UNCONF)
		{
		    VSUB2(delta, pp -> pt_inhit -> hit_point,
			pp -> pt_back -> pt_outhit -> hit_point);
		    if (debug & G_LINT_A_UNCONF)
		    {
			bu_log("inhit (%g,%g,%g) - back outhit (%g,%g,%g) ",
			    V3ARGS(pp -> pt_inhit -> hit_point),
			    V3ARGS(pp -> pt_back -> pt_outhit -> hit_point));
			bu_log(" = (%g,%g,%g), mag=%g\n",
			    V3ARGS(delta), MAGNITUDE(delta));
		    }
		    if ((mag_del = MAGNITUDE(delta)) > tolerance)
		    {
			if (do_plot3)
			{
			    color = get_color(cp -> glc_color, G_LINT_A_UNCONF);
			    pl_color(cp -> glc_fp, V3ARGS(color));
			    pdv_3line(cp -> glc_fp,
				pp -> pt_back -> pt_outhit -> hit_point,
				pp -> pt_inhit -> hit_point);
			}
			else
			{
			    printf("air_unconfined ");
			    if (show_origin)
				printf("%g %g %g ", V3ARGS(ap -> a_ray.r_pt));
			    printf("%s (%s) %s (%s) %g    %g %g %g    %g %g %g\n",
				pp -> pt_back -> pt_regionp -> reg_name,
				pp -> pt_back -> pt_outseg -> seg_stp->st_name,
				pp -> pt_regionp -> reg_name,
				pp -> pt_inseg -> seg_stp -> st_name,
				mag_del,
				pp -> pt_back -> pt_outhit -> hit_point[X],
				pp -> pt_back -> pt_outhit -> hit_point[Y],
				pp -> pt_back -> pt_outhit -> hit_point[Z],
				pp -> pt_inhit -> hit_point[X],
				pp -> pt_inhit -> hit_point[Y],
				pp -> pt_inhit -> hit_point[Z]);
			}
			++problems;
		    }
		}

		if (pp -> pt_forw == ph)
		{
		    if (what_to_report & G_LINT_A_LAST)
		    {
			if (do_plot3)
			{
			    color = get_color(cp -> glc_color, G_LINT_A_LAST);
			    pl_color(cp -> glc_fp, V3ARGS(color));
			    pdv_3point(cp -> glc_fp,
				    pp -> pt_outhit -> hit_point);
			}
			else
			{
			    printf("air_last ");
			    if (show_origin)
				printf("%g %g %g ", V3ARGS(ap -> a_ray.r_pt));
			    printf("%s %d %g %g %g\n",
				pp -> pt_regionp -> reg_name,
				pp -> pt_regionp -> reg_aircode,
				pp -> pt_outhit -> hit_point[X],
				pp -> pt_outhit -> hit_point[Y],
				pp -> pt_outhit -> hit_point[Z]);
			}
			++problems;
		    }
		}
		else if (what_to_report & G_LINT_A_UNCONF)
		{
		    VSUB2(delta, pp -> pt_forw -> pt_inhit -> hit_point,
			pp -> pt_outhit -> hit_point);
		    if (debug & G_LINT_A_UNCONF)
		    {
			bu_log("forw inhit (%g,%g,%g) - outhit (%g,%g,%g) ",
			    V3ARGS(pp -> pt_forw -> pt_inhit -> hit_point),
			    V3ARGS(pp -> pt_outhit -> hit_point));
			bu_log(" = (%g,%g,%g), mag=%g\n",
			    V3ARGS(delta), MAGNITUDE(delta));
		    }
		    if ((mag_del = MAGNITUDE(delta)) > tolerance)
		    {
			if (do_plot3)
			{
			    color = get_color(cp -> glc_color, G_LINT_A_UNCONF);
			    pl_color(cp -> glc_fp, V3ARGS(color));
			    pdv_3line(cp -> glc_fp,
				pp -> pt_outhit -> hit_point,
				pp -> pt_forw -> pt_inhit -> hit_point);
			}
			else
			{
			    printf("air_unconfined ");
			    if (show_origin)
				printf("%g %g %g ", V3ARGS(ap -> a_ray.r_pt));
			    printf("%s (%s) %s (%s) %g    %g %g %g    %g %g %g\n",
				pp -> pt_regionp -> reg_name,
				pp -> pt_outseg -> seg_stp -> st_name,
				pp -> pt_forw -> pt_regionp -> reg_name,
				pp -> pt_forw -> pt_inseg -> seg_stp -> st_name,
				mag_del,
				pp -> pt_outhit -> hit_point[X],
				pp -> pt_outhit -> hit_point[Y],
				pp -> pt_outhit -> hit_point[Z],
				pp -> pt_forw -> pt_inhit -> hit_point[X],
				pp -> pt_forw -> pt_inhit -> hit_point[Y],
				pp -> pt_forw -> pt_inhit -> hit_point[Z]);
			}
			++problems;
		    }
		}
		last_air = pp -> pt_regionp -> reg_aircode;
	    }
	    else
		last_air = 0;
	}

	/* Look for vacuum */
	if ((what_to_report & G_LINT_VAC) && (pp -> pt_back != ph))
	{
	    VSUB2(delta, pp -> pt_inhit -> hit_point,
		pp -> pt_back -> pt_outhit -> hit_point);
	    if (debug & G_LINT_VAC)
	    {
		bu_log("inhit (%g,%g,%g) - back outhit (%g,%g,%g) ",
		    V3ARGS(pp -> pt_inhit -> hit_point),
		    V3ARGS(pp -> pt_back -> pt_outhit -> hit_point));
		bu_log(" = (%g,%g,%g), mag=%g\n",
		    V3ARGS(delta), MAGNITUDE(delta));
	    }
	    if ((mag_del = MAGNITUDE(delta)) > tolerance)
	    {
		if (do_plot3)
		{
		    color = get_color(cp -> glc_color, G_LINT_VAC);
		    pl_color(cp -> glc_fp, V3ARGS(color));
		    pdv_3line(cp -> glc_fp,
			pp -> pt_back -> pt_outhit -> hit_point,
			pp -> pt_inhit -> hit_point);
		}
		else
		{
		    printf("vacuum ");
		    if (show_origin)
			printf("%g %g %g ", V3ARGS(ap -> a_ray.r_pt));
		    printf("%s (%s) %s (%s) %g    %g %g %g    %g %g %g\n",
			pp -> pt_back -> pt_regionp -> reg_name,
			pp -> pt_back -> pt_outseg -> seg_stp -> st_name,
			pp -> pt_regionp -> reg_name,
			pp -> pt_inseg -> seg_stp -> st_name,
			mag_del,
			pp -> pt_back -> pt_outhit -> hit_point[X],
			pp -> pt_back -> pt_outhit -> hit_point[Y],
			pp -> pt_back -> pt_outhit -> hit_point[Z],
			pp -> pt_inhit -> hit_point[X],
			pp -> pt_inhit -> hit_point[Y],
			pp -> pt_inhit -> hit_point[Z]);
		}
		++problems;
	    }
	}
    }
    return (problems);
}

/*		    N O _ O P _ O V E R L A P
 *			N O _ O P _ H I T
 *		       N O _ O P _ M I S S
 *
 *	Null event handlers for use by rt_shootray().
 *
 */
static int no_op_overlap (struct application *ap, struct partition *pp, struct region *r1, struct region *r2, struct partition *hp)
{
	return( 0 );
}

static int no_op_hit (struct application *ap, struct partition *ph, struct seg *dummy)
{
    return (1);
}

static int no_op_miss (struct application *ap)
{
    return (1);
}

/*			R P T _ O V L P
 *
 *	Overlap handler for use by rt_shootray().
 *
 *	Reports the current overlap on stdout, if the overlap
 *	is of length greater than tolerance.  The function
 *	returns 1 if the overlap was large enough to report,
 *	otherwise 0.
 */
static int rpt_ovlp (struct application *ap, struct partition *pp, struct region *r1, struct region *r2, struct partition *hp)
{
    vect_t		delta;
    fastf_t		mag_del;
    struct g_lint_ctrl	*cp;
    int			show_origin;
    int			do_plot3;
    fastf_t		tolerance;

    RT_AP_CHECK(ap);
    BU_CKMAG(pp, PT_MAGIC, "partition structure");
    BU_CKMAG(r1, RT_REGION_MAGIC, "region structure");
    BU_CKMAG(r2, RT_REGION_MAGIC, "region structure");
    cp = (struct g_lint_ctrl *) ap -> a_uptr;
    BU_CKMAG(cp, G_LINT_CTRL_MAGIC, "g_lint control structure");

    show_origin = (cp -> glc_how_to_report == G_LINT_ASCII_WITH_ORIGIN);
    do_plot3 = (cp -> glc_how_to_report == G_LINT_PLOT3);
    tolerance = cp -> glc_tol;

    /* Compute entry and exit points, and the vector between them */
    RT_HIT_NORM(pp -> pt_inhit, pp -> pt_inseg -> seg_stp, &ap -> a_ray);
    RT_HIT_NORM(pp -> pt_outhit, pp -> pt_outseg -> seg_stp, &ap -> a_ray);
    VSUB2(delta, pp -> pt_inhit -> hit_point, pp -> pt_outhit -> hit_point);

    if ((mag_del = MAGNITUDE(delta)) > tolerance)
    {
	if (do_plot3)
	{
	    pl_color(cp -> glc_fp,
			V3ARGS(&(cp -> glc_color[log_2(G_LINT_OVLP)])));
	    pdv_3line(cp -> glc_fp, pp -> pt_inhit -> hit_point,
				    pp -> pt_outhit -> hit_point);
	}
	else if (ovlp_log)
	    update_ovlp_log(r1, r2, mag_del,
		ap -> a_ray.r_pt,
		pp -> pt_inhit -> hit_point,
		pp -> pt_outhit -> hit_point);
	else
	    print_segment(r1 -> reg_name, r2 -> reg_name, mag_del,
		show_origin ? ap -> a_ray.r_pt : 0,
		pp -> pt_inhit -> hit_point,
		pp -> pt_outhit -> hit_point);
    }
    return (mag_del > tolerance);
}

void init_plot3 (struct application *ap)
{
    register struct rt_i	*rtip;
    struct g_lint_ctrl		*cp;

    RT_AP_CHECK(ap);
    rtip = ap -> a_rt_i;
    RT_CHECK_RTI(rtip);
    cp = (struct g_lint_ctrl *) ap -> a_uptr;
    BU_CKMAG(cp, G_LINT_CTRL_MAGIC, "g_lint control structure");

    pdv_3space(cp -> glc_fp, rtip->rti_pmin, rtip->rti_pmax);
}

int
main (int argc, char **argv)
{
    struct application	ap;
    char		db_title[TITLE_LEN+1];	/* Title of database */
    char		*sp;			/* String from strtoul(3) */
    fastf_t		azimuth = 0.0;
    fastf_t		celsiz = 100.0;		/* Spatial sampling rate */
    fastf_t		elevation = 0.0;
    struct g_lint_ctrl	control;		/* Info handed to librt(3) */
    int			cell_center = 0;	/* Fire from center of cell? */
    int			ch;			/* Character from getopt */
    int			complement_bits;	/* Used by -r option */
    int			i;			/* Dummy loop index */
    int			use_air = 0;		/* Does air count? */
    mat_t		model2view;		/* Model-to-view matrix */
    mat_t		view2model;		/* View-to-model matrix */
    point_t		cell;			/* Cell center, view coords */
    point_t		g_min;			/* Lower-left of grid plane */
    point_t		g_max;			/* Upper-right of grid plane */
    point_t		mdl_cell;		/* Cell center, model coords */
    point_t		mdl_extrema[2];		/* mdl_min and mdl_max */
    point_t		mdl_bb_vertex;		/* A bounding-box vertex */
    point_t		mdl_row_orig;		/* "Origin" of view-plane row */
    point_t		mdl_vpo;		/* View-plane origin */
    point_t		v_bb_vertex;	/* bounding-box vertex, view coords */
    struct rt_i		*rtip;
    vect_t		unit_D;			/* View basis vectors */
    vect_t		unit_H;
    vect_t		unit_V;

    extern int		bu_optind;			/* For use with getopt */
    extern char		*bu_optarg;

    bu_log("%s\n", rt_version());

    control.glc_magic = G_LINT_CTRL_MAGIC;
    control.glc_debug = 0;
    control.glc_tol = 0.0;
    control.glc_what_to_report = G_LINT_OVLP;
    control.glc_how_to_report = G_LINT_ASCII;
    control.glc_fp = stdout;
    control.glc_color = (unsigned char *) dflt_plot_rgb;

    /* Handle command-line options */
    while ((ch = bu_getopt(argc, argv, OPT_STRING)) != EOF)
	switch (ch)
	{
	    case 'a':
		if (sscanf(bu_optarg, "%lf", &azimuth) != 1)
		{
		    bu_log("Invalid azimuth specification: '%s'\n", bu_optarg);
		    printusage();
		    bu_exit (1, NULL);
		}
		break;
	    case 'c':
		cell_center = 1;
		break;
	    case 'e':
		if (sscanf(bu_optarg, "%lf", &elevation) != 1)
		{
		    bu_log("Invalid elevation specification: '%s'\n", bu_optarg);
		    printusage();
		    bu_exit (1, NULL);
		}
		if ((elevation < -90.0) || (elevation > 90.0))
		    bu_exit (1, "Illegal elevation: '%g'\n", elevation);
		break;
	    case 'g':
		if (sscanf(bu_optarg, "%lf", &celsiz) != 1)
		{
		    bu_log("Invalid grid-size specification: '%s'\n", bu_optarg);
		    printusage();
		    bu_exit (1, NULL);
		}
		if (celsiz < 0.0)
		    bu_exit (1, "Illegal grid size: '%g'\n", celsiz);
		break;
	    case 'o':
		control.glc_how_to_report = G_LINT_ASCII_WITH_ORIGIN;
		break;
	    case 'p':
		control.glc_how_to_report = G_LINT_PLOT3;
		if (ovlp_log)
		{
		    bu_rb_free1(ovlp_log, BU_RB_RETAIN_DATA);
		    ovlp_log = 0;
		}
		break;
	    case 'r':
		if (*bu_optarg == '-')
		{
		    complement_bits = 1;
		    ++bu_optarg;
		}
		else
		    complement_bits = 0;
		control.glc_what_to_report = strtoul(bu_optarg, &sp, 0);
		if (sp == bu_optarg)
		{
		    bu_log("Invalid report specification: '%s'\n", bu_optarg);
		    printusage();
		    bu_exit (1, NULL);
		}
		if (complement_bits)
		{
		    control.glc_what_to_report = ~(control.glc_what_to_report);
		    control.glc_what_to_report &= G_LINT_ALL;
		}
		use_air = ((control.glc_what_to_report & G_LINT_A_ANY) != 0);
		break;
	    case 's':
		ovlp_log = bu_rb_create1("overlap log", compare_overlaps);
		if (control.glc_how_to_report == G_LINT_PLOT3)
		    control.glc_how_to_report = G_LINT_ASCII;
		bu_rb_uniq_on1(ovlp_log);
		break;
	    case 't':
		if (sscanf(bu_optarg, "%lf", &(control.glc_tol)) != 1)
		{
		    bu_log("Invalid tolerance specification: '%s'\n",
			bu_optarg);
		    printusage();
		    bu_exit (1, NULL);
		}
		if (control.glc_tol < 0.0)
		    bu_exit (1, "Illegal tolerance: '%g'\n", control.glc_tol);
		break;
	    case 'u':
		use_air = 1;
		break;
	    case 'x':
		control.glc_debug = strtoul(bu_optarg, &sp, 16);
		if (sp == bu_optarg)
		{
		    bu_log("Invalid debug-flag specification: '%s'\n", bu_optarg);
		    printusage();
		    bu_exit (1, NULL);
		}
		break;
	    default:
		printusage();
		bu_exit (1, NULL);
	}

    if (argc - bu_optind < 2)
    {
	printusage();
	bu_exit (1, NULL);
    }
    if (control.glc_what_to_report & ~G_LINT_ALL)
	bu_log("WARNING: Ignoring undefined bits of report specification\n");

    /* Read in the geometry model */
    bu_log("Database file:  '%s'\n", argv[bu_optind]);
    bu_log("Building the directory... ");
    if ((rtip = rt_dirbuild(argv[bu_optind] , db_title, TITLE_LEN)) == RTI_NULL)
	bu_exit (1, "Could not build directory for file '%s'\n", argv[bu_optind]);
    rtip -> useair = use_air;
    bu_log("\nPreprocessing the geometry... ");
    while (++bu_optind < argc)
    {
	if (rt_gettree(rtip, argv[bu_optind]) == -1)
	    bu_exit (1, NULL);
	bu_log("\nObject '%s' processed", argv[bu_optind]);
    }
    bu_log("\nPrepping the geometry... ");
    rt_prep(rtip);
    bu_log("\n");

    /*
     *	Initialize the application structure
     */
    RT_APPLICATION_INIT(&ap);
    ap.a_hit =
	(control.glc_what_to_report & ~G_LINT_OVLP) ? rpt_hit
						    : no_op_hit;
    ap.a_miss = no_op_miss;
    ap.a_resource = RESOURCE_NULL;
    ap.a_overlap =
	(control.glc_what_to_report & G_LINT_OVLP) ? rpt_ovlp
						   : no_op_overlap;
    ap.a_onehit = 0;		/* Don't stop at first partition */
    ap.a_uptr = (char *) &control;
    ap.a_rt_i = rtip;
    ap.a_purpose = "Look for possible problems in geometry";

    /* Compute the basis vectors for the view coordinate system
     *	(N.B. I use VMOVEN() here instead of VMOVE() to emphasize that
     *	 each call copies exactly three elements of the array).
     */
    MAT_IDN(view2model);
    bn_mat_ae(view2model, azimuth, elevation);
    bn_mat_inv(model2view, view2model);
    VMOVEN(unit_D, model2view, 3);
    VMOVEN(unit_H, model2view + 4, 3);
    VMOVEN(unit_V, model2view + 8, 3);

    /* Compute the limits of gridding
     *	0. initialize mdl_extrema, g_min, and g_max,
     *	1. build each vertex of the bounding box in turn,
     *	2. rotate it into view coordinates,
     *	3. keep a running record of the horizontal and vertical
     *	   extrema in the view plane.
     *	4. Expand the extrema to the next whole multiple of celsiz.
     */
    VMOVE(mdl_extrema[0], rtip -> mdl_min);
    VMOVE(mdl_extrema[1], rtip -> mdl_max);
    VSETALL(g_min, 0.0);
    VMOVE(g_max, g_min);
    for (i = 0; i < 8; ++i)
    {
	VSET(mdl_bb_vertex,
	    mdl_extrema[(i & 0x4) > 0][X],
	    mdl_extrema[(i & 0x2) > 0][Y],
	    mdl_extrema[(i & 0x1) > 0][Z]);
	MAT4X3PNT(v_bb_vertex, model2view, mdl_bb_vertex);
	VMINMAX(g_min, g_max, v_bb_vertex);
    }
    for (i = 0; i < 3; ++i)
    {
	g_min[i] = celsiz * floor(g_min[i] / celsiz);
	g_max[i] = celsiz * ceil(g_max[i] / celsiz);
    }
    VSCALE(mdl_vpo, unit_D, g_max[0]);

    if (control.glc_how_to_report == G_LINT_PLOT3)
	init_plot3(&ap);

    /*
     *	Do the actual gridding
     */
    bu_log("Firing rays... ");
    VSCALE(ap.a_ray.r_dir, unit_D, -1.0);
    cell[2] = 0.0;
    for (cell[1] = g_max[2]; cell[1] >= g_min[2]; cell[1] -= celsiz)
    {
	VJOIN1(mdl_row_orig, mdl_vpo, cell[1], unit_V);
	for (cell[0] = g_min[1]; cell[0] <= g_max[1]; cell[0] += celsiz)
	{
	    VJOIN1(mdl_cell, mdl_row_orig, cell[0], unit_H);
	    VJOIN2(ap.a_ray.r_pt,
		mdl_cell,
		RAND_OFFSET, unit_H,
		RAND_OFFSET, unit_V);
	    VMOVE(ap.a_uvec, cell);
	    (void) rt_shootray(&ap);
	}
    }

    /*
     *	If overlaps have been collected for sorting,
     *	sort them now and then print them out.
     */
    if (ovlp_log)
    {
	ovlps_by_vol = bu_rb_create1("overlaps by volume", compare_by_vol);
	bu_rb_uniq_on1(ovlps_by_vol);
	bu_rb_walk1(ovlp_log, insert_by_vol, INORDER);

	if (control.glc_how_to_report == G_LINT_ASCII_WITH_ORIGIN)
	    bu_rb_walk1(ovlps_by_vol, print_overlap_o, INORDER);
	else
	    bu_rb_walk1(ovlps_by_vol, print_overlap, INORDER);
    }

    bu_exit (0, NULL);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.20
log
@quell decl mismatch warnings
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.19 2007/11/21 20:49:08 erikgreenwald Exp $ (ARL)";
d269 1
a269 1
    bzero((void *) op, sizeof(struct g_lint_ovlp));
@


14.19
log
@pass bu_exit a NULL instead of an empty string
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.18 2007/11/21 20:38:22 erikgreenwald Exp $ (ARL)";
d745 1
a745 1
static int no_op_overlap (struct application *ap, struct partition *pp, struct region *r1, struct region *r2)
d769 1
a769 1
static int rpt_ovlp (struct application *ap, struct partition *pp, struct region *r1, struct region *r2)
@


14.18
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.17 2007/11/21 19:28:06 erikgreenwald Exp $ (ARL)";
d884 1
a884 1
		    bu_exit (1, "");
d895 1
a895 1
		    bu_exit (1, "");
d905 1
a905 1
		    bu_exit (1, "");
d934 1
a934 1
		    bu_exit (1, "");
d955 1
a955 1
		    bu_exit (1, "");
d969 1
a969 1
		    bu_exit (1, "");
d974 1
a974 1
		bu_exit (1, "");
d980 1
a980 1
	bu_exit (1, "");
d995 1
a995 1
	    bu_exit (1, "");
d1098 1
a1098 1
    bu_exit (0, "");
@


14.17
log
@exit->bu_exit where applicable
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.16 2007/09/15 16:23:06 brlcad Exp $ (ARL)";
d250 1
a250 2
	bu_log("This shouldn't happen\n");
	bu_exit (1, "");
d379 1
a379 2
    {
	bu_log("%s:%d: bu_rb_insert() returns %d:  This should not happen\n",
a380 2
	bu_exit (1, "");
    }
d415 1
a415 2
    {
	bu_log("%s:%d: bu_rb_insert() returns %d:  This should not happen\n",
a416 2
	bu_exit (1, "");
    }
d898 1
a898 4
		{
		    bu_log("Illegal elevation: '%g'\n", elevation);
		    bu_exit (1, "");
		}
d908 1
a908 4
		{
		    bu_log("Illegal grid size: '%g'\n", celsiz);
		    bu_exit (1, "");
		}
d958 1
a958 4
		{
		    bu_log("Illegal tolerance: '%g'\n", control.glc_tol);
		    bu_exit (1, "");
		}
d989 1
a989 4
    {
	bu_log("Could not build directory for file '%s'\n", argv[bu_optind]);
	bu_exit (1, "");
    }
@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.15 2007/05/14 21:04:30 brlcad Exp $ (ARL)";
d251 1
a251 1
	exit (1);
d383 1
a383 1
	exit (1);
d422 1
a422 1
	exit (1);
d891 1
a891 1
		    exit (1);
d902 1
a902 1
		    exit (1);
d907 1
a907 1
		    exit (1);
d915 1
a915 1
		    exit (1);
d920 1
a920 1
		    exit (1);
d947 1
a947 1
		    exit (1);
d968 1
a968 1
		    exit (1);
d973 1
a973 1
		    exit (1);
d985 1
a985 1
		    exit (1);
d990 1
a990 1
		exit (1);
d996 1
a996 1
	exit (1);
d1007 1
a1007 1
	exit (1);
d1014 1
a1014 1
	    exit (1);
d1117 1
a1117 1
    exit (0);
@


14.15
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.14 2007/04/16 21:15:36 brlcad Exp $ (ARL)";
a35 1
#include <stdlib.h>
d38 1
a38 2

#ifdef HAVE_STRING_H
a39 4
#else
#include <strings.h>
#endif

d43 1
@


14.14
log
@revamp BRL-CAD's versioning setup.  no longer rely upon the vers.sh script, allowing for a more unified cross-platform configuration.  instead of globals, provide per-library functions that return the version string.  the version numbers are now stored in files in include/conf/.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.13 2007/02/02 08:48:29 brlcad Exp $ (ARL)";
d1048 2
a1049 2
    mat_ae(view2model, azimuth, elevation);
    mat_inv(model2view, view2model);
@


14.13
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.12 2007/01/27 01:41:34 brlcad Exp $ (ARL)";
d877 1
a877 1
    bu_log("%s\n", rt_version);
@


14.12
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.11 2007/01/23 01:13:32 brlcad Exp $ (ARL)";
d854 1
a854 1
    int			ch;			/* Character from getopt(3) */
d874 2
a875 4
    extern int		optind;			/* For use with getopt(3) */
    extern char		*optarg;

    extern int		getopt(int, char *const *, const char *);
d888 1
a888 1
    while ((ch = getopt(argc, argv, OPT_STRING)) != EOF)
d892 1
a892 1
		if (sscanf(optarg, "%lf", &azimuth) != 1)
d894 1
a894 1
		    bu_log("Invalid azimuth specification: '%s'\n", optarg);
d903 1
a903 1
		if (sscanf(optarg, "%lf", &elevation) != 1)
d905 1
a905 1
		    bu_log("Invalid elevation specification: '%s'\n", optarg);
d916 1
a916 1
		if (sscanf(optarg, "%lf", &celsiz) != 1)
d918 1
a918 1
		    bu_log("Invalid grid-size specification: '%s'\n", optarg);
d940 1
a940 1
		if (*optarg == '-')
d943 1
a943 1
		    ++optarg;
d947 2
a948 2
		control.glc_what_to_report = strtoul(optarg, &sp, 0);
		if (sp == optarg)
d950 1
a950 1
		    bu_log("Invalid report specification: '%s'\n", optarg);
d968 1
a968 1
		if (sscanf(optarg, "%lf", &(control.glc_tol)) != 1)
d971 1
a971 1
			optarg);
d985 2
a986 2
		control.glc_debug = strtoul(optarg, &sp, 16);
		if (sp == optarg)
d988 1
a988 1
		    bu_log("Invalid debug-flag specification: '%s'\n", optarg);
d998 1
a998 1
    if (argc - optind < 2)
d1007 1
a1007 1
    bu_log("Database file:  '%s'\n", argv[optind]);
d1009 1
a1009 1
    if ((rtip = rt_dirbuild(argv[optind] , db_title, TITLE_LEN)) == RTI_NULL)
d1011 1
a1011 1
	bu_log("Could not build directory for file '%s'\n", argv[optind]);
d1016 1
a1016 1
    while (++optind < argc)
d1018 1
a1018 1
	if (rt_gettree(rtip, argv[optind]) == -1)
d1020 1
a1020 1
	bu_log("\nObject '%s' processed", argv[optind]);
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.10 2007/01/20 14:36:49 brlcad Exp $ (ARL)";
a39 1

@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.9 2006/01/18 06:46:15 brlcad Exp $ (ARL)";
@


14.9
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 1995-2006 United States Government as represented by
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.8 2005/12/02 21:08:20 brlcad Exp $ (ARL)";
@


14.8
log
@use RT_APPLICATION_INIT instead of zero'ing
@
text
@d4 1
a4 1
 * Copyright (C) 1995-2005 United States Government as represented by
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.7 2005/10/23 04:44:30 brlcad Exp $ (ARL)";
@


14.7
log
@trailing ws
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.6 2005/01/30 20:30:37 brlcad Exp $ (ARL)";
d1033 1
a1033 1
    bzero((void *) &ap, sizeof(struct application));
@


14.6
log
@update copyright to 2005
@
text
@d28 1
a28 1
 *  
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/gtools/g_lint.c,v 14.5 2004/12/21 07:32:29 morrison Exp $ (ARL)";
d453 1
a453 1
    
d703 1
a703 1
	
d841 1
a841 1
    
@


14.6.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d453 1
a453 1

d703 1
a703 1

d841 1
a841 1

@


14.5
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1995-2004 United States Government as represented by
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/gtools/g_lint.c,v 14.4 2004/12/21 06:58:42 morrison Exp $ (ARL)";
@


14.4
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a31 2
 *  
 *
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/gtools/g_lint.c,v 14.3 2004/12/21 06:44:32 morrison Exp $ (ARL)";
@


14.3
log
@remove the old distribution notice section
@
text
@a33 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/gtools/g_lint.c,v 14.2 2004/12/20 20:21:31 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and GPL license
@
text
@a32 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/gtools/g_lint.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ L I N T . C
d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/gtools/g_lint.c,v 1.3 2004/09/03 23:30:56 morrison Exp $ (ARL)";
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/gtools/g_lint.c,v 1.2 2004/08/02 23:01:47 morrison Exp $ (ARL)";
d1118 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/gtools/g_lint.c,v 1.1 2004/05/20 15:19:09 morrison Exp $ (ARL)";
d32 1
a32 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/gtools/g_lint.c,v 1.14 2004/05/10 15:30:42 erikg Exp $ (ARL)";
d28 1
a28 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

