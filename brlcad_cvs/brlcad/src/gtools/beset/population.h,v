head	1.14;
access;
symbols
	rel-7-10-4:1.13
	STABLE:1.13.0.2
	rel-7-10-2:1.13;
locks; strict;
comment	@ * @;


1.14
date	2007.09.14.15.21.06;	author erikgreenwald;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.06.16.21.19;	author poolio;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.02.19.23.47;	author poolio;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.01.20.50.17;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.01.16.46.47;	author poolio;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.31.21.54.36;	author poolio;	state Exp;
branches;
next	1.8;

1.8
date	2007.07.28.07.14.56;	author poolio;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.18.17.14.09;	author poolio;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.11.15.58.31;	author poolio;	state Exp;
branches;
next	1.5;

1.5
date	2007.07.10.15.55.42;	author poolio;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.29.00.38.43;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.28.18.58.51;	author poolio;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.28.12.58.37;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.28.03.56.52;	author poolio;	state Exp;
branches;
next	;


desc
@@


1.14
log
@removed trailing whitespace
@
text
@/*                    P O P U L A T I O N . H
 * BRL-CAD
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file population.h
 *
 * prototypes and population structs
 *
 * Author -
 *   Ben Poole
 */

#ifndef __POPULATION_H__
#define __POPULATION_H__

#define GEO_SPHERE 1

#define VSCALE_SELF(a,c) { (a)[X] *= (c); (a)[Y] *= (c); (a)[Z]*=(c);}
#define VMUTATE(a){VMUT(a,-MUT_STEP/2+MUT_STEP*pop_rand())}
#define VMUT(a,c){(a)[X] += ((a)[X] == 0)?0:(c); (a)[Y] += ((a)[Y] == 0)?0:(c); (a)[Z]+=((a)[Z]==0)?0:(c);}
#define MUT_STEP .8



struct name{
    char n[256];
    int i;
};

struct individual {
    int id;
    fastf_t fitness;
};

struct population {
    struct individual *parent;
    struct individual *child;

    struct db_i *db_p;
    struct db_i *db_c;

    char **name;
    int size;
};

struct node{
    struct bu_list l;
    union tree **s_parent;
    union tree *s_child;
};

void pop_init	    (struct population *p, int size);
void pop_spawn	    (struct population *p);
void pop_clean	    (struct population *p);
void pop_add	    (struct individual *i, struct rt_wdb *db);
int  pop_wrand_ind  (struct individual *i, int size, fastf_t total_fitness, int offset);
int  pop_wrand_gop  (void);
fastf_t pop_rand    (void);
int pop_find_nodes(union tree *tp);

void pop_gop(int gop, char *parent1, char *parent2, char * child1, char *child2,  struct db_i *dbi_p,
	     struct db_i *dbi_c, struct resource *resp);
int pop_put_internal(const char *n, struct directory *dp, struct db_i *dbip, struct rt_db_internal *ip,
	struct resource *resp);





#endif /* __POPULATION_H__ */

/*
 * Local Variables:
 * tab-width: 8
 * mode: C
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.13
log
@pre-generate and store identifiers. more cleanup
@
text
@d34 1
a34 1
#define VMUTATE(a){VMUT(a,-MUT_STEP/2+MUT_STEP*pop_rand())} 
d54 2
a55 2
    struct db_i *db_p; 
    struct db_i *db_c; 
d76 1
a76 1
void pop_gop(int gop, char *parent1, char *parent2, char * child1, char *child2,  struct db_i *dbi_p, 
@


1.12
log
@now conforms to C89
@
text
@d46 1
a46 1
    char id[256];
d57 1
d68 1
a68 1
void pop_spawn	    (struct population *p, struct rt_wdb *db_fp);
@


1.11
log
@no need to malloc a single struct once, just use it
@
text
@d46 1
a46 1
    char id[256];//the nameeeeee
d54 2
a55 2
    struct db_i *db_p; // parent database
    struct db_i *db_c; // chld database
a74 3
//void pop_dup_functree(struct db_i *dbi_p, struct db_i *dbi_c,
//		      union tree *tp, struct resource *resp, 
//		      char *name );
@


1.10
log
@more mutation support and cosmetics
@
text
@d66 1
a66 1
void pop_init	    (struct population **p, int size);
@


1.9
log
@now able to keep an upper % of population and kill a lower %. general code cleanup.
@
text
@d33 7
@


1.8
log
@fitness function should be working, so selection must be broken
@
text
@d63 1
a63 1
int  pop_wrand_ind  (struct individual *i, int size, fastf_t total_fitness);
@


1.7
log
@working crossover and reproduction. implementation works, but is going to need a lot of tweaking.
@
text
@d50 2
d53 4
a56 3


    int size;
d66 1
@


1.6
log
@fixed issue with renaming directory pointers, combination trees are now supported
@
text
@d67 1
a67 1
void pop_dup(char *parent, char * child, struct db_i *dbi_p, 
@


1.5
log
@partially working tree implementation. still some bugs to work out...
@
text
@d69 2
@


1.4
log
@petty cosmetics while browsing, mostly ws
@
text
@d33 5
d39 1
a39 4
    point_t p;
    fastf_t r;
    char id[256];
    int type;
a40 1

d44 9
a52 2
    struct individual *individual;
    struct individual *offspring;
d64 10
@


1.3
log
@single sphere partially working
@
text
@d28 2
d56 1
@


1.2
log
@add headers/footers as needed
@
text
@d22 1
a22 1
 * Brief description
a37 2
    /* for raytracing */
    double gs[2]; //grid spacing
d46 7
a52 6
void pop_init (struct population **p, int size);
void pop_spawn(struct population *p, struct rt_wdb *db_fp);
void pop_clean(struct population *p);
int  pop_wrand_ind(struct individual *i, int size, fastf_t total_fitness);
int  pop_wrand_gop(void);
fastf_t pop_rand(void);
@


1.1
log
@implemented basic GA framework
@
text
@d1 28
d55 10
@

