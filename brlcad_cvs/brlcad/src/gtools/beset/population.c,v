head	1.30;
access;
symbols
	rel-7-10-4:1.26
	STABLE:1.26.0.2
	rel-7-10-2:1.26;
locks; strict;
comment	@ * @;


1.30
date	2007.11.21.20.38.22;	author erikgreenwald;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.21.16.10.12;	author erikgreenwald;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.14.17.44.10;	author erikgreenwald;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.14.15.21.06;	author erikgreenwald;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.09.15.50.34;	author poolio;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.08.23.38.08;	author poolio;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.06.16.21.19;	author poolio;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.02.19.23.47;	author poolio;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.02.00.15.10;	author poolio;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.01.21.07.29;	author brlcad;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.01.20.56.51;	author poolio;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.01.20.50.17;	author brlcad;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.01.16.46.47;	author poolio;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.31.21.54.36;	author poolio;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.30.01.21.06;	author poolio;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.29.16.34.59;	author poolio;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.28.07.14.56;	author poolio;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.23.22.09.18;	author poolio;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.20.17.55.52;	author poolio;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.20.14.49.12;	author poolio;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.18.17.14.09;	author poolio;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.16.16.20.49;	author poolio;	state Exp;
branches;
next	1.8;

1.8
date	2007.07.11.15.58.31;	author poolio;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.10.17.34.43;	author poolio;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.10.15.55.42;	author poolio;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.29.04.36.14;	author poolio;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.29.00.38.43;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.28.18.58.51;	author poolio;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.28.12.58.37;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.28.03.56.52;	author poolio;	state Exp;
branches;
next	;


desc
@@


1.30
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@/*                    P O P U L A T I O N . C
 * BRL-CAD
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file population.c
 *
 * routines to manipulate the population
 *
 * Author -
 *   Ben Poole
 */

#include "common.h"

#include <string.h>
#include <strings.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <math.h>
#include <limits.h>

#include "machine.h"
#include "bu.h"
#include "bn.h"
#include "vmath.h"
#include "raytrace.h"
#include "wdb.h"

#include "population.h"
#include "beset.h"


/* FIXME: get rid of globals*/
float *idx;
int shape_number;


/**
 *	P O P _ I N I T --- initialize a population of a given size
 */
void
pop_init (struct population *p, int size)
{
    int i;
    p->parent = bu_malloc(sizeof(struct individual) * size, "parent");
    p->child  = bu_malloc(sizeof(struct individual) * size, "child");
    p->size = size;
    p->db_c = p->db_p = DBI_NULL;
    p->name = bu_malloc(sizeof(char **) * size, "names");

    /* pre-compute indidvidual names */
    /*
    for(i = 0; i < size; i++){
	p->name[i] = bu_malloc(sizeof(char *) * 256, "name");
	snprintf(p->name[i], 256, "ind%.3d", i);
    }
    */


#define SEED 33
    /* init in main() bn_rand_init(idx, SEED);*/
    bn_rand_init(idx, SEED);
}

/**
 *	P O P _ C L E A N  --- cleanup population struct
 */
void
pop_clean (struct population *p)
{
    int i;
    for(i = 0; i < p->size; i++)
	bu_free(p->name[i], "name");
    bu_free(p->name, "names");
    bu_free(p->parent, "parent");
    bu_free(p->child, "child");
}

/**
 *	P O P _ S P A W N --- spawn a new population
 *	TODO: generalize/modularize somehow to allow adding more shapes and primitives
 *	also use variable/defined rates, intersection with bounding box, etc...
 */
void
pop_spawn (struct population *p)
{
    int i,j;
    point_t p1, p2, p3;
    struct wmember wm_hd;
    double r1, r2, r3;

    char shape[256];

    p->db_p = db_create("gen000", 5);
    p->db_p->dbi_wdbp = wdb_dbopen(p->db_p, RT_WDB_TYPE_DB_DISK);

    for(i = 0; i < p->size; i++) {
	p->name[i] = bu_malloc(sizeof(char *) * 256, "name");
	snprintf(p->name[i], 256, "ind%.3d", i);

	BU_LIST_INIT(&wm_hd.l);
	/*
	VSET(p1, -5, -5, -5);
	VSET(p2, 5, 5, 5);
	r1 = r2 = 2.5;
	*/
	for(j = 0; j < 6; j++){
	    /* VSETALL(p1, -10+pop_rand()*10); */
	    p1[0] = -10*pop_rand()*10;
	    p1[1] = -10*pop_rand()*10;
	    p1[2] = -10*pop_rand()*10;
	    r1 = 1+3*pop_rand();
	    snprintf(shape, 256, "ind%.3d-%.3d", i, j);
	    mk_sph(p->db_p->dbi_wdbp, shape, p1, r1);
	    mk_addmember(shape, &wm_hd.l, NULL, WMOP_UNION);
	}



	p->parent[i].fitness = 0.0;
	p->parent[i].id = i;
	/*

	snprintf(shape, 256, "ind%.3d-%.3d", i,0);
	mk_sph(p->db_p->dbi_wdbp, shape, p1, r1);
	mk_addmember(shape, &wm_hd.l, NULL, WMOP_UNION);


	snprintf(shape, 256, "ind%.3d-%.3d", i,1);
	mk_sph(p->db_p->dbi_wdbp,shape, p2, r2);
	mk_addmember(shape, &wm_hd.l, NULL, WMOP_UNION);

	snprintf(shape, 256, "gen%.3dind%.3d-%.3d", 0,i,2);
	mk_sph(p->db_p->dbi_wdbp, shape, p3, r3);
	mk_addmember(shape, &wm_hd.l, NULL, WMOP_UNION);
	*/
	mk_lcomb(p->db_p->dbi_wdbp, NL_P(p->parent[i].id), &wm_hd, 1, NULL, NULL, NULL, 0);
    }

/*
 * reload the db so we dont
 * have to do any extra checks
 * in the main looop
 */
    wdb_close(p->db_p->dbi_wdbp);
    if((p->db_p = db_open("gen000", "r")) == DBI_NULL)
	bu_exit(EXIT_FAILURE, "Failed to re-open initial population");
    if(db_dirbuild(p->db_p) < 0)
	bu_exit(EXIT_FAILURE, "Failed to load initial database");
}

/**
 *	P O P _ A D D --- add an parent to othe database
 *	TODO: Don't overwrite previous parents, one .g file per generation
 */
/*
void
pop_add(struct individual *i, struct rt_wdb *db_fp)
{
    switch(i->type)
    {
    case GEO_SPHERE:
	mk_sph(db_fp, i->id, i->p, i->r);
    }
}
*/


/**
 *	P O P _ W R A N D -- weighted random index of parent
 */
int
pop_wrand_ind(struct individual *i, int size, fastf_t total_fitness, int offset)
{
    int n = offset;
    fastf_t rindex, psum = 0;
    rindex =pop_rand() * total_fitness;
    psum = i[n].fitness;
    for(n = offset+1; n < size; n++) {
	psum += i[n].fitness;
	if( rindex <= psum )
	    return n-1;
    }
    return size-1;
}

/**
 *	P O P _ R A N D --- random number (0,1)
 */
fastf_t
pop_rand (void)
{
    return bn_rand0to1(idx);
}

/**
 *	P O P _ R A N D _ G O P --- return a random genetic operation
 *	TODO: implement other operations, weighted (like wrand) op selection
 */
int
pop_wrand_gop(void)
{
    float i = bn_rand0to1(idx);
    if(i < 0.1)
	return REPRODUCE;
    if(i < 0.3)
	return MUTATE;
    return CROSSOVER;
}

int node_idx;
int crossover_node;
int crossover;
int mutate;
int crossover_op;
int num_nodes;
union tree *crossover_point;
union tree **crossover_parent;
struct node *node;

/**
 *	P O P _ F I N D _ N O D E S --- find nodes with equal # of children
 *	note: not part of pop_functree as a lot less arguments are needed
 *	and it eliminates a lot of overhead
 */
int
pop_find_nodes(	union tree *tp)
{
    int n1, n2;
    struct node *add;

    if(!tp)
	return 0;

    switch(tp->tr_op){
	case OP_DB_LEAF:
	    return 1;
	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
	    crossover_parent = &tp->tr_b.tb_left;
	    n1 = pop_find_nodes(tp->tr_b.tb_left);
	    if(n1 == crossover_node){
		if(tp->tr_b.tb_left->tr_op & crossover_op){
		add = bu_malloc(sizeof(struct node), "node");
		add->s_parent = &tp->tr_b.tb_left;
		add->s_child = tp->tr_b.tb_left;
		BU_LIST_INSERT(&node->l, &add->l);
		++num_nodes;
		}
	    }
	    crossover_parent = &tp->tr_b.tb_right;
	    n2 = pop_find_nodes(tp->tr_b.tb_right);
	    if(n2 == crossover_node){
		if(tp->tr_b.tb_right->tr_op & crossover_op){
		add = bu_malloc(sizeof(struct node), "node");
		add->s_parent = &tp->tr_b.tb_right;
		add->s_child = tp->tr_b.tb_right;
		BU_LIST_INSERT(&node->l, &add->l);
		++num_nodes;
		}
	    }
	    /* include current node as part of the count to
	     * mirror the behavior of db_count_tree_nodes() */
	    return 1+n1 + n2;
    }

    return 0;
}


void
pop_mutate(int type, genptr_t ptr)
{
    int i;
    switch(type) {
	case ID_ELL:
	    VMUTATE(((struct rt_ell_internal *)ptr)->v);
	    VMUTATE(((struct rt_ell_internal *)ptr)->a);
	    VMUTATE(((struct rt_ell_internal *)ptr)->b);
	    VMUTATE(((struct rt_ell_internal *)ptr)->c);
	    break;
	case ID_TGC:
	    VMUTATE(((struct rt_tgc_internal *)ptr)->v);
	    VMUTATE(((struct rt_tgc_internal *)ptr)->h);
	    VMUTATE(((struct rt_tgc_internal *)ptr)->a);
	    VMUTATE(((struct rt_tgc_internal *)ptr)->b);
	    VMUTATE(((struct rt_tgc_internal *)ptr)->c);
	    VMUTATE(((struct rt_tgc_internal *)ptr)->d);
	    break;
	case ID_ARB8:
	    for(i=0; i < 8; i++)
		VMUTATE(((struct rt_arb_internal *)ptr)->pt[i]);

	default:
	    break;
    }
}






void
pop_functree(struct db_i *dbi_p, struct db_i *dbi_c,
		    union tree *tp,
		    struct resource *resp,
		    char *name
	)
{
    struct directory *dp;
    struct rt_db_internal in;
    char shape[256];

    if( !tp ){
	return;
    }
    if(crossover){
	if(node_idx > crossover_node) return;
	if(node_idx == crossover_node){
	    crossover_point = tp;
	    ++node_idx;
	    return;
	}
	else
	    ++node_idx;
    } else if(mutate)
	++node_idx;

    switch( tp->tr_op )  {

	case OP_DB_LEAF:
	    /* dont need to do any processing if crossing over */
	    if(crossover){
		return;
	    }


	    /* if we aren't crossing over, we copy the individual into the
	     * new database. If we're mutating, mutate the object after loading
	     * the internetal object */

	    if( !rt_db_lookup_internal(dbi_p, tp->tr_l.tl_name, &dp, &in, LOOKUP_NOISY, resp))
		bu_exit(EXIT_FAILURE, "Failed to read parent");

	    /* rename leaf based on individual it belongs to */
	    snprintf(shape, 256, "%s-%.3d", name, shape_number++);
	    bu_free(tp->tr_l.tl_name, "bu_strdup");
	    tp->tr_l.tl_name = bu_strdup(shape);

	    /* if we're mutating, and this is the node we've chosen
	     * to modify. mutate this node */
	    if( mutate && node_idx == crossover_node )
		pop_mutate(in.idb_minor_type, in.idb_ptr);


	    /* write child to new database */
	    if((dp=db_diradd(dbi_c, shape, -1, 0, dp->d_flags, (genptr_t)&dp->d_minor_type)) == DIR_NULL)
		bu_exit(EXIT_FAILURE, "Failed to add new object to the database");
	    if(rt_db_put_internal(dp, dbi_c, &in, resp) < 0)
		bu_exit(EXIT_FAILURE, "Failed to write new individual to databse");
	    rt_db_free_internal(&in, resp);

	    break;

	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
	    /* mutate CSG operation */
	    if(mutate)
		if(node_idx == crossover_node){
		  /*  tp->tr_op = (int)(2+pop_rand()*3);//FIXME: pop_rand() can be 1!*/
		}

	    /* if we're performing, save parent as it's right or left pointer will need
	     * to be modified to point to the new child node */
	    if(crossover && node_idx == crossover_node)
		crossover_parent = &tp->tr_b.tb_left;
	    pop_functree( dbi_p, dbi_c, tp->tr_b.tb_left, resp, name);
	    if(crossover && node_idx == crossover_node)
		crossover_parent = &tp->tr_b.tb_right;
	    pop_functree( dbi_p, dbi_c, tp->tr_b.tb_right, resp, name);
	    break;

	default:
	    bu_exit(EXIT_FAILURE,  "pop_functree: unrecognized operator\n" );
    }
}

void
pop_gop(int gop, char *parent1_id, char *parent2_id, char *child1_id, char *child2_id, struct db_i *dbi_p, struct db_i *dbi_c, struct resource *resp)
{
    struct rt_db_internal in1, in2;
    struct rt_comb_internal *parent1;
    struct rt_comb_internal *parent2;
    struct directory *dp;
    union tree *cpoint, **cross_parent;
    struct node *add;
    int i = 0;
    struct node *chosen_node;
    int rand_node;

    RT_CHECK_DBI( dbi_p );
    RT_CHECK_DBI( dbi_c );
    RT_CK_RESOURCE( resp );


    crossover_point = (union tree *)NULL;
    crossover_parent = (union tree **)NULL;
    node = (struct node*)NULL;

    if( !rt_db_lookup_internal(dbi_p, parent1_id, &dp, &in1, LOOKUP_NOISY, &rt_uniresource))
	bu_exit(EXIT_FAILURE, "Failed to read parent1");
    shape_number =num_nodes= 0;
    parent1 = (struct rt_comb_internal *)in1.idb_ptr;
    mutate = 0;
    switch(gop){
	case REPRODUCE:
	    pop_functree(dbi_p, dbi_c, parent1->tree, resp, child1_id);
	    break;
	case CROSSOVER:

	    crossover = 1;
	    /*load other parent */
	    if( !rt_db_lookup_internal(dbi_p, parent2_id, &dp, &in2, LOOKUP_NOISY, resp))
		bu_exit(EXIT_FAILURE, "Failed to read parent2");
	    parent2 = (struct rt_comb_internal *)in2.idb_ptr;

	    node = bu_malloc(sizeof(struct node), "node");
	    BU_LIST_INIT(&node->l);
	    chosen_node = NULL;

	    do{
		num_nodes = 0;
		crossover_parent = &parent1->tree;
		crossover_node = (int)(pop_rand() * db_count_tree_nodes(parent1->tree,0));
		node_idx = 0;
		pop_functree(dbi_p, dbi_c, parent1->tree, resp, NULL);
		cross_parent = crossover_parent;
		cpoint = crossover_point;


		crossover_op = crossover_point->tr_op;
#define MASK (OP_UNION | OP_XOR | OP_SUBTRACT|OP_INTERSECT)
		if(crossover_op & MASK)crossover_op = MASK;
		crossover_node = db_count_tree_nodes(crossover_point, 0);
		if(pop_find_nodes(parent2->tree) == crossover_node){
		    add = bu_malloc(sizeof(struct node), "node");
		    add->s_parent = &parent2->tree;
		    add->s_child = parent2->tree;
		    BU_LIST_INSERT(&node->l, &add->l);
		    ++num_nodes;
		}
		if(num_nodes > 0){
		    rand_node = (int)(pop_rand() * num_nodes);
		    for(add=BU_LIST_FIRST(node, &node->l);BU_LIST_NOT_HEAD(add, &node->l) && chosen_node == NULL; add=BU_LIST_PNEXT(node, add)){
			if(i++ == rand_node){
			    chosen_node = add;
			    /* break cleanly...? */
			}
		    }
		}
	    }while(chosen_node == NULL);


	    /* cross trees */
	    *cross_parent = chosen_node->s_child,resp;
	    *chosen_node->s_parent =cpoint;

	    while(BU_LIST_WHILE(add, node, &node->l)){
		BU_LIST_DEQUEUE(&add->l);
		bu_free(add, "node");
	    }
	    bu_free(node, "node");


	    crossover = 0;

	    /*duplicate shapes held in trees*/
	    pop_functree(dbi_p, dbi_c, parent1->tree, resp, child1_id);
	    shape_number = 0;
	    pop_functree(dbi_p, dbi_c, parent2->tree, resp, child2_id);


	    if((dp = db_diradd(dbi_c, child2_id, -1, 0, dp->d_flags, (genptr_t)&dp->d_minor_type)) == DIR_NULL)
		bu_exit(EXIT_FAILURE, "Failed to add new individual to child database");
	    rt_db_put_internal(dp, dbi_c, &in2, resp);
	    rt_db_free_internal(&in2, resp);

	    break;
	case MUTATE:
	    crossover_parent = &parent1->tree;
	    crossover_node = (int)(pop_rand() * db_count_tree_nodes(parent1->tree, 0));
	    node_idx = 0;
	    mutate = 1;
	    pop_functree(dbi_p, dbi_c, parent1->tree, resp, child1_id);
	    mutate = 0;
	    break;
	    /*
	    //random node to mutate
	    n = (int)(pop_rand() * db_count_tree_nodes(parent1->tree,0));
	    s_parent = &parent1->tree;
	    s_node = n;
	    node = 0;
	    //find node
	    pop_functree(dbi_p, dbi_c, parent1->tree, resp, NULL);
*/




	default:
	    bu_exit(EXIT_FAILURE, "illegal genetic operator\nfailed to execute genetic op");
    }


    if((dp=db_diradd(dbi_c, child1_id, -1, 0, dp->d_flags, (genptr_t)&dp->d_minor_type)) == DIR_NULL){
	bu_exit(EXIT_FAILURE, "Failed to add new individual to child database");
    }
    rt_db_put_internal(dp, dbi_c,  &in1, resp);
    rt_db_free_internal(&in1, resp);
}



/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.29
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d535 1
a535 2
	    bu_log("illegal genetic operator");
	    bu_exit(EXIT_FAILURE, "failed to execute genetic op");
@


1.28
log
@change c++/c99 "//" comments to more portable c89 /* */ comments
@
text
@d166 1
a166 1
	bu_bomb("Failed to re-open initial population");
d168 1
a168 1
	bu_bomb("Failed to load initial database");
d365 1
a365 1
		bu_bomb("Failed to read parent");
d380 1
a380 1
		bu_bomb("Failed to add new object to the database");
d382 1
a382 1
		bu_bomb("Failed to write new individual to databse");
d408 1
a408 1
	    bu_bomb( "pop_functree: unrecognized operator\n" );
d435 1
a435 1
	bu_bomb("Failed to read parent1");
d448 1
a448 1
		bu_bomb("Failed to read parent2");
d508 1
a508 1
		bu_bomb("Failed to add new individual to child database");
d536 1
a536 1
	    bu_bomb("failed to execute genetic op");
d541 1
a541 1
	bu_bomb("Failed to add new individual to child database");
@


1.27
log
@removed trailing whitespace
@
text
@d127 1
a127 1
	    //VSETALL(p1, -10+pop_rand()*10);
@


1.26
log
@slight population modification
@
text
@d49 1
a49 1
#include "beset.h" 
d54 1
a54 1
int shape_number; 
d60 1
a60 1
void 
d69 1
a69 1
    
d87 1
a87 1
void 
d103 1
a103 1
void 
d109 1
a109 1
    double r1, r2, r3; 
d113 1
a113 1
    p->db_p = db_create("gen000", 5); 
d115 1
a115 1
 
d176 1
a176 1
void 
d219 1
a219 1
int 
d242 1
a242 1
 *	note: not part of pop_functree as a lot less arguments are needed 
d253 1
a253 1
    
d283 1
a283 1
	    /* include current node as part of the count to 
d292 1
a292 1
void 
d298 4
a301 4
	    VMUTATE(((struct rt_ell_internal *)ptr)->v); 
	    VMUTATE(((struct rt_ell_internal *)ptr)->a); 
	    VMUTATE(((struct rt_ell_internal *)ptr)->b); 
	    VMUTATE(((struct rt_ell_internal *)ptr)->c); 
d363 1
a363 1
	    
@


1.25
log
@fitness now scales to union of bounding boxes. other slight modifications
@
text
@d126 5
a130 2
	for(j = 0; j < 5; j++){
	    VSETALL(p1, -10+pop_rand()*10);
@


1.24
log
@pre-generate and store identifiers. more cleanup
@
text
@d71 1
d76 1
d106 2
a107 2
    int i;
    point_t p1, p2; /* , p3; */
d109 1
a109 1
    double r1, r2; /* , r3; */
d117 2
a120 11

	p1[0] = -10+pop_rand()*10;
	p1[1] = -10+pop_rand()*10;
	p1[2] = -10+pop_rand()*10;
	r1 = 1+3*pop_rand();

	p2[0] = -10+pop_rand()*10;
	p2[1] = -10+pop_rand()*10;
	p2[2] = -10+pop_rand()*10;
	r2 = 1+3*pop_rand();
	
a121 6
	p3[0] = -10+pop_rand()*10;
	p3[1] = -10+pop_rand()*10;
	p3[2] = -10+pop_rand()*10;
	r3 = 1+3*pop_rand();
	*/
/*
d126 8
d138 1
d149 3
a151 4
	/*
	snprintf(NL_P(p->parent[i].id), 256, "gen%.3dind%.3d-%.3d", 0,i,2);
	mk_sph(db_fp, NL_P(p->parent[i].id), p3, r3);
	mk_addmember(NL_P(p->parent[i].id), &wm_hd.l, NULL, WMOP_UNION);
a152 3



@


1.23
log
@now conforms to C89
@
text
@d63 1
d67 9
a75 3
    p->db_p = db_create("gen000", 5); 
    p->db_p->dbi_wdbp = wdb_dbopen(p->db_p, RT_WDB_TYPE_DB_DISK);
    p->db_c = DBI_NULL;
d88 4
d102 1
a102 1
pop_spawn (struct population *p, struct rt_wdb *db_fp)
d109 5
d142 1
d144 3
a146 3
	snprintf(p->parent[i].id, 256, "gen%.3dind%.3d-%.3d", 0,i,0);
	mk_sph(db_fp, p->parent[i].id, p1, r1);
	mk_addmember(p->parent[i].id, &wm_hd.l, NULL, WMOP_UNION);
d149 3
a151 3
	snprintf(p->parent[i].id, 256, "gen%.3dind%.3d-%.3d", 0,i,1);
	mk_sph(db_fp, p->parent[i].id, p2, r2);
	mk_addmember(p->parent[i].id, &wm_hd.l, NULL, WMOP_UNION);
d154 3
a156 3
	snprintf(p->parent[i].id, 256, "gen%.3dind%.3d-%.3d", 0,i,2);
	mk_sph(db_fp, p->parent[i].id, p3, r3);
	mk_addmember(p->parent[i].id, &wm_hd.l, NULL, WMOP_UNION);
d161 1
a161 2
	snprintf(p->parent[i].id, 256, "gen%.3dind%.3d", 0, i);
	mk_lcomb(db_fp, p->parent[i].id, &wm_hd, 1, NULL, NULL, NULL, 0);
@


1.22
log
@fixed some bugs recently introduced. fstate no longer malloc'd
@
text
@d49 1
a49 1
#include "beset.h" // GOP options
d52 1
a52 1
//narsty globals -- move to main() ?
d66 1
a66 1
    p->db_p = db_create("gen000", 5); //FIXME: variable names
d71 1
a71 1
    // init in main() bn_rand_init(idx, SEED);
d372 1
a372 1
	    rt_db_free_internal(&in, resp);//error check?
d383 1
a383 1
		  //  tp->tr_op = (int)(2+pop_rand()*3);//FIXME: pop_rand() can be 1!
a403 4
    RT_CHECK_DBI( dbi_p );
    RT_CHECK_DBI( dbi_c );
    RT_CK_RESOURCE( resp );

d411 8
a421 3
    
    struct node *chosen_node;
    int rand_node;
d435 1
a435 1
	    //load other parent
a439 3
	    //temp: swap left trees
	    //pick two random nodes
	    //head node is the node we want to cross
d442 1
a443 3
	    	   
	    
	    chosen_node = NULL;
d467 1
a467 1
		    for(BU_LIST_FOR(add, node, &node->l)){
d470 1
a470 1
			    //BREAK CLEANLY!?!?
d477 1
a477 2
	    
	    //TODO: MEMORY LEAKS
a487 2


d490 1
a490 1
	    //duplicate shapes held in trees
@


1.21
log
@quell several warnings
@
text
@a414 1

d421 1
d432 1
@


1.20
log
@some documentation. re-initialize global vars every iteration.
@
text
@d94 1
a94 1
    point_t p1, p2, p3;
d96 1
a96 1
    double r1, r2, r3;
d98 1
a98 2
    for(i = 0; i < p->size; i++)
    {
d276 2
d415 4
a418 1
    crossover_point = crossover_parent = node = NULL;
@


1.19
log
@no need to malloc a single struct once, just use it
@
text
@d273 2
d414 1
@


1.18
log
@more mutation support and cosmetics
@
text
@d61 1
a61 1
pop_init (struct population **p, int size)
d63 6
a68 8
    *p = bu_malloc(sizeof(struct population), "population");

    (*p)->parent = bu_malloc(sizeof(struct individual) * size, "parent");
    (*p)->child  = bu_malloc(sizeof(struct individual) * size, "child");
    (*p)->size = size;
    (*p)->db_p = db_create("gen000", 5); //FIXME: variable names
    (*p)->db_p->dbi_wdbp = wdb_dbopen((*p)->db_p, RT_WDB_TYPE_DB_DISK);
    (*p)->db_c = DBI_NULL;
a82 1
    bu_free(p, "population");
@


1.17
log
@now able to keep an upper % of population and kill a lower %. general code cleanup.
@
text
@d233 5
d281 27
d325 1
a325 1
    if( !tp )
d327 1
d337 1
a337 2
    }
    else if(mutate)
d343 2
a344 1
	    if(crossover)
d346 1
d348 5
d356 1
a356 1
	    //rename tree
a359 26
#define VSCALE_SELF(a,c) { (a)[X] *= (c); (a)[Y] *= (c); (a)[Z]*=(c);}
#define VMUT(a,c){(a)[X] += ((a)[X] == 0)?0:(c); (a)[Y] += ((a)[Y] == 0)?0:(c); (a)[Z]+=((a)[Z]==0)?0:(c);}
#define MUT_STEP .8

	    if(mutate){
		if(node_idx == crossover_node){
		    switch(in.idb_minor_type){
			case ID_ELL:
			    /*
			    VSCALE_SELF(((struct rt_ell_internal *)in.idb_ptr)->v,  .3+2*pop_rand()); 
			    VSCALE_SELF(((struct rt_ell_internal *)in.idb_ptr)->a, .3+2*pop_rand());
			    VSCALE_SELF(((struct rt_ell_internal *)in.idb_ptr)->b, .3+2*pop_rand());
			    VSCALE_SELF(((struct rt_ell_internal *)in.idb_ptr)->c, .3+2*pop_rand());
			    */
			    VMUT(((struct rt_ell_internal *)in.idb_ptr)->v, -MUT_STEP/2+MUT_STEP*pop_rand()); 
			    /*
			    VMUT(((struct rt_ell_internal *)in.idb_ptr)->a,  -MUT_STEP/2+MUT_STEP*pop_rand()); 
			    VMUT(((struct rt_ell_internal *)in.idb_ptr)->b, -MUT_STEP/2+MUT_STEP*pop_rand()); 
			    VMUT(((struct rt_ell_internal *)in.idb_ptr)->c, -MUT_STEP/2+MUT_STEP*pop_rand()); 
			    */
			    
			default:
			    break;
		    }
		}
	    }
d361 4
d367 1
a375 1

d380 2
a381 1
	    if(mutate){
d385 3
a387 1
	    }
d395 1
a396 1
	    bu_log( "pop_functree: unrecognized operator %d\n", tp->tr_op );
d478 2
a479 2
	    *cross_parent = db_dup_subtree(chosen_node->s_child,resp);
	    *chosen_node->s_parent =db_dup_subtree(cpoint,resp);
@


1.16
log
@final bug fixed in fitness. crossover and reproduction are stable and functional
@
text
@d116 1
d121 1
d140 1
d144 1
d185 1
a185 1
pop_wrand_ind(struct individual *i, int size, fastf_t total_fitness)
d187 1
a187 1
    int n = 0;
a189 1

d191 1
a191 1
    for(n = 1; n < size; n++) {
d218 2
d226 1
d305 2
d321 28
d363 5
d390 1
a390 1
    struct rt_comb_internal *parent2, *swap;
d392 1
a392 1
    union tree *cpoint, **tmp, **cross_parent;
d402 1
a402 1

d485 6
@


1.15
log
@tweaks to selection. now converges on one sphere
@
text
@d97 1
a97 1
    point_t p1, p2;
d99 1
a99 1
    double r1, r2;
d115 10
d138 5
@


1.14
log
@fitness function should be working, so selection must be broken
@
text
@d106 3
a108 3
	p1[0] = -4+pop_rand()*4;
	p1[1] = -4+pop_rand()*4;
	p1[2] = -4+pop_rand()*4;
d111 3
a113 3
	p2[0] = -4+pop_rand()*4;
	p2[1] = -4+pop_rand()*4;
	p2[2] = -4+pop_rand()*4;
a122 1
	/*
a126 1
	*/
@


1.13
log
@more tweaks. two separated spheres still don't work...
@
text
@d106 9
a114 9
	p1[0] = -20+pop_rand()*20;
	p1[1] = -20+pop_rand()*20;
	p1[2] = -20+pop_rand()*20;
	r1 = 2+4*pop_rand();

	p2[0] = -20+pop_rand()*20;
	p2[1] = -20+pop_rand()*20;
	p2[2] = -20+pop_rand()*20;
	r2 = 2+4*pop_rand();
d123 1
d128 1
d174 1
a174 1
    psum += i[n].fitness;
d205 1
a205 1
int node;
d208 2
d212 49
d277 2
a278 2
	if(node > crossover_node) return;
	if(node == crossover_node){
d280 1
a280 1
	    ++node;
d284 1
a284 1
	    ++node;
d314 1
a314 1
	    if(crossover && node == crossover_node)
d317 1
a317 1
	    if(crossover && node == crossover_node)
d339 2
d342 2
d346 1
a346 1
    shape_number = 0;
d362 5
d368 33
a400 12
	    if(db_count_tree_nodes(parent2->tree,0) == 1){
		swap = parent1;
		parent1 = parent2;
		parent2 = swap;
	    }
	    
	    crossover_parent = &parent1->tree;
	    crossover_node = (int)(pop_rand() * db_count_tree_nodes(parent1->tree,0));
	    node = 0;
	    pop_functree(dbi_p, dbi_c, parent1->tree, resp, NULL);
	    cross_parent = crossover_parent;
	    cpoint = crossover_point;
a401 7
	    do{
		crossover_parent = &parent2->tree;
		crossover_node = (int)(pop_rand() * db_count_tree_nodes(parent2->tree,0));
		node = 0;
		pop_functree(dbi_p, dbi_c, parent2->tree, resp, NULL);//search for node
	    } while(cpoint->tr_op != OP_DB_LEAF && crossover_point->tr_op == OP_DB_LEAF); //fixme, union and intersects can cross
	
d404 10
a413 2
	    *cross_parent = db_dup_subtree(crossover_point,resp);
	    *crossover_parent =db_dup_subtree(cpoint,resp);
@


1.12
log
@memory leak finally fixed. updated fitness function, much better results.
@
text
@d106 9
a114 9
	p1[0] = -10+pop_rand()*10;
	p1[1] = -10+pop_rand()*10;
	p1[2] = -10+pop_rand()*10;
	r1 = 10*pop_rand();

	p2[0] = -10+pop_rand()*10;
	p2[1] = -10+pop_rand()*10;
	p2[2] = -10+pop_rand()*10;
	r2 = 10*pop_rand();
d198 1
a198 1
    if(i < 0.5)
a283 1
    struct rt_comb_internal *child1, *child2;
a286 3
    int nodes; //number of nodes
    int node1, node2;

d346 14
@


1.11
log
@more cosmetics and options updates
@
text
@d252 2
d347 1
d361 1
@


1.10
log
@working crossover and reproduction. implementation works, but is going to need a lot of tweaking.
@
text
@d68 1
a68 1
    (*p)->db_p = db_create("gen00", 5); //FIXME: variable names
d132 11
d170 1
a170 1
    rindex = bn_rand0to1(idx) * total_fitness;
d202 1
@


1.9
log
@moved back from bu_external to rt_db_internal structs. removed now useless pop_dup_internal.
@
text
@d188 2
a189 2
	return MUTATE_MOD;
    return MUTATE_RAND;
d191 6
d211 10
d225 3
d242 1
d247 2
d250 2
d261 1
a261 1
pop_dup(char *parent, char *child, struct db_i *dbi_p, struct db_i *dbi_c, struct resource *resp)
a262 1
    printf("pop dup\n");
a265 1
    printf("pop check done\n");
d267 4
a270 2
    struct rt_db_internal in;
    struct rt_comb_internal *comb;
d272 4
d277 2
a278 2
    if( !rt_db_lookup_internal(dbi_p, parent, &dp, &in, LOOKUP_NOISY, &rt_uniresource))
	bu_bomb("Failed to read parent");
d280 61
a340 3
    comb = (struct rt_comb_internal *)in.idb_ptr;
    //rename combination
    pop_functree(dbi_p, dbi_c, comb->tree, resp, child);
d342 1
a342 1
    if((dp=db_diradd(dbi_c, child, -1, 0, dp->d_flags, (genptr_t)&dp->d_minor_type)) == DIR_NULL){
d345 1
a345 1
    rt_db_put_internal(dp, dbi_c,  &in, resp);
@


1.8
log
@fixed issue with renaming directory pointers, combination trees are now supported
@
text
@d51 2
a52 1
//cut when pop_random() updated
d54 2
a55 1
int shape_number; //ugly but keeping
a73 1
    // fix this and modularize somehow
d200 1
a200 1
    struct bu_external ext;
d209 3
a211 4
	    if( (dp=db_lookup( dbi_p, tp->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL ){
		printf("failed to look up %s\n", tp->tr_l.tl_name);
		return;
	    }
a216 2
	    if( db_get_external(&ext, dp, dbi_p))
		bu_bomb("failed to read a leaf");
d219 2
a220 2
	    if(db_put_external(&ext,dp, dbi_c ) < 0)
		bu_bomb("failed to write leaf");
d249 1
a249 7
    if( (dp = db_lookup(dbi_p, parent, LOOKUP_NOISY)) == DIR_NULL){
	printf("PARENT LOOKUP FAILED, EXITING\n");
	exit(1);
	bu_bomb("db_lookup(parent) failed");
    }
    /*
    if(db_get_external(&ext, dp, dbi_p))
a250 8
    printf("converting...\n");
    RT_INIT_DB_INTERNAL(&in);
    if(rt_db_external5_to_internal5(&in, &ext, child, dbi_p, NULL, resp) < 0)
	bu_bomb("Faield to convert parent from external to internal");
    printf("converted\n");
    */
    if(rt_db_get_internal(&in, dp, dbi_p, NULL, resp) < 0 )
	bu_bomb("pop_dup: faled to load");
a255 5
    /*if(db_get_external(&ext, dp, dbi_p))
	bu_bomb("failed to read leaf");
	*/
//    rt_db_free_internal(&in, resp);
    
d259 1
a259 7
    printf("putting external\n");
    pop_put_internal(child, dp, dbi_c,  &in, resp);
    printf("external put\n");

    printf("done dup\n");

    
a262 52
int
pop_put_internal(
	const char		*name,
	struct directory	*dp,
	struct db_i		*dbip,
	struct rt_db_internal	*ip,
	struct resource		*resp)
{
	struct bu_external	ext;

	RT_CK_DIR(dp);
	RT_CK_DBI(dbip);
	RT_CK_DB_INTERNAL( ip );
	RT_CK_RESOURCE(resp);

	BU_ASSERT_LONG( dbip->dbi_version, ==, 5 );

	if( rt_db_cvt_to_external5( &ext, dp->d_namep, ip, 1.0, dbip, resp, DB5_MAJORTYPE_BRLCAD ) < 0 )  {
		bu_log("rt_db_put_internal5(%s):  export failure\n",
			dp->d_namep);
		goto fail;
	}
	BU_CK_EXTERNAL( &ext );

	if( ext.ext_nbytes != dp->d_len || dp->d_addr == -1L )  {
		if( db5_realloc( dbip, dp, &ext ) < 0 )  {
			bu_log("rt_db_put_internal5(%s) db_realloc5() failed\n", dp->d_namep);
			goto fail;
		}
	}
	BU_ASSERT_LONG( ext.ext_nbytes, ==, dp->d_len );

	if( dp->d_flags & RT_DIR_INMEM )  {
		bcopy( dp->d_un.ptr, (char *)ext.ext_buf, ext.ext_nbytes );
		goto ok;
	}
	//if((dp=db_diradd(dbic, name, -1, 0, dp->d_flags, (genptr_t)&dp->d_minor_type)) == DIR_NULL)
	  //  goto fail;
	if( db_write( dbip, (char *)ext.ext_buf, ext.ext_nbytes, dp->d_addr ) < 0 )  {
		goto fail;
	}
ok:
	bu_free_external( &ext );
	rt_db_free_internal( ip, resp );
	return 0;			/* OK */

fail:
	bu_free_external( &ext );
	rt_db_free_internal( ip, resp );
	return -2;		/* FAIL */
}

@


1.7
log
@more reasonable debugging output
@
text
@d199 1
a199 1
    struct rt_db_internal intern;
d213 1
a213 1
	    snprintf(shape, 256, "%s-%d", name, shape_number++);
a215 2
	    
	   //	    db_rename(dbi_p, dp, shape);
d217 1
a217 1
	    if( rt_db_get_internal(&intern, dp, dbi_p, NULL, resp) < 0)
d219 3
a221 4
	    RT_DIR_FREE_NAMEP(dp);
	    RT_DIR_SET_NAMEP(dp,shape);

	    if(rt_db_put_internal(dp, dbi_c, &intern, resp) < 0)
a222 1
	    rt_db_free_internal(&intern, resp);
d241 1
d245 1
d256 9
a266 1

d272 14
a285 2
    RT_DIR_FREE_NAMEP(dp);
    RT_DIR_SET_NAMEP(dp,child);
a286 2
    rt_db_put_internal(dp, dbi_c, &in, resp);
    rt_db_free_internal(&in, resp);
d289 54
@


1.6
log
@partially working tree implementation. still some bugs to work out...
@
text
@d30 1
d129 1
a129 1
	mk_lcomb(db_fp, p->parent[i].id, &wm_hd, 0, NULL, NULL, NULL, 0);
d208 2
a209 2
	    printf("leaf\n");
	    if( (dp=db_lookup( dbi_p, tp->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
d211 1
a213 1
	    printf("he\n");
d216 2
a217 3
	    printf("%s\n", shape);

	    db_rename(dbi_p, dp, shape);
d221 3
a226 1
	    printf("copied leaf\n");
d253 3
a255 2
    printf("looking up %s\n", parent);
    if( (dp = db_lookup(dbi_p, parent, LOOKUP_NOISY)) == DIR_NULL)
d257 1
a263 2
    db_rename(dbi_p, dp, child);
    printf("calling pop_functree\n");
d265 4
@


1.5
log
@fixed bug where spheres with non-whole radii produced odd results
@
text
@d42 1
d45 1
d51 2
a52 1
unsigned int idx;
d62 2
a63 2
    (*p)->individual = bu_malloc(sizeof(struct individual) * size, "individuals");
    (*p)->offspring  = bu_malloc(sizeof(struct individual) * size, "offspring");
d65 3
a68 2
    //remove when pop_rand() is updated
    //-------8<--------
d70 3
a72 2
    BN_RANDSEED(idx, SEED);
    //-----------------
d81 2
a82 2
    bu_free(p->individual, "individuals");
    bu_free(p->offspring, "offspring");
d95 4
a98 1
    point_t p1 = {0.0, 0.0, 0.0};
d101 28
a128 6
	VSET(p->individual[i].p, 1.0, 5.0, 0.0);
	snprintf(p->individual[i].id, 256, "i%d.s", i);
	p->individual[i].fitness = 0.0;
	p->individual[i].r = 1 + (10.0 * BN_RANDOM(idx));
	p->individual[i].type = GEO_SPHERE;
	mk_sph(db_fp, p->individual[i].id, p->individual[i].p, p->individual[i].r);
d133 2
a134 2
 *	P O P _ A D D --- add an individual to othe database
 *	TODO: Don't overwrite previous individuals, one .g file per generation
d136 1
d146 1
d150 1
a150 1
 *	P O P _ W R A N D -- weighted random index of individual
d157 1
a157 1
    rindex = BN_RANDOM(idx) * total_fitness;
a158 1
    /* EEEEEK WHAT IF RAND() IS ZEROOOOO!?!? */
a169 1
 *	TODO: change to bn_rand0t01() or bn_rand_half()
d174 1
a174 1
    return BN_RANDOM(idx);
d184 2
a185 2
    float i = BN_RANDOM(idx);
    //if(i < 0.5)
d187 51
a237 1
    //return MUTATE_RAND;
d240 28
d270 1
a271 1
 * mode: C
@


1.4
log
@petty cosmetics while browsing, mostly ws
@
text
@d96 1
a96 1
	p->individual[i].r = 1.0+i;//1 + (10.0 * BN_RANDOM(idx));
@


1.3
log
@single sphere partially working
@
text
@d28 1
a29 1
#include "common.h"
a159 9






   


@


1.2
log
@add headers/footers as needed
@
text
@d22 1
a22 1
 * Brief description
d48 1
d51 5
a55 1
void pop_init (struct population **p, int size)
d62 3
a65 1

d67 1
d70 5
a74 1
void pop_clean (struct population *p)
d81 7
a87 1
void pop_spawn(struct population *p, struct rt_wdb *db_fp)
d96 1
a96 2
	p->individual[i].r = 5.0;//1 + (10.0 * BN_RANDOM(idx));
	printf("p->individual[i].r = %g\n", p->individual[i].r);
d102 4
d137 4
d149 1
@


1.1
log
@implemented basic GA framework
@
text
@d1 28
d142 10
@

