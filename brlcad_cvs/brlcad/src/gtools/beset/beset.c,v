head	1.30;
access;
symbols
	rel-7-10-4:1.29
	STABLE:1.29.0.2
	rel-7-10-2:1.29;
locks; strict;
comment	@ * @;


1.30
date	2007.09.14.15.21.06;	author erikgreenwald;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.08.23.38.08;	author poolio;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.06.16.21.19;	author poolio;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.02.19.23.47;	author poolio;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.02.02.26.44;	author poolio;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.02.00.15.10;	author poolio;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.01.21.07.29;	author brlcad;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.01.20.50.17;	author brlcad;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.01.20.26.23;	author brlcad;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.31.21.54.36;	author poolio;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.29.16.34.59;	author poolio;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.28.07.14.55;	author poolio;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.24.19.41.44;	author poolio;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.23.22.09.18;	author poolio;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.20.17.55.51;	author poolio;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.20.14.49.12;	author poolio;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.19.18.19.48;	author poolio;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.18.17.14.09;	author poolio;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.11.15.58.31;	author poolio;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.10.17.34.43;	author poolio;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.10.15.55.42;	author poolio;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.29.04.36.14;	author poolio;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.29.04.11.30;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.29.02.51.00;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.29.01.06.45;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.29.01.00.10;	author poolio;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.29.00.38.43;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.28.18.58.51;	author poolio;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.28.03.56.52;	author poolio;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.21.20.24.55;	author poolio;	state Exp;
branches;
next	;


desc
@@


1.30
log
@removed trailing whitespace
@
text
@/*                         B E S E T . C
 * BRL-CAD
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file beset.c
 *
 * Ben's Evolutionary Shape Tool
 *
 *
 * Author - Ben Poole
 *
 */


#include "common.h"

#include <strings.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "plot3.h"
#include "wdb.h"

#include "fitness.h"
#include "population.h"
#include "beset.h"
struct rt_db_internal source_obj;


void usage(){fprintf(stderr, "Usage: %s [options] db.g object\nOptions:\n -p #\t\tPopulation size\n -g #\t\tNumber of generations\n -r #\t\tResolution \n -u #\t\tUpper percent of individuals to keep\n -l #\t\tLower percent of individuals to kill\n",bu_getprogname());exit(1);}


/* fitness of a given object compared to source */
static int cmp_ind(const void *p1, const void *p2)
{
    if(((struct individual *)p2)->fitness > ((struct individual *)p1)->fitness)
	return -1;
    else if (((struct individual *)p2)->fitness == ((struct individual *)p1)->fitness)
	return 0;
    else
	return 1;
}

int
parse_args (int ac, char *av[], struct options *opts)
{
    int c;

    bu_setprogname(av[0]);
    /* handle options */
    bu_opterr = 0;
    bu_optind = 0;
    av++; ac--;

    while ((c=bu_getopt(ac,av,OPTIONS)) != EOF) {
	switch (c) {
	    case 'm':
		opts->mut_rate = atoi(bu_optarg);
		continue;
	    case 'c':
		opts->cross_rate = atoi(bu_optarg);
		continue;
	    case 'x':
		sscanf(bu_optarg, "%x", (unsigned int *)&rt_g.debug );
		continue;
	    case 'p':
		opts->pop_size = atoi(bu_optarg);
		continue;
	    case 'g':
		opts->gens = atoi(bu_optarg);
		continue;
	    case 'r':
		opts->res = atoi(bu_optarg);
		continue;
	    case 'u':
		opts->keep_upper = atoi(bu_optarg);
		continue;
	    case 'l':
		opts->kill_lower = atoi(bu_optarg);
		continue;
	    default:
		fprintf(stderr, "Unrecognized option: -%c\n", c);
		usage();
	}
    }
    opts->keep_upper *= opts->pop_size/100.0;
    opts->kill_lower *= opts->pop_size/100.0;
    return bu_optind;
}



int main(int argc, char *argv[]){
    int i, g; /* generation and parent counters */
    int parent1, parent2;
    int gop;
    int best,worst;
    fastf_t total_fitness = 0.0f;
    struct fitness_state fstate;
    struct population pop = {NULL,NULL,NULL,NULL,NULL,0};
    char dbname[256] = {0};
    struct options opts = {DEFAULT_POP_SIZE, DEFAULT_GENS, DEFAULT_RES, 0, 0};
    struct individual *tmp = NULL;
    int  ac;
    struct directory *dp;
    int d_flags;
    unsigned char d_minor_type;
    struct db_i *source_db;


    ac = parse_args(argc, argv, &opts);
    if(argc - ac != 3)
	usage();


    /* read source model into fstate.rays */
    fit_prep(&fstate, opts.res, opts.res);
    fit_store(argv[ac+2], argv[ac+1], &fstate);


    /* initialize population and spawn initial individuals */
    pop_init(&pop, opts.pop_size);
    pop_spawn(&pop);

    source_db = db_open(argv[ac+1], "r+w");
    db_dirbuild(source_db);
       pop.db_c = db_create("testdb", 5);
    db_close(pop.db_c);


    for(g = 1; g < opts.gens; g++ ){
#ifdef VERBOSE
	printf("\nGeneration %d:\n"
		"--------------\n", g);
#endif

	total_fitness = 0.0f;
	best = worst = 0;

	snprintf(dbname, 256, "gen%.3d", g);
	pop.db_c = db_create(dbname, 5);

	pop_gop(REPRODUCE, argv[ac+2], NULL, argv[ac+2], NULL, source_db, pop.db_c, &rt_uniresource);



	/* calculate sum of all fitnesses and find
	 * the most fit individual in the population
	 * note: need to calculate outside of main pop
	 * loop because it's needed for pop_wrand_ind()*/
	for(i = 0; i < pop.size; i++) {
	   fit_diff(NL(pop.parent[i].id), pop.db_p, &fstate);
	   pop.parent[i].fitness = fstate.fitness;
	   total_fitness += FITNESS;
	}
	/* sort population - used for keeping top N and dropping bottom M */
	qsort(pop.parent, pop.size, sizeof(struct individual), cmp_ind);

	/* remove lower M of individuals */
	for(i = 0; i < opts.kill_lower; i++) {
	    total_fitness -= pop.parent[i].fitness;
	}


	printf("Most fit from %s was %s with a fitness of %g\n", dbname, NL(pop.parent[pop.size-1].id), pop.parent[pop.size-1].fitness);
	printf("%6.8g\t%6.8g\t%6.8g\n", total_fitness/pop.size, pop.parent[0].fitness, pop.parent[pop.size-1].fitness);
	for(i = 0; i < pop.size; i++){

	    pop.child[i].id = i;

	    /* keep upper N */
	    if(i >= pop.size - opts.keep_upper){
		pop_gop(REPRODUCE, NL(pop.parent[i].id), NULL, NL(pop.child[i].id), NULL,
			pop.db_p, pop.db_c, &rt_uniresource);
		continue;
	    }

	    /* Choose a random genetic operation and
	     * a parent which the op will be performed on*/
	    gop = pop_wrand_gop();
	    parent1 = pop_wrand_ind(pop.parent, pop.size, total_fitness, opts.kill_lower);
	    /* only need 1 more individual, can't crossover, so reproduce */
	    if(gop == CROSSOVER && i >= pop.size-opts.keep_upper-1)gop=REPRODUCE;

	    if(gop & (REPRODUCE | MUTATE)){
#ifdef VERBOSE
		printf("r(%s)\t ---------------> (%s)\n", NL(pop.parent[parent1].id), NL(pop.child[i].id));
#endif
		/* perform the genetic operation and output the child to the child database */
		pop_gop(gop, NL(pop.parent[parent1].id), NULL, NL(pop.child[i].id), NULL,
			pop.db_p, pop.db_c, &rt_uniresource);
	    } else {
	    /* If we're performing crossover, we need a second parent */
		parent2 = pop_wrand_ind(pop.parent, pop.size, total_fitness, opts.kill_lower);
		++i;
		pop.child[i].id = i;

#ifdef VERBOSE
		printf("x(%s, %s) --> (%s, %s)\n", NL(pop.parent[parent1].id), NL(pop.parent[parent2].id), pop.child[i-1].id, pop.child[i].id);
#endif
		/* perform the genetic operation and output the children to the cihld database */
		pop_gop(gop, NL(pop.parent[parent1].id), NL(pop.parent[parent2].id), NL(pop.child[i-1].id), NL(pop.child[i].id),
			pop.db_p, pop.db_c, &rt_uniresource);
	    }

	}



	/* Close parent db and move children
	 * to parent database and population
	 * Note: pop size is constant so we
	 * can keep the storage from the previous
	 * pop.parent for the next pop.child*/
	db_close(pop.db_p);
	pop.db_p = pop.db_c;
	tmp = pop.child;
	pop.child = pop.parent;
	pop.parent = tmp;

    }
    db_close(pop.db_p);

#ifdef VERBOSE
    printf("\nFINAL POPULATION\n"
	    "----------------\n");
    for(i = 0; i < pop.size; i++)
	printf("%s\tf:%.5g\n",NL(pop.child[i].id),
		pop.child[i].fitness);
#endif


    pop_clean(&pop);
    fit_clean(&fstate);
    return 0;
}



/*
 * Local Variables:
 * tab-width: 8
 * mode: C
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.29
log
@fitness now scales to union of bounding boxes. other slight modifications
@
text
@d125 1
a125 1
    char dbname[256] = {0}; 
d138 1
a138 1
    
d142 1
a142 1
    fit_store(argv[ac+2], argv[ac+1], &fstate); 
d154 1
a154 1
    
d157 1
a157 1
	printf("\nGeneration %d:\n" 
d162 1
a162 1
	best = worst = 0; 
d168 1
a168 1
 
d207 1
a207 1
	    if(gop == CROSSOVER && i >= pop.size-opts.keep_upper-1)gop=REPRODUCE; 
d222 1
a222 1
#ifdef VERBOSE 
d228 2
a229 2
	    } 
	    
d234 1
a234 1
	/* Close parent db and move children 
d237 1
a237 1
	 * can keep the storage from the previous 
d252 1
a252 1
	printf("%s\tf:%.5g\n",NL(pop.child[i].id), 
@


1.28
log
@pre-generate and store identifiers. more cleanup
@
text
@d51 1
d81 6
d129 4
d144 1
d148 6
d167 4
d189 1
a189 1
	printf("Most fit individual was %s with a fitness of %g\n", NL(pop.parent[pop.size-1].id), pop.parent[pop.size-1].fitness);
a190 1

a216 1
	    
d232 2
d246 1
d257 1
a258 1
    pop_clean(&pop);
@


1.27
log
@now conforms to C89
@
text
@d117 1
a117 1
    struct population pop = {NULL,NULL,NULL,NULL,0};
d135 1
a135 1
    pop_spawn(&pop, pop.db_p->dbi_wdbp);
d154 1
a154 1
	   fit_diff(pop.parent[i].id, pop.db_p, &fstate);
d167 1
a167 1
	printf("Most fit individual was %s with a fitness of %g\n", pop.parent[pop.size-1].id, pop.parent[pop.size-1].fitness);
d172 1
a172 1
	    snprintf(pop.child[i].id, 256, "gen%.3dind%.3d", g, i); 
d176 1
a176 1
		pop_gop(REPRODUCE, pop.parent[i].id, NULL, pop.child[i].id, NULL,
d190 1
a190 1
		printf("r(%s)\t ---------------> (%s)\n", pop.parent[parent1].id, pop.child[i].id);
d193 1
a193 1
		pop_gop(gop, pop.parent[parent1].id, NULL, pop.child[i].id, NULL,
d200 1
a200 1
		snprintf(pop.child[i].id, 256, "gen%.3dind%.3d", g, i); 
d203 1
a203 1
		printf("x(%s, %s) --> (%s, %s)\n", pop.parent[parent1].id, pop.parent[parent2].id, pop.child[i-1].id, pop.child[i].id);
d206 1
a206 1
		pop_gop(gop, pop.parent[parent1].id, pop.parent[parent2].id, pop.child[i-1].id, pop.child[i].id,
d229 1
a229 1
	printf("%s\tf:%.5g\n", pop.child[i].id, 
@


1.26
log
@documented -u and -l options
@
text
@d118 1
a118 1
    char dbname[256] = {0}; //name of database
d167 2
a168 2
	printf("Most fit individual was %s with a fitness of %lf\n", pop.parent[pop.size-1].id, pop.parent[pop.size-1].fitness);
	printf("%6.8lf\t%6.8lf\t%6.8lf\n", total_fitness/pop.size, pop.parent[0].fitness, pop.parent[pop.size-1].fitness);
d185 3
a187 3
	    //printf("selected %lf\n", pop.parent[parent1].fitness);
	    /* If we're performing crossover, we need a second parent */
	    if(gop == CROSSOVER && i >= pop.size-opts.keep_upper-1)gop=REPRODUCE; //cannot cross, so reproduce
d197 1
a197 1
		//while(parent2 == parent1) -- needed? can crossover be done on same 2 ind?
a198 1
//		printf("selected: %lf\n", pop.parent[parent2].fitness);
d200 1
a200 1
		snprintf(pop.child[i].id, 256, "gen%.3dind%.3d", g, i); //name the child
@


1.25
log
@fixed some bugs recently introduced. fstate no longer malloc'd
@
text
@d53 1
a53 1
void usage(){fprintf(stderr, "Usage: %s [options] db.g object\nOptions:\n -p #\t\tPopulation size\n -g #\t\tNumber of generations\n -r #\t\tResolution \n",bu_getprogname());exit(1);}
d117 1
a117 1
    struct population pop;
@


1.24
log
@quell several warnings
@
text
@d116 1
a116 1
    struct fitness_state *fstate = NULL;
a128 2
    rt_init_resource(&rt_uniresource,1,NULL);

d130 2
a131 2
    fstate = fit_prep(opts.res, opts.res);
    fit_store(argv[ac+2], argv[ac+1], fstate); 
d154 2
a155 2
	   fit_diff(pop.parent[i].id, pop.db_p, fstate);
	   pop.parent[i].fitness = fstate->fitness;
d162 1
a162 1
	for(i = 0; i < (opts.kill_lower > pop.size ? pop.size : opts.kill_lower); i++) {
d200 1
a201 1
		i++; // increase pop count
d235 1
a235 1
    fit_clean(fstate);
@


1.23
log
@no need to malloc a single struct once, just use it
@
text
@d164 1
a164 1
	for(i = 0; i < opts.kill_lower > pop.size ? pop.size : opts.kill_lower; i++) {
d169 2
a170 2
	printf("Most fit individual was %s with a fitness of %g\n", pop.parent[pop.size-1].id, pop.parent[pop.size-1].fitness);
	printf("%6.8g\t%6.8g\t%6.8g\n", total_fitness/pop.size, pop.parent[0].fitness, pop.parent[pop.size-1].fitness);
d187 1
a187 1
	    //printf("selected %g\n", pop.parent[parent1].fitness);
d201 3
a203 2
//		printf("selected: %g\n", pop.parent[parent2].fitness);
		snprintf(pop.child[i].id, 256, "gen%.3dind%.3d", g, ++i); //name the child and increase pop count
@


1.22
log
@initialize some vars
@
text
@d117 1
a117 1
    struct population *pop = NULL;
d137 2
a138 3
    pop_spawn(pop, pop->db_p->dbi_wdbp);
   
 
d149 1
a149 1
	pop->db_c = db_create(dbname, 5);
d155 3
a157 3
	for(i = 0; i < pop->size; i++) {
	   fit_diff(pop->parent[i].id, pop->db_p, fstate);
	   pop->parent[i].fitness = fstate->fitness;
d161 1
a161 1
	qsort(pop->parent, pop->size, sizeof(struct individual), cmp_ind);
d164 2
a165 2
	for(i = 0; i < opts.kill_lower > pop->size ? pop->size : opts.kill_lower; i++) {
	    total_fitness -= pop->parent[i].fitness;
d169 2
a170 2
	printf("Most fit individual was %s with a fitness of %g\n", pop->parent[pop->size-1].id, pop->parent[pop->size-1].fitness);
	printf("%6.8g\t%6.8g\t%6.8g\n", total_fitness/pop->size, pop->parent[0].fitness, pop->parent[pop->size-1].fitness);
d172 1
a172 1
	for(i = 0; i < pop->size; i++){
d174 1
a174 1
	    snprintf(pop->child[i].id, 256, "gen%.3dind%.3d", g, i); 
d177 3
a179 3
	    if(i >= pop->size - opts.keep_upper){
		pop_gop(REPRODUCE, pop->parent[i].id, NULL, pop->child[i].id, NULL,
			pop->db_p, pop->db_c, &rt_uniresource);
d186 2
a187 2
	    parent1 = pop_wrand_ind(pop->parent, pop->size, total_fitness, opts.kill_lower);
	    //printf("selected %g\n", pop->parent[parent1].fitness);
d189 1
a189 1
	    if(gop == CROSSOVER && i >= pop->size-opts.keep_upper-1)gop=REPRODUCE; //cannot cross, so reproduce
d192 1
a192 1
		printf("r(%s)\t ---------------> (%s)\n", pop->parent[parent1].id, pop->child[i].id);
d195 2
a196 2
		pop_gop(gop, pop->parent[parent1].id, NULL, pop->child[i].id, NULL,
			pop->db_p, pop->db_c, &rt_uniresource);
d200 3
a202 3
		parent2 = pop_wrand_ind(pop->parent, pop->size, total_fitness, opts.kill_lower);
//		printf("selected: %g\n", pop->parent[parent2].fitness);
		snprintf(pop->child[i].id, 256, "gen%.3dind%.3d", g, ++i); //name the child and increase pop count
d205 1
a205 1
		printf("x(%s, %s) --> (%s, %s)\n", pop->parent[parent1].id, pop->parent[parent2].id, pop->child[i-1].id, pop->child[i].id);
d208 2
a209 2
		pop_gop(gop, pop->parent[parent1].id, pop->parent[parent2].id, pop->child[i-1].id, pop->child[i].id,
			pop->db_p, pop->db_c, &rt_uniresource);
d218 6
a223 6
	 * pop->parent for the next pop->child*/
	db_close(pop->db_p);
	pop->db_p = pop->db_c;
	tmp = pop->child;
	pop->child = pop->parent;
	pop->parent = tmp;
d230 3
a232 3
    for(i = 0; i < pop->size; i++)
	printf("%s\tf:%.5g\n", pop->child[i].id, 
		pop->child[i].fitness);
d237 1
a237 1
    pop_clean(pop);
@


1.21
log
@now able to keep an upper % of population and kill a lower %. general code cleanup.
@
text
@d115 4
a118 4
    fastf_t total_fitness;
    struct fitness_state *fstate;
    struct population *pop;
    char dbname[256]; //name of database
d120 1
a120 1
    struct individual *tmp;
d146 2
a147 1
	total_fitness = best =worst= 0; 
d161 1
a161 1
	/* sort population - used for keeping top N and bottom M% */
d164 2
a165 2
	/* remove lower % of individuals */
	for(i = 0; i < opts.kill_lower; i++) {
d168 1
a168 1
 
d177 2
a178 2
	    /* keep upper % */
	    if(i >= pop->size- opts.keep_upper){
@


1.20
log
@tweaks to selection. now converges on one sphere
@
text
@d60 1
a60 1
	return 1;
d64 1
a64 1
	return -1;
d92 6
d103 2
d119 1
a119 1
    struct options opts = {DEFAULT_POP_SIZE, DEFAULT_GENS, DEFAULT_RES};
d138 2
a139 2

    
d156 1
a156 1
	   fit_linDiff(pop->parent[i].id, pop->db_p, fstate);
a157 2
	   if(pop->parent[i].fitness > pop->parent[best].fitness) best = i;
	   if(pop->parent[i].fitness < pop->parent[worst].fitness){ worst = i;}
d160 2
a161 4
	//total_fitness =0;
	//    pop->parent[i].fitness *= (pop->size-i)*(pop->size-i)/pop->size;
	printf("Most fit from generation %3d was: %s, fitness of %g\n", g-1, pop->parent[best].id, pop->parent[best].fitness);
	printf("%8.6g\t%8.6g\t%8.6g\n", total_fitness/pop->size, pop->parent[worst].fitness, pop->parent[best].fitness);
d163 5
a167 1
	qsort(pop->parent, pop->size, sizeof(struct individual), cmp_ind);
d169 2
d174 9
d186 1
a186 1
	    parent1 = pop_wrand_ind(pop->parent, pop->size, total_fitness);
a187 2
	    snprintf(pop->child[i].id, 256, "gen%.3dind%.3d", g, i); 

d189 10
a198 1
	    if(gop == CROSSOVER && i < pop->size-1){
d200 1
a200 1
		parent2 = pop_wrand_ind(pop->parent, pop->size, total_fitness);
d210 1
a210 8
	    } else {
#ifdef VERBOSE
		printf("r(%s)\t ---------------> (%s)\n", pop->parent[parent1].id, pop->child[i].id);
#endif
		/* perform the genetic operation and output the child to the child database */
		pop_gop(REPRODUCE, pop->parent[parent1].id, NULL, pop->child[i].id, NULL,
			pop->db_p, pop->db_c, &rt_uniresource);
	    }
@


1.19
log
@fitness function should be working, so selection must be broken
@
text
@d151 1
a151 1
	   if(pop->parent[i].fitness < pop->parent[worst].fitness) worst = i;
a154 1
	//qsort(pop->parent, pop->size, sizeof(struct individual), cmp_ind);
d159 2
@


1.18
log
@minor tweaks. still struggling on two spheres. i have my doubts as to whether the whole project will work...
@
text
@a146 1
	fastf_t same;
d148 2
a149 8
	   FITNESS = (1 - DIFF)-(abs(1-NODES)/10);//(NODES*5000.0);//(.5+500.0*abs(1-NODES));
	   printf("Same: %g\t Diff: %g\t Same/(Same+diff): %g\n", fstate->same, fstate->diff, fstate->same/(fstate->same+fstate->diff));
	
	   /*
	   if(i == 0)same = FITNESS;
	   if(FITNESS != same)printf("DIFF\n");
*/
//	   pop->parent[i].fitness = (1-fit_linDiff(pop->parent[i].id, pop->db_p, fstate));
d155 2
a156 5
	qsort(pop->parent, pop->size, sizeof(struct individual), cmp_ind);
	for(i = 0; i < pop->size; i++){
	    pop->parent[i].fitness *= (pop->size-i)*(pop->size-i)/pop->size;
	   total_fitness += pop->parent[i].fitness;
	}
d167 1
d174 1
@


1.17
log
@more tweaks. two separated spheres still don't work...
@
text
@d147 1
d149 8
a156 1
	   pop->parent[i].fitness = 2.0/(1+fit_linDiff(pop->parent[i].id, pop->db_p, fstate));
d159 1
d161 1
@


1.16
log
@memory leak finally fixed. updated fitness function, much better results.
@
text
@d106 1
a106 1
    int best;
d138 1
a138 1
	total_fitness = best = 0; 
d150 1
d158 1
@


1.15
log
@more cosmetics and options updates
@
text
@d132 1
a132 1
    for(g = 1; g < opts.gens; g++){
d150 4
@


1.14
log
@cosmetics, comments, and working options
@
text
@a23 1
 * CURRENT STATUS: single spheres work
a101 2


@


1.13
log
@working crossover and reproduction. implementation works, but is going to need a lot of tweaking.
@
text
@d54 1
a54 2
#define _L pop->parent[0]
void usage(){bu_bomb("Usage: ./beset [options] database rows cols");}
d68 2
a69 2
void
parse_args (int argc, char **argv)
d73 1
a73 1
    bu_setprogname(argv[0]);
d77 3
a79 3
    argv++; argc--;
    while (argv[0][0] == '-') {
	c = bu_getopt(argc, argv, "x:");
a82 2
		argc -= 2;
		argv += 2;
d84 9
a92 2
	    case EOF:
		break;
a95 1
	//	return 1;
d98 1
d109 1
a111 1
    int c;
d114 3
a116 1
    char indname[256];
d119 3
a121 1
//    parse_args(argc, argv);
a122 6
    argc--;
    argv++;
    if (argc != 4) {
	fprintf(stderr, "Usage: %s [options] database rows cols source_object\n", bu_getprogname());
	return 1;
    }
a125 2
    fstate = fit_prep(atoi(argv[1]), atoi(argv[2])); //ERROR CHECK

d127 2
a128 1
    fit_store(argv[3], argv[0], fstate); 
d130 3
a132 1
    pop_init(&pop, 10);
a133 4
    pop_spawn(pop, pop->db_p->dbi_wdbp);
    wdb_close(pop->db_p->dbi_wdbp);
    pop->db_p = db_open("gen00", "r");
    db_dirbuild(pop->db_p);
d135 2
a136 3

    //pop_spawn = gen00
    for(g = 1; g < 10; g++){
d139 1
a139 4
		//create a new db for each generation
	snprintf(dbname, 256, "gen%.2d", g);
	pop->db_c = db_create(dbname, 5);
	//pop->db_c->dbi_wdbp = wdb_dbopen(pop->db_c,RT_WDB_TYPE_DB_DISK);
d141 1
a141 3
	//evaluate fitness of parents
	total_fitness = 0;
	
d143 2
d146 4
d151 2
a152 1
	   pop->parent[i].fitness = 1.0-fit_linDiff(pop->parent[i].id, pop->db_p, fstate);
a153 1

d155 1
a156 1
	//qsort(pop->parent, pop->size, sizeof(struct individual), cmp_ind);
d160 5
a164 7
	    /*
	     * Choose a random genetic operation and
	     * two potential parents to the next individual
	     */
	    gop = pop_wrand_gop();//to be implemented
	    parent1 = parent2 = pop_wrand_ind(pop->parent, pop->size, total_fitness);
	    snprintf(pop->child[i].id, 256, "gen%.3dind%.3d", g, i); //name the child
d166 2
a167 1
	    if(gop == CROSSOVER){
d170 1
a170 2
		++i;
		snprintf(pop->child[i].id, 256, "gen%.3dind%.3d", g, i); //name the child
d172 1
d174 2
d179 1
d181 3
a183 1
		pop_gop(gop, pop->parent[parent1].id, NULL, pop->child[i].id, NULL,
a187 2
  db_close(pop->db_p);
	    pop->db_p = pop->db_c;
d189 9
a197 3

	struct individual *tmp = pop->child;
pop->child = pop->parent;
d201 4
a204 1
    printf("\nFINAL POPULATION\n----------------\n");
d208 1
a209 1
    //fit_updateRes(atoi(argv[1])*2, atoi(argv[2])*2);
d211 2
a212 2
    //fit_clean(fstate);
    //pop_clean(pop);
@


1.12
log
@fixed issue with renaming directory pointers, combination trees are now supported
@
text
@d103 1
a103 1
    int ind;
d139 2
d160 5
a164 1
	    ind = pop_wrand_ind(pop->parent, pop->size, total_fitness);
d166 16
a181 6
	    printf("-----Generating Individual %d-----\n", i);
	    snprintf(pop->child[i].id, 256, "gen%.3dind%.3d", g, i);
	    switch(REPRODUCE){
		case REPRODUCE:
		    pop_dup(pop->parent[ind].id, pop->child[i].id, pop->db_p, pop->db_c, &rt_uniresource );
		    break;
d183 1
a184 1
	printf("CLOSING DB_P\n");
a191 1
	printf("GENERATION %d COMPLETE\n", g);
d201 2
a202 2
    fit_clean(fstate);
    pop_clean(pop);
@


1.11
log
@more reasonable debugging output
@
text
@d132 3
a136 1
    struct directory *dp;
d142 1
a142 1
	pop->db_c->dbi_wdbp = wdb_dbopen(pop->db_c,RT_WDB_TYPE_DB_DISK);
d152 1
d158 2
a160 15

	    /*

	    if((dp = db_lookup(pop->db_p, "gen000ind004", LOOKUP_NOISY)) == DIR_NULL)
		printf("ERROR LOOKING UP PARENT\n");
	    else
		printf("SUCCESFULLY LOOKED UP gen000ind004\n");
		*/


	    ind = pop_wrand_ind(pop->parent, pop->size, total_fitness);
	    gop = pop_wrand_gop(); // to be implemented...
	    //going to need random node calculation for these too ...

	    pop->child[i] = pop->parent[ind]; //struct copy
a161 1

a162 10
		case MUTATE_MOD:  // mutate but do not replace values, modify them by +- MOD_RATE
		    break;
		case MUTATE_RAND:
		    break;
		case MUTATE_OP:
		    //modify op in tree
		    break;
		case CROSSOVER:
		    //perform crossover on tree
		    break;
a163 2

		    printf("copying %s to %s\n", pop->parent[ind].id, pop->child[i].id);
a166 2
	  	 //   snprintf(pop->child[i].id, 256, "g%di%d.s", g, i);
	//    pop_add(&pop->child[i], fstate->db->dbi_wdbp);
d169 1
a169 1
  wdb_close(pop->db_p->dbi_wdbp);
@


1.10
log
@partially working tree implementation. still some bugs to work out...
@
text
@d137 1
a137 4
	if((dp = db_lookup(pop->db_p, "gen000ind005", LOOKUP_NOISY)) == DIR_NULL)
	    printf("ERROR LOOKING UP PARENT");

	//create a new db for each generation
d145 2
d155 11
a171 1
	    printf("copying %s to %s\n", pop->parent[ind].id, pop->child[i].id);
d185 2
d188 1
d193 1
@


1.9
log
@fixed bug where spheres with non-whole radii produced odd results
@
text
@d24 1
a24 1
 * CURRENT STATUS: single spheres with a whole radius work
d47 1
d54 2
a55 1
#define _L pop->individual[0]
a56 1
struct population *pop;
d69 3
a71 8


int main(int argc, char *argv[]){
    int i, g; /* generation and individual counters */
    int ind;
    int gop;
    fastf_t total_fitness;
    struct fitness_state *fstate;
a74 1

d91 2
a92 1
		return 1;
d95 17
d113 4
d122 3
a124 6
    fstate = fit_prep(argv[0], atoi(argv[1]), atoi(argv[2]));
    if (!fstate || fstate < 0) {
	fprintf(stderr, "Error preparing %s\n", argv[0]);
	return 2;
    }
    fstate->db->dbi_wdbp = wdb_dbopen(fstate->db, RT_WDB_TYPE_DB_DISK);
d126 2
a127 1
    fit_store(argv[3], fstate);
a129 1
    pop_spawn(pop, fstate->db->dbi_wdbp);
d131 17
a147 1
    for(g = 0; g < 10; g++){
d149 2
a150 1
	   pop->individual[i].fitness = 1.0-fit_linDiff(pop->individual[i].id, fstate);
a151 4
	//qsort(pop->individual, pop->size, sizeof(struct individual), cmp_ind);

	/* calculate total fitness */
	total_fitness = 0;
d153 1
a153 1
	for (i = 0; i < pop->size; i++) {
a154 3
	    //printf("%s\tr:%g\tf:%g\n", pop->individual[i].id, pop->individual[i].r, pop->individual[i].fitness);
	    total_fitness += pop->individual[i].fitness;
	}
d156 1
a156 1
	    ind = pop_wrand_ind(pop->individual, pop->size, total_fitness);
d160 3
a162 1
	    pop->offspring[i] = pop->individual[ind];
d164 1
a164 1
	    switch(gop){
a165 1
		    pop->offspring[i].r += -.1 + (.2 * (pop_rand()));
a167 1
		    pop->offspring[i].r = 1+pop_rand() * SCALE;
d175 2
d178 2
a179 1
	    pop_add(&pop->offspring[i], fstate->db->dbi_wdbp);
d181 7
a187 3
	struct individual *tmp = pop->offspring;
	pop->offspring = pop->individual;
	pop->individual = tmp;
d193 2
a194 2
	printf("%s\tr:%5g\tf:%.5g\n", pop->offspring[i].id, 
		pop->offspring[i].r, pop->offspring[i].fitness);
@


1.8
log
@remove the if, just make the EOF check part of the case
@
text
@a70 2
    /* general inint stuff, parallel stuff, break into parallel function */
    point_t p1;
a111 1
    printf("____STORED MODEL____\n");
d114 1
a114 1
    pop_init(&pop, 1);
a115 1
    printf("___POPULATION_MODEL___\n");
d117 1
a117 1
    for(g = 0; g < 1; g++){
d121 1
a121 1
	qsort(pop->individual, pop->size, sizeof(struct individual), cmp_ind);
d128 1
d138 1
a138 2
	    //printf("ind: %g -- %g\n", pop->offspring[i].r, pop->individual[ind].r);
	    switch(CROSSOVER){
d160 4
@


1.7
log
@add support for librt -x debugging (e.g. -x 1 for rt_shootray() shotline debugging, see raytrace.h for debug flags)
@
text
@a87 3
	if (c == EOF) {
	    break;
	}
d94 2
@


1.6
log
@error check fit_prep() return value
@
text
@d70 1
a70 1
int main(int argc, char **argv){
d78 1
d80 25
a104 2
    if(argc != 5){
	fprintf(stderr, "Usage: %s database rows cols source_object\n", argv[0]);
d108 1
a108 1
    fstate = fit_prep(argv[1], atoi(argv[2]), atoi(argv[3]));
d110 1
a110 1
	fprintf(stderr, "Error preparing %s\n", argv[1]);
d116 1
a116 1
    fit_store(argv[4], fstate);
d166 1
a166 3


    //fit_updateRes(atoi(argv[2])*2, atoi(argv[3])*2);
@


1.5
log
@added logical debugging output
@
text
@d85 4
@


1.4
log
@petty cosmetics while browsing, mostly ws
@
text
@d79 2
a80 2
    if(argc != 6){
	fprintf(stderr, "Usage: %s database rows cols source_object test_object\n", argv[0]);
d87 1
d90 1
a90 1
    pop_init(&pop, 2);
d92 1
a99 1
	printf("%s:\t%.5g\t%.5g\n", _L.id, _L.fitness, _L.r);
a107 1
	    printf("%s\tr:%g\tf:%g\n", pop->individual[i].id, pop->individual[i].r, pop->individual[i].fitness);
a117 1
		    printf("off: %g\n", pop->offspring[i].r);
@


1.3
log
@single sphere partially working
@
text
@d80 1
a80 1
	fprintf(stderr, "Usage: ./fitness database rows cols source_object test_object\n");
@


1.2
log
@implemented basic GA framework
@
text
@d22 3
a24 1
 * Program to test functionality of fitness.c (temporary)
a40 1
#include <limits.h>                     /* home of INT_MAX aka MAXINT */
a54 1
struct fitness_state *fstate;
d77 1
d84 1
a84 1
    fit_prep(argv[1], atoi(argv[2]), atoi(argv[3]));
d87 1
a87 1
    fit_store(argv[4]);
d89 1
a89 1
    pop_init(&pop, 50);
d92 1
a92 2
    for(g = 0; g < 2; g++){
	printf("%d: ", g);
d94 1
a94 1
	   pop->individual[i].fitness = fit_linDiff(pop->individual[i].id);
a101 1
	    printf("%d: %g\n", 0, pop->individual[0].r);
d107 1
a107 1
	    printf("%d: r:%g\tf:%g\n", i, pop->individual[i].r, pop->individual[i].fitness);
d115 1
a115 1
	    switch(MUTATE_RAND){
a139 1
    fit_store(argv[4]);
d143 1
a143 1
    fit_clean();
@


1.1
log
@added build files and test program
@
text
@d30 2
a31 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d48 3
d52 1
d55 1
d58 11
d71 7
d83 3
a85 11
    int r = fit_prep(argv[1], atoi(argv[2]), atoi(argv[3]));
    if(r != 0){
       if(r == DB_OPEN_FAILURE){
	   fprintf(stderr, "db_open failure on %s\n", argv[1]);
	   return r;
       }
       else if(r == DB_DIRBUILD_FAILURE){
	   fprintf(stderr, "db_dirbuild failure on %s\n", argv[1]);
	   return r;
       }
   }
d87 56
a142 1
    printf("Linear Difference: %g\n", fit_linDiff(argv[5]));
a143 2
    //printf("Obj Fitness: %g\n", fit_fitness(argv[5]));

d146 1
@

