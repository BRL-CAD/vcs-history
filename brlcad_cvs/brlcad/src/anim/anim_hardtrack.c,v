head	14.16;
access;
symbols
	rel-7-10-4:14.13
	STABLE:14.13.0.2
	stable-branch:14.8
	rel-7-10-2:14.13
	rel-7-10-0:14.13
	rel-7-8-4:14.11
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.6
	rel-7-6-0:14.8
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.4
	bobWinPort:14.8.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.8
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.16
date	2007.11.21.20.49.05;	author erikgreenwald;	state Exp;
branches;
next	14.15;

14.15
date	2007.11.21.19.28.05;	author erikgreenwald;	state Exp;
branches;
next	14.14;

14.14
date	2007.09.15.16.23.03;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.23;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.42;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.29.00.51.53;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.12;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.02.14.02.29.35;	author brlcad;	state Exp;
branches
	14.8.6.1;
next	14.7;

14.7
date	2005.01.30.20.30.14;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.49;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.00.54.02;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.55;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.38;	author morrison;	state Exp;
branches;
next	;

14.8.6.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@pass bu_exit a NULL instead of an empty string
@
text
@/*                A N I M _ H A R D T R A C K . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file anim_hardtrack.c
 *  Animate the links and wheels of a tracked vehicle. It is assumed
 *  that the wheels do not translate with respect to the vehicle.
 *
 *  Author -
 *	Carl J. Nuzman
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "anim.h"


#define NW	num_wheels
#define NEXT(i)	(i+1)%NW
#define PREV(i)	(i+NW-1)%NW

#define TRACK_ANIM	0
#define TRACK_ARCED	1

typedef double *pdouble;

struct wheel {
    vect_t		pos;	/* displacement of wheel from vehicle origin */
    fastf_t		rad;	/* radius of wheel */
    fastf_t		ang0;	/* angle where track meets wheel; 0 < a < 2pi */
    fastf_t		ang1;	/* angle where track leaves wheel; 0 < a < 2pi */
    fastf_t		arc;	/* arclength of contact between wheel and track */
};

struct track {
    vect_t		pos0;	/* beginning point of track section */
    vect_t		pos1;	/* end point of track section */
    vect_t		dir;	/* unit vector: direction of track section */
    fastf_t		len;	/* length of track section */
};

struct slope {
    vect_t		dir;	/* vector from previous to current axle */
    fastf_t		len;	/* length of vector described above */
};

struct all {
    struct wheel 	w;	/* parameters describing the track around a wheel */
    struct track	t;	/* track between this wheel and the previous wheel */
    struct slope	s;	/* vector between this axle and the previous axle */
};

struct rlink {
    vect_t		pos;	/* reverse of initial position */
    fastf_t		ang;	/* initial angle */
};

/* external variables */
extern int bu_optind;
extern char *bu_optarg;

/* variables describing track geometry - used by main, trackprep, get_link */
struct all *x;
struct rlink *r;		/* reverse of initial locations of links */
int num_links, num_wheels;
fastf_t track_y, tracklen;

/* variables set by get_args */
int wheel_nindex;	/* argv[wheel_nindex] = wheelname*/
int link_nindex;	/* argv[link_nindex] = linkname*/
int print_wheel;	/* flag: do wheel animation */
int print_link;		/* flag: do link animation */
int print_mode;		/*  anim for rt or arced for mged */
int arced_frame;	/* which frame to arced */
int links_placed;	/* flag: links are initially on the track */
int axes, cent;		/* flags: alternate axes, centroid specified */
int steer;		/* flag: vehicle automatically steered */
int first_frame;	/* integer with which to begin numbering frames */
fastf_t radius;		/* common radius of all wheels */
fastf_t init_dist; 	/* initial distance of first link along track */
vect_t centroid, rcentroid;	/* alternate centroid and its reverse */
mat_t m_axes, m_rev_axes;	/* matrices to and from alternate axes */
char link_cmd[10];		/* default is "rarc" */
char wheel_cmd[10];		/* default is "lmul" */
int get_circumf;	/* flag: just return circumference of track */

int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist);

int
main(int argc, char **argv)
{
    void anim_dir2mat(fastf_t *, const fastf_t *, const fastf_t *), anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *),anim_mat_print(FILE *, const fastf_t *, int);
    int get_args(int argc, char **argv), track_prep(void), val, frame, go, i, count;
    fastf_t y_rot, distance, yaw, pitch, roll;
    vect_t p1, p2, p3, dir, dir2, wheel_now, wheel_prev;
    vect_t zero, position, vdelta, temp, to_track, to_front;
    mat_t mat_v, wmat, mat_x;
    FILE *stream;
    int last_frame;

    VSETALL(zero,0.0);
    VSETALL(to_track,0.0);
    VSETALL(centroid,0.0);
    VSETALL(rcentroid,0.0);
    init_dist = y_rot = radius= 0.0;
    first_frame = num_wheels = steer = axes = cent = links_placed=0;
    num_wheels = num_links = last_frame = 0;
    MAT_IDN(mat_v);
    MAT_IDN(mat_x);
    MAT_IDN(wmat);
    MAT_IDN(m_axes);
    MAT_IDN(m_rev_axes);

    if (!get_args(argc,argv)){
	fprintf(stderr,"anim_hardtrack: argument error.");
	return(-1);
    }

    if (axes || cent ){ /* vehicle has own reference frame */
	anim_add_trans(m_axes,centroid,zero);
	anim_add_trans(m_rev_axes,zero,rcentroid);
    }

    /* get track information from specified file */

    if (!(stream = fopen(*(argv+bu_optind),"r"))){
	fprintf(stderr,"Anim_hardtrack: Could not open file %s.\n",*(argv+bu_optind));
	return(0);
    }
    num_wheels = -1;
    if (radius) {
	while (!feof(stream)) {
	    fscanf(stream,"%*f %*f %*f");
	    num_wheels++;
	}
    } else {
	while (!feof(stream)) {
	    fscanf(stream,"%*f %*f %*f %*f");
	    num_wheels++;
	}
    }
    rewind(stream);

    /*allocate memory for track information*/
    x = (struct all *) bu_calloc(num_wheels,sizeof(struct all), "struct all");
    /*read rest of track info */
    for (i=0;i<NW;i++){
	fscanf(stream,"%lf %lf %lf", temp, temp+1, temp+2);
	if (radius)
	    x[i].w.rad = radius;
	else
	    fscanf(stream,"%lf",& x[i].w.rad);
	MAT4X3PNT(x[i].w.pos,m_rev_axes,temp);
	if (i==0)
	    track_y = x[0].w.pos[1];
	else
	    x[i].w.pos[1] = track_y;
    }
    (void) fclose(stream);

    (void) track_prep();

    if (get_circumf) {
	printf("%.10g\n",tracklen);
	return(0);
    }

    /* initialize to_track */
    VSET(to_track, 0.0, track_y, 0.0);
    VSET(to_front,1.0,0.0,0.0);

    if ((!print_link)&&(!print_wheel)) {
	fprintf(stderr,"anim_hardtrack: no ouput requested. Use -l or -w.\n");
	bu_exit(0, NULL);
    }
    /* main loop */
    distance = 0.0;
    if(!steer)
	frame = first_frame;
    else
	frame = first_frame-1;
    for (val = 3; val > 2; frame++) {
	go = 1;
	/*p2 is current position. p3 is next;p1 is previous*/
	VMOVE(p1,p2);
	VMOVE(p2,p3);
	scanf("%*f");/*time stamp*/
	val = scanf("%lf %lf %lf", p3, p3+1, p3 + 2);
	if(!steer){
	    scanf("%lf %lf %lf",&yaw,&pitch,&roll);
	    anim_dy_p_r2mat(mat_v,yaw,pitch,roll);
	    anim_add_trans(mat_v,p3,rcentroid);
	}
	else { /* analyze positions for steering */
	    /*get useful direction unit vectors*/
	    if (frame == first_frame){ /* first frame*/
		VSUBUNIT(dir,p3,p2);
		VMOVE(dir2,dir);
	    }
	    else if (val < 3){ /*last frame*/
		VSUBUNIT(dir,p2,p1);
		VMOVE(dir2,dir);
	    }
	    else if (frame > first_frame){ /*normal*/
		VSUBUNIT(dir,p3,p1);
		VSUBUNIT(dir2,p2,p1);/*needed for vertical case*/
	    }
	    else go = 0;/*first time through loop;no p2*/

			/*create matrix which would move vehicle*/
	    anim_dir2mat(mat_v,dir,dir2);
	    anim_add_trans(mat_v,p2,rcentroid);
	}

	/*determine distance traveled*/
	VMOVE(wheel_prev,wheel_now);
	MAT4X3PNT(wheel_now,mat_v,to_track);
	if (frame > first_frame){  /* increment distance by distance moved */
	    VSUB2(vdelta,wheel_now,wheel_prev);
	    MAT3X3VEC(temp,mat_v,to_front);/*new front of vehicle*/
	    distance += VDOT(temp,vdelta);/*portion of vdelta in line with track*/
	}

	if (go){
	    if (print_mode==TRACK_ANIM) {
		printf("start %d;\nclean;\n", frame);
	    } else if (print_mode==TRACK_ARCED) {
		if (frame != arced_frame) continue;
		last_frame = 1;
	    }
	    if (print_link) {
		for (count=0;count<num_links;count++){
		    (void) get_link(position,&y_rot,distance+tracklen*count/num_links+init_dist);
		    anim_y_p_r2mat(wmat,0.0,y_rot+r[count].ang,0.0);
		    anim_add_trans(wmat,position,r[count].pos);
		    if ((axes || cent) && links_placed){ /* link moved from vehicle coords */
			bn_mat_mul(mat_x,wmat,m_rev_axes);
			bn_mat_mul(wmat,m_axes,mat_x);
		    }
		    else if (axes || cent){ /* link moved to vehicle coords */
			MAT_MOVE(mat_x,wmat);
			bn_mat_mul(wmat,m_axes,mat_x);
		    }
		    if (print_mode==TRACK_ANIM) {
			printf("anim %s.%d matrix %s\n", *(argv+link_nindex),count,link_cmd);
			anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
		    } else if (print_mode==TRACK_ARCED) {
			printf("arced %s.%d matrix %s ", *(argv+link_nindex),count,link_cmd);
			anim_mat_printf(stdout,wmat,"%.10g ","","\n");
		    }
		}
	    }
	    if (print_wheel){
		for (count = 0;count<num_wheels;count++){
		    anim_y_p_r2mat(wmat,0.0,-distance/x[count].w.rad,0.0);
		    VREVERSE(temp,x[count].w.pos);
		    anim_add_trans(wmat,x[count].w.pos,temp);
		    if (axes || cent){
			bn_mat_mul(mat_x,wmat,m_rev_axes);
			bn_mat_mul(wmat,m_axes,mat_x);
		    }
		    if (print_mode==TRACK_ANIM) {
			printf("anim %s.%d matrix %s\n",*(argv+wheel_nindex),count,wheel_cmd);
			anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
		    } else if (print_mode==TRACK_ARCED) {
			printf("arced %s.%d matrix %s ",*(argv+wheel_nindex),count,wheel_cmd);
			anim_mat_printf(stdout,wmat,"%.10g ","","\n");
		    }
		}
	    }
	    if (print_mode==TRACK_ANIM)
		printf("end;\n");
	}
	if (last_frame) break;
    }

    if (x) {
	bu_free(x, "struct all");
    }
    if (r) {
	bu_free(r, "struct rlink");
    }
    return( 0 );
}


int track_prep(void)/*run once at the beginning to establish important track info*/
{
    int i;
    fastf_t phi, costheta, link_angle, arc_angle;
    vect_t difference, link_cent;

    /* first loop - get inter axle slopes and start/end angles */
    for (i=0;i<NW;i++){
	/*calculate current slope vector*/
	VSUB2(x[i].s.dir,x[i].w.pos,x[PREV(i)].w.pos);
	x[i].s.len = MAGNITUDE(x[i].s.dir);
	/*calculate end angle of previous wheel - atan2(y,x)*/
	phi = atan2(x[i].s.dir[2],x[i].s.dir[0]);/*absolute angle of slope*/
	costheta = (x[PREV(i)].w.rad - x[i].w.rad)/x[i].s.len;/*cosine of special angle*/
	x[PREV(i)].w.ang1 = phi +  acos(costheta);
	while (x[PREV(i)].w.ang1 < 0.0)
	    x[PREV(i)].w.ang1 += 2.0*M_PI;
	x[i].w.ang0 = x[PREV(i)].w.ang1;
    }

    /* second loop - handle concavities */
    for (i=0;i<NW;i++){
	arc_angle = x[i].w.ang0 - x[i].w.ang1;
	while (arc_angle < 0.0)
	    arc_angle += 2.0*M_PI;
	if (arc_angle > M_PI) { /* concave */
	    x[i].w.ang0 = 0.5*(x[i].w.ang0 + x[i].w.ang1);
	    x[i].w.ang1 = x[i].w.ang0;
	    x[i].w.arc = 0.0;
	}
	else { /* convex - angles are already correct */
	    x[i].w.arc = arc_angle;
	}
    }

    /* third loop - calculate geometry of track segments */
    tracklen = 0.0;
    for (i=0;i<NW;i++){
	/*calculate endpoints of track segment*/
	x[i].t.pos1[0] = x[i].w.pos[0] + x[i].w.rad*cos(x[i].w.ang0);
	x[i].t.pos1[1] = x[i].w.pos[1];
	x[i].t.pos1[2] = x[i].w.pos[2] + x[i].w.rad*sin(x[i].w.ang0);
	x[i].t.pos0[0] = x[PREV(i)].w.pos[0] + x[PREV(i)].w.rad*cos(x[PREV(i)].w.ang1);
	x[i].t.pos0[1] = x[PREV(i)].w.pos[1];
	x[i].t.pos0[2] = x[PREV(i)].w.pos[2] + x[PREV(i)].w.rad*sin(x[PREV(i)].w.ang1);
	/*calculate length and direction*/
	VSUB2(difference,x[i].t.pos1,x[i].t.pos0);
	x[i].t.len = MAGNITUDE(difference);
	VSCALE((x[i].t.dir),difference,(1.0/x[i].t.len));

	/*calculate arclength and total track length*/
	tracklen += x[i].t.len;
	tracklen += x[i].w.arc*x[i].w.rad;
    }

    /* for a track with links already placed, get initial positions*/
    r = (struct rlink *) bu_calloc(num_links, sizeof(struct rlink), "struct rlink");
    if (links_placed)
	for (i=0;i<num_links;i++){
	    get_link(link_cent,&link_angle,init_dist + tracklen*i/num_links);
	    VREVERSE(r[i].pos,link_cent);
	    r[i].ang = -link_angle;
	}
    return(0);
}


int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist)
{
    int i;
    vect_t temp;
    while (dist >= tracklen) /*periodicize*/
	dist -= tracklen;
    while (dist < 0.0)
	dist += tracklen;
    for (i=0;i<NW;i++){
	if ( (dist  -= x[i].t.len) < 0 ){
	    VSCALE(temp,(x[i].t.dir),dist);
	    VADD2(pos,x[i].t.pos1,temp);
	    *angle_p = atan2(x[i].t.dir[2],x[i].t.dir[0]);
	    return(2*i);
	}
	if ((dist -= x[i].w.rad*x[i].w.arc) < 0){
	    *angle_p = dist/x[i].w.rad;
	    *angle_p = x[i].w.ang1 - *angle_p; /*from x-axis to link*/
	    pos[0] = x[i].w.pos[0] + x[i].w.rad*cos(*angle_p);
	    pos[1] = x[i].w.pos[1];
	    pos[2] = x[i].w.pos[2] + x[i].w.rad*sin(*angle_p);
	    *angle_p -= M_PI_2; /*angle of clockwise tangent to circle*/
	    return(2*i+1);
	}
    }
    return -1;
}

#define OPT_STR "b:d:f:i:l:pr:w:sg:m:c"
int get_args(int argc, char **argv)
{
    fastf_t yaw, pch, rll;
    void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
    int c, i;
    axes = cent = links_placed = print_wheel = print_link = 0;
    get_circumf = 0;
    print_mode = TRACK_ANIM;
    strcpy(link_cmd, "rarc");
    strcpy(wheel_cmd, "lmul");
    while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
	i=0;
	switch(c){
	case 'b':
	    bu_optind -= 1;
	    sscanf(argv[bu_optind+(i++)],"%lf", &yaw );
	    sscanf(argv[bu_optind+(i++)],"%lf", &pch );
	    sscanf(argv[bu_optind+(i++)],"%lf", &rll );
	    bu_optind += 3;
	    anim_dx_y_z2mat(m_axes, rll, -pch, yaw);
	    anim_dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
	    axes = 1;
	    break;
	case 'd':
	    bu_optind -= 1;
	    sscanf(argv[bu_optind+(i++)],"%lf",centroid);
	    sscanf(argv[bu_optind+(i++)],"%lf",centroid+1);
	    sscanf(argv[bu_optind+(i++)],"%lf",centroid+2);
	    bu_optind += 3;
	    VREVERSE(rcentroid,centroid);
	    cent = 1;
	    break;
	case 'f':
	    sscanf(bu_optarg,"%d",&first_frame);
	    break;
	case 'i':
	    sscanf(bu_optarg,"%lf",&init_dist);
	    break;
	case 'p':
	    links_placed = 1;
	    break;
	case 'r':
	    sscanf(bu_optarg,"%lf",&radius);
	    break;
	case 'w':
	    wheel_nindex = bu_optind - 1;
	    /*sscanf(bu_optarg,"%s",wheel_name);*/
	    print_wheel = 1;
	    break;
	case 'l':
	    sscanf(bu_optarg,"%d", &num_links);
	    link_nindex = bu_optind;
	    bu_optind += 1;
	    print_link = 1;
	    break;
	case 's':
	    steer = 1;
	    break;
	case 'g':
	    sscanf(bu_optarg,"%d",&arced_frame);
	    print_mode = TRACK_ARCED;
	    break;
	case 'm':
	    switch (*bu_optarg) {
	    case 'l':
		strncpy(link_cmd,argv[bu_optind], 10);
		break;
	    case 'w':
		strncpy(wheel_cmd,argv[bu_optind], 10);
		break;
	    default:
		fprintf(stderr,"Unknown option: -m%c\n",*bu_optarg);
		return(0);
	    }
	    bu_optind += 1;
	    break;
	case 'c':
	    get_circumf = 1;
	    break;
	default:
	    fprintf(stderr,"Unknown option: -%c\n",c);
	    return(0);
	}
    }
    return(1);
}

void show_info(int which)/* for debugging - -1:track 0:both 1:link*/

{
    int i;
    if (which <=0){
	fprintf(stderr,"track length: %f\n",tracklen);
	fprintf(stderr,"link length: %f\n",tracklen/num_links);
	for (i=0;i<NW;i++){
	    fprintf(stderr,"wheel %d: %f %f %f %f %f %f\n",i,x[i].w.pos[0],x[i].w.pos[1],x[i].w.pos[2],x[i].w.rad,x[i].w.ang1,x[i].w.arc);
	    fprintf(stderr,"track %d: %f %f %f %f %f %f %f\n",i,x[i].t.pos1[0],x[i].t.pos1[1],x[i].t.pos1[2],x[i].t.dir[0],x[i].t.dir[1],x[i].t.dir[2],x[i].t.len);
	    fprintf(stderr,"slope %d: %f %f %f %f\n",i,x[i].s.dir[0],x[i].s.dir[1],x[i].s.dir[2],x[i].s.len);
	}
    }
    /*	if (which >= 0){
	fprintf(stderr,"%d %f %f %f %f\n",count,position[0],position[1],position[2],y_rot);
	}*/
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@exit->bu_exit where applicable
@
text
@d204 1
a204 1
	bu_exit(0, "");
@


14.14
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d204 1
a204 1
	exit(0);
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d37 1
a39 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.12
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.11
log
@more libbu memory management and header cleanup
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2006 United States Government as represented by
@


14.10
log
@update copyright to 2006
@
text
@d36 4
d41 1
a41 1
#include <string.h>
d43 1
a43 1
#include <strings.h>
a45 4
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
a51 7
#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif

#ifndef M_PI_2
#define M_PI_2	(M_PI*0.5)
#endif
d180 1
a180 1
    x = (struct all *) calloc(num_wheels,sizeof(struct all));
d311 7
d378 1
a378 1
    r = (struct rlink *) calloc(num_links, sizeof(struct rlink));
d406 1
a406 1
	    *angle_p = x[i].w.ang1 - *angle_p;/*from x-axis to link*/
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1993-2005 United States Government as represented by
@


14.8
log
@M-x indent-region
@
text
@d28 1
a28 1
 *  
d223 1
a223 1
	frame = first_frame-1; 
d234 1
a234 1
	    anim_add_trans(mat_v,p3,rcentroid);			
d251 1
a251 1
			
d253 2
a254 2
	    anim_dir2mat(mat_v,dir,dir2); 
	    anim_add_trans(mat_v,p2,rcentroid); 
d388 1
a388 1
	
d506 1
a506 1
          
@


14.8.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d223 1
a223 1
	frame = first_frame-1;
d234 1
a234 1
	    anim_add_trans(mat_v,p3,rcentroid);
d251 1
a251 1

d253 2
a254 2
	    anim_dir2mat(mat_v,dir,dir2);
	    anim_add_trans(mat_v,p2,rcentroid);
d388 1
a388 1

d506 1
a506 1

@


14.7
log
@update copyright to 2005
@
text
@d70 5
a74 5
vect_t		pos;	/* displacement of wheel from vehicle origin */
fastf_t		rad;	/* radius of wheel */
fastf_t		ang0;	/* angle where track meets wheel; 0 < a < 2pi */
fastf_t		ang1;	/* angle where track leaves wheel; 0 < a < 2pi */
fastf_t		arc;	/* arclength of contact between wheel and track */
d78 4
a81 4
vect_t		pos0;	/* beginning point of track section */
vect_t		pos1;	/* end point of track section */
vect_t		dir;	/* unit vector: direction of track section */
fastf_t		len;	/* length of track section */
d85 2
a86 2
vect_t		dir;	/* vector from previous to current axle */
fastf_t		len;	/* length of vector described above */
d90 3
a92 3
struct wheel 	w;	/* parameters describing the track around a wheel */
struct track	t;	/* track between this wheel and the previous wheel */
struct slope	s;	/* vector between this axle and the previous axle */
d96 2
a97 2
vect_t		pos;	/* reverse of initial position */
fastf_t		ang;	/* initial angle */
d134 31
a164 31
	void anim_dir2mat(fastf_t *, const fastf_t *, const fastf_t *), anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *),anim_mat_print(FILE *, const fastf_t *, int);
	int get_args(int argc, char **argv), track_prep(void), val, frame, go, i, count;
	fastf_t y_rot, distance, yaw, pitch, roll;
	vect_t p1, p2, p3, dir, dir2, wheel_now, wheel_prev;
	vect_t zero, position, vdelta, temp, to_track, to_front;
	mat_t mat_v, wmat, mat_x;
	FILE *stream;
	int last_frame;

	VSETALL(zero,0.0);
	VSETALL(to_track,0.0);
	VSETALL(centroid,0.0);
	VSETALL(rcentroid,0.0);
	init_dist = y_rot = radius= 0.0;
	first_frame = num_wheels = steer = axes = cent = links_placed=0;
	num_wheels = num_links = last_frame = 0;
	MAT_IDN(mat_v);
	MAT_IDN(mat_x);
	MAT_IDN(wmat);
	MAT_IDN(m_axes);
	MAT_IDN(m_rev_axes);

	if (!get_args(argc,argv)){
		fprintf(stderr,"anim_hardtrack: argument error.");
		return(-1);
	}

	if (axes || cent ){ /* vehicle has own reference frame */
		anim_add_trans(m_axes,centroid,zero);
		anim_add_trans(m_rev_axes,zero,rcentroid);
	}
d166 1
a166 1
	/* get track information from specified file */
d168 34
a201 17
	if (!(stream = fopen(*(argv+bu_optind),"r"))){
		fprintf(stderr,"Anim_hardtrack: Could not open file %s.\n",*(argv+bu_optind));
		return(0);
	}
	num_wheels = -1;
	if (radius) {
		while (!feof(stream)) {
			fscanf(stream,"%*f %*f %*f");
			num_wheels++;
		}
	} else {
		while (!feof(stream)) {
			fscanf(stream,"%*f %*f %*f %*f");
			num_wheels++;
		}
	}
	rewind(stream);
d203 1
a203 16
	/*allocate memory for track information*/
	x = (struct all *) calloc(num_wheels,sizeof(struct all));
		/*read rest of track info */
	for (i=0;i<NW;i++){
		fscanf(stream,"%lf %lf %lf", temp, temp+1, temp+2);
		if (radius)
			x[i].w.rad = radius;
		else
			fscanf(stream,"%lf",& x[i].w.rad);
		MAT4X3PNT(x[i].w.pos,m_rev_axes,temp);
		if (i==0)
			track_y = x[0].w.pos[1];
		else
			x[i].w.pos[1] = track_y;
	}
	(void) fclose(stream);
d205 4
a208 1
	(void) track_prep();
d210 41
a250 46
	if (get_circumf) {
		printf("%.10g\n",tracklen);
		return(0);
	}

	/* initialize to_track */
	VSET(to_track, 0.0, track_y, 0.0);
	VSET(to_front,1.0,0.0,0.0);

	if ((!print_link)&&(!print_wheel)) {
		fprintf(stderr,"anim_hardtrack: no ouput requested. Use -l or -w.\n");
		exit(0);
	}
	/* main loop */
	distance = 0.0;
	if(!steer)
		frame = first_frame;
	else
		frame = first_frame-1; 
	for (val = 3; val > 2; frame++) {
		go = 1;
		/*p2 is current position. p3 is next;p1 is previous*/
		VMOVE(p1,p2);
		VMOVE(p2,p3);
		scanf("%*f");/*time stamp*/
		val = scanf("%lf %lf %lf", p3, p3+1, p3 + 2);
		if(!steer){
			scanf("%lf %lf %lf",&yaw,&pitch,&roll);
			anim_dy_p_r2mat(mat_v,yaw,pitch,roll);
			anim_add_trans(mat_v,p3,rcentroid);			
		}
		else { /* analyze positions for steering */
			/*get useful direction unit vectors*/
			if (frame == first_frame){ /* first frame*/
				VSUBUNIT(dir,p3,p2);
				VMOVE(dir2,dir);
			}
			else if (val < 3){ /*last frame*/
				VSUBUNIT(dir,p2,p1);
				VMOVE(dir2,dir);
			}
			else if (frame > first_frame){ /*normal*/
				VSUBUNIT(dir,p3,p1);
				VSUBUNIT(dir2,p2,p1);/*needed for vertical case*/
			}
			else go = 0;/*first time through loop;no p2*/
d253 3
a255 3
			anim_dir2mat(mat_v,dir,dir2); 
			anim_add_trans(mat_v,p2,rcentroid); 
		}
d257 36
a292 7
		/*determine distance traveled*/
		VMOVE(wheel_prev,wheel_now);
		MAT4X3PNT(wheel_now,mat_v,to_track);
		if (frame > first_frame){  /* increment distance by distance moved */
			VSUB2(vdelta,wheel_now,wheel_prev);
			MAT3X3VEC(temp,mat_v,to_front);/*new front of vehicle*/
			distance += VDOT(temp,vdelta);/*portion of vdelta in line with track*/
d294 17
a310 50

		if (go){
			if (print_mode==TRACK_ANIM) {
				printf("start %d;\nclean;\n", frame);
			} else if (print_mode==TRACK_ARCED) {
				if (frame != arced_frame) continue;
				last_frame = 1;
			}
			if (print_link) {
			        for (count=0;count<num_links;count++){
		        	        (void) get_link(position,&y_rot,distance+tracklen*count/num_links+init_dist);
					anim_y_p_r2mat(wmat,0.0,y_rot+r[count].ang,0.0);
			        	anim_add_trans(wmat,position,r[count].pos);
			        	if ((axes || cent) && links_placed){ /* link moved from vehicle coords */
				        	bn_mat_mul(mat_x,wmat,m_rev_axes);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	else if (axes || cent){ /* link moved to vehicle coords */
			        		MAT_MOVE(mat_x,wmat);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	if (print_mode==TRACK_ANIM) {
						printf("anim %s.%d matrix %s\n", *(argv+link_nindex),count,link_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
			        	} else if (print_mode==TRACK_ARCED) {
			        		printf("arced %s.%d matrix %s ", *(argv+link_nindex),count,link_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","","\n");
			        	}
				}
			}
			if (print_wheel){
				for (count = 0;count<num_wheels;count++){
					anim_y_p_r2mat(wmat,0.0,-distance/x[count].w.rad,0.0);
					VREVERSE(temp,x[count].w.pos);
					anim_add_trans(wmat,x[count].w.pos,temp);
			        	if (axes || cent){
				        	bn_mat_mul(mat_x,wmat,m_rev_axes);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	if (print_mode==TRACK_ANIM) {
						printf("anim %s.%d matrix %s\n",*(argv+wheel_nindex),count,wheel_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
			        	} else if (print_mode==TRACK_ARCED) {
						printf("arced %s.%d matrix %s ",*(argv+wheel_nindex),count,wheel_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","","\n");
			        	}
				}
			}
			if (print_mode==TRACK_ANIM)
				printf("end;\n");
d312 7
a318 3
		if (last_frame) break;
	}
	return( 0 );
d324 62
a385 62
	int i;
	fastf_t phi, costheta, link_angle, arc_angle;
	vect_t difference, link_cent;

	/* first loop - get inter axle slopes and start/end angles */
	for (i=0;i<NW;i++){
		/*calculate current slope vector*/
		VSUB2(x[i].s.dir,x[i].w.pos,x[PREV(i)].w.pos);
		x[i].s.len = MAGNITUDE(x[i].s.dir);
		/*calculate end angle of previous wheel - atan2(y,x)*/
		phi = atan2(x[i].s.dir[2],x[i].s.dir[0]);/*absolute angle of slope*/
		costheta = (x[PREV(i)].w.rad - x[i].w.rad)/x[i].s.len;/*cosine of special angle*/
		x[PREV(i)].w.ang1 = phi +  acos(costheta);
		while (x[PREV(i)].w.ang1 < 0.0)
			x[PREV(i)].w.ang1 += 2.0*M_PI;
		x[i].w.ang0 = x[PREV(i)].w.ang1;
	}

	/* second loop - handle concavities */
        for (i=0;i<NW;i++){
                arc_angle = x[i].w.ang0 - x[i].w.ang1;
                while (arc_angle < 0.0)
                        arc_angle += 2.0*M_PI;
                if (arc_angle > M_PI) { /* concave */
                        x[i].w.ang0 = 0.5*(x[i].w.ang0 + x[i].w.ang1);
                        x[i].w.ang1 = x[i].w.ang0;
                        x[i].w.arc = 0.0;
                }
                else { /* convex - angles are already correct */
                        x[i].w.arc = arc_angle;
                }
        }

	/* third loop - calculate geometry of track segments */
	tracklen = 0.0;
	for (i=0;i<NW;i++){
		/*calculate endpoints of track segment*/
		x[i].t.pos1[0] = x[i].w.pos[0] + x[i].w.rad*cos(x[i].w.ang0);
		x[i].t.pos1[1] = x[i].w.pos[1];
		x[i].t.pos1[2] = x[i].w.pos[2] + x[i].w.rad*sin(x[i].w.ang0);
		x[i].t.pos0[0] = x[PREV(i)].w.pos[0] + x[PREV(i)].w.rad*cos(x[PREV(i)].w.ang1);
		x[i].t.pos0[1] = x[PREV(i)].w.pos[1];
		x[i].t.pos0[2] = x[PREV(i)].w.pos[2] + x[PREV(i)].w.rad*sin(x[PREV(i)].w.ang1);
		/*calculate length and direction*/
		VSUB2(difference,x[i].t.pos1,x[i].t.pos0);
		x[i].t.len = MAGNITUDE(difference);
		VSCALE((x[i].t.dir),difference,(1.0/x[i].t.len));

		/*calculate arclength and total track length*/
		tracklen += x[i].t.len;
		tracklen += x[i].w.arc*x[i].w.rad;
	}

	/* for a track with links already placed, get initial positions*/
	r = (struct rlink *) calloc(num_links, sizeof(struct rlink));
	if (links_placed)
		for (i=0;i<num_links;i++){
			get_link(link_cent,&link_angle,init_dist + tracklen*i/num_links);
			VREVERSE(r[i].pos,link_cent);
			r[i].ang = -link_angle;
		}
	return(0);
d391 21
a411 22
	int i;
	vect_t temp;
	while (dist >= tracklen) /*periodicize*/
		dist -= tracklen;
	while (dist < 0.0)
		dist += tracklen;
	for (i=0;i<NW;i++){
		if ( (dist  -= x[i].t.len) < 0 ){
			VSCALE(temp,(x[i].t.dir),dist);
			VADD2(pos,x[i].t.pos1,temp);
			*angle_p = atan2(x[i].t.dir[2],x[i].t.dir[0]);
			return(2*i);
		}
		if ((dist -= x[i].w.rad*x[i].w.arc) < 0){
			*angle_p = dist/x[i].w.rad;
			*angle_p = x[i].w.ang1 - *angle_p;/*from x-axis to link*/
			pos[0] = x[i].w.pos[0] + x[i].w.rad*cos(*angle_p);
			pos[1] = x[i].w.pos[1];
			pos[2] = x[i].w.pos[2] + x[i].w.rad*sin(*angle_p);
			*angle_p -= M_PI_2; /*angle of clockwise tangent to circle*/
			return(2*i+1);
		}
d413 2
a414 1
	return -1;
d420 83
a502 83
	fastf_t yaw, pch, rll;
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
	int c, i;
	axes = cent = links_placed = print_wheel = print_link = 0;
	get_circumf = 0;
	print_mode = TRACK_ANIM;
	strcpy(link_cmd, "rarc");
	strcpy(wheel_cmd, "lmul");
        while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
                i=0;
                switch(c){
                case 'b':
                	bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf", &yaw );
                        sscanf(argv[bu_optind+(i++)],"%lf", &pch );
                        sscanf(argv[bu_optind+(i++)],"%lf", &rll );
			bu_optind += 3;
			anim_dx_y_z2mat(m_axes, rll, -pch, yaw);
			anim_dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
			axes = 1;
                        break;
                case 'd':
                        bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+2);
                        bu_optind += 3;
                        VREVERSE(rcentroid,centroid);
                	cent = 1;
                        break;
                case 'f':
                	sscanf(bu_optarg,"%d",&first_frame);
                        break;
                case 'i':
                	sscanf(bu_optarg,"%lf",&init_dist);
                	break;
                case 'p':
                	links_placed = 1;
                	break;
                case 'r':
                	sscanf(bu_optarg,"%lf",&radius);
                	break;
                case 'w':
                	wheel_nindex = bu_optind - 1;
                	/*sscanf(bu_optarg,"%s",wheel_name);*/
                	print_wheel = 1;
                        break;
                case 'l':
                	sscanf(bu_optarg,"%d", &num_links);
                	link_nindex = bu_optind;
                	bu_optind += 1;
                	print_link = 1;
                        break;
                case 's':
                	steer = 1;
                	break;
                case 'g':
                	sscanf(bu_optarg,"%d",&arced_frame);
                	print_mode = TRACK_ARCED;
                	break;
                case 'm':
                	switch (*bu_optarg) {
                	case 'l':
                		strncpy(link_cmd,argv[bu_optind], 10);
                		break;
                	case 'w':
                		strncpy(wheel_cmd,argv[bu_optind], 10);
                		break;
                	default:
                		fprintf(stderr,"Unknown option: -m%c\n",*bu_optarg);
                		return(0);
                	}
                	bu_optind += 1;
                	break;
                case 'c':
                	get_circumf = 1;
                	break;
                default:
                        fprintf(stderr,"Unknown option: -%c\n",c);
                        return(0);
                }
        }
        return(1);
d508 12
a519 12
	int i;
	if (which <=0){
		fprintf(stderr,"track length: %f\n",tracklen);
		fprintf(stderr,"link length: %f\n",tracklen/num_links);
		for (i=0;i<NW;i++){
			fprintf(stderr,"wheel %d: %f %f %f %f %f %f\n",i,x[i].w.pos[0],x[i].w.pos[1],x[i].w.pos[2],x[i].w.rad,x[i].w.ang1,x[i].w.arc);
			fprintf(stderr,"track %d: %f %f %f %f %f %f %f\n",i,x[i].t.pos1[0],x[i].t.pos1[1],x[i].t.pos1[2],x[i].t.dir[0],x[i].t.dir[1],x[i].t.dir[2],x[i].t.len);
			fprintf(stderr,"slope %d: %f %f %f %f\n",i,x[i].s.dir[0],x[i].s.dir[1],x[i].s.dir[2],x[i].s.len);
		}
	}
/*	if (which >= 0){
		fprintf(stderr,"%d %f %f %f %f\n",count,position[0],position[1],position[2],y_rot);
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2004 United States Government as represented by
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a31 2
 *  
 *
@


14.4
log
@remove the old distribution notice section
@
text
@a33 3
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a32 4
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file anim_hardtrack.c
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 2
a2 1
/*			A N I M _ H A R D T R A C K . C
d4 18
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d512 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d25 1
a25 3


#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

