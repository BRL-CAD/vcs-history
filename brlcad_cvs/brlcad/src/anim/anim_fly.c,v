head	14.14;
access;
symbols
	rel-7-10-4:14.14
	STABLE:14.14.0.2
	stable-branch:14.8
	rel-7-10-2:14.14
	rel-7-10-0:14.14
	rel-7-8-4:14.12
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.6
	rel-7-6-0:14.8
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.4
	bobWinPort:14.8.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.8
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.14
date	2007.01.23.01.13.23;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.42;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.02.27.10.08.38;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.23.07.08.23;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.12;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.02.14.02.29.35;	author brlcad;	state Exp;
branches
	14.8.6.1;
next	14.7;

14.7
date	2005.01.30.20.30.14;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.49;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.00.54.02;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.06;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.37;	author morrison;	state Exp;
branches;
next	;

14.8.6.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@/*                      A N I M _ F L Y . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file anim_fly.c
 *	Simulate flying motion, for an airplane or virtual camera.
 *
 *  This filter operates on animation tables. Given the desired position
 *  of the airplane in each frame, anim_fly produces a table including the
 *  plane's position and orientation. A "magic factor" should be supplied
 *  to control the severity of banking. Looping behavior can be toggled
 *  with another option.
 *
 *
 *  Author -
 *	Carl J. Nuzman
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#include "common.h"

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "anim.h"


#define MAXN	100

int estimate_f = 0;
fastf_t max_bank = 0;
fastf_t max_cross = 0;
int loop = 1;
int print_int = 1;
fastf_t magic_factor = 1.0;
fastf_t desired_step = 0.1;

int get_args(int argc, char **argv);

#define PREP	-1
#define START	0
#define MIDDLE	1
#define WANE	2
#define	END	3
#define STOP	4

int
main(int argc, char **argv)
{
    int count, status, num_read, enn, i, pp;
    fastf_t *points, *cur;
    fastf_t yaw, pch, rll, stepsize, first[4], second[4];
    fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h);
    void get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll);

    yaw = pch = rll = 0.0;

    if (!get_args(argc,argv))
	fprintf(stderr,"Anim_fly: Get_args error");

    /* read first two lines of table to determine the time step used */
    /* (a constant time step is assumed throughout the rest of the file)*/
    scanf("%lf %lf %lf %lf", first, first+1, first+2, first+3);
    scanf("%lf %lf %lf %lf", second, second+1, second+2, second+3);
    stepsize = second[0]-first[0];

    /* determine n, the number of points to store ahead and behind
     * the current point. 2n points are stored, minimum enn=2 */
    enn = (int) (desired_step/stepsize);
    if (enn>MAXN) enn=MAXN;
    if (enn<1) enn=1;

    /* allocate storage */
    points = (fastf_t *) bu_calloc((3*enn+1)*4, sizeof(fastf_t), "points");

    /* read the first 3n points into the storage array*/
    VMOVEN(points+4, first, 4);
    VMOVEN(points+8, second, 4);
    num_read=4; /* in order to pass test if n=1 */
    for (cur=points+12; cur<points+(4*(3*enn+1)); cur+=4){
	num_read=scanf("%lf %lf %lf %lf", cur,cur+1,cur+2,cur+3);
    }
    if (num_read<4){
	fprintf(stderr,"Anim_fly: Not enough lines in input table.\n");
	fprintf(stderr,"Increase number of lines or reduce the minimum stepsize with -s.\n");
	fprintf(stderr,"Currently the minumum step size is %g seconds.\n",desired_step);
	return 0;
    }

    max_cross = 0;
    count = 0;
    pp = 0;
    status = START;
    while (status != STOP) {
	switch (status) {
	case START: /* first n points */
	    pp += 4;
	    get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_0, &yaw, &pch, &rll);
	    if (!(count%print_int)&&!estimate_f) {
		printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[pp+0],points[pp+1],points[pp+2],points[pp+3],yaw,pch,rll);
	    }
	    if (pp >= 4*enn)
		status=MIDDLE;
	    break;
	case MIDDLE: /* middle points (at least one)*/
	    for (i=0; i<3*enn*4; i++){
		VMOVEN(points+(4*i), points+(4*(i+1)), 4);
	    }
	    num_read=scanf("%lf %lf %lf %lf", points+(4*(3*enn)),points+(4*(3*enn)+1),points+(4*(3*enn)+2),points+(4*(3*enn)+3));
	    if (num_read < 4) {
		pp = 0;
		status = WANE;
	    }
	    get_orientation(points,points+(4*enn),points+4*(2*enn), f_prm_1, &yaw, &pch, &rll);
	    if (!(count%print_int)&&!estimate_f) {
		printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[4*(enn)+0],points[4*(enn)+1],points[4*(enn)+2],points[4*(enn)+3],yaw,pch,rll);
	    }
	    break;
	case WANE: /* last n - 1 middle points */
	    pp += 4;
	    if (pp >= 4*enn){
		status = END;
		count--;
		pp = 0;
		break;
	    }
	    get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_1, &yaw, &pch, &rll);
	    if (!(count%print_int)&&!estimate_f) {
		printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[4*(enn)+0+pp],points[4*(enn)+1+pp],points[4*(enn)+2+pp],points[4*(enn)+3+pp],yaw,pch,rll);
	    }
	    break;
	case END: /* last n points */
	    get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_2, &yaw, &pch, &rll);
	    if (!(count%print_int)&&!estimate_f) {
		printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[8*enn+pp+0],points[8*enn+pp+1],points[8*enn+pp+2],points[8*enn+pp+3],yaw,pch,rll);
	    }
	    pp += 4;
	    if (pp >= 4*enn)
		status = STOP;
	    break;
	}
	count++;


    }

    /* Return the factor needed to achieve the requested max_bank */
    if (estimate_f){
	if (max_cross < VDIVIDE_TOL) {
	    printf("%.10g\n",0.0);
	} else {
	    printf("%.10g\n", 1000.0 * max_bank/max_cross);
	}
    }
    bu_free(points, "points");
    return( 0 );
}

void
get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll)
{
    int i;
    fastf_t step,vel[3],accel[3];
    fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h),xyz2yaw(fastf_t *d),xyz2pch(fastf_t *d),bank(fastf_t *acc, fastf_t *vel);

    static fastf_t last_yaw;
    static int not_first_time, upside_down;

    step = p2[0] - p1[0];
    for (i=1;i<4;i++) {
	vel[i-1] = (*function)(p0[i],p1[i],p2[i],step);
	accel[i-1] = f_double_prm(p0[i],p1[i],p2[i],step);
    }
    *p_yaw = xyz2yaw(vel);
    *p_pch = xyz2pch(vel);
    *p_rll = bank(accel,vel);

    if (fabs(*p_pch)==90.0) /* don't change yaw if velocity vertical */
	*p_yaw = last_yaw;

    /* avoid sudden yaw changes in vertical loops */
    if (not_first_time&&loop){
	if ((fabs(last_yaw - *p_yaw)<181.0)&&(fabs(last_yaw - *p_yaw)>179.0))
	    upside_down = (upside_down) ? 0 : 1;
	if (upside_down)
	    (*p_rll) += 180;
    }

    last_yaw = *p_yaw;
    not_first_time = 1;
}

/* determine the yaw of the given direction vector */
fastf_t	xyz2yaw(fastf_t *d)
{
    fastf_t yaw;
    yaw = RTOD*atan2(d[1],d[0]);
    if (yaw < 0.0) yaw += 360.0;
    return yaw;
}

/* determine the pitch of the given direction vector */
fastf_t	xyz2pch(fastf_t *d)
{
    fastf_t x;
    x = sqrt(d[0]*d[0] + d[1]*d[1]);
    return (RTOD*atan2(d[2],x));

}

/* given the 3-d velocity and acceleration of an imaginary aircraft,
   find the amount of bank the aircraft would need to undergo.
   Algorithm: the bank angle is proportional to the cross product
   of the horizontal velocity and horizontal acceleration, up to a
   maximum bank of 90 degrees in either direction. */
fastf_t bank(fastf_t *acc, fastf_t *vel)
{
    fastf_t cross;

    cross = vel[1]*acc[0] - vel[0]*acc[1];

    if (estimate_f) {
	max_cross = ( fabs(cross) > max_cross) ? fabs(cross) : max_cross;
    }

    cross *= magic_factor;

    if (cross > 90) cross = 90;
    if (cross < -90) cross = -90;
    return cross;
}

/* given f(t), f(t+h), f(t+2h), and h, calculate f'(t) */
fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
{
    return  -(3.0*x0 - 4.0*x1 + x2)/(2*h);
}

/* given f(t), f(t+h), f(t+2h), and h, calculate f'(t+h) */
fastf_t f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
{
    return (x2 - x0)/(2*h);
}

/* given f(t), f(t+h), f(t+2h), and h, calculate f'(t+2h) */
fastf_t f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
{
    return (x0 - 4.0*x1 + 3.0*x2)/(2*h);
}


/* given f(t), f(t+h), f(t+2*h),  and h, calculate f'' */
fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h)
{
    return (x0 - 2.0*x1 + x2)/(h*h);
}


/* code to read command line arguments*/
#define OPT_STR "b:f:p:s:r"
int get_args(int argc, char **argv)
{
    int c;

    estimate_f = 0;
    while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
	switch(c){
	case 'b':
	    sscanf(bu_optarg,"%lf",&max_bank);
	    estimate_f = 1;
	    break;
	case 'f':
	    sscanf(bu_optarg,"%lf",&magic_factor);
	    magic_factor *= 0.001; /* to put factors in a more reasonable range */
	    break;
	case 'p':
	    sscanf(bu_optarg,"%d",&print_int);
	    break;
	case 'r':
	    loop = 0;
	    break;
	case 's':
	    sscanf(bu_optarg, "%lf", &desired_step);
	    break;
	default:
	    fprintf(stderr,"Unknown option: -%c\n",c);
	    return(0);
	}
    }
    return(1);
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.13
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.12
log
@stdlib.h and exit()
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2006 United States Government as represented by
@


14.11
log
@libbu for memory management
@
text
@d43 1
a49 3
#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif
d110 1
a110 1
	exit(0);
@


14.10
log
@update copyright to 2006
@
text
@a38 1

a40 2


d99 1
a99 1
    points = (fastf_t *) calloc((3*enn+1)*4, sizeof(fastf_t));
d180 1
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1993-2005 United States Government as represented by
@


14.8
log
@M-x indent-region
@
text
@d27 2
a28 2
 *  plane's position and orientation. A "magic factor" should be supplied 
 *  to control the severity of banking. Looping behavior can be toggled 
d31 1
a31 1
 * 
d34 1
a34 1
 *  
d50 1
a50 1
#include "anim.h" 
d82 1
a82 1
    void get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll);	
d95 1
a95 1
    /* determine n, the number of points to store ahead and behind 
d98 1
a98 1
    if (enn>MAXN) enn=MAXN;	
d215 1
a215 1
	
d241 1
a241 1
   of the horizontal velocity and horizontal acceleration, up to a 
@


14.8.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d27 2
a28 2
 *  plane's position and orientation. A "magic factor" should be supplied
 *  to control the severity of banking. Looping behavior can be toggled
d31 1
a31 1
 *
d34 1
a34 1
 *
d50 1
a50 1
#include "anim.h"
d82 1
a82 1
    void get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll);
d95 1
a95 1
    /* determine n, the number of points to store ahead and behind
d98 1
a98 1
    if (enn>MAXN) enn=MAXN;
d215 1
a215 1

d241 1
a241 1
   of the horizontal velocity and horizontal acceleration, up to a
@


14.7
log
@update copyright to 2005
@
text
@d78 103
a180 32
	int count, status, num_read, enn, i, pp;
	fastf_t *points, *cur;
	fastf_t yaw, pch, rll, stepsize, first[4], second[4];
	fastf_t f_prm_0(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_1(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h), f_prm_2(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h);
	void get_orientation(fastf_t *p0, fastf_t *p1, fastf_t *p2, fastf_t (*function) (/* ??? */), fastf_t *p_yaw, fastf_t *p_pch, fastf_t *p_rll);	

	yaw = pch = rll = 0.0;

	if (!get_args(argc,argv))
		fprintf(stderr,"Anim_fly: Get_args error");

	/* read first two lines of table to determine the time step used */
	/* (a constant time step is assumed throughout the rest of the file)*/
	scanf("%lf %lf %lf %lf", first, first+1, first+2, first+3);
	scanf("%lf %lf %lf %lf", second, second+1, second+2, second+3);
	stepsize = second[0]-first[0];

	/* determine n, the number of points to store ahead and behind 
	 * the current point. 2n points are stored, minimum enn=2 */
	enn = (int) (desired_step/stepsize);
	if (enn>MAXN) enn=MAXN;	
	if (enn<1) enn=1;

	/* allocate storage */
	points = (fastf_t *) calloc((3*enn+1)*4, sizeof(fastf_t));

	/* read the first 3n points into the storage array*/
	VMOVEN(points+4, first, 4);
	VMOVEN(points+8, second, 4);
	num_read=4; /* in order to pass test if n=1 */
	for (cur=points+12; cur<points+(4*(3*enn+1)); cur+=4){
		num_read=scanf("%lf %lf %lf %lf", cur,cur+1,cur+2,cur+3);
d182 2
a183 73
	if (num_read<4){
		fprintf(stderr,"Anim_fly: Not enough lines in input table.\n");
		fprintf(stderr,"Increase number of lines or reduce the minimum stepsize with -s.\n");
		fprintf(stderr,"Currently the minumum step size is %g seconds.\n",desired_step);
		exit(0);
	}

	max_cross = 0;
	count = 0;
	pp = 0;
	status = START;
	while (status != STOP) {
		switch (status) {
		case START: /* first n points */
			pp += 4;
			get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_0, &yaw, &pch, &rll);
			if (!(count%print_int)&&!estimate_f) {
				printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[pp+0],points[pp+1],points[pp+2],points[pp+3],yaw,pch,rll);
			}
			if (pp >= 4*enn)
				status=MIDDLE;
			break;
		case MIDDLE: /* middle points (at least one)*/
			for (i=0; i<3*enn*4; i++){
				VMOVEN(points+(4*i), points+(4*(i+1)), 4);
			}
			num_read=scanf("%lf %lf %lf %lf", points+(4*(3*enn)),points+(4*(3*enn)+1),points+(4*(3*enn)+2),points+(4*(3*enn)+3));
			if (num_read < 4) {
				pp = 0;
				status = WANE;
			}
			get_orientation(points,points+(4*enn),points+4*(2*enn), f_prm_1, &yaw, &pch, &rll);
			if (!(count%print_int)&&!estimate_f) {
				printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[4*(enn)+0],points[4*(enn)+1],points[4*(enn)+2],points[4*(enn)+3],yaw,pch,rll);
			}
			break;
		case WANE: /* last n - 1 middle points */
			pp += 4;
			if (pp >= 4*enn){
				status = END;
				count--;
				pp = 0;
				break;
			}
			get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_1, &yaw, &pch, &rll);
			if (!(count%print_int)&&!estimate_f) {
				printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[4*(enn)+0+pp],points[4*(enn)+1+pp],points[4*(enn)+2+pp],points[4*(enn)+3+pp],yaw,pch,rll);
			}
			break;
		case END: /* last n points */
			get_orientation(points+pp,points+pp+4*enn,points+pp+4*2*enn, f_prm_2, &yaw, &pch, &rll);
			if (!(count%print_int)&&!estimate_f) {
				printf("%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\t%.10g\n",points[8*enn+pp+0],points[8*enn+pp+1],points[8*enn+pp+2],points[8*enn+pp+3],yaw,pch,rll);
			}
			pp += 4;
			if (pp >= 4*enn)
				status = STOP;
			break;
		}
		count++;


	}

	/* Return the factor needed to achieve the requested max_bank */
	if (estimate_f){
		if (max_cross < VDIVIDE_TOL) {
			printf("%.10g\n",0.0);
		} else {
			printf("%.10g\n", 1000.0 * max_bank/max_cross);
		}
	}
	return( 0 );
d189 26
a214 26
	int i;
	fastf_t step,vel[3],accel[3];
	fastf_t f_double_prm(fastf_t x0, fastf_t x1, fastf_t x2, fastf_t h),xyz2yaw(fastf_t *d),xyz2pch(fastf_t *d),bank(fastf_t *acc, fastf_t *vel);

	static fastf_t last_yaw;
	static int not_first_time, upside_down;

	step = p2[0] - p1[0];
	for (i=1;i<4;i++) {
		vel[i-1] = (*function)(p0[i],p1[i],p2[i],step);
		accel[i-1] = f_double_prm(p0[i],p1[i],p2[i],step);
	}
	*p_yaw = xyz2yaw(vel);
	*p_pch = xyz2pch(vel);
	*p_rll = bank(accel,vel);

	if (fabs(*p_pch)==90.0) /* don't change yaw if velocity vertical */
		*p_yaw = last_yaw;

	/* avoid sudden yaw changes in vertical loops */
	if (not_first_time&&loop){
		if ((fabs(last_yaw - *p_yaw)<181.0)&&(fabs(last_yaw - *p_yaw)>179.0))
			upside_down = (upside_down) ? 0 : 1;
		if (upside_down)
			(*p_rll) += 180;
	}
d216 2
a217 2
	last_yaw = *p_yaw;
	not_first_time = 1;
d223 4
a226 4
	fastf_t yaw;
	yaw = RTOD*atan2(d[1],d[0]);
	if (yaw < 0.0) yaw += 360.0;
	return yaw;
d232 3
a234 3
	fastf_t x;
	x = sqrt(d[0]*d[0] + d[1]*d[1]);
	return (RTOD*atan2(d[2],x));
d239 4
a242 4
    find the amount of bank the aircraft would need to undergo.
	Algorithm: the bank angle is proportional to the cross product
	of the horizontal velocity and horizontal acceleration, up to a 
	maximum bank of 90 degrees in either direction. */
d245 1
a245 1
	fastf_t cross;
d247 1
a247 1
	cross = vel[1]*acc[0] - vel[0]*acc[1];
d249 3
a251 3
	if (estimate_f) {
		max_cross = ( fabs(cross) > max_cross) ? fabs(cross) : max_cross;
	}
d253 1
a253 1
	cross *= magic_factor;
d255 3
a257 3
	if (cross > 90) cross = 90;
	if (cross < -90) cross = -90;
	return cross;
d263 1
a263 1
	return  -(3.0*x0 - 4.0*x1 + x2)/(2*h);
d269 1
a269 1
	return (x2 - x0)/(2*h);
d275 1
a275 1
	return (x0 - 4.0*x1 + 3.0*x2)/(2*h);
d282 1
a282 1
	return (x0 - 2.0*x1 + x2)/(h*h);
d290 1
a290 1
	int c;
d292 23
a314 24
	estimate_f = 0;
	while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
		switch(c){
		case 'b':
			sscanf(bu_optarg,"%lf",&max_bank);
			estimate_f = 1;
			break;
		case 'f':
			sscanf(bu_optarg,"%lf",&magic_factor);
			magic_factor *= 0.001; /* to put factors in a more reasonable range */
			break;
		case 'p':
			sscanf(bu_optarg,"%d",&print_int);
			break;
		case 'r':
			loop = 0;
			break;
		case 's':
			sscanf(bu_optarg, "%lf", &desired_step);
			break;
		default:
			fprintf(stderr,"Unknown option: -%c\n",c);
			return(0);
		}
d316 2
a317 1
	return(1);
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2004 United States Government as represented by
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a37 2
 *  
 *
@


14.4
log
@remove the old distribution notice section
@
text
@a39 3
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a38 4
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file anim_fly.c
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 2
a2 1
/*			A N I M _ F L Y . C
d4 18
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d309 10
@


1.2
log
@obliterate externs.h
@
text
@d29 1
a29 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a38 1
#include "externs.h"
@

