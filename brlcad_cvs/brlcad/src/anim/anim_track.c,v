head	14.16;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.8
	rel-7-10-2:14.15
	rel-7-10-0:14.15
	rel-7-8-4:14.12
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.6
	rel-7-6-0:14.8
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.4
	bobWinPort:14.8.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.8
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.16
date	2007.09.15.16.23.03;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.31;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.23;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.42;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.23.07.20.53;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.23.07.08.23;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.12;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.02.14.02.29.35;	author brlcad;	state Exp;
branches
	14.8.6.1;
next	14.7;

14.7
date	2005.01.30.20.30.14;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.49;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.00.54.02;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.55;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.07;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.40;	author morrison;	state Exp;
branches;
next	;

14.8.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                    A N I M _ T R A C K . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file anim_track.c
 *  Animate the links and wheels of a tracked vehicle. Handles tracks that
 *  change in shape during the animation.
 *
 *  Author -
 *	Carl J. Nuzman
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#include "common.h"

#include <math.h>
#include <stdio.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "anim.h"

#define GIVEN		0
#define CALCULATED	1
#define STEERED		2

#define PRINT_ANIM	0
#define PRINT_ARCED	1

#define TRACK_MIN	0
#define TRACK_FIXED	1
#define TRACK_STRETCH	2
#define TRACK_ELASTIC	3

#define NW	num_wheels
#define NEXT(i)	(i+1)%NW
#define PREV(i)	(i+NW-1)%NW
typedef double *pdouble;

struct wheel {
    vect_t		pos;	/* displacement of wheel from vehicle origin */
    fastf_t		rad;	/* radius of wheel */
    fastf_t		ang0;	/* angle where track meets wheel 0<a<2pi*/
    fastf_t		ang1;	/* angle where track leaves wheel 0<a<p2i */
    fastf_t		arc;	/* radian length of contact between wheel and track 0<a<pi*/
};

struct track {
    vect_t		pos0;	/* beginning point of track section */
    vect_t		pos1;	/* end of track section */
    vect_t		dir;	/* unit vector:direction of track section ending here*/
    fastf_t		len;	/* length of track section ending here*/
};

struct slope {
    vect_t		dir;	/* vector from previous to current axle*/
    fastf_t		len;	/* length of vector above*/
};

struct all {
    struct wheel 	w;	/* parameters describing the track around a wheel */
    struct track	t;	/* track between this wheel and the previous wheel */
    struct slope	s;	/* vector between this axle and the previous axle */
};

/* external variables */
extern int bu_optind;
extern char *bu_optarg;

/* variables describing track geometry - used by main, trackprep, get_link*/
struct all *x;

fastf_t curve_a, curve_b, curve_c, s_start;
int num_links, num_wheels;
fastf_t track_y, tracklen, first_tracklen;

/* variables set by get_args */
int wheel_nindex;	/* argv[wheel_nindex] = wheelname*/
int link_nindex;	/* argv[link_nindex] = linkname*/
int print_wheel;	/* flag: do wheel animation */
int print_link;		/* flag: do link animation */
int print_mode;		/*  anim for rt or arced for mged */
int arced_frame;	/* which frame to arced */
int  axes, cent;	/* flags: alternate axes, centroid specified */
int dist_mode;		/* given, steered, or calculated  */
int  first_frame;	/* integer to begin numbering frames */
fastf_t init_dist;	/* initial distance of first link along track */
int one_radius;		/* flag: common radius specified */
fastf_t radius;		/* common radius of all wheels */
vect_t centroid, rcentroid;	/* alternate centroid and its reverse */
mat_t m_axes, m_rev_axes;	/* matrices to and from alternate axes */
char link_cmd[10];		/* default is "rarc" */
char wheel_cmd[10];		/* default is "lmul" */
int get_circumf;	/* flag: just return circumference of track */
int read_wheels;		/* flag: read new wheel positions each frame */
int len_mode;		/* mode for track_len */
int anti_strobe;	/* flag: take measures against strobing effect */

int
main(int argc, char **argv)
{
    void anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *), anim_mat_print(FILE *, const fastf_t *, int);
    int get_args(int argc, char **argv), get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist), track_prep(void), val, frame, i, count;
    int go;
    fastf_t y_rot, distance, yaw, pch, roll;
    vect_t cent_pos, wheel_now, wheel_prev;
    vect_t zero, position, vdelta, temp, to_track, to_front;
    mat_t wmat, mat_x;
    FILE *stream;
    struct wheel *wh;
    int last_steer, last_frame;
    int rndtabi=0;
    fastf_t halfpadlen, delta, prev_dist;

    VSETALL(zero,0.0);
    VSETALL(to_track,0.0);
    VSETALL(centroid,0.0);
    VSETALL(rcentroid,0.0);
    y_rot = 0.0;
    num_wheels = 0;
    last_steer = last_frame = 0;
    MAT_IDN(mat_x);
    MAT_IDN(wmat);
    MAT_IDN(m_axes);
    MAT_IDN(m_rev_axes);

    if (!get_args(argc,argv))
	fprintf(stderr,"Anim_track: Argument error.\n");

    if (axes || cent ){ /* vehicle has own reference frame */
	anim_add_trans(m_axes,centroid,zero);
	anim_add_trans(m_rev_axes,zero,rcentroid);
    }

    /* get track information from specified file */

    if (!(stream = fopen(*(argv+bu_optind),"r"))){
	fprintf(stderr,"Track: Could not open file %s.\n",*(argv+bu_optind));
	return(0);
    }
    num_wheels = -1;
    if (one_radius) {
	while (!feof(stream)) {
	    fscanf(stream,"%*f %*f %*f");
	    num_wheels++;
	}
    } else {
	while (!feof(stream)) {
	    fscanf(stream,"%*f %*f %*f %*f");
	    num_wheels++;
	}
    }
    rewind(stream);


    /*allocate memory for track information*/
    /* x: contains track geometry for the current frame */
    x = (struct all *) bu_calloc(num_wheels,sizeof(struct all), "x all");
    /* wh: contains geometry of wheels in mged database */
    wh = (struct wheel *) bu_calloc(num_wheels,sizeof(struct wheel), "wh wheel");

    /*read original wheel positions*/
    for (i=0;i<NW;i++){
	fscanf(stream,"%lf %lf %lf", temp, temp+1, temp+2);
	if (one_radius)
	    x[i].w.rad = radius;
	else
	    fscanf(stream,"%lf",& x[i].w.rad);
	MAT4X3PNT(x[i].w.pos,m_rev_axes,temp);
	if (i==0)
	    track_y = x[0].w.pos[1];
	else
	    x[i].w.pos[1] = track_y;


	wh[i].pos[0] = x[i].w.pos[0];
	wh[i].pos[1] = x[i].w.pos[1];
	wh[i].pos[2] = x[i].w.pos[2];
	wh[i].rad = x[i].w.rad;
    }
    (void) fclose(stream);

    /* initialize to_track */
    VSET(to_track, 0.0, track_y, 0.0);
    VSET(to_front,1.0,0.0,0.0);

    if (get_circumf&& (!read_wheels)) {
	track_prep();
	printf("%.10g\n",tracklen);
	return(0);
    }


    if (dist_mode==STEERED) {
	/* prime the pumps */
	scanf("%*f");/*time*/
	val = scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos + 2);
	if (val < 3)
	    return(0);
	go = anim_steer_mat(mat_x, cent_pos, 0);
	last_steer = 0;
    } else {
	go = 1;
    }

    if (anti_strobe) {
	BN_RANDSEED(rndtabi, 0);
    }

    /* main loop */
    prev_dist = distance = 0.0;
    frame = first_frame;
    for ( ; ; frame++) {
	if (dist_mode==GIVEN){
	    scanf("%*f");/*time*/
	    val = scanf("%lf",&distance);
	    if (val < 1) {
		break;
	    }
	}
	else if (dist_mode==CALCULATED){
	    scanf("%*f");/*time*/
	    scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos+2);
	    val = scanf("%lf %lf %lf",&yaw,&pch,&roll);
	    if (val < 3)
		break;
	    anim_dy_p_r2mat(mat_x,yaw,pch,roll);
	    anim_dy_p_r2mat(mat_x,yaw,pch,roll);
	    anim_add_trans(mat_x,cent_pos,rcentroid);
	}

	if (read_wheels) {
	    /* read in all wheel positions */
	    for(i=0;i<NW;i++){
		val=scanf("%lf %lf",x[i].w.pos, x[i].w.pos + 2);
		if (val < 2) {
		    break;
		}
	    }
	}

	if (dist_mode==STEERED) {
	    scanf("%*f");/*time*/
	    val = scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos + 2);
	    if (val < 3){
		if (last_steer)
		    break;
		else
		    last_steer = 1;
	    }
	    go = anim_steer_mat(mat_x, cent_pos, last_steer);
	    anim_add_trans(mat_x,cent_pos,rcentroid);
	}

	/* call track_prep to calculate geometry of track */
	if ((frame==first_frame)||read_wheels) {
	    if ((track_prep())==-1){
		fprintf(stderr,"Track: error in frame %d: track too short.\n",frame);
		break;
	    }
	    if (get_circumf) {
		printf("%d\t%.10g\n",frame,tracklen);
	    }
	}


	if ((dist_mode==CALCULATED)||(dist_mode==STEERED)){
	    /*determine distance traveled*/
	    VMOVE(wheel_prev,wheel_now);
	    MAT4X3PNT(wheel_now,mat_x,to_track);
	    if (frame > first_frame){ /* increment distance by distance moved*/
		VSUB2(vdelta,wheel_now,wheel_prev);
		MAT3X3VEC(temp,mat_x,to_front);/*new front of vehicle*/
		distance += VDOT(temp,vdelta);/*portion of vdelta in line with track*/
	    }
	}

	if (anti_strobe) {
	    halfpadlen = 0.5 * tracklen/(fastf_t) num_links;
	    delta = distance - prev_dist;
	    prev_dist = distance;
	    if ((delta >= halfpadlen)||(delta <= -halfpadlen)) {
		distance += BN_RANDOM(rndtabi) * 2.0* halfpadlen;
	    }
	}

	if (go && (!get_circumf)) {
	    if (print_mode==PRINT_ANIM) {
		printf("start %d;\nclean;\n", frame);
	    } else if (print_mode==PRINT_ARCED) {
		if (frame != arced_frame) continue;
		last_frame = 1;
	    }
	    if (print_link) {
		for (count=0;count<num_links;count++){
		    (void) get_link(position,&y_rot,distance+tracklen*count/num_links+init_dist);
		    anim_y_p_r2mat(wmat,0.0,y_rot,0.0);
		    anim_add_trans(wmat,position,zero);
		    if (axes || cent){ /* link moved to vehicle coords */
			MAT_MOVE(mat_x,wmat);
			bn_mat_mul(wmat,m_axes,mat_x);
		    }
		    if (print_mode==PRINT_ANIM) {
			printf("anim %s%d matrix %s\n", *(argv+link_nindex),count,link_cmd);
			anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
		    } else if (print_mode==PRINT_ARCED) {
			printf("arced %s%d matrix %s ", *(argv+link_nindex),count,link_cmd);
			anim_mat_printf(stdout,wmat,"%.10g ","","\n");
		    }
		}
	    }
	    if (print_wheel){
		for (count = 0;count<num_wheels;count++){
		    anim_y_p_r2mat(wmat,0.0,-distance/wh[count].rad,0.0);
		    VREVERSE(temp,wh[count].pos);
		    anim_add_trans(wmat,x[count].w.pos,temp);
		    if (axes || cent){
			bn_mat_mul(mat_x,wmat,m_rev_axes);
			bn_mat_mul(wmat,m_axes,mat_x);
		    }
		    if (print_mode==PRINT_ANIM) {
			printf("anim %s%d matrix %s\n",*(argv+wheel_nindex),count,wheel_cmd);
			anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
		    } else if (print_mode==PRINT_ARCED) {
			printf("arced %s%d matrix %s ",*(argv+wheel_nindex),count,wheel_cmd);
			anim_mat_printf(stdout,wmat,"%.10g ","","\n");
		    }
		}
	    }
	    if (print_mode==PRINT_ANIM)
		printf("end;\n");
	}
	if (last_frame) break;
    }
    bu_free(x, "x all");
    bu_free(wh, "wh wheel");
    return( 0 );
}

#define OPT_STR "sycuvb:d:f:i:r:p:w:g:m:l:a"

int get_args(int argc, char **argv)
{
    int c, i;
    fastf_t yaw, pch, rll;
    void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
    /* defaults*/
    wheel_nindex = link_nindex = 0;
    axes = cent = print_wheel = print_link = 0;
    arced_frame = first_frame = 0;
    init_dist = radius = 0.0;
    one_radius = get_circumf = read_wheels = 0;
    strcpy(link_cmd, "rarc");
    strcpy(wheel_cmd, "lmul");
    print_mode = PRINT_ANIM;
    dist_mode = GIVEN;
    len_mode = TRACK_MIN;
    anti_strobe = 0;

    while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
	i=0;
	switch(c){
	case 's':
	    dist_mode = STEERED;
	    break;
	case 'y':
	    dist_mode = CALCULATED;
	    break;
	case 'c':
	    get_circumf = 1;
	    break;
	case 'u':
	    dist_mode = GIVEN;
	    break;
	case 'v':
	    read_wheels = 1;
	    break;
	case 'b':
	    bu_optind -= 1;
	    sscanf(argv[bu_optind+(i++)],"%lf", &yaw );
	    sscanf(argv[bu_optind+(i++)],"%lf", &pch );
	    sscanf(argv[bu_optind+(i++)],"%lf", &rll );
	    bu_optind += 3;
	    anim_dx_y_z2mat(m_axes, rll, -pch, yaw);
	    anim_dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
	    axes = 1;
	    break;
	case 'd':
	    bu_optind -= 1;
	    sscanf(argv[bu_optind+(i++)],"%lf",centroid);
	    sscanf(argv[bu_optind+(i++)],"%lf",centroid+1);
	    sscanf(argv[bu_optind+(i++)],"%lf",centroid+2);
	    bu_optind += 3;
	    VREVERSE(rcentroid,centroid);
	    cent = 1;
	    break;
	case 'f':
	    sscanf(bu_optarg,"%d",&first_frame);
	    break;
	case 'i':
	    sscanf(bu_optarg,"%lf",&init_dist);
	    break;
	case 'r':
	    sscanf(bu_optarg,"%lf",&radius);
	    one_radius = 1;
	    break;
	case 'p':
	    sscanf(bu_optarg,"%d", &num_links);
	    link_nindex = bu_optind;
	    bu_optind += 1;
	    print_link = 1;
	    break;
	case 'w':
	    wheel_nindex = bu_optind - 1;
	    /*sscanf(bu_optarg,"%s",wheel_name);*/
	    print_wheel = 1;
	    break;
	case 'g':
	    sscanf(bu_optarg,"%d",&arced_frame);
	    print_mode = PRINT_ARCED;
	    break;
	case 'm':
	    switch (*bu_optarg) {
	    case 'p':
		strncpy(link_cmd,argv[bu_optind], 10);
		break;
	    case 'w':
		strncpy(wheel_cmd,argv[bu_optind], 10);
		break;
	    default:
		fprintf(stderr,"Unknown option: -m%c\n",*bu_optarg);
		return(0);
	    }
	    bu_optind += 1;
	    break;
	case 'l':
	    switch (*bu_optarg) {
	    case 'm':
		len_mode = TRACK_MIN;
		break;
	    case 'f':
		len_mode = TRACK_FIXED;
		sscanf(argv[bu_optind],"%lf",&first_tracklen);
		tracklen = first_tracklen;
		bu_optind++;
		break;
	    case 's':
		len_mode = TRACK_STRETCH;
		sscanf(argv[bu_optind],"%lf",&first_tracklen);
		tracklen = first_tracklen;
		bu_optind++;
		break;
	    case 'e':
		len_mode = TRACK_ELASTIC;
		sscanf(argv[bu_optind],"%lf",&first_tracklen);
		tracklen = first_tracklen;
		bu_optind++;
		break;
	    default:
		fprintf(stderr,"Unknown option: -l%c\n",*bu_optarg);
		return(0);
	    }
	    break;
	case 'a':
	    anti_strobe = 1;
	    break;
	default:
	    fprintf(stderr,"Unknown option: -%c\n",c);
	    return(0);
	}
    }
    return(1);
}

/* TRACK_PREP - Calculate the geometry of the track. Wheel positions and
 * radii should already exist in the x[i] structs. Track_prep fills in the
 * rest of the x[i] structs and also calculates values for curve_a, curve_b,
 * curve_c, and s_start, which describe the caternary segment
 * return values: 0 = GOOD
 * 		 -1 = BAD. Track too short to fit around wheels
 */
int track_prep(void)
{
    int i;
    fastf_t phi, costheta, arc_angle;
    fastf_t linearlen, hyperlen;
    vect_t difference;
    int getcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t *pth0, fastf_t *pth1, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one, fastf_t r_zero, fastf_t r_one);
    fastf_t hyper_get_s(fastf_t a, fastf_t c, fastf_t x);

    /* first loop - get inter axle slopes and start/end angles */
    for (i=0;i<NW;i++){
	/*calculate current slope vector*/
	VSUB2(x[i].s.dir,x[i].w.pos,x[PREV(i)].w.pos);
	x[i].s.len = MAGNITUDE(x[i].s.dir);
	/*calculate end angle of previous wheel assuming all convex*/
	phi = atan2(x[i].s.dir[2],x[i].s.dir[0]);/*absolute angle of slope*/
	costheta = (x[PREV(i)].w.rad - x[i].w.rad)/x[i].s.len;/*cosine of special angle*/
	x[PREV(i)].w.ang1 = phi +  acos(costheta);
	while (x[PREV(i)].w.ang1 < 0.0)
	    x[PREV(i)].w.ang1 += 2.0*M_PI;
	x[i].w.ang0 = x[PREV(i)].w.ang1;
    }
    /* second loop - handle concavities */
    for (i=0;i<NW;i++){
	arc_angle = x[i].w.ang0 - x[i].w.ang1;
	while (arc_angle < 0.0)
	    arc_angle += 2.0*M_PI;
	if (arc_angle > M_PI) { /* concave */
	    x[i].w.ang0 = 0.5*(x[i].w.ang0 + x[i].w.ang1);
	    x[i].w.ang1 = x[i].w.ang0;
	    x[i].w.arc = 0.0;
	}
	else { /* convex - angles are already correct */
	    x[i].w.arc = arc_angle;
	}
    }

    /* third loop - calculate geometry of straight track segments */
    for (i=0;i<NW;i++){
	/*calculate endpoints of track segment*/
	x[i].t.pos1[0] = x[i].w.pos[0] + x[i].w.rad*cos(x[i].w.ang0);
	x[i].t.pos1[1] = x[i].w.pos[1];
	x[i].t.pos1[2] = x[i].w.pos[2] + x[i].w.rad*sin(x[i].w.ang0);
	x[i].t.pos0[0] = x[PREV(i)].w.pos[0] + x[PREV(i)].w.rad*cos(x[PREV(i)].w.ang1);
	x[i].t.pos0[1] = x[PREV(i)].w.pos[1];
	x[i].t.pos0[2] = x[PREV(i)].w.pos[2] + x[PREV(i)].w.rad*sin(x[PREV(i)].w.ang1);
	/*calculate length and direction of track segment*/
	VSUB2(difference,x[i].t.pos1,x[i].t.pos0);
	x[i].t.len = MAGNITUDE(difference);
	VSCALE((x[i].t.dir),difference,(1.0/x[i].t.len));
    }

    /* calculate total track length used so far*/
    linearlen = x[0].w.arc*x[0].w.rad;
    for (i=1;i<NW;i++){
	linearlen += x[i].t.len;
	linearlen += x[i].w.arc*x[i].w.rad;
    }

    if (len_mode==TRACK_MIN) {
	tracklen = linearlen + x[0].t.len;
	curve_a = 0.0;
	return(0); /* early return */
    }

    if (len_mode==TRACK_ELASTIC) {
	tracklen = first_tracklen;
    }

    /* calculate geometry of hyperbolic segment */
    hyperlen = tracklen - linearlen;
    if(hyperlen < x[0].t.len){ /* desired length of hyperbola less than straight line*/
	if((len_mode==TRACK_ELASTIC)||(len_mode==TRACK_STRETCH)){
	    tracklen += (x[0].t.len-hyperlen);
	    hyperlen = tracklen - linearlen;
	}
	else{
	    return(-1);/*bad, track is too short*/
	}
    }

    getcurve(&curve_a,&curve_b,&curve_c,&(x[NW-1].w.ang1),&(x[0].w.ang0),hyperlen,x[NW-1].w.pos,x[0].w.pos,x[NW-1].w.rad,x[0].w.rad);

    /* re-evaluate zeroth track section in light of curve information */
    x[0].t.pos0[X] = x[NW-1].w.pos[X] + x[NW-1].w.rad * cos(x[NW-1].w.ang1);
    x[0].t.pos0[Z] = x[NW-1].w.pos[Z] + x[NW-1].w.rad * sin(x[NW-1].w.ang1);
    x[0].t.pos1[X] = x[0].w.pos[X] + x[0].w.rad * cos(x[0].w.ang0);
    x[0].t.pos1[Z] = x[0].w.pos[Z] + x[0].w.rad * sin(x[0].w.ang0);
    VSUB2(difference,x[0].t.pos1,x[0].t.pos0);
    x[0].t.len = MAGNITUDE(difference);
    VSCALE(x[0].t.dir,difference,(1.0/x[0].t.len));

    if (curve_a > VDIVIDE_TOL)
	s_start = hyper_get_s(curve_a, 0.0, x[0].t.pos0[X] - curve_c);

    x[0].w.arc = x[0].w.ang0 - x[0].w.ang1;
    if (x[0].w.arc<0.0)
	x[0].w.arc += 2.0*M_PI;
    x[NW-1].w.arc = x[NW-1].w.ang0 - x[NW-1].w.ang1;
    if (x[NW-1].w.arc<0.0)
	x[NW-1].w.arc += 2.0*M_PI;

    return(0); /*good*/
}

/* GET_LINK - Find the position and angle of a link which is a given
 * distance around the track, measured from the point where the caternary
 * section meets wheel.0.
 */
int get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist)
{
    int i;
    vect_t temp;
    fastf_t hyper_get_x(fastf_t a, fastf_t c, fastf_t s, int d, int x, int cos_ang), hyper_get_z(fastf_t a, fastf_t b, fastf_t c, fastf_t x), hyper_get_ang(fastf_t a, fastf_t c, fastf_t x);

    while (dist >= tracklen) /*periodicize*/
	dist -= tracklen;
    while (dist < 0.0)
	dist += tracklen;

    /* we want it to ignore the distance between wheel(n-1) and wheel(0)*/
    dist += x[0].t.len;
    for (i=0;i<NW;i++){
	if ( (dist  -= x[i].t.len) < 0 ){
	    VSCALE(temp,(x[i].t.dir),dist);
	    VADD2(pos,x[i].t.pos1,temp);
	    *angle_p = atan2(x[i].t.dir[2],x[i].t.dir[0]);
	    return(2*i);
	}
	if ((dist -= x[i].w.rad*x[i].w.arc) < 0){
	    *angle_p = dist/x[i].w.rad;
	    *angle_p = x[i].w.ang1 - *angle_p;/*from x-axis to link*/
	    pos[X] = x[i].w.pos[X] + x[i].w.rad*cos(*angle_p);
	    pos[Y] = x[i].w.pos[Y];
	    pos[Z] = x[i].w.pos[Z] + x[i].w.rad*sin(*angle_p);
	    *angle_p -= M_PI_2; /*angle of clockwise tangent to circle*/
	    return(2*i+1);
	}
    }

    /* caternary section */
    if ( curve_a > VDIVIDE_TOL){
	pos[X] = hyper_get_x(curve_a, 0.0, s_start+dist, 0, 0, 0);
	pos[Y] = x[0].w.pos[Y];
	pos[Z] = hyper_get_z(curve_a,curve_b,0.0, pos[X]);
	pos[X] += curve_c;
	*angle_p = hyper_get_ang(curve_a,curve_c, pos[X]);
    }
    else { /* practically linear */
	VSCALE(temp,(x[0].t.dir),dist);
	VADD2(pos,x[0].t.pos0,temp);
	*angle_p = atan2(x[0].t.dir[Z],x[0].t.dir[X]);
    }


    return -1;
}

void show_info(int which)/* for debugging - -1:track 0:both 1:link*/

{
    int i;
    if (which <=0){
	fprintf(stderr,"track length: %f\n",tracklen);
	fprintf(stderr,"link length: %f\n",tracklen/num_links);
	for (i=0;i<NW;i++){
	    fprintf(stderr,"wheel %d: \n",i);
	    fprintf(stderr," pos\t%f\t%f\t%f\t\n",x[i].w.pos[X],x[i].w.pos[Y],x[i].w.pos[Z]);
	    fprintf(stderr," rad\t%f\tang0\t%f\tang1\t%f\tarc\t%f\n",x[i].w.rad,x[i].w.ang0,x[i].w.ang1,x[i].w.arc);

	    fprintf(stderr,"track %d: \n",i);
	    fprintf(stderr," pos0\t%f\t%f\tpos1\t%f\t%f\n",x[i].t.pos0[X],x[i].t.pos0[Z],x[i].t.pos1[X],x[i].t.pos1[Z]);
	    fprintf(stderr," dir\t%f\t%f\t%f\tlen\t%f\n",x[i].t.dir[X],x[i].t.dir[Y],x[i].t.dir[Z],x[i].t.len);
	    fprintf(stderr,"slope %d: %f %f %f %f\n",i,x[i].s.dir[0],x[i].s.dir[1],x[i].s.dir[2],x[i].s.len);
	}
    }
    /*	if (which >= 0){
	fprintf(stderr,"%d %f %f %f %f\n",count,position[0],position[1],position[2],y_rot);
	}*/
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a34 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d37 1
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a291 1

a661 1

@


14.13
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.12
log
@s/nmu/num/ transpose
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2006 United States Government as represented by
@


14.11
log
@libbu for memory management
@
text
@d184 1
a184 1
    x = (struct all *) bu_calloc(nmu_wheels,sizeof(struct all), "x all");
@


14.10
log
@update copyright to 2006
@
text
@d37 1
a37 1
#include <string.h>
d39 1
a39 1
#include <strings.h>
a40 1

d43 1
a48 8
#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif

#ifndef M_PI_2
#define M_PI_2	1.57079632679489661923
#endif

d184 1
a184 1
    x = (struct all *) calloc(num_wheels,sizeof(struct all));
d186 1
a186 1
    wh = (struct wheel *) calloc(num_wheels,sizeof(struct wheel));
d362 2
a363 2
    free(x);
    free(wh);
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1993-2005 United States Government as represented by
@


14.8
log
@M-x indent-region
@
text
@d28 1
a28 1
 *  
d170 1
a170 1
	
d226 1
a226 1
		
d288 1
a288 1
		
d302 1
a302 1
	if ((dist_mode==CALCULATED)||(dist_mode==STEERED)){ 
d553 1
a553 1
	
d585 1
a585 1
		
d608 1
a608 1
		
d611 1
a611 1
	
d638 1
a638 1
    dist += x[0].t.len; 
d672 1
a672 1
	
d677 1
a677 1
          
@


14.8.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d170 1
a170 1

d226 1
a226 1

d288 1
a288 1

d302 1
a302 1
	if ((dist_mode==CALCULATED)||(dist_mode==STEERED)){
d553 1
a553 1

d585 1
a585 1

d608 1
a608 1

d611 1
a611 1

d638 1
a638 1
    dist += x[0].t.len;
d672 1
a672 1

d677 1
a677 1

@


14.7
log
@update copyright to 2005
@
text
@d75 5
a79 5
vect_t		pos;	/* displacement of wheel from vehicle origin */
fastf_t		rad;	/* radius of wheel */
fastf_t		ang0;	/* angle where track meets wheel 0<a<2pi*/
fastf_t		ang1;	/* angle where track leaves wheel 0<a<p2i */
fastf_t		arc;	/* radian length of contact between wheel and track 0<a<pi*/
d83 4
a86 4
vect_t		pos0;	/* beginning point of track section */
vect_t		pos1;	/* end of track section */
vect_t		dir;	/* unit vector:direction of track section ending here*/
fastf_t		len;	/* length of track section ending here*/
d90 2
a91 2
vect_t		dir;	/* vector from previous to current axle*/
fastf_t		len;	/* length of vector above*/
d95 3
a97 3
struct wheel 	w;	/* parameters describing the track around a wheel */
struct track	t;	/* track between this wheel and the previous wheel */
struct slope	s;	/* vector between this axle and the previous axle */
d136 32
a167 32
	void anim_y_p_r2mat(fastf_t *, double, double, double), anim_add_trans(fastf_t *, const fastf_t *, const fastf_t *), anim_mat_print(FILE *, const fastf_t *, int);
	int get_args(int argc, char **argv), get_link(fastf_t *pos, fastf_t *angle_p, fastf_t dist), track_prep(void), val, frame, i, count;
	int go;
	fastf_t y_rot, distance, yaw, pch, roll;
	vect_t cent_pos, wheel_now, wheel_prev;
	vect_t zero, position, vdelta, temp, to_track, to_front;
	mat_t wmat, mat_x;
	FILE *stream;
	struct wheel *wh;
	int last_steer, last_frame;
	int rndtabi=0;
	fastf_t halfpadlen, delta, prev_dist;

	VSETALL(zero,0.0);
	VSETALL(to_track,0.0);
	VSETALL(centroid,0.0);
	VSETALL(rcentroid,0.0);
	y_rot = 0.0;
	num_wheels = 0;
	last_steer = last_frame = 0;
	MAT_IDN(mat_x);
	MAT_IDN(wmat);
	MAT_IDN(m_axes);
	MAT_IDN(m_rev_axes);

	if (!get_args(argc,argv))
		fprintf(stderr,"Anim_track: Argument error.\n");

	if (axes || cent ){ /* vehicle has own reference frame */
		anim_add_trans(m_axes,centroid,zero);
		anim_add_trans(m_rev_axes,zero,rcentroid);
	}
d169 1
a169 1
	/* get track information from specified file */
d171 101
a271 14
	if (!(stream = fopen(*(argv+bu_optind),"r"))){
		fprintf(stderr,"Track: Could not open file %s.\n",*(argv+bu_optind));
		return(0);
	}
	num_wheels = -1;
	if (one_radius) {
		while (!feof(stream)) {
			fscanf(stream,"%*f %*f %*f");
			num_wheels++;
		}
	} else {
		while (!feof(stream)) {
			fscanf(stream,"%*f %*f %*f %*f");
			num_wheels++;
d273 1
a274 1
	rewind(stream);
d276 6
a281 12

	/*allocate memory for track information*/
	/* x: contains track geometry for the current frame */
	x = (struct all *) calloc(num_wheels,sizeof(struct all));
	/* wh: contains geometry of wheels in mged database */
	wh = (struct wheel *) calloc(num_wheels,sizeof(struct wheel));

	/*read original wheel positions*/
	for (i=0;i<NW;i++){
		fscanf(stream,"%lf %lf %lf", temp, temp+1, temp+2);
		if (one_radius)
			x[i].w.rad = radius;
d283 15
a297 12
			fscanf(stream,"%lf",& x[i].w.rad);
		MAT4X3PNT(x[i].w.pos,m_rev_axes,temp);
		if (i==0)
			track_y = x[0].w.pos[1];
		else
			x[i].w.pos[1] = track_y;


		wh[i].pos[0] = x[i].w.pos[0];
		wh[i].pos[1] = x[i].w.pos[1];
		wh[i].pos[2] = x[i].w.pos[2];
		wh[i].rad = x[i].w.rad;
a298 1
	(void) fclose(stream);
a299 3
	/* initialize to_track */
	VSET(to_track, 0.0, track_y, 0.0);
	VSET(to_front,1.0,0.0,0.0);
a300 6
	if (get_circumf&& (!read_wheels)) {
		track_prep();
		printf("%.10g\n",tracklen);
		return(0);
	}
		
d302 9
a310 10
	if (dist_mode==STEERED) {
		/* prime the pumps */
		scanf("%*f");/*time*/
		val = scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos + 2);
		if (val < 3)
			return(0);
		go = anim_steer_mat(mat_x, cent_pos, 0);
		last_steer = 0;
	} else {
		go = 1;
d314 59
a372 132
		BN_RANDSEED(rndtabi, 0);
	}

	/* main loop */
	prev_dist = distance = 0.0;
	frame = first_frame;
	for ( ; ; frame++) {
		if (dist_mode==GIVEN){
			scanf("%*f");/*time*/
			val = scanf("%lf",&distance);
			if (val < 1) {
				break;
			}
		}
		else if (dist_mode==CALCULATED){
			scanf("%*f");/*time*/
			scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos+2);
			val = scanf("%lf %lf %lf",&yaw,&pch,&roll);
			if (val < 3)
				break;
			anim_dy_p_r2mat(mat_x,yaw,pch,roll);
			anim_dy_p_r2mat(mat_x,yaw,pch,roll);
			anim_add_trans(mat_x,cent_pos,rcentroid);
		}

		if (read_wheels) {
			/* read in all wheel positions */
			for(i=0;i<NW;i++){
				val=scanf("%lf %lf",x[i].w.pos, x[i].w.pos + 2);
				if (val < 2) {
					break;
				}
			}
		}

		if (dist_mode==STEERED) {
			scanf("%*f");/*time*/
			val = scanf("%lf %lf %lf", cent_pos, cent_pos+1, cent_pos + 2);
			if (val < 3){
				if (last_steer)
					break;
				else
					last_steer = 1;
			}
			go = anim_steer_mat(mat_x, cent_pos, last_steer);
			anim_add_trans(mat_x,cent_pos,rcentroid);
		}
		
		/* call track_prep to calculate geometry of track */
		if ((frame==first_frame)||read_wheels) {
			if ((track_prep())==-1){
				fprintf(stderr,"Track: error in frame %d: track too short.\n",frame);
				break;
			}
			if (get_circumf) {
				printf("%d\t%.10g\n",frame,tracklen);
			}
		}



		if ((dist_mode==CALCULATED)||(dist_mode==STEERED)){ 
			/*determine distance traveled*/
			VMOVE(wheel_prev,wheel_now);
			MAT4X3PNT(wheel_now,mat_x,to_track);
			if (frame > first_frame){ /* increment distance by distance moved*/
				VSUB2(vdelta,wheel_now,wheel_prev);
				MAT3X3VEC(temp,mat_x,to_front);/*new front of vehicle*/
				distance += VDOT(temp,vdelta);/*portion of vdelta in line with track*/
			}
		}

		if (anti_strobe) {
			halfpadlen = 0.5 * tracklen/(fastf_t) num_links;
			delta = distance - prev_dist;
			prev_dist = distance;
			if ((delta >= halfpadlen)||(delta <= -halfpadlen)) {
				distance += BN_RANDOM(rndtabi) * 2.0* halfpadlen;
			}
		}

		if (go && (!get_circumf)) {
			if (print_mode==PRINT_ANIM) {
				printf("start %d;\nclean;\n", frame);
			} else if (print_mode==PRINT_ARCED) {
				if (frame != arced_frame) continue;
				last_frame = 1;
			}
			if (print_link) {
			        for (count=0;count<num_links;count++){
		        	        (void) get_link(position,&y_rot,distance+tracklen*count/num_links+init_dist);
					anim_y_p_r2mat(wmat,0.0,y_rot,0.0);
			        	anim_add_trans(wmat,position,zero);
			        	if (axes || cent){ /* link moved to vehicle coords */
			        		MAT_MOVE(mat_x,wmat);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	if (print_mode==PRINT_ANIM) {
						printf("anim %s%d matrix %s\n", *(argv+link_nindex),count,link_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
			        	} else if (print_mode==PRINT_ARCED) {
			        		printf("arced %s%d matrix %s ", *(argv+link_nindex),count,link_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","","\n");
			        	}
				}
			}
			if (print_wheel){
				for (count = 0;count<num_wheels;count++){
					anim_y_p_r2mat(wmat,0.0,-distance/wh[count].rad,0.0);
					VREVERSE(temp,wh[count].pos);
					anim_add_trans(wmat,x[count].w.pos,temp);
			        	if (axes || cent){
				        	bn_mat_mul(mat_x,wmat,m_rev_axes);
			        		bn_mat_mul(wmat,m_axes,mat_x);
			        	}
			        	if (print_mode==PRINT_ANIM) {
						printf("anim %s%d matrix %s\n",*(argv+wheel_nindex),count,wheel_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","\n",";\n");
			        	} else if (print_mode==PRINT_ARCED) {
						printf("arced %s%d matrix %s ",*(argv+wheel_nindex),count,wheel_cmd);
			        		anim_mat_printf(stdout,wmat,"%.10g ","","\n");
			        	}
				}
			}
			if (print_mode==PRINT_ANIM)
				printf("end;\n");
		}
		if (last_frame) break;
	}
	free(x);
	free(wh);
	return( 0 );
d379 129
a507 129
	int c, i;
	fastf_t yaw, pch, rll;
	void anim_dx_y_z2mat(fastf_t *, double, double, double), anim_dz_y_x2mat(fastf_t *, double, double, double);
	/* defaults*/
	wheel_nindex = link_nindex = 0;
	axes = cent = print_wheel = print_link = 0;
	arced_frame = first_frame = 0;
	init_dist = radius = 0.0;
	one_radius = get_circumf = read_wheels = 0;
	strcpy(link_cmd, "rarc");
	strcpy(wheel_cmd, "lmul");
	print_mode = PRINT_ANIM;
	dist_mode = GIVEN;
	len_mode = TRACK_MIN;
	anti_strobe = 0;

        while ( (c=bu_getopt(argc,argv,OPT_STR)) != EOF) {
                i=0;
                switch(c){
                case 's':
                	dist_mode = STEERED;
                	break;
                case 'y':
                	dist_mode = CALCULATED;
                	break;
                case 'c':
                	get_circumf = 1;
                	break;
                case 'u':
                	dist_mode = GIVEN;
                	break;
                case 'v':
                	read_wheels = 1;
                	break;
                case 'b':
                	bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf", &yaw );
                        sscanf(argv[bu_optind+(i++)],"%lf", &pch );
                        sscanf(argv[bu_optind+(i++)],"%lf", &rll );
			bu_optind += 3;
			anim_dx_y_z2mat(m_axes, rll, -pch, yaw);
			anim_dz_y_x2mat(m_rev_axes, -rll, pch, -yaw);
			axes = 1;
                        break;
                case 'd':
                        bu_optind -= 1;
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+1);
                        sscanf(argv[bu_optind+(i++)],"%lf",centroid+2);
                        bu_optind += 3;
                        VREVERSE(rcentroid,centroid);
                	cent = 1;
                        break;
                case 'f':
                	sscanf(bu_optarg,"%d",&first_frame);
                        break;
                case 'i':
                	sscanf(bu_optarg,"%lf",&init_dist);
                	break;
                case 'r':
                	sscanf(bu_optarg,"%lf",&radius);
                	one_radius = 1;
                	break;
                case 'p':
                	sscanf(bu_optarg,"%d", &num_links);
                	link_nindex = bu_optind;
                	bu_optind += 1;
                	print_link = 1;
                        break;
                case 'w':
                	wheel_nindex = bu_optind - 1;
                	/*sscanf(bu_optarg,"%s",wheel_name);*/
                	print_wheel = 1;
                        break;
                case 'g':
                	sscanf(bu_optarg,"%d",&arced_frame);
                	print_mode = PRINT_ARCED;
                	break;
                case 'm':
                	switch (*bu_optarg) {
                	case 'p':
                		strncpy(link_cmd,argv[bu_optind], 10);
                		break;
                	case 'w':
                		strncpy(wheel_cmd,argv[bu_optind], 10);
                		break;
                	default:
                		fprintf(stderr,"Unknown option: -m%c\n",*bu_optarg);
                		return(0);
                	}
                	bu_optind += 1;
                	break;
                case 'l':
                	switch (*bu_optarg) {
                	case 'm':
                		len_mode = TRACK_MIN;
                		break;
                	case 'f':
                		len_mode = TRACK_FIXED;
	                	sscanf(argv[bu_optind],"%lf",&first_tracklen);
	                	tracklen = first_tracklen;
	                	bu_optind++;
                		break;
                	case 's':
	        		len_mode = TRACK_STRETCH;
	                	sscanf(argv[bu_optind],"%lf",&first_tracklen);
	                	tracklen = first_tracklen;
	                	bu_optind++;
                       		break;
                	case 'e':
                		len_mode = TRACK_ELASTIC;
	                	sscanf(argv[bu_optind],"%lf",&first_tracklen);
	                	tracklen = first_tracklen;
	                	bu_optind++;
                		break;
                	default:
                		fprintf(stderr,"Unknown option: -l%c\n",*bu_optarg);
                		return(0);
                	}
                	break;
                case 'a':
                	anti_strobe = 1;
                	break;
                default:
                        fprintf(stderr,"Unknown option: -%c\n",c);
                        return(0);
                }
        }
        return(1);
d519 29
a547 19
	int i;
	fastf_t phi, costheta, arc_angle;
	fastf_t linearlen, hyperlen;
	vect_t difference;
	int getcurve(fastf_t *pa, fastf_t *pb, fastf_t *pc, fastf_t *pth0, fastf_t *pth1, fastf_t delta_s, fastf_t *p_zero, fastf_t *p_one, fastf_t r_zero, fastf_t r_one);
	fastf_t hyper_get_s(fastf_t a, fastf_t c, fastf_t x);

	/* first loop - get inter axle slopes and start/end angles */
	for (i=0;i<NW;i++){
		/*calculate current slope vector*/
		VSUB2(x[i].s.dir,x[i].w.pos,x[PREV(i)].w.pos);
		x[i].s.len = MAGNITUDE(x[i].s.dir);
		/*calculate end angle of previous wheel assuming all convex*/
		phi = atan2(x[i].s.dir[2],x[i].s.dir[0]);/*absolute angle of slope*/
		costheta = (x[PREV(i)].w.rad - x[i].w.rad)/x[i].s.len;/*cosine of special angle*/
		x[PREV(i)].w.ang1 = phi +  acos(costheta);
		while (x[PREV(i)].w.ang1 < 0.0)
			x[PREV(i)].w.ang1 += 2.0*M_PI;
		x[i].w.ang0 = x[PREV(i)].w.ang1;
d549 2
a550 13
	/* second loop - handle concavities */
	for (i=0;i<NW;i++){
		arc_angle = x[i].w.ang0 - x[i].w.ang1;
		while (arc_angle < 0.0)
			arc_angle += 2.0*M_PI;
		if (arc_angle > M_PI) { /* concave */
			x[i].w.ang0 = 0.5*(x[i].w.ang0 + x[i].w.ang1);
			x[i].w.ang1 = x[i].w.ang0;
			x[i].w.arc = 0.0;
		}
		else { /* convex - angles are already correct */
			x[i].w.arc = arc_angle;
		}
d552 1
d554 31
a584 31
	/* third loop - calculate geometry of straight track segments */
	for (i=0;i<NW;i++){
		/*calculate endpoints of track segment*/
		x[i].t.pos1[0] = x[i].w.pos[0] + x[i].w.rad*cos(x[i].w.ang0);
		x[i].t.pos1[1] = x[i].w.pos[1];
		x[i].t.pos1[2] = x[i].w.pos[2] + x[i].w.rad*sin(x[i].w.ang0);
		x[i].t.pos0[0] = x[PREV(i)].w.pos[0] + x[PREV(i)].w.rad*cos(x[PREV(i)].w.ang1);
		x[i].t.pos0[1] = x[PREV(i)].w.pos[1];
		x[i].t.pos0[2] = x[PREV(i)].w.pos[2] + x[PREV(i)].w.rad*sin(x[PREV(i)].w.ang1);
		/*calculate length and direction of track segment*/
		VSUB2(difference,x[i].t.pos1,x[i].t.pos0);
		x[i].t.len = MAGNITUDE(difference);
		VSCALE((x[i].t.dir),difference,(1.0/x[i].t.len));
	}

	/* calculate total track length used so far*/
	linearlen = x[0].w.arc*x[0].w.rad;
	for (i=1;i<NW;i++){
		linearlen += x[i].t.len;
		linearlen += x[i].w.arc*x[i].w.rad;
	}

	if (len_mode==TRACK_MIN) {
		tracklen = linearlen + x[0].t.len;
		curve_a = 0.0;
		return(0); /* early return */
	}

	if (len_mode==TRACK_ELASTIC) {
		tracklen = first_tracklen;
	}
d586 22
a607 22
	/* calculate geometry of hyperbolic segment */
	hyperlen = tracklen - linearlen;
	if(hyperlen < x[0].t.len){ /* desired length of hyperbola less than straight line*/
		if((len_mode==TRACK_ELASTIC)||(len_mode==TRACK_STRETCH)){
			tracklen += (x[0].t.len-hyperlen);
			hyperlen = tracklen - linearlen;
		}
		else{
			return(-1);/*bad, track is too short*/
		}
	}

	getcurve(&curve_a,&curve_b,&curve_c,&(x[NW-1].w.ang1),&(x[0].w.ang0),hyperlen,x[NW-1].w.pos,x[0].w.pos,x[NW-1].w.rad,x[0].w.rad);

	/* re-evaluate zeroth track section in light of curve information */
	x[0].t.pos0[X] = x[NW-1].w.pos[X] + x[NW-1].w.rad * cos(x[NW-1].w.ang1);
	x[0].t.pos0[Z] = x[NW-1].w.pos[Z] + x[NW-1].w.rad * sin(x[NW-1].w.ang1);
	x[0].t.pos1[X] = x[0].w.pos[X] + x[0].w.rad * cos(x[0].w.ang0);
	x[0].t.pos1[Z] = x[0].w.pos[Z] + x[0].w.rad * sin(x[0].w.ang0);
	VSUB2(difference,x[0].t.pos1,x[0].t.pos0);
	x[0].t.len = MAGNITUDE(difference);
	VSCALE(x[0].t.dir,difference,(1.0/x[0].t.len));
d609 2
a610 2
	if (curve_a > VDIVIDE_TOL)
		s_start = hyper_get_s(curve_a, 0.0, x[0].t.pos0[X] - curve_c);
d612 6
a617 6
	x[0].w.arc = x[0].w.ang0 - x[0].w.ang1;
	if (x[0].w.arc<0.0)
		x[0].w.arc += 2.0*M_PI;
	x[NW-1].w.arc = x[NW-1].w.ang0 - x[NW-1].w.ang1;
	if (x[NW-1].w.arc<0.0)
		x[NW-1].w.arc += 2.0*M_PI;
d619 1
a619 1
	return(0); /*good*/
d628 42
a669 42
	int i;
	vect_t temp;
	fastf_t hyper_get_x(fastf_t a, fastf_t c, fastf_t s, int d, int x, int cos_ang), hyper_get_z(fastf_t a, fastf_t b, fastf_t c, fastf_t x), hyper_get_ang(fastf_t a, fastf_t c, fastf_t x);

	while (dist >= tracklen) /*periodicize*/
		dist -= tracklen;
	while (dist < 0.0)
		dist += tracklen;

	/* we want it to ignore the distance between wheel(n-1) and wheel(0)*/
	dist += x[0].t.len; 
	for (i=0;i<NW;i++){
		if ( (dist  -= x[i].t.len) < 0 ){
			VSCALE(temp,(x[i].t.dir),dist);
			VADD2(pos,x[i].t.pos1,temp);
			*angle_p = atan2(x[i].t.dir[2],x[i].t.dir[0]);
			return(2*i);
		}
		if ((dist -= x[i].w.rad*x[i].w.arc) < 0){
			*angle_p = dist/x[i].w.rad;
			*angle_p = x[i].w.ang1 - *angle_p;/*from x-axis to link*/
			pos[X] = x[i].w.pos[X] + x[i].w.rad*cos(*angle_p);
			pos[Y] = x[i].w.pos[Y];
			pos[Z] = x[i].w.pos[Z] + x[i].w.rad*sin(*angle_p);
			*angle_p -= M_PI_2; /*angle of clockwise tangent to circle*/
			return(2*i+1);
		}
	}

	/* caternary section */
	if ( curve_a > VDIVIDE_TOL){
		pos[X] = hyper_get_x(curve_a, 0.0, s_start+dist, 0, 0, 0);
		pos[Y] = x[0].w.pos[Y];
		pos[Z] = hyper_get_z(curve_a,curve_b,0.0, pos[X]);
		pos[X] += curve_c;
		*angle_p = hyper_get_ang(curve_a,curve_c, pos[X]);
	}
	else { /* practically linear */
		VSCALE(temp,(x[0].t.dir),dist);
		VADD2(pos,x[0].t.pos0,temp);
		*angle_p = atan2(x[0].t.dir[Z],x[0].t.dir[X]);
	}
d673 1
a673 1
	return -1;
d679 17
a695 17
	int i;
	if (which <=0){
		fprintf(stderr,"track length: %f\n",tracklen);
		fprintf(stderr,"link length: %f\n",tracklen/num_links);
		for (i=0;i<NW;i++){
			fprintf(stderr,"wheel %d: \n",i);
			fprintf(stderr," pos\t%f\t%f\t%f\t\n",x[i].w.pos[X],x[i].w.pos[Y],x[i].w.pos[Z]);
			fprintf(stderr," rad\t%f\tang0\t%f\tang1\t%f\tarc\t%f\n",x[i].w.rad,x[i].w.ang0,x[i].w.ang1,x[i].w.arc);

			fprintf(stderr,"track %d: \n",i);
			fprintf(stderr," pos0\t%f\t%f\tpos1\t%f\t%f\n",x[i].t.pos0[X],x[i].t.pos0[Z],x[i].t.pos1[X],x[i].t.pos1[Z]);
			fprintf(stderr," dir\t%f\t%f\t%f\tlen\t%f\n",x[i].t.dir[X],x[i].t.dir[Y],x[i].t.dir[Z],x[i].t.len);
			fprintf(stderr,"slope %d: %f %f %f %f\n",i,x[i].s.dir[0],x[i].s.dir[1],x[i].s.dir[2],x[i].s.len);
		}
	}
/*	if (which >= 0){
		fprintf(stderr,"%d %f %f %f %f\n",count,position[0],position[1],position[2],y_rot);
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2004 United States Government as represented by
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a31 2
 *  
 *
@


14.4
log
@remove the old distribution notice section
@
text
@a33 3
 *  Copyright Notice -
 *      This software is Copyright (C) 1993-2004 by the United States Army
 *      in all countries except the USA.  All rights reserved.
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a32 4
 *  Distribution Notice -
 *      Re-distribution of this software is restricted, as described in
 *      your "Statement of Terms and Conditions for the Release of
 *      The BRL-CAD Pacakge" agreement.
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file anim_track.c
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 2
a2 1
/*			A N I M _ T R A C K . C
d4 18
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d688 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d25 1
a25 3


#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a37 1
#include "externs.h"
@

