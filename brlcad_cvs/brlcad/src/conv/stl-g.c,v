head	14.27;
access;
symbols
	rel-7-10-4:14.22
	STABLE:14.22.0.2
	stable-branch:14.7
	rel-7-10-2:14.22
	rel-7-10-0:14.18
	rel-7-8-4:14.14
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.8.2.1
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.4
	rel-7-6-0:14.8
	rel-7-4-2:14.7.2.1
	rel-7-4-branch:14.7.0.2
	bobWinPort:14.8.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.27
date	2007.11.21.20.49.06;	author erikgreenwald;	state Exp;
branches;
next	14.26;

14.26
date	2007.11.21.20.38.21;	author erikgreenwald;	state Exp;
branches;
next	14.25;

14.25
date	2007.11.21.19.05.59;	author erikgreenwald;	state Exp;
branches;
next	14.24;

14.24
date	2007.11.21.15.21.33;	author erikgreenwald;	state Exp;
branches;
next	14.23;

14.23
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.07.26.01.13.51;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.05.18.04.13.44;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.04.14.01.16.02;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.04.11.18.52.01;	author bob1961;	state Exp;
branches;
next	14.18;

14.18
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.27.01.41.32;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.36.44;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.08.18.04.28.29;	author johnranderson;	state Exp;
branches;
next	14.13;

14.13
date	2006.08.08.05.15.23;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.28.00.36.27;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.12.23.21.26.29;	author bob1961;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.07.26.04.40.53;	author brlcad;	state Exp;
branches
	14.8.2.1
	14.8.4.1;
next	14.7;

14.7
date	2005.01.30.20.30.20;	author brlcad;	state Exp;
branches
	14.7.2.1;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.51;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.10;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.10;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.57;	author morrison;	state Exp;
branches;
next	;

14.7.2.1
date	2005.08.16.21.03.48;	author brlcad;	state Exp;
branches;
next	;

14.8.2.1
date	2005.09.13.18.53.08;	author bob1961;	state Exp;
branches;
next	;

14.8.4.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.27
log
@pass bu_exit a NULL instead of an empty string
@
text
@/*                         S T L - G . C
 * BRL-CAD
 *
 * Copyright (c) 2002-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file stl-g.c
 *		S T L - G
 *
 * Code to convert Stereolithography format files to BRL-CAD
 *	Note that binary STL format is Little-endian (bytes at lower addresses have lower significance)
 *
 *  Author -
 *	John R. Anderson
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.26 2007/11/21 20:38:21 erikgreenwald Exp $";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>

#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"

static struct vert_root *tree_root;
static struct wmember all_head;
static char *input_file;	/* name of the input file */
static char *brlcad_file;	/* name of output file */
static struct bu_vls ret_name;	/* unique name built by Build_unique_name() */
static char *forced_name=NULL;	/* name specified on command line */
static int solid_count=0;	/* count of solids converted */
static struct bn_tol tol;	/* Tolerance structure */
static int id_no=1000;		/* Ident numbers */
static int const_id=-1;		/* Constant ident number (assigned to all regions if non-negative) */
static int mat_code=1;		/* default material code */
static int debug=0;		/* Debug flag */
static int binary=0;		/* flag indicating input is binary format */

static char *usage="%s [-db] [-t tolerance] [-N forced_name] [-i initial_ident] [-I constant_ident] [-m material_code] [-c units_str] [-x rt_debug_flag] input.stl output.g\n\
	where input.stl is a STereoLithography file\n\
	and output.g is the name of a BRL-CAD database file to receive the conversion.\n\
	The -b option specifies that the input file is in the binary STL format (default is ASCII). \n\
	The -c option specifies the units used in the STL file (units_str may be \"in\", \"ft\",... default is \"mm\"\n\
	The -N option specifies a name to use for the object.\n\
	The -d option prints additional debugging information.\n\
	The -i option sets the initial region ident number (default is 1000).\n\
	The -I option sets the ident number that will be assigned to all regions (conflicts with -i).\n\
	The -m option sets the integer material code for all the parts (default is 1).\n\
	The -t option specifies the minumim distance between two distinct vertices (mm).\n\
	The -x option specifies an RT debug flags (see debug.h).\n";
static FILE *fd_in;		/* input file */
static struct rt_wdb *fd_out;	/* Resulting BRL-CAD file */
static float conv_factor=1.0;	/* conversion factor from model units to mm */
static unsigned int obj_count=0; /* Count of parts converted for "stl-g" conversions */
static int *bot_faces=NULL;	 /* array of ints (indices into tree_root->the_array array) three per face */
static int bot_fsize=0;		/* current size of the bot_faces array */
static int bot_fcurr=0;		/* current bot face */

/* Size of blocks of faces to malloc */
#define BOT_FBLOCK	128

#define	MAX_LINE_LEN	512

void
Add_face( face )
int face[3];
{
	if( !bot_faces )
	{
		bot_faces = (int *)bu_malloc( 3 * BOT_FBLOCK * sizeof( int ), "bot_faces" );
		bot_fsize = BOT_FBLOCK;
		bot_fcurr = 0;
	}
	else if( bot_fcurr >= bot_fsize )
	{
		bot_fsize += BOT_FBLOCK;
		bot_faces = (int *)bu_realloc( (void *)bot_faces, 3 * bot_fsize * sizeof( int ), "bot_faces increase" );
	}

	VMOVE( &bot_faces[3*bot_fcurr], face );
	bot_fcurr++;
}

void
mk_unique_brlcad_name( struct bu_vls *name )
{
	char *c;
	int count=0;
	int len;

	c = bu_vls_addr( name );

	while( *c != '\0' ) {
		if( *c == '/' || !isprint( *c ) ) {
			*c = '_';
		}
		c++;
	}

	len = bu_vls_strlen( name );
	while( db_lookup( fd_out->dbip, bu_vls_addr( name ), LOOKUP_QUIET ) != DIR_NULL ) {
		char suff[10];

		bu_vls_trunc( name, len );
		count++;
		sprintf( suff, "_%d", count );
		bu_vls_strcat( name, suff );
	}
}

static void
Convert_part_ascii( line )
char line[MAX_LINE_LEN];
{
	char line1[MAX_LINE_LEN];
	struct bu_vls solid_name;
	struct bu_vls region_name;

	int start;
	int i;
	int face_count=0;
	int degenerate_count=0;
	int small_count=0;
	float colr[3]={0.5, 0.5, 0.5};
	unsigned char color[3]={ 128, 128, 128 };
	struct wmember head;
	vect_t normal={0,0,0};
	int solid_in_region=0;

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_prmem( "At start of Conv_prt():\n" );

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at start of Convet_part:\n" );
		if( bu_mem_barriercheck() )
			bu_exit(EXIT_FAILURE,  "Barrier check failed!!!\n" );
	}


	bot_fcurr = 0;
	BU_LIST_INIT( &head.l );

	start = (-1);
	/* skip leading blanks */
	while( isspace( line[++start] ) && line[start] != '\0' );
	if( strncmp( &line[start] , "solid" , 5 ) && strncmp( &line[start] , "SOLID" , 5 ) )
	{
		bu_log( "Convert_part_ascii: Called for non-part\n%s\n" , line );
		return;
	}

	/* skip blanks before name */
	start += 4;
	while( isspace( line[++start] ) && line[start] != '\0' );

	bu_vls_init( &region_name );
	if( forced_name )
		bu_vls_strcpy( &region_name, forced_name );
	else if( line[start] != '\0' )
	{
		char *ptr;

		/* get name */
		bu_vls_strcpy( &region_name, &line[start] );
		bu_vls_trimspace( &region_name );
		ptr = bu_vls_addr( &region_name );
		while( *ptr != '\0' ) {
			if( isspace( *ptr ) ) {
				bu_vls_trunc( &region_name, ptr - bu_vls_addr( &region_name ) );
				break;
			}
			ptr++;
		}
	}
	else /* build a name from the file name */
	{
		char *ptr;
		int base_len;

		obj_count++;

		/* copy the file name into our work space (skip over path) */
		ptr = strrchr( input_file, '/' );
		if( ptr ) {
			ptr++;
			bu_vls_strcpy( &region_name, ptr );
		} else {
			bu_vls_strcpy( &region_name, input_file );
		}

		/* eliminate a trailing ".stl" */
		ptr = strstr( bu_vls_addr( &region_name ), ".stl" );
		if( (base_len=(ptr - bu_vls_addr( &region_name ))) > 0 ) {
			bu_vls_trunc( &region_name, base_len );
		}
	}

	mk_unique_brlcad_name( &region_name );
	bu_log( "Converting Part: %s\n" , bu_vls_addr( &region_name ) );

	solid_count++;
	bu_vls_init( &solid_name );
	bu_vls_strcpy( &solid_name, "s." );
	bu_vls_vlscat( &solid_name, &region_name );
	mk_unique_brlcad_name( &solid_name );

	bu_log( "\tUsing solid name: %s\n" , bu_vls_addr( &solid_name ) );

	if( RT_G_DEBUG & DEBUG_MEM || RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_prmem( "At start of Convert_part_ascii()" );

	while( bu_fgets( line1, MAX_LINE_LEN, fd_in ) != NULL )
	{
		start = (-1);
		while( isspace( line1[++start] ) );
		if( !strncmp( &line1[start] , "endsolid" , 8 ) || !strncmp( &line1[start] , "ENDSOLID" , 8 ) )
			break;
		else if( !strncmp( &line1[start] , "color" , 5 ) || !strncmp( &line1[start] , "COLOR" , 5 ) )
		{
			sscanf( &line1[start+5] , "%f%f%f" , &colr[0] , &colr[1] , &colr[2] );
			for( i=0 ; i<3 ; i++ )
				color[i] = (int)(colr[i] * 255.0);
		}
		else if( !strncmp( &line1[start] , "normal" , 6 ) || !strncmp( &line1[start] , "NORMAL" , 6 ) )
		{
			float x,y,z;

			start += 6;
			sscanf( &line1[start] , "%f%f%f" , &x , &y , &z );
			VSET( normal , x , y , z );
		}
		else if( !strncmp( &line1[start] , "facet" , 5 ) || !strncmp( &line1[start] , "FACET" , 5 ) )
		{
			VSET( normal , 0.0 , 0.0 , 0.0 );

			start += 4;
			while( line1[++start] && isspace( line1[start] ) );

			if( line1[start] )
			{
				if( !strncmp( &line1[start] , "normal" , 6 ) || !strncmp( &line1[start] , "NORMAL" , 6 ) )
				{
					float x,y,z;

					start += 6;
					sscanf( &line1[start] , "%f%f%f" , &x , &y , &z );
					VSET( normal , x , y , z );
				}
			}
		}
		else if( !strncmp( &line1[start] , "outer loop" , 10 ) || !strncmp( &line1[start] , "OUTER LOOP" , 10 ) )
		{
			int endloop=0;
			int vert_no=0;
			int tmp_face[3];

			while( !endloop )
			{
				if( bu_fgets( line1, MAX_LINE_LEN, fd_in ) == NULL )
					bu_exit(EXIT_FAILURE,  "Unexpected EOF while reading a loop in a part!!!\n" );

				start = (-1);
				while( isspace( line1[++start] ) );

				if( !strncmp( &line1[start] , "endloop" , 7 ) || !strncmp( &line1[start] , "ENDLOOP" , 7 ) )
					endloop = 1;
				else if ( !strncmp( &line1[start] , "vertex" , 6 ) || !strncmp( &line1[start] , "VERTEX" , 6 ) )
				{
					double x,y,z;

					sscanf( &line1[start+6] , "%lf%lf%lf" , &x , &y , &z );

					if( vert_no > 2 )
					{
						int n;

						bu_log( "Non-triangular loop:\n" );
						for( n=0 ; n<3 ; n++ )
							bu_log( "\t( %g %g %g )\n", V3ARGS( &tree_root->the_array[tmp_face[n]] ) );

						bu_log( "\t( %g %g %g )\n", x, y, z );
					}
					x *= conv_factor;
					y *= conv_factor;
					z *= conv_factor;
					tmp_face[vert_no++] = Add_vert( x, y, z, tree_root, tol.dist_sq );
				}
				else
					bu_log( "Unrecognized line: %s\n", line1 );
			}

			/* check for degenerate faces */
			if( tmp_face[0] == tmp_face[1] )
			{
				degenerate_count++;
				continue;
			}

			if( tmp_face[0] == tmp_face[2] )
			{
				degenerate_count++;
				continue;
			}

			if( tmp_face[1] == tmp_face[2] )
			{
				degenerate_count++;
				continue;
			}

			if( debug )
			{
				int n;

				bu_log( "Making Face:\n" );
				for( n=0 ; n<3; n++ )
					bu_log( "\tvertex #%d: ( %g %g %g )\n", tmp_face[n], V3ARGS( &tree_root->the_array[3*tmp_face[n]] ) );
				VPRINT(" normal", normal);
			}

			Add_face( tmp_face );
			face_count++;
		}
	}

	/* Check if this part has any solid parts */
	if( face_count == 0 )
	{
		bu_log( "\t%s has no solid parts, ignoring\n" , bu_vls_addr( &region_name ) );
		if( degenerate_count )
			bu_log( "\t%d faces were degenerate\n", degenerate_count );
		if( small_count )
			bu_log( "\t%d faces were too small\n", small_count );
		bu_vls_free( &region_name );
		bu_vls_free( &solid_name );

		return;
	}
	else
	{
		if( degenerate_count )
			bu_log( "\t%d faces were degenerate\n", degenerate_count );
		if( small_count )
			bu_log( "\t%d faces were too small\n", small_count );
	}

	mk_bot( fd_out, bu_vls_addr( &solid_name ), RT_BOT_SOLID, RT_BOT_UNORIENTED, 0, tree_root->curr_vert, bot_fcurr,
		tree_root->the_array, bot_faces, NULL, NULL );
	clean_vert_tree( tree_root );

	if( face_count && !solid_in_region )
	{
		(void)mk_addmember( bu_vls_addr( &solid_name ) , &head.l , NULL, WMOP_UNION );
	}

	bu_log( "\tMaking region (%s)\n" , bu_vls_addr( &region_name ) );

	if( const_id >= 0 ) {
		mk_lrcomb( fd_out, bu_vls_addr( &region_name ), &head, 1, (char *)NULL,
			   (char *)NULL, color, const_id, 0, mat_code, 100, 0 );
		if( face_count ) {
				(void)mk_addmember( bu_vls_addr( &region_name ), &all_head.l,
						    NULL, WMOP_UNION );
		}
	} else {
		mk_lrcomb( fd_out, bu_vls_addr( &region_name ), &head, 1, (char *)NULL,
			   (char *)NULL, color, id_no, 0, mat_code, 100, 0 );
		if( face_count )
			(void)mk_addmember( bu_vls_addr( &region_name ), &all_head.l,
					    NULL, WMOP_UNION );
		id_no++;
	}

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at end of Convert_part_ascii:\n" );
		if( bu_mem_barriercheck() )
			bu_exit(EXIT_FAILURE,  "Barrier check failed!!!\n" );
	}

	bu_vls_free( &region_name );
	bu_vls_free( &solid_name );

	return;
}

/* Byte swaps a 4-byte val */
void lswap(unsigned int *v)
{
	unsigned int r;

	r = *v;
	*v = ((r & 0xff) << 24) | ((r & 0xff00) << 8) | ((r & 0xff0000) >> 8)
		| ((r & 0xff000000) >> 24);
}

static void
Convert_part_binary()
{
	unsigned char buf[51];
	unsigned long num_facets=0;
	float flts[12];
	vect_t normal;
	int tmp_face[3];
	struct wmember head;
	struct bu_vls solid_name;
	struct bu_vls region_name;
	int face_count=0;
	int degenerate_count=0;
	int small_count=0;

	solid_count++;
	bu_vls_init( &solid_name );
	bu_vls_init( &region_name );
	if( forced_name ) {
		bu_vls_strcpy( &solid_name, "s." );
		bu_vls_strcat( &solid_name, forced_name );
		bu_vls_strcpy( &region_name, forced_name );
	} else {
		bu_vls_strcat( &solid_name, "s.stl" );
		bu_vls_strcat( &region_name, "r.stl" );
	}
	bu_log( "\tUsing solid name: %s\n" , bu_vls_addr( &solid_name ) );


	fread( buf, 4, 1, fd_in );

	/* swap bytes to convert from Little-endian to network order (big-endian) */
	lswap( (unsigned int *)buf );

	/* now use our network to native host format conversion tools */
	num_facets = bu_glong( buf );

	bu_log( "\t%d facets\n", num_facets );
	while( fread( buf, 48, 1, fd_in ) ) {
		int i;
		double pt[3];

		/* swap bytes to convert from Little-endian to network order (big-endian) */
		for( i=0 ; i<12 ; i++ ) {
			lswap( (unsigned int *)&buf[i*4] );
		}

		/* now use our network to native host format conversion tools */
		ntohf( (unsigned char *)flts, buf, 12 );

		/* unused attribute byte count */
		fread( buf, 2, 1, fd_in );

		VMOVE( normal, flts );
		VSCALE( pt, &flts[3], conv_factor );
		tmp_face[0] = Add_vert( V3ARGS( pt ), tree_root, tol.dist_sq );
		VSCALE( pt, &flts[6], conv_factor );
		tmp_face[1] = Add_vert( V3ARGS( pt ), tree_root, tol.dist_sq );
		VSCALE( pt, &flts[9], conv_factor );
		tmp_face[2] = Add_vert( V3ARGS( pt ), tree_root, tol.dist_sq );

		/* check for degenerate faces */
		if( tmp_face[0] == tmp_face[1] ) {
			degenerate_count++;
			continue;
		}

		if( tmp_face[0] == tmp_face[2] ) {
			degenerate_count++;
			continue;
		}

		if( tmp_face[1] == tmp_face[2] ) {
			degenerate_count++;
			continue;
		}

		if( debug ) {
			int n;

			bu_log( "Making Face:\n" );
			for( n=0 ; n<3; n++ )
				bu_log( "\tvertex #%d: ( %g %g %g )\n", tmp_face[n], V3ARGS( &tree_root->the_array[3*tmp_face[n]] ) );
			VPRINT(" normal", normal);
		}

		Add_face( tmp_face );
		face_count++;
	}

	/* Check if this part has any solid parts */
	if( face_count == 0 )
	{
		bu_log( "\tpart has no solid parts, ignoring\n" );
		if( degenerate_count )
			bu_log( "\t%d faces were degenerate\n", degenerate_count );
		if( small_count )
			bu_log( "\t%d faces were too small\n", small_count );
		return;
	}
	else
	{
		if( degenerate_count )
			bu_log( "\t%d faces were degenerate\n", degenerate_count );
		if( small_count )
			bu_log( "\t%d faces were too small\n", small_count );
	}

	mk_bot( fd_out, bu_vls_addr( &solid_name ), RT_BOT_SOLID, RT_BOT_UNORIENTED, 0,
		tree_root->curr_vert, bot_fcurr, tree_root->the_array, bot_faces, NULL, NULL );
	clean_vert_tree( tree_root );

	BU_LIST_INIT( &head.l );
	if( face_count )
	{
		(void)mk_addmember( bu_vls_addr( &solid_name ) , &head.l , NULL, WMOP_UNION );
	}
	bu_log( "\tMaking region (%s)\n", bu_vls_addr( &region_name ) );

	if( const_id >= 0 ) {
		mk_lrcomb( fd_out, bu_vls_addr( &region_name ), &head, 1, (char *)NULL,
			   (char *)NULL, NULL, const_id, 0, mat_code, 100, 0 );
		if( face_count ) {
				(void)mk_addmember( bu_vls_addr( &region_name ), &all_head.l,
						    NULL, WMOP_UNION );
		}
	} else {
		mk_lrcomb( fd_out, bu_vls_addr( &region_name ), &head, 1, (char *)NULL,
			   (char *)NULL, NULL, id_no, 0, mat_code, 100, 0 );
		if( face_count )
			(void)mk_addmember( bu_vls_addr( &region_name ), &all_head.l,
					    NULL, WMOP_UNION );
		id_no++;
	}

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at end of Convert_part_ascii:\n" );
		if( bu_mem_barriercheck() )
			bu_exit(EXIT_FAILURE,  "Barrier check failed!!!\n" );
	}

	return;
}


static void
Convert_input()
{
	char line[ MAX_LINE_LEN ];

	if( binary ) {
		if( fread( line, 80, 1, fd_in ) < 1 ) {
			if( feof( fd_in ) ) {
				bu_exit(EXIT_FAILURE,  "Unexpected EOF in input file!!!\n" );
			} else {
				bu_log( "Error reading input file\n" );
				perror( "stl-g" );
				bu_exit(EXIT_FAILURE,  "Error reading input file\n" );
			}
		}
		line[80] = '\0';
		bu_log( "header data:\n%s\n\n", line );
		Convert_part_binary();
	} else {
		while( bu_fgets( line, MAX_LINE_LEN, fd_in ) != NULL ) {
		    int start = 0;
		    while( line[start] != '\0' && isspace( line[start] ) ) {
			start++;
		    }
			if( !strncmp( &line[start] , "solid" , 5 ) || !strncmp( &line[start] , "SOLID" , 5 ) )
				Convert_part_ascii( line );
			else
				bu_log( "Unrecognized line:\n%s\n" , line );
		}
	}
}


/*
 *			M A I N
 */
int
main(argc, argv)
int	argc;
char	*argv[];
{
	register int c;

	tol.magic = BN_TOL_MAGIC;

	/* this value selected as a resaonable compromise between eliminating
	 * needed faces and keeping degenerate faces
	 */
	tol.dist = 0.005;	/* default, same as MGED, RT, ... */
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	bu_vls_init( &ret_name );

	forced_name = NULL;

	conv_factor = 1.0;	/* default */

	if( argc < 2 )
		bu_exit(1, usage, argv[0]);

	/* Get command line arguments. */
	while ((c = bu_getopt(argc, argv, "bt:i:I:m:dx:N:c:")) != EOF) {
		double tmp;

		switch (c) {
		case 'b':	/* binary format */
			binary = 1;
			break;
		case 't':	/* tolerance */
			tmp = atof( bu_optarg );
			if( tmp <= 0.0 ) {
				bu_log( "Tolerance must be greater then zero, using default (%g)\n",
					tol.dist );
				break;
			}
			tol.dist = tmp;
			tol.dist_sq = tmp * tmp;
			break;
		case 'c':	/* convert from units */
			conv_factor = bu_units_conversion( bu_optarg );
			if( conv_factor == 0.0 )
			{
				bu_log( "Illegal units: (%s)\n", bu_optarg );
				bu_exit(EXIT_FAILURE,  "Illegal units!!\n" );
			}
			else
				bu_log( "Converting units from %s to mm (conversion factor is %g)\n", bu_optarg, conv_factor );
			break;
		case 'N':	/* force a name on this object */
			forced_name = bu_optarg;
			break;
		case 'i':
			id_no = atoi( bu_optarg );
			break;
		case  'I':
			const_id = atoi( bu_optarg );
			if( const_id < 0 )
			{
				bu_log( "Illegal value for '-I' option, must be zero or greater!!!\n" );
				bu_log( usage, argv[0] );
				bu_exit(EXIT_FAILURE,  "Illegal value for option '-I'\n" );
			}
			break;
		case 'm':
			mat_code = atoi( bu_optarg );
			break;
		case 'd':
			debug = 1;
			break;
		case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
			bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
			bu_log("\n");
			break;
		default:
			bu_exit(1, usage, argv[0]);
			break;
		}
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	input_file = argv[bu_optind];
	if( (fd_in=fopen( input_file, "rb")) == NULL )
	{
		bu_log( "Cannot open input file (%s)\n" , input_file );
		perror( argv[0] );
		bu_exit( 1, NULL );
	}
	bu_optind++;
	brlcad_file = argv[bu_optind];
	if( (fd_out=wdb_fopen( brlcad_file)) == NULL )
	{
		bu_log( "Cannot open BRL-CAD file (%s)\n" , brlcad_file );
		perror( argv[0] );
		bu_exit( 1, NULL );
	}

	mk_id_units( fd_out , "Conversion from Stereolithography format" , "mm" );

	BU_LIST_INIT( &all_head.l );

	/* create a tree sructure to hold the input vertices */
	tree_root = create_vert_tree();

	Convert_input();

	/* make a top level group */
	mk_lcomb( fd_out, "all", &all_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );

	fclose( fd_in );

	wdb_close( fd_out );

	return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.26
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.25 2007/11/21 19:05:59 erikgreenwald Exp $";
d699 1
a699 1
		bu_exit( 1, "" );
d707 1
a707 1
		bu_exit( 1, "" );
@


14.25
log
@exit->bu_exit where applicable
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.24 2007/11/21 15:21:33 erikgreenwald Exp $";
d630 1
a630 4
	{
		bu_log( usage, argv[0]);
		bu_exit(1, "");
	}
d687 1
a687 2
			bu_log( usage, argv[0]);
			bu_exit(1, "");
@


14.24
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.23 2007/09/15 16:23:04 brlcad Exp $";
d632 1
a632 1
		exit(1);
d691 1
a691 1
			exit(1);
d703 1
a703 1
		exit( 1 );
d711 1
a711 1
		exit( 1 );
@


14.23
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.22 2007/07/26 01:13:51 brlcad Exp $";
d163 1
a163 1
			bu_bomb( "Barrier check failed!!!\n" );
d287 1
a287 1
					bu_bomb( "Unexpected EOF while reading a loop in a part!!!\n" );
d405 1
a405 1
			bu_bomb( "Barrier check failed!!!\n" );
d563 1
a563 1
			bu_bomb( "Barrier check failed!!!\n" );
d578 1
a578 1
				bu_bomb( "Unexpected EOF in input file!!!\n" );
d582 1
a582 1
				bu_bomb( "Error reading input file\n" );
d658 1
a658 1
				bu_bomb( "Illegal units!!\n" );
d675 1
a675 1
				bu_bomb( "Illegal value for option '-I'\n" );
@


14.22
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.21 2007/05/18 04:13:44 brlcad Exp $";
d40 1
a40 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.21
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@a28 4
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.20 2007/04/14 01:16:02 brlcad Exp $";
@


14.20
log
@remove the WIN32 conditionals relating to the binary mode specifier on file opens.  just keep the rb/wb mode since ISO/IEC 9899:1990 does specify it.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.19 2007/04/11 18:52:01 bob1961 Exp $";
d171 1
a171 1
			rt_bomb( "Barrier check failed!!!\n" );
d413 1
a413 1
			rt_bomb( "Barrier check failed!!!\n" );
d571 1
a571 1
			rt_bomb( "Barrier check failed!!!\n" );
@


14.19
log
@Mods to open input file in untranslated/binary mode on windows.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.18 2007/02/20 08:19:47 brlcad Exp $";
a706 1
#ifdef _WIN32
a707 3
#else
	if( (fd_in=fopen( input_file, "r")) == NULL )
#endif
@


14.18
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.17 2007/01/27 01:41:32 brlcad Exp $";
d707 3
d711 1
@


14.17
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.16 2007/01/23 01:13:25 brlcad Exp $";
d247 1
a247 1
	while( fgets( line1, MAX_LINE_LEN, fd_in ) != NULL )
d294 1
a294 1
				if( fgets( line1, MAX_LINE_LEN, fd_in ) == NULL )
d597 1
a597 1
		while( fgets( line, MAX_LINE_LEN, fd_in ) != NULL ) {
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.15 2007/01/20 14:36:44 brlcad Exp $";
d76 1
a76 1
        The -b option specifies that the input file is in the binary STL format (default is ASCII). \n\
a460 1

d470 1
a470 1
 	while( fread( buf, 48, 1, fd_in ) ) {
d621 1
a621 1
        tol.magic = BN_TOL_MAGIC;
d626 4
a629 4
        tol.dist = 0.005;	/* default, same as MGED, RT, ... */
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;
@


14.15
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.14 2006/08/18 04:28:29 johnranderson Exp $";
@


14.14
log
@now ignores leading white space on the first line of the STL file
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2006 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.13 2006/08/08 05:15:23 brlcad Exp $";
@


14.13
log
@get rid of the old 'cad' path references/assumptions
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.12 2006/01/28 00:36:27 brlcad Exp $";
d600 5
a604 1
			if( !strncmp( line , "solid" , 5 ) || !strncmp( line , "SOLID" , 5 ) )
@


14.12
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.11 2006/01/18 06:46:13 brlcad Exp $";
d85 1
a85 1
	The -x option specifies an RT debug flags (see cad/librt/debug.h).\n";
@


14.11
log
@update copyright to 2006
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.10 2005/12/23 21:26:29 bob1961 Exp $";
d42 1
d46 1
a46 1
#include <string.h>
d48 1
a48 1
#include <strings.h>
@


14.10
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 2002-2005 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.9 2005/10/23 04:44:30 brlcad Exp $";
@


14.9
log
@trailing ws
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.8 2005/07/26 04:40:53 brlcad Exp $";
a58 3
extern char *optarg;
extern int optind,opterr,optopt;

d641 1
a641 1
	while ((c = getopt(argc, argv, "bt:i:I:m:dx:N:c:")) != EOF) {
d649 1
a649 1
			tmp = atof( optarg );
d659 1
a659 1
			conv_factor = bu_units_conversion( optarg );
d662 1
a662 1
				bu_log( "Illegal units: (%s)\n", optarg );
d666 1
a666 1
				bu_log( "Converting units from %s to mm (conversion factor is %g)\n", optarg, conv_factor );
d669 1
a669 1
			forced_name = optarg;
d672 1
a672 1
			id_no = atoi( optarg );
d675 1
a675 1
			const_id = atoi( optarg );
d684 1
a684 1
			mat_code = atoi( optarg );
d690 1
a690 1
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
d703 1
a703 1
	input_file = argv[optind];
d710 2
a711 2
	optind++;
	brlcad_file = argv[optind];
@


14.8
log
@make sure to include the errno.h header before any usage of the errno global just in case so bad things don't happen (like on fedora core)
@
text
@d30 1
a30 1
 *  
d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.7 2005/01/30 20:30:20 brlcad Exp $";
d299 1
a299 1
				
d426 1
a426 1
void lswap(unsigned int *v) 
@


14.8.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d30 1
a30 1
 *
d37 1
a37 1
static const char RCSid[] = "$Header$";
d299 1
a299 1

d426 1
a426 1
void lswap(unsigned int *v)
@


14.8.2.1
log
@Mods to use bu_getopt
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.8 2005/07/26 04:40:53 brlcad Exp $";
d59 3
d644 1
a644 1
	while ((c = bu_getopt(argc, argv, "bt:i:I:m:dx:N:c:")) != EOF) {
d652 1
a652 1
			tmp = atof( bu_optarg );
d662 1
a662 1
			conv_factor = bu_units_conversion( bu_optarg );
d665 1
a665 1
				bu_log( "Illegal units: (%s)\n", bu_optarg );
d669 1
a669 1
				bu_log( "Converting units from %s to mm (conversion factor is %g)\n", bu_optarg, conv_factor );
d672 1
a672 1
			forced_name = bu_optarg;
d675 1
a675 1
			id_no = atoi( bu_optarg );
d678 1
a678 1
			const_id = atoi( bu_optarg );
d687 1
a687 1
			mat_code = atoi( bu_optarg );
d693 1
a693 1
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
d706 1
a706 1
	input_file = argv[bu_optind];
d713 2
a714 2
	bu_optind++;
	brlcad_file = argv[bu_optind];
@


14.7
log
@update copyright to 2005
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.6 2004/12/21 07:32:29 morrison Exp $";
a41 2


d50 1
a60 1
extern int errno;
@


14.7.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/stl-g.c,v 14.8 2005/07/26 04:40:53 brlcad Exp $";
d42 2
a51 1
#include <errno.h>
d62 1
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2004 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/stl-g.c,v 14.5 2004/12/21 06:58:41 morrison Exp $";
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a33 2
 *  
 *
d37 1
a37 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/stl-g.c,v 14.4 2004/12/21 06:50:58 morrison Exp $";
@


14.4
log
@remove the old distribution notice section
@
text
@a35 3
 *  Copyright Notice -
 *	This software is Copyright (C) 2002-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d39 1
a39 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/stl-g.c,v 14.3 2004/12/18 06:50:51 morrison Exp $";
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a34 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
d42 1
a42 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/stl-g.c,v 14.2 2004/12/18 02:38:10 morrison Exp $";
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file stl-g.c
d46 1
a46 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/stl-g.c,v 14.1 2004/11/16 19:42:13 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
d45 1
a45 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/stl-g.c,v 1.4 2004/09/03 23:30:56 morrison Exp $";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/stl-g.c,v 1.3 2004/08/02 23:01:47 morrison Exp $";
d730 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/stl-g.c,v 1.2 2004/06/08 22:04:10 morrison Exp $";
d34 1
a34 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header$";
d28 1
a28 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/stl-g.c,v 11.7 2004/05/10 15:30:42 erikg Exp $";
a43 1
#include "externs.h"
@

