head	14.16;
access;
symbols
	rel-7-10-4:14.13
	STABLE:14.13.0.2
	stable-branch:14.4
	rel-7-10-2:14.13
	rel-7-10-0:14.13
	rel-7-8-4:14.8
	rel-7-8-2:14.8
	rel-7-8-0:14.8
	trimnurbs-branch:14.7.0.2
	help:14.7
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.16
date	2007.12.16.18.53.47;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.10.22.17.42.34;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.02.02.08.48.28;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.27.01.41.32;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.20.14.36.44;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.04.06.19.30.22;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.28.00.36.27;	author brlcad;	state Exp;
branches
	14.7.2.1;
next	14.6;

14.6
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.30.20;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.18.06.50.51;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.10;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.14.49.10;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.10;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.55;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;

14.7.2.1
date	2006.04.07.19.26.25;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.16
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                         P L Y - G . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file ply-g.c
 *
 */

#include "common.h"

/* system headers */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#else
#  ifdef HAVE_SYS_UNISTD_H
#    include <sys/unistd.h>
#  endif
#endif

/* interface headers */
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "wdb.h"


static FILE *ply_fp=NULL;
static struct rt_wdb *out_fp=NULL;
static char *ply_file;
static char *brlcad_file;
static fastf_t scale_factor=1000.0;	/* default units are meters */
static int ply_file_type=0;
static int verbose=0;
static int endianness;

static char *usage="Usage:\n\tply-g [-s scale_factor] [-d] [-v] input_file.ply output_file.g";

#define LINELEN		512

static char line[LINELEN];

#define PLY_ASCII		1
#define PLY_BIN_BIG_ENDIAN	2
#define PLY_BIN_LITTLE_ENDIAN	3

#define TYPE_CHAR	0
#define TYPE_UCHAR	1
#define TYPE_SHORT	2
#define TYPE_USHORT	3
#define TYPE_INT	4
#define TYPE_UINT	5
#define TYPE_FLOAT	6
#define TYPE_DOUBLE	7

static char *types[]={
	"char",
	"uchar",
	"short",
	"ushort",
	"int",
	"uint",
	"float",
	"double",
	NULL };

static char *types2[]={
	"int8",
	"uint8",
	"int16",
	"uint16",
	"int32",
	"uint32",
	"float32",
	"float64",
	NULL };


static int length[]={
	1,
	1,
	2,
	2,
	4,
	4,
	4,
	8,
	0 };

struct prop {
	int type;
	int index_type;		/* only used for lists */
	int list_type;		/* only used for lists */
	char *name;
	struct prop *next;
};
#define PROP_LIST_TYPE	-1

struct element {
	int type;
	int count;
	struct prop *props;
	struct element *next;
};


#define	ELEMENT_VERTEX	1
#define ELEMENT_FACE	2
#define	ELEMENT_OTHER	3

static struct element *root=NULL;

static int cur_vertex=-1;
static int cur_face=-1;

void
log_elements()
{
	struct element *elemp;
	struct prop *p;

	elemp = root;

	while( elemp ) {
		bu_log( "element:\n" );
		switch( elemp->type ) {
		case ELEMENT_VERTEX:
			bu_log( "\t%d vertices\n", elemp->count );
			break;
		case ELEMENT_FACE:
			bu_log( "\t%d faces\n", elemp->count );
			break;
		case ELEMENT_OTHER:
			bu_log( "\t%d others\n", elemp->count );
			break;
		}
		p = elemp->props;
		while( p ) {
			if( p->type == PROP_LIST_TYPE ) {
				bu_log( "\t\tproperty (%s) is a list\n", p->name );
			} else {
				bu_log( "\t\tproperty (%s) is a %s\n", p->name, types[p->type] );
			}
			p = p->next;
		}
		elemp = elemp->next;
	}
}


int
get_endianness()
{
	int i = 0x87654321;
	unsigned char* a = (unsigned char*) &i;

	if(*a != 0x21) {
		/* big Endian */
		return PLY_BIN_BIG_ENDIAN;
	} else {
		return PLY_BIN_LITTLE_ENDIAN;
	}
}

/* Byte swaps a 4-byte val */
void lswap4(unsigned int *in, unsigned int *out)
{
	unsigned int r;

	r = *in;
	*out = ((r & 0xff) << 24) |
	       ((r & 0xff00) << 8) |
	       ((r & 0xff0000) >> 8) |
	       ((r & 0xff000000) >> 24);
}

/* Byte swaps an 8-byte val */
void lswap8(unsigned long long *in, unsigned long long *out )
{
	long long r;

	r = *in;
	*out = ((r & 0xffLL) << 56) |
	       ((r & 0xff00LL) << 40) |
	       ((r & 0xff0000LL) << 24) |
	       ((r & 0xff000000LL) << 8) |
	       ((r & 0xff00000000LL) >> 8) |
	       ((r & 0xff0000000000LL) >> 24) |
	       ((r & 0xff000000000000LL) >> 40) |
	       ((r & 0xff00000000000000LL) >> 56);
}

void
skip( int type )
{
	char buf[16];
	double val_double;

	if( ply_file_type != PLY_ASCII ) {
		if( !fread( buf, 1, length[type], ply_fp ) ) {
			bu_exit(1, "Unexpected EOF while reading data\n" );
		}
	} else {
		if( fscanf( ply_fp, "%lf", &val_double ) != 1 ) {
			bu_exit(1, "ERROR: unable to parse data\n" );
		}
	}
}

double
get_double( int type )
{
	unsigned char buf1[16], buf2[16];
	char val_char;
	unsigned char val_uchar;
	short val_short;
	unsigned short val_ushort;
	int val_int;
	unsigned int val_uint;
	float val_float;
	double val_double;
	double val;

	if( ply_file_type == PLY_ASCII ) {
		switch( type ) {
		case TYPE_CHAR:
			if( fscanf( ply_fp, " %c", &val_char ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_char;
			break;
		case TYPE_UCHAR:
			if( fscanf( ply_fp, " %c", &val_uchar ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_uchar;
			break;
		case TYPE_SHORT:
			if( fscanf( ply_fp, "%hd", &val_short ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_short;
			break;
		case TYPE_USHORT:
			if( fscanf( ply_fp, "%hu", &val_ushort ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_ushort;
			break;
		case TYPE_INT:
			if( fscanf( ply_fp, "%d", &val_int ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_int;
			break;
		case TYPE_UINT:
			if( fscanf( ply_fp, "%u", &val_uint ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_uint;
			break;
		case TYPE_FLOAT:
			if( fscanf( ply_fp, "%f", &val_float ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_float;
			break;
		case TYPE_DOUBLE:
			if( fscanf( ply_fp, "%lf", &val_double ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_double;
			break;
		}
	} else {
		if( !fread( buf1, 1, length[type], ply_fp ) ) {
			bu_exit(1, "Unexpected EOF while reading data\n" );
		}
		if( ply_file_type != endianness ) {
			/* need to swap bytes */
			switch( length[type] ) {
			case 1:
				/* just copy to buf2 */
				buf2[0] = buf1[0];
				break;
			case 2:
				swab( buf1, buf2, 2 );
				break;
			case 4:
				lswap4( (unsigned int *)buf1, (unsigned int *)buf2 );
				break;
			case 8:
				lswap8( (unsigned long long *)buf1, (unsigned long long *)buf2 );
				break;
			default:
				bu_exit(1, "Property has illegal length (%d)!\n", length[type] );
				break;
			}
		} else {
			/* just copy to buf2 */
			memcpy(buf2, buf1, length[type]);
		}
		switch( type ) {
		case TYPE_CHAR:
			val = *((char *)buf2);
			break;
		case TYPE_UCHAR:
			val = *((unsigned char *)buf2);
			break;
		case TYPE_SHORT:
			val = *((short *)buf2);
			break;
		case TYPE_USHORT:
			val = *((unsigned short *)buf2);
			break;
		case TYPE_INT:
			val = *((int *)buf2 );
			break;
		case TYPE_UINT:
			val = *((unsigned int *)buf2);
			break;
		case TYPE_FLOAT:
			val = *((float *)buf2);
			break;
		case TYPE_DOUBLE:
			val = *((double *)buf2);
			break;
		}
	}

	return( val*scale_factor );
}

int
get_int( int type )
{
	unsigned char buf1[16], buf2[16];
	int val_int;
	unsigned int val_uint;
	double val_double;
	int val;


	if( ply_file_type == PLY_ASCII ) {
		switch( type ) {
		case TYPE_CHAR:
		case TYPE_UCHAR:
		case TYPE_SHORT:
		case TYPE_USHORT:
		case TYPE_INT:
			if( fscanf( ply_fp, "%d", &val_int ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_int;
			break;
		case TYPE_UINT:
			if( fscanf( ply_fp, "%u", &val_uint ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_uint;
			break;
		case TYPE_FLOAT:
		case TYPE_DOUBLE:
			if( fscanf( ply_fp, "%lf", &val_double ) != 1 ) {
				bu_exit(1, "ERROR parsing data\n" );
			}
			val = val_double;
			break;
		}
	} else {
		if( !fread( buf1, 1, length[type], ply_fp ) ) {
			bu_exit(1, "Unexpected EOF while reading data\n" );
		}
		if( ply_file_type != endianness ) {
			/* need to swap bytes */
			switch( length[type] ) {
			case 1:
				/* just copy to buf2 */
				buf2[0] = buf1[0];
				break;
			case 2:
				swab( buf1, buf2, 2 );
				break;
			case 4:
				lswap4( (unsigned int *)buf1, (unsigned int *)buf2 );
				break;
			case 8:
				lswap8( (unsigned long long *)buf1, (unsigned long long *)buf2 );
				break;
			default:
				bu_exit(1, "Property has illegal length (%d)!\n", length[type] );
				break;
			}
		} else {
			/* just copy to buf2 */
			memcpy(buf2, buf1, length[type]);
		}
		switch( type ) {
		case TYPE_CHAR:
			val = *((char *)buf2);
			break;
		case TYPE_UCHAR:
			val = *((unsigned char *)buf2);
			break;
		case TYPE_SHORT:
			val = *((short *)buf2);
			break;
		case TYPE_USHORT:
			val = *((unsigned short *)buf2);
			break;
		case TYPE_INT:
			val = *((int *)buf2 );
			break;
		case TYPE_UINT:
			val = *((unsigned int *)buf2);
			break;
		case TYPE_FLOAT:
			val = *((float *)buf2);
			break;
		case TYPE_DOUBLE:
			val = *((double *)buf2);
			break;
		}
	}

	return( val );
}

struct element *
new_element(char *str)
{
	struct element *ptr;
	char *c;

	if( verbose ) {
		bu_log( "Creating a new element structure\n" );
	}

	ptr = (struct element *)bu_calloc( 1, sizeof( struct element ), "element" );

	if( root ) {
		struct element *ptr2;

		ptr2 = root;
		while( ptr2->next != NULL ) {
			ptr2 = ptr2->next;
		}

		ptr2->next = ptr;
	} else {
		if( verbose ) {
			bu_log( "This element will be the root\n" );
		}
		root = ptr;
	}

	c = strtok( str, " \t" );
	if( !c ) {
		bu_log( "Error parsing line %s\n", line );
		bu_free( (char *)ptr, "element" );
		return( (struct element *)NULL );
	}

	if( !strncmp( c, "vertex", 6 ) ) {
		/* this is a vertex element */
		ptr->type = ELEMENT_VERTEX;
	} else if( !strncmp( c, "face", 4 ) ) {
		/* this ia a face element */
		ptr->type = ELEMENT_FACE;
	} else {
		ptr->type = ELEMENT_OTHER;
	}

	c = strtok( (char *)NULL, " \t" );
	if( !c ) {
		bu_log( "Error parsing line %s\n", line );
		bu_free( (char *)ptr, "element" );
		return( (struct element *)NULL );
	}

	ptr->count = atoi( c );

	return( ptr );
}

int
get_property( struct element *ptr )
{
	char *c;
	char *tmp_buf;
	struct prop *p;
	int i;

	if( !ptr->props ) {
		ptr->props = (struct prop *)bu_calloc( 1, sizeof( struct prop ), "property" );
		p = ptr->props;
	} else {
		p = ptr->props;
		while( p->next ) {
			p = p->next;
		}
		p->next = (struct prop *)bu_calloc( 1, sizeof( struct prop ), "property" );
		p = p->next;
	}

	tmp_buf = bu_strdup( line );

	c = strtok( tmp_buf, " \t" );
	if( c ) {
		if( strcmp( c, "property" ) ) {
			bu_exit(1, "get_property called for non-property, line = %s\n", line );
		}
	} else {
		bu_exit(1, "Unexpected EOL while parsing property, line = %s\n", line );
	}

	c = strtok( (char *)NULL, " \t" );
	if( !c ) {
		bu_exit(1, "Unexpected EOL while parsing property, line = %s\n", line );
	}

	if( !strcmp( c, "list" ) ) {
		if( verbose ) {
			bu_log( "\tfound a list\n" );
		}

		p->type = PROP_LIST_TYPE;

		c = strtok( (char *)NULL, " \t" );
		if( !c ) {
			bu_exit(1, "Unexpected EOL while parsing property, line = %s\n", line );
		}
		i = 0;
		while( types[i] ) {
			if( !strcmp( c, types[i] ) || !strcmp( c, types2[i] ) ) {
				p->index_type = i;
				break;
			}
			i++;
		}

		if( !types[i] ) {
			bu_exit(1, "Cannot find property type for line %s\n", line );
		}


		c = strtok( (char *)NULL, " \t" );
		if( !c ) {
			bu_exit(1, "Unexpected EOL while parsing property, line = %s\n", line );
		}
		i = 0;
		while( types[i] ) {
			if( !strcmp( c, types[i] ) || !strcmp( c, types2[i] ) ) {
				p->list_type = i;
				break;
			}
			i++;
		}

		if( !types[i] ) {
			bu_log( "Cannot find property type for line %s\n", line );
			bu_exit(1, "type = %s\n", c );
		}


	} else {
		i = 0;
		while( types[i] ) {
			if( !strcmp( c, types[i] ) || !strcmp( c, types2[i] ) ) {
				p->type = i;
				break;
			}
			i++;
		}

		if( !types[i] ) {
			bu_log( "Cannot find property type for line %s\n", line );
			bu_exit(1, "type = %s\n", c );
		}
	}

	c = strtok( (char *)NULL, " \t" );
	if( !c ) {
		bu_exit(1, "Unexpected EOL while parsing property, line = %s\n", line );
	}

	p->name = bu_strdup( c );

	bu_free( tmp_buf, "copy of line" );
	return( 0 );
}

int
read_ply_header()
{

	if( verbose ) {
		bu_log( "Reading header...\n" );
	}
	if( bu_fgets( line, LINELEN, ply_fp ) == NULL ) {
		bu_log( "Unexpected EOF in input file!\n" );
		return( 1 );
	}
	if( strncmp( line, "ply", 3 ) ) {
		bu_log( "Input file does not appear to be a PLY file!\n" );
		return( 1 );
	}
	while( bu_fgets( line, LINELEN, ply_fp ) ) {
		struct element *elem_ptr;
		int len;

		len = strlen( line );
		len--;
		while( len && isspace( line[len] ) ) {
			line[len] = '\0';
			len--;
		}

		if( verbose ) {
			bu_log( "Processing line:%s\n", line );
		}

		if( !strncmp( line, "end_header", 10 ) ) {
			if( verbose ) {
				bu_log( "Found end of header\n" );
			}
			break;
		}

		if( !strncmp( line, "comment", 7 ) ) {
			/* comment */
			bu_log( "%s\n", line );
			continue;
		}

		if( !strncmp( line, "format", 6 ) ) {
			/* format specification */
			if( !strncmp( &line[7], "ascii", 5 ) ) {
				ply_file_type = PLY_ASCII;
			} else if( !strncmp( &line[7], "binary_big_endian", 17 ) ) {
				ply_file_type = PLY_BIN_BIG_ENDIAN;
			} else if( !strncmp( &line[7], "binary_little_endian", 20 ) ) {
				ply_file_type = PLY_BIN_LITTLE_ENDIAN;
			} else {
				bu_log( "Unrecognized PLY format:%s\n", line );
				return( 1 );
			}

			if( verbose ) {
				switch( ply_file_type ) {
				case PLY_ASCII:
					bu_log( "This is an ASCII PLY file\n" );
					break;
				case PLY_BIN_BIG_ENDIAN:
					bu_log( "This is a binary big endian PLY file\n" );
					break;
				case PLY_BIN_LITTLE_ENDIAN:
					bu_log( "This is a binary little endian PLY file\n" );
					break;
				}
			}
		} else if( !strncmp( line, "element", 7 ) ) {
			/* found an element description */
			if( verbose ) {
				bu_log( "Found an element\n" );
			}
			elem_ptr = new_element( &line[8] );
		} else if( !strncmp( line, "property", 8 ) ) {
			if( !elem_ptr ) {
				bu_log( "Encountered \"property\" before \"element\"\n" );
				return( 1 );
			}
			if( get_property( elem_ptr ) ) {
				return( 1 );
			}
		}
	}

	return 0;
}

int
read_ply_data( struct rt_bot_internal *bot )
{
	struct element *elem_ptr;
	struct prop *p;
	int i;

	elem_ptr = root;
	while( elem_ptr ) {
		for( i=0 ; i<elem_ptr->count ; i++ ) {
			switch( elem_ptr->type ) {
			case ELEMENT_VERTEX:
				cur_vertex++;
				p = elem_ptr->props;
				while( p ) {
					if( !strcmp( p->name, "x" ) ) {
						bot->vertices[cur_vertex*3] = get_double(p->type );
					} else if( !strcmp( p->name, "y" ) ) {
						bot->vertices[cur_vertex*3+1] = get_double(p->type );
					} else if( !strcmp( p->name, "z" ) ) {
						bot->vertices[cur_vertex*3+2] = get_double(p->type );
					} else {
						skip( p->type );
					}
					p = p->next;
				}
				break;
			case ELEMENT_FACE:
				cur_face++;
				p = elem_ptr->props;
				while( p ) {
					if( p->type == PROP_LIST_TYPE ) {
						int vcount;
						int index;
						int v[4];

						vcount = get_int( p->index_type );

						if( vcount < 3 || vcount > 4) {
							bu_log( "ignoring face with %d vertices\n", vcount );
							for( index=0 ; index < vcount ; index++ ) {
								skip( p->list_type );
							}
							continue;
						}

						for( index=0 ; index < vcount ; index++ ) {
							v[index] = get_int( p->list_type );
							bot->faces[cur_face*3+index] = v[index];
						}

						if( vcount == 4 ) {
							/* need to break this into two BOT faces */
							bot->num_faces++;
							bot->faces = (int *)bu_realloc( bot->faces,
											bot->num_faces * 3 * sizeof( int ),
											"bot_faces" );
							cur_face++;
							/* bot->faces[cur_face*3] was already set above when index == 4 */
							bot->faces[cur_face*3+1] = v[0];
							bot->faces[cur_face*3+2] = v[2];
						}

					}
					p = p->next;
				}
				break;
			}

		}
		elem_ptr = elem_ptr->next;
	}

	return( 0 );
}

int
main( int argc, char *argv[] )
{
	struct rt_bot_internal *bot;
	struct element *elem_ptr;
	int c;

	/* get command line arguments */
	while ((c = bu_getopt(argc, argv, "dvs:")) != EOF)
	{
		switch( c )
		{
			case 's':	/* scale factor */
				scale_factor = atof( bu_optarg );
				if( scale_factor < SQRT_SMALL_FASTF ) {
					bu_log( "scale factor too small\n" );
					bu_exit(1, "%s\n", usage );
				}
				break;
			case 'd':	/* debug */
				bu_debug = BU_DEBUG_COREDUMP;
				break;
			case 'v':	/* verbose */
				verbose = 1;
				break;
			default:
				bu_log( "%s\n", usage );
				break;
		}
	}

	if( argc - bu_optind < 2 ) {
		bu_exit(1, "%s\n",usage );
	}

	ply_file = argv[bu_optind++];
	brlcad_file = argv[bu_optind];

	if( (out_fp = wdb_fopen( brlcad_file )) == NULL ) {
		perror( brlcad_file );
		bu_exit(1, "ERROR: Cannot open output file (%s)\n", brlcad_file );
	}

	if( (ply_fp=fopen( ply_file, "r")) == NULL ) {
		perror( ply_file );
		bu_exit(1, "ERROR: Cannot open PLY file (%s)\n", ply_file );
	}

	endianness = get_endianness();
	if( verbose ) {
		if( endianness == PLY_BIN_BIG_ENDIAN ) {
			bu_log( "This machine is BigEndian\n" );
		} else {
			bu_log( "This machine is LittleEndian\n" );
		}
	}

	/* read header */
	if( read_ply_header() ) {
		bu_exit( 1, "ERROR: File does not seem to be a PLY file\n" );
	}

	if( verbose ) {
		log_elements();
	}

	/* malloc BOT storage */
	bot = (struct rt_bot_internal *)bu_calloc( 1, sizeof( struct rt_bot_internal ), "BOT" );
	bot->magic = RT_BOT_INTERNAL_MAGIC;
	bot->mode = RT_BOT_SURFACE;
	bot->orientation = RT_BOT_UNORIENTED;
	bot->num_vertices = 0;
	bot->num_faces = 0;

	elem_ptr = root;
	while( elem_ptr ) {
		switch( elem_ptr->type ) {
		case ELEMENT_VERTEX:
			bot->num_vertices += elem_ptr->count;
			break;
		case ELEMENT_FACE:
			bot->num_faces += elem_ptr->count;
			break;
		}
		elem_ptr = elem_ptr->next;
	}

	if( bot->num_faces < 1 || bot->num_vertices < 1 ) {
		bu_log( "This PLY file appears to contain no geometry!\n" );
		return( 0 );
	}

	bot->faces = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "bot faces" );
	bot->vertices = (fastf_t *)bu_calloc( bot->num_vertices * 3, sizeof( fastf_t ), "bot vertices" );

	read_ply_data( bot );

	wdb_export( out_fp, "ply_bot", (genptr_t)bot, ID_BOT, 1.0 );

	return( 0 );
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@whoosh, another 10% complete on the bu_bomb to bu_exit conversion review.  also includes a slew of custom exit() calls that can use bu_exit() as well as toning down a slew of overzealous exclamation point use.  (20% complete overall)
@
text
@d324 1
a324 1
			bcopy( buf1, buf2, length[type] );
d419 1
a419 1
			bcopy( buf1, buf2, length[type] );
@


14.14
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d224 1
a224 2
			bu_log( "Unexpected EOF while reading data\n" );
			exit( 1 );
d228 1
a228 2
			bu_log( "ERROR parsing data\n" );
			exit( 1 );
d251 1
a251 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d257 1
a257 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d263 1
a263 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d269 1
a269 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d275 1
a275 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d281 1
a281 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d287 1
a287 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d293 1
a293 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d300 1
a300 2
			bu_log( "Unexpected EOF while reading data\n" );
			exit( 1 );
d319 1
a319 2
				bu_log( "Property has illegal length (%d)!!!\n", length[type] );
				exit( 1 );
d375 1
a375 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d381 1
a381 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d388 1
a388 2
				bu_log( "ERROR parsing data\n" );
				exit( 1 );
d395 1
a395 2
			bu_log( "Unexpected EOF while reading data\n" );
			exit( 1 );
d414 1
a414 2
				bu_log( "Property has illegal length (%d)!!!\n", length[type] );
				exit( 1 );
d534 1
a534 2
			bu_log( "get_property called for non-property, line = %s\n", line );
			exit( 1 );
d537 1
a537 2
		bu_log( "Unexpected EOL while parsing property, line = %s\n", line );
		exit( 1 );
d542 1
a542 2
		bu_log( "Unexpected EOL while parsing property, line = %s\n", line );
		exit( 1 );
d554 1
a554 2
			bu_log( "Unexpected EOL while parsing property, line = %s\n", line );
			exit( 1 );
d566 1
a566 2
			bu_log( "Cannot find property type for line %s\n", line );
			exit( 1 );
d572 1
a572 2
			bu_log( "Unexpected EOL while parsing property, line = %s\n", line );
			exit( 1 );
d585 1
a585 2
			bu_log( "type = %s\n", c );
			exit( 1 );
d601 1
a601 2
			bu_log( "type = %s\n", c );
			exit( 1 );
d607 1
a607 2
		bu_log( "Unexpected EOL while parsing property, line = %s\n", line );
		exit( 1 );
d624 1
a624 1
		bu_log( "Unexpected EOF in input file!!!\n" );
d628 1
a628 1
		bu_log( "Input file does not appear to be a PLY file!!!\n" );
d797 1
a797 2
					bu_log( "%s\n", usage );
					exit( 1 );
d813 1
a813 2
		bu_log( "%s\n",usage );
		exit( 1 );
a819 1
		bu_log( "Cannot open output file (%s)\n", brlcad_file );
d821 1
a821 1
		bu_bomb( "Cannot open output file\n" );
a824 1
		bu_log( "Cannot open PLY file (%s)\n", ply_file );
d826 1
a826 1
		bu_bomb( "Cannot open PLY file\n" );
d840 1
a840 1
		exit( 1 );
d869 1
a869 1
		bu_log( "This PLY file appears to contain no geometry!!!\n" );
@


14.13
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d31 3
a33 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
a40 1
#include <ctype.h>
@


14.12
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d652 1
a652 1
	if( fgets( line, LINELEN, ply_fp ) == NULL ) {
d660 1
a660 1
	while( fgets( line, LINELEN, ply_fp ) ) {
@


14.11
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d818 1
a818 1
	while ((c = getopt(argc, argv, "dvs:")) != EOF)
d823 1
a823 1
				scale_factor = atof( optarg );
d842 1
a842 1
	if( argc - optind < 2 ) {
d847 2
a848 2
	ply_file = argv[optind++];
	brlcad_file = argv[optind];
@


14.10
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d822 1
a822 1
		        case 's':	/* scale factor */
d830 1
a830 1
		        case 'd':	/* debug */
@


14.9
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.8
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


14.7
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d37 1
a37 1
#if defined(HAVE_UNISTD_H)
d40 1
a40 1
#  if defined(HAVE_SYS_UNISTD_H)
@


14.7.2.1
log
@update from HEAD
@
text
@d37 1
a37 1
#ifdef HAVE_UNISTD_H
d40 1
a40 1
#  ifdef HAVE_SYS_UNISTD_H
@


14.6
log
@update copyright to 2006
@
text
@d29 1
@


14.5
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


14.4
log
@update copyright to 2005
@
text
@d192 1
a192 1
void lswap4(unsigned int *in, unsigned int *out) 
d204 1
a204 1
void lswap8(unsigned long long *in, unsigned long long *out ) 
d381 1
a381 1
	
d632 1
a632 1
	
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d192 1
a192 1
void lswap4(unsigned int *in, unsigned int *out)
d204 1
a204 1
void lswap8(unsigned long long *in, unsigned long long *out )
d381 1
a381 1

d632 1
a632 1

@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file ply-g.c
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 24
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d890 10
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d6 1
a6 1
#ifdef USE_STRING_H
@


1.3
log
@quell long long constant int warning and add unistd.h header for getopt
@
text
@d1 1
a1 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d5 1
a5 1

d13 10
a29 1
#include <ctype.h>
d186 8
a193 8
	*out = ((r & 0xff) << 56) |
	       ((r & 0xff00) << 40) |
	       ((r & 0xff0000) << 24) |
	       ((r & 0xff000000) << 8) |
	       ((r & 0xff00000000) >> 8) |
	       ((r & 0xff0000000000) >> 24) |
	       ((r & 0xff000000000000) >> 40) |
	       ((r & 0xff00000000000000) >> 56);
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a13 1
#include "externs.h"
@

