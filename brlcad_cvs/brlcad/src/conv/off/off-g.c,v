head	1.13;
access;
symbols
	rel-7-10-4:1.11
	STABLE:1.11.0.2
	rel-7-10-2:1.11
	rel-7-10-0:1.9
	rel-7-8-4:1.5
	rel-7-8-2:1.5
	rel-7-8-0:1.5
	trimnurbs-branch:1.5.0.2
	help:1.5
	temp_tag:1.1
	postmerge-20051223-bobWinPort:1.1
	premerge-20051223-bobWinPort:1.1
	rel-7-6-6:1.1
	rel-7-6-branch:1.1.0.2
	rel-7-6-4:1.1;
locks; strict;
comment	@ * @;


1.13
date	2007.10.22.17.42.35;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.14.22.15.55;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.26.01.13.52;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.18.04.13.47;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.27.01.41.33;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.23.01.13.26;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.20.14.36.47;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.27.05.52.23;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.29.01.39.53;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.29.00.51.53;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.18.06.46.14;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.27.03.36.04;	author brlcad;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.10.27.03.36.04;	author brlcad;	state dead;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.11.13.17.45.00;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.13
log
@whoosh, another 10% complete on the bu_bomb to bu_exit conversion review.  also includes a slew of custom exit() calls that can use bu_exit() as well as toning down a slew of overzealous exclamation point use.  (20% complete overall)
@
text
@/*                         O F F - G . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file off-g.c
 *
 *  Program to convert from Digital Equipment Corporation's OFF
 *  (Object File Format) to BRL-CAD NMG objects.
 *  Inspired by Mike Markowski's jack-g Jack to NMG converter.
 *
 *  Author -
 *	Glenn Edward Durfee
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.12 2007/10/14 22:15:55 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "wdb.h"

static struct bn_tol tol;

/*
 *         R E A D _ F A C E S
 *
 * Reads the geometry from the the geometry file and creates the appropriate
 *  vertices and faces.
 */

int read_faces(struct model *m, FILE *fgeom)
{
	int 		   nverts, nfaces, nedges;
	register int 	   i, j, fail=0;
	fastf_t 	  *pts;
	struct vertex 	 **verts;
	struct faceuse 	 **outfaceuses;
	struct nmgregion  *r;
	struct shell 	  *s;

		/* Get numbers of vertices and faces, and grab the appropriate amount of memory */
	if (fscanf(fgeom, "%d %d %d", &nverts, &nfaces, &nedges) != 3)
		bu_exit(1, "Cannot read number of vertices, faces, edges.\n");

	pts = (fastf_t *) bu_malloc(sizeof(fastf_t) * 3 * nverts, "points list");
	verts = (struct vertex **) bu_malloc(sizeof(struct vertex *) * nverts, "vertices");
	outfaceuses = (struct faceuse **) bu_malloc(sizeof(struct faceuse *) * nfaces, "faceuses");

		/* Read in vertex geometry, store in geometry list */
	for (i = 0; i < nverts; i++) {
		if (fscanf(fgeom, "%lf %lf %lf", &pts[3*i], &pts[3*i+1], &pts[3*i+2]) != 3)
			bu_exit(1, "Not enough data points in geometry file.\n");

		verts[i] = (struct vertex *) 0;
		fscanf(fgeom, "%*[^\n]");
	}

	r = nmg_mrsv(m);		/* Make region, empty shell, vertex. */
	s = BU_LIST_FIRST(shell, &r->s_hd);


	for (i = 0; i < nfaces; i++) {		/* Read in each of the faces */
		struct vertex **vlist;
		int *pinds;

		if (fscanf(fgeom, "%d", &nedges) != 1) {
			bu_exit(1, "Not enough faces in geometry file.\n");
		}
					/* Grab memory for list for this face. */
		vlist = (struct vertex **) bu_malloc(sizeof(struct vertex *) * nedges, "vertex list");
		pinds = (int *) bu_malloc(sizeof(int) * nedges, "point indicies");

		for (j = 0; j < nedges; j++) {			/* Read list of point indicies. */
			if (fscanf(fgeom, "%d", &pinds[j]) != 1) {
				bu_exit(1, "Not enough points on face.\n");
			}
			vlist[j] = verts[pinds[j]-1];
		}

		outfaceuses[i] = nmg_cface(s, vlist, nedges);	/* Create face. */
		NMG_CK_FACEUSE(outfaceuses[i]);

		for (j = 0; j < nedges; j++)		/* Save (possibly) newly created vertex structs. */
			verts[pinds[j]-1] = vlist[j];

		fscanf(fgeom, "%*[^\n]");

		bu_free((char *)vlist, "vertext list");
		bu_free((char *)pinds, "point indicies");
	}

	for (i = 0; i < nverts; i++)
		if (verts[i] != 0)
			nmg_vertex_gv(verts[i], &pts[3*i]);
		else
			fprintf(stderr, "Warning: vertex %d unused.\n", i+1);

	for (i = 0; i < nfaces; i++) {
		plane_t pl;

		fprintf(stderr, "planeeqning face %d.\n", i);
		if( nmg_loop_plane_area( BU_LIST_FIRST( loopuse , &outfaceuses[i]->lu_hd ) , pl ) < 0.0 )
			fail = 1;
		else
			nmg_face_g( outfaceuses[i] , pl );

	}

	if (fail) return (-1);

	nmg_gluefaces(outfaceuses, nfaces, &tol);
	nmg_region_a(r, &tol);

	bu_free((char *)pts, "points list");
	return (0);
}


int off2nmg(FILE *fpin, struct rt_wdb *fpout)
{
	char title[64], geom_fname[64];
	char rname[67], sname[67];
	char buf[200], buf2[200];

	FILE *fgeom;
	struct model *m;

	title[0] = geom_fname[0] = '\0';

	bu_fgets(buf, sizeof(buf), fpin);
	while (!feof(fpin)) {				/* Retrieve the important data */
		if (sscanf(buf, "name %[^\n]s", buf2) > 0)
			strncpy(title, buf2, sizeof(title));
/*		if (sscanf(buf, "author %[^\n]s", buf2) > 0)
			strncpy(author, buf2, sizeof(author));
*/		if (sscanf(buf, "geometry %200[^\n]s", buf2) > 0) {
			char dtype[40], format[40];
			if (sscanf(buf2, "%40s %40s %64s", dtype, format, geom_fname) != 3)
				bu_exit(1, "Incomplete geometry field in input file.");
			if (strcmp(dtype, "indexed_poly") != 0)
				bu_exit(1, "Unknown geometry data type. Must be \"indexed_poly\".");
		}
		bu_fgets(buf, sizeof(buf), fpin);
	}

	if (strlen(title) < (unsigned)1)
		fprintf(stderr, "Warning: no title\n");

	if (strlen(geom_fname) < (unsigned)1)
		bu_exit(1, "ERROR: no geometry filename given");

	if ((fgeom = fopen(geom_fname, "r")) == NULL) {
		bu_exit(1, "off2nmg: cannot open %s (geometry description) for reading\n",
			geom_fname);
	}

	m = nmg_mm();
	read_faces(m, fgeom);
	fclose(fgeom);

	snprintf(sname, 67, "s.%s", title);
	snprintf(rname, 67, "r.%s", title);

	mk_id(fpout, title);
	mk_nmg(fpout, sname, m);
	mk_comb1(fpout, rname, sname, 1);

	nmg_km(m);
	return (0);
}


int main(int argc, char **argv)
{
	FILE *fpin;
	struct rt_wdb *fpout;

	tol.magic = BN_TOL_MAGIC;	/* Copied from proc-db/nmgmodel.c */
	tol.dist = 0.01;
	tol.dist_sq = 0.01 * 0.01;
	tol.perp = 0.001;
	tol.para = 0.999;

	/* Get filenames and open the files. */
	if (argc != 3)  {
		bu_exit(2, "Usage: off-g file.off file.g\n");
	}
	if ((fpin = fopen(argv[1], "rt")) == NULL) {
		bu_exit(1, "%s: cannot open %s for reading\n",
			argv[0], argv[1]);
	}
	if ((fpout = wdb_fopen(argv[2])) == NULL) {
		bu_exit(1, "%s: cannot create %s\n",
			argv[0], argv[2]);
	}


	off2nmg(fpin, fpout);

	fclose(fpin);
	wdb_close(fpout);

	return (0);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.12
log
@more level 4 flawfinder issues.  mostly string length clampages.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.11 2007/07/26 01:13:52 brlcad Exp $ (BRL)";
d70 1
a70 1
		bu_bomb("Cannot read number of vertices, faces, edges.\n");
d79 1
a79 1
			bu_bomb("Not enough data points in geometry file.\n");
d94 1
a94 2
			fprintf(stderr, "Not enough faces in geometry file.\n");
			exit(1);
d102 1
a102 2
				fprintf(stderr, "Not enough points on face.\n");
				exit(1);
d166 1
a166 1
				bu_bomb("Incomplete geometry field in input file.");
d168 1
a168 1
				bu_bomb("Unknown geometry data type. Must be \"indexed_poly\".");
d177 1
a177 1
		bu_bomb("Error: no geometry filename.");
d180 1
a180 1
		fprintf(stderr, "off2nmg: cannot open %s (geometry description) for reading\n",
a181 1
		exit(1);
d213 1
a213 2
		fprintf(stderr, "Usage: off-g file.off file.g\n");
		return 2;
d216 1
a216 1
		fprintf(stderr, "%s: cannot open %s for reading\n",
a217 1
		return (1);
d220 1
a220 1
		fprintf(stderr, "%s: cannot create %s\n",
a221 1
		return (1);
@


1.11
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.10 2007/05/18 04:13:47 brlcad Exp $ (BRL)";
d165 1
a165 1
*/		if (sscanf(buf, "geometry %[^\n]s", buf2) > 0) {
d167 1
a167 1
			if (sscanf(buf2, "%s %s %s", dtype, format, geom_fname) != 3)
d191 2
a192 2
	strcpy(sname, "s.");	strcat(sname, title);
	strcpy(rname, "r.");	strcat(rname, title);
@


1.10
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@a27 4
 *
 *  Source -
 *	The U.S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.9 2007/02/20 08:19:47 brlcad Exp $ (BRL)";
@


1.9
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.8 2007/01/27 01:41:33 brlcad Exp $ (BRL)";
d74 1
a74 1
		rt_bomb("Cannot read number of vertices, faces, edges.\n");
d83 1
a83 1
			rt_bomb("Not enough data points in geometry file.\n");
d172 1
a172 1
				rt_bomb("Incomplete geometry field in input file.");
d174 1
a174 1
				rt_bomb("Unknown geometry data type. Must be \"indexed_poly\".");
d183 1
a183 1
		rt_bomb("Error: no geometry filename.");
@


1.8
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.7 2007/01/23 01:13:26 brlcad Exp $ (BRL)";
d163 1
a163 1
	fgets(buf, sizeof(buf), fpin);
d176 1
a176 1
		fgets(buf, sizeof(buf), fpin);
@


1.7
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.6 2007/01/20 14:36:47 brlcad Exp $ (BRL)";
a151 2


@


1.6
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.5 2006/02/27 05:52:23 brlcad Exp $ (BRL)";
@


1.5
log
@quell warnings, missing stdlib.h, calls to exit with a negative, ws.
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.4 2006/01/29 01:39:53 brlcad Exp $ (BRL)";
@


1.4
log
@update converters to the API changes, avoiding the deprecated calls
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.3 2006/01/29 00:51:53 brlcad Exp $ (BRL)";
d39 3
d44 1
@


1.3
log
@more libbu memory management and header cleanup
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.2 2006/01/18 06:46:14 brlcad Exp $ (BRL)";
d87 1
a87 1
	s = RT_LIST_FIRST(shell, &r->s_hd);
d118 2
a119 2
		rt_free((char *)vlist, "vertext list");
		rt_free((char *)pinds, "point indicies");
d132 1
a132 1
		if( nmg_loop_plane_area( RT_LIST_FIRST( loopuse , &outfaceuses[i]->lu_hd ) , pl ) < 0.0 )
d144 1
a144 1
	rt_free((char *)pts, "points list");
d211 1
a211 1
	tol.magic = RT_TOL_MAGIC;	/* Copied from proc-db/nmgmodel.c */
@


1.2
log
@update copyright to 2006
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/off/off-g.c,v 1.1 2005/10/27 03:36:04 brlcad Exp $ (BRL)";
d73 3
a75 3
	pts = (fastf_t *) rt_malloc(sizeof(fastf_t) * 3 * nverts, "points list");
	verts = (struct vertex **) rt_malloc(sizeof(struct vertex *) * nverts, "vertices");
	outfaceuses = (struct faceuse **) rt_malloc(sizeof(struct faceuse *) * nfaces, "faceuses");
d99 2
a100 2
		vlist = (struct vertex **) rt_malloc(sizeof(struct vertex *) * nedges, "vertex list");
		pinds = (int *) rt_malloc(sizeof(int) * nedges, "point indicies");
@


1.1
log
@moved all the geometry converter directories from src/. to src/conv/.
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/off/off-g.c,v 14.6 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
@


1.1.2.1
log
@file off-g.c was added on branch rel-7-6-branch on 2005-11-13 17:45:00 +0000
@
text
@d1 250
@


1.1.2.2
log
@more merging changes from HEAD aka rel-7-6-4 to the rel-7-6-branch, adding the items that were moved and resolving rcs keyword conflicts
@
text
@a0 250
/*                         O F F - G . C
 * BRL-CAD
 *
 * Copyright (C) 2004-2005 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
 * information.
 */
/** @@file off-g.c
 *
 *  Program to convert from Digital Equipment Corporation's OFF
 *  (Object File Format) to BRL-CAD NMG objects.
 *  Inspired by Mike Markowski's jack-g Jack to NMG converter.
 *
 *  Author -
 *	Glenn Edward Durfee
 *
 *  Source -
 *	The U.S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header$ (BRL)";
#endif

#include <stdio.h>
#include <string.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "wdb.h"

static struct bn_tol tol;

/*
 *         R E A D _ F A C E S
 *
 * Reads the geometry from the the geometry file and creates the appropriate
 *  vertices and faces.
 */

int read_faces(struct model *m, FILE *fgeom)
{
	int 		   nverts, nfaces, nedges;
	register int 	   i, j, fail=0;
	fastf_t 	  *pts;
	struct vertex 	 **verts;
	struct faceuse 	 **outfaceuses;
	struct nmgregion  *r;
	struct shell 	  *s;

		/* Get numbers of vertices and faces, and grab the appropriate amount of memory */
	if (fscanf(fgeom, "%d %d %d", &nverts, &nfaces, &nedges) != 3)
		rt_bomb("Cannot read number of vertices, faces, edges.\n");

	pts = (fastf_t *) rt_malloc(sizeof(fastf_t) * 3 * nverts, "points list");
	verts = (struct vertex **) rt_malloc(sizeof(struct vertex *) * nverts, "vertices");
	outfaceuses = (struct faceuse **) rt_malloc(sizeof(struct faceuse *) * nfaces, "faceuses");

		/* Read in vertex geometry, store in geometry list */
	for (i = 0; i < nverts; i++) {
		if (fscanf(fgeom, "%lf %lf %lf", &pts[3*i], &pts[3*i+1], &pts[3*i+2]) != 3)
			rt_bomb("Not enough data points in geometry file.\n");

		verts[i] = (struct vertex *) 0;
		fscanf(fgeom, "%*[^\n]");
	}

	r = nmg_mrsv(m);		/* Make region, empty shell, vertex. */
	s = RT_LIST_FIRST(shell, &r->s_hd);


	for (i = 0; i < nfaces; i++) {		/* Read in each of the faces */
		struct vertex **vlist;
		int *pinds;

		if (fscanf(fgeom, "%d", &nedges) != 1) {
			fprintf(stderr, "Not enough faces in geometry file.\n");
			exit(1);
		}
					/* Grab memory for list for this face. */
		vlist = (struct vertex **) rt_malloc(sizeof(struct vertex *) * nedges, "vertex list");
		pinds = (int *) rt_malloc(sizeof(int) * nedges, "point indicies");

		for (j = 0; j < nedges; j++) {			/* Read list of point indicies. */
			if (fscanf(fgeom, "%d", &pinds[j]) != 1) {
				fprintf(stderr, "Not enough points on face.\n");
				exit(1);
			}
			vlist[j] = verts[pinds[j]-1];
		}

		outfaceuses[i] = nmg_cface(s, vlist, nedges);	/* Create face. */
		NMG_CK_FACEUSE(outfaceuses[i]);

		for (j = 0; j < nedges; j++)		/* Save (possibly) newly created vertex structs. */
			verts[pinds[j]-1] = vlist[j];

		fscanf(fgeom, "%*[^\n]");

		rt_free((char *)vlist, "vertext list");
		rt_free((char *)pinds, "point indicies");
	}

	for (i = 0; i < nverts; i++)
		if (verts[i] != 0)
			nmg_vertex_gv(verts[i], &pts[3*i]);
		else
			fprintf(stderr, "Warning: vertex %d unused.\n", i+1);

	for (i = 0; i < nfaces; i++) {
		plane_t pl;

		fprintf(stderr, "planeeqning face %d.\n", i);
		if( nmg_loop_plane_area( RT_LIST_FIRST( loopuse , &outfaceuses[i]->lu_hd ) , pl ) < 0.0 )
			fail = 1;
		else
			nmg_face_g( outfaceuses[i] , pl );

	}

	if (fail) return (-1);

	nmg_gluefaces(outfaceuses, nfaces, &tol);
	nmg_region_a(r, &tol);

	rt_free((char *)pts, "points list");
	return (0);
}




int off2nmg(FILE *fpin, struct rt_wdb *fpout)
{
	char title[64], geom_fname[64];
	char rname[67], sname[67];
	char buf[200], buf2[200];

	FILE *fgeom;
	struct model *m;

	title[0] = geom_fname[0] = '\0';

	fgets(buf, sizeof(buf), fpin);
	while (!feof(fpin)) {				/* Retrieve the important data */
		if (sscanf(buf, "name %[^\n]s", buf2) > 0)
			strncpy(title, buf2, sizeof(title));
/*		if (sscanf(buf, "author %[^\n]s", buf2) > 0)
			strncpy(author, buf2, sizeof(author));
*/		if (sscanf(buf, "geometry %[^\n]s", buf2) > 0) {
			char dtype[40], format[40];
			if (sscanf(buf2, "%s %s %s", dtype, format, geom_fname) != 3)
				rt_bomb("Incomplete geometry field in input file.");
			if (strcmp(dtype, "indexed_poly") != 0)
				rt_bomb("Unknown geometry data type. Must be \"indexed_poly\".");
		}
		fgets(buf, sizeof(buf), fpin);
	}

	if (strlen(title) < (unsigned)1)
		fprintf(stderr, "Warning: no title\n");

	if (strlen(geom_fname) < (unsigned)1)
		rt_bomb("Error: no geometry filename.");

	if ((fgeom = fopen(geom_fname, "r")) == NULL) {
		fprintf(stderr, "off2nmg: cannot open %s (geometry description) for reading\n",
			geom_fname);
		exit(1);
	}

	m = nmg_mm();
	read_faces(m, fgeom);
	fclose(fgeom);

	strcpy(sname, "s.");	strcat(sname, title);
	strcpy(rname, "r.");	strcat(rname, title);

	mk_id(fpout, title);
	mk_nmg(fpout, sname, m);
	mk_comb1(fpout, rname, sname, 1);

	nmg_km(m);
	return (0);
}


int main(int argc, char **argv)
{
	FILE *fpin;
	struct rt_wdb *fpout;

	tol.magic = RT_TOL_MAGIC;	/* Copied from proc-db/nmgmodel.c */
	tol.dist = 0.01;
	tol.dist_sq = 0.01 * 0.01;
	tol.perp = 0.001;
	tol.para = 0.999;

	/* Get filenames and open the files. */
	if (argc != 3)  {
		fprintf(stderr, "Usage: off-g file.off file.g\n");
		return 2;
	}
	if ((fpin = fopen(argv[1], "rt")) == NULL) {
		fprintf(stderr, "%s: cannot open %s for reading\n",
			argv[0], argv[1]);
		return (1);
	}
	if ((fpout = wdb_fopen(argv[2])) == NULL) {
		fprintf(stderr, "%s: cannot create %s\n",
			argv[0], argv[2]);
		return (1);
	}


	off2nmg(fpin, fpout);

	fclose(fpin);
	wdb_close(fpout);

	return (0);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


