head	14.23;
access;
symbols
	rel-7-10-4:14.19
	STABLE:14.19.0.2
	stable-branch:14.7
	rel-7-10-2:14.19
	rel-7-10-0:14.18
	rel-7-8-4:14.13
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.7.2.1
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.6
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.23
date	2007.12.16.15.59.37;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.10.22.08.47.38;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.09.14.15.21.03;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.05.18.04.13.43;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.03.07.16.14.16;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.32;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.08.14.16.25.31;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.28.00.36.27;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.12.23.21.26.29;	author bob1961;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.09.09.09.44.08;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.01.30.20.30.19;	author brlcad;	state Exp;
branches
	14.7.2.1
	14.7.6.1;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.50;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.09;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.03.15.55;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.14.49.30;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.08;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.51;	author morrison;	state Exp;
branches;
next	;

14.7.2.1
date	2005.09.13.18.53.08;	author bob1961;	state Exp;
branches;
next	;

14.7.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.23
log
@convert all bzero calls to memset
@
text
@/*                       F A S T 4 - G . C
 * BRL-CAD
 *
 * Copyright (c) 1994-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file fast4-g.c
 *                      F A S T 4 - G
 *
 *  Program to convert the FASTGEN4 format to BRL-CAD.
 *
 *  Author -
 *      John R. Anderson
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.22 2007/10/22 08:47:38 brlcad Exp $";
#endif

#include "common.h"

/* system headers */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#if defined(HAVE_UNISTD_H)
#  include <unistd.h>
#else
#  if defined(HAVE_SYS_UNISTD_H)
#    include <sys/unistd.h>
#  endif
#endif

/* interface headers */
#include "machine.h"
#include "db.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "plot3.h"

/* local headers */
#include "../librt/debug.h"


/* convenient macro for building regions */
#define	MK_REGION( fp , headp , name , r_id, rgb ) {\
    if( mode == 1 ) {\
	if( !quiet )\
	    bu_log( "Making region: %s (PLATE)\n", name ); \
	    mk_fastgen_region(fp, name, &((headp)->l), 'P', (char *)NULL, (char *)NULL, rgb, r_id, 0, 0, 0, 0 ); \
    } else if( mode == 2 ) {\
	if( !quiet ) \
	    bu_log( "Making region: %s (VOLUME)\n", name ); \
	    mk_fastgen_region(fp, name, &((headp)->l), 'V', (char *)NULL, (char *)NULL, rgb, r_id, 0, 0, 0, 0 ); \
    } else {\
	bu_log( "Illegal mode (%d), while trying to make region (%s)\n", mode, name );\
	bu_log( "\tRegion not made!\n");\
    }\
}

#define	PUSH( ptr )	bu_ptbl_ins( &stack , (long *)ptr )
#define POP( structure , ptr ) { \
    if( BU_PTBL_END( &stack ) == 0 ) \
	ptr = (struct structure *)NULL; \
    else { \
	ptr = (struct structure *)BU_PTBL_GET( &stack , BU_PTBL_END( &stack )-1 ); \
	bu_ptbl_rm( &stack , (long *)ptr ); \
    } \
}
#define	PUSH2( ptr )	bu_ptbl_ins( &stack2 , (long *)ptr )
#define POP2( structure , ptr )	{ \
    if( BU_PTBL_END( &stack2 ) == 0 ) \
	ptr = (struct structure *)NULL; \
    else { \
	ptr = (struct structure *)BU_PTBL_GET( &stack2 , BU_PTBL_END( &stack2 )-1 ); \
	bu_ptbl_rm( &stack2 , (long *)ptr ); \
    } \
}

#define	NAME_TREE_MAGIC	0x55555555
#define CK_TREE_MAGIC( ptr ) {\
    if( !ptr )\
	bu_log( "ERROR: Null name_tree pointer, file=%s, line=%d\n", __FILE__, __LINE__ );\
    else if( ptr->magic != NAME_TREE_MAGIC )\
	bu_log( "ERROR: bad name_tree pointer (x%x), file=%s, line=%d\n", ptr, __FILE__, __LINE__ );\
}


#define	PLATE_MODE	1
#define	VOLUME_MODE	2

#define	POS_CENTER	1	/* face positions for facets */
#define	POS_FRONT	2

#define	END_OPEN	1	/* End closure codes for cones */
#define	END_CLOSED	2

#define	GRID_BLOCK	256	/* allocate space for grid points in blocks of 256 points */

#define	CLINE		'l'
#define	CHEX1		'p'
#define	CHEX2		'b'
#define	CTRI		't'
#define	CQUAD		'q'
#define	CCONE1		'c'
#define	CCONE2		'd'
#define	CCONE3		'e'
#define	CSPHERE		's'
#define	NMG		'n'
#define	BOT		't'
#define	COMPSPLT	'h'

#define HOLE 1
#define WALL 2
#define INT_LIST_BLOCK		256	/* Number of int_list array slots to allocate */
#define	LINELEN			128	/* Length of char array for input line */
#define	REGION_LIST_BLOCK	256	/* initial length of array of region ids to process */


struct fast4_color {
    struct bu_list l;
    short low;
    short high;
    unsigned char rgb[3];
};

struct cline {
    int pt1,pt2;
    int element_id;
    int made;
    fastf_t thick;
    fastf_t radius;
    struct cline *next;
} *cline_root;

struct name_tree {
    long magic;
    int region_id;
    int mode;		/* PLATE_MODE or VOLUME_MODE */
    int inner;		/* 0 => this is a base/group name for a FASTGEN element */
    int in_comp_group;	/* > 0 -> region already in a component group */
    char *name;
    struct name_tree *nleft,*nright,*rleft,*rright;
} *name_root;

struct compsplt {
    int ident_to_split;
    int new_ident;
    fastf_t z;
    struct compsplt *next;
} *compsplt_root;

struct hole_list {
    int group;
    int component;
    struct hole_list *next;
};

struct holes {
    int group;
    int component;
    int type;
    struct hole_list *holes;
    struct holes *next;
} *hole_root;


int hex_faces[12][3]={
    { 0 , 1 , 4 }, /* 1 */
    { 1 , 5 , 4 }, /* 2 */
    { 1 , 2 , 5 }, /* 3 */
    { 2 , 6 , 5 }, /* 4 */
    { 2 , 3 , 6 }, /* 5 */
    { 3 , 7 , 6 }, /* 6 */
    { 3 , 0 , 7 }, /* 7 */
    { 0 , 4 , 7 }, /* 8 */
    { 4 , 6 , 7 }, /* 9 */
    { 4 , 5 , 6 }, /* 10 */
    { 0 , 1 , 2 }, /* 11 */
    { 0 , 2 , 3 }  /* 12 */
};

struct fast4_color HeadColor;

static char	line[LINELEN+1];		/* Space for input line */
static FILE	*fdin;			/* Input FASTGEN4 file pointer */
static struct rt_wdb *fdout;		/* Output BRL-CAD file pointer */
static FILE	*fd_plot=NULL;		/* file for plot output */
static FILE	*fd_muves=NULL;		/* file for MUVES data, output CHGCOMP and CBACKING data */
static int	grid_size;		/* Number of points that will fit in current grid_pts array */
static int	max_grid_no=0;		/* Maximum grid number used */
static int	mode=0;			/* Plate mode (1) or volume mode (2), of current component */
static int	group_id=(-1);		/* Group identification number from SECTION card */
static int	comp_id=(-1);		/* Component identification number from SECTION card */
static int	region_id=0;		/* Region id number (group id no X 1000 + component id no) */
static char	field[9];		/* Space for storing one field from an input line */
static char	vehicle[17];		/* Title for BRL-CAD model from VEHICLE card */
static int	name_count;		/* Count of number of times this name_name has been used */
static int	pass;			/* Pass number (0 -> only make names, 1-> do geometry ) */
static int	bot=0;			/* Flag: >0 -> There are BOT's in current component */
static int	warnings=0;		/* Flag: >0 -> Print warning messages */
static int	debug=0;		/* Debug flag */
static int	rt_debug=0;		/* RT_G_DEBUG */
static int	quiet=0;		/* flag to not blather */
static int	comp_count=0;		/* Count of components in FASTGEN4 file */
static int	f4_do_skips=0;		/* flag indicating that not all components will be processed */
static int	*region_list;		/* array of region_ids to be processed */
static int	region_list_len=0;	/* actual length of the malloc'd region_list array */
static int	f4_do_plot=0;		/* flag indicating plot file should be created */
static struct wmember  group_head[11];	/* Lists of regions for groups */
static struct wmember  hole_head;	/* List of regions used as holes (not solid parts of model) */
static struct bu_ptbl stack;		/* Stack for traversing name_tree */
static struct bu_ptbl stack2;		/* Stack for traversing name_tree */
static fastf_t	min_radius;		/* minimum radius for TGC solids */

static int		*faces=NULL;	/* one triplet per face indexing three grid points */
static fastf_t		*thickness;	/* thickness of each face */
static char		*facemode;	/* mode for each face */
static int		face_size=0;	/* actual length of above arrays */
static int		face_count=0;	/* number of faces in above arrays */

static int	*int_list;		/* Array of integers */
static int	int_list_count=0;	/* Number of ints in above array */
static int	int_list_length=0;	/* Length of int_list array */

static point_t *grid_points = NULL;

static char	*usage="Usage:\n\tfast4-g [-dwq] [-c component_list] [-m muves_file] [-o plot_file] [-b BU_DEBUG_FLAG] [-x RT_DEBUG_FLAG] fastgen4_bulk_data_file output.g\n\
	d - print debugging info\n\
	q - quiet mode (don't say anyhing except error messages\n\
	w - print warnings about creating default names\n\
	c - process only the listed region ids, may be a list (3001,4082,5347) or a range (2314-3527)\n\
	m - create a MUVES input file containing CHGCOMP and CBACKING elements\n\
	o - create a 'plot_file' containing a libplot3 plot file of all CTRI and CQUAD elements processed\n\
	b - set LIBBU debug flag\n\
	x - set RT debug flag\n";


static int
get_line(void)
{
    int len;

    memset((void *)line, 0, LINELEN);

    if( bu_fgets( line , LINELEN , fdin ) == (char *)NULL )
	return( 0 );

    len = strlen( line );
    if( line[len-1] != '\n' ) {
	/* long line skip over remainder of line */
	int c=1;

	while( c != '\n' && c != EOF )
	    c = getc( fdin );
	if( c == EOF )
	    return( 0 );
    } else
	line[len-1] = '\0';

    return( 1 );
}


static unsigned char *
get_fast4_color(int r_id) {
    struct fast4_color *fcp;

    for (BU_LIST_FOR(fcp, fast4_color, &HeadColor.l)) {
	if (fcp->low <= r_id && r_id <= fcp->high)
	    return fcp->rgb;
    }

    return (unsigned char *)NULL;
}


static int
is_a_hole(int id)
{
    struct holes *hole_ptr;
    struct hole_list *ptr;

    hole_ptr = hole_root;

    while( hole_ptr )
	{
	    if( hole_ptr->type == HOLE )
		{
		    ptr = hole_ptr->holes;
		    while( ptr )
			{
			    if( (ptr->group * 1000 + ptr->component) == id )
				return( 1 );
			    ptr = ptr->next;
			}
		}
	    hole_ptr = hole_ptr->next;
	}
    return( 0 );
}

static void
add_to_holes(char *name, int reg_id)
{
    if( mk_addmember( name , &hole_head.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
	bu_log( "add_to_holes: mk_addmember failed for region %s\n" , name );
}

static void
plot_tri(int pt1, int pt2, int pt3)
{
    pdv_3move( fd_plot, grid_points[pt1] );
    pdv_3cont( fd_plot, grid_points[pt2] );
    pdv_3cont( fd_plot, grid_points[pt3] );
    pdv_3cont( fd_plot, grid_points[pt1] );
}

static void
Check_names(void)
{
    struct name_tree *ptr;

    if( !name_root )
	return;

    bu_ptbl_reset( &stack );

    CK_TREE_MAGIC( name_root )
	/* ident order */
	ptr = name_root;
    while( 1 )
	{
	    while( ptr )
		{
		    PUSH( ptr );
		    ptr = ptr->rleft;
		}
	    POP( name_tree , ptr );
	    if( !ptr )
		break;

	    /* visit node */
	    CK_TREE_MAGIC( ptr )
		ptr = ptr->rright;
	}

    /* alpabetical order */
    ptr = name_root;
    while( 1 )
	{
	    while( ptr )
		{
		    PUSH( ptr );
		    ptr = ptr->nleft;
		}
	    POP( name_tree , ptr );
	    if( !ptr )
		break;

	    /* visit node */
	    CK_TREE_MAGIC( ptr )
		ptr = ptr->nright;
	}
}


static struct name_tree *
Search_names(struct name_tree *root, char *name, int *found)
{
    struct name_tree *ptr;

    *found = 0;

    ptr = root;
    if( !ptr )
	return( (struct name_tree *)NULL );

    while( 1 )
	{
	    int diff;

	    diff = strcmp( name , ptr->name );
	    if( diff == 0 )
		{
		    *found = 1;
		    return( ptr );
		}
	    else if( diff > 0 )
		{
		    if( ptr->nright )
			ptr = ptr->nright;
		    else
			return( ptr );
		}
	    else if( diff < 0 )
		{
		    if( ptr->nleft )
			ptr = ptr->nleft;
		    else
			return( ptr );
		}
	}
}


static struct name_tree *
Search_ident(struct name_tree *root, int reg_id, int *found)
{
    struct name_tree *ptr;

    *found = 0;

    ptr = root;
    if( !ptr )
	return( (struct name_tree *)NULL );

    while( 1 )
	{
	    int diff;

	    diff = reg_id -  ptr->region_id;

	    if( diff == 0 )
		{
		    *found = 1;
		    return( ptr );
		}
	    else if( diff > 0 )
		{
		    if( ptr->rright )
			ptr = ptr->rright;
		    else
			return( ptr );
		}
	    else if( diff < 0 )
		{
		    if( ptr->rleft )
			ptr = ptr->rleft;
		    else
			return( ptr );
		}
	}
}


static void
List_names(void)
{
    struct name_tree *ptr;

    bu_ptbl_reset( &stack );

    bu_log( "\nNames in ident order:\n" );
    ptr = name_root;
    while( 1 )
	{
	    while( ptr )
		{
		    PUSH( ptr );
		    ptr = ptr->rleft;
		}
	    POP( name_tree , ptr );
	    if( !ptr )
		break;

	    if( ptr->in_comp_group )
		bu_log( "%s %d %d (in a comp group)\n" , ptr->name , ptr->region_id , ptr->inner );
	    else
		bu_log( "%s %d %d (not in a comp group)\n" , ptr->name , ptr->region_id , ptr->inner );
	    ptr = ptr->rright;
	}

    bu_log( "\tAlphabetical list of names:\n" );
    ptr = name_root;
    while( 1 )
	{
	    while( ptr )
		{
		    PUSH( ptr );
		    ptr = ptr->nleft;
		}
	    POP( name_tree , ptr );
	    if( !ptr )
		break;

	    bu_log( "%s %d %d\n" , ptr->name, ptr->region_id , ptr->inner );
	    ptr = ptr->nright;
	}
}


static void
Insert_region_name(char *name, int reg_id)
{
    struct name_tree *nptr_model,*rptr_model;
    struct name_tree *new_ptr;
    int foundn,foundr;
    int diff;

    if( debug )
	bu_log( "Insert_region_name( name=%s, reg_id=%d\n" , name, reg_id );

    rptr_model = Search_ident( name_root , reg_id , &foundr );
    nptr_model = Search_names( name_root , name , &foundn );

    if( foundn && foundr )
	return;

    if( foundn != foundr )
	{
	    bu_log( "Insert_region_name: name %s ident %d\n\tfound name is %d\n\tfound ident is %d\n",
		    name, reg_id, foundn, foundr );
	    List_names();
	    bu_exit(1, "\tCannot insert new node\n" );
	}

    /* Add to tree for entire model */
    new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_region_name: new_ptr" );
    new_ptr->rleft = (struct name_tree *)NULL;
    new_ptr->rright = (struct name_tree *)NULL;
    new_ptr->nleft = (struct name_tree *)NULL;
    new_ptr->nright = (struct name_tree *)NULL;
    new_ptr->region_id = reg_id;
    new_ptr->mode = mode;
    new_ptr->inner = -1;
    new_ptr->in_comp_group = 0;
    new_ptr->name = bu_strdup( name );
    new_ptr->magic = NAME_TREE_MAGIC;

    if( !name_root )
	name_root = new_ptr;
    else
	{
	    diff = strcmp( name , nptr_model->name );

	    if( diff > 0 )
		{
		    if( nptr_model->nright )
			{
			    bu_log( "Insert_region_name: nptr_model->nright not null\n" );
			    bu_exit(1, "\tCannot insert new node\n");
			}
		    nptr_model->nright = new_ptr;
		}
	    else
		{
		    if( nptr_model->nleft )
			{
			    bu_log( "Insert_region_name: nptr_model->nleft not null\n" );
			    bu_exit(1, "\tCannot insert new node\n");
			}
		    nptr_model->nleft = new_ptr;
		}


	    diff = reg_id - rptr_model->region_id;

	    if( diff > 0 )
		{
		    if( rptr_model->rright )
			{
			    bu_log( "Insert_region_name: rptr_model->rright not null\n" );
			    bu_exit(1, "\tCannot insert new node\n");
			}
		    rptr_model->rright = new_ptr;
		}
	    else
		{
		    if( rptr_model->rleft )
			{
			    bu_log( "Insert_region_name: rptr_model->rleft not null\n" );
			    bu_exit(1, "\tCannot insert new node\n");
			}
		    rptr_model->rleft = new_ptr;
		}
	}
    Check_names();
    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed in Insert_region_name\n" );
}


static char *
find_region_name(int g_id, int c_id)
{
    struct name_tree *ptr;
    int reg_id;
    int found;

    reg_id = g_id * 1000 + c_id;

    if( debug )
	bu_log( "find_region_name( g_id=%d, c_id=%d ), reg_id=%d\n" , g_id, c_id, reg_id );

    ptr = Search_ident( name_root , reg_id , &found );

    if( found )
	return( ptr->name );
    else
	return( (char *)NULL );
}


static char *
make_unique_name(char *name)
{
    struct bu_vls vls;
    int found;

    /* make a unique name from what we got off the $NAME card */

    (void)Search_names( name_root , name , &found );
    if( !found )
	return( bu_strdup( name ) );

    bu_vls_init( &vls );

    while( found )
	{
	    bu_vls_trunc( &vls, 0 );
	    bu_vls_printf( &vls, "%s_%d", name, name_count );
	    (void)Search_names( name_root , bu_vls_addr( &vls ) , &found );
	}
    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed in make_unique_name\n" );

    return( bu_vls_strgrab( &vls ) );
}


static void
make_region_name(int g_id, int c_id)
{
    int r_id;
    const char *tmp_name;
    char *name;

    r_id = g_id * 1000 + c_id;

    if( debug )
	bu_log( "make_region_name( g_id=%d, c_id=%d )\n" , g_id, c_id );

    tmp_name = find_region_name( g_id , c_id );
    if( tmp_name )
	return;

    /* create a new name */
    name = (char *)bu_malloc( LINELEN, "make_region_name" );
    snprintf( name , LINELEN, "comp_%04d.r" , r_id );

    make_unique_name( name );

    Insert_region_name( name , r_id );
}

static char *
get_solid_name(char type, int element_id, int c_id, int g_id, int inner)
{
    int reg_id;
    struct bu_vls vls;

    reg_id = g_id * 1000 + c_id;

    bu_vls_init( &vls );
    bu_vls_printf( &vls , "%d.%d.%c%d" , reg_id , element_id , type , inner );

    return( bu_vls_strgrab( &vls ) );
}


static void
Insert_name(struct name_tree **root, char *name, int inner)
{
    struct name_tree *ptr;
    struct name_tree *new_ptr;
    int found;
    int diff;

    ptr = Search_names( *root , name , &found );

    if( found )
	{
	    bu_log( "Insert_name: %s already in name tree\n" , name );
	    return;
	}

    new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_name: new_ptr" );

    new_ptr->name = bu_strdup( name );
    new_ptr->nleft = (struct name_tree *)NULL;
    new_ptr->nright = (struct name_tree *)NULL;
    new_ptr->rleft = (struct name_tree *)NULL;
    new_ptr->rright = (struct name_tree *)NULL;
    new_ptr->region_id = (-region_id);
    new_ptr->in_comp_group = 0;
    new_ptr->inner = inner;
    new_ptr->magic = NAME_TREE_MAGIC;

    if( !*root )
	{
	    *root = new_ptr;
	    return;
	}

    diff = strcmp( name , ptr->name );
    if( diff > 0 )
	{
	    if( ptr->nright )
		{
		    bu_log( "Insert_name: ptr->nright not null\n" );
		    bu_exit(1, "\tCannot insert new node\n");
		}
	    ptr->nright = new_ptr;
	}
    else
	{
	    if( ptr->nleft )
		{
		    bu_log( "Insert_name: ptr->nleft not null\n" );
		    bu_exit(1, "\tCannot insert new node\n");
		}
	    ptr->nleft = new_ptr;
	}
    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed in Insert_name\n" );
}


static char *
make_solid_name(char type, int element_id, int c_id, int g_id, int inner)
{
    char *name;

    name = get_solid_name( type , element_id , c_id , g_id , inner );

    Insert_name( &name_root , name, inner );

    return( name );
}


static void
insert_int(int in)
{
    int i;

    for( i=0 ; i<int_list_count ; i++ )
	{
	    if( int_list[i] == in )
		return;
	}

    if( int_list_count == int_list_length )
	{
	    if( int_list_length == 0 )
		int_list = (int *)bu_malloc( INT_LIST_BLOCK*sizeof( int ) , "insert_id: int_list" );
	    else
		int_list = (int *)bu_realloc( (char *)int_list , (int_list_length + INT_LIST_BLOCK)*sizeof( int ) , "insert_id: int_list" );
	    int_list_length += INT_LIST_BLOCK;
	}

    int_list[int_list_count] = in;
    int_list_count++;

    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed in insert_int\n" );
}


static void
Subtract_holes(struct wmember *head, int comp_id, int group_id)
{
    struct holes *hole_ptr;
    struct hole_list *list_ptr;

    if( debug )
	bu_log( "Subtract_holes( comp_id=%d, group_id=%d )\n" , comp_id , group_id );

    hole_ptr = hole_root;
    while( hole_ptr )
	{
	    if( hole_ptr->group == group_id && hole_ptr->component == comp_id )
		{
		    list_ptr = hole_ptr->holes;
		    while( list_ptr )
			{
			    struct name_tree *ptr;
			    int reg_id;

			    reg_id = list_ptr->group * 1000 + list_ptr->component;
			    ptr = name_root;
			    while( ptr && ptr->region_id != reg_id )
				{
				    int diff;

				    diff = reg_id - ptr->region_id;
				    if( diff > 0 )
					ptr = ptr->rright;
				    else if( diff < 0 )
					ptr = ptr->rleft;
				}

			    bu_ptbl_reset( &stack );

			    while( ptr && ptr->region_id == reg_id )
				{

				    while( ptr && ptr->region_id == reg_id )
					{
					    PUSH( ptr );
					    ptr = ptr->rleft;
					}
				    POP( name_tree , ptr );
				    if( !ptr ||  ptr->region_id != reg_id )
					break;

				    if( debug )
					bu_log( "\tSubtracting %s\n", ptr->name );

				    if( mk_addmember( ptr->name , &(head->l), NULL , WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_exit(1, "Subtract_holes: mk_addmember failed\n");

				    ptr = ptr->rright;
				}

			    list_ptr = list_ptr->next;
			}
		    break;
		}
	    hole_ptr = hole_ptr->next;
	}
    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed in subtract_holes\n" );
}

static void
f4_do_compsplt(void)
{
    int gr, co, gr1,  co1;
    fastf_t z;
    struct compsplt *splt;

    strncpy( field, &line[8], 8 );
    gr = atoi( field );

    strncpy( field, &line[16], 8 );
    co = atoi( field );

    strncpy( field, &line[24], 8 );
    gr1 = atoi( field );

    strncpy( field, &line[32], 8 );
    co1 = atoi( field );

    strncpy( field, &line[40], 8 );
    z = atof( field ) * 25.4;

    if( compsplt_root == NULL )
	{
	    compsplt_root = (struct compsplt *)bu_calloc( 1, sizeof( struct compsplt ), "compsplt_root" );
	    splt = compsplt_root;
	}
    else
	{
	    splt = compsplt_root;
	    while( splt->next )
		splt = splt->next;
	    splt->next = (struct compsplt *)bu_calloc( 1, sizeof( struct compsplt ), "compsplt_root" );
	    splt = splt->next;
	}
    splt->next = (struct compsplt *)NULL;
    splt->ident_to_split = gr * 1000 + co;
    splt->new_ident = gr1 * 1000 + co1;
    splt->z = z;
    make_region_name( gr1, co1 );
}

static void
List_holes(void)
{
    struct holes *hole_ptr;
    struct hole_list *list_ptr;

    hole_ptr = hole_root;

    while( hole_ptr )
	{
	    bu_log( "Holes for Group %d, Component %d:\n" , hole_ptr->group, hole_ptr->component );
	    list_ptr = hole_ptr->holes;
	    while( list_ptr )
		{
		    bu_log( "\tgroup %d component %d\n" , list_ptr->group, list_ptr->component );
		    list_ptr = list_ptr->next;
		}
	    hole_ptr = hole_ptr->next;
	}
}


static void
Delete_name(struct name_tree **root, char *name)
{
    struct name_tree *ptr,*parent,*ptr2;
    int r_id;
    int found;
    int diff;

    /* first delete from name portion of tree */
    ptr = *root;
    parent = (struct name_tree *)NULL;
    found = 0;

    while( 1 )
	{
	    diff = strcmp( name , ptr->name );
	    if( diff == 0 )
		{
		    found = 1;
		    break;
		}
	    else if( diff > 0 )
		{
		    if( ptr->nright )
			{
			    parent = ptr;
			    ptr = ptr->nright;
			}
		    else
			break;
		}
	    else if( diff < 0 )
		{
		    if( ptr->nleft )
			{
			    parent = ptr;
			    ptr = ptr->nleft;
			}
		    else
			break;
		}
	}

    if( !found )
	return;

    r_id = ptr->region_id;

    if( parent == (struct name_tree *)NULL )
	{
	    if( ptr->nright )
		{
		    *root = ptr->nright;
		    ptr2 = *root;
		    while( ptr2->nleft )
			ptr2 = ptr2->nleft;
		    ptr2->nleft = ptr->nleft;

		    ptr2 = *root;
		    while( ptr2->rleft )
			ptr2 = ptr2->rleft;
		    ptr2->rleft = ptr->rleft;
		}
	    else if( ptr->nleft )
		{
		    *root = ptr->nleft;
		    ptr2 = *root;
		    while( ptr2->nright )
			ptr2 = ptr2->nright;
		    ptr2->nright = ptr->nright;
		    ptr2 = *root;
		    while( ptr2->rright )
			ptr2 = ptr2->rright;
		    ptr2->rright = ptr->rright;
		}
	    else
		{
		    /* This was the only name in the tree */
		    *root = (struct name_tree *)NULL;
		}
	    bu_free( (char *)ptr , "Delete_name: ptr" );
	    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
	    return;
	}
    else
	{
	    if( parent->nright == ptr )
		{
		    if( ptr->nleft )
			{
			    parent->nright = ptr->nleft;
			    ptr2 = ptr->nleft;
			    while( ptr2->nright )
				ptr2 = ptr2->nright;
			    ptr2->nright = ptr->nright;
			}
		    else
			parent->nright = ptr->nright;
		}
	    else if( parent->nleft == ptr )
		{
		    if( ptr->nright )
			{
			    parent->nleft = ptr->nright;
			    ptr2 = ptr->nright;
			    while( ptr2->nleft )
				ptr2 = ptr2->nleft;
			    ptr2->nleft = ptr->nleft;
			}
		    else
			parent->nleft = ptr->nleft;
		}
	}


    /* now delete from ident prtion of tree */
    ptr = *root;
    parent = (struct name_tree *)NULL;
    found = 0;

    while( 1 )
	{
	    diff = r_id - ptr->region_id;

	    if( diff == 0 )
		{
		    found = 1;
		    break;
		}
	    else if( diff > 0 )
		{
		    if( ptr->rright )
			{
			    parent = ptr;
			    ptr = ptr->rright;
			}
		    else
			break;
		}
	    else if( diff < 0 )
		{
		    if( ptr->rleft )
			{
			    parent = ptr;
			    ptr = ptr->rleft;
			}
		    else
			break;
		}
	}

    if( !found )
	{
	    bu_exit(1, "ERROR: name (%s) deleted from name tree, but not found in ident tree!\n" , name);
	}

    if( !parent )
	{
	    bu_exit(1, "ERROR: name (%s) is root of ident tree, but not name tree!\n" , name );
	}


    if( parent->rright == ptr )
	{
	    if( ptr->rleft )
		{
		    parent->rright = ptr->rleft;
		    ptr2 = ptr->rleft;
		    while( ptr2->rright )
			ptr2 = ptr2->rright;
		    ptr2->rright = ptr->rright;
		}
	    else
		parent->rright = ptr->rright;
	}
    else if( parent->rleft == ptr )
	{
	    if( ptr->rright )
		{
		    parent->rleft = ptr->rright;
		    ptr2 = ptr->rright;
		    while( ptr2->rleft )
			ptr2 = ptr2->rleft;
		    ptr2->rleft = ptr->rleft;
		}
	    else
		parent->rleft = ptr->rleft;
	}
    bu_free( (char *)ptr , "Delete_name: ptr" );
    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
    Check_names();
}


static void
add_to_series(char *name, int reg_id)
{
    if( group_id < 0 || group_id > 10 )
	{
	    bu_log( "add_to_series: region (%s) not added, illegal group number %d, region_id=$d\n" ,
		    name , group_id , reg_id );
	    return;
	}

    if( mk_addmember( name , &group_head[group_id].l, NULL ,WMOP_UNION ) == (struct wmember *)NULL )
	bu_log( "add_to_series: mk_addmember failed for region %s\n" , name );
}


static void
make_comp_group(void)
{
    struct wmember g_head;
    struct name_tree *ptr;

    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed in make_comp_group\n" );

    BU_LIST_INIT( &g_head.l );

    bu_ptbl_reset( &stack );

    ptr = name_root;
    while( 1 )
	{
	    while( ptr )
		{
		    PUSH( ptr );
		    ptr = ptr->nleft;
		}
	    POP( name_tree , ptr );
	    if( !ptr )
		break;

	    if(ptr->region_id == region_id && !ptr->inner && !ptr->in_comp_group )
		{
		    if( mk_addmember( ptr->name , &g_head.l , NULL , WMOP_UNION ) == (struct wmember *)NULL )
			{
			    bu_log( "make_comp_group: Could not add %s to group for ident %d\n" , ptr->name , ptr->region_id );
			    break;
			}
		    ptr->in_comp_group = 1;
		}
	    ptr = ptr->nright;
	}

    if( BU_LIST_NON_EMPTY( &g_head.l ) )
	{
	    char *name;
	    struct bu_vls vls;

	    if( !(name=find_region_name( group_id , comp_id )) )
		{
		    bu_vls_init( &vls );
		    bu_vls_printf( &vls , "comp_%d" , region_id );
		    name = make_unique_name( bu_vls_addr( &vls ) );
		    bu_vls_free( &vls );
		    if( warnings )
			bu_log( "Creating default name (%s) for group %d component %d\n",
				name , group_id , comp_id );
		    Insert_name( &name_root , name, 1 );
		}

	    mk_lfcomb( fdout , name , &g_head , 0 );
	    if( !is_a_hole( region_id ) )
		add_to_series( name , region_id );
	    else
		add_to_holes( name, region_id );

	    bu_free( (char *)name, "str_dupped name" );
	}
}


static void
Add_stragglers_to_groups(void)
{
    struct name_tree *ptr;

    ptr = name_root;

    while( 1 )
	{
	    while( ptr )
		{
		    PUSH( ptr );
		    ptr = ptr->rleft;
		}
	    POP( name_tree, ptr );
	    if( !ptr )
		break;

	    /* visit node */
	    CK_TREE_MAGIC( ptr );

	    if( !ptr->in_comp_group && ptr->region_id > 0 && !is_a_hole( ptr->region_id ) )
		{
		    /* add this component to a series */
		    (void)mk_addmember( ptr->name, &group_head[ptr->region_id/1000].l, NULL, WMOP_UNION );
		    ptr->in_comp_group = 1;
		}

	    ptr = ptr->rright;
	}
}


static void
f4_do_groups(void)
{
    int group_no;
    struct wmember head_all;

    if( debug )
	bu_log( "f4_do_groups\n" );

    BU_LIST_INIT( &head_all.l );

    Add_stragglers_to_groups();

    for( group_no=0 ; group_no < 11 ; group_no++ )
	{
	    char name[LINELEN] = {0};

	    if( BU_LIST_IS_EMPTY( &group_head[group_no].l ) )
		continue;

	    snprintf( name , LINELEN, "%dxxx_series" , group_no );
	    mk_lfcomb( fdout , name , &group_head[group_no] , 0 );

	    if( mk_addmember( name , &head_all.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
		bu_log( "f4_do_groups: mk_addmember failed to add %s to group all\n" , name );
	}

    if( BU_LIST_NON_EMPTY( &head_all.l ) )
	mk_lfcomb( fdout , "all" , &head_all , 0 );

    if( BU_LIST_NON_EMPTY( &hole_head.l ) )
	mk_lfcomb( fdout , "holes" , &hole_head , 0 );
}


static void
f4_do_name(void)
{
    int i,j;
    int g_id;
    int c_id;
    char comp_name[LINELEN] = {0}; /* should only use 25 chars */
    char tmp_name[LINELEN] = {0}; /* should only use 25 chars */

    if( pass )
	return;

    if( debug )
	bu_log( "f4_do_name: %s\n" , line );

    strncpy( field , &line[8] , 8 );
    g_id = atoi( field );

    if( g_id != group_id )
	{
	    bu_log( "$NAME card for group %d in section for group %d ignored\n" , g_id , group_id );
	    bu_log( "%s\n" , line );
	    return;
	}

    strncpy( field , &line[16] , 8 );
    c_id = atoi( field );

    if( c_id != comp_id )
	{
	    bu_log( "$NAME card for component %d in section for component %d ignored\n" , c_id , comp_id );
	    bu_log( "%s\n" , line );
	    return;
	}

    /* skip leading blanks */
    i = 56;
    while( i < 80 && isspace( line[i] ) )
	i++;
    if( i == 80 )
	return;

    strncpy( comp_name , &line[i] , 80 - i );

    /* eliminate trailing blanks */
    i = 80 - i;
    while(  --i >= 0 && isspace( comp_name[i] ) )
	comp_name[i] = '\0';

    /* copy comp_name to tmp_name while replacing white space with "_" */
    i = (-1);
    j = (-1);

    /* copy */
    while( comp_name[++i] != '\0' )
	{
	    if( isspace( comp_name[i] ) || comp_name[i] == '/' )
		{
		    if( j == (-1) || tmp_name[j] != '_' )
			tmp_name[++j] = '_';
		}
	    else
		tmp_name[++j] = comp_name[i];
	}
    tmp_name[++j] = '\0';

    /* reserve this name for group name */
    make_unique_name( tmp_name );
    Insert_region_name( tmp_name , region_id );

    name_count = 0;
    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed in f4_do_name\n" );
}


static void
f4_do_grid(void)
{
    int grid_no;
    fastf_t x,y,z;

    if( !pass )	/* not doing geometry yet */
	return;

    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed at start of f4_do_grid\n" );

    strncpy( field , &line[8] , 8 );
    grid_no = atoi( field );

    if( grid_no < 1 )
	{
	    bu_exit(1, "ERROR: bad grid id number = %d\n" , grid_no);
	}

    strncpy( field , &line[24] , 8 );
    x = atof( field );

    strncpy( field , &line[32] , 8 );
    y = atof( field );

    strncpy( field , &line[40] , 8 );
    z = atof( field );

    while( grid_no > grid_size - 1 )
	{
	    grid_size += GRID_BLOCK;
	    grid_points = (point_t *)bu_realloc( (char *)grid_points , grid_size * sizeof( point_t ) , "fast4-g: grid_points" );
	}

    VSET( grid_points[grid_no] , x*25.4 , y*25.4 , z*25.4 );

    if( grid_no > max_grid_no )
	max_grid_no = grid_no;
    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
	bu_log( "ERROR: bu_mem_barriercheck failed at end of f4_do_grid\n" );
}


static void
f4_do_sphere(void)
{
    int element_id;
    int center_pt;
    fastf_t thick;
    fastf_t radius;
    fastf_t inner_radius;
    char *name = (char *)NULL;
    struct wmember sphere_group;

    if( !pass )
	{
	    make_region_name( group_id , comp_id );
	    return;
	}

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    strncpy( field , &line[24] , 8 );
    center_pt = atoi( field );

    strncpy( field , &line[56] , 8 );
    thick = atof( field ) * 25.4;

    strncpy( field , &line[64] , 8 );
    radius = atof( field ) * 25.4;
    if( radius <= 0.0 )
	{
	    bu_log( "f4_do_sphere: illegal radius (%f), skipping sphere\n" , radius );
	    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
	    return;
	}

    if( center_pt < 1 || center_pt > max_grid_no )
	{
	    bu_log( "f4_do_sphere: illegal grid number for center point %d, skipping sphere\n" , center_pt );
	    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
	    return;
	}

    BU_LIST_INIT( &sphere_group.l );

    if( mode == VOLUME_MODE )
	{
	    name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 0 );
	    mk_sph( fdout , name , grid_points[center_pt] , radius );
	    bu_free( name, "solid_name" );
	}
    else if( mode == PLATE_MODE )
	{
	    name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 1 );
	    mk_sph( fdout , name , grid_points[center_pt] , radius );

	    BU_LIST_INIT( &sphere_group.l );

	    if( mk_addmember( name ,  &sphere_group.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
		{
		    bu_exit(1, "f4_do_sphere: Error in adding %s to sphere group\n" , name);
		}
	    bu_free( name, "solid_name" );

	    inner_radius = radius - thick;
	    if( thick > 0.0 && inner_radius <= 0.0 )
		{
		    bu_log( "f4_do_sphere: illegal thickness (%f), skipping inner sphere\n" , thick );
		    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		    return;
		}

	    name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 2 );
	    mk_sph( fdout , name , grid_points[center_pt] , inner_radius );

	    if( mk_addmember( name , &sphere_group.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
		{
		    bu_exit(1, "f4_do_sphere: Error in subtracting %s from sphere region\n" , name);
		}
	    bu_free( name, "solid_name" );

	    name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 0 );
	    mk_comb( fdout, name, &sphere_group.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
	    bu_free( name, "solid_name" );
	}
}


static void
f4_do_vehicle(void)
{
    if( pass )
	return;

    strncpy( vehicle , &line[8] , 16 ); /* why 16? */
    mk_id_units( fdout , vehicle , "in" );
}


static void
f4_do_cline(void)
{
    int element_id;
    int pt1,pt2;
    fastf_t thick;
    fastf_t radius;
    vect_t height;
    char *name;

    if( debug )
	bu_log( "f4_do_cline: %s\n" , line );

    if( !pass )
	{
	    make_region_name( group_id , comp_id );
	    return;
	}

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    strncpy( field , &line[24] , 8 );
    pt1 = atoi( field );
    if( pass && (pt1 < 1 || pt1 > max_grid_no) )
	{
	    bu_log( "Illegal grid point (%d) in CLINE, skipping\n", pt1 );
	    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
	    return;
	}

    strncpy( field , &line[32] , 8 );
    pt2 = atoi( field );
    if( pass && (pt2 < 1 || pt2 > max_grid_no) )
	{
	    bu_log( "Illegal grid point in CLINE (%d), skipping\n", pt2 );
	    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
	    return;
	}

    if( pt1 == pt2 )
	{
	    bu_log( "Ilegal grid points in CLINE ( %d and %d ), skipping\n", pt1 , pt2 );
	    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
	    return;
	}

    strncpy( field , &line[56] , 8 );
    thick = atof( field ) * 25.4;

    strncpy( field , &line[64] , 8 );
    radius = atof( field ) * 25.4;

    VSUB2( height , grid_points[pt2] , grid_points[pt1] );

    name = make_solid_name( CLINE , element_id , comp_id , group_id , 0 );
    mk_cline( fdout , name , grid_points[pt1] , height , radius, thick );
    bu_free( name, "solid_name" );
}


static void
f4_do_ccone1(void)
{
    int element_id;
    int pt1,pt2;
    fastf_t thick;
    int c1,c2;
    int end1,end2;
    vect_t height;
    fastf_t r1,r2;
    char *outer_name;
    char *inner_name;
    char *name = (char *)NULL;
    struct wmember r_head;

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    if( !pass )
	{
	    make_region_name( group_id , comp_id );
	    if( !get_line() )
		{
		    bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    bu_exit(1, "ERROR: unexpected end-of-file");
		}
	    return;
	}

    strncpy( field , &line[24] , 8 );
    pt1 = atoi( field );

    strncpy( field , &line[32] , 8 );
    pt2 = atoi( field );

    strncpy( field , &line[56] , 8 );
    thick = atof( field ) * 25.4;

    strncpy( field , &line[64] , 8 );
    r1 = atof( field ) * 25.4;

    strncpy( field , &line[72] , 8 );
    c1 = atoi( field );

    if( !get_line() )
	{
	    bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
		    group_id, comp_id, element_id , c1 );
	    bu_exit(1, "ERROR: unexpected end-of-file");
	}

    strncpy( field , line , 8 );
    c2 = atoi( field );

    if( c1 != c2 )
	{
	    bu_log( "WARNING: CCONE1 continuation flags disagree, %d vs %d\n" , c1 , c2 );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	}

    strncpy( field , &line[8] , 8 );
    r2 = atof( field ) * 25.4;

    strncpy( field , &line[16] , 8 );
    end1 = atoi( field );

    strncpy( field , &line[24] , 8 );
    end2 = atoi( field );

    if( r1 < 0.0 || r2 < 0.0 )
	{
	    bu_log( "ERROR: CCONE1 has illegal radii, %f and %f\n" , r1/25.4 , r2/25.4 );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	    bu_log( "\tCCONE1 solid ignored\n" );
	    return;
	}

    if( mode == PLATE_MODE )
	{
	    if( thick <= 0.0 )
		{
		    bu_log( "ERROR: Plate mode CCONE1 has illegal thickness (%f)\n" , thick/25.4 );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    bu_log( "\tCCONE1 solid ignored\n" );
		    return;
		}

	    if( r1-thick < min_radius && r2-thick < min_radius )
		{
		    bu_log( "ERROR: Plate mode CCONE1 has too large thickness (%f)\n" , thick/25.4 );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    bu_log( "\tCCONE1 solid ignored\n" );
		    return;
		}
	}

    if( pt1 < 1 || pt1 > max_grid_no || pt2 < 1 || pt2 > max_grid_no || pt1 == pt2 )
	{
	    bu_log( "ERROR: CCONE1 has illegal grid points ( %d and %d)\n" , pt1 , pt2 );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	    bu_log( "\tCCONE1 solid ignored\n" );
	    return;
	}

    /* BRL_CAD doesn't allow zero radius, so use a very small radius */
    if( r1 < min_radius )
	r1 = min_radius;
    if( r2 < min_radius )
	r2 = min_radius;

    VSUB2( height , grid_points[pt2] , grid_points[pt1] );

    if( mode == VOLUME_MODE )
	{
	    outer_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 0 );
	    mk_trc_h( fdout , outer_name , grid_points[pt1] , height , r1 , r2 );
	    bu_free( outer_name, "solid_name" );
	}
    else if( mode == PLATE_MODE )
	{
	    /* make inside TGC */

	    point_t base;
	    point_t top;
	    vect_t inner_height;
	    fastf_t inner_r1,inner_r2;
	    fastf_t length;
	    fastf_t sin_ang;
	    fastf_t slant_len;
	    fastf_t r1a,r2a;
	    vect_t height_dir;

	    /* make outside TGC */
	    outer_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 1 );
	    mk_trc_h( fdout , outer_name , grid_points[pt1] , height , r1 , r2 );

	    BU_LIST_INIT( &r_head.l );
	    if( mk_addmember( outer_name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
		bu_exit(1, "CCONE1: mk_addmember failed\n");
	    bu_free( outer_name, "solid_name" );

	    length = MAGNITUDE( height );
	    VSCALE( height_dir , height , 1.0/length );
	    slant_len = sqrt( length*length + (r2 - r1)*(r2 - r1) );

	    sin_ang = length/slant_len;

	    if( end1 == END_OPEN )
		{
		    r1a = r1;
		    inner_r1 = r1 - thick/sin_ang;
		    VMOVE( base , grid_points[pt1] );
		}
	    else
		{
		    r1a = r1 + (r2 - r1)*thick/length;
		    inner_r1 = r1a - thick/sin_ang;
		    VJOIN1( base , grid_points[pt1] , thick , height_dir );
		}

	    if( inner_r1 < 0.0 )
		{
		    fastf_t dist_to_new_base;

		    dist_to_new_base = inner_r1 * length/(r1 - r2 );
		    inner_r1 = min_radius;
		    VJOIN1( base , base , dist_to_new_base , height_dir );
		}
	    else if( inner_r1 < min_radius )
		inner_r1 = min_radius;

	    if( end2 == END_OPEN )
		{
		    r2a = r2;
		    inner_r2 = r2 - thick/sin_ang;
		    VMOVE( top , grid_points[pt2] );
		}
	    else
		{
		    r2a = r2 + (r1 - r2)*thick/length;
		    inner_r2 = r2a - thick/sin_ang;
		    VJOIN1( top , grid_points[pt2] , -thick , height_dir );
		}

	    if( inner_r2 < 0.0 )
		{
		    fastf_t dist_to_new_top;

		    dist_to_new_top = inner_r2 * length/(r2 - r1 );
		    inner_r2 = min_radius;
		    VJOIN1( top , top , -dist_to_new_top , height_dir );
		}
	    else if( inner_r2 < min_radius )
		inner_r2 = min_radius;

	    VSUB2( inner_height , top , base );
	    if( VDOT( inner_height , height ) <= 0.0 )
		{
		    bu_log( "ERROR: CCONE1 height (%f) too small for thickness (%f)\n" , length/25.4 , thick/25.4 );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    bu_log( "\tCCONE1 inner solid ignored\n" );
		}
	    else
		{
		    /* make inner tgc */

		    inner_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 2 );
		    mk_trc_h( fdout , inner_name , base , inner_height , inner_r1 , inner_r2 );

		    if( mk_addmember( inner_name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
			bu_exit(1, "CCONE1: mk_addmember failed\n");
		    bu_free( inner_name, "solid_name" );
		}

	    name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 0 );
	    mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
	    bu_free( name, "solid_name" );
	}

}


static void
f4_do_ccone2(void)
{
    int element_id;
    int pt1,pt2;
    int c1,c2;
    fastf_t ro1,ro2,ri1,ri2;
    vect_t height;
    char *name = (char *)NULL;
    struct wmember r_head;

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    if( !pass )
	{
	    make_region_name( group_id , comp_id );
	    if( !get_line() )
		{
		    bu_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    bu_exit(1, "ERROR: unexpected end-of-file encountered\n" );
		}
	    return;
	}

    strncpy( field , &line[24] , 8 );
    pt1 = atoi( field );

    strncpy( field , &line[32] , 8 );
    pt2 = atoi( field );

    strncpy( field , &line[64] , 8 );
    ro1 = atof( field ) * 25.4;

    strncpy( field , &line[72] , 8 );
    c1 = atoi( field );

    if( !get_line() )
	{
	    bu_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
		    group_id, comp_id, element_id , c1 );
	    bu_exit(1, "ERROR: unexpected end-of-file encountered\n" );
	}

    strncpy( field , line , 8 );
    c2 = atoi( field );

    if( c1 != c2 )
	{
	    bu_log( "WARNING: CCONE2 continuation flags disagree, %d vs %d\n" , c1 , c2 );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	}

    strncpy( field , &line[8] , 8 );
    ro2 = atof( field ) * 25.4;

    strncpy( field , &line[16] , 8 );
    ri1 = atof( field ) * 25.4;

    strncpy( field , &line[24] , 8 );
    ri2 = atof( field ) * 25.4;

    if( pt1 == pt2 )
	{
	    bu_log( "ERROR: CCONE2 has same endpoints %d and %d\n", pt1, pt2 );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	    return;
	}

    if( ro1 < 0.0 || ro2 < 0.0 || ri1 < 0.0 || ri2 < 0.0 )
	{
	    bu_log( "ERROR: CCONE2 has illegal radii %f %f %f %f\n" , ro1, ro2, ri1, ri2 );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	    return;
	}

    if( ro1 < min_radius )
	ro1 = min_radius;

    if( ro2 < min_radius )
	ro2 = min_radius;

    BU_LIST_INIT( &r_head.l );

    VSUB2( height , grid_points[pt2] , grid_points[pt1] );

    if( ri1 <= 0.0 && ri2 <= 0.0 )
	{
	    name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 0 );
	    mk_trc_h( fdout , name , grid_points[pt1] , height , ro1 , ro2 );
	    bu_free( name, "solid_name" );
	}
    else
	{
	    name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 1 );
	    mk_trc_h( fdout , name , grid_points[pt1] , height , ro1 , ro2 );

	    if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
		bu_exit(1, "mk_addmember failed!\n");
	    bu_free( name, "solid_name" );

	    if( ri1 < min_radius )
		ri1 = min_radius;

	    if( ri2 < min_radius )
		ri2 = min_radius;

	    name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 2 );
	    mk_trc_h( fdout , name , grid_points[pt1] , height , ri1 , ri2 );

	    if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
		bu_exit(1, "mk_addmember failed!\n");
	    bu_free( name, "solid_name" );

	    name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 0 );
	    mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
	    bu_free( name, "solid_name" );
	}
}


static void
f4_do_ccone3(void)
{
    int element_id;
    int pt1, pt2, pt3, pt4, i;
    char *name;
    fastf_t ro[4], ri[4], len03, len01, len12, len23;
    vect_t diff, diff2, diff3, diff4;
    struct wmember r_head;

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    if( !pass )
	{
	    make_region_name( group_id , comp_id );
	    if( !get_line() )
		{
		    bu_log( "Unexpected EOF while reading continuation card for CCONE3\n" );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    bu_exit(1, "ERROR: unexpected end-of-file encountered\n" );
		}
	    return;
	}

    strncpy( field , &line[24] , 8 );
    pt1 = atoi( field );

    strncpy( field , &line[32] , 8 );
    pt2 = atoi( field );

    strncpy( field , &line[40] , 8 );
    pt3 = atoi( field );

    strncpy( field , &line[48] , 8 );
    pt4 = atoi( field );

    strncpy( field, &line[72], 8 );

    if( !get_line() )
	{
	    bu_log( "Unexpected EOF while reading continuation card for CCONE3\n" );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %8.8s\n",
		    group_id, comp_id, element_id , field );
	    bu_exit(1, "ERROR: unexpected end-of-file encountered\n" );
	}

    if( strncmp( field, line, 8 ) )
	{
	    bu_log( "WARNING: CCONE3 continuation flags disagree, %8.8s vs %8.8s\n" , field , line );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	}

    for( i=0 ; i<4 ; i++ )
	{
	    strncpy( field, &line[8*(i+1)], 8 );
	    ro[i] = atof( field ) * 25.4;
	    if( ro[i] < 0.0 )
		{
		    bu_log( "ERROR: CCONE3 has illegal radius %f\n", ro[i] );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    return;
		}
	    if( !strcmp( field, "        " ) )
		ro[i] = -1.0;
	}

    for( i=0 ; i<4 ; i++ )
	{
	    strncpy( field, &line[32 + 8*(i+1)], 8 );
	    ri[i] = atof( field ) * 25.4;
	    if( ri[i] < 0.0 )
		{
		    bu_log( "ERROR: CCONE3 has illegal radius %f\n", ri[i] );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    return;
		}
	    if( !strcmp( field, "        " ) )
		ri[i] = -1.0;
	}

    VSUB2( diff4, grid_points[pt4], grid_points[pt1] );
    VSUB2( diff3, grid_points[pt3], grid_points[pt1] );
    VSUB2( diff2, grid_points[pt2], grid_points[pt1] );

    len03 = MAGNITUDE( diff4 );
    len01 = MAGNITUDE( diff2 );
    len12 = MAGNITUDE( diff3 ) - len01;
    len23 = len03 - len01 - len12;

    for( i=0 ; i<4 ; i+=3 )
	{
	    if( ro[i] ==-1.0 )
		{
		    if( ri[i] == -1.0 )
			{
			    bu_log( "ERROR: both inner and outer radii at g%d of a CCONE3 are undefined\n", i+1 );
			    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				    group_id, comp_id, element_id );
			    return;
			}
		    else
			ro[i] = ri[i];

		}
	    else if( ri[i] == -1.0 )
		ri[i] = ro[i];
	}

    if( ro[1] == -1.0 )
	{
	    if( ro[2] != -1.0 )
		ro[1] = ro[0] + (ro[2] - ro[0]) * len01 / (len01 + len12);
	    else
		ro[1] = ro[0] + (ro[3] - ro[0]) * len01 / len03;
	}
    if( ro[2] == -1.0 )
	{
	    if( ro[1] != -1.0 )
		ro[2] = ro[1] + (ro[3] - ro[1]) * len12 / (len12 + len23);
	    else
		ro[2] = ro[0] + (ro[3] - ro[0]) * (len01 + len12) / len03;
	}
    if( ri[1] == -1.0 )
	{
	    if( ri[2] != -1.0 )
		ri[1] = ri[0] + (ri[2] - ri[0]) * len01 / (len01 + len12);
	    else
		ri[1] = ri[0] + (ri[3] - ri[0]) * len01 / len03;
	}
    if( ri[2] == -1.0 )
	{
	    if( ri[1] != -1.0 )
		ri[2] = ri[1] + (ri[3] - ri[1]) * len12 / (len12 + len23);
	    else
		ri[2] = ri[0] + (ri[3] - ri[0]) * (len01 + len12) / len03;
	}

    for( i=0 ; i<4 ; i++ )
	{
	    if( ro[i] < min_radius )
		ro[i] = min_radius;
	    if( ri[i] < min_radius )
		ri[i] = min_radius;
	}

    BU_LIST_INIT( &r_head.l );

    if( pt1 != pt2 )
	{
	    VSUB2( diff, grid_points[pt2], grid_points[pt1] );

	    /* make first cone */
	    if( ro[0] != min_radius || ro[1] != min_radius )
		{
		    name = make_solid_name( CCONE3, element_id, comp_id, group_id, 1 );
		    mk_trc_h( fdout, name, grid_points[pt1], diff, ro[0], ro[1] );
		    if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_exit(1, "mk_addmember failed!\n");
		    bu_free( name, "solid_name" );

		    /* and the inner cone */
		    if( ri[0] != min_radius || ri[1] != min_radius )
			{
			    name = make_solid_name( CCONE3, element_id, comp_id, group_id, 11 );
			    mk_trc_h( fdout, name, grid_points[pt1], diff, ri[0], ri[1] );
			    if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_exit(1, "mk_addmember failed!\n");
			    bu_free( name, "solid_name" );
			}
		}
	}

    if( pt2 != pt3 )
	{
	    VSUB2( diff, grid_points[pt3], grid_points[pt2] );

	    /* make second cone */
	    if( ro[1] != min_radius || ro[2] != min_radius )
		{
		    name = make_solid_name( CCONE3, element_id, comp_id, group_id, 2 );
		    mk_trc_h( fdout, name, grid_points[pt2], diff, ro[1], ro[2] );
		    if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_exit(1, "mk_addmember failed!\n");
		    bu_free( name, "solid_name" );

		    /* and the inner cone */
		    if( ri[1] != min_radius || ri[2] != min_radius )
			{
			    name = make_solid_name( CCONE3, element_id, comp_id, group_id, 22 );
			    mk_trc_h( fdout, name, grid_points[pt2], diff, ri[1], ri[2] );
			    if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_exit(1, "mk_addmember failed!\n");
			    bu_free( name, "solid_name" );
			}
		}
	}

    if( pt3 != pt4 )
	{
	    VSUB2( diff, grid_points[pt4], grid_points[pt3] );

	    /* make third cone */
	    if( ro[2] != min_radius || ro[3] != min_radius )
		{
		    name = make_solid_name( CCONE3, element_id, comp_id, group_id, 3 );
		    mk_trc_h( fdout, name, grid_points[pt3], diff, ro[2], ro[3] );
		    if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_exit(1, "mk_addmember failed!\n");
		    bu_free( name, "solid_name" );

		    /* and the inner cone */
		    if( ri[2] != min_radius || ri[3] != min_radius )
			{
			    name = make_solid_name( CCONE3, element_id, comp_id, group_id, 33 );
			    mk_trc_h( fdout, name, grid_points[pt3], diff, ri[2], ri[3] );
			    if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_exit(1, "mk_addmember failed!\n");
			    bu_free( name, "solid_name" );
			}
		}
	}

    name = make_solid_name( CCONE3 , element_id , comp_id , group_id , 0 );
    mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
    bu_free( name, "solid_name" );
}


static int
skip_region( int id )
{
    int i;

    if( !f4_do_skips )
	return( 0 );

    for( i=0 ; i<f4_do_skips ; i++ )
	{
	    if( id == region_list[i] )
		return( 0 );
	}

    return( 1 );
}


static void
Add_holes( int type, int gr, int comp, struct hole_list *ptr )
{
    struct holes *hole_ptr = (struct holes *)NULL;
    struct holes *prev = (struct holes *)NULL;
    struct hole_list *hptr= (struct hole_list *)NULL;

    if( debug )
	{
	    bu_log( "Adding holes for group %d, component %d:\n", gr, comp );
	    hptr = ptr;
	    while( hptr )
		{
		    bu_log( "\t%d %d\n", hptr->group, hptr->component );
		    hptr = hptr->next;
		}
	}

    if( f4_do_skips )
	{
	    if( !skip_region(gr*1000 + comp) )
		{
		    /* add holes for this region to the list of regions to process */
		    hptr = ptr;
		    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole\n" );
		    while( hptr )
			{
			    if( f4_do_skips == region_list_len )
				{
				    region_list_len += REGION_LIST_BLOCK;
				    region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
				    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole (after realloc)\n" );
				}
			    region_list[f4_do_skips++] = 1000*hptr->group + hptr->component;
			    if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
				bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole (after adding %d\n)\n", 1000*hptr->group + hptr->component );
			    hptr = hptr->next;
			}
		}
	}

    if( !hole_root )
	{
	    hole_root = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_root" );
	    hole_root->group = gr;
	    hole_root->component = comp;
	    hole_root->type = type;
	    hole_root->holes = ptr;
	    hole_root->next = (struct holes *)NULL;
	    return;
	}

    hole_ptr = hole_root;
    prev = hole_root;
    while( hole_ptr )
	{
	    if( hole_ptr->group == gr &&
		hole_ptr->component == comp &&
		hole_ptr->type == type )
		break;
	    prev = hole_ptr;
	    hole_ptr = hole_ptr->next;
	}

    if( hole_ptr && hole_ptr->group == gr && hole_ptr->component == comp && hole_ptr->type == type )
	{
	    struct hole_list *list;

	    if( !hole_ptr->holes )
		hole_ptr->holes = ptr;
	    else
		{
		    list = hole_ptr->holes;
		    while( list->next )
			list = list->next;
		    list->next = ptr;
		}
	}
    else
	{
	    prev->next = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_ptr->next" );
	    hole_ptr = prev->next;
	    hole_ptr->group = gr;
	    hole_ptr->component = comp;
	    hole_ptr->type = type;
	    hole_ptr->holes = ptr;
	    hole_ptr->next = (struct holes *)NULL;
	}
}


static void
f4_do_hole_wall(int type)
{
    struct hole_list *list_ptr;
    struct hole_list *list_start;
    int group, comp;
    int igrp, icmp;
    int s_len;
    int col;

    if( debug )
	bu_log( "f4_do_hole_wall: %s\n" , line );

    if( pass )
	return;

    if( type != HOLE && type != WALL ) {
	bu_exit(1, "f4_do_hole_wall: unrecognized type (%d)\n", type);
    }

    /* eliminate trailing blanks */
    s_len = strlen( line );
    while( isspace(line[--s_len] ) )
	line[s_len] = '\0';

    s_len = strlen( line );
    if( s_len > 80 )
	s_len = 80;

    strncpy( field , &line[8] , 8 );
    group = atoi( field );

    strncpy( field , &line[16] , 8 );
    comp = atoi( field );

    list_start = (struct hole_list *)NULL;
    list_ptr = (struct hole_list *)NULL;
    col = 24;

    while( col < s_len )
	{
	    strncpy( field , &line[col] , 8 );
	    igrp = atoi( field );

	    col += 8;
	    if( col >= s_len )
		break;

	    strncpy( field , &line[col] , 8 );
	    icmp = atoi( field );

	    if( igrp >= 0 && icmp > 0 )
		{
		    if( igrp == group && comp == icmp )
			bu_log( "Hole or wall card references itself (ignoring): (%s)\n", line );
		    else
			{
			    if( list_ptr )
				{
				    list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "f4_do_hole_wall: list_ptr" );
				    list_ptr = list_ptr->next;
				}
			    else
				{
				    list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "f4_do_hole_wall: list_ptr" );
				    list_start = list_ptr;
				}

			    list_ptr->group = igrp;
			    list_ptr->component = icmp;
			    list_ptr->next = (struct hole_list *)NULL;
			}
		}

	    col += 8;
	}

    Add_holes( type, group , comp , list_start );
}


static void
f4_Add_bot_face(int pt1, int pt2, int pt3, fastf_t thick, int pos)
{

    if( pt1 == pt2 || pt2 == pt3 || pt1 == pt3 )
	{
	    bu_log( "f4_Add_bot_face: ignoring degenerate triangle in group %d component %d\n", group_id, comp_id );
	    return;
	}

    if( pos == 0 )	/* use default */
	pos = POS_FRONT;

    if( mode == PLATE_MODE )
	{
	    if( pos != POS_CENTER && pos != POS_FRONT )
		{
		    bu_log( "f4_Add_bot_face: illegal postion parameter (%d), must be one or two (ignoring face for group %d component %d)\n" , pos, group_id, comp_id );
		    return;
		}
	}

    if( face_count >= face_size )
	{
	    face_size += GRID_BLOCK;
	    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted before realloc of faces, thickness, and facemode\n" );
	    faces = (int *)bu_realloc( (void *)faces,  face_size*3*sizeof( int ), "faces" );
	    thickness = (fastf_t *)bu_realloc( (void *)thickness, face_size*sizeof( fastf_t ), "thickness" );
	    facemode = (char *)bu_realloc( (void *)facemode, face_size*sizeof( char ), "facemode" );
	    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted after realloc of faces, thickness, and facemode\n" );
	}

    faces[face_count*3] = pt1;
    faces[face_count*3+1] = pt2;
    faces[face_count*3+2] = pt3;

    if( mode == PLATE_MODE )
	{
	    thickness[face_count] = thick;
	    facemode[face_count] = pos;
	}
    else
	{
	    thickness[face_count] = 0,0;
	    facemode[face_count] = 0;
	}

    face_count++;

    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
	bu_log( "memory corrupted at end of f4_Add_bot_face()\n" );
}


static void
f4_do_tri(void)
{
    int element_id;
    int pt1,pt2,pt3;
    fastf_t thick;
    int pos;

    if( debug )
	bu_log( "f4_do_tri: %s\n" , line );

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    if( !bot )
	bot = element_id;

    if( !pass )
	return;

    if( faces == NULL )
	{
	    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted before malloc of faces\n" );
	    faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
	    thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
	    facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
	    face_size = GRID_BLOCK;
	    face_count = 0;
	    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted after malloc of faces , thickness, and facemode\n" );
	}

    strncpy( field , &line[24] , 8 );
    pt1 = atoi( field );

    strncpy( field , &line[32] , 8 );
    pt2 = atoi( field );

    strncpy( field , &line[40] , 8 );
    pt3 = atoi( field );

    thick = 0.0;
    pos = 0;

    if( mode == PLATE_MODE )
	{
	    strncpy( field , &line[56] , 8 );
	    thick = atof( field ) * 25.4;

	    strncpy( field , &line[64] , 8 );
	    pos = atoi( field );
	    if( pos == 0 )
		pos = POS_FRONT;

	    if( debug )
		bu_log( "\tplate mode: thickness = %f\n" , thick );

	}

    if( f4_do_plot )
	plot_tri( pt1, pt2, pt3 );

    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
	bu_log( "memory corrupted before call to f4_Add_bot_face()\n" );

    f4_Add_bot_face( pt1, pt2, pt3, thick, pos );

    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
	bu_log( "memory corrupted after call to f4_Add_bot_face()\n" );
}


static void
f4_do_quad(void)
{
    int element_id;
    int pt1,pt2,pt3,pt4;
    fastf_t thick = 0.0;
    int pos = 0;

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    if( debug )
	bu_log( "f4_do_quad: %s\n" , line );

    if( !bot )
	bot = element_id;

    if( !pass )
	return;

    if( faces == NULL )
	{
	    faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
	    thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
	    facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
	    face_size = GRID_BLOCK;
	    face_count = 0;
	}

    strncpy( field , &line[24] , 8 );
    pt1 = atoi( field );

    strncpy( field , &line[32] , 8 );
    pt2 = atoi( field );

    strncpy( field , &line[40] , 8 );
    pt3 = atoi( field );

    strncpy( field , &line[48] , 8 );
    pt4 = atoi( field );

    if( mode == PLATE_MODE )
	{
	    strncpy( field , &line[56] , 8 );
	    thick = atof( field ) * 25.4;

	    strncpy( field , &line[64] , 8 );
	    pos = atoi( field );

	    if( pos == 0 )	/* use default */
		pos = POS_FRONT;

	    if( pos != POS_CENTER && pos != POS_FRONT )
		{
		    bu_log( "f4_do_quad: illegal postion parameter (%d), must be one or two\n" , pos );
		    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		    return;
		}
	}

    f4_Add_bot_face( pt1, pt2, pt3, thick, pos );
    f4_Add_bot_face( pt1, pt3, pt4, thick, pos );
}


static void
make_bot_object(void)
{
    int i;
    int max_pt = 0;
    int min_pt = 999999;
    int num_vertices;
    struct bu_bitv *bv = (struct bu_bitv *)NULL;
    int bot_mode;
    char *name = (char *)NULL;
    int element_id = bot;
    int count;
    struct rt_bot_internal bot_ip;

    if( !pass )
	{
	    make_region_name( group_id , comp_id );
	    return;
	}

    bot_ip.magic = RT_BOT_INTERNAL_MAGIC;
    for( i=0 ; i<face_count ; i++ )
	{
	    V_MIN( min_pt, faces[i*3] );
	    V_MAX( max_pt, faces[i*3] );
	    V_MIN( min_pt, faces[i*3+1] );
	    V_MAX( max_pt, faces[i*3+1] );
	    V_MIN( min_pt, faces[i*3+2] );
	    V_MAX( max_pt, faces[i*3+2] );
	}

    num_vertices = max_pt - min_pt + 1;
    bot_ip.num_vertices = num_vertices;
    bot_ip.vertices = (fastf_t *)bu_calloc( num_vertices*3, sizeof( fastf_t ), "BOT vertices" );
    for( i=0 ; i<num_vertices ; i++ )
	VMOVE( &bot_ip.vertices[i*3], grid_points[min_pt+i] )

	    for( i=0 ; i<face_count*3 ; i++ )
		faces[i] -= min_pt;
    bot_ip.num_faces = face_count;
    bot_ip.faces = bu_calloc( face_count*3, sizeof( int ), "BOT faces" );
    for( i=0 ; i<face_count*3 ; i++ )
	bot_ip.faces[i] = faces[i];

    bot_ip.face_mode = (struct bu_bitv *)NULL;
    bot_ip.thickness = (fastf_t *)NULL;
    if( mode == PLATE_MODE )
	{
	    bot_mode = RT_BOT_PLATE;
	    bv = bu_bitv_new( face_count );
	    bu_bitv_clear( bv );
	    for( i=0 ; i<face_count ; i++ )
		{
		    if( facemode[i] == POS_FRONT )
			BU_BITSET( bv, i );
		}
	    bot_ip.face_mode = bv;
	    bot_ip.thickness = (fastf_t *)bu_calloc( face_count, sizeof( fastf_t ), "BOT thickness" );
	    for( i=0 ; i<face_count ; i++ )
		bot_ip.thickness[i] = thickness[i];
	}
    else
	bot_mode = RT_BOT_SOLID;

    bot_ip.mode = bot_mode;
    bot_ip.orientation = RT_BOT_UNORIENTED;
    bot_ip.bot_flags = 0;

    count = rt_bot_vertex_fuse( &bot_ip );
    if( count )
	(void)rt_bot_condense( &bot_ip );

    count = rt_bot_face_fuse( &bot_ip );
    if( count )
	bu_log( "WARNING: %d duplicate faces eliminated from group %d component %d\n", count, group_id, comp_id );

    name = make_solid_name( BOT , element_id , comp_id , group_id , 0 );
    mk_bot( fdout, name, bot_mode, RT_BOT_UNORIENTED, 0, bot_ip.num_vertices, bot_ip.num_faces, bot_ip.vertices,
	    bot_ip.faces, bot_ip.thickness, bot_ip.face_mode );
    bu_free( name, "solid_name" );

    if( mode == PLATE_MODE )
	{
	    bu_free( (char *)bot_ip.thickness, "BOT thickness" );
	    bu_free( (char *)bot_ip.face_mode, "BOT face_mode" );
	}
    bu_free( (char *)bot_ip.vertices, "BOT vertices" );
    bu_free( (char *)bot_ip.faces, "BOT faces" );

}


static void
skip_section(void)
{
    long section_start;

    /* skip to start of next section */
    section_start = ftell( fdin );
    if( get_line() )
	{
	    while( line[0] && strncmp( line, "SECTION" , 7 ) &&
		   strncmp( line, "HOLE", 4 ) &&
		   strncmp( line, "WALL", 4 ) &&
		   strncmp( line, "VEHICLE", 7 ) )
		{
		    section_start = ftell( fdin );
		    if( !get_line() )
			break;
		}
	}
    /* seek to start of the section */
    fseek( fdin, section_start, SEEK_SET );
}


/*	cleanup from previous component and start a new one.
 *	This is called with final == 1 when ENDDATA is found
 */
static void
f4_do_section(int final)
{
    int found;
    struct name_tree *nm_ptr;

    if( debug )
	bu_log( "f4_do_section(%d): %s\n", final , line );

    if( pass )	/* doing geometry */
	{
	    if( region_id && !skip_region( region_id ) )
		{
		    comp_count++;

		    if( bot )
			make_bot_object();
		}
	    if( final && debug ) /* The ENDATA card has been found */
		List_names();
	}
    else if( bot )
	{
	    make_region_name( group_id , comp_id );
	}

    if( !final )
	{
	    strncpy( field , &line[8] , 8 );
	    group_id = atoi( field );

	    strncpy( field , &line[16] , 8 );
	    comp_id = atoi( field );

	    region_id = group_id * 1000 + comp_id;

	    if( skip_region( region_id ) ) /* do not process this component */
		{
		    skip_section();
		    return;
		}

	    if( comp_id > 999 )
		{
		    bu_log( "Illegal component id number %d, changed to 999\n" , comp_id );
		    comp_id = 999;
		}

	    strncpy( field , &line[24] , 8 );
	    mode = atoi( field );
	    if( mode != 1 && mode != 2 )
		{
		    bu_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
			    mode, group_id, comp_id );
		    mode = 2;
		}

	    if( !pass )
		{
		    nm_ptr = Search_ident( name_root, region_id, &found );
		    if( found && nm_ptr->mode != mode ) {
			bu_log( "ERROR: second SECTION card found with different mode for component (group=%d, component=%d), conversion of this component will be incorrect!\n",
				group_id, comp_id );
		    }
		}
	}

    bot = 0;
    face_count = 0;
}


static void
f4_do_hex1(void)
{
    fastf_t thick=0.0;
    int pos;
    int pts[8];
    int element_id;
    int i;
    int cont1,cont2;

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    if( !bot )
	bot = element_id;

    if( !pass )
	{
	    if( !get_line() )
		{
		    bu_log( "Unexpected EOF while reading continuation card for CHEX1\n" );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    bu_exit(1, "ERROR: unexpected end-of-file encountered\n");
		}
	    return;
	}

    if( faces == NULL )
	{
	    faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
	    thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
	    facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
	    face_size = GRID_BLOCK;
	    face_count = 0;
	}

    for( i=0 ; i<6 ; i++ )
	{
	    strncpy( field , &line[24 + i*8] , 8 );
	    pts[i] = atoi( field );
	}

    strncpy( field , &line[72] , 8 );
    cont1 = atoi( field );

    if( !get_line() )
	{
	    bu_log( "Unexpected EOF while reading continuation card for CHEX1\n" );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
		    group_id, comp_id, element_id , cont1 );
	    bu_exit(1, "ERROR: unexpected end-of-file encountered\n");
	}

    strncpy( field , line , 8 );
    cont2 = atoi( field );

    if( cont1 != cont2 )
	{
	    bu_log( "Continuation card numbers do not match for CHEX1 element (%d vs %d)\n", cont1 , cont2 );
	    bu_log( "\tskipping CHEX1 element: group_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	    return;
	}

    strncpy( field , &line[8] , 8 );
    pts[6] = atoi( field );

    strncpy( field , &line[16] , 8 );
    pts[7] = atoi( field );

    if( mode == PLATE_MODE )
	{
	    strncpy( field , &line[56] , 8 );
	    thick = atof( field ) * 25.4;
	    if( thick <= 0.0 )
		{
		    bu_log( "f4_do_hex1: illegal thickness (%f), skipping CHEX1 element\n" , thick );
		    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		    return;
		}

	    strncpy( field , &line[64] , 8 );
	    pos = atoi( field );

	    if( pos == 0 )	/* use default */
		pos = POS_FRONT;

	    if( pos != POS_CENTER && pos != POS_FRONT )
		{
		    bu_log( "f4_do_hex1: illegal postion parameter (%d), must be 1 or 2, skipping CHEX1 element\n" , pos );
		    bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		    return;
		}
	}
    else
	{
	    pos =  POS_FRONT;
	    thick = 0.0;
	}

    for( i=0 ; i<12 ; i++ )
	f4_Add_bot_face( pts[hex_faces[i][0]], pts[hex_faces[i][1]], pts[hex_faces[i][2]], thick, pos );
}


static void
f4_do_hex2(void)
{
    int pts[8];
    int element_id;
    int i;
    int cont1,cont2;
    point_t points[8];
    char *name = (char *)NULL;

    strncpy( field , &line[8] , 8 );
    element_id = atoi( field );

    if( !pass )
	{
	    make_region_name( group_id , comp_id );
	    if( !get_line() )
		{
		    bu_log( "Unexpected EOF while reading continuation card for CHEX2\n" );
		    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			    group_id, comp_id, element_id );
		    bu_exit(1, "ERROR: unexpected end-of-file encountered\n");
		}
	    return;
	}

    for( i=0 ; i<6 ; i++ )
	{
	    strncpy( field , &line[24 + i*8] , 8 );
	    pts[i] = atoi( field );
	}

    strncpy( field , &line[72] , 8 );
    cont1 = atoi( field );

    if( !get_line() )
	{
	    bu_log( "Unexpected EOF while reading continuation card for CHEX2\n" );
	    bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
		    group_id, comp_id, element_id , cont1 );
	    bu_exit(1, "ERROR: unexpected end-of-file encountered\n");
	}

    strncpy( field , line , 8 );
    cont2 = atoi( field );

    if( cont1 != cont2 )
	{
	    bu_log( "Continuation card numbers do not match for CHEX2 element (%d vs %d)\n", cont1 , cont2 );
	    bu_log( "\tskipping CHEX2 element: group_id = %d, comp_id = %d, element_id = %d\n",
		    group_id, comp_id, element_id );
	    return;
	}

    strncpy( field , &line[8] , 8 );
    pts[6] = atoi( field );

    strncpy( field , &line[16] , 8 );
    pts[7] = atoi( field );

    for( i=0 ; i<8 ; i++ )
	VMOVE( points[i] , grid_points[pts[i]] );

    name = make_solid_name( CHEX2 , element_id , comp_id , group_id , 0 );
    mk_arb8( fdout , name , &points[0][X] );
    bu_free( name, "solid_name" );

}


static void
Process_hole_wall(void)
{
    if( debug )
	bu_log( "Process_hole_wall\n" );
    if( bu_debug & BU_DEBUG_MEM_CHECK )
	bu_prmem( "At start of Process_hole_wall:" );

    rewind( fdin );
    while( 1 )
	{
	    if( !strncmp( line , "HOLE" , 4 ) )
		f4_do_hole_wall( HOLE );
	    else if( !strncmp( line , "WALL" , 4 ) )
		f4_do_hole_wall( WALL );
	    else if( !strncmp( line , "COMPSPLT", 8 ) )
		f4_do_compsplt();
	    else if( !strncmp( line, "SECTION", 7 ) )
		{
		    strncpy( field , &line[24] , 8 );
		    mode = atoi( field );
		    if( mode != 1 && mode != 2 )
			{
			    bu_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
				    mode, group_id, comp_id );
			    mode = 2;
			}
		}
	    else if( !strncmp( line , "ENDDATA" , 7 ) )
		break;

	    if( !get_line() || !line[0] )
		break;
	}

    if( debug )
	{
	    bu_log( "At end of Process_hole_wall:\n" );
	    List_holes();
	}
}


static void
f4_do_chgcomp(void)
{

    if( !pass )
	return;

    if( !fd_muves )
	return;

    fprintf( fd_muves, "%s", line );
}


static void
f4_do_cbacking(void)
{
    int gr1, co1, gr2, co2, material;
    fastf_t thickness, probability;

    if( !pass )
	return;

    if( !fd_muves )
	return;

    strncpy( field, &line[8], 8 );
    gr1 = atoi( field );

    strncpy( field, &line[16], 8 );
    co1 = atoi( field );

    strncpy( field, &line[24], 8 );
    gr2 = atoi( field );

    strncpy( field, &line[32], 8 );
    co2 = atoi( field );

    strncpy( field, &line[40], 8 );
    thickness = atof( field ) * 25.4;

    strncpy( field, &line[48], 8 );
    probability = atof( field );

    strncpy( field, &line[56], 8 );
    material = atoi( field );

    fprintf( fd_muves, "CBACKING %d %d %g %g %d\n", gr1*1000+co1, gr2*1000+co2, thickness, probability, material );
}


static int
Process_input(int pass_number)
{

    if( debug )
	bu_log( "\n\nProcess_input( pass = %d )\n" , pass_number );
    if( bu_debug & BU_DEBUG_MEM_CHECK )
	bu_prmem( "At start of Process_input:" );

    if( pass_number != 0 && pass_number != 1 )
	{
	    bu_exit(1, "Process_input: illegal pass number %d\n" , pass_number);
	}

    region_id = 0;
    pass = pass_number;
    if( !get_line() || !line[0] )
	strcpy( line, "ENDDATA" );
    while( 1 )
	{
	    if( !strncmp( line , "VEHICLE" , 7 ) )
		f4_do_vehicle();
	    else if( !strncmp( line , "HOLE" , 4 ) )
		;
	    else if( !strncmp( line , "WALL" , 4 ) )
		;
	    else if( !strncmp( line , "COMPSPLT", 8 ) )
		;
	    else if( !strncmp( line, "CBACKING", 8 ) )
		f4_do_cbacking();
	    else if( !strncmp( line, "CHGCOMP", 7 ) )
		f4_do_chgcomp();
	    else if( !strncmp( line , "SECTION" , 7 ) )
		f4_do_section( 0 );
	    else if( !strncmp( line , "$NAME" , 5 ) )
		f4_do_name();
	    else if( !strncmp( line , "$COMMENT" , 8 ) )
		;
	    else if( !strncmp( line , "GRID" , 4 ) )
		f4_do_grid();
	    else if( !strncmp( line , "CLINE" , 5 ) )
		f4_do_cline();
	    else if( !strncmp( line , "CHEX1" , 5 ) )
		f4_do_hex1();
	    else if( !strncmp( line , "CHEX2" , 5 ) )
		f4_do_hex2();
	    else if( !strncmp( line , "CTRI" , 4 ) )
		f4_do_tri();
	    else if( !strncmp( line , "CQUAD" , 5 ) )
		f4_do_quad();
	    else if( !strncmp( line , "CCONE1" , 6 ) )
		f4_do_ccone1();
	    else if( !strncmp( line , "CCONE2" , 6 ) )
		f4_do_ccone2();
	    else if( !strncmp( line , "CCONE3" , 6 ) )
		f4_do_ccone3();
	    else if( !strncmp( line , "CSPHERE" , 7 ) )
		f4_do_sphere();
	    else if( !strncmp( line , "ENDDATA" , 7 ) )
		{
		    f4_do_section( 1 );
		    break;
		}
	    else
		bu_log( "ERROR: skipping unrecognized data type\n%s\n" , line );

	    if( !get_line() || !line[0] )
		strcpy( line, "ENDDATA" );
	}

    if( debug )
	{
	    bu_log( "At pass %d:\n" , pass );
	    List_names();
	}

    return( 0 );
}


/* This routine is called for each combination in the model (via db_functree).
 * It looks for regions that consist of only one member. If that one member
 * is a combination, then the tree from that combination is placed in the
 * region (eliminating an extra, unnecessary redirection).
 */
static void
fix_regions(struct db_i *dbip, struct directory *dp, genptr_t ptr)
{
    struct rt_db_internal   internal;
    struct rt_db_internal	internal2;
    struct directory	*dp2 = (struct directory *)NULL;
    struct rt_comb_internal *comb = (struct rt_comb_internal *)NULL;
    struct rt_comb_internal *comb2 = (struct rt_comb_internal *)NULL;
    union tree		*tree = (union tree *)NULL;
    union tree		*tree2 = (union tree *)NULL;

    /* only process regions */
    if( !(dp->d_flags & DIR_REGION) )
	return;

    if( rt_db_get_internal( &internal, dp, dbip, NULL, &rt_uniresource ) < 0 )
	{
	    bu_exit(1, "ERROR: Failed to get internal representation of %s\n", dp->d_namep);
	}

    if( internal.idb_type != ID_COMBINATION )
	{
	    bu_exit(1, "ERROR: In fix_regions: [%s] is not a combination!\n", dp->d_namep);
	}

    comb = (struct rt_comb_internal *)internal.idb_ptr;
    if( !comb->region_flag )
	{
	    bu_exit(1, "ERROR: %s is not a region!\n", dp->d_namep);
	}
    RT_CK_COMB( comb );
    tree = comb->tree;

    if( tree->tr_op != MKOP(12) )
	{
	    rt_db_free_internal( &internal , &rt_uniresource);
	    return;
	}

    /* only one element in tree */

    if( (dp2=db_lookup( dbip, tree->tr_l.tl_name, 0 )) == DIR_NULL )
	{
	    bu_log( "Could not find %s\n", tree->tr_l.tl_name );
	    rt_db_free_internal( &internal , &rt_uniresource);
	    return;
	}

    if( rt_db_get_internal( &internal2, dp2, dbip, NULL, &rt_uniresource ) < 0 )
	{
	    bu_exit(1, "ERROR: Failed to get internal representation of %s\n", dp2->d_namep );
	}

    if( internal2.idb_type != ID_COMBINATION )
	{
	    rt_db_free_internal( &internal , &rt_uniresource);
	    rt_db_free_internal( &internal2 , &rt_uniresource);
	    return;
	}

    comb2 = (struct rt_comb_internal *)internal2.idb_ptr;
    RT_CK_COMB( comb2 );

    if( debug )
	bu_log( "Fixing region %s\n", dp->d_namep );

    /* move the second tree into the first */
    tree2 = comb2->tree;
    comb->tree = tree2;
    if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )
	{
	    bu_exit(1, "ERROR: Failed to write region %s\n", dp->d_namep );
	}

    /* now kill the second combination */
    db_delete( dbip, dp2 );
    db_dirdelete( dbip, dp2 );

    db_free_tree( tree , &rt_uniresource);

}


static void
Post_process(char *output_file)
{
    struct db_i *dbip = (struct db_i *)NULL;
    struct directory *dp = (struct directory *)NULL;

    bu_log( "Cleaning up please wait.....\n" );

    if ((dbip = db_open( output_file , "rw")) == DBI_NULL)
	{
	    bu_log( "Cannot open %s, post processing not completed\n", output_file );
	    return;
	}

    if( debug )
	bu_log( "Rescanning file\n" );

    db_dirbuild( dbip );

    if( debug )
	bu_log( "looking up 'all'\n" );

    if( (dp=db_lookup( dbip, "all", 0 )) == DIR_NULL )
	{
	    bu_log( "Cannot find group 'all' in model, post processing not completed\n" );
	    db_close( dbip );
	    return;
	}

    if( debug )
	bu_log( "Calling db_functree\n" );

    db_functree( dbip, dp, fix_regions, 0, &rt_uniresource, NULL );

    if( debug )
	bu_log( "Post-processing complete\n" );
}


static void
make_region_list(char *str)
{
    char *ptr, *ptr2;

    region_list = (int *)bu_calloc( REGION_LIST_BLOCK, sizeof( int ), "region_list" );
    region_list_len = REGION_LIST_BLOCK;
    f4_do_skips = 0;

    ptr = strtok( str, "," );
    while( ptr )
	{
	    if( (ptr2=strchr( ptr, '-')) )
		{
		    int i, start, stop;

		    *ptr2 = '\0';
		    ptr2++;
		    start = atoi( ptr );
		    stop = atoi( ptr2 );
		    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list\n" );
		    for( i=start ; i<=stop ; i++ )
			{
			    if( f4_do_skips == region_list_len )
				{
				    region_list_len += REGION_LIST_BLOCK;
				    region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
				    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list (after realloc)\n" );
				}
			    region_list[f4_do_skips++] = i;
			    if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
				bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list (after adding %d)\n", i );
			}
		}
	    else
		{
		    if( f4_do_skips == region_list_len )
			{
			    region_list_len += REGION_LIST_BLOCK;
			    region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
			}
		    region_list[f4_do_skips++] = atoi( ptr );
		}
	    ptr = strtok( (char *)NULL, "," );
	}
}


static void
make_regions(void)
{
    struct name_tree *ptr1, *ptr2;
    struct holes *hptr;
    struct hole_list *lptr;
    struct compsplt *splt;
    struct wmember region;
    struct wmember solids;
    struct wmember holes;
    char reg_name[LINELEN] = {0};
    char solids_name[LINELEN] = {0};
    char hole_name[LINELEN] = {0};
    char splt_name[LINELEN] = {0};

    BU_LIST_INIT( &holes.l );

    /* loop through the list of region names (by ident) */
    bu_ptbl_reset( &stack );
    ptr1 = name_root;
    while( 1 )
	{
	    while( ptr1 )
		{
		    PUSH( ptr1 );
		    ptr1 = ptr1->rleft;
		}
	    POP( name_tree, ptr1 );
	    if( !ptr1 )
		break;

	    /* check if we are skipping some regions (but we might need all the holes) */
	    if( skip_region( ptr1->region_id ) && !is_a_hole( ptr1->region_id ) )
		goto cont1;

	    /* place all the solids for this ident in a "solids" combination */
	    BU_LIST_INIT( &solids.l );
	    bu_ptbl_reset( &stack2 );
	    ptr2 = name_root;
	    while( 1 )
		{
		    while( ptr2 )
			{
			    PUSH2( ptr2 );
			    ptr2 = ptr2->nleft;
			}
		    POP2( name_tree, ptr2 );
		    if( !ptr2 )
			break;

		    if( ptr2->region_id == -ptr1->region_id && ptr2->inner == 0 )
			{
			    if( mk_addmember( ptr2->name, &solids.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", ptr1->name, ptr2->name );
			}

		    ptr2 = ptr2->nright;
		}

	    if( BU_LIST_IS_EMPTY( &solids.l ) )
		goto cont1;

	    snprintf( solids_name, LINELEN, "solids_%d.s", ptr1->region_id );
	    if( mk_comb( fdout, solids_name, &solids.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1) )
		bu_log("Failed to make combination of solids (%s)!\n\tRegion %s is in ERROR!\n",
		       solids_name, ptr1->name );

	    /* hole components do not get made into regions */
	    if( is_a_hole( ptr1->region_id ) )
		{
		    /* just add it to the "holes" group */
		    if( mk_addmember( solids_name, &holes.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_log( "make_regions: mk_addmember failed to add %s to holes group\n", ptr1->name );
		    goto cont1;
		}

	    hptr = hole_root;
	    while( hptr && hptr->group * 1000 + hptr->component != ptr1->region_id )
		hptr = hptr->next;
	    if( hptr )
		lptr = hptr->holes;
	    else
		lptr = (struct hole_list *)NULL;

	    splt = compsplt_root;
	    while( splt && splt->ident_to_split != ptr1->region_id )
		splt = splt->next;

	    mode = ptr1->mode;
	    if( debug )
		bu_log( "Build region for %s %d, mode = %d\n", ptr1->name, ptr1->region_id, mode );

	    if( splt )
		{
		    vect_t norm;
		    struct name_tree *ptr2;
		    int found;

		    /* make a halfspace */
		    VSET( norm, 0.0, 0.0, 1.0 );
		    snprintf( splt_name, LINELEN, "splt_%d.s", ptr1->region_id );
		    mk_half( fdout, splt_name, norm, splt->z );

		    /* intersect halfspace with current region */
		    BU_LIST_INIT( &region.l );
		    if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );

		    if( mk_addmember( splt_name, &region.l, NULL, WMOP_INTERSECT ) == (struct wmember *)NULL )
			bu_log( "make_regions: mk_addmember failed to add %s to %s\n", splt_name, ptr1->name );

		    while( lptr )
			{
			    snprintf( hole_name, LINELEN, "solids_%d.s", (lptr->group * 1000 + lptr->component) );
			    if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
			    lptr = lptr->next;
			}
		    MK_REGION( fdout, &region, ptr1->name, ptr1->region_id, get_fast4_color(ptr1->region_id) )

			/* create new region by subtracting halfspace */
			BU_LIST_INIT( &region.l );
		    if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );

		    if( mk_addmember( splt_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
			bu_log( "make_regions: mk_addmember failed to add %s to %s\n", splt_name, ptr1->name );

		    while( lptr )
			{
			    snprintf( hole_name, LINELEN, "solids_%d.s", (lptr->group * 1000 + lptr->component) );
			    if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
			    lptr = lptr->next;
			}
		    ptr2 = Search_ident( name_root, splt->new_ident, &found );
		    if( found ) {
			MK_REGION( fdout, &region, ptr2->name, splt->new_ident, get_fast4_color(splt->new_ident) )
			    } else {
				sprintf( reg_name, "comp_%d.r", splt->new_ident );
				MK_REGION( fdout, &region, reg_name, splt->new_ident, get_fast4_color(splt->new_ident) )
				    }
		}
	    else
		{
		    BU_LIST_INIT( &region.l );
		    if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );

		    while( lptr )
			{
			    snprintf( hole_name, LINELEN, "solids_%d.s", (lptr->group * 1000 + lptr->component) );
			    if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
			    lptr = lptr->next;
			}
		    MK_REGION( fdout, &region, ptr1->name, ptr1->region_id, get_fast4_color(ptr1->region_id) )
			}
	cont1:
	    ptr1 = ptr1->rright;
	}

    if( BU_LIST_NON_EMPTY( &holes.l ) )
	{
	    /* build a "holes" group */
	    if( mk_comb( fdout, "holes", &holes.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1) )
		bu_log("Failed to make holes group!\n" );
	}
}


#define COLOR_LINE_LEN 256

static void
read_fast4_colors(char *color_file)
{
    FILE *fp;
    char line[COLOR_LINE_LEN] = {0};
    int low, high;
    int r, g, b;
    struct fast4_color *color;

    if ((fp = fopen(color_file, "r")) == (FILE *)NULL) {
	bu_log("Cannot open color file (%s)\n", color_file);
	return;
    }

    while (bu_fgets(line, COLOR_LINE_LEN, fp) != NULL) {
	if (sscanf(line, "%d %d %d %d %d", &low, &high, &r, &g, &b) != 5)
	    continue;

	/* skip invalid colors */
	if (r < 0 || 255 < r ||
	    g < 0 || 255 < g ||
	    b < 0 || 255 < b)
	    continue;

	/* skip bad region id ranges */
	if (high < low)
	    continue;

	BU_GETSTRUCT(color, fast4_color);
	color->low = low;
	color->high = high;
	color->rgb[0] = r;
	color->rgb[1] = g;
	color->rgb[2] = b;
	BU_LIST_APPEND(&HeadColor.l, &color->l);
    }
}


int
main(int argc, char **argv)
{
    int i;
    int c;
    char *plot_file=NULL;
    char *color_file=NULL;

    while( (c=bu_getopt( argc , argv , "qm:o:c:dwx:b:X:C:" ) ) != EOF )
	{
	    switch( c )
		{
		    case 'q':	/* quiet mode */
			quiet = 1;
			break;
		    case 'm':
			if( (fd_muves=fopen( bu_optarg, "w" )) == (FILE *)NULL )
			    {
				bu_log( "Unable to open MUVES file (%s)\n\tno MUVES file created\n",
					bu_optarg );
			    }
			break;
		    case 'o':	/* output a plotfile of original FASTGEN4 elements */
			f4_do_plot = 1;
			plot_file = bu_optarg;
			break;
		    case 'c':	/* convert only the specified components */
			make_region_list( bu_optarg );
			break;
		    case 'd':	/* debug option */
			debug = 1;
			break;
		    case 'w':	/* print warnings */
			warnings = 1;
			break;
		    case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_debug );
			bu_debug = rt_debug;
			break;
		    case 'b':
			sscanf( bu_optarg, "%x", (unsigned int *)&bu_debug );
			break;
		    case 'C':
			color_file = bu_optarg;
			break;
		    default:
			bu_log( "Unrecognzed option (%c)\n", c );
			bu_exit(1, usage);
			break;
		}
	}

    if( bu_debug & BU_DEBUG_MEM_CHECK )
	bu_log( "doing memory checking\n" );

    if( argc-bu_optind != 2 ) {
	bu_exit(1, usage);
    }

    rt_init_resource( &rt_uniresource, 0, NULL );

    if( (fdin=fopen( argv[bu_optind] , "r" )) == (FILE *)NULL )
	{
	    perror( "fast4-g" );
	    bu_exit(1, "Cannot open FASTGEN4 file (%s)\n" , argv[bu_optind]);
	}

    if( (fdout=wdb_fopen( argv[bu_optind+1] )) == NULL )
	{
	    perror( "fast4-g" );
	    bu_exit(1, "Cannot open file for output (%s)\n" , argv[bu_optind+1]);
	}

    if( plot_file )
	{
	    if( (fd_plot=fopen( plot_file, "w")) == NULL )
		{
		    bu_log( "Cannot open plot file (%s)\n", plot_file );
		    bu_exit(1, usage);
		}
	}

    if(bu_debug )
	{
	    bu_printb( "librtbu_debug",bu_debug, DEBUG_FORMAT );
	    bu_log("\n");
	}
    if( rt_g.NMG_debug )
	{
	    bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
	    bu_log("\n");
	}

    BU_LIST_INIT(&HeadColor.l);
    if (color_file)
	read_fast4_colors(color_file);

    grid_size = GRID_BLOCK;
    grid_points = (point_t *)bu_malloc( grid_size * sizeof( point_t ) , "fast4-g: grid_points" );

    cline_root = (struct cline *)NULL;

    name_root = (struct name_tree *)NULL;

    hole_root = (struct holes *)NULL;

    compsplt_root = (struct compsplt *)NULL;

    min_radius = 2.0 * sqrt( SQRT_SMALL_FASTF );

    name_count = 0;

    vehicle[0] = '\0';

    bu_ptbl_init( &stack , 64, " &stack ");
    bu_ptbl_init( &stack2 , 64, " &stack2 ");

    for( i=0 ; i<11 ; i++ )
	BU_LIST_INIT( &group_head[i].l );

    BU_LIST_INIT( &hole_head.l );

    if( !quiet )
	bu_log( "Scanning for HOLE, WALL, and COMPLSPLT cards...\n" );

    Process_hole_wall();

    rewind( fdin );

    if( !quiet )
	bu_log( "Building component names....\n" );

    Process_input( 0 );

    rewind( fdin );

    /* Make an ID record if no vehicle card was found */
    if( !vehicle[0] )
	mk_id_units( fdout , argv[bu_optind] , "in" );

    if( !quiet )
	bu_log( "Building components....\n" );

    while( Process_input( 1 ) );

    if( !quiet )
	bu_log( "Building regions and groups....\n" );

    /* make regions */
    make_regions();

    /* make groups */
    f4_do_groups();

    if( debug )
	List_holes();

    wdb_close( fdout );

    if( !quiet )
	bu_log( "%d components converted\n", comp_count );

    return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.22
log
@first 10% of the review of the bu_bomb() instances.  updating many to bu_exit() for the instances where the error or exit condition aren't catastrophic errors (i.e. they wouldn't benefit from having a stack trace of how we got into that state code-wise).  this also makes it easier to refactor usages of log & exit too to the new routine.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.21 2007/09/15 16:23:04 brlcad Exp $";
d268 1
a268 1
    bzero( (void *)line , LINELEN );
@


14.21
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.20 2007/09/14 15:21:03 erikgreenwald Exp $";
d81 1
a81 1
	bu_log( "\tRegion not made!!!!!\n");\
d539 1
a539 1
	    bu_bomb( "\tCannot insert new node\n" );
d566 1
a566 1
			    bu_bomb( "\tCannot insert new node\n" );
d575 1
a575 1
			    bu_bomb( "\tCannot insert new node\n" );
d588 1
a588 1
			    bu_bomb( "\tCannot insert new node\n" );
d597 1
a597 1
			    bu_bomb( "\tCannot insert new node\n" );
d736 1
a736 1
		    bu_bomb( "\tCannot insert new node\n" );
d745 1
a745 1
		    bu_bomb( "\tCannot insert new node\n" );
d846 1
a846 1
					bu_bomb( "Subtract_holes: mk_addmember failed\n" );
d1079 1
a1079 2
	    bu_log( "name (%s) deleted from name tree, but not found in ident tree!!\n" , name );
	    bu_bomb( "Delete_name\n" );
d1084 1
a1084 2
	    bu_log( "name (%s) is root of ident tree, but not name tree!!\n" , name );
	    bu_bomb( "Delete_name\n" );
d1362 1
a1362 2
	    bu_log( "ERROR: grid id number = %d\n" , grid_no );
	    bu_bomb( "BAD GRID ID NUMBER\n" );
d1448 1
a1448 2
		    bu_log( "f4_do_sphere: Error in adding %s to sphere group\n" , name );
		    bu_bomb( "f4_do_sphere" );
d1465 1
a1465 2
		    bu_log( "f4_do_sphere: Error in subtracting %s from sphere region\n" , name );
		    bu_bomb( "f4_do_sphere" );
d1574 1
a1574 1
		    bu_bomb( "CCONE1\n" );
d1599 1
a1599 1
	    bu_bomb( "CCONE1\n" );
d1694 1
a1694 1
		bu_bomb( "CCONE1: mk_addmember failed\n" );
d1767 1
a1767 1
			bu_bomb( "CCONE1: mk_addmember failed\n" );
d1801 1
a1801 1
		    bu_bomb( "CCONE2\n" );
d1823 1
a1823 1
	    bu_bomb( "CCONE2\n" );
d1883 1
a1883 1
		bu_bomb( "mk_addmember failed!\n" );
d1896 1
a1896 1
		bu_bomb( "mk_addmember failed!\n" );
d1927 1
a1927 1
		    bu_bomb( "CCONE3\n" );
d1951 1
a1951 1
	    bu_bomb( "CCONE3\n" );
d2068 1
a2068 1
			bu_bomb( "mk_addmember failed!\n" );
d2077 1
a2077 1
				bu_bomb( "mk_addmember failed!\n" );
d2093 1
a2093 1
			bu_bomb( "mk_addmember failed!\n" );
d2102 1
a2102 1
				bu_bomb( "mk_addmember failed!\n" );
d2118 1
a2118 1
			bu_bomb( "mk_addmember failed!\n" );
d2127 1
a2127 1
				bu_bomb( "mk_addmember failed!\n" );
d2266 3
a2268 5
    if( type != HOLE && type != WALL )
	{
	    bu_log( "f4_do_hole_wall: unrecognized type (%d)\n", type );
	    bu_bomb( "f4_do_hole_wall: unrecognized type\n" );
	}
d2705 1
a2705 1
			bu_log( "ERROR: second SECTION card found with different mode for component (group=%d, component=%d), conversion of this component will be incorrect!!!\n",
d2739 1
a2739 1
		    bu_bomb( "CHEX1\n" );
d2767 1
a2767 1
	    bu_bomb( "CHEX1\n" );
d2843 1
a2843 1
		    bu_bomb( "CHEX2\n" );
d2862 1
a2862 1
	    bu_bomb( "CHEX2\n" );
d2997 1
a2997 2
	    bu_log( "Process_input: illegal pass number %d\n" , pass_number );
	    bu_bomb( "Process_input" );
d3088 1
a3088 2
	    bu_log( "Failed to get internal representation of %s\n", dp->d_namep );
	    bu_bomb( "rt_db_get_internal() Failed!!!\n" );
d3093 1
a3093 2
	    bu_log( "In fix_regions:%s is not a combination!!!!\n", dp->d_namep );
	    bu_bomb( "Expecting a combination!!!!\n" );
d3099 1
a3099 2
	    bu_log( "%s is not a region!!!!\n", dp->d_namep );
	    bu_bomb( "Expecting a region!!!!\n" );
d3121 1
a3121 2
	    bu_log( "Failed to get internal representation of %s\n", dp2->d_namep );
	    bu_bomb( "rt_db_get_internal() Failed!!!\n" );
d3142 1
a3142 2
	    bu_log( "Failed to write region %s\n", dp->d_namep );
	    bu_bomb( "rt_db_put_internal() failed!!!\n" );
d3307 1
a3307 1
		bu_log("Failed to make combination of solids (%s)!!!!\n\tRegion %s is in ERROR!!!\n",
d3409 1
a3409 1
		bu_log("Failed to make holes group!!!!\n" );
d3502 1
a3502 1
			bu_bomb( usage );
d3511 1
a3511 2
	bu_log( usage );
	exit( 1 );
a3517 1
	    bu_log( "Cannot open FASTGEN4 file (%s)\n" , argv[bu_optind] );
d3519 1
a3519 1
	    exit( 1 );
a3523 1
	    bu_log( "Cannot open file for output (%s)\n" , argv[bu_optind+1] );
d3525 1
a3525 1
	    exit( 1 );
d3533 1
a3533 1
		    bu_bomb( usage );
@


14.20
log
@removed trailing whitespace
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.19 2007/05/18 04:13:43 brlcad Exp $";
a43 1
#ifdef HAVE_STRING_H
a44 3
#else
#include <strings.h>
#endif
@


14.19
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.18 2007/03/07 16:14:16 brlcad Exp $";
d3433 1
a3433 1
static void 
@


14.18
log
@massive restructuring of the code.  functions are defined in visibility order so declarations are unnecessary, functions are made static so they don't collide with librt's similar (but not identical) importFg4Section.c symbols (Add_bot_face, do_trid, do_quad, and do_tri functions; grid_pts variable), rename aforementioned and others with an f4_ prefix just to entirely avoid the naming confusion, reorder macros, defines, static vars, and functions into sections, and of course massive ws update while we're at it.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.17 2007/02/20 08:19:47 brlcad Exp $";
d543 1
a543 1
	    rt_bomb( "\tCannot insert new node\n" );
d570 1
a570 1
			    rt_bomb( "\tCannot insert new node\n" );
d579 1
a579 1
			    rt_bomb( "\tCannot insert new node\n" );
d592 1
a592 1
			    rt_bomb( "\tCannot insert new node\n" );
d601 1
a601 1
			    rt_bomb( "\tCannot insert new node\n" );
d740 1
a740 1
		    rt_bomb( "\tCannot insert new node\n" );
d749 1
a749 1
		    rt_bomb( "\tCannot insert new node\n" );
d850 1
a850 1
					rt_bomb( "Subtract_holes: mk_addmember failed\n" );
d1084 1
a1084 1
	    rt_bomb( "Delete_name\n" );
d1090 1
a1090 1
	    rt_bomb( "Delete_name\n" );
d1369 1
a1369 1
	    rt_bomb( "BAD GRID ID NUMBER\n" );
d1456 1
a1456 1
		    rt_bomb( "f4_do_sphere" );
d1474 1
a1474 1
		    rt_bomb( "f4_do_sphere" );
d1583 1
a1583 1
		    rt_bomb( "CCONE1\n" );
d1608 1
a1608 1
	    rt_bomb( "CCONE1\n" );
d1703 1
a1703 1
		rt_bomb( "CCONE1: mk_addmember failed\n" );
d1776 1
a1776 1
			rt_bomb( "CCONE1: mk_addmember failed\n" );
d1810 1
a1810 1
		    rt_bomb( "CCONE2\n" );
d1832 1
a1832 1
	    rt_bomb( "CCONE2\n" );
d1892 1
a1892 1
		rt_bomb( "mk_addmember failed!\n" );
d1905 1
a1905 1
		rt_bomb( "mk_addmember failed!\n" );
d1936 1
a1936 1
		    rt_bomb( "CCONE3\n" );
d1960 1
a1960 1
	    rt_bomb( "CCONE3\n" );
d2750 1
a2750 1
		    rt_bomb( "CHEX1\n" );
d2778 1
a2778 1
	    rt_bomb( "CHEX1\n" );
d2854 1
a2854 1
		    rt_bomb( "CHEX2\n" );
d2873 1
a2873 1
	    rt_bomb( "CHEX2\n" );
d3009 1
a3009 1
	    rt_bomb( "Process_input" );
d3519 1
a3519 1
			rt_bomb( usage );
@


14.17
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.16 2007/01/27 01:41:32 brlcad Exp $";
d73 137
a209 1
#define		LINELEN		128	/* Length of char array for input line */
d211 1
a211 1
#define		REGION_LIST_BLOCK	256	/* initial length of array of region ids to process */
d234 1
a234 1
static int	do_skips=0;		/* flag indicating that not all components will be processed */
d237 1
a237 1
static int	do_plot=0;		/* flag indicating plot file should be created */
d253 2
a254 1
#define		INT_LIST_BLOCK	256	/* Number of int_list array slots to allocate */
a265 2
#define		PLATE_MODE	1
#define		VOLUME_MODE	2
d267 4
a270 2
#define		POS_CENTER	1	/* face positions for facets */
#define		POS_FRONT	2
d272 1
a272 2
#define		END_OPEN	1	/* End closure codes for cones */
#define		END_CLOSED	2
d274 2
a275 14
#define		GRID_BLOCK	256	/* allocate space for grid points in blocks of 256 points */

#define		CLINE		'l'
#define		CHEX1		'p'
#define		CHEX2		'b'
#define		CTRI		't'
#define		CQUAD		'q'
#define		CCONE1		'c'
#define		CCONE2		'd'
#define		CCONE3		'e'
#define		CSPHERE		's'
#define		NMG		'n'
#define		BOT		't'
#define		COMPSPLT	'h'
d277 4
a280 2
void make_region_name(int g_id, int c_id);
char * make_solid_name(char type, int element_id, int c_id, int g_id, int inner);
d282 6
a287 1
unsigned char *get_fast4_color();
d289 2
a290 6
struct fast4_color {
  struct bu_list l;
  short low;
  short high;
  unsigned char rgb[3];
};
a291 1
struct fast4_color HeadColor;
d293 3
a295 22
/* convenient macro for building regions */
#define	MK_REGION( fp , headp , name , r_id, rgb ) \
			{\
				if( mode == 1 ) {\
					if( !quiet )\
						bu_log( "Making region: %s (PLATE)\n", name ); \
					mk_fastgen_region( fp , name , &((headp)->l) , 'P' ,\
						(char *)NULL, (char *)NULL, rgb, r_id, 0, 0, 0, 0 ); \
				}\
				else if( mode == 2 ) {\
					if( !quiet ) \
						bu_log( "Making region: %s (VOLUME)\n", name ); \
					mk_fastgen_region( fp , name , &((headp)->l) , 'V' ,\
						(char *)NULL, (char *)NULL, rgb, r_id, 0, 0, 0, 0 ); \
				}\
				else\
				{\
					bu_log( "Illegal mode (%d), while trying to make region (%s)\n",\
						mode, name );\
					bu_log( "\tRegion not made!!!!!\n");\
				}\
			}
d297 4
a300 18
#define	PUSH( ptr )	bu_ptbl_ins( &stack , (long *)ptr )
#define POP( structure , ptr )	{ if( BU_PTBL_END( &stack ) == 0 ) \
				ptr = (struct structure *)NULL; \
			  else \
			  { \
				ptr = (struct structure *)BU_PTBL_GET( &stack , BU_PTBL_END( &stack )-1 ); \
				bu_ptbl_rm( &stack , (long *)ptr ); \
			  } \
			}
#define	PUSH2( ptr )	bu_ptbl_ins( &stack2 , (long *)ptr )
#define POP2( structure , ptr )	{ if( BU_PTBL_END( &stack2 ) == 0 ) \
				ptr = (struct structure *)NULL; \
			  else \
			  { \
				ptr = (struct structure *)BU_PTBL_GET( &stack2 , BU_PTBL_END( &stack2 )-1 ); \
				bu_ptbl_rm( &stack2 , (long *)ptr ); \
			  } \
			}
d302 2
a303 25
#define	NHEX_FACES	12
int hex_faces[12][3]={
	{ 0 , 1 , 4 }, /* 1 */
	{ 1 , 5 , 4 }, /* 2 */
	{ 1 , 2 , 5 }, /* 3 */
	{ 2 , 6 , 5 }, /* 4 */
	{ 2 , 3 , 6 }, /* 5 */
	{ 3 , 7 , 6 }, /* 6 */
	{ 3 , 0 , 7 }, /* 7 */
	{ 0 , 4 , 7 }, /* 8 */
	{ 4 , 6 , 7 }, /* 9 */
	{ 4 , 5 , 6 }, /* 10 */
	{ 0 , 1 , 2 }, /* 11 */
	{ 0 , 2 , 3 }  /* 12 */
};

struct cline
{
	int pt1,pt2;
	int element_id;
	int made;
	fastf_t thick;
	fastf_t radius;
	struct cline *next;
} *cline_root;
a304 43
#define	NAME_TREE_MAGIC	0x55555555
#define CK_TREE_MAGIC( ptr )	\
	{\
		if( !ptr )\
			bu_log( "ERROR: Null name_tree pointer, file=%s, line=%d\n", __FILE__, __LINE__ );\
		else if( ptr->magic != NAME_TREE_MAGIC )\
			bu_log( "ERROR: bad name_tree pointer (x%x), file=%s, line=%d\n", ptr, __FILE__, __LINE__ );\
	}

struct name_tree
{
	long magic;
	int region_id;
	int mode;		/* PLATE_MODE or VOLUME_MODE */
	int inner;		/* 0 => this is a base/group name for a FASTGEN element */
	int in_comp_group;	/* > 0 -> region already in a component group */
	char *name;
	struct name_tree *nleft,*nright,*rleft,*rright;
} *name_root;

struct compsplt
{
	int ident_to_split;
	int new_ident;
	fastf_t z;
	struct compsplt *next;
} *compsplt_root;

struct hole_list
{
	int group;
	int component;
	struct hole_list *next;
};

struct holes
{
	int group;
	int component;
	int type;
	struct hole_list *holes;
	struct holes *next;
} *hole_root;
d306 1
a306 11
#define HOLE 1
#define WALL 2

point_t *grid_pts;

int get_line(void);
void Add_holes( int type, int gr, int comp, struct hole_list *ptr );
void make_bot_object(void);
int skip_region( int id );

int
d309 2
a310 2
	struct holes *hole_ptr;
	struct hole_list *ptr;
d312 1
a312 1
	hole_ptr = hole_root;
d314 1
a314 1
	while( hole_ptr )
d316 1
a316 1
		if( hole_ptr->type == HOLE )
d318 2
a319 2
			ptr = hole_ptr->holes;
			while( ptr )
d321 3
a323 3
				if( (ptr->group * 1000 + ptr->component) == id )
					return( 1 );
				ptr = ptr->next;
d326 1
a326 1
		hole_ptr = hole_ptr->next;
d328 1
a328 1
	return( 0 );
d331 1
a331 1
void
d334 2
a335 2
	if( mk_addmember( name , &hole_head.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
		bu_log( "add_to_holes: mk_addmember failed for region %s\n" , name );
d338 1
a338 1
void
d341 4
a344 4
	pdv_3move( fd_plot, grid_pts[pt1] );
	pdv_3cont( fd_plot, grid_pts[pt2] );
	pdv_3cont( fd_plot, grid_pts[pt3] );
	pdv_3cont( fd_plot, grid_pts[pt1] );
d347 1
a347 1
void
d350 1
a350 1
	struct name_tree *ptr;
d352 2
a353 2
	if( !name_root )
		return;
d355 1
a355 1
	bu_ptbl_reset( &stack );
d357 1
a357 1
	CK_TREE_MAGIC( name_root )
d360 1
a360 1
	while( 1 )
d362 1
a362 1
		while( ptr )
d364 2
a365 2
			PUSH( ptr );
			ptr = ptr->rleft;
d367 3
a369 3
		POP( name_tree , ptr );
		if( !ptr )
			break;
d371 2
a372 2
		/* visit node */
		CK_TREE_MAGIC( ptr )
d376 3
a378 3
	/* alpabetical order */
	ptr = name_root;
	while( 1 )
d380 1
a380 1
		while( ptr )
d382 2
a383 2
			PUSH( ptr );
			ptr = ptr->nleft;
d385 3
a387 3
		POP( name_tree , ptr );
		if( !ptr )
			break;
d389 2
a390 2
		/* visit node */
		CK_TREE_MAGIC( ptr )
d395 3
a397 2
void
insert_int(int in)
d399 1
a399 1
	int i;
d401 5
a405 5
	for( i=0 ; i<int_list_count ; i++ )
	{
		if( int_list[i] == in )
			return;
	}
d407 1
a407 1
	if( int_list_count == int_list_length )
d409 1
a409 6
		if( int_list_length == 0 )
			int_list = (int *)bu_malloc( INT_LIST_BLOCK*sizeof( int ) , "insert_id: int_list" );
		else
			int_list = (int *)bu_realloc( (char *)int_list , (int_list_length + INT_LIST_BLOCK)*sizeof( int ) , "insert_id: int_list" );
		int_list_length += INT_LIST_BLOCK;
	}
d411 14
a424 20
	int_list[int_list_count] = in;
	int_list_count++;

	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in insert_int\n" );
}

void
Subtract_holes(struct wmember *head, int comp_id, int group_id)
{
	struct holes *hole_ptr;
	struct hole_list *list_ptr;

	if( debug )
		bu_log( "Subtract_holes( comp_id=%d, group_id=%d )\n" , comp_id , group_id );

	hole_ptr = hole_root;
	while( hole_ptr )
	{
		if( hole_ptr->group == group_id && hole_ptr->component == comp_id )
d426 4
a429 45
			list_ptr = hole_ptr->holes;
			while( list_ptr )
			{
				struct name_tree *ptr;
				int reg_id;

				reg_id = list_ptr->group * 1000 + list_ptr->component;
				ptr = name_root;
				while( ptr && ptr->region_id != reg_id )
				{
					int diff;

					diff = reg_id - ptr->region_id;
					if( diff > 0 )
						ptr = ptr->rright;
					else if( diff < 0 )
						ptr = ptr->rleft;
				}

				bu_ptbl_reset( &stack );

				while( ptr && ptr->region_id == reg_id )
				{

					while( ptr && ptr->region_id == reg_id )
					{
						PUSH( ptr );
						ptr = ptr->rleft;
					}
					POP( name_tree , ptr );
					if( !ptr ||  ptr->region_id != reg_id )
						break;

					if( debug )
						bu_log( "\tSubtracting %s\n", ptr->name );

					if( mk_addmember( ptr->name , &(head->l), NULL , WMOP_SUBTRACT ) == (struct wmember *)NULL )
						rt_bomb( "Subtract_holes: mk_addmember failed\n" );

					ptr = ptr->rright;
				}

				list_ptr = list_ptr->next;
			}
			break;
a430 1
		hole_ptr = hole_ptr->next;
a431 2
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in subtract_holes\n" );
d434 3
a436 2
void
do_compsplt(void)
d438 1
a438 12
	int gr, co, gr1,  co1;
	fastf_t z;
	struct compsplt *splt;

	strncpy( field, &line[8], 8 );
	gr = atoi( field );

	strncpy( field, &line[16], 8 );
	co = atoi( field );

	strncpy( field, &line[24], 8 );
	gr1 = atoi( field );
d440 1
a440 2
	strncpy( field, &line[32], 8 );
	co1 = atoi( field );
d442 3
a444 2
	strncpy( field, &line[40], 8 );
	z = atof( field ) * 25.4;
d446 1
a446 1
	if( compsplt_root == NULL )
d448 1
a448 17
		compsplt_root = (struct compsplt *)bu_calloc( 1, sizeof( struct compsplt ), "compsplt_root" );
		splt = compsplt_root;
	}
	else
	{
		splt = compsplt_root;
		while( splt->next )
			splt = splt->next;
		splt->next = (struct compsplt *)bu_calloc( 1, sizeof( struct compsplt ), "compsplt_root" );
		splt = splt->next;
	}
	splt->next = (struct compsplt *)NULL;
	splt->ident_to_split = gr * 1000 + co;
	splt->new_ident = gr1 * 1000 + co1;
	splt->z = z;
	make_region_name( gr1, co1 );
}
d450 1
a450 5
void
List_holes(void)
{
	struct holes *hole_ptr;
	struct hole_list *list_ptr;
d452 13
a464 7
	hole_ptr = hole_root;

	while( hole_ptr )
	{
		bu_log( "Holes for Group %d, Component %d:\n" , hole_ptr->group, hole_ptr->component );
		list_ptr = hole_ptr->holes;
		while( list_ptr )
d466 4
a469 2
			bu_log( "\tgroup %d component %d\n" , list_ptr->group, list_ptr->component );
			list_ptr = list_ptr->next;
a470 1
		hole_ptr = hole_ptr->next;
d474 2
a475 1
void
d478 1
a478 1
	struct name_tree *ptr;
d480 1
a480 1
	bu_ptbl_reset( &stack );
d482 3
a484 3
	bu_log( "\nNames in ident order:\n" );
	ptr = name_root;
	while( 1 )
d486 1
a486 1
		while( ptr )
d488 2
a489 2
			PUSH( ptr );
			ptr = ptr->rleft;
d491 3
a493 3
		POP( name_tree , ptr );
		if( !ptr )
			break;
d495 5
a499 5
		if( ptr->in_comp_group )
			bu_log( "%s %d %d (in a comp group)\n" , ptr->name , ptr->region_id , ptr->inner );
		else
			bu_log( "%s %d %d (not in a comp group)\n" , ptr->name , ptr->region_id , ptr->inner );
		ptr = ptr->rright;
d502 3
a504 3
	bu_log( "\tAlphabetical list of names:\n" );
	ptr = name_root;
	while( 1 )
d506 1
a506 1
		while( ptr )
d508 2
a509 2
			PUSH( ptr );
			ptr = ptr->nleft;
d511 3
a513 3
		POP( name_tree , ptr );
		if( !ptr )
			break;
d515 2
a516 2
		bu_log( "%s %d %d\n" , ptr->name, ptr->region_id , ptr->inner );
		ptr = ptr->nright;
d520 3
a522 2
struct name_tree *
Search_names(struct name_tree *root, char *name, int *found)
d524 10
a533 1
	struct name_tree *ptr;
d535 10
a544 1
	*found = 0;
d546 12
a557 3
	ptr = root;
	if( !ptr )
		return( (struct name_tree *)NULL );
d559 3
a561 1
	while( 1 )
d563 1
a563 1
		int diff;
d565 1
a565 2
		diff = strcmp( name , ptr->name );
		if( diff == 0 )
d567 15
a581 2
			*found = 1;
			return( ptr );
d583 5
a587 1
		else if( diff > 0 )
d589 6
a594 4
			if( ptr->nright )
				ptr = ptr->nright;
			else
				return( ptr );
d596 1
a596 1
		else if( diff < 0 )
d598 6
a603 4
			if( ptr->nleft )
				ptr = ptr->nleft;
			else
				return( ptr );
d606 24
d632 3
a634 2
struct name_tree *
Search_ident(struct name_tree *root, int reg_id, int *found)
d636 2
a637 1
	struct name_tree *ptr;
d639 1
a639 1
	*found = 0;
d641 3
a643 3
	ptr = root;
	if( !ptr )
		return( (struct name_tree *)NULL );
d645 3
a647 1
	while( 1 )
d649 26
a674 1
		int diff;
d676 3
a678 1
		diff = reg_id -  ptr->region_id;
d680 17
a696 20
		if( diff == 0 )
		{
			*found = 1;
			return( ptr );
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
				ptr = ptr->rright;
			else
				return( ptr );
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
				ptr = ptr->rleft;
			else
				return( ptr );
		}
	}
d699 3
a701 2
void
Delete_name(struct name_tree **root, char *name)
d703 6
a708 9
	struct name_tree *ptr,*parent,*ptr2;
	int r_id;
	int found;
	int diff;

	/* first delete from name portion of tree */
	ptr = *root;
	parent = (struct name_tree *)NULL;
	found = 0;
d710 1
a710 1
	while( 1 )
d712 2
a713 26
		diff = strcmp( name , ptr->name );
		if( diff == 0 )
		{
			found = 1;
			break;
		}
		else if( diff > 0 )
		{
			if( ptr->nright )
			{
				parent = ptr;
				ptr = ptr->nright;
			}
			else
				break;
		}
		else if( diff < 0 )
		{
			if( ptr->nleft )
			{
				parent = ptr;
				ptr = ptr->nleft;
			}
			else
				break;
		}
d716 1
a716 2
	if( !found )
		return;
d718 9
a726 1
	r_id = ptr->region_id;
d728 1
a728 1
	if( parent == (struct name_tree *)NULL )
d730 3
a732 7
		if( ptr->nright )
		{
			*root = ptr->nright;
			ptr2 = *root;
			while( ptr2->nleft )
				ptr2 = ptr2->nleft;
			ptr2->nleft = ptr->nleft;
d734 2
a735 28
			ptr2 = *root;
			while( ptr2->rleft )
				ptr2 = ptr2->rleft;
			ptr2->rleft = ptr->rleft;
		}
		else if( ptr->nleft )
		{
			*root = ptr->nleft;
			ptr2 = *root;
			while( ptr2->nright )
				ptr2 = ptr2->nright;
			ptr2->nright = ptr->nright;
			ptr2 = *root;
			while( ptr2->rright )
				ptr2 = ptr2->rright;
			ptr2->rright = ptr->rright;
		}
		else
		{
			/* This was the only name in the tree */
			*root = (struct name_tree *)NULL;
		}
		bu_free( (char *)ptr , "Delete_name: ptr" );
		if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
			bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
		return;
	}
	else
d737 1
a737 1
		if( parent->nright == ptr )
d739 2
a740 10
			if( ptr->nleft )
			{
				parent->nright = ptr->nleft;
				ptr2 = ptr->nleft;
				while( ptr2->nright )
					ptr2 = ptr2->nright;
				ptr2->nright = ptr->nright;
			}
			else
				parent->nright = ptr->nright;
d742 5
a746 1
		else if( parent->nleft == ptr )
d748 2
a749 10
			if( ptr->nright )
			{
				parent->nleft = ptr->nright;
				ptr2 = ptr->nright;
				while( ptr2->nleft )
					ptr2 = ptr2->nleft;
				ptr2->nleft = ptr->nleft;
			}
			else
				parent->nleft = ptr->nleft;
d751 1
d753 9
d763 1
d765 4
a768 4
	/* now delete from ident prtion of tree */
	ptr = *root;
	parent = (struct name_tree *)NULL;
	found = 0;
a769 3
	while( 1 )
	{
		diff = r_id - ptr->region_id;
d771 4
a774 26
		if( diff == 0 )
		{
			found = 1;
			break;
		}
		else if( diff > 0 )
		{
			if( ptr->rright )
			{
				parent = ptr;
				ptr = ptr->rright;
			}
			else
				break;
		}
		else if( diff < 0 )
		{
			if( ptr->rleft )
			{
				parent = ptr;
				ptr = ptr->rleft;
			}
			else
				break;
		}
	}
d776 1
a776 1
	if( !found )
d778 2
a779 2
		bu_log( "name (%s) deleted from name tree, but not found in ident tree!!\n" , name );
		rt_bomb( "Delete_name\n" );
d782 1
a782 1
	if( !parent )
d784 5
a788 2
		bu_log( "name (%s) is root of ident tree, but not name tree!!\n" , name );
		rt_bomb( "Delete_name\n" );
d791 7
d799 11
a809 1
	if( parent->rright == ptr )
d811 1
a811 1
		if( ptr->rleft )
d813 45
a857 5
			parent->rright = ptr->rleft;
			ptr2 = ptr->rleft;
			while( ptr2->rright )
				ptr2 = ptr2->rright;
			ptr2->rright = ptr->rright;
d859 1
a859 2
		else
			parent->rright = ptr->rright;
d861 2
a862 17
	else if( parent->rleft == ptr )
	{
		if( ptr->rright )
		{
			parent->rleft = ptr->rright;
			ptr2 = ptr->rright;
			while( ptr2->rleft )
				ptr2 = ptr2->rleft;
			ptr2->rleft = ptr->rleft;
		}
		else
			parent->rleft = ptr->rleft;
	}
	bu_free( (char *)ptr , "Delete_name: ptr" );
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Delete_name\n" );
	Check_names();
d865 2
a866 2
void
Insert_name(struct name_tree **root, char *name, int inner)
d868 3
a870 4
	struct name_tree *ptr;
	struct name_tree *new_ptr;
	int found;
	int diff;
d872 2
a873 1
	ptr = Search_names( *root , name , &found );
d875 5
a879 5
	if( found )
	{
		bu_log( "Insert_name: %s already in name tree\n" , name );
		return;
	}
d881 2
a882 1
	new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_name: new_ptr" );
d884 2
a885 9
	new_ptr->name = bu_strdup( name );
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->region_id = (-region_id);
	new_ptr->in_comp_group = 0;
	new_ptr->inner = inner;
	new_ptr->magic = NAME_TREE_MAGIC;
d887 1
a887 1
	if( !*root )
d889 2
a890 2
		*root = new_ptr;
		return;
d892 1
a892 3

	diff = strcmp( name , ptr->name );
	if( diff > 0 )
d894 5
a898 6
		if( ptr->nright )
		{
			bu_log( "Insert_name: ptr->nright not null\n" );
			rt_bomb( "\tCannot insert new node\n" );
		}
		ptr->nright = new_ptr;
d900 16
a915 1
	else
d917 3
a919 1
		if( ptr->nleft )
d921 2
a922 2
			bu_log( "Insert_name: ptr->nleft not null\n" );
			rt_bomb( "\tCannot insert new node\n" );
d924 1
a924 1
		ptr->nleft = new_ptr;
a925 2
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Insert_name\n" );
d928 3
a930 2
void
Insert_region_name(char *name, int reg_id)
d932 4
a935 7
	struct name_tree *nptr_model,*rptr_model;
	struct name_tree *new_ptr;
	int foundn,foundr;
	int diff;

	if( debug )
		bu_log( "Insert_region_name( name=%s, reg_id=%d\n" , name, reg_id );
d937 4
a940 5
	rptr_model = Search_ident( name_root , reg_id , &foundr );
	nptr_model = Search_names( name_root , name , &foundn );

	if( foundn && foundr )
		return;
d942 1
a942 1
	if( foundn != foundr )
d944 26
a969 4
		bu_log( "Insert_region_name: name %s ident %d\n\tfound name is %d\n\tfound ident is %d\n",
			name, reg_id, foundn, foundr );
		List_names();
		rt_bomb( "\tCannot insert new node\n" );
d972 4
a975 12
	/* Add to tree for entire model */
	new_ptr = (struct name_tree *)bu_malloc( sizeof( struct name_tree ) , "Insert_region_name: new_ptr" );
	new_ptr->rleft = (struct name_tree *)NULL;
	new_ptr->rright = (struct name_tree *)NULL;
	new_ptr->nleft = (struct name_tree *)NULL;
	new_ptr->nright = (struct name_tree *)NULL;
	new_ptr->region_id = reg_id;
	new_ptr->mode = mode;
	new_ptr->inner = -1;
	new_ptr->in_comp_group = 0;
	new_ptr->name = bu_strdup( name );
	new_ptr->magic = NAME_TREE_MAGIC;
d977 1
a977 3
	if( !name_root )
		name_root = new_ptr;
	else
d979 7
a985 1
		diff = strcmp( name , nptr_model->name );
d987 6
a992 1
		if( diff > 0 )
d994 25
a1018 1
			if( nptr_model->nright )
d1020 5
a1024 2
				bu_log( "Insert_region_name: nptr_model->nright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
d1026 2
a1027 1
			nptr_model->nright = new_ptr;
d1029 1
a1029 1
		else
d1031 1
a1031 1
			if( nptr_model->nleft )
d1033 5
a1037 2
				bu_log( "Insert_region_name: nptr_model->nleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
d1039 2
a1040 1
			nptr_model->nleft = new_ptr;
d1042 1
d1045 15
a1059 3
		diff = reg_id - rptr_model->region_id;

		if( diff > 0 )
d1061 1
a1061 1
			if( rptr_model->rright )
d1063 2
a1064 2
				bu_log( "Insert_region_name: rptr_model->rright not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
d1066 2
a1067 1
			rptr_model->rright = new_ptr;
d1069 1
a1069 1
		else
d1071 1
a1071 1
			if( rptr_model->rleft )
d1073 2
a1074 2
				bu_log( "Insert_region_name: rptr_model->rleft not null\n" );
				rt_bomb( "\tCannot insert new node\n" );
d1076 2
a1077 1
			rptr_model->rleft = new_ptr;
a1079 4
	Check_names();
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in Insert_region_name\n" );
}
d1081 5
a1085 6
char *
find_region_name(int g_id, int c_id)
{
	struct name_tree *ptr;
	int reg_id;
	int found;
d1087 5
a1091 1
	reg_id = g_id * 1000 + c_id;
a1092 2
	if( debug )
		bu_log( "find_region_name( g_id=%d, c_id=%d ), reg_id=%d\n" , g_id, c_id, reg_id );
d1094 14
a1107 23
	ptr = Search_ident( name_root , reg_id , &found );

	if( found )
		return( ptr->name );
	else
		return( (char *)NULL );
}

char *
make_unique_name(char *name)
{
	struct bu_vls vls;
	int found;

	/* make a unique name from what we got off the $NAME card */

	(void)Search_names( name_root , name , &found );
	if( !found )
		return( bu_strdup( name ) );

	bu_vls_init( &vls );

	while( found )
d1109 10
a1118 3
		bu_vls_trunc( &vls, 0 );
		bu_vls_printf( &vls, "%s_%d", name, name_count );
		(void)Search_names( name_root , bu_vls_addr( &vls ) , &found );
d1120 5
a1124 2
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_unique_name\n" );
a1125 2
	return( bu_vls_strgrab( &vls ) );
}
d1127 1
a1127 1
void
d1130 1
a1130 1
	if( group_id < 0 || group_id > 10 )
d1132 3
a1134 3
		bu_log( "add_to_series: region (%s) not added, illegal group number %d, region_id=$d\n" ,
			name , group_id , reg_id );
		return;
d1137 2
a1138 2
	if( mk_addmember( name , &group_head[group_id].l, NULL ,WMOP_UNION ) == (struct wmember *)NULL )
		bu_log( "add_to_series: mk_addmember failed for region %s\n" , name );
d1141 2
a1142 1
void
d1145 2
a1146 2
	struct wmember g_head;
	struct name_tree *ptr;
d1148 2
a1149 2
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in make_comp_group\n" );
d1151 1
a1151 1
	BU_LIST_INIT( &g_head.l );
d1153 1
a1153 1
	bu_ptbl_reset( &stack );
d1155 2
a1156 2
	ptr = name_root;
	while( 1 )
d1158 1
a1158 1
		while( ptr )
d1160 2
a1161 2
			PUSH( ptr );
			ptr = ptr->nleft;
d1163 3
a1165 3
		POP( name_tree , ptr );
		if( !ptr )
			break;
d1167 1
a1167 1
		if(ptr->region_id == region_id && !ptr->inner && !ptr->in_comp_group )
d1169 1
a1169 1
			if( mk_addmember( ptr->name , &g_head.l , NULL , WMOP_UNION ) == (struct wmember *)NULL )
d1171 2
a1172 2
				bu_log( "make_comp_group: Could not add %s to group for ident %d\n" , ptr->name , ptr->region_id );
				break;
d1174 1
a1174 1
			ptr->in_comp_group = 1;
d1176 1
a1176 1
		ptr = ptr->nright;
d1179 1
a1179 1
	if( BU_LIST_NON_EMPTY( &g_head.l ) )
d1181 2
a1182 2
		char *name;
		struct bu_vls vls;
d1184 1
a1184 1
		if( !(name=find_region_name( group_id , comp_id )) )
d1186 8
a1193 8
			bu_vls_init( &vls );
			bu_vls_printf( &vls , "comp_%d" , region_id );
			name = make_unique_name( bu_vls_addr( &vls ) );
			bu_vls_free( &vls );
			if( warnings )
				bu_log( "Creating default name (%s) for group %d component %d\n",
						name , group_id , comp_id );
			Insert_name( &name_root , name, 1 );
d1196 5
a1200 5
		mk_lfcomb( fdout , name , &g_head , 0 );
		if( !is_a_hole( region_id ) )
			add_to_series( name , region_id );
		else
			add_to_holes( name, region_id );
d1202 1
a1202 1
		bu_free( (char *)name, "str_dupped name" );
d1206 2
a1207 1
void
d1210 1
a1210 1
	struct name_tree *ptr;
d1212 1
a1212 1
	ptr = name_root;
d1214 1
a1214 1
	while( 1 )
d1216 1
a1216 1
		while( ptr )
d1218 2
a1219 2
			PUSH( ptr );
			ptr = ptr->rleft;
d1221 3
a1223 3
		POP( name_tree, ptr );
		if( !ptr )
			break;
d1225 2
a1226 2
		/* visit node */
		CK_TREE_MAGIC( ptr );
d1228 1
a1228 1
		if( !ptr->in_comp_group && ptr->region_id > 0 && !is_a_hole( ptr->region_id ) )
d1230 3
a1232 3
			/* add this component to a series */
			(void)mk_addmember( ptr->name, &group_head[ptr->region_id/1000].l, NULL, WMOP_UNION );
			ptr->in_comp_group = 1;
d1235 1
a1235 1
		ptr = ptr->rright;
d1239 3
a1241 2
void
do_groups(void)
d1243 2
a1244 2
	int group_no;
	struct wmember head_all;
d1246 2
a1247 2
	if( debug )
		bu_log( "do_groups\n" );
d1249 1
a1249 1
	BU_LIST_INIT( &head_all.l );
d1251 1
a1251 1
	Add_stragglers_to_groups();
d1253 1
a1253 1
	for( group_no=0 ; group_no < 11 ; group_no++ )
d1255 1
a1255 1
		char name[LINELEN] = {0};
d1257 2
a1258 2
		if( BU_LIST_IS_EMPTY( &group_head[group_no].l ) )
			continue;
d1260 2
a1261 2
		snprintf( name , LINELEN, "%dxxx_series" , group_no );
		mk_lfcomb( fdout , name , &group_head[group_no] , 0 );
d1263 2
a1264 2
		if( mk_addmember( name , &head_all.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			bu_log( "do_groups: mk_addmember failed to add %s to group all\n" , name );
d1267 2
a1268 2
	if( BU_LIST_NON_EMPTY( &head_all.l ) )
		mk_lfcomb( fdout , "all" , &head_all , 0 );
d1270 2
a1271 2
	if( BU_LIST_NON_EMPTY( &hole_head.l ) )
		mk_lfcomb( fdout , "holes" , &hole_head , 0 );
d1274 3
a1276 2
void
do_name(void)
d1278 5
a1282 5
	int i,j;
	int g_id;
	int c_id;
	char comp_name[LINELEN] = {0}; /* should only use 25 chars */
	char tmp_name[LINELEN] = {0}; /* should only use 25 chars */
d1284 2
a1285 2
	if( pass )
		return;
d1287 2
a1288 2
	if( debug )
		bu_log( "do_name: %s\n" , line );
d1290 2
a1291 2
	strncpy( field , &line[8] , 8 );
	g_id = atoi( field );
d1293 1
a1293 1
	if( g_id != group_id )
d1295 3
a1297 3
		bu_log( "$NAME card for group %d in section for group %d ignored\n" , g_id , group_id );
		bu_log( "%s\n" , line );
		return;
d1300 2
a1301 2
	strncpy( field , &line[16] , 8 );
	c_id = atoi( field );
d1303 1
a1303 1
	if( c_id != comp_id )
d1305 3
a1307 3
		bu_log( "$NAME card for component %d in section for component %d ignored\n" , c_id , comp_id );
		bu_log( "%s\n" , line );
		return;
d1310 6
a1315 6
	/* skip leading blanks */
	i = 56;
	while( i < 80 && isspace( line[i] ) )
		i++;
	if( i == 80 )
		return;
d1317 1
a1317 1
	strncpy( comp_name , &line[i] , 80 - i );
d1319 4
a1322 4
	/* eliminate trailing blanks */
	i = 80 - i;
	while(  --i >= 0 && isspace( comp_name[i] ) )
		comp_name[i] = '\0';
d1324 3
a1326 3
	/* copy comp_name to tmp_name while replacing white space with "_" */
	i = (-1);
	j = (-1);
d1328 2
a1329 2
	/* copy */
	while( comp_name[++i] != '\0' )
d1331 1
a1331 1
		if( isspace( comp_name[i] ) || comp_name[i] == '/' )
d1333 2
a1334 2
			if( j == (-1) || tmp_name[j] != '_' )
				tmp_name[++j] = '_';
d1336 2
a1337 2
		else
			tmp_name[++j] = comp_name[i];
d1339 1
a1339 32
	tmp_name[++j] = '\0';

	/* reserve this name for group name */
	make_unique_name( tmp_name );
	Insert_region_name( tmp_name , region_id );

	name_count = 0;
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed in do_name\n" );
}

void
make_region_name(int g_id, int c_id)
{
	int r_id;
	const char *tmp_name;
	char *name;

	r_id = g_id * 1000 + c_id;

	if( debug )
		bu_log( "make_region_name( g_id=%d, c_id=%d )\n" , g_id, c_id );

	tmp_name = find_region_name( g_id , c_id );
	if( tmp_name )
		return;

	/* create a new name */
	name = (char *)bu_malloc( LINELEN, "make_region_name" );
	snprintf( name , LINELEN, "comp_%04d.r" , r_id );

	make_unique_name( name );
d1341 3
a1343 8
	Insert_region_name( name , r_id );
}

char *
get_solid_name(char type, int element_id, int c_id, int g_id, int inner)
{
	int reg_id;
	struct bu_vls vls;
d1345 3
a1347 6
	reg_id = g_id * 1000 + c_id;

	bu_vls_init( &vls );
	bu_vls_printf( &vls , "%d.%d.%c%d" , reg_id , element_id , type , inner );

	return( bu_vls_strgrab( &vls ) );
a1349 11
char *
make_solid_name(char type, int element_id, int c_id, int g_id, int inner)
{
	char *name;

	name = get_solid_name( type , element_id , c_id , g_id , inner );

	Insert_name( &name_root , name, inner );

	return( name );
}
d1351 2
a1352 2
void
do_grid(void)
d1354 2
a1355 2
	int grid_no;
	fastf_t x,y,z;
d1357 2
a1358 2
	if( !pass )	/* not doing geometry yet */
		return;
d1360 2
a1361 2
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at start of do_grid\n" );
d1363 2
a1364 2
	strncpy( field , &line[8] , 8 );
	grid_no = atoi( field );
d1366 1
a1366 1
	if( grid_no < 1 )
d1368 2
a1369 2
		bu_log( "ERROR: grid id number = %d\n" , grid_no );
		rt_bomb( "BAD GRID ID NUMBER\n" );
d1372 2
a1373 2
	strncpy( field , &line[24] , 8 );
	x = atof( field );
d1375 2
a1376 2
	strncpy( field , &line[32] , 8 );
	y = atof( field );
d1378 2
a1379 2
	strncpy( field , &line[40] , 8 );
	z = atof( field );
d1381 1
a1381 1
	while( grid_no > grid_size - 1 )
d1383 2
a1384 2
		grid_size += GRID_BLOCK;
		grid_pts = (point_t *)bu_realloc( (char *)grid_pts , grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
d1387 1
a1387 1
	VSET( grid_pts[grid_no] , x*25.4 , y*25.4 , z*25.4 );
d1389 4
a1392 4
	if( grid_no > max_grid_no )
		max_grid_no = grid_no;
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at end of do_grid\n" );
d1395 3
a1397 2
void
do_sphere(void)
d1399 7
a1405 7
	int element_id;
	int center_pt;
	fastf_t thick;
	fastf_t radius;
	fastf_t inner_radius;
	char *name = (char *)NULL;
	struct wmember sphere_group;
d1407 1
a1407 1
	if( !pass )
d1409 2
a1410 2
		make_region_name( group_id , comp_id );
		return;
d1413 2
a1414 2
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d1416 2
a1417 2
	strncpy( field , &line[24] , 8 );
	center_pt = atoi( field );
d1419 2
a1420 2
	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;
d1422 3
a1424 3
	strncpy( field , &line[64] , 8 );
	radius = atof( field ) * 25.4;
	if( radius <= 0.0 )
d1426 3
a1428 3
		bu_log( "do_sphere: illegal radius (%f), skipping sphere\n" , radius );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
d1431 1
a1431 1
	if( center_pt < 1 || center_pt > max_grid_no )
d1433 3
a1435 3
		bu_log( "do_sphere: illegal grid number for center point %d, skipping sphere\n" , center_pt );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
d1438 1
a1438 1
	BU_LIST_INIT( &sphere_group.l );
d1440 1
a1440 1
	if( mode == VOLUME_MODE )
d1442 3
a1444 3
		name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 0 );
		mk_sph( fdout , name , grid_pts[center_pt] , radius );
		bu_free( name, "solid_name" );
d1446 1
a1446 1
	else if( mode == PLATE_MODE )
d1448 2
a1449 2
		name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 1 );
		mk_sph( fdout , name , grid_pts[center_pt] , radius );
d1451 1
a1451 1
		BU_LIST_INIT( &sphere_group.l );
d1453 1
a1453 1
		if( mk_addmember( name ,  &sphere_group.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
d1455 2
a1456 2
			bu_log( "do_sphere: Error in adding %s to sphere group\n" , name );
			rt_bomb( "do_sphere" );
d1458 1
a1458 1
		bu_free( name, "solid_name" );
d1460 2
a1461 2
		inner_radius = radius - thick;
		if( thick > 0.0 && inner_radius <= 0.0 )
d1463 3
a1465 3
			bu_log( "do_sphere: illegal thickness (%f), skipping inner sphere\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
d1468 2
a1469 2
		name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 2 );
		mk_sph( fdout , name , grid_pts[center_pt] , inner_radius );
d1471 1
a1471 1
		if( mk_addmember( name , &sphere_group.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
d1473 2
a1474 2
			bu_log( "do_sphere: Error in subtracting %s from sphere region\n" , name );
			rt_bomb( "do_sphere" );
d1476 1
a1476 1
		bu_free( name, "solid_name" );
d1478 3
a1480 3
		name = make_solid_name( CSPHERE , element_id , comp_id , group_id , 0 );
		mk_comb( fdout, name, &sphere_group.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
		bu_free( name, "solid_name" );
d1484 3
a1486 2
void
do_vehicle(void)
d1488 2
a1489 2
	if( pass )
		return;
d1491 2
a1492 2
	strncpy( vehicle , &line[8] , 16 ); /* why 16? */
	mk_id_units( fdout , vehicle , "in" );
d1495 3
a1497 2
void
do_cline(void)
d1499 6
a1504 6
	int element_id;
	int pt1,pt2;
	fastf_t thick;
	fastf_t radius;
	vect_t height;
	char *name;
d1506 2
a1507 2
	if( debug )
		bu_log( "do_cline: %s\n" , line );
d1509 1
a1509 1
	if( !pass )
d1511 2
a1512 2
		make_region_name( group_id , comp_id );
		return;
d1515 2
a1516 2
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d1518 3
a1520 3
	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );
	if( pass && (pt1 < 1 || pt1 > max_grid_no) )
d1522 3
a1524 3
		bu_log( "Illegal grid point (%d) in CLINE, skipping\n", pt1 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
d1527 3
a1529 3
	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );
	if( pass && (pt2 < 1 || pt2 > max_grid_no) )
d1531 3
a1533 3
		bu_log( "Illegal grid point in CLINE (%d), skipping\n", pt2 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
d1536 1
a1536 1
	if( pt1 == pt2 )
d1538 3
a1540 3
		bu_log( "Ilegal grid points in CLINE ( %d and %d ), skipping\n", pt1 , pt2 );
		bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
		return;
d1543 2
a1544 2
	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;
d1546 2
a1547 2
	strncpy( field , &line[64] , 8 );
	radius = atof( field ) * 25.4;
d1549 1
a1549 1
	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );
d1551 33
a1583 32
	name = make_solid_name( CLINE , element_id , comp_id , group_id , 0 );
	mk_cline( fdout , name , grid_pts[pt1] , height , radius, thick );
	bu_free( name, "solid_name" );
}

void
do_ccone1(void)
{
	int element_id;
	int pt1,pt2;
	fastf_t thick;
	int c1,c2;
	int end1,end2;
	vect_t height;
	fastf_t r1,r2;
	char *outer_name;
	char *inner_name;
	char *name = (char *)NULL;
	struct wmember r_head;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		if( !get_line() )
		{
			bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE1\n" );
d1585 1
a1585 1
		return;
d1588 2
a1589 2
	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );
d1591 2
a1592 2
	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );
d1594 2
a1595 2
	strncpy( field , &line[56] , 8 );
	thick = atof( field ) * 25.4;
d1597 2
a1598 2
	strncpy( field , &line[64] , 8 );
	r1 = atof( field ) * 25.4;
d1600 2
a1601 2
	strncpy( field , &line[72] , 8 );
	c1 = atoi( field );
d1603 1
a1603 1
	if( !get_line() )
d1605 4
a1608 4
		bu_log( "Unexpected EOF while reading continuation card for CCONE1\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , c1 );
		rt_bomb( "CCONE1\n" );
d1611 2
a1612 2
	strncpy( field , line , 8 );
	c2 = atoi( field );
d1614 1
a1614 1
	if( c1 != c2 )
d1616 3
a1618 3
		bu_log( "WARNING: CCONE1 continuation flags disagree, %d vs %d\n" , c1 , c2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
d1621 2
a1622 2
	strncpy( field , &line[8] , 8 );
	r2 = atof( field ) * 25.4;
d1624 2
a1625 2
	strncpy( field , &line[16] , 8 );
	end1 = atoi( field );
d1627 2
a1628 2
	strncpy( field , &line[24] , 8 );
	end2 = atoi( field );
d1630 1
a1630 1
	if( r1 < 0.0 || r2 < 0.0 )
d1632 5
a1636 5
		bu_log( "ERROR: CCONE1 has illegal radii, %f and %f\n" , r1/25.4 , r2/25.4 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		bu_log( "\tCCONE1 solid ignored\n" );
		return;
d1639 1
a1639 1
	if( mode == PLATE_MODE )
d1641 1
a1641 1
		if( thick <= 0.0 )
d1643 5
a1647 5
			bu_log( "ERROR: Plate mode CCONE1 has illegal thickness (%f)\n" , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 solid ignored\n" );
			return;
d1650 1
a1650 1
		if( r1-thick < min_radius && r2-thick < min_radius )
d1652 5
a1656 5
			bu_log( "ERROR: Plate mode CCONE1 has too large thickness (%f)\n" , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 solid ignored\n" );
			return;
d1660 18
a1677 1
	if( pt1 < 1 || pt1 > max_grid_no || pt2 < 1 || pt2 > max_grid_no || pt1 == pt2 )
d1679 3
a1681 5
		bu_log( "ERROR: CCONE1 has illegal grid points ( %d and %d)\n" , pt1 , pt2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		bu_log( "\tCCONE1 solid ignored\n" );
		return;
d1683 13
d1697 3
a1699 31
	/* BRL_CAD doesn't allow zero radius, so use a very small radius */
	if( r1 < min_radius )
		r1 = min_radius;
	if( r2 < min_radius )
		r2 = min_radius;

	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );

	if( mode == VOLUME_MODE )
	{
		outer_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 0 );
		mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );
		bu_free( outer_name, "solid_name" );
	}
	else if( mode == PLATE_MODE )
	{
		/* make inside TGC */

		point_t base;
		point_t top;
		vect_t inner_height;
		fastf_t inner_r1,inner_r2;
		fastf_t length;
		fastf_t sin_ang;
		fastf_t slant_len;
		fastf_t r1a,r2a;
		vect_t height_dir;

		/* make outside TGC */
		outer_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 1 );
		mk_trc_h( fdout , outer_name , grid_pts[pt1] , height , r1 , r2 );
d1701 4
a1704 4
		BU_LIST_INIT( &r_head.l );
		if( mk_addmember( outer_name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			rt_bomb( "CCONE1: mk_addmember failed\n" );
		bu_free( outer_name, "solid_name" );
d1706 3
a1708 3
		length = MAGNITUDE( height );
		VSCALE( height_dir , height , 1.0/length );
		slant_len = sqrt( length*length + (r2 - r1)*(r2 - r1) );
d1710 1
a1710 1
		sin_ang = length/slant_len;
d1712 1
a1712 1
		if( end1 == END_OPEN )
d1714 3
a1716 3
			r1a = r1;
			inner_r1 = r1 - thick/sin_ang;
			VMOVE( base , grid_pts[pt1] );
d1718 1
a1718 1
		else
d1720 3
a1722 3
			r1a = r1 + (r2 - r1)*thick/length;
			inner_r1 = r1a - thick/sin_ang;
			VJOIN1( base , grid_pts[pt1] , thick , height_dir );
d1725 1
a1725 1
		if( inner_r1 < 0.0 )
d1727 1
a1727 1
			fastf_t dist_to_new_base;
d1729 3
a1731 3
			dist_to_new_base = inner_r1 * length/(r1 - r2 );
			inner_r1 = min_radius;
			VJOIN1( base , base , dist_to_new_base , height_dir );
d1733 2
a1734 2
		else if( inner_r1 < min_radius )
			inner_r1 = min_radius;
d1736 1
a1736 1
		if( end2 == END_OPEN )
d1738 3
a1740 3
			r2a = r2;
			inner_r2 = r2 - thick/sin_ang;
			VMOVE( top , grid_pts[pt2] );
d1742 1
a1742 1
		else
d1744 3
a1746 3
			r2a = r2 + (r1 - r2)*thick/length;
			inner_r2 = r2a - thick/sin_ang;
			VJOIN1( top , grid_pts[pt2] , -thick , height_dir );
d1749 1
a1749 1
		if( inner_r2 < 0.0 )
d1751 1
a1751 1
			fastf_t dist_to_new_top;
d1753 3
a1755 3
			dist_to_new_top = inner_r2 * length/(r2 - r1 );
			inner_r2 = min_radius;
			VJOIN1( top , top , -dist_to_new_top , height_dir );
d1757 2
a1758 2
		else if( inner_r2 < min_radius )
			inner_r2 = min_radius;
d1760 2
a1761 2
		VSUB2( inner_height , top , base );
		if( VDOT( inner_height , height ) <= 0.0 )
d1763 4
a1766 4
			bu_log( "ERROR: CCONE1 height (%f) too small for thickness (%f)\n" , length/25.4 , thick/25.4 );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			bu_log( "\tCCONE1 inner solid ignored\n" );
d1768 1
a1768 1
		else
d1770 1
a1770 1
			/* make inner tgc */
d1772 2
a1773 2
			inner_name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 2 );
			mk_trc_h( fdout , inner_name , base , inner_height , inner_r1 , inner_r2 );
d1775 3
a1777 3
			if( mk_addmember( inner_name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				rt_bomb( "CCONE1: mk_addmember failed\n" );
			bu_free( inner_name, "solid_name" );
d1780 3
a1782 3
		name = make_solid_name( CCONE1 , element_id , comp_id , group_id , 0 );
		mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
		bu_free( name, "solid_name" );
d1787 3
a1789 2
void
do_ccone2(void)
d1791 7
a1797 7
	int element_id;
	int pt1,pt2;
	int c1,c2;
	fastf_t ro1,ro2,ri1,ri2;
	vect_t height;
	char *name = (char *)NULL;
	struct wmember r_head;
d1799 2
a1800 2
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d1802 1
a1802 1
	if( !pass )
d1804 2
a1805 2
		make_region_name( group_id , comp_id );
		if( !get_line() )
d1807 4
a1810 4
			bu_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE2\n" );
d1812 1
a1812 1
		return;
d1815 2
a1816 2
	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );
d1818 2
a1819 2
	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );
d1821 2
a1822 2
	strncpy( field , &line[64] , 8 );
	ro1 = atof( field ) * 25.4;
d1824 2
a1825 2
	strncpy( field , &line[72] , 8 );
	c1 = atoi( field );
d1827 1
a1827 1
	if( !get_line() )
d1829 4
a1832 4
		bu_log( "Unexpected EOF while reading continuation card for CCONE2\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , c1 );
		rt_bomb( "CCONE2\n" );
d1835 2
a1836 2
	strncpy( field , line , 8 );
	c2 = atoi( field );
d1838 1
a1838 1
	if( c1 != c2 )
d1840 3
a1842 3
		bu_log( "WARNING: CCONE2 continuation flags disagree, %d vs %d\n" , c1 , c2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
d1845 2
a1846 2
	strncpy( field , &line[8] , 8 );
	ro2 = atof( field ) * 25.4;
d1848 2
a1849 2
	strncpy( field , &line[16] , 8 );
	ri1 = atof( field ) * 25.4;
d1851 2
a1852 2
	strncpy( field , &line[24] , 8 );
	ri2 = atof( field ) * 25.4;
d1854 1
a1854 1
	if( pt1 == pt2 )
d1856 4
a1859 4
		bu_log( "ERROR: CCONE2 has same endpoints %d and %d\n", pt1, pt2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
d1862 1
a1862 1
	if( ro1 < 0.0 || ro2 < 0.0 || ri1 < 0.0 || ri2 < 0.0 )
d1864 4
a1867 4
		bu_log( "ERROR: CCONE2 has illegal radii %f %f %f %f\n" , ro1, ro2, ri1, ri2 );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
d1870 2
a1871 2
	if( ro1 < min_radius )
		ro1 = min_radius;
d1873 2
a1874 2
	if( ro2 < min_radius )
		ro2 = min_radius;
d1876 1
a1876 1
	BU_LIST_INIT( &r_head.l );
d1878 1
a1878 1
	VSUB2( height , grid_pts[pt2] , grid_pts[pt1] );
d1880 1
a1880 1
	if( ri1 <= 0.0 && ri2 <= 0.0 )
d1882 3
a1884 3
		name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 0 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );
		bu_free( name, "solid_name" );
d1886 1
a1886 1
	else
d1888 2
a1889 2
		name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 1 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ro1 , ro2 );
d1891 3
a1893 3
		if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
			rt_bomb( "mk_addmember failed!\n" );
		bu_free( name, "solid_name" );
d1895 2
a1896 2
		if( ri1 < min_radius )
			ri1 = min_radius;
d1898 2
a1899 2
		if( ri2 < min_radius )
			ri2 = min_radius;
d1901 2
a1902 2
		name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 2 );
		mk_trc_h( fdout , name , grid_pts[pt1] , height , ri1 , ri2 );
d1904 3
a1906 3
		if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
			rt_bomb( "mk_addmember failed!\n" );
		bu_free( name, "solid_name" );
d1908 3
a1910 3
		name = make_solid_name( CCONE2 , element_id , comp_id , group_id , 0 );
		mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
		bu_free( name, "solid_name" );
d1914 3
a1916 2
void
do_ccone3(void)
d1918 6
a1923 6
	int element_id;
	int pt1, pt2, pt3, pt4, i;
	char *name;
	fastf_t ro[4], ri[4], len03, len01, len12, len23;
	vect_t diff, diff2, diff3, diff4;
	struct wmember r_head;
d1925 2
a1926 2
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d1928 1
a1928 1
	if( !pass )
d1930 2
a1931 2
		make_region_name( group_id , comp_id );
		if( !get_line() )
d1933 4
a1936 4
			bu_log( "Unexpected EOF while reading continuation card for CCONE3\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CCONE3\n" );
d1938 1
a1938 1
		return;
d1941 2
a1942 2
	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );
d1944 2
a1945 2
	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );
d1947 2
a1948 2
	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );
d1950 2
a1951 2
	strncpy( field , &line[48] , 8 );
	pt4 = atoi( field );
d1953 1
a1953 1
	strncpy( field, &line[72], 8 );
d1955 1
a1955 1
	if( !get_line() )
d1957 4
a1960 4
		bu_log( "Unexpected EOF while reading continuation card for CCONE3\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %8.8s\n",
			group_id, comp_id, element_id , field );
		rt_bomb( "CCONE3\n" );
d1963 1
a1963 1
	if( strncmp( field, line, 8 ) )
d1965 3
a1967 3
		bu_log( "WARNING: CCONE3 continuation flags disagree, %8.8s vs %8.8s\n" , field , line );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
d1970 1
a1970 1
	for( i=0 ; i<4 ; i++ )
d1972 3
a1974 3
		strncpy( field, &line[8*(i+1)], 8 );
		ro[i] = atof( field ) * 25.4;
		if( ro[i] < 0.0 )
d1976 4
a1979 4
			bu_log( "ERROR: CCONE3 has illegal radius %f\n", ro[i] );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			return;
d1981 2
a1982 2
		if( !strcmp( field, "        " ) )
			ro[i] = -1.0;
d1985 1
a1985 1
	for( i=0 ; i<4 ; i++ )
d1987 3
a1989 3
		strncpy( field, &line[32 + 8*(i+1)], 8 );
		ri[i] = atof( field ) * 25.4;
		if( ri[i] < 0.0 )
d1991 4
a1994 4
			bu_log( "ERROR: CCONE3 has illegal radius %f\n", ri[i] );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			return;
d1996 2
a1997 2
		if( !strcmp( field, "        " ) )
			ri[i] = -1.0;
d2000 3
a2002 3
	VSUB2( diff4, grid_pts[pt4], grid_pts[pt1] );
	VSUB2( diff3, grid_pts[pt3], grid_pts[pt1] );
	VSUB2( diff2, grid_pts[pt2], grid_pts[pt1] );
d2004 4
a2007 4
	len03 = MAGNITUDE( diff4 );
	len01 = MAGNITUDE( diff2 );
	len12 = MAGNITUDE( diff3 ) - len01;
	len23 = len03 - len01 - len12;
d2009 1
a2009 1
	for( i=0 ; i<4 ; i+=3 )
d2011 1
a2011 1
		if( ro[i] ==-1.0 )
d2013 1
a2013 1
			if( ri[i] == -1.0 )
d2015 4
a2018 4
				bu_log( "ERROR: both inner and outer radii at g%d of a CCONE3 are undefined\n", i+1 );
				bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
					group_id, comp_id, element_id );
				return;
d2020 2
a2021 2
			else
				ro[i] = ri[i];
d2024 2
a2025 2
		else if( ri[i] == -1.0 )
			ri[i] = ro[i];
d2028 1
a2028 1
	if( ro[1] == -1.0 )
d2030 4
a2033 4
		if( ro[2] != -1.0 )
			ro[1] = ro[0] + (ro[2] - ro[0]) * len01 / (len01 + len12);
		else
			ro[1] = ro[0] + (ro[3] - ro[0]) * len01 / len03;
d2035 1
a2035 1
	if( ro[2] == -1.0 )
d2037 4
a2040 4
		if( ro[1] != -1.0 )
			ro[2] = ro[1] + (ro[3] - ro[1]) * len12 / (len12 + len23);
		else
			ro[2] = ro[0] + (ro[3] - ro[0]) * (len01 + len12) / len03;
d2042 1
a2042 1
	if( ri[1] == -1.0 )
d2044 4
a2047 4
		if( ri[2] != -1.0 )
			ri[1] = ri[0] + (ri[2] - ri[0]) * len01 / (len01 + len12);
		else
			ri[1] = ri[0] + (ri[3] - ri[0]) * len01 / len03;
d2049 1
a2049 1
	if( ri[2] == -1.0 )
d2051 4
a2054 4
		if( ri[1] != -1.0 )
			ri[2] = ri[1] + (ri[3] - ri[1]) * len12 / (len12 + len23);
		else
			ri[2] = ri[0] + (ri[3] - ri[0]) * (len01 + len12) / len03;
d2057 1
a2057 1
	for( i=0 ; i<4 ; i++ )
d2059 4
a2062 4
		if( ro[i] < min_radius )
			ro[i] = min_radius;
		if( ri[i] < min_radius )
			ri[i] = min_radius;
d2065 1
a2065 1
	BU_LIST_INIT( &r_head.l );
d2067 1
a2067 1
	if( pt1 != pt2 )
d2069 1
a2069 1
		VSUB2( diff, grid_pts[pt2], grid_pts[pt1] );
d2071 2
a2072 2
		/* make first cone */
		if( ro[0] != min_radius || ro[1] != min_radius )
d2074 5
a2078 5
			name = make_solid_name( CCONE3, element_id, comp_id, group_id, 1 );
			mk_trc_h( fdout, name, grid_pts[pt1], diff, ro[0], ro[1] );
			if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );
			bu_free( name, "solid_name" );
d2080 2
a2081 2
			/* and the inner cone */
			if( ri[0] != min_radius || ri[1] != min_radius )
d2083 5
a2087 5
				name = make_solid_name( CCONE3, element_id, comp_id, group_id, 11 );
				mk_trc_h( fdout, name, grid_pts[pt1], diff, ri[0], ri[1] );
				if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
				bu_free( name, "solid_name" );
d2092 1
a2092 1
	if( pt2 != pt3 )
d2094 1
a2094 1
		VSUB2( diff, grid_pts[pt3], grid_pts[pt2] );
d2096 2
a2097 2
		/* make second cone */
		if( ro[1] != min_radius || ro[2] != min_radius )
d2099 5
a2103 5
			name = make_solid_name( CCONE3, element_id, comp_id, group_id, 2 );
			mk_trc_h( fdout, name, grid_pts[pt2], diff, ro[1], ro[2] );
			if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );
			bu_free( name, "solid_name" );
d2105 2
a2106 2
			/* and the inner cone */
			if( ri[1] != min_radius || ri[2] != min_radius )
d2108 5
a2112 5
				name = make_solid_name( CCONE3, element_id, comp_id, group_id, 22 );
				mk_trc_h( fdout, name, grid_pts[pt2], diff, ri[1], ri[2] );
				if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
				bu_free( name, "solid_name" );
d2117 1
a2117 1
	if( pt3 != pt4 )
d2119 1
a2119 1
		VSUB2( diff, grid_pts[pt4], grid_pts[pt3] );
d2121 2
a2122 2
		/* make third cone */
		if( ro[2] != min_radius || ro[3] != min_radius )
d2124 5
a2128 5
			name = make_solid_name( CCONE3, element_id, comp_id, group_id, 3 );
			mk_trc_h( fdout, name, grid_pts[pt3], diff, ro[2], ro[3] );
			if( mk_addmember( name , &r_head.l , NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_bomb( "mk_addmember failed!\n" );
			bu_free( name, "solid_name" );
d2130 2
a2131 2
			/* and the inner cone */
			if( ri[2] != min_radius || ri[3] != min_radius )
d2133 5
a2137 5
				name = make_solid_name( CCONE3, element_id, comp_id, group_id, 33 );
				mk_trc_h( fdout, name, grid_pts[pt3], diff, ri[2], ri[3] );
				if( mk_addmember( name , &r_head.l , NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_bomb( "mk_addmember failed!\n" );
				bu_free( name, "solid_name" );
d2142 3
a2144 3
	name = make_solid_name( CCONE3 , element_id , comp_id , group_id , 0 );
	mk_comb( fdout, name, &r_head.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1 );
	bu_free( name, "solid_name" );
d2147 20
a2166 1
void
d2169 3
a2171 3
	struct holes *hole_ptr = (struct holes *)NULL;
	struct holes *prev = (struct holes *)NULL;
	struct hole_list *hptr= (struct hole_list *)NULL;
d2173 1
a2173 1
	if( debug )
d2175 3
a2177 3
		bu_log( "Adding holes for group %d, component %d:\n", gr, comp );
		hptr = ptr;
		while( hptr )
d2179 2
a2180 2
			bu_log( "\t%d %d\n", hptr->group, hptr->component );
			hptr = hptr->next;
d2184 1
a2184 1
	if( do_skips )
d2186 1
a2186 1
		if( !skip_region(gr*1000 + comp) )
d2188 5
a2192 5
			/* add holes for this region to the list of regions to process */
			hptr = ptr;
			if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
				bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole\n" );
			while( hptr )
d2194 1
a2194 1
				if( do_skips == region_list_len )
d2196 4
a2199 4
					region_list_len += REGION_LIST_BLOCK;
					region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
					if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
						bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole (after realloc)\n" );
d2201 4
a2204 4
				region_list[do_skips++] = 1000*hptr->group + hptr->component;
				if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in Add_hole (after adding %d\n)\n", 1000*hptr->group + hptr->component );
				hptr = hptr->next;
d2209 1
a2209 1
	if( !hole_root )
d2211 7
a2217 7
		hole_root = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_root" );
		hole_root->group = gr;
		hole_root->component = comp;
		hole_root->type = type;
		hole_root->holes = ptr;
		hole_root->next = (struct holes *)NULL;
		return;
d2220 3
a2222 3
	hole_ptr = hole_root;
	prev = hole_root;
	while( hole_ptr )
d2224 6
a2229 6
		if( hole_ptr->group == gr &&
			hole_ptr->component == comp &&
			hole_ptr->type == type )
				break;
		prev = hole_ptr;
		hole_ptr = hole_ptr->next;
d2232 1
a2232 1
	if( hole_ptr && hole_ptr->group == gr && hole_ptr->component == comp && hole_ptr->type == type )
d2234 1
a2234 1
		struct hole_list *list;
d2236 3
a2238 3
		if( !hole_ptr->holes )
			hole_ptr->holes = ptr;
		else
d2240 4
a2243 4
			list = hole_ptr->holes;
			while( list->next )
				list = list->next;
			list->next = ptr;
d2246 1
a2246 1
	else
d2248 7
a2254 7
		prev->next = (struct holes *)bu_malloc( sizeof( struct holes ) , "Add_holes: hole_ptr->next" );
		hole_ptr = prev->next;
		hole_ptr->group = gr;
		hole_ptr->component = comp;
		hole_ptr->type = type;
		hole_ptr->holes = ptr;
		hole_ptr->next = (struct holes *)NULL;
d2258 3
a2260 2
void
do_hole_wall(int type)
d2262 6
a2267 6
	struct hole_list *list_ptr;
	struct hole_list *list_start;
	int group, comp;
	int igrp, icmp;
	int s_len;
	int col;
d2269 2
a2270 2
	if( debug )
		bu_log( "do_hole_wall: %s\n" , line );
d2272 2
a2273 2
	if( pass )
		return;
d2275 1
a2275 1
	if( type != HOLE && type != WALL )
d2277 2
a2278 2
		bu_log( "do_hole_wall: unrecognized type (%d)\n", type );
		bu_bomb( "do_hole_wall: unrecognized type\n" );
d2281 4
a2284 4
	/* eliminate trailing blanks */
	s_len = strlen( line );
	while( isspace(line[--s_len] ) )
		line[s_len] = '\0';
d2286 3
a2288 3
	s_len = strlen( line );
	if( s_len > 80 )
		s_len = 80;
d2290 2
a2291 2
	strncpy( field , &line[8] , 8 );
	group = atoi( field );
d2293 2
a2294 2
	strncpy( field , &line[16] , 8 );
	comp = atoi( field );
d2296 3
a2298 3
	list_start = (struct hole_list *)NULL;
	list_ptr = (struct hole_list *)NULL;
	col = 24;
d2300 1
a2300 1
	while( col < s_len )
d2302 2
a2303 2
		strncpy( field , &line[col] , 8 );
		igrp = atoi( field );
d2305 3
a2307 3
		col += 8;
		if( col >= s_len )
			break;
d2309 2
a2310 2
		strncpy( field , &line[col] , 8 );
		icmp = atoi( field );
d2312 1
a2312 1
		if( igrp >= 0 && icmp > 0 )
d2314 3
a2316 3
			if( igrp == group && comp == icmp )
				bu_log( "Hole or wall card references itself (ignoring): (%s)\n", line );
			else
d2318 1
a2318 1
				if( list_ptr )
d2320 2
a2321 2
					list_ptr->next = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_ptr = list_ptr->next;
d2323 1
a2323 1
				else
d2325 2
a2326 2
					list_ptr = (struct hole_list *)bu_malloc( sizeof( struct hole_list ) , "do_hole_wall: list_ptr" );
					list_start = list_ptr;
d2329 3
a2331 3
				list_ptr->group = igrp;
				list_ptr->component = icmp;
				list_ptr->next = (struct hole_list *)NULL;
d2335 1
a2335 1
		col += 8;
d2338 1
a2338 1
	Add_holes( type, group , comp , list_start );
a2340 24
int
get_line(void)
{
	int len;

	bzero( (void *)line , LINELEN );

	if( bu_fgets( line , LINELEN , fdin ) == (char *)NULL )
		return( 0 );

	len = strlen( line );
	if( line[len-1] != '\n' ) {
		/* long line skip over remainder of line */
		int c=1;

		while( c != '\n' && c != EOF )
			c = getc( fdin );
		if( c == EOF )
			return( 0 );
	} else
		line[len-1] = '\0';

	return( 1 );
}
d2342 2
a2343 2
void
Add_bot_face(int pt1, int pt2, int pt3, fastf_t thick, int pos)
d2346 1
a2346 1
	if( pt1 == pt2 || pt2 == pt3 || pt1 == pt3 )
d2348 2
a2349 2
		bu_log( "Add_bot_face: ignoring degenerate triangle in group %d component %d\n", group_id, comp_id );
		return;
d2352 2
a2353 2
	if( pos == 0 )	/* use default */
		pos = POS_FRONT;
d2355 1
a2355 1
	if( mode == PLATE_MODE )
d2357 1
a2357 1
		if( pos != POS_CENTER && pos != POS_FRONT )
d2359 2
a2360 2
			bu_log( "Add_bot_face: illegal postion parameter (%d), must be one or two (ignoring face for group %d component %d)\n" , pos, group_id, comp_id );
			return;
d2364 1
a2364 1
	if( face_count >= face_size )
d2366 8
a2373 8
		face_size += GRID_BLOCK;
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted before realloc of faces, thickness, and facemode\n" );
		faces = (int *)bu_realloc( (void *)faces,  face_size*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_realloc( (void *)thickness, face_size*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_realloc( (void *)facemode, face_size*sizeof( char ), "facemode" );
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted after realloc of faces, thickness, and facemode\n" );
d2376 3
a2378 3
	faces[face_count*3] = pt1;
	faces[face_count*3+1] = pt2;
	faces[face_count*3+2] = pt3;
d2380 1
a2380 1
	if( mode == PLATE_MODE )
d2382 2
a2383 2
		thickness[face_count] = thick;
		facemode[face_count] = pos;
d2385 1
a2385 1
	else
d2387 2
a2388 2
		thickness[face_count] = 0,0;
		facemode[face_count] = 0;
d2391 1
a2391 1
	face_count++;
d2393 2
a2394 2
	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted at end of Add_bot_face()\n" );
d2397 3
a2399 2
void
do_tri(void)
d2401 4
a2404 4
	int element_id;
	int pt1,pt2,pt3;
	fastf_t thick;
	int pos;
d2406 2
a2407 2
	if( debug )
		bu_log( "do_tri: %s\n" , line );
d2409 2
a2410 2
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d2412 2
a2413 2
	if( !bot )
		bot = element_id;
d2415 2
a2416 2
	if( !pass )
		return;
d2418 1
a2418 1
	if( faces == NULL )
d2420 9
a2428 9
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted before malloc of faces\n" );
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted after malloc of faces , thickness, and facemode\n" );
d2431 2
a2432 2
	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );
d2434 2
a2435 2
	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );
d2437 2
a2438 2
	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );
d2440 2
a2441 2
	thick = 0.0;
	pos = 0;
d2443 1
a2443 1
	if( mode == PLATE_MODE )
d2445 2
a2446 2
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;
d2448 4
a2451 4
		strncpy( field , &line[64] , 8 );
		pos = atoi( field );
		if( pos == 0 )
			pos = POS_FRONT;
d2453 2
a2454 2
		if( debug )
			bu_log( "\tplate mode: thickness = %f\n" , thick );
d2458 2
a2459 2
	if( do_plot )
		plot_tri( pt1, pt2, pt3 );
d2461 2
a2462 2
	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted before call to Add_bot_face()\n" );
d2464 1
a2464 1
	Add_bot_face( pt1, pt2, pt3, thick, pos );
d2466 2
a2467 2
	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted after call to Add_bot_face()\n" );
d2470 3
a2472 2
void
do_quad(void)
d2474 4
a2477 4
	int element_id;
	int pt1,pt2,pt3,pt4;
	fastf_t thick = 0.0;
	int pos = 0;
d2479 2
a2480 2
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d2482 2
a2483 2
	if( debug )
		bu_log( "do_quad: %s\n" , line );
d2485 2
a2486 2
	if( !bot )
		bot = element_id;
d2488 2
a2489 2
	if( !pass )
		return;
d2491 1
a2491 1
	if( faces == NULL )
d2493 5
a2497 5
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
d2500 2
a2501 2
	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );
d2503 2
a2504 2
	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );
d2506 2
a2507 2
	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );
d2509 2
a2510 2
	strncpy( field , &line[48] , 8 );
	pt4 = atoi( field );
d2512 1
a2512 1
	if( mode == PLATE_MODE )
d2514 2
a2515 2
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;
d2517 2
a2518 2
		strncpy( field , &line[64] , 8 );
		pos = atoi( field );
d2520 2
a2521 2
		if( pos == 0 )	/* use default */
			pos = POS_FRONT;
d2523 1
a2523 1
		if( pos != POS_CENTER && pos != POS_FRONT )
d2525 3
a2527 3
			bu_log( "do_quad: illegal postion parameter (%d), must be one or two\n" , pos );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
d2531 2
a2532 2
	Add_bot_face( pt1, pt2, pt3, thick, pos );
	Add_bot_face( pt1, pt3, pt4, thick, pos );
a2534 16
int
skip_region( int id )
{
	int i;

	if( !do_skips )
		return( 0 );

	for( i=0 ; i<do_skips ; i++ )
	{
		if( id == region_list[i] )
			return( 0 );
	}

	return( 1 );
}
d2536 1
a2536 1
void
d2539 33
a2571 33
	int i;
	int max_pt = 0;
	int min_pt = 999999;
	int num_vertices;
	struct bu_bitv *bv = (struct bu_bitv *)NULL;
	int bot_mode;
	char *name = (char *)NULL;
	int element_id = bot;
	int count;
	struct rt_bot_internal bot_ip;

	if( !pass )
	{
		make_region_name( group_id , comp_id );
		return;
	}

	bot_ip.magic = RT_BOT_INTERNAL_MAGIC;
	for( i=0 ; i<face_count ; i++ )
	{
		V_MIN( min_pt, faces[i*3] );
		V_MAX( max_pt, faces[i*3] );
		V_MIN( min_pt, faces[i*3+1] );
		V_MAX( max_pt, faces[i*3+1] );
		V_MIN( min_pt, faces[i*3+2] );
		V_MAX( max_pt, faces[i*3+2] );
	}

	num_vertices = max_pt - min_pt + 1;
	bot_ip.num_vertices = num_vertices;
	bot_ip.vertices = (fastf_t *)bu_calloc( num_vertices*3, sizeof( fastf_t ), "BOT vertices" );
	for( i=0 ; i<num_vertices ; i++ )
		VMOVE( &bot_ip.vertices[i*3], grid_pts[min_pt+i] )
d2573 1
a2573 1
	for( i=0 ; i<face_count*3 ; i++ )
d2575 4
a2578 4
	bot_ip.num_faces = face_count;
	bot_ip.faces = bu_calloc( face_count*3, sizeof( int ), "BOT faces" );
	for( i=0 ; i<face_count*3 ; i++ )
		bot_ip.faces[i] = faces[i];
d2580 3
a2582 3
	bot_ip.face_mode = (struct bu_bitv *)NULL;
	bot_ip.thickness = (fastf_t *)NULL;
	if( mode == PLATE_MODE )
d2584 4
a2587 4
		bot_mode = RT_BOT_PLATE;
		bv = bu_bitv_new( face_count );
		bu_bitv_clear( bv );
		for( i=0 ; i<face_count ; i++ )
d2589 2
a2590 2
			if( facemode[i] == POS_FRONT )
				BU_BITSET( bv, i );
d2592 4
a2595 4
		bot_ip.face_mode = bv;
		bot_ip.thickness = (fastf_t *)bu_calloc( face_count, sizeof( fastf_t ), "BOT thickness" );
		for( i=0 ; i<face_count ; i++ )
			bot_ip.thickness[i] = thickness[i];
d2597 2
a2598 2
	else
		bot_mode = RT_BOT_SOLID;
d2600 3
a2602 3
	bot_ip.mode = bot_mode;
	bot_ip.orientation = RT_BOT_UNORIENTED;
	bot_ip.bot_flags = 0;
d2604 3
a2606 3
	count = rt_bot_vertex_fuse( &bot_ip );
	if( count )
		(void)rt_bot_condense( &bot_ip );
d2608 3
a2610 3
	count = rt_bot_face_fuse( &bot_ip );
	if( count )
		bu_log( "WARNING: %d duplicate faces eliminated from group %d component %d\n", count, group_id, comp_id );
d2612 4
a2615 4
	name = make_solid_name( BOT , element_id , comp_id , group_id , 0 );
	mk_bot( fdout, name, bot_mode, RT_BOT_UNORIENTED, 0, bot_ip.num_vertices, bot_ip.num_faces, bot_ip.vertices,
		bot_ip.faces, bot_ip.thickness, bot_ip.face_mode );
	bu_free( name, "solid_name" );
d2617 1
a2617 1
	if( mode == PLATE_MODE )
d2619 2
a2620 2
		bu_free( (char *)bot_ip.thickness, "BOT thickness" );
		bu_free( (char *)bot_ip.face_mode, "BOT face_mode" );
d2622 2
a2623 2
	bu_free( (char *)bot_ip.vertices, "BOT vertices" );
	bu_free( (char *)bot_ip.faces, "BOT faces" );
d2627 2
a2628 1
void
d2631 1
a2631 1
	long section_start;
d2633 8
a2640 8
	/* skip to start of next section */
	section_start = ftell( fdin );
	if( get_line() )
	{
		while( line[0] && strncmp( line, "SECTION" , 7 ) &&
				strncmp( line, "HOLE", 4 ) &&
				strncmp( line, "WALL", 4 ) &&
				strncmp( line, "VEHICLE", 7 ) )
d2642 3
a2644 3
			section_start = ftell( fdin );
			if( !get_line() )
				break;
d2647 2
a2648 2
	/* seek to start of the section */
	fseek( fdin, section_start, SEEK_SET );
d2651 1
d2655 2
a2656 2
void
do_section(int final)
d2658 2
a2659 2
	int found;
	struct name_tree *nm_ptr;
d2661 2
a2662 2
	if( debug )
		bu_log( "do_section(%d): %s\n", final , line );
d2664 1
a2664 1
	if( pass )	/* doing geometry */
d2666 1
a2666 1
		if( region_id && !skip_region( region_id ) )
d2668 1
a2668 1
			comp_count++;
d2670 2
a2671 2
			if( bot )
				make_bot_object();
d2673 2
a2674 2
		if( final && debug ) /* The ENDATA card has been found */
			List_names();
d2676 1
a2676 1
	else if( bot )
d2678 1
a2678 1
		make_region_name( group_id , comp_id );
d2681 1
a2681 1
	if( !final )
d2683 2
a2684 2
		strncpy( field , &line[8] , 8 );
		group_id = atoi( field );
d2686 2
a2687 2
		strncpy( field , &line[16] , 8 );
		comp_id = atoi( field );
d2689 1
a2689 1
		region_id = group_id * 1000 + comp_id;
d2691 1
a2691 1
		if( skip_region( region_id ) ) /* do not process this component */
d2693 2
a2694 2
			skip_section();
			return;
d2697 1
a2697 1
		if( comp_id > 999 )
d2699 2
a2700 2
			bu_log( "Illegal component id number %d, changed to 999\n" , comp_id );
			comp_id = 999;
d2703 3
a2705 3
		strncpy( field , &line[24] , 8 );
		mode = atoi( field );
		if( mode != 1 && mode != 2 )
d2707 3
a2709 3
			bu_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
				mode, group_id, comp_id );
			mode = 2;
d2712 1
a2712 1
		if( !pass )
d2714 5
a2718 5
			nm_ptr = Search_ident( name_root, region_id, &found );
			if( found && nm_ptr->mode != mode ) {
				bu_log( "ERROR: second SECTION card found with different mode for component (group=%d, component=%d), conversion of this component will be incorrect!!!\n",
					group_id, comp_id );
			}
d2722 2
a2723 2
	bot = 0;
	face_count = 0;
d2726 3
a2728 2
void
do_hex1(void)
d2730 6
a2735 6
	fastf_t thick=0.0;
	int pos;
	int pts[8];
	int element_id;
	int i;
	int cont1,cont2;
d2737 2
a2738 2
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d2740 2
a2741 2
	if( !bot )
		bot = element_id;
d2743 1
a2743 1
	if( !pass )
d2745 1
a2745 1
		if( !get_line() )
d2747 4
a2750 4
			bu_log( "Unexpected EOF while reading continuation card for CHEX1\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CHEX1\n" );
d2752 1
a2752 1
		return;
d2755 1
a2755 1
	if( faces == NULL )
d2757 5
a2761 5
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
d2764 1
a2764 1
	for( i=0 ; i<6 ; i++ )
d2766 2
a2767 2
		strncpy( field , &line[24 + i*8] , 8 );
		pts[i] = atoi( field );
d2770 2
a2771 2
	strncpy( field , &line[72] , 8 );
	cont1 = atoi( field );
d2773 1
a2773 1
	if( !get_line() )
d2775 4
a2778 4
		bu_log( "Unexpected EOF while reading continuation card for CHEX1\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , cont1 );
		rt_bomb( "CHEX1\n" );
d2781 2
a2782 2
	strncpy( field , line , 8 );
	cont2 = atoi( field );
d2784 1
a2784 1
	if( cont1 != cont2 )
d2786 4
a2789 4
		bu_log( "Continuation card numbers do not match for CHEX1 element (%d vs %d)\n", cont1 , cont2 );
		bu_log( "\tskipping CHEX1 element: group_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
d2792 2
a2793 2
	strncpy( field , &line[8] , 8 );
	pts[6] = atoi( field );
d2795 2
a2796 2
	strncpy( field , &line[16] , 8 );
	pts[7] = atoi( field );
d2798 1
a2798 1
	if( mode == PLATE_MODE )
d2800 3
a2802 3
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;
		if( thick <= 0.0 )
d2804 3
a2806 3
			bu_log( "do_hex1: illegal thickness (%f), skipping CHEX1 element\n" , thick );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
d2809 2
a2810 2
		strncpy( field , &line[64] , 8 );
		pos = atoi( field );
d2812 2
a2813 2
		if( pos == 0 )	/* use default */
			pos = POS_FRONT;
d2815 1
a2815 1
		if( pos != POS_CENTER && pos != POS_FRONT )
d2817 3
a2819 3
			bu_log( "do_hex1: illegal postion parameter (%d), must be 1 or 2, skipping CHEX1 element\n" , pos );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
d2822 1
a2822 1
	else
d2824 2
a2825 2
		pos =  POS_FRONT;
		thick = 0.0;
d2828 2
a2829 2
	for( i=0 ; i<12 ; i++ )
		Add_bot_face( pts[hex_faces[i][0]], pts[hex_faces[i][1]], pts[hex_faces[i][2]], thick, pos );
d2832 3
a2834 2
void
do_hex2(void)
d2836 6
a2841 6
	int pts[8];
	int element_id;
	int i;
	int cont1,cont2;
	point_t points[8];
	char *name = (char *)NULL;
d2843 2
a2844 2
	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );
d2846 1
a2846 1
	if( !pass )
d2848 2
a2849 2
		make_region_name( group_id , comp_id );
		if( !get_line() )
d2851 4
a2854 4
			bu_log( "Unexpected EOF while reading continuation card for CHEX2\n" );
			bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d\n",
				group_id, comp_id, element_id );
			rt_bomb( "CHEX2\n" );
d2856 1
a2856 1
		return;
d2859 1
a2859 1
	for( i=0 ; i<6 ; i++ )
d2861 2
a2862 2
		strncpy( field , &line[24 + i*8] , 8 );
		pts[i] = atoi( field );
d2865 2
a2866 2
	strncpy( field , &line[72] , 8 );
	cont1 = atoi( field );
d2868 1
a2868 1
	if( !get_line() )
d2870 4
a2873 4
		bu_log( "Unexpected EOF while reading continuation card for CHEX2\n" );
		bu_log( "\tgroup_id = %d, comp_id = %d, element_id = %d, c1 = %d\n",
			group_id, comp_id, element_id , cont1 );
		rt_bomb( "CHEX2\n" );
d2876 2
a2877 2
	strncpy( field , line , 8 );
	cont2 = atoi( field );
d2879 1
a2879 1
	if( cont1 != cont2 )
d2881 4
a2884 4
		bu_log( "Continuation card numbers do not match for CHEX2 element (%d vs %d)\n", cont1 , cont2 );
		bu_log( "\tskipping CHEX2 element: group_id = %d, comp_id = %d, element_id = %d\n",
			group_id, comp_id, element_id );
		return;
d2887 2
a2888 2
	strncpy( field , &line[8] , 8 );
	pts[6] = atoi( field );
d2890 2
a2891 2
	strncpy( field , &line[16] , 8 );
	pts[7] = atoi( field );
d2893 2
a2894 2
	for( i=0 ; i<8 ; i++ )
		VMOVE( points[i] , grid_pts[pts[i]] );
d2896 3
a2898 3
	name = make_solid_name( CHEX2 , element_id , comp_id , group_id , 0 );
	mk_arb8( fdout , name , &points[0][X] );
	bu_free( name, "solid_name" );
d2902 2
a2903 1
void
d2906 23
a2928 23
	if( debug )
		bu_log( "Process_hole_wall\n" );
	if( bu_debug & BU_DEBUG_MEM_CHECK )
		bu_prmem( "At start of Process_hole_wall:" );

	rewind( fdin );
	while( 1 )
	{
		if( !strncmp( line , "HOLE" , 4 ) )
			do_hole_wall( HOLE );
		else if( !strncmp( line , "WALL" , 4 ) )
			do_hole_wall( WALL );
		else if( !strncmp( line , "COMPSPLT", 8 ) )
			do_compsplt();
		else if( !strncmp( line, "SECTION", 7 ) )
		{
			strncpy( field , &line[24] , 8 );
			mode = atoi( field );
			if( mode != 1 && mode != 2 )
			{
				bu_log( "Illegal mode (%d) for group %d component %d, using volume mode\n",
					mode, group_id, comp_id );
				mode = 2;
d2931 2
a2932 2
		else if( !strncmp( line , "ENDDATA" , 7 ) )
			break;
d2934 2
a2935 2
		if( !get_line() || !line[0] )
			break;
d2938 1
a2938 1
	if( debug )
d2940 2
a2941 2
		bu_log( "At end of Process_hole_wall:\n" );
		List_holes();
d2945 3
a2947 2
void
do_chgcomp(void)
d2950 2
a2951 2
	if( !pass )
		return;
d2953 2
a2954 2
	if( !fd_muves )
		return;
d2956 1
a2956 1
	fprintf( fd_muves, "%s", line );
d2959 3
a2961 2
void
do_cbacking(void)
d2963 2
a2964 2
	int gr1, co1, gr2, co2, material;
	fastf_t thickness, probability;
d2966 2
a2967 2
	if( !pass )
		return;
d2969 2
a2970 2
	if( !fd_muves )
		return;
d2972 2
a2973 2
	strncpy( field, &line[8], 8 );
	gr1 = atoi( field );
d2975 2
a2976 2
	strncpy( field, &line[16], 8 );
	co1 = atoi( field );
d2978 2
a2979 2
	strncpy( field, &line[24], 8 );
	gr2 = atoi( field );
d2981 2
a2982 2
	strncpy( field, &line[32], 8 );
	co2 = atoi( field );
d2984 2
a2985 2
	strncpy( field, &line[40], 8 );
	thickness = atof( field ) * 25.4;
d2987 2
a2988 2
	strncpy( field, &line[48], 8 );
	probability = atof( field );
d2990 2
a2991 2
	strncpy( field, &line[56], 8 );
	material = atoi( field );
d2993 1
a2993 1
	fprintf( fd_muves, "CBACKING %d %d %g %g %d\n", gr1*1000+co1, gr2*1000+co2, thickness, probability, material );
d2996 2
a2997 1
int
d3001 56
a3056 56
	if( debug )
		bu_log( "\n\nProcess_input( pass = %d )\n" , pass_number );
	if( bu_debug & BU_DEBUG_MEM_CHECK )
		bu_prmem( "At start of Process_input:" );

	if( pass_number != 0 && pass_number != 1 )
	{
		bu_log( "Process_input: illegal pass number %d\n" , pass_number );
		rt_bomb( "Process_input" );
	}

	region_id = 0;
	pass = pass_number;
	if( !get_line() || !line[0] )
		strcpy( line, "ENDDATA" );
	while( 1 )
	{
		if( !strncmp( line , "VEHICLE" , 7 ) )
			do_vehicle();
		else if( !strncmp( line , "HOLE" , 4 ) )
			;
		else if( !strncmp( line , "WALL" , 4 ) )
			;
		else if( !strncmp( line , "COMPSPLT", 8 ) )
			;
		else if( !strncmp( line, "CBACKING", 8 ) )
			do_cbacking();
		else if( !strncmp( line, "CHGCOMP", 7 ) )
			do_chgcomp();
		else if( !strncmp( line , "SECTION" , 7 ) )
			do_section( 0 );
		else if( !strncmp( line , "$NAME" , 5 ) )
			do_name();
		else if( !strncmp( line , "$COMMENT" , 8 ) )
			;
		else if( !strncmp( line , "GRID" , 4 ) )
			do_grid();
		else if( !strncmp( line , "CLINE" , 5 ) )
			do_cline();
		else if( !strncmp( line , "CHEX1" , 5 ) )
			do_hex1();
		else if( !strncmp( line , "CHEX2" , 5 ) )
			do_hex2();
		else if( !strncmp( line , "CTRI" , 4 ) )
			do_tri();
		else if( !strncmp( line , "CQUAD" , 5 ) )
			do_quad();
		else if( !strncmp( line , "CCONE1" , 6 ) )
			do_ccone1();
		else if( !strncmp( line , "CCONE2" , 6 ) )
			do_ccone2();
		else if( !strncmp( line , "CCONE3" , 6 ) )
			do_ccone3();
		else if( !strncmp( line , "CSPHERE" , 7 ) )
			do_sphere();
		else if( !strncmp( line , "ENDDATA" , 7 ) )
d3058 2
a3059 2
			do_section( 1 );
			break;
d3061 2
a3062 2
		else
			bu_log( "ERROR: skipping unrecognized data type\n%s\n" , line );
d3064 2
a3065 2
		if( !get_line() || !line[0] )
			strcpy( line, "ENDDATA" );
d3068 1
a3068 1
	if( debug )
d3070 2
a3071 2
		bu_log( "At pass %d:\n" , pass );
		List_names();
d3074 1
a3074 1
	return( 0 );
d3077 1
d3083 1
a3083 1
void
d3086 7
a3092 7
	struct rt_db_internal   internal;
	struct rt_db_internal	internal2;
	struct directory	*dp2 = (struct directory *)NULL;
	struct rt_comb_internal *comb = (struct rt_comb_internal *)NULL;
	struct rt_comb_internal *comb2 = (struct rt_comb_internal *)NULL;
	union tree		*tree = (union tree *)NULL;
	union tree		*tree2 = (union tree *)NULL;
d3094 3
a3096 3
	/* only process regions */
	if( !(dp->d_flags & DIR_REGION) )
		return;
d3098 1
a3098 1
	if( rt_db_get_internal( &internal, dp, dbip, NULL, &rt_uniresource ) < 0 )
d3100 2
a3101 2
		bu_log( "Failed to get internal representation of %s\n", dp->d_namep );
		bu_bomb( "rt_db_get_internal() Failed!!!\n" );
d3104 1
a3104 1
	if( internal.idb_type != ID_COMBINATION )
d3106 2
a3107 2
		bu_log( "In fix_regions:%s is not a combination!!!!\n", dp->d_namep );
		bu_bomb( "Expecting a combination!!!!\n" );
d3110 2
a3111 2
	comb = (struct rt_comb_internal *)internal.idb_ptr;
	if( !comb->region_flag )
d3113 2
a3114 2
		bu_log( "%s is not a region!!!!\n", dp->d_namep );
		bu_bomb( "Expecting a region!!!!\n" );
d3116 2
a3117 2
	RT_CK_COMB( comb );
	tree = comb->tree;
d3119 1
a3119 1
	if( tree->tr_op != MKOP(12) )
d3121 2
a3122 2
		rt_db_free_internal( &internal , &rt_uniresource);
		return;
d3125 1
a3125 1
	/* only one element in tree */
d3127 1
a3127 1
	if( (dp2=db_lookup( dbip, tree->tr_l.tl_name, 0 )) == DIR_NULL )
d3129 3
a3131 3
		bu_log( "Could not find %s\n", tree->tr_l.tl_name );
		rt_db_free_internal( &internal , &rt_uniresource);
		return;
d3134 1
a3134 1
	if( rt_db_get_internal( &internal2, dp2, dbip, NULL, &rt_uniresource ) < 0 )
d3136 2
a3137 2
		bu_log( "Failed to get internal representation of %s\n", dp2->d_namep );
		bu_bomb( "rt_db_get_internal() Failed!!!\n" );
d3140 1
a3140 1
	if( internal2.idb_type != ID_COMBINATION )
d3142 3
a3144 3
		rt_db_free_internal( &internal , &rt_uniresource);
		rt_db_free_internal( &internal2 , &rt_uniresource);
		return;
d3147 2
a3148 2
	comb2 = (struct rt_comb_internal *)internal2.idb_ptr;
	RT_CK_COMB( comb2 );
d3150 2
a3151 2
	if( debug )
		bu_log( "Fixing region %s\n", dp->d_namep );
d3153 4
a3156 4
	/* move the second tree into the first */
	tree2 = comb2->tree;
	comb->tree = tree2;
	if( rt_db_put_internal( dp, dbip, &internal, &rt_uniresource ) < 0 )
d3158 2
a3159 2
		bu_log( "Failed to write region %s\n", dp->d_namep );
		bu_bomb( "rt_db_put_internal() failed!!!\n" );
d3162 3
a3164 3
	/* now kill the second combination */
	db_delete( dbip, dp2 );
	db_dirdelete( dbip, dp2 );
d3166 1
a3166 1
	db_free_tree( tree , &rt_uniresource);
d3170 2
a3171 1
void
d3174 2
a3175 2
	struct db_i *dbip = (struct db_i *)NULL;
	struct directory *dp = (struct directory *)NULL;
d3177 1
a3177 1
	bu_log( "Cleaning up please wait.....\n" );
d3179 1
a3179 1
	if ((dbip = db_open( output_file , "rw")) == DBI_NULL)
d3181 2
a3182 2
		bu_log( "Cannot open %s, post processing not completed\n", output_file );
		return;
d3185 2
a3186 2
	if( debug )
		bu_log( "Rescanning file\n" );
d3188 1
a3188 1
	db_dirbuild( dbip );
d3190 2
a3191 2
	if( debug )
		bu_log( "looking up 'all'\n" );
d3193 1
a3193 1
	if( (dp=db_lookup( dbip, "all", 0 )) == DIR_NULL )
d3195 3
a3197 3
		bu_log( "Cannot find group 'all' in model, post processing not completed\n" );
		db_close( dbip );
		return;
d3200 2
a3201 2
	if( debug )
		bu_log( "Calling db_functree\n" );
d3203 1
a3203 1
	db_functree( dbip, dp, fix_regions, 0, &rt_uniresource, NULL );
d3205 2
a3206 2
	if( debug )
		bu_log( "Post-processing complete\n" );
d3209 2
a3210 1
void
d3213 1
a3213 1
	char *ptr, *ptr2;
d3215 3
a3217 3
	region_list = (int *)bu_calloc( REGION_LIST_BLOCK, sizeof( int ), "region_list" );
	region_list_len = REGION_LIST_BLOCK;
	do_skips = 0;
d3219 2
a3220 2
	ptr = strtok( str, "," );
	while( ptr )
d3222 1
a3222 1
		if( (ptr2=strchr( ptr, '-')) )
d3224 1
a3224 1
			int i, start, stop;
d3226 7
a3232 7
			*ptr2 = '\0';
			ptr2++;
			start = atoi( ptr );
			stop = atoi( ptr2 );
			if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
				bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list\n" );
			for( i=start ; i<=stop ; i++ )
d3234 1
a3234 1
				if( do_skips == region_list_len )
d3236 4
a3239 4
					region_list_len += REGION_LIST_BLOCK;
					region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
					if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
						bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list (after realloc)\n" );
d3241 3
a3243 3
				region_list[do_skips++] = i;
				if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
					bu_log( "ERROR: bu_mem_barriercheck failed in make_region_list (after adding %d)\n", i );
d3246 1
a3246 1
		else
d3248 1
a3248 1
			if( do_skips == region_list_len )
d3250 2
a3251 2
				region_list_len += REGION_LIST_BLOCK;
				region_list = (int *)bu_realloc( (char *)region_list, region_list_len*sizeof( int ), "region_list" );
d3253 1
a3253 1
			region_list[do_skips++] = atoi( ptr );
d3255 1
a3255 1
		ptr = strtok( (char *)NULL, "," );
d3259 3
a3261 1
void make_regions(void)
d3263 11
a3273 11
	struct name_tree *ptr1, *ptr2;
	struct holes *hptr;
	struct hole_list *lptr;
	struct compsplt *splt;
	struct wmember region;
	struct wmember solids;
	struct wmember holes;
	char reg_name[LINELEN] = {0};
	char solids_name[LINELEN] = {0};
	char hole_name[LINELEN] = {0};
	char splt_name[LINELEN] = {0};
d3275 1
a3275 1
	BU_LIST_INIT( &holes.l );
d3277 4
a3280 4
	/* loop through the list of region names (by ident) */
	bu_ptbl_reset( &stack );
	ptr1 = name_root;
	while( 1 )
d3282 1
a3282 1
		while( ptr1 )
d3284 2
a3285 2
			PUSH( ptr1 );
			ptr1 = ptr1->rleft;
d3287 7
a3293 3
		POP( name_tree, ptr1 );
		if( !ptr1 )
			break;
d3295 5
a3299 9
		/* check if we are skipping some regions (but we might need all the holes) */
		if( skip_region( ptr1->region_id ) && !is_a_hole( ptr1->region_id ) )
			goto cont1;

		/* place all the solids for this ident in a "solids" combination */
		BU_LIST_INIT( &solids.l );
		bu_ptbl_reset( &stack2 );
		ptr2 = name_root;
		while( 1 )
d3301 1
a3301 1
			while( ptr2 )
d3303 2
a3304 2
				PUSH2( ptr2 );
				ptr2 = ptr2->nleft;
d3306 3
a3308 3
			POP2( name_tree, ptr2 );
			if( !ptr2 )
				break;
d3310 1
a3310 1
			if( ptr2->region_id == -ptr1->region_id && ptr2->inner == 0 )
d3312 2
a3313 2
				if( mk_addmember( ptr2->name, &solids.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", ptr1->name, ptr2->name );
d3316 18
a3333 1
			ptr2 = ptr2->nright;
d3336 21
a3356 2
		if( BU_LIST_IS_EMPTY( &solids.l ) )
			goto cont1;
d3358 4
a3361 40
		snprintf( solids_name, LINELEN, "solids_%d.s", ptr1->region_id );
		if( mk_comb( fdout, solids_name, &solids.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1) )
			bu_log("Failed to make combination of solids (%s)!!!!\n\tRegion %s is in ERROR!!!\n",
				solids_name, ptr1->name );

		/* hole components do not get made into regions */
		if( is_a_hole( ptr1->region_id ) )
		{
			/* just add it to the "holes" group */
			if( mk_addmember( solids_name, &holes.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to holes group\n", ptr1->name );
			goto cont1;
		}

		hptr = hole_root;
		while( hptr && hptr->group * 1000 + hptr->component != ptr1->region_id )
			hptr = hptr->next;
		if( hptr )
			lptr = hptr->holes;
		else
			lptr = (struct hole_list *)NULL;

		splt = compsplt_root;
		while( splt && splt->ident_to_split != ptr1->region_id )
			splt = splt->next;

		mode = ptr1->mode;
		if( debug )
			bu_log( "Build region for %s %d, mode = %d\n", ptr1->name, ptr1->region_id, mode );

		if( splt )
		{
			vect_t norm;
			struct name_tree *ptr2;
			int found;

			/* make a halfspace */
			VSET( norm, 0.0, 0.0, 1.0 );
			snprintf( splt_name, LINELEN, "splt_%d.s", ptr1->region_id );
			mk_half( fdout, splt_name, norm, splt->z );
d3363 4
a3366 4
			/* intersect halfspace with current region */
			BU_LIST_INIT( &region.l );
			if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );
d3368 2
a3369 2
			if( mk_addmember( splt_name, &region.l, NULL, WMOP_INTERSECT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", splt_name, ptr1->name );
d3371 1
a3371 1
			while( lptr )
d3373 4
a3376 4
				snprintf( hole_name, LINELEN, "solids_%d.s", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
d3378 1
a3378 1
			MK_REGION( fdout, &region, ptr1->name, ptr1->region_id, get_fast4_color(ptr1->region_id) )
d3382 2
a3383 2
			if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );
d3385 2
a3386 2
			if( mk_addmember( splt_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", splt_name, ptr1->name );
d3388 1
a3388 1
			while( lptr )
d3390 9
a3398 9
				snprintf( hole_name, LINELEN, "solids_%d.s", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
			}
			ptr2 = Search_ident( name_root, splt->new_ident, &found );
			if( found ) {
				MK_REGION( fdout, &region, ptr2->name, splt->new_ident, get_fast4_color(splt->new_ident) )
			} else {
d3401 1
a3401 1
			}
d3403 1
a3403 1
		else
d3405 3
a3407 3
			BU_LIST_INIT( &region.l );
			if( mk_addmember( solids_name, &region.l, NULL, WMOP_UNION ) == (struct wmember *)NULL )
				bu_log( "make_regions: mk_addmember failed to add %s to %s\n", solids_name, ptr1->name );
d3409 1
a3409 1
			while( lptr )
d3411 6
a3416 4
				snprintf( hole_name, LINELEN, "solids_%d.s", (lptr->group * 1000 + lptr->component) );
				if( mk_addmember( hole_name, &region.l, NULL, WMOP_SUBTRACT ) == (struct wmember *)NULL )
					bu_log( "make_regions: mk_addmember failed to add %s to %s\n", hole_name, ptr1->name );
				lptr = lptr->next;
d3418 2
a3419 4
			MK_REGION( fdout, &region, ptr1->name, ptr1->region_id, get_fast4_color(ptr1->region_id) )
		}
cont1:
		ptr1 = ptr1->rright;
d3422 1
a3422 1
	if( BU_LIST_NON_EMPTY( &holes.l ) )
d3424 3
a3426 3
		/* build a "holes" group */
		if( mk_comb( fdout, "holes", &holes.l, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 1, 1) )
			bu_log("Failed to make holes group!!!!\n" );
d3430 1
d3433 36
a3468 46
void read_fast4_colors(char *color_file) {
  FILE *fp;
  char line[COLOR_LINE_LEN] = {0};
  int low, high;
  int r, g, b;
  struct fast4_color *color;

  if ((fp = fopen(color_file, "r")) == (FILE *)NULL) {
    bu_log("Cannot open color file (%s)\n", color_file);
    return;
  }

  while (bu_fgets(line, COLOR_LINE_LEN, fp) != NULL) {
    if (sscanf(line, "%d %d %d %d %d", &low, &high, &r, &g, &b) != 5)
      continue;

    /* skip invalid colors */
    if (r < 0 || 255 < r ||
	g < 0 || 255 < g ||
	b < 0 || 255 < b)
      continue;

    /* skip bad region id ranges */
    if (high < low)
      continue;

    BU_GETSTRUCT(color, fast4_color);
    color->low = low;
    color->high = high;
    color->rgb[0] = r;
    color->rgb[1] = g;
    color->rgb[2] = b;
    BU_LIST_APPEND(&HeadColor.l, &color->l);
  }
}

unsigned char *
get_fast4_color(int r_id) {
  struct fast4_color *fcp;

  for (BU_LIST_FOR(fcp, fast4_color, &HeadColor.l)) {
    if (fcp->low <= r_id && r_id <= fcp->high)
      return fcp->rgb;
  }

  return (unsigned char *)NULL;
d3475 46
a3520 46
	int i;
	int c;
	char *plot_file=NULL;
	char *color_file=NULL;

	while( (c=bu_getopt( argc , argv , "qm:o:c:dwx:b:X:C:" ) ) != EOF )
	{
		switch( c )
		{
			case 'q':	/* quiet mode */
				quiet = 1;
				break;
			case 'm':
				if( (fd_muves=fopen( bu_optarg, "w" )) == (FILE *)NULL )
				{
					bu_log( "Unable to open MUVES file (%s)\n\tno MUVES file created\n",
						bu_optarg );
				}
				break;
			case 'o':	/* output a plotfile of original FASTGEN4 elements */
				do_plot = 1;
				plot_file = bu_optarg;
				break;
			case 'c':	/* convert only the specified components */
				make_region_list( bu_optarg );
				break;
			case 'd':	/* debug option */
				debug = 1;
				break;
			case 'w':	/* print warnings */
				warnings = 1;
				break;
			case 'x':
				sscanf( bu_optarg, "%x", (unsigned int *)&rt_debug );
				bu_debug = rt_debug;
				break;
			case 'b':
				sscanf( bu_optarg, "%x", (unsigned int *)&bu_debug );
				break;
			case 'C':
				color_file = bu_optarg;
				break;
			default:
				bu_log( "Unrecognzed option (%c)\n", c );
				rt_bomb( usage );
				break;
d3524 2
a3525 2
	if( bu_debug & BU_DEBUG_MEM_CHECK )
		bu_log( "doing memory checking\n" );
d3527 4
a3530 4
	if( argc-bu_optind != 2 ) {
		bu_log( usage );
		exit( 1 );
	}
d3532 1
a3532 1
	rt_init_resource( &rt_uniresource, 0, NULL );
d3534 1
a3534 1
	if( (fdin=fopen( argv[bu_optind] , "r" )) == (FILE *)NULL )
d3536 3
a3538 3
		bu_log( "Cannot open FASTGEN4 file (%s)\n" , argv[bu_optind] );
		perror( "fast4-g" );
		exit( 1 );
d3541 1
a3541 1
	if( (fdout=wdb_fopen( argv[bu_optind+1] )) == NULL )
d3543 3
a3545 3
		bu_log( "Cannot open file for output (%s)\n" , argv[bu_optind+1] );
		perror( "fast4-g" );
		exit( 1 );
d3548 1
a3548 1
	if( plot_file )
d3550 1
a3550 1
		if( (fd_plot=fopen( plot_file, "w")) == NULL )
d3552 2
a3553 2
			bu_log( "Cannot open plot file (%s)\n", plot_file );
			bu_bomb( usage );
d3557 1
a3557 1
	if(bu_debug )
d3559 2
a3560 2
		bu_printb( "librtbu_debug",bu_debug, DEBUG_FORMAT );
		bu_log("\n");
d3562 1
a3562 1
	if( rt_g.NMG_debug )
d3564 2
a3565 2
		bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
		bu_log("\n");
d3568 3
a3570 3
	BU_LIST_INIT(&HeadColor.l);
	if (color_file)
	  read_fast4_colors(color_file);
d3572 2
a3573 2
	grid_size = GRID_BLOCK;
	grid_pts = (point_t *)bu_malloc( grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
d3575 1
a3575 1
	cline_root = (struct cline *)NULL;
d3577 1
a3577 1
	name_root = (struct name_tree *)NULL;
d3579 1
a3579 1
	hole_root = (struct holes *)NULL;
d3581 1
a3581 1
	compsplt_root = (struct compsplt *)NULL;
d3583 1
a3583 1
	min_radius = 2.0 * sqrt( SQRT_SMALL_FASTF );
d3585 1
a3585 1
	name_count = 0;
d3587 1
a3587 1
	vehicle[0] = '\0';
d3589 2
a3590 2
	bu_ptbl_init( &stack , 64, " &stack ");
	bu_ptbl_init( &stack2 , 64, " &stack2 ");
d3592 2
a3593 2
	for( i=0 ; i<11 ; i++ )
		BU_LIST_INIT( &group_head[i].l );
d3595 1
a3595 1
	BU_LIST_INIT( &hole_head.l );
d3597 2
a3598 2
	if( !quiet )
		bu_log( "Scanning for HOLE, WALL, and COMPLSPLT cards...\n" );
d3600 1
a3600 1
	Process_hole_wall();
d3602 1
a3602 1
	rewind( fdin );
d3604 2
a3605 2
	if( !quiet )
		bu_log( "Building component names....\n" );
d3607 1
a3607 1
	Process_input( 0 );
d3609 1
a3609 1
	rewind( fdin );
d3611 3
a3613 3
	/* Make an ID record if no vehicle card was found */
	if( !vehicle[0] )
		mk_id_units( fdout , argv[bu_optind] , "in" );
d3615 2
a3616 2
	if( !quiet )
		bu_log( "Building components....\n" );
d3618 1
a3618 1
	while( Process_input( 1 ) );
d3620 2
a3621 2
	if( !quiet )
		bu_log( "Building regions and groups....\n" );
d3623 2
a3624 2
	/* make regions */
	make_regions();
d3626 2
a3627 2
	/* make groups */
	do_groups();
d3629 2
a3630 2
	if( debug )
		List_holes();
d3632 1
a3632 1
	wdb_close( fdout );
d3634 2
a3635 2
	if( !quiet )
		bu_log( "%d components converted\n", comp_count );
d3637 1
a3637 1
	return 0;
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.15 2007/01/23 01:13:25 brlcad Exp $";
d2287 1
a2287 1
	if( fgets( line , LINELEN , fdin ) == (char *)NULL )
d3408 1
a3408 1
  while (fgets(line, COLOR_LINE_LEN, fp) != NULL) {
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.14 2007/01/20 14:36:43 brlcad Exp $";
d195 2
a196 2
			  	ptr = (struct structure *)BU_PTBL_GET( &stack , BU_PTBL_END( &stack )-1 ); \
			  	bu_ptbl_rm( &stack , (long *)ptr ); \
d204 2
a205 2
			  	ptr = (struct structure *)BU_PTBL_GET( &stack2 , BU_PTBL_END( &stack2 )-1 ); \
			  	bu_ptbl_rm( &stack2 , (long *)ptr ); \
@


14.14
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.13 2006/08/14 16:25:31 brlcad Exp $";
@


14.13
log
@this should allow for longer length object names when performing a conversion instead of seemingly arbitrarily limiting the names to 16 characters.  this change is made in response to sf feature request 1539998 (FastGen to BRL-CAD converter truncates names) from ashleybomboy.
@
text
@d4 1
a4 1
 * Copyright (c) 1994-2006 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.12 2006/01/28 00:36:27 brlcad Exp $";
@


14.12
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.11 2006/01/18 06:46:13 brlcad Exp $";
d1172 1
a1172 1
		char name[20];
d1177 1
a1177 1
		sprintf( name , "%dxxx_series" , group_no );
d1197 2
a1198 2
	char comp_name[25];
	char tmp_name[25];
d1270 1
a1270 1
	char *tmp_name;
d1283 2
a1284 2
	name = (char *)bu_malloc( 12, "make_region_name" );
	sprintf( name , "comp_%04d.r" , r_id );
d1369 1
a1369 1
	char *name;
d1455 1
a1455 1
	strncpy( vehicle , &line[8] , 16 );
d1531 1
a1531 1
	char *name;
d1757 1
a1757 1
	char *name;
d2110 3
a2112 2
	struct holes *hole_ptr, *prev;
	struct hole_list *hptr;
d2518 2
a2519 1
	int max_pt=0, min_pt=999999;
d2521 1
a2521 1
	struct bu_bitv *bv=NULL;
d2523 2
a2524 2
	char *name;
	int element_id=bot;
d2815 1
a2815 1
	char *name;
d3055 7
a3061 4
	struct directory	*dp2;
	struct rt_db_internal   internal, internal2;
	struct rt_comb_internal *comb, *comb2;
	union tree		*tree, *tree2;
d3142 2
a3143 2
	struct db_i *dbip;
	struct directory *dp;
d3235 4
a3238 4
	char reg_name[16];
	char solids_name[16];
	char hole_name[16];
	char splt_name[16];
d3287 1
a3287 1
		sprintf( solids_name, "solids_%d", ptr1->region_id );
d3325 1
a3325 1
			sprintf( splt_name, "splt_%d.s", ptr1->region_id );
d3338 1
a3338 1
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
d3355 1
a3355 1
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
d3376 1
a3376 1
				sprintf( hole_name, "solids_%d", (lptr->group * 1000 + lptr->component) );
d3399 1
a3399 1
  char line[COLOR_LINE_LEN];
@


14.11
log
@update copyright to 2006
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.10 2005/12/23 21:26:29 bob1961 Exp $";
d42 1
@


14.10
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1994-2005 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.9 2005/10/23 04:44:29 brlcad Exp $";
@


14.9
log
@trailing ws
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.8 2005/09/09 09:44:08 brlcad Exp $";
d3448 1
a3448 1
	while( (c=getopt( argc , argv , "qm:o:c:dwx:b:X:C:" ) ) != EOF )
d3456 1
a3456 1
				if( (fd_muves=fopen( optarg, "w" )) == (FILE *)NULL )
d3459 1
a3459 1
						optarg );
d3464 1
a3464 1
				plot_file = optarg;
d3467 1
a3467 1
				make_region_list( optarg );
d3476 1
a3476 1
				sscanf( optarg, "%x", (unsigned int *)&rt_debug );
d3480 1
a3480 1
				sscanf( optarg, "%x", (unsigned int *)&bu_debug );
d3483 1
a3483 1
				color_file = optarg;
d3495 1
a3495 1
	if( argc-optind != 2 ) {
d3502 1
a3502 1
	if( (fdin=fopen( argv[optind] , "r" )) == (FILE *)NULL )
d3504 1
a3504 1
		bu_log( "Cannot open FASTGEN4 file (%s)\n" , argv[optind] );
d3509 1
a3509 1
	if( (fdout=wdb_fopen( argv[optind+1] )) == NULL )
d3511 1
a3511 1
		bu_log( "Cannot open file for output (%s)\n" , argv[optind+1] );
d3581 1
a3581 1
		mk_id_units( fdout , argv[optind] , "in" );
@


14.8
log
@BRL-CAD not BRLCAD, consistency
@
text
@d29 1
a29 1
 *  
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.7 2005/01/30 20:30:19 brlcad Exp $";
d1981 1
a1981 1
			
d2266 1
a2266 1
			
@


14.7
log
@update copyright to 2005
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.6 2004/12/21 07:32:29 morrison Exp $";
d89 1
a89 1
static char	vehicle[17];		/* Title for BRLCAD model from VEHICLE card */
@


14.7.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d36 1
a36 1
static const char RCSid[] = "$Header$";
d89 1
a89 1
static char	vehicle[17];		/* Title for BRL-CAD model from VEHICLE card */
d1981 1
a1981 1

d2266 1
a2266 1

@


14.7.2.1
log
@Mods to use bu_getopt
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/fast4-g.c,v 14.7 2005/01/30 20:30:19 brlcad Exp $";
d3448 1
a3448 1
	while( (c=bu_getopt( argc , argv , "qm:o:c:dwx:b:X:C:" ) ) != EOF )
d3456 1
a3456 1
				if( (fd_muves=fopen( bu_optarg, "w" )) == (FILE *)NULL )
d3459 1
a3459 1
						bu_optarg );
d3464 1
a3464 1
				plot_file = bu_optarg;
d3467 1
a3467 1
				make_region_list( bu_optarg );
d3476 1
a3476 1
				sscanf( bu_optarg, "%x", (unsigned int *)&rt_debug );
d3480 1
a3480 1
				sscanf( bu_optarg, "%x", (unsigned int *)&bu_debug );
d3483 1
a3483 1
				color_file = bu_optarg;
d3495 1
a3495 1
	if( argc-bu_optind != 2 ) {
d3502 1
a3502 1
	if( (fdin=fopen( argv[bu_optind] , "r" )) == (FILE *)NULL )
d3504 1
a3504 1
		bu_log( "Cannot open FASTGEN4 file (%s)\n" , argv[bu_optind] );
d3509 1
a3509 1
	if( (fdout=wdb_fopen( argv[bu_optind+1] )) == NULL )
d3511 1
a3511 1
		bu_log( "Cannot open file for output (%s)\n" , argv[bu_optind+1] );
d3581 1
a3581 1
		mk_id_units( fdout , argv[bu_optind] , "in" );
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1994-2004 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/fast4-g.c,v 14.5 2004/12/21 06:58:41 morrison Exp $";
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a32 2
 *  
 *
d36 1
a36 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/fast4-g.c,v 14.4 2004/12/21 06:50:58 morrison Exp $";
@


14.4
log
@remove the old distribution notice section
@
text
@a34 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d38 1
a38 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/fast4-g.c,v 14.3 2004/12/18 06:50:50 morrison Exp $";
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a33 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
d41 1
a41 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/fast4-g.c,v 14.2 2004/12/18 02:38:09 morrison Exp $";
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file fast4-g.c
d45 1
a45 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/fast4-g.c,v 14.1 2004/11/16 19:42:12 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
d44 1
a44 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/fast4-g.c,v 1.6 2004/09/03 23:30:56 morrison Exp $";
@


1.6
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/fast4-g.c,v 1.5 2004/08/02 23:01:47 morrison Exp $";
d3595 10
@


1.5
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/fast4-g.c,v 1.4 2004/08/02 03:15:55 morrison Exp $";
d32 1
a32 1
#ifdef USE_STRING_H
@


1.4
log
@s/getline/get_line/ to avoid conflicting with the GNU extension
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/src/conv/fast4-g.c,v 1.3 2004/06/09 14:49:30 morrison Exp $";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.3
log
@add unistd.h header for getopt()
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/src/conv/fast4-g.c,v 1.2 2004/06/08 22:04:08 morrison Exp $";
d274 1
a274 1
int getline(void);
d1529 1
a1529 1
		if( !getline() )
d1554 1
a1554 1
	if( !getline() )
d1755 1
a1755 1
		if( !getline() )
d1777 1
a1777 1
	if( !getline() )
d1880 1
a1880 1
		if( !getline() )
d1904 1
a1904 1
	if( !getline() )
d2270 1
a2270 1
getline(void)
d2599 1
a2599 1
	if( getline() )
d2607 1
a2607 1
			if( !getline() )
d2707 1
a2707 1
		if( !getline() )
d2735 1
a2735 1
	if( !getline() )
d2810 1
a2810 1
		if( !getline() )
d2829 1
a2829 1
	if( !getline() )
d2894 1
a2894 1
		if( !getline() || !line[0] )
d2971 1
a2971 1
	if( !getline() || !line[0] )
d3021 1
a3021 1
		if( !getline() || !line[0] )
@


1.2
log
@obliterate externs.h
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header$";
d31 1
a31 2


d41 7
d49 1
d58 2
d61 1
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/fast4-g.c,v 11.83 2004/05/10 15:30:41 erikg Exp $";
a43 1
#include "externs.h"
@

