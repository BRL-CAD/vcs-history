head	14.35;
access;
symbols
	rel-7-10-4:14.26
	STABLE:14.26.0.2
	stable-branch:14.8
	rel-7-10-2:14.26
	rel-7-10-0:14.22
	rel-7-8-4:14.18
	rel-7-8-2:14.17
	rel-7-8-0:14.15
	trimnurbs-branch:14.15.0.2
	help:14.15
	temp_tag:14.12
	bobWinPort-20051223-freeze:14.9.2.1
	postmerge-20051223-bobWinPort:14.12
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.10
	rel-7-6-branch:14.10.0.2
	rel-7-6-0:14.10
	rel-7-4-2:14.9
	rel-7-4-branch:14.9.0.4
	bobWinPort:14.9.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.9
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.35
date	2007.12.31.20.25.13;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2007.12.17.14.48.50;	author bob1961;	state Exp;
branches;
next	14.33;

14.33
date	2007.12.16.15.59.37;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.11.21.20.49.05;	author erikgreenwald;	state Exp;
branches;
next	14.31;

14.31
date	2007.11.21.20.38.21;	author erikgreenwald;	state Exp;
branches;
next	14.30;

14.30
date	2007.11.21.19.05.59;	author erikgreenwald;	state Exp;
branches;
next	14.29;

14.29
date	2007.10.22.08.47.38;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.10.14.09.08.19;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.07.25.18.13.39;	author erikgreenwald;	state Exp;
branches;
next	14.25;

14.25
date	2007.05.19.06.53.33;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.05.18.23.53.45;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.05.18.23.42.12;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.27.01.41.32;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.07.09.19.17.15;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.05.01.02.21.53;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.04.29.03.02.18;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.01.28.22.46.16;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.01.23.03.14.49;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.12.23.21.26.29;	author bob1961;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.08.24.04.44.49;	author brlcad;	state Exp;
branches
	14.10.2.1;
next	14.9;

14.9
date	2005.05.28.02.14.50;	author brlcad;	state Exp;
branches
	14.9.2.1;
next	14.8;

14.8
date	2005.03.28.05.25.15;	author bob1961;	state Exp;
branches;
next	14.7;

14.7
date	2005.03.24.17.13.43;	author bob1961;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.18;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.23.06.05.42;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.38.18;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.50;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.09;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.19.30.06;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.08;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.49;	author morrison;	state Exp;
branches;
next	;

14.9.2.1
date	2005.09.08.16.23.20;	author bob1961;	state Exp;
branches;
next	;

14.10.2.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.35
log
@header cleanup, more address removal
@
text
@/*                         A S C 2 G . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file asc2g.c
 *
 *  This program generates a GED database from an
 *  ASCII GED data file.
 *
 *  Usage:  asc2g file.asc file.g
 *
 *  Authors -
 *  	Charles M Kennedy
 *  	Michael J Muuss
 *	Susanne Muuss, J.D.	 Converted to libwdb, Oct. 1990
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header$ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "bn.h"
#include "db.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "mater.h"


#define BUFSIZE			(16*1024)	/* input line buffer size */
#define TYPE_LEN			200
#define NAME_LEN			200

void		identbld(void), polyhbld(void), pipebld(void), particlebld(void);
void		solbld(void), arbnbld(void), clinebld(void), botbld(void), extrbld(void), sktbld(void);
int		combbld(void);
void		membbld(struct bu_list *headp), arsabld(void), arsbbld(void);
void		materbld(void), bsplbld(void), bsurfbld(void), zap_nl(void);
char		*nxt_spc(register char *cp);
void		strsolbld(void), nmgbld(void);

static union record	record;			/* GED database record */
char 		*buf = NULL;		/* Record input buffer */
char		name[NAME_LEN + 2] = {0};

FILE *ifp = NULL;
struct rt_wdb *ofp = NULL;
static int ars_ncurves = 0;
static int ars_ptspercurve = 0;
static int ars_curve = 0;
static int ars_pt = 0;
static char *ars_name = NULL;
static fastf_t **ars_curves = NULL;
static char *slave_name = "safe_interp";
static char *db_name = "_db";

static char usage[] = "\
Usage: asc2g file.asc file.g\n\
 Convert an ASCII BRL-CAD database to binary form\n\
";

char *aliases[] = {
    "attr",
    "color",
    "put",
    "title",
    "units",
    "find",
    "dbfind",
    "rm",
    (char *)0
};

int
incr_ars_pt(void)
{
    int ret=0;

    ars_pt++;
    if( ars_pt >= ars_ptspercurve )
	{
	    ars_curve++;
	    ars_pt = 0;
	    ret = 1;
	}

    if( ars_curve >= ars_ncurves )
	return( 2 );

    return( ret );
}

/*
 *			M A I N
 */
int
main(int argc, char *argv[])
{
    char c1[3];
#ifdef _WIN32
    _fmode = _O_BINARY;
#endif

    bu_debug = BU_DEBUG_COREDUMP;

    if( argc != 3 )
	bu_exit( 1, "%s", usage );

    Tcl_FindExecutable(argv[0]);

    ifp = fopen(argv[1],"r");
    if( !ifp )  perror(argv[1]);

    ofp = wdb_fopen(argv[2]);
    if( !ofp )  perror(argv[2]);
    if (ifp == NULL || ofp == NULL) {
	bu_exit(1, "asc2g: can't open files.");
    }

    rt_init_resource( &rt_uniresource, 0, NULL );

    if( bu_fgets( c1, 6, ifp ) == NULL ) {
	fclose(ifp); ifp = NULL;
	wdb_close(ofp); ofp = NULL;
	bu_exit(1, "Unexpected EOF\n");
    }

    /* new style ascii database */
    if (!strncmp(c1, "title", 5) || !strncmp(c1, "put ", 4) ) {
	Tcl_Interp     *interp;
	Tcl_Interp     *safe_interp;

	/* this is a Tcl script */


	/* No longer need ifp */
	fclose(ifp); ifp = NULL;

	BU_LIST_INIT(&rt_g.rtg_headwdb.l);

	interp = Tcl_CreateInterp();
	if (wdb_init_obj(interp, ofp, db_name) != TCL_OK ||
	    wdb_create_cmd(interp, ofp, db_name) != TCL_OK) {
	    bu_exit(1, "Failed to initialize wdb_obj!\n");
	}

	/* Create the safe interpreter */
	if ((safe_interp = Tcl_CreateSlave(interp, slave_name, 1)) == NULL) {
	    bu_exit(1, "Failed to create safe interpreter");
	}

	/* Create aliases */
	{
	    int	i;
	    int	ac = 1;
	    const char	*av[2];

	    av[1] = (char *)0;
	    for (i = 0; aliases[i] != (char *)0; ++i) {
		av[0] = aliases[i];
		Tcl_CreateAlias(safe_interp, aliases[i], interp, db_name, ac, av);
	    }
	    /* add "dbfind" separately */
	    av[0] = "find";
	    Tcl_CreateAlias(safe_interp, "dbfind", interp, db_name, ac, av);
	}

	if( Tcl_EvalFile( safe_interp, argv[1] ) != TCL_OK ) {
	    bu_log( "Failed to process input file (%s)!\n", argv[1] );
	    bu_log( "%s\n", Tcl_GetStringResult(safe_interp) );
	    Tcl_Exit(1);
	}

	/* free up our resources */
	mk_write_color_table( ofp );
	wdb_close(ofp); ofp = NULL;

	Tcl_Exit(0);
    } else {
	rewind( ifp );
    }

    /* allocate our input buffer */
    buf = (char *)bu_calloc( sizeof(char), BUFSIZE, "input buffer" );

    /* Read ASCII input file, each record on a line */
    while( ( bu_fgets( buf, BUFSIZE, ifp ) ) != (char *)0 )  {

    after_read:
	/* Clear the output record -- vital! */
	(void)memset((char *)&record, 0, sizeof(record));

	/* Check record type */
	switch( buf[0] )  {
	    case ID_SOLID:
		solbld();
		continue;

	    case ID_COMB:
		if( combbld() > 0 )  goto after_read;
		continue;

	    case ID_MEMB:
		bu_log("Warning: unattached Member record, ignored\n");
		continue;

	    case ID_ARS_A:
		arsabld();
		continue;

	    case ID_ARS_B:
		arsbbld();
		continue;

	    case ID_P_HEAD:
		polyhbld();
		continue;

	    case ID_P_DATA:
		bu_log("Unattached POLY-solid P_DATA (Q) record, skipping\n");
		continue;

	    case ID_IDENT:
		identbld();
		continue;

	    case ID_MATERIAL:
		materbld();
		continue;

	    case ID_BSOLID:
		bsplbld();
		continue;

	    case ID_BSURF:
		bsurfbld();
		continue;

	    case DBID_PIPE:
		pipebld();
		continue;

	    case DBID_STRSOL:
		strsolbld();
		continue;

	    case DBID_NMG:
		nmgbld();
		continue;

	    case DBID_PARTICLE:
		particlebld();
		continue;

	    case DBID_ARBN:
		arbnbld();
		continue;

	    case DBID_CLINE:
		clinebld();
		continue;

	    case DBID_BOT:
		botbld();
		continue;

	    case DBID_EXTR:
		extrbld();
		continue;

	    case DBID_SKETCH:
		sktbld();
		continue;

	    default:
		bu_log("asc2g: bad record type '%c' (0%o), skipping\n", buf[0], buf[0]);
		bu_log("%s\n", buf );
		continue;
	}
	memset(buf, 0, sizeof(char) * BUFSIZE);
    }

    /* Now, at the end of the database, dump out the entire
     * region-id-based color table.
     */
    mk_write_color_table( ofp );

    /* close up shop */
    bu_free(buf, "input buffer");
    buf = NULL; /* sanity */
    fclose(ifp); ifp = NULL;
    wdb_close(ofp); ofp = NULL;

    Tcl_Exit(0);
    return 0;
}

/*
 *			S T R S O L B L D
 *
 *  Input format is:
 *	s type name args...\n
 *
 *  Individual processing is needed for each 'type' of solid,
 *  to hand it off to the appropriate LIBWDB routine.
 */
void
strsolbld(void)
{
    char	*type = NULL;
    char	*name = NULL;
    char	*args = NULL;
    struct bu_vls	str;
    char *buf2 = (char *)bu_malloc(sizeof(char) * BUFSIZE, "strsolbld temporary buffer");
    char *bufp = buf2;

    memcpy(buf2, buf, sizeof(char) * BUFSIZE);

    bu_vls_init(&str);

#if defined (HAVE_STRSEP)
    (void)strsep( &buf2, " ");		/* skip stringsolid_id */
    type = strsep( &buf2, " ");
    name = strsep( &buf2, " " );
    args = strsep( &buf2, "\n" );
#else
    (void)strtok( buf, " ");		/* skip stringsolid_id */
    type = strtok( NULL, " ");
    name = strtok( NULL, " " );
    args = strtok( NULL, "\n" );
#endif

    if( strcmp( type, "dsp" ) == 0 )  {
	struct rt_dsp_internal *dsp;

	BU_GETSTRUCT( dsp, rt_dsp_internal );
	bu_vls_init( &dsp->dsp_name );
	bu_vls_strcpy( &str, args );
	if( bu_struct_parse( &str, rt_functab[ID_DSP].ft_parsetab, (char *)dsp ) < 0 )  {
	    bu_log("strsolbld(%s): Unable to parse %s solid's args of '%s'\n",
		   name, type, args);
	    rt_dsp_ifree( (struct rt_db_internal *)dsp );
	    goto out;
	}
	dsp->magic = RT_DSP_INTERNAL_MAGIC;
	if( wdb_export( ofp, name, (genptr_t)dsp, ID_DSP, mk_conv2mm ) < 0 )  {
	    bu_log("strsolbld(%s): Unable to export %s solid, args='%s'\n",
		   name, type, args);
	    goto out;
	}
	/* 'dsp' has already been freed by wdb_export() */
    } else if ( strcmp(type, "ebm") == 0) {
	struct rt_ebm_internal *ebm;

	BU_GETSTRUCT( ebm, rt_ebm_internal );

	MAT_IDN(ebm->mat);

	bu_vls_strcpy( &str, args );
	if (bu_struct_parse( &str, rt_functab[ID_EBM].ft_parsetab, (char *)ebm) < 0) {
	    bu_log("strsolbld(%s): Unable to parse %s solid's args of '%s'\n",
		   name, type, args);
	    rt_ebm_ifree( (struct rt_db_internal *)ebm );
	    return;
	}
	ebm->magic = RT_EBM_INTERNAL_MAGIC;
	if (wdb_export(ofp, name, (genptr_t)ebm, ID_EBM, mk_conv2mm) < 0) {
	    bu_log("strsolbld(%s): Unable to export %s solid, args='%s'\n",
		   name, type, args);
	    goto out;
	}
	/* 'ebm' has already been freed by wdb_export() */
    } else if ( strcmp(type, "vol") == 0) {
	struct rt_vol_internal *vol;

	BU_GETSTRUCT( vol, rt_vol_internal );
	MAT_IDN(vol->mat);

	bu_vls_strcpy( &str, args );
	if (bu_struct_parse( &str, rt_functab[ID_VOL].ft_parsetab, (char *)vol) < 0) {
	    bu_log("strsolbld(%s): Unable to parse %s solid's args of '%s'\n",
		   name, type, args);
	    rt_vol_ifree( (struct rt_db_internal *)vol );
	    return;
	}
	vol->magic = RT_VOL_INTERNAL_MAGIC;
	if (wdb_export(ofp, name, (genptr_t)vol, ID_VOL, mk_conv2mm) < 0) {
	    bu_log("strsolbld(%s): Unable to export %s solid, args='%s'\n",
		   name, type, args);
	    goto out;
	}
	/* 'vol' has already been freed by wdb_export() */
    } else {
	bu_log("strsolbld(%s): unable to convert '%s' type solid, skipping\n",
	       name, type);
    }

 out:
    bu_free(bufp, "strsolbld temporary buffer");
    bu_vls_free(&str);
}

#define LSEG 'L'
#define CARC 'A'
#define NURB 'N'

void
sktbld(void)
{
    register char *cp, *ptr;
    int i, j;
    int vert_count, seg_count;
    float fV[3], fu[3], fv[3];
    point_t V;
    vect_t u, v;
    point2d_t *verts;
    char name[NAME_LEN+1];
    struct rt_sketch_internal *skt;
    struct curve *crv;
    struct line_seg *lsg;
    struct carc_seg *csg;
    struct nurb_seg *nsg;

    cp = buf;

    cp++;
    cp++;

    (void)sscanf( cp, "%200s %f %f %f %f %f %f %f %f %f %d %d", /* NAME_LEN */
		  name,
		  &fV[0], &fV[1], &fV[2],
		  &fu[0], &fu[1], &fu[2],
		  &fv[0], &fv[1], &fv[2],
		  &vert_count, &seg_count );

    VMOVE( V, fV );
    VMOVE( u, fu );
    VMOVE( v, fv );

    verts = (point2d_t *)bu_calloc( vert_count, sizeof( point2d_t ), "verts" );

    if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
	    bu_exit( -1, "Unexpected EOF while reading sketch (%s) data\n", name );

    verts = (point2d_t *)bu_calloc( vert_count, sizeof( point2d_t ), "verts" );
    cp = buf;
    ptr = strtok( buf, " " );
    if( !ptr )
	    bu_exit( 1, "ERROR: no vertices for sketch (%s)\n", name );
    for( i=0 ; i<vert_count ; i++ )
	{
	    verts[i][0] = atof( ptr );
	    ptr = strtok( (char *)NULL, " " );
	    if( !ptr )
		    bu_exit( 1, "ERROR: not enough vertices for sketch (%s)\n", name );
	    verts[i][1] = atof( ptr );
	    ptr = strtok( (char *)NULL, " " );
	    if( !ptr && i < vert_count-1 )
		    bu_exit( 1, "ERROR: not enough vertices for sketch (%s)\n", name );
	}

    skt = (struct rt_sketch_internal *)bu_calloc( 1, sizeof( struct rt_sketch_internal ), "sketch" );
    skt->magic = RT_SKETCH_INTERNAL_MAGIC;
    VMOVE( skt->V, V );
    VMOVE( skt->u_vec, u );
    VMOVE( skt->v_vec, v );
    skt->vert_count = vert_count;
    skt->verts = verts;
    crv = &skt->skt_curve;
    crv->seg_count = seg_count;

    crv->segments = (genptr_t *)bu_calloc( crv->seg_count, sizeof( genptr_t ), "segments" );
    crv->reverse = (int *)bu_calloc( crv->seg_count, sizeof( int ), "reverse" );
    for( j=0 ; j<crv->seg_count ; j++ )
	{
	    double radius;
	    int k;

	    if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
		    bu_exit( -1, "Unexpected EOF while reading sketch (%s) data\n", name );

	    cp = buf + 2;
	    switch( *cp )
		{
		    case LSEG:
			lsg = (struct line_seg *)bu_malloc( sizeof( struct line_seg ), "line segment" );
			sscanf( cp+1, "%d %d %d", &crv->reverse[j], &lsg->start, &lsg->end );
			lsg->magic = CURVE_LSEG_MAGIC;
			crv->segments[j] = lsg;
			break;
		    case CARC:
			csg = (struct carc_seg *)bu_malloc( sizeof( struct carc_seg ), "arc segment" );
			sscanf( cp+1, "%d %d %d %lf %d %d", &crv->reverse[j], &csg->start, &csg->end,
				&radius, &csg->center_is_left, &csg->orientation );
			csg->radius = radius;
			csg->magic = CURVE_CARC_MAGIC;
			crv->segments[j] = csg;
			break;
		    case NURB:
			nsg = (struct nurb_seg *)bu_malloc( sizeof( struct nurb_seg ), "nurb segment" );
			sscanf( cp+1, "%d %d %d %d %d", &crv->reverse[j], &nsg->order, &nsg->pt_type,
				&nsg->k.k_size, &nsg->c_size );
			nsg->k.knots = (fastf_t *)bu_calloc( nsg->k.k_size, sizeof( fastf_t ), "knots" );
			nsg->ctl_points = (int *)bu_calloc( nsg->c_size, sizeof( int ), "control points" );
			if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
				bu_exit( -1, "Unexpected EOF while reading sketch (%s) data\n", name );
			cp = buf + 3;
			ptr = strtok( cp, " " );
			if( !ptr )
				bu_exit( 1, "ERROR: not enough knots for nurb segment in sketch (%s)\n", name );
			for( k=0 ; k<nsg->k.k_size ; k++ )
			    {
				nsg->k.knots[k] = atof( ptr );
				ptr = strtok( (char *)NULL, " " );
				if( !ptr && k<nsg->k.k_size-1 )
					bu_exit( 1, "ERROR: not enough knots for nurb segment in sketch (%s)\n", name );
			    }
			if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
				bu_exit( -1, "Unexpected EOF while reading sketch (%s) data\n", name );
			cp = buf + 3;
			ptr = strtok( cp, " " );
			if( !ptr )
				bu_exit( 1, "ERROR: not enough control points for nurb segment in sketch (%s)\n", name );
			for( k=0 ; k<nsg->c_size ; k++ )
			    {
				nsg->ctl_points[k] = atoi( ptr );
				ptr = strtok( (char *)NULL, " " );
				if( !ptr && k<nsg->c_size-1 )
					bu_exit( 1, "ERROR: not enough control points for nurb segment in sketch (%s)\n", name );
			    }
			nsg->magic = CURVE_NURB_MAGIC;
			crv->segments[j] = nsg;
			break;
		    default:
			bu_exit( 1, "Unrecognized segment type (%c) in sketch (%s)\n", *cp, name );
		}

	}

    (void)mk_sketch(ofp, name,  skt );
}

void
extrbld(void)
{
    register char *cp;
    char name[NAME_LEN+1];
    char sketch_name[NAME_LEN+1];
    int keypoint;
    float fV[3];
    float fh[3];
    float fu_vec[3], fv_vec[3];
    point_t V;
    vect_t h, u_vec, v_vec;

    cp = buf;

    cp++;

    cp++;
    (void)sscanf( cp, "%200s %200s %d %f %f %f  %f %f %f %f %f %f %f %f %f", /* NAME_LEN */
		  name, sketch_name, &keypoint, &fV[0], &fV[1], &fV[2], &fh[0], &fh[1], &fh[2],
		  &fu_vec[0], &fu_vec[1], &fu_vec[2], &fv_vec[0], &fv_vec[1], &fv_vec[2] );

    VMOVE( V, fV );
    VMOVE( h, fh );
    VMOVE( u_vec, fu_vec );
    VMOVE( v_vec, fv_vec );
    (void)mk_extrusion( ofp, name, sketch_name, V, h, u_vec, v_vec, keypoint );
}

/*
 *			N M G B L D
 *
 *  For the time being, what we read in from the ascii form is
 *  a hex dump of the on-disk form of NMG.
 *  This is the same between v4 and v5.
 *  Reassemble it in v5 binary form here,
 *  then import it,
 *  then re-export it.
 *  This extra step is necessary because we don't know what version
 *  database the output it, LIBWDB is only interested in writing
 *  in-memory versions.
 */
void
nmgbld(void)
{
    register char *cp;
    int	version;
    char	*name;
    long	granules;
    long	struct_count[26];
    struct bu_external	ext;
    struct rt_db_internal	intern;
    int	j;

    /* First, process the header line */
    cp = strtok( buf, " " );
    /* This is nmg_id, unused here. */
    cp = strtok( NULL, " " );
    version = atoi(cp);
    cp = strtok( NULL, " " );
    name = bu_strdup( cp );
    cp = strtok( NULL, " " );
    granules = atol( cp );

    /* Allocate storage for external v5 form of the body */
    BU_INIT_EXTERNAL(&ext);
    ext.ext_nbytes = SIZEOF_NETWORK_LONG + 26*SIZEOF_NETWORK_LONG + 128 * granules;
    ext.ext_buf = bu_malloc( ext.ext_nbytes, "nmg ext_buf" );
    bu_plong( ext.ext_buf, version );
    BU_ASSERT_LONG( version, ==, 1 );	/* DISK_MODEL_VERSION */

    /* Get next line of input with the 26 counts on it */
    if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
	bu_exit(-1, "Unexpected EOF while reading NMG %s data, line 2\n", name );

    /* Second, process counts for each kind of structure */
    cp = strtok( buf , " " );
    for( j=0 ; j<26 ; j++ )
	{
	    struct_count[j] = atol( cp );
	    bu_plong( ((unsigned char *)ext.ext_buf)+
		      SIZEOF_NETWORK_LONG*(j+1), struct_count[j] );
	    cp = strtok( (char *)NULL , " " );
	}

    /* Remaining lines have 32 bytes per line, in hex */
    /* There are 4 lines to make up one granule */
    cp = ((char *)ext.ext_buf) + (26+1)*SIZEOF_NETWORK_LONG;
    for( j=0; j < granules * 4; j++ )  {
	int k;
	unsigned int cp_i;

	if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
		bu_exit( -1, "Unexpected EOF while reading NMG %s data, hex line %d\n", name, j );

	for( k=0 ; k<32 ; k++ )
	    {
		sscanf( &buf[k*2] , "%2x" , &cp_i );
		*cp++ = cp_i;
	    }
    }

    /* Next, import this disk record into memory */
    RT_INIT_DB_INTERNAL(&intern);
    if( rt_functab[ID_NMG].ft_import5( &intern, &ext, bn_mat_identity, ofp->dbip, &rt_uniresource, ID_NMG ) < 0 )
	bu_exit( -1, "ft_import5 failed on NMG %s\n", name );
    bu_free_external(&ext);

    /* Now we should have a good NMG in memory */
    nmg_vmodel( (struct model *)intern.idb_ptr );

    /* Finally, squirt it back out through LIBWDB */
    mk_nmg( ofp, name, (struct model *)intern.idb_ptr );
    /* mk_nmg() frees the intern.idp_ptr pointer */
    RT_INIT_DB_INTERNAL(&intern);

    bu_free( name, "name" );
}

/*		S O L B L D
 *
 * This routine parses a solid record and determines which libwdb routine
 * to call to replicate this solid.  Simple primitives are expected.
 */

void
solbld(void)
{
    register char *cp;
    register char *np;
    register int i;

    char	s_type;			/* id for the type of primitive */
    fastf_t	val[24];		/* array of values/parameters for solid */
    point_t	center;			/* center; used by many solids */
    point_t pnts[9];		/* array of points for the arbs */
    point_t	norm;
    vect_t	a, b, c, d, n;		/* various vectors required */
    vect_t	height;			/* height vector for tgc */
    vect_t	breadth;		/* breadth vector for rpc */
    double	dd, rad1, rad2;

    cp = buf;
    cp++;				/* ident */
    cp = nxt_spc( cp );		/* skip the space */
    s_type = atoi(cp);

    cp = nxt_spc( cp );

    np = name;
    while( *cp != ' ' )  {
	*np++ = *cp++;
    }
    *np = '\0';

    cp = nxt_spc( cp );
    /* Comgeom solid type */

    for( i = 0; i < 24; i++ )  {
	cp = nxt_spc( cp );
	val[i] = atof( cp );
    }

    /* Switch on the record type to make the solids. */

    switch( s_type ) {

	case GRP:
	    VSET(center, val[0], val[1], val[2]);
	    VSET(n, val[3], val[4], val[5]);
	    (void)mk_grip( ofp, name, center, n, val[6] );
	    break;

	case TOR:
	    VSET(center, val[0], val[1], val[2]);
	    VSET(n, val[3], val[4], val[5]);
	    rad1 = MAGNITUDE(&val[6]);
	    rad2 = MAGNITUDE(n);
	    VUNITIZE(n);

	    /* Prevent illegal torii from floating point fuzz */
	    if( rad2 > rad1 )  rad2 = rad1;

	    mk_tor(ofp, name, center, n, rad1, rad2);
	    break;

	case GENTGC:
	    VSET(center, val[0], val[1], val[2]);
	    VSET(height, val[3], val[4], val[5]);
	    VSET(a, val[6], val[7], val[8]);
	    VSET(b, val[9], val[10], val[11]);
	    VSET(c, val[12], val[13], val[14]);
	    VSET(d, val[15], val[16], val[17]);

	    mk_tgc(ofp, name, center, height, a, b, c, d);
	    break;

	case GENELL:
	    VSET(center, val[0], val[1], val[2]);
	    VSET(a, val[3], val[4], val[5]);
	    VSET(b, val[6], val[7], val[8]);
	    VSET(c, val[9], val[10], val[11]);

	    mk_ell(ofp, name, center, a, b, c);
	    break;

	case GENARB8:
	    VSET(pnts[0], val[0], val[1], val[2]);
	    VSET(pnts[1], val[3], val[4], val[5]);
	    VSET(pnts[2], val[6], val[7], val[8]);
	    VSET(pnts[3], val[9], val[10], val[11]);
	    VSET(pnts[4], val[12], val[13], val[14]);
	    VSET(pnts[5], val[15], val[16], val[17]);
	    VSET(pnts[6], val[18], val[19], val[20]);
	    VSET(pnts[7], val[21], val[22], val[23]);

	    /* Convert from vector notation to absolute points */
	    for( i=1; i<8; i++ )  {
		VADD2( pnts[i], pnts[i], pnts[0] );
	    }

	    mk_arb8(ofp, name, &pnts[0][X]);
	    break;

	case HALFSPACE:
	    VSET(norm, val[0], val[1], val[2]);
	    dd = val[3];

	    mk_half(ofp, name, norm, dd);
	    break;

	case RPC:
	    VSET( center, val[0], val[1], val[2] );
	    VSET( height, val[3], val[4], val[5] );
	    VSET( breadth, val[6], val[7], val[8] );
	    dd = val[9];

	    mk_rpc( ofp, name, center, height, breadth, dd );
	    break;

	case RHC:
	    VSET( center, val[0], val[1], val[2] );
	    VSET( height, val[3], val[4], val[5] );
	    VSET( breadth, val[6], val[7], val[8] );
	    rad1 = val[9];
	    dd = val[10];

	    mk_rhc( ofp, name, center, height, breadth, rad1, dd );
	    break;

	case EPA:
	    VSET( center, val[0], val[1], val[2] );
	    VSET( height, val[3], val[4], val[5] );
	    VSET( a, val[6], val[7], val[8] );
	    VUNITIZE( a );
	    rad1 = val[9];
	    rad2 = val[10];

	    mk_epa( ofp, name, center, height, a, rad1, rad2 );
	    break;

	case EHY:
	    VSET( center, val[0], val[1], val[2] );
	    VSET( height, val[3], val[4], val[5] );
	    VSET( a, val[6], val[7], val[8] );
	    VUNITIZE( a );
	    rad1 = val[9];
	    rad2 = val[10];
	    dd = val[11];

	    mk_ehy( ofp, name, center, height, a, rad1, rad2, dd );
	    break;

	case ETO:
	    VSET( center, val[0], val[1], val[2] );
	    VSET( norm, val[3], val[4], val[5] );
	    VSET( c, val[6], val[7], val[8] );
	    rad1 = val[9];
	    rad2 = val[10];

	    mk_eto( ofp, name, center, norm, c, rad1, rad2 );
	    break;

	default:
	    bu_log("asc2g: bad solid %s s_type= %d, skipping\n",
		   name, s_type);
    }

}


/*			C O M B B L D
 *
 *  This routine builds combinations.
 *  It does so by processing the "C" combination input line,
 *  (which may be followed by optional material properties lines),
 *  and it then slurps up any following "M" member lines,
 *  building up a linked list of all members.
 *  Reading continues until a non-"M" record is encountered.
 *
 *  Returns -
 *	0	OK
 *	1	OK, another record exists in global input line buffer.
 */
int
combbld(void)
{
    struct bu_list	head;
    register char 	*cp;
    register char 	*np;
    int 		temp_nflag, temp_pflag;

    char		override;
    char		reg_flags;	/* region flag */
    int		is_reg;
    short		regionid;
    short		aircode;
    short		material;	/* GIFT material code */
    short		los;		/* LOS estimate */
    unsigned char	rgb[3];		/* Red, green, blue values */
    char		matname[32];	/* String of material name */
    char		matparm[60];	/* String of material parameters */
    char		inherit;	/* Inheritance property */

    /* Set all flags initially. */
    BU_LIST_INIT( &head );

    override = 0;
    temp_nflag = temp_pflag = 0;	/* indicators for optional fields */

    cp = buf;
    cp++;				/* ID_COMB */
    cp = nxt_spc( cp );		/* skip the space */

    reg_flags = *cp++;		/* Y, N, or new P, F */
    cp = nxt_spc( cp );

    np = name;
    while( *cp != ' ' )  {
	*np++ = *cp++;
    }
    *np = '\0';

    cp = nxt_spc( cp );

    regionid = (short)atoi( cp );
    cp = nxt_spc( cp );
    aircode = (short)atoi( cp );
    cp = nxt_spc( cp );
    /* DEPRECTED: number of members expected */
    cp = nxt_spc( cp );
    /* DEPRECATED: Comgeom reference number */
    cp = nxt_spc( cp );
    material = (short)atoi( cp );
    cp = nxt_spc( cp );
    los = (short)atoi( cp );
    cp = nxt_spc( cp );
    override = (char)atoi( cp );
    cp = nxt_spc( cp );

    rgb[0] = (unsigned char)atoi( cp );
    cp = nxt_spc( cp );
    rgb[1] = (unsigned char)atoi( cp );
    cp = nxt_spc( cp );
    rgb[2] = (unsigned char)atoi( cp );
    cp = nxt_spc( cp );

    temp_nflag = atoi( cp );
    cp = nxt_spc( cp );
    temp_pflag = atoi( cp );

    cp = nxt_spc( cp );
    inherit = atoi( cp );

    /* To support FASTGEN, different kinds of regions now exist. */
    switch( reg_flags )  {
	case 'Y':
	case 'R':
	    is_reg = DBV4_REGION;
	    break;
	case 'P':
	    is_reg = DBV4_REGION_FASTGEN_PLATE;
	    break;
	case 'V':
	    is_reg = DBV4_REGION_FASTGEN_VOLUME;
	    break;
	case 'N':
	default:
	    is_reg = 0;
    }

    if( temp_nflag )  {
	bu_fgets( buf, BUFSIZE, ifp );
	zap_nl();
	memset(matname, 0, sizeof(matname));
	strncpy( matname, buf, sizeof(matname)-1 );
    }
    if( temp_pflag )  {
	bu_fgets( buf, BUFSIZE, ifp );
	zap_nl();
	memset(matparm, 0, sizeof(matparm));
	strncpy( matparm, buf, sizeof(matparm)-1 );
    }

    for(;;)  {
	buf[0] = '\0';
	if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
	    break;

	if( buf[0] != ID_MEMB )  break;

	/* Process (and accumulate) the members */
	membbld( &head );
    }

    /* Spit them out, all at once.  Use GIFT semantics. */
    if( mk_comb(ofp, name, &head, is_reg,
		temp_nflag ? matname : (char *)0,
		temp_pflag ? matparm : (char *)0,
		override ? (unsigned char *)rgb : (unsigned char *)0,
		regionid, aircode, material, los, inherit, 0, 1) < 0 )  {
	fprintf(stderr,"asc2g: mk_lrcomb fail\n");
	abort();
    }

    if( buf[0] == '\0' )  return(0);
    return(1);
}


/*		M E M B B L D
 *
 *  This routine invokes libwdb to build a member of a combination.
 *  Called only from combbld()
 */
void
membbld(struct bu_list *headp)
{
    register char 	*cp;
    register char 	*np;
    register int 	i;
    char		relation;	/* boolean operation */
    char		inst_name[NAME_LEN+2];
    struct wmember	*memb;

    cp = buf;
    cp++;				/* ident */
    cp = nxt_spc( cp );		/* skip the space */

    relation = *cp++;
    cp = nxt_spc( cp );

    np = inst_name;
    while( *cp != ' ' )  {
	*np++ = *cp++;
    }
    *np = '\0';

    cp = nxt_spc( cp );

    memb = mk_addmember( inst_name, headp, NULL, relation );

    for( i = 0; i < 16; i++ )  {
	memb->wm_mat[i] = atof( cp );
	cp = nxt_spc( cp );
    }
}


/*		A R S B L D
 *
 * This routine builds ARS's.
 */

void
arsabld(void)
{
    char *cp;
    char *np;
    int i;

    if( ars_name )
	bu_free( (char *)ars_name, "ars_name" );
    cp = buf;
    cp = nxt_spc( cp );
    cp = nxt_spc( cp );

    np = cp;
    while( *(++cp) != ' ' );
    *cp++ = '\0';
    ars_name = bu_strdup( np );
    ars_ncurves = (short)atoi( cp );
    cp = nxt_spc( cp );
    ars_ptspercurve = (short)atoi( cp );

    ars_curves = (fastf_t **)bu_calloc( (ars_ncurves+1), sizeof(fastf_t *), "ars_curves" );
    for( i=0 ; i<ars_ncurves ; i++ )
	{
	    ars_curves[i] = (fastf_t *)bu_calloc( ars_ptspercurve + 1,
						  sizeof( fastf_t ) * ELEMENTS_PER_VECT, "ars_curve" );
	}

    ars_pt = 0;
    ars_curve = 0;
}

/*		A R S B L D
 *
 * This is the second half of the ARS-building.  It builds the ARS B record.
 */

void
arsbbld(void)
{
    char *cp;
    int i;
    int incr_ret;

    cp = buf;
    cp = nxt_spc( cp );		/* skip the space */
    cp = nxt_spc( cp );
    cp = nxt_spc( cp );
    for( i = 0; i < 8; i++ )  {
	cp = nxt_spc( cp );
	ars_curves[ars_curve][ars_pt*3] = atof( cp );
	cp = nxt_spc( cp );
	ars_curves[ars_curve][ars_pt*3 + 1] = atof( cp );
	cp = nxt_spc( cp );
	ars_curves[ars_curve][ars_pt*3 + 2] = atof( cp );
	if( ars_curve > 0 || ars_pt > 0 )
	    VADD2( &ars_curves[ars_curve][ars_pt*3], &ars_curves[ars_curve][ars_pt*3], &ars_curves[0][0] );

	incr_ret = incr_ars_pt();
	if( incr_ret == 2 ) {
	    /* finished, write out the ARS solid */
	    if( mk_ars( ofp, ars_name, ars_ncurves, ars_ptspercurve, ars_curves ) ) {
		bu_exit(1, "Failed trying to make ARS (%s)\n", ars_name );
	    }
	    return;
	} else if( incr_ret == 1 ) {
	    /* end of curve, ignore remainder of reocrd */
	    return;
	}
    }
}


/*		Z A P _ N L
 *
 * This routine removes newline and carriage return characters from
 * the buffer and substitutes in NULL.
 */

void
zap_nl(void)
{
    register char *bp;

    bp = &buf[0];

    while( *bp != '\0' )  {
	if(( *bp == '\n' ) || ( *bp == '\r' )) {
	    *bp = '\0';
	}
	bp++;
    }
}


/*		I D E N T B L D
 *
 * This routine makes an ident record.  It calls libwdb to do this.
 */

void
identbld(void)
{
    register char	*cp;
    register char	*np;
    char		units;		/* units code number */
    char		version[6] = {0};
    char		title[255] = {0};
    char		unit_str[8] = {0};
    double		local2mm;

    strncpy(unit_str, "none", 4);

    cp = buf;
    cp++;				/* ident */
    cp = nxt_spc( cp );		/* skip the space */

    units = (char)atoi( cp );
    cp = nxt_spc( cp );

    /* Note that there is no provision for handing libwdb the version.
     * However, this is automatically provided when needed.
     */

    np = version;
    while( *cp != '\n' && *cp != '\r' && *cp != '\0' )  {
	*np++ = *cp++;
    }
    *np = '\0';

    if( strcmp( version, ID_VERSION ) != 0 )  {
	bu_log("WARNING:  input file version (%s) is not %s\n",
	       version, ID_VERSION);
    }

    (void)bu_fgets( buf, BUFSIZE, ifp);
    zap_nl();
    (void)strncpy( title, buf, sizeof(title)-1 );

    /* XXX Should use db_conversions() for this */
    switch(units)  {
	case ID_NO_UNIT:
	    strncpy(unit_str,"mm",4);
	    break;
	case ID_MM_UNIT:
	    strncpy(unit_str,"mm",4);
	    break;
	case ID_UM_UNIT:
	    strncpy(unit_str,"um",4);
	    break;
	case ID_CM_UNIT:
	    strncpy(unit_str,"cm",4);
	    break;
	case ID_M_UNIT:
	    strncpy(unit_str,"m",4);
	    break;
	case ID_KM_UNIT:
	    strncpy(unit_str,"km",4);
	    break;
	case ID_IN_UNIT:
	    strncpy(unit_str,"in",4);
	    break;
	case ID_FT_UNIT:
	    strncpy(unit_str,"ft",4);
	    break;
	case ID_YD_UNIT:
	    strncpy(unit_str,"yard",4);
	    break;
	case ID_MI_UNIT:
	    strncpy(unit_str,"mile",4);
	    break;
	default:
	    fprintf(stderr,"asc2g: unknown v4 units code = %d, defaulting to millimeters\n", units);
	    strncpy(unit_str,"mm",4);
    }
    local2mm = bu_units_conversion(unit_str);
    if( local2mm <= 0 )  {
	fprintf(stderr, "asc2g: unable to convert v4 units string '%s', got local2mm=%g\n",
		unit_str, local2mm);
	bu_exit(3, NULL);
    }

    if( mk_id_editunits(ofp, title, local2mm) < 0 )
	bu_exit(2, "asc2g: unable to write database ID\n");
}


/*		P O L Y H B L D
 *
 *  Collect up all the information for a POLY-solid.
 *  These are handled as BoT solids in v5, but we still have to read
 *  the data in the old format, and then convert it.
 *
 *  The poly header line is followed by an unknown number of
 *  poly data lines.
 */

void
polyhbld(void)
{
    char	*cp;
    char	*name;
    long	startpos;
    long	nlines;
    struct rt_pg_internal	*pg;
    struct rt_db_internal	intern;
    struct bn_tol	tol;

    (void)strtok( buf, " " );	/* skip the ident character */
    cp = strtok( NULL, " \n" );
    name = bu_strdup(cp);

    /* Count up the number of poly data lines which follow */
    startpos = ftell(ifp);
    for( nlines = 0; ; nlines++ )  {
	if( bu_fgets( buf, BUFSIZE, ifp ) == NULL )  break;
	if( buf[0] != ID_P_DATA )  break;	/* 'Q' */
    }
    BU_ASSERT_LONG( nlines, >, 0 );

    /* Allocate storage for the faces */
    BU_GETSTRUCT( pg, rt_pg_internal );
    pg->magic = RT_PG_INTERNAL_MAGIC;
    pg->npoly = nlines;
    pg->poly = (struct rt_pg_face_internal *)bu_calloc( pg->npoly,
							sizeof(struct rt_pg_face_internal), "poly[]" );
    pg->max_npts = 0;

    /* Return to first 'Q' record */
    fseek( ifp, startpos, 0 );

    for( nlines = 0; nlines < pg->npoly; nlines++ )  {
	register struct rt_pg_face_internal	*fp = &pg->poly[nlines];
	register int	i;

	if( bu_fgets( buf, BUFSIZE, ifp ) == NULL )  break;
	if( buf[0] != ID_P_DATA )  bu_exit(1, "mis-count of Q records?\n");

	/* Input always has 5 points, even if all aren't significant */
	fp->verts = (fastf_t *)bu_malloc( 5*3*sizeof(fastf_t), "verts[]" );
	fp->norms = (fastf_t *)bu_malloc( 5*3*sizeof(fastf_t), "norms[]" );

	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */

	fp->npts = (char)atoi( cp );
	if( fp->npts > pg->max_npts )  pg->max_npts = fp->npts;

	for( i = 0; i < 5*3; i++ )  {
	    cp = nxt_spc( cp );
	    fp->verts[i] = atof( cp );
	}

	for( i = 0; i < 5*3; i++ )  {
	    cp = nxt_spc( cp );
	    fp->norms[i] = atof( cp );
	}
    }

    /* Convert the polysolid to a BoT */
    RT_INIT_DB_INTERNAL(&intern);
    intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
    intern.idb_type = ID_POLY;
    intern.idb_meth = &rt_functab[ID_POLY];
    intern.idb_ptr = pg;

    /* this tolerance structure is only used for converting polysolids to BOT's
     * use zero distance to avoid losing any polysolid facets
     */
    tol.magic = BN_TOL_MAGIC;
    tol.dist = 0.0;
    tol.dist_sq = tol.dist * tol.dist;
    tol.perp = 1e-6;
    tol.para = 1 - tol.perp;

    if( rt_pg_to_bot( &intern, &tol, &rt_uniresource ) < 0 )
	bu_exit(1, "Failed to convert [%s] polysolid object to triangle mesh\n", name);
    /* The polysolid is freed by the converter */

    /*
     * Since we already have an internal form, this is much simpler than
     * calling mk_bot().
     */
    if( wdb_put_internal( ofp, name, &intern, mk_conv2mm ) < 0 )
	bu_exit(1, "Failed to create [%s] triangle mesh representation from polysolid object\n", name);
    /* BoT internal has been freed */
}

/*		M A T E R B L D
 *
 *  Add information to the region-id based coloring table.
 */

void
materbld(void)
{
    register char *cp;
    int	low, hi;
    int	r,g,b;

    cp = buf;
    cp++;				/* skip ID_MATERIAL */
    cp = nxt_spc( cp );		/* skip the space */

    /* flags = (char)atoi( cp ); */
    cp = nxt_spc( cp );
    low = (short)atoi( cp );
    cp = nxt_spc( cp );
    hi = (short)atoi( cp );
    cp = nxt_spc( cp );
    r = (unsigned char)atoi( cp);
    cp = nxt_spc( cp );
    g = (unsigned char)atoi( cp);
    cp = nxt_spc( cp );
    b = (unsigned char)atoi( cp);

    /* Put it on a linked list for output later */
    rt_color_addrec( low, hi, r, g, b, -1L );
}

/*		B S P L B L D
 *
 *  This routine builds B-splines using libwdb.
 */

void
bsplbld(void)
{
#if 0
    register char	*cp;
    register char	*np;
    short		nsurf;		/* number of surfaces */
    fastf_t		resolution;	/* resolution of flatness */

    cp = buf;
    cp++;				/* ident */
    cp = nxt_spc( cp );		/* skip the space */

    np = name;
    while( *cp != ' ' )  {
	*np++ = *cp++;
    }
    *np = '\0';
    cp = nxt_spc( cp );

    nsurf = (short)atoi( cp );
    cp = nxt_spc( cp );
    resolution = atof( cp );

    mk_bsolid(ofp, name, nsurf, resolution);
#else
    bu_exit(1, "bsplbld() needs to be upgraded to v5\n");
#endif
}

/* 		B S U R F B L D
 *
 * This routine builds d-spline surface descriptions using libwdb.
 */

void
bsurfbld(void)
{
#if 0

    /* HELP! This involves mk_bsurf(filep, bp) where bp is a ptr to struct */

    register char	*cp;
    register int	i;
    register float	*vp;
    int		nbytes, count;
    float		*fp;

    cp = buf;
    record.d.d_id = *cp++;
    cp = nxt_spc( cp );		/* skip the space */

    record.d.d_order[0] = (short)atoi( cp );
    cp = nxt_spc( cp );
    record.d.d_order[1] = (short)atoi( cp );
    cp = nxt_spc( cp );
    record.d.d_kv_size[0] = (short)atoi( cp );
    cp = nxt_spc( cp );
    record.d.d_kv_size[1] = (short)atoi( cp );
    cp = nxt_spc( cp );
    record.d.d_ctl_size[0] = (short)atoi( cp );
    cp = nxt_spc( cp );
    record.d.d_ctl_size[1] = (short)atoi( cp );
    cp = nxt_spc( cp );
    record.d.d_geom_type = (short)atoi( cp );
    cp = nxt_spc( cp );
    record.d.d_nknots = (short)atoi( cp );
    cp = nxt_spc( cp );
    record.d.d_nctls = (short)atoi( cp );

    record.d.d_nknots =
	ngran( record.d.d_kv_size[0] + record.d.d_kv_size[1] );

    record.d.d_nctls =
	ngran( record.d.d_ctl_size[0] * record.d.d_ctl_size[1]
	       * record.d.d_geom_type);

    /* Write out the record */
    (void)fwrite( (char *)&record, sizeof record, 1, ofp );

    /*
     * The b_surf_head record is followed by
     * d_nknots granules of knot vectors (first u, then v),
     * and then by d_nctls granules of control mesh information.
     * Note that neither of these have an ID field!
     *
     * B-spline surface record, followed by
     *	d_kv_size[0] floats,
     *	d_kv_size[1] floats,
     *	padded to d_nknots granules, followed by
     *	ctl_size[0]*ctl_size[1]*geom_type floats,
     *	padded to d_nctls granules.
     *
     * IMPORTANT NOTE: granule == sizeof(union record)
     */

    /* Malloc and clear memory for the KNOT DATA and read it */
    nbytes = record.d.d_nknots * sizeof(union record);
    vp = (float *)bu_malloc(nbytes, "vp");
    fp = vp;
    memset((char *)vp, 0, nbytes);
    /* Read the knot vector information */
    count = record.d.d_kv_size[0] + record.d.d_kv_size[1];
    for( i = 0; i < count; i++ )  {
	bu_fgets( buf, BUFSIZE, ifp );
	(void)sscanf( buf, "%f", vp++);
    }
    /* Write out the information */
    (void)fwrite( (char *)fp, nbytes, 1, ofp );

    /* Free the knot data memory */
    (void)bu_free( (char *)fp, "knot data" );

    /* Malloc and clear memory for the CONTROL MESH data and read it */
    nbytes = record.d.d_nctls * sizeof(union record);
    vp = (float *)bu_malloc(nbytes, "vp");
    fp = vp;
    memset((char *)vp, 0, nbytes);
    /* Read the control mesh information */
    count = record.d.d_ctl_size[0] * record.d.d_ctl_size[1] *
	record.d.d_geom_type;
    for( i = 0; i < count; i++ )  {
	bu_fgets( buf, BUFSIZE, ifp );
	(void)sscanf( buf, "%f", vp++);
    }
    /* Write out the information */
    (void)fwrite( (char *)fp, nbytes, 1, ofp );

    /* Free the control mesh memory */
    (void)bu_free( (char *)fp, "mesh data" );
#else
    bu_exit(1, "bsrfbld() needs to be upgraded to v5\n");
#endif
}

/*		C L I N E B L D
 *
 */
void
clinebld(void)
{
    char			my_name[NAME_LEN];
    fastf_t			thickness;
    fastf_t			radius;
    point_t			V;
    vect_t			height;
    register char		*cp;
    register char		*np;

    cp = buf;
    cp++;
    cp = nxt_spc( cp );

    np = my_name;
    while( *cp != ' ' && *cp != '\n' && *cp != '\r' ) {
	*np++ = *cp++;
    }
    *np = '\0';

    cp = nxt_spc( cp );
    V[0] = atof( cp );
    cp = nxt_spc( cp );
    V[1] = atof( cp );
    cp = nxt_spc( cp );
    V[2] = atof( cp );
    cp = nxt_spc( cp );
    height[0] = atof( cp );
    cp = nxt_spc( cp );
    height[1] = atof( cp );
    cp = nxt_spc( cp );
    height[2] = atof( cp );
    cp = nxt_spc( cp );
    radius = atof( cp );
    cp = nxt_spc( cp );
    thickness = atof( cp );
    mk_cline( ofp, my_name, V, height, radius, thickness );
}

/*		B O T B L D
 *
 */
void
botbld(void)
{
    char			my_name[NAME_LEN];
    char			type;
    int			mode, orientation, error_mode, num_vertices, num_faces;
    int			i,j;
    double			a[3];
    fastf_t			*vertices;
    fastf_t			*thick=NULL;
    int			*faces;
    struct bu_bitv		*facemode=NULL;

    sscanf( buf, "%c %200s %d %d %d %d %d", &type, my_name, &mode, &orientation, /* NAME_LEN */
	    &error_mode, &num_vertices, &num_faces );

    /* get vertices */
    vertices = (fastf_t *)bu_calloc( num_vertices * 3, sizeof( fastf_t ), "botbld: vertices" );
    for( i=0 ; i<num_vertices ; i++ )
	{
	    bu_fgets( buf, BUFSIZE, ifp);
	    sscanf( buf, "%d: %le %le %le", &j, &a[0], &a[1], &a[2] );
	    if( i != j )
		{
		    bu_log( "Vertices out of order in solid %s (expecting %d, found %d)\n",
			    my_name, i, j );
		    bu_free( (char *)vertices, "botbld: vertices" );
		    bu_log( "Skipping this solid!\n" );
		    while( buf[0] == '\t' )
			bu_fgets( buf, BUFSIZE, ifp);
		    return;
		}
	    VMOVE( &vertices[i*3], a );
	}

    /* get faces (and possibly thicknesses */
    faces = (int *)bu_calloc( num_faces * 3, sizeof( int ), "botbld: faces" );
    if( mode == RT_BOT_PLATE )
	thick = (fastf_t *)bu_calloc( num_faces, sizeof( fastf_t ), "botbld thick" );
    for( i=0 ; i<num_faces ; i++ )
	{
	    bu_fgets( buf, BUFSIZE, ifp);
	    if( mode == RT_BOT_PLATE )
		sscanf( buf, "%d: %d %d %d %le", &j, &faces[i*3], &faces[i*3+1], &faces[i*3+2], &a[0] );
	    else
		sscanf( buf, "%d: %d %d %d", &j, &faces[i*3], &faces[i*3+1], &faces[i*3+2] );

	    if( i != j )
		{
		    bu_log( "Faces out of order in solid %s (expecting %d, found %d)\n",
			    my_name, i, j );
		    bu_free( (char *)vertices, "botbld: vertices" );
		    bu_free( (char *)faces, "botbld: faces" );
		    if( mode == RT_BOT_PLATE )
			bu_free( (char *)thick, "botbld thick" );
		    bu_log( "Skipping this solid!\n" );
		    while( buf[0] == '\t' )
			bu_fgets( buf, BUFSIZE, ifp);
		    return;
		}

	    if( mode == RT_BOT_PLATE )
		thick[i] = a[0];
	}

    if( mode == RT_BOT_PLATE )
	{
	    /* get bit vector */
	    bu_fgets( buf, BUFSIZE, ifp);
	    facemode = bu_hex_to_bitv( &buf[1] );
	}

    mk_bot( ofp, my_name, mode, orientation, 0, num_vertices, num_faces,
	    vertices, faces, thick, facemode );

    bu_free( (char *)vertices, "botbld: vertices" );
    bu_free( (char *)faces, "botbld: faces" );
    if( mode == RT_BOT_PLATE )
	{
	    bu_free( (char *)thick, "botbld thick" );
	    bu_free( (char *)facemode, "botbld facemode" );
	}
}

/*		P I P E B L D
 *
 *  This routine reads pipe data from standard in, constructs a doublely
 *  linked list of pipe points, and sends this list to mk_pipe().
 */

void
pipebld(void)
{

    char			name[NAME_LEN];
    register char		*cp;
    register char		*np;
    struct wdb_pipept	*sp;
    struct bu_list		head;

    /* Process the first buffer */

    cp = buf;
    cp++;				/* ident, not used later */
    cp = nxt_spc( cp );		/* skip spaces */

    np = name;
    while( *cp != '\n' && *cp != '\r' && *cp != '\0' )  {
	*np++ = *cp++;
    }
    *np = '\0';			/* null terminate the string */


    /* Read data lines and process */

    BU_LIST_INIT( &head );
    bu_fgets( buf, BUFSIZE, ifp);
    while( strncmp (buf , "END_PIPE", 8 ) )
	{
	    double id,od,x,y,z,bendradius;

	    sp = (struct wdb_pipept *)bu_malloc(sizeof(struct wdb_pipept), "pipe");

	    (void)sscanf( buf, "%le %le %le %le %le %le",
			  &id, &od,
			  &bendradius, &x, &y, &z );

	    sp->l.magic = WDB_PIPESEG_MAGIC;

	    sp->pp_id = id;
	    sp->pp_od = od;
	    sp->pp_bendradius = bendradius;
	    VSET( sp->pp_coord, x, y, z );

	    BU_LIST_INSERT( &head, &sp->l);
	    bu_fgets( buf, BUFSIZE, ifp);
	}

    mk_pipe(ofp, name, &head);
    mk_pipe_free( &head );
}

/*			P A R T I C L E B L D
 *
 * This routine reads particle data from standard in, and constructs the
 * parameters required by mk_particle.
 */

void
particlebld(void)
{

    char		name[NAME_LEN];
    char		ident;
    point_t		vertex;
    vect_t		height;
    double		vrad;
    double		hrad;


    /* Read all the information out of the existing buffer.  Note that
     * particles fit into one granule.
     */

    (void)sscanf(buf, "%c %200s %le %le %le %le %le %le %le %le", /* NAME_LEN */
		 &ident, name,
		 &vertex[0],
		 &vertex[1],
		 &vertex[2],
		 &height[0],
		 &height[1],
		 &height[2],
		 &vrad, &hrad);

    mk_particle( ofp, name, vertex, height, vrad, hrad);
}


/*			A R B N B L D
 *
 *  This routine reads arbn data from standard in and sendss it to
 *  mk_arbn().
 */

void
arbnbld(void)
{

    char		name[NAME_LEN] = {0};
    char		type[TYPE_LEN] = {0};
    int		i;
    int		neqn;			/* number of eqn expected */
    plane_t		*eqn;			/* pointer to plane equations for faces */
    register char	*cp;
    register char	*np;

    /* Process the first buffer */

    cp = buf;
    cp++;					/* ident */
    cp = nxt_spc(cp);			/* skip spaces */

    np = name;
    while( *cp != ' ')  {
	*np++ = *cp++;
    }
    *np = '\0';				/* null terminate the string */

    cp = nxt_spc(cp);

    neqn = atoi(cp);			/* find number of eqns */
    /*bu_log("neqn = %d\n", neqn);
     */
    /* Check to make sure plane equations actually came in. */
    if( neqn <= 0 )  {
	bu_log("asc2g: warning: %d equations counted for arbn %s\n", neqn, name);
    }

    /*bu_log("mallocing space for eqns\n");
     */
    /* Malloc space for the in-coming plane equations */
    eqn = (plane_t *)bu_malloc( sizeof( plane_t ) * neqn, "eqn" );

    /* Now, read the plane equations and put in appropriate place */

    /*bu_log("starting to dump eqns\n");
     */
    for( i = 0; i < neqn; i++ )  {
	bu_fgets( buf, BUFSIZE, ifp);
	(void)sscanf( buf, "%200s %le %le %le %le", type, /* TYPE_LEN */
		      &eqn[i][X], &eqn[i][Y], &eqn[i][Z], &eqn[i][3]);
    }

    /*bu_log("sending info to mk_arbn\n");
     */
    mk_arbn( ofp, name, neqn, eqn);
}

char *
nxt_spc(register char *cp)
{
    while( *cp != ' ' && *cp != '\t' && *cp !='\0' )  {
	cp++;
    }
    if( *cp != '\0' )  {
	cp++;
    }
    return( cp );
}

int
ngran(int nfloat)
{
    register int gran;
    /* Round up */
    gran = nfloat + ((sizeof(union record)-1) / sizeof(float) );
    gran = (gran * sizeof(float)) / sizeof(union record);
    return(gran);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.34
log
@Fixed a bug related to trying to close a null file pointer.
@
text
@a32 6
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.33 2007/12/16 15:59:37 brlcad Exp $ (BRL)";
@


14.33
log
@convert all bzero calls to memset
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.32 2007/11/21 20:49:05 erikgreenwald Exp $ (BRL)";
d170 2
a171 1
#ifdef _WIN32
d173 1
a173 3
#else
	rewind( ifp );
#endif
a210 1
	fclose(ifp); ifp = NULL;
@


14.32
log
@pass bu_exit a NULL instead of an empty string
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.31 2007/11/21 20:38:21 erikgreenwald Exp $ (BRL)";
d228 1
a228 1
	(void)bzero( (char *)&record, sizeof(record) );
d974 1
a974 1
	bzero( matname, sizeof(matname) );
d980 1
a980 1
	bzero( matparm, sizeof(matparm) );
d1480 1
a1480 1
    (void)bzero( (char *)vp, nbytes );
d1497 1
a1497 1
    (void)bzero( (char *)vp, nbytes );
@


14.31
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.30 2007/11/21 19:05:59 erikgreenwald Exp $ (BRL)";
d1233 1
a1233 1
	bu_exit(3, "");
@


14.30
log
@exit->bu_exit where applicable
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.29 2007/10/22 08:47:38 brlcad Exp $ (BRL)";
d141 2
a142 4
    if( argc != 3 ) {
	bu_log( "%s", usage );
	bu_exit( 1, "" );
    }
d480 1
a480 4
	{
	    bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
	    bu_exit( -1, "" );
	}
d486 1
a486 4
	{
	    bu_log( "ERROR: no vertices for sketch (%s)\n", name );
	    bu_exit( 1, "" );
	}
d492 1
a492 4
		{
		    bu_log( "ERROR: not enough vertices for sketch (%s)\n", name );
		    bu_exit( 1, "" );
		}
d496 1
a496 4
		{
		    bu_log( "ERROR: not enough vertices for sketch (%s)\n", name );
		    bu_exit( 1, "" );
		}
d517 1
a517 4
		{
		    bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
		    bu_exit( -1, "" );
		}
d543 1
a543 4
			    {
				bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
				bu_exit( -1, "" );
			    }
d547 1
a547 4
			    {
				bu_log( "ERROR: not enough knots for nurb segment in sketch (%s)\n", name );
				bu_exit( 1, "" );
			    }
d553 1
a553 4
				    {
					bu_log( "ERROR: not enough knots for nurb segment in sketch (%s)\n", name );
					bu_exit( 1, "" );
				    }
d556 1
a556 4
			    {
				bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
				bu_exit( -1, "" );
			    }
d560 1
a560 4
			    {
				bu_log( "ERROR: not enough control points for nurb segment in sketch (%s)\n", name );
				bu_exit( 1, "" );
			    }
d566 1
a566 4
				    {
					bu_log( "ERROR: not enough control points for nurb segment in sketch (%s)\n", name );
					bu_exit( 1, "" );
				    }
d572 1
a572 3
			bu_log( "Unrecognized segment type (%c) in sketch (%s)\n",
				*cp, name );
			bu_exit( 1, "" );
d652 2
a653 4
    if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )  {
	bu_log( "Unexpected EOF while reading NMG %s data, line 2\n", name );
	bu_exit(-1, "");
    }
d673 1
a673 4
	    {
		bu_log( "Unexpected EOF while reading NMG %s data, hex line %d\n", name, j );
		bu_exit( -1, "" );
	    }
d684 2
a685 4
    if( rt_functab[ID_NMG].ft_import5( &intern, &ext, bn_mat_identity, ofp->dbip, &rt_uniresource, ID_NMG ) < 0 )  {
	bu_log("ft_import5 failed on NMG %s\n", name );
	bu_exit( -1, "" );
    }
d1236 2
a1237 4
    if( mk_id_editunits(ofp, title, local2mm) < 0 )  {
	bu_log("asc2g: unable to write database ID\n");
	bu_exit(2, "");
    }
@


14.29
log
@first 10% of the review of the bu_bomb() instances.  updating many to bu_exit() for the instances where the error or exit condition aren't catastrophic errors (i.e. they wouldn't benefit from having a stack trace of how we got into that state code-wise).  this also makes it easier to refactor usages of log & exit too to the new routine.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.28 2007/10/14 09:08:19 brlcad Exp $ (BRL)";
d143 1
a143 1
	exit( 1 );
d484 1
a484 1
	    exit( -1 );
d493 1
a493 1
	    exit( 1 );
d502 1
a502 1
		    exit( 1 );
d509 1
a509 1
		    exit( 1 );
d533 1
a533 1
		    exit( -1 );
d562 1
a562 1
				exit( -1 );
d569 1
a569 1
				exit( 1 );
d578 1
a578 1
					exit( 1 );
d584 1
a584 1
				exit( -1 );
d591 1
a591 1
				exit( 1 );
d600 1
a600 1
					exit( 1 );
d609 1
a609 1
			exit( 1 );
d691 1
a691 1
	exit(-1);
d714 1
a714 1
		exit( -1 );
d728 1
a728 1
	exit( -1 );
d1277 1
a1277 1
	exit(3);
d1282 1
a1282 1
	exit(2);
@


14.28
log
@more taking care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.27 2007/09/15 16:23:04 brlcad Exp $ (BRL)";
d154 1
a154 2
	(void)fprintf(stderr, "asc2g: can't open files.");
	Tcl_Exit(1);
d162 1
a162 1
	bu_bomb( "Unexpected EOF\n" );
d182 1
a182 1
	    bu_bomb( "Failed to initialize wdb_obj!\n" );
d187 1
a187 2
	    bu_log("Failed to create safe interpreter");
	    Tcl_Exit(1);
d1154 1
a1154 1
	    VADD2( &ars_curves[ars_curve][ars_pt*3], &ars_curves[ars_curve][ars_pt*3], &ars_curves[0][0] )
d1156 5
a1160 15
		incr_ret = incr_ars_pt();
	if( incr_ret == 2 )
	    {
		/* finished, write out the ARS solid */
		if( mk_ars( ofp, ars_name, ars_ncurves, ars_ptspercurve, ars_curves ) )
		    {
			bu_log( "Failed trying to make ARS (%s)\n", ars_name );
			bu_bomb( "Failed trying to make ARS\n" );
		    }
		return;
	    }
	else if( incr_ret == 1 )
	    {
		/* end of curve, ignore remainder of reocrd */
		return;
d1162 5
d1336 1
a1336 1
	if( buf[0] != ID_P_DATA )  bu_bomb("mis-count of Q records?\n");
d1377 1
a1377 1
	bu_bomb("rt_pg_to_bot() failed\n");
d1385 1
a1385 1
	bu_bomb("wdb_put_internal() failure on BoT from polysolid\n");
d1452 1
a1452 1
    bu_bomb("bsplbld() needs to be upgraded to v5\n");
d1557 1
a1557 1
    bu_bomb("bsrfbld() needs to be upgraded to v5\n");
@


14.27
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.26 2007/07/25 18:13:39 erikgreenwald Exp $ (BRL)";
d66 1
a66 1
#define TYPELEN			100
d79 1
a79 1
char		name[NAMESIZE + 2] = {0};
d458 1
a458 1
    char name[NAMESIZE+1];
d470 1
a470 1
    (void)sscanf( cp, "%s %f %f %f %f %f %f %f %f %f %d %d",
d623 2
a624 2
    char name[NAMESIZE+1];
    char sketch_name[NAMESIZE+1];
d637 1
a637 1
    (void)sscanf( cp, "%s %s %d %f %f %f  %f %f %f %f %f %f %f %f %f",
d1068 1
a1068 1
    char		inst_name[NAMESIZE+2];
d1627 1
a1627 1
    sscanf( buf, "%c %s %d %d %d %d %d", &type, my_name, &mode, &orientation,
d1778 1
a1778 1
    (void)sscanf(buf, "%c %s %le %le %le %le %le %le %le %le",
d1803 1
a1803 1
    char		type[TYPELEN] = {0};
d1843 1
a1843 1
	(void)sscanf( buf, "%s %le %le %le %le", type,
@


14.26
log
@removed unnecessary blank lines
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.25 2007/05/19 06:53:33 brlcad Exp $ (BRL)";
d48 1
a48 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.25
log
@call Tcl_Exit() instead of exit() so that tcl can attempt to recover and cleanup resource prior to shutdown -- alas, tcl doesn't clean up properly, but using Tcl_Exit is at least sufficient according to the docs.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.24 2007/05/18 23:53:45 brlcad Exp $ (BRL)";
a1596 1

a1597 1

a1598 1

a1599 1

a1600 1

a1601 1

a1602 1

a1603 1

a1604 1

a1605 1

a1606 1

a1607 1

a1608 1

a1609 1

a1610 1

a1611 1

a1699 1

@


14.24
log
@close/free file pointers and buffers on shutdown
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.23 2007/05/18 23:42:12 brlcad Exp $ (BRL)";
d159 1
a159 1
	exit(1);
d193 1
a193 1
	    exit(1);
d215 1
a215 1
	    exit( 1 );
d223 1
a223 1
	return 0;
d339 1
@


14.23
log
@ws
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.22 2007/02/20 08:19:47 brlcad Exp $ (BRL)";
d82 2
a83 2
char 		*buf;		/* Record input buffer */
char		name[NAMESIZE + 2];
d85 8
a92 8
FILE	*ifp;
struct rt_wdb	*ofp;
static int ars_ncurves=0;
static int ars_ptspercurve=0;
static int ars_curve=0;
static int ars_pt=0;
static char *ars_name;
static fastf_t **ars_curves=NULL;
d136 1
a136 1
main(int argc, char **argv)
d165 2
a166 1
	fclose(ifp);
d178 1
a178 1
	fclose(ifp);
d218 6
a223 1
	exit( 0 );
a327 2
    bu_free(buf, "input buffer");

a331 1
    wdb_close(ofp);
d333 7
a339 1
    exit(0);
@


14.22
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.21 2007/01/27 01:41:32 brlcad Exp $ (BRL)";
d102 9
a110 9
	"attr",
	"color",
	"put",
	"title",
	"units",
	"find",
	"dbfind",
	"rm",
	(char *)0
d116 1
a116 1
	int ret=0;
d118 2
a119 2
	ars_pt++;
	if( ars_pt >= ars_ptspercurve )
d121 3
a123 3
		ars_curve++;
		ars_pt = 0;
		ret = 1;
d126 2
a127 2
	if( ars_curve >= ars_ncurves )
		return( 2 );
d129 1
a129 1
	return( ret );
d138 1
a138 1
	char c1[3];
d140 1
a140 1
	_fmode = _O_BINARY;
d143 1
a143 1
	bu_debug = BU_DEBUG_COREDUMP;
d145 4
a148 4
	if( argc != 3 ) {
		bu_log( "%s", usage );
		exit( 1 );
	}
d150 1
a150 1
	Tcl_FindExecutable(argv[0]);
d152 2
a153 2
	ifp = fopen(argv[1],"r");
	if( !ifp )  perror(argv[1]);
d155 6
a160 6
	ofp = wdb_fopen(argv[2]);
	if( !ofp )  perror(argv[2]);
	if (ifp == NULL || ofp == NULL) {
		(void)fprintf(stderr, "asc2g: can't open files.");
		exit(1);
	}
d162 1
a162 1
	rt_init_resource( &rt_uniresource, 0, NULL );
d164 4
a167 3
	if( bu_fgets( c1, 6, ifp ) == NULL ) {
		bu_bomb( "Unexpected EOF\n" );
	}
d169 4
a172 4
	/* new style ascii database */
	if (!strncmp(c1, "title", 5) || !strncmp(c1, "put ", 4) ) {
		Tcl_Interp     *interp;
		Tcl_Interp     *safe_interp;
d174 1
a174 1
		/* this is a Tcl script */
d177 1
a177 1
		fclose(ifp);
d179 1
a179 1
		rewind( ifp );
d181 13
a193 1
		BU_LIST_INIT(&rt_g.rtg_headwdb.l);
d195 21
a215 5
		interp = Tcl_CreateInterp();
		if (wdb_init_obj(interp, ofp, db_name) != TCL_OK ||
		    wdb_create_cmd(interp, ofp, db_name) != TCL_OK) {
		    bu_bomb( "Failed to initialize wdb_obj!\n" );
		}
d217 4
a220 5
		/* Create the safe interpreter */
		if ((safe_interp = Tcl_CreateSlave(interp, slave_name, 1)) == NULL) {
			bu_log("Failed to create safe interpreter");
			exit(1);
		}
d222 2
a223 15
		/* Create aliases */
		{
			int	i;
			int	ac = 1;
			const char	*av[2];

			av[1] = (char *)0;
			for (i = 0; aliases[i] != (char *)0; ++i) {
				av[0] = aliases[i];
				Tcl_CreateAlias(safe_interp, aliases[i], interp, db_name, ac, av);
			}
			/* add "dbfind" separately */
			av[0] = "find";
			Tcl_CreateAlias(safe_interp, "dbfind", interp, db_name, ac, av);
		}
d225 2
a226 5
		if( Tcl_EvalFile( safe_interp, argv[1] ) != TCL_OK ) {
			bu_log( "Failed to process input file (%s)!\n", argv[1] );
			bu_log( "%s\n", Tcl_GetStringResult(safe_interp) );
			exit( 1 );
		}
d228 90
a317 103
		exit( 0 );
	} else {
		rewind( ifp );
	}

	/* allocate our input buffer */
	buf = (char *)bu_calloc( sizeof(char), BUFSIZE, "input buffer" );

	/* Read ASCII input file, each record on a line */
	while( ( bu_fgets( buf, BUFSIZE, ifp ) ) != (char *)0 )  {

after_read:
		/* Clear the output record -- vital! */
		(void)bzero( (char *)&record, sizeof(record) );

		/* Check record type */
		switch( buf[0] )  {
		case ID_SOLID:
			solbld();
			continue;

		case ID_COMB:
			if( combbld() > 0 )  goto after_read;
			continue;

		case ID_MEMB:
			bu_log("Warning: unattached Member record, ignored\n");
			continue;

		case ID_ARS_A:
			arsabld();
			continue;

		case ID_ARS_B:
			arsbbld();
			continue;

		case ID_P_HEAD:
			polyhbld();
			continue;

		case ID_P_DATA:
			bu_log("Unattached POLY-solid P_DATA (Q) record, skipping\n");
			continue;

		case ID_IDENT:
			identbld();
			continue;

		case ID_MATERIAL:
			materbld();
			continue;

		case ID_BSOLID:
			bsplbld();
			continue;

		case ID_BSURF:
			bsurfbld();
			continue;

		case DBID_PIPE:
			pipebld();
			continue;

		case DBID_STRSOL:
			strsolbld();
			continue;

		case DBID_NMG:
			nmgbld();
			continue;

		case DBID_PARTICLE:
			particlebld();
			continue;

		case DBID_ARBN:
			arbnbld();
			continue;

		case DBID_CLINE:
			clinebld();
			continue;

		case DBID_BOT:
			botbld();
			continue;

		case DBID_EXTR:
			extrbld();
			continue;

		case DBID_SKETCH:
			sktbld();
			continue;

		default:
			bu_log("asc2g: bad record type '%c' (0%o), skipping\n", buf[0], buf[0]);
			bu_log("%s\n", buf );
			continue;
		}
		memset(buf, 0, sizeof(char) * BUFSIZE);
d319 2
d322 1
a322 1
	bu_free(buf, "input buffer");
d324 5
a328 5
	/* Now, at the end of the database, dump out the entire
	 * region-id-based color table.
	 */
	mk_write_color_table( ofp );
	wdb_close(ofp);
d330 1
a330 1
	exit(0);
d445 29
a473 29
	register char *cp, *ptr;
	int i, j;
	int vert_count, seg_count;
	float fV[3], fu[3], fv[3];
	point_t V;
	vect_t u, v;
	point2d_t *verts;
	char name[NAMESIZE+1];
	struct rt_sketch_internal *skt;
	struct curve *crv;
	struct line_seg *lsg;
	struct carc_seg *csg;
	struct nurb_seg *nsg;

	cp = buf;

	cp++;
	cp++;

	(void)sscanf( cp, "%s %f %f %f %f %f %f %f %f %f %d %d",
		name,
		&fV[0], &fV[1], &fV[2],
		&fu[0], &fu[1], &fu[2],
		&fv[0], &fv[1], &fv[2],
		&vert_count, &seg_count );

	VMOVE( V, fV );
	VMOVE( u, fu );
	VMOVE( v, fv );
d475 1
a475 1
	verts = (point2d_t *)bu_calloc( vert_count, sizeof( point2d_t ), "verts" );
d477 1
a477 1
	if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
d479 2
a480 2
		bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
		exit( -1 );
d483 4
a486 4
	verts = (point2d_t *)bu_calloc( vert_count, sizeof( point2d_t ), "verts" );
	cp = buf;
	ptr = strtok( buf, " " );
	if( !ptr )
d488 2
a489 2
		bu_log( "ERROR: no vertices for sketch (%s)\n", name );
		exit( 1 );
d491 1
a491 1
	for( i=0 ; i<vert_count ; i++ )
d493 3
a495 3
		verts[i][0] = atof( ptr );
		ptr = strtok( (char *)NULL, " " );
		if( !ptr )
d497 2
a498 2
			bu_log( "ERROR: not enough vertices for sketch (%s)\n", name );
			exit( 1 );
d500 3
a502 3
		verts[i][1] = atof( ptr );
		ptr = strtok( (char *)NULL, " " );
		if( !ptr && i < vert_count-1 )
d504 2
a505 2
			bu_log( "ERROR: not enough vertices for sketch (%s)\n", name );
			exit( 1 );
d509 13
a521 13
	skt = (struct rt_sketch_internal *)bu_calloc( 1, sizeof( struct rt_sketch_internal ), "sketch" );
	skt->magic = RT_SKETCH_INTERNAL_MAGIC;
	VMOVE( skt->V, V );
	VMOVE( skt->u_vec, u );
	VMOVE( skt->v_vec, v );
	skt->vert_count = vert_count;
	skt->verts = verts;
	crv = &skt->skt_curve;
	crv->seg_count = seg_count;

	crv->segments = (genptr_t *)bu_calloc( crv->seg_count, sizeof( genptr_t ), "segments" );
	crv->reverse = (int *)bu_calloc( crv->seg_count, sizeof( int ), "reverse" );
	for( j=0 ; j<crv->seg_count ; j++ )
d523 2
a524 2
		double radius;
		int k;
d526 1
a526 1
		if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
d528 2
a529 2
			bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
			exit( -1 );
d532 2
a533 2
		cp = buf + 2;
		switch( *cp )
d535 38
a572 29
			case LSEG:
				lsg = (struct line_seg *)bu_malloc( sizeof( struct line_seg ), "line segment" );
				sscanf( cp+1, "%d %d %d", &crv->reverse[j], &lsg->start, &lsg->end );
				lsg->magic = CURVE_LSEG_MAGIC;
				crv->segments[j] = lsg;
				break;
			case CARC:
				csg = (struct carc_seg *)bu_malloc( sizeof( struct carc_seg ), "arc segment" );
				sscanf( cp+1, "%d %d %d %lf %d %d", &crv->reverse[j], &csg->start, &csg->end,
					&radius, &csg->center_is_left, &csg->orientation );
				csg->radius = radius;
				csg->magic = CURVE_CARC_MAGIC;
				crv->segments[j] = csg;
				break;
			case NURB:
				nsg = (struct nurb_seg *)bu_malloc( sizeof( struct nurb_seg ), "nurb segment" );
				sscanf( cp+1, "%d %d %d %d %d", &crv->reverse[j], &nsg->order, &nsg->pt_type,
					&nsg->k.k_size, &nsg->c_size );
				nsg->k.knots = (fastf_t *)bu_calloc( nsg->k.k_size, sizeof( fastf_t ), "knots" );
				nsg->ctl_points = (int *)bu_calloc( nsg->c_size, sizeof( int ), "control points" );
				if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
				{
					bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
					exit( -1 );
				}
				cp = buf + 3;
				ptr = strtok( cp, " " );
				if( !ptr )
				{
d575 20
a594 20
				}
				for( k=0 ; k<nsg->k.k_size ; k++ )
				{
					nsg->k.knots[k] = atof( ptr );
					ptr = strtok( (char *)NULL, " " );
					if( !ptr && k<nsg->k.k_size-1 )
					{
						bu_log( "ERROR: not enough knots for nurb segment in sketch (%s)\n", name );
						exit( 1 );
					}
				}
				if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
				{
					bu_log( "Unexpected EOF while reading sketch (%s) data\n", name );
					exit( -1 );
				}
				cp = buf + 3;
				ptr = strtok( cp, " " );
				if( !ptr )
				{
d597 9
a605 18
				}
				for( k=0 ; k<nsg->c_size ; k++ )
				{
					nsg->ctl_points[k] = atoi( ptr );
					ptr = strtok( (char *)NULL, " " );
					if( !ptr && k<nsg->c_size-1 )
					{
						bu_log( "ERROR: not enough control points for nurb segment in sketch (%s)\n", name );
						exit( 1 );
					}
				}
				nsg->magic = CURVE_NURB_MAGIC;
				crv->segments[j] = nsg;
				break;
			default:
				bu_log( "Unrecognized segment type (%c) in sketch (%s)\n",
					*cp, name );
				exit( 1 );
d610 1
a610 1
	(void)mk_sketch(ofp, name,  skt );
d616 24
a639 24
	register char *cp;
	char name[NAMESIZE+1];
	char sketch_name[NAMESIZE+1];
	int keypoint;
	float fV[3];
	float fh[3];
	float fu_vec[3], fv_vec[3];
	point_t V;
	vect_t h, u_vec, v_vec;

	cp = buf;

	cp++;

	cp++;
	(void)sscanf( cp, "%s %s %d %f %f %f  %f %f %f %f %f %f %f %f %f",
		name, sketch_name, &keypoint, &fV[0], &fV[1], &fV[2], &fh[0], &fh[1], &fh[2],
		&fu_vec[0], &fu_vec[1], &fu_vec[2], &fv_vec[0], &fv_vec[1], &fv_vec[2] );

	VMOVE( V, fV );
	VMOVE( h, fh );
	VMOVE( u_vec, fu_vec );
	VMOVE( v_vec, fv_vec );
	(void)mk_extrusion( ofp, name, sketch_name, V, h, u_vec, v_vec, keypoint );
d658 35
a692 35
	register char *cp;
	int	version;
	char	*name;
	long	granules;
	long	struct_count[26];
	struct bu_external	ext;
	struct rt_db_internal	intern;
	int	j;

	/* First, process the header line */
	cp = strtok( buf, " " );
	/* This is nmg_id, unused here. */
	cp = strtok( NULL, " " );
	version = atoi(cp);
	cp = strtok( NULL, " " );
	name = bu_strdup( cp );
	cp = strtok( NULL, " " );
	granules = atol( cp );

	/* Allocate storage for external v5 form of the body */
	BU_INIT_EXTERNAL(&ext);
	ext.ext_nbytes = SIZEOF_NETWORK_LONG + 26*SIZEOF_NETWORK_LONG + 128 * granules;
	ext.ext_buf = bu_malloc( ext.ext_nbytes, "nmg ext_buf" );
	bu_plong( ext.ext_buf, version );
	BU_ASSERT_LONG( version, ==, 1 );	/* DISK_MODEL_VERSION */

	/* Get next line of input with the 26 counts on it */
	if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )  {
		bu_log( "Unexpected EOF while reading NMG %s data, line 2\n", name );
		exit(-1);
	}

	/* Second, process counts for each kind of structure */
	cp = strtok( buf , " " );
	for( j=0 ; j<26 ; j++ )
d694 4
a697 4
		struct_count[j] = atol( cp );
		bu_plong( ((unsigned char *)ext.ext_buf)+
			SIZEOF_NETWORK_LONG*(j+1), struct_count[j] );
		cp = strtok( (char *)NULL , " " );
d700 6
a705 6
	/* Remaining lines have 32 bytes per line, in hex */
	/* There are 4 lines to make up one granule */
	cp = ((char *)ext.ext_buf) + (26+1)*SIZEOF_NETWORK_LONG;
	for( j=0; j < granules * 4; j++ )  {
		int k;
		unsigned int cp_i;
d707 5
a711 5
		if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
		{
			bu_log( "Unexpected EOF while reading NMG %s data, hex line %d\n", name, j );
			exit( -1 );
		}
d713 6
a718 6
		for( k=0 ; k<32 ; k++ )
		{
			sscanf( &buf[k*2] , "%2x" , &cp_i );
			*cp++ = cp_i;
		}
	}
d720 7
a726 7
	/* Next, import this disk record into memory */
	RT_INIT_DB_INTERNAL(&intern);
	if( rt_functab[ID_NMG].ft_import5( &intern, &ext, bn_mat_identity, ofp->dbip, &rt_uniresource, ID_NMG ) < 0 )  {
		bu_log("ft_import5 failed on NMG %s\n", name );
		exit( -1 );
	}
	bu_free_external(&ext);
d728 2
a729 2
	/* Now we should have a good NMG in memory */
	nmg_vmodel( (struct model *)intern.idb_ptr );
d731 4
a734 4
	/* Finally, squirt it back out through LIBWDB */
	mk_nmg( ofp, name, (struct model *)intern.idb_ptr );
	/* mk_nmg() frees the intern.idp_ptr pointer */
	RT_INIT_DB_INTERNAL(&intern);
d736 1
a736 1
	bu_free( name, "name" );
d748 26
a773 13
	register char *cp;
	register char *np;
	register int i;

	char	s_type;			/* id for the type of primitive */
	fastf_t	val[24];		/* array of values/parameters for solid */
	point_t	center;			/* center; used by many solids */
	point_t pnts[9];		/* array of points for the arbs */
	point_t	norm;
	vect_t	a, b, c, d, n;		/* various vectors required */
	vect_t	height;			/* height vector for tgc */
	vect_t	breadth;		/* breadth vector for rpc */
	double	dd, rad1, rad2;
d775 2
a776 4
	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */
	s_type = atoi(cp);
d778 1
d780 2
d783 1
a783 5
	np = name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
	*np = '\0';
d785 1
a785 2
	cp = nxt_spc( cp );
	/* Comgeom solid type */
d787 53
a839 6
	for( i = 0; i < 24; i++ )  {
		cp = nxt_spc( cp );
		val[i] = atof( cp );
	}

	/* Switch on the record type to make the solids. */
d841 2
a842 1
	switch( s_type ) {
d844 55
a898 5
		case GRP:
			VSET(center, val[0], val[1], val[2]);
			VSET(n, val[3], val[4], val[5]);
			(void)mk_grip( ofp, name, center, n, val[6] );
			break;
d900 2
a901 6
		case TOR:
			VSET(center, val[0], val[1], val[2]);
			VSET(n, val[3], val[4], val[5]);
			rad1 = MAGNITUDE(&val[6]);
			rad2 = MAGNITUDE(n);
			VUNITIZE(n);
d903 4
a906 107
			/* Prevent illegal torii from floating point fuzz */
			if( rad2 > rad1 )  rad2 = rad1;

			mk_tor(ofp, name, center, n, rad1, rad2);
			break;

		case GENTGC:
			VSET(center, val[0], val[1], val[2]);
			VSET(height, val[3], val[4], val[5]);
			VSET(a, val[6], val[7], val[8]);
			VSET(b, val[9], val[10], val[11]);
			VSET(c, val[12], val[13], val[14]);
			VSET(d, val[15], val[16], val[17]);

			mk_tgc(ofp, name, center, height, a, b, c, d);
			break;

		case GENELL:
			VSET(center, val[0], val[1], val[2]);
			VSET(a, val[3], val[4], val[5]);
			VSET(b, val[6], val[7], val[8]);
			VSET(c, val[9], val[10], val[11]);

			mk_ell(ofp, name, center, a, b, c);
			break;

		case GENARB8:
			VSET(pnts[0], val[0], val[1], val[2]);
			VSET(pnts[1], val[3], val[4], val[5]);
			VSET(pnts[2], val[6], val[7], val[8]);
			VSET(pnts[3], val[9], val[10], val[11]);
			VSET(pnts[4], val[12], val[13], val[14]);
			VSET(pnts[5], val[15], val[16], val[17]);
			VSET(pnts[6], val[18], val[19], val[20]);
			VSET(pnts[7], val[21], val[22], val[23]);

			/* Convert from vector notation to absolute points */
			for( i=1; i<8; i++ )  {
				VADD2( pnts[i], pnts[i], pnts[0] );
			}

			mk_arb8(ofp, name, &pnts[0][X]);
			break;

		case HALFSPACE:
			VSET(norm, val[0], val[1], val[2]);
			dd = val[3];

			mk_half(ofp, name, norm, dd);
			break;

		case RPC:
			VSET( center, val[0], val[1], val[2] );
			VSET( height, val[3], val[4], val[5] );
			VSET( breadth, val[6], val[7], val[8] );
			dd = val[9];

			mk_rpc( ofp, name, center, height, breadth, dd );
			break;

		case RHC:
			VSET( center, val[0], val[1], val[2] );
			VSET( height, val[3], val[4], val[5] );
			VSET( breadth, val[6], val[7], val[8] );
			rad1 = val[9];
			dd = val[10];

			mk_rhc( ofp, name, center, height, breadth, rad1, dd );
			break;

		case EPA:
			VSET( center, val[0], val[1], val[2] );
			VSET( height, val[3], val[4], val[5] );
			VSET( a, val[6], val[7], val[8] );
			VUNITIZE( a );
			rad1 = val[9];
			rad2 = val[10];

			mk_epa( ofp, name, center, height, a, rad1, rad2 );
			break;

		case EHY:
			VSET( center, val[0], val[1], val[2] );
			VSET( height, val[3], val[4], val[5] );
			VSET( a, val[6], val[7], val[8] );
			VUNITIZE( a );
			rad1 = val[9];
			rad2 = val[10];
			dd = val[11];

			mk_ehy( ofp, name, center, height, a, rad1, rad2, dd );
			break;

		case ETO:
			VSET( center, val[0], val[1], val[2] );
			VSET( norm, val[3], val[4], val[5] );
			VSET( c, val[6], val[7], val[8] );
			rad1 = val[9];
			rad2 = val[10];

			mk_eto( ofp, name, center, norm, c, rad1, rad2 );
			break;

		default:
			bu_log("asc2g: bad solid %s s_type= %d, skipping\n",
				name, s_type);
	}
d927 35
a961 22
	struct bu_list	head;
	register char 	*cp;
	register char 	*np;
	int 		temp_nflag, temp_pflag;

	char		override;
	char		reg_flags;	/* region flag */
	int		is_reg;
	short		regionid;
	short		aircode;
	short		material;	/* GIFT material code */
	short		los;		/* LOS estimate */
	unsigned char	rgb[3];		/* Red, green, blue values */
	char		matname[32];	/* String of material name */
	char		matparm[60];	/* String of material parameters */
	char		inherit;	/* Inheritance property */

	/* Set all flags initially. */
	BU_LIST_INIT( &head );

	override = 0;
	temp_nflag = temp_pflag = 0;	/* indicators for optional fields */
d963 1
a963 3
	cp = buf;
	cp++;				/* ID_COMB */
	cp = nxt_spc( cp );		/* skip the space */
d965 25
a989 8
	reg_flags = *cp++;		/* Y, N, or new P, F */
	cp = nxt_spc( cp );

	np = name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
	*np = '\0';
d991 2
a992 1
	cp = nxt_spc( cp );
d994 2
a995 31
	regionid = (short)atoi( cp );
	cp = nxt_spc( cp );
	aircode = (short)atoi( cp );
	cp = nxt_spc( cp );
	/* DEPRECTED: number of members expected */
	cp = nxt_spc( cp );
	/* DEPRECATED: Comgeom reference number */
	cp = nxt_spc( cp );
	material = (short)atoi( cp );
	cp = nxt_spc( cp );
	los = (short)atoi( cp );
	cp = nxt_spc( cp );
	override = (char)atoi( cp );
	cp = nxt_spc( cp );

	rgb[0] = (unsigned char)atoi( cp );
	cp = nxt_spc( cp );
	rgb[1] = (unsigned char)atoi( cp );
	cp = nxt_spc( cp );
	rgb[2] = (unsigned char)atoi( cp );
	cp = nxt_spc( cp );

	temp_nflag = atoi( cp );
	cp = nxt_spc( cp );
	temp_pflag = atoi( cp );

	cp = nxt_spc( cp );
	inherit = atoi( cp );

	/* To support FASTGEN, different kinds of regions now exist. */
	switch( reg_flags )  {
d998 2
a999 2
		is_reg = DBV4_REGION;
		break;
d1001 2
a1002 2
		is_reg = DBV4_REGION_FASTGEN_PLATE;
		break;
d1004 2
a1005 2
		is_reg = DBV4_REGION_FASTGEN_VOLUME;
		break;
d1008 2
a1009 2
		is_reg = 0;
	}
d1011 12
a1022 12
	if( temp_nflag )  {
		bu_fgets( buf, BUFSIZE, ifp );
		zap_nl();
		bzero( matname, sizeof(matname) );
		strncpy( matname, buf, sizeof(matname)-1 );
	}
	if( temp_pflag )  {
		bu_fgets( buf, BUFSIZE, ifp );
		zap_nl();
		bzero( matparm, sizeof(matparm) );
		strncpy( matparm, buf, sizeof(matparm)-1 );
	}
d1024 4
a1027 4
	for(;;)  {
		buf[0] = '\0';
		if( bu_fgets( buf, BUFSIZE, ifp ) == (char *)0 )
			break;
d1029 1
a1029 1
		if( buf[0] != ID_MEMB )  break;
d1031 3
a1033 3
		/* Process (and accumulate) the members */
		membbld( &head );
	}
d1035 2
a1036 2
	/* Spit them out, all at once.  Use GIFT semantics. */
	if( mk_comb(ofp, name, &head, is_reg,
d1041 3
a1043 3
			fprintf(stderr,"asc2g: mk_lrcomb fail\n");
			abort();
	}
d1045 2
a1046 2
	if( buf[0] == '\0' )  return(0);
	return(1);
d1058 19
a1076 6
	register char 	*cp;
	register char 	*np;
	register int 	i;
	char		relation;	/* boolean operation */
	char		inst_name[NAMESIZE+2];
	struct wmember	*memb;
d1078 1
a1078 6
	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */

	relation = *cp++;
	cp = nxt_spc( cp );
d1080 1
a1080 5
	np = inst_name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
	*np = '\0';
d1082 2
d1085 1
a1085 7

	memb = mk_addmember( inst_name, headp, NULL, relation );

	for( i = 0; i < 16; i++ )  {
		memb->wm_mat[i] = atof( cp );
		cp = nxt_spc( cp );
	}
d1097 17
a1113 3
	char *cp;
	char *np;
	int i;
d1115 2
a1116 16
	if( ars_name )
		bu_free( (char *)ars_name, "ars_name" );
	cp = buf;
	cp = nxt_spc( cp );
	cp = nxt_spc( cp );

	np = cp;
	while( *(++cp) != ' ' );
	*cp++ = '\0';
	ars_name = bu_strdup( np );
	ars_ncurves = (short)atoi( cp );
	cp = nxt_spc( cp );
	ars_ptspercurve = (short)atoi( cp );

	ars_curves = (fastf_t **)bu_calloc( (ars_ncurves+1), sizeof(fastf_t *), "ars_curves" );
	for( i=0 ; i<ars_ncurves ; i++ )
d1118 2
a1119 2
		ars_curves[i] = (fastf_t *)bu_calloc( ars_ptspercurve + 1,
			sizeof( fastf_t ) * ELEMENTS_PER_VECT, "ars_curve" );
d1122 2
a1123 2
	ars_pt = 0;
	ars_curve = 0;
d1134 17
a1150 17
	char *cp;
	int i;
	int incr_ret;

	cp = buf;
	cp = nxt_spc( cp );		/* skip the space */
	cp = nxt_spc( cp );
	cp = nxt_spc( cp );
	for( i = 0; i < 8; i++ )  {
		cp = nxt_spc( cp );
		ars_curves[ars_curve][ars_pt*3] = atof( cp );
		cp = nxt_spc( cp );
		ars_curves[ars_curve][ars_pt*3 + 1] = atof( cp );
		cp = nxt_spc( cp );
		ars_curves[ars_curve][ars_pt*3 + 2] = atof( cp );
		if( ars_curve > 0 || ars_pt > 0 )
			VADD2( &ars_curves[ars_curve][ars_pt*3], &ars_curves[ars_curve][ars_pt*3], &ars_curves[0][0] )
d1153 16
a1168 16
		if( incr_ret == 2 )
		{
			/* finished, write out the ARS solid */
			if( mk_ars( ofp, ars_name, ars_ncurves, ars_ptspercurve, ars_curves ) )
			{
				bu_log( "Failed trying to make ARS (%s)\n", ars_name );
				bu_bomb( "Failed trying to make ARS\n" );
			}
			return;
		}
		else if( incr_ret == 1 )
		{
			/* end of curve, ignore remainder of reocrd */
			return;
		}
	}
d1181 1
a1181 1
	register char *bp;
d1183 1
a1183 1
	bp = &buf[0];
d1185 3
a1187 5
	while( *bp != '\0' )  {
	    if(( *bp == '\n' ) || ( *bp == '\r' )) {
		*bp = '\0';
	    }
	    bp++;
d1189 2
d1202 26
a1227 7
	register char	*cp;
	register char	*np;
	char		units;		/* units code number */
	char		version[6] = {0};
	char		title[255] = {0};
	char		unit_str[8] = {0};
	double		local2mm;
d1229 4
a1232 5
	strncpy(unit_str, "none", 4);

	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */
d1234 3
a1236 21
	units = (char)atoi( cp );
	cp = nxt_spc( cp );

	/* Note that there is no provision for handing libwdb the version.
	 * However, this is automatically provided when needed.
	 */

	np = version;
	while( *cp != '\n' && *cp != '\r' && *cp != '\0' )  {
		*np++ = *cp++;
	}
	*np = '\0';

	if( strcmp( version, ID_VERSION ) != 0 )  {
		bu_log("WARNING:  input file version (%s) is not %s\n",
			version, ID_VERSION);
	}

	(void)bu_fgets( buf, BUFSIZE, ifp);
	zap_nl();
	(void)strncpy( title, buf, sizeof(title)-1 );
d1238 2
a1239 2
/* XXX Should use db_conversions() for this */
	switch(units)  {
d1241 2
a1242 2
	  strncpy(unit_str,"mm",4);
	  break;
d1244 2
a1245 2
	  strncpy(unit_str,"mm",4);
	  break;
d1247 2
a1248 2
	  strncpy(unit_str,"um",4);
	  break;
d1250 2
a1251 2
	  strncpy(unit_str,"cm",4);
	  break;
d1253 2
a1254 2
	  strncpy(unit_str,"m",4);
	  break;
d1256 2
a1257 2
	  strncpy(unit_str,"km",4);
	  break;
d1259 2
a1260 2
	  strncpy(unit_str,"in",4);
	  break;
d1262 2
a1263 2
	  strncpy(unit_str,"ft",4);
	  break;
d1265 2
a1266 2
	  strncpy(unit_str,"yard",4);
	  break;
d1268 2
a1269 2
	  strncpy(unit_str,"mile",4);
	  break;
d1271 9
a1279 9
	  fprintf(stderr,"asc2g: unknown v4 units code = %d, defaulting to millimeters\n", units);
	  strncpy(unit_str,"mm",4);
	}
	local2mm = bu_units_conversion(unit_str);
	if( local2mm <= 0 )  {
		fprintf(stderr, "asc2g: unable to convert v4 units string '%s', got local2mm=%g\n",
			unit_str, local2mm);
		exit(3);
	}
d1281 4
a1284 4
	if( mk_id_editunits(ofp, title, local2mm) < 0 )  {
		bu_log("asc2g: unable to write database ID\n");
		exit(2);
	}
d1301 53
a1353 53
	char	*cp;
	char	*name;
	long	startpos;
	long	nlines;
	struct rt_pg_internal	*pg;
	struct rt_db_internal	intern;
	struct bn_tol	tol;

	(void)strtok( buf, " " );	/* skip the ident character */
	cp = strtok( NULL, " \n" );
	name = bu_strdup(cp);

	/* Count up the number of poly data lines which follow */
	startpos = ftell(ifp);
	for( nlines = 0; ; nlines++ )  {
		if( bu_fgets( buf, BUFSIZE, ifp ) == NULL )  break;
		if( buf[0] != ID_P_DATA )  break;	/* 'Q' */
	}
	BU_ASSERT_LONG( nlines, >, 0 );

	/* Allocate storage for the faces */
	BU_GETSTRUCT( pg, rt_pg_internal );
	pg->magic = RT_PG_INTERNAL_MAGIC;
	pg->npoly = nlines;
	pg->poly = (struct rt_pg_face_internal *)bu_calloc( pg->npoly,
		sizeof(struct rt_pg_face_internal), "poly[]" );
	pg->max_npts = 0;

	/* Return to first 'Q' record */
	fseek( ifp, startpos, 0 );

	for( nlines = 0; nlines < pg->npoly; nlines++ )  {
		register struct rt_pg_face_internal	*fp = &pg->poly[nlines];
		register int	i;

		if( bu_fgets( buf, BUFSIZE, ifp ) == NULL )  break;
		if( buf[0] != ID_P_DATA )  bu_bomb("mis-count of Q records?\n");

		/* Input always has 5 points, even if all aren't significant */
		fp->verts = (fastf_t *)bu_malloc( 5*3*sizeof(fastf_t), "verts[]" );
		fp->norms = (fastf_t *)bu_malloc( 5*3*sizeof(fastf_t), "norms[]" );

		cp = buf;
		cp++;				/* ident */
		cp = nxt_spc( cp );		/* skip the space */

		fp->npts = (char)atoi( cp );
		if( fp->npts > pg->max_npts )  pg->max_npts = fp->npts;

		for( i = 0; i < 5*3; i++ )  {
			cp = nxt_spc( cp );
			fp->verts[i] = atof( cp );
		}
d1355 3
a1357 4
		for( i = 0; i < 5*3; i++ )  {
			cp = nxt_spc( cp );
			fp->norms[i] = atof( cp );
		}
d1359 1
d1361 27
a1387 27
	/* Convert the polysolid to a BoT */
	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern.idb_type = ID_POLY;
	intern.idb_meth = &rt_functab[ID_POLY];
	intern.idb_ptr = pg;

	/* this tolerance structure is only used for converting polysolids to BOT's
	 * use zero distance to avoid losing any polysolid facets
	 */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.0;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	if( rt_pg_to_bot( &intern, &tol, &rt_uniresource ) < 0 )
		bu_bomb("rt_pg_to_bot() failed\n");
	/* The polysolid is freed by the converter */

	/*
	 * Since we already have an internal form, this is much simpler than
	 * calling mk_bot().
	 */
	if( wdb_put_internal( ofp, name, &intern, mk_conv2mm ) < 0 )
		bu_bomb("wdb_put_internal() failure on BoT from polysolid\n");
	/* BoT internal has been freed */
d1398 19
a1416 3
	register char *cp;
	int	low, hi;
	int	r,g,b;
d1418 2
a1419 18
	cp = buf;
	cp++;				/* skip ID_MATERIAL */
	cp = nxt_spc( cp );		/* skip the space */

	/* flags = (char)atoi( cp ); */
	cp = nxt_spc( cp );
	low = (short)atoi( cp );
	cp = nxt_spc( cp );
	hi = (short)atoi( cp );
	cp = nxt_spc( cp );
	r = (unsigned char)atoi( cp);
	cp = nxt_spc( cp );
	g = (unsigned char)atoi( cp);
	cp = nxt_spc( cp );
	b = (unsigned char)atoi( cp);

	/* Put it on a linked list for output later */
	rt_color_addrec( low, hi, r, g, b, -1L );
d1431 15
a1445 8
	register char	*cp;
	register char	*np;
	short		nsurf;		/* number of surfaces */
	fastf_t		resolution;	/* resolution of flatness */

	cp = buf;
	cp++;				/* ident */
	cp = nxt_spc( cp );		/* skip the space */
d1447 3
a1449 6
	np = name;
	while( *cp != ' ' )  {
		*np++ = *cp++;
	}
	*np = '\0';
	cp = nxt_spc( cp );
d1451 1
a1451 5
	nsurf = (short)atoi( cp );
	cp = nxt_spc( cp );
	resolution = atof( cp );

	mk_bsolid(ofp, name, nsurf, resolution);
d1453 1
a1453 1
	bu_bomb("bsplbld() needs to be upgraded to v5\n");
d1467 1
a1467 1
/* HELP! This involves mk_bsurf(filep, bp) where bp is a ptr to struct */
d1469 67
a1535 5
	register char	*cp;
	register int	i;
	register float	*vp;
	int		nbytes, count;
	float		*fp;
d1537 2
a1538 3
	cp = buf;
	record.d.d_id = *cp++;
	cp = nxt_spc( cp );		/* skip the space */
d1540 14
a1553 75
	record.d.d_order[0] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_order[1] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_kv_size[0] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_kv_size[1] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_ctl_size[0] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_ctl_size[1] = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_geom_type = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_nknots = (short)atoi( cp );
	cp = nxt_spc( cp );
	record.d.d_nctls = (short)atoi( cp );

	record.d.d_nknots =
		ngran( record.d.d_kv_size[0] + record.d.d_kv_size[1] );

	record.d.d_nctls =
		ngran( record.d.d_ctl_size[0] * record.d.d_ctl_size[1]
			* record.d.d_geom_type);

	/* Write out the record */
	(void)fwrite( (char *)&record, sizeof record, 1, ofp );

	/*
	 * The b_surf_head record is followed by
	 * d_nknots granules of knot vectors (first u, then v),
	 * and then by d_nctls granules of control mesh information.
	 * Note that neither of these have an ID field!
	 *
	 * B-spline surface record, followed by
	 *	d_kv_size[0] floats,
	 *	d_kv_size[1] floats,
	 *	padded to d_nknots granules, followed by
	 *	ctl_size[0]*ctl_size[1]*geom_type floats,
	 *	padded to d_nctls granules.
	 *
	 * IMPORTANT NOTE: granule == sizeof(union record)
	 */

	/* Malloc and clear memory for the KNOT DATA and read it */
	nbytes = record.d.d_nknots * sizeof(union record);
	vp = (float *)bu_malloc(nbytes, "vp");
	fp = vp;
	(void)bzero( (char *)vp, nbytes );
	/* Read the knot vector information */
	count = record.d.d_kv_size[0] + record.d.d_kv_size[1];
	for( i = 0; i < count; i++ )  {
		bu_fgets( buf, BUFSIZE, ifp );
		(void)sscanf( buf, "%f", vp++);
	}
	/* Write out the information */
	(void)fwrite( (char *)fp, nbytes, 1, ofp );

	/* Free the knot data memory */
	(void)bu_free( (char *)fp, "knot data" );

	/* Malloc and clear memory for the CONTROL MESH data and read it */
	nbytes = record.d.d_nctls * sizeof(union record);
	vp = (float *)bu_malloc(nbytes, "vp");
	fp = vp;
	(void)bzero( (char *)vp, nbytes );
	/* Read the control mesh information */
	count = record.d.d_ctl_size[0] * record.d.d_ctl_size[1] *
		record.d.d_geom_type;
	for( i = 0; i < count; i++ )  {
		bu_fgets( buf, BUFSIZE, ifp );
		(void)sscanf( buf, "%f", vp++);
	}
	/* Write out the information */
	(void)fwrite( (char *)fp, nbytes, 1, ofp );
d1555 2
a1556 2
	/* Free the control mesh memory */
	(void)bu_free( (char *)fp, "mesh data" );
d1558 1
a1558 1
	bu_bomb("bsrfbld() needs to be upgraded to v5\n");
d1568 17
a1584 7
	char			my_name[NAME_LEN];
	fastf_t			thickness;
	fastf_t			radius;
	point_t			V;
	vect_t			height;
	register char		*cp;
	register char		*np;
d1586 1
a1586 3
	cp = buf;
	cp++;
	cp = nxt_spc( cp );
d1588 1
a1588 5
	np = my_name;
	while( *cp != ' ' && *cp != '\n' && *cp != '\r' ) {
	    *np++ = *cp++;
	}
	*np = '\0';
d1590 1
a1590 1
	cp = nxt_spc( cp );
d1592 1
a1592 1
	V[0] = atof( cp );
d1594 1
a1594 1
	cp = nxt_spc( cp );
d1596 1
a1596 1
	V[1] = atof( cp );
d1598 1
a1598 1
	cp = nxt_spc( cp );
d1600 1
a1600 1
	V[2] = atof( cp );
d1602 1
a1602 1
	cp = nxt_spc( cp );
d1604 1
a1604 1
	height[0] = atof( cp );
d1606 1
a1606 1
	cp = nxt_spc( cp );
d1608 1
a1608 1
	height[1] = atof( cp );
d1610 1
a1610 1
	cp = nxt_spc( cp );
d1612 1
a1612 1
	height[2] = atof( cp );
d1614 1
a1614 1
	cp = nxt_spc( cp );
d1616 1
a1616 3
	radius = atof( cp );

	cp = nxt_spc( cp );
d1618 1
a1618 3
	thickness = atof( cp );

	mk_cline( ofp, my_name, V, height, radius, thickness );
d1627 16
a1642 16
	char			my_name[NAME_LEN];
	char			type;
	int			mode, orientation, error_mode, num_vertices, num_faces;
	int			i,j;
	double			a[3];
	fastf_t			*vertices;
	fastf_t			*thick=NULL;
	int			*faces;
	struct bu_bitv		*facemode=NULL;

	sscanf( buf, "%c %s %d %d %d %d %d", &type, my_name, &mode, &orientation,
		&error_mode, &num_vertices, &num_faces );

	/* get vertices */
	vertices = (fastf_t *)bu_calloc( num_vertices * 3, sizeof( fastf_t ), "botbld: vertices" );
	for( i=0 ; i<num_vertices ; i++ )
d1644 3
a1646 3
		bu_fgets( buf, BUFSIZE, ifp);
		sscanf( buf, "%d: %le %le %le", &j, &a[0], &a[1], &a[2] );
		if( i != j )
d1648 7
a1654 7
			bu_log( "Vertices out of order in solid %s (expecting %d, found %d)\n",
				my_name, i, j );
			bu_free( (char *)vertices, "botbld: vertices" );
			bu_log( "Skipping this solid!\n" );
			while( buf[0] == '\t' )
				bu_fgets( buf, BUFSIZE, ifp);
			return;
d1656 1
a1656 1
		VMOVE( &vertices[i*3], a );
d1659 5
a1663 5
	/* get faces (and possibly thicknesses */
	faces = (int *)bu_calloc( num_faces * 3, sizeof( int ), "botbld: faces" );
	if( mode == RT_BOT_PLATE )
		thick = (fastf_t *)bu_calloc( num_faces, sizeof( fastf_t ), "botbld thick" );
	for( i=0 ; i<num_faces ; i++ )
d1665 5
a1669 5
		bu_fgets( buf, BUFSIZE, ifp);
		if( mode == RT_BOT_PLATE )
			sscanf( buf, "%d: %d %d %d %le", &j, &faces[i*3], &faces[i*3+1], &faces[i*3+2], &a[0] );
		else
			sscanf( buf, "%d: %d %d %d", &j, &faces[i*3], &faces[i*3+1], &faces[i*3+2] );
d1671 1
a1671 1
		if( i != j )
d1673 10
a1682 10
			bu_log( "Faces out of order in solid %s (expecting %d, found %d)\n",
				my_name, i, j );
			bu_free( (char *)vertices, "botbld: vertices" );
			bu_free( (char *)faces, "botbld: faces" );
			if( mode == RT_BOT_PLATE )
				bu_free( (char *)thick, "botbld thick" );
			bu_log( "Skipping this solid!\n" );
			while( buf[0] == '\t' )
				bu_fgets( buf, BUFSIZE, ifp);
			return;
d1685 2
a1686 2
		if( mode == RT_BOT_PLATE )
			thick[i] = a[0];
d1689 1
a1689 1
	if( mode == RT_BOT_PLATE )
d1691 3
a1693 3
		/* get bit vector */
		bu_fgets( buf, BUFSIZE, ifp);
		facemode = bu_hex_to_bitv( &buf[1] );
d1696 2
a1697 2
	mk_bot( ofp, my_name, mode, orientation, 0, num_vertices, num_faces,
		vertices, faces, thick, facemode );
d1699 3
a1701 3
	bu_free( (char *)vertices, "botbld: vertices" );
	bu_free( (char *)faces, "botbld: faces" );
	if( mode == RT_BOT_PLATE )
d1703 2
a1704 2
		bu_free( (char *)thick, "botbld thick" );
		bu_free( (char *)facemode, "botbld facemode" );
d1719 17
a1735 17
	char			name[NAME_LEN];
	register char		*cp;
	register char		*np;
	struct wdb_pipept	*sp;
	struct bu_list		head;

	/* Process the first buffer */

	cp = buf;
	cp++;				/* ident, not used later */
	cp = nxt_spc( cp );		/* skip spaces */

	np = name;
	while( *cp != '\n' && *cp != '\r' && *cp != '\0' )  {
		*np++ = *cp++;
	}
	*np = '\0';			/* null terminate the string */
d1738 1
a1738 1
	/* Read data lines and process */
d1740 3
a1742 3
	BU_LIST_INIT( &head );
	bu_fgets( buf, BUFSIZE, ifp);
	while( strncmp (buf , "END_PIPE", 8 ) )
d1744 1
a1744 1
		double id,od,x,y,z,bendradius;
d1746 1
a1746 1
		sp = (struct wdb_pipept *)bu_malloc(sizeof(struct wdb_pipept), "pipe");
d1748 3
a1750 3
		(void)sscanf( buf, "%le %le %le %le %le %le",
				&id, &od,
				&bendradius, &x, &y, &z );
d1752 1
a1752 1
		sp->l.magic = WDB_PIPESEG_MAGIC;
d1754 4
a1757 4
		sp->pp_id = id;
		sp->pp_od = od;
		sp->pp_bendradius = bendradius;
		VSET( sp->pp_coord, x, y, z );
d1759 2
a1760 2
		BU_LIST_INSERT( &head, &sp->l);
		bu_fgets( buf, BUFSIZE, ifp);
d1763 2
a1764 2
	mk_pipe(ofp, name, &head);
	mk_pipe_free( &head );
d1777 21
a1797 21
	char		name[NAME_LEN];
	char		ident;
	point_t		vertex;
	vect_t		height;
	double		vrad;
	double		hrad;


	/* Read all the information out of the existing buffer.  Note that
	 * particles fit into one granule.
	 */

	(void)sscanf(buf, "%c %s %le %le %le %le %le %le %le %le",
		&ident, name,
		&vertex[0],
		&vertex[1],
		&vertex[2],
		&height[0],
		&height[1],
		&height[2],
		&vrad, &hrad);
d1799 1
a1799 1
	mk_particle( ofp, name, vertex, height, vrad, hrad);
d1813 19
a1831 7
	char		name[NAME_LEN] = {0};
	char		type[TYPELEN] = {0};
	int		i;
	int		neqn;			/* number of eqn expected */
	plane_t		*eqn;			/* pointer to plane equations for faces */
	register char	*cp;
	register char	*np;
d1833 1
a1833 1
	/* Process the first buffer */
d1835 7
a1841 3
	cp = buf;
	cp++;					/* ident */
	cp = nxt_spc(cp);			/* skip spaces */
d1843 14
a1856 30
	np = name;
	while( *cp != ' ')  {
		*np++ = *cp++;
	}
	*np = '\0';				/* null terminate the string */

	cp = nxt_spc(cp);

	neqn = atoi(cp);			/* find number of eqns */
/*bu_log("neqn = %d\n", neqn);
 */
	/* Check to make sure plane equations actually came in. */
	if( neqn <= 0 )  {
		bu_log("asc2g: warning: %d equations counted for arbn %s\n", neqn, name);
	}

/*bu_log("mallocing space for eqns\n");
 */
	/* Malloc space for the in-coming plane equations */
	eqn = (plane_t *)bu_malloc( sizeof( plane_t ) * neqn, "eqn" );

	/* Now, read the plane equations and put in appropriate place */

/*bu_log("starting to dump eqns\n");
 */
	for( i = 0; i < neqn; i++ )  {
		bu_fgets( buf, BUFSIZE, ifp);
		(void)sscanf( buf, "%s %le %le %le %le", type,
			&eqn[i][X], &eqn[i][Y], &eqn[i][Z], &eqn[i][3]);
	}
d1858 3
a1860 3
/*bu_log("sending info to mk_arbn\n");
 */
	mk_arbn( ofp, name, neqn, eqn);
d1866 7
a1872 7
	while( *cp != ' ' && *cp != '\t' && *cp !='\0' )  {
		cp++;
	}
	if( *cp != '\0' )  {
		cp++;
	}
	return( cp );
d1878 5
a1882 5
	register int gran;
	/* Round up */
	gran = nfloat + ((sizeof(union record)-1) / sizeof(float) );
	gran = (gran * sizeof(float)) / sizeof(union record);
	return(gran);
@


14.21
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.20 2007/01/23 01:13:25 brlcad Exp $ (BRL)";
d164 1
a164 1
	if( fgets( c1, 6, ifp ) == NULL ) {
d225 1
a225 1
	while( ( fgets( buf, BUFSIZE, ifp ) ) != (char *)0 )  {
d476 1
a476 1
	if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
d525 1
a525 1
		if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
d554 1
a554 1
				if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
d576 1
a576 1
				if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
d684 1
a684 1
	if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )  {
d706 1
a706 1
		if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
d1011 1
a1011 1
		fgets( buf, BUFSIZE, ifp );
d1017 1
a1017 1
		fgets( buf, BUFSIZE, ifp );
d1025 1
a1025 1
		if( fgets( buf, BUFSIZE, ifp ) == (char *)0 )
d1233 1
a1233 1
	(void)fgets( buf, BUFSIZE, ifp);
d1315 1
a1315 1
		if( fgets( buf, BUFSIZE, ifp ) == NULL )  break;
d1335 1
a1335 1
		if( fgets( buf, BUFSIZE, ifp ) == NULL )  break;
d1530 1
a1530 1
		fgets( buf, BUFSIZE, ifp );
d1548 1
a1548 1
		fgets( buf, BUFSIZE, ifp );
d1643 1
a1643 1
		fgets( buf, BUFSIZE, ifp);
d1652 1
a1652 1
				fgets( buf, BUFSIZE, ifp);
d1664 1
a1664 1
		fgets( buf, BUFSIZE, ifp);
d1680 1
a1680 1
				fgets( buf, BUFSIZE, ifp);
d1691 1
a1691 1
		fgets( buf, BUFSIZE, ifp);
d1740 1
a1740 1
	fgets( buf, BUFSIZE, ifp);
d1759 1
a1759 1
		fgets( buf, BUFSIZE, ifp);
d1852 1
a1852 1
		fgets( buf, BUFSIZE, ifp);
@


14.20
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.19 2007/01/20 14:36:43 brlcad Exp $ (BRL)";
d1370 5
a1374 5
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.0;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;
@


14.19
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.18 2006/07/09 19:17:15 brlcad Exp $ (BRL)";
@


14.18
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.17 2006/05/01 02:21:53 brlcad Exp $ (BRL)";
@


14.17
log
@add support for carriage returns so old ascii files copied from windows parse correctly.  use a little less emphatic emphasis on error (!!!)
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.16 2006/04/29 03:02:18 brlcad Exp $ (BRL)";
d70 3
a72 3
#define BUFSIZE			(8*1024)	/* input line buffer size */
#define TYPELEN			10
#define NAME_LEN			20
d1813 2
a1814 2
	char		name[NAME_LEN];
	char		type[TYPELEN];
@


14.16
log
@default units to millimeters instead of aborting if the units specified are unknown
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.15 2006/01/28 22:46:16 brlcad Exp $ (BRL)";
d166 1
a166 1
		bu_bomb( "Unexpected EOF!!!\n" );
d186 1
a186 1
		    bu_bomb( "Failed to initialize wdb_obj!!\n" );
d212 1
a212 1
			bu_log( "Failed to process input file (%s)!!\n", argv[1] );
d488 1
a488 1
		bu_log( "ERROR: no vertices for sketch (%s)!!!\n", name );
d497 1
a497 1
			bu_log( "ERROR: not enough vertices for sketch (%s)!!!\n", name );
d504 1
a504 1
			bu_log( "ERROR: not enough vertices for sketch (%s)!!!\n", name );
d564 1
a564 1
					bu_log( "ERROR: not enough knots for nurb segment in sketch (%s)!!!\n", name );
d573 1
a573 1
						bu_log( "ERROR: not enough knots for nurb segment in sketch (%s)!!!\n", name );
d586 1
a586 1
					bu_log( "ERROR: not enough control points for nurb segment in sketch (%s)!!!\n", name );
d595 1
a595 1
						bu_log( "ERROR: not enough control points for nurb segment in sketch (%s)!!!\n", name );
d603 1
a603 1
				bu_log( "Unrecognized segment type (%c) in sketch (%s)!!!\n",
d1174 2
a1175 2
 * This routine removes newline characters from the buffer and substitutes
 * in NULL.
d1186 4
a1189 3
		if( *bp == '\n' )
			*bp = '\0';
		bp++;
d1224 1
a1224 1
	while( *cp != '\n' && *cp != '\0' )  {
d1581 3
a1583 2
	while( *cp != ' ' && *cp != '\n' )
		*np++ = *cp++;
d1651 1
a1651 1
			bu_log( "Skipping this solid!!!\n" );
d1679 1
a1679 1
			bu_log( "Skipping this solid!!!\n" );
d1732 1
a1732 1
	while( *cp != '\n' )  {
@


14.15
log
@header cleanup, include stdlib.h for atol(). fixes some 64-bitness
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.14 2006/01/23 03:14:49 brlcad Exp $ (BRL)";
d95 1
a95 1
static char *db_name = "db";
d1270 2
a1271 2
	  fprintf(stderr,"asc2g: unknown v4 units code = %d\n", units);
	  exit(1);
@


14.14
log
@convert to libbu memory management
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.13 2006/01/18 06:46:13 brlcad Exp $ (BRL)";
d47 2
d54 3
a57 1
#include <stdio.h>
d68 1
a68 3
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif
@


14.13
log
@update copyright to 2006
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.12 2005/12/23 21:26:29 bob1961 Exp $ (BRL)";
d734 1
a734 1
	free( name );
d1522 1
a1522 4
	if( (vp = (float *)malloc(nbytes))  == (float *)0 )  {
		bu_log( "asc2g: spline knot malloc error\n");
		exit(1);
	}
d1535 1
a1535 1
	(void)free( (char *)fp );
d1539 1
a1539 4
	if( (vp = (float *)malloc(nbytes))  == (float *)0 )  {
		bu_log( "asc2g: control mesh malloc error\n");
		exit(1);
	}
d1553 1
a1553 1
	(void)free( (char *)fp );
d1742 1
a1742 5
		if( (sp = (struct wdb_pipept *)malloc(sizeof(struct wdb_pipept)) ) == NULL)
		{
				fprintf(stderr,"asc2g: malloc failure for pipe\n");
				exit(-1);
		}
d1842 1
a1842 4
	if( (eqn = (plane_t *)malloc( sizeof( plane_t ) * neqn ) ) == NULL)  {
		bu_log("asc2g: malloc failure for arbn\n");
		exit(-1);
	}
@


14.12
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.11 2005/10/23 04:44:29 brlcad Exp $ (BRL)";
@


14.11
log
@trailing ws
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.10 2005/08/24 04:44:49 brlcad Exp $ (BRL)";
d174 3
d178 1
d354 1
d359 6
@


14.10
log
@separate sections for strsep and strtok are no longer necessary since strsep is provided via libsysv now
@
text
@d23 1
a23 1
 *  
d28 1
a28 1
 *  
d32 2
a33 1
 *	Susanne Muuss, J.D.	 Converted to libwdb, Oct. 1990 
a34 1
 *  
d39 1
a39 1
 *  
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.9 2005/05/28 02:14:50 brlcad Exp $ (BRL)";
d153 1
a153 1
	
d761 1
a761 1
	
d800 1
a800 1
			
d949 1
a949 1
	
d1421 1
a1421 1
	
d1483 1
a1483 1
	record.d.d_nknots = 
d1486 2
a1487 2
	record.d.d_nctls = 
		ngran( record.d.d_ctl_size[0] * record.d.d_ctl_size[1] 
d1493 1
a1493 1
	/* 
@


14.10.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d23 1
a23 1
 *
d28 1
a28 1
 *
d32 1
a32 2
 *	Susanne Muuss, J.D.	 Converted to libwdb, Oct. 1990
 *
d34 1
d39 1
a39 1
 *
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d153 1
a153 1

d761 1
a761 1

d800 1
a800 1

d949 1
a949 1

d1421 1
a1421 1

d1483 1
a1483 1
	record.d.d_nknots =
d1486 2
a1487 2
	record.d.d_nctls =
		ngran( record.d.d_ctl_size[0] * record.d.d_ctl_size[1]
d1493 1
a1493 1
	/*
@


14.9
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.8 2005/03/28 05:25:15 bob1961 Exp $ (BRL)";
a349 1
#if defined (HAVE_STRSEP)
a353 6
#else
    (void)strtok( buf, " ");		/* skip stringsolid_id */
    type = strtok( NULL, " ");
    name = strtok( NULL, " " );
    args = strtok( NULL, "\n" );
#endif
@


14.9.2.1
log
@Mods for windows port
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.9 2005/05/28 02:14:50 brlcad Exp $ (BRL)";
a173 3
#ifdef _WIN32
		fclose(ifp);
#else
a174 1
#endif
@


14.8
log
@If Windows, call Tcl_FindExecutable() before calling Tcl_CreateInterp()
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.7 2005/03/24 17:13:43 bob1961 Exp $ (BRL)";
d48 1
a48 1
#include <string.h>
d50 1
a50 1
#include <strings.h>
d64 2
a65 2
#ifdef WIN32
#include <fcntl.h>
d138 1
a138 1
#ifdef WIN32
d149 2
d176 1
a176 3
#ifdef WIN32
		Tcl_FindExecutable("asc2g");
#endif
@


14.7
log
@Added call to wdb_create_cmd due to change in wdb_init_obj
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.6 2005/01/30 20:30:18 brlcad Exp $ (BRL)";
a67 5
extern void rt_dsp_ifree( struct rt_db_internal	*ip);
extern void rt_ebm_ifree( struct rt_db_internal	*ip);
extern void rt_vol_ifree( struct rt_db_internal	*ip);


d174 3
@


14.6
log
@update copyright to 2005
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.5 2004/12/23 06:05:42 brlcad Exp $ (BRL)";
d180 3
a182 2
		if( wdb_init_obj( interp, ofp, db_name ) != TCL_OK ) {
			bu_bomb( "Failed to initialize wdb_obj!!\n" );
@


14.5
log
@oop, that inttypes.h include wasn't supposed to get commited.
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/conv/asc2g.c,v 14.4 2004/12/21 06:38:18 morrison Exp $ (BRL)";
@


14.4
log
@remove the old copyright notice section
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/conv/asc2g.c,v 14.3 2004/12/18 06:50:50 morrison Exp $ (BRL)";
a327 1
#include <inttypes.h>
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a39 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/conv/asc2g.c,v 14.2 2004/12/18 02:38:09 morrison Exp $ (BRL)";
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file asc2g.c
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/conv/asc2g.c,v 14.1 2004/11/16 19:42:12 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *		A S C 2 G . C
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/conv/asc2g.c,v 1.4 2004/09/03 19:30:06 morrison Exp $ (BRL)";
@


1.4
log
@fix a IA64 crash bug where string functions were not getting a prototype due to USE_STRINGS and the implicit integer to pointer cast the compiler does by assuming the function returns an int obliterates the upper bits of the address (which is actually used on IA64).  don't cause a tiny memory leak by loosing track of a static const char array too while we're at it in units.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/conv/asc2g.c,v 1.3 2004/08/02 23:01:47 morrison Exp $ (BRL)";
d1874 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/conv/asc2g.c,v 1.2 2004/06/08 22:04:08 morrison Exp $ (BRL)";
d30 1
a30 4



#ifdef USE_STRING_H
d69 2
a70 2
static char 		buf[BUFSIZE];		/* Record input buffer */
char			name[NAMESIZE + 2];
d200 3
d297 1
d300 2
d311 1
d324 3
a326 3
    char	*type;
    char	*name;
    char	*args;
d328 4
d335 8
a342 3
    (void)strtok( buf, " " );
    /* skip stringsolid_id */
    type = strtok( NULL, " " );
d345 1
d413 1
d715 1
a715 1
	bu_free( name, "nmg name" );
d1183 3
a1185 3
	char		version[6];
	char		title[72];
	char		*unit_str = "none";
d1188 2
d1219 2
a1220 2
		unit_str = "mm";
		break;
d1222 2
a1223 2
		unit_str = "mm";
		break;
d1225 2
a1226 2
		unit_str = "um";
		break;
d1228 2
a1229 2
		unit_str = "cm";
		break;
d1231 2
a1232 2
		unit_str = "m";
		break;
d1234 2
a1235 2
		unit_str = "km";
		break;
d1237 2
a1238 2
		unit_str = "in";
		break;
d1240 2
a1241 2
		unit_str = "ft";
		break;
d1243 2
a1244 2
		unit_str = "yard";
		break;
d1246 2
a1247 2
		unit_str = "mile";
		break;
d1249 2
a1250 2
		fprintf(stderr,"asc2g: unknown v4 units code = %d\n", units);
		exit(1);
@


1.2
log
@obliterate externs.h
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d28 1
a28 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/conv/asc2g.c,v 11.62 2004/05/10 15:30:41 erikg Exp $ (BRL)";
a42 1
#include "externs.h"
@

