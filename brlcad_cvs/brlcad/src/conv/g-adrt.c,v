head	14.36;
access;
symbols
	rel-7-10-4:14.31
	STABLE:14.31.0.2
	rel-7-10-2:14.31
	rel-7-10-0:14.31
	rel-7-8-4:14.26
	rel-7-8-2:14.26
	rel-7-8-0:14.24
	trimnurbs-branch:14.24.0.2
	help:14.24
	temp_tag:14.20
	bobWinPort-20051223-freeze:14.10
	postmerge-20051223-bobWinPort:14.20
	premerge-20051223-bobWinPort:14.20
	rel-7-6-6:14.20
	rel-7-6-4:14.20
	rel-7-6-2:14.12
	rel-7-6-branch:14.12.0.2
	rel-7-6-0:14.12
	rel-7-4-2:14.7.2.1
	rel-7-4-branch:14.7.0.2
	bobWinPort:14.10.0.2
	rel-7-4-0:14.7;
locks; strict;
comment	@ * @;


14.36
date	2007.12.18.07.07.12;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2007.11.21.20.49.06;	author erikgreenwald;	state Exp;
branches;
next	14.34;

14.34
date	2007.11.21.19.05.59;	author erikgreenwald;	state Exp;
branches;
next	14.33;

14.33
date	2007.10.14.22.15.54;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.10.14.09.08.21;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.02.02.08.48.28;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.01.27.01.41.32;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2006.06.03.20.54.46;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2006.06.03.01.59.47;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2006.02.27.05.22.22;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2006.01.23.03.28.07;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2006.01.23.03.14.49;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2005.09.14.03.24.37;	author twingy;	state Exp;
branches;
next	14.18;

14.18
date	2005.09.13.23.12.05;	author twingy;	state Exp;
branches;
next	14.17;

14.17
date	2005.09.13.22.22.11;	author twingy;	state Exp;
branches;
next	14.16;

14.16
date	2005.09.13.14.03.52;	author twingy;	state Exp;
branches;
next	14.15;

14.15
date	2005.09.09.20.39.05;	author twingy;	state Exp;
branches;
next	14.14;

14.14
date	2005.09.09.09.44.08;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.09.09.05.50.29;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.09.06.03.13.09;	author twingy;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2005.09.06.02.14.07;	author twingy;	state Exp;
branches;
next	14.10;

14.10
date	2005.07.29.21.39.08;	author twingy;	state Exp;
branches;
next	14.9;

14.9
date	2005.07.28.13.17.35;	author twingy;	state Exp;
branches;
next	14.8;

14.8
date	2005.07.26.18.40.29;	author twingy;	state Exp;
branches;
next	14.7;

14.7
date	2005.07.13.02.43.25;	author brlcad;	state Exp;
branches
	14.7.2.1;
next	14.6;

14.6
date	2005.07.06.19.52.49;	author twingy;	state Exp;
branches;
next	14.5;

14.5
date	2005.07.06.19.42.28;	author twingy;	state Exp;
branches;
next	14.4;

14.4
date	2005.07.06.19.16.24;	author twingy;	state Exp;
branches;
next	14.3;

14.3
date	2005.07.05.21.38.50;	author twingy;	state Exp;
branches;
next	14.2;

14.2
date	2005.07.02.07.59.00;	author twingy;	state Exp;
branches;
next	14.1;

14.1
date	2005.07.01.21.09.00;	author twingy;	state Exp;
branches;
next	;

14.7.2.1
date	2005.08.16.21.03.48;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.36
log
@null-terminate strncat'd buffers for sanity sake since we don't usually check if we filled/truncated
@
text
@/*                     G - A D R T . C
 *
 * @@file g-adrt.c
 *
 * BRL-CAD
 *
 * Copyright (c) 2002-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 *  BRL-CAD -> ADRT Converter
 *
 *  Author -
 *      Justin L. Shumaker
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 * $Id$
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#include <string.h>
#include <math.h>

#include "machine.h"		/* machine specific definitions */
#include "vmath.h"		/* vector math macros */
#include "raytrace.h"		/* librt interface definitions */
#include "rtgeom.h"


#ifndef HUGE
#define HUGE 3.40282347e+38F
#endif
#define ADRT_GEOMETRY_REVISION 2


typedef struct property_s {
  char name[256];
  float color[3];
  float emission;
} property_t;


typedef struct regmap_s {
  char name[256];
  int id;
} regmap_t;


typedef struct mesh_map_s {
  char mesh[256];
  char prop[256];
} mesh_map_t;


static struct rt_i *rtip;	/* rt_dirbuild returns this */
FILE *adrt_fh;
int bot_count = 0, prop_num, regmap_num, use_regmap;
property_t *prop_list;
regmap_t *regmap_list;
mesh_map_t *mesh_map;
unsigned int total_tri_num, mesh_map_ind;

struct bu_vls*	region_name_from_path(struct db_full_path *pathp);


void regmap_lookup(char *name, int id) {
  int i;

  for(i = 0; i < regmap_num; i++) {
    if(id == regmap_list[i].id) {
      strncpy(name, regmap_list[i].name, 256);
      continue;
    }
  }
}


/*
*  r e g i o n _ n a m e _ f r o m _ p a t h
*
*  Walk backwards up the tree to the first region, then
*  make a vls string of everything at or above that level.
*  Basically, it produces the name of the region to which
*  the leaf of the path contributes.
*/
struct bu_vls* region_name_from_path(struct db_full_path *pathp) {
    int i, j;
    struct bu_vls *vls;

    /* walk up the path from the bottom looking for the region */
    for (i=pathp->fp_len-1 ; i >= 0 ; i--) {
	if (pathp->fp_names[i]->d_flags & DIR_REGION) {
	    goto found_region;
	}
    }
#if DEBUG
    bu_log("didn't find region on path %s\n", db_path_to_string( pathp ));
#endif
/*    abort(); */

 found_region:
    vls = bu_malloc(sizeof(struct bu_vls), "region name");
    bu_vls_init( vls );

    for(j = 0; j <= i; j++) {
      bu_vls_strcat(vls, "/");
      bu_vls_strcat(vls, pathp->fp_names[j]->d_namep);
    }

    return vls;

}


/*
*  r e g _ s t a r t _ f u n c
*  Called by the tree walker when it first encounters a region
*/
static int reg_start_func(struct db_tree_state *tsp,
			  struct db_full_path *pathp,
			  const struct rt_comb_internal *combp,
			  genptr_t client_data)
{
  char name[256], found;
  unsigned color[3];
  int i;

  /* color is here
   *    combp->rgb[3];
   *
   * phong properties are probably here:
   *	bu_vls_addr(combp->shader)
   */

  /* If no color is found, assign them a 75% gray color */
  color[0] = combp->rgb[0];
  color[1] = combp->rgb[1];
  color[2] = combp->rgb[2];

  if(color[0]+color[1]+color[2] == 0) {
    color[0] = 192;
    color[1] = 192;
    color[2] = 192;
  }

  /* Do a lookup conversion on the name with the region map if used */
  strncpy(name, pathp->fp_names[pathp->fp_len-1]->d_namep, 256);

  /* If name is null, skip it */
  if(!strlen(name))
    return(0);

  /* replace the BRL-CAD name with the regmap name */
  if(use_regmap)
    regmap_lookup(name, tsp->ts_regionid);

  found = 0;
  for(i = 0; i < prop_num; i++) {
    if(!strcmp(prop_list[i].name, name)) {
      found = 1;
      continue;
    }
  }

  if(!found) {
    prop_list = (property_t *)bu_realloc(prop_list, sizeof(property_t) * (prop_num + 1), "prop_list");
    strncpy(prop_list[prop_num].name, name, 256);
    prop_list[prop_num].color[0] = color[0] / 255.0;
    prop_list[prop_num].color[1] = color[1] / 255.0;
    prop_list[prop_num].color[2] = color[2] / 255.0;
    if(strstr(bu_vls_strgrab((struct bu_vls *)&(combp->shader)), "light")) {
      prop_list[prop_num].emission = 1.0;
    } else {
      prop_list[prop_num].emission = 0.0;
    }
    prop_num++;
  }
/*    printf("reg_start: -%s- [%d,%d,%d]\n", name, combp->rgb[0], combp->rgb[1], combp->rgb[2]); */

  return(0);
}


/*
*  r e g _ e n d _ f u n c
*
*  Called by the tree walker when it has finished walking the tree for the region
*  ie. all primitives have been processed
*/
static union tree* reg_end_func(struct db_tree_state *tsp,
				struct db_full_path *pathp,
				union tree *curtree,
				genptr_t client_data)
{
  return(NULL);
}


/*
*  l e a f _ f u n c
*
*  process a leaf of the region tree.  called by db_walk_tree()
*
*  Makes sure that this is a BoT primitive, creates the ADRT triangles
*  and some wrapper data structures so that we can ray-trace the BoT in
*  ADRT
*/
static union tree *leaf_func(struct db_tree_state *tsp,
			     struct db_full_path *pathp,
			     struct rt_db_internal *ip,
			     genptr_t client_data)
{
    register struct soltab *stp;
    union tree *curtree;
    struct directory *dp;
    struct bu_vls *vlsp;
    struct rt_i *rtip;
    struct rt_bot_internal *bot;
    vect_t vv;
    vectp_t vp;
    float vec[3];
    int i;
    char prop_name[256], mesh_name[256];
    unsigned char c;


    RT_CK_DBTS(tsp);
    RT_CK_DBI(tsp->ts_dbip);
    RT_CK_FULL_PATH(pathp);
    RT_CK_DB_INTERNAL(ip);
    rtip = tsp->ts_rtip;
    RT_CK_RTI(rtip);
    RT_CK_RESOURCE(tsp->ts_resp);
    dp = DB_FULL_PATH_CUR_DIR(pathp);


    if(ip->idb_minor_type != ID_BOT) {
#if DEBUG
	fprintf(stderr, "\"%s\" should be a BOT ", pathp->fp_names[pathp->fp_len-1]->d_namep);
	for (i=pathp->fp_len-1; i >= 0 ; i--) {
	    if (pathp->fp_names[i]->d_flags & DIR_REGION) {
		fprintf(stderr, "fix region %s\n", pathp->fp_names[i]->d_namep);
		goto found;
	    } else if (pathp->fp_names[i]->d_flags & DIR_COMB) {
		fprintf(stderr, "not a combination\n");
	    } else if (pathp->fp_names[i]->d_flags & DIR_SOLID) {
		fprintf(stderr, "not a primitive\n");
	    }
	}
	fprintf(stderr, "didn't find region?\n");
    found:
#endif
      return(TREE_NULL); /* BAD */
    }

/*    printf("region_id: %d\n", tsp->ts_regionid); */

    bot = (struct rt_bot_internal *)ip->idb_ptr;
    RT_BOT_CK_MAGIC(bot);
    rtip->nsolids++;

    /* Find the Properties Name */
    prop_name[0] = 0;


    if(use_regmap) {
      vlsp = region_name_from_path(pathp);
      strncpy(mesh_name, bu_vls_strgrab(vlsp), 256);
      regmap_lookup(mesh_name, tsp->ts_regionid);
      bu_free(vlsp, "vls");
    } else {
      strncpy(mesh_name, db_path_to_string(pathp), 256);
    }

    vlsp = region_name_from_path(pathp);
    strncpy(prop_name, bu_vls_strgrab(vlsp), 256);
    regmap_lookup(prop_name, tsp->ts_regionid);
    bu_free(vlsp, "vls");

    /* if name is null, assign default property */
    if(!strlen(prop_name))
      strcpy(prop_name, "default");

    /* Grab the chars from the end till the '/' */
    i = strlen(prop_name)-1;
    if(i >= 0)
      while(prop_name[i] != '/' && i > 0)
	i--;

    if(i != strlen(prop_name))
      strncpy(prop_name, &prop_name[i+1], 256);

    /* Display Status */
    printf("bots processed: %d\r", ++bot_count);
    fflush(stdout);

    /* this is for librt's benefit */
    BU_GETSTRUCT(stp, soltab);
    VSETALL(stp->st_min, HUGE);
    VSETALL(stp->st_max, -HUGE);

    for(vp = &bot->vertices[bot->num_vertices-1]; vp >= bot->vertices; vp -= 3) {
	VMINMAX(stp->st_min, stp->st_max, vp);
    }
    VMINMAX(rtip->mdl_min, rtip->mdl_max, stp->st_min);
    VMINMAX(rtip->mdl_min, rtip->mdl_max, stp->st_max);

    /* Write bot/mesh name */
    c = strlen(mesh_name) + 1;

    fwrite(&c, 1, 1, adrt_fh);
    fwrite(mesh_name, 1, c, adrt_fh);

    mesh_map = (mesh_map_t *)bu_realloc(mesh_map, sizeof(mesh_map_t) * (mesh_map_ind + 1), "mesh_map");

    strncpy(mesh_map[mesh_map_ind].mesh, mesh_name, 256);
    strncpy(mesh_map[mesh_map_ind].prop, prop_name, 256);
    mesh_map_ind++;


    /* Pack number of vertices */
    fwrite(&bot->num_vertices, sizeof(int), 1, adrt_fh);

    for(i = 0; i < bot->num_vertices; i++) {
      /* Change scale from mm to meters */
      vec[0] = bot->vertices[3*i+0] * 0.001;
      vec[1] = bot->vertices[3*i+1] * 0.001;
      vec[2] = bot->vertices[3*i+2] * 0.001;
      fwrite(vec, sizeof(float), 3, adrt_fh);
    }

    /* Add to total number of triangles */
    total_tri_num += bot->num_faces;

    if(bot->num_faces < 1<<16) {
      unsigned short ind;

      c = 0; /* using unsigned shorts */
      fwrite(&c, 1, 1, adrt_fh);

      /* Pack number of faces */
      ind = bot->num_faces;
      fwrite(&ind, sizeof(unsigned short), 1, adrt_fh);
      for(i = 0; i < 3 * bot->num_faces; i++) {
	ind = bot->faces[i];
	fwrite(&ind, sizeof(unsigned short), 1, adrt_fh);
      }
    } else {
      c = 1; /* using ints */
      fwrite(&c, 1, 1, adrt_fh);

      fwrite(&bot->num_faces, sizeof(int), 1, adrt_fh);
      fwrite(bot->faces, sizeof(int), 3*bot->num_faces, adrt_fh);
    }

    /* this piece is for db_walk_tree's benefit */
    RT_GET_TREE( curtree, tsp->ts_resp );
    curtree->magic = RT_TREE_MAGIC;
    curtree->tr_op = OP_SOLID;
    /* regionp will be filled in later by rt_tree_region_assign() */
    curtree->tr_a.tu_regionp = (struct region *)0;


    BU_GETSTRUCT( stp, soltab);
    stp->l.magic = RT_SOLTAB_MAGIC;
    stp->l2.magic = RT_SOLTAB2_MAGIC;
    stp->st_rtip = rtip;
    stp->st_dp = dp;
    dp->d_uses++;	/* XXX gratuitous junk */
    stp->st_uses = 1;
    stp->st_matp = (matp_t)0;
    bu_ptbl_init( &stp->st_regions, 0, "regions using solid" ); /* XXX gratuitous junk */

    VSUB2(vv, stp->st_max, stp->st_min); /* bounding box of bot span being computed */

    stp->st_aradius = MAGNITUDE(vv) * 0.5125;
    if (stp->st_aradius <= 0) stp->st_aradius = 1.0;

    /* fake out, */
    /*    stp->st_meth = &adrt_functab; */
    curtree->tr_a.tu_stp = stp;

    return( curtree );
}


void load_regmap(char *filename) {
  FILE *fh;
  char line[256], name[256], idstr[20], *ptr;
  int i, ind;

  regmap_num = 0;
  regmap_list = NULL;

  fh = fopen(filename, "r");
  if(!fh) {
    printf("region map file \"%s\" not found.\n", filename);
    return;
  } else {
    printf("using region map: %s\n", bu_optarg);
  }

  while(!feof(fh)) {
    /* read in the line */
    bu_fgets(line, 256, fh);

    /* strip off the new line */
    line[strlen(line)-1] = 0;

    /* replace any tabs with spaces */
    for(i = 0; i < strlen(line); i++)
      if(line[i] == '\t')
	line[i] = ' ';

    /* advance to the first non-space */
    ind = 0;
    while(line[ind] == ' ')
      ind++;

    /* If there is a '#' comment here then continue */
    if(line[ind] == '#')
      continue;

    /* advance to the first space while reading the name */
    i = 0;
    while(i < 256 && line[ind] != ' ' && ind < strlen(line))
      name[i++] = line[ind++];
    name[i] = 0;

    /* skip any lines that are empty */
    if(!strlen(name))
      continue;

    /* begin parsing the id's */
    while(ind < strlen(line)) {
      /* advance to the first id */
      while(line[ind] == ' ')
	ind++;

      /* check for comment */
      if(line[ind] == '#')
	break;

      /* advance to the first space while reading the id string */
      i = 0;
      while(i < 256 && line[ind] != ' ' && ind < strlen(line))
	idstr[i++] = line[ind++];
      idstr[i] = 0;

      /* chesk that there were no spaces after the last id */
      if(!strlen(idstr))
	break;

      /* if the id string contains a ':' then it's a range */
      if(strstr(idstr, ":")) {
	int hi, lo;

	ptr = strchr(idstr, ':');
	ptr++;
	hi = atoi(ptr);
	strchr(idstr, ':')[0] = 0;
	lo = atoi(idstr);

	/* insert an entry for the whole range */
	for(i = 0; i <= hi-lo; i++) {
	  /* Insert one entry into the regmap_list */
	  regmap_list = (regmap_t *)bu_realloc(regmap_list, sizeof(regmap_t) * (regmap_num + 1), "regmap_list");
	  strncpy(regmap_list[regmap_num].name, name, 256);
	  regmap_list[regmap_num].id = lo + i;
	  regmap_num++;
	}
      } else {
	/* insert one entry into the regmap_list */
	regmap_list = (regmap_t *)bu_realloc(regmap_list, sizeof(regmap_t) * (regmap_num + 1), "regmap_list");
	strncpy(regmap_list[regmap_num].name, name, 256);
	regmap_list[regmap_num].id = atoi(idstr);
	regmap_num++;
      }
    }
  }
}


int main(int argc, char *argv[]) {
  int i;
  char idbuf[132], filename[256];
  char shortopts[] = "r:";
  int c;
  unsigned char len;
  struct db_tree_state ts;
  unsigned short s;


  if(argc <= 3) {
    printf("Usage: g-adrt [-r region.map] file.g adrt_project_name [region list]\n");
    bu_exit(1, NULL);
  }

  /* Process command line arguments */
  use_regmap = 0;
  while((c = bu_getopt(argc, argv, shortopts)) != -1) {
    switch(c) {
      case 'r':
	use_regmap = 1;
	load_regmap(bu_optarg);
	break;

      default:
	break;
    }
  }
  argc -= bu_optind;
  argv += bu_optind;

  /* Open the adrt file */
  strncpy(filename, argv[1], 256);
  strncat(filename, ".adrt", 256);
  filename[256-1] = '\0';

  adrt_fh = fopen(filename, "w");
  printf("converting: %s\n", argv[0]);

  /* write 2-byte endian */
  s = 1;
  fwrite(&s, sizeof(unsigned short), 1, adrt_fh);

  /* write geometry revision number */
  s = ADRT_GEOMETRY_REVISION;
  fwrite(&s, sizeof(unsigned short), 1, adrt_fh);

  /* write total number of triangles (place holder) */
  total_tri_num = 0;
  fwrite(&total_tri_num, sizeof(unsigned int), 1, adrt_fh);


  bot_count = 0;
  mesh_map_ind = 0;
  prop_num = 0;
  prop_list = NULL;
  mesh_map = NULL;

  /*
  * Load database.
  * rt_dirbuild() returns an "instance" pointer which describes
  * the database to be ray traced.  It also gives you back the
  * title string in the header (ID) record.
  */

  if((rtip = rt_dirbuild(argv[0], idbuf, sizeof(idbuf))) == RTI_NULL) {
    fprintf(stderr,"rtexample: rt_dirbuild failure\n");
    bu_exit(2, NULL);
  }

  ts = rt_initial_tree_state;
  ts.ts_dbip = rtip->rti_dbip;
  ts.ts_rtip = rtip;
  ts.ts_resp = NULL;
  bu_avs_init(&ts.ts_attrs, 1, "avs in tree_state");

  /*
  * Generage a geometry file
  */
  db_walk_tree(rtip->rti_dbip, argc - 2, (const char **)&argv[2], 1, &ts, &reg_start_func, &reg_end_func, &leaf_func, (void *)0);

  /*
  * Write actual total number of triangles now.
  */
  fseek(adrt_fh, 4, SEEK_SET);
  fwrite(&total_tri_num, sizeof(unsigned int), 1, adrt_fh);
  fclose(adrt_fh);

  /*
  * Generate an environment file
  */
  strncpy(filename, argv[1], 256);
  strncat(filename, ".env", 256);
  filename[256-1] = '\0';

  adrt_fh = fopen(filename, "w");

  fprintf(adrt_fh, "geometry_file,%s.adrt\n", argv[1]);
  fprintf(adrt_fh, "properties_file,%s.properties\n", argv[1]);
  fprintf(adrt_fh, "textures_file,%s.textures\n", argv[1]);
  fprintf(adrt_fh, "mesh_map_file,%s.map\n", argv[1]);
  fprintf(adrt_fh, "frames_file,%s.frames\n", argv[1]);
  fprintf(adrt_fh, "image_size,512,384,128,128\n");
  fprintf(adrt_fh, "rendering_method,normal\n");

  fclose(adrt_fh);

  /*
  * Generate a properties file
  */
  strncpy(filename, argv[1], 256);
  strcat(filename, ".properties");
  adrt_fh = fopen(filename, "w");
  fprintf(adrt_fh, "properties,default\n");
  fprintf(adrt_fh, "color,0.8,0.8,0.8\n");
  fprintf(adrt_fh, "gloss,0.2\n");
  for(i = 0; i < prop_num; i++) {
    fprintf(adrt_fh, "properties,%s\n", prop_list[i].name);
    fprintf(adrt_fh, "color,%f,%f,%f\n", prop_list[i].color[0], prop_list[i].color[1], prop_list[i].color[2]);
    if(prop_list[i].emission > 0.0)
      fprintf(adrt_fh, "emission,%f\n", prop_list[i].emission);
  }
  fclose(adrt_fh);

  /*
  * Generate a textures file
  */
  strncpy(filename, argv[1], 256);
  strncat(filename, ".textures", 256);
  filename[256-1] = '\0';

  adrt_fh = fopen(filename, "w");
  fclose(adrt_fh);

  /*
  * Generate a mesh map file
  */
  strncpy(filename, argv[1], 256);
  strncat(filename, ".map", 256);
  filename[256-1] = '\0';

  adrt_fh = fopen(filename, "wb");
  for(i = 0; i < mesh_map_ind; i++) {
    len = strlen(mesh_map[i].mesh) + 1;
    fwrite(&len, 1, 1, adrt_fh);
    fwrite(mesh_map[i].mesh, 1, len, adrt_fh);

    len = strlen(mesh_map[i].prop) + 1;
    fwrite(&len, 1, 1, adrt_fh);
    fwrite(mesh_map[i].prop, 1, len, adrt_fh);
  }
  fclose(adrt_fh);

  /*
  * Generate a frames file
  */
  strncpy(filename, argv[1], 256);
  strncat(filename, ".frames", 256);
  filename[256-1] = '\0';

  adrt_fh = fopen(filename, "w");
  fprintf(adrt_fh, "frame,1\n");
  fprintf(adrt_fh, "camera,10.0,10.0,10.0,0.0,0.0,0.0,0.0,20.0,0.0\n");
  fclose(adrt_fh);

  printf("\ncomplete: %d triangles.\n", total_tri_num);
}
@


14.35
log
@pass bu_exit a NULL instead of an empty string
@
text
@d32 1
a32 1
 * $Id: g-adrt.c,v 14.34 2007/11/21 19:05:59 erikgreenwald Exp $
d539 2
d598 2
d634 2
d644 2
d663 2
@


14.34
log
@exit->bu_exit where applicable
@
text
@d32 1
a32 1
 * $Id: g-adrt.c,v 14.33 2007/10/14 22:15:54 brlcad Exp $
d517 1
a517 1
    bu_exit(1, "");
d570 1
a570 1
    bu_exit(2, "");
@


14.33
log
@more level 4 flawfinder issues.  mostly string length clampages.
@
text
@d32 1
a32 1
 * $Id: g-adrt.c,v 14.32 2007/10/14 09:08:21 brlcad Exp $
d517 1
a517 1
    exit(1);
d570 1
a570 1
    exit(2);
@


14.32
log
@more taking care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d32 1
a32 1
 * $Id: g-adrt.c,v 14.31 2007/02/20 08:19:47 brlcad Exp $
d613 1
a613 1
  adrt_fh = fopen(filename, "w", 256);
@


14.31
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d32 1
a32 1
 * $Id: g-adrt.c,v 14.30 2007/02/02 08:48:28 brlcad Exp $
d92 1
a92 1
      strcpy(name, regmap_list[i].name);
d168 1
a168 1
  strcpy(name, pathp->fp_names[pathp->fp_len-1]->d_namep);
d188 1
a188 1
    strcpy(prop_list[prop_num].name, name);
d289 1
a289 1
      strcpy(mesh_name, bu_vls_strgrab(vlsp));
d293 1
a293 1
      strcpy(mesh_name, db_path_to_string(pathp));
d297 1
a297 1
    strcpy(prop_name, bu_vls_strgrab(vlsp));
d312 1
a312 1
      strcpy(prop_name, &prop_name[i+1]);
d337 2
a338 2
    strcpy(mesh_map[mesh_map_ind].mesh, mesh_name);
    strcpy(mesh_map[mesh_map_ind].prop, prop_name);
d489 1
a489 1
	  strcpy(regmap_list[regmap_num].name, name);
d496 1
a496 1
	strcpy(regmap_list[regmap_num].name, name);
d537 2
a538 2
  strcpy(filename, argv[1]);
  strcat(filename, ".adrt");
d594 2
a595 2
  strcpy(filename, argv[1]);
  strcat(filename, ".env");
d611 1
a611 1
  strcpy(filename, argv[1]);
d613 1
a613 1
  adrt_fh = fopen(filename, "w");
d628 2
a629 2
  strcpy(filename, argv[1]);
  strcat(filename, ".textures");
d636 2
a637 2
  strcpy(filename, argv[1]);
  strcat(filename, ".map");
d653 2
a654 2
  strcpy(filename, argv[1]);
  strcat(filename, ".frames");
@


14.30
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d32 1
a32 1
 * $Id: g-adrt.c,v 14.29 2007/01/27 01:41:32 brlcad Exp $
d426 1
a426 1
    fgets(line, 256, fh);
@


14.29
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d32 1
a32 1
 * $Id: g-adrt.c,v 14.28 2007/01/23 01:13:25 brlcad Exp $
d421 1
a421 1
    printf("using region map: %s\n", optarg);
d526 1
a526 1
	load_regmap(optarg);
@


14.28
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d32 1
a32 1
 * $Id: g-adrt.c,v 14.27 2007/01/20 14:36:43 brlcad Exp $
a135 1

d212 3
a214 3
                                struct db_full_path *pathp,
                                union tree *curtree,
                                genptr_t client_data)
d230 3
a232 3
                             struct db_full_path *pathp,
                             struct rt_db_internal *ip,
                             genptr_t client_data)
d309 1
a309 1
        i--;
d366 2
a367 2
        ind = bot->faces[i];
        fwrite(&ind, sizeof(unsigned short), 1, adrt_fh);
d434 1
a434 1
        line[i] = ' ';
d459 1
a459 1
        ind++;
d463 1
a463 1
        break;
d468 1
a468 1
        idstr[i++] = line[ind++];
d473 1
a473 1
        break;
d477 1
a477 1
        int hi, lo;
d479 14
a492 14
        ptr = strchr(idstr, ':');
        ptr++;
        hi = atoi(ptr);
        strchr(idstr, ':')[0] = 0;
        lo = atoi(idstr);

        /* insert an entry for the whole range */
        for(i = 0; i <= hi-lo; i++) {
          /* Insert one entry into the regmap_list */
          regmap_list = (regmap_t *)bu_realloc(regmap_list, sizeof(regmap_t) * (regmap_num + 1), "regmap_list");
          strcpy(regmap_list[regmap_num].name, name);
          regmap_list[regmap_num].id = lo + i;
          regmap_num++;
        }
d494 5
a498 5
        /* insert one entry into the regmap_list */
        regmap_list = (regmap_t *)bu_realloc(regmap_list, sizeof(regmap_t) * (regmap_num + 1), "regmap_list");
        strcpy(regmap_list[regmap_num].name, name);
        regmap_list[regmap_num].id = atoi(idstr);
        regmap_num++;
d525 3
a527 3
        use_regmap = 1;
        load_regmap(optarg);
        break;
d530 1
a530 1
        break;
@


14.27
log
@update copyright to 2007
@
text
@d12 1
a12 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d17 1
a17 1
 * Library General Public License for more details.
d32 1
a32 1
 * $Id: g-adrt.c,v 14.26 2006/06/03 20:54:46 brlcad Exp $
@


14.26
log
@quell more unused variable warnings
@
text
@d7 1
a7 1
 * Copyright (c) 2002-2006 United States Government as represented by
d33 1
a33 1
 * $Id: g-adrt.c,v 14.25 2006/06/03 01:59:47 brlcad Exp $
@


14.25
log
@quell unused variable warnings
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.24 2006/02/27 05:22:22 brlcad Exp $
a241 1
    matp_t mat;
d245 1
a245 1
    int hash, i, n;
a378 2
    hash = db_dirhash( dp->d_namep );

a405 9
/*    ACQUIRE_SEMAPHORE_TREE(hash); */
#if 0
    BU_LIST_INSERT( &(rtip->rti_solidheads[hash]), &(stp->l) );
    BU_LIST_INSERT( &dp->d_use_hd, &(stp->l2) );
#endif
/*    RELEASE_SEMAPHORE_TREE(hash); */

    /*    bu_log("tree:0x%08x  stp:0x%08x\n", curtree, stp); */

@


14.24
log
@a variety of warning quellings, missing stdlib, calls to exit with a negative, ws.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.23 2006/01/23 03:28:07 brlcad Exp $
a238 1
    struct region_pointer *td = (struct region_pointer *)client_data;
d246 1
a246 1
    int hash, i, n, size;
d425 1
a425 1
  int i, ind, id;
d522 2
a523 1
  char shortopts[] = "r:", c;
a525 1
  struct directory *dp;
@


14.23
log
@how in the world did struct "vu_vls" compile?
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.22 2006/01/23 03:14:49 brlcad Exp $
d38 1
a38 1
#include <math.h>
a39 1
#include <string.h>
d43 2
@


14.22
log
@convert to libbu memory management
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.21 2006/01/18 06:46:13 brlcad Exp $
d193 1
a193 1
    if(strstr(bu_vls_strgrab((struct vu_vls *)&(combp->shader)), "light")) {
@


14.21
log
@update copyright to 2006
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.20 2005/10/23 04:44:29 brlcad Exp $
d188 1
a188 1
    prop_list = (property_t *)realloc(prop_list, sizeof(property_t) * (prop_num + 1));
d338 1
a338 1
    mesh_map = (mesh_map_t *)realloc(mesh_map, sizeof(mesh_map_t) * (mesh_map_ind + 1));
d502 1
a502 1
          regmap_list = (regmap_t *)realloc(regmap_list, sizeof(regmap_t) * (regmap_num + 1));
d509 1
a509 1
        regmap_list = (regmap_t *)realloc(regmap_list, sizeof(regmap_t) * (regmap_num + 1));
@


14.20
log
@trailing ws
@
text
@d7 1
a7 1
 * Copyright (C) 2002-2005 United States Government as represented by
d33 1
a33 1
 * $Id: g-adrt.c,v 14.19 2005/09/14 03:24:37 twingy Exp $
@


14.19
log
@region name is property now.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.18 2005/09/13 23:12:05 twingy Exp $
d104 2
a105 2
*  Basically, it produces the name of the region to which 
*  the leaf of the path contributes. 
d227 1
a227 1
*  and some wrapper data structures so that we can ray-trace the BoT in 
@


14.18
log
@mesh map binary fix.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.15 2005/09/09 20:39:05 twingy Exp $
d171 4
d299 8
d309 1
a309 1
    i = strlen(mesh_name)-1;
d311 1
a311 1
      while(mesh_name[i] != '/' && i > 0)
d314 2
a315 2
    if(i != strlen(mesh_name))
      strcpy(prop_name, &mesh_name[i+1]);
@


14.17
log
@mesh map file is now binary.
@
text
@a321 2
if(strlen(mesh_name) + strlen(prop_name) > 255)
printf("mesh_name: %s\n", mesh_name);
@


14.16
log
@for regions with no name they get tagged "unknown".
@
text
@d78 1
a78 1
int region_count = 0, prop_num, regmap_num, use_regmap;
d243 1
a243 1
    char prop_name[256], reg_name[256];
d286 9
a294 2
    vlsp = region_name_from_path(pathp);
    strcpy(reg_name, bu_vls_strgrab(vlsp));
d297 1
a297 1
    i = strlen(reg_name)-1;
d299 1
a299 1
      while(reg_name[i] != '/' && i > 0)
d302 2
a303 2
    if(use_regmap)
      regmap_lookup(reg_name, tsp->ts_regionid);
d306 1
a306 1
    printf("regions processed: %d\r", ++region_count);
a308 6
    if(i != strlen(reg_name))
      strcpy(prop_name, &reg_name[i+1]);
/*    printf("prop name: -%s-\n", prop_name); */
    bu_free(vlsp, "vls");


d321 4
a324 1
    c = strlen(reg_name) + 1;
d326 1
a326 1
    fwrite(reg_name, 1, c, adrt_fh);
a328 4
    if(!reg_name[0])
      strcpy(reg_name, "unknown");
    if(!prop_name[0])
      strcpy(prop_name, "unknown");
d330 1
a330 1
    strcpy(mesh_map[mesh_map_ind].mesh, reg_name);
d513 1
d559 1
a559 1
  region_count = 0;
d618 3
d642 10
a651 3
  adrt_fh = fopen(filename, "w");
  for(i = 0; i < mesh_map_ind; i++)
    fprintf(adrt_fh, "%s,%s\n", mesh_map[i].mesh, mesh_map[i].prop);
@


14.15
log
@generates a map file now.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.14 2005/09/09 09:44:08 brlcad Exp $
d291 3
a293 2
    while(reg_name[i] != '/' && i > 0)
      i--;
d325 5
@


14.14
log
@BRL-CAD not BRLCAD, consistency
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.13 2005/09/09 05:50:29 brlcad Exp $
d70 6
d78 1
a78 2
int region_count = 0;
int prop_num;
a79 1
int regmap_num;
d81 2
a82 2
int use_regmap;
unsigned int total_tri_num;
d162 1
a162 1
  if(!color[0] && !color[1] && !color[2]) {
d318 1
a318 6
    /* Pack bot/mesh name */
#if 0
    c = strlen(pathp->fp_names[pathp->fp_len-1]->d_namep) + 1;
    common_pack_write(common_g_app_data, common_g_app_ind, &c, sizeof(char));
    common_pack_write(common_g_app_data, common_g_app_ind, pathp->fp_names[pathp->fp_len-1]->d_namep, c);
#else
a321 1
#endif
d323 5
a327 4
    /* Set the properties name */
    c = strlen(prop_name) + 1;
    fwrite(&c, 1, 1, adrt_fh);
    fwrite(prop_name, 1, c, adrt_fh);
d553 1
d556 1
d595 7
a601 8
  strcpy(filename, argv[1]);
  strcat(filename, ".adrt");
  fprintf(adrt_fh, "geometry_file,%s\n", filename);
  fprintf(adrt_fh, "properties_file,properties.db\n");
  fprintf(adrt_fh, "textures_file,textures.db\n");
  fprintf(adrt_fh, "frames_file,frames.db\n");
  fprintf(adrt_fh, "image_size,640,480,80,80\n");
  fprintf(adrt_fh, "rendering_method,path,128\n");
d608 3
a610 1
  adrt_fh = fopen("properties.db", "w");
d622 13
a634 1
  adrt_fh = fopen("textures.db", "w");
d640 3
a642 1
  adrt_fh = fopen("frames.db", "w");
@


14.13
log
@use BRL-CAD instead of brl-cad if only to be at least internally consistent and serve good example
@
text
@d24 1
a24 1
 *  BRLCAD -> ADRT Converter
d33 1
a33 1
 * $Id: g-adrt.c,v 14.12 2005/09/06 03:13:09 twingy Exp $
@


14.12
log
@more total tri_num stuff
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.11 2005/09/06 02:14:07 twingy Exp $
d167 1
a167 1
  /* replace the brl-cad name with the regmap name */
@


14.12.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d24 1
a24 1
 *  BRL-CAD -> ADRT Converter
d33 1
a33 1
 * $Id$
a69 6
typedef struct mesh_map_s {
  char mesh[256];
  char prop[256];
} mesh_map_t;


d72 2
a73 1
int bot_count = 0, prop_num, regmap_num, use_regmap;
d75 1
d77 2
a78 2
mesh_map_t *mesh_map;
unsigned int total_tri_num, mesh_map_ind;
d100 2
a101 2
*  Basically, it produces the name of the region to which
*  the leaf of the path contributes.
d158 1
a158 1
  if(color[0]+color[1]+color[2] == 0) {
d167 1
a167 5
  /* If name is null, skip it */
  if(!strlen(name))
    return(0);

  /* replace the BRL-CAD name with the regmap name */
d219 1
a219 1
*  and some wrapper data structures so that we can ray-trace the BoT in
d239 1
a239 1
    char prop_name[256], mesh_name[256];
a281 9
    if(use_regmap) {
      vlsp = region_name_from_path(pathp);
      strcpy(mesh_name, bu_vls_strgrab(vlsp));
      regmap_lookup(mesh_name, tsp->ts_regionid);
      bu_free(vlsp, "vls");
    } else {
      strcpy(mesh_name, db_path_to_string(pathp));
    }

d283 1
a283 7
    strcpy(prop_name, bu_vls_strgrab(vlsp));
    regmap_lookup(prop_name, tsp->ts_regionid);
    bu_free(vlsp, "vls");

    /* if name is null, assign default property */
    if(!strlen(prop_name))
      strcpy(prop_name, "default");
d286 3
a288 4
    i = strlen(prop_name)-1;
    if(i >= 0)
      while(prop_name[i] != '/' && i > 0)
        i--;
d290 2
a291 2
    if(i != strlen(prop_name))
      strcpy(prop_name, &prop_name[i+1]);
d294 1
a294 1
    printf("bots processed: %d\r", ++bot_count);
d297 6
d314 10
a323 2
    /* Write bot/mesh name */
    c = strlen(mesh_name) + 1;
d325 2
d328 1
a328 8
    fwrite(mesh_name, 1, c, adrt_fh);

    mesh_map = (mesh_map_t *)realloc(mesh_map, sizeof(mesh_map_t) * (mesh_map_ind + 1));

    strcpy(mesh_map[mesh_map_ind].mesh, mesh_name);
    strcpy(mesh_map[mesh_map_ind].prop, prop_name);
    mesh_map_ind++;

a507 1
  unsigned char len;
d553 1
a553 2
  bot_count = 0;
  mesh_map_ind = 0;
a555 1
  mesh_map = NULL;
d594 8
a601 7
  fprintf(adrt_fh, "geometry_file,%s.adrt\n", argv[1]);
  fprintf(adrt_fh, "properties_file,%s.properties\n", argv[1]);
  fprintf(adrt_fh, "textures_file,%s.textures\n", argv[1]);
  fprintf(adrt_fh, "mesh_map_file,%s.map\n", argv[1]);
  fprintf(adrt_fh, "frames_file,%s.frames\n", argv[1]);
  fprintf(adrt_fh, "image_size,512,384,128,128\n");
  fprintf(adrt_fh, "rendering_method,normal\n");
d608 1
a608 6
  strcpy(filename, argv[1]);
  strcat(filename, ".properties");
  adrt_fh = fopen(filename, "w");
  fprintf(adrt_fh, "properties,default\n");
  fprintf(adrt_fh, "color,0.8,0.8,0.8\n");
  fprintf(adrt_fh, "gloss,0.2\n");
d620 1
a620 20
  strcpy(filename, argv[1]);
  strcat(filename, ".textures");
  adrt_fh = fopen(filename, "w");
  fclose(adrt_fh);

  /*
  * Generate a mesh map file
  */
  strcpy(filename, argv[1]);
  strcat(filename, ".map");
  adrt_fh = fopen(filename, "wb");
  for(i = 0; i < mesh_map_ind; i++) {
    len = strlen(mesh_map[i].mesh) + 1;
    fwrite(&len, 1, 1, adrt_fh);
    fwrite(mesh_map[i].mesh, 1, len, adrt_fh);

    len = strlen(mesh_map[i].prop) + 1;
    fwrite(&len, 1, 1, adrt_fh);
    fwrite(mesh_map[i].prop, 1, len, adrt_fh);
  }
d626 1
a626 3
  strcpy(filename, argv[1]);
  strcat(filename, ".frames");
  adrt_fh = fopen(filename, "w");
@


14.11
log
@total tri num at byte position 4.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.10 2005/07/29 21:39:08 twingy Exp $
d510 1
a510 1
  short s;
d542 1
a542 1
  fwrite(&s, sizeof(short), 1, adrt_fh);
d546 1
a546 1
  fwrite(&s, sizeof(short), 1, adrt_fh);
d549 2
a550 1
  fwrite(&total_tri_num, sizeof(int), 1, adrt_fh);
d579 6
a628 7


  /*
  * Write actual total number of triangles now.
  */
  fseek(adrt_fh, 4, SEEK_SET);
  fwrite(&total_tri_num, sizeof(int), 1, adrt_fh);
d631 1
a631 1
  printf("\ncomplete (%d triangles).\n", total_tri_num);
@


14.10
log
@g-adrt now creates an emission line if it finds a light source in the
shader string.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.9 2005/07/28 13:17:35 twingy Exp $
d54 1
a54 1
#define ADRT_GEOMETRY_REVISION 1
d78 1
d341 3
d548 4
d622 7
d631 1
a631 1
  printf("\ncomplete.\n");
@


14.9
log
@new and improved! 98% fat free!
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.8 2005/07/26 18:40:29 twingy Exp $
d60 1
d184 5
d586 1
a586 1
  fprintf(adrt_fh, "rendering_method,phong\n");
d597 2
@


14.8
log
@off by 1 on regions processed.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.7 2005/07/13 02:43:25 brlcad Exp $
d54 1
a54 1
#define ADRT_GEOMETRY_REVISION 0
d334 20
a353 3
    /* Pack number of faces */
    fwrite(&bot->num_faces, sizeof(int), 1, adrt_fh);
    fwrite(bot->faces, sizeof(int)*3, bot->num_faces, adrt_fh);
@


14.7
log
@common.h belongs before any system header, don't include brlcad_config.h directly -- not portable; also getopt isn't used, use the compatible bu_getopt routine instead
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.6 2005/07/06 19:52:49 twingy Exp $
d232 2
a233 1
    char c, prop_name[256], reg_name[256];
d287 1
a287 1
    printf("regions processed: %d\r", region_count++);
@


14.7.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.10 2005/07/29 21:39:08 twingy Exp $
d54 1
a54 1
#define ADRT_GEOMETRY_REVISION 1
a59 1
  float emission;
a182 5
    if(strstr(bu_vls_strgrab((struct vu_vls *)&(combp->shader)), "light")) {
      prop_list[prop_num].emission = 1.0;
    } else {
      prop_list[prop_num].emission = 0.0;
    }
d232 1
a232 2
    char prop_name[256], reg_name[256];
    unsigned char c;
d286 1
a286 1
    printf("regions processed: %d\r", ++region_count);
d333 3
a335 20
    if(bot->num_faces < 1<<16) {
      unsigned short ind;

      c = 0; /* using unsigned shorts */
      fwrite(&c, 1, 1, adrt_fh);

      /* Pack number of faces */
      ind = bot->num_faces;
      fwrite(&ind, sizeof(unsigned short), 1, adrt_fh);
      for(i = 0; i < 3 * bot->num_faces; i++) {
        ind = bot->faces[i];
        fwrite(&ind, sizeof(unsigned short), 1, adrt_fh);
      }
    } else {
      c = 1; /* using ints */
      fwrite(&c, 1, 1, adrt_fh);

      fwrite(&bot->num_faces, sizeof(int), 1, adrt_fh);
      fwrite(bot->faces, sizeof(int), 3*bot->num_faces, adrt_fh);
    }
d562 1
a562 1
  fprintf(adrt_fh, "rendering_method,path,128\n");
a572 2
    if(prop_list[i].emission > 0.0)
      fprintf(adrt_fh, "emission,%f\n", prop_list[i].emission);
@


14.6
log
@unsigned char
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.5 2005/07/06 19:42:28 twingy Exp $
d36 2
d41 3
a43 2
#include <unistd.h>
#include <getopt.h>
a44 1
#include "brlcad_config.h"	/* machine specific definitions */
d492 1
a492 1
  while((c = getopt(argc, argv, shortopts)) != -1) {
d503 2
a504 2
  argc -= optind;
  argv += optind;
@


14.5
log
@if color is 0 0 0 (i.e, not assigned), then supply it with 75% gray.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.4 2005/07/06 19:16:24 twingy Exp $
d54 1
d60 1
d138 2
a139 1
  char name[256], found, color[3];
@


14.4
log
@region map names now replaces brl-cad names if the -r argument is used.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.3 2005/07/05 21:38:50 twingy Exp $
d136 1
a136 1
  char name[256], found;
d146 13
a158 3
  if(combp->rgb[0] || combp->rgb[1] || combp->rgb[2] || 1) {
    /* Do a lookup conversion on the name with the region map if used */
    strcpy(name, pathp->fp_names[pathp->fp_len-1]->d_namep);
d160 3
a162 3
    /* replace the brl-cad name with the regmap name */
    if(use_regmap)
      regmap_lookup(name, tsp->ts_regionid);
d164 5
a168 6
    found = 0;
    for(i = 0; i < prop_num; i++) {
      if(!strcmp(prop_list[i].name, name)) {
        found = 1;
        continue;
      }
d170 1
d172 8
a179 8
    if(!found) {
      prop_list = (property_t *)realloc(prop_list, sizeof(property_t) * (prop_num + 1));
      strcpy(prop_list[prop_num].name, name);
      prop_list[prop_num].color[0] = combp->rgb[0] / 255.0;
      prop_list[prop_num].color[1] = combp->rgb[1] / 255.0;
      prop_list[prop_num].color[2] = combp->rgb[2] / 255.0;
      prop_num++;
    }
a180 1
  }
@


14.3
log
@adding region map support.
@
text
@d33 1
a33 1
 * $Id: g-adrt.c,v 14.2 2005/07/02 07:59:00 twingy Exp $
d76 13
d136 1
a136 1
  char found;
d146 8
a153 1
  if(combp->rgb[0] || combp->rgb[1] || combp->rgb[2]) {
d156 1
a156 1
      if(!strcmp(prop_list[i].name, pathp->fp_names[pathp->fp_len-1]->d_namep)) {
d164 1
a164 1
      strcpy(prop_list[prop_num].name, pathp->fp_names[pathp->fp_len-1]->d_namep);
d170 1
a170 1
/*    printf("reg_start: -%s- [%d,%d,%d]\n", pathp->fp_names[pathp->fp_len-1]->d_namep, combp->rgb[0], combp->rgb[1], combp->rgb[2]); */
a172 4
  /* to find the name of the region... it is probably
  * pathp->fp_names[pathp->fp_len-1]
  */

d231 1
a231 2
    if (ip->idb_minor_type != ID_BOT) {

a233 2
#endif

a235 1
#if DEBUG
a236 1
#endif
a238 1
#if DEBUG
a239 1
#endif
a240 1
#if DEBUG
a241 1
#endif
a243 1
#if DEBUG
d245 1
d247 1
a247 2
    found:
	return( TREE_NULL );		/* BAD */
d249 3
d259 1
a261 2
    printf("regions processed: %d\r", region_count++);
    fflush(stdout);
d268 7
a276 1

d295 1
a295 2
    common_pack_write(common_g_app_data, common_g_app_ind, &c, 
sizeof(char));
a439 1
printf("hi: %d, idstr: -%s- %d\n", hi, idstr, atoi(idstr));
a456 2

      printf("regmap_list[%d]: %s - %d\n", regmap_num, regmap_list[regmap_num-1].name, regmap_list[regmap_num-1].id);
d558 1
a558 1
    fprintf(adrt_fh, "color,%f,%f,%.f\n", prop_list[i].color[0], prop_list[i].color[1], prop_list[i].color[2]);
@


14.2
log
@igvt is functional again, still needs further testing and a few optimizations
I'm to tired to apply right now.
@
text
@d24 1
a24 1
 *  BRLCAD -> ADRT converter
d33 1
a33 1
 * $Id: g-adrt.c,v 14.1 2005/07/01 21:09:00 twingy Exp $
d39 2
d59 6
d70 3
d352 100
d455 1
d460 1
d462 1
a462 1
    printf("Usage: g-adrt file.g adrt_proj_name [region list]\n");
d466 16
d483 1
a483 1
  strcpy(filename, argv[2]);
d486 1
a486 1
  printf("Converting...\n", argv[1], filename);
d507 1
a507 1
  if((rtip = rt_dirbuild(argv[1], idbuf, sizeof(idbuf))) == RTI_NULL) {
d521 1
a521 1
  db_walk_tree(rtip->rti_dbip, argc - 3, (const char **)&argv[3], 1, &ts, &reg_start_func, &reg_end_func, &leaf_func, (void *)0);
d527 1
a527 1
  strcpy(filename, argv[2]);
d531 1
a531 1
  strcpy(filename, argv[2]);
@


14.1
log
@The g-adrt converter, only does BOTS.
@
text
@d33 1
a33 1
 * $Id: g.c,v 1.3 2005/06/18 01:56:30 twingy Exp $
d182 2
a183 2
    register matp_t mat;
    int hash, i, n, size;
d186 2
d189 2
a190 3
    vect_t vv, v0, v1, v2;
    struct region_pointer *td = (struct region_pointer *)client_data;
    struct bu_vls *vlsp;
d289 4
a292 4
      bot->vertices[3*i+0] *= 0.001;
      bot->vertices[3*i+1] *= 0.001;
      bot->vertices[3*i+2] *= 0.001;
      fwrite(&bot->vertices[3*i], sizeof(float), 3, adrt_fh);
d349 1
a349 1
    printf("usage: g-adrt file.g adrt_proj_name [region list]\n");
d389 4
a392 1
  db_walk_tree(rtip->rti_dbip, argc - 3, &argv[3], 1, &ts, &reg_start_func, &reg_end_func, &leaf_func, (void *)0);
@

