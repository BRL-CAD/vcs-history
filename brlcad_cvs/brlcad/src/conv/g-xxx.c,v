head	14.23;
access;
symbols
	rel-7-10-4:14.20
	STABLE:14.20.0.2
	stable-branch:14.7
	rel-7-10-2:14.20
	rel-7-10-0:14.19
	rel-7-8-4:14.13
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.2
	rel-7-6-0:14.8
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.23
date	2007.10.22.17.42.34;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.10.14.22.15.54;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.07.26.01.13.51;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.03.08.13.43.40;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.02.02.08.48.28;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.27.01.41.32;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.09.12.19.29.57;	author mjgillich;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.28.00.36.27;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.09.09.05.50.29;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.08.24.04.07.40;	author brlcad;	state Exp;
branches
	14.8.2.1;
next	14.7;

14.7
date	2005.01.30.20.30.20;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.50;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.10;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.24.14.51.28;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.09;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.53;	author morrison;	state Exp;
branches;
next	;

14.8.2.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.23
log
@whoosh, another 10% complete on the bu_bomb to bu_exit conversion review.  also includes a slew of custom exit() calls that can use bu_exit() as well as toning down a slew of overzealous exclamation point use.  (20% complete overall)
@
text
@/*                         G - X X X . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file g-xxx.c
 *
 *	Sample code for converting BRL-CAD models to some other format.
 *	This code assumes that your receiving format can handle CSG primitives
 *	and Boolean trees with transformation matrices
 *
 *  Author -
 *	John R. Anderson
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.22 2007/10/14 22:15:54 brlcad Exp $";
#endif

#include "common.h"

/* system headers */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

/* interface headers */
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "bu.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"

/*
  extern char *bu_optarg;
  extern int bu_optind, bu_opterr, bu_getopt();
*/

#define NUM_OF_CPUS_TO_USE 1

#define DEBUG_NAMES 1
#define DEBUG_STATS 2

long debug = 0;
int verbose = 0;

static struct db_i		*dbip;
static struct bn_tol		tol;

static const char usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";


int region_start (struct db_tree_state *tsp, struct db_full_path *pathp,
		  const struct rt_comb_internal * combp, genptr_t client_data );
union tree *region_end (struct db_tree_state *tsp, struct db_full_path *pathp,
			union tree *curtree, genptr_t client_data );
union tree *primitive_func( struct db_tree_state *tsp, struct db_full_path *pathp,
			    struct rt_db_internal *ip, genptr_t client_data);
void describe_tree( union tree *tree, struct bu_vls *str);


/*
 *			M A I N
 */
int
main(int argc, char *argv[])
{
    struct user_data {
	int info;
    } user_data;

    int		i;
    register int	c;
    char idbuf[132];

    struct rt_i *rtip;
    struct db_tree_state init_state;

    /*
      rt_init_resource(&rt_uniresource, 0, NULL);
      struct rt_db_internal intern;
      struct directory *dp;
    */
    bu_setlinebuf( stderr );

    /* calculational tolerances
     * mostly used by NMG routines
     */
    tol.magic = BN_TOL_MAGIC;
    tol.dist = 0.005;
    tol.dist_sq = tol.dist * tol.dist;
    tol.perp =1e-6;
    tol.para = 1 - tol.perp;

    /* Get command line arguments. */
    while ((c = bu_getopt(argc, argv, "t:a:n:o:r:vx:X:")) != EOF) {
	switch (c) {
	    case 't':		/* calculational tolerance */
		tol.dist = atof( bu_optarg );
		tol.dist_sq = tol.dist * tol.dist;
	    case 'o':		/* Output file name */
		/* grab output file name */
		break;
	    case 'v':		/* verbosity */
		verbose++;
		break;
	    case 'x':		/* librt debug flag (see librt/debug.h) */
		sscanf( bu_optarg, "%x", &rt_g.debug );
		bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
		bu_log("\n");
		break;
	    case 'X':		/* NMG debug flag (see h/nmg.h) */
		sscanf( bu_optarg, "%x", &rt_g.NMG_debug );
		bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
		bu_log("\n");
		break;
	    default:
		bu_exit(1, usage, argv[0]);
		break;
	}
    }

    if (bu_optind+1 >= argc) {
	bu_exit(1, usage, argv[0]);
    }

    /* Open BRL-CAD database */
    /* Scan all the records in the database and build a directory */
    /* rtip=rt_dirbuild(argv[bu_optind], idbuf, sizeof(idbuf)); */
    rtip=rt_dirbuild(argv[bu_optind], idbuf, sizeof(idbuf));
    if ( rtip == RTI_NULL) {
	bu_exit(1, "g-xxx: rt_dirbuild failure\n");
    }

    init_state = rt_initial_tree_state;

    bu_optind++;

    /* Walk the trees named on the command line
     * outputting combinations and primitives
     */
    for( i=bu_optind ; i<argc ; i++ ) {
	db_walk_tree(rtip->rti_dbip, argc - i, (const char **)&argv[i], NUM_OF_CPUS_TO_USE,
		     &init_state ,region_start, region_end, primitive_func, (genptr_t) &user_data);
    }

    return 0;
}


/**
 *      R E G I O N _ S T A R T
 *
 * @@brief This routine is called when a region is first encountered in the
 * heirarchy when processing a tree
 *
 *      @@param tsp tree state (for parsing the tree)
 *      @@param pathp A listing of all the nodes traversed to get to this node in the database
 *      @@param combp the combination record for this region
 *      @@param client_data pointer that was passed as last argument to db_walk_tree()
 *
 */
int
region_start (struct db_tree_state *tsp,
	      struct db_full_path *pathp,
	      const struct rt_comb_internal *combp,
	      genptr_t client_data )
{
    struct rt_comb_internal *comb;
    struct directory *dp;
    struct bu_vls str;

    if (debug&DEBUG_NAMES) {
	char *name = db_path_to_string(pathp);
	bu_log("region_start %s\n", name);
	bu_free(name, "reg_start name");
    }

    dp = DB_FULL_PATH_CUR_DIR(pathp);

    /* here is where the conversion should be done */
    if( combp->region_flag )
	printf( "Write this region (name=%s) as a part in your format:\n", dp->d_namep );
    else
	printf( "Write this combination (name=%s) as an assembly in your format:\n", dp->d_namep );

    bu_vls_init( &str );

    describe_tree( combp->tree, &str );

    printf( "\t%s\n\n", bu_vls_addr( &str ) );

    bu_vls_free( &str );

    return 0;
}


/**
 *      R E G I O N _ E N D
 *
 *
 * @@brief This is called when all sub-elements of a region have been processed by leaf_func.
 *
 *      @@param tsp
 *      @@param pathp
 *      @@param curtree
 *      @@param client_data
 *
 *      @@return TREE_NULL if data in curtree was "stolen", otherwise db_walk_tree will
 *      clean up the dta in the union tree * that is returned
 *
 * If it wants to retain the data in curtree it can by returning TREE_NULL.  Otherwise
 * db_walk_tree will clean up the data in the union tree * that is returned.
 *
 */
union tree *
region_end (struct db_tree_state *tsp,
	    struct db_full_path *pathp,
	    union tree *curtree,
	    genptr_t client_data )
{
    if (debug&DEBUG_NAMES) {
	char *name = db_path_to_string(pathp);
	bu_log("region_end   %s\n", name);
	bu_free(name, "region_end name");
    }

    return curtree;
}


/* This routine just produces an ascii description of the Boolean tree.
 * In a real converter, this would output the tree in the desired format.
 */
void
describe_tree( union tree *tree,
	       struct bu_vls *str)
{
    struct bu_vls left, right;
    char *unionn=" u ";
    char *sub=" - ";
    char *inter=" + ";
    char *xor=" ^ ";
    char *op=NULL;

    BU_CK_VLS(str);

    if( !tree )	{
	/* this tree has no members */
	bu_vls_strcat( str, "-empty-" );
	return;
    }

    RT_CK_TREE(tree);

    /* Handle all the possible node types.
     * the first four are the most common types, and are typically
     * the only ones found in a BRL-CAD database.
     */
    switch( tree->tr_op ) {
	case OP_DB_LEAF:	/* leaf node, this is a member */
	    /* Note: tree->tr_l.tl_mat is a pointer to a
	     * transformation matrix to apply to this member
	     */
	    bu_vls_strcat( str,  tree->tr_l.tl_name );
	    break;
	case OP_UNION:		/* union operator node */
	    op = unionn;
	    goto binary;
	case OP_INTERSECT:	/* intersection operator node */
	    op = inter;
	    goto binary;
	case OP_SUBTRACT:	/* subtraction operator node */
	    op = sub;
	    goto binary;
	case OP_XOR:		/* exclusive "or" operator node */
	    op = xor;
    binary:				/* common for all binary nodes */
	    bu_vls_init( &left );
	    bu_vls_init( &right );
	    describe_tree( tree->tr_b.tb_left, &left );
	    describe_tree( tree->tr_b.tb_right, &right );
	    bu_vls_putc( str, '(' );
	    bu_vls_vlscatzap( str, &left );
	    bu_vls_strcat( str, op );
	    bu_vls_vlscatzap( str, &right );
	    bu_vls_putc( str, ')' );
	    break;
	case OP_NOT:
	    bu_vls_strcat( str, "(!" );
	    describe_tree( tree->tr_b.tb_left, str );
	    bu_vls_putc( str, ')' );
	    break;
	case OP_GUARD:
	    bu_vls_strcat( str, "(G" );
	    describe_tree( tree->tr_b.tb_left, str );
	    bu_vls_putc( str, ')' );
	    break;
	case OP_XNOP:
	    bu_vls_strcat( str, "(X" );
	    describe_tree( tree->tr_b.tb_left, str );
	    bu_vls_putc( str, ')' );
	    break;
	case OP_NOP:
	    bu_vls_strcat( str, "NOP" );
	    break;
	default:
	    bu_exit(1, "ERROR: describe_tree() got unrecognized op (%d)\n", tree->tr_op );
    }
}


/* This routine is called by the tree walker (db_walk_tree)
 * for every primitive encountered in the trees specified on the command line */
union tree *
primitive_func( struct db_tree_state *tsp,
		struct db_full_path *pathp,
		struct rt_db_internal *ip,
		genptr_t client_data)
{
    int i;

    struct directory *dp;
    dp = DB_FULL_PATH_CUR_DIR(pathp);

    if (debug&DEBUG_NAMES) {
	char *name = db_path_to_string(pathp);
	bu_log("leaf_func    %s\n", name);
	bu_free(name, "region_end name");
    }

    /* handle each type of primitive (see h/rtgeom.h) */
    if( ip->idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
	switch( ip->idb_type ) {
	    /* most commonly used primitives */
	    case ID_TOR:	/* torus */
		{
		    struct rt_tor_internal *tor = (struct rt_tor_internal *)ip->idb_ptr;

		    printf( "Write this torus (name=%s) in your format:\n", dp->d_namep );
		    printf( "\tV=(%g %g %g)\n", V3ARGS( tor->v ) );
		    printf( "\tnormal=(%g %g %g)\n", V3ARGS( tor->h ) );
		    printf( "\tradius1 = %g\n", tor->r_a );
		    printf( "\tradius2 = %g\n", tor->r_h );
		    break;
		}
	    case ID_TGC: /* truncated general cone frustum */
	    case ID_REC: /* right elliptical cylinder */
		{
		    /* This primitive includes circular cross-section
		     * cones and cylinders
		     */
		    struct rt_tgc_internal *tgc = (struct rt_tgc_internal *)ip->idb_ptr;

		    printf( "Write this TGC (name=%s) in your format:\n", dp->d_namep );
		    printf( "\tV=(%g %g %g)\n", V3ARGS( tgc->v ) );
		    printf( "\tH=(%g %g %g)\n", V3ARGS( tgc->h ) );
		    printf( "\tA=(%g %g %g)\n", V3ARGS( tgc->a ) );
		    printf( "\tB=(%g %g %g)\n", V3ARGS( tgc->b ) );
		    printf( "\tC=(%g %g %g)\n", V3ARGS( tgc->c ) );
		    printf( "\tD=(%g %g %g)\n", V3ARGS( tgc->d ) );
		    break;
		}
	    case ID_ELL:
	    case ID_SPH:
		{
		    /* spheres and ellipsoids */
		    struct rt_ell_internal *ell = (struct rt_ell_internal *)ip->idb_ptr;

		    printf( "Write this ellipsoid (name=%s) in your format:\n", dp->d_namep );
		    printf( "\tV=(%g %g %g)\n", V3ARGS( ell->v ) );
		    printf( "\tA=(%g %g %g)\n", V3ARGS( ell->a ) );
		    printf( "\tB=(%g %g %g)\n", V3ARGS( ell->b ) );
		    printf( "\tC=(%g %g %g)\n", V3ARGS( ell->c ) );
		    break;
		}
	    case ID_ARB8:	/* convex primitive with from four to six faces */
		{
		    /* this primitive may have degenerate faces
		     * faces are: 0123, 7654, 0347, 1562, 0451, 3267
		     * (points listed above in counter-clockwise order)
		     */
		    struct rt_arb_internal *arb = (struct rt_arb_internal *)ip->idb_ptr;

		    printf( "Write this ARB (name=%s) in your format:\n", dp->d_namep );
		    for( i=0 ; i<8 ; i++ )
			printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
		    break;
		}
	    case ID_BOT:	/* Bag O' Triangles */
		{
		    struct rt_bot_internal *bot = (struct rt_bot_internal *)ip->idb_ptr;
		    break;
		}

		/* less commonly used primitives */
	    case ID_ARS:
		{
		    /* series of curves
		     * each with the same number of points
		     */
		    struct rt_ars_internal *ars = (struct rt_ars_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_HALF:
		{
		    /* half universe defined by a plane */
		    struct rt_half_internal *half = (struct rt_half_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_POLY:
		{
		    /* polygons (up to 5 vertices per) */
		    struct rt_pg_internal *pg = (struct rt_pg_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_BSPLINE:
		{
		    /* NURB surfaces */
		    struct rt_nurb_internal *nurb = (struct rt_nurb_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_NMG:
		{
		    /* N-manifold geometry */
		    struct model *m = (struct model *)ip->idb_ptr;
		    break;
		}
	    case ID_ARBN:
		{
		    struct rt_arbn_internal *arbn = (struct rt_arbn_internal *)ip->idb_ptr;
		    break;
		}

	    case ID_DSP:
		{
		    /* Displacement map (terrain primitive) */
		    /* normally used for terrain only */
		    /* the DSP primitive may reference an external file */
		    struct rt_dsp_internal *dsp = (struct rt_dsp_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_HF:
		{
		    /* height field (terrain primitive) */
		    /* the HF primitive references an external file */
		    struct rt_hf_internal *hf = (struct rt_hf_internal *)ip->idb_ptr;
		    break;
		}

		/* rarely used primitives */
	    case ID_EBM:
		{
		    /* extruded bit-map */
		    /* the EBM primitive references an external file */
		    struct rt_ebm_internal *ebm = (struct rt_ebm_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_VOL:
		{
		    /* the VOL primitive references an external file */
		    struct rt_vol_internal *vol = (struct rt_vol_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_PIPE:
		{
		    struct rt_pipe_internal *pipe = (struct rt_pipe_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_PARTICLE:
		{
		    struct rt_part_internal *part = (struct rt_part_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_RPC:
		{
		    struct rt_rpc_internal *rpc = (struct rt_rpc_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_RHC:
		{
		    struct rt_rhc_internal *rhc = (struct rt_rhc_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_EPA:
		{
		    struct rt_epa_internal *epa = (struct rt_epa_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_EHY:
		{
		    struct rt_ehy_internal *ehy = (struct rt_ehy_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_ETO:
		{
		    struct rt_eto_internal *eto = (struct rt_eto_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_GRIP:
		{
		    struct rt_grip_internal *grip = (struct rt_grip_internal *)ip->idb_ptr;
		    break;
		}

	    case ID_SKETCH:
		{
		    struct rt_sketch_internal *sketch = (struct rt_sketch_internal *)ip->idb_ptr;
		    break;
		}
	    case ID_EXTRUDE:
		{
		    /* note that an extrusion references a sketch, make sure you convert
		     * the sketch also
		     */
		    struct rt_extrude_internal *extrude = (struct rt_extrude_internal *)ip->idb_ptr;
		    break;
		}

	    default:
		bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_type );
		break;
	}
    } else {
	switch( ip->idb_major_type ) {
	    case DB5_MAJORTYPE_BINARY_UNIF:
		{
		    /* not actually a primitive, just a block of storage for data
		     * a uniform array of chars, ints, floats, doubles, ...
		     */
		    struct rt_binunif_internal *bin = (struct rt_binunif_internal *)ip->idb_ptr;

		    printf( "Found a binary object (%s)\n\n", dp->d_namep );
		    break;
		}
	    default:
		bu_log( "Major type of %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_major_type );
		break;
	}
    }

    return (union tree *) NULL;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.22
log
@more level 4 flawfinder issues.  mostly string length clampages.
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.21 2007/09/15 16:23:04 brlcad Exp $";
d57 2
a58 2
extern char *bu_optarg;
extern int bu_optind, bu_opterr, bu_getopt();
d90 52
a141 54
	struct user_data {
	   int info;
	} user_data;

	int		i;
	register int	c;
	char idbuf[132];

	struct rt_i *rtip;
	struct db_tree_state init_state;

/*
	rt_init_resource(&rt_uniresource, 0, NULL);
	struct rt_db_internal intern;
	struct directory *dp;
*/
	bu_setlinebuf( stderr );

	/* calculational tolerances
	 * mostly used by NMG routines
	 */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp =1e-6;
	tol.para = 1 - tol.perp;

	/* Get command line arguments. */
	while ((c = bu_getopt(argc, argv, "t:a:n:o:r:vx:X:")) != EOF) {
		switch (c) {
		case 't':		/* calculational tolerance */
			tol.dist = atof( bu_optarg );
			tol.dist_sq = tol.dist * tol.dist;
		case 'o':		/* Output file name */
			/* grab output file name */
			break;
		case 'v':		/* verbosity */
			verbose++;
			break;
		case 'x':		/* librt debug flag (see librt/debug.h) */
			sscanf( bu_optarg, "%x", &rt_g.debug );
			bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
			bu_log("\n");
			break;
		case 'X':		/* NMG debug flag (see h/nmg.h) */
			sscanf( bu_optarg, "%x", &rt_g.NMG_debug );
			bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
			bu_log("\n");
			break;
		default:
			fprintf(stderr, usage, argv[0]);
			exit(1);
			break;
		}
d143 1
d145 3
a147 4
	if (bu_optind+1 >= argc) {
		fprintf(stderr, usage, argv[0]);
		exit(1);
	}
d149 7
a155 8
	/* Open BRL-CAD database */
	/* Scan all the records in the database and build a directory */
	/* rtip=rt_dirbuild(argv[bu_optind], idbuf, sizeof(idbuf)); */
	rtip=rt_dirbuild(argv[bu_optind], idbuf, sizeof(idbuf));
	if ( rtip == RTI_NULL) {
	   fprintf(stderr,"g-xxx: rt_dirbuild failure\n");
	   exit(1);
	}
d157 1
a157 1
	init_state = rt_initial_tree_state;
d159 1
a159 1
	bu_optind++;
d161 7
a167 8
	/* Walk the trees named on the command line
	 * outputting combinations and primitives
	 */
	for( i=bu_optind ; i<argc ; i++ )
	{
	    db_walk_tree(rtip->rti_dbip, argc - i, (const char **)&argv[i], NUM_OF_CPUS_TO_USE,
			 &init_state ,region_start, region_end, primitive_func, (genptr_t) &user_data);
	}
d169 1
a169 1
	return 0;
d205 1
a205 1
	    printf( "Write this region (name=%s) as a part in your format:\n", dp->d_namep );
d207 1
a207 1
	    printf( "Write this combination (name=%s) as an assembly in your format:\n", dp->d_namep );
d262 14
a275 15
	struct bu_vls left, right;
	char *unionn=" u ";
	char *sub=" - ";
	char *inter=" + ";
	char *xor=" ^ ";
	char *op=NULL;

	BU_CK_VLS(str);

	if( !tree )
	{
		/* this tree has no members */
		bu_vls_strcat( str, "-empty-" );
		return;
	}
d277 1
a277 1
	RT_CK_TREE(tree);
d279 54
a332 56
	/* Handle all the possible node types.
	 * the first four are the most common types, and are typically
	 * the only ones found in a BRL-CAD database.
	 */
	switch( tree->tr_op )
	{
		case OP_DB_LEAF:	/* leaf node, this is a member */
			/* Note: tree->tr_l.tl_mat is a pointer to a
			 * transformation matrix to apply to this member
			 */
			bu_vls_strcat( str,  tree->tr_l.tl_name );
			break;
		case OP_UNION:		/* union operator node */
			op = unionn;
			goto binary;
		case OP_INTERSECT:	/* intersection operator node */
			op = inter;
			goto binary;
		case OP_SUBTRACT:	/* subtraction operator node */
			op = sub;
			goto binary;
		case OP_XOR:		/* exclusive "or" operator node */
			op = xor;
binary:				/* common for all binary nodes */
			bu_vls_init( &left );
			bu_vls_init( &right );
			describe_tree( tree->tr_b.tb_left, &left );
			describe_tree( tree->tr_b.tb_right, &right );
			bu_vls_putc( str, '(' );
			bu_vls_vlscatzap( str, &left );
			bu_vls_strcat( str, op );
			bu_vls_vlscatzap( str, &right );
			bu_vls_putc( str, ')' );
			break;
		case OP_NOT:
			bu_vls_strcat( str, "(!" );
			describe_tree( tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_GUARD:
			bu_vls_strcat( str, "(G" );
			describe_tree( tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_XNOP:
			bu_vls_strcat( str, "(X" );
			describe_tree( tree->tr_b.tb_left, str );
			bu_vls_putc( str, ')' );
			break;
		case OP_NOP:
			bu_vls_strcat( str, "NOP" );
			break;
		default:
			bu_log( "ERROR: describe_tree() got unrecognized op (%d)\n", tree->tr_op );
			bu_bomb( "ERROR: bad op\n" );
	}
d344 1
a344 1
	int i;
d346 8
a353 2
	struct directory *dp;
	dp = DB_FULL_PATH_CUR_DIR(pathp);
d355 191
a545 4
	if (debug&DEBUG_NAMES) {
	    char *name = db_path_to_string(pathp);
	    bu_log("leaf_func    %s\n", name);
	    bu_free(name, "region_end name");
d547 8
d556 2
a557 209
	/* handle each type of primitive (see h/rtgeom.h) */
	if( ip->idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
		switch( ip->idb_type )
			{
				/* most commonly used primitives */
			case ID_TOR:	/* torus */
				{
					struct rt_tor_internal *tor = (struct rt_tor_internal *)ip->idb_ptr;

					printf( "Write this torus (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( tor->v ) );
					printf( "\tnormal=(%g %g %g)\n", V3ARGS( tor->h ) );
					printf( "\tradius1 = %g\n", tor->r_a );
					printf( "\tradius2 = %g\n", tor->r_h );
					break;
				}
			case ID_TGC: /* truncated general cone frustum */
			case ID_REC: /* right elliptical cylinder */
				{
					/* This primitive includes circular cross-section
					 * cones and cylinders
					 */
					struct rt_tgc_internal *tgc = (struct rt_tgc_internal *)ip->idb_ptr;

					printf( "Write this TGC (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( tgc->v ) );
					printf( "\tH=(%g %g %g)\n", V3ARGS( tgc->h ) );
					printf( "\tA=(%g %g %g)\n", V3ARGS( tgc->a ) );
					printf( "\tB=(%g %g %g)\n", V3ARGS( tgc->b ) );
					printf( "\tC=(%g %g %g)\n", V3ARGS( tgc->c ) );
					printf( "\tD=(%g %g %g)\n", V3ARGS( tgc->d ) );
					break;
				}
			case ID_ELL:
			case ID_SPH:
				{
					/* spheres and ellipsoids */
					struct rt_ell_internal *ell = (struct rt_ell_internal *)ip->idb_ptr;

					printf( "Write this ellipsoid (name=%s) in your format:\n", dp->d_namep );
					printf( "\tV=(%g %g %g)\n", V3ARGS( ell->v ) );
					printf( "\tA=(%g %g %g)\n", V3ARGS( ell->a ) );
					printf( "\tB=(%g %g %g)\n", V3ARGS( ell->b ) );
					printf( "\tC=(%g %g %g)\n", V3ARGS( ell->c ) );
					break;
				}
			case ID_ARB8:	/* convex primitive with from four to six faces */
				{
					/* this primitive may have degenerate faces
					 * faces are: 0123, 7654, 0347, 1562, 0451, 3267
					 * (points listed above in counter-clockwise order)
					 */
					struct rt_arb_internal *arb = (struct rt_arb_internal *)ip->idb_ptr;

					printf( "Write this ARB (name=%s) in your format:\n", dp->d_namep );
					for( i=0 ; i<8 ; i++ )
						printf( "\tpoint #%d: (%g %g %g)\n", i, V3ARGS( arb->pt[i] ) );
					break;
				}
			case ID_BOT:	/* Bag O' Triangles */
				{
					struct rt_bot_internal *bot = (struct rt_bot_internal *)ip->idb_ptr;
					break;
				}

				/* less commonly used primitives */
			case ID_ARS:
				{
					/* series of curves
					 * each with the same number of points
					 */
					struct rt_ars_internal *ars = (struct rt_ars_internal *)ip->idb_ptr;
					break;
				}
			case ID_HALF:
				{
					/* half universe defined by a plane */
					struct rt_half_internal *half = (struct rt_half_internal *)ip->idb_ptr;
					break;
				}
			case ID_POLY:
				{
					/* polygons (up to 5 vertices per) */
					struct rt_pg_internal *pg = (struct rt_pg_internal *)ip->idb_ptr;
					break;
				}
			case ID_BSPLINE:
				{
					/* NURB surfaces */
					struct rt_nurb_internal *nurb = (struct rt_nurb_internal *)ip->idb_ptr;
					break;
				}
			case ID_NMG:
				{
					/* N-manifold geometry */
					struct model *m = (struct model *)ip->idb_ptr;
					break;
				}
			case ID_ARBN:
				{
					struct rt_arbn_internal *arbn = (struct rt_arbn_internal *)ip->idb_ptr;
					break;
				}

			case ID_DSP:
				{
					/* Displacement map (terrain primitive) */
					/* normally used for terrain only */
					/* the DSP primitive may reference an external file */
					struct rt_dsp_internal *dsp = (struct rt_dsp_internal *)ip->idb_ptr;
					break;
				}
			case ID_HF:
				{
					/* height field (terrain primitive) */
					/* the HF primitive references an external file */
					struct rt_hf_internal *hf = (struct rt_hf_internal *)ip->idb_ptr;
					break;
				}

				/* rarely used primitives */
			case ID_EBM:
				{
					/* extruded bit-map */
					/* the EBM primitive references an external file */
					struct rt_ebm_internal *ebm = (struct rt_ebm_internal *)ip->idb_ptr;
					break;
				}
			case ID_VOL:
				{
					/* the VOL primitive references an external file */
					struct rt_vol_internal *vol = (struct rt_vol_internal *)ip->idb_ptr;
					break;
				}
			case ID_PIPE:
				{
					struct rt_pipe_internal *pipe = (struct rt_pipe_internal *)ip->idb_ptr;
					break;
				}
			case ID_PARTICLE:
				{
					struct rt_part_internal *part = (struct rt_part_internal *)ip->idb_ptr;
					break;
				}
			case ID_RPC:
				{
					struct rt_rpc_internal *rpc = (struct rt_rpc_internal *)ip->idb_ptr;
					break;
				}
			case ID_RHC:
				{
					struct rt_rhc_internal *rhc = (struct rt_rhc_internal *)ip->idb_ptr;
					break;
				}
			case ID_EPA:
				{
					struct rt_epa_internal *epa = (struct rt_epa_internal *)ip->idb_ptr;
					break;
				}
			case ID_EHY:
				{
					struct rt_ehy_internal *ehy = (struct rt_ehy_internal *)ip->idb_ptr;
					break;
				}
			case ID_ETO:
				{
					struct rt_eto_internal *eto = (struct rt_eto_internal *)ip->idb_ptr;
					break;
				}
			case ID_GRIP:
				{
					struct rt_grip_internal *grip = (struct rt_grip_internal *)ip->idb_ptr;
					break;
				}

			case ID_SKETCH:
				{
					struct rt_sketch_internal *sketch = (struct rt_sketch_internal *)ip->idb_ptr;
					break;
				}
			case ID_EXTRUDE:
				{
					/* note that an extrusion references a sketch, make sure you convert
					 * the sketch also
					 */
					struct rt_extrude_internal *extrude = (struct rt_extrude_internal *)ip->idb_ptr;
					break;
				}

			default:
					bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_type );
					break;
		 }
	}
	else {
		switch( ip->idb_major_type ) {
			case DB5_MAJORTYPE_BINARY_UNIF:
				{
					/* not actually a primitive, just a block of storage for data
					 * a uniform array of chars, ints, floats, doubles, ...
					 */
					struct rt_binunif_internal *bin = (struct rt_binunif_internal *)ip->idb_ptr;

					printf( "Found a binary object (%s)\n\n", dp->d_namep );
					break;
				}
			default:
				bu_log( "Major type of %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_major_type );
				break;
d559 3
d563 1
d565 1
a565 1
	return (union tree *) NULL;
@


14.21
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.20 2007/07/26 01:13:51 brlcad Exp $";
d72 1
a72 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
@


14.20
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.19 2007/03/08 13:43:40 brlcad Exp $";
d41 1
a41 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.19
log
@c89 support, declare functions first
@
text
@a28 4
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d32 1
a32 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.18 2007/02/02 08:48:28 brlcad Exp $";
@


14.18
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.17 2007/01/27 01:41:32 brlcad Exp $";
d106 3
a108 1
	bu_setlinebuf( stderr );
d114 1
a114 2
	struct rt_i *rtip;
	struct db_tree_state init_state;
@


14.17
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.16 2007/01/23 01:13:25 brlcad Exp $";
d65 2
a66 2
extern char *optarg;
extern int optind, opterr, getopt();
d125 1
a125 1
	while ((c = getopt(argc, argv, "t:a:n:o:r:vx:X:")) != EOF) {
d128 1
a128 1
			tol.dist = atof( optarg );
d137 1
a137 1
			sscanf( optarg, "%x", &rt_g.debug );
d142 1
a142 1
			sscanf( optarg, "%x", &rt_g.NMG_debug );
d153 1
a153 1
	if (optind+1 >= argc) {
d160 2
a161 2
	/* rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf)); */
	rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf));
d169 1
a169 1
	optind++;
d174 1
a174 1
	for( i=optind ; i<argc ; i++ )
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.15 2007/01/21 04:45:41 brlcad Exp $";
d84 1
a84 1
                  const struct rt_comb_internal * combp, genptr_t client_data );
d86 1
a86 1
                        union tree *curtree, genptr_t client_data );
d88 1
a88 1
                            struct rt_db_internal *ip, genptr_t client_data);
d98 3
a100 3
        struct user_data {
           int info;
        } user_data;
d104 1
a104 1
        char idbuf[132];
d109 2
a110 2
        struct rt_db_internal intern;
        struct directory *dp;
d112 2
a113 2
        struct rt_i *rtip;
        struct db_tree_state init_state;
d160 6
a165 6
        /* rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf)); */
        rtip=rt_dirbuild(argv[optind], idbuf, sizeof(idbuf));
        if ( rtip == RTI_NULL) {
           fprintf(stderr,"g-xxx: rt_dirbuild failure\n");
           exit(1);
        }
d167 1
a167 1
        init_state = rt_initial_tree_state;
d176 2
a177 2
            db_walk_tree(rtip->rti_dbip, argc - i, (const char **)&argv[i], NUM_OF_CPUS_TO_USE,
                         &init_state ,region_start, region_end, primitive_func, (genptr_t) &user_data);
d198 3
a200 3
              struct db_full_path *pathp,
              const struct rt_comb_internal *combp,
              genptr_t client_data )
d207 3
a209 3
        char *name = db_path_to_string(pathp);
        bu_log("region_start %s\n", name);
        bu_free(name, "reg_start name");
d252 3
a254 3
            struct db_full_path *pathp,
            union tree *curtree,
            genptr_t client_data )
d257 3
a259 3
        char *name = db_path_to_string(pathp);
        bu_log("region_end   %s\n", name);
        bu_free(name, "region_end name");
d271 1
a271 1
               struct bu_vls *str)
a349 1

d354 3
a356 3
                struct db_full_path *pathp,
                struct rt_db_internal *ip,
                genptr_t client_data)
d358 1
a358 1
        int i;
d360 2
a361 2
        struct directory *dp;
        dp = DB_FULL_PATH_CUR_DIR(pathp);
d363 5
a367 5
        if (debug&DEBUG_NAMES) {
            char *name = db_path_to_string(pathp);
            bu_log("leaf_func    %s\n", name);
            bu_free(name, "region_end name");
        }
d559 3
a561 3
			          	bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, ip->idb_type );
                                        break;
	         }
d563 1
a563 1
        else {
d581 1
a581 1
        return (union tree *) NULL;
@


14.15
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.14 2007/01/20 14:36:43 brlcad Exp $";
@


14.14
log
@update copyright to 2007
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.13 2006/09/12 19:29:57 mjgillich Exp $";
d188 1
a188 1
 * \brief This routine is called when a region is first encountered in the
d191 4
a194 4
 *      \param tsp tree state (for parsing the tree)
 *      \param pathp A listing of all the nodes traversed to get to this node in the database
 *      \param combp the combination record for this region
 *      \param client_data pointer that was passed as last argument to db_walk_tree()
d237 1
a237 1
 * \brief This is called when all sub-elements of a region have been processed by leaf_func.
d239 4
a242 4
 *      \param tsp
 *      \param pathp
 *      \param curtree
 *      \param client_data
d244 1
a244 1
 *      \return TREE_NULL if data in curtree was "stolen", otherwise db_walk_tree will
@


14.13
log
@Modified g-xxx.c to db_walk_tree verses db_fun_tree
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2006 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.12 2006/01/28 00:36:27 brlcad Exp $";
@


14.12
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.11 2006/01/18 06:46:13 brlcad Exp $";
d60 1
d65 9
d75 2
a76 2
BU_EXTERN( void comb_func , ( struct db_i *dbip , struct directory *dp, genptr_t data ) );
BU_EXTERN( void primitive_func , ( struct db_i *dbip , struct directory *dp, genptr_t data ) );
a77 1
static int	verbose;
d81 10
a91 1
static char	usage[] = "Usage: %s [-v] [-xX lvl] [-a abs_tol] [-r rel_tol] [-n norm_tol] [-o out_file] brlcad_db.g object(s)\n";
d97 1
a97 3
main(argc, argv)
int	argc;
char	*argv[];
d99 4
d105 1
d108 1
a108 1

d110 5
d122 1
a122 1
	tol.perp = 1e-6;
d160 7
a166 6
	if ((dbip = db_open( argv[optind] , "r")) == DBI_NULL)
	{
		bu_log( "Cannot open %s\n" , argv[optind] );
		perror(argv[0]);
		exit(1);
	}
d168 1
a168 4
	/* scan all the records in the database and build a directory */
	db_dirbuild( dbip );

	/* open output file */
d177 54
a230 1
		struct directory *dp;
a231 8
		dp = db_lookup( dbip , argv[i] , 0 );
		if( dp == DIR_NULL )
		{
			bu_log( "WARNING!!! Could not find %s, skipping\n", argv[i] );
			continue;
		}
		db_functree( dbip, dp, comb_func, primitive_func, &rt_uniresource, NULL );
	}
d233 29
a261 1
	db_close(dbip);
d263 1
a263 1
	return 0;
d266 1
d271 2
a272 5
describe_tree( dbip, comb, tree, str )
struct db_i             *dbip;
struct rt_comb_internal *comb;
union tree              *tree;
struct bu_vls		*str;
d318 2
a319 2
			describe_tree( dbip, comb, tree->tr_b.tb_left, &left );
			describe_tree( dbip, comb, tree->tr_b.tb_right, &right );
d328 1
a328 1
			describe_tree( dbip, comb, tree->tr_b.tb_left, str );
d333 1
a333 1
			describe_tree( dbip, comb, tree->tr_b.tb_left, str );
d338 1
a338 1
			describe_tree( dbip, comb, tree->tr_b.tb_left, str );
a349 14
/* This function is called by the tree walker "db_functree" for each
 * combination encountered. This should either call a routine
 * to output the combination in your format, or do it itself.
 */
void
comb_func( dbip, dp, ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
{
	struct rt_db_internal itrn;
	struct rt_comb_internal *comb;
	int id;
	struct bu_vls str;
a350 18
	/* check if we already output this object */
	if( dp->d_uses )
		return;

	/* get the internal format of this combination */
	if( (id=rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity, &rt_uniresource ) ) < 0 )
	{
		bu_log( "rt_db_get_internal failed for %s\n", dp->d_namep );
		return;
	}

	RT_CK_DB_INTERNAL( &itrn );

	if( id != ID_COMBINATION )
	{
		bu_log( "ERROR: comb_func called for a non-combination (%s)\n", dp->d_namep );
		exit( 1 );
	}
d352 1
a352 22
	/* get the combination structure */
	comb = (struct rt_comb_internal *)itrn.idb_ptr;

	/* here is where the conversion should be done */
	if( comb->region_flag )
		printf( "Write this region (name=%s) as a part in your format:\n", dp->d_namep );
	else
		printf( "Write this combination (name=%s) as an assembly in your format:\n", dp->d_namep );

	bu_vls_init( &str );

	describe_tree( dbip, comb, comb->tree, &str );

	printf( "\t%s\n\n", bu_vls_addr( &str ) );

	bu_vls_free( &str );

	/* mark this object as converted */
	dp->d_uses++;
}

/* This routine is called by the tree walker (db_functree)
d354 5
a358 5
void
primitive_func( dbip, dp, ptr )
struct db_i *dbip;
struct directory *dp;
genptr_t	ptr;
d360 1
a360 5
	struct rt_db_internal itrn;

	/* check if we already converted this primitive */
	if( dp->d_uses )
		return;
d362 2
a363 6
	/* get the internal form of the primitive */
	if( rt_db_get_internal( &itrn, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
		bu_log( "rt_db_get_internal failed for %s\n", dp->d_namep );
		return;
	}
d365 5
a369 1
	RT_CK_DB_INTERNAL( &itrn );
d372 2
a373 2
	if( itrn.idb_major_type == DB5_MAJORTYPE_BRLCAD ) {
		switch( itrn.idb_type )
d378 1
a378 1
					struct rt_tor_internal *tor = (struct rt_tor_internal *)itrn.idb_ptr;
d393 1
a393 1
					struct rt_tgc_internal *tgc = (struct rt_tgc_internal *)itrn.idb_ptr;
d408 1
a408 1
					struct rt_ell_internal *ell = (struct rt_ell_internal *)itrn.idb_ptr;
d423 1
a423 2
					struct rt_arb_internal *arb = (struct rt_arb_internal *)itrn.idb_ptr;
					int i;
d432 1
a432 1
					struct rt_bot_internal *bot = (struct rt_bot_internal *)itrn.idb_ptr;
d442 1
a442 1
					struct rt_ars_internal *ars = (struct rt_ars_internal *)itrn.idb_ptr;
d448 1
a448 1
					struct rt_half_internal *half = (struct rt_half_internal *)itrn.idb_ptr;
d454 1
a454 1
					struct rt_pg_internal *pg = (struct rt_pg_internal *)itrn.idb_ptr;
d460 1
a460 1
					struct rt_nurb_internal *nurb = (struct rt_nurb_internal *)itrn.idb_ptr;
d466 1
a466 1
					struct model *m = (struct model *)itrn.idb_ptr;
d471 1
a471 1
					struct rt_arbn_internal *arbn = (struct rt_arbn_internal *)itrn.idb_ptr;
d480 1
a480 1
					struct rt_dsp_internal *dsp = (struct rt_dsp_internal *)itrn.idb_ptr;
d487 1
a487 1
					struct rt_hf_internal *hf = (struct rt_hf_internal *)itrn.idb_ptr;
d496 1
a496 1
					struct rt_ebm_internal *ebm = (struct rt_ebm_internal *)itrn.idb_ptr;
d502 1
a502 1
					struct rt_vol_internal *vol = (struct rt_vol_internal *)itrn.idb_ptr;
d507 1
a507 1
					struct rt_pipe_internal *pipe = (struct rt_pipe_internal *)itrn.idb_ptr;
d512 1
a512 1
					struct rt_part_internal *part = (struct rt_part_internal *)itrn.idb_ptr;
d517 1
a517 1
					struct rt_rpc_internal *rpc = (struct rt_rpc_internal *)itrn.idb_ptr;
d522 1
a522 1
					struct rt_rhc_internal *rhc = (struct rt_rhc_internal *)itrn.idb_ptr;
d527 1
a527 1
					struct rt_epa_internal *epa = (struct rt_epa_internal *)itrn.idb_ptr;
d532 1
a532 1
					struct rt_ehy_internal *ehy = (struct rt_ehy_internal *)itrn.idb_ptr;
d537 1
a537 1
					struct rt_eto_internal *eto = (struct rt_eto_internal *)itrn.idb_ptr;
d542 1
a542 1
					struct rt_grip_internal *grip = (struct rt_grip_internal *)itrn.idb_ptr;
d548 1
a548 1
					struct rt_sketch_internal *sketch = (struct rt_sketch_internal *)itrn.idb_ptr;
d556 1
a556 1
					struct rt_extrude_internal *extrude = (struct rt_extrude_internal *)itrn.idb_ptr;
d561 6
a566 5
				bu_log( "Primitive %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_type );
				break;
			}
	} else {
		switch( itrn.idb_major_type ) {
d572 1
a572 1
					struct rt_binunif_internal *bin = (struct rt_binunif_internal *)itrn.idb_ptr;
d578 1
a578 1
				bu_log( "Major type of %s is unrecognized type (%d)\n", dp->d_namep, itrn.idb_major_type );
d583 1
a583 2
	/* mark this primitive as converted */
	dp->d_uses++;
@


14.11
log
@update copyright to 2006
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.10 2005/10/23 04:44:30 brlcad Exp $";
d42 2
d55 1
@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1993-2005 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.9 2005/09/09 05:50:29 brlcad Exp $";
@


14.9
log
@use BRL-CAD instead of brl-cad if only to be at least internally consistent and serve good example
@
text
@d30 1
a30 1
 *  
d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.8 2005/08/24 04:07:40 brlcad Exp $";
d86 1
a86 1
	
d505 1
a505 1
				
d519 1
a519 1
				
@


14.8
log
@replace the deprecated port_setlinebuf() with bu_setlinebuf()
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.7 2005/01/30 20:30:20 brlcad Exp $";
d130 1
a130 1
	/* Open brl-cad database */
@


14.8.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d30 1
a30 1
 *
d37 1
a37 1
static const char RCSid[] = "$Header$";
d86 1
a86 1

d130 1
a130 1
	/* Open BRL-CAD database */
d505 1
a505 1

d519 1
a519 1

@


14.7
log
@update copyright to 2005
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/g-xxx.c,v 14.6 2004/12/21 07:32:29 morrison Exp $";
d83 1
a83 1
	port_setlinebuf( stderr );
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2004 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 14.5 2004/12/21 06:58:41 morrison Exp $";
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a33 2
 *  
 *
d37 1
a37 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 14.4 2004/12/21 06:50:58 morrison Exp $";
@


14.4
log
@remove the old distribution notice section
@
text
@a35 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d39 1
a39 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 14.3 2004/12/18 06:50:50 morrison Exp $";
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a34 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
d42 1
a42 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 14.2 2004/12/18 02:38:10 morrison Exp $";
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file g-xxx.c
d46 1
a46 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 14.1 2004/11/16 19:42:12 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G - X X X . C
d45 1
a45 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 1.5 2004/09/24 14:51:28 morrison Exp $";
@


1.5
log
@help make distcheck get a whole lot farther ..
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 1.4 2004/09/03 23:30:56 morrison Exp $";
d534 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 1.3 2004/08/02 23:01:47 morrison Exp $";
a30 2


d34 1
a34 1
#include <string.h>
d36 4
a39 1
#include <strings.h>
d49 1
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/g-xxx.c,v 1.2 2004/06/08 22:04:09 morrison Exp $";
d35 1
a35 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header$";
d29 1
a29 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/g-xxx.c,v 1.11 2004/05/10 15:30:41 erikg Exp $";
a43 1
#include "externs.h"
@

