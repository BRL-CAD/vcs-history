head	14.31;
access;
symbols
	rel-7-10-4:14.22
	STABLE:14.22.0.2
	stable-branch:14.8
	rel-7-10-2:14.22
	rel-7-10-0:14.20
	rel-7-8-4:14.15
	rel-7-8-2:14.14
	rel-7-8-0:14.14
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.8.2.1
	rel-7-4-branch:14.8.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.31
date	2007.12.18.07.07.12;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.12.03.21.55.11;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.11.21.20.49.06;	author erikgreenwald;	state Exp;
branches;
next	14.28;

14.28
date	2007.11.21.20.38.21;	author erikgreenwald;	state Exp;
branches;
next	14.27;

14.27
date	2007.11.21.19.05.59;	author erikgreenwald;	state Exp;
branches;
next	14.26;

14.26
date	2007.11.21.15.21.33;	author erikgreenwald;	state Exp;
branches;
next	14.25;

14.25
date	2007.10.18.09.11.56;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.10.14.22.15.54;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.07.26.01.13.51;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.05.18.04.13.44;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.02.02.08.48.28;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.27.01.41.32;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.20.14.36.44;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.08.05.15.23;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.04.06.19.30.22;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.28.00.36.27;	author brlcad;	state Exp;
branches
	14.13.2.1;
next	14.12;

14.12
date	2006.01.24.05.00.26;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.07.26.04.40.53;	author brlcad;	state Exp;
branches
	14.9.4.1;
next	14.8;

14.8
date	2005.04.13.01.43.19;	author brlcad;	state Exp;
branches
	14.8.2.1;
next	14.7;

14.7
date	2005.01.30.20.30.20;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.51;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.10;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.10;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.55;	author morrison;	state Exp;
branches;
next	;

14.8.2.1
date	2005.08.16.21.03.48;	author brlcad;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;

14.13.2.1
date	2006.04.07.19.26.25;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.31
log
@null-terminate strncat'd buffers for sanity sake since we don't usually check if we filled/truncated
@
text
@/*                        P R O E - G . C
 * BRL-CAD
 *
 * Copyright (c) 1994-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file proe-g.c
 *		P R O E - G
 *
 * Code to convert ascii output from Pro/Engineer to BRL-CAD
 * The required output is from the Pro/Develop application proe-brl
 * that must be initiated from the "BRL-CAD" option of Pro/Engineer's
 * "EXPORT" menu.
 *
 *  Author -
 *	John R. Anderson
 */

#ifndef lint
static const char RCSid[] = "$Header$";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include <regex.h>
#include <errno.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"

extern char *bu_optarg;
extern int bu_optind,bu_opterr,optopt;

static	struct wmember all_head;
static char *input_file;	/* name of the input file */
static char *brlcad_file;	/* name of output file */
static struct bu_vls ret_name;	/* unique name built by Build_unique_name() */
static char *forced_name=NULL;	/* name specified on command line */
static int stl_format=0;	/* Flag, non-zero indocates raw Stereolithography format input */
static int solid_count=0;	/* count of solids converted */
static struct bn_tol tol;	/* Tolerance structure */
static int id_no=1000;		/* Ident numbers */
static int const_id=-1;		/* Constant ident number (assigned to all regions if non-negative) */
static int mat_code=1;		/* default material code */
static int air_no=1;		/* Air numbers */
static int debug=0;		/* Debug flag */
static int cut_count=0;		/* count of assembly cut HAF solids created */
static int do_regex=0;		/* flag to indicate if 'u' option is in effect */
#if 0
static int do_simplify=0;	/* flag to try to simplify solids */
#endif
static regex_t reg_cmp;		/* compiled regular expression */
static char *proe_usage="%s [-darS] [-t tolerance] [-i initial_ident] [-I constant_ident] [-m material_code] [-u reg_exp] [-x rt_debug_flag] proe_file.brl output.g\n\
	where proe_file.brl is the output from Pro/Engineer's BRL-CAD EXPORT option\n\
	and output.g is the name of a BRL-CAD database file to receive the conversion.\n\
	The -d option prints additional debugging information.\n\
	The -i option sets the initial region ident number (default is 1000).\n\
	The -I option sets the non-negative ident number that will be assigned to all regions (conflicts with -i).\n\
	The -m option sets the integer material code for all the parts. (default is 1)\n\
	The -u option indicates that portions of object names that match the regular expression\n\
		'reg_exp' should be ignored.\n\
	The -a option creates BRL-CAD 'air' regions from everything in the model.\n\
	The -r option indicates that the model should not be re-oriented or scaled,\n\
		but left in the same orientation as it was in Pro/E.\n\
		This is to allow conversion of parts to be included in\n\
		previously converted Pro/E assemblies.\n\
	The -S option indicates that the input file is raw STL (STereoLithography) format.\n\
	The -t option specifies the minumim distance between two distinct vertices (mm).\n\
	The -x option specifies an RT debug flags (see debug.h).\n";
static char *stl_usage="%s [-da] [-t tolerance] [-N forced_name] [-i initial_ident] [-I constant_ident] [-m material_code] [-c units_str] [-u reg_exp] [-x rt_debug_flag] input.stl output.g\n\
	where input.stl is a STereoLithography file\n\
	and output.g is the name of a BRL-CAD database file to receive the conversion.\n\
	The -c option specifies the units used in the STL file (units_str may be \"in\", \"ft\",... default is \"mm\"\n\
	The -N option specifies a name to use for the object.\n\
	The -d option prints additional debugging information.\n\
	The -i option sets the initial region ident number (default is 1000).\n\
	The -I option sets the ident number that will be assigned to all regions (conflicts with -i).\n\
	The -m option sets the integer material code for all the parts (default is 1).\n\
	The -u option indicates that portions of object names that match the regular expression\n\
		'reg_exp' should be ignored.\n\
	The -a option creates BRL-CAD 'air' regions from everything in the model.\n\
	The -t option specifies the minumim distance between two distinct vertices (mm).\n\
	The -x option specifies an RT debug flags (see debug.h).\n";
static char *usage;
static FILE *fd_in;		/* input file (from Pro/E) */
static struct rt_wdb *fd_out;	/* Resulting BRL-CAD file */
static struct bu_ptbl null_parts; /* Table of NULL solids */
static float conv_factor=1.0;	/* conversion factor from model units to mm */
static int top_level=1;		/* flag to catch top level assembly or part */
static mat_t re_orient;		/* rotation matrix to put model in BRL-CAD orientation
				 * (+x towards front +z is up ) */
static int do_air=0;		/* When set, all regions are BRL-CAD "air" regions */
static int do_reorient=1;	/* When set, reorient entire model to BRL-CAD style */
static unsigned int obj_count=0; /* Count of parts converted for "stl-g" conversions */
static int *bot_faces=NULL;	 /* array of ints (indices into vert_tree_root->the_array array) three per face */
static int bot_fsize=0;		/* current size of the bot_faces array */
static int bot_fcurr=0;		/* current bot face */
static struct vert_root *vert_tree_root;	/* binary search tree for vertices */

/* Size of blocks of faces to malloc */
#define BOT_FBLOCK	128

struct render_verts
{
	point_t pt;
	struct vertex *v;
};

struct name_conv_list
{
	char *brlcad_name;
	char *solid_name;
	char *name;
	unsigned int obj;
	int solid_use_no;
	int comb_use_no;
	struct name_conv_list *next;
} *name_root=(struct name_conv_list *)NULL;

struct ptc_plane
{
	double  e1[3], e2[3], e3[3], origin[3];
};

struct ptc_cylinder
{
	double  e1[3], e2[3], e3[3], origin[3];
	double  radius;
};

union ptc_surf
{
	struct ptc_plane plane;
	struct ptc_cylinder cylinder;
};

struct ptc_surf_list
{
	struct bu_list	l;
	int type;
	union ptc_surf	surf;
} *surf_root=(struct ptc_surf_list *)NULL;

/* for type in struct ptc_plane and struct ptc_cylinder */
#define	SURF_PLANE	1
#define	SURF_CYLINDER	2

#define	MAX_LINE_LEN	512

#define	UNKNOWN_TYPE	0
#define	ASSEMBLY_TYPE	1
#define	PART_TYPE	2
#define	CUT_SOLID_TYPE	3

char *
Build_unique_name(char *name)
{
	struct name_conv_list *ptr;
	int name_len;
	int tries=0;

	name_len = strlen( name );
	bu_vls_strcpy( &ret_name, name );
	ptr = name_root;
	while( ptr )
	{
		if( !strcmp( bu_vls_addr( &ret_name ) , ptr->brlcad_name ) ||
		    (ptr->solid_name && !strcmp( bu_vls_addr( &ret_name ) , ptr->solid_name ) ) )
		{
			/* this name already exists, build a new one */
			++tries;
			bu_vls_trunc( &ret_name, name_len );
			bu_vls_printf( &ret_name, "_%d", tries );

			ptr = name_root;
		}

		ptr = ptr->next;
	}

	return( bu_vls_addr( &ret_name ) );
}

static struct name_conv_list *
Add_new_name(char *name, unsigned int obj, int type)
{
	struct name_conv_list *ptr;

	if( debug )
		bu_log( "Add_new_name( %s, x%x, %d )\n", name, obj, type );

	if( type != ASSEMBLY_TYPE && type != PART_TYPE && type != CUT_SOLID_TYPE )
	{
		bu_exit(EXIT_FAILURE, "Bad type for name (%s) in Add_new_name\n", name );
	}


	/* Add a new name */
	ptr = (struct name_conv_list *)bu_calloc( 1, sizeof( struct name_conv_list ) , "Add_new_name: prev->next" );
	ptr->next = (struct name_conv_list *)NULL;
	ptr->brlcad_name = bu_strdup( name );
	ptr->obj = obj;
	if( do_regex && type != CUT_SOLID_TYPE )
	{
		regmatch_t pmatch;

		if( regexec( &reg_cmp, ptr->brlcad_name, 1, &pmatch, 0  ) == 0 )
		{
			/* got a match */
			strncpy( &ptr->brlcad_name[pmatch.rm_so], &ptr->brlcad_name[pmatch.rm_eo], MAX_LINE_LEN-1 );
		}
		if( debug )
			bu_log( "\tafter reg_ex, name is %s\n", ptr->brlcad_name );
	}
	else if( type == CUT_SOLID_TYPE ) {
		bu_free( (char *)ptr->brlcad_name, "brlcad_name" );
		ptr->brlcad_name = NULL;
	}
	ptr->solid_use_no = 0;
	ptr->comb_use_no = 0;

	if( type != CUT_SOLID_TYPE )
	{
		/* make sure brlcad_name is unique */
		char *tmp;

		tmp = ptr->brlcad_name;
		ptr->brlcad_name = bu_strdup( Build_unique_name( ptr->brlcad_name ) );
		bu_free( (char *)tmp, "brlcad_name" );
	}

	if( type == ASSEMBLY_TYPE )
	{
		ptr->solid_name = NULL;
		return( ptr );
	}
	else if( type == PART_TYPE )
	{
		struct bu_vls vls;

		bu_vls_init( &vls );

		bu_vls_strcpy( &vls , "s." );
		bu_vls_strcat( &vls, ptr->brlcad_name );

		ptr->solid_name = bu_vls_strgrab( &vls );
	}
	else
	{
		struct bu_vls vls;

		bu_vls_init( &vls );

		bu_vls_strcpy( &vls , "s." );
		bu_vls_strcat( &vls, ptr->brlcad_name );

		ptr->solid_name = bu_vls_strgrab( &vls );
	}

	/* make sure solid name is unique */
	ptr->solid_name = bu_strdup( Build_unique_name( ptr->solid_name ) );
	return( ptr );
}

static char *
Get_unique_name(char *name, unsigned int obj, int type)
{
	struct name_conv_list *ptr,*prev;

	if( name_root == (struct name_conv_list *)NULL )
	{
		/* start new list */
		name_root = Add_new_name( name , obj , type );
		ptr = name_root;
	}
	else
	{
		int found=0;

		prev = (struct name_conv_list *)NULL;
		ptr = name_root;
		while( ptr && !found )
		{
			if( obj == ptr->obj )
				found = 1;
			else
			{
				prev = ptr;
				ptr = ptr->next;
			}
		}

		if( !found )
		{
			prev->next = Add_new_name( name , obj , type );
			ptr = prev->next;
		}
	}

	return( ptr->brlcad_name );
}

static char *
Get_solid_name(char *name, unsigned int obj)
{
	struct name_conv_list *ptr;

	ptr = name_root;

	while( ptr && obj != ptr->obj )
		ptr = ptr->next;

	if( !ptr )
		ptr = Add_new_name( name , 0 , PART_TYPE );

	return( ptr->solid_name );
}

static void
Convert_assy(char *line)
{
	struct wmember head;
	struct wmember *wmem = NULL;
	char line1[MAX_LINE_LEN];
	char name[MAX_LINE_LEN];
	unsigned int obj;
	char memb_name[MAX_LINE_LEN];
	unsigned int memb_obj;
	char *brlcad_name = NULL;
	float mat_col[4];
	float junk;
	int start;
	int i;

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at start of Convert_assy:\n" );
		if( bu_mem_barriercheck() )
			bu_exit(EXIT_FAILURE,  "Barrier check failed!!!\n" );
	}

	BU_LIST_INIT( &head.l );

	start = (-1);
	/* skip leading blanks */
	while( isspace( line[++start] ) && line[start] != '\0' );
	if( strncmp( &line[start] , "assembly" , 8 ) && strncmp( &line[start] , "ASSEMBLY" , 8 ) )
	{
		bu_log( "PROE-G: Convert_assy called for non-assembly:\n%s\n" , line );
		return;
	}

	/* skip blanks before name */
	start += 7;
	while( isspace( line[++start] ) && line[start] != '\0' );

	/* get name */
	i = (-1);
	start--;
	while( !isspace( line[++start] ) && line[start] != '\0' && line[start] != '\n' )
		name[++i] = line[start];
	name[++i] = '\0';

	/* get object pointer */
	sscanf( &line[start] , "%x %f" , &obj, &junk );

	bu_log( "Converting Assembly: %s\n" , name );

	if( debug )
		bu_log( "Convert_assy: %s x%x\n" , name , obj );

	while( bu_fgets( line1, MAX_LINE_LEN, fd_in ) )
	{
		/* skip leading blanks */
		start = (-1);
		while( isspace( line1[++start] ) && line[start] != '\0' );

		if( !strncmp( &line1[start] , "endassembly" , 11 ) || !strncmp( &line1[start] , "ENDASSEMBLY" , 11 ) )
		{

			brlcad_name = Get_unique_name( name , obj , ASSEMBLY_TYPE );
			if( debug )
			{
				struct wmember *wp;

				bu_log( "\tmake assembly ( %s)\n" , brlcad_name );
				for( BU_LIST_FOR( wp, wmember, &head.l ) )
					bu_log( "\t%c %s\n", wp->wm_op, wp->wm_name );
			}
			else
				bu_log( "\tUsing name: %s\n", brlcad_name );

			mk_lcomb( fd_out , brlcad_name , &head , 0 ,
			(char *)NULL , (char *)NULL , (unsigned char *)NULL , 0 );
			break;
		}
		else if( !strncmp( &line1[start] , "member" , 6 ) || !strncmp( &line1[start] , "MEMBER" , 6 ) )
		{
			start += 5;
			while( isspace( line1[++start] ) && line1[start] != '\0' );
			i = (-1);
			start--;
			while( !isspace( line1[++start] ) && line1[start] != '\0' && line1[start] != '\n' )
				memb_name[++i] = line1[start];
			memb_name[++i] = '\0';


			sscanf( &line1[start] , "%x" , &memb_obj );

			brlcad_name = Get_unique_name( memb_name , memb_obj , PART_TYPE );
			if( debug )
				bu_log( "\tmember (%s)\n" , brlcad_name );
			wmem = mk_addmember( brlcad_name , &head.l , NULL, WMOP_UNION );
		}
		else if( !strncmp( &line1[start] , "matrix" , 6 ) || !strncmp( &line1[start] , "MATRIX" , 6 ) )
		{
			int i,j;
			double scale,inv_scale;

			for( j=0 ; j<4 ; j++ )
			{
				bu_fgets( line1, MAX_LINE_LEN, fd_in );
				sscanf( line1 , "%f %f %f %f" , &mat_col[0] , &mat_col[1] , &mat_col[2] , &mat_col[3] );
				for( i=0 ; i<4 ; i++ )
					wmem->wm_mat[4*i+j] = mat_col[i];
			}

			/* convert this matrix to seperate scale factor into element #15 */
/*			scale = MAGNITUDE( &wmem->wm_mat[0] ); */
			scale = pow( bn_mat_det3( wmem->wm_mat ), 1.0/3.0 );
			if( debug )
			{
				bn_mat_print( brlcad_name, wmem->wm_mat );
				bu_log( "\tscale = %g, conv_factor = %g\n", scale, conv_factor );
			}
			if( scale != 1.0 )
			{
				inv_scale = 1.0/scale;
				for( j=0 ; j<3 ; j++ )
					HSCALE( &wmem->wm_mat[j*4], &wmem->wm_mat[j*4], inv_scale )

				/* clamp rotation elements to fabs(1.0) */
				for( j=0 ; j<3 ; j++ )
				{
					for( i=0 ; i<3 ; i++ )
					{
						if( wmem->wm_mat[j*4 + i] > 1.0 )
							wmem->wm_mat[j*4 + i] = 1.0;
						else if( wmem->wm_mat[j*4 + i] < -1.0 )
							wmem->wm_mat[j*4 + i] = -1.0;
					}
				}

				if( top_level)
					wmem->wm_mat[15] *= (inv_scale/conv_factor);
				else
					wmem->wm_mat[15] *= inv_scale;
			}
			else if( top_level )
				wmem->wm_mat[15] /= conv_factor;

			if( top_level && do_reorient )
			{
				/* apply re_orient transformation here */
				if( debug )
				{
					bu_log( "Applying re-orient matrix to member %s\n", brlcad_name );
					bn_mat_print( "re-orient matrix", re_orient );
				}
				bn_mat_mul2( re_orient, wmem->wm_mat );
			}
			if( debug )
				bn_mat_print( "final matrix", wmem->wm_mat );
		}
		else
		{
			bu_log( "Unrecognized line in assembly (%s)\n%s\n" , name , line1 );
		}
	}

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at end of Convet_assy:\n" );
		if( bu_mem_barriercheck() )
			bu_exit(EXIT_FAILURE,  "Barrier check failed!!!\n" );
	}

	top_level = 0;

}

static void
do_modifiers(char *line1, int *start, struct wmember *head, char *name, fastf_t *min, fastf_t *max)
{
	struct wmember *wmem;
	int i;

	while( strncmp( &line1[*start], "endmodifiers", 12 ) && strncmp( &line1[*start], "ENDMODIFIERS", 12 ) )
	{
		if( !strncmp( &line1[*start], "plane", 5 ) || !strncmp( &line1[*start], "PLANE", 5 ) )
		{
			struct name_conv_list *ptr;
			char haf_name[MAX_LINE_LEN];
			fastf_t dist;
			fastf_t tmp_dist;
			point_t origin;
			plane_t plane;
			vect_t e1,e2;
			double u_min,u_max,v_min,v_max;
			double x,y,z;
			int orient;
			point_t arb_pt[8];
			point_t rpp_corner;

			bu_fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf %lf", &x, &y, &z );
			VSET( origin, x, y, z );
			bu_fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf %lf", &x, &y, &z );
			VSET( e1, x, y, z );
			bu_fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf %lf", &x, &y, &z );
			VSET( e2, x, y, z );
			bu_fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf %lf", &x, &y, &z );
			VSET( plane, x, y, z );
			bu_fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf", &u_min, &v_min );
			bu_fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%lf %lf", &u_max, &v_max );
			bu_fgets( line1, MAX_LINE_LEN, fd_in );
			sscanf( line1, "%d", &orient );

			plane[H] = VDOT( plane, origin );

			VJOIN2( arb_pt[0], origin, u_min, e1, v_min, e2 );
			VJOIN2( arb_pt[1], origin, u_max, e1, v_min, e2 );
			VJOIN2( arb_pt[2], origin, u_max, e1, v_max, e2 );
			VJOIN2( arb_pt[3], origin, u_min, e1, v_max, e2 );

			/* find max distance to corner of enclosing RPP */
			dist = 0.0;
			VSET( rpp_corner, min[X], min[Y], min[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, min[X], min[Y], max[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, min[X], max[Y], min[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, min[X], max[Y], max[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, max[X], min[Y], min[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, max[X], min[Y], max[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, max[X], max[Y], min[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			VSET( rpp_corner, max[X], max[Y], max[Z] );
			tmp_dist = DIST_PT_PLANE( rpp_corner, plane ) * (fastf_t)orient;
			if( tmp_dist > dist )
				dist = tmp_dist;

			for( i=0 ; i<4 ; i++ )
			{
				VJOIN1( arb_pt[i+4], arb_pt[i], dist*(fastf_t)orient, plane );
			}

			if( top_level )
			{
				for( i=0 ; i<8 ; i++ )
					VSCALE( arb_pt[i], arb_pt[i], conv_factor )
			}

			cut_count++;

			snprintf( haf_name, MAX_LINE_LEN, "cut.%d", cut_count );
			ptr = Add_new_name( haf_name, 0, CUT_SOLID_TYPE );
			if( mk_arb8( fd_out, ptr->solid_name, (fastf_t *)arb_pt ) )
				bu_log( "Failed to create ARB8 solid for Assembly cut in part %s\n", name );
			else
			{
				/* Add this cut to the region */
				wmem = mk_addmember( ptr->solid_name, &(head->l), NULL,
						WMOP_SUBTRACT );

				if( top_level && do_reorient )
				{
					/* apply re_orient transformation here */
					if( debug )
					{
						bu_log( "Applying re-orient matrix to solid %s\n", ptr->solid_name );
						bn_mat_print( "re-orient matrix", re_orient );
					}
					bn_mat_mul2( re_orient, wmem->wm_mat );
				}

			}
		}
		bu_fgets( line1, MAX_LINE_LEN, fd_in );
		(*start) = (-1);
		while( isspace( line1[++(*start)] ) );
	}
}

void
Add_face(int *face)
{
	if( !bot_faces )
	{
		bot_faces = (int *)bu_malloc( 3 * BOT_FBLOCK * sizeof( int ), "bot_faces" );
		bot_fsize = BOT_FBLOCK;
		bot_fcurr = 0;
	}
	else if( bot_fcurr >= bot_fsize )
	{
		bot_fsize += BOT_FBLOCK;
		bot_faces = (int *)bu_realloc( (void *)bot_faces, 3 * bot_fsize * sizeof( int ), "bot_faces increase" );
	}

	VMOVE( &bot_faces[3*bot_fcurr], face );
	bot_fcurr++;
}

static void
Convert_part(char *line)
{
	char line1[MAX_LINE_LEN];
	char name[MAX_LINE_LEN];
	unsigned int obj=0;
	char *solid_name;
	int start;
	int i;
	int face_count=0;
	int degenerate_count=0;
	int small_count=0;
	float colr[3]={0.5, 0.5, 0.5};
	unsigned char color[3]={ 128, 128, 128 };
	char *brlcad_name;
	struct wmember head;
	struct wmember *wmem;
	vect_t normal={0,0,0};
	int solid_in_region=0;
	point_t part_max,part_min;	/* Part RPP */

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_prmem( "At start of Conv_prt():\n" );

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at start of Convet_part:\n" );
		if( bu_mem_barriercheck() )
			bu_exit(EXIT_FAILURE,  "Barrier check failed!!!\n" );
	}


	bot_fcurr = 0;
	BU_LIST_INIT( &head.l );
	VSETALL( part_min, MAX_FASTF );
	VSETALL( part_max, -MAX_FASTF );

	clean_vert_tree( vert_tree_root );

	start = (-1);
	/* skip leading blanks */
	while( isspace( line[++start] ) && line[start] != '\0' );
	if( strncmp( &line[start] , "solid" , 5 ) && strncmp( &line[start] , "SOLID" , 5 ) )
	{
		bu_log( "Convert_part: Called for non-part\n%s\n" , line );
		return;
	}

	/* skip blanks before name */
	start += 4;
	while( isspace( line[++start] ) && line[start] != '\0' );

	if( line[start] != '\0' ) {
		/* get name */
		i = (-1);
		start--;
		while( !isspace( line[++start] ) && line[start] != '\0' && line[start] != '\n' )
			name[++i] = line[start];
		name[++i] = '\0';

		/* get object id */
		sscanf( &line[start] , "%x" , &obj );
	} else if( stl_format && forced_name ) {
		strncpy( name, forced_name, MAX_LINE_LEN-1 );
	} else if( stl_format ) {
		/* build a name from the file name */
		char tmp_str[512];
		char *ptr;
		int len, suff_len;

		obj_count++;
		obj = obj_count;

		/* copy the file name into our work space */
		strncpy( tmp_str, input_file, 512 );
		tmp_str[511] = '\0';

		/* eliminate a trailing ".stl" */
		len = strlen( tmp_str );
		if( len > 4 )
		{
			if( !strncmp( &tmp_str[len-4], ".stl", 4 ) )
				tmp_str[len-4] = '\0';
		}

		/* skip over all characters prior to the last '/' */
		ptr = strrchr( tmp_str, '/' );
		if( !ptr )
			ptr = tmp_str;
		else
			ptr++;

		/* now copy what is left to the name */
		strncpy( name, ptr, MAX_LINE_LEN-1 );
		name[MAX_LINE_LEN-1] = '\0';

		sprintf( tmp_str, "_%d", obj_count );
		len = strlen( name );
		suff_len = strlen( tmp_str );
		if( len + suff_len < MAX_LINE_LEN-1 )
		    strncat( name, tmp_str, MAX_LINE_LEN - len - 1 );
		else
		    snprintf( &name[MAX_LINE_LEN-suff_len-1], MAX_LINE_LEN, "%s", tmp_str );
		name[MAX_LINE_LEN-1] = '\0'; /* sanity */

	} else {
		strncpy( name, "noname", MAX_LINE_LEN-1 );
	}

	bu_log( "Converting Part: %s\n" , name );

	if( debug )
		bu_log( "Conv_part %s x%x\n" , name , obj );

	solid_count++;
	solid_name = Get_solid_name( name , obj );

	bu_log( "\tUsing solid name: %s\n" , solid_name );

	if( RT_G_DEBUG & DEBUG_MEM || RT_G_DEBUG & DEBUG_MEM_FULL )
		bu_prmem( "At start of Convert_part()" );

	while( bu_fgets( line1, MAX_LINE_LEN, fd_in ) != NULL )
	{
		start = (-1);
		while( isspace( line1[++start] ) );
		if( !strncmp( &line1[start] , "endsolid" , 8 ) || !strncmp( &line1[start] , "ENDSOLID" , 8 ) )
			break;
		else if( !strncmp( &line1[start] , "color" , 5 ) || !strncmp( &line1[start] , "COLOR" , 5 ) )
		{
			sscanf( &line1[start+5] , "%f%f%f" , &colr[0] , &colr[1] , &colr[2] );
			for( i=0 ; i<3 ; i++ )
				color[i] = (int)(colr[i] * 255.0);
		}
		else if( !strncmp( &line1[start] , "normal" , 6 ) || !strncmp( &line1[start] , "NORMAL" , 6 ) )
		{
			float x,y,z;

			start += 6;
			sscanf( &line1[start] , "%f%f%f" , &x , &y , &z );
			VSET( normal , x , y , z );
		}
		else if( !strncmp( &line1[start] , "facet" , 5 ) || !strncmp( &line1[start] , "FACET" , 5 ) )
		{
			VSET( normal , 0.0 , 0.0 , 0.0 );

			start += 4;
			while( line1[++start] && isspace( line1[start] ) );

			if( line1[start] )
			{
				if( !strncmp( &line1[start] , "normal" , 6 ) || !strncmp( &line1[start] , "NORMAL" , 6 ) )
				{
					float x,y,z;

					start += 6;
					sscanf( &line1[start] , "%f%f%f" , &x , &y , &z );
					VSET( normal , x , y , z );
				}
			}
		}
		else if( !strncmp( &line1[start] , "outer loop" , 10 ) || !strncmp( &line1[start] , "OUTER LOOP" , 10 ) )
		{
			int endloop=0;
			int vert_no=0;
			int tmp_face[3];

			while( !endloop )
			{
				if( bu_fgets( line1, MAX_LINE_LEN, fd_in ) == NULL )
					bu_exit(EXIT_FAILURE,  "Unexpected EOF while reading a loop in a part!!!\n" );

				start = (-1);
				while( isspace( line1[++start] ) );

				if( !strncmp( &line1[start] , "endloop" , 7 ) || !strncmp( &line1[start] , "ENDLOOP" , 7 ) )
					endloop = 1;
				else if ( !strncmp( &line1[start] , "vertex" , 6 ) || !strncmp( &line1[start] , "VERTEX" , 6 ) )
				{
					double x,y,z;

					sscanf( &line1[start+6] , "%lf%lf%lf" , &x , &y , &z );
					if( top_level )
					{
						x *= conv_factor;
						y *= conv_factor;
						z *= conv_factor;
					}

					if( vert_no > 2 )
					{
						int n;

						bu_log( "Non-triangular loop:\n" );
						for( n=0 ; n<3 ; n++ )
							bu_log( "\t( %g %g %g )\n", V3ARGS( &vert_tree_root->the_array[tmp_face[n]] ) );

						bu_log( "\t( %g %g %g )\n", x, y, z );
					}
					tmp_face[vert_no++] = Add_vert( x, y, z, vert_tree_root, tol.dist_sq );
					VMINMAX( part_min, part_max, &vert_tree_root->the_array[tmp_face[vert_no-1]*3] );
				}
				else
					bu_log( "Unrecognized line: %s\n", line1 );
			}

			/* check for degenerate faces */
			if( tmp_face[0] == tmp_face[1] )
			{
				degenerate_count++;
				continue;
			}

			if( tmp_face[0] == tmp_face[2] )
			{
				degenerate_count++;
				continue;
			}

			if( tmp_face[1] == tmp_face[2] )
			{
				degenerate_count++;
				continue;
			}

			if( debug )
			{
				int n;

				bu_log( "Making Face:\n" );
				for( n=0 ; n<3; n++ )
					bu_log( "\tvertex #%d: ( %g %g %g )\n", tmp_face[n], V3ARGS( &vert_tree_root->the_array[3*tmp_face[n]] ) );
				VPRINT(" normal", normal);
			}

			Add_face( tmp_face );
			face_count++;
		}
		else if( !strncmp( &line1[start], "modifiers", 9 ) || !strncmp( &line1[start], "MODIFIERS", 9 ) )
		{
			if( face_count )
			{
				wmem = mk_addmember( solid_name , &head.l , NULL, WMOP_UNION );
				if( top_level && do_reorient )
				{
					/* apply re_orient transformation here */
					if( debug )
					{
						bu_log( "Applying re-orient matrix to solid %s\n", solid_name );
						bn_mat_print( "re-orient matrix", re_orient );
					}
					bn_mat_mul2( re_orient, wmem->wm_mat );
				}
				solid_in_region = 1;
			}
			do_modifiers( line1, &start, &head, name, part_min, part_max );
		}
	}

	/* Check if this part has any solid parts */
	if( face_count == 0 )
	{
		char *save_name;

		bu_log( "\t%s has no solid parts, ignoring\n" , name );
		if( degenerate_count )
			bu_log( "\t%d faces were degenerate\n", degenerate_count );
		if( small_count )
			bu_log( "\t%d faces were too small\n", small_count );
		brlcad_name = Get_unique_name( name , obj , PART_TYPE );
		save_name = bu_strdup( brlcad_name );
		bu_ptbl_ins( &null_parts, (long *)save_name );
		return;
	}
	else
	{
		if( degenerate_count )
			bu_log( "\t%d faces were degenerate\n", degenerate_count );
		if( small_count )
			bu_log( "\t%d faces were too small\n", small_count );
	}

	mk_bot( fd_out, solid_name, RT_BOT_SOLID, RT_BOT_UNORIENTED, 0, vert_tree_root->curr_vert, bot_fcurr,
		vert_tree_root->the_array, bot_faces, NULL, NULL );

	if( face_count && !solid_in_region )
	{
		wmem = mk_addmember( solid_name , &head.l , NULL, WMOP_UNION );
		if( top_level && do_reorient )
		{
			/* apply re_orient transformation here */
			if( debug )
			{
				bu_log( "Applying re-orient matrix to solid %s\n", solid_name );
				bn_mat_print( "re-orient matrix", re_orient );
			}
			bn_mat_mul2( re_orient, wmem->wm_mat );
		}
	}
	brlcad_name = Get_unique_name( name , obj , PART_TYPE );

	if( do_air )
	{
		bu_log( "\tMaking air region (%s)\n" , brlcad_name );

		mk_lrcomb( fd_out, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
		color, 0, air_no, 0, 100, 0 );
		air_no++;
	}
	else
	{
		bu_log( "\tMaking region (%s)\n" , brlcad_name );

		if( const_id >= 0 )
		{
			mk_lrcomb( fd_out, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
			color, const_id, 0, mat_code, 100, 0 );
			if( stl_format && face_count )
				(void)mk_addmember( brlcad_name, &all_head.l, NULL, WMOP_UNION );
		}
		else
		{
			mk_lrcomb( fd_out, brlcad_name, &head, 1, (char *)NULL, (char *)NULL,
			color, id_no, 0, mat_code, 100, 0 );
			if( stl_format && face_count )
				(void)mk_addmember( brlcad_name, &all_head.l, NULL, WMOP_UNION );
			id_no++;
		}
	}

	if( RT_G_DEBUG & DEBUG_MEM_FULL )
	{
		bu_log( "Barrier check at end of Convert_part:\n" );
		if( bu_mem_barriercheck() )
			bu_exit(EXIT_FAILURE,  "Barrier check failed!!!\n" );
	}

	top_level = 0;

	return;
}

static void
Convert_input(void)
{
	char line[ MAX_LINE_LEN ];

	if( !stl_format )
	{
		if( !bu_fgets( line, MAX_LINE_LEN, fd_in ) )
			return;

		sscanf( line, "%f", &conv_factor );
	}

	if( !do_reorient && !stl_format )
		conv_factor = 1.0;

	while( bu_fgets( line, MAX_LINE_LEN, fd_in ) != NULL )
	{
		if( !strncmp( line , "assembly" , 8 ) || !strncmp( line , "ASSEMBLY" , 8 ) )
			Convert_assy( line );
		else if( !strncmp( line , "solid" , 5 ) || !strncmp( line , "SOLID" , 5 ) )
			Convert_part( line );
		else
			bu_log( "Unrecognized line:\n%s\n" , line );
	}
}

static void
Rm_nulls(void)
{
	struct db_i *dbip;
	int i;
	struct directory *dp;

	dbip = fd_out->dbip;

	if( debug || BU_PTBL_END( &null_parts )  )
	{
		bu_log( "Deleting references to the following null parts:\n" );
		for( i=0 ; i<BU_PTBL_END( &null_parts ) ; i++ )
		{
			char *save_name;

			save_name = (char *)BU_PTBL_GET( &null_parts, i );
			bu_log( "\t%s\n" , save_name );
		}
	}

	FOR_ALL_DIRECTORY_START(dp, dbip) {
		struct rt_tree_array	*tree_list;
		struct rt_db_internal	intern;
		struct rt_comb_internal	*comb;
		int j;
		int node_count,actual_count;
		int changed=0;

		/* skip solids */
		if( dp->d_flags & DIR_SOLID )
			continue;

		/* skip non-geometry */
		if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
			continue;

		if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) < 1 )
		{
			bu_log( "Cannot get internal form of combination %s\n", dp->d_namep );
			continue;
		}
		comb = (struct rt_comb_internal *)intern.idb_ptr;
		RT_CK_COMB( comb );
		if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			db_non_union_push( comb->tree , &rt_uniresource);
			if( db_ck_v4gift_tree( comb->tree ) < 0 )
			{
				bu_log( "Cannot flatten tree (%s) for editing\n", dp->d_namep );
				continue;
			}
		}
		node_count = db_tree_nleaves( comb->tree );
		if( node_count > 0 )
		{
			tree_list = (struct rt_tree_array *)bu_calloc( node_count,
				sizeof( struct rt_tree_array ), "tree list" );
			actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION, 0, &rt_uniresource ) - tree_list;
			BU_ASSERT_LONG( actual_count, ==, node_count );
		}
		else
		{
			tree_list = (struct rt_tree_array *)NULL;
			actual_count = 0;
		}

		for( j=0; j<actual_count; j++ )
		{
			int k;
			int found=0;

			for( k=0 ; k<BU_PTBL_END( &null_parts ) ; k++ )
			{
				char *save_name;

				save_name = (char *)BU_PTBL_GET( &null_parts, k );
				if( !strcmp( save_name, tree_list[j].tl_tree->tr_l.tl_name ) )
				{
					found = 1;
					break;
				}
			}
			if( found )
			{
				/* This is a NULL part, delete the reference */
/*				if( debug ) */
					bu_log( "Deleting reference to null part (%s) from combination %s\n",
						tree_list[j].tl_tree->tr_l.tl_name, dp->d_namep );

				db_free_tree( tree_list[j].tl_tree , &rt_uniresource);

				for( k=j+1 ; k<actual_count ; k++ )
					tree_list[k-1] = tree_list[k]; /* struct copy */

				actual_count--;
				j--;
				changed = 1;
			}
		}

		if( changed )
		{
			if( actual_count )
				comb->tree = (union tree *)db_mkgift_tree( tree_list, actual_count, &rt_uniresource );
			else
				comb->tree = (union tree *)NULL;

			if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
			{
				bu_log( "Unable to write modified combination '%s' to database\n", dp->d_namep );
				rt_comb_ifree( &intern , &rt_uniresource);
				continue;
			}
		}
		bu_free( (char *)tree_list, "tree_list" );
	} FOR_ALL_DIRECTORY_END;
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	register int c;

	tol.magic = BN_TOL_MAGIC;

	/* this value selected as a resaonable compromise between eliminating
	 * needed faces and keeping degenerate faces
	 */
	tol.dist = 0.005;	/* default, same as MGED, RT, ... */
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	vert_tree_root = create_vert_tree();

	bu_ptbl_init( &null_parts, 64, " &null_parts");
	bu_vls_init( &ret_name );

	forced_name = NULL;

	if( strstr( argv[0], "stl-g" ) )
	{
		/* this code was called as stl-g */
		stl_format = 1;
		do_reorient = 0;
		conv_factor = 1.0;	/* default */
		usage = stl_usage;
	}
	else
		usage = proe_usage;

	if( argc < 2 )
		bu_exit(1, usage, argv[0]);

	/* Get command line arguments. */
	while ((c = bu_getopt(argc, argv, "St:i:I:m:rsdax:u:N:c:")) != EOF) {
		double tmp;

		switch (c) {
		case 't':	/* tolerance */
			tmp = atof( bu_optarg );
			if( tmp <= 0.0 ) {
				bu_log( "Tolerance must be greater then zero, using default (%g)\n",
					tol.dist );
				break;
			}
			tol.dist = tmp;
			tol.dist_sq = tmp * tmp;
			break;
		case 'c':	/* convert from units */
			conv_factor = bu_units_conversion( bu_optarg );
			if( conv_factor == 0.0 )
			{
				bu_log( "Illegal units: (%s)\n", bu_optarg );
				bu_exit(EXIT_FAILURE,  "Illegal units!!\n" );
			}
			else
				bu_log( "Converting units from %s to mm (conversion factor is %g)\n", bu_optarg, conv_factor );
			break;
		case 'N':	/* force a name on this object */
			forced_name = bu_optarg;
			break;

		case 'S':	/* raw stl_format format */
			stl_format = 1;
			do_reorient = 0;
			break;
		case 'i':
			id_no = atoi( bu_optarg );
			break;
		case  'I':
			const_id = atoi( bu_optarg );
			if( const_id < 0 )
			{
				bu_log( "Illegal value for '-I' option, must be zero or greater!!!\n" );
				bu_log( usage, argv[0] );
				bu_exit(EXIT_FAILURE,  "Illegal value for option '-I'\n" );
			}
			break;
		case 'm':
			mat_code = atoi( bu_optarg );
			break;
		case 'd':
			debug = 1;
			break;
		case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
			bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
			bu_log("\n");
			break;
		case 'u':
			do_regex = 1;
			if( regcomp( &reg_cmp, bu_optarg, 0 ) )
			{
				bu_log( "Bad regular expression (%s)\n", bu_optarg );
				bu_exit( 1, usage, argv[0] );
			}
			break;
		case 'a':
			do_air = 1;
			break;
		case 'r':
			do_reorient = 0;
			break;
#if 0
		case 's':
			do_simplify = 1;
			break;
#endif
		default:
			bu_exit(1, usage, argv[0]);
			break;
		}
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	input_file = argv[bu_optind];
	if( (fd_in=fopen( input_file, "r")) == NULL )
	{
		bu_log( "Cannot open input file (%s)\n" , input_file );
		perror( argv[0] );
		bu_exit( 1, NULL );
	}
	bu_optind++;
	brlcad_file = argv[bu_optind];
	if( (fd_out=wdb_fopen( brlcad_file)) == NULL )
	{
		bu_log( "Cannot open BRL-CAD file (%s)\n" , brlcad_file );
		perror( argv[0] );
		bu_exit( 1, NULL );
	}

	if( stl_format )
		mk_id_units( fd_out , "Conversion from Stereolithography format" , "mm" );
	else
		mk_id_units( fd_out , "Conversion from Pro/Engineer" , "in" );

	/* Create re-orient matrix */
	bn_mat_angles( re_orient, 0.0, 90.0, 90.0 );

	BU_LIST_INIT( &all_head.l );

	Convert_input();

	if( stl_format )
	{
		/* make a top level group */
		mk_lcomb( fd_out, "all", &all_head, 0, (char *)NULL, (char *)NULL, (unsigned char *)NULL, 0 );
	}

	fclose( fd_in );

	/* Remove references to null parts */
	Rm_nulls();

	wdb_close( fd_out );

	return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.30
log
@be more consistent on the buffer lengths and limits (needs testing on the name generation) using MAX_LINE_LENGTH for the names too
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.29 2007/11/21 20:49:06 erikgreenwald Exp $";
d766 1
d771 1
a771 1
			strncat( name, tmp_str, MAX_LINE_LEN - len - 1 );
d773 3
a775 1
			snprintf( &name[MAX_LINE_LEN-suff_len-1], MAX_LINE_LEN, "%s", tmp_str );
@


14.29
log
@pass bu_exit a NULL instead of an empty string
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.28 2007/11/21 20:38:21 erikgreenwald Exp $";
d221 1
a221 2
		bu_log( "Bad type for name (%s) in Add_new_name\n", name );
		bu_exit(EXIT_FAILURE,  "Add_new_name\n" );
d237 1
a237 2
			/* FIXME: this is fishy.. reg_cmp is user-provided */
			strcpy( &ptr->brlcad_name[pmatch.rm_so], &ptr->brlcad_name[pmatch.rm_eo] );
d352 1
a352 1
	char name[80];
d354 1
a354 1
	char memb_name[80];
d530 1
a530 1
			char haf_name[80];
d623 1
a623 1
			sprintf( haf_name, "cut.%d", cut_count );
d675 1
a675 1
	char name[MAX_LINE_LEN + 1];
d734 1
a734 1
		strncpy( name, forced_name, MAX_LINE_LEN );
d764 2
a765 2
		strncpy( name, ptr, MAX_LINE_LEN );
		name[MAX_LINE_LEN] = '\0';
d769 1
a769 1
		if( len + suff_len < MAX_LINE_LEN )
d774 1
a774 1
		strcpy( name, "noname" );
@


14.28
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.27 2007/11/21 19:05:59 erikgreenwald Exp $";
d1285 1
a1285 1
		bu_exit( 1, "" );
d1293 1
a1293 1
		bu_exit( 1, "" );
@


14.27
log
@exit->bu_exit where applicable
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.26 2007/11/21 15:21:33 erikgreenwald Exp $";
d1195 1
a1195 4
	{
		bu_log( usage, argv[0]);
		bu_exit(1, "");
	}
d1258 1
a1258 2
				bu_log( usage, argv[0] );
				bu_exit( 1, "" );
d1273 1
a1273 2
			bu_log( usage, argv[0]);
			bu_exit(1, "");
@


14.26
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.25 2007/10/18 09:11:56 brlcad Exp $";
d1197 1
a1197 1
		exit(1);
d1262 1
a1262 1
				exit( 1 );
d1278 1
a1278 1
			exit(1);
d1290 1
a1290 1
		exit( 1 );
d1298 1
a1298 1
		exit( 1 );
@


14.25
log
@more quellings of level 4 flawfinder issues
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.24 2007/10/14 22:15:54 brlcad Exp $";
d222 1
a222 1
		bu_bomb( "Add_new_name\n" );
d368 1
a368 1
			bu_bomb( "Barrier check failed!!!\n" );
d514 1
a514 1
			bu_bomb( "Barrier check failed!!!\n" );
d701 1
a701 1
			bu_bomb( "Barrier check failed!!!\n" );
d840 1
a840 1
					bu_bomb( "Unexpected EOF while reading a loop in a part!!!\n" );
d1004 1
a1004 1
			bu_bomb( "Barrier check failed!!!\n" );
d1220 1
a1220 1
				bu_bomb( "Illegal units!!\n" );
d1242 1
a1242 1
				bu_bomb( "Illegal value for option '-I'\n" );
@


14.24
log
@more level 4 flawfinder issues.  mostly string length clampages.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.23 2007/09/15 16:23:04 brlcad Exp $";
d772 1
a772 1
			strncat( name, tmp_str, MAX_LINE_LEN - strlen(name) - 1 );
d774 1
a774 1
			snprintf( &name[MAX_LINE_LEN-suff_len-1], MAX_LINE_LEN, tmp_str );
@


14.23
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.22 2007/07/26 01:13:51 brlcad Exp $";
d238 1
d725 1
a725 2
	if( line[start] != '\0' )
	{
d735 4
a738 5
	}
	else if( stl_format && forced_name )
		strcpy( name, forced_name );
	else if( stl_format ) /* build a name from the file name */
	{
d772 1
a772 1
			strcat( name, tmp_str );
d774 3
a776 1
			sprintf( &name[MAX_LINE_LEN-suff_len-1], tmp_str );
a777 2
	else
		strcpy( name, "noname" );
@


14.22
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.21 2007/05/18 04:13:44 brlcad Exp $";
d42 1
a42 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d46 1
@


14.21
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@a30 4
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.20 2007/02/20 08:19:47 brlcad Exp $";
@


14.20
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d38 1
a38 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.19 2007/02/02 08:48:28 brlcad Exp $";
d229 1
a229 1
		rt_bomb( "Add_new_name\n" );
d374 1
a374 1
			rt_bomb( "Barrier check failed!!!\n" );
d520 1
a520 1
			rt_bomb( "Barrier check failed!!!\n" );
d707 1
a707 1
			rt_bomb( "Barrier check failed!!!\n" );
d1012 1
a1012 1
			rt_bomb( "Barrier check failed!!!\n" );
@


14.19
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d38 1
a38 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.18 2007/01/27 01:41:32 brlcad Exp $";
d407 1
a407 1
	while( fgets( line1, MAX_LINE_LEN, fd_in ) )
d457 1
a457 1
				fgets( line1, MAX_LINE_LEN, fd_in );
d550 1
a550 1
			fgets( line1, MAX_LINE_LEN, fd_in );
d553 1
a553 1
			fgets( line1, MAX_LINE_LEN, fd_in );
d556 1
a556 1
			fgets( line1, MAX_LINE_LEN, fd_in );
d559 1
a559 1
			fgets( line1, MAX_LINE_LEN, fd_in );
d562 1
a562 1
			fgets( line1, MAX_LINE_LEN, fd_in );
d564 1
a564 1
			fgets( line1, MAX_LINE_LEN, fd_in );
d566 1
a566 1
			fgets( line1, MAX_LINE_LEN, fd_in );
d654 1
a654 1
		fgets( line1, MAX_LINE_LEN, fd_in );
d800 1
a800 1
	while( fgets( line1, MAX_LINE_LEN, fd_in ) != NULL )
d847 1
a847 1
				if( fgets( line1, MAX_LINE_LEN, fd_in ) == NULL )
d1027 1
a1027 1
		if( !fgets( line, MAX_LINE_LEN, fd_in ) )
d1036 1
a1036 1
	while( fgets( line, MAX_LINE_LEN, fd_in ) != NULL )
@


14.18
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.17 2007/01/23 01:13:25 brlcad Exp $";
d65 2
a66 2
extern char *optarg;
extern int optind,opterr,optopt;
d1209 1
a1209 1
	while ((c = getopt(argc, argv, "St:i:I:m:rsdax:u:N:c:")) != EOF) {
d1214 1
a1214 1
			tmp = atof( optarg );
d1224 1
a1224 1
			conv_factor = bu_units_conversion( optarg );
d1227 1
a1227 1
				bu_log( "Illegal units: (%s)\n", optarg );
d1231 1
a1231 1
				bu_log( "Converting units from %s to mm (conversion factor is %g)\n", optarg, conv_factor );
d1234 1
a1234 1
			forced_name = optarg;
d1242 1
a1242 1
			id_no = atoi( optarg );
d1245 1
a1245 1
			const_id = atoi( optarg );
d1254 1
a1254 1
			mat_code = atoi( optarg );
d1260 1
a1260 1
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
d1266 1
a1266 1
			if( regcomp( &reg_cmp, optarg, 0 ) )
d1268 1
a1268 1
				bu_log( "Bad regular expression (%s)\n", optarg );
d1293 1
a1293 1
	input_file = argv[optind];
d1300 2
a1301 2
	optind++;
	brlcad_file = argv[optind];
@


14.17
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.16 2007/01/20 14:36:44 brlcad Exp $";
d1174 1
a1174 1
        tol.magic = BN_TOL_MAGIC;
d1179 4
a1182 4
        tol.dist = 0.005;	/* default, same as MGED, RT, ... */
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;
@


14.16
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.15 2006/08/08 05:15:23 brlcad Exp $";
@


14.15
log
@get rid of the old 'cad' path references/assumptions
@
text
@d4 1
a4 1
 * Copyright (c) 1994-2006 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.14 2006/04/06 19:30:22 brlcad Exp $";
@


14.14
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.13 2006/01/28 00:36:27 brlcad Exp $";
d104 1
a104 1
	The -x option specifies an RT debug flags (see cad/librt/debug.h).\n";
d118 1
a118 1
	The -x option specifies an RT debug flags (see cad/librt/debug.h).\n";
@


14.13
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.12 2006/01/24 05:00:26 brlcad Exp $";
d55 3
@


14.13.2.1
log
@update from HEAD
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.13 2006/01/28 00:36:27 brlcad Exp $";
a54 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
@


14.12
log
@convert iteration over the array of linked list of directory nodes to FOR_ALL_DIRECTORY_START/FOR_ALL_DIRECTORY_END instead
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.11 2006/01/18 06:46:13 brlcad Exp $";
d44 1
d48 1
a48 1
#include <string.h>
d50 1
a50 1
#include <strings.h>
@


14.11
log
@update copyright to 2006
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.10 2005/10/23 04:44:30 brlcad Exp $";
d1049 1
d1065 15
a1079 3
	for( i=0 ; i<RT_DBNHASH ; i++ )
	{
		struct directory *dp;
d1081 8
a1088 1
		for( dp=dbip->dbi_Head[i] ; dp!=DIR_NULL ; dp=dp->d_forw )
d1090 4
a1093 9
			struct rt_tree_array	*tree_list;
			struct rt_db_internal	intern;
			struct rt_comb_internal	*comb;
			int j;
			int node_count,actual_count;
			int changed=0;

			/* skip solids */
			if( dp->d_flags & DIR_SOLID )
d1095 15
d1111 4
a1114 3
			/* skip non-geometry */
			if( !(dp->d_flags & ( DIR_SOLID | DIR_COMB ) ) )
				continue;
d1116 1
a1116 1
			if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) < 1 )
d1118 4
a1121 9
				bu_log( "Cannot get internal form of combination %s\n", dp->d_namep );
				continue;
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;
			RT_CK_COMB( comb );
			if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
			{
				db_non_union_push( comb->tree , &rt_uniresource);
				if( db_ck_v4gift_tree( comb->tree ) < 0 )
d1123 2
a1124 2
					bu_log( "Cannot flatten tree (%s) for editing\n", dp->d_namep );
					continue;
d1127 1
a1127 9
			node_count = db_tree_nleaves( comb->tree );
			if( node_count > 0 )
			{
				tree_list = (struct rt_tree_array *)bu_calloc( node_count,
					sizeof( struct rt_tree_array ), "tree list" );
				actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list, comb->tree, OP_UNION, 0, &rt_uniresource ) - tree_list;
				BU_ASSERT_LONG( actual_count, ==, node_count );
			}
			else
d1129 4
a1132 3
				tree_list = (struct rt_tree_array *)NULL;
				actual_count = 0;
			}
d1134 1
d1136 2
a1137 4
			for( j=0; j<actual_count; j++ )
			{
				int k;
				int found=0;
d1139 5
a1143 3
				for( k=0 ; k<BU_PTBL_END( &null_parts ) ; k++ )
				{
					char *save_name;
d1145 6
a1150 24
					save_name = (char *)BU_PTBL_GET( &null_parts, k );
					if( !strcmp( save_name, tree_list[j].tl_tree->tr_l.tl_name ) )
					{
						found = 1;
						break;
					}
				}
				if( found )
				{
					/* This is a NULL part, delete the reference */
/*					if( debug ) */
						bu_log( "Deleting reference to null part (%s) from combination %s\n",
							tree_list[j].tl_tree->tr_l.tl_name, dp->d_namep );

					db_free_tree( tree_list[j].tl_tree , &rt_uniresource);

					for( k=j+1 ; k<actual_count ; k++ )
						tree_list[k-1] = tree_list[k]; /* struct copy */

					actual_count--;
					j--;
					changed = 1;
				}
			}
d1152 1
a1152 1
			if( changed )
d1154 3
a1156 11
				if( actual_count )
					comb->tree = (union tree *)db_mkgift_tree( tree_list, actual_count, &rt_uniresource );
				else
					comb->tree = (union tree *)NULL;

				if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 )
				{
					bu_log( "Unable to write modified combination '%s' to database\n", dp->d_namep );
					rt_comb_ifree( &intern , &rt_uniresource);
					continue;
				}
a1157 1
			bu_free( (char *)tree_list, "tree_list" );
d1159 2
a1160 1
	}
@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1994-2005 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.9 2005/07/26 04:40:53 brlcad Exp $";
@


14.9
log
@make sure to include the errno.h header before any usage of the errno global just in case so bad things don't happen (like on fedora core)
@
text
@d32 1
a32 1
 *  
d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.8 2005/04/13 01:43:19 brlcad Exp $";
d635 1
a635 1
				wmem = mk_addmember( ptr->solid_name, &(head->l), NULL, 
d648 1
a648 1
				
d846 1
a846 1
				
d1048 1
a1048 1
	int i;	
@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d39 1
a39 1
static const char RCSid[] = "$Header$";
d635 1
a635 1
				wmem = mk_addmember( ptr->solid_name, &(head->l), NULL,
d648 1
a648 1

d846 1
a846 1

d1048 1
a1048 1
	int i;
@


14.8
log
@remove specific references to ARL addresses.  instead use brlcad.org mail aliases and the new sf.net mailing lists.
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.7 2005/01/30 20:30:20 brlcad Exp $";
a43 2


d52 2
a60 1
#include <regex.h>
a63 1
extern int errno;
@


14.8.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.9 2005/07/26 04:40:53 brlcad Exp $";
d44 2
a53 2
#include <regex.h>
#include <errno.h>
d61 1
d65 1
@


14.7
log
@update copyright to 2005
@
text
@d28 1
a28 2
 * "EXPORT" menu.  The Pro/develop application may be obtained via
 * anonymous FTP from ftp.brl.mil or via email from "jra@@arl.mil"
d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/proe-g.c,v 14.6 2004/12/21 07:32:29 morrison Exp $";
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1994-2004 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/proe-g.c,v 14.5 2004/12/21 06:58:41 morrison Exp $";
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a36 2
 *  
 *
d40 1
a40 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/proe-g.c,v 14.4 2004/12/21 06:50:58 morrison Exp $";
@


14.4
log
@remove the old distribution notice section
@
text
@a38 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d42 1
a42 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/proe-g.c,v 14.3 2004/12/18 06:50:51 morrison Exp $";
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a37 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
d45 1
a45 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/proe-g.c,v 14.2 2004/12/18 02:38:10 morrison Exp $";
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file proe-g.c
d49 1
a49 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/proe-g.c,v 14.1 2004/11/16 19:42:13 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
d48 1
a48 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/proe-g.c,v 1.4 2004/09/03 23:30:56 morrison Exp $";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/proe-g.c,v 1.3 2004/08/02 23:01:47 morrison Exp $";
d1330 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/proe-g.c,v 1.2 2004/06/08 22:04:10 morrison Exp $";
d37 1
a37 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header$";
d31 1
a31 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/proe-g.c,v 11.66 2004/05/10 15:30:42 erikg Exp $";
a46 1
#include "externs.h"
@

