head	1.7;
access;
symbols
	rel-7-10-4:1.5
	STABLE:1.5.0.2
	rel-7-10-2:1.5
	rel-7-10-0:1.4
	rel-7-8-4:1.2
	rel-7-8-2:1.2
	rel-7-8-0:1.2
	trimnurbs-branch:1.2.0.2
	help:1.2
	temp_tag:1.1
	postmerge-20051223-bobWinPort:1.1
	premerge-20051223-bobWinPort:1.1
	rel-7-6-6:1.1
	rel-7-6-branch:1.1.0.2
	rel-7-6-4:1.1;
locks; strict;
comment	@ * @;


1.7
date	2007.10.22.17.42.35;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.14.22.15.54;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.18.04.13.44;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.20.14.36.47;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.18.06.46.14;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.27.03.44.49;	author brlcad;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2005.10.27.03.44.49;	author brlcad;	state dead;
branches;
next	1.1.2.2;

1.1.2.2
date	2005.11.13.17.45.00;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.7
log
@whoosh, another 10% complete on the bu_bomb to bu_exit conversion review.  also includes a slew of custom exit() calls that can use bu_exit() as well as toning down a slew of overzealous exclamation point use.  (20% complete overall)
@
text
@/*                   C H E C K _ N A M E S . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file check_names.c
 *  Authors -
 *	John R. Anderson
 *
 *  Source -
 *	SLAD/BVLD/VMB
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#include "./iges_struct.h"
#include "./iges_extern.h"
#include <ctype.h>

char *
Add_brl_name( name )
char *name;
{
	struct name_list *ptr;
	int namelen;
	int i;

	/* replace white space */
	namelen = strlen( name );
	if( namelen > NAMESIZE)
	{
		namelen = NAMESIZE;
		name[namelen] = '\0';
	}
	for( i=0 ; i<namelen ; i++ )
	{
		if( isspace( name[i] ) || name[i] == '/' )
			name[i] = '_';
	}

	/* Check if name already in list */
	ptr = name_root;
	while( ptr )
	{
		if( !strncmp( ptr->name, name, NAMESIZE ) )
			return( ptr->name );
		ptr = ptr->next;
	}

	/* add this name to the list */
	ptr = (struct name_list *)bu_malloc( sizeof( struct name_list ), "Add_brl_name: ptr" );
	strncpy( ptr->name, name, NAMESIZE );
	ptr->next = name_root;
	name_root = ptr;

	return( ptr->name );
}

char *
Make_unique_brl_name( name )
char *name;
{
	struct name_list *ptr;
	int found;
	int namelen;
	int char_ptr;
	int i,j;

	/* replace white space */
	namelen = strlen( name );
	for( i=0 ; i<namelen ; i++ )
	{
		if( isspace( name[i] ) || name[i] == '/' )
			name[i] = '_';
	}

	/* check if name is already unique */
	found = 0;
	ptr = name_root;
	while( ptr )
	{
		if( !strncmp( ptr->name, name, NAMESIZE ) )
		{
			found = 1;
			break;
		}
		ptr = ptr->next;
	}

	if( !found )
		return( Add_brl_name( name ) );

	/* name is not unique, make it unique with a single character suffix */
	if( namelen < NAMESIZE )
		char_ptr = namelen;
	else
		char_ptr = NAMESIZE - 1;

	i = 0;
	while( found && 'A'+i <= 'z' )
	{
		name[char_ptr] = 'A' + i;
		name[char_ptr+1] = '\0';
		found = 0;
		ptr = name_root;
		while( ptr )
		{
			if( !strncmp( ptr->name, name, NAMESIZE ) )
			{
				found = 1;
				break;
			}
			ptr = ptr->next;
		}
		i++;
		if( 'A'+i == '[' )
			i = 'a' - 'A';
	}

	if( !found )
		return( Add_brl_name( name ) );


	/* still not unique! Try two character suffix */
	char_ptr--;
	i = 0;
	j = 0;
	while( found && 'A'+i <= 'z' && 'A'+j <= 'z' )
	{
		name[char_ptr] = 'A'+i;
		name[char_ptr+1] = 'A'+j;
		name[char_ptr+2] = '\0';
		found = 0;
		ptr = name_root;
		while( ptr )
		{
			if( !strncmp( ptr->name, name, NAMESIZE ) )
			{
				found = 1;
				break;
			}
			ptr = ptr->next;
		}
		j++;
		if( 'A'+j == '[' )
			j = 'a' - 'A';

		if( 'A'+j > 'z' )
		{
			j = 0;
			i++;
		}

		if( 'A'+i == '[' )
			i = 'a' - 'A';
	}

	if( !found )
	{
		/* not likely */
		bu_exit(1, "Could not make name unique: (%s)\n", name );
		return( (char *)NULL );		/* make the compilers happy */
	}
	else
		return( Add_brl_name( name ) );
}


void
Skip_field()
{
	int		done=0;
	int		lencard;

	if( card[counter] == eof ) /* This is an empty field */
	{
		counter++;
		return;
	}
	else if( card[counter] == eor ) /* Up against the end of record */
		return;

	if( card[72] == 'P' )
		lencard = PARAMLEN;
	else
		lencard = CARDLEN;

	if( counter >= lencard )
		Readrec( ++currec );

	while( !done )
	{
		while( card[counter++] != eof && card[counter] != eor &&
			counter <= lencard );
		if( counter > lencard && card[counter] != eor && card[counter] != eof )
			Readrec( ++currec );
		else
			done = 1;
	}

	if( card[counter] == eor )
		counter--;
}

void
Get_name( entityno , skip )
int entityno;
int skip;
{
	int			sol_num;
	int			i,j,k;
	int			no_of_assoc=0;
	int			no_of_props=0;
	int			name_de=0;
	char			*name;

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
	}

	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );
	for( i=0 ; i<skip ; i++ )
		Skip_field();

	/* skip over the associativities */
	Readint( &no_of_assoc , "" );
	for( k=0 ; k<no_of_assoc ; k++ )
		Readint( &j , "" );

	/* get property entity DE's */
	Readint( &no_of_props , "" );
	for( k=0 ; k<no_of_props ; k++ )
	{
		j = 0;
		Readint( &j , "" );
		if( dir[(j-1)/2]->type == 406 &&
		    dir[(j-1)/2]->form == 15 )
		{
			/* this is a name */
			name_de = j;
			break;
		}
	}

	if( !name_de )
		return;

	Readrec( dir[(name_de-1)/2]->param );
	Readint( &sol_num , "" );
	if( sol_num != 406 )
	{
		/* this is not a property entity */
		bu_log( "Check_names: entity at DE %d is not a property entity\n" , name_de );
		return;
	}

	Readint( &i , "" );
	if( i != 1 )
	{
		bu_log( "Bad property entity, form 15 (name) should have only one value, not %d\n" , i );
		return;
	}

	Readname( &name , "" );
	dir[entityno]->name = Make_unique_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );

}

void
Get_drawing_name( entityno )
int entityno;
{
	int entity_type;
	int no_of_views;
	int no_of_annot;
	int no_of_assoc;
	int no_of_props;
	int i,j,k;
	int name_de=0;
	char *name;

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
	}

	Readrec( dir[entityno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 404 )
	{
		bu_log( "Get_drawing_name: entity at P%07d (type %d) is not a drawing entity\n" , dir[entityno]->param , entity_type );
		return;
	}

	Readint( &no_of_views , "" );
	for( i=0 ; i<no_of_views ; i++ )
	{
		for( j=0 ; j<3 ; j++ )
			Skip_field();
	}

	Readint( &no_of_annot , "" );
	for( i=0 ; i<no_of_annot ; i++ )
		Skip_field();
	/* skip over the associativities */
	Readint( &no_of_assoc , "" );
	for( k=0 ; k<no_of_assoc ; k++ )
		Readint( &j , "" );

	/* get property entity DE's */
	Readint( &no_of_props , "" );
	for( k=0 ; k<no_of_props ; k++ )
	{
		j = 0;
		Readint( &j , "" );
		if( dir[(j-1)/2]->type == 406 &&
		    dir[(j-1)/2]->form == 15 )
		{
			/* this is a name */
			name_de = j;
			break;
		}
	}

	if( !name_de )
		return;

	Readrec( dir[(name_de-1)/2]->param );
	Readint( &entity_type , "" );
	if( entity_type != 406 )
	{
		/* this is not a property entity */
		bu_log( "Get_drawing_name: entity at DE %d is not a property entity\n" , name_de );
		return;
	}

	Readint( &i , "" );
	if( i != 1 )
	{
		bu_log( "Bad property entity, form 15 (name) should have only one value, not %d\n" , i );
		return;
	}

	Readname( &name , "" );
	dir[entityno]->name = Make_unique_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );
}

void
Get_csg_name( entityno )
int entityno;
{
	int			sol_num;
	int			i,j,k;
	int			num;
	int			skip;
	int			no_of_assoc=0;
	int			no_of_props=0;
	int			name_de=0;
	char			*name;

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
	}

	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );
	Readint( &num , "" );
	if( sol_num == 180 )
		skip = num;
	else if( sol_num == 184 )
		skip = 2*num;
	else
	{
		bu_log( "Get_csg_name: entity (type %d), not a CSG\n" , sol_num );
		return;
	}

	for( i=0 ; i<skip ; i++ )
		Skip_field();

	/* skip over the associativities */
	Readint( &no_of_assoc , "" );
	for( k=0 ; k<no_of_assoc ; k++ )
		Readint( &j , "" );

	/* get property entity DE's */
	Readint( &no_of_props , "" );
	for( k=0 ; k<no_of_props ; k++ )
	{
		j = 0;
		Readint( &j , "" );
		if( dir[(j-1)/2]->type == 406 &&
		    dir[(j-1)/2]->form == 15 )
		{
			/* this is a name */
			name_de = j;
			break;
		}
	}

	if( !name_de )
		return;

	Readrec( dir[(name_de-1)/2]->param );
	Readint( &sol_num , "" );
	if( sol_num != 406 )
	{
		/* this is not a property entity */
		bu_log( "Check_names: entity at DE %d is not a property entity\n" , name_de );
		return;
	}

	Readint( &i , "" );
	if( i != 1 )
	{
		bu_log( "Bad property entity, form 15 (name) should have only one value, not %d\n" , i );
		return;
	}

	Readname( &name , "" );
	dir[entityno]->name = Make_unique_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );
}


void
Get_brep_name( entityno )
int entityno;
{
	int			sol_num;
	int			i,j,k;
	int			num;
	int			skip;
	int			no_of_assoc=0;
	int			no_of_props=0;
	int			name_de=0;
	char			*name;

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
	}

	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );
	if( sol_num != 186 )
	{
		bu_log( "Get_brep_name: Entity (type %d) is not a BREP\n" , sol_num );
		return;
	}
	Skip_field();
	Skip_field();
	Readint( &num , "" );
	skip = 2*num;

	for( i=0 ; i<skip ; i++ )
		Skip_field();

	/* skip over the associativities */
	Readint( &no_of_assoc , "" );
	for( k=0 ; k<no_of_assoc ; k++ )
		Readint( &j , "" );

	/* get property entity DE's */
	Readint( &no_of_props , "" );
	for( k=0 ; k<no_of_props ; k++ )
	{
		j = 0;
		Readint( &j , "" );
		if( dir[(j-1)/2]->type == 406 &&
		    dir[(j-1)/2]->form == 15 )
		{
			/* this is a name */
			name_de = j;
			break;
		}
	}

	if( !name_de )
		return;

	Readrec( dir[(name_de-1)/2]->param );
	Readint( &sol_num , "" );
	if( sol_num != 406 )
	{
		/* this is not a property entity */
		bu_log( "Check_names: entity at DE %d is not a property entity\n" , name_de );
		return;
	}

	Readint( &i , "" );
	if( i != 1 )
	{
		bu_log( "Bad property entity, form 15 (name) should have only one value, not %d\n" , i );
		return;
	}

	Readname( &name , "" );
	dir[entityno]->name = Make_unique_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );
}

void
Get_subfig_name( entityno )
int entityno;
{
	int i;
	int entity_type;
	char *name;

	if( entityno >= totentities )
		bu_exit(1, "Get_subfig_name: entityno too big!\n" );

	if( dir[entityno]->type != 308 )
	{
		bu_exit(1, "Get_subfig_name called with entity type %s, should be Subfigure Definition\n",
			iges_type( dir[entityno]->type  ) );
	}

	if( dir[entityno]->param <= pstart )
	{
		bu_exit(1, "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
	}

	Readrec( dir[entityno]->param );

	Readint( &entity_type, "" );
	if( entity_type != 308 )
	{
		bu_exit(1, "Get_subfig_name: Read entity type %s, should be Subfigure Definition\n",
			iges_type( dir[entityno]->type  ) );
	}

	Readint( &i, "" );	/* ignore depth */
	Readname( &name, "" );	/* get subfigure name */

	dir[entityno]->name = Add_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );
}

void
Check_names()
{

	int i;

	bu_log( "Looking for Name Entities...\n" );
	for( i=0 ; i < totentities ; i++ )
	{
		switch( dir[i]->type )
		{
			case 152:
				Get_name( i , 13 );
				break;
			case 150:
			case 168:
				Get_name( i , 12 );
				break;
			case 156:
				Get_name( i , 9 );
				break;
			case 154:
			case 160:
			case 162:
				Get_name( i , 8 );
				break;
			case 164:
				Get_name( i , 5 );
				break;
			case 158:
				Get_name( i , 4 );
				break;
			case 180:
			case 184:
				Get_csg_name( i );
				break;
			case 186:
				Get_brep_name( i );
				break;
			case 308:
				Get_subfig_name( i );
				break;
			case 404:
				Get_drawing_name( i );
				break;
			case 410:
				if( dir[i]->form == 0 )
					Get_name( i , 8 );
				else if( dir[i]->form == 1 )
					Get_name( i , 22 );
				break;
			case 430:
				Get_name( i , 1 );
				break;
			default:
				break;
		}
	}

	bu_log( "Assigning names to entities without names...\n" );
	for( i=0 ; i < totentities ; i++ )
	{
		char tmp_name[NAMESIZE + 1];

		if( dir[i]->name == (char *)NULL )
		{
			switch( dir[i]->type )
			{
				case 150:
					sprintf( tmp_name , "block.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 152:
					sprintf( tmp_name , "wedge.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 154:
					sprintf( tmp_name , "cyl.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 156:
					sprintf( tmp_name , "cone.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 158:
					sprintf( tmp_name , "sphere.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 160:
					sprintf( tmp_name , "torus.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 162:
					sprintf( tmp_name , "revolution.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 164:
					sprintf( tmp_name , "extrusion.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 168:
					sprintf( tmp_name , "ell.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 180:
					sprintf( tmp_name , "region.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 184:
					sprintf( tmp_name , "group.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 186:
					sprintf( tmp_name , "brep.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 404:
					sprintf( tmp_name , "drawing.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 410:
					sprintf( tmp_name , "view.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 430:
					sprintf( tmp_name , "inst.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
			}
		}
	}
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.6
log
@more level 4 flawfinder issues.  mostly string length clampages.
@
text
@d138 1
a138 1
	/* still not unique!!! Try two character suffix */
d175 1
a175 2
		bu_log( "Could not make name unique: (%s)\n", name );
		bu_bomb( "Make_unique_brl_name: failed\n" );
d539 1
a539 1
		bu_bomb( "Get_subfig_name: entityno too big!!\n" );
d543 1
a543 1
		bu_log( "Get_subfig_name called with entity type %s, should be Subfigure Definition\n",
a544 1
		bu_bomb( "Get_subfig_name: bad type\n" );
d549 1
a549 1
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
a550 1
		bu_bomb( "Get_subfig_name: Bad entity\n" );
d558 1
a558 1
		bu_log( "Get_subfig_name: Read entity type %s, should be Subfigure Definition\n",
a559 1
		bu_bomb( "Get_subfig_name: bad type\n" );
@


1.5
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d66 1
a66 1
	strcpy( ptr->name, name );
@


1.4
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d176 1
a176 1
		rt_bomb( "Make_unique_brl_name: failed\n" );
d540 1
a540 1
		rt_bomb( "Get_subfig_name: entityno too big!!\n" );
d546 1
a546 1
		rt_bomb( "Get_subfig_name: bad type\n" );
d553 1
a553 1
		rt_bomb( "Get_subfig_name: Bad entity\n" );
d563 1
a563 1
		rt_bomb( "Get_subfig_name: bad type\n" );
@


1.3
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


1.2
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2006 United States Government as represented by
@


1.1
log
@moved all the geometry converter directories from src/. to src/conv/.
@
text
@d4 1
a4 1
 * Copyright (C) 1993-2005 United States Government as represented by
@


1.1.2.1
log
@file check_names.c was added on branch rel-7-6-branch on 2005-11-13 17:45:00 +0000
@
text
@d1 715
@


1.1.2.2
log
@more merging changes from HEAD aka rel-7-6-4 to the rel-7-6-branch, adding the items that were moved and resolving rcs keyword conflicts
@
text
@a0 715
/*                   C H E C K _ N A M E S . C
 * BRL-CAD
 *
 * Copyright (C) 1993-2005 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
 * information.
 */
/** @@file check_names.c
 *  Authors -
 *	John R. Anderson
 *
 *  Source -
 *	SLAD/BVLD/VMB
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#include "./iges_struct.h"
#include "./iges_extern.h"
#include <ctype.h>

char *
Add_brl_name( name )
char *name;
{
	struct name_list *ptr;
	int namelen;
	int i;

	/* replace white space */
	namelen = strlen( name );
	if( namelen > NAMESIZE)
	{
		namelen = NAMESIZE;
		name[namelen] = '\0';
	}
	for( i=0 ; i<namelen ; i++ )
	{
		if( isspace( name[i] ) || name[i] == '/' )
			name[i] = '_';
	}

	/* Check if name already in list */
	ptr = name_root;
	while( ptr )
	{
		if( !strncmp( ptr->name, name, NAMESIZE ) )
			return( ptr->name );
		ptr = ptr->next;
	}

	/* add this name to the list */
	ptr = (struct name_list *)bu_malloc( sizeof( struct name_list ), "Add_brl_name: ptr" );
	strcpy( ptr->name, name );
	ptr->next = name_root;
	name_root = ptr;

	return( ptr->name );
}

char *
Make_unique_brl_name( name )
char *name;
{
	struct name_list *ptr;
	int found;
	int namelen;
	int char_ptr;
	int i,j;

	/* replace white space */
	namelen = strlen( name );
	for( i=0 ; i<namelen ; i++ )
	{
		if( isspace( name[i] ) || name[i] == '/' )
			name[i] = '_';
	}

	/* check if name is already unique */
	found = 0;
	ptr = name_root;
	while( ptr )
	{
		if( !strncmp( ptr->name, name, NAMESIZE ) )
		{
			found = 1;
			break;
		}
		ptr = ptr->next;
	}

	if( !found )
		return( Add_brl_name( name ) );

	/* name is not unique, make it unique with a single character suffix */
	if( namelen < NAMESIZE )
		char_ptr = namelen;
	else
		char_ptr = NAMESIZE - 1;

	i = 0;
	while( found && 'A'+i <= 'z' )
	{
		name[char_ptr] = 'A' + i;
		name[char_ptr+1] = '\0';
		found = 0;
		ptr = name_root;
		while( ptr )
		{
			if( !strncmp( ptr->name, name, NAMESIZE ) )
			{
				found = 1;
				break;
			}
			ptr = ptr->next;
		}
		i++;
		if( 'A'+i == '[' )
			i = 'a' - 'A';
	}

	if( !found )
		return( Add_brl_name( name ) );


	/* still not unique!!! Try two character suffix */
	char_ptr--;
	i = 0;
	j = 0;
	while( found && 'A'+i <= 'z' && 'A'+j <= 'z' )
	{
		name[char_ptr] = 'A'+i;
		name[char_ptr+1] = 'A'+j;
		name[char_ptr+2] = '\0';
		found = 0;
		ptr = name_root;
		while( ptr )
		{
			if( !strncmp( ptr->name, name, NAMESIZE ) )
			{
				found = 1;
				break;
			}
			ptr = ptr->next;
		}
		j++;
		if( 'A'+j == '[' )
			j = 'a' - 'A';

		if( 'A'+j > 'z' )
		{
			j = 0;
			i++;
		}

		if( 'A'+i == '[' )
			i = 'a' - 'A';
	}

	if( !found )
	{
		/* not likely */
		bu_log( "Could not make name unique: (%s)\n", name );
		rt_bomb( "Make_unique_brl_name: failed\n" );
		return( (char *)NULL );		/* make the compilers happy */
	}
	else
		return( Add_brl_name( name ) );
}


void
Skip_field()
{
	int		done=0;
	int		lencard;

	if( card[counter] == eof ) /* This is an empty field */
	{
		counter++;
		return;
	}
	else if( card[counter] == eor ) /* Up against the end of record */
		return;

	if( card[72] == 'P' )
		lencard = PARAMLEN;
	else
		lencard = CARDLEN;

	if( counter >= lencard )
		Readrec( ++currec );

	while( !done )
	{
		while( card[counter++] != eof && card[counter] != eor &&
			counter <= lencard );
		if( counter > lencard && card[counter] != eor && card[counter] != eof )
			Readrec( ++currec );
		else
			done = 1;
	}

	if( card[counter] == eor )
		counter--;
}

void
Get_name( entityno , skip )
int entityno;
int skip;
{
	int			sol_num;
	int			i,j,k;
	int			no_of_assoc=0;
	int			no_of_props=0;
	int			name_de=0;
	char			*name;

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
	}

	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );
	for( i=0 ; i<skip ; i++ )
		Skip_field();

	/* skip over the associativities */
	Readint( &no_of_assoc , "" );
	for( k=0 ; k<no_of_assoc ; k++ )
		Readint( &j , "" );

	/* get property entity DE's */
	Readint( &no_of_props , "" );
	for( k=0 ; k<no_of_props ; k++ )
	{
		j = 0;
		Readint( &j , "" );
		if( dir[(j-1)/2]->type == 406 &&
		    dir[(j-1)/2]->form == 15 )
		{
			/* this is a name */
			name_de = j;
			break;
		}
	}

	if( !name_de )
		return;

	Readrec( dir[(name_de-1)/2]->param );
	Readint( &sol_num , "" );
	if( sol_num != 406 )
	{
		/* this is not a property entity */
		bu_log( "Check_names: entity at DE %d is not a property entity\n" , name_de );
		return;
	}

	Readint( &i , "" );
	if( i != 1 )
	{
		bu_log( "Bad property entity, form 15 (name) should have only one value, not %d\n" , i );
		return;
	}

	Readname( &name , "" );
	dir[entityno]->name = Make_unique_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );

}

void
Get_drawing_name( entityno )
int entityno;
{
	int entity_type;
	int no_of_views;
	int no_of_annot;
	int no_of_assoc;
	int no_of_props;
	int i,j,k;
	int name_de=0;
	char *name;

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
	}

	Readrec( dir[entityno]->param );
	Readint( &entity_type , "" );
	if( entity_type != 404 )
	{
		bu_log( "Get_drawing_name: entity at P%07d (type %d) is not a drawing entity\n" , dir[entityno]->param , entity_type );
		return;
	}

	Readint( &no_of_views , "" );
	for( i=0 ; i<no_of_views ; i++ )
	{
		for( j=0 ; j<3 ; j++ )
			Skip_field();
	}

	Readint( &no_of_annot , "" );
	for( i=0 ; i<no_of_annot ; i++ )
		Skip_field();
	/* skip over the associativities */
	Readint( &no_of_assoc , "" );
	for( k=0 ; k<no_of_assoc ; k++ )
		Readint( &j , "" );

	/* get property entity DE's */
	Readint( &no_of_props , "" );
	for( k=0 ; k<no_of_props ; k++ )
	{
		j = 0;
		Readint( &j , "" );
		if( dir[(j-1)/2]->type == 406 &&
		    dir[(j-1)/2]->form == 15 )
		{
			/* this is a name */
			name_de = j;
			break;
		}
	}

	if( !name_de )
		return;

	Readrec( dir[(name_de-1)/2]->param );
	Readint( &entity_type , "" );
	if( entity_type != 406 )
	{
		/* this is not a property entity */
		bu_log( "Get_drawing_name: entity at DE %d is not a property entity\n" , name_de );
		return;
	}

	Readint( &i , "" );
	if( i != 1 )
	{
		bu_log( "Bad property entity, form 15 (name) should have only one value, not %d\n" , i );
		return;
	}

	Readname( &name , "" );
	dir[entityno]->name = Make_unique_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );
}

void
Get_csg_name( entityno )
int entityno;
{
	int			sol_num;
	int			i,j,k;
	int			num;
	int			skip;
	int			no_of_assoc=0;
	int			no_of_props=0;
	int			name_de=0;
	char			*name;

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
	}

	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );
	Readint( &num , "" );
	if( sol_num == 180 )
		skip = num;
	else if( sol_num == 184 )
		skip = 2*num;
	else
	{
		bu_log( "Get_csg_name: entity (type %d), not a CSG\n" , sol_num );
		return;
	}

	for( i=0 ; i<skip ; i++ )
		Skip_field();

	/* skip over the associativities */
	Readint( &no_of_assoc , "" );
	for( k=0 ; k<no_of_assoc ; k++ )
		Readint( &j , "" );

	/* get property entity DE's */
	Readint( &no_of_props , "" );
	for( k=0 ; k<no_of_props ; k++ )
	{
		j = 0;
		Readint( &j , "" );
		if( dir[(j-1)/2]->type == 406 &&
		    dir[(j-1)/2]->form == 15 )
		{
			/* this is a name */
			name_de = j;
			break;
		}
	}

	if( !name_de )
		return;

	Readrec( dir[(name_de-1)/2]->param );
	Readint( &sol_num , "" );
	if( sol_num != 406 )
	{
		/* this is not a property entity */
		bu_log( "Check_names: entity at DE %d is not a property entity\n" , name_de );
		return;
	}

	Readint( &i , "" );
	if( i != 1 )
	{
		bu_log( "Bad property entity, form 15 (name) should have only one value, not %d\n" , i );
		return;
	}

	Readname( &name , "" );
	dir[entityno]->name = Make_unique_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );
}


void
Get_brep_name( entityno )
int entityno;
{
	int			sol_num;
	int			i,j,k;
	int			num;
	int			skip;
	int			no_of_assoc=0;
	int			no_of_props=0;
	int			name_de=0;
	char			*name;

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		return;
	}

	Readrec( dir[entityno]->param );
	Readint( &sol_num , "" );
	if( sol_num != 186 )
	{
		bu_log( "Get_brep_name: Entity (type %d) is not a BREP\n" , sol_num );
		return;
	}
	Skip_field();
	Skip_field();
	Readint( &num , "" );
	skip = 2*num;

	for( i=0 ; i<skip ; i++ )
		Skip_field();

	/* skip over the associativities */
	Readint( &no_of_assoc , "" );
	for( k=0 ; k<no_of_assoc ; k++ )
		Readint( &j , "" );

	/* get property entity DE's */
	Readint( &no_of_props , "" );
	for( k=0 ; k<no_of_props ; k++ )
	{
		j = 0;
		Readint( &j , "" );
		if( dir[(j-1)/2]->type == 406 &&
		    dir[(j-1)/2]->form == 15 )
		{
			/* this is a name */
			name_de = j;
			break;
		}
	}

	if( !name_de )
		return;

	Readrec( dir[(name_de-1)/2]->param );
	Readint( &sol_num , "" );
	if( sol_num != 406 )
	{
		/* this is not a property entity */
		bu_log( "Check_names: entity at DE %d is not a property entity\n" , name_de );
		return;
	}

	Readint( &i , "" );
	if( i != 1 )
	{
		bu_log( "Bad property entity, form 15 (name) should have only one value, not %d\n" , i );
		return;
	}

	Readname( &name , "" );
	dir[entityno]->name = Make_unique_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );
}

void
Get_subfig_name( entityno )
int entityno;
{
	int i;
	int entity_type;
	char *name;

	if( entityno >= totentities )
		rt_bomb( "Get_subfig_name: entityno too big!!\n" );

	if( dir[entityno]->type != 308 )
	{
		bu_log( "Get_subfig_name called with entity type %s, should be Subfigure Definition\n",
			iges_type( dir[entityno]->type  ) );
		rt_bomb( "Get_subfig_name: bad type\n" );
	}

	if( dir[entityno]->param <= pstart )
	{
		bu_log( "Illegal parameter pointer for entity D%07d (%s)\n" ,
				dir[entityno]->direct , dir[entityno]->name );
		rt_bomb( "Get_subfig_name: Bad entity\n" );
	}

	Readrec( dir[entityno]->param );

	Readint( &entity_type, "" );
	if( entity_type != 308 )
	{
		bu_log( "Get_subfig_name: Read entity type %s, should be Subfigure Definition\n",
			iges_type( dir[entityno]->type  ) );
		rt_bomb( "Get_subfig_name: bad type\n" );
	}

	Readint( &i, "" );	/* ignore depth */
	Readname( &name, "" );	/* get subfigure name */

	dir[entityno]->name = Add_brl_name( name );
	bu_free( (char *)name, "Get_name: name" );
}

void
Check_names()
{

	int i;

	bu_log( "Looking for Name Entities...\n" );
	for( i=0 ; i < totentities ; i++ )
	{
		switch( dir[i]->type )
		{
			case 152:
				Get_name( i , 13 );
				break;
			case 150:
			case 168:
				Get_name( i , 12 );
				break;
			case 156:
				Get_name( i , 9 );
				break;
			case 154:
			case 160:
			case 162:
				Get_name( i , 8 );
				break;
			case 164:
				Get_name( i , 5 );
				break;
			case 158:
				Get_name( i , 4 );
				break;
			case 180:
			case 184:
				Get_csg_name( i );
				break;
			case 186:
				Get_brep_name( i );
				break;
			case 308:
				Get_subfig_name( i );
				break;
			case 404:
				Get_drawing_name( i );
				break;
			case 410:
				if( dir[i]->form == 0 )
					Get_name( i , 8 );
				else if( dir[i]->form == 1 )
					Get_name( i , 22 );
				break;
			case 430:
				Get_name( i , 1 );
				break;
			default:
				break;
		}
	}

	bu_log( "Assigning names to entities without names...\n" );
	for( i=0 ; i < totentities ; i++ )
	{
		char tmp_name[NAMESIZE + 1];

		if( dir[i]->name == (char *)NULL )
		{
			switch( dir[i]->type )
			{
				case 150:
					sprintf( tmp_name , "block.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 152:
					sprintf( tmp_name , "wedge.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 154:
					sprintf( tmp_name , "cyl.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 156:
					sprintf( tmp_name , "cone.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 158:
					sprintf( tmp_name , "sphere.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 160:
					sprintf( tmp_name , "torus.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 162:
					sprintf( tmp_name , "revolution.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 164:
					sprintf( tmp_name , "extrusion.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 168:
					sprintf( tmp_name , "ell.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 180:
					sprintf( tmp_name , "region.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 184:
					sprintf( tmp_name , "group.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 186:
					sprintf( tmp_name , "brep.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 404:
					sprintf( tmp_name , "drawing.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 410:
					sprintf( tmp_name , "view.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
				case 430:
					sprintf( tmp_name , "inst.%d" , i );
					dir[i]->name = Make_unique_brl_name( tmp_name );
					break;
			}
		}
	}
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


