head	1.20;
access;
symbols
	rel-7-10-4:1.11
	STABLE:1.11.0.2
	rel-7-10-2:1.11
	rel-7-10-0:1.8
	rel-7-8-4:1.5
	rel-7-8-2:1.5
	rel-7-8-0:1.5
	trimnurbs-branch:1.4.0.2
	help:1.4
	temp_tag:1.2
	postmerge-20051223-bobWinPort:1.2
	premerge-20051223-bobWinPort:1.2
	rel-7-6-6:1.2
	rel-7-6-branch:1.2.0.2
	rel-7-6-4:1.2;
locks; strict;
comment	@ * @;


1.20
date	2007.12.16.15.59.37;	author brlcad;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.21.20.38.21;	author erikgreenwald;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.21.19.05.59;	author erikgreenwald;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.21.15.32.04;	author erikgreenwald;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.21.15.21.33;	author erikgreenwald;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.28.05.41.46;	author brlcad;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.22.17.42.35;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.14.22.15.54;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.15.16.23.05;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.26.01.13.52;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.18.04.13.44;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.14.21.04.30;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.31.21.38.50;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.23.01.13.26;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.20.14.36.47;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.06.19.30.22;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.27.05.52.22;	author brlcad;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2006.01.18.06.46.14;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.29.04.20.52;	author brlcad;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.10.27.03.44.49;	author brlcad;	state Exp;
branches;
next	;

1.2.2.1
date	2005.10.29.04.20.52;	author brlcad;	state dead;
branches;
next	1.2.2.2;

1.2.2.2
date	2005.11.13.17.45.00;	author brlcad;	state Exp;
branches;
next	;

1.4.2.1
date	2006.04.07.19.26.26;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


1.20
log
@convert all bzero calls to memset
@
text
@/*                          I G E S . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file iges.c
 *
 *  Code to support the g-iges converter
 *
 *  Author -
 *	John R. Anderson
 *
 *	Yet to do:
 *
 *		Utilize the IGES Right Angle Wedge entity (may not be worth the effort):
 *			1. arb_is_raw()
 *			2. raw_to_iges()
 *			3. modify arb_to_iges to use above
 *
 *		How to handle half-space solids????
 *
 *		How to handle xforms with scale factors?????
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.19 2007/11/21 20:38:21 erikgreenwald Exp $";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"

#include "./iges.h"
#include "../../librt/debug.h"


/* define defaulted entry for directory entry array */
#define	DEFAULT	(-99999)

extern int	verbose;
static int	solids_to_nmg=0;/* Count of solids that were converted to nmg's in CSG mode */
static int	dir_seq=0;	/* IGES file directory section sequence number */
static int	param_seq=0;	/* IGES file parameter section sequence number */
static int	start_len=0;	/* Length of Start Section */
static int	global_len=0;	/* Length of Global Section */
static int	attribute_de;	/* DE of attribute definition entity */
static const char	*global_form="%-72.72s%c%07d\n"; /* format for global section */
static const char	*param_form="%-64.64s %7d%c%07d\n"; /* format for parameter section */
static const char	*att_string="BRL-CAD attribute definition:material name,material parameters,region flag,ident number,air code,material code (GIFT),los density,inheritance";
static struct bn_tol tol;	/* tolerances */
static struct rt_tess_tol ttol;	/* tolerances */
static struct db_i *dbip=NULL;
static const char	*unknown="Unknown";
static int	unknown_count=0;
static int	de_pointer_number;
extern char	**independent;
extern int	no_of_indeps;
extern int	solid_is_brep;
extern int	comb_form;
extern int	do_nurbs;
extern int	mode;

BU_EXTERN( int write_dir_entry, ( FILE *fp, int entry[] ) );
BU_EXTERN( int write_vertex_list, ( struct nmgregion *r, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_edge_list, ( struct nmgregion *r, int vert_de, struct bu_ptbl *etab, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_shell_face_loop, ( char *name, struct nmgregion *r, int dependent, int edge_de, struct bu_ptbl *etab, int vert_de, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_solid_assembly, ( char *name, int de_list[], int length, int dependent, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_planar_nurb, ( struct faceuse *fu, vect_t u_dir, vect_t v_dir, fastf_t *u_max, fastf_t *v_max, point_t base_pt, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_name_entity, ( char *name, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_att_entity, ( struct iges_properties *props, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int nmg_to_iges, ( struct rt_db_internal *ip, char *name, FILE *fp_dir, FILE *fp_param ) );

#define		NO_OF_TYPES	31
static int	type_count[NO_OF_TYPES][2]={
    { 106 , 0 },	/* Copious Data */
    { 110 , 0 },	/* Line */
    { 116 , 0 },	/* Point */
    { 123 , 0 },	/* Direction */
    { 124 , 0 },	/* Transformation Matrix */
    { 126 , 0 },	/* Rational B-spline Curve */
    { 128 , 0 },	/* Rational B-spline Surface */
    { 142 , 0 },	/* Curve on a Parametric Surface */
    { 144 , 0 },	/* Trimmed Surface */
    { 150 , 0 },	/* Block */
    { 152 , 0 },	/* Right Angle Wedge */
    { 154 , 0 },	/* Right Circular Cylinder */
    { 156 , 0 },	/* Right Circular Cone Frustum */
    { 158 , 0 },	/* Sphere */
    { 160 , 0 },	/* Torus */
    { 164 , 0 },	/* Solid of Linear Extrusion */
    { 168 , 0 },	/* Ellipsoid */
    { 180 , 0 },	/* Boolean Tree */
    { 184 , 0 },	/* Solid Assembly */
    { 186 , 0 },	/* Manifold Solid BREP Object */
    { 190 , 0 },	/* Plane Surface */
    { 314 , 0 },	/* Color */
    { 322 , 0 },	/* Attribute Table Definition */
    { 406 , 0 },	/* Property Entity */
    { 422 , 0 },	/* Attribute Table Instance */
    { 430 , 0 },	/* Solid Instance */
    { 502 , 0 },	/* Vertex List */
    { 504 , 0 },	/* Edge List */
    { 508 , 0 },	/* Loop */
    { 510 , 0 },	/* Face */
    { 514 , 0 }	/* Shell */
};

static char	*type_label[NO_OF_TYPES]={
    "CopiusDa",
    "Line",
    "Point",
    "Directin",
    "Matrix",
    "B-spline",
    "NURB",
    "TrimCurv",
    "TrimSurf",
    "Block",
    "RA Wedge",
    "RC Cylin",
    "RC Frust",
    "Sphere",
    "Torus",
    "Extruson",
    "Ellipsod",
    "BoolTree",
    "Assembly",
    "BREP Obj",
    "PlaneSur",
    "Color",
    "Att Def",
    "Property",
    "Att Inst",
    "SolInst",
    "VertList",
    "EdgeList",
    "Loop",
    "Face",
    "Shell"
};

static char	*type_name[NO_OF_TYPES]={
    "Copious Data",
    "Line",
    "Point",
    "Direction",
    "Transformation Matrix",
    "Rational B_spline Curve",
    "NURB Surface",
    "Curve on a Parametric Surface",
    "Trimmed Surface",
    "Block",
    "Right Angle Wedge",
    "Right Circular Cylinder",
    "Right Circular Cone Frustum",
    "Sphere",
    "Torus",
    "Linear Sketch Extrusion",
    "Ellipsoid",
    "Boolean Tree",
    "Assembly Primitive",
    "Manifold Boundary Representation",
    "Plane Surface",
    "Color Definition",
    "Attribute Table Definition",
    "Property Entity",
    "Attribute Table Instance",
    "Primitive Instance",
    "Vertex List",
    "Edge List",
    "Loop",
    "Face",
    "Shell"
};

static unsigned char colortab[9][4]={
    { 0 , 217 , 217 , 217 }, /* index 0 actually represents an undefined color */
    { 1 ,   0 ,   0 ,   0 },
    { 2 , 255 ,   0 ,   0 },
    { 3 ,   0 , 255 ,   0 },
    { 4 ,   0 ,   0 , 255 },
    { 5 , 255 , 255 ,   0 },
    { 6 , 255 ,   0 , 255 },
    { 7 ,   0 , 255 , 255 },
    { 8 , 255 , 255 , 255 }};


void
nmg_to_winged_edge( r )
     struct nmgregion *r;
{
    struct shell *s;

    NMG_CK_REGION( r );

    for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
	    struct faceuse *fu;

	    NMG_CK_SHELL( s );
	    for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
		    struct loopuse *lu;

		    NMG_CK_FACEUSE( fu );
		    if( fu->orientation != OT_SAME )
			continue;

		    for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
			    struct edgeuse *eu1,*eu2;

			    NMG_CK_LOOPUSE( lu );
			    if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			    for( BU_LIST_FOR( eu1 , edgeuse , &lu->down_hd ) )
				{
				    struct edgeuse *eu_new;
				    struct vertex *v1=NULL,*v2=NULL;

				    NMG_CK_EDGEUSE( eu1 );
				    if( eu1->radial_p == eu1->eumate_p )
					continue;	/* dangling edge (?warning?) */

				    if( eu1->radial_p->eumate_p->radial_p == eu1->eumate_p )
					continue;	/* winged edge */

				    /* this edge has more than two radial faces
				     * find the other face from this shell
				     */
				    eu2 = eu1->radial_p;
				    while( eu2 != eu1 && eu2 != eu1->eumate_p
					   && nmg_find_s_of_eu( eu2 ) != s )
					eu2 = eu2->eumate_p->radial_p;

				    /* unglue edge eu1 */
				    nmg_unglueedge( eu1 );

				    /* Make a new edge */
				    eu_new = nmg_me( v1 , v2 , s );

				    /* Give the endpoints the same coordinates as the originbal edge */
				    nmg_vertex_gv( eu_new->vu_p->v_p , eu1->vu_p->v_p->vg_p->coord );
				    nmg_vertex_gv( eu_new->eumate_p->vu_p->v_p , eu1->eumate_p->vu_p->v_p->vg_p->coord );

				    /* Move edgeuses to the new vertices */
				    nmg_movevu( eu1->vu_p , eu_new->vu_p->v_p );
				    nmg_movevu( eu1->eumate_p->vu_p , eu_new->eumate_p->vu_p->v_p );

				    /* kill the new edge (I only wanted it for its vertices) */
				    if( nmg_keu( eu_new ) )
					bu_exit(EXIT_FAILURE,  "nmg_to_winged_edge: Can't happen nmg_keu resulted in empty shell!\n" );

				    /* move the other edgeuse to the same edge */
				    if( eu2 == eu1 || eu2 == eu1->eumate_p )
					bu_log( "nmg_to_winged_edge: couldn't find second radial face for eu x%x in shell x%x\n" , eu1 , s );
				    else
					nmg_moveeu( eu1 , eu2 );
				}
			}
		}
	}
}

void
get_props( props , comb )
     struct iges_properties *props;
     struct rt_comb_internal *comb;
{
    char *endp;

    RT_CK_COMB( comb );

    endp = strchr( bu_vls_addr(&comb->shader), ' ' );
    memset(props->material_name, 0, 32);
    memset(props->material_params, 0, 60);
    if( endp )  {
	int	len;
	len = endp - bu_vls_addr(&comb->shader);
	if( len > 31 ) len = 31;
	strncpy( props->material_name, bu_vls_addr(&comb->shader), len );
	strncpy( props->material_params, endp+1, 59 );
    } else {
	strncpy( props->material_name, bu_vls_addr(&comb->shader), 31 );
	props->material_params[0] = '\0';
    }
    if( comb->region_flag )
	{
	    props->region_flag = 'R';
	    props->ident = comb->region_id;
	    props->air_code = comb->aircode;
	    props->material_code = comb->GIFTmater;
	    props->los_density = comb->los;
	}
    props->color_defined = ( comb->rgb_valid ? 1 : 0 );
    if( props->color_defined )
	{
	    props->color[0] = comb->rgb[0];
	    props->color[1] = comb->rgb[1];
	    props->color[2] = comb->rgb[2];
	}
    else
	{
	    props->color[0] = 0;
	    props->color[1] = 0;
	    props->color[2] = 0;
	}
    props->inherit = ( comb->inherit ? 1 : 0 );
}

int
lookup_props( props , name )
     struct iges_properties *props;
     char *name;
{
    struct directory *dp;
    struct rt_db_internal intern;
    struct rt_comb_internal *comb;
    int id;

    strncpy( props->name, name, NAMESIZE );
    props->material_name[0] = '\0';
    props->material_params[0] = '\0';
    props->region_flag = ' ';
    props->ident = 0;
    props->air_code = 0;
    props->material_code = 0;
    props->los_density = 0;
    props->color[0] = 0;
    props->color[1] = 0;
    props->color[2] = 0;

    if( name == NULL )
	return( 1 );

    dp  = db_lookup( dbip , name , 1 );
    if( dp == DIR_NULL )
	return( 1 );

    if( !(dp->d_flags & DIR_COMB) )
	return( 1 );

    id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL , &rt_uniresource);

    if( id < 0 )
	{
	    rt_db_free_internal( &intern , &rt_uniresource);
	    bu_log( "Could not get internal form of %s\n", dp->d_namep );
	    return( 1 );
	}

    if( id != ID_COMBINATION )
	{
	    rt_db_free_internal( &intern , &rt_uniresource);
	    bu_log( "Directory/Database mismatch! is %s a combination or not???\n", dp->d_namep );
	    return( 1 );
	}

    comb = (struct rt_comb_internal *)intern.idb_ptr;
    RT_CK_COMB( comb );

    get_props( props , comb );
    rt_db_free_internal( &intern , &rt_uniresource);
    return( 0 );
}


int
write_freeform(FILE *fp,	/* output file */
	       char *s,		/* the string to be output (must not contain any NL's) */
	       int de,		/* the directory entry # that this belongs to (ignored for Global section) */
	       char c)		/* 'G' for global section
				 * 'P' for parameter section
				 * 'S' for start section */
{
    int paramlen;
    int start_seq;
    int str_len;
    int line_start=0;
    int line_end=0;
    int *seq_no;
    int remaining_chars=0;
    int i;

    if( c == 'P' )
	{
	    seq_no = &param_seq;
	    paramlen = 64;
	}
    else if( c == 'G' )
	{
	    seq_no = &global_len;
	    paramlen = 72;
	}
    else if( c == 'S' )
	{
	    seq_no = &start_len;
	    paramlen = 72;
	}
    else
	    bu_exit( 1, "Bad section character passed to 'write_freeform' (%c)\n" , c );

    str_len = strlen( s );
    start_seq = (*seq_no);


    /* the start section is just one big string, so just print in pieces if necessary */
    if( c == 'S' )
	{
	    line_start = 0;
	    while( line_start < str_len )
		{
		    (*seq_no)++;
		    fprintf( fp , global_form , &s[line_start] , c , *seq_no );
		    line_start += paramlen;
		}
	    return( *seq_no - start_seq );
	}

    /* Just print any string that will fit */
    if( str_len <= paramlen )
	{
	    (*seq_no)++;
	    if( c == 'P' )
		fprintf( fp , param_form , s , de , c , *seq_no );
	    else
		fprintf( fp , global_form , s , c , *seq_no );
	    return( *seq_no - start_seq );
	}
    else /* break string into lines */
	{
	    int curr_loc=0;
	    int field_start=0;

	    while( 1 )
		{
		    line_end = line_start + paramlen - 1;
		    curr_loc = line_start;
		    if( line_end >= str_len ) /* write the last line and break */
			{
			    (*seq_no)++;
			    if( c == 'P' )
				fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
			    else
				fprintf( fp , global_form , &s[line_start] , c , *seq_no );
			    break;
			}
		    else /* find the end of this line */
			{
			    /* cannot extend numbers across lines,
			     * but character strings may. The only way
			     * to be sure is to interpret the entire string */

			    if( remaining_chars >= paramlen )
				{
				    /* just print more of the string */
				    (*seq_no)++;
				    if( c == 'P' )
					fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
				    else
					fprintf( fp , global_form , &s[line_start] , c , *seq_no );
				    remaining_chars -= paramlen;
				}
			    else
				{
				    int done=0;

				    while( !done )
					{
					    char num[81];
					    int j=0;

					    /* skip over any remainder of a string */
					    if( remaining_chars )
						{
						    curr_loc = line_start + remaining_chars;
						    remaining_chars = 0;
						}
					    field_start = curr_loc;

					    if( s[curr_loc] == ',' || s[curr_loc] == ';' )
						{
						    /* empty field */
						    curr_loc++;
						}
					    else
						{
						    while( isdigit(s[curr_loc]) )
							num[j++] = s[curr_loc++];
						    num[j] = '\0';

						    if( s[curr_loc] == 'H' )
							{
							    /* This is a string */
							    int len;

							    len = atoi( num );

							    /* skip over the 'H' */
							    curr_loc++;

							    if( curr_loc + len >= line_end )
								{
								    /* break this line in a string */
								    (*seq_no)++;
								    if( c == 'P' )
									fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
								    else
									fprintf( fp , global_form , &s[line_start] , c , *seq_no );
								    remaining_chars = curr_loc + len - line_end;
								    done = 1;
								}
							    else
								curr_loc += len + 1;
							}
						    else
							{
							    /* this is not a string and cannot be continued to next line */

							    /* find end of this field */
							    while( curr_loc < str_len && s[curr_loc] != ',' && s[curr_loc] != ';' )
								{
								    curr_loc++;
								}

							    if( s[curr_loc] == ',' || s[curr_loc] == ';' )
								curr_loc++;

							    if( curr_loc > line_end )
								{
								    /* end of line must be at start of this field */

								    line_end = field_start-1;
								    for( i=line_start ; i<=line_end ; i++ )
									fputc( s[i] , fp );

								    /* fill out line with blanks */
								    for( i=0 ; i<paramlen-(line_end-line_start+1) ; i++ )
									fputc( ' ' , fp );
								    if( c == 'P' )
									fprintf( fp , " %7d" , de );
								    /* add columns 73 through 80 */
								    (*seq_no)++;
								    fprintf( fp , "%c%07d\n" , c , *seq_no );
								    done = 1;
								}
							}
						}
					}
				}
			}
		    line_start = line_end + 1;
		}
	    return( *seq_no - start_seq );
	}
}


int
write_color_entity( color , fp_dir , fp_param )
     unsigned char color[3];
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;
    float			c[3];

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* convert colors to percents */
    for( i=0 ; i<3 ; i++ )
	c[i] = (float)color[i]/2.55;

    bu_vls_printf( &str , "314,%g,%g,%g;" , c[0] , c[1] , c[2] );

    dir_entry[1] = 314;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    dir_entry[9] = 10201;
    dir_entry[11] = 314;
    dir_entry[15] = 0;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
get_color( color , fp_dir , fp_param )
     unsigned char color[3];
     FILE *fp_dir,*fp_param;
{
    int color_de;

    for( color_de=0 ; color_de < 9 ; color_de++ )
	{
	    if( color[0] == colortab[color_de][1] &&
		color[1] == colortab[color_de][2] &&
		color[2] == colortab[color_de][3] )
		break;
	}

    if( color_de == 9 )
	color_de = (-write_color_entity( color , fp_dir , fp_param ));

    return( color_de );
}

int
write_attribute_definition( fp_dir , fp_param )
     FILE *fp_dir,*fp_param;
{
    struct bu_vls str;
    int dir_entry[21];
    int i;

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* start with parameter data */
    bu_vls_printf( &str , "322,%ldH%s,5001,9" , strlen( att_string ) , att_string );
    bu_vls_printf( &str , ",1,3,1" ); /* material name */
    bu_vls_printf( &str , ",2,3,1" ); /* material parameters */
    bu_vls_printf( &str , ",3,6,1" ); /* region flag (logical value) */
    bu_vls_printf( &str , ",4,1,1" ); /* ident number */
    bu_vls_printf( &str , ",5,1,1" ); /* air code number */
    bu_vls_printf( &str , ",6,1,1" ); /* material code number */
    bu_vls_printf( &str , ",7,1,1" ); /* los density (X100) */
    bu_vls_printf( &str , ",8,1,1" ); /* inheritance */
    bu_vls_printf( &str , ",9,6,1;" ); /* color_defined (logical value) */


    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    /* write directory entry for line entity */
    dir_entry[1] = 322;
    dir_entry[8] = 0;
    dir_entry[9] = 10201;
    dir_entry[11] = 322;
    dir_entry[15] = 0;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );

}

void
iges_init( set_tol , set_ttol , set_verbose , dbip_set )
     struct bn_tol *set_tol;
     struct rt_tess_tol *set_ttol;
     int set_verbose;
     struct db_i *dbip_set;
{
    BN_CK_TOL( set_tol );
    RT_CK_TESS_TOL( set_ttol );
    tol = (*set_tol);
    ttol = (*set_ttol);
    verbose = set_verbose;
    dbip = dbip_set;

    dir_seq = 0;
    param_seq = 0;
    start_len = 0;
    global_len = 0;
}

void
Print_stats(FILE *fp)
{
    int i;
    int total_entities=0;

    fprintf( fp , "Wrote the following numbers and type of entities:\n" );
    for( i=0 ; i<NO_OF_TYPES ; i++ )
	if( type_count[i][1] > 0 )
	    {
		total_entities += type_count[i][1];
		fprintf( fp , "\t%d - %s\n" , type_count[i][1] , type_name[i] );
	    }

    fprintf( fp , "Total of %d entities written\n" , total_entities );

    if( solids_to_nmg )
	fprintf( fp , "%d solids converted to NMG's before exporting to IGES\n" , solids_to_nmg );
}

int
write_dir_entry(FILE *fp , int entry[])
{
    int i,j,type_index;
    const char *label;

    for( type_index=0; type_index<NO_OF_TYPES ; type_index++ )
	if( type_count[type_index][0] == entry[1] )
	    break;
    if( type_index == NO_OF_TYPES )
	{
	    bu_log( "Writing directory entry for an unknown entity type (%d)\n" , entry[1] );
	    label = unknown;
	    unknown_count++;
	    entry[19] = unknown_count;
	}
    else
	{
	    label = type_label[type_index];
	    type_count[type_index][1]++;
	    entry[19] = type_count[type_index][1];
	}

    entry[10] = dir_seq + 1;
    entry[20] = dir_seq + 2;

    for( j=0 ; j<2 ; j++ )
	{

	    for( i=j*10+1 ; i<(j+1)*10 ; i++ )
		{
		    if( i == 18 )
			fprintf( fp , "%8.8s" , label );
		    else if( entry[i] == DEFAULT )
			fprintf( fp , "        " );
		    else if( i == 9 )
			fprintf( fp , "%08d" , entry[i] );
		    else
			fprintf( fp , "%8d" , entry[i] );
		}
	    fprintf( fp , "D%07d\n" , entry[(j+1)*10] );
	}

    dir_seq += 2;
    return( dir_seq - 1 );
}


void
w_start_global(
	       FILE *fp_dir,
	       FILE *fp_param,
	       const char *db_name,
	       const char *prog_name,
	       const char *output_file,
	       const char *id,
	       const char *version)
{
    struct bu_vls str;
    time_t now;
    struct tm *timep;
    struct stat db_stat;

    bu_vls_init( &str );

    /* Write Start Section */
    bu_vls_printf( &str , "This IGES file created by %s from the database %s." , prog_name , db_name );
    write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'S' );
    bu_vls_free( &str );

    /* Write Global Section */
    bu_vls_printf( &str , ",,%ldH%s" , strlen( db_name ), db_name);

    if( output_file == NULL )
	bu_vls_printf( &str , ",7Hstd_out" );
    else
	bu_vls_printf( &str , ",%ldH%s" , strlen( output_file ) , output_file );

    bu_vls_printf( &str , ",%ldH%s,%ldH%s,32,38,6,308,15,%ldH%s,1.0,2,2HMM,,1.0" ,
		   strlen( version ) , version ,
		   strlen( id ) , id,
		   strlen( db_name ) , db_name );

    (void)time( &now );
    timep = localtime( &now );
    bu_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d",
		   timep->tm_year+1900,
		   timep->tm_mon + 1,
		   timep->tm_mday,
		   timep->tm_hour,
		   timep->tm_min,
		   timep->tm_sec );

    bu_vls_printf( &str , ",%g,100000.0,7HUnknown,7HUnknown,9,0" ,
		   RT_LEN_TOL );

    if( stat( db_name , &db_stat ) )
	{
	    bu_log( "Cannot stat %s\n" , db_name );
	    perror( prog_name );
	    bu_vls_strcat( &str , ",15H00000101.000000;" );
	}
    else
	{
	    timep = localtime( &db_stat.st_mtime );
	    bu_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d;",
			   timep->tm_year+1900,
			   timep->tm_mon + 1,
			   timep->tm_mday,
			   timep->tm_hour,
			   timep->tm_min,
			   timep->tm_sec );
	}

    write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'G' );

    /* write attribute definition entity */

    if( mode != TRIMMED_SURF_MODE )
	attribute_de = write_attribute_definition( fp_dir ,  fp_param );

    bu_vls_free( &str );
}


int
nmgregion_to_iges( name , r , dependent , fp_dir , fp_param )
     char *name;
     struct nmgregion *r;
     int dependent;
     FILE *fp_dir,*fp_param;
{
    struct nmgregion	*new_r;		/* temporary nmgregion */
    struct shell		*s_new;		/* shell made by nmg_mrsv */
    struct bu_ptbl		vtab;		/* vertex table */
    struct bu_ptbl		etab;		/* edge table */
    struct bu_ptbl		**shells;	/* array of tables of shells */
    int			*brep_de;	/* Directory entry sequence # for BREP Object(s) */
    int			vert_de;	/* Directory entry sequence # for vertex list */
    int			edge_de;	/* Directory entry sequence # for edge list */
    int			outer_shell_count; /* number of outer shells in nmgregion */
    int			face_count=0;	/* number of faces in nmgregion */
    int			i;

    NMG_CK_REGION( r );

    {
	struct shell *s;
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	    {
		struct faceuse *fu;

		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		    {
			struct loopuse *lu;

			if( fu->orientation != OT_SAME )
			    continue;

			face_count++;

			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			    {
				struct edgeuse *eu;

				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				    continue;

				for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
				    {
					struct vertex *v;

					v = eu->vu_p->v_p;
					NMG_CK_VERTEX( v );
					if( !v->vg_p )
					    bu_log( "vertex with no geometry!\n" );
				    }
			    }
		    }
	    }
    }

    if( face_count == 0 )
	return( 0 );

    /* Find outer shells and void shells and their associations */
    outer_shell_count = nmg_find_outer_and_void_shells( r , &shells , &tol );

    brep_de = (int *)bu_calloc( outer_shell_count , sizeof( int ) , "nmgregion_to_iges: brep_de" );

    for( i=0 ; i<outer_shell_count ; i++ )
	{
	    int j;
	    int tmp_dependent;
	    struct shell *s;
	    char *tmp_name;

	    if( outer_shell_count == 1 )
		{
		    new_r = r;
		    s_new = NULL;
		    tmp_name = name;
		    tmp_dependent = dependent;
		}
	    else
		{
		    new_r = nmg_mrsv( r->m_p );
		    s_new = BU_LIST_FIRST( shell , &new_r->s_hd );
		    tmp_name = NULL;
		    tmp_dependent = 1;

		    for( j=BU_PTBL_END( shells[i] )-1 ; j >= 0  ; j-- )
			{
			    s = (struct shell *)BU_PTBL_GET( shells[i] , j );
			    nmg_mv_shell_to_region( s , new_r );
			}
		    (void)nmg_ks( s_new );
		}


	    /* Make the vertex list entity */
	    vert_de = write_vertex_list( new_r , &vtab , fp_dir , fp_param );

	    /* Make the edge list entity */
	    edge_de = write_edge_list( new_r , vert_de , &etab , &vtab , fp_dir , fp_param );

	    /* Make the face, loop, shell entities */
	    brep_de[i] = write_shell_face_loop( tmp_name , new_r , tmp_dependent , edge_de , &etab , vert_de , &vtab , fp_dir , fp_param );

	    /* Clear the tables */
	    (void)bu_ptbl_reset( &vtab );
	    (void)bu_ptbl_reset( &etab );

	    if( outer_shell_count != 1 )
		(void)nmg_kr( new_r );
	}

    /* Free the tables */
    (void)bu_ptbl_free( &vtab );
    (void)bu_ptbl_free( &etab );

    if( outer_shell_count != 1 )
	return( write_solid_assembly( name, brep_de , outer_shell_count , dependent , fp_dir , fp_param ) );
    else
	return( brep_de[0] );
}

int
verts_to_copious_data( pts , vert_count , pt_size , fp_dir , fp_param )
     point_t *pts;
     int vert_count;
     int pt_size;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;

    if( vert_count < 2 )
	return( 0 );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    bu_vls_printf( &str , "106,%d,%d" , pt_size-1 , vert_count+1 );
    if( pt_size == 2 )
	{
	    bu_vls_printf( &str , ",0.0" );
	    for( i=0 ; i<vert_count ; i++ )
		bu_vls_printf( &str , ",%f,%f" , pts[i][0] , pts[i][1] );
	    bu_vls_printf( &str , ",%f,%f" , pts[0][0] , pts[0][1] );
	}
    else if( pt_size == 3 )
	{
	    for( i=0 ; i<vert_count ; i++ )
		bu_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[i] ) );
	    bu_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[0] ) );
	}

    bu_vls_strcat( &str , ";" );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

    /* write directory entry for vertex list entity */
    dir_entry[1] = 106;
    dir_entry[8] = 0;
    if( pt_size == 2 )
	{
	    dir_entry[9] = 10500;
	    dir_entry[15] = 63;
	}
    else
	{
	    dir_entry[9] = 10000;
	    dir_entry[15] = 12;
	}
    dir_entry[11] = 106;


    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ));
}

int
nmg_loop_to_tcurve( lu , surf_de , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param )
     struct loopuse *lu;
     int surf_de;
     vect_t u_dir,v_dir;
     fastf_t u_max,v_max;
     point_t base_pt;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    struct edgeuse		*eu;
    int			vert_count=0;
    point_t			*model_pts;
    point_t			*param_pts;
    int			i;

    NMG_CK_LOOPUSE( lu );

    if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
	return( 0 );

    /* count vertices */
    for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	vert_count++;

    if( vert_count < 3 )
	return( 0 );

    /* Allocate memory for points */
    model_pts = (point_t *)bu_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: model_pts" );
    param_pts = (point_t *)bu_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: param_pts" );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    bu_vls_printf( &str , "142,0,%d" , surf_de );

    i = 0;
    for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	{
	    struct vertex_g *vg;
	    vect_t from_base;
	    fastf_t u,v;

	    NMG_CK_EDGEUSE( eu );
	    NMG_CK_VERTEXUSE( eu->vu_p );
	    NMG_CK_VERTEX( eu->vu_p->v_p );
	    NMG_CK_VERTEX_G( eu->vu_p->v_p->vg_p );
	    vg = eu->vu_p->v_p->vg_p;

	    if( i >= vert_count )
		bu_exit(1, "nmg_loop_to_tcurve: too many vertices in loop!\n" );

	    VMOVE( model_pts[i] , vg->coord );

	    VSUB2( from_base , vg->coord , base_pt );
	    u = VDOT( u_dir , from_base )/u_max;
	    v = VDOT( v_dir , from_base )/v_max;
	    if( u < 0.0 )
		u = 0.0;
	    if( u > 1.0 )
		u = 1.0;
	    if( v < 0.0 )
		v = 0.0;
	    if( v > 1.0 )
		v = 1.0;
	    VSET( param_pts[i] , u , v , 0.0 );

	    i++;
	}

    bu_vls_printf( &str , ",%d" , verts_to_copious_data( param_pts , vert_count , 2 , fp_dir , fp_param ) );
    bu_vls_printf( &str , ",%d,0;" , verts_to_copious_data( model_pts , vert_count , 3 , fp_dir , fp_param ));

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

    /* write directory entry for vertex list entity */
    dir_entry[1] = 142;
    dir_entry[8] = 0;
    dir_entry[9] = 10500;
    dir_entry[11] = 142;
    dir_entry[15] = 0;


    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ));
}

void
nmg_fu_to_tsurf( fu , fp_dir , fp_param )
     struct faceuse *fu;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    struct loopuse		*lu;
    int			surf_de;
    vect_t			u_dir,v_dir;
    fastf_t			u_max,v_max;
    point_t			base_pt;
    int			loop_count=0;
    int			*curve_de;
    int			i;

    NMG_CK_FACEUSE( fu );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* count loops */
    for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
	    NMG_CK_LOOPUSE( lu );

	    if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		continue;

	    loop_count++;
	}

    if( loop_count < 1 )	/* nothing to output */
	return;

    /* write underlying surface */
    surf_de = write_planar_nurb( fu , u_dir , v_dir , &u_max , &v_max , base_pt , fp_dir , fp_param );

    /* allocate space to hold DE for each trimming curve */
    curve_de = (int *)bu_calloc( loop_count , sizeof( int ) , "nmg_fu_to_tsurf: curve_de" );

    i = (-1);
    for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
	    if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		continue;

	    curve_de[++i] = nmg_loop_to_tcurve( lu , surf_de , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param );
	}

    bu_vls_printf( &str , "144,%d,0,%d" , surf_de , loop_count-1 );
    for( i=0 ; i<loop_count ; i++ )
	bu_vls_printf( &str , ",%d" , curve_de[i] );
    bu_vls_strcat( &str , ";" );

    bu_free( (char *)curve_de , "nmg_fu_to_tsurf: curve_de" );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

    /* write directory entry for vertex list entity */
    dir_entry[1] = 144;
    dir_entry[8] = 0;
    dir_entry[9] = 0;
    dir_entry[11] = 144;
    dir_entry[15] = 0;

    bu_vls_free( &str );

    (void)write_dir_entry( fp_dir , dir_entry );

}

int nmgregion_to_tsurf( name , r , fp_dir , fp_param )
     char *name;
     struct nmgregion *r;
     FILE *fp_dir,*fp_param;
{
    struct shell *s;

    NMG_CK_REGION( r );

    for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
	    struct faceuse *fu;

	    NMG_CK_SHELL( s );
	    for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
		    NMG_CK_FACEUSE( fu );

		    if( fu->orientation != OT_SAME )
			continue;

		    nmg_fu_to_tsurf( fu , fp_dir , fp_param );
		}
	}

    return( -1 );
}

int
write_vertex_list( r , vtab , fp_dir , fp_param )
     struct nmgregion *r;
     struct bu_ptbl *vtab;   /* vertex table */
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;

    NMG_CK_REGION( r );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* Built list of vertex structs */
    nmg_vertex_tabulate( vtab, &r->l.magic );

    /* write parameter data for vertex list entity */
    bu_vls_printf( &str , "502,%d" , BU_PTBL_END( vtab  ) );

    for( i=0 ; i<BU_PTBL_END( vtab ) ; i++ ) {
	struct vertex                   *v;
	register struct vertex_g        *vg;

	v = (struct vertex *)BU_PTBL_GET(vtab,i);
	NMG_CK_VERTEX(v);
	vg = v->vg_p;
	if( !vg )
	    bu_log( "No geometry for vertex x%x #%d in table\n" , v , i );
	NMG_CK_VERTEX_G(vg);
	bu_vls_printf( &str, ",%g,%g,%g",
		       vg->coord[X],
		       vg->coord[Y],
		       vg->coord[Z] );
    }
    bu_vls_strcat( &str , ";" );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

    /* write directory entry for vertex list entity */
    dir_entry[1] = 502;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 502;
    dir_entry[15] = 1;


    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ));
}

int
write_line_entity( start_vg , end_vg , fp_dir , fp_param )
     struct vertex_g	*start_vg;
     struct vertex_g	*end_vg;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls str;
    int dir_entry[21];
    int i;

    NMG_CK_VERTEX_G( start_vg );
    NMG_CK_VERTEX_G( end_vg );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* start with parameter data */
    bu_vls_printf( &str , "110,%g,%g,%g,%g,%g,%g;" ,
		   start_vg->coord[X],
		   start_vg->coord[Y],
		   start_vg->coord[Z],
		   end_vg->coord[X],
		   end_vg->coord[Y],
		   end_vg->coord[Z] );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    /* write directory entry for line entity */
    dir_entry[1] = 110;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 110;
    dir_entry[15] = 0;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_linear_bspline( start_vg , end_vg , fp_dir , fp_param )
     struct vertex_g	*start_vg;
     struct vertex_g	*end_vg;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls str;
    int dir_entry[21];
    int i;

    NMG_CK_VERTEX_G( start_vg );
    NMG_CK_VERTEX_G( end_vg );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* start with parameter data */
    bu_vls_printf( &str , "126,1,1,0,0,1,0,0.,0.,1.,1.,1.,1.,%g,%g,%g,%g,%g,%g,0.,1.;" ,
		   start_vg->coord[X],
		   start_vg->coord[Y],
		   start_vg->coord[Z],
		   end_vg->coord[X],
		   end_vg->coord[Y],
		   end_vg->coord[Z] );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    /* write directory entry for line entity */
    dir_entry[1] = 126;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 126;
    dir_entry[15] = 1;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_edge_list( r , vert_de , etab , vtab , fp_dir , fp_param )
     struct nmgregion *r;
     int vert_de;		/* DE# for vertex list */
     struct bu_ptbl *etab;	/* edge table */
     struct bu_ptbl *vtab;	/* vertex table (already filled in) */
     FILE *fp_dir,*fp_param;
{
    struct bu_vls str;
    int dir_entry[21];
    int i;

    NMG_CK_REGION( r );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* Build list of edge structures */
    nmg_edge_tabulate( etab , &r->l.magic );

    bu_vls_printf( &str , "504,%d" , BU_PTBL_END( etab ) );

    /* write parameter data for edge list entity */
    for( i=0 ; i<BU_PTBL_END( etab ) ; i++ )
	{
	    struct edge			*e;
	    struct edgeuse			*eu;
	    struct vertexuse		*vu;
	    struct vertex			*start_v,*end_v;
	    struct vertex_g			*start_vg,*end_vg;
	    int				line_de; /* directory entry # for line entity */

	    e = (struct edge *)BU_PTBL_GET(etab,i);
	    NMG_CK_EDGE(e);
	    eu = e->eu_p;
	    NMG_CK_EDGEUSE(eu);
	    vu = eu->vu_p;
	    NMG_CK_VERTEXUSE(vu);
	    start_v = vu->v_p;
	    NMG_CK_VERTEX(start_v);
	    start_vg = start_v->vg_p;
	    NMG_CK_VERTEX_G(start_vg);
	    vu = eu->eumate_p->vu_p;
	    NMG_CK_VERTEXUSE(vu);
	    end_v = vu->v_p;
	    NMG_CK_VERTEX(end_v);
	    end_vg = end_v->vg_p;
	    NMG_CK_VERTEX_G(end_vg);
	    if( do_nurbs )
		line_de = write_linear_bspline( start_vg , end_vg , fp_dir , fp_param );
	    else
		line_de = write_line_entity( start_vg , end_vg , fp_dir , fp_param );
	    bu_vls_printf( &str , ",%d,%d,%d,%d,%d",
			   line_de,
			   vert_de , bu_ptbl_locate( vtab , (long *)start_v ) + 1,
			   vert_de , bu_ptbl_locate( vtab , (long *)end_v ) + 1 );
	}
    bu_vls_strcat( &str , ";" );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    /* write directory entry for edge list entity */
    dir_entry[1] = 504;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 504;
    dir_entry[15] = 1;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_point_entity( pt , fp_dir , fp_param )
     point_t pt;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;

    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    bu_vls_init( &str );

    bu_vls_printf( &str , "116,%g,%g,%g,0;" ,
		   pt[X],
		   pt[Y],
		   pt[Z] );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    dir_entry[1] = 116;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 116;
    dir_entry[15] = 0;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_direction_entity( pt , fp_dir , fp_param )
     point_t pt;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;

    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    bu_vls_init( &str );

    bu_vls_printf( &str , "123,%g,%g,%g;" ,
		   pt[X],
		   pt[Y],
		   pt[Z] );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    dir_entry[1] = 123;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 123;
    dir_entry[15] = 0;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_plane_entity( plane , fp_dir , fp_param )
     plane_t plane;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls	str;
    point_t		pt_on_plane;	/* a point on the plane */
    int		dir_entry[21];
    int		i;

    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    bu_vls_init( &str );

    VSCALE( pt_on_plane , plane , plane[3] );

    bu_vls_printf( &str , "190,%d,%d;" ,
		   write_point_entity( pt_on_plane , fp_dir , fp_param ),
		   write_direction_entity( plane , fp_dir , fp_param ) );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    dir_entry[1] = 190;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 190;
    dir_entry[15] = 0;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );

}

int
write_planar_nurb( fu , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param )
     struct faceuse *fu;
     vect_t u_dir,v_dir;	/* output */
     fastf_t *u_max,*v_max;	/* output */
     point_t base_pt;	/* output ( point at u,v==0 ) */
     FILE *fp_dir;
     FILE *fp_param;
{
    struct loopuse		*lu;
    struct edgeuse		*eu,*eu_next;
    struct vertex_g		*vg,*vg_next;
    point_t			ctl_pt;
    fastf_t			umin,umax,vmin,vmax;
    struct bu_vls   	str;
    int           	 	dir_entry[21];
    int             	i;

    NMG_CK_FACEUSE( fu );

    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    bu_vls_init( &str );

    /* create direction vectors in u and v directions in plane */
    lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
    NMG_CK_LOOPUSE( lu );
    while( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC &&
	   BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
	{
	    lu = BU_LIST_PNEXT( loopuse , lu );
	    NMG_CK_LOOPUSE( lu );
	}
    if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
	{
	    bu_log( "Write_planar_nurb: could not find a loop (with edges) in face\n" );
	    return( 0 );
	}

    eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
    NMG_CK_EDGEUSE( eu );
    vg = eu->vu_p->v_p->vg_p;
    NMG_CK_VERTEX_G( vg );
    eu_next = BU_LIST_PNEXT( edgeuse , eu );
    NMG_CK_EDGEUSE( eu_next );
    vg_next = eu_next->vu_p->v_p->vg_p;
    NMG_CK_VERTEX_G( vg_next );

    VSUB2( u_dir , vg_next->coord , vg->coord );
    VUNITIZE( u_dir );
    VCROSS( v_dir , fu->f_p->g.plane_p->N , u_dir );
    VUNITIZE( v_dir );

    /* find the max and min distances from vg along u_dir and v_dir in the face */
    umin = MAX_FASTF;
    vmin = MAX_FASTF;
    umax = (-umin);
    vmax = (-vmin);

    for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
	    NMG_CK_LOOPUSE( lu );
	    if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		continue;

	    for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
		    vect_t	tmp_vect;
		    fastf_t	distu,distv;

		    NMG_CK_EDGEUSE( eu );

		    VSUB2( tmp_vect , eu->vu_p->v_p->vg_p->coord , vg->coord );
		    distu = VDOT( tmp_vect , u_dir );
		    V_MIN( umin , distu );
		    V_MAX( umax , distu );
		    distv = VDOT( tmp_vect , v_dir );
		    V_MIN( vmin , distv );
		    V_MAX( vmax , distv );
		}
	}

    *u_max = umax - umin;
    *v_max = vmax - vmin;

    /* Put preliminary stuff for planar nurb in string */
    bu_vls_printf( &str , "128,1,1,1,1,0,0,1,0,0,0.,0.,1.,1.,0.,0.,1.,1.,1.,1.,1.,1." );

    /* Now put control points in string */
    VJOIN2( ctl_pt , vg->coord , umin , u_dir , vmin , v_dir );
    VMOVE( base_pt , ctl_pt );
    bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
    VJOIN1( ctl_pt , ctl_pt , umax-umin , u_dir );
    bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
    VJOIN2( ctl_pt , vg->coord , umin , u_dir , vmax , v_dir );
    bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
    VJOIN1( ctl_pt , ctl_pt , umax-umin , u_dir );
    bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );

    /* Now put parameter ranges last */
    bu_vls_printf( &str , ",0.,1.,0.,1.;" );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    dir_entry[1] = 128;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 128;
    dir_entry[15] = 1;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );

}

int
write_shell_face_loop( name , r , dependent , edge_de , etab , vert_de , vtab , fp_dir , fp_param )
     char *name;
     struct nmgregion *r;
     int dependent;
     int edge_de;		/* directory entry # for edge list */
     struct bu_ptbl *etab;	/* Table of edge pointers */
     int vert_de;		/* directory entry # for vertex list */
     struct bu_ptbl *vtab;	/* Table of vertex pointers */
     FILE *fp_dir,*fp_param;
{
    struct edgeuse		*eu;
    struct faceuse		*fu;
    struct loopuse		*lu;
    struct shell		*s;
    struct vertex		*v;
    struct bu_vls		str;
    struct iges_properties	props;
    int			*shell_list;
    int			i;
    int			shell_count=0;
    int			dir_entry[21];
    int			name_de;
    int			prop_de;
    int			color_de=DEFAULT;

    NMG_CK_REGION( r );

    bu_vls_init( &str );

    /* count the shells */
    for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	shell_count++;

    /* make space for the list of shell DE's */
    shell_list = (int *)bu_calloc( shell_count , sizeof( int ) , "write_shell_face_loop: shell_list" );

    shell_count = 0;
    for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
	    int	*face_list;
	    int	face_count=0;


	    /* Count faces */
	    for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
		{
		    NMG_CK_FACEUSE(fu);
		    if (fu->orientation != OT_SAME)
			continue;
		    face_count++;
		}
	    face_list = (int *)bu_calloc( face_count , sizeof( int ) , "face_list" );
	    face_count = 0;

	    /* Shell is made of faces. */
	    for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
		{
		    int	*loop_list;
		    int	loop_count=0;
		    int	exterior_loop=(-1);	/* index of outer loop (in loop_list) */
		    int	outer_loop_flag=1;	/* IGES flag to indicate a selected outer loop */

		    if (fu->orientation != OT_SAME)
			continue;

		    /* Count loops */
		    for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
			{
			    NMG_CK_LOOPUSE(lu);
			    if( lu->orientation == OT_SAME )
				exterior_loop = loop_count;
			    loop_count++;
			}
		    loop_list = (int *)bu_calloc( loop_count , sizeof( int ) , "loop_list" );

		    loop_count = 0;
		    for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
			{
			    int		edge_count=0;

			    /* Count edges */
			    if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
				{
				    for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
					{
					    NMG_CK_EDGEUSE(eu);
					    NMG_CK_EDGE(eu->e_p);
					    NMG_CK_VERTEXUSE(eu->vu_p);
					    NMG_CK_VERTEX(eu->vu_p->v_p);
					    NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
					    edge_count++;
					}
				}
			    else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
				{
				    v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
				    NMG_CK_VERTEX(v);
				    NMG_CK_VERTEX_G(v->vg_p);
				    edge_count++;
				}
			    else
				bu_log("write_shell_face_loop: loopuse mess up! (1)\n");

			    bu_vls_printf( &str , "508,%d" , edge_count );

			    if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
				{
				    for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
					{
					    int orientation;
					    struct edge *e;
					    struct edgeuse *eu_tab;

					    e = eu->e_p;
					    eu_tab = e->eu_p;
					    if( eu_tab->vu_p->v_p == eu->vu_p->v_p )
						orientation = 1;
					    else
						orientation = 0;

					    bu_vls_printf( &str , ",0,%d,%d,%d,0",
							   edge_de ,
							   bu_ptbl_locate( etab , (long *)(e)) + 1,
							   orientation );

					    edge_count++;
					}
				}
			    else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
				{
				    v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
				    bu_vls_printf( &str , ",1,%d,%d,1,0",
						   vert_de,
						   bu_ptbl_locate( vtab , (long *)v )+1 );
				} else
				    bu_log("write_shell_face_loop: loopuse mess up! (2)\n");

			    bu_vls_strcat( &str , ";" );

			    /* write loop entry */
			    /* initialize directory entry */
			    for( i=0 ; i<21 ; i++ )
				dir_entry[i] = DEFAULT;

			    /* remember where parameter data is going */
			    dir_entry[2] = param_seq + 1;

			    /* get parameter line count */
			    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

			    /* write directory entry for loop entity */
			    dir_entry[1] = 508;
			    dir_entry[8] = 0;
			    dir_entry[9] = 10001;
			    dir_entry[11] = 508;
			    dir_entry[15] = 1;
			    loop_list[loop_count++] = write_dir_entry( fp_dir , dir_entry );

			    bu_vls_free( &str );

			}

		    if( exterior_loop < 0 )
			{
			    bu_log( "No outside loop found for face\n" );
			    outer_loop_flag = 0;
			}
		    else if( exterior_loop != 0 ) /* move outside loop to start of list */
			{
			    int tmp;

			    tmp = loop_list[0];
			    loop_list[0] = loop_list[exterior_loop];
			    loop_list[exterior_loop] = tmp;
			}

		    if( do_nurbs )
			{
			    vect_t u_dir,v_dir;
			    point_t base_pt;
			    fastf_t u_max,v_max;

			    bu_vls_printf( &str , "510,%d,%d,%d" ,
					   write_planar_nurb( fu , u_dir , v_dir , &u_max , &v_max , base_pt , fp_dir , fp_param ),
					   loop_count,
					   outer_loop_flag );
			}
		    else
			bu_vls_printf( &str , "510,%d,%d,%d" ,
				       write_plane_entity( fu->f_p->g.plane_p->N , fp_dir , fp_param ),
				       loop_count,
				       outer_loop_flag );

		    for( i=0 ; i<loop_count ; i++ )
			bu_vls_printf( &str , ",%d" , loop_list[i] );

		    bu_vls_strcat( &str , ";" );

		    for( i=0 ; i<21 ; i++ )
			dir_entry[i] = DEFAULT;

		    dir_entry[1] = 510;
		    dir_entry[2] = param_seq + 1;
		    dir_entry[8] = 0;
		    dir_entry[9] = 10001;
		    dir_entry[11] = 510;
		    dir_entry[15] = 1;
		    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

		    face_list[face_count++] = write_dir_entry( fp_dir , dir_entry );;

		    bu_free( (char *)loop_list , "loop list" );
		    bu_vls_free( &str );
		}

	    /* write shell entity */
	    bu_vls_printf( &str , "514,%d" , face_count );
	    for( i=0 ; i<face_count ; i++ )
		bu_vls_printf( &str , ",%d,1" , face_list[i] );
	    bu_vls_strcat( &str , ";" );

	    /* initialize directory entry */
	    for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	    dir_entry[1] = 514;
	    dir_entry[2] = param_seq + 1;
	    dir_entry[8] = 0;
	    dir_entry[9] = 10001;
	    dir_entry[11] = 514;
	    dir_entry[15] = 1;
	    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	    shell_list[shell_count++] = write_dir_entry( fp_dir , dir_entry );

	    bu_free( (char *)face_list , "face list" );
	    bu_vls_free( &str );
	}

    /* write BREP object entity */

    /* write name entity */
    if( name != NULL )
	name_de = write_name_entity( name , fp_dir , fp_param );
    else
	name_de = 0;

    /* write color and attributes entities, if appropriate */
    if( !name || lookup_props( &props , name ) )
	{
	    prop_de = 0;
	    color_de = 0;
	}
    else
	{
	    prop_de = write_att_entity( &props , fp_dir , fp_param );
	    if( props.color_defined )
		color_de = get_color( props.color , fp_dir , fp_param );
	}

    /* Put outer shell in BREP object first */
    bu_vls_printf( &str , "186,%d,1,%d" , shell_list[0] , shell_count-1 );

    /* Add all other shells */
    for( i=1 ; i<shell_count ; i++ )
	{
	    bu_vls_printf( &str , ",%d,1" , shell_list[i] );
	}

    if( prop_de || name_de )
	{
	    if( prop_de && name_de )
		bu_vls_strcat( &str , ",0,2" );
	    else
		bu_vls_printf( &str , ",0,1" );
	    if( prop_de )
		bu_vls_printf( &str , ",%d" , prop_de );
	    if( name_de )
		bu_vls_printf( &str , ",%d" , name_de );

	}

    bu_vls_strcat( &str , ";"  );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    dir_entry[1] = 186;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    if( dependent )
	dir_entry[9] = 10001;
    else
	dir_entry[9] = 1;
    dir_entry[11] = 186;
    dir_entry[13] = color_de;
    dir_entry[15] = 0;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_free( (char *)shell_list , "shell list" );
    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

void
w_terminate( fp )
     FILE *fp;
{
    fprintf( fp , "S%07dG%07dD%07dP%07d%40.40sT0000001\n" , start_len , global_len , dir_seq , param_seq , " " );
}

int
arb_is_rpp( arb )
     struct rt_arb_internal *arb;
{
    vect_t v0,v1,v2;
    int i;

    RT_ARB_CK_MAGIC( arb );

    /* for an rpp, all the height edge vectors must be equal,
       all the width edge vectors must be equal, all the
       depth edge vectors must be equal, and at least one
       vertex must have three right angles */

    /* check the height vectors */
    VSUB2( v0 , arb->pt[4] , arb->pt[0] );
    for( i=5 ; i<8 ; i++ )
	{
	    VSUB2( v1 , arb->pt[i] , arb->pt[i-4] );
	    if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
		return( 0 );
	}

    /* check the width vectors */
    VSUB2( v0 , arb->pt[1] , arb->pt[0] );
    VSUB2( v1 , arb->pt[2] , arb->pt[3] );
    if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
	return( 0 );
    VSUB2( v1 , arb->pt[6] , arb->pt[7] );
    if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
	return( 0 );
    VSUB2( v1 , arb->pt[5] , arb->pt[4] );
    if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
	return( 0 );

    /* check the depth vectors */
    VSUB2( v0 , arb->pt[3] , arb->pt[0] );
    VSUB2( v1 , arb->pt[2] , arb->pt[1] );
    if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
	return( 0 );
    VSUB2( v1 , arb->pt[6] , arb->pt[5] );
    if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
	return( 0 );
    VSUB2( v1 , arb->pt[7] , arb->pt[4] );
    if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
	return( 0 );

    /* check for a right angle corner */
    VSUB2( v0 , arb->pt[3] , arb->pt[0] );
    VSUB2( v1 , arb->pt[1] , arb->pt[0] );
    VSUB2( v2 , arb->pt[4] , arb->pt[0] );
    VUNITIZE( v0 );
    VUNITIZE( v1 );
    VUNITIZE( v2 );
    if( !BN_VECT_ARE_PERP( VDOT( v0 , v1 ) , &tol ) )
	return( 0 );
    if( !BN_VECT_ARE_PERP( VDOT( v0 , v2 ) , &tol ) )
	return( 0 );
    if( !BN_VECT_ARE_PERP( VDOT( v1 , v2 ) , &tol ) )
	return( 0 );

    return( 1 );
}

int
write_name_entity( name , fp_dir , fp_param )
     char *name;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;
    int			name_len;

    name_len = strlen( name );
    if( !name_len )
	return( 0 );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* write parameter data into a string */
    if( name_len >= NAMESIZE )
	bu_vls_printf( &str , "406,1,16H%16.16s;" , name );
    else
	bu_vls_printf( &str , "406,1,%ldH%s;" , strlen( name ) , name );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
    bu_vls_free( &str );

    /* write directory entry for name property entity */
    dir_entry[1] = 406;
    dir_entry[8] = 0;
    dir_entry[9] = 1010301;
    dir_entry[11] = 406;
    dir_entry[15] = 15;
    return( write_dir_entry( fp_dir , dir_entry ));
}

int
tor_to_iges( ip , name , fp_dir , fp_param )
     struct rt_db_internal *ip;
     char *name;
     FILE *fp_dir,*fp_param;
{
    struct rt_tor_internal	*tor;
    struct bu_vls		str;
    int			dir_entry[21];
    int			name_de;
    int			i;

    if( ip->idb_type != ID_TOR )
	bu_log( "tor_to_iges called for non-torus (type=%d)\n" , ip->idb_type );

    tor = (struct rt_tor_internal *)ip->idb_ptr;

    RT_TOR_CK_MAGIC( tor );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* write a name entity for this solid */
    name_de = write_name_entity( name , fp_dir , fp_param );

    /* write parameter data into a string */
    bu_vls_printf( &str , "160,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		   tor->r_a,
		   tor->r_h,
		   tor->v[X] , tor->v[Y] , tor->v[Z],
		   tor->h[X] , tor->h[Y] , tor->h[Z],
		   name_de );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
    bu_vls_free( &str );

    /* write directory entry for torus entity */
    dir_entry[1] = 160;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 160;
    dir_entry[15] = 0;
    return( write_dir_entry( fp_dir , dir_entry ));

}

int
sph_to_iges( ip , name , fp_dir , fp_param )
     char *name;
     struct rt_db_internal *ip;
     FILE *fp_dir,*fp_param;
{
    struct rt_ell_internal	*sph;
    struct bu_vls		str;
    double			radius;
    int			dir_entry[21];
    int			name_de;
    int			i;

    if( ip->idb_type != ID_SPH )
	bu_log( "sph_to_iges called for non-sph (type=%d)\n" , ip->idb_type );

    sph = (struct rt_ell_internal *)ip->idb_ptr;

    RT_ELL_CK_MAGIC( sph );

    /* write name entity */
    name_de = write_name_entity( name , fp_dir , fp_param );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    radius = MAGNITUDE( sph->a );

    /* write parameter data into a string */
    bu_vls_printf( &str , "158,%g,%g,%g,%g,0,1,%d;",
		   radius,
		   sph->v[X] , sph->v[Y] , sph->v[Z] ,
		   name_de );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
    bu_vls_free( &str );

    /* write directory entry for sphere entity */
    dir_entry[1] = 158;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 158;
    dir_entry[15] = 0;
    return( write_dir_entry( fp_dir , dir_entry ));

}

int
ell_to_iges( ip , name , fp_dir , fp_param )
     char *name;
     struct rt_db_internal *ip;
     FILE *fp_dir,*fp_param;
{
    struct rt_ell_internal	*ell;
    struct bu_vls		str;
    double			radius_a;
    double			radius_b;
    double			radius_c;
    vect_t			a_dir;
    vect_t			b_dir;
    vect_t			c_dir;
    int			dir_entry[21];
    int			name_de;
    int			i;

    if( ip->idb_type != ID_ELL )
	bu_log( "ell_to_iges called for non-ell (type=%d)\n" , ip->idb_type );

    ell = (struct rt_ell_internal *)ip->idb_ptr;

    RT_ELL_CK_MAGIC( ell );

    /* write name entity */
    name_de = write_name_entity( name , fp_dir , fp_param );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    radius_a = MAGNITUDE( ell->a );
    radius_b = MAGNITUDE( ell->b );
    radius_c = MAGNITUDE( ell->c );

    VMOVE( a_dir , ell->a );
    VMOVE( b_dir , ell->b );
    VMOVE( c_dir , ell->c );

    VUNITIZE( a_dir );
    VUNITIZE( b_dir );
    VUNITIZE( c_dir );

    /* write parameter data into a string */
    bu_vls_printf( &str , "168,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		   radius_a , radius_b , radius_c ,
		   ell->v[X] , ell->v[Y] , ell->v[Z] ,
		   a_dir[X] , a_dir[Y] , a_dir[Z] ,
		   c_dir[X] , c_dir[Y] , c_dir[Z] ,
		   name_de );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
    bu_vls_free( &str );

    /* write directory entry for ellipsoid entity */
    dir_entry[1] = 168;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 168;
    dir_entry[15] = 0;
    return( write_dir_entry( fp_dir , dir_entry ));

}
int
rpp_to_iges( ip , name , fp_dir , fp_param )
     char *name;
     struct rt_db_internal *ip;
     FILE *fp_dir,*fp_param;
{
    struct rt_arb_internal	*arb;
    struct bu_vls		str;
    double			length_a;
    double			length_b;
    double			length_c;
    vect_t			a_dir;
    vect_t			b_dir;
    vect_t			c_dir;
    vect_t			tmp_dir;
    int			dir_entry[21];
    int			name_de;
    int			i;

    if( ip->idb_type != ID_ARB8 )
	bu_log( "rpp_to_iges called for non-arb (type=%d)\n" , ip->idb_type );

    arb = (struct rt_arb_internal *)ip->idb_ptr;

    RT_ARB_CK_MAGIC( arb );

    /* write name entity */
    name_de = write_name_entity( name , fp_dir , fp_param );

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    VSUB2( a_dir , arb->pt[1] , arb->pt[0] );
    VSUB2( b_dir , arb->pt[3] , arb->pt[0] );
    VSUB2( c_dir , arb->pt[4] , arb->pt[0] );

    length_a = MAGNITUDE( a_dir );
    length_b = MAGNITUDE( b_dir );
    length_c = MAGNITUDE( c_dir );

    VUNITIZE( a_dir );
    VUNITIZE( b_dir );
    VUNITIZE( c_dir );

    /* c_dir cross a_dir must give b_dir for IGES */
    VCROSS( tmp_dir , c_dir , a_dir );
    if( VDOT( b_dir , tmp_dir ) < 0.0 )
	{
	    /* not a right-handed system, so exchange a_dir with c_dir */
	    double tmp_length;

	    VMOVE( tmp_dir , a_dir );
	    VMOVE( a_dir , c_dir );
	    VMOVE( c_dir , tmp_dir );
	    tmp_length = length_a;
	    length_a = length_c;
	    length_c = tmp_length;
	}

    /* write parameter data into a string */
    bu_vls_printf( &str , "150,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		   length_a , length_b , length_c ,
		   arb->pt[0][X] , arb->pt[0][Y] , arb->pt[0][Z] ,
		   a_dir[X] , a_dir[Y] , a_dir[Z] ,
		   c_dir[X] , c_dir[Y] , c_dir[Z] ,
		   name_de );

    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
    bu_vls_free( &str );

    /* write directory entry for block entity */
    dir_entry[1] = 150;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 150;
    dir_entry[15] = 0;
    return( write_dir_entry( fp_dir , dir_entry ));
}

int
arb_to_iges( ip , name , fp_dir , fp_param )
     char *name;
     struct rt_db_internal *ip;
     FILE *fp_dir,*fp_param;
{
    struct rt_arb_internal *arb;

    if( ip->idb_type != ID_ARB8 )
	{
	    bu_log( "arb_to_iges called for non-arb (type=%d)\n" , ip->idb_type );
	    return( 0 );
	}

    arb = (struct rt_arb_internal *)ip->idb_ptr;

    RT_ARB_CK_MAGIC( arb );

    if( arb_is_rpp( arb ) )
	return( rpp_to_iges( ip , name , fp_dir , fp_param ) );
    else
	return( nmg_to_iges( ip , name , fp_dir , fp_param ) );
}

int
tgc_to_iges( ip , name , fp_dir , fp_param )
     char *name;
     struct rt_db_internal *ip;
     FILE *fp_dir,*fp_param;
{
    struct rt_tgc_internal	*tgc;
    fastf_t			h_len,a_len,b_len,c_len,d_len;
    vect_t			h_dir,a_dir,b_dir;
    int			iges_type;
    struct bu_vls		str;
    int			dir_entry[21];
    int			name_de;
    int			i;

    if( ip->idb_type != ID_TGC )
	{
	    bu_log( "tgc_to_iges called for non-tgc (type=%d)\n" , ip->idb_type );
	    return( 0 );
	}

    tgc = (struct rt_tgc_internal *)ip->idb_ptr;

    RT_TGC_CK_MAGIC( tgc );

    h_len = MAGNITUDE( tgc->h );
    a_len = MAGNITUDE( tgc->a );
    b_len = MAGNITUDE( tgc->b );
    c_len = MAGNITUDE( tgc->c );
    d_len = MAGNITUDE( tgc->d );

    /* Use VSCALE rather than VUNITIZE, since we have
       already done the sqrt */

    VMOVE( h_dir , tgc->h );
    VSCALE( h_dir , h_dir , 1.0/h_len );

    VMOVE( a_dir , tgc->a );
    VSCALE( a_dir , a_dir , 1.0/a_len );

    VMOVE( b_dir , tgc->b );
    VSCALE( b_dir , b_dir , 1.0/b_len );

    if( !BN_VECT_ARE_PERP( VDOT( h_dir , a_dir ) , &tol ) ||
	!BN_VECT_ARE_PERP( VDOT( h_dir , b_dir ) , &tol ) )
	{
	    /* this is not an rcc or a trc */
	    return( nmg_to_iges( ip , name , fp_dir , fp_param ));
	}

    if( NEAR_ZERO( a_len-b_len , tol.dist ) &&
	NEAR_ZERO( c_len-d_len , tol.dist ) )
	{
	    /* this tgc is either an rcc or a trc */

	    /* write name entity */
	    name_de = write_name_entity( name , fp_dir , fp_param );

	    bu_vls_init( &str );

	    /* initialize directory entry */
	    for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	    if( NEAR_ZERO( a_len-c_len , tol.dist ) )
		{
		    /* its an rcc */
		    iges_type = 154;
		    bu_vls_printf( &str , "154,%g,%g,%g,%g,%g,%g,%g,%g" ,
				   h_len , a_len ,
				   tgc->v[X] , tgc->v[Y] , tgc->v[Z] ,
				   h_dir[X] , h_dir[Y] , h_dir[Z] );
		}
	    else
		{
		    /* its a trc */

		    fastf_t bigger_r,smaller_r;
		    vect_t base;

		    iges_type = 156;
		    if( a_len > c_len )
			{
			    bigger_r = a_len;
			    smaller_r = c_len;
			    VMOVE( base , tgc->v );
			}
		    else
			{
			    bigger_r = c_len;
			    smaller_r = a_len;
			    VADD2( base , tgc->v , tgc->h );
			    VREVERSE( h_dir , h_dir );
			}
		    bu_vls_printf( &str , "156,%g,%g,%g,%g,%g,%g,%g,%g,%g" ,
				   h_len , bigger_r , smaller_r ,
				   base[X] , base[Y] , base[Z] ,
				   h_dir[X] , h_dir[Y] , h_dir[Z] );
		}

	    bu_vls_printf( &str , ",0,1,%d;" , name_de );

	    /* remember where parameter data is going */
	    dir_entry[2] = param_seq + 1;

	    /* get parameter line count */
	    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	    bu_vls_free( &str );

	    /* fill in directory entry */
	    dir_entry[1] = iges_type;
	    dir_entry[8] = 0;
	    dir_entry[9] = 10001;
	    dir_entry[11] = iges_type;
	    dir_entry[15] = 0;

	    return( write_dir_entry( fp_dir , dir_entry ));
	}
    else
	return( nmg_to_iges( ip , name , fp_dir , fp_param ));
}

int
write_tree_of_unions( name, de_list , length , dependent , fp_dir , fp_param )
     char *name;
     int de_list[];
     int length;
     int dependent;
     FILE *fp_dir;
     FILE *fp_param;
{
    struct bu_vls		str;
    struct iges_properties	props;
    int			dir_entry[21];
    int			name_de;
    int			prop_de;
    int			color_de=DEFAULT;
    int			i;

    bu_vls_init( &str );

    /* write name entity */
    if( name != NULL )
	name_de = write_name_entity( name , fp_dir , fp_param );
    else
	name_de = 0;

    /* write color and attributes entities, if appropriate */
    if( lookup_props( &props , name ) )
	{
	    prop_de = 0;
	    color_de = 0;
	}
    else
	{
	    prop_de = write_att_entity( &props , fp_dir , fp_param );
	    if( props.color_defined )
		color_de = get_color( props.color , fp_dir , fp_param );
	}

    /* write parameter data into a string */
    bu_vls_printf( &str , "180,%d,%d" , 2*length-1 , -de_list[0] );
    for( i=1 ; i<length ; i++ )
	bu_vls_printf( &str , ",%d,1" , -de_list[i] );

    if( prop_de || name_de )
	{
	    if( prop_de && name_de )
		bu_vls_strcat( &str , ",0,2" );
	    else
		bu_vls_printf( &str , ",0,1" );
	    if( prop_de )
		bu_vls_printf( &str , ",%d" , prop_de );
	    if( name_de )
		bu_vls_printf( &str , ",%d" , name_de );

	}

    bu_vls_strcat( &str , ";"  );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    dir_entry[1] = 180;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    if( dependent )
	dir_entry[9] = 10001;
    else
	dir_entry[9] = 1;
    dir_entry[11] = 180;
    dir_entry[13] = color_de;
    dir_entry[15] = 0;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_solid_assembly( name, de_list , length , dependent , fp_dir , fp_param )
     char *name;
     int de_list[];
     int length;
     int dependent;
     FILE *fp_dir;
     FILE *fp_param;
{
    struct bu_vls		str;
    struct iges_properties	props;
    int			dir_entry[21];
    int			name_de;
    int			prop_de;
    int			color_de=DEFAULT;
    int			i;

    bu_vls_init( &str );

    /* write name entity */
    if( name != NULL )
	name_de = write_name_entity( name , fp_dir , fp_param );
    else
	name_de = 0;

    /* write color and attributes entities, if appropriate */
    if( lookup_props( &props , name ) )
	{
	    prop_de = 0;
	    color_de = 0;
	}
    else
	{
	    prop_de = write_att_entity( &props , fp_dir , fp_param );
	    if( props.color_defined )
		color_de = get_color( props.color , fp_dir , fp_param );
	}

    /* write parameter data into a string */
    bu_vls_printf( &str , "184,%d" , length );
    for( i=0 ; i<length ; i++ )
	bu_vls_printf( &str , ",%d" , de_list[i] );
    for( i=0 ; i<length ; i++ )
	bu_vls_printf( &str , ",0" );

    if( prop_de || name_de )
	{
	    if( prop_de && name_de )
		bu_vls_strcat( &str , ",0,2" );
	    else
		bu_vls_printf( &str , ",0,1" );
	    if( prop_de )
		bu_vls_printf( &str , ",%d" , prop_de );
	    if( name_de )
		bu_vls_printf( &str , ",%d" , name_de );

	}

    bu_vls_strcat( &str , ";"  );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    dir_entry[1] = 184;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    if( dependent )
	dir_entry[9] = 10001;
    else
	dir_entry[9] = 1;
    dir_entry[11] = 184;
    dir_entry[13] = color_de;
    dir_entry[15] = 0;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
nmg_to_iges( ip , name , fp_dir , fp_param )
     struct rt_db_internal *ip;
     char *name;
     FILE *fp_dir,*fp_param;
{
    struct model *model;
    struct nmgregion *r;
    int region_count;
    int *region_de;
    int brep_de;
    int dependent;
    int i;

    RT_CK_DB_INTERNAL( ip );

    dependent = 1;
    for( i=0 ; i<no_of_indeps ; i++ )
	{
	    if( !strncmp( name , independent[i] , NAMESIZE ) )
		{
		    dependent = 0;
		    break;
		}
	}

    solid_is_brep = 1;
    comb_form = 1;
    if( ip->idb_type == ID_NMG )
	{
	    model = (struct model *)ip->idb_ptr;
	    NMG_CK_MODEL( model );

	    /* count the number of nmgregions */
	    region_count = 0;
	    for( BU_LIST_FOR( r , nmgregion , &model->r_hd ) )
		{
		    NMG_CK_REGION( r );
		    region_count++;
		}

	    if( region_count == 0 )
		return( 0 );
	    else if( region_count == 1 )
		return( nmgregion_to_iges( name , BU_LIST_FIRST( nmgregion , &model->r_hd ) ,
					   dependent , fp_dir , fp_param ) );
	    else
		{
		    /* make a boolean tree unioning all the regions */

		    /* space to save the iges location of each nmgregion */
		    region_de = (int *)bu_calloc( region_count , sizeof( int ) , "nmg_to_iges" );

		    /* loop through all nmgregions in the model */
		    region_count = 0;
		    for( BU_LIST_FOR( r , nmgregion , &model->r_hd ) )
			region_de[region_count++] = nmgregion_to_iges( (char *)NULL , r , 1 ,
								       fp_dir , fp_param );

		    /* now make the boolean tree */
		    brep_de = write_tree_of_unions( name , region_de , region_count ,
						    dependent , fp_dir , fp_param );

		    bu_free( (char *)region_de , "nmg_to_iges" );
		    return( brep_de );
		}
	}
    else
	{
	    if( ip->idb_type == ID_BOT )
		{
		    struct rt_bot_internal *bot=(struct rt_bot_internal *)ip->idb_ptr;
		    if( bot->mode != RT_BOT_SOLID )
			{
			    bu_log( "%s is a plate mode primitive, and cannot be converted to IGES format!\n", name );
			    return( 0 );
			}
		}
	    model = nmg_mm();
	    if( rt_functab[ip->idb_type].ft_tessellate( &r , model , ip , &ttol , &tol ) )
		{
		    nmg_km( model );
		    return( 0 );
		}
	    else
		{
		    solids_to_nmg++;
		    brep_de =  nmgregion_to_iges( name , r , dependent , fp_dir , fp_param );
		    nmg_km( model );
		    return( brep_de );
		}
	}
}

int
null_to_iges( ip , name , fp_dir , fp_param )
     struct rt_db_internal *ip;
     char *name;
     FILE *fp_dir,*fp_param;
{
    return( 0 );
}

int
write_xform_entity( mat , fp_dir , fp_param )
     mat_t mat;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* write parameter data into a string */
    bu_vls_strcpy( &str , "124"  );
    for( i=0 ; i<12 ; i++ )
	{
	    bu_vls_printf( &str , ",%g" , mat[i] );
	}
    bu_vls_strcat( &str , ";" );

    dir_entry[1] = 124;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 124;
    dir_entry[15] = 0;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_solid_instance( orig_de , mat , fp_dir , fp_param )
     int orig_de;
     mat_t mat;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* write the transformation matrix and make the link */
    dir_entry[7] = write_xform_entity( mat , fp_dir , fp_param );

    /* write parameter data into a string */
    bu_vls_printf( &str , "430,%d;" , orig_de );

    dir_entry[1] = 430;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    dir_entry[9] = 10001;
    dir_entry[11] = 430;
    dir_entry[15] = solid_is_brep ? 1 : 0;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_att_entity( props , fp_dir , fp_param )
     struct iges_properties *props;
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			str_len;
    int			i;

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* write parameter data into a string */
    bu_vls_strcpy( &str , "422" );

    /* material name */
    str_len = strlen( props->material_name );
    if( str_len )
	bu_vls_printf( &str , ",%dH%s" , str_len , props->material_name );
    else
	bu_vls_strcat( &str , "," );

    /* material parameters */
    str_len = strlen( props->material_params );
    if( str_len )
	bu_vls_printf( &str , ",%dH%s" , str_len , props->material_params );
    else
	bu_vls_strcat( &str , "," );

    /* region flag */
    if( props->region_flag == 'R' )
	bu_vls_strcat( &str , ",1" );
    else
	bu_vls_strcat( &str , ",0" );

    /* ident number, air code, material code, los density */
    bu_vls_printf( &str , ",%d,%d,%d,%d,%d,%d;" ,
		   props->ident ,
		   props->air_code ,
		   props->material_code ,
		   props->los_density,
		   props->inherit,
		   props->color_defined );

    dir_entry[1] = 422;
    dir_entry[2] = param_seq + 1;
    dir_entry[3] = (-attribute_de);
    dir_entry[8] = 0;
    dir_entry[9] = 10301;
    dir_entry[11] = 422;
    dir_entry[15] = 0;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}

/*
 *	Write a region or group of only one member as a solid instance
 *
 */
int
short_comb_to_iges( props , dependent , de_pointers , fp_dir , fp_param )
     struct iges_properties *props;
     int dependent;
     int de_pointers[];
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			name_de;
    int			props_de;
    int			color_de=DEFAULT;
    int			status=1;
    int			i;

    /* if member has not been converted, don't try to write the tree */
    if( de_pointers[0] == 0  )
	return( 0 );

    if( dependent )
	status = 10001;

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* write name entity */
    name_de = write_name_entity( props->name , fp_dir , fp_param );

    /* write attributes entity */
    props_de = write_att_entity( props , fp_dir , fp_param );

    /* get color */
    if( props->color_defined )
	color_de = get_color( props->color , fp_dir , fp_param );
    else
	color_de = 0;

    /* write parameter data into a string */
    bu_vls_printf( &str , "430,%d" , de_pointers[0] );

    if( props_de || name_de )
	{
	    if( props_de && name_de )
		bu_vls_strcat( &str , ",0,2" );
	    else
		bu_vls_printf( &str , ",0,1" );
	    if( props_de )
		bu_vls_printf( &str , ",%d" , props_de );
	    if( name_de )
		bu_vls_printf( &str , ",%d" , name_de );

	}
    bu_vls_strcat( &str , ";" );

    dir_entry[1] = 430;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    dir_entry[9] = status;
    dir_entry[11] = 430;
    dir_entry[13] = color_de;
    dir_entry[15] = comb_form;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );

}

int
count_non_union_ops( tp )
     union tree *tp;
{
    int count=0;

    RT_CK_TREE( tp );

    switch( tp->tr_op )
	{
	    case OP_INTERSECT:
	    case OP_SUBTRACT:
		count++;
	    case OP_UNION:
		count += count_non_union_ops( tp->tr_b.tb_left );
		count += count_non_union_ops( tp->tr_b.tb_right );
		break;
	    default:
		break;
	}

    return( count );
}

void
igs_tree( str, tp, length, de_pointers )
     struct bu_vls *str;
     union tree *tp;
     int length;
     int *de_pointers;
{
    RT_CK_TREE( tp );
    BU_CK_VLS( str );

    switch( tp->tr_op )
	{
	    case OP_UNION:
		igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
		igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
		bu_vls_strcat( str, ",1" );
		break;
	    case OP_INTERSECT:
		igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
		igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
		bu_vls_strcat( str, ",2" );
		break;
	    case OP_SUBTRACT:
		igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
		igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
		bu_vls_strcat( str, ",3" );
		break;
	    case OP_DB_LEAF:
		bu_vls_printf( str, ",%d", -de_pointers[de_pointer_number] );
		de_pointer_number++;
		break;
	    default:
		bu_log( "Unrecognized operation in combination!\n" );
		break;
	}
}

void
write_igs_tree( str, comb, length, de_pointers )
     struct bu_vls *str;
     struct rt_comb_internal *comb;
     int length;
     int *de_pointers;
{
    BU_CK_VLS( str );
    RT_CK_COMB( comb );

    bu_vls_printf( str , "180,%d", 2*length-1 );

    de_pointer_number = 0;
    igs_tree( str, comb->tree, length, de_pointers );
}

int
tree_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param )
     struct rt_comb_internal *comb;
     int length,dependent;
     struct iges_properties *props;
     int de_pointers[];
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			actual_length=0;
    int			name_de;
    int			props_de;
    int			color_de=DEFAULT;
    int			non_union_count=0;
    int			status=1;
    int			entity_type;
    int			i;

    RT_CK_COMB( comb );

    /* if any part of this tree has not been converted, don't try to write the tree */
    for( i=0 ; i<length ; i++ )
	{
	    if( de_pointers[i] )
		actual_length++;
	}
    if( actual_length != length )
	return( 0 );

    if( dependent )
	status = 10001;

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* write name entity */
    name_de = write_name_entity( props->name , fp_dir , fp_param );

    /* write attributes entity */
    props_de = write_att_entity( props , fp_dir , fp_param );

    /* get color */
    if( props->color_defined )
	color_de = get_color( props->color , fp_dir , fp_param );
    else
	color_de = 0;

    non_union_count = count_non_union_ops( comb->tree );

    if( mode == CSG_MODE || non_union_count )
	{
	    /* write the combination as a Boolean tree */
	    entity_type = 180;
	    write_igs_tree( &str, comb, length, de_pointers );
	}
    else
	{
	    /* write the combination as a solid assembly */
	    entity_type = 184;

	    bu_vls_printf( &str , "%d,%d" , entity_type , length );
	    for( i=0 ; i<length ; i++ )
		bu_vls_printf( &str , ",%d" , de_pointers[i] );
	    for( i=0 ; i<length ; i++ )
		bu_vls_strcat( &str , ",0" );
	}

    if( props_de || name_de )
	{
	    if( props_de && name_de )
		bu_vls_strcat( &str , ",0,2" );
	    else
		bu_vls_printf( &str , ",0,1" );
	    if( props_de )
		bu_vls_printf( &str , ",%d" , props_de );
	    if( name_de )
		bu_vls_printf( &str , ",%d" , name_de );

	}
    bu_vls_strcat( &str , ";" );

    dir_entry[1] = entity_type;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    dir_entry[9] = status;
    dir_entry[11] = entity_type;
    dir_entry[13] = color_de;
    dir_entry[15] = comb_form;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );

}

int
comb_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param )
     struct rt_comb_internal *comb;
     int length,dependent;
     struct iges_properties *props;
     int de_pointers[];
     FILE *fp_dir,*fp_param;
{
    RT_CK_COMB( comb );

    if( length == 1 )
	return( short_comb_to_iges( props , dependent , de_pointers , fp_dir , fp_param ) );
    else
	return( tree_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param ) );
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.19
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.18 2007/11/21 19:05:59 erikgreenwald Exp $";
d303 2
a304 2
    bzero( props->material_name, 32 );
    bzero( props->material_params, 60 );
@


1.18
log
@exit->bu_exit where applicable
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.17 2007/11/21 15:32:04 erikgreenwald Exp $";
d429 1
a429 4
	{
	    bu_log( "Bad section character passed to 'write_freeform' (%c)\n" , c );
	    bu_exit( 1, "" );
	}
@


1.17
log
@char*label isn't munged, so make it const
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.16 2007/11/21 15:21:33 erikgreenwald Exp $";
d431 1
a431 1
	    exit( 1 );
@


1.16
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.15 2007/10/28 05:41:46 brlcad Exp $";
d736 1
a736 1
    char *label;
@


1.15
log
@more flawfinder and bu_exit conversions
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.14 2007/10/22 17:42:35 brlcad Exp $";
d280 1
a280 1
					bu_bomb( "nmg_to_winged_edge: Can't happen nmg_keu resulted in empty shell!\n" );
@


1.14
log
@whoosh, another 10% complete on the bu_bomb to bu_exit conversion review.  also includes a slew of custom exit() calls that can use bu_exit() as well as toning down a slew of overzealous exclamation point use.  (20% complete overall)
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.13 2007/10/14 22:15:54 brlcad Exp $";
d74 3
a76 3
static char	*global_form="%-72.72s%c%07d\n"; /* format for global section */
static char	*param_form="%-64.64s %7d%c%07d\n"; /* format for parameter section */
static char	*att_string="BRL-CAD attribute definition:material name,material parameters,region flag,ident number,air code,material code (GIFT),los density,inheritance";
d80 1
a80 1
static char	*unknown="Unknown";
@


1.13
log
@more level 4 flawfinder issues.  mostly string length clampages.
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.12 2007/09/15 16:23:05 brlcad Exp $";
d280 1
a280 1
					bu_bomb( "nmg_to_winged_edge: Can't happen nmg_keu resulted in empty shell!!!!\n" );
d383 1
a383 1
	    bu_log( "Directory/Database mismatch!!!! is %s a combination or not???\n", dp->d_namep );
d907 1
a907 1
					    bu_log( "vertex with no geometry!!\n" );
d1098 1
a1098 1
		bu_bomb( "nmg_loop_to_tcurve: too many vertices in loop!!!!\n" );
d2774 1
a2774 1
			    bu_log( "%s is a plate mode primitive, and cannot be converted to IGES format!!!\n", name );
d3068 1
a3068 1
		bu_log( "Unrecognized operation in combination!!\n" );
@


1.12
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.11 2007/07/26 01:13:52 brlcad Exp $";
d349 1
a349 1
    strcpy( props->name, name );
@


1.11
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.10 2007/05/18 04:13:44 brlcad Exp $";
d48 1
a48 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


1.10
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d27 1
a27 3
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
a28 5
 */

/*	Yet to do:
 *

d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.9 2007/05/14 21:04:30 brlcad Exp $";
@


1.9
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d47 1
a47 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.8 2007/01/31 21:38:50 brlcad Exp $";
d291 1
a291 1
					rt_bomb( "nmg_to_winged_edge: Can't happen nmg_keu resulted in empty shell!!!!\n" );
d1109 1
a1109 1
		rt_bomb( "nmg_loop_to_tcurve: too many vertices in loop!!!!\n" );
@


1.8
log
@more BRL-CAD name consistency.  allow BRLCAD or BRL-CAD in the attribute string.
@
text
@d47 1
a47 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.7 2007/01/23 01:13:26 brlcad Exp $";
a66 2
#include "rtlist.h"
#include "rtstring.h"
d70 1
@


1.7
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d47 1
a47 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.6 2007/01/20 14:36:47 brlcad Exp $";
d88 1
a88 1
static char	*att_string="BRLCAD attribute definition:material name,material parameters,region flag,ident number,air code,material code (GIFT),los density,inheritance";
a101 1
BU_EXTERN( int write_freeform, ( FILE *fp, char s[], int de, char c ) );
a406 34
int
write_color_entity( color , fp_dir , fp_param )
     unsigned char color[3];
     FILE *fp_dir,*fp_param;
{
    struct bu_vls		str;
    int			dir_entry[21];
    int			i;
    float			c[3];

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* convert colors to percents */
    for( i=0 ; i<3 ; i++ )
	c[i] = (float)color[i]/2.55;

    bu_vls_printf( &str , "314,%g,%g,%g;" , c[0] , c[1] , c[2] );

    dir_entry[1] = 314;
    dir_entry[2] = param_seq + 1;
    dir_entry[8] = 0;
    dir_entry[9] = 10201;
    dir_entry[11] = 314;
    dir_entry[15] = 0;
    dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );
}
d409 2
a410 160
get_color( color , fp_dir , fp_param )
     unsigned char color[3];
     FILE *fp_dir,*fp_param;
{
    int color_de;

    for( color_de=0 ; color_de < 9 ; color_de++ )
	{
	    if( color[0] == colortab[color_de][1] &&
		color[1] == colortab[color_de][2] &&
		color[2] == colortab[color_de][3] )
		break;
	}

    if( color_de == 9 )
	color_de = (-write_color_entity( color , fp_dir , fp_param ));

    return( color_de );
}

int
write_attribute_definition( fp_dir , fp_param )
     FILE *fp_dir,*fp_param;
{
    struct bu_vls str;
    int dir_entry[21];
    int i;

    bu_vls_init( &str );

    /* initialize directory entry */
    for( i=0 ; i<21 ; i++ )
	dir_entry[i] = DEFAULT;

    /* start with parameter data */
    bu_vls_printf( &str , "322,%ldH%s,5001,9" , strlen( att_string ) , att_string );
    bu_vls_printf( &str , ",1,3,1" ); /* material name */
    bu_vls_printf( &str , ",2,3,1" ); /* material parameters */
    bu_vls_printf( &str , ",3,6,1" ); /* region flag (logical value) */
    bu_vls_printf( &str , ",4,1,1" ); /* ident number */
    bu_vls_printf( &str , ",5,1,1" ); /* air code number */
    bu_vls_printf( &str , ",6,1,1" ); /* material code number */
    bu_vls_printf( &str , ",7,1,1" ); /* los density (X100) */
    bu_vls_printf( &str , ",8,1,1" ); /* inheritance */
    bu_vls_printf( &str , ",9,6,1;" ); /* color_defined (logical value) */


    /* remember where parameter data is going */
    dir_entry[2] = param_seq + 1;

    /* get parameter line count */
    dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

    /* write directory entry for line entity */
    dir_entry[1] = 322;
    dir_entry[8] = 0;
    dir_entry[9] = 10201;
    dir_entry[11] = 322;
    dir_entry[15] = 0;

    bu_vls_free( &str );

    return( write_dir_entry( fp_dir , dir_entry ) );

}

void
iges_init( set_tol , set_ttol , set_verbose , dbip_set )
     struct bn_tol *set_tol;
     struct rt_tess_tol *set_ttol;
     int set_verbose;
     struct db_i *dbip_set;
{
    BN_CK_TOL( set_tol );
    RT_CK_TESS_TOL( set_ttol );
    tol = (*set_tol);
    ttol = (*set_ttol);
    verbose = set_verbose;
    dbip = dbip_set;

    dir_seq = 0;
    param_seq = 0;
    start_len = 0;
    global_len = 0;
}

void
Print_stats( fp )
     FILE *fp;
{
    int i;
    int total_entities=0;

    fprintf( fp , "Wrote the following numbers and type of entities:\n" );
    for( i=0 ; i<NO_OF_TYPES ; i++ )
	if( type_count[i][1] > 0 )
	    {
		total_entities += type_count[i][1];
		fprintf( fp , "\t%d - %s\n" , type_count[i][1] , type_name[i] );
	    }

    fprintf( fp , "Total of %d entities written\n" , total_entities );

    if( solids_to_nmg )
	fprintf( fp , "%d solids converted to NMG's before exporting to IGES\n" , solids_to_nmg );
}

int
write_dir_entry( fp , entry )
     FILE *fp;
     int entry[];
{
    int i,j,type_index;
    char *label;

    for( type_index=0; type_index<NO_OF_TYPES ; type_index++ )
	if( type_count[type_index][0] == entry[1] )
	    break;
    if( type_index == NO_OF_TYPES )
	{
	    bu_log( "Writing directory entry for an unknown entity type (%d)\n" , entry[1] );
	    label = unknown;
	    unknown_count++;
	    entry[19] = unknown_count;
	}
    else
	{
	    label = type_label[type_index];
	    type_count[type_index][1]++;
	    entry[19] = type_count[type_index][1];
	}

    entry[10] = dir_seq + 1;
    entry[20] = dir_seq + 2;

    for( j=0 ; j<2 ; j++ )
	{

	    for( i=j*10+1 ; i<(j+1)*10 ; i++ )
		{
		    if( i == 18 )
			fprintf( fp , "%8.8s" , label );
		    else if( entry[i] == DEFAULT )
			fprintf( fp , "        " );
		    else if( i == 9 )
			fprintf( fp , "%08d" , entry[i] );
		    else
			fprintf( fp , "%8d" , entry[i] );
		}
	    fprintf( fp , "D%07d\n" , entry[(j+1)*10] );
	}

    dir_seq += 2;
    return( dir_seq - 1 );
}

int
write_freeform(
	       FILE *fp,	/* output file */
	       char s[],	/* the string to be output (must not contain any NL's) */
a414 1

d601 191
d811 1
a811 1
    (void)write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'S' );
d858 1
a858 1
    (void)write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'G' );
@


1.6
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d47 1
a47 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.5 2006/04/06 19:30:22 brlcad Exp $";
@


1.5
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2006 United States Government as represented by
d48 1
a48 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.4 2006/02/27 05:52:22 brlcad Exp $";
@


1.4
log
@quell warnings, missing stdlib.h, calls to exit with a negative, ws.
@
text
@d48 1
a48 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.3 2006/01/18 06:46:14 brlcad Exp $";
d480 1
a480 1
    bu_vls_printf( &str , "322,%dH%s,5001,9" , strlen( att_string ) , att_string );
d819 1
a819 1
    bu_vls_printf( &str , ",,%dH%s" , strlen( db_name ), db_name);
d824 1
a824 1
	bu_vls_printf( &str , ",%dH%s" , strlen( output_file ) , output_file );
d826 1
a826 1
    bu_vls_printf( &str , ",%dH%s,%dH%s,32,38,6,308,15,%dH%s,1.0,2,2HMM,,1.0" ,
d2129 1
a2129 1
	bu_vls_printf( &str , "406,1,%dH%s;" , strlen( name ) , name );
@


1.4.2.1
log
@update from HEAD
@
text
@d48 1
a48 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.4 2006/02/27 05:52:22 brlcad Exp $";
d480 1
a480 1
    bu_vls_printf( &str , "322,%ldH%s,5001,9" , strlen( att_string ) , att_string );
d819 1
a819 1
    bu_vls_printf( &str , ",,%ldH%s" , strlen( db_name ), db_name);
d824 1
a824 1
	bu_vls_printf( &str , ",%ldH%s" , strlen( output_file ) , output_file );
d826 1
a826 1
    bu_vls_printf( &str , ",%ldH%s,%ldH%s,32,38,6,308,15,%ldH%s,1.0,2,2HMM,,1.0" ,
d2129 1
a2129 1
	bu_vls_printf( &str , "406,1,%ldH%s;" , strlen( name ) , name );
@


1.3
log
@update copyright to 2006
@
text
@d48 1
a48 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.2 2005/10/29 04:20:52 brlcad Exp $";
d53 1
a53 2


d57 1
a57 1
#include <string.h>
d59 1
a59 1
#include <strings.h>
d65 1
d76 1
d116 32
a147 32
			{ 106 , 0 },	/* Copious Data */
			{ 110 , 0 },	/* Line */
			{ 116 , 0 },	/* Point */
			{ 123 , 0 },	/* Direction */
			{ 124 , 0 },	/* Transformation Matrix */
			{ 126 , 0 },	/* Rational B-spline Curve */
			{ 128 , 0 },	/* Rational B-spline Surface */
			{ 142 , 0 },	/* Curve on a Parametric Surface */
			{ 144 , 0 },	/* Trimmed Surface */
			{ 150 , 0 },	/* Block */
			{ 152 , 0 },	/* Right Angle Wedge */
			{ 154 , 0 },	/* Right Circular Cylinder */
			{ 156 , 0 },	/* Right Circular Cone Frustum */
			{ 158 , 0 },	/* Sphere */
			{ 160 , 0 },	/* Torus */
			{ 164 , 0 },	/* Solid of Linear Extrusion */
			{ 168 , 0 },	/* Ellipsoid */
			{ 180 , 0 },	/* Boolean Tree */
			{ 184 , 0 },	/* Solid Assembly */
			{ 186 , 0 },	/* Manifold Solid BREP Object */
			{ 190 , 0 },	/* Plane Surface */
			{ 314 , 0 },	/* Color */
			{ 322 , 0 },	/* Attribute Table Definition */
			{ 406 , 0 },	/* Property Entity */
			{ 422 , 0 },	/* Attribute Table Instance */
			{ 430 , 0 },	/* Solid Instance */
			{ 502 , 0 },	/* Vertex List */
			{ 504 , 0 },	/* Edge List */
			{ 508 , 0 },	/* Loop */
			{ 510 , 0 },	/* Face */
			{ 514 , 0 }	/* Shell */
		};
d150 32
a181 32
			"CopiusDa",
			"Line",
			"Point",
			"Directin",
			"Matrix",
			"B-spline",
			"NURB",
			"TrimCurv",
			"TrimSurf",
			"Block",
			"RA Wedge",
			"RC Cylin",
			"RC Frust",
			"Sphere",
			"Torus",
			"Extruson",
			"Ellipsod",
			"BoolTree",
			"Assembly",
			"BREP Obj",
			"PlaneSur",
			"Color",
			"Att Def",
			"Property",
			"Att Inst",
			"SolInst",
			"VertList",
			"EdgeList",
			"Loop",
			"Face",
			"Shell"
		};
d184 32
a215 32
			"Copious Data",
			"Line",
			"Point",
			"Direction",
			"Transformation Matrix",
			"Rational B_spline Curve",
			"NURB Surface",
			"Curve on a Parametric Surface",
			"Trimmed Surface",
			"Block",
			"Right Angle Wedge",
			"Right Circular Cylinder",
			"Right Circular Cone Frustum",
			"Sphere",
			"Torus",
			"Linear Sketch Extrusion",
			"Ellipsoid",
			"Boolean Tree",
			"Assembly Primitive",
			"Manifold Boundary Representation",
			"Plane Surface",
			"Color Definition",
			"Attribute Table Definition",
			"Property Entity",
			"Attribute Table Instance",
			"Primitive Instance",
			"Vertex List",
			"Edge List",
			"Loop",
			"Face",
			"Shell"
		};
d218 9
a226 9
	{ 0 , 217 , 217 , 217 }, /* index 0 actually represents an undefined color */
	{ 1 ,   0 ,   0 ,   0 },
	{ 2 , 255 ,   0 ,   0 },
	{ 3 ,   0 , 255 ,   0 },
	{ 4 ,   0 ,   0 , 255 },
	{ 5 , 255 , 255 ,   0 },
	{ 6 , 255 ,   0 , 255 },
	{ 7 ,   0 , 255 , 255 },
	{ 8 , 255 , 255 , 255 }};
d231 1
a231 1
struct nmgregion *r;
d233 1
a233 1
	struct shell *s;
d235 1
a235 1
	NMG_CK_REGION( r );
d237 1
a237 1
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
d239 1
a239 1
		struct faceuse *fu;
d241 2
a242 2
		NMG_CK_SHELL( s );
		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d244 1
a244 1
			struct loopuse *lu;
d246 3
a248 3
			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				continue;
d250 1
a250 1
			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d252 1
a252 1
				struct edgeuse *eu1,*eu2;
d254 3
a256 3
				NMG_CK_LOOPUSE( lu );
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;
d258 1
a258 1
				for( BU_LIST_FOR( eu1 , edgeuse , &lu->down_hd ) )
d260 2
a261 2
					struct edgeuse *eu_new;
					struct vertex *v1=NULL,*v2=NULL;
d263 38
a300 38
					NMG_CK_EDGEUSE( eu1 );
					if( eu1->radial_p == eu1->eumate_p )
						continue;	/* dangling edge (?warning?) */

					if( eu1->radial_p->eumate_p->radial_p == eu1->eumate_p )
						continue;	/* winged edge */

					/* this edge has more than two radial faces
					 * find the other face from this shell
					 */
					eu2 = eu1->radial_p;
					while( eu2 != eu1 && eu2 != eu1->eumate_p
						&& nmg_find_s_of_eu( eu2 ) != s )
							eu2 = eu2->eumate_p->radial_p;

					/* unglue edge eu1 */
					nmg_unglueedge( eu1 );

					/* Make a new edge */
					eu_new = nmg_me( v1 , v2 , s );

					/* Give the endpoints the same coordinates as the originbal edge */
					nmg_vertex_gv( eu_new->vu_p->v_p , eu1->vu_p->v_p->vg_p->coord );
					nmg_vertex_gv( eu_new->eumate_p->vu_p->v_p , eu1->eumate_p->vu_p->v_p->vg_p->coord );

					/* Move edgeuses to the new vertices */
					nmg_movevu( eu1->vu_p , eu_new->vu_p->v_p );
					nmg_movevu( eu1->eumate_p->vu_p , eu_new->eumate_p->vu_p->v_p );

					/* kill the new edge (I only wanted it for its vertices) */
					if( nmg_keu( eu_new ) )
						rt_bomb( "nmg_to_winged_edge: Can't happen nmg_keu resulted in empty shell!!!!\n" );

					/* move the other edgeuse to the same edge */
					if( eu2 == eu1 || eu2 == eu1->eumate_p )
						bu_log( "nmg_to_winged_edge: couldn't find second radial face for eu x%x in shell x%x\n" , eu1 , s );
					else
						nmg_moveeu( eu1 , eu2 );
d309 2
a310 2
struct iges_properties *props;
struct rt_comb_internal *comb;
d312 1
a312 1
	char *endp;
d314 1
a314 1
	RT_CK_COMB( comb );
d316 20
a335 33
	endp = strchr( bu_vls_addr(&comb->shader), ' ' );
	bzero( props->material_name, 32 );
	bzero( props->material_params, 60 );
	if( endp )  {
		int	len;
		len = endp - bu_vls_addr(&comb->shader);
		if( len > 31 ) len = 31;
		strncpy( props->material_name, bu_vls_addr(&comb->shader), len );
		strncpy( props->material_params, endp+1, 59 );
	} else {
		strncpy( props->material_name, bu_vls_addr(&comb->shader), 31 );
		props->material_params[0] = '\0';
	}
	if( comb->region_flag )
	{
		props->region_flag = 'R';
		props->ident = comb->region_id;
		props->air_code = comb->aircode;
		props->material_code = comb->GIFTmater;
		props->los_density = comb->los;
	}
	props->color_defined = ( comb->rgb_valid ? 1 : 0 );
	if( props->color_defined )
	{
		props->color[0] = comb->rgb[0];
		props->color[1] = comb->rgb[1];
		props->color[2] = comb->rgb[2];
	}
	else
	{
		props->color[0] = 0;
		props->color[1] = 0;
		props->color[2] = 0;
d337 14
a350 1
	props->inherit = ( comb->inherit ? 1 : 0 );
d355 2
a356 2
struct iges_properties *props;
char *name;
d358 16
a373 4
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int id;
d375 2
a376 11
	strcpy( props->name, name );
	props->material_name[0] = '\0';
	props->material_params[0] = '\0';
	props->region_flag = ' ';
	props->ident = 0;
	props->air_code = 0;
	props->material_code = 0;
	props->los_density = 0;
	props->color[0] = 0;
	props->color[1] = 0;
	props->color[2] = 0;
d378 3
a380 2
	if( name == NULL )
		return( 1 );
d382 2
a383 6
	dp  = db_lookup( dbip , name , 1 );
	if( dp == DIR_NULL )
		return( 1 );

	if( !(dp->d_flags & DIR_COMB) )
		return( 1 );
d385 1
a385 1
	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL , &rt_uniresource);
d387 1
a387 1
	if( id < 0 )
d389 3
a391 3
		rt_db_free_internal( &intern , &rt_uniresource);
		bu_log( "Could not get internal form of %s\n", dp->d_namep );
		return( 1 );
d394 1
a394 1
	if( id != ID_COMBINATION )
d396 3
a398 3
		rt_db_free_internal( &intern , &rt_uniresource);
		bu_log( "Directory/Database mismatch!!!! is %s a combination or not???\n", dp->d_namep );
		return( 1 );
d401 2
a402 2
	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );
d404 3
a406 3
	get_props( props , comb );
	rt_db_free_internal( &intern , &rt_uniresource);
	return( 0 );
d411 2
a412 2
unsigned char color[3];
FILE *fp_dir,*fp_param;
d414 4
a417 4
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
	float			c[3];
d419 1
a419 1
	bu_vls_init( &str );
d421 3
a423 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;
d425 3
a427 3
	/* convert colors to percents */
	for( i=0 ; i<3 ; i++ )
		c[i] = (float)color[i]/2.55;
d429 1
a429 1
	bu_vls_printf( &str , "314,%g,%g,%g;" , c[0] , c[1] , c[2] );
d431 7
a437 7
	dir_entry[1] = 314;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10201;
	dir_entry[11] = 314;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d439 1
a439 1
	bu_vls_free( &str );
d441 1
a441 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d446 2
a447 2
unsigned char color[3];
FILE *fp_dir,*fp_param;
d449 1
a449 1
	int color_de;
d451 1
a451 1
	for( color_de=0 ; color_de < 9 ; color_de++ )
d453 4
a456 4
		if( color[0] == colortab[color_de][1] &&
		    color[1] == colortab[color_de][2] &&
		    color[2] == colortab[color_de][3] )
			break;
d459 2
a460 2
	if( color_de == 9 )
		color_de = (-write_color_entity( color , fp_dir , fp_param ));
d462 1
a462 1
	return( color_de );
d467 1
a467 1
FILE *fp_dir,*fp_param;
d469 35
a503 9
	struct bu_vls str;
	int dir_entry[21];
	int i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d505 1
a505 25
	/* start with parameter data */
	bu_vls_printf( &str , "322,%dH%s,5001,9" , strlen( att_string ) , att_string );
	bu_vls_printf( &str , ",1,3,1" ); /* material name */
	bu_vls_printf( &str , ",2,3,1" ); /* material parameters */
	bu_vls_printf( &str , ",3,6,1" ); /* region flag (logical value) */
	bu_vls_printf( &str , ",4,1,1" ); /* ident number */
	bu_vls_printf( &str , ",5,1,1" ); /* air code number */
	bu_vls_printf( &str , ",6,1,1" ); /* material code number */
	bu_vls_printf( &str , ",7,1,1" ); /* los density (X100) */
	bu_vls_printf( &str , ",8,1,1" ); /* inheritance */
	bu_vls_printf( &str , ",9,6,1;" ); /* color_defined (logical value) */


	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 322;
	dir_entry[8] = 0;
	dir_entry[9] = 10201;
	dir_entry[11] = 322;
	dir_entry[15] = 0;
d507 1
a507 3
	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
d513 16
a528 16
struct bn_tol *set_tol;
struct rt_tess_tol *set_ttol;
int set_verbose;
struct db_i *dbip_set;
{
	BN_CK_TOL( set_tol );
	RT_CK_TESS_TOL( set_ttol );
	tol = (*set_tol);
	ttol = (*set_ttol);
	verbose = set_verbose;
	dbip = dbip_set;

	dir_seq = 0;
	param_seq = 0;
	start_len = 0;
	global_len = 0;
d533 1
a533 1
FILE *fp;
d535 2
a536 2
	int i;
	int total_entities=0;
d538 7
a544 7
	fprintf( fp , "Wrote the following numbers and type of entities:\n" );
	for( i=0 ; i<NO_OF_TYPES ; i++ )
		if( type_count[i][1] > 0 )
		{
			total_entities += type_count[i][1];
			fprintf( fp , "\t%d - %s\n" , type_count[i][1] , type_name[i] );
		}
d546 1
a546 1
	fprintf( fp , "Total of %d entities written\n" , total_entities );
d548 2
a549 2
	if( solids_to_nmg )
		fprintf( fp , "%d solids converted to NMG's before exporting to IGES\n" , solids_to_nmg );
d554 2
a555 2
FILE *fp;
int entry[];
d557 2
a558 2
	int i,j,type_index;
	char *label;
d560 4
a563 4
	for( type_index=0; type_index<NO_OF_TYPES ; type_index++ )
		if( type_count[type_index][0] == entry[1] )
			break;
	if( type_index == NO_OF_TYPES )
d565 4
a568 4
		bu_log( "Writing directory entry for an unknown entity type (%d)\n" , entry[1] );
		label = unknown;
		unknown_count++;
		entry[19] = unknown_count;
d570 1
a570 1
	else
d572 3
a574 3
		label = type_label[type_index];
		type_count[type_index][1]++;
		entry[19] = type_count[type_index][1];
d577 2
a578 2
	entry[10] = dir_seq + 1;
	entry[20] = dir_seq + 2;
d580 1
a580 1
	for( j=0 ; j<2 ; j++ )
d583 1
a583 1
		for( i=j*10+1 ; i<(j+1)*10 ; i++ )
d585 8
a592 8
			if( i == 18 )
				fprintf( fp , "%8.8s" , label );
			else if( entry[i] == DEFAULT )
				fprintf( fp , "        " );
			else if( i == 9 )
				fprintf( fp , "%08d" , entry[i] );
			else
				fprintf( fp , "%8d" , entry[i] );
d594 1
a594 1
		fprintf( fp , "D%07d\n" , entry[(j+1)*10] );
d597 2
a598 2
	dir_seq += 2;
	return( dir_seq - 1 );
d603 6
a608 6
FILE *fp,	/* output file */
char s[],	/* the string to be output (must not contain any NL's) */
int de,		/* the directory entry # that this belongs to (ignored for Global section) */
char c)		/* 'G' for global section
		 * 'P' for parameter section
		 * 'S' for start section */
d611 8
a618 8
	int paramlen;
	int start_seq;
	int str_len;
	int line_start=0;
	int line_end=0;
	int *seq_no;
	int remaining_chars=0;
	int i;
d620 1
a620 1
	if( c == 'P' )
d622 2
a623 2
		seq_no = &param_seq;
		paramlen = 64;
d625 1
a625 1
	else if( c == 'G' )
d627 2
a628 2
		seq_no = &global_len;
		paramlen = 72;
d630 1
a630 1
	else if( c == 'S' )
d632 2
a633 2
		seq_no = &start_len;
		paramlen = 72;
d635 1
a635 1
	else
d637 2
a638 2
		bu_log( "Bad section character passed to 'write_freeform' (%c)\n" , c );
		exit( 1 );
d641 2
a642 2
	str_len = strlen( s );
	start_seq = (*seq_no);
d645 2
a646 2
	/* the start section is just one big string, so just print in pieces if necessary */
	if( c == 'S' )
d648 2
a649 2
		line_start = 0;
		while( line_start < str_len )
d651 3
a653 3
			(*seq_no)++;
			fprintf( fp , global_form , &s[line_start] , c , *seq_no );
			line_start += paramlen;
d655 1
a655 1
		return( *seq_no - start_seq );
d658 2
a659 2
	/* Just print any string that will fit */
	if( str_len <= paramlen )
d661 6
a666 6
		(*seq_no)++;
		if( c == 'P' )
			fprintf( fp , param_form , s , de , c , *seq_no );
		else
			fprintf( fp , global_form , s , c , *seq_no );
		return( *seq_no - start_seq );
d668 1
a668 1
	else /* break string into lines */
d670 2
a671 2
		int curr_loc=0;
		int field_start=0;
d673 1
a673 1
		while( 1 )
d675 3
a677 3
			line_end = line_start + paramlen - 1;
			curr_loc = line_start;
			if( line_end >= str_len ) /* write the last line and break */
d679 6
a684 6
				(*seq_no)++;
				if( c == 'P' )
					fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
				else
					fprintf( fp , global_form , &s[line_start] , c , *seq_no );
				break;
d686 1
a686 1
			else /* find the end of this line */
d688 3
a690 3
				/* cannot extend numbers across lines,
				 * but character strings may. The only way
				 * to be sure is to interpret the entire string */
d692 1
a692 1
				if( remaining_chars >= paramlen )
d694 7
a700 7
					/* just print more of the string */
					(*seq_no)++;
					if( c == 'P' )
						fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
					else
						fprintf( fp , global_form , &s[line_start] , c , *seq_no );
					remaining_chars -= paramlen;
d702 1
a702 1
				else
d704 1
a704 1
					int done=0;
d706 1
a706 1
					while( !done )
d708 2
a709 2
						char num[81];
						int j=0;
d711 2
a712 2
						/* skip over any remainder of a string */
						if( remaining_chars )
d714 2
a715 2
							curr_loc = line_start + remaining_chars;
							remaining_chars = 0;
d717 1
a717 1
						field_start = curr_loc;
d719 1
a719 1
						if( s[curr_loc] == ',' || s[curr_loc] == ';' )
d721 2
a722 2
							/* empty field */
							curr_loc++;
d724 1
a724 1
						else
d726 3
a728 3
							while( isdigit(s[curr_loc]) )
								num[j++] = s[curr_loc++];
							num[j] = '\0';
d730 1
a730 1
							if( s[curr_loc] == 'H' )
d732 2
a733 2
								/* This is a string */
								int len;
d735 1
a735 1
								len = atoi( num );
d737 2
a738 2
								/* skip over the 'H' */
								curr_loc++;
d740 1
a740 1
								if( curr_loc + len >= line_end )
d742 8
a749 8
									/* break this line in a string */
									(*seq_no)++;
									if( c == 'P' )
										fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
									else
										fprintf( fp , global_form , &s[line_start] , c , *seq_no );
									remaining_chars = curr_loc + len - line_end;
									done = 1;
d751 2
a752 2
								else
									curr_loc += len + 1;
d754 1
a754 1
							else
d756 1
a756 1
								/* this is not a string and cannot be continued to next line */
d758 2
a759 2
								/* find end of this field */
								while( curr_loc < str_len && s[curr_loc] != ',' && s[curr_loc] != ';' )
d761 1
a761 1
									curr_loc++;
d764 2
a765 2
								if( s[curr_loc] == ',' || s[curr_loc] == ';' )
									curr_loc++;
d767 1
a767 1
								if( curr_loc > line_end )
d769 1
a769 1
									/* end of line must be at start of this field */
d771 13
a783 13
									line_end = field_start-1;
									for( i=line_start ; i<=line_end ; i++ )
										fputc( s[i] , fp );

									/* fill out line with blanks */
									for( i=0 ; i<paramlen-(line_end-line_start+1) ; i++ )
										fputc( ' ' , fp );
									if( c == 'P' )
										fprintf( fp , " %7d" , de );
									/* add columns 73 through 80 */
									(*seq_no)++;
									fprintf( fp , "%c%07d\n" , c , *seq_no );
									done = 1;
d790 1
a790 1
			line_start = line_end + 1;
d792 1
a792 1
		return( *seq_no - start_seq );
d798 62
a859 62
	FILE *fp_dir,
	FILE *fp_param,
	const char *db_name,
	const char *prog_name,
	const char *output_file,
	const char *id,
	const char *version)
{
	struct bu_vls str;
	time_t now;
	struct tm *timep;
	struct stat db_stat;

	bu_vls_init( &str );

	/* Write Start Section */
	bu_vls_printf( &str , "This IGES file created by %s from the database %s." , prog_name , db_name );
	(void)write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'S' );
	bu_vls_free( &str );

	/* Write Global Section */
	bu_vls_printf( &str , ",,%dH%s" , strlen( db_name ), db_name);

	if( output_file == NULL )
		bu_vls_printf( &str , ",7Hstd_out" );
	else
		bu_vls_printf( &str , ",%dH%s" , strlen( output_file ) , output_file );

	bu_vls_printf( &str , ",%dH%s,%dH%s,32,38,6,308,15,%dH%s,1.0,2,2HMM,,1.0" ,
		strlen( version ) , version ,
		strlen( id ) , id,
		strlen( db_name ) , db_name );

	(void)time( &now );
	timep = localtime( &now );
	bu_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d",
		timep->tm_year+1900,
		timep->tm_mon + 1,
		timep->tm_mday,
		timep->tm_hour,
		timep->tm_min,
		timep->tm_sec );

	bu_vls_printf( &str , ",%g,100000.0,7HUnknown,7HUnknown,9,0" ,
		RT_LEN_TOL );

	if( stat( db_name , &db_stat ) )
	{
		bu_log( "Cannot stat %s\n" , db_name );
		perror( prog_name );
		bu_vls_strcat( &str , ",15H00000101.000000;" );
	}
	else
	{
		timep = localtime( &db_stat.st_mtime );
		bu_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d;",
			timep->tm_year+1900,
			timep->tm_mon + 1,
			timep->tm_mday,
			timep->tm_hour,
			timep->tm_min,
			timep->tm_sec );
d862 1
a862 1
	(void)write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'G' );
d864 1
a864 1
	/* write attribute definition entity */
d866 2
a867 2
	if( mode != TRIMMED_SURF_MODE )
		attribute_de = write_attribute_definition( fp_dir ,  fp_param );
d869 1
a869 1
	bu_vls_free( &str );
d875 16
a890 16
char *name;
struct nmgregion *r;
int dependent;
FILE *fp_dir,*fp_param;
{
	struct nmgregion	*new_r;		/* temporary nmgregion */
	struct shell		*s_new;		/* shell made by nmg_mrsv */
	struct bu_ptbl		vtab;		/* vertex table */
	struct bu_ptbl		etab;		/* edge table */
	struct bu_ptbl		**shells;	/* array of tables of shells */
	int			*brep_de;	/* Directory entry sequence # for BREP Object(s) */
	int			vert_de;	/* Directory entry sequence # for vertex list */
	int			edge_de;	/* Directory entry sequence # for edge list */
	int			outer_shell_count; /* number of outer shells in nmgregion */
	int			face_count=0;	/* number of faces in nmgregion */
	int			i;
d892 1
a892 1
	NMG_CK_REGION( r );
d894 5
a898 5
	{
		struct shell *s;
		for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		{
			struct faceuse *fu;
d900 3
a902 3
			for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
			{
				struct loopuse *lu;
d904 2
a905 2
				if( fu->orientation != OT_SAME )
					continue;
d907 1
a907 1
				face_count++;
d909 3
a911 3
				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					struct edgeuse *eu;
d913 2
a914 2
					if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;
d916 13
a928 3
					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						struct vertex *v;
d930 2
a931 9
						v = eu->vu_p->v_p;
						NMG_CK_VERTEX( v );
						if( !v->vg_p )
							bu_log( "vertex with no geometry!!\n" );
					}
				}
			}
		}
	}
d933 2
a934 2
	if( face_count == 0 )
		return( 0 );
d936 1
a936 2
	/* Find outer shells and void shells and their associations */
	outer_shell_count = nmg_find_outer_and_void_shells( r , &shells , &tol );
d938 1
a938 3
	brep_de = (int *)bu_calloc( outer_shell_count , sizeof( int ) , "nmgregion_to_iges: brep_de" );

	for( i=0 ; i<outer_shell_count ; i++ )
d940 4
a943 4
		int j;
		int tmp_dependent;
		struct shell *s;
		char *tmp_name;
d945 1
a945 1
		if( outer_shell_count == 1 )
d947 4
a950 4
			new_r = r;
			s_new = NULL;
			tmp_name = name;
			tmp_dependent = dependent;
d952 1
a952 1
		else
d954 4
a957 4
			new_r = nmg_mrsv( r->m_p );
			s_new = BU_LIST_FIRST( shell , &new_r->s_hd );
			tmp_name = NULL;
			tmp_dependent = 1;
d959 1
a959 1
			for( j=BU_PTBL_END( shells[i] )-1 ; j >= 0  ; j-- )
d961 2
a962 2
				s = (struct shell *)BU_PTBL_GET( shells[i] , j );
				nmg_mv_shell_to_region( s , new_r );
d964 1
a964 1
			(void)nmg_ks( s_new );
d968 2
a969 2
		/* Make the vertex list entity */
		vert_de = write_vertex_list( new_r , &vtab , fp_dir , fp_param );
d971 2
a972 2
		/* Make the edge list entity */
		edge_de = write_edge_list( new_r , vert_de , &etab , &vtab , fp_dir , fp_param );
d974 2
a975 2
		/* Make the face, loop, shell entities */
		brep_de[i] = write_shell_face_loop( tmp_name , new_r , tmp_dependent , edge_de , &etab , vert_de , &vtab , fp_dir , fp_param );
d977 3
a979 3
		/* Clear the tables */
		(void)bu_ptbl_reset( &vtab );
		(void)bu_ptbl_reset( &etab );
d981 2
a982 2
		if( outer_shell_count != 1 )
			(void)nmg_kr( new_r );
d985 3
a987 3
	/* Free the tables */
	(void)bu_ptbl_free( &vtab );
	(void)bu_ptbl_free( &etab );
d989 4
a992 4
	if( outer_shell_count != 1 )
		return( write_solid_assembly( name, brep_de , outer_shell_count , dependent , fp_dir , fp_param ) );
	else
		return( brep_de[0] );
d997 8
a1004 8
point_t *pts;
int vert_count;
int pt_size;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
d1006 2
a1007 2
	if( vert_count < 2 )
		return( 0 );
d1009 1
a1009 1
	bu_vls_init( &str );
d1011 3
a1013 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d1015 2
a1016 2
	bu_vls_printf( &str , "106,%d,%d" , pt_size-1 , vert_count+1 );
	if( pt_size == 2 )
d1018 4
a1021 4
		bu_vls_printf( &str , ",0.0" );
		for( i=0 ; i<vert_count ; i++ )
			bu_vls_printf( &str , ",%f,%f" , pts[i][0] , pts[i][1] );
		bu_vls_printf( &str , ",%f,%f" , pts[0][0] , pts[0][1] );
d1023 1
a1023 1
	else if( pt_size == 3 )
d1025 3
a1027 3
		for( i=0 ; i<vert_count ; i++ )
			bu_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[i] ) );
		bu_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[0] ) );
d1030 1
a1030 1
	bu_vls_strcat( &str , ";" );
d1032 2
a1033 2
	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;
d1035 2
a1036 2
	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
d1038 4
a1041 4
	/* write directory entry for vertex list entity */
	dir_entry[1] = 106;
	dir_entry[8] = 0;
	if( pt_size == 2 )
d1043 2
a1044 2
		dir_entry[9] = 10500;
		dir_entry[15] = 63;
d1046 1
a1046 1
	else
d1048 2
a1049 2
		dir_entry[9] = 10000;
		dir_entry[15] = 12;
d1051 1
a1051 1
	dir_entry[11] = 106;
d1054 1
a1054 1
	bu_vls_free( &str );
d1056 1
a1056 1
	return( write_dir_entry( fp_dir , dir_entry ));
d1061 14
a1074 14
struct loopuse *lu;
int surf_de;
vect_t u_dir,v_dir;
fastf_t u_max,v_max;
point_t base_pt;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	struct edgeuse		*eu;
	int			vert_count=0;
	point_t			*model_pts;
	point_t			*param_pts;
	int			i;
d1076 1
a1076 1
	NMG_CK_LOOPUSE( lu );
d1078 2
a1079 2
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( 0 );
d1081 3
a1083 3
	/* count vertices */
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		vert_count++;
d1085 2
a1086 2
	if( vert_count < 3 )
		return( 0 );
d1088 3
a1090 3
	/* Allocate memory for points */
	model_pts = (point_t *)bu_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: model_pts" );
	param_pts = (point_t *)bu_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: param_pts" );
d1092 1
a1092 1
	bu_vls_init( &str );
d1094 3
a1096 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d1098 1
a1098 1
	bu_vls_printf( &str , "142,0,%d" , surf_de );
d1100 2
a1101 2
	i = 0;
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1103 3
a1105 3
		struct vertex_g *vg;
		vect_t from_base;
		fastf_t u,v;
d1107 5
a1111 5
		NMG_CK_EDGEUSE( eu );
		NMG_CK_VERTEXUSE( eu->vu_p );
		NMG_CK_VERTEX( eu->vu_p->v_p );
		NMG_CK_VERTEX_G( eu->vu_p->v_p->vg_p );
		vg = eu->vu_p->v_p->vg_p;
d1113 2
a1114 2
		if( i >= vert_count )
			rt_bomb( "nmg_loop_to_tcurve: too many vertices in loop!!!!\n" );
d1116 1
a1116 1
		VMOVE( model_pts[i] , vg->coord );
d1118 12
a1129 12
		VSUB2( from_base , vg->coord , base_pt );
		u = VDOT( u_dir , from_base )/u_max;
		v = VDOT( v_dir , from_base )/v_max;
		if( u < 0.0 )
			u = 0.0;
		if( u > 1.0 )
			u = 1.0;
		if( v < 0.0 )
			v = 0.0;
		if( v > 1.0 )
			v = 1.0;
		VSET( param_pts[i] , u , v , 0.0 );
d1131 1
a1131 1
		i++;
d1134 2
a1135 2
	bu_vls_printf( &str , ",%d" , verts_to_copious_data( param_pts , vert_count , 2 , fp_dir , fp_param ) );
	bu_vls_printf( &str , ",%d,0;" , verts_to_copious_data( model_pts , vert_count , 3 , fp_dir , fp_param ));
d1137 2
a1138 2
	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;
d1140 2
a1141 2
	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
d1143 6
a1148 6
	/* write directory entry for vertex list entity */
	dir_entry[1] = 142;
	dir_entry[8] = 0;
	dir_entry[9] = 10500;
	dir_entry[11] = 142;
	dir_entry[15] = 0;
d1151 1
a1151 1
	bu_vls_free( &str );
d1153 1
a1153 1
	return( write_dir_entry( fp_dir , dir_entry ));
d1158 2
a1159 2
struct faceuse *fu;
FILE *fp_dir,*fp_param;
d1161 10
a1170 10
	struct bu_vls		str;
	int			dir_entry[21];
	struct loopuse		*lu;
	int			surf_de;
	vect_t			u_dir,v_dir;
	fastf_t			u_max,v_max;
	point_t			base_pt;
	int			loop_count=0;
	int			*curve_de;
	int			i;
d1172 1
a1172 1
	NMG_CK_FACEUSE( fu );
d1174 1
a1174 1
	bu_vls_init( &str );
d1176 3
a1178 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d1180 2
a1181 2
	/* count loops */
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1183 1
a1183 1
		NMG_CK_LOOPUSE( lu );
d1185 2
a1186 2
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;
d1188 1
a1188 1
		loop_count++;
d1191 2
a1192 2
	if( loop_count < 1 )	/* nothing to output */
		return;
d1194 2
a1195 2
	/* write underlying surface */
	surf_de = write_planar_nurb( fu , u_dir , v_dir , &u_max , &v_max , base_pt , fp_dir , fp_param );
d1197 2
a1198 2
	/* allocate space to hold DE for each trimming curve */
	curve_de = (int *)bu_calloc( loop_count , sizeof( int ) , "nmg_fu_to_tsurf: curve_de" );
d1200 2
a1201 2
	i = (-1);
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
d1203 2
a1204 2
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;
d1206 1
a1206 1
		curve_de[++i] = nmg_loop_to_tcurve( lu , surf_de , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param );
d1209 4
a1212 4
	bu_vls_printf( &str , "144,%d,0,%d" , surf_de , loop_count-1 );
	for( i=0 ; i<loop_count ; i++ )
		bu_vls_printf( &str , ",%d" , curve_de[i] );
	bu_vls_strcat( &str , ";" );
d1214 1
a1214 1
	bu_free( (char *)curve_de , "nmg_fu_to_tsurf: curve_de" );
d1216 2
a1217 2
	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;
d1219 2
a1220 2
	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
d1222 6
a1227 6
	/* write directory entry for vertex list entity */
	dir_entry[1] = 144;
	dir_entry[8] = 0;
	dir_entry[9] = 0;
	dir_entry[11] = 144;
	dir_entry[15] = 0;
d1229 1
a1229 1
	bu_vls_free( &str );
d1231 1
a1231 1
	(void)write_dir_entry( fp_dir , dir_entry );
d1236 3
a1238 3
char *name;
struct nmgregion *r;
FILE *fp_dir,*fp_param;
d1240 1
a1240 1
	struct shell *s;
d1242 1
a1242 1
	NMG_CK_REGION( r );
d1244 1
a1244 1
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
d1246 1
a1246 1
		struct faceuse *fu;
d1248 2
a1249 2
		NMG_CK_SHELL( s );
		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
d1251 1
a1251 1
			NMG_CK_FACEUSE( fu );
d1253 2
a1254 2
			if( fu->orientation != OT_SAME )
				continue;
d1256 1
a1256 1
			nmg_fu_to_tsurf( fu , fp_dir , fp_param );
d1260 1
a1260 1
	return( -1 );
d1265 51
a1315 18
struct nmgregion *r;
struct bu_ptbl *vtab;   /* vertex table */
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	NMG_CK_REGION( r );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* Built list of vertex structs */
	nmg_vertex_tabulate( vtab, &r->l.magic );
a1316 2
	/* write parameter data for vertex list entity */
	bu_vls_printf( &str , "502,%d" , BU_PTBL_END( vtab  ) );
d1318 1
a1318 32
	for( i=0 ; i<BU_PTBL_END( vtab ) ; i++ ) {
		struct vertex                   *v;
		register struct vertex_g        *vg;

		v = (struct vertex *)BU_PTBL_GET(vtab,i);
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
if( !vg )
	bu_log( "No geometry for vertex x%x #%d in table\n" , v , i );
		NMG_CK_VERTEX_G(vg);
		bu_vls_printf( &str, ",%g,%g,%g",
			vg->coord[X],
			vg->coord[Y],
			vg->coord[Z] );
	}
	bu_vls_strcat( &str , ";" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 502;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 502;
	dir_entry[15] = 1;


	bu_vls_free( &str );
d1320 1
a1320 1
	return( write_dir_entry( fp_dir , dir_entry ));
d1325 38
a1362 10
struct vertex_g	*start_vg;
struct vertex_g	*end_vg;
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	NMG_CK_VERTEX_G( start_vg );
	NMG_CK_VERTEX_G( end_vg );
d1364 1
a1364 27
	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* start with parameter data */
	bu_vls_printf( &str , "110,%g,%g,%g,%g,%g,%g;" ,
			start_vg->coord[X],
			start_vg->coord[Y],
			start_vg->coord[Z],
			end_vg->coord[X],
			end_vg->coord[Y],
			end_vg->coord[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 110;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 110;
	dir_entry[15] = 0;
d1366 1
a1366 3
	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
d1371 38
a1408 38
struct vertex_g	*start_vg;
struct vertex_g	*end_vg;
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	NMG_CK_VERTEX_G( start_vg );
	NMG_CK_VERTEX_G( end_vg );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* start with parameter data */
	bu_vls_printf( &str , "126,1,1,0,0,1,0,0.,0.,1.,1.,1.,1.,%g,%g,%g,%g,%g,%g,0.,1.;" ,
			start_vg->coord[X],
			start_vg->coord[Y],
			start_vg->coord[Z],
			end_vg->coord[X],
			end_vg->coord[Y],
			end_vg->coord[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 126;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 126;
	dir_entry[15] = 1;
d1410 1
a1410 1
	bu_vls_free( &str );
d1412 1
a1412 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d1417 72
a1488 9
struct nmgregion *r;
int vert_de;		/* DE# for vertex list */
struct bu_ptbl *etab;	/* edge table */
struct bu_ptbl *vtab;	/* vertex table (already filled in) */
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;
d1490 1
a1490 1
	NMG_CK_REGION( r );
d1492 1
a1492 64
	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* Build list of edge structures */
	nmg_edge_tabulate( etab , &r->l.magic );

	bu_vls_printf( &str , "504,%d" , BU_PTBL_END( etab ) );

	/* write parameter data for edge list entity */
	for( i=0 ; i<BU_PTBL_END( etab ) ; i++ )
	{
		struct edge			*e;
		struct edgeuse			*eu;
		struct vertexuse		*vu;
		struct vertex			*start_v,*end_v;
		struct vertex_g			*start_vg,*end_vg;
		int				line_de; /* directory entry # for line entity */

		e = (struct edge *)BU_PTBL_GET(etab,i);
		NMG_CK_EDGE(e);
		eu = e->eu_p;
		NMG_CK_EDGEUSE(eu);
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		start_v = vu->v_p;
		NMG_CK_VERTEX(start_v);
		start_vg = start_v->vg_p;
		NMG_CK_VERTEX_G(start_vg);
		vu = eu->eumate_p->vu_p;
		NMG_CK_VERTEXUSE(vu);
		end_v = vu->v_p;
		NMG_CK_VERTEX(end_v);
		end_vg = end_v->vg_p;
		NMG_CK_VERTEX_G(end_vg);
		if( do_nurbs )
			line_de = write_linear_bspline( start_vg , end_vg , fp_dir , fp_param );
		else
			line_de = write_line_entity( start_vg , end_vg , fp_dir , fp_param );
		bu_vls_printf( &str , ",%d,%d,%d,%d,%d",
			line_de,
			vert_de , bu_ptbl_locate( vtab , (long *)start_v ) + 1,
			vert_de , bu_ptbl_locate( vtab , (long *)end_v ) + 1 );
	}
	bu_vls_strcat( &str , ";" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for edge list entity */
	dir_entry[1] = 504;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 504;
	dir_entry[15] = 1;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
d1497 2
a1498 2
point_t pt;
FILE *fp_dir,*fp_param;
d1500 3
a1502 3
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
d1504 2
a1505 2
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d1507 1
a1507 1
	bu_vls_init( &str );
d1509 4
a1512 4
	bu_vls_printf( &str , "116,%g,%g,%g,0;" ,
		pt[X],
		pt[Y],
		pt[Z] );
d1514 2
a1515 2
	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;
d1517 2
a1518 2
	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d1520 5
a1524 5
	dir_entry[1] = 116;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 116;
	dir_entry[15] = 0;
d1526 1
a1526 1
	bu_vls_free( &str );
d1528 1
a1528 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d1533 2
a1534 2
point_t pt;
FILE *fp_dir,*fp_param;
d1536 3
a1538 3
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
d1540 2
a1541 2
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d1543 1
a1543 1
	bu_vls_init( &str );
d1545 4
a1548 4
	bu_vls_printf( &str , "123,%g,%g,%g;" ,
		pt[X],
		pt[Y],
		pt[Z] );
d1550 2
a1551 2
	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;
d1553 2
a1554 2
	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d1556 5
a1560 5
	dir_entry[1] = 123;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 123;
	dir_entry[15] = 0;
d1562 1
a1562 1
	bu_vls_free( &str );
d1564 1
a1564 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d1569 2
a1570 2
plane_t plane;
FILE *fp_dir,*fp_param;
d1572 4
a1575 4
	struct bu_vls	str;
	point_t		pt_on_plane;	/* a point on the plane */
	int		dir_entry[21];
	int		i;
d1577 2
a1578 2
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d1580 1
a1580 1
	bu_vls_init( &str );
d1582 1
a1582 1
	VSCALE( pt_on_plane , plane , plane[3] );
d1584 3
a1586 3
	bu_vls_printf( &str , "190,%d,%d;" ,
		write_point_entity( pt_on_plane , fp_dir , fp_param ),
		write_direction_entity( plane , fp_dir , fp_param ) );
d1588 2
a1589 2
	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;
d1591 2
a1592 2
	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d1594 5
a1598 5
	dir_entry[1] = 190;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 190;
	dir_entry[15] = 0;
d1600 1
a1600 1
	bu_vls_free( &str );
d1602 1
a1602 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d1608 63
a1670 15
struct faceuse *fu;
vect_t u_dir,v_dir;	/* output */
fastf_t *u_max,*v_max;	/* output */
point_t base_pt;	/* output ( point at u,v==0 ) */
FILE *fp_dir;
FILE *fp_param;
{
	struct loopuse		*lu;
	struct edgeuse		*eu,*eu_next;
	struct vertex_g		*vg,*vg_next;
	point_t			ctl_pt;
	fastf_t			umin,umax,vmin,vmax;
	struct bu_vls   	str;
	int           	 	dir_entry[21];
	int             	i;
d1672 1
a1672 49
	NMG_CK_FACEUSE( fu );

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	/* create direction vectors in u and v directions in plane */
	lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
	NMG_CK_LOOPUSE( lu );
	while( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC &&
				BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
	{
		lu = BU_LIST_PNEXT( loopuse , lu );
		NMG_CK_LOOPUSE( lu );
	}
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
	{
		bu_log( "Write_planar_nurb: could not find a loop (with edges) in face\n" );
		return( 0 );
	}

	eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
	NMG_CK_EDGEUSE( eu );
		vg = eu->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg );
	eu_next = BU_LIST_PNEXT( edgeuse , eu );
	NMG_CK_EDGEUSE( eu_next );
	vg_next = eu_next->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg_next );

	VSUB2( u_dir , vg_next->coord , vg->coord );
	VUNITIZE( u_dir );
	VCROSS( v_dir , fu->f_p->g.plane_p->N , u_dir );
	VUNITIZE( v_dir );

	/* find the max and min distances from vg along u_dir and v_dir in the face */
	umin = MAX_FASTF;
	vmin = MAX_FASTF;
	umax = (-umin);
	vmax = (-vmin);

	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
d1674 2
a1675 2
			vect_t	tmp_vect;
			fastf_t	distu,distv;
d1677 1
a1677 1
			NMG_CK_EDGEUSE( eu );
d1679 7
a1685 7
			VSUB2( tmp_vect , eu->vu_p->v_p->vg_p->coord , vg->coord );
			distu = VDOT( tmp_vect , u_dir );
			V_MIN( umin , distu );
			V_MAX( umax , distu );
			distv = VDOT( tmp_vect , v_dir );
			V_MIN( vmin , distv );
			V_MAX( vmax , distv );
d1689 2
a1690 2
	*u_max = umax - umin;
	*v_max = vmax - vmin;
d1692 2
a1693 2
	/* Put preliminary stuff for planar nurb in string */
	bu_vls_printf( &str , "128,1,1,1,1,0,0,1,0,0,0.,0.,1.,1.,0.,0.,1.,1.,1.,1.,1.,1." );
d1695 25
a1719 25
	/* Now put control points in string */
	VJOIN2( ctl_pt , vg->coord , umin , u_dir , vmin , v_dir );
	VMOVE( base_pt , ctl_pt );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN1( ctl_pt , ctl_pt , umax-umin , u_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN2( ctl_pt , vg->coord , umin , u_dir , vmax , v_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN1( ctl_pt , ctl_pt , umax-umin , u_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );

	/* Now put parameter ranges last */
	bu_vls_printf( &str , ",0.,1.,0.,1.;" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 128;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 128;
	dir_entry[15] = 1;
d1721 1
a1721 1
	bu_vls_free( &str );
d1723 1
a1723 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d1729 37
a1765 37
char *name;
struct nmgregion *r;
int dependent;
int edge_de;		/* directory entry # for edge list */
struct bu_ptbl *etab;	/* Table of edge pointers */
int vert_de;		/* directory entry # for vertex list */
struct bu_ptbl *vtab;	/* Table of vertex pointers */
FILE *fp_dir,*fp_param;
{
	struct edgeuse		*eu;
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct shell		*s;
	struct vertex		*v;
	struct bu_vls		str;
	struct iges_properties	props;
	int			*shell_list;
	int			i;
	int			shell_count=0;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;

	NMG_CK_REGION( r );

	bu_vls_init( &str );

	/* count the shells */
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		shell_count++;

	/* make space for the list of shell DE's */
	shell_list = (int *)bu_calloc( shell_count , sizeof( int ) , "write_shell_face_loop: shell_list" );

	shell_count = 0;
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
d1767 2
a1768 2
		int	*face_list;
		int	face_count=0;
d1771 2
a1772 2
		/* Count faces */
		for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
d1774 4
a1777 4
			NMG_CK_FACEUSE(fu);
			if (fu->orientation != OT_SAME)
				continue;
			face_count++;
d1779 2
a1780 2
		face_list = (int *)bu_calloc( face_count , sizeof( int ) , "face_list" );
		face_count = 0;
d1782 2
a1783 2
		/* Shell is made of faces. */
		for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
d1785 4
a1788 4
			int	*loop_list;
			int	loop_count=0;
			int	exterior_loop=(-1);	/* index of outer loop (in loop_list) */
			int	outer_loop_flag=1;	/* IGES flag to indicate a selected outer loop */
d1790 2
a1791 2
			if (fu->orientation != OT_SAME)
				continue;
d1793 2
a1794 2
			/* Count loops */
			for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
d1796 4
a1799 4
				NMG_CK_LOOPUSE(lu);
				if( lu->orientation == OT_SAME )
					exterior_loop = loop_count;
				loop_count++;
d1801 1
a1801 1
			loop_list = (int *)bu_calloc( loop_count , sizeof( int ) , "loop_list" );
d1803 2
a1804 2
			loop_count = 0;
			for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
d1806 1
a1806 1
				int		edge_count=0;
d1808 2
a1809 2
				/* Count edges */
				if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
d1811 1
a1811 1
					for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
d1813 6
a1818 6
						NMG_CK_EDGEUSE(eu);
						NMG_CK_EDGE(eu->e_p);
						NMG_CK_VERTEXUSE(eu->vu_p);
						NMG_CK_VERTEX(eu->vu_p->v_p);
						NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
						edge_count++;
d1821 1
a1821 1
				else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
d1823 4
a1826 4
		  			v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					NMG_CK_VERTEX(v);
					NMG_CK_VERTEX_G(v->vg_p);
		  			edge_count++;
d1828 2
a1829 2
				else
					bu_log("write_shell_face_loop: loopuse mess up! (1)\n");
d1831 1
a1831 1
				bu_vls_printf( &str , "508,%d" , edge_count );
d1833 1
a1833 1
				if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
d1835 1
a1835 1
					for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
d1837 15
a1851 15
						int orientation;
						struct edge *e;
						struct edgeuse *eu_tab;

						e = eu->e_p;
						eu_tab = e->eu_p;
						if( eu_tab->vu_p->v_p == eu->vu_p->v_p )
							orientation = 1;
						else
							orientation = 0;

						bu_vls_printf( &str , ",0,%d,%d,%d,0",
							edge_de ,
							bu_ptbl_locate( etab , (long *)(e)) + 1,
							orientation );
d1853 1
a1853 1
						edge_count++;
d1856 1
a1856 1
				else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
d1858 4
a1861 4
		  			v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					bu_vls_printf( &str , ",1,%d,%d,1,0",
						vert_de,
						bu_ptbl_locate( vtab , (long *)v )+1 );
d1863 3
a1865 1
					bu_log("write_shell_face_loop: loopuse mess up! (2)\n");
d1867 7
a1873 1
				bu_vls_strcat( &str , ";" );
d1875 2
a1876 18
				/* write loop entry */
				/* initialize directory entry */
				for( i=0 ; i<21 ; i++ )
					dir_entry[i] = DEFAULT;

				/* remember where parameter data is going */
				dir_entry[2] = param_seq + 1;

				/* get parameter line count */
				dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

				/* write directory entry for loop entity */
				dir_entry[1] = 508;
				dir_entry[8] = 0;
				dir_entry[9] = 10001;
				dir_entry[11] = 508;
				dir_entry[15] = 1;
				loop_list[loop_count++] = write_dir_entry( fp_dir , dir_entry );
d1878 9
a1886 1
				bu_vls_free( &str );
d1890 1
a1890 1
			if( exterior_loop < 0 )
d1892 2
a1893 2
				bu_log( "No outside loop found for face\n" );
				outer_loop_flag = 0;
d1895 1
a1895 1
			else if( exterior_loop != 0 ) /* move outside loop to start of list */
d1897 1
a1897 1
				int tmp;
d1899 3
a1901 3
				tmp = loop_list[0];
				loop_list[0] = loop_list[exterior_loop];
				loop_list[exterior_loop] = tmp;
d1904 1
a1904 1
			if( do_nurbs )
d1906 8
a1913 8
				vect_t u_dir,v_dir;
				point_t base_pt;
				fastf_t u_max,v_max;

				bu_vls_printf( &str , "510,%d,%d,%d" ,
					write_planar_nurb( fu , u_dir , v_dir , &u_max , &v_max , base_pt , fp_dir , fp_param ),
					loop_count,
					outer_loop_flag );
d1915 5
a1919 5
			else
				bu_vls_printf( &str , "510,%d,%d,%d" ,
					write_plane_entity( fu->f_p->g.plane_p->N , fp_dir , fp_param ),
					loop_count,
					outer_loop_flag );
d1921 2
a1922 2
			for( i=0 ; i<loop_count ; i++ )
				bu_vls_printf( &str , ",%d" , loop_list[i] );
d1924 1
a1924 1
			bu_vls_strcat( &str , ";" );
d1926 2
a1927 2
			for( i=0 ; i<21 ; i++ )
				dir_entry[i] = DEFAULT;
d1929 7
a1935 7
			dir_entry[1] = 510;
			dir_entry[2] = param_seq + 1;
			dir_entry[8] = 0;
			dir_entry[9] = 10001;
			dir_entry[11] = 510;
			dir_entry[15] = 1;
			dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d1937 1
a1937 1
			face_list[face_count++] = write_dir_entry( fp_dir , dir_entry );;
d1939 2
a1940 2
			bu_free( (char *)loop_list , "loop list" );
			bu_vls_free( &str );
d1943 5
a1947 5
		/* write shell entity */
		bu_vls_printf( &str , "514,%d" , face_count );
		for( i=0 ; i<face_count ; i++ )
			bu_vls_printf( &str , ",%d,1" , face_list[i] );
		bu_vls_strcat( &str , ";" );
d1949 3
a1951 3
		/* initialize directory entry */
		for( i=0 ; i<21 ; i++ )
			dir_entry[i] = DEFAULT;
d1953 7
a1959 7
		dir_entry[1] = 514;
		dir_entry[2] = param_seq + 1;
		dir_entry[8] = 0;
		dir_entry[9] = 10001;
		dir_entry[11] = 514;
		dir_entry[15] = 1;
		dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d1961 1
a1961 1
		shell_list[shell_count++] = write_dir_entry( fp_dir , dir_entry );
d1963 2
a1964 2
		bu_free( (char *)face_list , "face list" );
		bu_vls_free( &str );
d1967 1
a1967 1
	/* write BREP object entity */
d1969 5
a1973 5
	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;
d1975 2
a1976 2
	/* write color and attributes entities, if appropriate */
	if( !name || lookup_props( &props , name ) )
d1978 2
a1979 2
		prop_de = 0;
		color_de = 0;
d1981 1
a1981 1
	else
d1983 3
a1985 3
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
d1988 2
a1989 2
	/* Put outer shell in BREP object first */
	bu_vls_printf( &str , "186,%d,1,%d" , shell_list[0] , shell_count-1 );
d1991 2
a1992 2
	/* Add all other shells */
	for( i=1 ; i<shell_count ; i++ )
d1994 1
a1994 1
			bu_vls_printf( &str , ",%d,1" , shell_list[i] );
d1997 1
a1997 1
	if( prop_de || name_de )
d1999 8
a2006 8
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );
d2010 1
a2010 1
	bu_vls_strcat( &str , ";"  );
d2012 3
a2014 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d2016 11
a2026 11
	dir_entry[1] = 186;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 186;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d2028 2
a2029 2
	bu_free( (char *)shell_list , "shell list" );
	bu_vls_free( &str );
d2031 1
a2031 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d2036 1
a2036 1
FILE *fp;
d2038 1
a2038 1
	fprintf( fp , "S%07dG%07dD%07dP%07d%40.40sT0000001\n" , start_len , global_len , dir_seq , param_seq , " " );
d2043 1
a2043 1
struct rt_arb_internal *arb;
d2045 4
a2048 2
	vect_t v0,v1,v2;
	int i;
d2050 4
a2053 1
	RT_ARB_CK_MAGIC( arb );
d2055 6
a2060 50
	/* for an rpp, all the height edge vectors must be equal,
	   all the width edge vectors must be equal, all the
	   depth edge vectors must be equal, and at least one
	   vertex must have three right angles */

	/* check the height vectors */
	VSUB2( v0 , arb->pt[4] , arb->pt[0] );
	for( i=5 ; i<8 ; i++ )
	{
		VSUB2( v1 , arb->pt[i] , arb->pt[i-4] );
		if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	}

	/* check the width vectors */
	VSUB2( v0 , arb->pt[1] , arb->pt[0] );
	VSUB2( v1 , arb->pt[2] , arb->pt[3] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[6] , arb->pt[7] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[5] , arb->pt[4] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );

	/* check the depth vectors */
	VSUB2( v0 , arb->pt[3] , arb->pt[0] );
	VSUB2( v1 , arb->pt[2] , arb->pt[1] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[6] , arb->pt[5] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[7] , arb->pt[4] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );

	/* check for a right angle corner */
	VSUB2( v0 , arb->pt[3] , arb->pt[0] );
	VSUB2( v1 , arb->pt[1] , arb->pt[0] );
	VSUB2( v2 , arb->pt[4] , arb->pt[0] );
	VUNITIZE( v0 );
	VUNITIZE( v1 );
	VUNITIZE( v2 );
	if( !BN_VECT_ARE_PERP( VDOT( v0 , v1 ) , &tol ) )
		return( 0 );
	if( !BN_VECT_ARE_PERP( VDOT( v0 , v2 ) , &tol ) )
		return( 0 );
	if( !BN_VECT_ARE_PERP( VDOT( v1 , v2 ) , &tol ) )
d2062 39
d2102 1
a2102 1
	return( 1 );
d2107 2
a2108 2
char *name;
FILE *fp_dir,*fp_param;
d2110 4
a2113 4
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
	int			name_len;
d2115 3
a2117 3
	name_len = strlen( name );
	if( !name_len )
		return( 0 );
d2119 1
a2119 1
	bu_vls_init( &str );
d2121 24
a2144 24
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write parameter data into a string */
	if( name_len >= NAMESIZE )
		bu_vls_printf( &str , "406,1,16H%16.16s;" , name );
	else
		bu_vls_printf( &str , "406,1,%dH%s;" , strlen( name ) , name );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for name property entity */
	dir_entry[1] = 406;
	dir_entry[8] = 0;
	dir_entry[9] = 1010301;
	dir_entry[11] = 406;
	dir_entry[15] = 15;
	return( write_dir_entry( fp_dir , dir_entry ));
d2149 48
a2196 48
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
{
	struct rt_tor_internal	*tor;
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_TOR )
		bu_log( "tor_to_iges called for non-torus (type=%d)\n" , ip->idb_type );

	tor = (struct rt_tor_internal *)ip->idb_ptr;

	RT_TOR_CK_MAGIC( tor );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write a name entity for this solid */
	name_de = write_name_entity( name , fp_dir , fp_param );

	/* write parameter data into a string */
	bu_vls_printf( &str , "160,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		tor->r_a,
		tor->r_h,
		tor->v[X] , tor->v[Y] , tor->v[Z],
		tor->h[X] , tor->h[Y] , tor->h[Z],
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for torus entity */
	dir_entry[1] = 160;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 160;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));
d2202 49
a2250 49
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_ell_internal	*sph;
	struct bu_vls		str;
	double			radius;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_SPH )
		bu_log( "sph_to_iges called for non-sph (type=%d)\n" , ip->idb_type );

	sph = (struct rt_ell_internal *)ip->idb_ptr;

	RT_ELL_CK_MAGIC( sph );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	radius = MAGNITUDE( sph->a );

	/* write parameter data into a string */
	bu_vls_printf( &str , "158,%g,%g,%g,%g,0,1,%d;",
		radius,
		sph->v[X] , sph->v[Y] , sph->v[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for sphere entity */
	dir_entry[1] = 158;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 158;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));
d2256 66
a2321 66
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_ell_internal	*ell;
	struct bu_vls		str;
	double			radius_a;
	double			radius_b;
	double			radius_c;
	vect_t			a_dir;
	vect_t			b_dir;
	vect_t			c_dir;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_ELL )
		bu_log( "ell_to_iges called for non-ell (type=%d)\n" , ip->idb_type );

	ell = (struct rt_ell_internal *)ip->idb_ptr;

	RT_ELL_CK_MAGIC( ell );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	radius_a = MAGNITUDE( ell->a );
	radius_b = MAGNITUDE( ell->b );
	radius_c = MAGNITUDE( ell->c );

	VMOVE( a_dir , ell->a );
	VMOVE( b_dir , ell->b );
	VMOVE( c_dir , ell->c );

	VUNITIZE( a_dir );
	VUNITIZE( b_dir );
	VUNITIZE( c_dir );

	/* write parameter data into a string */
	bu_vls_printf( &str , "168,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		radius_a , radius_b , radius_c ,
		ell->v[X] , ell->v[Y] , ell->v[Z] ,
		a_dir[X] , a_dir[Y] , a_dir[Z] ,
		c_dir[X] , c_dir[Y] , c_dir[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for ellipsoid entity */
	dir_entry[1] = 168;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 168;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));
d2326 82
a2407 82
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_arb_internal	*arb;
	struct bu_vls		str;
	double			length_a;
	double			length_b;
	double			length_c;
	vect_t			a_dir;
	vect_t			b_dir;
	vect_t			c_dir;
	vect_t			tmp_dir;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_ARB8 )
		bu_log( "rpp_to_iges called for non-arb (type=%d)\n" , ip->idb_type );

	arb = (struct rt_arb_internal *)ip->idb_ptr;

	RT_ARB_CK_MAGIC( arb );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	VSUB2( a_dir , arb->pt[1] , arb->pt[0] );
	VSUB2( b_dir , arb->pt[3] , arb->pt[0] );
	VSUB2( c_dir , arb->pt[4] , arb->pt[0] );

	length_a = MAGNITUDE( a_dir );
	length_b = MAGNITUDE( b_dir );
	length_c = MAGNITUDE( c_dir );

	VUNITIZE( a_dir );
	VUNITIZE( b_dir );
	VUNITIZE( c_dir );

	/* c_dir cross a_dir must give b_dir for IGES */
	VCROSS( tmp_dir , c_dir , a_dir );
	if( VDOT( b_dir , tmp_dir ) < 0.0 )
	{
		/* not a right-handed system, so exchange a_dir with c_dir */
		double tmp_length;

		VMOVE( tmp_dir , a_dir );
		VMOVE( a_dir , c_dir );
		VMOVE( c_dir , tmp_dir );
		tmp_length = length_a;
		length_a = length_c;
		length_c = tmp_length;
	}

	/* write parameter data into a string */
	bu_vls_printf( &str , "150,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		length_a , length_b , length_c ,
		arb->pt[0][X] , arb->pt[0][Y] , arb->pt[0][Z] ,
		a_dir[X] , a_dir[Y] , a_dir[Z] ,
		c_dir[X] , c_dir[Y] , c_dir[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for block entity */
	dir_entry[1] = 150;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 150;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));
d2412 3
a2414 3
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
d2416 1
a2416 1
	struct rt_arb_internal *arb;
d2418 1
a2418 1
	if( ip->idb_type != ID_ARB8 )
d2420 2
a2421 2
		bu_log( "arb_to_iges called for non-arb (type=%d)\n" , ip->idb_type );
		return( 0 );
d2424 1
a2424 1
	arb = (struct rt_arb_internal *)ip->idb_ptr;
d2426 1
a2426 1
	RT_ARB_CK_MAGIC( arb );
d2428 4
a2431 4
	if( arb_is_rpp( arb ) )
		return( rpp_to_iges( ip , name , fp_dir , fp_param ) );
	else
		return( nmg_to_iges( ip , name , fp_dir , fp_param ) );
d2436 3
a2438 3
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
d2440 8
a2447 8
	struct rt_tgc_internal	*tgc;
	fastf_t			h_len,a_len,b_len,c_len,d_len;
	vect_t			h_dir,a_dir,b_dir;
	int			iges_type;
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			i;
d2449 1
a2449 1
	if( ip->idb_type != ID_TGC )
d2451 2
a2452 2
		bu_log( "tgc_to_iges called for non-tgc (type=%d)\n" , ip->idb_type );
                return( 0 );
d2455 1
a2455 1
	tgc = (struct rt_tgc_internal *)ip->idb_ptr;
d2457 1
a2457 1
        RT_TGC_CK_MAGIC( tgc );
d2459 5
a2463 5
	h_len = MAGNITUDE( tgc->h );
	a_len = MAGNITUDE( tgc->a );
	b_len = MAGNITUDE( tgc->b );
	c_len = MAGNITUDE( tgc->c );
	d_len = MAGNITUDE( tgc->d );
d2465 2
a2466 2
	/* Use VSCALE rather than VUNITIZE, since we have
	   already done the sqrt */
d2468 2
a2469 2
	VMOVE( h_dir , tgc->h );
	VSCALE( h_dir , h_dir , 1.0/h_len );
d2471 2
a2472 2
	VMOVE( a_dir , tgc->a );
	VSCALE( a_dir , a_dir , 1.0/a_len );
d2474 2
a2475 2
	VMOVE( b_dir , tgc->b );
	VSCALE( b_dir , b_dir , 1.0/b_len );
d2477 2
a2478 2
	if( !BN_VECT_ARE_PERP( VDOT( h_dir , a_dir ) , &tol ) ||
	    !BN_VECT_ARE_PERP( VDOT( h_dir , b_dir ) , &tol ) )
d2480 2
a2481 2
		/* this is not an rcc or a trc */
		return( nmg_to_iges( ip , name , fp_dir , fp_param ));
d2484 2
a2485 2
	if( NEAR_ZERO( a_len-b_len , tol.dist ) &&
	    NEAR_ZERO( c_len-d_len , tol.dist ) )
d2487 1
a2487 1
		/* this tgc is either an rcc or a trc */
d2489 2
a2490 2
		/* write name entity */
		name_de = write_name_entity( name , fp_dir , fp_param );
d2492 1
a2492 1
		bu_vls_init( &str );
d2494 3
a2496 3
		/* initialize directory entry */
		for( i=0 ; i<21 ; i++ )
			dir_entry[i] = DEFAULT;
d2498 1
a2498 1
		if( NEAR_ZERO( a_len-c_len , tol.dist ) )
d2500 6
a2505 6
			/* its an rcc */
			iges_type = 154;
			bu_vls_printf( &str , "154,%g,%g,%g,%g,%g,%g,%g,%g" ,
				h_len , a_len ,
				tgc->v[X] , tgc->v[Y] , tgc->v[Z] ,
				h_dir[X] , h_dir[Y] , h_dir[Z] );
d2507 1
a2507 1
		else
d2509 1
a2509 1
			/* its a trc */
d2511 2
a2512 2
			fastf_t bigger_r,smaller_r;
			vect_t base;
d2514 2
a2515 2
			iges_type = 156;
			if( a_len > c_len )
d2517 3
a2519 3
				bigger_r = a_len;
				smaller_r = c_len;
				VMOVE( base , tgc->v );
d2521 1
a2521 1
			else
d2523 4
a2526 4
				bigger_r = c_len;
				smaller_r = a_len;
				VADD2( base , tgc->v , tgc->h );
				VREVERSE( h_dir , h_dir );
d2528 4
a2531 4
			bu_vls_printf( &str , "156,%g,%g,%g,%g,%g,%g,%g,%g,%g" ,
				h_len , bigger_r , smaller_r ,
				base[X] , base[Y] , base[Z] ,
				h_dir[X] , h_dir[Y] , h_dir[Z] );
d2534 1
a2534 1
		bu_vls_printf( &str , ",0,1,%d;" , name_de );
d2536 2
a2537 2
		/* remember where parameter data is going */
		dir_entry[2] = param_seq + 1;
d2539 10
a2548 10
		/* get parameter line count */
		dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
		bu_vls_free( &str );

		/* fill in directory entry */
		dir_entry[1] = iges_type;
		dir_entry[8] = 0;
		dir_entry[9] = 10001;
		dir_entry[11] = iges_type;
		dir_entry[15] = 0;
d2550 1
a2550 1
		return( write_dir_entry( fp_dir , dir_entry ));
d2552 2
a2553 2
	else
		return( nmg_to_iges( ip , name , fp_dir , fp_param ));
d2558 14
a2571 14
char *name;
int de_list[];
int length;
int dependent;
FILE *fp_dir;
FILE *fp_param;
{
	struct bu_vls		str;
	struct iges_properties	props;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;
	int			i;
d2573 1
a2573 1
	bu_vls_init( &str );
d2575 5
a2579 5
	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;
d2581 2
a2582 2
	/* write color and attributes entities, if appropriate */
	if( lookup_props( &props , name ) )
d2584 2
a2585 2
		prop_de = 0;
		color_de = 0;
d2587 1
a2587 1
	else
d2589 3
a2591 3
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
d2594 4
a2597 4
	/* write parameter data into a string */
	bu_vls_printf( &str , "180,%d,%d" , 2*length-1 , -de_list[0] );
	for( i=1 ; i<length ; i++ )
		bu_vls_printf( &str , ",%d,1" , -de_list[i] );
d2599 1
a2599 1
	if( prop_de || name_de )
d2601 8
a2608 8
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );
d2612 1
a2612 1
	bu_vls_strcat( &str , ";"  );
d2614 3
a2616 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d2618 11
a2628 11
	dir_entry[1] = 180;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 180;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d2630 1
a2630 1
	bu_vls_free( &str );
d2632 1
a2632 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d2637 22
a2658 53
char *name;
int de_list[];
int length;
int dependent;
FILE *fp_dir;
FILE *fp_param;
{
	struct bu_vls		str;
	struct iges_properties	props;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;
	int			i;

	bu_vls_init( &str );

	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;

	/* write color and attributes entities, if appropriate */
	if( lookup_props( &props , name ) )
	{
		prop_de = 0;
		color_de = 0;
	}
	else
	{
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
	}

	/* write parameter data into a string */
	bu_vls_printf( &str , "184,%d" , length );
	for( i=0 ; i<length ; i++ )
		bu_vls_printf( &str , ",%d" , de_list[i] );
	for( i=0 ; i<length ; i++ )
		bu_vls_printf( &str , ",0" );

	if( prop_de || name_de )
	{
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );
d2660 11
d2673 6
a2678 1
	bu_vls_strcat( &str , ";"  );
d2680 14
a2693 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d2695 3
a2697 11
	dir_entry[1] = 184;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 184;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d2699 11
a2709 1
	bu_vls_free( &str );
d2711 3
a2713 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d2718 11
a2728 11
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
{
	struct model *model;
	struct nmgregion *r;
	int region_count;
	int *region_de;
	int brep_de;
	int dependent;
	int i;
d2730 1
a2730 1
	RT_CK_DB_INTERNAL( ip );
d2732 2
a2733 2
	dependent = 1;
	for( i=0 ; i<no_of_indeps ; i++ )
d2735 1
a2735 1
		if( !strncmp( name , independent[i] , NAMESIZE ) )
d2737 2
a2738 2
			dependent = 0;
			break;
d2742 10
a2751 10
	solid_is_brep = 1;
	comb_form = 1;
	if( ip->idb_type == ID_NMG )
	{
		model = (struct model *)ip->idb_ptr;
		NMG_CK_MODEL( model );

		/* count the number of nmgregions */
		region_count = 0;
		for( BU_LIST_FOR( r , nmgregion , &model->r_hd ) )
d2753 2
a2754 2
			NMG_CK_REGION( r );
			region_count++;
d2757 6
a2762 6
		if( region_count == 0 )
			return( 0 );
		else if( region_count == 1 )
			return( nmgregion_to_iges( name , BU_LIST_FIRST( nmgregion , &model->r_hd ) ,
				dependent , fp_dir , fp_param ) );
		else
d2764 1
a2764 1
			/* make a boolean tree unioning all the regions */
d2766 2
a2767 2
			/* space to save the iges location of each nmgregion */
			region_de = (int *)bu_calloc( region_count , sizeof( int ) , "nmg_to_iges" );
d2769 9
a2777 9
			/* loop through all nmgregions in the model */
			region_count = 0;
			for( BU_LIST_FOR( r , nmgregion , &model->r_hd ) )
				region_de[region_count++] = nmgregion_to_iges( (char *)NULL , r , 1 ,
						fp_dir , fp_param );

			/* now make the boolean tree */
			brep_de = write_tree_of_unions( name , region_de , region_count ,
						dependent , fp_dir , fp_param );
d2779 2
a2780 2
			bu_free( (char *)region_de , "nmg_to_iges" );
			return( brep_de );
d2783 1
a2783 1
	else
d2785 1
a2785 1
		if( ip->idb_type == ID_BOT )
d2787 2
a2788 2
			struct rt_bot_internal *bot=(struct rt_bot_internal *)ip->idb_ptr;
			if( bot->mode != RT_BOT_SOLID )
d2790 2
a2791 2
				bu_log( "%s is a plate mode primitive, and cannot be converted to IGES format!!!\n", name );
				return( 0 );
d2794 2
a2795 2
		model = nmg_mm();
		if( rt_functab[ip->idb_type].ft_tessellate( &r , model , ip , &ttol , &tol ) )
d2797 2
a2798 2
			nmg_km( model );
			return( 0 );
d2800 1
a2800 1
		else
d2802 4
a2805 4
			solids_to_nmg++;
			brep_de =  nmgregion_to_iges( name , r , dependent , fp_dir , fp_param );
			nmg_km( model );
			return( brep_de );
d2812 3
a2814 3
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
d2816 1
a2816 1
	return( 0 );
d2821 2
a2822 2
mat_t mat;
FILE *fp_dir,*fp_param;
d2824 3
a2826 3
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
d2828 1
a2828 1
	bu_vls_init( &str );
d2830 3
a2832 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;
d2834 3
a2836 3
	/* write parameter data into a string */
	bu_vls_strcpy( &str , "124"  );
	for( i=0 ; i<12 ; i++ )
d2838 1
a2838 1
		bu_vls_printf( &str , ",%g" , mat[i] );
d2840 1
a2840 1
	bu_vls_strcat( &str , ";" );
d2842 7
a2848 7
	dir_entry[1] = 124;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 124;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d2850 1
a2850 1
	bu_vls_free( &str );
d2852 1
a2852 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d2857 3
a2859 3
int orig_de;
mat_t mat;
FILE *fp_dir,*fp_param;
d2861 3
a2863 3
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
d2865 1
a2865 1
	bu_vls_init( &str );
d2867 3
a2869 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;
d2871 2
a2872 2
	/* write the transformation matrix and make the link */
	dir_entry[7] = write_xform_entity( mat , fp_dir , fp_param );
d2874 2
a2875 2
	/* write parameter data into a string */
	bu_vls_printf( &str , "430,%d;" , orig_de );
d2877 7
a2883 7
	dir_entry[1] = 430;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 430;
	dir_entry[15] = solid_is_brep ? 1 : 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d2885 1
a2885 1
	bu_vls_free( &str );
d2887 1
a2887 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d2892 2
a2893 2
struct iges_properties *props;
FILE *fp_dir,*fp_param;
d2895 51
a2945 51
	struct bu_vls		str;
	int			dir_entry[21];
	int			str_len;
	int			i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write parameter data into a string */
	bu_vls_strcpy( &str , "422" );

	/* material name */
	str_len = strlen( props->material_name );
	if( str_len )
		bu_vls_printf( &str , ",%dH%s" , str_len , props->material_name );
	else
		bu_vls_strcat( &str , "," );

	/* material parameters */
	str_len = strlen( props->material_params );
	if( str_len )
		bu_vls_printf( &str , ",%dH%s" , str_len , props->material_params );
	else
		bu_vls_strcat( &str , "," );

	/* region flag */
	if( props->region_flag == 'R' )
		bu_vls_strcat( &str , ",1" );
	else
		bu_vls_strcat( &str , ",0" );

	/* ident number, air code, material code, los density */
	bu_vls_printf( &str , ",%d,%d,%d,%d,%d,%d;" ,
		props->ident ,
		props->air_code ,
		props->material_code ,
		props->los_density,
		props->inherit,
		props->color_defined );

	dir_entry[1] = 422;
	dir_entry[2] = param_seq + 1;
	dir_entry[3] = (-attribute_de);
	dir_entry[8] = 0;
	dir_entry[9] = 10301;
	dir_entry[11] = 422;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d2947 1
a2947 1
	bu_vls_free( &str );
d2949 1
a2949 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d2958 12
a2969 12
struct iges_properties *props;
int dependent;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			props_de;
	int			color_de=DEFAULT;
	int			status=1;
	int			i;
d2971 15
a2985 3
	/* if member has not been converted, don't try to write the tree */
	if( de_pointers[0] == 0  )
		return( 0 );
d2987 2
a2988 2
	if( dependent )
		status = 10001;
d2990 5
a2994 1
	bu_vls_init( &str );
d2996 2
a2997 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d2999 10
a3008 2
	/* write name entity */
	name_de = write_name_entity( props->name , fp_dir , fp_param );
d3010 2
a3011 2
	/* write attributes entity */
	props_de = write_att_entity( props , fp_dir , fp_param );
d3013 8
a3020 31
	/* get color */
	if( props->color_defined )
		color_de = get_color( props->color , fp_dir , fp_param );
	else
		color_de = 0;

	/* write parameter data into a string */
	bu_vls_printf( &str , "430,%d" , de_pointers[0] );

	if( props_de || name_de )
	{
		if( props_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( props_de )
			bu_vls_printf( &str , ",%d" , props_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}
	bu_vls_strcat( &str , ";" );

	dir_entry[1] = 430;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = status;
	dir_entry[11] = 430;
	dir_entry[13] = color_de;
	dir_entry[15] = comb_form;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d3022 1
a3022 1
	bu_vls_free( &str );
d3024 1
a3024 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d3030 1
a3030 1
union tree *tp;
d3032 1
a3032 1
	int count=0;
d3034 1
a3034 1
	RT_CK_TREE( tp );
d3036 1
a3036 1
	switch( tp->tr_op )
d3038 9
a3046 9
		case OP_INTERSECT:
		case OP_SUBTRACT:
			count++;
		case OP_UNION:
			count += count_non_union_ops( tp->tr_b.tb_left );
			count += count_non_union_ops( tp->tr_b.tb_right );
			break;
		default:
			break;
d3049 1
a3049 1
	return( count );
d3054 32
a3085 32
struct bu_vls *str;
union tree *tp;
int length;
int *de_pointers;
{
	RT_CK_TREE( tp );
	BU_CK_VLS( str );

	switch( tp->tr_op )
	{
		case OP_UNION:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",1" );
			break;
		case OP_INTERSECT:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",2" );
			break;
		case OP_SUBTRACT:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",3" );
			break;
		case OP_DB_LEAF:
			bu_vls_printf( str, ",%d", -de_pointers[de_pointer_number] );
			de_pointer_number++;
			break;
		default:
			bu_log( "Unrecognized operation in combination!!\n" );
			break;
d3091 4
a3094 4
struct bu_vls *str;
struct rt_comb_internal *comb;
int length;
int *de_pointers;
d3096 2
a3097 2
	BU_CK_VLS( str );
	RT_CK_COMB( comb );
d3099 1
a3099 1
	bu_vls_printf( str , "180,%d", 2*length-1 );
d3101 2
a3102 2
	de_pointer_number = 0;
	igs_tree( str, comb->tree, length, de_pointers );
d3107 18
a3124 18
struct rt_comb_internal *comb;
int length,dependent;
struct iges_properties *props;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			actual_length=0;
	int			name_de;
	int			props_de;
	int			color_de=DEFAULT;
	int			non_union_count=0;
	int			status=1;
	int			entity_type;
	int			i;

	RT_CK_COMB( comb );
d3126 2
a3127 2
	/* if any part of this tree has not been converted, don't try to write the tree */
	for( i=0 ; i<length ; i++ )
d3129 2
a3130 2
		if( de_pointers[i] )
			actual_length++;
d3132 2
a3133 2
	if( actual_length != length )
		return( 0 );
d3135 2
a3136 2
	if( dependent )
		status = 10001;
d3138 1
a3138 1
	bu_vls_init( &str );
d3140 3
a3142 3
	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;
d3144 2
a3145 2
	/* write name entity */
	name_de = write_name_entity( props->name , fp_dir , fp_param );
d3147 2
a3148 2
	/* write attributes entity */
	props_de = write_att_entity( props , fp_dir , fp_param );
d3150 5
a3154 5
	/* get color */
	if( props->color_defined )
		color_de = get_color( props->color , fp_dir , fp_param );
	else
		color_de = 0;
d3156 1
a3156 1
	non_union_count = count_non_union_ops( comb->tree );
d3158 1
a3158 1
	if( mode == CSG_MODE || non_union_count )
d3160 3
a3162 3
		/* write the combination as a Boolean tree */
		entity_type = 180;
		write_igs_tree( &str, comb, length, de_pointers );
d3164 1
a3164 1
	else
d3166 2
a3167 2
		/* write the combination as a solid assembly */
		entity_type = 184;
d3169 5
a3173 5
		bu_vls_printf( &str , "%d,%d" , entity_type , length );
		for( i=0 ; i<length ; i++ )
			bu_vls_printf( &str , ",%d" , de_pointers[i] );
		for( i=0 ; i<length ; i++ )
			bu_vls_strcat( &str , ",0" );
d3176 1
a3176 1
	if( props_de || name_de )
d3178 20
a3197 20
		if( props_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( props_de )
			bu_vls_printf( &str , ",%d" , props_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}
	bu_vls_strcat( &str , ";" );

	dir_entry[1] = entity_type;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = status;
	dir_entry[11] = entity_type;
	dir_entry[13] = color_de;
	dir_entry[15] = comb_form;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );
d3199 1
a3199 1
	bu_vls_free( &str );
d3201 1
a3201 1
	return( write_dir_entry( fp_dir , dir_entry ) );
d3207 12
a3218 12
struct rt_comb_internal *comb;
int length,dependent;
struct iges_properties *props;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	RT_CK_COMB( comb );

	if( length == 1 )
		return( short_comb_to_iges( props , dependent , de_pointers , fp_dir , fp_param ) );
	else
		return( tree_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param ) );
@


1.2
log
@fix relative include paths after the move to src/conv (thanks dtr)
@
text
@d4 1
a4 1
 * Copyright (C) 1993-2005 United States Government as represented by
d48 1
a48 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/iges/iges.c,v 1.1 2005/10/27 03:44:49 brlcad Exp $";
@


1.2.2.1
log
@file iges.c was added on branch rel-7-6-branch on 2005-11-13 17:45:00 +0000
@
text
@d1 3228
@


1.2.2.2
log
@more merging changes from HEAD aka rel-7-6-4 to the rel-7-6-branch, adding the items that were moved and resolving rcs keyword conflicts
@
text
@a0 3228
/*                          I G E S . C
 * BRL-CAD
 *
 * Copyright (C) 1993-2005 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
 * information.
 */
/** @@file iges.c
 *
 *  Code to support the g-iges converter
 *
 *  Author -
 *	John R. Anderson
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
 */

/*	Yet to do:
 *

 *		Utilize the IGES Right Angle Wedge entity (may not be worth the effort):
 *			1. arb_is_raw()
 *			2. raw_to_iges()
 *			3. modify arb_to_iges to use above
 *
 *		How to handle half-space solids????
 *
 *		How to handle xforms with scale factors?????
 */

#ifndef lint
static const char RCSid[] = "$Header$";
#endif

#include "common.h"



#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "machine.h"
#include "vmath.h"
#include "rtlist.h"
#include "rtstring.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./iges.h"
#include "../../librt/debug.h"

/* define defaulted entry for directory entry array */
#define	DEFAULT	(-99999)

extern int	verbose;
static int	solids_to_nmg=0;/* Count of solids that were converted to nmg's in CSG mode */
static int	dir_seq=0;	/* IGES file directory section sequence number */
static int	param_seq=0;	/* IGES file parameter section sequence number */
static int	start_len=0;	/* Length of Start Section */
static int	global_len=0;	/* Length of Global Section */
static int	attribute_de;	/* DE of attribute definition entity */
static char	*global_form="%-72.72s%c%07d\n"; /* format for global section */
static char	*param_form="%-64.64s %7d%c%07d\n"; /* format for parameter section */
static char	*att_string="BRLCAD attribute definition:material name,material parameters,region flag,ident number,air code,material code (GIFT),los density,inheritance";
static struct bn_tol tol;	/* tolerances */
static struct rt_tess_tol ttol;	/* tolerances */
static struct db_i *dbip=NULL;
static char	*unknown="Unknown";
static int	unknown_count=0;
static int	de_pointer_number;
extern char	**independent;
extern int	no_of_indeps;
extern int	solid_is_brep;
extern int	comb_form;
extern int	do_nurbs;
extern int	mode;

BU_EXTERN( int write_freeform, ( FILE *fp, char s[], int de, char c ) );
BU_EXTERN( int write_dir_entry, ( FILE *fp, int entry[] ) );
BU_EXTERN( int write_vertex_list, ( struct nmgregion *r, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_edge_list, ( struct nmgregion *r, int vert_de, struct bu_ptbl *etab, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_shell_face_loop, ( char *name, struct nmgregion *r, int dependent, int edge_de, struct bu_ptbl *etab, int vert_de, struct bu_ptbl *vtab, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_solid_assembly, ( char *name, int de_list[], int length, int dependent, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_planar_nurb, ( struct faceuse *fu, vect_t u_dir, vect_t v_dir, fastf_t *u_max, fastf_t *v_max, point_t base_pt, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_name_entity, ( char *name, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int write_att_entity, ( struct iges_properties *props, FILE *fp_dir, FILE *fp_param ) );
BU_EXTERN( int nmg_to_iges, ( struct rt_db_internal *ip, char *name, FILE *fp_dir, FILE *fp_param ) );

#define		NO_OF_TYPES	31
static int	type_count[NO_OF_TYPES][2]={
			{ 106 , 0 },	/* Copious Data */
			{ 110 , 0 },	/* Line */
			{ 116 , 0 },	/* Point */
			{ 123 , 0 },	/* Direction */
			{ 124 , 0 },	/* Transformation Matrix */
			{ 126 , 0 },	/* Rational B-spline Curve */
			{ 128 , 0 },	/* Rational B-spline Surface */
			{ 142 , 0 },	/* Curve on a Parametric Surface */
			{ 144 , 0 },	/* Trimmed Surface */
			{ 150 , 0 },	/* Block */
			{ 152 , 0 },	/* Right Angle Wedge */
			{ 154 , 0 },	/* Right Circular Cylinder */
			{ 156 , 0 },	/* Right Circular Cone Frustum */
			{ 158 , 0 },	/* Sphere */
			{ 160 , 0 },	/* Torus */
			{ 164 , 0 },	/* Solid of Linear Extrusion */
			{ 168 , 0 },	/* Ellipsoid */
			{ 180 , 0 },	/* Boolean Tree */
			{ 184 , 0 },	/* Solid Assembly */
			{ 186 , 0 },	/* Manifold Solid BREP Object */
			{ 190 , 0 },	/* Plane Surface */
			{ 314 , 0 },	/* Color */
			{ 322 , 0 },	/* Attribute Table Definition */
			{ 406 , 0 },	/* Property Entity */
			{ 422 , 0 },	/* Attribute Table Instance */
			{ 430 , 0 },	/* Solid Instance */
			{ 502 , 0 },	/* Vertex List */
			{ 504 , 0 },	/* Edge List */
			{ 508 , 0 },	/* Loop */
			{ 510 , 0 },	/* Face */
			{ 514 , 0 }	/* Shell */
		};

static char	*type_label[NO_OF_TYPES]={
			"CopiusDa",
			"Line",
			"Point",
			"Directin",
			"Matrix",
			"B-spline",
			"NURB",
			"TrimCurv",
			"TrimSurf",
			"Block",
			"RA Wedge",
			"RC Cylin",
			"RC Frust",
			"Sphere",
			"Torus",
			"Extruson",
			"Ellipsod",
			"BoolTree",
			"Assembly",
			"BREP Obj",
			"PlaneSur",
			"Color",
			"Att Def",
			"Property",
			"Att Inst",
			"SolInst",
			"VertList",
			"EdgeList",
			"Loop",
			"Face",
			"Shell"
		};

static char	*type_name[NO_OF_TYPES]={
			"Copious Data",
			"Line",
			"Point",
			"Direction",
			"Transformation Matrix",
			"Rational B_spline Curve",
			"NURB Surface",
			"Curve on a Parametric Surface",
			"Trimmed Surface",
			"Block",
			"Right Angle Wedge",
			"Right Circular Cylinder",
			"Right Circular Cone Frustum",
			"Sphere",
			"Torus",
			"Linear Sketch Extrusion",
			"Ellipsoid",
			"Boolean Tree",
			"Assembly Primitive",
			"Manifold Boundary Representation",
			"Plane Surface",
			"Color Definition",
			"Attribute Table Definition",
			"Property Entity",
			"Attribute Table Instance",
			"Primitive Instance",
			"Vertex List",
			"Edge List",
			"Loop",
			"Face",
			"Shell"
		};

static unsigned char colortab[9][4]={
	{ 0 , 217 , 217 , 217 }, /* index 0 actually represents an undefined color */
	{ 1 ,   0 ,   0 ,   0 },
	{ 2 , 255 ,   0 ,   0 },
	{ 3 ,   0 , 255 ,   0 },
	{ 4 ,   0 ,   0 , 255 },
	{ 5 , 255 , 255 ,   0 },
	{ 6 , 255 ,   0 , 255 },
	{ 7 ,   0 , 255 , 255 },
	{ 8 , 255 , 255 , 255 }};


void
nmg_to_winged_edge( r )
struct nmgregion *r;
{
	struct shell *s;

	NMG_CK_REGION( r );

	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct faceuse *fu;

		NMG_CK_SHELL( s );
		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
			struct loopuse *lu;

			NMG_CK_FACEUSE( fu );
			if( fu->orientation != OT_SAME )
				continue;

			for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
			{
				struct edgeuse *eu1,*eu2;

				NMG_CK_LOOPUSE( lu );
				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
					continue;

				for( BU_LIST_FOR( eu1 , edgeuse , &lu->down_hd ) )
				{
					struct edgeuse *eu_new;
					struct vertex *v1=NULL,*v2=NULL;

					NMG_CK_EDGEUSE( eu1 );
					if( eu1->radial_p == eu1->eumate_p )
						continue;	/* dangling edge (?warning?) */

					if( eu1->radial_p->eumate_p->radial_p == eu1->eumate_p )
						continue;	/* winged edge */

					/* this edge has more than two radial faces
					 * find the other face from this shell
					 */
					eu2 = eu1->radial_p;
					while( eu2 != eu1 && eu2 != eu1->eumate_p
						&& nmg_find_s_of_eu( eu2 ) != s )
							eu2 = eu2->eumate_p->radial_p;

					/* unglue edge eu1 */
					nmg_unglueedge( eu1 );

					/* Make a new edge */
					eu_new = nmg_me( v1 , v2 , s );

					/* Give the endpoints the same coordinates as the originbal edge */
					nmg_vertex_gv( eu_new->vu_p->v_p , eu1->vu_p->v_p->vg_p->coord );
					nmg_vertex_gv( eu_new->eumate_p->vu_p->v_p , eu1->eumate_p->vu_p->v_p->vg_p->coord );

					/* Move edgeuses to the new vertices */
					nmg_movevu( eu1->vu_p , eu_new->vu_p->v_p );
					nmg_movevu( eu1->eumate_p->vu_p , eu_new->eumate_p->vu_p->v_p );

					/* kill the new edge (I only wanted it for its vertices) */
					if( nmg_keu( eu_new ) )
						rt_bomb( "nmg_to_winged_edge: Can't happen nmg_keu resulted in empty shell!!!!\n" );

					/* move the other edgeuse to the same edge */
					if( eu2 == eu1 || eu2 == eu1->eumate_p )
						bu_log( "nmg_to_winged_edge: couldn't find second radial face for eu x%x in shell x%x\n" , eu1 , s );
					else
						nmg_moveeu( eu1 , eu2 );
				}
			}
		}
	}
}

void
get_props( props , comb )
struct iges_properties *props;
struct rt_comb_internal *comb;
{
	char *endp;

	RT_CK_COMB( comb );

	endp = strchr( bu_vls_addr(&comb->shader), ' ' );
	bzero( props->material_name, 32 );
	bzero( props->material_params, 60 );
	if( endp )  {
		int	len;
		len = endp - bu_vls_addr(&comb->shader);
		if( len > 31 ) len = 31;
		strncpy( props->material_name, bu_vls_addr(&comb->shader), len );
		strncpy( props->material_params, endp+1, 59 );
	} else {
		strncpy( props->material_name, bu_vls_addr(&comb->shader), 31 );
		props->material_params[0] = '\0';
	}
	if( comb->region_flag )
	{
		props->region_flag = 'R';
		props->ident = comb->region_id;
		props->air_code = comb->aircode;
		props->material_code = comb->GIFTmater;
		props->los_density = comb->los;
	}
	props->color_defined = ( comb->rgb_valid ? 1 : 0 );
	if( props->color_defined )
	{
		props->color[0] = comb->rgb[0];
		props->color[1] = comb->rgb[1];
		props->color[2] = comb->rgb[2];
	}
	else
	{
		props->color[0] = 0;
		props->color[1] = 0;
		props->color[2] = 0;
	}
	props->inherit = ( comb->inherit ? 1 : 0 );
}

int
lookup_props( props , name )
struct iges_properties *props;
char *name;
{
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int id;

	strcpy( props->name, name );
	props->material_name[0] = '\0';
	props->material_params[0] = '\0';
	props->region_flag = ' ';
	props->ident = 0;
	props->air_code = 0;
	props->material_code = 0;
	props->los_density = 0;
	props->color[0] = 0;
	props->color[1] = 0;
	props->color[2] = 0;

	if( name == NULL )
		return( 1 );

	dp  = db_lookup( dbip , name , 1 );
	if( dp == DIR_NULL )
		return( 1 );

	if( !(dp->d_flags & DIR_COMB) )
		return( 1 );

	id = rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL , &rt_uniresource);

	if( id < 0 )
	{
		rt_db_free_internal( &intern , &rt_uniresource);
		bu_log( "Could not get internal form of %s\n", dp->d_namep );
		return( 1 );
	}

	if( id != ID_COMBINATION )
	{
		rt_db_free_internal( &intern , &rt_uniresource);
		bu_log( "Directory/Database mismatch!!!! is %s a combination or not???\n", dp->d_namep );
		return( 1 );
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	get_props( props , comb );
	rt_db_free_internal( &intern , &rt_uniresource);
	return( 0 );
}

int
write_color_entity( color , fp_dir , fp_param )
unsigned char color[3];
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
	float			c[3];

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;

	/* convert colors to percents */
	for( i=0 ; i<3 ; i++ )
		c[i] = (float)color[i]/2.55;

	bu_vls_printf( &str , "314,%g,%g,%g;" , c[0] , c[1] , c[2] );

	dir_entry[1] = 314;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10201;
	dir_entry[11] = 314;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
get_color( color , fp_dir , fp_param )
unsigned char color[3];
FILE *fp_dir,*fp_param;
{
	int color_de;

	for( color_de=0 ; color_de < 9 ; color_de++ )
	{
		if( color[0] == colortab[color_de][1] &&
		    color[1] == colortab[color_de][2] &&
		    color[2] == colortab[color_de][3] )
			break;
	}

	if( color_de == 9 )
		color_de = (-write_color_entity( color , fp_dir , fp_param ));

	return( color_de );
}

int
write_attribute_definition( fp_dir , fp_param )
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* start with parameter data */
	bu_vls_printf( &str , "322,%dH%s,5001,9" , strlen( att_string ) , att_string );
	bu_vls_printf( &str , ",1,3,1" ); /* material name */
	bu_vls_printf( &str , ",2,3,1" ); /* material parameters */
	bu_vls_printf( &str , ",3,6,1" ); /* region flag (logical value) */
	bu_vls_printf( &str , ",4,1,1" ); /* ident number */
	bu_vls_printf( &str , ",5,1,1" ); /* air code number */
	bu_vls_printf( &str , ",6,1,1" ); /* material code number */
	bu_vls_printf( &str , ",7,1,1" ); /* los density (X100) */
	bu_vls_printf( &str , ",8,1,1" ); /* inheritance */
	bu_vls_printf( &str , ",9,6,1;" ); /* color_defined (logical value) */


	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 322;
	dir_entry[8] = 0;
	dir_entry[9] = 10201;
	dir_entry[11] = 322;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );

}

void
iges_init( set_tol , set_ttol , set_verbose , dbip_set )
struct bn_tol *set_tol;
struct rt_tess_tol *set_ttol;
int set_verbose;
struct db_i *dbip_set;
{
	BN_CK_TOL( set_tol );
	RT_CK_TESS_TOL( set_ttol );
	tol = (*set_tol);
	ttol = (*set_ttol);
	verbose = set_verbose;
	dbip = dbip_set;

	dir_seq = 0;
	param_seq = 0;
	start_len = 0;
	global_len = 0;
}

void
Print_stats( fp )
FILE *fp;
{
	int i;
	int total_entities=0;

	fprintf( fp , "Wrote the following numbers and type of entities:\n" );
	for( i=0 ; i<NO_OF_TYPES ; i++ )
		if( type_count[i][1] > 0 )
		{
			total_entities += type_count[i][1];
			fprintf( fp , "\t%d - %s\n" , type_count[i][1] , type_name[i] );
		}

	fprintf( fp , "Total of %d entities written\n" , total_entities );

	if( solids_to_nmg )
		fprintf( fp , "%d solids converted to NMG's before exporting to IGES\n" , solids_to_nmg );
}

int
write_dir_entry( fp , entry )
FILE *fp;
int entry[];
{
	int i,j,type_index;
	char *label;

	for( type_index=0; type_index<NO_OF_TYPES ; type_index++ )
		if( type_count[type_index][0] == entry[1] )
			break;
	if( type_index == NO_OF_TYPES )
	{
		bu_log( "Writing directory entry for an unknown entity type (%d)\n" , entry[1] );
		label = unknown;
		unknown_count++;
		entry[19] = unknown_count;
	}
	else
	{
		label = type_label[type_index];
		type_count[type_index][1]++;
		entry[19] = type_count[type_index][1];
	}

	entry[10] = dir_seq + 1;
	entry[20] = dir_seq + 2;

	for( j=0 ; j<2 ; j++ )
	{

		for( i=j*10+1 ; i<(j+1)*10 ; i++ )
		{
			if( i == 18 )
				fprintf( fp , "%8.8s" , label );
			else if( entry[i] == DEFAULT )
				fprintf( fp , "        " );
			else if( i == 9 )
				fprintf( fp , "%08d" , entry[i] );
			else
				fprintf( fp , "%8d" , entry[i] );
		}
		fprintf( fp , "D%07d\n" , entry[(j+1)*10] );
	}

	dir_seq += 2;
	return( dir_seq - 1 );
}

int
write_freeform(
FILE *fp,	/* output file */
char s[],	/* the string to be output (must not contain any NL's) */
int de,		/* the directory entry # that this belongs to (ignored for Global section) */
char c)		/* 'G' for global section
		 * 'P' for parameter section
		 * 'S' for start section */

{
	int paramlen;
	int start_seq;
	int str_len;
	int line_start=0;
	int line_end=0;
	int *seq_no;
	int remaining_chars=0;
	int i;

	if( c == 'P' )
	{
		seq_no = &param_seq;
		paramlen = 64;
	}
	else if( c == 'G' )
	{
		seq_no = &global_len;
		paramlen = 72;
	}
	else if( c == 'S' )
	{
		seq_no = &start_len;
		paramlen = 72;
	}
	else
	{
		bu_log( "Bad section character passed to 'write_freeform' (%c)\n" , c );
		exit( 1 );
	}

	str_len = strlen( s );
	start_seq = (*seq_no);


	/* the start section is just one big string, so just print in pieces if necessary */
	if( c == 'S' )
	{
		line_start = 0;
		while( line_start < str_len )
		{
			(*seq_no)++;
			fprintf( fp , global_form , &s[line_start] , c , *seq_no );
			line_start += paramlen;
		}
		return( *seq_no - start_seq );
	}

	/* Just print any string that will fit */
	if( str_len <= paramlen )
	{
		(*seq_no)++;
		if( c == 'P' )
			fprintf( fp , param_form , s , de , c , *seq_no );
		else
			fprintf( fp , global_form , s , c , *seq_no );
		return( *seq_no - start_seq );
	}
	else /* break string into lines */
	{
		int curr_loc=0;
		int field_start=0;

		while( 1 )
		{
			line_end = line_start + paramlen - 1;
			curr_loc = line_start;
			if( line_end >= str_len ) /* write the last line and break */
			{
				(*seq_no)++;
				if( c == 'P' )
					fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
				else
					fprintf( fp , global_form , &s[line_start] , c , *seq_no );
				break;
			}
			else /* find the end of this line */
			{
				/* cannot extend numbers across lines,
				 * but character strings may. The only way
				 * to be sure is to interpret the entire string */

				if( remaining_chars >= paramlen )
				{
					/* just print more of the string */
					(*seq_no)++;
					if( c == 'P' )
						fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
					else
						fprintf( fp , global_form , &s[line_start] , c , *seq_no );
					remaining_chars -= paramlen;
				}
				else
				{
					int done=0;

					while( !done )
					{
						char num[81];
						int j=0;

						/* skip over any remainder of a string */
						if( remaining_chars )
						{
							curr_loc = line_start + remaining_chars;
							remaining_chars = 0;
						}
						field_start = curr_loc;

						if( s[curr_loc] == ',' || s[curr_loc] == ';' )
						{
							/* empty field */
							curr_loc++;
						}
						else
						{
							while( isdigit(s[curr_loc]) )
								num[j++] = s[curr_loc++];
							num[j] = '\0';

							if( s[curr_loc] == 'H' )
							{
								/* This is a string */
								int len;

								len = atoi( num );

								/* skip over the 'H' */
								curr_loc++;

								if( curr_loc + len >= line_end )
								{
									/* break this line in a string */
									(*seq_no)++;
									if( c == 'P' )
										fprintf( fp , param_form , &s[line_start] , de , c , *seq_no );
									else
										fprintf( fp , global_form , &s[line_start] , c , *seq_no );
									remaining_chars = curr_loc + len - line_end;
									done = 1;
								}
								else
									curr_loc += len + 1;
							}
							else
							{
								/* this is not a string and cannot be continued to next line */

								/* find end of this field */
								while( curr_loc < str_len && s[curr_loc] != ',' && s[curr_loc] != ';' )
								{
									curr_loc++;
								}

								if( s[curr_loc] == ',' || s[curr_loc] == ';' )
									curr_loc++;

								if( curr_loc > line_end )
								{
									/* end of line must be at start of this field */

									line_end = field_start-1;
									for( i=line_start ; i<=line_end ; i++ )
										fputc( s[i] , fp );

									/* fill out line with blanks */
									for( i=0 ; i<paramlen-(line_end-line_start+1) ; i++ )
										fputc( ' ' , fp );
									if( c == 'P' )
										fprintf( fp , " %7d" , de );
									/* add columns 73 through 80 */
									(*seq_no)++;
									fprintf( fp , "%c%07d\n" , c , *seq_no );
									done = 1;
								}
							}
						}
					}
				}
			}
			line_start = line_end + 1;
		}
		return( *seq_no - start_seq );
	}
}

void
w_start_global(
	FILE *fp_dir,
	FILE *fp_param,
	const char *db_name,
	const char *prog_name,
	const char *output_file,
	const char *id,
	const char *version)
{
	struct bu_vls str;
	time_t now;
	struct tm *timep;
	struct stat db_stat;

	bu_vls_init( &str );

	/* Write Start Section */
	bu_vls_printf( &str , "This IGES file created by %s from the database %s." , prog_name , db_name );
	(void)write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'S' );
	bu_vls_free( &str );

	/* Write Global Section */
	bu_vls_printf( &str , ",,%dH%s" , strlen( db_name ), db_name);

	if( output_file == NULL )
		bu_vls_printf( &str , ",7Hstd_out" );
	else
		bu_vls_printf( &str , ",%dH%s" , strlen( output_file ) , output_file );

	bu_vls_printf( &str , ",%dH%s,%dH%s,32,38,6,308,15,%dH%s,1.0,2,2HMM,,1.0" ,
		strlen( version ) , version ,
		strlen( id ) , id,
		strlen( db_name ) , db_name );

	(void)time( &now );
	timep = localtime( &now );
	bu_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d",
		timep->tm_year+1900,
		timep->tm_mon + 1,
		timep->tm_mday,
		timep->tm_hour,
		timep->tm_min,
		timep->tm_sec );

	bu_vls_printf( &str , ",%g,100000.0,7HUnknown,7HUnknown,9,0" ,
		RT_LEN_TOL );

	if( stat( db_name , &db_stat ) )
	{
		bu_log( "Cannot stat %s\n" , db_name );
		perror( prog_name );
		bu_vls_strcat( &str , ",15H00000101.000000;" );
	}
	else
	{
		timep = localtime( &db_stat.st_mtime );
		bu_vls_printf( &str , ",15H%04d%02d%02d.%02d%02d%02d;",
			timep->tm_year+1900,
			timep->tm_mon + 1,
			timep->tm_mday,
			timep->tm_hour,
			timep->tm_min,
			timep->tm_sec );
	}

	(void)write_freeform( fp_dir , bu_vls_addr( &str ) , 0 , 'G' );

	/* write attribute definition entity */

	if( mode != TRIMMED_SURF_MODE )
		attribute_de = write_attribute_definition( fp_dir ,  fp_param );

	bu_vls_free( &str );
}


int
nmgregion_to_iges( name , r , dependent , fp_dir , fp_param )
char *name;
struct nmgregion *r;
int dependent;
FILE *fp_dir,*fp_param;
{
	struct nmgregion	*new_r;		/* temporary nmgregion */
	struct shell		*s_new;		/* shell made by nmg_mrsv */
	struct bu_ptbl		vtab;		/* vertex table */
	struct bu_ptbl		etab;		/* edge table */
	struct bu_ptbl		**shells;	/* array of tables of shells */
	int			*brep_de;	/* Directory entry sequence # for BREP Object(s) */
	int			vert_de;	/* Directory entry sequence # for vertex list */
	int			edge_de;	/* Directory entry sequence # for edge list */
	int			outer_shell_count; /* number of outer shells in nmgregion */
	int			face_count=0;	/* number of faces in nmgregion */
	int			i;

	NMG_CK_REGION( r );

	{
		struct shell *s;
		for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		{
			struct faceuse *fu;

			for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
			{
				struct loopuse *lu;

				if( fu->orientation != OT_SAME )
					continue;

				face_count++;

				for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
				{
					struct edgeuse *eu;

					if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
						continue;

					for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
					{
						struct vertex *v;

						v = eu->vu_p->v_p;
						NMG_CK_VERTEX( v );
						if( !v->vg_p )
							bu_log( "vertex with no geometry!!\n" );
					}
				}
			}
		}
	}

	if( face_count == 0 )
		return( 0 );

	/* Find outer shells and void shells and their associations */
	outer_shell_count = nmg_find_outer_and_void_shells( r , &shells , &tol );

	brep_de = (int *)bu_calloc( outer_shell_count , sizeof( int ) , "nmgregion_to_iges: brep_de" );

	for( i=0 ; i<outer_shell_count ; i++ )
	{
		int j;
		int tmp_dependent;
		struct shell *s;
		char *tmp_name;

		if( outer_shell_count == 1 )
		{
			new_r = r;
			s_new = NULL;
			tmp_name = name;
			tmp_dependent = dependent;
		}
		else
		{
			new_r = nmg_mrsv( r->m_p );
			s_new = BU_LIST_FIRST( shell , &new_r->s_hd );
			tmp_name = NULL;
			tmp_dependent = 1;

			for( j=BU_PTBL_END( shells[i] )-1 ; j >= 0  ; j-- )
			{
				s = (struct shell *)BU_PTBL_GET( shells[i] , j );
				nmg_mv_shell_to_region( s , new_r );
			}
			(void)nmg_ks( s_new );
		}


		/* Make the vertex list entity */
		vert_de = write_vertex_list( new_r , &vtab , fp_dir , fp_param );

		/* Make the edge list entity */
		edge_de = write_edge_list( new_r , vert_de , &etab , &vtab , fp_dir , fp_param );

		/* Make the face, loop, shell entities */
		brep_de[i] = write_shell_face_loop( tmp_name , new_r , tmp_dependent , edge_de , &etab , vert_de , &vtab , fp_dir , fp_param );

		/* Clear the tables */
		(void)bu_ptbl_reset( &vtab );
		(void)bu_ptbl_reset( &etab );

		if( outer_shell_count != 1 )
			(void)nmg_kr( new_r );
	}

	/* Free the tables */
	(void)bu_ptbl_free( &vtab );
	(void)bu_ptbl_free( &etab );

	if( outer_shell_count != 1 )
		return( write_solid_assembly( name, brep_de , outer_shell_count , dependent , fp_dir , fp_param ) );
	else
		return( brep_de[0] );
}

int
verts_to_copious_data( pts , vert_count , pt_size , fp_dir , fp_param )
point_t *pts;
int vert_count;
int pt_size;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	if( vert_count < 2 )
		return( 0 );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_printf( &str , "106,%d,%d" , pt_size-1 , vert_count+1 );
	if( pt_size == 2 )
	{
		bu_vls_printf( &str , ",0.0" );
		for( i=0 ; i<vert_count ; i++ )
			bu_vls_printf( &str , ",%f,%f" , pts[i][0] , pts[i][1] );
		bu_vls_printf( &str , ",%f,%f" , pts[0][0] , pts[0][1] );
	}
	else if( pt_size == 3 )
	{
		for( i=0 ; i<vert_count ; i++ )
			bu_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[i] ) );
		bu_vls_printf( &str , ",%f,%f,%f" , V3ARGS( pts[0] ) );
	}

	bu_vls_strcat( &str , ";" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 106;
	dir_entry[8] = 0;
	if( pt_size == 2 )
	{
		dir_entry[9] = 10500;
		dir_entry[15] = 63;
	}
	else
	{
		dir_entry[9] = 10000;
		dir_entry[15] = 12;
	}
	dir_entry[11] = 106;


	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ));
}

int
nmg_loop_to_tcurve( lu , surf_de , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param )
struct loopuse *lu;
int surf_de;
vect_t u_dir,v_dir;
fastf_t u_max,v_max;
point_t base_pt;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	struct edgeuse		*eu;
	int			vert_count=0;
	point_t			*model_pts;
	point_t			*param_pts;
	int			i;

	NMG_CK_LOOPUSE( lu );

	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
		return( 0 );

	/* count vertices */
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		vert_count++;

	if( vert_count < 3 )
		return( 0 );

	/* Allocate memory for points */
	model_pts = (point_t *)bu_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: model_pts" );
	param_pts = (point_t *)bu_calloc( vert_count , sizeof( point_t ) , "nmg_loop_to_tcurve: param_pts" );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_printf( &str , "142,0,%d" , surf_de );

	i = 0;
	for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
	{
		struct vertex_g *vg;
		vect_t from_base;
		fastf_t u,v;

		NMG_CK_EDGEUSE( eu );
		NMG_CK_VERTEXUSE( eu->vu_p );
		NMG_CK_VERTEX( eu->vu_p->v_p );
		NMG_CK_VERTEX_G( eu->vu_p->v_p->vg_p );
		vg = eu->vu_p->v_p->vg_p;

		if( i >= vert_count )
			rt_bomb( "nmg_loop_to_tcurve: too many vertices in loop!!!!\n" );

		VMOVE( model_pts[i] , vg->coord );

		VSUB2( from_base , vg->coord , base_pt );
		u = VDOT( u_dir , from_base )/u_max;
		v = VDOT( v_dir , from_base )/v_max;
		if( u < 0.0 )
			u = 0.0;
		if( u > 1.0 )
			u = 1.0;
		if( v < 0.0 )
			v = 0.0;
		if( v > 1.0 )
			v = 1.0;
		VSET( param_pts[i] , u , v , 0.0 );

		i++;
	}

	bu_vls_printf( &str , ",%d" , verts_to_copious_data( param_pts , vert_count , 2 , fp_dir , fp_param ) );
	bu_vls_printf( &str , ",%d,0;" , verts_to_copious_data( model_pts , vert_count , 3 , fp_dir , fp_param ));

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 142;
	dir_entry[8] = 0;
	dir_entry[9] = 10500;
	dir_entry[11] = 142;
	dir_entry[15] = 0;


	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ));
}

void
nmg_fu_to_tsurf( fu , fp_dir , fp_param )
struct faceuse *fu;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	struct loopuse		*lu;
	int			surf_de;
	vect_t			u_dir,v_dir;
	fastf_t			u_max,v_max;
	point_t			base_pt;
	int			loop_count=0;
	int			*curve_de;
	int			i;

	NMG_CK_FACEUSE( fu );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* count loops */
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );

		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		loop_count++;
	}

	if( loop_count < 1 )	/* nothing to output */
		return;

	/* write underlying surface */
	surf_de = write_planar_nurb( fu , u_dir , v_dir , &u_max , &v_max , base_pt , fp_dir , fp_param );

	/* allocate space to hold DE for each trimming curve */
	curve_de = (int *)bu_calloc( loop_count , sizeof( int ) , "nmg_fu_to_tsurf: curve_de" );

	i = (-1);
	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		curve_de[++i] = nmg_loop_to_tcurve( lu , surf_de , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param );
	}

	bu_vls_printf( &str , "144,%d,0,%d" , surf_de , loop_count-1 );
	for( i=0 ; i<loop_count ; i++ )
		bu_vls_printf( &str , ",%d" , curve_de[i] );
	bu_vls_strcat( &str , ";" );

	bu_free( (char *)curve_de , "nmg_fu_to_tsurf: curve_de" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 144;
	dir_entry[8] = 0;
	dir_entry[9] = 0;
	dir_entry[11] = 144;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	(void)write_dir_entry( fp_dir , dir_entry );

}

int nmgregion_to_tsurf( name , r , fp_dir , fp_param )
char *name;
struct nmgregion *r;
FILE *fp_dir,*fp_param;
{
	struct shell *s;

	NMG_CK_REGION( r );

	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		struct faceuse *fu;

		NMG_CK_SHELL( s );
		for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
		{
			NMG_CK_FACEUSE( fu );

			if( fu->orientation != OT_SAME )
				continue;

			nmg_fu_to_tsurf( fu , fp_dir , fp_param );
		}
	}

	return( -1 );
}

int
write_vertex_list( r , vtab , fp_dir , fp_param )
struct nmgregion *r;
struct bu_ptbl *vtab;   /* vertex table */
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	NMG_CK_REGION( r );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* Built list of vertex structs */
	nmg_vertex_tabulate( vtab, &r->l.magic );

	/* write parameter data for vertex list entity */
	bu_vls_printf( &str , "502,%d" , BU_PTBL_END( vtab  ) );

	for( i=0 ; i<BU_PTBL_END( vtab ) ; i++ ) {
		struct vertex                   *v;
		register struct vertex_g        *vg;

		v = (struct vertex *)BU_PTBL_GET(vtab,i);
		NMG_CK_VERTEX(v);
		vg = v->vg_p;
if( !vg )
	bu_log( "No geometry for vertex x%x #%d in table\n" , v , i );
		NMG_CK_VERTEX_G(vg);
		bu_vls_printf( &str, ",%g,%g,%g",
			vg->coord[X],
			vg->coord[Y],
			vg->coord[Z] );
	}
	bu_vls_strcat( &str , ";" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );

	/* write directory entry for vertex list entity */
	dir_entry[1] = 502;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 502;
	dir_entry[15] = 1;


	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ));
}

int
write_line_entity( start_vg , end_vg , fp_dir , fp_param )
struct vertex_g	*start_vg;
struct vertex_g	*end_vg;
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	NMG_CK_VERTEX_G( start_vg );
	NMG_CK_VERTEX_G( end_vg );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* start with parameter data */
	bu_vls_printf( &str , "110,%g,%g,%g,%g,%g,%g;" ,
			start_vg->coord[X],
			start_vg->coord[Y],
			start_vg->coord[Z],
			end_vg->coord[X],
			end_vg->coord[Y],
			end_vg->coord[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 110;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 110;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_linear_bspline( start_vg , end_vg , fp_dir , fp_param )
struct vertex_g	*start_vg;
struct vertex_g	*end_vg;
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	NMG_CK_VERTEX_G( start_vg );
	NMG_CK_VERTEX_G( end_vg );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* start with parameter data */
	bu_vls_printf( &str , "126,1,1,0,0,1,0,0.,0.,1.,1.,1.,1.,%g,%g,%g,%g,%g,%g,0.,1.;" ,
			start_vg->coord[X],
			start_vg->coord[Y],
			start_vg->coord[Z],
			end_vg->coord[X],
			end_vg->coord[Y],
			end_vg->coord[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] =  write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for line entity */
	dir_entry[1] = 126;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 126;
	dir_entry[15] = 1;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_edge_list( r , vert_de , etab , vtab , fp_dir , fp_param )
struct nmgregion *r;
int vert_de;		/* DE# for vertex list */
struct bu_ptbl *etab;	/* edge table */
struct bu_ptbl *vtab;	/* vertex table (already filled in) */
FILE *fp_dir,*fp_param;
{
	struct bu_vls str;
	int dir_entry[21];
	int i;

	NMG_CK_REGION( r );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* Build list of edge structures */
	nmg_edge_tabulate( etab , &r->l.magic );

	bu_vls_printf( &str , "504,%d" , BU_PTBL_END( etab ) );

	/* write parameter data for edge list entity */
	for( i=0 ; i<BU_PTBL_END( etab ) ; i++ )
	{
		struct edge			*e;
		struct edgeuse			*eu;
		struct vertexuse		*vu;
		struct vertex			*start_v,*end_v;
		struct vertex_g			*start_vg,*end_vg;
		int				line_de; /* directory entry # for line entity */

		e = (struct edge *)BU_PTBL_GET(etab,i);
		NMG_CK_EDGE(e);
		eu = e->eu_p;
		NMG_CK_EDGEUSE(eu);
		vu = eu->vu_p;
		NMG_CK_VERTEXUSE(vu);
		start_v = vu->v_p;
		NMG_CK_VERTEX(start_v);
		start_vg = start_v->vg_p;
		NMG_CK_VERTEX_G(start_vg);
		vu = eu->eumate_p->vu_p;
		NMG_CK_VERTEXUSE(vu);
		end_v = vu->v_p;
		NMG_CK_VERTEX(end_v);
		end_vg = end_v->vg_p;
		NMG_CK_VERTEX_G(end_vg);
		if( do_nurbs )
			line_de = write_linear_bspline( start_vg , end_vg , fp_dir , fp_param );
		else
			line_de = write_line_entity( start_vg , end_vg , fp_dir , fp_param );
		bu_vls_printf( &str , ",%d,%d,%d,%d,%d",
			line_de,
			vert_de , bu_ptbl_locate( vtab , (long *)start_v ) + 1,
			vert_de , bu_ptbl_locate( vtab , (long *)end_v ) + 1 );
	}
	bu_vls_strcat( &str , ";" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	/* write directory entry for edge list entity */
	dir_entry[1] = 504;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 504;
	dir_entry[15] = 1;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_point_entity( pt , fp_dir , fp_param )
point_t pt;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	bu_vls_printf( &str , "116,%g,%g,%g,0;" ,
		pt[X],
		pt[Y],
		pt[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 116;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 116;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_direction_entity( pt , fp_dir , fp_param )
point_t pt;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	bu_vls_printf( &str , "123,%g,%g,%g;" ,
		pt[X],
		pt[Y],
		pt[Z] );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 123;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 123;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_plane_entity( plane , fp_dir , fp_param )
plane_t plane;
FILE *fp_dir,*fp_param;
{
	struct bu_vls	str;
	point_t		pt_on_plane;	/* a point on the plane */
	int		dir_entry[21];
	int		i;

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	VSCALE( pt_on_plane , plane , plane[3] );

	bu_vls_printf( &str , "190,%d,%d;" ,
		write_point_entity( pt_on_plane , fp_dir , fp_param ),
		write_direction_entity( plane , fp_dir , fp_param ) );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 190;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 190;
	dir_entry[15] = 0;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );

}

int
write_planar_nurb( fu , u_dir , v_dir , u_max , v_max , base_pt , fp_dir , fp_param )
struct faceuse *fu;
vect_t u_dir,v_dir;	/* output */
fastf_t *u_max,*v_max;	/* output */
point_t base_pt;	/* output ( point at u,v==0 ) */
FILE *fp_dir;
FILE *fp_param;
{
	struct loopuse		*lu;
	struct edgeuse		*eu,*eu_next;
	struct vertex_g		*vg,*vg_next;
	point_t			ctl_pt;
	fastf_t			umin,umax,vmin,vmax;
	struct bu_vls   	str;
	int           	 	dir_entry[21];
	int             	i;

	NMG_CK_FACEUSE( fu );

	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	bu_vls_init( &str );

	/* create direction vectors in u and v directions in plane */
	lu = BU_LIST_FIRST( loopuse , &fu->lu_hd );
	NMG_CK_LOOPUSE( lu );
	while( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC &&
				BU_LIST_NOT_HEAD( lu , &fu->lu_hd ) )
	{
		lu = BU_LIST_PNEXT( loopuse , lu );
		NMG_CK_LOOPUSE( lu );
	}
	if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
	{
		bu_log( "Write_planar_nurb: could not find a loop (with edges) in face\n" );
		return( 0 );
	}

	eu = BU_LIST_FIRST( edgeuse , &lu->down_hd );
	NMG_CK_EDGEUSE( eu );
		vg = eu->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg );
	eu_next = BU_LIST_PNEXT( edgeuse , eu );
	NMG_CK_EDGEUSE( eu_next );
	vg_next = eu_next->vu_p->v_p->vg_p;
	NMG_CK_VERTEX_G( vg_next );

	VSUB2( u_dir , vg_next->coord , vg->coord );
	VUNITIZE( u_dir );
	VCROSS( v_dir , fu->f_p->g.plane_p->N , u_dir );
	VUNITIZE( v_dir );

	/* find the max and min distances from vg along u_dir and v_dir in the face */
	umin = MAX_FASTF;
	vmin = MAX_FASTF;
	umax = (-umin);
	vmax = (-vmin);

	for( BU_LIST_FOR( lu , loopuse , &fu->lu_hd ) )
	{
		NMG_CK_LOOPUSE( lu );
		if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
			continue;

		for( BU_LIST_FOR( eu , edgeuse , &lu->down_hd ) )
		{
			vect_t	tmp_vect;
			fastf_t	distu,distv;

			NMG_CK_EDGEUSE( eu );

			VSUB2( tmp_vect , eu->vu_p->v_p->vg_p->coord , vg->coord );
			distu = VDOT( tmp_vect , u_dir );
			V_MIN( umin , distu );
			V_MAX( umax , distu );
			distv = VDOT( tmp_vect , v_dir );
			V_MIN( vmin , distv );
			V_MAX( vmax , distv );
		}
	}

	*u_max = umax - umin;
	*v_max = vmax - vmin;

	/* Put preliminary stuff for planar nurb in string */
	bu_vls_printf( &str , "128,1,1,1,1,0,0,1,0,0,0.,0.,1.,1.,0.,0.,1.,1.,1.,1.,1.,1." );

	/* Now put control points in string */
	VJOIN2( ctl_pt , vg->coord , umin , u_dir , vmin , v_dir );
	VMOVE( base_pt , ctl_pt );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN1( ctl_pt , ctl_pt , umax-umin , u_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN2( ctl_pt , vg->coord , umin , u_dir , vmax , v_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );
	VJOIN1( ctl_pt , ctl_pt , umax-umin , u_dir );
	bu_vls_printf( &str , ",%g,%g,%g" , V3ARGS( ctl_pt ) );

	/* Now put parameter ranges last */
	bu_vls_printf( &str , ",0.,1.,0.,1.;" );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	dir_entry[1] = 128;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 128;
	dir_entry[15] = 1;

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );

}

int
write_shell_face_loop( name , r , dependent , edge_de , etab , vert_de , vtab , fp_dir , fp_param )
char *name;
struct nmgregion *r;
int dependent;
int edge_de;		/* directory entry # for edge list */
struct bu_ptbl *etab;	/* Table of edge pointers */
int vert_de;		/* directory entry # for vertex list */
struct bu_ptbl *vtab;	/* Table of vertex pointers */
FILE *fp_dir,*fp_param;
{
	struct edgeuse		*eu;
	struct faceuse		*fu;
	struct loopuse		*lu;
	struct shell		*s;
	struct vertex		*v;
	struct bu_vls		str;
	struct iges_properties	props;
	int			*shell_list;
	int			i;
	int			shell_count=0;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;

	NMG_CK_REGION( r );

	bu_vls_init( &str );

	/* count the shells */
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		shell_count++;

	/* make space for the list of shell DE's */
	shell_list = (int *)bu_calloc( shell_count , sizeof( int ) , "write_shell_face_loop: shell_list" );

	shell_count = 0;
	for( BU_LIST_FOR( s , shell , &r->s_hd ) )
	{
		int	*face_list;
		int	face_count=0;


		/* Count faces */
		for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
		{
			NMG_CK_FACEUSE(fu);
			if (fu->orientation != OT_SAME)
				continue;
			face_count++;
		}
		face_list = (int *)bu_calloc( face_count , sizeof( int ) , "face_list" );
		face_count = 0;

		/* Shell is made of faces. */
		for (BU_LIST_FOR(fu, faceuse, &s->fu_hd))
		{
			int	*loop_list;
			int	loop_count=0;
			int	exterior_loop=(-1);	/* index of outer loop (in loop_list) */
			int	outer_loop_flag=1;	/* IGES flag to indicate a selected outer loop */

			if (fu->orientation != OT_SAME)
				continue;

			/* Count loops */
			for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
			{
				NMG_CK_LOOPUSE(lu);
				if( lu->orientation == OT_SAME )
					exterior_loop = loop_count;
				loop_count++;
			}
			loop_list = (int *)bu_calloc( loop_count , sizeof( int ) , "loop_list" );

			loop_count = 0;
			for (BU_LIST_FOR(lu, loopuse, &fu->lu_hd))
			{
				int		edge_count=0;

				/* Count edges */
				if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
				{
					for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
					{
						NMG_CK_EDGEUSE(eu);
						NMG_CK_EDGE(eu->e_p);
						NMG_CK_VERTEXUSE(eu->vu_p);
						NMG_CK_VERTEX(eu->vu_p->v_p);
						NMG_CK_VERTEX_G(eu->vu_p->v_p->vg_p);
						edge_count++;
					}
				}
				else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
				{
		  			v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					NMG_CK_VERTEX(v);
					NMG_CK_VERTEX_G(v->vg_p);
		  			edge_count++;
				}
				else
					bu_log("write_shell_face_loop: loopuse mess up! (1)\n");

				bu_vls_printf( &str , "508,%d" , edge_count );

				if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_EDGEUSE_MAGIC)
				{
					for (BU_LIST_FOR(eu, edgeuse, &lu->down_hd))
					{
						int orientation;
						struct edge *e;
						struct edgeuse *eu_tab;

						e = eu->e_p;
						eu_tab = e->eu_p;
						if( eu_tab->vu_p->v_p == eu->vu_p->v_p )
							orientation = 1;
						else
							orientation = 0;

						bu_vls_printf( &str , ",0,%d,%d,%d,0",
							edge_de ,
							bu_ptbl_locate( etab , (long *)(e)) + 1,
							orientation );

						edge_count++;
					}
				}
				else if (BU_LIST_FIRST_MAGIC(&lu->down_hd) == NMG_VERTEXUSE_MAGIC)
				{
		  			v = BU_LIST_PNEXT(vertexuse, &lu->down_hd)->v_p;
					bu_vls_printf( &str , ",1,%d,%d,1,0",
						vert_de,
						bu_ptbl_locate( vtab , (long *)v )+1 );
				} else
					bu_log("write_shell_face_loop: loopuse mess up! (2)\n");

				bu_vls_strcat( &str , ";" );

				/* write loop entry */
				/* initialize directory entry */
				for( i=0 ; i<21 ; i++ )
					dir_entry[i] = DEFAULT;

				/* remember where parameter data is going */
				dir_entry[2] = param_seq + 1;

				/* get parameter line count */
				dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

				/* write directory entry for loop entity */
				dir_entry[1] = 508;
				dir_entry[8] = 0;
				dir_entry[9] = 10001;
				dir_entry[11] = 508;
				dir_entry[15] = 1;
				loop_list[loop_count++] = write_dir_entry( fp_dir , dir_entry );

				bu_vls_free( &str );

			}

			if( exterior_loop < 0 )
			{
				bu_log( "No outside loop found for face\n" );
				outer_loop_flag = 0;
			}
			else if( exterior_loop != 0 ) /* move outside loop to start of list */
			{
				int tmp;

				tmp = loop_list[0];
				loop_list[0] = loop_list[exterior_loop];
				loop_list[exterior_loop] = tmp;
			}

			if( do_nurbs )
			{
				vect_t u_dir,v_dir;
				point_t base_pt;
				fastf_t u_max,v_max;

				bu_vls_printf( &str , "510,%d,%d,%d" ,
					write_planar_nurb( fu , u_dir , v_dir , &u_max , &v_max , base_pt , fp_dir , fp_param ),
					loop_count,
					outer_loop_flag );
			}
			else
				bu_vls_printf( &str , "510,%d,%d,%d" ,
					write_plane_entity( fu->f_p->g.plane_p->N , fp_dir , fp_param ),
					loop_count,
					outer_loop_flag );

			for( i=0 ; i<loop_count ; i++ )
				bu_vls_printf( &str , ",%d" , loop_list[i] );

			bu_vls_strcat( &str , ";" );

			for( i=0 ; i<21 ; i++ )
				dir_entry[i] = DEFAULT;

			dir_entry[1] = 510;
			dir_entry[2] = param_seq + 1;
			dir_entry[8] = 0;
			dir_entry[9] = 10001;
			dir_entry[11] = 510;
			dir_entry[15] = 1;
			dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

			face_list[face_count++] = write_dir_entry( fp_dir , dir_entry );;

			bu_free( (char *)loop_list , "loop list" );
			bu_vls_free( &str );
		}

		/* write shell entity */
		bu_vls_printf( &str , "514,%d" , face_count );
		for( i=0 ; i<face_count ; i++ )
			bu_vls_printf( &str , ",%d,1" , face_list[i] );
		bu_vls_strcat( &str , ";" );

		/* initialize directory entry */
		for( i=0 ; i<21 ; i++ )
			dir_entry[i] = DEFAULT;

		dir_entry[1] = 514;
		dir_entry[2] = param_seq + 1;
		dir_entry[8] = 0;
		dir_entry[9] = 10001;
		dir_entry[11] = 514;
		dir_entry[15] = 1;
		dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

		shell_list[shell_count++] = write_dir_entry( fp_dir , dir_entry );

		bu_free( (char *)face_list , "face list" );
		bu_vls_free( &str );
	}

	/* write BREP object entity */

	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;

	/* write color and attributes entities, if appropriate */
	if( !name || lookup_props( &props , name ) )
	{
		prop_de = 0;
		color_de = 0;
	}
	else
	{
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
	}

	/* Put outer shell in BREP object first */
	bu_vls_printf( &str , "186,%d,1,%d" , shell_list[0] , shell_count-1 );

	/* Add all other shells */
	for( i=1 ; i<shell_count ; i++ )
	{
			bu_vls_printf( &str , ",%d,1" , shell_list[i] );
	}

	if( prop_de || name_de )
	{
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}

	bu_vls_strcat( &str , ";"  );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	dir_entry[1] = 186;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 186;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_free( (char *)shell_list , "shell list" );
	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

void
w_terminate( fp )
FILE *fp;
{
	fprintf( fp , "S%07dG%07dD%07dP%07d%40.40sT0000001\n" , start_len , global_len , dir_seq , param_seq , " " );
}

int
arb_is_rpp( arb )
struct rt_arb_internal *arb;
{
	vect_t v0,v1,v2;
	int i;

	RT_ARB_CK_MAGIC( arb );

	/* for an rpp, all the height edge vectors must be equal,
	   all the width edge vectors must be equal, all the
	   depth edge vectors must be equal, and at least one
	   vertex must have three right angles */

	/* check the height vectors */
	VSUB2( v0 , arb->pt[4] , arb->pt[0] );
	for( i=5 ; i<8 ; i++ )
	{
		VSUB2( v1 , arb->pt[i] , arb->pt[i-4] );
		if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	}

	/* check the width vectors */
	VSUB2( v0 , arb->pt[1] , arb->pt[0] );
	VSUB2( v1 , arb->pt[2] , arb->pt[3] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[6] , arb->pt[7] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[5] , arb->pt[4] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );

	/* check the depth vectors */
	VSUB2( v0 , arb->pt[3] , arb->pt[0] );
	VSUB2( v1 , arb->pt[2] , arb->pt[1] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[6] , arb->pt[5] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );
	VSUB2( v1 , arb->pt[7] , arb->pt[4] );
	if( !VAPPROXEQUAL( v0 , v1 , tol.dist ) )
			return( 0 );

	/* check for a right angle corner */
	VSUB2( v0 , arb->pt[3] , arb->pt[0] );
	VSUB2( v1 , arb->pt[1] , arb->pt[0] );
	VSUB2( v2 , arb->pt[4] , arb->pt[0] );
	VUNITIZE( v0 );
	VUNITIZE( v1 );
	VUNITIZE( v2 );
	if( !BN_VECT_ARE_PERP( VDOT( v0 , v1 ) , &tol ) )
		return( 0 );
	if( !BN_VECT_ARE_PERP( VDOT( v0 , v2 ) , &tol ) )
		return( 0 );
	if( !BN_VECT_ARE_PERP( VDOT( v1 , v2 ) , &tol ) )
		return( 0 );

	return( 1 );
}

int
write_name_entity( name , fp_dir , fp_param )
char *name;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;
	int			name_len;

	name_len = strlen( name );
	if( !name_len )
		return( 0 );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write parameter data into a string */
	if( name_len >= NAMESIZE )
		bu_vls_printf( &str , "406,1,16H%16.16s;" , name );
	else
		bu_vls_printf( &str , "406,1,%dH%s;" , strlen( name ) , name );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for name property entity */
	dir_entry[1] = 406;
	dir_entry[8] = 0;
	dir_entry[9] = 1010301;
	dir_entry[11] = 406;
	dir_entry[15] = 15;
	return( write_dir_entry( fp_dir , dir_entry ));
}

int
tor_to_iges( ip , name , fp_dir , fp_param )
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
{
	struct rt_tor_internal	*tor;
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_TOR )
		bu_log( "tor_to_iges called for non-torus (type=%d)\n" , ip->idb_type );

	tor = (struct rt_tor_internal *)ip->idb_ptr;

	RT_TOR_CK_MAGIC( tor );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write a name entity for this solid */
	name_de = write_name_entity( name , fp_dir , fp_param );

	/* write parameter data into a string */
	bu_vls_printf( &str , "160,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		tor->r_a,
		tor->r_h,
		tor->v[X] , tor->v[Y] , tor->v[Z],
		tor->h[X] , tor->h[Y] , tor->h[Z],
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for torus entity */
	dir_entry[1] = 160;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 160;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));

}

int
sph_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_ell_internal	*sph;
	struct bu_vls		str;
	double			radius;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_SPH )
		bu_log( "sph_to_iges called for non-sph (type=%d)\n" , ip->idb_type );

	sph = (struct rt_ell_internal *)ip->idb_ptr;

	RT_ELL_CK_MAGIC( sph );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	radius = MAGNITUDE( sph->a );

	/* write parameter data into a string */
	bu_vls_printf( &str , "158,%g,%g,%g,%g,0,1,%d;",
		radius,
		sph->v[X] , sph->v[Y] , sph->v[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for sphere entity */
	dir_entry[1] = 158;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 158;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));

}

int
ell_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_ell_internal	*ell;
	struct bu_vls		str;
	double			radius_a;
	double			radius_b;
	double			radius_c;
	vect_t			a_dir;
	vect_t			b_dir;
	vect_t			c_dir;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_ELL )
		bu_log( "ell_to_iges called for non-ell (type=%d)\n" , ip->idb_type );

	ell = (struct rt_ell_internal *)ip->idb_ptr;

	RT_ELL_CK_MAGIC( ell );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	radius_a = MAGNITUDE( ell->a );
	radius_b = MAGNITUDE( ell->b );
	radius_c = MAGNITUDE( ell->c );

	VMOVE( a_dir , ell->a );
	VMOVE( b_dir , ell->b );
	VMOVE( c_dir , ell->c );

	VUNITIZE( a_dir );
	VUNITIZE( b_dir );
	VUNITIZE( c_dir );

	/* write parameter data into a string */
	bu_vls_printf( &str , "168,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		radius_a , radius_b , radius_c ,
		ell->v[X] , ell->v[Y] , ell->v[Z] ,
		a_dir[X] , a_dir[Y] , a_dir[Z] ,
		c_dir[X] , c_dir[Y] , c_dir[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for ellipsoid entity */
	dir_entry[1] = 168;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 168;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));

}
int
rpp_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_arb_internal	*arb;
	struct bu_vls		str;
	double			length_a;
	double			length_b;
	double			length_c;
	vect_t			a_dir;
	vect_t			b_dir;
	vect_t			c_dir;
	vect_t			tmp_dir;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_ARB8 )
		bu_log( "rpp_to_iges called for non-arb (type=%d)\n" , ip->idb_type );

	arb = (struct rt_arb_internal *)ip->idb_ptr;

	RT_ARB_CK_MAGIC( arb );

	/* write name entity */
	name_de = write_name_entity( name , fp_dir , fp_param );

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	VSUB2( a_dir , arb->pt[1] , arb->pt[0] );
	VSUB2( b_dir , arb->pt[3] , arb->pt[0] );
	VSUB2( c_dir , arb->pt[4] , arb->pt[0] );

	length_a = MAGNITUDE( a_dir );
	length_b = MAGNITUDE( b_dir );
	length_c = MAGNITUDE( c_dir );

	VUNITIZE( a_dir );
	VUNITIZE( b_dir );
	VUNITIZE( c_dir );

	/* c_dir cross a_dir must give b_dir for IGES */
	VCROSS( tmp_dir , c_dir , a_dir );
	if( VDOT( b_dir , tmp_dir ) < 0.0 )
	{
		/* not a right-handed system, so exchange a_dir with c_dir */
		double tmp_length;

		VMOVE( tmp_dir , a_dir );
		VMOVE( a_dir , c_dir );
		VMOVE( c_dir , tmp_dir );
		tmp_length = length_a;
		length_a = length_c;
		length_c = tmp_length;
	}

	/* write parameter data into a string */
	bu_vls_printf( &str , "150,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,0,1,%d;",
		length_a , length_b , length_c ,
		arb->pt[0][X] , arb->pt[0][Y] , arb->pt[0][Z] ,
		a_dir[X] , a_dir[Y] , a_dir[Z] ,
		c_dir[X] , c_dir[Y] , c_dir[Z] ,
		name_de );

	/* remember where parameter data is going */
	dir_entry[2] = param_seq + 1;

	/* get parameter line count */
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
	bu_vls_free( &str );

	/* write directory entry for block entity */
	dir_entry[1] = 150;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 150;
	dir_entry[15] = 0;
	return( write_dir_entry( fp_dir , dir_entry ));
}

int
arb_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_arb_internal *arb;

	if( ip->idb_type != ID_ARB8 )
	{
		bu_log( "arb_to_iges called for non-arb (type=%d)\n" , ip->idb_type );
		return( 0 );
	}

	arb = (struct rt_arb_internal *)ip->idb_ptr;

	RT_ARB_CK_MAGIC( arb );

	if( arb_is_rpp( arb ) )
		return( rpp_to_iges( ip , name , fp_dir , fp_param ) );
	else
		return( nmg_to_iges( ip , name , fp_dir , fp_param ) );
}

int
tgc_to_iges( ip , name , fp_dir , fp_param )
char *name;
struct rt_db_internal *ip;
FILE *fp_dir,*fp_param;
{
	struct rt_tgc_internal	*tgc;
	fastf_t			h_len,a_len,b_len,c_len,d_len;
	vect_t			h_dir,a_dir,b_dir;
	int			iges_type;
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			i;

	if( ip->idb_type != ID_TGC )
	{
		bu_log( "tgc_to_iges called for non-tgc (type=%d)\n" , ip->idb_type );
                return( 0 );
	}

	tgc = (struct rt_tgc_internal *)ip->idb_ptr;

        RT_TGC_CK_MAGIC( tgc );

	h_len = MAGNITUDE( tgc->h );
	a_len = MAGNITUDE( tgc->a );
	b_len = MAGNITUDE( tgc->b );
	c_len = MAGNITUDE( tgc->c );
	d_len = MAGNITUDE( tgc->d );

	/* Use VSCALE rather than VUNITIZE, since we have
	   already done the sqrt */

	VMOVE( h_dir , tgc->h );
	VSCALE( h_dir , h_dir , 1.0/h_len );

	VMOVE( a_dir , tgc->a );
	VSCALE( a_dir , a_dir , 1.0/a_len );

	VMOVE( b_dir , tgc->b );
	VSCALE( b_dir , b_dir , 1.0/b_len );

	if( !BN_VECT_ARE_PERP( VDOT( h_dir , a_dir ) , &tol ) ||
	    !BN_VECT_ARE_PERP( VDOT( h_dir , b_dir ) , &tol ) )
	{
		/* this is not an rcc or a trc */
		return( nmg_to_iges( ip , name , fp_dir , fp_param ));
	}

	if( NEAR_ZERO( a_len-b_len , tol.dist ) &&
	    NEAR_ZERO( c_len-d_len , tol.dist ) )
	{
		/* this tgc is either an rcc or a trc */

		/* write name entity */
		name_de = write_name_entity( name , fp_dir , fp_param );

		bu_vls_init( &str );

		/* initialize directory entry */
		for( i=0 ; i<21 ; i++ )
			dir_entry[i] = DEFAULT;

		if( NEAR_ZERO( a_len-c_len , tol.dist ) )
		{
			/* its an rcc */
			iges_type = 154;
			bu_vls_printf( &str , "154,%g,%g,%g,%g,%g,%g,%g,%g" ,
				h_len , a_len ,
				tgc->v[X] , tgc->v[Y] , tgc->v[Z] ,
				h_dir[X] , h_dir[Y] , h_dir[Z] );
		}
		else
		{
			/* its a trc */

			fastf_t bigger_r,smaller_r;
			vect_t base;

			iges_type = 156;
			if( a_len > c_len )
			{
				bigger_r = a_len;
				smaller_r = c_len;
				VMOVE( base , tgc->v );
			}
			else
			{
				bigger_r = c_len;
				smaller_r = a_len;
				VADD2( base , tgc->v , tgc->h );
				VREVERSE( h_dir , h_dir );
			}
			bu_vls_printf( &str , "156,%g,%g,%g,%g,%g,%g,%g,%g,%g" ,
				h_len , bigger_r , smaller_r ,
				base[X] , base[Y] , base[Z] ,
				h_dir[X] , h_dir[Y] , h_dir[Z] );
		}

		bu_vls_printf( &str , ",0,1,%d;" , name_de );

		/* remember where parameter data is going */
		dir_entry[2] = param_seq + 1;

		/* get parameter line count */
		dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ), dir_seq+1 , 'P' );
		bu_vls_free( &str );

		/* fill in directory entry */
		dir_entry[1] = iges_type;
		dir_entry[8] = 0;
		dir_entry[9] = 10001;
		dir_entry[11] = iges_type;
		dir_entry[15] = 0;

		return( write_dir_entry( fp_dir , dir_entry ));
	}
	else
		return( nmg_to_iges( ip , name , fp_dir , fp_param ));
}

int
write_tree_of_unions( name, de_list , length , dependent , fp_dir , fp_param )
char *name;
int de_list[];
int length;
int dependent;
FILE *fp_dir;
FILE *fp_param;
{
	struct bu_vls		str;
	struct iges_properties	props;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;
	int			i;

	bu_vls_init( &str );

	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;

	/* write color and attributes entities, if appropriate */
	if( lookup_props( &props , name ) )
	{
		prop_de = 0;
		color_de = 0;
	}
	else
	{
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
	}

	/* write parameter data into a string */
	bu_vls_printf( &str , "180,%d,%d" , 2*length-1 , -de_list[0] );
	for( i=1 ; i<length ; i++ )
		bu_vls_printf( &str , ",%d,1" , -de_list[i] );

	if( prop_de || name_de )
	{
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}

	bu_vls_strcat( &str , ";"  );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	dir_entry[1] = 180;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 180;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_solid_assembly( name, de_list , length , dependent , fp_dir , fp_param )
char *name;
int de_list[];
int length;
int dependent;
FILE *fp_dir;
FILE *fp_param;
{
	struct bu_vls		str;
	struct iges_properties	props;
	int			dir_entry[21];
	int			name_de;
	int			prop_de;
	int			color_de=DEFAULT;
	int			i;

	bu_vls_init( &str );

	/* write name entity */
	if( name != NULL )
		name_de = write_name_entity( name , fp_dir , fp_param );
	else
		name_de = 0;

	/* write color and attributes entities, if appropriate */
	if( lookup_props( &props , name ) )
	{
		prop_de = 0;
		color_de = 0;
	}
	else
	{
		prop_de = write_att_entity( &props , fp_dir , fp_param );
		if( props.color_defined )
			color_de = get_color( props.color , fp_dir , fp_param );
	}

	/* write parameter data into a string */
	bu_vls_printf( &str , "184,%d" , length );
	for( i=0 ; i<length ; i++ )
		bu_vls_printf( &str , ",%d" , de_list[i] );
	for( i=0 ; i<length ; i++ )
		bu_vls_printf( &str , ",0" );

	if( prop_de || name_de )
	{
		if( prop_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( prop_de )
			bu_vls_printf( &str , ",%d" , prop_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}

	bu_vls_strcat( &str , ";"  );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	dir_entry[1] = 184;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	if( dependent )
		dir_entry[9] = 10001;
	else
		dir_entry[9] = 1;
	dir_entry[11] = 184;
	dir_entry[13] = color_de;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
nmg_to_iges( ip , name , fp_dir , fp_param )
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
{
	struct model *model;
	struct nmgregion *r;
	int region_count;
	int *region_de;
	int brep_de;
	int dependent;
	int i;

	RT_CK_DB_INTERNAL( ip );

	dependent = 1;
	for( i=0 ; i<no_of_indeps ; i++ )
	{
		if( !strncmp( name , independent[i] , NAMESIZE ) )
		{
			dependent = 0;
			break;
		}
	}

	solid_is_brep = 1;
	comb_form = 1;
	if( ip->idb_type == ID_NMG )
	{
		model = (struct model *)ip->idb_ptr;
		NMG_CK_MODEL( model );

		/* count the number of nmgregions */
		region_count = 0;
		for( BU_LIST_FOR( r , nmgregion , &model->r_hd ) )
		{
			NMG_CK_REGION( r );
			region_count++;
		}

		if( region_count == 0 )
			return( 0 );
		else if( region_count == 1 )
			return( nmgregion_to_iges( name , BU_LIST_FIRST( nmgregion , &model->r_hd ) ,
				dependent , fp_dir , fp_param ) );
		else
		{
			/* make a boolean tree unioning all the regions */

			/* space to save the iges location of each nmgregion */
			region_de = (int *)bu_calloc( region_count , sizeof( int ) , "nmg_to_iges" );

			/* loop through all nmgregions in the model */
			region_count = 0;
			for( BU_LIST_FOR( r , nmgregion , &model->r_hd ) )
				region_de[region_count++] = nmgregion_to_iges( (char *)NULL , r , 1 ,
						fp_dir , fp_param );

			/* now make the boolean tree */
			brep_de = write_tree_of_unions( name , region_de , region_count ,
						dependent , fp_dir , fp_param );

			bu_free( (char *)region_de , "nmg_to_iges" );
			return( brep_de );
		}
	}
	else
	{
		if( ip->idb_type == ID_BOT )
		{
			struct rt_bot_internal *bot=(struct rt_bot_internal *)ip->idb_ptr;
			if( bot->mode != RT_BOT_SOLID )
			{
				bu_log( "%s is a plate mode primitive, and cannot be converted to IGES format!!!\n", name );
				return( 0 );
			}
		}
		model = nmg_mm();
		if( rt_functab[ip->idb_type].ft_tessellate( &r , model , ip , &ttol , &tol ) )
		{
			nmg_km( model );
			return( 0 );
		}
		else
		{
			solids_to_nmg++;
			brep_de =  nmgregion_to_iges( name , r , dependent , fp_dir , fp_param );
			nmg_km( model );
			return( brep_de );
		}
	}
}

int
null_to_iges( ip , name , fp_dir , fp_param )
struct rt_db_internal *ip;
char *name;
FILE *fp_dir,*fp_param;
{
	return( 0 );
}

int
write_xform_entity( mat , fp_dir , fp_param )
mat_t mat;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;

	/* write parameter data into a string */
	bu_vls_strcpy( &str , "124"  );
	for( i=0 ; i<12 ; i++ )
	{
		bu_vls_printf( &str , ",%g" , mat[i] );
	}
	bu_vls_strcat( &str , ";" );

	dir_entry[1] = 124;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 124;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_solid_instance( orig_de , mat , fp_dir , fp_param )
int orig_de;
mat_t mat;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
	        dir_entry[i] = DEFAULT;

	/* write the transformation matrix and make the link */
	dir_entry[7] = write_xform_entity( mat , fp_dir , fp_param );

	/* write parameter data into a string */
	bu_vls_printf( &str , "430,%d;" , orig_de );

	dir_entry[1] = 430;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = 10001;
	dir_entry[11] = 430;
	dir_entry[15] = solid_is_brep ? 1 : 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

int
write_att_entity( props , fp_dir , fp_param )
struct iges_properties *props;
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			str_len;
	int			i;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write parameter data into a string */
	bu_vls_strcpy( &str , "422" );

	/* material name */
	str_len = strlen( props->material_name );
	if( str_len )
		bu_vls_printf( &str , ",%dH%s" , str_len , props->material_name );
	else
		bu_vls_strcat( &str , "," );

	/* material parameters */
	str_len = strlen( props->material_params );
	if( str_len )
		bu_vls_printf( &str , ",%dH%s" , str_len , props->material_params );
	else
		bu_vls_strcat( &str , "," );

	/* region flag */
	if( props->region_flag == 'R' )
		bu_vls_strcat( &str , ",1" );
	else
		bu_vls_strcat( &str , ",0" );

	/* ident number, air code, material code, los density */
	bu_vls_printf( &str , ",%d,%d,%d,%d,%d,%d;" ,
		props->ident ,
		props->air_code ,
		props->material_code ,
		props->los_density,
		props->inherit,
		props->color_defined );

	dir_entry[1] = 422;
	dir_entry[2] = param_seq + 1;
	dir_entry[3] = (-attribute_de);
	dir_entry[8] = 0;
	dir_entry[9] = 10301;
	dir_entry[11] = 422;
	dir_entry[15] = 0;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );
}

/*
 *	Write a region or group of only one member as a solid instance
 *
 */
int
short_comb_to_iges( props , dependent , de_pointers , fp_dir , fp_param )
struct iges_properties *props;
int dependent;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			name_de;
	int			props_de;
	int			color_de=DEFAULT;
	int			status=1;
	int			i;

	/* if member has not been converted, don't try to write the tree */
	if( de_pointers[0] == 0  )
		return( 0 );

	if( dependent )
		status = 10001;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write name entity */
	name_de = write_name_entity( props->name , fp_dir , fp_param );

	/* write attributes entity */
	props_de = write_att_entity( props , fp_dir , fp_param );

	/* get color */
	if( props->color_defined )
		color_de = get_color( props->color , fp_dir , fp_param );
	else
		color_de = 0;

	/* write parameter data into a string */
	bu_vls_printf( &str , "430,%d" , de_pointers[0] );

	if( props_de || name_de )
	{
		if( props_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( props_de )
			bu_vls_printf( &str , ",%d" , props_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}
	bu_vls_strcat( &str , ";" );

	dir_entry[1] = 430;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = status;
	dir_entry[11] = 430;
	dir_entry[13] = color_de;
	dir_entry[15] = comb_form;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );

}

int
count_non_union_ops( tp )
union tree *tp;
{
	int count=0;

	RT_CK_TREE( tp );

	switch( tp->tr_op )
	{
		case OP_INTERSECT:
		case OP_SUBTRACT:
			count++;
		case OP_UNION:
			count += count_non_union_ops( tp->tr_b.tb_left );
			count += count_non_union_ops( tp->tr_b.tb_right );
			break;
		default:
			break;
	}

	return( count );
}

void
igs_tree( str, tp, length, de_pointers )
struct bu_vls *str;
union tree *tp;
int length;
int *de_pointers;
{
	RT_CK_TREE( tp );
	BU_CK_VLS( str );

	switch( tp->tr_op )
	{
		case OP_UNION:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",1" );
			break;
		case OP_INTERSECT:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",2" );
			break;
		case OP_SUBTRACT:
			igs_tree( str, tp->tr_b.tb_left, length, de_pointers );
			igs_tree( str, tp->tr_b.tb_right, length, de_pointers );
			bu_vls_strcat( str, ",3" );
			break;
		case OP_DB_LEAF:
			bu_vls_printf( str, ",%d", -de_pointers[de_pointer_number] );
			de_pointer_number++;
			break;
		default:
			bu_log( "Unrecognized operation in combination!!\n" );
			break;
	}
}

void
write_igs_tree( str, comb, length, de_pointers )
struct bu_vls *str;
struct rt_comb_internal *comb;
int length;
int *de_pointers;
{
	BU_CK_VLS( str );
	RT_CK_COMB( comb );

	bu_vls_printf( str , "180,%d", 2*length-1 );

	de_pointer_number = 0;
	igs_tree( str, comb->tree, length, de_pointers );
}

int
tree_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param )
struct rt_comb_internal *comb;
int length,dependent;
struct iges_properties *props;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	struct bu_vls		str;
	int			dir_entry[21];
	int			actual_length=0;
	int			name_de;
	int			props_de;
	int			color_de=DEFAULT;
	int			non_union_count=0;
	int			status=1;
	int			entity_type;
	int			i;

	RT_CK_COMB( comb );

	/* if any part of this tree has not been converted, don't try to write the tree */
	for( i=0 ; i<length ; i++ )
	{
		if( de_pointers[i] )
			actual_length++;
	}
	if( actual_length != length )
		return( 0 );

	if( dependent )
		status = 10001;

	bu_vls_init( &str );

	/* initialize directory entry */
	for( i=0 ; i<21 ; i++ )
		dir_entry[i] = DEFAULT;

	/* write name entity */
	name_de = write_name_entity( props->name , fp_dir , fp_param );

	/* write attributes entity */
	props_de = write_att_entity( props , fp_dir , fp_param );

	/* get color */
	if( props->color_defined )
		color_de = get_color( props->color , fp_dir , fp_param );
	else
		color_de = 0;

	non_union_count = count_non_union_ops( comb->tree );

	if( mode == CSG_MODE || non_union_count )
	{
		/* write the combination as a Boolean tree */
		entity_type = 180;
		write_igs_tree( &str, comb, length, de_pointers );
	}
	else
	{
		/* write the combination as a solid assembly */
		entity_type = 184;

		bu_vls_printf( &str , "%d,%d" , entity_type , length );
		for( i=0 ; i<length ; i++ )
			bu_vls_printf( &str , ",%d" , de_pointers[i] );
		for( i=0 ; i<length ; i++ )
			bu_vls_strcat( &str , ",0" );
	}

	if( props_de || name_de )
	{
		if( props_de && name_de )
			bu_vls_strcat( &str , ",0,2" );
		else
			bu_vls_printf( &str , ",0,1" );
		if( props_de )
			bu_vls_printf( &str , ",%d" , props_de );
		if( name_de )
			bu_vls_printf( &str , ",%d" , name_de );

	}
	bu_vls_strcat( &str , ";" );

	dir_entry[1] = entity_type;
	dir_entry[2] = param_seq + 1;
	dir_entry[8] = 0;
	dir_entry[9] = status;
	dir_entry[11] = entity_type;
	dir_entry[13] = color_de;
	dir_entry[15] = comb_form;
	dir_entry[14] = write_freeform( fp_param , bu_vls_addr( &str ) , dir_seq+1 , 'P' );

	bu_vls_free( &str );

	return( write_dir_entry( fp_dir , dir_entry ) );

}

int
comb_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param )
struct rt_comb_internal *comb;
int length,dependent;
struct iges_properties *props;
int de_pointers[];
FILE *fp_dir,*fp_param;
{
	RT_CK_COMB( comb );

	if( length == 1 )
		return( short_comb_to_iges( props , dependent , de_pointers , fp_dir , fp_param ) );
	else
		return( tree_to_iges( comb , length , dependent , props , de_pointers , fp_dir , fp_param ) );
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.1
log
@moved all the geometry converter directories from src/. to src/conv/.
@
text
@d48 1
a48 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/iges/iges.c,v 14.6 2005/10/23 04:44:31 brlcad Exp $";
d73 2
a74 2
#include "../iges/iges.h"
#include "../librt/debug.h"
@

