head	1.12;
access;
symbols
	rel-7-10-4:1.11
	STABLE:1.11.0.2
	rel-7-10-2:1.11;
locks; strict;
comment	@// @;


1.12
date	2007.09.14.15.21.03;	author erikgreenwald;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.26.21.24.56;	author jlowenz;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.05.20.41.03;	author jlowenz;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.14.21.44.50;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.14.21.21.38;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.14.16.47.16;	author jlowenz;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.14.13.59.39;	author jlowenz;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.10.17.40.36;	author jlowenz;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.07.19.57.40;	author jlowenz;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.04.20.52.03;	author jlowenz;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.26.20.30.57;	author jlowenz;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.25.18.30.45;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


1.12
log
@removed trailing whitespace
@
text
@/*                      N _ I G E S . C P P
 * BRL-CAD
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file n_iges.cpp
 *
 * Brief description
 *
 * Author -
 *   Jason Owens
 */

/* interface header */
#include "n_iges.hpp"

/* implementation system headers */
#include <list>
#include <assert.h>


namespace brlcad {

  ////////////////////////////////////////////////////////////////////////////////
  Integer::Integer() {
    _val = 0;
  }
  Integer::Integer(long val) {
    _val = val;
  }
  Integer::Integer(const string& field) {
      if (field.length() == 0) _val = 0;
      else {
	  int first = field.find_first_not_of(" \t\n\r");
	  _val = strtol(field.substr(first,field.length()-first).c_str(), NULL, 0);
      }
  }
  Integer::Integer(const Integer& intg) {
    _val = intg._val;
  }
  FILE*
  Integer::read(FILE* in) {
    return in;
  }
  string
  Integer::write(FILE* out) {
    return "";
  }

  ////////////////////////////////////////////////////////////////////////////////
  Pointer::Pointer() {
    _val = 0;
  }
  Pointer::Pointer(long val) {
    _val = labs(val);
  }
  Pointer::Pointer(const string& field) {
    _val = 0;
    int first = field.find_first_not_of(" \t\n\r");
    if (first >= 0) {
      _val = strtol(field.substr(first,field.length()-first).c_str(), NULL, 0);
      if (_val < 0) _val = labs(_val);
    }
 }
  Pointer::Pointer(const Pointer& ptr) {
    _val = ptr._val;
  }
  FILE*
  Pointer::read(FILE* in) {
    return in;

  }
  string
  Pointer::write(FILE* out) {
    return "";
  }

  ////////////////////////////////////////////////////////////////////////////////
  Real::Real() { _val = 0.0; }
  Real::Real(double v) { _val = v; }
  Real::Real(const string& field) {
      if (field.length() == 0) _val = 0.0;
      else {
	  string copy = field;
	  int first = field.find_first_not_of(" \t\n\r");
	  int exp = field.find_first_of("DF");
	  if (exp != string::npos) {
	      copy.replace(exp,1,"e");
	      debug("Real(" << copy << ")");
	  }
	  _val = strtod(copy.substr(first,field.length()-first).c_str(), NULL);
      }
      debug("Real(" << _val << ")");
  }
  Real::Real(const Real& r) {
    _val = r._val;
  }

  FILE*
  Real::read(FILE* in) {
    return in;

  }
  string
  Real::write(FILE* out) {
    return "";
  }

  ////////////////////////////////////////////////////////////////////////////////
  String::String() {
    _val = "";
  }
  String::String(const string& field) {
    if (field.length() == 0) {
      _val = "";
    } else {
      int first = field.find_first_not_of(" \t\n\r0");
      int index = field.find_first_of("H", first);
      if (index != string::npos) {
	int size = atoi(field.substr(first,index).c_str());
	_val = field.substr(index+1,size);
      } else {
	_val = field.substr(first,field.length()-first);
      }
    }
  }
  String::String(const String& str) {
    _val = str._val;
  }
  String::String(const char* str) {
    _val = str;
  }

  FILE*
  String::read(FILE* in) {
    return in;

  }
  string
  String::write(FILE* out) {
    return "";
  }

  ////////////////////////////////////////////////////////////////////////////////
  Logical::Logical() {
    _val = false;
  }
  Logical::Logical(const string& field) {
    int first = field.find_first_not_of(" \t\n\r");
    _val = strtol(field.substr(first,field.length()-first).c_str(), NULL, 0) != 0;
  }
  Logical::Logical(bool val) {
    _val = val;
  }
  Logical::Logical(const Logical& p) {
    _val = p._val;
  }

  FILE*
  Logical::read(FILE* in) {
    return in;

  }
  string
  Logical::write(FILE* out) {
    return "";
  }

  //--------------------------------------------------------------------------------
  // Record
  int Record::_reclen = -1;

  void
  Record::calcRecsize(FILE* in)
  {
    int i,j,k=(-1),recl=0,length[NRECS],ch;

    for( j=0 ; j<NRECS ; j++ )
      {
	i = 1;
	while( (ch = fgetc(in) ) != '\n' && i < NCHAR && ch != EOF )
	  i++;
	if( i == NCHAR )
	  {
	    recl = 80;
	    break;
	  }
	else if( ch == EOF )
	  {
	    k = j - 1;
	    break;
	  }
	else
	  length[j] = i; /* record this record length */
      }
    if( k == (-1) )	/* We didn't encounter an early EOF */
      k = NRECS;

    if( fseek(in, 0, SEEK_SET) ) /* rewind file */ {
      bu_log( "Cannot rewind file\n" );
      perror( "Recsize" );
      exit( 1 );
    }

    if( recl == 0 ) /* then LF's were found */ {
      recl = length[1];	/* don't use length[0] */

      /* check for consistent record lengths */
      for( j=2 ; j<k ; j++ ) {
	if( recl != length[j] )
	  throw new RecordException("no consistent record lengths");
      }
    }
    Record::_reclen = recl;
  }


  Record::Record(FILE* in) : _fp(in) {
    if (_reclen < 0) calcRecsize(in); // XXX: fixme
    _start = ftell(in);
    _read();
  }

  Record::Record(FILE* in, int paramStart, int record) : _fp(in) {
    if (_reclen < 0) calcRecsize(in);
    _start = ftell(in);
    int pos = (record-1)*_reclen;
    fseek(_fp, paramStart + pos, SEEK_SET);
    _read();
  }

  string
  Record::_field(int index) {
    return _line.substr(index*8,8);
  }

  bool
  Record::_readLine() {
    char buf[_reclen+1];
    for (int i = 0; i < _reclen; i++) buf[i] = fgetc(_fp);
    buf[_reclen] = 0;
    //char* str = fgets(buf, _reclen, _fp);
    _line = buf;
    _type = _line[72];
    return true;
  }

  void
  Record::_undoRead(int numLines) {
    fseek(_fp, -(numLines * _reclen), SEEK_CUR);
  }

  void
  Record::_read() {
    _readLine();
    switch (_type) {
    case 'S': _readStart(); break;
    case 'G': _readGlobal(); break;
    case 'D': _readDirectory(); break;
    case 'P': _readParameter(Integer(_field(8))); break;
    case 'T': break;
    default: _valid=false;
    }
  }

  void
  Record::_readStart() {
    // handle what was already read
    _card << _line.substr(0,72);
    while (_readLine() && isStart()) {
      _card << _line.substr(0,72);
    }
    // push back the last line
    _undoRead(); _type = 'S';
    // output the start value
    printf("%s", _card.str().c_str());
    _valid = true;
  }

  void
  Record::_readGlobal() {
    _card << _line.substr(0,72);
    while (_readLine() && isGlobal()) {
      _card << _line.substr(0,72);
    }
    _undoRead(); _type = 'G';
    printf("Read global section\n");
    _valid = true;
  }

  void
  Record::_readDirectory() {
    // each DE is 2 lines - we've read one line
    _card << _line.substr(0,72);
    if (_readLine() && isDirectory())
      _card << _line.substr(0,72);
    else {
      _valid = false;
      _undoRead();
      return;
    }
    _dirEntries.push_back(_card.str());

    int i = 1;
    _card.seekp(0,ios::beg);
    while (_readLine() && isDirectory()) {
      _card << _line.substr(0,72);
      if (i % 2 == 0) {
	_dirEntries.push_back(_card.str());
	_card.seekp(0,ios::beg);
      }
      i++;
    }
    _undoRead(); _type = 'D'; // should have read a parameter line!
    _valid = true;
#if DEBUG
    for (list<string>::iterator i = _dirEntries.begin(); i != _dirEntries.end(); i++) {
      cout << "dir: " << *i << endl;
    }
#endif
  }

  void
  Record::_readParameter(int id) {
    _card << _line.substr(0,64);
    while (_readLine() && isParameter() && (id == Integer(_field(8)))) {
      _card << _line.substr(0,64);
    }
    _undoRead(); _type = 'P';
  }

  GlobalSection*
  Record::createGlobalSection() {
    return new GlobalSection(_card.str());
  }

  void
  Record::createDirectory(vector<DirectoryEntry*>& dir) {
    for (list<string>::iterator i = _dirEntries.begin(); i != _dirEntries.end(); i++) {
      dir.push_back(new DirectoryEntry(*i));
    }
  }

  string
  Record::getParameterData() {
    return _card.str();
  }

  //--------------------------------------------------------------------------------
  // DirectoryEntry definition
  DirectoryEntry::DirectoryEntry(const string& in) : _rawEntry(in) {
    _type = Integer(_field(1));
    _paramData = Pointer(_field(2));
    _structure = Pointer(_field(3));
    long lfp   = Integer(_field(4));
    _lineFontPattern = (lfp >= 0) ? DualIP(Integer(lfp)) : DualIP(Pointer(lfp));
    long lvl   = Integer(_field(5));
    _level     = (lvl >= 0) ? DualIP(Integer(lvl)) : DualIP(Pointer(lvl));
    _view      = Pointer(_field(6));
    _xform     = Pointer(_field(7));
    _label     = Pointer(_field(8));
    _parseStatus(_field(9));
    _lineWeight = Integer(_field(12));
    long color = Integer(_field(13));
    _color     = (color > 0) ? DualIP(Integer(color)) : DualIP(Pointer(color));
    _parameterLineCount = Integer(_field(14));
    _formId    = Integer(_field(15));
    string el  = _field(18);
    el.replace(0, el.find_first_not_of(" "), "");
    _entityLabel = el;
    _entitySubscript = Integer(_field(19));
  }

  void
  DirectoryEntry::_parseStatus(const string& status) {
    int stat = atoi(status.substr(0,2).c_str());
    _visible = (Visibility)stat;
    stat = atoi(status.substr(2,2).c_str());
    _subordinate = (Subordinate)stat;
    stat = atoi(status.substr(4,2).c_str());
    _use = (EntityUse)stat;
    stat = atoi(status.substr(6,2).c_str());
    _hierarchy = (Hierarchy)stat;
  }

  string
  DirectoryEntry::_field(int index) {
    int xindex = (index > 10) ? index - 1 : index;
    return _rawEntry.substr((xindex-1) * FIELD_WIDTH, FIELD_WIDTH);
  }

  string
  DirectoryEntry::toString() {
    ostringstream ss;
    ss << "Type: " << _type << ", " << "Param: " << _paramData;
    return ss.str();
  }

  //--------------------------------------------------------------------------------
  // GlobalSection definition

  // hmm - boost would be nice...
  void split(list<string>& els, const string& str, const string& delim, int init = 0) {
    int start = init;
    int end = str.find_first_of(delim, start);
    while (end != string::npos) {
      if (end != string::npos) {
	if ((end - start) != 0) {
	  string s = str.substr(start, end-start);
	  els.push_back(s);
	} else
	  els.push_back("");
      }
      start = end+1;
      end = str.find_first_of(delim,start);
    }
  }

  GlobalSection::GlobalSection() {
    // XXX: todo
  }

  GlobalSection::GlobalSection(const string& in) {
    read(in);
  }

  void
  GlobalSection::read(const string& in) {
    int index = 0;
    list<string> fields;

    cout << in << endl;

    // param delimiter
    if (in[0] == ',' && in[1] == ',') {
      _params[0] = ",";
      _params[1] = ";";
      index = 2;
    } else if (in[0] == ',') {
      _params[0] = ",";
      _params[1] = in.substr(1,3);
      index = 4;
    } else {
      _params[0] = in.substr(0,3);
      if (in[4] == ',') {
	_params[1] = ';';
	index = 5;
      } else {
	index = in.find_first_of(paramDelim(), 4);
	_params[1] = in.substr(4,index);
	index += 4;
      }
    }
    split(fields, in, paramDelim() + recordDelim(), index);

    cout << "paramDelim:  " << paramDelim() << endl;
    cout << "recordDelim: " << recordDelim() << endl;

    index = 2;
    for (list<string>::iterator iter = fields.begin(); iter != fields.end(); iter++) {
      _params[index] = *iter;
      index++;
    }

    cout << toString();
  }

  //--------------------------------------------------------------------------------
  // ParameterData definition
  ParameterData::ParameterData() {}

  Pointer
  ParameterData::getPointer(int index) const {
    return Pointer(params[index]);
  }

  Integer
  ParameterData::getInteger(int index) const {
    return Integer(params[index]);
  }

  Logical
  ParameterData::getLogical(int index) const {
    return Logical(params[index]);
  }

  String
  ParameterData::getString(int index) const {
    return String(params[index]);
  }

  Real
  ParameterData::getReal(int index) const {
    return Real(params[index]);
  }

  void
  ParameterData::addParam(const string& param) {
    params.push_back(param);
  }


  //--------------------------------------------------------------------------------
  // IGES definition
  IGES::IGES() {

  }

  IGES::IGES(const struct db_i* dbip) {

  }

  IGES::IGES(const string& filename) {
    FILE* in = fopen(filename.c_str(), "r");

    readStart(in);
    readGlobal(in);
    readDirectory(in);
    locateParameters(in);

    _file = in;
  }

  IGES::~IGES() {
    delete _global;
    for (vector<DirectoryEntry*>::iterator i = _dir.begin(); i != _dir.end(); i++) {
      delete (*i);
    }
  }

  const GlobalSection&
  IGES::global() const {
    return *_global;
  }

  string
  IGES::getTypeName(IGESEntity ide) const {
    switch (ide) {
    case Null: return "Null";
    case CircularArc: return "CircularArc";
    case CompositeCurve: return "CompositeCurve";
    case ConicArc: return "ConicArc";
    case CopiousData: return "CopiousData";
    case Plane: return "Plane";
    case Line: return "Line";
    case ParametricSplineCurve: return "ParametricSplineCurve";
    case ParametricSplineSurface: return "ParametricSplineSurface";
    case Point: return "Point";
    case RuledSurface: return "RuledSurface";
    case SurfaceOfRevolution: return "SurfaceOfRevolution";
    case TabulatedCylinder: return "TabulatedCylinder";
    case TransformationMatrix: return "TransformationMatrix";
    case Flash: return "Flash";
    case RationalBSplineCurve: return "RationalBSplineCurve";
    case RationalBSplineSurface: return "RationalBSplineSurface";
    case OffsetCurve: return "OffsetCurve";
    case OffsetSurface: return "OffsetSurface";
    case Boundary: return "Boundary";
    case CurveOnAParametricSurface: return "CurveOnAParametricSurface";
    case BoundedSurface: return "BoundedSurface";
    case TrimmedParametricSurface: return "TrimmedParametricSurface";
    case PlaneSurface: return "PlaneSurface";
    case RightCircularCylindricalSurface: return "RightCircularCylindricalSurface";
    case RightCircularConicalSurface: return "RightCircularConicalSurface";
    case SphericalSurface: return "SphericalSurface";
    case ToroidalSurface: return "ToroidalSurface";
    case Block: return "Block";
    case RightAngularWedge: return "RightAngularWedge";
    case RightCircularCylinder: return "RightCircularCylinder";
    case RightCircularConeFrustum: return "RightCircularConeFrustum";
    case Sphere: return "Sphere";
    case Torus: return "Torus";
    case SolidOfRevolution: return "SolidOfRevolution";
    case SolidOfLinearExtrusion: return "SolidOfLinearExtrusion";
    case Ellipsoid: return "Ellipsoid";
    case ManifoldSolidBRepObject: return "ManifoldSolidBRepObject";
    case Vertex: return "Vertex";
    case Edge: return "Edge";
    case Loop: return "Loop";
    case Face: return "Face";
    case Shell: return "Shell";
    case AngularDimension: return "AngularDimension";
    case CurveDimension: return "CurveDimension";
    case DiameterDimension: return "DiameterDimension";
    case FlagNote: return "FlagNote";
    case GeneralLabel: return "GeneralLabel";
    case GeneralNote: return "GeneralNote";
    case NewGeneralNote: return "NewGeneralNote";
    case LeaderArrow: return "LeaderArrow";
    case LinearDimension: return "LinearDimension";
    case OrdinateDimension: return "OrdinateDimension";
    case PointDimension: return "PointDimension";
    case RadiusDimension: return "RadiusDimension";
    case GeneralSymbol: return "GeneralSymbol";
    case SectionedArea: return "SectionedArea";
    case ConnectPoint: return "Connect";
    case Node: return "Node";
    case FiniteElement: return "Finite";
    case NodalDisplacementAndRotation: return "NodalDisplacementAndRotation";
    case NodalResults: return "NodalResults";
    case ElementResults: return "ElementResults";
    case AssociativityDefinition: return "AssociativityDefinition";
    case LineFontDefinition: return "LineFontDefinition";
    case MACRODefinition: return "MACRODefinition";
    case SubfigureDefinition: return "SubfigureDefinition";
    case TextFontDefinition: return "TextFontDefinition";
    case TextDisplayTemplate: return "TextDisplayTemplate";
    case ColorDefinition: return "ColorDefinition";
    case UnitsData: return "UnitsData";
    case NetworkSubfigureDefinition: return "NetworkSubfigureDefinition";
    case AttributeTableDefinition: return "AttributeTableDefinition";
    case AssociativityInstance: return "AssociativityInstance";
    case Drawing: return "Drawing";
    case Property: return "Property";
    case SingularSubfigureInstance: return "SingularSubfigureInstance";
    case View: return "View";
    case RectangularArraySubfigureInstance: return "RectangularArraySubfigureInstance";
    case CircularArraySubfigureInstance: return "CircularArraySubfigureInstance";
    case ExternalReference: return "ExternalReference";
    case NodalLoadConstraint: return "NodalLoad";
    case NetworkSubfigureInstance: return "NetworkSubfigureInstance";
    case AttributeTableInstance: return "AttributeTableInstance";
    }
    return "Unknown";
  }



  bool
  IGES::readBreps(Extractor* handler)
  {
    DEList breps;
    find(ManifoldSolidBRepObject, breps);
    debug("Found " << breps.size() << " breps!");

    for (DEList::iterator i = breps.begin(); i != breps.end(); i++) {
      handler->extract(this, *i); // should be a BrepHandler subclass, but the code doesn't enforce it
    }
  }

  void
  IGES::find(IGESEntity id, DEList& outList) {
    debug("ID: " << id);
    for (DEVector::iterator i = _dir.begin(); i != _dir.end(); i++) {
      debug((*i)->toString());
      if (((long)id) == ((long)(*i)->type())) outList.push_back(*i);
    }
  }

  void
  IGES::readStart(FILE* in) {
    Record start(in);
    if (!start.isStart()) {
      cerr << "Start section not found" << endl;
      exit(-1);
    }
  }

  void
  IGES::readGlobal(FILE* in) {
    Record global(in);
    _global = global.createGlobalSection();
  }

  void
  IGES::readDirectory(FILE* in) {
    Record dir(in);
    dir.createDirectory(_dir);
  }

  void
  IGES::locateParameters(FILE* in) {
    Record test(in);
    if (test.isParameter()) {
      test.reset();
      paramSectionStart = test.where();
      debug( "Param section starts: " << paramSectionStart );
    } else {
      cerr << "Param section not found! Aborting" << endl;
      exit(-1);
    }
  }

  void
  IGES::getParameter(const Pointer& ptr, ParameterData& outParam) {
    // hmm
    Record r(_file, paramSectionStart, ptr());
    string pd = r.getParameterData();
    list<string> l;
    split(l, pd, _global->paramDelim() + _global->recordDelim());
    outParam.clear();
    for (list<string>::iterator i = l.begin(); i != l.end(); i++) {
      outParam.addParam(*i);
    }
  }

  DirectoryEntry*
  IGES::getDirectoryEntry(const Pointer& ptr) {
    return _dir[(ptr-1)/2];
  }

  void
  IGES::getTransformation(const Pointer& ptr, mat_t out_xform)
  {
    if (ptr() == 0) return;
    //MAT_IDN(xform);
    DirectoryEntry* xform_de = getDirectoryEntry(ptr);
    ParameterData params;
    getParameter(xform_de->paramData(), params);

    mat_t xform;
    for (int i = 0; i < 12; i++) {
      xform[i] = params.getReal(i+1);
    }
    xform[12] = xform[13] = xform[14] = 0;
    xform[15] = 1.0;

    mat_t parent_xform;
    if (xform_de->xform()() != 0) {
      MAT_IDN(parent_xform);
      getTransformation(xform_de->xform(), parent_xform);
      bn_mat_mul(out_xform, parent_xform, xform);
    } else {
      MAT_COPY(out_xform, xform);
    }
  }

  //--------------------------------------------------------------------------------
  // Extractor
  Extractor::~Extractor() {
    for (list<Extractor*>::iterator i = handlers.begin(); i != handlers.end(); i++) {
      delete (*i);
    }
  }

  Extractor*
  Extractor::cascadeDelete(Extractor* handler) {
    handlers.push_back(handler);
    return handler;
  }
}

/*
 * Local Variables:
 * tab-width: 8
 * mode: C++
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.11
log
@fix a bug in IGES parsing where an empty field should yield a default numerical value
@
text
@d48 1
a48 1
	  int first = field.find_first_not_of(" \t\n\r");  
d55 1
a55 1
  FILE* 
d82 1
a82 1
  FILE* 
d85 1
a85 1
    
d94 1
a94 1
  Real::Real(double v) { _val = v; }  
d101 2
a102 2
	  if (exp != string::npos) { 
	      copy.replace(exp,1,"e");     
d113 1
a113 1
  FILE* 
d116 1
a116 1
    
d148 1
a148 1
  FILE* 
d151 1
a151 1
    
d163 1
a163 1
    int first = field.find_first_not_of(" \t\n\r");  
d173 1
a173 1
  FILE* 
d176 1
a176 1
    
d186 1
a186 1
  
d189 1
a189 1
  {    
d221 1
a221 1
      
d238 1
a238 1
  Record::Record(FILE* in, int paramStart, int record) : _fp(in) {    
d244 1
a244 1
  }  
d250 1
a250 1
  
d261 1
a261 1
  
d267 1
a267 1
  void 
d279 2
a280 2
  
  void 
d293 1
a293 1
  
d304 2
a305 2
  
  void 
d317 1
a317 1
    
d350 2
a351 2
  
  void 
d364 1
a364 1
  // DirectoryEntry definition  
d397 1
a397 1
    _hierarchy = (Hierarchy)stat;    
d400 1
a400 1
  string 
d421 1
a421 1
      if (end != string::npos) { 
d425 1
a425 1
	} else 
d427 2
a428 2
      } 
      start = end+1;     
d432 1
a432 1
  
d451 1
a451 1
      _params[1] = ";";      
d469 1
a469 1
    
d474 1
a474 1
    for (list<string>::iterator iter = fields.begin(); iter != fields.end(); iter++) {      
d478 2
a479 2
    
    cout << toString();    
d495 1
a495 1
  
d500 1
a500 1
  
d505 1
a505 1
  
d520 1
a520 1
  
d529 1
a529 1
  
d553 1
a553 1
    case Null: return "Null";    
d650 1
a650 1
    for (DEList::iterator i = breps.begin(); i != breps.end(); i++) {      
d655 1
a655 1
  void 
d658 1
a658 1
    for (DEVector::iterator i = _dir.begin(); i != _dir.end(); i++) {    
d672 1
a672 1
  
d675 1
a675 1
    Record global(in); 
d718 1
a718 1
  {    
d721 1
a721 1
    DirectoryEntry* xform_de = getDirectoryEntry(ptr);    
d743 1
a743 1
  // Extractor  
d749 1
a749 1
  
@


1.10
log
@Fix IGES string->double conversion bugs (duh)
@
text
@d46 5
a50 2
    int first = field.find_first_not_of(" \t\n\r");  
    _val = strtol(field.substr(first,field.length()-first).c_str(), NULL, 0);
d96 12
a107 9
    string copy = field;
    int first = field.find_first_not_of(" \t\n\r");
    int exp = field.find_first_of("DF");
    if (exp != string::npos) { 
      copy.replace(exp,1,"e");     
      debug("Real(" << copy << ")");
    }
    _val = strtod(copy.substr(first,field.length()-first).c_str(), NULL);
    debug("Real(" << _val << ")");
@


1.9
log
@add the file header/footers (added automatically by running [ sh/template.sh lgpl path/to/filename ])
@
text
@d96 3
a98 2
    if (exp != string::npos) {
      copy.replace(exp,exp+1,"e");
d100 2
a101 1
    _val = strtod(field.substr(first,field.length()-first).c_str(), NULL);
@


1.8
log
@vmath is predominantly vector math, matrix math is elsewhere in bn (this holds for other operations that are more intensive than basic vector math code too).  in particular, seems at a glance that this code should be using bn_mat_mult().
@
text
@d1 28
d30 2
d748 10
@


1.7
log
@add xform matrix extraction (still needs to be optimized)
@
text
@a676 18
  
  // !! why isn't this in VMATH?
  void matmult(mat_t a, mat_t b, mat_t c)
  {
    // vectorize?
    mat_t tmp;
    int i,j,k;
    
    for( i=0 ; i<4 ; i++ )
      for( j=0 ; j<4 ; j++ ) {
	tmp[i*4+j] = 0.0;
	for( k=0 ; k<4 ; k++ )
	  tmp[i*4+j] += a[i*4+k] * b[k*4+j];
      }
    for( i=0 ; i<4 ; i++ )
      for( j=0 ; j<4 ; j++ )
	c[i*4+j] = tmp[i*4+j];
  }
d698 1
a698 1
      matmult(parent_xform, xform, out_xform);
@


1.6
log
@Remove some debugging statements, and make parameter methods const.
@
text
@d677 44
@


1.5
log
@ws
@
text
@a17 1
    debug("Integer(" << _val << ")");
d45 1
a45 2
    debug("Pointer(" << _val << ")");
  }
a69 1
    debug("Real(" << _val << ")");
a101 1
    debug("String(" << _val << ")");
a126 1
    debug("Logical(" << _val << ")");
a190 1
    debug("Record Length: " << _reclen);
a220 1
    debug("Reading: " << _line);
a385 1
	  debug("__________" << s << "__________");
a389 1
      cout << els.back() << endl;
d449 1
a449 2
  ParameterData::getPointer(int index) {
    debug("passing to Pointer(): " << params[index]);
d454 1
a454 1
  ParameterData::getInteger(int index) {
d459 1
a459 1
  ParameterData::getLogical(int index) {
d464 1
a464 1
  ParameterData::getString(int index) {
d469 1
a469 1
  ParameterData::getReal(int index) {
a668 1
      debug("addingParam: " << *i);
@


1.4
log
@fix datatype parsing. add debug statements, fix bug in directoryentry access.
@
text
@d338 1
a338 2
    
    long lfp = Integer(_field(4));
d340 5
a344 10

    long lvl = Integer(_field(5));
    _level = (lvl >= 0) ? DualIP(Integer(lvl)) : DualIP(Pointer(lvl));

    _view = Pointer(_field(6));

    _xform = Pointer(_field(7));

    _label = Pointer(_field(8));

a345 1

a346 1
    
d348 1
a348 2
    _color = (color > 0) ? DualIP(Integer(color)) : DualIP(Pointer(color));
    
d350 2
a351 4
    
    _formId = Integer(_field(15));
   
    string el = _field(18);
a353 1

@


1.3
log
@implement methods needed for parameter handling and extraction code
@
text
@d3 1
d40 6
a45 3
    int first = field.find_first_not_of(" \t\n\r");  
    _val = strtol(field.substr(first,field.length()-first).c_str(), NULL, 0);
    if (_val < 0) _val = labs(_val);
d129 3
a131 1
    // XXX: todo parse field
d180 1
a180 1
    if( fseek(in, 0, 0) ) /* rewind file */ {
d202 1
d208 1
d282 1
d403 5
a407 3
	if ((end - start) != 0) 
	  els.push_back(str.substr(start, end-start));
	else 
d471 1
d659 1
a659 1
    Record global(in);
d691 1
d698 1
a698 1
    return _dir[ptr+1/2];
@


1.2
log
@Started work on brep handling infrastructure. will provide user-implemented callbacks for custom application behavior.
@
text
@d7 1
d31 1
d57 1
d84 1
d120 1
d199 1
a199 1
  Record::Record(FILE* in, int record) : _fp(in) {    
d202 1
a202 1
    fseek(_fp, pos, SEEK_SET);
d299 5
a303 1
    // XXX: todo!
d311 2
a312 3
  vector<DirectoryEntry*>*
  Record::createDirectory() {
    vector<DirectoryEntry*>* dir = new vector<DirectoryEntry*>();
d314 1
a314 1
      dir->push_back(new DirectoryEntry(*i));
d316 5
a320 1
    return dir;
d456 1
a456 3
  ParameterData::ParameterData() {
    
  }
d458 1
a458 1
  Pointer 
d460 1
a460 1
    return 0;
d463 1
a463 1
  Integer 
d465 1
a465 1
    return 0;
d467 2
a468 1
  Logical 
d470 1
a470 1
    return false;
d472 2
a473 1
  String  
d475 1
a475 1
    return "";
d477 2
a478 1
  Real    
d480 6
a485 1
    return 0.0;
d512 3
a514 1
    delete _dir;
d630 1
a630 1
    for (DEVector::iterator i = _dir->begin(); i != _dir->end(); i++) {    
d654 1
a654 1
    _dir = dir.createDirectory();
d672 10
d683 3
d688 13
@


1.1
log
@Initial work on new IGES converter to support opennurbs breps. Old converter is quite intertwined with existing BRL-CAD NMG/NURBS code... seemed a bit cleaner to refactor things somewhat. Currently reads start, global and directory sections correctly. Just started work on BREP entity parsing.
@
text
@a3 5
#if DEBUG
#define debug(l) cout << l << endl;
#else
#define debug(l)
#endif
d55 2
d67 4
d102 3
d116 3
d120 8
a128 1
  }
d244 1
a244 1
    _undoRead();
d256 1
a256 1
    _undoRead();
d283 1
a283 1
    _undoRead(); // should have read a parameter line!
d294 1
a294 1
    
d443 29
a593 4
  bool 
  IGES::write(const Geometry& geom) {
    return false;
  }
d596 1
a596 1
  IGES::readBreps(BrepHandler& handler)
d602 2
a603 2
    for (DEList::iterator i = breps.begin(); i != breps.end(); i++) {
      // do something!
d650 5
@

