head	1.17;
access;
symbols
	rel-7-10-4:1.16
	STABLE:1.16.0.2
	rel-7-10-2:1.16;
locks; strict;
comment	@// @;


1.17
date	2007.09.14.15.21.03;	author erikgreenwald;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.28.16.59.32;	author jlowenz;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.14.22.14.23;	author jlowenz;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.04.20.19.59;	author jlowenz;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.01.20.12.45;	author jlowenz;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.17.03.16.40;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.15.16.44.54;	author jlowenz;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.14.21.13.46;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.14.20.17.32;	author jlowenz;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.14.18.00.47;	author jlowenz;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.14.16.48.57;	author jlowenz;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.14.14.01.59;	author jlowenz;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.10.19.50.25;	author jlowenz;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.10.17.39.36;	author jlowenz;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.07.20.01.42;	author jlowenz;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.04.20.49.35;	author jlowenz;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.26.20.30.57;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


1.17
log
@removed trailing whitespace
@
text
@#include "n_iges.hpp"

#include <iostream>
#include <assert.h>

using namespace std;

namespace brlcad {

  BrepHandler::BrepHandler() {}

  BrepHandler::~BrepHandler() {}

  void
  BrepHandler::extract(IGES* iges, const DirectoryEntry* de) {
    _iges = iges;
    extractBrep(de);
  }

  void
  BrepHandler::extractBrep(const DirectoryEntry* de) {
    debug("########################### E X T R A C T   B R E P");
    ParameterData params;
    _iges->getParameter(de->paramData(), params);

    Pointer shell = params.getPointer(1);
    extractShell(_iges->getDirectoryEntry(shell), false, params.getLogical(2));
    int numVoids = params.getInteger(3);

    if (numVoids <= 0) return;

    int index = 4;
    for (int i = 0; i < numVoids; i++) {
      shell = params.getPointer(index);
      extractShell(_iges->getDirectoryEntry(shell),
		   true,
		   params.getLogical(index+1));
      index += 2;
    }
  }

  void
  BrepHandler::extractShell(const DirectoryEntry* de, bool isVoid, bool orientWithFace) {
    debug("########################### E X T R A C T   S H E L L");
    ParameterData params;
    _iges->getParameter(de->paramData(), params);

    handleShell(isVoid, orientWithFace);

    int numFaces = params.getInteger(1);
    for (int i = 1; i <= numFaces; i++) {
      Pointer facePtr = params.getPointer(i*2);
      bool orientWithSurface = params.getLogical(i*2+1);
      DirectoryEntry* faceDE = _iges->getDirectoryEntry(facePtr);
      extractFace(faceDE, orientWithSurface);
    }
  }

  void
  BrepHandler::extractFace(const DirectoryEntry* de, bool orientWithSurface) {
    // spec says the surface can be:
    //   parametric spline surface
    //   ruled surface
    //   surface of revolution
    //   tabulated cylinder
    //   rational b-spline surface
    //   offset surface
    //   plane surface
    //   rccyl surface
    //   rccone surface
    //   spherical surface
    //   toroidal surface

    debug("########################## E X T R A C T   F A C E");
    ParameterData params;
    _iges->getParameter(de->paramData(), params);

    Pointer surfaceDE = params.getPointer(1);
    int surf = extractSurface(_iges->getDirectoryEntry(surfaceDE));

    int face = handleFace(orientWithSurface, surf);

    int numLoops = params.getInteger(2);
    bool isOuter = params.getLogical(3) || true; // outer is not set in IGES from Pro/E!
    for (int i = 4; (i-4) < numLoops; i++) {
      Pointer loopDE = params.getPointer(i);
      extractLoop(_iges->getDirectoryEntry(loopDE), isOuter, face);
      isOuter = false;
    }
  }

  int
  BrepHandler::extractLine(const DirectoryEntry* de, const ParameterData& params)
  {
    point_t start, end;
    start[X] = params.getReal(1);
    start[Y] = params.getReal(2);
    start[Z] = params.getReal(3);
    end[X] = params.getReal(4);
    end[Y] = params.getReal(5);
    end[Z] = params.getReal(6);

    // probably need to transform this line?

    return handleLine(start, end);
  }

  int
  BrepHandler::extractLine(const Pointer& ptr)
  {
    DirectoryEntry* de = _iges->getDirectoryEntry(ptr);
    ParameterData params;
    _iges->getParameter(de->paramData(), params);
    return extractLine(de, params);
  }

  int
  BrepHandler::extractSurfaceOfRevolution(const ParameterData& params) {
      Pointer linePtr = params.getPointer(1);
      Pointer curvePtr = params.getPointer(2);
      double startAngle = params.getReal(3);
      double endAngle = params.getReal(4);

      // load the line (axis of revolution)
      int line = extractLine(linePtr);

      // load the curve (generatrix)
      int curve = extractCurve(_iges->getDirectoryEntry(curvePtr), false);

      return handleSurfaceOfRevolution(line, curve, startAngle, endAngle);
  }

  int
  BrepHandler::extractRationalBSplineSurface(const ParameterData& params) {
    // possible to do optimization of form type???
    // see spec
    const int ui = params.getInteger(1);
    const int vi = params.getInteger(2);
    int u_degree = params.getInteger(3);
    int v_degree = params.getInteger(4);
    bool u_closed = params.getInteger(5)() == 1;
    bool v_closed = params.getInteger(6)() == 1;
    bool rational = params.getInteger(7)() == 0;
    bool u_periodic = params.getInteger(8)() == 1;
    bool v_periodic = params.getInteger(9)() == 1;

    const int n1 = 1+ui-u_degree;
    const int n2 = 1+vi-v_degree;

    const int u_num_knots = n1 + 2 * u_degree;
    const int v_num_knots = n2 + 2 * v_degree;
    const int num_weights = (1+ui)*(1+vi);

    // read the u knots
    int i = 10; // first u knot
    double* u_knots = new double[u_num_knots+1];
    for (int _i = 0; _i <= u_num_knots; _i++) {
      u_knots[_i] = params.getReal(i);
      i++;
    }
    i = 11 + u_num_knots; // first v knot
    double* v_knots = new double[v_num_knots+1];
    for (int _i = 0; _i <= v_num_knots; _i++) {
      v_knots[_i] = params.getReal(i);
      i++;
    }

    // read the weights (w)
    i = 11 + u_num_knots + v_num_knots;
    double* weights = new double[num_weights];
    for (int _i = 0; _i < num_weights; _i++) {
      weights[_i] = params.getReal(i);
      i++;
    }

    // read the control points
    i = 12 + u_num_knots + v_num_knots + num_weights;
    double* ctl_points = new double[(ui+1)*(vi+1)*3];
    const int numu = ui+1;
    const int numv = vi+1;
    for (int _v = 0; _v < numv; _v++) {
      for (int _u = 0; _u < numu; _u++) {
	int index = _v*numu*3 + _u*3;
	ctl_points[index+0] = params.getReal(i);
	ctl_points[index+1] = params.getReal(i+1);
	ctl_points[index+2] = params.getReal(i+2);
	i += 3;
      }
    }

    // read the domain intervals
    double umin = params.getReal(i);
    double umax = params.getReal(i+1);
    double vmin = params.getReal(i+2);
    double vmax = params.getReal(i+3);

    debug("u: [" << umin << "," << umax << "]");
    debug("v: [" << vmin << "," << vmax << "]");

    int controls[] = {ui+1,vi+1};
    int degrees[] = {u_degree,v_degree};
    int index = handleRationalBSplineSurface( controls,
					      degrees,
					      u_closed,
					      v_closed,
					      rational,
					      u_periodic,
					      v_periodic,
					      u_num_knots+1,
					      v_num_knots+1,
					      u_knots,
					      v_knots,
					      weights,
					      ctl_points);
    delete [] ctl_points;
    delete [] weights;
    delete [] v_knots;
    delete [] u_knots;
    return index;
  }

  int
  BrepHandler::extractSurface(const DirectoryEntry* de) {
    debug("########################## E X T R A C T   S U R F A C E");
    ParameterData params;
    _iges->getParameter(de->paramData(), params);
    // determine the surface type to extract
    switch (de->type()) {
    case ParametricSplineSurface:
      debug("\tparametric spline surface");
      break;
    case RuledSurface:
      debug("\truled surface");
      break;
    case SurfaceOfRevolution:
      debug("\tsurface of rev.");
      return extractSurfaceOfRevolution(params);
    case TabulatedCylinder:
      debug("\ttabulated cylinder");
      break;
    case RationalBSplineSurface:
      debug("\trational b-spline surface");
      return extractRationalBSplineSurface(params);
    case OffsetSurface:
      debug("\toffset surface");
      break;
    case PlaneSurface:
      debug("\tplane surface");
      break;
    case RightCircularCylindricalSurface:
      debug("\tright circular cylindrical surface");
      break;
    case RightCircularConicalSurface:
      debug("\tright circular conical surface");
      break;
    case SphericalSurface:
      debug("\tspherical surface");
      break;
    case ToroidalSurface:
      debug("\ttoroidal surface");
      break;
    }
    return 0;
  }

  class PSpaceCurve {
  public:
    PSpaceCurve(IGES* _iges, BrepHandler* _brep, Logical& iso, Pointer& c)
    {
      DirectoryEntry* curveDE = _iges->getDirectoryEntry(c);
      ParameterData param;
      _iges->getParameter(curveDE->paramData(), param);
    }
    PSpaceCurve(const PSpaceCurve& ps)
      : isIso(ps.isIso), curveIndex(ps.curveIndex) {}

    Logical isIso;
    int curveIndex;
  };


  int
  BrepHandler::extractEdge(const DirectoryEntry* edgeListDE, int index) {
    EdgeKey k = make_pair(edgeListDE, index);
    EdgeMap::iterator i = edges.find(k);
    if (i == edges.end()) {
      Pointer initVertexList;
      Integer initVertexIndex;
      Pointer termVertexList;
      Integer termVertexIndex;
      debug("########################## E X T R A C T   E D G E");
      ParameterData params;
      _iges->getParameter(edgeListDE->paramData(), params);
      int paramIndex = (index-1)*5 + 2;
      Pointer msCurvePtr = params.getPointer(paramIndex);
      initVertexList = params.getPointer(paramIndex+1);
      initVertexIndex = params.getInteger(paramIndex+2);
      termVertexList = params.getPointer(paramIndex+3);
      termVertexIndex = params.getInteger(paramIndex+4);

      // extract the model space curves
      int mCurveIndex = extractCurve(_iges->getDirectoryEntry(msCurvePtr), false);

      // extract the vertices
      int initVertex = extractVertex(_iges->getDirectoryEntry(initVertexList),
					initVertexIndex);
      int termVertex = extractVertex(_iges->getDirectoryEntry(termVertexList),
					termVertexIndex);

      edges[k] = handleEdge(mCurveIndex, initVertex, termVertex);
      return edges[k];
    } else {
      return i->second;
    }
  }

  int
  BrepHandler::extractLoop(const DirectoryEntry* de, bool isOuter, int face) {
    debug("########################## E X T R A C T   L O O P");
    ParameterData params;
    _iges->getParameter(de->paramData(), params);

    int loop = handleLoop(isOuter, face);
    int numberOfEdges = params.getInteger(1);

    int i = 2; // extract the edge uses!
    for (int _i = 0; _i < numberOfEdges; _i++) {
      bool isVertex = (1 == params.getInteger(i)) ? true : false;
      Pointer edgePtr = params.getPointer(i+1);
      int index = params.getInteger(i+2);
      // need to get the edge list, and extract the edge info
      int edge = extractEdge(_iges->getDirectoryEntry(edgePtr), index);
      bool orientWithCurve = params.getLogical(i+3);

      // handle this edge
      handleEdgeUse(edge, orientWithCurve);

      // deal with param-space curves (not generally included in Pro/E output)
      int numCurves = params.getInteger(i+4);
      int j = i+5;
      list<PSpaceCurve> pCurveIndices;
      for (int _j = 0; _j < numCurves; _j++) {
	// handle the param-space curves, which are generally not included in MSBO
	Logical iso = params.getLogical(j);
	Pointer ptr = params.getPointer(j+1);
	pCurveIndices.push_back(PSpaceCurve(_iges,
					    this,
					    iso,
					    ptr));
	j += 2;
      }
      i = j;
    }
    return loop;
  }

  int
  BrepHandler::extractVertex(const DirectoryEntry* de, int index) {
    VertKey k = make_pair(de,index);
    VertMap::iterator i = vertices.find(k);
    if (i == vertices.end()) {
      // XXX: fix this...

      ParameterData params;
      _iges->getParameter(de->paramData(), params);
      int num_verts = params.getInteger(1);
      debug("num verts: " << num_verts);
      debug("index    : " << index);
      assert(index <= num_verts);

      int i = 3*index-1;

      point_t pt;
      pt[X] = params.getReal(i);
      pt[Y] = params.getReal(i+1);
      pt[Z] = params.getReal(i+2);

      // XXX: xform matrix application?
      vertices[k] = handleVertex(pt);
      return vertices[k];
    } else {
      return i->second;
    }
  }

  int
  BrepHandler::extractCircularArc(const DirectoryEntry* de, const ParameterData& params) {
    point_t center, start, end;
    double offset_z = params.getReal(1);
    center[X] = params.getReal(2);
    center[Y] = params.getReal(3);
    center[Z] = offset_z;
    start[X]  = params.getReal(4);
    start[Y]  = params.getReal(5);
    start[Z]  = offset_z;
    end[X]    = params.getReal(6);
    end[Y]    = params.getReal(7);
    end[Z]    = offset_z;

    mat_t xform;
    MAT_IDN(xform);
    _iges->getTransformation(de->xform(), xform);

    // choose the circle/interval representation
    // so, calculate the circle params, and then the angle the arc subtends
    double dx = start[X] - center[X];
    double dy = start[Y] - center[Y];
    double radius = sqrt(dx*dx + dy*dy);

    point_t tcenter, tstart, tend;
    MAT4X3PNT(tcenter, xform, center);
    MAT4X3PNT(tstart, xform, start);
    MAT4X3PNT(tend, xform, end);
    vect_t normal = {0,0,1};
    vect_t tnormal;
    MAT4X3VEC(tnormal, xform, normal);

    return handleCircularArc(radius, tcenter, tnormal, tstart, tend);
  }

  int
  BrepHandler::extractRationalBSplineCurve(const DirectoryEntry* de, const ParameterData& params) {
    int k       = params.getInteger(1);
    int degree  = params.getInteger(2);
    bool planar = (params.getInteger(3)() == 1) ? true : false;
    bool closed = (params.getInteger(4)() == 1) ? true : false;
    bool rational = (params.getInteger(5)() == 0) ? true : false;
    bool periodic = (params.getInteger(6)() == 1) ? true : false;

    int num_control_points = k + 1;
    int n = k + 1 - degree;
    int num_knots = n + 2 * degree + 1;

    double* knots = new double[num_knots];
    int i = 7;
    for (int _i = 0; _i < num_knots; _i++) {
      knots[_i] = params.getReal(i);
      i++;
    }

    double* weights = new double[num_control_points];
    for (int _i = 0; _i < num_control_points; _i++) {
      weights[_i] = params.getReal(i);
      i++;
    }

    double* ctl_points = new double[num_control_points * 3];
    for (int _i = 0; _i < num_control_points; _i++) {
      ctl_points[_i*3]   = params.getReal(i);
      ctl_points[_i*3+1] = params.getReal(i+1);
      ctl_points[_i*3+2] = params.getReal(i+2);
      i += 3;
    }

    double umin = params.getReal(i); i++;
    double umax = params.getReal(i); i++;

    vect_t unit_normal;
    if (planar) {
      VSET(unit_normal, params.getReal(i), params.getReal(i+1), params.getReal(i+2));
      i += 3;
    }

    int val = handleRationalBSplineCurve(degree,
					 umin,
					 umax,
					 planar,
					 unit_normal,
					 closed,
					 rational,
					 periodic,
					 num_knots,
					 knots,
					 num_control_points,
					 weights,
					 ctl_points);
    delete [] knots;
    delete [] weights;
    delete [] ctl_points;
    return val;
  }

  int
  BrepHandler::extractCurve(const DirectoryEntry* de, bool isISO) {
    debug("########################## E X T R A C T   C U R V E");
    ParameterData params;
    _iges->getParameter(de->paramData(), params);
    switch (de->type()) {
    case CircularArc:
      debug("\tcircular arc");
      return extractCircularArc(de, params);
    case CompositeCurve:
      debug("\tcomposite curve");
      break;
    case ConicArc:
      debug("\tconic arc");
      break;
    case CopiousData:
      debug("\tcopious data");
      // 11: 2d path
      // 12: 3d path
      // 63: simple closed planar curve
      break;
    case Line:
      debug("\tline");
      return extractLine(de, params);
    case ParametricSplineCurve:
      debug("\tparametric spline curve");
      break;
    case RationalBSplineCurve:
      debug("\trational b-spline curve");
      return extractRationalBSplineCurve(de, params);
    case OffsetCurve:
      debug("\toffset curve");
      break;
    }
    return 0;
  }

}
@


1.16
log
@fix memory leak when handling curves
@
text
@d20 1
a20 1
  void 
d25 1
a25 1
    
d29 3
a31 3
    
    if (numVoids <= 0) return;    
    
d34 1
a34 1
      shell = params.getPointer(index);      
d41 1
a41 1
  
d47 1
a47 1
    
d59 1
a59 1
  void 
d74 1
a74 1
    debug("########################## E X T R A C T   F A C E"); 
d77 1
a77 1
        
d86 1
a86 1
      Pointer loopDE = params.getPointer(i);      
d109 1
a109 1
  BrepHandler::extractLine(const Pointer& ptr) 
d123 1
a123 1
      
d126 1
a126 1
      
d129 1
a129 1
      
d131 1
a131 1
  }  
d146 1
a146 1
      
d149 1
a149 1
      
d153 1
a153 1
      
d167 1
a167 1
      
d175 1
a175 1
      
d190 1
a190 1
      
d241 1
a241 1
    case RationalBSplineSurface: 
d268 1
a268 1
    PSpaceCurve(IGES* _iges, BrepHandler* _brep, Logical& iso, Pointer& c) 
d274 1
a274 1
    PSpaceCurve(const PSpaceCurve& ps) 
d280 1
a280 1
      
d283 1
a283 1
  BrepHandler::extractEdge(const DirectoryEntry* edgeListDE, int index) { 
d286 1
a286 1
    if (i == edges.end()) {      
d290 1
a290 1
      Integer termVertexIndex;    
d300 1
a300 1
      
d303 3
a305 3
      
      // extract the vertices      
      int initVertex = extractVertex(_iges->getDirectoryEntry(initVertexList), 
d309 1
a309 1
      
d331 3
a333 3
      // need to get the edge list, and extract the edge info     
      int edge = extractEdge(_iges->getDirectoryEntry(edgePtr), index);      
      bool orientWithCurve = params.getLogical(i+3);      
d347 1
a347 1
					    this, 
d357 1
a357 1
  int 
d362 2
a363 2
      // XXX: fix this... 
      
d370 1
a370 1
      
d372 1
a372 1
      
d377 1
a377 1
      
d409 2
a410 2
    
    point_t tcenter, tstart, tend;    
d429 1
a429 1
    
d440 1
a440 1
    
d454 1
a454 1
    
d457 1
a457 1
    
d463 1
a463 1
        
d483 1
a483 1
  int 
d489 1
a489 1
    case CircularArc: 
d504 1
a504 1
    case Line: 
@


1.15
log
@When an arc's start center and end points are coplanar, we can't find the plane! so calculate the normal and pass it through to the handler...
@
text
@d464 17
a480 13
    return handleRationalBSplineCurve(degree,
				      umin,
				      umax,
				      planar,
				      unit_normal,
				      closed,
				      rational,
				      periodic,
				      num_knots,
				      knots,
				      num_control_points,
				      weights,
				      ctl_points);
@


1.14
log
@Debug IGES parsing/handling and openNURBS extensions. Still not building a simple B-Rep correctly (trim vertices not agreeing)
@
text
@d410 1
a410 1
    point_t tcenter, tstart, tend;
d414 5
a418 2
    
    return handleCircularArc(radius, tcenter, tstart, tend);
@


1.13
log
@Fix bug in IGES nurbs extraction (index calculation errors)
@
text
@d84 1
a84 1
    bool isOuter = params.getLogical(3);    
d86 1
a86 1
      Pointer loopDE = params.getPointer(i);
d310 2
a311 1
      return handleEdge(mCurveIndex, initVertex, termVertex);
d331 3
a333 3
      // need to get the edge list, and extract the edge info
      int edge = extractEdge(_iges->getDirectoryEntry(edgePtr), index);
      bool orientWithCurve = params.getLogical(i+3);
d338 1
a338 1
      // deal with param-space curves (not generally included from Pro/E)
a339 1
      debug("Num param-space curves in " << string((isOuter)?"outer":"inner") << " loop: " << numCurves);
@


1.12
log
@need assert.h for assert()
@
text
@d147 2
a148 2
    int n1 = 1+ui-u_degree;
    int n2 = 1+vi-v_degree;
d156 2
a157 2
    double* u_knots = new double[u_num_knots];
    for (int _i = 0; _i < u_num_knots; _i++) {
d162 2
a163 2
    double* v_knots = new double[v_num_knots];
    for (int _i = 0; _i < v_num_knots; _i++) {
d178 1
a178 1
    double* ctl_points = new double[CP_SIZE(ui+1, vi+1, 3)];
d183 4
a186 3
	ctl_points[CPI(_u,_v,0)] = params.getReal(i);
	ctl_points[CPI(_u,_v,1)] = params.getReal(i+1);
	ctl_points[CPI(_u,_v,2)] = params.getReal(i+2);
d197 3
d209 2
a210 2
					      u_num_knots,
					      v_num_knots,
@


1.11
log
@fixed edge extraction/vertex bug
@
text
@d4 2
@


1.10
log
@use VSET
@
text
@d285 1
a285 1
      debug("########################## E X T R A C T   E D G E  U S E");
d288 1
a288 1
      int paramIndex = (index-1)*5 + 1;
d361 2
d365 1
a365 1
      int i = 3*num_verts-1;
@


1.9
log
@implement extraction of edges and vertices, finish loop and edge use handling calls. there remains a bug in the vertex extractor at this point.
@
text
@d449 1
a449 3
      unit_normal[X] = params.getReal(i);
      unit_normal[Y] = params.getReal(i+1);
      unit_normal[Z] = params.getReal(i+2);
@


1.8
log
@implement extraction routine for rational b-spline curves
@
text
@d91 1
a91 1
  BrepHandler::extractLine(const ParameterData& params) 
d94 8
a101 6
    start[0] = params.getReal(1);
    start[1] = params.getReal(2);
    start[2] = params.getReal(3);
    end[0] = params.getReal(4);
    end[1] = params.getReal(5);
    end[2] = params.getReal(6);
d112 1
a112 1
    return extractLine(params);
d276 9
a284 4
  class EdgeUse {
  public:
    EdgeUse(IGES* _iges, BrepHandler* _brep, Pointer& edgeList, int index)
    { 
a285 1
      DirectoryEntry* edgeListDE = _iges->getDirectoryEntry(edgeList);
d296 11
a306 1
      mCurveIndex = _brep->extractCurve(_iges->getDirectoryEntry(msCurvePtr), false);
d308 1
a308 15
    EdgeUse(const EdgeUse& eu) 
      : mCurveIndex(eu.mCurveIndex),
	pCurveIndices(eu.pCurveIndices),
	initVertexList(eu.initVertexList), 
	initVertexIndex(eu.initVertexIndex), 
	termVertexList(eu.termVertexList), 
	termVertexIndex(eu.termVertexIndex) {}
    
    int mCurveIndex; // model space curve???
    list<PSpaceCurve> pCurveIndices; // parameter space curves
    Pointer initVertexList;
    Integer initVertexIndex;
    Pointer termVertexList;
    Integer termVertexIndex;    
  };
d310 1
a310 1
  void 
d325 1
a325 1
      EdgeUse eu(_iges, this, edgePtr, index);
d327 5
d335 1
d340 4
a343 4
	eu.pCurveIndices.push_back(PSpaceCurve(_iges,
					       this, 
					       iso,
					       ptr));
d348 1
d351 25
a375 8
  void 
  BrepHandler::extractEdge(const DirectoryEntry* de) {
    
  }
  
  void 
  BrepHandler::extractVertex(const DirectoryEntry* de) {

d493 1
a493 1
      return extractLine(params);
@


1.7
log
@implement extraction routine for circular arcs
@
text
@d367 1
d384 60
d473 1
a473 1
      break;
@


1.6
log
@Implement extract routine for surfaces of revolution.
@
text
@d72 1
a72 1
    debug("########################### E X T R A C T   F A C E"); 
d91 1
a91 1
  BrepHandler::extractLine(const Pointer& ptr, point_t start, point_t end) 
d93 1
a93 3
    DirectoryEntry* de = _iges->getDirectoryEntry(ptr);
    ParameterData params;
    _iges->getParameter(de->paramData(), params);
d105 9
d121 1
a121 2
      point_t start, end;
      int line = extractLine(linePtr, start, end);
d352 31
d385 1
d389 27
a415 1

a416 11
    // spec says the curve may be:
    //   100 Circular Arc 
    //   102 Composite Curve 
    //   104 Conic Arc 
    //   106/11 2D Path 
    //   106/12 3D Path 
    //   106/63 Simple Closed Planar Curve 
    //   110 Line 
    //   112 Parametric Spline Curve 
    //   126 Rational B-Spline Curve 
    //   130 Offset Curve 
@


1.5
log
@Add specific curve and surface handlers. Implement rational b-spline extraction routine.
@
text
@d91 118
d215 2
a216 1
    case ParametricSplineSurface:      
d219 1
d222 2
a223 1
      break;
d225 1
d227 3
a229 82
    case RationalBSplineSurface: {
      // possible to do optimization of form type???
      // see spec
      const int ui = params.getInteger(1);
      const int vi = params.getInteger(2);
      int u_degree = params.getInteger(3);
      int v_degree = params.getInteger(4);
      bool u_closed = params.getInteger(5)() == 1;
      bool v_closed = params.getInteger(6)() == 1;
      bool rational = params.getInteger(7)() == 0;
      bool u_periodic = params.getInteger(8)() == 1;
      bool v_periodic = params.getInteger(9)() == 1;
      
      int n1 = 1+ui-u_degree;
      int n2 = 1+vi-v_degree;
      
      const int u_num_knots = n1 + 2 * u_degree;
      const int v_num_knots = n2 + 2 * v_degree;
      const int num_weights = (1+ui)*(1+vi);
      
      // read the u knots
      int i = 10; // first u knot
      double* u_knots = new double[u_num_knots];
      for (int _i = 0; _i < u_num_knots; _i++) {
	u_knots[_i] = params.getReal(i);
	i++;
      }
      i = 11 + u_num_knots; // first v knot
      double* v_knots = new double[v_num_knots];
      for (int _i = 0; _i < v_num_knots; _i++) {
	v_knots[_i] = params.getReal(i);
	i++;
      }
      
      // read the weights (w)
      i = 11 + u_num_knots + v_num_knots;
      double* weights = new double[num_weights];
      for (int _i = 0; _i < num_weights; _i++) {
	weights[_i] = params.getReal(i);
	i++;
      }
      
      // read the control points
      i = 12 + u_num_knots + v_num_knots + num_weights;
      double* ctl_points = new double[CP_SIZE(ui+1, vi+1, 3)];
      const int numu = ui+1;
      const int numv = vi+1;
      for (int _v = 0; _v < numv; _v++) {
	for (int _u = 0; _u < numu; _u++) {
	  ctl_points[CPI(_u,_v,0)] = params.getReal(i);
	  ctl_points[CPI(_u,_v,1)] = params.getReal(i+1);
	  ctl_points[CPI(_u,_v,2)] = params.getReal(i+2);
	  i += 3;
	}
      }
      
      // read the domain intervals
      double umin = params.getReal(i);
      double umax = params.getReal(i+1);
      double vmin = params.getReal(i+2);
      double vmax = params.getReal(i+3);

      int controls[] = {ui+1,vi+1};
      int degrees[] = {u_degree,v_degree};
      int index = handleRationalBSplineSurface( controls,
						degrees,
						u_closed,
						v_closed,
						rational,
						u_periodic,
						v_periodic,
						u_num_knots,
						v_num_knots,
						u_knots,
						v_knots,
						weights,
						ctl_points);
      delete [] ctl_points;
      delete [] weights;
      delete [] v_knots;
      delete [] u_knots;      
    } break;
d231 1
d234 1
d237 1
d240 1
d243 1
d246 1
d348 5
d364 1
a364 2

    
@


1.4
log
@ws
@
text
@d105 1
a105 1
    case RationalBSplineSurface:
d108 2
a109 2
      int ui = params.getInteger(1);
      int vi = params.getInteger(2);
d116 71
a186 3
      bool v_periodic = params.getInteger(9)() == 1;      
	
      break;
@


1.3
log
@loop and edgeuse implementation/debugging. parses, but Pro/E outputs model-space trim curves!!!! need to sample the curves.
@
text
@d59 13
d95 38
a132 1
    return handleSurface((IGESEntity)(int)de->type(), params);
d166 1
a166 1
      // extract the model space curves - is this even valid for MSBO?
a191 1

d205 2
a206 1
      for (int _j = 0; _j < numCurves; _j++) {	
d215 1
a215 4
      
      

      i = j;      
d231 12
@


1.2
log
@flesh out extraction methods using iges spec.
@
text
@d20 1
d42 1
d59 1
d79 1
d85 1
a85 1
  class EdgeList {
d87 11
a97 1
    
d99 1
d101 33
a133 5
  DirectoryEntry* 
  BrepHandler::getEdge(Pointer& edgeList, int index) {    
    DirectoryEntry* edgeListDE = _iges->getDirectoryEntry(edgeList);
    
  }
d137 1
d147 1
a147 2
      bool isVertex = (1 == 
params.getInteger(i)) ? true : false;
d149 3
a151 1
      int index = params.getPointer(i+2);
d153 2
a154 1
      int numCurves = params.getLogical(i+4);
a155 1
      list<int> curve_list;
d157 6
a162 3
	bool isIso = params.getLogical(j);
	Pointer curvePtr = params.getPointer(j+1);
	curve_list.push_back(extractCurve(_iges->getDirectoryEntry(curvePtr), isIso));
d166 1
a166 4
      // need to get the edge list, and extract the edge info
      DirectoryEntry* edgeDE = getEdge(edgePtr, index);
      //extractEdge(, isVertex, 

d184 1
a184 1

@


1.1
log
@Started work on brep handling infrastructure. will provide user-implemented callbacks for custom application behavior.
@
text
@d3 3
d8 3
a10 1
BrepHandler::BrepHandler() {}
d12 5
a16 1
BrepHandler::~BrepHandler() {}
d18 20
a37 4
void 
BrepHandler::extract(IGES* iges, const DirectoryEntry* de) {
  ParameterData params;
  iges->getParameter(de->paramData(), params);
d39 92
a130 1
}
d132 7
a138 6
// extract calls these methods for custom work!
ShellHandler* 
BrepHandler::handleBoundaryShell() {
  debug("handleBoundaryShell");
  return NULL;
}
d140 1
a140 5
ShellHandler* 
BrepHandler::handleVoidShell() {
  debug("handleVoidShell");
  return NULL;
}
@

