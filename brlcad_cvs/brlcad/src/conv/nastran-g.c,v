head	14.20;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.7
	rel-7-10-2:14.16
	rel-7-10-0:14.16
	rel-7-8-4:14.12
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.20
date	2007.12.31.17.38.20;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.22.17.42.34;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.10.14.22.15.54;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.02.02.08.48.28;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.04.06.19.30.22;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.28.00.36.27;	author brlcad;	state Exp;
branches
	14.11.2.1;
next	14.10;

14.10
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.09.09.05.50.29;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.01.30.20.30.20;	author brlcad;	state Exp;
branches
	14.7.6.1;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.50;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.10;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.09;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.54;	author morrison;	state Exp;
branches;
next	;

14.7.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;

14.11.2.1
date	2006.04.07.19.26.25;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.20
log
@file pointer, not file descriptor.  there's a difference.
@
text
@/*                     N A S T R A N - G . C
 * BRL-CAD
 *
 * Copyright (c) 1997-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file nastran-g.c
 *
 *	Code to convert a NASTRAN finite element model to BRL-CAD.
 *
 *  Author -
 *      John R. Anderson
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.19 2007/10/22 17:42:34 brlcad Exp $";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "../librt/debug.h"

struct coord_sys
{
	struct bu_list	l;	/* for the linked list */
	int cid;		/* coordinate system identification number */
	char type;		/* coordinate system type */
	int rid;		/* reference coordinate system */
	point_t origin;		/* origin of this coord system */
	vect_t v1, v2, v3;	/* three unit vectors */
};

struct grid_point
{
	int gid;		/* grid point ID number */
	int cid;		/* coordinate system this point uses */
	point_t pt;		/* actual grid point */
	struct vertex **v;	/* corresponding NMG vertex structure (indexed by pid) */
};

struct pbar
{
	struct bu_list l;	/* for the linked list */
	int pid;		/* PBAR ID number */
	int mid;		/* material ID number */
	fastf_t area;		/* cross-sectional area */
	struct wmember head;	/* head of linked list of members for this pid */
};

struct pshell
{
	struct bu_list l;	/* for the linked list */
	int pid;		/* PSHELL ID number */
	int mid;		/* material ID number */
	fastf_t thick;		/* thickness of shell */
	struct shell *s;	/* actual NMG shell */
};


#define		CORD_CYL	'C'
#define		CORD_RECT	'R'
#define		CORD_SPH	'S'

extern char *bu_optarg;
extern int bu_optind, bu_opterr, optopt;

#define		NAMESIZE	16	/* from db.h */

#define		MAXLINELEN	256	/* maximum allowed input line length */

#define		INCHES		1
#define		MM		2

static fastf_t conv[3]={
	1.0,
	25.4,
	1.0
};

static int			units;		/* units flag */
static char			*output_file = "nastran.g";
static struct rt_wdb		*fpout;		/* brlcad output file */
static FILE			*fpin;		/* NASTRAN input file */
static FILE			*fptmp;		/* temporary version of NASTRAN input */
static char			*Usage="Usage:\n\t%s [-p] [-xX lvl] [-t tol.dist] [-i NASTRAN_file] -o BRL-CAD_file\n";
static long			start_off;
static char			*delims=", \t";
static struct coord_sys		coord_head;	/* head of linked list of coordinate systems */
static struct pbar		pbar_head;	/* head of linked list of PBAR's */
static struct pshell		pshell_head;	/* head of linked list of PSHELL's */
static int			pshell_count=0;	/* number of different PSHELL's */
static int			grid_count=0;	/* number of grid points */
static int			grid_used=0;	/* actual count of grid points currently in memory */
static struct grid_point	*g_pts;		/* array of grid points */
static int			bar_def_pid=0;	/* default property ID number for CBAR's */
static char			**curr_rec;	/* current input record */
static char			**prev_rec;	/* previous input record */
static char			*line;		/* current input line */
static char			*next_line;	/* next input line */
static char			*prev_line;	/* previous input line */
static int			input_status;		/* status of input FILE */
static long			line_count;	/* count of input lines */
static long			bulk_data_start_line;	/* line number where BULK DATA begins */
static struct model		*nmg_model;	/* NMG solid for surfaces */
static struct shell		*nmg_shell;	/* NMG shell */
static struct bn_tol		tol;		/* tolerance for NMG's */
static int			polysolids=1;	/* flag for outputting NMG's rather than BOT's */

HIDDEN int get_next_record( FILE *fp, int call_input, int write_flag );
HIDDEN int convert_pt( const point_t pt, struct coord_sys *cs, point_t out_pt );

#define		INPUT_OK	0
#define		INPUT_NULL	1

#define		UNKNOWN		0
#define		FREE_FIELD	1
#define		SMALL_FIELD	2
#define		LARGE_FIELD	3

#define		NO_OF_FIELDS	20
#define		FIELD_LENGTH	17

HIDDEN void
reset_input(void)
{
	int i;
	char *tmp;

	for( i=0 ; i < 20 ; i++ )
		prev_rec[i][0] = '\0';

	fseek( fpin, start_off, SEEK_SET );
	line_count = bulk_data_start_line;

	tmp = bu_fgets( next_line, MAXLINELEN, fpin );
	while( tmp && *tmp == '$' )
		tmp = bu_fgets( next_line, MAXLINELEN, fpin );

	if( tmp != (char *)NULL )
		input_status = INPUT_OK;
	else
		input_status = INPUT_NULL;
}

HIDDEN void
write_fields(void)
{
	int i, j;

	for( i=0 ; i<NO_OF_FIELDS ; i++ )
	{
		/* eliminate trailing blanks */
		j = strlen( curr_rec[i] ) - 1;
		while( j && ( isspace( curr_rec[i][j] ) || curr_rec[i][j] == '\012' || curr_rec[i][j] == '\015' ) )
			j--;
		curr_rec[i][++j] = '\0';

		/* skip leading blanks */
		j = 0;
		while( curr_rec[i][j] != '\0' && isspace( curr_rec[i][j] ) )
			j++;
		fprintf( fptmp, "%s,", &curr_rec[i][j] );
	}
	fprintf( fptmp, "\n" );
}

HIDDEN void
do_silly_nastran_shortcuts(void)
{
	int field_no;

	for( field_no=0 ; field_no < NO_OF_FIELDS ; field_no++ )
	{
		if( !strcmp( curr_rec[field_no], "=" ) )
		{
			strncpy( curr_rec[field_no], prev_rec[field_no], FIELD_LENGTH );
		}
		else if( !strcmp( curr_rec[field_no], "==" ) )
		{
			while( field_no < NO_OF_FIELDS )
			{
				strncpy( curr_rec[field_no], prev_rec[field_no], FIELD_LENGTH );
				field_no++;
			}
		}
		else if( curr_rec[field_no][0] == '*' )
		{
			int i=0;

			while( curr_rec[field_no][++i] == '(' );

			if( strchr( prev_rec[field_no], '.' ) )
			{
				fastf_t a, b;

				a = atof( prev_rec[field_no] );
				b = atof( &curr_rec[field_no][i] );
				sprintf( curr_rec[field_no], "%-#*E", FIELD_LENGTH-6, a+b );
			}
			else
			{
				int a, b;

				a = atoi( prev_rec[field_no] );
				b = atoi( &curr_rec[field_no][i] );
				sprintf( curr_rec[field_no], "%d", a+b );
			}
		}
	}
}

HIDDEN void
get_large_field_input(FILE *fp, int write_flag)
{
	char **tmp_rec;
	int field_no;
	int card_len;
	int last_field;
	int i;

	tmp_rec = prev_rec;
	prev_rec = curr_rec;
	curr_rec = tmp_rec;

	for( field_no=0 ; field_no < NO_OF_FIELDS ; field_no ++ )
		curr_rec[field_no][0] = '\0';

	card_len = strlen( line );
	last_field = (card_len - 8)/16 + 1;
	if( ((last_field - 1) * 16 + 8) < card_len )
		last_field++;
	if( last_field > 5 )
		last_field = 5;
	strncpy( curr_rec[0], line, 8 );
	curr_rec[0][8] = '\0';
	for( field_no=1 ; field_no < last_field ; field_no++ )
	{
		strncpy( curr_rec[field_no], &line[field_no*16 - 8], 16 );
		curr_rec[field_no][16] = '\0';
	}

	/* remove the newline from the end of the last field */
	i = strlen( curr_rec[last_field-1] ) - 1;
	while( isspace( curr_rec[last_field-1][i] ) || curr_rec[last_field-1][i] == '\012' || curr_rec[last_field-1][i] == '\015' )
		i--;
	curr_rec[last_field-1][++i] = '\0';

	if( next_line[0] == '*' )
	{
		if( !get_next_record( fp, 0, 0 ) )
		{
			bu_exit(1, "unexpected end of INPUT at line #%d\n", line_count );
		}

		card_len = strlen( line );
		last_field = (card_len - 8)/16 + 1;
		if( ((last_field - 1) * 16 + 8) < card_len )
			last_field++;
		if( last_field > 5 )
			last_field = 5;
		last_field += 4;
		for( field_no=5 ; field_no < last_field ; field_no++ )
		{
			strncpy( curr_rec[field_no], &line[(field_no-4)*16 - 8], 16 );
			curr_rec[field_no][16] = '\0';
		}
	}

	if( write_flag )
		write_fields();
}

HIDDEN void
get_small_field_input(FILE *fp, int write_flag)
{
	char **tmp_rec;
	int field_no;
	int card_len;
	int last_field;

	tmp_rec = prev_rec;
	prev_rec = curr_rec;
	curr_rec = tmp_rec;

	for( field_no=0 ; field_no < NO_OF_FIELDS ; field_no ++ )
		curr_rec[field_no][0] = '\0';

	card_len = strlen( line );
	last_field = card_len/8 + 1;
	if( (last_field * 8) < card_len )
		last_field++;
	if( last_field > 9 )
		last_field = 9;
	strncpy( curr_rec[0], line, 8 );
	curr_rec[0][8] = '\0';
	for( field_no=2 ; field_no < last_field+1 ; field_no++ )
	{
		strncpy( curr_rec[field_no-1], &line[(field_no-1)*8], 8 );
		curr_rec[field_no-1][8] = '\0';
	}

	if( next_line[0] == '+' )
	{
		if( !get_next_record( fp, 0, 0 ) )
		{
			bu_exit(1, "unexpected end of INPUT at line #%d\n", line_count );
		}

		card_len = strlen( line );
		last_field = card_len/8 + 1;
		if( (last_field * 8) < card_len )
			last_field++;
		if( last_field > 9 )
			last_field = 9;
		last_field += 9;
		for( field_no=10 ; field_no < last_field+1 ; field_no++ )
		{
			strncpy( curr_rec[field_no-1], &line[(field_no-9)*8], 8 );
			curr_rec[field_no-1][8] = '\0';
		}
	}

	if( write_flag )
		write_fields();
}

HIDDEN void
get_free_form_input(FILE *fp, int write_flag)
{
	char **tmp_rec;
	int field_no;
	int i, j;

	i = (-1);
	while( isspace( line[++i] ) );
	if( line[i] == '=' && isdigit( line[i+1] ) )
	{
		int count;

		count = atoi( &line[i+1] );

		i = (-1);
		while( isspace( prev_line[++i] ) );
		if( prev_line[i] == '=' && isdigit( prev_line[i+1] ) )
		{
			bu_log( "Cannot use consecutive replication cards:\n" );
			bu_log( "%s", prev_line );
			bu_log( "%s", line );
			bu_exit(1, "ERROR: Cannot use consecutive replication cards\n" );
		}

		for( i=0 ; i<count ; i++ )
		{
			strncpy( line, prev_line, MAXLINELEN );
			get_free_form_input( fp, write_flag );
		}
		return;
	}
	else
	{
		tmp_rec = prev_rec;
		prev_rec = curr_rec;
		curr_rec = tmp_rec;

		for( field_no=0 ; field_no < NO_OF_FIELDS ; field_no ++ )
			curr_rec[field_no][0] = '\0';

		field_no = (-1);
		i = 0;
		while( ++field_no < NO_OF_FIELDS && line[i] != '\0' )
		{
			while( line[i] != '\0' && isspace( line[i] ) )
				i++;
			j = (-1);
			while( line[i] != '\0' && line[i] != ',' && !isspace( line[i] ) )
				curr_rec[field_no][++j] = line[i++];
			curr_rec[field_no][++j] = '\0';
			if( line[i] == ',' )
				i++;
		}

		if( strchr( curr_rec[9], '+' ) )
		{
			/* continuation card */
			if( !get_next_record( fp, 0, 0 ) )
			{
				bu_exit(1, "unexpected end of INPUT at line #%d\n", line_count );
			}

			i = 0;
			while( ++field_no < NO_OF_FIELDS && line[i] != '\0' )
			{
				while( line[i] != '\0' && isspace( line[i] ) )
					i++;
				j = (-1);
				while( line[i] != '\0' && line[i] != ',' && !isspace( line[i] ) )
					curr_rec[field_no][++j] = line[i++];
				curr_rec[field_no][++j] = '\0';
				if( line[i] == ',' )
					i++;
			}
		}
	}

	do_silly_nastran_shortcuts();

	if( write_flag )
		write_fields();

}

HIDDEN int
get_next_record( FILE *fp, int call_input, int write_flag )
{
	char *tmp;
	int form;
	int i;

	form = UNKNOWN;

	/* read next line of input, skipping comments */
	while( 1 )
	{
		line_count++;
		tmp = bu_fgets( prev_line, MAXLINELEN, fp );
		if( !tmp || prev_line[0] != '$' )
			break;
	}

	/* Convert to all UPPER case */
	i = (-1);
	while( prev_line[++i] != '\0' )
	{
		if( isalpha( prev_line[i] ) )
			prev_line[i] = toupper( prev_line[i] );
	}

	if( tmp == (char *)NULL )
	{
		/* encountered end of input file */
		if( input_status != INPUT_NULL )
		{
			/* still have "next_line" to process */
			tmp = prev_line;
			prev_line = line;
			line = next_line;
			next_line = tmp;

			/* set flag to indicate end of input */
			input_status = INPUT_NULL;
		}
		else	/* no more input */
			return( 0 );
	}
	else
	{
		/* put next line of input into "line"
		 * and save just read line in "next_line"
		 */
		tmp = prev_line;
		prev_line = line;
		line = next_line;
		next_line = tmp;
	}

	if( !call_input )
		return( 1 );

	/* check which format is being used */
	tmp = strchr( line, ',' );
	if( tmp && tmp - line < 10 )
		form = FREE_FIELD;
	else
	{
		tmp = strchr( line, '=' );
		if( tmp && tmp - line < 10 )
			form = FREE_FIELD;
	}

	/* if this is FREE_FIELD, call approporiate processor */
	if( form == FREE_FIELD )
	{
		get_free_form_input( fp, write_flag );
		return( 1 );
	}

	/* not FREE_FIELD, check for LARGE_FIELD */
	i = (-1);
	while( ++i < 8 && (isalpha( line[i] ) || isspace( line[i] )) );
	if( i < 8 && line[i] == '*' )
		form = LARGE_FIELD;

	if( form == LARGE_FIELD )
	{
		get_large_field_input( fp, write_flag );
		return( 1 );
	}

	/* default is SMALL_FIELD */
	form = SMALL_FIELD;
	get_small_field_input( fp, write_flag );
	return( 1 );

}

HIDDEN void
log_line(char *str)
{
	int i;

	i = (-1);
	while( ++i < MAXLINELEN && line[i] != '\n' )
		if( line[i] == '\0' )
			line[i] = ' ';
	bu_log( "%s:\n", str );
	bu_log( "%s", line );

}

HIDDEN void
convert_input(void)
{

	reset_input();

	while( get_next_record( fpin, 1, 1 ) );
}

HIDDEN int
convert_cs(struct coord_sys *cs)
{
	struct coord_sys *cs2;
	point_t tmp_orig, tmp_pt1, tmp_pt2;

	if( !cs->rid )
		return( 0 );

	for( BU_LIST_FOR( cs2, coord_sys, &coord_head.l ) )
	{
		if( cs2->cid != cs->rid )
			continue;
		break;
	}

	if( BU_LIST_IS_HEAD( &cs2->l, &coord_head.l ) )
	{
		bu_exit(1, "A coordinate system is defined in terms of a non-existent coordinate system!!!\n" );
	}

	if( convert_pt( cs->origin, cs2, tmp_orig ) )
		return( 1 );

	if( convert_pt( cs->v1, cs2, tmp_pt1 ) )
		return( 1 );

	if( convert_pt( cs->v2, cs2, tmp_pt2 ) )
		return( 1 );

	VMOVE( cs->origin, tmp_orig );
	VSUB2( cs->v3, tmp_pt1, cs->origin );
	VUNITIZE( cs->v3 );
	VSUB2( cs->v1, tmp_pt2, cs->origin );
	VCROSS( cs->v2, cs->v3, cs->v1 );
	VUNITIZE( cs->v2 );
	VCROSS( cs->v1, cs->v3, cs->v2 );
	cs->rid = 0;
	return( 0 );
}

HIDDEN int
convert_pt( const point_t pt, struct coord_sys *cs, point_t out_pt )
{
	point_t tmp_pt;
	fastf_t c1, c2, c3, c4;

	if( cs->rid )
	{
		if( convert_cs( cs ) )
			return( 1 );
	}

	switch( cs->type )
	{
		case CORD_CYL:
			c1 = pt[X] * cos( pt[Y] * bn_degtorad );
			c2 = pt[X] * sin( pt[Y] * bn_degtorad );
			VJOIN3( tmp_pt, cs->origin, c1, cs->v1, c2, cs->v2, pt[Z], cs->v3);
			VMOVE( out_pt, tmp_pt );
			break;

		case CORD_RECT:
			VJOIN3( tmp_pt, cs->origin, pt[X], cs->v1, pt[Y], cs->v2, pt[Z], cs->v3 );
			VMOVE( out_pt, tmp_pt );
			break;

		case CORD_SPH:
			c4 = pt[X] * sin( pt[Y] * bn_degtorad );
			c1 = c4 * cos( pt[Z] * bn_degtorad );
			c2 = c4 * sin( pt[Z] * bn_degtorad );
			c3 = pt[X] * cos( pt[Y] * bn_degtorad );
			VJOIN3( tmp_pt, cs->origin, c1, cs->v1, c2, cs->v2, c3, cs->v3);
			VMOVE( out_pt, tmp_pt );
			break;

		default:
			bu_exit(1, "Unrecognized coordinate system type (%c) for cid=%d!\n",
				cs->type, cs->cid );
	}
	return( 0 );
}

/* routine to convert a grid point ot BRL-CAD (default cartesian)
 *
 *	returns:
 *		0 on success
 *		1 if cannot convert
 */

HIDDEN int
convert_grid(int index)
{
	struct coord_sys *cs;
	point_t tmp_pt;

	if( !g_pts[index].cid )
		return( 0 );

	for( BU_LIST_FOR( cs, coord_sys, &coord_head.l ) )
	{
		if( cs->cid != g_pts[index].cid )
			continue;
		break;
	}

	if( BU_LIST_IS_HEAD( &cs->l, &coord_head.l ) )
	{
		bu_exit(1, "No coordinate system defined for grid point #%d!\n", g_pts[index].gid );
	}

	if( convert_pt( g_pts[index].pt, cs, tmp_pt ) )
		return( 1 );

	VMOVE( g_pts[index].pt, tmp_pt );
	g_pts[index].cid = 0;

	return( 0 );
}

HIDDEN int
get_gridi(int gid)
{
	int i;
	int found=(-1);

	for( i=0 ; i<grid_used ; i++ )
	{
		if( g_pts[i].gid != gid )
			continue;

		found = i;
		break;
	}

	if( found < 0 )
	{
		bu_exit(1, "Grid point %d is not defined!\n", gid );
	}

	if( g_pts[found].cid )
	{
		if( !convert_grid( found ) )
		{
			bu_exit(1, "Could not convert grid point #%d to BRL-CAD!\n", gid );
		}
	}

	return( found );
}

HIDDEN void
get_grid(int gid, fastf_t *pt)
{
	int i;
	int found=(-1);

	for( i=0 ; i<grid_used ; i++ )
	{
		if( g_pts[i].gid != gid )
			continue;

		found = i;
		break;
	}

	if( found < 0 )
	{
		bu_exit(1, "Grid point %d is not defined!\n", gid );
	}

	if( g_pts[found].cid )
	{
		if( !convert_grid( found ) )
		{
			bu_exit(1, "Could not convert grid point #%d to BRL-CAD!\n", gid );
		}
	}

	VMOVE( pt, g_pts[found].pt );
}

HIDDEN void
get_coord_sys(void)
{
	int form;
	char type;
	char *ptr;
	struct coord_sys *cs;
	int i,gid;
	double tmp[3];
	point_t tmp_pt;

	form = atoi( &curr_rec[0][4] );
	if( form != 1 && form != 2 )
	{
		bu_log( "unrecognized form for coordinate system definition (%d):\n", form );
		bu_log( "%s\n", line );
		return;
	}
	type = curr_rec[0][5];

	if( type != CORD_CYL && type != CORD_RECT && type != CORD_SPH )
	{
		bu_log( "unrecognized coordinate system type (%c):\n", type );
		bu_log( "%s\n", line );
		return;
	}

	ptr = strtok( line, delims );
	ptr = strtok( (char *)NULL, delims );
	if( !ptr )
	{
		log_line( "Incomplete coordinate system definition" );
		return;
	}

	BU_GETSTRUCT( cs, coord_sys );

	switch( form )
	{
		case 1:
			cs->type = type;
			cs->cid = atoi( curr_rec[1] );
			gid = atoi( curr_rec[2] );
			get_grid( gid, cs->origin );
			gid = atoi( curr_rec[3] );
			get_grid( gid, tmp_pt );
			VSUB2( cs->v3, tmp_pt, cs->origin );
			VUNITIZE( cs->v3 );
			gid = atoi( curr_rec[4] );
			get_grid( gid, tmp_pt );
			VSUB2( cs->v1, tmp_pt, cs->origin );
			VCROSS( cs->v2, cs->v3, cs->v1 );
			VUNITIZE( cs->v2 );
			VCROSS( cs->v1, cs->v2, cs->v3 );
			BU_LIST_INSERT( &coord_head.l, &cs->l );

			if( !strlen( curr_rec[5] ) )
				break;

			BU_GETSTRUCT( cs, coord_sys );
			cs->type = type;
			cs->cid = atoi( curr_rec[5] );
			gid = atoi( curr_rec[6] );
			get_grid( gid, cs->origin );
			gid = atoi( curr_rec[7] );
			get_grid( gid, tmp_pt );
			VSUB2( cs->v3, tmp_pt, cs->origin );
			VUNITIZE( cs->v3 );
			gid = atoi( curr_rec[8] );
			get_grid( gid, tmp_pt );
			VSUB2( cs->v1, tmp_pt, cs->origin );
			VCROSS( cs->v2, cs->v3, cs->v1 );
			VUNITIZE( cs->v2 );
			VCROSS( cs->v1, cs->v2, cs->v3 );
			BU_LIST_INSERT( &coord_head.l, &cs->l );

			break;
		case 2:
			cs->type = type;
			cs->cid = atoi( curr_rec[1] );
			cs->rid = atoi( curr_rec[2] );
			for( i=0 ; i<3 ; i++ )
				tmp[i] = atof( curr_rec[3+i] );
			VMOVE( cs->origin, tmp );
			for( i=0 ; i<3 ; i++ )
				tmp[i] = atof( curr_rec[6+i] );
			VMOVE( cs->v1, tmp );
			for( i=0 ; i<3 ; i++ )
				tmp[i] = atof( curr_rec[9+i] );
			VMOVE( cs->v2, tmp );

			if( !cs->rid )
			{
				point_t tmp_pt1, tmp_pt2;

				/* this coordinate system is defined in terms of the default */
				VMOVE( tmp_pt1, cs->v1 );
				VMOVE( tmp_pt2, cs->v2 );

				VSUB2( cs->v3, tmp_pt1, cs->origin );
				VUNITIZE( cs->v3 );
				VSUB2( cs->v1, tmp_pt2, cs->origin );
				VCROSS( cs->v2, cs->v3, cs->v1 );
				VUNITIZE( cs->v2 );
				VCROSS( cs->v1, cs->v3, cs->v2 );
			}

			BU_LIST_INSERT( &coord_head.l, &cs->l );
			break;
	}
}

HIDDEN int
convert_all_cs(void)
{
	int ret=0;
	struct coord_sys *cs;

	for( BU_LIST_FOR( cs, coord_sys, &coord_head.l ) )
	{
		if( convert_cs( cs ) )
			ret = 1;
	}

	return( ret );
}

HIDDEN int
convert_all_pts(void)
{
	int i;
	int ret=0;

	for( i=0 ; i<grid_used ; i++ )
	{
		if( convert_grid( i ) )
			ret = 1;
	}

	return( ret );
}

HIDDEN int
get_pid_index(int pid)
{
	struct pshell *psh;
	int index=0;

	if( pid == 0 )
		return( 0 );

	for( BU_LIST_FOR( psh, pshell, &pshell_head.l ) )
	{
		index++;
		if( psh->pid == pid )
			return( index );
	}

	return( 0 );
}

HIDDEN void
get_cquad4(void)
{
	int pid;
	int g1, g2, g3, g4;
	int gin1, gin2, gin3, gin4;
	point_t pt1, pt2, pt3, pt4;
	struct vertex **v[3];
	struct faceuse *fu;
	struct shell *s;
	int pid_index=0;

	pid = atoi( curr_rec[2] );

	pid_index = get_pid_index( pid );

	g1 = atoi( curr_rec[3] );

	g2 = atoi( curr_rec[4] );

	g3 = atoi( curr_rec[5] );

	g4 = atoi( curr_rec[6] );

	gin1 = get_gridi( g1 );
	gin2 = get_gridi( g2 );
	gin3 = get_gridi( g3 );
	gin4 = get_gridi( g4 );

	VSCALE( pt1, g_pts[gin1].pt, conv[units] );
	VSCALE( pt2, g_pts[gin2].pt, conv[units] );
	VSCALE( pt3, g_pts[gin3].pt, conv[units] );
	VSCALE( pt4, g_pts[gin4].pt, conv[units] );

	if( !nmg_model && !pid )
	{
		struct nmgregion *r;

		nmg_model = nmg_mm();
		r = nmg_mrsv( nmg_model );
		nmg_shell = BU_LIST_FIRST( shell, &r->s_hd );
	}

	if( !pid )
		s = nmg_shell;
	else
	{
		struct pshell *psh;
		int found=0;

		/* find pshell entry for this pid */
		for( BU_LIST_FOR( psh, pshell, &pshell_head.l ) )
		{
			if( psh->pid == pid )
			{
				found = 1;
				break;
			}
		}

		if( !found )
		{
			bu_log( "Cannot find PSHELL entry for a CQUAD4 element (ignoring)!\n" );
			write_fields();
			return;
		}

		if( psh->s )
			s = psh->s;
		else
		{
			struct model *m;
			struct nmgregion *r;

			m = nmg_mm();
			r = nmg_mrsv( m );
			s = BU_LIST_FIRST( shell, &r->s_hd );
			psh->s = s;
		}
	}

	v[0] = &g_pts[gin1].v[pid_index];
	v[1] = &g_pts[gin2].v[pid_index];
	v[2] = &g_pts[gin3].v[pid_index];

	fu = nmg_cmface( s, v, 3 );

	if( !g_pts[gin1].v[pid_index]->vg_p )
		nmg_vertex_gv( g_pts[gin1].v[pid_index], pt1 );
	if( !g_pts[gin2].v[pid_index]->vg_p )
		nmg_vertex_gv( g_pts[gin2].v[pid_index], pt2 );
	if( !g_pts[gin3].v[pid_index]->vg_p )
		nmg_vertex_gv( g_pts[gin3].v[pid_index], pt3 );
	nmg_calc_face_g( fu );

	v[0] = &g_pts[gin1].v[pid_index];
	v[1] = &g_pts[gin3].v[pid_index];
	v[2] = &g_pts[gin4].v[pid_index];

	fu = nmg_cmface( s, v, 3 );

	if( !g_pts[gin4].v[pid_index]->vg_p )
		nmg_vertex_gv( g_pts[gin4].v[pid_index], pt4 );
	nmg_calc_face_g( fu );
}

HIDDEN void
get_ctria3(void)
{
	int pid;
	int g1, g2, g3;
	int gin1, gin2, gin3;
	point_t pt1, pt2, pt3;
	struct vertex **v[3];
	struct faceuse *fu;
	struct shell *s;
	struct pshell *psh;
	int pid_index=0;

	pid = atoi( curr_rec[2] );

	pid_index = get_pid_index( pid );

	g1 = atoi( curr_rec[3] );

	g2 = atoi( curr_rec[4] );

	g3 = atoi( curr_rec[5] );

	gin1 = get_gridi( g1 );
	gin2 = get_gridi( g2 );
	gin3 = get_gridi( g3 );

	v[0] = &g_pts[gin1].v[pid_index];
	v[1] = &g_pts[gin2].v[pid_index];
	v[2] = &g_pts[gin3].v[pid_index];

	VSCALE( pt1, g_pts[gin1].pt, conv[units] );
	VSCALE( pt2, g_pts[gin2].pt, conv[units] );
	VSCALE( pt3, g_pts[gin3].pt, conv[units] );

	if( !nmg_model && !pid )
	{
		struct nmgregion *r;

		nmg_model = nmg_mm();
		r = nmg_mrsv( nmg_model );
		nmg_shell = BU_LIST_FIRST( shell, &r->s_hd );
	}

	if( !pid )
		s = nmg_shell;
	else
	{
		int found=0;

		/* find pshell entry for this pid */
		for( BU_LIST_FOR( psh, pshell, &pshell_head.l ) )
		{
			if( psh->pid == pid )
			{
				found = 1;
				break;
			}
		}

		if( !found )
		{
			bu_log( "Cannot find PSHELL entry for a CTRIA3 element (ignoring)!\n" );
			write_fields();
			return;
		}

		if( psh->s )
			s = psh->s;
		else
		{
			struct model *m;
			struct nmgregion *r;

			m = nmg_mm();
			r = nmg_mrsv( m );
			s = BU_LIST_FIRST( shell, &r->s_hd );
			psh->s = s;
		}
	}

	fu = nmg_cmface( s, v, 3 );

	if( !g_pts[gin1].v[pid_index]->vg_p )
		nmg_vertex_gv( g_pts[gin1].v[pid_index], pt1 );
	if( !g_pts[gin2].v[pid_index]->vg_p )
		nmg_vertex_gv( g_pts[gin2].v[pid_index], pt2 );
	if( !g_pts[gin3].v[pid_index]->vg_p )
		nmg_vertex_gv( g_pts[gin3].v[pid_index], pt3 );

	nmg_calc_face_g( fu );
}

HIDDEN void
get_cbar(void)
{
	int eid, pid;
	int g1, g2;
	point_t pt1, pt2;
	fastf_t radius;
	vect_t height;
	struct pbar *pb;
	char cbar_name[NAMESIZE];

	eid = atoi( curr_rec[1] );

	pid = atoi( curr_rec[2] );
	if( !pid )
	{
		if( bar_def_pid )
			pid = bar_def_pid;
		else
			pid = eid;
	}

	g1 = atoi( curr_rec[3] );

	g2 = atoi( curr_rec[4] );

	get_grid( g1, pt1 );
	get_grid( g2, pt2 );

	for( BU_LIST_FOR( pb, pbar, &pbar_head.l ) )
	{
		if( pb->pid == pid )
			break;
	}

	if( BU_LIST_IS_HEAD( &pb->l, &pbar_head.l ) )
	{
		log_line( "Non-existent PID referenced in CBAR" );
		return;
	}

	VSCALE( pt1, pt1, conv[units] );
	VSCALE( pt2, pt2, conv[units] );

	radius = sqrt( pb->area/bn_pi );
	radius = radius * conv[units];

	VSUB2( height, pt2, pt1 );

	sprintf( cbar_name, "cbar.%d", eid );
	mk_rcc( fpout, cbar_name, pt1, height, radius );

	mk_addmember( cbar_name, &pb->head.l, NULL, WMOP_UNION );
}

int
main(int argc, char **argv)
{
	int c;
	int i;
	struct pshell *psh;
	struct pbar *pb;
	struct wmember head;
	struct wmember all_head;
	char *nastran_file = "Converted from NASTRAN file (stdin)";

	fpin = stdin;

	units = INCHES;

	/* XXX These need to be improved */
	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;

	while( (c=bu_getopt( argc, argv, "x:X:t:ni:o:m")) != EOF )
	{
		switch( c )
		{
			case 'x':
				sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
				bu_printb( "librt RT_G_DEBUG", RT_G_DEBUG, DEBUG_FORMAT );
				bu_log("\n");
				break;
			case 'X':
				sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
				bu_printb( "librt rt_g.NMG_debug", rt_g.NMG_debug, NMG_DEBUG_FORMAT );
				bu_log("\n");
				break;
			case 't':		/* calculational tolerance */
				tol.dist = atof( bu_optarg );
				tol.dist_sq = tol.dist * tol.dist;
			case 'n':
				polysolids = 0;
				break;
			case 'm':
				units = MM;
				break;
			case 'i':
				nastran_file = bu_optarg;
				fpin = fopen( bu_optarg, "r" );
				if( fpin == (FILE *)NULL )
				{
					bu_log( "Cannot open NASTRAN file (%s) for reading!\n", bu_optarg );
					bu_exit(1, Usage, argv[0] );
				}
				break;
			case 'o':
				output_file = bu_optarg;
				break;
		}
	}

	fpout = wdb_fopen( output_file );
	if( fpout == NULL )
	{
		bu_log( "Cannot open BRL-CAD file (%s) for writing!\n", output_file );
		bu_exit(1, Usage, argv[0] );
	}

	if( !fpin || !fpout )
	{
		bu_exit(1, Usage, argv[0] );
	}

	line = (char *)bu_malloc( MAXLINELEN, "line" );
	next_line = (char *)bu_malloc( MAXLINELEN, "next_line" );
	prev_line = (char *)bu_malloc( MAXLINELEN, "prev_line" );
	curr_rec = (char **)bu_calloc( NO_OF_FIELDS, sizeof( char *), "curr_rec" );
	for( i=0 ; i<NO_OF_FIELDS ; i++ )
		curr_rec[i] = (char *)bu_malloc( sizeof( char )*FIELD_LENGTH, "curr_rec[i]" );
	prev_rec = (char **)bu_calloc( NO_OF_FIELDS, sizeof( char *), "prev_rec" );
	for( i=0 ; i<NO_OF_FIELDS ; i++ )
		prev_rec[i] = (char *)bu_malloc( sizeof( char )*FIELD_LENGTH, "prev_rec[i]" );

	/* first pass, find start of NASTRAN "bulk data" */
	start_off = (-1);
	bulk_data_start_line = 0;
	while( bu_fgets( line, MAXLINELEN, fpin ) )
	{
		bulk_data_start_line++;
		if( strncmp( line, "BEGIN BULK", 10 ) )
			continue;

		start_off = ftell( fpin );
		break;
	}

	if( start_off < 0 )
	{
		bu_log( "Cannot find start of bulk data in NASTRAN file!\n" );
		bu_exit(1, Usage, argv[0] );
	}

	/* convert BULK data deck into something reasonable */
	fptmp = bu_temp_file(NULL, 0);
	if( fptmp == NULL )
	{
		perror( argv[0] );
		bu_exit(1, "Cannot open temporary file\n" );
	}
	convert_input();

	/* initialize some lists */
	BU_LIST_INIT( &coord_head.l );
	BU_LIST_INIT( &pbar_head.l );
	BU_LIST_INIT( &pshell_head.l );
	BU_LIST_INIT( &all_head.l );

	nmg_model = (struct model *)NULL;

	/* count grid points */
	fseek( fptmp, 0, SEEK_SET );
	while( bu_fgets( line, MAXLINELEN, fptmp  ) )
	{
		if( !strncmp( line, "GRID", 4 ) )
			grid_count++;
	}
	if( !grid_count )
	{
		bu_exit(1, "No geometry in this NASTRAN file!\n" );
	}

	/* get default values and properties */
	fseek( fptmp, 0, SEEK_SET );
	while( get_next_record( fptmp, 1, 0 ) )
	{
		if( !strncmp( curr_rec[0], "BAROR", 5 ) )
		{
			/* get BAR defaults */
			bar_def_pid = atoi( curr_rec[2] );
		}
		else if( !strncmp( curr_rec[0], "PBAR", 4 ) )
		{
			struct pbar *pb;

			BU_GETSTRUCT( pb, pbar );

			pb->pid = atoi( curr_rec[1] );
			pb->mid = atoi( curr_rec[2] );
			pb->area = atof( curr_rec[3] );

			BU_LIST_INIT( &pb->head.l );

			BU_LIST_INSERT( &pbar_head.l, &pb->l );
		}
		else if( !strncmp( curr_rec[0], "PSHELL", 6 ) )
		{
			BU_GETSTRUCT( psh, pshell );

			psh->s = (struct shell *)NULL;
			psh->pid = atoi( curr_rec[1] );
			psh->mid = atoi( curr_rec[2] );
			psh->thick = atof( curr_rec[3] );
			BU_LIST_INSERT( &pshell_head.l, &psh->l );
			pshell_count++;
		}
	}

	/* allocate storage for grid points */
	g_pts = (struct grid_point *)bu_calloc( grid_count, sizeof( struct grid_point ), "grid points" );

	/* get all grid points */
	fseek( fptmp, 0, SEEK_SET );
	while( get_next_record( fptmp, 1, 0 ) )
	{
		int gid;
		int cid;
		double tmp[3];

		if( strncmp( curr_rec[0], "GRID", 4 ) )
			continue;

		gid = atoi( curr_rec[1] );
		cid = atoi( curr_rec[2] );

		for( i=0 ; i<3 ; i++ )
		{
			tmp[i] = atof( curr_rec[i+3] );
		}

		g_pts[grid_used].gid = gid;
		g_pts[grid_used].cid = cid;
		g_pts[grid_used].v = (struct vertex **)bu_calloc( pshell_count + 1, sizeof( struct vertex *), "g_pts vertex array" );;
		VMOVE( g_pts[grid_used].pt, tmp );
		grid_used++;
	}


	/* find coordinate systems */
	fseek( fptmp, 0, SEEK_SET );
	while( get_next_record( fptmp, 1, 0 ) )
	{
		if( strncmp( curr_rec[0], "CORD", 4 ) )
			continue;

		get_coord_sys();
	}
#if 0
	bu_log( "Original grid:\n" );
	for( i=0 ; i<grid_used ; i++ )
	{
		bu_log( "Grid point: gid=%d, cid=%d, (%g %g %g)\n", g_pts[i].gid,
			g_pts[i].cid, V3ARGS( g_pts[i].pt ) );
	}

	bu_log( "\nOriginal coordinate systems:\n" );
	for( BU_LIST_FOR( cs, coord_sys, &coord_head.l ) )
	{
		bu_log( "cid=%d, type=%c, rid=%d\n", cs->cid, cs->type, cs->rid );
		bu_log( "\torigin=(%g %g %g)\n", V3ARGS( cs->origin ) );
		bu_log( "\tv1=(%g %g %g)\n", V3ARGS( cs->v1 ) );
		bu_log( "\tv2=(%g %g %g)\n", V3ARGS( cs->v2 ) );
		bu_log( "\tv3=(%g %g %g)\n", V3ARGS( cs->v3 ) );
	}
#endif
	/* convert everything to BRL-CAD coordinate system */
	i = 0;
	while( convert_all_cs() || convert_all_pts() )
	{
		i++;
		if( i > 10 )
		{
			bu_exit(1, "Cannot convert to default coordinate system, check for circular definition\n" );
		}
	}

#if 0
	bu_log( "Converted grid:\n" );
	for( i=0 ; i<grid_used ; i++ )
	{
		bu_log( "Grid point: gid=%d, cid=%d, (%g %g %g)\n", g_pts[i].gid,
			g_pts[i].cid, V3ARGS( g_pts[i].pt ) );
	}

	bu_log( "\nConverted coordinate systems:\n" );
	for( BU_LIST_FOR( cs, coord_sys, &coord_head.l ) )
	{
		bu_log( "cid=%d, type=%c, rid=%d\n", cs->cid, cs->type, cs->rid );
		bu_log( "\torigin=(%g %g %g)\n", V3ARGS( cs->origin ) );
		bu_log( "\tv1=(%g %g %g)\n", V3ARGS( cs->v1 ) );
		bu_log( "\tv2=(%g %g %g)\n", V3ARGS( cs->v2 ) );
		bu_log( "\tv3=(%g %g %g)\n", V3ARGS( cs->v3 ) );
	}
#endif

	mk_id( fpout, nastran_file );

	/* get elements */
	fseek( fptmp, 0, SEEK_SET );
	while( get_next_record( fptmp, 1, 0 ) )
	{
		if( !strncmp( curr_rec[0], "CBAR", 4 ) )
			get_cbar();
		else if( !strncmp( curr_rec[0], "CROD", 4 ) )
			get_cbar();
		else if( !strncmp( curr_rec[0], "CTRIA3", 6 ) )
			get_ctria3();
		else if( !strncmp( curr_rec[0], "CQUAD4", 6 ) )
			get_cquad4();
	}

	if( nmg_model )
	{
		nmg_rebound( nmg_model, &tol );
		if( polysolids )
			write_shell_as_polysolid( fpout, "pshell.0", nmg_shell );
		else
			mk_nmg( fpout, "pshell.0", nmg_model );
	}

	BU_LIST_INIT( &head.l );
	for( BU_LIST_FOR( psh, pshell, &pshell_head.l ) )
	{
		struct model *m;
		char name[NAMESIZE];

		if( !psh->s )
			continue;

		m = nmg_find_model( &psh->s->l.magic );
		nmg_rebound( m, &tol );
		nmg_fix_normals( psh->s, &tol );
		if( psh->thick > tol.dist )
		{
			nmg_model_face_fuse( m, &tol );
			nmg_hollow_shell( psh->s, psh->thick*conv[units], 1, &tol );
		}
		sprintf( name, "pshell.%d", psh->pid );
		if( polysolids )
			write_shell_as_polysolid( fpout, name, psh->s );
		else
			mk_nmg( fpout, name, m );

		mk_addmember( name, &head.l, NULL, WMOP_UNION );
	}
	if( BU_LIST_NON_EMPTY( &head.l ) )
	{
		mk_lfcomb( fpout, "shells", &head, 0 );
		mk_addmember( "shells", &all_head.l, NULL, WMOP_UNION );
	}

	BU_LIST_INIT( &head.l );
	for( BU_LIST_FOR( pb, pbar, &pbar_head.l ) )
	{
		char name[NAMESIZE];

		if( BU_LIST_IS_EMPTY( &pb->head.l ) )
			continue;

		sprintf( name, "pbar_group.%d", pb->pid );
		mk_lfcomb( fpout, name, &pb->head, 0 );

		mk_addmember( name, &head.l, NULL, WMOP_UNION );
	}
	if( BU_LIST_NON_EMPTY( &head.l ) )
	{
		mk_lfcomb( fpout, "pbars", &head, 0 );
		mk_addmember( "pbars", &all_head.l, NULL, WMOP_UNION );
	}

	if( BU_LIST_NON_EMPTY( &all_head.l ) )
	{
		mk_lfcomb( fpout, "all", &all_head, 0 );
	}
	wdb_close(fpout);
	return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.19
log
@whoosh, another 10% complete on the bu_bomb to bu_exit conversion review.  also includes a slew of custom exit() calls that can use bu_exit() as well as toning down a slew of overzealous exclamation point use.  (20% complete overall)
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.18 2007/10/14 22:15:54 brlcad Exp $";
d117 3
a119 3
static struct rt_wdb		*fdout;		/* brlcad output file */
static FILE			*fdin;		/* NASTRAN input file */
static FILE			*fdtmp;		/* temporary version of NASTRAN input */
d144 1
a144 1
HIDDEN int get_next_record( FILE *fd, int call_input, int write_flag );
d167 1
a167 1
	fseek( fdin, start_off, SEEK_SET );
d170 1
a170 1
	tmp = bu_fgets( next_line, MAXLINELEN, fdin );
d172 1
a172 1
		tmp = bu_fgets( next_line, MAXLINELEN, fdin );
d197 1
a197 1
		fprintf( fdtmp, "%s,", &curr_rec[i][j] );
d199 1
a199 1
	fprintf( fdtmp, "\n" );
d248 1
a248 1
get_large_field_input(FILE *fd, int write_flag)
d285 1
a285 1
		if( !get_next_record( fd, 0, 0 ) )
d309 1
a309 1
get_small_field_input(FILE *fd, int write_flag)
d339 1
a339 1
		if( !get_next_record( fd, 0, 0 ) )
d363 1
a363 1
get_free_form_input(FILE *fd, int write_flag)
d390 1
a390 1
			get_free_form_input( fd, write_flag );
d420 1
a420 1
			if( !get_next_record( fd, 0, 0 ) )
d448 1
a448 1
get_next_record( FILE *fd, int call_input, int write_flag )
d460 1
a460 1
		tmp = bu_fgets( prev_line, MAXLINELEN, fd );
d518 1
a518 1
		get_free_form_input( fd, write_flag );
d530 1
a530 1
		get_large_field_input( fd, write_flag );
d536 1
a536 1
	get_small_field_input( fd, write_flag );
d561 1
a561 1
	while( get_next_record( fdin, 1, 1 ) );
d1156 1
a1156 1
	mk_rcc( fdout, cbar_name, pt1, height, radius );
d1172 1
a1172 1
	fdin = stdin;
d1208 2
a1209 2
				fdin = fopen( bu_optarg, "r" );
				if( fdin == (FILE *)NULL )
d1221 2
a1222 2
	fdout = wdb_fopen( output_file );
	if( fdout == NULL )
d1228 1
a1228 1
	if( !fdin || !fdout )
d1246 1
a1246 1
	while( bu_fgets( line, MAXLINELEN, fdin ) )
d1252 1
a1252 1
		start_off = ftell( fdin );
d1263 2
a1264 2
	fdtmp = tmpfile();
	if( fdtmp == NULL )
d1280 2
a1281 2
	fseek( fdtmp, 0, SEEK_SET );
	while( bu_fgets( line, MAXLINELEN, fdtmp  ) )
d1292 2
a1293 2
	fseek( fdtmp, 0, SEEK_SET );
	while( get_next_record( fdtmp, 1, 0 ) )
d1331 2
a1332 2
	fseek( fdtmp, 0, SEEK_SET );
	while( get_next_record( fdtmp, 1, 0 ) )
d1358 2
a1359 2
	fseek( fdtmp, 0, SEEK_SET );
	while( get_next_record( fdtmp, 1, 0 ) )
d1414 1
a1414 1
	mk_id( fdout, nastran_file );
d1417 2
a1418 2
	fseek( fdtmp, 0, SEEK_SET );
	while( get_next_record( fdtmp, 1, 0 ) )
d1434 1
a1434 1
			write_shell_as_polysolid( fdout, "pshell.0", nmg_shell );
d1436 1
a1436 1
			mk_nmg( fdout, "pshell.0", nmg_model );
d1458 1
a1458 1
			write_shell_as_polysolid( fdout, name, psh->s );
d1460 1
a1460 1
			mk_nmg( fdout, name, m );
d1466 1
a1466 1
		mk_lfcomb( fdout, "shells", &head, 0 );
d1479 1
a1479 1
		mk_lfcomb( fdout, name, &pb->head, 0 );
d1485 1
a1485 1
		mk_lfcomb( fdout, "pbars", &head, 0 );
d1491 1
a1491 1
		mk_lfcomb( fdout, "all", &all_head, 0 );
d1493 1
a1493 1
	wdb_close(fdout);
@


14.18
log
@more level 4 flawfinder issues.  mostly string length clampages.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.17 2007/09/15 16:23:04 brlcad Exp $";
d287 1
a287 2
			bu_log( "unexpected end of INPUT at line #%d\n", line_count );
			bu_bomb( "unexpected end of INPUT\n" );
d341 1
a341 2
			bu_log( "unexpected end of INPUT at line #%d\n", line_count );
			bu_bomb( "unexpected end of INPUT\n" );
d384 1
a384 1
			bu_bomb( "ERROR: Cannot use consecutive replication cards\n" );
d422 1
a422 2
				bu_log( "unexpected end of INPUT at line #%d\n", line_count );
				bu_bomb( "unexpected end of INPUT\n" );
d582 1
a582 2
		bu_log( "A coordinate system is defined in terms of a non-existent coordinate system!!!\n" );
		exit( 1 );
d641 1
a641 1
			bu_log( "Unrecognized coordinate system type (%c) for cid=%d!!!\n",
a642 1
			exit( 1 );
d672 1
a672 2
		bu_log( "No coordinate system defined for grid point #%d!!!\n", g_pts[index].gid );
		exit( 1 );
d701 1
a701 2
		bu_log( "Grid point %d is not defined!!\n", gid );
		exit( 1 );
d708 1
a708 2
			bu_log( "Could not convert grid point #%d to BRL-CAD!!!\n", gid );
			exit( 1 );
d732 1
a732 2
		bu_log( "Grid point %d is not defined!!\n", gid );
		exit( 1 );
d739 1
a739 2
			bu_log( "Could not convert grid point #%d to BRL-CAD!!!\n", gid );
			exit( 1 );
d969 1
a969 1
			bu_log( "Cannot find PSHELL entry for a CQUAD4 element (ignoring)!!!\n" );
d1075 1
a1075 1
			bu_log( "Cannot find PSHELL entry for a CTRIA3 element (ignoring)!!!\n" );
d1211 2
a1212 3
					bu_log( "Cannot open NASTRAN file (%s) for reading!!!\n", bu_optarg );
					bu_log( "Usage", argv[0] );
					exit( 1 );
d1224 2
a1225 3
		bu_log( "Cannot open BRL-CAD file (%s) for writing!!!\n", output_file );
		bu_log( "Usage", argv[0] );
		exit( 1 );
d1230 1
a1230 2
		bu_log( Usage, argv[0] );
		exit( 1 );
d1258 2
a1259 3
		bu_log( "Cannot find start of bulk data in NASTRAN file!!!\n" );
		bu_log( "Usage", argv[0] );
		exit( 1 );
d1267 1
a1267 1
		bu_bomb( "Cannot open temporary file\n" );
d1288 1
a1288 2
		bu_log( "No geometry in this NASTRAN file!!!\n" );
		exit( 1 );
d1391 1
a1391 2
			bu_log( "Cannot convert to default coordinate system, check for circular definition\n" );
			exit( 1 );
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.16 2007/02/20 08:19:47 brlcad Exp $";
d211 1
a211 1
			strcpy( curr_rec[field_no], prev_rec[field_no] );
d217 1
a217 1
				strcpy( curr_rec[field_no], prev_rec[field_no] );
d391 1
a391 1
			strcpy( line, prev_line );
@


14.16
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.15 2007/02/02 08:48:28 brlcad Exp $";
d42 1
a42 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d45 1
@


14.15
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.14 2007/01/23 01:13:25 brlcad Exp $";
d173 1
a173 1
	tmp = fgets( next_line, MAXLINELEN, fdin );
d175 1
a175 1
		tmp = fgets( next_line, MAXLINELEN, fdin );
d466 1
a466 1
		tmp = fgets( prev_line, MAXLINELEN, fd );
d1262 1
a1262 1
	while( fgets( line, MAXLINELEN, fdin ) )
d1298 1
a1298 1
	while( fgets( line, MAXLINELEN, fdtmp  ) )
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.13 2007/01/20 14:36:43 brlcad Exp $";
d102 2
a103 2
extern char *optarg;
extern int optind, opterr, optopt;
d1196 1
a1196 1
	while( (c=getopt( argc, argv, "x:X:t:ni:o:m")) != EOF )
d1201 1
a1201 1
				sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
d1206 1
a1206 1
				sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
d1211 1
a1211 1
				tol.dist = atof( optarg );
d1220 2
a1221 2
				nastran_file = optarg;
				fdin = fopen( optarg, "r" );
d1224 1
a1224 1
					bu_log( "Cannot open NASTRAN file (%s) for reading!!!\n", optarg );
d1230 1
a1230 1
				output_file = optarg;
@


14.13
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.12 2006/04/06 19:30:22 brlcad Exp $";
@


14.12
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2006 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.11 2006/01/28 00:36:27 brlcad Exp $";
@


14.11
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.10 2006/01/18 06:46:13 brlcad Exp $";
d50 3
@


14.11.2.1
log
@update from HEAD
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.11 2006/01/28 00:36:27 brlcad Exp $";
a49 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
@


14.10
log
@update copyright to 2006
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.9 2005/10/23 04:44:30 brlcad Exp $";
d40 1
a40 2


d44 1
a44 1
#include <string.h>
d46 1
a46 1
#include <strings.h>
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1997-2005 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.8 2005/09/09 05:50:29 brlcad Exp $";
@


14.8
log
@use BRL-CAD instead of brl-cad if only to be at least internally consistent and serve good example
@
text
@d28 1
a28 1
 *  
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.7 2005/01/30 20:30:20 brlcad Exp $";
d1372 1
a1372 1
	
@


14.7
log
@update copyright to 2005
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/nastran-g.c,v 14.6 2004/12/21 07:32:29 morrison Exp $";
d122 1
a122 1
static char			*Usage="Usage:\n\t%s [-p] [-xX lvl] [-t tol.dist] [-i NASTRAN_file] -o brl-cad_file\n";
@


14.7.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d35 1
a35 1
static const char RCSid[] = "$Header$";
d122 1
a122 1
static char			*Usage="Usage:\n\t%s [-p] [-xX lvl] [-t tol.dist] [-i NASTRAN_file] -o BRL-CAD_file\n";
d1372 1
a1372 1

@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2004 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/nastran-g.c,v 14.5 2004/12/21 06:58:41 morrison Exp $";
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a31 2
 *  
 *
d35 1
a35 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/nastran-g.c,v 14.4 2004/12/21 06:50:58 morrison Exp $";
@


14.4
log
@remove the old distribution notice section
@
text
@a33 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d37 1
a37 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/nastran-g.c,v 14.3 2004/12/18 06:50:50 morrison Exp $";
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a32 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
d40 1
a40 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/nastran-g.c,v 14.2 2004/12/18 02:38:10 morrison Exp $";
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file nastran-g.c
d44 1
a44 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/nastran-g.c,v 14.1 2004/11/16 19:42:13 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 2
a2 1
/*		N A S T R A N - G
d4 20
a23 1
 *	Code to convert a NASTRAN finite element model to BRL-CAD
d43 1
a43 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/nastran-g.c,v 1.4 2004/09/03 23:30:56 morrison Exp $";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d23 1
a23 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/nastran-g.c,v 1.3 2004/08/02 23:01:47 morrison Exp $";
d1502 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d23 1
a23 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/nastran-g.c,v 1.2 2004/06/08 22:04:09 morrison Exp $";
d32 1
a32 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d23 1
a23 1
static const char RCSid[] = "$Header$";
d26 1
a26 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d23 1
a23 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/nastran-g.c,v 1.19 2004/05/10 15:30:42 erikg Exp $";
a42 1
#include "externs.h"
@

