head	14.26;
access;
symbols
	rel-7-10-4:14.19
	STABLE:14.19.0.2
	stable-branch:14.5
	rel-7-10-2:14.19
	rel-7-10-0:14.16
	rel-7-8-4:14.11
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.4
	rel-7-6-0:14.6
	rel-7-4-2:14.5.2.1
	rel-7-4-branch:14.5.0.2
	bobWinPort:14.6.0.2
	rel-7-4-0:14.5
	rel-7-2-6:14.5
	rel-7-2-4:14.5
	rel-7-2-2:14.5
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.26
date	2007.12.18.07.07.12;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.10.28.05.41.46;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.10.22.17.42.34;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.10.22.08.47.38;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.10.18.09.11.56;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.10.14.09.08.20;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.07.26.01.13.51;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.18.04.13.43;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.14.21.04.30;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.02.02.08.48.28;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.21.43.00;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.32;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.28.00.36.27;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.23.03.14.49;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.09.09.05.50.29;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.07.26.04.40.53;	author brlcad;	state Exp;
branches
	14.6.4.1;
next	14.5;

14.5
date	2005.01.30.20.30.19;	author brlcad;	state Exp;
branches
	14.5.2.1;
next	14.4;

14.4
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.50;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.09;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.14.49.30;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.08;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.51;	author morrison;	state Exp;
branches;
next	;

14.5.2.1
date	2005.08.16.21.03.48;	author brlcad;	state Exp;
branches;
next	;

14.6.4.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.26
log
@null-terminate strncat'd buffers for sanity sake since we don't usually check if we filled/truncated
@
text
@/*                      E U C L I D - G . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file euclid-g.c
 *
 *  Program to convert Euclid file into a BRL-CAD NMG object.
 *
 *  Authors -
 *	Michael Markowski
 *	John R. Anderson
 */
#ifndef lint
static const char RCSid[] = "$Header$";
#endif

#include "common.h"

/* system headers */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#if defined(HAVE_UNISTD_H)
#  include <unistd.h>
#else
#  if defined(HAVE_SYS_UNISTD_H)
#    include <sys/unistd.h>
#  endif
#endif
#include <errno.h>

/* interface headers */
#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "wdb.h"

/* local headers */
#include "../librt/debug.h"


#define BRLCAD_TITLE_LENGTH	72
#define MAX_FACES_PER_REGION	8192
#define MAX_PTS_PER_FACE	8192

#define MAX(A, B) ((A) > (B) ? (A) : (B))

#define inout(_i,_j)	in_out[_i*shell_count + _j]
#define OUTSIDE		1
#define INSIDE		(-1)
#define OUTER_SHELL	0x00000001
#define	INNER_SHELL	0x00000002
#define INVERT_SHELL	0x00000004

struct vlist {
	fastf_t		pt[3*MAX_PTS_PER_FACE];
	struct vertex	*vt[MAX_PTS_PER_FACE];
};

void euclid_to_brlcad(FILE *fpin, struct rt_wdb *fpout);
int find_vert(struct vlist *vert, int nv, fastf_t x, fastf_t y, fastf_t z);
int store_vert(struct vlist *vert, int *nv, fastf_t x, fastf_t y, fastf_t z);
int read_euclid_face(int *lst, int *ni, FILE *fp, struct vlist *vert, int *nv);
int cvt_euclid_region(FILE *fp, struct rt_wdb *fpdb, int reg_id);


struct bu_ptbl groups[11];

static int polysolids;
static int debug;
static const char usage[] = "Usage: %s [-v] [-i euclid_db] [-o brlcad_db] [-d tolerance] [-p] [-xX lvl]\n\t\t(-p indicates write as polysolids)\n ";
static struct bn_tol  tol;

void
Find_loop_crack(struct shell *s)
{
	struct faceuse *fu;

	for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
	{
		struct loopuse *lu;

		for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
		{
			struct edgeuse *eu;
			int found=0;

			if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) != NMG_EDGEUSE_MAGIC )
				continue;

			for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
			{
				struct edgeuse *eu_next;

				eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu->l );
				if( eu->vu_p->v_p == eu_next->vu_p->v_p )
				{
					found = 2;
					break;
				}
				eu_next = BU_LIST_PNEXT_CIRC( edgeuse, &eu_next->l );

				if( eu->vu_p->v_p == eu_next->vu_p->v_p )
				{
					found = 1;
					break;
				}
			}

			if( !found )
				continue;

			if( found == 1 )
				bu_log( "Found a crack:\n" );
			else if( found ==2 )
				bu_log( "Found a zero length edge:\n" );
			nmg_pr_fu_briefly( fu, "" );
		}
	}
}

int
main(int argc, char **argv)
{
	char		*bfile, *efile;
	FILE		*fpin;
	struct rt_wdb	*fpout;
	char		title[BRLCAD_TITLE_LENGTH];	/* BRL-CAD database title */
	register int	c;
	int i;

	fpin = stdin;
	efile = NULL;
	bfile = "euclid.g";
	polysolids = 1;
	debug = 0;

	tol.magic = BN_TOL_MAGIC;
	tol.dist = 0.005;
	tol.dist_sq = tol.dist * tol.dist;
	tol.perp = 1e-6;
	tol.para = 1 - tol.perp;


	/* Get command line arguments. */
	while ((c = bu_getopt(argc, argv, "d:vi:o:nx:X:")) != EOF) {
		switch (c) {
		case 'd':
			tol.dist = atof( bu_optarg );
			tol.dist_sq = tol.dist * tol.dist;
			break;
		case 'v':
			debug = 1;
			break;
		case 'i':
			efile = bu_optarg;
			if ((fpin = fopen(efile, "r")) == NULL)
			{
				perror( argv[0] );
				bu_exit(1, "%s: cannot open %s for reading\n",
					argv[0], efile);
			}
			break;
		case 'o':
			bfile = bu_optarg;
			break;
		case 'n':
			polysolids = 0;
			break;
		case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
			break;
		default:
			bu_exit(1, usage, argv[0]);
			break;
		}
	}

	/* Output BRL-CAD database header.  No problem if more than one. */
	if( efile == NULL )
		snprintf( title, BRLCAD_TITLE_LENGTH, "Conversion from EUCLID (tolerance distance = %gmm)", tol.dist );
	else
	{
		char tol_str[BRLCAD_TITLE_LENGTH];
		int title_len,tol_len;

		snprintf( title, BRLCAD_TITLE_LENGTH, "%s", efile );
		title_len = strlen( title );

		snprintf( tol_str, BRLCAD_TITLE_LENGTH, " (tolerance distance = %gmm)", tol.dist );
		tol_len =  strlen( tol_str );

		/* add the tolerance only if it'll completely fit */
		if( title_len + tol_len < BRLCAD_TITLE_LENGTH ) {
		    strncat(title, tol_str, tol_len);
		    title[BRLCAD_TITLE_LENGTH-1] = '\0';
		}
	}

	if ((fpout = wdb_fopen(bfile)) == NULL) {
		perror( argv[0] );
		bu_exit(1, "%s: cannot open %s for writing\n",
			argv[0], bfile);
	}

	mk_id( fpout, title );

	for( i=0 ; i<11 ; i++ )
		bu_ptbl_init( &groups[i] , 64, " &groups[i] ");

	euclid_to_brlcad(fpin, fpout);

	fclose(fpin);
	wdb_close(fpout);
	return 0;
}

/*
 *	A d d _ N M G _ t o _ D b
 *
 *	Write the nmg to a BRL-CAD style data base.
 */
static void
add_nmg_to_db(struct rt_wdb *fpout, struct model *m, int reg_id)
{
	char	id[80], *rname, *sname;
	int gift_ident;
	int group_id;
	struct nmgregion *r;
	struct shell *s;
	struct wmember head;

	BU_LIST_INIT( &head.l );

	r = BU_LIST_FIRST( nmgregion , &m->r_hd );
	s = BU_LIST_FIRST( shell , &r->s_hd );

	sprintf(id, "%d", reg_id);
	rname = bu_malloc(sizeof(id) + 3, "rname");	/* Region name. */
	sname = bu_malloc(sizeof(id) + 3, "sname");	/* Solid name. */

	snprintf(sname, 80, "%s.s", id);
	if( polysolids )
		mk_bot_from_nmg( fpout , sname , s );
	else
	{
		int something_left=1;

		while( BU_LIST_NOT_HEAD( s, &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell, &s->l );
			if( nmg_simplify_shell( s ) )
			{
				if( nmg_ks( s ) )
				{
					/* we killed it all! */
					something_left = 0;
					break;
				}
			}
			s = next_s;
		}
		if( something_left )
			mk_nmg(fpout, sname,  m);		/* Make nmg object. */
	}

	gift_ident = reg_id % 100000;
	group_id = gift_ident/1000;
	if( group_id > 10 )
		group_id = 10;

	snprintf(rname, 80, "%s.r", id);

	if( mk_addmember( sname, &head.l, NULL, WMOP_UNION ) == WMEMBER_NULL )
	{
		bu_exit(1, "add_nmg_to_db: mk_addmember failed for solid %s\n" , sname);
	}

	if( mk_lrcomb( fpout, rname, &head, 1, (char *)NULL, (char *)NULL,
	    (unsigned char *)NULL, gift_ident, 0, 0, 100, 0 ) )
	{
		bu_exit(1, "add_nmg_to_db: mk_rlcomb failed for region %s\n" , rname);
	}

	bu_ptbl_ins( &groups[group_id] , (long *)rname );

	bu_free( (char *)sname , "euclid-g: solid name" );
}

static void
build_groups(struct rt_wdb *fpout)
{
	int i,j;
	struct wmember head;
	struct wmember head_all;
	char group_name[18];

	BU_LIST_INIT( &head.l );
	BU_LIST_INIT( &head_all.l );

	for( i=0 ; i<11 ; i++ )
	{

		if( BU_PTBL_END( &groups[i] ) < 1 )
			continue;

		for( j=0 ; j<BU_PTBL_END( &groups[i] ) ; j++ )
		{
			char *region_name;

			region_name = (char *)BU_PTBL_GET( &groups[i] , j );
			if( mk_addmember( region_name , &head.l , NULL, WMOP_UNION ) == WMEMBER_NULL )
			{
				bu_exit(1, "build_groups: mk_addmember failed for region %s\n" , region_name);
			}
		}

		if( i < 10 )
			sprintf( group_name , "%dxxx_series" , i );
		else
			sprintf( group_name , "ids_over_9999" );

		j = mk_lfcomb( fpout , group_name , &head , 0 )
		if( j )
		{
			bu_exit(1, "build_groups: mk_lcomb failed for group %s\n" , group_name);
		}

		if( mk_addmember( group_name , &head_all.l , NULL, WMOP_UNION ) == WMEMBER_NULL )
		{
			bu_exit(1, "build_groups: mk_addmember failed for group %s\n" , group_name);
		}
	}

	j = mk_lfcomb( fpout , "all" , &head_all , 0 )
	if( j )
		bu_exit(1, "build_groups: mk_lcomb failed for group 'all'\n");
}

/*
 *	E u c l i d _ t o _ B r l C a d
 *
 *	Convert a Euclid data base into a BRL-CAD data base.  This might or
 *	might not be correct, but a Euclid data base of faceted objects is
 *	assumed to be an ascii file of records of the following form:
 *
 *		RID FT A? B? NPT
 *		I0 X0 Y0 Z0
 *		I1 X1 Y1 Z1
 *	    	...
 *		Inpt Xnpt Ynpt Znpt
 *		Ip A B C D
 *
 *	where RID is an integer closed region id number,
 *
 *		FT is the facet type with the following values:
 *		   0: simple facet (no holes).
 *		   1: this facet is a hole.
 *		   2: this is a surface facet which will be given holes.
 *
 *		A? B? are unknown variables.
 *
 *		NPT is the number of data point coordinates which will follow.
 *
 *		Ij is a data point index number.
 *
 *		Xi Yi Zi are data point coordinates in mm.
 *
 *		A, B, C, D are the facet's plane equation coefficients and
 *		<A B C> is an outward pointing surface normal.
 */
void
euclid_to_brlcad(FILE *fpin, struct rt_wdb *fpout)
{
	char	str[80];
	int	reg_id;

	/* skip first string in file (what is it??) */
	if( fscanf( fpin , "%80s" , str ) == EOF )
		bu_exit(1, "Failed on first attempt to read input" );

	/* Id of first region. */
	if (fscanf(fpin, "%d", &reg_id) != 1) {
		bu_exit(1, "euclid_to_brlcad: no region id\n");
	}

	/* Convert each region to an individual nmg. */
	do {
		fprintf( stderr , "Converting region %d...\n", reg_id);
		reg_id = cvt_euclid_region(fpin, fpout, reg_id);
	} while (reg_id != -1);

	/* Build groups based on idents */
	build_groups( fpout );
}

#if 0
static void
add_shells_to_db( fpout, shell_count, shells, reg_id )
struct rt_wdb *fpout;
int shell_count;
struct shell *shells[];
int reg_id;
{
	struct model *m=(struct model *)NULL;
	char sol_name[80];
	char *reg_name;
	struct wmember head;
	int solid_no=0;
	int shell_no;
	int gift_ident, group_id;

	BU_LIST_INIT( &head.l );

	for( shell_no=0 ; shell_no < shell_count ; shell_no++ )
	{
		if( !shells[shell_no] )
			continue;

		NMG_CK_SHELL( shells[shell_no] );

		if( !m )
			m = nmg_find_model( &shells[shell_no]->l.magic );

		solid_no++;
		sprintf( sol_name , "%d.%d.s", reg_id, solid_no );

		if( mk_addmember( sol_name, &head.l, NULL, WMOP_UNION ) == WMEMBER_NULL )
		{
			bu_exit(1, "add_shells_to_db: mk_addmember failed for solid %s\n" , sol_name);
		}

		if( polysolids )
			mk_bot_from_nmg( fpout, sol_name, shells[shell_no] );
		else
		{
			struct model *m_tmp;
			struct nmgregion *r_tmp;
			struct shell *s=shells[shell_no];

			/* Move this shell to a seperate model and write to .g file */
			m_tmp = nmg_mmr();
			r_tmp = BU_LIST_FIRST( nmgregion , &m_tmp->r_hd );
			BU_LIST_DEQUEUE( &s->l );
			s->r_p = r_tmp;
			BU_LIST_APPEND( &r_tmp->s_hd, &s->l )

			nmg_m_reindex( m_tmp , 0 );

			nmg_rebound( m_tmp, &tol );

			mk_nmg( fpout , sol_name, m_tmp );

			nmg_km( m_tmp );

		}
	}

	nmg_m_reindex( m , 0 );

	gift_ident = reg_id % 100000;
	group_id = gift_ident/1000;
	if( group_id > 10 )
		group_id = 10;

	reg_name = (char *)bu_malloc( strcspn( sol_name, "." ) + 3, "reg_name" );
	sprintf( reg_name, "%d.r", reg_id );
	if( mk_lrcomb( fpout, reg_name, &head, 1, (char *)NULL, (char *)NULL,
	    (unsigned char *)NULL, gift_ident, 0, 0, 100, 0 ) )
	{
		bu_exit(1, "add_nmg_to_db: mk_rlcomb failed for region %s\n" , reg_name);
	}

	bu_ptbl_ins( &groups[group_id] , (long *)reg_name );
}
#endif

/*
 *	R e a d _ E u c l i d _ R e g i o n
 *
 *	Make a list of indices into global vertex coordinate array.
 *	This list represents the face under construction.
 */
int
cvt_euclid_region(FILE *fp, struct rt_wdb *fpdb, int reg_id)
{
	int	cur_id, face, facet_type, i, lst[MAX_PTS_PER_FACE], np, nv;
	int hole_face = -4200;
	struct faceuse	*outfaceuses[MAX_PTS_PER_FACE];
	struct model	*m;	/* Input/output, nmg model. */
	struct nmgregion *r;
	struct shell	*s;
	struct faceuse	*fu;
	struct vertex	*vertlist[MAX_PTS_PER_FACE];
	struct vlist	vert;

	m = nmg_mm();		/* Make nmg model. */
	r = nmg_mrsv(m);	/* Make region, empty shell, vertex. */
	s = BU_LIST_FIRST(shell, &r->s_hd);

	nv = 0;			/* Initially no vertices for this region. */
	face = 0;		/* No faces either. */
	/* Grab all the faces for one region. */
	do {
		/* Get vertices for a single face. */
		facet_type = read_euclid_face(lst, &np, fp, &vert, &nv);

		if( np > 2 )
		{

			/* Make face out of vertices in lst. */
			for (i = 0; i < np; i++)
				vertlist[i] = vert.vt[lst[i]];

			switch(facet_type) {
			case 0:	/* Simple facet (no holes). */
				if( debug )
				{
					bu_log( "Making simple face:\n" );
					for( i=0; i<np; i++ )
						bu_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
				}
				outfaceuses[face] = nmg_cface(s, vertlist, np);
				face++;
				break;

			case 1:	/* Facet is a hole. */
				if( debug )
				{
					bu_log( "Making a hole:\n" );
					for( i=0; i<np; i++ )
						bu_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
				}
				nmg_add_loop_to_face(s, outfaceuses[hole_face],
					vertlist, np, OT_OPPOSITE);
				break;

			case 2:	/* Facet will be given at least one hole. */
				if( debug )
				{
					bu_log( "Making face which will get a hole:\n" );
					for( i=0; i<np; i++ )
						bu_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[lst[i]*3] ));
				}
				outfaceuses[face] = nmg_cface(s, vertlist, np);
				hole_face = face;
				face++;
				break;

			default:
				fprintf(stderr, "cvt_euclid_face: in region %d, face %d is an unknown facet type\n", reg_id, face);
				break;
			}

			/* Save (possibly) newly created vertex structs. */
			for (i = 0; i < np; i++)
				vert.vt[lst[i]] = vertlist[i];
		}

		/* Get next face's region id. */
		if (fscanf(fp, "%d", &cur_id) != 1)
			cur_id = -1;
	} while (reg_id == cur_id);

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "After building faces:\n" );

	/* Associate the vertex geometry, ccw. */
	if( debug )
		bu_log( "Associating vertex geometry:\n" );
	for (i = 0; i < nv; i++)
	{
		if (vert.vt[i])
		{
			if( debug )
				bu_log( "\t( %g %g %g )\n" , V3ARGS( &vert.pt[3*i] ) );
			nmg_vertex_gv(vert.vt[i], &vert.pt[3*i]);
		}
	}

	if( debug )
		bu_log( "Calling nmg_model_vertex_fuse()\n" );
	(void)nmg_model_vertex_fuse( m, &tol );

	/* Break edges on vertices */
	if( debug )
		bu_log( "Calling nmg_model_break_e_on_v()\n" );
	(void)nmg_model_break_e_on_v( m, &tol );

	/* kill zero length edgeuses */
	if( nmg_kill_zero_length_edgeuses( m ) )
	{
		nmg_km( m );
		m = (struct model *)NULL;
		return( cur_id );
	}

	/* kill cracks */
	s = BU_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "Before assoc face geom:\n" );

	/* Associate the face geometry. */
	if( debug )
		bu_log( "Associating face geometry:\n" );
	for (i = 0; i < face; i++)
	{
		/* skip faceuses that were killed */
		if( outfaceuses[i]->l.magic != NMG_FACEUSE_MAGIC )
			continue;

		/* calculate plane for this faceuse */
		if( nmg_calc_face_g( outfaceuses[i] ) )
		{
			bu_log( "nmg_calc_face_g failed\n" );
			nmg_pr_fu_briefly( outfaceuses[i], "" );
		}
	}

	/* Compute "geometry" for model, region, and shell */
	if( debug )
		bu_log( "Rebound\n" );
	nmg_rebound( m , &tol );

#if 0
	/* Break edges on vertices */
	if( debug )
		bu_log( "Calling nmg_model_break_e_on_v()\n" );
	(void)nmg_model_break_e_on_v( m, &tol );

	/* kill cracks */
	s = BU_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	/* kill zero length edgeuses */
	if( nmg_kill_zero_length_edgeuses( m ) )
	{
		nmg_km( m );
		m = (struct model *)NULL;
		return( cur_id );
	}
#endif

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "Before glueing faces:\n" );

	/* Glue faceuses together. */
	if( debug )
		bu_log( "Glueing faces\n" );
	(void)nmg_model_edge_fuse( m, &tol );

	/* Compute "geometry" for model, region, and shell */
	if( debug )
		bu_log( "Rebound\n" );
	nmg_rebound( m , &tol );

	/* fix the normals */
	if( debug )
		bu_log( "Fix normals\n" );
	nmg_fix_normals( s, &tol );

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "After fixing normals:\n" );

	if( debug )
		bu_log( "nmg_s_join_touchingloops( %x )\n", s );
	nmg_s_join_touchingloops( s, &tol );

	/* kill cracks */
	s = BU_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	if( debug )
		bu_log( "nmg_s_split_touchingloops( %x )\n", s );
	nmg_s_split_touchingloops( s, &tol);

	/* kill cracks */
	s = BU_LIST_FIRST( shell , &r->s_hd );
	if( nmg_kill_cracks( s ) )
	{
		if( nmg_ks( s ) )
		{
			nmg_km( m );
			m = (struct model *)0;
		}
		s = (struct shell *)0;
	}

	if( !m )
		return( cur_id );

	/* verify face plane calculations */
	if( debug )
	{
		nmg_stash_model_to_file( "before_tri.g", m, "before_tri" );
		bu_log( "Verify plane equations:\n" );
	}

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "Before nmg_make_faces_within_tol():\n" );

	nmg_make_faces_within_tol( s, &tol );

	if( RT_G_DEBUG&DEBUG_MEM_FULL )
		bu_prmem( "After nmg_make_faces_within_tol():\n" );

	if( debug )
	{
		bu_log( "Checking faceuses:\n" );
		for( BU_LIST_FOR( fu, faceuse, &s->fu_hd ) )
		{
			struct loopuse *lu;
			struct edgeuse *eu;
			struct vertexuse *vu;
			fastf_t dist_to_plane;
			plane_t pl;

			NMG_CK_FACEUSE( fu );

			if( fu->orientation != OT_SAME )
				continue;

			NMG_GET_FU_PLANE( pl, fu );

			if( debug )
				bu_log( "faceuse x%x ( %g %g %g %g )\n", fu, V4ARGS( pl ) );

			/* check if all the vertices for this face lie on the plane */
			for( BU_LIST_FOR( lu, loopuse, &fu->lu_hd ) )
			{
				NMG_CK_LOOPUSE( lu );

				if( BU_LIST_FIRST_MAGIC( &lu->down_hd ) == NMG_VERTEXUSE_MAGIC )
				{
					vu = BU_LIST_FIRST( vertexuse, &lu->down_hd );
					dist_to_plane = DIST_PT_PLANE( vu->v_p->vg_p->coord, pl );
					if( dist_to_plane > tol.dist || dist_to_plane < -tol.dist )
						bu_log( "\tvertex x%x ( %g %g %g ) is %g off plane\n",
							vu->v_p, V3ARGS( vu->v_p->vg_p->coord ), dist_to_plane );
				}
				else
				{
					for( BU_LIST_FOR( eu, edgeuse, &lu->down_hd ) )
					{
						NMG_CK_EDGEUSE( eu );
						vu = eu->vu_p;
						dist_to_plane = DIST_PT_PLANE( vu->v_p->vg_p->coord, pl );
						if( dist_to_plane > tol.dist || dist_to_plane < -tol.dist )
							bu_log( "\tvertex x%x ( %g %g %g ) is %g off plane\n",
								vu->v_p, V3ARGS( vu->v_p->vg_p->coord ), dist_to_plane );
					}
				}
			}
		}
	}

	if( debug )
		bu_log( "%d vertices out of tolerance after fixing out of tolerance faces\n" , nmg_ck_geometry( m , &tol ) );
#if 0
	/* Fuse */
	if( debug )
	{
		nmg_stash_model_to_file( "before_fuse.g", m, "before_fuse" );
		bu_log( "Fuse model:\n" );
	}
	i = nmg_model_fuse( m, &tol );
	if( debug )
		bu_log( "\t%d objects fused\n" , i );
#endif

	nmg_s_join_touchingloops( s, &tol );
	nmg_s_split_touchingloops( s, &tol);

#if 0
	/* if the shell we just built has a void shell inside, nmg_fix_normals will
	 * point the normals of the void shell in the wrong direction. This section
	 * of code looks for such a situation and reverses the normals of the void shell
	 *
	 * first decompose the shell into maximally connected shells
	 */
	if( (shell_count = nmg_decompose_shell( s , &tol )) > 1 )
	{
		/* This shell has more than one part */
		struct shell **shells;
		struct bu_ptbl verts;
		int shell1_no, shell2_no, outer_shell_count=0;
		short *in_out;
		short *shell_inout;

		shell_inout = (short *)bu_calloc( shell_count, sizeof( short ), "shell_inout" );
		in_out = (short *)bu_calloc( shell_count * shell_count , sizeof( short ) , "in_out" );

		bu_ptbl_init( &verts , 64, " &verts ");

		shells = (struct shell **)bu_calloc( shell_count, sizeof( struct shell *), "shells" );

		/* fuse geometry */
		(void)nmg_model_vertex_fuse( m, &tol );

		i = 0;

		if( debug )
			bu_log( "\nShell decomposed into %d sub-shells\n", shell_count );


		/* insure that bounding boxes are available
		 * and that all the shells are closed.
		 */
		shell1_no = (-1);
		for( BU_LIST_FOR( s , shell , &r->s_hd ) )
		{
			shells[++shell1_no] = s;
			if( !s->sa_p )
				nmg_shell_a( s , &tol );

			if( nmg_check_closed_shell( s , &tol ) )
			{
				bu_log( "Warning: Region %d is not a closed surface\n" , reg_id );
				bu_log( "\tCreating new faces to close region\n" );
				nmg_close_shell( s , &tol );
				if( nmg_check_closed_shell( s , &tol ) )
					bu_exit(1, "Cannot close shell\n" );
			}
		}

		shell1_no = (-1);
		for( BU_LIST_FOR( s, shell , &r->s_hd ) )
		{
			struct shell *s2;
			int outside=0;
			int inside=0;

			shell1_no++;

			nmg_vertex_tabulate( &verts, &s->l.magic );

			shell2_no = (-1);
			for( BU_LIST_FOR( s2 , shell , &r->s_hd ) )
			{
				int j;
				int in=0;
				int on=0;
				int out=0;

				shell2_no++;

				if( s2 == s )
					continue;

				for( j=0 ; j<BU_PTBL_END( &verts ) ; j++ )
				{
					struct vertex *v;

					v = (struct vertex *)BU_PTBL_GET( &verts , j );
					NMG_CK_VERTEX( v );

					if( nmg_find_v_in_shell( v, s2, 1 ) )
					{
						on++;
						continue;
					}

					switch( nmg_class_pt_s(v->vg_p->coord, s2, &tol) )
					{
						case NMG_CLASS_AinB:
							in++;
							break;
						case NMG_CLASS_AonBshared:
							on++;
							break;
						case NMG_CLASS_AoutB:
							out++;
							break;
						default:
							bu_bomb( "UNKNOWN CLASS!\n" );
							break;
					}
				}

				if( out > in )
					inout( shell1_no, shell2_no ) = OUTSIDE;
				else
					inout( shell1_no, shell2_no ) = INSIDE;

			}

			bu_ptbl_reset( &verts );
		}

		bu_ptbl_free( &verts);

		/* determine which shells are outer shells, which are inner,
		 * and which must be inverted
		 */
		for( shell1_no=0 ; shell1_no < shell_count ; shell1_no++ )
		{
			int outers=0,inners=0;

			shell_inout[shell1_no] = 0;
			for( shell2_no=0 ; shell2_no < shell_count ; shell2_no++ )
			{

				if( shell1_no == shell2_no )
					continue;

				if( inout( shell1_no, shell2_no ) == OUTSIDE )
					outers++;
				else if( inout( shell1_no, shell2_no ) == INSIDE )
					inners++;
			}

			if( outers && !inners )
				shell_inout[shell1_no] |= OUTER_SHELL;
			if( inners )
				shell_inout[shell1_no] |= INNER_SHELL;
			if( inners%2 )
			{
				shell_inout[shell1_no] |= INVERT_SHELL;
				nmg_invert_shell( shells[shell1_no] );
			}
		}

		/* join inner shells to outer shells */
		for( shell1_no=0 ; shell1_no < shell_count ; shell1_no++ )
		{
			struct shell *outer_shell=(struct shell *)NULL;

			if( shell_inout[shell1_no] & OUTER_SHELL )
				continue;

			if( !shell_inout[shell1_no] & INNER_SHELL )
				bu_exit(1, "Found a shell that is neither inner nor outer!\n");

			/* Look for an outer shell to take this inner shell */
			for( shell2_no=0 ; shell2_no < shell_count ; shell2_no++ )
			{
				if( shell2_no == shell1_no )
					continue;

				if( !shells[shell2_no] )
					continue;

				if( inout( shell1_no, shell2_no ) == INSIDE &&
					shell_inout[shell2_no] & OUTER_SHELL )
				{
					outer_shell = shells[shell2_no];
					break;
				}

			}
			if( !outer_shell )
				bu_exit(1, "Cannot find outer shell for inner shell!\n" );

			/* Place this inner shell in the outer shell */
			nmg_js( outer_shell, shells[shell1_no], &tol );
			shells[shell1_no] = (struct shell *)NULL;
		}

		/* Check and count the outer shells */
		for( shell1_no=0 ; shell1_no < shell_count ; shell1_no++ )
		{
			if( !shells[shell1_no] )
				continue;

			if( shell_inout[shell1_no] & INNER_SHELL )
				bu_exit(1, "An inner shell was not placed in an outer shell!\n");

			outer_shell_count++;
		}

		if( outer_shell_count < 1 )
			bu_exit(1, "No shells found\n");
		else if( outer_shell_count == 1 )
			add_nmg_to_db( fpdb, m, reg_id );
		else
			add_shells_to_db( fpdb, shell_count, shells, reg_id );

		bu_free( (char *)shells, "shells" );
		bu_free( (char *)shell_inout, "shell_inout" );
		bu_free( (char *)in_out, "in_out" );
	}
	else
#endif
	{
		if( debug )
			bu_log( "Writing model to database:\n" );
		add_nmg_to_db( fpdb, m, reg_id );
	}

	nmg_km(m);				/* Safe to kill model now. */

	return(cur_id);
}

/*
 *	R e a d _ E u c l i d _ F a c e
 *
 *	Read in vertices from a Euclid facet file and store them in an
 *	array of nmg vertex structures.  Then make a list of indices of these
 *	vertices in the vertex array.  This list represents the face under
 *	construction.
 *
 *	XXX Fix this!  Only allows set max of points and assumes
 *	no errors during reading...
 */
int
read_euclid_face(int *lst, int *ni, FILE *fp, struct vlist *vert, int *nv)
{
	double	num_points, x, y, z, a, b, c, d;
	int	i, j, k, facet_type;

	/* Description of record. */
	fscanf(fp, "%d %*f %*f %lf", &facet_type, &num_points);
	*ni = (int)num_points;

	if( debug )
		bu_log( "facet type %d has %d points:\n", facet_type,  *ni );

	/* Read in data points. */
	for (i = 0; i < *ni; i++)
	{
		fscanf(fp, "%*d %lf %lf %lf", &x, &y, &z);

		if( debug )
			bu_log( "\tpoint #%d ( %g %g %g )\n", i+1, x, y, z );

		if ((lst[i] = find_vert(vert, *nv, x, y, z)) == -1)
		{
			lst[i] = store_vert(vert, nv, x, y, z);
			if( debug )
				bu_log( "\t\tStoring vertex ( %g %g %g ) at index %d\n" , x, y, z, lst[i] );
		}
		else if( debug )
			bu_log( "\t\tFound vertex ( %g %g %g ) at index %d\n" , x, y, z, lst[i] );
	}

	/* Read in plane equation. */
	fscanf(fp, "%*d %lf %lf %lf %lf", &a, &b, &c, &d);
	if( debug )
		bu_log( "plane equation for face is ( %f %f %f %f )\n", a, b, c, d );

	/* Remove duplicate points (XXX this should be improved). */
	for (i = 0; i < *ni; i++)
		for (j = i+1; j < *ni; j++)
			if (lst[i] == lst[j]) {
				int increment;

				if( debug )
					bu_log( "\tComparing vertices at indices lst[%d]=%d and lst[%d]=%d\n", i, lst[i], j, lst[j] );

				if( j == i+1 || (i == 0 && j == (*ni-1))  )
					increment = 1;
				else if( j == i+2 )
				{
					j = i+1;
					increment = 2;
				}
				else
				{
					bu_log( "warning: removing distant duplicates\n" );
					increment = 1;
				}

				for (k = j ; k < *ni-increment; k++)
					lst[k] = lst[k + increment];
				*ni -= increment;
			}

	return(facet_type);
}

/*
 *	F i n d _ V e r t
 *
 *	Try to locate a geometric point in the list of vertices.  If found,
 *	return the index number within the vertex array, otherwise return
 *	a -1.
 */
int
find_vert(struct vlist *vert, int nv, fastf_t x, fastf_t y, fastf_t z)
{
	int	found, i;
	point_t new_pt;

	VSET( new_pt, x, y, z );
	found = 0;
	for (i = 0; i < nv; i++)
	{
		if( bn_pt3_pt3_equal( &vert->pt[3*i], new_pt, &tol ) )
		{
			found = 1;
			break;
		}
	}
	if (!found)
		return( -1 );
	else
		return( i );
}

/*
 *	S t o r e _ V e r t
 *
 *	Store vertex in an array of vertices.
 */
int
store_vert(struct vlist *vert, int *nv, fastf_t x, fastf_t y, fastf_t z)
{
	vert->pt[*nv*3+0] = x;
	vert->pt[*nv*3+1] = y;
	vert->pt[*nv*3+2] = z;
	vert->vt[*nv] = (struct vertex *)NULL;

	++*nv;

	if (*nv > MAX_PTS_PER_FACE) {
	    bu_exit(1, "read_euclid_face: no more vertex room\n");
	}

	return(*nv - 1);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.25
log
@more flawfinder and bu_exit conversions
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.24 2007/10/22 17:42:34 brlcad Exp $";
d218 1
@


14.24
log
@whoosh, another 10% complete on the bu_bomb to bu_exit conversion review.  also includes a slew of custom exit() calls that can use bu_exit() as well as toning down a slew of overzealous exclamation point use.  (20% complete overall)
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.23 2007/10/22 08:47:38 brlcad Exp $";
d178 2
a179 1
				fprintf(stderr,	"%s: cannot open %s for reading\n",
a180 2
				perror( argv[0] );
				exit(1);
d196 1
a196 2
			fprintf(stderr, usage, argv[0]);
			exit(1);
d222 2
a223 1
		fprintf(stderr,	"%s: cannot open %s for writing\n",
a224 2
		perror( argv[0] );
		exit(1);
@


14.23
log
@first 10% of the review of the bu_bomb() instances.  updating many to bu_exit() for the instances where the error or exit condition aren't catastrophic errors (i.e. they wouldn't benefit from having a stack trace of how we got into that state code-wise).  this also makes it easier to refactor usages of log & exit too to the new routine.
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.22 2007/10/18 09:11:56 brlcad Exp $";
d1013 1
a1013 1
				bu_bomb( "Cannot find outer shell for inner shell!\n" );
@


14.22
log
@more quellings of level 4 flawfinder issues
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.21 2007/10/14 09:08:20 brlcad Exp $";
d302 1
a302 2
		bu_log( "add_nmg_to_db: mk_addmember failed for solid %s\n" , sname );
		bu_bomb( "add_nmg_to_db: FAILED\n" );
d308 1
a308 2
		bu_log( "add_nmg_to_db: mk_rlcomb failed for region %s\n" , rname );
		bu_bomb( "add_nmg_to_db: FAILED\n" );
d340 1
a340 2
				bu_log( "build_groups: mk_addmember failed for region %s\n" , region_name );
				bu_bomb( "build_groups: FAILED\n" );
d352 1
a352 2
			bu_log( "build_groups: mk_lcomb failed for group %s\n" , group_name );
			bu_bomb( "build_groups: mk_lcomb FAILED\n" );
d357 1
a357 2
			bu_log( "build_groups: mk_addmember failed for group %s\n" , group_name );
			bu_bomb( "build_groups: FAILED\n" );
d363 1
a363 1
		bu_bomb( "build_groups: mk_lcomb failed for group 'all'\n" );
d406 1
a406 1
		bu_bomb( "Failed on first attempt to read input" );
d410 1
a410 2
		fprintf(stderr, "euclid_to_brlcad: no region id\n");
		exit(1);
d456 1
a456 2
			bu_log( "add_shells_to_db: mk_addmember failed for solid %s\n" , sol_name );
			bu_bomb( "add_shells_to_db: FAILED\n" );
d497 1
a497 2
		bu_log( "add_nmg_to_db: mk_rlcomb failed for region %s\n" , reg_name );
		bu_bomb( "add_nmg_to_db: FAILED\n" );
d883 1
a883 1
					bu_bomb( "Cannot close shell\n" );
d993 1
a993 1
				bu_bomb( "Found a shell that is neither inner nor outer!\n" );
d1027 1
a1027 1
				bu_bomb( "An inner shell was not placed in an outer shell!\n" );
d1033 1
a1033 1
			bu_bomb( "No shells!\n" );
d1178 1
a1178 3
		fprintf(stderr,
		"read_euclid_face: no more vertex room\n");
		exit(1);
@


14.21
log
@more taking care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.20 2007/09/15 16:23:04 brlcad Exp $";
a210 1
		snprintf( tol_str, BRLCAD_TITLE_LENGTH, " (tolerance distance = %gmm)", tol.dist );
d213 2
d216 5
a220 4
		if( title_len + tol_len > BRLCAD_TITLE_LENGTH )
			strncat( &title[BRLCAD_TITLE_LENGTH-tol_len-1], tol_str, BRLCAD_TITLE_LENGTH - title_len - tol_len  - 1);
		else
			strcat( title, tol_str);
@


14.20
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.19 2007/07/26 01:13:51 brlcad Exp $";
d90 1
a90 1
static char	usage[] = "Usage: %s [-v] [-i euclid_db] [-o brlcad_db] [-d tolerance] [-p] [-xX lvl]\n\t\t(-p indicates write as polysolids)\n ";
d205 1
a205 1
		sprintf( title, "Conversion from EUCLID (tolerance distance = %gmm)", tol.dist );
d211 2
a212 2
		sprintf( tol_str, " (tolerance distance = %gmm)", tol.dist );
		sprintf( title, "%s", efile );
d216 1
a216 1
			strcat( &title[BRLCAD_TITLE_LENGTH-tol_len-1], tol_str );
d218 1
a218 1
			strcat( title, tol_str );
d264 1
a264 1
	sprintf(sname, "%s.s", id);
d296 1
a296 1
	sprintf(rname, "%s.r", id);
d408 1
a408 1
	if( fscanf( fpin , "%s" , str ) == EOF )
@


14.19
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d30 1
a30 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.18 2007/05/18 04:13:43 brlcad Exp $";
d39 1
a39 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.18
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@a27 5
 *
 *  Source -
 *	The US Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d30 1
a30 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.17 2007/05/14 21:04:30 brlcad Exp $";
@


14.17
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.16 2007/02/02 08:48:28 brlcad Exp $";
d289 1
a289 1
					/* we killed it all!!! */
d310 1
a310 1
		rt_bomb( "add_nmg_to_db: FAILED\n" );
d317 1
a317 1
		rt_bomb( "add_nmg_to_db: FAILED\n" );
d350 1
a350 1
				rt_bomb( "build_groups: FAILED\n" );
d363 1
a363 1
			rt_bomb( "build_groups: mk_lcomb FAILED\n" );
d369 1
a369 1
			rt_bomb( "build_groups: FAILED\n" );
d375 1
a375 1
		rt_bomb( "build_groups: mk_lcomb failed for group 'all'\n" );
d418 1
a418 1
		rt_bomb( "Failed on first attempt to read input" );
d470 1
a470 1
			rt_bomb( "add_shells_to_db: FAILED\n" );
d512 1
a512 1
		rt_bomb( "add_nmg_to_db: FAILED\n" );
d898 1
a898 1
					rt_bomb( "Cannot close shell\n" );
d951 1
a951 1
							rt_bomb( "UNKNOWN CLASS!!!\n" );
d1008 1
a1008 1
				rt_bomb( "Found a shell that is neither inner nor outer!!!\n" );
d1028 1
a1028 1
				rt_bomb( "Cannot find outer shell for inner shell!!!\n" );
d1042 1
a1042 1
				rt_bomb( "An inner shell was not placed in an outer shell!!\n" );
d1048 1
a1048 1
			rt_bomb( "No shells!!!!\n" );
@


14.16
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.15 2007/01/27 21:43:00 brlcad Exp $";
a63 1
#include "rtlist.h"
@


14.15
log
@remove the tolerance parameter from nmg_invert_shell.  it's not used, contrary to the commented purpose, and just complicates the interface unnecessarily so remove it.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.14 2007/01/27 01:41:32 brlcad Exp $";
d175 1
a175 1
	while ((c = getopt(argc, argv, "d:vi:o:nx:X:")) != EOF) {
d178 1
a178 1
			tol.dist = atof( optarg );
d185 1
a185 1
			efile = optarg;
d195 1
a195 1
			bfile = optarg;
d201 1
a201 1
			sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
d204 1
a204 1
			sscanf( optarg, "%x", (unsigned int *)&rt_g.NMG_debug );
@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.13 2007/01/23 01:13:25 brlcad Exp $";
d996 1
a996 1
				nmg_invert_shell( shells[shell1_no], &tol );
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.12 2007/01/20 14:36:43 brlcad Exp $";
d167 5
a171 5
        tol.magic = BN_TOL_MAGIC;
        tol.dist = 0.005;
        tol.dist_sq = tol.dist * tol.dist;
        tol.perp = 1e-6;
        tol.para = 1 - tol.perp;
@


14.12
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.11 2006/01/28 00:36:27 brlcad Exp $";
@


14.11
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.10 2006/01/23 03:14:49 brlcad Exp $";
@


14.10
log
@convert to libbu memory management
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.9 2006/01/18 06:46:13 brlcad Exp $";
d42 1
d46 1
a46 1
#include <string.h>
d48 1
a48 1
#include <strings.h>
@


14.9
log
@update copyright to 2006
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.8 2005/10/23 04:44:29 brlcad Exp $";
d271 2
a272 2
	rname = malloc(sizeof(id) + 3);	/* Region name. */
	sname = malloc(sizeof(id) + 3);	/* Solid name. */
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.7 2005/09/09 05:50:29 brlcad Exp $";
@


14.7
log
@use BRL-CAD instead of brl-cad if only to be at least internally consistent and serve good example
@
text
@d29 1
a29 1
 *  
d33 1
a33 1
 *  
d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.6 2005/07/26 04:40:53 brlcad Exp $";
d1095 1
a1095 1
	
d1127 1
a1127 1
				
@


14.6
log
@make sure to include the errno.h header before any usage of the errno global just in case so bad things don't happen (like on fedora core)
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.5 2005/01/30 20:30:19 brlcad Exp $";
d253 1
a253 1
 *	Write the nmg to a brl-cad style data base.
@


14.6.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d33 1
a33 1
 *
d36 1
a36 1
static const char RCSid[] = "$Header$";
d253 1
a253 1
 *	Write the nmg to a BRL-CAD style data base.
d1095 1
a1095 1

d1127 1
a1127 1

@


14.5
log
@update copyright to 2005
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.4 2004/12/21 07:18:57 morrison Exp $";
d56 1
a94 2
extern int errno;

@


14.5.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d36 1
a36 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/euclid-g.c,v 14.6 2005/07/26 04:40:53 brlcad Exp $";
a55 1
#include <errno.h>
d94 2
@


14.4
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d36 1
a36 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/euclid-g.c,v 14.3 2004/12/18 06:50:50 morrison Exp $";
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a33 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
d36 1
a36 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/euclid-g.c,v 14.2 2004/12/18 02:38:09 morrison Exp $";
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file euclid-g.c
d38 1
a38 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/euclid-g.c,v 14.1 2004/11/16 19:42:12 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			E U C L I D - G . C
d37 1
a37 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/euclid-g.c,v 1.5 2004/09/03 23:30:56 morrison Exp $";
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/euclid-g.c,v 1.4 2004/08/02 23:01:47 morrison Exp $";
d1184 10
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/euclid-g.c,v 1.3 2004/06/09 14:49:30 morrison Exp $";
d26 1
a26 1
#ifdef USE_STRING_H
@


1.3
log
@add unistd.h header for getopt()
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/src/conv/euclid-g.c,v 1.2 2004/06/08 22:04:08 morrison Exp $";
d21 1
a21 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header$";
d25 1
a25 2


d33 7
d41 1
d49 2
d52 1
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d18 1
a18 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/euclid-g.c,v 11.28 2004/05/10 15:30:41 erikg Exp $";
a35 1
#include "externs.h"
@

