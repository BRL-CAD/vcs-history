head	14.19;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.7
	rel-7-10-2:14.15
	rel-7-10-0:14.15
	rel-7-8-4:14.11
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.19
date	2007.11.21.20.49.05;	author erikgreenwald;	state Exp;
branches;
next	14.18;

14.18
date	2007.11.21.20.38.21;	author erikgreenwald;	state Exp;
branches;
next	14.17;

14.17
date	2007.11.21.19.05.59;	author erikgreenwald;	state Exp;
branches;
next	14.16;

14.16
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.02.02.08.48.28;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.25;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.04.06.19.30.22;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.28.00.36.27;	author brlcad;	state Exp;
branches
	14.10.2.1;
next	14.9;

14.9
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.01.30.20.30.19;	author brlcad;	state Exp;
branches
	14.7.6.1;
next	14.6;

14.6
date	2004.12.21.07.32.29;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.58.41;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.50.58;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.50;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.38.09;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.08;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.51;	author morrison;	state Exp;
branches;
next	;

14.7.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;

14.10.2.1
date	2006.04.07.19.26.25;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.19
log
@pass bu_exit a NULL instead of an empty string
@
text
@/*                         E N F - G . C
 * BRL-CAD
 *
 * Copyright (c) 2001-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file enf-g.c
 *
 *  Program to convert the tessellated Elysium Neutral File format to BRL-CAD.
 *
 *  Author -
 *      John R. Anderson
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.18 2007/11/21 20:38:21 erikgreenwald Exp $";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "db.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "plot3.h"
#include "../librt/debug.h"

#define MAX_LINE_LEN	256

static	FILE *fd_in;
static	struct rt_wdb *fd_out;
static	char line[MAX_LINE_LEN];
static	fastf_t local_tol;
static	fastf_t local_tol_sq;
static	int ident;
static	char *part_name_file=NULL;
static	int use_part_name_hash=0;
static	int max_name_len=0;
static	Tcl_HashTable htbl;
static	int name_not_converted=0;
static	int indent_level=0;
static	int indent_delta=4;

static struct vert_root *tree_root;

#define DO_INDENT	{ int _i; \
				for( _i=0 ; _i<indent_level ; _i++ ) {\
					bu_log( " " ); \
				} \
			}

static int verbose=0;

extern char *bu_optarg;
extern int bu_optind, bu_opterr, optopt;

struct obj_info {
	char obj_type;			/* type of this object (from defines below) */
	char *obj_name;			/* name of this object */
	char *brlcad_comb;		/* unique BRL-CAD name for this region or assembly */
	char *brlcad_solid;		/* unique BRL-CAD name for the solid if this is a region */
	int obj_id;			/* id number (from ENF file) */
	int part_count;			/* number of members (for assembly), number of faces (for part) */
	struct obj_info **members;	/* pointer to array of member objects (only valid for assemblies) */
};

/* object types */
#define UNKNOWN_TYPE	0
#define PART_TYPE	1
#define ASSEMBLY_TYPE	2

static int *part_tris=NULL;		/* list of triangles for current part */
static int max_tri=0;			/* number of triangles currently malloced */
static int curr_tri=0;			/* number of triangles currently being used */

#define TRI_BLOCK 512			/* number of triangles to malloc per call */

void
lower_case( char *name )
{
	unsigned char *c;

	c = (unsigned char *)name;
	while( *c ) {
		(*c) = tolower( *c );
		c++;
	}
}

void
create_name_hash( FILE *fd )
{
	char line[MAX_LINE_LEN];
	Tcl_HashEntry *hash_entry=NULL;
	int new_entry=0;

	Tcl_InitHashTable( &htbl, TCL_STRING_KEYS );

	while( bu_fgets( line, MAX_LINE_LEN, fd ) ) {
		char *part_no, *desc, *ptr;

		ptr = strtok( line, " \t\n" );
		if( !ptr )
			bu_exit( 1, "*****Error processing part name file at line:\n\t%s\n", line );
		part_no = bu_strdup( ptr );
		lower_case( part_no );
		ptr = strtok( (char *)NULL, " \t\n" );
		if( !ptr )
			bu_exit( 1, "*****Error processing part name file at line:\n\t%s\n", line );
		desc = bu_strdup( ptr );
		lower_case( desc );

		hash_entry = Tcl_CreateHashEntry( &htbl, part_no, &new_entry );
		if( new_entry ) {
			Tcl_SetHashValue( hash_entry, desc );
		} else {
			bu_free( (char *)part_no, "part_no" );
			bu_free( (char *)desc, "desc" );
		}
	}
}

/* routine to check for bad triangles
 * only checks for triangles with duplicate vertices
 */
int
bad_triangle( int v[3], fastf_t *vertices )
{
	fastf_t dist;
	fastf_t coord;
	int i;

	if( v[0] == v[1] || v[1] == v[2] || v[0] == v[2] )
		return( 1 );

	dist = 0;
	for( i=0 ; i<3 ; i++ ) {
		coord = vertices[v[0]*3+i] - vertices[v[1]*3+i];
		dist += coord * coord;
	}
	dist = sqrt( dist );
	if( dist < local_tol ) {
		return( 1 );
	}

	dist = 0;
	for( i=0 ; i<3 ; i++ ) {
		coord = vertices[v[1]*3+i] - vertices[v[2]*3+i];
		dist += coord * coord;
	}
	dist = sqrt( dist );
	if( dist < local_tol ) {
		return( 1 );
	}

	dist = 0;
	for( i=0 ; i<3 ; i++ ) {
		coord = vertices[v[0]*3+i] - vertices[v[2]*3+i];
		dist += coord * coord;
	}
	dist = sqrt( dist );
	if( dist < local_tol ) {
		return( 1 );
	}

	return( 0 );
}


/* routine to add a new triangle to the current part */
void
add_triangle( int v[3] )
{
	if( curr_tri >= max_tri ) {
		/* allocate more memory for triangles */
		max_tri += TRI_BLOCK;
		part_tris = (int *)bu_realloc( part_tris, sizeof( int ) * max_tri * 3, "part_tris" );
	}

	/* fill in triangle info */
	VMOVE( &part_tris[curr_tri*3], v );

	/* increment count */
	curr_tri++;
}


void
List_assem( struct obj_info *assem )
{
	int i;

	if( assem->obj_type != ASSEMBLY_TYPE ) {
		bu_log( "ERROR: List_assem called for non-assembly\n" );
	}
	bu_log( "Assembly: %s (id=%d)\n", assem->obj_name, assem->obj_id );
	bu_log( "\t%d members\n", assem->part_count );
	for( i=0 ; i<assem->part_count ; i++ ) {
		bu_log( "\t\ty %s\n", assem->members[i]->obj_name );
	}
}

void
Usage(void)
{
	bu_log( "Usage:\n\tenf-g [-i starting_ident] [-t tolerance] [-l name_length_limit] [-n part_number_to_name_list] input_facets_file output_brlcad_file.g\n" );
}

void
Make_brlcad_names( struct obj_info *part )
{
	struct bu_vls vls;
	int count=0;
	char *tmp_name, *ptr;
	Tcl_HashEntry *hash_entry=NULL;

	bu_vls_init( &vls );

	if( use_part_name_hash ) {
		hash_entry = Tcl_FindHashEntry( &htbl, part->obj_name );
		if( !hash_entry ) {
			/* try without any name extension */
			if( (ptr=strrchr( part->obj_name, '_' )) != NULL ) {
				bu_vls_strncpy( &vls, part->obj_name, (ptr - part->obj_name) );
				hash_entry = Tcl_FindHashEntry( &htbl, bu_vls_addr( &vls ) );
			}
		}

		if( !hash_entry ) {
			/* try without any name extension */
			if( (ptr=strchr( part->obj_name, '_' )) != NULL ) {
				bu_vls_strncpy( &vls, part->obj_name, (ptr - part->obj_name) );
				hash_entry = Tcl_FindHashEntry( &htbl, bu_vls_addr( &vls ) );
			}
		}

		if( !hash_entry ) {
			/* try adding "-011" */
			if( (ptr=strchr( part->obj_name, '-' ))  != NULL ) {
				bu_vls_strncpy( &vls, part->obj_name, (ptr - part->obj_name) );
				bu_vls_strcat( &vls, "-011" );
				hash_entry = Tcl_FindHashEntry( &htbl, bu_vls_addr( &vls ) );
			}
		}

		if( !hash_entry ) {
			name_not_converted++;
		}
	}

	bu_vls_free( &vls );
	if( hash_entry ) {
		tmp_name = bu_strdup( (char *)Tcl_GetHashValue( hash_entry ) );
	} else {
		if( use_part_name_hash ) {
			bu_log( "\tWarning: no name found for part %s\n", part->obj_name );
		}
		/* make a copy of object name, then make it a legal BRL-CAD name */
		if( strlen( part->obj_name ) < 1 ) {
			tmp_name = bu_strdup( "s.1" );
		} else {
			tmp_name = bu_strdup( part->obj_name );
			ptr = tmp_name;
			while( *ptr != '\0' ) {
				if( !(isalnum( *ptr ) || *ptr == '-')) {
					*ptr = '_';
				}
				ptr++;
			}
		}
	}

	if( part->obj_type == PART_TYPE ) {
		/* find a unique solid name */
		bu_vls_printf( &vls, "s.%s", tmp_name );
		if( max_name_len ) {
			bu_vls_trunc( &vls, max_name_len );
		}
		while( db_lookup( fd_out->dbip, bu_vls_addr( &vls ), LOOKUP_QUIET ) != DIR_NULL) {
			int digits, val=10;

			count++;
			if( max_name_len ) {
				digits = 1;
				while( count >= val ) {
					digits++;
					val *= 10;
				}
				bu_vls_trunc( &vls, 0 );
				bu_vls_printf( &vls, "s.%s", tmp_name );
				bu_vls_trunc( &vls, max_name_len - digits - 1 );
				bu_vls_printf( &vls, ".%d", count );
			} else {
				bu_vls_trunc( &vls, 0 );
				bu_vls_printf( &vls, "s.%s.%d", tmp_name, count );
			}
		}
		part->brlcad_solid = bu_vls_strgrab( &vls );
	} else {
		part->brlcad_solid = NULL;
	}

	/* find a unique non-primitive name */
	bu_vls_printf( &vls, "%s", tmp_name );
	if( max_name_len ) {
		bu_vls_trunc( &vls, max_name_len );
	}
	while( db_lookup( fd_out->dbip, bu_vls_addr( &vls ), LOOKUP_QUIET) != DIR_NULL ) {
		int digits, val=10;

		count++;
		if( max_name_len ) {
			digits = 1;
			while( count >= val ) {
				digits++;
				val *= 10;
			}
			bu_vls_trunc( &vls, 0 );
			bu_vls_printf( &vls, "%s", tmp_name );
			bu_vls_trunc( &vls, max_name_len - digits - 1 );
			bu_vls_printf( &vls, ".%d", count );
		} else {
			bu_vls_trunc( &vls, 0 );
			bu_vls_printf( &vls, "%s.%d", tmp_name, count );
		}
	}
	part->brlcad_comb = bu_vls_strgrab( &vls );

	switch( part->obj_type ) {
		case UNKNOWN_TYPE:
			bu_log( "ERROR: Unknown object type for %s\n", part->obj_name );
			break;
		case PART_TYPE:
			if( use_part_name_hash ) {
				DO_INDENT
				bu_log( "part %s changed name to (%s)\n",
					part->obj_name,
					part->brlcad_comb );
			} else {
				DO_INDENT
				bu_log( "part %s\n", part->brlcad_comb );
			}
			break;
		case ASSEMBLY_TYPE:
			if( use_part_name_hash ) {
				DO_INDENT
				bu_log( "assembly %s changed name to (%s)\n",
					part->obj_name,
					part->brlcad_comb );
			} else {
				DO_INDENT
				bu_log( "assembly %s\n", part->brlcad_comb );
			}
			break;
	}

	bu_free( tmp_name, "tmp_name" );
}


struct obj_info *
Part_import( int id_start )
{
	struct obj_info *part;
	struct wmember reg_head;
	unsigned char rgb[3];
	int surf_count=0;
	int id_end;
	int last_surf=0;
	int i;
	int tri[3];
	int corner_index=-1;

	clean_vert_tree( tree_root );

	VSETALL( rgb, 128 );

	part = (struct obj_info *)bu_calloc( 1, sizeof( struct obj_info ), "part" );
	part->obj_type = PART_TYPE;
	part->obj_id = id_start;
	while( bu_fgets( line, MAX_LINE_LEN, fd_in ) ) {
		if( !strncmp( line, "PartName", 8 ) ) {
			line[strlen( line ) - 1] = '\0';
			part->obj_name = bu_strdup( &line[9] );
			lower_case( part->obj_name );
			Make_brlcad_names( part );
		} else if( !strncmp( line, "FaceCount", 9 ) ) {
			surf_count = atoi( &line[10] );
			if( surf_count == 0 ) {
				last_surf = 1;
			}
		} else if( !strncmp( line, "EndPartId", 9 ) ) {
			/* found end of part, check id */
			id_end = atoi( &line[10] );
			if( id_end != id_start )
				bu_exit( 1, "ERROR: found end of part id %d while processing part %d\n", id_end, id_start );
			if( last_surf ) {
				break;
			}
		} else if( !strncmp( line, "FaceRGB", 7 ) ) {
			/* get face color */
			char *ptr;

			i = 8;
			ptr = strtok( &line[i], " \t" );
			for( i=0 ; i<3 && ptr ; i++ ) {
				rgb[i] = atof( ptr );
				ptr = strtok( (char *)NULL, " \t" );
			}
		} else if( !strncmp( line, "Facet", 5 ) ) {
			/* read a triangle */
			VSETALL( tri, -1 );
			corner_index = -1;
		} else if( !strncmp( line, "Face", 4 ) ) {
			/* start of a surface */
			int surf_no;

			surf_no = atoi( &line[5] );
			if( surf_no == surf_count ) {
				last_surf = 1;
			}
		} else if( !strncmp( line, "TriangleCount", 13 ) ) {
			/* get number of triangles for this surface */
		} else if( !strncmp( line, "Verticies", 9 ) ) {
			/* get vertex list for this triangle */
		} else if( !strncmp( line, "Vertex", 6 ) ) {
			/* get a vertex */
			char *ptr;
			double v[3];

			i = 7;
			while( !isspace( line[i] ) && line[i] != '\0' )
				i++;
			ptr = strtok( &line[i], " \t" );
			for( i=0 ; i<3 && ptr ; i++ ) {
				v[i] = atof( ptr );
				ptr = strtok( (char *)NULL, " \t" );
			}
			tri[++corner_index] = Add_vert( V3ARGS( v ), tree_root, local_tol_sq );
			if( corner_index == 2 ) {
				if( !bad_triangle( tri, tree_root->the_array ) ) {
					add_triangle( tri );
				}
			}
		} else if( !strncmp( line, "Normal", 6 ) ) {
			/* get a vertex normal */
		} else if( !strncmp( line, "PointCount", 10 ) ) {
			/* get number of vertices for this surface */
		} else
			bu_exit( 1, "ERROR: unrecognized line encountered while processing part id %d:\n%s\n", id_start, line );
	}

	if( curr_tri == 0 ) {
		/* no facets in this part, so ignore it */
		bu_free( (char *)part, "part" );
		part = (struct obj_info *)NULL;
	} else {

		/* write this part to database, first make a primitive solid */
		if( mk_bot( fd_out, part->brlcad_solid, RT_BOT_SOLID, RT_BOT_UNORIENTED, 0,
			    tree_root->curr_vert, curr_tri, tree_root->the_array, part_tris, NULL, NULL ) )
			bu_exit( 1, "Failed to write primitive %s (%s) to database\n", part->brlcad_solid, part->obj_name );
		if( verbose ) {
			DO_INDENT;
			bu_log( "Wrote BOT %s\n", part->brlcad_solid );
		}

		/* then a region */
		BU_LIST_INIT( &reg_head.l );
		if( mk_addmember( part->brlcad_solid, &reg_head.l, NULL, WMOP_UNION ) == WMEMBER_NULL )
			bu_exit( 1, "ERROR: Failed to add solid (%s), to region (%s)\n", part->brlcad_solid, part->brlcad_comb );
		if( mk_comb( fd_out, part->brlcad_comb, &reg_head.l, 1, NULL, NULL, rgb, ident++,
			     0, 1, 100, 0, 0, 0 ) )
			bu_exit( 1, "Failed to write region %s (%s) to database\n", part->brlcad_comb, part->obj_name );
		if( verbose ) {
			DO_INDENT;
			bu_log( "Wrote region %s\n", part->brlcad_comb );
		}

		if( use_part_name_hash ) {
			if( db5_update_attribute( part->brlcad_comb, "Part_No",
						  part->obj_name, fd_out->dbip ) ) {
				bu_log( "Failed to assign Part_no attribute to %s\n",
					part->brlcad_comb );
			}
		}
	}

	/* free some memory */
	if( part_tris ) {
		bu_free( (char *)part_tris, "part_tris" );
	}
	max_tri = 0;
	curr_tri = 0;
	part_tris = NULL;

	return( part );
}

struct obj_info *
Assembly_import( int id_start )
{
	struct obj_info *this_assem, *member;
	struct wmember assem_head;
	int id_end, member_id;
	int i;

	this_assem = (struct obj_info *)bu_calloc( 1, sizeof( struct obj_info ),
						   "this_assem" );
	this_assem->obj_type = ASSEMBLY_TYPE;
	this_assem->obj_id = id_start;
	this_assem->part_count = 0;
	this_assem->members = NULL;
	while( bu_fgets( line, MAX_LINE_LEN, fd_in ) ) {
		if( !strncmp( line, "AssemblyName", 12 ) ) {
			line[strlen( line ) - 1] = '\0';
			this_assem->obj_name = bu_strdup( &line[13] );
			lower_case( this_assem->obj_name );
			DO_INDENT;
			bu_log( "Start of assembly %s (id = %d)\n", this_assem->obj_name, id_start );
			indent_level += indent_delta;
		} else if( !strncmp( line, "PartId", 6 ) ) {
			/* found a member part */
			member_id = atoi( &line[7] );
			member = Part_import( member_id );
			if( !member )
				continue;
			this_assem->part_count++;
			this_assem->members = (struct obj_info **)bu_realloc(
			      this_assem->members,
			      this_assem->part_count * sizeof( struct obj_info *),
			      "this_assem->members" );
			this_assem->members[this_assem->part_count-1] = member;
		} else if( !strncmp( line, "AssemblyId", 10 ) ) {
			/* found a member assembly */
			member_id = atoi( &line[11] );
			member = Assembly_import( member_id );
			this_assem->part_count++;
			this_assem->members = (struct obj_info **)bu_realloc(
			      this_assem->members,
			      this_assem->part_count * sizeof( struct obj_info *),
			      "this_assem->members" );
			this_assem->members[this_assem->part_count-1] = member;
		} else if( !strncmp( line, "EndAssemblyId", 13 ) ) {
			/* found end of assembly, make sure it is this one */
			id_end = atoi( &line[14] );
			if( id_end != id_start )
				bu_exit( 1, "ERROR: found end of assembly id %d while processing id %d\n", id_end, id_start );
			indent_level -= indent_delta;
			DO_INDENT;
			bu_log( "Found end of assembly %s (id = %d)\n",  this_assem->obj_name, id_start );
			break;
		} else {
			bu_log( "Unrecognized line encountered while processing assembly id %d:\n",
				id_start );
			bu_exit( 1, "%s\n", line );
		}
	}

	Make_brlcad_names( this_assem );

	/* write this assembly to the database */
	BU_LIST_INIT( &assem_head.l );

	for( i=0 ; i<this_assem->part_count ; i++ )
		if( mk_addmember( this_assem->members[i]->brlcad_comb,
				  &assem_head.l, NULL, WMOP_UNION ) == WMEMBER_NULL )
		    bu_exit( 1, "ERROR: Failed to add region %s to assembly %s\n", this_assem->members[i]->brlcad_comb, this_assem->brlcad_comb );

	if( mk_comb( fd_out, this_assem->brlcad_comb, &assem_head.l, 0, NULL, NULL, NULL,
		     0, 0, 0, 0, 0, 0, 0 ) )
		bu_exit( 1, "ERROR: Failed to write combination (%s) to database\n", this_assem->brlcad_comb );
	if( use_part_name_hash ) {
		if( db5_update_attribute( this_assem->brlcad_comb, "Part_No",
					  this_assem->obj_name, fd_out->dbip ) ) {
			bu_log( "Failed to assign Part_no attribute to %s\n",
				this_assem->brlcad_comb );
		}
	}

	return( this_assem );
}

int
main( int argc, char *argv[] )
{
	char *input_file, *output_file;
	FILE *fd_parts;
	struct obj_info **top_level_assems=NULL;
	int top_level_assem_count=0;
	int curr_top_level=-1;
	fastf_t tmp;
	int id;
	int c;

	local_tol = 0.005;
	local_tol_sq = local_tol * local_tol;
	ident = 1000;

	while( (c=bu_getopt( argc, argv, "vi:t:n:l:" ) ) != EOF ) {
		switch( c ) {
			case 'v':	/* verbose */
				verbose = 1;
				break;
			case 'i':	/* starting ident number */
				ident = atoi( bu_optarg );
				break;
			case 't':	/* tolerance */
				tmp = atof( bu_optarg );
				if( tmp <= 0.0 )
					bu_exit( 1, "Illegal tolerance (%g), musy be > 0.0\n", tmp );
				break;
			case 'n':	/* part name list */
				part_name_file = bu_optarg;
				use_part_name_hash = 1;
				break;
			case 'l':	/* max name length */
				max_name_len = atoi( bu_optarg );
				if( max_name_len < 5 )
					bu_exit( 1, "Unreasonable name length limitation\n" );
				break;
			default:
				bu_log( "Unrecognized option %c\n", c );
				Usage();
				bu_exit( 1, NULL );
		}
	}

	if( argc - bu_optind != 2 ) {
		bu_log( "Not enough arguments!!\n" );
		Usage();
		bu_exit( 1, NULL );
	}

	input_file = bu_strdup( argv[bu_optind] );
	output_file = bu_strdup( argv[bu_optind+1] );

	if( (fd_in=fopen( input_file, "r" )) == NULL ) {
		bu_log( "Cannot open %s for reading\n", input_file );
		perror( argv[0] );
		bu_exit( 1, NULL );
	}

	if( (fd_out=wdb_fopen( output_file )) == NULL ) {
		bu_log( "Cannot open %s for writing\n", output_file );
		perror( argv[0] );
		bu_exit( 1, NULL );
	}

	if( use_part_name_hash ) {
		if( (fd_parts=fopen( part_name_file, "r" )) == NULL ) {
			bu_log( "Cannot open part name file (%s)\n", part_name_file );
			perror( argv[0] );
			bu_exit( 1, NULL );
		}
		create_name_hash( fd_parts );
	}

	tree_root = create_vert_tree();

	/* finally, start processing the input */
	while( bu_fgets( line, MAX_LINE_LEN, fd_in ) ) {
		if( !strncmp( line, "FileName", 8 ) ) {
			bu_log( "Converting facets originally from %s",
				&line[9] );
		} else if( !strncmp( line, "TopAssemblies", 13 ) ) {
			bu_log( "Top level assemblies: %s", &line[14] );
			top_level_assem_count = atoi( &line[14] );
			if( top_level_assem_count < 1 ) {
				top_level_assems = (struct obj_info **)NULL;
			} else {
				top_level_assems = (struct obj_info **)bu_calloc( top_level_assem_count,
									 sizeof( struct obj_info * ),
									 "top_level_assems" );
			}
		} else if( !strncmp( line, "PartCount", 9 ) ) {
			bu_log( "Part count: %s", &line[10] );
		} else if( !strncmp( line, "AssemblyId", 10 ) ) {
			id = atoi( &line[11] );
			curr_top_level++;
			if( curr_top_level >= top_level_assem_count ) {
				bu_log( "Warning: too many top level assemblies\n" );
				bu_log( "\texpected %d, this os number %d\n",
					top_level_assem_count, curr_top_level+1 );
				top_level_assem_count = curr_top_level+1;
				top_level_assems = (struct obj_info **)bu_realloc( top_level_assems,
									  top_level_assem_count *
									 sizeof( struct obj_info * ),
									 "top_level_assems" );
			}
			top_level_assems[curr_top_level] = Assembly_import( id );
		} else if( !strncmp( line, "PartId", 6 ) ) {
			/* found a top-level part */
			id = atoi( &line[7] );
			(void)Part_import( id );
		}
	}

	if( name_not_converted ) {
		bu_log( "Warning %d objects were not found in the part number to name mapping,\n",
			name_not_converted );
		bu_log( "\ttheir names remain as part numbers.\n" );
	}

	return( 0 );
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.18
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.17 2007/11/21 19:05:59 erikgreenwald Exp $";
d656 1
a656 1
				bu_exit( 1, "" );
d663 1
a663 1
		bu_exit( 1, "" );
d672 1
a672 1
		bu_exit( 1, "" );
d678 1
a678 1
		bu_exit( 1, "" );
d685 1
a685 1
			bu_exit( 1, "" );
@


14.17
log
@exit->bu_exit where applicable
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.16 2007/09/15 16:23:04 brlcad Exp $";
d134 2
a135 5
		if( !ptr ) {
			bu_log( "*****Error processing part name file at line:\n" );
			bu_log( "\t%s\n", line );
			bu_exit( 1, "" );
		}
d139 2
a140 5
		if( !ptr ) {
			bu_log( "*****Error processing part name file at line:\n" );
			bu_log( "\t%s\n", line );
			bu_exit( 1, "" );
		}
d426 2
a427 5
			if( id_end != id_start ) {
				bu_log( "ERROR: found end of part id %d while processing part %d\n",
					id_end, id_start );
				bu_exit( 1, "" );
			}
d480 2
a481 6
		} else {
			bu_log( "ERROR: unrecognized line encountered while processing part id %d:\n",
				id_start );
			bu_log( "%s\n", line );
			bu_exit( 1, "" );
		}
d492 2
a493 5
			    tree_root->curr_vert, curr_tri, tree_root->the_array, part_tris, NULL, NULL ) ) {
			bu_log( "Failed to write primitive %s (%s) to database\n",
				part->brlcad_solid, part->obj_name );
			bu_exit( 1, "" );
		}
d501 2
a502 5
		if( mk_addmember( part->brlcad_solid, &reg_head.l, NULL, WMOP_UNION ) == WMEMBER_NULL ) {
			bu_log( "ERROR: Failed to add solid (%s), to region (%s)\n",
				part->brlcad_solid, part->brlcad_comb );
			bu_exit( 1, "" );
		}
d504 2
a505 5
			     0, 1, 100, 0, 0, 0 ) ) {
			bu_log( "Failed to write region %s (%s) to database\n",
				part->brlcad_comb, part->obj_name );
			bu_exit( 1, "" );
		}
d578 2
a579 5
			if( id_end != id_start ) {
				bu_log( "ERROR: found end of assembly id %d while processing id %d\n",
					id_end, id_start );
				bu_exit( 1, "" );
			}
d587 1
a587 2
			bu_log( "%s\n", line );
			bu_exit( 1, "" );
d596 1
a596 1
	for( i=0 ; i<this_assem->part_count ; i++ ) {
d598 2
a599 7
				  &assem_head.l, NULL, WMOP_UNION ) == WMEMBER_NULL ) {
				bu_log( "ERROR: Failed to add region %s to assembly %s\n",
					this_assem->members[i]->brlcad_comb,
					this_assem->brlcad_comb );
				bu_exit( 1, "" );
		}
	}
d602 2
a603 5
		     0, 0, 0, 0, 0, 0, 0 ) ) {
		bu_log( "ERROR: Failed to write combination (%s) to database\n",
			this_assem->brlcad_comb );
		bu_exit( 1, "" );
	}
d641 2
a642 5
				if( tmp <= 0.0 ) {
					bu_log( "Illegal tolerance (%g), musy be > 0.0\n",
						tmp );
					bu_exit( 1, "" );
				}
d650 2
a651 4
				if( max_name_len < 5 ) {
					bu_log( "Unreasonable name length limitation\n" );
					bu_exit( 1, "" );
				}
@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.15 2007/02/20 08:19:47 brlcad Exp $";
d137 1
a137 1
			exit( 1 );
d145 1
a145 1
			exit( 1 );
d435 1
a435 1
				exit( 1 );
d493 1
a493 1
			exit( 1 );
d508 1
a508 1
			exit( 1 );
d520 1
a520 1
			exit( 1 );
d526 1
a526 1
			exit( 1 );
d603 1
a603 1
				exit( 1 );
d613 1
a613 1
			exit( 1 );
d628 1
a628 1
				exit( 1 );
d636 1
a636 1
		exit( 1 );
d678 1
a678 1
					exit( 1 );
d689 1
a689 1
					exit( 1 );
d695 1
a695 1
				exit( 1 );
d702 1
a702 1
		exit( 1 );
d711 1
a711 1
		exit( 1 );
d717 1
a717 1
		exit( 1 );
d724 1
a724 1
			exit( 1 );
@


14.15
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.14 2007/02/02 08:48:28 brlcad Exp $";
d42 1
a42 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.14
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.13 2007/01/23 01:13:25 brlcad Exp $";
d134 1
a134 1
	while( fgets( line, MAX_LINE_LEN, fd ) ) {
d422 1
a422 1
	while( fgets( line, MAX_LINE_LEN, fd_in ) ) {
d571 1
a571 1
	while( fgets( line, MAX_LINE_LEN, fd_in ) ) {
d736 1
a736 1
	while( fgets( line, MAX_LINE_LEN, fd_in ) ) {
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.12 2007/01/20 14:36:43 brlcad Exp $";
d89 2
a90 2
extern char *optarg;
extern int optind, opterr, optopt;
d669 1
a669 1
	while( (c=getopt( argc, argv, "vi:t:n:l:" ) ) != EOF ) {
d675 1
a675 1
				ident = atoi( optarg );
d678 1
a678 1
				tmp = atof( optarg );
d686 1
a686 1
				part_name_file = optarg;
d690 1
a690 1
				max_name_len = atoi( optarg );
d703 1
a703 1
	if( argc - optind != 2 ) {
d709 2
a710 2
	input_file = bu_strdup( argv[optind] );
	output_file = bu_strdup( argv[optind+1] );
@


14.12
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d34 1
a34 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.11 2006/04/06 19:30:22 brlcad Exp $";
@


14.11
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.10 2006/01/28 00:36:27 brlcad Exp $";
@


14.10
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.9 2006/01/18 06:46:13 brlcad Exp $";
d50 3
@


14.10.2.1
log
@update from HEAD
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.10 2006/01/28 00:36:27 brlcad Exp $";
a49 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
@


14.9
log
@update copyright to 2006
@
text
@d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.8 2005/10/23 04:44:29 brlcad Exp $";
d40 1
d44 1
a44 1
#include <string.h>
d46 1
a46 1
#include <strings.h>
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2001-2005 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.7 2005/01/30 20:30:19 brlcad Exp $";
@


14.7
log
@update copyright to 2005
@
text
@d28 1
a28 1
 *  
d35 1
a35 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/conv/enf-g.c,v 14.6 2004/12/21 07:32:29 morrison Exp $";
d82 1
a82 1
			} 
@


14.7.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d35 1
a35 1
static const char RCSid[] = "$Header$";
d82 1
a82 1
			}
@


14.6
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2004 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/enf-g.c,v 14.5 2004/12/21 06:58:41 morrison Exp $";
@


14.5
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a31 2
 *  
 *
d35 1
a35 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/enf-g.c,v 14.4 2004/12/21 06:50:58 morrison Exp $";
@


14.4
log
@remove the old distribution notice section
@
text
@a33 3
 *  Copyright Notice -
 *	This software is Copyright (C) 2001-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d37 1
a37 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/enf-g.c,v 14.3 2004/12/18 06:50:50 morrison Exp $";
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a32 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
d40 1
a40 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/enf-g.c,v 14.2 2004/12/18 02:38:09 morrison Exp $";
@


14.2
log
@acquire copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file enf-g.c
d44 1
a44 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/enf-g.c,v 14.1 2004/11/16 19:42:12 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *                      E N F - G
d43 1
a43 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/enf-g.c,v 1.4 2004/09/03 23:30:56 morrison Exp $";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/enf-g.c,v 1.3 2004/08/02 23:01:47 morrison Exp $";
d767 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/conv/enf-g.c,v 1.2 2004/06/08 22:04:08 morrison Exp $";
a28 2


d31 1
a31 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header$";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvs/brlcad/conv/enf-g.c,v 11.16 2004/05/10 15:30:41 erikg Exp $";
a43 1
#include "externs.h"
@

