head	14.25;
access;
symbols
	rel-7-10-4:14.19
	STABLE:14.19.0.2
	stable-branch:14.4
	rel-7-10-2:14.18
	rel-7-10-0:14.16
	rel-7-8-4:14.14
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.6
	rel-7-6-0:14.6
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.4
	bobWinPort:14.6.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.25
date	2007.12.02.21.51.10;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.11.21.20.49.10;	author erikgreenwald;	state Exp;
branches;
next	14.23;

14.23
date	2007.11.21.20.38.23;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.11.21.19.49.12;	author erikgreenwald;	state Exp;
branches;
next	14.21;

14.21
date	2007.10.22.20.59.56;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.09.15.16.23.19;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.09.04.15.37.53;	author erikgreenwald;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.18.04.13.50;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.12.22.23.05;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.45;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.36.59;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.07.10.19.06.23;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.04.05.19.15.29;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.02.27.10.08.41;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2006.01.29.08.39.28;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.31.07.40.43;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.31.07.38.04;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.04.26.08.31.58;	author brlcad;	state Exp;
branches
	14.6.6.1;
next	14.5;

14.5
date	2005.04.26.03.14.49;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.09;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.02.43.05;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.30;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.09.01.45.02;	author kermit;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.59;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.34;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.43;	author morrison;	state Exp;
branches;
next	;

14.6.6.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2006.04.07.19.34.21;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.25
log
@no longer need the pre-ansi hacks with c89 functionality assumption, remove the non stdard-based variable-length argument functions
@
text
@/*                         R T S R V . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file rtsrv.c
 *
 *  Remote Ray Tracing service program, using RT library.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.24 2007/11/21 20:49:10 erikgreenwald Exp $ (BRL)";

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#  include <stdarg.h>
#ifdef HAVE_SYS_IOCTL_H
#  include <sys/ioctl.h>
#  include <sys/resource.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#  include <sys/socket.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <sys/fcntl.h>
#endif

#ifdef VMIN
#  undef VMIN
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "pkg.h"
#include "fb.h"

#include "../librt/debug.h"
#include "../rt/ext.h"
#include "rtprivate.h"

#include "./protocol.h"


struct bu_list	WorkHead;

struct pkg_queue {
	struct bu_list	l;
	unsigned short	type;
	char		*buf;
};

/***** Variables shared with viewing model *** */
FBIO		*fbp = FBIO_NULL;	/* Framebuffer handle */
FILE		*outfp = NULL;		/* optional pixel output file */
mat_t		view2model;
mat_t		model2view;
int		srv_startpix;		/* offset for view_pixel */
int		srv_scanlen = REMRT_MAX_PIXELS;	/* max assignment */
char		*scanbuf;
/***** end of sharing with viewing model *****/

extern void grid_setup();
extern void worker();

/***** variables shared with worker() ******/
struct application ap;
vect_t		left_eye_delta;
int		report_progress;	/* !0 = user wants progress report */
/***** end variables shared with worker() *****/

/***** variables shared with do.c *****/
char		*beginptr;		/* sbrk() at start of program */
/***** end variables shared with do.c *****/

/* Variables shared within mainline pieces */
extern fastf_t	rt_dist_tol;		/* Value for rti_tol.dist */
extern fastf_t	rt_perp_tol;		/* Value for rti_tol.perp */
extern int	rdebug;			/* RT program debugging (not library) */
extern int	rt_verbosity;		/* from liboptical */
static char idbuf[132];			/* First ID record info */

/* State flags */
static int	seen_dirbuild;
static int	seen_gettrees;
static int	seen_matrix;

static char *title_file, *title_obj;	/* name of file and first object */

#define MAX_WIDTH	(16*1024)

static int	avail_cpus;		/* # of cpus avail on this system */
static int	max_cpus;		/* max # cpus for use, <= avail_cpus */

int	save_overlaps=0;

/*
 * Package Handlers.
 */
void	ph_unexp(register struct pkg_conn *pc, char *buf);	/* foobar message handler */
void	ph_enqueue(register struct pkg_conn *pc, char *buf);	/* Addes message to linked list */
void	ph_dirbuild(register struct pkg_conn *pc, char *buf);
void	ph_gettrees(register struct pkg_conn *pc, char *buf);
void	ph_matrix(register struct pkg_conn *pc, char *buf);
void	ph_options(register struct pkg_conn *pc, char *buf);
void	ph_lines(struct pkg_conn *pc, char *buf);
void	ph_end(register struct pkg_conn *pc, char *buf);
void	ph_restart(register struct pkg_conn *pc, char *buf);
void	ph_loglvl(register struct pkg_conn *pc, char *buf);
void	ph_cd(register struct pkg_conn *pc, char *buf);

void	prepare(void);

struct pkg_switch pkgswitch[] = {
	{ MSG_DIRBUILD,	ph_dirbuild,	"DirBuild" },
	{ MSG_GETTREES,	ph_enqueue,	"Get Trees" },
	{ MSG_MATRIX,	ph_enqueue,	"Set Matrix" },
	{ MSG_OPTIONS,	ph_enqueue,	"Options" },
	{ MSG_LINES,	ph_enqueue,	"Compute lines" },
	{ MSG_END,	ph_end,		"End" },
	{ MSG_PRINT,	ph_unexp,	"Log Message" },
	{ MSG_LOGLVL,	ph_loglvl,	"Change log level" },
	{ MSG_RESTART,	ph_restart,	"Restart" },
	{ MSG_CD,	ph_cd,		"Change Dir" },
	{ 0,		0,		(char *)0 }
};

struct pkg_conn *pcsrv;		/* PKG connection to server */
char		*control_host;	/* name of host running controller */
char		*tcp_port;	/* TCP port on control_host */

int debug = 0;		/* 0=off, 1=debug, 2=verbose */

char srv_usage[] = "Usage: rtsrv [-d] control-host tcp-port [cmd]\n";

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
	register int	n;

	if( argc < 2 )  {
		fprintf(stderr, "%s", srv_usage);
		return 1;
	}
	while( argv[1][0] == '-' )  {
		if( strcmp( argv[1], "-d" ) == 0 )  {
			debug++;
		} else if( strcmp( argv[1], "-x" ) == 0 )  {
			sscanf( argv[2], "%x", (unsigned int *)&rt_g.debug );
			argc--; argv++;
		} else if( strcmp( argv[1], "-X" ) == 0 )  {
			sscanf( argv[2], "%x", (unsigned int *)&rdebug );
			argc--; argv++;
		} else {
			fprintf(stderr, "%s", srv_usage);
			return 3;
		}
		argc--; argv++;
	}
	if( argc != 3 && argc != 4 )  {
		fprintf(stderr, "%s", srv_usage);
		return 2;
	}

	control_host = argv[1];
	tcp_port = argv[2];

	/* Note that the LIBPKG error logger can not be
	 * "bu_log", as that can cause bu_log to be entered recursively.
	 * Given the special version of bu_log in use here,
	 * that will result in a deadlock in bu_semaphore_acquire(res_syscall)!
	 *  libpkg will default to stderr via pkg_errlog(), which is fine.
	 */
	pcsrv = pkg_open( control_host, tcp_port, "tcp", "", "",
		pkgswitch, NULL );
	if( pcsrv == PKC_ERROR )  {
		fprintf(stderr, "rtsrv: unable to contact %s, port %s\n",
			control_host, tcp_port);
		return 1;
	}

	if( argc == 4 )  {
		/* Slip one command to dispatcher */
		(void)pkg_send( MSG_CMD, argv[3], strlen(argv[3])+1, pcsrv );

		/* Prevent chasing the package with an immediate TCP close */
		sleep(1);

		pkg_close( pcsrv );
		return 0;
	}

#ifdef SO_SNDBUF
	/* increase the default send buffer size to 32k since we're
	 * sending pixels more than likely.
	 */
	{
		int val = 32767;
		n = setsockopt( pcsrv->pkc_fd, SOL_SOCKET, SO_SNDBUF, (const void *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_SNDBUF");
	}
#endif

	if( !debug )  {
		/* A fresh process */
		if (fork())
		    return 0;

		/* Go into our own process group */
		n = bu_process_id();

#ifdef HAVE_SETPGID
		if( setpgid( n, n ) < 0 )
			perror("setpgid");
#else
		/* SysV uses setpgrp with no args and it can't fail,
		 * obsoleted by setpgid.
		 */
		setpgrp();
#endif

		/* Deal with CPU limits on "those kinds" of systems */
		if( bu_cpulimit_get() > 0 )  {
			bu_cpulimit_set( 9999999 );
		}

		/*
		 *  Unless controller process has specificially said
		 *  that this is an interactive session, eg, for a demo,
		 *  drop to the lowest sensible priority.
		 */
		if( !interactive )  {
			bu_nice_set(19);		/* lowest priority */
		}

		/* Close off the world */
		fclose(stdin);
		fclose(stdout);
		fclose(stderr);

		(void)close(0);
		(void)close(1);
		(void)close(2);

		/* For stdio & perror safety, reopen 0,1,2 */
		(void)open("/dev/null", 0);	/* to fd 0 */
		(void)dup(0);			/* to fd 1 */
		(void)dup(0);			/* to fd 2 */

#if defined(HAVE_SYS_IOCTL_H) && defined(TIOCNOTTY)
		n = open("/dev/tty", 2);
		if (n >= 0) {
			(void)ioctl(n, TIOCNOTTY, 0);
			(void)close(n);
		}
#endif
	}

	/* Send our version string */
	if( pkg_send( MSG_VERSION,
	    PROTOCOL_VERSION, strlen(PROTOCOL_VERSION)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send MSG_VERSION error\n");
		return 1;
	}
	if( debug )  fprintf(stderr, "PROTOCOL_VERSION='%s'\n", PROTOCOL_VERSION );

	/*
	 *  Now that the fork() has been done, it is safe to initialize
	 *  the parallel processing support.
	 */

	beginptr = (char *) sbrk(0);

	avail_cpus = bu_avail_cpus();
	max_cpus = bu_get_public_cpus();

	/* Need to set rtg_parallel non_zero here for RES_INIT to work */
	npsw = max_cpus;
	if( npsw > 1 )  {
		rt_g.rtg_parallel = 1;
	} else
		rt_g.rtg_parallel = 0;
	bu_semaphore_init( RT_SEM_LAST );

	bu_log("using %d of %d cpus\n",
		npsw, avail_cpus );
	if( max_cpus <= 0 )  {
		pkg_close(pcsrv);
		return 0;
	}

	/*
	 *  Initialize the non-parallel memory resource.
	 *  The parallel guys are initialized after the rt_dirbuild().
	 */
	rt_init_resource( &rt_uniresource, MAX_PSW, NULL );
	bn_rand_init( rt_uniresource.re_randptr, MAX_PSW );

	BU_LIST_INIT( &WorkHead );

	for(;;)  {
		register struct pkg_queue	*lp;
		fd_set ifds;
		struct timeval tv;

		/* First, process any packages in library buffers */
		if( pkg_process( pcsrv ) < 0 )  {
			bu_log("pkg_get error\n");
			break;
		}

		/* Second, see if any input to read */
		FD_ZERO(&ifds);
		FD_SET(pcsrv->pkc_fd, &ifds);
		tv.tv_sec = BU_LIST_NON_EMPTY( &WorkHead ) ? 0L : 9999L;
		tv.tv_usec = 0L;

		if( select(pcsrv->pkc_fd+1, &ifds, (fd_set *)0, (fd_set *)0,
			&tv ) != 0 )  {
			n = pkg_suckin(pcsrv);
			if( n < 0 )  {
				bu_log("pkg_suckin error\n");
				break;
			} else if( n == 0 )  {
				/* EOF detected */
				break;
			} else {
				/* All is well */
			}
		}

		/* Third, process any new packages in library buffers */
		if( pkg_process( pcsrv ) < 0 )  {
			bu_log("pkg_get error\n");
			break;
		}

		/* Finally, more work may have just arrived, check our list */
		if( BU_LIST_NON_EMPTY( &WorkHead ) )  {
			lp = BU_LIST_FIRST( pkg_queue, &WorkHead );
			BU_LIST_DEQUEUE( &lp->l );
			switch( lp->type )  {
			case MSG_MATRIX:
				ph_matrix( (struct pkg_conn *)0, lp->buf );
				break;
			case MSG_LINES:
				ph_lines( (struct pkg_conn *)0, lp->buf );
				break;
			case MSG_OPTIONS:
				ph_options( (struct pkg_conn *)0, lp->buf );
				break;
			case MSG_GETTREES:
				ph_gettrees( (struct pkg_conn *)0, lp->buf );
				break;
			default:
				bu_log("bad list element, type=%d\n", lp->type );
				return 33;
			}
			bu_free( (char *)lp, "struct pkg_queue" );
		}
	}

	return(0);		/* bu_exit(0, NULL) */
}

/*
 *			P H _ E N Q U E U E
 *
 *  Generic routine to add a newly arrived PKG to a linked list,
 *  for later processing.
 *  Note that the buffer will be freed when the list element is processed.
 *  Presently used for MATRIX and LINES messages.
 */
void
ph_enqueue(register struct pkg_conn *pc, char *buf)
{
	register struct pkg_queue	*lp;

	if( debug )  fprintf(stderr, "ph_enqueue: %s\n", buf );

	BU_GETSTRUCT( lp, pkg_queue );
	lp->type = pc->pkc_type;
	lp->buf = buf;
	BU_LIST_INSERT( &WorkHead, &lp->l );
}

void
ph_cd(register struct pkg_conn *pc, char *buf)
{
	if(debug)fprintf(stderr,"ph_cd %s\n", buf);
	if( chdir( buf ) < 0 )
		bu_exit(1, "ph_cd: chdir(%s) failure\n", buf);
	(void)free(buf);
}

void
ph_restart(register struct pkg_conn *pc, char *buf)
{

	if(debug)fprintf(stderr,"ph_restart %s\n", buf);
	bu_log("Restarting\n");
	pkg_close(pcsrv);
	execlp( "rtsrv", "rtsrv", control_host, tcp_port, (char *)0);
	perror("rtsrv");
	bu_exit(1, NULL);
}

/*
 *			P H _ D I R B U I L D
 *
 *  The only argument is the name of the database file.
 */
void
ph_dirbuild(register struct pkg_conn *pc, char *buf)
{
#define MAXARGS 1024
	char	*argv[MAXARGS+1];
	struct rt_i *rtip;
	int	n;

	if( debug )  fprintf(stderr, "ph_dirbuild: %s\n", buf );

	if( (rt_split_cmd( argv, MAXARGS, buf )) <= 0 )  {
		/* No words in input */
		(void)free(buf);
		return;
	}

	if( seen_dirbuild )  {
		bu_log("ph_dirbuild:  MSG_DIRBUILD already seen, ignored\n");
		(void)free(buf);
		return;
	}

	title_file = bu_strdup(argv[0]);

	/* Build directory of GED database */
	if( (rtip=rt_dirbuild( title_file, idbuf, sizeof(idbuf) )) == RTI_NULL )
		bu_exit(2, "ph_dirbuild:  rt_dirbuild(%s) failure\n", title_file);
	ap.a_rt_i = rtip;
	seen_dirbuild = 1;

	/*
	 *  Initialize all the per-CPU memory resources.
	 *  Go for the max, as TCL interface may change npsw as we run.
	 */
	for( n=0; n < MAX_PSW; n++ )  {
		rt_init_resource( &resource[n], n, rtip );
		bn_rand_init( resource[n].re_randptr, n );
	}

	if( pkg_send( MSG_DIRBUILD_REPLY,
	    idbuf, strlen(idbuf)+1, pcsrv ) < 0 )
		fprintf(stderr,"MSG_DIRBUILD_REPLY error\n");
}

/*
 *			P H _ G E T T R E E S
 *
 *  Each word in the command buffer is the name of a treetop.
 */
void
ph_gettrees(register struct pkg_conn *pc, char *buf)
{
#define MAXARGS 1024
	char	*argv[MAXARGS+1];
	int	argc;
	struct rt_i *rtip = ap.a_rt_i;

	RT_CK_RTI(rtip);

	if( debug )  fprintf(stderr, "ph_gettrees: %s\n", buf );

	/* Copy values from command line options into rtip */
	rtip->useair = use_air;
	if( rt_dist_tol > 0 )  {
		rtip->rti_tol.dist = rt_dist_tol;
		rtip->rti_tol.dist_sq = rt_dist_tol * rt_dist_tol;
	}
	if( rt_perp_tol > 0 )  {
		rtip->rti_tol.perp = rt_perp_tol;
		rtip->rti_tol.para = 1 - rt_perp_tol;
	}

	if( (argc = rt_split_cmd( argv, MAXARGS, buf )) <= 0 )  {
		/* No words in input */
		(void)free(buf);
		return;
	}
	title_obj = bu_strdup(argv[0]);

	if( rtip->needprep == 0 )  {
		/* First clean up after the end of the previous frame */
		if(debug)bu_log("Cleaning previous model\n");
		view_end( &ap );
		view_cleanup( rtip );
		rt_clean(rtip);
		if(rdebug&RDEBUG_RTMEM_END)
			bu_prmem( "After rt_clean" );
	}

	/* Load the desired portion of the model */
	if( rt_gettrees(rtip, argc, (const char **)argv, npsw) < 0 )
		fprintf(stderr,"rt_gettrees(%s) FAILED\n", argv[0]);

	/* In case it changed from startup time via an OPT command */
	if( npsw > 1 )  {
		rt_g.rtg_parallel = 1;
	} else
		rt_g.rtg_parallel = 0;

	beginptr = (char *) sbrk(0);

	seen_gettrees = 1;
	(void)free(buf);

	prepare();

	/* Acknowledge that we are ready */
	if( pkg_send( MSG_GETTREES_REPLY,
	    title_obj, strlen(title_obj)+1, pcsrv ) < 0 )
		fprintf(stderr,"MSG_START error\n");
}

/*
 *			P R O C E S S _ C M D
 */
void
process_cmd(char *buf)
{
	register char	*cp;
	register char	*sp;
	register char	*ep;
	int		len;
	extern struct command_tab rt_cmdtab[];	/* from do.c */

	/* Parse the string */
	len = strlen(buf);
	ep = buf+len;
	sp = buf;
	cp = buf;
	while( sp < ep )  {
		/* Find next semi-colon */
		while( *cp && *cp != ';' )  cp++;
		*cp++ = '\0';
		/* Process this command */
		if( debug )  bu_log("process_cmd '%s'\n", sp);
		if( rt_do_cmd( ap.a_rt_i, sp, rt_cmdtab ) < 0 )
			bu_exit(1, "process_cmd: error on '%s'\n", sp );
		sp = cp;
	}
}

void
ph_options(register struct pkg_conn *pc, char *buf)
{

	if( debug )  fprintf(stderr, "ph_options: %s\n", buf );

	process_cmd( buf );

	/* Just in case command processed was "opt -P" */
	if( npsw < 0 )  {
		/* Negative number means "all but" npsw */
		npsw = max_cpus + npsw;
	}
	if( npsw > MAX_PSW )  npsw = MAX_PSW;

	if( width <= 0 || height <= 0 )
		bu_exit(3, "ph_options:  width=%d, height=%d\n", width, height);
	(void)free(buf);
}

void
ph_matrix(register struct pkg_conn *pc, char *buf)
{
#ifndef NO_MAGIC_CHECKING
	register struct rt_i *rtip = ap.a_rt_i;

	RT_CK_RTI(rtip);
#endif

	if( debug )  fprintf(stderr, "ph_matrix: %s\n", buf );

	/* Start options in a known state */
	AmbientIntensity = 0.4;
	hypersample = 0;
	jitter = 0;
	rt_perspective = 0;
	eye_backoff = 1.414;
	aspect = 1;
	stereo = 0;
	use_air = 0;
	width = height = 0;
	cell_width = cell_height = 0;
	lightmodel = 0;
	incr_mode = 0;
	rt_dist_tol = 0;
	rt_perp_tol = 0;

	process_cmd( buf );
	free(buf);

	seen_matrix = 1;
}

void
prepare(void)
{
	register struct rt_i *rtip = ap.a_rt_i;

	RT_CK_RTI(rtip);

	if( debug )  fprintf(stderr, "prepare()\n");

	/*
	 * initialize application -- it will allocate 1 line and
	 * set buf_mode=1, as well as do mlib_init().
	 */
	(void)view_init( &ap, title_file, title_obj, 0 );

	do_prep( rtip );

	if( rtip->nsolids <= 0 )
		bu_exit(3, "ph_matrix: No solids remain after prep.\n");

	grid_setup();

	/* initialize lighting */
	view_2init( &ap );

	rtip->nshots = 0;
	rtip->nmiss_model = 0;
	rtip->nmiss_tree = 0;
	rtip->nmiss_solid = 0;
	rtip->nmiss = 0;
	rtip->nhits = 0;
	rtip->rti_nrays = 0;

}

/*
 *			P H _ L I N E S
 *
 *
 *  Process pixels from 'a' to 'b' inclusive.
 *  The results are sent back all at once.
 *  Limitation:  may not do more than 'width' pixels at once,
 *  because that is the size of the buffer (for now).
 */
void
ph_lines(struct pkg_conn *pc, char *buf)
{
	auto int		a,b, fr;
	struct line_info	info;
	register struct rt_i	*rtip = ap.a_rt_i;
	struct	bu_external	ext;

	RT_CK_RTI(rtip);

	if( debug > 1 )  fprintf(stderr, "ph_lines: %s\n", buf );
	if( !seen_gettrees )  {
		bu_log("ph_lines:  no MSG_GETTREES yet\n");
		return;
	}
	if( !seen_matrix )  {
		bu_log("ph_lines:  no MSG_MATRIX yet\n");
		return;
	}

	a=0;
	b=0;
	fr=0;
	if( sscanf( buf, "%d %d %d", &a, &b, &fr ) != 3 )
		bu_exit(2, "ph_lines:  %s conversion error\n", buf );

	srv_startpix = a;		/* buffer un-offset for view_pixel */
	if( b-a+1 > srv_scanlen )  b = a + srv_scanlen - 1;

	rtip->rti_nrays = 0;
	info.li_startpix = a;
	info.li_endpix = b;
	info.li_frame = fr;

	rt_prep_timer();
	do_run( a, b );
	info.li_nrays = rtip->rti_nrays;
	info.li_cpusec = rt_read_timer( (char *)0, 0 );
	info.li_percent = 42.0;	/* for now */

	if (!bu_struct_export( &ext, (genptr_t)&info, desc_line_info ) )
		bu_exit(98, "ph_lines: bu_struct_export failure\n");

	if(debug)  {
		fprintf(stderr,"PIXELS fr=%d pix=%d..%d, rays=%d, cpu=%g\n",
			info.li_frame,
			info.li_startpix, info.li_endpix,
			info.li_nrays, info.li_cpusec);
	}
	if( pkg_2send( MSG_PIXELS, ext.ext_buf, ext.ext_nbytes, scanbuf, (b-a+1)*3, pcsrv ) < 0 )  {
		fprintf(stderr,"MSG_PIXELS send error\n");
		db_free_external(&ext);
	}

	db_free_external(&ext);
}

int print_on = 1;

void
ph_loglvl(register struct pkg_conn *pc, char *buf)
{
	if(debug) fprintf(stderr, "ph_loglvl %s\n", buf);
	if( buf[0] == '0' )
		print_on = 0;
	else	print_on = 1;
	(void)free(buf);
}

/**** Other replacement routines from libbu/log.c ****/
int	bu_log_indent_cur_level = 0; /* formerly rt_g.rtg_logindent */
/*
 *			B U _ L O G _ I N D E N T _ D E L T A
 *
 *  Change indentation level by indicated number of characters.
 *  Call with a large negative number to cancel all indentation.
 */
void
bu_log_indent_delta(int delta)
{
	if( (bu_log_indent_cur_level += delta) < 0 )
		bu_log_indent_cur_level = 0;
}

/*
 *			B U _ L O G _ I N D E N T _ V L S
 *
 *  For multi-line vls generators, honor logindent level like bu_log() does,
 *  and prefix the proper number of spaces.
 *  Should be called at the front of each new line.
 */
void
bu_log_indent_vls(struct bu_vls *v)
{
	bu_vls_spaces( v, bu_log_indent_cur_level );
}


/*
 *			B U _ L O G
 *
 *  Log an error.
 *  This version buffers a full line, to save network traffic.
 */
void
bu_log( char *fmt, ... )
{
	va_list ap;
	char buf[512];		/* a generous output line.  Must be AUTO, else non-PARALLEL. */

	if( print_on == 0 )  return;
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	va_start( ap, fmt );
	(void)vsprintf( buf, fmt, ap );
	va_end(ap);

	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if(debug) fprintf(stderr, "%s", buf);
	if( pkg_send( MSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send MSG_PRINT failed\n");
		bu_exit(12, NULL);
	}
out:
	bu_semaphore_release( BU_SEM_SYSCALL );
}


/*
 *			B U _ B O M B
 *
 *  Replacement for the LIBBU routine of the same name.
 */
int		bu_setjmp_valid = 0;	/* !0 = bu_jmpbuf is valid */
jmp_buf		bu_jmpbuf;		/* for BU_SETJMP() */

void
bu_bomb(const char *str)
{
	char	*bomb = "RTSRV terminated by bu_bomb()\n";

	if( pkg_send( MSG_PRINT, (char *)str, strlen(str)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"bu_bomb MSG_PRINT failed\n");
	}
	if( pkg_send( MSG_PRINT, bomb, strlen(bomb)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"bu_bomb MSG_PRINT failed\n");
	}

	if(debug)  fprintf(stderr,"\n%s\n", str);
	fflush(stderr);
	if( RT_G_DEBUG || rt_g.NMG_debug || bu_debug || debug )
		abort();	/* should dump */
	bu_exit(12, NULL);
}

void
ph_unexp(register struct pkg_conn *pc, char *buf)
{
	register int i;

	if(debug) fprintf(stderr, "ph_unexp %s\n", buf);

	for( i=0; pc->pkc_switch[i].pks_handler != NULL; i++ )  {
		if( pc->pkc_switch[i].pks_type == pc->pkc_type )  break;
	}
	bu_log("ph_unexp: unable to handle %s message: len %d",
		pc->pkc_switch[i].pks_title, pc->pkc_len);
	*buf = '*';
	(void)free(buf);
}

/*
 *			P H _ E N D
 */
void
ph_end(register struct pkg_conn *pc, char *buf)
{
	if( debug )  fprintf(stderr, "ph_end\n");
	pkg_close(pcsrv);
	bu_exit(0, NULL);
}

/*
 *			P H _ P R I N T
 */
void
ph_print(register struct pkg_conn *pc, char *buf)
{
	fprintf(stderr,"msg: %s\n", buf);
	(void)free(buf);
}

/* Stub for do.c */
void
memory_summary(void)
{
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.24
log
@pass bu_exit a NULL instead of an empty string
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.23 2007/11/21 20:38:23 erikgreenwald Exp $ (BRL)";
a44 1
#ifdef HAVE_STDARG_H
a45 3
#else
#  include <varargs.h>
#endif
d182 1
a182 1
		fprintf(stderr, srv_usage);
d195 1
a195 1
			fprintf(stderr, srv_usage);
d201 1
a201 1
		fprintf(stderr, srv_usage);
a794 1
#ifdef HAVE_STDARG_H
a818 85
#else /* !HAVE_STDARG_H */

#  ifdef HAVE_VARARGS_H
/*
 *  			B U _ L O G
 *
 *  Log a library event using the Berkeley _doprnt() routine.
 *
 *  Replacement for the LIBBU routine of the same name for
 *  across-network logging.
 */
/* VARARGS */
void
bu_log(va_alist)
va_dcl
{
	va_list		ap;
	char		*fmt;
	char		buf[512];
	FILE		strbuf;
	static char	*cp;			/* NON-PARALLEL */

	if( print_on == 0 )  return;
	if( cp == (char *)0 )  cp = buf;

	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start(ap);
	fmt = va_arg(ap,char *);
#if defined(mips) || (defined(alliant) && defined(i860))
	(void) vsprintf( cp, fmt, ap );
#else
	strbuf._flag = _IOWRT|_IOSTRG;
#if defined(sun)
	strbuf._ptr = (unsigned char *)cp;
#else
	strbuf._ptr = cp;
#endif
	strbuf._cnt = sizeof(buf)-(cp-buf);
	(void) _doprnt( fmt, ap, &strbuf );
	putc( '\0', &strbuf );
#endif
	va_end(ap);

	if(debug) fprintf(stderr, "%s", buf);
	while( *cp++ )  ;		/* leaves one beyond null */
	if( cp[-2] != '\n' )
		goto out;
	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if( pkg_send( MSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send MSG_PRINT failed\n");
		bu_exit(12, NULL);
	}
	cp = buf;
out:
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
}
#  else  /* !HAVE_VARARGS_H */
void
bu_log( str, a, b, c, d, e, f, g, h )
char	*str;
int	a, b, c, d, e, f, g, h;
{
	char	buf[512];		/* a generous output line */

	if( print_on == 0 )  return;
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	(void)sprintf( buf, str, a, b, c, d, e, f, g, h );

	if( pcsrv == PKC_NULL || pcsrv == PKC_ERROR )  {
		fprintf(stderr, "%s", buf);
		goto out;
	}
	if(debug) fprintf(stderr, "%s", buf);
	if( pkg_send( MSG_PRINT, buf, strlen(buf)+1, pcsrv ) < 0 )  {
		fprintf(stderr,"pkg_send MSG_PRINT failed\n");
		bu_exit(12, NULL);
	}
out:
	bu_semaphore_release( BU_SEM_SYSCALL );
}
#  endif /* end !HAVE_VARARGS_H */
#endif /* end !HAVE_STDARG_H */
@


14.23
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.22 2007/11/21 19:49:12 erikgreenwald Exp $ (BRL)";
d407 1
a407 1
	return(0);		/* bu_exit(0, "") */
d449 1
a449 1
	bu_exit(1, "");
d819 1
a819 1
		bu_exit(12, "");
d877 1
a877 1
		bu_exit(12, "");
d902 1
a902 1
		bu_exit(12, "");
d935 1
a935 1
	bu_exit(12, "");
d962 1
a962 1
	bu_exit(0, "");
@


14.22
log
@exit->bu_exit where applicable
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.21 2007/10/22 20:59:56 brlcad Exp $ (BRL)";
d435 2
a436 4
	if( chdir( buf ) < 0 )  {
		bu_log("ph_cd: chdir(%s) failure\n", buf);
		bu_exit(1, "");
	}
d482 2
a483 4
	if( (rtip=rt_dirbuild( title_file, idbuf, sizeof(idbuf) )) == RTI_NULL )  {
		bu_log("ph_dirbuild:  rt_dirbuild(%s) failure\n", title_file);
		bu_exit(2, "");
	}
d592 2
a593 4
		if( rt_do_cmd( ap.a_rt_i, sp, rt_cmdtab ) < 0 )  {
			bu_log("process_cmd: error on '%s'\n", sp );
			bu_exit(1, "");
		}
d613 2
a614 4
	if( width <= 0 || height <= 0 )  {
		bu_log("ph_options:  width=%d, height=%d\n", width, height);
		bu_exit(3, "");
	}
d668 2
a669 4
	if( rtip->nsolids <= 0 )  {
		bu_log("ph_matrix: No solids remain after prep.\n");
		bu_exit(3, "");
	}
d718 2
a719 4
	if( sscanf( buf, "%d %d %d", &a, &b, &fr ) != 3 )  {
		bu_log("ph_lines:  %s conversion error\n", buf );
		bu_exit(2, "");
	}
d735 2
a736 4
	if (!bu_struct_export( &ext, (genptr_t)&info, desc_line_info ) ) {
		bu_log("ph_lines: bu_struct_export failure\n");
		bu_exit(98, "");
	}
@


14.21
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.20 2007/09/15 16:23:19 brlcad Exp $ (BRL)";
d407 1
a407 1
	return(0);		/* exit(0) */
d437 1
a437 1
		exit(1);
d451 1
a451 1
	exit(1);
d486 1
a486 1
		exit(2);
d598 1
a598 1
			exit(1);
d621 1
a621 1
		exit(3);
d678 1
a678 1
		exit(3);
d730 1
a730 1
		exit(2);
d749 1
a749 1
		exit(98);
d833 1
a833 1
		exit(12);
d891 1
a891 1
		exit(12);
d916 1
a916 1
		exit(12);
d949 1
a949 1
	exit(12);
d976 1
a976 1
	exit(0);
@


14.20
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.19 2007/09/04 15:37:53 erikgreenwald Exp $ (BRL)";
a276 3
#ifdef CRAY
			bu_nice_set(6);		/* highest "free" priority */
#else
a277 1
#endif
@


14.19
log
@commit to quell compiler warning
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.18 2007/05/18 04:13:50 brlcad Exp $ (BRL)";
d39 3
a44 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
a49 3

#include <sys/time.h>

a53 1

@


14.18
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.17 2007/05/12 22:23:05 brlcad Exp $ (BRL)";
d948 1
a948 1
	if( pkg_send( MSG_PRINT, str, strlen(str)+1, pcsrv ) < 0 )  {
@


14.17
log
@use new bu_process_id() function to get the pid now
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.16 2007/01/23 01:13:45 brlcad Exp $ (BRL)";
d946 1
a946 1
	char	*bomb = "RTSRV terminated by rt_bomb()\n";
d949 1
a949 1
		fprintf(stderr,"rt_bomb MSG_PRINT failed\n");
d952 1
a952 1
		fprintf(stderr,"rt_bomb MSG_PRINT failed\n");
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.15 2007/01/20 14:36:59 brlcad Exp $ (BRL)";
d260 1
a260 1
		n = getpid();
@


14.15
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.14 2006/07/10 19:06:23 brlcad Exp $ (BRL)";
@


14.14
log
@refactor away the old BSD block defines among other simple cleanup
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.13 2006/04/05 19:15:29 brlcad Exp $ (BRL)";
@


14.13
log
@more header/warning cleanup from Intel compiler warnings on Altix
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.12 2006/02/27 10:08:41 brlcad Exp $ (BRL)";
d244 4
a247 1
#if BSD == 43
d249 2
a250 3
		int	val = 32767;
		n = setsockopt( pcsrv->pkc_fd, SOL_SOCKET,
			SO_SNDBUF, (char *)&val, sizeof(val) );
d824 1
a824 1
#if (__STDC__ && !apollo)
d849 1
a849 5
#else /* __STDC__ */

#if defined(sgi) && !defined(mips)
# define _sgi3d	1
#endif
d851 1
a851 1
#if (defined(BSD) && !defined(_sgi3d)) || defined(mips) || defined(CRAY2)
d908 1
a908 2
#else
/* VARARGS */
d932 2
a933 2
#endif /* not BSD */
#endif /* not __STDC__ */
@


14.12
log
@stdlib.h and exit()
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.11 2006/01/29 08:39:28 brlcad Exp $ (BRL)";
d64 9
@


14.12.2.1
log
@update from HEAD
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.12 2006/02/27 10:08:41 brlcad Exp $ (BRL)";
a63 9
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <sys/fcntl.h>
#endif
@


14.11
log
@update to api changes from rt_* to bu_* for certain routines.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.10 2006/01/18 06:46:23 brlcad Exp $ (BRL)";
d38 2
a42 1
#include <stdio.h>
d83 1
d185 1
a185 1
		exit(1);
d198 1
a198 1
			exit(3);
d204 1
a204 1
		exit(2);
d221 1
a221 1
		exit(1);
d232 1
a232 1
		exit(0);
d247 1
a247 1
			exit(0);
d307 1
a307 1
		exit(1);
d333 1
a333 1
		exit(0);
d401 1
a401 1
				exit(33);
@


14.10
log
@update copyright to 2006
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.9 2005/10/31 07:40:43 brlcad Exp $ (BRL)";
d401 1
a401 1
			rt_free( (char *)lp, "struct pkg_queue" );
@


14.9
log
@comment on oddity of bu_log being here
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.8 2005/10/31 07:38:04 brlcad Exp $ (BRL)";
@


14.8
log
@call setpgrp correctly (no args, always valid return) and use a configure check result for setpgid
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.7 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
d844 1
a844 1
 *  			R T _ L O G
d846 4
a849 1
 *  Log an RT library event using the Berkeley _doprnt() routine.
@


14.7
log
@trailing ws
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.6 2005/04/26 08:31:58 brlcad Exp $ (BRL)";
d250 1
a250 2
		/* SysV uses setpgrp with no args and it can't fail */
#if (defined(__STDC__) || defined(SYSV)) && !defined(_BSD_COMPAT)
d254 4
a257 2
		if( setpgrp( n, n ) < 0 )
			perror("setpgrp");
@


14.6
log
@remove the old irix _BSD_COMPAT hack, needs to be a configure check if anyone ever tries compiling there again
@
text
@d32 1
a32 1
 *  
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.5 2005/04/26 03:14:49 brlcad Exp $ (BRL)";
d693 1
a693 1
/* 
d844 1
a844 1
 *  
d926 1
a926 1
 *  
@


14.6.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d250 2
a251 1
#ifdef HAVE_SETPGID
d255 2
a256 4
		/* SysV uses setpgrp with no args and it can't fail,
		 * obsoleted by setpgid.
		 */
		setpgrp();
d693 1
a693 1
/*
d843 3
a845 6
 *  			B U _ L O G
 *
 *  Log a library event using the Berkeley _doprnt() routine.
 *
 *  Replacement for the LIBBU routine of the same name for
 *  across-network logging.
d926 1
a926 1
 *
@


14.5
log
@rt_verbosity is being provided by liboptical, so don't need to repeat it here in the front end.  also get rid of the silly SYSV checks and replace them with more appropriate preprocessor macros vars HAVE_SYS_IOCTL_H and TIOCNOTTY.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.4 2005/01/30 20:31:09 brlcad Exp $ (BRL)";
a37 4
#if IRIX == 4
#define _BSD_COMPAT	1
#endif

d39 1
a39 1
#include <unistd.h>
d43 1
a43 1
#include <string.h>
d45 1
a45 1
#include <strings.h>
d48 1
a48 1
# include <stdarg.h>
d50 1
a50 1
# include <varargs.h>
d56 2
a57 2
# include <sys/ioctl.h>
# include <sys/resource.h>
d61 5
a65 1
# include <sys/socket.h>
a67 1
#undef	VMIN
@


14.4
log
@update copyright to 2005
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/remrt/rtsrv.c,v 14.3 2004/12/21 06:38:21 morrison Exp $ (BRL)";
d59 1
a59 1
#ifndef SYSV
d118 1
a118 1
int		rt_verbosity = -1;
d292 1
a292 1
#ifndef SYSV
@


14.3
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/remrt/rtsrv.c,v 14.2 2004/12/21 02:43:05 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL
@
text
@a32 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/remrt/rtsrv.c,v 14.1 2004/11/16 19:42:30 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			R T S R V . C
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/remrt/rtsrv.c,v 1.5 2004/09/09 01:45:02 kermit Exp $ (BRL)";
@


1.5
log
@Added <unistd.h> to fix implicit cast (for IA64 architecture).
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/remrt/rtsrv.c,v 1.4 2004/09/03 23:30:59 morrison Exp $ (BRL)";
d978 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/remrt/rtsrv.c,v 1.3 2004/08/02 23:01:52 morrison Exp $ (BRL)";
a21 2


d26 3
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/remrt/rtsrv.c,v 1.2 2004/06/08 22:04:34 morrison Exp $ (BRL)";
d29 1
a29 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d20 1
a20 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d18 1
a18 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/remrt/rtsrv.c,v 11.35 2004/05/10 15:30:49 erikg Exp $ (BRL)";
a54 1
#include "externs.h"
@

