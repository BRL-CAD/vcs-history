head	14.21;
access;
symbols
	rel-7-10-4:14.17
	STABLE:14.17.0.2
	stable-branch:14.6
	rel-7-10-2:14.17
	rel-7-10-0:14.16
	rel-7-8-4:14.13
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.7
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.6
	rel-7-6-0:14.6
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.4
	bobWinPort:14.6.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.21
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.10.22.21.12.28;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.22.21.06.48;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.14.21.04.31;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.08.24.17.49.41;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.23.14.53.11;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.19.21.00.34;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.08.11.06.33.44;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.23.04.36.32;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.33;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.47;	author brlcad;	state Exp;
branches
	14.6.6.1;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.02.24.40;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.19;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.38;	author morrison;	state Exp;
branches;
next	;

14.6.6.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.21
log
@convert all bzero calls to memset
@
text
@/*                        D M - P E X . C
 * BRL-CAD
 *
 * Copyright (c) 1988-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file dm-pex.c
 *
 *  An X Window System interface for MGED
 *  that uses PEX. This display manager started
 *  out with the innards from DM-X.C
 *
 *  Experimental.
 *
 *  Author -
 *      Robert Parker
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#ifndef lint
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.20 2007/10/22 21:12:28 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#ifdef HAVE_XOSDEFS_H
#  include <X11/Xfuncproto.h>
#  include <X11/Xosdefs.h>
#endif
#if defined(linux)
#  undef   X_NOT_STDC_ENV
#  undef   X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */

#include <X11/PEX5/PEXlib.h>
#include <X11/Xutil.h>

#include "tk.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "dm.h"
#include "dm-pex.h"


#define DO_XSELECTINPUT 0
#define SET_COLOR( r, g, b, c ) { \
	(c).rgb.red = (r); \
	(c).rgb.green = (g); \
	(c).rgb.blue = (b);}

#define IMMED_MODE_SPT(info) (((info)->subset_info & 0xffff) ==\
			      PEXCompleteImplementation ||\
			      (info)->subset_info & PEXImmediateMode)
#define Pex_VMOVE(a,b) {\
			(a).x = (b)[X];\
			(a).y = (b)[Y];\
			(a).z = (b)[Z]; }

struct pex_vars head_pex_vars;
void     Pex_establish_perspective();
void     Pex_set_perspective();

static void     Pex_var_init();
static void     Pex_setup_renderer();
static void     Pex_mat_copy();
static void     Pex_load_startup();

static void	label();
static void	draw();

/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
static int      Pex_init();
static int	Pex_open();
static void	Pex_close();
static void	Pex_input();
static void	Pex_prolog(), Pex_epilog();
static void	Pex_normal(), Pex_newrot();
static void	Pex_update();
static void	Pex_puts(), Pex_2d_line(), Pex_light();
static int	Pex_object();
static unsigned Pex_cvtvecs(), Pex_load();
static void	Pex_viewchange(), Pex_colorchange();
static void	Pex_window(), Pex_debug(), Pex_selectargs();

struct dm dm_pex = {
  Pex_init,
  Pex_open, Pex_close,
  Pex_input,
  Pex_prolog, Pex_epilog,
  Pex_normal, Pex_newrot,
  Pex_update,
  Pex_puts, Pex_2d_line,
  Pex_light,
  Pex_object,	Pex_cvtvecs, Pex_load,
  0,
  Pex_viewchange,
  Pex_colorchange,
  Pex_window, Pex_debug, 0, 0,
  0,				/* no displaylist */
  PLOTBOUND,
  "pex", "X Window System (X11)",
  0,
  0,
  0,
  0,
  0,
  0
};

extern Tcl_Interp *interp;
extern Tk_Window tkwin;

static int view_num = 0;
#if TRY_DEPTHCUE
static int cue_num = 1;
#endif

static int perspective_table[] = { 30, 45, 60, 90 };

static int
Pex_init(dmp, argc, argv)
struct dm *dmp;
int argc;
char *argv[];
{
  static int count = 0;

  /* Only need to do this once for this display manager */
  if(!count)
    Pex_load_startup(dmp);

  bu_vls_init(&dmp->dm_pathName);
  bu_vls_printf(&dmp->dmr_pathName, ".dm_pex%d", count++);

  dmp->dmr_vars = bu_calloc(1, sizeof(struct pex_vars), "Pex_init: pex_vars");
  ((struct pex_vars *)dmp->dmr_vars)->perspective_angle = 3;

  /* initialize the modifiable variables */
  ((struct pex_vars *)dmp->dmr_vars)->mvars.dummy_perspective = 1;

  if(BU_LIST_IS_EMPTY(&head_pex_vars.l))
    Tk_CreateGenericHandler(dmp->dmr_eventhandler, (ClientData)DM_TYPE_PEX);

  BU_LIST_APPEND(&head_pex_vars.l, &((struct pex_vars *)dmp->dmr_vars)->l);

  if(dmp->dmr_vars)
	return TCL_OK;

  return TCL_ERROR;
}


/*
 *			P E X _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
static int
Pex_open(struct dm *dmp)
{
  int first_event, first_error;
  char *cp;
  XGCValues gcv;
  XColor a_color;
  Visual *a_visual;
  int a_screen;
  Colormap  a_cmap;
  struct bu_vls str;
  Display *tmp_dpy;
  char pex_err[80];
  PEXExtensionInfo *pex_info;

  bu_vls_init(&str);

  ((struct pex_vars *)dmp->dmr_vars)->fontstruct = NULL;

  /* Make xtkwin a toplevel window */
  ((struct pex_vars *)dmp->dmr_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
		       bu_vls_addr(&dmp->dmr_pathName), dmp->dmr_dname);

  /*
   * Create the X drawing window by calling create_x which
   * is defined in xinit.tk
   */
  bu_vls_strcpy(&str, "init_x ");
  bu_vls_printf(&str, "%s\n", bu_vls_addr(&dmp->dmr_pathName));

  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
    bu_vls_free(&str);
    (void)pex_close(dmp);
    return TCL_ERROR;
  }

  bu_vls_free(&str);
  ((struct pex_vars *)dmp->dmr_vars)->dpy = Tk_Display(((struct pex_vars *)dmp->dmr_vars)->xtkwin);

  /* make sure there really is a display before proceeding. */
  if (!((struct pex_vars *)dmp->dm_vars)->dpy) {
      bu_vls_free(&str);
      (void)pex_close(dmp);
      return TCL_ERROR;
  }

  ((struct pex_vars *)dmp->dmr_vars)->width =
    DisplayWidth(((struct pex_vars *)dmp->dmr_vars)->dpy,
		 DefaultScreen(((struct pex_vars *)dmp->dmr_vars)->dpy)) - 20;
  ((struct pex_vars *)dmp->dmr_vars)->height =
    DisplayHeight(((struct pex_vars *)dmp->dmr_vars)->dpy,
		  DefaultScreen(((struct pex_vars *)dmp->dmr_vars)->dpy)) - 20;

  /* Make window square */
  if(((struct pex_vars *)dmp->dmr_vars)->height < ((struct pex_vars *)dmp->dmr_vars)->width)
    ((struct pex_vars *)dmp->dmr_vars)->width = ((struct pex_vars *)dmp->dmr_vars)->height;
  else
    ((struct pex_vars *)dmp->dmr_vars)->height = ((struct pex_vars *)dmp->dmr_vars)->width;

  Tk_GeometryRequest(((struct pex_vars *)dmp->dmr_vars)->xtkwin,
		     ((struct pex_vars *)dmp->dmr_vars)->width,
		     ((struct pex_vars *)dmp->dmr_vars)->height);
#if 0
  /*XXX*/
  XSynchronize(((struct pex_vars *)dmp->dmr_vars)->dpy, TRUE);
#endif

  Tk_MakeWindowExist(((struct pex_vars *)dmp->dmr_vars)->xtkwin);
  ((struct pex_vars *)dmp->dmr_vars)->win =
      Tk_WindowId(((struct pex_vars *)dmp->dmr_vars)->xtkwin);

#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
  ((struct pex_vars *)dmp->dmr_vars)->pix_width = ((struct pex_vars *)dmp->dmr_vars)->width;
  ((struct pex_vars *)dmp->dmr_vars)->pix_height = ((struct pex_vars *)dmp->dmr_vars)->height;
  ((struct pex_vars *)dmp->dmr_vars)->pix =
    Tk_GetPixmap(((struct pex_vars *)dmp->dmr_vars)->dpy,
		 DefaultRootWindow(((struct pex_vars *)dmp->dmr_vars)->dpy),
		 ((struct pex_vars *)dmp->dmr_vars)->width,
		 ((struct pex_vars *)dmp->dmr_vars)->height,
		 Tk_Depth(((struct pex_vars *)dmp->dmr_vars)->xtkwin));
#endif

  a_screen = Tk_ScreenNumber(((struct pex_vars *)dmp->dmr_vars)->xtkwin);
  a_visual = Tk_Visual(((struct pex_vars *)dmp->dmr_vars)->xtkwin);

  /* Get color map indices for the colors we use. */
  ((struct pex_vars *)dmp->dmr_vars)->black = BlackPixel( ((struct pex_vars *)dmp->dmr_vars)->dpy, a_screen );
  ((struct pex_vars *)dmp->dmr_vars)->white = WhitePixel( ((struct pex_vars *)dmp->dmr_vars)->dpy, a_screen );

  a_cmap = Tk_Colormap(((struct pex_vars *)dmp->dmr_vars)->xtkwin);
  a_color.red = 255<<8;
  a_color.green=0;
  a_color.blue=0;
  a_color.flags = DoRed | DoGreen| DoBlue;
  if ( ! XAllocColor(((struct pex_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
    bu_log( "dm-X: Can't Allocate red\n");
    return TCL_ERROR;
  }
  ((struct pex_vars *)dmp->dmr_vars)->red = a_color.pixel;
    if ( ((struct pex_vars *)dmp->dmr_vars)->red == ((struct pex_vars *)dmp->dmr_vars)->white )
      ((struct pex_vars *)dmp->dmr_vars)->red = ((struct pex_vars *)dmp->dmr_vars)->black;

    a_color.red = 200<<8;
    a_color.green=200<<8;
    a_color.blue=0<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct pex_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
	bu_log( "dm-X: Can't Allocate yellow\n");
	return TCL_ERROR;
    }
    ((struct pex_vars *)dmp->dmr_vars)->yellow = a_color.pixel;
    if ( ((struct pex_vars *)dmp->dmr_vars)->yellow == ((struct pex_vars *)dmp->dmr_vars)->white )
      ((struct pex_vars *)dmp->dmr_vars)->yellow = ((struct pex_vars *)dmp->dmr_vars)->black;

    a_color.red = 0;
    a_color.green=0;
    a_color.blue=255<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct pex_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
	bu_log( "dm-X: Can't Allocate blue\n");
	return TCL_ERROR;
    }
    ((struct pex_vars *)dmp->dmr_vars)->blue = a_color.pixel;
    if ( ((struct pex_vars *)dmp->dmr_vars)->blue == ((struct pex_vars *)dmp->dmr_vars)->white )
      ((struct pex_vars *)dmp->dmr_vars)->blue = ((struct pex_vars *)dmp->dmr_vars)->black;

    a_color.red = 128<<8;
    a_color.green=128<<8;
    a_color.blue= 128<<8;
    a_color.flags = DoRed | DoGreen| DoBlue;
    if ( ! XAllocColor(((struct pex_vars *)dmp->dmr_vars)->dpy, a_cmap, &a_color)) {
	bu_log( "dm-X: Can't Allocate gray\n");
	return TCL_ERROR;
    }
    ((struct pex_vars *)dmp->dmr_vars)->gray = a_color.pixel;
    if ( ((struct pex_vars *)dmp->dmr_vars)->gray == ((struct pex_vars *)dmp->dmr_vars)->white )
      ((struct pex_vars *)dmp->dmr_vars)->gray = ((struct pex_vars *)dmp->dmr_vars)->black;

    /* Select border, background, foreground colors,
     * and border width.
     */
    if( a_visual->class == GrayScale || a_visual->class == StaticGray ) {
	((struct pex_vars *)dmp->dmr_vars)->is_monochrome = 1;
	((struct pex_vars *)dmp->dmr_vars)->bd = BlackPixel( ((struct pex_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct pex_vars *)dmp->dmr_vars)->bg = WhitePixel( ((struct pex_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct pex_vars *)dmp->dmr_vars)->fg = BlackPixel( ((struct pex_vars *)dmp->dmr_vars)->dpy, a_screen );
    } else {
	/* Hey, it's a color server.  Ought to use 'em! */
	((struct pex_vars *)dmp->dmr_vars)->is_monochrome = 0;
	((struct pex_vars *)dmp->dmr_vars)->bd = WhitePixel( ((struct pex_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct pex_vars *)dmp->dmr_vars)->bg = BlackPixel( ((struct pex_vars *)dmp->dmr_vars)->dpy, a_screen );
	((struct pex_vars *)dmp->dmr_vars)->fg = WhitePixel( ((struct pex_vars *)dmp->dmr_vars)->dpy, a_screen );
    }

    if( !((struct pex_vars *)dmp->dmr_vars)->is_monochrome &&
	((struct pex_vars *)dmp->dmr_vars)->fg != ((struct pex_vars *)dmp->dmr_vars)->red &&
	((struct pex_vars *)dmp->dmr_vars)->red != ((struct pex_vars *)dmp->dmr_vars)->black )
      ((struct pex_vars *)dmp->dmr_vars)->fg = ((struct pex_vars *)dmp->dmr_vars)->red;

    gcv.foreground = ((struct pex_vars *)dmp->dmr_vars)->fg;
    gcv.background = ((struct pex_vars *)dmp->dmr_vars)->bg;

    cp = FONT6;
    if ( (((struct pex_vars *)dmp->dmr_vars)->fontstruct =
	 XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, cp)) == NULL ) {
      /* Try hardcoded backup font */
      if ( (((struct pex_vars *)dmp->dmr_vars)->fontstruct =
	    XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, FONTBACK)) == NULL) {
	bu_log( "dm-X: Can't open font '%s' or '%s'\n", cp, FONTBACK );
	return TCL_ERROR;
      }
    }
    gcv.font = ((struct pex_vars *)dmp->dmr_vars)->fontstruct->fid;
    ((struct pex_vars *)dmp->dmr_vars)->gc = XCreateGC(((struct pex_vars *)dmp->dmr_vars)->dpy,
					       ((struct pex_vars *)dmp->dmr_vars)->win,
					       (GCFont|GCForeground|GCBackground),
						&gcv);

/* Begin PEX stuff. */
    if(PEXInitialize(((struct pex_vars *)dmp->dmr_vars)->dpy,
		     &pex_info, 80, pex_err) != 0){
      bu_vls_free(&str);
      bu_log("Pex_setup: %s\n", pex_err);
      return TCL_ERROR;
    }

    if(!IMMED_MODE_SPT(pex_info)){
      bu_vls_free(&str);
      bu_log("Pex_setup: Immediate mode is not supported.\n");
      return TCL_ERROR;
    }

    Pex_setup_renderer(dmp);

#if DO_XSELECTINPUT
    /* start with constant tracking OFF */
    XSelectInput(((struct pex_vars *)dmp->dmr_vars)->dpy,
		 ((struct pex_vars *)dmp->dmr_vars)->win,
		 ExposureMask|ButtonPressMask|KeyPressMask|StructureNotifyMask);
#endif

#if 1
    Pex_configure_window_shape(dmp);
#endif

    Tk_SetWindowBackground(((struct pex_vars *)dmp->dmr_vars)->xtkwin, ((struct pex_vars *)dmp->dmr_vars)->bg);
    Tk_MapWindow(((struct pex_vars *)dmp->dmr_vars)->xtkwin);

    return TCL_OK;
}

/*
 *  			P E X _ C L O S E
 *
 *  Gracefully release the display.
 */
static void
Pex_close(dmp)
struct dm *dmp;
{
  if(((struct pex_vars *)dmp->dmr_vars)->gc != 0)
    XFreeGC(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc);

#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
  if(((struct pex_vars *)dmp->dmr_vars)->pix != 0)
     Tk_FreePixmap(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->pix);
#endif

  if(((struct pex_vars *)dmp->dmr_vars)->xtkwin != 0)
    Tk_DestroyWindow(((struct pex_vars *)dmp->dmr_vars)->xtkwin);

  if(((struct pex_vars *)dmp->dmr_vars)->l.forw != BU_LIST_NULL)
    BU_LIST_DEQUEUE(&((struct pex_vars *)dmp->dmr_vars)->l);

  bu_free(dmp->dmr_vars, "Pex_close: dmp->dmr_vars");

  if(BU_LIST_IS_EMPTY(&head_pex_vars.l))
    Tk_DeleteGenericHandler(dmp->dmr_eventhandler, (ClientData)DM_TYPE_PEX);
}

/*
 *			P E X _ P R O L O G
 *
 * There are global variables which are parameters to this routine.
 */
static void
Pex_prolog(dmp)
struct dm *dmp;
{
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
  XGCValues       gcv;

  gcv.foreground = ((struct pex_vars *)dmp->dmr_vars)->bg;
  XChangeGC(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc,
	    GCForeground, &gcv);
  XFillRectangle(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->pix,
		 ((struct pex_vars *)dmp->dmr_vars)->gc, 0, 0,
		 ((struct pex_vars *)dmp->dmr_vars)->width + 1,
		 ((struct pex_vars *)dmp->dmr_vars)->height + 1);
#else
  XClearWindow(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->win);
#endif
}

/*
 *			P E X _ E P I L O G
 */
static void
Pex_epilog(dmp)
struct dm *dmp;
{
  /* Put the center point up last */
  draw( dmp, 0, 0, 0, 0 );

#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
  XCopyArea(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->pix,
	    ((struct pex_vars *)dmp->dmr_vars)->win, ((struct pex_vars *)dmp->dmr_vars)->gc, 0, 0,
	    ((struct pex_vars *)dmp->dmr_vars)->width, ((struct pex_vars *)dmp->dmr_vars)->height,
	    0, 0);
#endif

  /* Prevent lag between events and updates */
  XSync(((struct pex_vars *)dmp->dmr_vars)->dpy, 0);
}

/*
 *  			P E X _ N E W R O T
 */
/* ARGSUSED */
static void
Pex_newrot(dmp, mat)
struct dm *dmp;
mat_t mat;
{
  float *mptr;
  int perspective;
  int err;
  PEXViewEntry view;

#if 0
  static PEXNPCSubVolume viewport = { { 0.0, 0.0, 0.0 }, { 1.0, 1.0, 1.0 } };

  /* specified in view coordinates */
  static PEXCoord prp = { 0.0, 0.0, 2.0 };
  static PEXCoord2D view_win[] = { {-2.0, -2.0}, {2.0, 2.0} };
  static double front = 2.0;
  static double view_plane = 0.0;
  static double back = -2.0;

  /* specified in world coordinates */
  static PEXVector vpn = { 0.5, 0.5, 1.0 };
  static PEXVector vuv = { 0.0, 1.0, 0.0 };
  static PEXCoord vrp = { 0.0, 0.0, 0.0 };

  if((err = PEXViewOrientationMatrix(&vrp, &vpn, &vuv, view.orientation)) != 0){
    bu_log("Pex_newrot: bad PEXViewOrientationMatrix return - %d\n", err);
    return;
  }
#else
  static PEXNPCSubVolume viewport = { { 0.0, 0.0, 0.0 }, { 1.0, 1.0, 1.0 } };
  static PEXCoord2D view_win[] = { { -1.0, -1.0 }, { 1.0, 1.0 } };
  static PEXCoord prp = { 0.0, 0.0, 1.0 };
  static double front = 1.0;
  static double view_plane = 0.0;
  static double back = -1.0;

  Pex_mat_copy(view.orientation, mat);
#endif

  perspective = 0;
  if((err = PEXViewMappingMatrix(view_win, &viewport, perspective,
				 &prp, view_plane, back, front,
				 view.mapping)) != 0){
    bu_log("Pex_newrot: bad PEXViewMappingMatrix return - %d\n", err);
    return;
  }

#if 1
  view.clip_flags = 0;
#else
  view.clip_flags = PEXClippingAll;
#endif
  view.clip_limits = viewport;

  PEXSetTableEntries(((struct pex_vars *)dmp->dmr_vars)->dpy,
		     ((struct pex_vars *)dmp->dmr_vars)->rattrs.view_table,
		     view_num, 1, PEXLUTView, (PEXPointer)&view);
#if 0
  PEXSetViewIndex(((struct pex_vars *)dmp->dmr_vars)->dpy,
		  ((struct pex_vars *)dmp->dmr_vars)->renderer,
		  PEXOCRender, view_num);
#endif
}

/*
 *  			P E X _ O B J E C T
 *
 *  Set up for an object, transformed as indicated, and with an
 *  object center as specified.  The ratio of object to screen size
 *  is passed in as a convienience.
 *
 *  Returns 0 if object could be drawn, !0 if object was omitted.
 */

/* ARGSUSED */
static int
Pex_object( dmp, vp, m, linestyle, r, g, b )
struct dm *dmp;
register struct bn_vlist *vp;
fastf_t *m;
int linestyle;
register short r, g, b;
{
  register struct bn_vlist    *tvp;
  PEXCoord coord_buf[1024];
  PEXCoord *cp;                /* current coordinate */
  int first;
  int ncoord;                  /* number of coordinates */
  PEXColor color;

  PEXBeginRendering(((struct pex_vars *)dmp->dmr_vars)->dpy,
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
		    ((struct pex_vars *)dmp->dmr_vars)->pix,
#else
		    ((struct pex_vars *)dmp->dmr_vars)->win,
#endif
		    ((struct pex_vars *)dmp->dmr_vars)->renderer);
  {
#if 0
    if( illum ){
      SET_COLOR( 0.9, 0.9, 0.9, color );
    }else{
      SET_COLOR( r / 255.0, g / 255.0,
		 b / 255.0, color );
    }
#else
    SET_COLOR( r / 255.0, g / 255.0, b / 255.0, color );
#endif

    PEXSetLineColor(((struct pex_vars *)dmp->dmr_vars)->dpy,
		    ((struct pex_vars *)dmp->dmr_vars)->renderer,
		    PEXOCRender, PEXColorTypeRGB, &color);

    PEXSetLineWidth(((struct pex_vars *)dmp->dmr_vars)->dpy,
		    ((struct pex_vars *)dmp->dmr_vars)->renderer,
		    PEXOCRender, 1.0);

    if( linestyle )
      PEXSetLineType(((struct pex_vars *)dmp->dmr_vars)->dpy,
		     ((struct pex_vars *)dmp->dmr_vars)->renderer,
		     PEXOCRender, PEXLineTypeDashed);
    else
      PEXSetLineType(((struct pex_vars *)dmp->dmr_vars)->dpy,
		     ((struct pex_vars *)dmp->dmr_vars)->renderer,
		     PEXOCRender, PEXLineTypeSolid);

    ncoord = 0;
    cp = coord_buf;
    first = 1;
    for( BU_LIST_FOR( tvp, bn_vlist, &vp->l ) )  {
      register int	i;
      register int	nused = tvp->nused;
      register int	*cmd = tvp->cmd;
      register point_t *pt = tvp->pt;

      /* Viewing region is from -1.0 to +1.0 */
      /* 2^31 ~= 2e9 -- dynamic range of a long int */
      /* 2^(31-11) = 2^20 ~= 1e6 */
      for( i = 0; i < nused; i++,cmd++,pt++ )  {
	switch( *cmd )  {
	case BN_VLIST_POLY_START:
	case BN_VLIST_POLY_VERTNORM:
	  break;
	case BN_VLIST_LINE_MOVE:
	  /* Move, start line */
	  if( first == 0 ){
	    PEXPolyline(((struct pex_vars *)dmp->dmr_vars)->dpy,
			((struct pex_vars *)dmp->dmr_vars)->renderer,
			PEXOCRender, ncoord, coord_buf);

	    ncoord = 0;
	    cp = coord_buf;
	  }

	  first = 0;
	  Pex_VMOVE(*cp, *pt);
	  ++cp;
	  ++ncoord;
	  break;
	case BN_VLIST_LINE_DRAW:
	case BN_VLIST_POLY_MOVE:
	case BN_VLIST_POLY_DRAW:
	  Pex_VMOVE(*cp, *pt);
	  ++cp;
	  ++ncoord;
	  break;
	case BN_VLIST_POLY_END:
	  Pex_VMOVE(*cp, *pt);
	  ++ncoord;

	  PEXPolyline(((struct pex_vars *)dmp->dmr_vars)->dpy,
		      ((struct pex_vars *)dmp->dmr_vars)->renderer,
		      PEXOCRender, ncoord, coord_buf);

	  ncoord = 0;
	  cp = coord_buf;
	  first = 1;
	  break;
	}
      }
    }

    if( first == 0)
      PEXPolyline(((struct pex_vars *)dmp->dmr_vars)->dpy,
		  ((struct pex_vars *)dmp->dmr_vars)->renderer,
		  PEXOCRender, ncoord, coord_buf);

    if (linestyle) /* restore solid lines */
      PEXSetLineType(((struct pex_vars *)dmp->dmr_vars)->dpy,
		     ((struct pex_vars *)dmp->dmr_vars)->renderer,
		     PEXOCRender, PEXLineTypeSolid);
  }
  PEXEndRendering(((struct pex_vars *)dmp->dmr_vars)->dpy,
		  ((struct pex_vars *)dmp->dmr_vars)->renderer, True);

  return 1;        /* OK */
}

/*
 *			P E X _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 * Turns off windowing.
 */
static void
Pex_normal(dmp)
struct dm *dmp;
{
	return;
}

/*
 *			P E X _ U P D A T E
 *
 * Transmit accumulated displaylist to the display processor.
 */
static void
Pex_update(dmp)
struct dm *dmp;
{
    XFlush(((struct pex_vars *)dmp->dmr_vars)->dpy);
}

/*
 *			P E X _ P U T S
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
static void
Pex_puts( dmp, str, x, y, size, r, g, b )
struct dm *dmp;
register char *str;
int x, y;
int size;
register short r, g, b;
{
	XGCValues gcv;
#if 0
	unsigned long fg;

	switch( color )  {
	case DM_BLACK:
		fg = ((struct pex_vars *)dmp->dmr_vars)->black;
		break;
	case DM_RED:
		fg = ((struct pex_vars *)dmp->dmr_vars)->red;
		break;
	case DM_BLUE:
		fg = ((struct pex_vars *)dmp->dmr_vars)->blue;
		break;
	default:
	case DM_YELLOW:
		fg = ((struct pex_vars *)dmp->dmr_vars)->yellow;
		break;
	case DM_WHITE:
		fg = ((struct pex_vars *)dmp->dmr_vars)->gray;
		break;
	}
	gcv.foreground = fg;
	XChangeGC( ((struct pex_vars *)dmp->dmr_vars)->dpy,
		   ((struct pex_vars *)dmp->dmr_vars)->gc, GCForeground, &gcv );
#else
	PEXColor color;

	PEXSetTextColor(((struct pex_vars *)dmp->dmr_vars)->dpy,
			((struct pex_vars *)dmp->dmr_vars)->renderer,
			PEXOCRender, PEXColorTypeRGB, &color);
#endif
	label( dmp, (double)x, (double)y, str );
}

/*
 *			P E X _ 2 D _ G O T O
 *
 */
static void
Pex_2d_line( dmp, x1, y1, x2, y2, dashed, r, g, b )
struct dm *dmp;
int x1, y1;
int x2, y2;
int dashed;
register short r, g, b;
{
#if 0
  PEXCoord2D coord_buf_2D[2];

  PEXBeginRendering(((struct pex_vars *)dmp->dmr_vars)->dpy,
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
		    ((struct pex_vars *)dmp->dmr_vars)->pix,
#else
		    ((struct pex_vars *)dmp->dmr_vars)->win,
#endif
		    ((struct pex_vars *)dmp->dmr_vars)->renderer);
  {

    coord_buf_2D[0].x = x1;
    coord_buf_2D[0].y = y1;
    coord_buf_2D[1].x = x2;
    coord_buf_2D[1].y = y2;

    PEXSetLineWidth(((struct pex_vars *)dmp->dmr_vars)->dpy,
		    ((struct pex_vars *)dmp->dmr_vars)->renderer,
		    PEXOCRender, 1.0);

    if( dashed ){
      PEXSetLineType(((struct pex_vars *)dmp->dmr_vars)->dpy,
		     ((struct pex_vars *)dmp->dmr_vars)->renderer,
		     PEXOCRender, PEXLineTypeDashed);
    }else{
      PEXSetLineType(((struct pex_vars *)dmp->dmr_vars)->dpy,
					  ((struct pex_vars *)dmp->dmr_vars)->renderer,
					  PEXOCRender, PEXLineTypeSolid);
    }


    PEXPolyline2D(((struct pex_vars *)dmp->dmr_vars)->dpy,
		((struct pex_vars *)dmp->dmr_vars)->renderer,
		PEXOCRender, 2, coord_buf_2D);

  }
  PEXEndRendering(((struct pex_vars *)dmp->dmr_vars)->dpy,
		  ((struct pex_vars *)dmp->dmr_vars)->renderer, True);
#else
    XGCValues gcv;

    gcv.foreground = ((struct pex_vars *)dmp->dmr_vars)->yellow;
    XChangeGC( ((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc, GCForeground, &gcv );
    if( dashed ) {
	XSetLineAttributes(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc, 1, LineOnOffDash, CapButt, JoinMiter );
    } else {
	XSetLineAttributes(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc, 1, LineSolid, CapButt, JoinMiter );
    }
    draw( dmp, x1, y1, x2, y2 );
#endif
}

/*
 *			P E X _ I N P U T
 *
 * Execution must suspend in this routine until a significant event
 * has occured on either the command stream,
 * unless "noblock" is set.
 *
 *
 * Implicit Return -
 *	If any files are ready for input, their bits will be set in 'input'.
 *	Otherwise, 'input' will be all zeros.
 *
 * DEPRECATED
 *
 */
/* ARGSUSED */
static void
Pex_input( dmp, input, noblock )
struct dm *dmp;
fd_set		*input;
int		noblock;
{
    return;
}

/*
 *			P E X _ L I G H T
 */
/* ARGSUSED */
static void
Pex_light( dmp, cmd, func )
struct dm *dmp;
int cmd;
int func;			/* BE_ or BV_ function */
{
	return;
}

/* ARGSUSED */
static unsigned
Pex_cvtvecs( dmp, sp )
struct dm *dmp;
struct solid *sp;
{
	return( 0 );
}

/*
 * Loads displaylist
 */
static unsigned
Pex_load( dmp, addr, count )
struct dm *dmp;
unsigned addr, count;
{
	bu_log("Pex_load(x%x, %d.)\n", addr, count );
	return( 0 );
}

static void
Pex_viewchange(dmp)
struct dm *dmp;
{
  return;
}

static void
Pex_colorchange(dmp)
struct dm *dmp;
{
#if TRY_DEPTHCUE
  PEXDepthCueEntry cue_entry;

  if(((struct pex_vars *)dmp->dmr_vars)->mvars.cue)
    cue_entry.mode = PEXOn;
  else
    cue_entry.mode = PEXOff;

  cue_entry.front_plane = 0.9;
  cue_entry.back_plane = 0.1;
  cue_entry.front_scaling = 1;
  cue_entry.back_scaling = 0.5;
  SET_COLOR( 0, 0, 0, cue_entry.color.value );

  PEXSetTableEntries( ((struct pex_vars *)dmp->dmr_vars)->dpy,
		      ((struct pex_vars *)dmp->dmr_vars)->rattrs.depth_cue_table,
		      cue_num, 1, PEXLUTDepthCue, &cue_entry );
#endif
}

/* ARGSUSED */
static void
Pex_debug(dmp, lvl)
struct dm *dmp;
{
	XFlush(((struct pex_vars *)dmp->dmr_vars)->dpy);
	bu_log("flushed\n");
}

static void
Pex_window(dmp, w)
struct dm *dmp;
register int w[];
{
#if 0
	/* Compute the clipping bounds */
	clipmin[0] = w[1] / 2048.;
	clipmin[1] = w[3] / 2048.;
	clipmin[2] = w[5] / 2048.;
	clipmax[0] = w[0] / 2047.;
	clipmax[1] = w[2] / 2047.;
	clipmax[2] = w[4] / 2047.;
#endif
}

/*********XXX**********/
/*
 *  Called for 2d_line, and dot at center of screen.
 */
static void
draw( dmp, x1, y1, x2, y2 )
struct dm *dmp;
int	x1, y1;		/* from point */
int	x2, y2;		/* to point */
{
  int	sx1, sy1, sx2, sy2;

  sx1 = GED_TO_Xx( dmp, x1 );
  sy1 = GED_TO_Xy( dmp, y1 );
  sx2 = GED_TO_Xx( dmp, x2 );
  sy2 = GED_TO_Xy( dmp, y2 );

  if( sx1 == sx2 && sy1 == sy2 )
    XDrawPoint( ((struct pex_vars *)dmp->dmr_vars)->dpy,
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
		((struct pex_vars *)dmp->dmr_vars)->pix,
#else
		((struct pex_vars *)dmp->dmr_vars)->win,
#endif
		((struct pex_vars *)dmp->dmr_vars)->gc, sx1, sy1 );
  else
    XDrawLine( ((struct pex_vars *)dmp->dmr_vars)->dpy,
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
	       ((struct pex_vars *)dmp->dmr_vars)->pix,
#else
	       ((struct pex_vars *)dmp->dmr_vars)->win,
#endif
	       ((struct pex_vars *)dmp->dmr_vars)->gc, sx1, sy1, sx2, sy2 );
}

static void
label( dmp, x, y, str )
struct dm *dmp;
double	x, y;
char	*str;
{
  int	sx, sy;

  sx = GED_TO_Xx( dmp, x );
  sy = GED_TO_Xy( dmp, y );
  /* point is center of text? - seems like what MGED wants... */
  /* The following makes the menu look good, the rest bad */
  /*sy += ((struct pex_vars *)dmp->dmr_vars)->fontstruct->maPex_bounds.ascent + ((struct pex_vars *)dmp->dmr_vars)->fontstruct->maPex_bounds.descent/2);*/

  XDrawString( ((struct pex_vars *)dmp->dmr_vars)->dpy,
#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
	       ((struct pex_vars *)dmp->dmr_vars)->pix,
#else
	       ((struct pex_vars *)dmp->dmr_vars)->win,
#endif
	       ((struct pex_vars *)dmp->dmr_vars)->gc, sx, sy, str, strlen(str) );
}

static XWMHints xwmh = {
	StateHint,		        /* flags */
	0,				/* input */
	NormalState,			/* initial_state */
	0,				/* icon pixmap */
	0,				/* icon window */
	0, 0,				/* icon location */
	0,				/* icon mask */
	0				/* Window group */
};

void
Pex_configure_window_shape(dmp)
struct dm *dmp;
{
  XWindowAttributes xwa;
  XFontStruct     *newfontstruct;
  XGCValues       gcv;

  XGetWindowAttributes( ((struct pex_vars *)dmp->dmr_vars)->dpy,
			((struct pex_vars *)dmp->dmr_vars)->win, &xwa );
  ((struct pex_vars *)dmp->dmr_vars)->height = xwa.height;
  ((struct pex_vars *)dmp->dmr_vars)->width = xwa.width;

#ifdef DOUBLE_BUFFERING_WITH_PIXMAPS
    if(((struct pex_vars *)dmp->dmr_vars)->height != ((struct pex_vars *)dmp->dmr_vars)->pix_height ||
       ((struct pex_vars *)dmp->dmr_vars)->width != ((struct pex_vars *)dmp->dmr_vars)->pix_width){
      Tk_FreePixmap( ((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->pix );

      ((struct pex_vars *)dmp->dmr_vars)->pix_width = ((struct pex_vars *)dmp->dmr_vars)->width;
      ((struct pex_vars *)dmp->dmr_vars)->pix_height = ((struct pex_vars *)dmp->dmr_vars)->height;
      ((struct pex_vars *)dmp->dmr_vars)->pix =
	Tk_GetPixmap(((struct pex_vars *)dmp->dmr_vars)->dpy,
		     DefaultRootWindow(((struct pex_vars *)dmp->dmr_vars)->dpy),
		     ((struct pex_vars *)dmp->dmr_vars)->pix_width,
		     ((struct pex_vars *)dmp->dmr_vars)->pix_height,
		     Tk_Depth(((struct pex_vars *)dmp->dmr_vars)->xtkwin));
    }
#endif

  /* First time through, load a font or quit */
  if (((struct pex_vars *)dmp->dmr_vars)->fontstruct == NULL) {
    if ((((struct pex_vars *)dmp->dmr_vars)->fontstruct = XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, FONT9)) == NULL ) {
      /* Try hardcoded backup font */
      if ((((struct pex_vars *)dmp->dmr_vars)->fontstruct = XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, FONTBACK)) == NULL) {
	Tcl_AppendResult(interp, "dm-X: Can't open font '", FONT9,
			 "' or '", FONTBACK, "'\n", (char *)NULL);
	return;
      }
    }

    gcv.font = ((struct pex_vars *)dmp->dmr_vars)->fontstruct->fid;
    XChangeGC(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc,
	      GCFont, &gcv);
  }

  /* Always try to choose a the font that best fits the window size.
   */

  if (((struct pex_vars *)dmp->dmr_vars)->width < 582) {
    if (((struct pex_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, FONT5)) != NULL ) {
	XFreeFont(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->fontstruct);
	((struct pex_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct pex_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
      }
    }
  } else if (((struct pex_vars *)dmp->dmr_vars)->width < 679) {
    if (((struct pex_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, FONT6)) != NULL ) {
	XFreeFont(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->fontstruct);
	((struct pex_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct pex_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
      }
    }
  } else if (((struct pex_vars *)dmp->dmr_vars)->width < 776) {
    if (((struct pex_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, FONT7)) != NULL ) {
	XFreeFont(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->fontstruct);
	((struct pex_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct pex_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
      }
    }
  } else if (((struct pex_vars *)dmp->dmr_vars)->width < 873) {
    if (((struct pex_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, FONT8)) != NULL ) {
	XFreeFont(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->fontstruct);
	((struct pex_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct pex_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
      }
    }
  } else {
    if (((struct pex_vars *)dmp->dmr_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct pex_vars *)dmp->dmr_vars)->dpy, FONT9)) != NULL ) {
	XFreeFont(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->fontstruct);
	((struct pex_vars *)dmp->dmr_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct pex_vars *)dmp->dmr_vars)->fontstruct->fid;
	XChangeGC(((struct pex_vars *)dmp->dmr_vars)->dpy, ((struct pex_vars *)dmp->dmr_vars)->gc,
		  GCFont, &gcv);
      }
    }
  }
}

void
Pex_establish_perspective(dmp)
struct dm *dmp;
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf( &vls, "set perspective %d\n",
		 ((struct pex_vars *)dmp->dmr_vars)->mvars.perspective_mode ?
		 perspective_table[((struct pex_vars *)dmp->dmr_vars)->perspective_angle] : -1 );

  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

#if 0
  dmaflag = 1;
#endif
}

/*
   This routine will toggle the perspective_angle if the
   dummy_perspective value is 0 or less. Otherwise, the
   perspective_angle is set to the value of (dummy_perspective - 1).
*/
void
Pex_set_perspective(dmp)
struct dm *dmp;
{
  /* set perspective matrix */
  if(((struct pex_vars *)dmp->dmr_vars)->mvars.dummy_perspective > 0)
    ((struct pex_vars *)dmp->dmr_vars)->perspective_angle = ((struct pex_vars *)dmp->dmr_vars)->mvars.dummy_perspective <= 4 ?
    ((struct pex_vars *)dmp->dmr_vars)->mvars.dummy_perspective - 1: 3;
  else if (--((struct pex_vars *)dmp->dmr_vars)->perspective_angle < 0) /* toggle perspective matrix */
    ((struct pex_vars *)dmp->dmr_vars)->perspective_angle = 3;

  if(((struct pex_vars *)dmp->dmr_vars)->mvars.perspective_mode){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf( &vls, "set perspective %d\n",
		   perspective_table[((struct pex_vars *)dmp->dmr_vars)->perspective_angle] );

    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
  }

  /*
    Just in case the "!" is used with the set command. This
    allows us to toggle through more than two values.
   */
  ((struct pex_vars *)dmp->dmr_vars)->mvars.dummy_perspective = 1;

#if 0
  dmaflag = 1;
#endif
}

static void
Pex_load_startup(dmp)
struct dm *dmp;
{
  char *filename;

  memset((void *)&head_pex_vars, 0, sizeof(struct pex_vars));
  BU_LIST_INIT( &head_pex_vars.l );

  if((filename = getenv("DM_PEX_RCFILE")) != (char *)NULL )
    Tcl_EvalFile(interp, filename);
}

static void
Pex_setup_renderer(dmp)
struct dm *dmp;
{
  unsigned long mask = 0;

/*XXX Slowly adding more stuff */

#if TRY_DEPTHCUE
  mask |= PEXRADepthCueTable;
  ((struct pex_vars *)dmp->dmr_vars)->rattrs.view_table =
    PEXCreateLookupTable(((struct pex_vars *)dmp->dmr_vars)->dpy,
			 ((struct pex_vars *)dmp->dmr_vars)->win, PEXLUTDepthCue);
#endif

  mask |= PEXRAViewTable;
  ((struct pex_vars *)dmp->dmr_vars)->rattrs.view_table =
    PEXCreateLookupTable(((struct pex_vars *)dmp->dmr_vars)->dpy,
			 ((struct pex_vars *)dmp->dmr_vars)->win, PEXLUTView);

  ((struct pex_vars *)dmp->dmr_vars)->renderer =
    PEXCreateRenderer(((struct pex_vars *)dmp->dmr_vars)->dpy,
		      ((struct pex_vars *)dmp->dmr_vars)->win,
		      mask, &((struct pex_vars *)dmp->dmr_vars)->rattrs);

#if TRY_DEPTHCUE
  PEXSetDepthCueIndex(((struct pex_vars *)dmp->dmr_vars)->dpy,
		  ((struct pex_vars *)dmp->dmr_vars)->renderer,
		  PEXOCRender, cue_num);
#endif

  PEXSetViewIndex(((struct pex_vars *)dmp->dmr_vars)->dpy,
		  ((struct pex_vars *)dmp->dmr_vars)->renderer,
		  PEXOCRender, view_num);
}

/* P E X _ M A T _ C O P Y
 *
 * Copy the Brlcad matrix to a PEX matrix
 */
static void
Pex_mat_copy( dest, src )
register PEXMatrix	dest;
register const mat_t	src;
{
  register int i, j, k;

  k = 0;

  /* Copy all elements */
#if 1
  /* regular copy */
  for( i=0; i<4; ++i)
    for( j=0; j<4; ++j)
      dest[i][j] = src[k++];
#else
  /* transpose copy */
  for( i=0; i<4; ++i)
    for( j=0; j<4; ++j)
      dest[j][i] = src[k++];
#endif
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.20
log
@whoops, here's to reviewing all commit e-mails even when I make them.. apparently edited out the wrong line for noalias.h
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.18 2007/10/22 20:59:55 brlcad Exp $ (BRL)";
d1160 1
a1160 1
  bzero((void *)&head_pex_vars, sizeof(struct pex_vars));
@


14.19
log
@removed the non-ansi/stc compliant noalias.h and noalias-prag.h headers that were used with the cray (and alliant) to make pragma decls before loops.  made obsolete long ago with the move to ansi compliance.
@
text
@a1216 1
#include "noalias.h"
d1225 1
@


14.18
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.17 2007/05/14 21:04:31 brlcad Exp $ (BRL)";
a1225 1
    for( j=0; j<4; ++j)
@


14.17
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.16 2007/01/27 01:41:37 brlcad Exp $ (BRL)";
a344 2
#ifndef CRAY2
#if 1
a355 1
#endif
a359 6
#else
    ((struct pex_vars *)dmp->dmr_vars)->gc = XCreateGC(((struct pex_vars *)dmp->dmr_vars)->dpy,
					       ((struct pex_vars *)dmp->dmr_vars)->win,
					       (GCForeground|GCBackground),
					       &gcv);
#endif
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.15 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
d560 1
a560 1
register struct rt_vlist *vp;
d565 1
a565 1
  register struct rt_vlist    *tvp;
d611 1
a611 1
    for( BU_LIST_FOR( tvp, rt_vlist, &vp->l ) )  {
d622 2
a623 2
	case RT_VLIST_POLY_START:
	case RT_VLIST_POLY_VERTNORM:
d625 1
a625 1
	case RT_VLIST_LINE_MOVE:
d641 3
a643 3
	case RT_VLIST_LINE_DRAW:
	case RT_VLIST_POLY_MOVE:
	case RT_VLIST_POLY_DRAW:
d648 1
a648 1
	case RT_VLIST_POLY_END:
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.14 2007/01/20 14:36:52 brlcad Exp $ (BRL)";
d171 1
a171 1
        return TCL_OK;
d795 2
a796 2
		                          ((struct pex_vars *)dmp->dmr_vars)->renderer,
		                          PEXOCRender, PEXLineTypeSolid);
d995 1
a995 1
        StateHint,		        /* flags */
@


14.14
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d38 1
a38 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.13 2006/08/24 17:49:41 brlcad Exp $ (BRL)";
@


14.13
log
@according to one of the tcl devs (thx jenglish), Tk_IsMapped() is not what we should be using to determine if the tkwin is 'valid' .. being 'mapped' apparently means that there is a window that has been explicitly mapped via a Tk_MapWindow() call or is otherwise fully drawn/displayed.  fall back to a simple non-null check instead.
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2006 United States Government as represented by
d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.12 2006/08/23 14:53:11 brlcad Exp $ (BRL)";
@


14.12
log
@missed pex interface, use xtkwin insted of dpy with Tk_IsMapped()
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.11 2006/08/19 21:00:34 brlcad Exp $ (BRL)";
d185 1
a185 2
Pex_open(dmp)
struct dm *dmp;
d216 1
d224 1
a224 1
  if (!((struct pex_vars *)dmp->dm_vars)->dpy || !Tk_IsMapped(((struct pex_vars *)dmp->dm_vars)->xtkwin)) {
@


14.11
log
@make sure we actually got a display before proceeding with the display manager initialization.  this prevents the display manager from crashing out quickly upon startup when some condition fails (like there not being an X11 server to connect to, then attempting to get the size of that display or a screen, etc)
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.10 2006/08/11 06:33:44 brlcad Exp $ (BRL)";
d224 1
a224 1
  if (!((struct pex_vars *)dmp->dm_vars)->dpy || !Tk_IsMapped(((struct pex_vars *)dmp->dm_vars)->dpy)) {
@


14.10
log
@HAVE_XOSDEFS_H was a conf.h fictional, update to new configure check for HAVE_X11_XOSDEFS_H and clean up header foo some.
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.9 2006/01/23 04:36:32 brlcad Exp $ (BRL)";
d222 8
@


14.9
log
@need stdlib.h for getenv()
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.8 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
a41 6
#define DO_XSELECTINPUT 0
#define SET_COLOR( r, g, b, c ) { \
	(c).rgb.red = (r); \
	(c).rgb.green = (g); \
	(c).rgb.blue = (b);}

a43 2
#include "tk.h"

d58 2
d67 7
@


14.8
log
@update copyright to 2006
@
text
@d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.7 2005/10/23 04:44:33 brlcad Exp $ (BRL)";
a49 1

d52 1
d54 2
a55 2
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
d58 2
a59 2
#	undef   X_NOT_STDC_ENV
#	undef   X_NOT_POSIX
a68 3
#if 0
#include "mater.h"
#endif
a71 3
#if 0
#include "solid.h"
#endif
@


14.7
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1988-2005 United States Government as represented by
d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.6 2005/01/30 20:30:47 brlcad Exp $ (BRL)";
@


14.6
log
@update copyright to 2005
@
text
@d36 1
a36 1
 *  
d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-pex.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
d241 1
a241 1
		     ((struct pex_vars *)dmp->dmr_vars)->width, 
d294 1
a294 1
    
d403 1
a403 1
 *  
d503 1
a503 1
  
d546 1
a546 1
 *  
d782 1
a782 1
    
d786 1
a786 1
		                        
d797 1
a797 1
    
d831 1
a831 1
 * DEPRECATED 
d844 1
a844 1
/* 
@


14.6.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d36 1
a36 1
 *
d39 1
a39 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d241 1
a241 1
		     ((struct pex_vars *)dmp->dmr_vars)->width,
d294 1
a294 1

d403 1
a403 1
 *
d503 1
a503 1

d546 1
a546 1
 *
d782 1
a782 1

d786 1
a786 1

d797 1
a797 1

d831 1
a831 1
 * DEPRECATED
d844 1
a844 1
/*
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2004 United States Government as represented by
d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-pex.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a36 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
d39 1
a39 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-pex.c,v 14.3 2004/12/21 05:45:22 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-pex.c,v 14.2 2004/12/21 02:24:40 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-pex.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 3
/* Experimental. */
/*
 *			D M - P E X . C
d27 2
d42 1
a42 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-pex.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-pex.c,v 1.2 2004/06/08 22:04:19 morrison Exp $ (BRL)";
d1220 10
@


1.2
log
@obliterate externs.h
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d31 1
a31 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d22 1
a22 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libdm/dm-pex.c,v 1.11 2004/05/10 15:30:44 erikg Exp $ (BRL)";
a51 1
#include "externs.h"
@

