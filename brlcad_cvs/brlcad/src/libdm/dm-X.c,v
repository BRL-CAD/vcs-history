head	14.27;
access;
symbols
	rel-7-10-4:14.25.2.1
	STABLE:14.25.0.2
	stable-branch:14.7
	rel-7-10-2:14.25
	rel-7-10-0:14.23
	rel-7-8-4:14.21
	rel-7-8-2:14.14
	rel-7-8-0:14.14
	trimnurbs-branch:14.14.0.2
	help:14.14
	temp_tag:14.11
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.11
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.2
	rel-7-6-0:14.8
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.7
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.27
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.09.15.16.23.10;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.05.14.21.04.31;	author brlcad;	state Exp;
branches
	14.25.2.1;
next	14.24;

14.24
date	2007.04.23.13.30.19;	author joevalleyfield;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2006.08.24.17.49.41;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.08.22.21.19.02;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.08.19.21.00.34;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.08.14.17.31.01;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.08.11.06.42.30;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.08.11.06.33.44;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.10.02.07.25;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.02.07.06.25.05;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.23.04.36.32;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.31.06.08.20;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.33;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.09.16.18.58.34;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.08.27.14.24.33;	author brlcad;	state Exp;
branches
	14.8.2.1;
next	14.7;

14.7
date	2005.03.13.00.43.39;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.47;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.02.24.40;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.03.20.42.29;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.19;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.37;	author morrison;	state Exp;
branches;
next	;

14.8.2.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.25.2.1
date	2007.09.28.14.04.31;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.27
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@/*                          D M - X . C
 * BRL-CAD
 *
 * Copyright (c) 1988-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file dm-X.c
 *
 *  An X Window System Display Manager.
 *
 *  Author -
 *	Phillip Dykstra
 *	Robert G. Parker
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.26 2007/09/15 16:23:10 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#ifdef DM_X

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>

#include <X11/Xlib.h>
#include <X11/Xutil.h>

#define USE_DIALS_AND_BUTTONS 1

#ifdef HAVE_X11_XOSDEFS_H
#  include <X11/Xfuncproto.h>
#  include <X11/Xosdefs.h>
#endif
#if USE_DIALS_AND_BUTTONS
#  include <X11/extensions/XInput.h>
#endif
#if defined(linux)
#  undef   X_NOT_STDC_ENV
#  undef   X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */

#include "tk.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "dm.h"
#include "dm-X.h"
#include "dm_xvars.h"
#include "solid.h"


HIDDEN void	label();
HIDDEN void	draw();
HIDDEN void     x_var_init();
HIDDEN XVisualInfo *X_choose_visual(struct dm *dmp);

/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
struct dm	*X_open_dm(Tcl_Interp *interp, int argc, char **argv);
HIDDEN int	X_close_dm(struct dm *dmp);
HIDDEN int	X_drawBegin(struct dm *dmp), X_drawEnd(struct dm *dmp);
HIDDEN int	X_normal(struct dm *dmp), X_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int      X_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect);
HIDDEN int	X_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      X_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	X_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency);
HIDDEN int	X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	X_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	X_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	X_configureWin(struct dm *dmp);
HIDDEN int	X_setLight(struct dm *dmp, int light_on);
HIDDEN int	X_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	X_setWinBounds(struct dm *dmp, register int *w), X_debug(struct dm *dmp, int lvl);

struct dm dm_X = {
    X_close_dm,
    X_drawBegin,
    X_drawEnd,
    X_normal,
    X_loadMatrix,
    X_drawString2D,
    X_drawLine2D,
    X_drawPoint2D,
    X_drawVList,
    X_setFGColor,
    X_setBGColor,
    X_setLineAttr,
    X_configureWin,
    X_setWinBounds,
    X_setLight,
    Nu_int0,
    Nu_int0,
    X_setZBuffer,
    X_debug,
    Nu_int0,
    Nu_int0,
    Nu_int0,
    Nu_int0,
    0,
    0,				/* no displaylist */
    0,                            /* no stereo */
    PLOTBOUND,			/* zoom-in limit */
    1,				/* bound flag */
    "X",
    "X Window System (X11)",
    DM_TYPE_X,
    1,
    0,
    0,
    0,
    0,
    1.0, /* aspect ratio */
    0,
    {0, 0},
    {0, 0, 0, 0, 0},		/* bu_vls path name*/
    {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
    {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
    {0, 0, 0},			/* bg color */
    {0, 0, 0},			/* fg color */
    {GED_MIN, GED_MIN, GED_MIN},	/* clipmin */
    {GED_MAX, GED_MAX, GED_MAX},	/* clipmax */
    0,				/* no debugging */
    0,				/* no perspective */
    0,				/* no lighting */
    0,				/* no transparency */
    0,				/* depth buffer is not writable */
    0,				/* no zbuffer */
    0,				/* no zclipping */
    1,                            /* clear back buffer after drawing and swap */
    0				/* Tcl interpreter */
};

fastf_t min_short = (fastf_t)SHRT_MIN;
fastf_t max_short = (fastf_t)SHRT_MAX;

extern int vectorThreshold;	/* defined in libdm/tcl.c */

static void
get_color(Display *dpy, Colormap cmap, XColor *color)
{
    Status st;
    XColor rgb;
#define CSCK   0xf800

    rgb = *color;

    st = XAllocColor(dpy, cmap, color);
    switch (st) {
	case 1:
#if 0
	    if ( (color->red & CSCK) != (rgb.red & CSCK) ||
		 (color->green & CSCK) != (rgb.green & CSCK) ||
		 (color->blue & CSCK) != (rgb.blue & CSCK) ) {
		bu_log("\nlooking for fg    (%3d,%3d,%3d) %04x,%04x,%04x got \n                  (%3d,%3d,%3d) %04x,%04x,%04x\n",
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue,

		       (color->red >> 8), (color->green >> 8), (color->blue >> 8),
		       color->red, color->green, color->blue);
	    }
#endif
	    break;
	case BadColor:
	    bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n",
		   (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		   rgb.red, rgb.green, rgb.blue);
	    break;

	default:
	    bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n",
		   (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		   rgb.red, rgb.green, rgb.blue);
	    break;
    }
#undef CSCK

}

/*
 *			X _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
struct dm *
X_open_dm(Tcl_Interp *interp, int argc, char **argv)
{
    static int count = 0;
    int make_square = -1;
    XGCValues gcv;
#if USE_DIALS_AND_BUTTONS
    int j, k;
    int ndevices;
    int nclass = 0;
    int unused;
    XDeviceInfoPtr olist = NULL, list = NULL;
    XDevice *dev = NULL;
    XEventClass e_class[15];
    XInputClassInfo *cip = NULL;
#endif
    struct bu_vls str;
    struct bu_vls init_proc_vls;
    struct dm *dmp = (struct dm *)NULL;
    Tk_Window tkwin;

    struct dm_xvars *pubvars = NULL;
    struct x_vars *privars = NULL;

    if ((tkwin = Tk_MainWindow(interp)) == NULL) {
	return DM_NULL;
    }

    BU_GETSTRUCT(dmp, dm);
    if(dmp == DM_NULL) {
	return DM_NULL;
    }

    *dmp = dm_X; /* struct copy */
    dmp->dm_interp = interp;

    dmp->dm_vars.pub_vars = (genptr_t)bu_calloc(1, sizeof(struct dm_xvars), "X_open_dm: dm_xvars");
    if(dmp->dm_vars.pub_vars == (genptr_t)NULL){
	bu_free((genptr_t)dmp, "X_open_dm: dmp");
	return DM_NULL;
    }
    pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;

    dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct x_vars), "X_open_dm: x_vars");
    if(dmp->dm_vars.priv_vars == (genptr_t)NULL){
	bu_free((genptr_t)dmp->dm_vars.pub_vars, "X_open_dm: dmp->dm_vars.pub_vars");
	bu_free((genptr_t)dmp, "X_open_dm: dmp");
	return DM_NULL;
    }
    privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    bu_vls_init(&dmp->dm_pathName);
    bu_vls_init(&dmp->dm_tkName);
    bu_vls_init(&dmp->dm_dName);
    bu_vls_init(&init_proc_vls);

    dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);

    if(bu_vls_strlen(&dmp->dm_pathName) == 0)
	bu_vls_printf(&dmp->dm_pathName, ".dm_X%d", count);

    ++count;
    if(bu_vls_strlen(&dmp->dm_dName) == 0){
	char *dp;

	dp = getenv("DISPLAY");
	if(dp)
	    bu_vls_strcpy(&dmp->dm_dName, dp);
	else
	    bu_vls_strcpy(&dmp->dm_dName, ":0.0");
    }
    if(bu_vls_strlen(&init_proc_vls) == 0)
	bu_vls_strcpy(&init_proc_vls, "bind_dm");

    /* initialize dm specific variables */
    pubvars->devmotionnotify = LASTEvent;
    pubvars->devbuttonpress = LASTEvent;
    pubvars->devbuttonrelease = LASTEvent;
    dmp->dm_aspect = 1.0;

    pubvars->fontstruct = NULL;

    if(dmp->dm_top){
	/* Make xtkwin a toplevel window */
	pubvars->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
						  bu_vls_addr(&dmp->dm_pathName),
						  bu_vls_addr(&dmp->dm_dName));
	pubvars->top = pubvars->xtkwin;
    }else{
	char *cp;

	cp = strrchr(bu_vls_addr(&dmp->dm_pathName), (int)'.');
	if(cp == bu_vls_addr(&dmp->dm_pathName)){
	    pubvars->top = tkwin;
	}else{
	    struct bu_vls top_vls;

	    bu_vls_init(&top_vls);
	    bu_vls_printf(&top_vls, "%*s", cp - bu_vls_addr(&dmp->dm_pathName),
			  bu_vls_addr(&dmp->dm_pathName));
	    pubvars->top =
		Tk_NameToWindow(interp, bu_vls_addr(&top_vls), tkwin);
	    bu_vls_free(&top_vls);
	}

	/* Make xtkwin an embedded window */
	pubvars->xtkwin =
	    Tk_CreateWindow(interp, pubvars->top,
			    cp + 1, (char *)NULL);
    }

    if(pubvars->xtkwin == NULL){
	bu_log("X_open_dm: Failed to open %s\n", bu_vls_addr(&dmp->dm_pathName));
	(void)X_close_dm(dmp);
	return DM_NULL;
    }

    bu_vls_printf(&dmp->dm_tkName, "%s",
		  (char *)Tk_Name(pubvars->xtkwin));

    bu_vls_init(&str);
    bu_vls_printf(&str, "_init_dm %S %S\n",
		  &init_proc_vls,
		  &dmp->dm_pathName);

    if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
	bu_vls_free(&str);
	(void)X_close_dm(dmp);
	return DM_NULL;
    }

    bu_vls_free(&init_proc_vls);
    bu_vls_free(&str);

    pubvars->dpy = Tk_Display(pubvars->top);

    /* make sure there really is a display before proceeding. */
    if (!pubvars->dpy) {
	(void)X_close_dm(dmp);
	return DM_NULL;
    }

    if(dmp->dm_width == 0){
	dmp->dm_width =
	    DisplayWidth(pubvars->dpy,
			 DefaultScreen(pubvars->dpy)) - 30;
	++make_square;
    }

    if(dmp->dm_height == 0){
	dmp->dm_height =
	    DisplayHeight(pubvars->dpy,
			  DefaultScreen(pubvars->dpy)) - 30;
	++make_square;
    }

    if(make_square > 0){
	/* Make window square */
	if(dmp->dm_height <
	   dmp->dm_width)
	    dmp->dm_width = dmp->dm_height;
	else
	    dmp->dm_height = dmp->dm_width;
    }

    Tk_GeometryRequest(pubvars->xtkwin,
		       dmp->dm_width,
		       dmp->dm_height);

#if 0
    /*XXX For debugging purposes */
    XSynchronize(pubvars->dpy, 1);
#endif

    /* must do this before MakeExist */
    if((pubvars->vip = X_choose_visual(dmp)) == NULL){
	bu_log("X_open_dm: Can't get an appropriate visual.\n");
	(void)X_close_dm(dmp);
	return DM_NULL;
    }

    Tk_MakeWindowExist(pubvars->xtkwin);
    pubvars->win =
	Tk_WindowId(pubvars->xtkwin);
    dmp->dm_id = pubvars->win;

    privars->pix =
	Tk_GetPixmap(pubvars->dpy,
		     DefaultRootWindow(pubvars->dpy),
		     dmp->dm_width,
		     dmp->dm_height,
		     Tk_Depth(pubvars->xtkwin));

    if(privars->is_trueColor){
	XColor fg, bg;

	fg.red = 65535;
	fg.green = fg.blue = 0;

	get_color(pubvars->dpy,
		  pubvars->cmap,
		  &fg);

	privars->fg = fg.pixel;

	bg.red = bg.green = bg.blue = 0;
	get_color(pubvars->dpy,
		  pubvars->cmap,
		  &bg);

	privars->bg = bg.pixel;
    }else{
	dm_allocate_color_cube( pubvars->dpy,
				pubvars->cmap,
				privars->pixels,
				/* cube dimension, uses XStoreColor */
				6, CMAP_BASE, 1 );

	privars->bg =
	    dm_get_pixel(DM_BLACK,
			 privars->pixels,
			 CUBE_DIMENSION);
	privars->fg =
	    dm_get_pixel(DM_RED,
			 privars->pixels,
			 CUBE_DIMENSION);
    }

    gcv.background = privars->bg;
    gcv.foreground = privars->fg;
    privars->gc = XCreateGC(pubvars->dpy,
			    pubvars->win,
			    (GCForeground|GCBackground), &gcv);

    /* First see if the server supports XInputExtension */
    {
	int return_val;

	if(!XQueryExtension(pubvars->dpy,
			    "XInputExtension", &return_val, &return_val, &return_val))
	    goto Skip_dials;
    }

#if USE_DIALS_AND_BUTTONS
    /*
     * Take a look at the available input devices. We're looking
     * for "dial+buttons".
     */
    if (XQueryExtension(pubvars->dpy, "XInputExtension", &unused, &unused, &unused)) {
	olist = list = (XDeviceInfoPtr)XListInputDevices(pubvars->dpy, &ndevices);
    }

    if( list == (XDeviceInfoPtr)NULL ||
	list == (XDeviceInfoPtr)1 )  goto Done;

    for(j = 0; j < ndevices; ++j, list++){
	if(list->use == IsXExtensionDevice){
	    if(!strcmp(list->name, "dial+buttons")){
		if((dev = XOpenDevice(pubvars->dpy,
				      list->id)) == (XDevice *)NULL){
		    bu_log("X_open_dm: Couldn't open the dials+buttons\n");
		    goto Done;
		}

		for(cip = dev->classes, k = 0; k < dev->num_classes;
		    ++k, ++cip){
		    switch(cip->input_class){
#ifdef IR_BUTTONS
			case ButtonClass:
			    DeviceButtonPress(dev, pubvars->devbuttonpress,
					      e_class[nclass]);
			    ++nclass;
			    DeviceButtonRelease(dev, pubvars->devbuttonrelease,
						e_class[nclass]);
			    ++nclass;
			    break;
#endif
#ifdef IR_KNOBS
			case ValuatorClass:
			    DeviceMotionNotify(dev, pubvars->devmotionnotify,
					       e_class[nclass]);
			    ++nclass;
			    break;
#endif
			default:
			    break;
		    }
		}

		XSelectExtensionEvent(pubvars->dpy,
				      pubvars->win, e_class, nclass);
		goto Done;
	    }
	}
    }
 Done:
    XFreeDeviceList(olist);
#endif

 Skip_dials:
    (void)X_configureWin_guts(dmp, 1);

    Tk_SetWindowBackground(pubvars->xtkwin,
			   privars->bg);
    Tk_MapWindow(pubvars->xtkwin);

    MAT_IDN(privars->xmat);

    return dmp;
}

/*
 *  			X _ C L O S E
 *
 *  Gracefully release the display.
 */
HIDDEN int
X_close_dm(struct dm *dmp)
{
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    if(pubvars->dpy){
	if(privars->gc)
	    XFreeGC(pubvars->dpy,
		    privars->gc);

	if(privars->pix)
	    Tk_FreePixmap(pubvars->dpy,
			  privars->pix);

	/*XXX Possibly need to free the colormap */
	if (pubvars->cmap)
	    XFreeColormap(pubvars->dpy,
			  pubvars->cmap);

	if(pubvars->xtkwin)
	    Tk_DestroyWindow(pubvars->xtkwin);

#if 0
	XCloseDisplay(pubvars->dpy);
#endif
    }

    bu_vls_free(&dmp->dm_pathName);
    bu_vls_free(&dmp->dm_tkName);
    bu_vls_free(&dmp->dm_dName);
    bu_free((genptr_t)dmp->dm_vars.priv_vars, "X_close_dm: x_vars");
    bu_free((genptr_t)dmp->dm_vars.pub_vars, "X_close_dm: dm_xvars");
    bu_free((genptr_t)dmp, "X_close_dm: dmp");

    return TCL_OK;
}

/*
 *			X _ D R A W B E G I N
 */
HIDDEN int
X_drawBegin(struct dm *dmp)
{
    XGCValues       gcv;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    if (dmp->dm_debugLevel)
	bu_log("X_drawBegin()\n");

    /* clear pixmap */
    gcv.foreground = privars->bg;
    XChangeGC(pubvars->dpy,
	      privars->gc,
	      GCForeground, &gcv);
    XFillRectangle(pubvars->dpy,
		   privars->pix,
		   privars->gc, 0,
		   0, dmp->dm_width + 1,
		   dmp->dm_height + 1);

    /* reset foreground */
    gcv.foreground = privars->fg;
    XChangeGC(pubvars->dpy,
	      privars->gc,
	      GCForeground, &gcv);

    return TCL_OK;
}

/*
 *			X _ E P I L O G
 */
HIDDEN int
X_drawEnd(struct dm *dmp)
{
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    if (dmp->dm_debugLevel)
	bu_log("X_drawEnd()\n");

    XCopyArea(pubvars->dpy,
	      privars->pix,
	      pubvars->win,
	      privars->gc,
	      0, 0, dmp->dm_width,
	      dmp->dm_height, 0, 0);

    /* Prevent lag between events and updates */
    XSync(pubvars->dpy, 0);

    return TCL_OK;
}

/*
 *  			X _ L O A D M A T R I X
 *
 *  Load a new transformation matrix.  This will be followed by
 *  many calls to X_drawVList().
 */
/* ARGSUSED */
HIDDEN int
X_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
{
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    if(dmp->dm_debugLevel){
	bu_log("X_loadMatrix()\n");

	bu_log("which eye = %d\t", which_eye);
	bu_log("transformation matrix = \n");
#if 1
	bu_log("%g %g %g %g\n", mat[0], mat[1], mat[2], mat[3]);
	bu_log("%g %g %g %g\n", mat[4], mat[5], mat[6], mat[7]);
	bu_log("%g %g %g %g\n", mat[8], mat[9], mat[10], mat[11]);
	bu_log("%g %g %g %g\n", mat[12], mat[13], mat[14], mat[15]);
#else
	bu_log("%g %g %g %g\n", mat[0], mat[4], mat[8], mat[12]);
	bu_log("%g %g %g %g\n", mat[1], mat[5], mat[9], mat[13]);
	bu_log("%g %g %g %g\n", mat[2], mat[6], mat[10], mat[14]);
	bu_log("%g %g %g %g\n", mat[3], mat[7], mat[11], mat[15]);
#endif
    }

    MAT_COPY(privars->xmat, mat);
    return TCL_OK;
}

/*
 *  			X _ D R A W V L I S T
 *
 */

HIDDEN int
X_drawVList(struct dm *dmp, register struct bn_vlist *vp)
{
    static vect_t			spnt, lpnt, pnt;
    register struct bn_vlist	*tvp;
    XSegment			segbuf[1024];		/* XDrawSegments list */
    XSegment			*segp;			/* current segment */
    int				nseg;		        /* number of segments */
    fastf_t				delta;
    register point_t		*pt_prev = NULL;
    fastf_t				dist_prev=1.0;
    static int			nvectors = 0;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;


    if (dmp->dm_debugLevel) {
	bu_log("X_drawVList()\n");
	bu_log("vp - %lu, perspective - %d\n", vp, dmp->dm_perspective);
    }

    /* delta is used in clipping to insure clipped endpoint is slightly
     * in front of eye plane (perspective mode only).
     * This value is a SWAG that seems to work OK.
     */
    delta = privars->xmat[15]*0.0001;
    if (delta < 0.0)
	delta = -delta;
    if (delta < SQRT_SMALL_FASTF)
	delta = SQRT_SMALL_FASTF;

    nseg = 0;
    segp = segbuf;
    for (BU_LIST_FOR(tvp, bn_vlist, &vp->l)) {
	register int	i;
	register int	nused = tvp->nused;
	register int	*cmd = tvp->cmd;
	register point_t *pt = tvp->pt;
	fastf_t 	 dist;

	/* Viewing region is from -1.0 to +1.0 */
	/* 2^31 ~= 2e9 -- dynamic range of a long int */
	/* 2^(31-11) = 2^20 ~= 1e6 */
	/* Integerize and let the X server do the clipping */
	for (i = 0; i < nused; i++,cmd++,pt++) {
	    switch (*cmd) {
		case BN_VLIST_POLY_START:

		case BN_VLIST_POLY_VERTNORM:
		    continue;
		case BN_VLIST_POLY_MOVE:
		case BN_VLIST_LINE_MOVE:
		    /* Move, not draw */
		    if (dmp->dm_debugLevel > 2) {
			bu_log("before transformation:\n");
			bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
		    }

		    if (dmp->dm_perspective > 0) {
			/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
			 */
			dist = VDOT(*pt, &privars->xmat[12]) + privars->xmat[15];
			if (dist <= 0.0) {
			    pt_prev = pt;
			    dist_prev = dist;
			    continue;
			} else {
			    MAT4X3PNT(lpnt, privars->xmat, *pt);
			    dist_prev = dist;
			    pt_prev = pt;
			}
		    } else {
			MAT4X3PNT(lpnt, privars->xmat, *pt);
		    }

		    lpnt[0] *= 2047;
		    lpnt[1] *= 2047 * dmp->dm_aspect;
		    lpnt[2] *= 2047;
		    continue;
		case BN_VLIST_POLY_DRAW:
		case BN_VLIST_POLY_END:
		case BN_VLIST_LINE_DRAW:
		    /* draw */
		    if (dmp->dm_debugLevel > 2) {
			bu_log("before transformation:\n");
			bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
		    }

		    if (dmp->dm_perspective > 0) {
			/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
			 */
			dist = VDOT( *pt, &privars->xmat[12] ) + privars->xmat[15];
			if (dmp->dm_debugLevel > 2)
			    bu_log( "dist=%g, dist_prev=%g\n", dist, dist_prev );
			if (dist <= 0.0) {
			    if (dist_prev <= 0.0) {
				/* nothing to plot */
				dist_prev = dist;
				pt_prev = pt;
				continue;
			    } else {
				fastf_t alpha;
				vect_t diff;
				point_t tmp_pt;

				/* clip this end */
				VSUB2(diff, *pt, *pt_prev);
				alpha = (dist_prev - delta) / (dist_prev - dist);
				VJOIN1(tmp_pt, *pt_prev, alpha, diff);
				MAT4X3PNT(pnt, privars->xmat, tmp_pt);
			    }
			} else {
			    if (dist_prev <= 0.0) {
				fastf_t alpha;
				vect_t diff;
				point_t tmp_pt;

				/* clip other end */
				VSUB2(diff, *pt, *pt_prev);
				alpha = (-dist_prev + delta) / (dist - dist_prev);
				VJOIN1(tmp_pt, *pt_prev, alpha, diff);
				MAT4X3PNT(lpnt, privars->xmat, tmp_pt);
				lpnt[0] *= 2047;
				lpnt[1] *= 2047 * dmp->dm_aspect;
				lpnt[2] *= 2047;
				MAT4X3PNT(pnt, privars->xmat, *pt);
			    } else {
				MAT4X3PNT(pnt, privars->xmat, *pt);
			    }
			}
			dist_prev = dist;
		    } else {
			MAT4X3PNT(pnt, privars->xmat, *pt);
		    }

		    pnt[0] *= 2047;
		    pnt[1] *= 2047 * dmp->dm_aspect;
		    pnt[2] *= 2047;

		    /* save pnt --- it might get changed by clip() */
		    VMOVE(spnt, pnt);
		    pt_prev = pt;

		    if (dmp->dm_debugLevel > 2) {
			bu_log("before clipping:\n");
			bu_log("clipmin - %lf %lf %lf\n",
			       dmp->dm_clipmin[X],
			       dmp->dm_clipmin[Y],
			       dmp->dm_clipmin[Z]);
			bu_log("clipmax - %lf %lf %lf\n",
			       dmp->dm_clipmax[X],
			       dmp->dm_clipmax[Y],
			       dmp->dm_clipmax[Z]);
			bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
			bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
		    }

		    if (dmp->dm_zclip) {
			if (vclip(lpnt, pnt,
				  dmp->dm_clipmin,
				  dmp->dm_clipmax) == 0) {
			    VMOVE(lpnt, spnt);
			    continue;
			}
		    } else {
			/* Check to see if lpnt or pnt contain values that exceed
			   the capacity of a short (segbuf is an array of XSegments which
			   contain shorts). If so, do clipping now. Otherwise, let the
			   X server do the clipping */
			if (lpnt[0] < min_short || max_short < lpnt[0] ||
			    lpnt[1] < min_short || max_short < lpnt[1] ||
			    pnt[0] < min_short || max_short < pnt[0] ||
			    pnt[1] < min_short || max_short < pnt[1]) {
			    /* if the entire line segment will not be visible then ignore it */
			    if (clip(&lpnt[0], &lpnt[1], &pnt[0], &pnt[1]) == -1) {
				VMOVE(lpnt, spnt);
				continue;
			    }
			}
		    }

		    if (dmp->dm_debugLevel > 2) {
			bu_log("after clipping:\n");
			bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
			bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
		    }

		    /* convert to X window coordinates */
		    segp->x1 = (short)GED_TO_Xx(dmp, lpnt[0]);
		    segp->y1 = (short)GED_TO_Xy(dmp, lpnt[1]);
		    segp->x2 = (short)GED_TO_Xx(dmp, pnt[0]);
		    segp->y2 = (short)GED_TO_Xy(dmp, pnt[1]);

		    nseg++;
		    segp++;
		    VMOVE(lpnt, spnt);

		    if (nseg == 1024) {
			XDrawSegments(pubvars->dpy,
				      privars->pix,
				      privars->gc, segbuf, nseg);

			nseg = 0;
			segp = segbuf;
		    }
		    break;
	    }
	}

	nvectors += nused;
	if (nvectors >= vectorThreshold) {
	    if (dmp->dm_debugLevel)
		bu_log("X_drawVList(): handle Tcl events\n");

	    nvectors = 0;

	    /* Handle events in the queue */
	    while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
	}
    }

    if (nseg) {
	XDrawSegments( pubvars->dpy,
		       privars->pix,
		       privars->gc, segbuf, nseg );
    }

    return TCL_OK;
}

/*
 *			X _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 */
HIDDEN int
X_normal(struct dm *dmp)
{
    if (dmp->dm_debugLevel)
	bu_log("X_normal()\n");

    return TCL_OK;
}

/*
 *			X _ D R A W S T R I N G 2 D
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
HIDDEN int
X_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
{
    int sx, sy;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    if (dmp->dm_debugLevel){
	bu_log("X_drawString2D():\n");
	bu_log("\tstr - %s\n", str);
	bu_log("\tx - %g\n", x);
	bu_log("\ty - %g\n", y);
	bu_log("\tsize - %d\n", size);
	if(use_aspect){
	    bu_log("\tuse_aspect - %d\t\taspect ratio - %g\n", use_aspect, dmp->dm_aspect);
	}else
	    bu_log("\tuse_aspect - 0");
    }

    sx = dm_Normal2Xx(dmp, x);
    sy = dm_Normal2Xy(dmp, y, use_aspect);

    XDrawString( pubvars->dpy,
		 privars->pix,
		 privars->gc,
		 sx, sy, str, strlen(str) );

    return TCL_OK;
}

HIDDEN int
X_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
{
    int	sx1, sy1, sx2, sy2;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    sx1 = dm_Normal2Xx(dmp, x1);
    sx2 = dm_Normal2Xx(dmp, x2);
    sy1 = dm_Normal2Xy(dmp, y1, 0);
    sy2 = dm_Normal2Xy(dmp, y2, 0);

    if (dmp->dm_debugLevel) {
	bu_log("X_drawLine2D()\n");
	bu_log("x1 = %g, y1 = %g\n", x1, y1);
	bu_log("x2 = %g, y2 = %g\n", x2, y2);
	bu_log("sx1 = %d, sy1 = %d\n", sx1, sy1);
	bu_log("sx2 = %d, sy2 = %d\n", sx2, sy2);
    }

    XDrawLine( pubvars->dpy,
	       privars->pix,
	       privars->gc,
	       sx1, sy1, sx2, sy2 );

    return TCL_OK;
}

HIDDEN int
X_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
{
    int   sx, sy;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    sx = dm_Normal2Xx(dmp, x);
    sy = dm_Normal2Xy(dmp, y, 0);

    if (dmp->dm_debugLevel) {
	bu_log("X_drawPoint2D()\n");
	bu_log("x = %g, y = %g\n", x, y);
	bu_log("sx = %d, sy = %d\n", sx, sy);
    }

    XDrawPoint( pubvars->dpy,
		privars->pix,
		privars->gc, sx, sy );

    return TCL_OK;
}

HIDDEN int
X_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency)
{
    XGCValues gcv;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    if (dmp->dm_debugLevel)
	bu_log("X_setFGColor()\n");

    dmp->dm_fg[0] = r;
    dmp->dm_fg[1] = g;
    dmp->dm_fg[2] = b;

    if(privars->is_trueColor){
	XColor color;

	color.red = r << 8;
	color.green = g << 8;
	color.blue = b << 8;
	get_color(pubvars->dpy,
		  pubvars->cmap,
		  &color);

	gcv.foreground = color.pixel;
    }else
	gcv.foreground = dm_get_pixel(r, g, b,
				      privars->pixels,
				      CUBE_DIMENSION);

    /* save foreground pixel */
    privars->fg = gcv.foreground;

    XChangeGC(pubvars->dpy,
	      privars->gc,
	      GCForeground, &gcv);

    return TCL_OK;
}

HIDDEN int
X_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
{
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    if (dmp->dm_debugLevel)
	bu_log("X_setBGColor()\n");

    dmp->dm_bg[0] = r;
    dmp->dm_bg[1] = g;
    dmp->dm_bg[2] = b;

    if(privars->is_trueColor){

	XColor color;

	color.red = r << 8;
	color.green = g << 8;
	color.blue = b << 8;

	get_color(pubvars->dpy,
		  pubvars->cmap,
		  &color);

	privars->bg = color.pixel;
    } else
	privars->bg =
	    dm_get_pixel(r, g, b, privars->pixels, CUBE_DIMENSION);

    return TCL_OK;
}

HIDDEN int
X_setLineAttr(struct dm *dmp, int width, int style)
{
    int linestyle;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    if (dmp->dm_debugLevel)
	bu_log("X_setLineAttr()\n");

    dmp->dm_lineWidth = width;
    dmp->dm_lineStyle = style;

    if(width <= 1)
	width = 0;

    if(style == DM_DASHED_LINE)
	linestyle = LineOnOffDash;
    else
	linestyle = LineSolid;

    XSetLineAttributes( pubvars->dpy,
			privars->gc,
			width, linestyle, CapButt, JoinMiter );

    return TCL_OK;
}

/* ARGSUSED */
HIDDEN int
X_debug(struct dm *dmp, int lvl)
{
    dmp->dm_debugLevel = lvl;

    return TCL_OK;
}

HIDDEN int
X_setWinBounds(struct dm *dmp, register int *w)
{
    if (dmp->dm_debugLevel)
	bu_log("X_setWinBounds()\n");

    dmp->dm_clipmin[0] = w[0];
    dmp->dm_clipmin[1] = w[2];
    dmp->dm_clipmin[2] = w[4];
    dmp->dm_clipmax[0] = w[1];
    dmp->dm_clipmax[1] = w[3];
    dmp->dm_clipmax[2] = w[5];

    return TCL_OK;
}

HIDDEN int
X_configureWin_guts(struct dm *dmp, int force)
{
    XWindowAttributes xwa;
    XFontStruct     *newfontstruct;
    XGCValues       gcv;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    XGetWindowAttributes( pubvars->dpy,
			  pubvars->win, &xwa );

    /* nothing to do */
    if (!force &&
	dmp->dm_height == xwa.height &&
	dmp->dm_width == xwa.width)
	return TCL_OK;

    dmp->dm_height = xwa.height;
    dmp->dm_width = xwa.width;
    dmp->dm_aspect = (fastf_t)dmp->dm_width / (fastf_t)dmp->dm_height;

    if (dmp->dm_debugLevel) {
	bu_log("X_configureWin_guts()\n");
	bu_log("width = %d, height = %d\n", dmp->dm_width, dmp->dm_height);
    }

    Tk_FreePixmap(pubvars->dpy,
		  privars->pix);
    privars->pix =
	Tk_GetPixmap(pubvars->dpy,
		     DefaultRootWindow(pubvars->dpy),
		     dmp->dm_width,
		     dmp->dm_height,
		     Tk_Depth(pubvars->xtkwin));

    /* First time through, load a font or quit */
    if (pubvars->fontstruct == NULL) {
	if ((pubvars->fontstruct =
	     XLoadQueryFont(pubvars->dpy, FONT9)) == NULL ) {
	    /* Try hardcoded backup font */
	    if ((pubvars->fontstruct =
		 XLoadQueryFont(pubvars->dpy, FONTBACK)) == NULL) {
		bu_log("dm-X: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
		return TCL_ERROR;
	    }
	}

	gcv.font = pubvars->fontstruct->fid;
	XChangeGC(pubvars->dpy,
		  privars->gc, GCFont, &gcv);
    }

    /* Always try to choose a the font that best fits the window size.
     */

    if (dmp->dm_width < 582) {
	if (pubvars->fontstruct->per_char->width != 5) {
	    if ((newfontstruct = XLoadQueryFont(pubvars->dpy,
						FONT5)) != NULL ) {
		XFreeFont(pubvars->dpy,
			  pubvars->fontstruct);
		pubvars->fontstruct = newfontstruct;
		gcv.font = pubvars->fontstruct->fid;
		XChangeGC(pubvars->dpy,
			  privars->gc, GCFont, &gcv);
	    }
	}
    } else if (dmp->dm_width < 679) {
	if (pubvars->fontstruct->per_char->width != 6){
	    if ((newfontstruct = XLoadQueryFont(pubvars->dpy,
						FONT6)) != NULL ) {
		XFreeFont(pubvars->dpy,
			  pubvars->fontstruct);
		pubvars->fontstruct = newfontstruct;
		gcv.font = pubvars->fontstruct->fid;
		XChangeGC(pubvars->dpy,
			  privars->gc, GCFont, &gcv);
	    }
	}
    } else if (dmp->dm_width < 776) {
	if (pubvars->fontstruct->per_char->width != 7){
	    if ((newfontstruct = XLoadQueryFont(pubvars->dpy,
						FONT7)) != NULL ) {
		XFreeFont(pubvars->dpy,
			  pubvars->fontstruct);
		pubvars->fontstruct = newfontstruct;
		gcv.font = pubvars->fontstruct->fid;
		XChangeGC(pubvars->dpy,
			  privars->gc, GCFont, &gcv);
	    }
	}
    } else if (dmp->dm_width < 873) {
	if (pubvars->fontstruct->per_char->width != 8){
	    if ((newfontstruct = XLoadQueryFont(pubvars->dpy,
						FONT8)) != NULL ) {
		XFreeFont(pubvars->dpy,
			  pubvars->fontstruct);
		pubvars->fontstruct = newfontstruct;
		gcv.font = pubvars->fontstruct->fid;
		XChangeGC(pubvars->dpy,
			  privars->gc, GCFont, &gcv);
	    }
	}
    } else {
	if (pubvars->fontstruct->per_char->width != 9){
	    if ((newfontstruct = XLoadQueryFont(pubvars->dpy,
						FONT9)) != NULL ) {
		XFreeFont(pubvars->dpy,
			  pubvars->fontstruct);
		pubvars->fontstruct = newfontstruct;
		gcv.font = pubvars->fontstruct->fid;
		XChangeGC(pubvars->dpy,
			  privars->gc, GCFont, &gcv);
	    }
	}
    }

    return TCL_OK;
}

HIDDEN int
X_configureWin(struct dm *dmp)
{
    /* don't force */
    return X_configureWin_guts(dmp, 0);
}

HIDDEN int
X_setLight(struct dm *dmp, int light_on)
{
    if (dmp->dm_debugLevel)
	bu_log("X_setLight:\n");

    dmp->dm_light = light_on;

    return TCL_OK;
}

HIDDEN int
X_setZBuffer(struct dm *dmp, int zbuffer_on)
{
    if (dmp->dm_debugLevel)
	bu_log("X_setZBuffer:\n");

    dmp->dm_zbuffer = zbuffer_on;

    return TCL_OK;
}

HIDDEN XVisualInfo *
X_choose_visual(struct dm *dmp)
{
    XVisualInfo *vip, vitemp, *vibase, *maxvip;
    int good[256];
    int num, i, j;
    int tries, baddepth;
    int desire_trueColor = 1;
    int min_depth = 8;
    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;
    struct x_vars *privars = (struct x_vars *)dmp->dm_vars.priv_vars;

    vibase = XGetVisualInfo(pubvars->dpy,
			    0, &vitemp, &num);

    while (1) {
	for (i=0, j=0, vip=vibase; i<num; i++, vip++){
#if 0
	    /* code to force a particular visual class and depth */
	    if (vip->depth != 8)
		continue;
	    if (vip->class != PseudoColor)
		continue;
#else
	    /* requirements */
	    if (vip->depth < min_depth)
		continue;
	    if (desire_trueColor){
		if (vip->class != TrueColor)
		    continue;
	    }else if (vip->class != PseudoColor)
		continue;
#endif

	    /* this visual meets criteria */
	    good[j++] = i;
	}

	baddepth = 1000;
	for(tries = 0; tries < j; ++tries) {
	    maxvip = vibase + good[0];
	    for (i=1; i<j; i++) {
		vip = vibase + good[i];
		if ((vip->depth > maxvip->depth)&&(vip->depth < baddepth)){
		    maxvip = vip;
		}
	    }

	    /* make sure Tk handles it */
	    if(desire_trueColor){
		pubvars->cmap =
		    XCreateColormap(pubvars->dpy,
				    RootWindow(pubvars->dpy,
					       maxvip->screen),
				    maxvip->visual, AllocNone);
		privars->is_trueColor = 1;
	    }else{
		pubvars->cmap =
		    XCreateColormap(pubvars->dpy,
				    RootWindow(pubvars->dpy,
					       maxvip->screen),
				    maxvip->visual, AllocAll);
		privars->is_trueColor = 0;
	    }

	    if (Tk_SetWindowVisual(pubvars->xtkwin,
				   maxvip->visual,
				   maxvip->depth,
				   pubvars->cmap)){
		pubvars->depth = maxvip->depth;

		return maxvip; /* success */
	    } else {
		/* retry with lesser depth */
		baddepth = maxvip->depth;
		XFreeColormap(pubvars->dpy, pubvars->cmap);
	    }
	}

	if(desire_trueColor)
	    desire_trueColor = 0;
	else
	    return (XVisualInfo *)NULL; /* failure */
    }
}

#endif /* DM_X */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.26
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.25 2007/05/14 21:04:31 brlcad Exp $ (BRL)";
a512 1
#ifndef CRAY2
a513 1
#endif
@


14.25
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.24 2007/04/23 13:30:19 joevalleyfield Exp $ (BRL)";
d45 1
a45 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.25.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.26 2007/09/15 16:23:10 brlcad Exp $ (BRL)";
d45 5
a49 1
#include <string.h>
@


14.24
log
@preliminary support for unaccelerated mgen on aqua through dm-tk

configure.ac:
        - use two levels of expansion for BRLCAD_DATA
        - enable_aqua configure option
        - move X11 ac_ macro tests from argument check section
        - rely on AC_PATH_XTRA to figure out most of what we need to know about
                where to find X
        - no longer look for libICE, libXmu, or libXsm  AC_PATH_XTRA
                populates X_PRE_LIBS with these but they seem completely unused
                right now.
        - look for opengl libs and headers in all of the places AC_PATH_XTRA
                looked for the xlibs
        - use tk's xlib headers when using tk-aqua rather than x
        - remove X11 "ugly hack"
        - include tk flags where necessary
        - remove --disable-shared from subconfigs
        - forcibly add tcl and tk build dirs to libtool wrapper scripts
libdm/Makefile.am, dm-tk.[ch], dm.h, dm-generic.c, dm_obj.c, mged/Makefile.am,
                attach.c, dm-generic.c, dm-tk.c, ged.c:
        - use lower case when referring to tk
        - add support for using dm-tk
        - include X_CFLAGS with DM_X
irprep/Makefile.am, util/Makefile.am:
        - disable build of ir-X, pl-X when there is no X
dm-X.c:
        - no need to test for HAVE_X11_XLIB here; if we don't have it we
                shouldn't be building this file
libfb/Makefile.am, if_tk.c, libfb/tcl.c:
        - build if_tk.c
        - add preliminary hooks so if_tk can be called when ready
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.23 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
d674 1
a674 1
    register struct rt_vlist	*tvp;
d703 1
a703 1
    for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
d716 1
a716 1
		case RT_VLIST_POLY_START:
d718 1
a718 1
		case RT_VLIST_POLY_VERTNORM:
d720 2
a721 2
		case RT_VLIST_POLY_MOVE:
		case RT_VLIST_LINE_MOVE:
d750 3
a752 3
		case RT_VLIST_POLY_DRAW:
		case RT_VLIST_POLY_END:
		case RT_VLIST_LINE_DRAW:
@


14.23
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.22 2007/01/20 14:36:52 brlcad Exp $ (BRL)";
d51 2
a52 4
#ifdef HAVE_X11_XLIB_H
#  include <X11/Xlib.h>
#  include <X11/Xutil.h>
#endif
@


14.22
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.21 2006/08/24 17:49:41 brlcad Exp $ (BRL)";
@


14.21
log
@according to one of the tcl devs (thx jenglish), Tk_IsMapped() is not what we should be using to determine if the tkwin is 'valid' .. being 'mapped' apparently means that there is a window that has been explicitly mapped via a Tk_MapWindow() call or is otherwise fully drawn/displayed.  fall back to a simple non-null check instead.
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2006 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.20 2006/08/22 21:19:02 brlcad Exp $ (BRL)";
@


14.20
log
@Tk_IsMapped takes a tkwin, not a Display, so give it what it wants for the sanity check.  add another for the mainwindow too even.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.19 2006/08/19 21:00:34 brlcad Exp $ (BRL)";
d232 1
a232 1
    XDevice *dev;
d234 1
a234 1
    XInputClassInfo *cip;
d238 1
a238 1
    struct dm *dmp;
d244 1
a244 1
    if (((tkwin = Tk_MainWindow(interp)) == NULL) || !Tk_IsMapped(tkwin)) {
a347 1

d354 1
a354 2
    pubvars->dpy =
	Tk_Display(pubvars->top);
d357 2
a358 1
    if (!pubvars->dpy || !Tk_IsMapped(pubvars->xtkwin)) {
@


14.19
log
@make sure we actually got a display before proceeding with the display manager initialization.  this prevents the display manager from crashing out quickly upon startup when some condition fails (like there not being an X11 server to connect to, then attempting to get the size of that display or a screen, etc)
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.18 2006/08/14 17:31:01 brlcad Exp $ (BRL)";
d244 1
a244 1
    if ((tkwin = Tk_MainWindow(interp)) == NULL) {
d249 1
a249 1
    if(dmp == DM_NULL)
d251 1
d359 1
a359 1
    if (!pubvars->dpy || !Tk_IsMapped(pubvars->dpy)) {
@


14.18
log
@change function names to avoid debug build name clashing
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.17 2006/08/11 06:42:30 brlcad Exp $ (BRL)";
d357 5
@


14.17
log
@oops .. they are x_vars, not dm_xvars
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.16 2006/08/11 06:33:44 brlcad Exp $ (BRL)";
d93 2
a94 2
struct dm	*X_open(Tcl_Interp *interp, int argc, char **argv);
HIDDEN int	X_close(struct dm *dmp);
d111 1
a111 1
    X_close,
d221 1
a221 1
X_open(Tcl_Interp *interp, int argc, char **argv)
d255 1
a255 1
    dmp->dm_vars.pub_vars = (genptr_t)bu_calloc(1, sizeof(struct dm_xvars), "X_open: dm_xvars");
d257 1
a257 1
	bu_free((genptr_t)dmp, "X_open: dmp");
d262 1
a262 1
    dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct x_vars), "X_open: x_vars");
d264 2
a265 2
	bu_free((genptr_t)dmp->dm_vars.pub_vars, "X_open: dmp->dm_vars.pub_vars");
	bu_free((genptr_t)dmp, "X_open: dmp");
d331 2
a332 2
	bu_log("X_open: Failed to open %s\n", bu_vls_addr(&dmp->dm_pathName));
	(void)X_close(dmp);
d346 1
a346 1
	(void)X_close(dmp);
d391 2
a392 2
	bu_log("X_open: Can't get an appropriate visual.\n");
	(void)X_close(dmp);
d475 1
a475 1
		    bu_log("X_open: Couldn't open the dials+buttons\n");
d534 1
a534 1
X_close(struct dm *dmp)
d564 3
a566 3
    bu_free((genptr_t)dmp->dm_vars.priv_vars, "X_close: x_vars");
    bu_free((genptr_t)dmp->dm_vars.pub_vars, "X_close: dm_xvars");
    bu_free((genptr_t)dmp, "X_close: dmp");
@


14.16
log
@HAVE_XOSDEFS_H was a conf.h fictional, update to new configure check for HAVE_X11_XOSDEFS_H and clean up header foo some.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.15 2006/08/10 02:07:25 brlcad Exp $ (BRL)";
d242 1
a242 1
    struct dm_xvars *privars = NULL;
d268 1
a268 1
    privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d537 1
a537 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d579 1
a579 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d611 1
a611 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d639 1
a639 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d681 1
a681 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d927 1
a927 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d957 1
a957 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d985 1
a985 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d1008 1
a1008 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d1047 1
a1047 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d1081 1
a1081 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d1136 1
a1136 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
d1289 1
a1289 1
    struct dm_xvars *privars = (struct dm_xvars *)dmp->dm_vars.priv_vars;
@


14.15
log
@cleanup the lengthy repetition of pub_vars and priv_vars using some local vars pointers, ws too
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.14 2006/02/07 06:25:05 brlcad Exp $ (BRL)";
d51 5
a55 3
#include "tk.h"
#include <X11/Xlib.h>
#include <X11/Xutil.h>
d59 1
a59 1
#ifdef HAVE_XOSDEFS_H
d72 2
@


14.14
log
@aix Xutil.h header uses Bool #define which is provided by Xlib.h, which Xutil.h doesn't include for you.  so we need to include Xlib.h first.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.13 2006/01/23 04:36:32 brlcad Exp $ (BRL)";
d47 1
a47 1
#include <string.h>
d49 1
a49 1
#include <strings.h>
d58 2
a59 2
#include <X11/Xfuncproto.h>
#include <X11/Xosdefs.h>
d62 1
a62 1
#include <X11/extensions/XInput.h>
d65 2
a66 2
#	undef   X_NOT_STDC_ENV
#	undef   X_NOT_POSIX
d107 55
a161 55
  X_close,
  X_drawBegin,
  X_drawEnd,
  X_normal,
  X_loadMatrix,
  X_drawString2D,
  X_drawLine2D,
  X_drawPoint2D,
  X_drawVList,
  X_setFGColor,
  X_setBGColor,
  X_setLineAttr,
  X_configureWin,
  X_setWinBounds,
  X_setLight,
  Nu_int0,
  Nu_int0,
  X_setZBuffer,
  X_debug,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  0,
  0,				/* no displaylist */
  0,                            /* no stereo */
  PLOTBOUND,			/* zoom-in limit */
  1,				/* bound flag */
  "X",
  "X Window System (X11)",
  DM_TYPE_X,
  1,
  0,
  0,
  0,
  0,
  1.0, /* aspect ratio */
  0,
  {0, 0},
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {GED_MIN, GED_MIN, GED_MIN},	/* clipmin */
  {GED_MAX, GED_MAX, GED_MAX},	/* clipmax */
  0,				/* no debugging */
  0,				/* no perspective */
  0,				/* no lighting */
  0,				/* no transparency */
  0,				/* depth buffer is not writable */
  0,				/* no zbuffer */
  0,				/* no zclipping */
  1,                            /* clear back buffer after drawing and swap */
  0				/* Tcl interpreter */
d172 2
a173 2
	Status st;
	XColor rgb;
d176 1
a176 1
	rgb = *color;
d178 2
a179 2
	st = XAllocColor(dpy, cmap, color);
	switch (st) {
d182 6
a187 6
		if ( (color->red & CSCK) != (rgb.red & CSCK) ||
		     (color->green & CSCK) != (rgb.green & CSCK) ||
		     (color->blue & CSCK) != (rgb.blue & CSCK) ) {
			bu_log("\nlooking for fg    (%3d,%3d,%3d) %04x,%04x,%04x got \n                  (%3d,%3d,%3d) %04x,%04x,%04x\n",
			       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
			       rgb.red, rgb.green, rgb.blue,
d189 3
a191 3
			       (color->red >> 8), (color->green >> 8), (color->blue >> 8),
			       color->red, color->green, color->blue);
		}
d193 1
a193 1
		break;
d195 4
a198 4
		bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n",
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue);
		break;
d201 5
a205 5
		bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n",
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue);
		break;
	}
d219 3
a221 3
  static int count = 0;
  int make_square = -1;
  XGCValues gcv;
d223 8
a230 8
  int j, k;
  int ndevices;
  int nclass = 0;
  int unused;
  XDeviceInfoPtr olist = NULL, list = NULL;
  XDevice *dev;
  XEventClass e_class[15];
  XInputClassInfo *cip;
d232 71
a302 72
  struct bu_vls str;
  struct bu_vls init_proc_vls;
  struct dm *dmp;
  Tk_Window tkwin;

  if ((tkwin = Tk_MainWindow(interp)) == NULL) {
	  return DM_NULL;
  }

  BU_GETSTRUCT(dmp, dm);
  if(dmp == DM_NULL)
    return DM_NULL;

  *dmp = dm_X; /* struct copy */
  dmp->dm_interp = interp;

  dmp->dm_vars.pub_vars = (genptr_t)bu_calloc(1, sizeof(struct dm_xvars), "X_open: dm_xvars");
  if(dmp->dm_vars.pub_vars == (genptr_t)NULL){
    bu_free((genptr_t)dmp, "X_open: dmp");
    return DM_NULL;
  }

  dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct x_vars), "X_open: x_vars");
  if(dmp->dm_vars.priv_vars == (genptr_t)NULL){
    bu_free((genptr_t)dmp->dm_vars.pub_vars, "X_open: dmp->dm_vars.pub_vars");
    bu_free((genptr_t)dmp, "X_open: dmp");
    return DM_NULL;
  }

  bu_vls_init(&dmp->dm_pathName);
  bu_vls_init(&dmp->dm_tkName);
  bu_vls_init(&dmp->dm_dName);
  bu_vls_init(&init_proc_vls);

  dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);

  if(bu_vls_strlen(&dmp->dm_pathName) == 0)
    bu_vls_printf(&dmp->dm_pathName, ".dm_X%d", count);

  ++count;
  if(bu_vls_strlen(&dmp->dm_dName) == 0){
    char *dp;

    dp = getenv("DISPLAY");
    if(dp)
      bu_vls_strcpy(&dmp->dm_dName, dp);
    else
      bu_vls_strcpy(&dmp->dm_dName, ":0.0");
  }
  if(bu_vls_strlen(&init_proc_vls) == 0)
    bu_vls_strcpy(&init_proc_vls, "bind_dm");

  /* initialize dm specific variables */
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify = LASTEvent;
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress = LASTEvent;
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease = LASTEvent;
  dmp->dm_aspect = 1.0;

  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = NULL;

  if(dmp->dm_top){
    /* Make xtkwin a toplevel window */
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
						      bu_vls_addr(&dmp->dm_pathName),
						      bu_vls_addr(&dmp->dm_dName));
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin;
  }else{
    char *cp;

    cp = strrchr(bu_vls_addr(&dmp->dm_pathName), (int)'.');
    if(cp == bu_vls_addr(&dmp->dm_pathName)){
      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = tkwin;
d304 30
a333 1
      struct bu_vls top_vls;
d335 8
a342 27
      bu_vls_init(&top_vls);
      bu_vls_printf(&top_vls, "%*s", cp - bu_vls_addr(&dmp->dm_pathName),
		    bu_vls_addr(&dmp->dm_pathName));
      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top =
	Tk_NameToWindow(interp, bu_vls_addr(&top_vls), tkwin);
      bu_vls_free(&top_vls);
    }

    /* Make xtkwin an embedded window */
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin =
      Tk_CreateWindow(interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top,
		      cp + 1, (char *)NULL);
  }

  if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin == NULL){
    bu_log("X_open: Failed to open %s\n", bu_vls_addr(&dmp->dm_pathName));
    (void)X_close(dmp);
    return DM_NULL;
  }

  bu_vls_printf(&dmp->dm_tkName, "%s",
		(char *)Tk_Name(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  bu_vls_init(&str);
  bu_vls_printf(&str, "_init_dm %S %S\n",
		&init_proc_vls,
		&dmp->dm_pathName);
d344 4
a347 1
  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
a348 1
    (void)X_close(dmp);
d350 9
a358 2
    return DM_NULL;
  }
d360 6
a365 2
  bu_vls_free(&init_proc_vls);
  bu_vls_free(&str);
d367 8
a374 25
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy =
    Tk_Display(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top);

  if(dmp->dm_width == 0){
    dmp->dm_width =
      DisplayWidth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		   DefaultScreen(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy)) - 30;
    ++make_square;
  }

  if(dmp->dm_height == 0){
    dmp->dm_height =
      DisplayHeight(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    DefaultScreen(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy)) - 30;
    ++make_square;
  }

  if(make_square > 0){
    /* Make window square */
    if(dmp->dm_height <
       dmp->dm_width)
      dmp->dm_width = dmp->dm_height;
    else
      dmp->dm_height = dmp->dm_width;
  }
d376 3
a378 3
  Tk_GeometryRequest(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
		     dmp->dm_width,
		     dmp->dm_height);
d381 2
a382 2
  /*XXX For debugging purposes */
  XSynchronize(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 1);
d385 68
a452 68
  /* must do this before MakeExist */
  if((((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip = X_choose_visual(dmp)) == NULL){
    bu_log("X_open: Can't get an appropriate visual.\n");
    (void)X_close(dmp);
    return DM_NULL;
  }

  Tk_MakeWindowExist(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win =
      Tk_WindowId(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  dmp->dm_id = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win;

  ((struct x_vars *)dmp->dm_vars.priv_vars)->pix =
    Tk_GetPixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 DefaultRootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy),
		 dmp->dm_width,
		 dmp->dm_height,
		 Tk_Depth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  if(((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor){
    XColor fg, bg;

    fg.red = 65535;
    fg.green = fg.blue = 0;

    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
	      &fg);

    ((struct x_vars *)dmp->dm_vars.priv_vars)->fg = fg.pixel;

    bg.red = bg.green = bg.blue = 0;
    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		&bg);

    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg = bg.pixel;
  }else{
    dm_allocate_color_cube( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
			    ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
			    /* cube dimension, uses XStoreColor */
			    6, CMAP_BASE, 1 );

    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg =
      dm_get_pixel(DM_BLACK,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
		   CUBE_DIMENSION);
    ((struct x_vars *)dmp->dm_vars.priv_vars)->fg =
      dm_get_pixel(DM_RED,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
		   CUBE_DIMENSION);
  }

  gcv.background = ((struct x_vars *)dmp->dm_vars.priv_vars)->bg;
  gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->fg;
  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc = XCreateGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
						  (GCForeground|GCBackground), &gcv);

  /* First see if the server supports XInputExtension */
  {
    int return_val;

    if(!XQueryExtension(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     "XInputExtension", &return_val, &return_val, &return_val))
      goto Skip_dials;
  }
d455 19
a473 19
  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  if (XQueryExtension(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, "XInputExtension", &unused, &unused, &unused)) {
      olist = list = (XDeviceInfoPtr)XListInputDevices(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, &ndevices);
  }

  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      list->id)) == (XDevice *)NULL){
	  bu_log("X_open: Couldn't open the dials+buttons\n");
	  goto Done;
	}
d475 3
a477 3
	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
d479 8
a486 8
	  case ButtonClass:
	    DeviceButtonPress(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress,
			      e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease,
				e_class[nclass]);
	    ++nclass;
	    break;
d489 5
a493 5
	  case ValuatorClass:
	    DeviceMotionNotify(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify,
			       e_class[nclass]);
	    ++nclass;
	    break;
d495 9
a503 3
	  default:
	    break;
	  }
d505 3
a507 9

	XSelectExtensionEvent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);
d510 1
a510 1
Skip_dials:
d512 1
a512 1
  (void)X_configureWin_guts(dmp, 1);
d515 3
a517 3
  Tk_SetWindowBackground(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->bg);
  Tk_MapWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
d519 1
a519 1
  MAT_IDN(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat);
d521 1
a521 1
  return dmp;
d532 2
a533 13
  if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy){
    if(((struct x_vars *)dmp->dm_vars.priv_vars)->gc)
      XFreeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc);

    if(((struct x_vars *)dmp->dm_vars.priv_vars)->pix)
      Tk_FreePixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    ((struct x_vars *)dmp->dm_vars.priv_vars)->pix);

    /*XXX Possibly need to free the colormap */
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)
      XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);
d535 16
a550 2
    if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)
      Tk_DestroyWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
d553 1
a553 1
    XCloseDisplay(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy);
d555 1
a555 1
  }
d557 6
a562 6
  bu_vls_free(&dmp->dm_pathName);
  bu_vls_free(&dmp->dm_tkName);
  bu_vls_free(&dmp->dm_dName);
  bu_free((genptr_t)dmp->dm_vars.priv_vars, "X_close: x_vars");
  bu_free((genptr_t)dmp->dm_vars.pub_vars, "X_close: dm_xvars");
  bu_free((genptr_t)dmp, "X_close: dmp");
d564 1
a564 1
  return TCL_OK;
d573 23
a595 1
  XGCValues       gcv;
d597 1
a597 21
  if (dmp->dm_debugLevel)
    bu_log("X_drawBegin()\n");

  /* clear pixmap */
  gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->bg;
  XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	    GCForeground, &gcv);
  XFillRectangle(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		 ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, 0,
		 0, dmp->dm_width + 1,
		 dmp->dm_height + 1);

  /* reset foreground */
  gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->fg;
  XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	    GCForeground, &gcv);

  return TCL_OK;
d606 2
a607 2
  if (dmp->dm_debugLevel)
    bu_log("X_drawEnd()\n");
d609 7
a615 4
  XCopyArea(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
d617 1
a617 1
 	    dmp->dm_height, 0, 0);
d619 2
a620 2
  /* Prevent lag between events and updates */
  XSync(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 0);
d622 1
a622 1
  return TCL_OK;
d635 1
a635 2
  if(dmp->dm_debugLevel){
    bu_log("X_loadMatrix()\n");
d637 5
a641 2
    bu_log("which eye = %d\t", which_eye);
    bu_log("transformation matrix = \n");
d643 4
a646 4
    bu_log("%g %g %g %g\n", mat[0], mat[1], mat[2], mat[3]);
    bu_log("%g %g %g %g\n", mat[4], mat[5], mat[6], mat[7]);
    bu_log("%g %g %g %g\n", mat[8], mat[9], mat[10], mat[11]);
    bu_log("%g %g %g %g\n", mat[12], mat[13], mat[14], mat[15]);
d648 4
a651 4
    bu_log("%g %g %g %g\n", mat[0], mat[4], mat[8], mat[12]);
    bu_log("%g %g %g %g\n", mat[1], mat[5], mat[9], mat[13]);
    bu_log("%g %g %g %g\n", mat[2], mat[6], mat[10], mat[14]);
    bu_log("%g %g %g %g\n", mat[3], mat[7], mat[11], mat[15]);
d653 1
a653 1
  }
d655 2
a656 2
  MAT_COPY(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, mat);
  return TCL_OK;
d667 17
a683 14
	static vect_t			spnt, lpnt, pnt;
	register struct rt_vlist	*tvp;
	XSegment			segbuf[1024];		/* XDrawSegments list */
	XSegment			*segp;			/* current segment */
	int				nseg;		        /* number of segments */
	fastf_t				delta;
	register point_t		*pt_prev = NULL;
	fastf_t				dist_prev=1.0;
	static int			nvectors = 0;

	if (dmp->dm_debugLevel) {
		bu_log("X_drawVList()\n");
		bu_log("vp - %lu, perspective - %d\n", vp, dmp->dm_perspective);
	}
d685 80
a764 28
	/* delta is used in clipping to insure clipped endpoint is slightly
	 * in front of eye plane (perspective mode only).
	 * This value is a SWAG that seems to work OK.
	 */
	delta = ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15]*0.0001;
	if (delta < 0.0)
		delta = -delta;
	if (delta < SQRT_SMALL_FASTF)
		delta = SQRT_SMALL_FASTF;

	nseg = 0;
	segp = segbuf;
	for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		fastf_t 	 dist;

		/* Viewing region is from -1.0 to +1.0 */
		/* 2^31 ~= 2e9 -- dynamic range of a long int */
		/* 2^(31-11) = 2^20 ~= 1e6 */
		/* Integerize and let the X server do the clipping */
		for (i = 0; i < nused; i++,cmd++,pt++) {
			switch (*cmd) {
			case RT_VLIST_POLY_START:

			case RT_VLIST_POLY_VERTNORM:
d766 22
a787 26
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
				/* Move, not draw */
				if (dmp->dm_debugLevel > 2) {
					bu_log("before transformation:\n");
					bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
				}

				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT(*pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12]) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
					if (dist <= 0.0) {
						pt_prev = pt;
						dist_prev = dist;
						continue;
					} else {
						MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						dist_prev = dist;
						pt_prev = pt;
					}
				} else {
					MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
				}

d791 51
d843 3
a845 60
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
				/* draw */
				if (dmp->dm_debugLevel > 2) {
					bu_log("before transformation:\n");
					bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
				}

				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT( *pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12] ) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
					if (dmp->dm_debugLevel > 2)
						bu_log( "dist=%g, dist_prev=%g\n", dist, dist_prev );
					if (dist <= 0.0) {
						if (dist_prev <= 0.0) {
							/* nothing to plot */
							dist_prev = dist;
							pt_prev = pt;
							continue;
						} else {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip this end */
							VSUB2(diff, *pt, *pt_prev);
							alpha = (dist_prev - delta) / (dist_prev - dist);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
						}
					} else {
						if (dist_prev <= 0.0) {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip other end */
							VSUB2(diff, *pt, *pt_prev);
							alpha = (-dist_prev + delta) / (dist - dist_prev);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
							lpnt[0] *= 2047;
							lpnt[1] *= 2047 * dmp->dm_aspect;
							lpnt[2] *= 2047;
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						} else {
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						}
					}
					dist_prev = dist;
				} else {
					MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
				}

				pnt[0] *= 2047;
				pnt[1] *= 2047 * dmp->dm_aspect;
				pnt[2] *= 2047;
d847 27
a873 53
				/* save pnt --- it might get changed by clip() */
				VMOVE(spnt, pnt);
				pt_prev = pt;

				if (dmp->dm_debugLevel > 2) {
					bu_log("before clipping:\n");
					bu_log("clipmin - %lf %lf %lf\n",
					       dmp->dm_clipmin[X],
					       dmp->dm_clipmin[Y],
					       dmp->dm_clipmin[Z]);
					bu_log("clipmax - %lf %lf %lf\n",
					       dmp->dm_clipmax[X],
					       dmp->dm_clipmax[Y],
					       dmp->dm_clipmax[Z]);
					bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
					bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
				}

				if (dmp->dm_zclip) {
					if (vclip(lpnt, pnt,
						  dmp->dm_clipmin,
						  dmp->dm_clipmax) == 0) {
						VMOVE(lpnt, spnt);
						continue;
					}
				} else {
					/* Check to see if lpnt or pnt contain values that exceed
					   the capacity of a short (segbuf is an array of XSegments which
					   contain shorts). If so, do clipping now. Otherwise, let the
					   X server do the clipping */
					if (lpnt[0] < min_short || max_short < lpnt[0] ||
					    lpnt[1] < min_short || max_short < lpnt[1] ||
					    pnt[0] < min_short || max_short < pnt[0] ||
					    pnt[1] < min_short || max_short < pnt[1]) {
						/* if the entire line segment will not be visible then ignore it */
						if (clip(&lpnt[0], &lpnt[1], &pnt[0], &pnt[1]) == -1) {
							VMOVE(lpnt, spnt);
							continue;
						}
					}
				}

				if (dmp->dm_debugLevel > 2) {
					bu_log("after clipping:\n");
					bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
					bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
				}

				/* convert to X window coordinates */
				segp->x1 = (short)GED_TO_Xx(dmp, lpnt[0]);
				segp->y1 = (short)GED_TO_Xy(dmp, lpnt[1]);
				segp->x2 = (short)GED_TO_Xx(dmp, pnt[0]);
				segp->y2 = (short)GED_TO_Xy(dmp, pnt[1]);
d875 4
a878 15
				nseg++;
				segp++;
				VMOVE(lpnt, spnt);

				if (nseg == 1024) {
					XDrawSegments(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
						      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg);

					nseg = 0;
					segp = segbuf;
				}
				break;
			}
		}
d880 1
a880 4
		nvectors += nused;
		if (nvectors >= vectorThreshold) {
			if (dmp->dm_debugLevel)
				bu_log("X_drawVList(): handle Tcl events\n");
d882 2
a883 5
			nvectors = 0;

			/* Handle events in the queue */
			while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
		}
d885 1
d887 5
a891 5
	if (nseg) {
		XDrawSegments( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
			       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg );
	}
d893 1
a893 1
	return TCL_OK;
d905 2
a906 2
  if (dmp->dm_debugLevel)
    bu_log("X_normal()\n");
d908 1
a908 1
  return TCL_OK;
d921 15
a935 1
  int sx, sy;
d937 2
a938 11
  if (dmp->dm_debugLevel){
    bu_log("X_drawString2D():\n");
    bu_log("\tstr - %s\n", str);
    bu_log("\tx - %g\n", x);
    bu_log("\ty - %g\n", y);
    bu_log("\tsize - %d\n", size);
    if(use_aspect){
      bu_log("\tuse_aspect - %d\t\taspect ratio - %g\n", use_aspect, dmp->dm_aspect);
    }else
      bu_log("\tuse_aspect - 0");
  }
d940 4
a943 2
  sx = dm_Normal2Xx(dmp, x);
  sy = dm_Normal2Xy(dmp, y, use_aspect);
d945 1
a945 6
  XDrawString( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	       sx, sy, str, strlen(str) );

  return TCL_OK;
d951 16
a966 1
  int	sx1, sy1, sx2, sy2;
d968 4
a971 17
  sx1 = dm_Normal2Xx(dmp, x1);
  sx2 = dm_Normal2Xx(dmp, x2);
  sy1 = dm_Normal2Xy(dmp, y1, 0);
  sy2 = dm_Normal2Xy(dmp, y2, 0);

  if (dmp->dm_debugLevel) {
    bu_log("X_drawLine2D()\n");
    bu_log("x1 = %g, y1 = %g\n", x1, y1);
    bu_log("x2 = %g, y2 = %g\n", x2, y2);
    bu_log("sx1 = %d, sy1 = %d\n", sx1, sy1);
    bu_log("sx2 = %d, sy2 = %d\n", sx2, sy2);
  }

  XDrawLine( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	     ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	     ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	     sx1, sy1, sx2, sy2 );
d973 1
a973 1
  return TCL_OK;
d979 12
a990 1
  int   sx, sy;
d992 3
a994 2
  sx = dm_Normal2Xx(dmp, x);
  sy = dm_Normal2Xy(dmp, y, 0);
d996 1
a996 11
  if (dmp->dm_debugLevel) {
    bu_log("X_drawPoint2D()\n");
    bu_log("x = %g, y = %g\n", x, y);
    bu_log("sx = %d, sy = %d\n", sx, sy);
  }

  XDrawPoint( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, sx, sy );

  return TCL_OK;
d1002 20
a1021 1
  XGCValues gcv;
d1023 12
a1034 2
  if (dmp->dm_debugLevel)
    bu_log("X_setFGColor()\n");
d1036 1
a1036 28
  dmp->dm_fg[0] = r;
  dmp->dm_fg[1] = g;
  dmp->dm_fg[2] = b;

  if(((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor){
    XColor color;

    color.red = r << 8;
    color.green = g << 8;
    color.blue = b << 8;
    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
	      &color);

    gcv.foreground = color.pixel;
  }else
    gcv.foreground = dm_get_pixel(r, g, b,
				  ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels,
				  CUBE_DIMENSION);

  /* save foreground pixel */
  ((struct x_vars *)dmp->dm_vars.priv_vars)->fg = gcv.foreground;

  XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	    GCForeground, &gcv);

  return TCL_OK;
d1042 2
a1043 2
  if (dmp->dm_debugLevel)
    bu_log("X_setBGColor()\n");
d1045 2
a1046 3
  dmp->dm_bg[0] = r;
  dmp->dm_bg[1] = g;
  dmp->dm_bg[2] = b;
d1048 3
a1050 1
  if(((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor){
d1052 1
a1052 1
    XColor color;
d1054 1
a1054 3
    color.red = r << 8;
    color.green = g << 8;
    color.blue = b << 8;
d1056 3
a1058 3
    get_color(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap,
		&color);
d1060 3
a1062 4
    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg = color.pixel;
  } else
    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg =
      dm_get_pixel(r, g, b, ((struct x_vars *)dmp->dm_vars.priv_vars)->pixels, CUBE_DIMENSION);
d1064 6
a1069 1
  return TCL_OK;
d1075 3
a1077 1
  int linestyle;
d1079 2
a1080 2
  if (dmp->dm_debugLevel)
    bu_log("X_setLineAttr()\n");
d1082 2
a1083 2
  dmp->dm_lineWidth = width;
  dmp->dm_lineStyle = style;
d1085 2
a1086 2
  if(width <= 1)
    width = 0;
d1088 4
a1091 4
  if(style == DM_DASHED_LINE)
    linestyle = LineOnOffDash;
  else
    linestyle = LineSolid;
d1093 3
a1095 3
  XSetLineAttributes( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
		      width, linestyle, CapButt, JoinMiter );
d1097 1
a1097 1
  return TCL_OK;
d1104 1
a1104 1
  dmp->dm_debugLevel = lvl;
d1106 1
a1106 1
  return TCL_OK;
d1112 2
a1113 2
  if (dmp->dm_debugLevel)
    bu_log("X_setWinBounds()\n");
d1115 6
a1120 6
  dmp->dm_clipmin[0] = w[0];
  dmp->dm_clipmin[1] = w[2];
  dmp->dm_clipmin[2] = w[4];
  dmp->dm_clipmax[0] = w[1];
  dmp->dm_clipmax[1] = w[3];
  dmp->dm_clipmax[2] = w[5];
d1122 1
a1122 1
  return TCL_OK;
d1128 52
a1179 12
  XWindowAttributes xwa;
  XFontStruct     *newfontstruct;
  XGCValues       gcv;

  XGetWindowAttributes( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, &xwa );

  /* nothing to do */
  if (!force &&
      dmp->dm_height == xwa.height &&
      dmp->dm_width == xwa.width)
    return TCL_OK;
d1181 60
a1240 97
  dmp->dm_height = xwa.height;
  dmp->dm_width = xwa.width;
  dmp->dm_aspect = (fastf_t)dmp->dm_width / (fastf_t)dmp->dm_height;

  if (dmp->dm_debugLevel) {
    bu_log("X_configureWin_guts()\n");
    bu_log("width = %d, height = %d\n", dmp->dm_width, dmp->dm_height);
  }

  Tk_FreePixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct x_vars *)dmp->dm_vars.priv_vars)->pix);
  ((struct x_vars *)dmp->dm_vars.priv_vars)->pix =
    Tk_GetPixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 DefaultRootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy),
		 dmp->dm_width,
		 dmp->dm_height,
		 Tk_Depth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  /* First time through, load a font or quit */
  if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct == NULL) {
    if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct =
	 XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, FONT9)) == NULL ) {
      /* Try hardcoded backup font */
      if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct =
	   XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, FONTBACK)) == NULL) {
	bu_log("dm-X: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
	return TCL_ERROR;
      }
    }

    gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
    XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
  }

  /* Always try to choose a the font that best fits the window size.
   */

  if (dmp->dm_width < 582) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 5) {
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT5)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  } else if (dmp->dm_width < 679) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 6){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT6)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  } else if (dmp->dm_width < 776) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 7){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT7)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  } else if (dmp->dm_width < 873) {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 8){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT8)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
    }
  } else {
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 9){
      if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
					  FONT9)) != NULL ) {
	XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
	gcv.font = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid;
	XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, GCFont, &gcv);
      }
a1241 1
  }
d1243 1
a1243 1
  return TCL_OK;
d1249 2
a1250 2
  /* don't force */
  return X_configureWin_guts(dmp, 0);
d1256 2
a1257 2
  if (dmp->dm_debugLevel)
    bu_log("X_setLight:\n");
d1259 1
a1259 1
  dmp->dm_light = light_on;
d1261 1
a1261 1
  return TCL_OK;
d1267 2
a1268 2
  if (dmp->dm_debugLevel)
    bu_log("X_setZBuffer:\n");
d1270 1
a1270 1
  dmp->dm_zbuffer = zbuffer_on;
d1272 1
a1272 1
  return TCL_OK;
d1278 8
a1285 6
  XVisualInfo *vip, vitemp, *vibase, *maxvip;
  int good[256];
  int num, i, j;
  int tries, baddepth;
  int desire_trueColor = 1;
  int min_depth = 8;
d1287 2
a1288 2
  vibase = XGetVisualInfo(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  0, &vitemp, &num);
d1290 2
a1291 2
  while (1) {
    for (i=0, j=0, vip=vibase; i<num; i++, vip++){
d1293 5
a1297 5
      /* code to force a particular visual class and depth */
      if (vip->depth != 8)
	continue;
      if (vip->class != PseudoColor)
	continue;
d1299 8
a1306 8
      /* requirements */
      if (vip->depth < min_depth)
	continue;
      if (desire_trueColor){
	if (vip->class != TrueColor)
	  continue;
      }else if (vip->class != PseudoColor)
	continue;
d1309 13
a1321 3
      /* this visual meets criteria */
      good[j++] = i;
    }
d1323 29
a1351 7
    baddepth = 1000;
    for(tries = 0; tries < j; ++tries) {
      maxvip = vibase + good[0];
      for (i=1; i<j; i++) {
	vip = vibase + good[i];
	if ((vip->depth > maxvip->depth)&&(vip->depth < baddepth)){
	  maxvip = vip;
a1352 1
      }
d1354 4
a1357 30
      /* make sure Tk handles it */
      if(desire_trueColor){
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap =
	  XCreateColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  RootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				     maxvip->screen),
			  maxvip->visual, AllocNone);
	((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor = 1;
      }else{
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap =
	  XCreateColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  RootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				     maxvip->screen),
			  maxvip->visual, AllocAll);
	((struct x_vars *)dmp->dm_vars.priv_vars)->is_trueColor = 0;
      }

      if (Tk_SetWindowVisual(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
			     maxvip->visual,
			     maxvip->depth,
			     ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)){
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->depth = maxvip->depth;

	return maxvip; /* success */
      } else {
	/* retry with lesser depth */
	baddepth = maxvip->depth;
	XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);
      }
a1358 6

    if(desire_trueColor)
      desire_trueColor = 0;
    else
      return (XVisualInfo *)NULL; /* failure */
  }
@


14.13
log
@need stdlib.h for getenv()
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.12 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
d52 1
@


14.12
log
@update copyright to 2006
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.11 2005/10/31 06:08:20 brlcad Exp $ (BRL)";
d43 1
@


14.11
log
@quell aix compiler warnings, cast bu_free pointer to genptr_t
@
text
@d4 1
a4 1
 * Copyright (C) 1988-2005 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.10 2005/10/23 04:44:33 brlcad Exp $ (BRL)";
@


14.10
log
@trailing ws
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.9 2005/09/16 18:58:34 brlcad Exp $ (BRL)";
d248 1
a248 1
    bu_free(dmp, "X_open: dmp");
d254 2
a255 2
    bu_free(dmp->dm_vars.pub_vars, "X_open: dmp->dm_vars.pub_vars");
    bu_free(dmp, "X_open: dmp");
d550 3
a552 3
  bu_free(dmp->dm_vars.priv_vars, "X_close: x_vars");
  bu_free(dmp->dm_vars.pub_vars, "X_close: dm_xvars");
  bu_free(dmp, "X_close: dmp");
@


14.9
log
@wrap the file contents in its DM_* symbol so that it can be compiled regardless of it being available
@
text
@d28 1
a28 1
 *  
d33 1
a33 1
 *  
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.8 2005/08/27 14:24:33 brlcad Exp $ (BRL)";
d165 1
a165 1
extern int vectorThreshold;	/* defined in libdm/tcl.c */ 
d167 1
a167 1
static void 
d178 1
a178 1
	case 1: 
d193 1
a193 1
		bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n", 
d199 1
a199 1
		bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n", 
d370 1
a370 1
		     dmp->dm_width, 
d430 1
a430 1
  }  
d519 1
a519 1
 *  
d644 1
a644 1
 *  
d1107 1
a1107 1
    
d1271 1
a1271 1
			
d1310 1
a1310 1
      } else { 
@


14.8
log
@add a configure test for SGI knobs support, and define the IR_KNOBS and IR_BUTTONS if/when they are available.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.7 2005/03/13 00:43:39 brlcad Exp $ (BRL)";
d41 1
d1325 2
@


14.8.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d33 1
a33 1
 *
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a40 1
#ifdef DM_X
d164 1
a164 1
extern int vectorThreshold;	/* defined in libdm/tcl.c */
d166 1
a166 1
static void
d177 1
a177 1
	case 1:
d192 1
a192 1
		bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n",
d198 1
a198 1
		bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n",
d247 1
a247 1
    bu_free((genptr_t)dmp, "X_open: dmp");
d253 2
a254 2
    bu_free((genptr_t)dmp->dm_vars.pub_vars, "X_open: dmp->dm_vars.pub_vars");
    bu_free((genptr_t)dmp, "X_open: dmp");
d369 1
a369 1
		     dmp->dm_width,
d429 1
a429 1
  }
d518 1
a518 1
 *
d549 3
a551 3
  bu_free((genptr_t)dmp->dm_vars.priv_vars, "X_close: x_vars");
  bu_free((genptr_t)dmp->dm_vars.pub_vars, "X_close: dm_xvars");
  bu_free((genptr_t)dmp, "X_close: dmp");
d643 1
a643 1
 *
d1106 1
a1106 1

d1270 1
a1270 1

d1309 1
a1309 1
      } else {
a1323 2
#endif /* DM_X */

@


14.7
log
@quell the Xlib extension warning on XInputExtension by checking for it and not making a call to XListInputDevices if it's not available.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.6 2005/01/30 20:30:47 brlcad Exp $ (BRL)";
d470 1
a470 1
#if IR_BUTTONS
d480 1
a480 1
#if IR_KNOBS
@


14.6
log
@update copyright to 2005
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
d223 2
a224 1
  XDeviceInfoPtr olist, list;
d451 3
a453 3
  olist = list =
    (XDeviceInfoPtr)XListInputDevices(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				      &ndevices);
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2004 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-X.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a33 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-X.c,v 14.3 2004/12/21 05:45:22 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-X.c,v 14.2 2004/12/21 02:24:40 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-X.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			D M - X . C
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-X.c,v 1.5 2004/09/03 23:30:57 morrison Exp $ (BRL)";
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-X.c,v 1.4 2004/08/03 20:42:29 morrison Exp $ (BRL)";
d1306 10
@


1.4
log
@apply Bob's provided patches from 20040630.  this includes itcl namespace scoping, windows DLL exporting, and wdb arb edit support
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libdm/dm-X.c,v 1.2 2004/06/08 22:04:19 morrison Exp $ (BRL)";
d28 1
a28 1
#ifdef USE_STRING_H
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d138 1
@


1.2
log
@obliterate externs.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libdm/dm-X.c,v 1.64 2004/05/10 15:30:44 erikg Exp $ (BRL)";
a53 1
#include "externs.h"
@

