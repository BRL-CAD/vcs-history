head	14.11;
access;
symbols
	rel-7-10-4:14.11
	STABLE:14.11.0.2
	stable-branch:14.7
	rel-7-10-2:14.11
	rel-7-10-0:14.10
	rel-7-8-4:14.8
	rel-7-8-2:14.8
	rel-7-8-0:14.8
	trimnurbs-branch:14.8.0.2
	help:14.8
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.7
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.11
date	2007.04.11.18.48.48;	author bob1961;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.01.30.20.30.47;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.02.24.40;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.47.22;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.25.05.03.14;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.19;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.37;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.11
log
@Added support for the drawDataAxes command.
@
text
@/*                          A X E S . C
 * BRL-CAD
 *
 * Copyright (c) 1998-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file axes.c
 *
 * Functions -
 *	draw_axes	Common axes drawing routine that draws axes at the
 *			specifed point and orientation.
 * Author -
 *	Robert G. Parker
 *
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	berdeen Proving Ground, Maryland  21005
 *
 */

#include "common.h"

#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "dm.h"

/*XXX This needs to be modified to handle an array/list of data points */
void
dmo_drawDataAxes_cmd(struct dm *dmp,
		     fastf_t viewSize, /* in mm */
		     mat_t rmat,       /* view rotation matrix */
		     point_t axesPos,  /* in view coordinates */
		     fastf_t axesSize, /* in view coordinates */
		     int *axesColor,
		     int lineWidth)    /* in pixels */
{
    register fastf_t halfAxesSize;		/* half the length of an axis */
    point_t v2;
    point_t rxv1, rxv2;
    point_t ryv1, ryv2;
    point_t rzv1, rzv2;
    point_t o_rv2;
    /* Save the line attributes */
    int saveLineWidth = dmp->dm_lineWidth;
    int saveLineStyle = dmp->dm_lineStyle;

    halfAxesSize = axesSize * 0.5;

    /* set color */
    DM_SET_FGCOLOR(dmp, axesColor[0], axesColor[1], axesColor[2], 1, 1.0);

    /* set linewidth */
    DM_SET_LINE_ATTR(dmp, lineWidth, 0);  /* solid lines */

    /* build X axis about view center */
    VSET(v2, halfAxesSize, 0.0, 0.0);

    /* rotate X axis into position */
    MAT4X3PNT(rxv2, rmat, v2);
    VSCALE(rxv1, rxv2, -1.0);

    /* draw X axis with x/y offsets */
    DM_DRAW_LINE_2D(dmp,
		    rxv1[X] + axesPos[X], (rxv1[Y] + axesPos[Y]) * dmp->dm_aspect,
		    rxv2[X] + axesPos[X], (rxv2[Y] + axesPos[Y]) * dmp->dm_aspect);

    /* build Y axis about view center */
    VSET(v2, 0.0, halfAxesSize, 0.0);

    /* rotate Y axis into position */
    MAT4X3PNT(ryv2, rmat, v2);
    VSCALE(ryv1, ryv2, -1.0);

    /* draw Y axis with x/y offsets */
    DM_DRAW_LINE_2D(dmp,
		    ryv1[X] + axesPos[X], (ryv1[Y] + axesPos[Y]) * dmp->dm_aspect,
		    ryv2[X] + axesPos[X], (ryv2[Y] + axesPos[Y]) * dmp->dm_aspect);

    /* build Z axis about view center */
    VSET(v2, 0.0, 0.0, halfAxesSize);

    /* rotate Z axis into position */
    MAT4X3PNT(rzv2, rmat, v2);
    VSCALE(rzv1, rzv2, -1.0);

    /* draw Z axis with x/y offsets */
    DM_DRAW_LINE_2D(dmp,
		    rzv1[X] + axesPos[X], (rzv1[Y] + axesPos[Y]) * dmp->dm_aspect,
		    rzv2[X] + axesPos[X], (rzv2[Y] + axesPos[Y]) * dmp->dm_aspect);

    /* Restore the line attributes */
    DM_SET_LINE_ATTR(dmp, saveLineWidth, saveLineStyle);
}


void
dmo_drawAxes_cmd(struct dm *dmp,
		 fastf_t viewSize, /* in mm */
		 mat_t rmat,       /* view rotation matrix */
		 point_t axesPos,  /* in view coordinates */
		 fastf_t axesSize, /* in view coordinates */
		 int *axesColor,
		 int *labelColor,
		 int lineWidth,    /* in pixels */
		 int posOnly,
		 int threeColor,
		 int tickEnabled,
		 int tickLen,      /* in pixels */
		 int majorTickLen,      /* in pixels */
		 fastf_t tickInterval, /* in mm */
		 int ticksPerMajor,
		 int *tickColor,
		 int *majorTickColor,
		 int tickThreshold)
{
  register fastf_t halfAxesSize;		/* half the length of an axis */
  register fastf_t xlx, xly;			/* X axis label position */
  register fastf_t ylx, yly;			/* Y axis label position */
  register fastf_t zlx, zly;			/* Z axis label position */
  register fastf_t l_offset = 0.0078125;	/* axis label offset from axis endpoints */
  point_t v2;
  point_t rxv1, rxv2;
  point_t ryv1, ryv2;
  point_t rzv1, rzv2;
  point_t o_rv2;
  /* Save the line attributes */
  int saveLineWidth = dmp->dm_lineWidth;
  int saveLineStyle = dmp->dm_lineStyle;

  halfAxesSize = axesSize * 0.5;

  /* set axes line width */
  DM_SET_LINE_ATTR(dmp, lineWidth, 0);  /* solid lines */

  /* build X axis about view center */
  VSET(v2, halfAxesSize, 0.0, 0.0);

  /* rotate X axis into position */
  MAT4X3PNT(rxv2, rmat, v2);
  if (posOnly) {
    VSET(rxv1, 0.0, 0.0, 0.0);
  } else {
    VSCALE(rxv1, rxv2, -1.0);
  }

  /* find the X axis label position about view center */
  VSET(v2, v2[X] + l_offset, v2[Y] + l_offset, v2[Z] + l_offset);
  MAT4X3PNT(o_rv2, rmat, v2);
  xlx = o_rv2[X];
  xly = o_rv2[Y];

  if (threeColor) {
    /* set X axis color - red */
    DM_SET_FGCOLOR(dmp, 255, 0, 0, 1, 1.0);

    /* draw the X label */
    DM_DRAW_STRING_2D(dmp, "X", xlx + axesPos[X], xly + axesPos[Y], 1, 1);
  } else
    /* set axes color */
    DM_SET_FGCOLOR(dmp, axesColor[0], axesColor[1], axesColor[2], 1, 1.0);

  /* draw X axis with x/y offsets */
  DM_DRAW_LINE_2D(dmp, rxv1[X] + axesPos[X], (rxv1[Y] + axesPos[Y]) * dmp->dm_aspect,
		  rxv2[X] + axesPos[X], (rxv2[Y] + axesPos[Y]) * dmp->dm_aspect);

  /* build Y axis about view center */
  VSET(v2, 0.0, halfAxesSize, 0.0);

  /* rotate Y axis into position */
  MAT4X3PNT(ryv2, rmat, v2);
  if (posOnly) {
    VSET(ryv1, 0.0, 0.0, 0.0);
  } else {
    VSCALE(ryv1, ryv2, -1.0);
  }

  /* find the Y axis label position about view center */
  VSET(v2, v2[X] + l_offset, v2[Y] + l_offset, v2[Z] + l_offset);
  MAT4X3PNT(o_rv2, rmat, v2);
  ylx = o_rv2[X];
  yly = o_rv2[Y];

  if (threeColor) {
    /* set Y axis color - green */
    DM_SET_FGCOLOR(dmp, 0, 255, 0, 1, 1.0);

    /* draw the Y label */
    DM_DRAW_STRING_2D(dmp, "Y", ylx + axesPos[X], yly + axesPos[Y], 1, 1);
  }

  /* draw Y axis with x/y offsets */
  DM_DRAW_LINE_2D(dmp, ryv1[X] + axesPos[X], (ryv1[Y] + axesPos[Y]) * dmp->dm_aspect,
		  ryv2[X] + axesPos[X], (ryv2[Y] + axesPos[Y]) * dmp->dm_aspect);

  /* build Z axis about view center */
  VSET(v2, 0.0, 0.0, halfAxesSize);

  /* rotate Z axis into position */
  MAT4X3PNT(rzv2, rmat, v2);
  if (posOnly) {
    VSET(rzv1, 0.0, 0.0, 0.0);
  } else {
    VSCALE(rzv1, rzv2, -1.0);
  }

  /* find the Z axis label position about view center */
  VSET(v2, v2[X] + l_offset, v2[Y] + l_offset, v2[Z] + l_offset);
  MAT4X3PNT(o_rv2, rmat, v2);
  zlx = o_rv2[X];
  zly = o_rv2[Y];

  if (threeColor) {
    /* set Z axis color - blue*/
    DM_SET_FGCOLOR(dmp, 0, 0, 255, 1, 1.0);

    /* draw the Z label */
    DM_DRAW_STRING_2D(dmp, "Z", zlx + axesPos[X], zly + axesPos[Y], 1, 1);
  }

  /* draw Z axis with x/y offsets */
  DM_DRAW_LINE_2D(dmp, rzv1[X] + axesPos[X], (rzv1[Y] + axesPos[Y]) * dmp->dm_aspect,
		  rzv2[X] + axesPos[X], (rzv2[Y] + axesPos[Y]) * dmp->dm_aspect);

  if (!threeColor) {
    /* set axes string color */
    DM_SET_FGCOLOR(dmp, labelColor[0], labelColor[1], labelColor[2], 1, 1.0);

    /* draw axes strings/labels with x/y offsets */
    DM_DRAW_STRING_2D(dmp, "X", xlx + axesPos[X], xly + axesPos[Y], 1, 1);
    DM_DRAW_STRING_2D(dmp, "Y", ylx + axesPos[X], yly + axesPos[Y], 1, 1);
    DM_DRAW_STRING_2D(dmp, "Z", zlx + axesPos[X], zly + axesPos[Y], 1, 1);
  }

  if (tickEnabled) {
    /* number of ticks in one direction of a coordinate axis */
    int numTicks = viewSize / tickInterval * 0.5 * halfAxesSize;
    int doMajorOnly = 0;
    int i;
    vect_t xend1, xend2;
    vect_t yend1, yend2;
    vect_t zend1, zend2;
    vect_t dir;
    vect_t rxdir, neg_rxdir;
    vect_t rydir, neg_rydir;
    vect_t rzdir, neg_rzdir;
    fastf_t interval;
    fastf_t tlen;
    fastf_t maj_tlen;
    vect_t maj_xend1, maj_xend2;
    vect_t maj_yend1, maj_yend2;
    vect_t maj_zend1, maj_zend2;

    if (dmp->dm_width <= numTicks / halfAxesSize * tickThreshold * 2) {
      int numMajorTicks = numTicks / ticksPerMajor;

      if (dmp->dm_width <= numMajorTicks / halfAxesSize * tickThreshold * 2) {
	  /* Restore the line attributes */
	  DM_SET_LINE_ATTR(dmp, saveLineWidth, saveLineStyle);

	  return;
      }

      doMajorOnly = 1;
    }

    /* convert tick interval in model space to view space */
    interval = tickInterval / viewSize * 2.0;

    /* convert tick length in pixels to view space */
    tlen = tickLen / (fastf_t)dmp->dm_width * 2.0;

    /* convert major tick length in pixels to view space */
    maj_tlen = majorTickLen / (fastf_t)dmp->dm_width * 2.0;

    if (!doMajorOnly) {
      /* calculate end points for x ticks */
      VSET(dir, tlen, 0.0, 0.0);
      MAT4X3PNT(xend1, rmat, dir);
      VSCALE(xend2, xend1, -1.0);

      /* calculate end points for y ticks */
      VSET(dir, 0.0, tlen, 0.0);
      MAT4X3PNT(yend1, rmat, dir);
      VSCALE(yend2, yend1, -1.0);

      /* calculate end points for z ticks */
      VSET(dir, 0.0, 0.0, tlen);
      MAT4X3PNT(zend1, rmat, dir);
      VSCALE(zend2, zend1, -1.0);
    }

    /* calculate end points for major x ticks */
    VSET(dir, maj_tlen, 0.0, 0.0);
    MAT4X3PNT(maj_xend1, rmat, dir);
    VSCALE(maj_xend2, maj_xend1, -1.0);

    /* calculate end points for major y ticks */
    VSET(dir, 0.0, maj_tlen, 0.0);
    MAT4X3PNT(maj_yend1, rmat, dir);
    VSCALE(maj_yend2, maj_yend1, -1.0);

    /* calculate end points for major z ticks */
    VSET(dir, 0.0, 0.0, maj_tlen);
    MAT4X3PNT(maj_zend1, rmat, dir);
    VSCALE(maj_zend2, maj_zend1, -1.0);

    /* calculate the rotated x direction vector */
    VSET(dir, interval, 0.0, 0.0);
    MAT4X3PNT(rxdir, rmat, dir);
    VSCALE(neg_rxdir, rxdir, -1.0);

    /* calculate the rotated y direction vector */
    VSET(dir, 0.0, interval, 0.0);
    MAT4X3PNT(rydir, rmat, dir);
    VSCALE(neg_rydir, rydir, -1.0);

    /* calculate the rotated z direction vector */
    VSET(dir, 0.0, 0.0, interval);
    MAT4X3PNT(rzdir, rmat, dir);
    VSCALE(neg_rzdir, rzdir, -1.0);

    /* draw ticks along X axis */
    for (i = 1; i <= numTicks; ++i) {
      vect_t tvec;
      point_t t1, t2;
      int notMajor;

      if (ticksPerMajor == 0)
	notMajor = 1;
      else
	notMajor = i % ticksPerMajor;

      /********* draw ticks along X *********/
      /* positive X direction */
      VSCALE(tvec, rxdir, i);

      /* draw tick in XY plane */
      if (notMajor) {
	if (doMajorOnly)
	  continue;

	/* set tick color */
	DM_SET_FGCOLOR(dmp, tickColor[0], tickColor[1], tickColor[2], 1, 1.0);

	VADD2(t1, yend1, tvec);
	VADD2(t2, yend2, tvec);
      } else {
	/* set major tick color */
	DM_SET_FGCOLOR(dmp, majorTickColor[0], majorTickColor[1], majorTickColor[2], 1, 1.0);

	VADD2(t1, maj_yend1, tvec);
	VADD2(t2, maj_yend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      /* draw tick in XZ plane */
      if (notMajor) {
	VADD2(t1, zend1, tvec);
	VADD2(t2, zend2, tvec);
      } else {
	VADD2(t1, maj_zend1, tvec);
	VADD2(t2, maj_zend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      if (!posOnly) {
      /* negative X direction */
      VSCALE(tvec, neg_rxdir, i);

      /* draw tick in XY plane */
      if (notMajor) {
	VADD2(t1, yend1, tvec);
	VADD2(t2, yend2, tvec);
      } else {
	VADD2(t1, maj_yend1, tvec);
	VADD2(t2, maj_yend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      /* draw tick in XZ plane */
      if (notMajor) {
	VADD2(t1, zend1, tvec);
	VADD2(t2, zend2, tvec);
      } else {
	VADD2(t1, maj_zend1, tvec);
	VADD2(t2, maj_zend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);
      }

      /********* draw ticks along Y *********/
      /* positive Y direction */
      VSCALE(tvec, rydir, i);

      /* draw tick in YX plane */
      if (notMajor) {
	VADD2(t1, xend1, tvec);
	VADD2(t2, xend2, tvec);
      } else {
	VADD2(t1, maj_xend1, tvec);
	VADD2(t2, maj_xend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      /* draw tick in YZ plane */
      if (notMajor) {
	VADD2(t1, zend1, tvec);
	VADD2(t2, zend2, tvec);
      } else {
	VADD2(t1, maj_zend1, tvec);
	VADD2(t2, maj_zend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      if (!posOnly) {
      /* negative Y direction */
      VSCALE(tvec, neg_rydir, i);

      /* draw tick in YX plane */
      if (notMajor) {
	VADD2(t1, xend1, tvec);
	VADD2(t2, xend2, tvec);
      } else {
	VADD2(t1, maj_xend1, tvec);
	VADD2(t2, maj_xend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      /* draw tick in XZ plane */
      if (notMajor) {
	VADD2(t1, zend1, tvec);
	VADD2(t2, zend2, tvec);
      } else {
	VADD2(t1, maj_zend1, tvec);
	VADD2(t2, maj_zend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);
      }

      /********* draw ticks along Z *********/
      /* positive Z direction */
      VSCALE(tvec, rzdir, i);

      /* draw tick in ZX plane */
      if (notMajor) {
	VADD2(t1, xend1, tvec);
	VADD2(t2, xend2, tvec);
      } else {
	VADD2(t1, maj_xend1, tvec);
	VADD2(t2, maj_xend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      /* draw tick in ZY plane */
      if (notMajor) {
	VADD2(t1, yend1, tvec);
	VADD2(t2, yend2, tvec);
      } else {
	VADD2(t1, maj_yend1, tvec);
	VADD2(t2, maj_yend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      if (!posOnly) {
      /* negative Z direction */
      VSCALE(tvec, neg_rzdir, i);

      /* draw tick in ZX plane */
      if (notMajor) {
	VADD2(t1, xend1, tvec);
	VADD2(t2, xend2, tvec);
      } else {
	VADD2(t1, maj_xend1, tvec);
	VADD2(t2, maj_xend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);

      /* draw tick in ZY plane */
      if (notMajor) {
	VADD2(t1, yend1, tvec);
	VADD2(t2, yend2, tvec);
      } else {
	VADD2(t1, maj_yend1, tvec);
	VADD2(t2, maj_yend2, tvec);
      }
      DM_DRAW_LINE_2D(dmp, t1[X] + axesPos[X], (t1[Y] + axesPos[Y]) * dmp->dm_aspect,
		      t2[X] + axesPos[X], (t2[Y] + axesPos[Y]) * dmp->dm_aspect);
      }
    }
  }

  /* Restore the line attributes */
  DM_SET_LINE_ATTR(dmp, saveLineWidth, saveLineStyle);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.10
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d46 69
d145 3
d276 4
a279 1
	return;
d521 3
@


14.9
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.8
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2006 United States Government as represented by
@


14.7
log
@update copyright to 2005
@
text
@d4 1
a4 1
 * Copyright (C) 1998-2005 United States Government as represented by
@


14.6
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 United States Government as represented by
@


14.5
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a33 3
 * Copyright Notice -
 *      This software is Copyright (C) 1998-2004 by the United States Army.
 *      All rights reserved.
@


14.4
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.3
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.2
log
@how the heck are these old cake helper script files still alive?? delete.
@
text
@d1 21
a21 2
/*
 *			A X E S . C
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d16 1
a16 1
 *      This software is Copyright (C) 1998 by the United States Army.
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d432 10
@


1.3
log
@replace conf.h with config.h block
@
text
@d20 1
a20 3
#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d20 3
a22 1
#include "conf.h"
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a28 1
#include "externs.h"
@

