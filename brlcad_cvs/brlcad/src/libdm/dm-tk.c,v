head	14.14;
access;
symbols
	rel-7-10-4:14.12.2.1
	STABLE:14.12.0.2
	rel-7-10-2:14.12
	rel-7-10-0:14.8
	rel-7-8-4:14.5;
locks; strict;
comment	@ * @;


14.14
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.09.15.16.23.10;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.05.26.22.04.37;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2007.05.14.19.12.41;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.05.14.19.12.03;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.04.23.13.30.19;	author joevalleyfield;	state Exp;
branches;
next	14.8;

14.8
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2006.08.24.17.49.41;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2006.08.22.21.19.02;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2006.08.19.21.00.34;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2006.08.11.06.33.44;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2006.08.10.01.00.52;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2007.09.28.14.04.31;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.14
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@/*                          D M - T K . C
 * BRL-CAD
 *
 * Copyright (c) 1988-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file dm-tk.c
 *
 *  A Display Manager that should work wherever tk does.
 *
 *  Author -
 *      Tim J. Myers
 *
 *  Derived from display managers written by -
 *	Phillip Dykstra
 *	Robert G. Parker
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */

#include "common.h"

#ifdef DM_TK

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>

/* Even on a platform that has no real X, I should be able to use the
 * Xutil that comes with Tk
 */
#include <tk.h>
#include <X11/Xutil.h>
#include <X11/X.h>

#define USE_DIALS_AND_BUTTONS 0

#ifdef HAVE_X11_XOSDEFS_H
#  include <X11/Xfuncproto.h>
#  include <X11/Xosdefs.h>
#endif
#if USE_DIALS_AND_BUTTONS
#  include <X11/extensions/XInput.h>
#endif
#if defined(linux)
#  undef   X_NOT_STDC_ENV
#  undef   X_NOT_POSIX
#endif
#define XLIB_ILLEGAL_ACCESS	/* necessary on facist SGI 5.0.1 */

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "dm.h"
#include "dm-tk.h"
#include "dm-X.h"
#include "dm_xvars.h"
#include "solid.h"


struct dm	*tk_open_dm(Tcl_Interp *interp, int argc, char **argv);

HIDDEN void	label();
HIDDEN void	draw();
HIDDEN void     x_var_init();

/* Display Manager package interface */

#define PLOTBOUND	1000.0	/* Max magnification in Rot matrix */
HIDDEN int	tk_close(struct dm *dmp);
HIDDEN int	tk_drawBegin(struct dm *dmp), tk_drawEnd(struct dm *dmp);
HIDDEN int	tk_normal(struct dm *dmp), tk_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int      tk_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect);
HIDDEN int	tk_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      tk_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	tk_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      tk_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency);
HIDDEN int	tk_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	tk_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	tk_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	tk_configureWin(struct dm *dmp);
HIDDEN int	tk_setLight(struct dm *dmp, int light_on);
HIDDEN int	tk_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	tk_setWinBounds(struct dm *dmp, register int *w), tk_debug(struct dm *dmp, int lvl);

struct dm dm_tk = {
    tk_close,
    tk_drawBegin,
    tk_drawEnd,
    tk_normal,
    tk_loadMatrix,
    tk_drawString2D,
    tk_drawLine2D,
    tk_drawPoint2D,
    tk_drawVList,
    tk_setFGColor,
    tk_setBGColor,
    tk_setLineAttr,
    tk_configureWin,
    tk_setWinBounds,
    tk_setLight,
    Nu_int0,
    Nu_int0,
    tk_setZBuffer,
    tk_debug,
    Nu_int0,
    Nu_int0,
    Nu_int0,
    Nu_int0,
    0,
    0,				/* no displaylist */
    0,                            /* no stereo */
    PLOTBOUND,			/* zoom-in limit */
    1,				/* bound flag */
    "Tk",
    "Tk Abstraction Layer",
    DM_TYPE_TK,
    1,
    0,
    0,
    0,
    0,
    1.0, /* aspect ratio */
    0,
    {0, 0},
    {0, 0, 0, 0, 0},		/* bu_vls path name*/
    {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
    {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
    {0, 0, 0},			/* bg color */
    {0, 0, 0},			/* fg color */
    {GED_MIN, GED_MIN, GED_MIN},	/* clipmin */
    {GED_MAX, GED_MAX, GED_MAX},	/* clipmax */
    0,				/* no debugging */
    0,				/* no perspective */
    0,				/* no lighting */
    0,				/* no transparency */
    0,				/* depth buffer is not writable */
    0,				/* no zbuffer */
    0,				/* no zclipping */
    1,                            /* clear back buffer after drawing and swap */
    0				/* Tcl interpreter */
};

static fastf_t min_short = (fastf_t)SHRT_MIN;
static fastf_t max_short = (fastf_t)SHRT_MAX;

extern int vectorThreshold;	/* defined in libdm/tcl.c */

static void
get_color(Display *dpy, Colormap cmap, XColor *color)
{
    Status st;
    XColor rgb;

#define CSCK   0xf800

    rgb = *color;

    st = XAllocColor(dpy, cmap, color);
    switch (st) {
	case 1:
#if 0
	    if ( (color->red & CSCK) != (rgb.red & CSCK) ||
		 (color->green & CSCK) != (rgb.green & CSCK) ||
		 (color->blue & CSCK) != (rgb.blue & CSCK) ) {
		bu_log("\nlooking for fg    (%3d,%3d,%3d) %04x,%04x,%04x got \n                  (%3d,%3d,%3d) %04x,%04x,%04x\n",
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue,

		       (color->red >> 8), (color->green >> 8), (color->blue >> 8),
		       color->red, color->green, color->blue);
	    }
#endif
	    break;
	case BadColor:
	    bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n",
		   (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		   rgb.red, rgb.green, rgb.blue);
	    break;

	default:
	    bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n",
		   (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		   rgb.red, rgb.green, rgb.blue);
	    break;
    }
#undef CSCK

}

/*
 *			T k _ O P E N
 *
 * Fire up the display manager, and the display processor.
 *
 */
struct dm *
tk_open_dm(Tcl_Interp *interp, int argc, char **argv)
{
    static int count = 0;
    int make_square = -1;
    XGCValues gcv;

    struct bu_vls str;
    struct bu_vls init_proc_vls;
    struct dm *dmp = (struct dm *)NULL;
    Tk_Window tkwin;
    Display *dpy = (Display *)NULL;

    if ((tkwin = Tk_MainWindow(interp)) == NULL) {
	return DM_NULL;
    }

    BU_GETSTRUCT(dmp, dm);
    if(dmp == DM_NULL)
	return DM_NULL;

    *dmp = dm_tk; /* struct copy */
    dmp->dm_interp = interp;

    dmp->dm_vars.pub_vars = (genptr_t)bu_calloc(1, sizeof(struct dm_xvars), "tk_open: dm_xvars");
    if(dmp->dm_vars.pub_vars == (genptr_t)NULL){
	bu_free(dmp, "tk_open: dmp");
	return DM_NULL;
    }

    dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct tk_vars), "tk_open: tk_vars");
    if(dmp->dm_vars.priv_vars == (genptr_t)NULL){
	bu_free(dmp->dm_vars.pub_vars, "tk_open: dmp->dm_vars.pub_vars");
	bu_free(dmp, "tk_open: dmp");
	return DM_NULL;
    }

    bu_vls_init(&dmp->dm_pathName);
    bu_vls_init(&dmp->dm_tkName);
    bu_vls_init(&dmp->dm_dName);
    bu_vls_init(&init_proc_vls);

    dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);

    if(bu_vls_strlen(&dmp->dm_pathName) == 0) {
	bu_vls_printf(&dmp->dm_pathName, ".dm_tk%d", count);
    }

    ++count;
    if(bu_vls_strlen(&dmp->dm_dName) == 0){
	char *dp;

	dp = DisplayString(Tk_Display(tkwin));

	if(dp)
	    bu_vls_strcpy(&dmp->dm_dName, dp);
	else
	    bu_vls_strcpy(&dmp->dm_dName, ":0.0");
    }
    if(bu_vls_strlen(&init_proc_vls) == 0)
	bu_vls_strcpy(&init_proc_vls, "bind_dm");

    /* initialize dm specific variables */
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify = LASTEvent;
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress = LASTEvent;
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease = LASTEvent;
    dmp->dm_aspect = 1.0;

    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontset = 0;

    if(dmp->dm_top){
	/* Make xtkwin a toplevel window */
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
										     bu_vls_addr(&dmp->dm_pathName),
										     bu_vls_addr(&dmp->dm_dName));
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin;
    }else{
	char *cp;

	cp = strrchr(bu_vls_addr(&dmp->dm_pathName), (int)'.');
	if(cp == bu_vls_addr(&dmp->dm_pathName)){
	    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = tkwin;
	}else{
	    struct bu_vls top_vls;

	    bu_vls_init(&top_vls);
	    bu_vls_printf(&top_vls, "%*s", cp - bu_vls_addr(&dmp->dm_pathName),
			  bu_vls_addr(&dmp->dm_pathName));
	    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top =
		Tk_NameToWindow(interp, bu_vls_addr(&top_vls), tkwin);
	    bu_vls_free(&top_vls);
	}

	/* Make xtkwin an embedded window */
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin =
	    Tk_CreateWindow(interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top,
			    cp + 1, (char *)NULL);
    }

    if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin == NULL){
	bu_log("tk_open: Failed to open %s\n", bu_vls_addr(&dmp->dm_pathName));
	(void)tk_close(dmp);
	return DM_NULL;
    }

    bu_vls_printf(&dmp->dm_tkName, "%s",
		  (char *)Tk_Name(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

    bu_vls_init(&str);
    bu_vls_printf(&str, "_init_dm %S %S\n",
		  &init_proc_vls,
		  &dmp->dm_pathName);

    if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
	bu_vls_free(&str);
	(void)tk_close(dmp);

	return DM_NULL;
    }

    bu_vls_free(&init_proc_vls);
    bu_vls_free(&str);

    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy =
	Tk_Display(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top);
    dpy = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy;

    /* make sure there really is a display before proceeding. */
    if (!dpy) {
	(void)tk_close(dmp);
	return DM_NULL;
    }

    if(dmp->dm_width == 0){
	dmp->dm_width =
	    WidthOfScreen(Tk_Screen((
				     (struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)) - 30;
	++make_square;
    }

    if(dmp->dm_height == 0){
	dmp->dm_height =
	    HeightOfScreen(Tk_Screen((
				      (struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)) - 30;
	++make_square;
    }

    if(make_square > 0){
	/* Make window square */
	if(dmp->dm_height <
	   dmp->dm_width)
	    dmp->dm_width = dmp->dm_height;
	else
	    dmp->dm_height = dmp->dm_width;
    }

    Tk_GeometryRequest(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
		       dmp->dm_width,
		       dmp->dm_height);

#if 0
    /*XXX For debugging purposes */
    XSynchronize(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 1);

    /* must do this before MakeExist */
    if((((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip = Tk_choose_visual(dmp)) == NULL){
	bu_log("Tk_open: Can't get an appropriate visual.\n");
	(void)tk_close(dmp);
	return DM_NULL;
    }

#endif

    Tk_MakeWindowExist(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win =
	Tk_WindowId(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
    dmp->dm_id = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win;

    ((struct x_vars *)dmp->dm_vars.priv_vars)->pix =
	Tk_GetPixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     DefaultRootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy),
		     dmp->dm_width,
		     dmp->dm_height,
		     Tk_Depth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

    XColor fg, bg;

    fg.red = 65535;
    fg.green = fg.blue = 0;

    ((struct x_vars *)dmp->dm_vars.priv_vars)->fg =
	Tk_GetColorByValue(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
			   &fg)->pixel;

    bg.red = bg.green = bg.blue = 3277;

    ((struct x_vars *)dmp->dm_vars.priv_vars)->bg =
	Tk_GetColorByValue(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
			   &bg)->pixel;

    gcv.background = ((struct x_vars *)dmp->dm_vars.priv_vars)->bg;
    gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->fg;

    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc =
	Tk_GetGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
		 (GCForeground|GCBackground), &gcv);


#if HAVE_X
#ifdef HAVE_XQUERYEXTENSION
    /* First see if the server supports XInputExtension */
    {
	int return_val;

	if(!XQueryExtension(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			    "XInputExtension", &return_val, &return_val, &return_val))
	    goto Skip_dials;
    }
#endif

#if USE_DIALS_AND_BUTTONS
    /*
     * Take a look at the available input devices. We're looking
     * for "dial+buttons".
     */
    if (XQueryExtension(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, "XInputExtension", &unused, &unused, &unused)) {
	olist = list = (XDeviceInfoPtr)XListInputDevices(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, &ndevices);
    }

    if( list == (XDeviceInfoPtr)NULL ||
	list == (XDeviceInfoPtr)1 )  goto Done;

    for(j = 0; j < ndevices; ++j, list++){
	if(list->use == IsXExtensionDevice){
	    if(!strcmp(list->name, "dial+buttons")){
		if((dev = XOpenDevice(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				      list->id)) == (XDevice *)NULL){
		    bu_log("Tk_open: Couldn't open the dials+buttons\n");
		    goto Done;
		}

		for(cip = dev->classes, k = 0; k < dev->num_classes;
		    ++k, ++cip){
		    switch(cip->input_class){
#if IR_BUTTONS
			case ButtonClass:
			    DeviceButtonPress(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress,
					      e_class[nclass]);
			    ++nclass;
			    DeviceButtonRelease(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease,
						e_class[nclass]);
			    ++nclass;
			    break;
#endif
#if IR_KNOBS
			case ValuatorClass:
			    DeviceMotionNotify(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify,
					       e_class[nclass]);
			    ++nclass;
			    break;
#endif /*USE_DIALS_AND_BUTTONS*/
#endif /*HAVE_X*/
			default:
			    break;
		    }
		}

		XSelectExtensionEvent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, e_class, nclass);
		goto Done;
	    }
	}
    }
 Done:
    XFreeDeviceList(olist);
#endif

 Skip_dials:
    (void)tk_configureWin_guts(dmp, 1);

    /*
      Tk_SetWindowBackground(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
      ((struct x_vars *)dmp->dm_vars.priv_vars)->bg);
    */
    Tk_MapWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

    MAT_IDN(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat);

    return dmp;
}

/**
 *  @@proc tk_close
 *
 *  Gracefully release the display.
 */
HIDDEN int
tk_close(struct dm *dmp)
{
    if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy){
	if(((struct x_vars *)dmp->dm_vars.priv_vars)->gc)
	    Tk_FreeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc);

	if(((struct x_vars *)dmp->dm_vars.priv_vars)->pix)
	    Tk_FreePixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  ((struct x_vars *)dmp->dm_vars.priv_vars)->pix);

	/*XXX Possibly need to free the colormap */
	if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)
	    XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);

	if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)
	    Tk_DestroyWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

    }

    bu_vls_free(&dmp->dm_pathName);
    bu_vls_free(&dmp->dm_tkName);
    bu_vls_free(&dmp->dm_dName);
    bu_free(dmp->dm_vars.priv_vars, "tk_close: tk_vars");
    bu_free(dmp->dm_vars.pub_vars, "tk_close: dm_tkvars");
    bu_free(dmp, "tk_close: dmp");

    return TCL_OK;
}

/**
 * @@proc tk_drawBegin
 * This white-washes the dm's pixmap with the background color.
 */
HIDDEN int
tk_drawBegin(struct dm *dmp)
{
    XGCValues       gcv;

    if (dmp->dm_debugLevel)
	bu_log("tk_drawBegin()\n");

    /* clear pixmap */
    gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->bg;
    XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	      GCForeground, &gcv);
    XFillRectangle(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, 0,
		   0, dmp->dm_width + 1,
		   dmp->dm_height + 1);

    /* reset foreground */

    gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->fg;
    XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	      GCForeground, &gcv);

    return TCL_OK;
}

/**
 *  tk_drawEnd
 *  This copies the pixmap into the window.
 */
HIDDEN int
tk_drawEnd(struct dm *dmp)
{
    if (dmp->dm_debugLevel)
	bu_log("tk_drawEnd()\n");

    XCopyArea(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	      0, 0, dmp->dm_width,
	      dmp->dm_height, 0, 0);


    /* Prevent lag between events and updates */
    XSync(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 0);

    return TCL_OK;
}

/**
 * @@proc tk_loadMatrix
 *
 *  Load a new transformation matrix.  This will be followed by
 *  many calls to tk_drawVList().
 */
/* ARGSUSED */
HIDDEN int
tk_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
{
    if(dmp->dm_debugLevel){
	bu_log("tk_loadMatrix()\n");

	bu_log("which eye = %d\t", which_eye);
	bu_log("transformation matrix = \n");
#if 1
	bu_log("%g %g %g %g\n", mat[0], mat[1], mat[2], mat[3]);
	bu_log("%g %g %g %g\n", mat[4], mat[5], mat[6], mat[7]);
	bu_log("%g %g %g %g\n", mat[8], mat[9], mat[10], mat[11]);
	bu_log("%g %g %g %g\n", mat[12], mat[13], mat[14], mat[15]);
#else
	bu_log("%g %g %g %g\n", mat[0], mat[4], mat[8], mat[12]);
	bu_log("%g %g %g %g\n", mat[1], mat[5], mat[9], mat[13]);
	bu_log("%g %g %g %g\n", mat[2], mat[6], mat[10], mat[14]);
	bu_log("%g %g %g %g\n", mat[3], mat[7], mat[11], mat[15]);
#endif
    }

    MAT_COPY(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, mat);
    return TCL_OK;
}

/**
 * tk_drawVList
 *
 */

HIDDEN int
tk_drawVList(struct dm *dmp, register struct bn_vlist *vp)
{
#if 1
    static vect_t			spnt, lpnt, pnt;
    register struct bn_vlist	*tvp;
    XSegment			segbuf[1024];		/* XDrawSegments list */
    XSegment			*segp;			/* current segment */
    int				nseg;		        /* number of segments */
    fastf_t				delta;
    register point_t		*pt_prev = NULL;
    fastf_t				dist_prev=1.0;
    static int			nvectors = 0;

    if (dmp->dm_debugLevel) {
	bu_log("tk_drawVList()\n");
	bu_log("vp - %lu, perspective - %d\n", vp, dmp->dm_perspective);
    }

    /* delta is used in clipping to insure clipped endpoint is slightly
     * in front of eye plane (perspective mode only).
     * This value is a SWAG that seems to work OK.
     */
    delta = ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15]*0.0001;
    if (delta < 0.0)
	delta = -delta;
    if (delta < SQRT_SMALL_FASTF)
	delta = SQRT_SMALL_FASTF;

    nseg = 0;
    segp = segbuf;
    for (BU_LIST_FOR(tvp, bn_vlist, &vp->l)) {
	register int	i;
	register int	nused = tvp->nused;
	register int	*cmd = tvp->cmd;
	register point_t *pt = tvp->pt;
	fastf_t 	 dist;

	/* Viewing region is from -1.0 to +1.0 */
	/* 2^31 ~= 2e9 -- dynamic range of a long int */
	/* 2^(31-11) = 2^20 ~= 1e6 */
	/* Integerize and let the X server do the clipping */
	for (i = 0; i < nused; i++,cmd++,pt++) {
	    switch (*cmd) {
		case BN_VLIST_POLY_START:

		case BN_VLIST_POLY_VERTNORM:
		    continue;
		case BN_VLIST_POLY_MOVE:
		case BN_VLIST_LINE_MOVE:
		    /* Move, not draw */
		    if (dmp->dm_debugLevel > 2) {
			bu_log("before transformation:\n");
			bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
		    }

		    if (dmp->dm_perspective > 0) {
			/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
			 */
			dist = VDOT(*pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12]) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
			if (dist <= 0.0) {
			    pt_prev = pt;
			    dist_prev = dist;
			    continue;
			} else {
			    MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
			    dist_prev = dist;
			    pt_prev = pt;
			}
		    } else {
			MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
		    }

		    lpnt[0] *= 2047;
		    lpnt[1] *= 2047 * dmp->dm_aspect;
		    lpnt[2] *= 2047;
		    continue;
		case BN_VLIST_POLY_DRAW:
		case BN_VLIST_POLY_END:
		case BN_VLIST_LINE_DRAW:
		    /* draw */
		    if (dmp->dm_debugLevel > 2) {
			bu_log("before transformation:\n");
			bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
		    }

		    if (dmp->dm_perspective > 0) {
			/* cannot apply perspective transformation to
			 * points behind eye plane!!!!
			 */
			dist = VDOT( *pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12] ) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
			if (dmp->dm_debugLevel > 2)
			    bu_log( "dist=%g, dist_prev=%g\n", dist, dist_prev );
			if (dist <= 0.0) {
			    if (dist_prev <= 0.0) {
				/* nothing to plot */
				dist_prev = dist;
				pt_prev = pt;
				continue;
			    } else {
				fastf_t alpha;
				vect_t diff;
				point_t tmp_pt;

				/* clip this end */
				VSUB2(diff, *pt, *pt_prev);
				alpha = (dist_prev - delta) / (dist_prev - dist);
				VJOIN1(tmp_pt, *pt_prev, alpha, diff);
				MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
			    }
			} else {
			    if (dist_prev <= 0.0) {
				fastf_t alpha;
				vect_t diff;
				point_t tmp_pt;

				/* clip other end */
				VSUB2(diff, *pt, *pt_prev);
				alpha = (-dist_prev + delta) / (dist - dist_prev);
				VJOIN1(tmp_pt, *pt_prev, alpha, diff);
				MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
				lpnt[0] *= 2047;
				lpnt[1] *= 2047 * dmp->dm_aspect;
				lpnt[2] *= 2047;
				MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
			    } else {
				MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
			    }
			}
			dist_prev = dist;
		    } else {
			MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
		    }

		    pnt[0] *= 2047;
		    pnt[1] *= 2047 * dmp->dm_aspect;
		    pnt[2] *= 2047;

		    /* save pnt --- it might get changed by clip() */
		    VMOVE(spnt, pnt);
		    pt_prev = pt;

		    if (dmp->dm_debugLevel > 2) {
			bu_log("before clipping:\n");
			bu_log("clipmin - %lf %lf %lf\n",
			       dmp->dm_clipmin[X],
			       dmp->dm_clipmin[Y],
			       dmp->dm_clipmin[Z]);
			bu_log("clipmax - %lf %lf %lf\n",
			       dmp->dm_clipmax[X],
			       dmp->dm_clipmax[Y],
			       dmp->dm_clipmax[Z]);
			bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
			bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
		    }

		    if (dmp->dm_zclip) {
			if (vclip(lpnt, pnt,
				  dmp->dm_clipmin,
				  dmp->dm_clipmax) == 0) {
			    VMOVE(lpnt, spnt);
			    continue;
			}
		    } else {
			/* Check to see if lpnt or pnt contain values that exceed
			   the capacity of a short (segbuf is an array of XSegments which
			   contain shorts). If so, do clipping now. Otherwise, let the
			   X server do the clipping */
			if (lpnt[0] < min_short || max_short < lpnt[0] ||
			    lpnt[1] < min_short || max_short < lpnt[1] ||
			    pnt[0] < min_short || max_short < pnt[0] ||
			    pnt[1] < min_short || max_short < pnt[1]) {
			    /* if the entire line segment will not be visible then ignore it */
			    if (clip(&lpnt[0], &lpnt[1], &pnt[0], &pnt[1]) == -1) {
				VMOVE(lpnt, spnt);
				continue;
			    }
			}
		    }

		    if (dmp->dm_debugLevel > 2) {
			bu_log("after clipping:\n");
			bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
			bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
		    }

		    /* convert to X window coordinates */
		    segp->x1 = (short)GED_TO_Xx(dmp, lpnt[0]);
		    segp->y1 = (short)GED_TO_Xy(dmp, lpnt[1]);
		    segp->x2 = (short)GED_TO_Xx(dmp, pnt[0]);
		    segp->y2 = (short)GED_TO_Xy(dmp, pnt[1]);

		    nseg++;
		    segp++;
		    VMOVE(lpnt, spnt);

		    if (nseg == 1024) {
			XDrawSegments(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
				      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg);

			nseg = 0;
			segp = segbuf;
		    }
		    break;
	    }
	}

	nvectors += nused;
	if (nvectors >= vectorThreshold) {
	    if (dmp->dm_debugLevel)
		bu_log("tk_drawVList(): handle Tcl events\n");

	    nvectors = 0;

	    /* Handle events in the queue */
	    while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
	}
    }

    if (nseg) {
	XDrawSegments( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg );
    }

#endif
    return TCL_OK;
}

/*
 *			X _ N O R M A L
 *
 * Restore the display processor to a normal mode of operation
 * (ie, not scaled, rotated, displaced, etc).
 */
HIDDEN int
tk_normal(struct dm *dmp)
{
    if (dmp->dm_debugLevel)
	bu_log("tk_normal()\n");

    return TCL_OK;
}

/*
 *			X _ D R A W S T R I N G 2 D
 *
 * Output a string into the displaylist.
 * The starting position of the beam is as specified.
 */
/* ARGSUSED */
HIDDEN int
tk_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
{
    int sx, sy;

    if (dmp->dm_debugLevel){
	bu_log("tk_drawString2D():\n");
	bu_log("\tstr - %s\n", str);
	bu_log("\tx - %g\n", x);
	bu_log("\ty - %g\n", y);
	bu_log("\tsize - %d\n", size);

	bu_log("color = %d\n", ((struct x_vars *)dmp->dm_vars.priv_vars)->fg);
	/*  bu_log("real_color = %d\n", ((struct x_vars *)dmp->dm_vars.priv_vars)->gc->foreground); */

	if(use_aspect){
	    bu_log("\tuse_aspect - %d\t\taspect ratio - %g\n", use_aspect, dmp->dm_aspect);
	}else
	    bu_log("\tuse_aspect - 0");
    }

    sx = dm_Normal2Xx(dmp, x);
    sy = dm_Normal2Xy(dmp, y, use_aspect);


    Tk_DrawChars(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		 ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
		 ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct,
		 str, strlen(str), sx, sy);

    return TCL_OK;
}

HIDDEN int
tk_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
{
    int	sx1, sy1, sx2, sy2;

    sx1 = dm_Normal2Xx(dmp, x1);
    sx2 = dm_Normal2Xx(dmp, x2);
    sy1 = dm_Normal2Xy(dmp, y1, 0);
    sy2 = dm_Normal2Xy(dmp, y2, 0);

    if (dmp->dm_debugLevel) {
	bu_log("tk_drawLine2D()\n");
	bu_log("x1 = %g, y1 = %g\n", x1, y1);
	bu_log("x2 = %g, y2 = %g\n", x2, y2);
	bu_log("sx1 = %d, sy1 = %d\n", sx1, sy1);
	bu_log("sx2 = %d, sy2 = %d\n", sx2, sy2);
	bu_log("color = %d\n", ((struct x_vars *)dmp->dm_vars.priv_vars)->fg);
    }

    XDrawLine( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	       sx1, sy1, sx2, sy2 );

    return TCL_OK;
}

HIDDEN int
tk_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
{
    int   sx, sy;

    sx = dm_Normal2Xx(dmp, x);
    sy = dm_Normal2Xy(dmp, y, 0);

    if (dmp->dm_debugLevel) {
	bu_log("tk_drawPoint2D()\n");
	bu_log("x = %g, y = %g\n", x, y);
	bu_log("sx = %d, sy = %d\n", sx, sy);
    }

    XDrawPoint( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		((struct x_vars *)dmp->dm_vars.priv_vars)->gc, sx, sy );

    return TCL_OK;
}

HIDDEN int
tk_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency)
{
    XGCValues gcv;

    if (dmp->dm_debugLevel)
	bu_log("tk_setFGColor( %d %d %d)\n", r, g, b);

    dmp->dm_fg[0] = r;
    dmp->dm_fg[1] = g;
    dmp->dm_fg[2] = b;

    XColor color;

    color.red = r << 8;
    color.green = g << 8;
    color.blue = b << 8;

    ((struct x_vars *)dmp->dm_vars.priv_vars)->fg = Tk_GetColorByValue
	(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, &color)->pixel;

    XSetForeground(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->fg);

    return TCL_OK;
}

HIDDEN int
tk_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
{
    if (dmp->dm_debugLevel)
	bu_log("tk_setBGColor()\n");

    dmp->dm_bg[0] = r;
    dmp->dm_bg[1] = g;
    dmp->dm_bg[2] = b;


    XColor color;

    color.red = r << 8;
    color.green = g << 8;
    color.blue = b << 8;

    XSetBackground(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		   ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
		   Tk_GetColorByValue(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
				      &color)->pixel);

    return TCL_OK;
}

HIDDEN int
tk_setLineAttr(struct dm *dmp, int width, int style)
{
    int linestyle;

    if (dmp->dm_debugLevel)
	bu_log("tk_setLineAttr( width: %d, style: %d)\n", width, style);

    dmp->dm_lineWidth = width;
    dmp->dm_lineStyle = style;

    if(width < 1)
	width = 1;

    if(style == DM_DASHED_LINE)
	linestyle = LineOnOffDash;
    else
	linestyle = LineSolid;

    XSetLineAttributes( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
			width, linestyle, CapButt, JoinMiter );

    return TCL_OK;
}

/* ARGSUSED */
HIDDEN int
tk_debug(struct dm *dmp, int lvl)
{
    dmp->dm_debugLevel = lvl;

    return TCL_OK;
}

HIDDEN int
tk_setWinBounds(struct dm *dmp, register int *w)
{
    if (dmp->dm_debugLevel)
	bu_log("tk_setWinBounds()\n");

    dmp->dm_clipmin[0] = w[0];
    dmp->dm_clipmin[1] = w[2];
    dmp->dm_clipmin[2] = w[4];
    dmp->dm_clipmax[0] = w[1];
    dmp->dm_clipmax[1] = w[3];
    dmp->dm_clipmax[2] = w[5];

    return TCL_OK;
}

HIDDEN int
tk_configureWin_guts(struct dm *dmp, int force)
{
    XFontStruct     *newfontstruct;
    XGCValues       gcv;
    int h, w;

    /* nothing to do */
    h = Tk_Height(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
    w = Tk_Width(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

    if (!force && dmp->dm_width==w && dmp->dm_height == h)
	return TCL_OK;

    dmp->dm_width=w;
    dmp->dm_width=h;

    dmp->dm_aspect = (fastf_t)dmp->dm_width / (fastf_t)dmp->dm_height;

    if (dmp->dm_debugLevel) {
	bu_log("tk_configureWin_guts()\n");
	bu_log("width = %d, height = %d\n", dmp->dm_width, dmp->dm_height);
    }

    Tk_FreePixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		  ((struct x_vars *)dmp->dm_vars.priv_vars)->pix);
    ((struct x_vars *)dmp->dm_vars.priv_vars)->pix =
	Tk_GetPixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     DefaultRootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy),
		     dmp->dm_width,
		     dmp->dm_height,
		     Tk_Depth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

    /* First time through, load a font or quit */
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontset == 0) {

	((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct =
	    Tk_GetFont(dmp->dm_interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, FONT9);

	if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct == NULL) {
	    /* Try hardcoded backup font */

	    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct =
		Tk_GetFont(dmp->dm_interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, FONTBACK);

	    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct == NULL) {
		bu_log("dm-Tk: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
		return TCL_ERROR;
	    }
	}
	((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontset = 1;
    }

    /* XXX:  I removed the font-sizing routine from dm-X from here.  Something
       should be devised to replace it.  --TJM*/

    return TCL_OK;
}

HIDDEN int
tk_configureWin(struct dm *dmp)
{
    /* don't force */
    return tk_configureWin_guts(dmp, 0);
}

HIDDEN int
tk_setLight(struct dm *dmp, int light_on)
{
    if (dmp->dm_debugLevel)
	bu_log("tk_setLight:\n");

    dmp->dm_light = light_on;

    return TCL_OK;
}

HIDDEN int
tk_setZBuffer(struct dm *dmp, int zbuffer_on)
{
    if (dmp->dm_debugLevel)
	bu_log("tk_setZBuffer:\n");

    dmp->dm_zbuffer = zbuffer_on;

    return TCL_OK;
}

#endif /* DM_TK */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.13
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@a493 1
#ifndef CRAY2
d495 1
a495 1
#endif
@


14.12
log
@credit tim, ws
@
text
@d44 1
a44 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.12.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d44 5
a48 1
#include <string.h>
@


14.11
log
@ws
@
text
@d25 3
a34 1
 *
a35 3
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.10 2007/05/14 19:12:03 brlcad Exp $ (BRL)";
#endif
d1170 1
a1170 1
#endif
@


14.10
log
@Tk_DrawChars takes a Tk_Font, not a Tk_Font*, quell warnings by making the display have exactly what Tk_GetFont() returns instead of a pointer.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.9 2007/04/23 13:30:19 joevalleyfield Exp $ (BRL)";
d111 55
a165 55
  tk_close,
  tk_drawBegin,
  tk_drawEnd,
  tk_normal,
  tk_loadMatrix,
  tk_drawString2D,
  tk_drawLine2D,
  tk_drawPoint2D,
  tk_drawVList,
  tk_setFGColor,
  tk_setBGColor,
  tk_setLineAttr,
  tk_configureWin,
  tk_setWinBounds,
  tk_setLight,
  Nu_int0,
  Nu_int0,
  tk_setZBuffer,
  tk_debug,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  Nu_int0,
  0,
  0,				/* no displaylist */
  0,                            /* no stereo */
  PLOTBOUND,			/* zoom-in limit */
  1,				/* bound flag */
  "Tk",
  "Tk Abstraction Layer",
  DM_TYPE_TK,
  1,
  0,
  0,
  0,
  0,
  1.0, /* aspect ratio */
  0,
  {0, 0},
  {0, 0, 0, 0, 0},		/* bu_vls path name*/
  {0, 0, 0, 0, 0},		/* bu_vls full name drawing window */
  {0, 0, 0, 0, 0},		/* bu_vls short name drawing window */
  {0, 0, 0},			/* bg color */
  {0, 0, 0},			/* fg color */
  {GED_MIN, GED_MIN, GED_MIN},	/* clipmin */
  {GED_MAX, GED_MAX, GED_MAX},	/* clipmax */
  0,				/* no debugging */
  0,				/* no perspective */
  0,				/* no lighting */
  0,				/* no transparency */
  0,				/* depth buffer is not writable */
  0,				/* no zbuffer */
  0,				/* no zclipping */
  1,                            /* clear back buffer after drawing and swap */
  0				/* Tcl interpreter */
d176 2
a177 2
	Status st;
	XColor rgb;
d181 1
a181 1
	rgb = *color;
d183 2
a184 2
	st = XAllocColor(dpy, cmap, color);
	switch (st) {
d187 6
a192 6
		if ( (color->red & CSCK) != (rgb.red & CSCK) ||
		     (color->green & CSCK) != (rgb.green & CSCK) ||
		     (color->blue & CSCK) != (rgb.blue & CSCK) ) {
			bu_log("\nlooking for fg    (%3d,%3d,%3d) %04x,%04x,%04x got \n                  (%3d,%3d,%3d) %04x,%04x,%04x\n",
			       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
			       rgb.red, rgb.green, rgb.blue,
d194 3
a196 3
			       (color->red >> 8), (color->green >> 8), (color->blue >> 8),
			       color->red, color->green, color->blue);
		}
d198 1
a198 1
		break;
d200 4
a203 4
		bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n",
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue);
		break;
d206 5
a210 5
		bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n",
		       (rgb.red >> 8), (rgb.green >> 8), (rgb.blue >> 8),
		       rgb.red, rgb.green, rgb.blue);
		break;
	}
d224 33
a256 48
  static int count = 0;
  int make_square = -1;
  XGCValues gcv;

  struct bu_vls str;
  struct bu_vls init_proc_vls;
  struct dm *dmp = (struct dm *)NULL;
  Tk_Window tkwin;
  Display *dpy = (Display *)NULL;

  if ((tkwin = Tk_MainWindow(interp)) == NULL) {
      return DM_NULL;
  }

  BU_GETSTRUCT(dmp, dm);
  if(dmp == DM_NULL)
    return DM_NULL;

  *dmp = dm_tk; /* struct copy */
  dmp->dm_interp = interp;

  dmp->dm_vars.pub_vars = (genptr_t)bu_calloc(1, sizeof(struct dm_xvars), "tk_open: dm_xvars");
  if(dmp->dm_vars.pub_vars == (genptr_t)NULL){
    bu_free(dmp, "tk_open: dmp");
    return DM_NULL;
  }

  dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct tk_vars), "tk_open: tk_vars");
  if(dmp->dm_vars.priv_vars == (genptr_t)NULL){
    bu_free(dmp->dm_vars.pub_vars, "tk_open: dmp->dm_vars.pub_vars");
    bu_free(dmp, "tk_open: dmp");
    return DM_NULL;
  }

  bu_vls_init(&dmp->dm_pathName);
  bu_vls_init(&dmp->dm_tkName);
  bu_vls_init(&dmp->dm_dName);
  bu_vls_init(&init_proc_vls);

  dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);

  if(bu_vls_strlen(&dmp->dm_pathName) == 0) {
      bu_vls_printf(&dmp->dm_pathName, ".dm_tk%d", count);
  }

  ++count;
  if(bu_vls_strlen(&dmp->dm_dName) == 0){
    char *dp;
d258 4
a261 1
    dp = DisplayString(Tk_Display(tkwin));
d263 34
a296 28
    if(dp)
      bu_vls_strcpy(&dmp->dm_dName, dp);
    else
      bu_vls_strcpy(&dmp->dm_dName, ":0.0");
  }
  if(bu_vls_strlen(&init_proc_vls) == 0)
    bu_vls_strcpy(&init_proc_vls, "bind_dm");

  /* initialize dm specific variables */
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify = LASTEvent;
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress = LASTEvent;
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease = LASTEvent;
  dmp->dm_aspect = 1.0;

  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontset = 0;

  if(dmp->dm_top){
    /* Make xtkwin a toplevel window */
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin = Tk_CreateWindowFromPath(interp, tkwin,
						      bu_vls_addr(&dmp->dm_pathName),
						      bu_vls_addr(&dmp->dm_dName));
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin;
  }else{
    char *cp;

    cp = strrchr(bu_vls_addr(&dmp->dm_pathName), (int)'.');
    if(cp == bu_vls_addr(&dmp->dm_pathName)){
      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top = tkwin;
d298 15
a312 1
      struct bu_vls top_vls;
d314 5
a318 27
      bu_vls_init(&top_vls);
      bu_vls_printf(&top_vls, "%*s", cp - bu_vls_addr(&dmp->dm_pathName),
		    bu_vls_addr(&dmp->dm_pathName));
      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top =
	Tk_NameToWindow(interp, bu_vls_addr(&top_vls), tkwin);
      bu_vls_free(&top_vls);
    }

    /* Make xtkwin an embedded window */
    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin =
      Tk_CreateWindow(interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->top,
		      cp + 1, (char *)NULL);
  }

  if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin == NULL){
    bu_log("tk_open: Failed to open %s\n", bu_vls_addr(&dmp->dm_pathName));
    (void)tk_close(dmp);
    return DM_NULL;
  }

  bu_vls_printf(&dmp->dm_tkName, "%s",
		(char *)Tk_Name(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  bu_vls_init(&str);
  bu_vls_printf(&str, "_init_dm %S %S\n",
		&init_proc_vls,
		&dmp->dm_pathName);
d320 22
a341 1
  if(Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR){
a342 1
    (void)tk_close(dmp);
d344 16
a359 2
    return DM_NULL;
  }
d361 6
a366 2
  bu_vls_free(&init_proc_vls);
  bu_vls_free(&str);
d368 8
a375 32
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy =
    Tk_Display(((struct dm_xvars *)dmp->dm_vars.pub_vars)->top);
  dpy = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy;

  /* make sure there really is a display before proceeding. */
  if (!dpy) {
      (void)tk_close(dmp);
      return DM_NULL;
  }

  if(dmp->dm_width == 0){
    dmp->dm_width =
      WidthOfScreen(Tk_Screen((
	(struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)) - 30;
    ++make_square;
  }

  if(dmp->dm_height == 0){
    dmp->dm_height =
      HeightOfScreen(Tk_Screen((
	(struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)) - 30;
    ++make_square;
  }

  if(make_square > 0){
    /* Make window square */
    if(dmp->dm_height <
       dmp->dm_width)
      dmp->dm_width = dmp->dm_height;
    else
      dmp->dm_height = dmp->dm_width;
  }
d377 3
a379 3
  Tk_GeometryRequest(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
		     dmp->dm_width,
		     dmp->dm_height);
d382 2
a383 2
  /*XXX For debugging purposes */
  XSynchronize(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 1);
d385 6
a390 6
  /* must do this before MakeExist */
  if((((struct dm_xvars *)dmp->dm_vars.pub_vars)->vip = Tk_choose_visual(dmp)) == NULL){
    bu_log("Tk_open: Can't get an appropriate visual.\n");
    (void)tk_close(dmp);
    return DM_NULL;
  }
d394 11
a404 11
  Tk_MakeWindowExist(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win =
      Tk_WindowId(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  dmp->dm_id = ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win;

  ((struct x_vars *)dmp->dm_vars.priv_vars)->pix =
    Tk_GetPixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 DefaultRootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy),
		 dmp->dm_width,
		 dmp->dm_height,
		 Tk_Depth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));
d413 1
a413 1
	&fg)->pixel;
d419 1
a419 1
	&bg)->pixel;
d421 2
a422 2
  gcv.background = ((struct x_vars *)dmp->dm_vars.priv_vars)->bg;
  gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->fg;
d424 3
a426 3
  ((struct x_vars *)dmp->dm_vars.priv_vars)->gc =
    Tk_GetGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
    (GCForeground|GCBackground), &gcv);
d431 8
a438 8
  /* First see if the server supports XInputExtension */
  {
    int return_val;

    if(!XQueryExtension(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		     "XInputExtension", &return_val, &return_val, &return_val))
      goto Skip_dials;
  }
d442 19
a460 19
  /*
   * Take a look at the available input devices. We're looking
   * for "dial+buttons".
   */
  if (XQueryExtension(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, "XInputExtension", &unused, &unused, &unused)) {
      olist = list = (XDeviceInfoPtr)XListInputDevices(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, &ndevices);
  }

  if( list == (XDeviceInfoPtr)NULL ||
      list == (XDeviceInfoPtr)1 )  goto Done;

  for(j = 0; j < ndevices; ++j, list++){
    if(list->use == IsXExtensionDevice){
      if(!strcmp(list->name, "dial+buttons")){
	if((dev = XOpenDevice(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      list->id)) == (XDevice *)NULL){
	  bu_log("Tk_open: Couldn't open the dials+buttons\n");
	  goto Done;
	}
d462 3
a464 3
	for(cip = dev->classes, k = 0; k < dev->num_classes;
	    ++k, ++cip){
	  switch(cip->input_class){
d466 8
a473 8
	  case ButtonClass:
	    DeviceButtonPress(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonpress,
			      e_class[nclass]);
	    ++nclass;
	    DeviceButtonRelease(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devbuttonrelease,
				e_class[nclass]);
	    ++nclass;
	    break;
d476 5
a480 5
	  case ValuatorClass:
	    DeviceMotionNotify(dev, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->devmotionnotify,
			       e_class[nclass]);
	    ++nclass;
	    break;
d483 9
a491 3
	  default:
	    break;
	  }
d493 3
a495 9

	XSelectExtensionEvent(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, e_class, nclass);
	goto Done;
      }
    }
  }
Done:
  XFreeDeviceList(olist);
d498 1
a498 1
Skip_dials:
d500 1
a500 1
  (void)tk_configureWin_guts(dmp, 1);
d502 5
a506 5
/*
  Tk_SetWindowBackground(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
			 ((struct x_vars *)dmp->dm_vars.priv_vars)->bg);
*/
  Tk_MapWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
d508 1
a508 1
  MAT_IDN(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat);
d510 1
a510 1
  return dmp;
d521 25
a545 25
  if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy){
    if(((struct x_vars *)dmp->dm_vars.priv_vars)->gc)
      Tk_FreeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc);

    if(((struct x_vars *)dmp->dm_vars.priv_vars)->pix)
      Tk_FreePixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    ((struct x_vars *)dmp->dm_vars.priv_vars)->pix);

    /*XXX Possibly need to free the colormap */
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap)
      XFreeColormap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->cmap);

    if(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)
      Tk_DestroyWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

  }

  bu_vls_free(&dmp->dm_pathName);
  bu_vls_free(&dmp->dm_tkName);
  bu_vls_free(&dmp->dm_dName);
  bu_free(dmp->dm_vars.priv_vars, "tk_close: tk_vars");
  bu_free(dmp->dm_vars.pub_vars, "tk_close: dm_tkvars");
  bu_free(dmp, "tk_close: dmp");
d547 1
a547 1
  return TCL_OK;
d557 1
a557 1
  XGCValues       gcv;
d559 2
a560 2
  if (dmp->dm_debugLevel)
    bu_log("tk_drawBegin()\n");
d562 10
a571 10
  /* clear pixmap */
  gcv.foreground = ((struct x_vars *)dmp->dm_vars.priv_vars)->bg;
  XChangeGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	    GCForeground, &gcv);
  XFillRectangle(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
		 ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, 0,
		 0, dmp->dm_width + 1,
		 dmp->dm_height + 1);
d573 1
a573 1
  /* reset foreground */
d577 2
a578 2
	((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	GCForeground, &gcv);
d580 1
a580 1
  return TCL_OK;
d590 2
a591 2
  if (dmp->dm_debugLevel)
    bu_log("tk_drawEnd()\n");
d593 4
a596 4
  XCopyArea(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win,
	    ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
d598 1
a598 1
	    dmp->dm_height, 0, 0);
d601 2
a602 2
  /* Prevent lag between events and updates */
  XSync(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy, 0);
d604 1
a604 1
  return TCL_OK;
d617 2
a618 2
  if(dmp->dm_debugLevel){
    bu_log("tk_loadMatrix()\n");
d620 2
a621 2
    bu_log("which eye = %d\t", which_eye);
    bu_log("transformation matrix = \n");
d623 4
a626 4
    bu_log("%g %g %g %g\n", mat[0], mat[1], mat[2], mat[3]);
    bu_log("%g %g %g %g\n", mat[4], mat[5], mat[6], mat[7]);
    bu_log("%g %g %g %g\n", mat[8], mat[9], mat[10], mat[11]);
    bu_log("%g %g %g %g\n", mat[12], mat[13], mat[14], mat[15]);
d628 4
a631 4
    bu_log("%g %g %g %g\n", mat[0], mat[4], mat[8], mat[12]);
    bu_log("%g %g %g %g\n", mat[1], mat[5], mat[9], mat[13]);
    bu_log("%g %g %g %g\n", mat[2], mat[6], mat[10], mat[14]);
    bu_log("%g %g %g %g\n", mat[3], mat[7], mat[11], mat[15]);
d633 1
a633 1
  }
d635 2
a636 2
  MAT_COPY(((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, mat);
  return TCL_OK;
d648 14
a661 14
	static vect_t			spnt, lpnt, pnt;
	register struct bn_vlist	*tvp;
	XSegment			segbuf[1024];		/* XDrawSegments list */
	XSegment			*segp;			/* current segment */
	int				nseg;		        /* number of segments */
	fastf_t				delta;
	register point_t		*pt_prev = NULL;
	fastf_t				dist_prev=1.0;
	static int			nvectors = 0;

	if (dmp->dm_debugLevel) {
		bu_log("tk_drawVList()\n");
		bu_log("vp - %lu, perspective - %d\n", vp, dmp->dm_perspective);
	}
d663 80
a742 28
	/* delta is used in clipping to insure clipped endpoint is slightly
	 * in front of eye plane (perspective mode only).
	 * This value is a SWAG that seems to work OK.
	 */
	delta = ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15]*0.0001;
	if (delta < 0.0)
		delta = -delta;
	if (delta < SQRT_SMALL_FASTF)
		delta = SQRT_SMALL_FASTF;

	nseg = 0;
	segp = segbuf;
	for (BU_LIST_FOR(tvp, bn_vlist, &vp->l)) {
		register int	i;
		register int	nused = tvp->nused;
		register int	*cmd = tvp->cmd;
		register point_t *pt = tvp->pt;
		fastf_t 	 dist;

		/* Viewing region is from -1.0 to +1.0 */
		/* 2^31 ~= 2e9 -- dynamic range of a long int */
		/* 2^(31-11) = 2^20 ~= 1e6 */
		/* Integerize and let the X server do the clipping */
		for (i = 0; i < nused; i++,cmd++,pt++) {
			switch (*cmd) {
			case BN_VLIST_POLY_START:

			case BN_VLIST_POLY_VERTNORM:
d744 22
a765 26
			case BN_VLIST_POLY_MOVE:
			case BN_VLIST_LINE_MOVE:
				/* Move, not draw */
				if (dmp->dm_debugLevel > 2) {
					bu_log("before transformation:\n");
					bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
				}

				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT(*pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12]) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
					if (dist <= 0.0) {
						pt_prev = pt;
						dist_prev = dist;
						continue;
					} else {
						MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						dist_prev = dist;
						pt_prev = pt;
					}
				} else {
					MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
				}

d769 51
d821 3
a823 60
			case BN_VLIST_POLY_DRAW:
			case BN_VLIST_POLY_END:
			case BN_VLIST_LINE_DRAW:
				/* draw */
				if (dmp->dm_debugLevel > 2) {
					bu_log("before transformation:\n");
					bu_log("pt - %lf %lf %lf\n", V3ARGS(*pt));
				}

				if (dmp->dm_perspective > 0) {
					/* cannot apply perspective transformation to
					 * points behind eye plane!!!!
					 */
					dist = VDOT( *pt, &((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[12] ) + ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat[15];
					if (dmp->dm_debugLevel > 2)
						bu_log( "dist=%g, dist_prev=%g\n", dist, dist_prev );
					if (dist <= 0.0) {
						if (dist_prev <= 0.0) {
							/* nothing to plot */
							dist_prev = dist;
							pt_prev = pt;
							continue;
						} else {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip this end */
							VSUB2(diff, *pt, *pt_prev);
							alpha = (dist_prev - delta) / (dist_prev - dist);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
						}
					} else {
						if (dist_prev <= 0.0) {
							fastf_t alpha;
							vect_t diff;
							point_t tmp_pt;

							/* clip other end */
							VSUB2(diff, *pt, *pt_prev);
							alpha = (-dist_prev + delta) / (dist - dist_prev);
							VJOIN1(tmp_pt, *pt_prev, alpha, diff);
							MAT4X3PNT(lpnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, tmp_pt);
							lpnt[0] *= 2047;
							lpnt[1] *= 2047 * dmp->dm_aspect;
							lpnt[2] *= 2047;
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						} else {
							MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
						}
					}
					dist_prev = dist;
				} else {
					MAT4X3PNT(pnt, ((struct x_vars *)dmp->dm_vars.priv_vars)->xmat, *pt);
				}

				pnt[0] *= 2047;
				pnt[1] *= 2047 * dmp->dm_aspect;
				pnt[2] *= 2047;
d825 27
a851 57
				/* save pnt --- it might get changed by clip() */
				VMOVE(spnt, pnt);
				pt_prev = pt;

				if (dmp->dm_debugLevel > 2) {
					bu_log("before clipping:\n");
					bu_log("clipmin - %lf %lf %lf\n",
					       dmp->dm_clipmin[X],
					       dmp->dm_clipmin[Y],
					       dmp->dm_clipmin[Z]);
					bu_log("clipmax - %lf %lf %lf\n",
					       dmp->dm_clipmax[X],
					       dmp->dm_clipmax[Y],
					       dmp->dm_clipmax[Z]);
					bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
					bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
				}

				if (dmp->dm_zclip) {
					if (vclip(lpnt, pnt,
						  dmp->dm_clipmin,
						  dmp->dm_clipmax) == 0) {
						VMOVE(lpnt, spnt);
						continue;
					}
				} else {
					/* Check to see if lpnt or pnt contain values that exceed
					   the capacity of a short (segbuf is an array of XSegments which
					   contain shorts). If so, do clipping now. Otherwise, let the
					   X server do the clipping */
					if (lpnt[0] < min_short || max_short < lpnt[0] ||
					    lpnt[1] < min_short || max_short < lpnt[1] ||
					    pnt[0] < min_short || max_short < pnt[0] ||
					    pnt[1] < min_short || max_short < pnt[1]) {
						/* if the entire line segment will not be visible then ignore it */
						if (clip(&lpnt[0], &lpnt[1], &pnt[0], &pnt[1]) == -1) {
							VMOVE(lpnt, spnt);
							continue;
						}
					}
				}

				if (dmp->dm_debugLevel > 2) {
					bu_log("after clipping:\n");
					bu_log("pt1 - %lf %lf %lf\n", lpnt[X], lpnt[Y], lpnt[Z]);
					bu_log("pt2 - %lf %lf %lf\n", pnt[X], pnt[Y], pnt[Z]);
				}

				/* convert to X window coordinates */
				segp->x1 = (short)GED_TO_Xx(dmp, lpnt[0]);
				segp->y1 = (short)GED_TO_Xy(dmp, lpnt[1]);
				segp->x2 = (short)GED_TO_Xx(dmp, pnt[0]);
				segp->y2 = (short)GED_TO_Xy(dmp, pnt[1]);

				nseg++;
				segp++;
				VMOVE(lpnt, spnt);
d853 4
a856 16
				if (nseg == 1024) {
					XDrawSegments(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
						      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg);

					nseg = 0;
					segp = segbuf;
				}
				break;
			}
		}

		nvectors += nused;
		if (nvectors >= vectorThreshold) {
			if (dmp->dm_debugLevel)
				bu_log("tk_drawVList(): handle Tcl events\n");
d858 1
a858 1
			nvectors = 0;
d860 2
a861 3
			/* Handle events in the queue */
			while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
		}
d863 1
d865 5
a869 5
	if (nseg) {
		XDrawSegments( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
			       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, segbuf, nseg );
	}
d872 1
a872 1
	return TCL_OK;
d884 2
a885 2
  if (dmp->dm_debugLevel)
    bu_log("tk_normal()\n");
d887 1
a887 1
  return TCL_OK;
d900 1
a900 1
  int sx, sy;
d902 15
a916 6
  if (dmp->dm_debugLevel){
    bu_log("tk_drawString2D():\n");
    bu_log("\tstr - %s\n", str);
    bu_log("\tx - %g\n", x);
    bu_log("\ty - %g\n", y);
    bu_log("\tsize - %d\n", size);
d918 2
a919 2
  bu_log("color = %d\n", ((struct x_vars *)dmp->dm_vars.priv_vars)->fg);
  /*  bu_log("real_color = %d\n", ((struct x_vars *)dmp->dm_vars.priv_vars)->gc->foreground); */
a920 5
    if(use_aspect){
      bu_log("\tuse_aspect - %d\t\taspect ratio - %g\n", use_aspect, dmp->dm_aspect);
    }else
      bu_log("\tuse_aspect - 0");
  }
d922 5
a926 2
  sx = dm_Normal2Xx(dmp, x);
  sy = dm_Normal2Xy(dmp, y, use_aspect);
d928 1
a928 8

  Tk_DrawChars(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	       ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	       ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	       ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct,
	       str, strlen(str), sx, sy);

  return TCL_OK;
d934 15
a948 1
  int	sx1, sy1, sx2, sy2;
d950 4
a953 18
  sx1 = dm_Normal2Xx(dmp, x1);
  sx2 = dm_Normal2Xx(dmp, x2);
  sy1 = dm_Normal2Xy(dmp, y1, 0);
  sy2 = dm_Normal2Xy(dmp, y2, 0);

  if (dmp->dm_debugLevel) {
    bu_log("tk_drawLine2D()\n");
    bu_log("x1 = %g, y1 = %g\n", x1, y1);
    bu_log("x2 = %g, y2 = %g\n", x2, y2);
    bu_log("sx1 = %d, sy1 = %d\n", sx1, sy1);
    bu_log("sx2 = %d, sy2 = %d\n", sx2, sy2);
    bu_log("color = %d\n", ((struct x_vars *)dmp->dm_vars.priv_vars)->fg);
  }

  XDrawLine( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	     ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	     ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	     sx1, sy1, sx2, sy2 );
d955 1
a955 1
  return TCL_OK;
d961 1
a961 1
  int   sx, sy;
d963 2
a964 2
  sx = dm_Normal2Xx(dmp, x);
  sy = dm_Normal2Xy(dmp, y, 0);
d966 5
a970 5
  if (dmp->dm_debugLevel) {
    bu_log("tk_drawPoint2D()\n");
    bu_log("x = %g, y = %g\n", x, y);
    bu_log("sx = %d, sy = %d\n", sx, sy);
  }
d972 3
a974 3
  XDrawPoint( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->pix,
	      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc, sx, sy );
d976 1
a976 1
  return TCL_OK;
d1001 2
a1002 2
	((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	((struct x_vars *)dmp->dm_vars.priv_vars)->fg);
d1025 3
a1027 3
	((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
	Tk_GetColorByValue(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
	&color)->pixel);
d1029 1
a1029 1
  return TCL_OK;
d1035 1
a1035 1
  int linestyle;
d1037 2
a1038 2
  if (dmp->dm_debugLevel)
    bu_log("tk_setLineAttr( width: %d, style: %d)\n", width, style);
d1040 2
a1041 2
  dmp->dm_lineWidth = width;
  dmp->dm_lineStyle = style;
d1043 2
a1044 2
  if(width < 1)
    width = 1;
d1046 4
a1049 4
  if(style == DM_DASHED_LINE)
    linestyle = LineOnOffDash;
  else
    linestyle = LineSolid;
d1051 3
a1053 3
  XSetLineAttributes( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		      ((struct x_vars *)dmp->dm_vars.priv_vars)->gc,
		      width, linestyle, CapButt, JoinMiter );
d1055 1
a1055 1
  return TCL_OK;
d1062 1
a1062 1
  dmp->dm_debugLevel = lvl;
d1064 1
a1064 1
  return TCL_OK;
d1070 2
a1071 2
  if (dmp->dm_debugLevel)
    bu_log("tk_setWinBounds()\n");
d1073 6
a1078 6
  dmp->dm_clipmin[0] = w[0];
  dmp->dm_clipmin[1] = w[2];
  dmp->dm_clipmin[2] = w[4];
  dmp->dm_clipmax[0] = w[1];
  dmp->dm_clipmax[1] = w[3];
  dmp->dm_clipmax[2] = w[5];
d1080 1
a1080 1
  return TCL_OK;
d1086 7
a1092 7
  XFontStruct     *newfontstruct;
  XGCValues       gcv;
  int h, w;

  /* nothing to do */
  h = Tk_Height(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
  w = Tk_Width(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);
d1094 27
a1120 2
  if (!force && dmp->dm_width==w && dmp->dm_height == h)
    return TCL_OK;
d1122 2
a1123 2
  dmp->dm_width=w;
  dmp->dm_width=h;
d1125 2
a1126 1
  dmp->dm_aspect = (fastf_t)dmp->dm_width / (fastf_t)dmp->dm_height;
d1128 7
a1134 33
  if (dmp->dm_debugLevel) {
    bu_log("tk_configureWin_guts()\n");
    bu_log("width = %d, height = %d\n", dmp->dm_width, dmp->dm_height);
  }

  Tk_FreePixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		((struct x_vars *)dmp->dm_vars.priv_vars)->pix);
  ((struct x_vars *)dmp->dm_vars.priv_vars)->pix =
    Tk_GetPixmap(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
		 DefaultRootWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy),
		 dmp->dm_width,
		 dmp->dm_height,
		 Tk_Depth(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin));

  /* First time through, load a font or quit */
  if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontset == 0) {

      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct =
	  Tk_GetFont(dmp->dm_interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, FONT9);

      if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct == NULL) {
	  /* Try hardcoded backup font */

	  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct =
	      Tk_GetFont(dmp->dm_interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, FONTBACK);

	  if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct == NULL) {
	      bu_log("dm-Tk: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
	      return TCL_ERROR;
	  }
      }
      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontset = 1;
  }
d1136 2
a1137 2
  /* XXX:  I removed the font-sizing routine from dm-X from here.  Something
	   should be devised to replace it.  --TJM*/
d1139 1
a1139 1
  return TCL_OK;
d1145 2
a1146 2
  /* don't force */
  return tk_configureWin_guts(dmp, 0);
d1152 2
a1153 2
  if (dmp->dm_debugLevel)
    bu_log("tk_setLight:\n");
d1155 1
a1155 1
  dmp->dm_light = light_on;
d1157 1
a1157 1
  return TCL_OK;
d1163 2
a1164 2
  if (dmp->dm_debugLevel)
    bu_log("tk_setZBuffer:\n");
d1166 1
a1166 1
  dmp->dm_zbuffer = zbuffer_on;
d1168 1
a1168 1
  return TCL_OK;
@


14.9
log
@preliminary support for unaccelerated mgen on aqua through dm-tk

configure.ac:
        - use two levels of expansion for BRLCAD_DATA
        - enable_aqua configure option
        - move X11 ac_ macro tests from argument check section
        - rely on AC_PATH_XTRA to figure out most of what we need to know about
                where to find X
        - no longer look for libICE, libXmu, or libXsm  AC_PATH_XTRA
                populates X_PRE_LIBS with these but they seem completely unused
                right now.
        - look for opengl libs and headers in all of the places AC_PATH_XTRA
                looked for the xlibs
        - use tk's xlib headers when using tk-aqua rather than x
        - remove X11 "ugly hack"
        - include tk flags where necessary
        - remove --disable-shared from subconfigs
        - forcibly add tcl and tk build dirs to libtool wrapper scripts
libdm/Makefile.am, dm-tk.[ch], dm.h, dm-generic.c, dm_obj.c, mged/Makefile.am,
                attach.c, dm-generic.c, dm-tk.c, ged.c:
        - use lower case when referring to tk
        - add support for using dm-tk
        - include X_CFLAGS with DM_X
irprep/Makefile.am, util/Makefile.am:
        - disable build of ir-X, pl-X when there is no X
dm-X.c:
        - no need to test for HAVE_X11_XLIB here; if we don't have it we
                shouldn't be building this file
libfb/Makefile.am, if_tk.c, libfb/tcl.c:
        - build if_tk.c
        - add preliminary hooks so if_tk can be called when ready
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.8 2007/01/27 01:41:37 brlcad Exp $ (BRL)";
d289 1
a289 1
  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct = NULL;
d649 1
a649 1
	register struct rt_vlist	*tvp;
d675 1
a675 1
	for (BU_LIST_FOR(tvp, rt_vlist, &vp->l)) {
d688 1
a688 1
			case RT_VLIST_POLY_START:
d690 1
a690 1
			case RT_VLIST_POLY_VERTNORM:
d692 2
a693 2
			case RT_VLIST_POLY_MOVE:
			case RT_VLIST_LINE_MOVE:
d722 3
a724 3
			case RT_VLIST_POLY_DRAW:
			case RT_VLIST_POLY_END:
			case RT_VLIST_LINE_DRAW:
d922 1
a922 1
  Tk_DrawChars( ((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
d1117 15
a1131 11
  if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct == NULL) {
    if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct =
	Tk_GetFont(dmp->dm_interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
	FONT9)) == NULL ) {

      /* Try hardcoded backup font */
      if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->tkfontstruct =
	  Tk_GetFont(dmp->dm_interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin,
	  FONTBACK)) == NULL ) {
	bu_log("dm-Tk: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
	return TCL_ERROR;
d1133 1
a1133 1
    }
@


14.8
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.7 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
d40 2
d79 1
a79 1
#include "dm-Tk.h"
d85 1
a85 1
struct dm	*tk_open(Tcl_Interp *interp, int argc, char **argv);
d94 32
a125 32
HIDDEN int	Tk_close(struct dm *dmp);
HIDDEN int	Tk_drawBegin(struct dm *dmp), Tk_drawEnd(struct dm *dmp);
HIDDEN int	Tk_normal(struct dm *dmp), Tk_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int      Tk_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect);
HIDDEN int	Tk_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2);
HIDDEN int      Tk_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int	Tk_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int      Tk_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency);
HIDDEN int	Tk_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int	Tk_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int	Tk_configureWin_guts(struct dm *dmp, int force);
HIDDEN int	Tk_configureWin(struct dm *dmp);
HIDDEN int	Tk_setLight(struct dm *dmp, int light_on);
HIDDEN int	Tk_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int	Tk_setWinBounds(struct dm *dmp, register int *w), Tk_debug(struct dm *dmp, int lvl);

struct dm dm_Tk = {
  Tk_close,
  Tk_drawBegin,
  Tk_drawEnd,
  Tk_normal,
  Tk_loadMatrix,
  Tk_drawString2D,
  Tk_drawLine2D,
  Tk_drawPoint2D,
  Tk_drawVList,
  Tk_setFGColor,
  Tk_setBGColor,
  Tk_setLineAttr,
  Tk_configureWin,
  Tk_setWinBounds,
  Tk_setLight,
d128 2
a129 2
  Tk_setZBuffer,
  Tk_debug,
d222 1
a222 1
tk_open(Tcl_Interp *interp, int argc, char **argv)
d242 1
a242 1
  *dmp = dm_Tk; /* struct copy */
d251 1
a251 1
  dmp->dm_vars.priv_vars = (genptr_t)bu_calloc(1, sizeof(struct Tk_vars), "tk_open: Tk_vars");
d266 1
a266 1
      bu_vls_printf(&dmp->dm_pathName, ".dm_Tk%d", count);
d322 1
a322 1
    (void)Tk_close(dmp);
d336 1
a336 1
    (void)Tk_close(dmp);
d350 1
a350 1
      (void)Tk_close(dmp);
d388 1
a388 1
    (void)Tk_close(dmp);
d500 1
a500 1
  (void)Tk_configureWin_guts(dmp, 1);
d514 1
a514 1
 *  @@proc Tk_close
d519 1
a519 1
Tk_close(struct dm *dmp)
d543 3
a545 3
  bu_free(dmp->dm_vars.priv_vars, "Tk_close: Tk_vars");
  bu_free(dmp->dm_vars.pub_vars, "Tk_close: dm_Tkvars");
  bu_free(dmp, "Tk_close: dmp");
d551 1
a551 1
 * @@proc Tk_drawBegin
d555 1
a555 1
Tk_drawBegin(struct dm *dmp)
d560 1
a560 1
    bu_log("Tk_drawBegin()\n");
d584 1
a584 1
 *  Tk_drawEnd
d588 1
a588 1
Tk_drawEnd(struct dm *dmp)
d591 1
a591 1
    bu_log("Tk_drawEnd()\n");
d608 1
a608 1
 * @@proc Tk_loadMatrix
d611 1
a611 1
 *  many calls to Tk_drawVList().
d615 1
a615 1
Tk_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
d618 1
a618 1
    bu_log("Tk_loadMatrix()\n");
d640 1
a640 1
 * Tk_drawVList
d645 1
a645 1
Tk_drawVList(struct dm *dmp, register struct bn_vlist *vp)
d659 1
a659 1
		bu_log("Tk_drawVList()\n");
d856 1
a856 1
				bu_log("Tk_drawVList(): handle Tcl events\n");
d882 1
a882 1
Tk_normal(struct dm *dmp)
d885 1
a885 1
    bu_log("Tk_normal()\n");
d898 1
a898 1
Tk_drawString2D(struct dm *dmp, register char *str, fastf_t x, fastf_t y, int size, int use_aspect)
d903 1
a903 1
    bu_log("Tk_drawString2D():\n");
d932 1
a932 1
Tk_drawLine2D(struct dm *dmp, fastf_t x1, fastf_t y1, fastf_t x2, fastf_t y2)
d942 1
a942 1
    bu_log("Tk_drawLine2D()\n");
d959 1
a959 1
Tk_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
d967 1
a967 1
    bu_log("Tk_drawPoint2D()\n");
d980 1
a980 1
Tk_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency)
d985 1
a985 1
	bu_log("Tk_setFGColor( %d %d %d)\n", r, g, b);
d1008 1
a1008 1
Tk_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
d1011 1
a1011 1
	bu_log("Tk_setBGColor()\n");
d1033 1
a1033 1
Tk_setLineAttr(struct dm *dmp, int width, int style)
d1038 1
a1038 1
    bu_log("Tk_setLineAttr( width: %d, style: %d)\n", width, style);
d1060 1
a1060 1
Tk_debug(struct dm *dmp, int lvl)
d1068 1
a1068 1
Tk_setWinBounds(struct dm *dmp, register int *w)
d1071 1
a1071 1
    bu_log("Tk_setWinBounds()\n");
d1084 1
a1084 1
Tk_configureWin_guts(struct dm *dmp, int force)
d1103 1
a1103 1
    bu_log("Tk_configureWin_guts()\n");
d1139 1
a1139 1
Tk_configureWin(struct dm *dmp)
d1142 1
a1142 1
  return Tk_configureWin_guts(dmp, 0);
d1146 1
a1146 1
Tk_setLight(struct dm *dmp, int light_on)
d1149 1
a1149 1
    bu_log("Tk_setLight:\n");
d1157 1
a1157 1
Tk_setZBuffer(struct dm *dmp, int zbuffer_on)
d1160 1
a1160 1
    bu_log("Tk_setZBuffer:\n");
d1167 1
@


14.7
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d27 1
a27 1
 *  
d32 1
a32 1
 *  
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.6 2007/01/20 14:36:52 brlcad Exp $ (BRL)";
d169 1
a169 1
extern int vectorThreshold;	/* defined in libdm/tcl.c */ 
d171 1
a171 1
static void 
d183 1
a183 1
	case 1: 
d198 1
a198 1
		bu_log("XAllocColor failed (BadColor) for (%3d,%3d,%3d) %04x,%04x,%04x\n", 
d204 1
a204 1
		bu_log("XAllocColor error for (%3d,%3d,%3d) %04x,%04x,%04x\n", 
d355 1
a355 1
        (struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)) - 30;
d362 1
a362 1
        (struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)) - 30;
d376 1
a376 1
		     dmp->dm_width, 
d409 1
a409 1
    ((struct x_vars *)dmp->dm_vars.priv_vars)->fg = 
d411 1
a411 1
        &fg)->pixel;
d417 1
a417 1
        &bg)->pixel;
d423 1
a423 1
    Tk_GetGC(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, 
d513 1
a513 1
 *  
d550 1
a550 1
 * This white-washes the dm's pixmap with the background color. 
d596 1
a596 1
 	    dmp->dm_height, 0, 0);
d639 1
a639 1
 *  
d1025 1
a1025 1
        &color)->pixel);
d1117 3
a1119 3
        Tk_GetFont(dmp->dm_interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, 
        FONT9)) == NULL ) {
     
d1122 2
a1123 2
          Tk_GetFont(dmp->dm_interp, ((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin, 
          FONTBACK)) == NULL ) {
d1131 1
a1131 1
           should be devised to replace it.  --TJM*/
@


14.6
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.5 2006/08/24 17:49:41 brlcad Exp $ (BRL)";
@


14.5
log
@according to one of the tcl devs (thx jenglish), Tk_IsMapped() is not what we should be using to determine if the tkwin is 'valid' .. being 'mapped' apparently means that there is a window that has been explicitly mapped via a Tk_MapWindow() call or is otherwise fully drawn/displayed.  fall back to a simple non-null check instead.
@
text
@d4 1
a4 1
 * Copyright (C) 1988-2005 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.4 2006/08/22 21:19:02 brlcad Exp $ (BRL)";
@


14.4
log
@Tk_IsMapped takes a tkwin, not a Display, so give it what it wants for the sanity check.  add another for the mainwindow too even.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.3 2006/08/19 21:00:34 brlcad Exp $ (BRL)";
d229 1
a229 1
  struct dm *dmp;
d231 1
a231 1
  Display *dpy;
d233 2
a234 2
  if (((tkwin = Tk_MainWindow(interp)) == NULL) || !Tk_IsMapped(tkwin)) {
	  return DM_NULL;
d348 1
a348 1
  if (!dpy || !Tk_IsMapped(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)) {
@


14.3
log
@make sure we actually got a display before proceeding with the display manager initialization.  this prevents the display manager from crashing out quickly upon startup when some condition fails (like there not being an X11 server to connect to, then attempting to get the size of that display or a screen, etc)
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.2 2006/08/11 06:33:44 brlcad Exp $ (BRL)";
d233 1
a233 1
  if ((tkwin = Tk_MainWindow(interp)) == NULL) {
d348 1
a348 1
  if (!dpy || !Tk_IsMapped(dpy)) {
@


14.2
log
@HAVE_XOSDEFS_H was a conf.h fictional, update to new configure check for HAVE_X11_XOSDEFS_H and clean up header foo some.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-tk.c,v 14.1 2006/08/10 01:00:52 brlcad Exp $ (BRL)";
d231 1
d264 3
a266 2
  if(bu_vls_strlen(&dmp->dm_pathName) == 0)
    bu_vls_printf(&dmp->dm_pathName, ".dm_Tk%d", count);
d345 7
@


14.1
log
@add initial DM_TK interface (from Tim Myers)
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libdm/dm-X.c,v 14.7 2005/03/13 00:43:39 brlcad Exp $ (BRL)";
d59 1
a59 1
#ifdef HAVE_XOSDEFS_H
@

