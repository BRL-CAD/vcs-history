head	1.16;
access;
symbols
	rel-7-10-4:1.15
	STABLE:1.15.0.2
	rel-7-10-2:1.14
	rel-7-10-0:1.14
	rel-7-8-4:1.8
	rel-7-8-2:1.8
	rel-7-8-0:1.8
	trimnurbs-branch:1.8.0.2
	help:1.8
	temp_tag:1.8
	bobWinPort-20051223-freeze:1.2
	postmerge-20051223-bobWinPort:1.8
	premerge-20051223-bobWinPort:1.8
	rel-7-6-6:1.8
	rel-7-6-4:1.8
	rel-7-6-2:1.3
	rel-7-6-branch:1.3.0.2
	rel-7-6-0:1.3
	rel-7-4-2:1.2
	rel-7-4-branch:1.2.0.4
	bobWinPort:1.2.0.2
	rel-7-4-0:1.2;
locks; strict;
comment	@ * @;


1.16
date	2007.12.05.21.24.13;	author erikgreenwald;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.30.19.11.29;	author brlcad;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.20.20.05.07;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.08.06.49.18;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.02.19.46.34;	author erikgreenwald;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.23.01.13.21;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.21.00.51.05;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.18.22.17.57;	author erikgreenwald;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.21.16.02.42;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.21.02.17.11;	author twingy;	state dead;
branches;
next	1.5;

1.5
date	2005.09.14.12.06.04;	author twingy;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.14.12.04.31;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.08.05.11.20;	author twingy;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2005.06.30.09.02.46;	author twingy;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.30.02.45.20;	author twingy;	state Exp;
branches;
next	;

1.3.2.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.16
log
@merge in updated librender
@
text
@/*                   R E N D E R _ U T I L . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file render_util.c
 *
 *  Author -
 *      Justin L. Shumaker
 *
 */

#include "render_util.h"
#include "umath.h"
#include "adrt_struct.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct render_segment_s {
  adrt_mesh_t *mesh;
  uint8_t complete;
  tfloat thickness;
} render_segment_t;


typedef struct render_shotline_s {
  render_segment_t *seglist;
  TIE_3 in_hit;
  uint32_t segnum;
  uint32_t segind;
} render_shotline_t;


/* Generate vector list for a spall cone given a reference angle */
void render_util_spall_vec(TIE_3 dir, tfloat angle, int vec_num, TIE_3 *vec_list) {
#if 0
  TIE_3 vec;
  tfloat radius, t;
  int i;


  /* Otherwise the cone would be twice the angle */
  angle *= 0.5;

  /* Figure out the rotations of the ray direction */
  vec = dir;
  vec.v[2] = 0;

  radius = sqrt(vec.v[0]*vec.v[0] + vec.v[1]*vec.v[1]);
  vec.v[0] /= radius;
  vec.v[1] /= radius;
  
  vec.v[0] = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*MATH_RAD2DEG : acos(vec.v[0])*MATH_RAD2DEG;

  /* triangles to approximate */
  for(i = 0; i < vec_num; i++) {
    t = angle * sin((i * 360 / vec_num) * MATH_DEG2RAD);
    vec_list[i].v[0] = cos((vec.v[0] + t) * MATH_DEG2RAD);
    vec_list[i].v[1] = sin((vec.v[0] + t) * MATH_DEG2RAD);

    t = angle * cos((i * 360 / vec_num) * MATH_DEG2RAD);
    vec_list[i].v[2] = cos(acos(dir.v[2]) + t * MATH_DEG2RAD);
  }
#endif
}


static void* shot_hit(tie_ray_t *ray, tie_id_t *id, tie_tri_t *tri, void *ptr) {
  adrt_mesh_t *mesh = (adrt_mesh_t *)(tri->ptr);
  render_shotline_t *shotline = (render_shotline_t *)ptr;
  uint32_t i;
  uint8_t found;

  /* Scan from segind to segnum to find a match */
  found = 0;
  for(i = shotline->segind; i < shotline->segnum; i++) {
    if(shotline->seglist[i].mesh == mesh) {
      found = 1;
      shotline->seglist[i].complete = 1;
      shotline->seglist[i].thickness = sqrt(id->dist) - sqrt(shotline->seglist[i].thickness);

      /* Advance to next !complete */
      while(shotline->seglist[shotline->segind].complete && shotline->segind <= i)
        shotline->segind++;
      break;
    }
  }

  if(!found) {
    /* Grow the shotline */
    shotline->seglist = (render_segment_t *)realloc(shotline->seglist, (shotline->segnum + 1) * sizeof(render_segment_t));

    /* Assign */
    shotline->seglist[shotline->segnum].mesh = mesh;
    shotline->seglist[shotline->segnum].complete = 0;
    shotline->seglist[shotline->segnum].thickness = id->dist;

    /* In-hit */
    if(shotline->segnum == 0) {
      shotline->in_hit = ray->dir;
      MATH_VEC_MUL_SCALAR(shotline->in_hit, shotline->in_hit, id->dist);
      MATH_VEC_ADD(shotline->in_hit, shotline->in_hit, ray->pos);
    }

    /* Increment */
    shotline->segnum++;
  }

  return(NULL);
}


void render_util_shotline_list(tie_t *tie, tie_ray_t *ray, void **data, int *dlen) {
  tie_id_t id;
  render_shotline_t shotline;
  uint32_t i;
  uint8_t c;

  shotline.seglist = NULL;
  shotline.segnum = 0;
  shotline.segind = 0;

  tie_work(tie, ray, &id, shot_hit, &shotline);

  /* result length */
  *dlen = 0;

  /* in-hit */
  *data = realloc(*data, sizeof(TIE_3));
  memcpy(&((char *)*data)[*dlen], &shotline.in_hit, sizeof(TIE_3));
  *dlen = sizeof(TIE_3);

  /* number of segments */
  *data = realloc(*data, *dlen + sizeof(uint32_t));
  memcpy(&((char *)*data)[*dlen], &shotline.segnum, sizeof(uint32_t));
  *dlen += sizeof(uint32_t);

  for(i = 0; i < shotline.segnum; i++) {
/*    printf("i: %d, complete: %d, thickness: %.3f, name: %s\n", i, shotline.seglist[i].complete, shotline.seglist[i].thickness, shotline.seglist[i].mesh->name); */
    c = strlen(shotline.seglist[i].mesh->name) + 1;

    /* Grow the data */
    *data = realloc(*data, *dlen + 1 + c + sizeof(uint32_t));

    /* length of string */
    memcpy(&((char *)*data)[*dlen], &c, 1);
    *dlen += 1;

    /* string */
    memcpy(&((char *)*data)[*dlen], shotline.seglist[i].mesh->name, c);
    *dlen += c;

    /* thickness */
    memcpy(&((char *)*data)[*dlen], &shotline.seglist[i].thickness, sizeof(tfloat));
    *dlen += sizeof(tfloat);
  }

  /* Free shotline data */
  free(shotline.seglist);
}


void render_util_spall_list(tie_t *tie, tie_ray_t *ray, tfloat angle, void **data, int *dlen) {
#if 0
  shotline_t shotline;
  tie_ray_t sray;
  tie_id_t id;
  int i, ind;
  unsigned char c;
  TIE_3 *vec_list, in, out;
 

  shotline.mesh_list = NULL;
  shotline.mesh_num = 0;

  MATH_VEC_SET(shotline.in, 0, 0 ,0);
  MATH_VEC_SET(shotline.out, 0, 0 ,0);

  /* Fire the center ray first */
  tie_work(tie, ray, &id, shot_hit, &shotline);
  in = shotline.in;
  out = shotline.out;

  sray.pos = shotline.in;

  /* allocate memory for 32 spall rays */
  vec_list = (TIE_3 *)malloc(32 * sizeof(TIE_3));
  if (!vec_list) {
      perror("vec_list");
      exit(1);
  }

  /* Fire the 32 spall rays from the first in-hit at full angle */
  render_util_spall_vec(ray->dir, angle, 32, vec_list);
  for(i = 0; i < 32; i++) {
    sray.dir = vec_list[i];
    tie_work(tie, &sray, &id, shot_hit, &shotline);
  }

  /* Fire the 16 spall rays from the first in-hit at half angle */
  render_util_spall_vec(ray->dir, angle*0.5, 16, vec_list);
  for(i = 0; i < 16; i++) {
    sray.dir = vec_list[i];
    tie_work(tie, &sray, &id, shot_hit, &shotline);
  }

  /* Fire the 12 spall rays from the first in-hit at quarter angle */
  render_util_spall_vec(ray->dir, angle*0.25, 12, vec_list);
  for(i = 0; i < 12; i++) {
    sray.dir = vec_list[i];
    tie_work(tie, &sray, &id, shot_hit, &shotline);
  }

  free(vec_list);

  shotline.in = in;
  shotline.out = out;

  ind = 0;

  *data = (void *)realloc(*data, 6*sizeof(tfloat) + sizeof(int));

  /* pack in hit */
  memcpy(&((char *)*data)[ind], &shotline.in, sizeof(TIE_3));
  ind += sizeof(TIE_3);

  /* pack out hit */
  memcpy(&((char *)*data)[ind], &shotline.out, sizeof(TIE_3));
  ind += sizeof(TIE_3);

  memcpy(&((char *)*data)[ind], &shotline.mesh_num, sizeof(int));
  ind += sizeof(int);

  for(i = 0; i < shotline.mesh_num; i++) {
    c = strlen(shotline.mesh_list[i]->name) + 1;

    *data = realloc(*data, ind + c + 2); /* 1 for length, 1 for null char */

    /* length */
    memcpy(&((char *)*data)[ind], &c, 1);
    ind += 1;

    /* name */
    memcpy(&((char *)*data)[ind], shotline.mesh_list[i]->name, c);
    ind += c;

/*    printf("hit[%d]: -%s-\n", i, shotline.mesh_list[i]->name); */
  }

  *dlen = ind;
#endif
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.15
log
@TFLOAT changed to tfloat.  also quell a few warnings/bugs related to passing the wrong TIE_3 pointer type.
@
text
@d29 1
a29 1
#include "adrt_common.h"
d35 13
a47 6
typedef struct shotline_s {
  common_mesh_t **mesh_list;
  TIE_3 in;
  TIE_3 out;
  int mesh_num;
} shotline_t;
d52 1
d68 1
a68 1

d80 1
d85 38
a122 18
  common_triangle_t *t = ((common_triangle_t *)(tri->ptr));
  shotline_t *shotline;
  int i, match;

  shotline = (shotline_t *)ptr;

  match = 0;
  for(i = 0; i < shotline->mesh_num; i++)
    if(t->mesh == shotline->mesh_list[i])
      match = 1;

  if(!match) {
    shotline->mesh_list = (common_mesh_t **)realloc(shotline->mesh_list, sizeof(common_mesh_t *) * (shotline->mesh_num + 1));
    shotline->mesh_list[shotline->mesh_num] = t->mesh;
    if(!shotline->mesh_num)
      shotline->in = id->pos;
    shotline->out = id->pos;
    shotline->mesh_num++;
a129 1
  shotline_t shotline;
d131 7
a137 14
  int i, ind;
  unsigned char c;


  shotline.mesh_list = NULL;
  shotline.mesh_num = 0;

  shotline.in.v[0] = 0;
  shotline.in.v[1] = 0;
  shotline.in.v[2] = 0;

  shotline.out.v[0] = 0;
  shotline.out.v[1] = 0;
  shotline.out.v[2] = 0;
d141 2
a142 1
  ind = 0;
d144 4
a147 1
  *data = (void *)realloc(*data, 6*sizeof(tfloat) + sizeof(int));
d149 4
a152 7
  /* pack in hit */
  memcpy(&((char *)*data)[ind], &shotline.in.v[0], sizeof(tfloat));
  ind += sizeof(tfloat);
  memcpy(&((char *)*data)[ind], &shotline.in.v[1], sizeof(tfloat));
  ind += sizeof(tfloat);
  memcpy(&((char *)*data)[ind], &shotline.in.v[2], sizeof(tfloat));
  ind += sizeof(tfloat);
d154 3
a156 7
  /* pack out hit */
  memcpy(&((char *)*data)[ind], &shotline.out.v[0], sizeof(tfloat));
  ind += sizeof(tfloat);
  memcpy(&((char *)*data)[ind], &shotline.out.v[1], sizeof(tfloat));
  ind += sizeof(tfloat);
  memcpy(&((char *)*data)[ind], &shotline.out.v[2], sizeof(tfloat));
  ind += sizeof(tfloat);
d158 2
a159 5
  memcpy(&((char *)*data)[ind], &shotline.mesh_num, sizeof(int));
  ind += sizeof(int);

  for(i = 0; i < shotline.mesh_num; i++) {
    c = strlen(shotline.mesh_list[i]->name) + 1;
d161 3
a163 1
    *data = realloc(*data, ind + 1 + c); /* 1 for length */
d165 3
a167 3
    /* length */
    memcpy(&((char *)*data)[ind], &c, 1);
    ind += 1;
d169 3
a171 5
    /* name */
    memcpy(&((char *)*data)[ind], shotline.mesh_list[i]->name, c);
    ind += c;

/*    printf("hit[%d]: -%s-\n", i, shotline.mesh_list[i]->name); */
d174 2
a175 1
  *dlen = ind;
d180 1
d187 1
a187 1

d267 1
@


1.14
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d44 1
a44 1
void render_util_spall_vec(TIE_3 dir, TFLOAT angle, int vec_num, TIE_3 *vec_list) {
d46 1
a46 1
  TFLOAT radius, t;
d122 1
a122 1
  *data = (void *)realloc(*data, 6*sizeof(TFLOAT) + sizeof(int));
d125 6
a130 6
  memcpy(&((char *)*data)[ind], &shotline.in.v[0], sizeof(TFLOAT));
  ind += sizeof(TFLOAT);
  memcpy(&((char *)*data)[ind], &shotline.in.v[1], sizeof(TFLOAT));
  ind += sizeof(TFLOAT);
  memcpy(&((char *)*data)[ind], &shotline.in.v[2], sizeof(TFLOAT));
  ind += sizeof(TFLOAT);
d133 6
a138 6
  memcpy(&((char *)*data)[ind], &shotline.out.v[0], sizeof(TFLOAT));
  ind += sizeof(TFLOAT);
  memcpy(&((char *)*data)[ind], &shotline.out.v[1], sizeof(TFLOAT));
  ind += sizeof(TFLOAT);
  memcpy(&((char *)*data)[ind], &shotline.out.v[2], sizeof(TFLOAT));
  ind += sizeof(TFLOAT);
d163 1
a163 1
void render_util_spall_list(tie_t *tie, tie_ray_t *ray, TFLOAT angle, void **data, int *dlen) {
d220 1
a220 1
  *data = (void *)realloc(*data, 6*sizeof(TFLOAT) + sizeof(int));
@


1.13
log
@give adrt some distinctiveness in the header
@
text
@d187 4
@


1.12
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
@


1.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d44 1
a44 1
void render_util_spall_vec(TIE_3 dir, tfloat angle, int vec_num, TIE_3 *vec_list) {
d46 1
a46 1
  tfloat radius, t;
d122 1
a122 1
  *data = (void *)realloc(*data, 6*sizeof(tfloat) + sizeof(int));
d125 6
a130 6
  memcpy(&((char *)*data)[ind], &shotline.in.v[0], sizeof(tfloat));
  ind += sizeof(tfloat);
  memcpy(&((char *)*data)[ind], &shotline.in.v[1], sizeof(tfloat));
  ind += sizeof(tfloat);
  memcpy(&((char *)*data)[ind], &shotline.in.v[2], sizeof(tfloat));
  ind += sizeof(tfloat);
d133 6
a138 6
  memcpy(&((char *)*data)[ind], &shotline.out.v[0], sizeof(tfloat));
  ind += sizeof(tfloat);
  memcpy(&((char *)*data)[ind], &shotline.out.v[1], sizeof(tfloat));
  ind += sizeof(tfloat);
  memcpy(&((char *)*data)[ind], &shotline.out.v[2], sizeof(tfloat));
  ind += sizeof(tfloat);
d163 1
a163 1
void render_util_spall_list(tie_t *tie, tie_ray_t *ray, tfloat angle, void **data, int *dlen) {
d216 1
a216 1
  *data = (void *)realloc(*data, 6*sizeof(tfloat) + sizeof(int));
@


1.10
log
@standard header and footer cleanup
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
@


1.9
log
@uppercase all #define symbols
@
text
@d1 26
d247 10
@


1.8
log
@trailing ws
@
text
@d35 1
a35 1
  vec.v[0] = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg;
d39 3
a41 3
    t = angle * sin((i * 360 / vec_num) * math_deg2rad);
    vec_list[i].v[0] = cos((vec.v[0] + t) * math_deg2rad);
    vec_list[i].v[1] = sin((vec.v[0] + t) * math_deg2rad);
d43 2
a44 2
    t = angle * cos((i * 360 / vec_num) * math_deg2rad);
    vec_list[i].v[2] = cos(acos(dir.v[2]) + t * math_deg2rad);
d149 2
a150 2
  math_vec_set(shotline.in, 0, 0 ,0);
  math_vec_set(shotline.out, 0, 0 ,0);
@


1.7
log
@libvis->librender
@
text
@d34 1
a34 1
  
d79 1
a79 1
 
d144 1
a144 1
 
@


1.6
log
@removed
@
text
@@


1.5
log
@same thing, different function.
@
text
@@


1.4
log
@256 char len string bug in render_util.c
@
text
@d142 1
a142 1
  char c;
@


1.3
log
@fixed a stack pop bug in the kd-tree cache loader.  engine is 1.1% faster.
@
text
@d78 1
a78 1
  char c;
a91 1

@


1.3.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d34 1
a34 1

d78 2
a79 2
  unsigned char c;

d92 1
d143 1
a143 1
  unsigned char c;
d145 1
a145 1

@


1.2
log
@Shotline remapped to '/' on num pad.  Spall cone mapped to '*' on num pad.
Spall cone now fires 32 full angle, 16 half angle, 12 quarter angle rays.
Shotline moved into render utilities.
@
text
@d121 1
a121 1
    *data = realloc(*data, ind + c + 2); /* 1 for length, 1 for null char */
@


1.1
log
@Utility for generating spall vectors.
@
text
@d3 12
d18 1
a18 1
void render_util_spall(TIE_3 dir, tfloat angle, int vec_num, TIE_3 *vec_list) {
d23 4
d47 175
@

