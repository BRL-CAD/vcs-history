head	1.14;
access;
symbols
	rel-7-10-4:1.14
	STABLE:1.14.0.2
	rel-7-10-2:1.13
	rel-7-10-0:1.13
	rel-7-8-4:1.8
	rel-7-8-2:1.8
	rel-7-8-0:1.8
	trimnurbs-branch:1.8.0.2
	help:1.8
	temp_tag:1.7
	bobWinPort-20051223-freeze:1.2
	postmerge-20051223-bobWinPort:1.7
	premerge-20051223-bobWinPort:1.7
	rel-7-6-6:1.7
	rel-7-6-4:1.7
	rel-7-6-2:1.5
	rel-7-6-branch:1.5.0.2
	rel-7-6-0:1.5
	bobWinPort:1.2.0.2;
locks; strict;
comment	@ * @;


1.14
date	2007.08.30.19.11.29;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.20.20.05.05;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.08.06.49.17;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.02.19.46.34;	author erikgreenwald;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.23.01.13.21;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.21.00.12.17;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.10.15.12.35;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.23.04.44.27;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.20.20.33.46;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.08.29.06.37.16;	author twingy;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2005.08.15.20.50.11;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.15.20.20.26;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.15.18.18.38;	author twingy;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.15.03.46.41;	author twingy;	state Exp;
branches;
next	;

1.5.2.1
date	2005.11.13.13.46.11;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.14
log
@TFLOAT changed to tfloat.  also quell a few warnings/bugs related to passing the wrong TIE_3 pointer type.
@
text
@/*                         B E N C H . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file bench.c
 *
 * Author -
 *   Justin Shumaker
 */

#include "bench.h"
#include <math.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
/*** lib common ***/
#include "canim.h"
#include "cdb.h"
#include "pack.h"
#include "unpack.h"
/*** lib util ***/
#include "camera.h"
#include "image.h"
#include "umath.h"
/*** Networking Includes ***/
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>


#define LOCAL_PORT 10000


void *bench_frame;
common_db_t db;
util_camera_t camera;
tie_t tie;
void *app_data;
int app_size;
int server_socket;
pthread_t bench_thread;
tienet_sem_t bench_net_sem;


static void* bench_ipc(void *ptr) {
  struct sockaddr_in server;
  struct sockaddr_in client;
  int client_socket;
  unsigned int addrlen;


  /* create a socket */
  if((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    fprintf(stderr, "unable to create socket, exiting.\n");
    exit(1);
  }

  /* server address */
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = htonl(INADDR_ANY);
  server.sin_port = htons(LOCAL_PORT);

  /* bind socket */
  if(bind(server_socket, (struct sockaddr *)&server, sizeof(server)) < 0) {
    fprintf(stderr, "socket already bound, exiting.\n");
    exit(1);
  }

  /* listen for connections */
  listen(server_socket, 3);

  /* wait for connection before streaming data */
  addrlen = sizeof(client);
  tienet_sem_post(&bench_net_sem);
  client_socket = accept(server_socket, (struct sockaddr *)&client, &addrlen);

  /* send the application data */
  printf("ipc connection established, sending data: %d bytes\n", app_size);
  tienet_send(client_socket, &app_size, sizeof(int), 0);
  tienet_send(client_socket, app_data, app_size, 0);

  close(client_socket);
  close(server_socket);
}


void bench(char *proj, int cache, int image) {
  struct sockaddr_in server;
  struct sockaddr_in client;
  struct hostent h;
  int i, res_len, client_socket;
  common_work_t work;
  void *res_buf;
  unsigned char *image24;
  clock_t ticks1, ticks2, ticks3;
  tfloat t;


  ticks1 = clock();
  tienet_sem_init(&bench_net_sem, 0);

  printf("loading and prepping ...\n");
  /* Camera with no threads */
  util_camera_init(&camera, 1);

  /* Parse Env Data */
  common_db_load(&db, proj);

  /*
  * Hack the environment settings to make it think there is no cache file
  * if the user is generating one, otherwise it never generates one
  */
  if(cache)
    db.env.kdtree_cache_file[0] = 0;

  /* Read the data off disk and pack it */
  app_size = common_pack(&db, &app_data, proj);

  /* Launch a networking thread to do ipc data streaming */
  pthread_create(&bench_thread, NULL, bench_ipc, 0);

  /* Parse the data into memory for rendering */
  /* create a socket */
  if((client_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    fprintf(stderr, "unable to create socket, exiting.\n");
    exit(1);
  }

  /* Bind any available port number */
  client.sin_family = AF_INET;
  client.sin_addr.s_addr = htonl(INADDR_ANY);
  client.sin_port = htons(0);

  if(bind(client_socket, (struct sockaddr *)&client, sizeof(client)) < 0) {
    fprintf(stderr, "unable to bind socket, exiting\n");
    exit(1);
  }

  /* Establish ipc connection */
  if(gethostbyname("localhost")) {
    h = gethostbyname("localhost")[0];
  } else {
    fprintf(stderr, "unknown host: %s\n", "localhost");
    exit(1);
  }

  server.sin_family = h.h_addrtype;
  memcpy((char *)&server.sin_addr.s_addr, h.h_addr_list[0], h.h_length);
  server.sin_port = htons(LOCAL_PORT);

  tienet_sem_wait(&bench_net_sem);
  if(connect(client_socket, (struct sockaddr *)&server, sizeof(server)) < 0) {
    fprintf(stderr, "cannot establish connection, exiting.\n");
    exit(1);
  }

  /* stream and unpack the data */
  common_unpack(&db, &tie, &camera, client_socket);
  tie_prep(&tie);

  /* Prep */
  common_env_prep(&db.env);
  util_camera_prep(&camera, &db);

  /* Allocate memory for a frame */
  bench_frame = malloc(4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);
  if (!bench_frame) {
      perror("bench_frame");
      exit(1);
  }
  memset(bench_frame, 0, 4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);

  /* Render an image */
  work.orig_x = 0;
  work.orig_y = 0;
  work.size_x = db.env.img_w;
  work.size_y = db.env.img_h;
  work.format = COMMON_BIT_DEPTH_24;

  printf("rendering ...\n");
  res_buf = NULL;
  ticks2 = clock();
  util_camera_render(&camera, &db, &tie, &work, sizeof(common_work_t), &res_buf, &res_len);
  ticks3 = clock();

  printf("prep   time: %.3f sec\n", (tfloat)(ticks2 - ticks1) / (tfloat)CLOCKS_PER_SEC);
  t = (tfloat)(ticks3 - ticks2) / (tfloat)CLOCKS_PER_SEC;
  printf("render time: %.3f sec\n", t);
  printf("rays /  sec: %d\n", (int)((db.env.img_w * db.env.img_h) / t));
  if(image) {
    image24 = &((unsigned char *)res_buf)[sizeof(common_work_t)];
    util_image_save_ppm("dump.ppm", image24, db.env.img_w, db.env.img_h);
  }

  close(client_socket);

  util_camera_free(&camera);
  free(app_data);
  free(bench_frame);
  common_unpack_free(&db);

  if(cache) {
    void *kdcache;
    unsigned int size;
    FILE *fh;

    tie_kdtree_cache_free(&tie, &kdcache);
    memcpy(&size, kdcache, sizeof(unsigned int));
    printf("saving kd-tree cache: %d bytes\n", size);
    fh = fopen("kdtree.cache", "w");
      fwrite(kdcache, size, 1, fh);
    fclose(fh);
    free(kdcache);
  }
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.13
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d117 1
a117 1
  TFLOAT t;
d187 1
a187 1
  bench_frame = malloc(4 * sizeof(TFLOAT) * db.env.img_w * db.env.img_h);
d192 1
a192 1
  memset(bench_frame, 0, 4 * sizeof(TFLOAT) * db.env.img_w * db.env.img_h);
d207 2
a208 2
  printf("prep   time: %.3f sec\n", (TFLOAT)(ticks2 - ticks1) / (TFLOAT)CLOCKS_PER_SEC);
  t = (TFLOAT)(ticks3 - ticks2) / (TFLOAT)CLOCKS_PER_SEC;
@


1.12
log
@give adrt some distinctiveness in the header
@
text
@d188 4
@


1.11
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
@


1.10
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d117 1
a117 1
  tfloat t;
d187 2
a188 2
  bench_frame = malloc(4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);
  memset(bench_frame, 0, 4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);
d203 2
a204 2
  printf("prep   time: %.3f sec\n", (tfloat)(ticks2 - ticks1) / (tfloat)CLOCKS_PER_SEC);
  t = (tfloat)(ticks3 - ticks2) / (tfloat)CLOCKS_PER_SEC;
@


1.9
log
@standard header and footer
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
@


1.8
log
@ADRT compiles happily again.
@
text
@d1 25
d233 10
@


1.7
log
@trailing ws
@
text
@d192 1
a192 1
  common_unpack_free();
@


1.6
log
@calling common_unpack_free()
@
text
@d129 1
a129 1
 
@


1.5
log
@Integrated kd-tree caching.
It's generated with adrt_bench by supplying the -c argument.
kdtree_cache_file,kdtree.cache goes into project.env file to make it work.
@
text
@d192 1
@


1.5.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d129 1
a129 1

a191 1
  common_unpack_free();
@


1.4
log
@here we go.
@
text
@d77 3
d83 1
a83 1
void bench(char *proj, int dump) {
d105 7
d147 1
a153 1
  tienet_sem_wait(&bench_net_sem);
d182 1
a182 1
  if(dump) {
d187 2
d192 14
@


1.3
log
@working now
@
text
@d88 2
d91 2
a144 1
  printf("prepping tie\n");
a145 1
  printf("done\n");
d164 1
d166 1
d168 4
a171 2
  image24 = &((unsigned char *)res_buf)[sizeof(common_work_t)];

d173 1
@


1.2
log
@benchmark utility almost done.
@
text
@d38 1
d70 1
d74 2
a75 1
printf("ipc connection established, sending data\n");
a84 1
  char image_name[16];
d86 2
a87 1
  void *mesg, *res_buf;
d89 1
d91 1
a91 1
  printf("Loading and Prepping...\n");
d138 2
a139 1

d141 3
d153 1
a153 1
  /* Render a 2000x1500 (3 megapixel) image */
d156 3
a158 3
  work.size_x = 2000;
  work.size_y = 1500;
  mesg = malloc(sizeof(common_work_t));
d160 2
a161 1
  printf("Rendering...\n");
d164 1
a164 1
  free(mesg);
d166 3
a168 17

  /* Initialize the work dispatcher */
//  rise_dispatcher_init();
//    rise_dispatcher_generate(&db, NULL, 0);

#if 0
    {
      unsigned char *image24;

      image24 = (unsigned char *)malloc(3 * db.env.img_w * db.env.img_h);
      sprintf(image_name, "image_%.4d.ppm", i);
      rise_post_process(rise_master_frame, db.env.img_w, db.env.img_h);
      util_image_convert_128to24(image24, rise_master_frame, db.env.img_w, db.env.img_h);
      util_image_save_ppm(image_name, image24, db.env.img_w, db.env.img_h);
      free(image24);
    }
#endif
@


1.1
log
@some of the benchmarking files
@
text
@d1 1
a1 1
#include "master.h"
d12 1
d14 1
a16 4
/**** rise ****/
#include "dispatcher.h"
#include "post.h"
#include "rise.h"
a17 1
#include "tienet.h"
d24 1
a24 12
#if RISE_USE_COMPRESSION
  #include <zlib.h>
#endif


/* socket structure */
typedef struct rise_master_socket_s {
  int num;
  tienet_sem_t update_sem;
  struct rise_master_socket_s *prev;
  struct rise_master_socket_s *next;
} rise_master_socket_t;
d27 1
a27 3
void rise_master(int port, int obs_port, char *proj, char *list, char *exec, int interval);
void rise_master_result(void *res_buf, int res_len);
void* rise_master_networking(void *ptr);
a28 2
int rise_master_tile_num;
int rise_master_work_ind;
d30 1
a30 7
tienet_sem_t rise_master_frame_sem;

void *rise_master_frame;

pthread_t rise_master_networking_thread;
int rise_master_active_connections, rise_master_alive;
rise_master_socket_t *rise_master_socklist;
d32 6
d40 5
a44 4
void rise_master(int port, int obs_port, char *proj, char *list, char *exec, int interval) {
  int i, app_size;
  void *app_data;
  char image_name[16];
d47 5
a51 2
  rise_master_work_ind = 0;
  tienet_sem_init(&rise_master_frame_sem, 0);
d53 4
a56 2
  /* initialize the semaphore for frame updates */
  rise_master_active_connections = 0;
d58 4
a61 44
  rise_master_alive = 1;

  /* Parse Env Data */
  common_db_load(&db, proj);

  /* Initialize tienet master */
  rise_master_tile_num = (db.env.img_w * db.env.img_h) / (db.env.tile_w * db.env.tile_h);
  tienet_master_init(port, rise_master_result, list, exec, 10, RISE_VER_KEY);

  rise_master_frame = malloc(4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);
  memset(rise_master_frame, 0, 4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);

  /* Launch a thread to handle networking */
  pthread_create(&rise_master_networking_thread, NULL, rise_master_networking,&obs_port);

  /* Initialize the work dispatcher */
  rise_dispatcher_init();

  /* Render Frame */
  for(i = 0; i < db.anim.frame_num && rise_master_alive; i++) {
    printf("Preparing frame #%d of %d\n", i+1, db.anim.frame_num);

    /* Parse and pack the application data */
    app_size = common_pack(&db, &app_data, proj);
    tienet_master_prep(app_data, app_size);

    /* Fill the work buffer */
    rise_dispatcher_generate(&db, NULL, 0);

    /* Wait for frame to finish */
    tienet_sem_wait(&rise_master_frame_sem);
#if 1
    {
      unsigned char *image24;

      image24 = (unsigned char *)malloc(3 * db.env.img_w * db.env.img_h);
      sprintf(image_name, "image_%.4d.ppm", i);
      rise_post_process(rise_master_frame, db.env.img_w, db.env.img_h);
      util_image_convert_128to24(image24, rise_master_frame, db.env.img_w, db.env.img_h);
      util_image_save_ppm(image_name, image24, db.env.img_w, db.env.img_h);
      free(image24);
    }
#endif
    free(app_data);
d64 2
a65 8
  /* Wait for the tienet master work buffer to empty and for all the results to come back */
  tienet_master_wait();

  /* Shutdown */
  tienet_master_shutdown();

  /* Free network data */
  tienet_master_free();
d67 7
a73 9
  /* Free the dispatcher data */
  rise_dispatcher_free();

  free(rise_master_frame);

#if 0
  /* End the networking thread */
  pthread_join(rise_master_networking_thread, NULL);
#endif
d77 6
a82 2
void rise_master_result(void *res_buf, int res_len) {
  rise_master_socket_t *sock;
d84 1
a84 2
  unsigned char *rgb_data;
  int i, ind;
a85 2
  memcpy(&work, res_buf, sizeof(common_work_t));
  rise_master_work_ind++;
d87 3
a89 29
  rgb_data = &((unsigned char *)res_buf)[sizeof(common_work_t)];

  ind = 0;
  for(i = work.orig_y; i < work.orig_y + work.size_y; i++) {
    memcpy(&((char *)rise_master_frame)[4 * sizeof(tfloat) * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 4*sizeof(tfloat)*work.size_x);
    ind += 4 * sizeof(tfloat) * work.size_x;
  }

  /* Progress Indicator */
  printf("Progress: %.1f%%\r", 100 * (tfloat)rise_master_work_ind / (tfloat)rise_master_tile_num);
  fflush(stdout);
/*printf("result: %d %d\n", work.orig_x, work.orig_y); */

  /* post update to all nodes that a tile has come in */
  for(sock = rise_master_socklist; sock; sock = sock->next) {
    if(sock->next) {
      if(!sock->update_sem.val)
        tienet_sem_post(&(sock->update_sem));
    }
  }

  /* Draw the frame to the screen */
  if(rise_master_work_ind == rise_master_tile_num) {
    /* Save image to disk */
    tienet_sem_post(&rise_master_frame_sem);

    rise_master_work_ind = 0;
  }
}
d91 2
d94 2
a95 14
void* rise_master_networking(void *ptr) {
  rise_master_socket_t *sock, *tmp;
  struct sockaddr_in master, observer;
  fd_set readfds;
  int port, master_socket, highest_fd, new_socket, error;
  tfloat cam[8];
  unsigned int addrlen;
  unsigned char op;
  short endian;
  void *frame24;
#if RISE_USE_COMPRESSION
  void *comp_buf;
#endif

d97 2
a98 7
  port = *(int *)ptr;
  frame24 = malloc(3 * db.env.img_w * db.env.img_h);


#if RISE_USE_COMPRESSION
  comp_buf = malloc(db.env.img_w * db.env.img_h*3);
#endif
d100 1
d102 1
a102 1
  if((master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
d107 9
a115 5
  /* initialize socket list */
  rise_master_socklist = (rise_master_socket_t *)malloc(sizeof(rise_master_socket_t));
  rise_master_socklist->next = NULL;
  rise_master_socklist->prev = NULL;
  rise_master_socklist->num = master_socket;
d117 7
a123 1
  highest_fd = master_socket;
d125 3
d129 2
a130 8
  /* server address */
  master.sin_family = AF_INET;
  master.sin_addr.s_addr = htonl(INADDR_ANY);
  master.sin_port = htons(port);

  /* bind socket */
  if(bind(master_socket, (struct sockaddr *)&master, sizeof(master)) < 0) {
    fprintf(stderr, "socket already bound, exiting.\n");
a133 2
  FD_ZERO(&readfds);
  FD_SET(master_socket, &readfds);
d135 1
a135 2
  /* listen for connections */
  listen(rise_master_socklist->num, 3);
d137 14
a150 2
  addrlen = sizeof(observer);
  rise_master_active_connections = 0;
d152 2
a153 71
  while(rise_master_alive) {
    /* wait for some network activity */
    select(highest_fd+1, &readfds, NULL, NULL, NULL);
    /* cycle through each socket and address the activity */
    for(sock = rise_master_socklist; sock; sock = sock->next) {
      /* check if activity was on this socket */
      if(FD_ISSET(sock->num, &readfds)) {
        if(sock->num == master_socket) {
          /* new connection */
          new_socket = accept(master_socket, (struct sockaddr *)&observer, &addrlen);
          if(new_socket >= 0) {
            tmp = rise_master_socklist;
            rise_master_socklist = (rise_master_socket_t *)malloc(sizeof(rise_master_socket_t));
            rise_master_socklist->num = new_socket;
            rise_master_socklist->next = tmp;
            rise_master_socklist->prev = NULL;
            tienet_sem_init(&(rise_master_socklist->update_sem), 0);
            tmp->prev = rise_master_socklist;
            if(new_socket > highest_fd)
              highest_fd = new_socket;
            rise_master_active_connections++;
          }
        } else {
          op = 255;
          /* observer communication */
          error = tienet_recv(sock->num, &op, 1, 0);
          /* remove socket from pool if there's an error, i.e slave disconnected */
          if(error || op == RISE_NET_OP_QUIT) {
            tmp = sock;
            if(sock->prev)
              sock->prev->next = sock->next;
            /* master is always last, no need to check for sock->next next */
            sock->next->prev = sock->prev;
            if(sock == rise_master_socklist)
              rise_master_socklist = rise_master_socklist->next;
            close(sock->num);
            sock = sock->next;
            free(tmp);
            rise_master_active_connections--;
          } else {
            switch(op) {
              case RISE_NET_OP_INIT:
                /* Send screen width and height */
                endian = 1;
                tienet_send(sock->num, &endian, sizeof(short), 0);
                tienet_send(sock->num, &db.env.img_w, sizeof(int), 0);
                tienet_send(sock->num, &db.env.img_h, sizeof(int), 0);
                tienet_send(sock->num, &common_pack_trinum, sizeof(int), 0);
                break;

              case RISE_NET_OP_FRAME:
                tienet_sem_wait(&(sock->update_sem));
                util_image_convert_128to24(frame24, rise_master_frame, db.env.img_w, db.env.img_h);

#if RISE_USE_COMPRESSION
                {
                  unsigned long dest_len;
                  int comp_size;
                  dest_len = 3 * db.env.img_w * db.env.img_h;

                  /* frame data */
                  compress(comp_buf, &dest_len, frame24, 3 * db.env.img_w * db.env.img_h);
                  comp_size = dest_len;
                  tienet_send(sock->num, &comp_size, sizeof(int), 0);
                  tienet_send(sock->num, comp_buf, comp_size, 0);
                }
#else
                /* frame data */
                tienet_send(sock->num, frame24, 3 * db.env.img_w * db.env.img_h, 0);
#endif
                break;
d155 1
a155 15
              case RISE_NET_OP_QUIT:
                rise_master_active_connections = 0;
                break;

              case RISE_NET_OP_SHUTDOWN:
                rise_master_alive = 0;
                break;

              default:
                break;
            }
          }
        }
      }
    }
a156 8
    /* Rebuild select list for next select call */
    highest_fd = 0;
    for(sock = rise_master_socklist; sock; sock = sock->next) {
      if(sock->num > highest_fd)
        highest_fd = sock->num;
      FD_SET(sock->num, &readfds);
    }
  }
d158 3
a160 3
#if RISE_USE_COMPRESSION
  free(comp_buf);
#endif
d162 3
d166 8
a173 3
  /* free rise_master_socklist */
  for(sock = rise_master_socklist->next; sock; sock = sock->next)
    free(sock->prev);
d175 3
a177 2
  free(frame24);
  return 0;
@

