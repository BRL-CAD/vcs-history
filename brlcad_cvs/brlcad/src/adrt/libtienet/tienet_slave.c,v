head	1.17;
access;
symbols
	rel-7-10-4:1.15
	STABLE:1.15.0.2
	rel-7-10-2:1.15
	rel-7-10-0:1.15
	rel-7-8-4:1.9
	rel-7-8-2:1.9
	rel-7-8-0:1.9
	trimnurbs-branch:1.9.0.2
	help:1.9
	temp_tag:1.8
	bobWinPort-20051223-freeze:1.5
	postmerge-20051223-bobWinPort:1.8
	premerge-20051223-bobWinPort:1.8
	rel-7-6-6:1.8
	rel-7-6-4:1.8
	rel-7-6-2:1.5
	rel-7-6-branch:1.5.0.4
	rel-7-6-0:1.5
	rel-7-4-2:1.2.2.1
	rel-7-4-branch:1.2.0.2
	bobWinPort:1.5.0.2
	rel-7-4-0:1.2;
locks; strict;
comment	@ * @;


1.17
date	2007.12.16.18.53.47;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.05.15.33.42;	author erikgreenwald;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.20.20.05.08;	author brlcad;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.08.06.49.19;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.27.01.41.30;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.23.01.13.22;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.21.00.50.29;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.20.14.36.41;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.18.06.46.12;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.10.19.16.29;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.09.22.06.26;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.28.00.28.30;	author twingy;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2005.07.27.17.43.59;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.20.18.37.07;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.18.21.58.58;	author twingy;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.06.18.06.40.40;	author twingy;	state Exp;
branches;
next	;

1.2.2.1
date	2005.08.16.21.03.47;	author brlcad;	state Exp;
branches;
next	;

1.5.4.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.17
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                  T I E N E T _ S L A V E . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file tienet_slave.c
 *
 *  Comments -
 *      TIE Networking Slave
 *
 *  Author -
 *      Justin L. Shumaker
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 * $Id: tienet_slave.c,v 1.16 2007/12/05 15:33:42 erikgreenwald Exp $
 */

#include "tienet_slave.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include "tie.h"
#include "tienet_define.h"
#include "tienet_util.h"
#if TN_COMPRESSION
# include <zlib.h>
#endif


void	tienet_slave_worker(int port, char *host);

short	tienet_endian;
int	tienet_slave_ver_key;


/* work function callback */
typedef void tienet_slave_fcb_work_t(tienet_buffer_t *work, tienet_buffer_t *result);
tienet_slave_fcb_work_t	*tienet_slave_fcb_work;

/* free function callback */
typedef void tienet_slave_fcb_free_t();
tienet_slave_fcb_free_t	*tienet_slave_fcb_free;

void tienet_slave_init(int port, char *host,
                       void fcb_work(tienet_buffer_t *work, tienet_buffer_t *result),
                       void fcb_free(void),
                       int ver_key)
{
  tienet_slave_fcb_work = fcb_work;
  tienet_slave_fcb_free = fcb_free;


  /* Store version key for comparisson with version key on master */
  tienet_slave_ver_key = ver_key;

  /*
  * If host is specified, connect to master, do work, shutdown.
  */

  if(host[0]) {
    tienet_slave_worker(port, host);
  } else {
    fprintf(stdout, "missing hostname, exiting.\n");
    exit(1);
  }
}


void tienet_slave_free() {
}


void tienet_slave_worker(int port, char *host) {
  tienet_buffer_t result, buffer;
  struct sockaddr_in master, slave;
  struct hostent h;
  short op;
  uint32_t size;
  int slave_socket;
#if TN_COMPRESSION
  tienet_buffer_t buffer_comp;
  unsigned long dest_len;
#endif


  /* Initialize res_buf to NULL for realloc'ing */
  TIENET_BUFFER_INIT(result);
  TIENET_BUFFER_INIT(buffer);
#if TN_COMPRESSION
  TIENET_BUFFER_INIT(buffer_comp);
#endif

  if(gethostbyname(host)) {
    h = gethostbyname(host)[0];
  } else {
    fprintf(stderr, "unknown host: %s\n", host);
    exit(1);
  }

  master.sin_family = h.h_addrtype;
  memcpy((char *)&master.sin_addr.s_addr, h.h_addr_list[0], h.h_length);
  master.sin_port = htons(port);

  /* Create a socket */
  if((slave_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    fprintf(stderr, "unable to create socket, exiting.\n");
    exit(1);
  }

  /* Bind any available port number */
  slave.sin_family = AF_INET;
  slave.sin_addr.s_addr = htonl(INADDR_ANY);
  slave.sin_port = htons(0);

  if(bind(slave_socket, (struct sockaddr *)&slave, sizeof(slave)) < 0) {
    fprintf(stderr, "unable to bind socket, exiting\n");
    exit(1);
  }

  /* connect to master and request work */
  if(connect(slave_socket, (struct sockaddr *)&master, sizeof(master)) < 0) {
    fprintf(stderr, "cannot connect to master, exiting.\n");
    exit(1);
  }

  /* receive endian of master */
  tienet_recv(slave_socket, &tienet_endian, sizeof(short), 0);
  tienet_endian = tienet_endian == 1 ? 0 : 1;

  /* send version key, master will respond whether to continue or not */
  tienet_send(slave_socket, &tienet_slave_ver_key, sizeof(int), tienet_endian);

  /* If version mismatch then exit */
  tienet_recv(slave_socket, &op, sizeof(short), tienet_endian);
  if(op == TN_OP_COMPLETE)
    return;

  /* Request Work Unit */
//  op = TN_OP_REQWORK;
//  tienet_send(slave_socket, &op, sizeof(short), tienet_endian);

  while(1) {
    tienet_recv(slave_socket, &op, sizeof(short), tienet_endian);
    if(op == TN_OP_SHUTDOWN || op == TN_OP_COMPLETE) {
      close(slave_socket);
      exit(0);
    } else {
      tienet_recv(slave_socket, &size, sizeof(uint32_t), tienet_endian);
      TIENET_BUFFER_SIZE(buffer, size);
      tienet_recv(slave_socket, buffer.data, size, 0);
      buffer.ind = size;

      /* Process work and Generate Results */
      tienet_slave_fcb_work(&buffer, &result);

      if(!result.ind)
        continue;

      /* Send Result Back, length of: result + op_code + result_length + compression_length */
      TIENET_BUFFER_SIZE(buffer, result.ind+sizeof(short)+sizeof(int)+sizeof(uint32_t));

      buffer.ind = 0;

      /* Pack Operation Code */
      op = TN_OP_RESULT;
      if(tienet_endian) tienet_flip(&op, &op, sizeof(short));
      TCOPY(short, &op, 0, buffer.data, buffer.ind);
      if(tienet_endian) tienet_flip(&op, &op, sizeof(short));
      buffer.ind += sizeof(short);

      /* Pack Result Length */
      if(tienet_endian) tienet_flip(&result.ind, &result.ind, sizeof(uint32_t));
      TCOPY(uint32_t, &result.ind, 0, buffer.data, buffer.ind);
      if(tienet_endian) tienet_flip(&result.ind, &result.ind, sizeof(uint32_t));
      buffer.ind += sizeof(uint32_t);

#if TN_COMPRESSION
      /* Compress the result buffer */
      TIENET_BUFFER_SIZE(buffer_comp, result.ind+32);

      dest_len = buffer_comp.size+32;
      compress(buffer_comp.data, &dest_len, result.data, result.ind);
      size = (uint32_t)dest_len;
    
      /* Pack Compressed Result Length */
      if(tienet_endian) tienet_flip(&size, &size, sizeof(uint32_t));
      TCOPY(uint32_t, &size, 0, buffer.data, buffer.ind);
      if(tienet_endian) tienet_flip(&size, &size, sizeof(uint32_t));
      buffer.ind += sizeof(uint32_t);

      /* Pack Compressed Result Data */
      memcpy(&((char *)buffer.data)[buffer.ind], buffer_comp.data, size);
      buffer.ind += size;
#else
      /* Pack Result Data */
      memcpy(&((char *)buffer.data)[buffer.ind], result.data, result.ind);
      buffer.ind += result.ind;
#endif
      tienet_send(slave_socket, buffer.data, buffer.ind, 0);
    }
  }

  TIENET_BUFFER_FREE(result);
  TIENET_BUFFER_FREE(buffer);
#if TN_COMPRESSION
  TIENET_BUFFER_FREE(buffer_comp);
#endif
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.16
log
@upgrade to the updated version
@
text
@d32 1
a32 1
 * $Id: tienet_slave.c,v 1.3 2007/12/04 21:32:22 erikg Exp $
d124 1
a124 1
  bcopy(h.h_addr_list[0], (char *)&master.sin_addr.s_addr, h.h_length);
d215 1
a215 1
      bcopy(buffer_comp.data, &((char *)buffer.data)[buffer.ind], size);
d219 1
a219 1
      bcopy(result.data, &((char *)buffer.data)[buffer.ind], result.ind);
@


1.15
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d32 1
a32 1
 * $Id: tienet_slave.c,v 1.14 2007/02/08 06:49:19 brlcad Exp $
d45 1
a52 1
int	tienet_slave_prep(int slave_socket, tie_t *tie);
a53 1
void	tienet_slave_daemon(int port);
a58 4
/* init function callback */
typedef void tienet_slave_fcb_init_t(tie_t *tie, int socknum);
tienet_slave_fcb_init_t	*tienet_slave_fcb_init;

d60 1
a60 1
typedef void tienet_slave_fcb_work_t(tie_t *tie, void *data, unsigned int size, void **res_buf, unsigned int *res_len);
a66 5
/* mesg function callback */
typedef void tienet_slave_fcb_mesg_t(void *mesg, unsigned int mesg_len);
tienet_slave_fcb_mesg_t	*tienet_slave_fcb_mesg;


d68 3
a70 5
		       void fcb_init(tie_t *tie, int socknum),
		       void fcb_work(tie_t *tie, void *data, unsigned int size, void **res_buf, unsigned int *res_len),
		       void fcb_free(void),
		       void fcb_mesg(void *mesg, unsigned int mesg_len),
		       int ver_key)
a71 1
  tienet_slave_fcb_init = fcb_init;
a73 1
  tienet_slave_fcb_mesg = fcb_mesg;
a80 1
  * If host is not specified, run as daemon, listen for master to connect
d86 2
a87 1
    tienet_slave_daemon(port);
d97 6
a102 8
  struct sockaddr_in	master, slave;
  struct hostent	h;
  short			op;
  unsigned int		size, res_len, data_max, ind;
  int			slave_socket;
  uint64_t		rays_fired;
  void			*data, *res_buf;
  tie_t			tie;
d104 2
a105 3
  int			comp_max;
  void			*comp_buf;
  unsigned long		dest_len;
d110 5
a114 1
  res_buf = NULL;
d124 1
a124 1
  memcpy((char *)&master.sin_addr.s_addr, h.h_addr_list[0], h.h_length);
d162 2
a163 10
  op = TN_OP_REQWORK;
  tienet_send(slave_socket, &op, sizeof(short), tienet_endian);

  data_max = 0;
  data = NULL;
#if TN_COMPRESSION
  comp_max = 0;
  comp_buf = NULL;
#endif

a169 29
    } else if(op == TN_OP_MESSAGE) {
      unsigned int mesg_len;
      void *mesg;

      /* send this message to the application */
      tienet_recv(slave_socket, &mesg_len, sizeof(unsigned int), tienet_endian);
      mesg = malloc(mesg_len);
      if (!mesg) {
	  perror("malloc");
	  exit(1);
      }
      tienet_recv(slave_socket, mesg, mesg_len, 0);
      tienet_slave_fcb_mesg(mesg, mesg_len);
      free(mesg);
    } else if(op == TN_OP_PREP) {
      /* This can be done better */

      /* Clean and Reinitialize TIE */
      tienet_slave_fcb_free();

      if(tienet_slave_prep(slave_socket, &tie)) {
	fprintf(stderr, "version mismatch, exiting.\n");
	close(slave_socket);
	exit(0);
      }

      /* Now that we've been updated, Request a Work Unit */
      op = TN_OP_REQWORK;
      tienet_send(slave_socket, &op, sizeof(short), tienet_endian);
d171 4
a174 5
      tienet_recv(slave_socket, &size, sizeof(unsigned int), tienet_endian);
      if(size > data_max) {
	data_max = size;
	data = realloc(data, size);
      }
a175 1
      tienet_recv(slave_socket, data, size, 0);
d177 4
a180 1
      tienet_slave_fcb_work(&tie, data, size, &res_buf, &res_len);
d182 4
a185 5
      /* Send Result Back, length of: result + op_code + rays_fired + result_length + compression_length */
      if(res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int) > data_max) {
	data_max = res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int);
	data = realloc(data, data_max);
      }
a186 1
      ind = 0;
d190 1
a190 1
      memcpy(&((char*)data)[ind], &op, sizeof(short));
d192 1
a192 7
      ind += sizeof(short);

      /* Pack total number of rays fired */
      rays_fired = tie.rays_fired;
      if(tienet_endian) tienet_flip(&rays_fired, &rays_fired, sizeof(uint64_t));
      memcpy(&((char*)data)[ind], &rays_fired, sizeof(uint64_t));
      ind += sizeof(uint64_t);
d195 4
a198 4
      if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
      memcpy(&((char*)data)[ind], &res_len, sizeof(unsigned int));
      if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
      ind += sizeof(unsigned int);
d202 1
a202 8
      if(comp_max < res_len) {
	comp_buf = realloc(comp_buf, res_len+32);	/* 32 bytes of extra padding for zlib */
	comp_max = res_len;
      }

      dest_len = comp_max+32;
      compress(comp_buf, &dest_len, res_buf, res_len);
      size = (unsigned int)dest_len;
d204 4
d209 4
a212 4
      if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
      memcpy(&((char*)data)[ind], &size, sizeof(unsigned int));
      if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
      ind += sizeof(unsigned int);
d215 2
a216 2
      memcpy(&((char*)data)[ind], comp_buf, size);
      ind += size;
d219 2
a220 193
      memcpy(&((char*)data)[ind], res_buf, res_len);
      ind += res_len;
#endif
      tienet_send(slave_socket, data, ind, 0);
    }
  }

  free(data);
  free(res_buf);
#if TN_COMPRESSION
  free(comp_buf);
#endif
}


void tienet_slave_daemon(int port) {
  struct sockaddr_in	master, slave;
  socklen_t		addrlen;
  fd_set		readfds;
  short			op;
  unsigned int		size, res_len, data_max, disconnect, ind;
  int			master_socket, slave_socket;
  uint64_t		rays_fired;
  void			*data, *res_buf;
  tie_t			tie;
#if TN_COMPRESSION
  int			comp_max;
  void			*comp_buf;
  unsigned long		dest_len;
#endif


  /* Initialize res_buf to NULL for realloc'ing */
  res_buf = NULL;

  if((slave_socket = socket(AF_INET, SOCK_STREAM, 0)) <= 0) {
    fprintf(stderr, "unable to create socket, exiting.\n");
    exit(1);
  }

  addrlen = sizeof(struct sockaddr_in);
  slave.sin_family = AF_INET;
  slave.sin_addr.s_addr = INADDR_ANY;
  slave.sin_port = htons(port);

  if(bind(slave_socket, (struct sockaddr*)&slave, addrlen)) {
    fprintf(stderr, "socket already bound, exiting.\n");
    exit(1);
  }

  /* listen for connections */
  listen(slave_socket, 3);

  addrlen = sizeof(slave);

  /* Handle connections from master */
  FD_ZERO(&readfds);
  FD_SET(slave_socket, &readfds);
  while(1) {
    disconnect = 0;
    select(slave_socket+1, &readfds, NULL, NULL, NULL);

    /* Accept connection from master */
    master_socket = accept(slave_socket, (struct sockaddr*)&master, &addrlen);

    /* receive endian of master */
    tienet_recv(master_socket, &tienet_endian, sizeof(short), 0);
    tienet_endian = tienet_endian == 1 ? 0 : 1;

    /* send version key, master will respond whether to continue or not */
    tienet_send(master_socket, &tienet_slave_ver_key, sizeof(int), tienet_endian);

    /* If version mismatch then exit, under normal conditions we get TN_OP_OKAY */
    tienet_recv(master_socket, &op, sizeof(short), tienet_endian);
    if(op == TN_OP_COMPLETE)
      return;

    /* Request Work Unit */
    op = TN_OP_REQWORK;
    tienet_send(master_socket, &op, sizeof(short), tienet_endian);

    data_max = 0;
    data = NULL;
#if TN_COMPRESSION
    comp_max = 0;
    comp_buf = NULL;
#endif

    if(master_socket >= 0) {
      do {
	/* Fetch Work Unit */
	tienet_recv(master_socket, &op, sizeof(short), tienet_endian);
	if(op == TN_OP_SHUTDOWN) {
	  close(master_socket);
	  close(slave_socket);
	  tienet_slave_fcb_free();
	  exit(0);
	} else if(op == TN_OP_COMPLETE) {
	  close(master_socket);
	  tienet_slave_fcb_free();
	} else if(op == TN_OP_MESSAGE) {
	  unsigned int mesg_len;
	  void *mesg;

	  /* send this message to the application */
	  tienet_recv(master_socket, &mesg_len, sizeof(unsigned int), tienet_endian);
	  mesg = malloc(mesg_len);
	  if (!mesg) {
	      perror("malloc");
	      exit(1);
	  }
	  tienet_recv(master_socket, mesg, mesg_len, 0);
	  tienet_slave_fcb_mesg(mesg, mesg_len);
	  free(mesg);
	} else if(op == TN_OP_PREP) {
	  /* This can be done better */

	  /* Clean and Reinitialize TIE */
	  tienet_slave_fcb_free();

	  if(tienet_slave_prep(master_socket, &tie)) {
	    fprintf(stderr, "version mismatch, exiting.\n");
	    close(master_socket);
	    exit(0);
	  }

	  /* Now that we've been updated, Request a Work Unit */
	  op = TN_OP_REQWORK;
	  tienet_send(master_socket, &op, sizeof(short), tienet_endian);
	} else {
	  disconnect += tienet_recv(master_socket, &size, sizeof(unsigned int), tienet_endian);

	  if(size > data_max) {
	    data_max = size;
	    data = realloc(data, size);
	  }

	  /* Process work and Generate Results */
	  disconnect += tienet_recv(master_socket, data, size, 0);

	  if(!disconnect)
	    tienet_slave_fcb_work(&tie, data, size, &res_buf, &res_len);

	  /* Send Result Back, length of: result + op_code + rays_fired + result_length + compression_length */
	  if(res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int) > data_max) {
	    data_max = res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int);
	    data = realloc(data, data_max);
	  }

	  ind = 0;
	  /* Pack Operation Code */
	  op = TN_OP_RESULT;
	  if(tienet_endian) tienet_flip(&op, &op, sizeof(short));
	  memcpy(&((char*)data)[ind], &op, sizeof(short));
	  if(tienet_endian) tienet_flip(&op, &op, sizeof(short));
	  ind += sizeof(short);

	  /* Pack total number of rays fired */
	  rays_fired = tie.rays_fired;
	  if(tienet_endian) tienet_flip(&rays_fired, &rays_fired, sizeof(uint64_t));
	  memcpy(&((char*)data)[ind], &rays_fired, sizeof(uint64_t));
	  ind += sizeof(uint64_t);

	  /* Pack Result Length */
	  if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
	  memcpy(&((char*)data)[ind], &res_len, sizeof(unsigned int));
	  if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
	  ind += sizeof(unsigned int);

#if TN_COMPRESSION
	  /* Compress the result buffer */
	  if(comp_max < res_len) {
	    comp_buf = realloc(comp_buf, res_len+32);	/* 32 bytes of extra padding for zlib */
	    comp_max = res_len;
	  }

	  dest_len = comp_max+32;
	  compress(comp_buf, &dest_len, res_buf, res_len);
	  size = (unsigned int)dest_len;

	  /* Pack Compressed Result Length */
	  if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
	  memcpy(&((char*)data)[ind], &size, sizeof(unsigned int));
	  if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
	  ind += sizeof(unsigned int);

	  /* Pack Compressed Result Data */
	  memcpy(&((char*)data)[ind], comp_buf, size);
	  ind += size;
#else
	  /* Pack Result Data */
	  memcpy(&((char*)data)[ind], res_buf, res_len);
	  ind += res_len;
d222 1
a222 9
	  disconnect += tienet_send(master_socket, data, ind, 0);
	}
      } while(op != TN_OP_COMPLETE && !disconnect);

      /* Free Data When Master disconnects */
      if(disconnect) {
	close(master_socket);
	tienet_slave_fcb_free();
      }
a223 3

    /* rebuild select list */
    FD_SET(slave_socket, &readfds);
d226 2
a227 2
  free(data);
  free(res_buf);
d229 1
a229 1
  free(comp_buf);
a232 14

int tienet_slave_prep(int slave_socket, tie_t *tie) {
  /*
  * Process and prep application data.
  * Passing the slave socket allows slave to process the data
  * on demand instead of requiring memory to spike by having it
  * all stored in one big data glob.
  */
  tienet_slave_fcb_init(tie, slave_socket);

  tie_prep(tie);
  return(0);
}

@


1.14
log
@give adrt some distinctiveness in the header
@
text
@d32 1
a32 1
 * $Id: tienet_slave.c,v 1.13 2007/01/27 01:41:30 brlcad Exp $
d198 4
d386 4
@


1.13
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d2 1
a2 1
 * BRL-CAD
d32 1
a32 1
 * $Id: tienet_slave.c,v 1.12 2007/01/23 01:13:22 brlcad Exp $
@


1.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d32 1
a32 1
 * $Id: tienet_slave.c,v 1.11 2007/01/21 00:50:29 brlcad Exp $
d78 5
a82 5
                       void fcb_init(tie_t *tie, int socknum),
                       void fcb_work(tie_t *tie, void *data, unsigned int size, void **res_buf, unsigned int *res_len),
                       void fcb_free(void),
                       void fcb_mesg(void *mesg, unsigned int mesg_len),
                       int ver_key)
d208 3
a210 3
        fprintf(stderr, "version mismatch, exiting.\n");
        close(slave_socket);
        exit(0);
d219 2
a220 2
        data_max = size;
        data = realloc(data, size);
d229 2
a230 2
        data_max = res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int);
        data = realloc(data, data_max);
d256 2
a257 2
        comp_buf = realloc(comp_buf, res_len+32);	/* 32 bytes of extra padding for zlib */
        comp_max = res_len;
d365 74
a438 74
        /* Fetch Work Unit */
        tienet_recv(master_socket, &op, sizeof(short), tienet_endian);
        if(op == TN_OP_SHUTDOWN) {
          close(master_socket);
          close(slave_socket);
          tienet_slave_fcb_free();
          exit(0);
        } else if(op == TN_OP_COMPLETE) {
          close(master_socket);
          tienet_slave_fcb_free();
        } else if(op == TN_OP_MESSAGE) {
          unsigned int mesg_len;
          void *mesg;

          /* send this message to the application */
          tienet_recv(master_socket, &mesg_len, sizeof(unsigned int), tienet_endian);
          mesg = malloc(mesg_len);
          tienet_recv(master_socket, mesg, mesg_len, 0);
          tienet_slave_fcb_mesg(mesg, mesg_len);
          free(mesg);
        } else if(op == TN_OP_PREP) {
          /* This can be done better */

          /* Clean and Reinitialize TIE */
          tienet_slave_fcb_free();

          if(tienet_slave_prep(master_socket, &tie)) {
            fprintf(stderr, "version mismatch, exiting.\n");
            close(master_socket);
            exit(0);
          }

          /* Now that we've been updated, Request a Work Unit */
          op = TN_OP_REQWORK;
          tienet_send(master_socket, &op, sizeof(short), tienet_endian);
        } else {
          disconnect += tienet_recv(master_socket, &size, sizeof(unsigned int), tienet_endian);

          if(size > data_max) {
            data_max = size;
            data = realloc(data, size);
          }

          /* Process work and Generate Results */
          disconnect += tienet_recv(master_socket, data, size, 0);

          if(!disconnect)
            tienet_slave_fcb_work(&tie, data, size, &res_buf, &res_len);

          /* Send Result Back, length of: result + op_code + rays_fired + result_length + compression_length */
          if(res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int) > data_max) {
            data_max = res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int);
            data = realloc(data, data_max);
          }

          ind = 0;
          /* Pack Operation Code */
          op = TN_OP_RESULT;
          if(tienet_endian) tienet_flip(&op, &op, sizeof(short));
          memcpy(&((char*)data)[ind], &op, sizeof(short));
          if(tienet_endian) tienet_flip(&op, &op, sizeof(short));
          ind += sizeof(short);

          /* Pack total number of rays fired */
          rays_fired = tie.rays_fired;
          if(tienet_endian) tienet_flip(&rays_fired, &rays_fired, sizeof(uint64_t));
          memcpy(&((char*)data)[ind], &rays_fired, sizeof(uint64_t));
          ind += sizeof(uint64_t);

          /* Pack Result Length */
          if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
          memcpy(&((char*)data)[ind], &res_len, sizeof(unsigned int));
          if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
          ind += sizeof(unsigned int);
d441 19
a459 19
          /* Compress the result buffer */
          if(comp_max < res_len) {
            comp_buf = realloc(comp_buf, res_len+32);	/* 32 bytes of extra padding for zlib */
            comp_max = res_len;
          }

          dest_len = comp_max+32;
          compress(comp_buf, &dest_len, res_buf, res_len);
          size = (unsigned int)dest_len;

          /* Pack Compressed Result Length */
          if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
          memcpy(&((char*)data)[ind], &size, sizeof(unsigned int));
          if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
          ind += sizeof(unsigned int);

          /* Pack Compressed Result Data */
          memcpy(&((char*)data)[ind], comp_buf, size);
          ind += size;
d461 3
a463 3
          /* Pack Result Data */
          memcpy(&((char*)data)[ind], res_buf, res_len);
          ind += res_len;
d465 2
a466 2
          disconnect += tienet_send(master_socket, data, ind, 0);
        }
d471 2
a472 2
        close(master_socket);
        tienet_slave_fcb_free();
@


1.11
log
@standard header and footer cleanup
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
d32 1
a32 1
 * $Id: tienet_slave.c,v 1.10 2007/01/20 14:36:41 brlcad Exp $
@


1.10
log
@update copyright to 2007
@
text
@d1 1
a1 4
/*                     S L A V E . C
 *
 * @@file slave.c
 *
d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d19 2
d32 1
a32 1
 * $Id: tienet_slave.c,v 1.9 2006/01/18 06:46:12 brlcad Exp $
d500 10
@


1.9
log
@update copyright to 2006
@
text
@d7 1
a7 1
 * Copyright (c) 2002-2006 United States Government as represented by
d34 1
a34 1
 * $Id: tienet_slave.c,v 1.8 2005/10/23 04:44:28 brlcad Exp $
@


1.8
log
@trailing ws
@
text
@d7 1
a7 1
 * Copyright (C) 2002-2005 United States Government as represented by
d34 1
a34 1
 * $Id: tienet_slave.c,v 1.7 2005/09/10 19:16:29 twingy Exp $
@


1.7
log
@stuff to fix 32/64 communication
@
text
@d34 1
a34 1
 * $Id: tienet_slave.c,v 1.6 2005/09/09 22:06:26 twingy Exp $
d265 1
a265 1
    
d451 1
a451 1
          size = (unsigned int)dest_len;    
d491 1
a491 1
  /* 
@


1.6
log
@fixed 64/32 bit network communications bug in tienet.
@
text
@d34 1
a34 1
 * $Id: tienet_slave.c,v 1.5 2005/07/28 00:28:30 twingy Exp $
a53 8
void	tienet_slave_init(int port,
                          char *host,
                          void fcb_init(tie_t *tie, int socknum),
                          void fcb_work(tie_t *tie, void *data, int size, void **res_buf, int *res_len),
                          void fcb_free(void),
                          void fcb_mesg(void *mesg, int mesg_len),
                          int ver_key);
void	tienet_slave_free(void);
d67 1
a67 1
typedef void tienet_slave_fcb_work_t(tie_t *tie, void *data, int size, void **res_buf, int *res_len);
d75 1
a75 1
typedef void tienet_slave_fcb_mesg_t(void *mesg, int mesg_len);
d81 1
a81 1
                       void fcb_work(tie_t *tie, void *data, int size, void **res_buf, int *res_len),
d83 1
a83 1
                       void fcb_mesg(void *mesg, int mesg_len),
d91 1
d194 2
a195 2
      int	mesg_len;
      void	*mesg;
d198 1
a198 1
      tienet_recv(slave_socket, &mesg_len, sizeof(int), tienet_endian);
d219 1
a219 1
      tienet_recv(slave_socket, &size, sizeof(int), tienet_endian);
d250 4
a253 4
      if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(int));
      memcpy(&((char*)data)[ind], &res_len, sizeof(int));
      if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(int));
      ind += sizeof(int);
d378 2
a379 2
          int	mesg_len;
          void	*mesg;
d382 1
a382 1
          tienet_recv(master_socket, &mesg_len, sizeof(int), tienet_endian);
d403 1
a403 1
          disconnect += tienet_recv(master_socket, &size, sizeof(int), tienet_endian);
d437 4
a440 4
          if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(int));
          memcpy(&((char*)data)[ind], &res_len, sizeof(int));
          if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(int));
          ind += sizeof(int);
@


1.5
log
@* Overall load time for all 8 nodes during startup is 25% faster.
* File size of adrt mesh is now 33% smaller.  It uses shortst when trinum
  of the mesh is under 64K triangles.
* Prep data to slaves is now multi-threaded (all slaves get data from
  master at the same time, heavy network load).
@
text
@d34 1
a34 1
 * $Id: tienet_slave.c,v 1.4 2005/07/27 17:43:59 twingy Exp $
d123 2
a124 1
  int			slave_socket, size, res_len, data_max, ind;
d237 2
a238 2
      if(res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(long) > data_max) {
        data_max = res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(long);
d271 1
d274 4
a277 4
      if(tienet_endian) tienet_flip(&dest_len, &dest_len, sizeof(long));
      memcpy(&((char*)data)[ind], &dest_len, sizeof(long));
      if(tienet_endian) tienet_flip(&dest_len, &dest_len, sizeof(long));
      ind += sizeof(long);
d280 2
a281 2
      memcpy(&((char*)data)[ind], comp_buf, dest_len);
      ind += dest_len;
d304 2
a305 1
  int			master_socket, slave_socket, size, res_len, data_max, disconnect, ind;
d424 2
a425 2
          if(res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(long) > data_max) {
            data_max = res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(long);
d458 2
a459 1
    
d461 4
a464 4
          if(tienet_endian) tienet_flip(&dest_len, &dest_len, sizeof(long));
          memcpy(&((char*)data)[ind], &dest_len, sizeof(long));
          if(tienet_endian) tienet_flip(&dest_len, &dest_len, sizeof(long));
          ind += sizeof(long);
d467 2
a468 2
          memcpy(&((char*)data)[ind], comp_buf, dest_len);
          ind += dest_len;
@


1.5.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d34 1
a34 1
 * $Id$
d54 8
d75 1
a75 1
typedef void tienet_slave_fcb_work_t(tie_t *tie, void *data, unsigned int size, void **res_buf, unsigned int *res_len);
d83 1
a83 1
typedef void tienet_slave_fcb_mesg_t(void *mesg, unsigned int mesg_len);
d89 1
a89 1
                       void fcb_work(tie_t *tie, void *data, unsigned int size, void **res_buf, unsigned int *res_len),
d91 1
a91 1
                       void fcb_mesg(void *mesg, unsigned int mesg_len),
a98 1

d123 1
a123 2
  unsigned int		size, res_len, data_max, ind;
  int			slave_socket;
d200 2
a201 2
      unsigned int mesg_len;
      void *mesg;
d204 1
a204 1
      tienet_recv(slave_socket, &mesg_len, sizeof(unsigned int), tienet_endian);
d225 1
a225 1
      tienet_recv(slave_socket, &size, sizeof(unsigned int), tienet_endian);
d236 2
a237 2
      if(res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int) > data_max) {
        data_max = res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int);
d256 4
a259 4
      if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
      memcpy(&((char*)data)[ind], &res_len, sizeof(unsigned int));
      if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
      ind += sizeof(unsigned int);
d270 1
a270 2
      size = (unsigned int)dest_len;

d272 4
a275 4
      if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
      memcpy(&((char*)data)[ind], &size, sizeof(unsigned int));
      if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
      ind += sizeof(unsigned int);
d278 2
a279 2
      memcpy(&((char*)data)[ind], comp_buf, size);
      ind += size;
d302 1
a302 2
  unsigned int		size, res_len, data_max, disconnect, ind;
  int			master_socket, slave_socket;
d382 2
a383 2
          unsigned int mesg_len;
          void *mesg;
d386 1
a386 1
          tienet_recv(master_socket, &mesg_len, sizeof(unsigned int), tienet_endian);
d407 1
a407 1
          disconnect += tienet_recv(master_socket, &size, sizeof(unsigned int), tienet_endian);
d421 2
a422 2
          if(res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int) > data_max) {
            data_max = res_len+sizeof(short)+sizeof(uint64_t)+sizeof(int)+sizeof(unsigned int);
d441 4
a444 4
          if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
          memcpy(&((char*)data)[ind], &res_len, sizeof(unsigned int));
          if(tienet_endian) tienet_flip(&res_len, &res_len, sizeof(unsigned int));
          ind += sizeof(unsigned int);
d455 1
a455 2
          size = (unsigned int)dest_len;

d457 4
a460 4
          if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
          memcpy(&((char*)data)[ind], &size, sizeof(unsigned int));
          if(tienet_endian) tienet_flip(&size, &size, sizeof(unsigned int));
          ind += sizeof(unsigned int);
d463 2
a464 2
          memcpy(&((char*)data)[ind], comp_buf, size);
          ind += size;
d494 1
a494 1
  /*
@


1.4
log
@* Fixed the rendering weirdness on the slave start-up
  Slaves were requesting a work unit right after prep begins
  so that slaves were holding onto a work unit for a lengthy time
  until prep finished and causing the units to not get done until
  prep finished.
* Added compute nodes status to observer.
* Added Scale Factor status to observer.
* Changed bytes transfered to mibi bytes instead of kilobytes.
@
text
@d34 1
a34 1
 * $Id: tienet_slave.c,v 1.3 2005/07/20 18:37:07 twingy Exp $
d182 1
a182 1
  /* Fetch Work Unit */
d220 4
a393 1
printf("PREP_A\n");
a401 1
printf("PREP_B\n");
a419 1

@


1.3
log
@* Data on demand to nodes (~20% mem savings).
* tlist memory leak in unpack.c fixed.
* BSP Depth Visualization rendering method.
* Split Plane Coloring
* Testing more efficient BSP methods.
@
text
@d34 1
a34 1
 * $Id: tienet_slave.c,v 1.2 2005/06/18 21:58:58 twingy Exp $
d349 1
a349 1
    /* If version mismatch then exit */
d354 1
a354 1
    /* Fetch Work Unit */
a357 1

d390 1
d399 5
@


1.2
log
@Added licensing info to libtexture files.
@
text
@d34 1
a34 1
 * $Id: tienet_slave.c,v 1.1 2005/06/18 06:40:40 twingy Exp $
d56 1
a56 1
                          void fcb_init(tie_t *tie, void *app_data, int app_size),
d71 1
a71 1
typedef void tienet_slave_fcb_init_t(tie_t *tie, void *app_data, int app_size);
d88 1
a88 1
                       void fcb_init(tie_t *tie, void *app_data, int app_size),
d488 7
a494 12
  int app_size;
  void *app_data;

  /* receive application data */
  tienet_recv(slave_socket, &app_size, sizeof(int), tienet_endian);
  app_data = malloc(app_size);
  tienet_recv(slave_socket, app_data, app_size, 0);

  /* process and prep application data */
  tienet_slave_fcb_init(tie, app_data, app_size);

  free(app_data);
@


1.2.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d34 1
a34 1
 * $Id: tienet_slave.c,v 1.5 2005/07/28 00:28:30 twingy Exp $
d56 1
a56 1
                          void fcb_init(tie_t *tie, int socknum),
d71 1
a71 1
typedef void tienet_slave_fcb_init_t(tie_t *tie, int socknum);
d88 1
a88 1
                       void fcb_init(tie_t *tie, int socknum),
d182 1
a182 1
  /* Request Work Unit */
a219 4

      /* Now that we've been updated, Request a Work Unit */
      op = TN_OP_REQWORK;
      tienet_send(slave_socket, &op, sizeof(short), tienet_endian);
d349 1
a349 1
    /* If version mismatch then exit, under normal conditions we get TN_OP_OKAY */
d354 1
a354 1
    /* Request Work Unit */
d358 1
a398 4

          /* Now that we've been updated, Request a Work Unit */
          op = TN_OP_REQWORK;
          tienet_send(master_socket, &op, sizeof(short), tienet_endian);
d413 1
d488 12
a499 7
  /* 
  * Process and prep application data.
  * Passing the slave socket allows slave to process the data
  * on demand instead of requiring memory to spike by having it
  * all stored in one big data glob.
  */
  tienet_slave_fcb_init(tie, slave_socket);
@


1.1
log
@
fixing linking problems to get adrt to properly link to brlcad.
@
text
@d2 3
a22 3
 */
/** @@file slave.c
 *                     S L A V E . C
d24 2
a25 1
 *  TIE Networking Slave
d34 1
a34 1
 * $Id: slave.c,v 1.2 2005/06/18 01:09:31 twingy Exp $
@

