head	1.23;
access;
symbols
	rel-7-10-4:1.18
	STABLE:1.18.0.2
	rel-7-10-2:1.17
	rel-7-10-0:1.17
	rel-7-8-4:1.9
	rel-7-8-2:1.9
	rel-7-8-0:1.9
	trimnurbs-branch:1.9.0.2
	help:1.9
	temp_tag:1.8
	bobWinPort-20051223-freeze:1.5
	postmerge-20051223-bobWinPort:1.8
	premerge-20051223-bobWinPort:1.8
	rel-7-6-6:1.8
	rel-7-6-4:1.8
	rel-7-6-2:1.5
	rel-7-6-branch:1.5.0.4
	rel-7-6-0:1.5
	rel-7-4-2:1.3.2.1
	rel-7-4-branch:1.3.0.2
	bobWinPort:1.5.0.2
	rel-7-4-0:1.3;
locks; strict;
comment	@ * @;


1.23
date	2007.12.16.18.53.47;	author brlcad;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.06.05.23.14;	author brlcad;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.05.15.33.42;	author erikgreenwald;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.04.21.57.59;	author erikgreenwald;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.14.08.01.45;	author brlcad;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.30.19.11.30;	author brlcad;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.28.18.57.35;	author erikgreenwald;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.20.20.05.08;	author brlcad;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.08.06.49.19;	author brlcad;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.02.19.46.35;	author erikgreenwald;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.27.01.41.30;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.23.01.13.22;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.21.00.50.29;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.20.14.36.41;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.18.06.46.12;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.10.19.16.29;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.09.22.06.26;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.28.00.28.29;	author twingy;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2005.07.27.17.43.59;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.08.20.00.48;	author twingy;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2005.06.18.21.58.58;	author twingy;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.18.06.40.40;	author twingy;	state Exp;
branches;
next	;

1.3.2.1
date	2005.08.16.21.03.47;	author brlcad;	state Exp;
branches;
next	;

1.5.4.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.23
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                 T I E N E T _ M A S T E R . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file tienet_master.c
 *
 *  Comments -
 *      TIE Networking Master
 *
 *  Author -
 *      Justin L. Shumaker
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 * $Id: tienet_master.c,v 1.22 2007/12/06 05:23:14 brlcad Exp $
 */

#include "tienet_master.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include "tie.h"
#include "tienet_define.h"
#include "tienet_util.h"

#if TN_COMPRESSION
# include <zlib.h>
#endif


typedef struct tienet_master_data_s {
  void *data;
  int size;	/* Current size of work in bytes */
} tienet_master_data_t;


typedef struct tienet_master_socket_s {
  int active;	/* Once a slave has completed its first work unit this becomes 1 */
  int idle;	/* When a slave has finished a work unit and there's nothing left for it to work on */
  int num;
  tienet_master_data_t mesg;	/* Used for a broadcast message */
  tienet_master_data_t work;	/* The work unit currently being processed */
  struct tienet_master_socket_s *prev;
  struct tienet_master_socket_s *next;
} tienet_master_socket_t;


void				tienet_master_init(int port, void fcb_result(tienet_buffer_t *result), char *list, char *exec, int buffer_size, int ver_key, int verbose);
void				tienet_master_free(void);
void				tienet_master_push(void *data, int size);
void				tienet_master_shutdown(void);
void				tienet_master_broadcast(void *mesg, int mesg_len);

void				tienet_master_begin(void);
void				tienet_master_end(void);
void				tienet_master_wait(void);

void				tienet_master_connect_slaves(fd_set *readfds);
void*				tienet_master_listener(void *ptr);
void				tienet_master_send_work(tienet_master_socket_t *sock);
void				tienet_master_result(tienet_master_socket_t *sock);
void				tienet_master_shutdown(void);

static int			tienet_master_ver_key;
static int			tienet_master_port;
static int			tienet_master_highest_fd;

int				tienet_master_active_slaves;
int				tienet_master_socket_num;
static tienet_master_socket_t	*tienet_master_socket_list;
static tienet_master_socket_t	*tienet_master_dead_socket_list;

int				tienet_master_buffer_size;
static tienet_master_data_t	*tienet_master_buffer;		/* Buffer */
static int			tienet_master_pos_fill;
static int			tienet_master_pos_read;

static tienet_sem_t		tienet_master_sem_fill;	/* Fill Buffer Semaphore */
static tienet_sem_t		tienet_master_sem_read;	/* Read Buffer Semaphore */
static tienet_sem_t		tienet_master_sem_app;	/* Application Semaphore */
static tienet_sem_t		tienet_master_sem_out;	/* Outstanding Semaphore */
static tienet_sem_t		tienet_master_sem_shutdown; /* Shutdown Semaphore */

uint64_t			tienet_master_transfer;
static char			tienet_master_exec[64];	/* Something to run in order to jumpstart the slaves */
static char			tienet_master_list[64]; /* A list of slaves in daemon mode to connect to */
int				tienet_master_verbose;
int				tienet_master_endflag;
int				tienet_master_shutdown_state;
int				tienet_master_halt_networking;

tienet_buffer_t			tienet_master_result_buffer;
pthread_mutex_t			tienet_master_send_mut;
pthread_mutex_t			tienet_master_push_mut;
pthread_mutex_t			tienet_master_broadcast_mut;


#if TN_COMPRESSION
tienet_buffer_t			tienet_master_result_buffer_comp;
#endif

/* result data callback */
typedef void tienet_master_fcb_result_t(tienet_buffer_t *result);
tienet_master_fcb_result_t	*tienet_master_fcb_result;


void tienet_master_init(int port, void fcb_result(tienet_buffer_t *result), char *list, char *exec, int buffer_size, int ver_key, int verbose)
{
  pthread_t thread;
  int i;


  tienet_master_port = port;
  tienet_master_verbose = verbose;
  tienet_master_buffer_size = buffer_size;
  tienet_master_buffer = (tienet_master_data_t *)malloc(sizeof(tienet_master_data_t) * tienet_master_buffer_size);

  tienet_master_fcb_result = fcb_result;
  tienet_master_active_slaves = 0;
  tienet_master_socket_num = 0;
  tienet_master_socket_list = NULL;
  tienet_master_dead_socket_list = NULL;

  tienet_master_transfer = 0;
  tienet_master_endflag = 0;
  tienet_master_shutdown_state = 0;
  tienet_master_halt_networking = 0;

  tienet_master_pos_fill = 0;
  tienet_master_pos_read = 0;

  TIENET_BUFFER_INIT(tienet_master_result_buffer);
#if TN_COMPRESSION
  TIENET_BUFFER_INIT(tienet_master_result_buffer_comp);
#endif

  strncpy(tienet_master_list, list, 64-1);
  strncpy(tienet_master_exec, exec, 64-1);

  /* Copy version key to validate slaves of correct version are connecting */
  tienet_master_ver_key = ver_key;

  /* Force the first slave that connects to perform a Fill Buffer -> Read Buffer Move */
  tienet_sem_init(&tienet_master_sem_fill, 0);
  tienet_sem_init(&tienet_master_sem_read, 0);

  /* Allow the application to fill the buffer with tienet_master_buffer_size */
  for (i = 0; i < tienet_master_buffer_size; i++)
  {
    tienet_master_buffer[i].data = NULL;
    tienet_master_buffer[i].size = 0;
    tienet_sem_post(&tienet_master_sem_fill);
  }

  tienet_sem_init(&tienet_master_sem_app, 0);
  tienet_sem_init(&tienet_master_sem_out, 0);
  pthread_mutex_init(&tienet_master_send_mut, 0);
  pthread_mutex_init(&tienet_master_push_mut, 0);
  pthread_mutex_init(&tienet_master_broadcast_mut, 0);
  
  /* Start the Listener as a Thread */
  pthread_create(&thread, NULL, tienet_master_listener, NULL);
}


void tienet_master_free()
{
  int i;
  tienet_master_socket_t *sock;

  tienet_sem_free(&tienet_master_sem_fill);
  tienet_sem_free(&tienet_master_sem_read);
  tienet_sem_free(&tienet_master_sem_app);
  tienet_sem_free(&tienet_master_sem_out);

  TIENET_BUFFER_FREE(tienet_master_result_buffer);
#if TN_COMPRESSION
  TIENET_BUFFER_FREE(tienet_master_result_buffer_bomp);
#endif
  free(tienet_master_buffer);

  for (i = 0; i < tienet_master_buffer_size; i++)
    free(tienet_master_buffer[i].data);

  for (sock = tienet_master_socket_list->next; sock; sock = sock->next)
    free(sock->prev);
}


void tienet_master_push(void *data, int size)
{
  tienet_master_socket_t *socket, *tmp;
  short op;

  pthread_mutex_lock(&tienet_master_push_mut);

  op = TN_OP_SENDWORK;

  /* Decrement semaphore */
  tienet_sem_wait(&tienet_master_sem_fill);

  /* Fill buffer, Grow if necessary */
  if (sizeof(short) + sizeof(int) + size > tienet_master_buffer[tienet_master_pos_fill].size)
  {
    tienet_master_buffer[tienet_master_pos_fill].size = sizeof(short) + sizeof(int) + size;
    tienet_master_buffer[tienet_master_pos_fill].data = realloc(tienet_master_buffer[tienet_master_pos_fill].data, tienet_master_buffer[tienet_master_pos_fill].size);
  }
  TCOPY(short, &op, 0, tienet_master_buffer[tienet_master_pos_fill].data, 0);
  TCOPY(int, &size, 0, tienet_master_buffer[tienet_master_pos_fill].data, sizeof(short));
  memcpy(&((char *)(tienet_master_buffer[tienet_master_pos_fill].data))[sizeof(short) + sizeof(int)], data, size);

  /* Circular Increment */
  tienet_master_pos_fill = (tienet_master_pos_fill + 1) % tienet_master_buffer_size;
  tienet_sem_post(&tienet_master_sem_read);

  /* Process items in tienet_master_DeadSocketList */
  for (socket = tienet_master_dead_socket_list; socket;)
  {
    tienet_sem_wait(&tienet_master_sem_fill);
    TCOPY(int, &(socket->work.size), 0, &size, 0);

    /* Fill buffer, Grow if necessary */
    if (sizeof(short) + sizeof(int) + size > tienet_master_buffer[tienet_master_pos_fill].size)
    {
      tienet_master_buffer[tienet_master_pos_fill].size = sizeof(short) + sizeof(int) + size;
      tienet_master_buffer[tienet_master_pos_fill].data = realloc(tienet_master_buffer[tienet_master_pos_fill].data, tienet_master_buffer[tienet_master_pos_fill].size);
    }
    memcpy(tienet_master_buffer[tienet_master_pos_fill].data, socket->work.data, sizeof(short) + sizeof(int) + size);

    /* Circular Increment */
    tienet_master_pos_fill = (tienet_master_pos_fill + 1) % tienet_master_buffer_size;

    tmp = socket;
    if (socket == tienet_master_dead_socket_list)
      tienet_master_dead_socket_list = tienet_master_dead_socket_list->next;
    socket = socket->next;

    free(tmp->work.data);
    free(tmp);

    tienet_sem_post(&tienet_master_sem_read);
  }

  
  /*
  * Tell any idle slaves to get back to work.
  * This is the case where slaves have exhausted the work buffer,
  * then new work becomes available.
  */
  for (socket = tienet_master_socket_list; socket; socket = socket->next)
  {
    /* Only if not master socket do we send data to slave */
    if (socket->next && socket->idle)
      tienet_master_send_work(socket);
  }

  pthread_mutex_unlock(&tienet_master_push_mut);
}


void tienet_master_begin()
{
  if (!tienet_master_sem_app.val)
    tienet_master_endflag = 0;
}


void tienet_master_end()
{
  tienet_master_endflag = 1;
}


void tienet_master_wait()
{
  tienet_sem_wait(&tienet_master_sem_app);
}


void tienet_master_connect_slaves(fd_set *readfds)
{
  FILE				*fh;
  struct	sockaddr_in	daemon, slave;
  struct	hostent		slave_ent;
  tienet_master_socket_t	*tmp;
  short				op;
  char				host[64], *temp;
  int				daemon_socket, port, slave_ver_key;


  fh = fopen(tienet_master_list, "r");
  if (fh)
  {
    while(!feof(fh))
    {
      fgets(host, 64, fh);
      if (host[0])
      {
        port = TN_SLAVE_PORT;
        temp = strchr(host, ':');
        if (temp)
        {
          port = atoi(&temp[1]);
          temp[0] = 0;
        }
        else
        {
          host[strlen(host)-1] = 0;
        }

        /* check to see if this slave is in dns */
        if (gethostbyname(host))
        {
          slave_ent = gethostbyname(host)[0];

          /* This is what we're connecting to */
          slave.sin_family = slave_ent.h_addrtype;
          memcpy((char *)&slave.sin_addr.s_addr, slave_ent.h_addr_list[0], slave_ent.h_length);
          slave.sin_port = htons(port);

          /* Make a communications socket that will get stuffed into the list */
          daemon_socket = socket(AF_INET, SOCK_STREAM, 0);
          if (daemon_socket < 0)
          {
            fprintf(stderr, "unable to create  socket, exiting.\n");
            exit(1);
          }

          daemon.sin_family = AF_INET;
          daemon.sin_addr.s_addr = htonl(INADDR_ANY);
          daemon.sin_port = htons(0);

          if (bind(daemon_socket, (struct sockaddr *)&daemon, sizeof(daemon)) < 0)
          {
            fprintf(stderr, "unable to bind socket, exiting.\n");
            exit(1);
          }

          /* Make an attempt to connect to this host and initiate work */
          if (connect(daemon_socket, (struct sockaddr *)&slave, sizeof(slave)) < 0)
          {
            fprintf(stderr, "cannot connect to slave: %s:%d, skipping.\n", host, port);
          }
          else
          {
            /* Send endian to slave */
            op = 1;
            tienet_send(daemon_socket, &op, sizeof(short), 0);

            /* Read Version Key and Compare to ver_key, if valid proceed, if not tell slave to disconnect */
            tienet_recv(daemon_socket, &slave_ver_key, sizeof(int), 0);
            if (slave_ver_key != tienet_master_ver_key)
            {
              op = TN_OP_COMPLETE;
              tienet_send(daemon_socket, &op, sizeof(short), 0);
            }
            else
            {
              op = TN_OP_OKAY;
              tienet_send(daemon_socket, &op, sizeof(short), 0);

              /* Append to select list */
              tmp = tienet_master_socket_list;
              tienet_master_socket_list = (tienet_master_socket_t *)malloc(sizeof(tienet_master_socket_t));
              tienet_master_socket_list->next = tmp;
              tienet_master_socket_list->prev = NULL;
              tienet_master_socket_list->work.data = NULL;
              tienet_master_socket_list->work.size = 0;
              tienet_master_socket_list->mesg.data = NULL;
              tienet_master_socket_list->mesg.size = 0;
              tienet_master_socket_list->num = daemon_socket;
              tienet_master_socket_list->active = 0;
              tienet_master_socket_list->idle = 1;

              tmp->prev = tienet_master_socket_list;
              tienet_master_socket_num++;
              FD_SET(daemon_socket, readfds);

              /* Check to see if it's the new highest */
              if (daemon_socket > tienet_master_highest_fd)
                tienet_master_highest_fd = daemon_socket;
            }
          }
        }
        else
        {
          fprintf(stderr, "unknown host: %s, skipping.\n", host);
        }
      }
      host[0] = 0;
    }
    fclose(fh);
  }
}


void* tienet_master_listener(void *ptr)
{
  struct	sockaddr_in	master, slave;
  socklen_t			addrlen;
  fd_set			readfds;
  tienet_master_socket_t	*sock, *tmp;
  int				r, master_socket, slave_socket, slave_ver_key;
  short				op;


  if ((master_socket = socket(AF_INET, SOCK_STREAM, 0)) <= 0)
  {
    fprintf(stderr, "cannot creating socket, exiting.\n");
    exit(1);
  }

  addrlen = sizeof(struct sockaddr_in);
  master.sin_family = AF_INET;
  master.sin_addr.s_addr = INADDR_ANY;
  master.sin_port = htons(tienet_master_port);

  if (bind(master_socket, (struct sockaddr *)&master, addrlen))
  {
    fprintf(stderr, "socket already bound, exiting.\n");
    exit(1);
  }

  /* Set first socket as master, rest are slaves - LIFO Stack - Always gets processed last */
  tienet_master_socket_list = (tienet_master_socket_t *)malloc(sizeof(tienet_master_socket_t));
  tienet_master_socket_list->next = NULL;
  tienet_master_socket_list->prev = NULL;
  tienet_master_socket_list->work.data = NULL;
  tienet_master_socket_list->work.size = 0;
  tienet_master_socket_list->mesg.data = NULL;
  tienet_master_socket_list->mesg.size = 0;
  tienet_master_socket_list->num = master_socket;
  tienet_master_highest_fd = master_socket;

  /* Listen for connections */
  listen(master_socket, 3);

  addrlen = sizeof(slave);

  FD_ZERO(&readfds);
  FD_SET(master_socket, &readfds);

  /* Execute script - used for spawning slaves */
  system(tienet_master_exec);

  /* Process slave host list - used for connecting to running daemons */
  tienet_master_connect_slaves(&readfds);

  /* Handle Network Communications */
  while(1)
  {
    select(tienet_master_highest_fd+1, &readfds, NULL, NULL, NULL);

    /*
    * Kill this thread if the shutdown call has been made and work
    * units that were out have come back in.
    */
    if (tienet_master_halt_networking)
      return(NULL);


    /* Slave Communication */
    for (sock = tienet_master_socket_list; sock; sock = sock->next)
    {
      if (FD_ISSET(sock->num, &readfds))
      {
        if (sock->num == master_socket)
        {
          /* New Connections, Always LAST in readfds list */
          slave_socket = accept(master_socket, (struct sockaddr *)&slave, &addrlen);
          if (slave_socket >= 0)
          {
            if (tienet_master_verbose)
              printf ("The slave %s has connected on port: %d, sock_num: %d\n", inet_ntoa(slave.sin_addr), tienet_master_port, slave_socket);
            tmp = tienet_master_socket_list;
            tienet_master_socket_list = (tienet_master_socket_t *)malloc(sizeof(tienet_master_socket_t));
            tienet_master_socket_list->next = tmp;
            tienet_master_socket_list->prev = NULL;
            tienet_master_socket_list->work.data = NULL;
            tienet_master_socket_list->work.size = 0;
            tienet_master_socket_list->mesg.data = NULL;
            tienet_master_socket_list->mesg.size = 0;
            tienet_master_socket_list->num = slave_socket;
            tienet_master_socket_list->active = 0;
            tienet_master_socket_list->idle = 1;
            tmp->prev = tienet_master_socket_list;
            tienet_master_socket_num++;

            /* Send endian to slave */
            op = 1;
            tienet_send(slave_socket, &op, sizeof(short), 0);
            /* Read Version Key and Compare to ver_key, if valid proceed, if not tell slave to disconnect */
            tienet_recv(slave_socket, &slave_ver_key, sizeof(int), 0);
            if (slave_ver_key != tienet_master_ver_key)
            {
              op = TN_OP_COMPLETE;
              tienet_send(slave_socket, &op, sizeof(short), 0);
            }
            else
            {
              /* Version is okay, proceed */
              op = TN_OP_OKAY;
              tienet_send(slave_socket, &op, sizeof(short), 0);

              /* Append to select list */
              if (slave_socket > tienet_master_highest_fd)
                tienet_master_highest_fd = slave_socket;
            }

            /* Send some work */
//            tienet_master_send_work(sock);
          }
        }
        else
        {
          /* Make sure socket is still active on this recv */
          r = tienet_recv(sock->num, &op, sizeof(short), 0);
          /* if "r", error code returned, remove slave from pool */
          if (r)
          {
            tienet_master_socket_t		*tmp2;
            /* Because master socket is always last there is no need to check if "next" exists.
             * Remove this socket from chain and link prev and next up to fill gap. */
            if (sock->prev)
              sock->prev->next = sock->next;
            sock->next->prev = sock->prev;

            /* Store ptr to sock before we modify it */
            tmp = sock;
            /* If the socket is the head then we need to not only modify the socket,
             * but the head as well. */
            if (tienet_master_socket_list == sock)
              tienet_master_socket_list = sock->next;
            sock = sock->prev ? sock->prev : sock->next;

            /* Put the socket into the tienet_master_DeadSocketList */
            if (tienet_master_dead_socket_list)
            {
              tmp2 = tienet_master_dead_socket_list;
              tienet_master_dead_socket_list = tmp;
              tienet_master_dead_socket_list->prev = NULL;
              tienet_master_dead_socket_list->next = tmp2;
              tmp2->prev = tienet_master_dead_socket_list;
            }
            else
            {
              tienet_master_dead_socket_list = tmp;
              tienet_master_dead_socket_list->next = NULL;
              tienet_master_dead_socket_list->prev = NULL;
            }

            tienet_master_socket_num--;
          }
          else
          {
            /*
            * Slave Op Instructions
            */
            switch(op)
            {
              case TN_OP_REQWORK:
                tienet_master_send_work(sock);
                break;

              case TN_OP_RESULT:
                tienet_master_result(sock);
                break;

              default:
                break;
            }
          }
        }
      }
    }

    /* Rebuild select list for next select call */
    tienet_master_highest_fd = 0;
    for (sock = tienet_master_socket_list; sock; sock = sock->next)
    {
      if (sock->num > tienet_master_highest_fd)
        tienet_master_highest_fd = sock->num;
      FD_SET(sock->num, &readfds);
    }
  }
}


void tienet_master_send_work(tienet_master_socket_t *sock)
{
  int size;
  short op;

  /* 
  * This exists to prevent a collision from tienet_master_push calling this function
  * as a result of a socket being idle and then given work.  If this function were called
  * and 2 threads entered the if (tienet_master_sem_read.val) block and waited on tienet_master_sem_read
  * with the first one hitting the wait on a value of one the other one could end up waiting forever.
  */
  pthread_mutex_lock(&tienet_master_send_mut);

  /*
  * If shutdown has been initiated, do not send any data to the slaves,
  * instead they need to wait for a shutdown message.
  */
  if (tienet_master_shutdown_state)
  {
    /* if no work units are out, allow the shutdown to proceed. */
    if (!tienet_master_sem_out.val)
      tienet_sem_post(&tienet_master_sem_shutdown);
    return;
  }


  /*
  * Check to see if a broadcast message is sitting in the queue.
  * The mutex prevents a read and write from occuring at the same time.
  */
  pthread_mutex_lock(&tienet_master_broadcast_mut);
  if (sock->mesg.size)
  {
    op = TN_OP_SENDWORK;
    tienet_send(sock->num, &op, sizeof(short), 0);
    tienet_send(sock->num, &sock->mesg.size, sizeof(int), 0);
    tienet_send(sock->num, sock->mesg.data, sock->mesg.size, 0);

    free(sock->mesg.data);
    sock->mesg.data = NULL;
    sock->mesg.size = 0;

    pthread_mutex_unlock(&tienet_master_broadcast_mut);
    pthread_mutex_unlock(&tienet_master_send_mut);
    return;
  }
  pthread_mutex_unlock(&tienet_master_broadcast_mut);


  /* Check to see if work is available */
  if (tienet_master_sem_read.val)
  {
    sock->idle = 0;
    tienet_sem_wait(&tienet_master_sem_read);

    /* Increment counter for work units out */
    tienet_sem_post(&tienet_master_sem_out);

    /* Send Work Unit */
    TCOPY(int, tienet_master_buffer[tienet_master_pos_read].data, sizeof(short), &size, 0);
    tienet_send(sock->num, tienet_master_buffer[tienet_master_pos_read].data, sizeof(short) + sizeof(int) + size, 0);

    if (sizeof(short) + sizeof(int) + size > sock->work.size)
    {
      sock->work.size = sizeof(short) + sizeof(int) + size;
      sock->work.data = realloc(sock->work.data, sock->work.size);
    }

    /* Make a copy of this data in the slave list */
    memcpy(sock->work.data, tienet_master_buffer[tienet_master_pos_read].data, sizeof(short) + sizeof(int) + size);

    /* Circular Increment */
    tienet_master_pos_read = (tienet_master_pos_read + 1) % tienet_master_buffer_size;

    /* Application is free to push another work unit into the buffer */
    tienet_sem_post(&tienet_master_sem_fill);

    tienet_master_transfer += size;
  }
  else
  {
    /* no work was available, socket is entering an active idle state. */
    sock->idle = 1;
  }

  pthread_mutex_unlock(&tienet_master_send_mut);
}


void tienet_master_result(tienet_master_socket_t *sock)
{
#if TN_COMPRESSION
  unsigned long	dest_len;
#endif

  /* A work unit has come in, this slave is officially active */
  if (!sock->active)
  {
    sock->active = 1;
    tienet_master_active_slaves++;
  }

  /* Decrement counter for work units out */
  tienet_sem_wait(&tienet_master_sem_out);

  /* receive result length */
  tienet_recv(sock->num, &tienet_master_result_buffer.ind, sizeof(unsigned int), 0);
  tienet_master_transfer += sizeof(unsigned int);

  /* allocate memory for result buffer if more is needed */
  TIENET_BUFFER_SIZE(tienet_master_result_buffer, tienet_master_result_buffer.ind);
#if TN_COMPRESSION
  /* receive compressed length */
  tienet_recv(sock->num, &tienet_master_result_buffer_comp.ind, sizeof(unsigned int), 0);

  TIENET_BUFFER_SIZE(tienet_master_result_buffer_comp, comp_len);

  tienet_recv(sock->num, tienet_master_result_buffer_comp.data, comp_len, 0);

  /* uncompress the data */
  dest_len = tienet_master_result_buffer.ind+32;	/* some extra padding for zlib to work with */
  uncompress(tienet_master_result_buffer.data, &dest_len, tienet_master_result_buffer_comp.data, tienet_master_result_buffer_comp.ind);

  tienet_master_transfer += tienet_master_result_buffer_comp.ind + sizeof(unsigned int);
#else
  /* receive result data */
  tienet_recv(sock->num, tienet_master_result_buffer.data, tienet_master_result_buffer.ind, 0);
  tienet_master_transfer += tienet_master_result_buffer.ind;
#endif

  /* Send next work unit out before processing results so that slave is not waiting while result is being processed. */
  tienet_master_send_work(sock);

  /* Application level result callback function to process results. */
  tienet_master_fcb_result(&tienet_master_result_buffer);

  /*
  * If there's no units still out, the application has indicated it's done generating work,
  * and there's no available work left in the buffer, we're done.
  */

  if (!tienet_master_sem_out.val && tienet_master_endflag && !tienet_master_sem_read.val)
  {
    /* Release the wait semaphore, we're all done. */
    tienet_sem_post(&tienet_master_sem_shutdown);
    tienet_sem_post(&tienet_master_sem_app);
  }
}


void tienet_master_shutdown()
{
  short op;
  tienet_master_socket_t *socket;


  tienet_master_shutdown_state = 1;
  printf("Master is shutting down, standby.\n");
  tienet_sem_wait(&tienet_master_sem_shutdown);
  tienet_master_halt_networking = 1;

  /* Close Sockets */
  for (socket = tienet_master_socket_list; socket; socket = socket->next)
  {
    if (socket->next)
    {
      /* Only if slave socket do we send data to it. */
      op = TN_OP_COMPLETE;
      tienet_send(socket->num, &op, sizeof(short), 0);

      /*
      * Wait on Recv.  When slave socket closes, select will be triggered.
      * At this point we know for sure the slave has disconnected.  This prevents
      * the master socket from being closed before the slave socket, thus pushing
      * the socket into an evil wait state
      */

      tienet_recv(socket->num, &op, sizeof(short), 0);
      close(socket->num);
    }
  }

  printf("Total data transfered: %.1f MiB\n", (tfloat)tienet_master_transfer/(tfloat)(1024*1024));
}


/* This function does not support message queuing right now, so don't try it. */
void tienet_master_broadcast(void *mesg, int mesg_len)
{
  tienet_master_socket_t *socket;

  /* Prevent a Read and Write of the broadcast from occuring at the same time */
  pthread_mutex_lock(&tienet_master_broadcast_mut);

  /* Send a message to each available socket */
  for (socket = tienet_master_socket_list; socket; socket = socket->next)
  {
    /* Only if not master socket */
    if (socket->next)
    {
      socket->mesg.size = mesg_len;
      socket->mesg.data = malloc(mesg_len);
      memcpy(socket->mesg.data, mesg, mesg_len);
    }
  }
  pthread_mutex_unlock(&tienet_master_broadcast_mut);

  /*
  * Tell any idle slaves to get back to work.
  * This is the case where slaves have exhausted the work buffer,
  * then new work becomes available.
  */
  for (socket = tienet_master_socket_list; socket; socket = socket->next)
  {
    /* Only if not master socket do we send data to slave */
    if (socket->next && socket->idle)
      tienet_master_send_work(socket);
  }
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.22
log
@check the length
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.21 2007/12/05 15:33:42 erikgreenwald Exp $
d234 1
a234 1
  bcopy(data, &((char *)(tienet_master_buffer[tienet_master_pos_fill].data))[sizeof(short) + sizeof(int)], size);
d252 1
a252 1
    bcopy(socket->work.data, tienet_master_buffer[tienet_master_pos_fill].data, sizeof(short) + sizeof(int) + size);
d342 1
a342 1
          bcopy(slave_ent.h_addr_list[0], (char *)&slave.sin_addr.s_addr, slave_ent.h_length);
d682 1
a682 1
    bcopy(tienet_master_buffer[tienet_master_pos_read].data, sock->work.data, sizeof(short) + sizeof(int) + size);
d815 1
a815 1
      bcopy(mesg, socket->mesg.data, mesg_len);
@


1.21
log
@upgrade to the updated version
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.3 2007/12/04 21:32:22 erikg Exp $
d161 2
a162 2
  strcpy(tienet_master_list, list);
  strcpy(tienet_master_exec, exec);
@


1.20
log
@minimize use of tie.h
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.19 2007/10/14 08:01:45 brlcad Exp $
d46 1
a61 1
  uint64_t rays;
a63 1
  int prep;	/* 1 == needs new prep data */
a64 1
  pthread_t thread; /* Thread for each socket used to feed it prep data */
d72 1
a72 1
void				tienet_master_init(int port, void fcb_result(void *res_buf, int res_len), char *list, char *exec, int buffer_size, int ver_key);
a73 1
void				tienet_master_prep(void *app_data, int app_size);
a76 1
uint64_t			tienet_master_get_rays_fired(void);
a80 1
void*				tienet_master_prep_thread(void *ptr);
a96 3
static int			tienet_master_app_size;		/* Application Data */
static void			*tienet_master_app_data;

a103 1
static tienet_sem_t		tienet_master_sem_prep;	/* Preparation Semaphore */
d111 1
a111 1
uint64_t			tienet_master_rays_fired;
d116 1
a116 2
void				*tienet_master_res_buf;
int				tienet_master_res_max;
d121 1
d123 1
a123 2
void				*tienet_master_comp_buf;
unsigned int			tienet_master_comp_max;
d127 1
a127 1
typedef void tienet_master_fcb_result_t(void *res_buf, int res_len);
d131 4
a134 4
void tienet_master_init(int port, void fcb_result(void *res_buf, int res_len), char *list, char *exec, int buffer_size, int ver_key) {
  pthread_t	thread;
  int		i;

a135 2
  tienet_master_app_size = 0;
  tienet_master_app_data = NULL;
d138 1
a140 4
  if (!tienet_master_buffer) {
      perror("malloc");
      exit(1);
  }
d156 1
a156 3
  tienet_master_res_buf = NULL;
  tienet_master_res_max = 0;

d158 1
a158 2
  tienet_master_comp_buf = NULL;
  tienet_master_comp_max = 0;
d161 2
a162 2
  strncpy(tienet_master_list, list, 64);
  strncpy(tienet_master_exec, exec, 64);
a169 1
  tienet_sem_init(&tienet_master_sem_prep, 0);
d172 2
a173 1
  for(i = 0; i < tienet_master_buffer_size; i++) {
d184 1
a184 1

d190 4
a193 3
void tienet_master_free() {
  int				i;
  tienet_master_socket_t	*sock;
a196 1
  tienet_sem_free(&tienet_master_sem_prep);
d200 1
d202 1
a202 1
  free(tienet_master_comp_buf);
d204 1
d206 1
a206 1
  for(i = 0; i < tienet_master_buffer_size; i++)
d209 1
a209 1
  for(sock = tienet_master_socket_list->next; sock; sock = sock->next)
a210 3

  free(tienet_master_buffer);
  free(tienet_master_res_buf);
d214 2
a215 21
void tienet_master_prep(void *app_data, int app_size) {
  short op;
  tienet_master_socket_t *socket;


  /* Send a message to each available socket */
  tienet_master_active_slaves = 0;
  for(socket = tienet_master_socket_list; socket; socket = socket->next) {
    /* Only if not master */
    if(socket->next)
      socket->prep = 1;
  }


  tienet_master_app_size = app_size;
  tienet_master_app_data = app_data;
  tienet_sem_post(&tienet_master_sem_prep);
}


void tienet_master_push(void *data, int size) {
d227 2
a228 1
  if(sizeof(short) + sizeof(int) + size > tienet_master_buffer[tienet_master_pos_fill].size) {
d232 3
a234 3
  memcpy(&((char *)(tienet_master_buffer[tienet_master_pos_fill].data))[0], &op, sizeof(short));
  memcpy(&((char *)(tienet_master_buffer[tienet_master_pos_fill].data))[sizeof(short)], &size, sizeof(int));
  memcpy(&((char *)(tienet_master_buffer[tienet_master_pos_fill].data))[sizeof(short) + sizeof(int)], data, size);
d241 2
a242 1
  for(socket = tienet_master_dead_socket_list; socket;) {
d244 2
a245 1
    memcpy(&size, &(socket->work.size), sizeof(int));
d247 2
a248 1
    if(sizeof(short) + sizeof(int) + size > tienet_master_buffer[tienet_master_pos_fill].size) {
d252 1
a252 1
    memcpy(tienet_master_buffer[tienet_master_pos_fill].data, socket->work.data, sizeof(short) + sizeof(int) + size);
d258 1
a258 1
    if(socket == tienet_master_dead_socket_list)
d268 1
a268 1

d274 2
a275 1
  for(socket = tienet_master_socket_list; socket; socket = socket->next) {
d277 1
a277 1
    if(socket->next && socket->idle)
d285 3
a287 2
void tienet_master_begin() {
  if(!tienet_master_sem_app.val)
d292 2
a293 1
void tienet_master_end() {
d298 2
a299 1
void tienet_master_wait() {
d304 2
a305 14
void* tienet_master_prep_thread(void *ptr) {
  short op;
  tienet_master_socket_t *sock;

  sock = (tienet_master_socket_t *)ptr;
  op = TN_OP_PREP;
  tienet_send(sock->num, &op, sizeof(short), 0);
  tienet_send(sock->num, &tienet_master_app_size, sizeof(int), 0);
  tienet_send(sock->num, tienet_master_app_data, tienet_master_app_size, 0);
  return(0);
}


void tienet_master_connect_slaves(fd_set *readfds) {
d316 4
a319 2
  if(fh) {
    while(!feof(fh)) {
d321 92
a412 78
      if(host[0]) {
	port = TN_SLAVE_PORT;
	temp = strchr(host, ':');
	if(temp) {
	  port = atoi(&temp[1]);
	  temp[0] = 0;
	} else {
	  host[strlen(host)-1] = 0;
	}

	if(gethostbyname(host)) { /* check to see if this slave is in dns */
	  slave_ent = gethostbyname(host)[0];

	  /* This is what we're connecting to */
	  slave.sin_family = slave_ent.h_addrtype;
	  memcpy((char *)&slave.sin_addr.s_addr, slave_ent.h_addr_list[0], slave_ent.h_length);
	  slave.sin_port = htons(port);

	  /* Make a communications socket that will get stuffed into the list */
	  daemon_socket = socket(AF_INET, SOCK_STREAM, 0);
	  if(daemon_socket < 0) {
	    fprintf(stderr, "unable to create  socket, exiting.\n");
	    exit(1);
	  }

	  daemon.sin_family = AF_INET;
	  daemon.sin_addr.s_addr = htonl(INADDR_ANY);
	  daemon.sin_port = htons(0);

	  if(bind(daemon_socket, (struct sockaddr *)&daemon, sizeof(daemon)) < 0) {
	    fprintf(stderr, "unable to bind socket, exiting.\n");
	    exit(1);
	  }

	  /* Make an attempt to connect to this host and initiate work */
	  if(connect(daemon_socket, (struct sockaddr *)&slave, sizeof(slave)) < 0) {
	    fprintf(stderr, "cannot connect to slave: %s:%d, skipping.\n", host, port);
	  } else {
	    /* Send endian to slave */
	    op = 1;
	    tienet_send(daemon_socket, &op, sizeof(short), 0);

	    /* Read Version Key and Compare to ver_key, if valid proceed, if not tell slave to disconnect */
	    tienet_recv(daemon_socket, &slave_ver_key, sizeof(int), 0);
	    if(slave_ver_key != tienet_master_ver_key) {
	      op = TN_OP_COMPLETE;
	      tienet_send(daemon_socket, &op, sizeof(short), 0);
	    } else {
	      op = TN_OP_OKAY;
	      tienet_send(daemon_socket, &op, sizeof(short), 0);

	      /* Append to select list */
	      tmp = tienet_master_socket_list;
	      tienet_master_socket_list = (tienet_master_socket_t *)malloc(sizeof(tienet_master_socket_t));
	      tienet_master_socket_list->next = tmp;
	      tienet_master_socket_list->prev = NULL;
	      tienet_master_socket_list->work.data = NULL;
	      tienet_master_socket_list->work.size = 0;
	      tienet_master_socket_list->mesg.data = NULL;
	      tienet_master_socket_list->mesg.size = 0;
	      tienet_master_socket_list->num = daemon_socket;
	      tienet_master_socket_list->rays = 0;
	      tienet_master_socket_list->active = 0;
	      tienet_master_socket_list->idle = 0;
	      tienet_master_socket_list->prep = 1;

	      tmp->prev = tienet_master_socket_list;
	      tienet_master_socket_num++;
	      FD_SET(daemon_socket, readfds);

	      /* Check to see if it's the new highest */
	      if(daemon_socket > tienet_master_highest_fd)
		tienet_master_highest_fd = daemon_socket;
	    }
	  }
	} else {
	  fprintf(stderr, "unknown host: %s, skipping.\n", host);
	}
d421 2
a422 1
void* tienet_master_listener(void *ptr) {
d431 2
a432 4
  /* Wait until prep call has been made before proceeding */
  tienet_sem_wait(&tienet_master_sem_prep);

  if((master_socket = socket(AF_INET, SOCK_STREAM, 0)) <= 0) {
d442 2
a443 1
  if(bind(master_socket, (struct sockaddr *)&master, addrlen)) {
a449 4
  if (!tienet_master_socket_list) {
      perror("malloc");
      exit(1);
  }
d474 2
a475 1
  while(1) {
d482 1
a482 1
    if(tienet_master_halt_networking)
d487 111
a597 103
    for(sock = tienet_master_socket_list; sock; sock = sock->next) {
      if(FD_ISSET(sock->num, &readfds)) {
	if(sock->num == master_socket) {
	  /* New Connections, Always LAST in readfds list */
	  slave_socket = accept(master_socket, (struct sockaddr *)&slave, &addrlen);
	  if(slave_socket >= 0) {
/*            printf("The slave %s has connected on port: %d, sock_num: %d\n", inet_ntoa(slave.sin_addr), tienet_master_port, slave_socket); */
	    tmp = tienet_master_socket_list;
	    tienet_master_socket_list = (tienet_master_socket_t *)malloc(sizeof(tienet_master_socket_t));
	    if (!tienet_master_socket_list) {
		perror("malloc");
		exit(1);
	    }
	    tienet_master_socket_list->next = tmp;
	    tienet_master_socket_list->prev = NULL;
	    tienet_master_socket_list->work.data = NULL;
	    tienet_master_socket_list->work.size = 0;
	    tienet_master_socket_list->mesg.data = NULL;
	    tienet_master_socket_list->mesg.size = 0;
	    tienet_master_socket_list->num = slave_socket;
	    tienet_master_socket_list->rays = 0;
	    tienet_master_socket_list->active = 0;
	    tienet_master_socket_list->idle = 0;
	    tienet_master_socket_list->prep = 1;
	    tmp->prev = tienet_master_socket_list;
	    tienet_master_socket_num++;

	    /* Send endian to slave */
	    op = 1;
	    tienet_send(slave_socket, &op, sizeof(short), 0);
	    /* Read Version Key and Compare to ver_key, if valid proceed, if not tell slave to disconnect */
	    tienet_recv(slave_socket, &slave_ver_key, sizeof(int), 0);
	    if(slave_ver_key != tienet_master_ver_key) {
	      op = TN_OP_COMPLETE;
	      tienet_send(slave_socket, &op, sizeof(short), 0);
	    } else {
	      /* Version is okay, proceed */
	      op = TN_OP_OKAY;
	      tienet_send(slave_socket, &op, sizeof(short), 0);

	      /* Append to select list */
	      if(slave_socket > tienet_master_highest_fd)
		tienet_master_highest_fd = slave_socket;
	    }
	  }
	} else {
	  /* Make sure socket is still active on this recv */
	  r = tienet_recv(sock->num, &op, sizeof(short), 0);
	  /* if "r", error code returned, remove slave from pool */
	  if(r) {
	    tienet_master_socket_t		*tmp2;
	    /* Because master socket is always last there is no need to check if "next" exists.
	     * Remove this socket from chain and link prev and next up to fill gap. */
	    if(sock->prev)
	      sock->prev->next = sock->next;
	    sock->next->prev = sock->prev;

	    /* Store ptr to sock before we modify it */
	    tmp = sock;
	    /* If the socket is the head then we need to not only modify the socket,
	     * but the head as well. */
	    if(tienet_master_socket_list == sock)
	      tienet_master_socket_list = sock->next;
	    sock = sock->prev ? sock->prev : sock->next;

	    /* Put the socket into the tienet_master_DeadSocketList */
	    if(tienet_master_dead_socket_list) {
	      tmp2 = tienet_master_dead_socket_list;
	      tienet_master_dead_socket_list = tmp;
	      tienet_master_dead_socket_list->prev = NULL;
	      tienet_master_dead_socket_list->next = tmp2;
	      tmp2->prev = tienet_master_dead_socket_list;
	    } else {
	      tienet_master_dead_socket_list = tmp;
	      tienet_master_dead_socket_list->next = NULL;
	      tienet_master_dead_socket_list->prev = NULL;
	    }

	    tienet_master_socket_num--;
	  } else {
	    /*
	    * Slave Op Instructions
	    */
	    switch(op) {
	      case TN_OP_REQWORK:
		/* If application/prep data is stale, send latest data */
		if(sock->prep) {
		  sock->prep = 0;
		  pthread_create(&sock->thread, NULL, tienet_master_prep_thread, sock);
		} else {
		  tienet_master_send_work(sock);
		}
		break;

	      case TN_OP_RESULT:
		tienet_master_result(sock);
		break;

	      default:
		break;
	    }
	  }
	}
d603 4
a606 3
    for(sock = tienet_master_socket_list; sock; sock = sock->next) {
      if(sock->num > tienet_master_highest_fd)
	tienet_master_highest_fd = sock->num;
d613 2
a614 1
void tienet_master_send_work(tienet_master_socket_t *sock) {
d618 1
a618 1
  /*
d621 1
a621 1
  * and 2 threads entered the if(tienet_master_sem_read.val) block and waited on tienet_master_sem_read
d630 2
a631 1
  if(tienet_master_shutdown_state) {
d633 1
a633 1
    if(!tienet_master_sem_out.val)
d638 24
d663 2
a664 1
  if(tienet_master_sem_read.val) {
a670 18
    /*
    * Check to see if a broadcast message is sitting in the queue.
    * The mutex prevents a read and write from occuring at the same time.
    */
    pthread_mutex_lock(&tienet_master_broadcast_mut);
    if(sock->mesg.size) {
      op = TN_OP_MESSAGE;
      tienet_send(sock->num, &op, sizeof(short), 0);
      tienet_send(sock->num, &sock->mesg.size, sizeof(int), 0);
      tienet_send(sock->num, sock->mesg.data, sock->mesg.size, 0);

      free(sock->mesg.data);
      sock->mesg.data = NULL;
      sock->mesg.size = 0;
    }
    pthread_mutex_unlock(&tienet_master_broadcast_mut);


d672 1
a672 1
    memcpy(&size, &((char *)(tienet_master_buffer[tienet_master_pos_read].data))[sizeof(short)], sizeof(int));
d675 2
a676 1
    if(sizeof(short) + sizeof(int) + size > sock->work.size) {
d682 1
a682 1
    memcpy(sock->work.data, tienet_master_buffer[tienet_master_pos_read].data, sizeof(short) + sizeof(int) + size);
d691 3
a693 1
  } else {
d702 2
a703 2
void tienet_master_result(tienet_master_socket_t *sock) {
  unsigned int res_len, comp_len;
d709 2
a710 1
  if(!sock->active) {
a717 3
  /* receive rays fired */
  tienet_recv(sock->num, &sock->rays, sizeof(uint64_t), 0);

d719 1
a719 1
  tienet_recv(sock->num, &res_len, sizeof(unsigned int), 0);
d723 1
a723 5
  if(res_len+32 > tienet_master_res_max) {
    tienet_master_res_max = res_len+32;
    tienet_master_res_buf = realloc(tienet_master_res_buf, tienet_master_res_max);
  }

a724 2
  dest_len = res_len+32;

d726 1
a726 1
  tienet_recv(sock->num, &comp_len, sizeof(unsigned int), 0);
d728 1
a728 5
  /* receive compressed result data */
  if(comp_len > tienet_master_comp_max) {
    tienet_master_comp_max = comp_len;
    tienet_master_comp_buf = realloc(tienet_master_comp_buf, tienet_master_comp_max);
  }
d730 1
a730 1
  tienet_recv(sock->num, tienet_master_comp_buf, comp_len, 0);
d733 2
a734 2
  dest_len = res_len+32;	/* some extra padding for zlib to work with */
  uncompress(tienet_master_res_buf, &dest_len, tienet_master_comp_buf, comp_len);
d736 1
a736 1
  tienet_master_transfer += comp_len + sizeof(unsigned int);
d739 2
a740 2
  tienet_recv(sock->num, tienet_master_res_buf, res_len, 0);
  tienet_master_transfer += res_len;
d743 1
a743 1
  /* Send next work unit out before processing results so that slave is not waiting */
d746 2
a747 2
  /* Application level result callback function to process results */
  tienet_master_fcb_result(tienet_master_res_buf, res_len);
d754 2
a755 1
  if(!tienet_master_sem_out.val && tienet_master_endflag && !tienet_master_sem_read.val) {
d763 2
a764 1
void tienet_master_shutdown() {
d775 4
a778 2
  for(socket = tienet_master_socket_list; socket; socket = socket->next) {
    if(socket->next) {
d795 1
a795 1
  printf("Total data transfered: %.1f MiB\n", (double)tienet_master_transfer/(double)(1024*1024));
d800 2
a801 1
void tienet_master_broadcast(void *mesg, int mesg_len) {
d808 2
a809 1
  for(socket = tienet_master_socket_list; socket; socket = socket->next) {
d811 2
a812 1
    if(socket->next) {
d815 1
a815 5
      if (!socket->mesg.data) {
	  perror("malloc");
	  exit(1);
      }
      memcpy(socket->mesg.data, mesg, mesg_len);
a817 1

a818 1
}
d820 11
a830 10

uint64_t tienet_master_get_rays_fired() {
  tienet_master_socket_t	*sock;
  uint64_t			rays_fired;

  rays_fired = 0;
  for(sock = tienet_master_socket_list; sock; sock = sock->next)
    rays_fired += sock->rays;

  return(rays_fired);
@


1.19
log
@take care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.18 2007/08/30 19:11:30 brlcad Exp $
a45 1
#include "tie.h"
d811 1
a811 1
  printf("Total data transfered: %.1f MiB\n", (tfloat)tienet_master_transfer/(tfloat)(1024*1024));
@


1.18
log
@TFLOAT changed to tfloat.  also quell a few warnings/bugs related to passing the wrong TIE_3 pointer type.
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.17 2007/03/28 18:57:35 erikgreenwald Exp $
d180 2
a181 2
  strcpy(tienet_master_list, list);
  strcpy(tienet_master_exec, exec);
@


1.17
log
@Use "tienet_master_socket_list" instead of undeclared "tienet_master_socke_list". Don't people try to compile before committing anymore?
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.16 2007/03/20 20:05:08 brlcad Exp $
d812 1
a812 1
  printf("Total data transfered: %.1f MiB\n", (TFLOAT)tienet_master_transfer/(TFLOAT)(1024*1024));
@


1.16
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.15 2007/02/08 06:49:19 brlcad Exp $
d477 1
a477 1
  if (!tienet_master_socke_list) {
@


1.15
log
@give adrt some distinctiveness in the header
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.14 2007/02/02 19:46:35 erikgreenwald Exp $
d153 4
d477 4
d526 4
d829 4
@


1.14
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
d32 1
a32 1
 * $Id: tienet_master.c,v 1.13 2007/01/27 01:41:30 brlcad Exp $
@


1.13
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.12 2007/01/23 01:13:22 brlcad Exp $
d800 1
a800 1
  printf("Total data transfered: %.1f MiB\n", (tfloat)tienet_master_transfer/(tfloat)(1024*1024));
@


1.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d32 1
a32 1
 * $Id: tienet_master.c,v 1.11 2007/01/21 00:50:29 brlcad Exp $
d359 77
a435 77
        port = TN_SLAVE_PORT;
        temp = strchr(host, ':');
        if(temp) {
          port = atoi(&temp[1]);
          temp[0] = 0;
        } else {
          host[strlen(host)-1] = 0;
        }

        if(gethostbyname(host)) { /* check to see if this slave is in dns */
          slave_ent = gethostbyname(host)[0];

          /* This is what we're connecting to */
          slave.sin_family = slave_ent.h_addrtype;
          memcpy((char *)&slave.sin_addr.s_addr, slave_ent.h_addr_list[0], slave_ent.h_length);
          slave.sin_port = htons(port);

          /* Make a communications socket that will get stuffed into the list */
          daemon_socket = socket(AF_INET, SOCK_STREAM, 0);
          if(daemon_socket < 0) {
            fprintf(stderr, "unable to create  socket, exiting.\n");
            exit(1);
          }

          daemon.sin_family = AF_INET;
          daemon.sin_addr.s_addr = htonl(INADDR_ANY);
          daemon.sin_port = htons(0);

          if(bind(daemon_socket, (struct sockaddr *)&daemon, sizeof(daemon)) < 0) {
            fprintf(stderr, "unable to bind socket, exiting.\n");
            exit(1);
          }

          /* Make an attempt to connect to this host and initiate work */
          if(connect(daemon_socket, (struct sockaddr *)&slave, sizeof(slave)) < 0) {
            fprintf(stderr, "cannot connect to slave: %s:%d, skipping.\n", host, port);
          } else {
            /* Send endian to slave */
            op = 1;
            tienet_send(daemon_socket, &op, sizeof(short), 0);

            /* Read Version Key and Compare to ver_key, if valid proceed, if not tell slave to disconnect */
            tienet_recv(daemon_socket, &slave_ver_key, sizeof(int), 0);
            if(slave_ver_key != tienet_master_ver_key) {
              op = TN_OP_COMPLETE;
              tienet_send(daemon_socket, &op, sizeof(short), 0);
            } else {
              op = TN_OP_OKAY;
              tienet_send(daemon_socket, &op, sizeof(short), 0);

              /* Append to select list */
              tmp = tienet_master_socket_list;
              tienet_master_socket_list = (tienet_master_socket_t *)malloc(sizeof(tienet_master_socket_t));
              tienet_master_socket_list->next = tmp;
              tienet_master_socket_list->prev = NULL;
              tienet_master_socket_list->work.data = NULL;
              tienet_master_socket_list->work.size = 0;
              tienet_master_socket_list->mesg.data = NULL;
              tienet_master_socket_list->mesg.size = 0;
              tienet_master_socket_list->num = daemon_socket;
              tienet_master_socket_list->rays = 0;
              tienet_master_socket_list->active = 0;
              tienet_master_socket_list->idle = 0;
              tienet_master_socket_list->prep = 1;

              tmp->prev = tienet_master_socket_list;
              tienet_master_socket_num++;
              FD_SET(daemon_socket, readfds);

              /* Check to see if it's the new highest */
              if(daemon_socket > tienet_master_highest_fd)
                tienet_master_highest_fd = daemon_socket;
            }
          }
        } else {
          fprintf(stderr, "unknown host: %s, skipping.\n", host);
        }
d511 4
a514 4
        if(sock->num == master_socket) {
          /* New Connections, Always LAST in readfds list */
          slave_socket = accept(master_socket, (struct sockaddr *)&slave, &addrlen);
          if(slave_socket >= 0) {
d516 92
a607 92
            tmp = tienet_master_socket_list;
            tienet_master_socket_list = (tienet_master_socket_t *)malloc(sizeof(tienet_master_socket_t));
            tienet_master_socket_list->next = tmp;
            tienet_master_socket_list->prev = NULL;
            tienet_master_socket_list->work.data = NULL;
            tienet_master_socket_list->work.size = 0;
            tienet_master_socket_list->mesg.data = NULL;
            tienet_master_socket_list->mesg.size = 0;
            tienet_master_socket_list->num = slave_socket;
            tienet_master_socket_list->rays = 0;
            tienet_master_socket_list->active = 0;
            tienet_master_socket_list->idle = 0;
            tienet_master_socket_list->prep = 1;
            tmp->prev = tienet_master_socket_list;
            tienet_master_socket_num++;

            /* Send endian to slave */
            op = 1;
            tienet_send(slave_socket, &op, sizeof(short), 0);
            /* Read Version Key and Compare to ver_key, if valid proceed, if not tell slave to disconnect */
            tienet_recv(slave_socket, &slave_ver_key, sizeof(int), 0);
            if(slave_ver_key != tienet_master_ver_key) {
              op = TN_OP_COMPLETE;
              tienet_send(slave_socket, &op, sizeof(short), 0);
            } else {
              /* Version is okay, proceed */
              op = TN_OP_OKAY;
              tienet_send(slave_socket, &op, sizeof(short), 0);

              /* Append to select list */
              if(slave_socket > tienet_master_highest_fd)
                tienet_master_highest_fd = slave_socket;
            }
          }
        } else {
          /* Make sure socket is still active on this recv */
          r = tienet_recv(sock->num, &op, sizeof(short), 0);
          /* if "r", error code returned, remove slave from pool */
          if(r) {
            tienet_master_socket_t		*tmp2;
            /* Because master socket is always last there is no need to check if "next" exists.
             * Remove this socket from chain and link prev and next up to fill gap. */
            if(sock->prev)
              sock->prev->next = sock->next;
            sock->next->prev = sock->prev;

            /* Store ptr to sock before we modify it */
            tmp = sock;
            /* If the socket is the head then we need to not only modify the socket,
             * but the head as well. */
            if(tienet_master_socket_list == sock)
              tienet_master_socket_list = sock->next;
            sock = sock->prev ? sock->prev : sock->next;

            /* Put the socket into the tienet_master_DeadSocketList */
            if(tienet_master_dead_socket_list) {
              tmp2 = tienet_master_dead_socket_list;
              tienet_master_dead_socket_list = tmp;
              tienet_master_dead_socket_list->prev = NULL;
              tienet_master_dead_socket_list->next = tmp2;
              tmp2->prev = tienet_master_dead_socket_list;
            } else {
              tienet_master_dead_socket_list = tmp;
              tienet_master_dead_socket_list->next = NULL;
              tienet_master_dead_socket_list->prev = NULL;
            }

            tienet_master_socket_num--;
          } else {
            /*
            * Slave Op Instructions
            */
            switch(op) {
              case TN_OP_REQWORK:
                /* If application/prep data is stale, send latest data */
                if(sock->prep) {
                  sock->prep = 0;
                  pthread_create(&sock->thread, NULL, tienet_master_prep_thread, sock);
                } else {
                  tienet_master_send_work(sock);
                }
                break;

              case TN_OP_RESULT:
                tienet_master_result(sock);
                break;

              default:
                break;
            }
          }
        }
d615 1
a615 1
        tienet_master_highest_fd = sock->num;
@


1.11
log
@standard header and footer cleanup
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
d32 1
a32 1
 * $Id: tienet_master.c,v 1.10 2007/01/20 14:36:41 brlcad Exp $
@


1.10
log
@update copyright to 2007
@
text
@d1 1
a1 4
/*                     M A S T E R . C
 *
 * @@file master.c
 *
d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d19 2
d32 1
a32 1
 * $Id: tienet_master.c,v 1.9 2006/01/18 06:46:12 brlcad Exp $
d835 10
@


1.9
log
@update copyright to 2006
@
text
@d7 1
a7 1
 * Copyright (c) 2002-2006 United States Government as represented by
d34 1
a34 1
 * $Id: tienet_master.c,v 1.8 2005/10/23 04:44:28 brlcad Exp $
@


1.8
log
@trailing ws
@
text
@d7 1
a7 1
 * Copyright (C) 2002-2005 United States Government as represented by
d34 1
a34 1
 * $Id: tienet_master.c,v 1.7 2005/09/10 19:16:29 twingy Exp $
@


1.7
log
@stuff to fix 32/64 communication
@
text
@d34 1
a34 1
 * $Id: tienet_master.c,v 1.6 2005/09/09 22:06:26 twingy Exp $
d201 1
a201 1
  
d301 1
a301 1
  
d628 1
a628 1
  /* 
@


1.6
log
@fixed 64/32 bit network communications bug in tienet.
@
text
@d34 1
a34 1
 * $Id: tienet_master.c,v 1.5 2005/07/28 00:28:29 twingy Exp $
d702 1
a702 1
  unsigned int size, res_len, comp_len;
d744 1
a744 1
  dest_len = comp_len+32;	/* some extra padding for zlib to work with */
a745 1
  size = dest_len;
@


1.5
log
@* Overall load time for all 8 nodes during startup is 25% faster.
* File size of adrt mesh is now 33% smaller.  It uses shortst when trinum
  of the mesh is under 64K triangles.
* Prep data to slaves is now multi-threaded (all slaves get data from
  master at the same time, heavy network load).
@
text
@d34 1
a34 1
 * $Id: tienet_master.c,v 1.4 2005/07/27 17:43:59 twingy Exp $
d136 1
a136 1
int				tienet_master_comp_max;
d702 1
a702 1
  int		res_len;
a703 1
  long		comp_len;
d720 2
a721 2
  tienet_recv(sock->num, &res_len, sizeof(int), 0);
  tienet_master_transfer += sizeof(int);
a722 1
#if TN_COMPRESSION
d729 1
d733 1
a733 1
  tienet_recv(sock->num, &comp_len, sizeof(long), 0);
d744 1
a744 1
  dest_len = res_len+32;	/* some extra padding for zlib to work with */
d746 1
d748 1
a748 1
  tienet_master_transfer += comp_len + sizeof(long);
a749 6
  /* allocate memory for result buffer if more is needed */
  if(res_len+32 > tienet_master_res_max) {
    tienet_master_res_max = res_len+32;
    tienet_master_res_buf = realloc(tienet_master_res_buf, tienet_master_res_max);
  }

@


1.5.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d34 1
a34 1
 * $Id$
d136 1
a136 1
unsigned int			tienet_master_comp_max;
d201 1
a201 1

d301 1
a301 1

d628 1
a628 1
  /*
d702 1
a702 1
  unsigned int res_len, comp_len;
d704 1
d721 2
a722 2
  tienet_recv(sock->num, &res_len, sizeof(unsigned int), 0);
  tienet_master_transfer += sizeof(unsigned int);
d724 1
a730 1
#if TN_COMPRESSION
d734 1
a734 1
  tienet_recv(sock->num, &comp_len, sizeof(unsigned int), 0);
d748 1
a748 1
  tienet_master_transfer += comp_len + sizeof(unsigned int);
d750 6
@


1.4
log
@* Fixed the rendering weirdness on the slave start-up
  Slaves were requesting a work unit right after prep begins
  so that slaves were holding onto a work unit for a lengthy time
  until prep finished and causing the units to not get done until
  prep finished.
* Added compute nodes status to observer.
* Added Scale Factor status to observer.
* Changed bytes transfered to mibi bytes instead of kilobytes.
@
text
@d34 1
a34 1
 * $Id: tienet_master.c,v 1.3 2005/07/08 20:00:48 twingy Exp $
d69 1
d88 1
d132 1
d200 1
d333 13
a593 4
                  op = TN_OP_PREP;
                  tienet_send(sock->num, &op, sizeof(short), 0);
                  tienet_send(sock->num, &tienet_master_app_size, sizeof(int), 0);
                  tienet_send(sock->num, tienet_master_app_data, tienet_master_app_size, 0);
d595 1
d655 5
a659 1
    /* Check to see if a broadcast message is sitting in the queue */
d670 1
d817 3
d829 2
@


1.3
log
@bug fix, adding more component net stuff.
@
text
@d34 1
a34 1
 * $Id: tienet_master.c,v 1.2 2005/06/18 21:58:58 twingy Exp $
d65 2
a66 1
  int idle;
d76 1
a76 2
void				tienet_master_init(int port, void fcb_result(void *res_buf, int res_len), char *
list, char *exec, int buffer_size, int ver_key);
d98 1
d118 1
a118 1
int				tienet_master_transfer;
d129 1
d154 1
d196 1
d234 1
d252 1
d308 2
d405 1
d511 1
d575 10
a584 1
                tienet_master_send_work(sock);
a640 9
    /* If application/prep data is stale, send latest data */
    if(sock->prep) {
      op = TN_OP_PREP;
      tienet_send(sock->num, &op, sizeof(short), 0);
      tienet_send(sock->num, &tienet_master_app_size, sizeof(int), 0);
      tienet_send(sock->num, tienet_master_app_data, tienet_master_app_size, 0);
      sock->prep = 0;
    }

d689 5
d726 1
a726 1
  dest_len = res_len + 32;	/* some extra padding for zlib to work with */
d790 1
a790 1
  printf("Total data transfered: %.0f kB\n", (tfloat)tienet_master_transfer/(tfloat)1024);
d796 1
a796 1
  tienet_master_socket_t	*socket;
@


1.3.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d34 1
a34 1
 * $Id: tienet_master.c,v 1.5 2005/07/28 00:28:29 twingy Exp $
d65 1
a65 2
  int active;	/* Once a slave has completed its first work unit this becomes 1 */
  int idle;	/* When a slave has finished a work unit and there's nothing left for it to work on */
a67 1
  pthread_t thread; /* Thread for each socket used to feed it prep data */
d75 2
a76 1
void				tienet_master_init(int port, void fcb_result(void *res_buf, int res_len), char *list, char *exec, int buffer_size, int ver_key);
a86 1
void*				tienet_master_prep_thread(void *ptr);
a97 1
int				tienet_master_active_slaves;
d117 1
a117 1
uint64_t			tienet_master_transfer;
a127 2
pthread_mutex_t			tienet_master_push_mut;
pthread_mutex_t			tienet_master_broadcast_mut;
a151 1
  tienet_master_active_slaves = 0;
a192 2
  pthread_mutex_init(&tienet_master_push_mut, 0);
  pthread_mutex_init(&tienet_master_broadcast_mut, 0);
a229 1
  tienet_master_active_slaves = 0;
a246 1
  pthread_mutex_lock(&tienet_master_push_mut);
a301 2

  pthread_mutex_unlock(&tienet_master_push_mut);
a320 13
void* tienet_master_prep_thread(void *ptr) {
  short op;
  tienet_master_socket_t *sock;

  sock = (tienet_master_socket_t *)ptr;
  op = TN_OP_PREP;
  tienet_send(sock->num, &op, sizeof(short), 0);
  tienet_send(sock->num, &tienet_master_app_size, sizeof(int), 0);
  tienet_send(sock->num, tienet_master_app_data, tienet_master_app_size, 0);
  return(0);
}


a396 1
              tienet_master_socket_list->active = 0;
a501 1
            tienet_master_socket_list->active = 0;
d565 1
a565 7
                /* If application/prep data is stale, send latest data */
                if(sock->prep) {
                  sock->prep = 0;
                  pthread_create(&sock->thread, NULL, tienet_master_prep_thread, sock);
                } else {
                  tienet_master_send_work(sock);
                }
d622 10
a631 5
    /*
    * Check to see if a broadcast message is sitting in the queue.
    * The mutex prevents a read and write from occuring at the same time.
    */
    pthread_mutex_lock(&tienet_master_broadcast_mut);
a641 1
    pthread_mutex_unlock(&tienet_master_broadcast_mut);
a678 5
  /* A work unit has come in, this slave is officially active */
  if(!sock->active) {
    sock->active = 1;
    tienet_master_active_slaves++;
  }
d711 1
a711 1
  dest_len = res_len+32;	/* some extra padding for zlib to work with */
d775 1
a775 1
  printf("Total data transfered: %.1f MiB\n", (tfloat)tienet_master_transfer/(tfloat)(1024*1024));
d781 1
a781 4
  tienet_master_socket_t *socket;

  /* Prevent a Read and Write of the broadcast from occuring at the same time */
  pthread_mutex_lock(&tienet_master_broadcast_mut);
a791 2

  pthread_mutex_unlock(&tienet_master_broadcast_mut);
@


1.2
log
@Added licensing info to libtexture files.
@
text
@d34 1
a34 1
 * $Id: tienet_master.c,v 1.1 2005/06/18 06:40:40 twingy Exp $
d75 2
a76 1
void				tienet_master_init(int port, void fcb_result(void *res_buf, int res_len), char *list, char *exec, int buffer_size, int ver_key);
@


1.1
log
@
fixing linking problems to get adrt to properly link to brlcad.
@
text
@d2 3
a22 3
 */
/** @@file master.c
 *                     M A S T E R . C
d24 2
a25 1
 *  TIE Networking Master
d34 1
a34 1
 * $Id: master.c,v 1.2 2005/06/18 01:09:31 twingy Exp $
@

