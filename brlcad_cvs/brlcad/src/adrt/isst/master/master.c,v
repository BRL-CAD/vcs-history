head	1.30;
access;
symbols
	rel-7-10-4:1.27
	STABLE:1.27.0.2
	rel-7-10-2:1.26
	rel-7-10-0:1.26
	rel-7-8-4:1.18
	rel-7-8-2:1.18
	rel-7-8-0:1.18
	trimnurbs-branch:1.18.0.2
	help:1.18
	temp_tag:1.18
	bobWinPort-20051223-freeze:1.6
	postmerge-20051223-bobWinPort:1.18
	premerge-20051223-bobWinPort:1.18
	rel-7-6-6:1.18
	rel-7-6-4:1.18
	rel-7-6-2:1.9
	rel-7-6-branch:1.9.0.2
	rel-7-6-0:1.9
	rel-7-4-2:1.6.4.2
	rel-7-4-branch:1.6.0.4
	bobWinPort:1.6.0.2;
locks; strict;
comment	@ * @;


1.30
date	2007.12.18.21.39.09;	author erikgreenwald;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.18.18.22.14;	author erikgreenwald;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.06.20.17.09;	author erikgreenwald;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.30.19.11.29;	author brlcad;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.28.18.59.17;	author erikgreenwald;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.20.20.05.05;	author brlcad;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.08.06.49.17;	author brlcad;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.02.19.46.34;	author erikgreenwald;	state Exp;
branches;
next	1.22;

1.22
date	2007.01.27.01.41.30;	author brlcad;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.23.01.13.21;	author brlcad;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.21.00.53.11;	author brlcad;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.18.22.17.56;	author erikgreenwald;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.21.16.16.15;	author twingy;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.21.02.15.01;	author twingy;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.14.07.28.35;	author twingy;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.14.02.04.14;	author twingy;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.12.22.39.12;	author twingy;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.12.18.13.46;	author twingy;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.10.19.31.48;	author twingy;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.10.19.25.07;	author twingy;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.10.19.16.28;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.08.05.11.20;	author twingy;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2005.09.06.06.28.44;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.25.23.24.36;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.29.21.40.07;	author twingy;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2005.07.29.17.48.17;	author twingy;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.27.17.43.58;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.26.16.28.05;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.20.18.37.04;	author twingy;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.18.20.57.56;	author twingy;	state Exp;
branches;
next	;

1.6.4.1
date	2005.07.29.21.40.07;	author brlcad;	state dead;
branches;
next	1.6.4.2;

1.6.4.2
date	2005.08.16.21.03.45;	author brlcad;	state Exp;
branches;
next	;

1.9.2.1
date	2005.11.13.13.46.11;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.30
log
@generify function names a bit (hopefully leading to unification of the various compute chunks)
@
text
@/*                        M A S T E R . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file master.c
 *
 * Author -
 *   Justin Shumaker
 *
 */

#include "master.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "camera.h"
#include "dispatcher.h"		/* Dispatcher that creates work units */
#include "compnet.h"		/* Component Networking, Sends Component Names via Network */
#include "adrt.h"		/* adrt Defines */
#include "adrt_struct.h"	/* adrt common structs */
#include "tienet.h"		/* Networking stuff */
/* Networking Includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#if ADRT_USE_COMPRESSION
  #include <zlib.h>
#endif


/* socket structure */
typedef struct master_socket_s
{
  int32_t num;
  int32_t controller;
  int32_t active;
  tienet_sem_t frame_sem;
  struct master_socket_s *prev;
  struct master_socket_s *next;
} master_socket_t;


typedef struct master_s
{
  uint8_t wid_list[ADRT_MAX_WORKSPACE_NUM];

  uint16_t image_w;
  uint16_t image_h;
  uint16_t image_format;

  uint32_t tile_num;

  master_socket_t *socklist;
  tienet_sem_t wait_sem;

  tienet_buffer_t buf;
#if ADRT_USE_COMPRESSION
  tienet_buffer_t buf_comp;
#endif

  uint32_t frame_ind;
  uint8_t slave_data[64];
  uint32_t slave_data_len;
  pthread_t networking_thread;
  uint32_t active_connections;
  uint32_t alive;
} master_t;


void* master_networking (void *ptr);
void master_result (tienet_buffer_t *result);

master_t master;


static void
master_setup ()
{
  uint16_t i;

  master.active_connections = 0;

  master.alive = 1;

  master.frame_ind = 0;

  TIENET_BUFFER_INIT(master.buf);
#if ADRT_USE_COMPRESSION
  TIENET_BUFFER_INIT(master.buf_comp);
#endif

  /* -1 indicates this slot is not used and thus does not contain an open project. */
  for (i = 0; i < ADRT_MAX_WORKSPACE_NUM; i++)
    master.wid_list[i] = 0;
}


void
master_init (int port, int obs_port, char *list, char *exec, char *comp_host, int verbose)
{
  /* Setup defaults */
  master_setup();

  /* Initialize tienet master */
  master.tile_num = DISPATCHER_TILE_NUM * DISPATCHER_TILE_NUM;
  tienet_master_init(port, master_result, list, exec, 5, ADRT_VER_KEY, verbose);

  /* Launch a thread to handle networking */
  pthread_create(&master.networking_thread, NULL, master_networking, &obs_port);

  /* Connect to the component Server */
  compnet_connect(comp_host, ISST_COMPNET_PORT);

  /* Initialize the work dispatcher */
  master_dispatcher_init();

  tienet_sem_init(&master.wait_sem, 0);

  /* Process work units */
  tienet_sem_wait(&master.wait_sem);

  /* Wait for the tienet master work buffer to empty and for all the results to come back */
  tienet_master_wait();

  /* Shutdown */
  tienet_master_shutdown();

  /* Free network data */
  tienet_master_free();

  /* Free the dispatcher data */
  master_dispatcher_free();

  TIENET_BUFFER_FREE(master.buf);
#if ADRT_USE_COMPRESSION
  TIENET_BUFFER_FREE(master.buf_comp);
#endif

  /* Wait for networking thread to end */
  pthread_join(master.networking_thread, NULL);
}


void
master_result (tienet_buffer_t *result)
{
  master_socket_t *sock;
  camera_tile_t tile;
  uint8_t *rgb_data, op;
  uint16_t wid;
  uint32_t i, ind, ind2, update;


  update = 0;
  ind = 0;

  op = result->data[ind];
  ind += 1;

  TCOPY (uint16_t, result->data, ind, &wid, 0);
  ind += 2;

  switch(op)
  {
    case ADRT_WORK_FRAME:
      /* Work unit data */
      TCOPY(camera_tile_t, result->data, ind, &tile, 0);
      ind += sizeof (camera_tile_t);

      /* Pointer to RGB Data */
      rgb_data = &result->data[ind];

      /* Copy the tile into the image */
      ind = 0;
      ind2 = tile.orig_x + tile.orig_y * master.image_w;

      /* Only does 24-bit right now */
      for (i = 0; i < tile.size_y; i++)
      {
        bcopy(&rgb_data[3*ind], &master.buf.data[3*ind2], 3*tile.size_x);
        ind += tile.size_x;
        ind2 += master.image_w;
      }

      master.frame_ind++;

      /* Image is complete, draw the frame. */
      if (master.frame_ind == master.tile_num)
      {
        update = 1;
        master.frame_ind = 0;
        master.buf.ind = 3 * master.image_w * master.image_h;
      }
      break;

    case ADRT_WORK_SHOTLINE:
      {
        tienet_buffer_t selection_buf;
        uint32_t i, num, tind;
        uint8_t c;
        char name[256];

        TIENET_BUFFER_INIT(selection_buf);
        TIENET_BUFFER_SIZE(selection_buf, result->ind);

        /* Send this data to the slaves as ADRT_WORK_SELECT for highlighting hit components */
        selection_buf.ind = 0;

        op = ADRT_WORK_SELECT;
        TCOPY(uint8_t, &op, 0, selection_buf.data, selection_buf.ind);
        selection_buf.ind += 1;

        TCOPY(uint16_t, &wid, 0, selection_buf.data, selection_buf.ind);
        selection_buf.ind += 2;

        tind = ind;

        /* Skip over in-hit */
        tind += sizeof(TIE_3);

        /* Number of meshes */
        TCOPY(uint32_t, result->data, tind, &num, 0);
        tind += 4;

        /* Reset Flag */
        op = 1;
        TCOPY(uint8_t, &op, 0, selection_buf.data, selection_buf.ind);
        selection_buf.ind += 1;

        /* Number of meshes */
        TCOPY(uint32_t, &num, 0, selection_buf.data, selection_buf.ind);
        selection_buf.ind += 4;

        /* For each intersected mesh extract the name and pack it, skipping the thickness */
        for (i = 0; i < num; i++)
        {
          /* length of string */
          TCOPY(uint8_t, result->data, tind, &c, 0);
          tind += 1;

          /* the name */
          bcopy(&result->data[tind], name, c);
          tind += c;

          /* skip over the thickness */
          tind += sizeof(tfloat);

          /* pack the mesh name length and name */
          TCOPY(uint8_t, &c, 0, selection_buf.data, selection_buf.ind);
          selection_buf.ind += 1;

          bcopy(name, &selection_buf.data[selection_buf.ind], c);
          selection_buf.ind += c;
        }

        /* Shotline Selection data being sent to slaves */
        tienet_master_broadcast(selection_buf.data, selection_buf.ind);
        update = 1;

        TIENET_BUFFER_FREE(selection_buf);

        /* The data that will be sent to the observer */
        TIENET_BUFFER_SIZE(master.buf, result->ind - ind + 1);
        master.buf.ind = 0;
        bcopy(&result->data[ind], &master.buf.data[master.buf.ind], result->ind - ind);
        master.buf.ind += result->ind - ind;
      }
      break;

    case ADRT_WORK_MINMAX:
      /* The data that will be sent to the observer */
      TIENET_BUFFER_SIZE(master.buf, result->ind - ind);
      master.buf.ind = 0;
      bcopy(&result->data[ind], &master.buf.data[master.buf.ind], result->ind - ind);
      master.buf.ind += result->ind - ind;
      update = 1;
      break;

    default:
      break;
  }

  /* Alert the observers that a new frame is available for viewing */
  if (update)
    for (sock = master.socklist; sock; sock = sock->next)
      if (sock->next)
        if (!sock->frame_sem.val)
          tienet_sem_post (&(sock->frame_sem));
}


void*
master_networking (void *ptr)
{
  master_socket_t *sock, *tmp;
  struct sockaddr_in master_addr, observer_addr;
  fd_set readfds;
  int port, master_socket, highest_fd, new_socket, error;
  unsigned int addrlen;
  uint8_t op;
  uint16_t endian;


  port = *(int *) ptr;


  /* create a socket */
  if ((master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0)
  {
    fprintf (stderr, "unable to create socket, exiting.\n");
    exit(1);
  }

  /* initialize socket list */
  master.socklist = (master_socket_t *)malloc(sizeof(master_socket_t));
  master.socklist->next = NULL;
  master.socklist->prev = NULL;
  master.socklist->num = master_socket;

  highest_fd = master_socket;


  /* server address */
  master_addr.sin_family = AF_INET;
  master_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  master_addr.sin_port = htons(port);

  /* bind socket */
  if (bind (master_socket, (struct sockaddr *)&master_addr, sizeof(master_addr)) < 0)
  {
    fprintf(stderr, "observer socket already bound, exiting.\n");
    exit(1);
  }

  FD_ZERO(&readfds);
  FD_SET(master_socket, &readfds);

  /* listen for connections */
  listen (master.socklist->num, 3);

  addrlen = sizeof(observer_addr);
  master.active_connections = 0;

  while (master.alive || master.active_connections)
  {
    /* wait for some network activity */
    select(highest_fd+1, &readfds, NULL, NULL, NULL);

    /* cycle through each socket and address the activity */
    for (sock = master.socklist; sock; sock = sock->next)
    {
      /* if no longer alive then mark each of the active connections as no longer active */
      if (!master.alive)
        sock->active = 0;

      /* check if activity was on this socket */
      if (!FD_ISSET(sock->num, &readfds))
        continue;

      /* new connection */
      if (sock->num == master_socket)
      {
        new_socket = accept (master_socket, (struct sockaddr *)&observer_addr, &addrlen);
        if (new_socket >= 0)
        {
          tmp = master.socklist;
          master.socklist = (master_socket_t *)malloc(sizeof(master_socket_t));
          master.socklist->num = new_socket;
          master.socklist->controller = master.active_connections ? 0 : 1;
          master.socklist->active = 1;
          master.socklist->next = tmp;
          master.socklist->prev = NULL;
          tienet_sem_init(&(master.socklist->frame_sem), 0);
          tmp->prev = master.socklist;
          if (new_socket > highest_fd)
            highest_fd = new_socket;
          master.active_connections++;
        }
        continue;
      }

      /* remove socket from pool if there's an error, i.e slave disconnected */
      op = 255;
      error = tienet_recv (sock->num, &op, 1, 0);
      if (error || op == ADRT_NETOP_QUIT || !sock->active)
      {
        op = ADRT_NETOP_QUIT;
        tienet_send (sock->num, &op, 1, 0);

        tmp = sock;
        if (sock->prev)
          sock->prev->next = sock->next;
        /* master is always last, no need to check for sock->next next */
        sock->next->prev = sock->prev;
        if (sock == master.socklist)
          master.socklist = master.socklist->next;
        close(sock->num);
        sock = sock->next;
        free(tmp);
        master.active_connections--;
        continue;
      }


      /* standard communication */
      switch (op)
      {
        case ADRT_NETOP_SHUTDOWN:
          tienet_sem_post (&master.wait_sem);
          return (NULL);
          break;

        case ADRT_NETOP_INIT:
          /* send endian */
          endian = 1;
          tienet_send (sock->num, &endian, 2, 0);
          break;

        case ADRT_NETOP_REQWID:
          {
            uint16_t i;

            /*
            * Allocate a Workspace ID that the client application can
            * use to pass along to the slaves to associate a project id with.
            */
            i = 0;
            while (master.wid_list[i] && i < ADRT_MAX_WORKSPACE_NUM)
              i++;

            /* Mark this ID as being in use. */
            master.wid_list[i] = 1;

            /* Send this WID to the client application. */
            tienet_send (sock->num, &i, 2, 0);
          }
          break;

        case ADRT_NETOP_LOAD:
          {
            uint32_t size;
            void *mesg;

            tienet_recv (sock->num, &size, 4, 0);
            mesg = malloc (size);
            tienet_recv (sock->num, mesg, size, 0);
            tienet_master_broadcast(mesg, size);
            free(mesg);
          }
          break;

        case ADRT_NETOP_WORK:
          {
            uint16_t wid;

            /* Size */
            tienet_recv (sock->num, &master.slave_data_len, 4, 0);
            tienet_recv (sock->num, master.slave_data, master.slave_data_len, 0);

            op = master.slave_data[0];
            bcopy (&master.slave_data[1], &wid, 2);

            switch(op)
            {
              case ADRT_WORK_FRAME_ATTR:
                TCOPY(uint16_t, master.slave_data, 3, &master.image_w, 0);
                TCOPY(uint16_t, master.slave_data, 5, &master.image_h, 0);
                TCOPY(uint16_t, master.slave_data, 7, &master.image_format, 0);
                TIENET_BUFFER_SIZE(master.buf, 3 * master.image_w * master.image_h);
                tienet_master_broadcast(master.slave_data, master.slave_data_len);
                tienet_sem_post(&(sock->frame_sem));
                break;

              case ADRT_WORK_FRAME:
                {
                  /* Fill the work buffer */
                  master_dispatcher_generate(master.slave_data, master.slave_data_len, master.image_w, master.image_h, master.image_format);
                }
                break;

              case ADRT_WORK_SHOTLINE:
                tienet_master_push(master.slave_data, master.slave_data_len);
                break;

              case ADRT_WORK_SELECT:
                tienet_master_broadcast(master.slave_data, master.slave_data_len);
                tienet_sem_post(&(sock->frame_sem));
                break;

              case ADRT_WORK_STATUS:
                tienet_master_broadcast(master.slave_data, master.slave_data_len);
                break;

              case ADRT_WORK_MINMAX:
                tienet_master_push(master.slave_data, master.slave_data_len);
                break;

              default:
                break;
            }

            /* Wait for the result to come back */
            tienet_sem_wait(&(sock->frame_sem));

            /* Stamp the result with the work type */
            tienet_send (sock->num, &op, 1, 0);

            /* Workspace ID */
            tienet_send (sock->num, &wid, 2, 0);

            /* Size of result data */
            tienet_send (sock->num, &master.buf.ind, 4, 0);

#if ADRT_USE_COMPRESSION
            {
              unsigned long dest_len;
              unsigned int comp_size;

              dest_len = master.buf.ind + 32;
              TIENET_BUFFER_SIZE(master.buf_comp, dest_len);

              /* result data */
              compress(&master.buf_comp.data[sizeof(unsigned int)], &dest_len, master.buf.data, master.buf.ind);
              comp_size = dest_len;

              TCOPY(uint32_t, &comp_size, 0, master.buf_comp.data, 0);

              /* int compressed data size in bytes followed by actual rgb frame data */
              tienet_send (sock->num, master.buf_comp.data, comp_size + sizeof(unsigned int), 0);
            }
#else
            /* result data */
            tienet_send (sock->num, master.buf.data, master.buf.ind, 0);
#endif
          }
          break;

        case ADRT_NETOP_QUIT:
          master.active_connections = 0;
          break;

        default:
          break;
      }
    }

    /* Rebuild select list for next select call */
    highest_fd = 0;
    for (sock = master.socklist; sock; sock = sock->next)
    {
      if (sock->num > highest_fd)
        highest_fd = sock->num;
      FD_SET(sock->num, &readfds);
    }
  }

  /* free master.socklist */
  for (sock = master.socklist->next; sock; sock = sock->next)
    free(sock->prev);

  return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.29
log
@merge in the newer stuff
@
text
@d119 1
a119 1
isst_master_init (int port, int obs_port, char *list, char *exec, char *comp_host, int verbose)
d132 1
a132 1
  isst_compnet_connect(comp_host, ISST_COMPNET_PORT);
d135 1
a135 1
  isst_master_dispatcher_init();
d152 1
a152 1
  isst_master_dispatcher_free();
a359 1
printf("listening\n");
d497 1
a497 1
                  isst_master_dispatcher_generate(master.slave_data, master.slave_data_len, master.image_w, master.image_h, master.image_format);
@


1.28
log
@use the new tienet api... sorta...
@
text
@d33 1
a33 3
#include "SDL.h"		/* SDL */
#include "display.h"		/* Display utilities */
#include "canim.h"		/* Animation Stuff */
a34 1
#include "cdb.h"		/* Common structs and stuff */
d36 2
a37 4
#include "isst.h"		/* ISST Defines */
#include "image.h"		/* Image import/export utilities */
#include "pack.h"		/* Data packing for transport to nodes */
#include "isst_struct.h"	/* isst common structs */
a38 2
#include "umath.h"		/* Extended math utilities */
#include "isst_python.h"	/* Python code Interpreter */
d46 1
a46 1
#if ISST_USE_COMPRESSION
d52 5
a56 4
typedef struct isst_master_socket_s {
  int num;
  int controller;
  int active;
d58 36
a93 80
  struct isst_master_socket_s *prev;
  struct isst_master_socket_s *next;
} isst_master_socket_t;


void isst_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host);
void* isst_master_networking(void *ptr);
void isst_master_result(void *res_buf, int res_len);
void isst_master_update(void);
void isst_master_process_events(isst_event_t *event_queue, uint8_t event_num, isst_master_socket_t *sock);


/***** GLOBALS *****/
int isst_master_tile_num;
TIE_3 isst_master_camera_position;
TIE_3 isst_master_camera_focus;
TIE_3 isst_master_cor; /* center of rotation */
TIE_3 isst_master_shot_position;
TIE_3 isst_master_shot_direction;
TIE_3 isst_master_in_hit;
TIE_3 isst_master_out_hit;
tfloat isst_master_spall_angle;
tfloat isst_master_camera_azimuth;
tfloat isst_master_camera_elevation;

common_db_t db;
isst_master_socket_t *isst_master_socklist;
tienet_sem_t isst_master_frame_wait_sem;
void *isst_master_observer_frame;
pthread_mutex_t isst_master_observer_frame_mut;
void *rgb_frame;
int frame_ind;
char isst_master_slave_data[64];
int isst_master_slave_data_len;
pthread_t isst_master_networking_thread;
tfloat isst_master_scale;
int isst_master_active_connections;
int isst_master_alive;
unsigned char isst_master_rm;
pthread_mutex_t isst_master_update_mut;
int isst_master_mouse_grab;
int isst_master_shift_enabled;
/*******************/


static void isst_master_setup() {
  tfloat celev;

  isst_master_active_connections = 0;

  isst_master_alive = 1;
  isst_master_scale = 0.01;
  isst_master_mouse_grab = 0;
  isst_master_shift_enabled = 0;
  isst_master_spall_angle = 10;
  MATH_VEC_SET(isst_master_in_hit, 0, 0, 0);
  MATH_VEC_SET(isst_master_out_hit, 0, 0, 0);

  MATH_VEC_SET(isst_master_camera_position, 10, 10, 10);
  MATH_VEC_SET(isst_master_shot_position, 0, 0, 0);
  isst_master_camera_focus = isst_master_camera_position;

  celev = cos(35 * MATH_DEG2RAD);
  isst_master_camera_focus.v[0] -= cos(45 * MATH_DEG2RAD) * celev;
  isst_master_camera_focus.v[1] -= sin(45 * MATH_DEG2RAD) * celev;
  isst_master_camera_focus.v[2] -= sin(35 * MATH_DEG2RAD);

  isst_master_camera_azimuth = 45;
  isst_master_camera_elevation = 35;

  isst_master_rm = RENDER_METHOD_PHONG;

  frame_ind = 0;

  rgb_frame = malloc(3 * db.env.img_w * db.env.img_h);
  if (!rgb_frame) {
      perror("rgb_frame");
      exit(1);
  }
  memset(rgb_frame, 0, 3 * db.env.img_w * db.env.img_h);
a94 6
  isst_master_observer_frame = malloc(3 * db.env.img_w * db.env.img_h);
  if (!isst_master_observer_frame) {
      perror("isst_master_observer_frame");
      exit(1);
  }
}
d96 4
d101 1
a101 4
void isst_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host) {
  int frame_num, app_size;
  void *app_data;
  struct timeval start, cur;
d103 1
d105 1
a105 2
  /* Parse Env Data */
  common_db_load(&db, proj);
d107 4
a110 2
  /* Setup defaults */
  isst_master_setup();
d112 4
a115 2
  /* Initialize Python Processor */
  isst_python_init();
a116 2
  /* Mutex for everytime the master builds update data to send to nodes */
  pthread_mutex_init(&isst_master_update_mut, 0);
d118 5
a122 6
  /*
  * This mutex exists to prevent the observer from reading a frame while
  * the result function is writing to it, which would otherwise result in
  * the appearance of single buffering behavior for moderately high frame rates.
  */
  pthread_mutex_init(&isst_master_observer_frame_mut, 0);
d125 2
a126 2
  isst_master_tile_num = (db.env.img_w * db.env.img_h) / (db.env.tile_w * db.env.tile_h);
  tienet_master_init(port, isst_master_result, list, exec, 5, ISST_VER_KEY, 0);
d129 1
a129 1
  pthread_create(&isst_master_networking_thread, NULL, isst_master_networking,&obs_port);
d134 2
a135 9
  /* Parse and pack the application data */
  printf("loading scene... ");
  fflush(stdout);
  app_size = common_pack(&db, &app_data, proj);
  printf("done.\n");

  /* XXX FIX ME, I think this should be a "prep" message?
  tienet_master_prep(app_data, app_size);
  */
d137 1
a137 2
  /* Initialize the work dispatcher */
  isst_dispatcher_init();
d139 2
a140 38
  /* Data for computing fps */
  frame_num = 0;
  gettimeofday(&start, NULL);

  /*
  * Double buffer semaphore, never let more than 1 frame into the future
  * to be computed at any given time.  Without this, for 3 given frames
  * there is a possibility that while frame_0 and frame_1 are being computed
  * by the compute nodes, that frame_2 might be worked on by a compute node.
  * because frame indices are 0 or 1, hence double buffered, frame_0 and frame_2
  * have the same frame id and can therefore have resulting tiles over-write
  * one another resulting in a jittery image.
  */
  tienet_sem_init(&isst_master_frame_wait_sem, 1);

  while(isst_master_alive) {
    /* Double buffer semaphore, do not get too far ahead */
    tienet_sem_wait(&isst_master_frame_wait_sem);

    /* Update Camera Position */
    isst_master_update();

    /* Fill the work buffer */
    isst_dispatcher_generate(&db, isst_master_slave_data, isst_master_slave_data_len);

#if 0
    frame_num++;
    if(!(frame_num % 7)) {
      gettimeofday(&cur, NULL);
      printf("FPS: %.3f  SLAVES: %d    \r",
	    (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
	    tienet_master_socket_num);
      start = cur;
      frame_num = 0;
      fflush(stdout);
    }
#endif
  }
d152 1
a152 1
  isst_dispatcher_free();
d154 4
a157 1
  free(rgb_frame);
d159 3
a161 2
  /* End the networking thread */
  pthread_join(isst_master_networking_thread, NULL);
a162 2
  isst_python_free();
}
d164 40
d205 1
a205 49
void isst_master_result(void *res_buf, int res_len) {
  isst_master_socket_t *sock;
  common_work_t work;
  unsigned char *rgb_data;
  int i, ind, num;
  short frame;
  char name[256];
  unsigned char c;


  /* Work unit data */
  memcpy(&work, res_buf, sizeof(common_work_t));

  if(work.size_x == 0) {  /* ugly hack until I get a better identifier in place */
    char *mesg;
    short slop;

    /* Read and advance to data */
    ind = sizeof(common_work_t);

    /* first hit */
    memcpy(&isst_master_in_hit, &((unsigned char *)res_buf)[ind], sizeof(TIE_3));
    ind += sizeof(TIE_3);

    /* last hit */
    memcpy(&isst_master_out_hit, &((unsigned char *)res_buf)[ind], sizeof(TIE_3));
    ind += sizeof(TIE_3);

printf("in_hit: [%f, %f, %f], out_hit: [%f, %f, %f]\n", isst_master_in_hit.v[0], isst_master_in_hit.v[1], isst_master_in_hit.v[2], isst_master_out_hit.v[0], isst_master_out_hit.v[1], isst_master_out_hit.v[2]);

    /* Set the Center of of Rotation */
    MATH_VEC_ADD(isst_master_cor, isst_master_in_hit, isst_master_out_hit);
    MATH_VEC_MUL_SCALAR(isst_master_cor, isst_master_cor, 0.5);

    /* number of meshes */
    memcpy(&num, &((unsigned char *)res_buf)[ind], sizeof(int));
    ind += sizeof(int);

    /* reset the component server to collapse all fields */
    isst_compnet_reset();

    for(i = 0; i < num; i++) {
      memcpy(&c, &((unsigned char *)res_buf)[ind], 1);
      ind += 1;
      memcpy(name, &((unsigned char *)res_buf)[ind], c);
      ind += c;
printf("component[%d]: %s\n", i, name);
      isst_compnet_update(name, 1);
    }
d207 8
a214 6
    /* Send a message to update hitlist */
    mesg = malloc(sizeof(short) + res_len - sizeof(common_work_t) - 6*sizeof(tfloat));
    if (!mesg) {
	perror("mesg");
	exit(1);
    }
d216 73
a288 22
    ind = 0;
    slop = ISST_OP_SHOT;
    memcpy(&((char *)mesg)[ind], &slop, sizeof(short));
    ind += sizeof(short);

    memcpy(&((char *)mesg)[ind], &((unsigned char *)res_buf)[sizeof(common_work_t) + 6*sizeof(tfloat)], res_len - sizeof(common_work_t) - 6*sizeof(tfloat));
    ind += res_len - sizeof(common_work_t) - 6*sizeof(tfloat);

    tienet_master_broadcast(mesg, ind);
    free(mesg);
  } else {
    /* Pointer to RGB Data */
    rgb_data = &((unsigned char *)res_buf)[sizeof(common_work_t)];

    frame_ind++;

    /* Copy the tile into the image */
    ind = 0;
    for(i = work.orig_y; i < work.orig_y + work.size_y; i++) {
      memcpy(&((char *)rgb_frame)[3 * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 3*work.size_y);
      ind += 3*work.size_y;
    }
d290 8
d299 2
a300 19
    /* Image is complete, draw the frame. */
    if(frame_ind == isst_master_tile_num) {
      frame_ind = 0;

      /* Copy this frame to the observer frame buffer */
      pthread_mutex_lock(&isst_master_observer_frame_mut);
      memcpy(isst_master_observer_frame, rgb_frame, 3 * db.env.img_w * db.env.img_h);
      pthread_mutex_unlock(&isst_master_observer_frame_mut);

      /* Allow the next frame to be computed */
      tienet_sem_post(&isst_master_frame_wait_sem);

      /* Alert the observers that a new frame is available for viewing */
      for(sock = isst_master_socklist; sock; sock = sock->next) {
	if(sock->next)
	  if(!sock->frame_sem.val)
	    tienet_sem_post(&(sock->frame_sem));
      }
    }
d302 7
d312 5
a316 3
void* isst_master_networking(void *ptr) {
  isst_master_socket_t *sock, *tmp;
  struct sockaddr_in master, observer;
d320 2
a321 5
  unsigned char op;
  short endian;
#if ISST_USE_COMPRESSION
  void *comp_buf;
#endif
d324 1
a324 1
  port = *(int *)ptr;
a326 8
#if ISST_USE_COMPRESSION
  comp_buf = malloc(3 * db.env.img_w * db.env.img_h + 1024);
  if (!comp_buf) {
      perror("comp_buf");
      exit(1);
  }
#endif

d328 3
a330 2
  if((master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    fprintf(stderr, "unable to create socket, exiting.\n");
d335 4
a338 8
  isst_master_socklist = (isst_master_socket_t *)malloc(sizeof(isst_master_socket_t));
  if (!isst_master_socklist) {
      perror("isst_master_socklist");
      exit(1);
  }
  isst_master_socklist->next = NULL;
  isst_master_socklist->prev = NULL;
  isst_master_socklist->num = master_socket;
d344 3
a346 3
  master.sin_family = AF_INET;
  master.sin_addr.s_addr = htonl(INADDR_ANY);
  master.sin_port = htons(port);
d349 2
a350 1
  if(bind(master_socket, (struct sockaddr *)&master, sizeof(master)) < 0) {
d359 2
a360 1
  listen(isst_master_socklist->num, 3);
d362 2
a363 2
  addrlen = sizeof(observer);
  isst_master_active_connections = 0;
d365 2
a366 1
  while(isst_master_alive || isst_master_active_connections) {
d369 1
d371 2
a372 1
    for(sock = isst_master_socklist; sock; sock = sock->next) {
d374 2
a375 2
      if(!isst_master_alive)
	sock->active = 0;
d378 174
a551 87
      if(FD_ISSET(sock->num, &readfds)) {
	if(sock->num == master_socket) {
	  /* new connection */
	  new_socket = accept(master_socket, (struct sockaddr *)&observer, &addrlen);
	  if(new_socket >= 0) {
	    tmp = isst_master_socklist;
	    isst_master_socklist = (isst_master_socket_t *)malloc(sizeof(isst_master_socket_t));
	    if (!isst_master_socklist) {
		perror("isst_master_socklist");
		exit(1);
	    }
	    isst_master_socklist->num = new_socket;
	    isst_master_socklist->controller = isst_master_active_connections ? 0 : 1;
	    isst_master_socklist->active = 1;
	    isst_master_socklist->next = tmp;
	    isst_master_socklist->prev = NULL;
	    tienet_sem_init(&(isst_master_socklist->frame_sem), 0);
	    tmp->prev = isst_master_socklist;
	    if(new_socket > highest_fd)
	      highest_fd = new_socket;
	    isst_master_active_connections++;
	  }
	} else {
	  op = 255;
	  /* observer communication */
	  error = tienet_recv(sock->num, &op, 1, 0);

	  /* remove socket from pool if there's an error, i.e slave disconnected */
	  if(error || op == ISST_NET_OP_QUIT || !sock->active) {
	    op = ISST_NET_OP_QUIT;
	    tienet_send(sock->num, &op, 1, 0);

	    tmp = sock;
	    if(sock->prev)
	      sock->prev->next = sock->next;
	    /* master is always last, no need to check for sock->next next */
	    sock->next->prev = sock->prev;
	    if(sock == isst_master_socklist)
	      isst_master_socklist = isst_master_socklist->next;
	    close(sock->num);
	    sock = sock->next;
	    free(tmp);
	    isst_master_active_connections--;

	  } else {
	    switch(op) {
	      case ISST_NET_OP_INIT:
		/* Send screen width and height */
		endian = 1;
		tienet_send(sock->num, &endian, sizeof(short), 0);
		tienet_send(sock->num, &db.env.img_w, sizeof(int), 0);
		tienet_send(sock->num, &db.env.img_h, sizeof(int), 0);
		break;

	      case ISST_NET_OP_FRAME:
		tienet_sem_wait(&(sock->frame_sem));

		/* Let observer know everything is okay, continue as usual. */
		op = ISST_NET_OP_NOP;
		tienet_send(sock->num, &op, 1, 0);

		{
		  isst_event_t event_queue[64];
		  uint8_t event_num;

		  /* Get the event Queue and process it */
		  tienet_recv(sock->num, &event_num, sizeof(uint8_t), 0);
		  if(event_num)
		    tienet_recv(sock->num, event_queue, event_num * sizeof(isst_event_t), 0);
		  isst_master_process_events(event_queue, event_num, sock);
		}

#if ISST_USE_COMPRESSION
		{
		  unsigned long dest_len;
		  unsigned int comp_size;
		  dest_len = 3 * db.env.img_w * db.env.img_h + 1024;

		  /* frame data */
		  pthread_mutex_lock(&isst_master_observer_frame_mut);
		  compress(&((char *)comp_buf)[sizeof(unsigned int)], &dest_len, isst_master_observer_frame, 3 * db.env.img_w * db.env.img_h);
		  pthread_mutex_unlock(&isst_master_observer_frame_mut);
		  comp_size = dest_len;
		  memcpy(comp_buf, &comp_size, sizeof(unsigned int));
		  /* int for frame size in bytes followed by actual rgb frame data */
		  tienet_send(sock->num, comp_buf, comp_size + sizeof(unsigned int), 0);
		}
d553 2
a554 4
		/* frame data */
		pthread_mutex_lock(&isst_master_observer_frame_mut);
		tienet_send(sock->num, isst_master_observer_frame, db.env.img_w * db.env.img_h * 3, 0);
		pthread_mutex_unlock(&isst_master_observer_frame_mut);
d556 6
d563 2
a564 57
		/* Send overlay data */
		{
		  isst_overlay_data_t overlay;

		  overlay.camera_position = isst_master_camera_position;
		  overlay.camera_azimuth = isst_master_camera_azimuth;
		  overlay.camera_elevation = isst_master_camera_elevation;
		  overlay.compute_nodes = tienet_master_active_slaves;
		  overlay.in_hit = isst_master_in_hit;
		  overlay.out_hit = isst_master_out_hit;
		  overlay.scale = isst_master_scale;
		  sprintf(overlay.resolution, "%dx%d", db.env.img_w, db.env.img_h);
		  overlay.controller = sock->controller;

		  tienet_send(sock->num, &overlay, sizeof(isst_overlay_data_t), 0);
		}

		/* Lock things down so that isst_master_update data doesn't get tainted */
		pthread_mutex_lock(&isst_master_update_mut);

		pthread_mutex_unlock(&isst_master_update_mut);
		break;

	      case ISST_NET_OP_MESG:
		{
		  char *string;
		  int len;

		  string = (char *)malloc(1024);
		  if (!string) {
		      perror("string");
		      exit(1);
		  }
		  tienet_recv(sock->num, &len, 1, 0);
		  tienet_recv(sock->num, string, len, 0);

		  isst_python_code(string);
		  len = strlen(string) + 1;

		  tienet_send(sock->num, &len, 1, 0);
		  tienet_send(sock->num, string, len, 0);

		  free(string);
		}
		break;


	      case ISST_NET_OP_QUIT:
		isst_master_active_connections = 0;
		break;


	      default:
		break;
	    }
	  }
	}
d570 4
a573 3
    for(sock = isst_master_socklist; sock; sock = sock->next) {
      if(sock->num > highest_fd)
	highest_fd = sock->num;
d578 2
a579 7
#if ISST_USE_COMPRESSION
  free(comp_buf);
#endif


  /* free isst_master_socklist */
  for(sock = isst_master_socklist->next; sock; sock = sock->next)
a584 477

/* additional baggage that goes with each work unit */
void isst_master_update() {
  char op;

  isst_master_slave_data_len = 0;

  /* Lock things down so that isst_master_update data doesn't get tainted */
  pthread_mutex_lock(&isst_master_update_mut);

  /* function */
  op = ISST_OP_RENDER;
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &op, 1);
  isst_master_slave_data_len += 1;

  /* Camera Position */
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], isst_master_camera_position.v, sizeof(TIE_3));
  isst_master_slave_data_len += sizeof(TIE_3);

  /* Camera Focus */
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], isst_master_camera_focus.v, sizeof(TIE_3));
  isst_master_slave_data_len += sizeof(TIE_3);

  /* Rendering Method and Data */
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_rm, 1);
  isst_master_slave_data_len += 1;

  switch(isst_master_rm) {
    case RENDER_METHOD_PLANE:
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_position, sizeof(TIE_3));
      isst_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_direction, sizeof(TIE_3));
      isst_master_slave_data_len += sizeof(TIE_3);
      break;

    case RENDER_METHOD_SPALL:
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_in_hit, sizeof(TIE_3));
      isst_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_direction, sizeof(TIE_3));
      isst_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_spall_angle, sizeof(tfloat));
      isst_master_slave_data_len += sizeof(tfloat);
      break;

    default:
      break;
  }

  pthread_mutex_unlock(&isst_master_update_mut);
}


void isst_master_process_events(isst_event_t *event_queue, uint8_t event_num, isst_master_socket_t *sock) {
  int i, update;
  TIE_3 vec, vec2, vec3;
  tfloat celev;


  for(i = 0; i < event_num; i++) {
    update = 0;
    switch(event_queue[i].type) {
      printf("event_type: %d\n", event_queue[i].type);
      case SDL_KEYDOWN:
	update = 1;
	switch(event_queue[i].keysym) {
	  case SDLK_LSHIFT:
	  case SDLK_RSHIFT:
	    isst_master_shift_enabled = 1;
	    break;

	  case SDLK_1: /* RENDER_METHOD_PHONG */
	    isst_master_rm = RENDER_METHOD_PHONG;
	    break;

	  case SDLK_2: /* RENDER_METHOD_PLANE */
	    isst_master_rm = RENDER_METHOD_PLANE;
	    break;

	  case SDLK_3: /* RENDER_METHOD_SPALL */
	    isst_master_rm = RENDER_METHOD_SPALL;
	    break;

	  case SDLK_4: /* RENDER_METHOD_COMPONENT */
	    isst_master_rm = RENDER_METHOD_COMPONENT;
	    break;

	  case SDLK_8: /* RENDER_METHOD_DEPTH */
	    isst_master_rm = RENDER_METHOD_DEPTH;
	    break;

	  case SDLK_9: /* RENDER_METHOD_GRID */
	    isst_master_rm = RENDER_METHOD_GRID;
	    break;

	  case SDLK_0: /* RENDER_METHOD_NORMAL */
	    isst_master_rm = RENDER_METHOD_NORMAL;
	    break;


	  case SDLK_UP:
	    MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
	    MATH_VEC_MUL_SCALAR(vec, vec, isst_master_scale*10.0);
	    MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec);
	    break;

	  case SDLK_DOWN:
	    MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
	    MATH_VEC_MUL_SCALAR(vec, vec, isst_master_scale*10.0);
	    MATH_VEC_SUB(isst_master_camera_position, isst_master_camera_position, vec);
	    break;

	  case SDLK_LEFT:
	    /* strafe left */
	    MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
	    MATH_VEC_SET(vec2, 0, 0, 1);
	    MATH_VEC_CROSS(vec3, vec2, vec);
	    MATH_VEC_MUL_SCALAR(vec3, vec3, (isst_master_scale*10.0));
	    MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec3);
	    break;

	  case SDLK_RIGHT:
	    /* strafe right */
	    MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
	    MATH_VEC_SET(vec2, 0, 0, 1);
	    MATH_VEC_CROSS(vec3, vec2, vec);
	    MATH_VEC_MUL_SCALAR(vec3, vec3, (isst_master_scale*10.0));
	    MATH_VEC_SUB(isst_master_camera_position, isst_master_camera_position, vec3);
	    break;

	  case SDLK_F12: /* Server Shutdown and quit*/
	    isst_master_alive = 0;
	    break;

	  case SDLK_d: /* detach */
	    sock->active = 0;
	    break;

	  case SDLK_e: /* export frame */
#if 0
	    pthread_mutex_lock(&isst_observer_gui_mut);
	    {
	      char filename[32];
	      void *image24;
	      strcpy(filename, "frame.ppm");
	      image24 = malloc(3 * screen_w * screen_h);
	      if (!image24) {
		  perror("image24");
		  exit(1);
	      }
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
	      util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
#else
	      util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 1);
#endif
	      util_display_text_input("export_frame", filename, 32);
	      util_image_save_ppm(filename, image24, screen_w, screen_h);
	    }
	    pthread_mutex_unlock(&isst_observer_gui_mut);
#endif
	    break;

	  case SDLK_f: /* fullscreen toggle */
	    /* Reserved for Fullscreen */
	    break;

	  case SDLK_g: /* grab mouse */
	    isst_master_mouse_grab = isst_master_mouse_grab ^ 1;
	    break;

	  case SDLK_KP1: /* front, back */
	    {
	      tfloat dist;

	      /* distance to center of rotation */
	      MATH_VEC_SUB(vec, isst_master_camera_position, isst_master_cor);
	      MATH_VEC_DOT(dist, vec, vec);
	      dist = sqrt(dist);

	      isst_master_camera_position = isst_master_cor;
	      if(isst_master_shift_enabled) {
		isst_master_camera_position.v[0] -= dist;
		isst_master_camera_azimuth = 180;
		isst_master_camera_elevation = 0;
	      } else {
		isst_master_camera_position.v[0] += dist;
		isst_master_camera_azimuth = 0;
		isst_master_camera_elevation = 0;
	      }
	    }
	    break;

	  case SDLK_KP3: /* right, left */
	    {
	      tfloat dist;

	      /* distance to center of rotation */
	      MATH_VEC_SUB(vec, isst_master_camera_position, isst_master_cor);
	      MATH_VEC_DOT(dist, vec, vec);
	      dist = sqrt(dist);

	      isst_master_camera_position = isst_master_cor;
	      if(isst_master_shift_enabled) {
		isst_master_camera_position.v[1] -= dist;
		isst_master_camera_azimuth = 270;
		isst_master_camera_elevation = 0;
	      } else {
		isst_master_camera_position.v[1] += dist;
		isst_master_camera_azimuth = 90;
		isst_master_camera_elevation = 0;
	      }
	    }
	    break;

	  case SDLK_KP7: /* top, bottom */
	    {
	      tfloat dist;

	      /* distance to center of rotation */
	      MATH_VEC_SUB(vec, isst_master_camera_position, isst_master_cor);
	      MATH_VEC_DOT(dist, vec, vec);
	      dist = sqrt(dist);

	      isst_master_camera_position = isst_master_cor;
	      if(isst_master_shift_enabled) {
		isst_master_camera_position.v[2] -= dist;
		isst_master_camera_azimuth = 0;
		isst_master_camera_elevation = -90 + 0.01;
	      } else {
		isst_master_camera_position.v[2] += dist;
		isst_master_camera_azimuth = 0;
		isst_master_camera_elevation = 90 - 0.01;
	      }
	    }
	    break;

	  case SDLK_KP0: /* set camera position and direction to shot position and direction */
	    isst_master_camera_position = isst_master_shot_position;
	    /* project and unitize shot vector onto xy plane */
	    vec = isst_master_shot_direction;
	    vec.v[2] = 0;
	    MATH_VEC_UNITIZE(vec);

	    isst_master_camera_azimuth = fmod(180 + (vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*MATH_RAD2DEG : acos(vec.v[0])*MATH_RAD2DEG), 360.0);
	    isst_master_camera_elevation = -asin(isst_master_shot_direction.v[2]) * MATH_RAD2DEG;
	    break;


	  case SDLK_KP_DIVIDE: /* shotline */
	    {
	      void *mesg;
	      common_work_t work;
	      TIE_3 direction;
	      int dlen;
	      char op;

	      /* Queue a work unit for a shot needed for the plane render method */
	      mesg = malloc(sizeof(common_work_t) + 1 + 2*sizeof(TIE_3));
	      if (!mesg) {
		  perror("mesg");
		  exit(1);
	      }
	      dlen = 0;

	      work.orig_x = 0;
	      work.orig_y = 0;
	      work.size_x = 0;
	      work.size_y = 0;

	      memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
	      dlen += sizeof(common_work_t);

	      /* function */
	      op = ISST_OP_SHOT;
	      memcpy(&((char *)mesg)[dlen], &op, 1);
	      dlen += 1;

	      /* position */
	      memcpy(&((char *)mesg)[dlen], &isst_master_camera_position, sizeof(TIE_3));
	      dlen += sizeof(TIE_3);

	      MATH_VEC_SUB(direction, isst_master_camera_focus, isst_master_camera_position);
	      MATH_VEC_UNITIZE(direction);

	      /* direction */
	      memcpy(&((char *)mesg)[dlen], &direction, sizeof(TIE_3));
	      dlen += sizeof(TIE_3);

	      isst_master_shot_position = isst_master_camera_position;
	      isst_master_shot_direction = direction;

	      tienet_master_push(mesg, dlen);
	      free(mesg);
	    }
	    break;

	  case SDLK_KP_MULTIPLY: /* spawl cone */
	    {
	      void *mesg;
	      common_work_t work;
	      TIE_3 direction;
	      int dlen;
	      char op;

	      /* Queue a work unit for a shot needed for the plane render method */
	      mesg = malloc(sizeof(common_work_t) + 1 + 2*sizeof(TIE_3) + sizeof(tfloat));
	      if (!mesg) {
		  perror("mesg");
		  exit(1);
	      }
	      dlen = 0;

	      work.orig_x = 0;
	      work.orig_y = 0;
	      work.size_x = 0;
	      work.size_y = 0;

	      memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
	      dlen += sizeof(common_work_t);

	      /* function */
	      op = ISST_OP_SPALL;
	      memcpy(&((char *)mesg)[dlen], &op, 1);
	      dlen += 1;

	      /* position */
	      memcpy(&((char *)mesg)[dlen], &isst_master_camera_position, sizeof(TIE_3));
	      dlen += sizeof(TIE_3);

	      MATH_VEC_SUB(direction, isst_master_camera_focus, isst_master_camera_position);
	      MATH_VEC_UNITIZE(direction);

	      /* direction */
	      memcpy(&((char *)mesg)[dlen], &direction, sizeof(TIE_3));
	      dlen += sizeof(TIE_3);

	      /* angle */
	      memcpy(&((char *)mesg)[dlen], &isst_master_spall_angle, sizeof(tfloat));
	      dlen += sizeof(tfloat);

	      isst_master_shot_position = isst_master_camera_position;
	      isst_master_shot_direction = direction;

	      tienet_master_push(mesg, dlen);
	      free(mesg);
	    }
	    break;


	  case SDLK_BACKQUOTE: /* console */
	    /* reserved for console in observer */
	    break;

	  default:
	    break;
	}
	break;

      case SDL_KEYUP:
	switch(event_queue[i].keysym) {
	  case SDLK_LSHIFT:
	  case SDLK_RSHIFT:
	    isst_master_shift_enabled = 0;
	    break;

	  default:
	    break;
	}

      case SDL_MOUSEBUTTONDOWN:
	update = 1;
	if(event_queue[i].button == SDL_BUTTON_WHEELUP)
	  isst_master_scale *= 1.25;

	if(event_queue[i].button == SDL_BUTTON_WHEELDOWN)
	  isst_master_scale *= 0.8;
	break;

      case SDL_MOUSEMOTION:
	if(event_queue[i].motion_state && isst_master_mouse_grab) {
	  int dx, dy;

	  dx = -event_queue[i].motion_xrel;
	  dy = -event_queue[i].motion_yrel;

	  update = 1;
	  if(event_queue[i].button & 1<<(SDL_BUTTON_LEFT-1)) {
	    /* backward and forward */
	    MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
	    MATH_VEC_MUL_SCALAR(vec, vec, (isst_master_scale*dy));
	    MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec);

	    /* strafe */
#if 0
	    MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
	    vec2.v[0] = 0;
	    vec2.v[1] = 0;
	    vec2.v[2] = 1;
	    MATH_VEC_CROSS(vec3, vec2, vec);
	    MATH_VEC_MUL_SCALAR(vec3, vec3, (isst_master_scale*dx));
	    MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec3);
#endif
	  } else if(event_queue[i].button & 1<<(SDL_BUTTON_RIGHT-1)) {
	    /* if the shift key is held down then rotate about Center of Rotation */
	    if(isst_master_shift_enabled) {
	      TIE_3 vec;
	      tfloat mag, angle;

	      vec.v[0] = isst_master_cor.v[0] - isst_master_camera_position.v[0];
	      vec.v[1] = isst_master_cor.v[1] - isst_master_camera_position.v[1];
	      vec.v[2] = 0;

#if 0
	      MATH_VEC_UNITIZE(vec);
	      MATH_VEC_MAGnitude(mag, vec);
#else
	      angle = vec.v[0]*vec.v[0] + vec.v[1]*vec.v[1];
	      mag = sqrt(angle);
	      vec.v[0] /= mag;
	      vec.v[1] /= mag;
#endif

	      vec.v[0] = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*MATH_RAD2DEG : acos(vec.v[0])*MATH_RAD2DEG;

	      vec.v[0] -= 0.035*dx;
	      vec.v[0] *= MATH_DEG2RAD;

	      isst_master_camera_position.v[0] = -mag*cos(vec.v[0]) + isst_master_cor.v[0];
	      isst_master_camera_position.v[1] = -mag*sin(vec.v[0]) + isst_master_cor.v[1];
	      isst_master_camera_azimuth -= 0.035*dx;
	    } else {
	      isst_master_camera_azimuth += 0.035*dx;
	      isst_master_camera_elevation -= 0.035*dy;
	    }
	  } else if(event_queue[i].button & 1<<(SDL_BUTTON_MIDDLE-1)) {
	    isst_master_camera_position.v[2] += isst_master_scale*dy;

	    /* strafe */
	    MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
	    MATH_VEC_SET(vec2, 0, 0, 1);
	    MATH_VEC_CROSS(vec3, vec2, vec);
	    MATH_VEC_MUL_SCALAR(vec3, vec3, (isst_master_scale*dx));
	    MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec3);
	  }

	  /* Keep azimuth position */
	  if(isst_master_camera_azimuth < 0)
	    isst_master_camera_azimuth += 360;
	  if(isst_master_camera_azimuth > 360)
	    isst_master_camera_azimuth -= 360;

	  /* Keep elevation between -90 and +90 */
	  if(isst_master_camera_elevation < -90)
	    isst_master_camera_elevation = -90;
	  if(isst_master_camera_elevation > 90)
	    isst_master_camera_elevation = 90;

	}
	break;

      default:
	break;
    }

    if(update) {
      /* Update the camera data based on the current azimuth and elevation */
      isst_master_camera_focus = isst_master_camera_position;
      celev = cos(isst_master_camera_elevation * MATH_DEG2RAD);
      isst_master_camera_focus.v[0] -= cos(isst_master_camera_azimuth * MATH_DEG2RAD) * celev;
      isst_master_camera_focus.v[1] -= sin(isst_master_camera_azimuth * MATH_DEG2RAD) * celev;
      isst_master_camera_focus.v[2] -= sin(isst_master_camera_elevation * MATH_DEG2RAD);
    }
  }
}

@


1.27
log
@TFLOAT changed to tfloat.  also quell a few warnings/bugs related to passing the wrong TIE_3 pointer type.
@
text
@d180 1
a180 1
  tienet_master_init(port, isst_master_result, list, exec, 5, ISST_VER_KEY);
d194 1
d196 1
@


1.26
log
@the variable is "isst_master_observer_frame", not "isst_master_observer".
@
text
@d85 3
a87 3
TFLOAT isst_master_spall_angle;
TFLOAT isst_master_camera_azimuth;
TFLOAT isst_master_camera_elevation;
d99 1
a99 1
TFLOAT isst_master_scale;
d110 1
a110 1
  TFLOAT celev;
d229 1
a229 1
	    (TFLOAT)(frame_num) / ((cur.tv_sec + (TFLOAT)cur.tv_usec/1000000.0) - (start.tv_sec + (TFLOAT)start.tv_usec/1000000.0)),
d310 1
a310 1
    mesg = malloc(sizeof(short) + res_len - sizeof(common_work_t) - 6*sizeof(TFLOAT));
d321 2
a322 2
    memcpy(&((char *)mesg)[ind], &((unsigned char *)res_buf)[sizeof(common_work_t) + 6*sizeof(TFLOAT)], res_len - sizeof(common_work_t) - 6*sizeof(TFLOAT));
    ind += res_len - sizeof(common_work_t) - 6*sizeof(TFLOAT);
d654 2
a655 2
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_spall_angle, sizeof(TFLOAT));
      isst_master_slave_data_len += sizeof(TFLOAT);
d669 1
a669 1
  TFLOAT celev;
d785 1
a785 1
	      TFLOAT dist;
d807 1
a807 1
	      TFLOAT dist;
d829 1
a829 1
	      TFLOAT dist;
d918 1
a918 1
	      mesg = malloc(sizeof(common_work_t) + 1 + 2*sizeof(TIE_3) + sizeof(TFLOAT));
d950 2
a951 2
	      memcpy(&((char *)mesg)[dlen], &isst_master_spall_angle, sizeof(TFLOAT));
	      dlen += sizeof(TFLOAT);
d1019 1
a1019 1
	      TFLOAT mag, angle;
@


1.25
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d146 2
a147 2
  if (!isst_master_observer) {
      perror("isst_master_observer");
@


1.24
log
@give adrt some distinctiveness in the header
@
text
@d139 4
d146 4
d311 4
d381 4
d395 4
d443 4
d559 4
d759 4
d871 4
d919 4
@


1.23
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
@


1.22
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d85 3
a87 3
tfloat isst_master_spall_angle;
tfloat isst_master_camera_azimuth;
tfloat isst_master_camera_elevation;
d99 1
a99 1
tfloat isst_master_scale;
d110 1
a110 1
  tfloat celev;
d221 1
a221 1
	    (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
d302 1
a302 1
    mesg = malloc(sizeof(short) + res_len - sizeof(common_work_t) - 6*sizeof(tfloat));
d309 2
a310 2
    memcpy(&((char *)mesg)[ind], &((unsigned char *)res_buf)[sizeof(common_work_t) + 6*sizeof(tfloat)], res_len - sizeof(common_work_t) - 6*sizeof(tfloat));
    ind += res_len - sizeof(common_work_t) - 6*sizeof(tfloat);
d626 2
a627 2
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_spall_angle, sizeof(tfloat));
      isst_master_slave_data_len += sizeof(tfloat);
d641 1
a641 1
  tfloat celev;
d753 1
a753 1
	      tfloat dist;
d775 1
a775 1
	      tfloat dist;
d797 1
a797 1
	      tfloat dist;
d882 1
a882 1
	      mesg = malloc(sizeof(common_work_t) + 1 + 2*sizeof(TIE_3) + sizeof(tfloat));
d910 2
a911 2
	      memcpy(&((char *)mesg)[dlen], &isst_master_spall_angle, sizeof(tfloat));
	      dlen += sizeof(tfloat);
d979 1
a979 1
	      tfloat mag, angle;
@


1.21
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d221 2
a222 2
            (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
            tienet_master_socket_num);
d342 3
a344 3
        if(sock->next)
          if(!sock->frame_sem.val)
            tienet_sem_post(&(sock->frame_sem));
d413 1
a413 1
        sock->active = 0;
d417 66
a482 66
        if(sock->num == master_socket) {
          /* new connection */
          new_socket = accept(master_socket, (struct sockaddr *)&observer, &addrlen);
          if(new_socket >= 0) {
            tmp = isst_master_socklist;
            isst_master_socklist = (isst_master_socket_t *)malloc(sizeof(isst_master_socket_t));
            isst_master_socklist->num = new_socket;
            isst_master_socklist->controller = isst_master_active_connections ? 0 : 1;
            isst_master_socklist->active = 1;
            isst_master_socklist->next = tmp;
            isst_master_socklist->prev = NULL;
            tienet_sem_init(&(isst_master_socklist->frame_sem), 0);
            tmp->prev = isst_master_socklist;
            if(new_socket > highest_fd)
              highest_fd = new_socket;
            isst_master_active_connections++;
          }
        } else {
          op = 255;
          /* observer communication */
          error = tienet_recv(sock->num, &op, 1, 0);

          /* remove socket from pool if there's an error, i.e slave disconnected */
          if(error || op == ISST_NET_OP_QUIT || !sock->active) {
            op = ISST_NET_OP_QUIT;
            tienet_send(sock->num, &op, 1, 0);

            tmp = sock;
            if(sock->prev)
              sock->prev->next = sock->next;
            /* master is always last, no need to check for sock->next next */
            sock->next->prev = sock->prev;
            if(sock == isst_master_socklist)
              isst_master_socklist = isst_master_socklist->next;
            close(sock->num);
            sock = sock->next;
            free(tmp);
            isst_master_active_connections--;

          } else {
            switch(op) {
              case ISST_NET_OP_INIT:
                /* Send screen width and height */
                endian = 1;
                tienet_send(sock->num, &endian, sizeof(short), 0);
                tienet_send(sock->num, &db.env.img_w, sizeof(int), 0);
                tienet_send(sock->num, &db.env.img_h, sizeof(int), 0);
                break;

              case ISST_NET_OP_FRAME:
                tienet_sem_wait(&(sock->frame_sem));

                /* Let observer know everything is okay, continue as usual. */
                op = ISST_NET_OP_NOP;
                tienet_send(sock->num, &op, 1, 0);

                {
                  isst_event_t event_queue[64];
                  uint8_t event_num;

                  /* Get the event Queue and process it */
                  tienet_recv(sock->num, &event_num, sizeof(uint8_t), 0);
                  if(event_num)
                    tienet_recv(sock->num, event_queue, event_num * sizeof(isst_event_t), 0);
                  isst_master_process_events(event_queue, event_num, sock);
                }
d485 14
a498 14
                {
                  unsigned long dest_len;
                  unsigned int comp_size;
                  dest_len = 3 * db.env.img_w * db.env.img_h + 1024;

                  /* frame data */
                  pthread_mutex_lock(&isst_master_observer_frame_mut);
                  compress(&((char *)comp_buf)[sizeof(unsigned int)], &dest_len, isst_master_observer_frame, 3 * db.env.img_w * db.env.img_h);
                  pthread_mutex_unlock(&isst_master_observer_frame_mut);
                  comp_size = dest_len;
                  memcpy(comp_buf, &comp_size, sizeof(unsigned int));
                  /* int for frame size in bytes followed by actual rgb frame data */
                  tienet_send(sock->num, comp_buf, comp_size + sizeof(unsigned int), 0);
                }
d500 4
a503 4
                /* frame data */
                pthread_mutex_lock(&isst_master_observer_frame_mut);
                tienet_send(sock->num, isst_master_observer_frame, db.env.img_w * db.env.img_h * 3, 0);
                pthread_mutex_unlock(&isst_master_observer_frame_mut);
d506 53
a558 53
                /* Send overlay data */
                {
                  isst_overlay_data_t overlay;

                  overlay.camera_position = isst_master_camera_position;
                  overlay.camera_azimuth = isst_master_camera_azimuth;
                  overlay.camera_elevation = isst_master_camera_elevation;
                  overlay.compute_nodes = tienet_master_active_slaves;
                  overlay.in_hit = isst_master_in_hit;
                  overlay.out_hit = isst_master_out_hit;
                  overlay.scale = isst_master_scale;
                  sprintf(overlay.resolution, "%dx%d", db.env.img_w, db.env.img_h);
                  overlay.controller = sock->controller;

                  tienet_send(sock->num, &overlay, sizeof(isst_overlay_data_t), 0);
                }

                /* Lock things down so that isst_master_update data doesn't get tainted */
                pthread_mutex_lock(&isst_master_update_mut);

                pthread_mutex_unlock(&isst_master_update_mut);
                break;

              case ISST_NET_OP_MESG:
                {
                  char *string;
                  int len;

                  string = (char *)malloc(1024);
                  tienet_recv(sock->num, &len, 1, 0);
                  tienet_recv(sock->num, string, len, 0);

                  isst_python_code(string);
                  len = strlen(string) + 1;

                  tienet_send(sock->num, &len, 1, 0);
                  tienet_send(sock->num, string, len, 0);

                  free(string);
                }
                break;


              case ISST_NET_OP_QUIT:
                isst_master_active_connections = 0;
                break;


              default:
                break;
            }
          }
        }
d566 1
a566 1
        highest_fd = sock->num;
d649 69
a717 73
        update = 1;
        switch(event_queue[i].keysym) {
          case SDLK_LSHIFT:
          case SDLK_RSHIFT:
            isst_master_shift_enabled = 1;
            break;

          case SDLK_1: /* RENDER_METHOD_PHONG */
            isst_master_rm = RENDER_METHOD_PHONG;
            break;

          case SDLK_2: /* RENDER_METHOD_PLANE */
            isst_master_rm = RENDER_METHOD_PLANE;
            break;

          case SDLK_3: /* RENDER_METHOD_SPALL */
            isst_master_rm = RENDER_METHOD_SPALL;
            break;

          case SDLK_4: /* RENDER_METHOD_COMPONENT */
            isst_master_rm = RENDER_METHOD_COMPONENT;
            break;

          case SDLK_8: /* RENDER_METHOD_DEPTH */
            isst_master_rm = RENDER_METHOD_DEPTH;
            break;

          case SDLK_9: /* RENDER_METHOD_GRID */
            isst_master_rm = RENDER_METHOD_GRID;
            break;

          case SDLK_0: /* RENDER_METHOD_NORMAL */
            isst_master_rm = RENDER_METHOD_NORMAL;
            break;


          case SDLK_UP:
            MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
            MATH_VEC_MUL_SCALAR(vec, vec, isst_master_scale*10.0);
            MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec);
            break;

          case SDLK_DOWN:
            MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
            MATH_VEC_MUL_SCALAR(vec, vec, isst_master_scale*10.0);
            MATH_VEC_SUB(isst_master_camera_position, isst_master_camera_position, vec);
            break;

          case SDLK_LEFT:
            /* strafe left */
            MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
            MATH_VEC_SET(vec2, 0, 0, 1);
            MATH_VEC_CROSS(vec3, vec2, vec);
            MATH_VEC_MUL_SCALAR(vec3, vec3, (isst_master_scale*10.0));
            MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec3);
            break;

          case SDLK_RIGHT:
            /* strafe right */
            MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
            MATH_VEC_SET(vec2, 0, 0, 1);
            MATH_VEC_CROSS(vec3, vec2, vec);
            MATH_VEC_MUL_SCALAR(vec3, vec3, (isst_master_scale*10.0));
            MATH_VEC_SUB(isst_master_camera_position, isst_master_camera_position, vec3);
            break;

          case SDLK_F12: /* Server Shutdown and quit*/
            isst_master_alive = 0;
            break;

          case SDLK_d: /* detach */
            sock->active = 0;
            break;
d719 5
a723 1
          case SDLK_e: /* export frame */
d725 6
a730 6
            pthread_mutex_lock(&isst_observer_gui_mut);
            {
              char filename[32];
              void *image24;
              strcpy(filename, "frame.ppm");
              image24 = malloc(3 * screen_w * screen_h);
d732 1
a732 1
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
d734 1
a734 1
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 1);
d736 4
a739 4
              util_display_text_input("export_frame", filename, 32);
              util_image_save_ppm(filename, image24, screen_w, screen_h);
            }
            pthread_mutex_unlock(&isst_observer_gui_mut);
d741 1
a741 1
            break;
d743 3
a745 3
          case SDLK_f: /* fullscreen toggle */
            /* Reserved for Fullscreen */
            break;
d748 78
a825 1
            isst_master_mouse_grab = isst_master_mouse_grab ^ 1;
d828 102
a929 179
          case SDLK_KP1: /* front, back */
            {
              tfloat dist;

              /* distance to center of rotation */
              MATH_VEC_SUB(vec, isst_master_camera_position, isst_master_cor);
              MATH_VEC_DOT(dist, vec, vec);
              dist = sqrt(dist);

              isst_master_camera_position = isst_master_cor;
              if(isst_master_shift_enabled) {
                isst_master_camera_position.v[0] -= dist;
                isst_master_camera_azimuth = 180;
                isst_master_camera_elevation = 0;
              } else {
                isst_master_camera_position.v[0] += dist;
                isst_master_camera_azimuth = 0;
                isst_master_camera_elevation = 0;
              }
            }
            break;

          case SDLK_KP3: /* right, left */
            {
              tfloat dist;

              /* distance to center of rotation */
              MATH_VEC_SUB(vec, isst_master_camera_position, isst_master_cor);
              MATH_VEC_DOT(dist, vec, vec);
              dist = sqrt(dist);

              isst_master_camera_position = isst_master_cor;
              if(isst_master_shift_enabled) {
                isst_master_camera_position.v[1] -= dist;
                isst_master_camera_azimuth = 270;
                isst_master_camera_elevation = 0;
              } else {
                isst_master_camera_position.v[1] += dist;
                isst_master_camera_azimuth = 90;
                isst_master_camera_elevation = 0;
              }
            }
            break;

          case SDLK_KP7: /* top, bottom */
            {
              tfloat dist;

              /* distance to center of rotation */
              MATH_VEC_SUB(vec, isst_master_camera_position, isst_master_cor);
              MATH_VEC_DOT(dist, vec, vec);
              dist = sqrt(dist);

              isst_master_camera_position = isst_master_cor;
              if(isst_master_shift_enabled) {
                isst_master_camera_position.v[2] -= dist;
                isst_master_camera_azimuth = 0;
                isst_master_camera_elevation = -90 + 0.01;
              } else {
                isst_master_camera_position.v[2] += dist;
                isst_master_camera_azimuth = 0;
                isst_master_camera_elevation = 90 - 0.01;
              }
            }
            break;

          case SDLK_KP0: /* set camera position and direction to shot position and direction */
            isst_master_camera_position = isst_master_shot_position;
            /* project and unitize shot vector onto xy plane */
            vec = isst_master_shot_direction;
            vec.v[2] = 0;
            MATH_VEC_UNITIZE(vec);

            isst_master_camera_azimuth = fmod(180 + (vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*MATH_RAD2DEG : acos(vec.v[0])*MATH_RAD2DEG), 360.0);
            isst_master_camera_elevation = -asin(isst_master_shot_direction.v[2]) * MATH_RAD2DEG;
            break;


          case SDLK_KP_DIVIDE: /* shotline */
            {
              void *mesg;
              common_work_t work;
              TIE_3 direction;
              int dlen;
              char op;

              /* Queue a work unit for a shot needed for the plane render method */
              mesg = malloc(sizeof(common_work_t) + 1 + 2*sizeof(TIE_3));
              dlen = 0;

              work.orig_x = 0;
              work.orig_y = 0;
              work.size_x = 0;
              work.size_y = 0;

              memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
              dlen += sizeof(common_work_t);

              /* function */
              op = ISST_OP_SHOT;
              memcpy(&((char *)mesg)[dlen], &op, 1);
              dlen += 1;

              /* position */
              memcpy(&((char *)mesg)[dlen], &isst_master_camera_position, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              MATH_VEC_SUB(direction, isst_master_camera_focus, isst_master_camera_position);
              MATH_VEC_UNITIZE(direction);

              /* direction */
              memcpy(&((char *)mesg)[dlen], &direction, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              isst_master_shot_position = isst_master_camera_position;
              isst_master_shot_direction = direction;

              tienet_master_push(mesg, dlen);
              free(mesg);
            }
            break;

          case SDLK_KP_MULTIPLY: /* spawl cone */
            {
              void *mesg;
              common_work_t work;
              TIE_3 direction;
              int dlen;
              char op;

              /* Queue a work unit for a shot needed for the plane render method */
              mesg = malloc(sizeof(common_work_t) + 1 + 2*sizeof(TIE_3) + sizeof(tfloat));
              dlen = 0;

              work.orig_x = 0;
              work.orig_y = 0;
              work.size_x = 0;
              work.size_y = 0;

              memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
              dlen += sizeof(common_work_t);

              /* function */
              op = ISST_OP_SPALL;
              memcpy(&((char *)mesg)[dlen], &op, 1);
              dlen += 1;

              /* position */
              memcpy(&((char *)mesg)[dlen], &isst_master_camera_position, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              MATH_VEC_SUB(direction, isst_master_camera_focus, isst_master_camera_position);
              MATH_VEC_UNITIZE(direction);

              /* direction */
              memcpy(&((char *)mesg)[dlen], &direction, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              /* angle */
              memcpy(&((char *)mesg)[dlen], &isst_master_spall_angle, sizeof(tfloat));
              dlen += sizeof(tfloat);

              isst_master_shot_position = isst_master_camera_position;
              isst_master_shot_direction = direction;

              tienet_master_push(mesg, dlen);
              free(mesg);
            }
            break;


          case SDLK_BACKQUOTE: /* console */
            /* reserved for console in observer */
            break;

          default:
            break;
        }
        break;
d932 9
a940 9
        switch(event_queue[i].keysym) {
          case SDLK_LSHIFT:
          case SDLK_RSHIFT:
            isst_master_shift_enabled = 0;
            break;

          default:
            break;
        }
d943 7
a949 7
        update = 1;
        if(event_queue[i].button == SDL_BUTTON_WHEELUP)
          isst_master_scale *= 1.25;

        if(event_queue[i].button == SDL_BUTTON_WHEELDOWN)
          isst_master_scale *= 0.8;
        break;
d952 1
a952 1
        if(event_queue[i].motion_state && isst_master_mouse_grab) {
d958 6
a963 6
          update = 1;
          if(event_queue[i].button & 1<<(SDL_BUTTON_LEFT-1)) {
            /* backward and forward */
            MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
            MATH_VEC_MUL_SCALAR(vec, vec, (isst_master_scale*dy));
            MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec);
d965 1
a965 1
            /* strafe */
d967 7
a973 7
            MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
            vec2.v[0] = 0;
            vec2.v[1] = 0;
            vec2.v[2] = 1;
            MATH_VEC_CROSS(vec3, vec2, vec);
            MATH_VEC_MUL_SCALAR(vec3, vec3, (isst_master_scale*dx));
            MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec3);
d975 9
a983 9
          } else if(event_queue[i].button & 1<<(SDL_BUTTON_RIGHT-1)) {
            /* if the shift key is held down then rotate about Center of Rotation */
            if(isst_master_shift_enabled) {
              TIE_3 vec;
              tfloat mag, angle;

              vec.v[0] = isst_master_cor.v[0] - isst_master_camera_position.v[0];
              vec.v[1] = isst_master_cor.v[1] - isst_master_camera_position.v[1];
              vec.v[2] = 0;
d986 2
a987 2
              MATH_VEC_UNITIZE(vec);
              MATH_VEC_MAGnitude(mag, vec);
d989 4
a992 4
              angle = vec.v[0]*vec.v[0] + vec.v[1]*vec.v[1];
              mag = sqrt(angle);
              vec.v[0] /= mag;
              vec.v[1] /= mag;
d995 1
a995 1
              vec.v[0] = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*MATH_RAD2DEG : acos(vec.v[0])*MATH_RAD2DEG;
d997 2
a998 2
              vec.v[0] -= 0.035*dx;
              vec.v[0] *= MATH_DEG2RAD;
d1000 29
a1028 29
              isst_master_camera_position.v[0] = -mag*cos(vec.v[0]) + isst_master_cor.v[0];
              isst_master_camera_position.v[1] = -mag*sin(vec.v[0]) + isst_master_cor.v[1];
              isst_master_camera_azimuth -= 0.035*dx;
            } else {
              isst_master_camera_azimuth += 0.035*dx;
              isst_master_camera_elevation -= 0.035*dy;
            }
          } else if(event_queue[i].button & 1<<(SDL_BUTTON_MIDDLE-1)) {
            isst_master_camera_position.v[2] += isst_master_scale*dy;

            /* strafe */
            MATH_VEC_SUB(vec, isst_master_camera_focus, isst_master_camera_position);
            MATH_VEC_SET(vec2, 0, 0, 1);
            MATH_VEC_CROSS(vec3, vec2, vec);
            MATH_VEC_MUL_SCALAR(vec3, vec3, (isst_master_scale*dx));
            MATH_VEC_ADD(isst_master_camera_position, isst_master_camera_position, vec3);
          }

          /* Keep azimuth position */
          if(isst_master_camera_azimuth < 0)
            isst_master_camera_azimuth += 360;
          if(isst_master_camera_azimuth > 360)
            isst_master_camera_azimuth -= 360;

          /* Keep elevation between -90 and +90 */
          if(isst_master_camera_elevation < -90)
            isst_master_camera_elevation = -90;
          if(isst_master_camera_elevation > 90)
            isst_master_camera_elevation = 90;
d1030 2
a1031 2
        }
        break;
d1034 1
a1034 1
        break;
@


1.20
log
@standard header and footer cleanup
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
@


1.19
log
@uppercase all #define symbols
@
text
@d1 26
d1047 10
@


1.18
log
@reverted
@
text
@d93 2
a94 2
  math_vec_set(isst_master_in_hit, 0, 0, 0);
  math_vec_set(isst_master_out_hit, 0, 0, 0);
d96 2
a97 2
  math_vec_set(isst_master_camera_position, 10, 10, 10);
  math_vec_set(isst_master_shot_position, 0, 0, 0);
d100 4
a103 4
  celev = cos(35 * math_deg2rad);
  isst_master_camera_focus.v[0] -= cos(45 * math_deg2rad) * celev;
  isst_master_camera_focus.v[1] -= sin(45 * math_deg2rad) * celev;
  isst_master_camera_focus.v[2] -= sin(35 * math_deg2rad);
d256 2
a257 2
    math_vec_add(isst_master_cor, isst_master_in_hit, isst_master_out_hit);
    math_vec_mul_scalar(isst_master_cor, isst_master_cor, 0.5);
d660 3
a662 3
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_mul_scalar(vec, vec, isst_master_scale*10.0);
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec);
d666 3
a668 3
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_mul_scalar(vec, vec, isst_master_scale*10.0);
            math_vec_sub(isst_master_camera_position, isst_master_camera_position, vec);
d673 5
a677 5
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (isst_master_scale*10.0));
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec3);
d682 5
a686 5
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (isst_master_scale*10.0));
            math_vec_sub(isst_master_camera_position, isst_master_camera_position, vec3);
d730 2
a731 2
              math_vec_sub(vec, isst_master_camera_position, isst_master_cor);
              math_vec_dot(dist, vec, vec);
d752 2
a753 2
              math_vec_sub(vec, isst_master_camera_position, isst_master_cor);
              math_vec_dot(dist, vec, vec);
d774 2
a775 2
              math_vec_sub(vec, isst_master_camera_position, isst_master_cor);
              math_vec_dot(dist, vec, vec);
d796 1
a796 1
            math_vec_unitize(vec);
d798 2
a799 2
            isst_master_camera_azimuth = fmod(180 + (vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg), 360.0);
            isst_master_camera_elevation = -asin(isst_master_shot_direction.v[2]) * math_rad2deg;
d832 2
a833 2
              math_vec_sub(direction, isst_master_camera_focus, isst_master_camera_position);
              math_vec_unitize(direction);
d876 2
a877 2
              math_vec_sub(direction, isst_master_camera_focus, isst_master_camera_position);
              math_vec_unitize(direction);
d935 3
a937 3
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_mul_scalar(vec, vec, (isst_master_scale*dy));
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec);
d941 1
a941 1
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
d945 3
a947 3
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (isst_master_scale*dx));
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec3);
d960 2
a961 2
              math_vec_unitize(vec);
              math_vec_magnitude(mag, vec);
d969 1
a969 1
              vec.v[0] = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg;
d972 1
a972 1
              vec.v[0] *= math_deg2rad;
d985 5
a989 5
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (isst_master_scale*dx));
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec3);
d1014 4
a1017 4
      celev = cos(isst_master_camera_elevation * math_deg2rad);
      isst_master_camera_focus.v[0] -= cos(isst_master_camera_azimuth * math_deg2rad) * celev;
      isst_master_camera_focus.v[1] -= sin(isst_master_camera_azimuth * math_deg2rad) * celev;
      isst_master_camera_focus.v[2] -= sin(isst_master_camera_elevation * math_deg2rad);
@


1.17
log
@librender is now libvis, render method terminology becomes visualization method or vis
method for short.
@
text
@d108 1
a108 1
  isst_master_rm = VM_PHONG;
d585 1
a585 1
    case VM_PLANE:
d593 1
a593 1
    case VM_SPALL:
d630 2
a631 2
          case SDLK_1: /* VM_PHONG */
            isst_master_rm = VM_PHONG;
d634 2
a635 2
          case SDLK_2: /* VM_PLANE */
            isst_master_rm = VM_PLANE;
d638 2
a639 2
          case SDLK_3: /* VM_SPALL */
            isst_master_rm = VM_SPALL;
d642 2
a643 2
          case SDLK_4: /* VM_COMPONENT */
            isst_master_rm = VM_COMPONENT;
d646 2
a647 2
          case SDLK_8: /* VM_DEPTH */
            isst_master_rm = VM_DEPTH;
d650 2
a651 2
          case SDLK_9: /* VM_GRID */
            isst_master_rm = VM_GRID;
d654 2
a655 2
          case SDLK_0: /* VM_NORMAL */
            isst_master_rm = VM_NORMAL;
@


1.16
log
@some friendly messages.
@
text
@d108 1
a108 1
  isst_master_rm = RENDER_METHOD_PHONG;
d585 1
a585 1
    case RENDER_METHOD_PLANE:
d593 1
a593 1
    case RENDER_METHOD_SPALL:
d630 2
a631 2
          case SDLK_1: /* RENDER_METHOD_PHONG */
            isst_master_rm = RENDER_METHOD_PHONG;
d634 2
a635 2
          case SDLK_2: /* RENDER_METHOD_PLANE */
            isst_master_rm = RENDER_METHOD_PLANE;
d638 2
a639 2
          case SDLK_3: /* RENDER_METHOD_SPALL */
            isst_master_rm = RENDER_METHOD_SPALL;
d642 2
a643 2
          case SDLK_4: /* RENDER_METHOD_COMPONENT */
            isst_master_rm = RENDER_METHOD_COMPONENT;
d646 2
a647 2
          case SDLK_8: /* RENDER_METHOD_DEPTH */
            isst_master_rm = RENDER_METHOD_DEPTH;
d650 2
a651 2
          case SDLK_9: /* RENDER_METHOD_GRID */
            isst_master_rm = RENDER_METHOD_GRID;
d654 2
a655 2
          case SDLK_0: /* RENDER_METHOD_NORMAL */
            isst_master_rm = RENDER_METHOD_NORMAL;
@


1.15
log
@isst_event_t integration.
@
text
@d190 1
a190 1
#if 1
@


1.14
log
@screen 2x magnification for low res contexts (F1 F2).
@
text
@d47 1
a47 1
void isst_master_process_events(SDL_Event *event_queue, int event_num, isst_master_socket_t *sock);
d448 2
a449 2
                  SDL_Event event_queue[64];
                  short event_num;
d452 1
a452 1
                  tienet_recv(sock->num, &event_num, sizeof(short), 0);
d454 1
a454 1
                    tienet_recv(sock->num, event_queue, event_num * sizeof(SDL_Event), 0);
d612 1
a612 1
void isst_master_process_events(SDL_Event *event_queue, int event_num, isst_master_socket_t *sock) {
d624 1
a624 1
        switch(event_queue[i].key.keysym.sym) {
d906 1
a906 1
        switch(event_queue[i].key.keysym.sym) {
d918 1
a918 1
        if(event_queue[i].button.button == SDL_BUTTON_WHEELUP)
d921 1
a921 1
        if(event_queue[i].button.button == SDL_BUTTON_WHEELDOWN)
d926 1
a926 1
        if(event_queue[i].motion.state && isst_master_mouse_grab) {
d929 2
a930 2
	  dx = -event_queue[i].motion.xrel;
	  dy = -event_queue[i].motion.yrel;
d933 1
a933 1
          if(event_queue[i].button.button & 1<<(SDL_BUTTON_LEFT-1)) {
d949 1
a949 1
          } else if(event_queue[i].button.button & 1<<(SDL_BUTTON_RIGHT-1)) {
d981 1
a981 1
          } else if(event_queue[i].button.button & 1<<(SDL_BUTTON_MIDDLE-1)) {
@


1.13
log
@camera uses threads more efficiently.
isst master locks the frames down so observer doesn't get mid-render frames.
@
text
@d65 1
a65 1
tienet_sem_t isst_master_double_buffer_sem;
d68 2
a69 3
void *rgb_frame[2];
int frame_ind[2];
short frame_cur_ind;
d110 1
a110 3
  frame_ind[0] = 0;
  frame_ind[1] = 0;
  frame_cur_ind = 0;
d112 2
a113 5
  rgb_frame[0] = malloc(3 * db.env.img_w * db.env.img_h);
  rgb_frame[1] = malloc(3 * db.env.img_w * db.env.img_h);

  memset(rgb_frame[0], 0, 3 * db.env.img_w * db.env.img_h);
  memset(rgb_frame[1], 0, 3 * db.env.img_w * db.env.img_h);
d141 1
a141 1
  *
d178 1
a178 1
  tienet_sem_init(&isst_master_double_buffer_sem, 2);
d182 1
a182 1
    tienet_sem_wait(&isst_master_double_buffer_sem);
a189 2
    frame_cur_ind = 1 - frame_cur_ind;

d216 1
a216 2
  free(rgb_frame[0]);
  free(rgb_frame[1]);
d292 1
a292 3
    /* Frame index */
    memcpy(&frame, &((char *)res_buf)[sizeof(common_work_t) + 3 * work.size_x * work.size_y], sizeof(short));
    frame_ind[frame]++;
d297 1
a297 1
      memcpy(&((char *)rgb_frame[frame])[3 * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 3*work.size_y);
d303 2
a304 2
    if(frame_ind[frame] == isst_master_tile_num) {
      frame_ind[frame] = 0;
d308 1
a308 1
      memcpy(isst_master_observer_frame, rgb_frame[frame], 3 * db.env.img_w * db.env.img_h);
d312 1
a312 1
      tienet_sem_post(&isst_master_double_buffer_sem);
a571 4
  /* Frame Index */
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &frame_cur_ind, sizeof(short));
  isst_master_slave_data_len += sizeof(short);

@


1.12
log
@32/64 observer comms should work
@
text
@d63 5
a70 1
short frame_ind_done;
a76 2
isst_master_socket_t *isst_master_socklist;
common_db_t db;
a113 4
  frame_ind_done = 0;

  rgb_frame[0] = NULL;
  rgb_frame[1] = NULL;
d120 2
d143 7
d175 11
d187 3
a315 1
      frame_ind_done = frame;
d317 9
d327 1
a327 1
        if(sock->next) {
a329 1
        }
d476 3
a478 1
                  compress(&((char *)comp_buf)[sizeof(unsigned int)], &dest_len, rgb_frame[frame_ind_done], 3 * db.env.img_w * db.env.img_h);
d486 3
a488 1
                tienet_send(sock->num, rgb_frame[frame_ind_done], db.env.img_w * db.env.img_h * 3, 0);
@


1.11
log
@32/64 comms fixed, time to fix observer-fu
@
text
@d444 1
a444 1
                  int comp_size;
d448 1
a448 1
                  compress(&((char *)comp_buf)[sizeof(int)], &dest_len, rgb_frame[frame_ind_done], 3 * db.env.img_w * db.env.img_h);
d450 1
a450 1
                  memcpy(comp_buf, &comp_size, sizeof(int));
d452 1
a452 1
                  tienet_send(sock->num, comp_buf, comp_size + sizeof(int), 0);
@


1.10
log
@stuff to fix 32/64 communication
@
text
@a224 1
printf("%d %d %d %d %d :: %d\n", work.orig_x, work.orig_y, work.size_x, work.size_y, work.format, res_len);
a281 1
printf("frame: %d\n", frame);
@


1.9
log
@fixed a stack pop bug in the kd-tree cache loader.  engine is 1.1% faster.
@
text
@d225 1
d283 1
a283 1

@


1.9.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d47 1
a47 1
void isst_master_process_events(isst_event_t *event_queue, uint8_t event_num, isst_master_socket_t *sock);
d63 4
a66 7
common_db_t db;
isst_master_socket_t *isst_master_socklist;
tienet_sem_t isst_master_frame_wait_sem;
void *isst_master_observer_frame;
pthread_mutex_t isst_master_observer_frame_mut;
void *rgb_frame;
int frame_ind;
d73 2
d109 4
a112 1
  frame_ind = 0;
d114 2
a115 2
  rgb_frame = malloc(3 * db.env.img_w * db.env.img_h);
  memset(rgb_frame, 0, 3 * db.env.img_w * db.env.img_h);
d117 5
a121 1
  isst_master_observer_frame = malloc(3 * db.env.img_w * db.env.img_h);
a142 7
  /*
  * This mutex exists to prevent the observer from reading a frame while
  * the result function is writing to it, which would otherwise result in
  * the appearance of single buffering behavior for moderately high frame rates.
  */
  pthread_mutex_init(&isst_master_observer_frame_mut, 0);

a167 11
  /*
  * Double buffer semaphore, never let more than 1 frame into the future
  * to be computed at any given time.  Without this, for 3 given frames
  * there is a possibility that while frame_0 and frame_1 are being computed
  * by the compute nodes, that frame_2 might be worked on by a compute node.
  * because frame indices are 0 or 1, hence double buffered, frame_0 and frame_2
  * have the same frame id and can therefore have resulting tiles over-write
  * one another resulting in a jittery image.
  */
  tienet_sem_init(&isst_master_frame_wait_sem, 1);

a168 3
    /* Double buffer semaphore, do not get too far ahead */
    tienet_sem_wait(&isst_master_frame_wait_sem);

d175 3
a177 1
#if 0
d203 2
a204 1
  free(rgb_frame);
d280 4
a283 1
    frame_ind++;
d288 1
a288 1
      memcpy(&((char *)rgb_frame)[3 * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 3*work.size_y);
d294 3
a296 7
    if(frame_ind == isst_master_tile_num) {
      frame_ind = 0;

      /* Copy this frame to the observer frame buffer */
      pthread_mutex_lock(&isst_master_observer_frame_mut);
      memcpy(isst_master_observer_frame, rgb_frame, 3 * db.env.img_w * db.env.img_h);
      pthread_mutex_unlock(&isst_master_observer_frame_mut);
a297 4
      /* Allow the next frame to be computed */
      tienet_sem_post(&isst_master_frame_wait_sem);

      /* Alert the observers that a new frame is available for viewing */
d299 1
a299 1
        if(sock->next)
d302 1
d432 2
a433 2
                  isst_event_t event_queue[64];
                  uint8_t event_num;
d436 1
a436 1
                  tienet_recv(sock->num, &event_num, sizeof(uint8_t), 0);
d438 1
a438 1
                    tienet_recv(sock->num, event_queue, event_num * sizeof(isst_event_t), 0);
d445 1
a445 1
                  unsigned int comp_size;
d449 1
a449 3
                  pthread_mutex_lock(&isst_master_observer_frame_mut);
                  compress(&((char *)comp_buf)[sizeof(unsigned int)], &dest_len, isst_master_observer_frame, 3 * db.env.img_w * db.env.img_h);
                  pthread_mutex_unlock(&isst_master_observer_frame_mut);
d451 1
a451 1
                  memcpy(comp_buf, &comp_size, sizeof(unsigned int));
d453 1
a453 1
                  tienet_send(sock->num, comp_buf, comp_size + sizeof(unsigned int), 0);
d457 1
a457 3
                pthread_mutex_lock(&isst_master_observer_frame_mut);
                tienet_send(sock->num, isst_master_observer_frame, db.env.img_w * db.env.img_h * 3, 0);
                pthread_mutex_unlock(&isst_master_observer_frame_mut);
d552 4
d596 1
a596 1
void isst_master_process_events(isst_event_t *event_queue, uint8_t event_num, isst_master_socket_t *sock) {
d608 1
a608 1
        switch(event_queue[i].keysym) {
d890 1
a890 1
        switch(event_queue[i].keysym) {
d902 1
a902 1
        if(event_queue[i].button == SDL_BUTTON_WHEELUP)
d905 1
a905 1
        if(event_queue[i].button == SDL_BUTTON_WHEELDOWN)
d910 1
a910 1
        if(event_queue[i].motion_state && isst_master_mouse_grab) {
d913 2
a914 2
	  dx = -event_queue[i].motion_xrel;
	  dy = -event_queue[i].motion_yrel;
d917 1
a917 1
          if(event_queue[i].button & 1<<(SDL_BUTTON_LEFT-1)) {
d933 1
a933 1
          } else if(event_queue[i].button & 1<<(SDL_BUTTON_RIGHT-1)) {
d965 1
a965 1
          } else if(event_queue[i].button & 1<<(SDL_BUTTON_MIDDLE-1)) {
@


1.8
log
@investigating tie->free()
@
text
@d796 1
a796 1
              mesg = malloc(sizeof(common_work_t) + 2 * sizeof(TIE_3));
d840 1
a840 1
              mesg = malloc(sizeof(common_work_t) + 2 * sizeof(TIE_3) + sizeof(tfloat));
@


1.7
log
@experimental kd-tree code finds empty space more agressively.
master is printing fps for now.
@
text
@d677 4
a708 4
          case SDLK_q: /* quit */
            sock->active = 0;
            break;

@


1.6
log
@added depth to parser so you can render bsp depth from rise.
@
text
@d177 1
a177 1
#if 0
@


1.6.4.1
log
@file master.c was added on branch rel-7-4-branch on 2005-08-16 21:03:45 +0000
@
text
@d1 1004
@


1.6.4.2
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@a0 1004
#include "master.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "SDL.h"		/* SDL */
#include "display.h"		/* Display utilities */
#include "canim.h"		/* Animation Stuff */
#include "dispatcher.h"		/* Dispatcher that creates work units */
#include "cdb.h"		/* Common structs and stuff */
#include "compnet.h"		/* Component Networking, Sends Component Names via Network */
#include "isst.h"		/* ISST Defines */
#include "image.h"		/* Image import/export utilities */
#include "pack.h"		/* Data packing for transport to nodes */
#include "isst_struct.h"	/* isst common structs */
#include "tienet.h"		/* Networking stuff */
#include "umath.h"		/* Extended math utilities */
#include "isst_python.h"	/* Python code Interpreter */
/* Networking Includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#if ISST_USE_COMPRESSION
  #include <zlib.h>
#endif


/* socket structure */
typedef struct isst_master_socket_s {
  int num;
  int controller;
  int active;
  tienet_sem_t frame_sem;
  struct isst_master_socket_s *prev;
  struct isst_master_socket_s *next;
} isst_master_socket_t;


void isst_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host);
void* isst_master_networking(void *ptr);
void isst_master_result(void *res_buf, int res_len);
void isst_master_update(void);
void isst_master_process_events(SDL_Event *event_queue, int event_num, isst_master_socket_t *sock);


/***** GLOBALS *****/
int isst_master_tile_num;
TIE_3 isst_master_camera_position;
TIE_3 isst_master_camera_focus;
TIE_3 isst_master_cor; /* center of rotation */
TIE_3 isst_master_shot_position;
TIE_3 isst_master_shot_direction;
TIE_3 isst_master_in_hit;
TIE_3 isst_master_out_hit;
tfloat isst_master_spall_angle;
tfloat isst_master_camera_azimuth;
tfloat isst_master_camera_elevation;

void *rgb_frame[2];
int frame_ind[2];
short frame_cur_ind;
short frame_ind_done;
char isst_master_slave_data[64];
int isst_master_slave_data_len;
pthread_t isst_master_networking_thread;
tfloat isst_master_scale;
int isst_master_active_connections;
int isst_master_alive;
isst_master_socket_t *isst_master_socklist;
common_db_t db;
unsigned char isst_master_rm;
pthread_mutex_t isst_master_update_mut;
int isst_master_mouse_grab;
int isst_master_shift_enabled;
/*******************/


static void isst_master_setup() {
  tfloat celev;

  isst_master_active_connections = 0;

  isst_master_alive = 1;
  isst_master_scale = 0.01;
  isst_master_mouse_grab = 0;
  isst_master_shift_enabled = 0;
  isst_master_spall_angle = 10;
  math_vec_set(isst_master_in_hit, 0, 0, 0);
  math_vec_set(isst_master_out_hit, 0, 0, 0);

  math_vec_set(isst_master_camera_position, 10, 10, 10);
  math_vec_set(isst_master_shot_position, 0, 0, 0);
  isst_master_camera_focus = isst_master_camera_position;

  celev = cos(35 * math_deg2rad);
  isst_master_camera_focus.v[0] -= cos(45 * math_deg2rad) * celev;
  isst_master_camera_focus.v[1] -= sin(45 * math_deg2rad) * celev;
  isst_master_camera_focus.v[2] -= sin(35 * math_deg2rad);

  isst_master_camera_azimuth = 45;
  isst_master_camera_elevation = 35;

  isst_master_rm = RENDER_METHOD_PHONG;

  frame_ind[0] = 0;
  frame_ind[1] = 0;
  frame_cur_ind = 0;
  frame_ind_done = 0;

  rgb_frame[0] = NULL;
  rgb_frame[1] = NULL;

  rgb_frame[0] = malloc(3 * db.env.img_w * db.env.img_h);
  rgb_frame[1] = malloc(3 * db.env.img_w * db.env.img_h);

  memset(rgb_frame[0], 0, 3 * db.env.img_w * db.env.img_h);
  memset(rgb_frame[1], 0, 3 * db.env.img_w * db.env.img_h);
}


void isst_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host) {
  int frame_num, app_size;
  void *app_data;
  struct timeval start, cur;


  /* Parse Env Data */
  common_db_load(&db, proj);

  /* Setup defaults */
  isst_master_setup();

  /* Initialize Python Processor */
  isst_python_init();

  /* Mutex for everytime the master builds update data to send to nodes */
  pthread_mutex_init(&isst_master_update_mut, 0);

  /* Initialize tienet master */
  isst_master_tile_num = (db.env.img_w * db.env.img_h) / (db.env.tile_w * db.env.tile_h);
  tienet_master_init(port, isst_master_result, list, exec, 5, ISST_VER_KEY);

  /* Launch a thread to handle networking */
  pthread_create(&isst_master_networking_thread, NULL, isst_master_networking,&obs_port);

  /* Connect to the component Server */
  isst_compnet_connect(comp_host, ISST_COMPNET_PORT);

  /* Parse and pack the application data */
  printf("loading scene... ");
  fflush(stdout);
  app_size = common_pack(&db, &app_data, proj);
  printf("done.\n");

  tienet_master_prep(app_data, app_size);

  /* Initialize the work dispatcher */
  isst_dispatcher_init();

  /* Data for computing fps */
  frame_num = 0;
  gettimeofday(&start, NULL);

  while(isst_master_alive) {
    /* Update Camera Position */
    isst_master_update();

    /* Fill the work buffer */
    isst_dispatcher_generate(&db, isst_master_slave_data, isst_master_slave_data_len);

    frame_cur_ind = 1 - frame_cur_ind;

#if 0
    frame_num++;
    if(!(frame_num % 7)) {
      gettimeofday(&cur, NULL);
      printf("FPS: %.3f  SLAVES: %d    \r",
            (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
            tienet_master_socket_num);
      start = cur;
      frame_num = 0;
      fflush(stdout);
    }
#endif
  }

  /* Wait for the tienet master work buffer to empty and for all the results to come back */
  tienet_master_wait();

  /* Shutdown */
  tienet_master_shutdown();

  /* Free network data */
  tienet_master_free();

  /* Free the dispatcher data */
  isst_dispatcher_free();

  free(rgb_frame[0]);
  free(rgb_frame[1]);

  /* End the networking thread */
  pthread_join(isst_master_networking_thread, NULL);

  isst_python_free();
}


void isst_master_result(void *res_buf, int res_len) {
  isst_master_socket_t *sock;
  common_work_t work;
  unsigned char *rgb_data;
  int i, ind, num;
  short frame;
  char name[256];
  unsigned char c;


  /* Work unit data */
  memcpy(&work, res_buf, sizeof(common_work_t));

  if(work.size_x == 0) {  /* ugly hack until I get a better identifier in place */
    char *mesg;
    short slop;

    /* Read and advance to data */
    ind = sizeof(common_work_t);

    /* first hit */
    memcpy(&isst_master_in_hit, &((unsigned char *)res_buf)[ind], sizeof(TIE_3));
    ind += sizeof(TIE_3);

    /* last hit */
    memcpy(&isst_master_out_hit, &((unsigned char *)res_buf)[ind], sizeof(TIE_3));
    ind += sizeof(TIE_3);

printf("in_hit: [%f, %f, %f], out_hit: [%f, %f, %f]\n", isst_master_in_hit.v[0], isst_master_in_hit.v[1], isst_master_in_hit.v[2], isst_master_out_hit.v[0], isst_master_out_hit.v[1], isst_master_out_hit.v[2]);

    /* Set the Center of of Rotation */
    math_vec_add(isst_master_cor, isst_master_in_hit, isst_master_out_hit);
    math_vec_mul_scalar(isst_master_cor, isst_master_cor, 0.5);

    /* number of meshes */
    memcpy(&num, &((unsigned char *)res_buf)[ind], sizeof(int));
    ind += sizeof(int);

    /* reset the component server to collapse all fields */
    isst_compnet_reset();

    for(i = 0; i < num; i++) {
      memcpy(&c, &((unsigned char *)res_buf)[ind], 1);
      ind += 1;
      memcpy(name, &((unsigned char *)res_buf)[ind], c);
      ind += c;
printf("component[%d]: %s\n", i, name);
      isst_compnet_update(name, 1);
    }

    /* Send a message to update hitlist */
    mesg = malloc(sizeof(short) + res_len - sizeof(common_work_t) - 6*sizeof(tfloat));

    ind = 0;
    slop = ISST_OP_SHOT;
    memcpy(&((char *)mesg)[ind], &slop, sizeof(short));
    ind += sizeof(short);

    memcpy(&((char *)mesg)[ind], &((unsigned char *)res_buf)[sizeof(common_work_t) + 6*sizeof(tfloat)], res_len - sizeof(common_work_t) - 6*sizeof(tfloat));
    ind += res_len - sizeof(common_work_t) - 6*sizeof(tfloat);

    tienet_master_broadcast(mesg, ind);
    free(mesg);
  } else {
    /* Pointer to RGB Data */
    rgb_data = &((unsigned char *)res_buf)[sizeof(common_work_t)];

    /* Frame index */
    memcpy(&frame, &((char *)res_buf)[sizeof(common_work_t) + 3 * work.size_x * work.size_y], sizeof(short));

    frame_ind[frame]++;

    /* Copy the tile into the image */
    ind = 0;
    for(i = work.orig_y; i < work.orig_y + work.size_y; i++) {
      memcpy(&((char *)rgb_frame[frame])[3 * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 3*work.size_y);
      ind += 3*work.size_y;
    }


    /* Image is complete, draw the frame. */
    if(frame_ind[frame] == isst_master_tile_num) {
      frame_ind[frame] = 0;
      frame_ind_done = frame;

      for(sock = isst_master_socklist; sock; sock = sock->next) {
        if(sock->next) {
          if(!sock->frame_sem.val)
            tienet_sem_post(&(sock->frame_sem));
        }
      }
    }
  }
}


void* isst_master_networking(void *ptr) {
  isst_master_socket_t *sock, *tmp;
  struct sockaddr_in master, observer;
  fd_set readfds;
  int port, master_socket, highest_fd, new_socket, error;
  unsigned int addrlen;
  unsigned char op;
  short endian;
#if ISST_USE_COMPRESSION
  void *comp_buf;
#endif


  port = *(int *)ptr;


#if ISST_USE_COMPRESSION
  comp_buf = malloc(3 * db.env.img_w * db.env.img_h + 1024);
#endif

  /* create a socket */
  if((master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    fprintf(stderr, "unable to create socket, exiting.\n");
    exit(1);
  }

  /* initialize socket list */
  isst_master_socklist = (isst_master_socket_t *)malloc(sizeof(isst_master_socket_t));
  isst_master_socklist->next = NULL;
  isst_master_socklist->prev = NULL;
  isst_master_socklist->num = master_socket;

  highest_fd = master_socket;


  /* server address */
  master.sin_family = AF_INET;
  master.sin_addr.s_addr = htonl(INADDR_ANY);
  master.sin_port = htons(port);

  /* bind socket */
  if(bind(master_socket, (struct sockaddr *)&master, sizeof(master)) < 0) {
    fprintf(stderr, "observer socket already bound, exiting.\n");
    exit(1);
  }

  FD_ZERO(&readfds);
  FD_SET(master_socket, &readfds);

  /* listen for connections */
  listen(isst_master_socklist->num, 3);

  addrlen = sizeof(observer);
  isst_master_active_connections = 0;

  while(isst_master_alive || isst_master_active_connections) {
    /* wait for some network activity */
    select(highest_fd+1, &readfds, NULL, NULL, NULL);
    /* cycle through each socket and address the activity */
    for(sock = isst_master_socklist; sock; sock = sock->next) {
      /* if no longer alive then mark each of the active connections as no longer active */
      if(!isst_master_alive)
        sock->active = 0;

      /* check if activity was on this socket */
      if(FD_ISSET(sock->num, &readfds)) {
        if(sock->num == master_socket) {
          /* new connection */
          new_socket = accept(master_socket, (struct sockaddr *)&observer, &addrlen);
          if(new_socket >= 0) {
            tmp = isst_master_socklist;
            isst_master_socklist = (isst_master_socket_t *)malloc(sizeof(isst_master_socket_t));
            isst_master_socklist->num = new_socket;
            isst_master_socklist->controller = isst_master_active_connections ? 0 : 1;
            isst_master_socklist->active = 1;
            isst_master_socklist->next = tmp;
            isst_master_socklist->prev = NULL;
            tienet_sem_init(&(isst_master_socklist->frame_sem), 0);
            tmp->prev = isst_master_socklist;
            if(new_socket > highest_fd)
              highest_fd = new_socket;
            isst_master_active_connections++;
          }
        } else {
          op = 255;
          /* observer communication */
          error = tienet_recv(sock->num, &op, 1, 0);

          /* remove socket from pool if there's an error, i.e slave disconnected */
          if(error || op == ISST_NET_OP_QUIT || !sock->active) {
            op = ISST_NET_OP_QUIT;
            tienet_send(sock->num, &op, 1, 0);

            tmp = sock;
            if(sock->prev)
              sock->prev->next = sock->next;
            /* master is always last, no need to check for sock->next next */
            sock->next->prev = sock->prev;
            if(sock == isst_master_socklist)
              isst_master_socklist = isst_master_socklist->next;
            close(sock->num);
            sock = sock->next;
            free(tmp);
            isst_master_active_connections--;

          } else {
            switch(op) {
              case ISST_NET_OP_INIT:
                /* Send screen width and height */
                endian = 1;
                tienet_send(sock->num, &endian, sizeof(short), 0);
                tienet_send(sock->num, &db.env.img_w, sizeof(int), 0);
                tienet_send(sock->num, &db.env.img_h, sizeof(int), 0);
                break;

              case ISST_NET_OP_FRAME:
                tienet_sem_wait(&(sock->frame_sem));

                /* Let observer know everything is okay, continue as usual. */
                op = ISST_NET_OP_NOP;
                tienet_send(sock->num, &op, 1, 0);

                {
                  SDL_Event event_queue[64];
                  short event_num;

                  /* Get the event Queue and process it */
                  tienet_recv(sock->num, &event_num, sizeof(short), 0);
                  if(event_num)
                    tienet_recv(sock->num, event_queue, event_num * sizeof(SDL_Event), 0);
                  isst_master_process_events(event_queue, event_num, sock);
                }

#if ISST_USE_COMPRESSION
                {
                  unsigned long dest_len;
                  int comp_size;
                  dest_len = 3 * db.env.img_w * db.env.img_h + 1024;

                  /* frame data */
                  compress(&((char *)comp_buf)[sizeof(int)], &dest_len, rgb_frame[frame_ind_done], 3 * db.env.img_w * db.env.img_h);
                  comp_size = dest_len;
                  memcpy(comp_buf, &comp_size, sizeof(int));
                  /* int for frame size in bytes followed by actual rgb frame data */
                  tienet_send(sock->num, comp_buf, comp_size + sizeof(int), 0);
                }
#else
                /* frame data */
                tienet_send(sock->num, rgb_frame[frame_ind_done], db.env.img_w * db.env.img_h * 3, 0);
#endif

                /* Send overlay data */
                {
                  isst_overlay_data_t overlay;

                  overlay.camera_position = isst_master_camera_position;
                  overlay.camera_azimuth = isst_master_camera_azimuth;
                  overlay.camera_elevation = isst_master_camera_elevation;
                  overlay.compute_nodes = tienet_master_active_slaves;
                  overlay.in_hit = isst_master_in_hit;
                  overlay.out_hit = isst_master_out_hit;
                  overlay.scale = isst_master_scale;
                  sprintf(overlay.resolution, "%dx%d", db.env.img_w, db.env.img_h);
                  overlay.controller = sock->controller;

                  tienet_send(sock->num, &overlay, sizeof(isst_overlay_data_t), 0);
                }

                /* Lock things down so that isst_master_update data doesn't get tainted */
                pthread_mutex_lock(&isst_master_update_mut);

                pthread_mutex_unlock(&isst_master_update_mut);
                break;

              case ISST_NET_OP_MESG:
                {
                  char *string;
                  int len;

                  string = (char *)malloc(1024);
                  tienet_recv(sock->num, &len, 1, 0);
                  tienet_recv(sock->num, string, len, 0);

                  isst_python_code(string);
                  len = strlen(string) + 1;

                  tienet_send(sock->num, &len, 1, 0);
                  tienet_send(sock->num, string, len, 0);

                  free(string);
                }
                break;


              case ISST_NET_OP_QUIT:
                isst_master_active_connections = 0;
                break;


              default:
                break;
            }
          }
        }
      }
    }

    /* Rebuild select list for next select call */
    highest_fd = 0;
    for(sock = isst_master_socklist; sock; sock = sock->next) {
      if(sock->num > highest_fd)
        highest_fd = sock->num;
      FD_SET(sock->num, &readfds);
    }
  }

#if ISST_USE_COMPRESSION
  free(comp_buf);
#endif


  /* free isst_master_socklist */
  for(sock = isst_master_socklist->next; sock; sock = sock->next)
    free(sock->prev);

  return 0;
}


/* additional baggage that goes with each work unit */
void isst_master_update() {
  char op;

  isst_master_slave_data_len = 0;

  /* Lock things down so that isst_master_update data doesn't get tainted */
  pthread_mutex_lock(&isst_master_update_mut);

  /* function */
  op = ISST_OP_RENDER;
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &op, 1);
  isst_master_slave_data_len += 1;

  /* Frame Index */
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &frame_cur_ind, sizeof(short));
  isst_master_slave_data_len += sizeof(short);

  /* Camera Position */
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], isst_master_camera_position.v, sizeof(TIE_3));
  isst_master_slave_data_len += sizeof(TIE_3);

  /* Camera Focus */
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], isst_master_camera_focus.v, sizeof(TIE_3));
  isst_master_slave_data_len += sizeof(TIE_3);

  /* Rendering Method and Data */
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_rm, 1);
  isst_master_slave_data_len += 1;

  switch(isst_master_rm) {
    case RENDER_METHOD_PLANE:
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_position, sizeof(TIE_3));
      isst_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_direction, sizeof(TIE_3));
      isst_master_slave_data_len += sizeof(TIE_3);
      break;

    case RENDER_METHOD_SPALL:
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_in_hit, sizeof(TIE_3));
      isst_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_direction, sizeof(TIE_3));
      isst_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_spall_angle, sizeof(tfloat));
      isst_master_slave_data_len += sizeof(tfloat);
      break;

    default:
      break;
  }

  pthread_mutex_unlock(&isst_master_update_mut);
}


void isst_master_process_events(SDL_Event *event_queue, int event_num, isst_master_socket_t *sock) {
  int i, update;
  TIE_3 vec, vec2, vec3;
  tfloat celev;


  for(i = 0; i < event_num; i++) {
    update = 0;
    switch(event_queue[i].type) {
      printf("event_type: %d\n", event_queue[i].type);
      case SDL_KEYDOWN:
        update = 1;
        switch(event_queue[i].key.keysym.sym) {
          case SDLK_LSHIFT:
          case SDLK_RSHIFT:
            isst_master_shift_enabled = 1;
            break;

          case SDLK_1: /* RENDER_METHOD_PHONG */
            isst_master_rm = RENDER_METHOD_PHONG;
            break;

          case SDLK_2: /* RENDER_METHOD_PLANE */
            isst_master_rm = RENDER_METHOD_PLANE;
            break;

          case SDLK_3: /* RENDER_METHOD_SPALL */
            isst_master_rm = RENDER_METHOD_SPALL;
            break;

          case SDLK_4: /* RENDER_METHOD_COMPONENT */
            isst_master_rm = RENDER_METHOD_COMPONENT;
            break;

          case SDLK_8: /* RENDER_METHOD_DEPTH */
            isst_master_rm = RENDER_METHOD_DEPTH;
            break;

          case SDLK_9: /* RENDER_METHOD_GRID */
            isst_master_rm = RENDER_METHOD_GRID;
            break;

          case SDLK_0: /* RENDER_METHOD_NORMAL */
            isst_master_rm = RENDER_METHOD_NORMAL;
            break;


          case SDLK_UP:
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_mul_scalar(vec, vec, isst_master_scale*10.0);
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec);
            break;

          case SDLK_DOWN:
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_mul_scalar(vec, vec, isst_master_scale*10.0);
            math_vec_sub(isst_master_camera_position, isst_master_camera_position, vec);
            break;

          case SDLK_LEFT:
            /* strafe left */
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (isst_master_scale*10.0));
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec3);
            break;

          case SDLK_RIGHT:
            /* strafe right */
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (isst_master_scale*10.0));
            math_vec_sub(isst_master_camera_position, isst_master_camera_position, vec3);
            break;

          case SDLK_F12: /* Server Shutdown and quit*/
            isst_master_alive = 0;
            break;

          case SDLK_e: /* export frame */
#if 0
            pthread_mutex_lock(&isst_observer_gui_mut);
            {
              char filename[32];
              void *image24;
              strcpy(filename, "frame.ppm");
              image24 = malloc(3 * screen_w * screen_h);
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
#else
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 1);
#endif
              util_display_text_input("export_frame", filename, 32);
              util_image_save_ppm(filename, image24, screen_w, screen_h);
            }
            pthread_mutex_unlock(&isst_observer_gui_mut);
#endif
            break;

          case SDLK_f: /* fullscreen toggle */
            /* Reserved for Fullscreen */
            break;

	  case SDLK_g: /* grab mouse */
            isst_master_mouse_grab = isst_master_mouse_grab ^ 1;
	    break;

          case SDLK_q: /* quit */
            sock->active = 0;
            break;

          case SDLK_KP1: /* front, back */
            {
              tfloat dist;

              /* distance to center of rotation */
              math_vec_sub(vec, isst_master_camera_position, isst_master_cor);
              math_vec_dot(dist, vec, vec);
              dist = sqrt(dist);

              isst_master_camera_position = isst_master_cor;
              if(isst_master_shift_enabled) {
                isst_master_camera_position.v[0] -= dist;
                isst_master_camera_azimuth = 180;
                isst_master_camera_elevation = 0;
              } else {
                isst_master_camera_position.v[0] += dist;
                isst_master_camera_azimuth = 0;
                isst_master_camera_elevation = 0;
              }
            }
            break;

          case SDLK_KP3: /* right, left */
            {
              tfloat dist;

              /* distance to center of rotation */
              math_vec_sub(vec, isst_master_camera_position, isst_master_cor);
              math_vec_dot(dist, vec, vec);
              dist = sqrt(dist);

              isst_master_camera_position = isst_master_cor;
              if(isst_master_shift_enabled) {
                isst_master_camera_position.v[1] -= dist;
                isst_master_camera_azimuth = 270;
                isst_master_camera_elevation = 0;
              } else {
                isst_master_camera_position.v[1] += dist;
                isst_master_camera_azimuth = 90;
                isst_master_camera_elevation = 0;
              }
            }
            break;

          case SDLK_KP7: /* top, bottom */
            {
              tfloat dist;

              /* distance to center of rotation */
              math_vec_sub(vec, isst_master_camera_position, isst_master_cor);
              math_vec_dot(dist, vec, vec);
              dist = sqrt(dist);

              isst_master_camera_position = isst_master_cor;
              if(isst_master_shift_enabled) {
                isst_master_camera_position.v[2] -= dist;
                isst_master_camera_azimuth = 0;
                isst_master_camera_elevation = -90 + 0.01;
              } else {
                isst_master_camera_position.v[2] += dist;
                isst_master_camera_azimuth = 0;
                isst_master_camera_elevation = 90 - 0.01;
              }
            }
            break;

          case SDLK_KP0: /* set camera position and direction to shot position and direction */
            isst_master_camera_position = isst_master_shot_position;
            /* project and unitize shot vector onto xy plane */
            vec = isst_master_shot_direction;
            vec.v[2] = 0;
            math_vec_unitize(vec);

            isst_master_camera_azimuth = fmod(180 + (vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg), 360.0);
            isst_master_camera_elevation = -asin(isst_master_shot_direction.v[2]) * math_rad2deg;
            break;


          case SDLK_KP_DIVIDE: /* shotline */
            {
              void *mesg;
              common_work_t work;
              TIE_3 direction;
              int dlen;
              char op;

              /* Queue a work unit for a shot needed for the plane render method */
              mesg = malloc(sizeof(common_work_t) + 2 * sizeof(TIE_3));
              dlen = 0;

              work.orig_x = 0;
              work.orig_y = 0;
              work.size_x = 0;
              work.size_y = 0;

              memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
              dlen += sizeof(common_work_t);

              /* function */
              op = ISST_OP_SHOT;
              memcpy(&((char *)mesg)[dlen], &op, 1);
              dlen += 1;

              /* position */
              memcpy(&((char *)mesg)[dlen], &isst_master_camera_position, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              math_vec_sub(direction, isst_master_camera_focus, isst_master_camera_position);
              math_vec_unitize(direction);

              /* direction */
              memcpy(&((char *)mesg)[dlen], &direction, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              isst_master_shot_position = isst_master_camera_position;
              isst_master_shot_direction = direction;

              tienet_master_push(mesg, dlen);
              free(mesg);
            }
            break;

          case SDLK_KP_MULTIPLY: /* spawl cone */
            {
              void *mesg;
              common_work_t work;
              TIE_3 direction;
              int dlen;
              char op;

              /* Queue a work unit for a shot needed for the plane render method */
              mesg = malloc(sizeof(common_work_t) + 2 * sizeof(TIE_3) + sizeof(tfloat));
              dlen = 0;

              work.orig_x = 0;
              work.orig_y = 0;
              work.size_x = 0;
              work.size_y = 0;

              memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
              dlen += sizeof(common_work_t);

              /* function */
              op = ISST_OP_SPALL;
              memcpy(&((char *)mesg)[dlen], &op, 1);
              dlen += 1;

              /* position */
              memcpy(&((char *)mesg)[dlen], &isst_master_camera_position, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              math_vec_sub(direction, isst_master_camera_focus, isst_master_camera_position);
              math_vec_unitize(direction);

              /* direction */
              memcpy(&((char *)mesg)[dlen], &direction, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              /* angle */
              memcpy(&((char *)mesg)[dlen], &isst_master_spall_angle, sizeof(tfloat));
              dlen += sizeof(tfloat);

              isst_master_shot_position = isst_master_camera_position;
              isst_master_shot_direction = direction;

              tienet_master_push(mesg, dlen);
              free(mesg);
            }
            break;


          case SDLK_BACKQUOTE: /* console */
            /* reserved for console in observer */
            break;

          default:
            break;
        }
        break;

      case SDL_KEYUP:
        switch(event_queue[i].key.keysym.sym) {
          case SDLK_LSHIFT:
          case SDLK_RSHIFT:
            isst_master_shift_enabled = 0;
            break;

          default:
            break;
        }

      case SDL_MOUSEBUTTONDOWN:
        update = 1;
        if(event_queue[i].button.button == SDL_BUTTON_WHEELUP)
          isst_master_scale *= 1.25;

        if(event_queue[i].button.button == SDL_BUTTON_WHEELDOWN)
          isst_master_scale *= 0.8;
        break;

      case SDL_MOUSEMOTION:
        if(event_queue[i].motion.state && isst_master_mouse_grab) {
	  int dx, dy;

	  dx = -event_queue[i].motion.xrel;
	  dy = -event_queue[i].motion.yrel;

          update = 1;
          if(event_queue[i].button.button & 1<<(SDL_BUTTON_LEFT-1)) {
            /* backward and forward */
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_mul_scalar(vec, vec, (isst_master_scale*dy));
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec);

            /* strafe */
#if 0
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            vec2.v[0] = 0;
            vec2.v[1] = 0;
            vec2.v[2] = 1;
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (isst_master_scale*dx));
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec3);
#endif
          } else if(event_queue[i].button.button & 1<<(SDL_BUTTON_RIGHT-1)) {
            /* if the shift key is held down then rotate about Center of Rotation */
            if(isst_master_shift_enabled) {
              TIE_3 vec;
              tfloat mag, angle;

              vec.v[0] = isst_master_cor.v[0] - isst_master_camera_position.v[0];
              vec.v[1] = isst_master_cor.v[1] - isst_master_camera_position.v[1];
              vec.v[2] = 0;

#if 0
              math_vec_unitize(vec);
              math_vec_magnitude(mag, vec);
#else
              angle = vec.v[0]*vec.v[0] + vec.v[1]*vec.v[1];
              mag = sqrt(angle);
              vec.v[0] /= mag;
              vec.v[1] /= mag;
#endif

              vec.v[0] = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg;

              vec.v[0] -= 0.035*dx;
              vec.v[0] *= math_deg2rad;

              isst_master_camera_position.v[0] = -mag*cos(vec.v[0]) + isst_master_cor.v[0];
              isst_master_camera_position.v[1] = -mag*sin(vec.v[0]) + isst_master_cor.v[1];
              isst_master_camera_azimuth -= 0.035*dx;
            } else {
              isst_master_camera_azimuth += 0.035*dx;
              isst_master_camera_elevation -= 0.035*dy;
            }
          } else if(event_queue[i].button.button & 1<<(SDL_BUTTON_MIDDLE-1)) {
            isst_master_camera_position.v[2] += isst_master_scale*dy;

            /* strafe */
            math_vec_sub(vec, isst_master_camera_focus, isst_master_camera_position);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (isst_master_scale*dx));
            math_vec_add(isst_master_camera_position, isst_master_camera_position, vec3);
          }

          /* Keep azimuth position */
          if(isst_master_camera_azimuth < 0)
            isst_master_camera_azimuth += 360;
          if(isst_master_camera_azimuth > 360)
            isst_master_camera_azimuth -= 360;

          /* Keep elevation between -90 and +90 */
          if(isst_master_camera_elevation < -90)
            isst_master_camera_elevation = -90;
          if(isst_master_camera_elevation > 90)
            isst_master_camera_elevation = 90;

        }
        break;

      default:
        break;
    }

    if(update) {
      /* Update the camera data based on the current azimuth and elevation */
      isst_master_camera_focus = isst_master_camera_position;
      celev = cos(isst_master_camera_elevation * math_deg2rad);
      isst_master_camera_focus.v[0] -= cos(isst_master_camera_azimuth * math_deg2rad) * celev;
      isst_master_camera_focus.v[1] -= sin(isst_master_camera_azimuth * math_deg2rad) * celev;
      isst_master_camera_focus.v[2] -= sin(isst_master_camera_elevation * math_deg2rad);
    }
  }
}
@


1.5
log
@* Adjusted colors for plane and spall.
* Fixed the axis aligned geometry intersections.
* Added in_hit to observer overlay
@
text
@d782 1
a782 1
            isst_master_camera_azimuth = fmod(vec.v[1] < 0 ? 180.0 + acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg, 360.0);
@


1.4
log
@* Fixed the rendering weirdness on the slave start-up
  Slaves were requesting a work unit right after prep begins
  so that slaves were holding onto a work unit for a lengthy time
  until prep finished and causing the units to not get done until
  prep finished.
* Added compute nodes status to observer.
* Added Scale Factor status to observer.
* Changed bytes transfered to mibi bytes instead of kilobytes.
@
text
@d468 2
d782 2
a783 2
            isst_master_camera_azimuth = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg;
            isst_master_camera_elevation = asin(isst_master_shot_direction.v[2]) * math_rad2deg;
@


1.3
log
@Fixed AE for keith and removed origin AE stuff....  Fixed component view and
left bsp depth viewing in.
@
text
@d467 2
@


1.2
log
@* Data on demand to nodes (~20% mem savings).
* tlist memory leak in unpack.c fixed.
* BSP Depth Visualization rendering method.
* Split Plane Coloring
* Testing more efficient BSP methods.
@
text
@d52 2
a53 2
TIE_3 isst_master_camera_pos;
TIE_3 isst_master_camera_foc;
d55 2
a56 2
TIE_3 isst_master_shot_pos;
TIE_3 isst_master_shot_dir;
a61 2
tfloat isst_master_origin_azimuth;
tfloat isst_master_origin_elevation;
d83 2
d95 11
a105 8
  math_vec_set(isst_master_camera_pos, 10, 0, 0);
  math_vec_set(isst_master_shot_pos, 0, 0, 0);
  isst_master_camera_foc = isst_master_camera_pos;
  isst_master_camera_foc.v[1] += 1;
  isst_master_camera_azimuth = 180;
  isst_master_camera_elevation = 0;
  isst_master_origin_azimuth = 0; 
  isst_master_origin_elevation = 0; 
d241 2
d464 1
a464 1
                  overlay.camera_pos = isst_master_camera_pos;
a466 2
                  overlay.origin_azimuth = isst_master_origin_azimuth;
                  overlay.origin_elevation = isst_master_origin_elevation;
d553 1
a553 1
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], isst_master_camera_pos.v, sizeof(TIE_3));
d557 1
a557 1
  memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], isst_master_camera_foc.v, sizeof(TIE_3));
d566 1
a566 1
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_pos, sizeof(TIE_3));
d569 1
a569 1
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_dir, sizeof(TIE_3));
d577 1
a577 1
      memcpy(&((char *)isst_master_slave_data)[isst_master_slave_data_len], &isst_master_shot_dir, sizeof(TIE_3));
d640 1
a640 1
            math_vec_sub(vec, isst_master_camera_foc, isst_master_camera_pos);
d642 1
a642 1
            math_vec_add(isst_master_camera_pos, isst_master_camera_pos, vec);
d646 1
a646 1
            math_vec_sub(vec, isst_master_camera_foc, isst_master_camera_pos);
d648 1
a648 1
            math_vec_sub(isst_master_camera_pos, isst_master_camera_pos, vec);
d653 1
a653 1
            math_vec_sub(vec, isst_master_camera_foc, isst_master_camera_pos);
d657 1
a657 1
            math_vec_add(isst_master_camera_pos, isst_master_camera_pos, vec3);
d662 1
a662 1
            math_vec_sub(vec, isst_master_camera_foc, isst_master_camera_pos);
d666 1
a666 1
            math_vec_sub(isst_master_camera_pos, isst_master_camera_pos, vec3);
d710 1
a710 1
              math_vec_sub(vec, isst_master_camera_pos, isst_master_cor);
d714 1
a714 1
              isst_master_camera_pos = isst_master_cor;
d716 2
a717 2
                isst_master_camera_pos.v[1] += dist;
                isst_master_camera_azimuth = 270;
d720 2
a721 2
                isst_master_camera_pos.v[1] -= dist;
                isst_master_camera_azimuth = 90;
d732 1
a732 1
              math_vec_sub(vec, isst_master_camera_pos, isst_master_cor);
d736 1
a736 1
              isst_master_camera_pos = isst_master_cor;
d738 2
a739 2
                isst_master_camera_pos.v[0] -= dist;
                isst_master_camera_azimuth = 0;
d742 2
a743 2
                isst_master_camera_pos.v[0] += dist;
                isst_master_camera_azimuth = 180;
d754 1
a754 1
              math_vec_sub(vec, isst_master_camera_pos, isst_master_cor);
d758 1
a758 1
              isst_master_camera_pos = isst_master_cor;
d760 1
a760 1
                isst_master_camera_pos.v[2] -= dist;
d762 1
a762 1
                isst_master_camera_elevation = 90;
d764 1
a764 1
                isst_master_camera_pos.v[2] += dist;
d766 1
a766 1
                isst_master_camera_elevation = -90;
d772 1
a772 1
            isst_master_camera_pos = isst_master_shot_pos;
d774 1
a774 1
            vec = isst_master_shot_dir;
d779 1
a779 1
            isst_master_camera_elevation = asin(isst_master_shot_dir.v[2]) * math_rad2deg;
d787 1
a787 1
              TIE_3 dir;
d809 1
a809 1
              memcpy(&((char *)mesg)[dlen], &isst_master_camera_pos, sizeof(TIE_3));
d812 2
a813 2
              math_vec_sub(dir, isst_master_camera_foc, isst_master_camera_pos);
              math_vec_unitize(dir);
d816 1
a816 1
              memcpy(&((char *)mesg)[dlen], &dir, sizeof(TIE_3));
d819 2
a820 2
              isst_master_shot_pos = isst_master_camera_pos;
              isst_master_shot_dir = dir;
d831 1
a831 1
              TIE_3 dir;
d853 1
a853 1
              memcpy(&((char *)mesg)[dlen], &isst_master_camera_pos, sizeof(TIE_3));
d856 2
a857 2
              math_vec_sub(dir, isst_master_camera_foc, isst_master_camera_pos);
              math_vec_unitize(dir);
d860 1
a860 1
              memcpy(&((char *)mesg)[dlen], &dir, sizeof(TIE_3));
d867 2
a868 2
              isst_master_shot_pos = isst_master_camera_pos;
              isst_master_shot_dir = dir;
d915 1
a915 1
            math_vec_sub(vec, isst_master_camera_foc, isst_master_camera_pos);
d917 1
a917 1
            math_vec_add(isst_master_camera_pos, isst_master_camera_pos, vec);
d921 1
a921 1
            math_vec_sub(vec, isst_master_camera_foc, isst_master_camera_pos);
d927 1
a927 1
            math_vec_add(isst_master_camera_pos, isst_master_camera_pos, vec3);
d935 2
a936 2
              vec.v[0] = isst_master_cor.v[0] - isst_master_camera_pos.v[0];
              vec.v[1] = isst_master_cor.v[1] - isst_master_camera_pos.v[1];
d954 2
a955 2
              isst_master_camera_pos.v[0] = -mag*cos(vec.v[0]) + isst_master_cor.v[0];
              isst_master_camera_pos.v[1] = -mag*sin(vec.v[0]) + isst_master_cor.v[1];
d959 1
a959 1
              isst_master_camera_elevation += 0.035*dy;
d962 1
a962 1
            isst_master_camera_pos.v[2] += isst_master_scale*dy;
d965 1
a965 1
            math_vec_sub(vec, isst_master_camera_foc, isst_master_camera_pos);
d969 1
a969 1
            math_vec_add(isst_master_camera_pos, isst_master_camera_pos, vec3);
d972 12
a983 2
          isst_master_camera_azimuth = fmod(isst_master_camera_azimuth, 360.0);
          isst_master_camera_elevation = fmod(isst_master_camera_elevation, 360.0);
d993 1
a993 1
      isst_master_camera_foc = isst_master_camera_pos;
d995 3
a997 17
      isst_master_camera_foc.v[0] += cos(isst_master_camera_azimuth * math_deg2rad) * celev;
      isst_master_camera_foc.v[1] += sin(isst_master_camera_azimuth * math_deg2rad) * celev;
      isst_master_camera_foc.v[2] += sin(isst_master_camera_elevation * math_deg2rad);

      /* Update the Origin azimuth and elevation based on the camera position, azimuth = 0 along +X axis */
      vec = isst_master_camera_pos;
      vec.v[2] = 0;

      /* origin azimuth */
      math_vec_unitize(vec);
      vec.v[0] = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg;
      isst_master_origin_azimuth = fmod(vec.v[0], 360.0);

      /* origin elevation */
      vec = isst_master_camera_pos;
      math_vec_unitize(vec);
      isst_master_origin_elevation = sin(vec.v[2]);
@


1.1
log
@IVAT is now ISST (Interactive Shot Selection Tool).
@
text
@d607 2
a608 2
          case SDLK_0: /* RENDER_METHOD_PATH */
            isst_master_rm = RENDER_METHOD_PATH;
d611 2
a612 2
          case SDLK_1: /* RENDER_METHOD_NORMAL */
            isst_master_rm = RENDER_METHOD_NORMAL;
d615 2
a616 6
          case SDLK_2: /* RENDER_METHOD_PHONG */
            isst_master_rm = RENDER_METHOD_PHONG;
            break;

          case SDLK_3: /* RENDER_METHOD_PLANE */
            isst_master_rm = RENDER_METHOD_PLANE;
d623 2
a624 2
          case SDLK_5: /* RENDER_METHOD_SPALL */
            isst_master_rm = RENDER_METHOD_SPALL;
d631 5
@

