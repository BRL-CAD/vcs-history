head	1.20;
access;
symbols
	rel-7-10-4:1.19
	STABLE:1.19.0.2
	rel-7-10-2:1.17
	rel-7-10-0:1.17
	rel-7-8-4:1.11
	rel-7-8-2:1.11
	rel-7-8-0:1.11
	trimnurbs-branch:1.11.0.2
	help:1.11
	temp_tag:1.11
	bobWinPort-20051223-freeze:1.5
	postmerge-20051223-bobWinPort:1.11
	premerge-20051223-bobWinPort:1.11
	rel-7-6-6:1.11
	rel-7-6-4:1.11
	rel-7-6-2:1.6
	rel-7-6-branch:1.6.0.2
	rel-7-6-0:1.6
	rel-7-4-2:1.5.4.2
	rel-7-4-branch:1.5.0.4
	bobWinPort:1.5.0.2;
locks; strict;
comment	@ * @;


1.20
date	2007.10.14.08.01.45;	author brlcad;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.10.19.38.27;	author erikgreenwald;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.30.19.11.29;	author brlcad;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.20.20.05.06;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.08.06.49.17;	author brlcad;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.02.19.46.34;	author erikgreenwald;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.27.01.41.30;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.23.01.13.21;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.21.00.53.11;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.23.04.44.27;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.14.07.28.36;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.14.02.04.38;	author twingy;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.12.22.39.12;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.10.19.31.48;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.08.05.11.20;	author twingy;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2005.07.29.17.48.17;	author twingy;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2005.07.28.00.28.29;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.27.17.43.58;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.26.16.28.05;	author twingy;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.18.20.57.56;	author twingy;	state Exp;
branches;
next	;

1.5.4.1
date	2005.07.29.17.48.17;	author brlcad;	state dead;
branches;
next	1.5.4.2;

1.5.4.2
date	2005.08.16.21.03.46;	author brlcad;	state Exp;
branches;
next	;

1.6.2.1
date	2005.11.13.13.46.11;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.20
log
@take care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@/*                      O B S E R V E R . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file observer.c
 *
 * Author -
 *   Justin Shumaker
 *
 */

#include "common.h"
#include "observer.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "SDL.h"
#include "isst.h"
#include "image.h"
#include "display.h"
#include "umath.h"
#include "isst_struct.h"
#include "tienet.h"
#include "splash.h"
/* Networking Includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#if ISST_USE_COMPRESSION
  #include <zlib.h>
#endif


typedef struct isst_observer_net_info_s {
  struct hostent master;
  int port;
} isst_observer_net_info_t;


void isst_observer(char *host, int port);
void* isst_observer_networking(void *ptr);
void isst_observer_event_loop(void);


/***** GLOBALS *****/
pthread_t isst_observer_networking_thread;
pthread_mutex_t isst_observer_magnify_mut;
pthread_mutex_t event_mut;

tienet_sem_t isst_observer_sdlinit_sem;
tienet_sem_t isst_observer_sdlready_sem;
tienet_sem_t isst_observer_splash_sem;
pthread_mutex_t isst_observer_console_mut;

int screen_w;
int screen_h;

short isst_observer_endian;
uint8_t isst_observer_event_queue_size;
isst_event_t isst_observer_event_queue[64];
int isst_observer_event_loop_alive;
int isst_observer_display_init;
int isst_observer_master_socket;
unsigned int isst_observer_mouse_grab;
unsigned int isst_observer_magnify;

void *magnify_buffer;
/*******************/


void isst_observer(char *host, int port) {
  isst_observer_net_info_t ni;

  /* server address */
  if(gethostbyname(host)) {
    ni.master = gethostbyname(host)[0];
  } else {
    fprintf(stderr, "hostname %s unknown, exiting.\n", host);
    exit(1);
  }
  ni.port = port;

  isst_observer_event_queue_size = 0;
  isst_observer_event_loop_alive = 1;

  pthread_mutex_init(&event_mut, 0);
  pthread_mutex_init(&isst_observer_magnify_mut, 0);
  isst_observer_magnify = 1;

  tienet_sem_init(&isst_observer_sdlinit_sem, 0);
  tienet_sem_init(&isst_observer_sdlready_sem, 0);
  tienet_sem_init(&isst_observer_splash_sem, 0);
  pthread_mutex_init(&isst_observer_console_mut, 0);
  isst_observer_display_init = 1;

  /* Launch a thread to handle events */
  pthread_create(&isst_observer_networking_thread, NULL, isst_observer_networking, &ni);

  /* Process events */
  tienet_sem_wait(&isst_observer_sdlinit_sem);
  isst_observer_event_loop();

  /* JOIN EVENT HANDLING THREAD */
  pthread_join(isst_observer_networking_thread, NULL);
}


void* isst_observer_networking(void *ptr) {
  isst_observer_net_info_t *ni;
  struct timeval start, cur;
  struct sockaddr_in my_addr, srv_addr;
  unsigned int addrlen;
  unsigned char op;
  tfloat fps;
  int frame_num;
  void *frame;
#if ISST_USE_COMPRESSION
  void *comp_buf;
#endif

  ni = (isst_observer_net_info_t *)ptr;

  /* create a socket */
  if((isst_observer_master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    perror("Socket creation error");
    exit(1);
  }

  /* client address */
  my_addr.sin_family = AF_INET;
  my_addr.sin_addr.s_addr = INADDR_ANY;
  my_addr.sin_port = htons(0);

  srv_addr.sin_family = ni->master.h_addrtype;
  memcpy((char*)&srv_addr.sin_addr.s_addr, ni->master.h_addr_list[0], ni->master.h_length);
  srv_addr.sin_port = htons(ni->port);

  if(bind(isst_observer_master_socket, (struct sockaddr *)&my_addr, sizeof(my_addr)) < 0) {
    fprintf(stderr, "unable to bind socket, exiting.\n");
    exit(1);
  }

  /* connect to master */
  if(connect(isst_observer_master_socket, (struct sockaddr *)&srv_addr, sizeof(srv_addr)) < 0) {
    fprintf(stderr, "cannot connect to master, exiting.\n");
    exit(1);
  }

  addrlen = sizeof(srv_addr);

  /* send version and get endian info */
  op = ISST_NET_OP_INIT;
  tienet_send(isst_observer_master_socket, &op, 1, isst_observer_endian);
  tienet_recv(isst_observer_master_socket, &isst_observer_endian, sizeof(short), 0);
  isst_observer_endian = isst_observer_endian == 1 ? 0 : 1;
  tienet_recv(isst_observer_master_socket, &screen_w, sizeof(int), isst_observer_endian);
  tienet_recv(isst_observer_master_socket, &screen_h, sizeof(int), isst_observer_endian);

  /* Screen size is known.  Initialize SDL and continue once it's ready */
  tienet_sem_post(&isst_observer_sdlinit_sem);

  /* Allocate memory for frame buffer */
  magnify_buffer = malloc(screen_w*screen_h*3);
  if (!magnify_buffer) {
      perror("magnify_buffer");
      exit(1);
  }
  frame = malloc(screen_w*screen_h*3);
  if (!frame) {
      perror("frame");
      exit(1);
  }
#if ISST_USE_COMPRESSION
  comp_buf = malloc(screen_w*screen_h*3);
  if (!comp_buf) {
      perror("comp_buf");
      exit(1);
  }
#endif


  gettimeofday(&start, NULL);
  frame_num = 0;


  while(1) {
    /* Send request for next frame */
    op = ISST_NET_OP_FRAME;
    tienet_send(isst_observer_master_socket, &op, 1, isst_observer_endian);

    /* Check whether to quit here or not */
    tienet_recv(isst_observer_master_socket, &op, 1, isst_observer_endian);

    if(op == ISST_NET_OP_QUIT) {
      free(frame);
#if isst_USE_COMPRESSION
      free(comp_buf);
#endif
      util_display_free();
      close(isst_observer_master_socket);

      isst_observer_event_loop_alive = 0;
      printf("Observer detatched from master.\n");
      return(NULL);
    }

    /* Send Event Queue to Master */
    pthread_mutex_lock(&event_mut);

    tienet_send(isst_observer_master_socket, &isst_observer_event_queue_size, sizeof(uint8_t), 0);
    if(isst_observer_event_queue_size)
      tienet_send(isst_observer_master_socket, isst_observer_event_queue, isst_observer_event_queue_size * sizeof(isst_event_t), 0);
    isst_observer_event_queue_size = 0;

    pthread_mutex_unlock(&event_mut);

    /* get frame data */
    pthread_mutex_lock(&isst_observer_magnify_mut);

#if ISST_USE_COMPRESSION
    {
      unsigned long dest_len;
      unsigned int comp_size;

      tienet_recv(isst_observer_master_socket, &comp_size, sizeof(unsigned int), 0);
      tienet_recv(isst_observer_master_socket, comp_buf, comp_size, 0);

      dest_len = screen_w*screen_h*3;
      uncompress(frame, &dest_len, comp_buf, (unsigned long)comp_size);
    }
#else
    tienet_recv(isst_observer_master_socket, frame, 3*screen_w*screen_h, 0);
#endif

    if(isst_observer_display_init) {
      isst_observer_display_init = 0;
      tienet_sem_post(&isst_observer_splash_sem);
      tienet_sem_wait(&isst_observer_sdlready_sem);
    }


    /* Magnify the image if magnify > 1 */
    {
      unsigned int x, y;
      unsigned char pixel[6];

      if(isst_observer_magnify == 1) {
	memcpy(util_display_buffer->pixels, frame, 3*screen_w*screen_h);
      } else if(isst_observer_magnify == 2) {
	for(y = 0; y < screen_h; y++) {
	  for(x = 0; x < screen_w; x++) {
	    memcpy(pixel, &((char *)frame)[3*(y*screen_w+x)], 3);
	    pixel[3] = pixel[0];
	    pixel[4] = pixel[1];
	    pixel[5] = pixel[2];
	    memcpy(&((char *)util_display_buffer->pixels)[3*(4*y*screen_w+2*x)], pixel, 6);
	    memcpy(&((char *)util_display_buffer->pixels)[3*(2*screen_w*(2*y+1)+2*x)], pixel, 6);
	  }
	}
      }
    }


    /* compute frames per second (fps) */
    frame_num++;
    if(!(frame_num % 7)) {
      gettimeofday(&cur, NULL);
      fps = (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
      start = cur;
      frame_num = 0;
      fflush(stdout);
    }

    /* Get the overlay data */
    {
      isst_overlay_data_t overlay;
      char string[ADRT_NAME_SIZE];

      tienet_recv(isst_observer_master_socket, &overlay, sizeof(isst_overlay_data_t), 0);

      /* Wait for the console to unlock */
      pthread_mutex_lock(&isst_observer_console_mut);

      /* Draw Frame */
      util_display_draw(NULL);

      /* Overlay some useful text */
      snprintf(string, ADRT_NAME_SIZE, "position: %.3f %.3f %.3f", overlay.camera_position.v[0], overlay.camera_position.v[1], overlay. camera_position.v[2]);
      util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

      snprintf(string, ADRT_NAME_SIZE, "camera_ae: %.3f %.3f", overlay.camera_azimuth, overlay.camera_elevation);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

      snprintf(string, ADRT_NAME_SIZE, "in_hit: %.3f %.3f %.3f", overlay.in_hit.v[0], overlay.in_hit.v[1], overlay.in_hit.v[2], overlay.out_hit.v[0], overlay.out_hit.v[1], overlay.out_hit.v[2]);
      util_display_text(string, 0, 2, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

      snprintf(string, ADRT_NAME_SIZE, "nodes: %d", overlay.compute_nodes);
      util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

      snprintf(string, ADRT_NAME_SIZE, "fps: %.1f", fps);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

      snprintf(string, ADRT_NAME_SIZE, "units: meters");
      util_display_text(string, 0, 0, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_TOP);

      /* Multiply by 100 to put this number into a more weidly domain */
      snprintf(string, ADRT_NAME_SIZE, "scale: %.3f", overlay.scale * 100.0);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_TOP);

      snprintf(string, ADRT_NAME_SIZE, "res: %s", overlay.resolution);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_BOTTOM);

      snprintf(string, ADRT_NAME_SIZE, "controller: %s", overlay.controller ? "yes" : "no");
      util_display_text(string, 0, 0, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_BOTTOM);

      util_display_cross();
      util_display_flip();

      pthread_mutex_unlock(&isst_observer_console_mut);
    }

    pthread_mutex_unlock(&isst_observer_magnify_mut);
  }

  return(NULL);
}


void isst_observer_process(char *content, char *response) {
  char op;

  op = ISST_NET_OP_MESG;
  tienet_send(isst_observer_master_socket, &op, 1, 0);

  /* length of content */
  op = strlen(content);
  if(strlen(content)) {
    op += 1;
    tienet_send(isst_observer_master_socket, &op, 1, 0);

    /* content */
    tienet_send(isst_observer_master_socket, content, op, 0);

    /* get the response */
    tienet_recv(isst_observer_master_socket, &op, 1, 0);
    tienet_recv(isst_observer_master_socket, response, op, 0);
  }
}


void isst_observer_event_loop() {
  SDL_Event event;
  char **content_buffer, **console_buffer;
  int content_lines, console_lines, i;


  content_lines = 0;
  console_lines = 0;
  content_buffer = (char **)malloc(sizeof(char *) * 100);
  if (!content_buffer) {
      perror("content_buffer");
      exit(1);
  }
  console_buffer = (char **)malloc(sizeof(char *) * 100);
  if (!console_buffer) {
      perror("console_buffer");
      exit(1);
  }
  for(i = 0; i < 100; i++) {
    content_buffer[i] = (char *)malloc(80);
    if (!content_buffer[i]) {
	perror("content_buffer[i]");
	exit(1);
    }
    console_buffer[i] = (char *)malloc(80);
    if (!console_buffer[i]) {
	perror("console_buffer[i]");
	exit(1);
    }
  }
  content_buffer[0][0] = 0;
  console_buffer[0][0] = 0;


  /* Display Loading Splash Screen */
  util_display_init(isst_logo.width, isst_logo.height);

  SDL_WM_SetCaption("ADRT_ISST_Observer Loading...", NULL);
  memcpy(util_display_buffer->pixels, isst_logo.pixel_data, 3 * isst_logo.width * isst_logo.height);
  util_display_draw(NULL);
  util_display_flip();

  tienet_sem_wait(&isst_observer_splash_sem);
  util_display_free();

  /* Initialize the display with the size of the render context */
  util_display_init(screen_w, screen_h);

  SDL_WM_SetCaption("ADRT_ISST_Observer", NULL);
  tienet_sem_post(&isst_observer_sdlready_sem);

  while(SDL_WaitEvent(&event) >= 0 && isst_observer_event_loop_alive) {
    switch(event.type) {
      case SDL_KEYDOWN:
	switch(event.key.keysym.sym) {
	  case SDLK_F1: /* screen magnify 1x */
	    /* Set magnification level */
	    pthread_mutex_lock(&isst_observer_magnify_mut);
	    isst_observer_magnify = 1;

	    /* Free the existing context */
	    util_display_free();

	    /* Initialize the new context */
	    util_display_init(screen_w, screen_h);

	    magnify_buffer = realloc(magnify_buffer, screen_w*screen_h*3);
	    pthread_mutex_unlock(&isst_observer_magnify_mut);
	    break;

	  case SDLK_F2: /* screen magnify 2x */
	    /* Set magnification level */
	    pthread_mutex_lock(&isst_observer_magnify_mut);
	    isst_observer_magnify = 2;

	    /* Free the existing context */
	    util_display_free();

	    /* Initialize the new context */
	    util_display_init(2*screen_w, 2*screen_h);

	    magnify_buffer = realloc(magnify_buffer, 4*screen_w*screen_h*3);
	    pthread_mutex_unlock(&isst_observer_magnify_mut);
	    break;

	  case SDLK_f: /* fullscreen mode */
	    SDL_WM_ToggleFullScreen(util_display_screen);
	    break;

	  case SDLK_g: /* mouse grabbing */
	    isst_observer_mouse_grab ^= 1;
	    SDL_WM_GrabInput(isst_observer_mouse_grab ? SDL_GRAB_ON : SDL_GRAB_OFF);
	    SDL_ShowCursor(!isst_observer_mouse_grab);
	    break;

	  case SDLK_PRINT:
	    {
	      void *image24;

	      /* Screen dump */
	      image24 = malloc(3 * screen_w * screen_h);
	      if (!image24) {
		  perror("image24");
		  exit(1);
	      }
	      util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
	      util_image_save_ppm("screenshot.ppm", image24, screen_w, screen_h);
	      free(image24);
	    }
	    break;

	  case SDLK_BACKQUOTE:
	    /* Bring up the console */
	    pthread_mutex_lock(&isst_observer_console_mut);
	    util_display_editor(content_buffer, &content_lines, console_buffer, &console_lines, isst_observer_process);
	    pthread_mutex_unlock(&isst_observer_console_mut);
	    break;

	  default:
	    break;
	}
	break;

      default:
	break;
    }

    pthread_mutex_lock(&event_mut);
    /* Build up an event queue to send prior to receiving each frame */
    if(isst_observer_event_queue_size < 64) {
      isst_observer_event_queue[isst_observer_event_queue_size].type = event.type;
      isst_observer_event_queue[isst_observer_event_queue_size].keysym = event.key.keysym.sym;
      isst_observer_event_queue[isst_observer_event_queue_size].button = event.button.button;
      isst_observer_event_queue[isst_observer_event_queue_size].motion_state = event.motion.state;
      isst_observer_event_queue[isst_observer_event_queue_size].motion_xrel = event.motion.xrel;
      isst_observer_event_queue[isst_observer_event_queue_size].motion_yrel = event.motion.yrel;
      isst_observer_event_queue_size++;
    }
    pthread_mutex_unlock(&event_mut);
  }


  for(i = 0; i < 100; i++) {
    free(content_buffer[i]);
    free(console_buffer[i]);
  }
  free(content_buffer);
  free(console_buffer);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.19
log
@should only be using common.h, not brlcad_config.h
@
text
@d297 1
a297 1
      char string[256];
d308 1
a308 1
      sprintf(string, "position: %.3f %.3f %.3f", overlay.camera_position.v[0], overlay.camera_position.v[1], overlay. camera_position.v[2]);
d311 1
a311 1
      sprintf(string, "camera_ae: %.3f %.3f", overlay.camera_azimuth, overlay.camera_elevation);
d314 1
a314 1
      sprintf(string, "in_hit: %.3f %.3f %.3f", overlay.in_hit.v[0], overlay.in_hit.v[1], overlay.in_hit.v[2], overlay.out_hit.v[0], overlay.out_hit.v[1], overlay.out_hit.v[2]);
d317 1
a317 1
      sprintf(string, "nodes: %d", overlay.compute_nodes);
d320 1
a320 1
      sprintf(string, "fps: %.1f", fps);
d323 1
a323 1
      sprintf(string, "units: meters");
d327 1
a327 1
      sprintf(string, "scale: %.3f", overlay.scale * 100.0);
d330 1
a330 1
      sprintf(string, "res: %s", overlay.resolution);
d333 1
a333 1
      sprintf(string, "controller: %s", overlay.controller ? "yes" : "no");
@


1.18
log
@TFLOAT changed to tfloat.  also quell a few warnings/bugs related to passing the wrong TIE_3 pointer type.
@
text
@d27 1
a27 1
#include "brlcad_config.h"
@


1.17
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d134 1
a134 1
  TFLOAT fps;
d288 1
a288 1
      fps = (TFLOAT)(frame_num) / ((cur.tv_sec + (TFLOAT)cur.tv_usec/1000000.0) - (start.tv_sec + (TFLOAT)start.tv_usec/1000000.0)),
@


1.16
log
@give adrt some distinctiveness in the header
@
text
@d184 4
d189 4
d195 4
d380 4
d385 4
d391 4
d396 4
d472 4
@


1.15
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
@


1.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d134 1
a134 1
  tfloat fps;
d276 1
a276 1
      fps = (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
@


1.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a90 1

d256 1
a256 1
        memcpy(util_display_buffer->pixels, frame, 3*screen_w*screen_h);
d258 10
a267 10
        for(y = 0; y < screen_h; y++) {
          for(x = 0; x < screen_w; x++) {
            memcpy(pixel, &((char *)frame)[3*(y*screen_w+x)], 3);
            pixel[3] = pixel[0];
            pixel[4] = pixel[1];
            pixel[5] = pixel[2];
            memcpy(&((char *)util_display_buffer->pixels)[3*(4*y*screen_w+2*x)], pixel, 6);
            memcpy(&((char *)util_display_buffer->pixels)[3*(2*screen_w*(2*y+1)+2*x)], pixel, 6);
          }
        }
d397 64
a460 64
        switch(event.key.keysym.sym) {
          case SDLK_F1: /* screen magnify 1x */
            /* Set magnification level */
            pthread_mutex_lock(&isst_observer_magnify_mut);
            isst_observer_magnify = 1;

            /* Free the existing context */
            util_display_free();

            /* Initialize the new context */
            util_display_init(screen_w, screen_h);

            magnify_buffer = realloc(magnify_buffer, screen_w*screen_h*3);
            pthread_mutex_unlock(&isst_observer_magnify_mut);
            break;

          case SDLK_F2: /* screen magnify 2x */
            /* Set magnification level */
            pthread_mutex_lock(&isst_observer_magnify_mut);
            isst_observer_magnify = 2;

            /* Free the existing context */
            util_display_free();

            /* Initialize the new context */
            util_display_init(2*screen_w, 2*screen_h);

            magnify_buffer = realloc(magnify_buffer, 4*screen_w*screen_h*3);
            pthread_mutex_unlock(&isst_observer_magnify_mut);
            break;

          case SDLK_f: /* fullscreen mode */
            SDL_WM_ToggleFullScreen(util_display_screen);
            break;

          case SDLK_g: /* mouse grabbing */
            isst_observer_mouse_grab ^= 1;
            SDL_WM_GrabInput(isst_observer_mouse_grab ? SDL_GRAB_ON : SDL_GRAB_OFF);
            SDL_ShowCursor(!isst_observer_mouse_grab);
            break;

          case SDLK_PRINT:
            {
              void *image24;

              /* Screen dump */
              image24 = malloc(3 * screen_w * screen_h);
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
              util_image_save_ppm("screenshot.ppm", image24, screen_w, screen_h);
              free(image24);
            }
            break;

          case SDLK_BACKQUOTE:
            /* Bring up the console */
            pthread_mutex_lock(&isst_observer_console_mut);
            util_display_editor(content_buffer, &content_lines, console_buffer, &console_lines, isst_observer_process);
            pthread_mutex_unlock(&isst_observer_console_mut);
            break;

          default:
            break;
        }
        break;
d463 1
a463 1
        break;
@


1.12
log
@standard header and footer cleanup
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
@


1.11
log
@trailing ws
@
text
@d1 26
d489 10
@


1.10
log
@some friendly messages.
@
text
@d69 1
a69 1
  /* server address */ 
@


1.9
log
@isst_event_t integration.
@
text
@d356 2
a357 1
  util_display_draw((void *)isst_logo.pixel_data);
@


1.8
log
@screen 2x magnification for low res contexts (F1 F2).
@
text
@d53 2
a54 2
short isst_observer_event_queue_size;
SDL_Event isst_observer_event_queue[64];
d176 1
d193 1
a193 1
    tienet_send(isst_observer_master_socket, &isst_observer_event_queue_size, sizeof(short), isst_observer_endian);
d195 1
a195 1
      tienet_send(isst_observer_master_socket, isst_observer_event_queue, isst_observer_event_queue_size * sizeof(SDL_Event), isst_observer_endian);
d202 1
d218 7
d231 1
a231 1
        memcpy(magnify_buffer, frame, 3*screen_w*screen_h);
d239 2
a240 2
            memcpy(&((char *)magnify_buffer)[3*(4*y*screen_w+2*x)], pixel, 6);
            memcpy(&((char *)magnify_buffer)[3*(2*screen_w*(2*y+1)+2*x)], pixel, 6);
a245 5
    if(isst_observer_display_init) {
      isst_observer_display_init = 0;
      tienet_sem_post(&isst_observer_splash_sem);
      tienet_sem_wait(&isst_observer_sdlready_sem);
    }
d268 1
a268 1
      util_display_draw(magnify_buffer);
d442 9
a450 2
    if(isst_observer_event_queue_size < 64)
      isst_observer_event_queue[isst_observer_event_queue_size++] = event;
@


1.7
log
@32/64 observer comms should work
@
text
@d41 1
a41 1
pthread_mutex_t isst_observer_gui_mut;
a52 1

a54 1
int isst_observer_mouse_grab;
d58 4
d82 2
a83 1
  pthread_mutex_init(&isst_observer_gui_mut, 0);
a106 1
  void *frame;
d111 1
a115 1

d158 1
a176 1
      util_display_free();
d181 1
d200 1
d216 21
d264 1
a264 1
      util_display_draw(frame);
d300 2
d358 1
d368 30
d403 1
a403 1
            isst_observer_mouse_grab = isst_observer_mouse_grab ^ 1;
@


1.6
log
@fixed a stack pop bug in the kd-tree cache loader.  engine is 1.1% faster.
@
text
@d200 1
a200 1
      int comp_size;
d202 1
a202 1
      tienet_recv(isst_observer_master_socket, &comp_size, sizeof(int), 0);
@


1.6.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d41 1
a41 1
pthread_mutex_t isst_observer_magnify_mut;
d53 4
a56 2
uint8_t isst_observer_event_queue_size;
isst_event_t isst_observer_event_queue[64];
a59 4
unsigned int isst_observer_mouse_grab;
unsigned int isst_observer_magnify;

void *magnify_buffer;
d67 1
a67 1
  /* server address */
d80 1
a80 2
  pthread_mutex_init(&isst_observer_magnify_mut, 0);
  isst_observer_magnify = 1;
d104 1
a108 1
  void *frame;
d113 1
a155 1
  magnify_buffer = malloc(screen_w*screen_h*3);
a172 1

d174 1
a178 1
      util_display_free();
d189 1
a189 1
    tienet_send(isst_observer_master_socket, &isst_observer_event_queue_size, sizeof(uint8_t), 0);
d191 1
a191 1
      tienet_send(isst_observer_master_socket, isst_observer_event_queue, isst_observer_event_queue_size * sizeof(isst_event_t), 0);
a196 2
    pthread_mutex_lock(&isst_observer_magnify_mut);

d200 1
a200 1
      unsigned int comp_size;
d202 1
a202 1
      tienet_recv(isst_observer_master_socket, &comp_size, sizeof(unsigned int), 0);
a217 23

    /* Magnify the image if magnify > 1 */
    {
      unsigned int x, y;
      unsigned char pixel[6];

      if(isst_observer_magnify == 1) {
        memcpy(util_display_buffer->pixels, frame, 3*screen_w*screen_h);
      } else if(isst_observer_magnify == 2) {
        for(y = 0; y < screen_h; y++) {
          for(x = 0; x < screen_w; x++) {
            memcpy(pixel, &((char *)frame)[3*(y*screen_w+x)], 3);
            pixel[3] = pixel[0];
            pixel[4] = pixel[1];
            pixel[5] = pixel[2];
            memcpy(&((char *)util_display_buffer->pixels)[3*(4*y*screen_w+2*x)], pixel, 6);
            memcpy(&((char *)util_display_buffer->pixels)[3*(2*screen_w*(2*y+1)+2*x)], pixel, 6);
          }
        }
      }
    }


d239 1
a239 1
      util_display_draw(NULL);
a274 2

    pthread_mutex_unlock(&isst_observer_magnify_mut);
d325 1
a325 2
  memcpy(util_display_buffer->pixels, isst_logo.pixel_data, 3 * isst_logo.width * isst_logo.height);
  util_display_draw(NULL);
a330 1
  /* Initialize the display with the size of the render context */
a339 30
          case SDLK_F1: /* screen magnify 1x */
            /* Set magnification level */
            pthread_mutex_lock(&isst_observer_magnify_mut);
            isst_observer_magnify = 1;

            /* Free the existing context */
            util_display_free();

            /* Initialize the new context */
            util_display_init(screen_w, screen_h);

            magnify_buffer = realloc(magnify_buffer, screen_w*screen_h*3);
            pthread_mutex_unlock(&isst_observer_magnify_mut);
            break;

          case SDLK_F2: /* screen magnify 2x */
            /* Set magnification level */
            pthread_mutex_lock(&isst_observer_magnify_mut);
            isst_observer_magnify = 2;

            /* Free the existing context */
            util_display_free();

            /* Initialize the new context */
            util_display_init(2*screen_w, 2*screen_h);

            magnify_buffer = realloc(magnify_buffer, 4*screen_w*screen_h*3);
            pthread_mutex_unlock(&isst_observer_magnify_mut);
            break;

d345 1
a345 1
            isst_observer_mouse_grab ^= 1;
d380 2
a381 9
    if(isst_observer_event_queue_size < 64) {
      isst_observer_event_queue[isst_observer_event_queue_size].type = event.type;
      isst_observer_event_queue[isst_observer_event_queue_size].keysym = event.key.keysym.sym;
      isst_observer_event_queue[isst_observer_event_queue_size].button = event.button.button;
      isst_observer_event_queue[isst_observer_event_queue_size].motion_state = event.motion.state;
      isst_observer_event_queue[isst_observer_event_queue_size].motion_xrel = event.motion.xrel;
      isst_observer_event_queue[isst_observer_event_queue_size].motion_yrel = event.motion.yrel;
      isst_observer_event_queue_size++;
    }
@


1.5
log
@* Adjusted colors for plane and spall.
* Fixed the axis aligned geometry intersections.
* Added in_hit to observer overlay
@
text
@d350 1
a350 1
          case SDLK_F2:
@


1.5.4.1
log
@file observer.c was added on branch rel-7-4-branch on 2005-08-16 21:03:46 +0000
@
text
@d1 392
@


1.5.4.2
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@a0 392
#include "brlcad_config.h"
#include "observer.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "SDL.h"
#include "isst.h"
#include "image.h"
#include "display.h"
#include "umath.h"
#include "isst_struct.h"
#include "tienet.h"
#include "splash.h"
/* Networking Includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#if ISST_USE_COMPRESSION
  #include <zlib.h>
#endif


typedef struct isst_observer_net_info_s {
  struct hostent master;
  int port;
} isst_observer_net_info_t;


void isst_observer(char *host, int port);
void* isst_observer_networking(void *ptr);
void isst_observer_event_loop(void);


/***** GLOBALS *****/
pthread_t isst_observer_networking_thread;
pthread_mutex_t isst_observer_gui_mut;
pthread_mutex_t event_mut;

tienet_sem_t isst_observer_sdlinit_sem;
tienet_sem_t isst_observer_sdlready_sem;
tienet_sem_t isst_observer_splash_sem;
pthread_mutex_t isst_observer_console_mut;

int screen_w;
int screen_h;

short isst_observer_endian;

short isst_observer_event_queue_size;
SDL_Event isst_observer_event_queue[64];
int isst_observer_mouse_grab;
int isst_observer_event_loop_alive;
int isst_observer_display_init;
int isst_observer_master_socket;
/*******************/



void isst_observer(char *host, int port) {
  isst_observer_net_info_t ni;

  /* server address */ 
  if(gethostbyname(host)) {
    ni.master = gethostbyname(host)[0];
  } else {
    fprintf(stderr, "hostname %s unknown, exiting.\n", host);
    exit(1);
  }
  ni.port = port;

  isst_observer_event_queue_size = 0;
  isst_observer_event_loop_alive = 1;

  pthread_mutex_init(&event_mut, 0);
  pthread_mutex_init(&isst_observer_gui_mut, 0);

  tienet_sem_init(&isst_observer_sdlinit_sem, 0);
  tienet_sem_init(&isst_observer_sdlready_sem, 0);
  tienet_sem_init(&isst_observer_splash_sem, 0);
  pthread_mutex_init(&isst_observer_console_mut, 0);
  isst_observer_display_init = 1;

  /* Launch a thread to handle events */
  pthread_create(&isst_observer_networking_thread, NULL, isst_observer_networking, &ni);

  /* Process events */
  tienet_sem_wait(&isst_observer_sdlinit_sem);
  isst_observer_event_loop();

  /* JOIN EVENT HANDLING THREAD */
  pthread_join(isst_observer_networking_thread, NULL);
}


void* isst_observer_networking(void *ptr) {
  isst_observer_net_info_t *ni;
  struct timeval start, cur;
  struct sockaddr_in my_addr, srv_addr;
  void *frame;
  unsigned int addrlen;
  unsigned char op;
  tfloat fps;
  int frame_num;
#if ISST_USE_COMPRESSION
  void *comp_buf;
#endif


  ni = (isst_observer_net_info_t *)ptr;

  /* create a socket */
  if((isst_observer_master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    perror("Socket creation error");
    exit(1);
  }

  /* client address */
  my_addr.sin_family = AF_INET;
  my_addr.sin_addr.s_addr = INADDR_ANY;
  my_addr.sin_port = htons(0);

  srv_addr.sin_family = ni->master.h_addrtype;
  memcpy((char*)&srv_addr.sin_addr.s_addr, ni->master.h_addr_list[0], ni->master.h_length);
  srv_addr.sin_port = htons(ni->port);

  if(bind(isst_observer_master_socket, (struct sockaddr *)&my_addr, sizeof(my_addr)) < 0) {
    fprintf(stderr, "unable to bind socket, exiting.\n");
    exit(1);
  }

  /* connect to master */
  if(connect(isst_observer_master_socket, (struct sockaddr *)&srv_addr, sizeof(srv_addr)) < 0) {
    fprintf(stderr, "cannot connect to master, exiting.\n");
    exit(1);
  }

  addrlen = sizeof(srv_addr);

  /* send version and get endian info */
  op = ISST_NET_OP_INIT;
  tienet_send(isst_observer_master_socket, &op, 1, isst_observer_endian);
  tienet_recv(isst_observer_master_socket, &isst_observer_endian, sizeof(short), 0);
  isst_observer_endian = isst_observer_endian == 1 ? 0 : 1;
  tienet_recv(isst_observer_master_socket, &screen_w, sizeof(int), isst_observer_endian);
  tienet_recv(isst_observer_master_socket, &screen_h, sizeof(int), isst_observer_endian);

  /* Screen size is known.  Initialize SDL and continue once it's ready */
  tienet_sem_post(&isst_observer_sdlinit_sem);

  /* Allocate memory for frame buffer */
  frame = malloc(screen_w*screen_h*3);
#if ISST_USE_COMPRESSION
  comp_buf = malloc(screen_w*screen_h*3);
#endif


  gettimeofday(&start, NULL);
  frame_num = 0;


  while(1) {
    /* Send request for next frame */
    op = ISST_NET_OP_FRAME;
    tienet_send(isst_observer_master_socket, &op, 1, isst_observer_endian);

    /* Check whether to quit here or not */
    tienet_recv(isst_observer_master_socket, &op, 1, isst_observer_endian);
    if(op == ISST_NET_OP_QUIT) {
      util_display_free();
      free(frame);
#if isst_USE_COMPRESSION
      free(comp_buf);
#endif
      close(isst_observer_master_socket);

      isst_observer_event_loop_alive = 0;
      printf("Observer detatched from master.\n");
      return(NULL);
    }

    /* Send Event Queue to Master */
    pthread_mutex_lock(&event_mut);

    tienet_send(isst_observer_master_socket, &isst_observer_event_queue_size, sizeof(short), isst_observer_endian);
    if(isst_observer_event_queue_size)
      tienet_send(isst_observer_master_socket, isst_observer_event_queue, isst_observer_event_queue_size * sizeof(SDL_Event), isst_observer_endian);
    isst_observer_event_queue_size = 0;

    pthread_mutex_unlock(&event_mut);

    /* get frame data */
#if ISST_USE_COMPRESSION
    {
      unsigned long dest_len;
      int comp_size;

      tienet_recv(isst_observer_master_socket, &comp_size, sizeof(int), 0);
      tienet_recv(isst_observer_master_socket, comp_buf, comp_size, 0);

      dest_len = screen_w*screen_h*3;
      uncompress(frame, &dest_len, comp_buf, (unsigned long)comp_size);
    }
#else
    tienet_recv(isst_observer_master_socket, frame, 3*screen_w*screen_h, 0);
#endif

    if(isst_observer_display_init) {
      isst_observer_display_init = 0;
      tienet_sem_post(&isst_observer_splash_sem);
      tienet_sem_wait(&isst_observer_sdlready_sem);
    }

    /* compute frames per second (fps) */
    frame_num++;
    if(!(frame_num % 7)) {
      gettimeofday(&cur, NULL);
      fps = (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
      start = cur;
      frame_num = 0;
      fflush(stdout);
    }

    /* Get the overlay data */
    {
      isst_overlay_data_t overlay;
      char string[256];

      tienet_recv(isst_observer_master_socket, &overlay, sizeof(isst_overlay_data_t), 0);

      /* Wait for the console to unlock */
      pthread_mutex_lock(&isst_observer_console_mut);

      /* Draw Frame */
      util_display_draw(frame);

      /* Overlay some useful text */
      sprintf(string, "position: %.3f %.3f %.3f", overlay.camera_position.v[0], overlay.camera_position.v[1], overlay. camera_position.v[2]);
      util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

      sprintf(string, "camera_ae: %.3f %.3f", overlay.camera_azimuth, overlay.camera_elevation);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

      sprintf(string, "in_hit: %.3f %.3f %.3f", overlay.in_hit.v[0], overlay.in_hit.v[1], overlay.in_hit.v[2], overlay.out_hit.v[0], overlay.out_hit.v[1], overlay.out_hit.v[2]);
      util_display_text(string, 0, 2, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

      sprintf(string, "nodes: %d", overlay.compute_nodes);
      util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

      sprintf(string, "fps: %.1f", fps);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

      sprintf(string, "units: meters");
      util_display_text(string, 0, 0, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_TOP);

      /* Multiply by 100 to put this number into a more weidly domain */
      sprintf(string, "scale: %.3f", overlay.scale * 100.0);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_TOP);

      sprintf(string, "res: %s", overlay.resolution);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_BOTTOM);

      sprintf(string, "controller: %s", overlay.controller ? "yes" : "no");
      util_display_text(string, 0, 0, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_BOTTOM);

      util_display_cross();
      util_display_flip();

      pthread_mutex_unlock(&isst_observer_console_mut);
    }
  }

  return(NULL);
}


void isst_observer_process(char *content, char *response) {
  char op;

  op = ISST_NET_OP_MESG;
  tienet_send(isst_observer_master_socket, &op, 1, 0);

  /* length of content */
  op = strlen(content);
  if(strlen(content)) {
    op += 1;
    tienet_send(isst_observer_master_socket, &op, 1, 0);

    /* content */
    tienet_send(isst_observer_master_socket, content, op, 0);

    /* get the response */
    tienet_recv(isst_observer_master_socket, &op, 1, 0);
    tienet_recv(isst_observer_master_socket, response, op, 0);
  }
}


void isst_observer_event_loop() {
  SDL_Event event;
  char **content_buffer, **console_buffer;
  int content_lines, console_lines, i;


  content_lines = 0;
  console_lines = 0;
  content_buffer = (char **)malloc(sizeof(char *) * 100);
  console_buffer = (char **)malloc(sizeof(char *) * 100);
  for(i = 0; i < 100; i++) {
    content_buffer[i] = (char *)malloc(80);
    console_buffer[i] = (char *)malloc(80);
  }
  content_buffer[0][0] = 0;
  console_buffer[0][0] = 0;


  /* Display Loading Splash Screen */
  util_display_init(isst_logo.width, isst_logo.height);

  SDL_WM_SetCaption("ADRT_ISST_Observer Loading...", NULL);
  util_display_draw((void *)isst_logo.pixel_data);
  util_display_flip();

  tienet_sem_wait(&isst_observer_splash_sem);
  util_display_free();

  util_display_init(screen_w, screen_h);

  SDL_WM_SetCaption("ADRT_ISST_Observer", NULL);
  tienet_sem_post(&isst_observer_sdlready_sem);

  while(SDL_WaitEvent(&event) >= 0 && isst_observer_event_loop_alive) {
    switch(event.type) {
      case SDL_KEYDOWN:
        switch(event.key.keysym.sym) {
          case SDLK_f: /* fullscreen mode */
            SDL_WM_ToggleFullScreen(util_display_screen);
            break;

          case SDLK_g: /* mouse grabbing */
            isst_observer_mouse_grab = isst_observer_mouse_grab ^ 1;
            SDL_WM_GrabInput(isst_observer_mouse_grab ? SDL_GRAB_ON : SDL_GRAB_OFF);
            SDL_ShowCursor(!isst_observer_mouse_grab);
            break;

          case SDLK_F2:
            {
              void *image24;

              /* Screen dump */
              image24 = malloc(3 * screen_w * screen_h);
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
              util_image_save_ppm("screenshot.ppm", image24, screen_w, screen_h);
              free(image24);
            }
            break;

          case SDLK_BACKQUOTE:
            /* Bring up the console */
            pthread_mutex_lock(&isst_observer_console_mut);
            util_display_editor(content_buffer, &content_lines, console_buffer, &console_lines, isst_observer_process);
            pthread_mutex_unlock(&isst_observer_console_mut);
            break;

          default:
            break;
        }
        break;

      default:
        break;
    }

    pthread_mutex_lock(&event_mut);
    /* Build up an event queue to send prior to receiving each frame */
    if(isst_observer_event_queue_size < 64)
      isst_observer_event_queue[isst_observer_event_queue_size++] = event;
    pthread_mutex_unlock(&event_mut);
  }


  for(i = 0; i < 100; i++) {
    free(content_buffer[i]);
    free(console_buffer[i]);
  }
  free(content_buffer);
  free(console_buffer);
}
@


1.4
log
@* Overall load time for all 8 nodes during startup is 25% faster.
* File size of adrt mesh is now 33% smaller.  It uses shortst when trinum
  of the mesh is under 64K triangles.
* Prep data to slaves is now multi-threaded (all slaves get data from
  master at the same time, heavy network load).
@
text
@d248 3
@


1.3
log
@* Fixed the rendering weirdness on the slave start-up
  Slaves were requesting a work unit right after prep begins
  so that slaves were holding onto a work unit for a lengthy time
  until prep finished and causing the units to not get done until
  prep finished.
* Added compute nodes status to observer.
* Added Scale Factor status to observer.
* Changed bytes transfered to mibi bytes instead of kilobytes.
@
text
@d258 1
a258 1
      sprintf(string, "scale: %.2f", overlay.scale * 100.0);
@


1.2
log
@Fixed AE for keith and removed origin AE stuff....  Fixed component view and
left bsp depth viewing in.
@
text
@d241 1
d248 3
a253 3
      sprintf(string, "res: %s", overlay.resolution);
      util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

d257 7
@


1.1
log
@IVAT is now ISST (Interactive Shot Selection Tool).
@
text
@d241 1
a241 1
      sprintf(string, "position: %.3f %.3f %.3f", overlay.camera_pos.v[0], overlay.camera_pos.v[1], overlay. camera_pos.v[2]);
d244 1
a244 1
      sprintf(string, "origin_ae: %.3f %.3f", overlay.origin_azimuth, overlay.origin_elevation);
a246 3
      sprintf(string, "camera_ae: %.3f %.3f", overlay.camera_azimuth, overlay.camera_elevation);
      util_display_text(string, 0, 2, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

@

