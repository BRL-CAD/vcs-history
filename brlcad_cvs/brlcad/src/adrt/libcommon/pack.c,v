head	1.33;
access;
symbols
	rel-7-10-4:1.32
	STABLE:1.32.0.2
	rel-7-10-2:1.30
	rel-7-10-0:1.30
	rel-7-8-4:1.23
	rel-7-8-2:1.23
	rel-7-8-0:1.23
	trimnurbs-branch:1.23.0.2
	help:1.23
	temp_tag:1.22
	bobWinPort-20051223-freeze:1.11
	postmerge-20051223-bobWinPort:1.22
	premerge-20051223-bobWinPort:1.22
	rel-7-6-6:1.22
	rel-7-6-4:1.22
	rel-7-6-2:1.16
	rel-7-6-branch:1.16.0.2
	rel-7-6-0:1.16
	rel-7-4-2:1.9.2.1
	rel-7-4-branch:1.9.0.2
	bobWinPort:1.11.0.2
	rel-7-4-0:1.9;
locks; strict;
comment	@ * @;


1.33
date	2007.10.14.08.01.45;	author brlcad;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.10.19.38.27;	author erikgreenwald;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.30.19.11.29;	author brlcad;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.20.20.05.06;	author brlcad;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.08.06.49.18;	author brlcad;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.02.19.46.34;	author erikgreenwald;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.27.01.41.30;	author brlcad;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.23.01.13.21;	author brlcad;	state Exp;
branches;
next	1.25;

1.25
date	2007.01.21.00.51.04;	author brlcad;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.20.14.36.41;	author brlcad;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.18.06.46.11;	author brlcad;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.21.16.16.15;	author twingy;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.21.02.15.01;	author twingy;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.21.00.03.07;	author twingy;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.13.22.21.37;	author twingy;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.13.04.05.08;	author twingy;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.09.03.31.08;	author twingy;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.08.21.58.43;	author twingy;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2005.09.06.03.14.21;	author twingy;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.06.03.13.54;	author twingy;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.29.19.25.55;	author twingy;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.29.06.37.16;	author twingy;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.28.00.28.29;	author twingy;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.20.18.37.05;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.11.17.18.15;	author twingy;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2005.07.02.07.59.00;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.01.21.07.54;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.01.15.13.02;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.18.21.58.46;	author twingy;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.18.06.40.40;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.18.01.56.30;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.17.21.40.58;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.17.15.09.26;	author lbutler;	state Exp;
branches;
next	;

1.9.2.1
date	2005.08.16.21.03.46;	author brlcad;	state Exp;
branches;
next	;

1.16.2.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.33
log
@take care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@/*                     P A C K . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file pack.c
 *
 *  Common Library - Parsing and Packing
 *
 *  Author -
 *      Justin L. Shumaker
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 * $Id: pack.c,v 1.32 2007/09/10 19:38:27 erikgreenwald Exp $
 */

#include "pack.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "umath.h"
#include "texture.h"
#include "tienet.h"
#include "common.h"


#define K *1024
#define M *1024 K


void	common_pack_write(void **dest, int *ind, void *src, int size);

int	common_pack(common_db_t *db, void **app_data, char *proj);
void	common_pack_camera(common_db_t *db, void **app_data, int *app_ind);
void	common_pack_env(common_db_t *db, void **app_data, int *app_ind);
void	common_pack_prop(void **app_data, int *app_ind, char *filename);
void	common_pack_texture(void **app_data, int *app_ind, char *filename);

void	common_pack_mesh(common_db_t *db, void **app_data, int *app_ind, char *filename);
void	common_pack_mesh_adrt(common_db_t *db, void **app_data, int *app_ind, char *filename);
void    common_pack_kdtree_cache(common_db_t *db, void **app_data, int *app_ind, char *filename);
void	common_pack_mesh_map(void **app_data, int *app_ind, char *filename);

int	common_pack_app_size;
int	common_pack_app_mem;
int	common_pack_trinum;


void common_pack_write(void **dest, int *ind, void *src, int size) {
  if((int)(*ind + size) > (int)common_pack_app_size)
    common_pack_app_size = *ind + size;

  if(common_pack_app_size > common_pack_app_mem) {
    common_pack_app_mem = common_pack_app_size + (16 M);
    *dest = realloc(*dest, common_pack_app_mem);
  }

  memcpy(&(((char *)*dest)[*ind]), src, size);
  *ind += size;
}


int common_pack(common_db_t *db, void **app_data, char *proj) {
  short s;
  int app_ind, i;

  common_pack_app_size = 0;
  common_pack_app_mem = 0;

  common_pack_trinum = 0;

  /* Initialize app_data */
  app_ind = 0;
  (*app_data) = NULL;

  /* VERSION */
  s = 0;
  common_pack_write(app_data, &app_ind, &s, sizeof(short));

  /* ENVIRONMENT DATA */
  common_pack_env(db, app_data, &app_ind);

  /* CAMERA DATA */
  common_pack_camera(db, app_data, &app_ind);

  /* PROPERTY DATA */
  common_pack_prop(app_data, &app_ind, db->env.properties_file);

  /* TEXTURE DATA */
  common_pack_texture(app_data, &app_ind, db->env.textures_file);

  /* MESH DATA */
  common_pack_mesh(db, app_data, &app_ind, db->env.geometry_file);

  /* KD-TREE CACHE DATA */
  common_pack_kdtree_cache(db, app_data, &app_ind, db->env.kdtree_cache_file);

  /* MESH MAP FILE */
  common_pack_mesh_map(app_data, &app_ind, db->env.mesh_map_file);


  *app_data = realloc(*app_data, common_pack_app_size);
  return(common_pack_app_size);
}


void common_pack_camera(common_db_t *db, void **app_data, int *app_ind) {
  short s;
  unsigned int marker, size;

  marker = *app_ind;
  *app_ind += sizeof(unsigned int);

  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].pos, sizeof(TIE_3));
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].focus, sizeof(TIE_3));
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].tilt, sizeof(tfloat));
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].fov, sizeof(tfloat));
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].dof, sizeof(tfloat));


  size = *app_ind - marker - sizeof(unsigned int);
  common_pack_write(app_data, &marker, &size, sizeof(unsigned int));
  *app_ind = marker + size;
}


void common_pack_env(common_db_t *db, void **app_data, int *app_ind) {
  unsigned int marker, size;
  short s;

  marker = *app_ind;
  *app_ind += sizeof(unsigned int);

  s = COMMON_PACK_ENV_RM;
  common_pack_write(app_data, app_ind, &s, sizeof(short));
  common_pack_write(app_data, app_ind, &db->env.rm, sizeof(unsigned int));

  switch(db->env.rm) {
    case RENDER_METHOD_NORMAL:
      break;

    case RENDER_METHOD_PHONG:
      break;

    case RENDER_METHOD_PATH:
      common_pack_write(app_data, app_ind, &((render_path_t *)db->env.render.data)->samples, sizeof(render_path_t));
      break;

    case RENDER_METHOD_PLANE:
      break;

    case RENDER_METHOD_FLAT:
      break;

    default:
      break;
  }

  s = COMMON_PACK_ENV_IMAGESIZE;
  common_pack_write(app_data, app_ind, &s, sizeof(short));
  common_pack_write(app_data, app_ind, &db->env.img_w, sizeof(int));
  common_pack_write(app_data, app_ind, &db->env.img_h, sizeof(int));
  common_pack_write(app_data, app_ind, &db->env.img_hs, sizeof(int));


  size = *app_ind - marker - sizeof(unsigned int);
  common_pack_write(app_data, &marker, &size, sizeof(unsigned int));
  *app_ind = marker + size;
}


void common_pack_prop(void **app_data, int *app_ind, char *filename) {
  FILE *fh;
  common_prop_t def_prop;
  char line[ADRT_NAME_SIZE], name[ADRT_NAME_SIZE], *token;
  unsigned char c;
  unsigned int marker, size, prop_num;

  marker = *app_ind;
  *app_ind += sizeof(unsigned int);

  fh = fopen(filename, "r");
  if(!fh) {
    fprintf(stderr, "error: Properties file %s doesn't exist, exiting.\n", filename);
    exit(1);
  }

  prop_num = 0;
  while(fgets(line, ADRT_NAME_SIZE, fh)) {
    token = strtok(line, ",");
    if(!strcmp("properties", token)) {

      if(prop_num) {
	/* pack name */
	c = strlen(name) + 1;
	common_pack_write(app_data, app_ind, &c, sizeof(char));
	common_pack_write(app_data, app_ind, name, c);
	/* pack properties data */
	common_pack_write(app_data, app_ind, &def_prop, sizeof(common_prop_t));
      }

      token = strtok(NULL, ",");
      /* strip off newline */
      if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
      strncpy(name, token, ADRT_NAME_SIZE);

      /* set defaults */
      def_prop.color.v[0] = 0.8;
      def_prop.color.v[1] = 0.8;
      def_prop.color.v[2] = 0.8;
      def_prop.density = 0.5;
      def_prop.gloss = 0.5;
      def_prop.emission = 0.0;
      def_prop.ior = 1.0;

      prop_num++;

    } else if(!strcmp("color", token)) {

      token = strtok(NULL, ",");
      def_prop.color.v[0] = atof(token);
      token = strtok(NULL, ",");
      def_prop.color.v[1] = atof(token);
      token = strtok(NULL, ",");
      def_prop.color.v[2] = atof(token);

    } else if(!strcmp("density", token)) {

      token = strtok(NULL, ",");
      def_prop.density = atof(token);

    } else if(!strcmp("gloss", token)) {

      token = strtok(NULL, ",");
      def_prop.gloss = atof(token);

    } else if(!strcmp("emission", token)) {

      token = strtok(NULL, ",");
      def_prop.emission = atof(token);

    } else if(!strcmp("ior", token)) {

      token = strtok(NULL, ",");
      def_prop.ior = atof(token);

    }
  }

  if(prop_num) {
    /* pack name */
    c = strlen(name) + 1;
    common_pack_write(app_data, app_ind, &c, sizeof(char));
    common_pack_write(app_data, app_ind, name, c);
    /* pack properties data */
    common_pack_write(app_data, app_ind, &def_prop, sizeof(common_prop_t));
  }


  size = *app_ind - marker - sizeof(unsigned int);
  common_pack_write(app_data, &marker, &size, sizeof(unsigned int));
  *app_ind = marker + size;
}


void common_pack_texture(void **app_data, int *app_ind, char *filename) {
  FILE *fh;
  char line[256], *token;
  unsigned char c;
  unsigned int marker, size;
  short s;

  marker = *app_ind;
  *app_ind += sizeof(unsigned int);

  fh = fopen(filename, "r");
  if(!fh) {
    fprintf(stderr, "error: Textures file %s doesn't exist, exiting.\n", filename);
    exit(1);
  }


  while(fgets(line, 256, fh)) {
    token = strtok(line, ",");
    if(!strcmp("texture", token)) {
      token = strtok(NULL, ",");
      if(!strcmp("stack", token)) {
	s = TEXTURE_STACK;
	common_pack_write(app_data, app_ind, &s, sizeof(short));

	/* name */
	token = strtok(NULL, ",");
	if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;

	c = strlen(token) + 1;
	common_pack_write(app_data, app_ind, &c, sizeof(char));
	common_pack_write(app_data, app_ind, token, c);
      } else if(!strcmp("mix", token)) {
	tfloat coef;

	s = TEXTURE_MIX;
	common_pack_write(app_data, app_ind, &s, sizeof(short));

	/* name */
	token = strtok(NULL, ",");
	c = strlen(token) + 1;
	common_pack_write(app_data, app_ind, &c, sizeof(char));
	common_pack_write(app_data, app_ind, token, c);

	/* texture 1 */
	token = strtok(NULL, ",");
	c = strlen(token) + 1;
	common_pack_write(app_data, app_ind, &c, sizeof(char));
	common_pack_write(app_data, app_ind, token, c);

	/* texture 2 */
	token = strtok(NULL, ",");
	c = strlen(token) + 1;
	common_pack_write(app_data, app_ind, &c, sizeof(char));
	common_pack_write(app_data, app_ind, token, c);
/*
	sscanf(strstr(tag, "mode"), "mode=\"%[^\"]", ident);
	c = strlen(ident);
	common_pack_write(app_data, app_ind, &c, sizeof(char));
	common_pack_write(app_data, app_ind, ident, c);
*/

	/* coefficient */
	token = strtok(NULL, ",");
	if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
	coef = atof(token);
	common_pack_write(app_data, app_ind, &coef, sizeof(tfloat));
      }
    } else if(!strcmp("blend", token)) {
      TIE_3 color1, color2;

      s = TEXTURE_BLEND;
      common_pack_write(app_data, app_ind, &s, sizeof(short));

      /* color 1 */
      token = strtok(NULL, ",");
      color1.v[0] = atof(token);
      token = strtok(NULL, ",");
      color1.v[1] = atof(token);
      token = strtok(NULL, ",");
      color1.v[2] = atof(token);

      /* color 2 */
      token = strtok(NULL, ",");
      color2.v[0] = atof(token);
      token = strtok(NULL, ",");
      color2.v[1] = atof(token);
      token = strtok(NULL, ",");
      if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
      color2.v[2] = atof(token);

      common_pack_write(app_data, app_ind, &color1, sizeof(TIE_3));
      common_pack_write(app_data, app_ind, &color2, sizeof(TIE_3));
    } else if(!strcmp("bump", token)) {
      TIE_3 coef;

      s = TEXTURE_BUMP;
      common_pack_write(app_data, app_ind, &s, sizeof(short));

      /* coefficient */
      token = strtok(NULL, ",");
      coef.v[0] = atof(token);
      token = strtok(NULL, ",");
      coef.v[1] = atof(token);
      token = strtok(NULL, ",");
      if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
      coef.v[2] = atof(token);

      common_pack_write(app_data, app_ind, &coef, sizeof(TIE_3));
    } else if(!strcmp("checker", token)) {
      int tile;

      s = TEXTURE_CHECKER;
      common_pack_write(app_data, app_ind, &s, sizeof(short));

      /* tile */
      token = strtok(NULL, ",");
      if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
      tile = atoi(token);

      common_pack_write(app_data, app_ind, &tile, sizeof(unsigned int));
    } else if(!strcmp("camo", token)) {
      tfloat size;
      int octaves, absolute;
      TIE_3 color1, color2, color3;

      s = TEXTURE_CAMO;
      common_pack_write(app_data, app_ind, &s, sizeof(short));

      /* size */
      token = strtok(NULL, ",");
      size = atof(token);

      /* octaves */
      token = strtok(NULL, ",");
      octaves = atoi(token);

      /* absolute */
      token = strtok(NULL, ",");
      absolute = atoi(token);

      /* color 1 */
      token = strtok(NULL, ",");
      color1.v[0] = atof(token);
      token = strtok(NULL, ",");
      color1.v[1] = atof(token);
      token = strtok(NULL, ",");
      color1.v[2] = atof(token);

      /* color 2 */
      token = strtok(NULL, ",");
      color2.v[0] = atof(token);
      token = strtok(NULL, ",");
      color2.v[1] = atof(token);
      token = strtok(NULL, ",");
      color2.v[2] = atof(token);

      /* color 3 */
      token = strtok(NULL, ",");
      color3.v[0] = atof(token);
      token = strtok(NULL, ",");
      color3.v[1] = atof(token);
      token = strtok(NULL, ",");
      if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
      color3.v[2] = atof(token);

      common_pack_write(app_data, app_ind, &size, sizeof(tfloat));
      common_pack_write(app_data, app_ind, &octaves, sizeof(int));
      common_pack_write(app_data, app_ind, &absolute, sizeof(int));
      common_pack_write(app_data, app_ind, &color1, sizeof(TIE_3));
      common_pack_write(app_data, app_ind, &color2, sizeof(TIE_3));
      common_pack_write(app_data, app_ind, &color3, sizeof(TIE_3));
    } else if(!strcmp("clouds", token)) {
      tfloat size;
      int octaves, absolute;
      TIE_3 scale, translate;

      s = TEXTURE_CLOUDS;
      common_pack_write(app_data, app_ind, &s, sizeof(short));

      /* size */
      token = strtok(NULL, ",");
      size = atof(token);

      /* octaves */
      token = strtok(NULL, ",");
      octaves = atoi(token);

      /* absolute */
      token = strtok(NULL, ",");
      absolute = atoi(token);

      /* scale */
      token = strtok(NULL, ",");
      scale.v[0] = atof(token);
      token = strtok(NULL, ",");
      scale.v[1] = atof(token);
      token = strtok(NULL, ",");
      scale.v[2] = atof(token);

      /* translate */
      token = strtok(NULL, ",");
      translate.v[0] = atof(token);
      token = strtok(NULL, ",");
      translate.v[1] = atof(token);
      token = strtok(NULL, ",");
      if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
      translate.v[2] = atof(token);

      common_pack_write(app_data, app_ind, &size, sizeof(tfloat));
      common_pack_write(app_data, app_ind, &octaves, sizeof(int));
      common_pack_write(app_data, app_ind, &absolute, sizeof(int));
      common_pack_write(app_data, app_ind, &scale, sizeof(TIE_3));
      common_pack_write(app_data, app_ind, &translate, sizeof(TIE_3));
    } else if(!strcmp("image", token)) {
/*
      char file[64];
      image = SDL_LoadBMP(file);
      if(image) {
	s = TEXTURE_IMAGE;
	common_pack_write(app_data, app_ind, &s, sizeof(short));
	common_pack_write(app_data, app_ind, &(image->w), sizeof(short));
	common_pack_write(app_data, app_ind, &(image->h), sizeof(short));
	common_pack_write(app_data, app_ind, image->pixels, 3*image->w*image->h);
      }
*/
    } else if(!strcmp("gradient", token)) {
      int axis;

      s = TEXTURE_GRADIENT;
      common_pack_write(app_data, app_ind, &s, sizeof(short));

      /* axis */
      token = strtok(NULL, ",");
      if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
      axis = atoi(token);

      common_pack_write(app_data, app_ind, &axis, sizeof(int));
    }
  }

  fclose(fh);


  size = *app_ind - marker - sizeof(unsigned int);
  common_pack_write(app_data, &marker, &size, sizeof(unsigned int));
  *app_ind = marker + size;
}


void common_pack_mesh(common_db_t *db, void **app_data, int *app_ind, char *filename) {
  common_pack_mesh_adrt(db, app_data, app_ind, filename);
}


void common_pack_mesh_adrt(common_db_t *db, void **app_data, int *app_ind, char *filename) {
  FILE *fh;
  TIE_3 v[48];
  char meshname[256], texturename[256];
  unsigned char c;
  unsigned short s, endian;
  int matrixind;
  unsigned int face[144], marker_size, size, i, j, k, n, num, end, total_tri_num;


  fh = fopen(filename, "rb");
  if(!fh) {
    fprintf(stderr, "error: ADRT geometry file %s doesn't exist, exiting.\n", filename);
    exit(1);
  }

  /* Marker for size of all mesh data */
  marker_size = *app_ind;
  *app_ind += sizeof(unsigned int);

  /* Get End Position */
  fseek(fh, 0, SEEK_END);
  end = ftell(fh);
  fseek(fh, 0, SEEK_SET);

  /* Check Endian */
  fread(&endian, sizeof(unsigned short), 1, fh);
  endian = endian == 1 ? 0 : 1;

  /* Check Geometry Revision */
  fread(&s, sizeof(unsigned short), 1, fh);

  /* Total number of Triangles */
  fread(&total_tri_num, sizeof(unsigned int), 1, fh);
  common_pack_write(app_data, app_ind, &total_tri_num, sizeof(unsigned int));

  while(ftell(fh) != end) {
    /* Mesh Name */
    fread(&c, sizeof(char), 1, fh);
    fread(meshname, sizeof(char), c, fh);
    common_pack_write(app_data, app_ind, &c, sizeof(char));
    common_pack_write(app_data, app_ind, meshname, c);

    /* Pack Number of Vertices */
    fread(&num, sizeof(unsigned int), 1, fh);
    if(endian) tienet_flip(&num, &num, sizeof(unsigned int));
    common_pack_write(app_data, app_ind, &num, sizeof(unsigned int));

    /* Read and Pack Vertices */
    n = 0;
    for(i = 0; i < num; i += n) {
      n = i+48 < num ? 48 : num - i;
      fread(v, sizeof(TIE_3), n, fh);
      common_pack_write(app_data, app_ind, &v, n * sizeof(TIE_3));
    }

    /* Pack Number of Faces */

    /* Short or Int used for face indices */
    fread(&c, 1, 1, fh);
    common_pack_write(app_data, app_ind, &c, 1);

    if(c) {
      fread(&num, sizeof(unsigned int), 1, fh);
      if(endian) tienet_flip(&num, &num, sizeof(unsigned int));
      common_pack_write(app_data, app_ind, &num, sizeof(unsigned int));
      common_pack_trinum += num;

      /* Pack Faces */
      i = 0;
      while(i < num) {
	n = num - i > 48 ? 48 : num - i;
	fread(face, 3*sizeof(unsigned int), n, fh);
	common_pack_write(app_data, app_ind, face, 3 * n * sizeof(unsigned int));
	i += n;
      }
    } else {
      unsigned short snum, sface[144];

      fread(&snum, sizeof(unsigned short), 1, fh);
      if(endian) tienet_flip(&snum, &snum, sizeof(unsigned short));
      common_pack_write(app_data, app_ind, &snum, sizeof(unsigned short));
      common_pack_trinum += snum;

      /* Pack Faces */
      i = 0;
      while(i < snum) {
	n = snum - i > 48 ? 48 : snum - i;
	fread(sface, 3*sizeof(unsigned short), n, fh);
	common_pack_write(app_data, app_ind, sface, 3 * n * sizeof(unsigned short));
	i += n;
      }
    }

    /* Determine if Mesh has a Transformation Matrix assigned to it */
    matrixind = -1;
    for(n = 0; n < db->anim.frame_list[0].tnum; n++)
      if(!strcmp(meshname, db->anim.frame_list[0].tlist[n].mesh_name))
	matrixind = n;

    /* Write Matrix */
    if(matrixind >= 0) {
      common_pack_write(app_data, app_ind, db->anim.frame_list[0].tlist[matrixind].matrix, sizeof(tfloat)*16);
    } else{
      tfloat matrix[16];
      math_mat_ident(matrix, 4);
      common_pack_write(app_data, app_ind, matrix, sizeof(tfloat)*16);
    }
  }

  fclose(fh);

  /* pack the size of the mesh data */
  size = *app_ind - marker_size - sizeof(unsigned int); /* make sure you're not counting the data size integer */
  common_pack_write(app_data, &marker_size, &size, sizeof(unsigned int));

  *app_ind = marker_size + size;
}


void common_pack_kdtree_cache(common_db_t *db, void **app_data, int *app_ind, char *filename) {
  FILE *fh;
  void *kdcache;
  unsigned int marker, size;

  marker = *app_ind;
  *app_ind += sizeof(unsigned int);

  if(!filename)
    return;

  fh = fopen(filename, "rb");
  if(!fh) {
    size = *app_ind - marker - sizeof(unsigned int);
    common_pack_write(app_data, &marker, &size, sizeof(unsigned int));
    *app_ind = marker + size;
    return;
  }

  /* Get End Position */
  fseek(fh, 0, SEEK_END);
  size = ftell(fh);
  fseek(fh, 0, SEEK_SET);

  kdcache = malloc(size);
  if (!kdcache) {
      perror("kdcache");
      exit(1);
  }
  fread(kdcache, size, 1, fh);
  common_pack_write(app_data, app_ind, kdcache, size);
  fclose(fh);
  free(kdcache);

  size = *app_ind - marker - sizeof(unsigned int);
  common_pack_write(app_data, &marker, &size, sizeof(unsigned int));
  *app_ind = marker + size;
}


void common_pack_mesh_map(void **app_data, int *app_ind, char *filename) {
  FILE *fh;
  unsigned int marker, size;
  void *map;


  marker = *app_ind;
  *app_ind += sizeof(unsigned int);

  fh = fopen(filename, "rb");
  if(!fh) {
    fprintf(stderr, "error: Mesh Map file %s doesn't exist, exiting.\n", filename);
    exit(1);
  }

  fseek(fh, 0, SEEK_END);
  size = ftell(fh);
  fseek(fh, 0, SEEK_SET);

  map = malloc(size);
  if (!map) {
      perror("map");
      exit(1);
  }
  fread(map, size, 1, fh);
  common_pack_write(app_data, app_ind, map, size);
  free(map);

  fclose(fh);

  size = *app_ind - marker - sizeof(unsigned int);
  common_pack_write(app_data, &marker, &size, sizeof(unsigned int));
  *app_ind = marker + size;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.32
log
@should only be using common.h, not brlcad_config.h
@
text
@d31 1
a31 1
 * $Id: pack.c,v 1.31 2007/08/30 19:11:29 brlcad Exp $
d193 1
a193 1
  char line[256], name[256], *token;
d207 1
a207 1
  while(fgets(line, 256, fh)) {
d223 1
a223 1
      strcpy(name, token);
@


1.31
log
@TFLOAT changed to tfloat.  also quell a few warnings/bugs related to passing the wrong TIE_3 pointer type.
@
text
@d31 1
a31 1
 * $Id: pack.c,v 1.30 2007/03/20 20:05:06 brlcad Exp $
d42 1
a42 1
#include "brlcad_config.h"
@


1.30
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d31 1
a31 1
 * $Id: pack.c,v 1.29 2007/02/08 06:49:18 brlcad Exp $
d134 3
a136 3
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].tilt, sizeof(TFLOAT));
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].fov, sizeof(TFLOAT));
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].dof, sizeof(TFLOAT));
d317 1
a317 1
	TFLOAT coef;
d350 1
a350 1
	common_pack_write(app_data, app_ind, &coef, sizeof(TFLOAT));
d406 1
a406 1
      TFLOAT size;
d450 1
a450 1
      common_pack_write(app_data, app_ind, &size, sizeof(TFLOAT));
d457 1
a457 1
      TFLOAT size;
d493 1
a493 1
      common_pack_write(app_data, app_ind, &size, sizeof(TFLOAT));
d641 1
a641 1
      common_pack_write(app_data, app_ind, db->anim.frame_list[0].tlist[matrixind].matrix, sizeof(TFLOAT)*16);
d643 1
a643 1
      TFLOAT matrix[16];
d645 1
a645 1
      common_pack_write(app_data, app_ind, matrix, sizeof(TFLOAT)*16);
@


1.29
log
@give adrt some distinctiveness in the header
@
text
@d31 1
a31 1
 * $Id: pack.c,v 1.28 2007/02/02 19:46:34 erikgreenwald Exp $
d684 4
d719 4
@


1.28
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
d31 1
a31 1
 * $Id: pack.c,v 1.27 2007/01/27 01:41:30 brlcad Exp $
@


1.27
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d31 1
a31 1
 * $Id: pack.c,v 1.26 2007/01/23 01:13:21 brlcad Exp $
d134 3
a136 3
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].tilt, sizeof(tfloat));
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].fov, sizeof(tfloat));
  common_pack_write(app_data, app_ind, &db->anim.frame_list[0].dof, sizeof(tfloat));
d317 1
a317 1
	tfloat coef;
d350 1
a350 1
	common_pack_write(app_data, app_ind, &coef, sizeof(tfloat));
d406 1
a406 1
      tfloat size;
d450 1
a450 1
      common_pack_write(app_data, app_ind, &size, sizeof(tfloat));
d457 1
a457 1
      tfloat size;
d493 1
a493 1
      common_pack_write(app_data, app_ind, &size, sizeof(tfloat));
d641 1
a641 1
      common_pack_write(app_data, app_ind, db->anim.frame_list[0].tlist[matrixind].matrix, sizeof(tfloat)*16);
d643 1
a643 1
      tfloat matrix[16];
d645 1
a645 1
      common_pack_write(app_data, app_ind, matrix, sizeof(tfloat)*16);
@


1.26
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d31 1
a31 1
 * $Id: pack.c,v 1.25 2007/01/21 00:51:04 brlcad Exp $
d212 6
a217 6
        /* pack name */
        c = strlen(name) + 1;
        common_pack_write(app_data, app_ind, &c, sizeof(char));
        common_pack_write(app_data, app_ind, name, c);
        /* pack properties data */
        common_pack_write(app_data, app_ind, &def_prop, sizeof(common_prop_t));
d306 2
a307 2
        s = TEXTURE_STACK;
        common_pack_write(app_data, app_ind, &s, sizeof(short));
d309 7
a315 7
        /* name */
        token = strtok(NULL, ",");
        if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;

        c = strlen(token) + 1;
        common_pack_write(app_data, app_ind, &c, sizeof(char));
        common_pack_write(app_data, app_ind, token, c);
d317 1
a317 1
        tfloat coef;
d319 2
a320 2
        s = TEXTURE_MIX;
        common_pack_write(app_data, app_ind, &s, sizeof(short));
d322 17
a338 17
        /* name */
        token = strtok(NULL, ",");
        c = strlen(token) + 1;
        common_pack_write(app_data, app_ind, &c, sizeof(char));
        common_pack_write(app_data, app_ind, token, c);

        /* texture 1 */
        token = strtok(NULL, ",");
        c = strlen(token) + 1;
        common_pack_write(app_data, app_ind, &c, sizeof(char));
        common_pack_write(app_data, app_ind, token, c);

        /* texture 2 */
        token = strtok(NULL, ",");
        c = strlen(token) + 1;
        common_pack_write(app_data, app_ind, &c, sizeof(char));
        common_pack_write(app_data, app_ind, token, c);
d340 4
a343 4
        sscanf(strstr(tag, "mode"), "mode=\"%[^\"]", ident);
        c = strlen(ident);
        common_pack_write(app_data, app_ind, &c, sizeof(char));
        common_pack_write(app_data, app_ind, ident, c);
d346 5
a350 5
        /* coefficient */
        token = strtok(NULL, ",");
        if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
        coef = atof(token);
        common_pack_write(app_data, app_ind, &coef, sizeof(tfloat));
d503 5
a507 5
        s = TEXTURE_IMAGE;
        common_pack_write(app_data, app_ind, &s, sizeof(short));
        common_pack_write(app_data, app_ind, &(image->w), sizeof(short));
        common_pack_write(app_data, app_ind, &(image->h), sizeof(short));
        common_pack_write(app_data, app_ind, image->pixels, 3*image->w*image->h);
d610 4
a613 4
        n = num - i > 48 ? 48 : num - i;
        fread(face, 3*sizeof(unsigned int), n, fh);
        common_pack_write(app_data, app_ind, face, 3 * n * sizeof(unsigned int));
        i += n;
d626 4
a629 4
        n = snum - i > 48 ? 48 : snum - i;
        fread(sface, 3*sizeof(unsigned short), n, fh);
        common_pack_write(app_data, app_ind, sface, 3 * n * sizeof(unsigned short));
        i += n;
d637 1
a637 1
        matrixind = n;
@


1.25
log
@standard header and footer cleanup
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d31 1
a31 1
 * $Id: pack.c,v 1.24 2007/01/20 14:36:41 brlcad Exp $
@


1.24
log
@update copyright to 2007
@
text
@a21 1
 *                     P A C K . C
d32 1
a32 1
 * $Id: pack.c,v 1.23 2006/01/18 06:46:11 brlcad Exp $
d726 10
@


1.23
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2006 United States Government as represented by
d33 1
a33 1
 * $Id: pack.c,v 1.22 2005/09/21 16:16:15 twingy Exp $
@


1.22
log
@reverted
@
text
@d4 1
a4 1
 * Copyright (C) 2002-2005 United States Government as represented by
d33 1
a33 1
 * $Id: pack.c,v 1.20 2005/09/21 00:03:07 twingy Exp $
@


1.21
log
@librender is now libvis, render method terminology becomes visualization method or vis
method for short.
@
text
@d156 1
a156 1
  common_pack_write(app_data, app_ind, &db->env.vm, sizeof(unsigned int));
d158 2
a159 2
  switch(db->env.vm) {
    case VM_NORMAL:
d162 1
a162 1
    case VM_PHONG:
d165 2
a166 2
    case VM_PATH:
      common_pack_write(app_data, app_ind, &((vis_path_t *)db->env.vis.data)->samples, sizeof(vis_path_t));
d169 1
a169 1
    case VM_PLANE:
d172 1
a172 1
    case VM_FLAT:
@


1.20
log
@*** empty log message ***
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.19 2005/09/13 22:21:37 twingy Exp $
d156 1
a156 1
  common_pack_write(app_data, app_ind, &db->env.rm, sizeof(unsigned int));
d158 2
a159 2
  switch(db->env.rm) {
    case RENDER_METHOD_NORMAL:
d162 1
a162 1
    case RENDER_METHOD_PHONG:
d165 2
a166 2
    case RENDER_METHOD_PATH:
      common_pack_write(app_data, app_ind, &((render_path_t *)db->env.render.data)->samples, sizeof(render_path_t));
d169 1
a169 1
    case RENDER_METHOD_PLANE:
d172 1
a172 1
    case RENDER_METHOD_FLAT:
@


1.19
log
@mesh map file is now binary.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.18 2005/09/13 04:05:08 twingy Exp $
a168 3
    case RENDER_METHOD_KELOS:
      break;

@


1.18
log
@fixed some fu
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.17 2005/09/09 03:31:08 twingy Exp $
a583 1
//    meshname[(int)(c++)] = 0;
a701 2
  char line[256], *token;
  unsigned char c;
d703 1
d709 1
a709 1
  fh = fopen(filename, "r");
d715 3
a717 5
  while(fgets(line, 256, fh)) {
    token = strtok(line, ",");
    c = strlen(token) + 1;
    common_pack_write(app_data, app_ind, &c, 1);
    common_pack_write(app_data, app_ind, token, c);
d719 4
a722 6
    token = strtok(NULL, ",");
    if(token[strlen(token)-1] == '\n') token[strlen(token)-1] = 0;
    c = strlen(token) + 1;
    common_pack_write(app_data, app_ind, &c, 1);
    common_pack_write(app_data, app_ind, token, c);
  }
@


1.17
log
@fixed python exporter.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.16 2005/09/08 21:58:43 twingy Exp $
d550 2
a551 2
  int face[144], marker_size, size, i, j, k, n, num, matrixind, end;
  unsigned int total_tri_num;
d584 1
a584 1
    meshname[(int)(c++)] = 0;
d589 3
a591 3
    fread(&num, sizeof(int), 1, fh);
    if(endian) tienet_flip(&num, &num, sizeof(int));
    common_pack_write(app_data, app_ind, &num, sizeof(int));
d608 3
a610 3
      fread(&num, sizeof(int), 1, fh);
      if(endian) tienet_flip(&num, &num, sizeof(int));
      common_pack_write(app_data, app_ind, &num, sizeof(int));
d617 2
a618 2
        fread(face, 3*sizeof(int), n, fh);
        common_pack_write(app_data, app_ind, face, 3 * n * sizeof(int));
@


1.16
log
@adrt now uses a mesh map, no properties embedded in adrt file.  Transformation matrices being applied in unpack
again.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.15 2005/09/06 03:14:21 twingy Exp $
a587 9
    /* Texture/Properties Name */
#if 0
    fread(&c, sizeof(char), 1, fh);
    fread(texturename, sizeof(char), c, fh);
    texturename[(int)(c++)] = 0;
    common_pack_write(app_data, app_ind, &c, sizeof(char));
    common_pack_write(app_data, app_ind, texturename, c);
#endif

@


1.16.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d33 1
a33 1
 * $Id$
d169 3
d550 2
a551 2
  int matrixind;
  unsigned int face[144], marker_size, size, i, j, k, n, num, end, total_tri_num;
d584 1
d588 9
d598 3
a600 3
    fread(&num, sizeof(unsigned int), 1, fh);
    if(endian) tienet_flip(&num, &num, sizeof(unsigned int));
    common_pack_write(app_data, app_ind, &num, sizeof(unsigned int));
d617 3
a619 3
      fread(&num, sizeof(unsigned int), 1, fh);
      if(endian) tienet_flip(&num, &num, sizeof(unsigned int));
      common_pack_write(app_data, app_ind, &num, sizeof(unsigned int));
d626 2
a627 2
        fread(face, 3*sizeof(unsigned int), n, fh);
        common_pack_write(app_data, app_ind, face, 3 * n * sizeof(unsigned int));
d712 2
a714 1
  void *map;
d720 1
a720 1
  fh = fopen(filename, "rb");
d726 5
a730 3
  fseek(fh, 0, SEEK_END);
  size = ftell(fh);
  fseek(fh, 0, SEEK_SET);
d732 6
a737 4
  map = malloc(size);
  fread(map, size, 1, fh);
  common_pack_write(app_data, app_ind, map, size);
  free(map);
@


1.15
log
@removed prints
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.14 2005/09/06 03:13:54 twingy Exp $
d62 1
d118 4
d129 1
a129 1
  int marker, size;
d132 1
a132 1
  *app_ind += sizeof(int);
d141 2
a142 2
  size = *app_ind - marker - sizeof(int);
  common_pack_write(app_data, &marker, &size, sizeof(int));
d148 1
a148 1
  int marker, size;
d152 1
a152 1
  *app_ind += sizeof(int);
d156 1
a156 1
  common_pack_write(app_data, app_ind, &db->env.rm, sizeof(int));
d189 2
a190 2
  size = *app_ind - marker - sizeof(int);
  common_pack_write(app_data, &marker, &size, sizeof(int));
d200 1
a200 1
  int marker, size, prop_num;
d203 1
a203 1
  *app_ind += sizeof(int);
d207 1
a207 1
    printf("Properties file: %s does not exist, exiting...\n", filename);
d283 2
a284 2
  size = *app_ind - marker - sizeof(int);
  common_pack_write(app_data, &marker, &size, sizeof(int));
d293 1
a293 1
  int marker, size;
d297 1
a297 1
  *app_ind += sizeof(int);
d301 1
a301 1
    printf("Textures file: %s does not exist, exiting...\n", filename);
d409 1
a409 1
      common_pack_write(app_data, app_ind, &tile, sizeof(int));
d533 2
a534 2
  size = *app_ind - marker - sizeof(int);
  common_pack_write(app_data, &marker, &size, sizeof(int));
d556 1
a556 1
    printf("ADRT geometry file: %s does not exist, exiting...\n", filename);
d562 1
a562 1
  *app_ind += sizeof(int);
d589 1
d595 1
d667 2
a668 2
  size = *app_ind - marker_size - sizeof(int); /* make sure you're not counting the data size integer */
  common_pack_write(app_data, &marker_size, &size, sizeof(int));
d677 1
a677 1
  int marker, size;
d680 4
a683 1
  *app_ind += sizeof(int);
d687 2
a688 2
    size = *app_ind - marker - sizeof(int);
    common_pack_write(app_data, &marker, &size, sizeof(int));
d704 39
a742 2
  size = *app_ind - marker - sizeof(int);
  common_pack_write(app_data, &marker, &size, sizeof(int));
@


1.14
log
@total tri num stuff.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.13 2005/08/29 19:25:55 twingy Exp $
a569 1
printf("rev: %d\n", s);
a573 1
printf("total_tri_num: %d\n", total_tri_num);  
@


1.13
log
@kd-tree caching is now tuned to the point where full start-up time takes less than
1/4 the time as it did with the fast mid-split algorithm.  This number should approach
1/8 as the various parts of the packing/unpacking and caching algorithms are tuned
even further.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.12 2005/08/29 06:37:16 twingy Exp $
d544 3
a546 2
  short s, endian;
  int face[144], marker_size, marker_trinum, size, i, j, k, n, num, matrixind, end;
a558 4
  /* Marker for total number of triangles */
  marker_trinum = *app_ind;
  *app_ind += sizeof(int);

d565 1
a565 1
  fread(&endian, sizeof(short), 1, fh);
d569 7
a575 1
  fread(&s, sizeof(short), 1, fh);
a660 3
  /* pack the total number of triangles */
  common_pack_write(app_data, &marker_trinum, &common_pack_trinum, sizeof(int));

@


1.12
log
@Integrated kd-tree caching.
It's generated with adrt_bench by supplying the -c argument.
kdtree_cache_file,kdtree.cache goes into project.env file to make it work.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.11 2005/07/28 00:28:29 twingy Exp $
d541 1
a541 1
  TIE_3 v;
d594 6
a599 4
    /* Pack Vertices */
    for(i = 0; i < num; i++) {
      fread(&v, sizeof(TIE_3), 1, fh);
      common_pack_write(app_data, app_ind, &v, sizeof(TIE_3));
@


1.11
log
@* Overall load time for all 8 nodes during startup is 25% faster.
* File size of adrt mesh is now 33% smaller.  It uses shortst when trinum
  of the mesh is under 64K triangles.
* Prep data to slaves is now multi-threaded (all slaves get data from
  master at the same time, heavy network load).
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.10 2005/07/20 18:37:05 twingy Exp $
d61 1
a61 1

d114 3
d665 33
@


1.10
log
@* Data on demand to nodes (~20% mem savings).
* tlist memory leak in unpack.c fixed.
* BSP Depth Visualization rendering method.
* Split Plane Coloring
* Testing more efficient BSP methods.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.9 2005/07/11 17:18:15 twingy Exp $
d542 1
a542 1
  int face[3], marker_size, marker_trinum, size, i, j, k, n, num, matrixind, end;
a597 4
    fread(&num, sizeof(int), 1, fh);
    if(endian) tienet_flip(&num, &num, sizeof(int));
    common_pack_write(app_data, app_ind, &num, sizeof(int));
    common_pack_trinum += num;
d599 34
a632 4
    /* Pack Faces */
    for(i = 0; i < num; i++) {
      fread(face, sizeof(int), 3, fh);
      common_pack_write(app_data, app_ind, face, sizeof(int) * 3);
@


1.9
log
@char c to unsigned char c to allow for strings 255 chars long, not 127.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.8 2005/07/02 07:59:00 twingy Exp $
a122 2
  s = COMMON_PACK_CAMERA;
  common_pack_write(app_data, app_ind, &s, sizeof(short));
a125 1

d140 1
a141 2
  int marker, size;

a142 2
  s = COMMON_PACK_ENV;
  common_pack_write(app_data, app_ind, &s, sizeof(short));
a145 1

a189 1
  short s;
a193 3

  s = COMMON_PACK_PROP;
  common_pack_write(app_data, app_ind, &s, sizeof(short));
a196 1

d285 1
a286 2
  int marker, size;

a287 2
  s = COMMON_PACK_TEXTURE;
  common_pack_write(app_data, app_ind, &s, sizeof(short));
a290 1

a550 3
  s = COMMON_PACK_MESH;
  common_pack_write(app_data, app_ind, &s, sizeof(short));

@


1.9.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.11 2005/07/28 00:28:29 twingy Exp $
d123 2
d128 1
d143 1
a144 1
  short s;
d146 3
d152 1
d197 1
d202 3
d208 1
d297 1
a298 1
  short s;
d300 3
d306 1
d558 1
a558 1
  int face[144], marker_size, marker_trinum, size, i, j, k, n, num, matrixind, end;
d567 3
d617 4
d622 4
a625 34
    /* Short or Int used for face indices */
    fread(&c, 1, 1, fh);
    common_pack_write(app_data, app_ind, &c, 1);

    if(c) {
      fread(&num, sizeof(int), 1, fh);
      if(endian) tienet_flip(&num, &num, sizeof(int));
      common_pack_write(app_data, app_ind, &num, sizeof(int));
      common_pack_trinum += num;

      /* Pack Faces */
      i = 0;
      while(i < num) {
        n = num - i > 48 ? 48 : num - i;
        fread(face, 3*sizeof(int), n, fh);
        common_pack_write(app_data, app_ind, face, 3 * n * sizeof(int));
        i += n;
      }
    } else {
      unsigned short snum, sface[144];

      fread(&snum, sizeof(unsigned short), 1, fh);
      if(endian) tienet_flip(&snum, &snum, sizeof(unsigned short));
      common_pack_write(app_data, app_ind, &snum, sizeof(unsigned short));
      common_pack_trinum += snum;

      /* Pack Faces */
      i = 0;
      while(i < snum) {
        n = snum - i > 48 ? 48 : snum - i;
        fread(sface, 3*sizeof(unsigned short), n, fh);
        common_pack_write(app_data, app_ind, sface, 3 * n * sizeof(unsigned short));
        i += n;
      }
@


1.8
log
@igvt is functional again, still needs further testing and a few optimizations
I'm to tired to apply right now.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.7 2005/07/01 21:07:54 twingy Exp $
d198 2
a199 1
  char c, line[256], name[256], *token;
d295 2
a296 1
  char c, line[256], *token;
d555 2
a556 1
  char c, meshname[256], texturename[256];
@


1.7
log
@Moved the g loader int adrt to a converter in brl-cad.  The converter creates
all the necessary files that adrt needs to use geometry.  Going to fix unpack
next so the program is usable again.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.6 2005/07/01 15:13:02 twingy Exp $
d71 1
a71 1
/*
a77 1
*/
d555 1
a555 1
  int face[3], marker, size, i, j, k, n, num, matrixind, end;
d567 6
a572 2
  /* Size of mesh data */
  marker = *app_ind;
a587 3
    s = COMMON_PACK_MESH_NEW;
    common_pack_write(app_data, app_ind, &s, sizeof(short));

d643 8
a650 3
  size = *app_ind - marker;
  common_pack_write(app_data, &marker, &size, sizeof(int));
  *app_ind = marker + size;
@


1.6
log
@The project directory now has a single project file that lists the file names
for properties, textures, frames, geometry, and geometry arguments.  The
application no longer requires the -g and -a options.  IGVT has been updated
to reflect these changes, RISE is next.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.5 2005/06/18 21:58:46 twingy Exp $
a44 1
#include "g.h"
d59 1
a59 1
void	common_pack_mesh(common_db_t *db, void **app_data, int *app_ind, char *filename, char *args);
d71 1
a71 1

d77 2
a78 2
  memcpy(&(((char*)*dest)[*ind]), src, size);

d113 1
a113 1
  common_pack_mesh(db, app_data, &app_ind, db->env.geometry_file, db->env.geometry_file_args);
d546 2
a547 8
void common_pack_mesh(common_db_t *db, void **app_data, int *app_ind, char *filename, char *args) {
  if(strstr(filename, ".db")) {
    common_pack_mesh_adrt(db, app_data, app_ind, filename);
  } else if(strstr(filename, ".g")) {
    common_pack_g(app_data, app_ind, filename, args);
  } else {
    printf("unknown file format\n");
  }
d552 5
a556 5
  FILE		*fh;
  TIE_3		v[3], tv[3], min, max;
  char		c, meshname[256], texturename[256];
  short		s, endian;
  int		marker, tri_marker, size, i, j, k, n, num, matrixind, end;
d559 6
a571 12
  /* Number of triangles */
  tri_marker = *app_ind;
  *app_ind += sizeof(int);


  fh = fopen(filename, "rb");
  if(!fh) {
    printf("ADRT geometry file: %s does not exist, exiting...\n", filename);
    exit(1);
  }


d581 2
d602 12
a613 1
    /* Triangle Num */
d619 6
a630 49
    for(i = 0; i < num; i++) {
      /* Smooth Triangle */
      fread(&c, sizeof(char), 1, fh);
      common_pack_write(app_data, app_ind, &c, sizeof(char));

      /* Read 3 Verts */
      fread(v, sizeof(TIE_3), 3, fh);
      if(endian)
        for(j = 0; j < 3; j++)
          for(k = 0; k < 3; k++)
            tienet_flip(&v[j].v[k], &v[j].v[k], sizeof(tfloat));

      /* Apply transformation */
      if(matrixind >= 0)
        for(n = 0; n < 3; n++) {
          math_vec_transform(tv[n], v[n], db->anim.frame_list[0].tlist[matrixind].matrix);
          v[n] = tv[n];
        }
      common_pack_write(app_data, app_ind, v, sizeof(TIE_3)*3);

      /* Smooth Normals */
      if(c) {
        fread(v, sizeof(TIE_3), 3, fh);
        if(tienet_endian)
          for(j = 0; j < 3; j++)
            for(k = 0; k < 3; k++)
              tienet_flip(&v[j].v[k], &v[j].v[k], sizeof(tfloat));
        common_pack_write(app_data, app_ind, v, sizeof(TIE_3)*3);
      }

      /* Find min and max for mesh */
      if (!i) {
        min = v[0];
        max = v[0];
      }

      math_vec_min(min, v[0]);
      math_vec_min(min, v[1]);
      math_vec_min(min, v[2]);

      math_vec_max(max, v[0]);
      math_vec_max(max, v[1]);
      math_vec_max(max, v[2]);
    }

    /* Write min and max for mesh */
    common_pack_write(app_data, app_ind, &min, sizeof(TIE_3));
    common_pack_write(app_data, app_ind, &max, sizeof(TIE_3));

d635 1
a635 1
      tfloat	matrix[16];
d643 1
a643 1
  size = *app_ind - marker - sizeof(int);
d645 1
a645 2
  common_pack_write(app_data, &tri_marker, &common_pack_trinum, sizeof(int));
  *app_ind = marker + sizeof(int) + size;
@


1.5
log
@Added licensing info to libtexture files.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.4 2005/06/18 06:40:40 twingy Exp $
d54 1
a54 1
int	common_pack(common_db_t *db, void **app_data, char *proj, char *geom_file, char *args);
d84 1
a84 2
int common_pack(common_db_t *db, void **app_data, char *proj, char *geom_file, char *args) {
  char path[256];
d86 1
a86 1
  int app_ind;
a90 7
  /* Parse path out of proj and chdir to it */
  strcpy(path, proj);
  if(proj[strlen(proj)-1] != '/')
    strcat(path, "/");

  chdir(path);

d101 3
a106 3
  /* ENVIRONMENT DATA */
  common_pack_env(db, app_data, &app_ind);

d108 1
a108 1
  common_pack_prop(app_data, &app_ind, "properties.db");
d111 1
a111 1
  common_pack_texture(app_data, &app_ind, "texture.db");
d114 1
a114 1
  common_pack_mesh(db, app_data, &app_ind, geom_file, args);
d211 5
d308 4
d579 6
@


1.4
log
@
fixing linking problems to get adrt to properly link to brlcad.
@
text
@d33 1
a33 5
 * $Id: pack.c,v 1.3 2005/06/18 01:56:30 twingy Exp $
 */

/*
 * $Id: pack.c,v 1.3 2005/06/18 01:56:30 twingy Exp $
d42 1
a42 1
#include "texture_includes.h"
@


1.3
log
@Added licensing info to libcommon files.
@
text
@d33 1
a33 1
 * $Id: pack.c,v 1.2 2005/06/18 01:30:04 twingy Exp $
d37 1
a37 1
 * $Id: pack.c,v 1.2 2005/06/17 21:40:58 erikgreenwald Exp $
d49 1
a49 3
#if HAVE_BRLCAD
  #include "g.h"
#endif
a552 1
#if HAVE_BRLCAD
a554 1
#endif
@


1.2
log
@use brlcad_config.h instead of config.h
@
text
@d1 35
d37 1
a37 1
 * $Id: pack.c,v 1.1 2005/06/17 15:09:26 lbutler Exp $
@


1.1
log
@Welcome ADRT
@
text
@d2 1
a2 1
 * $Id: pack.c,v 1.4 2005/06/15 22:03:12 justin Exp $
d13 1
a13 1
#include "config.h"
@

