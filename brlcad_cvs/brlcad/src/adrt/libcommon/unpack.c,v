head	1.36;
access;
symbols
	rel-7-10-4:1.34
	STABLE:1.34.0.2
	rel-7-10-2:1.33
	rel-7-10-0:1.33
	rel-7-8-4:1.25
	rel-7-8-2:1.25
	rel-7-8-0:1.25
	trimnurbs-branch:1.25.0.2
	help:1.25
	temp_tag:1.24
	bobWinPort-20051223-freeze:1.11
	postmerge-20051223-bobWinPort:1.24
	premerge-20051223-bobWinPort:1.24
	rel-7-6-6:1.24
	rel-7-6-4:1.23
	rel-7-6-2:1.15
	rel-7-6-branch:1.15.0.2
	rel-7-6-0:1.15
	rel-7-4-2:1.7.2.1
	rel-7-4-branch:1.7.0.2
	bobWinPort:1.11.0.2
	rel-7-4-0:1.7;
locks; strict;
comment	@ * @;


1.36
date	2007.12.06.20.18.55;	author erikgreenwald;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.29.21.55.29;	author erikgreenwald;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.30.19.11.29;	author brlcad;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.20.20.05.06;	author brlcad;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.08.06.49.18;	author brlcad;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.02.19.46.34;	author erikgreenwald;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.27.01.41.30;	author brlcad;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.23.01.13.21;	author brlcad;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.21.00.51.04;	author brlcad;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.20.14.36.41;	author brlcad;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.18.22.17.57;	author erikgreenwald;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.18.06.46.11;	author brlcad;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.30.20.33.53;	author brlcad;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.21.16.16.15;	author twingy;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.21.02.15.01;	author twingy;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.21.00.03.07;	author twingy;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.20.20.29.21;	author twingy;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.13.23.13.29;	author twingy;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.13.22.21.37;	author twingy;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.09.03.31.08;	author twingy;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.08.21.58.43;	author twingy;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2005.09.06.03.13.54;	author twingy;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.29.19.25.55;	author twingy;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.29.06.37.16;	author twingy;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.29.21.40.07;	author twingy;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.28.00.28.29;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.27.17.43.58;	author twingy;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.20.18.37.06;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.11.17.18.15;	author twingy;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2005.07.02.22.14.32;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.02.07.59.00;	author twingy;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.01.21.07.54;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.18.21.58.46;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.18.01.56.30;	author twingy;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.17.15.09.26;	author lbutler;	state Exp;
branches;
next	;

1.7.2.1
date	2005.08.16.21.03.46;	author brlcad;	state Exp;
branches;
next	;

1.15.2.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.36
log
@plane is now cut
@
text
@/*                     U N P A C K . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file unpack.c
 *
 *  Common Library - Parsing and Packing Header
 *
 *  Author -
 *      Justin L. Shumaker
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 * $Id: unpack.c,v 1.35 2007/11/29 21:55:29 erikgreenwald Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "unpack.h"
#include "tienet.h"
#include "umath.h"

int prop_num;
common_unpack_prop_node_t *prop_list;

int texture_num;
common_unpack_texture_node_t *texture_list;

common_prop_t common_unpack_def_prop;

void	common_unpack(common_db_t *db, tie_t *tie, util_camera_t *camera, int socknum);
void	common_unpack_free(common_db_t *db);
void	common_unpack_camera(util_camera_t *camera, int socknum);
void	common_unpack_env(common_db_t *db, int socknum);
void	common_unpack_prop(int socknum);
void	common_unpack_texture(int socknum);
void	common_unpack_mesh(common_db_t *db, int socknum, tie_t *tie);
void	common_unpack_kdtree_cache(int socknum, tie_t *tie);
void	common_unpack_mesh_map(common_db_t *db, int socknum);
void	common_unpack_mesh_link(char *mesh_name, char *prop_name, common_db_t *db);
void	common_unpack_prop_lookup(char *name, common_prop_t **prop);
void	common_unpack_texture_lookup(char *name, texture_t **texture);


void common_unpack(common_db_t *db, tie_t *tie, util_camera_t *camera, int socknum) {
  int size;
  short ver, block;

  prop_num = 0;
  prop_list = NULL;
  texture_num = 0;
  texture_list = NULL;
  db->mesh_num = 0;
  db->mesh_list = NULL;

  /* Set default prop values */
  common_unpack_def_prop.color.v[0] = 0.8;
  common_unpack_def_prop.color.v[1] = 0.8;
  common_unpack_def_prop.color.v[2] = 0.8;
  common_unpack_def_prop.gloss = 0.2;
  common_unpack_def_prop.density = 0.5;
  common_unpack_def_prop.emission = 0.0;
  common_unpack_def_prop.ior = 1.0;

  /* Read in the size of the application data */
  tienet_recv(socknum, &size, sizeof(int), 0);

  /* Version */
  tienet_recv(socknum, &ver, sizeof(short), tienet_endian);

  /* Unpack Data */
  common_unpack_env(db, socknum);
  common_unpack_camera(camera, socknum);
  common_unpack_prop(socknum);
  common_unpack_texture(socknum);
  common_unpack_mesh(db, socknum, tie);
  common_unpack_kdtree_cache(socknum, tie);
  common_unpack_mesh_map(db, socknum);
}


void common_unpack_free(common_db_t *db) {
  int i;

  /* Free texture data */
  for(i = 0; i < texture_num; i++)
    texture_list[i].texture->free(texture_list[i].texture);
  free(texture_list);

  if (!db)
    return;

  /* Free mesh data */
  for(i = 0; i < db->mesh_num; i++) {
    /* Free triangle data */
    free(db->mesh_list[i]->tri_list);
    free(db->mesh_list[i]);
  }
  free(db->mesh_list);
}


void common_unpack_env(common_db_t *db, int socknum) {
  int ind, size;
  short block;

  /* size of environment data */
  tienet_recv(socknum, &size, sizeof(int), 0);

  ind = 0;
  do {
    tienet_recv(socknum, &block, sizeof(short), tienet_endian);
    ind += sizeof(short);
    switch(block) {
      case COMMON_PACK_ENV_RM:
	{
	  tienet_recv(socknum, &db->env.rm, sizeof(int), tienet_endian);
	  ind += sizeof(int);
	  switch(db->env.rm) {
	    case RENDER_METHOD_FLAT:
	      render_flat_init(&db->env.render);
	      break;

	    case RENDER_METHOD_NORMAL:
	      render_normal_init(&db->env.render);
	      break;

	    case RENDER_METHOD_PHONG:
	      render_phong_init(&db->env.render);
	      break;

	    case RENDER_METHOD_DEPTH:
	      render_depth_init(&db->env.render);
	      break;

	    case RENDER_METHOD_PATH:
	      {
		int samples;

		tienet_recv(socknum, &samples, sizeof(int), tienet_endian);
		ind += sizeof(int);
		render_path_init(&db->env.render, samples);
	      }
	      break;

	    case RENDER_METHOD_PLANE:
	      {
		TIE_3 ray_pos, ray_dir;

		tienet_recv(socknum, &ray_pos.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &ray_pos.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &ray_pos.v[2], sizeof(tfloat), tienet_endian);

		tienet_recv(socknum, &ray_dir.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &ray_dir.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &ray_dir.v[2], sizeof(tfloat), tienet_endian);

		ind += 6 * sizeof(tfloat);
		render_cut_init(&db->env.render, ray_pos, ray_dir);
	      }
	      break;

	    default:
	      break;
	  }
	}
	break;

      case COMMON_PACK_ENV_IMAGESIZE:
	{
	  tienet_recv(socknum, &db->env.img_w, sizeof(int), tienet_endian);
	  tienet_recv(socknum, &db->env.img_h, sizeof(int), tienet_endian);
	  tienet_recv(socknum, &db->env.img_hs, sizeof(int), tienet_endian);
	  ind += 3 * sizeof(int);
	}
	break;

      default:
	break;
    }
  } while(ind < size);
}


void common_unpack_camera(util_camera_t *camera, int socknum) {
  int size;

  /* size of camera data */
  tienet_recv(socknum, &size, sizeof(int), 0);

  /* POSITION */
  tienet_recv(socknum, &camera->pos.v[0], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->pos.v[1], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->pos.v[2], sizeof(tfloat), tienet_endian);

  /* FOCUS */
  tienet_recv(socknum, &camera->focus.v[0], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->focus.v[1], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->focus.v[2], sizeof(tfloat), tienet_endian);

  /* TILT */
  tienet_recv(socknum, &camera->tilt, sizeof(tfloat), tienet_endian);

  /* FIELD OF VIEW */
  tienet_recv(socknum, &camera->fov, sizeof(tfloat), tienet_endian);

  /* DEPTH OF FIELD */
  tienet_recv(socknum, &camera->dof, sizeof(tfloat), tienet_endian);
}


void common_unpack_prop(int socknum) {
  int ind, size;
  char c;

  /* size of property data */
  tienet_recv(socknum, &size, sizeof(int), 0);

  ind = 0;
  while(ind < size) {
    prop_num++;
    prop_list = (common_unpack_prop_node_t*)realloc(prop_list, sizeof(common_unpack_prop_node_t)*prop_num);

    /* property name */
    tienet_recv(socknum, &c, sizeof(char), 0);
    tienet_recv(socknum, prop_list[prop_num-1].name, c, 0);
    ind += c + 1;

    /* property data */
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[0], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[1], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[2], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.density, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.gloss, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.emission, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.ior, sizeof(tfloat), tienet_endian);
    ind += 7 * sizeof(tfloat);
  }
}


void common_unpack_texture(int socknum) {
  texture_t *stack = NULL, *texture = NULL;
  int ind, size;
  short block;
  unsigned char c;

  /* size of texture data */
  tienet_recv(socknum, &size, sizeof(int), 0);


  ind = 0;
  while(ind < size) {
    tienet_recv(socknum, &block, sizeof(short), tienet_endian);
    ind += sizeof(short);

    switch(block) {
      case TEXTURE_STACK:
	texture_num++;
	texture_list = (common_unpack_texture_node_t *)realloc(texture_list, sizeof(common_unpack_texture_node_t)*texture_num);

	texture_list[texture_num-1].texture = stack = (texture_t *)malloc(sizeof(texture_t));
	if (!texture_list[texture_num-1].texture) {
	    perror("texture_list[texture_num-1].texture");
	    exit(1);
	}
	texture_stack_init(stack);

	tienet_recv(socknum, &c, sizeof(char), 0);
	tienet_recv(socknum, texture_list[texture_num-1].name, c, 0);
	ind += c + 1;
	break;

      case TEXTURE_MIX:
	{
	  texture_t *texture1, *texture2;
	  char s1[64], s2[64];
	  tfloat coef;

	  texture_num++;
	  texture_list = (common_unpack_texture_node_t*)realloc(texture_list, sizeof(common_unpack_texture_node_t)*texture_num);
	  texture_list[texture_num-1].texture = (texture_t*)malloc(sizeof(texture_t));
	  if (!texture_list[texture_num-1].texture) {
	      perror("texture_list[texture_num-1].texture");
	      exit(1);
	  }
	  tienet_recv(socknum, &c, sizeof(char), 0);
	  tienet_recv(socknum, texture_list[texture_num-1].name, c, 0);
	  ind += c + c+1;
	  tienet_recv(socknum, &c, sizeof(char), 0);
	  tienet_recv(socknum, s1, c, 0);
	  ind += c + c+1;
	  tienet_recv(socknum, &c, sizeof(char), 0);
	  tienet_recv(socknum, s2, c, 0);
	  ind += c + c+1;
	  tienet_recv(socknum, &coef, sizeof(tfloat), tienet_endian);
	  ind += sizeof(tfloat);
	  common_unpack_texture_lookup(s1, &texture1);
	  common_unpack_texture_lookup(s2, &texture2);
	  texture_mix_init(texture_list[texture_num-1].texture, texture1, texture2, coef);
	}
	break;

      case TEXTURE_BLEND:
	{
	  TIE_3 color1, color2;

	  texture = (texture_t*)malloc(sizeof(texture_t));
	  if (!texture) {
	      perror("texture");
	      exit(1);
	  }
	  /* COLOR 1 */
	  tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
	  ind += 3 * sizeof(tfloat);
	  /* COLOR 2 */
	  tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
	  ind += 3 * sizeof(tfloat);
	  texture_blend_init(texture, color1, color2);
	  texture_stack_push(stack, texture);
	}
	break;

      case TEXTURE_BUMP:
	{
	  TIE_3 coef;

	  texture = (texture_t*)malloc(sizeof(texture_t));
	  if (!texture) {
	      perror("texture");
	      exit(1);
	  }
	  tienet_recv(socknum, &coef.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &coef.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &coef.v[2], sizeof(tfloat), tienet_endian);
	  ind += 3 * sizeof(tfloat);
	  texture_bump_init(texture, coef);
	  texture_stack_push(stack, texture);
	}
	break;

      case TEXTURE_CHECKER:
	{
	  int tile;

	  texture = (texture_t*)malloc(sizeof(texture_t));
	  if (!texture) {
	      perror("texture");
	      exit(1);
	  }
	  tienet_recv(socknum, &tile, sizeof(int), tienet_endian);
	  ind += sizeof(int);
	  texture_checker_init(texture, tile);
	  texture_stack_push(stack, texture);
	}
	break;

      case TEXTURE_CAMO:
	{
	  tfloat size;
	  int octaves, absolute;
	  TIE_3 color1, color2, color3;

	  texture = (texture_t*)malloc(sizeof(texture_t));
	  if (!texture) {
	      perror("texture");
	      exit(1);
	  }
	  tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &octaves, sizeof(int), tienet_endian);
	  tienet_recv(socknum, &absolute, sizeof(int), tienet_endian);
	  tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color3.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color3.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color3.v[2], sizeof(tfloat), tienet_endian);
	  ind += 10*sizeof(tfloat) + 2*sizeof(int);
	  texture_camo_init(texture, size, octaves, absolute, color1, color2, color3);
	  texture_stack_push(stack, texture);
	}
	break;

      case TEXTURE_CLOUDS:
	{
	  tfloat size;
	  int octaves, absolute;
	  TIE_3 scale, translate;

	  texture = (texture_t*)malloc(sizeof(texture_t));
	  if (!texture) {
	      perror("texture");
	      exit(1);
	  }
	  tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &octaves, sizeof(int), tienet_endian);
	  tienet_recv(socknum, &absolute, sizeof(int), tienet_endian);
	  tienet_recv(socknum, &scale.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &scale.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &scale.v[2], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &translate.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &translate.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &translate.v[2], sizeof(tfloat), tienet_endian);
	  ind += 7*sizeof(tfloat) + 2*sizeof(int);
	  texture_clouds_init(texture, size, octaves, absolute, scale, translate);
	  texture_stack_push(stack, texture);
	}
	break;

      case TEXTURE_IMAGE:
	{
	  short w, h;
	  unsigned char *image;

	  texture = (texture_t*)malloc(sizeof(texture_t));
	  if (!texture) {
	      perror("texture");
	      exit(1);
	  }
	  tienet_recv(socknum, &w, sizeof(short), tienet_endian);
	  tienet_recv(socknum, &h, sizeof(short), tienet_endian);
	  ind += 2*sizeof(short);
	  image = (unsigned char*)malloc(3*w*h);
	  if (!image) {
	      perror("image");
	      exit(1);
	  }
	  tienet_recv(socknum, image, 3*w*h, 0);
	  ind += 3*w*h;
	  texture_image_init(texture, w, h, image);
	  texture_stack_push(stack, texture);
	  free(image);
	}
	break;

      case TEXTURE_GRADIENT:
	{
	  int axis;

	  texture = (texture_t*)malloc(sizeof(texture_t));
	  if (!texture) {
	      perror("texture");
	      exit(1);
	  }
	  tienet_recv(socknum, &axis, sizeof(int), tienet_endian);
	  ind += sizeof(int);
	  texture_gradient_init(texture, axis);
	  texture_stack_push(stack, texture);
	}
	break;

      default:
	break;
    }
  }
}


void common_unpack_mesh(common_db_t *db, int socknum, tie_t *tie) {
  TIE_3 v[3], *vlist, *tlist;
  char name[256];
  unsigned char c;
  short block;
  unsigned int num, ind;
  int size, *flist, i, start, vnum, vmax, fnum, fmax;


  vlist = NULL;
  flist = NULL;
  tlist = NULL;
  vmax = 0;
  fmax = 0;

  /* size of mesh data */
  tienet_recv(socknum, &size, sizeof(int), 0);
  ind = 0;

  /* initialize tie with triangle number */
  tienet_recv(socknum, &num, sizeof(unsigned int), tienet_endian);
  tie_init(tie, num, TIE_KDTREE_FAST);
  ind += sizeof(unsigned int);

  while(ind < size) {
    /* Create a Mesh */
    db->mesh_num++;
    db->mesh_list = (common_mesh_t **)realloc(db->mesh_list, sizeof(common_mesh_t *)*db->mesh_num);
    db->mesh_list[db->mesh_num-1] = (common_mesh_t *)malloc(sizeof(common_mesh_t));
    if (!db->mesh_list[db->mesh_num-1]) {
	perror("db->mesh_list[db->mesh_num-1]");
	exit(1);
    }
    db->mesh_list[db->mesh_num-1]->flags = 0;
    db->mesh_list[db->mesh_num-1]->tri_num = 0;
    db->mesh_list[db->mesh_num-1]->tri_list = NULL;

    /* Mesh Name */
    tienet_recv(socknum, &c, sizeof(char), 0);
    tienet_recv(socknum, db->mesh_list[db->mesh_num-1]->name, c, 0);
    ind += c + 1;

    /* Vertices */
    tienet_recv(socknum, &vnum, sizeof(int), tienet_endian);
    ind += sizeof(int);
    if(vnum > vmax) {
      vmax = vnum;
      vlist = (TIE_3 *)realloc(vlist, vmax * sizeof(TIE_3));
    }
    tienet_recv(socknum, vlist, vnum * sizeof(TIE_3), 0);
    ind += vnum * sizeof(TIE_3);

    /* Faces */
    /* Determine short or int based indices */
    tienet_recv(socknum, &c, 1, 0);
    ind += 1;

    if(c) {
      tienet_recv(socknum, &fnum, sizeof(int), tienet_endian);
      ind += sizeof(int);

      if(fnum > fmax) {
	fmax = fnum;
	flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
	tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
      }
      tienet_recv(socknum, flist, fnum * 3 * sizeof(int), 0);
      ind += fnum * 3 * sizeof(int);
    } else {
      unsigned short sfnum, sind[144];
      int j, n;

      tienet_recv(socknum, &sfnum, sizeof(unsigned short), tienet_endian);
      ind += sizeof(unsigned short);

      fnum = sfnum;
      if(fnum > fmax) {
	fmax = fnum;
	flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
	tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
      }

      i = 0;
      while(i < fnum) {
	n = fnum - i > 48 ? 48 : fnum - i;
	tienet_recv(socknum, &sind, 3 * n * sizeof(unsigned short), 0);

	for(j = 0; j < n; j++) {
	  flist[3*(i+j) + 0] = sind[3*j + 0];
	  flist[3*(i+j) + 1] = sind[3*j + 1];
	  flist[3*(i+j) + 2] = sind[3*j + 2];
	}

	i += n;
      }

      ind += fnum * 3 * sizeof(unsigned short);
    }

    /* Min and Max */
#if 0
    for(j = 0; j < 3; j++)
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->min.v[j]), sizeof(tfloat), tienet_endian);
    for(j = 0; j < 3; j++)
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->max.v[j]), sizeof(tfloat), tienet_endian);
#endif

    /* Matrix */
    for(i = 0; i < 16; i++)
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->matrix[i]), sizeof(tfloat), tienet_endian);
    ind += 16 * sizeof(tfloat);

    /* Store inverted matrix */
    math_mat_invert(db->mesh_list[db->mesh_num-1]->matinv, db->mesh_list[db->mesh_num-1]->matrix, 4);

    /* Apply Transformation Matrix to Vertices */
    for(i = 0; i < vnum; i++) {
      v[0] = vlist[i];
      MATH_VEC_TRANSFORM(vlist[i], v[0], db->mesh_list[db->mesh_num-1]->matrix);
    }

    /* Allocate memory for ADRT triangles */
    db->mesh_list[db->mesh_num-1]->tri_num = fnum;
    db->mesh_list[db->mesh_num-1]->tri_list = (common_triangle_t *)malloc(fnum * sizeof(common_triangle_t));
    if (!db->mesh_list[db->mesh_num-1]->tri_list) {
	perror("db->mesh_list[db->mesh_num-1]->tri_list");
	exit(1);
    }

    /* Build the triangle list */
    for(i = 0; i < fnum; i++) {
      db->mesh_list[db->mesh_num-1]->tri_list[i].mesh = db->mesh_list[db->mesh_num-1];
      db->mesh_list[db->mesh_num-1]->tri_list[i].normals = NULL;
      tlist[i*3+0] = vlist[flist[3*i+0]];
      tlist[i*3+1] = vlist[flist[3*i+1]];
      tlist[i*3+2] = vlist[flist[3*i+2]];
    }

    /* ADD TRIANGLES TO TIE */
    tie_push(tie, &tlist, fnum, db->mesh_list[db->mesh_num-1]->tri_list, sizeof(common_triangle_t));
  }

  free(vlist);
  free(flist);
  free(tlist);
}


void common_unpack_kdtree_cache(int socknum, tie_t *tie) {
  int size;
  void *kdcache;

  /* size of kdtree cache data */
  tienet_recv(socknum, &size, sizeof(int), 0);

  /* retreive the data */
  if(size > 0) {
    kdcache = malloc(size);
    if (!kdcache) {
	perror("kdcache");
	exit(1);
    }
    tienet_recv(socknum, kdcache, size, 0);

    /* feed the kd-tree into libtie */
    tie_kdtree_cache_load(tie, kdcache, size);

    free(kdcache);
  }
}


void common_unpack_mesh_map(common_db_t *db, int socknum) {
  unsigned int size, ind;
  unsigned char c;
  char mesh_name[256], prop_name[256];

  /* size of mesh data */
  tienet_recv(socknum, &size, sizeof(unsigned int), 0);
  ind = 0;

  while(ind < size) {
    tienet_recv(socknum, &c, 1, 0);
    tienet_recv(socknum, mesh_name, c, 0);
    ind += 1 + c;

    tienet_recv(socknum, &c, 1, 0);
    tienet_recv(socknum, prop_name, c, 0);
    ind += 1 + c;

    /* Link a property and texture to a mesh */
    common_unpack_mesh_link(mesh_name, prop_name, db);
  }
}


void common_unpack_mesh_link(char *mesh_name, char *prop_name, common_db_t *db) {
  unsigned int i;


  for(i = 0; i < db->mesh_num; i++) {
    /* Find Mesh */
    if(!strcmp(mesh_name, db->mesh_list[i]->name)) {
      common_unpack_prop_lookup(prop_name, &(db->mesh_list[i]->prop));
      db->mesh_list[i]->texture = NULL;
      return;
    }
  }
}


void common_unpack_prop_lookup(char *name, common_prop_t **prop) {
  unsigned int i;

  for(i = 0; i < prop_num; i++)
    if(!strcmp(name, prop_list[i].name)) {
/*       printf("*** FOUND FOR: -%s-\n", name); */
      *prop = &prop_list[i].prop;
      return;
    }

/*  printf("PROPERTIES NOT FOUND FOR: -%s-\n", name); */
  *prop = &common_unpack_def_prop;
}


void common_unpack_texture_lookup(char *name, texture_t **texture) {
  unsigned int i;

  for(i = 0; i < texture_num; i++)
    if(!strcmp(name, texture_list[i].name)) {
      *texture = texture_list[i].texture;
      return;
    }

  *texture = NULL;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.35
log
@update the tie_init() calls with the new parm
@
text
@d31 1
a31 1
 * $Id: unpack.c,v 1.34 2007/08/30 19:11:29 brlcad Exp $
d178 1
a178 1
		render_plane_init(&db->env.render, ray_pos, ray_dir);
@


1.34
log
@TFLOAT changed to tfloat.  also quell a few warnings/bugs related to passing the wrong TIE_3 pointer type.
@
text
@d31 1
a31 1
 * $Id: unpack.c,v 1.33 2007/03/20 20:05:06 brlcad Exp $
d506 1
a506 1
  tie_init(tie, num);
@


1.33
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d31 1
a31 1
 * $Id: unpack.c,v 1.32 2007/02/08 06:49:18 brlcad Exp $
d169 7
a175 7
		tienet_recv(socknum, &ray_pos.v[0], sizeof(TFLOAT), tienet_endian);
		tienet_recv(socknum, &ray_pos.v[1], sizeof(TFLOAT), tienet_endian);
		tienet_recv(socknum, &ray_pos.v[2], sizeof(TFLOAT), tienet_endian);

		tienet_recv(socknum, &ray_dir.v[0], sizeof(TFLOAT), tienet_endian);
		tienet_recv(socknum, &ray_dir.v[1], sizeof(TFLOAT), tienet_endian);
		tienet_recv(socknum, &ray_dir.v[2], sizeof(TFLOAT), tienet_endian);
d177 1
a177 1
		ind += 6 * sizeof(TFLOAT);
d211 3
a213 3
  tienet_recv(socknum, &camera->pos.v[0], sizeof(TFLOAT), tienet_endian);
  tienet_recv(socknum, &camera->pos.v[1], sizeof(TFLOAT), tienet_endian);
  tienet_recv(socknum, &camera->pos.v[2], sizeof(TFLOAT), tienet_endian);
d216 3
a218 3
  tienet_recv(socknum, &camera->focus.v[0], sizeof(TFLOAT), tienet_endian);
  tienet_recv(socknum, &camera->focus.v[1], sizeof(TFLOAT), tienet_endian);
  tienet_recv(socknum, &camera->focus.v[2], sizeof(TFLOAT), tienet_endian);
d221 1
a221 1
  tienet_recv(socknum, &camera->tilt, sizeof(TFLOAT), tienet_endian);
d224 1
a224 1
  tienet_recv(socknum, &camera->fov, sizeof(TFLOAT), tienet_endian);
d227 1
a227 1
  tienet_recv(socknum, &camera->dof, sizeof(TFLOAT), tienet_endian);
d249 8
a256 8
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[0], sizeof(TFLOAT), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[1], sizeof(TFLOAT), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[2], sizeof(TFLOAT), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.density, sizeof(TFLOAT), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.gloss, sizeof(TFLOAT), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.emission, sizeof(TFLOAT), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.ior, sizeof(TFLOAT), tienet_endian);
    ind += 7 * sizeof(TFLOAT);
d297 1
a297 1
	  TFLOAT coef;
d315 2
a316 2
	  tienet_recv(socknum, &coef, sizeof(TFLOAT), tienet_endian);
	  ind += sizeof(TFLOAT);
d333 4
a336 4
	  tienet_recv(socknum, &color1.v[0], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color1.v[1], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color1.v[2], sizeof(TFLOAT), tienet_endian);
	  ind += 3 * sizeof(TFLOAT);
d338 4
a341 4
	  tienet_recv(socknum, &color2.v[0], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color2.v[1], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color2.v[2], sizeof(TFLOAT), tienet_endian);
	  ind += 3 * sizeof(TFLOAT);
d356 4
a359 4
	  tienet_recv(socknum, &coef.v[0], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &coef.v[1], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &coef.v[2], sizeof(TFLOAT), tienet_endian);
	  ind += 3 * sizeof(TFLOAT);
d383 1
a383 1
	  TFLOAT size;
d392 1
a392 1
	  tienet_recv(socknum, &size, sizeof(TFLOAT), tienet_endian);
d395 10
a404 10
	  tienet_recv(socknum, &color1.v[0], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color1.v[1], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color1.v[2], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color2.v[0], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color2.v[1], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color2.v[2], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color3.v[0], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color3.v[1], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &color3.v[2], sizeof(TFLOAT), tienet_endian);
	  ind += 10*sizeof(TFLOAT) + 2*sizeof(int);
d412 1
a412 1
	  TFLOAT size;
d421 1
a421 1
	  tienet_recv(socknum, &size, sizeof(TFLOAT), tienet_endian);
d424 7
a430 7
	  tienet_recv(socknum, &scale.v[0], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &scale.v[1], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &scale.v[2], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &translate.v[0], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &translate.v[1], sizeof(TFLOAT), tienet_endian);
	  tienet_recv(socknum, &translate.v[2], sizeof(TFLOAT), tienet_endian);
	  ind += 7*sizeof(TFLOAT) + 2*sizeof(int);
d587 1
a587 1
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->min.v[j]), sizeof(TFLOAT), tienet_endian);
d589 1
a589 1
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->max.v[j]), sizeof(TFLOAT), tienet_endian);
d594 2
a595 2
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->matrix[i]), sizeof(TFLOAT), tienet_endian);
    ind += 16 * sizeof(TFLOAT);
d624 1
a624 1
    tie_push(tie, tlist, fnum, db->mesh_list[db->mesh_num-1]->tri_list, sizeof(common_triangle_t));
d650 1
a650 1
    tie_kdtree_cache_load(tie, kdcache);
@


1.32
log
@give adrt some distinctiveness in the header
@
text
@d31 1
a31 1
 * $Id: unpack.c,v 1.31 2007/02/02 19:46:34 erikgreenwald Exp $
d282 4
d302 4
d328 4
d352 4
d370 4
d388 4
d417 4
d442 4
d450 4
d467 4
d514 4
d609 4
d643 4
@


1.31
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
d31 1
a31 1
 * $Id: unpack.c,v 1.30 2007/01/27 01:41:30 brlcad Exp $
@


1.30
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d31 1
a31 1
 * $Id: unpack.c,v 1.29 2007/01/23 01:13:21 brlcad Exp $
d169 7
a175 7
		tienet_recv(socknum, &ray_pos.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &ray_pos.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &ray_pos.v[2], sizeof(tfloat), tienet_endian);

		tienet_recv(socknum, &ray_dir.v[0], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &ray_dir.v[1], sizeof(tfloat), tienet_endian);
		tienet_recv(socknum, &ray_dir.v[2], sizeof(tfloat), tienet_endian);
d177 1
a177 1
		ind += 6 * sizeof(tfloat);
d211 3
a213 3
  tienet_recv(socknum, &camera->pos.v[0], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->pos.v[1], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->pos.v[2], sizeof(tfloat), tienet_endian);
d216 3
a218 3
  tienet_recv(socknum, &camera->focus.v[0], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->focus.v[1], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->focus.v[2], sizeof(tfloat), tienet_endian);
d221 1
a221 1
  tienet_recv(socknum, &camera->tilt, sizeof(tfloat), tienet_endian);
d224 1
a224 1
  tienet_recv(socknum, &camera->fov, sizeof(tfloat), tienet_endian);
d227 1
a227 1
  tienet_recv(socknum, &camera->dof, sizeof(tfloat), tienet_endian);
d249 8
a256 8
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[0], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[1], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[2], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.density, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.gloss, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.emission, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.ior, sizeof(tfloat), tienet_endian);
    ind += 7 * sizeof(tfloat);
d293 1
a293 1
	  tfloat coef;
d307 2
a308 2
	  tienet_recv(socknum, &coef, sizeof(tfloat), tienet_endian);
	  ind += sizeof(tfloat);
d321 4
a324 4
	  tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
	  ind += 3 * sizeof(tfloat);
d326 4
a329 4
	  tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
	  ind += 3 * sizeof(tfloat);
d340 4
a343 4
	  tienet_recv(socknum, &coef.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &coef.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &coef.v[2], sizeof(tfloat), tienet_endian);
	  ind += 3 * sizeof(tfloat);
d363 1
a363 1
	  tfloat size;
d368 1
a368 1
	  tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
d371 10
a380 10
	  tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color3.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color3.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &color3.v[2], sizeof(tfloat), tienet_endian);
	  ind += 10*sizeof(tfloat) + 2*sizeof(int);
d388 1
a388 1
	  tfloat size;
d393 1
a393 1
	  tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
d396 7
a402 7
	  tienet_recv(socknum, &scale.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &scale.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &scale.v[2], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &translate.v[0], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &translate.v[1], sizeof(tfloat), tienet_endian);
	  tienet_recv(socknum, &translate.v[2], sizeof(tfloat), tienet_endian);
	  ind += 7*sizeof(tfloat) + 2*sizeof(int);
d543 1
a543 1
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->min.v[j]), sizeof(tfloat), tienet_endian);
d545 1
a545 1
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->max.v[j]), sizeof(tfloat), tienet_endian);
d550 2
a551 2
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->matrix[i]), sizeof(tfloat), tienet_endian);
    ind += 16 * sizeof(tfloat);
@


1.29
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d31 1
a31 1
 * $Id: unpack.c,v 1.28 2007/01/21 00:51:04 brlcad Exp $
d135 52
a186 52
        {
          tienet_recv(socknum, &db->env.rm, sizeof(int), tienet_endian);
          ind += sizeof(int);
          switch(db->env.rm) {
            case RENDER_METHOD_FLAT:
              render_flat_init(&db->env.render);
              break;

            case RENDER_METHOD_NORMAL:
              render_normal_init(&db->env.render);
              break;

            case RENDER_METHOD_PHONG:
              render_phong_init(&db->env.render);
              break;

            case RENDER_METHOD_DEPTH:
              render_depth_init(&db->env.render);
              break;

            case RENDER_METHOD_PATH:
              {
                int samples;

                tienet_recv(socknum, &samples, sizeof(int), tienet_endian);
                ind += sizeof(int);
                render_path_init(&db->env.render, samples);
              }
              break;

            case RENDER_METHOD_PLANE:
              {
                TIE_3 ray_pos, ray_dir;

                tienet_recv(socknum, &ray_pos.v[0], sizeof(tfloat), tienet_endian);
                tienet_recv(socknum, &ray_pos.v[1], sizeof(tfloat), tienet_endian);
                tienet_recv(socknum, &ray_pos.v[2], sizeof(tfloat), tienet_endian);

                tienet_recv(socknum, &ray_dir.v[0], sizeof(tfloat), tienet_endian);
                tienet_recv(socknum, &ray_dir.v[1], sizeof(tfloat), tienet_endian);
                tienet_recv(socknum, &ray_dir.v[2], sizeof(tfloat), tienet_endian);

                ind += 6 * sizeof(tfloat);
                render_plane_init(&db->env.render, ray_pos, ray_dir);
              }
              break;

            default:
              break;
          }
        }
        break;
d189 7
a195 7
        {
          tienet_recv(socknum, &db->env.img_w, sizeof(int), tienet_endian);
          tienet_recv(socknum, &db->env.img_h, sizeof(int), tienet_endian);
          tienet_recv(socknum, &db->env.img_hs, sizeof(int), tienet_endian);
          ind += 3 * sizeof(int);
        }
        break;
d198 1
a198 1
        break;
d278 2
a279 2
        texture_num++;
        texture_list = (common_unpack_texture_node_t *)realloc(texture_list, sizeof(common_unpack_texture_node_t)*texture_num);
d281 2
a282 2
        texture_list[texture_num-1].texture = stack = (texture_t *)malloc(sizeof(texture_t));
        texture_stack_init(stack);
d284 4
a287 4
        tienet_recv(socknum, &c, sizeof(char), 0);
        tienet_recv(socknum, texture_list[texture_num-1].name, c, 0);
        ind += c + 1;
        break;
d290 24
a313 24
        {
          texture_t *texture1, *texture2;
          char s1[64], s2[64];
          tfloat coef;

          texture_num++;
          texture_list = (common_unpack_texture_node_t*)realloc(texture_list, sizeof(common_unpack_texture_node_t)*texture_num);
          texture_list[texture_num-1].texture = (texture_t*)malloc(sizeof(texture_t));
          tienet_recv(socknum, &c, sizeof(char), 0);
          tienet_recv(socknum, texture_list[texture_num-1].name, c, 0);
          ind += c + c+1;
          tienet_recv(socknum, &c, sizeof(char), 0);
          tienet_recv(socknum, s1, c, 0);
          ind += c + c+1;
          tienet_recv(socknum, &c, sizeof(char), 0);
          tienet_recv(socknum, s2, c, 0);
          ind += c + c+1;
          tienet_recv(socknum, &coef, sizeof(tfloat), tienet_endian);
          ind += sizeof(tfloat);
          common_unpack_texture_lookup(s1, &texture1);
          common_unpack_texture_lookup(s2, &texture2);
          texture_mix_init(texture_list[texture_num-1].texture, texture1, texture2, coef);
        }
        break;
d316 2
a317 2
        {
          TIE_3 color1, color2;
d319 15
a333 15
          texture = (texture_t*)malloc(sizeof(texture_t));
          /* COLOR 1 */
          tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
          ind += 3 * sizeof(tfloat);
          /* COLOR 2 */
          tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
          ind += 3 * sizeof(tfloat);
          texture_blend_init(texture, color1, color2);
          texture_stack_push(stack, texture);
        }
        break;
d336 2
a337 2
        {
          TIE_3 coef;
d339 9
a347 9
          texture = (texture_t*)malloc(sizeof(texture_t));
          tienet_recv(socknum, &coef.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &coef.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &coef.v[2], sizeof(tfloat), tienet_endian);
          ind += 3 * sizeof(tfloat);
          texture_bump_init(texture, coef);
          texture_stack_push(stack, texture);
        }
        break;
d350 2
a351 2
        {
          int tile;
d353 7
a359 7
          texture = (texture_t*)malloc(sizeof(texture_t));
          tienet_recv(socknum, &tile, sizeof(int), tienet_endian);
          ind += sizeof(int);
          texture_checker_init(texture, tile);
          texture_stack_push(stack, texture);
        }
        break;
d362 23
a384 23
        {
          tfloat size;
          int octaves, absolute;
          TIE_3 color1, color2, color3;

          texture = (texture_t*)malloc(sizeof(texture_t));
          tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &octaves, sizeof(int), tienet_endian);
          tienet_recv(socknum, &absolute, sizeof(int), tienet_endian);
          tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color3.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color3.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color3.v[2], sizeof(tfloat), tienet_endian);
          ind += 10*sizeof(tfloat) + 2*sizeof(int);
          texture_camo_init(texture, size, octaves, absolute, color1, color2, color3);
          texture_stack_push(stack, texture);
        }
        break;
d387 20
a406 20
        {
          tfloat size;
          int octaves, absolute;
          TIE_3 scale, translate;

          texture = (texture_t*)malloc(sizeof(texture_t));
          tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &octaves, sizeof(int), tienet_endian);
          tienet_recv(socknum, &absolute, sizeof(int), tienet_endian);
          tienet_recv(socknum, &scale.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &scale.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &scale.v[2], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &translate.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &translate.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &translate.v[2], sizeof(tfloat), tienet_endian);
          ind += 7*sizeof(tfloat) + 2*sizeof(int);
          texture_clouds_init(texture, size, octaves, absolute, scale, translate);
          texture_stack_push(stack, texture);
        }
        break;
d409 16
a424 16
        {
          short w, h;
          unsigned char *image;

          texture = (texture_t*)malloc(sizeof(texture_t));
          tienet_recv(socknum, &w, sizeof(short), tienet_endian);
          tienet_recv(socknum, &h, sizeof(short), tienet_endian);
          ind += 2*sizeof(short);
          image = (unsigned char*)malloc(3*w*h);
          tienet_recv(socknum, image, 3*w*h, 0);
          ind += 3*w*h;
          texture_image_init(texture, w, h, image);
          texture_stack_push(stack, texture);
          free(image);
        }
        break;
d427 2
a428 2
        {
          int axis;
d430 7
a436 7
          texture = (texture_t*)malloc(sizeof(texture_t));
          tienet_recv(socknum, &axis, sizeof(int), tienet_endian);
          ind += sizeof(int);
          texture_gradient_init(texture, axis);
          texture_stack_push(stack, texture);
        }
        break;
d439 1
a439 1
        break;
d503 3
a505 3
        fmax = fnum;
        flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
        tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
d518 3
a520 3
        fmax = fnum;
        flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
        tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
d525 2
a526 2
        n = fnum - i > 48 ? 48 : fnum - i;
        tienet_recv(socknum, &sind, 3 * n * sizeof(unsigned short), 0);
d528 5
a532 5
        for(j = 0; j < n; j++) {
          flist[3*(i+j) + 0] = sind[3*j + 0];
          flist[3*(i+j) + 1] = sind[3*j + 1];
          flist[3*(i+j) + 2] = sind[3*j + 2];
        }
d534 1
a534 1
        i += n;
@


1.28
log
@standard header and footer cleanup
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d31 1
a31 1
 * $Id: unpack.c,v 1.27 2007/01/20 14:36:41 brlcad Exp $
@


1.27
log
@update copyright to 2007
@
text
@a21 1
 *                     U N P A C K . C
d32 1
a32 1
 * $Id: unpack.c,v 1.26 2007/01/18 22:17:57 erikgreenwald Exp $
d671 10
@


1.26
log
@uppercase all #define symbols
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2006 United States Government as represented by
d33 1
a33 1
 * $Id: unpack.c,v 1.25 2006/01/18 06:46:11 brlcad Exp $
@


1.25
log
@update copyright to 2006
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.24 2005/11/30 20:33:53 brlcad Exp $
d561 1
a561 1
      math_vec_transform(vlist[i], v[0], db->mesh_list[db->mesh_num-1]->matrix);
@


1.24
log
@make sure db is a valid pointer so common_unpack_free doesn't crash
@
text
@d4 1
a4 1
 * Copyright (C) 2002-2005 United States Government as represented by
d33 1
a33 1
 * $Id: unpack.c,v 1.23 2005/10/23 04:44:28 brlcad Exp $
@


1.23
log
@trailing ws
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.22 2005/09/21 16:16:15 twingy Exp $
d111 3
@


1.22
log
@reverted
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.20 2005/09/21 00:03:07 twingy Exp $
d268 1
a268 1
  
@


1.21
log
@librender is now libvis, render method terminology becomes visualization method or vis
method for short.
@
text
@d135 1
a135 1
          tienet_recv(socknum, &db->env.vm, sizeof(int), tienet_endian);
d137 3
a139 3
          switch(db->env.vm) {
            case VM_FLAT:
              vis_flat_init(&db->env.vis);
d142 2
a143 2
            case VM_NORMAL:
              vis_normal_init(&db->env.vis);
d146 2
a147 2
            case VM_PHONG:
              vis_phong_init(&db->env.vis);
d150 2
a151 2
            case VM_DEPTH:
              vis_depth_init(&db->env.vis);
d154 1
a154 1
            case VM_PATH:
d160 1
a160 1
                vis_path_init(&db->env.vis, samples);
d164 1
a164 1
            case VM_PLANE:
d177 1
a177 1
                vis_plane_init(&db->env.vis, ray_pos, ray_dir);
@


1.20
log
@*** empty log message ***
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.19 2005/09/20 20:29:21 twingy Exp $
d135 1
a135 1
          tienet_recv(socknum, &db->env.rm, sizeof(int), tienet_endian);
d137 3
a139 3
          switch(db->env.rm) {
            case RENDER_METHOD_FLAT:
              render_flat_init(&db->env.render);
d142 2
a143 2
            case RENDER_METHOD_NORMAL:
              render_normal_init(&db->env.render);
d146 2
a147 2
            case RENDER_METHOD_PHONG:
              render_phong_init(&db->env.render);
d150 2
a151 2
            case RENDER_METHOD_DEPTH:
              render_depth_init(&db->env.render);
d154 1
a154 1
            case RENDER_METHOD_PATH:
d160 1
a160 1
                render_path_init(&db->env.render, samples);
d164 1
a164 1
            case RENDER_METHOD_PLANE:
d177 1
a177 1
                render_plane_init(&db->env.render, ray_pos, ray_dir);
@


1.19
log
@unpack_free is enabled again
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.18 2005/09/13 23:13:29 twingy Exp $
a163 4
            case RENDER_METHOD_KELOS:
              render_kelos_init(&db->env.render);
              break;

@


1.18
log
@binary mesh map file fix.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.16 2005/09/09 03:31:08 twingy Exp $
a105 1
#if 0
d112 6
a117 9
  for(i = 0; i < mesh_num; i++)
    free(mesh_list[i]);
  free(mesh_list);

  /* Free triangle data */
  for(i = 0; i < tri_num; i++)
    free(tri_list[i]);
  free(tri_list);
#endif
@


1.17
log
@mesh map file is now binary.
@
text
@d624 1
a624 1
    ind += c;
d628 1
a628 1
    ind += c;
@


1.16
log
@fixed python exporter.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.15 2005/09/08 21:58:43 twingy Exp $
d624 1
a624 1
    ind += 1 + c;
d628 1
a628 1
    ind += 1 + c;
@


1.15
log
@adrt now uses a mesh map, no properties embedded in adrt file.  Transformation matrices being applied in unpack
again.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.14 2005/09/06 03:13:54 twingy Exp $
d564 4
a567 2
    for(i = 0; i < vnum; i++)
      math_vec_transform(vlist[i], vlist[i], db->mesh_list[db->mesh_num-1]->matrix);
d644 1
@


1.15.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d33 1
a33 1
 * $Id$
d106 1
d113 9
a121 6
  for(i = 0; i < db->mesh_num; i++) {
    /* Free triangle data */
    free(db->mesh_list[i]->tri_list);
    free(db->mesh_list[i]);
  }
  free(db->mesh_list);
d168 4
d276 1
a276 1

d564 2
a565 4
    for(i = 0; i < vnum; i++) {
      v[0] = vlist[i];
      math_vec_transform(vlist[i], v[0], db->mesh_list[db->mesh_num-1]->matrix);
    }
a641 1
      db->mesh_list[i]->texture = NULL;
@


1.14
log
@total tri num stuff.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.13 2005/08/29 19:25:55 twingy Exp $
d60 2
d99 1
a489 9
    /* Texture */
    tienet_recv(socknum, &c, sizeof(char), 0);
    tienet_recv(socknum, name, c, 0);
    ind += c + 1;
    common_unpack_texture_lookup(name, &(db->mesh_list[db->mesh_num-1]->texture));

    /* Properties */
    common_unpack_prop_lookup(name, &(db->mesh_list[db->mesh_num-1]->prop));

d547 20
a579 1

a581 17


    /* Min and Max */
#if 0
    for(j = 0; j < 3; j++)
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->min.v[j]), sizeof(tfloat), tienet_endian);
    for(j = 0; j < 3; j++)
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->max.v[j]), sizeof(tfloat), tienet_endian);
#endif

    /* Matrix */
    for(i = 0; i < 16; i++)
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->matrix[i]), sizeof(tfloat), tienet_endian);
    ind += 16 * sizeof(tfloat);

    /* Store inverted matrix */
    math_mat_invert(db->mesh_list[db->mesh_num-1]->matinv, db->mesh_list[db->mesh_num-1]->matrix, 4);
d610 38
d649 1
a649 1
  int		i;
d664 1
a664 1
  int		i;
a673 1

@


1.13
log
@kd-tree caching is now tuned to the point where full start-up time takes less than
1/4 the time as it did with the fast mid-split algorithm.  This number should approach
1/8 as the various parts of the packing/unpacking and caching algorithms are tuned
even further.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.12 2005/08/29 06:37:16 twingy Exp $
d454 2
a455 1
  int ind, size, *flist, i, num, start, vnum, vmax, fnum, fmax;
d469 1
a469 1
  tienet_recv(socknum, &num, sizeof(int), tienet_endian);
d471 1
a471 2
  ind += sizeof(int);
  
@


1.12
log
@Integrated kd-tree caching.
It's generated with adrt_bench by supplying the -c argument.
kdtree_cache_file,kdtree.cache goes into project.env file to make it work.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.11 2005/07/29 21:40:07 twingy Exp $
a549 1

@


1.11
log
@added depth to parser so you can render bsp depth from rise.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.10 2005/07/28 00:28:29 twingy Exp $
d59 1
d96 1
d595 20
d641 1
@


1.10
log
@* Overall load time for all 8 nodes during startup is 25% faster.
* File size of adrt mesh is now 33% smaller.  It uses shortst when trinum
  of the mesh is under 64K triangles.
* Prep data to slaves is now multi-threaded (all slaves get data from
  master at the same time, heavy network load).
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.9 2005/07/27 17:43:58 twingy Exp $
d149 4
@


1.9
log
@* Fixed the rendering weirdness on the slave start-up
  Slaves were requesting a work unit right after prep begins
  so that slaves were holding onto a work unit for a lengthy time
  until prep finished and causing the units to not get done until
  prep finished.
* Added compute nodes status to observer.
* Added Scale Factor status to observer.
* Changed bytes transfered to mibi bytes instead of kilobytes.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.8 2005/07/20 18:37:06 twingy Exp $
d501 45
a545 6
    tienet_recv(socknum, &fnum, sizeof(int), tienet_endian);
    ind += sizeof(int);
    if(fnum > fmax) {
      fmax = fnum;
      flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
      tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
a546 2
    tienet_recv(socknum, flist, fnum * 3 * sizeof(int), 0);
    ind += fnum * 3 * sizeof(int);
@


1.8
log
@* Data on demand to nodes (~20% mem savings).
* tlist memory leak in unpack.c fixed.
* BSP Depth Visualization rendering method.
* Split Plane Coloring
* Testing more efficient BSP methods.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.7 2005/07/11 17:18:15 twingy Exp $
d498 1
a498 1
    ind +=  vnum * sizeof(TIE_3);
@


1.7
log
@char c to unsigned char c to allow for strings 255 chars long, not 127.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.6 2005/07/02 22:14:32 twingy Exp $
a43 3

int app_ind;

d52 1
a52 8

#define common_unpack_read(_src, _ind, _dest, _size, _flip) { \
	memcpy(_dest, &((char*)_src)[_ind], _size); \
	if(_flip) tienet_flip(&((char*)_src)[_ind], _dest, _size); \
	_ind += _size; }


void	common_unpack(common_db_t *db, tie_t *tie, util_camera_t *camera, int mask, void *app_data, int app_size);
d54 5
a58 5
void	common_unpack_camera(util_camera_t *camera, void *app_data, int size);
void	common_unpack_env(common_db_t *db, void *app_data, int size);
void	common_unpack_prop(void *app_data, int size);
void	common_unpack_texture(void *app_data, int size);
void	common_unpack_mesh(common_db_t *db, void *app_data, int size, tie_t *tie);
d63 2
a64 2
void common_unpack(common_db_t *db, tie_t *tie, util_camera_t *camera, int mask, void *app_data, int app_size) {
  int size, marker;
a66 3

  app_ind = 0;

d83 2
a84 2
  /* COMMON PROJECT DATA VERSION */
  common_unpack_read(app_data, app_ind, &ver, sizeof(short), tienet_endian);
d86 2
a87 20
  while(app_ind != app_size) {
    common_unpack_read(app_data, app_ind, &block, sizeof(short), tienet_endian);
    common_unpack_read(app_data, app_ind, &size, sizeof(int), tienet_endian);
    marker = app_ind;
/*    printf("block: %d, %d\n", block, size); */
    switch(block) {
      case COMMON_PACK_CAMERA:
        if(mask & COMMON_PACK_ALL || mask & COMMON_PACK_CAMERA)
          common_unpack_camera(camera, app_data, size);
        break;

      case COMMON_PACK_ENV:
        if(mask & COMMON_PACK_ALL || mask & COMMON_PACK_ENV)
          common_unpack_env(db, app_data, size);
        break;

      case COMMON_PACK_PROP:
        if(mask & COMMON_PACK_ALL || mask & COMMON_PACK_PROP)
          common_unpack_prop(app_data, size);
         break;
d89 6
a94 12
      case COMMON_PACK_TEXTURE:
        if(mask & COMMON_PACK_ALL || mask & COMMON_PACK_TEXTURE)
          common_unpack_texture(app_data, size);
        break;

      case COMMON_PACK_MESH:
        if(mask & COMMON_PACK_ALL || mask & COMMON_PACK_MESH)
          common_unpack_mesh(db, app_data, size, tie);
        break;
    }
    app_ind = marker + size;
  }
d120 3
a122 35
void common_unpack_camera(util_camera_t *camera, void *app_data, int size) {
  TIE_3		pos, focus;
  tfloat	tilt, fov, dof;


  /* POSITION */
  common_unpack_read(app_data, app_ind, &pos.v[0], sizeof(tfloat), tienet_endian);
  common_unpack_read(app_data, app_ind, &pos.v[1], sizeof(tfloat), tienet_endian);
  common_unpack_read(app_data, app_ind, &pos.v[2], sizeof(tfloat), tienet_endian);

  /* FOCUS */
  common_unpack_read(app_data, app_ind, &focus.v[0], sizeof(tfloat), tienet_endian);
  common_unpack_read(app_data, app_ind, &focus.v[1], sizeof(tfloat), tienet_endian);
  common_unpack_read(app_data, app_ind, &focus.v[2], sizeof(tfloat), tienet_endian);

  /* TILT */
  common_unpack_read(app_data, app_ind, &tilt, sizeof(tfloat), tienet_endian);

  /* FIELD OF VIEW */
  common_unpack_read(app_data, app_ind, &fov, sizeof(tfloat), tienet_endian);

  /* DEPTH OF FIELD */
  common_unpack_read(app_data, app_ind, &dof, sizeof(tfloat), tienet_endian);

  camera->pos = pos;
  camera->focus = focus;
  camera->tilt = tilt;
  camera->fov = fov;
  camera->dof = dof;
}


void common_unpack_env(common_db_t *db, void *app_data, int size) {
  int		start;
  short		block;
d124 2
d127 1
a127 1
  start = app_ind;
d129 2
a130 1
    common_unpack_read(app_data, app_ind, &block, sizeof(short), tienet_endian);
d134 2
a135 1
          common_unpack_read(app_data, app_ind, &db->env.rm, sizeof(int), tienet_endian);
d152 3
a154 1
                common_unpack_read(app_data, app_ind, &samples, sizeof(int), tienet_endian);
d167 7
a173 7
                common_unpack_read(app_data, app_ind, &ray_pos.v[0], sizeof(tfloat), tienet_endian);
                common_unpack_read(app_data, app_ind, &ray_pos.v[1], sizeof(tfloat), tienet_endian);
                common_unpack_read(app_data, app_ind, &ray_pos.v[2], sizeof(tfloat), tienet_endian);

                common_unpack_read(app_data, app_ind, &ray_dir.v[0], sizeof(tfloat), tienet_endian);
                common_unpack_read(app_data, app_ind, &ray_dir.v[1], sizeof(tfloat), tienet_endian);
                common_unpack_read(app_data, app_ind, &ray_dir.v[2], sizeof(tfloat), tienet_endian);
d175 1
d188 4
a191 3
          common_unpack_read(app_data, app_ind, &db->env.img_w, sizeof(int), tienet_endian);
          common_unpack_read(app_data, app_ind, &db->env.img_h, sizeof(int), tienet_endian);
          common_unpack_read(app_data, app_ind, &db->env.img_hs, sizeof(int), tienet_endian);
d198 1
a198 1
  } while(app_ind - start < size);
d202 5
a206 3
void common_unpack_prop(void *app_data, int size) {
  int			start;
  char			c;
d208 4
d213 25
a237 2
  start = app_ind;
  do {
d242 3
a244 2
    common_unpack_read(app_data, app_ind, &c, sizeof(char), 0);
    common_unpack_read(app_data, app_ind, prop_list[prop_num-1].name, c, 0);
d247 9
a255 8
    common_unpack_read(app_data, app_ind, &prop_list[prop_num-1].prop.color.v[0], sizeof(tfloat), tienet_endian);
    common_unpack_read(app_data, app_ind, &prop_list[prop_num-1].prop.color.v[1], sizeof(tfloat), tienet_endian);
    common_unpack_read(app_data, app_ind, &prop_list[prop_num-1].prop.color.v[2], sizeof(tfloat), tienet_endian);
    common_unpack_read(app_data, app_ind, &prop_list[prop_num-1].prop.density, sizeof(tfloat), tienet_endian);
    common_unpack_read(app_data, app_ind, &prop_list[prop_num-1].prop.gloss, sizeof(tfloat), tienet_endian);
    common_unpack_read(app_data, app_ind, &prop_list[prop_num-1].prop.emission, sizeof(tfloat), tienet_endian);
    common_unpack_read(app_data, app_ind, &prop_list[prop_num-1].prop.ior, sizeof(tfloat), tienet_endian);
  } while(app_ind - start < size);
d259 3
a261 2
void common_unpack_texture(void *app_data, int size) {
  int start;
a263 1
  texture_t *stack = NULL, *texture = NULL;
d265 8
a273 3
  start = app_ind;
  do {
    common_unpack_read(app_data, app_ind, &block, sizeof(short), tienet_endian);
d282 3
a284 2
        common_unpack_read(app_data, app_ind, &c, sizeof(char), 0);
        common_unpack_read(app_data, app_ind, texture_list[texture_num-1].name, c, 0);
d296 11
a306 7
          common_unpack_read(app_data, app_ind, &c, sizeof(char), 0);
          common_unpack_read(app_data, app_ind, texture_list[texture_num-1].name, c, 0);
          common_unpack_read(app_data, app_ind, &c, sizeof(char), 0);
          common_unpack_read(app_data, app_ind, s1, c, 0);
          common_unpack_read(app_data, app_ind, &c, sizeof(char), 0);
          common_unpack_read(app_data, app_ind, s2, c, 0);
          common_unpack_read(app_data, app_ind, &coef, sizeof(tfloat), tienet_endian);
d319 4
a322 3
          common_unpack_read(app_data, app_ind, &color1.v[0], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color1.v[1], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color1.v[2], sizeof(tfloat), tienet_endian);
d324 4
a327 3
          common_unpack_read(app_data, app_ind, &color2.v[0], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color2.v[1], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color2.v[2], sizeof(tfloat), tienet_endian);
d338 4
a341 3
          common_unpack_read(app_data, app_ind, &coef.v[0], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &coef.v[1], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &coef.v[2], sizeof(tfloat), tienet_endian);
d352 2
a353 1
          common_unpack_read(app_data, app_ind, &tile, sizeof(int), tienet_endian);
d366 13
a378 12
          common_unpack_read(app_data, app_ind, &size, sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &octaves, sizeof(int), tienet_endian);
          common_unpack_read(app_data, app_ind, &absolute, sizeof(int), tienet_endian);
          common_unpack_read(app_data, app_ind, &color1.v[0], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color1.v[1], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color1.v[2], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color2.v[0], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color2.v[1], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color2.v[2], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color3.v[0], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color3.v[1], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &color3.v[2], sizeof(tfloat), tienet_endian);
d391 10
a400 9
          common_unpack_read(app_data, app_ind, &size, sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &octaves, sizeof(int), tienet_endian);
          common_unpack_read(app_data, app_ind, &absolute, sizeof(int), tienet_endian);
          common_unpack_read(app_data, app_ind, &scale.v[0], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &scale.v[1], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &scale.v[2], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &translate.v[0], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &translate.v[1], sizeof(tfloat), tienet_endian);
          common_unpack_read(app_data, app_ind, &translate.v[2], sizeof(tfloat), tienet_endian);
d412 3
a414 2
          common_unpack_read(app_data, app_ind, &w, sizeof(short), tienet_endian);
          common_unpack_read(app_data, app_ind, &h, sizeof(short), tienet_endian);
d416 2
a417 1
          common_unpack_read(app_data, app_ind, image, 3*w*h, 0);
d429 2
a430 1
          common_unpack_read(app_data, app_ind, &axis, sizeof(int), tienet_endian);
d439 1
a439 1
  } while(app_ind - start < size);
d443 1
a443 1
void common_unpack_mesh(common_db_t *db, void *app_data, int size, tie_t *tie) {
d448 1
a448 1
  int *flist, i, num, start, vnum, vmax, fnum, fmax;
a450 1
  start = app_ind;
d457 4
d462 1
a462 1
  common_unpack_read(app_data, app_ind, &num, sizeof(int), tienet_endian);
d464 2
d467 1
a467 1
  do {
d477 3
a479 2
    common_unpack_read(app_data, app_ind, &c, sizeof(char), 0);
    common_unpack_read(app_data, app_ind, db->mesh_list[db->mesh_num-1]->name, c, 0);
d482 3
a484 2
    common_unpack_read(app_data, app_ind, &c, sizeof(char), 0);
    common_unpack_read(app_data, app_ind, name, c, 0);
d491 2
a492 1
    common_unpack_read(app_data, app_ind, &vnum, sizeof(int), tienet_endian);
d497 2
a498 1
    common_unpack_read(app_data, app_ind, vlist, vnum * sizeof(TIE_3), 0);
d501 2
a502 1
    common_unpack_read(app_data, app_ind, &fnum, sizeof(int), tienet_endian);
d508 2
a509 1
    common_unpack_read(app_data, app_ind, flist, fnum * 3 * sizeof(int), 0);
a513 1
    tlist = (TIE_3 *)malloc(fnum * 3 * sizeof(TIE_3));
d532 1
a532 1
      common_unpack_read(app_data, app_ind, &(db->mesh_list[db->mesh_num-1]->min.v[j]), sizeof(tfloat), tienet_endian);
d534 1
a534 1
      common_unpack_read(app_data, app_ind, &(db->mesh_list[db->mesh_num-1]->max.v[j]), sizeof(tfloat), tienet_endian);
d539 2
a540 1
      common_unpack_read(app_data, app_ind, &(db->mesh_list[db->mesh_num-1]->matrix[i]), sizeof(tfloat), tienet_endian);
d544 1
a544 2

  } while(app_ind - start < size);
@


1.7.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.11 2005/07/29 21:40:07 twingy Exp $
d44 3
d55 8
a62 1
void	common_unpack(common_db_t *db, tie_t *tie, util_camera_t *camera, int socknum);
d64 5
a68 5
void	common_unpack_camera(util_camera_t *camera, int socknum);
void	common_unpack_env(common_db_t *db, int socknum);
void	common_unpack_prop(int socknum);
void	common_unpack_texture(int socknum);
void	common_unpack_mesh(common_db_t *db, int socknum, tie_t *tie);
d73 2
a74 2
void common_unpack(common_db_t *db, tie_t *tie, util_camera_t *camera, int socknum) {
  int size;
d77 3
d96 18
a113 2
  /* Read in the size of the application data */
  tienet_recv(socknum, &size, sizeof(int), 0);
d115 4
a118 2
  /* Version */
  tienet_recv(socknum, &ver, sizeof(short), tienet_endian);
d120 12
a131 6
  /* Unpack Data */
  common_unpack_env(db, socknum);
  common_unpack_camera(camera, socknum);
  common_unpack_prop(socknum);
  common_unpack_texture(socknum);
  common_unpack_mesh(db, socknum, tie);
d157 35
a191 3
void common_unpack_env(common_db_t *db, int socknum) {
  int ind, size;
  short block;
a192 2
  /* size of environment data */
  tienet_recv(socknum, &size, sizeof(int), 0);
d194 1
a194 1
  ind = 0;
d196 1
a196 2
    tienet_recv(socknum, &block, sizeof(short), tienet_endian);
    ind += sizeof(short);
d200 1
a200 2
          tienet_recv(socknum, &db->env.rm, sizeof(int), tienet_endian);
          ind += sizeof(int);
a213 4
            case RENDER_METHOD_DEPTH:
              render_depth_init(&db->env.render);
              break;

d217 1
a217 3

                tienet_recv(socknum, &samples, sizeof(int), tienet_endian);
                ind += sizeof(int);
d230 7
a236 7
                tienet_recv(socknum, &ray_pos.v[0], sizeof(tfloat), tienet_endian);
                tienet_recv(socknum, &ray_pos.v[1], sizeof(tfloat), tienet_endian);
                tienet_recv(socknum, &ray_pos.v[2], sizeof(tfloat), tienet_endian);

                tienet_recv(socknum, &ray_dir.v[0], sizeof(tfloat), tienet_endian);
                tienet_recv(socknum, &ray_dir.v[1], sizeof(tfloat), tienet_endian);
                tienet_recv(socknum, &ray_dir.v[2], sizeof(tfloat), tienet_endian);
a237 1
                ind += 6 * sizeof(tfloat);
d250 3
a252 4
          tienet_recv(socknum, &db->env.img_w, sizeof(int), tienet_endian);
          tienet_recv(socknum, &db->env.img_h, sizeof(int), tienet_endian);
          tienet_recv(socknum, &db->env.img_hs, sizeof(int), tienet_endian);
          ind += 3 * sizeof(int);
d259 1
a259 1
  } while(ind < size);
d263 3
a265 2
void common_unpack_camera(util_camera_t *camera, int socknum) {
  int size;
a266 2
  /* size of camera data */
  tienet_recv(socknum, &size, sizeof(int), 0);
d268 2
a269 30
  /* POSITION */
  tienet_recv(socknum, &camera->pos.v[0], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->pos.v[1], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->pos.v[2], sizeof(tfloat), tienet_endian);

  /* FOCUS */
  tienet_recv(socknum, &camera->focus.v[0], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->focus.v[1], sizeof(tfloat), tienet_endian);
  tienet_recv(socknum, &camera->focus.v[2], sizeof(tfloat), tienet_endian);

  /* TILT */
  tienet_recv(socknum, &camera->tilt, sizeof(tfloat), tienet_endian);

  /* FIELD OF VIEW */
  tienet_recv(socknum, &camera->fov, sizeof(tfloat), tienet_endian);

  /* DEPTH OF FIELD */
  tienet_recv(socknum, &camera->dof, sizeof(tfloat), tienet_endian);
}


void common_unpack_prop(int socknum) {
  int ind, size;
  char c;

  /* size of property data */
  tienet_recv(socknum, &size, sizeof(int), 0);

  ind = 0;
  while(ind < size) {
d274 2
a275 3
    tienet_recv(socknum, &c, sizeof(char), 0);
    tienet_recv(socknum, prop_list[prop_num-1].name, c, 0);
    ind += c + 1;
d278 8
a285 9
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[0], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[1], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.color.v[2], sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.density, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.gloss, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.emission, sizeof(tfloat), tienet_endian);
    tienet_recv(socknum, &prop_list[prop_num-1].prop.ior, sizeof(tfloat), tienet_endian);
    ind += 7 * sizeof(tfloat);
  }
d289 2
a290 3
void common_unpack_texture(int socknum) {
  texture_t *stack = NULL, *texture = NULL;
  int ind, size;
d293 1
a294 8
  /* size of texture data */
  tienet_recv(socknum, &size, sizeof(int), 0);
  

  ind = 0;
  while(ind < size) {
    tienet_recv(socknum, &block, sizeof(short), tienet_endian);
    ind += sizeof(short);
d296 3
d307 2
a308 3
        tienet_recv(socknum, &c, sizeof(char), 0);
        tienet_recv(socknum, texture_list[texture_num-1].name, c, 0);
        ind += c + 1;
d320 7
a326 11
          tienet_recv(socknum, &c, sizeof(char), 0);
          tienet_recv(socknum, texture_list[texture_num-1].name, c, 0);
          ind += c + c+1;
          tienet_recv(socknum, &c, sizeof(char), 0);
          tienet_recv(socknum, s1, c, 0);
          ind += c + c+1;
          tienet_recv(socknum, &c, sizeof(char), 0);
          tienet_recv(socknum, s2, c, 0);
          ind += c + c+1;
          tienet_recv(socknum, &coef, sizeof(tfloat), tienet_endian);
          ind += sizeof(tfloat);
d339 3
a341 4
          tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
          ind += 3 * sizeof(tfloat);
d343 3
a345 4
          tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
          ind += 3 * sizeof(tfloat);
d356 3
a358 4
          tienet_recv(socknum, &coef.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &coef.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &coef.v[2], sizeof(tfloat), tienet_endian);
          ind += 3 * sizeof(tfloat);
d369 1
a369 2
          tienet_recv(socknum, &tile, sizeof(int), tienet_endian);
          ind += sizeof(int);
d382 12
a393 13
          tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &octaves, sizeof(int), tienet_endian);
          tienet_recv(socknum, &absolute, sizeof(int), tienet_endian);
          tienet_recv(socknum, &color1.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color1.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color1.v[2], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color2.v[2], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color3.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color3.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &color3.v[2], sizeof(tfloat), tienet_endian);
          ind += 10*sizeof(tfloat) + 2*sizeof(int);
d406 9
a414 10
          tienet_recv(socknum, &size, sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &octaves, sizeof(int), tienet_endian);
          tienet_recv(socknum, &absolute, sizeof(int), tienet_endian);
          tienet_recv(socknum, &scale.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &scale.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &scale.v[2], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &translate.v[0], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &translate.v[1], sizeof(tfloat), tienet_endian);
          tienet_recv(socknum, &translate.v[2], sizeof(tfloat), tienet_endian);
          ind += 7*sizeof(tfloat) + 2*sizeof(int);
d426 2
a427 3
          tienet_recv(socknum, &w, sizeof(short), tienet_endian);
          tienet_recv(socknum, &h, sizeof(short), tienet_endian);
          ind += 2*sizeof(short);
d429 1
a429 2
          tienet_recv(socknum, image, 3*w*h, 0);
          ind += 3*w*h;
d441 1
a441 2
          tienet_recv(socknum, &axis, sizeof(int), tienet_endian);
          ind += sizeof(int);
d450 1
a450 1
  }
d454 1
a454 1
void common_unpack_mesh(common_db_t *db, int socknum, tie_t *tie) {
d459 1
a459 1
  int ind, size, *flist, i, num, start, vnum, vmax, fnum, fmax;
d462 1
a468 4
  /* size of mesh data */
  tienet_recv(socknum, &size, sizeof(int), 0);
  ind = 0;

d470 1
a470 1
  tienet_recv(socknum, &num, sizeof(int), tienet_endian);
a471 2
  ind += sizeof(int);
  
d473 1
a473 1
  while(ind < size) {
d483 2
a484 3
    tienet_recv(socknum, &c, sizeof(char), 0);
    tienet_recv(socknum, db->mesh_list[db->mesh_num-1]->name, c, 0);
    ind += c + 1;
d487 2
a488 3
    tienet_recv(socknum, &c, sizeof(char), 0);
    tienet_recv(socknum, name, c, 0);
    ind += c + 1;
d495 1
a495 2
    tienet_recv(socknum, &vnum, sizeof(int), tienet_endian);
    ind += sizeof(int);
d500 1
a500 2
    tienet_recv(socknum, vlist, vnum * sizeof(TIE_3), 0);
    ind += vnum * sizeof(TIE_3);
d503 5
a507 45
    /* Determine short or int based indices */
    tienet_recv(socknum, &c, 1, 0);
    ind += 1;

    if(c) {
      tienet_recv(socknum, &fnum, sizeof(int), tienet_endian);
      ind += sizeof(int);

      if(fnum > fmax) {
        fmax = fnum;
        flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
        tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
      }
      tienet_recv(socknum, flist, fnum * 3 * sizeof(int), 0);
      ind += fnum * 3 * sizeof(int);
    } else {
      unsigned short sfnum, sind[144];
      int j, n;

      tienet_recv(socknum, &sfnum, sizeof(unsigned short), tienet_endian);
      ind += sizeof(unsigned short);

      fnum = sfnum;
      if(fnum > fmax) {
        fmax = fnum;
        flist = (int *)realloc(flist, fmax * 3 * sizeof(int));
        tlist = (TIE_3 *)realloc(tlist, fmax * 3 * sizeof(TIE_3));
      }

      i = 0;
      while(i < fnum) {
        n = fnum - i > 48 ? 48 : fnum - i;
        tienet_recv(socknum, &sind, 3 * n * sizeof(unsigned short), 0);

        for(j = 0; j < n; j++) {
          flist[3*(i+j) + 0] = sind[3*j + 0];
          flist[3*(i+j) + 1] = sind[3*j + 1];
          flist[3*(i+j) + 2] = sind[3*j + 2];
        }

        i += n;
      }


      ind += fnum * 3 * sizeof(unsigned short);
d509 1
d514 1
d533 1
a533 1
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->min.v[j]), sizeof(tfloat), tienet_endian);
d535 1
a535 1
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->max.v[j]), sizeof(tfloat), tienet_endian);
d540 1
a540 2
      tienet_recv(socknum, &(db->mesh_list[db->mesh_num-1]->matrix[i]), sizeof(tfloat), tienet_endian);
    ind += 16 * sizeof(tfloat);
d544 2
a545 1
  }
@


1.6
log
@re-optimized memory allocations in the mesh unpack function, all optimizations
that existed before the migration are back in now.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.5 2005/07/02 07:59:00 twingy Exp $
d292 1
a292 1
  char c;
d456 2
a457 1
  char c, name[256];
@


1.5
log
@igvt is functional again, still needs further testing and a few optimizations
I'm to tired to apply right now.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.4 2005/07/01 21:07:54 twingy Exp $
d462 5
d495 4
a498 1
    vlist = (TIE_3 *)malloc(vnum * sizeof(TIE_3));
d503 5
a507 1
    flist = (int *)malloc(fnum * 3 * sizeof(int));
a543 3
    free(vlist);
    free(flist);
    free(tlist);
d545 4
@


1.4
log
@Moved the g loader int adrt to a converter in brl-cad.  The converter creates
all the necessary files that adrt needs to use geometry.  Going to fix unpack
next so the program is usable again.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.3 2005/06/18 21:58:46 twingy Exp $
d455 4
a458 4
  TIE_3			v[3], *tlist = NULL;
  char			c, name[256];
  short			block;
  int			i, j, k, num, start, tnum;
a460 1
  tnum = 0;
a467 2
    common_unpack_read(app_data, app_ind, &block, sizeof(short), tienet_endian);

d489 3
a491 1
    common_unpack_read(app_data, app_ind, &num, sizeof(int), tienet_endian);
d494 8
d503 2
a504 10
    if(num > tnum) {
      tnum = num;
      tlist = (TIE_3 *)realloc(tlist, sizeof(TIE_3) * tnum * 3);
    }


    db->mesh_list[db->mesh_num-1]->tri_num = num;
    db->mesh_list[db->mesh_num-1]->tri_list = (common_triangle_t *)malloc(num * sizeof(common_triangle_t));

    for(i = 0; i < num; i++) {
d507 3
a509 19

      /* Smooth Triangle */
      common_unpack_read(app_data, app_ind, &c, sizeof(char), 0);

      /* Triangle */
      for(j = 0; j < 3; j++)
        for(k = 0; k < 3; k++)
          common_unpack_read(app_data, app_ind, &v[j].v[k], sizeof(tfloat), tienet_endian);

      tlist[i*3+0] = v[0];
      tlist[i*3+1] = v[1];
      tlist[i*3+2] = v[2];

      if(c) {
        db->mesh_list[db->mesh_num-1]->tri_list[i].normals = (tfloat *)malloc(sizeof(tfloat)*9);
        for(j = 0; j < 9; j++)
          common_unpack_read(app_data, app_ind, &(db->mesh_list[db->mesh_num-1]->tri_list[i].normals[j]), sizeof(tfloat), tienet_endian);
      }

d514 1
a514 1
    tie_push(tie, tlist, num, db->mesh_list[db->mesh_num-1]->tri_list, sizeof(common_triangle_t));
d518 1
d523 1
d526 2
a527 2
    for(j = 0; j < 16; j++)
      common_unpack_read(app_data, app_ind, &(db->mesh_list[db->mesh_num-1]->matrix[j]), sizeof(tfloat), tienet_endian);
d529 1
d531 4
a535 2

  free(tlist);
@


1.3
log
@Added licensing info to libtexture files.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.2 2005/06/18 01:56:30 twingy Exp $
d491 1
a491 1
    /* Triangles */
d494 2
@


1.2
log
@Added licensing info to libcommon files.
@
text
@d33 1
a33 1
 * $Id: unpack.c,v 1.2 2005/06/18 01:30:04 twingy Exp $
a42 1
#include "texture_includes.h"
@


1.1
log
@Welcome ADRT
@
text
@d1 33
a33 2
/*
 * $Id: unpack.c,v 1.5 2005/06/15 22:03:12 justin Exp $
@

