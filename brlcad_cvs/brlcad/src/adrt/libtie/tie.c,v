head	1.60;
access;
symbols
	rel-7-10-4:1.55
	STABLE:1.55.0.2
	rel-7-10-2:1.51
	rel-7-10-0:1.51
	rel-7-8-4:1.42
	rel-7-8-2:1.42
	rel-7-8-0:1.42
	trimnurbs-branch:1.42.0.2
	help:1.42
	temp_tag:1.41
	bobWinPort-20051223-freeze:1.17
	postmerge-20051223-bobWinPort:1.41
	premerge-20051223-bobWinPort:1.41
	rel-7-6-6:1.41
	rel-7-6-4:1.41
	rel-7-6-2:1.36
	rel-7-6-branch:1.36.0.2
	rel-7-6-0:1.36
	rel-7-4-2:1.6.2.1
	rel-7-4-branch:1.6.0.2
	bobWinPort:1.17.0.2
	rel-7-4-0:1.6;
locks; strict;
comment	@ * @;


1.60
date	2007.12.04.21.16.50;	author erikgreenwald;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.03.22.30.18;	author erikgreenwald;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.03.22.24.31;	author erikgreenwald;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.28.20.56.47;	author erikgreenwald;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.14.15.21.02;	author erikgreenwald;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.10.19.38.27;	author erikgreenwald;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.10.18.50.37;	author erikgreenwald;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.10.18.47.46;	author erikgreenwald;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.30.19.04.57;	author brlcad;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.20.20.05.07;	author brlcad;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.08.06.49.19;	author brlcad;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.02.19.46.35;	author erikgreenwald;	state Exp;
branches;
next	1.48;

1.48
date	2007.01.27.01.41.30;	author brlcad;	state Exp;
branches;
next	1.47;

1.47
date	2007.01.23.01.13.22;	author brlcad;	state Exp;
branches;
next	1.46;

1.46
date	2007.01.21.04.45.40;	author brlcad;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.21.00.50.13;	author brlcad;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.20.14.36.41;	author brlcad;	state Exp;
branches;
next	1.43;

1.43
date	2007.01.18.22.17.57;	author erikgreenwald;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.18.06.46.11;	author brlcad;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.20.21.03.31;	author twingy;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.20.20.58.40;	author twingy;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.20.20.55.25;	author twingy;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.20.20.34.01;	author twingy;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.08.21.58.44;	author twingy;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2005.09.08.05.11.20;	author twingy;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.06.06.28.44;	author twingy;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.06.03.45.13;	author twingy;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.06.01.03.23;	author twingy;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.30.20.08.23;	author twingy;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.29.19.25.55;	author twingy;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.29.06.37.16;	author twingy;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.27.21.18.39;	author twingy;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.27.21.16.37;	author twingy;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.27.06.17.50;	author twingy;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.26.22.16.24;	author twingy;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.26.17.56.09;	author twingy;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.26.14.57.47;	author twingy;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.25.23.24.36;	author twingy;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.25.02.44.15;	author twingy;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.23.17.59.52;	author twingy;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.16.04.47.38;	author twingy;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.16.04.18.20;	author twingy;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.15.03.45.25;	author twingy;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.10.20.32.58;	author twingy;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.10.05.32.08;	author twingy;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.09.03.18.59;	author twingy;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.09.03.06.25;	author twingy;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.08.00.44.55;	author twingy;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.29.17.48.17;	author twingy;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.28.00.28.29;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.26.16.28.05;	author twingy;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.20.21.38.48;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.20.18.37.06;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.08.20.00.48;	author twingy;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2005.07.05.15.05.33;	author twingy;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.18.21.58.58;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.18.00.49.06;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.17.21.40.59;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.17.15.09.27;	author lbutler;	state Exp;
branches;
next	;

1.6.2.1
date	2005.08.16.21.03.46;	author brlcad;	state Exp;
branches;
next	;

1.36.2.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.60
log
@removal of the "bit hack"
@
text
@/*
 *  tie.c
 *
 *  RCSid:          $Id: tie.c,v 1.2 2007/12/03 21:55:23 erikg Exp $
*/

#ifdef HAVE_CONFIG_H
# include "common.h"
#endif

#include "tie.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "tie_struct.h"

#ifdef TIE_SSE
# include <xmmintrin.h>
#endif

#ifdef HAVE_STDINT_H
# include <stdint.h>
#endif

TIE_VAL(int tie_check_degenerate) = 1;

/*************************************************************
 **************** PRIVATE FUNCTIONS **************************
 *************************************************************/

static void tie_tri_prep(tie_t *tie)
{
  TIE_3 v1, v2, u, v;
  int i, i1, i2;
  tie_tri_t *tri;

  for (i = 0; i < tie->tri_num; i++) {
    tri = &tie->tri_list[i];

    v1 = tri->data[1];
    v2 = tri->data[2];

    /* Compute Normal */
    MATH_VEC_SUB(u, tri->data[1], tri->data[0]);
    MATH_VEC_SUB(v, tri->data[2], tri->data[0]);
    MATH_VEC_CROSS(tri->data[1], u, v);

    MATH_VEC_UNITIZE(tri->data[1]);

    /* Compute i1 and i2 */
    u.v[0] = fabs(tri->data[1].v[0]);
    u.v[1] = fabs(tri->data[1].v[1]);
    u.v[2] = fabs(tri->data[1].v[2]);

    if (u.v[2] > u.v[1] && u.v[2] > u.v[0]) {
      i1 = 0;
      i2 = 1;
    } else if (u.v[1] > u.v[2] && u.v[1] > u.v[0]) {
      i1 = 0;
      i2 = 2;
    } else {
      i1 = 1;
      i2 = 2;
    }

    /* compute u1, v2, u2, v2 */
    tri->data[2].v[1] = v1.v[i1] - tri->data[0].v[i1];
    tri->data[2].v[2] = v2.v[i1] - tri->data[0].v[i1];
    tri->v[0] = v1.v[i2] - tri->data[0].v[i2];
    tri->v[1] = v2.v[i2] - tri->data[0].v[i2];

    if (i1 == 0 && i2 == 1)
      tri->v = (tfloat *)((intptr_t)(tri->v) + 2);
    else if (i1 == 0)
      tri->v = (tfloat *)((intptr_t)(tri->v) + 1);

    /* Compute DotVN */
    MATH_VEC_MUL_SCALAR(v1, tri->data[0], -1.0);
    MATH_VEC_DOT(tri->data[2].v[0], v1, tri->data[1]);
  }
}


/*************************************************************
 **************** EXPORTED FUNCTIONS *************************
 *************************************************************/

/**
 * Initialize a tie_t data structure
 *
 * This needs to be called before any other libtie data structures are called.
 *
 * @@param tie pointer to a struct tie_t
 * @@return void
 */
TIE_FUNC(void tie_init, tie_t *tie, unsigned int tri_num, int kdmethod)
{
  tie->kdtree = NULL;
  tie->kdmethod = kdmethod;
  tie->tri_num = 0;
  tie->tri_num_alloc = tri_num;
  tie->tri_list = (tie_tri_t *)malloc(sizeof(tie_tri_t) * tri_num);
  tie->stat = 0;
  tie->rays_fired = 0;
}

/**
 * Free up all the stuff associated with libtie
 *
 * All of the KDTREE nodes and triangles that we have allocated need to
 * be freed in a controlled manner.  This routine does that.
 *
 * @@param tie pointer to a struct tie_t
 * @@return void
 */
TIE_FUNC(void tie_free, tie_t *tie)
{
  int i;

  /* Free Triangle Data */
  for (i = 0; i < tie->tri_num; i++)
    free ((void *)((intptr_t)(tie->tri_list[i].v) & ~0x7L));
  free (tie->tri_list);

  /* Free KDTREE Nodes */
  tie_kdtree_free (tie);
}


/**
 * Get ready to shoot rays at triangles
 *
 * Build the KDTREE tree for the triangles we have
 *
 * @@param tie pointer to a struct tie_t which now has all the triangles in it
 * @@return void
 */
TIE_FUNC(void tie_prep, tie_t *tie)
{
  /* Build the kd-tree */
  tie_kdtree_prep (tie);

  /* Prep all the triangles */
  tie_tri_prep (tie);
}


/**
 * Shoot a ray at some triangles
 *
 * The user-provided hitfunc is called at each ray/triangle intersection.
 * Calls are guaranteed to be made in the ray-intersection order.
 * The last argument (void *ptr) is passed to the hitfunc as-is, to allow
 * application specific data to be passed to the hitfunc.
 *
 * @@param tie a struct tie_t universe
 * @@param ray the ray to be intersected with the geometry
 * @@param id the intersection data for each intersection
 * @@param hitfunc the application routine to be called upon ray/triangle intersection.
 * This function should return 0 if the ray is to continue propagating through the geometry,
 * or non-zero if ray intersection should cease.
 * @@param ptr a pointer to be passed to the hitfunc when it is called.
 *
 * @@return the return value from the user hitfunc() is used.
 * In the event that the ray does not hit anything, or the ray exits the geometry space, a null value will be returned.
 * @@retval 0 ray did not hit anything, or ray was propagated through the geometry completely.
 * @@retval !0 the value returned from the last invokation of hitfunc()
 */
TIE_FUNC(void* tie_work, tie_t *tie, tie_ray_t *ray, tie_id_t *id, void *(*hitfunc)(tie_ray_t*, tie_id_t*, tie_tri_t*, void *ptr), void *ptr)
{
  tie_stack_t stack[40];
  tie_id_t t, id_list[256];
  tie_tri_t *hit_list[256], *tri;
  tie_geom_t *data;
  tie_kdtree_t *node_aligned, *temp[2];
  tfloat near, far, dirinv[3], dist;
  int i, n, ab[3], split, stack_ind, hit_count;
  void *result;


/*ErPLog( "ray: %f %f %f %f %f %f\n", ray->pos.v[0], ray->pos.v[1], ray->pos.v[2], ray->dir.v[0], ray->dir.v[1], ray->dir.v[2] );*/

  if (!tie->kdtree)
    return (NULL);

  ray->kdtree_depth = 0;

  /*
  * Precompute direction inverse since it's used in a bunch of divides,
  * this allows those divides to become fast multiplies.
  */
  for (i = 0; i < 3; i++) {
    if (ray->dir.v[i] == 0.0)
      ray->dir.v[i] = TIE_PREC;
    dirinv[i] = 1.0 / ray->dir.v[i];
    ab[i] = dirinv[i] < 0.0 ? 1.0 : 0.0;
  }

  /* Extracting value of splitting plane from tie->kdtree pointer */
  split = ((intptr_t)(((tie_kdtree_t *)((intptr_t)tie->kdtree & ~0x7L))->data)) & 0x3;

  /* Initialize ray segment */
  if (ray->dir.v[split] < 0.0)
    far = (tie->min.v[split] - ray->pos.v[split]) * dirinv[split];
  else
    far = (tie->max.v[split] - ray->pos.v[split]) * dirinv[split];

  stack_ind = 0;
  stack[0].node = tie->kdtree;
  stack[0].near = 0;
  stack[0].far = far;

  /* Process items on the stack */
  do {
    near = stack[stack_ind].near;
    far = stack[stack_ind].far;

    /*
    * Take the pointer from stack[stack_ind] and remove lower pts bits used to store data to
    * give a valid ptr address.
    */
    node_aligned = (tie_kdtree_t *)((intptr_t)stack[stack_ind].node & ~0x7L);
    stack_ind--;

    /*
    * KDTREE TRAVERSAL
    *
    * 3 conditions can happen here:
    *   - Ray only intersects the nearest node
    *   - Ray only intersects the furthest node
    *   - Ray intersects both nodes, pushing the furthest onto the stack
    *
    * Gordon Stoll's Mantra - Rays are Measured in Millions :-)
    */
    while (((intptr_t)(node_aligned->data)) & 0x4) {
      ray->kdtree_depth++;

      /* Retreive the splitting plane */
      split = ((intptr_t)(node_aligned->data)) & 0x3;

      /* Calculate the projected 1d distance to splitting axis */
      dist = (node_aligned->axis - ray->pos.v[split]) * dirinv[split];

      temp[0] = &((tie_kdtree_t *)(node_aligned->data))[ab[split]];
      temp[1] = &((tie_kdtree_t *)(node_aligned->data))[1-ab[split]];

      i = near >= dist; /* Node B Only? */
      node_aligned = (tie_kdtree_t *)((intptr_t)(temp[i]) & ~0x7L);

      if (far < dist || i)
        continue;

      /* Nearest Node and Push Furthest */
      stack_ind++;
      stack[stack_ind].node = temp[1];
      stack[stack_ind].near = dist;
      stack[stack_ind].far = far;
      far = dist;
    }


    /*
    * RAY/TRIANGLE INTERSECTION - Only gets executed on geometry nodes.
    * This part of the function is being executed because the KDTREE Traversal is Complete.
    */
    data = (tie_geom_t *)(node_aligned->data);
    if (data->tri_num == 0)
      continue;

    hit_count = 0;
    for (i = 0; i < data->tri_num; i++) {
      /*
      * Triangle Intersection Code
      */
      tfloat u0, v0, *v;
      int i1, i2;

      tri = data->tri_list[i];
      MATH_VEC_DOT(u0, tri->data[1], ray->pos);
      MATH_VEC_DOT(v0, tri->data[1], ray->dir);
      t.dist = -(tri->data[2].v[0] + u0) / v0;

      /*
      * Intersection point on triangle must lie within the kdtree node or it is rejected
      * Apply TIE_PREC to near and far such that triangles that lie on orthogonal planes
      * aren't in a precision fuzz boundary, thus missing something they should actualy
      * have hit.
      */
      if (t.dist < near-TIE_PREC || t.dist > far+TIE_PREC)
        continue;

      /* Compute Intersection Point (P = O + Dt) */
      MATH_VEC_MUL_SCALAR(t.pos, ray->dir, t.dist);
      MATH_VEC_ADD(t.pos, ray->pos, t.pos);

      /* Extract i1 and i2 indices from lower bits of the v pointer */
      v = (tfloat *)((intptr_t)(tri->v) & ~0x7L);

      i1 = TIE_TAB1[((intptr_t)(tri->v) & 0x7)];
      i2 = TIE_TAB1[3 + ((intptr_t)(tri->v) & 0x7)];

      /* Compute U and V */
      u0 = t.pos.v[i1] - tri->data[0].v[i1];
      v0 = t.pos.v[i2] - tri->data[0].v[i2];

      /*
      * Compute the barycentric coordinates, and make sure the coordinates
      * fall within the boundaries of the triangle plane.
      */
      if (fabs(tri->data[2].v[1]) <= TIE_PREC) {
        t.beta = u0 / tri->data[2].v[2];
        if (t.beta < 0 || t.beta > 1)
          continue;
        t.alpha = (v0 - t.beta*v[1]) / v[0];
      } else {
        t.beta = (v0*tri->data[2].v[1] - u0*v[0]) / (v[1]*tri->data[2].v[1] - tri->data[2].v[2]*v[0]);
        if (t.beta < 0 || t.beta > 1)
          continue;
        t.alpha = (u0 - t.beta*tri->data[2].v[2]) / tri->data[2].v[1];
      }

      if (t.alpha < 0 || (t.alpha + t.beta) > 1.0)
        continue;

      /* Triangle Intersected, append it in the list */
      if (hit_count < 0xff) {
        hit_list[hit_count] = tri;
        id_list[hit_count] = t;
        hit_count++;
      }
    }


    /* If we hit something, then sort the hit triangles on demand */
    for (i = 0; i < hit_count; i++) {
      /* Sort the list so that HitList and IDList [n] is in order wrt [i] */
      for (n = i; n < hit_count; n++) {
        if (id_list[n].dist < id_list[i].dist) {
          /* Swap */
          tri = hit_list[i];
          t = id_list[i];
          hit_list[i] = hit_list[n];
          id_list[i] = id_list[n];
          hit_list[n] = tri;
          id_list[n] = t;
        }
      }

      id_list[i].norm = hit_list[i]->data[1];
      result = hitfunc(ray, &id_list[i], hit_list[i], ptr);

      if (result) {
        *id = id_list[i];
        return (result);
      }
    }
  } while (stack_ind >= 0);

  return (NULL);
}


/**
 * Add a triangle
 *
 * Add a new triangle to the universe to be raytraced.
 *
 * @@param tie the universe
 * @@param tlist is an array of TIE_3 vertice triplets (v0, v1, v2) that form each triangle.
 * @@param tnum is the number of triangles (tlist = 3 * tnum of TIE_3's).
 * @@param plist is a list of pointer data that gets assigned to the ptr of each triangle.
 * This will typically be 4-byte (32-bit architecture) spaced array of pointers that
 * associate the triangle pointer with your arbitrary structure, i.e a mesh.
 * @@param pstride is the number of bytes to increment the pointer list as it assigns
 * a pointer to each mesh, typically a value of 4 (for 32-bit machines).  If you have
 * a single pointer that groups all triangles to a common structure then you can use
 * a value of 0 for pstride.  This will give the pointer of all triangles the pointer
 * address of plist.
 * @@return void
 */
TIE_FUNC(void tie_push, tie_t *tie, TIE_3 **tlist, int tnum, void *plist, int pstride)
{
  int i;

  if (tnum + tie->tri_num > tie->tri_num_alloc) {
    tie->tri_list = (tie_tri_t *)realloc(tie->tri_list, sizeof(tie_tri_t) * (tie->tri_num + tnum));
    tie->tri_num_alloc += tnum;
  }

  for (i = 0; i < tnum; i++) {
    if(tie_check_degenerate) {
      TIE_3 u, v, w;

      MATH_VEC_SUB(u, (*tlist[i*3+1]), (*tlist[i*3+0]));
      MATH_VEC_SUB(v, (*tlist[i*3+2]), (*tlist[i*3+0]));
      MATH_VEC_CROSS(w, u, v);

      if (fabs(w.v[0]) < 0.0001 && fabs(w.v[1]) < 0.0001 && fabs(w.v[2]) < 0.0001)
        continue;
    }
    tie->tri_list[tie->tri_num].data[0] = *tlist[i*3+0];
    tie->tri_list[tie->tri_num].data[1] = *tlist[i*3+1];
    tie->tri_list[tie->tri_num].data[2] = *tlist[i*3+2];
    if (plist) {
      tie->tri_list[tie->tri_num].ptr = plist;
      plist = (void *)((intptr_t)plist + pstride);
    } else
      tie->tri_list[tie->tri_num].ptr = NULL;
    tie->tri_list[tie->tri_num].v = (tfloat *)malloc(2*sizeof(tfloat));
    tie->tri_num++;
  }
}
@


1.59
log
@make triangle degeneracy testing a runtime selectable feature
@
text
@d4 1
a4 1
 *  RCSid:          $Id: tie.c,v 1.58 2007/12/03 22:24:31 erikgreenwald Exp $
d76 1
a76 1
     else if (i1 == 0)
d90 1
a90 1
/*
d109 1
a109 1
/*
d132 1
a132 1
/*
d150 1
a150 1
/*
d205 1
a205 1
  if (ray->dir.v[split] < 0.0) {
d207 1
a207 1
  } else {
a208 1
  }
d224 1
a224 1
    node_aligned = stack[stack_ind].node;
d246 2
a247 2
      temp[0] = &((tie_kdtree_t *) (((intptr_t)(node_aligned->data)) & ~0x7L))[ab[split]];
      temp[1] = &((tie_kdtree_t *) (((intptr_t)(node_aligned->data)) & ~0x7L))[1-ab[split]];
d250 1
a250 1
      node_aligned = temp[i];
d332 1
a332 2
      } else
        printf ("TIE: WARNING over 255!!!!!\n");
d365 1
a365 1
/*
d388 2
a389 3
    /* Allocate the next 256K triangle increment greater than tnum + tie->tri_num. */
    tie->tri_num_alloc = (1 + (tnum + tie->tri_num) / (1<<18)) * (1<<18);
    tie->tri_list = (tie_tri_t *) realloc (tie->tri_list, sizeof(tie_tri_t) * tie->tri_num_alloc);
@


1.58
log
@build execution paths for both single and double precision floats in the same lib
@
text
@d4 1
a4 1
 *  RCSid:          $Id: tie.c,v 1.57 2007/11/28 20:56:47 erikgreenwald Exp $
d27 1
a27 1
int tie_check_degenerate = 1;
d396 2
a397 2
#if TIE_CHECK_DEGENERATE
    TIE_3 u, v, w;
d399 3
a401 3
    MATH_VEC_SUB(u, (*tlist[i*3+1]), (*tlist[i*3+0]));
    MATH_VEC_SUB(v, (*tlist[i*3+2]), (*tlist[i*3+0]));
    MATH_VEC_CROSS(w, u, v);
d403 3
a405 3
    if (fabs(w.v[0]) < 0.0001 && fabs(w.v[1]) < 0.0001 && fabs(w.v[2]) < 0.0001)
      continue;
#endif
@


1.57
log
@merge of the "other" libtie...
@
text
@d4 1
a4 1
 *  RCSid:          $Id: tie.c,v 1.56 2007/09/14 15:21:02 erikgreenwald Exp $
d27 1
a27 3
/**************************************************
**************** PRIVATE FUNCTIONS ****************
***************************************************/
d29 5
a33 2
static void
tie_tri_prep (tie_t *tie)
d39 1
a39 2
  for (i = 0; i < tie->tri_num; i++)
  {
d57 1
a57 2
    if (u.v[2] > u.v[1] && u.v[2] > u.v[0])
    {
d60 1
a60 3
    }
    else if (u.v[1] > u.v[2] && u.v[1] > u.v[0])
    {
d63 1
a63 3
    }
    else
    {
a74 1
    {
d76 1
a76 3
    }
    else if (i1 == 0)
    {
a77 1
    }
d98 1
a98 2
void
tie_init (tie_t *tie, unsigned int tri_num, int kdmethod)
d118 1
a118 2
void
tie_free (tie_t *tie)
d140 1
a140 2
void
tie_prep(tie_t *tie)
d171 1
a171 2
void*
tie_work (tie_t *tie, tie_ray_t *ray, tie_id_t *id, void *(*hitfunc)(tie_ray_t*, tie_id_t*, tie_tri_t*, void *ptr), void *ptr)
d187 1
d194 1
a194 2
  for (i = 0; i < 3; i++)
  {
d205 1
a205 2
  if (ray->dir.v[split] < 0.0)
  {
d217 1
a217 3
/*  while (stack_ind >= 0) */
  do
  {
d238 1
a238 2
    while (((intptr_t)(node_aligned->data)) & 0x4)
    {
d274 1
a274 2
    for (i = 0; i < data->tri_num; i++)
    {
d313 1
a313 2
      if (fabs(tri->data[2].v[1]) <= TIE_PREC)
      {
d315 1
a315 1
        if(t.beta < 0 || t.beta > 1)
d318 1
a318 3
      }
      else
      {
d320 1
a320 1
        if(t.beta < 0 || t.beta > 1)
d325 1
a325 1
      if(t.alpha < 0 || (t.alpha + t.beta) > 1.0)
d329 1
a329 2
      if (hit_count < 0xff)
      {
d333 1
a333 3
      }
      else
      {
a334 1
      }
d339 1
a339 2
    for (i = 0; i < hit_count; i++)
    {
d341 2
a342 4
      for (n = i; n < hit_count; n++)
      {
        if (id_list[n].dist < id_list[i].dist)
        {
d356 1
a356 2
      if (result)
      {
d358 1
a358 1
        return(result);
d363 1
a363 1
  return(NULL);
d385 1
a385 2
void
tie_push(tie_t *tie, TIE_3 **tlist, int tnum, void *plist, int pstride)
d389 1
a389 2
  if(tnum + tie->tri_num > tie->tri_num_alloc)
  {
d395 1
a395 2
  for (i = 0; i < tnum; i++)
  {
d409 1
a409 2
    if (plist)
    {
d412 1
a412 3
    }
    else
    {
a413 1
    }
@


1.56
log
@removed trailing whitespace
@
text
@d4 1
a4 1
 *  RCSid:          $Id: tie.c,v 1.55 2007/09/10 19:38:27 erikgreenwald Exp $
d108 1
a108 1
tie_init (tie_t *tie, unsigned int tri_num)
d111 1
@


1.55
log
@should only be using common.h, not brlcad_config.h
@
text
@d4 1
a4 1
 *  RCSid:          $Id: tie.c,v 1.54 2007/09/10 18:50:37 erikgreenwald Exp $
d165 1
a165 1
 * Calls are guaranteed to be made in the ray-intersection order.  
d174 1
a174 1
 * or non-zero if ray intersection should cease.  
@


1.54
log
@wrap stdint.h (fix for solaris)
@
text
@d4 1
a4 1
 *  RCSid:          $Id: tie.c,v 1.53 2007/09/10 18:47:46 erikgreenwald Exp $
d8 1
a8 1
# include "brlcad_config.h"
@


1.53
log
@move to old C comments so we can remove the -std=c99 cflag
@
text
@d4 1
a4 1
 *  RCSid:          $Id: tie.c,v 1.52 2007/08/30 19:04:57 brlcad Exp $
d7 4
d23 4
a26 1
#include <stdint.h>
@


1.52
log
@libtie update from Justin.  these changes are the updates after integration of libtie with MUVES-S2.  it includes a few minor api changes as well as a variety of bug fixes and other cleanup.
@
text
@d4 1
a4 1
 *  RCSid:          $Id: tie.c,v 1.2 2007/05/09 13:57:38 kmurray Exp $
d223 1
a223 1
//  while (stack_ind >= 0)
@


1.51
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d1 2
a2 5
/*                     T I E . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2002-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
d4 2
a5 45
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup libtie */
/** @@{ */
/** @@file tie.c
 *
 *  @@brief support routines for shooting at triangles
 *  Comments -
 *      Triangle Intersection Engine
 *
 * The calling sequence is as follows:
 *	@@li tie_init()	initialize the data structure
 *	@@li tie_push()	add triangles to the universe to be raytraced
 *	@@li tie_prep()	build the KDTREE for the triangles
 *	@@li tie_work()	shoot some ray
 *	@@li tie_work()	shoot some ray
 *	@@li tie_work()	shoot some ray
 *	@@li tie_work()	shoot some ray
 *	@@li tie_work()	shoot some ray
 *	@@li tie_free()	Free up all the memory
 *
 *  Author -
 *      Justin L. Shumaker
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 * $Id: tie.c,v 1.50 2007/02/08 06:49:19 brlcad Exp $
 */

#ifdef HAVE_CONFIG_H
# include "brlcad_config.h"
#endif
d13 1
a13 1
#include "struct.h"
d19 8
a26 5
/*************************************************************
 **************** PRIVATE FUNCTIONS **************************
 *************************************************************/

static void tie_tri_prep(tie_t *tie) {
d31 2
a32 1
  for(i = 0; i < tie->tri_num; i++) {
d42 1
d50 2
a51 1
    if(u.v[2] > u.v[1] && u.v[2] > u.v[0]) {
d54 3
a56 1
    } else if(u.v[1] > u.v[2] && u.v[1] > u.v[0]) {
d59 3
a61 1
    } else {
d72 7
a78 4
    if(i1 == 0 && i2 == 1) {
      tri->v = (TFLOAT *)((intptr_t)(tri->v) + 2);
    } else if (i1 == 0) {
      tri->v = (TFLOAT *)((intptr_t)(tri->v) + 1);
d92 1
a92 1
/**
d100 3
a102 1
void tie_init(tie_t *tie, unsigned int tri_num) {
a106 4
  if (!tie->tri_list) {
      perror("malloc");
      exit(1);
  }
d111 1
a111 1
/**
d120 3
a122 1
void tie_free(tie_t *tie) {
d126 3
a128 3
  for(i = 0; i < tie->tri_num; i++)
    free( (void *)((intptr_t)(tie->tri_list[i].v) & ~0x7L) );
  free(tie->tri_list);
d131 1
a131 1
  tie_kdtree_free(tie);
d135 1
a135 1
/**
d143 3
a145 1
void tie_prep(tie_t *tie) {
d147 1
a147 1
  tie_kdtree_prep(tie);
d150 1
a150 1
  tie_tri_prep(tie);
d154 1
a154 1
/**
d158 1
a158 1
 * Calls are guaranteed to be made in the ray-intersection order.
d167 1
a167 1
 * or non-zero if ray intersection should cease.
d175 3
a177 1
void* tie_work(tie_t *tie, tie_ray_t *ray, tie_id_t *id, void *(*hitfunc)(tie_ray_t*, tie_id_t*, tie_tri_t*, void *ptr), void *ptr) {
d183 1
a183 1
  TFLOAT near, far, dirinv[3], dist;
d188 1
a188 2
  if(!tie->kdtree)
    return(NULL);
d190 2
d198 3
a200 2
  for(i = 0; i < 3; i++) {
    if(ray->dir.v[i] == 0)
d203 1
a203 1
    ab[i] = dirinv[i] < 0 ? 1 : 0;
d210 2
a211 1
  if(ray->dir.v[split] < 0) {
d223 3
a225 1
  while(stack_ind >= 0) {
d233 1
a233 1
    node_aligned = (tie_kdtree_t *)((intptr_t)stack[stack_ind].node & ~0x7L);
d246 2
a247 1
    while(((intptr_t)(node_aligned->data)) & 0x4) {
d256 2
a257 2
      temp[0] = &((tie_kdtree_t *)(node_aligned->data))[ab[split]];
      temp[1] = &((tie_kdtree_t *)(node_aligned->data))[1-ab[split]];
d260 1
a260 1
      node_aligned = (tie_kdtree_t *)((intptr_t)(temp[i]) & ~0x7L);
d262 2
a263 2
      if(far < dist || i)
	continue;
d279 1
a279 1
    if(data->tri_num == 0)
d283 2
a284 1
    for(i = 0; i < data->tri_num; i++) {
d288 1
a288 1
      TFLOAT u0, v0, *v;
d302 2
a303 2
      if(t.dist < near-TIE_PREC || t.dist > far+TIE_PREC)
	continue;
d310 1
a310 1
      v = (TFLOAT *)((intptr_t)(tri->v) & ~0x7L);
d323 13
a335 10
      if(fabs(tri->data[2].v[1]) <= TIE_PREC) {
	t.beta = u0 / tri->data[2].v[2];
	if(t.beta < 0 || t.beta > 1)
	  continue;
	t.alpha = (v0 - t.beta*v[1]) / v[0];
      } else {
	t.beta = (v0*tri->data[2].v[1] - u0*v[0]) / (v[1]*tri->data[2].v[1] - tri->data[2].v[2]*v[0]);
	if(t.beta < 0 || t.beta > 1)
	  continue;
	t.alpha = (u0 - t.beta*tri->data[2].v[2]) / tri->data[2].v[1];
d339 1
a339 1
	continue;
d342 9
a350 4
      if(hit_count < 0xff) {
	hit_list[hit_count] = tri;
	id_list[hit_count] = t;
	hit_count++;
a351 2


d356 2
a357 1
    for(i = 0; i < hit_count; i++) {
d359 12
a370 10
      for(n = i; n < hit_count; n++) {
	if(id_list[n].dist < id_list[i].dist) {
	  /* Swap */
	  tri = hit_list[i];
	  t = id_list[i];
	  hit_list[i] = hit_list[n];
	  id_list[i] = id_list[n];
	  hit_list[n] = tri;
	  id_list[n] = t;
	}
d376 4
a379 3
      if(result) {
	*id = id_list[i];
	return(result);
d382 1
a382 1
  }
d388 1
a388 1
/**
d406 3
a408 1
void tie_push(tie_t *tie, TIE_3 *tlist, int tnum, void *plist, int pstride) {
d411 5
a415 3
  if(tnum + tie->tri_num > tie->tri_num_alloc) {
    tie->tri_list = (tie_tri_t *)realloc(tie->tri_list, sizeof(tie_tri_t) * (tie->tri_num + tnum));
    tie->tri_num_alloc += tnum;
d418 17
a434 5
  for(i = 0; i < tnum; i++) {
    tie->tri_list[tie->tri_num].data[0] = tlist[i*3+0];
    tie->tri_list[tie->tri_num].data[1] = tlist[i*3+1];
    tie->tri_list[tie->tri_num].data[2] = tlist[i*3+2];
    if(plist) {
d437 3
a439 1
    } else {
d442 1
a442 5
    tie->tri_list[tie->tri_num].v = (TFLOAT *)malloc(2*sizeof(TFLOAT));
    if (!tie->tri_list[tie->tri_num].v) {
	perror("malloc");
	exit(1);
    }
a445 12

/** @@} */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.50
log
@give adrt some distinctiveness in the header
@
text
@d46 1
a46 1
 * $Id: tie.c,v 1.49 2007/02/02 19:46:35 erikgreenwald Exp $
d138 4
d437 4
@


1.49
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
d46 1
a46 1
 * $Id: tie.c,v 1.48 2007/01/27 01:41:30 brlcad Exp $
@


1.48
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d46 1
a46 1
 * $Id: tie.c,v 1.47 2007/01/23 01:13:22 brlcad Exp $
d109 1
a109 1
      tri->v = (tfloat *)((intptr_t)(tri->v) + 2);
d111 1
a111 1
      tri->v = (tfloat *)((intptr_t)(tri->v) + 1);
d208 1
a208 1
  tfloat near, far, dirinv[3], dist;
d306 1
a306 1
      tfloat u0, v0, *v;
d328 1
a328 1
      v = (tfloat *)((intptr_t)(tri->v) & ~0x7L);
d432 1
a432 1
    tie->tri_list[tie->tri_num].v = (tfloat *)malloc(2*sizeof(tfloat));
@


1.47
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d46 1
a46 1
 * $Id: tie.c,v 1.46 2007/01/21 04:45:40 brlcad Exp $
d282 1
a282 1
        continue;
d321 1
a321 1
        continue;
d342 4
a345 4
        t.beta = u0 / tri->data[2].v[2];
        if(t.beta < 0 || t.beta > 1)
          continue;
        t.alpha = (v0 - t.beta*v[1]) / v[0];
d347 4
a350 4
        t.beta = (v0*tri->data[2].v[1] - u0*v[0]) / (v[1]*tri->data[2].v[1] - tri->data[2].v[2]*v[0]);
        if(t.beta < 0 || t.beta > 1)
          continue;
        t.alpha = (u0 - t.beta*tri->data[2].v[2]) / tri->data[2].v[1];
d354 1
a354 1
        continue;
d358 3
a360 3
        hit_list[hit_count] = tri;
        id_list[hit_count] = t;
        hit_count++;
d371 9
a379 9
        if(id_list[n].dist < id_list[i].dist) {
          /* Swap */
          tri = hit_list[i];
          t = id_list[i];
          hit_list[i] = hit_list[n];
          id_list[i] = id_list[n];
          hit_list[n] = tri;
          id_list[n] = t;
        }
d386 2
a387 2
        *id = id_list[i];
        return(result);
@


1.46
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d46 1
a46 1
 * $Id: tie.c,v 1.45 2007/01/21 00:50:13 brlcad Exp $
@


1.45
log
@standard header and footer cleanup
@
text
@d21 2
a28 21
 *      The calling sequence is as follows:
 *        - tie_init()	initialize the data structure
 *        - tie_push()	add triangles to the universe to be raytraced
 *        - tie_prep()	build the KDTREE for the triangles
 *        - tie_work()	shoot some ray
 *        - tie_work()	shoot some ray
 *        - tie_work()	shoot some ray
 *        - tie_work()	shoot some ray
 *        - tie_free()	Free up all the memory
 *
 *  Author -
 *      Justin L. Shumaker
 *
 *  Source -
 *      The U. S. Army Research Laboratory
 *      Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 * $Id: tie.c,v 1.44 2007/01/20 14:36:41 brlcad Exp $
 */
/** @@addtogroup libtie
 *
d39 9
a47 1
 * @@{
@


1.44
log
@update copyright to 2007
@
text
@a1 3
 *
 * @@file tie.c
 *
d20 2
d44 1
a44 1
 * $Id: tie.c,v 1.43 2007/01/18 22:17:57 erikgreenwald Exp $
d450 10
@


1.43
log
@uppercase all #define symbols
@
text
@d7 1
a7 1
 * Copyright (c) 2002-2006 United States Government as represented by
d45 1
a45 1
 * $Id: tie.c,v 1.42 2006/01/18 06:46:11 brlcad Exp $
@


1.42
log
@update copyright to 2006
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.41 2005/10/23 04:44:28 brlcad Exp $
d94 4
a97 4
    math_vec_sub(u, tri->data[1], tri->data[0]);
    math_vec_sub(v, tri->data[2], tri->data[0]);
    math_vec_cross(tri->data[1], u, v);
    math_vec_unitize(tri->data[1]);
d128 2
a129 2
    math_vec_mul_scalar(v1, tri->data[0], -1.0);
    math_vec_dot(tri->data[2].v[0], v1, tri->data[1]);
d323 2
a324 2
      math_vec_dot(u0, tri->data[1], ray->pos);
      math_vec_dot(v0, tri->data[1], ray->dir);
d337 2
a338 2
      math_vec_mul_scalar(t.pos, ray->dir, t.dist);
      math_vec_add(t.pos, ray->pos, t.pos);
@


1.41
log
@trailing ws
@
text
@d7 1
a7 1
 * Copyright (C) 2002-2005 United States Government as represented by
d45 1
a45 1
 * $Id: tie.c,v 1.40 2005/09/20 21:03:31 twingy Exp $
@


1.40
log
@enough formatting already
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.39 2005/09/20 20:58:40 twingy Exp $
d198 1
a198 1
 * Calls are guaranteed to be made in the ray-intersection order.  
d207 1
a207 1
 * or non-zero if ray intersection should cease.  
@


1.39
log
@more formatting
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.38 2005/09/20 20:55:25 twingy Exp $
d441 1
a441 1
      plist = ((intptr_t *)plist) + pstride;
@


1.38
log
@formatting
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.37 2005/09/20 20:34:01 twingy Exp $
d441 1
a441 1
      *((intptr_t **)plist) += pstride;
@


1.37
log
@tie_push doesn't throw warning anymore
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.36 2005/09/08 21:58:44 twingy Exp $
d370 1
a370 1
      if(hit_count < 250) {
@


1.36
log
@adrt now uses a mesh map, no properties embedded in adrt file.  Transformation matrices being applied in unpack
again.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.35 2005/09/08 05:11:20 twingy Exp $
d441 1
a441 1
      plist += pstride;
@


1.36.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d45 1
a45 1
 * $Id$
d198 1
a198 1
 * Calls are guaranteed to be made in the ray-intersection order.
d207 1
a207 1
 * or non-zero if ray intersection should cease.
d370 1
a370 1
      if(hit_count < 0xff) {
d441 1
a441 1
      plist = (void *)((intptr_t)plist + pstride);
@


1.35
log
@fixed a stack pop bug in the kd-tree cache loader.  engine is 1.1% faster.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.34 2005/09/06 06:28:44 twingy Exp $
d165 1
a165 1
  int			i;
d168 1
a168 2
  for(i = 0; i < tie->tri_num; i++) {
    printf("free: %p\n", (void *)((intptr_t)(tie->tri_list[i].v) & ~0x7L));
a169 1
  }
d342 1
d375 2
d419 1
a419 1
 * associate the triantle pointer with your arbitrary structure, i.e a mesh.
@


1.34
log
@investigating tie->free()
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.33 2005/09/06 03:45:13 twingy Exp $
d67 1
d71 1
a71 1
#include <math.h>
d122 1
a122 1
      tri->v = (tfloat *)((TIE_PTR_CAST)(tri->v) + 2);
d124 1
a124 1
      tri->v = (tfloat *)((TIE_PTR_CAST)(tri->v) + 1);
a167 1
printf("CP:A\n");
d169 2
a170 2
    printf("free: %p\n", (void *)((TIE_PTR_CAST)(tie->tri_list[i].v) & ~0x7L));
    free( (void *)((TIE_PTR_CAST)(tie->tri_list[i].v) & ~0x7L) );
a171 1
printf("CP:B\n");
a172 1
printf("CP:C\n");
d245 1
a245 1
  split = ((TIE_PTR_CAST)(((tie_kdtree_t *)((TIE_PTR_CAST)tie->kdtree & ~0x7L))->data)) & 0x3;
d268 1
a268 1
    node_aligned = (tie_kdtree_t *)((TIE_PTR_CAST)stack[stack_ind].node & ~0x7L);
d281 1
a281 1
    while(((TIE_PTR_CAST)(node_aligned->data)) & 0x4) {
d285 1
a285 1
      split = ((TIE_PTR_CAST)(node_aligned->data)) & 0x3;
d294 1
a294 1
      node_aligned = (tie_kdtree_t *)((TIE_PTR_CAST)(temp[i]) & ~0x7L);
a311 2
    hit_count = 0;

d313 2
d316 1
d343 3
a345 3
      v = (tfloat *)((TIE_PTR_CAST)(tri->v) & ~0x7L);
      i1 = TIE_TAB1[((TIE_PTR_CAST)(tri->v) & 0x7)];
      i2 = TIE_TAB1[3 + ((TIE_PTR_CAST)(tri->v) & 0x7)];
d427 1
a427 2
  int i, ind, step;
  void *mem;
a433 3
  step = 2 * sizeof(tfloat);
  mem = malloc(tnum * step);
  ind = 0;
d444 1
a444 2
    tie->tri_list[tie->tri_num].v = (tfloat *)&((char *)mem)[ind];
    ind += step;
@


1.33
log
@support for unknown triangle number at tie_init()
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.32 2005/09/06 01:03:23 twingy Exp $
d167 3
a169 1
  for(i = 0; i < tie->tri_num; i++)
d171 2
d174 1
@


1.32
log
@Aggressive prep is about 3.3x faster now.  Fixed a few Makefile.am's.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.31 2005/08/30 20:08:23 twingy Exp $
d145 1
a145 1
void tie_init(tie_t *tie, int tri_num) {
d148 1
d426 5
@


1.31
log
@about to try some stuff.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.30 2005/08/29 19:25:55 twingy Exp $
d117 2
a118 2
    tri->v12[0] = v1.v[i2] - tri->data[0].v[i2];
    tri->v12[1] = v2.v[i2] - tri->data[0].v[i2];
d121 1
a121 1
      tri->v12 = (tfloat *)((TIE_PTR_CAST)(tri->v12) + 2);
d123 1
a123 1
      tri->v12 = (tfloat *)((TIE_PTR_CAST)(tri->v12) + 1);
d167 1
a167 1
    free( (void *)((TIE_PTR_CAST)(tie->tri_list[i].v12) & ~0x7L) );
d337 4
a340 4
      /* Extract i1 and i2 indices from lower bits of the v12 pointer */
      v = (tfloat *)((TIE_PTR_CAST)(tri->v12) & ~0x7L);
      i1 = TIE_TAB1[((TIE_PTR_CAST)(tri->v12) & 0x7)];
      i2 = TIE_TAB1[3 + ((TIE_PTR_CAST)(tri->v12) & 0x7)];
d438 1
a438 1
    tie->tri_list[tie->tri_num].v12 = (tfloat *)&((char *)mem)[ind];
@


1.30
log
@kd-tree caching is now tuned to the point where full start-up time takes less than
1/4 the time as it did with the fast mid-split algorithm.  This number should approach
1/8 as the various parts of the packing/unpacking and caching algorithms are tuned
even further.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.29 2005/08/29 06:37:16 twingy Exp $
d366 5
a370 3
      hit_list[hit_count] = tri;
      id_list[hit_count] = t;
      hit_count++;
@


1.29
log
@Integrated kd-tree caching.
It's generated with adrt_bench by supplying the -c argument.
kdtree_cache_file,kdtree.cache goes into project.env file to make it work.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.28 2005/08/27 21:18:39 twingy Exp $
d407 10
a416 6
 * @@param v0 vertex of triangle
 * @@param v1 vertex of triangle
 * @@param v2 vertex of triangle
 * @@param ptr value to be stashed in triangle data structure for reference by the hitfunc() routine.
 * Typically, this is a pointer to a mesh data structure.  It can be anything the application hitfunc() routine might
 * want to get at from the triangle data structure.
@


1.28
log
@removed extraneous stuff
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.27 2005/08/27 21:16:37 twingy Exp $
d154 1
a154 1
 * Free up all the stuff associate with libtie
@


1.27
log
@kdtree code was put into its own separate file since it's going to consume
more than half the actual engine code.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.26 2005/08/27 06:17:50 twingy Exp $
a76 9
#ifndef HUGE
# ifdef HUGE_VAL
#  define HUGE HUGE_VAL
# else
#  define HUGE 3e23
# endif
#endif


@


1.26
log
@Adding finishing touches to algorithm.  Will be adding some controls to
tie_init to allow developer to control both agressiveness of kd-tree building
algorithm and memory consumption as a function of # of triangles.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.25 2005/08/26 22:16:24 twingy Exp $
a84 1
tfloat TIE_PREC;
a89 144

static void tie_free_node(tie_kdtree_t *node) {
  tie_kdtree_t	*node_aligned = (tie_kdtree_t*)((TIE_PTR_CAST)node & ~0x7L);

  if(((TIE_PTR_CAST)(node_aligned->data)) & 0x4) {
    /* Node Data is KDTREE Children, Recurse */
    tie_free_node(&((tie_kdtree_t*)(node_aligned->data))[0]);
    tie_free_node(&((tie_kdtree_t*)(node_aligned->data))[1]);
    free((void*)((TIE_PTR_CAST)(node_aligned->data) & ~0x7L));
  } else {
    /* This node points to a geometry node, free it */
    free(((tie_geom_t*)((TIE_PTR_CAST)(node_aligned->data) & ~0x7L))->tri_list);
    free((void*)((TIE_PTR_CAST)(node_aligned->data) & ~0x7L));
  }
}


static void tie_insert(tie_t *tie, tie_tri_t *tri_list, int tri_num) {
  tie_geom_t *g;
  TIE_3 min, max;
  int i;


  if(!tri_num)
    return;

  /* Insert all triangles into the Head Node */
  if(!tie->kdtree) {
    tie->kdtree = (tie_kdtree_t *)malloc(sizeof(tie_kdtree_t));
    tie->kdtree->data = (void *)malloc(sizeof(tie_geom_t));
    g = ((tie_geom_t *)(tie->kdtree->data));
    g->tri_num = 0;

    math_bbox(tie->min, tie->max, tri_list[0].data[0], tri_list[0].data[1], tri_list[0].data[2]);

    g->tri_list = (tie_tri_t **)malloc(sizeof(tie_tri_t *) * tri_num);

    /* form bounding box of scene */
    for(i = 0; i < tri_num; i++) {
      g->tri_list[i] = &tri_list[i];

      /* Get Bounding Box of Triangle */
      math_bbox(min, max, tri_list[i].data[0], tri_list[i].data[1], tri_list[i].data[2]);

      /* Check to see if defines a new Max or Min point */
      math_vec_min(tie->min, min);
      math_vec_max(tie->max, max);
      /* printf("Box: [%.3f, %.3f, %.3f] [%.3f, %.3f, %.3f]\n", tie->min.v[0], tie->min.v[1], tie->min.v[2], tie->max.v[0], tie->max.v[1], tie->max.v[2]); */
    }

    ((tie_geom_t *)(tie->kdtree->data))->tri_num = tri_num;
  }
}


static int tie_tri_box_overlap(TIE_3 *center, TIE_3 *half_size, TIE_3 triverts[3]) {
  /*
   * use separating axis theorem to test overlap between triangle and box
   * need to test for overlap in these directions:
   * 1) the {x,y,z}-directions (actually, since we use the AABB of the triangle
   *    we do not even need to test these)
   * 2) normal of the triangle
   * 3) crossproduct(edge from tri, {x,y,z}-directin)
   *    this gives 3x3=9 more tests
   */
  TIE_3 v0, v1, v2, normal, e0, e1, e2, fe, p;
  tfloat min, max, d, t, rad;

  /* move everything so that the boxcenter is in (0,0,0) */
  math_vec_sub(v0, triverts[0], (*center));
  math_vec_sub(v1, triverts[1], (*center));
  math_vec_sub(v2, triverts[2], (*center));

  /*
  * First test overlap in the {x,y,z}-directions
  * find min, max of the triangle each direction, and test for overlap in
  * that direction -- this is equivalent to testing a minimal AABB around
  * the triangle against the AABB
  */

  /* test in X-direction */
  math_min3(min, v0.v[0], v1.v[0], v2.v[0]);
  math_max3(max, v0.v[0], v1.v[0], v2.v[0]);
  if(min > half_size->v[0] || max < -half_size->v[0])
    return 0;

  /* test in Y-direction */
  math_min3(min, v0.v[1], v1.v[1], v2.v[1]);
  math_max3(max, v0.v[1], v1.v[1], v2.v[1]);
  if(min > half_size->v[1] || max < -half_size->v[1])
    return 0;

  /* test in Z-direction */
  math_min3(min, v0.v[2], v1.v[2], v2.v[2]);
  math_max3(max, v0.v[2], v1.v[2], v2.v[2]);
  if(min > half_size->v[2] || max < -half_size->v[2])
    return 0;

  /* compute triangle edges */
  math_vec_sub(e0, v1, v0); /* tri edge 0 */
  math_vec_sub(e1, v2, v1); /* tri edge 1 */
  math_vec_sub(e2, v0, v2); /* tri edge 2 */

  /* Perform the 9 tests */
  fe.v[0] = fabs(e0.v[0]);
  fe.v[1] = fabs(e0.v[1]);
  fe.v[2] = fabs(e0.v[2]);

  AXISTEST_X01(e0.v[2], e0.v[1], fe.v[2], fe.v[1]);
  AXISTEST_Y02(e0.v[2], e0.v[0], fe.v[2], fe.v[0]);
  AXISTEST_Z12(e0.v[1], e0.v[0], fe.v[1], fe.v[0]);

  fe.v[0] = fabs(e1.v[0]);
  fe.v[1] = fabs(e1.v[1]);
  fe.v[2] = fabs(e1.v[2]);

  AXISTEST_X01(e1.v[2], e1.v[1], fe.v[2], fe.v[1]);
  AXISTEST_Y02(e1.v[2], e1.v[0], fe.v[2], fe.v[0]);
  AXISTEST_Z0(e1.v[1], e1.v[0], fe.v[1], fe.v[0]);

  fe.v[0] = fabs(e2.v[0]);
  fe.v[1] = fabs(e2.v[1]);
  fe.v[2] = fabs(e2.v[2]);

  AXISTEST_X2(e2.v[2], e2.v[1], fe.v[2], fe.v[1]);
  AXISTEST_Y1(e2.v[2], e2.v[0], fe.v[2], fe.v[0]);
  AXISTEST_Z12(e2.v[1], e2.v[0], fe.v[1], fe.v[0]);

  /*
  * Test if the box intersects the plane of the triangle
  * compute plane equation of triangle: normal*x+d=0
  */
  math_vec_cross(normal, e0, e1);
  math_vec_dot(d, normal, v0);  /* plane eq: normal . x + d = 0 */

  p.v[0] = normal.v[0] > 0 ? half_size->v[0] : -half_size->v[0];
  p.v[1] = normal.v[1] > 0 ? half_size->v[1] : -half_size->v[1];
  p.v[2] = normal.v[2] > 0 ? half_size->v[2] : -half_size->v[2];

  math_vec_dot(t, normal, p);
  return t >= d ? 1 : 0;
}


a141 390
static void tie_build_tree(tie_t *tie, tie_kdtree_t *node, int depth, TIE_3 min, TIE_3 max, int node_a, int node_b) {
  tie_geom_t	*child[2], *node_geom_data = (tie_geom_t*)(node->data);
  TIE_3		cmin[2], cmax[2], center, half_size;
  int		i, j, n, split, cnt[2];

#if 0
  if(depth >= 24)
    printf("%f %f %f %f %f %f\n", min.v[0], min.v[1], min.v[2], max.v[0], max.v[1], max.v[2]);
#endif

  /* Terminating criteria for KDTREE subdivision */
  if(node_geom_data->tri_num <= TIE_KDTREE_NODE_MAX || depth > tie->max_depth) {
    tie->stat++;
#if 0
    if(node_geom_data->tri_num > tie->stat)
      tie->stat = node_geom_data->tri_num;
    if(node_geom_data->tri_num > tie->stat) {
      tie->stat = node_geom_data->tri_num;
      printf("depth: %d, tris: %d\n", depth, node_geom_data->tri_num);
      printf("%f %f %f %f %f %f\n", min.v[0], min.v[1], min.v[2], max.v[0], max.v[1], max.v[2]);
    }
    exit(0);
#endif
    return;
  }

#if 0
{
  /**********************
  * MID-SPLIT ALGORITHM *
  ***********************/
  TIE_3 vec;

  /* Left Child */
  cmin[0] = min;
  cmax[0] = max;

  /* Right Child */
  cmin[1] = min;
  cmax[1] = max;

  math_vec_add(center, max, min);
  math_vec_mul_scalar(center, center, 0.5);

  /* Split along largest Axis to keep node sizes relatively cube-like (Naive) */
  math_vec_sub(vec, max, min);

  /* Determine the largest Axis */
  if(vec.v[0] >= vec.v[1] && vec.v[0] >= vec.v[2]) {
    cmax[0].v[0] = center.v[0];
    cmin[1].v[0] = center.v[0];
    node->axis = center.v[0];
    split = 0;
  } else if(vec.v[1] >= vec.v[0] && vec.v[1] >= vec.v[2]) {
    cmax[0].v[1] = center.v[1];
    cmin[1].v[1] = center.v[1];
    node->axis = center.v[1];
    split = 1;
  } else {
    cmax[0].v[2] = center.v[2];
    cmin[1].v[2] = center.v[2];
    node->axis = center.v[2];
    split = 2;
  }
}
#else
{
  /******************************
  * Justin's Home Grown KD-Tree *
  *******************************/
  int slice[3][MAX_SLICES+MIN_SLICES], gap[3][2], active, split_slice;
  int side[3][MAX_SLICES+MIN_SLICES][2], d, s, k, smax[3], smin, slice_num;
  tfloat coef[3][MAX_SLICES+MIN_SLICES], split_coef, beg, end;

  /*
  * Calculate number of slices to use as a function of triangle density.
  * Slices as a function of relative node size does not work so well.
  */
  slice_num = MIN_SLICES + MAX_SLICES * ((tfloat)node_geom_data->tri_num / (tfloat)tie->tri_num);

  for(d = 0; d < 3; d++) {
    for(k = 0; k < slice_num; k++) {
      slice[d][k] = 0;
      side[d][k][0] = 0;
      side[d][k][1] = 0;

      /* Left Child */
      cmin[0] = min;
      cmax[0] = max;

      /* Right Child */
      cmin[1] = min;
      cmax[1] = max;

      /* construct slices so as not to use the boundaries as slices */
      coef[d][k] = ((tfloat)k / (tfloat)(slice_num-1)) * (tfloat)(slice_num-2) / (tfloat)slice_num + (tfloat)1 / (tfloat)slice_num;
      cmax[0].v[d] = min.v[d]*(1.0-coef[d][k]) + max.v[d]*coef[d][k];
      cmin[1].v[d] = cmax[0].v[d];

      for(i = 0; i < node_geom_data->tri_num; i++) {
        s = 0;

        for(n = 0; n < 2; n++) { /* child A and B */
          math_vec_add(center, cmax[n], cmin[n]);
          math_vec_mul_scalar(center, center, 0.5);
          math_vec_sub(half_size, cmax[n], cmin[n]);
          math_vec_mul_scalar(half_size, half_size, 0.5);

          /*
          * Check to see if any triangle points are inside of the node before
          * spending alot of cycles on the full blown triangle box overlap
          */
          for(j = 0; j < 3; j++)
            if(node_geom_data->tri_list[i]->data[j].v[0] > cmin[n].v[0] &&
               node_geom_data->tri_list[i]->data[j].v[0] < cmax[n].v[0] &&
               node_geom_data->tri_list[i]->data[j].v[1] > cmin[n].v[1] &&
               node_geom_data->tri_list[i]->data[j].v[1] < cmax[n].v[1] &&
               node_geom_data->tri_list[i]->data[j].v[2] > cmin[n].v[2] &&
               node_geom_data->tri_list[i]->data[j].v[2] < cmax[n].v[2]) {
               j = 4;
            }

          if(j == 5) {
            s++;
            side[d][k][n]++;
          } else {
            if(tie_tri_box_overlap(&center, &half_size, node_geom_data->tri_list[i]->data)) {
              s++;
              side[d][k][n]++;
            }
          }
        }

        if(s == 2)
          slice[d][k]++;
      }
    }
  }

  /* Store the max value from each of the 3 Slice arrays */
  for(d = 0; d < 3; d++) {
    smax[d] = 0;
    for(k = 0; k < slice_num; k++) {
      if(slice[d][k] > smax[d])
        smax[d] = slice[d][k];
    }
  }

  /*
  * To eliminate "empty" areas, build a list of spans where geometric complexity is
  * less than MIN_SPAN of the overal nodes size and then selecting the splitting plane
  * the corresponds to the span slice domain nearest the center to bias towards a balanced tree
  */

  for(d = 0; d < 3; d++) {
    gap[d][0] = 0;
    gap[d][1] = 0;
    beg = 0;
    end = 0;
    active = 0;

    for(k = 0; k < slice_num; k++) {
/*      printf("slice[%d][%d]: %d < %d\n", d, k, slice[d][k], (int)(MIN_DENSITY * (tfloat)smax[d])); */
      if(slice[d][k] < (int)(MIN_DENSITY * (tfloat)smax[d])) {
        if(!active) {
          active = 1;
          beg = k;
          end = k;
        } else {
          end = k;
        }
      } else {
        if(active) {
          if(end - beg > gap[d][1] - gap[d][0]) {
            gap[d][0] = beg;
            gap[d][1] = end;
          }
        }
        active = 0;
      }
    }

    if(active)
      if(end - beg > gap[d][1] - gap[d][0]) {
        gap[d][0] = beg;
        gap[d][1] = end;
      }
  }

#if 0
  printf("gap_x: %d->%d = %d\n", gap[0][0], gap[0][1], gap[0][1]-gap[0][0]);
  printf("gap_y: %d->%d = %d\n", gap[1][0], gap[1][1], gap[1][1]-gap[1][0]);
  printf("gap_z: %d->%d = %d\n", gap[2][0], gap[2][1], gap[2][1]-gap[2][0]);
#endif

  /*
  * If there is a gap atleast MIN_SPAN in side wrt the nodes dimension size
  * then use the nearest edge of the gap to 0.5 as the splitting plane,
  * Use the the gap with the largest span.
  * If no gaps are found meeting the criteria then weight the span values to
  * bias towards a balanced kd-tree and choose the minima of that weighted curve.
  */

  /* Largest gap */
  d = 0;
  if(gap[1][1] - gap[1][0] > gap[d][1] - gap[d][0])
    d = 1;
  if(gap[2][1] - gap[2][0] > gap[d][1] - gap[d][0])
    d = 2;
  
  /*
  * Largest gap found must meet MIN_SPAN requirements
  * There must be atleast 500 triangles or we don't bother.
  * Lower triangle numbers means there is a higher probability that
  * triangles lack any sort of coherent structure.
  */
  if((tfloat)(gap[d][1] - gap[d][0]) / (tfloat)slice_num > MIN_SPAN && node_geom_data->tri_num > 500) {
/*  printf("choosing slice[%d]: %d->%d :: %d tris\n", d, gap[d][0], gap[d][1], node_geom_data->tri_num); */
    split = d;
    if(abs(gap[d][0] - slice_num/2) < abs(gap[d][1] - slice_num/2)) {
      /* choose gap[d][0] as splitting plane */
      split_coef = ((tfloat)gap[d][0] / (tfloat)(slice_num-1)) * (tfloat)(slice_num-2) / (tfloat)slice_num + (tfloat)1 / (tfloat)slice_num;
      split_slice = gap[d][0];
    } else {
      /* choose gap[d][1] as splitting plane */
      split_coef = ((tfloat)gap[d][1] / (tfloat)(slice_num-1)) * (tfloat)(slice_num-2) / (tfloat)slice_num + (tfloat)1 / (tfloat)slice_num;
      split_slice = gap[d][1];
    }
  } else {
    /*
    * Weight the slices based on a heuristic driven linear scaling function to bias values
    * towards the center as more desirable.  This solves the case of a partially linear graph
    * to prevent marching to determine a desirable splitting point.  If this section of code
    * is being executed it's typically because most 'empty space' has now been eliminated
    * and/or the resulting geometry is now losing structure as the smaller cells are being
    * created, i.e dividing a fraction of a wing-nut instead of an engine-block.
    */
    for(d = 0; d < 3; d++) {
      for(k = 0; k < slice_num; k++) {
        slice[d][k] += fabs(coef[d][k]-0.5) * SCALE_COEF * smax[d];
/*        printf("%.3f %d\n", coef[d][k], slice[d][k]); */
      }
    }

    /* Choose the slice with the graphs minima as the splitting plane. */
    split = 0;
    smin = tie->tri_num;
    split_coef = 0.5;
    for(d = 0; d < 3; d++) {
      for(k = 0; k < slice_num; k++) {
        if(slice[d][k] < smin) {
          split_coef = coef[d][k];
          split = d;
          split_slice = k;
          smin = slice[d][k];
        }
      }
    }

    /*
    * If the dimension chosen to split along has a value of 0 for the maximum value
    * then the geometry was aligned such that it fell undetectable between the slices
    * and therefore was not picked up by the marching slices.  In the event that this
    * happens, choose to naively split along the middle as this last ditch decision
    * will give better results than the algorithm naively picking the first of the
    * the slices forming these irregular, short followed by a long box, splits.
    */
    if(smax[split] == 0) {
      split_coef = coef[split][slice_num / 2];
      split_slice = slice_num / 2;
    }
  }

  /*
  * Lastly, after we have supposedly chosen the most ideal splitting point,
  * check to see that the subdivision that is about to take place is worth
  * doing.  In other words, if both children have the same number of triangles
  * as the parent does then stop.
  */
  if(side[split][split_slice][0] == node_geom_data->tri_num && side[split][split_slice][1] == node_geom_data->tri_num)
    return;

#if 0
  if(side[split][split_slice][0] == node_a && side[split][split_slice][1] == node_b) {
    if(node_geom_data->tri_num < 10)
      return;
//      printf("%f %f %f %f %f %f\n", min.v[0], min.v[1], min.v[2], max.v[0], max.v[1], max.v[2]);
//      printf("moo: %d - %d\n", depth, node_geom_data->tri_num);
  }
#endif


#if 0
  printf("winner: depth: %d, dim = %d, smin = %d, coef: %.3f\n", depth, split, smin, split_coef);
  printf("winner: min: %.3f %.3f %.3f, max: %.3f %.3f %.3f, tris: %d\n", min.v[0], min.v[1], min.v[2], max.v[0], max.v[1], max.v[2], node_geom_data->tri_num);
#endif

  /* Based on the winner, construct the two child nodes */
  /* Left Child */
  cmin[0] = min;
  cmax[0] = max;

  /* Right Child */
  cmin[1] = min;
  cmax[1] = max;

  cmax[0].v[split] = min.v[split]*(1.0-split_coef) + max.v[split]*split_coef;
  cmin[1].v[split] = cmax[0].v[split];
  node->axis = cmax[0].v[split];
}
#endif


  /* Allocate 2 children nodes for the parent node */
  node->data = (void *)malloc(2 * sizeof(tie_kdtree_t));

  ((tie_kdtree_t *)(node->data))[0].data = malloc(sizeof(tie_geom_t));
  ((tie_kdtree_t *)(node->data))[1].data = malloc(sizeof(tie_geom_t));

  /* Initialize Triangle List */
  child[0] = ((tie_geom_t *)(((tie_kdtree_t *)(node->data))[0].data));
  child[1] = ((tie_geom_t *)(((tie_kdtree_t *)(node->data))[1].data));

  child[0]->tri_list = (tie_tri_t **)malloc(sizeof(tie_tri_t *) * node_geom_data->tri_num);
  child[0]->tri_num = 0;

  child[1]->tri_list = (tie_tri_t **)malloc(sizeof(tie_tri_t *) * node_geom_data->tri_num);
  child[1]->tri_num = 0;


  /* 
  * Determine if the triangles touch either of the two children nodes,
  * if it does insert it into them respectively.
  */
  for(n = 0; n < 2; n++) {
    cnt[n] = 0;

    math_vec_add(center, cmax[n], cmin[n]);
    math_vec_mul_scalar(center, center, 0.5);
    math_vec_sub(half_size, cmax[n], cmin[n]);
    math_vec_mul_scalar(half_size, half_size, 0.5);

    for(i = 0; i < node_geom_data->tri_num; i++) {
      /*
      * Check to see if any triangle points are inside of the node before
      * spending alot of cycles on the full blown triangle box overlap
      */
      for(j = 0; j < 3; j++)
        if(node_geom_data->tri_list[i]->data[j].v[0] > cmin[n].v[0] &&
           node_geom_data->tri_list[i]->data[j].v[0] < cmax[n].v[0] &&
           node_geom_data->tri_list[i]->data[j].v[1] > cmin[n].v[1] &&
           node_geom_data->tri_list[i]->data[j].v[1] < cmax[n].v[1] &&
           node_geom_data->tri_list[i]->data[j].v[2] > cmin[n].v[2] &&
           node_geom_data->tri_list[i]->data[j].v[2] < cmax[n].v[2]) {
           j = 4;
        }

      if(j == 5) {
        child[n]->tri_list[child[n]->tri_num++] = node_geom_data->tri_list[i];
        cnt[n]++;
      } else {
        if(tie_tri_box_overlap(&center, &half_size, node_geom_data->tri_list[i]->data)) {
          child[n]->tri_list[child[n]->tri_num++] = node_geom_data->tri_list[i];
          cnt[n]++;
        }
      }
    }

    /* Resize Tri List to actual ammount of memory used */
    child[n]->tri_list = (tie_tri_t **)realloc(child[n]->tri_list, sizeof(tie_tri_t *)*child[n]->tri_num);
  }

  /*
  * Now that the triangles have been propogated to the appropriate child nodes,
  * free the triangle list on this node.
  */
  node_geom_data->tri_num = 0;
  free(node_geom_data->tri_list);
  free(node_geom_data);

  /* Push each child through the same process. */
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[0], depth+1, cmin[0], cmax[0], cnt[0], cnt[1]);
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[1], depth+1, cmin[1], cmax[1], cnt[0], cnt[1]);
 
  /* Assign the splitting dimension to the node */
  /* If we've come this far then YES, this node DOES have child nodes, MARK it as so. */
  node->data = (void*)((TIE_PTR_CAST)(node->data) + split + 4);
}


d176 1
a176 1
    free( (void*)((TIE_PTR_CAST)(tie->tri_list[i].v12) & ~0x7L) );
d180 1
a180 3
  if(tie->kdtree) /* prevent tie from crashing when a tie_free() is called right after a tie_init() */
    tie_free_node(tie->kdtree);
  free(tie->kdtree);
d193 2
a194 33
  TIE_3		delta;

  tie_insert(tie, tie->tri_list, tie->tri_num);

  if(!tie->kdtree)
    return;

  /* Trim KDTREE back from power of 2 size (set during insert phase) to number of actual triangles */
  ((tie_geom_t *)(tie->kdtree->data))->tri_list = (tie_tri_t **)realloc(((tie_geom_t *)(tie->kdtree->data))->tri_list, sizeof(tie_tri_t *) * ((tie_geom_t *)(tie->kdtree->data))->tri_num);

  /*
  * Compute Floating Fuzz Precision Value
  * For now, take largest dimension as basis for TIE_PREC
  */
  math_vec_sub(delta, tie->max, tie->min);
  math_max3(TIE_PREC, delta.v[0], delta.v[1], delta.v[2]);
#if TIE_SINGLE_PREC
  TIE_PREC *= 0.000001;
#else
  TIE_PREC *= 0.000000000001;
#endif

  /* Grow the head node a little bit to avoid floating point fuzz in the building process */
  math_vec_mul_scalar(delta, delta, 2.0); // XXX
  math_vec_sub(tie->min, tie->min, delta);
  math_vec_add(tie->max, tie->max, delta);

  /* Compute Max Depth to allow the KD-Tree to grow to */
  tie->max_depth = (int)(TIE_KDTREE_DEPTH_K1 * (log(tie->tri_num) / log(2)) + TIE_KDTREE_DEPTH_K2);
  printf("max_depth: %d\n", tie->max_depth);

  /* Build the KDTREE */
  tie_build_tree(tie, tie->kdtree, 0, tie->min, tie->max, 0, 0);
a197 4

  printf("stat: %d\n", tie->stat);
/*  exit(0); */ /* uncomment to profile prep phase only */
  tie->stat = 0;
@


1.25
log
@working on final changes
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.24 2005/08/26 17:56:09 twingy Exp $
d293 1
a293 1
//  if(depth <= 4)
d545 13
a565 1
#if 0
d568 2
a569 1
#else
d571 3
a573 2
    if(node_geom_data->tri_num > 32)
      printf("%f %f %f %f %f %f\n", min.v[0], min.v[1], min.v[2], max.v[0], max.v[1], max.v[2]);
a574 1
//    return;
d578 1
d753 1
a753 1
  math_vec_mul_scalar(delta, delta, 0.01);
@


1.24
log
@kd-tree code clean-up.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.23 2005/08/26 14:57:47 twingy Exp $
d287 1
a287 1
static void tie_build_tree(tie_t *tie, tie_kdtree_t *node, int depth, TIE_3 min, TIE_3 max, tfloat cost) {
d293 1
a293 1
  if(depth <= 4)
d299 2
d303 5
a307 4
#if 0
    printf("num: %d, depth: %d\n", node_geom_data->tri_num, depth);
    if(node_geom_data->tri_num > tie->stat) */
      tie->stat++; */
d318 2
d357 2
a358 2
  int span[3][MAX_SLICES+MIN_SLICES], gap[3][2], active;
  int d, s, k, smax[3], smin, slice_num;
d369 3
a371 1
      span[d][k] = 0;
d411 1
d413 1
a413 1
            if(tie_tri_box_overlap(&center, &half_size, node_geom_data->tri_list[i]->data))
d415 2
d421 1
a421 1
          span[d][k]++;
d430 2
a431 2
      if(span[d][k] > smax[d])
        smax[d] = span[d][k];
d449 2
a450 2
/*      printf("span[%d][%d]: %d < %d\n", d, k, span[d][k], (int)(MIN_DENSITY * (tfloat)smax[d])); */
      if(span[d][k] < (int)(MIN_DENSITY * (tfloat)smax[d])) {
d504 1
a504 1
/*  printf("choosing span[%d]: %d->%d :: %d tris\n", d, gap[d][0], gap[d][1], node_geom_data->tri_num); */
d509 1
d513 1
d526 2
a527 2
        span[d][k] += fabs(coef[d][k]-0.5) * SCALE_COEF * smax[d];
/*        printf("%.3f %d\n", coef[d][k], span[d][k]); */
d537 1
a537 1
        if(span[d][k] < smin) {
d540 2
a541 1
          smin = span[d][k];
d547 18
d654 2
a655 2
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[0], depth+1, cmin[0], cmax[0], 0);
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[1], depth+1, cmin[1], cmax[1], 0);
d748 1
a748 1
  tie_build_tree(tie, tie->kdtree, 0, tie->min, tie->max, ((tie_geom_t *)(tie->kdtree->data))->tri_num);
@


1.23
log
@New kd-tree building algorithm (yet to be named) is now suitable for general purpose
use as an improvement (avg 25% - 100% faster) over the old algorithm and uses about
half the memory consumption as before.  One more criteria is yet to be added, more
improvements to come.  Algorithm is 10x slower than mid-split so kd-tree caching
is on the way.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.22 2005/08/25 23:24:36 twingy Exp $
d289 1
a289 1
  TIE_3		cmin[2], cmax[2], center, half_size, vec;
d311 1
d346 1
d352 3
a354 3
  int span[3][MAX_SLICES+9], gap[3][2], active;
  int d, s, k, smax[3], smin, slice_num[3];
  tfloat coef, split_coef, beg, end;
d356 5
a360 12
  /* Calculate the number of slices that will be used for this node */
#if 0
  /* Function of relative size */
  slice_num[0] = 7 + MAX_SLICES * ((max.v[0] - min.v[0]) / (tie->max.v[0] - tie->min.v[0]));
  slice_num[1] = 7 + MAX_SLICES * ((max.v[1] - min.v[1]) / (tie->max.v[1] - tie->min.v[1]));
  slice_num[2] = 7 + MAX_SLICES * ((max.v[2] - min.v[2]) / (tie->max.v[2] - tie->min.v[2]));
#else
  /* Function of triangle density */
  slice_num[0] = MIN_SLICES + MAX_SLICES * ((tfloat)node_geom_data->tri_num / (tfloat)tie->tri_num);
  slice_num[1] = MIN_SLICES + MAX_SLICES * ((tfloat)node_geom_data->tri_num / (tfloat)tie->tri_num);
  slice_num[2] = MIN_SLICES + MAX_SLICES * ((tfloat)node_geom_data->tri_num / (tfloat)tie->tri_num);
#endif
d363 1
a363 1
    for(k = 0; k < slice_num[d]; k++) {
d375 2
a376 2
      coef = ((tfloat)k/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
      cmax[0].v[d] = min.v[d]*(1.0-coef) + max.v[d]*coef;
d419 1
a419 1
    for(k = 0; k < slice_num[d]; k++) {
d438 1
a438 1
    for(k = 0; k < slice_num[d]; k++) {
d487 7
a493 2
  /* Largest gap > MIN_SPAN? */
  if((tfloat)(gap[d][1] - gap[d][0]) / (tfloat)slice_num[d] > MIN_SPAN && node_geom_data->tri_num > 500) {
d496 1
a496 1
    if(abs(gap[d][0] - slice_num[d]/2) < abs(gap[d][1] - slice_num[d]/2)) {
d498 1
a498 1
      split_coef = ((tfloat)gap[d][0]/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
d501 1
a501 1
      split_coef = ((tfloat)gap[d][1]/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
d513 3
a515 4
      for(k = 0; k < slice_num[d]; k++) {
        coef = ((tfloat)k/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
        span[d][k] += fabs(coef-0.5) * SCALE_COEF * smax[d];
/*        printf("%.3f %d\n", coef, span[d][k]); */
d522 1
d524 1
a524 1
      for(k = 0; k < slice_num[d]; k++) {
d526 1
a526 1
          split_coef = ((tfloat)k/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
@


1.22
log
@experimental kd-tree code finds empty space more agressively.
master is printing fps for now.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.21 2005/08/25 02:44:15 twingy Exp $
a84 7
/* KDTREE VALUES */
#define MAX_SLICES 80
#define MIN_DENSITY 0.01
#define MIN_SPAN    0.15
#define SCALE_COEF  1.80
/*****************/

d292 4
a295 1
  printf("%f %f %f %f %f %f\n", min.v[0], min.v[1], min.v[2], max.v[0], max.v[1], max.v[2]);
d299 1
a299 1
    if(node_geom_data->tri_num > tie->stat) {
d301 4
a304 5
    }

/*    printf("num: %d, depth: %d\n", node_geom_data->tri_num, depth); */
/*    if(node_geom_data->tri_num > tie->stat) */
/*      tie->stat++; */
d306 1
d311 3
d347 3
d352 1
a352 1
  tfloat coef, split_coef, smax_wgt_coef[3], beg, end;
d356 1
d361 4
a364 3
  slice_num[0] = 9 + MAX_SLICES * ((tfloat)node_geom_data->tri_num / (tfloat)tie->tri_num);
  slice_num[1] = 9 + MAX_SLICES * ((tfloat)node_geom_data->tri_num / (tfloat)tie->tri_num);
  slice_num[2] = 9 + MAX_SLICES * ((tfloat)node_geom_data->tri_num / (tfloat)tie->tri_num);
d367 2
a368 2
  for(d = 0; d < 3; d++) { // dimension
    for(k = 0; k < slice_num[d]; k++) { // slice
d384 1
a384 1
      for(i = 0; i < node_geom_data->tri_num; i++) { // triangles
d387 1
a387 1
        for(n = 0; n < 2; n++) { // child A and B
a416 1

d421 1
a421 2

  /* Grab the max value from each of the 3 Slice arrays */
d425 1
a425 1
      if(span[d][k] > smax[d]) {
a426 3
        smax_wgt_coef[d] = ((tfloat)k/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
        smax_wgt_coef[d] = 0.5;
      }
a429 2

/***************************/
d432 1
a432 1
  * less than 10% of the overal nodes size and then selecting the splitting plane
d444 1
a444 1
      printf("span[%d][%d]: %d < %d\n", d, k, span[d][k], (int)(MIN_DENSITY * (tfloat)smax[d]));
d464 1
a464 1
    if(active) {
a468 1
    }
d471 5
a475 4
//  printf("gap_x: %d->%d = %d\n", gap[0][0], gap[0][1], gap[0][1]-gap[0][0]);
//  printf("gap_y: %d->%d = %d\n", gap[1][0], gap[1][1], gap[1][1]-gap[1][0]);
//  printf("gap_z: %d->%d = %d\n", gap[2][0], gap[2][1], gap[2][1]-gap[2][0]);
/******************/
d493 10
a502 7
if((tfloat)(gap[d][1] - gap[d][0]) / (tfloat)slice_num[d] > MIN_SPAN && node_geom_data->tri_num > 500) {
  printf("choosing span[%d]: %d->%d :: %d tris\n", d, gap[d][0], gap[d][1], node_geom_data->tri_num);

  split = d;
  if(abs(gap[d][0] - slice_num[d]/2) < abs(gap[d][1] - slice_num[d]/2)) {
    /* choose gap[d][0] as splitting plane */
    split_coef = ((tfloat)gap[d][0]/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
d504 14
a517 11
    /* choose gap[d][1] as splitting plane */
    split_coef = ((tfloat)gap[d][1]/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
  }
} else {

  /* Weight the slices based on a heuristic driven linear scaling function from the center */
  for(d = 0; d < 3; d++) {
    for(k = 0; k < slice_num[d]; k++) {
      coef = ((tfloat)k/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
      span[d][k] += fabs(coef-smax_wgt_coef[d]) * SCALE_COEF * smax[d];
//      printf("%.3f %d\n", coef, span[d][k]);
a518 1
  }
d520 10
a529 9
  /* Choose the slice with the least value as the splitting plane */
  split = 0;
  smin = tie->tri_num;
  for(d = 0; d < 3; d++) {
    for(k = 0; k < slice_num[d]; k++) {
      if(span[d][k] < smin) {
        split_coef = ((tfloat)k/(tfloat)(slice_num[d]-1)) * (tfloat)(slice_num[d]-2)/(tfloat)slice_num[d] + (tfloat)1/(tfloat)slice_num[d];
        split = d;
        smin = span[d][k];
a532 1
}
a534 15
  if(node_geom_data->tri_num < 15) {
    for(i = 0; i < node_geom_data->tri_num; i++) {
      printf("tri[%d]: [%.3f %.3f %.3f] [%.3f %.3f %.3f] [%.3f %.3f %.3f]\n", 
i,
node_geom_data->tri_list[i]->data[0].v[0],
node_geom_data->tri_list[i]->data[0].v[1],
node_geom_data->tri_list[i]->data[0].v[2],
node_geom_data->tri_list[i]->data[1].v[0],
node_geom_data->tri_list[i]->data[1].v[1],
node_geom_data->tri_list[i]->data[1].v[2],
node_geom_data->tri_list[i]->data[2].v[0],
node_geom_data->tri_list[i]->data[2].v[1],
node_geom_data->tri_list[i]->data[2].v[2]);
    }
  }
d554 1
d825 1
a825 1
      i = near >= dist; // Node B Only?
@


1.21
log
@experimenting with kd-tree's
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.20 2005/08/23 17:59:52 twingy Exp $
d84 7
a90 1
#define MAX_SLICES 50
d299 1
a299 1
/*  printf("%f %f %f %f %f %f\n", min.v[0], min.v[1], min.v[2], max.v[0], max.v[1], max.v[2]); */
d310 1
d314 1
a314 1
#if 1
d348 1
a348 1
  int span[3][MAX_SLICES];
d350 1
a350 1
  tfloat coef, split_coef, smax_wgt_coef[3];
d417 2
d431 78
d513 1
a513 1
      span[d][k] += fabs(coef-smax_wgt_coef[d]) * (1.5 + depth * 0.05) * smax[d];
d530 1
a530 1

@


1.20
log
@removed min surface area, bad heuristics to use
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.19 2005/08/16 04:47:38 twingy Exp $
d84 1
a339 1
..
d341 14
a354 3
int d, s;
tfloat sa, cost_test[3][7][2];
TIE_3 vec1, vec2;
d356 3
a358 8
  /*
  * Test all 3 splitting planes
  * Test 7 possible cuts for each splitting plane test
  */
  for(d = 0; d < 3; d++) {
    /* Eight Splitting plane tests */
    for(s = 0; s < 7; s++) {
      /* Generate box sizes */
d368 38
a405 26
      math_vec_add(center, max, min);
      math_vec_mul_scalar(vec, min, ((tfloat)(s+1)));
      math_vec_mul_scalar(center, max, ((tfloat)(7-s)));
      math_vec_add(center, center, vec);
      math_vec_mul_scalar(center, center, 0.125);

      cmax[0].v[d] = center.v[d];
      cmin[1].v[d] = center.v[d];

      /* Compute cost by examining surface area of all triangles for both nodes */
      for(n = 0; n < 2; n++) {
        cnt[n] = 0;

        math_vec_add(center, cmax[n], cmin[n]);
        math_vec_mul_scalar(center, center, 0.5);
        math_vec_sub(half_size, cmax[n], cmin[n]);
        math_vec_mul_scalar(half_size, half_size, 0.5);

        /*
        * compute surface area
        * surface area of 3d triangle:
        *  1/2 (V1-V0) x (V2 - V0)
        *  where 'x' is cross product.
        */
        sa = 0;
        for(i = 0; i < node_geom_data->tri_num; i++) {
a406 2
        }
        sa /= (tfloat)node->geom_data->tri_num;
d408 22
d431 12
d445 14
d461 12
d474 3
@


1.19
log
@reverting
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.18 2005/08/16 04:19:25 twingy Exp $
a290 1
  tfloat	n1cost, n2cost, a, b;
a305 17
  /* If node area is to small with respect to scene node area then terminate */
  a = (max.v[0]-min.v[0])*(max.v[1]-min.v[1]) +
      (max.v[0]-min.v[0])*(max.v[2]-min.v[2]) + 
      (max.v[1]-min.v[1])*(max.v[2]-min.v[2]);

  b = (tie->max.v[0]-tie->min.v[0])*(tie->max.v[1]-tie->min.v[1]) +
      (tie->max.v[0]-tie->min.v[0])*(tie->max.v[2]-tie->min.v[2]) +
      (tie->max.v[1]-tie->min.v[1])*(tie->max.v[2]-tie->min.v[2]);

  /* If ratio of areas is too small then don't bother splitting */
  if(a / b <= TIE_KDTREE_MIN_AREA) {
    if(node_geom_data->tri_num > tie->stat) {
      tie->stat = node_geom_data->tri_num;
    }
    return;
  }

d469 2
a470 2
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[0], depth+1, cmin[0], cmax[0], n1cost);
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[1], depth+1, cmin[1], cmax[1], n2cost);
d720 1
a727 2
      v = (tfloat *)((TIE_PTR_CAST)(tri->v12) & ~0x7L);

@


1.18
log
@in the process of fixing adrt.py and tie.c is ~2% faster.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.17 2005/08/15 03:45:25 twingy Exp $
d614 1
a614 1
  tie_stack_t stack[40], *sptr;
a684 1
      i = near >= dist; // Node B Only?
d689 1
d696 4
a699 4
      sptr = &stack[++stack_ind];
      sptr->node = temp[1];
      sptr->near = dist;
      sptr->far = far;
d737 5
a741 6
      /*
      * Extract i1 and i2 indices from lower bits of the v12 pointer,
      * and compute U and V with them.
      */
      n = (TIE_PTR_CAST)(tri->v12) & 0x7;
      i1 = TIE_TAB1[n];
a742 1
      i2 = TIE_TAB1[3+n];
@


1.17
log
@adding local benchmark utility minus networking stuff to do benchmarking with TIE.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.16 2005/08/10 20:32:58 twingy Exp $
d614 1
a614 1
  tie_stack_t stack[40];
d685 1
a689 1
      i = near >= dist; // Node B Only?
d696 4
a699 4
      stack_ind++;
      stack[stack_ind].node = temp[1];
      stack[stack_ind].near = dist;
      stack[stack_ind].far = far;
d737 6
a742 5
      /* Extract i1 and i2 indices from lower bits of the v12 pointer */
      i1 = TIE_TAB1[((TIE_PTR_CAST)(tri->v12) & 0x7)];
      i2 = TIE_TAB1[3 + ((TIE_PTR_CAST)(tri->v12) & 0x7)];

      /* Compute U and V */
d744 1
@


1.16
log
@added surface area termination criteria
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.15 2005/08/10 05:32:08 twingy Exp $
d297 4
d302 2
a303 2
/*    if(node_geom_data->tri_num > tie->max_tri) */
/*      tie->max_tri++; */
d317 4
a320 1
  if(a / b <= TIE_KDTREE_MIN_AREA)
d322 1
a322 2

  tie->max_tri++;
d512 1
a512 1
  tie->max_tri = 0;
d586 1
a586 1
  printf("max_tri: %d\n", tie->max_tri);
d588 1
d614 3
a616 3
  tie_stack_t stack[1024];
  tie_id_t t, id_list[1024];
  tie_tri_t *hit_list[1024], *tri;
d645 1
a645 1
    far  = (tie->min.v[split] - ray->pos.v[split]) * dirinv[split];
d647 1
a647 1
    far  = (tie->max.v[split] - ray->pos.v[split]) * dirinv[split];
d703 1
d727 2
a728 1
      * aren't in a precision fuzz boundary.
@


1.15
log
@dynamic kd-tree depth calculation
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.14 2005/08/09 03:18:59 twingy Exp $
d287 1
a287 1
static void tie_build_tree(tie_t *tie, tie_kdtree_t *node, int depth, TIE_3 min, TIE_3 max, int inside) {
d291 1
a294 1
  tie->max_tri++;
d303 15
d351 60
d481 2
a482 2
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[0], depth+1, cmin[0], cmax[0], cnt[0]);
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[1], depth+1, cmin[1], cmax[1], cnt[1]);
@


1.14
log
@removed a conditional
@
text
@d31 1
a31 1
 *        - tie_prep()	build the BSP for the triangles
d45 1
a45 1
 * $Id: tie.c,v 1.13 2005/08/09 03:06:25 twingy Exp $
d52 1
a52 1
 *	@@li tie_prep()	build the BSP for the triangles
d92 2
a93 2
static void tie_free_node(tie_bsp_t *node) {
  tie_bsp_t	*node_aligned = (tie_bsp_t*)((TIE_PTR_CAST)node & ~0x7L);
d96 3
a98 3
    /* Node Data is BSP Children, Recurse */
    tie_free_node(&((tie_bsp_t*)(node_aligned->data))[0]);
    tie_free_node(&((tie_bsp_t*)(node_aligned->data))[1]);
d118 4
a121 4
  if(!tie->bsp) {
    tie->bsp = (tie_bsp_t *)malloc(sizeof(tie_bsp_t));
    tie->bsp->data = (void *)malloc(sizeof(tie_geom_t));
    g = ((tie_geom_t *)(tie->bsp->data));
d141 1
a141 1
    ((tie_geom_t *)(tie->bsp->data))->tri_num = tri_num;
d287 1
a287 1
static void tie_build_tree(tie_t *tie, tie_bsp_t *node, int depth, TIE_3 min, TIE_3 max, int inside) {
d295 2
a296 2
  /* Terminating criteria for BSP subdivision */
  if(node_geom_data->tri_num <= TIE_BSP_NODE_MAX || depth > TIE_BSP_DEPTH_MAX) {
d303 1
a311 1

a314 1
#if 1
a335 158
  /*
  * Determine which of the 3 axis has the largest sum of entirely split and contained triangles.
  * If the sum of the largest split is less than or equal to max triangles per node then terminate.
  */
{
  int x[2], y[2], z[2];

  x[0] = 0;
  x[1] = 0;
  y[0] = 0;
  y[1] = 0;
  z[0] = 0;
  z[1] = 0;

  for(i = 0; i < node_geom_data->tri_num; i++) {
    /* X0 - Test */
    n = 0;
    for(j = 0; j < 3; j++) {
      if(node_geom_data->tri_list[i]->data[j].v[0] > center.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[0] < max.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[1] > min.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[1] < max.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[2] > min.v[2] &&
         node_geom_data->tri_list[i]->data[j].v[2] < max.v[2]) {
         n++;
      }
    }
    if(n)
      x[0]++;

    /* X1 - Test */
    n = 0;
    for(j = 0; j < 3; j++) {
      if(node_geom_data->tri_list[i]->data[j].v[0] > min.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[0] < center.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[1] > min.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[1] < max.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[2] > min.v[2] &&
         node_geom_data->tri_list[i]->data[j].v[2] < max.v[2]) {
         n++;
      }
    }
    if(n)
      x[1]++;

    /* Y0 - Test */
    n = 0;
    for(j = 0; j < 3; j++) {
      if(node_geom_data->tri_list[i]->data[j].v[0] > min.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[0] < max.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[1] > center.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[1] < max.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[2] > min.v[2] &&
         node_geom_data->tri_list[i]->data[j].v[2] < max.v[2]) {
         n++;
      }
    }
    if(n)
      y[0]++;

    /* Y1 - Test */
    n = 0;
    for(j = 0; j < 3; j++) {
      if(node_geom_data->tri_list[i]->data[j].v[0] > min.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[0] < max.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[1] > min.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[1] < center.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[2] > min.v[2] &&
         node_geom_data->tri_list[i]->data[j].v[2] < max.v[2]) {
         n++;
      }
    }
    if(n)
      y[1]++;

    /* Z0 - Test */
    n = 0;
    for(j = 0; j < 3; j++) {
      if(node_geom_data->tri_list[i]->data[j].v[0] > min.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[0] < max.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[1] > min.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[1] < max.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[2] > center.v[2] &&
         node_geom_data->tri_list[i]->data[j].v[2] < max.v[2]) {
         n++;
      }
    }
    if(n)
      z[0]++;

    /* Z1 - Test */
    n = 0;
    for(j = 0; j < 3; j++) {
      if(node_geom_data->tri_list[i]->data[j].v[0] > min.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[0] < max.v[0] &&
         node_geom_data->tri_list[i]->data[j].v[1] > min.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[1] < max.v[1] &&
         node_geom_data->tri_list[i]->data[j].v[2] > min.v[2] &&
         node_geom_data->tri_list[i]->data[j].v[2] < center.v[2]) {
         n++;
      }
    }
    if(n)
      z[1]++;
      
  }

//  if(x[0]+x[1] <= TIE_BSP_NODE_MAX && y[0]+y[1] <= TIE_BSP_NODE_MAX && z[0]+z[1] <= TIE_BSP_NODE_MAX) {
  if(x[0]+x[1] == 0 && y[0]+y[1] == 0 && z[0]+z[1] == 0) {
    /* DONE! */
    tie->max_tri++;
    return;
  }

#if 0
  /* Determine the largest sum */
  if(x[0]+x[1] <= y[0]+y[1] && x[0]+x[1] <= z[0]+z[1]) {
    cmax[0].v[0] = center.v[0];
    cmin[1].v[0] = center.v[0];
    node->axis = center.v[0];
    split = 0;
  } else if(y[0]+y[1] <= x[0]+x[1] && y[0]+y[1] <= z[0]+z[1]) {
    cmax[0].v[1] = center.v[1];
    cmin[1].v[1] = center.v[1];
    node->axis = center.v[1];
    split = 1;
  } else {
    cmax[0].v[2] = center.v[2];
    cmin[1].v[2] = center.v[2];
    node->axis = center.v[2];
    split = 2;
  }

#else
  /* Split along largest Axis to keep node sizes relatively cube-like (Naive) */
  math_vec_sub(vec, max, min);

  /* Determine the largest Axis */
  if(vec.v[0] >= vec.v[1] && vec.v[0] >= vec.v[2]) {
    cmax[0].v[0] = center.v[0];
    cmin[1].v[0] = center.v[0];
    node->axis = center.v[0];
    split = 0;
  } else if(vec.v[1] >= vec.v[0] && vec.v[1] >= vec.v[2]) {
    cmax[0].v[1] = center.v[1];
    cmin[1].v[1] = center.v[1];
    node->axis = center.v[1];
    split = 1;
  } else {
    cmax[0].v[2] = center.v[2];
    cmin[1].v[2] = center.v[2];
    node->axis = center.v[2];
    split = 2;
  }

#endif
}

d339 1
a339 1
  node->data = (void *)malloc(2 * sizeof(tie_bsp_t));
d341 2
a342 2
  ((tie_bsp_t *)(node->data))[0].data = malloc(sizeof(tie_geom_t));
  ((tie_bsp_t *)(node->data))[1].data = malloc(sizeof(tie_geom_t));
d345 2
a346 2
  child[0] = ((tie_geom_t *)(((tie_bsp_t *)(node->data))[0].data));
  child[1] = ((tie_geom_t *)(((tie_bsp_t *)(node->data))[1].data));
d406 2
a407 2
  tie_build_tree(tie, &((tie_bsp_t *)(node->data))[0], depth+1, cmin[0], cmax[0], cnt[0]);
  tie_build_tree(tie, &((tie_bsp_t *)(node->data))[1], depth+1, cmin[1], cmax[1], cnt[1]);
d428 1
a428 1
  tie->bsp = NULL;
d438 1
a438 1
 * All of the BSP nodes and triangles that we have allocated need to
d452 4
a455 4
  /* Free BSP Nodes */
  if(tie->bsp) /* prevent tie from crashing when a tie_free() is called right after a tie_init() */
    tie_free_node(tie->bsp);
  free(tie->bsp);
d462 1
a462 1
 * Build the BSP tree for the triangles we have
d472 1
a472 1
  if(!tie->bsp)
d475 2
a476 2
  /* Trim BSP back from power of 2 size (set during insert phase) to number of actual triangles */
  ((tie_geom_t *)(tie->bsp->data))->tri_list = (tie_tri_t **)realloc(((tie_geom_t *)(tie->bsp->data))->tri_list, sizeof(tie_tri_t *) * ((tie_geom_t *)(tie->bsp->data))->tri_num);
d478 4
a482 1
  /* For now, take largest dimension as basis for TIE_PREC */
d489 1
d495 6
a500 1
  tie_build_tree(tie, tie->bsp, 0, tie->min, tie->max, ((tie_geom_t *)(tie->bsp->data))->tri_num);
d502 1
a502 1
/*  printf("count: %d\n", tie->count); */
d536 1
a536 1
  tie_bsp_t *node_aligned, *temp[2];
d542 1
a542 1
  if(!tie->bsp)
d545 1
a545 1
  ray->bsp_depth = 0;
d558 2
a559 2
  /* Extracting value of splitting plane from tie->bsp pointer */
  split = ((TIE_PTR_CAST)(((tie_bsp_t *)((TIE_PTR_CAST)tie->bsp & ~0x7L))->data)) & 0x3;
d569 1
a569 1
  stack[0].node = tie->bsp;
d582 1
a582 1
    node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)stack[stack_ind].node & ~0x7L);
d586 1
a586 1
    * BSP TRAVERSAL
d596 1
a596 1
      ray->bsp_depth++;
d604 2
a605 2
      temp[0] = &((tie_bsp_t *)(node_aligned->data))[ab[split]];
      temp[1] = &((tie_bsp_t *)(node_aligned->data))[1-ab[split]];
d608 1
a608 1
      node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)(temp[i]) & ~0x7L);
d623 1
a623 1
    * This part of the function is being executed because the BSP Traversal is Complete.
d642 1
a642 1
      * Intersection point on triangle must lie within the bsp node or it is rejected
@


1.13
log
@another cvs commit test.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.12 2005/08/08 00:44:55 twingy Exp $
d686 1
a686 1
  tie_bsp_t *node_aligned;
d754 5
a758 5
      /* Nearest Node - Only */
      if(far < dist) {
        node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)(&((tie_bsp_t *)(node_aligned->data))[ab[split]]) & ~0x7L);
        continue;
      }
d760 1
a760 3
      /* Furthest Node - Only */
      if(dist < near) {
        node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)(&((tie_bsp_t *)(node_aligned->data))[1-ab[split]]) & ~0x7L);
a761 1
      }
d765 1
a765 1
      stack[stack_ind].node = &((tie_bsp_t *)(node_aligned->data))[1-ab[split]];
a768 1
      node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)(&((tie_bsp_t *)(node_aligned->data))[ab[split]]) & ~0x7L);
@


1.12
log
@TIE is now more than 5% faster for incoherent rays.
It now properly uses ray segments.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.11 2005/07/29 17:48:17 twingy Exp $
a889 1

@


1.11
log
@* Adjusted colors for plane and spall.
* Fixed the axis aligned geometry intersections.
* Added in_hit to observer overlay
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.10 2005/07/28 00:28:29 twingy Exp $
d687 2
a688 2
  tfloat near, far, dirinv[3];
  int i, n, stack_ind, hit_count;
d698 3
a700 4
   * Precompute direction inverse since it's used in a bunch of divides,
   * this allows those divides to become fast multiplies.
   */

d705 1
d709 5
a713 3
  i = ((TIE_PTR_CAST)(((tie_bsp_t *)((TIE_PTR_CAST)tie->bsp & ~0x7L))->data)) & 0x3;
  if(ray->dir.v[i] < 0) {
    far = (tie->min.v[i] - ray->pos.v[i]) * dirinv[i];
d715 1
a715 1
    far = (tie->max.v[i] - ray->pos.v[i]) * dirinv[i];
a717 2
  /* Determine Geometry with Closest Intersection Pt */
  id->dist = 0;
d723 1
a732 1

d738 6
a743 4
    * The side of the splitting plane wrt ray position, the sign of the ray direction,
    * and the distance wrt Near and Far are used to generate 8 possible cases to
    * determine if nodes: A&B, A, or B are hit.
    * The following is an optimized and simplified form of the above logic.
d746 3
a748 5
      int split;
      tfloat distance_t;
 
     ray->bsp_depth++;
     /* Retreive the splitting plane */
a749 1
      distance_t = (node_aligned->axis - ray->pos.v[split]) * dirinv[split];
d751 2
d754 10
a763 28
      if(ray->pos.v[split] < node_aligned->axis) {
        if(ray->dir.v[split] >= 0 && distance_t < near) {
          node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)(&((tie_bsp_t *)(node_aligned->data))[1]) & ~0x7L);
        } else {
          if(distance_t >= near && distance_t <= far) {
            /* Intersect Node A then B */
            stack_ind++;
            stack[stack_ind].node = &((tie_bsp_t *)(node_aligned->data))[1];
            stack[stack_ind].near = distance_t;
            stack[stack_ind].far = far;
            far = distance_t;
          }
          node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)(&((tie_bsp_t *)(node_aligned->data))[0]) & ~0x7L);
        }
      } else {
        if(ray->dir.v[split] < 0 && distance_t < near) {
          node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)(&((tie_bsp_t *)(node_aligned->data))[0]) & ~0x7L);
        } else {
          if(distance_t >= near && distance_t <= far) {
            /* Intersect Node B then A */
            stack_ind++;
            stack[stack_ind].node = &((tie_bsp_t *)(node_aligned->data))[0];
            stack[stack_ind].near = distance_t;
            stack[stack_ind].far = far;
            far = distance_t;
          }
          node_aligned = (tie_bsp_t *)((TIE_PTR_CAST)(&((tie_bsp_t *)(node_aligned->data))[1]) & ~0x7L);
        }
d765 8
a774 1

d776 2
a777 1
    * RAY/TRIANGLE INTERSECTION - Only gets executed on geometry nodes - BSP Traversal Complete
d817 4
a820 1
      /* Make sure barycentric coordinates fall within the boundaries of the triangle plane */
a841 2
    if(!hit_count)
      continue;
d843 1
a843 1
    /* If we hit something, then */
@


1.10
log
@* Overall load time for all 8 nodes during startup is 25% faster.
* File size of adrt mesh is now 33% smaller.  It uses shortst when trinum
  of the mesh is under 64K triangles.
* Prep data to slaves is now multi-threaded (all slaves get data from
  master at the same time, heavy network load).
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.9 2005/07/26 16:28:05 twingy Exp $
d806 2
d809 1
a809 1
      if(t.dist < near || t.dist > far)
@


1.9
log
@Fixed AE for keith and removed origin AE stuff....  Fixed component view and
left bsp depth viewing in.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.8 2005/07/20 21:38:48 twingy Exp $
d498 1
a498 1
  node->data = (void*)malloc(sizeof(tie_bsp_t)*2);
d504 2
a505 2
  child[0] = ((tie_geom_t *)(((tie_bsp_t*)(node->data))[0].data));
  child[1] = ((tie_geom_t *)(((tie_bsp_t*)(node->data))[1].data));
d507 1
a507 1
  child[0]->tri_list = (tie_tri_t**)malloc(sizeof(tie_tri_t*) * node_geom_data->tri_num);
d510 1
a510 1
  child[1]->tri_list = (tie_tri_t**)malloc(sizeof(tie_tri_t*) * node_geom_data->tri_num);
@


1.8
log
@committing before I do a whole bunch of horribly nasty optimization testing fu
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.7 2005/07/20 18:37:06 twingy Exp $
d299 1
a299 2
//      tie->max_tri++;
/*    tie->count += node_geom_data->tri_num; */
a589 1
  tie->count = 0;
a691 1
ray->depth = 0;
d695 2
d747 1
a747 1
ray->depth++;
@


1.7
log
@* Data on demand to nodes (~20% mem savings).
* tlist memory leak in unpack.c fixed.
* BSP Depth Visualization rendering method.
* Split Plane Coloring
* Testing more efficient BSP methods.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.6 2005/07/08 20:00:48 twingy Exp $
d316 1
a316 1
#if 0
d775 1
a775 1
            stack[stack_ind].node = &((tie_bsp_t *)(node_aligned -> data))[0];
@


1.6
log
@bug fix, adding more component net stuff.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.5 2005/07/05 15:05:33 twingy Exp $
d235 38
a272 28
static void tie_tri_prep(tie_tri_t *tri) {
  TIE_3		v1, v2, u, v;
  int		i1, i2;

  v1 = tri->data[1];
  v2 = tri->data[2];

  /* Compute Normal */
  math_vec_sub(u, tri->data[1], tri->data[0]);
  math_vec_sub(v, tri->data[2], tri->data[0]);
  math_vec_cross(tri->data[1], u, v);
  math_vec_unitize(tri->data[1]);

  /* Compute i1 and i2 */
  u.v[0] = fabs(tri->data[1].v[0]);
  u.v[1] = fabs(tri->data[1].v[1]);
  u.v[2] = fabs(tri->data[1].v[2]);

  if(u.v[2] > u.v[1] && u.v[2] > u.v[0]) {
    i1 = 0;
    i2 = 1;
  } else if(u.v[1] > u.v[2] && u.v[1] > u.v[0]) {
    i1 = 0;
    i2 = 2;
  } else {
    i1 = 1;
    i2 = 2;
  }
d274 5
a278 5
  /* compute u1, v2, u2, v2 */
  tri->data[2].v[1] = v1.v[i1] - tri->data[0].v[i1];
  tri->data[2].v[2] = v2.v[i1] - tri->data[0].v[i1];
  tri->v12[0] = v1.v[i2] - tri->data[0].v[i2];
  tri->v12[1] = v2.v[i2] - tri->data[0].v[i2];
d280 3
a282 4
  if(i1 == 0 && i2 == 1) {
    tri->v12 = (tfloat *)((TIE_PTR_CAST)(tri->v12) + 2);
  } else if (i1 == 0) {
    tri->v12 = (tfloat *)((TIE_PTR_CAST)(tri->v12) + 1);
a283 4

  /* Compute DotVN */
  math_vec_mul_scalar(v1, tri->data[0], -1.0);
  math_vec_dot(tri->data[2].v[0], v1, tri->data[1]);
d294 1
d299 1
a299 1
      tie->max_tri++;
d316 1
a316 1
#if 1
d454 1
a454 1
  if(x[0]+x[1] >= y[0]+y[1] && x[0]+x[1] >= z[0]+z[1]) {
d459 1
a459 1
  } else if(y[0]+y[1] >= x[0]+x[1] && y[0]+y[1] >= z[0]+z[1]) {
a628 1
  int		i;
a630 1

d637 1
a637 1
  ((tie_geom_t*)(tie->bsp->data))->tri_list = (tie_tri_t**)realloc(((tie_geom_t*)(tie->bsp->data))->tri_list, sizeof(tie_tri_t*) * ((tie_geom_t*)(tie->bsp->data))->tri_num);
a638 1
/*    printf("Building BSP: [%.3f,%.3f,%.3f], [%.3f,%.3f,%.3f]\n", iBSPRoot -> Min.v[0], iBSPRoot -> Min.v[1], iBSPRoot -> Min.v[2], iBSPRoot -> Max.v[0], iBSPRoot -> Max.v[1], iBSPRoot -> Max.v[2]); */
d652 1
a652 1
  tie_build_tree(tie, tie->bsp, 0, tie->min, tie->max, ((tie_geom_t*)(tie->bsp->data))->tri_num);
d655 1
a655 2
  for(i = 0; i < tie->tri_num; i++)
    tie_tri_prep(&tie->tri_list[i]);
d694 1
d748 1
d897 1
@


1.6.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d31 1
a31 1
 *        - tie_prep()	build the KDTREE for the triangles
d45 1
a45 1
 * $Id: tie.c,v 1.16 2005/08/10 20:32:58 twingy Exp $
d52 1
a52 1
 *	@@li tie_prep()	build the KDTREE for the triangles
d92 2
a93 2
static void tie_free_node(tie_kdtree_t *node) {
  tie_kdtree_t	*node_aligned = (tie_kdtree_t*)((TIE_PTR_CAST)node & ~0x7L);
d96 3
a98 3
    /* Node Data is KDTREE Children, Recurse */
    tie_free_node(&((tie_kdtree_t*)(node_aligned->data))[0]);
    tie_free_node(&((tie_kdtree_t*)(node_aligned->data))[1]);
d118 4
a121 4
  if(!tie->kdtree) {
    tie->kdtree = (tie_kdtree_t *)malloc(sizeof(tie_kdtree_t));
    tie->kdtree->data = (void *)malloc(sizeof(tie_geom_t));
    g = ((tie_geom_t *)(tie->kdtree->data));
d141 1
a141 1
    ((tie_geom_t *)(tie->kdtree->data))->tri_num = tri_num;
d235 28
a262 32
static void tie_tri_prep(tie_t *tie) {
  TIE_3 v1, v2, u, v;
  int i, i1, i2;
  tie_tri_t *tri;

  for(i = 0; i < tie->tri_num; i++) {
    tri = &tie->tri_list[i];

    v1 = tri->data[1];
    v2 = tri->data[2];

    /* Compute Normal */
    math_vec_sub(u, tri->data[1], tri->data[0]);
    math_vec_sub(v, tri->data[2], tri->data[0]);
    math_vec_cross(tri->data[1], u, v);
    math_vec_unitize(tri->data[1]);

    /* Compute i1 and i2 */
    u.v[0] = fabs(tri->data[1].v[0]);
    u.v[1] = fabs(tri->data[1].v[1]);
    u.v[2] = fabs(tri->data[1].v[2]);

    if(u.v[2] > u.v[1] && u.v[2] > u.v[0]) {
      i1 = 0;
      i2 = 1;
    } else if(u.v[1] > u.v[2] && u.v[1] > u.v[0]) {
      i1 = 0;
      i2 = 2;
    } else {
      i1 = 1;
      i2 = 2;
    }
d264 5
a268 5
    /* compute u1, v2, u2, v2 */
    tri->data[2].v[1] = v1.v[i1] - tri->data[0].v[i1];
    tri->data[2].v[2] = v2.v[i1] - tri->data[0].v[i1];
    tri->v12[0] = v1.v[i2] - tri->data[0].v[i2];
    tri->v12[1] = v2.v[i2] - tri->data[0].v[i2];
d270 5
a274 5
    if(i1 == 0 && i2 == 1) {
      tri->v12 = (tfloat *)((TIE_PTR_CAST)(tri->v12) + 2);
    } else if (i1 == 0) {
      tri->v12 = (tfloat *)((TIE_PTR_CAST)(tri->v12) + 1);
    }
d276 3
a278 4
    /* Compute DotVN */
    math_vec_mul_scalar(v1, tri->data[0], -1.0);
    math_vec_dot(tri->data[2].v[0], v1, tri->data[1]);
  }
d282 1
a282 1
static void tie_build_tree(tie_t *tie, tie_kdtree_t *node, int depth, TIE_3 min, TIE_3 max, tfloat cost) {
a285 1
  tfloat	n1cost, n2cost, a, b;
d289 2
a290 2
  /* Terminating criteria for KDTREE subdivision */
  if(node_geom_data->tri_num <= TIE_KDTREE_NODE_MAX || depth > tie->max_depth) {
d293 2
a294 1
/*      tie->max_tri++; */
a297 16
  /* If node area is to small with respect to scene node area then terminate */
  a = (max.v[0]-min.v[0])*(max.v[1]-min.v[1]) +
      (max.v[0]-min.v[0])*(max.v[2]-min.v[2]) + 
      (max.v[1]-min.v[1])*(max.v[2]-min.v[2]);

  b = (tie->max.v[0]-tie->min.v[0])*(tie->max.v[1]-tie->min.v[1]) +
      (tie->max.v[0]-tie->min.v[0])*(tie->max.v[2]-tie->min.v[2]) +
      (tie->max.v[1]-tie->min.v[1])*(tie->max.v[2]-tie->min.v[2]);

  /* If ratio of areas is too small then don't bother splitting */
  if(a / b <= TIE_KDTREE_MIN_AREA)
    return;

  tie->max_tri++;

#if 1
d306 1
d310 1
a331 6
..
{
int d, s;
tfloat sa, cost_test[3][7][2];
TIE_3 vec1, vec2;

d333 2
a334 2
  * Test all 3 splitting planes
  * Test 7 possible cuts for each splitting plane test
d336 2
a337 39
  for(d = 0; d < 3; d++) {
    /* Eight Splitting plane tests */
    for(s = 0; s < 7; s++) {
      /* Generate box sizes */

      /* Left Child */
      cmin[0] = min;
      cmax[0] = max;

      /* Right Child */
      cmin[1] = min;
      cmax[1] = max;

      math_vec_add(center, max, min);
      math_vec_mul_scalar(vec, min, ((tfloat)(s+1)));
      math_vec_mul_scalar(center, max, ((tfloat)(7-s)));
      math_vec_add(center, center, vec);
      math_vec_mul_scalar(center, center, 0.125);

      cmax[0].v[d] = center.v[d];
      cmin[1].v[d] = center.v[d];

      /* Compute cost by examining surface area of all triangles for both nodes */
      for(n = 0; n < 2; n++) {
        cnt[n] = 0;

        math_vec_add(center, cmax[n], cmin[n]);
        math_vec_mul_scalar(center, center, 0.5);
        math_vec_sub(half_size, cmax[n], cmin[n]);
        math_vec_mul_scalar(half_size, half_size, 0.5);

        /*
        * compute surface area
        * surface area of 3d triangle:
        *  1/2 (V1-V0) x (V2 - V0)
        *  where 'x' is cross product.
        */
        sa = 0;
        for(i = 0; i < node_geom_data->tri_num; i++) {
d339 18
a356 2
        }
        sa /= (tfloat)node->geom_data->tri_num;
d358 3
d362 14
d377 14
d392 11
d404 81
d487 1
d489 1
d493 1
a493 1
  node->data = (void *)malloc(2 * sizeof(tie_kdtree_t));
d495 2
a496 2
  ((tie_kdtree_t *)(node->data))[0].data = malloc(sizeof(tie_geom_t));
  ((tie_kdtree_t *)(node->data))[1].data = malloc(sizeof(tie_geom_t));
d499 2
a500 2
  child[0] = ((tie_geom_t *)(((tie_kdtree_t *)(node->data))[0].data));
  child[1] = ((tie_geom_t *)(((tie_kdtree_t *)(node->data))[1].data));
d502 1
a502 1
  child[0]->tri_list = (tie_tri_t **)malloc(sizeof(tie_tri_t *) * node_geom_data->tri_num);
d505 1
a505 1
  child[1]->tri_list = (tie_tri_t **)malloc(sizeof(tie_tri_t *) * node_geom_data->tri_num);
d560 2
a561 2
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[0], depth+1, cmin[0], cmax[0], n1cost);
  tie_build_tree(tie, &((tie_kdtree_t *)(node->data))[1], depth+1, cmin[1], cmax[1], n2cost);
d582 1
a582 1
  tie->kdtree = NULL;
d585 1
d593 1
a593 1
 * All of the KDTREE nodes and triangles that we have allocated need to
d607 4
a610 4
  /* Free KDTREE Nodes */
  if(tie->kdtree) /* prevent tie from crashing when a tie_free() is called right after a tie_init() */
    tie_free_node(tie->kdtree);
  free(tie->kdtree);
d617 1
a617 1
 * Build the KDTREE tree for the triangles we have
d623 1
d626 1
d629 1
a629 1
  if(!tie->kdtree)
d632 2
a633 2
  /* Trim KDTREE back from power of 2 size (set during insert phase) to number of actual triangles */
  ((tie_geom_t *)(tie->kdtree->data))->tri_list = (tie_tri_t **)realloc(((tie_geom_t *)(tie->kdtree->data))->tri_list, sizeof(tie_tri_t *) * ((tie_geom_t *)(tie->kdtree->data))->tri_num);
d635 1
a635 4
  /*
  * Compute Floating Fuzz Precision Value
  * For now, take largest dimension as basis for TIE_PREC
  */
d637 1
a643 1

d649 1
a649 3
  /* Compute Max Depth to allow the KD-Tree to grow to */
  tie->max_depth = (int)(TIE_KDTREE_DEPTH_K1 * (log(tie->tri_num) / log(2)) + TIE_KDTREE_DEPTH_K2);
  printf("max_depth: %d\n", tie->max_depth);
d651 3
a653 5
  /* Build the KDTREE */
  tie_build_tree(tie, tie->kdtree, 0, tie->min, tie->max, ((tie_geom_t *)(tie->kdtree->data))->tri_num);

  /* Prep all the triangles */
  tie_tri_prep(tie);
d686 3
a688 3
  tie_kdtree_t *node_aligned, *temp[2];
  tfloat near, far, dirinv[3], dist;
  int i, n, ab[3], split, stack_ind, hit_count;
d692 1
a692 1
  if(!tie->kdtree)
d695 4
a698 1
  ray->kdtree_depth = 0;
a699 4
  /*
  * Precompute direction inverse since it's used in a bunch of divides,
  * this allows those divides to become fast multiplies.
  */
a703 1
    ab[i] = dirinv[i] < 0 ? 1 : 0;
d706 4
a709 6
  /* Extracting value of splitting plane from tie->kdtree pointer */
  split = ((TIE_PTR_CAST)(((tie_kdtree_t *)((TIE_PTR_CAST)tie->kdtree & ~0x7L))->data)) & 0x3;

  /* Initialize ray segment */
  if(ray->dir.v[split] < 0) {
    far  = (tie->min.v[split] - ray->pos.v[split]) * dirinv[split];
d711 1
a711 1
    far  = (tie->max.v[split] - ray->pos.v[split]) * dirinv[split];
d714 2
d717 1
a717 1
  stack[0].node = tie->kdtree;
a720 1
  /* Process items on the stack */
d729 2
a730 1
    node_aligned = (tie_kdtree_t *)((TIE_PTR_CAST)stack[stack_ind].node & ~0x7L);
d734 1
a734 6
    * KDTREE TRAVERSAL
    *
    * 3 conditions can happen here:
    *   - Ray only intersects the nearest node
    *   - Ray only intersects the furthest node
    *   - Ray intersects both nodes, pushing the furthest onto the stack
d736 4
a739 1
    * Gordon Stoll's Mantra - Rays are Measured in Millions :-)
d742 4
a745 3
      ray->kdtree_depth++;

      /* Retreive the splitting plane */
d747 1
a748 2
      /* Calculate the projected 1d distance to splitting axis */
      dist = (node_aligned->axis - ray->pos.v[split]) * dirinv[split];
d750 30
a779 2
      temp[0] = &((tie_kdtree_t *)(node_aligned->data))[ab[split]];
      temp[1] = &((tie_kdtree_t *)(node_aligned->data))[1-ab[split]];
a780 13
      i = near >= dist; // Node B Only?
      node_aligned = (tie_kdtree_t *)((TIE_PTR_CAST)(temp[i]) & ~0x7L);

      if(far < dist || i)
        continue;

      /* Nearest Node and Push Furthest */
      stack_ind++;
      stack[stack_ind].node = temp[1];
      stack[stack_ind].near = dist;
      stack[stack_ind].far = far;
      far = dist;
    }
d783 1
a783 2
    * RAY/TRIANGLE INTERSECTION - Only gets executed on geometry nodes.
    * This part of the function is being executed because the KDTREE Traversal is Complete.
d802 1
a802 3
      * Intersection point on triangle must lie within the kdtree node or it is rejected
      * Apply TIE_PREC to near and far such that triangles that lie on orthogonal planes
      * aren't in a precision fuzz boundary.
d804 1
a804 1
      if(t.dist < near-TIE_PREC || t.dist > far+TIE_PREC)
d821 1
a821 4
      /*
      * Compute the barycentric coordinates, and make sure the coordinates
      * fall within the boundaries of the triangle plane.
      */
d843 2
d846 1
a846 1
    /* If we hit something, then sort the hit triangles on demand */
@


1.5
log
@experimenting with more efficient BSP building methods.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.4 2005/06/18 21:58:58 twingy Exp $
d310 1
a310 1
#if 0
@


1.4
log
@Added licensing info to libtexture files.
@
text
@d45 1
a45 1
 * $Id: tie.c,v 1.3 2005/06/18 00:49:06 twingy Exp $
d309 2
d331 114
d446 45
d655 1
a655 1
/*  printf("max_tri: %d\n", tie->max_tri); */
@


1.3
log
@Added licensing info to libtie files.
@
text
@d2 3
a22 3
 */
/** @@file tie.c
 *                     T I E . C
d24 13
a36 1
 *  Triangle Intersection Engine
d45 1
a45 14
 * @@brief support routines for shooting at triangles
 *
 * The calling sequence is as follows:
 *	- tie_init()	initialize the data structure
 *	- tie_push()	add triangles to the universe to be raytraced
 *	- tie_prep()	build the BSP for the triangles
 *	- tie_work()	shoot some ray
 *	- tie_work()	shoot some ray
 *	- tie_work()	shoot some ray
 *	- tie_work()	shoot some ray
 *	- tie_work()	shoot some ray
 *	- tie_free()	Free up all the memory
 *
 * $Id: tie.c,v 1.1 2005/06/17 15:09:27 lbutler Exp $
d61 1
@


1.2
log
@use brlcad_config.h instead of config.h
@
text
@d1 5
a5 1
/** @@addtogroup libtie
d7 13
a19 12
 * The calling sequence is as follows:
 *	@@li tie_init()	initialize the data structure
 *	@@li tie_push()	add triangles to the universe to be raytraced
 *	@@li tie_prep()	build the BSP for the triangles
 *	@@li tie_work()	shoot some ray
 *	@@li tie_work()	shoot some ray
 *	@@li tie_work()	shoot some ray
 *	@@li tie_work()	shoot some ray
 *	@@li tie_work()	shoot some ray
 *	@@li tie_free()	Free up all the memory
 * @@{
 * $Id: tie.c,v 1.1 2005/06/17 15:09:27 lbutler Exp $
d22 10
d45 16
a61 1

@


1.1
log
@Welcome ADRT
@
text
@d14 1
a14 1
 * $Id: tie.c,v 1.46 2005/06/14 04:29:57 justin Exp $
d33 1
a33 1
# include "config.h"
@

