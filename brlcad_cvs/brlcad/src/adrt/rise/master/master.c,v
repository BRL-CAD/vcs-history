head	1.18;
access;
symbols
	rel-7-10-4:1.18
	STABLE:1.18.0.2
	rel-7-10-2:1.17
	rel-7-10-0:1.17
	rel-7-8-4:1.11
	rel-7-8-2:1.11
	rel-7-8-0:1.11
	trimnurbs-branch:1.11.0.4
	help:1.11
	temp_tag:1.11
	bobWinPort-20051223-freeze:1.9
	postmerge-20051223-bobWinPort:1.11
	premerge-20051223-bobWinPort:1.11
	rel-7-6-6:1.11
	rel-7-6-4:1.11
	rel-7-6-2:1.11
	rel-7-6-branch:1.11.0.2
	rel-7-6-0:1.11
	rel-7-4-2:1.5.2.1
	rel-7-4-branch:1.5.0.2
	bobWinPort:1.9.0.2
	rel-7-4-0:1.5;
locks; strict;
comment	@ * @;


1.18
date	2007.08.30.19.11.30;	author brlcad;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.20.20.05.08;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.08.06.49.19;	author brlcad;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.02.19.46.37;	author erikgreenwald;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.27.01.41.31;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.23.01.13.23;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.21.00.53.11;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.08.05.11.21;	author twingy;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.16.04.18.20;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.15.03.45.25;	author twingy;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.10.20.32.58;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.29.21.40.07;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.20.18.37.07;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.01.21.07.54;	author twingy;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2005.06.25.03.13.29;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.23.04.55.51;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.21.04.32.35;	author twingy;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.17.15.09.29;	author lbutler;	state Exp;
branches;
next	;

1.5.2.1
date	2005.08.16.21.03.47;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.18
log
@TFLOAT changed to tfloat.  also quell a few warnings/bugs related to passing the wrong TIE_3 pointer type.
@
text
@/*                        M A S T E R . C
 * BRL-CAD / ADRT
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file master.c
 *
 *  Author -
 *      Justin L. Shumaker
 *
 */

#include "master.h"
#include <math.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
/*** lib common ***/
#include "canim.h"
#include "cdb.h"
#include "pack.h"
/*** lib util ***/
#include "image.h"
#include "umath.h"
/**** rise ****/
#include "dispatcher.h"
#include "post.h"
#include "rise.h"
/*** Networking Includes ***/
#include "tienet.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#if RISE_USE_COMPRESSION
  #include <zlib.h>
#endif


/* socket structure */
typedef struct rise_master_socket_s {
  int num;
  tienet_sem_t update_sem;
  struct rise_master_socket_s *prev;
  struct rise_master_socket_s *next;
} rise_master_socket_t;


void rise_master(int port, int obs_port, char *proj, char *list, char *exec, int interval);
void rise_master_result(void *res_buf, int res_len);
void* rise_master_networking(void *ptr);

int rise_master_tile_num;
int rise_master_work_ind;

tienet_sem_t rise_master_frame_sem;

void *rise_master_frame;

pthread_t rise_master_networking_thread;
int rise_master_active_connections, rise_master_alive;
rise_master_socket_t *rise_master_socklist;
common_db_t db;


void rise_master(int port, int obs_port, char *proj, char *list, char *exec, int interval) {
  int i, app_size;
  void *app_data;
  char image_name[16];


  rise_master_work_ind = 0;
  tienet_sem_init(&rise_master_frame_sem, 0);

  /* initialize the semaphore for frame updates */
  rise_master_active_connections = 0;

  rise_master_alive = 1;

  /* Parse Env Data */
  common_db_load(&db, proj);

  /* Initialize tienet master */
  rise_master_tile_num = (db.env.img_w * db.env.img_h) / (db.env.tile_w * db.env.tile_h);
  tienet_master_init(port, rise_master_result, list, exec, 10, RISE_VER_KEY);

  rise_master_frame = malloc(4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);
  if (!rise_master_frame) {
      perror("rise_master_frame");
      exit(1);
  }
  memset(rise_master_frame, 0, 4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);

  /* Launch a thread to handle networking */
  pthread_create(&rise_master_networking_thread, NULL, rise_master_networking,&obs_port);

  /* Initialize the work dispatcher */
  rise_dispatcher_init();

  /* Render Frame */
  for(i = 0; i < db.anim.frame_num && rise_master_alive; i++) {
    printf("Preparing frame #%d of %d\n", i+1, db.anim.frame_num);

    /* Parse and pack the application data */
    app_size = common_pack(&db, &app_data, proj);
    tienet_master_prep(app_data, app_size);

    /* Fill the work buffer */
    rise_dispatcher_generate(&db, NULL, 0);

    /* Wait for frame to finish */
    tienet_sem_wait(&rise_master_frame_sem);
#if 1
    {
      unsigned char *image24;

      image24 = (unsigned char *)malloc(3 * db.env.img_w * db.env.img_h);
      if (!image24) {
	  perror("image24");
	  exit(1);
      }
      sprintf(image_name, "image_%.4d.ppm", i);
      rise_post_process(rise_master_frame, db.env.img_w, db.env.img_h);
      util_image_convert_128to24(image24, rise_master_frame, db.env.img_w, db.env.img_h);
      util_image_save_ppm(image_name, image24, db.env.img_w, db.env.img_h);
      free(image24);
    }
#endif
    free(app_data);
  }

  /* Wait for the tienet master work buffer to empty and for all the results to come back */
  tienet_master_wait();

  /* Shutdown */
  tienet_master_shutdown();

  /* Free network data */
  tienet_master_free();

  /* Free the dispatcher data */
  rise_dispatcher_free();

  free(rise_master_frame);

#if 0
  /* End the networking thread */
  pthread_join(rise_master_networking_thread, NULL);
#endif
}


void rise_master_result(void *res_buf, int res_len) {
  rise_master_socket_t *sock;
  common_work_t work;
  unsigned char *rgb_data;
  int i, ind;

  memcpy(&work, res_buf, sizeof(common_work_t));
  rise_master_work_ind++;

  rgb_data = &((unsigned char *)res_buf)[sizeof(common_work_t)];

  ind = 0;
  for(i = work.orig_y; i < work.orig_y + work.size_y; i++) {
    memcpy(&((char *)rise_master_frame)[4 * sizeof(tfloat) * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 4*sizeof(tfloat)*work.size_x);
    ind += 4 * sizeof(tfloat) * work.size_x;
  }

  /* Progress Indicator */
  printf("Progress: %.1f%%\r", 100 * (tfloat)rise_master_work_ind / (tfloat)rise_master_tile_num);
  fflush(stdout);
/*printf("result: %d %d\n", work.orig_x, work.orig_y); */

  /* post update to all nodes that a tile has come in */
  for(sock = rise_master_socklist; sock; sock = sock->next) {
    if(sock->next) {
      if(!sock->update_sem.val)
	tienet_sem_post(&(sock->update_sem));
    }
  }

  /* Draw the frame to the screen */
  if(rise_master_work_ind == rise_master_tile_num) {
    /* Save image to disk */
    tienet_sem_post(&rise_master_frame_sem);

    rise_master_work_ind = 0;
  }
}


void* rise_master_networking(void *ptr) {
  rise_master_socket_t *sock, *tmp;
  struct sockaddr_in master, observer;
  fd_set readfds;
  int port, master_socket, highest_fd, new_socket, error;
  tfloat cam[8];
  unsigned int addrlen;
  unsigned char op;
  short endian;
  void *frame24;
#if RISE_USE_COMPRESSION
  void *comp_buf;
#endif


  port = *(int *)ptr;
  frame24 = malloc(3 * db.env.img_w * db.env.img_h);
  if (!frame24) {
      perror("frame24");
      exit(1);
  }


#if RISE_USE_COMPRESSION
  comp_buf = malloc(db.env.img_w * db.env.img_h*3);
  if (!comp_buf) {
      perror("comp_buf");
      exit(1);
  }
#endif

  /* create a socket */
  if((master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    fprintf(stderr, "unable to create socket, exiting.\n");
    exit(1);
  }

  /* initialize socket list */
  rise_master_socklist = (rise_master_socket_t *)malloc(sizeof(rise_master_socket_t));
  if (!rise_master_socklist) {
      perror("rise_master_socklist");
      exit(1);
  }
  rise_master_socklist->next = NULL;
  rise_master_socklist->prev = NULL;
  rise_master_socklist->num = master_socket;

  highest_fd = master_socket;


  /* server address */
  master.sin_family = AF_INET;
  master.sin_addr.s_addr = htonl(INADDR_ANY);
  master.sin_port = htons(port);

  /* bind socket */
  if(bind(master_socket, (struct sockaddr *)&master, sizeof(master)) < 0) {
    fprintf(stderr, "socket already bound, exiting.\n");
    exit(1);
  }

  FD_ZERO(&readfds);
  FD_SET(master_socket, &readfds);

  /* listen for connections */
  listen(rise_master_socklist->num, 3);

  addrlen = sizeof(observer);
  rise_master_active_connections = 0;

  while(rise_master_alive) {
    /* wait for some network activity */
    select(highest_fd+1, &readfds, NULL, NULL, NULL);
    /* cycle through each socket and address the activity */
    for(sock = rise_master_socklist; sock; sock = sock->next) {
      /* check if activity was on this socket */
      if(FD_ISSET(sock->num, &readfds)) {
	if(sock->num == master_socket) {
	  /* new connection */
	  new_socket = accept(master_socket, (struct sockaddr *)&observer, &addrlen);
	  if(new_socket >= 0) {
	    tmp = rise_master_socklist;
	    rise_master_socklist = (rise_master_socket_t *)malloc(sizeof(rise_master_socket_t));
	    if (!rise_master_socklist) {
		perror("rise_master_socklist");
		exit(1);
	    }
	    rise_master_socklist->num = new_socket;
	    rise_master_socklist->next = tmp;
	    rise_master_socklist->prev = NULL;
	    tienet_sem_init(&(rise_master_socklist->update_sem), 0);
	    tmp->prev = rise_master_socklist;
	    if(new_socket > highest_fd)
	      highest_fd = new_socket;
	    rise_master_active_connections++;
	  }
	} else {
	  op = 255;
	  /* observer communication */
	  error = tienet_recv(sock->num, &op, 1, 0);
	  /* remove socket from pool if there's an error, i.e slave disconnected */
	  if(error || op == RISE_NET_OP_QUIT) {
	    tmp = sock;
	    if(sock->prev)
	      sock->prev->next = sock->next;
	    /* master is always last, no need to check for sock->next next */
	    sock->next->prev = sock->prev;
	    if(sock == rise_master_socklist)
	      rise_master_socklist = rise_master_socklist->next;
	    close(sock->num);
	    sock = sock->next;
	    free(tmp);
	    rise_master_active_connections--;
	  } else {
	    switch(op) {
	      case RISE_NET_OP_INIT:
		/* Send screen width and height */
		endian = 1;
		tienet_send(sock->num, &endian, sizeof(short), 0);
		tienet_send(sock->num, &db.env.img_w, sizeof(int), 0);
		tienet_send(sock->num, &db.env.img_h, sizeof(int), 0);
		tienet_send(sock->num, &common_pack_trinum, sizeof(int), 0);
		break;

	      case RISE_NET_OP_FRAME:
		tienet_sem_wait(&(sock->update_sem));
		util_image_convert_128to24(frame24, rise_master_frame, db.env.img_w, db.env.img_h);

#if RISE_USE_COMPRESSION
		{
		  unsigned long dest_len;
		  int comp_size;
		  dest_len = 3 * db.env.img_w * db.env.img_h;

		  /* frame data */
		  compress(comp_buf, &dest_len, frame24, 3 * db.env.img_w * db.env.img_h);
		  comp_size = dest_len;
		  tienet_send(sock->num, &comp_size, sizeof(int), 0);
		  tienet_send(sock->num, comp_buf, comp_size, 0);
		}
#else
		/* frame data */
		tienet_send(sock->num, frame24, 3 * db.env.img_w * db.env.img_h, 0);
#endif
		break;

	      case RISE_NET_OP_QUIT:
		rise_master_active_connections = 0;
		break;

	      case RISE_NET_OP_SHUTDOWN:
		rise_master_alive = 0;
		break;

	      default:
		break;
	    }
	  }
	}
      }
    }

    /* Rebuild select list for next select call */
    highest_fd = 0;
    for(sock = rise_master_socklist; sock; sock = sock->next) {
      if(sock->num > highest_fd)
	highest_fd = sock->num;
      FD_SET(sock->num, &readfds);
    }
  }

#if RISE_USE_COMPRESSION
  free(comp_buf);
#endif


  /* free rise_master_socklist */
  for(sock = rise_master_socklist->next; sock; sock = sock->next)
    free(sock->prev);

  free(frame24);
  return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.17
log
@since adrt uses malloc, add checks on use for a null return value.  this probably would be a good reason to being associating with libbu.. (this fixes sf bug 1680679 - Check return codes everywhere; submitted by Markus Elfring (elfring))
@
text
@d105 1
a105 1
  rise_master_frame = malloc(4 * sizeof(TFLOAT) * db.env.img_w * db.env.img_h);
d110 1
a110 1
  memset(rise_master_frame, 0, 4 * sizeof(TFLOAT) * db.env.img_w * db.env.img_h);
d184 2
a185 2
    memcpy(&((char *)rise_master_frame)[4 * sizeof(TFLOAT) * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 4*sizeof(TFLOAT)*work.size_x);
    ind += 4 * sizeof(TFLOAT) * work.size_x;
d189 1
a189 1
  printf("Progress: %.1f%%\r", 100 * (TFLOAT)rise_master_work_ind / (TFLOAT)rise_master_tile_num);
d216 1
a216 1
  TFLOAT cam[8];
@


1.16
log
@give adrt some distinctiveness in the header
@
text
@d106 4
d136 4
d228 4
d236 4
d250 4
d294 4
@


1.15
log
@finish changing all #defined symbols to uppercase...
@
text
@d2 1
a2 1
 * BRL-CAD
@


1.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d105 2
a106 2
  rise_master_frame = malloc(4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);
  memset(rise_master_frame, 0, 4 * sizeof(tfloat) * db.env.img_w * db.env.img_h);
d176 2
a177 2
    memcpy(&((char *)rise_master_frame)[4 * sizeof(tfloat) * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 4*sizeof(tfloat)*work.size_x);
    ind += 4 * sizeof(tfloat) * work.size_x;
d181 1
a181 1
  printf("Progress: %.1f%%\r", 100 * (tfloat)rise_master_work_ind / (tfloat)rise_master_tile_num);
d208 1
a208 1
  tfloat cam[8];
@


1.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d189 1
a189 1
        tienet_sem_post(&(sock->update_sem));
d268 46
a313 46
        if(sock->num == master_socket) {
          /* new connection */
          new_socket = accept(master_socket, (struct sockaddr *)&observer, &addrlen);
          if(new_socket >= 0) {
            tmp = rise_master_socklist;
            rise_master_socklist = (rise_master_socket_t *)malloc(sizeof(rise_master_socket_t));
            rise_master_socklist->num = new_socket;
            rise_master_socklist->next = tmp;
            rise_master_socklist->prev = NULL;
            tienet_sem_init(&(rise_master_socklist->update_sem), 0);
            tmp->prev = rise_master_socklist;
            if(new_socket > highest_fd)
              highest_fd = new_socket;
            rise_master_active_connections++;
          }
        } else {
          op = 255;
          /* observer communication */
          error = tienet_recv(sock->num, &op, 1, 0);
          /* remove socket from pool if there's an error, i.e slave disconnected */
          if(error || op == RISE_NET_OP_QUIT) {
            tmp = sock;
            if(sock->prev)
              sock->prev->next = sock->next;
            /* master is always last, no need to check for sock->next next */
            sock->next->prev = sock->prev;
            if(sock == rise_master_socklist)
              rise_master_socklist = rise_master_socklist->next;
            close(sock->num);
            sock = sock->next;
            free(tmp);
            rise_master_active_connections--;
          } else {
            switch(op) {
              case RISE_NET_OP_INIT:
                /* Send screen width and height */
                endian = 1;
                tienet_send(sock->num, &endian, sizeof(short), 0);
                tienet_send(sock->num, &db.env.img_w, sizeof(int), 0);
                tienet_send(sock->num, &db.env.img_h, sizeof(int), 0);
                tienet_send(sock->num, &common_pack_trinum, sizeof(int), 0);
                break;

              case RISE_NET_OP_FRAME:
                tienet_sem_wait(&(sock->update_sem));
                util_image_convert_128to24(frame24, rise_master_frame, db.env.img_w, db.env.img_h);
d316 11
a326 11
                {
                  unsigned long dest_len;
                  int comp_size;
                  dest_len = 3 * db.env.img_w * db.env.img_h;

                  /* frame data */
                  compress(comp_buf, &dest_len, frame24, 3 * db.env.img_w * db.env.img_h);
                  comp_size = dest_len;
                  tienet_send(sock->num, &comp_size, sizeof(int), 0);
                  tienet_send(sock->num, comp_buf, comp_size, 0);
                }
d328 2
a329 2
                /* frame data */
                tienet_send(sock->num, frame24, 3 * db.env.img_w * db.env.img_h, 0);
d331 1
a331 1
                break;
d333 13
a345 13
              case RISE_NET_OP_QUIT:
                rise_master_active_connections = 0;
                break;

              case RISE_NET_OP_SHUTDOWN:
                rise_master_alive = 0;
                break;

              default:
                break;
            }
          }
        }
d353 1
a353 1
        highest_fd = sock->num;
@


1.12
log
@standard header and footer cleanup
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
@


1.11
log
@fixed a stack pop bug in the kd-tree cache loader.  engine is 1.1% faster.
@
text
@d1 26
d370 10
@


1.10
log
@in the process of fixing adrt.py and tie.c is ~2% faster.
@
text
@d101 1
a101 1
#if 0
@


1.9
log
@adding local benchmark utility minus networking stuff to do benchmarking with TIE.
@
text
@d101 1
a101 1
#if 1
@


1.8
log
@added surface area termination criteria
@
text
@d101 1
a101 1
#if 0
@


1.7
log
@added depth to parser so you can render bsp depth from rise.
@
text
@d101 1
a101 1
#if 1
@


1.6
log
@* Data on demand to nodes (~20% mem savings).
* tlist memory leak in unpack.c fixed.
* BSP Depth Visualization rendering method.
* Split Plane Coloring
* Testing more efficient BSP methods.
@
text
@d101 1
a101 1
#if 0
@


1.5
log
@Moved the g loader int adrt to a converter in brl-cad.  The converter creates
all the necessary files that adrt needs to use geometry.  Going to fix unpack
next so the program is usable again.
@
text
@d101 1
d112 1
a112 1

@


1.5.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@a100 1
#if 0
d111 1
a111 1
#endif
@


1.4
log
@Minimal support to get rise_observer working.
@
text
@d41 1
a41 1
void rise_master(int port, int obs_port, char *proj, char *geom_file, char *args, char *list, char *exec, int interval);
d58 1
a58 1
void rise_master(int port, int obs_port, char *proj, char *geom_file, char *args, char *list, char *exec, int interval) {
d93 1
a93 1
    app_size = common_pack(&db, &app_data, proj, geom_file, args);
@


1.3
log
@Python interpretor working now.  Command interface has become a blender style
editing interface with ctrl+p to process and ctrl+l to clear buffers.  Rise image
output re-enabled.
@
text
@d35 1
a35 2
  int controller;
  tienet_sem_t frame_sem;
d158 8
a171 8

    for(sock = rise_master_socklist; sock; sock = sock->next) {
      if(sock->next) {
        if(!sock->frame_sem.val)
          tienet_sem_post(&(sock->frame_sem));
      }
    }

d185 1
d192 2
a247 1
            rise_master_socklist->controller = rise_master_active_connections ? 0 : 1;
d250 1
a250 1
            tienet_sem_init(&(rise_master_socklist->frame_sem), 0);
a281 1
                tienet_send(sock->num, &(sock->controller), sizeof(int), 0);
d284 3
a286 3
              case RISE_NET_OP_GETSTATE:
                tienet_send(sock->num, cam, sizeof(tfloat)*8, 0);
                break;
a287 2
              case RISE_NET_OP_FRAME:
                tienet_sem_wait(&(sock->frame_sem));
d292 1
a292 1
                  dest_len = db.env.img_w * db.env.img_h*3;
d295 1
a295 1
                  compress(comp_buf, &dest_len, rise_master_frame, db.env.img_w * db.env.img_h*3);
d302 1
a302 1
                tienet_send(sock->num, master_frame, db.env.img_w * db.env.img_h * 3, 0);
a303 1
                /* camera data */
d340 1
@


1.2
log
@Added tenths of a percent to rise progress.
@
text
@d107 3
a109 3
//      rise_post_process(rise_master_frame, db.env.img_w, db.env.img_h);
//      util_image_convert_128to24(image24, rise_master_frame, db.env.img_w, db.env.img_h);
//      util_image_save_ppm(image_name, image24, db.env.img_w, db.env.img_h);
@


1.1
log
@Welcome ADRT
@
text
@d155 1
a155 1
  printf("Progress: %.0f%%\r", 100 * (tfloat)rise_master_work_ind / (tfloat)rise_master_tile_num);
@

