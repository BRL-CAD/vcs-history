head	1.29;
access;
symbols;
locks; strict;
comment	@ * @;


1.29
date	2005.07.10.03.58.18;	author twingy;	state dead;
branches;
next	1.28;

1.28
date	2005.07.10.03.48.10;	author twingy;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.10.03.06.17;	author twingy;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.10.01.50.46;	author twingy;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.09.02.44.44;	author twingy;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.08.20.00.47;	author twingy;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.06.22.10.05;	author twingy;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.06.21.31.54;	author twingy;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.01.15.13.01;	author twingy;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.30.09.02.46;	author twingy;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.29.21.04.42;	author twingy;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.29.17.07.38;	author twingy;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.28.21.05.13;	author twingy;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.27.21.13.35;	author twingy;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.24.22.57.40;	author twingy;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.24.06.28.01;	author twingy;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.24.03.31.45;	author twingy;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.23.22.41.16;	author twingy;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.23.21.51.25;	author twingy;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.23.04.55.51;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.23.00.43.14;	author twingy;	state Exp;
branches;
next	1.8;

1.8
date	2005.06.22.05.19.34;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.21.22.16.57;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.19.22.02.22;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.18.22.25.39;	author twingy;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.18.22.17.36;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.18.21.58.45;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.17.19.10.46;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.17.15.09.25;	author lbutler;	state Exp;
branches;
next	;


desc
@@


1.29
log
@IGVT->ISST 90%
@
text
@#include "master.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "SDL.h"		/* SDL */
#include "display.h"		/* Display utilities */
#include "canim.h"		/* Animation Stuff */
#include "dispatcher.h"		/* Dispatcher that creates work units */
#include "cdb.h"		/* Common structs and stuff */
#include "compnet.h"		/* Component Networking, Sends Component Names via Network */
#include "ivat.h"		/* IVAT Defines */
#include "image.h"		/* Image import/export utilities */
#include "pack.h"		/* Data packing for transport to nodes */
#include "ivat_struct.h"	/* ivat common structs */
#include "tienet.h"		/* Networking stuff */
#include "umath.h"		/* Extended math utilities */
#include "ivat_python.h"	/* Python code Interpreter */
/* Networking Includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#if IVAT_USE_COMPRESSION
  #include <zlib.h>
#endif


/* socket structure */
typedef struct ivat_master_socket_s {
  int num;
  int controller;
  int active;
  tienet_sem_t frame_sem;
  struct ivat_master_socket_s *prev;
  struct ivat_master_socket_s *next;
} ivat_master_socket_t;


void ivat_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host);
void* ivat_master_networking(void *ptr);
void ivat_master_result(void *res_buf, int res_len);
void ivat_master_update(void);
void ivat_master_process_events(SDL_Event *event_queue, int event_num, ivat_master_socket_t *sock);


/***** GLOBALS *****/
int ivat_master_tile_num;
TIE_3 ivat_master_camera_pos;
TIE_3 ivat_master_camera_foc;
TIE_3 ivat_master_cor; /* center of rotation */
TIE_3 ivat_master_shot_pos;
TIE_3 ivat_master_shot_dir;
tfloat ivat_master_spall_angle;
TIE_3 ivat_master_in_hit;
TIE_3 ivat_master_out_hit;

void *rgb_frame[2];
int frame_ind[2];
short frame_cur_ind;
short frame_ind_done;
char ivat_master_slave_data[64];
int ivat_master_slave_data_len;
pthread_t ivat_master_networking_thread;
tfloat ivat_master_azim;
tfloat ivat_master_elev;
tfloat ivat_master_scale;
int ivat_master_active_connections;
int ivat_master_alive;
ivat_master_socket_t *ivat_master_socklist;
common_db_t db;
unsigned char ivat_master_rm;
pthread_mutex_t ivat_master_update_mut;
int ivat_master_mouse_grab;
int ivat_master_shift_enabled;
/*******************/


static void ivat_master_setup() {
  ivat_master_active_connections = 0;

  ivat_master_alive = 1;
  ivat_master_scale = 0.01;
  ivat_master_mouse_grab = 0;
  ivat_master_shift_enabled = 0;
  ivat_master_spall_angle = 10;
  math_vec_set(ivat_master_in_hit, 0, 0, 0);
  math_vec_set(ivat_master_out_hit, 0, 0, 0);

  math_vec_set(ivat_master_camera_pos, 1, 1, 1);
  math_vec_set(ivat_master_shot_pos, 0, 0, 0);

  ivat_master_camera_foc = ivat_master_camera_pos;
  ivat_master_camera_foc.v[1] += 1;
  ivat_master_azim = 90;
  ivat_master_elev = 0;
  ivat_master_rm = RENDER_METHOD_PHONG;

  frame_ind[0] = 0;
  frame_ind[1] = 0;
  frame_cur_ind = 0;
  frame_ind_done = 0;

  rgb_frame[0] = NULL;
  rgb_frame[1] = NULL;

  rgb_frame[0] = malloc(3 * db.env.img_w * db.env.img_h);
  rgb_frame[1] = malloc(3 * db.env.img_w * db.env.img_h);

  memset(rgb_frame[0], 0, 3 * db.env.img_w * db.env.img_h);
  memset(rgb_frame[1], 0, 3 * db.env.img_w * db.env.img_h);
}


void ivat_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host) {
  int frame_num, app_size;
  void *app_data;
  struct timeval start, cur;


  /* Parse Env Data */
  common_db_load(&db, proj);

  /* Setup defaults */
  ivat_master_setup();

  /* Initialize Python Processor */
  ivat_python_init();

  /* Mutex for everytime the master builds update data to send to nodes */
  pthread_mutex_init(&ivat_master_update_mut, 0);

  /* Initialize tienet master */
  ivat_master_tile_num = (db.env.img_w * db.env.img_h) / (db.env.tile_w * db.env.tile_h);
  tienet_master_init(port, ivat_master_result, list, exec, 5, IVAT_VER_KEY);

  /* Launch a thread to handle networking */
  pthread_create(&ivat_master_networking_thread, NULL, ivat_master_networking,&obs_port);

  /* Connect to the component Server */
  ivat_compnet_connect(comp_host, IVAT_COMPNET_PORT);

  /* Parse and pack the application data */
  printf("loading scene... ");
  fflush(stdout);
  app_size = common_pack(&db, &app_data, proj);
  printf("done.\n");

  tienet_master_prep(app_data, app_size);

  /* Initialize the work dispatcher */
  ivat_dispatcher_init();

  /* Data for computing fps */
  frame_num = 0;
  gettimeofday(&start, NULL);

  while(ivat_master_alive) {
    /* Update Camera Position */
    ivat_master_update();

    /* Fill the work buffer */
    ivat_dispatcher_generate(&db, ivat_master_slave_data, ivat_master_slave_data_len);

    frame_cur_ind = 1 - frame_cur_ind;

#if 0
    frame_num++;
    if(!(frame_num % 7)) {
      gettimeofday(&cur, NULL);
      printf("FPS: %.3f  SLAVES: %d    \r",
            (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
            tienet_master_socket_num);
      start = cur;
      frame_num = 0;
      fflush(stdout);
    }
#endif
  }

  /* Wait for the tienet master work buffer to empty and for all the results to come back */
  tienet_master_wait();

  /* Shutdown */
  tienet_master_shutdown();

  /* Free network data */
  tienet_master_free();

  /* Free the dispatcher data */
  ivat_dispatcher_free();

  free(rgb_frame[0]);
  free(rgb_frame[1]);

  /* End the networking thread */
  pthread_join(ivat_master_networking_thread, NULL);

  ivat_python_free();
}


void ivat_master_result(void *res_buf, int res_len) {
  ivat_master_socket_t *sock;
  common_work_t work;
  unsigned char *rgb_data;
  int i, ind, num;
  short frame;
  char c, name[256];


  /* Work unit data */
  memcpy(&work, res_buf, sizeof(common_work_t));

  if(work.size_x == 0) {  /* ugly hack until I get a better identifier in place */
    char *mesg;
    short slop;

    /* Read and advance to data */
    ind = sizeof(common_work_t);

    /* first hit */
    memcpy(&ivat_master_in_hit, &((unsigned char *)res_buf)[ind], sizeof(TIE_3));
    ind += sizeof(TIE_3);

    /* last hit */
    memcpy(&ivat_master_out_hit, &((unsigned char *)res_buf)[ind], sizeof(TIE_3));
    ind += sizeof(TIE_3);

    /* Set the Center of of Rotation */
    math_vec_add(ivat_master_cor, ivat_master_in_hit, ivat_master_out_hit);
    math_vec_mul_scalar(ivat_master_cor, ivat_master_cor, 0.5);

    /* number of meshes */
    memcpy(&num, &((unsigned char *)res_buf)[ind], sizeof(int));
    ind += sizeof(int);

    /* reset the component server to collapse all fields */
    ivat_compnet_reset();

    for(i = 0; i < num; i++) {
      memcpy(&c, &((unsigned char *)res_buf)[ind], 1);
      ind += 1;
      memcpy(name, &((unsigned char *)res_buf)[ind], c);
      ind += c;
      ivat_compnet_update(name, 1);
    }

    /* Send a message to update hitlist */
    mesg = malloc(sizeof(short) + res_len - sizeof(common_work_t) - 6*sizeof(tfloat));

    ind = 0;
    slop = IVAT_OP_SHOT;
    memcpy(&((char *)mesg)[ind], &slop, sizeof(short));
    ind += sizeof(short);

    memcpy(&((char *)mesg)[ind], &((unsigned char *)res_buf)[sizeof(common_work_t) + 6*sizeof(tfloat)], res_len - sizeof(common_work_t) - 6*sizeof(tfloat));
    ind += res_len - sizeof(common_work_t) - 6*sizeof(tfloat);

    tienet_master_broadcast(mesg, ind);
    free(mesg);
  } else {
    /* Pointer to RGB Data */
    rgb_data = &((unsigned char *)res_buf)[sizeof(common_work_t)];

    /* Frame index */
    memcpy(&frame, &((char *)res_buf)[sizeof(common_work_t) + 3 * work.size_x * work.size_y], sizeof(short));

    frame_ind[frame]++;

    /* Copy the tile into the image */
    ind = 0;
    for(i = work.orig_y; i < work.orig_y + work.size_y; i++) {
      memcpy(&((char *)rgb_frame[frame])[3 * (work.orig_x + i * db.env.img_w)], &rgb_data[ind], 3*work.size_y);
      ind += 3*work.size_y;
    }


    /* Image is complete, draw the frame. */
    if(frame_ind[frame] == ivat_master_tile_num) {
      frame_ind[frame] = 0;
      frame_ind_done = frame;

      for(sock = ivat_master_socklist; sock; sock = sock->next) {
        if(sock->next) {
          if(!sock->frame_sem.val)
            tienet_sem_post(&(sock->frame_sem));
        }
      }
    }
  }
}


void* ivat_master_networking(void *ptr) {
  ivat_master_socket_t *sock, *tmp;
  struct sockaddr_in master, observer;
  fd_set readfds;
  int port, master_socket, highest_fd, new_socket, error;
  unsigned int addrlen;
  unsigned char op;
  short endian;
#if IVAT_USE_COMPRESSION
  void *comp_buf;
#endif


  port = *(int *)ptr;


#if IVAT_USE_COMPRESSION
  comp_buf = malloc(3 * db.env.img_w * db.env.img_h + 1024);
#endif

  /* create a socket */
  if((master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    fprintf(stderr, "unable to create socket, exiting.\n");
    exit(1);
  }

  /* initialize socket list */
  ivat_master_socklist = (ivat_master_socket_t *)malloc(sizeof(ivat_master_socket_t));
  ivat_master_socklist->next = NULL;
  ivat_master_socklist->prev = NULL;
  ivat_master_socklist->num = master_socket;

  highest_fd = master_socket;


  /* server address */
  master.sin_family = AF_INET;
  master.sin_addr.s_addr = htonl(INADDR_ANY);
  master.sin_port = htons(port);

  /* bind socket */
  if(bind(master_socket, (struct sockaddr *)&master, sizeof(master)) < 0) {
    fprintf(stderr, "observer socket already bound, exiting.\n");
    exit(1);
  }

  FD_ZERO(&readfds);
  FD_SET(master_socket, &readfds);

  /* listen for connections */
  listen(ivat_master_socklist->num, 3);

  addrlen = sizeof(observer);
  ivat_master_active_connections = 0;

  while(ivat_master_alive || ivat_master_active_connections) {
    /* wait for some network activity */
    select(highest_fd+1, &readfds, NULL, NULL, NULL);
    /* cycle through each socket and address the activity */
    for(sock = ivat_master_socklist; sock; sock = sock->next) {
      /* if no longer alive then mark each of the active connections as no longer active */
      if(!ivat_master_alive)
        sock->active = 0;

      /* check if activity was on this socket */
      if(FD_ISSET(sock->num, &readfds)) {
        if(sock->num == master_socket) {
          /* new connection */
          new_socket = accept(master_socket, (struct sockaddr *)&observer, &addrlen);
          if(new_socket >= 0) {
            tmp = ivat_master_socklist;
            ivat_master_socklist = (ivat_master_socket_t *)malloc(sizeof(ivat_master_socket_t));
            ivat_master_socklist->num = new_socket;
            ivat_master_socklist->controller = ivat_master_active_connections ? 0 : 1;
            ivat_master_socklist->active = 1;
            ivat_master_socklist->next = tmp;
            ivat_master_socklist->prev = NULL;
            tienet_sem_init(&(ivat_master_socklist->frame_sem), 0);
            tmp->prev = ivat_master_socklist;
            if(new_socket > highest_fd)
              highest_fd = new_socket;
            ivat_master_active_connections++;
          }
        } else {
          op = 255;
          /* observer communication */
          error = tienet_recv(sock->num, &op, 1, 0);

          /* remove socket from pool if there's an error, i.e slave disconnected */
          if(error || op == IVAT_NET_OP_QUIT || !sock->active) {
            op = IVAT_NET_OP_QUIT;
            tienet_send(sock->num, &op, 1, 0);

            tmp = sock;
            if(sock->prev)
              sock->prev->next = sock->next;
            /* master is always last, no need to check for sock->next next */
            sock->next->prev = sock->prev;
            if(sock == ivat_master_socklist)
              ivat_master_socklist = ivat_master_socklist->next;
            close(sock->num);
            sock = sock->next;
            free(tmp);
            ivat_master_active_connections--;

          } else {
            switch(op) {
              case IVAT_NET_OP_INIT:
                /* Send screen width and height */
                endian = 1;
                tienet_send(sock->num, &endian, sizeof(short), 0);
                tienet_send(sock->num, &db.env.img_w, sizeof(int), 0);
                tienet_send(sock->num, &db.env.img_h, sizeof(int), 0);
                break;

              case IVAT_NET_OP_FRAME:
                tienet_sem_wait(&(sock->frame_sem));

                /* Let observer know everything is okay, continue as usual. */
                op = IVAT_NET_OP_NOP;
                tienet_send(sock->num, &op, 1, 0);

                {
                  SDL_Event event_queue[64];
                  short event_num;

                  /* Get the event Queue and process it */
                  tienet_recv(sock->num, &event_num, sizeof(short), 0);
                  if(event_num)
                    tienet_recv(sock->num, event_queue, event_num * sizeof(SDL_Event), 0);
                  ivat_master_process_events(event_queue, event_num, sock);
                }

#if IVAT_USE_COMPRESSION
                {
                  unsigned long dest_len;
                  int comp_size;
                  dest_len = 3 * db.env.img_w * db.env.img_h + 1024;

                  /* frame data */
                  compress(&((char *)comp_buf)[sizeof(int)], &dest_len, rgb_frame[frame_ind_done], 3 * db.env.img_w * db.env.img_h);
                  comp_size = dest_len;
                  memcpy(comp_buf, &comp_size, sizeof(int));
                  /* int for frame size in bytes followed by actual rgb frame data */
                  tienet_send(sock->num, comp_buf, comp_size + sizeof(int), 0);
                }
#else
                /* frame data */
                tienet_send(sock->num, rgb_frame[frame_ind_done], db.env.img_w * db.env.img_h * 3, 0);
#endif

                /* Send overlay data */
                {
                  ivat_overlay_data_t overlay;

                  overlay.camera_pos = ivat_master_camera_pos;
                  overlay.azimuth = ivat_master_azim;
                  overlay.elevation = ivat_master_elev;
                  sprintf(overlay.resolution, "%dx%d", db.env.img_w, db.env.img_h);
                  overlay.controller = sock->controller;

                  tienet_send(sock->num, &overlay, sizeof(ivat_overlay_data_t), 0);
                }

                /* Lock things down so that ivat_master_update data doesn't get tainted */
                pthread_mutex_lock(&ivat_master_update_mut);

                pthread_mutex_unlock(&ivat_master_update_mut);
                break;

              case IVAT_NET_OP_MESG:
                {
                  char *string;
                  int len;

                  string = (char *)malloc(1024);
                  tienet_recv(sock->num, &len, 1, 0);
                  tienet_recv(sock->num, string, len, 0);

                  ivat_python_code(string);
                  len = strlen(string) + 1;

                  tienet_send(sock->num, &len, 1, 0);
                  tienet_send(sock->num, string, len, 0);

                  free(string);
                }
                break;


              case IVAT_NET_OP_QUIT:
                ivat_master_active_connections = 0;
                break;


              default:
                break;
            }
          }
        }
      }
    }

    /* Rebuild select list for next select call */
    highest_fd = 0;
    for(sock = ivat_master_socklist; sock; sock = sock->next) {
      if(sock->num > highest_fd)
        highest_fd = sock->num;
      FD_SET(sock->num, &readfds);
    }
  }

#if IVAT_USE_COMPRESSION
  free(comp_buf);
#endif


  /* free ivat_master_socklist */
  for(sock = ivat_master_socklist->next; sock; sock = sock->next)
    free(sock->prev);

  return 0;
}


/* additional baggage that goes with each work unit */
void ivat_master_update() {
  char op;

  ivat_master_slave_data_len = 0;

  /* Lock things down so that ivat_master_update data doesn't get tainted */
  pthread_mutex_lock(&ivat_master_update_mut);

  /* function */
  op = IVAT_OP_RENDER;
  memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], &op, 1);
  ivat_master_slave_data_len += 1;

  /* Frame Index */
  memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], &frame_cur_ind, sizeof(short));
  ivat_master_slave_data_len += sizeof(short);

  /* Camera Position */
  memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], ivat_master_camera_pos.v, sizeof(TIE_3));
  ivat_master_slave_data_len += sizeof(TIE_3);

  /* Camera Focus */
  memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], ivat_master_camera_foc.v, sizeof(TIE_3));
  ivat_master_slave_data_len += sizeof(TIE_3);

  /* Rendering Method and Data */
  memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], &ivat_master_rm, 1);
  ivat_master_slave_data_len += 1;

  switch(ivat_master_rm) {
    case RENDER_METHOD_PLANE:
      memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], &ivat_master_shot_pos, sizeof(TIE_3));
      ivat_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], &ivat_master_shot_dir, sizeof(TIE_3));
      ivat_master_slave_data_len += sizeof(TIE_3);
      break;

    case RENDER_METHOD_SPALL:
      memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], &ivat_master_in_hit, sizeof(TIE_3));
      ivat_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], &ivat_master_shot_dir, sizeof(TIE_3));
      ivat_master_slave_data_len += sizeof(TIE_3);

      memcpy(&((char *)ivat_master_slave_data)[ivat_master_slave_data_len], &ivat_master_spall_angle, sizeof(tfloat));
      ivat_master_slave_data_len += sizeof(tfloat);
      break;

    default:
      break;
  }

  pthread_mutex_unlock(&ivat_master_update_mut);
}


void ivat_master_process_events(SDL_Event *event_queue, int event_num, ivat_master_socket_t *sock) {
  int i, update;
  TIE_3 vec, vec2, vec3;
  tfloat celev;


  for(i = 0; i < event_num; i++) {
    update = 0;
    switch(event_queue[i].type) {
      printf("event_type: %d\n", event_queue[i].type);
      case SDL_KEYDOWN:
        update = 1;
        switch(event_queue[i].key.keysym.sym) {
          case SDLK_LSHIFT:
          case SDLK_RSHIFT:
            ivat_master_shift_enabled = 1;
            break;

          case SDLK_0: /* RENDER_METHOD_PATH */
            ivat_master_rm = RENDER_METHOD_PATH;
            break;

          case SDLK_1: /* RENDER_METHOD_NORMAL */
            ivat_master_rm = RENDER_METHOD_NORMAL;
            break;

          case SDLK_2: /* RENDER_METHOD_PHONG */
            ivat_master_rm = RENDER_METHOD_PHONG;
            break;

          case SDLK_3: /* RENDER_METHOD_PLANE */
            ivat_master_rm = RENDER_METHOD_PLANE;
            break;

          case SDLK_4: /* RENDER_METHOD_COMPONENT */
            ivat_master_rm = RENDER_METHOD_COMPONENT;
            break;

          case SDLK_5: /* RENDER_METHOD_SPALL */
            ivat_master_rm = RENDER_METHOD_SPALL;
            break;

          case SDLK_9: /* RENDER_METHOD_GRID */
            ivat_master_rm = RENDER_METHOD_GRID;
            break;

          case SDLK_UP:
            math_vec_sub(vec, ivat_master_camera_foc, ivat_master_camera_pos);
            math_vec_mul_scalar(vec, vec, ivat_master_scale*10.0);
            math_vec_add(ivat_master_camera_pos, ivat_master_camera_pos, vec);
            break;

          case SDLK_DOWN:
            math_vec_sub(vec, ivat_master_camera_foc, ivat_master_camera_pos);
            math_vec_mul_scalar(vec, vec, ivat_master_scale*10.0);
            math_vec_sub(ivat_master_camera_pos, ivat_master_camera_pos, vec);
            break;

          case SDLK_LEFT:
            /* strafe left */
            math_vec_sub(vec, ivat_master_camera_foc, ivat_master_camera_pos);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (ivat_master_scale*10.0));
            math_vec_add(ivat_master_camera_pos, ivat_master_camera_pos, vec3);
            break;

          case SDLK_RIGHT:
            /* strafe right */
            math_vec_sub(vec, ivat_master_camera_foc, ivat_master_camera_pos);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (ivat_master_scale*10.0));
            math_vec_sub(ivat_master_camera_pos, ivat_master_camera_pos, vec3);
            break;

          case SDLK_F12: /* Server Shutdown and quit*/
            ivat_master_alive = 0;
            break;

          case SDLK_e: /* export frame */
#if 0
            pthread_mutex_lock(&ivat_observer_gui_mut);
            {
              char filename[32];
              void *image24;
              strcpy(filename, "frame.ppm");
              image24 = malloc(3 * screen_w * screen_h);
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
#else
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 1);
#endif
              util_display_text_input("export_frame", filename, 32);
              util_image_save_ppm(filename, image24, screen_w, screen_h);
            }
            pthread_mutex_unlock(&ivat_observer_gui_mut);
#endif
            break;

          case SDLK_f: /* fullscreen toggle */
            /* Reserved for Fullscreen */
            break;

	  case SDLK_g: /* grab mouse */
            ivat_master_mouse_grab = ivat_master_mouse_grab ^ 1;
	    break;

          case SDLK_q: /* quit */
            sock->active = 0;
            break;

          case SDLK_KP1: /* front, back */
            {
              tfloat dist;

              /* distance to center of rotation */
              math_vec_sub(vec, ivat_master_camera_pos, ivat_master_cor);
              math_vec_dot(dist, vec, vec);
              dist = sqrt(dist);

              ivat_master_camera_pos = ivat_master_cor;
              if(ivat_master_shift_enabled) {
                ivat_master_camera_pos.v[1] += dist;
                ivat_master_azim = 270;
                ivat_master_elev = 0;
              } else {
                ivat_master_camera_pos.v[1] -= dist;
                ivat_master_azim = 90;
                ivat_master_elev = 0;
              }
            }
            break;

          case SDLK_KP3: /* right, left */
            {
              tfloat dist;

              /* distance to center of rotation */
              math_vec_sub(vec, ivat_master_camera_pos, ivat_master_cor);
              math_vec_dot(dist, vec, vec);
              dist = sqrt(dist);

              ivat_master_camera_pos = ivat_master_cor;
              if(ivat_master_shift_enabled) {
                ivat_master_camera_pos.v[0] -= dist;
                ivat_master_azim = 0;
                ivat_master_elev = 0;
              } else {
                ivat_master_camera_pos.v[0] += dist;
                ivat_master_azim = 180;
                ivat_master_elev = 0;
              }
            }
            break;

          case SDLK_KP7: /* top, bottom */
            {
              tfloat dist;

              /* distance to center of rotation */
              math_vec_sub(vec, ivat_master_camera_pos, ivat_master_cor);
              math_vec_dot(dist, vec, vec);
              dist = sqrt(dist);

              ivat_master_camera_pos = ivat_master_cor;
              if(ivat_master_shift_enabled) {
                ivat_master_camera_pos.v[2] -= dist;
                ivat_master_azim = 0;
                ivat_master_elev = 90;
              } else {
                ivat_master_camera_pos.v[2] += dist;
                ivat_master_azim = 0;
                ivat_master_elev = -90;
              }
            }
            break;

          case SDLK_KP0: /* set camera position and direction to shot position and direction */
            ivat_master_camera_pos = ivat_master_shot_pos;
            /* project and unitize shot vector onto xy plane */
            vec = ivat_master_shot_dir;
            vec.v[2] = 0;
            math_vec_unitize(vec);

            ivat_master_azim = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg;
            ivat_master_elev = asin(ivat_master_shot_dir.v[2]) * math_rad2deg;
            break;


          case SDLK_KP_DIVIDE: /* shotline */
            {
              void *mesg;
              common_work_t work;
              TIE_3 dir;
              int dlen;
              char op;

              /* Queue a work unit for a shot needed for the plane render method */
              mesg = malloc(sizeof(common_work_t) + 2 * sizeof(TIE_3));
              dlen = 0;

              work.orig_x = 0;
              work.orig_y = 0;
              work.size_x = 0;
              work.size_y = 0;

              memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
              dlen += sizeof(common_work_t);

              /* function */
              op = IVAT_OP_SHOT;
              memcpy(&((char *)mesg)[dlen], &op, 1);
              dlen += 1;

              /* position */
              memcpy(&((char *)mesg)[dlen], &ivat_master_camera_pos, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              math_vec_sub(dir, ivat_master_camera_foc, ivat_master_camera_pos);
              math_vec_unitize(dir);

              /* direction */
              memcpy(&((char *)mesg)[dlen], &dir, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              ivat_master_shot_pos = ivat_master_camera_pos;
              ivat_master_shot_dir = dir;

              tienet_master_push(mesg, dlen);
              free(mesg);
            }
            break;

          case SDLK_KP_MULTIPLY: /* spawl cone */
            {
              void *mesg;
              common_work_t work;
              TIE_3 dir;
              int dlen;
              char op;

              /* Queue a work unit for a shot needed for the plane render method */
              mesg = malloc(sizeof(common_work_t) + 2 * sizeof(TIE_3) + sizeof(tfloat));
              dlen = 0;

              work.orig_x = 0;
              work.orig_y = 0;
              work.size_x = 0;
              work.size_y = 0;

              memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
              dlen += sizeof(common_work_t);

              /* function */
              op = IVAT_OP_SPALL;
              memcpy(&((char *)mesg)[dlen], &op, 1);
              dlen += 1;

              /* position */
              memcpy(&((char *)mesg)[dlen], &ivat_master_camera_pos, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              math_vec_sub(dir, ivat_master_camera_foc, ivat_master_camera_pos);
              math_vec_unitize(dir);

              /* direction */
              memcpy(&((char *)mesg)[dlen], &dir, sizeof(TIE_3));
              dlen += sizeof(TIE_3);

              /* angle */
              memcpy(&((char *)mesg)[dlen], &ivat_master_spall_angle, sizeof(tfloat));
              dlen += sizeof(tfloat);

              ivat_master_shot_pos = ivat_master_camera_pos;
              ivat_master_shot_dir = dir;

              tienet_master_push(mesg, dlen);
              free(mesg);
            }
            break;


          case SDLK_BACKQUOTE: /* console */
            /* reserved for console in observer */
            break;

          default:
            break;
        }
        break;

      case SDL_KEYUP:
        switch(event_queue[i].key.keysym.sym) {
          case SDLK_LSHIFT:
          case SDLK_RSHIFT:
            ivat_master_shift_enabled = 0;
            break;

          default:
            break;
        }

      case SDL_MOUSEBUTTONDOWN:
        update = 1;
        if(event_queue[i].button.button == SDL_BUTTON_WHEELUP)
          ivat_master_scale *= 1.25;

        if(event_queue[i].button.button == SDL_BUTTON_WHEELDOWN)
          ivat_master_scale *= 0.8;
        break;

      case SDL_MOUSEMOTION:
        if(event_queue[i].motion.state && ivat_master_mouse_grab) {
	  int dx, dy;

	  dx = -event_queue[i].motion.xrel;
	  dy = -event_queue[i].motion.yrel;

          update = 1;
          if(event_queue[i].button.button & 1<<(SDL_BUTTON_LEFT-1)) {
            /* backward and forward */
            math_vec_sub(vec, ivat_master_camera_foc, ivat_master_camera_pos);
            math_vec_mul_scalar(vec, vec, (ivat_master_scale*dy));
            math_vec_add(ivat_master_camera_pos, ivat_master_camera_pos, vec);

            /* strafe */
#if 0
            math_vec_sub(vec, ivat_master_camera_foc, ivat_master_camera_pos);
            vec2.v[0] = 0;
            vec2.v[1] = 0;
            vec2.v[2] = 1;
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (ivat_master_scale*dx));
            math_vec_add(ivat_master_camera_pos, ivat_master_camera_pos, vec3);
#endif
          } else if(event_queue[i].button.button & 1<<(SDL_BUTTON_RIGHT-1)) {
            /* if the shift key is held down then rotate about Center of Rotation */
            if(ivat_master_shift_enabled) {
              TIE_3 vec;
              tfloat radius, angle;

              vec.v[0] = ivat_master_cor.v[0] - ivat_master_camera_pos.v[0];
              vec.v[1] = ivat_master_cor.v[1] - ivat_master_camera_pos.v[1];
              vec.v[2] = 0;

              angle = vec.v[0]*vec.v[0] + vec.v[1]*vec.v[1];
              radius = sqrt(angle);
              vec.v[0] /= radius;
              vec.v[1] /= radius;

              vec.v[0] = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg;

              vec.v[0] -= 0.035*dx;
              vec.v[0] *= math_deg2rad;

              ivat_master_camera_pos.v[0] = -radius*cos(vec.v[0]) + ivat_master_cor.v[0];
              ivat_master_camera_pos.v[1] = -radius*sin(vec.v[0]) + ivat_master_cor.v[1];
              ivat_master_azim -= 0.035*dx;
            } else {
              ivat_master_azim += 0.035*dx;
              ivat_master_elev += 0.035*dy;
            }
          } else if(event_queue[i].button.button & 1<<(SDL_BUTTON_MIDDLE-1)) {
            ivat_master_camera_pos.v[2] += ivat_master_scale*dy;

            /* strafe */
            math_vec_sub(vec, ivat_master_camera_foc, ivat_master_camera_pos);
            math_vec_set(vec2, 0, 0, 1);
            math_vec_cross(vec3, vec2, vec);
            math_vec_mul_scalar(vec3, vec3, (ivat_master_scale*dx));
            math_vec_add(ivat_master_camera_pos, ivat_master_camera_pos, vec3);
          }

          ivat_master_azim = fmod(ivat_master_azim, 360.0);
          ivat_master_elev = fmod(ivat_master_elev, 360.0);
        }
        break;

      default:
        break;
    }

    if(update) {
      ivat_master_camera_foc = ivat_master_camera_pos;
      celev = cos(ivat_master_elev * math_deg2rad);
      ivat_master_camera_foc.v[0] += cos(ivat_master_azim * math_deg2rad) * celev;
      ivat_master_camera_foc.v[1] += sin(ivat_master_azim * math_deg2rad) * celev;
      ivat_master_camera_foc.v[2] += sin(ivat_master_elev * math_deg2rad);
    }
  }
}
@


1.28
log
@75% done IGVT -> IVAT conversion.
@
text
@@


1.27
log
@updated the NEWS and README
@
text
@d13 1
a13 1
#include "igvt.h"		/* IGVT Defines */
d16 1
a16 1
#include "igvt_struct.h"	/* igvt common structs */
d19 1
a19 1
#include "igvt_python.h"	/* Python code Interpreter */
d27 1
a27 1
#if IGVT_USE_COMPRESSION
d33 1
a33 1
typedef struct igvt_master_socket_s {
d38 3
a40 3
  struct igvt_master_socket_s *prev;
  struct igvt_master_socket_s *next;
} igvt_master_socket_t;
d43 5
a47 5
void igvt_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host);
void* igvt_master_networking(void *ptr);
void igvt_master_result(void *res_buf, int res_len);
void igvt_master_update(void);
void igvt_master_process_events(SDL_Event *event_queue, int event_num, igvt_master_socket_t *sock);
d51 9
a59 9
int igvt_master_tile_num;
TIE_3 igvt_master_camera_pos;
TIE_3 igvt_master_camera_foc;
TIE_3 igvt_master_cor; /* center of rotation */
TIE_3 igvt_master_shot_pos;
TIE_3 igvt_master_shot_dir;
tfloat igvt_master_spall_angle;
TIE_3 igvt_master_in_hit;
TIE_3 igvt_master_out_hit;
d65 9
a73 9
char igvt_master_slave_data[64];
int igvt_master_slave_data_len;
pthread_t igvt_master_networking_thread;
tfloat igvt_master_azim;
tfloat igvt_master_elev;
tfloat igvt_master_scale;
int igvt_master_active_connections;
int igvt_master_alive;
igvt_master_socket_t *igvt_master_socklist;
d75 4
a78 4
unsigned char igvt_master_rm;
pthread_mutex_t igvt_master_update_mut;
int igvt_master_mouse_grab;
int igvt_master_shift_enabled;
d82 2
a83 2
static void igvt_master_setup() {
  igvt_master_active_connections = 0;
d85 16
a100 16
  igvt_master_alive = 1;
  igvt_master_scale = 0.01;
  igvt_master_mouse_grab = 0;
  igvt_master_shift_enabled = 0;
  igvt_master_spall_angle = 10;
  math_vec_set(igvt_master_in_hit, 0, 0, 0);
  math_vec_set(igvt_master_out_hit, 0, 0, 0);

  math_vec_set(igvt_master_camera_pos, 1, 1, 1);
  math_vec_set(igvt_master_shot_pos, 0, 0, 0);

  igvt_master_camera_foc = igvt_master_camera_pos;
  igvt_master_camera_foc.v[1] += 1;
  igvt_master_azim = 90;
  igvt_master_elev = 0;
  igvt_master_rm = RENDER_METHOD_PHONG;
d118 1
a118 1
void igvt_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host) {
d128 1
a128 1
  igvt_master_setup();
d131 1
a131 1
  igvt_python_init();
d134 1
a134 1
  pthread_mutex_init(&igvt_master_update_mut, 0);
d137 2
a138 2
  igvt_master_tile_num = (db.env.img_w * db.env.img_h) / (db.env.tile_w * db.env.tile_h);
  tienet_master_init(port, igvt_master_result, list, exec, 5, IGVT_VER_KEY);
d141 1
a141 1
  pthread_create(&igvt_master_networking_thread, NULL, igvt_master_networking,&obs_port);
d144 1
a144 1
  igvt_compnet_connect(comp_host, IGVT_COMPNET_PORT);
d155 1
a155 1
  igvt_dispatcher_init();
d161 1
a161 1
  while(igvt_master_alive) {
d163 1
a163 1
    igvt_master_update();
d166 1
a166 1
    igvt_dispatcher_generate(&db, igvt_master_slave_data, igvt_master_slave_data_len);
d194 1
a194 1
  igvt_dispatcher_free();
d200 1
a200 1
  pthread_join(igvt_master_networking_thread, NULL);
d202 1
a202 1
  igvt_python_free();
d206 2
a207 2
void igvt_master_result(void *res_buf, int res_len) {
  igvt_master_socket_t *sock;
d226 1
a226 1
    memcpy(&igvt_master_in_hit, &((unsigned char *)res_buf)[ind], sizeof(TIE_3));
d230 1
a230 1
    memcpy(&igvt_master_out_hit, &((unsigned char *)res_buf)[ind], sizeof(TIE_3));
d234 2
a235 2
    math_vec_add(igvt_master_cor, igvt_master_in_hit, igvt_master_out_hit);
    math_vec_mul_scalar(igvt_master_cor, igvt_master_cor, 0.5);
d242 1
a242 1
    igvt_compnet_reset();
d249 1
a249 1
      igvt_compnet_update(name, 1);
d256 1
a256 1
    slop = IGVT_OP_SHOT;
d283 1
a283 1
    if(frame_ind[frame] == igvt_master_tile_num) {
d287 1
a287 1
      for(sock = igvt_master_socklist; sock; sock = sock->next) {
d298 2
a299 2
void* igvt_master_networking(void *ptr) {
  igvt_master_socket_t *sock, *tmp;
d306 1
a306 1
#if IGVT_USE_COMPRESSION
d314 1
a314 1
#if IGVT_USE_COMPRESSION
d325 4
a328 4
  igvt_master_socklist = (igvt_master_socket_t *)malloc(sizeof(igvt_master_socket_t));
  igvt_master_socklist->next = NULL;
  igvt_master_socklist->prev = NULL;
  igvt_master_socklist->num = master_socket;
d348 1
a348 1
  listen(igvt_master_socklist->num, 3);
d351 1
a351 1
  igvt_master_active_connections = 0;
d353 1
a353 1
  while(igvt_master_alive || igvt_master_active_connections) {
d357 1
a357 1
    for(sock = igvt_master_socklist; sock; sock = sock->next) {
d359 1
a359 1
      if(!igvt_master_alive)
d368 9
a376 9
            tmp = igvt_master_socklist;
            igvt_master_socklist = (igvt_master_socket_t *)malloc(sizeof(igvt_master_socket_t));
            igvt_master_socklist->num = new_socket;
            igvt_master_socklist->controller = igvt_master_active_connections ? 0 : 1;
            igvt_master_socklist->active = 1;
            igvt_master_socklist->next = tmp;
            igvt_master_socklist->prev = NULL;
            tienet_sem_init(&(igvt_master_socklist->frame_sem), 0);
            tmp->prev = igvt_master_socklist;
d379 1
a379 1
            igvt_master_active_connections++;
d387 2
a388 2
          if(error || op == IGVT_NET_OP_QUIT || !sock->active) {
            op = IGVT_NET_OP_QUIT;
d396 2
a397 2
            if(sock == igvt_master_socklist)
              igvt_master_socklist = igvt_master_socklist->next;
d401 1
a401 1
            igvt_master_active_connections--;
d405 1
a405 1
              case IGVT_NET_OP_INIT:
d413 1
a413 1
              case IGVT_NET_OP_FRAME:
d417 1
a417 1
                op = IGVT_NET_OP_NOP;
d428 1
a428 1
                  igvt_master_process_events(event_queue, event_num, sock);
d431 1
a431 1
#if IGVT_USE_COMPRESSION
d451 1
a451 1
                  igvt_overlay_data_t overlay;
d453 3
a455 3
                  overlay.camera_pos = igvt_master_camera_pos;
                  overlay.azimuth = igvt_master_azim;
                  overlay.elevation = igvt_master_elev;
d459 1
a459 1
                  tienet_send(sock->num, &overlay, sizeof(igvt_overlay_data_t), 0);
d462 2
a463 2
                /* Lock things down so that igvt_master_update data doesn't get tainted */
                pthread_mutex_lock(&igvt_master_update_mut);
d465 1
a465 1
                pthread_mutex_unlock(&igvt_master_update_mut);
d468 1
a468 1
              case IGVT_NET_OP_MESG:
d477 1
a477 1
                  igvt_python_code(string);
d488 2
a489 2
              case IGVT_NET_OP_QUIT:
                igvt_master_active_connections = 0;
d503 1
a503 1
    for(sock = igvt_master_socklist; sock; sock = sock->next) {
d510 1
a510 1
#if IGVT_USE_COMPRESSION
d515 2
a516 2
  /* free igvt_master_socklist */
  for(sock = igvt_master_socklist->next; sock; sock = sock->next)
d524 1
a524 1
void igvt_master_update() {
d527 1
a527 1
  igvt_master_slave_data_len = 0;
d529 2
a530 2
  /* Lock things down so that igvt_master_update data doesn't get tainted */
  pthread_mutex_lock(&igvt_master_update_mut);
d533 3
a535 3
  op = IGVT_OP_RENDER;
  memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &op, 1);
  igvt_master_slave_data_len += 1;
d538 2
a539 2
  memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &frame_cur_ind, sizeof(short));
  igvt_master_slave_data_len += sizeof(short);
d542 2
a543 2
  memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], igvt_master_camera_pos.v, sizeof(TIE_3));
  igvt_master_slave_data_len += sizeof(TIE_3);
d546 2
a547 2
  memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], igvt_master_camera_foc.v, sizeof(TIE_3));
  igvt_master_slave_data_len += sizeof(TIE_3);
d550 2
a551 2
  memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_rm, 1);
  igvt_master_slave_data_len += 1;
d553 1
a553 1
  switch(igvt_master_rm) {
d555 2
a556 2
      memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_shot_pos, sizeof(TIE_3));
      igvt_master_slave_data_len += sizeof(TIE_3);
d558 2
a559 2
      memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_shot_dir, sizeof(TIE_3));
      igvt_master_slave_data_len += sizeof(TIE_3);
d563 2
a564 2
      memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_in_hit, sizeof(TIE_3));
      igvt_master_slave_data_len += sizeof(TIE_3);
d566 2
a567 2
      memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_shot_dir, sizeof(TIE_3));
      igvt_master_slave_data_len += sizeof(TIE_3);
d569 2
a570 2
      memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_spall_angle, sizeof(tfloat));
      igvt_master_slave_data_len += sizeof(tfloat);
d577 1
a577 1
  pthread_mutex_unlock(&igvt_master_update_mut);
d581 1
a581 1
void igvt_master_process_events(SDL_Event *event_queue, int event_num, igvt_master_socket_t *sock) {
d596 1
a596 1
            igvt_master_shift_enabled = 1;
d600 1
a600 1
            igvt_master_rm = RENDER_METHOD_PATH;
d604 1
a604 1
            igvt_master_rm = RENDER_METHOD_NORMAL;
d608 1
a608 1
            igvt_master_rm = RENDER_METHOD_PHONG;
d612 1
a612 1
            igvt_master_rm = RENDER_METHOD_PLANE;
d616 1
a616 1
            igvt_master_rm = RENDER_METHOD_COMPONENT;
d620 1
a620 1
            igvt_master_rm = RENDER_METHOD_SPALL;
d624 1
a624 1
            igvt_master_rm = RENDER_METHOD_GRID;
d628 3
a630 3
            math_vec_sub(vec, igvt_master_camera_foc, igvt_master_camera_pos);
            math_vec_mul_scalar(vec, vec, igvt_master_scale*10.0);
            math_vec_add(igvt_master_camera_pos, igvt_master_camera_pos, vec);
d634 3
a636 3
            math_vec_sub(vec, igvt_master_camera_foc, igvt_master_camera_pos);
            math_vec_mul_scalar(vec, vec, igvt_master_scale*10.0);
            math_vec_sub(igvt_master_camera_pos, igvt_master_camera_pos, vec);
d641 1
a641 1
            math_vec_sub(vec, igvt_master_camera_foc, igvt_master_camera_pos);
d644 2
a645 2
            math_vec_mul_scalar(vec3, vec3, (igvt_master_scale*10.0));
            math_vec_add(igvt_master_camera_pos, igvt_master_camera_pos, vec3);
d650 1
a650 1
            math_vec_sub(vec, igvt_master_camera_foc, igvt_master_camera_pos);
d653 2
a654 2
            math_vec_mul_scalar(vec3, vec3, (igvt_master_scale*10.0));
            math_vec_sub(igvt_master_camera_pos, igvt_master_camera_pos, vec3);
d658 1
a658 1
            igvt_master_alive = 0;
d663 1
a663 1
            pthread_mutex_lock(&igvt_observer_gui_mut);
d677 1
a677 1
            pthread_mutex_unlock(&igvt_observer_gui_mut);
d686 1
a686 1
            igvt_master_mouse_grab = igvt_master_mouse_grab ^ 1;
d698 1
a698 1
              math_vec_sub(vec, igvt_master_camera_pos, igvt_master_cor);
d702 5
a706 5
              igvt_master_camera_pos = igvt_master_cor;
              if(igvt_master_shift_enabled) {
                igvt_master_camera_pos.v[1] += dist;
                igvt_master_azim = 270;
                igvt_master_elev = 0;
d708 3
a710 3
                igvt_master_camera_pos.v[1] -= dist;
                igvt_master_azim = 90;
                igvt_master_elev = 0;
d720 1
a720 1
              math_vec_sub(vec, igvt_master_camera_pos, igvt_master_cor);
d724 5
a728 5
              igvt_master_camera_pos = igvt_master_cor;
              if(igvt_master_shift_enabled) {
                igvt_master_camera_pos.v[0] -= dist;
                igvt_master_azim = 0;
                igvt_master_elev = 0;
d730 3
a732 3
                igvt_master_camera_pos.v[0] += dist;
                igvt_master_azim = 180;
                igvt_master_elev = 0;
d742 1
a742 1
              math_vec_sub(vec, igvt_master_camera_pos, igvt_master_cor);
d746 5
a750 5
              igvt_master_camera_pos = igvt_master_cor;
              if(igvt_master_shift_enabled) {
                igvt_master_camera_pos.v[2] -= dist;
                igvt_master_azim = 0;
                igvt_master_elev = 90;
d752 3
a754 3
                igvt_master_camera_pos.v[2] += dist;
                igvt_master_azim = 0;
                igvt_master_elev = -90;
d760 1
a760 1
            igvt_master_camera_pos = igvt_master_shot_pos;
d762 1
a762 1
            vec = igvt_master_shot_dir;
d766 2
a767 2
            igvt_master_azim = vec.v[1] < 0 ? 360.0 - acos(vec.v[0])*math_rad2deg : acos(vec.v[0])*math_rad2deg;
            igvt_master_elev = asin(igvt_master_shot_dir.v[2]) * math_rad2deg;
d792 1
a792 1
              op = IGVT_OP_SHOT;
d797 1
a797 1
              memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos, sizeof(TIE_3));
d800 1
a800 1
              math_vec_sub(dir, igvt_master_camera_foc, igvt_master_camera_pos);
d807 2
a808 2
              igvt_master_shot_pos = igvt_master_camera_pos;
              igvt_master_shot_dir = dir;
d836 1
a836 1
              op = IGVT_OP_SPALL;
d841 1
a841 1
              memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos, sizeof(TIE_3));
d844 1
a844 1
              math_vec_sub(dir, igvt_master_camera_foc, igvt_master_camera_pos);
d852 1
a852 1
              memcpy(&((char *)mesg)[dlen], &igvt_master_spall_angle, sizeof(tfloat));
d855 2
a856 2
              igvt_master_shot_pos = igvt_master_camera_pos;
              igvt_master_shot_dir = dir;
d877 1
a877 1
            igvt_master_shift_enabled = 0;
d887 1
a887 1
          igvt_master_scale *= 1.25;
d890 1
a890 1
          igvt_master_scale *= 0.8;
d894 1
a894 1
        if(event_queue[i].motion.state && igvt_master_mouse_grab) {
d903 3
a905 3
            math_vec_sub(vec, igvt_master_camera_foc, igvt_master_camera_pos);
            math_vec_mul_scalar(vec, vec, (igvt_master_scale*dy));
            math_vec_add(igvt_master_camera_pos, igvt_master_camera_pos, vec);
d909 1
a909 1
            math_vec_sub(vec, igvt_master_camera_foc, igvt_master_camera_pos);
d914 2
a915 2
            math_vec_mul_scalar(vec3, vec3, (igvt_master_scale*dx));
            math_vec_add(igvt_master_camera_pos, igvt_master_camera_pos, vec3);
d919 1
a919 1
            if(igvt_master_shift_enabled) {
d923 2
a924 2
              vec.v[0] = igvt_master_cor.v[0] - igvt_master_camera_pos.v[0];
              vec.v[1] = igvt_master_cor.v[1] - igvt_master_camera_pos.v[1];
d937 3
a939 3
              igvt_master_camera_pos.v[0] = -radius*cos(vec.v[0]) + igvt_master_cor.v[0];
              igvt_master_camera_pos.v[1] = -radius*sin(vec.v[0]) + igvt_master_cor.v[1];
              igvt_master_azim -= 0.035*dx;
d941 2
a942 2
              igvt_master_azim += 0.035*dx;
              igvt_master_elev += 0.035*dy;
d945 1
a945 1
            igvt_master_camera_pos.v[2] += igvt_master_scale*dy;
d948 1
a948 1
            math_vec_sub(vec, igvt_master_camera_foc, igvt_master_camera_pos);
d951 2
a952 2
            math_vec_mul_scalar(vec3, vec3, (igvt_master_scale*dx));
            math_vec_add(igvt_master_camera_pos, igvt_master_camera_pos, vec3);
d955 2
a956 2
          igvt_master_azim = fmod(igvt_master_azim, 360.0);
          igvt_master_elev = fmod(igvt_master_elev, 360.0);
d965 5
a969 5
      igvt_master_camera_foc = igvt_master_camera_pos;
      celev = cos(igvt_master_elev * math_deg2rad);
      igvt_master_camera_foc.v[0] += cos(igvt_master_azim * math_deg2rad) * celev;
      igvt_master_camera_foc.v[1] += sin(igvt_master_azim * math_deg2rad) * celev;
      igvt_master_camera_foc.v[2] += sin(igvt_master_elev * math_deg2rad);
@


1.26
log
@basic component server communication complete.
@
text
@d210 1
a210 1
  int i, ind;
d212 1
d222 1
a222 7
#if 1
    /* Read the data */
{
    int num;
    char c, name[256];

    /* advance to data */
a224 1
    printf("******** HIT_LIST *********\n");
a236 2
    printf("in: [%.3f, %.3f, %.3f] ... out: [%.3f, %.3f, %.3f]\n", igvt_master_in_hit.v[0], igvt_master_in_hit.v[1], igvt_master_in_hit.v[2], igvt_master_out_hit.v[0], igvt_master_out_hit.v[1], igvt_master_out_hit.v[2]);

d241 3
a249 1
/*      printf("name[%d]: %s\n", i, name); */
a250 2
}
#endif
@


1.25
log
@made the arguments for slave and observer more convenient, debugging python
adrt.blah bug.
@
text
@d144 1
a144 1
//  igvt_compnet_connect(comp_host, IGVT_COMPNET_PORT);
d254 1
a254 1
//      igvt_compnet_update(name, 1);
d478 2
a479 1
                  char *string, len;
d490 1
@


1.24
log
@bug fix, adding more component net stuff.
@
text
@d348 1
a348 1
    fprintf(stderr, "socket already bound, exiting.\n");
@


1.23
log
@slowly adding hooks to talk to component server.
@
text
@d82 1
a82 1
static void igvt_master_setup_defaults() {
d107 3
d112 1
d124 3
d128 1
a128 1
  igvt_master_setup_defaults();
a135 3
  /* Parse Env Data */
  common_db_load(&db, proj);

d144 1
a144 1
  igvt_compnet_connect(comp_host, IGVT_COMPNET_PORT);
d254 2
a255 1
      printf("name[%d]: %s\n", i, name);
@


1.22
log
@adding support to communicate with a component server, i.e fuzzy fault tree viewer.
@
text
@d12 1
d82 1
a82 12
void igvt_master(int port, int obs_port, char *proj, char *list, char *exec, char *comp_host) {
  int frame_num, app_size;
  void *app_data;
  struct timeval start, cur;


  /* Initialize Python Processor */
  igvt_python_init();

  /* Mutex for everytime the master builds update data to send to nodes */
  pthread_mutex_init(&igvt_master_update_mut, 0);

a101 8
  /* Parse Env Data */
  common_db_load(&db, proj);

  /* Initialize tienet master */
  igvt_master_tile_num = (db.env.img_w * db.env.img_h) / (db.env.tile_w * db.env.tile_h);

  tienet_master_init(port, igvt_master_result, list, exec, 5, IGVT_VER_KEY);

d108 1
a108 1
  rgb_frame[1]= malloc(3 * db.env.img_w * db.env.img_h);
d111 24
d139 3
@


1.21
log
@The project directory now has a single project file that lists the file names
for properties, textures, frames, geometry, and geometry arguments.  The
application no longer requires the -g and -a options.  IGVT has been updated
to reflect these changes, RISE is next.
@
text
@d42 1
a42 1
void igvt_master(int port, int obs_port, char *proj, char *list, char *exec, int interval);
d81 1
a81 1
void igvt_master(int port, int obs_port, char *proj, char *list, char *exec, int interval) {
@


1.20
log
@Shotline remapped to '/' on num pad.  Spall cone mapped to '*' on num pad.
Spall cone now fires 32 full angle, 16 half angle, 12 quarter angle rays.
Shotline moved into render utilities.
@
text
@d42 1
a42 1
void igvt_master(int port, int obs_port, char *proj, char *geom_file, char *args, char *list, char *exec, int interval);
d81 1
a81 1
void igvt_master(int port, int obs_port, char *proj, char *geom_file, char *args, char *list, char *exec, int interval) {
d136 1
a136 1
  app_size = common_pack(&db, &app_data, proj, geom_file, args);
@


1.19
log
@Spall cone emits from entry point of geometry now.
@
text
@d517 2
d524 5
d763 1
a763 1
          case SDLK_KP_PERIOD:
d769 1
d783 50
d839 1
d843 4
@


1.18
log
@spawl -> spall.
@
text
@d57 2
d100 2
a212 2
    TIE_3 in_hit;
    TIE_3 out_hit;
d219 2
a220 6
    memcpy(&in_hit.v[0], &((unsigned char *)res_buf)[ind], sizeof(tfloat));
    ind += sizeof(tfloat);
    memcpy(&in_hit.v[1], &((unsigned char *)res_buf)[ind], sizeof(tfloat));
    ind += sizeof(tfloat);
    memcpy(&in_hit.v[2], &((unsigned char *)res_buf)[ind], sizeof(tfloat));
    ind += sizeof(tfloat);
d223 2
a224 6
    memcpy(&out_hit.v[0], &((unsigned char *)res_buf)[ind], sizeof(tfloat));
    ind += sizeof(tfloat);
    memcpy(&out_hit.v[1], &((unsigned char *)res_buf)[ind], sizeof(tfloat));
    ind += sizeof(tfloat);
    memcpy(&out_hit.v[2], &((unsigned char *)res_buf)[ind], sizeof(tfloat));
    ind += sizeof(tfloat);
d227 2
a228 3
    igvt_master_cor.v[0] = (in_hit.v[0] + out_hit.v[0]) * 0.5;
    igvt_master_cor.v[1] = (in_hit.v[1] + out_hit.v[1]) * 0.5;
    igvt_master_cor.v[2] = (in_hit.v[2] + out_hit.v[2]) * 0.5;
d230 1
a230 1
    printf("in: [%.3f, %.3f, %.3f] ... out: [%.3f, %.3f, %.3f]\n", in_hit.v[0], in_hit.v[1], in_hit.v[2], out_hit.v[0], out_hit.v[1], out_hit.v[2]);
d548 1
a548 1
      memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_shot_pos, sizeof(TIE_3));
d775 1
a775 1
              memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos.v, sizeof(TIE_3));
d781 1
a781 1
              memcpy(&((char *)mesg)[dlen], &dir.v, sizeof(TIE_3));
@


1.17
log
@Spawl cone rendering method now display as shaded red transparent.  Added
python hooks for getting and setting spawl angle.
@
text
@d56 1
a56 1
tfloat igvt_master_spawl_angle;
d97 1
a97 1
  igvt_master_spawl_angle = 10;
d554 1
a554 1
    case RENDER_METHOD_SPAWL:
d561 1
a561 1
      memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_spawl_angle, sizeof(tfloat));
d611 2
a612 2
          case SDLK_5: /* RENDER_METHOD_SPAWL */
            igvt_master_rm = RENDER_METHOD_SPAWL;
@


1.16
log
@Adding s pawl cone render method.
@
text
@d56 1
d97 1
d560 3
@


1.15
log
@fixing rise observer
@
text
@d543 16
a558 3
  if(igvt_master_rm == RENDER_METHOD_PLANE) {
    memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_shot_pos, sizeof(TIE_3));
    igvt_master_slave_data_len += sizeof(TIE_3);
d560 2
a561 2
    memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_shot_dir, sizeof(TIE_3));
    igvt_master_slave_data_len += sizeof(TIE_3);
d606 4
d865 1
a865 1
              vec.v[0] -= 0.05*dx;
d870 1
a870 1
              igvt_master_azim -= 0.05*dx;
d872 2
a873 2
              igvt_master_azim += 0.05*dx;
              igvt_master_elev += 0.05*dy;
@


1.14
log
@Additional render data is now passed along in render method baggage in master. Observer reports fps on
screen now.  Add math_vec_set to libtie.  Master fires shotline by pressing keypad period, and keypad 0
places camera back at the shotline origin.
@
text
@d54 2
a55 2
TIE_3 igvt_master_shotline_pos;
TIE_3 igvt_master_shotline_dir;
d98 1
a98 1
  math_vec_set(igvt_master_shotline_pos, 0, 0, 0);
d255 1
a255 1
    slop = IGVT_OP_SHOTLINE;
d544 1
a544 1
    memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_shotline_pos, sizeof(TIE_3));
d547 1
a547 1
    memcpy(&((char *)igvt_master_slave_data)[igvt_master_slave_data_len], &igvt_master_shotline_dir, sizeof(TIE_3));
d729 4
a732 4
          case SDLK_KP0: /* set camera position and direction to shotline position and direction */
            igvt_master_camera_pos = igvt_master_shotline_pos;
            /* project and unitize shotline vector onto xy plane */
            vec = igvt_master_shotline_dir;
d737 1
a737 1
            igvt_master_elev = asin(igvt_master_shotline_dir.v[2]) * math_rad2deg;
d748 1
a748 1
              /* Queue a work unit for a shotline needed for the plane render method */
d769 2
a770 2
              igvt_master_shotline_pos = igvt_master_camera_pos;
              igvt_master_shotline_dir = dir;
@


1.13
log
@Added blender style 6 orthogonal views using keypad 1, 3, 7 plus shift.
@
text
@d54 2
d97 2
a98 3
  igvt_master_camera_pos.v[0] = 1;
  igvt_master_camera_pos.v[1] = 1;
  igvt_master_camera_pos.v[2] = 1;
d153 1
a153 1
    if(!(frame_num%7)) {
d520 1
d543 8
d586 1
a586 40
            {
              void *mesg;
              common_work_t work;
              TIE_3 dir;
              int dlen;

              igvt_master_rm = RENDER_METHOD_PLANE;

              /* Queue a work unit for a shotline needed for the plane render method */
              mesg = malloc(sizeof(common_work_t) + 2 * sizeof(TIE_3));
              dlen = 0;

              work.orig_x = 0;
              work.orig_y = 0;
              work.size_x = 0;
              work.size_y = 0;

              memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
              dlen += sizeof(common_work_t);

              memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos.v[0], sizeof(tfloat));
              dlen += sizeof(tfloat);
              memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos.v[1], sizeof(tfloat));
              dlen += sizeof(tfloat);
              memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos.v[2], sizeof(tfloat));
              dlen += sizeof(tfloat);

              math_vec_sub(dir, igvt_master_camera_foc, igvt_master_camera_pos);
              math_vec_unitize(dir);

              memcpy(&((char *)mesg)[dlen], &dir.v[0], sizeof(tfloat));
              dlen += sizeof(tfloat);
              memcpy(&((char *)mesg)[dlen], &dir.v[1], sizeof(tfloat));
              dlen += sizeof(tfloat);
              memcpy(&((char *)mesg)[dlen], &dir.v[2], sizeof(tfloat));
              dlen += sizeof(tfloat);

              tienet_master_push(mesg, dlen);
              free(mesg);
            }
d612 1
a612 3
            vec2.v[0] = 0;
            vec2.v[1] = 0;
            vec2.v[2] = 1;
d621 1
a621 3
            vec2.v[0] = 0;
            vec2.v[1] = 0;
            vec2.v[2] = 1;
d729 47
d863 1
a863 3
            vec2.v[0] = 0;
            vec2.v[1] = 0;
            vec2.v[2] = 1;
@


1.12
log
@adjusting parameters.
@
text
@d696 68
@


1.11
log
@Camera position, azimuth, and elevation accessible from python now.
Added cut and paste to editor, 85% done.
@
text
@d740 1
d748 1
@


1.10
log
@Python interpretor working now.  Command interface has become a blender style
editing interface with ctrl+p to process and ctrl+l to clear buffers.  Rise image
output re-enabled.
@
text
@d12 1
a12 1
#include "igvt.h"		/* Defines */
d15 1
a15 1
#include "igvt_struct.h"		/* igvt common structs */
d48 1
@


1.9
log
@Skeleton framework for python integration in place, console 75% done.
@
text
@d18 1
a18 1
#include "igvt_python.h"	/* Python Command Interpreter */
d81 1
a81 1
  /* Initialize Python Command Processor */
d473 1
a473 1
                  igvt_python_command(string);
@


1.8
log
@more additions to the console and beginning to add python interpreter.
@
text
@d80 4
d180 2
d469 1
a469 1
                  string = (char *)malloc(80);
d474 1
a475 1
                  len = strlen(string) + 1;
@


1.7
log
@Started on util_display_console for use in igvt observer, 25% done.
@
text
@d18 1
a47 1

d459 18
@


1.6
log
@Added rotate about center of rotation holding shift key + right mouse.
@
text
@d671 4
@


1.5
log
@Shotline visualization is working again.
@
text
@d71 1
d87 2
d145 1
a145 1
#if 1
d222 5
d529 1
d533 5
d674 12
d719 26
a744 2
            igvt_master_azim += 0.05*dx;
            igvt_master_elev += 0.05*dy;
@


1.4
log
@put Observer F12 to shutdown master back in.
@
text
@a43 1
void igvt_master_parse_op(int sock_num);
a485 60
void igvt_master_parse_op(int sock_num) {
  unsigned char op;

  tienet_recv(sock_num, &op, 1, 0);

  switch(op) {
    case IGVT_OBS_OP_RM:
    {
      common_work_t work;
      TIE_3 dir;
      int dlen;
      void *mesg;

      /* Update render method on slaves */
      tienet_recv(sock_num, &op, 1, 0);
      igvt_master_rm = op;

      if(op == RENDER_METHOD_PLANE) {
        /* Queue a work unit for a shotline needed for the plane render method */
        mesg = malloc(sizeof(common_work_t) + 2 * sizeof(TIE_3));
        dlen = 0;

        work.orig_x = 0;
        work.orig_y = 0;
        work.size_x = 0;
        work.size_y = 0;

        memcpy(&((char *)mesg)[dlen], &work, sizeof(common_work_t));
        dlen += sizeof(common_work_t);

        memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos.v[0], sizeof(tfloat));
        dlen += sizeof(tfloat);
        memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos.v[1], sizeof(tfloat));
        dlen += sizeof(tfloat);
        memcpy(&((char *)mesg)[dlen], &igvt_master_camera_pos.v[2], sizeof(tfloat));
        dlen += sizeof(tfloat);

        math_vec_sub(dir, igvt_master_camera_foc, igvt_master_camera_pos);
        math_vec_unitize(dir);

        memcpy(&((char *)mesg)[dlen], &dir.v[0], sizeof(tfloat));
        dlen += sizeof(tfloat);
        memcpy(&((char *)mesg)[dlen], &dir.v[1], sizeof(tfloat));
        dlen += sizeof(tfloat);
        memcpy(&((char *)mesg)[dlen], &dir.v[2], sizeof(tfloat));
        dlen += sizeof(tfloat);

        tienet_master_push(mesg, dlen);

        free(mesg);
      }
      break;
    }

    default:
      break;
  }
}


d537 40
a576 10
            igvt_master_rm = RENDER_METHOD_PLANE;
#if 0
            ((char *)igvt_observer_msg)[0] = IGVT_OBS_OP_RM;
            ((char *)igvt_observer_msg)[1] = RENDER_METHOD_PLANE;
            igvt_observer_msg_len = 2;
            igvt_observer_pv_enabled = 1;
            igvt_observer_pv_pos = camera_pos;
            math_vec_sub(igvt_observer_pv_dir, camera_foc, camera_pos);
            math_vec_unitize(igvt_observer_pv_dir);
#endif
@


1.3
log
@Added licensing info to libtexture files.
@
text
@d62 5
a66 2
tfloat igvt_master_azim, igvt_master_elev, igvt_master_scale;
int mouse_x, mouse_y, igvt_master_active_connections, igvt_master_alive;
d337 1
a337 1
  while(igvt_master_alive) {
d342 4
d369 1
a652 1
            printf("Shutting down master and exiting.\n");
@


1.2
log
@hoisting build system and making it play nice with brlcad
@
text
@a447 3
              case IGVT_NET_OP_SHUTDOWN:
                igvt_master_alive = 0;
                break;
a644 1
#if 0
d646 1
a646 3
            igvt_observer_master_shutdown = 1;
            return;
#endif
@


1.1
log
@Welcome ADRT
@
text
@d15 1
a15 1
#include "struct.h"		/* igvt common structs */
@

