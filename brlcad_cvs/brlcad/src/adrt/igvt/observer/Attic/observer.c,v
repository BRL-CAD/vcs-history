head	1.19;
access;
symbols;
locks; strict;
comment	@ * @;


1.19
date	2005.07.10.03.58.18;	author twingy;	state dead;
branches;
next	1.18;

1.18
date	2005.07.10.03.48.10;	author twingy;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.10.01.50.47;	author twingy;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.25.03.13.28;	author twingy;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.24.06.28.01;	author twingy;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.23.23.11.30;	author twingy;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.23.04.55.51;	author twingy;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.23.00.43.15;	author twingy;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.22.05.19.34;	author twingy;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.22.02.36.25;	author twingy;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.21.22.16.57;	author twingy;	state Exp;
branches;
next	1.8;

1.8
date	2005.06.21.04.27.59;	author twingy;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.21.02.37.17;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.20.21.45.52;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.19.22.02.23;	author twingy;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.18.22.17.37;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.17.21.40.52;	author erikgreenwald;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.17.19.10.46;	author erikgreenwald;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.17.15.09.25;	author lbutler;	state Exp;
branches;
next	;


desc
@@


1.19
log
@IGVT->ISST 90%
@
text
@#include "brlcad_config.h"
#include "observer.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include "SDL.h"
#include "ivat.h"
#include "image.h"
#include "display.h"
#include "umath.h"
#include "ivat_struct.h"
#include "tienet.h"
#include "splash.h"
/* Networking Includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#if IVAT_USE_COMPRESSION
  #include <zlib.h>
#endif


typedef struct ivat_observer_net_info_s {
  struct hostent master;
  int port;
} ivat_observer_net_info_t;


void ivat_observer(char *host, int port);
void* ivat_observer_networking(void *ptr);
void ivat_observer_event_loop(void);


/***** GLOBALS *****/
pthread_t ivat_observer_networking_thread;
pthread_mutex_t ivat_observer_gui_mut;
pthread_mutex_t event_mut;

tienet_sem_t ivat_observer_sdlinit_sem;
tienet_sem_t ivat_observer_sdlready_sem;
tienet_sem_t ivat_observer_splash_sem;
pthread_mutex_t ivat_observer_console_mut;

int screen_w;
int screen_h;

short ivat_observer_endian;

short ivat_observer_event_queue_size;
SDL_Event ivat_observer_event_queue[64];
int ivat_observer_mouse_grab;
int ivat_observer_event_loop_alive;
int ivat_observer_display_init;
int ivat_observer_master_socket;
/*******************/



void ivat_observer(char *host, int port) {
  ivat_observer_net_info_t ni;

  /* server address */ 
  if(gethostbyname(host)) {
    ni.master = gethostbyname(host)[0];
  } else {
    fprintf(stderr, "hostname %s unknown, exiting.\n", host);
    exit(1);
  }
  ni.port = port;

  ivat_observer_event_queue_size = 0;
  ivat_observer_event_loop_alive = 1;

  pthread_mutex_init(&event_mut, 0);
  pthread_mutex_init(&ivat_observer_gui_mut, 0);

  tienet_sem_init(&ivat_observer_sdlinit_sem, 0);
  tienet_sem_init(&ivat_observer_sdlready_sem, 0);
  tienet_sem_init(&ivat_observer_splash_sem, 0);
  pthread_mutex_init(&ivat_observer_console_mut, 0);
  ivat_observer_display_init = 1;

  /* Launch a thread to handle events */
  pthread_create(&ivat_observer_networking_thread, NULL, ivat_observer_networking, &ni);

  /* Process events */
  tienet_sem_wait(&ivat_observer_sdlinit_sem);
  ivat_observer_event_loop();

  /* JOIN EVENT HANDLING THREAD */
  pthread_join(ivat_observer_networking_thread, NULL);
}


void* ivat_observer_networking(void *ptr) {
  ivat_observer_net_info_t *ni;
  struct timeval start, cur;
  struct sockaddr_in my_addr, srv_addr;
  void *frame;
  unsigned int addrlen;
  unsigned char op;
  tfloat fps;
  int frame_num;
#if IVAT_USE_COMPRESSION
  void *comp_buf;
#endif


  ni = (ivat_observer_net_info_t *)ptr;

  /* create a socket */
  if((ivat_observer_master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    perror("Socket creation error");
    exit(1);
  }

  /* client address */
  my_addr.sin_family = AF_INET;
  my_addr.sin_addr.s_addr = INADDR_ANY;
  my_addr.sin_port = htons(0);

  srv_addr.sin_family = ni->master.h_addrtype;
  memcpy((char*)&srv_addr.sin_addr.s_addr, ni->master.h_addr_list[0], ni->master.h_length);
  srv_addr.sin_port = htons(ni->port);

  if(bind(ivat_observer_master_socket, (struct sockaddr *)&my_addr, sizeof(my_addr)) < 0) {
    fprintf(stderr, "unable to bind socket, exiting.\n");
    exit(1);
  }

  /* connect to master */
  if(connect(ivat_observer_master_socket, (struct sockaddr *)&srv_addr, sizeof(srv_addr)) < 0) {
    fprintf(stderr, "cannot connect to master, exiting.\n");
    exit(1);
  }

  addrlen = sizeof(srv_addr);

  /* send version and get endian info */
  op = IVAT_NET_OP_INIT;
  tienet_send(ivat_observer_master_socket, &op, 1, ivat_observer_endian);
  tienet_recv(ivat_observer_master_socket, &ivat_observer_endian, sizeof(short), 0);
  ivat_observer_endian = ivat_observer_endian == 1 ? 0 : 1;
  tienet_recv(ivat_observer_master_socket, &screen_w, sizeof(int), ivat_observer_endian);
  tienet_recv(ivat_observer_master_socket, &screen_h, sizeof(int), ivat_observer_endian);

  /* Screen size is known.  Initialize SDL and continue once it's ready */
  tienet_sem_post(&ivat_observer_sdlinit_sem);

  /* Allocate memory for frame buffer */
  frame = malloc(screen_w*screen_h*3);
#if IVAT_USE_COMPRESSION
  comp_buf = malloc(screen_w*screen_h*3);
#endif


  gettimeofday(&start, NULL);
  frame_num = 0;


  while(1) {
    /* Send request for next frame */
    op = IVAT_NET_OP_FRAME;
    tienet_send(ivat_observer_master_socket, &op, 1, ivat_observer_endian);

    /* Check whether to quit here or not */
    tienet_recv(ivat_observer_master_socket, &op, 1, ivat_observer_endian);
    if(op == IVAT_NET_OP_QUIT) {
      util_display_free();
      free(frame);
#if ivat_USE_COMPRESSION
      free(comp_buf);
#endif
      close(ivat_observer_master_socket);

      ivat_observer_event_loop_alive = 0;
      printf("Observer detatched from master.\n");
      return(NULL);
    }

    /* Send Event Queue to Master */
    pthread_mutex_lock(&event_mut);

    tienet_send(ivat_observer_master_socket, &ivat_observer_event_queue_size, sizeof(short), ivat_observer_endian);
    if(ivat_observer_event_queue_size)
      tienet_send(ivat_observer_master_socket, ivat_observer_event_queue, ivat_observer_event_queue_size * sizeof(SDL_Event), ivat_observer_endian);
    ivat_observer_event_queue_size = 0;

    pthread_mutex_unlock(&event_mut);

    /* get frame data */
#if IVAT_USE_COMPRESSION
    {
      unsigned long dest_len;
      int comp_size;

      tienet_recv(ivat_observer_master_socket, &comp_size, sizeof(int), 0);
      tienet_recv(ivat_observer_master_socket, comp_buf, comp_size, 0);

      dest_len = screen_w*screen_h*3;
      uncompress(frame, &dest_len, comp_buf, (unsigned long)comp_size);
    }
#else
    tienet_recv(ivat_observer_master_socket, frame, 3*screen_w*screen_h, 0);
#endif

    if(ivat_observer_display_init) {
      ivat_observer_display_init = 0;
      tienet_sem_post(&ivat_observer_splash_sem);
      tienet_sem_wait(&ivat_observer_sdlready_sem);
    }

    /* compute frames per second (fps) */
    frame_num++;
    if(!(frame_num % 7)) {
      gettimeofday(&cur, NULL);
      fps = (tfloat)(frame_num) / ((cur.tv_sec + (tfloat)cur.tv_usec/1000000.0) - (start.tv_sec + (tfloat)start.tv_usec/1000000.0)),
      start = cur;
      frame_num = 0;
      fflush(stdout);
    }

    /* Get the overlay data */
    {
      ivat_overlay_data_t overlay;
      char string[256];

      tienet_recv(ivat_observer_master_socket, &overlay, sizeof(ivat_overlay_data_t), 0);

      /* Wait for the console to unlock */
      pthread_mutex_lock(&ivat_observer_console_mut);

      /* Draw Frame */
      util_display_draw(frame);

      sprintf(string, "position: %.3f %.3f %.3f", overlay.camera_pos.v[0], overlay.camera_pos.v[1], overlay. camera_pos.v[2]);
      util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

      sprintf(string, "azim: %.3f  elev: %.3f", overlay.azimuth, overlay.elevation);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);

      sprintf(string, "fps: %.1f", fps);
      util_display_text(string, 0, 1, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

      sprintf(string, "res: %s", overlay.resolution);
      util_display_text(string, 0, 0, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_BOTTOM);

      sprintf(string, "units: meters");
      util_display_text(string, 0, 0, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_TOP);

      sprintf(string, "controller: %s", overlay.controller ? "yes" : "no");
      util_display_text(string, 0, 0, UTIL_JUSTIFY_RIGHT, UTIL_JUSTIFY_BOTTOM);

      util_display_cross();
      util_display_flip();

      pthread_mutex_unlock(&ivat_observer_console_mut);
    }
  }

  return(NULL);
}


void ivat_observer_process(char *content, char *response) {
  char op;

  op = IVAT_NET_OP_MESG;
  tienet_send(ivat_observer_master_socket, &op, 1, 0);

  /* length of content */
  op = strlen(content);
  if(strlen(content)) {
    op += 1;
    tienet_send(ivat_observer_master_socket, &op, 1, 0);

    /* content */
    tienet_send(ivat_observer_master_socket, content, op, 0);

    /* get the response */
    tienet_recv(ivat_observer_master_socket, &op, 1, 0);
    tienet_recv(ivat_observer_master_socket, response, op, 0);
  }
}


void ivat_observer_event_loop() {
  SDL_Event event;
  char **content_buffer, **console_buffer;
  int content_lines, console_lines, i;


  content_lines = 0;
  console_lines = 0;
  content_buffer = (char **)malloc(sizeof(char *) * 100);
  console_buffer = (char **)malloc(sizeof(char *) * 100);
  for(i = 0; i < 100; i++) {
    content_buffer[i] = (char *)malloc(80);
    console_buffer[i] = (char *)malloc(80);
  }
  content_buffer[0][0] = 0;
  console_buffer[0][0] = 0;


  /* Display Loading Splash Screen */
  util_display_init(isst_logo.width, isst_logo.height);

  SDL_WM_SetCaption("ADRT_ISST_Observer Loading...", NULL);
  util_display_draw((void *)isst_logo.pixel_data);
  util_display_flip();

  tienet_sem_wait(&ivat_observer_splash_sem);
  util_display_free();

  util_display_init(screen_w, screen_h);

  SDL_WM_SetCaption("ADRT_ISST_Observer", NULL);
  tienet_sem_post(&ivat_observer_sdlready_sem);

  while(SDL_WaitEvent(&event) >= 0 && ivat_observer_event_loop_alive) {
    switch(event.type) {
      case SDL_KEYDOWN:
        switch(event.key.keysym.sym) {
          case SDLK_f: /* fullscreen mode */
            SDL_WM_ToggleFullScreen(util_display_screen);
            break;

          case SDLK_g: /* mouse grabbing */
            ivat_observer_mouse_grab = ivat_observer_mouse_grab ^ 1;
            SDL_WM_GrabInput(ivat_observer_mouse_grab ? SDL_GRAB_ON : SDL_GRAB_OFF);
            SDL_ShowCursor(!ivat_observer_mouse_grab);
            break;

          case SDLK_F2:
            {
              void *image24;

              /* Screen dump */
              image24 = malloc(3 * screen_w * screen_h);
              util_image_convert_32to24(image24, util_display_screen->pixels, screen_w, screen_h, 0);
              util_image_save_ppm("screenshot.ppm", image24, screen_w, screen_h);
              free(image24);
            }
            break;

          case SDLK_BACKQUOTE:
            /* Bring up the console */
            pthread_mutex_lock(&ivat_observer_console_mut);
            util_display_editor(content_buffer, &content_lines, console_buffer, &console_lines, ivat_observer_process);
            pthread_mutex_unlock(&ivat_observer_console_mut);
            break;

          default:
            break;
        }
        break;

      default:
        break;
    }

    pthread_mutex_lock(&event_mut);
    /* Build up an event queue to send prior to receiving each frame */
    if(ivat_observer_event_queue_size < 64)
      ivat_observer_event_queue[ivat_observer_event_queue_size++] = event;
    pthread_mutex_unlock(&event_mut);
  }


  for(i = 0; i < 100; i++) {
    free(content_buffer[i]);
    free(console_buffer[i]);
  }
  free(content_buffer);
  free(console_buffer);
}
@


1.18
log
@75% done IGVT -> IVAT conversion.
@
text
@@


1.17
log
@basic component server communication complete.
@
text
@d9 1
a9 1
#include "igvt.h"
d13 1
a13 1
#include "igvt_struct.h"
d23 1
a23 1
#if IGVT_USE_COMPRESSION
d28 1
a28 1
typedef struct igvt_observer_net_info_s {
d31 1
a31 1
} igvt_observer_net_info_t;
d34 3
a36 3
void igvt_observer(char *host, int port);
void* igvt_observer_networking(void *ptr);
void igvt_observer_event_loop(void);
d40 2
a41 2
pthread_t igvt_observer_networking_thread;
pthread_mutex_t igvt_observer_gui_mut;
d44 4
a47 4
tienet_sem_t igvt_observer_sdlinit_sem;
tienet_sem_t igvt_observer_sdlready_sem;
tienet_sem_t igvt_observer_splash_sem;
pthread_mutex_t igvt_observer_console_mut;
d52 1
a52 1
short igvt_observer_endian;
d54 6
a59 6
short igvt_observer_event_queue_size;
SDL_Event igvt_observer_event_queue[64];
int igvt_observer_mouse_grab;
int igvt_observer_event_loop_alive;
int igvt_observer_display_init;
int igvt_observer_master_socket;
d64 2
a65 2
void igvt_observer(char *host, int port) {
  igvt_observer_net_info_t ni;
d76 2
a77 2
  igvt_observer_event_queue_size = 0;
  igvt_observer_event_loop_alive = 1;
d80 1
a80 1
  pthread_mutex_init(&igvt_observer_gui_mut, 0);
d82 5
a86 5
  tienet_sem_init(&igvt_observer_sdlinit_sem, 0);
  tienet_sem_init(&igvt_observer_sdlready_sem, 0);
  tienet_sem_init(&igvt_observer_splash_sem, 0);
  pthread_mutex_init(&igvt_observer_console_mut, 0);
  igvt_observer_display_init = 1;
d89 1
a89 1
  pthread_create(&igvt_observer_networking_thread, NULL, igvt_observer_networking, &ni);
d92 2
a93 2
  tienet_sem_wait(&igvt_observer_sdlinit_sem);
  igvt_observer_event_loop();
d96 1
a96 1
  pthread_join(igvt_observer_networking_thread, NULL);
d100 2
a101 2
void* igvt_observer_networking(void *ptr) {
  igvt_observer_net_info_t *ni;
d109 1
a109 1
#if IGVT_USE_COMPRESSION
d114 1
a114 1
  ni = (igvt_observer_net_info_t *)ptr;
d117 1
a117 1
  if((igvt_observer_master_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
d131 1
a131 1
  if(bind(igvt_observer_master_socket, (struct sockaddr *)&my_addr, sizeof(my_addr)) < 0) {
d137 1
a137 1
  if(connect(igvt_observer_master_socket, (struct sockaddr *)&srv_addr, sizeof(srv_addr)) < 0) {
d145 6
a150 6
  op = IGVT_NET_OP_INIT;
  tienet_send(igvt_observer_master_socket, &op, 1, igvt_observer_endian);
  tienet_recv(igvt_observer_master_socket, &igvt_observer_endian, sizeof(short), 0);
  igvt_observer_endian = igvt_observer_endian == 1 ? 0 : 1;
  tienet_recv(igvt_observer_master_socket, &screen_w, sizeof(int), igvt_observer_endian);
  tienet_recv(igvt_observer_master_socket, &screen_h, sizeof(int), igvt_observer_endian);
d153 1
a153 1
  tienet_sem_post(&igvt_observer_sdlinit_sem);
d157 1
a157 1
#if IGVT_USE_COMPRESSION
d168 2
a169 2
    op = IGVT_NET_OP_FRAME;
    tienet_send(igvt_observer_master_socket, &op, 1, igvt_observer_endian);
d172 2
a173 2
    tienet_recv(igvt_observer_master_socket, &op, 1, igvt_observer_endian);
    if(op == IGVT_NET_OP_QUIT) {
d176 1
a176 1
#if igvt_USE_COMPRESSION
d179 1
a179 1
      close(igvt_observer_master_socket);
d181 1
a181 1
      igvt_observer_event_loop_alive = 0;
d189 4
a192 4
    tienet_send(igvt_observer_master_socket, &igvt_observer_event_queue_size, sizeof(short), igvt_observer_endian);
    if(igvt_observer_event_queue_size)
      tienet_send(igvt_observer_master_socket, igvt_observer_event_queue, igvt_observer_event_queue_size * sizeof(SDL_Event), igvt_observer_endian);
    igvt_observer_event_queue_size = 0;
d197 1
a197 1
#if IGVT_USE_COMPRESSION
d202 2
a203 2
      tienet_recv(igvt_observer_master_socket, &comp_size, sizeof(int), 0);
      tienet_recv(igvt_observer_master_socket, comp_buf, comp_size, 0);
d209 1
a209 1
    tienet_recv(igvt_observer_master_socket, frame, 3*screen_w*screen_h, 0);
d212 4
a215 4
    if(igvt_observer_display_init) {
      igvt_observer_display_init = 0;
      tienet_sem_post(&igvt_observer_splash_sem);
      tienet_sem_wait(&igvt_observer_sdlready_sem);
d230 1
a230 1
      igvt_overlay_data_t overlay;
d233 1
a233 1
      tienet_recv(igvt_observer_master_socket, &overlay, sizeof(igvt_overlay_data_t), 0);
d236 1
a236 1
      pthread_mutex_lock(&igvt_observer_console_mut);
d262 1
a262 1
      pthread_mutex_unlock(&igvt_observer_console_mut);
d270 1
a270 1
void igvt_observer_process(char *content, char *response) {
d273 2
a274 2
  op = IGVT_NET_OP_MESG;
  tienet_send(igvt_observer_master_socket, &op, 1, 0);
d280 1
a280 1
    tienet_send(igvt_observer_master_socket, &op, 1, 0);
d283 1
a283 1
    tienet_send(igvt_observer_master_socket, content, op, 0);
d286 2
a287 2
    tienet_recv(igvt_observer_master_socket, &op, 1, 0);
    tienet_recv(igvt_observer_master_socket, response, op, 0);
d292 1
a292 1
void igvt_observer_event_loop() {
d317 1
a317 1
  tienet_sem_wait(&igvt_observer_splash_sem);
d323 1
a323 1
  tienet_sem_post(&igvt_observer_sdlready_sem);
d325 1
a325 1
  while(SDL_WaitEvent(&event) >= 0 && igvt_observer_event_loop_alive) {
d334 3
a336 3
            igvt_observer_mouse_grab = igvt_observer_mouse_grab ^ 1;
            SDL_WM_GrabInput(igvt_observer_mouse_grab ? SDL_GRAB_ON : SDL_GRAB_OFF);
            SDL_ShowCursor(!igvt_observer_mouse_grab);
d353 3
a355 3
            pthread_mutex_lock(&igvt_observer_console_mut);
            util_display_editor(content_buffer, &content_lines, console_buffer, &console_lines, igvt_observer_process);
            pthread_mutex_unlock(&igvt_observer_console_mut);
d369 2
a370 2
    if(igvt_observer_event_queue_size < 64)
      igvt_observer_event_queue[igvt_observer_event_queue_size++] = event;
@


1.16
log
@Minimal support to get rise_observer working.
@
text
@d277 12
a288 9
  op = strlen(content) + 1;
  tienet_send(igvt_observer_master_socket, &op, 1, 0);

  /* content */
  tienet_send(igvt_observer_master_socket, content, op, 0);

  /* get the response */
  tienet_recv(igvt_observer_master_socket, &op, 1, 0);
  tienet_recv(igvt_observer_master_socket, response, op, 0);
@


1.15
log
@Additional render data is now passed along in render method baggage in master. Observer reports fps on
screen now.  Add math_vec_set to libtie.  Master fires shotline by pressing keypad period, and keypad 0
places camera back at the shotline origin.
@
text
@a321 2
  SDL_EnableKeyRepeat(150, 50);

@


1.14
log
@New splash screen, and renaming IGVT to Interactive Shot Selection Tool (ISST) in progress,,,
@
text
@d107 2
d163 2
d218 9
d247 3
@


1.13
log
@Python interpretor working now.  Command interface has become a blender style
editing interface with ctrl+p to process and ctrl+l to clear buffers.  Rise image
output re-enabled.
@
text
@d292 1
a292 1
  util_display_init(512, 288);
d294 2
a295 2
  SDL_WM_SetCaption("ADRT_IGVT_Observer Loading...", NULL);
  util_display_draw((void *)splash_image.pixel_data);
d303 1
a303 2
  util_display_text("Loading ...", 10, 4, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);
  SDL_WM_SetCaption("ADRT_IGVT_Observer", NULL);
@


1.12
log
@Skeleton framework for python integration in place, console 75% done.
@
text
@d254 1
a254 1
void igvt_observer_command(char *command, char *response) {
d260 2
a261 2
  /* length of command */
  op = strlen(command) + 1;
d264 2
a265 2
  /* command */
  tienet_send(igvt_observer_master_socket, command, op, 0);
d275 2
a276 2
  char **command_buffer, **console_buffer;
  int command_lines, console_lines, i;
d279 1
a279 1
  command_lines = 0;
d281 1
a281 1
  command_buffer = (char **)malloc(sizeof(char *) * 100);
d284 1
a284 1
    command_buffer[i] = (char *)malloc(80);
d287 2
d338 1
a338 1
            util_display_console(command_buffer, &command_lines, console_buffer, &console_lines, igvt_observer_command);
d360 1
a360 1
    free(command_buffer[i]);
d363 1
a363 1
  free(command_buffer);
@


1.11
log
@more additions to the console and beginning to add python interpreter.
@
text
@d261 1
a261 1
  op = strlen(command);
a269 2

  printf("response: %s\n", response);
d275 2
a276 2
  char **command_buffer;
  int lines, i;
d279 2
a280 1
  lines = 0;
d282 2
a283 1
  for(i = 0; i < 100; i++)
d285 2
d336 1
a336 1
            util_display_console(command_buffer, &lines, igvt_observer_command);
d357 1
a357 1
  for(i = 0; i < 100; i++)
d359 2
d362 1
@


1.10
log
@Most of the console event handling is now in place... 50% done.
@
text
@d59 1
a102 1
  int sockd;
d115 1
a115 1
  if((sockd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
d129 1
a129 1
  if(bind(sockd, (struct sockaddr *)&my_addr, sizeof(my_addr)) < 0) {
d135 1
a135 1
  if(connect(sockd, (struct sockaddr *)&srv_addr, sizeof(srv_addr)) < 0) {
d144 2
a145 2
  tienet_send(sockd, &op, 1, igvt_observer_endian);
  tienet_recv(sockd, &igvt_observer_endian, sizeof(short), 0);
d147 2
a148 2
  tienet_recv(sockd, &screen_w, sizeof(int), igvt_observer_endian);
  tienet_recv(sockd, &screen_h, sizeof(int), igvt_observer_endian);
d165 1
a165 1
    tienet_send(sockd, &op, 1, igvt_observer_endian);
d168 1
a168 1
    tienet_recv(sockd, &op, 1, igvt_observer_endian);
d175 1
a175 1
      close(sockd);
d185 1
a185 1
    tienet_send(sockd, &igvt_observer_event_queue_size, sizeof(short), igvt_observer_endian);
d187 1
a187 1
      tienet_send(sockd, igvt_observer_event_queue, igvt_observer_event_queue_size * sizeof(SDL_Event), igvt_observer_endian);
d198 2
a199 2
      tienet_recv(sockd, &comp_size, sizeof(int), 0);
      tienet_recv(sockd, comp_buf, comp_size, 0);
d205 1
a205 1
    tienet_recv(sockd, frame, 3*screen_w*screen_h, 0);
a213 4
    pthread_mutex_lock(&igvt_observer_console_mut);

    /* Draw Frame */
    util_display_draw(frame);
d220 7
a226 1
      tienet_recv(sockd, &overlay, sizeof(igvt_overlay_data_t), 0);
a241 1
    }
d243 2
a244 2
    util_display_cross();
    util_display_flip();
d246 2
a247 1
    pthread_mutex_unlock(&igvt_observer_console_mut);
d255 17
@


1.9
log
@Started on util_display_console for use in igvt observer, 25% done.
@
text
@d258 1
a258 1
  char command_buffer[100][80];
d263 1
d265 1
a265 1
    command_buffer[i][0] = 0;
d315 1
a315 1
            util_display_console((char **)command_buffer, &lines, igvt_observer_command);
d334 5
@


1.8
log
@[F2] for screenshot in observer, output screenshot.ppm.
@
text
@d47 1
d84 1
d214 2
d244 2
d252 4
d258 7
d271 1
a271 1
  util_display_draw(splash_image.pixel_data);
d311 7
@


1.7
log
@formatting.
@
text
@d253 1
a253 1
  SDL_WM_SetCaption("ADRT_IGVT_Observer - Loading...", NULL);
d262 1
a262 1
/*  util_display_text("Loading ...", 10, 4, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP); */
d288 1
a288 1
              util_image_convert_32to24(image24, util_display_screen, screen_w, screen_h, 1);
@


1.6
log
@added splash screen and added sdl wasinit to display.
@
text
@d282 12
@


1.5
log
@Added rotate about center of rotation holding shift key + right mouse.
@
text
@d15 1
d46 1
d57 1
d82 2
a149 1
  tienet_sem_wait(&igvt_observer_sdlready_sem);
d206 6
d250 2
a251 2
  util_display_init(screen_w, screen_h);
  SDL_WM_SetCaption("ADRT_IGVT_Observer", NULL);
d253 2
a254 1
  util_display_text("Loading ...", 10, 4, UTIL_JUSTIFY_LEFT, UTIL_JUSTIFY_TOP);
d257 7
@


1.4
log
@put Observer F12 to shutdown master back in.
@
text
@a263 3
          case SDLK_q: /* quit, decouple display, end this function */
            break;

@


1.3
log
@use brlcad_config.h instead of config.h
@
text
@d54 1
d72 1
d170 2
a237 1
  int alive = 1;
d248 1
a248 1
  SDL_EnableKeyRepeat(50, 50);
d250 1
a250 1
  while(SDL_WaitEvent(&event) >= 0 && alive) {
a264 1
            alive = 0;
@


1.2
log
@hoisting build system and making it play nice with brlcad
@
text
@d1 1
a1 1
#include "config.h"
@


1.1
log
@Welcome ADRT
@
text
@d13 1
a13 1
#include "struct.h"
@

