head	1.12;
access;
symbols
	rel-7-10-4:1.12
	STABLE:1.12.0.2
	rel-7-10-2:1.12
	rel-7-10-0:1.12
	rel-7-8-4:1.8
	rel-7-8-2:1.8
	rel-7-8-0:1.8
	trimnurbs-branch:1.8.0.2
	help:1.8
	temp_tag:1.8
	postmerge-20051223-bobWinPort:1.8
	premerge-20051223-bobWinPort:1.8
	rel-7-6-6:1.8
	rel-7-6-4:1.8
	rel-7-6-2:1.2
	rel-7-6-branch:1.2.0.2
	rel-7-6-0:1.2;
locks; strict;
comment	@# @;


1.12
date	2007.02.08.06.49.19;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.23.01.13.23;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.21.00.10.08;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.20.13.39.46;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.23.04.44.28;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.20.04.42.21;	author twingy;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.20.02.30.14;	author twingy;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.20.01.59.40;	author twingy;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.20.01.43.02;	author twingy;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.09.03.31.08;	author twingy;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.07.19.40.15;	author twingy;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.08.16.04.18.20;	author twingy;	state Exp;
branches;
next	;

1.2.2.1
date	2005.11.13.13.46.12;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.12
log
@give adrt some distinctiveness in the header
@
text
@#                         A D R T . P Y
# BRL-CAD / ADRT
#
# Copyright (c) 2007 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# version 2.1 as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this file; see the file named COPYING for more
# information.
#
###
#
# Author -
#  Justin Shumaker
#
################
## REQUIRES PYTHON 2.3 RIGHT NOW
## CHANGE THESE TO WHERE YOUR PYTHON 2.2 IS LOCATED
#import sys
#sys.path.append('/usr/local/lib/python2.2')
#sys.path.append('/usr/local/lib/python2.2/lib-dynload')
################

import commands
import Blender
import math
import os
import struct
from struct import pack
from Blender import BGL, Draw, NMesh, Object, Camera, Lamp, Scene, Types
from math import log


framework_name = "scene"
layer_mask = 3
export_all_frames = 0
framework_button = 0

def export_meshes():
  fh = open(framework_name + ".adrt", "wb")

  ## Endian
  fh.write(pack('h', 1))

  ## Version
  fh.write(pack('h', 2))

  ## Calculate total number of triangles
  obj_list = Blender.Object.Get()

  num = 0
  for obj in obj_list:
    if (obj.Layer & layer_mask) == obj.Layer:
      if(type(obj.getData()) == Types.NMeshType):
        for f in obj.getData().faces:
          if len(f.v) == 4:
            num = num + 2
          if len(f.v) == 3:
            num = num + 1

  fh.write(pack('i', num))
  print "\nWriting %d triangles..." % num

  ## Pack each mesh
  for obj in obj_list:
    if (obj.Layer & layer_mask) == obj.Layer:
      if(type(obj.getData()) == Types.NMeshType):
        ## Mesh Name Length
        fh.write(pack('B', len(obj.getName())+1))
        ## Mesh Name
        fh.write(obj.getName())
        fh.write(pack('B', 0))
        ## Vertice Total
        fh.write(pack('I', len(obj.getData().verts)))
        ## Write Vertices
        for v in obj.getData().verts:
          fh.write(pack('fff', v.co[0], v.co[1], v.co[2]))
        ## Write Faces
        num = 0
        for f in obj.getData().faces:
          if len(f.v) == 4:
            num = num + 2
          if len(f.v) == 3:
            num = num + 1

        if(len(obj.getData().faces) < 1<<16):
          fh.write(pack('B', 0))
          fh.write(pack('H', num))
          for f in obj.getData().faces:
            if len(f.v) >= 3:
              fh.write(pack('HHH', f.v[0].index, f.v[1].index, f.v[2].index))
            if len(f.v) == 4:
              fh.write(pack('HHH', f.v[0].index, f.v[2].index, f.v[3].index))
        else:
          fh.write(pack('B', 1))
          fh.write(pack('I', num))
          for f in obj.getData().faces:
            if len(f.v) >= 3:
              fh.write(pack('III', f.v[0].index, f.v[1].index, f.v[2].index))
            if len(f.v) == 4:
              fh.write(pack('III', f.v[0].index, f.v[2].index, f.v[3].index))



  ## close the file handle
  fh.close()


def export_properties():
  fh = open(framework_name + ".properties", "w")

  print "Writing Properties..."

  ## default property
  fh.write("properties,%s\n" % "default")
  fh.write("color,%f,%f,%f\n" % (0.8, 0.8, 0.8))
  fh.write("gloss,%f\n" % (0.2))
  fh.write("emission,%f\n" % (0.0))

  for m in Blender.Material.Get():
    fh.write("properties,%s\n" % m.getName())
    fh.write("color,%f,%f,%f\n" % (m.rgbCol[0], m.rgbCol[1], m.rgbCol[2]))
    if(m.getEmit() > 0.0):
      fh.write("emission,%f\n" % (m.getEmit()))
  fh.close()


def export_textures():
  fh = open(framework_name + ".textures", "w")

  print "Writing Textures..."
  fh.close()


def export_mesh_map():
  fh = open(framework_name + ".map", "wb")

  print "Writing Mesh Map..."
  obj_list = Blender.Object.Get()
  for obj in obj_list:
    if (obj.Layer & layer_mask) == obj.Layer:
      if(type(obj.getData()) == Types.NMeshType):
        if(len(obj.getData().materials)) > 0:
          fh.write(pack('B', len(obj.getName())+1))
          fh.write(obj.getName());
          fh.write(pack('B', 0))

          fh.write(pack('B', len(obj.getData().materials[0].getName())+1))
          fh.write(obj.getData().materials[0].getName());
          fh.write(pack('B', 0))
        else:
          fh.write(pack('B', len(obj.getName())+1))
          fh.write(obj.getName());
          fh.write(pack('B', 0))

          fh.write(pack('B', len("default")+1))
          fh.write("default");
          fh.write(pack('B', 0))



  fh.close()


def write_camera(fh, obj):
  focus = [0, 0, 0]

  fh.write("camera")

  loc = obj.matrix[3]
  look = obj.matrix[2]
  upvec = obj.matrix[1]

  # Generate Focus/Look Vector
  focus[0] = loc[0] - look[0]
  focus[1] = loc[1] - look[1]
  focus[2] = loc[2] - look[2]

  fh.write(",%f,%f,%f" % (loc[0], loc[1], loc[2])) # position
  fh.write(",%f,%f,%f" % (focus[0], focus[1], focus[2])) # focus
  fh.write(",0.0") # tilt


  # Vertical FoV = 2 * atan(height/(2*lens_mm)) * pi / 180
  # Horiz FoV = 2 * atan(width/(2*lens_mm)) * pi / 180
  #
  # simulate a 35mm camera w 24x36mm image plane
  # Blender uses the image width for this calcuation

  FoV = math.atan(35.0 / (2.0 * obj.getData().getLens())) * 180 / math.pi * 0.75

  fh.write(",%f,%f\n" % (FoV, 0.0))


def write_frame(fh, frame):
  print "Writing frame: %d" % frame
  fh.write("frame,%d\n" % frame)

  m_identity = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]

  obj_list = Blender.Object.Get()
  for obj in obj_list:
    if(obj.Layer & layer_mask) == obj.Layer:
      if type(obj.getData()) == Types.CameraType:
        write_camera(fh, obj)

    if type(obj.getData()) == Types.NMeshType:
      obj_name = obj.getName()
      m = obj.matrix

      same = 1
      for y in range(4):
        for x in range(4):
          if m[x][y] != m_identity[x][y]:
            same = 0

      if same == 0:
        fh.write("transform_mesh,%s" % obj_name)
        fh.write(",%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f\n" % \
                (m[0][0], m[0][1], m[0][2], m[0][3], m[1][0], m[1][1], m[1][2], m[1][3], \
                 m[2][0], m[2][1], m[2][2], m[2][3], m[3][0], m[3][1], m[3][2], m[3][3]))


def export_frames():
  global export_all_frames

  fh = open(framework_name + ".frames", "w")

  cur = Blender.Get('curframe')

  if export_all_frames == 0:
    write_frame(fh, cur)
  else:
    sta = Blender.Get('staframe')
    end = Blender.Get('endframe')
    for frame in range (sta, end+1):
      Blender.Set('curframe', frame)
      Blender.Window.RedrawAll()
      write_frame(fh, frame)


  fh.close()


def export_environment():
  fh = open(framework_name + ".env", "w")
  fh.write("geometry_file," + framework_name + ".adrt\n")
  fh.write("properties_file," + framework_name + ".properties\n")
  fh.write("textures_file," + framework_name + ".textures\n")
  fh.write("mesh_map_file," + framework_name + ".map\n")
  fh.write("frames_file," + framework_name + ".frames\n")
  fh.write("image_size,512,384,128,128\n")
  fh.write("rendering_method,normal\n")
  fh.close()


def event(evt, val):
  if evt == Draw.ESCKEY:
    Draw.Exit()
    return
  else:
    return
  Draw.Register(draw_gui, event, buttonEvent)


def button_event(evt):
  global framework_button, framework_name, layer_mask, export_all_frames

  ## Export ADRT Framework
  if evt == 1:
    ## export mesh data
    export_meshes()

    ## export properties data
    export_properties()

    ## export textures data
    export_textures()

    ## export mesh map
    export_mesh_map()

    ## export frame data
    export_frames()

    ## export an environment file
    export_environment()
    print "Complete."

  if evt == 2:
    framework_name = framework_button.val

  if evt == 3:
    layer_mask = 0xfffff

  if evt == 4:
    layer_mask = 0

  if evt == 5:
    export_all_frames ^= 1

  if evt >= 32:
    layer_mask ^= 1<<(evt - 32)

  Draw.Redraw(1)


def draw_gui():
  global framework_button, framework_name, layer_mask, export_all_frames

  ##########
  Draw.Button("Export ADRT Framework", 1, 0, 0, 160, 20, "Export Scene")
  framework_button = Draw.String("Framework Name:", 2, 160, 0, 240, 20, framework_name, 64, "Framework Name")
  ##########


  ##########
  Draw.Button("Select All", 3, 0, 60, 160, 20, "Deselect all Layers")
  Draw.Button("Select None", 4, 0, 40, 160, 20, "Select all Layers")

  layer_id = 0
  for row in range(2):
    for col in range(10):
      Draw.Toggle(" ", 32+layer_id, 160+col*20, 60-row*20, 20, 20, layer_mask & 1<<layer_id, "")
      layer_id += 1
  ##########

  ##########
  Draw.Toggle("Export All Frames", 5, 0, 100, 160, 20, export_all_frames, "")
  ##########


############################################
## Begin Event Handling
############################################
Draw.Register(draw_gui, event, button_event)
############################################

# Local Variables:
# mode: Python
# tab-width: 8
# c-basic-offset: 4
# python-indent-level: 4
# indent-tabs-mode: t
# End:
# ex: shiftwidth=4 tabstop=8
@


1.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d2 1
a2 1
# BRL-CAD
@


1.10
log
@apply the standard header and footer, more to come
@
text
@d9 1
a9 1
# as published by the Free Software Foundation.
@


1.9
log
@trailing newline
@
text
@d1 24
d347 9
@


1.8
log
@trailing ws
@
text
@d322 1
a322 1
############################################@


1.7
log
@null terminator
@
text
@d167 2
a168 2
          
      
d174 1
a174 1
      
d176 1
a176 1
  
@


1.6
log
@signed stuff
@
text
@d28 1
a28 1
  fh.write(pack('H', 1))
d31 1
a31 1
  fh.write(pack('H', 2))
d46 1
a46 1
  fh.write(pack('I', num))
d133 1
a133 1
          fh.write(pack('B', len(obj.getData().materials[0].getName())))
d322 1
a322 1
############################################
@


1.5
log
@fixed string termination on mesh name
@
text
@d28 1
a28 1
  fh.write(pack('h', 1))
d31 1
a31 1
  fh.write(pack('h', 2))
d46 1
a46 1
  fh.write(pack('i', num))
@


1.4
log
@uses binary .map file now
@
text
@d54 1
a54 1
        fh.write(pack('B', len(obj.getName())))
d57 1
@


1.3
log
@fixed python exporter.
@
text
@d120 1
a120 1
  fh = open(framework_name + ".map", "w")
d128 7
a134 1
          fh.write(obj.getName() + "," + obj.getData().materials[0].getName() + "\n")
d136 8
a143 1
          fh.write(obj.getName() + ",default\n")
@


1.2
log
@new and improved blender exporter, 98% fat free.
@
text
@d63 7
d72 1
a72 1
          fh.write(pack('H', len(obj.getData().faces)))
d80 1
a80 1
          fh.write(pack('I', len(obj.getData().faces)))
d223 1
a223 1
  fh.write("image_size,1024,768,128,128\n")
d265 3
a291 1

@


1.2.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d54 1
a54 1
        fh.write(pack('B', len(obj.getName())+1))
a56 1
        fh.write(pack('B', 0))
a62 7
        num = 0
        for f in obj.getData().faces:
          if len(f.v) == 4:
            num = num + 2
          if len(f.v) == 3:
            num = num + 1

d65 1
a65 1
          fh.write(pack('H', num))
d73 1
a73 1
          fh.write(pack('I', num))
d113 1
a113 1
  fh = open(framework_name + ".map", "wb")
d121 1
a121 7
          fh.write(pack('B', len(obj.getName())+1))
          fh.write(obj.getName());
          fh.write(pack('B', 0))

          fh.write(pack('B', len(obj.getData().materials[0].getName())+1))
          fh.write(obj.getData().materials[0].getName());
          fh.write(pack('B', 0))
d123 1
a123 8
          fh.write(pack('B', len(obj.getName())+1))
          fh.write(obj.getName());
          fh.write(pack('B', 0))

          fh.write(pack('B', len("default")+1))
          fh.write("default");
          fh.write(pack('B', 0))

d146 2
a147 2


d153 1
a153 1

d155 1
a155 1

d216 1
a216 1
  fh.write("image_size,512,384,128,128\n")
a257 3
    layer_mask = 0xfffff

  if evt == 4:
d282 1
d299 1
a299 1
############################################@


1.1
log
@in the process of fixing adrt.py and tie.c is ~2% faster.
@
text
@d4 3
a6 3
import sys
sys.path.append('/usr/local/lib/python2.2')
sys.path.append('/usr/local/lib/python2.2/lib-dynload')
d13 2
a16 14
#################
animation = 0
layers = []
layerBase = 40
i = 0
while i < 20:
    layers.append(1)
    i += 1
layerBits = 0
layerBtns = []
propertiesList = []
projectName = "proj"
projectButton = 0
#################
d19 4
a22 7
def event(evt, val):
  if evt == Draw.ESCKEY:
    Draw.Exit()
    return
  else:
    return
  Draw.Register(drawGUI, event, buttonEvent)
d24 2
d27 2
a28 2
def NMeshDump(of, obj, mesh):
  global propertiesList
d30 2
a31 19
  myName = obj.getName()
  if not mesh.materials:
    ## Write length of Name
    of.write(pack('b', len(myName)))
    of.write(myName)
    of.write(pack('b', 0))
  else:
    matName = mesh.materials[0].getName()
    ## Write length of Name
    of.write(pack('b', len(myName)))
    of.write(myName)
    of.write(pack('b', len(matName)))
    of.write(matName)

    found = -1
    try:
      found = propertiesList.index(matName)
    except ValueError:
      pass
d33 2
a35 1
  ## Write Number of Triangles
d37 42
a78 34
  for f in mesh.faces:
    if len(f.v) == 4:
      num = num + 2
    if len(f.v) == 3:
      num = num + 1
  of.write(pack('i', num))

  ## Write Triangles
  for f in mesh.faces:
    if len(f.v) >= 3:
      if f.smooth:
        smooth = chr(1)
      else:
        smooth = chr(0)
      of.write(pack('c', smooth))
      of.write(pack('fffffffff', mesh.verts[f.v[0].index].co[0], mesh.verts[f.v[0].index].co[1], mesh.verts[f.v[0].index].co[2],
                                 mesh.verts[f.v[1].index].co[0], mesh.verts[f.v[1].index].co[1], mesh.verts[f.v[1].index].co[2],
                                 mesh.verts[f.v[2].index].co[0], mesh.verts[f.v[2].index].co[1], mesh.verts[f.v[2].index].co[2]))

      ## Smooth Normals
      if f.smooth:
        of.write(pack('fffffffff', mesh.verts[f.v[0].index].no[0], mesh.verts[f.v[0].index].no[1], mesh.verts[f.v[0].index].no[2],
                                   mesh.verts[f.v[1].index].no[0], mesh.verts[f.v[1].index].no[1], mesh.verts[f.v[1].index].no[2],
                                   mesh.verts[f.v[2].index].no[0], mesh.verts[f.v[2].index].no[1], mesh.verts[f.v[2].index].no[2]))

      if len(f.v) == 4:
        of.write(pack('c', smooth))
        of.write(pack('fffffffff', mesh.verts[f.v[0].index].co[0], mesh.verts[f.v[0].index].co[1], mesh.verts[f.v[0].index].co[2],
                                   mesh.verts[f.v[2].index].co[0], mesh.verts[f.v[2].index].co[1], mesh.verts[f.v[2].index].co[2],
                                   mesh.verts[f.v[3].index].co[0], mesh.verts[f.v[3].index].co[1], mesh.verts[f.v[3].index].co[2]))
        if f.smooth:
          of.write(pack('fffffffff', mesh.verts[f.v[0].index].no[0], mesh.verts[f.v[0].index].no[1], mesh.verts[f.v[0].index].no[2],
                                     mesh.verts[f.v[2].index].no[0], mesh.verts[f.v[2].index].no[1], mesh.verts[f.v[2].index].no[2],
                                     mesh.verts[f.v[3].index].no[0], mesh.verts[f.v[3].index].no[1], mesh.verts[f.v[3].index].no[2]))
d82 14
a95 3
def dumpMeshes():
  global exportStatus, layerBits
  objList = Blender.Object.Get()
d97 6
a102 3
  of = open(projectName + "/mesh.db", "w")
  ## Endian
  of.write(pack('h', 1))
a103 25
  objCount = 0
  for obj in objList:
      if (obj.Layer & layerBits) == 0:
          continue
      if type(obj.getData()) == Types.NMeshType:
          objCount += 1

  i = 0
  for obj in objList:
      if (obj.Layer & layerBits) == 0:
          continue
      data = obj.getData()
      if type(data) == Types.NMeshType:
          exportStatus = "Mesh %d of %d %s" % \
                         (i, objCount, obj.getName())
          print exportStatus
          Draw.Draw()
          NMeshDump(of, obj, data)
          i += 1


def dumpProperties():
  propertiesFileName = projectName + "/properties.db"
  print propertiesFileName
  propertiesFile = open(propertiesFileName, "w")
d105 2
a106 2
  objCount = 0
  objCount = len(Blender.Material.Get())
d108 2
a109 5
  i = 0
  for m in Blender.Material.Get():
    myName = m.getName()
    exportStatus = "Properties for %s (%d of %d)" % (myName, i, objCount)
    print exportStatus
a110 1
    propertiesFile.write("properties,%s\n" % (myName))
d112 2
a113 2
    propertiesFile.write("color,%f,%f,%f\n" % \
            (m.rgbCol[0], m.rgbCol[1], m.rgbCol[2]))
d115 9
a123 2
    i += 1
  propertiesFile.close()
d126 1
a126 15
def dumpFrames():
  cur = Blender.Get('curframe')
  frameFileName = projectName + "/frame.db"
  frameFile = open(frameFileName, "w")

  if animation == 0:
    dumpOneFrame(frameFile, cur)
  else:
    sta = Blender.Get('staframe')
    end = Blender.Get('endframe')
    for frame in range (sta, end+1):
      Blender.Set('curframe', frame)
      Blender.Window.RedrawAll()
      dumpOneFrame(frameFile, frame)
  frameFile.close()
d129 1
a129 1
def dumpCamera(of, obj, cam):
d132 1
a132 1
  of.write("camera")
d143 5
a147 5
  of.write(",%f,%f,%f" % (loc[0], loc[1], loc[2])) # position
  of.write(",%f,%f,%f" % (focus[0], focus[1], focus[2])) # focus
  of.write(",0.0") # tilt


d153 4
a157 1
  FoV = math.atan(35.0 / (2.0 * cam.getLens())) * 180 / math.pi * 0.75
d159 3
a161 1
  of.write(",%f,%f\n" % (FoV, 0.0))
d163 1
d165 5
a169 3
def dumpOneFrame(of, n):
  print "exporting frame: %d" % n
  of.write("frame,%d\n" % n)
d171 2
a172 11
  objList = Blender.Object.Get()
  m_identity = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]

  for obj in objList:
    if (obj.Layer & layerBits) == 0:
      continue
    data = obj.getData()
    if type(data) == Types.CameraType:
      dumpCamera(of, obj, data)
    if type(data) == Types.NMeshType:
      objName = obj.getName()
d181 5
a185 3
      if same != 1:
        of.write("transform_mesh,%s" % objName)
        of.write(",%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f\n" % (m[0][0], m[0][1], m[0][2], m[0][3], m[1][0], m[1][1], m[1][2], m[1][3], m[2][0], m[2][1], m[2][2], m[2][3], m[3][0], m[3][1], m[3][2], m[3][3]))
d188 2
d191 1
a191 10
def mat_mul(b, a):
  m = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
  mat_print("    a", a)
  mat_print("    b", b)
  for j in range(4):
    for i in range(4):
      m[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + \
                a[i][2] * b[2][j] + a[i][3] * b[3][j]
  mat_print("    m", m)
  return m
d193 1
d195 33
a227 6
def mat_print(s, m):
  print s
  print "\t%f %f %f %f" % (m[0][0], m[0][1], m[0][2], m[0][3])
  print "\t%f %f %f %f" % (m[1][0], m[1][1], m[1][2], m[1][3])
  print "\t%f %f %f %f" % (m[2][0], m[2][1], m[2][2], m[2][3])
  print "\t%f %f %f %f" % (m[3][0], m[3][1], m[3][2], m[3][3])
d230 2
a231 2
def doExport():
  global layerBits
d233 4
a236 1
  print "Exporting...\n"
d238 2
a239 7
  ## Built Layer Bit Mask
  i = 0
  layerBits = 0
  while i < 20:
    if layers[i] != 0:
      layerBits |= (1 << i)
    i += 1
d241 2
a242 2
  ## Make Project Directory
  commands.getoutput("mkdir %s" % projectName)
d244 2
a245 3
  envFileName = projectName + "/settings.env"
  print envFileName
  envFile = open(envFileName, "w")
d247 2
a248 2
  envFile.write("image_size,%d,%d\n" % (640,480))
  envFile.write("rendering_method,normal\n")
d250 3
a252 1
  envFile.close();
d254 2
a255 3
  textureFileName = projectName + "/texture.db"
  textureFile = open(textureFileName, "w")
  textureFile.close();
d257 2
a258 2
  dumpMeshes()
  dumpProperties()
d260 2
a261 4
  if animation == 1:
    dumpFrames()
  else
    dumpOneFrame(, 1)
d263 2
a264 2
def buttonEvent(evt):
  global animation, sceneVal, layerBtns, layers, projectName, projectButton
a265 17
  if evt == 8:
    projectName = projectButton.val
  if evt == 1:
    doExport()
  elif evt == 4:
    animation = 1 - animation
  elif evt == 6:
    for i in range(20):
      layers[i] = 1
      layerBtns[i].val = 1
  elif evt == 7:
    for i in range(20):
      layers[i] = 0
      layerBtns[i].val = 0
  elif evt >= layerBase and evt < layerBase + 20:
    layerNumber = evt - layerBase
    layers[layerNumber] = 1 - layers[layerNumber]
d269 2
a270 2
def drawGUI():
  global layers, layerBtns, projectName, projectButton
d272 4
a275 15
  ## Set background color
#  BGL.glClearColor(0.0, 0.0, 0.0, 1)
#  BGL.glClear(BGL.GL_COLOR_BUFFER_BIT)

  xPad = 10
  height = 18
  yLoc = xPad + 10
  yDelta = height

  expWidth = Draw.GetStringWidth("Export", 'normal') + 40
  Draw.Button("Export", 1, xPad, yLoc, expWidth, 2*height, "Export Scene")

  # Draw the layer buttons
  layerBtn = 0 # start with the bottom row
  btnSize = height
a276 7
  for row in range(2):
    ypos = yLoc + (1-row) * btnSize
    xpos = xPad
    for col in range(10):
      layerBtns.append(Draw.Toggle(" ",  layerBase + layerBtn, expWidth + xpos, ypos, btnSize, btnSize, layers[layerBtn]))
      xpos += btnSize
      layerBtn += 1
d278 3
a280 2
  Draw.Button("All", 6, 10*btnSize + xPad + expWidth, yLoc, btnSize*5, height, "Deselect all Layers")
  Draw.Button("None", 7, 10*btnSize + xPad + expWidth, yLoc+btnSize, btnSize*5, height, "Select all Layers")
d283 6
a288 2
  yLoc += yDelta
  yLoc += yDelta
d290 3
a292 2
  Draw.Toggle("Export Animation Data", 4, xPad, yLoc, 345, height, animation, "Export Animation Data")
  yLoc += yDelta
a293 4
  projectName = os.getcwd()
  projectName += "/myproj"
  projectButton = Draw.String("Project:", 8, xPad, yLoc, 345, height, projectName, 64, "Project Name")
  yLoc += yDelta
d295 1
a295 1
##########################################
d297 3
a299 3
##########################################
Draw.Register(drawGUI, event, buttonEvent)
##########################################
@

