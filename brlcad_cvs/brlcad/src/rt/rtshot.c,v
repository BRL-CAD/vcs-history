head	14.19;
access;
symbols
	rel-7-10-4:14.13
	STABLE:14.13.0.2
	stable-branch:14.4
	rel-7-10-2:14.13
	rel-7-10-0:14.13
	rel-7-8-4:14.11
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.6
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.19
date	2007.11.22.07.04.04;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.11.21.21.21.40;	author erikgreenwald;	state Exp;
branches;
next	14.17;

14.17
date	2007.11.21.20.49.10;	author erikgreenwald;	state Exp;
branches;
next	14.16;

14.16
date	2007.11.21.20.38.23;	author erikgreenwald;	state Exp;
branches;
next	14.15;

14.15
date	2007.11.21.19.28.07;	author erikgreenwald;	state Exp;
branches;
next	14.14;

14.14
date	2007.09.15.16.23.20;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.46;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.37.00;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.28.00.36.29;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.23.04.05.59;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.14.03.22.09;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.12.08.01.43.01;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.23.04.44.38;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.09.19.18.02.09;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.09;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.24.01.40.00;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.38.22;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.16.03.13.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.59;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.35;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.46;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.19
log
@bu_exit formats the exit statement distinctly, don't confuse it as a complete drop-in replacement for bu_log+exit
@
text
@/*                        R T S H O T . C
 * BRL-CAD
 *
 * Copyright (c) 1987-2007 United  States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file rtshot.c
 *
 *  Demonstration Ray Tracing main program, using RT library.
 *  Fires a single ray, given any two of these three parameters:
 *	start point
 *	at point
 *	direction vector
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.18 2007/11/21 21:21:40 erikgreenwald Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "../librt/debug.h"
#include "plot3.h"


extern void rt_raybundle_maker( struct xray	*rp,
				double		radius,
				const vect_t	avec,
				const vect_t	bvec,
				int		rays_per_ring,
				int		nring);

extern int rt_shootray_bundle( struct application *ap,
			       struct xray		*rays,
			       int			nrays);

char	usage[] = "\
Usage:  rtshot [options] model.g objects...\n\
 -U #		Set use_air flag\n\
 -u #		Set libbu debug flag\n\
 -x #		Set librt debug flags\n\
 -X #		Set rt program debug flags\n\
 -N #		Set NMG debug flags\n\
 -d # # #	Set direction vector\n\
 -p # # #	Set starting point\n\
 -a # # #	Set shoot-at point\n\
 -t #		Set number of triangles per piece for BOT's (default is 4)\n\
 -b #		Set threshold number of triangles to use pieces (default is 32)\n\
 -O #		Set overlap-claimant handling\n\
 -o #		Set onehit flag\n\
 -r #		Set ray length\n\
 -n #		Set number of rings for ray bundle\n\
 -c #		Set number of rays per ring for ray bundle\n\
 -R #		Set radius for ray bundle\n\
 -v \"attribute_name1 attribute_name2 ...\" Show attribute values\n";

static FILE	*plotfp;		/* For plotting into */

int		set_dir = 0;
int		set_pt = 0;
int		set_at = 0;
int		set_onehit = 0;
fastf_t		set_ray_length = 0.0;
vect_t		at_vect;
int		overlap_claimant_handling = 0;
int		use_air = 0;		/* Handling of air */
int		rays_per_ring = 0;
int		num_rings = 0;
fastf_t		bundle_radius = 0.0;

extern int hit(struct application *ap, struct partition *PartHeadp, struct seg *segp);
extern int miss(register struct application *ap);
extern int rt_bot_tri_per_piece;
extern int rt_bot_minpieces;

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
    struct application	ap;

    static struct rt_i *rtip;
    char *title_file;
    char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
    char *ptr;
    int attr_count=0, i;
    char **attrs = (char **)NULL;

    if( argc < 3 )  {
	bu_exit(1, usage);
    }

    RT_APPLICATION_INIT(&ap);

    argc--;
    argv++;
    while( argv[0][0] == '-' ) switch( argv[0][1] )  {
	case 'R':
	    bundle_radius = atof( argv[1] );
	    argc -= 2;
	    argv += 2;
	    break;
	case 'n':
	    num_rings = atoi( argv[1] );
	    argc -= 2;
	    argv += 2;
	    break;
	case 'c':
	    rays_per_ring = atoi( argv[1] );
	    argc -= 2;
	    argv += 2;
	    break;
	case 'v':
	    /* count the number of attribute names provided */
	    ptr = argv[1];
	    while( *ptr ) {
		while( *ptr && isspace( *ptr ) )
		    ptr++;
		if( *ptr )
		    attr_count++;
		while( *ptr && !isspace( *ptr ) )
		    ptr++;
	    }

	    if( attr_count == 0 ) {
		bu_log( "missing list of attribute names!\n" );
		bu_exit( 1, usage );
	    }

	    /* allocate enough for a null terminated list */
	    attrs = (char **)bu_calloc( attr_count + 1, sizeof( char *), "attrs" );

	    /* use strtok to actually grab the names */
	    i = 0;
	    ptr = strtok( argv[1], "\t " );
	    while( ptr && i < attr_count ) {
		attrs[i] = bu_strdup( ptr );
		ptr = strtok( (char *)NULL, "\t " );
		i++;
	    }
	    argc -= 2;
	    argv += 2;
	    break;
	case 't':
	    rt_bot_tri_per_piece = atoi( argv[1] );
	    argc -= 2;
	    argv += 2;
	    break;
	case 'b':
	    rt_bot_minpieces = atoi( argv[1] );
	    argc -= 2;
	    argv += 2;
	    break;
	case 'o':
	    sscanf( argv[1], "%d", &set_onehit );
	    argc -= 2;
	    argv += 2;
	    break;
	case 'r':
	    {
		float ray_len;

		sscanf( argv[1], "%f", &ray_len );
		set_ray_length = ray_len;
	    }
	    argc -= 2;
	    argv += 2;
	    break;
	case 'U':
	    sscanf( argv[1], "%d", &use_air );
	    argc -= 2;
	    argv += 2;
	    break;
	case 'u':
	    sscanf( argv[1], "%x", (unsigned int *)&bu_debug );
	    fprintf(stderr,"librt bu_debug=x%x\n", bu_debug);
	    argc -= 2;
	    argv += 2;
	    break;
	case 'x':
	    sscanf( argv[1], "%x", (unsigned int *)&rt_g.debug );
	    fprintf(stderr,"librt rt_g.debug=x%x\n", rt_g.debug);
	    argc -= 2;
	    argv += 2;
	    break;
	case 'X':
	    sscanf( argv[1], "%x", (unsigned int *)&rdebug );
	    fprintf(stderr,"rdebug=x%x\n", rdebug);
	    argc -= 2;
	    argv += 2;
	    break;
	case 'N':
	    sscanf( argv[1], "%x", (unsigned int *)&rt_g.NMG_debug);
	    fprintf(stderr,"librt rt_g.NMG_debug=x%x\n", rt_g.NMG_debug);
	    argc -= 2;
	    argv += 2;
	    break;
	case 'd':
	    if( argc < 4 )  goto err;
	    ap.a_ray.r_dir[X] = atof( argv[1] );
	    ap.a_ray.r_dir[Y] = atof( argv[2] );
	    ap.a_ray.r_dir[Z] = atof( argv[3] );
	    set_dir = 1;
	    argc -= 4;
	    argv += 4;
	    continue;

	case 'p':
	    if( argc < 4 )  goto err;
	    ap.a_ray.r_pt[X] = atof( argv[1] );
	    ap.a_ray.r_pt[Y] = atof( argv[2] );
	    ap.a_ray.r_pt[Z] = atof( argv[3] );
	    set_pt = 1;
	    argc -= 4;
	    argv += 4;
	    continue;

	case 'a':
	    if( argc < 4 )  goto err;
	    at_vect[X] = atof( argv[1] );
	    at_vect[Y] = atof( argv[2] );
	    at_vect[Z] = atof( argv[3] );
	    set_at = 1;
	    argc -= 4;
	    argv += 4;
	    continue;

	case 'O':
	    {
		if( !strcmp( argv[1], "resolve" ) || !strcmp( argv[1], "0") )
		    overlap_claimant_handling = 0;
		else if( !strcmp( argv[1], "rebuild_fastgen" ) || !strcmp( argv[1], "1") )
		    overlap_claimant_handling = 1;
		else if( !strcmp( argv[1], "rebuild_all" ) || !strcmp( argv[1], "2") )
		    overlap_claimant_handling = 2;
		else if( !strcmp( argv[1], "retain" ) || !strcmp( argv[1], "3") )
		    overlap_claimant_handling = 3;
		else
		    {
			bu_log( "Illegal argument (%s) to '-O' option.  Must be:\n", argv[1] );
			bu_log( "\t'resolve' or '0'\n");
			bu_log( "\t'rebuild_fastgen' or '1'\n");
			bu_log( "\t'rebuild_all' or '2'\n");
			bu_log( "\t'retain' or '3'\n");
			bu_exit(1, NULL);
		    }
		argc -= 2;
		argv += 2;
	    }
	    continue;

	default:
    err:
	    bu_exit(1, usage);
    }
    if( argc < 2 )  {
	(void)fputs(usage, stderr);
	bu_exit(1,"rtshot: MGED database not specified\n");
    }

    if( set_dir + set_pt + set_at != 2 )  goto err;

    if( num_rings != 0 || rays_per_ring != 0 || bundle_radius != 0.0 ) {
	if( num_rings <= 0 || rays_per_ring <= 0 || bundle_radius <= 0.0 ) {
	    fprintf( stderr, "Must have all of \"-R\", \"-n\", and \"-c\" set\n" );
	    goto err;
	}
    }

    /* Load database */
    title_file = argv[0];
    argv++;
    argc--;
    if( (rtip=rt_dirbuild(title_file, idbuf, sizeof(idbuf))) == RTI_NULL ) {
	bu_exit(2,"rtshot:  rt_dirbuild failure\n");
    }

    if( overlap_claimant_handling )
	rtip->rti_save_overlaps = 1;

    ap.a_rt_i = rtip;
    fprintf(stderr, "db title:  %s\n", idbuf);
    rtip->useair = use_air;

    /* Walk trees */
    if( rt_gettrees_and_attrs( rtip, (const char **)attrs, argc, (const char **)argv, 1 ) ) {
	bu_exit(1, "rt_gettrees FAILED\n");
    }
    ap.attrs = attrs;

    rt_prep(rtip);

    if( R_DEBUG&RDEBUG_RAYPLOT )  {
	if( (plotfp = fopen("rtshot.plot", "w")) == NULL )  {
	    perror("rtshot.plot");
	    bu_exit(1, NULL);
	}
	pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
    }

    /* Compute r_dir and r_pt from the inputs */
    if( set_at )  {
	if( set_dir ) {
	    vect_t	diag;
	    fastf_t	viewsize;
	    VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
	    viewsize = MAGNITUDE( diag );
	    VJOIN1( ap.a_ray.r_pt, at_vect,
		    -viewsize/2.0, ap.a_ray.r_dir );
	} else {
	    /* set_pt */
	    VSUB2( ap.a_ray.r_dir, at_vect, ap.a_ray.r_pt );
	}
    }
    VUNITIZE( ap.a_ray.r_dir );

    if( rays_per_ring ) {
	bu_log( "Central Ray:\n" );
    }
    VPRINT( "Pnt", ap.a_ray.r_pt );
    VPRINT( "Dir", ap.a_ray.r_dir );

    if( set_onehit )
	ap.a_onehit = set_onehit;
    else
	ap.a_onehit = 0;

    if( set_ray_length > 0.0 )
	ap.a_ray_length = set_ray_length;
    else
	ap.a_ray_length = 0.0;

    /* Shoot Ray */
    ap.a_purpose = "main ray";
    ap.a_hit = hit;
    ap.a_miss = miss;

    if( rays_per_ring ) {
	vect_t avec, bvec;
	struct xray *rp;

	/* create orthogonal rays for basis of bundle */
	bn_vec_ortho( avec, ap.a_ray.r_dir );
	VCROSS( bvec, ap.a_ray.r_dir, avec );
	VUNITIZE( bvec );

	rp = (struct xray *)bu_calloc( sizeof( struct xray ),
				       (rays_per_ring * num_rings) + 1,
				       "ray bundle" );
	rp[0] = ap.a_ray;	/* struct copy */
	rp[0].magic = RT_RAY_MAGIC;
	rt_raybundle_maker( rp, bundle_radius, avec, bvec, rays_per_ring, num_rings );
	(void)rt_shootray_bundle( &ap, rp, (rays_per_ring * num_rings) + 1 );
    } else {
	(void)rt_shootray( &ap );
    }

    return(0);
}

int hit(register struct application *ap, struct partition *PartHeadp, struct seg *segp)
{
    register struct partition *pp;
    register struct soltab *stp;
    struct curvature cur;
    fastf_t out;
    point_t inpt, outpt;
    vect_t	inormal, onormal;

    if( (pp=PartHeadp->pt_forw) == PartHeadp )
	return(0);		/* Nothing hit?? */

    if( overlap_claimant_handling == 1 )
	rt_rebuild_overlaps( PartHeadp, ap, 1 );
    else if( overlap_claimant_handling == 2 )
	rt_rebuild_overlaps( PartHeadp, ap, 0 );

    /* First, plot ray start to inhit */
    if( R_DEBUG&RDEBUG_RAYPLOT )  {
	if( pp->pt_inhit->hit_dist > 0.0001 )  {
	    VJOIN1( inpt, ap->a_ray.r_pt,
		    pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	    pl_color( plotfp, 0, 0, 255 );
	    pdv_3line( plotfp, ap->a_ray.r_pt, inpt );
	}
    }
    for( ; pp != PartHeadp; pp = pp->pt_forw )  {
	matp_t inv_mat;
	Tcl_HashEntry *entry;

	bu_log("\n--- Hit region %s (in %s, out %s) reg_bit = %d\n",
	       pp->pt_regionp->reg_name,
	       pp->pt_inseg->seg_stp->st_name,
	       pp->pt_outseg->seg_stp->st_name,
	       pp->pt_regionp->reg_bit);

	entry = Tcl_FindHashEntry( (Tcl_HashTable *)ap->a_rt_i->Orca_hash_tbl,
			       (const char *)(size_t)pp->pt_regionp->reg_bit );
	if( !entry ) {
	    inv_mat = (matp_t)NULL;
	}
	else {
	    inv_mat = (matp_t)Tcl_GetHashValue( entry );
	    bn_mat_print( "inv_mat", inv_mat );
	}

	if( pp->pt_overlap_reg )
	    {
		struct region *pp_reg;
		int j=-1;

		bu_log( "    Claiming regions:\n" );
		while( (pp_reg=pp->pt_overlap_reg[++j]) )
		    bu_log( "        %s\n", pp_reg->reg_name );
	    }

	/* inhit info */
	stp = pp->pt_inseg->seg_stp;
	VJOIN1( inpt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	RT_HIT_NORMAL( inormal, pp->pt_inhit, stp, &(ap->a_ray), pp->pt_inflip );
	RT_CURVATURE( &cur, pp->pt_inhit, pp->pt_inflip, stp );

	rt_pr_hit( "  In", pp->pt_inhit );
	VPRINT(    "  Ipoint", inpt );
	VPRINT(    "  Inormal", inormal );
	bu_log(    "   PDir (%g, %g, %g) c1=%g, c2=%g\n",
		   V3ARGS(cur.crv_pdir), cur.crv_c1, cur.crv_c2);

	if( inv_mat ) {
	    point_t in_trans;

	    MAT4X3PNT( in_trans, inv_mat, inpt );
	    bu_log( "\ttransformed ORCA inhit = (%g %g %g)\n", V3ARGS( in_trans ) );
	}

	/* outhit info */
	stp = pp->pt_outseg->seg_stp;
	VJOIN1( outpt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir );
	RT_HIT_NORMAL( onormal, pp->pt_outhit, stp, &(ap->a_ray), pp->pt_outflip );
	RT_CURVATURE( &cur, pp->pt_outhit, pp->pt_outflip, stp );

	rt_pr_hit( "  Out", pp->pt_outhit );
	VPRINT(    "  Opoint", outpt );
	VPRINT(    "  Onormal", onormal );
	bu_log(    "   PDir (%g, %g, %g) c1=%g, c2=%g\n",
		   V3ARGS(cur.crv_pdir), cur.crv_c1, cur.crv_c2);

	if( inv_mat ) {
	    point_t out_trans;
	    vect_t dir_trans;

	    MAT4X3PNT( out_trans, inv_mat, outpt );
	    MAT4X3VEC( dir_trans, inv_mat, ap->a_ray.r_dir );
	    VUNITIZE( dir_trans );
	    bu_log( "\ttranformed ORCA outhit = (%g %g %g)\n", V3ARGS( out_trans ) );
	    bu_log( "\ttransformed ORCA ray direction = (%g %g %g)\n", V3ARGS( dir_trans ) );
	}

	/* Plot inhit to outhit */
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
	    if( (out = pp->pt_outhit->hit_dist) >= INFINITY )
		out = 10000;	/* to imply the direction */

	    VJOIN1( outpt,
		    ap->a_ray.r_pt, out,
		    ap->a_ray.r_dir );
	    pl_color( plotfp, 0, 255, 255 );
	    pdv_3line( plotfp, inpt, outpt );
	}

	{
	    struct region *regp = pp->pt_regionp;
	    int i;

	    if( ap->attrs ) {
		bu_log( "\tattribute values:\n" );
		i = 0;
		while( ap->attrs[i] && regp->attr_values[i] ) {
		    bu_log( "\t\t%s:\n", ap->attrs[i] );
		    bu_log( "\t\t\tstring rep = %s\n",
			    BU_MRO_GETSTRING(regp->attr_values[i]));
		    bu_log( "\t\t\tlong rep = %d\n",
			    BU_MRO_GETLONG(regp->attr_values[i]));
		    bu_log( "\t\t\tdouble rep = %f\n",
			    BU_MRO_GETDOUBLE(regp->attr_values[i]));
		    i++;
		}
	    }
	}
    }
    return(1);
}

int miss(register struct application *ap)
{
    bu_log("missed\n");
    if( R_DEBUG&RDEBUG_RAYPLOT )  {
	vect_t	out;

	VJOIN1( out, ap->a_ray.r_pt,
		10000, ap->a_ray.r_dir );	/* to imply direction */
	pl_color( plotfp, 190, 0, 0 );
	pdv_3line( plotfp, ap->a_ray.r_pt, out );
    }
    return(0);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.18
log
@quell type warning on 64b build
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.17 2007/11/21 20:49:10 erikgreenwald Exp $ (BRL)";
d122 1
a122 2
	(void)fputs(usage, stderr);
	bu_exit(1, NULL);
d158 2
a159 3
		bu_log( "missing list of attribute names!!!\n" );
		(void)fputs(usage, stderr);
		bu_exit( 1, NULL );
d276 2
a277 1
			bu_exit( 1, "\t'retain' or '3'\n");
d286 1
a286 2
	    (void)fputs(usage, stderr);
	    bu_exit(1, NULL);
a288 1
	fprintf(stderr,"rtshot: MGED database not specified\n");
d290 1
a290 1
	bu_exit(1, NULL);
d307 1
a307 2
	fprintf(stderr,"rtshot:  rt_dirbuild failure\n");
	bu_exit(2, NULL);
d319 1
a319 2
	fprintf(stderr,"rt_gettrees FAILED\n");
	bu_exit( 1, NULL );
@


14.17
log
@pass bu_exit a NULL instead of an empty string
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.16 2007/11/21 20:38:23 erikgreenwald Exp $ (BRL)";
d435 1
a435 1
				   (char *)pp->pt_regionp->reg_bit );
@


14.16
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.15 2007/11/21 19:28:07 erikgreenwald Exp $ (BRL)";
d123 1
a123 1
	bu_exit(1, "");
d161 1
a161 1
		bu_exit( 1, "" );
d288 1
a288 1
	    bu_exit(1, "");
d293 1
a293 1
	bu_exit(1, "");
d311 1
a311 1
	bu_exit(2, "");
d324 1
a324 1
	bu_exit( 1, "" );
d333 1
a333 1
	    bu_exit(1, "");
@


14.15
log
@exit->bu_exit where applicable
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.14 2007/09/15 16:23:20 brlcad Exp $ (BRL)";
d278 1
a278 2
			bu_log( "\t'retain' or '3'\n");
			bu_exit( 1, "" );
@


14.14
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.13 2007/01/23 01:13:46 brlcad Exp $ (BRL)";
d123 1
a123 1
	exit(1);
d161 1
a161 1
		exit( 1 );
d279 1
a279 1
			exit( 1 );
d289 1
a289 1
	    exit(1);
d294 1
a294 1
	exit(1);
d312 1
a312 1
	exit(2);
d325 1
a325 1
	exit( 1 );
d334 1
a334 1
	    exit(1);
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.12 2007/01/20 14:37:00 brlcad Exp $ (BRL)";
d44 1
a44 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.12
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.11 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
@


14.11
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d4 1
a4 1
 * Copyright (c) 1987-2006 United  States Government as represented by
d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.10 2006/01/23 04:05:59 brlcad Exp $ (BRL)";
@


14.10
log
@convert to libbu memory management
@
text
@d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.9 2006/01/18 06:46:23 brlcad Exp $ (BRL)";
d43 1
a49 1

d52 1
@


14.9
log
@update copyright to 2006
@
text
@d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.8 2006/01/14 03:22:09 brlcad Exp $ (BRL)";
a43 1

@


14.8
log
@use rt_gettrees_and_attrs instead of rt_gettrees_muves.  the latter is a special hook routine provided to muves (though why rt_gettrees_and_attrs wasn't sufficient is a mystery to me).  the abstraction does keep them ever so slightly decoupled, but brl-cad code shouldn't be calling it even if rtshot was initially perhaps an example for them.
@
text
@d4 1
a4 1
 * Copyright (C) 1987-2005 United  States Government as represented by
d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.7 2005/12/08 01:43:01 brlcad Exp $ (BRL)";
@


14.7
log
@make the application structure non-global, use RT_APPLICATION_INIT; ws
@
text
@d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.6 2005/10/23 04:44:38 brlcad Exp $ (BRL)";
d328 1
a328 1
    if( rt_gettrees_muves( rtip, (const char **)attrs, argc, (const char **)argv, 1 ) ) {
@


14.6
log
@trailing ws
@
text
@d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.5 2005/09/19 18:02:09 brlcad Exp $ (BRL)";
a93 2
struct application	ap;

d117 1
a117 13
	static struct rt_i *rtip;
	char *title_file;
	char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
	char *ptr;
	int attr_count=0, i;
	char **attrs = (char **)NULL;

	if( argc < 3 )  {
		(void)fputs(usage, stderr);
		exit(1);
	}

	bzero( &ap, sizeof( struct application ) );
d119 17
a135 3
	argc--;
	argv++;
	while( argv[0][0] == '-' ) switch( argv[0][1] )  {
d137 4
a140 4
		bundle_radius = atof( argv[1] );
		argc -= 2;
		argv += 2;
		break;
d142 4
a145 4
		num_rings = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
d147 4
a150 4
		rays_per_ring = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
d152 10
a161 10
		/* count the number of attribute names provided */
		ptr = argv[1];
		while( *ptr ) {
			while( *ptr && isspace( *ptr ) )
				ptr++;
			if( *ptr )
				attr_count++;
			while( *ptr && !isspace( *ptr ) )
				ptr++;
		}
d163 5
a167 5
		if( attr_count == 0 ) {
			bu_log( "missing list of attribute names!!!\n" );
			(void)fputs(usage, stderr);
			exit( 1 );
		}
d169 2
a170 2
		/* allocate enough for a null terminated list */
		attrs = (char **)bu_calloc( attr_count + 1, sizeof( char *), "attrs" );
d172 11
a182 11
		/* use strtok to actually grab the names */
		i = 0;
		ptr = strtok( argv[1], "\t " );
		while( ptr && i < attr_count ) {
			attrs[i] = bu_strdup( ptr );
			ptr = strtok( (char *)NULL, "\t " );
			i++;
		}
		argc -= 2;
		argv += 2;
		break;
d184 4
a187 4
		rt_bot_tri_per_piece = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
d189 4
a192 4
		rt_bot_minpieces = atoi( argv[1] );
		argc -= 2;
		argv += 2;
		break;
d194 4
a197 4
		sscanf( argv[1], "%d", &set_onehit );
		argc -= 2;
		argv += 2;
		break;
d199 2
a200 2
		{
			float ray_len;
d202 6
a207 6
			sscanf( argv[1], "%f", &ray_len );
			set_ray_length = ray_len;
		}
		argc -= 2;
		argv += 2;
		break;
d209 4
a212 4
		sscanf( argv[1], "%d", &use_air );
		argc -= 2;
		argv += 2;
		break;
d214 5
a218 5
		sscanf( argv[1], "%x", (unsigned int *)&bu_debug );
		fprintf(stderr,"librt bu_debug=x%x\n", bu_debug);
		argc -= 2;
		argv += 2;
		break;
d220 5
a224 5
		sscanf( argv[1], "%x", (unsigned int *)&rt_g.debug );
		fprintf(stderr,"librt rt_g.debug=x%x\n", rt_g.debug);
		argc -= 2;
		argv += 2;
		break;
d226 5
a230 5
		sscanf( argv[1], "%x", (unsigned int *)&rdebug );
		fprintf(stderr,"rdebug=x%x\n", rdebug);
		argc -= 2;
		argv += 2;
		break;
d232 5
a236 5
		sscanf( argv[1], "%x", (unsigned int *)&rt_g.NMG_debug);
		fprintf(stderr,"librt rt_g.NMG_debug=x%x\n", rt_g.NMG_debug);
		argc -= 2;
		argv += 2;
		break;
d238 8
a245 8
		if( argc < 4 )  goto err;
		ap.a_ray.r_dir[X] = atof( argv[1] );
		ap.a_ray.r_dir[Y] = atof( argv[2] );
		ap.a_ray.r_dir[Z] = atof( argv[3] );
		set_dir = 1;
		argc -= 4;
		argv += 4;
		continue;
d248 8
a255 8
		if( argc < 4 )  goto err;
		ap.a_ray.r_pt[X] = atof( argv[1] );
		ap.a_ray.r_pt[Y] = atof( argv[2] );
		ap.a_ray.r_pt[Z] = atof( argv[3] );
		set_pt = 1;
		argc -= 4;
		argv += 4;
		continue;
d258 8
a265 8
		if( argc < 4 )  goto err;
		at_vect[X] = atof( argv[1] );
		at_vect[Y] = atof( argv[2] );
		at_vect[Z] = atof( argv[3] );
		set_at = 1;
		argc -= 4;
		argv += 4;
		continue;
d268 22
a289 22
		{
			if( !strcmp( argv[1], "resolve" ) || !strcmp( argv[1], "0") )
				overlap_claimant_handling = 0;
			else if( !strcmp( argv[1], "rebuild_fastgen" ) || !strcmp( argv[1], "1") )
				overlap_claimant_handling = 1;
			else if( !strcmp( argv[1], "rebuild_all" ) || !strcmp( argv[1], "2") )
				overlap_claimant_handling = 2;
			else if( !strcmp( argv[1], "retain" ) || !strcmp( argv[1], "3") )
				overlap_claimant_handling = 3;
			else
			{
				bu_log( "Illegal argument (%s) to '-O' option.  Must be:\n", argv[1] );
				bu_log( "\t'resolve' or '0'\n");
				bu_log( "\t'rebuild_fastgen' or '1'\n");
				bu_log( "\t'rebuild_all' or '2'\n");
				bu_log( "\t'retain' or '3'\n");
				exit( 1 );
			}
			argc -= 2;
			argv += 2;
		}
		continue;
d292 64
a355 39
err:
		(void)fputs(usage, stderr);
		exit(1);
	}
	if( argc < 2 )  {
		fprintf(stderr,"rtshot: MGED database not specified\n");
		(void)fputs(usage, stderr);
		exit(1);
	}

	if( set_dir + set_pt + set_at != 2 )  goto err;

	if( num_rings != 0 || rays_per_ring != 0 || bundle_radius != 0.0 ) {
		if( num_rings <= 0 || rays_per_ring <= 0 || bundle_radius <= 0.0 ) {
			fprintf( stderr, "Must have all of \"-R\", \"-n\", and \"-c\" set\n" );
			goto err;
		}
	}

	/* Load database */
	title_file = argv[0];
	argv++;
	argc--;
	if( (rtip=rt_dirbuild(title_file, idbuf, sizeof(idbuf))) == RTI_NULL ) {
		fprintf(stderr,"rtshot:  rt_dirbuild failure\n");
		exit(2);
	}

	if( overlap_claimant_handling )
		rtip->rti_save_overlaps = 1;

	ap.a_rt_i = rtip;
	fprintf(stderr, "db title:  %s\n", idbuf);
	rtip->useair = use_air;

	/* Walk trees */
	if( rt_gettrees_muves( rtip, (const char **)attrs, argc, (const char **)argv, 1 ) ) {
		fprintf(stderr,"rt_gettrees FAILED\n");
		exit( 1 );
d357 2
a358 3
	ap.attrs = attrs;

	rt_prep(rtip);
d360 40
a399 29
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
		if( (plotfp = fopen("rtshot.plot", "w")) == NULL )  {
			perror("rtshot.plot");
			exit(1);
		}
		pdv_3space( plotfp, rtip->rti_pmin, rtip->rti_pmax );
	}

	/* Compute r_dir and r_pt from the inputs */
	if( set_at )  {
		if( set_dir ) {
			vect_t	diag;
			fastf_t	viewsize;
			VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
			viewsize = MAGNITUDE( diag );
			VJOIN1( ap.a_ray.r_pt, at_vect,
				-viewsize/2.0, ap.a_ray.r_dir );
		} else {
			/* set_pt */
			VSUB2( ap.a_ray.r_dir, at_vect, ap.a_ray.r_pt );
		}
	}
	VUNITIZE( ap.a_ray.r_dir );

	if( rays_per_ring ) {
		bu_log( "Central Ray:\n" );
	}
	VPRINT( "Pnt", ap.a_ray.r_pt );
	VPRINT( "Dir", ap.a_ray.r_dir );
d401 1
a401 36
	if( set_onehit )
		ap.a_onehit = set_onehit;
	else
		ap.a_onehit = 0;

	if( set_ray_length > 0.0 )
		ap.a_ray_length = set_ray_length;
	else
		ap.a_ray_length = 0.0;

	/* Shoot Ray */
	ap.a_purpose = "main ray";
	ap.a_hit = hit;
	ap.a_miss = miss;

	if( rays_per_ring ) {
		vect_t avec, bvec;
		struct xray *rp;

		/* create orthogonal rays for basis of bundle */
		bn_vec_ortho( avec, ap.a_ray.r_dir );
		VCROSS( bvec, ap.a_ray.r_dir, avec );
		VUNITIZE( bvec );

		rp = (struct xray *)bu_calloc( sizeof( struct xray ),
					       (rays_per_ring * num_rings) + 1,
					       "ray bundle" );
		rp[0] = ap.a_ray;	/* struct copy */
		rp[0].magic = RT_RAY_MAGIC;
		rt_raybundle_maker( rp, bundle_radius, avec, bvec, rays_per_ring, num_rings );
		(void)rt_shootray_bundle( &ap, rp, (rays_per_ring * num_rings) + 1 );
	} else {
		(void)rt_shootray( &ap );
	}

	return(0);
d406 95
a500 14
	register struct partition *pp;
	register struct soltab *stp;
	struct curvature cur;
	fastf_t out;
	point_t inpt, outpt;
	vect_t	inormal, onormal;

	if( (pp=PartHeadp->pt_forw) == PartHeadp )
		return(0);		/* Nothing hit?? */

	if( overlap_claimant_handling == 1 )
		rt_rebuild_overlaps( PartHeadp, ap, 1 );
	else if( overlap_claimant_handling == 2 )
		rt_rebuild_overlaps( PartHeadp, ap, 0 );
d502 1
a502 1
	/* First, plot ray start to inhit */
d504 2
a505 26
		if( pp->pt_inhit->hit_dist > 0.0001 )  {
			VJOIN1( inpt, ap->a_ray.r_pt,
				pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
			pl_color( plotfp, 0, 0, 255 );
			pdv_3line( plotfp, ap->a_ray.r_pt, inpt );
		}
	}
	for( ; pp != PartHeadp; pp = pp->pt_forw )  {
		matp_t inv_mat;
		Tcl_HashEntry *entry;

		bu_log("\n--- Hit region %s (in %s, out %s) reg_bit = %d\n",
			pp->pt_regionp->reg_name,
			pp->pt_inseg->seg_stp->st_name,
			pp->pt_outseg->seg_stp->st_name,
		        pp->pt_regionp->reg_bit);

		entry = Tcl_FindHashEntry( (Tcl_HashTable *)ap->a_rt_i->Orca_hash_tbl,
					   (char *)pp->pt_regionp->reg_bit );
		if( !entry ) {
			inv_mat = (matp_t)NULL;
		}
		else {
			inv_mat = (matp_t)Tcl_GetHashValue( entry );
			bn_mat_print( "inv_mat", inv_mat );
		}
d507 10
a516 9
		if( pp->pt_overlap_reg )
		{
			struct region *pp_reg;
			int j=-1;

			bu_log( "    Claiming regions:\n" );
			while( (pp_reg=pp->pt_overlap_reg[++j]) )
				bu_log( "        %s\n", pp_reg->reg_name );
		}
d518 12
a529 72
		/* inhit info */
		stp = pp->pt_inseg->seg_stp;
		VJOIN1( inpt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
		RT_HIT_NORMAL( inormal, pp->pt_inhit, stp, &(ap->a_ray), pp->pt_inflip );
		RT_CURVATURE( &cur, pp->pt_inhit, pp->pt_inflip, stp );

		rt_pr_hit( "  In", pp->pt_inhit );
		VPRINT(    "  Ipoint", inpt );
		VPRINT(    "  Inormal", inormal );
		bu_log(    "   PDir (%g, %g, %g) c1=%g, c2=%g\n",
			V3ARGS(cur.crv_pdir), cur.crv_c1, cur.crv_c2);

		if( inv_mat ) {
			point_t in_trans;

			MAT4X3PNT( in_trans, inv_mat, inpt );
			bu_log( "\ttransformed ORCA inhit = (%g %g %g)\n", V3ARGS( in_trans ) );
		}

		/* outhit info */
		stp = pp->pt_outseg->seg_stp;
		VJOIN1( outpt, ap->a_ray.r_pt, pp->pt_outhit->hit_dist, ap->a_ray.r_dir );
		RT_HIT_NORMAL( onormal, pp->pt_outhit, stp, &(ap->a_ray), pp->pt_outflip );
		RT_CURVATURE( &cur, pp->pt_outhit, pp->pt_outflip, stp );

		rt_pr_hit( "  Out", pp->pt_outhit );
		VPRINT(    "  Opoint", outpt );
		VPRINT(    "  Onormal", onormal );
		bu_log(    "   PDir (%g, %g, %g) c1=%g, c2=%g\n",
			V3ARGS(cur.crv_pdir), cur.crv_c1, cur.crv_c2);

		if( inv_mat ) {
			point_t out_trans;
			vect_t dir_trans;

			MAT4X3PNT( out_trans, inv_mat, outpt );
			MAT4X3VEC( dir_trans, inv_mat, ap->a_ray.r_dir );
			VUNITIZE( dir_trans );
			bu_log( "\ttranformed ORCA outhit = (%g %g %g)\n", V3ARGS( out_trans ) );
			bu_log( "\ttransformed ORCA ray direction = (%g %g %g)\n", V3ARGS( dir_trans ) );
		}

		/* Plot inhit to outhit */
		if( R_DEBUG&RDEBUG_RAYPLOT )  {
			if( (out = pp->pt_outhit->hit_dist) >= INFINITY )
				out = 10000;	/* to imply the direction */

			VJOIN1( outpt,
				ap->a_ray.r_pt, out,
				ap->a_ray.r_dir );
			pl_color( plotfp, 0, 255, 255 );
			pdv_3line( plotfp, inpt, outpt );
		}

		{
			struct region *regp = pp->pt_regionp;
			int i;

			if( ap->attrs ) {
				bu_log( "\tattribute values:\n" );
				i = 0;
				while( ap->attrs[i] && regp->attr_values[i] ) {
					bu_log( "\t\t%s:\n", ap->attrs[i] );
					bu_log( "\t\t\tstring rep = %s\n",
						BU_MRO_GETSTRING(regp->attr_values[i]));
					bu_log( "\t\t\tlong rep = %d\n",
						BU_MRO_GETLONG(regp->attr_values[i]));
					bu_log( "\t\t\tdouble rep = %f\n",
						BU_MRO_GETDOUBLE(regp->attr_values[i]));
					i++;
				}
			}
d531 1
d533 2
a534 1
	return(1);
d539 10
a548 10
	bu_log("missed\n");
	if( R_DEBUG&RDEBUG_RAYPLOT )  {
		vect_t	out;

		VJOIN1( out, ap->a_ray.r_pt,
			10000, ap->a_ray.r_dir );	/* to imply direction */
		pl_color( plotfp, 190, 0, 0 );
		pdv_3line( plotfp, ap->a_ray.r_pt, out );
	}
	return(0);
@


14.5
log
@use RT_BUFSIZE define from rtprivate.h instead of constant 132
@
text
@d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.4 2005/01/30 20:31:09 brlcad Exp $ (BRL)";
d526 1
a526 1
						BU_MRO_GETLONG(regp->attr_values[i])); 
@


14.4
log
@update copyright to 2005
@
text
@d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.3 2004/12/24 01:40:00 brlcad Exp $ (BRL)";
d121 1
a121 1
	char idbuf[132];		/* First ID record info */
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d121 1
a121 1
	char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
d526 1
a526 1
						BU_MRO_GETLONG(regp->attr_values[i]));
@


14.3
log
@add the mysteriously missing gpl header..
@
text
@d4 1
a4 1
 * Copyright (c) 1987-2004 United  States Government as represented by
d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtshot.c,v 14.2 2004/12/21 06:38:22 morrison Exp $ (BRL)";
@


14.2
log
@remove the old copyright notice section
@
text
@d1 21
a21 2
/*
 *			R T S H O T . C 
a35 1
 *  
d38 1
a38 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtshot.c,v 14.1 2004/11/16 19:42:31 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@a17 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtshot.c,v 1.5 2004/09/16 03:13:13 morrison Exp $ (BRL)";
@


1.5
log
@a_hit hook functions are now also given a segment pointer, so match prototype even if unused and quell the warnings
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtshot.c,v 1.4 2004/09/03 23:30:59 morrison Exp $ (BRL)";
d535 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtshot.c,v 1.3 2004/08/02 23:01:52 morrison Exp $ (BRL)";
a27 2


d31 1
a31 1
#include <string.h>
d33 1
a33 1
#include <strings.h>
d45 1
d93 2
a94 1
extern int hit(struct application *ap, struct partition *PartHeadp), miss(register struct application *ap);
d389 1
a389 1
int hit(register struct application *ap, struct partition *PartHeadp)
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtshot.c,v 1.2 2004/06/08 22:04:35 morrison Exp $ (BRL)";
d32 1
a32 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d26 1
a26 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d23 1
a23 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/rtshot.c,v 11.30 2004/05/10 15:30:49 erikg Exp $ (BRL)";
a42 1
#include "externs.h"
@

