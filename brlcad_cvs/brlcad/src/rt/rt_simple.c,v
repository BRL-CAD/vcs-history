head	14.11;
access;
symbols
	rel-7-10-4:14.10
	STABLE:14.10.0.2
	stable-branch:14.3
	rel-7-10-2:14.10
	rel-7-10-0:14.10
	rel-7-8-4:14.8
	rel-7-8-2:14.8
	rel-7-8-0:14.8
	trimnurbs-branch:14.8.0.2
	help:14.8
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.3
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.5
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.11
date	2007.09.15.16.23.20;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.23.01.13.45;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.20.14.36.59;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.02.27.10.08.41;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.12.08.01.37.55;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.38;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.09.09.09.44.09;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.09;	author brlcad;	state Exp;
branches
	14.3.6.1;
next	14.2;

14.2
date	2004.12.24.01.40.00;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.59;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.45;	author morrison;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.11
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                     R T _ S I M P L E . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file rt_simple.c
 *
 * a minimal raytracing application in BRLCAD.
 *
 * The primary BRL-CAD ray-tracing API consists of calls to the function
 * rt_shootray().  This function takes a single argument, the address of a
 * data structure called the "application" structure.  This data structure
 * contains crucial information, such as the origin and direction of the ray
 * to be traced, what to do if the ray hits geometry, or misses everything.
 * While the application struct is a large and somewhat complex looking one,
 * (it is defined in h/raytrace.h) there are really very few items in it
 * which the application programmer must know about. These are:
 *
 *	a_rt_i		The "rt instance" from a call to rt_dirbuild()
 *	a_ray		The ray origin and direction
 *	a_hit		A routine that is called when the ray overlaps geometry
 *	a_miss		A routine that is called when the ray misses everything
 *
 * Most of the work an application performs will be done in the "hit" routine.
 * This user-supplied routine gets called deep inside the raytracing library
 * under rt_shootray().  It is provided with 3 parameters:
 *
 *	ap		A pointer to the application structure passed to
 *				rt_shootray()
 *	PartHeadp	A list of ray "partitions" which overlap geometry
 *	segp		A list of ray "segments" which were used to create the
 *				partitions
 *
 * Most applications can ignore the last parameter.  The PartHeadp parameter
 * is a linked-list of "partition" structures (defined in "raytrace.h").
 * It is the job of the "hit" routine to process these ray/object intersections
 * to do the work of the application.
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"


/* these will be defined later */

int hit(struct application *ap, struct partition *PartHeadp, struct seg *segp);
int miss(register struct application *ap);


/*	M A I N
 *
 *	This is where it all gets started
 */
int main(int argc, char **argv)
{
    /* the "ray tracing instance" structure contains definitions for librt
     * which are specific to the particular model being processed.  One
     * copy exists for each model.  Defined in "raytrace.h"
     */
    static struct rt_i *rtip;

    /* the "application" structure carries information about how the
     * ray-casting should be performed.  Defined in "raytrace.h"
     */
    struct application ap;

    /* by default, all values in application struct should be zeroed */
    RT_APPLICATION_INIT(&ap);

    /* Check for command-line arguments.  Make sure we have at least a
     * geometry file and one geometry object on the command line.
     */
    if (argc < 2) {
	fprintf(stderr,
		"Usage: %s geometry_file.g geom_object [geom_object...]\n",
		*argv);
	return -1;
    }


    /* First we need to build a directory (or table of contents) for
     * the objects in the database file.  That is the job of rt_dirbuild()
     */
    if( (rtip=rt_dirbuild(argv[1], (char *)NULL, 0)) == RTI_NULL ) {
	fprintf(stderr,"rt_dirbuild failure\n");
	return 2;
    }

    /* skip over the program name, and database name, leaving only the
     * list of objects in the database
     */
    argc -= 2;
    argv += 2;

    /* Add objects to the "active set".  These are the objects we are
     * interested in intersecting our ray with.
     */
    if( rt_gettrees_and_attrs( rtip, (const char **)NULL,
			       argc, (const char **)argv, 1 ) ) {
	fprintf(stderr,"rt_gettrees FAILED\n");
	return 1;
    }

    /* prepare objects for ray-tracing */
    rt_prep(rtip);

    /* set up the ray to be shot */
    VSET(ap.a_ray.r_pt, 0.0, 0.0, 0.0);
    VSET(ap.a_ray.r_dir, 0.0, 0.0, 1.0);

    /* register the hit/miss routines, and record the rtip */
    ap.a_hit = hit;
    ap.a_miss = miss;
    ap.a_rt_i = rtip;

    ap.a_purpose = "main ray";	/* a text string for informational purposes */

    /* shoot the ray */
    (void)rt_shootray( &ap );

    return(0);
}

/*	H I T
 *
 *	Routine that is called at the end of each ray which encounters at
 *	least one object
 */
int hit(struct application *ap,		/* application struct from main() */
	struct partition *PartHeadp, 	/* linked list of "partitions" */
	struct seg *segp)		/* segment list */
{
    /* partitions are spans of a ray which intersect material objects */
    struct partition *pp;
    point_t	pt;

    fprintf(stderr, "hit\n");

    for (pp=PartHeadp->pt_forw ; pp != PartHeadp ; pp = pp->pt_forw ) {

	/* construct the actual hit-point from the ray and the distance
	 * to the intersection point
	 */
	VJOIN1(pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir);

	fprintf(stderr, "\"%s\" hit at %g %g %g\n",
		ap->a_purpose, /* this was the string we set in main() */
		V3ARGS(pt));
    }
    return 1;
}


/*	M I S S
 *
 *	Routine that is called if a ray does not intersect ANY geometry
 */
int miss(register struct application *ap)
{
    fprintf(stderr, "%s missed\n", ap->a_purpose);
    return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.10
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d58 1
a58 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.9
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.8
log
@stdlib.h and exit()
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


14.7
log
@update copyright to 2006
@
text
@d57 1
d112 1
a112 1
	exit(2);
d127 1
a127 1
	exit( 1 );
@


14.6
log
@RT_APPLICATION_INIT
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


14.5
log
@trailing ws
@
text
@d71 1
a71 3
int hit(struct application *ap,
	struct partition *PartHeadp,
	struct seg *segp);
d93 1
a93 2
    memset((void *)&ap, 0, sizeof(ap));

@


14.4
log
@BRL-CAD not BRLCAD, consistency
@
text
@d25 1
a25 1
 * The primary BRL-CAD ray-tracing API consists of calls to the function 
d31 1
a31 1
 * (it is defined in h/raytrace.h) there are really very few items in it 
d40 1
a40 1
 * This user-supplied routine gets called deep inside the raytracing library 
d50 1
a50 1
 * is a linked-list of "partition" structures (defined in "raytrace.h").  
d186 1
a186 1
int miss(register struct application *ap) 
@


14.3
log
@update copyright to 2005
@
text
@d25 1
a25 1
 * The primary BRLCAD ray-tracing API consists of calls to the function 
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d25 1
a25 1
 * The primary BRL-CAD ray-tracing API consists of calls to the function
d31 1
a31 1
 * (it is defined in h/raytrace.h) there are really very few items in it
d40 1
a40 1
 * This user-supplied routine gets called deep inside the raytracing library
d50 1
a50 1
 * is a linked-list of "partition" structures (defined in "raytrace.h").
d186 1
a186 1
int miss(register struct application *ap)
@


14.2
log
@add the mysteriously missing gpl header..
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 23
a23 1
/*	R T _ S I M P L E  --- a minimal raytracing application in BRLCAD
a56 2


d59 1
a59 1
#include <string.h>
d61 1
a61 1
#include <strings.h>
d68 1
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d170 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d38 1
a38 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d33 1
a33 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

