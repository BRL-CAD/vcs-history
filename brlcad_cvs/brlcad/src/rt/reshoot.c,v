head	1.12;
access;
symbols
	rel-7-10-4:1.9
	STABLE:1.9.0.2
	rel-7-10-2:1.9
	rel-7-10-0:1.8
	rel-7-8-4:1.4
	rel-7-8-2:1.4
	rel-7-8-0:1.4
	trimnurbs-branch:1.4.0.2
	help:1.4;
locks; strict;
comment	@ * @;


1.12
date	2007.12.16.15.59.40;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.21.16.18.53;	author erikgreenwald;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.20.05.54.51;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.14.21.04.33;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.27.01.41.45;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.23.01.13.45;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.21.04.45.45;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.20.14.36.59;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.05.22.37.57;	author lbutler;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.05.22.05.24;	author lbutler;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.05.19.46.44;	author lbutler;	state Exp;
branches;
next	;


desc
@@


1.12
log
@convert all bzero calls to memset
@
text
@/*                     S H O T L I N E S . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file reshoot.c
 *
 * A program to shoot reshoot and compare results to previous runs.
 *
 * This program is geared towards performing regression tests of the
 * BRL-CAD libraries.  A candidate application is run with
 * the RT_G_DEBUG flag DEBUG_ALLHITS set.  This causes the application
 * to log all calls to the application hit() routine, and print the
 * contents of the struct partition.  The log is processed to
 * eliminate extraneous information to produce the input to this
 * program.  The following awk program, will suffice:  @@verbatim

	/Pnt/ { START=index($0,"(") + 1
	       STR=substr($0, START, index($0,")") - START)
	       gsub(  ", "  , "," , STR)
	       printf "Pnt=%s\n",STR

	       }


	/Dir/ { START=index($0,"(") + 1
	       STR=substr($0, START, index($0,")") - START)
	       gsub(  ", "  , "," , STR)
	       printf "Dir=%s\n",STR
	       }
	/PT/  { PARTIN=$3
	       PARTOUT=$5
	       }
	/InHIT/ { INHIT=$2 }
	/OutHIT/ { OUTHIT=$2 }
	/Region/ { printf "\tregion=%s in=%s in%s out=%s out%s\n",$2,PARTIN,INHIT,PARTOUT,OUTHIT}

@@endverbatim
 * If this awk program is stored in the file p.awk then: @@verbatim
	awk -f p.awk < logfile > inputfile
@@endverbatim
 * will produce a suitable input file for this program.  The form is as
 * follows: @@verbatim
	Pnt=1,2,3
	Dir=4,5,6
		region=/all.g/platform.r in=platform.s indist=10016.8 out=platform.s outdist=10023.8
@@endverbatim
 * where the line begining with "region" may be repeated any number of times, representing each
 * region encountered along the ray.
 * now run this program as follows: @@verbatim
	reshoot geom.g obj [obj...] < inputfile
@@endverbatim
 * and this  will re-shoot all of the rays that the original program
 * shot, and compare the results.
 *
 * One of the basic assumptions is that the application structure
 * field a_onehit is set to zero in the original application, causing
 * all rays to be shot all the way through the geometry
 */
#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <strings.h>
#include <math.h>
#include <stddef.h>

#include "machine.h"		/* machine specific definitions */
#include "vmath.h"		/* vector math macros */
#include "bu.h"
#include "raytrace.h"		/* librt interface definitions */
#include "rtprivate.h"


char *progname = "(noname)";

/**
 * @@struct shot
 * A description of a single shotline, and all the regions that were
 * hit by the shotline.
 */
struct shot {
    point_t pt;
    vect_t dir;
    struct bu_list regions;
};

/**
 * @@struct shot_sp
 * The parse table for a struct shot
 */
static const struct bu_structparse shot_sp[] = {
    { "%f", 3, "Pnt", bu_offsetofarray(struct shot, pt), BU_STRUCTPARSE_FUNC_NULL},
    { "%f", 3, "Dir", bu_offsetofarray(struct shot, dir), BU_STRUCTPARSE_FUNC_NULL},
    {"", 0, (char *)0, 0, BU_STRUCTPARSE_FUNC_NULL }
};

/**
 * @@struct reg_hit
 *
 * This describes the interaction of the ray with a single region
 */
struct reg_hit {
    struct bu_list l; /* linked list membership */
    struct bu_vls regname; /* name of the region */
    struct bu_vls in_primitive; /* name of the primitive for the inbound hit */
    double indist; /* distance along ray to the inbound hit */
    struct bu_vls out_primitive; /* name of the primitive for the outbound hit */
    double outdist; /* distance along ray to the outbound hit */
};

static const struct bu_structparse reg_sp[] = {
    {"%S", 1, "region", bu_offsetof(struct reg_hit, regname), BU_STRUCTPARSE_FUNC_NULL },
    {"%S", 1, "in", bu_offsetof(struct reg_hit, in_primitive), BU_STRUCTPARSE_FUNC_NULL},
    {"%S", 1, "out", bu_offsetof(struct reg_hit, out_primitive), BU_STRUCTPARSE_FUNC_NULL},
    {"%f", 1, "indist", bu_offsetof(struct reg_hit, indist), BU_STRUCTPARSE_FUNC_NULL},
    {"%f", 1, "outdist", bu_offsetof(struct reg_hit, outdist), BU_STRUCTPARSE_FUNC_NULL},
    {"", 0, (char *)0, 0, BU_STRUCTPARSE_FUNC_NULL }
};


/**
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void
usage(char *s)
{
    if (s) (void)fputs(s, stderr);
    bu_exit(1, "Usage: %s geom.g obj [obj...] < rayfile \n", progname);
}


/**
 *  Process a single ray intersection list.
 *  A pointer to this function is in the application structure a_hit field.
 *  rt_shootray() calls this if geometry is hit by the ray.  It passes the
 *  application structure which describes the state of the world
 *  (see raytrace.h), and a circular linked list of partitions,
 *  each one describing one in and out segment of one region.
 * @@return
 *	integer value, typically 1.  This value becomes the return value to rtshootray()
 */
int
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
{
    /* see raytrace.h for all of these guys */
    register struct partition *pp;
    struct shot *sh = (struct shot *)ap->a_uptr;
    int status = 0;
    struct reg_hit *rh;
    struct bu_vls v;
    struct bu_vls result;
    struct valstruct {
	double val;
    } vs;
    static struct bu_structparse val_sp[] = {
	{"%f", 1, "val", bu_offsetof(struct valstruct, val)},
    };

    bu_vls_init(&v);
    bu_vls_init(&result);

    /* examine each partition until we get back to the head */
    rh = BU_LIST_FIRST(reg_hit, &sh->regions);
    for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {

	bu_vls_trunc(&result, 0);

	/* since the values were printed out using a %g format,
	 * we have to do the same thing to the result to compare them
	 */
	bu_vls_trunc(&v, 0);
	bu_vls_printf(&v, "val=%g", pp->pt_inhit->hit_dist);
	bu_struct_parse(&v, val_sp, (const char *)&vs);

	if (vs.val != rh->indist) {
	    bu_vls_printf(&result, "\tinhit mismatch %g %g\n", pp->pt_inhit->hit_dist, rh->indist);
	    status = 1;
	}

	bu_vls_trunc(&v, 0);
	bu_vls_printf(&v, "val=%g", pp->pt_outhit->hit_dist);
	bu_struct_parse(&v, val_sp, (const char *)&vs);


	if (vs.val != rh->outdist) {
	    bu_vls_printf(&result, "\touthit mismatch %g %g\n", pp->pt_outhit->hit_dist, rh->outdist);
	    status = 1;
	}

	/* check the region name */
	if (strcmp( pp->pt_regionp->reg_name, bu_vls_addr(&rh->regname) )) {
	    /* region names don't match */
	    bu_vls_printf(&result, "\tregion name mismatch %s %s\n", pp->pt_regionp->reg_name, bu_vls_addr(&rh->regname) );
	    status = 1;
	}

	if ( strcmp(pp->pt_inseg->seg_stp->st_dp->d_namep, bu_vls_addr(&rh->in_primitive))) {
	    bu_vls_printf(&result,"\tin primitive name mismatch %s %s\n",pp->pt_inseg->seg_stp->st_dp->d_namep, bu_vls_addr(&rh->in_primitive));
	    status = 1;
	}
	if ( strcmp(pp->pt_outseg->seg_stp->st_dp->d_namep, bu_vls_addr(&rh->out_primitive))) {
	    bu_vls_printf(&result, "\tout primitive name mismatch %s %s\n",pp->pt_outseg->seg_stp->st_dp->d_namep, bu_vls_addr(&rh->out_primitive));
	    status = 1;
	}
	if (bu_vls_strlen(&result) > 0) {
	    bu_log("Ray Pt %g,%g,%g Dir %g,%g,%g\n%S",
		   V3ARGS(sh->pt),
		   V3ARGS(sh->dir),
		   &result);
	}

	rh = BU_LIST_NEXT(reg_hit, &rh->l);
    }

    /*
     * This value is returned by rt_shootray
     * a hit usually returns 1, miss 0.
     */
    return status;
}


/**
 * Function called when ray misses all geometry
 * A pointer to this function is stored in the application structure
 * field a_miss.  rt_shootray() will call this when the ray misses all geometry.
 * it passees the application structure.
 * @@return
 *	Typically 0, and becomes the return value from rt_shootray()
 */
int
miss(register struct application *ap)
{
    return(0);
}

/**
 * Print a shot.  Mostly a debugging routine.
 *
 */
void
pr_shot(struct shot *sh)
{
    struct reg_hit *rh;
    /* shoot the old ray */
    bu_struct_print("shooting", shot_sp, (const char *)sh);
    for (BU_LIST_FOR(rh, reg_hit, &sh->regions)) {
	bu_struct_print("", reg_sp, (const char *)rh);
    }
}

/**
 *	Re-shoot a ray
 *	The ray described by the parametry sh
 *
 *	@@param sh  a pointer to a struct shot describing the ray to shoot and expected results
 *	@@param ap  a pointer to a struct application
 *	@@return
 *	integer value indicating if there was a difference
 */
int
do_shot(struct shot *sh, struct application *ap)
{
    struct reg_hit *rh;
    int status;


    VMOVE(ap->a_ray.r_pt, sh->pt);
    VMOVE(ap->a_ray.r_dir, sh->dir);
    ap->a_uptr = (genptr_t)sh;

    ap->a_hit = hit;
    ap->a_miss = miss;
    status = rt_shootray( ap );	/* do it */

    /* clean up */
    while (BU_LIST_WHILE(rh, reg_hit, &sh->regions)) {
	BU_LIST_DEQUEUE( &(rh->l) );
	bu_vls_free(&rh->regname);
	bu_vls_free(&rh->in_primitive);
	bu_vls_free(&rh->out_primitive);
	bu_free(rh, "");
    }
    return status;
}


/**
 *	Load the database, parse the input, and shoot the rays
 * @@return
 * integer flag value indicating whether any differences were detected.  0 = none, !0 = different
 */
int
main(int argc, char **argv)
{
    /* every application needs one of these */
    struct application	ap;
    static struct rt_i *rtip;	/* rt_dirbuild returns this */
    char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */

    int arg_count;
    int status = 0;
    struct bu_vls buf;
    struct shot sh;


    progname = argv[0];

    if( argc < 3 )  {
	usage("insufficient args\n");
    }


    /*
     *  Load database.
     *  rt_dirbuild() returns an "instance" pointer which describes
     *  the database to be ray traced.  It also gives you back the
     *  title string in the header (ID) record.
     */
    if( (rtip=rt_dirbuild(argv[1], idbuf, sizeof(idbuf))) == RTI_NULL ) {
	bu_exit(2, "rtexample: rt_dirbuild failure\n");
    }

    /* intialize the application structure to all zeros */
    RT_APPLICATION_INIT(&ap);

    ap.a_rt_i = rtip;	/* your application uses this instance */

    /* Walk trees.
     * Here you identify any object trees in the database that you
     * want included in the ray trace.
     */
    while( argc > 2 )  {
	if( rt_gettree(rtip, argv[2]) < 0 )
	    fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[0]);
	argc--;
	argv++;
    }
    /*
     * This next call gets the database ready for ray tracing.
     * (it precomputes some values, sets up space partitioning, etc.)
     */
    rt_prep_parallel(rtip,1);


    bu_vls_init(&buf);


    memset((void *)&sh, 0, sizeof(sh));
    BU_LIST_INIT(&sh.regions);

    while (bu_vls_gets(&buf, stdin) >= 0) {
	char *p = bu_vls_addr(&buf);

	switch (*p) {
	case 'P' :
	    {

		if (BU_LIST_NON_EMPTY(&sh.regions)) {
		    status |= do_shot(&sh, &ap);
		}

		if (bu_struct_parse(&buf, shot_sp, (const char *)&sh)) {
		    bu_exit(EXIT_FAILURE, "error parsing pt");
		}

		break;
	    }
	case 'D' :
	    {
		if (bu_struct_parse(&buf, shot_sp, (const char *)&sh)) {
		    bu_exit(EXIT_FAILURE, "error parsing dir");
		}
		break;
	    }

	default:
	    {
		struct reg_hit *rh = bu_calloc(1, sizeof (struct reg_hit), "");


		if (bu_struct_parse(&buf, reg_sp, (const char *)rh)) {
		    bu_log("Error parsing region %s\nSkipping to next line\n",
			   bu_vls_addr(&buf));
		}
		BU_LIST_APPEND(&sh.regions, &rh->l);

		break;
	    }
	}
	bu_vls_trunc(&buf, 0);
    }
    status |= do_shot(&sh, &ap);


    return status;
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.11
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d364 1
a364 1
    bzero((void *)&sh, sizeof(sh));
@


1.10
log
@anything using the bu offset macros needs to include stddef.h for the standard offset macros.  other minor mods for bu_exit.
@
text
@d379 1
a379 1
		    bu_bomb("error parsing pt");
d387 1
a387 1
		    bu_bomb("error parsing dir");
@


1.9
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d76 1
d80 1
d107 3
a109 3
    { "%f", 3, "Pnt", bu_offsetofarray(struct shot, pt)},
    { "%f", 3, "Dir", bu_offsetofarray(struct shot, dir)},
    {"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
d127 6
a132 6
    {"%S", 1, "region", bu_offsetof(struct reg_hit, regname) },
    {"%S", 1, "in", bu_offsetof(struct reg_hit, in_primitive)},
    {"%S", 1, "out", bu_offsetof(struct reg_hit, out_primitive)},
    {"%f", 1, "indist", bu_offsetof(struct reg_hit, indist)},
    {"%f", 1, "outdist", bu_offsetof(struct reg_hit, outdist)},
    {"",	0, (char *)0,		0,			BU_STRUCTPARSE_FUNC_NULL }
d143 1
a143 4

    (void) fprintf(stderr, "Usage: %s geom.g obj [obj...] < rayfile \n",
		   progname);
    exit(1);
a325 1
	exit(1);
d336 1
a336 2
	fprintf(stderr,"rtexample: rt_dirbuild failure\n");
	exit(2);
@


1.8
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d125 5
a129 5
    {"%S", 1, "region", offsetof(struct reg_hit, regname) },
    {"%S", 1, "in", offsetof(struct reg_hit, in_primitive)},
    {"%S", 1, "out", offsetof(struct reg_hit, out_primitive)},
    {"%f", 1, "indist", offsetof(struct reg_hit, indist)},
    {"%f", 1, "outdist", offsetof(struct reg_hit, outdist)},
d172 1
a172 1
	{"%f", 1, "val", offsetof(struct valstruct, val)},
@


1.7
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d25 1
a25 1
 * BRL-CAD libraries.  A candidate application is run with 
d27 3
a29 3
 * to log all calls to the application hit() routine, and print the 
 * contents of the struct partition.  The log is processed to 
 * eliminate extraneous information to produce the input to this 
d36 1
a36 1
	
d38 2
a39 2
	
	
d51 1
a51 1
	
d54 1
a54 1
 	awk -f p.awk < logfile > inputfile
d56 1
a56 1
 * will produce a suitable input file for this program.  The form is as 
d58 2
a59 2
 	Pnt=1,2,3
 	Dir=4,5,6
d65 1
a65 1
 	reshoot geom.g obj [obj...] < inputfile
d70 2
a71 2
 * One of the basic assumptions is that the application structure 
 * field a_onehit is set to zero in the original application, causing 
a86 1

a147 1

d182 1
a182 1
 	bu_vls_trunc(&result, 0);
d184 1
a184 1
	/* since the values were printed out using a %g format, 
d222 4
a225 4
 	    bu_log("Ray Pt %g,%g,%g Dir %g,%g,%g\n%S", 
 		   V3ARGS(sh->pt),
 		   V3ARGS(sh->dir),
 		   &result);
d241 1
a241 1
 * A pointer to this function is stored in the application structure 
d292 1
a292 1
    /* clean up */		
a329 3
    


a363 2


d395 1
a395 1
	default: 
a417 1

@


1.6
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


1.5
log
@update copyright to 2007
@
text
@d31 1
a31 1
 * program.  The following awk program, will suffice:  \verbatim
d53 2
a54 2
\endverbatim
 * If this awk program is stored in the file p.awk then: \verbatim
d56 1
a56 1
\endverbatim
d58 1
a58 1
 * follows: \verbatim
d62 1
a62 1
\endverbatim
d65 1
a65 1
 * now run this program as follows: \verbatim
d67 1
a67 1
\endverbatim
d92 1
a92 1
 * \struct shot
d103 1
a103 1
 * \struct shot_sp
d113 1
a113 1
 * \struct reg_hit
d158 1
a158 1
 * \return
d247 1
a247 1
 * \return
d275 3
a277 3
 *	\param sh  a pointer to a struct shot describing the ray to shoot and expected results
 *	\param ap  a pointer to a struct application
 *	\return
d309 1
a309 1
 * \return
@


1.4
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


1.3
log
@extended documentation, code formatting, modified reporting
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


1.2
log
@better output formatting
@
text
@d225 1
a225 1
 	    bu_log("Ray Pt %g %g %g Dir %g %g %g\n%S", 
a323 1
    char *p;
d379 1
a379 1
	p = bu_vls_addr(&buf);
d382 2
a383 1
	case 'P' : {
d385 16
a400 2
	    if (BU_LIST_NON_EMPTY(&sh.regions)) {
		status |= do_shot(&sh, &ap);
d403 3
a405 3
	    if (bu_struct_parse(&buf, shot_sp, (const char *)&sh)) {
		bu_bomb("error parsing pt");
	    }
a406 10
	    break;
	}
	case 'D' : {
	    if (bu_struct_parse(&buf, shot_sp, (const char *)&sh)) {
		bu_bomb("error parsing dir");
	    }
	    break;
	}
	case '\t' : {
	    struct reg_hit *rh = bu_calloc(1, sizeof (struct reg_hit), "");
d408 5
d414 1
a414 2
	    if (bu_struct_parse(&buf, reg_sp, (const char *)rh)) {
		bu_bomb("errror parsing region");
a415 7
	    BU_LIST_APPEND(&sh.regions, &rh->l);

	    break;
	}
	default: 
	    bu_log("%s skipping: %s\n", BU_FLSTR, p);
	    break;
@


1.1
log
@This is an application for re-shooting rays and comparing the results
to previous applicatin runs.  The princiiple use will probably be
in the regression test suite.  In that context, it should allow us
to shoot all the MUVES test suite rays outside of MUVES.  The one downside
is that it relies on the RT_G_DEBUG flag DEBUG_ALLHITS to cause librt
to log the original rays.  Since floating point values are logged with %g some
precision is lost.
@
text
@d142 1
a142 1
	if (s) (void)fputs(s, stderr);
d144 3
a146 3
	(void) fprintf(stderr, "Usage: %s geom.g obj [obj...] < rayfile \n",
			progname);
	exit(1);
d170 1
a170 1
    bu_vls_init(&v);
d178 2
d185 2
d195 1
a195 1
	    bu_log("inhit mismatch %g %g\n", pp->pt_inhit->hit_dist, rh->indist);
d205 1
a205 1
	    bu_log("outhit mismatch %g %g\n", pp->pt_outhit->hit_dist, rh->outdist);
d212 1
a212 1
	    bu_log("region name mismatch %s %s\n", pp->pt_regionp->reg_name, bu_vls_addr(&rh->regname) );
d217 1
a217 1
	    bu_log("primitive name mismatch %s %s\n",pp->pt_inseg->seg_stp->st_dp->d_namep, bu_vls_addr(&rh->in_primitive));
d221 1
a221 1
	    bu_log("primitive name mismatch %s %s\n",pp->pt_outseg->seg_stp->st_dp->d_namep, bu_vls_addr(&rh->out_primitive));
d224 6
a229 1

@

