head	14.31;
access;
symbols
	rel-7-10-4:14.30
	STABLE:14.30.0.2
	stable-branch:14.6
	rel-7-10-2:14.28
	rel-7-10-0:14.25
	rel-7-8-4:14.21
	rel-7-8-2:14.21
	rel-7-8-0:14.21
	trimnurbs-branch:14.20.0.2
	help:14.20
	temp_tag:14.18
	bobWinPort-20051223-freeze:14.12.2.1
	postmerge-20051223-bobWinPort:14.18
	premerge-20051223-bobWinPort:14.17
	rel-7-6-6:14.16
	rel-7-6-4:14.16
	rel-7-6-2:14.12
	rel-7-6-branch:14.12.0.4
	rel-7-6-0:14.12
	rel-7-4-2:14.10.2.1
	rel-7-4-branch:14.10.0.2
	bobWinPort:14.12.0.2
	rel-7-4-0:14.10
	rel-7-2-6:14.10
	rel-7-2-4:14.7
	rel-7-2-2:14.6
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.31
date	2007.09.15.16.23.20;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.08.18.05.56.29;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.08.18.00.22.58;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.04.18.04.03.56;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.04.17.03.23.57;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.04.16.21.15.37;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.01.27.01.41.45;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.23.01.13.45;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.20.14.36.59;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.06.08.34.56;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2006.03.30.00.01.05;	author lbutler;	state Exp;
branches;
next	14.20;

14.20
date	2006.02.27.09.10.29;	author brlcad;	state Exp;
branches
	14.20.2.1;
next	14.19;

14.19
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2005.12.23.21.26.46;	author bob1961;	state Exp;
branches;
next	14.17;

14.17
date	2005.12.22.06.32.06;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.11.04.10.38.37;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.10.23.04.44.38;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.10.19.23.20.44;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.09.19.18.02.09;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.08.15.21.44.15;	author bob1961;	state Exp;
branches
	14.12.2.1
	14.12.4.1;
next	14.11;

14.11
date	2005.07.16.23.17.05;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.05.28.02.14.58;	author brlcad;	state Exp;
branches
	14.10.2.1;
next	14.9;

14.9
date	2005.05.17.06.02.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.05.14.19.18.48;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.04.27.02.38.54;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.03.28.06.31.37;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.03.24.17.26.44;	author bob1961;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.09;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.24.01.40.00;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.38.22;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.16.08.05.48;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.34;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.44;	author morrison;	state Exp;
branches;
next	;

14.10.2.1
date	2005.08.16.21.03.50;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2005.09.08.16.23.20;	author bob1961;	state Exp;
branches;
next	;

14.12.4.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;

14.20.2.1
date	2006.04.07.19.34.23;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.31
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                          M A I N . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United  States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file main.c
 *
 *  Ray Tracing User Interface (RTUIF) main program, using LIBRT library.
 *
 *  Invoked by MGED for quick pictures.
 *  Is linked with each of several "back ends":
 *	view.c, viewpp.c, viewray.c, viewcheck.c, etc
 *  to produce different executable programs:
 *	rt, rtpp, rtray, rtcheck, etc.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.30 2007/08/18 05:56:29 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <signal.h>
#include <math.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "pkg.h"

/* private */
#include "./ext.h"
#include "../librt/debug.h"
#include "rtprivate.h"
#include "brlcad_version.h"


extern const char title[];
extern const char usage[];


/***** Variables shared with viewing model *** */
FBIO		*fbp = FBIO_NULL;	/* Framebuffer handle */
FILE		*outfp = NULL;		/* optional pixel output file */
int		output_is_binary = 1;	/* !0 means output file is binary */
mat_t		view2model;
mat_t		model2view;
/***** end of sharing with viewing model *****/

/***** variables shared with worker() ******/
struct application ap;
vect_t		left_eye_delta;
int		report_progress;	/* !0 = user wants progress report */
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
extern int	incr_mode;		/* !0 for incremental resolution */
extern int	incr_nlevel;		/* number of levels */
extern int	npsw;			/* number of worker PSWs to run */
/***** end variables shared with worker() *****/

/***** variables shared with do.c *****/
extern int	pix_start;		/* pixel to start at */
extern int	pix_end;		/* pixel to end at */
extern int	nobjs;			/* Number of cmd-line treetops */
extern char	**objtab;		/* array of treetop strings */
char		*beginptr;		/* sbrk() at start of program */
long		n_malloc;		/* Totals at last check */
long		n_free;
long		n_realloc;
extern int	matflag;		/* read matrix from stdin */
extern int	desiredframe;		/* frame to start at */
extern int	curframe;		/* current frame number,
					 * also shared with view.c */
extern char	*outputfile;		/* name of base of output file */
extern int	interactive;		/* human is watching results */
/***** end variables shared with do.c *****/


extern fastf_t	rt_dist_tol;		/* Value for rti_tol.dist */
extern fastf_t	rt_perp_tol;		/* Value for rti_tol.perp */
extern char	*framebuffer;		/* desired framebuffer */

extern struct command_tab	rt_cmdtab[];

extern struct resource	resource[];	/* from opt.c */

int	save_overlaps=0;	/* flag for setting rti_save_overlaps */


/*
 *			S I G I N F O _ H A N D L E R
 */
void
siginfo_handler(int arg)
{
	report_progress = 1;
#ifdef SIGUSR1
	(void)signal( SIGUSR1, siginfo_handler );
#endif
#ifdef SIGINFO
	(void)signal( SIGINFO, siginfo_handler );
#endif
}


/*
 *			M E M O R Y _ S U M M A R Y
 */
void
memory_summary(void)
{
#ifdef HAVE_SBRK
	if (rt_verbosity & VERBOSE_STATS)  {
		long	mdelta = bu_n_malloc - n_malloc;
		long	fdelta = bu_n_free - n_free;
		fprintf(stderr,
			"Additional mem=%ld., #malloc=%ld, #free=%ld, #realloc=%ld (%ld retained)\n",
			(long)((char *)sbrk(0)-beginptr),
			mdelta,
			fdelta,
			bu_n_realloc - n_realloc,
			mdelta - fdelta);
	}
	beginptr = (char *) sbrk(0);
#endif
	n_malloc = bu_n_malloc;
	n_free = bu_n_free;
	n_realloc = bu_n_realloc;
}

/*
 *			M A I N
 */
int main(int argc, char **argv)
{
	struct rt_i *rtip = NULL;
	char *title_file = NULL, *title_obj = NULL;	/* name of file and first object */
	char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
	void	application_init();
	struct bu_vls	times;
	int i;

#ifdef _WIN32
#if 1
	_setmode(_fileno(stdin), _O_BINARY);
	_setmode(_fileno(stdout), _O_BINARY);
	_setmode(_fileno(stderr), _O_BINARY);
#else
	_fmode = _O_BINARY;
#endif
#endif

#ifndef _WIN32
	bu_setlinebuf( stderr );
#endif

#ifdef HAVE_SBRK
	beginptr = (char *) sbrk(0);
#endif
	azimuth = 35.0;			/* GIFT defaults */
	elevation = 25.0;

	AmbientIntensity=0.4;
	background[0] = background[1] = 0.0;
	background[2] = 1.0/255.0; /* slightly non-black */

	/* Before option processing, get default number of processors */
	npsw = bu_avail_cpus();		/* Use all that are present */
	if( npsw > DEFAULT_PSW )  npsw = DEFAULT_PSW;
	if( npsw > MAX_PSW )  npsw = MAX_PSW;

	/* Before option processing, do application-specific initialization */
	RT_APPLICATION_INIT( &ap );
	application_init();

	/* Process command line options */
	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		return 1;
	}
	/* Identify the versions of the libraries we are using. */
	if (rt_verbosity & VERBOSE_LIBVERSIONS) {
		(void)fprintf(stderr, "%s%s%s%s\n",
			      brlcad_ident(title),
			      rt_version(),
			      bn_version(),
			      bu_version()
		      );
	}
#if defined(DEBUG)
	(void)fprintf(stderr, "Compile-time debug symbols are available\n");
#endif
#if defined(NO_BOMBING_MACROS) || defined(NO_MAGIC_CHECKING) || defined(NO_BADRAY_CECHKING) || defined(NO_DEBUG_CHECKING)
	(void)fprintf(stderr, "WARNING: Run-time debugging is disabled and may enhance performance\n");
#endif

	/* Identify what host we're running on */
	if (rt_verbosity & VERBOSE_LIBVERSIONS) {
		char	hostname[512] = {0};
#ifndef _WIN32
		if( gethostname( hostname, sizeof(hostname) ) >= 0 &&
		    hostname[0] != '\0' )
			(void)fprintf(stderr, "Running on %s\n", hostname);
#else
	sprintf(hostname,"Microsoft Windows");
	(void)fprintf(stderr, "Running on %s\n", hostname);
#endif
	}

	if( bu_optind >= argc )  {
		fprintf(stderr,"%s:  MGED database not specified\n", argv[0]);
		(void)fputs(usage, stderr);
		return 1;
	}

	if (rpt_overlap)
		ap.a_logoverlap = ((void (*)())0);
	else
		ap.a_logoverlap = rt_silent_logoverlap;

	/* If user gave no sizing info at all, use 512 as default */
	if( width <= 0 && cell_width <= 0 )
		width = 512;
	if( height <= 0 && cell_height <= 0 )
		height = 512;

	/* If user didn't provide an aspect ratio, use the image
	 * dimensions ratio as a default.
	 */
	if (aspect <= 0.0) {
	    aspect = (fastf_t)width / (fastf_t)height;
	}

	if( sub_grid_mode ) {
		/* check that we have a legal subgrid */
		if( sub_xmax >= width || sub_ymax >= height ) {
			fprintf( stderr, "rt: illegal values for subgrid %d,%d,%d,%d\n",
				 sub_xmin, sub_ymin, sub_xmax, sub_ymax );
			fprintf( stderr, "\tFor a %d X %d image, the subgrid must be within 0,0,%d,%d\n",
				 width, height, width-1, height-1 );
			return 1;
		}
	}

	if( incr_mode )  {
		int x = height;
		if( x < width )  x = width;
		incr_nlevel = 1;
		while( (1<<incr_nlevel) < x )
			incr_nlevel++;
		height = width = 1<<incr_nlevel;
		if (rt_verbosity & VERBOSE_INCREMENTAL)
			fprintf(stderr,
			    "incremental resolution, nlevels = %d, width=%d\n",
			    incr_nlevel, width);
	}

	/*
	 *  Handle parallel initialization, if applicable.
	 */
#ifndef PARALLEL
	npsw = 1;			/* force serial */
#endif

	if( npsw < 0 )  {
		/* Negative number means "all but" npsw */
		npsw = bu_avail_cpus() + npsw;
	}


	/* allow debug builds to go higher than the max */
	if (!(bu_debug & BU_DEBUG_PARALLEL)) {
	    if( npsw > MAX_PSW ) {
		npsw = MAX_PSW;
	    }
	}

	if (npsw > 1) {
	    rt_g.rtg_parallel = 1;
	    if (rt_verbosity & VERBOSE_MULTICPU)
		fprintf(stderr,"Planning to run with %d processors\n", npsw );
	} else {
	    rt_g.rtg_parallel = 0;
	}

	/* Initialize parallel processor support */
	bu_semaphore_init( RT_SEM_LAST );

	/*
	 *  Do not use bu_log() or bu_malloc() before this point!
	 */

	if( bu_debug )  {
		bu_printb( "libbu bu_debug", bu_debug, BU_DEBUG_FORMAT );
		bu_log("\n");
	}

	if( RT_G_DEBUG )  {
		bu_printb( "librt rt_g.debug", rt_g.debug, DEBUG_FORMAT );
		bu_log("\n");
	}
	if( rdebug )  {
		bu_printb( "rt rdebug", rdebug, RDEBUG_FORMAT );
		bu_log("\n");
	}

	/* We need this to run rt_dirbuild */
	rt_init_resource( &rt_uniresource, MAX_PSW, NULL );
	bn_rand_init( rt_uniresource.re_randptr, 0 );

	title_file = argv[bu_optind];
	title_obj = argv[bu_optind+1];
	nobjs = argc - bu_optind - 1;
	objtab = &(argv[bu_optind+1]);

	if( nobjs <= 0 )  {
		bu_log("%s: no objects specified -- raytrace aborted\n", argv[0]);
		return 1;
	}

	/* Echo back the command line arugments as given, in 3 Tcl commands */
	if (rt_verbosity & VERBOSE_MODELTITLE) {
		struct bu_vls str;
		bu_vls_init(&str);
		bu_vls_from_argv( &str, bu_optind, (const char **)argv );
		bu_vls_strcat( &str, "\nopendb "  );
		bu_vls_strcat( &str, title_file );
		bu_vls_strcat( &str, ";\ntree " );
		bu_vls_from_argv( &str,
			nobjs <= 16 ? nobjs : 16,
			(const char **)argv+bu_optind+1 );
		if( nobjs > 16 )
			bu_vls_strcat( &str, " ...");
		else
			bu_vls_putc( &str, ';' );
		bu_log("%s\n", bu_vls_addr(&str) );
		bu_vls_free(&str);
	}

	/* Build directory of GED database */
	bu_vls_init( &times );
	rt_prep_timer();
	if( (rtip=rt_dirbuild(title_file, idbuf, sizeof(idbuf))) == RTI_NULL ) {
		bu_log("rt:  rt_dirbuild(%s) failure\n", title_file);
		return 2;
	}
	ap.a_rt_i = rtip;
	(void)rt_get_timer( &times, NULL );
	if (rt_verbosity & VERBOSE_MODELTITLE)
		bu_log("db title:  %s\n", idbuf);
	if (rt_verbosity & VERBOSE_STATS)
		bu_log("DIRBUILD: %s\n", bu_vls_addr(&times) );
	bu_vls_free( &times );
	memory_summary();

	/* Copy values from command line options into rtip */
	rtip->rti_space_partition = space_partition;
	rtip->rti_nugrid_dimlimit = nugrid_dimlimit;
	rtip->rti_nu_gfactor = nu_gfactor;
	rtip->useair = use_air;
	rtip->rti_save_overlaps = save_overlaps;
	if( rt_dist_tol > 0 )  {
		rtip->rti_tol.dist = rt_dist_tol;
		rtip->rti_tol.dist_sq = rt_dist_tol * rt_dist_tol;
	}
	if( rt_perp_tol > 0 )  {
		rtip->rti_tol.perp = rt_perp_tol;
		rtip->rti_tol.para = 1 - rt_perp_tol;
	}
	if (rt_verbosity & VERBOSE_TOLERANCE)
		rt_pr_tol( &rtip->rti_tol );

	/* before view_init */
	if( outputfile && strcmp( outputfile, "-") == 0 )
		outputfile = (char *)0;

	pkg_init();

	/*
	 *  Initialize application.
	 *  Note that width & height may not have been set yet,
	 *  since they may change from frame to frame.
	 */
	if( view_init( &ap, title_file, title_obj, outputfile!=(char *)0, framebuffer!=(char *)0 ) != 0 )  {
		/* Framebuffer is desired */
		register int xx, yy;
		int	zoom;

		/* Ask for a fb big enough to hold the image, at least 512. */
		/* This is so MGED-invoked "postage stamps" get zoomed up big enough to see */
		xx = yy = 512;
		if( width > xx || height > yy )  {
			xx = width;
			yy = height;
		}
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		fbp = fb_open( framebuffer, xx, yy );
		bu_semaphore_release( BU_SEM_SYSCALL );
		if( fbp == FBIO_NULL )  {
			fprintf(stderr,"rt:  can't open frame buffer\n");
			pkg_terminate();
			return 12;
		}

		bu_semaphore_acquire( BU_SEM_SYSCALL );
		/* If fb came out smaller than requested, do less work */
		if( fb_getwidth(fbp) < width )  width = fb_getwidth(fbp);
		if( fb_getheight(fbp) < height )  height = fb_getheight(fbp);

		/* If the fb is lots bigger (>= 2X), zoom up & center */
		if( width > 0 && height > 0 )  {
			zoom = fb_getwidth(fbp)/width;
			if( fb_getheight(fbp)/height < zoom )
				zoom = fb_getheight(fbp)/height;
		} else {
			zoom = 1;
		}
		(void)fb_view( fbp, width/2, height/2,
			zoom, zoom );
		bu_semaphore_release( BU_SEM_SYSCALL );
	}
	if( (outputfile == (char *)0) && (fbp == FBIO_NULL) )  {
		/* If not going to framebuffer, or to a file, then use stdout */
		if( outfp == NULL )  outfp = stdout;
		/* output_is_binary is changed by view_init, as appropriate */
		if( output_is_binary && isatty(fileno(outfp)) )  {
			fprintf(stderr,"rt:  attempting to send binary output to terminal, aborting\n");
			pkg_terminate();
			return 14;
		}
	}

	/*
	 *  Initialize all the per-CPU memory resources.
	 *  The number of processors can change at runtime, init them all.
	 */
	for( i=0; i < MAX_PSW; i++ )  {
		rt_init_resource( &resource[i], i, rtip );
		bn_rand_init( resource[i].re_randptr, i );
	}
	memory_summary();

#ifdef SIGUSR1
	(void)signal( SIGUSR1, siginfo_handler );
#endif
#ifdef SIGINFO
	(void)signal( SIGINFO, siginfo_handler );
#endif

	if( !matflag )  {
		int frame_retval;
		def_tree( rtip );		/* Load the default trees */
		do_ae( azimuth, elevation );
		frame_retval = do_frame( curframe );
		if (frame_retval != 0) {
		    /* Release the framebuffer, if any */
		    if( fbp != FBIO_NULL ) {
			fb_close(fbp);
		    }
		    pkg_terminate();
		    return 1;
		}
	} else if( !isatty(fileno(stdin)) && old_way( stdin ) )  {
		; /* All is done */
	} else {
		register char	*buf;
		register int	ret;
		/*
		 * New way - command driven.
		 * Process sequence of input commands.
		 * All the work happens in the functions
		 * called by rt_do_cmd().
		 */
		while( (buf = rt_read_cmd( stdin )) != (char *)0 )  {
			if( R_DEBUG&RDEBUG_PARSE )
				fprintf(stderr,"cmd: %s\n", buf );
			ret = rt_do_cmd( rtip, buf, rt_cmdtab );
			bu_free( buf, "rt_read_cmd command buffer" );
			if( ret < 0 )
				break;
		}
		if( curframe < desiredframe )  {
			fprintf(stderr,
				"rt:  Desired frame %d not reached, last was %d\n",
				desiredframe, curframe);
		}
	}

	/* Release the framebuffer, if any */
	if( fbp != FBIO_NULL )
		fb_close(fbp);

	pkg_terminate();
	return(0);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.30
log
@oops, remove the sigill signal handler vestige I was using for debugging.
@
text
@d39 1
a39 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.29 2007/08/18 00:22:58 brlcad Exp $ (BRL)";
d46 1
a46 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d50 1
a53 1

@


14.29
log
@allow the ray-tracers to use more than the available cpus for debugging and testing purposes.  this was previously only possible via compile-time modifications, but now is possible via the BU_DEBUG_PARALLEL debug flag (-\!10 on most of the raytracers).
@
text
@d39 1
a39 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.28 2007/04/18 04:03:56 brlcad Exp $ (BRL)";
a486 2
	signal(SIGILL, sigill_handler);

@


14.28
log
@brlcad_version() name changed to brlcad_ident()
@
text
@d39 1
a39 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.27 2007/04/17 03:23:57 brlcad Exp $ (BRL)";
d142 1
d301 1
d306 10
a315 2
	if( npsw > MAX_PSW )  npsw = MAX_PSW;
	if( npsw > 1 )  {
d319 3
a321 2
	} else
		rt_g.rtg_parallel = 0;
d487 2
@


14.27
log
@redo the client-side version reporting to use the new brlcad_version() interface, utilizing a per-binary title as needed, instead of the former vers.sh setup.
@
text
@d39 1
a39 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.26 2007/04/16 21:15:37 brlcad Exp $ (BRL)";
d220 1
a220 1
			      brlcad_version(title),
@


14.26
log
@revamp BRL-CAD's versioning setup.  no longer rely upon the vers.sh script, allowing for a more unified cross-platform configuration.  instead of globals, provide per-library functions that return the version string.  the version numbers are now stored in files in include/conf/.
@
text
@d39 1
a39 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.25 2007/01/27 01:41:45 brlcad Exp $ (BRL)";
d66 3
d70 1
d72 5
a76 2
#include "../librt/debug.h"
#include "pkg.h"
a77 1
extern char	usage[];
a121 2
extern char	version[];		/* From vers.c */

d220 1
a220 1
			version+5,
d224 1
a224 1
		      );	/* +5 to skip @@(#) */
d235 1
a235 2
		char	hostname[512];
		hostname[0] = '\0';
@


14.25
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d39 1
a39 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.24 2007/01/23 01:13:45 brlcad Exp $ (BRL)";
d217 3
a219 3
			rt_version+5,
			bn_version+5,
			bu_version+5
@


14.24
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d39 1
a39 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.23 2007/01/20 14:36:59 brlcad Exp $ (BRL)";
d305 1
a305 1
	        fprintf(stderr,"Planning to run with %d processors\n", npsw );
d402 1
a402 1
	/* 
@


14.23
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d39 1
a39 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.22 2007/01/06 08:34:56 brlcad Exp $ (BRL)";
@


14.22
log
@be less harsh about this being a debug build -- just say debug symbols are available and leave it at that
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United  States Government as represented by
d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.21 2006/03/30 00:01:05 lbutler Exp $ (BRL)";
@


14.21
log
@When complaining about not getting an MGED database, we now accurately report
the name of the program (from argv[0]) being run, rather than pretending that
all rtuif programs are called "rt".
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.20 2006/02/27 09:10:29 brlcad Exp $ (BRL)";
d224 1
a224 1
	(void)fprintf(stderr, "WARNING: Compile-time debugging is enabled and may limit performance\n");
@


14.20
log
@stdlib.h warning quelling
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.19 2006/01/18 06:46:23 brlcad Exp $ (BRL)";
d245 1
a245 1
		fprintf(stderr,"rt:  MGED database not specified\n");
@


14.20.2.1
log
@update from HEAD
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.20 2006/02/27 09:10:29 brlcad Exp $ (BRL)";
d245 1
a245 1
		fprintf(stderr,"%s:  MGED database not specified\n", argv[0]);
@


14.19
log
@update copyright to 2006
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.18 2005/12/23 21:26:46 bob1961 Exp $ (BRL)";
d45 1
d212 1
a212 1
		exit(1);
d247 1
a247 1
		exit(1);
d275 1
a275 1
			exit( 1 );
d342 1
a342 1
		exit(1);
d369 1
a369 1
		exit(2);
d426 1
a426 1
			exit(12);
d453 1
a453 1
			exit(14);
@


14.18
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United  States Government as represented by
d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
@


14.17
log
@use 0.0 as the 'default' aspect ratio to represent unset.  catch a negative aspect ratio as an error.  a 'default'/unset aspect ratio will get adjusted to be the image dimensions ratio.
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.16 2005/11/04 10:38:37 brlcad Exp $ (BRL)";
d69 1
a69 1

d400 3
a402 1
	/*
d424 1
d451 1
d483 1
d516 1
@


14.16
log
@output a warning iff compile-time debugging is enabled so the benchmark tests can look for it
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.15 2005/10/23 04:44:38 brlcad Exp $ (BRL)";
d260 7
@


14.15
log
@trailing ws
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.14 2005/10/19 23:20:44 brlcad Exp $ (BRL)";
d222 3
d226 1
a226 1
	(void)fprintf(stderr, "WARNING: Run-time debugging is disabled for extra performance\n");
@


14.14
log
@initialize pointers to NULL
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.13 2005/09/19 18:02:09 brlcad Exp $ (BRL)";
d260 1
a260 1
			fprintf( stderr, "rt: illegal values for subgrid %d,%d,%d,%d\n", 
d276 1
a276 1
			fprintf(stderr, 
d390 1
a390 1
	/* 
@


14.13
log
@use RT_BUFSIZE define from rtprivate.h instead of constant 132
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.12 2005/08/15 21:44:15 bob1961 Exp $ (BRL)";
d168 2
a169 3
	struct rt_i *rtip;
	char *title_file, *title_obj;	/* name of file and first object */
	register int	x;
d269 1
a269 1
		x = height;
@


14.12
log
@Mods for Windows port
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.11 2005/07/16 23:17:05 brlcad Exp $ (BRL)";
d168 1
a168 1
	static struct rt_i *rtip;
d171 1
a171 1
	char idbuf[132];		/* First ID record info */
@


14.12.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d168 4
a171 3
	struct rt_i *rtip = NULL;
	char *title_file = NULL, *title_obj = NULL;	/* name of file and first object */
	char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
a222 3
#if defined(DEBUG)
	(void)fprintf(stderr, "WARNING: Compile-time debugging is enabled and may limit performance\n");
#endif
d224 1
a224 1
	(void)fprintf(stderr, "WARNING: Run-time debugging is disabled and may enhance performance\n");
d261 1
a261 1
			fprintf( stderr, "rt: illegal values for subgrid %d,%d,%d,%d\n",
d270 1
a270 1
		int x = height;
d277 1
a277 1
			fprintf(stderr,
d391 1
a391 1
	/*
@


14.12.2.1
log
@Mods for windows port
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.12 2005/08/15 21:44:15 bob1961 Exp $ (BRL)";
d69 1
a69 1
#include "pkg.h"
a390 2
	pkg_init();

a412 1
			pkg_terminate();
a438 1
			pkg_terminate();
a469 1
		    pkg_terminate();
a501 1
	pkg_terminate();
@


14.11
log
@allow rt to output simultaneously to a file and to a framebuffer
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.10 2005/05/28 02:14:58 brlcad Exp $ (BRL)";
d186 1
a186 1

d188 1
@


14.10
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.9 2005/05/17 06:02:16 brlcad Exp $ (BRL)";
d395 1
a395 1
	if( view_init( &ap, title_file, title_obj, outputfile!=(char *)0 ) != 0 )  {
d431 2
a432 1
	} else if( outputfile == (char *)0 )  {
@


14.10.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.11 2005/07/16 23:17:05 brlcad Exp $ (BRL)";
d395 1
a395 1
	if( view_init( &ap, title_file, title_obj, outputfile!=(char *)0, framebuffer!=(char *)0 ) != 0 )  {
d431 1
a431 2
	}
	if( (outputfile == (char *)0) && (fbp == FBIO_NULL) )  {
@


14.9
log
@the PRODUCTION switch no longer exists, check for any of the run-time debug defines
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.8 2005/05/14 19:18:48 brlcad Exp $ (BRL)";
d54 1
a54 1
#ifndef WIN32
d58 4
a69 4
#ifdef WIN32
#  include <fcntl.h>
#endif

d176 1
a176 1
#ifdef WIN32
d230 1
a230 1
#ifndef WIN32
@


14.8
log
@if the frame actually fails for some reason, return a non-zero value instead of 0 (this prevents returning zero when output file gives permission denied)
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.7 2005/04/27 02:38:54 brlcad Exp $ (BRL)";
d222 2
a223 2
#ifdef PRODUCTION
	(void)fprintf(stderr, "Running with production compilation\n");
@


14.7
log
@replace HAVE_SBRK_DECL with the HAVE_SBRK configure check name
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.6 2005/03/28 06:31:37 bob1961 Exp $ (BRL)";
d459 1
d462 8
a469 1
		(void)do_frame( curframe );
@


14.6
log
@Add code to allow liboptical to be a Windows DLL
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.5 2005/03/24 17:26:44 bob1961 Exp $ (BRL)";
d144 1
a144 1
#ifdef HAVE_SBRK_DECL
d189 1
a189 1
#ifdef HAVE_SBRK_DECL
@


14.5
log
@Add code to open files in binary mode (Windows Only)
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.4 2005/01/30 20:31:09 brlcad Exp $ (BRL)";
a58 1
#include "bu.h"
a59 1
#include "bn.h"
a72 3
extern int	rdebug;			/* RT program debugging */
int		rt_verbosity = -1;	/* blather incesantly by default */

@


14.4
log
@update copyright to 2005
@
text
@d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.3 2004/12/24 01:40:00 brlcad Exp $ (BRL)";
d182 5
d189 2
@


14.3
log
@add the mysteriously missing gpl header..
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United  States Government as represented by
d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/main.c,v 14.2 2004/12/21 06:38:22 morrison Exp $ (BRL)";
@


14.2
log
@remove the old copyright notice section
@
text
@d1 21
a21 2
/*
 *			M A I N . C
a37 1
 *  
d40 1
a40 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/main.c,v 14.1 2004/11/16 19:42:31 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@a19 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985,1987 by the United States Army.
 *	All rights reserved.
d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/main.c,v 1.4 2004/09/16 08:05:48 morrison Exp $ (BRL)";
@


1.4
log
@quell yet more warnings..
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/main.c,v 1.3 2004/08/02 23:01:52 morrison Exp $ (BRL)";
d477 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/main.c,v 1.2 2004/06/08 22:04:34 morrison Exp $ (BRL)";
a29 2


d32 3
a34 1
#include <string.h>
d40 1
a40 1
#include <unistd.h>
d54 1
a54 1
#include <fcntl.h>
d57 1
d112 1
d321 1
a321 1
		bu_vls_from_argv( &str, bu_optind, argv );
d327 1
a327 1
			argv+bu_optind+1 );
@


1.2
log
@obliterate externs.h
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d28 1
a28 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d25 1
a25 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/main.c,v 11.61 2004/05/10 15:30:49 erikg Exp $ (BRL)";
a45 1
#include "externs.h"
@

