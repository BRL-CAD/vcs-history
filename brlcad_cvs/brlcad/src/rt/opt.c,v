head	14.24;
access;
symbols
	rel-7-10-4:14.20
	STABLE:14.20.0.2
	stable-branch:14.6
	rel-7-10-2:14.18
	rel-7-10-0:14.18
	rel-7-8-4:14.15
	rel-7-8-2:14.14
	rel-7-8-0:14.14
	trimnurbs-branch:14.14.0.2
	help:14.14
	temp_tag:14.12
	bobWinPort-20051223-freeze:14.9.2.1
	postmerge-20051223-bobWinPort:14.12
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.24
date	2007.12.02.22.34.24;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.11.21.16.18.53;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.10.17.02.10.13;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.09.15.16.23.20;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.08.18.09.31.26;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.08.18.00.22.58;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.27.01.41.45;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.23.01.13.45;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.20.14.36.59;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.06.22.16.11.23;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.01.28.00.36.29;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.12.23.21.26.46;	author bob1961;	state Exp;
branches;
next	14.11;

14.11
date	2005.12.22.06.32.06;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.38;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.08.15.21.43.07;	author bob1961;	state Exp;
branches
	14.9.2.1
	14.9.4.1;
next	14.8;

14.8
date	2005.06.07.02.44.38;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.06.03.05.24.11;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.03.28.06.31.37;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.03.24.17.28.24;	author bob1961;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.09;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.24.01.40.00;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.38.22;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.59;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.34;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.44;	author morrison;	state Exp;
branches;
next	;

14.9.2.1
date	2005.09.13.19.20.58;	author bob1961;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.24
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@/*                           O P T . C
 * BRL-CAD
 *
 * Copyright (c) 1989-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file opt.c
 *
 *  Option handling for Ray Tracing main program.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.23 2007/11/21 16:18:53 erikgreenwald Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./ext.h"

#include "rtprivate.h"
#include "../librt/debug.h"

int		rpt_dist = 0;		/* report distance to each pixel */
int		width = 0;		/* # of pixels in X */
int		height = 0;		/* # of lines in Y */


/***** Variables shared with viewing model *** */
int		doubles_out = 0;	/* u_char or double .pix output file */
double		azimuth = 0.0, elevation = 0.0;
int		lightmodel = 0;		/* Select lighting model */
int		rpt_overlap = 1;	/* report overlapping region names */
int		default_background = 1; /* Default is black */
int		rt_text_mode = 0;       /* Currently used by rtcheck and nirt */
/***** end of sharing with viewing model *****/

/***** variables shared with worker() ******/
int		query_x = 0;
int		query_y = 0;
int		Query_one_pixel = 0;
int		query_rdebug  = 0;
int		query_debug = 0;
int		stereo = 0;		/* stereo viewing */
int		hypersample = 0;		/* number of extra rays to fire */
unsigned int	jitter = 0;		/* ray jitter control variable */
fastf_t		rt_perspective = (fastf_t)0.0;	/* presp (degrees X) 0 => ortho */
fastf_t		aspect = (fastf_t)1.0;	/* view aspect ratio X/Y (needs to be 1.0 for g/G options) */
vect_t		dx_model;		/* view delta-X as model-space vect */
vect_t		dy_model;		/* view delta-Y as model-space vect */
vect_t		dx_unit;		/* view delta-X as unit-len vect */
vect_t		dy_unit;		/* view delta-Y as unit-len vect */
fastf_t		cell_width = (fastf_t)0.0;		/* model space grid cell width */
fastf_t		cell_height = (fastf_t)0.0;	/* model space grid cell height */
int		cell_newsize = 0;		/* new grid cell size */
point_t		eye_model = {(fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0};		/* model-space location of eye */
fastf_t         eye_backoff = (fastf_t)1.414;	/* dist from eye to center */
extern int		width;			/* # of pixels in X */
extern int		height;			/* # of lines in Y */
mat_t		Viewrotscale = { (fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0,
				 (fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0,
				 (fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0,
				 (fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0};
fastf_t		viewsize = (fastf_t)0.0;
int		incr_mode = 0;		/* !0 for incremental resolution */
int		incr_level = 0;		/* current incremental level */
int		incr_nlevel = 0;	/* number of levels */
int		npsw = 1;		/* number of worker PSWs to run */
struct resource	resource[MAX_PSW];	/* memory resources */
int		transpose_grid = 0;     /* reverse the order of grid traversal */
/***** end variables shared with worker() *****/

/***** Photon Mapping Variables *****/
double		pmargs[9];
char		pmfile[255];
/***** ************************ *****/

/***** variables shared with do.c *****/
char		*string_pix_start = (char *)NULL;	/* string spec of starting pixel */
char		*string_pix_end = (char *)NULL;	/* string spec of ending pixel */
int		pix_start = -1;		/* pixel to start at */
int		pix_end = 0;		/* pixel to end at */
int		nobjs = 0;		/* Number of cmd-line treetops */
char		**objtab = (char **)NULL;	/* array of treetop strings */
int		matflag = 0;		/* read matrix from stdin */
int		desiredframe = 0;	/* frame to start at */
int		finalframe = -1;	/* frame to halt at */
int		curframe = 0;		/* current frame number,
					 * also shared with view.c */
char		*outputfile = (char *)NULL;	/* name of base of output file */
int		interactive = 0;	/* human is watching results */
int		benchmark = 0;		/* No random numbers:  benchmark */

int		sub_grid_mode = 0;	/* mode to raytrace a rectangular portion of view */
int		sub_xmin = 0;		/* lower left of sub rectangle */
int		sub_ymin = 0;
int		sub_xmax = 0;		/* upper right of sub rectangle */
int		sub_ymax = 0;
/***** end variables shared with do.c *****/


/***** variables shared with view.c *****/
fastf_t		frame_delta_t = (fastf_t)(1.0/30.0); /* 1.0 / frames_per_second_playback */
double		airdensity;    /* is the scene hazy (we shade the void space */
double		haze[3] = { 0.8, 0.9, 0.99 };	      /* color of the haze */

/***** end variables shared with view.c *****/

/* temporary kludge to get rt to use a tighter tolerance for raytracing */
fastf_t		rt_dist_tol = (fastf_t)0.0005;	/* Value for rti_tol.dist */

fastf_t		rt_perp_tol = (fastf_t)0.0;	/* Value for rti_tol.perp */
char		*framebuffer = (char *)NULL;		/* desired framebuffer */

int		space_partition = 	/*space partitioning algorithm to use*/
			RT_PART_NUBSPT;
int		nugrid_dimlimit = 0;	/* limit to each dimension of
					   the nugrid */
double		nu_gfactor = RT_NU_GFACTOR_DEFAULT;
		      /* constant factor in NUgrid algorithm, if applicable */

#define MAX_WIDTH	(32*1024)

extern struct command_tab	rt_cmdtab[];

/*
 *			G E T _ A R G S
 */
int get_args( int argc, register char **argv )
{
	register int c;
	register int i;

	bu_optind = 1;		/* restart */


#define GETOPT_STR	\
	".:,:@@:a:b:c:d:e:f:g:h:ij:l:n:o:p:q:rs:tv:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:WX:!:+:"

	while( (c=bu_getopt( argc, argv, GETOPT_STR )) != EOF )  {
		switch( c )  {
		case 'q':
			i = atoi(bu_optarg);
			if (i <= 0) {
				bu_exit(EXIT_FAILURE, "-q %d is < 0\n", i);
			}
			if ( i > BN_RANDHALFTABSIZE) {
				bu_exit(EXIT_FAILURE, "-q %d is > maximum (%d)\n",
				       i, BN_RANDHALFTABSIZE);
			}
			bn_randhalftabsize = i;
			break;
		case 'h':
		    i = sscanf(bu_optarg, "%lg,%lg,%lg,%lg",
			       &airdensity, &haze[X], &haze[Y], &haze[Z]);
		    break;
		case 't':
			transpose_grid = 1;
			break;
		case 'j':
			{
				register char	*cp = bu_optarg;

				sub_xmin = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				sub_ymin = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				sub_xmax = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				sub_ymax = atoi(cp);

				bu_log("Sub-rectangle: (%d,%d) (%d,%d)\n",
					sub_xmin, sub_ymin,
					sub_xmax, sub_ymax );
				if( sub_xmin >= 0 && sub_xmin < sub_xmax &&
				    sub_ymin >= 0 && sub_ymin < sub_ymax )  {
					sub_grid_mode = 1;
				} else {
					sub_grid_mode = 0;
					bu_log("ERROR, bad sub-rectangle, ignored\n");
				}
			}
			break;
		case '.':
			nu_gfactor = (double)atof( bu_optarg );
			break;
		case ',':
			space_partition = atoi(bu_optarg);
			break;
		case '@@':
			nugrid_dimlimit = atoi(bu_optarg);
			break;
		case 'c':
			(void)rt_do_cmd( (struct rt_i *)0, bu_optarg, rt_cmdtab );
			break;
		case 'C':
			{
				char		buf[128] = {0};
				int		r,g,b;
				register char	*cp = bu_optarg;

				r = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				g = atoi(cp);
				while( (*cp >= '0' && *cp <= '9') )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				b = atoi(cp);

				if( r < 0 || r > 255 )  r = 255;
				if( g < 0 || g > 255 )  g = 255;
				if( b < 0 || b > 255 )  b = 255;

#if defined(_WIN32)
				if (r == 0)
				    background[0] = 0.0;
				else
				    background[0] = r / 255.0;
				if (g == 0)
				    background[1] = 0.0;
				else
				    background[1] = g / 255.0;
				if (b == 0)
				    background[2] = 0.0;
				else
				    background[2] = b / 255.0;
#else
				sprintf(buf,"set background=%f/%f/%f",
					r/255., g/255., b/255. );
				(void)rt_do_cmd( (struct rt_i *)0, buf,
					rt_cmdtab );
#endif
			}
			break;
		case 'T':
			{
				double		f;
				char		*cp;
				f = 0;
				if( sscanf( bu_optarg, "%lf", &f ) == 1 )  {
					if( f > 0 )
						rt_dist_tol = f;
				}
				f = 0;
				if( (cp = strchr(bu_optarg, '/')) ||
				    (cp = strchr(bu_optarg, ',')) )  {
					if( sscanf( cp+1, "%lf", &f ) == 1 )  {
						if( f > 0 && f < 1 )
							rt_perp_tol = f;
					}
				}
				bu_log("Using tolerance %lg", f);
				break;
			}
		case 'U':
			use_air = atoi( bu_optarg );
			break;
		case 'I':
			interactive = 1;
			break;
		case 'i':
			incr_mode = 1;
			break;
		case 'S':
			stereo = 1;
			break;
		case 'J':
			sscanf( bu_optarg, "%x", &jitter );
			break;
		case 'H':
			hypersample = atoi( bu_optarg );
			if( hypersample > 0 )
				jitter = 1;
			break;
		case 'F':
			framebuffer = bu_optarg;
			break;
		case 'D':
			desiredframe = atoi( bu_optarg );
			break;
		case 'K':
			finalframe = atoi( bu_optarg );
			break;
		case 'N':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.NMG_debug);
			bu_log("NMG_debug=0x%x\n", rt_g.NMG_debug);
			break;
		case 'M':
			matflag = 1;
			break;
		case 'A':
			AmbientIntensity = atof( bu_optarg );
			break;
		case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		case 'X':
			sscanf( bu_optarg, "%x", (unsigned int *)&rdebug );
			break;
		case '!':
			sscanf( bu_optarg, "%x", (unsigned int *)&bu_debug );
			break;

		case 's':
			/* Square size */
			i = atoi( bu_optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"squaresize=%d out of range\n", i);
			else
				width = height = i;
			break;
		case 'n':
			i = atoi( bu_optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"height=%d out of range\n", i);
			else
				height = i;
			break;
		case 'W':
			(void)rt_do_cmd( (struct rt_i *)0, "set background=1.0/1.0/1.0", rt_cmdtab );
			default_background = 0;
			break;
		case 'w':
			i = atoi( bu_optarg );
			if( i < 2 || i > MAX_WIDTH )
				fprintf(stderr,"width=%d out of range\n", i);
			else
				width = i;
			break;
		case 'g':
			cell_width = atof( bu_optarg );
			cell_newsize = 1;
			break;
		case 'G':
			cell_height = atof( bu_optarg );
			cell_newsize = 1;
			break;

		case 'a':
			/* Set azimuth */
			azimuth = atof( bu_optarg );
			matflag = 0;
			break;
		case 'e':
			/* Set elevation */
			elevation = atof( bu_optarg );
			matflag = 0;
			break;
		case 'l':
			{
				char	*item;

				/* Select lighting model # */
				lightmodel= 1;	/* Initialize with Full Lighting Model */
				item= strtok(bu_optarg,",");
				lightmodel= atoi(item);

				if (lightmodel == 7) {					/* Process the photon mapping arguments */
					item= strtok(NULL,",");
					pmargs[0]= item ? atoi(item) : 16384;		/* Number of Global Photons */
					item= strtok(NULL,",");
					pmargs[1]= item ? atof(item) : 50;		/* Percent of Global Photons that should be used for Caustic Photons */
					item= strtok(NULL,",");
					pmargs[2]= item ? atoi(item) : 10;		/* Number of Irradiance Sample Rays, Total Rays is this number squared */
					item= strtok(NULL,",");
					pmargs[3]= item ? atof(item) : 60.0;		/* Angular Tolerance */
					item= strtok(NULL,",");
					pmargs[4]= item ? atoi(item) : 0;		/* Random Seed */
					item= strtok(NULL,",");
					pmargs[5]= item ? atoi(item) : 0;		/* Importance Mapping */
					item= strtok(NULL,",");
					pmargs[6]= item ? atoi(item) : 0;		/* Irradiance Hypersampling */
					item= strtok(NULL,",");
					pmargs[7]= item ? atoi(item) : 0;		/* Visualize Irradiance */
					item= strtok(NULL,",");
					pmargs[8]= item ? atof(item) : 1.0;		/* Scale Lumens */
					item= strtok(NULL,",");
					if (item) { strncpy(pmfile,item, 255-1); } else { pmfile[0]= 0; }
/*					item ? strcpy(pmfile,item) : pmfile[0]= 0;*/	/* Scale Lumens */
				}
			}
			break;
		case 'O':
			/* Output pixel file name, double precision format */
			outputfile = bu_optarg;
			doubles_out = 1;
			break;
		case 'o':
			/* Output pixel file name, unsigned char format */
			outputfile = bu_optarg;
			doubles_out = 0;
			break;
		case 'p':
			rt_perspective = atof( bu_optarg );
			if( rt_perspective < 0 || rt_perspective > 179 ) {
				fprintf(stderr,"persp=%g out of range\n", rt_perspective);
				rt_perspective = 0;
			}
			break;
		case 'v': /* Set level of "non-debug" debugging output */
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_verbosity );
			bu_printb( "Verbosity:", rt_verbosity,
				VERBOSE_FORMAT);
			bu_log("\n");
			break;
		case 'E':
			eye_backoff = atof( bu_optarg );
			break;

		case 'P':
			/* Number of parallel workers */
			{
				int avail_cpus;

				avail_cpus = bu_avail_cpus();

				npsw = atoi( bu_optarg );

				if (npsw > avail_cpus ) {
					fprintf( stderr, "Requesting %d cpus, only %d available.",
						 npsw, avail_cpus );

					if ((bu_debug & BU_DEBUG_PARALLEL) ||
					    (RT_G_DEBUG & DEBUG_PARALLEL)) {
					    fprintf(stderr, "\nAllowing surplus cpus due to debug flag.\n");
					} else {
					    fprintf( stderr, "  Will use %d.\n", avail_cpus );
					    npsw = avail_cpus;
					}
				}
				if( npsw == 0 || npsw < -MAX_PSW || npsw > MAX_PSW )  {
				    fprintf(stderr,"Numer of requested cpus (%d) is out of range 1..%d", npsw, MAX_PSW);

				    if ((bu_debug & BU_DEBUG_PARALLEL) ||
					(RT_G_DEBUG & DEBUG_PARALLEL)) {
					fprintf(stderr, ", but allowing due to debug flag\n", DEFAULT_PSW);
				    } else {
					fprintf(stderr, ", using -P%d\n", DEFAULT_PSW);
					npsw = DEFAULT_PSW;
				    }
				}
			}
			break;
		case 'Q':
			Query_one_pixel = ! Query_one_pixel;
			sscanf(bu_optarg, "%d,%d\n", &query_x, &query_y);
			break;
		case 'B':
			/*  Remove all intentional random effects
			 *  (dither, etc) for benchmarking purposes.
			 */
			benchmark = 1;
			bn_mathtab_constant();
			break;
		case 'b':
			/* Specify a single pixel to be done */
			/* Actually processed in do_frame() */
			string_pix_start = bu_optarg;
			npsw = 1;	/* Cancel running in parallel */
			break;
		case 'f':
			/* set expected playback rate in frames-per-second.
			 * This actually gets stored as the delta-t per frame.
			 */
			if ( (frame_delta_t=atof( bu_optarg )) == 0.0) {
				fprintf(stderr, "Invalid frames/sec (%s) == 0.0\n",
					bu_optarg);
				frame_delta_t = 30.0;
			}
			frame_delta_t = 1.0 / frame_delta_t;
			break;
#if 0
		case ?:
			/* XXX what letter to use? */
			/* Specify the pixel to end at */
			/* Actually processed in do_frame() */
			string_pix_end = bu_optarg;
			break;
#endif
		case 'V':
			/* View aspect */
			{
				fastf_t xx, yy;
				register char *cp = bu_optarg;

				xx = atof(cp);
				while( (*cp >= '0' && *cp <= '9')
					|| *cp == '.' )  cp++;
				while( *cp && (*cp < '0' || *cp > '9') ) cp++;
				yy = atof(cp);
				if( yy == 0 )
					aspect = xx;
				else
					aspect = xx/yy;
				if( aspect <= 0.0 ) {
					fprintf(stderr,"Bogus aspect %g, using 1.0\n", aspect);
					aspect = 1.0;
				}
			}
			break;
		case 'r':
			/* report overlapping region names */
			rpt_overlap = 1;
			break;
		case 'R':
			/* DON'T report overlapping region names */
			rpt_overlap = 0;
			break;
		case 'd':
			rpt_dist = atoi( bu_optarg );
			break;
		case '+':
		    {
			register char	*cp = bu_optarg;
			switch (*cp) {
			case 't':
			    rt_text_mode = 1;
			    break;
			default:
			    fprintf(stderr,"unknown option %c\n", *cp);
			    return(0);	/* BAD */
			}
		    }
		    break;
		default:		/* '?' */
			fprintf(stderr,"unknown option %c\n", c);
			return(0);	/* BAD */
		}
	}

	/* sanity checks for sane values */
	if( aspect <= 0.0 ) {
	    aspect = 1.0;
	}

	/* Compat */
	if (RT_G_DEBUG || R_DEBUG || rt_g.NMG_debug )
		bu_debug |= BU_DEBUG_COREDUMP;

	if (RT_G_DEBUG & DEBUG_MEM_FULL)
	    bu_debug |= BU_DEBUG_MEM_CHECK;
	if (RT_G_DEBUG & DEBUG_MEM)
	    bu_debug |= BU_DEBUG_MEM_LOG;
	if (RT_G_DEBUG & DEBUG_PARALLEL)
	    bu_debug |= BU_DEBUG_PARALLEL;
	if (RT_G_DEBUG & DEBUG_MATH)
	    bu_debug |= BU_DEBUG_MATH;

	if (R_DEBUG & RDEBUG_RTMEM_END)
	    bu_debug |= BU_DEBUG_MEM_CHECK;

	return(1);			/* OK */
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d34 1
a34 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.22 2007/10/17 02:10:13 brlcad Exp $ (BRL)";
d411 1
a411 1
					if (item) { strcpy(pmfile,item); } else { pmfile[0]= 0; }
@


14.22
log
@john noticed that the -g and -G options were not working on the rt apps anymore due to the change to the default aspect from 1.0 to 0.0; and sure enough, he was right.  the aspect ratio change (made several years ago!) was for the -V view aspect option, but obviously had other users in other files that used the value.  this changes the default back to 1.0 while also adding a sanity check into the argument processor to make sure the aspect ratio is always a sane value.
@
text
@d34 1
a34 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.21 2007/09/15 16:23:20 brlcad Exp $ (BRL)";
d175 1
a175 2
				bu_log("-q %d is < 0\n", i);
				bu_bomb("");
d178 1
a178 1
				bu_log("-q %d is > maximum (%d)\n",
a179 1
				bu_bomb("");
@


14.21
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d34 1
a34 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.20 2007/08/18 09:31:26 brlcad Exp $ (BRL)";
d78 1
a78 1
fastf_t		aspect = (fastf_t)0.0;	/* view aspect ratio X/Y */
d566 5
@


14.20
log
@meh
@
text
@d34 1
a34 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.19 2007/08/18 00:22:58 brlcad Exp $ (BRL)";
d43 1
a43 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.19
log
@allow the ray-tracers to use more than the available cpus for debugging and testing purposes.  this was previously only possible via compile-time modifications, but now is possible via the BU_DEBUG_PARALLEL debug flag (-\!10 on most of the raytracers).
@
text
@d34 1
a34 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.18 2007/01/27 01:41:45 brlcad Exp $ (BRL)";
d237 1
a237 1
				char		buf[128];
@


14.18
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d34 1
a34 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.17 2007/01/23 01:13:45 brlcad Exp $ (BRL)";
d458 2
a459 2
				if( npsw > avail_cpus ) {
					fprintf( stderr, "Requesting %d cpus, only %d available. ",
d461 8
a468 2
					fprintf( stderr, "Will use %d.\n", avail_cpus );
					npsw = avail_cpus;
d471 9
a479 3
					fprintf(stderr,"abs(npsw) out of range 1..%d, using -P%d\n",
						MAX_PSW, MAX_PSW);
					npsw = MAX_PSW;
d571 1
a571 1
	if( RT_G_DEBUG || R_DEBUG || rt_g.NMG_debug )
d574 8
a581 4
	if( RT_G_DEBUG & DEBUG_MEM_FULL )  bu_debug |= BU_DEBUG_MEM_CHECK;
	if( RT_G_DEBUG & DEBUG_MEM )  bu_debug |= BU_DEBUG_MEM_LOG;
	if( RT_G_DEBUG & DEBUG_PARALLEL )  bu_debug |= BU_DEBUG_PARALLEL;
	if( RT_G_DEBUG & DEBUG_MATH )  bu_debug |= BU_DEBUG_MATH;
d583 2
a584 1
	if( R_DEBUG & RDEBUG_RTMEM_END )  bu_debug |= BU_DEBUG_MEM_CHECK;
@


14.17
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d34 1
a34 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.16 2007/01/20 14:36:59 brlcad Exp $ (BRL)";
d399 1
a399 1
 					pmargs[0]= item ? atoi(item) : 16384;		/* Number of Global Photons */
@


14.16
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d34 1
a34 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.15 2006/06/22 16:11:23 brlcad Exp $ (BRL)";
@


14.15
log
@initialize a slew of uninitialized values using proper casts for the fastf_t types.  uninitialized garbage was causing debug and runtime problems on altix
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2006 United States Government as represented by
d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.14 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
@


14.14
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.13 2006/01/18 06:46:23 brlcad Exp $ (BRL)";
d60 2
a61 2
int		width = 0;			/* # of pixels in X */
int		height = 0;			/* # of lines in Y */
d66 1
a66 1
double		azimuth, elevation;
d74 5
a78 5
int		query_x;
int		query_y;
int		Query_one_pixel;
int		query_rdebug;
int		query_debug;
d80 3
a82 3
int		hypersample=0;		/* number of extra rays to fire */
unsigned int	jitter=0;		/* ray jitter control variable */
fastf_t		rt_perspective=0;	/* presp (degrees X) 0 => ortho */
d88 5
a92 5
fastf_t		cell_width=0.0;		/* model space grid cell width */
fastf_t		cell_height=0.0;	/* model space grid cell height */
int		cell_newsize=0;		/* new grid cell size */
point_t		eye_model;		/* model-space location of eye */
fastf_t         eye_backoff = 1.414;	/* dist from eye to center */
d95 5
a99 2
mat_t		Viewrotscale;
fastf_t		viewsize=0;
d101 2
a102 2
int		incr_level;		/* current incremental level */
int		incr_nlevel;		/* number of levels */
d114 2
a115 2
char		*string_pix_start;	/* string spec of starting pixel */
char		*string_pix_end;	/* string spec of ending pixel */
d117 3
a119 3
int		pix_end;		/* pixel to end at */
int		nobjs;			/* Number of cmd-line treetops */
char		**objtab;		/* array of treetop strings */
d125 1
a125 1
char		*outputfile = (char *)0;/* name of base of output file */
d138 1
a138 1
fastf_t		frame_delta_t = 1./30.; /* 1.0 / frames_per_second_playback */
d145 1
a145 1
fastf_t		rt_dist_tol = 0.0005;	/* Value for rti_tol.dist */
d147 2
a148 2
fastf_t		rt_perp_tol = 0;	/* Value for rti_tol.perp */
char		*framebuffer;		/* desired framebuffer */
@


14.13
log
@update copyright to 2006
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.12 2005/12/23 21:26:46 bob1961 Exp $ (BRL)";
d40 1
d45 1
a45 1
#include <string.h>
d47 1
a47 1
#include <strings.h>
@


14.12
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1989-2005 United States Government as represented by
d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
@


14.11
log
@use 0.0 as the 'default' aspect ratio to represent unset.  catch a negative aspect ratio as an error.  a 'default'/unset aspect ratio will get adjusted to be the image dimensions ratio.
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.10 2005/10/23 04:44:38 brlcad Exp $ (BRL)";
d250 14
d268 1
@


14.10
log
@trailing ws
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.9 2005/08/15 21:43:07 bob1961 Exp $ (BRL)";
d82 1
a82 1
fastf_t		aspect = 1;		/* view aspect ratio X/Y */
d504 1
a504 1
				if( aspect == 0 ) {
d506 1
a506 1
					aspect = 1;
@


14.9
log
@Add support for outputting plot in text mode
@
text
@d32 1
a32 1
 *  
d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.8 2005/06/07 02:44:38 brlcad Exp $ (BRL)";
d187 1
a187 1
		    i = sscanf(bu_optarg, "%lg,%lg,%lg,%lg", 
@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d187 1
a187 1
		    i = sscanf(bu_optarg, "%lg,%lg,%lg,%lg",
@


14.9.2.1
log
@Since there is no "background" command in rt_cmdtab and we already have the background color parsed, go ahead and set the background (Windows only, for now)
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.9 2005/08/15 21:43:07 bob1961 Exp $ (BRL)";
a249 14
#if defined(_WIN32)
				if (r == 0)
				    background[0] = 0.0;
				else
				    background[0] = r / 255.0;
				if (g == 0)
				    background[1] = 0.0;
				else
				    background[1] = g / 255.0;
				if (b == 0)
				    background[2] = 0.0;
				else
				    background[2] = b / 255.0;
#else
a253 1
#endif
@


14.8
log
@init the cell width and height to something
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.7 2005/06/03 05:24:11 brlcad Exp $ (BRL)";
d69 1
d169 1
a169 1
	".:,:@@:a:b:c:d:e:f:g:h:ij:l:n:o:p:q:rs:tv:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:WX:!:"
d521 13
@


14.7
log
@add a -W option to all of the raytracers that specifies that a 'non-default' (usually inverted) background color should be used.  for rt, this is a white background.
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.6 2005/03/28 06:31:37 bob1961 Exp $ (BRL)";
a39 2


d86 2
a87 2
fastf_t		cell_width;		/* model space grid cell width */
fastf_t		cell_height;		/* model space grid cell height */
@


14.6
log
@Add code to allow liboptical to be a Windows DLL
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.5 2005/03/24 17:28:24 bob1961 Exp $ (BRL)";
d70 1
d170 1
a170 1
	".:,:@@:a:b:c:d:e:f:g:h:ij:l:n:o:p:q:rs:tv:w:x:A:BC:D:E:F:G:H:IJ:K:MN:O:P:Q:RST:U:V:X:!:"
d341 4
@


14.5
log
@Initialize width and height to zero
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.4 2005/01/30 20:31:09 brlcad Exp $ (BRL)";
a59 2
extern int	rdebug;			/* RT program debugging */

@


14.4
log
@update copyright to 2005
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.3 2004/12/24 01:40:00 brlcad Exp $ (BRL)";
d63 2
a64 2
int		width;			/* # of pixels in X */
int		height;			/* # of lines in Y */
@


14.3
log
@add the mysteriously missing gpl header..
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2004 United States Government as represented by
d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/opt.c,v 14.2 2004/12/21 06:38:22 morrison Exp $ (BRL)";
@


14.2
log
@remove the old copyright notice section
@
text
@d1 21
a21 2
/*
 *			O P T . C
d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/opt.c,v 14.1 2004/11/16 19:42:31 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@a13 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
d16 1
a16 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/opt.c,v 1.4 2004/09/03 23:30:59 morrison Exp $ (BRL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/opt.c,v 1.3 2004/08/02 23:01:52 morrison Exp $ (BRL)";
d522 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/opt.c,v 1.2 2004/06/08 22:04:34 morrison Exp $ (BRL)";
d29 1
a29 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d22 1
a22 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/opt.c,v 11.40 2004/05/10 15:30:49 erikg Exp $ (BRL)";
a37 1
#include "externs.h"
@

