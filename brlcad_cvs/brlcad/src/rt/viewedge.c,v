head	14.33;
access;
symbols
	rel-7-10-4:14.26
	STABLE:14.26.0.2
	stable-branch:14.8
	rel-7-10-2:14.26
	rel-7-10-0:14.23
	rel-7-8-4:14.19
	rel-7-8-2:14.19
	rel-7-8-0:14.19
	trimnurbs-branch:14.19.0.2
	help:14.19
	temp_tag:14.18
	bobWinPort-20051223-freeze:14.14
	postmerge-20051223-bobWinPort:14.18
	premerge-20051223-bobWinPort:14.18
	rel-7-6-6:14.18
	rel-7-6-4:14.16
	rel-7-6-2:14.14
	rel-7-6-branch:14.14.0.4
	rel-7-6-0:14.14
	rel-7-4-2:14.13.2.1
	rel-7-4-branch:14.13.0.2
	bobWinPort:14.14.0.2
	rel-7-4-0:14.13
	rel-7-2-6:14.12
	rel-7-2-4:14.9
	rel-7-2-2:14.7
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.33
date	2007.12.17.07.53.19;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.11.28.14.11.28;	author erikgreenwald;	state Exp;
branches;
next	14.31;

14.31
date	2007.11.21.16.18.53;	author erikgreenwald;	state Exp;
branches;
next	14.30;

14.30
date	2007.11.15.18.01.02;	author erikgreenwald;	state Exp;
branches;
next	14.29;

14.29
date	2007.11.15.17.52.19;	author erikgreenwald;	state Exp;
branches;
next	14.28;

14.28
date	2007.10.22.00.58.40;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.10.22.00.30.27;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.04.17.03.23.57;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.04.13.18.55.00;	author erikgreenwald;	state Exp;
branches;
next	14.24;

14.24
date	2007.04.13.17.07.43;	author erikgreenwald;	state Exp;
branches;
next	14.23;

14.23
date	2007.03.15.18.55.04;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.27.01.41.45;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.23.01.13.46;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.20.14.37.00;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.01.18.06.46.24;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2005.12.14.02.29.27;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2005.12.08.01.54.43;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.10.23.04.44.38;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.09.19.17.59.00;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.07.16.23.22.10;	author brlcad;	state Exp;
branches
	14.14.4.1;
next	14.13;

14.13
date	2005.06.21.07.03.55;	author brlcad;	state Exp;
branches
	14.13.2.1;
next	14.12;

14.12
date	2005.06.03.05.34.58;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.06.03.05.26.15;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.05.28.02.14.59;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.04.26.08.39.36;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.04.11.18.32.27;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.03.31.05.53.12;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.03.28.06.31.37;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.01.30.20.31.10;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.24.01.40.01;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.07.25.31;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.38.22;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.20.19.37.30;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.19.57.13;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.47;	author morrison;	state Exp;
branches;
next	;

14.13.2.1
date	2005.08.16.21.03.50;	author brlcad;	state Exp;
branches;
next	;

14.14.4.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.33
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                      V I E W E D G E . C
 * BRL-CAD
 *
 * Copyright (c) 2001-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file viewedge.c
 *
 *  Ray Tracing program RTEDGE bottom half.
 *
 *  This module utilizes the RT library to interrogate a MGED
 *  model and produce a pixfile or framebuffer image of the
 *  hidden line 'edges' of the geometry. An edge exists whenever
 *  there is a change in region ID, or a significant change in
 *  obliquity or line-of-sight distance.
 *
 *
 *  XXX - Add support for detecting changes in specified attributes.
 *
 *  Author -
 *	Ronald A. Bowers
 *
 */

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "fb.h"
#include "bu.h"

#include "./ext.h"


#define RTEDGE_DEBUG 1

int	use_air = 0;			/* Handling of air in librt */
int	using_mlib = 0;			/* Material routines NOT used */

extern 	FBIO	*fbp;			/* Framebuffer handle */
extern	fastf_t	viewsize;
extern	int	lightmodel;
extern	int	width, height;
extern	int	per_processor_chunk;
extern	int	default_background;

static	int pixsize = 0;		/* bytes per pixel in scanline */

struct cell {
    int		c_ishit;
    struct region *	c_region;
    fastf_t		c_dist;		/* distance from emanation plane to in_hit */
    int		c_id;		/* region_id of component hit */
    point_t		c_hit;		/* 3-space hit point of ray */
    vect_t		c_normal;	/* surface normal at the hit point */
    vect_t		c_rdir;		/* ray direction, permits perspective */
};

#define MISS_DIST	MAX_FASTF
#define MISS_ID		-1

static unsigned char *writeable[MAX_PSW];
static unsigned char *scanline[MAX_PSW];
static unsigned char *blendline[MAX_PSW];
static struct cell   *saved[MAX_PSW];
static struct resource occlusion_resources[MAX_PSW];

int   		nEdges = 0;
int   		nPixels = 0;
fastf_t		max_dist = -1; /* min. distance for drawing pits/mountains */
fastf_t		maxangle; /* Value of the cosine of the angle between
			   * surface normals that triggers shading
			   */

typedef int color[3];
color	fgcolor = { 255, 255, 255};
color	bgcolor = { 0, 0, 0};

/*
 * Flags that set which edges are detected.
 * detect_ids means detect boundaries region id codes.
 * detect_regions -> detect region boundaries.
 * detect_distance -> detect noticable differences in hit distance.
 * detect_normals -> detect rapid change in surface normals
 */
int	detect_ids = 1;
int	detect_regions = 0;
int	detect_distance = 1;
int	detect_normals = 1;
int     detect_attributes = 0; /* unsupported yet */

RGBpixel fb_bg_color;

/*
 * Overlay Mode
 *
 * If set, and the fbio points to a readable framebuffer, only
 * edge pixels are splatted. This allows rtedge to overlay edges
 * directly rather than having to use pixmerge.
 */
#define OVERLAY_MODE_UNSET 0
#define OVERLAY_MODE_DOIT  1
#define OVERLAY_MODE_FORCE 2

static int    overlay = OVERLAY_MODE_UNSET;

/*
 * Blend Mode
 *
 * If set, and the fbio points to a readable framebuffer, the edge
 * pixels are blended (using some HSV manipulations) with the
 * original framebuffer pixels. The intent is to produce an effect
 * similar to the "bugs" on TV networks.
 *
 * Doesn't work worth beans!
 */
int    blend = 0;

/*
 * Region Colors Mode
 *
 * If set, the color of edge pixels is set to the region colors.
 * If the edge is determined because of a change from one region
 * to another, the color selected is the one from the region with
 * the lowest hit distance.
 */
int    region_colors = 0;

/*
 * Occlusions Mode
 *
 * This is really cool! Occlusion allows the user to specify a second
 * set of objects (from the same .g) that can be used to separate fore-
 * ground from background.
 */
#define OCCLUSION_MODE_NONE 0
#define OCCLUSION_MODE_EDGES 1
#define OCCLUSION_MODE_HITS 2
#define OCCLUSION_MODE_DITHER 3
#define OCCLUSION_MODE_DEFAULT 2

int occlusion_mode = OCCLUSION_MODE_NONE;

struct bu_vls occlusion_objects;
struct rt_i *occlusion_rtip = NULL;
struct application **occlusion_apps;

static struct bu_image_file *bif = NULL;

static int occlusion_hit (struct application *,
			  struct partition *, struct seg *);
static int occlusion_miss (struct application *);
static int occludes (struct application *, struct cell *);


/*
 * Prototypes for the viewedge edge detection functions
 */
static int rayhit (struct application *, struct partition *, struct seg *);
static int raymiss (struct application *);
static void choose_color (RGBpixel col, struct cell *me,
			  struct cell *left, struct cell *below);

#define COSTOL 0.91    /* normals differ if dot product < COSTOL */
#define OBLTOL 0.1     /* high obliquity if cosine of angle < OBLTOL ! */
#define is_Odd(_a)      ((_a)&01)
#define ARCTAN_87       19.08

#ifndef Abs
# define Abs( x )        ((x) < 0 ? -(x) : (x))                  /* UNSAFE */
#endif


/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
    /*XXX need to investigate why this doesn't work on Windows */
#if !defined(__alpha) && !defined(_WIN32) /* XXX Alpha does not support this initialization! */
    {"%d", 1, "detect_regions", bu_byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "dr", bu_byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "detect_distance", bu_byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "dd", bu_byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "detect_normals", bu_byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "dn", bu_byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "detect_ids", bu_byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "di", bu_byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 3, "foreground", bu_byteoffset(fgcolor), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 3, "fg", bu_byteoffset(fgcolor), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 3, "background", bu_byteoffset(bgcolor), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 3, "bg", bu_byteoffset(bgcolor), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "overlay", bu_byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "ov", bu_byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "blend", bu_byteoffset(blend), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "bl", bu_byteoffset(blend), BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "region_color", bu_byteoffset(region_colors),
     BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "rc", bu_byteoffset(region_colors), BU_STRUCTPARSE_FUNC_NULL},
    {"%S", 1, "occlusion_objects", bu_byteoffset(occlusion_objects),
     BU_STRUCTPARSE_FUNC_NULL},
    {"%S", 1, "oo", bu_byteoffset(occlusion_objects),
     BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "occlusion_mode", bu_byteoffset(occlusion_mode),
     BU_STRUCTPARSE_FUNC_NULL},
    {"%d", 1, "om", bu_byteoffset(occlusion_mode), BU_STRUCTPARSE_FUNC_NULL},
    {"%f", 1, "max_dist", bu_byteoffset(max_dist), BU_STRUCTPARSE_FUNC_NULL},
#endif
    {"",	0, (char *)0,	0,	BU_STRUCTPARSE_FUNC_NULL }
};


const char title[] = "RT Hidden-Line Renderer";
const char usage[] = "\
Usage:  rtedge [options] model.g objects... >file.pix\n\
Options:\n\
 -s #               Grid size in pixels, (default 512)\n\
 -w # -n #          Grid size width and height in pixels\n\
 -V #               View (pixel) aspect ratio (width/height)\n\
 -a #               Azimuth in deg\n\
 -e #               Elevation in deg\n\
 -M                 Read matrix+cmds on stdin\n\
 -N #               NMG debug flags\n\
 -o model.pix       Output file, .pix format (default=fb)\n\
 -x #               librt debug flags\n\
 -X #               rt debug flags\n\
 -p #               Perspsective, degrees side to side\n\
 -P #               Set number of processors\n\
 -T #/#             Tolerance: distance/angular\n\
 -r                 Report overlaps\n\
 -R                 Do not report overlaps\n\
 -c                 Auxillary commands (see man page)\n\
";


/*
 *  Called at the start of a run.
 *  Returns 1 if framebuffer should be opened, else 0.
 */
int
view_init( struct application *ap, char *file, char *obj, int minus_o, int minus_F )
{
    /*
     *  Allocate a scanline for each processor.
     */
    ap->a_hit = rayhit;
    ap->a_miss = raymiss;
    ap->a_onehit = 1;

    /*
     * Does the user want occlusion checking?
     *
     * If so, load and prep.
     */
    if (bu_vls_strlen(&occlusion_objects) != 0) {
	struct db_i *dbip;
	int nObjs;
	const char **objs;
	int i;

	bu_log ("rtedge: loading occlusion geometry from %s.\n", file);

	if (Tcl_SplitList (NULL, bu_vls_addr (&occlusion_objects), &nObjs,
			   &objs) == TCL_ERROR) {
	    bu_log  ("rtedge: occlusion list = %s\n",
		     bu_vls_addr(&occlusion_objects));
	    bu_exit (EXIT_FAILURE, "rtedge: could not parse occlusion objects list.\n");
	}

	for (i=0; i<nObjs; ++i) {
	    bu_log ("rtedge: occlusion object %d = %s\n", i, objs[i]);
	}


	if( (dbip = db_open( file, "r" )) == DBI_NULL )
	    bu_exit (EXIT_FAILURE, "rtedge: could not open database.\n");
	RT_CK_DBI(dbip);

	occlusion_rtip = rt_new_rti( dbip ); /* clones dbip */

	for( i=0; i < MAX_PSW; i++ ) {
		rt_init_resource( &occlusion_resources[i], i, occlusion_rtip );
		bn_rand_init( occlusion_resources[i].re_randptr, i );
	    }

	db_close(dbip);			 /* releases original dbip */

	for (i=0; i<nObjs; ++i)
	    if (rt_gettree (occlusion_rtip, objs[i]) < 0)
		bu_log ("rtedge: gettree failed for %s\n", objs[i]);
	    else
		bu_log ("rtedge: got tree for object %d = %s\n", i, objs[i]);

	bu_log ("rtedge: occlusion rt_gettrees done.\n");

	rt_prep (occlusion_rtip);

	bu_log ("rtedge: occlustion prep done.\n");

	/*
	 * Create a set of application structures for the occlusion
	 * geometry. Need one per cpu, the upper half does the per-
	 * thread allocation in worker, but that's off limits.
	 */
	occlusion_apps = bu_calloc (npsw, sizeof(struct application *),
				    "occlusion application structure array");
	for (i=0; i<npsw; ++i) {
	    occlusion_apps[i] = bu_malloc (sizeof(struct application), "occlusion_application structure");

	    RT_APPLICATION_INIT(occlusion_apps[i]);

	    occlusion_apps[i]->a_rt_i = occlusion_rtip;
	    occlusion_apps[i]->a_resource = (struct resource *)BU_PTBL_GET( &occlusion_rtip->rti_resources, i );
	    occlusion_apps[i]->a_onehit = 1;
	    occlusion_apps[i]->a_hit = occlusion_hit;
	    occlusion_apps[i]->a_miss = occlusion_miss;
	    if (rpt_overlap)
		occlusion_apps[i]->a_logoverlap = ((void (*)())0);
	    else
		occlusion_apps[i]->a_logoverlap = rt_silent_logoverlap;

	}
	bu_log ("rtedge: will perform occlusion testing.\n");

	/*
	 * If an inclusion mode has not been specified, use the default.
	 */
	if (occlusion_mode == OCCLUSION_MODE_NONE) {
	    occlusion_mode = OCCLUSION_MODE_DEFAULT;
	    bu_log ("rtedge: occlusion mode = %d\n", occlusion_mode);
	}

	if ((occlusion_mode != OCCLUSION_MODE_NONE) &&
	    (overlay == OVERLAY_MODE_UNSET)) {
	    bu_log ("rtedge: automagically activating overlay mode.\n");
	    overlay = OVERLAY_MODE_DOIT;
	}

    }

    if (occlusion_mode != OCCLUSION_MODE_NONE &&
	bu_vls_strlen(&occlusion_objects) == 0) {
	bu_exit (EXIT_FAILURE, "rtedge: occlusion mode set, but no objects were specified.\n");
    }

    /* if non-default/inverted background was requested, swap the
     * foreground and background colors.
     */
    if (!default_background) {
	color tmp;
	tmp[RED] = fgcolor[RED];
	tmp[GRN] = fgcolor[GRN];
	tmp[BLU] = fgcolor[BLU];
	fgcolor[RED] = bgcolor[RED];
	fgcolor[GRN] = bgcolor[GRN];
	fgcolor[BLU] = bgcolor[BLU];
	bgcolor[RED] = tmp[RED];
	bgcolor[GRN] = tmp[GRN];
	bgcolor[BLU] = tmp[BLU];
    }

    if( minus_o && (overlay || blend)) {
	/*
	 * Output is to a file stream.  Do not allow parallel processing
	 * since we can't seek to the rows.
	 */
	rt_g.rtg_parallel = 0;
	bu_log ("view_init: deactivating parallelism due to -o option.\n");
	/*
	 * The overlay and blend cannot be used in -o mode.
	 * Note that the overlay directive takes precendence, they
	 * can't be used together.
	 */
	overlay = 0;
	blend = 0;
	bu_log ("view_init: deactivating overlay and blending due to -o option.\n");
    }

    if (overlay)
	bu_log ("view_init: will perform simple overlay.\n");
    else if (blend)
	bu_log ("view_init: will perform blending.\n");

    return minus_F || (!minus_o && !minus_F); /* we need a framebuffer */
}

/* beginning of a frame */
void
view_2init( struct application *ap )
{
    int i;

    if(outputfile)
	bif = bu_image_save_open(outputfile,BU_IMAGE_AUTO,width,height,3);

    /*
     * Per_processor_chuck specifies the number of pixels rendered
     * per each pass of a worker. By making this value equal to the
     * width of the image, each worker will render one scanline at
     * a time.
     */
    per_processor_chunk = width;

    /*
     * Use three bytes per pixel.
     */
    pixsize = 3;

    /*
     * Set the hit distance difference necessary to trigger an edge.
     * This algorythm was stolen from lgt, I may make it settable later.
     */
    if (max_dist < .00001)
	max_dist = (cell_width*ARCTAN_87)+2;

    /*
     * Determine if the framebuffer is readable.
     */
    if (overlay || blend)
	if (fb_read(fbp,0,0,fb_bg_color,1) < 0)
	    bu_exit (EXIT_FAILURE, "rt_edge: specified framebuffer is not readable, cannot merge.\n");

    /*
     * Create a cell to store current data for next cells left side.
     * Create a edge flag buffer for each processor.
     * Create a scanline buffer for each processor.
     */
    for (i = 0; i < npsw; ++i) {
	if (saved[i] == NULL)
	    saved[i] = (struct cell *) bu_calloc( 1, sizeof(struct cell), "saved cell info" );
	if (writeable[i] == NULL)
	    writeable[i] = (unsigned char *) bu_calloc( 1, per_processor_chunk, "writeable pixel flag buffer" );
	if (scanline[i] == NULL)
	    scanline[i] = (unsigned char *) bu_calloc( per_processor_chunk, pixsize, "scanline buffer" );
	/*
	 * If blending is desired, create scanline buffers to hold
	 * the read-in lines from the framebuffer.
	 */
	if (blend && blendline[i] == NULL)
	    blendline[i] = (unsigned char *) bu_calloc( per_processor_chunk, pixsize, "blend buffer" );
    }

    /*
     * If operating in overlay mode, we want the rtedge background color
     * to be the shaded images background. This sets the bg color
     * automatically, but assumes that pixel 0,0 is background. If not,
     * the user can set it manually (so long as it isn't 0 0 1!).
     *
     */
    if (overlay && bgcolor[RED] == 0 && bgcolor[GRN] == 0 && bgcolor[BLU] == 1) {
	    bgcolor[RED] = fb_bg_color[RED];
	    bgcolor[GRN] = fb_bg_color[GRN];
	    bgcolor[BLU] = fb_bg_color[BLU];
    }
    return;
}

/* end of each pixel */
void view_pixel( struct application *ap ) { }


/*
 * view_eol - action performed at the end of each scanline
 *
 */
void
view_eol( struct application *ap )
{
    int cpu = ap->a_resource->re_cpu;
    int i;

    if (overlay) {
	/*
	 * Overlay mode. Check if the pixel is an edge.
	 * If so, write it to the framebuffer.
	 */
	for (i = 0; i < per_processor_chunk; ++i) {
	    if (writeable[cpu][i]) {
		/*
		 * Write this pixel
		 */
		bu_semaphore_acquire (BU_SEM_SYSCALL);
		fb_write(fbp, i, ap->a_y, &scanline[cpu][i*3], 1);
		bu_semaphore_release (BU_SEM_SYSCALL);
	    }
	}
	return;
    }
    else if (blend) {
	/*
	 * Blend mode.
	 *
	 * Read a line from the existing framebuffer,
	 * convert to HSV, manipulate, and put the results
	 * in the scanline as RGB.
	 */
	int replace_down = 0; /* flag that specifies if the pixel in the
			       * scanline below must be replaced.
			       */
	RGBpixel rgb;
	fastf_t hsv[3];

	bu_semaphore_acquire (BU_SEM_SYSCALL);
	if (fb_read(fbp,0,ap->a_y,blendline[cpu],per_processor_chunk) < 0)
	    bu_exit (EXIT_FAILURE, "rtedge: error reading from framebuffer.\n");
	bu_semaphore_release (BU_SEM_SYSCALL);

	for (i=0; i<per_processor_chunk; ++i) {
	    /*
	     * Is this pixel an edge?
	     */
	    if (writeable[cpu][i]) {

		/*
		 * The pixel is an edge, retrieve the appropriate
		 * pixel from the line buffer and convert it to HSV.
		 */
		rgb[RED] = blendline[cpu][i*3+RED];
		rgb[GRN] = blendline[cpu][i*3+GRN];
		rgb[BLU] = blendline[cpu][i*3+BLU];

		/*
		 * Is the pixel in the blendline array the
		 * background color? If so, look left and down
		 * to determine which pixel is the "source" of the
		 * edge. Unless, of course, we are on the bottom
		 * scanline or the leftmost column (x=y=0)
		 */
		if (i != 0 && ap->a_y != 0 && !diffpixel (rgb,fb_bg_color)) {
		    RGBpixel left;
		    RGBpixel down;

		    left[RED] = blendline[cpu][(i-1)*3+RED];
		    left[GRN] = blendline[cpu][(i-1)*3+GRN];
		    left[BLU] = blendline[cpu][(i-1)*3+BLU];

		    bu_semaphore_acquire (BU_SEM_SYSCALL);
		    fb_read (fbp, i, ap->a_y - 1, down, 1);
		    bu_semaphore_release (BU_SEM_SYSCALL);

		    if (diffpixel (left, fb_bg_color)) {
			/*
			 * Use this one.
			 */
			rgb[RED] = left[RED];
			rgb[GRN] = left[GRN];
			rgb[BLU] = left[BLU];
		    }
		    else if (diffpixel (down, fb_bg_color)) {
			/*
			 * Use the pixel from the scanline below
			 */
			replace_down = 1;

			rgb[RED] = down[RED];
			rgb[GRN] = down[GRN];
			rgb[BLU] = down[BLU];
		    }
		}
		/*
		 * Convert to HSV
		 */
		bu_rgb_to_hsv (rgb, hsv);

		/*
		 * Now perform the manipulations.
		 */
		hsv[VAL] *= 3.0;
		hsv[SAT] /= 3.0;

		if (hsv[VAL] > 1.0) {
		    fastf_t d = hsv[VAL] - 1.0;

		    hsv[VAL] = 1.0;
		    hsv[SAT] -= d;
		    hsv[SAT] = hsv[SAT] >= 0.0 ? hsv[SAT] : 0.0;
		}

		/*
		 * Convert back to RGB.
		 */
		bu_hsv_to_rgb(hsv,rgb);

		if (replace_down) {
		    /*
		     * Write this pixel immediately, do not put it into
		     * the blendline since it corresponds to the wrong
		     * scanline.
		     */
		    bu_semaphore_acquire (BU_SEM_SYSCALL);
		    fb_write (fbp, i, ap->a_y, rgb, 1);
		    bu_semaphore_release (BU_SEM_SYSCALL);

		    replace_down = 0;
		} else {
		    /*
		     * Put this pixel back into the blendline array.
		     * We'll push it to the buffer when the entire
		     * scanline has been processed.
		     */
		    blendline[cpu][i*3+RED] = rgb[RED];
		    blendline[cpu][i*3+GRN] = rgb[GRN];
		    blendline[cpu][i*3+BLU] = rgb[BLU];
		}
	    } /* end "if this pixel is an edge" */
	} /* end pixel loop */

	/*
	 * Write the blendline to the framebuffer.
	 */
	bu_semaphore_acquire (BU_SEM_SYSCALL);
	fb_write (fbp, 0, ap->a_y, blendline[cpu], per_processor_chunk);
	bu_semaphore_release (BU_SEM_SYSCALL);
	return;
    } /* end blend */

    if( fbp != FBIO_NULL ) {
	/*
	 * Simple whole scanline write to a framebuffer.
	 */
	bu_semaphore_acquire (BU_SEM_SYSCALL);
	fb_write( fbp, 0, ap->a_y, scanline[cpu], per_processor_chunk );
	bu_semaphore_release (BU_SEM_SYSCALL);
    }
    if( outputfile != NULL ) {
	/*
	 * Write to a file.
	 */
	bu_semaphore_acquire (BU_SEM_SYSCALL);
	bu_image_save_writeline(bif,ap->a_y,scanline[cpu]);
	bu_semaphore_release (BU_SEM_SYSCALL);
    }
    if (fbp == FBIO_NULL && outputfile == NULL)
	bu_log ("rtedge: strange, no end of line actions taken.\n");

    return;

}

void view_setup(void) { }

/*
 * end of a frame, called after rt_clean()
 */
void view_cleanup(void) { }

/*
 * end of each frame
 */
void view_end(void) { 
    if(bif)
	bu_image_save_close(bif); 
    bif = NULL;
}

/*
 *			R A Y H I T
 */
int rayhit (struct application *ap, register struct partition *pt,
	    struct seg *segp )
{
    if ( handle_main_ray(ap, pt, segp))
	ap->a_user = 1;
    else
	ap->a_user = 0;
    return 1;
}

/*
 *			R A Y M I S S
 */
int raymiss( struct application *ap )
{
    if ( handle_main_ray(ap, NULL, NULL))
	ap->a_user = 1;
    else
	ap->a_user = 0;
    return 0;
}

/*
 *			R A Y H I T 2
 */
int rayhit2 (struct application *ap, register struct partition *pt,
	     struct seg *segp )
{
    struct partition	*pp = pt->pt_forw;
    struct hit		*hitp = pt->pt_forw->pt_inhit;
    struct cell 	*c = (struct cell *)ap->a_uptr;

    c->c_ishit 		= 1;
    c->c_region 	= pp->pt_regionp;
    c->c_id 		= pp->pt_regionp->reg_regionid;
    VMOVE(c->c_rdir, ap->a_ray.r_dir);
    VJOIN1(c->c_hit, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
    RT_HIT_NORMAL(c->c_normal, hitp,
		  pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);
    c->c_dist = hitp->hit_dist;

    return 1;
}

/*
 *			R A Y M I S S 2
 */
int raymiss2( register struct application *ap )
{
    struct cell *c = (struct cell *)ap->a_uptr;

    c->c_ishit    	= 0;
    c->c_region   	= 0;
    c->c_dist     	= MISS_DIST;
    c->c_id	    	= MISS_ID;
    VSETALL(c->c_hit, MISS_DIST);
    VSETALL(c->c_normal, 0);
    VMOVE(c->c_rdir, ap->a_ray.r_dir);

    return 0;
}

int is_edge(struct application *ap, struct cell *here,
	    struct cell *left, struct cell *below)
{
    if (here->c_ishit) {
	if (detect_ids) 
	    if (here->c_id != left->c_id || here->c_id != below->c_id) 
		return 1;

	if (detect_regions) 
	    if (here->c_region != left->c_region ||
		here->c_region != below->c_region ) 
		return 1;

	if (detect_distance) 
	    if (Abs(here->c_dist - left->c_dist) > max_dist ||
		Abs(here->c_dist - below->c_dist) > max_dist) 
		return 1;

	if (detect_normals) 
	    if ((VDOT(here->c_normal, left->c_normal) < COSTOL) ||
		(VDOT(here->c_normal, below->c_normal)< COSTOL)) 
		return 1;
    }
    else
	if (left->c_ishit || below->c_ishit)
	    return 1;
    return 0;
}

/*
 *			H A N D L E _ M A I N _ R A Y
 *
 */

int
handle_main_ray( struct application *ap, register struct partition *PartHeadp,
		 struct seg *segp )
{
    register struct partition *pp;
    register struct hit	*hitp;		/* which hit */

    struct application	a2;
    struct cell		me;
    struct cell		below;
    struct cell		left;
    int			edge = 0;
    int			cpu;
    int                     oc = 1;

    RGBpixel                      col;

    RT_APPLICATION_INIT(&a2);
    memset(&me, 0, sizeof(struct cell));
    memset(&below, 0, sizeof(struct cell));
    memset(&left, 0, sizeof(struct cell));

    cpu = ap->a_resource->re_cpu;

    if (PartHeadp == NULL) {
	/* The main shotline missed.
	 * pack the application struct
	 */
	me.c_ishit    = 0;
	me.c_dist   = MISS_DIST;
	me.c_id	    = MISS_ID;
	me.c_region = 0;
	VSETALL(me.c_hit, MISS_DIST);
	VSETALL(me.c_normal, 0);
	VMOVE(me.c_rdir, ap->a_ray.r_dir);
    } else {
	pp = PartHeadp->pt_forw;
	hitp = pp->pt_inhit;
	/*
	 * Stuff the information for this cell.
	 */
	me.c_ishit    = 1;
	me.c_id = pp->pt_regionp->reg_regionid;
	me.c_dist = hitp->hit_dist;
	me.c_region = pp->pt_regionp;
	VMOVE(me.c_rdir, ap->a_ray.r_dir);
	VJOIN1(me.c_hit, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
	RT_HIT_NORMAL(me.c_normal, hitp,
		      pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);
    }

    /*
     * Now, fire a ray for both the cell below and if necessary, the
     * cell to the left.
     */
    a2.a_hit = rayhit2;
    a2.a_miss = raymiss2;
    a2.a_onehit = 1;
    a2.a_rt_i = ap->a_rt_i;
    a2.a_resource = ap->a_resource;
    a2.a_logoverlap = ap->a_logoverlap;

    VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dy_model); /* below */
    VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
    a2.a_uptr = (genptr_t)&below;
    rt_shootray(&a2);

    if (ap->a_x == 0) {
	/*
	 * For the first pixel in a scanline, we have to shoot to the left.
	 * For each pixel afterword, we save the current cell info to be used
	 * as the left side cell info for the following pixel
	 */
	VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dx_model); /* left */
	VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
	a2.a_uptr = (genptr_t)&left;
	rt_shootray(&a2);
    } else {
	left.c_ishit    = saved[cpu]->c_ishit;
	left.c_id = saved[cpu]->c_id;
	left.c_dist = saved[cpu]->c_dist;
	left.c_region = saved[cpu]->c_region;
	VMOVE (left.c_rdir, saved[cpu]->c_rdir);
	VMOVE (left.c_hit, saved[cpu]->c_hit);
	VMOVE (left.c_normal, saved[cpu]->c_normal);
    }

    /*
     * Is this pixel an edge?
     */
    edge = is_edge (ap, &me, &left, &below);

    /*
     * Does this pixel occlude the second geometry?
     * Note that we must check on edges as well since right side and
     * top edges are actually misses.
     */
    if (occlusion_mode != OCCLUSION_MODE_NONE) 
	if (me.c_ishit || edge) 
	    oc = occludes (ap, &me);

    /*
     * Perverse Pixel Painting Paradigm(tm)
     * If a pixel should be written to the fb, writeable is set.
     */
    if (occlusion_mode == OCCLUSION_MODE_EDGES)
	writeable[cpu][ap->a_x] = (edge && oc) ;
    else if (occlusion_mode == OCCLUSION_MODE_HITS)
	writeable[cpu][ap->a_x] = ( (me.c_ishit || edge) && oc);
    else if (occlusion_mode == OCCLUSION_MODE_DITHER) {
	if (edge && oc)
	    writeable[cpu][ap->a_x] = 1;
	else if (me.c_ishit && oc) {
	    /*
	     * Dither mode.
	     *
	     * For occluding non-edges, only write every
	     * other pixel.
	     */
	    if (oc == 1 && ((ap->a_x + ap->a_y) % 2) == 0)
		writeable[cpu][ap->a_x] = 1;
	    else if (oc == 2)
		writeable[cpu][ap->a_x] = 1;
	    else
		writeable[cpu][ap->a_x] = 0;
	}
	else
	    writeable[cpu][ap->a_x] = 0;
    }
    else
	if (edge)
	    writeable[cpu][ap->a_x] = 1;
	else
	    writeable[cpu][ap->a_x] = 0;

    if (edge) {
	choose_color (col, &me, &left, &below);

	scanline[cpu][ap->a_x*3+RED] = col[RED];
	scanline[cpu][ap->a_x*3+GRN] = col[GRN];
	scanline[cpu][ap->a_x*3+BLU] = col[BLU];
    } else {
	scanline[cpu][ap->a_x*3+RED] = bgcolor[RED];
	scanline[cpu][ap->a_x*3+GRN] = bgcolor[GRN];
	scanline[cpu][ap->a_x*3+BLU] = bgcolor[BLU];
    }

    /*
     * Save the cell info for the next pixel.
     */
    saved[cpu]->c_ishit = me.c_ishit;
    saved[cpu]->c_id = me.c_id;
    saved[cpu]->c_dist = me.c_dist;
    saved[cpu]->c_region = me.c_region;
    VMOVE (saved[cpu]->c_rdir, me.c_rdir);
    VMOVE (saved[cpu]->c_hit, me.c_hit);
    VMOVE (saved[cpu]->c_normal, me.c_normal);

    return edge;
}

void application_init (void) {
    bu_vls_init(&occlusion_objects);
}


int diffpixel (RGBpixel a, RGBpixel b)
{
    if (a[RED] != b[RED]) return 1;
    if (a[GRN] != b[GRN]) return 1;
    if (a[BLU] != b[BLU]) return 1;
    return 0;
}

/*
 */
void choose_color (RGBpixel col, struct cell *me,
		   struct cell *left, struct cell *below)
{
    col[RED] = fgcolor[RED];
    col[GRN] = fgcolor[GRN];
    col[BLU] = fgcolor[BLU];

    if (region_colors) {

	struct cell *use_this = me;

	/*
	 * Determine the cell with the smallest hit distance.
	 */

	use_this = (me->c_dist < left->c_dist) ? me : left ;
	use_this = (use_this->c_dist < below->c_dist) ? use_this : below ;

	if (use_this == (struct cell *)NULL)
	    bu_exit (EXIT_FAILURE, "Error: use_this is NULL.\n");

	col[RED] = 255 * use_this->c_region->reg_mater.ma_color[RED];
	col[GRN] = 255 * use_this->c_region->reg_mater.ma_color[GRN];
	col[BLU] = 255 * use_this->c_region->reg_mater.ma_color[BLU];
    }
    return;
}

static int occlusion_hit (struct application *ap, struct partition *pt,
			  struct seg *segp)
{
    struct hit		*hitp = pt->pt_forw->pt_inhit;

    ap->a_dist = hitp->hit_dist;
    return 1;
}

static int occlusion_miss (struct application *ap)
{
    ap->a_dist = MAX_FASTF;
    return 0;
}


static int occludes (struct application *ap, struct cell *here)
{
    int cpu = ap->a_resource->re_cpu;
    int oc_hit = 0;
    /*
     * Test the hit distance on the second geometry.
     * If the second geometry is closer, do not
     * color pixel
     */
    VMOVE (occlusion_apps[cpu]->a_ray.r_pt, ap->a_ray.r_pt);
    VMOVE (occlusion_apps[cpu]->a_ray.r_dir, ap->a_ray.r_dir);


    oc_hit = rt_shootray (occlusion_apps[cpu]);

    if (!oc_hit)
	/*
	 * The occlusion ray missed, therefore this
	 * pixel occludes the second geometry.
	 *
	 * Return 2 so that the fact that there is no
	 * geometry behind can be conveyed to the
	 * OCCLUSION_MODE_DITHER section.
	 */
	return 2;

    if (occlusion_apps[cpu]->a_dist < here->c_dist)
	/*
	 * The second geometry is close than the edge, therefore it
	 * is 'foreground'. Do not draw the edge.
	 *
	 * - This pixel DOES NOT occlude the second geometry.
	 */
	return 0;
    return 1;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.32
log
@LOCAL->static, per machine.h deprecation list
@
text
@a35 4
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
a36 3
#ifndef lint
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.31 2007/11/21 16:18:53 erikgreenwald Exp $ (BRL)";
#endif
d778 7
a784 7
    static struct application	a2;
    static struct cell		me;
    static struct cell		below;
    static struct cell		left;
    static int			edge = 0;
    static int			cpu;
    static int                     oc = 1;
@


14.31
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.30 2007/11/15 18:01:02 erikgreenwald Exp $ (BRL)";
d785 7
a791 7
    LOCAL struct application	a2;
    LOCAL struct cell		me;
    LOCAL struct cell		below;
    LOCAL struct cell		left;
    LOCAL int			edge = 0;
    LOCAL int			cpu;
    LOCAL int                     oc = 1;
@


14.30
log
@allow users to set arbitrary distance threshholds
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.29 2007/11/15 17:52:19 erikgreenwald Exp $ (BRL)";
d48 1
d290 1
a290 1
	    bu_bomb ("rtedge: could not parse occlusion objects list.\n");
d299 1
a299 1
	    bu_bomb ("rtedge: could not open database.\n");
d366 1
a366 1
	bu_bomb ("rtedge: occlusion mode set, but no objects were specified.\n");
d444 1
a444 1
	    bu_bomb ("rt_edge: specified framebuffer is not readable, cannot merge.\n");
d528 1
a528 1
	    bu_bomb ("rtedge: error reading from framebuffer.\n");
d973 1
a973 1
	    bu_bomb ("Error: use_this is NULL.\n");
@


14.29
log
@minor clean-up
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.28 2007/10/22 00:58:40 brlcad Exp $ (BRL)";
d95 1
a95 1
fastf_t		max_dist; /* min. distance for drawing pits/mountains */
d229 1
d435 2
a436 1
    max_dist = (cell_width*ARCTAN_87)+2;
@


14.28
log
@oops, remove debugging
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.27 2007/10/22 00:30:27 brlcad Exp $ (BRL)";
a183 2
static int is_edge(struct application *, struct cell *, struct cell *,
		   struct cell *below);
a184 1
static int rayhit2 (struct application *, struct partition *, struct seg *);
a185 4
static int raymiss2 (struct application *);
static int handle_main_ray(struct application *, struct partition *,
			   struct seg *);
static int diffpixel (RGBpixel a, RGBpixel b);
d195 1
a195 1
#define Abs( x )        ((x) < 0 ? -(x) : (x))                  /* UNSAFE */
d296 1
a296 1
	if( (dbip = db_open( file, "r" )) == DBI_NULL ) {
a297 1
	}
d302 1
a302 2
	for( i=0; i < MAX_PSW; i++ )
	    {
d309 2
a310 2
	for (i=0; i<nObjs; ++i) {
	    if (rt_gettree (occlusion_rtip, objs[i]) < 0) {
d312 1
a312 2
	    }
	    else {
a313 2
	    }
	}
d338 1
a338 1
	    if (rpt_overlap) {
d340 1
a340 1
	    } else {
a341 1
	    }
d400 1
a400 1
    if (overlay) {
d402 1
a402 1
    } else if (blend) {
a403 1
    }
d405 1
a405 4
    if (minus_F || (!minus_o && !minus_F)) {
	return 1;		/* we need a framebuffer */
    }
    return 0;
a425 20
     * Create a cell to store current data for next cells left side.
     */
    for (i = 0; i < npsw; ++i) {
	if (saved[i] == NULL) {
	    saved[i] = (struct cell *) bu_calloc( 1, sizeof(struct cell),
						  "saved cell info" );
	}
    }

    /*
     * Create a edge flag buffer for each processor.
     */
    for ( i = 0; i < npsw; ++i ) {
	if (writeable[i] == NULL) {
	    writeable[i] = (unsigned char *) bu_calloc( 1, per_processor_chunk,
							"writeable pixel flag buffer" );
	}
    }

    /*
a430 10
     * Create a scanline buffer for each processor.
     */
    for ( i = 0; i < npsw; ++i ) {
	if (scanline[i] == NULL) {
	    scanline[i] = (unsigned char *) bu_calloc( per_processor_chunk,
						       pixsize, "scanline buffer" );
	}
    }

    /*
d439 2
a440 3
    if (overlay || blend) {

	if (fb_read(fbp,0,0,fb_bg_color,1) < 0) {
a442 3
	}
    }

d444 3
a446 2
     * If blending is desired, create scanline buffers to hold
     * the read-in lines from the framebuffer.
d448 13
a460 8
    if (blend) {
	for (i = 0; i < npsw; ++i) {
	    if (blendline[i] == NULL) {
		blendline[i] = (unsigned char *) bu_calloc( per_processor_chunk,
							    pixsize,
							    "blend buffer" );
	    }
	}
d470 1
a470 5
    if (overlay) {
	if (bgcolor[RED] == 0 &&
	    bgcolor[GRN] == 0 &&
	    bgcolor[BLU] == 1) {

a473 1
	}
d524 1
a524 1
	if (fb_read(fbp,0,ap->a_y,blendline[cpu],per_processor_chunk) < 0) {
a525 1
	}
d615 1
a615 2
		}
		else {
d653 1
a653 1
    if (fbp == FBIO_NULL && outputfile == NULL) {
a654 1
    }
d660 1
a660 1
void view_setup(void) {  }
d682 1
a682 1
    if ( handle_main_ray(ap, pt, segp)) {
d684 1
a684 1
    } else {
a685 1
    }
d694 1
a694 1
    if ( handle_main_ray(ap, NULL, NULL)) {
d696 1
a696 1
    } else {
a697 1
    }
d720 1
a720 1
    return(1);
d738 1
a738 1
    return(0);
d745 2
a746 3

	if (detect_ids) {
	    if (here->c_id != left->c_id || here->c_id != below->c_id) {
a747 2
	    }
	}
d749 1
a749 1
	if (detect_regions) {
d751 1
a751 1
		here->c_region != below->c_region ) {
a752 2
	    }
	}
d754 1
a754 1
	if (detect_distance) {
d756 1
a756 1
		Abs(here->c_dist - below->c_dist) > max_dist) {
a757 2
	    }
	}
d759 1
a759 1
	if (detect_normals) {
d761 1
a761 1
		(VDOT(here->c_normal, below->c_normal)< COSTOL)) {
a762 2
	    }
	}
d764 2
a765 2
    else {
	if (left->c_ishit || below->c_ishit) {
a766 3
	}
    }

a769 1

d852 1
a852 2
    }
    else {
d872 2
a873 2
    if (occlusion_mode != OCCLUSION_MODE_NONE) {
	if (me.c_ishit || edge) {
a874 2
	}
    }
d880 4
a883 17
    if (occlusion_mode == OCCLUSION_MODE_EDGES) {

	if (edge && oc) {
	    writeable[cpu][ap->a_x] = 1;
	} else {
	    writeable[cpu][ap->a_x] = 0;
	}
    }
    else if (occlusion_mode == OCCLUSION_MODE_HITS) {

	if ( (me.c_ishit || edge) && oc) {
	    writeable[cpu][ap->a_x] = 1;
	}
	else {
	    writeable[cpu][ap->a_x] = 0;
	}
    }
d885 1
a885 2

	if (edge && oc) {
a886 1
	}
d894 1
a894 1
	    if (oc == 1 && ((ap->a_x + ap->a_y) % 2) == 0) {
d896 1
a896 2
	    }
	    else if (oc == 2) {
d898 1
a898 2
	    }
	    else {
a899 1
	    }
d901 1
a901 1
	else {
a902 1
	}
d904 2
a905 2
    else {
	if (edge) {
d907 1
a907 1
	} else {
a908 2
	}
    }
a910 1

a915 1

a916 1

d969 1
a969 1
	if (use_this == (struct cell *)NULL) {
a970 1
	}
a974 1

d1010 1
a1010 1
    if (!oc_hit) {
a1019 1
    }
d1021 1
a1021 1
    if (occlusion_apps[cpu]->a_dist < here->c_dist) {
a1028 1
    }
@


14.27
log
@ws expand for readability
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.26 2007/04/17 03:23:57 brlcad Exp $ (BRL)";
a697 1
	bu_log("SHOULD NOT BE GETTING HERE\n");
@


14.26
log
@redo the client-side version reporting to use the new brlcad_version() interface, utilizing a per-binary title as needed, instead of the former vers.sh setup.
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.25 2007/04/13 18:55:00 erikgreenwald Exp $ (BRL)";
d698 1
d724 5
a728 1
void view_end(void) { if(bif)bu_image_save_close(bif); bif = NULL; }
@


14.25
log
@move the bif close from view_clewnup to view_end (so it actually gets called *cough*)
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.24 2007/04/13 17:07:43 erikgreenwald Exp $ (BRL)";
d240 3
a242 1
char usage[] = "\
d260 2
a261 1
 -c                 Auxillary commands (see man page)\n";
@


14.24
log
@First victim of the libu image stuff.
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.23 2007/03/15 18:55:04 erikgreenwald Exp $ (BRL)";
d715 1
a715 1
void view_cleanup(void) { if(bif)bu_image_save_close(bif); bif = NULL; }
d720 1
a720 1
void view_end(void) { }
@


14.23
log
@"po' boy" spinlock to avoid scanlines being written out of order (race condition). Fixes PR 1657171.
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.22 2007/01/27 01:41:45 brlcad Exp $ (BRL)";
d173 1
a173 1
static int lastlinedone;
d428 3
d694 1
a694 1
    if( outfp != NULL ) {
a697 4

	/* if it's not our turn, surrender and spin */
	while(lastlinedone != (ap->a_y-1))
	    sleep(0);
d699 1
a699 2
	fwrite( scanline[cpu], pixsize, per_processor_chunk, outfp );
	lastlinedone = ap->a_y;	/* mark that we've seen this line, so the next can proceed */
d702 1
a702 1
    if (fbp == FBIO_NULL && outfp == NULL) {
d710 1
a710 1
void view_setup(void) { lastlinedone = -1; }
d715 1
a715 1
void view_cleanup(void) { }
@


14.22
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.21 2007/01/23 01:13:46 brlcad Exp $ (BRL)";
d173 2
d695 4
d701 1
d712 1
a712 1
void view_setup(void) { }
@


14.21
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.20 2007/01/20 14:37:00 brlcad Exp $ (BRL)";
a1079 1

@


14.20
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d42 1
a42 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.19 2006/01/18 06:46:24 brlcad Exp $ (BRL)";
@


14.19
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006 United States Government as represented by
d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.18 2005/12/14 02:29:27 brlcad Exp $ (BRL)";
@


14.18
log
@the rewrite to allow output to both a file and a framebuffer simultaneously overlooked the else that attempted to test neither file nor framebuffer.  fix output blather of 'strange, no end of line actions taken'
@
text
@d4 1
a4 1
 * Copyright (C) 2001-2005 United States Government as represented by
d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.17 2005/12/08 01:54:43 brlcad Exp $ (BRL)";
@


14.17
log
@RT_APPLICATION_INIT; ws
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.16 2005/10/23 04:44:38 brlcad Exp $ (BRL)";
d698 1
a698 1
    else {
@


14.16
log
@trailing ws
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.15 2005/09/19 17:59:00 brlcad Exp $ (BRL)";
d76 7
a82 7
        int		c_ishit;
	struct region *	c_region;
	fastf_t		c_dist;		/* distance from emanation plane to in_hit */
	int		c_id;		/* region_id of component hit */
	point_t		c_hit;		/* 3-space hit point of ray */
	vect_t		c_normal;	/* surface normal at the hit point */
	vect_t		c_rdir;		/* ray direction, permits perspective */
d184 1
a184 1
	struct cell *below);
d207 1
a207 1
/*XXX need to investigate why this doesn't work on Windows */
d209 26
a234 26
  {"%d", 1, "detect_regions", bu_byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dr", bu_byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_distance", bu_byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dd", bu_byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_normals", bu_byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dn", bu_byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_ids", bu_byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "di", bu_byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "foreground", bu_byteoffset(fgcolor), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "fg", bu_byteoffset(fgcolor), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "background", bu_byteoffset(bgcolor), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "bg", bu_byteoffset(bgcolor), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "overlay", bu_byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "ov", bu_byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "blend", bu_byteoffset(blend), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "bl", bu_byteoffset(blend), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "region_color", bu_byteoffset(region_colors),
   BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "rc", bu_byteoffset(region_colors), BU_STRUCTPARSE_FUNC_NULL},
  {"%S", 1, "occlusion_objects", bu_byteoffset(occlusion_objects),
   BU_STRUCTPARSE_FUNC_NULL},
  {"%S", 1, "oo", bu_byteoffset(occlusion_objects),
   BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "occlusion_mode", bu_byteoffset(occlusion_mode),
   BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "om", bu_byteoffset(occlusion_mode), BU_STRUCTPARSE_FUNC_NULL},
d236 1
a236 1
  {"",	0, (char *)0,	0,	BU_STRUCTPARSE_FUNC_NULL }
d267 59
a325 17
  /*
   *  Allocate a scanline for each processor.
   */
  ap->a_hit = rayhit;
  ap->a_miss = raymiss;
  ap->a_onehit = 1;

  /*
   * Does the user want occlusion checking?
   *
   * If so, load and prep.
   */
  if (bu_vls_strlen(&occlusion_objects) != 0) {
    struct db_i *dbip;
    int nObjs;
    const char **objs;
    int i;
d327 1
a327 1
    bu_log ("rtedge: loading occlusion geometry from %s.\n", file);
d329 22
a350 6
    if (Tcl_SplitList (NULL, bu_vls_addr (&occlusion_objects), &nObjs,
		       &objs) == TCL_ERROR) {
      bu_log  ("rtedge: occlusion list = %s\n",
	       bu_vls_addr(&occlusion_objects));
      bu_bomb ("rtedge: could not parse occlusion objects list.\n");
    }
d352 2
a353 3
    for (i=0; i<nObjs; ++i) {
      bu_log ("rtedge: occlusion object %d = %s\n", i, objs[i]);
    }
d355 13
a368 2
    if( (dbip = db_open( file, "r" )) == DBI_NULL ) {
      bu_bomb ("rtedge: could not open database.\n");
a369 1
    RT_CK_DBI(dbip);
d371 4
a374 1
    occlusion_rtip = rt_new_rti( dbip ); /* clones dbip */
d376 15
a390 5
    for( i=0; i < MAX_PSW; i++ )
      {
	rt_init_resource( &occlusion_resources[i], i, occlusion_rtip );
	bn_rand_init( occlusion_resources[i].re_randptr, i );
      }
d392 16
a407 1
    db_close(dbip);			 /* releases original dbip */
d409 4
a412 7
    for (i=0; i<nObjs; ++i) {
      if (rt_gettree (occlusion_rtip, objs[i]) < 0) {
	bu_log ("rtedge: gettree failed for %s\n", objs[i]);
      }
      else {
	bu_log ("rtedge: got tree for object %d = %s\n", i, objs[i]);
      }
d415 5
a419 1
    bu_log ("rtedge: occlusion rt_gettrees done.\n");
d421 5
a425 1
    rt_prep (occlusion_rtip);
d427 7
a433 1
    bu_log ("rtedge: occlustion prep done.\n");
d436 1
a436 3
     * Create a set of application structures for the occlusion
     * geometry. Need one per cpu, the upper half does the per-
     * thread allocation in worker, but that's off limits.
d438 6
a443 16
    occlusion_apps = bu_calloc (npsw, sizeof(struct application *),
			    "occlusion application structure array");
    for (i=0; i<npsw; ++i) {
      occlusion_apps[i] = bu_calloc (1, sizeof(struct application),
				 "occlusion_application structure");

      occlusion_apps[i]->a_rt_i = occlusion_rtip;
      occlusion_apps[i]->a_resource = (struct resource *)BU_PTBL_GET( &occlusion_rtip->rti_resources, i );
      occlusion_apps[i]->a_onehit = 1;
      occlusion_apps[i]->a_hit = occlusion_hit;
      occlusion_apps[i]->a_miss = occlusion_miss;
      if (rpt_overlap) {
	      occlusion_apps[i]->a_logoverlap = ((void (*)())0);
      } else {
	      occlusion_apps[i]->a_logoverlap = rt_silent_logoverlap;
      }
d445 8
a453 1
    bu_log ("rtedge: will perform occlusion testing.\n");
d456 6
a461 1
     * If an inclusion mode has not been specified, use the default.
d463 6
a468 33
    if (occlusion_mode == OCCLUSION_MODE_NONE) {
      occlusion_mode = OCCLUSION_MODE_DEFAULT;
      bu_log ("rtedge: occlusion mode = %d\n", occlusion_mode);
    }

    if ((occlusion_mode != OCCLUSION_MODE_NONE) &&
	(overlay == OVERLAY_MODE_UNSET)) {
      bu_log ("rtedge: automagically activating overlay mode.\n");
      overlay = OVERLAY_MODE_DOIT;
    }

  }

  if (occlusion_mode != OCCLUSION_MODE_NONE &&
      bu_vls_strlen(&occlusion_objects) == 0) {
    bu_bomb ("rtedge: occlusion mode set, but no objects were specified.\n");
  }

  /* if non-default/inverted background was requested, swap the
   * foreground and background colors.
   */
  if (!default_background) {
      color tmp;
      tmp[RED] = fgcolor[RED];
      tmp[GRN] = fgcolor[GRN];
      tmp[BLU] = fgcolor[BLU];
      fgcolor[RED] = bgcolor[RED];
      fgcolor[GRN] = bgcolor[GRN];
      fgcolor[BLU] = bgcolor[BLU];
      bgcolor[RED] = tmp[RED];
      bgcolor[GRN] = tmp[GRN];
      bgcolor[BLU] = tmp[BLU];
  }
a469 1
  if( minus_o && (overlay || blend)) {
d471 2
a472 2
     * Output is to a file stream.  Do not allow parallel processing
     * since we can't seek to the rows.
d474 2
a475 2
    rt_g.rtg_parallel = 0;
    bu_log ("view_init: deactivating parallelism due to -o option.\n");
d477 1
a477 3
     * The overlay and blend cannot be used in -o mode.
     * Note that the overlay directive takes precendence, they
     * can't be used together.
d479 7
a485 16
    overlay = 0;
    blend = 0;
    bu_log ("view_init: deactivating overlay and blending due to -o option.\n");
  }

  if (overlay) {
    bu_log ("view_init: will perform simple overlay.\n");
  } else if (blend) {
    bu_log ("view_init: will perform blending.\n");
  }

  if (minus_F || (!minus_o && !minus_F)) {
      return 1;		/* we need a framebuffer */
  }
  return 0;
}
d487 13
a499 5
/* beginning of a frame */
void
view_2init( struct application *ap )
{
  int i;
d501 16
a516 89
  /*
   * Per_processor_chuck specifies the number of pixels rendered
   * per each pass of a worker. By making this value equal to the
   * width of the image, each worker will render one scanline at
   * a time.
   */
  per_processor_chunk = width;

  /*
   * Create a cell to store current data for next cells left side.
   */
  for (i = 0; i < npsw; ++i) {
    if (saved[i] == NULL) {
      saved[i] = (struct cell *) bu_calloc( 1, sizeof(struct cell),
					      "saved cell info" );
    }
  }

  /*
   * Create a edge flag buffer for each processor.
   */
  for ( i = 0; i < npsw; ++i ) {
    if (writeable[i] == NULL) {
      writeable[i] = (unsigned char *) bu_calloc( 1, per_processor_chunk,
					      "writeable pixel flag buffer" );
    }
  }

  /*
   * Use three bytes per pixel.
   */
  pixsize = 3;

  /*
   * Create a scanline buffer for each processor.
   */
  for ( i = 0; i < npsw; ++i ) {
    if (scanline[i] == NULL) {
      scanline[i] = (unsigned char *) bu_calloc( per_processor_chunk,
						 pixsize, "scanline buffer" );
    }
  }

  /*
   * Set the hit distance difference necessary to trigger an edge.
   * This algorythm was stolen from lgt, I may make it settable later.
   */
  max_dist = (cell_width*ARCTAN_87)+2;

  /*
   * Determine if the framebuffer is readable.
   */
  if (overlay || blend) {

    if (fb_read(fbp,0,0,fb_bg_color,1) < 0) {
      bu_bomb ("rt_edge: specified framebuffer is not readable, cannot merge.\n");

    }
  }

  /*
   * If blending is desired, create scanline buffers to hold
   * the read-in lines from the framebuffer.
   */
  if (blend) {
    for (i = 0; i < npsw; ++i) {
      if (blendline[i] == NULL) {
	blendline[i] = (unsigned char *) bu_calloc( per_processor_chunk,
						    pixsize,
						    "blend buffer" );
      }
    }
  }

  /*
   * If operating in overlay mode, we want the rtedge background color
   * to be the shaded images background. This sets the bg color
   * automatically, but assumes that pixel 0,0 is background. If not,
   * the user can set it manually (so long as it isn't 0 0 1!).
   *
   */
  if (overlay) {
    if (bgcolor[RED] == 0 &&
	bgcolor[GRN] == 0 &&
	bgcolor[BLU] == 1) {

      bgcolor[RED] = fb_bg_color[RED];
      bgcolor[GRN] = fb_bg_color[GRN];
      bgcolor[BLU] = fb_bg_color[BLU];
d518 1
a518 2
  }
  return;
d532 2
a533 2
  int cpu = ap->a_resource->re_cpu;
  int i;
d535 1
a535 7
  if (overlay) {
    /*
     * Overlay mode. Check if the pixel is an edge.
     * If so, write it to the framebuffer.
     */
    for (i = 0; i < per_processor_chunk; ++i) {
      if (writeable[cpu][i]) {
d537 2
a538 1
	 * Write this pixel
d540 11
a550 4
	bu_semaphore_acquire (BU_SEM_SYSCALL);
	fb_write(fbp, i, ap->a_y, &scanline[cpu][i*3], 1);
	bu_semaphore_release (BU_SEM_SYSCALL);
      }
d552 1
a552 28
    return;
  }
  else if (blend) {
    /*
     * Blend mode.
     *
     * Read a line from the existing framebuffer,
     * convert to HSV, manipulate, and put the results
     * in the scanline as RGB.
     */
    int replace_down = 0; /* flag that specifies if the pixel in the
			   * scanline below must be replaced.
			   */
    RGBpixel rgb;
    fastf_t hsv[3];

    bu_semaphore_acquire (BU_SEM_SYSCALL);
    if (fb_read(fbp,0,ap->a_y,blendline[cpu],per_processor_chunk) < 0) {
      bu_bomb ("rtedge: error reading from framebuffer.\n");
    }
    bu_semaphore_release (BU_SEM_SYSCALL);

    for (i=0; i<per_processor_chunk; ++i) {
      /*
       * Is this pixel an edge?
       */
      if (writeable[cpu][i]) {

d554 5
a558 2
	 * The pixel is an edge, retrieve the appropriate
	 * pixel from the line buffer and convert it to HSV.
d560 5
a564 3
	rgb[RED] = blendline[cpu][i*3+RED];
	rgb[GRN] = blendline[cpu][i*3+GRN];
	rgb[BLU] = blendline[cpu][i*3+BLU];
d566 5
a570 18
	/*
	 * Is the pixel in the blendline array the
	 * background color? If so, look left and down
	 * to determine which pixel is the "source" of the
	 * edge. Unless, of course, we are on the bottom
	 * scanline or the leftmost column (x=y=0)
	 */
	if (i != 0 && ap->a_y != 0 && !diffpixel (rgb,fb_bg_color)) {
	  RGBpixel left;
	  RGBpixel down;

	  left[RED] = blendline[cpu][(i-1)*3+RED];
	  left[GRN] = blendline[cpu][(i-1)*3+GRN];
	  left[BLU] = blendline[cpu][(i-1)*3+BLU];

	  bu_semaphore_acquire (BU_SEM_SYSCALL);
	  fb_read (fbp, i, ap->a_y - 1, down, 1);
	  bu_semaphore_release (BU_SEM_SYSCALL);
d572 1
a572 1
	  if (diffpixel (left, fb_bg_color)) {
d574 1
a574 1
	     * Use this one.
d576 96
a671 9
	    rgb[RED] = left[RED];
	    rgb[GRN] = left[GRN];
	    rgb[BLU] = left[BLU];
	  }
	  else if (diffpixel (down, fb_bg_color)) {
	    /*
	     * Use the pixel from the scanline below
	     */
	    replace_down = 1;
a672 5
	    rgb[RED] = down[RED];
	    rgb[GRN] = down[GRN];
	    rgb[BLU] = down[BLU];
	  }
	}
d674 1
a674 1
	 * Convert to HSV
d676 5
a680 1
	bu_rgb_to_hsv (rgb, hsv);
d682 1
d684 1
a684 1
	 * Now perform the manipulations.
d686 5
a690 11
	hsv[VAL] *= 3.0;
	hsv[SAT] /= 3.0;

	if (hsv[VAL] > 1.0) {
	  fastf_t d = hsv[VAL] - 1.0;

	  hsv[VAL] = 1.0;
	  hsv[SAT] -= d;
	  hsv[SAT] = hsv[SAT] >= 0.0 ? hsv[SAT] : 0.0;
	}

d692 1
a692 1
	 * Convert back to RGB.
d694 7
a700 1
	bu_hsv_to_rgb(hsv,rgb);
a701 31
	if (replace_down) {
	  /*
	   * Write this pixel immediately, do not put it into
	   * the blendline since it corresponds to the wrong
	   * scanline.
	   */
	  bu_semaphore_acquire (BU_SEM_SYSCALL);
	  fb_write (fbp, i, ap->a_y, rgb, 1);
	  bu_semaphore_release (BU_SEM_SYSCALL);

	  replace_down = 0;
	}
	else {
	  /*
	   * Put this pixel back into the blendline array.
	   * We'll push it to the buffer when the entire
	   * scanline has been processed.
	   */
	  blendline[cpu][i*3+RED] = rgb[RED];
	  blendline[cpu][i*3+GRN] = rgb[GRN];
	  blendline[cpu][i*3+BLU] = rgb[BLU];
	}
      } /* end "if this pixel is an edge" */
    } /* end pixel loop */

    /*
     * Write the blendline to the framebuffer.
     */
    bu_semaphore_acquire (BU_SEM_SYSCALL);
    fb_write (fbp, 0, ap->a_y, blendline[cpu], per_processor_chunk);
    bu_semaphore_release (BU_SEM_SYSCALL);
a702 23
  } /* end blend */

  if( fbp != FBIO_NULL ) {
    /*
     * Simple whole scanline write to a framebuffer.
     */
    bu_semaphore_acquire (BU_SEM_SYSCALL);
    fb_write( fbp, 0, ap->a_y, scanline[cpu], per_processor_chunk );
    bu_semaphore_release (BU_SEM_SYSCALL);
  }
  if( outfp != NULL ) {
    /*
     * Write to a file.
     */
    bu_semaphore_acquire (BU_SEM_SYSCALL);
    fwrite( scanline[cpu], pixsize, per_processor_chunk, outfp );
    bu_semaphore_release (BU_SEM_SYSCALL);
  }
  else {
    bu_log ("rtedge: strange, no end of line actions taken.\n");
  }

  return;
d722 1
a722 1
	struct seg *segp )
d749 1
a749 1
	struct seg *segp )
d761 1
a761 1
	pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);
d788 1
a788 1
  if (here->c_ishit) {
d790 5
a794 5
    if (detect_ids) {
      if (here->c_id != left->c_id || here->c_id != below->c_id) {
	return 1;
      }
    }
d796 6
a801 6
    if (detect_regions) {
      if (here->c_region != left->c_region ||
	  here->c_region != below->c_region ) {
	return 1;
      }
    }
d803 6
a808 6
    if (detect_distance) {
      if (Abs(here->c_dist - left->c_dist) > max_dist ||
	  Abs(here->c_dist - below->c_dist) > max_dist) {
	return 1;
      }
    }
d810 6
a815 5
    if (detect_normals) {
      if ((VDOT(here->c_normal, left->c_normal) < COSTOL) ||
	  (VDOT(here->c_normal, below->c_normal)< COSTOL)) {
	return 1;
      }
d817 4
a820 4
  }
  else {
    if (left->c_ishit || below->c_ishit) {
      return 1;
a821 1
  }
d823 1
a823 1
  return 0;
d836 2
a837 2
  register struct partition *pp;
  register struct hit	*hitp;		/* which hit */
d839 47
a885 20
  LOCAL struct application	a2;
  LOCAL struct cell		me;
  LOCAL struct cell		below;
  LOCAL struct cell		left;
  LOCAL int			edge = 0;
  LOCAL int			cpu;
  LOCAL int                     oc = 1;

  RGBpixel                      col;

  memset(&a2, 0, sizeof(struct application));
  memset(&me, 0, sizeof(struct cell));
  memset(&below, 0, sizeof(struct cell));
  memset(&left, 0, sizeof(struct cell));

  cpu = ap->a_resource->re_cpu;

  if (PartHeadp == NULL) {
    /* The main shotline missed.
     * pack the application struct
d887 33
a919 10
    me.c_ishit    = 0;
    me.c_dist   = MISS_DIST;
    me.c_id	    = MISS_ID;
    me.c_region = 0;
    VSETALL(me.c_hit, MISS_DIST);
    VSETALL(me.c_normal, 0);
    VMOVE(me.c_rdir, ap->a_ray.r_dir);
  } else {
    pp = PartHeadp->pt_forw;
    hitp = pp->pt_inhit;
d921 1
a921 1
     * Stuff the information for this cell.
d923 1
a923 9
    me.c_ishit    = 1;
    me.c_id = pp->pt_regionp->reg_regionid;
    me.c_dist = hitp->hit_dist;
    me.c_region = pp->pt_regionp;
    VMOVE(me.c_rdir, ap->a_ray.r_dir);
    VJOIN1(me.c_hit, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
    RT_HIT_NORMAL(me.c_normal, hitp,
		  pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);
  }
d925 10
a934 15
  /*
   * Now, fire a ray for both the cell below and if necessary, the
   * cell to the left.
   */
  a2.a_hit = rayhit2;
  a2.a_miss = raymiss2;
  a2.a_onehit = 1;
  a2.a_rt_i = ap->a_rt_i;
  a2.a_resource = ap->a_resource;
  a2.a_logoverlap = ap->a_logoverlap;

  VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dy_model); /* below */
  VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
  a2.a_uptr = (genptr_t)&below;
  rt_shootray(&a2);
a935 1
  if (ap->a_x == 0) {
d937 2
a938 3
     * For the first pixel in a scanline, we have to shoot to the left.
     * For each pixel afterword, we save the current cell info to be used
     * as the left side cell info for the following pixel
d940 1
a940 36
    VSUB2(a2.a_ray.r_pt, ap->a_ray.r_pt, dx_model); /* left */
    VMOVE(a2.a_ray.r_dir, ap->a_ray.r_dir);
    a2.a_uptr = (genptr_t)&left;
    rt_shootray(&a2);
  }
  else {
    left.c_ishit    = saved[cpu]->c_ishit;
    left.c_id = saved[cpu]->c_id;
    left.c_dist = saved[cpu]->c_dist;
    left.c_region = saved[cpu]->c_region;
    VMOVE (left.c_rdir, saved[cpu]->c_rdir);
    VMOVE (left.c_hit, saved[cpu]->c_hit);
    VMOVE (left.c_normal, saved[cpu]->c_normal);
  }

  /*
   * Is this pixel an edge?
   */
  edge = is_edge (ap, &me, &left, &below);

  /*
   * Does this pixel occlude the second geometry?
   * Note that we must check on edges as well since right side and
   * top edges are actually misses.
   */
  if (occlusion_mode != OCCLUSION_MODE_NONE) {
    if (me.c_ishit || edge) {
      oc = occludes (ap, &me);
    }
  }

  /*
   * Perverse Pixel Painting Paradigm(tm)
   * If a pixel should be written to the fb, writeable is set.
   */
  if (occlusion_mode == OCCLUSION_MODE_EDGES) {
d942 5
a946 4
    if (edge && oc) {
      writeable[cpu][ap->a_x] = 1;
    } else {
      writeable[cpu][ap->a_x] = 0;
d948 1
a948 2
  }
  else if (occlusion_mode == OCCLUSION_MODE_HITS) {
d950 6
a955 2
    if ( (me.c_ishit || edge) && oc) {
      writeable[cpu][ap->a_x] = 1;
d957 1
a957 5
    else {
      writeable[cpu][ap->a_x] = 0;
    }
  }
  else if (occlusion_mode == OCCLUSION_MODE_DITHER) {
d959 23
a981 19
    if (edge && oc) {
      writeable[cpu][ap->a_x] = 1;
    }
    else if (me.c_ishit && oc) {
      /*
       * Dither mode.
       *
       * For occluding non-edges, only write every
       * other pixel.
       */
      if (oc == 1 && ((ap->a_x + ap->a_y) % 2) == 0) {
	writeable[cpu][ap->a_x] = 1;
      }
      else if (oc == 2) {
	writeable[cpu][ap->a_x] = 1;
      }
      else {
	writeable[cpu][ap->a_x] = 0;
      }
d984 5
a988 1
      writeable[cpu][ap->a_x] = 0;
d990 1
a990 2
  }
  else {
a991 5
      writeable[cpu][ap->a_x] = 1;
    } else {
      writeable[cpu][ap->a_x] = 0;
    }
  }
d993 1
a993 1
  if (edge) {
d995 3
a997 1
    choose_color (col, &me, &left, &below);
d999 1
a999 3
    scanline[cpu][ap->a_x*3+RED] = col[RED];
    scanline[cpu][ap->a_x*3+GRN] = col[GRN];
    scanline[cpu][ap->a_x*3+BLU] = col[BLU];
d1001 4
a1004 1
  } else {
d1006 10
a1015 4
    scanline[cpu][ap->a_x*3+RED] = bgcolor[RED];
    scanline[cpu][ap->a_x*3+GRN] = bgcolor[GRN];
    scanline[cpu][ap->a_x*3+BLU] = bgcolor[BLU];
  }
d1017 1
a1017 12
  /*
   * Save the cell info for the next pixel.
   */
  saved[cpu]->c_ishit = me.c_ishit;
  saved[cpu]->c_id = me.c_id;
  saved[cpu]->c_dist = me.c_dist;
  saved[cpu]->c_region = me.c_region;
  VMOVE (saved[cpu]->c_rdir, me.c_rdir);
  VMOVE (saved[cpu]->c_hit, me.c_hit);
  VMOVE (saved[cpu]->c_normal, me.c_normal);

  return edge;
d1021 1
a1021 1
  bu_vls_init(&occlusion_objects);
d1027 4
a1030 4
  if (a[RED] != b[RED]) return 1;
  if (a[GRN] != b[GRN]) return 1;
  if (a[BLU] != b[BLU]) return 1;
  return 0;
d1036 1
a1036 1
		  struct cell *left, struct cell *below)
d1038 3
a1040 3
  col[RED] = fgcolor[RED];
  col[GRN] = fgcolor[GRN];
  col[BLU] = fgcolor[BLU];
d1042 1
a1042 1
  if (region_colors) {
d1044 1
a1044 1
    struct cell *use_this = me;
d1046 3
a1048 3
    /*
     * Determine the cell with the smallest hit distance.
     */
d1050 2
a1051 2
    use_this = (me->c_dist < left->c_dist) ? me : left ;
    use_this = (use_this->c_dist < below->c_dist) ? use_this : below ;
d1053 3
a1055 3
    if (use_this == (struct cell *)NULL) {
      bu_bomb ("Error: use_this is NULL.\n");
    }
d1057 3
a1059 3
    col[RED] = 255 * use_this->c_region->reg_mater.ma_color[RED];
    col[GRN] = 255 * use_this->c_region->reg_mater.ma_color[GRN];
    col[BLU] = 255 * use_this->c_region->reg_mater.ma_color[BLU];
d1061 2
a1062 2
  }
  return;
d1066 1
a1066 1
		      struct seg *segp)
d1068 1
a1068 1
  struct hit		*hitp = pt->pt_forw->pt_inhit;
d1070 2
a1071 2
  ap->a_dist = hitp->hit_dist;
  return 1;
d1076 2
a1077 2
  ap->a_dist = MAX_FASTF;
  return 0;
d1084 9
a1092 9
  int cpu = ap->a_resource->re_cpu;
  int oc_hit = 0;
  /*
   * Test the hit distance on the second geometry.
   * If the second geometry is closer, do not
   * color pixel
   */
  VMOVE (occlusion_apps[cpu]->a_ray.r_pt, ap->a_ray.r_pt);
  VMOVE (occlusion_apps[cpu]->a_ray.r_dir, ap->a_ray.r_dir);
d1095 1
a1095 1
  oc_hit = rt_shootray (occlusion_apps[cpu]);
d1097 11
a1107 11
  if (!oc_hit) {
    /*
     * The occlusion ray missed, therefore this
     * pixel occludes the second geometry.
     *
     * Return 2 so that the fact that there is no
     * geometry behind can be conveyed to the
     * OCCLUSION_MODE_DITHER section.
     */
    return 2;
  }
d1109 10
a1118 10
  if (occlusion_apps[cpu]->a_dist < here->c_dist) {
    /*
     * The second geometry is close than the edge, therefore it
     * is 'foreground'. Do not draw the edge.
     *
     * - This pixel DOES NOT occlude the second geometry.
     */
    return 0;
  }
  return 1;
@


14.15
log
@remove stale comment
@
text
@d31 1
a31 1
 *  
d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.14 2005/07/16 23:22:10 brlcad Exp $ (BRL)";
d98 1
a98 1
			   * surface normals that triggers shading 
d135 1
a135 1
 * 
d137 1
a137 1
 * pixels are blended (using some HSV manipulations) with the 
d147 1
a147 1
 * 
d149 1
a149 1
 * If the edge is determined because of a change from one region 
d174 1
a174 1
static int occlusion_hit (struct application *, 
d189 1
a189 1
static int handle_main_ray(struct application *, struct partition *, 
d220 1
a220 1
  {"%d", 3, "bg", bu_byteoffset(bgcolor), BU_STRUCTPARSE_FUNC_NULL},	
d225 1
a225 1
  {"%d", 1, "region_color", bu_byteoffset(region_colors), 
d228 1
a228 1
  {"%S", 1, "occlusion_objects", bu_byteoffset(occlusion_objects), 
d230 1
a230 1
  {"%S", 1, "oo", bu_byteoffset(occlusion_objects), 
d232 1
a232 1
  {"%d", 1, "occlusion_mode", bu_byteoffset(occlusion_mode), 
d258 1
a258 1
 
d276 1
a276 1
   * 
d287 1
a287 1
    if (Tcl_SplitList (NULL, bu_vls_addr (&occlusion_objects), &nObjs, 
d289 1
a289 1
      bu_log  ("rtedge: occlusion list = %s\n", 
d297 1
a297 1
    
d306 1
a306 1
    for( i=0; i < MAX_PSW; i++ )  
d334 1
a334 1
    occlusion_apps = bu_calloc (npsw, sizeof(struct application *), 
d337 1
a337 1
      occlusion_apps[i] = bu_calloc (1, sizeof(struct application), 
d351 1
a351 1
    }    		       
d362 1
a362 1
    if ((occlusion_mode != OCCLUSION_MODE_NONE) && 
d369 1
a369 1
 
d408 1
a408 1
  if (overlay) {      
d413 1
a413 1
  
d439 1
a439 1
      saved[i] = (struct cell *) bu_calloc( 1, sizeof(struct cell), 
d441 1
a441 1
    }	
d449 1
a449 1
      writeable[i] = (unsigned char *) bu_calloc( 1, per_processor_chunk, 
d451 1
a451 1
    }	
d458 1
a458 1
  
d464 1
a464 1
      scanline[i] = (unsigned char *) bu_calloc( per_processor_chunk, 
d466 1
a466 1
    }	
d468 1
a468 1
  
d474 1
a474 1
  
d479 1
a479 1
    
d482 1
a482 1
      
d493 2
a494 2
	blendline[i] = (unsigned char *) bu_calloc( per_processor_chunk, 
						    pixsize, 
d496 1
a496 1
      }	
d499 1
a499 1
 
d501 2
a502 2
   * If operating in overlay mode, we want the rtedge background color 
   * to be the shaded images background. This sets the bg color 
d508 1
a508 1
    if (bgcolor[RED] == 0 && 
d511 1
a511 1
      
d545 1
a545 1
	fb_write(fbp, i, ap->a_y, &scanline[cpu][i*3], 1);	  
d564 1
a564 1
    
d570 1
a570 1
    
d589 1
a589 1
	 * edge. Unless, of course, we are on the bottom 
d595 1
a595 1
	  
d601 1
a601 1
	  fb_read (fbp, i, ap->a_y - 1, down, 1);	  
d605 1
a605 1
	    /* 
d627 1
a627 1
      
d636 1
a636 1
	  
d646 1
a646 1
	
d648 2
a649 2
	  /* 
	   * Write this pixel immediately, do not put it into 
d658 1
a658 1
	} 
d660 1
a660 1
	  /* 
d672 1
a672 1
    /* 
d676 1
a676 1
    fb_write (fbp, 0, ap->a_y, blendline[cpu], per_processor_chunk);	  
d699 2
a700 2
  } 
  
d763 1
a763 1
    return(1);		
d776 1
a776 1
    c->c_id	    	= MISS_ID;	
d792 2
a793 2
      } 
    } 
d796 1
a796 1
      if (here->c_region != left->c_region || 
d801 1
a801 1
  
d812 1
a812 1
	return 1;	
d821 1
a821 1
  
d837 1
a837 1
  
d843 1
a843 1
  LOCAL int			cpu;	
d852 3
a854 3
  
  cpu = ap->a_resource->re_cpu;	
  
d868 1
a868 1
    hitp = pp->pt_inhit;	
d879 1
a879 1
		  pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);	       
d881 1
a881 1
  
d892 1
a892 1
  
d897 1
a897 1
  
d918 1
a918 1
  
d940 1
a940 1
      
d948 1
a948 1
      
d951 1
a951 1
    } 
d957 1
a957 1
      
d965 1
a965 1
       * For occluding non-edges, only write every 
d970 1
a970 1
      } 
d977 1
a977 1
    } 
d993 1
a993 1
    
d997 1
a997 1
    
d999 1
a999 1
    
d1002 1
a1002 1
    scanline[cpu][ap->a_x*3+BLU] = bgcolor[BLU];	  
d1019 1
a1019 1
void application_init (void) { 
d1064 1
a1064 1
static int occlusion_hit (struct application *ap, struct partition *pt, 
d1068 1
a1068 1
  
d1070 1
a1070 1
  return 1;		
d1076 1
a1076 1
  return 0;		
d1082 2
a1083 2
{ 
  int cpu = ap->a_resource->re_cpu;	
d1098 3
a1100 3
     * The occlusion ray missed, therefore this 
     * pixel occludes the second geometry. 
     * 
d1102 1
a1102 1
     * geometry behind can be conveyed to the 
d1109 1
a1109 1
    /* 
d1115 2
a1116 2
    return 0; 
  }    
@


14.14
log
@add support for simultaneous -o file and -F framebuffer output to rtedge
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.13 2005/06/21 07:03:55 brlcad Exp $ (BRL)";
a279 1
    /*    char idbuf[512]; */
@


14.14.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d31 1
a31 1
 *
d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header$ (BRL)";
d98 1
a98 1
			   * surface normals that triggers shading
d135 1
a135 1
 *
d137 1
a137 1
 * pixels are blended (using some HSV manipulations) with the
d147 1
a147 1
 *
d149 1
a149 1
 * If the edge is determined because of a change from one region
d174 1
a174 1
static int occlusion_hit (struct application *,
d189 1
a189 1
static int handle_main_ray(struct application *, struct partition *,
d220 1
a220 1
  {"%d", 3, "bg", bu_byteoffset(bgcolor), BU_STRUCTPARSE_FUNC_NULL},
d225 1
a225 1
  {"%d", 1, "region_color", bu_byteoffset(region_colors),
d228 1
a228 1
  {"%S", 1, "occlusion_objects", bu_byteoffset(occlusion_objects),
d230 1
a230 1
  {"%S", 1, "oo", bu_byteoffset(occlusion_objects),
d232 1
a232 1
  {"%d", 1, "occlusion_mode", bu_byteoffset(occlusion_mode),
d258 1
a258 1

d276 1
a276 1
   *
d280 1
d288 1
a288 1
    if (Tcl_SplitList (NULL, bu_vls_addr (&occlusion_objects), &nObjs,
d290 1
a290 1
      bu_log  ("rtedge: occlusion list = %s\n",
d298 1
a298 1

d307 1
a307 1
    for( i=0; i < MAX_PSW; i++ )
d335 1
a335 1
    occlusion_apps = bu_calloc (npsw, sizeof(struct application *),
d338 1
a338 1
      occlusion_apps[i] = bu_calloc (1, sizeof(struct application),
d352 1
a352 1
    }
d363 1
a363 1
    if ((occlusion_mode != OCCLUSION_MODE_NONE) &&
d370 1
a370 1

d409 1
a409 1
  if (overlay) {
d414 1
a414 1

d440 1
a440 1
      saved[i] = (struct cell *) bu_calloc( 1, sizeof(struct cell),
d442 1
a442 1
    }
d450 1
a450 1
      writeable[i] = (unsigned char *) bu_calloc( 1, per_processor_chunk,
d452 1
a452 1
    }
d459 1
a459 1

d465 1
a465 1
      scanline[i] = (unsigned char *) bu_calloc( per_processor_chunk,
d467 1
a467 1
    }
d469 1
a469 1

d475 1
a475 1

d480 1
a480 1

d483 1
a483 1

d494 2
a495 2
	blendline[i] = (unsigned char *) bu_calloc( per_processor_chunk,
						    pixsize,
d497 1
a497 1
      }
d500 1
a500 1

d502 2
a503 2
   * If operating in overlay mode, we want the rtedge background color
   * to be the shaded images background. This sets the bg color
d509 1
a509 1
    if (bgcolor[RED] == 0 &&
d512 1
a512 1

d546 1
a546 1
	fb_write(fbp, i, ap->a_y, &scanline[cpu][i*3], 1);
d565 1
a565 1

d571 1
a571 1

d590 1
a590 1
	 * edge. Unless, of course, we are on the bottom
d596 1
a596 1

d602 1
a602 1
	  fb_read (fbp, i, ap->a_y - 1, down, 1);
d606 1
a606 1
	    /*
d628 1
a628 1

d637 1
a637 1

d647 1
a647 1

d649 2
a650 2
	  /*
	   * Write this pixel immediately, do not put it into
d659 1
a659 1
	}
d661 1
a661 1
	  /*
d673 1
a673 1
    /*
d677 1
a677 1
    fb_write (fbp, 0, ap->a_y, blendline[cpu], per_processor_chunk);
d700 2
a701 2
  }

d764 1
a764 1
    return(1);
d777 1
a777 1
    c->c_id	    	= MISS_ID;
d793 2
a794 2
      }
    }
d797 1
a797 1
      if (here->c_region != left->c_region ||
d802 1
a802 1

d813 1
a813 1
	return 1;
d822 1
a822 1

d838 1
a838 1

d844 1
a844 1
  LOCAL int			cpu;
d853 3
a855 3

  cpu = ap->a_resource->re_cpu;

d869 1
a869 1
    hitp = pp->pt_inhit;
d880 1
a880 1
		  pp->pt_inseg->seg_stp, &(ap->a_ray), pp->pt_inflip);
d882 1
a882 1

d893 1
a893 1

d898 1
a898 1

d919 1
a919 1

d941 1
a941 1

d949 1
a949 1

d952 1
a952 1
    }
d958 1
a958 1

d966 1
a966 1
       * For occluding non-edges, only write every
d971 1
a971 1
      }
d978 1
a978 1
    }
d994 1
a994 1

d998 1
a998 1

d1000 1
a1000 1

d1003 1
a1003 1
    scanline[cpu][ap->a_x*3+BLU] = bgcolor[BLU];
d1020 1
a1020 1
void application_init (void) {
d1065 1
a1065 1
static int occlusion_hit (struct application *ap, struct partition *pt,
d1069 1
a1069 1

d1071 1
a1071 1
  return 1;
d1077 1
a1077 1
  return 0;
d1083 2
a1084 2
{
  int cpu = ap->a_resource->re_cpu;
d1099 3
a1101 3
     * The occlusion ray missed, therefore this
     * pixel occludes the second geometry.
     *
d1103 1
a1103 1
     * geometry behind can be conveyed to the
d1110 1
a1110 1
    /*
d1116 2
a1117 2
    return 0;
  }
@


14.13
log
@get rid of the rogue byteoffset duplicates and make everyone use bu_byteoffset() instead
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.12 2005/06/03 05:34:58 brlcad Exp $ (BRL)";
d265 1
a265 1
view_init( struct application *ap, char *file, char *obj, int minus_o )
d392 1
a392 1
  if( minus_o ) {
d394 2
a395 3
     * Output is to a file stream.
     * Do not open a framebuffer, do not allow parallel
     * processing since we can't seek to the rows.
d398 1
a398 1
    bu_log ("view_init: deactivating parallelism due to minus_o.\n");
d406 1
a406 2
    bu_log ("view_init: deactivating overlay and blending due to minus_o.\n");
    return(0);
d408 2
a409 1
  else if (overlay) {      
d411 1
a411 2
  }
  else if (blend) {
d415 4
a418 1
  return(1);		/* we need a framebuffer */
d550 1
d679 1
d681 2
a682 1
  else if( fbp != FBIO_NULL ) {
d690 1
a690 1
  else if( outfp != NULL ) {
@


14.13.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.14 2005/07/16 23:22:10 brlcad Exp $ (BRL)";
d265 1
a265 1
view_init( struct application *ap, char *file, char *obj, int minus_o, int minus_F )
d392 1
a392 1
  if( minus_o && (overlay || blend)) {
d394 3
a396 2
     * Output is to a file stream.  Do not allow parallel processing
     * since we can't seek to the rows.
d399 1
a399 1
    bu_log ("view_init: deactivating parallelism due to -o option.\n");
d407 2
a408 1
    bu_log ("view_init: deactivating overlay and blending due to -o option.\n");
d410 1
a410 2

  if (overlay) {      
d412 2
a413 1
  } else if (blend) {
d417 1
a417 4
  if (minus_F || (!minus_o && !minus_F)) {
      return 1;		/* we need a framebuffer */
  }
  return 0;
a548 1
    return;
a676 1
    return;
d678 1
a678 2

  if( fbp != FBIO_NULL ) {
d686 1
a686 1
  if( outfp != NULL ) {
@


14.12
log
@only swap the colors once otherwise the frame backgrounds will flop back and forth
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.11 2005/06/03 05:26:15 brlcad Exp $ (BRL)";
d50 1
d56 2
d60 1
a203 22
/*
 * From do.c
 */
#if defined (CRAY)
#	define byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if defined(IRIX) && IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
#	define byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if defined(sgi) || defined(__convexc__) || defined(ultrix) || defined(_HPUX_SOURCE)
/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define byteoffset(_i)	((int)((char *)&(_i)))
#    else
#       if defined(__ia64__) || defined(__x86_64__) || defined(__sparc64__)
#		define byteoffset(_i)	((long)(((void *)&(_i))-((void *)0)))
#	else
/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#		define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#	endif
#    endif
#  endif
#endif
d209 17
a225 17
  {"%d", 1, "detect_regions", byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dr", byteoffset(detect_regions), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_distance", byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dd", byteoffset(detect_distance), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_normals", byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "dn", byteoffset(detect_normals), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "detect_ids", byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "di", byteoffset(detect_ids), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "foreground", byteoffset(fgcolor), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "fg", byteoffset(fgcolor), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "background", byteoffset(bgcolor), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "bg", byteoffset(bgcolor), BU_STRUCTPARSE_FUNC_NULL},	
  {"%d", 1, "overlay", byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "ov", byteoffset(overlay), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "blend", byteoffset(blend), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "bl", byteoffset(blend), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 1, "region_color", byteoffset(region_colors), 
d227 2
a228 2
  {"%d", 1, "rc", byteoffset(region_colors), BU_STRUCTPARSE_FUNC_NULL},
  {"%S", 1, "occlusion_objects", byteoffset(occlusion_objects), 
d230 1
a230 1
  {"%S", 1, "oo", byteoffset(occlusion_objects), 
d232 1
a232 1
  {"%d", 1, "occlusion_mode", byteoffset(occlusion_mode), 
d234 1
a234 1
  {"%d", 1, "om", byteoffset(occlusion_mode), BU_STRUCTPARSE_FUNC_NULL},
@


14.11
log
@the new -W option on rtedge means that the foreground and background colors need to be inverted so that it's black lines on a white background by default.  (this implements sf request 1177331)
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.10 2005/05/28 02:14:59 brlcad Exp $ (BRL)";
d394 15
a516 16

  /* if non-default/inverted background was requested, swap the
   * foreground and background colors.
   */
  if (!default_background) {
      color tmp;
      tmp[RED] = fgcolor[RED];
      tmp[GRN] = fgcolor[GRN];
      tmp[BLU] = fgcolor[BLU];
      fgcolor[RED] = bgcolor[RED];
      fgcolor[GRN] = bgcolor[GRN];
      fgcolor[BLU] = bgcolor[BLU];
      bgcolor[RED] = tmp[RED];
      bgcolor[GRN] = tmp[GRN];
      bgcolor[BLU] = tmp[BLU];
  }
@


14.10
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.9 2005/04/26 08:39:36 brlcad Exp $ (BRL)";
d66 2
a67 1
extern int	per_processor_chunk;
d502 16
@


14.9
log
@use if defined() preprocessor checks for the symbols so cygwin behaves
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.8 2005/04/11 18:32:27 brlcad Exp $ (BRL)";
d225 1
a225 1
#if !defined(__alpha) && !defined(WIN32) /* XXX Alpha does not support this initialization! */
@


14.8
log
@add explicit build support for sparc64
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.7 2005/03/31 05:53:12 brlcad Exp $ (BRL)";
d202 1
a202 1
#if CRAY
d205 1
a205 1
#  if IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
d208 1
a208 1
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
d221 1
@


14.7
log
@arrrrgh!!!  rtedge was using a global named background, which was removed when liboptical picked up the rt background variable of the same name.  the problem is that rtedge was using a triplet of ints, rt/liboptical used/uses a triplet of floats! .. this caused the set command struct parse variable setting to not work quite as was intended... resulting in the background never changing from black.  this fixes the problem by reinstating rtedges global int triplet but lets call it bgcolor now.. (addresses sf bug 1172633)  should probably make rtedge do what rt does eventually.
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.6 2005/03/28 06:31:37 bob1961 Exp $ (BRL)";
d212 1
a212 1
#       if defined(__ia64__) || defined(__x86_64__)
@


14.6
log
@Add code to allow liboptical to be a Windows DLL
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.5 2005/01/30 20:31:10 brlcad Exp $ (BRL)";
d97 2
a98 1
color	foreground = { 255, 255, 255};
d113 1
a113 1
RGBpixel bg_color;
d233 4
a236 4
  {"%d", 3, "foreground", byteoffset(foreground), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "fg", byteoffset(foreground), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "background", byteoffset(background), BU_STRUCTPARSE_FUNC_NULL},
  {"%d", 3, "bg", byteoffset(background), BU_STRUCTPARSE_FUNC_NULL},	
d481 1
a481 1
    if (fb_read(fbp,0,0,bg_color,1) < 0) {
d509 3
a511 3
    if (background[RED] == 0 && 
	background[GRN] == 0 &&
	background[BLU] == 1) {
d513 3
a515 3
      background[RED] = bg_color[RED];
      background[GRN] = bg_color[GRN];
      background[BLU] = bg_color[BLU];
d592 1
a592 1
	if (i != 0 && ap->a_y != 0 && !diffpixel (rgb,bg_color)) {
d604 1
a604 1
	  if (diffpixel (left, bg_color)) {
d612 1
a612 1
	  else if (diffpixel (down, bg_color)) {
d998 3
a1000 3
    scanline[cpu][ap->a_x*3+RED] = background[RED];
    scanline[cpu][ap->a_x*3+GRN] = background[GRN];
    scanline[cpu][ap->a_x*3+BLU] = background[BLU];	  
d1035 3
a1037 3
  col[RED] = foreground[RED];
  col[GRN] = foreground[GRN];
  col[BLU] = foreground[BLU];
@


14.5
log
@update copyright to 2005
@
text
@d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.4 2004/12/24 01:40:01 brlcad Exp $ (BRL)";
d222 2
d250 1
@


14.4
log
@add the mysteriously missing gpl header..
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2004 United States Government as represented by
d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewedge.c,v 14.3 2004/12/21 07:25:31 morrison Exp $ (BRL)";
@


14.3
log
@tidy up a lil bit
@
text
@d1 21
a21 2
/*
 *			V I E W E D G E
d38 4
a41 2
 *	
 *
d43 1
a43 1
static const char RCSviewedge[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewedge.c,v 14.2 2004/12/21 06:38:22 morrison Exp $ (BRL)";
a47 2


@


14.2
log
@remove the old copyright notice section
@
text
@d22 1
a22 1
static const char RCSviewedge[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewedge.c,v 14.1 2004/11/16 19:42:31 morrison Exp $ (BRL)";
a1007 2
 *
 *
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@a20 3
 *  Copyright Notice -
 *	This software is Copyright (C) 2001-2004 by the United States Army.
 * All rights reserved.  */
d22 1
a22 1
static const char RCSviewedge[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewedge.c,v 1.4 2004/09/20 19:37:30 morrison Exp $ (BRL)";
@


1.4
log
@support byteoffsets for the amd64 opterons too.
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewedge.c,v 1.3 2004/09/03 19:57:13 morrison Exp $ (BRL)";
d1099 10
@


1.3
log
@use ((long)(((void *)&(_i))-((void *)0))) as a byte offset for __ia64__ .. there probably shouldn't be three of these..
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewedge.c,v 1.2 2004/08/02 23:01:52 morrison Exp $ (BRL)";
d195 1
a195 1
#       if defined(__ia64__)
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewedge.c,v 1.1 2004/05/20 15:20:47 morrison Exp $ (BRL)";
d195 3
d199 2
a200 1
#	define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d25 1
a25 1
static const char RCSviewedge[] = "@@(#)$Header: /cvs/brlcad/rt/viewedge.c,v 11.27 2004/05/10 15:30:49 erikg Exp $ (BRL)";
d28 1
a28 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

