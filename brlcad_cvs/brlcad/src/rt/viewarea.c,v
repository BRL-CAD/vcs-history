head	14.20;
access;
symbols
	rel-7-10-4:14.17
	STABLE:14.17.0.2
	stable-branch:14.3
	rel-7-10-2:14.17
	rel-7-10-0:14.15
	rel-7-8-4:14.13
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.12
	bobWinPort-20051223-freeze:14.10
	postmerge-20051223-bobWinPort:14.12
	premerge-20051223-bobWinPort:14.12
	rel-7-6-6:14.12
	rel-7-6-4:14.11
	rel-7-6-2:14.10
	rel-7-6-branch:14.10.0.4
	rel-7-6-0:14.10
	rel-7-4-2:14.9.2.1
	rel-7-4-branch:14.9.0.2
	bobWinPort:14.10.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.20
date	2007.12.02.22.34.24;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.11.20.22.32;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.09.15.16.23.20;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.04.17.03.23.57;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.04.14.03.39.02;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.46;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.37.00;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.18.06.46.24;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.12.08.01.50.32;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.23.04.44.38;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.07.27.20.33.14;	author brlcad;	state Exp;
branches
	14.10.4.1;
next	14.9;

14.9
date	2005.06.23.01.22.18;	author brlcad;	state Exp;
branches
	14.9.2.1;
next	14.8;

14.8
date	2005.06.22.23.33.26;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.06.22.23.12.51;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.06.22.22.55.49;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.06.22.22.31.04;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.04.22.05.44.15;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.10;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.24.01.40.00;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.59;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.46;	author morrison;	state Exp;
branches;
next	;

14.9.2.1
date	2005.08.16.21.03.50;	author brlcad;	state Exp;
branches;
next	;

14.10.4.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.20
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@/*                      V I E W A R E A . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file viewarea.c
 *
 *  Computes the exposed and presented surface area projections of
 *  specified geometry.  Exposed area is the occluded 2D projection,
 *  presented is the unoccluded 2D projection.  That is to say that if
 *  there is an object in front, it will reduce the exposed area, but
 *  not the presented area.
 *
 *  Authors -
 *    Christopher Sean Morrison
 *    John R. Anderson
 *
 *  Source -
 *    The U. S. Army Research Laboratory
 *    Aberdeen Proving Ground, Maryland  21005
 */
#ifndef lint
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.19 2007/10/11 20:22:32 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>
#include <math.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ext.h"
#include "../librt/debug.h"
#include "plot3.h"
#include "rtprivate.h"

#define	MM2IN	0.03937008		/* mm times MM2IN gives inches */
#define TOL 0.01/MM2IN			/* GIFT has a 0.01 inch tolerance */

extern int	npsw;			/* number of worker PSWs to run */

int		use_air = 1;		/* Handling of air in librt */

extern int 	 rpt_overlap;

extern fastf_t  rt_cline_radius;        /* from g_cline.c */

static long hit_count=0;
static fastf_t cell_area=0.0;


/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
    {"",	0, (char *)0,	0,		BU_STRUCTPARSE_FUNC_NULL }
};


const char title[] = "RT Area";
const char usage[] = "\
Usage:  rtarea [options] model.g objects...\n\
Options:\n\
 -s #		Grid size in pixels, default 512\n\
 -a Az		Azimuth in degrees	(conflicts with -M)\n\
 -e Elev	Elevation in degrees	(conflicts with -M)\n\
 -M		Read model2view matrix on stdin (conflicts with -a, -e)\n\
 -g #		Grid cell width in millimeters (conflicts with -s)\n\
 -G #		Grid cell height in millimeters (conflicts with -s)\n\
 -J #		Jitter.  Default is off.  Any non-zero number is on\n\
 -U #		Set use_air boolean to # (default=1)\n\
 -c \"set rt_cline_radius=radius\"      Additional radius to be added to CLINE solids\n\
 -x #		Set librt debug flags\n\
";


struct area {
    struct area *assembly;	/* pointer to a linked list of assemblies */
    long hits;			/* presented hits count */
    long exposures;		/* exposed hits count */
    int seen;			/* book-keeping for exposure */
    int depth;			/* assembly depth */
    const char *name;		/* assembly name */
};

struct area_list {
    struct area *cell;
    struct area_list *next;
};

typedef enum area_type {
    PRESENTED_AREA,
    EXPOSED_AREA
} area_type_t;


int rayhit(struct application *ap, struct partition *PartHeadp, struct seg *segHeadp);
int raymiss(register struct application *ap);


/*
 *  			V I E W _ I N I T
 */
int
view_init( register struct application *ap, char *file, char *obj )
{
    ap->a_hit = rayhit;
    ap->a_miss = raymiss;
    ap->a_onehit = 0;

    if( !rpt_overlap )
	ap->a_logoverlap = rt_silent_logoverlap;

    output_is_binary = 0;		/* output is printable ascii */

    hit_count = 0;

    return(0);		/* No framebuffer needed */
}

/*
 *			V I E W _ 2 I N I T
 *
 *  View_2init is called by do_frame(), which in turn is called by
 *  main().
 */
void
view_2init( struct application *ap )
{
    register struct region *rp;
    register struct rt_i *rtip = ap->a_rt_i;

    /* initial empty parent assembly */
    struct area *assembly;

    cell_area = cell_width * cell_height;

    assembly = (struct area *)bu_calloc(1, sizeof(struct area), "view_2init assembly allocation");

    /* allocate the initial areas and point them all to the same (empty) starting assembly list */
    bu_semaphore_acquire( RT_SEM_RESULTS );
    for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
	struct area *cell;
	/* allocate memory first time through */
	cell = (struct area *)bu_calloc(1, sizeof(struct area), "view_2init area allocation");
	cell->assembly = assembly;
	rp->reg_udata = (genptr_t)cell;
    }
    bu_semaphore_release( RT_SEM_RESULTS );

    return;
}

/*
 *			R A Y M I S S
 *
 *  Null function -- handle a miss
 *  This function is called by rt_shootray(), which is called by
 *  do_frame().
 */
int
raymiss(register struct application *ap)
{
    return(0);
}

/*
 *			V I E W _ P I X E L
 *
 *  This routine is called from do_run(), and in this case does nothing.
 */
void
view_pixel()
{
    return;
}


/* keeps track of how many times we encounter an assembly by
 * maintaining a simple linked list of them using the same structure
 * used for regions.
 */
static void
increment_assembly_counter(register struct area *cell, const char *path, area_type_t type)
{
    int l;
    char *buffer;
    int depth;

    if (!cell || !path) {
	return;
    }

    l = strlen(path);
    buffer = bu_calloc(l+1, sizeof(char), "increment_assembly_counter buffer allocation");
    strncpy(buffer, path, l);

    /* trim off the region name */
    while (l > 0) {
	if (buffer[l-1] == '/') {
	    break;
	}
	l--;
    }
    buffer[l-1] = '\0';

    /* get the region names, one at a time */
    depth = 0;
    while (l > 0) {
	if (buffer[l-1] == '/') {
	    register struct area *cellp;

	    /* scan the assembly list */
	    cellp = cell->assembly;
	    while (cellp->name) {
		if ( (strcmp(cellp->name, &buffer[l])==0) ) {
		    if (type == EXPOSED_AREA) {
			if (!cellp->seen) {
			    cellp->exposures++;
			    cellp->seen++;
			    if (depth > cellp->depth) {
				cellp->depth = depth;
			    }
			}
		    }
		    if (type == PRESENTED_AREA) {
			cellp->hits++;
			cellp->seen++;
			if (depth > cellp->depth) {
			    cellp->depth = depth;
			}
		    }
		    break;
		}
		cellp = cellp->assembly;
	    }

	    /* insert a new assembly? */
	    if (!cellp->name) {
		char *name;
		int len;

		/* sanity check */
		if (cellp->assembly) {
		    bu_log("Inconsistent assembly list detected\n");
		    break;
		}

		len = strlen(&buffer[l])+1;
		name = (char *)bu_malloc(len, "increment_assembly_counter assembly name allocation");
		strncpy(name, &buffer[l], len-1);
		cellp->name = name;
		if (type == EXPOSED_AREA) {
		    cellp->exposures++;
		}
		if (type == PRESENTED_AREA) {
		    cellp->hits++;
		}
		cellp->seen++;
		if (depth > cellp->depth) {
		    cellp->depth = depth;
		}

		/* allocate space for the next assembly */
		cellp->assembly = (struct area *)bu_calloc(1, sizeof(struct area), "increment_assembly_counter assembly allocation");
	    }

	    buffer[l-1] = '\0';
	    depth++;
	}
	l--;
    }

    bu_free(buffer, "increment_assembly_counter buffer free");

    return;
}


/*
 *			R A Y H I T
 *
 */
int
rayhit(struct application *ap, struct partition *PartHeadp, struct seg *segHeadp)
{
    register struct region *rp;
    struct rt_i *rtip = ap->a_rt_i;
    register struct partition *pp = PartHeadp->pt_forw;
    register struct area *cell;
    register int l;


    if( pp == PartHeadp )
	return(0);		/* nothing was actually hit?? */

    /* ugh, horrible block */
    bu_semaphore_acquire( RT_SEM_RESULTS );

    hit_count++;

    /* clear the list of visited regions */
    for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
	struct area *cellp;
	cell = (struct area *)rp->reg_udata;
	cell->seen = 0;

	for (cellp = cell->assembly; cellp; cellp = cellp->assembly) {
	    cellp->seen = 0;
	}
    }

    /* get the exposed areas (i.e. first hits) */
    for (pp = PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw) {
	struct region  *reg = pp->pt_regionp;
	cell = (struct area *)reg->reg_udata;

	/* ignore air */
	if (reg->reg_aircode) {
	    continue;
	}

	/* have not visited this region yet, so increment the count */
	if (!cell->seen) {
	    cell->exposures++;
	    cell->seen++;

	    if (!cell->name) {
		/* get the region name */
		int l = strlen(reg->reg_name);
		while (l > 0) {
		    if (reg->reg_name[l-1] == '/') {
			break;
		    }
		    l--;
		}
		cell->name = &reg->reg_name[l];
	    }

	    /* record the parent assemblies */
	    increment_assembly_counter(cell, reg->reg_name, EXPOSED_AREA);
	}

	/* halt after first non-air */
	break;
    }

    /* get the presented areas */
    for (pp = PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw) {
	struct region  *reg = pp->pt_regionp;
	cell = (struct area *)reg->reg_udata;

	/* ignore air */
	if (reg->reg_aircode) {
	    continue;
	}

	cell->hits++;

	if (!cell->name) {
	    /* get the region name */
	    int l = strlen(reg->reg_name);
	    while (l > 0) {
		if (reg->reg_name[l-1] == '/') {
		    break;
		}
		l--;
	    }
	    cell->name = &reg->reg_name[l];
	}

	/* record the parent assemblies */
	increment_assembly_counter(cell, reg->reg_name, PRESENTED_AREA);
    }
    bu_semaphore_release( RT_SEM_RESULTS );

    return(0);
}


/*
 *			V I E W _ E O L
 *
 *  View_eol() is called by rt_shootray() in do_run().  In this case,
 *  it does nothing.
 */
void	view_eol()
{
}


/*  p r i n t _ r e g i o n _ a r e a _ l i s t
 *
 * Prints a list of region areas sorted alphabetically reporting
 * either the presented or exposed area 'type' and keeping track of
 * the 'count' of regions printed.  this routine returns the number of
 * ray hits across all regions.
 */
static long int
print_region_area_list(long int *count, struct rt_i *rtip, area_type_t type)
{
    struct region *rp;
    register struct area *cell = (struct area *)NULL;
    long int cumulative = 0;

    struct area_list *listHead = (struct area_list *)bu_malloc(sizeof(struct area_list), "print_area_list area list node allocation");
    struct area_list *listp;
    listHead->cell = (struct area *)NULL;
    listHead->next = (struct area_list *)NULL;

    /* sort the cell entries alphabetically */
    for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
	cell = (struct area *)rp->reg_udata;
	listp = listHead;

	if (cell) {
	    if (cell->hits > 0) {
		struct area_list *prev = (struct area_list *)NULL;
		struct area_list *newNode;

		while (listp->next) {
		    if (!listp->cell || (strcmp(cell->name, listp->cell->name) < 0)) {
			break;
		    }
		    prev = listp;
		    listp = listp->next;
		}

		newNode = (struct area_list *)bu_malloc(sizeof(struct area_list), "print_area_list area list node allocation");
		newNode->cell = cell;
		newNode->next = (struct area_list *)NULL;

		if (!prev) {
		    listHead = newNode;
		    newNode->next = listp;
		} else {
		    newNode->next = prev->next;
		    prev->next = newNode;
		}

		cumulative += cell->hits;
		if (count) {
		    (*count)++;
		}
	    }
	}
    }

    if (type == PRESENTED_AREA) {
	bu_log("\nPresented Region Areas\n======================\n");
    }
    if (type == EXPOSED_AREA) {
	bu_log("\nExposed Region Areas\n====================\n");
    }
    for (listp = listHead; listp->cell != NULL;) {
	struct area_list *prev = listp;
	cell = listp->cell;
	if (type == PRESENTED_AREA) {
	    bu_log("Region %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cell->name, cell->hits, cell_area * (fastf_t)cell->hits, cell_area * (fastf_t)cell->hits / 1000000.0);
	    fflush(stdout); fflush(stderr);
	}
	if (type == EXPOSED_AREA) {
	    bu_log("Region %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cell->name, cell->exposures, cell_area * (fastf_t)cell->exposures, cell_area * (fastf_t)cell->exposures / 1000000.0);
	    fflush(stdout); fflush(stderr);
	}
	listp = listp->next;
	bu_free(prev, "print_area_list area list node free");
    }
    bu_free(listp, "print_area_list area list node free");

    return cumulative;
}


/*  p r i n t _ a s s e m b l y _ a r e a _ l i s t
 *
 * Prints a list of region areas sorted alphabetically reporting
 * either the presented or exposed area 'type' and keeping track of
 * the 'count' of regions printed.  this routine returns the number of
 * ray hits across all regions.
 */
static long int
print_assembly_area_list(struct rt_i *rtip, long int max_depth, area_type_t type)
{
    struct region *rp;
    struct area *cellp;
    int depth;
    register struct area *cell = (struct area *)NULL;
    long int count = 0;

    struct area_list *listHead = (struct area_list *)bu_malloc(sizeof(struct area_list), "print_area_list area list node allocation");
    struct area_list *listp;
    listHead->cell = (struct area *)NULL;
    listHead->next = (struct area_list *)NULL;

    /* insertion sort based on depth and case */
    rp = BU_LIST_FIRST(region, &(rtip->HeadRegion));
    cell = (struct area *)rp->reg_udata;
    for (cellp = cell->assembly; cellp; cellp = cellp->assembly) {
	int counted_items;
	listp = listHead;

	if (type == PRESENTED_AREA) {
	    counted_items = cellp->hits;
	}
	if (type == EXPOSED_AREA) {
	    counted_items = cellp->exposures;
	}
	if (counted_items) {
	    struct area_list *prev = (struct area_list *)NULL;
	    struct area_list *newNode;

	    while (listp->next) {
		if ((!listp->cell) || (cellp->depth > listp->cell->depth)) {
		    break;
		}
		if ((cellp->depth == listp->cell->depth) && (strcmp(cellp->name, listp->cell->name) < 0)) {
		    break;
		}

		prev = listp;
		listp = listp->next;
	    }

	    newNode = (struct area_list *)bu_malloc(sizeof(struct area_list), "print_area_list area list node allocation");
	    newNode->cell = cellp;
	    newNode->next = (struct area_list *)NULL;

	    if (!prev) {
		listHead = newNode;
		newNode->next = listp;
	    } else {
		newNode->next = prev->next;
		prev->next = newNode;
	    }

	    count++;
	}
    }


    if (type == PRESENTED_AREA) {
	bu_log("\nPresented Assembly Areas\n========================\n");
    }
    if (type == EXPOSED_AREA) {
	bu_log("\nExposed Assembly Areas\n======================\n");
    }
    for (listp = listHead; listp->cell != NULL;) {
	int indents = max_depth - listp->cell->depth;
	struct area_list *prev = listp;
	cell = listp->cell;

	while (indents-- > 0) {
	    if (indents % 2) {
		bu_log("++");
	    } else {
		bu_log("--");
	    }
	}

	if (type == PRESENTED_AREA) {
	    bu_log("Assembly %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cell->name, cell->hits, cell_area * (fastf_t)cell->hits, cell_area * (fastf_t)cell->hits / 1000000.0);
	    fflush(stdout); fflush(stderr);
	}
	if (type == EXPOSED_AREA) {
	    bu_log("Assembly %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cell->name, cell->exposures, cell_area * (fastf_t)cell->exposures, cell_area * (fastf_t)cell->exposures / 1000000.0);
	    fflush(stdout); fflush(stderr);
	}

	listp = listp->next;
	bu_free(prev, "print_area_list area list node free");
    }
    bu_free(listp, "print_area_list area list node free");

    return count;
}


/*
 *			V I E W _ E N D
 *
 */
void
view_end(struct application *ap)
{
    register struct region *rp;
    struct rt_i *rtip = ap->a_rt_i;
    fastf_t total_area=0.0;
    long cumulative = 0;
    register struct area *cell = (struct area *)NULL;

    int max_depth = 0;
    struct area *cellp;

    long int presented_region_count = 0;
    long int presented_assembly_count = 0;
    long int exposed_region_count = 0;
    long int exposed_assembly_count = 0;

    cumulative = print_region_area_list(&presented_region_count, rtip, PRESENTED_AREA);
    (void) print_region_area_list(&exposed_region_count, rtip, EXPOSED_AREA);

    /* find the maximum assembly depth */
    rp = BU_LIST_FIRST(region, &(rtip->HeadRegion));
    cell = (struct area *)rp->reg_udata;
    for (cellp = cell->assembly; cellp; cellp = cellp->assembly) {
	if (cellp->depth > max_depth) {
	    max_depth = cellp->depth;
	}
    }

    presented_assembly_count = print_assembly_area_list(rtip, max_depth, PRESENTED_AREA);

    exposed_assembly_count = print_assembly_area_list(rtip, max_depth, EXPOSED_AREA);

    bu_log("\nSummary\n=======\n");
    total_area = cell_area * (fastf_t)hit_count;
    bu_log("Cumulative Presented Areas (%ld hits) = %18.4lf square mm\t(%.4lf square meters)\n", cumulative, cell_area * (fastf_t)cumulative, cell_area * (fastf_t)cumulative / 1000000.0);
    bu_log("Total Exposed Area         (%ld hits) = %18.4lf square mm\t(%.4lf square meters)\n", hit_count, total_area, total_area / 1000000.0);
    bu_log("Number of Presented Regions:    %8d\n", presented_region_count);
    bu_log("Number of Presented Assemblies: %8d\n", presented_assembly_count);
    bu_log("Number of Exposed Regions:    %8d\n", exposed_region_count);
    bu_log("Number of Exposed Assemblies: %8d\n", exposed_assembly_count);
    bu_log("\n");

    /* free the assembly areas */
    cell = (struct area *)rp->reg_udata;
    if (cell) {
	struct area *next_cell;
	cell = cell->assembly;
	while (cell) {
	    next_cell = cell->assembly;
	    if (cell->name) {
		bu_free((char *)cell->name, "view_end assembly name free");
	    }
	    bu_free(cell, "view_end assembly free");
	    cell = next_cell;
	}
    }

    /* free the region areas */
    for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
	cell = (struct area *)rp->reg_udata;

	if (cell) {
	    bu_free(cell, "view_end area free");
	    cell = (genptr_t)NULL;
	    rp->reg_name = (genptr_t)NULL;
	}
    }

    /* flush for good measure */
    fflush(stdout); fflush(stderr);

    return;
}

void view_setup() {}
void view_cleanup() {}
void application_init () {}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.19
log
@flush stdout/stderr just for good measure.
@
text
@d37 1
a37 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.18 2007/09/15 16:23:20 brlcad Exp $ (BRL)";
d256 1
d264 3
a266 2
		name = (char *)bu_malloc(strlen(&buffer[l])+1, "increment_assembly_counter assembly name allocation");
		strcpy(name, &buffer[l]);
@


14.18
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d37 1
a37 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.17 2007/04/17 03:23:57 brlcad Exp $ (BRL)";
d665 3
@


14.17
log
@redo the client-side version reporting to use the new brlcad_version() interface, utilizing a per-binary title as needed, instead of the former vers.sh setup.
@
text
@d37 1
a37 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.16 2007/04/14 03:39:02 brlcad Exp $ (BRL)";
d44 1
a44 6

#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.16
log
@john points out a blatent thread locking problem where a BU_SEM_SYSCALL is acquired prior to a bu_calloc() which itself also attempts to acquire that same semaphore.. how the hell did that ever work??  make it use RT_SEM_RESULTS instead since it is simply initializing the results array.  also, toss in some flushed output to avoid flooding the mged command windows to see if that helps with a separate lockup issue.  finally, remove the USE_FORKED_THREADS hack for linux, which presumably was probably added because of this semaphore bug.
@
text
@d37 1
a37 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.15 2007/01/23 01:13:46 brlcad Exp $ (BRL)";
d79 2
d96 1
d120 1
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d37 1
a37 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.14 2007/01/20 14:37:00 brlcad Exp $ (BRL)";
d76 1
a76 1
	{"",	0, (char *)0,	0,		BU_STRUCTPARSE_FUNC_NULL }
a118 1
 *
d123 3
a125 8
#if defined(USE_FORKED_THREADS)
    printf("\n*** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ***\nLimiting the number of processors to 1 for proper area calculations\n\n");
    npsw = 1;
    rt_g.rtg_parallel = 0;
#endif
	ap->a_hit = rayhit;
	ap->a_miss = raymiss;
	ap->a_onehit = 0;
d127 2
a128 2
	if( !rpt_overlap )
		 ap->a_logoverlap = rt_silent_logoverlap;
d130 1
a130 1
	output_is_binary = 0;		/* output is printable ascii */
d132 1
a132 1
	hit_count = 0;
d134 1
a134 1
	return(0);		/* No framebuffer needed */
d141 1
a141 2
 *  main().  It writes the view-specific COVART header.
 *
d157 1
a157 1
    bu_semaphore_acquire( BU_SEM_SYSCALL );
d165 1
a165 1
    bu_semaphore_release( BU_SEM_SYSCALL );
d180 1
a180 1
	return(0);
d191 1
a191 1
	return;
d311 1
d474 1
d478 1
d577 1
d581 1
@


14.14
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d37 1
a37 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.13 2006/01/18 06:46:24 brlcad Exp $ (BRL)";
@


14.13
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.12 2005/12/08 01:50:32 brlcad Exp $ (BRL)";
@


14.12
log
@k&r -> C
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.11 2005/10/23 04:44:38 brlcad Exp $ (BRL)";
@


14.11
log
@trailing ws
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.10 2005/07/27 20:33:14 brlcad Exp $ (BRL)";
d152 1
a152 2
view_2init( ap )
struct application	*ap;
@


14.10
log
@irix compiler doesn't like setting the two pointers to NULL at the same time, plus the cast wasn't right anyways.
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.9 2005/06/23 01:22:18 brlcad Exp $ (BRL)";
d102 1
a102 1
};    
d149 1
a149 1
 * 
d164 1
a164 1
	
d206 1
a206 1
 * used for regions. 
d214 1
a214 1
    
d315 1
a315 1
    
d369 1
a369 1
    
d462 1
a462 1
		
d515 1
a515 1
	
d522 1
a522 1
	
d532 1
a532 1
	    
d544 1
a544 1
	    
d548 1
a548 1
	    
d556 1
a556 1
	    
d560 1
a560 1
    
@


14.10.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header$ (BRL)";
d102 1
a102 1
};
d149 1
a149 1
 *
d164 1
a164 1

d206 1
a206 1
 * used for regions.
d214 1
a214 1

d315 1
a315 1

d369 1
a369 1

d462 1
a462 1

d515 1
a515 1

d522 1
a522 1

d532 1
a532 1

d544 1
a544 1

d548 1
a548 1

d556 1
a556 1

d560 1
a560 1

@


14.9
log
@now the assemblies are sorted too.  each depth is independently sorted.
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.8 2005/06/22 23:33:26 brlcad Exp $ (BRL)";
d665 2
a666 1
	    cell = (struct area *)rp->reg_name = (genptr_t)NULL;
@


14.9.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.10 2005/07/27 20:33:14 brlcad Exp $ (BRL)";
d665 1
a665 2
	    cell = (genptr_t)NULL;
	    rp->reg_name = (genptr_t)NULL;
@


14.8
log
@refactor the two assembly printing sections into one function, print_assembly_area_list
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.7 2005/06/22 23:12:51 brlcad Exp $ (BRL)";
d515 46
d568 4
a571 7
	
    rp = BU_LIST_FIRST(region, &(rtip->HeadRegion));
    cell = (struct area *)rp->reg_udata;
    depth = max_depth;
    while (depth >= 0) {
	for (cellp = cell->assembly; cellp; cellp = cellp->assembly) {
	    int counted_items;
d573 5
a577 2
	    if (type == PRESENTED_AREA) {
		counted_items = cellp->hits;
d579 1
a579 12
	    if (type == EXPOSED_AREA) {
		counted_items = cellp->exposures;
	    }
	    if (counted_items && depth == cellp->depth) {
		int indents = max_depth - depth;
		while (indents-- > 0) {
		    if (indents % 2) {
			bu_log("++");
		    } else {
			bu_log("--");
		    }
		}
d581 5
a585 8
		if (type == PRESENTED_AREA) {
		    bu_log("Assembly %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cellp->name, cellp->hits, cell_area * (fastf_t)cellp->hits, cell_area * (fastf_t)cellp->hits / 1000000.0);
		}
		if (type == EXPOSED_AREA) {
		    bu_log("Assembly %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cellp->name, cellp->exposures, cell_area * (fastf_t)cellp->exposures, cell_area * (fastf_t)cellp->exposures / 1000000.0);
		}
		count++;
	    }
d587 3
a589 1
	depth--;
d591 1
a611 1
    int depth;
@


14.7
log
@refactor the two assembly book-keeping functions into just one using the area type enum type.  also fix the previous refactoring's count of region encounters.
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.6 2005/06/22 22:55:49 brlcad Exp $ (BRL)";
d495 67
a583 5
    struct area_list *listHead = (struct area_list *)bu_malloc(sizeof(struct area_list), "view_end area list node allocation");
    struct area_list *listp;
    listHead->cell = (struct area *)NULL;
    listHead->next = (struct area_list *)NULL;

d596 1
a596 20
    bu_log("\nPresented Assembly Areas\n========================\n");
    cell = (struct area *)rp->reg_udata;
    depth = max_depth;
    while (depth >= 0) {
	for (cellp = cell->assembly; cellp; cellp = cellp->assembly) {
	    if (cellp->hits && depth == cellp->depth) {
		int indents = max_depth - depth;
		while (indents-- > 0) {
		    if (indents % 2) {
			bu_log("++");
		    } else {
			bu_log("--");
		    }
		}
		bu_log("Assembly %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cellp->name, cellp->hits, cell_area * (fastf_t)cellp->hits, cell_area * (fastf_t)cellp->hits / 1000000.0);
		presented_assembly_count++;
	    }
	}
	depth--;
    }
d598 1
a598 20
    bu_log("\nExposed Assembly Areas\n======================\n");
    cell = (struct area *)rp->reg_udata;
    depth = max_depth;
    while (depth >= 0) {
	for (cellp = cell->assembly; cellp; cellp = cellp->assembly) {
	    if (cellp->exposures && depth == cellp->depth) {
		int indents = max_depth - depth;
		while (indents-- > 0) {
		    if (indents % 2) {
			bu_log("++");
		    } else {
			bu_log("--");
		    }
		}
		bu_log("Assembly %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cellp->name, cellp->exposures, cell_area * (fastf_t)cellp->exposures, cell_area * (fastf_t)cellp->exposures / 1000000.0);
		exposed_assembly_count++;
	    }
	}
	depth--;
    }
@


14.6
log
@refactor the printing of region areas to a function
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.5 2005/06/22 22:31:04 brlcad Exp $ (BRL)";
d109 6
d204 4
d209 1
a209 1
increment_assembly_exposures(struct area *cell, const char *path)
d214 1
a214 1

d220 1
a220 1
    buffer = bu_calloc(l+1, sizeof(char), "increment_assembly_exposures buffer allocation");
a230 1
    l--;
d242 11
a252 2
		    if (!cellp->seen) {
			cellp->exposures++;
d273 1
a273 1
		name = (char *)bu_malloc(strlen(&buffer[l])+1, "increment_assembly_exposures assembly name allocation");
d276 2
a277 4
		cellp->exposures++;
		cellp->seen++;
		if (depth > cellp->depth) {
		    cellp->depth = depth;
d279 1
a279 51

		/* allocate space for the next assembly */
		cellp->assembly = (struct area *)bu_calloc(1, sizeof(struct area), "increment_assembly_exposures assembly allocation");
	    }

	    buffer[l-1] = '\0';
	    depth++;
	}
	l--;
    }

    bu_free(buffer, "increment_assembly_exposures buffer free");

    return;
}


static void
increment_assembly_hits(register struct area *cell, const char *path)
{
    int l;
    char *buffer;
    int depth;
    
    if (!cell || !path) {
	return;
    }

    l = strlen(path);
    buffer = bu_calloc(l+1, sizeof(char), "increment_assembly_hits buffer allocation");
    strncpy(buffer, path, l);

    /* trim off the region name */
    while (l > 0) {
	if (buffer[l-1] == '/') {
	    break;
	}
	l--;
    }
    buffer[l-1] = '\0';

    /* get the region names, one at a time */
    depth = 0;
    while (l > 0) {
	if (buffer[l-1] == '/') {
	    register struct area *cellp;

	    /* scan the assembly list */
	    cellp = cell->assembly;
	    while (cellp->name) {
		if ( (strcmp(cellp->name, &buffer[l])==0) ) {
a280 5
		    cellp->seen++;
		    if (depth > cellp->depth) {
			cellp->depth = depth;
		    }
		    break;
a281 17
		cellp = cellp->assembly;
	    }

	    /* insert a new assembly? */
	    if (!cellp->name) {
		char *name;

		/* sanity check */
		if (cellp->assembly) {
		    bu_log("Inconsistent assembly list detected\n");
		    break;
		}

		name = (char *)bu_malloc(strlen(&buffer[l])+1, "increment_assembly_hits assembly name allocation");
		strcpy(name, &buffer[l]);
		cellp->name = name;
		cellp->hits++;
d288 1
a288 1
		cellp->assembly = (struct area *)bu_calloc(1, sizeof(struct area), "increment_assembly_hits assembly allocation");
d297 1
a297 1
    bu_free(buffer, "increment_assembly_hits buffer free");
d363 1
a363 1
	    increment_assembly_exposures(cell, reg->reg_name);
d395 1
a395 1
	increment_assembly_hits(cell, reg->reg_name);
a413 6
typedef enum area_type {
    PRESENTED_AREA,
    EXPOSED_AREA
} area_type_t;


d421 2
a422 2
static long
print_region_area_list(long *count, struct rt_i *rtip, area_type_t type)
d426 1
a426 1
    long cumulative = 0;
d465 1
a465 1
		    *count++;
a522 1

@


14.5
log
@Shazam.  This makes a fairly extensive improvement (pretty much a rewrite) of rtarea to report both the presented and exposed area projections for both regions and assemblies.  The regions are sorted alphabetically, the assemblies are indented by maximum encountered visitation depth (which isn't the same as the construction hierarchy, but good enough for organizing the list somewhat), and the number of hits are reported as well.  more work is needed to alphabetize the assembly levels as well as reduce some of the code duplication.
@
text
@d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.4 2005/04/22 05:44:15 brlcad Exp $ (BRL)";
d470 7
a476 2
/*
 *			V I E W _ E N D
d478 4
d483 2
a484 2
void
view_end(struct application *ap)
d486 2
a487 3
    register struct region *rp;
    struct rt_i *rtip = ap->a_rt_i;
    fastf_t total_area=0.0;
a488 1
    register struct area *cell = (struct area *)NULL;
d490 1
a490 10
    int max_depth = 0;
    struct area *cellp;
    int depth;

    long int presented_region_count = 0;
    long int presented_assembly_count = 0;
    long int exposed_region_count = 0;
    long int exposed_assembly_count = 0;

    struct area_list *listHead = (struct area_list *)bu_malloc(sizeof(struct area_list), "view_end area list node allocation");
d513 1
a513 1
		newNode = (struct area_list *)bu_malloc(sizeof(struct area_list), "view_end area list node allocation");
d526 3
a528 1
		presented_region_count++;
d532 7
a538 1
    bu_log("\nPresented Region Areas\n======================\n");
d542 6
a547 1
	bu_log("Region %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cell->name, cell->hits, cell_area * (fastf_t)cell->hits, cell_area * (fastf_t)cell->hits / 1000000.0);
d549 1
a549 1
	bu_free(prev, "view_end area list node free");
d551 1
a551 1
    bu_free(listp, "view_end area list node free");
d553 2
a554 3
    listHead = (struct area_list *)bu_malloc(sizeof(struct area_list), "view_end area list node allocation");
    listHead->cell = (struct area *)NULL;
    listHead->next = (struct area_list *)NULL;
a555 3
    for( BU_LIST_FOR( rp, region, &(rtip->HeadRegion) ) )  {
	cell = (struct area *)rp->reg_udata;
	listp = listHead;
d557 12
a568 4
	if (cell) {
	    if (cell->exposures > 0) {
		struct area_list *prev = (struct area_list *)NULL;
		struct area_list *newNode;
d570 3
a572 7
		while (listp->next) {
		    if (!listp->cell || (strcmp(cell->name, listp->cell->name) < 0)) {
			break;
		    }
		    prev = listp;
		    listp = listp->next;
		}
d574 4
a577 3
		newNode = (struct area_list *)bu_malloc(sizeof(struct area_list), "view_end area list node allocation");
		newNode->cell = cell;
		newNode->next = (struct area_list *)NULL;
d579 4
a582 7
		if (!prev) {
		    listHead = newNode;
		    newNode->next = listp;
		} else {
		    newNode->next = prev->next;
		    prev->next = newNode;
		}
d584 1
a584 13
		exposed_region_count++;
	    }
	}
    }
    bu_log("\nExposed Region Areas\n====================\n");
    for (listp = listHead; listp->cell != NULL;) {
	struct area_list *prev = listp;
	cell = listp->cell;
	bu_log("Region %s\t(%ld hits)\t= %18.4lf square mm\t(%.4lf square meters)\n", cell->name, cell->exposures, cell_area * (fastf_t)cell->exposures, cell_area * (fastf_t)cell->exposures / 1000000.0);
	listp = listp->next;
	bu_free(prev, "view_end area list node free");
    }
    bu_free(listp, "view_end area list node free");
d586 1
d657 1
a657 1
		bu_free((char *)cell->name, "viewend assembly name free");
d659 1
a659 1
	    bu_free(cell, "viewend assembly free");
d669 1
a669 1
	    bu_free(cell, "viewend area free");
@


14.4
log
@if we're on a system that needs to USE_FORKED_THREADS to get proper statistics computations, it means that we cannot use global variables to store values so force rtarea to a single CPU so that we at least get the area
@
text
@d22 14
d38 1
a38 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.3 2005/01/30 20:31:10 brlcad Exp $ (BRL)";
a42 2


d47 1
a47 1
#include <string.h>
d49 1
a49 1
#include <strings.h>
d95 14
d126 1
a126 1
	ap->a_onehit = 1;
d149 7
a155 1
	cell_area = cell_width * cell_height;
d157 14
a170 1
	return;
d197 162
d366 88
a453 1
	register struct partition *pp = PartHeadp->pt_forw;
d455 2
a456 6
	if( pp == PartHeadp )
		return(0);		/* nothing was actually hit?? */

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	hit_count++;
	bu_semaphore_release( BU_SEM_SYSCALL );
a457 2
	return(0);
}
d469 1
d477 198
a674 3
	fastf_t total_area=0.0;

	total_area = cell_area * (fastf_t)hit_count;
d676 1
a676 1
	bu_log( "Area = %g square mm (%g square meters)\n\n", total_area, total_area / 1000000.0 );
@


14.3
log
@update copyright to 2005
@
text
@d24 1
a24 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.2 2004/12/24 01:40:00 brlcad Exp $ (BRL)";
d83 2
a84 1
int	rayhit(), raymiss();
a89 1

d91 1
a91 3
view_init( ap, file, obj, minus_o )
register struct application *ap;
char *file, *obj;
d93 5
a97 1

d107 2
d116 1
a116 1
 *  main() in rt.c.  It writes the view-specific COVART header.
a122 2
	hit_count = 0;

d136 1
a136 1
raymiss()
d157 1
a157 3
rayhit( ap, PartHeadp )
struct application *ap;
register struct partition *PartHeadp;
a167 1

d186 1
a186 1
view_end()
a189 1

d192 1
a192 1
	bu_log( "Area = %g square mm (%g square meters)\n", total_area, total_area / 1000000.0 );
@


14.2
log
@add the mysteriously missing gpl header..
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d24 1
a24 1
static const char RCSrayg3[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewarea.c,v 14.1 2004/11/16 19:42:31 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			V I E W A R E A
d24 1
a24 1
static const char RCSrayg3[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewarea.c,v 1.3 2004/09/03 23:30:59 morrison Exp $ (BRL)";
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d5 1
a5 1
static const char RCSrayg3[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewarea.c,v 1.2 2004/08/02 23:01:52 morrison Exp $ (BRL)";
d181 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d5 1
a5 1
static const char RCSrayg3[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewarea.c,v 1.1 2004/05/20 15:20:46 morrison Exp $ (BRL)";
d15 1
a15 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d5 1
a5 1
static const char RCSrayg3[] = "@@(#)$Header: /cvs/brlcad/rt/viewarea.c,v 11.2 2004/05/10 15:30:49 erikg Exp $ (BRL)";
d8 1
a8 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

