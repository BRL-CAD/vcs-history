head	14.12;
access;
symbols
	rel-7-10-4:14.12
	STABLE:14.12.0.2
	stable-branch:14.3
	rel-7-10-2:14.12
	rel-7-10-0:14.12
	rel-7-8-4:14.10
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.3
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.4
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.12
date	2007.01.23.01.13.45;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.37.00;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.04.05.19.54.27;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.02.27.10.08.41;	author brlcad;	state Exp;
branches
	14.9.2.1;
next	14.8;

14.8
date	2006.01.20.22.43.55;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.12.31.02.17.08;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.12.08.01.40.57;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.09.19.18.02.09;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.09;	author brlcad;	state Exp;
branches
	14.3.6.1;
next	14.2;

14.2
date	2004.12.24.01.40.00;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.24.14.51.29;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.45;	author morrison;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;

14.9.2.1
date	2006.04.07.19.34.23;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@/*                     R T E X A M P L E . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file rtexample.c
 *
 *  A trivial example of a program that uses librt to shoot a single
 *  ray at some geometry in a .g database.  With lots of comments.
 *
 *  This file is part of the default compile in source distributions
 *  of BRL-CAD and is usually installed or provided via binary and
 *  source distributions.  To compile this example from a binary
 *  install:
 *
 *  cc -I/usr/brlcad/include/brlcad -L/usr/brlcad/lib -o rtexample rtexample.c -lbu -lrt -lm
 *
 */
#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "machine.h"		/* machine specific definitions */
#include "vmath.h"		/* vector math macros */
#include "raytrace.h"		/* librt interface definitions */
#include "rtprivate.h"


/* routines for shootray() to call on hit or miss */
extern int hit(struct application *ap, struct partition *PartHeadp, struct seg *segs);
extern int miss(register struct application *ap);


char	usage[] = "\
Usage:  rtexample model.g objects...\n";

int
main(int argc, char **argv)
{
    /* every application needs one of these */
    struct application	ap;

    static struct rt_i *rtip;	/* rt_dirbuild returns this */
    char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */

    if( argc < 3 )  {
	(void)fputs(usage, stderr);
	return 1;
    }

    /*
     *  Load database.
     *  rt_dirbuild() returns an "instance" pointer which describes
     *  the database to be ray traced.  It also gives you back the
     *  title string in the header (ID) record.
     */
    if( (rtip=rt_dirbuild(argv[1], idbuf, sizeof(idbuf))) == RTI_NULL ) {
	fprintf(stderr,"rtexample: rt_dirbuild failure\n");
	return 2;
    }

    /* intialize the application structure to all zeros */
    RT_APPLICATION_INIT(&ap);

    ap.a_rt_i = rtip;	/* your application uses this instance */
    fprintf(stderr, "db title: %s\n", idbuf);

    /* Walk trees.
     * Here you identify any object trees in the database that you
     * want included in the ray trace.
     */
    while( argc > 2 )  {
	if( rt_gettree(rtip, argv[2]) < 0 )
	    fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[0]);
	argc--;
	argv++;
    }
    /*
     * This next call gets the database ready for ray tracing.
     * (it precomputes some values, sets up space partitioning, etc.)
     */
    rt_prep_parallel(rtip,1);

    /*
     * Set the ray start point and direction
     * rt_shootray() uses these two to determine what ray to fire.
     * In this case we simply shoot down the z axis toward the
     * origin from 10 meters away [librt assumes units of millimeters.
     * not that is really maters here, but an MGED database made with
     * units=mm will have the same values in the file (and thus in
     * librt) that you see displayed by MGED.
     */
    VSET( ap.a_ray.r_pt, 0, 0, 10000 );
    VSET( ap.a_ray.r_dir, 0, 0, -1 );

    VPRINT( "Pnt", ap.a_ray.r_pt );
    VPRINT( "Dir", ap.a_ray.r_dir );

    /* Shoot Ray */
    ap.a_hit = hit;			/* where to go on a hit */
    ap.a_miss = miss;		/* where to go on a miss */
    (void)rt_shootray( &ap );	/* do it */

    /*
     * A real application would probably set up another
     * ray and fire again.
     */

    return(0);
}


/*
 *  rt_shootray() was told to call this on a hit.  He gives up the
 *  application structure which describes the state of the world
 *  (see raytrace.h), and a circular linked list of partitions,
 *  each one describing one in and out segment of one region.
 */
int
hit(register struct application *ap, struct partition *PartHeadp, struct seg *segs)
{
    /* see raytrace.h for all of these guys */
    register struct partition *pp;
    register struct hit *hitp;
    register struct soltab *stp;
    struct curvature cur;
    point_t		pt;
    vect_t		inormal;
    vect_t		onormal;

    /* examine each partition until we get back to the head */
    for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
	bu_log("\n--- Hit region %s (in %s, out %s)\n",
	       pp->pt_regionp->reg_name,
	       pp->pt_inseg->seg_stp->st_name,
	       pp->pt_outseg->seg_stp->st_name );

	/* inhit info */
	hitp = pp->pt_inhit;
	stp = pp->pt_inseg->seg_stp;

	VJOIN1( pt, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );

	/* This macro takes care of the flip flag and all that */
	RT_HIT_NORMAL( inormal, hitp, stp, &(ap->a_ray), pp->pt_inflip );

	rt_pr_hit( "  In", hitp );
	VPRINT(    "  Ipoint", pt );
	VPRINT(    "  Inormal", inormal );
	/*
	 * This next macro fills in the curvature information
	 * which consists on a principle direction vector, and
	 * the inverse radii of curvature along that direction
	 * and perpendicular to it.  Positive curvature bends
	 * toward the outward pointing normal.
	 */
	RT_CURVATURE( &cur, hitp, pp->pt_inflip, stp );
	VPRINT("PDir", cur.crv_pdir );
	bu_log(" c1=%g\n", cur.crv_c1);
	bu_log(" c2=%g\n", cur.crv_c2);

	/* outhit info */
	hitp = pp->pt_outhit;
	stp = pp->pt_outseg->seg_stp;
	VJOIN1( pt, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
	RT_HIT_NORMAL( onormal, hitp, stp, &(ap->a_ray), pp->pt_outflip );

	rt_pr_hit( "  Out", hitp );
	VPRINT(    "  Opoint", pt );
	VPRINT(    "  Onormal", onormal );
    }

    /*
     * A more complicated application would probably fill in a
     * new local application structure and describe say a reflected
     * or refracted ray, and then call rt_shootray with it.
     */

    /*
     * This value is returned by rt_shootray
     * a hit usually returns 1, miss 0.
     */
    return(1);
}


/*
 * rt_shootray() was told to call this on a miss.
 */
int
miss(register struct application *ap)
{
    bu_log("missed\n");
    return(0);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.11
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.10
log
@more header/warning cleanup from Intel compiler warnings on Altix
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


14.9
log
@stdlib.h and exit()
@
text
@d39 1
d137 1
d208 1
@


14.9.2.1
log
@update from HEAD
@
text
@a38 1
#include <string.h>
a135 1
int
a205 1
int
@


14.8
log
@main returns an int
@
text
@d36 1
d65 1
a65 1
	exit(1);
d76 1
a76 1
	exit(2);
@


14.7
log
@update copyright to 2006
@
text
@d53 1
@


14.6
log
@add more comments on what the file is and its purpose, fix the compile example so that it works on an installed brl-cad too
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


14.5
log
@make the application structure non-global, use RT_APPLICATION_INIT; ws
@
text
@d23 9
a31 1
 *  A trivial example of a program that uses librt.  With comments.
a32 1
 *    cc -I/usr/include/brlcad -o rtexample rtexample.c librt.a -lm
@


14.4
log
@use RT_BUFSIZE define from rtprivate.h instead of constant 132
@
text
@a37 3
/* every application needs one of these */
struct application	ap;

d42 1
d48 2
a49 7
	static struct rt_i *rtip;	/* rt_dirbuild returns this */
	char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */

	if( argc < 3 )  {
		(void)fputs(usage, stderr);
		exit(1);
	}
d51 2
a52 28
	/*
	 *  Load database.
	 *  rt_dirbuild() returns an "instance" pointer which describes
	 *  the database to be ray traced.  It also gives you back the
	 *  title string in the header (ID) record.
	 */
	if( (rtip=rt_dirbuild(argv[1], idbuf, sizeof(idbuf))) == RTI_NULL ) {
		fprintf(stderr,"rtexample: rt_dirbuild failure\n");
		exit(2);
	}
	ap.a_rt_i = rtip;	/* your application uses this instance */
	fprintf(stderr, "db title: %s\n", idbuf);

	/* Walk trees.
	 * Here you identify any object trees in the database that you
	 * want included in the ray trace.
	 */
	while( argc > 2 )  {
		if( rt_gettree(rtip, argv[2]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[0]);
		argc--;
		argv++;
	}
	/*
	 * This next call gets the database ready for ray tracing.
	 * (it precomputes some values, sets up space partitioning, etc.)
	 */
	rt_prep_parallel(rtip,1);
d54 62
a115 11
	/*
	 * Set the ray start point and direction
	 * rt_shootray() uses these two to determine what ray to fire.
	 * In this case we simply shoot down the z axis toward the
	 * origin from 10 meters away [librt assumes units of millimeters.
	 * not that is really maters here, but an MGED database made with
	 * units=mm will have the same values in the file (and thus in
	 * librt) that you see displayed by MGED.
	 */
	VSET( ap.a_ray.r_pt, 0, 0, 10000 );
	VSET( ap.a_ray.r_dir, 0, 0, -1 );
d117 2
a118 2
	VPRINT( "Pnt", ap.a_ray.r_pt );
	VPRINT( "Dir", ap.a_ray.r_dir );
a119 12
	/* Shoot Ray */
	ap.a_hit = hit;			/* where to go on a hit */
	ap.a_miss = miss;		/* where to go on a miss */
	(void)rt_shootray( &ap );	/* do it */

	/*
	 * A real application would probably set up another
	 * ray and fire again.
	 */

	return(0);
}
d129 63
a191 50
	/* see raytrace.h for all of these guys */
	register struct partition *pp;
	register struct hit *hitp;
	register struct soltab *stp;
	struct curvature cur;
	point_t		pt;
	vect_t		inormal;
	vect_t		onormal;

	/* examine each partition until we get back to the head */
	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
		bu_log("\n--- Hit region %s (in %s, out %s)\n",
			pp->pt_regionp->reg_name,
			pp->pt_inseg->seg_stp->st_name,
			pp->pt_outseg->seg_stp->st_name );

		/* inhit info */
		hitp = pp->pt_inhit;
		stp = pp->pt_inseg->seg_stp;

		VJOIN1( pt, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );

		/* This macro takes care of the flip flag and all that */
		RT_HIT_NORMAL( inormal, hitp, stp, &(ap->a_ray), pp->pt_inflip );

		rt_pr_hit( "  In", hitp );
		VPRINT(    "  Ipoint", pt );
		VPRINT(    "  Inormal", inormal );
		/*
		 * This next macro fills in the curvature information
		 * which consists on a principle direction vector, and
		 * the inverse radii of curvature along that direction
		 * and perpendicular to it.  Positive curvature bends
		 * toward the outward pointing normal.
		 */
		RT_CURVATURE( &cur, hitp, pp->pt_inflip, stp );
		VPRINT("PDir", cur.crv_pdir );
		bu_log(" c1=%g\n", cur.crv_c1);
		bu_log(" c2=%g\n", cur.crv_c2);

		/* outhit info */
		hitp = pp->pt_outhit;
		stp = pp->pt_outseg->seg_stp;
		VJOIN1( pt, ap->a_ray.r_pt, hitp->hit_dist, ap->a_ray.r_dir );
		RT_HIT_NORMAL( onormal, hitp, stp, &(ap->a_ray), pp->pt_outflip );

		rt_pr_hit( "  Out", hitp );
		VPRINT(    "  Opoint", pt );
		VPRINT(    "  Onormal", onormal );
	}
a192 12
	/*
	 * A more complicated application would probably fill in a
	 * new local application structure and describe say a reflected
	 * or refracted ray, and then call rt_shootray with it.
	 */

	/*
	 * This value is returned by rt_shootray
	 * a hit usually returns 1, miss 0.
	 */
	return(1);
}
d199 2
a200 2
	bu_log("missed\n");
	return(0);
@


14.3
log
@update copyright to 2005
@
text
@a28 2


d31 1
d35 2
d51 1
a51 1
	char idbuf[132];		/* First ID record info */
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 2
a32 1

a35 2
#include "rtprivate.h"

d50 1
a50 1
	char idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
@


14.2
log
@add the mysteriously missing gpl header..
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			R T E X A M P L E . C
@


1.3
log
@help make distcheck get a whole lot farther ..
@
text
@d175 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d22 2
a23 1
extern int hit(struct application *ap, struct partition *PartHeadp), miss(register struct application *ap);
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d8 1
a8 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

