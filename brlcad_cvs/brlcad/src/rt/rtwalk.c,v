head	14.14;
access;
symbols
	rel-7-10-4:14.11
	STABLE:14.11.0.2
	stable-branch:14.4
	rel-7-10-2:14.11
	rel-7-10-0:14.11
	rel-7-8-4:14.9
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.5
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.14
date	2007.11.21.20.49.11;	author erikgreenwald;	state Exp;
branches;
next	14.13;

14.13
date	2007.11.21.19.28.07;	author erikgreenwald;	state Exp;
branches;
next	14.12;

14.12
date	2007.09.15.16.23.20;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.46;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.37.00;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.02.27.10.08.41;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.28.00.36.29;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.12.08.01.47.09;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.09.19.18.02.09;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.09;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.24.01.40.00;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.38.22;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.16.03.13.13;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.35;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.46;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.14
log
@pass bu_exit a NULL instead of an empty string
@
text
@/*                        R T W A L K . C
 * BRL-CAD
 *
 * Copyright (c) 1987-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file rtwalk.c
 *
 *  Demonstration Ray Tracing main program, using RT library.
 *  Walk a path *without running into any geometry*,
 *  given the start and goal points.
 *
 *  Authors -
 *	Michael John Muuss
 *	Robert J. Reschly, Jr.
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.13 2007/11/21 19:28:07 erikgreenwald Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtprivate.h"
#include "../librt/debug.h"
#include "plot3.h"


char	usage[] = "\
Usage:  rtwalk [options] startXYZ destXYZ model.g objects...\n\
 -X #		Set debug flags\n\
	1	plots on stdout\n\
	2	plots, attempts in red\n\
	3	all plots, plus printing\n\
 -x #		Set librt debug flags\n\
 -n #		Number of steps\n\
 -v #		Viewsize\n\
(output is rtwalk.mats)\n\
";

double		viewsize = 42;

/*
 *	0 - off
 *	1 - plots
 *	2 - plots with attempted rays in red
 *	3 - lots of printfs too
 */

int		npsw = 1;		/* Run serially */
int		interactive = 0;	/* human is watching results */

point_t		start_point;
point_t		goal_point;

vect_t		dir_prev_step;		/* Dir used on last step */
point_t		pt_prev_step;
vect_t		norm_prev_step = {0, 0, 0};

vect_t		norm_cur_try;		/* normal vector at current hit pt */
point_t		hit_cur_try;
struct curvature curve_cur;

int		nsteps = 10;
fastf_t		incr_dist;
double		clear_dist = 0.0;
double		max_dist_togo;

extern int hit(struct application *ap, struct partition *PartHeadp, struct seg *segp);
extern int miss(register struct application *ap);

FILE		*plotfp;
FILE		*outfp = NULL;

void		proj_goal(struct application *ap);
void		write_matrix(int frame);

/*
 *			G E T _ A R G S
 */
int
get_args(int argc, register char **argv)
{
    register int c;

    while( (c=bu_getopt( argc, argv, "x:X:n:v:" )) != EOF )  {
	switch( c )  {
	    case 'x':
		sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
		fprintf(stderr,"librt rt_g.debug=x%x\n", rt_g.debug);
		break;
	    case 'X':
		sscanf( bu_optarg, "%x", (unsigned int *)&rdebug );
		fprintf(stderr,"rt rdebug=x%x\n", rdebug);
		break;

	    case 'n':
		nsteps = atoi( bu_optarg );
		break;
	    case 'v':
		viewsize = atof( bu_optarg );
		break;

	    default:		/* '?' */
		fprintf(stderr,"unknown option %c\n", c);
		return(0);	/* BAD */
	}
    }
    return(1);			/* OK */
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
    struct application	ap;

    static struct rt_i *rtip;
    char	*title_file;
    char	idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
    int	curstep;
    vect_t	first_dir;		/* First dir chosen on a step */
    int	i;

    bu_semaphore_init( RT_SEM_LAST );

    if ( !get_args( argc, argv ) )  {
	(void)fputs(usage, stderr);
	bu_exit(1, NULL);
    }
    if( bu_optind+7 >= argc )  {
	(void)fputs(usage, stderr);
	bu_exit(1, NULL);
    }

    RT_APPLICATION_INIT(&ap);

    /* Start point */
    start_point[X] = atof( argv[bu_optind] );
    start_point[Y] = atof( argv[bu_optind+1] );
    start_point[Z] = atof( argv[bu_optind+2] );

    /* Destination point */
    goal_point[X] = atof( argv[bu_optind+3] );
    goal_point[Y] = atof( argv[bu_optind+4] );
    goal_point[Z] = atof( argv[bu_optind+5] );
    bu_optind += 6;

    VSUB2( first_dir, goal_point, start_point );
    incr_dist = MAGNITUDE(first_dir) / nsteps;
    VMOVE( ap.a_ray.r_pt, start_point );
    VMOVE( ap.a_ray.r_dir, first_dir );
    VUNITIZE( ap.a_ray.r_dir );	/* initial dir, for dir_prev_step */

    fprintf(stderr,"nsteps = %d, incr_dist = %gmm\n", nsteps, incr_dist );
    fprintf(stderr,"viewsize = %gmm\n", viewsize);

    /* Load database */
    title_file = argv[bu_optind++];
    if( (rtip=rt_dirbuild(title_file, idbuf, sizeof(idbuf))) == RTI_NULL ) {
	fprintf(stderr,"rtwalk:  rt_dirbuild failure\n");
	bu_exit(2, NULL);
    }
    ap.a_rt_i = rtip;
    fprintf(stderr, "db title:  %s\n", idbuf);

    /* Walk trees */
    for( i=bu_optind; i < argc; i++ )  {
	if( rt_gettree(rtip, argv[bu_optind]) < 0 )
	    fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[bu_optind]);
	bu_optind++;
    }

    /* Prep finds the model RPP, needed for the plotting step */
    rt_prep(rtip);

    /*
     *  With stdout for the plot file, and stderr for
     *  remarks, the output must go into a file.
     */
    if( (outfp=fopen("rtwalk.mats", "w")) == NULL )  {
	perror("rtwalk.mats");
	bu_exit(1, NULL);
    }
    plotfp = stdout;

    /* Plot all of the solids */
    if( R_DEBUG > 0 )  {
	pl_color( plotfp, 150, 150, 150 );
	rt_plot_all_solids( plotfp, rtip, &rt_uniresource );
    }

    /* Take a walk */
    for( curstep = 0; curstep < nsteps*4; curstep++ )  {
	mat_t	mat;
	int	failed_try;

	/*
	 *  In order to be able to compute deltas from the
	 *  previous to the current step, here we handle
	 *  the results of the last iteration.
	 *  The first and last iterations result in no output
	 */
	if(R_DEBUG>=3) {
	    VPRINT("pos", ap.a_ray.r_pt);
	}
	if( curstep > 0 )  {
	    if( R_DEBUG > 0 )  {
		if( curstep&1 )
		    pl_color( plotfp, 0, 255, 0 );
		else
		    pl_color( plotfp, 0, 0, 255 );
		pdv_3line( plotfp,
			   pt_prev_step, ap.a_ray.r_pt );
	    }
	    write_matrix(curstep);
	}
	VMOVE( pt_prev_step, ap.a_ray.r_pt );
	VMOVE( dir_prev_step, ap.a_ray.r_dir );
	VSETALL( norm_cur_try, 0 );	/* sanity */

	/* See if goal has been reached */
	VSUB2( first_dir, goal_point, ap.a_ray.r_pt );
	if( (max_dist_togo=MAGNITUDE(first_dir)) < 1.0 )  {
	    fprintf(stderr,"Complete in %d steps\n", curstep);
	    bu_exit(0, NULL);
	}

	/*  See if there is significant clear space ahead
	 *  Avoid taking small steps.
	 */
	if( clear_dist < incr_dist * 0.25 )
	    clear_dist = 0.0;
	if( clear_dist > 0.0 )
	    goto advance;

	/*
	 * Initial direction:  Head directly towards the goal.
	 */
	VUNITIZE( first_dir );
	VMOVE( ap.a_ray.r_dir, first_dir );

	for( failed_try=0; failed_try<100; failed_try++ )  {
	    vect_t	out;
	    int	i;

	    /* Shoot Ray */
	    if(R_DEBUG>=3)fprintf(stderr,"try=%d, maxtogo=%g  ",
				  failed_try, max_dist_togo);
	    ap.a_hit = hit;
	    ap.a_miss = miss;
	    ap.a_onehit = 1;
	    if( rt_shootray( &ap ) == 0 )  {
		/* A miss, the way is clear all the way */
		clear_dist = max_dist_togo*2;
		break;
	    }
	    /* Hit, check distance to closest obstacle */
	    if( clear_dist >= incr_dist )  {
		/* Clear for at least one more step.
		 * Zap memory of prev normal --
		 * this probe ahead does not count.
		 * Current normal has no significance,
		 * because object is more than one step away.
		 */
		VSETALL( norm_cur_try, 0 );
		break;
	    }
	    /*
	     * Failed, try another direction
	     */

	    if(R_DEBUG > 2 )   {
		/* Log attempted ray in Red */
		VJOIN1( out, ap.a_ray.r_pt,
			incr_dist*4, ap.a_ray.r_dir );
		pl_color( plotfp, 255, 0, 0 );
		pdv_3line( plotfp,
			   pt_prev_step, out );
	    }

	    /* Initial try was in direction of goal, it failed. */
	    if( failed_try == 0 )  {
		/*  First recovery attempt.
		 *  If hit normal has not changed, continue
		 *  the direction of the last step.
		 *  Otherwise, head on tangent plane.
		 */
		if( VEQUAL( norm_cur_try, norm_prev_step ) )  {
		    if(R_DEBUG>=3)fprintf(stderr,
					  "Try prev dir\n");
		    VMOVE( ap.a_ray.r_dir, dir_prev_step );
		    continue;
		}
		if(R_DEBUG>=3)fprintf(stderr,"Try tangent\n");
		proj_goal(&ap);
		continue;
	    } else if( failed_try <= 7 )  {
		/* Try 7 azimuthal escapes, 1..7 */
		i = failed_try-1+1;	/*  1..7 */
		if(R_DEBUG>=3)fprintf(stderr,"Try az %d\n", i);
		bn_mat_ae( mat, i*45.0, 0.0 );
	    } else if( failed_try <= 14 ) {
		/* Try 7 Elevations to escape, 8..14 */
		i = failed_try-8+1;	/*     1..7 */
		if(R_DEBUG>=3)fprintf(stderr,"Try el %d\n", i);
		bn_mat_ae( mat, 0.0, i*45.0 );
	    } else {
		fprintf(stderr,"trapped, giving up on escape\n");
		bu_exit(1, NULL);
	    }
	    MAT4X3VEC( ap.a_ray.r_dir, mat, first_dir );

	    /*
	     *  If new ray is nearly perpendicular to
	     *  the tangent plane, it is doomed to failure;
	     *  pick any tangent and use that instead.
	     */
	    if( (VDOT( ap.a_ray.r_dir, norm_cur_try )) < -0.9995 )  {
		vect_t	olddir;

		VMOVE( olddir, ap.a_ray.r_dir );
		VCROSS( ap.a_ray.r_dir, olddir, norm_cur_try );
	    }
	}
	if( failed_try > 0 )  {
	    /* Extra trys were required, prevent runaways */
	    if( clear_dist > incr_dist )
		clear_dist = incr_dist;
	}

	/* One simple attempt at not overshooting the goal.
	 * Really should measure distance point-to-line
	 */
	if( clear_dist > max_dist_togo )
	    clear_dist = max_dist_togo;

	/* Advance position along ray */
    advance:	;
	if( clear_dist > 0.0 )  {
	    fastf_t	step;
	    if( clear_dist < incr_dist )
		step = clear_dist;
	    else
		step = incr_dist;
	    VJOIN1( ap.a_ray.r_pt, ap.a_ray.r_pt,
		    step, ap.a_ray.r_dir );
	    clear_dist -= step;
	}

	/* Save status */
	VMOVE( norm_prev_step, norm_cur_try );
    }
    fprintf(stderr,"%d steps used without reaching goal by %gmm\n", curstep, max_dist_togo);
    bu_exit(1, NULL);
}

int hit(register struct application *ap, struct partition *PartHeadp, struct seg *segp)
{
    register struct partition *pp;
    register struct soltab *stp;
    register struct hit *hitp;

    for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
	if( pp->pt_outhit->hit_dist >= 0.0 )  break;
    if( pp == PartHeadp )  {
	bu_log("hit:  no hit out front?\n");
	return(0);
    }
    hitp = pp->pt_inhit;
    stp = pp->pt_inseg->seg_stp;
    VJOIN1( hit_cur_try, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
    RT_HIT_NORMAL( norm_cur_try, hitp, stp, &(ap->a_ray), pp->pt_inflip );
    RT_CURVATURE( &curve_cur, hitp, pp->pt_inflip, stp );

    clear_dist = hitp->hit_dist - 1;	/* Decrease 1mm */

    return(1);	/* HIT */
}

int
miss(register struct application *ap)
{
    return(0);
}

/*
 *			P R O J _ G O A L
 *
 *  When progress towards the goal is blocked by an object,
 *  head off "towards the side" to try to get around.
 *  Project the goal point onto the plane tangent to the object
 *  at the hit point.  Head for the projection of the goal point,
 *  which should keep things moving in the right general direction,
 *  except perhaps for concave objects.
 */
void
proj_goal(struct application *ap)
{
    vect_t	goal_dir;
    vect_t	goal_proj;
    vect_t	newdir;
    fastf_t	k;

    if( VDOT( ap->a_ray.r_dir, norm_cur_try ) < -0.9995 )  {
	/* Projected goal will be right where we are now.
	 * Pick any tangent at all.
	 * Use principle dir of curvature.
	 */
	VMOVE( ap->a_ray.r_dir, curve_cur.crv_pdir );
	return;
    }

    VSUB2( goal_dir, hit_cur_try, goal_point );
    k = VDOT( goal_dir, norm_cur_try );
    VJOIN1( goal_proj, goal_point,
	    k, norm_cur_try );
    VSUB2( newdir, goal_proj, hit_cur_try );
    VUNITIZE( newdir );
    VMOVE( ap->a_ray.r_dir, newdir );
}

/*
 *			W R I T E _ M A T R I X
 */
void
write_matrix(int frame)
{
    fprintf(outfp, "start %d;\n", frame);
    fprintf(outfp, "clean;\n");
    fprintf(outfp, "viewsize %g;\n", viewsize);
    fprintf(outfp, "eye_pt %g %g %g;\n", V3ARGS(pt_prev_step) );
    fprintf(outfp, "lookat_pt %g %g %g  0;\n", V3ARGS(goal_point) );
    fprintf(outfp, "end;\n\n" );
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.13
log
@exit->bu_exit where applicable
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.12 2007/09/15 16:23:20 brlcad Exp $ (BRL)";
d157 1
a157 1
	bu_exit(1, "");
d161 1
a161 1
	bu_exit(1, "");
d190 1
a190 1
	bu_exit(2, "");
d211 1
a211 1
	bu_exit(1, "");
d254 1
a254 1
	    bu_exit(0, "");
d338 1
a338 1
		bu_exit(1, "");
d383 1
a383 1
    bu_exit(1, "");
@


14.12
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.11 2007/01/23 01:13:46 brlcad Exp $ (BRL)";
d157 1
a157 1
	exit(1);
d161 1
a161 1
	exit(1);
d190 1
a190 1
	exit(2);
d211 1
a211 1
	exit(1);
d254 1
a254 1
	    exit(0);
d338 1
a338 1
		exit(1);
d383 1
a383 1
    exit(1);
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.10 2007/01/20 14:37:00 brlcad Exp $ (BRL)";
d45 1
a45 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.9 2006/02/27 10:08:41 brlcad Exp $ (BRL)";
@


14.9
log
@stdlib.h and exit()
@
text
@d4 1
a4 1
 * Copyright (c) 1987-2006 United States Government as represented by
d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.8 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
@


14.8
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.7 2006/01/18 06:46:23 brlcad Exp $ (BRL)";
d46 5
@


14.7
log
@update copyright to 2006
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.6 2005/12/08 01:47:09 brlcad Exp $ (BRL)";
d42 1
@


14.6
log
@make the application structure non-global, use RT_APPLICATION_INIT; ws
@
text
@d4 1
a4 1
 * Copyright (C) 1987-2005 United States Government as represented by
d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.5 2005/09/19 18:02:09 brlcad Exp $ (BRL)";
@


14.5
log
@use RT_BUFSIZE define from rtprivate.h instead of constant 132
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.4 2005/01/30 20:31:09 brlcad Exp $ (BRL)";
a77 2
struct application	ap;

d100 1
a100 1
void		proj_goal(void);
d109 1
a109 1
	register int c;
d111 21
a131 22
	while( (c=bu_getopt( argc, argv, "x:X:n:v:" )) != EOF )  {
		switch( c )  {
		case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
			fprintf(stderr,"librt rt_g.debug=x%x\n", rt_g.debug);
			break;
		case 'X':
			sscanf( bu_optarg, "%x", (unsigned int *)&rdebug );
			fprintf(stderr,"rt rdebug=x%x\n", rdebug);
			break;

		case 'n':
			nsteps = atoi( bu_optarg );
			break;
		case 'v':
			viewsize = atof( bu_optarg );
			break;

		default:		/* '?' */
			fprintf(stderr,"unknown option %c\n", c);
			return(0);	/* BAD */
		}
d133 2
a134 1
	return(1);			/* OK */
d143 1
a143 6
	static struct rt_i *rtip;
	char	*title_file;
	char	idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
	int	curstep;
	vect_t	first_dir;		/* First dir chosen on a step */
	int	i;
d145 6
a150 1
	bu_semaphore_init( RT_SEM_LAST );
d152 1
a152 8
	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit(1);
	}
	if( bu_optind+7 >= argc )  {
		(void)fputs(usage, stderr);
		exit(1);
	}
d154 8
a161 16
	/* Start point */
	start_point[X] = atof( argv[bu_optind] );
	start_point[Y] = atof( argv[bu_optind+1] );
	start_point[Z] = atof( argv[bu_optind+2] );

	/* Destination point */
	goal_point[X] = atof( argv[bu_optind+3] );
	goal_point[Y] = atof( argv[bu_optind+4] );
	goal_point[Z] = atof( argv[bu_optind+5] );
	bu_optind += 6;

	VSUB2( first_dir, goal_point, start_point );
	incr_dist = MAGNITUDE(first_dir) / nsteps;
	VMOVE( ap.a_ray.r_pt, start_point );
	VMOVE( ap.a_ray.r_dir, first_dir );
	VUNITIZE( ap.a_ray.r_dir );	/* initial dir, for dir_prev_step */
d163 1
a163 2
	fprintf(stderr,"nsteps = %d, incr_dist = %gmm\n", nsteps, incr_dist );
	fprintf(stderr,"viewsize = %gmm\n", viewsize);
d165 48
a212 8
	/* Load database */
	title_file = argv[bu_optind++];
	if( (rtip=rt_dirbuild(title_file, idbuf, sizeof(idbuf))) == RTI_NULL ) {
		fprintf(stderr,"rtwalk:  rt_dirbuild failure\n");
		exit(2);
	}
	ap.a_rt_i = rtip;
	fprintf(stderr, "db title:  %s\n", idbuf);
d214 10
a223 9
	/* Walk trees */
	for( i=bu_optind; i < argc; i++ )  {
		if( rt_gettree(rtip, argv[bu_optind]) < 0 )
			fprintf(stderr,"rt_gettree(%s) FAILED\n", argv[bu_optind]);
		bu_optind++;
	}

	/* Prep finds the model RPP, needed for the plotting step */
	rt_prep(rtip);
d226 4
a229 2
	 *  With stdout for the plot file, and stderr for
	 *  remarks, the output must go into a file.
d231 23
a253 3
	if( (outfp=fopen("rtwalk.mats", "w")) == NULL )  {
		perror("rtwalk.mats");
		exit(1);
a254 1
	plotfp = stdout;
d256 7
a262 5
	/* Plot all of the solids */
	if( R_DEBUG > 0 )  {
		pl_color( plotfp, 150, 150, 150 );
		rt_plot_all_solids( plotfp, rtip, &rt_uniresource );
	}
d264 5
a268 35
	/* Take a walk */
	for( curstep = 0; curstep < nsteps*4; curstep++ )  {
		mat_t	mat;
		int	failed_try;

		/*
		 *  In order to be able to compute deltas from the
		 *  previous to the current step, here we handle
		 *  the results of the last iteration.
		 *  The first and last iterations result in no output
		 */
		if(R_DEBUG>=3) {
			VPRINT("pos", ap.a_ray.r_pt);
		}
		if( curstep > 0 )  {
			if( R_DEBUG > 0 )  {
				if( curstep&1 )
					pl_color( plotfp, 0, 255, 0 );
				else
					pl_color( plotfp, 0, 0, 255 );
				pdv_3line( plotfp,
					pt_prev_step, ap.a_ray.r_pt );
			}
			write_matrix(curstep);
		}
		VMOVE( pt_prev_step, ap.a_ray.r_pt );
		VMOVE( dir_prev_step, ap.a_ray.r_dir );
		VSETALL( norm_cur_try, 0 );	/* sanity */

		/* See if goal has been reached */
		VSUB2( first_dir, goal_point, ap.a_ray.r_pt );
		if( (max_dist_togo=MAGNITUDE(first_dir)) < 1.0 )  {
			fprintf(stderr,"Complete in %d steps\n", curstep);
			exit(0);
		}
d270 22
a291 2
		/*  See if there is significant clear space ahead
		 *  Avoid taking small steps.
d293 22
a314 7
		if( clear_dist < incr_dist * 0.25 )
			clear_dist = 0.0;
		if( clear_dist > 0.0 )
			goto advance;

		/*
		 * Initial direction:  Head directly towards the goal.
d316 5
a320 90
		VUNITIZE( first_dir );
		VMOVE( ap.a_ray.r_dir, first_dir );

		for( failed_try=0; failed_try<100; failed_try++ )  {
			vect_t	out;
			int	i;

			/* Shoot Ray */
			if(R_DEBUG>=3)fprintf(stderr,"try=%d, maxtogo=%g  ",
				failed_try, max_dist_togo);
			ap.a_hit = hit;
			ap.a_miss = miss;
			ap.a_onehit = 1;
			if( rt_shootray( &ap ) == 0 )  {
				/* A miss, the way is clear all the way */
				clear_dist = max_dist_togo*2;
				break;
			}
			/* Hit, check distance to closest obstacle */
			if( clear_dist >= incr_dist )  {
				/* Clear for at least one more step.
				 * Zap memory of prev normal --
				 * this probe ahead does not count.
				 * Current normal has no significance,
				 * because object is more than one step away.
				 */
				VSETALL( norm_cur_try, 0 );
				break;
			}
			/*
			 * Failed, try another direction
			 */

			if(R_DEBUG > 2 )   {
				/* Log attempted ray in Red */
				VJOIN1( out, ap.a_ray.r_pt,
					incr_dist*4, ap.a_ray.r_dir );
				pl_color( plotfp, 255, 0, 0 );
				pdv_3line( plotfp,
					pt_prev_step, out );
			}

			/* Initial try was in direction of goal, it failed. */
			if( failed_try == 0 )  {
				/*  First recovery attempt.
				 *  If hit normal has not changed, continue
				 *  the direction of the last step.
				 *  Otherwise, head on tangent plane.
				 */
				if( VEQUAL( norm_cur_try, norm_prev_step ) )  {
					if(R_DEBUG>=3)fprintf(stderr,
						"Try prev dir\n");
					VMOVE( ap.a_ray.r_dir, dir_prev_step );
					continue;
				}
				if(R_DEBUG>=3)fprintf(stderr,"Try tangent\n");
				proj_goal();
				continue;
			} else if( failed_try <= 7 )  {
				/* Try 7 azimuthal escapes, 1..7 */
				i = failed_try-1+1;	/*  1..7 */
				if(R_DEBUG>=3)fprintf(stderr,"Try az %d\n", i);
				bn_mat_ae( mat, i*45.0, 0.0 );
			} else if( failed_try <= 14 ) {
				/* Try 7 Elevations to escape, 8..14 */
				i = failed_try-8+1;	/*     1..7 */
				if(R_DEBUG>=3)fprintf(stderr,"Try el %d\n", i);
				bn_mat_ae( mat, 0.0, i*45.0 );
			} else {
				fprintf(stderr,"trapped, giving up on escape\n");
				exit(1);
			}
			MAT4X3VEC( ap.a_ray.r_dir, mat, first_dir );

			/*
			 *  If new ray is nearly perpendicular to
			 *  the tangent plane, it is doomed to failure;
			 *  pick any tangent and use that instead.
			 */
			if( (VDOT( ap.a_ray.r_dir, norm_cur_try )) < -0.9995 )  {
				vect_t	olddir;

				VMOVE( olddir, ap.a_ray.r_dir );
				VCROSS( ap.a_ray.r_dir, olddir, norm_cur_try );
			}
		}
		if( failed_try > 0 )  {
			/* Extra trys were required, prevent runaways */
			if( clear_dist > incr_dist )
				clear_dist = incr_dist;
d322 18
d341 17
a357 5
		/* One simple attempt at not overshooting the goal.
		 * Really should measure distance point-to-line
		 */
		if( clear_dist > max_dist_togo )
			clear_dist = max_dist_togo;
d359 5
a363 12
		/* Advance position along ray */
advance:	;
		if( clear_dist > 0.0 )  {
			fastf_t	step;
			if( clear_dist < incr_dist )
				step = clear_dist;
			else
				step = incr_dist;
			VJOIN1( ap.a_ray.r_pt, ap.a_ray.r_pt,
				step, ap.a_ray.r_dir );
			clear_dist -= step;
		}
d365 11
a375 2
		/* Save status */
		VMOVE( norm_prev_step, norm_cur_try );
d377 6
a382 2
	fprintf(stderr,"%d steps used without reaching goal by %gmm\n", curstep, max_dist_togo);
	exit(1);
d387 15
a401 15
	register struct partition *pp;
	register struct soltab *stp;
	register struct hit *hitp;

	for( pp=PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )
		if( pp->pt_outhit->hit_dist >= 0.0 )  break;
	if( pp == PartHeadp )  {
		bu_log("hit:  no hit out front?\n");
		return(0);
	}
	hitp = pp->pt_inhit;
	stp = pp->pt_inseg->seg_stp;
	VJOIN1( hit_cur_try, ap->a_ray.r_pt, pp->pt_inhit->hit_dist, ap->a_ray.r_dir );
	RT_HIT_NORMAL( norm_cur_try, hitp, stp, &(ap->a_ray), pp->pt_inflip );
	RT_CURVATURE( &curve_cur, hitp, pp->pt_inflip, stp );
d403 1
a403 1
	clear_dist = hitp->hit_dist - 1;	/* Decrease 1mm */
d405 1
a405 1
	return(1);	/* HIT */
d411 1
a411 1
	return(0);
d425 1
a425 1
proj_goal(void)
d427 21
a447 21
	vect_t	goal_dir;
	vect_t	goal_proj;
	vect_t	newdir;
	fastf_t	k;

	if( VDOT( ap.a_ray.r_dir, norm_cur_try ) < -0.9995 )  {
		/* Projected goal will be right where we are now.
		 * Pick any tangent at all.
		 * Use principle dir of curvature.
		 */
		VMOVE( ap.a_ray.r_dir, curve_cur.crv_pdir );
		return;
	}

	VSUB2( goal_dir, hit_cur_try, goal_point );
	k = VDOT( goal_dir, norm_cur_try );
	VJOIN1( goal_proj, goal_point,
		k, norm_cur_try );
	VSUB2( newdir, goal_proj, hit_cur_try );
	VUNITIZE( newdir );
	VMOVE( ap.a_ray.r_dir, newdir );
d456 6
a461 6
	fprintf(outfp, "start %d;\n", frame);
	fprintf(outfp, "clean;\n");
	fprintf(outfp, "viewsize %g;\n", viewsize);
	fprintf(outfp, "eye_pt %g %g %g;\n", V3ARGS(pt_prev_step) );
	fprintf(outfp, "lookat_pt %g %g %g  0;\n", V3ARGS(goal_point) );
	fprintf(outfp, "end;\n\n" );
@


14.4
log
@update copyright to 2005
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.3 2004/12/24 01:40:00 brlcad Exp $ (BRL)";
d147 1
a147 1
	char	idbuf[132];		/* First ID record info */
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d147 1
a147 1
	char	idbuf[RT_BUFSIZE] = {0};		/* First ID record info */
@


14.3
log
@add the mysteriously missing gpl header..
@
text
@d4 1
a4 1
 * Copyright (c) 1987-2004 United States Government as represented by
d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/rtwalk.c,v 14.2 2004/12/21 06:38:22 morrison Exp $ (BRL)";
@


14.2
log
@remove the old copyright notice section
@
text
@d1 21
a21 2
/*
 *			R T W A L K . C 
a34 1
 *  
d37 1
a37 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtwalk.c,v 14.1 2004/11/16 19:42:31 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@a16 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
d19 1
a19 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtwalk.c,v 1.4 2004/09/16 03:13:13 morrison Exp $ (BRL)";
@


1.4
log
@a_hit hook functions are now also given a segment pointer, so match prototype even if unused and quell the warnings
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtwalk.c,v 1.3 2004/08/02 23:01:52 morrison Exp $ (BRL)";
d446 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/rtwalk.c,v 1.2 2004/06/08 22:04:35 morrison Exp $ (BRL)";
a26 2


d38 1
d81 1
a81 1
extern int hit(struct application *ap, struct partition *PartHeadp);
d368 1
a368 1
int hit(register struct application *ap, struct partition *PartHeadp)
@


1.2
log
@obliterate externs.h
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d25 1
a25 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d22 1
a22 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/rtwalk.c,v 11.19 2004/05/10 15:30:49 erikg Exp $ (BRL)";
a35 1
#include "externs.h"
@

