head	14.37;
access;
symbols
	rel-7-10-4:14.27
	STABLE:14.27.0.2
	stable-branch:14.8
	rel-7-10-2:14.27
	rel-7-10-0:14.25
	rel-7-8-4:14.20
	rel-7-8-2:14.18
	rel-7-8-0:14.18
	trimnurbs-branch:14.18.0.2
	help:14.18
	temp_tag:14.16
	bobWinPort-20051223-freeze:14.14
	postmerge-20051223-bobWinPort:14.16
	premerge-20051223-bobWinPort:14.16
	rel-7-6-6:14.15
	rel-7-6-4:14.15
	rel-7-6-2:14.14
	rel-7-6-branch:14.14.0.6
	rel-7-6-0:14.14
	rel-7-4-2:14.14
	rel-7-4-branch:14.14.0.4
	bobWinPort:14.14.0.2
	rel-7-4-0:14.14
	rel-7-2-6:14.13
	rel-7-2-4:14.11
	rel-7-2-2:14.7
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.6
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.37
date	2007.12.02.22.34.24;	author brlcad;	state Exp;
branches;
next	14.36;

14.36
date	2007.11.21.20.49.10;	author erikgreenwald;	state Exp;
branches;
next	14.35;

14.35
date	2007.11.21.20.38.23;	author erikgreenwald;	state Exp;
branches;
next	14.34;

14.34
date	2007.11.21.19.28.07;	author erikgreenwald;	state Exp;
branches;
next	14.33;

14.33
date	2007.11.21.16.18.53;	author erikgreenwald;	state Exp;
branches;
next	14.32;

14.32
date	2007.11.08.19.35.55;	author bob1961;	state Exp;
branches;
next	14.31;

14.31
date	2007.10.22.20.59.56;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.10.22.19.53.30;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.10.19.20.04.34;	author bob1961;	state Exp;
branches;
next	14.28;

14.28
date	2007.10.14.01.17.30;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.07.30.18.18.10;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.05.18.04.13.50;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.01.27.01.41.45;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.26.03.30.22;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.23.01.13.45;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.20.14.36.59;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.06.15.53.31;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.06.22.16.17.38;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.06.22.14.20.28;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.01.28.00.36.29;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.12.22.18.40.18;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.06.21.07.03.55;	author brlcad;	state Exp;
branches
	14.14.6.1;
next	14.13;

14.13
date	2005.05.28.02.14.58;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.05.16.00.13.41;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.05.04.03.37.18;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.05.02.00.29.19;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.04.26.08.39.36;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.04.11.18.32.27;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.03.30.07.41.13;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.03.28.06.31.37;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.03.24.17.25.32;	author bob1961;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.09;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.24.01.40.00;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.38.22;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.30;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.20.19.37.30;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.16.06.34.47;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.19.57.13;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.34;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.44;	author morrison;	state Exp;
branches;
next	;

14.14.6.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.37
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@/*                            D O . C
 * BRL-CAD
 *
 * Copyright (c) 1987-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file do.c
 *
 *  Routines that process the various commands, and manage
 *  the overall process of running the raytracing process.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#ifndef lint
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.36 2007/11/21 20:49:10 erikgreenwald Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#ifdef HAVE_UNIX_IO
#  include <sys/types.h>
#  include <sys/stat.h>
#  include <fcntl.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "rtprivate.h"
#include "bu.h"

/***** Variables shared with viewing model *** */
extern FILE	*outfp;			/* optional pixel output file */
extern double	azimuth, elevation;
extern mat_t	view2model;
extern mat_t	model2view;
/***** end of sharing with viewing model *****/

extern void	grid_setup(void);
extern void	worker(int cpu, genptr_t arg);

/***** variables shared with worker() ******/
extern struct application ap;
extern int	hypersample;		/* number of extra rays to fire */
extern fastf_t	aspect;			/* view aspect ratio X/Y */
extern fastf_t	cell_width;		/* model space grid cell width */
extern fastf_t	cell_height;		/* model space grid cell height */
extern point_t	eye_model;		/* model-space location of eye */
extern fastf_t  eye_backoff;		/* dist of eye from center */
extern fastf_t	rt_perspective;		/* persp (degrees X) 0 => ortho */
extern int	width;			/* # of pixels in X */
extern int	height;			/* # of lines in Y */
extern mat_t	Viewrotscale;		/* view orientation quaternion */
extern fastf_t	viewsize;
extern int	incr_mode;		/* !0 for incremental resolution */
extern int	incr_level;		/* current incremental level */
extern int	incr_nlevel;		/* number of levels */
extern int	npsw;
extern struct resource resource[];
/***** end variables shared with worker() */

/***** variables shared with rt.c *****/
extern char	*string_pix_start;	/* string spec of starting pixel */
extern char	*string_pix_end;	/* string spec of ending pixel */
extern int	pix_start;		/* pixel to start at */
extern int	pix_end;		/* pixel to end at */
extern int	nobjs;			/* Number of cmd-line treetops */
extern char	**objtab;		/* array of treetop strings */
extern int	matflag;		/* read matrix from stdin */
extern int	desiredframe;		/* frame to start at */
extern int	finalframe;		/* frame to halt at */
extern int	curframe;		/* current frame number */
extern char	*outputfile;		/* name of base of output file */
extern int	interactive;		/* human is watching results */
extern int	save_overlaps;		/* flag for setting rti_save_overlaps */
/***** end variables shared with rt.c *****/

/***** variables shared with viewg3.c *****/
struct bu_vls   ray_data_file;  /* file name for ray data output */
/***** end variables shared with viewg3.c *****/

/***** variables for frame buffer black pixel rendering *****/
unsigned char *pixmap = NULL; /* Pixel Map for rerendering of black pixels */


void		def_tree(register struct rt_i *rtip);
void		do_ae(double azim, double elev);
void		res_pr(void);
void		memory_summary(void);

/*
 *			O L D _ F R A M E
 *
 *  Acquire particulars about a frame, in the old format.
 *  Returns -1 if unable to acquire info, 0 if successful.
 */
int
old_frame(FILE *fp)
{
	register int i;
	char number[128];

	/* Visible part is from -1 to +1 in view space */
	if( fscanf( fp, "%128s", number ) != 1 )  return(-1);
	viewsize = atof(number);
	if( fscanf( fp, "%128s", number ) != 1 )  return(-1);
	eye_model[X] = atof(number);
	if( fscanf( fp, "%128s", number ) != 1 )  return(-1);
	eye_model[Y] = atof(number);
	if( fscanf( fp, "%128s", number ) != 1 )  return(-1);
	eye_model[Z] = atof(number);
	for( i=0; i < 16; i++ )  {
		if( fscanf( fp, "%128s", number ) != 1 )
			return(-1);
		Viewrotscale[i] = atof(number);
	}
	return(0);		/* OK */
}


/*
 *			O L D _ W A Y
 *
 *  Determine if input file is old or new format, and if
 *  old format, handle process *  Returns 0 if new way, 1 if old way (and all done).
 *  Note that the rewind() will fail on ttys, pipes, and sockets (sigh).
 */
int
old_way(FILE *fp)
{
	int	c;

	viewsize = -42.0;

	/* Sneek a peek at the first character, and then put it back */
	if( (c = fgetc( fp )) == EOF )  {
		/* Claim old way, all (ie, nothing) done */
		return(1);
	}
	if( ungetc( c, fp ) != c )
		bu_exit(EXIT_FAILURE, "do.c:old_way() ungetc failure\n");

	/*
	 * Old format files start immediately with a %.9e format,
	 * so the very first character should be a digit or '-'.
	 */
	if( (c < '0' || c > '9') && c != '-' )  {
		return( 0 );		/* Not old way */
	}

	if( old_frame( fp ) < 0 || viewsize <= 0.0 )  {
		rewind( fp );
		return(0);		/* Not old way */
	}
	bu_log("Interpreting command stream in old format\n");

	def_tree( ap.a_rt_i );		/* Load the default trees */

	curframe = 0;
	do {
		if( finalframe >= 0 && curframe > finalframe )
			return(1);
		if( curframe >= desiredframe )
			do_frame( curframe );
		curframe++;
	}  while( old_frame( fp ) >= 0 && viewsize > 0.0 );
	return(1);			/* old way, all done */
}


/*
 *			C M _ S T A R T
 *
 *  Process "start" command in new format input stream
 */
int cm_start( int argc, char **argv)
{
	char	*buf = (char *)NULL;
	int	frame;

	frame = atoi(argv[1]);
	if( finalframe >= 0 && frame > finalframe )
		return(-1);	/* Indicate EOF -- user declared a halt */
	if( frame >= desiredframe )  {
		curframe = frame;
		return(0);
	}

	/* Skip over unwanted frames -- find next frame start */
	while( (buf = rt_read_cmd( stdin )) != (char *)0 )  {
		register char *cp;

		cp = buf;
		while( *cp && isspace(*cp) )  cp++;	/* skip spaces */
		if( strncmp( cp, "start", 5 ) != 0 )  continue;
		while( *cp && !isspace(*cp) )  cp++;	/* skip keyword */
		while( *cp && isspace(*cp) )  cp++;	/* skip spaces */
		frame = atoi(cp);
		bu_free( buf, "rt_read_cmd command buffer (skipping frames)" );
		buf = (char *)0;
		if( finalframe >= 0 && frame > finalframe )
			return(-1);			/* "EOF" */
		if( frame >= desiredframe )  {
			curframe = frame;
			return(0);
		}
	}
	return(-1);		/* EOF */
}

int cm_vsize( int argc, char **argv)
{
	viewsize = atof( argv[1] );
	return(0);
}

int cm_eyept(int argc, char **argv)
{
	register int i;

	for( i=0; i<3; i++ )
		eye_model[i] = atof( argv[i+1] );
	return(0);
}

int cm_lookat_pt(int argc, char **argv)
{
	point_t	pt;
	vect_t	dir;
	int	yflip = 0;
	quat_t quat;

	if( argc < 4 )
		return(-1);
	pt[X] = atof(argv[1]);
	pt[Y] = atof(argv[2]);
	pt[Z] = atof(argv[3]);
	if( argc > 4 )
		yflip = atoi(argv[4]);

	/*
	 *  eye_pt should have been specified before here and
	 *  different from the lookat point or the lookat point will
	 *  be from the "front"
	 */
	if (VAPPROXEQUAL(pt, eye_model, VDIVIDE_TOL)) {
	    VSETALLN(quat, 0.5, 4);
	    quat_quat2mat(Viewrotscale, quat); /* front */
	} else {
	    VSUB2( dir, pt, eye_model );
	    VUNITIZE( dir );
	    bn_mat_lookat( Viewrotscale, dir, yflip );
	}

	return(0);
}

int cm_vrot( int argc, char **argv)
{
	register int i;

	for( i=0; i<16; i++ )
		Viewrotscale[i] = atof( argv[i+1] );
	return(0);
}

int cm_orientation(int argc, char **argv)
{
	register int	i;
	quat_t		quat;

	for( i=0; i<4; i++ )
		quat[i] = atof( argv[i+1] );
	quat_quat2mat( Viewrotscale, quat );
	return(0);
}

int cm_end(int argc, char **argv)
{
	struct rt_i *rtip = ap.a_rt_i;

	if( rtip && BU_LIST_IS_EMPTY( &rtip->HeadRegion ) )  {
		def_tree( rtip );		/* Load the default trees */
	}

	/* If no matrix or az/el specified yet, use params from cmd line */
	if( Viewrotscale[15] <= 0.0 )
		do_ae( azimuth, elevation );

	if( do_frame( curframe ) < 0 )  return(-1);
	return(0);
}

int cm_tree( int argc, const char **argv)
{
	register struct rt_i *rtip = ap.a_rt_i;
	struct bu_vls	times;

	if( argc <= 1 )  {
		def_tree( rtip );		/* Load the default trees */
		return(0);
	}
	bu_vls_init( &times );

	rt_prep_timer();
	if( rt_gettrees(rtip, argc-1, &argv[1], npsw) < 0 )
		bu_log("rt_gettrees(%s) FAILED\n", argv[0]);
	(void)rt_get_timer( &times, NULL );

	if (rt_verbosity & VERBOSE_STATS)
		bu_log("GETTREE: %s\n", bu_vls_addr(&times) );
	bu_vls_free( &times );
	return(0);
}

int cm_multiview( int argc, char **argv)
{
	register struct rt_i *rtip = ap.a_rt_i;
	int i;
	static int a[] = {
		 35,   0,
		  0,  90, 135, 180, 225, 270, 315,
		  0,  90, 135, 180, 225, 270, 315
	};
	static int e[] = {
		25, 90,
		30, 30, 30, 30, 30, 30, 30,
		60, 60, 60, 60, 60, 60, 60
	};

	if( rtip && BU_LIST_IS_EMPTY( &rtip->HeadRegion ) )  {
		def_tree( rtip );		/* Load the default trees */
	}
	for( i=0; i<(sizeof(a)/sizeof(a[0])); i++ )  {
		do_ae( (double)a[i], (double)e[i] );
		(void)do_frame( curframe++ );
	}
	return(-1);	/* end RT by returning an error */
}

/*
 *			C M _ A N I M
 *
 *  Experimental animation code
 *
 *  Usage:  anim <path> <type> args
 */
int cm_anim(int argc, const char **argv)
{

	if( db_parse_anim( ap.a_rt_i->rti_dbip, argc, argv ) < 0 )  {
		bu_log("cm_anim:  %s %s failed\n", argv[1], argv[2]);
		return(-1);		/* BAD */
	}
	return(0);
}

/*
 *			C M _ C L E A N
 *
 *  Clean out results of last rt_prep(), and start anew.
 */
int cm_clean(int argc, char **argv)
{
	/* Allow lighting model to clean up (e.g. lights, materials, etc) */
	view_cleanup( ap.a_rt_i );

	rt_clean( ap.a_rt_i );

	if(R_DEBUG&RDEBUG_RTMEM_END)
		bu_prmem( "After cm_clean" );
	return(0);
}

/*
 *			C M _ C L O S E D B
 *
 *  To be invoked after a "clean" command, to close out the ".g" database.
 *  Intended for memory debugging, to help chase down memory "leaks".
 *  This terminates the program, as there is no longer a database.
 */
int cm_closedb(int argc, char **argv)
{
	db_close( ap.a_rt_i->rti_dbip );
	ap.a_rt_i->rti_dbip = DBI_NULL;

	bu_free( (genptr_t)ap.a_rt_i, "struct rt_i" );
	ap.a_rt_i = RTI_NULL;

	bu_prmem( "After _closedb" );
	bu_exit(0, NULL);

	return( 1 );	/* for compiler */
}

/* viewing module specific variables */
extern struct bu_structparse view_parse[];

struct bu_structparse set_parse[] = {
/*XXX need to investigate why this doesn't work on Windows */
#if !defined(__alpha) && !defined(_WIN32) /* XXX Alpha does not support this initialization! */
	{"%d",	1, "width",	bu_byteoffset(width),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "height",	bu_byteoffset(height),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "save_overlaps", bu_byteoffset(save_overlaps),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "perspective", bu_byteoffset(rt_perspective),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "angle",	bu_byteoffset(rt_perspective),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "rt_bot_minpieces", bu_byteoffset(rt_bot_minpieces),BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "rt_bot_tri_per_piece", bu_byteoffset(rt_bot_tri_per_piece),BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "rt_cline_radius", bu_byteoffset(rt_cline_radius),BU_STRUCTPARSE_FUNC_NULL },
	{"%S",  1, "ray_data_file", bu_byteoffset(ray_data_file),BU_STRUCTPARSE_FUNC_NULL },
	{"i", bu_byteoffset(view_parse[0]),"View_Module-Specific Parameters", 0, BU_STRUCTPARSE_FUNC_NULL },
#endif
	{"",	0, (char *)0,	0,				BU_STRUCTPARSE_FUNC_NULL }
};

/*
 *			C M _ S E T
 *
 *  Allow variable values to be set or examined.
 */
int cm_set(int argc, char **argv)
{
	struct bu_vls	str;

	if( argc <= 1 ) {
		bu_struct_print( "Generic and Application-Specific Parameter Values",
			set_parse, (char *)0 );
		return(0);
	}
	bu_vls_init( &str );
	bu_vls_from_argv( &str, argc-1, (const char **)argv+1 );
	if( bu_struct_parse( &str, set_parse, (char *)0 ) < 0 )  {
		bu_vls_free( &str );
		return(-1);
	}
	bu_vls_free( &str );
	return(0);
}

/*
 *			C M _ A E
 */
int cm_ae( int argc, char **argv)
{
	azimuth = atof(argv[1]);	/* set elevation and azimuth */
	elevation = atof(argv[2]);
	do_ae(azimuth, elevation);

	return(0);
}

/*
 *			C M _ O P T
 */
int cm_opt(int argc, char **argv)
{
	int old_bu_optind=bu_optind;	/* need to restore this value after calling get_args() */

	if( get_args( argc, argv ) <= 0 ) {
		bu_optind = old_bu_optind;
		return(-1);
	}
	bu_optind = old_bu_optind;
	return(0);
}


/*
 *			D E F _ T R E E
 *
 *  Load default tree list, from command line.
 */
void
def_tree(register struct rt_i *rtip)
{
	struct bu_vls	times;

	RT_CK_RTI(rtip);

	bu_vls_init( &times );
	rt_prep_timer();
	if( rt_gettrees(rtip, nobjs, (const char **)objtab, npsw) < 0 )
		bu_log("rt_gettrees(%s) FAILED\n", objtab[0]);
	(void)rt_get_timer( &times, NULL );

	if (rt_verbosity & VERBOSE_STATS)
		bu_log("GETTREE: %s\n", bu_vls_addr(&times));
	bu_vls_free( &times );
	memory_summary();
}

/*
 *			D O _ P R E P
 *
 *  This is a separate function primarily as a service to REMRT.
 */
void
do_prep(struct rt_i *rtip)
{
	struct bu_vls	times;

	RT_CHECK_RTI(rtip);
	if( rtip->needprep )  {
		/* Allow lighting model to set up (e.g. lights, materials, etc) */
		view_setup(rtip);

		/* Allow RT library to prepare itself */
		bu_vls_init( &times );
		rt_prep_timer();
		rt_prep_parallel(rtip, npsw);

		(void)rt_get_timer( &times, NULL );
		if (rt_verbosity & VERBOSE_STATS)
			bu_log( "PREP: %s\n", bu_vls_addr(&times) );
		bu_vls_free( &times );
	}
	memory_summary();
	if (rt_verbosity & VERBOSE_STATS)  {
		bu_log("%s: %d nu, %d cut, %d box (%d empty)\n",
			rtip->rti_space_partition == RT_PART_NUGRID ?
				"NUGrid" : "NUBSP",
			rtip->rti_ncut_by_type[CUT_NUGRIDNODE],
			rtip->rti_ncut_by_type[CUT_CUTNODE],
			rtip->rti_ncut_by_type[CUT_BOXNODE],
			rtip->nempty_cells );
#if 0
rt_pr_cut_info( rtip, "main" );
#endif
	}
}

/*
 *			D O _ F R A M E
 *
 *  Do all the actual work to run a frame.
 *
 *  Returns -1 on error, 0 if OK.
 */
int
do_frame(int framenumber)
{
	struct bu_vls	times;
	char framename[128] = {0};		/* File name to hold current frame */
	struct rt_i *rtip = ap.a_rt_i;
	double	utime = 0.0;			/* CPU time used */
	double	nutime = 0.0;			/* CPU time used, normalized by ncpu */
	double	wallclock;		/* # seconds of wall clock time */
	int	npix,i;			/* # of pixel values to be done */
	int	lim;
	vect_t	work, temp;
	quat_t	quat;

	if (rt_verbosity & VERBOSE_FRAMENUMBER)
		bu_log( "\n...................Frame %5d...................\n",
			framenumber);

	/* Compute model RPP, etc */
	do_prep( rtip );

	if (rt_verbosity & VERBOSE_VIEWDETAIL)
		bu_log("Tree: %d solids in %d regions\n",
			rtip->nsolids, rtip->nregions );

	if (Query_one_pixel) {
		query_rdebug = R_DEBUG;
		query_debug = RT_G_DEBUG;
		rt_g.debug = rdebug = 0;
	}

	if( rtip->nsolids <= 0 )
		bu_exit(3, "rt ERROR: No solids\n");

	if (rt_verbosity & VERBOSE_VIEWDETAIL)
		bu_log("Model: X(%g,%g), Y(%g,%g), Z(%g,%g)\n",
			rtip->mdl_min[X], rtip->mdl_max[X],
			rtip->mdl_min[Y], rtip->mdl_max[Y],
			rtip->mdl_min[Z], rtip->mdl_max[Z] );

	/*
	 *  Perform Grid setup.
	 *  This may alter cell size or width/height.
	 */
	grid_setup();
	/* az/el 0,0 is when screen +Z is model +X */
	VSET( work, 0, 0, 1 );
	MAT3X3VEC( temp, view2model, work );
	bn_ae_vec( &azimuth, &elevation, temp );

	if (rt_verbosity & VERBOSE_VIEWDETAIL)
		bu_log(
			"View: %g azimuth, %g elevation off of front view\n",
			azimuth, elevation);
	quat_mat2quat( quat, model2view );
	if (rt_verbosity & VERBOSE_VIEWDETAIL) {
		bu_log("Orientation: %g, %g, %g, %g\n", V4ARGS(quat) );
		bu_log("Eye_pos: %g, %g, %g\n", V3ARGS(eye_model) );
		bu_log("Size: %gmm\n", viewsize);
#if 0
	/*
	 *  This code shows how the model2view matrix can be reconstructed
	 *  using the information from the Orientation, Eye_pos, and Size
	 *  messages.
	 */
		{
			mat_t	rotscale, xlate;
			mat_t	new;
			quat_t	newquat;

			bn_mat_print("model2view", model2view);
			quat_quat2mat( rotscale, quat );
			rotscale[15] = 0.5 * viewsize;
			MAT_IDN( xlate );
			MAT_DELTAS_VEC_NEG( xlate, eye_model);
			bn_mat_mul( new, rotscale, xlate );
			bn_mat_print("reconstructed m2v", new);
			quat_mat2quat( newquat, new );
			HPRINT( "reconstructed orientation:", newquat );
		}
#endif
		bu_log("Grid: (%g, %g) mm, (%d, %d) pixels\n",
			cell_width, cell_height,
			width, height );
		bu_log("Beam: radius=%g mm, divergence=%g mm/1mm\n",
			ap.a_rbeam, ap.a_diverge );
	}

	/* Process -b and ??? options now, for this frame */
	if( pix_start == -1 )  {
		pix_start = 0;
		pix_end = height * width - 1;
	}
	if( string_pix_start )  {
		int xx, yy;
		register char *cp = string_pix_start;

		xx = atoi(cp);
		while( *cp >= '0' && *cp <= '9' )  cp++;
		while( *cp && (*cp < '0' || *cp > '9') ) cp++;
		yy = atoi(cp);
		bu_log("only pixel %d %d\n", xx, yy);
		if( xx * yy >= 0 )  {
			pix_start = yy * width + xx;
			pix_end = pix_start;
		}
	}
	if( string_pix_end )  {
		int xx, yy;
		register char *cp = string_pix_end;

		xx = atoi(cp);
		while( *cp >= '0' && *cp <= '9' )  cp++;
		while( *cp && (*cp < '0' || *cp > '9') ) cp++;
		yy = atoi(cp);
		bu_log("ending pixel %d %d\n", xx, yy);
		if( xx * yy >= 0 )  {
			pix_end = yy * width + xx;
		}
	}

	/*
	 *  After the parameters for this calculation have been established,
	 *  deal with CPU limits and priorities, where appropriate.
	 *  Because limits exist, they better be adequate.
	 *  We assume that the Cray can produce MINRATE pixels/sec
	 *  on images with extreme amounts of glass & mirrors.
	 */
#define MINRATE	65
	npix = width*height*(hypersample+1);
	if( (lim = bu_cpulimit_get()) > 0 )  {
		bu_cpulimit_set( lim + npix / MINRATE + 100 );
	}

	/* Allocate data for pixel map for rerendering of black pixels */
	if (pixmap == NULL) {
	    pixmap = (unsigned char*)bu_calloc(sizeof(RGBpixel), width*height, "pixmap allocate");
	}

	/*
	 *  If this image is unlikely to be for debugging,
	 *  be gentle to the machine.
	 */
	if( !interactive )  {
		if( npix > 256*256 )
			bu_nice_set(10);
		else if( npix > 512*512 )
			bu_nice_set(14);
	}

	/*
	 *  Determine output file name
	 *  On UNIX only, check to see if this is a "restart".
	 */
	if( outputfile != (char *)0 )  {
		if( framenumber <= 0 )  {
			snprintf( framename, 128, "%s", outputfile );
		}  else  {
			snprintf( framename, 128, "%s.%d", outputfile, framenumber );
		}
#ifdef HAVE_UNIX_IO
		/*
		 *  This code allows the computation of a particular frame
		 *  to a disk file to be resumed automaticly.
		 *  This is worthwhile crash protection.
		 *  This use of stat() and fseek() is UNIX-specific.
		 *
		 *  It is not appropriate for the RT "top part" to assume
		 *  anything about the data that the view module will be
		 *  storing.  Therefore, it is the responsibility of
		 *  view_2init() to also detect that some existing data
		 *  is in the file, and take appropriate measures
		 *  (like reading it in).
		 *  view_2init() can depend on the file being open for both
		 *  reading and writing, but must do it's own positioning.
		 */
		{
			struct		stat	sb;
			if( stat( framename, &sb ) >= 0 &&
			    sb.st_size > 0 &&
			    sb.st_size < width*height*sizeof(RGBpixel))  {
				/* File exists, with partial results */
				register int	fd;
				if( (fd = open( framename, 2 )) < 0 ||
				    (outfp = fdopen( fd, "r+" )) == NULL )  {
					perror( framename );
					if( matflag )  return(0);	/* OK */
					return(-1);			/* Bad */
				}
				/* Read existing pix data into the frame buffer */
				if (sb.st_size > 0) {
					(void)fread(pixmap,1,(size_t)sb.st_size,outfp);
				}
			}
		}
#endif

		/* Ordinary case for creating output file */
#if defined(_WIN32) && !defined(__CYGWIN__)
		if( outfp == NULL && (outfp = fopen( framename, "w+b" )) == NULL )
#else
		if( outfp == NULL && (outfp = fopen( framename, "w" )) == NULL )
#endif
		    {
			perror( framename );
			if( matflag )  return(0);	/* OK */
			return(-1);			/* Bad */
		    }

		if (rt_verbosity & VERBOSE_OUTPUTFILE)
			bu_log("Output file is '%s' %dx%d pixels\n",
				framename, width, height);
	}

	/* initialize lighting, may update pix_start */
	view_2init( &ap, framename );

	/* Just while doing the ray-tracing */
	if(R_DEBUG&RDEBUG_RTMEM)
		bu_debug |= (BU_DEBUG_MEM_CHECK|BU_DEBUG_MEM_LOG);

	rtip->nshots = 0;
	rtip->nmiss_model = 0;
	rtip->nmiss_tree = 0;
	rtip->nmiss_solid = 0;
	rtip->nmiss = 0;
	rtip->nhits = 0;
	rtip->rti_nrays = 0;

	if (rt_verbosity & (VERBOSE_LIGHTINFO|VERBOSE_STATS))
		bu_log("\n");
	fflush(stdout);
	fflush(stderr);

	/*
	 *  Compute the image
	 *  It may prove desirable to do this in chunks
	 */
	rt_prep_timer();

	if( incr_mode )  {
		for( incr_level = 1; incr_level <= incr_nlevel; incr_level++ )  {
			if( incr_level > 1 )
				view_2init( &ap, framename );

			do_run( 0, (1<<incr_level)*(1<<incr_level)-1 );
		}
	} else {
		do_run( pix_start, pix_end );

		/* Reset values to full size, for next frame (if any) */
		pix_start = 0;
		pix_end = height*width - 1;
	}
	bu_vls_init( &times );
	utime = rt_get_timer( &times, &wallclock );

	/*
	 *  End of application.  Done outside of timing section.
	 *  Typically, writes any remaining results out.
	 */
	view_end( &ap );

	/* Stop memory debug printing until next frame, leave full checking on */
	if(R_DEBUG&RDEBUG_RTMEM)
		bu_debug &= ~BU_DEBUG_MEM_LOG;

	/*
	 *  Certain parallel systems (eg, Alliant) count the entire
	 *  multi-processor complex as one computer, and charge only once.
	 *  This matches the desired behavior here.
	 *  Other vendors (eg, SGI) count each processor separately,
	 *  and charge for all of them.  These results need to be normalized.
	 *  Otherwise, all we would know is that a given workload takes about
	 *  the same amount of CPU time, regardless of the number of CPUs.
	 */
#if !defined(alliant)
	if( npsw > 1 )  {
		int avail_cpus;
		int ncpus;

		avail_cpus = bu_avail_cpus();
		if( npsw > avail_cpus ) {
			ncpus = avail_cpus;
		} else {
			ncpus = npsw;
		}
		nutime = utime / ncpus;			/* compensate */
	} else
#endif
		nutime = utime;

	/* prevent a bogus near-zero time to prevent infinate and near-infinate
	 * results without relying on IEEE floating point zero comparison.
	 */
	if (NEAR_ZERO(nutime, VDIVIDE_TOL)) {
	  bu_log("WARNING:  Raytrace timings are likely to be meaningless\n");
	  nutime = VDIVIDE_TOL;
	}

	/*
	 *  All done.  Display run statistics.
	 */
	if (rt_verbosity & VERBOSE_STATS)
		bu_log("SHOT: %s\n", bu_vls_addr( &times ) );
	bu_vls_free( &times );
	memory_summary();
	if (rt_verbosity & VERBOSE_STATS) {
		bu_log("%ld solid/ray intersections: %ld hits + %ld miss\n",
			rtip->nshots, rtip->nhits, rtip->nmiss );
		bu_log("pruned %.1f%%:  %ld model RPP, %ld dups skipped, %ld solid RPP\n",
			rtip->nshots>0?((double)rtip->nhits*100.0)/rtip->nshots:100.0,
			rtip->nmiss_model, rtip->ndup, rtip->nmiss_solid );
		bu_log("Frame %2d: %10d pixels in %9.2f sec = %12.2f pixels/sec\n",
			framenumber,
			width*height, nutime, ((double)(width*height))/nutime );
		bu_log("Frame %2d: %10d rays   in %9.2f sec = %12.2f rays/sec (RTFM)\n",
			framenumber,
			rtip->rti_nrays, nutime, ((double)(rtip->rti_nrays))/nutime );
		bu_log("Frame %2d: %10d rays   in %9.2f sec = %12.2f rays/CPU_sec\n",
			framenumber,
			rtip->rti_nrays, utime, ((double)(rtip->rti_nrays))/utime );
		bu_log("Frame %2d: %10d rays   in %9.2f sec = %12.2f rays/sec (wallclock)\n",
			framenumber,
			rtip->rti_nrays,
			wallclock, ((double)(rtip->rti_nrays))/wallclock );
	}
	if( outfp != NULL )  {
		/* Protect finished product */
		if( outputfile != (char *)0 )
		    (void)bu_fchmod(framename, outfp, 0444);

		(void)fclose(outfp);
		outfp = NULL;
	}

	if(R_DEBUG&RDEBUG_STATS)  {
		/* Print additional statistics */
		res_pr();
	}

	bu_log("\n");
	bu_free(pixmap, "pixmap allocate");
	pixmap = (unsigned char *)NULL;
	return(0);		/* OK */
}

/*
 *			D O _ A E
 *
 *  Compute the rotation specified by the azimuth and elevation
 *  parameters.  First, note that these are specified relative
 *  to the GIFT "front view", ie, model (X,Y,Z) is view (Z,X,Y):
 *  looking down X axis, Y right, Z up.
 *  A positive azimuth represents rotating the *eye* around the
 *  Y axis, or, rotating the *model* in -Y.
 *  A positive elevation represents rotating the *eye* around the
 *  X axis, or, rotating the *model* in -X.
 */
void
do_ae(double azim, double elev)
{
	vect_t	temp;
	vect_t	diag;
	mat_t	toEye;
	struct rt_i *rtip = ap.a_rt_i;

	if( rtip->nsolids <= 0 )
	    bu_exit(EXIT_FAILURE, "do_ae: no solids active\n");
	if ( rtip->nregions <= 0 )
	    bu_exit(EXIT_FAILURE, "do_ae: no regions active\n");

	if( rtip->mdl_max[X] >= INFINITY ) {
	    bu_log("do_ae: infinite model bounds? setting a unit minimum\n");
	    VSETALL( rtip->mdl_min, -1 );
	}
	if ( rtip->mdl_max[X] <= -INFINITY ) {
	    bu_log("do_ae: infinite model bounds? setting a unit maximum\n");
	    VSETALL( rtip->mdl_max, 1 );
	}

	/*
	 *  Enlarge the model RPP just slightly, to avoid nasty
	 *  effects with a solid's face being exactly on the edge
	 *  NOTE:  This code is duplicated out of librt/tree.c/rt_prep(),
	 *  and has to appear here to enable the viewsize calculation to
	 *  match the final RPP.
	 */
	rtip->mdl_min[X] = floor( rtip->mdl_min[X] );
	rtip->mdl_min[Y] = floor( rtip->mdl_min[Y] );
	rtip->mdl_min[Z] = floor( rtip->mdl_min[Z] );
	rtip->mdl_max[X] = ceil( rtip->mdl_max[X] );
	rtip->mdl_max[Y] = ceil( rtip->mdl_max[Y] );
	rtip->mdl_max[Z] = ceil( rtip->mdl_max[Z] );

	MAT_IDN( Viewrotscale );
	bn_mat_angles( Viewrotscale, 270.0+elev, 0.0, 270.0-azim );

	/* Look at the center of the model */
	MAT_IDN( toEye );
	toEye[MDX] = -((rtip->mdl_max[X]+rtip->mdl_min[X])/2.0);
	toEye[MDY] = -((rtip->mdl_max[Y]+rtip->mdl_min[Y])/2.0);
	toEye[MDZ] = -((rtip->mdl_max[Z]+rtip->mdl_min[Z])/2.0);

	/* Fit a sphere to the model RPP, diameter is viewsize,
	 * unless viewsize command used to override.
	 */
	if( viewsize <= 0 ) {
		VSUB2( diag, rtip->mdl_max, rtip->mdl_min );
		viewsize = MAGNITUDE( diag );
		if( aspect > 1 ) {
			/* don't clip any of the image when autoscaling */
			viewsize *= aspect;
		}
	}
	Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
	bn_mat_mul( model2view, Viewrotscale, toEye );
	bn_mat_inv( view2model, model2view );
	VSET( temp, 0, 0, eye_backoff );
	MAT4X3PNT( eye_model, view2model, temp );
}

/*
 *			R E S _ P R
 */
void
res_pr(void)
{
	register struct resource *res;
	register int i;

	fprintf(stderr,"\nResource use summary, by processor:\n");
	res = &resource[0];
	for( i=0; i<npsw; i++, res++ )  {
		fprintf(stderr, "---CPU %d:\n", i);
		if( res->re_magic != RESOURCE_MAGIC )  {
			fprintf(stderr,"Bad magic number!!\n");
			continue;
		}
		fprintf(stderr,"seg       len=%10ld get=%10ld free=%10ld\n",
			res->re_seglen, res->re_segget, res->re_segfree );
		fprintf(stderr,"partition len=%10ld get=%10ld free=%10ld\n",
			res->re_partlen, res->re_partget, res->re_partfree );
#if 0
		fprintf(stderr,"bitv_elem len=%10ld get=%10ld free=%10ld\n",
			res->re_bitvlen, res->re_bitvget, res->re_bitvfree );
#endif
		fprintf(stderr,"boolstack len=%10ld\n",
			res->re_boolslen);
	}
}

/*
 *  Command table for RT control script language
 */

struct command_tab rt_cmdtab[] = {
	{"start", "frame number", "start a new frame",
		cm_start,	2, 2},
	{"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2},
	{"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4},
	{"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5},
	{"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17},
	{"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5},
	{"end", 	"", "end of frame setup, begin raytrace",
		cm_end,		1, 1},
	{"multiview", "", "produce stock set of views",
		cm_multiview,	1, 1},
	{"anim", 	"path type args", "specify articulation animation",
		cm_anim,	4, 999},
	{"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_tree,	1, 999},
	{"clean", "", "clean articulation from previous frame",
		cm_clean,	1, 1},
	{"_closedb", "", "Close .g database, (for memory debugging)",
		cm_closedb,	1, 1},
	{"set", 	"", "show or set parameters",
		cm_set,		1, 999},
	{"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_ae,		3, 3},
	{"opt", "-flags", "set flags, like on command line",
		cm_opt,		2, 999},
	{(char *)0, (char *)0, (char *)0,
		0,		0, 0	/* END */}
};

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.36
log
@pass bu_exit a NULL instead of an empty string
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.35 2007/11/21 20:38:23 erikgreenwald Exp $ (BRL)";
d130 1
a130 1
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
d132 1
a132 1
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
d134 1
a134 1
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
d136 1
a136 1
	if( fscanf( fp, "%s", number ) != 1 )  return(-1);
d139 1
a139 1
		if( fscanf( fp, "%s", number ) != 1 )
d721 1
a721 1
			sprintf( framename, outputfile );
d723 1
a723 1
			sprintf( framename, "%s.%d", outputfile, framenumber );
@


14.35
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.34 2007/11/21 19:28:07 erikgreenwald Exp $ (BRL)";
d417 1
a417 1
	bu_exit(0, "");
@


14.34
log
@exit->bu_exit where applicable
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.33 2007/11/21 16:18:53 erikgreenwald Exp $ (BRL)";
d596 2
a597 4
	if( rtip->nsolids <= 0 )  {
		bu_log("rt ERROR: No solids\n");
		bu_exit(3, "");
	}
@


14.33
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.32 2007/11/08 19:35:55 bob1961 Exp $ (BRL)";
d417 1
a417 1
	exit(0);
d598 1
a598 1
		exit(3);
@


14.32
log
@Using bu_fchmod() instead of fchmod().
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.31 2007/10/22 20:59:56 brlcad Exp $ (BRL)";
d167 1
a167 1
		bu_bomb("do.c:old_way() ungetc failure\n");
d935 1
a935 1
	    bu_bomb("do_ae: no solids active\n");
d937 1
a937 1
	    bu_bomb("do_ae: no regions active\n");
@


14.31
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.30 2007/10/22 19:53:30 brlcad Exp $ (BRL)";
d897 1
a897 1
			fchmod( fileno(outfp), 0444 );
@


14.30
log
@wrong direction bob.. working to remove _all_ instances of _WIN32 not in a core library.  besides, using chmod() is actually has a fundamental race condition flaw that is a security violation; and causes the new flawfinder regression test to fail.  hopefully msvc has _fchmod() like the other posix funcs it supports prefixed.  if not, need to add a libbu compatibility routine.
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.29 2007/10/19 20:04:34 bob1961 Exp $ (BRL)";
a694 3
#ifdef CRAY2
#define MINRATE	35
#else
a695 1
#endif
a721 15
#ifdef CRAY_COS
		/* Dots in COS file names make them permanant files. */
		sprintf( framename, "F%d", framenumber );
		if( (outfp = fopen( framename, "w" )) == NULL )  {
			perror( framename );
			if( matflag )  return(0);
			return(-1);
		}
		/* Dispose to shell script starts with "!" */
		if( framenumber <= 0 || outputfile[0] == '!' )  {
			sprintf( framename, outputfile );
		}  else  {
			sprintf( framename, "%s.%d", outputfile, framenumber );
		}
#else
d766 1
a766 1
		if( outfp == NULL && (outfp = fopen( framename, "w+b" )) == NULL )  {
d768 1
a768 1
		if( outfp == NULL && (outfp = fopen( framename, "w" )) == NULL )  {
d770 1
d774 2
a775 2
		}
#endif /* CRAY_COS */
a894 22
#ifdef CRAY_COS
		int status;
		char dn[16];
		char message[128];

		strncpy( dn, outfp->ldn, sizeof(outfp->ldn) );	/* COS name */
#endif

#ifdef CRAY_COS
		status = 0;
		/* Binary out */
		(void)DISPOSE( &status, "DN      ", dn,
			"TEXT    ", framename,
			"NOWAIT  ",
			"DF      ", "BB      " );
		sprintf(message,
			"%s Dispose,dn='%s',text='%s'.  stat=0%o",
			(status==0) ? "Good" : "---BAD---",
			dn, framename, status );
		bu_log( "%s\n", message);
		remark(message);	/* Send to log files */
#else
a897 1
#endif
@


14.29
log
@Minor mod for Windows.
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.28 2007/10/14 01:17:30 brlcad Exp $ (BRL)";
a936 3
#if defined(_WIN32) && !defined(__CYGWIN__)
			chmod( framename, 0444 );
#else
a938 1
#endif
@


14.28
log
@use fchmod() instead of chmod() to avoid race condition.  quell flawfinder warning
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.27 2007/07/30 18:18:10 brlcad Exp $ (BRL)";
d937 3
d942 1
@


14.27
log
@initialize framename to null
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.26 2007/05/18 04:13:50 brlcad Exp $ (BRL)";
d920 1
a920 2
		(void)fclose(outfp);
		outfp = NULL;
d937 1
a937 1
			chmod( framename, 0444 );
d939 3
@


14.26
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.25 2007/01/27 01:41:45 brlcad Exp $ (BRL)";
d569 1
a569 1
	char framename[128];		/* File name to hold current frame */
@


14.25
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.24 2007/01/26 03:30:22 brlcad Exp $ (BRL)";
d167 1
a167 1
		rt_bomb("do.c:old_way() ungetc failure\n");
d974 1
a974 1
	    rt_bomb("do_ae: no solids active\n");
d976 1
a976 1
	    rt_bomb("do_ae: no regions active\n");
@


14.24
log
@simplify, use MAT_DELTAS_VEC_NEG when setting translation elements to negative vector values
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.23 2007/01/23 01:13:45 brlcad Exp $ (BRL)";
d948 1
a948 1
        bu_free(pixmap, "pixmap allocate");
d1094 1
a1094 1
	        0,		0, 0	/* END */}
@


14.23
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.22 2007/01/20 14:36:59 brlcad Exp $ (BRL)";
d641 1
a641 1
			MAT_DELTAS( xlate, -eye_model[X], -eye_model[Y], -eye_model[Z] );
@


14.22
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d35 1
a35 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.21 2007/01/06 15:53:31 brlcad Exp $ (BRL)";
@


14.21
log
@awesome.. not only did karel (aka clock3) identify and report on an animation bug in rt with extensive detail, he went on to trace down the problem and actually identified the bug.  a variable that keeps track of frame progress was not being reset to null after a frame was completed causing subsequent frames to dereference an invalid pointer and segfault.  apply the fix from sf bug 1629285 (persistent segfaults during animation - with a fix). this affected all raytracers, but not library users.  excellent work, karel.  excellent.
@
text
@d4 1
a4 1
 * Copyright (c) 1987-2006 United States Government as represented by
d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.20 2006/06/22 16:17:38 brlcad Exp $ (BRL)";
@


14.20
log
@check and see if the eye point was set to something different than the look at point, otherwise choose a default 'front' view just to pick a direction.  also, make sure rtip is valid before checking lists
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.19 2006/06/22 14:20:28 brlcad Exp $ (BRL)";
d205 1
a205 1
	char	*buf;
d227 1
d950 1
@


14.19
log
@gah, don't reset the view scale.. it might have been specifically set to something else.  instead call do_ae() now instead of waiting for end.  this still doesn't work right as do_ae does its own autoview on the geometry and resizes, but at least ae command doesn't override now
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.18 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
d80 1
a80 1
extern mat_t	Viewrotscale;
d257 1
d268 3
a270 1
	 *  eye_pt must have been specified before here (for now)
d272 9
a280 3
	VSUB2( dir, pt, eye_model );
	VUNITIZE( dir );
	bn_mat_lookat( Viewrotscale, dir, yflip );
d308 1
a308 1
	if( BU_LIST_IS_EMPTY( &rtip->HeadRegion ) )  {
d357 1
a357 1
	if( BU_LIST_IS_EMPTY( &rtip->HeadRegion ) )  {
d1005 3
a1007 3
	toEye[MDX] = -(rtip->mdl_max[X]+rtip->mdl_min[X])/2;
	toEye[MDY] = -(rtip->mdl_max[Y]+rtip->mdl_min[Y])/2;
	toEye[MDZ] = -(rtip->mdl_max[Z]+rtip->mdl_min[Z])/2;
@


14.18
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.17 2006/01/18 06:46:23 brlcad Exp $ (BRL)";
d464 1
a464 2
	Viewrotscale[15] = 0.0;		/* set scale to 0.0 so that cm_end */
					/* will do the do_ae               */
@


14.17
log
@update copyright to 2006
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.16 2005/12/22 18:40:18 brlcad Exp $ (BRL)";
d41 1
a41 2


d47 3
a49 3
# include <sys/types.h>
# include <sys/stat.h>
# include <fcntl.h>
@


14.16
log
@make sure pixmap is null before wiping it out.  instead of setting all the elements to zero, save cpu cycles and just request a bu_calloc...
@
text
@d4 1
a4 1
 * Copyright (C) 1987-2005 United States Government as represented by
d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.15 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
@


14.15
log
@trailing ws
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.14 2005/06/21 07:03:55 brlcad Exp $ (BRL)";
d699 3
a701 3
	pixmap= (unsigned char*)bu_malloc(sizeof(RGBpixel)*width*height, "pixmap allocate");
	for (i= 0; i < width*height*sizeof(RGBpixel); i++)
		pixmap[i]= 0;
@


14.14
log
@get rid of the rogue byteoffset duplicates and make everyone use bu_byteoffset() instead
@
text
@d33 1
a33 1
 *  
d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.13 2005/05/28 02:14:58 brlcad Exp $ (BRL)";
d151 1
a151 1
 * 
d458 1
a458 1
/* 
d757 1
a757 1
			if( stat( framename, &sb ) >= 0 && 
d788 1
a788 1
			bu_log("Output file is '%s' %dx%d pixels\n", 
d846 1
a846 1
	 *  Certain parallel systems (eg, Alliant) count the entire 
@


14.14.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d33 1
a33 1
 *
d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d151 1
a151 1
 *
d458 1
a458 1
/*
d757 1
a757 1
			if( stat( framename, &sb ) >= 0 &&
d788 1
a788 1
			bu_log("Output file is '%s' %dx%d pixels\n",
d846 1
a846 1
	 *  Certain parallel systems (eg, Alliant) count the entire
@


14.13
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.12 2005/05/16 00:13:41 brlcad Exp $ (BRL)";
d58 1
a416 35
#if 0
/* from librt/g_bot.c */
extern int rt_bot_minpieces;
extern int rt_bot_tri_per_piece;
#endif

/*
 *  Generic settable parameters.
 *  By setting the "base address" to zero in the bu_structparse call,
 *  the actual memory address is given here as the structure offset.
 *
 *  Strictly speaking, the C language only permits initializers of the
 *  form: address +- constant, where here the intent is to measure the
 *  byte address of the indicated variable.
 *  Matching compensation code for the CRAY is located in librt/parse.c
 */
#if CRAY
#	define byteoffset(_i)	(((int)&(_i)))	/* actually a word offset */
#else
#  if defined (IRIX) && IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
#	define byteoffset(_i)	((size_t)__INTADDR__(&(_i)))
#  else
#    if sgi || __convexc__ || ultrix || _HPUX_SOURCE
	/* "Lazy" way.  Works on reasonable machines with byte addressing */
#	define byteoffset(_i)	((int)((char *)&(_i)))
#    else
#       if defined(__ia64__) || defined(__x86_64__) || defined(__sparc64__)
#		define byteoffset(_i)	((long)(((void *)&(_i))-((void *)0)))
#	else
        	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#		define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
#	endif
#    endif
#  endif
#endif
d420 10
a429 10
	{"%d",	1, "width",	byteoffset(width),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "height",	byteoffset(height),		BU_STRUCTPARSE_FUNC_NULL },
	{"%d",	1, "save_overlaps", byteoffset(save_overlaps),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "perspective", byteoffset(rt_perspective),	BU_STRUCTPARSE_FUNC_NULL },
	{"%f",	1, "angle",	byteoffset(rt_perspective),	BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "rt_bot_minpieces", byteoffset(rt_bot_minpieces),BU_STRUCTPARSE_FUNC_NULL },
	{"%d",  1, "rt_bot_tri_per_piece", byteoffset(rt_bot_tri_per_piece),BU_STRUCTPARSE_FUNC_NULL },
	{"%f",  1, "rt_cline_radius", byteoffset(rt_cline_radius),BU_STRUCTPARSE_FUNC_NULL },
	{"%S",  1, "ray_data_file", byteoffset(ray_data_file),BU_STRUCTPARSE_FUNC_NULL },
	{"i", byteoffset(view_parse[0]),"View_Module-Specific Parameters", 0, BU_STRUCTPARSE_FUNC_NULL },
@


14.12
log
@keep up with the times, readjust the character padding from the frame number and elapsed to the pixel count and rate.  output line still fits exactly onto an 80 character line as before.
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.11 2005/05/04 03:37:18 brlcad Exp $ (BRL)";
d453 1
a453 1
#if !defined(__alpha) && !defined(WIN32) /* XXX Alpha does not support this initialization! */
d811 1
a811 1
#if defined(WIN32) && !defined(__CYGWIN__)
@


14.11
log
@cast stat size to a safe type for printing/saving in case off_t is a 64bit type in st_size otherwise the fread can fail
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.10 2005/05/02 00:29:19 brlcad Exp $ (BRL)";
d925 1
a925 2
		bu_log(
			"Frame %5d: %8d pixels in %10.2f sec = %10.2f pixels/sec\n",
d928 1
a928 2
		bu_log(
			"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/sec (RTFM)\n",
d931 1
a931 2
		bu_log(
			"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/CPU_sec\n",
d934 1
a934 2
		bu_log(
			"Frame %5d: %8d rays   in %10.2f sec = %10.2f rays/sec (wallclock)\n",
@


14.10
log
@do what rt_prep_parallel does.. don't stop just because the bounds are infinite -- keep going since it may just be a collection of halfspaces.  halt if no regions remain too.
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.9 2005/04/26 08:39:36 brlcad Exp $ (BRL)";
d803 2
a804 2
				if (sb.st_size) {
					(void)fread(pixmap,1,sb.st_size,outfp);
@


14.9
log
@use if defined() preprocessor checks for the symbols so cygwin behaves
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.8 2005/04/11 18:32:27 brlcad Exp $ (BRL)";
d1004 12
a1015 3
		rt_bomb("do_ae: no solids active\n");
	if( rtip->mdl_max[X] >= INFINITY || rtip->mdl_max[X] <= -INFINITY )
		rt_bomb("do_ae: infinite model bounds?\n");
@


14.8
log
@add explicit build support for sparc64
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.7 2005/03/30 07:41:13 brlcad Exp $ (BRL)";
d435 1
a435 1
#  if IRIX > 5 && _MIPS_SIM != _MIPS_SIM_ABI32
@


14.7
log
@fix rttherm (and pretty much any of the rt progs) from crashing when the output file already exists and is larger than the size currently being rendered.  also change the pixmap malloc to a bu_malloc to avoid returning null
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.6 2005/03/28 06:31:37 bob1961 Exp $ (BRL)";
d442 1
a442 1
#       if defined(__ia64__) || defined(__x86_64__)
@


14.6
log
@Add code to allow liboptical to be a Windows DLL
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.5 2005/03/24 17:25:32 bob1961 Exp $ (BRL)";
d733 1
a733 1
	pixmap= (unsigned char*)malloc(sizeof(RGBpixel)*width*height);
d791 3
a793 1
			if( stat( framename, &sb ) >= 0 && sb.st_size > 0 )  {
d979 1
a979 1
        free(pixmap);
@


14.5
log
@Add code to open files in binary mode (Windows Only)
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.4 2005/01/30 20:31:09 brlcad Exp $ (BRL)";
a57 3
#include "../librt/debug.h"

extern int	rdebug;			/* RT program debugging (not library) */
a104 6
/***** variables shared with refract.c *****/
extern int	max_bounces;		/* max reflection/recursion level */
extern int	max_ireflect;		/* max internal reflection level */
/***** end variables shared with refract.c *****/


a108 4
/***** variables shared with g_cline.c ******/
extern fastf_t rt_cline_radius;
/***** end variables shared with g_cline.c ******/

d416 1
d420 1
d452 2
a453 1
#if !defined(__alpha)	/* XXX Alpha does not support this initialization! */
@


14.4
log
@update copyright to 2005
@
text
@d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.3 2004/12/24 01:40:00 brlcad Exp $ (BRL)";
d819 3
d823 1
@


14.3
log
@add the mysteriously missing gpl header..
@
text
@d4 1
a4 1
 * Copyright (c) 1987-2004 United States Government as represented by
d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/do.c,v 14.2 2004/12/21 06:38:22 morrison Exp $ (BRL)";
@


14.2
log
@remove the old copyright notice section
@
text
@d1 21
a21 2
/*
 *			D O . C 
d36 1
a36 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/do.c,v 14.1 2004/11/16 19:42:30 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@a14 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1987-2004 by the United States Army.
 *	All rights reserved.
d17 1
a17 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/do.c,v 1.6 2004/09/20 19:37:30 morrison Exp $ (BRL)";
@


1.6
log
@support byteoffsets for the amd64 opterons too.
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/do.c,v 1.5 2004/09/16 06:34:47 morrison Exp $ (BRL)";
d1105 10
@


1.5
log
@quell hook warnings (const)
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/do.c,v 1.4 2004/09/03 19:57:13 morrison Exp $ (BRL)";
d437 1
a437 1
#       if defined(__ia64__)
@


1.4
log
@use ((long)(((void *)&(_i))-((void *)0))) as a byte offset for __ia64__ .. there probably shouldn't be three of these..
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/do.c,v 1.3 2004/08/02 23:01:52 morrison Exp $ (BRL)";
d477 1
a477 1
	bu_vls_from_argv( &str, argc-1, argv+1 );
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/src/rt/do.c,v 1.2 2004/06/08 22:04:34 morrison Exp $ (BRL)";
d437 6
a442 2
	/* "Conservative" way of finding # bytes as diff of 2 char ptrs */
#	define byteoffset(_i)	((int)(((char *)&(_i))-((char *)0)))
@


1.2
log
@obliterate externs.h
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header$ (BRL)";
d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char RCSrt[] = "@@(#)$Header: /cvs/brlcad/rt/do.c,v 11.53 2004/05/10 15:30:49 erikg Exp $ (BRL)";
a42 1
#include "externs.h"
@

