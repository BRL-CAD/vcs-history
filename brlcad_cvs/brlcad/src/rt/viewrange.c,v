head	14.12;
access;
symbols
	rel-7-10-4:14.11
	STABLE:14.11.0.2
	stable-branch:14.4
	rel-7-10-2:14.11
	rel-7-10-0:14.9
	rel-7-8-4:14.6
	rel-7-8-2:14.6
	rel-7-8-0:14.6
	trimnurbs-branch:14.6.0.2
	help:14.6
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.12
date	2007.11.21.16.18.53;	author erikgreenwald;	state Exp;
branches;
next	14.11;

14.11
date	2007.05.18.04.13.51;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.04.17.03.23.57;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.27.01.41.45;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2007.01.23.01.13.46;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2007.01.20.14.37.00;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.18.06.46.24;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.38;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.11;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.24.01.40.01;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.38.22;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.16.03.13.13;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.47;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.12
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@/*                     V I E W R A N G E . C
 * BRL-CAD
 *
 * Copyright (c) 1991-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file viewrange.c
 *
 *  RT-View-Module for visualizing range data.  The output is a
 *  UNIX-Plot file.  Direction vectors are preserved so that
 *  perspective is theoretically possible.
 *  The algorithm is based on plotting all the hit distances for all
 *  the pixels ray-traced.
 *
 *  Author -
 *	Susanne L. Muuss, J.D.
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
#ifndef lint
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.11 2007/05/18 04:13:51 brlcad Exp $";
#endif

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "plot3.h"

/* private */
#include "./ext.h"
#include "rtprivate.h"


#define CELLNULL ( (struct cell *) 0)

struct cell {
	float	c_dist;			/* distance from emanation plane to in_hit */
	point_t	c_hit;			/* 3-space hit point of ray */
};

extern	int	width;			/* # of pixels in X; picture width */
extern int	npsw;			/* number of worker PSWs to run */
float		max_dist;
struct cell	*cellp;

int		use_air = 0;		/* Internal air recognition is off */

int		using_mlib = 0;		/* Material routines NOT used */

/* Viewing module specific "set" variables */
struct bu_structparse view_parse[] = {
	{"",	0, (char *)0,	0,	BU_STRUCTPARSE_FUNC_NULL }
};


const char title[] = "RT Range Plot";
const char usage[] = "\
Usage:  rtrange [options] model.g objects... >file.ray\n\
Options:\n\
 -s #		Grid size in pixels, default 512\n\
 -a Az		Azimuth in degrees	(conflicts with -M)\n\
 -e Elev	Elevation in degrees	(conflicts with -M)\n\
 -M		Read model2view matrix on stdin (conflicts with -a, -e)\n\
 -o model.g	Specify output file (default=stdout)\n\
 -U #		Set use_air boolean to # (default=1)\n\
 -x #		Set librt debug flags\n\
";


int	rayhit(register struct application *ap, struct partition *PartHeadp, struct seg *segp);
int	raymiss(register struct application *ap);


/*
 *  			V I E W _ I N I T
 *
 *  This routine is called by main().  It initializes the entire run, i.e.,
 *  it does things such as opening files, etc., which must be done before
 *  any other computations take place.  It is called only once per run.
 *  Pointers to rayhit() and raymiss() are set up and are later called from
 *  do_run().
 */

int
view_init(register struct application *ap, char *file, char *obj, int minus_o)
{

	ap->a_hit = rayhit;
	ap->a_miss = raymiss;
	ap->a_onehit = 1;

	output_is_binary = 1;		/* output is binary */

	return(0);			/* No framebuffer needed */
}

/*
 *			V I E W _ 2 I N I T
 *
 *  A null-function.
 *  View_2init is called by do_frame(), which in turn is called by
 *  main() in rt.c.  This routine is called once per frame.  Static
 *  images only have one frame.  Animations have MANY frames, and bounding
 *  boxes, for example, need to be computed once per frame.
 *  Never preclude a new and nifty animation: rule: if it's a variable, it can
 *  change from frame to frame ( frame/picture width; angle between surface
 *  normals triggering shading.... etc).
 */

void
view_2init(struct application *ap)
{
	if( outfp == NULL )
		bu_exit(EXIT_FAILURE, "outfp is NULL\n");

	/*
	 *  For now, RTRANGE does not operate in parallel, while ray-tracing.
	 *  However, not dropping out of parallel mode until here permits
	 *  tree walking and database prepping to still be done in parallel.
	 */
	if( npsw >= 1 )  {
		bu_log("Note: changing from %d cpus to 1 cpu\n", npsw );
		npsw = 1;		/* Disable parallel processing */
	}


	/* malloc() a buffer that has room for as many struct cell 's
	 * as the incoming file is wide (width).
	 * Rather than using malloc(), though, bu_malloc() is used.  This
	 * has the advantage of inbuild error-checking and automatic aborting
	 * if there is no memory.  Also, bu_malloc() takes a string as its
	 * final parameter: this tells the user exactly where memory ran out.
	 */


	cellp = (struct cell *)bu_malloc(sizeof(struct cell) * width,
		"cell buffer" );


	/* Obtain the maximun distance within the model to use as the
	 * background distance.  Also get the coordinates of the model's
	 * bounding box and feed them to
	 * pdv_3space.  This will allow the image to appear in the plot
	 * starting with the same size as the model.
	 */

	pdv_3space(outfp, ap->a_rt_i->rti_pmin, ap->a_rt_i->rti_pmax);

	/* Find the max dist fron emantion plane to end of model
	 * space.  This can be twice the radius of the bounding
	 * sphere.
	 */

	max_dist = 2 * (ap->a_rt_i->rti_radius);
}


/*
 *			R A Y M I S S
 *
 *  This function is called by rt_shootray(), which is called by
 *  do_frame(). Records coordinates where a miss is detected.
 */

int
raymiss(register struct application *ap)
{

	struct	cell	*posp;		/* store the current cell position */

	/* Getting defensive.... just in case. */
	if(ap->a_x > width)  {
		bu_exit(EXIT_FAILURE, "raymiss: pixels exceed width\n");
	}

	posp = &(cellp[ap->a_x]);

	/* Find the hit point for the miss. */

	VJOIN1(posp->c_hit, ap->a_ray.r_pt, max_dist, ap->a_ray.r_dir);
	posp->c_dist = max_dist;

	return(0);
}

/*
 *			V I E W _ P I X E L
 *
 *  This routine is called from do_run(), and in this case does nothing.
 */

void
view_pixel(void)
{
	return;
}

void view_setup(void) {}
void view_cleanup(void) {}


/*
 *			R A Y H I T
 *
 *  Rayhit() is called by rt_shootray() when a hit is detected.  It
 *  computes the hit distance, the distance traveled by the
 *  ray, and the direction vector.
 *
 */

int
rayhit(struct application *ap, register struct partition *PartHeadp, struct seg *segp)
{
	register struct partition *pp = PartHeadp->pt_forw;
	struct	cell	*posp;		/* stores current cell position */


	if( pp == PartHeadp )
		return(0);		/* nothing was actually hit?? */


	/* Getting defensive.... just in case. */
	if(ap->a_x > width)  {
		bu_exit(EXIT_FAILURE, "rayhit: pixels exceed width\n");
	}

	posp = &(cellp[ap->a_x]);

	/* Calculate the hit distance and the direction vector.  This is done
	 * by VJOIN1(hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir).
	 */

	VJOIN1(pp->pt_inhit->hit_point, ap->a_ray.r_pt,
		pp->pt_inhit->hit_dist, ap->a_ray.r_dir);

	/* Now store the distance and the direction vector as appropriate.
	 * Output the ray data: screen plane (pixel) coordinates
	 * for x and y positions of a ray, region_id, and hit_distance.
	 * The x and y positions are represented by ap->a_x and ap->a_y.
	 *
	 *  Assume all rays are parallel.
	 */

	posp->c_dist = pp->pt_inhit->hit_dist;
	VMOVE(posp->c_hit, pp->pt_inhit->hit_point);

	return(0);
}

/*
 *			V I E W _ E O L
 *
 *  View_eol() is called by rt_shootray() in do_run().
 *  This routine is called by worker.c whenever there is a full scanline.
 *  worker.c figures out what is a full scanline.  Whenever there
 *  is a full buffer in memory, the hit distances ar plotted.
 */

void	view_eol(struct application *ap)
{
	struct cell	*posp;
	int		i;
	int		cont;		/* continue flag */

	posp = &(cellp[0]);
	cont = 0;

	/* Plot the starting point and set cont to 0.  Then
	 * march along the entire array and continue to plot the
	 * hit points based on their distance from the emanation
	 * plane. When consecutive hit-points with identical distances
	 * are found, cont is set to one so that the entire sequence
	 * of like-distanced hit-points can be plotted together.
	 */

	pdv_3move( outfp, posp->c_hit );

	for( i = 0; i < width-1; i++, posp++ )  {
		if( posp->c_dist == (posp+1)->c_dist )  {
			cont = 1;
			continue;
		} else  {
			if(cont)  {
				pdv_3cont(outfp, posp->c_hit);
				cont = 0;
			}
			pdv_3cont(outfp, (posp+1)->c_hit);
		}
	}

	/* Catch the boundary condition if the last couple of cells
	 * heve the same distance.
	 */

	pdv_3cont(outfp, posp->c_hit);
}


/*
 *			V I E W _ E N D
 *
 *  View_end() is called by rt_shootray in do_run().
 */

void
view_end(struct application *ap)
{

	fflush(outfp);
}


void application_init (void) {}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.11
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d38 1
a38 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.10 2007/04/17 03:23:57 brlcad Exp $";
d44 1
d137 1
a137 1
		bu_bomb("outfp is NULL\n");
d196 1
a196 1
		bu_bomb("raymiss: pixels exceed width\n");
d247 1
a247 1
		bu_bomb("rayhit: pixels exceed width\n");
@


14.10
log
@redo the client-side version reporting to use the new brlcad_version() interface, utilizing a per-binary title as needed, instead of the former vers.sh setup.
@
text
@d38 1
a38 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.9 2007/01/27 01:41:45 brlcad Exp $";
d136 1
a136 1
		rt_bomb("outfp is NULL\n");
d195 1
a195 1
		rt_bomb("raymiss: pixels exceed width\n");
d246 1
a246 1
		rt_bomb("rayhit: pixels exceed width\n");
@


14.9
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.8 2007/01/23 01:13:46 brlcad Exp $";
d49 3
a53 1
#include "plot3.h"
d78 2
a79 1
char usage[] = "\
d91 1
d95 1
@


14.8
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.7 2007/01/20 14:37:00 brlcad Exp $";
a329 1

@


14.7
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.6 2006/01/18 06:46:24 brlcad Exp $";
@


14.6
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 1991-2006 United States Government as represented by
d39 1
a39 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.5 2005/10/23 04:44:38 brlcad Exp $";
@


14.5
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1991-2005 United States Government as represented by
d39 1
a39 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.4 2005/01/30 20:31:11 brlcad Exp $";
@


14.4
log
@update copyright to 2005
@
text
@d31 1
a31 1
 *  
d36 1
a36 1
 *  
d39 1
a39 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.3 2004/12/24 01:40:01 brlcad Exp $";
d160 1
a160 1
	 * bounding box and feed them to 
d226 1
a226 1
 *  
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d31 1
a31 1
 *
d36 1
a36 1
 *
d39 1
a39 1
static const char RCSrayrange[] = "@@(#)$Header$";
d160 1
a160 1
	 * bounding box and feed them to
d226 1
a226 1
 *
@


14.3
log
@add the mysteriously missing gpl header..
@
text
@d4 1
a4 1
 * Copyright (c) 1991-2004 United States Government as represented by
d39 1
a39 1
static const char RCSrayrange[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/viewrange.c,v 14.2 2004/12/21 06:38:22 morrison Exp $";
@


14.2
log
@remove the old copyright notice section
@
text
@d1 21
a21 2
/*
 *			V I E W R A N G E
d39 1
a39 1
static const char RCSrayrange[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewrange.c,v 14.1 2004/11/16 19:42:31 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@a17 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1991-2004 by the United States Army.
 *	All rights reserved.
d20 1
a20 1
static const char RCSrayrange[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewrange.c,v 1.3 2004/09/16 03:13:13 morrison Exp $";
@


1.3
log
@a_hit hook functions are now also given a segment pointer, so match prototype even if unused and quell the warnings
@
text
@d23 1
a23 1
static const char RCSrayrange[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewrange.c,v 1.2 2004/08/02 23:01:52 morrison Exp $";
d317 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@a21 2


d23 1
a23 1
static const char RCSrayrange[] = "@@(#)$Header: /cvs/brlcad/src/rt/viewrange.c,v 1.1 2004/05/20 15:20:47 morrison Exp $";
a27 2


d38 1
d73 2
a74 1
int	rayhit(register struct application *ap, struct partition *PartHeadp), raymiss(register struct application *ap);
d214 1
a214 1
rayhit(struct application *ap, register struct partition *PartHeadp)
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d25 1
a25 1
static const char RCSrayrange[] = "@@(#)$Header: /cvs/brlcad/rt/viewrange.c,v 11.14 2004/05/10 15:30:49 erikg Exp $";
d28 1
a28 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

