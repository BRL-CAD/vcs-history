head	14.25;
access;
symbols
	rel-7-10-4:14.18
	STABLE:14.18.0.2
	stable-branch:14.5
	rel-7-10-2:14.18
	rel-7-10-0:14.17
	rel-7-8-4:14.14
	rel-7-8-2:14.13
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.5
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.3
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.25
date	2007.12.17.07.53.19;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.12.17.02.16.54;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.11.28.14.11.28;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.11.21.20.49.11;	author erikgreenwald;	state Exp;
branches;
next	14.21;

14.21
date	2007.11.21.19.28.07;	author erikgreenwald;	state Exp;
branches;
next	14.20;

14.20
date	2007.11.21.16.18.53;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.09.15.16.23.20;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.18.04.13.51;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.27.01.41.45;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.46;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.37.00;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.08.01.15.01.39;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.05.21.14.31.26;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.23.04.05.59;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.24;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.12.23.21.26.46;	author bob1961;	state Exp;
branches;
next	14.9;

14.9
date	2005.12.22.18.56.03;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.38;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.06.15.04.34.53;	author brlcad;	state Exp;
branches
	14.7.6.1;
next	14.6;

14.6
date	2005.04.22.05.41.44;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.01.30.20.31.11;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.20.00.53.16;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.24.01.40.01;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.06.38.23;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.31;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.48;	author morrison;	state Exp;
branches;
next	;

14.7.6.1
date	2005.11.13.13.46.19;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.25
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                        W O R K E R . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file worker.c
 *
 *  Routines to handle initialization of the grid,
 *  and dispatch of the first rays from the eye.
 *
 *  Author -
 *	Michael John Muuss
 *
 */

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "./ext.h"
#include "rtprivate.h"
#include "fb.h"					/* Added because RGBpixel is now needed in do_pixel() */

/* for fork/pipe linux timing hack */
#ifdef USE_FORKED_THREADS
#  include <sys/select.h>
#  include <sys/types.h>
#  ifdef HAVE_SYS_WAIT_H
#    include <sys/wait.h>
#  endif
#  include <unistd.h>
#endif

#define CRT_BLEND(v)	(0.26*(v)[X] + 0.66*(v)[Y] + 0.08*(v)[Z])
#define NTSC_BLEND(v)	(0.30*(v)[X] + 0.59*(v)[Y] + 0.11*(v)[Z])

extern int		query_x;
extern int		query_y;
extern int		Query_one_pixel;
extern int		query_rdebug;
extern int		query_debug;

extern unsigned	char	*pixmap;		/* pixmap for rerendering of black pixels */


int		per_processor_chunk = 0;	/* how many pixels to do at once */

fastf_t		gift_grid_rounding = 0;		/* set to 25.4 for inches */

point_t		viewbase_model;	/* model-space location of viewplane corner */

int			fullfloat_mode = 0;
int			reproject_mode = 0;
struct floatpixel	*curr_float_frame;	/* buffer of full frame */
struct floatpixel	*prev_float_frame;
int		reproj_cur;	/* number of pixels reprojected this frame */
int		reproj_max;	/* out of total number of pixels */

/* Local communication with worker() */
int cur_pixel;			/* current pixel number, 0..last_pixel */
int last_pixel;			/* last pixel number */

int	stop_worker = 0;

/*
 * For certain hypersample values there is a particular advantage to subdividing
 * the pixel and shooting a ray in each sub-pixel.  This structure keeps track of
 * those patterns
 */
struct jitter_pattern {
	int   num_samples;/* number of samples, or coordinate pairs in coords[] */
	float rand_scale[2]; /* amount to scale bn_rand_half value */
	float coords[32]; /* center of each sub-pixel */
};

static struct jitter_pattern pt_pats[] = {

	{4, {0.5, 0.5}, 	/* -H 3 */
	 { 0.25, 0.25,
	   0.25, 0.75,
	   0.75, 0.25,
	   0.75, 0.75 } },

	{5, {0.4, 0.4}, 	/* -H 4 */
	 { 0.2, 0.2,
	   0.2, 0.8,
	   0.8, 0.2,
	   0.8, 0.8,
	   0.5, 0.5} },

	{9, {0.3333, 0.3333}, /* -H 8 */
	 { 0.17, 0.17,  0.17, 0.5,  0.17, 0.82,
	   0.5, 0.17,    0.5, 0.5,   0.5, 0.82,
	   0.82, 0.17,  0.82, 0.5,  0.82, 0.82 } },

	{16, {0.25, 0.25}, 	/* -H 15 */
	 { 0.125, 0.125,  0.125, 0.375, 0.125, 0.625, 0.125, 0.875,
	   0.375, 0.125,  0.375, 0.375, 0.375, 0.625, 0.375, 0.875,
	   0.625, 0.125,  0.625, 0.375, 0.625, 0.625, 0.625, 0.875,
	   0.875, 0.125,  0.875, 0.375, 0.875, 0.625, 0.875, 0.875} },

	{ 0, {0.0, 0.0}, {0.0} } /* must be here to stop search */
};


/***********************************************************************
 *
 *  compute_point
 *
 * Compute the origin for this ray, based upon the number of samples
 * per pixel and the number of the current sample.  For certain
 * ray-counts, it is highly advantageous to subdivide the pixel and
 * fire each ray in a specific sub-section of the pixel.
 */
static void
jitter_start_pt(vect_t point, struct application *a, int samplenum, int pat_num)
{
	fastf_t dx, dy;

	if (pat_num >= 0) {
		dx = a->a_x + pt_pats[pat_num].coords[samplenum*2] +
			(bn_rand_half(a->a_resource->re_randptr) *
			 pt_pats[pat_num].rand_scale[X] );

		dy = a->a_y + pt_pats[pat_num].coords[samplenum*2 + 1] +
			(bn_rand_half(a->a_resource->re_randptr) *
			 pt_pats[pat_num].rand_scale[Y] );
	} else {
		dx = a->a_x + bn_rand_half(a->a_resource->re_randptr);
		dy = a->a_y + bn_rand_half(a->a_resource->re_randptr);
	}
	VJOIN2( point, viewbase_model, dx, dx_model, dy, dy_model );
}


void do_pixel(int cpu,
	      int pat_num,
	      int pixelnum)
{
    int i;
    struct	application	a;
    struct	pixel_ext	pe;
    vect_t			stereo_point;		/* Ref point on eye or view plane */
    vect_t			point;		/* Ref point on eye or view plane */
    vect_t			colorsum = {(fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0};
    int				samplenum = 0;
    static const double one_over_255 = 1.0 / 255.0;
    register RGBpixel		pixel = {0, 0, 0};
    const int pindex = (pixelnum * sizeof(RGBpixel));

    /* Obtain fresh copy of global application struct */
    a = ap;				/* struct copy */
    a.a_resource = &resource[cpu];

    if( incr_mode )  {
	register int i = 1<<incr_level;
	a.a_y = pixelnum/i;
	a.a_x = pixelnum - (a.a_y * i);
	/*	a.a_x = pixelnum%i; */
	if( incr_level != 0 )  {
	    /* See if already done last pass */
	    if( ((a.a_x & 1) == 0 ) &&
		((a.a_y & 1) == 0 ) )
		return;
	}
	a.a_x <<= (incr_nlevel-incr_level);
	a.a_y <<= (incr_nlevel-incr_level);
    } else {
	a.a_y = pixelnum/width;
	a.a_x = pixelnum - (a.a_y * width);
	/*	a.a_x = pixelnum%width; */
    }

    if (Query_one_pixel) {
	if (a.a_x == query_x && a.a_y == query_y) {
	    rdebug = query_rdebug;
	    rt_g.debug = query_debug;
	} else {
	    rt_g.debug = rdebug = 0;
	}
    }

    if( sub_grid_mode )  {
	if( a.a_x < sub_xmin || a.a_x > sub_xmax )
	    return;
	if( a.a_y < sub_ymin || a.a_y > sub_ymax )
	    return;
    }
    if( fullfloat_mode )  {
	register struct floatpixel	*fp;
	fp = &curr_float_frame[a.a_y*width + a.a_x];
	if( fp->ff_frame >= 0 )  {
	    return;	/* pixel was reprojected */
	}
    }

    /* Check the pixel map to determine if this image should be rendered or not */
    if (pixmap) {
	a.a_user= 1;	/* Force Shot Hit */

	if (pixmap[pindex + RED] + pixmap[pindex + GRN] + pixmap[pindex + BLU]) {
	    /* non-black pixmap pixel */

	    a.a_color[RED]= (double)(pixmap[pindex + RED]) * one_over_255;
	    a.a_color[GRN]= (double)(pixmap[pindex + GRN]) * one_over_255;
	    a.a_color[BLU]= (double)(pixmap[pindex + BLU]) * one_over_255;

	    /* we're done */
	    view_pixel( &a );
	    if( a.a_x == width-1 ) {
		view_eol( &a );		/* End of scan line */
	    }
	    return;
	}
    }

    /* our starting point, used for non-jitter */
    VJOIN2 (point, viewbase_model, a.a_x, dx_model, a.a_y, dy_model);

    /* not tracing the corners of a prism by default */
    a.a_pixelext=(struct pixel_ext *)NULL;

    /* black or no pixmap, so compute the pixel(s) */

    /* LOOP BELOW IS UNROLLED ONE SAMPLE SINCE THAT'S THE COMMON CASE.
     *
     * XXX - If you edit the unrolled or non-unrolled section, be sure
     * to edit the other section.
     */
    if (hypersample == 0) {
	/* not hypersampling, so just do it */

	/****************/
	/* BEGIN UNROLL */
	/****************/

	if (jitter & JITTER_CELL ) {
	    jitter_start_pt(point, &a, samplenum, pat_num);
	}

	if (a.a_rt_i->rti_prismtrace) {
	    /* compute the four corners */
	    pe.magic = PIXEL_EXT_MAGIC;
	    VJOIN2(pe.corner[0].r_pt, viewbase_model, a.a_x, dx_model, a.a_y, dy_model );
	    VJOIN2(pe.corner[1].r_pt, viewbase_model, (a.a_x+1), dx_model, a.a_y, dy_model );
	    VJOIN2(pe.corner[2].r_pt, viewbase_model, (a.a_x+1), dx_model, (a.a_y+1), dy_model );
	    VJOIN2(pe.corner[3].r_pt, viewbase_model, a.a_x, dx_model, (a.a_y+1), dy_model );
	    a.a_pixelext = &pe;
	}

	if( rt_perspective > 0.0 )  {
	    VSUB2( a.a_ray.r_dir, point, eye_model );
	    VUNITIZE( a.a_ray.r_dir );
	    VMOVE( a.a_ray.r_pt, eye_model );
	    if (a.a_rt_i->rti_prismtrace) {
		VSUB2(pe.corner[0].r_dir, pe.corner[0].r_pt, eye_model);
		VSUB2(pe.corner[1].r_dir, pe.corner[1].r_pt, eye_model);
		VSUB2(pe.corner[2].r_dir, pe.corner[2].r_pt, eye_model);
		VSUB2(pe.corner[3].r_dir, pe.corner[3].r_pt, eye_model);
	    }
	} else {
	    VMOVE( a.a_ray.r_pt, point );
	    VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );

	    if (a.a_rt_i->rti_prismtrace) {
		VMOVE(pe.corner[0].r_dir, a.a_ray.r_dir);
		VMOVE(pe.corner[1].r_dir, a.a_ray.r_dir);
		VMOVE(pe.corner[2].r_dir, a.a_ray.r_dir);
		VMOVE(pe.corner[3].r_dir, a.a_ray.r_dir);
	    }
	}
	if( report_progress )  {
	    report_progress = 0;
	    bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
	}

	a.a_level = 0;		/* recursion level */
	a.a_purpose = "main ray";
	(void)rt_shootray( &a );

	if( stereo )  {
	    fastf_t right,left;

	    right = CRT_BLEND(a.a_color);

	    VSUB2( stereo_point, point, left_eye_delta );
	    if( rt_perspective > 0.0 )  {
		VSUB2( a.a_ray.r_dir, stereo_point, eye_model );
		VUNITIZE( a.a_ray.r_dir );
		VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
	    } else {
		VMOVE( a.a_ray.r_pt, stereo_point );
	    }
	    a.a_level = 0;		/* recursion level */
	    a.a_purpose = "left eye ray";
	    (void)rt_shootray( &a );

	    left = CRT_BLEND(a.a_color);
	    VSET( a.a_color, left, 0, right );
	}
	VADD2( colorsum, colorsum, a.a_color );

	/**************/
	/* END UNROLL */
	/**************/

    } else {
	/* hypersampling, so iterate */

	for( samplenum=0; samplenum<=hypersample; samplenum++ )  {
	    /* shoot at a point based on the jitter pattern number */

	    /**********************/
	    /* BEGIN NON-UNROLLED */
	    /**********************/

	    if (jitter & JITTER_CELL ) {
		jitter_start_pt(point, &a, samplenum, pat_num);
	    }

	    if (a.a_rt_i->rti_prismtrace) {
		/* compute the four corners */
		pe.magic = PIXEL_EXT_MAGIC;
		VJOIN2(pe.corner[0].r_pt, viewbase_model, a.a_x, dx_model, a.a_y, dy_model );
		VJOIN2(pe.corner[1].r_pt, viewbase_model, (a.a_x+1), dx_model, a.a_y, dy_model );
		VJOIN2(pe.corner[2].r_pt, viewbase_model, (a.a_x+1), dx_model, (a.a_y+1), dy_model );
		VJOIN2(pe.corner[3].r_pt, viewbase_model, a.a_x, dx_model, (a.a_y+1), dy_model );
		a.a_pixelext = &pe;
	    }

	    if( rt_perspective > 0.0 )  {
		VSUB2( a.a_ray.r_dir, point, eye_model );
		VUNITIZE( a.a_ray.r_dir );
		VMOVE( a.a_ray.r_pt, eye_model );
		if (a.a_rt_i->rti_prismtrace) {
		    VSUB2(pe.corner[0].r_dir, pe.corner[0].r_pt, eye_model);
		    VSUB2(pe.corner[1].r_dir, pe.corner[1].r_pt, eye_model);
		    VSUB2(pe.corner[2].r_dir, pe.corner[2].r_pt, eye_model);
		    VSUB2(pe.corner[3].r_dir, pe.corner[3].r_pt, eye_model);
		}
	    } else {
		VMOVE( a.a_ray.r_pt, point );
		VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );

		if (a.a_rt_i->rti_prismtrace) {
		    VMOVE(pe.corner[0].r_dir, a.a_ray.r_dir);
		    VMOVE(pe.corner[1].r_dir, a.a_ray.r_dir);
		    VMOVE(pe.corner[2].r_dir, a.a_ray.r_dir);
		    VMOVE(pe.corner[3].r_dir, a.a_ray.r_dir);
		}
	    }
	    if( report_progress )  {
		report_progress = 0;
		bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
	    }

	    a.a_level = 0;		/* recursion level */
	    a.a_purpose = "main ray";
	    (void)rt_shootray( &a );

	    if( stereo )  {
		fastf_t right,left;

		right = CRT_BLEND(a.a_color);

		VSUB2( stereo_point, point, left_eye_delta );
		if( rt_perspective > 0.0 )  {
		    VSUB2( a.a_ray.r_dir, stereo_point, eye_model );
		    VUNITIZE( a.a_ray.r_dir );
		    VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
		} else {
		    VMOVE( a.a_ray.r_pt, stereo_point );
		}
		a.a_level = 0;		/* recursion level */
		a.a_purpose = "left eye ray";
		(void)rt_shootray( &a );

		left = CRT_BLEND(a.a_color);
		VSET( a.a_color, left, 0, right );
	    }
	    VADD2( colorsum, colorsum, a.a_color );

	    /********************/
	    /* END NON-UNROLLED */
	    /********************/
	} /* for samplenum <= hypersample */

	{
	    /* scale the hypersampled results */
	    fastf_t f;
	    f = 1.0 / (hypersample+1);
	    VSCALE( a.a_color, colorsum, f );
	}
    } /* end unrolling else case */

    /* bu_log("2: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]); */

    /* we're done */
    view_pixel( &a );
    if( a.a_x == width-1 ) {
	view_eol( &a );		/* End of scan line */
    }
    return;
}


/*
 *  			W O R K E R
 *
 *  Compute some pixels, and store them.
 *  A "self-dispatching" parallel algorithm.
 *  Executes until there is no more work to be done, or is told to stop.
 *
 *  In order to reduce the traffic through the res_worker critical section,
 *  a multiple pixel block may be removed from the work queue at once.
 *
 *  For a general-purpose version, see LIBRT rt_shoot_many_rays()
 */
void
worker(int cpu, genptr_t arg)
{
	int	pixel_start;
	int	pixelnum;
	int	pat_num = -1;

	/* The more CPUs at work, the bigger the bites we take */
	if( per_processor_chunk <= 0 )  per_processor_chunk = npsw;

	if( cpu >= MAX_PSW )  {
		bu_log("rt/worker() cpu %d > MAX_PSW %d, array overrun\n", cpu, MAX_PSW);
		bu_exit(EXIT_FAILURE, "rt/worker() cpu > MAX_PSW, array overrun\n");
	}
	RT_CK_RESOURCE( &resource[cpu] );

	pat_num = -1;
	if (hypersample) {
		int i, ray_samples;

		ray_samples = hypersample + 1;
		for (i=0 ; pt_pats[i].num_samples != 0 ; i++) {
			if (pt_pats[i].num_samples == ray_samples) {
				pat_num = i;
				goto pat_found;
			}
		}
	}
 pat_found:

	if (transpose_grid) {
	  int     tmp;

	  /* switch cur_pixel and last_pixel */
	  tmp = cur_pixel;
	  cur_pixel = last_pixel;
	  last_pixel = tmp;

	  while (1)  {
	    if (stop_worker)
	      return;

	    bu_semaphore_acquire(RT_SEM_WORKER);
	    pixel_start = cur_pixel;
	    cur_pixel -= per_processor_chunk;
	    bu_semaphore_release(RT_SEM_WORKER);

	    for (pixelnum = pixel_start; pixelnum > pixel_start-per_processor_chunk; pixelnum--) {
	      if (pixelnum < last_pixel)
		return;

	      do_pixel(cpu, pat_num, pixelnum);
	    }
	  }
	} else {
	  while (1) {
	    if (stop_worker)
	      return;

	    bu_semaphore_acquire(RT_SEM_WORKER);
	    pixel_start = cur_pixel;
	    cur_pixel += per_processor_chunk;
	    bu_semaphore_release(RT_SEM_WORKER);

	    for (pixelnum = pixel_start; pixelnum < pixel_start+per_processor_chunk; pixelnum++) {

	      if (pixelnum > last_pixel)
		return;

	      do_pixel(cpu, pat_num, pixelnum);
	    }
	  }
	}
}


/*
 *			G R I D _ S E T U P
 *
 *  In theory, the grid can be specified by providing any two of
 *  these sets of parameters:
 *	number of pixels (width, height)
 *	viewsize (in model units, mm)
 *	number of grid cells (cell_width, cell_height)
 *  however, for now, it is required that the view size always be specified,
 *  and one or the other parameter be provided.
 */
void
grid_setup(void)
{
	vect_t temp;
	mat_t toEye;

	if( viewsize <= 0.0 )
		bu_exit(EXIT_FAILURE, "viewsize <= 0");
	/* model2view takes us to eye_model location & orientation */
	MAT_IDN( toEye );
	MAT_DELTAS_VEC_NEG( toEye, eye_model );
	Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
	bn_mat_mul( model2view, Viewrotscale, toEye );
	bn_mat_inv( view2model, model2view );

	/* Determine grid cell size and number of pixels */
	if( cell_newsize ) {
		if( cell_width <= 0.0 ) cell_width = cell_height;
		if( cell_height <= 0.0 ) cell_height = cell_width;
		width = (viewsize / cell_width) + 0.99;
		height = (viewsize / (cell_height*aspect)) + 0.99;
		cell_newsize = 0;
	} else {
		/* Chop -1.0..+1.0 range into parts */
		cell_width = viewsize / width;
		cell_height = viewsize / (height*aspect);
	}

	/*
	 *  Optional GIFT compatabilty, mostly for RTG3.
	 *  Round coordinates of lower left corner to fall on integer-
	 *  valued coordinates, in "gift_grid_rounding" units.
	 */
	if( gift_grid_rounding > 0.0 )  {
		point_t		v_ll;		/* view, lower left */
		point_t		m_ll;		/* model, lower left */
		point_t		hv_ll;		/* hv, lower left*/
		point_t		hv_wanted;
		vect_t		hv_delta;
		vect_t		m_delta;
		mat_t		model2hv;
		mat_t		hv2model;

		/* Build model2hv matrix, including mm2inches conversion */
		MAT_COPY( model2hv, Viewrotscale );
		model2hv[15] = gift_grid_rounding;
		bn_mat_inv( hv2model, model2hv );

		VSET( v_ll, -1, -1, 0 );
		MAT4X3PNT( m_ll, view2model, v_ll );
		MAT4X3PNT( hv_ll, model2hv, m_ll );
		VSET( hv_wanted, floor(hv_ll[X]), floor(hv_ll[Y]),floor(hv_ll[Z]) );
		VSUB2( hv_delta, hv_ll, hv_wanted );

		MAT4X3PNT( m_delta, hv2model, hv_delta );
		VSUB2( eye_model, eye_model, m_delta );
		MAT_DELTAS_VEC_NEG( toEye, eye_model );
		bn_mat_mul( model2view, Viewrotscale, toEye );
		bn_mat_inv( view2model, model2view );
	}

	/* Create basis vectors dx and dy for emanation plane (grid) */
	VSET( temp, 1, 0, 0 );
	MAT3X3VEC( dx_unit, view2model, temp );	/* rotate only */
	VSCALE( dx_model, dx_unit, cell_width );

	VSET( temp, 0, 1, 0 );
	MAT3X3VEC( dy_unit, view2model, temp );	/* rotate only */
	VSCALE( dy_model, dy_unit, cell_height );

	if( stereo )  {
		/* Move left 2.5 inches (63.5mm) */
		VSET( temp, -63.5*2.0/viewsize, 0, 0 );
		bu_log("red eye: moving %f relative screen (left)\n", temp[X]);
		MAT4X3VEC( left_eye_delta, view2model, temp );
		VPRINT("left_eye_delta", left_eye_delta);
	}

	/* "Lower left" corner of viewing plane */
	if( rt_perspective > 0.0 )  {
		fastf_t	zoomout;
		zoomout = 1.0 / tan( bn_degtorad * rt_perspective / 2.0 );
		VSET( temp, -1, -1/aspect, -zoomout );	/* viewing plane */
		/*
		 * divergence is perspective angle divided by the number
		 * of pixels in that angle. Extra factor of 0.5 is because
		 * perspective is a full angle while divergence is the tangent
		 * (slope) of a half angle.
		 */
		ap.a_diverge = tan( bn_degtorad * rt_perspective * 0.5 / width );
		ap.a_rbeam = 0;
	}  else  {
		/* all rays go this direction */
		VSET( temp, 0, 0, -1 );
		MAT4X3VEC( ap.a_ray.r_dir, view2model, temp );
		VUNITIZE( ap.a_ray.r_dir );

		VSET( temp, -1, -1/aspect, 0 );	/* eye plane */
		ap.a_rbeam = 0.5 * viewsize / width;
		ap.a_diverge = 0;
	}
	if( NEAR_ZERO(ap.a_rbeam, SMALL) && NEAR_ZERO(ap.a_diverge, SMALL) )
		bu_exit(EXIT_FAILURE, "zero-radius beam");
	MAT4X3PNT( viewbase_model, view2model, temp );

	if( jitter & JITTER_FRAME )  {
		/* Move the frame in a smooth circular rotation in the plane */
		fastf_t		ang;	/* radians */
		fastf_t		dx, dy;

		ang = curframe * frame_delta_t * bn_twopi / 10;	/* 10 sec period */
		dx = cos(ang) * 0.5;	/* +/- 1/4 pixel width in amplitude */
		dy = sin(ang) * 0.5;
		VJOIN2( viewbase_model, viewbase_model,
			dx, dx_model,
			dy, dy_model );
	}

	if( cell_width <= 0 || cell_width >= INFINITY ||
	    cell_height <= 0 || cell_height >= INFINITY )  {
		bu_log("grid_setup: cell size ERROR (%g, %g) mm\n",
			cell_width, cell_height );
		bu_exit(EXIT_FAILURE, "cell size");
	}
	if( width <= 0 || height <= 0 )  {
		bu_log("grid_setup: ERROR bad image size (%d, %d)\n",
			width, height );
		bu_exit(EXIT_FAILURE, "bad size");
	}
}


/*
 *			D O _ R U N
 *
 *  Compute a run of pixels, in parallel if the hardware permits it.
 *
 *  For a general-purpose version, see LIBRT rt_shoot_many_rays()
 */
void do_run( int a, int b )
{
	int		cpu;

#  ifdef USE_FORKED_THREADS
	int pid, wpid;
	int waitret;
	void *buffer = (void*)0;
	int p[2] = {0,0};
	struct resource *tmp_res;

	if( rt_g.rtg_parallel ) {
		buffer = bu_calloc(npsw, sizeof(resource[0]), "buffer");
		if (pipe(p) == -1) {
			perror("pipe failed");
		}
	}
#  endif

	cur_pixel = a;
	last_pixel = b;

	if( !rt_g.rtg_parallel )  {
		/*
		 * SERIAL case -- one CPU does all the work.
		 */
		npsw = 1;
		worker(0, NULL);
	} else {
		/*
		 *  Parallel case.
		 */

		/* hack to bypass a bug in the Linux 2.4 kernel pthreads
		 * implementation. cpu statistics are only traceable on a
		 * process level and the timers will report effectively no
		 * elapsed cpu time.  this allows the stats of all threads
		 * to be gathered up by an encompassing process that may
		 * be timed.
		 *
		 * XXX this should somehow only apply to a build on a 2.4
		 * linux kernel.
		 */
#  ifdef USE_FORKED_THREADS
		pid = fork();
		if (pid < 0) {
			perror("fork failed");
			bu_exit(1, NULL);
		} else if (pid == 0) {
#  endif

			bu_parallel( worker, npsw, NULL );

#  ifdef USE_FORKED_THREADS
			/* send raytrace instance data back to the parent */
			if (write(p[1], resource, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to write to the communication pipe");
				bu_exit(1, NULL);
			}
			/* flush the pipe */
			if (close(p[1]) == -1) {
				perror("Unable to close the communication pipe");
				sleep(1); /* give the parent time to read */
			}
			bu_exit(0, NULL);
		} else {
			if (read(p[0], buffer, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to read from the communication pipe");
			}

			/* do not use the just read info to overwrite the resource structures.
			 * doing so will hose the resources completely
			 */

			/* parent ends up waiting on his child (and his child's threads) to
			 * terminate.  we can get valid usage statistics on a child process.
			 */
			while ((wpid = wait(&waitret)) != pid && wpid != -1)
				; /* do nothing */
		} /* end fork() */
#  endif

	} /* end parallel case */

#  ifdef USE_FORKED_THREADS
	if( rt_g.rtg_parallel ) {
		tmp_res = (struct resource *)buffer;
	} else {
		tmp_res = resource;
	}
	for( cpu=0; cpu < npsw; cpu++ ) {
		if ( tmp_res[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &tmp_res[cpu] );
		rt_zero_res_stats( &resource[cpu] );
	}
#  else
	/* Tally up the statistics */
	for ( cpu=0; cpu < npsw; cpu++ ) {
		if ( resource[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &resource[cpu] );
	}
#endif
	return;
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.24
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@a27 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
a28 3
#ifndef lint
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.23 2007/11/28 14:11:28 erikgreenwald Exp $ (BRL)";
#endif
d163 4
a166 4
    static	struct	application	a;
    static	struct	pixel_ext	pe;
    static	vect_t			stereo_point;		/* Ref point on eye or view plane */
    static	vect_t			point;		/* Ref point on eye or view plane */
@


14.23
log
@LOCAL->static, per machine.h deprecation list
@
text
@d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.22 2007/11/21 20:49:11 erikgreenwald Exp $ (BRL)";
d148 1
a148 1
	FAST fastf_t dx, dy;
d312 1
a312 1
	    FAST fastf_t right,left;
d392 1
a392 1
		FAST fastf_t right,left;
d420 1
a420 1
	    FAST fastf_t f;
@


14.22
log
@pass bu_exit a NULL instead of an empty string
@
text
@d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.21 2007/11/21 19:28:07 erikgreenwald Exp $ (BRL)";
d171 4
a174 4
    LOCAL	struct	application	a;
    LOCAL	struct	pixel_ext	pe;
    LOCAL	vect_t			stereo_point;		/* Ref point on eye or view plane */
    LOCAL	vect_t			point;		/* Ref point on eye or view plane */
@


14.21
log
@exit->bu_exit where applicable
@
text
@d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.20 2007/11/21 16:18:53 erikgreenwald Exp $ (BRL)";
d722 1
a722 1
			bu_exit(1, "");
d732 1
a732 1
				bu_exit(1, "");
d739 1
a739 1
			bu_exit(0, "");
@


14.20
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.19 2007/09/15 16:23:20 brlcad Exp $ (BRL)";
d722 1
a722 1
			exit(1);
d732 1
a732 1
				exit(1);
d739 1
a739 1
			exit(0);
@


14.19
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.18 2007/05/18 04:13:51 brlcad Exp $ (BRL)";
d41 1
d461 1
a461 1
		bu_bomb("rt/worker() cpu > MAX_PSW, array overrun\n");
d543 1
a543 1
		bu_bomb("viewsize <= 0");
d638 1
a638 1
		bu_bomb("zero-radius beam");
d658 1
a658 1
		bu_bomb("cell size");
d663 1
a663 1
		bu_bomb("bad size");
@


14.18
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.17 2007/01/27 01:41:45 brlcad Exp $ (BRL)";
a40 1
#ifdef HAVE_STRING_H
a41 1
#endif
@


14.17
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.16 2007/01/23 01:13:46 brlcad Exp $ (BRL)";
d462 1
a462 1
		rt_bomb("rt/worker() cpu > MAX_PSW, array overrun\n");
d544 1
a544 1
		rt_bomb("viewsize <= 0");
d639 1
a639 1
		rt_bomb("zero-radius beam");
d659 1
a659 1
		rt_bomb("cell size");
d664 1
a664 1
		rt_bomb("bad size");
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.15 2007/01/20 14:37:00 brlcad Exp $ (BRL)";
d263 1
a263 1
	
d295 1
a295 1
	    
d307 1
a307 1
	
d311 1
a311 1
	
d314 1
a314 1
	    
d316 1
a316 1
	    
d328 1
a328 1
	   
d375 1
a375 1
	    
d387 1
a387 1
	
d391 1
a391 1
	
d394 1
a394 1
	    
d396 1
a396 1
	    
d408 1
a408 1
	   
d659 1
a659 1
	    	rt_bomb("cell size");
d737 2
a738 2
			  	perror("Unable to close the communication pipe");
			  	sleep(1); /* give the parent time to read */
@


14.15
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d35 1
a35 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.14 2006/08/01 15:01:39 brlcad Exp $ (BRL)";
@


14.14
log
@reorder functions so that forward declarations are not needed
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.13 2006/05/21 14:31:26 brlcad Exp $ (BRL)";
@


14.13
log
@get rid of the ifdef linux, init some vars used by USE_FORKED_THREADS
@
text
@d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.12 2006/01/23 04:05:59 brlcad Exp $ (BRL)";
d66 11
d95 41
a135 5
extern int		query_x;
extern int		query_y;
extern int		Query_one_pixel;
extern int		query_rdebug;
extern int		query_debug;
a136 1
extern unsigned	char	*pixmap;		/* pixmap for rerendering of black pixels */
d138 3
a140 2
/*
 *			G R I D _ S E T U P
d142 4
a145 7
 *  In theory, the grid can be specified by providing any two of
 *  these sets of parameters:
 *	number of pixels (width, height)
 *	viewsize (in model units, mm)
 *	number of grid cells (cell_width, cell_height)
 *  however, for now, it is required that the view size always be specified,
 *  and one or the other parameter be provided.
d147 2
a148 2
void
grid_setup(void)
d150 1
a150 2
	vect_t temp;
	mat_t toEye;
d152 4
a155 8
	if( viewsize <= 0.0 )
		rt_bomb("viewsize <= 0");
	/* model2view takes us to eye_model location & orientation */
	MAT_IDN( toEye );
	MAT_DELTAS_VEC_NEG( toEye, eye_model );
	Viewrotscale[15] = 0.5*viewsize;	/* Viewscale */
	bn_mat_mul( model2view, Viewrotscale, toEye );
	bn_mat_inv( view2model, model2view );
d157 3
a159 7
	/* Determine grid cell size and number of pixels */
	if( cell_newsize ) {
		if( cell_width <= 0.0 ) cell_width = cell_height;
		if( cell_height <= 0.0 ) cell_height = cell_width;
		width = (viewsize / cell_width) + 0.99;
		height = (viewsize / (cell_height*aspect)) + 0.99;
		cell_newsize = 0;
d161 2
a162 3
		/* Chop -1.0..+1.0 range into parts */
		cell_width = viewsize / width;
		cell_height = viewsize / (height*aspect);
d164 2
a166 14
	/*
	 *  Optional GIFT compatabilty, mostly for RTG3.
	 *  Round coordinates of lower left corner to fall on integer-
	 *  valued coordinates, in "gift_grid_rounding" units.
	 */
	if( gift_grid_rounding > 0.0 )  {
		point_t		v_ll;		/* view, lower left */
		point_t		m_ll;		/* model, lower left */
		point_t		hv_ll;		/* hv, lower left*/
		point_t		hv_wanted;
		vect_t		hv_delta;
		vect_t		m_delta;
		mat_t		model2hv;
		mat_t		hv2model;
d168 14
a181 4
		/* Build model2hv matrix, including mm2inches conversion */
		MAT_COPY( model2hv, Viewrotscale );
		model2hv[15] = gift_grid_rounding;
		bn_mat_inv( hv2model, model2hv );
d183 3
a185 5
		VSET( v_ll, -1, -1, 0 );
		MAT4X3PNT( m_ll, view2model, v_ll );
		MAT4X3PNT( hv_ll, model2hv, m_ll );
		VSET( hv_wanted, floor(hv_ll[X]), floor(hv_ll[Y]),floor(hv_ll[Z]) );
		VSUB2( hv_delta, hv_ll, hv_wanted );
d187 10
a196 5
		MAT4X3PNT( m_delta, hv2model, hv_delta );
		VSUB2( eye_model, eye_model, m_delta );
		MAT_DELTAS_VEC_NEG( toEye, eye_model );
		bn_mat_mul( model2view, Viewrotscale, toEye );
		bn_mat_inv( view2model, model2view );
d198 7
d206 8
a213 4
	/* Create basis vectors dx and dy for emanation plane (grid) */
	VSET( temp, 1, 0, 0 );
	MAT3X3VEC( dx_unit, view2model, temp );	/* rotate only */
	VSCALE( dx_model, dx_unit, cell_width );
d215 11
a225 10
	VSET( temp, 0, 1, 0 );
	MAT3X3VEC( dy_unit, view2model, temp );	/* rotate only */
	VSCALE( dy_model, dy_unit, cell_height );

	if( stereo )  {
		/* Move left 2.5 inches (63.5mm) */
		VSET( temp, -63.5*2.0/viewsize, 0, 0 );
		bu_log("red eye: moving %f relative screen (left)\n", temp[X]);
		MAT4X3VEC( left_eye_delta, view2model, temp );
		VPRINT("left_eye_delta", left_eye_delta);
d227 1
d229 3
a231 18
	/* "Lower left" corner of viewing plane */
	if( rt_perspective > 0.0 )  {
		fastf_t	zoomout;
		zoomout = 1.0 / tan( bn_degtorad * rt_perspective / 2.0 );
		VSET( temp, -1, -1/aspect, -zoomout );	/* viewing plane */
		/*
		 * divergence is perspective angle divided by the number
		 * of pixels in that angle. Extra factor of 0.5 is because
		 * perspective is a full angle while divergence is the tangent
		 * (slope) of a half angle.
		 */
		ap.a_diverge = tan( bn_degtorad * rt_perspective * 0.5 / width );
		ap.a_rbeam = 0;
	}  else  {
		/* all rays go this direction */
		VSET( temp, 0, 0, -1 );
		MAT4X3VEC( ap.a_ray.r_dir, view2model, temp );
		VUNITIZE( ap.a_ray.r_dir );
d233 2
a234 7
		VSET( temp, -1, -1/aspect, 0 );	/* eye plane */
		ap.a_rbeam = 0.5 * viewsize / width;
		ap.a_diverge = 0;
	}
	if( NEAR_ZERO(ap.a_rbeam, SMALL) && NEAR_ZERO(ap.a_diverge, SMALL) )
		rt_bomb("zero-radius beam");
	MAT4X3PNT( viewbase_model, view2model, temp );
d236 3
a238 4
	if( jitter & JITTER_FRAME )  {
		/* Move the frame in a smooth circular rotation in the plane */
		fastf_t		ang;	/* radians */
		fastf_t		dx, dy;
d240 6
a245 6
		ang = curframe * frame_delta_t * bn_twopi / 10;	/* 10 sec period */
		dx = cos(ang) * 0.5;	/* +/- 1/4 pixel width in amplitude */
		dy = sin(ang) * 0.5;
		VJOIN2( viewbase_model, viewbase_model,
			dx, dx_model,
			dy, dy_model );
d247 1
a247 286

	if( cell_width <= 0 || cell_width >= INFINITY ||
	    cell_height <= 0 || cell_height >= INFINITY )  {
		bu_log("grid_setup: cell size ERROR (%g, %g) mm\n",
			cell_width, cell_height );
	    	rt_bomb("cell size");
	}
	if( width <= 0 || height <= 0 )  {
		bu_log("grid_setup: ERROR bad image size (%d, %d)\n",
			width, height );
		rt_bomb("bad size");
	}
}


/*
 *			D O _ R U N
 *
 *  Compute a run of pixels, in parallel if the hardware permits it.
 *
 *  For a general-purpose version, see LIBRT rt_shoot_many_rays()
 */
void do_run( int a, int b )
{
	int		cpu;

#  ifdef USE_FORKED_THREADS
	int pid, wpid;
	int waitret;
	void *buffer = (void*)0;
	int p[2] = {0,0};
	struct resource *tmp_res;

	if( rt_g.rtg_parallel ) {
		buffer = bu_calloc(npsw, sizeof(resource[0]), "buffer");
		if (pipe(p) == -1) {
			perror("pipe failed");
		}
	}
#  endif

	cur_pixel = a;
	last_pixel = b;

	if( !rt_g.rtg_parallel )  {
		/*
		 * SERIAL case -- one CPU does all the work.
		 */
		npsw = 1;
		worker(0, NULL);
	} else {
		/*
		 *  Parallel case.
		 */

		/* hack to bypass a bug in the Linux 2.4 kernel pthreads
		 * implementation. cpu statistics are only traceable on a
		 * process level and the timers will report effectively no
		 * elapsed cpu time.  this allows the stats of all threads
		 * to be gathered up by an encompassing process that may
		 * be timed.
		 *
		 * XXX this should somehow only apply to a build on a 2.4
		 * linux kernel.
		 */
#  ifdef USE_FORKED_THREADS
		pid = fork();
		if (pid < 0) {
			perror("fork failed");
			exit(1);
		} else if (pid == 0) {
#  endif

			bu_parallel( worker, npsw, NULL );

#  ifdef USE_FORKED_THREADS
			/* send raytrace instance data back to the parent */
			if (write(p[1], resource, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to write to the communication pipe");
				exit(1);
			}
			/* flush the pipe */
			if (close(p[1]) == -1) {
			  	perror("Unable to close the communication pipe");
			  	sleep(1); /* give the parent time to read */
			}
			exit(0);
		} else {
			if (read(p[0], buffer, sizeof(resource[0]) * npsw) == -1) {
				perror("Unable to read from the communication pipe");
			}

			/* do not use the just read info to overwrite the resource structures.
			 * doing so will hose the resources completely
			 */

			/* parent ends up waiting on his child (and his child's threads) to
			 * terminate.  we can get valid usage statistics on a child process.
			 */
			while ((wpid = wait(&waitret)) != pid && wpid != -1)
				; /* do nothing */
		} /* end fork() */
#  endif

	} /* end parallel case */

#  ifdef USE_FORKED_THREADS
	if( rt_g.rtg_parallel ) {
		tmp_res = (struct resource *)buffer;
	} else {
		tmp_res = resource;
	}
	for( cpu=0; cpu < npsw; cpu++ ) {
		if ( tmp_res[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &tmp_res[cpu] );
		rt_zero_res_stats( &resource[cpu] );
	}
#  else
	/* Tally up the statistics */
	for ( cpu=0; cpu < npsw; cpu++ ) {
		if ( resource[cpu].re_magic != RESOURCE_MAGIC )  {
			bu_log("ERROR: CPU %d resources corrupted, statistics bad\n", cpu);
			continue;
		}
		rt_add_res_stats( ap.a_rt_i, &resource[cpu] );
	}
#endif
	return;
}

#define CRT_BLEND(v)	(0.26*(v)[X] + 0.66*(v)[Y] + 0.08*(v)[Z])
#define NTSC_BLEND(v)	(0.30*(v)[X] + 0.59*(v)[Y] + 0.11*(v)[Z])
int	stop_worker = 0;

/*
 * For certain hypersample values there is a particular advantage to subdividing
 * the pixel and shooting a ray in each sub-pixel.  This structure keeps track of
 * those patterns
 */
struct jitter_pattern {
	int   num_samples;/* number of samples, or coordinate pairs in coords[] */
	float rand_scale[2]; /* amount to scale bn_rand_half value */
	float coords[32]; /* center of each sub-pixel */
};

static struct jitter_pattern pt_pats[] = {

	{4, {0.5, 0.5}, 	/* -H 3 */
	 { 0.25, 0.25,
	   0.25, 0.75,
	   0.75, 0.25,
	   0.75, 0.75 } },

	{5, {0.4, 0.4}, 	/* -H 4 */
	 { 0.2, 0.2,
	   0.2, 0.8,
	   0.8, 0.2,
	   0.8, 0.8,
	   0.5, 0.5} },

	{9, {0.3333, 0.3333}, /* -H 8 */
	 { 0.17, 0.17,  0.17, 0.5,  0.17, 0.82,
	   0.5, 0.17,    0.5, 0.5,   0.5, 0.82,
	   0.82, 0.17,  0.82, 0.5,  0.82, 0.82 } },

	{16, {0.25, 0.25}, 	/* -H 15 */
	 { 0.125, 0.125,  0.125, 0.375, 0.125, 0.625, 0.125, 0.875,
	   0.375, 0.125,  0.375, 0.375, 0.375, 0.625, 0.375, 0.875,
	   0.625, 0.125,  0.625, 0.375, 0.625, 0.625, 0.625, 0.875,
	   0.875, 0.125,  0.875, 0.375, 0.875, 0.625, 0.875, 0.875} },

	{ 0, {0.0, 0.0}, {0.0} } /* must be here to stop search */
};

/***********************************************************************
 *
 *  compute_point
 *
 * Compute the origin for this ray, based upon the number of samples
 * per pixel and the number of the current sample.  For certain
 * ray-counts, it is highly advantageous to subdivide the pixel and
 * fire each ray in a specific sub-section of the pixel.
 */
static void
jitter_start_pt(vect_t point, struct application *a, int samplenum, int pat_num)
{
	FAST fastf_t dx, dy;

	if (pat_num >= 0) {
		dx = a->a_x + pt_pats[pat_num].coords[samplenum*2] +
			(bn_rand_half(a->a_resource->re_randptr) *
			 pt_pats[pat_num].rand_scale[X] );

		dy = a->a_y + pt_pats[pat_num].coords[samplenum*2 + 1] +
			(bn_rand_half(a->a_resource->re_randptr) *
			 pt_pats[pat_num].rand_scale[Y] );
	} else {
		dx = a->a_x + bn_rand_half(a->a_resource->re_randptr);
		dy = a->a_y + bn_rand_half(a->a_resource->re_randptr);
	}
	VJOIN2( point, viewbase_model, dx, dx_model, dy, dy_model );
}

void do_pixel(int cpu,
	      int pat_num,
	      int pixelnum)
{
    int i;
    LOCAL	struct	application	a;
    LOCAL	struct	pixel_ext	pe;
    LOCAL	vect_t			stereo_point;		/* Ref point on eye or view plane */
    LOCAL	vect_t			point;		/* Ref point on eye or view plane */
    vect_t			colorsum = {(fastf_t)0.0, (fastf_t)0.0, (fastf_t)0.0};
    int				samplenum = 0;
    static const double one_over_255 = 1.0 / 255.0;
    register RGBpixel		pixel = {0, 0, 0};
    const int pindex = (pixelnum * sizeof(RGBpixel));

    /* Obtain fresh copy of global application struct */
    a = ap;				/* struct copy */
    a.a_resource = &resource[cpu];

    if( incr_mode )  {
	register int i = 1<<incr_level;
	a.a_y = pixelnum/i;
	a.a_x = pixelnum - (a.a_y * i);
	/*	a.a_x = pixelnum%i; */
	if( incr_level != 0 )  {
	    /* See if already done last pass */
	    if( ((a.a_x & 1) == 0 ) &&
		((a.a_y & 1) == 0 ) )
		return;
	}
	a.a_x <<= (incr_nlevel-incr_level);
	a.a_y <<= (incr_nlevel-incr_level);
    } else {
	a.a_y = pixelnum/width;
	a.a_x = pixelnum - (a.a_y * width);
	/*	a.a_x = pixelnum%width; */
    }

    if (Query_one_pixel) {
	if (a.a_x == query_x && a.a_y == query_y) {
	    rdebug = query_rdebug;
	    rt_g.debug = query_debug;
	} else {
	    rt_g.debug = rdebug = 0;
	}
    }

    if( sub_grid_mode )  {
	if( a.a_x < sub_xmin || a.a_x > sub_xmax )
	    return;
	if( a.a_y < sub_ymin || a.a_y > sub_ymax )
	    return;
    }
    if( fullfloat_mode )  {
	register struct floatpixel	*fp;
	fp = &curr_float_frame[a.a_y*width + a.a_x];
	if( fp->ff_frame >= 0 )  {
	    return;	/* pixel was reprojected */
	}
    }

    /* Check the pixel map to determine if this image should be rendered or not */
    if (pixmap) {
	a.a_user= 1;	/* Force Shot Hit */

	if (pixmap[pindex + RED] + pixmap[pindex + GRN] + pixmap[pindex + BLU]) {
	    /* non-black pixmap pixel */

	    a.a_color[RED]= (double)(pixmap[pindex + RED]) * one_over_255;
	    a.a_color[GRN]= (double)(pixmap[pindex + GRN]) * one_over_255;
	    a.a_color[BLU]= (double)(pixmap[pindex + BLU]) * one_over_255;

	    /* we're done */
	    view_pixel( &a );
	    if( a.a_x == width-1 ) {
		view_eol( &a );		/* End of scan line */
	    }
	    return;
	}
    }
d385 230
a614 29
		report_progress = 0;
		bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
	    }
	
	    a.a_level = 0;		/* recursion level */
	    a.a_purpose = "main ray";
	    (void)rt_shootray( &a );
	
	    if( stereo )  {
		FAST fastf_t right,left;
	    
		right = CRT_BLEND(a.a_color);
	    
		VSUB2( stereo_point, point, left_eye_delta );
		if( rt_perspective > 0.0 )  {
		    VSUB2( a.a_ray.r_dir, stereo_point, eye_model );
		    VUNITIZE( a.a_ray.r_dir );
		    VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
		} else {
		    VMOVE( a.a_ray.r_pt, stereo_point );
		}
		a.a_level = 0;		/* recursion level */
		a.a_purpose = "left eye ray";
		(void)rt_shootray( &a );
	   
		left = CRT_BLEND(a.a_color);
		VSET( a.a_color, left, 0, right );
	    }
	    VADD2( colorsum, colorsum, a.a_color );
d616 18
a633 4
	    /********************/
	    /* END NON-UNROLLED */
	    /********************/
	} /* for samplenum <= hypersample */
d635 3
a637 5
	{
	    /* scale the hypersampled results */
	    FAST fastf_t f;
	    f = 1.0 / (hypersample+1);
	    VSCALE( a.a_color, colorsum, f );
d639 8
a646 1
    } /* end unrolling else case */
d648 7
a654 1
    /* bu_log("2: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]); */
d656 11
a666 6
    /* we're done */
    view_pixel( &a );
    if( a.a_x == width-1 ) {
	view_eol( &a );		/* End of scan line */
    }
    return;
d669 1
d671 1
a671 1
 *  			W O R K E R
d673 1
a673 6
 *  Compute some pixels, and store them.
 *  A "self-dispatching" parallel algorithm.
 *  Executes until there is no more work to be done, or is told to stop.
 *
 *  In order to reduce the traffic through the res_worker critical section,
 *  a multiple pixel block may be removed from the work queue at once.
d677 1
a677 2
void
worker(int cpu, genptr_t arg)
d679 1
a679 3
	int	pixel_start;
	int	pixelnum;
	int	pat_num = -1;
d681 6
a686 2
	/* The more CPUs at work, the bigger the bites we take */
	if( per_processor_chunk <= 0 )  per_processor_chunk = npsw;
d688 4
a691 16
	if( cpu >= MAX_PSW )  {
		bu_log("rt/worker() cpu %d > MAX_PSW %d, array overrun\n", cpu, MAX_PSW);
		rt_bomb("rt/worker() cpu > MAX_PSW, array overrun\n");
	}
	RT_CK_RESOURCE( &resource[cpu] );

	pat_num = -1;
	if (hypersample) {
		int i, ray_samples;

		ray_samples = hypersample + 1;
		for (i=0 ; pt_pats[i].num_samples != 0 ; i++) {
			if (pt_pats[i].num_samples == ray_samples) {
				pat_num = i;
				goto pat_found;
			}
d694 1
a694 1
 pat_found:
d696 2
a697 2
	if (transpose_grid) {
	  int     tmp;
d699 10
a708 4
	  /* switch cur_pixel and last_pixel */
	  tmp = cur_pixel;
	  cur_pixel = last_pixel;
	  last_pixel = tmp;
d710 17
a726 3
	  while (1)  {
	    if (stop_worker)
	      return;
d728 1
a728 4
	    bu_semaphore_acquire(RT_SEM_WORKER);
	    pixel_start = cur_pixel;
	    cur_pixel -= per_processor_chunk;
	    bu_semaphore_release(RT_SEM_WORKER);
d730 16
a745 3
	    for (pixelnum = pixel_start; pixelnum > pixel_start-per_processor_chunk; pixelnum--) {
	      if (pixelnum < last_pixel)
		return;
d747 3
a749 7
	      do_pixel(cpu, pat_num, pixelnum);
	    }
	  }
	} else {
	  while (1) {
	    if (stop_worker)
	      return;
d751 7
a757 4
	    bu_semaphore_acquire(RT_SEM_WORKER);
	    pixel_start = cur_pixel;
	    cur_pixel += per_processor_chunk;
	    bu_semaphore_release(RT_SEM_WORKER);
d759 1
a759 1
	    for (pixelnum = pixel_start; pixelnum < pixel_start+per_processor_chunk; pixelnum++) {
d761 22
a782 6
	      if (pixelnum > last_pixel)
		return;

	      do_pixel(cpu, pat_num, pixelnum);
	    }
	  }
d784 2
d788 1
@


14.12
log
@convert to libbu memory management
@
text
@d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.11 2006/01/18 06:46:24 brlcad Exp $ (BRL)";
d57 1
a57 1
#if defined(USE_FORKED_THREADS)
d246 1
a246 1
#  if defined(linux)
d249 2
a250 2
	int p[2];
	void *buffer;
d285 1
a285 1
#  if defined(USE_FORKED_THREADS)
d295 1
a295 1
#  if defined(USE_FORKED_THREADS)
d326 1
a326 1
#  if defined(USE_FORKED_THREADS)
@


14.11
log
@update copyright to 2006
@
text
@d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.10 2005/12/23 21:26:46 bob1961 Exp $ (BRL)";
a40 2


d46 1
d254 1
a254 5
		buffer = calloc(npsw, sizeof(resource[0]));
		if (buffer == NULL) {
			perror("calloc failed");
			bu_bomb("Unable to allocate memory");
		}
@


14.10
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header$ (BRL)";
@


14.9
log
@rewrite do_pixel() for a 30% performance enhancement on an model-less scene. this results in a savings of 5-30% time depending on model complexity/size.  the performance is gained by removing some rediculous memory copying into temporaries and optimizing away several divisions and modulos.  the main loop is also unrolled one iteration since the default case does not involve hypersampling. also rework the logic on testing whether a pixmap (previous results render) is being used since considerable time was spent testing each pixel even when a pixmap wasn't being used.  most of these optimizations were performed based on Shark profiler results on OS X of rendering a large empty image. there are still a plethora of cpu stalls that should be fixable with compiler alignment directives
@
text
@d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.8 2005/10/23 04:44:38 brlcad Exp $ (BRL)";
d683 6
a688 4
	/* scale the hypersampled results */
	FAST fastf_t f;
	f = 1.0 / (hypersample+1);
	VSCALE( a.a_color, colorsum, f );
@


14.8
log
@trailing ws
@
text
@d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.7 2005/06/15 04:34:53 brlcad Exp $ (BRL)";
d435 38
a472 24
	LOCAL	struct	application	a;
	LOCAL	struct	pixel_ext	pe;
	LOCAL	vect_t			point;		/* Ref point on eye or view plane */
	LOCAL	vect_t			colorsum;
	int				samplenum,i;
        unsigned	char		*pixel;


	/* Obtain fresh copy of global application struct */
	a = ap;				/* struct copy */
	a.a_resource = &resource[cpu];

	if( incr_mode )  {
		register int i = 1<<incr_level;
		a.a_x = pixelnum%i;
		a.a_y = pixelnum/i;
		if( incr_level != 0 )  {
			/* See if already done last pass */
			if( ((a.a_x & 1) == 0 ) &&
			    ((a.a_y & 1) == 0 ) )
				return;
		}
		a.a_x <<= (incr_nlevel-incr_level);
		a.a_y <<= (incr_nlevel-incr_level);
d474 1
a474 2
		a.a_x = pixelnum%width;
		a.a_y = pixelnum/width;
d476 1
d478 31
a508 7
	if (Query_one_pixel) {
		if (a.a_x == query_x && a.a_y == query_y) {
			rdebug = query_rdebug;
			rt_g.debug = query_debug;
		} else {
			rt_g.debug = rdebug = 0;
		}
d510 1
d512 32
a543 12
	if( sub_grid_mode )  {
		if( a.a_x < sub_xmin || a.a_x > sub_xmax )
			return;
		if( a.a_y < sub_ymin || a.a_y > sub_ymax )
			return;
	}
	if( fullfloat_mode )  {
		register struct floatpixel	*fp;
		fp = &curr_float_frame[a.a_y*width + a.a_x];
		if( fp->ff_frame >= 0 )  {
			return;	/* pixel was reprojected */
		}
d546 10
a555 18


        /* Check the pixel map to determine if this image should be rendered or not */
	pixel= (unsigned char*)malloc(sizeof(RGBpixel));
	for (i= 0; i < sizeof(RGBpixel); i++)
		pixel[i]= 0;
	if (pixmap) {
/*		bu_log("val[%d]\n",3*(pixelnum%width+pixelnum/width));*/
		memcpy(pixel,&pixmap[pixelnum*sizeof(RGBpixel)],sizeof(RGBpixel));
		a.a_user= 1;	/* Force Shot Hit */
/*		bu_log("a.a_user: %d\n",a.a_user);*/
	}

	if (pixel[0]+pixel[1]+pixel[2]) {
		a.a_color[0]= (double)(pixel[0])/255.0;
		a.a_color[1]= (double)(pixel[1])/255.0;
		a.a_color[2]= (double)(pixel[2])/255.0;
/*		bu_log("1: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]);*/
d557 54
a610 1
		VSETALL( colorsum, 0 );
d612 3
a614 36
		for( samplenum=0; samplenum<=hypersample; samplenum++ )  {
			if( jitter & JITTER_CELL ) {
				jitter_start_pt(point, &a, samplenum, pat_num);
			}  else  {
				VJOIN2( point, viewbase_model,
					a.a_x, dx_model,
					a.a_y, dy_model );
			}
			if (a.a_rt_i->rti_prismtrace) {
				/* compute the four corners */
				pe.magic = PIXEL_EXT_MAGIC;

				VJOIN2(pe.corner[0].r_pt,
				       viewbase_model,
				       a.a_x, dx_model,
				       a.a_y, dy_model );

				VJOIN2(pe.corner[1].r_pt,
				       viewbase_model,
				       (a.a_x+1), dx_model,
				       a.a_y, dy_model );

				VJOIN2(pe.corner[2].r_pt,
				       viewbase_model,
				       (a.a_x+1), dx_model,
				       (a.a_y+1), dy_model );

				VJOIN2(pe.corner[3].r_pt,
				       viewbase_model,
				       a.a_x, dx_model,
				       (a.a_y+1), dy_model );

				a.a_pixelext = &pe;
			} else {
				a.a_pixelext=(struct pixel_ext *)NULL;
			}
d616 9
a624 38
			if( rt_perspective > 0.0 )  {
				VSUB2( a.a_ray.r_dir,
				point, eye_model );
				VUNITIZE( a.a_ray.r_dir );
				VMOVE( a.a_ray.r_pt, eye_model );
				if (a.a_rt_i->rti_prismtrace) {
					VSUB2(pe.corner[0].r_dir,
					      pe.corner[0].r_pt,
					      eye_model);
					VSUB2(pe.corner[1].r_dir,
					      pe.corner[1].r_pt,
					      eye_model);
					VSUB2(pe.corner[2].r_dir,
					      pe.corner[2].r_pt,
					      eye_model);
					VSUB2(pe.corner[3].r_dir,
					      pe.corner[3].r_pt,
					      eye_model);
				}
			} else {
				VMOVE( a.a_ray.r_pt, point );
				VMOVE( a.a_ray.r_dir, ap.a_ray.r_dir );

				if (a.a_rt_i->rti_prismtrace) {
					VMOVE(pe.corner[0].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[1].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[2].r_dir,
					      a.a_ray.r_dir);
					VMOVE(pe.corner[3].r_dir,
					      a.a_ray.r_dir);
				}
			}
			if( report_progress )  {
				report_progress = 0;
				bu_log("\tframe %d, xy=%d,%d on cpu %d, samp=%d\n", curframe, a.a_x, a.a_y, cpu, samplenum );
			}
d626 42
a667 32
			a.a_level = 0;		/* recursion level */
			a.a_purpose = "main ray";
			(void)rt_shootray( &a );

			if( stereo )  {
				FAST fastf_t right,left;

				right = CRT_BLEND(a.a_color);

				VSUB2(  point, point,
					left_eye_delta );
				if( rt_perspective > 0.0 )  {
					VSUB2( a.a_ray.r_dir,
					       point, eye_model );
					VUNITIZE( a.a_ray.r_dir );
					VADD2( a.a_ray.r_pt, eye_model, left_eye_delta );
				} else {
					VMOVE( a.a_ray.r_pt, point );
				}
				a.a_level = 0;		/* recursion level */
				a.a_purpose = "left eye ray";
				(void)rt_shootray( &a );

				left = CRT_BLEND(a.a_color);
				VSET( a.a_color, left, 0, right );
			}
			VADD2( colorsum, colorsum, a.a_color );
		} /* for samplenum <= hypersample */
		if( hypersample )  {
			FAST fastf_t f;
			f = 1.0 / (hypersample+1);
			VSCALE( a.a_color, colorsum, f );
d669 8
d678 19
a696 7
/*		bu_log("2: [%d,%d] : [%.2f,%.2f,%.2f]\n",pixelnum%width,pixelnum/width,a.a_color[0],a.a_color[1],a.a_color[2]);*/
	}

	free(pixel);
	view_pixel( &a );
	if( a.a_x == width-1 )
		view_eol( &a );		/* End of scan line */
@


14.7
log
@protect the sys/wait.h headers with HAVE_SYS_WAIT_H since not all systems (e.g. mingw) have it.
@
text
@d33 1
a33 1
 *  
d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.6 2005/04/22 05:41:44 brlcad Exp $ (BRL)";
d290 1
a290 1
#  if defined(USE_FORKED_THREADS) 
d311 1
a311 1
			exit(0); 
d406 3
a408 3
 * Compute the origin for this ray, based upon the number of samples 
 * per pixel and the number of the current sample.  For certain 
 * ray-counts, it is highly advantageous to subdivide the pixel and 
d411 1
a411 1
static void 
d418 1
a418 1
			(bn_rand_half(a->a_resource->re_randptr) * 
d420 1
a420 1
	
d422 1
a422 1
			(bn_rand_half(a->a_resource->re_randptr) * 
d629 1
a629 1
 *  
@


14.7.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d33 1
a33 1
 *
d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header$ (BRL)";
d290 1
a290 1
#  if defined(USE_FORKED_THREADS)
d311 1
a311 1
			exit(0);
d406 3
a408 3
 * Compute the origin for this ray, based upon the number of samples
 * per pixel and the number of the current sample.  For certain
 * ray-counts, it is highly advantageous to subdivide the pixel and
d411 1
a411 1
static void
d418 1
a418 1
			(bn_rand_half(a->a_resource->re_randptr) *
d420 1
a420 1

d422 1
a422 1
			(bn_rand_half(a->a_resource->re_randptr) *
d629 1
a629 1
 *
@


14.6
log
@surround the pthread timing blocks with USE_FORKED_THREADS define instead of just using linux since there are plenty of linux systems where the statistics hack is not necessary
@
text
@d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.5 2005/01/30 20:31:11 brlcad Exp $ (BRL)";
d61 3
a63 1
#  include <sys/wait.h>
@


14.5
log
@update copyright to 2005
@
text
@d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.4 2005/01/20 00:53:16 brlcad Exp $ (BRL)";
d58 1
a58 1
#if defined(linux)
d288 1
a288 1
#  if defined(linux)
d298 1
a298 1
#  if defined(linux)
d329 1
a329 1
#  if defined(linux )
@


14.4
log
@thx, Balbir Thomas for pointing out the illegal syntax. needed to move the variable sets after the preprocessor block for cur_pixel and last_pixel.
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.3 2004/12/24 01:40:01 brlcad Exp $ (BRL)";
@


14.3
log
@add the mysteriously missing gpl header..
@
text
@d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/rt/worker.c,v 14.2 2004/12/21 06:38:23 morrison Exp $ (BRL)";
a244 3
	cur_pixel = a;
	last_pixel = b;

d264 2
@


14.2
log
@remove the old copyright notice section
@
text
@d1 21
a21 2
/*
 *			W O R K E R . C
d36 1
a36 1
static const char RCSworker[] = "@@(#)$Header: /cvs/brlcad/src/rt/worker.c,v 14.1 2004/11/16 19:42:31 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@a14 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d17 1
a17 1
static const char RCSworker[] = "@@(#)$Header: /cvs/brlcad/src/rt/worker.c,v 1.2 2004/08/02 23:01:52 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /cvs/brlcad/src/rt/worker.c,v 1.1 2004/05/20 15:20:48 morrison Exp $ (BRL)";
d696 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char RCSworker[] = "@@(#)$Header: /cvs/brlcad/rt/worker.c,v 11.46 2004/05/10 15:30:49 erikg Exp $ (BRL)";
d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

