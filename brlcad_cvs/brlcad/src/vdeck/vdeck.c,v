head	14.22;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	rel-7-10-2:14.16
	rel-7-10-0:14.14
	rel-7-8-4:14.11
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.6
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.22
date	2007.12.31.17.56.54;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.11.21.20.49.14;	author erikgreenwald;	state Exp;
branches;
next	14.20;

14.20
date	2007.11.21.19.49.13;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.27.21.58.41;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.10.14.08.01.46;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.27;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.07.26.01.14.00;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.05.14.21.04.34;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.55;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.57;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.37.07;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.04.05.18.19.52;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.02.27.10.08.41;	author brlcad;	state Exp;
branches
	14.10.2.1;
next	14.9;

14.9
date	2006.01.29.08.39.28;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.24.05.00.27;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.30;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.23.04.44.39;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.09.19.21.16.28;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.35;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.21.06.38.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.36.56;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.32;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.31.00;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.53;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.47;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.22.02;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.21;	author brlcad;	state Exp;
branches;
next	;

14.10.2.1
date	2006.04.07.19.34.24;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.22
log
@comment and header cleanup, convert k&r prototypes to ansi, doxygenify
@
text
@/*                         V D E C K . C
 * BRL-CAD
 *
 * Copyright (c) 1990-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file vdeck.c
 *
 *	Derived from KARDS, written by Keith Applin.
 *
 * Generate a COM-GEOM card images suitable for input to gift5 (also
 * gift(1V)) from an mged(1V) target description.
 *
 * There are 3 files generated at a time, the Solid table, Region
 * table, and Ident table, which when concatenated in that order, make
 * a COM-GEOM deck.  The record formats in the order that they appear,
 * are described below, and are strictly column oriented.

 * Note that the Solid table begins with a Title and a Control card,
 * the rest of the record types appear once for each object, that is,
 * one Solid record for each Solid, one Region and one Ident record
 * for each Region as totaled on the Control card, however, the Solid
 * and Region records may span more than 1 card.
 *
----------------------------------------------------------------------------
|File|Record  :             Contents              :       Format           |
|----|---------------------------------------------------------------------|
| 1  |Title   : target_units, title               : a2,3x,a60              |
|    |Control : #_of_solids, #_of_regions         : i5,i5                  |
|    |Solid   : sol_#,sol_type,params.,comment    : i5,a5,6f10.0,a10       |
|    | cont'  : sol_#,parameters,comment          : i5,5x,6f10.0,a10       |
|----|---------------------------------------------------------------------|
| 2  |Region  : reg_#,(op,[sol/reg]_#)*,comment   : i5,1x,9(a2,i5),1x,a10  |
|    | cont'  : reg_#,(op,[sol/reg]_#)*,comment   : i5,1x,9(a2,i5),1x,a10  |
|----|---------------------------------------------------------------------|
| 3  |Flag    : a -1 marks end of region table    : i5                     |
|    |Idents  : reg_#,ident,space,mat,%,descriptn : 5i5,5x,a50             |
----------------------------------------------------------------------------
 *
 *  Author -
 *	Gary S. Moss
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <math.h>
#include <string.h>

#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"

#include "./vextern.h"
#include "../librt/debug.h"


int	debug = 0;

char	*cmd[] = {
	"",
	"C O M M A N D                  D E S C R I P T I O N",
	"",
	"deck [output file prefix]      Produce COM GEOM card deck.",
	"erase                          Erase current list of objects.",
	"insert [object[s]]             Add an object to current list.",
	"list [object[s]]               Display current list of selected objects.",
	"number [solid] [region]        Specify starting numbers for objects.",
	"quit                           Terminate run.",
	"remove [object[s]]             Remove an object from current list.",
	"sort                           Sort table of contents alphabetically.",
	"toc [object[s]]                Table of contents of solids database.",
	"! [shell command]              Execute a UNIX shell command.",
	"",
	"NOTE:",
	"First letter of command is sufficient, and all arguments are optional.",
	"Objects may be specified with string matching operators (*, [], -, ? or \\)",
	"as in the UNIX shell.",
	0
};

char	*usage[] = {
	"",
	"v d e c k ($Revision: 14.21 $)",
	"Make COMGEOM decks of objects from a \"mged\" file suitable as",
	"input to GIFT5 or gift(1V).",
	"",
	"Usage: vdeck file.g",
	"",
	0
};

/*  These arrays are now dynamically allocated by toc() */

char	**toc_list;		/* Sorted table of contents. */
char	**curr_list;		/* regions and solids to be processed. */
int	curr_ct = 0;
char	**tmp_list;		/* Temporary list of names */
int	tmp_ct = 0;

/* List of arguments from command line parser.				*/
char	*arg_list[MAXARG];
int	arg_ct = 0;

/* Structure used by setjmp() and longjmp() to save environment.	*/
jmp_buf	env;

/* File names and descriptors.						*/
char	*objfile;
FILE	*regfp;
struct bu_vls	bu_vls;
struct bu_vls	st_vls;
struct bu_vls	id_vls;
char	*rt_file;
FILE	*solfp;
char	*st_file;
FILE	*ridfp;
char	*id_file;

/* Counters.								*/
int	nns;		/* Solids.					*/
int	nnr;		/* Regions not members of other regions.	*/
int	ndir;		/* Entries in directory.			*/

/* Miscellaneous globals leftover from Keith's KARDS code.		*/
int		delsol = 0, delreg = 0;
char		buff[30];
long		savsol;		/* File postion of # of solids & regions */

/* Structures.								*/
mat_t		identity;

extern void		menu();
extern void		quit();

char			getarg();
void			quit(), abort_sig();

char			getcmd();
void			prompt();

void			addarb();
void			addtgc();
void			addtor();
void			addhalf();
void			addarbn();
void			addell();
void			addars();
void			deck();
void			itoa();
void			vls_blanks();
void			vls_itoa();
void			vls_ftoa_vec_cvt();
void			vls_ftoa_vec();
void			vls_ftoa_cvt();
void			vls_ftoa();
extern int		parsArg();
extern int		insert();
extern int		col_prt();
extern int		match();
extern int		delete();
extern int		shell();
extern int		cgarbs();
extern int		redoarb();

BU_EXTERN(void ewrite, (FILE *fp, const char *buf, unsigned bytes) );
BU_EXTERN(void blank_fill, (FILE *fp, int count) );

/* Head of linked list of solids */
struct soltab	sol_hd;

struct db_i	*dbip;		/* Database instance ptr */


/*
 *			P R O M P T
 *
 *  Print a non-newline-terminate string, and flush stdout
 */
void
prompt( char *fmt )
{
	fputs( fmt, stdout );
	fflush(stdout);
}


/**
 * S O R T F U N C
 *
 * Comparison function for qsort().
 *
 * 'a' is the exact template expected by qsort.
 */
static int
sortFunc(const void *a, const void *b)
{
	const char **lhs = (const char **)a;
	const char **rhs = (const char **)b;

	return( strcmp( *lhs, *rhs ) );
}


/**
 *			M A I N
 */
int
main( int argc, char *argv[] )
{
	setbuf( stdout, bu_malloc( BUFSIZ, "stdout buffer" ) );
	BU_LIST_INIT( &(sol_hd.l) );

	bu_vls_init( &bu_vls );
	bu_vls_init( &st_vls );
	bu_vls_init( &id_vls );

	if( ! parsArg( argc, argv ) )
	{
		menu( usage );
		return 1;
	}

	rt_init_resource( &rt_uniresource, 0, NULL );

	/* Build directory from object file.	 	*/
	if( db_dirbuild(dbip) < 0 )  {
		fprintf(stderr,"db_dirbuild() failure\n");
		return 1;
	}

	toc();		/* Build table of contents from directory.	*/

#if 0
	rt_g.debug |= DEBUG_TREEWALK;
#endif

	/*      C o m m a n d   I n t e r p r e t e r			*/
	(void) setjmp( env );/* Point of re-entry from aborted command.	*/
	prompt( CMD_PROMPT );
	while( 1 )
	{
		/* Return to default interrupt handler after every command,
		 allows exit from program only while command interpreter
		 is waiting for input from keyboard.
		 */
		(void) signal( SIGINT, quit );

		switch( getcmd( arg_list, 0 ) )
		{
		case DECK :
			deck( arg_list[1] );
			break;
		case ERASE :
			while( curr_ct > 0 )
				bu_free( curr_list[--curr_ct], "curr_list[ct]" );
			break;
		case INSERT :
			if( arg_list[1] == 0 )
			{
				prompt( "enter object[s] to insert: " );
				(void) getcmd( arg_list, arg_ct );
			}
			(void) insert( arg_list, arg_ct );
			break;
		case LIST :
			{
				register int	i;
				if( arg_list[1] == 0 )
				{
					(void) col_prt( curr_list, curr_ct );
					break;
				}
				for( tmp_ct = 0, i = 0; i < curr_ct; i++ )
					if( match( arg_list[1], curr_list[i] ) )
						tmp_list[tmp_ct++] = curr_list[i];
				(void) col_prt( tmp_list, tmp_ct );
				break;
			}
		case MENU :
			menu( cmd );
			prompt( PROMPT );
			continue;
		case NUMBER :
			if( arg_list[1] == 0 )
			{
				prompt( "enter number of 1st solid: " );
				(void) getcmd( arg_list, arg_ct );
				prompt( "enter number of 1st region: " );
				(void) getcmd( arg_list, arg_ct );
			}
			if( arg_list[1] )
				delsol = atoi( arg_list[1] ) - 1;
			if( arg_list[2] )
				delreg = atoi( arg_list[2] ) - 1;
			break;
		case REMOVE :
			if( arg_list[1] == 0 )
			{
				prompt( "enter object[s] to remove: " );
				(void) getcmd( arg_list, arg_ct );
			}
			(void) delete( arg_list );
			break;
		case RETURN :
			prompt( PROMPT );
			continue;
		case SHELL :
			if( arg_list[1] == 0 )
			{
				prompt( "enter shell command: " );
				(void) getcmd( arg_list, arg_ct );
			}
			(void) shell( arg_list );
			break;
		case SORT_TOC :
			qsort( (genptr_t)toc_list, (unsigned)ndir,
			    sizeof(char *), sortFunc );
			break;
		case TOC :
			list_toc( arg_list );
			break;
		case EOF :
		case QUIT :
			(void) printf( "quitting...\n" );
			goto out;
		default :
			(void) printf( "Invalid command\n" );
			prompt( PROMPT );
			continue;
		}
		prompt( CMD_PROMPT );
	}
out:
	return 0;
}


/**
 * F L A T T E N _ T R E E
 *
 * This routine turns a union tree into a flat string.
 */
void
flatten_tree( struct bu_vls *vls, union tree *tp, char *op, int neg )
{
	int	bit;

	BU_CK_VLS( vls );

	switch( tp->tr_op )  {

	case OP_NOP:
		bu_log("NOP\n");
		return;

	case OP_SOLID:
		bit = tp->tr_a.tu_stp->st_bit;
		if( bit < 10000 )  {
			/* Old way, just use negative number in I5 field */
			bu_vls_strncat( vls, op, 2 );
			if(neg) bit = -bit;
		} else {
			/* New way, due to Tom Sullivan of Sandia. */
			/* "or" becomes "nr", "  " becomes "nn" */
			if(neg)  {
				if( *op == ' ' )
					bu_vls_strncat( vls, "nn", 2 );
				else if( *op == 'o' && op[1] == 'r' )
					bu_vls_strncat( vls, "nr", 2 );
				else
					bu_vls_strncat( vls, "??", 2 );
			} else {
				bu_vls_strncat( vls, op, 2 );
			}
		}
		vls_itoa( vls, bit, 5 );
		/* tp->tr_a.tu_stp->st_name */
		return;

	case OP_REGION:
		bu_log("REGION 'stp'=x%x\n", (unsigned int)tp->tr_a.tu_stp );
		return;

	default:
		bu_log("Unknown op=x%x\n", tp->tr_op );
		return;

	case OP_UNION:
		flatten_tree( vls, tp->tr_b.tb_left, "or", neg );
		flatten_tree( vls, tp->tr_b.tb_right, "or", 0 );
		break;
	case OP_INTERSECT:
		flatten_tree( vls, tp->tr_b.tb_left, op, neg );
		flatten_tree( vls, tp->tr_b.tb_right, "  ", 0 );
		break;
	case OP_SUBTRACT:
		flatten_tree( vls, tp->tr_b.tb_left, op, neg );
		flatten_tree( vls, tp->tr_b.tb_right, "  ", 1 );
		break;
	}
}


/**
 * R E G I O N _ E N D
 *
 * This routine will be called by db_walk_tree() once all the solids
 * in this region have been visited.
 */
union tree *
region_end( register struct db_tree_state *tsp, struct db_full_path *pathp, union tree *curtree, genptr_t client_data )
{
	struct directory	*dp;
	char			*fullname;
	struct bu_vls		ident;
	struct bu_vls		reg;
	struct bu_vls		flat;
	char			obuf[128];
	char			*cp;
	int			left;
	int			length;
	struct directory	*regdp = DIR_NULL;
	int			i;
	int			first;

	bu_vls_init( &ident );
	bu_vls_init( &reg );
	bu_vls_init( &flat );
	fullname = db_path_to_string(pathp);

	dp = DB_FULL_PATH_CUR_DIR(pathp);
	dp->d_uses++;		/* instance number */

	/* For name, find pointer to region combination */
	for( i=0; i < pathp->fp_len; i++ )  {
		regdp = pathp->fp_names[i];
		if( regdp->d_flags & DIR_REGION )  break;
	}

	nnr++;			/* Start new region */

	/* Print an indicator of our progress */
	if( debug )
		(void) printf( "%4d:%s\n", nnr+delreg, fullname );

	/*
	 *  Write the boolean formula into the region table.
	 */

	/* Convert boolean tree into string of 7-char chunks */
	if( curtree->tr_op == OP_NOP )  {
		bu_vls_strcat( &flat, "" );
	} else {
		/* Rewrite tree so that all unions are at tree top */
		db_non_union_push( curtree, &rt_uniresource );
		flatten_tree( &flat, curtree, "  ", 0 );
	}

	/* Output 9 of the 7-char chunks per region "card" */
	cp = bu_vls_addr( &flat );
	left = bu_vls_strlen( &flat );
	first = 1;

	do  {
		register char	*op;

		op = obuf;
		if( first )  {
			(void) sprintf( op, "%5d ", nnr+delreg );
			first = 0;
		} else {
			strncpy( op, "      ", 6 );
		}
		op += 6;

		if( left > 9*7 )  {
			strncpy( op, cp, 9*7 );
			cp += 9*7;
			op += 9*7;
			left -= 9*7;
		} else {
			strncpy( op, cp, left );
			op += left;
			while( left < 9*7 )  {
				*op++ = ' ';
				left++;
			}
			left = 0;
		}
		strncpy( op, regdp->d_namep, 128 );
		op += strlen(op);
		*op++ = '\n';
		*op = '\0';
		ewrite( regfp, obuf, strlen(obuf) );
	} while( left > 0 );

	/*
	 *  Write a record into the region ident table.
	 */
	vls_itoa( &ident, nnr+delreg, 5 );
	vls_itoa( &ident, tsp->ts_regionid, 5 );
	vls_itoa( &ident, tsp->ts_aircode, 5 );
	vls_itoa( &ident, tsp->ts_gmater, 5 );
	vls_itoa( &ident, tsp->ts_los, 5 );
	bu_vls_strcat( &ident, "     " );		/* 5 spaces */

	length = strlen( fullname );
	if( length > 50 )  {
		register char	*bp;

		bp = fullname + (length - 50);
		*bp = '*';
		bu_vls_strcat( &ident, bp );
	} else {
		/* Omit leading slash, for compat with old version */
		bu_vls_strcat( &ident, fullname+1 );
	}
	bu_vls_strcat( &ident, "\n" );
	bu_vls_fwrite( ridfp, &ident );

	bu_vls_free( &ident );
	bu_vls_free( &reg );
	bu_vls_free( &flat );
	bu_free( fullname, "fullname" );

	/*
	 *  Returned tree will be freed by caller.
	 *  To keep solid table available for seraching,
	 *  add this tree to a list of trees to be released once
	 *  everything is finished.
	 */
	/* XXX Should make list of "regions" (trees) here */
	return  (union tree *)0;
}


/**
 * G E T T R E E _ L E A F
 *
 * Re-use the librt "soltab" structures here, for our own purposes.
 */
union tree *
gettree_leaf( struct db_tree_state *tsp, struct db_full_path *pathp, struct rt_db_internal *ip, genptr_t client_data )
{
	register fastf_t	f;
	register struct soltab	*stp;
	union tree		*curtree;
	struct directory	*dp;
	struct bu_vls		sol;
	register int		i;
	register matp_t		mat;

	bu_vls_init( &sol );

	RT_CK_DB_INTERNAL(ip);
	dp = DB_FULL_PATH_CUR_DIR(pathp);

	/* Determine if this matrix is an identity matrix */
	for( i=0; i<16; i++ )  {
		f = tsp->ts_mat[i] - bn_mat_identity[i];
		if( !NEAR_ZERO(f, 0.0001) )
			break;
	}
	if( i < 16 )  {
		/* Not identity matrix */
		mat = tsp->ts_mat;
	} else {
		/* Identity matrix */
		mat = (matp_t)0;
	}

	/*
	 *  Check to see if this exact solid has already been processed.
	 *  Match on leaf name and matrix.
	 */
	for( BU_LIST_FOR( stp, soltab, &(sol_hd.l) ) )  {
		RT_CHECK_SOLTAB(stp);				/* debug */

		/* Leaf solids must be the same */
		if( dp != stp->st_dp )  continue;

		if( mat == (matp_t)0 )  {
			if( stp->st_matp == (matp_t)0 )  {
				if( debug )
					bu_log("rt_gettree_leaf:  %s re-referenced (ident)\n",
						dp->d_namep );
				goto found_it;
			}
			goto next_one;
		}
		if( stp->st_matp == (matp_t)0 )  goto next_one;

		for( i=0; i<16; i++ )  {
			f = mat[i] - stp->st_matp[i];
			if( !NEAR_ZERO(f, 0.0001) )
				goto next_one;
		}
		/* Success, we have a match! */
		if( debug )  {
			bu_log("rt_gettree_leaf:  %s re-referenced\n",
			    dp->d_namep );
		}
		goto found_it;
next_one:
		;
	}

	BU_GETSTRUCT(stp, soltab);
	stp->l.magic = RT_SOLTAB_MAGIC;
	stp->st_id = ip->idb_type;
	stp->st_dp = dp;
	if( mat )  {
		stp->st_matp = (matp_t)bu_malloc( sizeof(mat_t), "st_matp" );
		MAT_COPY( stp->st_matp, mat );
	} else {
		stp->st_matp = mat;
	}
	stp->st_specific = (genptr_t)0;

	/* init solid's maxima and minima */
	VSETALL( stp->st_max, -INFINITY );
	VSETALL( stp->st_min,  INFINITY );

	RT_CK_DB_INTERNAL( ip );

	if(debug)  {
		struct bu_vls	str;
		bu_vls_init( &str );
		/* verbose=1, mm2local=1.0 */
		if( ip->idb_meth->ft_describe( &str, ip, 1, 1.0, &rt_uniresource, dbip ) < 0 )  {
			bu_log("rt_gettree_leaf(%s):  solid describe failure\n",
			    dp->d_namep );
		}
		bu_log( "%s:  %s", dp->d_namep, bu_vls_addr( &str ) );
		bu_vls_free( &str );
	}

	/* For now, just link them all onto the same list */
	BU_LIST_INSERT( &(sol_hd.l), &(stp->l) );

	stp->st_bit = ++nns;

	/* Solid number is stp->st_bit + delsol */

	/* Process appropriate solid type.				*/
	switch( ip->idb_type )  {
	case ID_TOR:
		addtor( &sol, (struct rt_tor_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_ARB8:
		addarb( &sol, (struct rt_arb_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_ELL:
		addell( &sol, (struct rt_ell_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_TGC:
		addtgc( &sol, (struct rt_tgc_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_ARS:
		addars( &sol, (struct rt_ars_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_HALF:
		addhalf( &sol, (struct rt_half_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_ARBN:
		addarbn( &sol, (struct rt_arbn_internal *)ip->idb_ptr,
		    dp->d_namep, stp->st_bit+delsol );
		break;
	case ID_PIPE:
		/* XXX */
	default:
		(void) fprintf( stderr,
		    "vdeck: '%s' Primitive type %s has no corresponding COMGEOM primitive, skipping\n",
		    dp->d_namep, ip->idb_meth->ft_name );
		vls_itoa( &sol, stp->st_bit+delsol, 5 );
		bu_vls_strcat( &sol, ip->idb_meth->ft_name );
		vls_blanks( &sol, 5*10 );
		bu_vls_strcat( &sol, dp->d_namep );
		bu_vls_strcat( &sol, "\n");
		break;
	}

	bu_vls_fwrite( solfp, &sol );
	bu_vls_free( &sol );

found_it:
	BU_GETUNION( curtree, tree );
	curtree->magic = RT_TREE_MAGIC;
	curtree->tr_op = OP_SOLID;
	curtree->tr_a.tu_stp = stp;
	curtree->tr_a.tu_regionp = (struct region *)0;

	return(curtree);
}


void
swap_vec( vect_t v1, vect_t v2 )
{
	vect_t	work;

	VMOVE( work, v1 );
	VMOVE( v1, v2 );
	VMOVE( v2, work );
}


void
swap_dbl( register double *d1, register double *d2 )
{
	double	t;
	t = *d1;
	*d1 = *d2;
	*d2 = t;
	return;
}


/**
 * A D D T O R
 *
 * Process torus.
 */
void
addtor( struct bu_vls *v, struct rt_tor_internal *gp, char *name, int num )
{
	BU_CK_VLS(v);
	RT_TOR_CK_MAGIC(gp);

	/* V, N, r1, r2 */
	vls_itoa( v, num, 5 );
	bu_vls_strcat( v, "tor  " );		/* 5 */
	vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
	vls_ftoa_vec( v, gp->h, 10, 4 );
	bu_vls_strcat( v, name );
	bu_vls_strcat( v, "\n" );

	vls_itoa( v, num, 5 );
	vls_blanks( v, 5 );
	vls_ftoa_cvt( v, gp->r_a, 10, 4 );
	vls_ftoa_cvt( v, gp->r_h, 10, 4 );
	vls_blanks( v, 4*10 );
	bu_vls_strcat( v, name );
	bu_vls_strcat( v, "\n");
}


/**
 * A D D H A L F
 */
void
addhalf(struct bu_vls *v, struct rt_half_internal *gp, char *name, int num )
{
	BU_CK_VLS(v);
	RT_HALF_CK_MAGIC(gp);

	/* N, d */
	vls_itoa( v, num, 5 );
	bu_vls_strcat( v, "haf  " );		/* 5 */
	vls_ftoa_vec( v, gp->eqn, 10, 4 );
	vls_ftoa_cvt( v, -(gp->eqn[3]), 10, 4 );
	vls_blanks( v, 2*10 );
	bu_vls_strcat( v, name );
	bu_vls_strcat( v, "\n" );
}


/**
 * A D D A R B N
 */
void
addarbn(struct bu_vls *v, struct rt_arbn_internal *gp, char *name, int num )
{
	register int	i;

	BU_CK_VLS(v);
	RT_ARBN_CK_MAGIC(gp);

	/* nverts, nverts_index_nums, nplane_eqns, naz_el */
	vls_itoa( v, num, 5 );
	bu_vls_strcat( v, "arbn " );		/* 5 */
	vls_itoa( v, 0, 10 );			/* vertex points, 2/card */
	vls_itoa( v, 0, 10 );			/* vertex index #, 6/card */
	vls_itoa( v, gp->neqn, 10 );		/* plane eqn, 1/card */
	vls_itoa( v, 0, 10 );			/* az/el & index #, 2/card */
	vls_blanks( v, 20 );
	bu_vls_strcat( v, name );
	bu_vls_strcat( v, "\n" );

	for( i=0; i < gp->neqn; i++ )  {
		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec( v, gp->eqn[i], 10, 4 );
		vls_ftoa_cvt( v, gp->eqn[i][3], 10, 4 );
		vls_blanks( v, 2*10 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );
	}
}


static void
vls_solid_pts(struct bu_vls *v, const point_t pts[], int npts, const char *name, int num, const char *kind )
{
	register int	i;

	for( i = 0; i < npts; )  {
		vls_itoa( v, num, 5 );
		if( i == 0 )
			bu_vls_strncat( v, kind, 5 );
		else
			bu_vls_strcat( v, "     " );
		vls_ftoa_vec_cvt( v, pts[i], 10, 4 );
		if( ++i < npts )  {
			vls_ftoa_vec_cvt( v, pts[i], 10, 4 );
		} else {
			vls_blanks( v, 3*10 );
		}
		i++;
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
	}
}


/**
 *			A D D A R B
 *
 *  Process generalized arb.
 */
void
addarb(struct bu_vls *v, struct rt_arb_internal *gp, char *name, int num )
{
	register int	i;
	int	uniq_pts[8];
	int	samevecs[11];
	int	cgtype;
	point_t	pts[8];		/* GIFT-order points */

	/* Enter new arb code.						*/
	if( (i = cgarbs( &cgtype, gp, uniq_pts, samevecs, CONV_EPSILON )) == 0 ||
	    redoarb( pts, gp, uniq_pts, samevecs, i, cgtype ) == 0 )  {
		fprintf(stderr,"vdeck: addarb(%s): failure\n", name);
		vls_itoa( v, num, 5 );
		bu_vls_strncat( v, "arb??", 5 );
		vls_blanks( v, 6*10 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
		return;
	}

	/* Print the solid parameters.					*/
	switch( cgtype )  {
	case 8:
		vls_solid_pts( v, (const point_t *)pts, 8, name, num, "arb8 " );
		break;
	case 7:
		vls_solid_pts( v, (const point_t *)pts, 7, name, num, "arb7 " );
		break;
	case 6:
		VMOVE( pts[5], pts[6] );
		vls_solid_pts( v, (const point_t *)pts, 6, name, num, "arb6 " );
		break;
	case 5:
		vls_solid_pts( v, (const point_t *)pts, 5, name, num, "arb5 " );
		break;
	case 4:
		VMOVE( pts[3], pts[4] );
		vls_solid_pts( v, (const point_t *)pts, 4, name, num, "arb4 " );
		break;

		/* Currently, cgarbs() will not return RAW, BOX, or RPP */
	default:
		(void) fprintf( stderr, "addarb: Unknown arb cgtype=%d.\n",
		    cgtype );
		bu_exit( 10, NULL );
	}
}

#define GENELL	1
#define	ELL1	2
#define SPH	3

/**
 * A D D E L L
 *
 * Process the general ellipsoid.
 */
void
addell(struct bu_vls *v, struct rt_ell_internal *gp, char *name, int num )
{
	double	ma, mb, mc;
	int	cgtype;

	/* Check for ell1 or sph.					*/
	ma = MAGNITUDE( gp->a );
	mb = MAGNITUDE( gp->b );
	mc = MAGNITUDE( gp->c );
	if( fabs( ma-mb ) < CONV_EPSILON )  {
		/* vector A == vector B */
		cgtype = ELL1;
		/* SPH if vector B == vector C also */
		if( fabs( mb-mc ) < CONV_EPSILON )
			cgtype = SPH;
		else	/* switch A and C */
		{
			swap_vec( gp->a, gp->c );
			swap_dbl( &ma, &mc );
		}
	} else if( fabs( ma-mc ) < CONV_EPSILON ) {
		/* vector A == vector C */
		cgtype = ELL1;
		/* switch vector A and vector B */
		swap_vec( gp->a, gp->b );
		swap_dbl( &ma, &mb );
	} else if( fabs( mb-mc ) < CONV_EPSILON )
		cgtype = ELL1;
	else
		cgtype = GENELL;

	/* Print the solid parameters.					*/
	vls_itoa( v, num, 5 );
	switch( cgtype )  {
	case GENELL:
		bu_vls_strcat( v, "ellg " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec_cvt( v, gp->b, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->c, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
		break;
	case ELL1:
		bu_vls_strcat( v, "ell1 " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_cvt( v, mb, 10, 4 );
		vls_blanks( v, 5*10 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
		break;
	case SPH:
		bu_vls_strcat( v, "sph  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_cvt( v, ma, 10, 4 );
		vls_blanks( v, 2*10 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );
		break;
	default:
		(void) fprintf( stderr,
		    "Error in type of ellipse (%d).\n",
		    cgtype
		    );
		bu_exit( 10, NULL );
	}
}


#define TGC	1
#define TEC	2
#define TRC	3
#define REC	4
#define RCC	5


/**
 * A D D T G C
 *
 * Process generalized truncated cone.
 */
void
addtgc(struct bu_vls *v, struct rt_tgc_internal *gp, char *name, int num )
{
	vect_t	axb, cxd;
	double	ma, mb, mc, md, maxb, mcxd, mh;
	int	cgtype;

	/* Check for tec rec trc rcc.					*/
	cgtype = TGC;
	VCROSS( axb, gp->a, gp->b );
	VCROSS( cxd, gp->c, gp->d );

	ma = MAGNITUDE( gp->a );
	mb = MAGNITUDE( gp->b );
	mc = MAGNITUDE( gp->c );
	md = MAGNITUDE( gp->d );
	maxb = MAGNITUDE( axb );
	mcxd = MAGNITUDE( cxd );
	mh = MAGNITUDE( gp->h );

	if( ma <= 0.0 || mb <= 0.0 )  {
		fprintf(stderr, "addtgc(%s): ma=%e, mb=%e, skipping\n", name, ma, mb );
		return;
	}

	/* TEC if ratio top and bot vectors equal and base parallel to top.
	 */
	if( mc != 0.0 && md != 0.0 &&
	    fabs( (mb/md)-(ma/mc) ) < CONV_EPSILON &&
	    fabs( fabs(VDOT(axb,cxd)) - (maxb*mcxd) ) < CONV_EPSILON )  {
		cgtype = TEC;
	}

	/* Check for right cylinder.					*/
	if( fabs( fabs(VDOT(gp->h,axb)) - (mh*maxb) ) < CONV_EPSILON )  {
		if( fabs( ma-mb ) < CONV_EPSILON )  {
			if( fabs( ma-mc ) < CONV_EPSILON )
				cgtype = RCC;
			else
				cgtype = TRC;
		} else {
			/* elliptical */
			if( fabs( ma-mc ) < CONV_EPSILON )
				cgtype = REC;
		}
	}

	/* Insure that magnitude of A is greater than B, and magnitude of
		C is greater than D for the GIFT code (boy, is THIS a shame).
		This need only be done for the elliptical REC and TEC types.
	 */
	if( (cgtype == REC || cgtype == TEC) && ma < mb )  {
		swap_vec( gp->a, gp->b );
		swap_dbl( &ma, &mb );
		swap_vec( gp->c, gp->d );
		swap_dbl( &mc, &md );
	}

	/* Print the solid parameters.					*/
	vls_itoa( v, num, 5 );
	switch( cgtype )  {
	case TGC:
		bu_vls_strcat( v, "tgc  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->b, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_cvt( v, mc, 10, 4 );
		vls_ftoa_cvt( v, md, 10, 4 );
		vls_blanks( v, 4*10 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
		break;
	case RCC:
		bu_vls_strcat( v, "rcc  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_cvt( v, ma, 10, 4 );
		vls_blanks( v, 5*10 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
		break;
	case TRC:
		bu_vls_strcat( v, "trc  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_cvt( v, ma, 10, 4 );
		vls_ftoa_cvt( v, mc, 10, 4 );
		vls_blanks( v, 4*10 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
		break;
	case TEC:
		bu_vls_strcat( v, "tec  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->b, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa( v, ma/mc, 10, 4 );	/* dimensionless ratio */
		vls_blanks( v, 5*10 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
		break;
	case REC:
		bu_vls_strcat( v, "rec  " );		/* 5 */
		vls_ftoa_vec_cvt( v, gp->v, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->h, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n" );

		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );
		vls_ftoa_vec_cvt( v, gp->a, 10, 4 );
		vls_ftoa_vec_cvt( v, gp->b, 10, 4 );
		bu_vls_strcat( v, name );
		bu_vls_strcat( v, "\n");
		break;
	default:
		(void) fprintf( stderr,
		    "Error in tgc type (%d).\n",
		    cgtype
		    );
		bu_exit( 10, NULL );
	}
}


/**
 * A R S _ C U R V E _ O U T
 */
void
ars_curve_out(struct bu_vls *v, fastf_t *fp, int todo, int curveno, int num )
{
	while( todo > 0 )  {
		vls_itoa( v, num, 5 );
		vls_blanks( v, 5 );

		/* First point */
		vls_ftoa_vec_cvt( v, fp, 10, 4 );
		fp += 3;
		todo--;

		/* Second point */
		if( todo >= 1 )  {
			vls_ftoa_vec_cvt( v, fp, 10, 4 );
			fp += 3;
			todo--;
		} else {
			vls_blanks( v, 3*10 );
		}

		bu_vls_strcat( v, "curve " );
		vls_itoa( v, curveno, 3 );
		bu_vls_strcat( v, "\n" );
	}
}


/**
 * A D D A R S
 *
 * Process triangular surfaced polyhedron - ars.
 */
void
addars(struct bu_vls *v, struct rt_ars_internal *gp, char *name, int num )
{
	register int	i;

	RT_ARS_CK_MAGIC(gp);

	vls_itoa( v, num, 5 );
	bu_vls_strcat( v, "ars  " );		/* 5 */
	vls_itoa( v, gp->ncurves, 10 );
	vls_itoa( v, gp->pts_per_curve, 10 );
	vls_blanks( v, 4*10 );
	bu_vls_strcat( v, name );
	bu_vls_strcat( v, "\n" );

	for( i=0; i < gp->ncurves; i++ )  {
		/* Output the points on this curve */
		ars_curve_out( v, gp->curves[i], gp->pts_per_curve, i, num );
	}
}


/**
 * e w r i t e
 *
 * Write with error checking.
 */
void
ewrite(FILE *fp, const char *buf, unsigned bytes )
{
	if( bytes == 0 )  return;

	if( fwrite( buf, bytes, 1, fp ) != 1 )  {
		perror("write");
		(void)fprintf(stderr, "vdeck: write error\n");
		bu_exit(2, NULL);
	}
}


/**
 * d e c k
 *
 * make a COMGEOM deck for current list of objects
 */
void
deck( register char *prefix )
{
	nns = nnr = 0;

	/* Create file for solid table.					*/
	if( prefix != 0 )
	{
		(void) bu_vls_strcpy( &st_vls, prefix );
		(void) bu_vls_strcat( &st_vls, ".st" );
	}
	else
		(void) bu_vls_strcpy( &st_vls, "solids" );
	st_file = bu_vls_addr( &st_vls );
	if( (solfp = fopen( st_file, "w")) == NULL )  {
		perror( st_file );
		bu_exit( 10, NULL );
	}


	/* Target units (a2,3x)						*/
	ewrite( solfp, bu_units_string(dbip->dbi_local2base), 2 );
	blank_fill( solfp, 3 );

	/* Title							*/
	if( dbip->dbi_title == NULL )
		ewrite( solfp, objfile, (unsigned) strlen( objfile ) );
	else
		ewrite( solfp, dbip->dbi_title, (unsigned) strlen( dbip->dbi_title ) );
	ewrite( solfp, LF, 1 );

	/* Save space for number of solids and regions.			*/
	savsol = ftell( solfp );
	blank_fill( solfp, 10 );
	ewrite( solfp, LF, 1 );

	/* Create file for region table.				*/
	if( prefix != 0 )
	{
		(void) bu_vls_strcpy( &bu_vls, prefix );
		(void) bu_vls_strcat( &bu_vls, ".rt" );
	}
	else
		(void) bu_vls_strcpy( &bu_vls, "regions" );
	rt_file = bu_vls_addr( &bu_vls );
	if( (regfp = fopen( rt_file, "w" )) == NULL )  {
		perror( rt_file );
		bu_exit( 10, NULL );
	}

	/* create file for region ident table
	 */
	if( prefix != 0 )
	{
		(void) bu_vls_strcpy( &id_vls, prefix );
		(void) bu_vls_strcat( &id_vls, ".id" );
	}
	else
		(void) bu_vls_strcpy( &id_vls, "region_ids" );
	id_file = bu_vls_addr( &id_vls );
	if( (ridfp = fopen( id_file, "w" )) == NULL )  {
		perror( id_file );
		bu_exit( 10, NULL );
	}
	itoa( -1, buff, 5 );
	ewrite( ridfp, buff, 5 );
	ewrite( ridfp, LF, 1 );

	/* Initialize matrices.						*/
	MAT_IDN( identity );

	if( !sol_hd.l.magic )  BU_LIST_INIT( &sol_hd.l );

	/*  Build the whole card deck.	*/
	/*  '1' indicates one CPU.  This code isn't ready for parallelism */
	if( db_walk_tree( dbip, curr_ct, (const char **)curr_list,
	    1, &rt_initial_tree_state,
	    0, region_end, gettree_leaf, (genptr_t)NULL ) < 0 )  {
		fprintf(stderr,"Unable to treewalk any trees!\n");
		bu_exit(11, NULL);
	}

	/* Go back, and add number of solids and regions on second card. */
	fseek( solfp, savsol, 0 );
	itoa( nns, buff, 5 );
	ewrite( solfp, buff, 5 );
	itoa( nnr, buff, 5 );
	ewrite( solfp, buff, 5 );

	/* Finish region id table.					*/
	ewrite( ridfp, LF, 1 );

	(void) printf( "====================================================\n" );
	(void) printf( "O U T P U T    F I L E S :\n\n" );
	(void) printf( "solid table = \"%s\"\n", st_file );
	(void) printf( "region table = \"%s\"\n", rt_file );
	(void) printf( "region identification table = \"%s\"\n", id_file );
	(void) fclose( solfp );
	(void) fclose( regfp );
	(void) fclose( ridfp );

	/* reset starting numbers for solids and regions
	 */
	delsol = delreg = 0;
	/* XXX should free soltab list */
}


/**
 * s h e l l
 *
 * Execute shell command.
 */
int
shell(char *args[])
{
	register char	*from, *to;
	char		*argv[4], cmdbuf[MAXLN];
	int		pid, ret, status;
	register int	i;

	(void) signal( SIGINT, SIG_IGN );

	/* Build arg vector.						*/
	argv[0] = "Shell( deck )";
	argv[1] = "-c";
	to = argv[2] = cmdbuf;
	for( i = 1; i < arg_ct; i++ ) {
		from = args[i];
		if( (to + strlen( args[i] )) - argv[2] > MAXLN - 1 ) {
			(void) fprintf( stderr, "\ncommand line too long\n" );
			bu_exit( 10, NULL );
		}
		(void) printf( "%s ", args[i] );
		while( *from )
			*to++ = *from++;
		*to++ = ' ';
	}
	to[-1] = '\0';
	(void) printf( "\n" );
	argv[3] = 0;
	if( (pid = fork()) == -1 ) {
		perror( "shell()" );
		return( -1 );
	} else	if( pid == 0 ) { /*
				  * CHILD process - execs a shell command
					  */
		(void) signal( SIGINT, SIG_DFL );
		(void) execv( "/bin/sh", argv );
		perror( "/bin/sh -c" );
		bu_exit( 99, NULL );
	} else	/*
		 * PARENT process - waits for shell command
		 * to finish.
			 */
		do {
			if( (ret = wait( &status )) == -1 ) {
				perror( "wait( /bin/sh -c )" );
				break;
			}
		} while( ret != pid );
	return( 0 );
}


/**
 * t o c
 *
 * Build a sorted list of names of all the objects accessable in the
 * object file.
 */
void
toc()
{
	register struct directory *dp;
	register int		count;

	/* Determine necessary table size */
	count = 0;
	FOR_ALL_DIRECTORY_START(dp, dbip) {
	    count++;
	} FOR_ALL_DIRECTORY_END;
	count += 1;		/* Safety */

	/* Allocate tables */
	toc_list = (char **)bu_malloc( count * sizeof(char *), "toc_list[]" );
	tmp_list = (char **)bu_malloc( count * sizeof(char *), "tmp_list[]" );
	curr_list = (char **)bu_malloc( count * sizeof(char *), "curr_list[]" );
	ndir = 0;

	/* Fill in toc_list[] */
	FOR_ALL_DIRECTORY_START(dp, dbip) {
	    toc_list[ndir++] = dp->d_namep;
	} FOR_ALL_DIRECTORY_END;
}


/**
 * l i s t _ t o c
 *
 * List the table of contents.
 */
void
list_toc( char *args[] )
{
	register int	i, j;
	(void) fflush( stdout );
	for( tmp_ct = 0, i = 1; args[i] != NULL; i++ )
	{
		for( j = 0; j < ndir; j++ )
		{
			if( match( args[i], toc_list[j] ) )
				tmp_list[tmp_ct++] = toc_list[j];
		}
	}
	if( i > 1 )
		(void) col_prt( tmp_list, tmp_ct );
	else
		(void) col_prt( toc_list, ndir );
	return;
}


#define NAMESIZE	16
#define MAX_COL	(NAMESIZE*5)
#define SEND_LN()	{\
			buf[column++] = '\n';\
			ewrite( stdout, buf, (unsigned) column );\
			column = 0;\
			}


/**
 * c o l _ p r t
 *
 * Print list of names in tabular columns.
 */
int
col_prt( register char *list[], register int ct )
{
	char		buf[MAX_COL+2];
	register int	i, column, spaces;

	for( i = 0, column = 0; i < ct; i++ )
	{
		if( column + (int)strlen( list[i] ) > MAX_COL )
		{
			SEND_LN();
			i--;
		}
		else
		{
			(void) strncpy( &buf[column], list[i], MAX_COL+2 );
			column += strlen( list[i] );
			spaces = NAMESIZE - (column % NAMESIZE );
			if( column + spaces < MAX_COL )
				for( ; spaces > 0; spaces-- )
					buf[column++] = ' ';
			else
				SEND_LN();
		}
	}
	SEND_LN();
	return	ct;
}


/**
 * i n s e r t
 *
 * Insert each member of the table of contents 'toc_list' which
 * matches one of the arguments into the current list 'curr_list'.
 */
int
insert(char *args[], register int ct)
{
	register int	i, j, nomatch;

	/* For each argument (does not include args[0]).			*/
	for( i = 1; i < ct; i++ )
	{ /* If object is in table of contents, insert in current list.	*/
		nomatch = YES;
		for( j = 0; j < ndir; j++ )
		{
			if( match( args[i], toc_list[j] ) )
			{
				nomatch = NO;
				/* Allocate storage for string.			*/
				curr_list[curr_ct++] = bu_strdup(toc_list[j]);
			}
		}
		if( nomatch )
			(void) fprintf( stderr,
			    "Object \"%s\" not found.\n", args[i] );
	}
	return	curr_ct;
}

/**
 * d e l e t e
 *
 * delete all members of current list 'curr_list' which match one of
 * the arguments.
 */
int
delete(char *args[])
{
	register int	i;
	register int	nomatch;

	/* for each object in arg list
	 */
	for( i = 1; i < arg_ct; i++ ) {
		register int	j;
		nomatch = YES;

		/* traverse list to find string
		 */
		for( j = 0; j < curr_ct; )
			if( match( args[i], curr_list[j] ) )
			{
				register int	k;

				nomatch = NO;
				bu_free( curr_list[j], "curr_list" );
				--curr_ct;
				/* starting from bottom of list,
				 * pull all entries up to fill up space
				 made by deletion
				 */
				for( k = j; k < curr_ct; k++ )
					curr_list[k] = curr_list[k+1];
			}
			else	++j;
		if( nomatch )
			(void) fprintf( stderr,
			    "Object \"%s\" not found.\n",
			    args[i]
			    );
	}
	return( curr_ct );
}


/**
 * i t o a
 *
 * Convert integer to ascii  wd format.
 */
void
itoa( register int n, register char *s, register int w )
{
	int	 c, i, j, sign;

	if( (sign = n) < 0 )	n = -n;
	i = 0;
	do
		s[i++] = n % 10 + '0';
	while( (n /= 10) > 0 );
	if( sign < 0 )	s[i++] = '-';

	/* Blank fill array.					*/
	for( j = i; j < w; j++ )	s[j] = ' ';
	if( i > w ) {
		s[w-1] = (s[w]-1-'0')*10 + (s[w-1]-'0')  + 'A';
	}
	s[w] = '\0';

	/* Reverse the array.					*/
	for( i = 0, j = w - 1; i < j; i++, j-- ) {
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}


void
vls_blanks(struct bu_vls *v, int n )
{
	BU_CK_VLS(v);
	bu_vls_strncat( v, "                                                                                                                                ",
	    n);
}


/**
 * V L S _ I T O A
 *
 * Convert integer to ascii  wd format.
 */
void
vls_itoa(struct bu_vls *v, int n, int w )
{
	int	 c, i, j, sign;
	register char	*s;

	BU_CK_VLS(v);
	bu_vls_strncat( v, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", w);
	s = bu_vls_addr(v)+bu_vls_strlen(v)-w;

	if( (sign = n) < 0 )	n = -n;
	i = 0;
	do
		s[i++] = n % 10 + '0';
	while( (n /= 10) > 0 );
	if( sign < 0 )	s[i++] = '-';

	/* Blank fill array.					*/
	for( j = i; j < w; j++ )	s[j] = ' ';
	if( i > w ) {
		s[w-1] = (s[w]-1-'0')*10 + (s[w-1]-'0')  + 'A';
	}
	s[w] = '\0';

	/* Reverse the array.					*/
	for( i = 0, j = w - 1; i < j; i++, j-- ) {
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}


void
vls_ftoa_vec_cvt(struct bu_vls *v, const vect_t vec, int w, int d)
{
	vls_ftoa( v, vec[X]*dbip->dbi_base2local, w, d );
	vls_ftoa( v, vec[Y]*dbip->dbi_base2local, w, d );
	vls_ftoa( v, vec[Z]*dbip->dbi_base2local, w, d );
}


void
vls_ftoa_vec(struct bu_vls *v, const vect_t vec, int w, int d)
{
	vls_ftoa( v, vec[X], w, d );
	vls_ftoa( v, vec[Y], w, d );
	vls_ftoa( v, vec[Z], w, d );
}


void
vls_ftoa_cvt(struct bu_vls *v, double f, int w, int d)
{
	vls_ftoa( v, f*dbip->dbi_base2local, w, d );
}


/**
 * V L S _ F T O A
 *
 * Convert float to ascii  w.df format.
 */
void
vls_ftoa( struct bu_vls *v, double f, int w, int d )
{
	register char	*s;
	register int	c, i, j;
	long	n, sign;

	BU_CK_VLS(v);
	bu_vls_strncat( v, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", w);
	s = bu_vls_addr(v)+bu_vls_strlen(v)-w;

	if( w <= d + 2 )
	{
		(void) fprintf( stderr,
		    "ftoascii: incorrect format  need w.df  stop"
		    );
		bu_exit( 10, NULL );
	}
	for( i = 1; i <= d; i++ )
		f = f * 10.0;

	/* round up */
	if( f < 0.0 )
		f -= 0.5;
	else
		f += 0.5;
	n = f;
	if( (sign = n) < 0 )
		n = -n;
	i = 0;
	do	{
		s[i++] = n % 10 + '0';
		if( i == d )
			s[i++] = '.';
	}	while( (n /= 10) > 0 );

	/* Zero fill the d field if necessary.				*/
	if( i < d )
	{
		for( j = i; j < d; j++ )
			s[j] = '0';
		s[j++] = '.';
		i = j;
	}
	if( sign < 0 )
		s[i++] = '-';

	/* Blank fill rest of field.					*/
	for ( j = i; j < w; j++ )
		s[j] = ' ';
	if( i > w )
		(void) fprintf( stderr, "Ftoascii: field length too small\n" );
	s[w] = '\0';

	/* Reverse the array.						*/
	for( i = 0, j = w - 1; i < j; i++, j-- )
	{
		c    = s[i];
		s[i] = s[j];
		s[j] =    c;
	}
}


/**
 * g e t c m d
 *
 * Return first character read from keyboard, copy command into
 * args[0] and arguments into args[1]...args[n].
 */
char
getcmd(char *args[], register int ct)
{
	/* Get arguments.						 */
	if( ct == 0 )
		while( --arg_ct >= 0 )
			bu_free( args[arg_ct], "args[arg_ct]" );
	for( arg_ct = ct; arg_ct < MAXARG - 1; ++arg_ct )
	{
		args[arg_ct] = bu_malloc( MAXLN, "getcmd buffer" );
		if( ! getarg( args[arg_ct] ) )
			break;
	}
	++arg_ct;
	args[arg_ct] = 0;

	/* Before returning to command interpreter,
	 * set up interrupt handler for commands...
	 * trap interrupts such that command is aborted cleanly and
	 * command line is restored rather than terminating program
	 */
	(void) signal( SIGINT, abort_sig );
	return	(args[0])[0];
}


/**
 * g e t a r g
 *
 * Get a word of input into 'str', Return 0 if newline is encountered.
 * Return 1 otherwise.
 */
char
getarg( register char *str )
{
	do {
		*str = getchar();
		if( (int)(*str) == ' ' ) {
			*str = '\0';
			return( 1 );
		}
		else
			++str;
	}	while( (int)(str[-1]) != EOF && (int)(str[-1]) != '\n' );
	if( (int)(str[-1]) == '\n' )
		--str;
	*str = '\0';
	return	0;
}


/**
 * m e n u
 *
 * Display menu stored at address 'addr'.
 */
void
menu( char **addr )
{
	register char	**sbuf = addr;
	while( *sbuf )
		(void) printf( "%s\n", *sbuf++ );
	(void) fflush( stdout );
	return;
}


/**
 * b l a n k _ f i l l 
 *
 * Write count blanks to fildes.
 */
void
blank_fill(FILE *fp, register int count)
{
	ewrite( fp, BLANKS, (unsigned) count );
}


/**
 * a b o r t
 *
 * Abort command without terminating run (restore command prompt) and
 * cleanup temporary files.
 */
void
abort_sig( int sig )
{
	(void) signal( SIGINT, quit );	/* reset trap */

	/* goto command interpreter with environment restored.		*/
	longjmp( env, sig );
}


/**
 * q u i t
 *
 * Terminate run.
 */
void
quit( int sig )
{
	(void) fprintf( stdout, "quitting...\n" );
	bu_exit( 0, NULL );
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@pass bu_exit a NULL instead of an empty string
@
text
@d22 15
a36 2
 *  Author -
 *	Gary S. Moss
a37 22
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.20 2007/11/21 19:49:13 erikgreenwald Exp $ (BRL)";
#endif

/*
	Derived from KARDS, written by Keith Applin.

	Generate a COM-GEOM card images suitable for input to gift5
	(also gift(1V)) from an mged(1V) target description.

	There are 3 files generated at a time, the Solid table, Region table,
	and Ident table, which when concatenated in that order, make a
	COM-GEOM deck.  The record formats in the order that they appear, are
	described below, and are strictly column oriented.

	Note that the Solid table begins with a Title and a Control card, the
	rest of the record types appear once for each object, that is, one
	Solid record for each Solid, one Region and one
	Ident record for each Region as totaled on the Control card, however,
	the Solid and Region records may span more than 1 card.

d51 5
a55 1
|--------------------------------------------------------------------------|
a56 1
 */
d110 1
a110 1
	"v d e c k ($Revision: 14.20 $)",
d207 1
a207 2
prompt( fmt )
char	*fmt;
d213 5
a217 2
/*
 *			S O R T F U N C
d219 1
a219 1
 *	Comparison function for qsort().
d222 1
a222 8
sortFunc( a, b )
#if __STDC__
const void	*a;		/* The exact template expected by qsort */
const void	*b;
#else
const genptr_t	a;
const genptr_t	b;
#endif
d230 2
a231 1
/*
d235 1
a235 2
main( argc, argv )
char	*argv[];
d364 3
a366 2
/*
 *			F L A T T E N _ T R E E
d368 1
a368 1
 *  This routine turns a union tree into a flat string.
d371 1
a371 5
flatten_tree( vls, tp, op, neg )
struct bu_vls	*vls;
union tree	*tp;
char		*op;
int		neg;
d408 1
a408 2
		bu_log("REGION 'stp'=x%x\n",
		    tp->tr_a.tu_stp );
d430 3
a432 2
/*
 *			R E G I O N _ E N D
d434 2
a435 2
 *  This routine will be called by db_walk_tree() once all the
 *  solids in this region have been visited.
d437 2
a438 5
union tree *region_end( tsp, pathp, curtree, client_data )
register struct db_tree_state	*tsp;
struct db_full_path	*pathp;
union tree		*curtree;
genptr_t		client_data;
d563 3
a565 2
/*
 *			G E T T R E E _ L E A F
d567 1
a567 1
 *  Re-use the librt "soltab" structures here, for our own purposes.
d569 2
a570 5
union tree *gettree_leaf( tsp, pathp, ip, client_data )
struct db_tree_state	*tsp;
struct db_full_path	*pathp;
struct rt_db_internal	*ip;
genptr_t		client_data;
d729 1
d731 1
a731 2
swap_vec( v1, v2 )
vect_t	v1, v2;
d740 1
d742 1
a742 2
swap_dbl( d1, d2 )
register double	*d1, *d2;
d751 3
a753 2
/*
 *			A D D T O R
d755 1
a755 1
 *  Process torus.
d758 1
a758 5
addtor( v, gp, name, num )
struct bu_vls		*v;
struct rt_tor_internal	*gp;
char			*name;
int			num;
d780 3
a782 2
/*
 *			A D D H A L F
d785 1
a785 5
addhalf( v, gp, name, num )
struct bu_vls		*v;
struct rt_half_internal	*gp;
char			*name;
int			num;
d800 3
a802 2
/*
 *			A D D A R B N
d805 1
a805 5
addarbn( v, gp, name, num )
struct bu_vls		*v;
struct rt_arbn_internal	*gp;
char			*name;
int			num;
d834 1
d836 1
a836 7
vls_solid_pts( v, pts, npts, name, num, kind )
struct bu_vls	*v;
const point_t	pts[];
const int	npts;
const char	*name;
const int	num;
const char	*kind;
d858 2
a859 1
/*
d865 1
a865 5
addarb( v, gp, name, num )
struct bu_vls		*v;
struct rt_arb_internal	*gp;
char			*name;
int			num;
d917 2
a918 2
/*
 *			A D D E L L
d920 1
a920 1
 *	Process the general ellipsoid.
d923 1
a923 5
addell( v, gp, name, num )
struct bu_vls		*v;
struct rt_ell_internal	*gp;
char			*name;
int			num;
d1002 1
d1009 3
a1011 2
/*
 *			A D D T G C
d1013 1
a1013 1
 *	Process generalized truncated cone.
d1016 1
a1016 5
addtgc( v, gp, name, num )
struct bu_vls		*v;
struct rt_tgc_internal	*gp;
char			*name;
int			num;
d1171 3
a1173 2
/*
 *			A R S _ C U R V E _ O U T
d1176 1
a1176 6
ars_curve_out( v, fp, todo, curveno, num )
struct bu_vls		*v;
fastf_t			*fp;
int			todo;
int			curveno;
int			num;
d1202 3
a1204 2
/*
 *			A D D A R S
d1206 1
a1206 1
 *	Process triangular surfaced polyhedron - ars.
d1209 1
a1209 5
addars( v, gp, name, num )
struct bu_vls		*v;
struct rt_ars_internal	*gp;
char			*name;
int			num;
d1229 5
a1233 2
/*	e w r i t e
	Write with error checking.
d1236 1
a1236 4
ewrite( fp, buf, bytes )
FILE		*fp;
const char	*buf;
unsigned	bytes;
a1246 9
/*
	Section 1:	C O M M A N D S

			deck()
			shell()
 */

/*	d e c k ( )
	make a COMGEOM deck for current list of objects
d1248 4
d1254 1
a1254 2
deck( prefix )
register char *prefix;
d1360 5
a1364 2
/*	s h e l l ( )
	Execute shell command.
d1367 1
a1367 2
shell( args )
char  *args[];
d1417 6
a1422 3
/*	t o c ( )
	Build a sorted list of names of all the objects accessable
	in the object file.
a1427 1
	register int		i;
a1448 8
/*
	Section 3:	L I S T   P R O C E S S I N G   R O U T I N E S

			list_toc()
			col_prt()
			insert()
			delete()
*/
d1450 4
a1453 2
/*	l i s t _ t o c ( )
	List the table of contents.
d1456 1
a1456 2
list_toc( args )
char	 *args[];
d1475 1
d1484 5
a1488 2
/*	c o l _ p r t ( )
	Print list of names in tabular columns.
d1491 1
a1491 3
col_prt( list, ct )
register char	*list[];
register int	ct;
d1519 6
a1524 3
/*	i n s e r t ( )
	Insert each member of the table of contents 'toc_list' which
	matches one of the arguments into the current list 'curr_list'.
d1527 1
a1527 3
insert(  args,	ct )
char		*args[];
register int	ct;
d1551 5
a1555 3
/*	d e l e t e ( )
	delete all members of current list 'curr_list' which match
	one of the arguments
d1558 1
a1558 2
delete(  args )
char	*args[];
a1595 2
/*
	Section 4:	S T R I N G   P R O C E S S I N G   R O U T I N E S
d1597 4
a1600 6
			itoa()
			check()
 */

/*	i t o a ( )
	Convert integer to ascii  wd format.
d1603 1
a1603 5
itoa( n, s, w )
register
char	*s;
register
int   n,    w;
d1629 1
d1631 1
a1631 3
vls_blanks( v, n )
struct bu_vls	*v;
int		n;
d1638 3
a1640 2
/*
 *			V L S _ I T O A
d1642 1
a1642 1
 *	Convert integer to ascii  wd format.
d1645 1
a1645 4
vls_itoa( v, n, w )
struct bu_vls	*v;
register int	n;
register int	w;
d1676 1
d1685 1
d1694 1
d1701 3
a1703 2
/*
 *			V L S _ F T O A
d1705 1
a1705 1
 *	Convert float to ascii  w.df format.
d1770 3
a1772 2
/*
	Section 5:	I / O   R O U T I N E S
d1774 2
a1775 12
			getcmd()
			getarg()
			menu()
			blank_fill()
			bug()
			fbug()
 */

/*	g e t c m d ( )
	Return first character read from keyboard,
	copy command into args[0] and arguments into args[1]...args[n].

d1778 1
a1778 3
getcmd( args, ct )
char		*args[];
register int	ct;
d1802 6
a1807 4
/*	g e t a r g ( )
	Get a word of input into 'str',
	Return 0 if newline is encountered.
	Return 1 otherwise.
d1810 1
a1810 2
getarg( str )
register char	*str;
d1812 1
a1812 2
	do
	{
d1814 1
a1814 2
		if( (int)(*str) == ' ' )
		{
d1827 5
a1831 2
/*	m e n u ( )
	Display menu stored at address 'addr'.
d1834 1
a1834 2
menu( addr )
char **addr;
d1843 5
a1847 2
/*	b l a n k _ f i l l ( )
	Write count blanks to fildes.
d1850 1
a1850 3
blank_fill( fp, count )
FILE		*fp;
register int	count;
d1855 3
a1857 2
/*
	Section 6:	I N T E R R U P T   H A N D L E R S
d1859 2
a1860 7
			abort_sig()
			quit()
 */

/*	a b o r t ( )
	Abort command without terminating run (restore command prompt) and
	cleanup temporary files.
a1861 1
/*ARGSUSED*/
d1863 1
a1863 1
abort_sig( sig )
d1871 5
a1875 2
/*	q u i t ( )
	Terminate run.
a1876 1
/*ARGSUSED*/
d1878 1
a1878 1
quit( sig )
d1884 1
@


14.20
log
@exit->bu_exit where applicable
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.19 2007/10/27 21:58:41 brlcad Exp $ (BRL)";
d116 1
a116 1
	"v d e c k ($Revision: 14.19 $)",
d945 1
a945 1
		bu_exit( 10, "" );
d1038 1
a1038 1
		bu_exit( 10, "" );
d1209 1
a1209 1
		bu_exit( 10, "" );
d1292 1
a1292 1
		bu_exit(2, "");
d1324 1
a1324 1
		bu_exit( 10, "" );
d1355 1
a1355 1
		bu_exit( 10, "" );
d1370 1
a1370 1
		bu_exit( 10, "" );
d1387 1
a1387 1
		bu_exit(11, "");
d1437 1
a1437 1
			bu_exit( 10, "" );
d1456 1
a1456 1
		bu_exit( 99, "" );
d1784 1
a1784 1
		bu_exit( 10, "" );
d1954 1
a1954 1
	bu_exit( 0, "" );
@


14.19
log
@quell compilation warnings for constness changes
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.18 2007/10/14 08:01:46 brlcad Exp $ (BRL)";
d116 1
a116 1
	"v d e c k ($Revision: 14.18 $)",
d945 1
a945 1
		exit( 10 );
d1038 1
a1038 1
		exit( 10 );
d1209 1
a1209 1
		exit( 10 );
d1292 1
a1292 1
		exit(2);
d1324 1
a1324 1
		exit( 10 );
d1355 1
a1355 1
		exit( 10 );
d1370 1
a1370 1
		exit( 10 );
d1387 1
a1387 1
		exit(11);
d1437 1
a1437 1
			exit( 10 );
d1456 1
a1456 1
		exit( 99 );
d1784 1
a1784 1
		exit( 10 );
d1954 1
a1954 1
	exit( 0 );
@


14.18
log
@take care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.17 2007/09/15 16:23:27 brlcad Exp $ (BRL)";
d116 1
a116 1
	"v d e c k ($Revision: 14.17 $)",
d1742 1
a1742 5
vls_ftoa_vec_cvt( v, vec, w, d )
struct bu_vls	*v;
vect_t		vec;
int		w;
int		d;
d1750 1
a1750 5
vls_ftoa_vec( v, vec, w, d )
struct bu_vls	*v;
vect_t		vec;
int		w;
int		d;
d1758 1
a1758 4
vls_ftoa_cvt( v, f, w, d )
struct bu_vls	*v;
register double	f;
register int	w, d;
d1769 1
a1769 4
vls_ftoa( v, f, w, d )
struct bu_vls	*v;
register double	f;
register int	w, d;
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.16 2007/07/26 01:14:00 brlcad Exp $ (BRL)";
d116 1
a116 1
	"v d e c k ($Revision: 14.16 $)",
d534 1
a534 1
		strcpy( op, regdp->d_namep );
d1561 1
a1561 1
			(void) strcpy( &buf[column], list[i] );
@


14.16
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.15 2007/05/14 21:04:34 brlcad Exp $ (BRL)";
d69 2
a70 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d116 1
a116 1
	"v d e c k ($Revision: 14.15 $)",
@


14.15
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@a23 9
 *	U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground
 *	Maryland 21005-5066
 *	(301)278-6647 or AV-298-6647
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.14 2007/01/27 01:41:55 brlcad Exp $ (BRL)";
d119 1
a119 1
	"v d e c k ($Revision: 14.14 $)",
@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.13 2007/01/23 01:13:57 brlcad Exp $ (BRL)";
a94 1
#include "rtstring.h"
a98 1

d128 1
a128 1
	"v d e c k ($Revision: 14.13 $)",
d155 1
a155 1
struct bu_vls	rt_vls;
d261 1
a261 1
	RT_LIST_INIT( &(sol_hd.l) );
d263 1
a263 1
	bu_vls_init( &rt_vls );
d394 1
a394 1
struct rt_vls	*vls;
d401 1
a401 1
	RT_VLS_CHECK( vls );
d406 1
a406 1
		rt_log("NOP\n");
d413 1
a413 1
			rt_vls_strncat( vls, op, 2 );
d420 1
a420 1
					rt_vls_strncat( vls, "nn", 2 );
d422 1
a422 1
					rt_vls_strncat( vls, "nr", 2 );
d424 1
a424 1
					rt_vls_strncat( vls, "??", 2 );
d426 1
a426 1
				rt_vls_strncat( vls, op, 2 );
d434 1
a434 1
		rt_log("REGION 'stp'=x%x\n",
d439 1
a439 1
		rt_log("Unknown op=x%x\n", tp->tr_op );
d471 3
a473 3
	struct rt_vls		ident;
	struct rt_vls		reg;
	struct rt_vls		flat;
d482 3
a484 3
	RT_VLS_INIT( &ident );
	RT_VLS_INIT( &reg );
	RT_VLS_INIT( &flat );
d508 1
a508 1
		rt_vls_strcat( &flat, "" );
d516 2
a517 2
	cp = rt_vls_addr( &flat );
	left = rt_vls_strlen( &flat );
d561 1
a561 1
	rt_vls_strcat( &ident, "     " );		/* 5 spaces */
d569 1
a569 1
		rt_vls_strcat( &ident, bp );
d572 1
a572 1
		rt_vls_strcat( &ident, fullname+1 );
d574 2
a575 2
	rt_vls_strcat( &ident, "\n" );
	rt_vls_fwrite( ridfp, &ident );
d577 3
a579 3
	rt_vls_free( &ident );
	rt_vls_free( &reg );
	rt_vls_free( &flat );
d607 1
a607 1
	struct rt_vls		sol;
d611 1
a611 1
	RT_VLS_INIT( &sol );
d618 1
a618 1
		f = tsp->ts_mat[i] - rt_identity[i];
d634 1
a634 1
	for( RT_LIST_FOR( stp, soltab, &(sol_hd.l) ) )  {
d643 1
a643 1
					rt_log("rt_gettree_leaf:  %s re-referenced (ident)\n",
d658 1
a658 1
			rt_log("rt_gettree_leaf:  %s re-referenced\n",
d666 1
a666 1
	GETSTRUCT(stp, soltab);
d685 2
a686 2
		struct rt_vls	str;
		rt_vls_init( &str );
d689 1
a689 1
			rt_log("rt_gettree_leaf(%s):  solid describe failure\n",
d692 1
a692 1
		bu_log( "%s:  %s", dp->d_namep, rt_vls_addr( &str ) );
d697 1
a697 1
	RT_LIST_INSERT( &(sol_hd.l), &(stp->l) );
d740 1
a740 1
		rt_vls_strcat( &sol, ip->idb_meth->ft_name );
d742 2
a743 2
		rt_vls_strcat( &sol, dp->d_namep );
		rt_vls_strcat( &sol, "\n");
d747 2
a748 2
	rt_vls_fwrite( solfp, &sol );
	rt_vls_free( &sol );
d751 1
a751 1
	GETUNION( curtree, tree );
d789 1
a789 1
struct rt_vls		*v;
d794 1
a794 1
	RT_VLS_CHECK(v);
d799 1
a799 1
	rt_vls_strcat( v, "tor  " );		/* 5 */
d802 2
a803 2
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n" );
d810 2
a811 2
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n");
d819 1
a819 1
struct rt_vls		*v;
d824 1
a824 1
	RT_VLS_CHECK(v);
d829 1
a829 1
	rt_vls_strcat( v, "haf  " );		/* 5 */
d833 2
a834 2
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n" );
d842 1
a842 1
struct rt_vls		*v;
d849 1
a849 1
	RT_VLS_CHECK(v);
d854 1
a854 1
	rt_vls_strcat( v, "arbn " );		/* 5 */
d860 2
a861 2
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n" );
d869 2
a870 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d876 1
a876 1
struct rt_vls	*v;
d888 1
a888 1
			rt_vls_strncat( v, kind, 5 );
d890 1
a890 1
			rt_vls_strcat( v, "     " );
d898 2
a899 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d910 1
a910 1
struct rt_vls		*v;
d926 1
a926 1
		rt_vls_strncat( v, "arb??", 5 );
d928 2
a929 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d972 1
a972 1
struct rt_vls		*v;
d1010 1
a1010 1
		rt_vls_strcat( v, "ellg " );		/* 5 */
d1013 2
a1014 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d1020 2
a1021 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1024 1
a1024 1
		rt_vls_strcat( v, "ell1 " );		/* 5 */
d1027 2
a1028 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d1034 2
a1035 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1038 1
a1038 1
		rt_vls_strcat( v, "sph  " );		/* 5 */
d1042 2
a1043 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d1067 1
a1067 1
struct rt_vls		*v;
d1131 1
a1131 1
		rt_vls_strcat( v, "tgc  " );		/* 5 */
d1134 2
a1135 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d1141 2
a1142 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1149 2
a1150 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1153 1
a1153 1
		rt_vls_strcat( v, "rcc  " );		/* 5 */
d1156 2
a1157 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d1163 2
a1164 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1167 1
a1167 1
		rt_vls_strcat( v, "trc  " );		/* 5 */
d1170 2
a1171 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d1178 2
a1179 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1182 1
a1182 1
		rt_vls_strcat( v, "tec  " );		/* 5 */
d1185 2
a1186 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d1192 2
a1193 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1199 2
a1200 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1203 1
a1203 1
		rt_vls_strcat( v, "rec  " );		/* 5 */
d1206 2
a1207 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n" );
d1213 2
a1214 2
		rt_vls_strcat( v, name );
		rt_vls_strcat( v, "\n");
d1230 1
a1230 1
struct rt_vls		*v;
d1254 1
a1254 1
		rt_vls_strcat( v, "curve " );
d1256 1
a1256 1
		rt_vls_strcat( v, "\n" );
d1267 1
a1267 1
struct rt_vls		*v;
d1277 1
a1277 1
	rt_vls_strcat( v, "ars  " );		/* 5 */
d1281 2
a1282 2
	rt_vls_strcat( v, name );
	rt_vls_strcat( v, "\n" );
d1341 1
a1341 1
	ewrite( solfp, rt_units_string(dbip->dbi_local2base), 2 );
d1359 2
a1360 2
		(void) bu_vls_strcpy( &rt_vls, prefix );
		(void) bu_vls_strcat( &rt_vls, ".rt" );
d1363 2
a1364 2
		(void) bu_vls_strcpy( &rt_vls, "regions" );
	rt_file = bu_vls_addr( &rt_vls );
d1391 1
a1391 1
	if( !sol_hd.l.magic )  RT_LIST_INIT( &sol_hd.l );
d1705 1
a1705 1
struct rt_vls	*v;
d1708 2
a1709 2
	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "                                                                                                                                ",
d1720 1
a1720 1
struct rt_vls	*v;
d1727 3
a1729 3
	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", w);
	s = rt_vls_addr(v)+rt_vls_strlen(v)-w;
d1755 1
a1755 1
struct rt_vls	*v;
d1767 1
a1767 1
struct rt_vls	*v;
d1779 1
a1779 1
struct rt_vls	*v;
d1793 1
a1793 1
struct rt_vls	*v;
d1801 3
a1803 3
	RT_VLS_CHECK(v);
	rt_vls_strncat( v, "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", w);
	s = rt_vls_addr(v)+rt_vls_strlen(v)-w;
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.12 2007/01/20 14:37:07 brlcad Exp $ (BRL)";
d53 2
a54 2
  	Ident record for each Region as totaled on the Control card, however,
  	the Solid and Region records may span more than 1 card.
d130 1
a130 1
	"v d e c k ($Revision: 14.12 $)",
d1401 1
a1401 1
	    	exit(11);
d1905 1
a1905 1
 	Return 1 otherwise.
@


14.12
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.11 2006/04/05 18:19:52 brlcad Exp $ (BRL)";
d130 1
a130 1
	"v d e c k ($Revision: 14.11 $)",
@


14.11
log
@more header/warning cleanup from Intel compiler warnings on Altix
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2006 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.10 2006/02/27 10:08:41 brlcad Exp $ (BRL)";
d131 1
a131 1
	"v d e c k ($Revision: 14.10 $)",
@


14.10
log
@stdlib.h and exit()
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.9 2006/01/29 08:39:28 brlcad Exp $ (BRL)";
d84 9
d131 1
a131 1
	"v d e c k ($Revision: 14.9 $)",
@


14.10.2.1
log
@update from HEAD
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.10 2006/02/27 10:08:41 brlcad Exp $ (BRL)";
a83 9
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
d122 1
a122 1
	"v d e c k ($Revision: 14.10 $)",
@


14.9
log
@update to api changes from rt_* to bu_* for certain routines.
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.8 2006/01/24 05:00:27 brlcad Exp $ (BRL)";
d75 1
d78 1
d80 1
a80 1
#include <string.h>
d82 1
a82 1
#include <strings.h>
a83 1
#include <math.h>
d95 1
d122 1
a122 1
	"v d e c k ($Revision: 14.8 $)",
d264 1
a264 1
		exit( 1 );
d272 1
a272 1
		exit(1);
d378 1
a378 1
	exit( 0 );
@


14.8
log
@convert iteration over the array of linked list of directory nodes to FOR_ALL_DIRECTORY_START/FOR_ALL_DIRECTORY_END instead
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.7 2006/01/18 06:46:30 brlcad Exp $ (BRL)";
d120 1
a120 1
	"v d e c k ($Revision: 14.7 $)",
d252 1
a252 1
	setbuf( stdout, rt_malloc( BUFSIZ, "stdout buffer" ) );
d297 1
a297 1
				rt_free( curr_list[--curr_ct], "curr_list[ct]" );
d572 1
a572 1
	rt_free( fullname, "fullname" );
d663 1
a663 1
		stp->st_matp = (matp_t)rt_malloc( sizeof(mat_t), "st_matp" );
d1493 3
a1495 3
	toc_list = (char **)rt_malloc( count * sizeof(char *), "toc_list[]" );
	tmp_list = (char **)rt_malloc( count * sizeof(char *), "tmp_list[]" );
	curr_list = (char **)rt_malloc( count * sizeof(char *), "curr_list[]" );
d1600 1
a1600 1
				curr_list[curr_ct++] = rt_strdup(toc_list[j]);
d1635 1
a1635 1
				rt_free( curr_list[j], "curr_list" );
d1873 1
a1873 1
			rt_free( args[arg_ct], "args[arg_ct]" );
d1876 1
a1876 1
		args[arg_ct] = rt_malloc( MAXLN, "getcmd buffer" );
@


14.7
log
@update copyright to 2006
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.6 2005/10/23 04:44:39 brlcad Exp $ (BRL)";
d120 1
a120 1
	"v d e c k ($Revision: 14.6 $)",
d1487 3
a1489 5
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp=dp->d_forw )  {
			count++;
		}
	}
d1499 3
a1501 5
	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp=dp->d_forw )  {
			toc_list[ndir++] = dp->d_namep;
		}
	}
@


14.6
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1990-2005 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.5 2005/09/19 21:16:28 brlcad Exp $ (BRL)";
d120 1
a120 1
	"v d e c k ($Revision: 14.5 $)",
@


14.5
log
@BU_EXTERN
@
text
@d29 1
a29 1
 *  
d34 1
a34 1
 *  
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.4 2005/01/30 20:31:35 brlcad Exp $ (BRL)";
d120 1
a120 1
	"v d e c k ($Revision: 14.4 $)",
d146 1
a146 1
FILE	*regfp;		
d151 1
a151 1
FILE	*solfp;		
d153 1
a153 1
FILE	*ridfp;		
d308 1
a308 1
			{	
d654 1
a654 1
next_one: 
d766 1
a766 1
{	
d958 1
a958 1
 *			A D D E L L 
d1108 1
a1108 1
	/* Insure that magnitude of A is greater than B, and magnitude of 
d1290 1
a1290 1
{	
d1314 1
a1314 1
{	
d1523 1
a1523 1
{	
d1556 1
a1556 1
{	
d1591 1
a1591 1
{	
d1627 1
a1627 1
	for( i = 1; i < arg_ct; i++ ) { 
d1635 1
a1635 1
			{	
d1647 1
a1647 1
			} 
d1679 2
a1680 2
	do	
		s[i++] = n % 10 + '0';	
d1729 2
a1730 2
	do	
		s[i++] = n % 10 + '0';	
d1867 1
a1867 1
		
d1928 1
a1928 1
{	
d1943 1
a1943 1
{	
@


14.4
log
@update copyright to 2005
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vdeck/vdeck.c,v 14.3 2004/12/21 06:38:23 morrison Exp $ (BRL)";
d120 1
a120 1
	"v d e c k ($Revision: 14.3 $)",
d202 2
a203 2
RT_EXTERN(void ewrite, (FILE *fp, const char *buf, unsigned bytes) );
RT_EXTERN(void blank_fill, (FILE *fp, int count) );
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d34 1
a34 1
 *
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d120 1
a120 1
	"v d e c k ($Revision$)",
d146 1
a146 1
FILE	*regfp;
d151 1
a151 1
FILE	*solfp;
d153 1
a153 1
FILE	*ridfp;
d202 2
a203 2
BU_EXTERN(void ewrite, (FILE *fp, const char *buf, unsigned bytes) );
BU_EXTERN(void blank_fill, (FILE *fp, int count) );
d308 1
a308 1
			{
d654 1
a654 1
next_one:
d766 1
a766 1
{
d958 1
a958 1
 *			A D D E L L
d1108 1
a1108 1
	/* Insure that magnitude of A is greater than B, and magnitude of
d1290 1
a1290 1
{
d1314 1
a1314 1
{
d1523 1
a1523 1
{
d1556 1
a1556 1
{
d1591 1
a1591 1
{
d1627 1
a1627 1
	for( i = 1; i < arg_ct; i++ ) {
d1635 1
a1635 1
			{
d1647 1
a1647 1
			}
d1679 2
a1680 2
	do
		s[i++] = n % 10 + '0';
d1729 2
a1730 2
	do
		s[i++] = n % 10 + '0';
d1867 1
a1867 1

d1928 1
a1928 1
{
d1943 1
a1943 1
{
@


14.3
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2004 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vdeck/vdeck.c,v 14.2 2004/12/21 03:36:56 morrison Exp $ (BRL)";
d120 1
a120 1
	"v d e c k ($Revision: 14.2 $)",
@


14.2
log
@assign copyright and GPL
@
text
@a34 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vdeck/vdeck.c,v 14.1 2004/11/16 19:42:32 morrison Exp $ (BRL)";
d120 1
a120 1
	"v d e c k ($Revision: 14.1 $)",
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			V D E C K
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vdeck/vdeck.c,v 1.4 2004/09/03 23:31:00 morrison Exp $ (BRL)";
d123 1
a123 1
	"v d e c k ($Revision: 1.4 $)",
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vdeck/vdeck.c,v 1.3 2004/08/02 23:01:53 morrison Exp $ (BRL)";
d104 1
a104 1
	"v d e c k ($Revision: 1.3 $)",
d1962 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vdeck/vdeck.c,v 1.2 2004/06/08 22:04:47 morrison Exp $ (BRL)";
d61 1
a61 1
#ifdef USE_STRING_H
d104 1
a104 1
	"v d e c k ($Revision: 1.2 $)",
@


1.2
log
@obliterate externs.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d57 1
a57 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
d104 1
a104 1
	"v d e c k ($Revision$)",
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/vdeck/vdeck.c,v 11.21 2004/05/10 15:30:51 erikg Exp $ (BRL)";
a60 2


a71 1
#include "externs.h"
d106 1
a106 1
	"v d e c k ($Revision: 11.21 $)",
@

