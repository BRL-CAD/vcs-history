head	14.8;
access;
symbols
	rel-7-10-4:14.6
	STABLE:14.6.0.2
	stable-branch:14.1
	rel-7-10-2:14.6
	rel-7-10-0:14.5
	rel-7-8-4:14.2
	rel-7-8-2:14.2
	rel-7-8-0:14.2
	trimnurbs-branch:14.2.0.8
	help:14.2
	temp_tag:14.2
	bobWinPort-20051223-freeze:14.2
	postmerge-20051223-bobWinPort:14.2
	premerge-20051223-bobWinPort:14.2
	rel-7-6-6:14.2
	rel-7-6-4:14.2
	rel-7-6-2:14.2
	rel-7-6-branch:14.2.0.6
	rel-7-6-0:14.2
	rel-7-4-2:14.2
	rel-7-4-branch:14.2.0.4
	bobWinPort:14.2.0.2
	rel-7-4-0:14.2
	rel-7-2-6:14.2
	rel-7-2-4:14.2
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.8
date	2007.12.16.18.53.50;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2007.07.26.01.13.58;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2007.01.27.01.41.43;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2007.01.23.01.13.40;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2007.01.21.07.32.56;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2005.04.26.08.27.38;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.16;	author morrison;	state Exp;
branches;
next	;


desc
@@


14.8
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                        T E R M I O . C
 * BRL-CAD
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file termio.c
 *
 *	Author:		Gary S. Moss
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libtermio/termio.c,v 14.7 2007/10/22 20:59:55 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>

#ifdef HAVE_SYS_FILE_H
#  include <sys/file.h>
#endif

#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#if HAVE_SYS_IOCTL_COMPAT_H
#	include <sys/ioctl_compat.h>
#	define TAB3 (TAB1|TAB2)
#	if !defined(OCRNL)
#		define OCRNL   0000010
#	endif
#endif


#include "machine.h"

/*
 *  This file will work IFF one of these three flags is set:
 *	HAVE_TERMIOS_H	use POXIX termios and tcsetattr() call with XOPEN flags
 *	SYSV		use SysV Rel3 termio and TCSETA ioctl
 *	BSD		use Version 7 / BSD sgttyb and TIOCSETP ioctl
 */

#if defined(HAVE_MEMORY_H)
#  include <memory.h>
#endif

#if defined(HAVE_TERMIOS_H)
#  undef SYSV
#  undef BSD
#  include <termios.h>

static struct termios	save_tio[FOPEN_MAX], curr_tio[FOPEN_MAX];

#else	/* !defined(HAVE_TERMIOS_H) */

#  ifdef SYSV
#    undef BSD
#    include <termio.h>
#    include <memory.h>
	static struct termio	save_tio[FOPEN_MAX], curr_tio[FOPEN_MAX];
#  endif /* SYSV */

#  ifdef BSD
#    undef SYSV
#    include <sys/ioctl.h>
#      ifndef	XTABS
#	define	XTABS	(TAB1 | TAB2)
#      endif /* XTABS */

	static struct sgttyb	save_tio[FOPEN_MAX], curr_tio[FOPEN_MAX];
#  endif /* BSD */

#endif /* HAVE_TERMIOS_H */

#include "libtermio.h"

static int		fileStatus[FOPEN_MAX];
void			prnt_Tio();
static void		copy_Tio();

/*	c l r _ C b r e a k ( )
	Clear CBREAK mode, for file descriptor 'fd'.
 */
void
clr_Cbreak( fd )
int	fd;
	{
#ifdef BSD
	curr_tio[fd].sg_flags &= ~CBREAK;	/* CBREAK mode OFF.	*/
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV
	curr_tio[fd].c_lflag |= ICANON;		/* Canonical input ON.	*/

	curr_tio[fd].c_cc[VEOF] = 4;		/* defaults!		*/
	curr_tio[fd].c_cc[VEOL] = 0;		/*   best we can do.... */

	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_lflag |= ICANON;		/* Canonical input ON.	*/
	curr_tio[fd].c_cc[VEOF] = 4;		/* defaults!		*/
	curr_tio[fd].c_cc[VEOL] = 0;		/*   best we can do.... */
	(void)tcsetattr( fd, TCSAFLUSH, &curr_tio[fd] );
#endif
	return;
	}

/*	s e t _ C b r e a k ( )
	Set CBREAK mode, 'fd'.
 */
void
set_Cbreak( fd )
int	fd;
	{
#ifdef BSD
	curr_tio[fd].sg_flags |= CBREAK;	/* CBREAK mode ON.	*/
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV
	curr_tio[fd].c_lflag &= ~ICANON;	/* Canonical input OFF. */

	curr_tio[fd].c_cc[VMIN] = 1;
	curr_tio[fd].c_cc[VTIME] = 0;

	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_lflag &= ~ICANON;	/* Canonical input OFF. */
	curr_tio[fd].c_cc[VMIN] = 1;
	curr_tio[fd].c_cc[VTIME] = 0;
	(void)tcsetattr( fd, TCSANOW, &curr_tio[fd] );
#endif
	return;
	}

/*	c l r _ R a w ( )
	Set cooked mode, 'fd'.
 */
void
clr_Raw( fd )
int	fd;
	{
#ifdef BSD
	curr_tio[fd].sg_flags &= ~RAW;		/* Raw mode OFF.	*/
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV
	curr_tio[fd].c_lflag |= ICANON;		/* Canonical input ON.	*/

	curr_tio[fd].c_lflag |= ISIG;		/* Signals ON.		*/
	curr_tio[fd].c_cc[VEOF] = 4;		/* defaults!		*/
	curr_tio[fd].c_cc[VEOL] = 0;		/*   best we can do.... */

	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_lflag |= ICANON;		/* Canonical input ON.	*/
	curr_tio[fd].c_lflag |= ISIG;		/* Signals ON.		*/
	curr_tio[fd].c_cc[VEOF] = 4;		/* defaults!		*/
	curr_tio[fd].c_cc[VEOL] = 0;		/*   best we can do.... */
	(void)tcsetattr( fd, TCSAFLUSH, &curr_tio[fd] );
#endif
	return;
	}

/*	s e t _ R a w ( )
	Set raw mode, 'fd'.
 */
void
set_Raw( fd )
int	fd;
	{
#ifdef BSD
	curr_tio[fd].sg_flags |= RAW;		/* Raw mode ON.		*/
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV
	curr_tio[fd].c_lflag &= ~ICANON;	/* Canonical input OFF. */

	curr_tio[fd].c_lflag &= ~ISIG;		/* Signals OFF.		*/
	curr_tio[fd].c_cc[VMIN] = 1;
	curr_tio[fd].c_cc[VTIME] = 0;

	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_lflag &= ~ICANON;	/* Canonical input OFF. */
	curr_tio[fd].c_lflag &= ~ISIG;		/* Signals OFF.		*/
	curr_tio[fd].c_cc[VMIN] = 1;
	curr_tio[fd].c_cc[VTIME] = 0;
	(void)tcsetattr( fd, TCSANOW, &curr_tio[fd] );
#endif
	return;
	}

/*	s e t _ E c h o ( )
	Set echo mode, 'fd'.
 */
void
set_Echo( fd )
int	fd;
	{
#ifdef BSD
	curr_tio[fd].sg_flags |= ECHO;		/* Echo mode ON.	*/
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV
	curr_tio[fd].c_lflag |= ECHO;		/* Echo mode ON.	*/
	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_lflag |= ECHO;		/* Echo mode ON.	*/
	(void)tcsetattr( fd, TCSANOW, &curr_tio[fd] );
#endif
	return;
	}

/*	c l r _ E c h o ( )
	Clear echo mode, 'fd'.
 */
void
clr_Echo( fd )
int	fd;
	{
#ifdef BSD
	curr_tio[fd].sg_flags &= ~ECHO;		/* Echo mode OFF.	*/
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV
	curr_tio[fd].c_lflag &= ~ECHO;		/* Echo mode OFF.	*/
	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_lflag &= ~ECHO;		/* Echo mode OFF.	*/
	(void)tcsetattr( fd, TCSANOW, &curr_tio[fd] );
#endif
	return;
	}

/*	s e t _ T a b s ( )
	Turn on tab expansion, 'fd'.
 */
void
set_Tabs( fd )
int	fd;
	{
#ifdef BSD
	curr_tio[fd].sg_flags |= XTABS;		/* Tab expansion ON.	*/
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV

	curr_tio[fd].c_oflag |= TAB3;		/* Tab expansion ON.	*/

	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_oflag |= TAB3;		/* Tab expansion ON.	*/
	(void)tcsetattr( fd, TCSANOW, &curr_tio[fd] );
#endif
	return;
	}

/*	c l r _ T a b s ( )
	Turn off tab expansion, 'fd'.
 */
void
clr_Tabs( fd )
int	fd;
	{
#ifdef BSD
	curr_tio[fd].sg_flags &= ~XTABS;	/* Tab expans. OFF.	*/
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV

	curr_tio[fd].c_oflag &= ~TAB3;		/* Tab expans. OFF.	*/

	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_oflag &= ~TAB3;		/* Tab expans. OFF.	*/
	(void)tcsetattr( fd, TCSANOW, &curr_tio[fd] );
#endif
	return;
	}

/*	s e t _ H U P C L ( )
	Turn on "Hang up on last close", 'fd'.
 */
void
set_HUPCL( fd )
int	fd;
	{
#ifdef BSD
	(void) ioctl( fd, TIOCHPCL, NULL );
#endif

#ifdef SYSV
	curr_tio[fd].c_cflag |= HUPCL;
	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif

#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_cflag |= HUPCL;
	(void)tcsetattr( fd, TCSANOW, &curr_tio[fd] );
#endif
	return;
	}

/*	c l r _ C R N L ( )
	Turn off CR/LF mapping, fd.
 */
void
clr_CRNL( fd )
	{
#ifdef BSD
	curr_tio[fd].sg_flags &= ~CRMOD;
	(void) ioctl( fd, TIOCSETP, &curr_tio[fd] );
#endif
#ifdef SYSV

	curr_tio[fd].c_oflag &= ~(ONLCR|OCRNL);
	curr_tio[fd].c_iflag &= ~(ICRNL|INLCR);

	(void) ioctl( fd, TCSETA, &curr_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	curr_tio[fd].c_oflag &= ~(ONLCR|OCRNL);
	curr_tio[fd].c_iflag &= ~(ICRNL|INLCR);
	(void)tcsetattr( fd, TCSAFLUSH, &curr_tio[fd] );
#endif
	}

/*	g e t _ O _ S p e e d ( )
	Get the terminals output speed, 'fd'.
 */
unsigned short
get_O_Speed( fd )
	{
#ifdef BSD
	return	(unsigned short) save_tio[fd].sg_ospeed;
#endif
#ifdef SYSV
	return	save_tio[fd].c_cflag & CBAUD;
#endif
#ifdef HAVE_TERMIOS_H
	return	cfgetospeed( &save_tio[fd] );
#endif
	}

/*	s a v e _ T t y ( )
	Get and save terminal parameters, 'fd'.
 */
void
save_Tty( fd )
int	fd;
	{
#if BSD
	(void) ioctl( fd, TIOCGETP, &save_tio[fd] );
#endif
#ifdef SYSV
	(void) ioctl( fd, TCGETA, &save_tio[fd] );
#endif
#ifdef HAVE_TERMIOS_H
	(void)tcgetattr( fd, &save_tio[fd] );
#endif
	copy_Tio( &curr_tio[fd], &save_tio[fd] );
	return;
	}

/*	r e s e t _ T t y ( )
	Set the terminal back to the mode that the user had last time
	save_Tty() was called for 'fd'.
 */
void
reset_Tty( fd )
int	fd;
	{
#if BSD
	(void) ioctl( fd, TIOCSETP, &save_tio[fd] ); /* Write setting.		*/
#endif
#if SYSV
	(void) ioctl( fd, TCSETA, &save_tio[fd] ); /* Write setting.		*/
#endif
#if HAVE_TERMIOS_H
	(void)tcsetattr( fd, TCSAFLUSH, &save_tio[fd] );
#endif
	return;
	}

/*	s a v e _ F i l _ S t a t ( )
	Save file status flags for 'fd'.
 */
int
save_Fil_Stat( fd )
int	fd;
	{
	return	fileStatus[fd] = fcntl( fd, F_GETFL, 0 );
	}

/*	r e s e t _ F i l _ S t a t ( )
	Restore file status flags for file desc. 'fd' to what they were the
	last time saveFilStat(fd) was called.
 */
int
reset_Fil_Stat( fd )
int	fd;
	{
	return	fcntl( fd, F_SETFL, fileStatus[fd] );
	}

/*	s e t _ O _ N D E L A Y ( )
	Set non-blocking read on 'fd'.
 */
int
set_O_NDELAY( fd )
int	fd;
	{
#if defined(SYSV) || defined(BSD)
	return	fcntl( fd, F_SETFL, O_NDELAY );
#else
#if HAVE_TERMIOS_H
	return	fcntl( fd, F_SETFL, FNDELAY );
#endif
#endif
	}

/*	c o p y _ T i o ( )						*/
static void
copy_Tio( to, from )
#ifdef BSD
struct sgttyb	*to, *from;
#endif
#ifdef SYSV
struct termio	*to, *from;
#endif
#ifdef HAVE_TERMIOS_H
struct termios	*to, *from;
#endif
{
	(void)memcpy((char *) to, (char *) from, sizeof(*from));
	return;
}

/*	p r n t _ T i o ( )						*/
void
prnt_Tio( msg, tio_ptr )
char		*msg;
#ifdef BSD
struct sgttyb	*tio_ptr;
#endif
#ifdef SYSV
struct termio	*tio_ptr;
#endif
#ifdef HAVE_TERMIOS_H
struct termios	*tio_ptr;
#endif
	{	register int	i;
	(void) fprintf( stderr, "%s :\n\r", msg );
#ifdef BSD
	(void) fprintf( stderr, "\tsg_ispeed=%d\n\r", (int) tio_ptr->sg_ispeed );
	(void) fprintf( stderr, "\tsg_ospeed=%d\n\r", (int) tio_ptr->sg_ospeed );
	(void) fprintf( stderr, "\tsg_erase='%c'\n\r", tio_ptr->sg_erase );
	(void) fprintf( stderr, "\tsg_kill='%c'\n\r", tio_ptr->sg_kill );
	(void) fprintf( stderr, "\tsg_flags=0x%x\n\r", tio_ptr->sg_flags );
#endif
#ifdef SYSV

	(void) fprintf( stderr, "\tc_iflag=0x%x\n\r", tio_ptr->c_iflag );
	(void) fprintf( stderr, "\tc_oflag=0x%x\n\r", tio_ptr->c_oflag );
	(void) fprintf( stderr, "\tc_cflag=0x%x\n\r", tio_ptr->c_cflag );
	(void) fprintf( stderr, "\tc_lflag=0x%x\n\r", tio_ptr->c_lflag );
	(void) fprintf( stderr, "\tc_line=%c\n\r", tio_ptr->c_line );
	for( i = 0; i < NCC; ++i )
		{
		(void) fprintf( stderr,
				"\tc_cc[%d]=0%o\n\r",
				i,
				tio_ptr->c_cc[i]
				);
		}
#endif
#ifdef HAVE_TERMIOS_H

	(void) fprintf( stderr, "\tc_iflag=0x%x\n\r", (unsigned int)tio_ptr->c_iflag );
	(void) fprintf( stderr, "\tc_oflag=0x%x\n\r", (unsigned int)tio_ptr->c_oflag );
	(void) fprintf( stderr, "\tc_cflag=0x%x\n\r", (unsigned int)tio_ptr->c_cflag );
	(void) fprintf( stderr, "\tc_lflag=0x%x\n\r", (unsigned int)tio_ptr->c_lflag );
	for( i = 0; i < NCCS; ++i )
		{
		(void) fprintf( stderr,
				"\tc_cc[%d]=0%o\n\r",
				i,
				tio_ptr->c_cc[i]
				);
		}
#endif
	return;
	}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.7
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libtermio/termio.c,v 14.6 2007/07/26 01:13:58 brlcad Exp $ (BRL)";
d455 1
a455 12
struct termios	*to;
struct termios	*from;
#endif
	{
#ifdef BSD
	(void)bcopy( (char *)from, (char*)to, sizeof(struct sgttyb) );
#endif
#ifdef SYSV
	(void) memcpy( (char *) to, (char *) from, sizeof(struct termio) );
#endif
#ifdef HAVE_TERMIOS_H
	(void) memcpy( (char *) to, (char *) from, sizeof(struct termios) );
d457 2
d460 1
a460 1
	}
@


14.6
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libtermio/termio.c,v 14.5 2007/01/27 01:41:43 brlcad Exp $ (BRL)";
d109 1
a109 1
#ifndef CRAY2
d112 1
a112 1
#endif
d137 1
a137 1
#ifndef CRAY2
d140 1
a140 1
#endif
d165 1
a165 1
#ifndef CRAY2
d169 1
a169 1
#endif
d195 1
a195 1
#ifndef CRAY2
d199 1
a199 1
#endif
d268 1
a268 1
#ifndef CRAY2
d270 1
a270 1
#endif
d292 1
a292 1
#ifndef CRAY2
d294 1
a294 1
#endif
a310 1
#ifndef CRAY2
d314 1
d319 1
a319 1
#endif
d338 1
a338 1
#ifndef CRAY2
d341 1
a341 1
#endif
a360 1
#ifndef CRAY2
a362 1
#endif
@


14.5
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d22 2
a23 6
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libtermio/termio.c,v 14.4 2007/01/23 01:13:40 brlcad Exp $ (BRL)";
@


14.4
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libtermio/termio.c,v 14.3 2007/01/21 07:32:56 brlcad Exp $ (BRL)";
a52 1

@


14.3
log
@add missing lgpl header
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libtermio/termio.c,v 14.2 2005/04/26 08:27:38 brlcad Exp $ (BRL)";
@


14.2
log
@use the configure check header file macros for fcntl.h and sys/file.h
@
text
@d1 21
a21 2
/*LINTLIBRARY*/
/*
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libtermio/termio.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
a33 2


@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d10 1
a10 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libtermio/termio.c,v 1.2 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d19 6
a24 4
#if IRIX >= 5
#include <sys/file.h>
#else
#include <fcntl.h>
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d10 1
a10 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libtermio/termio.c,v 1.1 2004/05/20 15:20:16 morrison Exp $ (BRL)";
d514 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d10 1
a10 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libtermio/termio.c,v 11.10 2004/05/10 15:30:47 erikg Exp $ (BRL)";
d13 1
a13 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

