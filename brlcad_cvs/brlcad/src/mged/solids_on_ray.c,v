head	14.17;
access;
symbols
	rel-7-10-4:14.11.2.1
	STABLE:14.11.0.2
	stable-branch:14.3
	rel-7-10-2:14.11
	rel-7-10-0:14.10
	rel-7-8-4:14.7
	rel-7-8-2:14.7
	rel-7-8-0:14.7
	trimnurbs-branch:14.7.0.2
	help:14.7
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.3
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.4
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.17
date	2007.12.14.21.02.47;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.12.02.22.34.23;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.11.21.20.38.23;	author erikgreenwald;	state Exp;
branches;
next	14.14;

14.14
date	2007.11.21.19.49.12;	author erikgreenwald;	state Exp;
branches;
next	14.13;

14.13
date	2007.11.21.15.52.58;	author erikgreenwald;	state Exp;
branches;
next	14.12;

14.12
date	2007.09.15.16.23.18;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.05.14.21.04.32;	author brlcad;	state Exp;
branches
	14.11.2.1;
next	14.10;

14.10
date	2007.01.27.01.41.44;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.23.01.13.42;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2007.01.20.14.36.58;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.02.27.10.08.40;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.12.08.01.34.05;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches
	14.3.6.1;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.29;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.28;	author morrison;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.18;	author brlcad;	state Exp;
branches;
next	;

14.11.2.1
date	2007.09.28.14.04.35;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.17
log
@quell overlap callback decl warning
@
text
@/*                 S O L I D S _ O N _ R A Y . C
 * BRL-CAD
 *
 * Copyright (c) 1995-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file solids_on_ray.c
 *
 *	Routines to implement the click-to-pick-an-edit-solid feature.
 *
 *  Functions -
 *	skewer_solids		fire a ray and list the solids hit
 *
 *  Author -
 *	Paul Tanenbaum
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.16 2007/12/02 22:34:23 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <signal.h>
#include <string.h>

#include "tcl.h"
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"


#define	ORDER_BY_NAME		 0
#define	ORDER_BY_DISTANCE	 1

#define	made_it()		printf("Made it to %s%d\n", \
					__FILE__, __LINE__); \
				fflush(stdout)

/*
 *		S O L _ N A M E _ D I S T
 *
 *	Little pair for storing the name and distance of a solid
 */
struct sol_name_dist
{
    long	magic;
    char	*name;
    fastf_t	dist;
};
#define	SOL_NAME_DIST_MAGIC	0x736c6e64

#if OLD_RPT
/*
 *		S O L _  C O M P _ N A M E
 *
 *	The function to order solids alphabetically by name
 */
static int
sol_comp_name(void *v1, void *v2)
{
    struct sol_name_dist	*s1 = v1;
    struct sol_name_dist	*s2 = v2;

    BU_CKMAG(s1, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
    BU_CKMAG(s2, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");

    return(strcmp(s1 -> name, s2 -> name));
}

/*
 *		S O L _  C O M P _ D I S T
 *
 *	The function to order solids by distance along the ray
 */
static int
sol_comp_dist(void *v1, void *v2)
{
    struct sol_name_dist	*s1 = v1;
    struct sol_name_dist	*s2 = v2;

    BU_CKMAG(s1, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");
    BU_CKMAG(s2, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");

    if (s1 -> dist > s2 -> dist)
	return (1);
    else if (s1 -> dist == s2 -> dist)
	return (0);
    else /* (s1 -> dist < s2 -> dist) */
	return (-1);
}

/*
 *			M K _ S O L I D
 */
static struct sol_name_dist *
mk_solid(char *name, fastf_t dist)
{
    struct sol_name_dist	*sp;

    sp = (struct sol_name_dist *)
	    bu_malloc(sizeof(struct sol_name_dist), "solid");
    sp -> magic = SOL_NAME_DIST_MAGIC;
    sp -> name = (char *)
	    bu_malloc(strlen(name) + 1, "solid name");
    strncpy(sp -> name, name, strlen(name));
    sp -> dist = dist;
    return (sp);
}

/*
 *			F R E E _ S O L I D
 *
 *	This function has two parameters: the solid to free and
 *	an indication whether the name member of the solid should
 *	also be freed.
 */
static void
free_solid(struct sol_name_dist *sol, int free_name)
{
    BU_CKMAG(sol, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");

    if (free_name)
	bu_free((genptr_t) sol -> name, "solid name");
    bu_free((genptr_t) sol, "solid");
}

/*
 *			P R I N T _ S O L I D
 */
static void
print_solid(void *vp, int depth)
{
    struct sol_name_dist	*sol = vp;
    struct bu_vls tmp_vls;

    BU_CKMAG(sol, SOL_NAME_DIST_MAGIC, "sol_name_dist structure");

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "solid %s at distance %g along ray\n",
		  sol -> name, sol -> dist);
    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
    bu_vls_free(&tmp_vls);
}
#endif /* OLD_RPT */


/*
 *			    N O _ O P
 *
 *	    Null event handler for use by rt_shootray().
 *
 *	Does nothing.  Returns 1.
 */
static int
no_op(struct application *ap, struct partition *ph, struct region *r1, struct region *r2, struct partition *hp)
{
    return (1);
}

/*
 *	    B U I L D _ P A T H _ N A M E _ O F _ S O L I D ( )
 *
 *	Builds the slash-separated path name for a struct solid.
 */
void
build_path_name_of_solid(struct bu_vls *vp, struct solid *sp)
{
    bu_vls_trunc(vp, 0);
    db_path_to_vls(vp, &sp->s_fullpath);
}

#if OLD_RPT
/*
 *			R P T _ S O L I D S
 *
 *		Hit handler for use by rt_shootray().
 *
 *	Grabs the first partition it sees, extracting thence
 *	the segment list.  Rpt_solids() sorts the solids along
 *	the ray by first encounter.  As a side-effect, rpt_solids()
 *	stores in ap->a_uptr the address of a null-terminated array
 *	of the sorted solid names.  If ap->a_user is nonzero,
 *	rpt_solids() stashes the complete path name for each solid,
 *	otherwise, just its basename.  It returns 1.
 */
/* If this is defined inside the body of rpt_solids(), it causes
 * the IRIX 6 compilers to segmentation fault in WHIRL file phase. Ugh. */
static int			(*rpt_solids_orders[])() =
				{
				    sol_comp_name,
				    sol_comp_dist
				};

static int
rpt_solids(struct application *ap, struct partition *ph, struct seg *finished_segs)
{
    char			**result;
    struct db_full_path		*fp;
    int				i;
    struct partition		*pp;
    bu_rb_tree			*solids;
    struct seg			*segp;
    struct sol_name_dist	*old_sol;
    struct sol_name_dist	*sol;
    struct soltab		*stp;
    struct bu_vls		sol_path_name;
    int				index;

    /*
     *	Initialize the solid list
     */
    if ((solids = bu_rb_create("Primitive list", 2, rpt_solids_orders)) == BU_RB_TREE_NULL)
	bu_exit (1, "%s: %d: bu_rb_create() bombed\n", __FILE__, __LINE__);
    solids -> rbt_print = print_solid;
    bu_rb_uniq_on(solids, ORDER_BY_NAME);

    bu_vls_init(&sol_path_name);

    /*
     *	Get the list of segments along this ray
     *	and seek to its head
     */
    BU_CKMAG(ph, PT_HD_MAGIC, "partition head");
    pp = ph -> pt_forw;
    BU_CKMAG(pp, PT_MAGIC, "partition structure");
    if (BU_LIST_MAGIC_WRONG((struct bu_list *) finished_segs,
			    RT_SEG_MAGIC))
	BU_CKMAG(finished_segs, BU_LIST_HEAD_MAGIC, "list head");

    /*
     *	New stuff
     */

    RT_CK_LIST_HEAD(&finished_segs->l);

    for (BU_LIST_FOR(pp, partition, (struct bu_list *) &ph -> pt_magic))
    {
	BU_CKMAG(pp, PT_MAGIC, "partition");
	BU_CKMAG(pp -> pt_regionp, RT_REGION_MAGIC, "region");
	printf("    Partition <x%lx> is '%s' ",
	    (long)pp, pp -> pt_regionp -> reg_name);

	printf("\n--- Primitives hit on this partition ---\n");
	for (i = 0; i < (pp -> pt_seglist).end; ++i)
	{
	    stp = ((struct seg *)BU_PTBL_GET(&pp->pt_seglist, i))->seg_stp;
	    RT_CK_SOLTAB(stp);
	    bu_vls_trunc(&sol_path_name, 0);
	    fp = &(stp -> st_path);
	    if (fp -> magic != 0)
	    {
		printf(" full path... ");fflush(stdout);
		RT_CK_FULL_PATH(fp);
		bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
	    }
	    else
	    {
		printf(" dir-entry name... ");fflush(stdout);
		BU_CKMAG(stp -> st_dp, RT_DIR_MAGIC,
		    "directory");
		bu_vls_strcpy(&sol_path_name, stp -> st_name);
	    }
	    printf("'%s'\n", bu_vls_addr(&sol_path_name));fflush(stdout);
	}
	printf("------------------------------------\n");

    /*
     *	Look at each segment that participated in this ray partition.
     */
    for( index = 0; index < BU_PTBL_END(&pp->pt_seglist); index++ )  {
	segp = (struct seg *)BU_PTBL_GET(&pp->pt_seglist, index);
	RT_CK_SEG(segp);
	RT_CK_SOLTAB(segp -> seg_stp);

	printf("Primitive #%d in this partition is ", index);fflush(stdout);
	bu_vls_trunc(&sol_path_name, 0);
	fp = &(segp -> seg_stp -> st_path);
	if (fp -> magic != 0)
	{
		printf(" full path... ");fflush(stdout);
		RT_CK_FULL_PATH(fp);
		bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
	}
	else
	{
		printf(" dir-entry name... ");fflush(stdout);
		BU_CKMAG(segp -> seg_stp -> st_dp, RT_DIR_MAGIC,
		    "directory");
		bu_vls_strcpy(&sol_path_name, segp -> seg_stp -> st_name);
	}
	printf("'%s'\n", bu_vls_addr(&sol_path_name));

	/*
	 *	Attempt to record the new solid.
	 *	If it shares its name with a previously recorded solid,
	 *	then retain the one that appears earlier on the ray.
	 */
	sol = mk_solid(bu_vls_addr(&sol_path_name),
		    segp -> seg_in.hit_dist);
	if (bu_rb_insert(solids, (void *) sol) < 0)
	{
	    old_sol = (struct sol_name_dist *)
			bu_rb_curr(solids, ORDER_BY_NAME);
	    BU_CKMAG(old_sol, SOL_NAME_DIST_MAGIC,
		"sol_name_dist structure");
	    if (sol -> dist >= old_sol -> dist)
		free_solid(sol, 1);
	    else
	    {
		bu_rb_delete(solids, ORDER_BY_NAME);
		bu_rb_insert(solids, sol);
		free_solid(old_sol, 1);
	    }
	}
    }
    }

    /*
     *	Record the resulting list of solid names
     *	for use by the calling function
     */
    result = (char **)
		bu_malloc((solids -> rbt_nm_nodes + 1) * sizeof(char *),
			  "names of solids on ray");
    for (sol = (struct sol_name_dist *) bu_rb_min(solids, ORDER_BY_DISTANCE),
		i=0;
	 sol != NULL;
	 sol = (struct sol_name_dist *) bu_rb_succ(solids, ORDER_BY_DISTANCE),
		++i)
    {
	result[i] = sol -> name;
	free_solid(sol, 0);
    }
    result[i] = 0;
    ap -> a_uptr = (char *) result;

    bu_rb_free(solids, BU_RB_RETAIN_DATA);

    return 1;
    /*
     *	End new stuff
     */
#if 0

    for (segh = pp -> pt_inseg;
	    *((long *) segh) != BU_LIST_HEAD_MAGIC;
	    segh = (struct seg *) (segh -> l.forw))
	BU_CKMAG(segh, RT_SEG_MAGIC, "segment structure");

    /*
     *	Let's see what final_segs contains...
     */
    RT_CHECK_SEG(final_segs -> seg_stp);
    bu_vls_trunc(&sol_path_name, 0);
    fp = &(final_segs -> seg_stp -> st_path);
    bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
    printf("At line %d, sol_path_name contains '%s'\n",
	    __LINE__, bu_vls_addr(&sol_path_name));

    /*
     *	March down the segment list
     */
    for (segp = (struct seg *) (segh -> l.forw);
	    segp != segh;
	    segp = (struct seg *) segp -> l.forw)
    {
	BU_CKMAG(segp, RT_SEG_MAGIC, "seg structure");

	bu_vls_trunc(&sol_path_name, 0);
	fp = &(segp -> seg_stp -> st_path);
	printf("At line %d, sol_path_name contains '%s'\n",
		__LINE__, bu_vls_addr(&sol_path_name));
	if (fp -> magic)
	    bu_vls_strcpy(&sol_path_name, db_path_to_string(fp));
	printf("At line %d, sol_path_name contains '%s'\n",
		__LINE__, bu_vls_addr(&sol_path_name));
	bu_vls_strcat(&sol_path_name, segp -> seg_stp -> st_name);
	printf("At line %d, sol_path_name contains '%s'\n",
		__LINE__, bu_vls_addr(&sol_path_name));
	sol = mk_solid(bu_vls_addr(&sol_path_name),
		    segp -> seg_in.hit_dist);
	printf("and segp -> seg_stp = %x\n", segp -> seg_stp);
	/*
	 *	Attempt to record the new solid.
	 *	If it shares its name with a previously recorded solid,
	 *	then retain the one that appears earlier on the ray.
	 */
	if (bu_rb_insert(solids, (void *) sol) < 0)
	{
	    old_sol = (struct sol_name_dist *)
			bu_rb_curr(solids, ORDER_BY_NAME);
	    BU_CKMAG(old_sol, SOL_NAME_DIST_MAGIC,
		"sol_name_dist structure");
	    if (sol -> dist >= old_sol -> dist)
		free_solid(sol, 1);
	    else
	    {
		bu_rb_delete(solids, ORDER_BY_NAME);
		bu_rb_insert(solids, sol);
		free_solid(old_sol, 1);
	    }
	}
    }
    printf("HELLO %s:%d\n", __FILE__, __LINE__);

    result = (char **)
		bu_malloc((solids -> rbt_nm_nodes + 1) * sizeof(char *),
			  "names of solids on ray");
    for (sol = (struct sol_name_dist *) bu_rb_min(solids, ORDER_BY_DISTANCE),
		i=0;
	 sol != NULL;
	 sol = (struct sol_name_dist *) bu_rb_succ(solids, ORDER_BY_DISTANCE),
		++i)
    {
	result[i] = sol -> name;
	free_solid(sol, 0);
    }
    result[i] = 0;
    ap -> a_uptr = (char *) result;

    bu_rb_free(solids, RB_RETAIN_DATA);
    return (1);
#endif
}
#endif

/*
 *			R P T _ H I T S _ M I K E
 *
 *  Each partition represents a segment, i.e. a single solid.
 *  Boolean operations have not been performed.
 *  The partition list is sorted by ascending inhit distance.
 *  This code does not attempt to eliminate duplicate segs,
 *  e.g. from piercing the torus twice.
 */
static int
rpt_hits_mike(struct application *ap, struct partition *PartHeadp, struct seg *segp)
{
	register struct partition	*pp;
	int		len;
	char		**list;
	int		i;

	len = rt_partition_len(PartHeadp) + 2;
	list = (char **)bu_calloc( len, sizeof(char *), "hit list[]");

	i = 0;
	for( pp = PartHeadp->pt_forw; pp != PartHeadp; pp = pp->pt_forw )  {
		RT_CK_PT(pp);
		list[i++] = db_path_to_string( &(pp->pt_inseg->seg_stp->st_path) );
	}
	list[i++] = NULL;
	if( i > len )  bu_exit(EXIT_FAILURE, "rpt_hits_mike: array overflow\n");

	ap->a_uptr = (genptr_t)list;
	return len;
}

/*
 *			R P T _ M I S S
 *
 *		Miss handler for use by rt_shootray().
 *
 *	Stuffs the address of a null string in ap->a_uptr and returns 0.
 */

static int
rpt_miss(struct application *ap)
{
	ap->a_uptr = NULL;

    return (0);
}

/*
 *		    S K E W E R _ S O L I D S
 *
 *	Fire a ray at some geometry and obtain a list of
 *	the solids encountered, sorted by first intersection.
 *
 *	The function has five parameters: the model and objects at which
 *	to fire (in an argc/argv pair) the origination point and direction
 *	for the ray, and a result-format specifier.  So long as it could
 *	find the objects in the model, skewer_solids() returns a null-
 *	terminated array of solid names.  Otherwise, it returns 0.  If
 *	full_path is nonzero, then the entire path for each solid is
 *	recorded.  Otherwise, only the basename is recorded.
 *
 *	N.B. - It is the caller's responsibility to free the array
 *	of solid names.
 */
char **skewer_solids (int argc, const char **argv, fastf_t *ray_orig, fastf_t *ray_dir, int full_path)
{
    struct application	ap;
    struct rt_i		*rtip;
    struct bu_list	sol_list;

	if (argc <= 0) {
		Tcl_AppendResult( interp, "skewer_solids argc<=0\n", (char *)NULL );
		return ((char **) 0);
	}

	/* .inmem rt_gettrees .rt -i -u [who] */
	rtip = rt_new_rti( dbip );
	rtip->useair = 1;
	rtip->rti_dont_instance = 1;	/* full paths to solids, too. */
	if (rt_gettrees(rtip, argc, argv, 1) == -1) {
		Tcl_AppendResult( interp, "rt_gettrees() failed\n", (char *)NULL );
		rt_clean(rtip);
		bu_free((genptr_t)rtip, "struct rt_i");
		return ((char **) 0);
	}

	/* .rt prep 1 */
	rtip->rti_hasty_prep = 1;
	rt_prep(rtip);

    BU_LIST_INIT(&sol_list);

    /*
     *	Initialize the application
     */
    RT_APPLICATION_INIT(&ap);
    ap.a_magic = RT_AP_MAGIC;
    ap.a_ray.magic = RT_RAY_MAGIC;
    ap.a_hit = rpt_hits_mike;
    ap.a_miss = rpt_miss;
    ap.a_resource = RESOURCE_NULL;
    ap.a_overlap = no_op;
    ap.a_onehit = 0;
    ap.a_user = 1;	/* Requests full paths to solids, not just basenames */
    ap.a_rt_i = rtip;
    ap.a_zero1 = ap.a_zero2 = 0;
    ap.a_purpose = "skewer_solids()";
    ap.a_no_booleans = 1;		/* full paths, no booleans */
    VMOVE(ap.a_ray.r_pt, ray_orig);
    VMOVE(ap.a_ray.r_dir, ray_dir);

    (void) rt_shootray(&ap);

	rt_clean(rtip);
	bu_free((genptr_t)rtip, "struct rt_i");

    return ((char **) ap.a_uptr);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.16
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.15 2007/11/21 20:38:23 erikgreenwald Exp $ (ARL)";
d179 1
a179 1
no_op(struct application *ap, struct partition *ph)
@


14.15
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.14 2007/11/21 19:49:12 erikgreenwald Exp $ (ARL)";
d129 1
a129 1
    (void) strcpy(sp -> name, name);
@


14.14
log
@exit->bu_exit where applicable
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.13 2007/11/21 15:52:58 erikgreenwald Exp $ (ARL)";
d237 1
a237 4
    {
	bu_log("%s: %d: bu_rb_create() bombed\n", __FILE__, __LINE__);
	bu_exit (1, "");
    }
@


14.13
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.12 2007/09/15 16:23:18 brlcad Exp $ (ARL)";
d239 1
a239 1
	exit (1);
@


14.12
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.11 2007/05/14 21:04:32 brlcad Exp $ (ARL)";
d480 1
a480 1
	if( i > len )  bu_bomb("rpt_hits_mike: array overflow\n");
@


14.11
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.10 2007/01/27 01:41:44 brlcad Exp $ (ARL)";
d44 1
a44 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.11.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.12 2007/09/15 16:23:18 brlcad Exp $ (ARL)";
d44 5
a48 1
#include <string.h>
@


14.10
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.9 2007/01/23 01:13:42 brlcad Exp $ (ARL)";
a53 1
#include "redblack.h"
d267 1
a267 1
    for (RT_LIST_FOR(pp, partition, (struct bu_list *) &ph -> pt_magic))
@


14.9
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.8 2007/01/20 14:36:58 brlcad Exp $ (ARL)";
d303 1
a303 1
        segp = (struct seg *)BU_PTBL_GET(&pp->pt_seglist, index);
@


14.8
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.7 2006/02/27 10:08:40 brlcad Exp $ (ARL)";
@


14.7
log
@stdlib.h and exit()
@
text
@d4 1
a4 1
 * Copyright (c) 1995-2006 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.6 2006/01/18 06:46:19 brlcad Exp $ (ARL)";
@


14.6
log
@update copyright to 2006
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.5 2005/12/08 01:34:05 brlcad Exp $ (ARL)";
d41 1
a41 2


d45 5
d61 1
@


14.5
log
@RT_APPLICATION_INIT and k&r -> ansi
@
text
@d4 1
a4 1
 * Copyright (C) 1995-2005 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.4 2005/10/23 04:44:37 brlcad Exp $ (ARL)";
@


14.4
log
@trailing ws
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (ARL)";
d84 1
a84 2
sol_comp_name(v1, v2)
void *v1, *v2;
d101 1
a101 2
sol_comp_dist(v1, v2)
void *v1, *v2;
d121 1
a121 3
mk_solid(name, dist)
char	*name;
fastf_t	dist;
d143 1
a143 4
free_solid(sol, free_name)
struct sol_name_dist	*sol;
int			free_name;

d156 1
a156 3
print_solid(vp, depth)
void	*vp;
int	depth;
d220 1
a220 4
rpt_solids(ap, ph, finished_segs)
struct application	*ap;
struct partition	*ph;
struct seg		*finished_segs;
d551 1
@


14.3
log
@update copyright to 2005
@
text
@d30 1
a30 1
 *  
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/solids_on_ray.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (ARL)";
d85 1
a85 1
void *v1, *v2;    
d103 1
a103 1
void *v1, *v2;    
d282 1
a282 1
	
d408 1
a408 1
	
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d30 1
a30 1
 *
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d85 1
a85 1
void *v1, *v2;
d103 1
a103 1
void *v1, *v2;
d282 1
a282 1

d408 1
a408 1

@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1995-2004 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/solids_on_ray.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *		S O L I D S _ O N _ R A Y . C
a33 9
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/solids_on_ray.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (ARL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/solids_on_ray.c,v 1.2 2004/06/08 22:04:29 morrison Exp $ (ARL)";
d575 10
@


1.2
log
@obliterate externs.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d29 1
a29 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/solids_on_ray.c,v 1.37 2004/05/10 15:30:48 erikg Exp $ (ARL)";
a44 1
#include "externs.h"
@

