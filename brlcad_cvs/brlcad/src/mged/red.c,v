head	14.22;
access;
symbols
	rel-7-10-4:14.16.2.1
	STABLE:14.16.0.2
	stable-branch:14.3
	rel-7-10-2:14.16
	rel-7-10-0:14.15
	rel-7-8-4:14.9
	rel-7-8-2:14.8
	rel-7-8-0:14.8
	trimnurbs-branch:14.8.0.2
	help:14.8
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.6
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.22
date	2007.12.14.13.05.26;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.12.02.22.34.23;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.09.25.04.30.58;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.09.25.04.12.04;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.09.25.03.43.48;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.17;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.07.26.01.13.58;	author brlcad;	state Exp;
branches
	14.16.2.1;
next	14.15;

14.15
date	2007.01.23.01.13.42;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.18.16.51.07;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.18.16.37.05;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.18.16.24.58;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.11.05.02.26.15;	author johnranderson;	state Exp;
branches;
next	14.9;

14.9
date	2006.07.09.19.17.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.28.00.36.29;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.31.07.30.58;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.05.28.02.14.52;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.29;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.27;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.18;	author brlcad;	state Exp;
branches;
next	;

14.16.2.1
date	2007.09.28.14.04.35;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.22
log
@use bu_temp_file() instead of mktemp/mkstemp for better generalized temp file management.  fixes directory assumptions and cleans up temp file creation some
@
text
@/*                           R E D . C
 * BRL-CAD
 *
 * Copyright (c) 1992-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file red.c
 *
 *	These routines allow editing of a combination using the text editor
 *	of the users choice.
 *
 *  Author -
 *	John Anderson
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.21 2007/12/02 22:34:23 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "db.h"

#include "./ged.h"
#include "./sedit.h"

extern int cmd_name(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static char	red_tmpfil[MAXPATHLEN] = {0};
static char	red_tmpcomb[17];
static char	*red_tmpcomb_init = "red_tmp.aXXXXXX";
static char	delims[] = " \t/";	/* allowable delimiters */


HIDDEN char *
find_keyword(int i, char *line, char *word)
{
    char *ptr1;
    char *ptr2;
    int j;

    /* find the keyword */
    ptr1 = strstr( &line[i], word );
    if( !ptr1 )
	return( (char *)NULL );

    /* find the '=' */
    ptr2 = strchr( ptr1, '=' );
    if( !ptr2 )
	return( (char *)NULL );

    /* skip any white space before the value */
    while( isspace( *(++ptr2) ) );

    /* eliminate trailing white space */
    j = strlen( line );
    while( isspace( line[--j] ) );
    line[j+1] = '\0';

    /* return pointer to the value */
    return( ptr2 );
}

HIDDEN void
print_matrix(FILE *fp, matp_t matrix)
{
    int k;
    char buf[64];
    fastf_t tmp;

    if( !matrix )
	return;

    for( k=0 ; k<16 ; k++ ) {
	sprintf( buf, "%g", matrix[k] );
	tmp = atof( buf );
	if( tmp == matrix[k] )
	    fprintf( fp, " %g", matrix[k] );
	else
	    fprintf( fp, " %.12e", matrix[k] );
	if ((k&3)==3) fputc(' ', fp);
    }
}

HIDDEN void
vls_print_matrix(struct bu_vls *vls, matp_t matrix)
{
    int k;
    char buf[64];
    fastf_t tmp;

    if(!matrix)
	return;

    if(bn_mat_is_identity(matrix))
	return;

    for(k=0; k<16; k++){
	sprintf(buf, "%g", matrix[k]);
	tmp = atof(buf);
	if(tmp == matrix[k])
	    bu_vls_printf(vls, " %g", matrix[k]);
	else
	    bu_vls_printf(vls, " %.12e", matrix[k]);
	if ((k&3)==3) bu_vls_printf(vls, " ");
    }
}

void
put_rgb_into_comb(struct rt_comb_internal *comb, char *str)
{
    int r, g, b;

    if(sscanf(str, "%d%d%d", &r, &g, &b) != 3){
	comb->rgb_valid = 0;
	return;
    }

    /* clamp the RGB values to [0,255] */
    if(r < 0)
	r = 0;
    else if(r > 255)
	r = 255;

    if(g < 0)
	g = 0;
    else if(g > 255)
	g = 255;

    if(b < 0)
	b = 0;
    else if(b > 255)
	b = 255;

    comb->rgb[0] = (unsigned char)r;
    comb->rgb[1] = (unsigned char)g;
    comb->rgb[2] = (unsigned char)b;
    comb->rgb_valid = 1;
}

struct line_list{
    struct bu_list l;
    char *line;
};

struct line_list HeadLines;

HIDDEN int
count_nodes(char *line)
{
    char *ptr;
    char *name;
    char relation;
    int node_count=0;

    /* sanity */
    if (line == NULL)
	return 0;

    ptr = strtok(line , delims);

    while (ptr) {
	/* First non-white is the relation operator */
	relation = (*ptr);

	if (relation != '+' && relation != 'u' && relation != '-') {
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, " %c is not a legal operator\n" , relation );
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	    return( -1 );
	}

	/* Next must be the member name */
	name = strtok((char *)NULL, delims);

	if (name == NULL) {
	    Tcl_AppendResult(interp, " operand name missing\n", (char *)NULL);
	    return( -1 );
	}

	ptr = strtok( (char *)NULL, delims );
	/*
	 * If this token is not a boolean operator, then it must be the start
	 * of a matrix which we will skip.
	 */
	if (ptr && !((*ptr == 'u' || *ptr == '-' || *ptr=='+') &&
		     *(ptr+1) == '\0')) {
	    int k;

	    /* skip past matrix, k=1 because we already have the first value */
	    for (k=1 ; k<16 ; k++) {
		ptr = strtok( (char *)NULL, delims );
		if (!ptr) {
		    Tcl_AppendResult(interp, "expecting a matrix\n", (char *)NULL);
		    return( -1 );
		}
	    }

	    /* get the next relational operator on the current line */
	    ptr = strtok( (char *)NULL, delims );
	}

	node_count++;
    }

    return node_count;
}

static int
make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index)
{
    struct rt_db_internal	intern;
    union tree		*final_tree;

    if (tree_index)
	final_tree = (union tree *)db_mkgift_tree( rt_tree_array, node_count, &rt_uniresource );
    else
	final_tree = (union tree *)NULL;

    RT_INIT_DB_INTERNAL(&intern);
    intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
    intern.idb_type = ID_COMBINATION;
    intern.idb_meth = &rt_functab[ID_COMBINATION];
    intern.idb_ptr = (genptr_t)comb;
    comb->tree = final_tree;

    if (strcmp(new_name, old_name)) {
	int flags;

	if (comb->region_flag)
	    flags = DIR_COMB | DIR_REGION;
	else
	    flags = DIR_COMB;

	if (dp != DIR_NULL) {
	    if (db_delete(dbip, dp) || db_dirdelete(dbip, dp)) {
		Tcl_AppendResult(interp, "ERROR: Unable to delete directory entry for ",
				 old_name, "\n", (char *)NULL);
		rt_comb_ifree(&intern, &rt_uniresource);
		return(1);
	    }
	}

	if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
	    Tcl_AppendResult(interp, "Cannot add ", new_name,
			     " to directory, no changes made\n", (char *)NULL);
	    rt_comb_ifree(&intern, &rt_uniresource);
	    return(1);
	}
    } else if( dp == DIR_NULL ) {
	int flags;

	if (comb->region_flag)
	    flags = DIR_COMB | DIR_REGION;
	else
	    flags = DIR_COMB;

	if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
	    Tcl_AppendResult(interp, "Cannot add ", new_name,
			     " to directory, no changes made\n", (char *)NULL);
	    rt_comb_ifree( &intern, &rt_uniresource );
	    return(1);
	}
    } else {
	if (comb->region_flag)
	    dp->d_flags |= DIR_REGION;
	else
	    dp->d_flags &= ~DIR_REGION;
    }

    if (rt_db_put_internal(dp, dbip, &intern, &rt_uniresource) < 0) {
	Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
	return 1;
    }

    return(0);
}


HIDDEN int
put_tree_into_comb(struct rt_comb_internal *comb, struct directory *dp, char *old_name, char *new_name, char *str)
{
    int			i;
    int			done;
    char			*line;
    char			*ptr;
    char			relation;
    char			*name;
    struct rt_tree_array	*rt_tree_array;
    struct line_list	*llp;
    int			node_count = 0;
    int			tree_index = 0;
    union tree		*tp;
    matp_t			matrix;
    struct bu_vls		vls;
    int			result;

    if (str == (char *)NULL)
	return TCL_ERROR;

    BU_LIST_INIT(&HeadLines.l);

    /* break str into lines */
    line = str;
    ptr = strchr(str, '\n');
    if (ptr != NULL)
	*ptr = '\0';
    bu_vls_init(&vls);
    while (line != (char *)NULL) {
	int n;

	bu_vls_strcpy(&vls, line);

	if ((n = count_nodes(bu_vls_addr(&vls))) < 0) {
	    bu_vls_free(&vls);
	    bu_list_free(&HeadLines.l);
	    return TCL_ERROR;
	} else if (n > 0) {
	    BU_GETSTRUCT(llp, line_list);
	    BU_LIST_INSERT(&HeadLines.l, &llp->l);
	    llp->line = line;

	    node_count += n;
	} /* else blank line */

	if (ptr != NULL && *(ptr+1) != '\0') {
	    /* leap frog past EOS */
	    line = ptr + 1;

	    ptr = strchr(line, '\n');
	    if (ptr != NULL)
		*ptr = '\0';
	} else {
	    line = NULL;
	}
    }
    bu_vls_free(&vls);

    /* build tree list */
    if (node_count)
	rt_tree_array = (struct rt_tree_array *)bu_calloc(node_count, sizeof(struct rt_tree_array), "tree list" );
    else
	rt_tree_array = (struct rt_tree_array *)NULL;

    for (BU_LIST_FOR(llp, line_list, &HeadLines.l)) {
	done = 0;
	ptr = strtok(llp->line, delims);
	while (!done) {
	    if (!ptr)
		break;

	    /* First non-white is the relation operator */
	    relation = (*ptr);
	    if (relation == '\0')
		break;

	    /* Next must be the member name */
	    ptr = strtok((char *)NULL, delims);
	    if (ptr == (char *)NULL) {
		bu_list_free(&HeadLines.l);
		if (rt_tree_array)
		    bu_free((char *)rt_tree_array, "red: tree list");
		bu_log("no name specified\n");
		return TCL_ERROR;
	    }
	    name = ptr;

	    /* Eliminate trailing white space from name */
	    i = strlen( ptr );
	    while(isspace(name[--i]))
		name[i] = '\0';

	    /* Check for existence of member */
	    if ((db_lookup(dbip , name , LOOKUP_QUIET)) == DIR_NULL)
		bu_log("\tWARNING: ' %s ' does not exist\n", name);

	    /* get matrix */
	    ptr = strtok((char *)NULL, delims);
	    if (ptr == (char *)NULL) {
		matrix = (matp_t)NULL;
		done = 1;
	    } else if (*ptr == 'u' ||
		       (*ptr == '-' && *(ptr+1) == '\0') ||
		       (*ptr == '+' && *(ptr+1) == '\0')) {
		/* assume another relational operator */
		matrix = (matp_t)NULL;
	    } else {
		int k;

		matrix = (matp_t)bu_calloc(16, sizeof(fastf_t), "red: matrix");
		matrix[0] = atof(ptr);
		for (k=1 ; k<16 ; k++) {
		    ptr = strtok((char *)NULL, delims);
		    if (!ptr) {
			bu_log("incomplete matrix for member %s - No changes made\n", name);
			bu_free( (char *)matrix, "red: matrix" );
			if(rt_tree_array)
			    bu_free((char *)rt_tree_array, "red: tree list");
			bu_list_free(&HeadLines.l);
			return TCL_ERROR;
		    }
		    matrix[k] = atof( ptr );
		}
		if (bn_mat_is_identity( matrix )) {
		    bu_free((char *)matrix, "red: matrix");
		    matrix = (matp_t)NULL;
		}

		ptr = strtok((char *)NULL, delims);
		if (ptr == (char *)NULL)
		    done = 1;
	    }

	    /* Add it to the combination */
	    switch (relation) {
		case '+':
		    rt_tree_array[tree_index].tl_op = OP_INTERSECT;
		    break;
		case '-':
		    rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
		    break;
		default:
		    bu_log("unrecognized relation (assume UNION)\n");
		case 'u':
		    rt_tree_array[tree_index].tl_op = OP_UNION;
		    break;
	    }

	    BU_GETUNION(tp, tree);
	    rt_tree_array[tree_index].tl_tree = tp;
	    tp->tr_l.magic = RT_TREE_MAGIC;
	    tp->tr_l.tl_op = OP_DB_LEAF;
	    tp->tr_l.tl_name = bu_strdup( name );
	    tp->tr_l.tl_mat = matrix;
	    tree_index++;
	}
    }

    bu_list_free(&HeadLines.l);
    result = make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index);
    if (result == 0)
	return TCL_OK;
    else
	return TCL_ERROR;
}

int
cmd_get_comb(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
    struct directory *dp;
    struct rt_db_internal	intern;
    struct rt_comb_internal *comb;
    struct rt_tree_array	*rt_tree_array;
    int i;
    int node_count;
    int actual_count;
    struct bu_vls vls;

    CHECK_DBI_NULL;
    CHECK_READ_ONLY;

    bu_vls_init(&vls);

    if (argc != 2) {
	bu_vls_printf(&vls, "helpdevel get_comb");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    dp = db_lookup(dbip , argv[1] , LOOKUP_QUIET);

    if (dp != DIR_NULL) {
	if (!(dp->d_flags & DIR_COMB)) {
	    Tcl_AppendResult(interp, argv[1],
			     " is not a combination, so cannot be edited this way\n", (char *)NULL);
	    return TCL_ERROR;
	}

	if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
	    TCL_READ_ERR_return;

	comb = (struct rt_comb_internal *)intern.idb_ptr;

	if (comb->tree && db_ck_v4gift_tree(comb->tree) < 0) {
	    db_non_union_push(comb->tree, &rt_uniresource);
	    if (db_ck_v4gift_tree(comb->tree) < 0) {
		Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL);
		return TCL_ERROR;
	    }
	}

	node_count = db_tree_nleaves(comb->tree);
	if (node_count > 0) {
	    rt_tree_array = (struct rt_tree_array *)bu_calloc(node_count,
							      sizeof(struct rt_tree_array),
							      "tree list");
	    actual_count = (struct rt_tree_array *)db_flatten_tree(rt_tree_array,
								   comb->tree,
								   OP_UNION,
								   1,
								   &rt_uniresource) - rt_tree_array;
	    BU_ASSERT_LONG(actual_count, ==, node_count);
	    comb->tree = TREE_NULL;
	} else {
	    rt_tree_array = (struct rt_tree_array *)NULL;
	    actual_count = 0;
	}

	Tcl_AppendElement(interp, dp->d_namep);                 /* NAME=name */
	if (comb->region_flag) {
	    Tcl_AppendElement(interp, "Yes");              /* REGION=Yes */
	    bu_vls_trunc(&vls, 0);
	    bu_vls_printf(&vls, "%d", comb->region_id );
	    Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* REGION_ID=comb->region_id */
	    bu_vls_trunc(&vls, 0);
	    bu_vls_printf(&vls, "%d", comb->aircode);
	    Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* AIRCODE=comb->aircode */
	    bu_vls_trunc(&vls, 0);
	    bu_vls_printf(&vls, "%d", comb->GIFTmater);
	    Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* GIFT_MATERIAL=comb->GIFTmater */
	    bu_vls_trunc(&vls, 0);
	    bu_vls_printf(&vls, "%d", comb->los );
	    Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* LOS=comb->los */
	} else {
	    Tcl_AppendElement(interp, "No");   /* REGION=No */
	}

	if (comb->rgb_valid) {
	    bu_vls_trunc(&vls, 0);
	    bu_vls_printf(&vls, "%d %d %d", V3ARGS(comb->rgb));
	    Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* COLOR=comb->rgb */
	} else
	    Tcl_AppendElement(interp, "");                 /* COLOR="" */

	Tcl_AppendElement(interp, bu_vls_addr(&comb->shader)); /* SHADER=comb->shader */

	if (comb->inherit)
	    Tcl_AppendElement(interp, "Yes");  /* INHERIT=Yes */
	else
	    Tcl_AppendElement(interp, "No");   /* INHERIT=No  */


	bu_vls_trunc(&vls, 0);
	for (i = 0 ; i < actual_count ; i++) {
	    char op;

	    switch (rt_tree_array[i].tl_op) {
		case OP_UNION:
		    op = 'u';
		    break;
		case OP_INTERSECT:
		    op = '+';
		    break;
		case OP_SUBTRACT:
		    op = '-';
		    break;
		default:
		    Tcl_AppendResult(interp, "Illegal op code in tree\n",
				     (char *)NULL);
		    bu_vls_free(&vls);

		    return TCL_ERROR;
	    }

	    bu_vls_printf(&vls, " %c %s\t" , op , rt_tree_array[i].tl_tree->tr_l.tl_name);
	    vls_print_matrix(&vls, rt_tree_array[i].tl_tree->tr_l.tl_mat);
	    bu_vls_printf(&vls, "\n");
	    db_free_tree(rt_tree_array[i].tl_tree, &rt_uniresource);
	}

	Tcl_AppendElement(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_OK;
    } else {
	Tcl_AppendElement(interp, argv[1]); /* NAME=argv[1] */
	Tcl_AppendElement(interp, "Yes");    /* REGION=Yes */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%d", item_default);
	Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* REGION_ID=item_default */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%d", air_default);
	Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* AIRCODE=air_default */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%d", mat_default);
	Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* GIFT_MATERIAL=mat_default */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%d", los_default);
	Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* LOS=los_default */
	Tcl_AppendElement(interp, "");      /* COLOR=""         */
	Tcl_AppendElement(interp, "");      /* SHADER=""        */
	Tcl_AppendElement(interp, "No");    /* INHERIT=No       */
	Tcl_AppendElement(interp, "");      /* COMBINATION:""   */
	bu_vls_free(&vls);

	return TCL_RETURN;
    }
}


int
writecomb( const struct rt_comb_internal *comb, const char *name )
{
    /*	Writes the file for later editing */
    struct rt_tree_array	*rt_tree_array;
    FILE			*fp;
    int			i;
    int			node_count;
    int			actual_count;

    if( comb )
	RT_CK_COMB( comb );

    /* open the file */
    if( (fp=fopen( red_tmpfil , "w" )) == NULL ) {
	perror( "MGED" );
	Tcl_AppendResult(interp, "Cannot open temporary file for writing\n", (char *)NULL);
	return(1);
    }

    if( !comb )	{
	fprintf( fp, "NAME=%s\n", name );
	fprintf( fp, "REGION=No\n" );
	fprintf( fp, "REGION_ID=\n" );
	fprintf( fp, "AIRCODE=\n" );
	fprintf( fp, "GIFT_MATERIAL=\n" );
	fprintf( fp, "LOS=\n" );
	fprintf( fp, "COLOR=\n" );
	fprintf( fp, "SHADER=\n" );
	fprintf( fp, "INHERIT=No\n" );
	fprintf( fp, "COMBINATION:\n" );
	fclose( fp );
	return( 0 );
    }

    if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 ) {
	db_non_union_push( comb->tree, &rt_uniresource );
	if( db_ck_v4gift_tree( comb->tree ) < 0 ) {
	    Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL );
	    return( 1 );
	}
    }
    node_count = db_tree_nleaves( comb->tree );
    if( node_count > 0 ) {
	rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count,
							   sizeof( struct rt_tree_array ), "tree list" );
	actual_count = (struct rt_tree_array *)db_flatten_tree(
							       rt_tree_array, comb->tree, OP_UNION,
							       0, &rt_uniresource ) - rt_tree_array;
	BU_ASSERT_LONG( actual_count, ==, node_count );
    } else {
	rt_tree_array = (struct rt_tree_array *)NULL;
	actual_count = 0;
    }

    fprintf( fp, "NAME=%s\n", name );
    if( comb->region_flag ) {
	fprintf( fp, "REGION=Yes\n" );
	fprintf( fp, "REGION_ID=%d\n", comb->region_id );
	fprintf( fp, "AIRCODE=%d\n", comb->aircode );
	fprintf( fp, "GIFT_MATERIAL=%d\n", comb->GIFTmater );
	fprintf( fp, "LOS=%d\n", comb->los );
    } else {
	fprintf( fp, "REGION=No\n" );
	fprintf( fp, "REGION_ID=\n" );
	fprintf( fp, "AIRCODE=\n" );
	fprintf( fp, "GIFT_MATERIAL=\n" );
	fprintf( fp, "LOS=\n" );
    }

    if( comb->rgb_valid )
	fprintf( fp, "COLOR= %d %d %d\n", V3ARGS( comb->rgb ) );
    else
	fprintf( fp, "COLOR=\n" );

    fprintf( fp, "SHADER=%s\n", bu_vls_addr( &comb->shader ) );
#if 0
    fprintf( fp, "MATERIAL=%s\n", bu_vls_addr( &comb->material ) );
#endif
    if( comb->inherit )
	fprintf( fp, "INHERIT=Yes\n" );
    else
	fprintf( fp, "INHERIT=No\n" );

    fprintf( fp, "COMBINATION:\n" );

    for( i=0 ; i<actual_count ; i++ ) {
	char op;

	switch( rt_tree_array[i].tl_op ) {
	    case OP_UNION:
		op = 'u';
		break;
	    case OP_INTERSECT:
		op = '+';
		break;
	    case OP_SUBTRACT:
		op = '-';
		break;
	    default:
		Tcl_AppendResult(interp, "Illegal op code in tree\n",
				 (char *)NULL );
		fclose( fp );
		return( 1 );
	}
	if( fprintf( fp , " %c %s" , op , rt_tree_array[i].tl_tree->tr_l.tl_name ) <= 0 ) {
	    Tcl_AppendResult(interp, "Cannot write to temporary file (", red_tmpfil, "). Aborting edit\n", (char *)NULL );
	    fclose( fp );
	    return( 1 );
	}
	print_matrix( fp, rt_tree_array[i].tl_tree->tr_l.tl_mat );
	fprintf( fp, "\n" );
    }
    fclose( fp );
    return( 0 );
}

int
checkcomb(void)
{
    /*	Do some minor checking of the edited file */

    FILE *fp;
    int node_count=0;
    int nonsubs=0;
    int i,j,done,ch;
    int done2,first;
    char relation;
    char name_v4[NAMESIZE+1];
    char *name_v5=NULL;
    char *name=NULL;
    char line[RT_MAXLINE] = {0};
    char lineCopy[RT_MAXLINE] = {0};
    char *ptr = (char *)NULL;
    int region=(-1);
    int id=0,air=0;
    int rgb_valid;

    if( (fp=fopen( red_tmpfil , "r" )) == NULL ) {
	perror( "MGED" );
	Tcl_AppendResult(interp, "Cannot open temporary file for reading\n", (char *)NULL);
	return(-1);
    }

    /* Read a line at a time */
    done = 0;
    while( !done ) {
	/* Read a line */
	i = (-1);

	while( (ch=getc( fp )) != EOF && ch != '\n' && i < RT_MAXLINE )
	    line[++i] = ch;

	if( ch == EOF ) {
	    /* We must be done */
	    done = 1;
	    if( i < 0 )
		break;
	}
	if( i == RT_MAXLINE ) {
	    line[RT_MAXLINE-1] = '\0';
	    Tcl_AppendResult(interp, "Line too long in edited file:\n",
			     line, "\n", (char *)NULL);
	    fclose( fp );
	    return( -1 );
	}

	line[++i] = '\0';
	strncpy( lineCopy, line, RT_MAXLINE-1 );

	/* skip leading white space */
	i = (-1);
	while( isspace( line[++i] ));

	if( line[i] == '\0' )
	    continue;	/* blank line */

	if( (ptr=find_keyword(i, line, "NAME" ) ) ) {
	    if( dbip->dbi_version < 5 ) {
		int len;

		len = strlen( ptr );
		if( len >= NAMESIZE ) {
		    while( len > 1 && isspace( ptr[len-1] ) )
			len--;
		}
		if( len >= NAMESIZE ) {
		    Tcl_AppendResult(interp, "Name too long for v4 database: ",
				     ptr, "\n", lineCopy, "\n", (char *)NULL );
		    fclose( fp );
		    return( -1 );
		}
	    }
	    continue;
	} else if( (ptr=find_keyword( i, line, "REGION_ID" ) ) ) {
	    id = atoi( ptr );
	    continue;
	} else if( (ptr=find_keyword( i, line, "REGION" ) ) ) {
	    if( *ptr == 'y' || *ptr == 'Y' )
		region = 1;
	    else
		region = 0;
	    continue;
	} else if( (ptr=find_keyword( i, line, "AIRCODE" ) ) ) {
	    air = atoi( ptr );
	    continue;
	} else if( (ptr=find_keyword( i, line, "GIFT_MATERIAL" ) ) ) {
	    continue;
	} else if( (ptr=find_keyword( i, line, "LOS" ) ) ) {
	    continue;
	} else if( (ptr=find_keyword( i, line, "COLOR" ) ) ) {
	    char *ptr2;

	    rgb_valid = 1;
	    ptr2 = strtok( ptr, delims );
	    if( !ptr2 ) {
		continue;
	    } else {
		ptr2 = strtok( (char *)NULL, delims );
		if( !ptr2 ) {
		    rgb_valid = 0;
		} else {
		    ptr2 = strtok( (char *)NULL, delims );
		    if( !ptr2 ) {
			rgb_valid = 0;
		    }
		}
	    }
	    if( !rgb_valid ) {
		Tcl_AppendResult(interp, "WARNING: invalid color specification!!! Must be three integers, each 0-255\n", (char *)NULL );
	    }
	    continue;
	} else if( (ptr=find_keyword( i, line, "SHADER" ) ) )
	    continue;
#if 0
	else if( (ptr=find_keyword( i, line, "MATERIAL" ) ) )
	    continue;
#endif
	else if( (ptr=find_keyword( i, line, "INHERIT" ) ) )
	    continue;
	else if( !strncmp( &line[i], "COMBINATION:", 12 ) ) {
	    if( region < 0 ) {
		Tcl_AppendResult(interp, "Region flag not correctly set\n",
				 "\tMust be 'Yes' or 'No'\n", "\tNo Changes made\n",
				 (char *)NULL );
		fclose( fp );
		return( -1 );
	    } else if( region ) {
		if( id < 0 ) {
		    Tcl_AppendResult(interp, "invalid region ID\n",
				     "\tNo Changes made\n",
				     (char *)NULL );
		    fclose( fp );
		    return( -1 );
		}
		if( air < 0 ) {
		    Tcl_AppendResult(interp, "invalid Air code\n",
				     "\tNo Changes made\n",
				     (char *)NULL );
		    fclose( fp );
		    return( -1 );
		}
		if( air == 0 && id == 0 )
		    Tcl_AppendResult(interp, "Warning: both ID and Air codes are 0!!!\n", (char *)NULL );
		if( air && id )
		    Tcl_AppendResult(interp, "Warning: both ID and Air codes are non-zero!!!\n", (char *)NULL );
	    }
	    continue;
	}

	done2=0;
	first=1;
	ptr = strtok( line , delims );

	while (!done2) {
	    if( name_v5 ) {
		bu_free( name_v5, "name_v5" );
		name_v5 = NULL;
	    }
	    /* First non-white is the relation operator */
	    if( !ptr ) {
		done2 = 1;
		break;
	    }

	    relation = (*ptr);
	    if( relation == '\0' ) {
		if (first)
		    done = 1;

		done2 = 1;
		break;
	    }
	    first = 0;

	    /* Next must be the member name */
	    ptr = strtok( (char *)NULL, delims );
	    name = NULL;
	    if( ptr != NULL && *ptr != '\0' ) {
		if( dbip->dbi_version < 5 ) {
		    strncpy( name_v4 , ptr , NAMESIZE );
		    name_v4[NAMESIZE] = '\0';

		    /* Eliminate trailing white space from name */
		    j = NAMESIZE;
		    while( isspace( name_v4[--j] ) )
			name_v4[j] = '\0';
		    name = name_v4;
		} else {
		    int len;

		    len = strlen( ptr );
		    name_v5 = (char *)bu_malloc( len + 1, "name_v5" );
		    strncpy( name_v5, ptr, len );
		    while( isspace( name_v5[len-1] ) ) {
			len--;
			name_v5[len] = '\0';
		    }
		    name = name_v5;
		}
	    }

	    if( relation != '+' && relation != 'u' && relation != '-' ) {
		struct bu_vls tmp_vls;

		bu_vls_init(&tmp_vls);
		bu_vls_printf(&tmp_vls, " %c is not a legal operator\n" , relation );
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), lineCopy,
				 "\n", (char *)NULL);
		bu_vls_free(&tmp_vls);
		fclose( fp );
		if( dbip->dbi_version >= 5 && name_v5 )
		    bu_free( name_v5, "name_v5" );
		return( -1 );
	    }

	    if( relation != '-' )
		nonsubs++;

	    if( name == NULL || name[0] == '\0' ) {
		Tcl_AppendResult(interp, " operand name missing\n",
				 lineCopy, "\n", (char *)NULL);
		fclose( fp );
		if( dbip->dbi_version >= 5 && name_v5 )
		    bu_free( name_v5, "name_v5" );
		return( -1 );
	    }

	    ptr = strtok( (char *)NULL, delims );
	    if( !ptr )
		done2 = 1;
	    else if(*ptr != 'u' &&
		    (*ptr != '-' || *(ptr+1) != '\0') &&
		    (*ptr != '+' || *(ptr+1) != '\0')) {
		int k;

		/* skip past matrix */
		for( k=1 ; k<16 ; k++ ) {
		    ptr = strtok( (char *)NULL, delims );
		    if( !ptr) {
			Tcl_AppendResult(interp, "incomplete matrix\n",
					 lineCopy, "\n", (char *)NULL);
			fclose( fp );
			if( dbip->dbi_version >= 5 && name_v5 )
			    bu_free( name_v5, "name_v5" );
			return( -1 );
		    }
		}

		/* get the next relational operator on the current line */
		ptr = strtok( (char *)NULL, delims );
	    }

	    node_count++;
	}
    }

    if( dbip->dbi_version >= 5 && name_v5 )
	bu_free( name_v5, "name_v5" );

    fclose( fp );

    if( nonsubs == 0 && node_count ) {
	Tcl_AppendResult(interp, "Cannot create a combination with all subtraction operators\n",
			 (char *)NULL);
	return( -1 );
    }
    return( node_count );
}


int build_comb(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name)
{
    /*	Build the new combination by adding to the recently emptied combination
	This keeps combo info associated with this combo intact */

    FILE *fp;
    char relation;
    char *name=NULL, *new_name;
    char name_v4[NAMESIZE+1];
    char new_name_v4[NAMESIZE+1];
    char line[RT_MAXLINE] = {0};
    char *ptr;
    int ch;
    int i;
    int done=0;
    int done2;
    struct rt_tree_array *rt_tree_array;
    int tree_index=0;
    union tree *tp;
    matp_t matrix;
    int ret=0;

    if(dbip == DBI_NULL)
	return 0;

    if( comb ) {
	RT_CK_COMB( comb );
	RT_CK_DIR( dp );
    }

    if( (fp=fopen( red_tmpfil , "r" )) == NULL ) {
	Tcl_AppendResult(interp, " Cannot open edited file: ", red_tmpfil, "\n", (char *)NULL);
	return( 1 );
    }

    /* empty the existing combination */
    if( comb && comb->tree ) {
	db_free_tree( comb->tree, &rt_uniresource );
	comb->tree = NULL;
    } else {
	/* make an empty combination structure */
	BU_GETSTRUCT( comb, rt_comb_internal );
	comb->magic = RT_COMB_MAGIC;
	comb->tree = TREE_NULL;
	bu_vls_init( &comb->shader );
	bu_vls_init( &comb->material );
    }

    /* build tree list */
    if( node_count )
	rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count , sizeof( struct rt_tree_array ) , "tree list" );
    else
	rt_tree_array = (struct rt_tree_array *)NULL;

    if( dbip->dbi_version < 5 ) {
	if( dp == DIR_NULL )
	    NAMEMOVE( old_name, new_name_v4 );
	else
	    NAMEMOVE( dp->d_namep, new_name_v4 );
	new_name = new_name_v4;
    } else {
	if( dp == DIR_NULL )
	    new_name = bu_strdup( old_name );
	else
	    new_name = bu_strdup( dp->d_namep );
    }

    /* Read edited file */
    while( !done ) {
	/* Read a line */
	i = (-1);

	while( (ch=getc( fp )) != EOF && ch != '\n' && i < RT_MAXLINE )
	    line[++i] = ch;

	if( ch == EOF ) {
	    /* We must be done */
	    done = 1;
	    if( i < 0 )
		break;
	}

	line[++i] = '\0';

	/* skip leading white space */
	i = (-1);
	while( isspace( line[++i] ));

	if( line[i] == '\0' )
	    continue;	/* blank line */

	if( (ptr=find_keyword(i, line, "NAME" ) ) ) {
	    if( dbip->dbi_version < 5 )
		NAMEMOVE( ptr, new_name_v4 );
	    else {
		bu_free( new_name, "new_name" );
		new_name = bu_strdup( ptr );
	    }
	    continue;
	} else if( (ptr=find_keyword( i, line, "REGION_ID" ) ) ) {
	    comb->region_id = atoi( ptr );
	    continue;
	} else if( (ptr=find_keyword( i, line, "REGION" ) ) ) {
	    if( *ptr == 'y' || *ptr == 'Y' )
		comb->region_flag = 1;
	    else
		comb->region_flag = 0;
	    continue;
	} else if( (ptr=find_keyword( i, line, "AIRCODE" ) ) ) {
	    comb->aircode = atoi( ptr );
	    continue;
	} else if( (ptr=find_keyword( i, line, "GIFT_MATERIAL" ) ) ) {
	    comb->GIFTmater = atoi( ptr );
	    continue;
	} else if( (ptr=find_keyword( i, line, "LOS" ) ) ) {
	    comb->los = atoi( ptr );
	    continue;
	} else if( (ptr=find_keyword( i, line, "COLOR" ) ) ) {
	    char *ptr2;
	    int value;

	    ptr2 = strtok( ptr, delims );
	    if( !ptr2 ) {
		comb->rgb_valid = 0;
		continue;
	    }
	    value = atoi( ptr2 );
	    if( value < 0 ) {
		Tcl_AppendResult(interp, "Red value less than 0, assuming 0\n", (char *)NULL );
		value = 0;
	    }
	    if( value > 255 ) {
		Tcl_AppendResult(interp, "Red value greater than 255, assuming 255\n", (char *)NULL );
		value = 255;
	    }
	    comb->rgb[0] = value;
	    ptr2 = strtok( (char *)NULL, delims );
	    if( !ptr2 ) {
		Tcl_AppendResult(interp, "Invalid RGB value\n", (char *)NULL );
		comb->rgb_valid = 0;
		continue;
	    }
	    value = atoi( ptr2 );
	    if( value < 0 ) {
		Tcl_AppendResult(interp, "Green value less than 0, assuming 0\n", (char *)NULL );
		value = 0;
	    }
	    if( value > 255 ) {
		Tcl_AppendResult(interp, "Green value greater than 255, assuming 255\n", (char *)NULL );
		value = 255;
	    }
	    comb->rgb[1] = value;
	    ptr2 = strtok( (char *)NULL, delims );
	    if( !ptr2 ) {
		Tcl_AppendResult(interp, "Invalid RGB value\n", (char *)NULL );
		comb->rgb_valid = 0;
		continue;
	    }
	    value = atoi( ptr2 );
	    if( value < 0 ) {
		Tcl_AppendResult(interp, "Blue value less than 0, assuming 0\n", (char *)NULL );
		value = 0;
	    }
	    if( value > 255 ) {
		Tcl_AppendResult(interp, "Blue value greater than 255, assuming 255\n", (char *)NULL );
		value = 255;
	    }
	    comb->rgb[2] = value;
	    comb->rgb_valid = 1;
	    continue;
	} else if( (ptr=find_keyword( i, line, "SHADER" ) ) ) {
	    bu_vls_strcpy( &comb->shader,  ptr );
	    continue;
	}
#if 0
	else if( (ptr=find_keyword( i, line, "MATERIAL" ) ) ) {
	    bu_vls_strcpy( &comb->material,  ptr );
	    continue;
	}
#endif
	else if( (ptr=find_keyword( i, line, "INHERIT" ) ) ) {
	    if( *ptr == 'y' || *ptr == 'Y' )
		comb->inherit = 1;
	    else
		comb->inherit = 0;
	    continue;
	} else if( !strncmp( &line[i], "COMBINATION:", 12 ) )
	    continue;

	done2=0;
	ptr = strtok( line, delims );
	while (!done2) {
	    if ( !ptr )
		break;

	    /* First non-white is the relation operator */
	    relation = (*ptr);
	    if( relation == '\0' )
		break;

	    /* Next must be the member name */
	    ptr = strtok( (char *)NULL, delims );
	    if( dbip->dbi_version < 5 ) {
		strncpy( name_v4 , ptr, NAMESIZE );
		name_v4[NAMESIZE] = '\0';
		name = name_v4;
	    } else {
		if( name )
		    bu_free( name, "name" );
		name = bu_strdup( ptr );
	    }

	    /* Eliminate trailing white space from name */
	    if( dbip->dbi_version < 5 )
		i = NAMESIZE;
	    else
		i = strlen( name );
	    while( isspace( name[--i] ) )
		name[i] = '\0';

	    /* Check for existence of member */
	    if( (db_lookup( dbip , name , LOOKUP_QUIET )) == DIR_NULL )
		Tcl_AppendResult(interp, "\tWARNING: '", name, "' does not exist\n", (char *)NULL);
	    /* get matrix */
	    ptr = strtok( (char *)NULL, delims );
	    if( !ptr ){
		matrix = (matp_t)NULL;
		done2 = 1;
	    }else if(*ptr == 'u' ||
		     (*ptr == '-' && *(ptr+1) == '\0') ||
		     (*ptr == '+' && *(ptr+1) == '\0')) {
		/* assume another relational operator */
		matrix = (matp_t)NULL;
	    }else {
		int k;

		matrix = (matp_t)bu_calloc( 16, sizeof( fastf_t ), "red: matrix" );
		matrix[0] = atof( ptr );
		for( k=1 ; k<16 ; k++ ) {
		    ptr = strtok( (char *)NULL, delims );
		    if( !ptr ) {
			Tcl_AppendResult(interp, "incomplete matrix for member ",
					 name, " No changes made\n", (char *)NULL );
			bu_free( (char *)matrix, "red: matrix" );
			if( rt_tree_array )
			    bu_free( (char *)rt_tree_array, "red: tree list" );
			fclose( fp );
			return( 1 );
		    }
		    matrix[k] = atof( ptr );
		}
		if( bn_mat_is_identity( matrix ) ) {
		    bu_free( (char *)matrix, "red: matrix" );
		    matrix = (matp_t)NULL;
		}

		ptr = strtok( (char *)NULL, delims );
		if (ptr == (char *)NULL)
		    done2 = 1;
	    }

	    /* Add it to the combination */
	    switch( relation ) {
		case '+':
		    rt_tree_array[tree_index].tl_op = OP_INTERSECT;
		    break;
		case '-':
		    rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
		    break;
		default:
		    Tcl_AppendResult(interp, "unrecognized relation (assume UNION)\n",
				     (char *)NULL );
		case 'u':
		    rt_tree_array[tree_index].tl_op = OP_UNION;
		    break;
	    }
	    BU_GETUNION( tp, tree );
	    rt_tree_array[tree_index].tl_tree = tp;
	    tp->tr_l.magic = RT_TREE_MAGIC;
	    tp->tr_l.tl_op = OP_DB_LEAF;
	    tp->tr_l.tl_name = bu_strdup( name );
	    tp->tr_l.tl_mat = matrix;
	    tree_index++;
	}
    }

    fclose( fp );

    ret = make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index);

    if( dbip->dbi_version >= 5 ) {
	if( name )
	    bu_free( name, "name " );
	bu_free( new_name, "new_name" );
    }

    return( ret );
}

void
mktemp_comb(char *str)
{
    /* Make a temporary name for a combination
       a template name is expected as in "mk_temp()" with
       5 trailing X's */

    int counter,done;
    char *ptr;


    if(dbip == DBI_NULL)
	return;

    /* Set "ptr" to start of X's */

    ptr = str;
    while( *ptr != '\0' )
	ptr++;

    while( *(--ptr) == 'X' );
    ptr++;


    counter = 1;
    done = 0;
    while( !done && counter < 99999 ) {
	sprintf( ptr , "%d" , counter );
	if( db_lookup( dbip , str , LOOKUP_QUIET ) == DIR_NULL )
	    done = 1;
	else
	    counter++;
    }
}

int save_comb(struct directory *dpold)
{
    /* Save a combination under a temporory name */

    register struct directory	*dp;
    struct rt_db_internal		intern;

    if(dbip == DBI_NULL)
	return 0;

    /* Make a new name */
    mktemp_comb( red_tmpcomb );

    if( rt_db_get_internal( &intern, dpold, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	TCL_READ_ERR_return;

    if( (dp=db_diradd( dbip, red_tmpcomb, -1L, 0, dpold->d_flags, (genptr_t)&intern.idb_type)) == DIR_NULL )  {
	Tcl_AppendResult(interp, "Cannot save copy of ", dpold->d_namep,
			 ", no changes made\n", (char *)NULL);
	return( 1 );
    }

    if( rt_db_put_internal(	dp, dbip, &intern, &rt_uniresource ) < 0 ) {
	Tcl_AppendResult(interp, "Cannot save copy of ", dpold->d_namep,
			 ", no changes made\n", (char *)NULL);
	return( 1 );
    }

    return( 0 );
}

/* restore a combination that was saved in "red_tmpcomb" */
void
restore_comb(struct directory *dp)
{
    char *av[4];
    char *name;

    /* Save name of original combo */
    name = bu_strdup( dp->d_namep );

    av[0] = "kill";
    av[1] = name;
    av[2] = NULL;
    av[3] = NULL;
    (void)cmd_kill((ClientData)NULL, interp, 2, av);

    av[0] = "mv";
    av[1] = red_tmpcomb;
    av[2] = name;

    (void)cmd_name((ClientData)NULL, interp, 3, av);

    bu_free( name, "bu_strdup'd name" );
}


/*
 *  Usage:  put_comb comb_name is_Region id air material los color
 *			shader inherit boolean_expr
 */
int
cmd_put_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    struct directory *dp;
    struct rt_db_internal	intern;
    struct rt_comb_internal *comb;
    char new_name_v4[NAMESIZE+1];
    char *new_name;
    int offset;
    int save_comb_flag = 0;

    CHECK_DBI_NULL;
    CHECK_READ_ONLY;

    if(argc < 7 || 11 < argc){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel put_comb");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    strncpy(red_tmpcomb, red_tmpcomb_init, 17-1);
    dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );
    if(dp != DIR_NULL){
	if( !(dp->d_flags & DIR_COMB) ){
	    Tcl_AppendResult(interp, argv[1],
			     " is not a combination, so cannot be edited this way\n", (char *)NULL);
	    return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	    TCL_READ_ERR_return;

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	save_comb(dp); /* Save combination to a temp name */
	save_comb_flag = 1;
    }else{
	comb = (struct rt_comb_internal *)NULL;
    }

    /* empty the existing combination */
    if( comb && comb->tree ){
	db_free_tree( comb->tree, &rt_uniresource );
	comb->tree = NULL;
    }else{
	/* make an empty combination structure */
	BU_GETSTRUCT( comb, rt_comb_internal );
	comb->magic = RT_COMB_MAGIC;
	comb->tree = TREE_NULL;
	bu_vls_init( &comb->shader );
	bu_vls_init( &comb->material );
    }

    if( dbip->dbi_version < 5 )	{
	new_name = new_name_v4;
	if(dp == DIR_NULL)
	    NAMEMOVE(argv[1], new_name_v4);
	else
	    NAMEMOVE(dp->d_namep, new_name_v4);
    } else {
	if( dp == DIR_NULL )
	    new_name = argv[1];
	else
	    new_name = dp->d_namep;
    }

    if(*argv[2] == 'y' || *argv[2] == 'Y')
	comb->region_flag = 1;
    else
	comb->region_flag = 0;

    if(comb->region_flag){
	if(argc != 11){
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "help put_comb");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    return TCL_ERROR;
	}

	comb->region_id = atoi(argv[3]);
	comb->aircode = atoi(argv[4]);
	comb->GIFTmater = atoi(argv[5]);
	comb->los = atoi(argv[6]);

	/* use the new values for defaults */
	item_default = comb->region_id + 1;
	air_default = comb->aircode;
	mat_default = comb->GIFTmater;
	los_default = comb->los;
	offset = 6;
    }else{
	if(argc != 7){
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "help put_comb");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    return TCL_ERROR;
	}
	offset = 2;
    }

    put_rgb_into_comb(comb, argv[offset + 1]);
    bu_vls_strcpy(&comb->shader, argv[offset +2]);

    if(*argv[offset + 3] == 'y' || *argv[offset + 3] == 'Y')
	comb->inherit = 1;
    else
	comb->inherit = 0;

    if(put_tree_into_comb(comb, dp, argv[1], new_name, argv[offset + 4]) == TCL_ERROR){
	if(comb){
	    restore_comb(dp);
	    Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL);
	}
	(void)unlink(red_tmpfil);
	return TCL_ERROR;
    }else if(save_comb_flag){
	/* eliminate the temporary combination */
	char *av[3];

	av[0] = "kill";
	av[1] = red_tmpcomb;
	av[2] = NULL;
	(void)cmd_kill(clientData, interp, 2, av);
    }

    (void)unlink(red_tmpfil);
    return TCL_OK;
}


int
f_red(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    FILE *fp;
    struct directory *dp;
    struct rt_db_internal	intern;
    struct rt_comb_internal	*comb;
    int node_count;

    CHECK_DBI_NULL;

    if(argc != 2){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help red");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    strncpy(red_tmpcomb, red_tmpcomb_init, 17-1);

    dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );

    if( dp != DIR_NULL ) {
	if( !(dp->d_flags & DIR_COMB ) ) {
	    Tcl_AppendResult(interp, argv[1],
			     " is not a combination, so cannot be edited this way\n", (char *)NULL);
	    return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	    TCL_READ_ERR_return;

	comb = (struct rt_comb_internal *)intern.idb_ptr;

	/* Make a file for the text editor */
	fp = bu_temp_file(red_tmpfil, MAXPATHLEN);

	/* Write the combination components to the file */
	if( writecomb( comb, dp->d_namep ) ) {
	    Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
	    unlink( red_tmpfil );
	    return TCL_ERROR;
	}
    } else {
	comb = (struct rt_comb_internal *)NULL;

	/* Make a file for the text editor */
	fp = bu_temp_file(red_tmpfil, MAXPATHLEN);

	/* Write the combination components to the file */
	if( writecomb( comb, argv[1] ) ) {
	    Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
	    unlink( red_tmpfil );
	    return TCL_ERROR;
	}
    }

    /* Edit the file */
    if( editit( red_tmpfil ) ){

	/* specifically avoid CHECK_READ_ONLY; above so that
	 * we can delay checking if the geometry is read-only
	 * until here so that red may be used to view objects.
	 */
	if (!dbip->dbi_read_only) {
	    if( (node_count = checkcomb()) < 0 ){ /* Do some quick checking on the edited file */
		Tcl_AppendResult(interp, "Error in edited region, no changes made\n", (char *)NULL);
		if( comb )
		    rt_comb_ifree( &intern, &rt_uniresource );
		(void)unlink( red_tmpfil );
		return TCL_ERROR;
	    }

	    if( comb ){
		if( save_comb( dp ) ){ /* Save combination to a temp name */
		    Tcl_AppendResult(interp, "No changes made\n", (char *)NULL);
		    rt_comb_ifree( &intern, &rt_uniresource );
		    (void)unlink( red_tmpfil );
		    return TCL_OK;
		}
	    }

	    if( build_comb( comb, dp, node_count, argv[1] ) ){
		Tcl_AppendResult(interp, "Unable to construct new ", dp->d_namep,
				 (char *)NULL);
		if( comb ){
		    restore_comb( dp );
		    Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL );
		    rt_comb_ifree( &intern, &rt_uniresource );
		}

		(void)unlink( red_tmpfil );
		return TCL_ERROR;
	    }else if( comb ){
		/* eliminate the temporary combination */
		char *av[3];

		av[0] = "kill";
		av[1] = red_tmpcomb;
		av[2] = NULL;
		(void)cmd_kill(clientData, interp, 2, av);
	    }
	} else {
	    Tcl_AppendResult(interp, "Because the database is READ-ONLY no changes were made.\n", (char *)NULL);
	}
    }

    if (fp) {
	fclose(fp);
	fp = NULL;
    }
    unlink(red_tmpfil);
    return TCL_OK;
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.20 2007/09/25 04:30:58 brlcad Exp $ (BRL)";
d57 1
a57 6
static char	red_tmpfil[17];
#ifndef _WIN32
static char	*red_tmpfil_init = "/tmp/GED.aXXXXXX";
#else
static char	*red_tmpfil_init = "C:\\GED.aXXXXXX";
#endif
a650 1
	Tcl_AppendResult(interp, "Cannot open create file for editing\n", (char *)NULL);
d652 1
d742 1
a742 2
	    Tcl_AppendResult(interp, "Cannot write to temp file (", red_tmpfil,
			     "). Aborting edit\n", (char *)NULL );
a774 1
	Tcl_AppendResult(interp, "Cannot open create file for editing\n", (char *)NULL);
d776 1
d1058 1
a1058 2
	Tcl_AppendResult(interp, " Cannot open edited file: ",
			 red_tmpfil, "\n", (char *)NULL);
a1445 1
    strncpy(red_tmpfil, red_tmpfil_init, 17-1);
d1564 1
a1568 1
    int fd;
a1581 1
    strncpy(red_tmpfil, red_tmpfil_init, 17-1);
d1599 1
a1599 9
#ifdef _WIN32
	(void)mktemp( red_tmpfil );
#else
	if ((fd = mkstemp(red_tmpfil)) < 0) {
	    perror(red_tmpfil);
	    return TCL_ERROR;;
	}
	(void)close(fd);
#endif
d1609 1
d1611 1
a1611 9
#ifdef _WIN32
	(void)mktemp( red_tmpfil );
#else
	if ((fd = mkstemp(red_tmpfil)) < 0) {
	    perror(red_tmpfil);
	    return TCL_ERROR;;
	}
	(void)close(fd);
#endif
d1671 5
a1675 1
    (void)unlink( red_tmpfil );
@


14.20
log
@oop, no fp
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.19 2007/09/25 04:12:04 brlcad Exp $ (BRL)";
d63 1
a63 1
static char	red_tmpcomb[16];
d810 1
a810 1
	strcpy( lineCopy, line );
d955 1
a955 1
		    strcpy( name_v5, ptr );
d1453 2
a1454 2
    strcpy(red_tmpfil, red_tmpfil_init);
    strcpy(red_tmpcomb, red_tmpcomb_init);
d1590 2
a1591 2
    strcpy(red_tmpfil, red_tmpfil_init);
    strcpy(red_tmpcomb, red_tmpcomb_init);
@


14.19
log
@apply karel's same tweak to the tree listing as well for spacing out matrices one character per matrix line
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.18 2007/09/25 03:43:48 brlcad Exp $ (BRL)";
d138 1
a138 1
	if ((k&3)==3) fputc(' ', fp);
@


14.18
log
@apply Karel's sf patch 1800475 (improve ergonomoy of red) that provides improved matrix readability for mged 'red' command.  the change adds an additional space after each matrix line in the 'red' file being edited.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.17 2007/09/15 16:23:17 brlcad Exp $ (BRL)";
d138 1
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.16 2007/07/26 01:13:58 brlcad Exp $ (BRL)";
d114 1
@


14.16
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.15 2007/01/23 01:13:42 brlcad Exp $ (BRL)";
d38 1
a38 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d41 1
@


14.16.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.20 2007/09/25 04:30:58 brlcad Exp $ (BRL)";
d38 5
a42 1
#include <string.h>
a44 1

a116 1
	if ((k&3)==3) fputc(' ', fp);
a139 1
	if ((k&3)==3) bu_vls_printf(vls, " ");
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a27 4
 *  Source -
 *	SECAD/VLD Computing Consortium
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.14 2007/01/20 14:36:57 brlcad Exp $ (BRL)";
@


14.14
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.13 2007/01/18 16:51:07 brlcad Exp $ (BRL)";
@


14.13
log
@restructure file so that the function declarations can go away.
@
text
@d4 1
a4 1
 * Copyright (c) 1992-2006 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.12 2007/01/18 16:37:05 brlcad Exp $ (BRL)";
@


14.12
log
@massive ws cleanup, make braces consistently match hacking style
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.11 2007/01/18 16:24:58 brlcad Exp $ (BRL)";
a74 135
void put_rgb_into_comb(struct rt_comb_internal *comb, char *str);
void restore_comb(struct directory *dp);
int editit(const char *file);
static int make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index);
int clear_comb(),build_comb(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name),save_comb(struct directory *dpold);

int
f_red(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    struct directory *dp;
    struct rt_db_internal	intern;
    struct rt_comb_internal	*comb;
    int node_count;
    int fd;

    CHECK_DBI_NULL;

    if(argc != 2){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help red");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    strcpy(red_tmpfil, red_tmpfil_init);
    strcpy(red_tmpcomb, red_tmpcomb_init);

    dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );

    if( dp != DIR_NULL ) {
	if( !(dp->d_flags & DIR_COMB ) ) {
	    Tcl_AppendResult(interp, argv[1],
			     " is not a combination, so cannot be edited this way\n", (char *)NULL);
	    return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	    TCL_READ_ERR_return;

	comb = (struct rt_comb_internal *)intern.idb_ptr;

	/* Make a file for the text editor */
#ifdef _WIN32
	(void)mktemp( red_tmpfil );
#else
	if ((fd = mkstemp(red_tmpfil)) < 0) {
	    perror(red_tmpfil);
	    return TCL_ERROR;;
	}
	(void)close(fd);
#endif

	/* Write the combination components to the file */
	if( writecomb( comb, dp->d_namep ) ) {
	    Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
	    unlink( red_tmpfil );
	    return TCL_ERROR;
	}
    } else {
	comb = (struct rt_comb_internal *)NULL;
	/* Make a file for the text editor */
#ifdef _WIN32
	(void)mktemp( red_tmpfil );
#else
	if ((fd = mkstemp(red_tmpfil)) < 0) {
	    perror(red_tmpfil);
	    return TCL_ERROR;;
	}
	(void)close(fd);
#endif

	/* Write the combination components to the file */
	if( writecomb( comb, argv[1] ) ) {
	    Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
	    unlink( red_tmpfil );
	    return TCL_ERROR;
	}
    }

    /* Edit the file */
    if( editit( red_tmpfil ) ){

	/* specifically avoid CHECK_READ_ONLY; above so that
	 * we can delay checking if the geometry is read-only
	 * until here so that red may be used to view objects.
	 */
	if (!dbip->dbi_read_only) {
	    if( (node_count = checkcomb()) < 0 ){ /* Do some quick checking on the edited file */
		Tcl_AppendResult(interp, "Error in edited region, no changes made\n", (char *)NULL);
		if( comb )
		    rt_comb_ifree( &intern, &rt_uniresource );
		(void)unlink( red_tmpfil );
		return TCL_ERROR;
	    }

	    if( comb ){
		if( save_comb( dp ) ){ /* Save combination to a temp name */
		    Tcl_AppendResult(interp, "No changes made\n", (char *)NULL);
		    rt_comb_ifree( &intern, &rt_uniresource );
		    (void)unlink( red_tmpfil );
		    return TCL_OK;
		}
	    }

	    if( build_comb( comb, dp, node_count, argv[1] ) ){
		Tcl_AppendResult(interp, "Unable to construct new ", dp->d_namep,
				 (char *)NULL);
		if( comb ){
		    restore_comb( dp );
		    Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL );
		    rt_comb_ifree( &intern, &rt_uniresource );
		}

		(void)unlink( red_tmpfil );
		return TCL_ERROR;
	    }else if( comb ){
		/* eliminate the temporary combination */
		char *av[3];

		av[0] = "kill";
		av[1] = red_tmpcomb;
		av[2] = NULL;
		(void)cmd_kill(clientData, interp, 2, av);
	    }
	} else {
	    Tcl_AppendResult(interp, "Because the database is READ-ONLY no changes were made.\n", (char *)NULL);
	}
    }

    (void)unlink( red_tmpfil );
    return TCL_OK;
}
d251 71
d646 1
a646 4
/*
 *  Usage:  put_comb comb_name is_Region id air material los color
 *			shader inherit boolean_expr
 */
d648 1
a648 1
cmd_put_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d650 6
a655 7
    struct directory *dp;
    struct rt_db_internal	intern;
    struct rt_comb_internal *comb;
    char new_name_v4[NAMESIZE+1];
    char *new_name;
    int offset;
    int save_comb_flag = 0;
d657 2
a658 2
    CHECK_DBI_NULL;
    CHECK_READ_ONLY;
d660 6
a665 2
    if(argc < 7 || 11 < argc){
	struct bu_vls vls;
d667 13
a679 5
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel put_comb");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
d682 5
a686 155
    strcpy(red_tmpfil, red_tmpfil_init);
    strcpy(red_tmpcomb, red_tmpcomb_init);
    dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );
    if(dp != DIR_NULL){
	if( !(dp->d_flags & DIR_COMB) ){
	    Tcl_AppendResult(interp, argv[1],
			     " is not a combination, so cannot be edited this way\n", (char *)NULL);
	    return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
	    TCL_READ_ERR_return;

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	save_comb(dp); /* Save combination to a temp name */
	save_comb_flag = 1;
    }else{
	comb = (struct rt_comb_internal *)NULL;
    }

    /* empty the existing combination */
    if( comb && comb->tree ){
	db_free_tree( comb->tree, &rt_uniresource );
	comb->tree = NULL;
    }else{
	/* make an empty combination structure */
	BU_GETSTRUCT( comb, rt_comb_internal );
	comb->magic = RT_COMB_MAGIC;
	comb->tree = TREE_NULL;
	bu_vls_init( &comb->shader );
	bu_vls_init( &comb->material );
    }

    if( dbip->dbi_version < 5 )	{
	new_name = new_name_v4;
	if(dp == DIR_NULL)
	    NAMEMOVE(argv[1], new_name_v4);
	else
	    NAMEMOVE(dp->d_namep, new_name_v4);
    } else {
	if( dp == DIR_NULL )
	    new_name = argv[1];
	else
	    new_name = dp->d_namep;
    }

    if(*argv[2] == 'y' || *argv[2] == 'Y')
	comb->region_flag = 1;
    else
	comb->region_flag = 0;

    if(comb->region_flag){
	if(argc != 11){
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "help put_comb");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    return TCL_ERROR;
	}

	comb->region_id = atoi(argv[3]);
	comb->aircode = atoi(argv[4]);
	comb->GIFTmater = atoi(argv[5]);
	comb->los = atoi(argv[6]);

	/* use the new values for defaults */
	item_default = comb->region_id + 1;
	air_default = comb->aircode;
	mat_default = comb->GIFTmater;
	los_default = comb->los;
	offset = 6;
    }else{
	if(argc != 7){
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "help put_comb");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	    return TCL_ERROR;
	}
	offset = 2;
    }

    put_rgb_into_comb(comb, argv[offset + 1]);
    bu_vls_strcpy(&comb->shader, argv[offset +2]);

    if(*argv[offset + 3] == 'y' || *argv[offset + 3] == 'Y')
	comb->inherit = 1;
    else
	comb->inherit = 0;

    if(put_tree_into_comb(comb, dp, argv[1], new_name, argv[offset + 4]) == TCL_ERROR){
	if(comb){
	    restore_comb(dp);
	    Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL);
	}
	(void)unlink(red_tmpfil);
	return TCL_ERROR;
    }else if(save_comb_flag){
	/* eliminate the temporary combination */
	char *av[3];

	av[0] = "kill";
	av[1] = red_tmpcomb;
	av[2] = NULL;
	(void)cmd_kill(clientData, interp, 2, av);
    }

    (void)unlink(red_tmpfil);
    return TCL_OK;
}

int
writecomb( const struct rt_comb_internal *comb, const char *name )
{
    /*	Writes the file for later editing */
    struct rt_tree_array	*rt_tree_array;
    FILE			*fp;
    int			i;
    int			node_count;
    int			actual_count;

    if( comb )
	RT_CK_COMB( comb );

    /* open the file */
    if( (fp=fopen( red_tmpfil , "w" )) == NULL ) {
	Tcl_AppendResult(interp, "Cannot open create file for editing\n", (char *)NULL);
	perror( "MGED" );
	return(1);
    }

    if( !comb )	{
	fprintf( fp, "NAME=%s\n", name );
	fprintf( fp, "REGION=No\n" );
	fprintf( fp, "REGION_ID=\n" );
	fprintf( fp, "AIRCODE=\n" );
	fprintf( fp, "GIFT_MATERIAL=\n" );
	fprintf( fp, "LOS=\n" );
	fprintf( fp, "COLOR=\n" );
	fprintf( fp, "SHADER=\n" );
	fprintf( fp, "INHERIT=No\n" );
	fprintf( fp, "COMBINATION:\n" );
	fclose( fp );
	return( 0 );
    }

    if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 ) {
	db_non_union_push( comb->tree, &rt_uniresource );
	if( db_ck_v4gift_tree( comb->tree ) < 0 ) {
	    Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL );
	    return( 1 );
a1037 70
static int
make_tree(struct rt_comb_internal *comb, struct directory *dp, int node_count, char *old_name, char *new_name, struct rt_tree_array *rt_tree_array, int tree_index)
{
    struct rt_db_internal	intern;
    union tree		*final_tree;

    if (tree_index)
	final_tree = (union tree *)db_mkgift_tree( rt_tree_array, node_count, &rt_uniresource );
    else
	final_tree = (union tree *)NULL;

    RT_INIT_DB_INTERNAL(&intern);
    intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
    intern.idb_type = ID_COMBINATION;
    intern.idb_meth = &rt_functab[ID_COMBINATION];
    intern.idb_ptr = (genptr_t)comb;
    comb->tree = final_tree;

    if (strcmp(new_name, old_name)) {
	int flags;

	if (comb->region_flag)
	    flags = DIR_COMB | DIR_REGION;
	else
	    flags = DIR_COMB;

	if (dp != DIR_NULL) {
	    if (db_delete(dbip, dp) || db_dirdelete(dbip, dp)) {
		Tcl_AppendResult(interp, "ERROR: Unable to delete directory entry for ",
				 old_name, "\n", (char *)NULL);
		rt_comb_ifree(&intern, &rt_uniresource);
		return(1);
	    }
	}

	if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
	    Tcl_AppendResult(interp, "Cannot add ", new_name,
			     " to directory, no changes made\n", (char *)NULL);
	    rt_comb_ifree(&intern, &rt_uniresource);
	    return(1);
	}
    } else if( dp == DIR_NULL ) {
	int flags;

	if (comb->region_flag)
	    flags = DIR_COMB | DIR_REGION;
	else
	    flags = DIR_COMB;

	if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
	    Tcl_AppendResult(interp, "Cannot add ", new_name,
			     " to directory, no changes made\n", (char *)NULL);
	    rt_comb_ifree( &intern, &rt_uniresource );
	    return(1);
	}
    } else {
	if (comb->region_flag)
	    dp->d_flags |= DIR_REGION;
	else
	    dp->d_flags &= ~DIR_REGION;
    }

    if (rt_db_put_internal(dp, dbip, &intern, &rt_uniresource) < 0) {
	Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
	return 1;
    }

    return(0);
}

d1430 276
@


14.11
log
@even if the matrix is an identity matrix, print it so that the user has a starting point. add a comment about using red with a read-only db.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.10 2006/11/05 02:26:15 johnranderson Exp $ (BRL)";
d84 29
a112 31
	struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int node_count;
	int fd;

	CHECK_DBI_NULL;

	if(argc != 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help red");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	strcpy(red_tmpfil, red_tmpfil_init);
	strcpy(red_tmpcomb, red_tmpcomb_init);

	dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );

	if( dp != DIR_NULL )
	{
		if( !(dp->d_flags & DIR_COMB ) )
		{
		  Tcl_AppendResult(interp, argv[1],
				   " is not a combination, so cannot be edited this way\n", (char *)NULL);
		  return TCL_ERROR;
		}
d114 2
a115 2
		if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
			TCL_READ_ERR_return;
d117 1
a117 1
		comb = (struct rt_comb_internal *)intern.idb_ptr;
d119 1
a119 1
		/* Make a file for the text editor */
d121 1
a121 1
		(void)mktemp( red_tmpfil );
d123 5
a127 5
		if ((fd = mkstemp(red_tmpfil)) < 0) {
			perror(red_tmpfil);
			return TCL_ERROR;;
		}
		(void)close(fd);
d130 9
a138 12
		/* Write the combination components to the file */
		if( writecomb( comb, dp->d_namep ) )
		{
		  Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
		  unlink( red_tmpfil );
		  return TCL_ERROR;
		}
	}
	else
	{
		comb = (struct rt_comb_internal *)NULL;
		/* Make a file for the text editor */
d140 1
a140 1
		(void)mktemp( red_tmpfil );
d142 5
a146 5
		if ((fd = mkstemp(red_tmpfil)) < 0) {
			perror(red_tmpfil);
			return TCL_ERROR;;
		}
		(void)close(fd);
d149 5
a153 7
		/* Write the combination components to the file */
		if( writecomb( comb, argv[1] ) )
		{
		  Tcl_AppendResult(interp, "Unable to edit ", argv[1], "\n", (char *)NULL);
		  unlink( red_tmpfil );
		  return TCL_ERROR;
		}
d155 1
d157 2
a158 2
	/* Edit the file */
	if( editit( red_tmpfil ) ){
d160 29
a188 44
	        /* specifically avoid CHECK_READ_ONLY; above so that
		 * we can delay checking if the geometry is read-only
		 * until here so that red may be used to view objects.
		 */
		if (!dbip->dbi_read_only) {
			if( (node_count = checkcomb()) < 0 ){ /* Do some quick checking on the edited file */
				Tcl_AppendResult(interp, "Error in edited region, no changes made\n", (char *)NULL);
				if( comb )
					rt_comb_ifree( &intern, &rt_uniresource );
				(void)unlink( red_tmpfil );
				return TCL_ERROR;
			}

			if( comb ){
				if( save_comb( dp ) ){ /* Save combination to a temp name */
					Tcl_AppendResult(interp, "No changes made\n", (char *)NULL);
					rt_comb_ifree( &intern, &rt_uniresource );
					(void)unlink( red_tmpfil );
					return TCL_OK;
				}
			}

			if( build_comb( comb, dp, node_count, argv[1] ) ){
				Tcl_AppendResult(interp, "Unable to construct new ", dp->d_namep,
						 (char *)NULL);
				if( comb ){
					restore_comb( dp );
					Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL );
					rt_comb_ifree( &intern, &rt_uniresource );
				}

				(void)unlink( red_tmpfil );
				return TCL_ERROR;
			}else if( comb ){
				/* eliminate the temporary combination */
				char *av[3];

				av[0] = "kill";
				av[1] = red_tmpcomb;
				av[2] = NULL;
				(void)cmd_kill(clientData, interp, 2, av);
			}
		} else {
			Tcl_AppendResult(interp, "Because the database is READ-ONLY no changes were made.\n", (char *)NULL);
d190 14
d205 1
d207 2
a208 2
	(void)unlink( red_tmpfil );
	return TCL_OK;
d214 21
a234 21
	char *ptr1;
	char *ptr2;
	int j;

	/* find the keyword */
	ptr1 = strstr( &line[i], word );
	if( !ptr1 )
		return( (char *)NULL );

	/* find the '=' */
	ptr2 = strchr( ptr1, '=' );
	if( !ptr2 )
		return( (char *)NULL );

	/* skip any white space before the value */
	while( isspace( *(++ptr2) ) );

	/* eliminate trailing white space */
	j = strlen( line );
	while( isspace( line[--j] ) );
	line[j+1] = '\0';
d236 2
a237 2
	/* return pointer to the value */
	return( ptr2 );
d243 15
a257 16
	int k;
	char buf[64];
	fastf_t tmp;

	if( !matrix )
		return;

	for( k=0 ; k<16 ; k++ )
	{
		sprintf( buf, "%g", matrix[k] );
		tmp = atof( buf );
		if( tmp == matrix[k] )
			fprintf( fp, " %g", matrix[k] );
		else
			fprintf( fp, " %.12e", matrix[k] );
	}
d263 18
a280 18
  int k;
  char buf[64];
  fastf_t tmp;

  if(!matrix)
    return;

  if(bn_mat_is_identity(matrix))
    return;

  for(k=0; k<16; k++){
    sprintf(buf, "%g", matrix[k]);
    tmp = atof(buf);
    if(tmp == matrix[k])
      bu_vls_printf(vls, " %g", matrix[k]);
    else
      bu_vls_printf(vls, " %.12e", matrix[k]);
  }
d286 6
a291 1
  int r, g, b;
d293 20
a312 25
  if(sscanf(str, "%d%d%d", &r, &g, &b) != 3){
    comb->rgb_valid = 0;
    return;
  }

  /* clamp the RGB values to [0,255] */
  if(r < 0)
    r = 0;
  else if(r > 255)
    r = 255;

  if(g < 0)
    g = 0;
  else if(g > 255)
    g = 255;

  if(b < 0)
    b = 0;
  else if(b > 255)
    b = 255;

  comb->rgb[0] = (unsigned char)r;
  comb->rgb[1] = (unsigned char)g;
  comb->rgb[2] = (unsigned char)b;
  comb->rgb_valid = 1;
d316 2
a317 2
  struct bu_list l;
  char *line;
d325 32
a356 41
  char *ptr;
  char *name;
  char relation;
  int node_count=0;

  /* sanity */
  if (line == NULL)
    return 0;

  ptr = strtok(line , delims);

  while (ptr) {
    /* First non-white is the relation operator */
    relation = (*ptr);

    if (relation != '+' && relation != 'u' && relation != '-') {
      struct bu_vls tmp_vls;

      bu_vls_init(&tmp_vls);
      bu_vls_printf(&tmp_vls, " %c is not a legal operator\n" , relation );
      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
      bu_vls_free(&tmp_vls);
      return( -1 );
    }

    /* Next must be the member name */
    name = strtok((char *)NULL, delims);

    if (name == NULL) {
      Tcl_AppendResult(interp, " operand name missing\n", (char *)NULL);
      return( -1 );
    }

    ptr = strtok( (char *)NULL, delims );
    /*
     * If this token is not a boolean operator, then it must be the start
     * of a matrix which we will skip.
     */
    if (ptr && !((*ptr == 'u' || *ptr == '-' || *ptr=='+') &&
		 *(ptr+1) == '\0')) {
      int k;
a357 2
      /* skip past matrix, k=1 because we already have the first value */
      for (k=1 ; k<16 ; k++) {
d359 19
a377 3
	if (!ptr) {
	  Tcl_AppendResult(interp, "expecting a matrix\n", (char *)NULL);
	  return( -1 );
a378 1
      }
d380 1
a380 2
      /* get the next relational operator on the current line */
      ptr = strtok( (char *)NULL, delims );
d383 1
a383 4
    node_count++;
  }

  return node_count;
d389 28
a416 14
	int			i;
	int			done;
	char			*line;
	char			*ptr;
	char			relation;
	char			*name;
	struct rt_tree_array	*rt_tree_array;
	struct line_list	*llp;
	int			node_count = 0;
	int			tree_index = 0;
	union tree		*tp;
	matp_t			matrix;
	struct bu_vls		vls;
	int			result;
d418 1
a418 2
	if (str == (char *)NULL)
		return TCL_ERROR;
d420 15
a434 1
	BU_LIST_INIT(&HeadLines.l);
d436 2
a437 4
	/* break str into lines */
	line = str;
	ptr = strchr(str, '\n');
	if (ptr != NULL)
d439 11
a449 3
	bu_vls_init(&vls);
	while (line != (char *)NULL) {
		int n;
d451 22
a472 1
		bu_vls_strcpy(&vls, line);
d474 31
a504 2
		if ((n = count_nodes(bu_vls_addr(&vls))) < 0) {
			bu_vls_free(&vls);
d507 2
a508 17
		} else if (n > 0) {
			BU_GETSTRUCT(llp, line_list);
			BU_LIST_INSERT(&HeadLines.l, &llp->l);
			llp->line = line;

			node_count += n;
		} /* else blank line */

		if (ptr != NULL && *(ptr+1) != '\0') {
			/* leap frog past EOS */
			line = ptr + 1;

			ptr = strchr(line, '\n');
			if (ptr != NULL)
				*ptr = '\0';
		} else {
			line = NULL;
d510 32
d543 1
a543 1
	bu_vls_free(&vls);
d545 6
a550 106
	/* build tree list */
	if (node_count)
		rt_tree_array = (struct rt_tree_array *)bu_calloc(node_count, sizeof(struct rt_tree_array), "tree list" );
	else
		rt_tree_array = (struct rt_tree_array *)NULL;

	for (BU_LIST_FOR(llp, line_list, &HeadLines.l)) {
		done = 0;
		ptr = strtok(llp->line, delims);
		while (!done) {
			if (!ptr)
				break;

			/* First non-white is the relation operator */
			relation = (*ptr);
			if (relation == '\0')
				break;

			/* Next must be the member name */
			ptr = strtok((char *)NULL, delims);
			if (ptr == (char *)NULL) {
				bu_list_free(&HeadLines.l);
				if (rt_tree_array)
					bu_free((char *)rt_tree_array, "red: tree list");
				bu_log("no name specified\n");
				return TCL_ERROR;
			}
			name = ptr;

			/* Eliminate trailing white space from name */
			i = strlen( ptr );
			while(isspace(name[--i]))
				name[i] = '\0';

			/* Check for existence of member */
			if ((db_lookup(dbip , name , LOOKUP_QUIET)) == DIR_NULL)
				bu_log("\tWARNING: ' %s ' does not exist\n", name);

			/* get matrix */
			ptr = strtok((char *)NULL, delims);
			if (ptr == (char *)NULL) {
				matrix = (matp_t)NULL;
				done = 1;
			} else if (*ptr == 'u' ||
				   (*ptr == '-' && *(ptr+1) == '\0') ||
				   (*ptr == '+' && *(ptr+1) == '\0')) {
				/* assume another relational operator */
				matrix = (matp_t)NULL;
			} else {
				int k;

				matrix = (matp_t)bu_calloc(16, sizeof(fastf_t), "red: matrix");
				matrix[0] = atof(ptr);
				for (k=1 ; k<16 ; k++) {
					ptr = strtok((char *)NULL, delims);
					if (!ptr) {
						bu_log("incomplete matrix for member %s - No changes made\n", name);
						bu_free( (char *)matrix, "red: matrix" );
						if(rt_tree_array)
							bu_free((char *)rt_tree_array, "red: tree list");
						bu_list_free(&HeadLines.l);
						return TCL_ERROR;
					}
					matrix[k] = atof( ptr );
				}
				if (bn_mat_is_identity( matrix )) {
					bu_free((char *)matrix, "red: matrix");
					matrix = (matp_t)NULL;
				}

				ptr = strtok((char *)NULL, delims);
				if (ptr == (char *)NULL)
					done = 1;
			}

			/* Add it to the combination */
			switch (relation) {
			case '+':
				rt_tree_array[tree_index].tl_op = OP_INTERSECT;
				break;
			case '-':
				rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
				break;
			default:
				bu_log("unrecognized relation (assume UNION)\n");
			case 'u':
				rt_tree_array[tree_index].tl_op = OP_UNION;
				break;
			}

			BU_GETUNION(tp, tree);
			rt_tree_array[tree_index].tl_tree = tp;
			tp->tr_l.magic = RT_TREE_MAGIC;
			tp->tr_l.tl_op = OP_DB_LEAF;
			tp->tr_l.tl_name = bu_strdup( name );
			tp->tr_l.tl_mat = matrix;
			tree_index++;
		}
	}

	bu_list_free(&HeadLines.l);
	result = make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index);
	if (result == 0)
		return TCL_OK;
	else
		return TCL_ERROR;
d559 29
a587 8
	struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal *comb;
	struct rt_tree_array	*rt_tree_array;
	int i;
	int node_count;
	int actual_count;
	struct bu_vls vls;
d589 2
a590 2
	CHECK_DBI_NULL;
	CHECK_READ_ONLY;
d592 1
a592 1
	bu_vls_init(&vls);
d594 4
a597 4
	if (argc != 2) {
		bu_vls_printf(&vls, "helpdevel get_comb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
d599 1
d602 16
a617 1
	dp = db_lookup(dbip , argv[1] , LOOKUP_QUIET);
d619 18
a636 6
	if (dp != DIR_NULL) {
		if (!(dp->d_flags & DIR_COMB)) {
			Tcl_AppendResult(interp, argv[1],
					 " is not a combination, so cannot be edited this way\n", (char *)NULL);
			return TCL_ERROR;
		}
d638 6
a643 2
		if (rt_db_get_internal(&intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource) < 0)
			TCL_READ_ERR_return;
d645 1
a645 1
		comb = (struct rt_comb_internal *)intern.idb_ptr;
d647 4
a650 7
		if (comb->tree && db_ck_v4gift_tree(comb->tree) < 0) {
			db_non_union_push(comb->tree, &rt_uniresource);
			if (db_ck_v4gift_tree(comb->tree) < 0) {
				Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL);
				return TCL_ERROR;
			}
		}
a651 16
		node_count = db_tree_nleaves(comb->tree);
		if (node_count > 0) {
			rt_tree_array = (struct rt_tree_array *)bu_calloc(node_count,
									  sizeof(struct rt_tree_array),
									  "tree list");
			actual_count = (struct rt_tree_array *)db_flatten_tree(rt_tree_array,
									       comb->tree,
									       OP_UNION,
									       1,
									       &rt_uniresource) - rt_tree_array;
			BU_ASSERT_LONG(actual_count, ==, node_count);
			comb->tree = TREE_NULL;
		} else {
			rt_tree_array = (struct rt_tree_array *)NULL;
			actual_count = 0;
		}
d653 27
a679 18
		Tcl_AppendElement(interp, dp->d_namep);                 /* NAME=name */
		if (comb->region_flag) {
			Tcl_AppendElement(interp, "Yes");              /* REGION=Yes */
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d", comb->region_id );
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* REGION_ID=comb->region_id */
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d", comb->aircode);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* AIRCODE=comb->aircode */
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d", comb->GIFTmater);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* GIFT_MATERIAL=comb->GIFTmater */
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d", comb->los );
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* LOS=comb->los */
		} else {
			Tcl_AppendElement(interp, "No");   /* REGION=No */
		}
d681 2
a682 42
		if (comb->rgb_valid) {
			bu_vls_trunc(&vls, 0);
			bu_vls_printf(&vls, "%d %d %d", V3ARGS(comb->rgb));
			Tcl_AppendElement(interp, bu_vls_addr(&vls));  /* COLOR=comb->rgb */
		} else
			Tcl_AppendElement(interp, "");                 /* COLOR="" */

		Tcl_AppendElement(interp, bu_vls_addr(&comb->shader)); /* SHADER=comb->shader */

		if (comb->inherit)
			Tcl_AppendElement(interp, "Yes");  /* INHERIT=Yes */
		else
			Tcl_AppendElement(interp, "No");   /* INHERIT=No  */


		bu_vls_trunc(&vls, 0);
		for (i = 0 ; i < actual_count ; i++) {
			char op;

			switch (rt_tree_array[i].tl_op) {
			case OP_UNION:
				op = 'u';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			default:
				Tcl_AppendResult(interp, "Illegal op code in tree\n",
						 (char *)NULL);
				bu_vls_free(&vls);

				return TCL_ERROR;
			}

			bu_vls_printf(&vls, " %c %s\t" , op , rt_tree_array[i].tl_tree->tr_l.tl_name);
			vls_print_matrix(&vls, rt_tree_array[i].tl_tree->tr_l.tl_mat);
			bu_vls_printf(&vls, "\n");
			db_free_tree(rt_tree_array[i].tl_tree, &rt_uniresource);
		}
d684 21
a704 2
		Tcl_AppendElement(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
d706 2
a707 24
		return TCL_OK;
	} else {
		Tcl_AppendElement(interp, argv[1]); /* NAME=argv[1] */
		Tcl_AppendElement(interp, "Yes");    /* REGION=Yes */
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "%d", item_default);
		Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* REGION_ID=item_default */
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "%d", air_default);
		Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* AIRCODE=air_default */
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "%d", mat_default);
		Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* GIFT_MATERIAL=mat_default */
		bu_vls_trunc(&vls, 0);
		bu_vls_printf(&vls, "%d", los_default);
		Tcl_AppendElement(interp, bu_vls_addr(&vls)); /* LOS=los_default */
		Tcl_AppendElement(interp, "");      /* COLOR=""         */
		Tcl_AppendElement(interp, "");      /* SHADER=""        */
		Tcl_AppendElement(interp, "No");    /* INHERIT=No       */
		Tcl_AppendElement(interp, "");      /* COMBINATION:""   */
		bu_vls_free(&vls);

		return TCL_RETURN;
	}
d717 7
a723 7
  struct directory *dp;
  struct rt_db_internal	intern;
  struct rt_comb_internal *comb;
  char new_name_v4[NAMESIZE+1];
  char *new_name;
  int offset;
  int save_comb_flag = 0;
d725 2
a726 2
  CHECK_DBI_NULL;
  CHECK_READ_ONLY;
d728 55
a782 2
  if(argc < 7 || 11 < argc){
    struct bu_vls vls;
d784 4
a787 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel put_comb");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d789 33
a821 99
  strcpy(red_tmpfil, red_tmpfil_init);
  strcpy(red_tmpcomb, red_tmpcomb_init);
  dp = db_lookup( dbip , argv[1] , LOOKUP_QUIET );
  if(dp != DIR_NULL){
    if( !(dp->d_flags & DIR_COMB) ){
      Tcl_AppendResult(interp, argv[1],
		       " is not a combination, so cannot be edited this way\n", (char *)NULL);
      return TCL_ERROR;
    }

    if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
      TCL_READ_ERR_return;

    comb = (struct rt_comb_internal *)intern.idb_ptr;
    save_comb(dp); /* Save combination to a temp name */
    save_comb_flag = 1;
  }else{
    comb = (struct rt_comb_internal *)NULL;
  }

  /* empty the existing combination */
  if( comb && comb->tree ){
    db_free_tree( comb->tree, &rt_uniresource );
    comb->tree = NULL;
  }else{
    /* make an empty combination structure */
    BU_GETSTRUCT( comb, rt_comb_internal );
    comb->magic = RT_COMB_MAGIC;
    comb->tree = TREE_NULL;
    bu_vls_init( &comb->shader );
    bu_vls_init( &comb->material );
  }

  if( dbip->dbi_version < 5 )
  {
	  new_name = new_name_v4;
	  if(dp == DIR_NULL)
		  NAMEMOVE(argv[1], new_name_v4);
	  else
		  NAMEMOVE(dp->d_namep, new_name_v4);
  } else {
	  if( dp == DIR_NULL )
		  new_name = argv[1];
	  else
		  new_name = dp->d_namep;
  }

  if(*argv[2] == 'y' || *argv[2] == 'Y')
    comb->region_flag = 1;
  else
    comb->region_flag = 0;

  if(comb->region_flag){
    if(argc != 11){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help put_comb");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }

    comb->region_id = atoi(argv[3]);
    comb->aircode = atoi(argv[4]);
    comb->GIFTmater = atoi(argv[5]);
    comb->los = atoi(argv[6]);

    /* use the new values for defaults */
    item_default = comb->region_id + 1;
    air_default = comb->aircode;
    mat_default = comb->GIFTmater;
    los_default = comb->los;
    offset = 6;
  }else{
    if(argc != 7){
      struct bu_vls vls;

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "help put_comb");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
    }
    offset = 2;
  }

  put_rgb_into_comb(comb, argv[offset + 1]);
  bu_vls_strcpy(&comb->shader, argv[offset +2]);

  if(*argv[offset + 3] == 'y' || *argv[offset + 3] == 'Y')
    comb->inherit = 1;
  else
    comb->inherit = 0;

  if(put_tree_into_comb(comb, dp, argv[1], new_name, argv[offset + 4]) == TCL_ERROR){
    if(comb){
      restore_comb(dp);
      Tcl_AppendResult(interp, "\toriginal restored\n", (char *)NULL);
a822 5
    (void)unlink(red_tmpfil);
    return TCL_ERROR;
  }else if(save_comb_flag){
    /* eliminate the temporary combination */
    char *av[3];
d824 24
a847 5
    av[0] = "kill";
    av[1] = red_tmpcomb;
    av[2] = NULL;
    (void)cmd_kill(clientData, interp, 2, av);
  }
d849 2
a850 2
  (void)unlink(red_tmpfil);
  return TCL_OK;
d856 31
a886 33
/*	Writes the file for later editing */
	struct rt_tree_array	*rt_tree_array;
	FILE			*fp;
	int			i;
	int			node_count;
	int			actual_count;

	if( comb )
		RT_CK_COMB( comb );

	/* open the file */
	if( (fp=fopen( red_tmpfil , "w" )) == NULL )
	{
	  Tcl_AppendResult(interp, "Cannot open create file for editing\n", (char *)NULL);
	  perror( "MGED" );
	  return(1);
	}

	if( !comb )
	{
		fprintf( fp, "NAME=%s\n", name );
		fprintf( fp, "REGION=No\n" );
		fprintf( fp, "REGION_ID=\n" );
		fprintf( fp, "AIRCODE=\n" );
		fprintf( fp, "GIFT_MATERIAL=\n" );
		fprintf( fp, "LOS=\n" );
		fprintf( fp, "COLOR=\n" );
		fprintf( fp, "SHADER=\n" );
		fprintf( fp, "INHERIT=No\n" );
		fprintf( fp, "COMBINATION:\n" );
		fclose( fp );
		return( 0 );
	}
d888 5
a892 23
	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
	{
		db_non_union_push( comb->tree, &rt_uniresource );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL );
			return( 1 );
		}
	}
	node_count = db_tree_nleaves( comb->tree );
	if( node_count > 0 )
	{
		rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count,
			sizeof( struct rt_tree_array ), "tree list" );
		actual_count = (struct rt_tree_array *)db_flatten_tree(
			rt_tree_array, comb->tree, OP_UNION,
			0, &rt_uniresource ) - rt_tree_array;
		BU_ASSERT_LONG( actual_count, ==, node_count );
	}
	else
	{
		rt_tree_array = (struct rt_tree_array *)NULL;
		actual_count = 0;
d894 13
d908 14
a921 17
	fprintf( fp, "NAME=%s\n", name );
	if( comb->region_flag )
	{
		fprintf( fp, "REGION=Yes\n" );
		fprintf( fp, "REGION_ID=%d\n", comb->region_id );
		fprintf( fp, "AIRCODE=%d\n", comb->aircode );
		fprintf( fp, "GIFT_MATERIAL=%d\n", comb->GIFTmater );
		fprintf( fp, "LOS=%d\n", comb->los );
	}
	else
	{
		fprintf( fp, "REGION=No\n" );
		fprintf( fp, "REGION_ID=\n" );
		fprintf( fp, "AIRCODE=\n" );
		fprintf( fp, "GIFT_MATERIAL=\n" );
		fprintf( fp, "LOS=\n" );
	}
d923 4
a926 4
	if( comb->rgb_valid )
		fprintf( fp, "COLOR= %d %d %d\n", V3ARGS( comb->rgb ) );
	else
		fprintf( fp, "COLOR=\n" );
d928 1
a928 1
	fprintf( fp, "SHADER=%s\n", bu_vls_addr( &comb->shader ) );
d930 1
a930 1
	fprintf( fp, "MATERIAL=%s\n", bu_vls_addr( &comb->material ) );
d932 6
a937 4
	if( comb->inherit )
		fprintf( fp, "INHERIT=Yes\n" );
	else
		fprintf( fp, "INHERIT=No\n" );
d939 2
a940 1
	fprintf( fp, "COMBINATION:\n" );
d942 21
a962 30
	for( i=0 ; i<actual_count ; i++ )
	{
		char op;

		switch( rt_tree_array[i].tl_op )
		{
			case OP_UNION:
				op = 'u';
				break;
			case OP_INTERSECT:
				op = '+';
				break;
			case OP_SUBTRACT:
				op = '-';
				break;
			default:
				Tcl_AppendResult(interp, "Illegal op code in tree\n",
					(char *)NULL );
				fclose( fp );
				return( 1 );
		}
		if( fprintf( fp , " %c %s" , op , rt_tree_array[i].tl_tree->tr_l.tl_name ) <= 0 )
		{
			Tcl_AppendResult(interp, "Cannot write to temp file (", red_tmpfil,
				"). Aborting edit\n", (char *)NULL );
			fclose( fp );
			return( 1 );
		}
		print_matrix( fp, rt_tree_array[i].tl_tree->tr_l.tl_mat );
		fprintf( fp, "\n" );
d964 5
a968 2
	fclose( fp );
	return( 0 );
d974 1
a974 1
/*	Do some minor checking of the edited file */
d976 21
a996 22
	FILE *fp;
	int node_count=0;
	int nonsubs=0;
	int i,j,done,ch;
	int done2,first;
	char relation;
	char name_v4[NAMESIZE+1];
	char *name_v5=NULL;
	char *name=NULL;
	char line[RT_MAXLINE] = {0};
	char lineCopy[RT_MAXLINE] = {0};
	char *ptr = (char *)NULL;
	int region=(-1);
	int id=0,air=0;
	int rgb_valid;

	if( (fp=fopen( red_tmpfil , "r" )) == NULL )
	{
	  Tcl_AppendResult(interp, "Cannot open create file for editing\n", (char *)NULL);
	  perror( "MGED" );
	  return(-1);
	}
d998 129
a1126 24
	/* Read a line at a time */
	done = 0;
	while( !done )
	{
		/* Read a line */
		i = (-1);

		while( (ch=getc( fp )) != EOF && ch != '\n' && i < RT_MAXLINE )
			line[++i] = ch;

		if( ch == EOF )	/* We must be done */
		{
			done = 1;
			if( i < 0 )
				break;
		}
		if( i == RT_MAXLINE )
		{
		  line[RT_MAXLINE-1] = '\0';
		  Tcl_AppendResult(interp, "Line too long in edited file:\n",
				   line, "\n", (char *)NULL);
		  fclose( fp );
		  return( -1 );
		}
d1128 36
a1163 2
		line[++i] = '\0';
		strcpy( lineCopy, line );
d1165 56
a1220 118
		/* skip leading white space */
		i = (-1);
		while( isspace( line[++i] ));

		if( line[i] == '\0' )
			continue;	/* blank line */

		if( (ptr=find_keyword(i, line, "NAME" ) ) )
		{
			if( dbip->dbi_version < 5 ) {
				int len;

				len = strlen( ptr );
				if( len >= NAMESIZE ) {
					while( len > 1 && isspace( ptr[len-1] ) )
						len--;
				}
				if( len >= NAMESIZE ) {
					Tcl_AppendResult(interp, "Name too long for v4 database: ",
						ptr, "\n", lineCopy, "\n", (char *)NULL );
					fclose( fp );
					return( -1 );
				}
			}
			continue;
		}
		else if( (ptr=find_keyword( i, line, "REGION_ID" ) ) )
		{
			id = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "REGION" ) ) )
		{
			if( *ptr == 'y' || *ptr == 'Y' )
				region = 1;
			else
				region = 0;
			continue;
		}
		else if( (ptr=find_keyword( i, line, "AIRCODE" ) ) )
		{
			air = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "GIFT_MATERIAL" ) ) )
		{
			continue;
		}
		else if( (ptr=find_keyword( i, line, "LOS" ) ) )
		{
			continue;
		}
		else if( (ptr=find_keyword( i, line, "COLOR" ) ) )
		{
			char *ptr2;

			rgb_valid = 1;
			ptr2 = strtok( ptr, delims );
			if( !ptr2 ) {
			    continue;
			} else {
			    ptr2 = strtok( (char *)NULL, delims );
			    if( !ptr2 ) {
				rgb_valid = 0;
			    } else {
				ptr2 = strtok( (char *)NULL, delims );
				if( !ptr2 ) {
				    rgb_valid = 0;
				}
			    }
			}
			if( !rgb_valid ) {
				Tcl_AppendResult(interp, "WARNING: invalid color specification!!! Must be three integers, each 0-255\n", (char *)NULL );
			}
			continue;
		}
		else if( (ptr=find_keyword( i, line, "SHADER" ) ) )
			continue;
#if 0
		else if( (ptr=find_keyword( i, line, "MATERIAL" ) ) )
			continue;
#endif
		else if( (ptr=find_keyword( i, line, "INHERIT" ) ) )
			continue;
		else if( !strncmp( &line[i], "COMBINATION:", 12 ) )
		{
			if( region < 0 )
			{
				Tcl_AppendResult(interp, "Region flag not correctly set\n",
					"\tMust be 'Yes' or 'No'\n", "\tNo Changes made\n",
					(char *)NULL );
				fclose( fp );
				return( -1 );
			}
			else if( region )
			{
				if( id < 0 )
				{
					Tcl_AppendResult(interp, "invalid region ID\n",
						"\tNo Changes made\n",
						(char *)NULL );
					fclose( fp );
					return( -1 );
				}
				if( air < 0 )
				{
					Tcl_AppendResult(interp, "invalid Air code\n",
						"\tNo Changes made\n",
						(char *)NULL );
					fclose( fp );
					return( -1 );
				}
				if( air == 0 && id == 0 )
					Tcl_AppendResult(interp, "Warning: both ID and Air codes are 0!!!\n", (char *)NULL );
				if( air && id )
					Tcl_AppendResult(interp, "Warning: both ID and Air codes are non-zero!!!\n", (char *)NULL );
			}
			continue;
d1223 3
a1225 108
		done2=0;
		first=1;
		ptr = strtok( line , delims );

		while (!done2) {
			if( name_v5 ) {
				bu_free( name_v5, "name_v5" );
				name_v5 = NULL;
			}
			/* First non-white is the relation operator */
			if( !ptr )
			{
				done2 = 1;
				break;
			}

			relation = (*ptr);
			if( relation == '\0' )
			{
				if (first)
					done = 1;

				done2 = 1;
				break;
			}
			first = 0;

			/* Next must be the member name */
			ptr = strtok( (char *)NULL, delims );
			name = NULL;
			if( ptr != NULL && *ptr != '\0' ) {
			    if( dbip->dbi_version < 5 ) {
				strncpy( name_v4 , ptr , NAMESIZE );
				name_v4[NAMESIZE] = '\0';

				/* Eliminate trailing white space from name */
				j = NAMESIZE;
				while( isspace( name_v4[--j] ) )
					name_v4[j] = '\0';
				name = name_v4;
			    } else {
				int len;

				len = strlen( ptr );
				name_v5 = (char *)bu_malloc( len + 1, "name_v5" );
				strcpy( name_v5, ptr );
				while( isspace( name_v5[len-1] ) ) {
					len--;
					name_v5[len] = '\0';
				}
				name = name_v5;
			    }
			}

			if( relation != '+' && relation != 'u' && relation != '-' )
			{
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls, " %c is not a legal operator\n" , relation );
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), lineCopy,
					   "\n", (char *)NULL);
			  bu_vls_free(&tmp_vls);
			  fclose( fp );
			  if( dbip->dbi_version >= 5 && name_v5 )
				  bu_free( name_v5, "name_v5" );
			  return( -1 );
			}

			if( relation != '-' )
				nonsubs++;

			if( name == NULL || name[0] == '\0' )
			{
				Tcl_AppendResult(interp, " operand name missing\n",
						 lineCopy, "\n", (char *)NULL);
				fclose( fp );
				if( dbip->dbi_version >= 5 && name_v5 )
					bu_free( name_v5, "name_v5" );
				return( -1 );
			}

			ptr = strtok( (char *)NULL, delims );
			if( !ptr )
				done2 = 1;
			else if(*ptr != 'u' &&
				(*ptr != '-' || *(ptr+1) != '\0') &&
				(*ptr != '+' || *(ptr+1) != '\0')) {
				int k;

				/* skip past matrix */
				for( k=1 ; k<16 ; k++ )
				{
					ptr = strtok( (char *)NULL, delims );
					if( !ptr)
					{
						Tcl_AppendResult(interp, "incomplete matrix\n",
								 lineCopy, "\n", (char *)NULL);
						fclose( fp );
						if( dbip->dbi_version >= 5 && name_v5 )
							bu_free( name_v5, "name_v5" );
						return( -1 );
					}
				}

				/* get the next relational operator on the current line */
				ptr = strtok( (char *)NULL, delims );
			}
d1227 1
a1227 2
			node_count++;
		}
d1229 1
d1231 2
a1232 2
	if( dbip->dbi_version >= 5 && name_v5 )
		bu_free( name_v5, "name_v5" );
d1234 1
a1234 1
	fclose( fp );
d1236 6
a1241 7
	if( nonsubs == 0 && node_count )
	{
	  Tcl_AppendResult(interp, "Cannot create a combination with all subtraction operators\n",
			   (char *)NULL);
	  return( -1 );
	}
	return( node_count );
d1247 7
a1253 2
	struct rt_db_internal	intern;
	union tree		*final_tree;
d1255 12
a1266 2
	if (tree_index)
		final_tree = (union tree *)db_mkgift_tree( rt_tree_array, node_count, &rt_uniresource );
d1268 1
a1268 1
		final_tree = (union tree *)NULL;
d1270 17
a1286 23
	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern.idb_type = ID_COMBINATION;
	intern.idb_meth = &rt_functab[ID_COMBINATION];
	intern.idb_ptr = (genptr_t)comb;
	comb->tree = final_tree;

	if (strcmp(new_name, old_name)) {
		int flags;

		if (comb->region_flag)
			flags = DIR_COMB | DIR_REGION;
		else
			flags = DIR_COMB;

		if (dp != DIR_NULL) {
			if (db_delete(dbip, dp) || db_dirdelete(dbip, dp)) {
				Tcl_AppendResult(interp, "ERROR: Unable to delete directory entry for ",
						 old_name, "\n", (char *)NULL);
				rt_comb_ifree(&intern, &rt_uniresource);
				return(1);
			}
		}
d1288 4
a1291 8
		if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
			Tcl_AppendResult(interp, "Cannot add ", new_name,
					 " to directory, no changes made\n", (char *)NULL);
			rt_comb_ifree(&intern, &rt_uniresource);
			return(1);
		}
	} else if( dp == DIR_NULL ) {
		int flags;
d1293 12
a1304 17
		if (comb->region_flag)
			flags = DIR_COMB | DIR_REGION;
		else
			flags = DIR_COMB;

		if ((dp=db_diradd(dbip, new_name, -1L, 0, flags, (genptr_t)&intern.idb_type)) == DIR_NULL) {
			Tcl_AppendResult(interp, "Cannot add ", new_name,
					 " to directory, no changes made\n", (char *)NULL);
			rt_comb_ifree( &intern, &rt_uniresource );
			return(1);
		}
	} else {
		if (comb->region_flag)
			dp->d_flags |= DIR_REGION;
		else
			dp->d_flags &= ~DIR_REGION;
	}
d1306 4
a1309 4
	if (rt_db_put_internal(dp, dbip, &intern, &rt_uniresource) < 0) {
		Tcl_AppendResult(interp, "ERROR: Unable to write new combination into database.\n", (char *)NULL);
		return 1;
	}
d1311 1
a1311 1
	return(0);
d1317 1
a1317 1
/*	Build the new combination by adding to the recently emptied combination
d1320 30
a1349 48
	FILE *fp;
	char relation;
	char *name=NULL, *new_name;
	char name_v4[NAMESIZE+1];
	char new_name_v4[NAMESIZE+1];
	char line[RT_MAXLINE] = {0};
	char *ptr;
	int ch;
	int i;
	int done=0;
	int done2;
	struct rt_tree_array *rt_tree_array;
	int tree_index=0;
	union tree *tp;
	matp_t matrix;
	int ret=0;

	if(dbip == DBI_NULL)
	  return 0;

	if( comb )
	{
		RT_CK_COMB( comb );
		RT_CK_DIR( dp );
	}

	if( (fp=fopen( red_tmpfil , "r" )) == NULL )
	{
	  Tcl_AppendResult(interp, " Cannot open edited file: ",
			   red_tmpfil, "\n", (char *)NULL);
	  return( 1 );
	}

	/* empty the existing combination */
	if( comb && comb->tree )
	{
		db_free_tree( comb->tree, &rt_uniresource );
		comb->tree = NULL;
	}
	else
	{
		/* make an empty combination structure */
		BU_GETSTRUCT( comb, rt_comb_internal );
		comb->magic = RT_COMB_MAGIC;
		comb->tree = TREE_NULL;
		bu_vls_init( &comb->shader );
		bu_vls_init( &comb->material );
	}
d1351 12
a1362 5
	/* build tree list */
	if( node_count )
		rt_tree_array = (struct rt_tree_array *)bu_calloc( node_count , sizeof( struct rt_tree_array ) , "tree list" );
	else
		rt_tree_array = (struct rt_tree_array *)NULL;
d1364 5
a1368 28
	if( dbip->dbi_version < 5 ) {
		if( dp == DIR_NULL )
			NAMEMOVE( old_name, new_name_v4 );
		else
			NAMEMOVE( dp->d_namep, new_name_v4 );
		new_name = new_name_v4;
	} else {
		if( dp == DIR_NULL )
			new_name = bu_strdup( old_name );
		else
			new_name = bu_strdup( dp->d_namep );
	}

	/* Read edited file */
	while( !done )
	{
		/* Read a line */
		i = (-1);

		while( (ch=getc( fp )) != EOF && ch != '\n' && i < RT_MAXLINE )
			line[++i] = ch;

		if( ch == EOF )	/* We must be done */
		{
			done = 1;
			if( i < 0 )
				break;
		}
d1370 12
a1381 1
		line[++i] = '\0';
d1383 107
a1489 114
		/* skip leading white space */
		i = (-1);
		while( isspace( line[++i] ));

		if( line[i] == '\0' )
			continue;	/* blank line */

		if( (ptr=find_keyword(i, line, "NAME" ) ) )
		{
			if( dbip->dbi_version < 5 )
				NAMEMOVE( ptr, new_name_v4 );
			else {
				bu_free( new_name, "new_name" );
				new_name = bu_strdup( ptr );
			}
			continue;
		}
		else if( (ptr=find_keyword( i, line, "REGION_ID" ) ) )
		{
			comb->region_id = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "REGION" ) ) )
		{
			if( *ptr == 'y' || *ptr == 'Y' )
				comb->region_flag = 1;
			else
				comb->region_flag = 0;
			continue;
		}
		else if( (ptr=find_keyword( i, line, "AIRCODE" ) ) )
		{
			comb->aircode = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "GIFT_MATERIAL" ) ) )
		{
			comb->GIFTmater = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "LOS" ) ) )
		{
			comb->los = atoi( ptr );
			continue;
		}
		else if( (ptr=find_keyword( i, line, "COLOR" ) ) )
		{
			char *ptr2;
			int value;

			ptr2 = strtok( ptr, delims );
			if( !ptr2 )
			{
				comb->rgb_valid = 0;
				continue;
			}
			value = atoi( ptr2 );
			if( value < 0 )
			{
				Tcl_AppendResult(interp, "Red value less than 0, assuming 0\n", (char *)NULL );
				value = 0;
			}
			if( value > 255 )
			{
				Tcl_AppendResult(interp, "Red value greater than 255, assuming 255\n", (char *)NULL );
				value = 255;
			}
			comb->rgb[0] = value;
			ptr2 = strtok( (char *)NULL, delims );
			if( !ptr2 )
			{
				Tcl_AppendResult(interp, "Invalid RGB value\n", (char *)NULL );
				comb->rgb_valid = 0;
				continue;
			}
			value = atoi( ptr2 );
			if( value < 0 )
			{
				Tcl_AppendResult(interp, "Green value less than 0, assuming 0\n", (char *)NULL );
				value = 0;
			}
			if( value > 255 )
			{
				Tcl_AppendResult(interp, "Green value greater than 255, assuming 255\n", (char *)NULL );
				value = 255;
			}
			comb->rgb[1] = value;
			ptr2 = strtok( (char *)NULL, delims );
			if( !ptr2 )
			{
				Tcl_AppendResult(interp, "Invalid RGB value\n", (char *)NULL );
				comb->rgb_valid = 0;
				continue;
			}
			value = atoi( ptr2 );
			if( value < 0 )
			{
				Tcl_AppendResult(interp, "Blue value less than 0, assuming 0\n", (char *)NULL );
				value = 0;
			}
			if( value > 255 )
			{
				Tcl_AppendResult(interp, "Blue value greater than 255, assuming 255\n", (char *)NULL );
				value = 255;
			}
			comb->rgb[2] = value;
			comb->rgb_valid = 1;
			continue;
		}
		else if( (ptr=find_keyword( i, line, "SHADER" ) ) )
		{
			bu_vls_strcpy( &comb->shader,  ptr );
			continue;
		}
d1491 4
a1494 5
		else if( (ptr=find_keyword( i, line, "MATERIAL" ) ) )
		{
			bu_vls_strcpy( &comb->material,  ptr );
			continue;
		}
d1496 70
a1565 110
		else if( (ptr=find_keyword( i, line, "INHERIT" ) ) )
		{
			if( *ptr == 'y' || *ptr == 'Y' )
				comb->inherit = 1;
			else
				comb->inherit = 0;
			continue;
		}
		else if( !strncmp( &line[i], "COMBINATION:", 12 ) )
			continue;

		done2=0;
		ptr = strtok( line, delims );
		while (!done2) {
			if ( !ptr )
			  break;

			/* First non-white is the relation operator */
			relation = (*ptr);
			if( relation == '\0' )
				break;

			/* Next must be the member name */
			ptr = strtok( (char *)NULL, delims );
			if( dbip->dbi_version < 5 ) {
				strncpy( name_v4 , ptr, NAMESIZE );
				name_v4[NAMESIZE] = '\0';
				name = name_v4;
			} else {
				if( name )
					bu_free( name, "name" );
				name = bu_strdup( ptr );
			}

			/* Eliminate trailing white space from name */
			if( dbip->dbi_version < 5 )
				i = NAMESIZE;
			else
				i = strlen( name );
			while( isspace( name[--i] ) )
				name[i] = '\0';

			/* Check for existence of member */
			if( (db_lookup( dbip , name , LOOKUP_QUIET )) == DIR_NULL )
			  Tcl_AppendResult(interp, "\tWARNING: '", name, "' does not exist\n", (char *)NULL);
			/* get matrix */
			ptr = strtok( (char *)NULL, delims );
			if( !ptr ){
				matrix = (matp_t)NULL;
				done2 = 1;
			}else if(*ptr == 'u' ||
				(*ptr == '-' && *(ptr+1) == '\0') ||
				(*ptr == '+' && *(ptr+1) == '\0')) {
				/* assume another relational operator */
				matrix = (matp_t)NULL;
			}else
			{
				int k;

				matrix = (matp_t)bu_calloc( 16, sizeof( fastf_t ), "red: matrix" );
				matrix[0] = atof( ptr );
				for( k=1 ; k<16 ; k++ )
				{
					ptr = strtok( (char *)NULL, delims );
					if( !ptr )
					{
						Tcl_AppendResult(interp, "incomplete matrix for member ",
							name, " No changes made\n", (char *)NULL );
						bu_free( (char *)matrix, "red: matrix" );
						if( rt_tree_array )
							bu_free( (char *)rt_tree_array, "red: tree list" );
						fclose( fp );
						return( 1 );
					}
					matrix[k] = atof( ptr );
				}
				if( bn_mat_is_identity( matrix ) )
				{
					bu_free( (char *)matrix, "red: matrix" );
					matrix = (matp_t)NULL;
				}

				ptr = strtok( (char *)NULL, delims );
				if (ptr == (char *)NULL)
					done2 = 1;
			}

			/* Add it to the combination */
			switch( relation )
			{
				case '+':
					rt_tree_array[tree_index].tl_op = OP_INTERSECT;
					break;
				case '-':
					rt_tree_array[tree_index].tl_op = OP_SUBTRACT;
					break;
				default:
					Tcl_AppendResult(interp, "unrecognized relation (assume UNION)\n",
						(char *)NULL );
				case 'u':
					rt_tree_array[tree_index].tl_op = OP_UNION;
					break;
			}
			BU_GETUNION( tp, tree );
			rt_tree_array[tree_index].tl_tree = tp;
			tp->tr_l.magic = RT_TREE_MAGIC;
			tp->tr_l.tl_op = OP_DB_LEAF;
			tp->tr_l.tl_name = bu_strdup( name );
			tp->tr_l.tl_mat = matrix;
			tree_index++;
d1567 32
d1600 1
d1602 1
a1602 1
	fclose( fp );
d1604 1
a1604 1
	ret = make_tree(comb, dp, node_count, old_name, new_name, rt_tree_array, tree_index);
d1606 5
a1610 5
	if( dbip->dbi_version >= 5 ) {
		if( name )
			bu_free( name, "name " );
		bu_free( new_name, "new_name" );
	}
d1612 1
a1612 1
	return( ret );
d1618 3
a1620 3
/* Make a temporary name for a combination
	a template name is expected as in "mk_temp()" with
	5 trailing X's */
d1622 2
a1623 2
	int counter,done;
	char *ptr;
d1626 2
a1627 2
	if(dbip == DBI_NULL)
	  return;
d1629 1
a1629 1
	/* Set "ptr" to start of X's */
d1631 3
a1633 3
	ptr = str;
	while( *ptr != '\0' )
		ptr++;
d1635 2
a1636 2
	while( *(--ptr) == 'X' );
	ptr++;
d1639 9
a1647 10
	counter = 1;
	done = 0;
	while( !done && counter < 99999 )
	{
		sprintf( ptr , "%d" , counter );
		if( db_lookup( dbip , str , LOOKUP_QUIET ) == DIR_NULL )
			done = 1;
		else
			counter++;
	}
d1652 1
a1652 1
/* Save a combination under a temporory name */
d1654 2
a1655 2
	register struct directory	*dp;
	struct rt_db_internal		intern;
d1657 2
a1658 2
	if(dbip == DBI_NULL)
	  return 0;
d1660 2
a1661 2
	/* Make a new name */
	mktemp_comb( red_tmpcomb );
d1663 2
a1664 2
	if( rt_db_get_internal( &intern, dpold, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		TCL_READ_ERR_return;
d1666 5
a1670 5
	if( (dp=db_diradd( dbip, red_tmpcomb, -1L, 0, dpold->d_flags, (genptr_t)&intern.idb_type)) == DIR_NULL )  {
	  Tcl_AppendResult(interp, "Cannot save copy of ", dpold->d_namep,
			   ", no changes made\n", (char *)NULL);
	  return( 1 );
	}
d1672 5
a1676 6
	if( rt_db_put_internal(	dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "Cannot save copy of ", dpold->d_namep,
			", no changes made\n", (char *)NULL);
		return( 1 );
	}
d1678 1
a1678 1
	return( 0 );
d1685 2
a1686 2
  char *av[4];
  char *name;
d1688 2
a1689 2
  /* Save name of original combo */
  name = bu_strdup( dp->d_namep );
d1691 5
a1695 5
  av[0] = "kill";
  av[1] = name;
  av[2] = NULL;
  av[3] = NULL;
  (void)cmd_kill((ClientData)NULL, interp, 2, av);
d1697 3
a1699 3
  av[0] = "mv";
  av[1] = red_tmpcomb;
  av[2] = name;
d1701 1
a1701 1
  (void)cmd_name((ClientData)NULL, interp, 3, av);
d1703 1
a1703 1
  bu_free( name, "bu_strdup'd name" );
@


14.10
log
@Improved error checking
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.9 2006/07/09 19:17:16 brlcad Exp $ (BRL)";
a90 3
#if 0
	CHECK_READ_ONLY;
#endif
d165 5
a255 3
	if( bn_mat_is_identity( matrix ) )
		return;

@


14.9
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.8 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
d1008 1
d1039 5
a1043 2
		  Tcl_AppendResult(interp, "Line too long in edited file\n", (char *)NULL);
		  return( 1 );
d1047 1
d1067 4
a1070 1
					Tcl_AppendResult(interp, "Name too long for v4 database: ", ptr, "\n", (char *)NULL );
d1075 5
a1087 5
		else if( (ptr=find_keyword( i, line, "REGION_ID" ) ) )
		{
			id = atoi( ptr );
			continue;
		}
d1107 5
a1111 2
			if( !ptr2 )
			{
d1113 6
a1118 1
				continue;
d1120 2
a1121 11
			ptr2 = strtok( (char *)NULL, delims );
			if( !ptr2 )
			{
				rgb_valid = 0;
				continue;
			}
			ptr2 = strtok( (char *)NULL, delims );
			if( !ptr2 )
			{
				rgb_valid = 0;
				continue;
a1122 2
			if( !rgb_valid )
				Tcl_AppendResult(interp, "Invalid color specification!!! Must be three integers, each 0-255\n", (char *)NULL );
d1141 1
a1141 1
				return( 1 );
d1151 1
a1151 1
					return( 1 );
d1159 1
a1159 1
					return( 1 );
d1199 2
a1200 1
			if( dbip->dbi_version < 5 ) {
d1209 1
a1209 1
			} else {
d1220 1
d1229 2
a1230 1
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
d1233 1
a1233 1
			  if( dbip->dbi_version >= 5 )
d1237 1
d1243 2
a1244 1
				Tcl_AppendResult(interp, " operand name missing\n", (char *)NULL);
d1246 1
a1246 1
				if( dbip->dbi_version >= 5 )
d1265 2
a1266 1
						Tcl_AppendResult(interp, "expecting a matrix\n", (char *)NULL);
d1268 1
a1268 1
						if( dbip->dbi_version >= 5 )
@


14.8
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.7 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d1007 2
a1008 2
	char line[MAXLINE];
	char *ptr;
d1027 1
a1027 1
		while( (ch=getc( fp )) != EOF && ch != '\n' && i<MAXLINE )
d1036 1
a1036 1
		if( i == MAXLINE )
d1366 1
a1366 1
	char line[MAXLINE];
d1435 1
a1435 1
		while( (ch=getc( fp )) != EOF && ch != '\n' && i<MAXLINE )
@


14.7
log
@update copyright to 2006
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.6 2005/10/31 07:30:58 brlcad Exp $ (BRL)";
d40 1
@


14.6
log
@header cleanup, reorg, and general bug squashing including adding missing headers
@
text
@d4 1
a4 1
 * Copyright (C) 1992-2005 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.5 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
@


14.5
log
@trailing ws
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.4 2005/05/28 02:14:52 brlcad Exp $ (BRL)";
d48 4
d57 2
a60 1
#include <ctype.h>
@


14.4
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d28 1
a28 1
 *  
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
d749 1
a749 1
    
d1173 1
a1173 1
			
d1595 1
a1595 1
	
d1692 1
a1692 1
	a template name is expected as in "mk_temp()" with 
d1752 1
a1752 1
	
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a47 4
#include <ctype.h>
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
a52 2
#include "db.h"

d55 1
d749 1
a749 1

d1173 1
a1173 1

d1595 1
a1595 1

d1692 1
a1692 1
	a template name is expected as in "mk_temp()" with
d1752 1
a1752 1

@


14.3
log
@update copyright to 2005
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/red.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
a39 2


d43 1
a43 1
#	include <string.h>
d45 1
a45 1
#	include <strings.h>
d60 1
a60 1
#ifndef WIN32
d119 1
a119 1
#ifdef WIN32
d141 1
a141 1
#ifdef WIN32
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1992-2004 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/red.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			R E D . C
a32 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1992-2004 by the United States Army.
 *	All rights reserved.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/red.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/red.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d1767 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/red.c,v 1.2 2004/06/08 22:04:29 morrison Exp $ (BRL)";
d29 1
a29 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/red.c,v 11.71 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a40 1
#include "externs.h"
@

