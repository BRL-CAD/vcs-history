head	14.30;
access;
symbols
	rel-7-10-4:14.28.2.1
	STABLE:14.28.0.2
	stable-branch:14.3
	rel-7-10-2:14.28
	rel-7-10-0:14.21
	rel-7-8-4:14.18
	rel-7-8-2:14.10
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.4.2.1
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.7
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.30
date	2007.10.19.19.54.54;	author bob1961;	state Exp;
branches;
next	14.29;

14.29
date	2007.09.15.16.23.16;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.06.27.09.18.21;	author brlcad;	state Exp;
branches
	14.28.2.1;
next	14.27;

14.27
date	2007.06.16.01.10.45;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.05.14.20.23.18;	author bob1961;	state Exp;
branches;
next	14.25;

14.25
date	2007.05.07.03.58.42;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.05.06.22.41.15;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.05.06.19.18.16;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.04.23.13.30.20;	author joevalleyfield;	state Exp;
branches;
next	14.21;

14.21
date	2007.02.20.08.19.49;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.23.01.13.41;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.08.24.03.01.31;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.08.24.02.36.49;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.08.08.05.56.44;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.08.05.55.24;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.08.08.02.54.43;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.08.07.16.04.39;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.07.12.01.52.22;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.07.09.19.17.16;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.05.22.15.11.46;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.7;

14.7
date	2005.11.11.21.44.16;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.09.16.18.51.53;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.05.28.02.14.51;	author brlcad;	state Exp;
branches
	14.4.2.1
	14.4.6.1;
next	14.3;

14.3
date	2005.01.30.20.31.05;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.17.26;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.26;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.20;	author morrison;	state Exp;
branches;
next	;

14.4.2.1
date	2005.09.08.16.09.50;	author bob1961;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;

14.28.2.1
date	2007.09.28.14.04.33;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.30
log
@Minor mods for getting things compiled on Windows.
@
text
@/*                        A T T A C H . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file attach.c
 *
 * Functions -
 *	f_refresh	request display refresh
 *	f_attach	attach display device
 *	attach		attach to a given display processor
 *	f_release	release display device
 *	release		guts for f_release
 *      gui_setup	called by loadtk to initialize the gui
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.29 2007/09/15 16:23:16 brlcad Exp $ (BRL)";
#endif

#if defined(_WIN32) && !defined(__CYGWIN__)
#define WIN32_INCLUDE_ORDER_HACK
#endif

#if defined(WIN32_INCLUDE_ORDER_HACK)
#ifdef _WIN32
#  include <winsock2.h>
#endif
#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>		/* for struct timeval */
#endif

#include "itk.h"
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#if !defined(WIN32_INCLUDE_ORDER_HACK)
#ifdef _WIN32
#  include <winsock2.h>
#endif
#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>		/* for struct timeval */
#endif

#include "tcl.h"
#include "tk.h"
#include "itk.h"
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "dm-Null.h"

#include "./ged.h"
#include "./titles.h"
#include "./sedit.h"
#include "./mged_solid.h"
#include "./mged_dm.h"

#define NEED_GUI(_type) ( \
	IS_DM_TYPE_WGL(_type) || \
	IS_DM_TYPE_OGL(_type) || \
	IS_DM_TYPE_GLX(_type) || \
	IS_DM_TYPE_PEX(_type) || \
	IS_DM_TYPE_TK(_type) || \
	IS_DM_TYPE_X(_type) )

/* All systems can compile these! */
extern int Plot_dm_init(struct dm_list *o_dm_list, int argc, char **argv);
extern int PS_dm_init(struct dm_list *o_dm_list, int argc, char **argv);

#ifdef DM_X
extern int X_dm_init();
extern void X_fb_open();
#endif /* DM_X */

#ifdef DM_TK
extern int tk_dm_init();
extern void tk_fb_open();
#endif /* DM_TK */

#ifdef DM_WGL
extern int Wgl_dm_init();
extern void Wgl_fb_open();
#endif /* DM_WGL */

#ifdef DM_OGL
extern int Ogl_dm_init();
extern void Ogl_fb_open();
#endif /* DM_OGL */

#ifdef DM_GLX
extern int Glx_dm_init();
#endif /* DM_GLX */

#ifdef DM_PEX
extern int Pex_dm_init();
#endif /* DM_PEX */

extern void set_port(void);		/* defined in fbserv.c */
extern void share_dlist(struct dm_list *dlp2);	/* defined in share.c */
extern void predictor_init(void);	/* defined in predictor.c */
extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */

extern struct _color_scheme default_color_scheme;

int mged_default_dlist = 0;   /* This variable is available via Tcl for controlling use of display lists */
struct dm_list head_dm_list;  /* list of active display managers */
struct dm_list *curr_dm_list = (struct dm_list *)NULL;
static int windowbounds[6] = { XMIN, XMAX, YMIN, YMAX, (int)GED_MIN, (int)GED_MAX };

struct w_dm which_dm[] = {
  { DM_TYPE_PLOT, "plot", Plot_dm_init },  /* DM_PLOT_INDEX defined in mged_dm.h */
  { DM_TYPE_PS, "ps", PS_dm_init },      /* DM_PS_INDEX defined in mged_dm.h */
#ifdef DM_X
  { DM_TYPE_X, "X", X_dm_init },
#endif /* DM_X */
#ifdef DM_TK
  { DM_TYPE_TK, "tk", tk_dm_init },
#endif /* DM_TK */
#ifdef DM_WGL
  { DM_TYPE_WGL, "wgl", Wgl_dm_init },
#endif /* DM_WGL */
#ifdef DM_OGL
  { DM_TYPE_OGL, "ogl", Ogl_dm_init },
#endif /* DM_OGL */
#ifdef DM_GLX
  { DM_TYPE_GLX, "glx", Glx_dm_init },
#endif /* DM_GLX */
#ifdef DM_PEX
  { DM_TYPE_PEX, "pex", Pex_dm_init },
#endif /* DM_PEX */
  { -1, (char *)NULL, (int (*)())NULL}
};


void
mged_fb_open(void)
{
#ifdef DM_X
  if(dmp->dm_type == DM_TYPE_X)
    X_fb_open();
#endif /* DM_X */
#ifdef DM_TK
  if(dmp->dm_type == DM_TYPE_TK)
    tk_fb_open();
#endif /* DM_TK */
#ifdef DM_WGL
  if(dmp->dm_type == DM_TYPE_WGL)
      Wgl_fb_open();
#endif /* DM_WGL */
#ifdef DM_OGL
  if(dmp->dm_type == DM_TYPE_OGL)
      Ogl_fb_open();
#endif /* DM_OGL */
}


void
mged_fb_close(void)
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "fb_close_existing %lu", fbp);
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  fbp = (FBIO *)0;
}


void
mged_slider_init_vls(struct dm_list *p)
{
  bu_vls_init(&p->dml_fps_name);
  bu_vls_init(&p->dml_aet_name);
  bu_vls_init(&p->dml_ang_name);
  bu_vls_init(&p->dml_center_name);
  bu_vls_init(&p->dml_size_name);
  bu_vls_init(&p->dml_adc_name);
}


void
mged_slider_free_vls(struct dm_list *p)
{
  if (BU_VLS_IS_INITIALIZED(&p->dml_fps_name)) {
    bu_vls_free(&p->dml_fps_name);
    bu_vls_free(&p->dml_aet_name);
    bu_vls_free(&p->dml_ang_name);
    bu_vls_free(&p->dml_center_name);
    bu_vls_free(&p->dml_size_name);
    bu_vls_free(&p->dml_adc_name);
  }
}


int
release(char *name, int need_close)
{
  struct dm_list *save_dm_list = DM_LIST_NULL;

  if(name != NULL){
    struct dm_list *p;

    if(!strcmp("nu", name))
      return TCL_OK;  /* Ignore */

    FOR_ALL_DISPLAYS(p, &head_dm_list.l){
      if(strcmp(name, bu_vls_addr(&p->dml_dmp->dm_pathName)))
	continue;

      /* found it */
      if(p != curr_dm_list){
	save_dm_list = curr_dm_list;
	curr_dm_list = p;
      }
      break;
    }

    if(p == &head_dm_list){
      Tcl_AppendResult(interp, "release: ", name,
		       " not found\n", (char *)NULL);
      return TCL_ERROR;
    }
  }else if(dmp && !strcmp("nu", bu_vls_addr(&pathName)))
      return TCL_OK;  /* Ignore */

  if(fbp){
    if(mged_variables->mv_listen){
      /* drop all clients */
      mged_variables->mv_listen = 0;
      set_port();
    }

    /* release framebuffer resources */
    mged_fb_close();
  }

  /*
   *  This saves the state of the resoures to the "nu" display manager, which
   *  is beneficial only if closing the last display manager. So when
   *  another display manager is opened, it looks like the last one
   *  the user had open. This depends on "nu" always being last in the list.
   */
  usurp_all_resources(BU_LIST_LAST(dm_list, &head_dm_list.l), curr_dm_list);

  /* If this display is being referenced by a command window,
     then remove the reference  */
  if(curr_dm_list->dml_tie != NULL)
    curr_dm_list->dml_tie->cl_tie = (struct dm_list *)NULL;

  if(need_close)
    DM_CLOSE(dmp);

  RT_FREE_VLIST(&curr_dm_list->dml_p_vlist);
  BU_LIST_DEQUEUE( &curr_dm_list->l );
  mged_slider_free_vls(curr_dm_list);
  bu_free( (genptr_t)curr_dm_list, "release: curr_dm_list" );

  if(save_dm_list != DM_LIST_NULL)
    curr_dm_list = save_dm_list;
  else
    curr_dm_list = (struct dm_list *)head_dm_list.l.forw;

  return TCL_OK;
}

int
f_release(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if(argc < 1 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help release");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if(argc == 2){
    int status;
    struct bu_vls vls1;

    bu_vls_init(&vls1);

    if(*argv[1] != '.')
      bu_vls_printf(&vls1, ".%s", argv[1]);
    else
      bu_vls_strcpy(&vls1, argv[1]);

    status = release(bu_vls_addr(&vls1), 1);

    bu_vls_free(&vls1);
    return status;
  }else
    return release((char *)NULL, 1);
}


void
print_valid_dm(void)
{
    int i = 0;
    Tcl_AppendResult(interp, "\tThe following display manager types are valid: ", (char *)NULL);
#ifdef DM_X
    Tcl_AppendResult(interp, "X  ", (char *)NULL);
    i++;
#endif /* DM_X */
#ifdef DM_TK
    Tcl_AppendResult(interp, "tk  ", (char *)NULL);
    i++;
#endif /* DM_TK */
#ifdef DM_WGL
    Tcl_AppendResult(interp, "wgl  ", (char *)NULL);
    i++;
#endif /* DM_WGL */
#ifdef DM_OGL
    Tcl_AppendResult(interp, "ogl  ", (char *)NULL);
    i++;
#endif /* DM_OGL */
#ifdef DM_GLX
    Tcl_AppendResult(interp, "glx", (char *)NULL);
    i++;
#endif /* DM_GLX */
    if (i==0) {
	Tcl_AppendResult(interp, "NONE AVAILABLE", (char *)NULL);
    }
    Tcl_AppendResult(interp, "\n", (char *)NULL);
}


int
f_attach(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  register struct w_dm *wp;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help attach");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    print_valid_dm();
    return TCL_ERROR;
  }

  /* Look at last argument, skipping over any options which preceed it */
  for( wp = &which_dm[2]; wp->type != -1; wp++ )
    if( strcmp(argv[argc - 1], wp->name ) == 0 )
      break;

  if(wp->type == -1){
    Tcl_AppendResult(interp, "attach(", argv[argc - 1], "): BAD\n", (char *)NULL);
    print_valid_dm();
    return TCL_ERROR;
  }

  return mged_attach(wp, argc, argv);
}


int
gui_setup(char *dstr)
{
  /* initialize only once */
  if(tkwin != NULL)
    return TCL_OK;

  Tcl_ResetResult(interp);

  /* set DISPLAY to dstr */
  if(dstr != (char *)NULL){
    Tcl_SetVar(interp, "env(DISPLAY)", dstr, TCL_GLOBAL_ONLY);
#ifdef HAVE_SETENV
    setenv("DISPLAY", dstr, 0);
#endif
  }

  /* This runs the tk.tcl script */
  if (Tk_Init(interp) == TCL_ERROR) {
      const char *result = Tcl_GetStringResult(interp);
      /* hack to avoid a stupid Tk error */
      if (strncmp(result, "this isn't a Tk applicationcouldn't", 35) == 0) {
	  result = (result + 27);
	  Tcl_ResetResult(interp);
	  Tcl_AppendResult(interp, result, (char *)NULL);
      }
      return TCL_ERROR;
  }

  /* Initialize [incr Tk] */
  if (Itk_Init(interp) == TCL_ERROR) {
    return TCL_ERROR;
  }

  /* Import [incr Tk] commands into the global namespace */
  if (Tcl_Import(interp, Tcl_GetGlobalNamespace(interp),
		 "::itk::*", /* allowOverwrite */ 1) != TCL_OK) {
    return TCL_ERROR;
  }

  /* Initialize the Iwidgets package */
  if (Tcl_Eval(interp, "package require Iwidgets") != TCL_OK) {
    return TCL_ERROR;
  }

  /* Import iwidgets into the global namespace */
  if (Tcl_Import(interp, Tcl_GetGlobalNamespace(interp),
		 "::iwidgets::*", /* allowOverwrite */ 1) != TCL_OK) {
    return TCL_ERROR;
  }

#ifdef BRLCAD_DEBUG
  /* Initialize libdm */
  (void)Dm_d_Init(interp);

  /* Initialize libfb */
  (void)Fb_d_Init(interp);
#else
  /* Initialize libdm */
  (void)Dm_Init(interp);

  /* Initialize libfb */
  (void)Fb_Init(interp);
#endif

  if((tkwin = Tk_MainWindow(interp)) == NULL){
    return TCL_ERROR;
  }

  /* create the event handler */
  Tk_CreateGenericHandler(doEvent, (ClientData)NULL);

  Tcl_Eval(interp, "wm withdraw .");
  Tcl_Eval(interp, "tk appname mged");

  return TCL_OK;
}


int
mged_attach(
	struct w_dm *wp,
	int argc,
	char *argv[])
{
  register struct dm_list *o_dm_list;

  if (!wp) {
      return TCL_ERROR;
  }

  o_dm_list = curr_dm_list;
  BU_GETSTRUCT(curr_dm_list, dm_list);

  /* initialize predictor stuff */
  BU_LIST_INIT(&curr_dm_list->dml_p_vlist);
  predictor_init();

  /* Only need to do this once */
  if(tkwin == NULL && NEED_GUI(wp->type)){
    struct dm *tmp_dmp;
    struct bu_vls tmp_vls;

    /* look for "-d display_string" and use it if provided */
    BU_GETSTRUCT(tmp_dmp, dm);
    bu_vls_init(&tmp_dmp->dm_pathName);
    bu_vls_init(&tmp_dmp->dm_dName);
    bu_vls_init(&tmp_vls);
    dm_processOptions(tmp_dmp, &tmp_vls, argc - 1, argv + 1);
    if(strlen(bu_vls_addr(&tmp_dmp->dm_dName))){
      if(gui_setup(bu_vls_addr(&tmp_dmp->dm_dName)) == TCL_ERROR){
	bu_free( (genptr_t)curr_dm_list, "f_attach: dm_list" );
	curr_dm_list = o_dm_list;
	bu_vls_free(&tmp_dmp->dm_pathName);
	bu_vls_free(&tmp_dmp->dm_dName);
	bu_vls_free(&tmp_vls);
	bu_free((genptr_t)tmp_dmp, "mged_attach: tmp_dmp");
	return TCL_ERROR;
      }
    } else if(gui_setup((char *)NULL) == TCL_ERROR){
      bu_free( (genptr_t)curr_dm_list, "f_attach: dm_list" );
      curr_dm_list = o_dm_list;
      bu_vls_free(&tmp_dmp->dm_pathName);
      bu_vls_free(&tmp_dmp->dm_dName);
      bu_vls_free(&tmp_vls);
      bu_free((genptr_t)tmp_dmp, "mged_attach: tmp_dmp");
      return TCL_ERROR;
    }

    bu_vls_free(&tmp_dmp->dm_pathName);
    bu_vls_free(&tmp_dmp->dm_dName);
    bu_vls_free(&tmp_vls);
    bu_free((genptr_t)tmp_dmp, "mged_attach: tmp_dmp");
  }

  BU_LIST_APPEND(&head_dm_list.l, &curr_dm_list->l);

  if (!wp->name || !wp->init) {
      return TCL_ERROR;
  }

  if(wp->init(o_dm_list, argc, argv) == TCL_ERROR) {
    goto Bad;
  }

  /* initialize the background color */
  cs_set_bg();

  mged_link_vars(curr_dm_list);

  Tcl_ResetResult(interp);
  Tcl_AppendResult(interp, "ATTACHING ", dmp->dm_name, " (", dmp->dm_lname,
		   ")\n", (char *)NULL);

#ifdef DO_DISPLAY_LISTS
  share_dlist(curr_dm_list);

  if(displaylist && mged_variables->mv_dlist && !dlist_state->dl_active){
    createDLists(&dgop->dgo_headSolid);
    dlist_state->dl_active = 1;
  }
#endif

  DM_SET_WIN_BOUNDS(dmp, windowbounds);
  mged_fb_open();

  return TCL_OK;

Bad:
  Tcl_AppendResult(interp, "attach(", argv[argc - 1], "): BAD\n", (char *)NULL);

  if(dmp != (struct dm *)0)
    release((char *)NULL, 1);  /* release() will call dm_close */
  else
    release((char *)NULL, 0);  /* release() will not call dm_close */

  return TCL_ERROR;
}

void
get_attached(void)
{
  int argc;
  char *argv[3];
  char line[80] = {0};
  struct w_dm *wp = (struct w_dm *)NULL;
  int inflimit = 1000;
  char *ret = (char *)NULL;

  while(inflimit > 0){
    memset(line, 0, 80);

    bu_log("attach (nu");

    /* print all the available display manager types, skipping plot and ps */
    wp = &which_dm[2];
    for( ; wp->type != -1; wp++ ) {
	bu_log("|%s", wp->name);
    }
    bu_log(")[nu]? ");

    ret = bu_fgets(line, sizeof(line), stdin); /* \n, Null terminated */

    /* handle EOF */
    if (!ret) {
	bu_log("\n");
	return;
    }

    if(line[0] == '\n' || strncmp(line, "nu", 2) == 0) {
	return;  /* Nothing more to do. */
    }

    line[strlen(line)-1] = '\0';        /* remove newline */

    for( wp = &which_dm[2]; wp->type != -1; wp++ ) {
	if( strcmp( line, wp->name ) == 0 ) {
	    break;
	}
    }

    if( wp->type != -1 ) {
	break;
    }

    /* Not a valid choice, loop. */
    inflimit--;
  }

  if (inflimit <= 0) {
      bu_log("\nInfinite Loop protection, attach aborted!\n");
      return;
  }

  argc = 2;
  argv[0] = "";
  argv[1] = "";
  argv[2] = (char *)NULL;
  (void)mged_attach(wp, argc, argv);
}


/*
 *			F _ D M
 *
 *  Run a display manager specific command(s).
 */
int
f_dm(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  if( !cmd_hook ){
    Tcl_AppendResult(interp, "The '", dmp->dm_name,
		     "' display manager does not support local commands.\n",
		     (char *)NULL);
    return TCL_ERROR;
  }

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help dm");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  return cmd_hook( argc-1, argv+1 );
}

/*
 *			 I S _ D M _ N U L L
 *
 *  Returns -
 *	 0	If the display manager goes to a real screen.
 *	!0	If the null display manager is attached.
 */
int
is_dm_null(void)
{
  return(curr_dm_list == &head_dm_list);
}


void
dm_var_init(struct dm_list *initial_dm_list)
{
  BU_GETSTRUCT(adc_state, _adc_state);
  *adc_state = *initial_dm_list->dml_adc_state;			/* struct copy */
  adc_state->adc_rc = 1;
#if 0
  adc_state->adc_a1 = adc_state->adc_a2 = 45.0;
#endif

  BU_GETSTRUCT(menu_state, _menu_state);
  *menu_state = *initial_dm_list->dml_menu_state;		/* struct copy */
  menu_state->ms_rc = 1;

  BU_GETSTRUCT(rubber_band, _rubber_band);
  *rubber_band = *initial_dm_list->dml_rubber_band;		/* struct copy */
  rubber_band->rb_rc = 1;

  BU_GETSTRUCT(mged_variables, _mged_variables);
  *mged_variables = *initial_dm_list->dml_mged_variables;	/* struct copy */
  mged_variables->mv_rc = 1;
  mged_variables->mv_dlist = mged_default_dlist;
  mged_variables->mv_listen = 0;
  mged_variables->mv_port = 0;
  mged_variables->mv_fb = 0;

  BU_GETSTRUCT(color_scheme, _color_scheme);
#if 0
  /* initialize using the last curr_dm_list */
  *color_scheme = *initial_dm_list->dml_color_scheme;		/* struct copy */
#else
  /* initialize using the nu display manager */
  *color_scheme = *BU_LIST_LAST(dm_list, &head_dm_list.l)->dml_color_scheme;
#endif
  color_scheme->cs_rc = 1;

  BU_GETSTRUCT(grid_state, _grid_state);
  *grid_state = *initial_dm_list->dml_grid_state;		/* struct copy */
  grid_state->gr_rc = 1;

  BU_GETSTRUCT(axes_state, _axes_state);
  *axes_state = *initial_dm_list->dml_axes_state;		/* struct copy */
  axes_state->ax_rc = 1;

  BU_GETSTRUCT(dlist_state, _dlist_state);
  dlist_state->dl_rc = 1;

  BU_GETSTRUCT(view_state, _view_state);
  *view_state = *initial_dm_list->dml_view_state;			/* struct copy */
  view_state->vs_vop = vo_open_cmd("");
  *view_state->vs_vop = *initial_dm_list->dml_view_state->vs_vop;	/* struct copy */
  view_state->vs_vop->vo_clientData = view_state;
  view_state->vs_rc = 1;
  view_ring_init(curr_dm_list->dml_view_state, (struct _view_state *)NULL);

  dirty = 1;
  mapped = 1;
  netfd = -1;
  owner = 1;
  am_mode = AMM_IDLE;
  adc_auto = 1;
  grid_auto_size = 1;
}


void
mged_link_vars(struct dm_list *p)
{
  mged_slider_init_vls(p);

  bu_vls_printf(&p->dml_fps_name, "%s(%S,fps)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_aet_name, "%s(%S,aet)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_ang_name, "%s(%S,ang)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_center_name, "%s(%S,center)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_size_name, "%s(%S,size)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
  bu_vls_printf(&p->dml_adc_name, "%s(%S,adc)", MGED_DISPLAY_VAR,
		&p->dml_dmp->dm_pathName);
}

int
f_get_dm_list(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  struct dm_list *dlp;

  if(argc != 1){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel get_dm_list");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
    Tcl_AppendElement(interp, bu_vls_addr(&dlp->dml_dmp->dm_pathName));

  return TCL_OK;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.29
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d39 16
a54 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.28 2007/06/27 09:18:21 brlcad Exp $ (BRL)";
d63 1
d74 1
a87 1

@


14.28
log
@remove the final few remaining references to interp->result (both comments and code)
@
text
@d39 1
a39 5
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.27 2007/06/16 01:10:45 brlcad Exp $ (BRL)";
#endif

#ifdef _WIN32
#  include <winsock2.h>
d46 4
a49 4
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
@


14.28.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d39 5
a43 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.29 2007/09/15 16:23:16 brlcad Exp $ (BRL)";
d50 4
a53 4
#include <string.h>

#ifdef _WIN32
#  include <winsock2.h>
@


14.27
log
@jeebus, why in the world is a vls being used for a constant string..
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.26 2007/05/14 20:23:18 bob1961 Exp $ (BRL)";
d400 2
a401 1
  if(Tk_Init(interp) == TCL_ERROR){
d403 4
a406 2
      if (strncmp(interp->result, "this isn't a Tk applicationcouldn't", 35) == 0) {
	  interp->result = (interp->result + 27);
@


14.26
log
@Include winsock2.h before windows.h to get rid of redefinition errors.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.25 2007/05/07 03:58:42 brlcad Exp $ (BRL)";
a384 2
  struct bu_vls vls;

a388 1
  bu_vls_init(&vls);
d393 1
a393 2
    bu_vls_strcpy(&vls, "env(DISPLAY)");
    Tcl_SetVar(interp, bu_vls_addr(&vls), dstr, TCL_GLOBAL_ONLY);
a404 1
      bu_vls_free(&vls);
a409 1
    bu_vls_free(&vls);
a415 1
    bu_vls_free(&vls);
a420 1
    bu_vls_free(&vls);
a426 1
    bu_vls_free(&vls);
a444 1
    bu_vls_free(&vls);
d451 2
a452 3
  bu_vls_strcpy(&vls, "wm withdraw . ; tk appname mged");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
@


14.25
log
@wrap in HAVE_SETENV
@
text
@d39 5
a43 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.24 2007/05/06 22:41:15 brlcad Exp $ (BRL)";
@


14.24
log
@reorder so that function declarations are not necessary
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.23 2007/05/06 19:18:16 brlcad Exp $ (BRL)";
d394 1
d396 1
@


14.23
log
@turn off the bezier canvas, make an attempt at tcl 8.5's raw bezier support
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.22 2007/04/23 13:30:20 joevalleyfield Exp $ (BRL)";
a112 1

a118 10
int gui_setup(char *dstr);
void get_attached(void);
void print_valid_dm(void);
void dm_var_init(struct dm_list *initial_dm_list);
void mged_slider_init_vls(struct dm_list *p);
void mged_slider_free_vls(struct dm_list *p);

void mged_fb_open(void);
void mged_fb_close(void);

d149 62
d315 32
d377 3
a379 2
void
print_valid_dm(void)
d381 79
a459 26
    int i = 0;
    Tcl_AppendResult(interp, "\tThe following display manager types are valid: ", (char *)NULL);
#ifdef DM_X
    Tcl_AppendResult(interp, "X  ", (char *)NULL);
    i++;
#endif /* DM_X */
#ifdef DM_TK
    Tcl_AppendResult(interp, "tk  ", (char *)NULL);
    i++;
#endif /* DM_TK */
#ifdef DM_WGL
    Tcl_AppendResult(interp, "wgl  ", (char *)NULL);
    i++;
#endif /* DM_WGL */
#ifdef DM_OGL
    Tcl_AppendResult(interp, "ogl  ", (char *)NULL);
    i++;
#endif /* DM_OGL */
#ifdef DM_GLX
    Tcl_AppendResult(interp, "glx", (char *)NULL);
    i++;
#endif /* DM_GLX */
    if (i==0) {
	Tcl_AppendResult(interp, "NONE AVAILABLE", (char *)NULL);
    }
    Tcl_AppendResult(interp, "\n", (char *)NULL);
d462 1
a625 83
int
gui_setup(char *dstr)
{
  struct bu_vls vls;

  /* initialize only once */
  if(tkwin != NULL)
    return TCL_OK;

  bu_vls_init(&vls);
  Tcl_ResetResult(interp);

  if(dstr != (char *)NULL){
    bu_vls_strcpy(&vls, "env(DISPLAY)");
    Tcl_SetVar(interp, bu_vls_addr(&vls), dstr, TCL_GLOBAL_ONLY);
  }

  /* This runs the tk.tcl script */
  if(Tk_Init(interp) == TCL_ERROR){
      /* hack to avoid a stupid Tk error */
      if (strncmp(interp->result, "this isn't a Tk applicationcouldn't", 35) == 0) {
	  interp->result = (interp->result + 27);
      }
      bu_vls_free(&vls);
      return TCL_ERROR;
  }

  /* Initialize [incr Tk] */
  if (Itk_Init(interp) == TCL_ERROR) {
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Import [incr Tk] commands into the global namespace */
  if (Tcl_Import(interp, Tcl_GetGlobalNamespace(interp),
		 "::itk::*", /* allowOverwrite */ 1) != TCL_OK) {
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Initialize the Iwidgets package */
  if (Tcl_Eval(interp, "package require Iwidgets") != TCL_OK) {
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* Import iwidgets into the global namespace */
  if (Tcl_Import(interp, Tcl_GetGlobalNamespace(interp),
		 "::iwidgets::*", /* allowOverwrite */ 1) != TCL_OK) {
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

#ifdef BRLCAD_DEBUG
  /* Initialize libdm */
  (void)Dm_d_Init(interp);

  /* Initialize libfb */
  (void)Fb_d_Init(interp);
#else
  /* Initialize libdm */
  (void)Dm_Init(interp);

  /* Initialize libfb */
  (void)Fb_Init(interp);
#endif

  if((tkwin = Tk_MainWindow(interp)) == NULL){
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  /* create the event handler */
  Tk_CreateGenericHandler(doEvent, (ClientData)NULL);

  bu_vls_strcpy(&vls, "wm withdraw . ; tk appname mged");
  Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  return TCL_OK;
}


d667 1
a731 23
void
mged_slider_init_vls(struct dm_list *p)
{
  bu_vls_init(&p->dml_fps_name);
  bu_vls_init(&p->dml_aet_name);
  bu_vls_init(&p->dml_ang_name);
  bu_vls_init(&p->dml_center_name);
  bu_vls_init(&p->dml_size_name);
  bu_vls_init(&p->dml_adc_name);
}

void
mged_slider_free_vls(struct dm_list *p)
{
  if (BU_VLS_IS_INITIALIZED(&p->dml_fps_name)) {
    bu_vls_free(&p->dml_fps_name);
    bu_vls_free(&p->dml_aet_name);
    bu_vls_free(&p->dml_ang_name);
    bu_vls_free(&p->dml_center_name);
    bu_vls_free(&p->dml_size_name);
    bu_vls_free(&p->dml_adc_name);
  }
}
a772 34
void
mged_fb_open(void)
{
#ifdef DM_X
  if(dmp->dm_type == DM_TYPE_X)
    X_fb_open();
#endif /* DM_X */
#ifdef DM_TK
  if(dmp->dm_type == DM_TYPE_TK)
    tk_fb_open();
#endif /* DM_TK */
#ifdef DM_WGL
  if(dmp->dm_type == DM_TYPE_WGL)
      Wgl_fb_open();
#endif /* DM_WGL */
#ifdef DM_OGL
  if(dmp->dm_type == DM_TYPE_OGL)
      Ogl_fb_open();
#endif /* DM_OGL */
}

void
mged_fb_close(void)
{
  struct bu_vls vls;

  bu_vls_init(&vls);
  bu_vls_printf(&vls, "fb_close_existing %lu", fbp);
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);

  fbp = (FBIO *)0;
}

@


14.22
log
@preliminary support for unaccelerated mgen on aqua through dm-tk

configure.ac:
        - use two levels of expansion for BRLCAD_DATA
        - enable_aqua configure option
        - move X11 ac_ macro tests from argument check section
        - rely on AC_PATH_XTRA to figure out most of what we need to know about
                where to find X
        - no longer look for libICE, libXmu, or libXsm  AC_PATH_XTRA
                populates X_PRE_LIBS with these but they seem completely unused
                right now.
        - look for opengl libs and headers in all of the places AC_PATH_XTRA
                looked for the xlibs
        - use tk's xlib headers when using tk-aqua rather than x
        - remove X11 "ugly hack"
        - include tk flags where necessary
        - remove --disable-shared from subconfigs
        - forcibly add tcl and tk build dirs to libtool wrapper scripts
libdm/Makefile.am, dm-tk.[ch], dm.h, dm-generic.c, dm_obj.c, mged/Makefile.am,
                attach.c, dm-generic.c, dm-tk.c, ged.c:
        - use lower case when referring to tk
        - add support for using dm-tk
        - include X_CFLAGS with DM_X
irprep/Makefile.am, util/Makefile.am:
        - disable build of ir-X, pl-X when there is no X
dm-X.c:
        - no need to test for HAVE_X11_XLIB here; if we don't have it we
                shouldn't be building this file
libfb/Makefile.am, if_tk.c, libfb/tcl.c:
        - build if_tk.c
        - add preliminary hooks so if_tk can be called when ready
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.21 2007/02/20 08:19:49 brlcad Exp $ (BRL)";
a117 2
extern void Tk_CreateCanvasBezierType();

a514 3
  /* Add Bezier Curves to the canvas widget */
  Tk_CreateCanvasBezierType();

@


14.21
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.20 2007/01/23 01:13:41 brlcad Exp $ (BRL)";
d77 1
d89 5
d143 3
d305 4
d752 4
@


14.20
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.19 2007/01/20 14:36:57 brlcad Exp $ (BRL)";
d436 1
a436 1
    ret = fgets(line, sizeof(line), stdin); /* \n, Null terminated */
@


14.19
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.18 2006/08/24 03:01:31 brlcad Exp $ (BRL)";
@


14.18
log
@prevent infinite loop on classic mged attach prompt.  check whether fgets is stuck on EOF so we can cancel the prompt.
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.17 2006/08/24 02:36:49 brlcad Exp $ (BRL)";
@


14.17
log
@simple infinite loop protection on the attach prompt (it can go into an inf loop on unexpected input (e.g. ctrl-d)).  also protect against dereference crashes when there is no display.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.16 2006/08/08 05:56:44 brlcad Exp $ (BRL)";
d420 2
a421 2
  char line[80];
  register struct w_dm *wp;
d423 1
d429 2
a430 1
    /* skip plot and ps */
d432 3
a434 2
    for( ; wp->type != -1; wp++ )
      bu_log("|%s", wp->name);
a435 1
    (void)fgets(line, sizeof(line), stdin); /* \n, Null terminated */
d437 11
a447 2
    if(line[0] == '\n' || strncmp(line, "nu", 2) == 0)
      return;  /* Nothing more to do. */
d451 7
a457 2
    for( wp = &which_dm[2]; wp->type != -1; wp++ )
      if( strcmp( line, wp->name ) == 0 )
d459 1
a459 3

    if( wp->type != -1 )
      break;
d464 1
d467 1
@


14.16
log
@remove apparently dead code, 'do_2nd_attach_prompt()'
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.15 2006/08/08 05:55:24 brlcad Exp $ (BRL)";
d323 4
d373 5
a377 1
  if(wp->init(o_dm_list, argc, argv) == TCL_ERROR)
d379 1
d422 4
a426 1
  while(1){
d448 4
@


14.15
log
@looks like bezier canvas support should now be available for both windows studio build projects. libtclcad should build sans tk sources now, try enabling it.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.14 2006/08/08 02:54:43 brlcad Exp $ (BRL)";
a123 4
#if 0
static int do_2nd_attach_prompt();
#endif

a256 29
#if 0
static int
do_2nd_attach_prompt()
{
  char *dm_default;
  char  hostname[80];
  char  display[82];
  struct bu_vls prompt;


  bu_vls_init(&prompt);

  /* get or create the default display */
  if( (dm_default = getenv("DISPLAY")) == NULL ) {
    /* Env not set, use local host */
    gethostname( hostname, 80 );
    hostname[79] = '\0';
    (void)sprintf( display, "%s:0", hostname );
    dm_default = display;
  }

  bu_vls_printf(&prompt, "Display [%s]? ", dm_default);

  Tcl_AppendResult(interp, MORE_ARGS_STR, bu_vls_addr(&prompt), (char *)NULL);
  bu_vls_printf(&curr_cmd_list->cl_more_default, "%s", dm_default);

  return TCL_ERROR;
}
#endif
@


14.14
log
@decouple DM_X from the other display manager interfaces, clean up the preprocessor logic so Windows does not need to declare DM_X but also to avoid using _WIN32 where possible as well.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.13 2006/08/07 16:04:39 brlcad Exp $ (BRL)";
a112 1
#ifndef _WIN32
a113 1
#endif
a506 1
#ifndef _WIN32
a507 2
#endif

@


14.13
log
@add explicit code for DM_WGL and IF_WGL for Windows GL support instead of piggybacking off of the OGL interface
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.12 2006/07/12 01:52:22 brlcad Exp $ (BRL)";
d45 2
a51 1
#include <stdio.h>
d56 4
a61 6
#ifdef DM_X
#  include "tk.h"
#  include "itk.h"
#else
#  include "tcl.h"
#endif
d72 1
a84 1
#  ifndef _WIN32
d87 1
a87 1
#  endif /* DM_X && !_WIN32 */
d89 1
a89 1
#  ifdef DM_WGL
d92 1
a92 1
#  endif /* DM_WGL */
d94 1
a94 1
#  ifdef DM_OGL
d97 1
a97 2
#  endif
#endif /* DM_X */
d101 2
a102 1
#endif
d105 1
a105 1
#endif
a141 1
#ifndef _WIN32
d143 1
a143 1
#endif
d146 1
a146 1
#endif
d149 1
a149 2
#endif
#endif
d152 1
a152 1
#endif
d155 1
a155 1
#endif
d326 1
a328 1
#ifndef _WIN32
d330 3
a332 2
#  endif /* !_WIN32 */
#  ifdef DM_WGL
d334 3
a336 2
#  endif /* DM_WGL */
#  ifdef DM_OGL
d338 2
a339 2
#  endif /* DM_OGL */
#endif /* DM_X */
d342 5
a346 1
#endif
a365 1
#ifdef DM_X
a400 1
#endif
a483 1
#ifdef DM_X
a539 6
  /* Add Bezier Curves to the canvas widget */
#ifndef _WIN32
  Tk_CreateCanvasBezierType();
#endif


a564 1
#endif /* DM_X */
a742 1
#  ifndef _WIN32
d745 2
a746 2
#  endif
#  ifdef DM_WGL
d749 2
a750 2
#  endif
#  ifdef DM_OGL
d753 1
a753 2
#  endif
#endif
a758 1
#ifdef DM_X
a766 1
#endif
@


14.12
log
@declare mged_link_vars() correctly
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.11 2006/07/09 19:17:16 brlcad Exp $ (BRL)";
d74 1
d88 6
a93 1
#  endif
d146 3
d333 5
a337 2
#endif
#ifdef DM_OGL
d339 2
a340 2
#endif
#endif
d750 1
a750 1
#ifndef _WIN32
d753 9
a761 8
#endif
#ifdef DM_OGL
#ifndef _WIN32
  else
#endif
if(dmp->dm_type == DM_TYPE_OGL)
    Ogl_fb_open();
#endif
@


14.11
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.10 2006/05/22 15:11:46 brlcad Exp $ (BRL)";
d84 1
a84 1
#ifndef _WIN32
d87 1
a87 1
#endif
d89 1
a89 1
#ifdef DM_OGL
d92 1
a92 1
#endif
a114 1
int mged_attach(struct w_dm *wp, int argc, char **argv);
a119 1
void mged_link_vars(struct dm_list *p);
@


14.10
log
@init curr_dm_list to null
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.9 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
a132 1
char tmp_str[1024];
@


14.9
log
@update copyright to 2006
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.8 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d132 1
a132 1
struct dm_list *curr_dm_list;
@


14.8
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.7 2005/11/11 21:44:16 brlcad Exp $ (BRL)";
@


14.7
log
@hide a malformed Tk erorr that ends up missing a newline between statements.  since this is inherintly a Tk application, just remove that part of the interpreter result (loosing those few bytes of memory, but only once)
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.6 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
d102 2
a104 1
extern void set_port(void);		/* defined in fbserv.c */
d126 1
d537 7
d549 1
@


14.6
log
@trailing ws
@
text
@d29 1
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.5 2005/09/16 18:51:53 brlcad Exp $ (BRL)";
d480 1
d489 6
a494 2
    bu_vls_free(&vls);
    return TCL_ERROR;
d502 1
@


14.5
log
@rework tkwin into cmd.c and profide the DM_X and DM_OGL defines to the build.  probably fixes a bug or two of some sort on the display manager.  also migrate the tolerance vars together along with other ws and header cleanup
@
text
@d29 1
a29 1
 *  
d32 1
a32 1
 *  
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.4 2005/05/28 02:14:51 brlcad Exp $ (BRL)";
d407 1
a407 1
    createDLists(&dgop->dgo_headSolid); 
d730 1
a730 1
  else 
@


14.4
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.3 2005/01/30 20:31:05 brlcad Exp $ (BRL)";
a109 3
#ifdef DM_X
extern Tk_Window tkwin;
#endif
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 2
 *      gui_setup	called by loadtk to initialize the gui
 *
d32 1
a32 1
 *
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d110 3
d410 1
a410 1
    createDLists(&dgop->dgo_headSolid);
a481 1
  Tcl_ResetResult(interp);
d490 2
a491 6
      /* hack to avoid a stupid Tk error */
      if (strncmp(interp->result, "this isn't a Tk applicationcouldn't", 35) == 0) {
	  interp->result = (interp->result + 27);
      }
      bu_vls_free(&vls);
      return TCL_ERROR;
a498 1

d733 1
a733 1
  else
@


14.4.2.1
log
@Mods for windows port
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.4 2005/05/28 02:14:51 brlcad Exp $ (BRL)";
d101 1
a102 2

extern void share_dlist(struct dm_list *dlp2);	/* defined in share.c */
a126 1

a530 7
#ifdef BRLCAD_DEBUG
  /* Initialize libdm */
  (void)Dm_d_Init(interp);

  /* Initialize libfb */
  (void)Fb_d_Init(interp);
#else
a535 1
#endif
@


14.3
log
@update copyright to 2005
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/attach.c,v 14.2 2004/12/21 04:17:26 butler Exp $ (BRL)";
a43 1

d50 2
a51 2
#ifndef WIN32
#include <sys/time.h>		/* for struct timeval */
d53 1
d65 1
d83 1
a83 1
#ifndef WIN32
d106 1
a106 1
#ifndef WIN32
d140 1
a140 1
#ifndef WIN32
d325 1
a325 1
#ifndef WIN32
d495 1
a495 1
#ifndef WIN32
d526 1
a526 1
#ifndef WIN32
d727 1
a727 1
#ifndef WIN32
d732 1
a732 1
#ifndef WIN32
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/attach.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			A T T A C H . C
a36 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/attach.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/attach.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d739 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/attach.c,v 1.2 2004/06/08 22:04:26 morrison Exp $ (BRL)";
d30 1
a30 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/attach.c,v 11.124 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a41 1
#include "externs.h"
@

