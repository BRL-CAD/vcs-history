head	14.80;
access;
symbols
	rel-7-10-4:14.68.2.1
	STABLE:14.68.0.2
	stable-branch:14.6
	rel-7-10-2:14.67
	rel-7-10-0:14.55
	rel-7-8-4:14.50
	rel-7-8-2:14.32
	rel-7-8-0:14.26
	trimnurbs-branch:14.26.0.2
	help:14.26
	temp_tag:14.23
	bobWinPort-20051223-freeze:14.13.2.1
	postmerge-20051223-bobWinPort:14.23
	premerge-20051223-bobWinPort:14.22
	rel-7-6-6:14.22
	rel-7-6-4:14.21
	rel-7-6-2:14.13
	rel-7-6-branch:14.13.0.4
	rel-7-6-0:14.13
	rel-7-4-2:14.12.2.1
	rel-7-4-branch:14.12.0.2
	bobWinPort:14.13.0.2
	rel-7-4-0:14.12
	rel-7-2-6:14.8
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.6
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.80
date	2007.12.16.15.59.40;	author brlcad;	state Exp;
branches;
next	14.79;

14.79
date	2007.12.08.23.16.18;	author brlcad;	state Exp;
branches;
next	14.78;

14.78
date	2007.11.21.20.49.09;	author erikgreenwald;	state Exp;
branches;
next	14.77;

14.77
date	2007.11.21.19.49.11;	author erikgreenwald;	state Exp;
branches;
next	14.76;

14.76
date	2007.11.04.16.26.38;	author bob1961;	state Exp;
branches;
next	14.75;

14.75
date	2007.10.19.19.54.54;	author bob1961;	state Exp;
branches;
next	14.74;

14.74
date	2007.09.15.16.23.17;	author brlcad;	state Exp;
branches;
next	14.73;

14.73
date	2007.09.15.03.26.47;	author brlcad;	state Exp;
branches;
next	14.72;

14.72
date	2007.09.14.23.30.42;	author brlcad;	state Exp;
branches;
next	14.71;

14.71
date	2007.09.14.23.17.19;	author brlcad;	state Exp;
branches;
next	14.70;

14.70
date	2007.09.14.20.06.49;	author brlcad;	state Exp;
branches;
next	14.69;

14.69
date	2007.09.14.15.21.09;	author erikgreenwald;	state Exp;
branches;
next	14.68;

14.68
date	2007.09.02.22.04.51;	author johnranderson;	state Exp;
branches
	14.68.2.1;
next	14.67;

14.67
date	2007.07.30.19.09.40;	author brlcad;	state Exp;
branches;
next	14.66;

14.66
date	2007.07.10.18.45.22;	author brlcad;	state Exp;
branches;
next	14.65;

14.65
date	2007.06.28.06.11.39;	author brlcad;	state Exp;
branches;
next	14.64;

14.64
date	2007.06.22.08.01.09;	author brlcad;	state Exp;
branches;
next	14.63;

14.63
date	2007.06.16.21.17.25;	author johnranderson;	state Exp;
branches;
next	14.62;

14.62
date	2007.06.11.05.41.27;	author brlcad;	state Exp;
branches;
next	14.61;

14.61
date	2007.05.20.23.14.18;	author brlcad;	state Exp;
branches;
next	14.60;

14.60
date	2007.05.20.22.46.24;	author brlcad;	state Exp;
branches;
next	14.59;

14.59
date	2007.05.20.22.30.14;	author brlcad;	state Exp;
branches;
next	14.58;

14.58
date	2007.04.23.13.30.20;	author joevalleyfield;	state Exp;
branches;
next	14.57;

14.57
date	2007.04.18.04.03.55;	author brlcad;	state Exp;
branches;
next	14.56;

14.56
date	2007.04.17.01.05.46;	author brlcad;	state Exp;
branches;
next	14.55;

14.55
date	2007.02.20.08.19.49;	author brlcad;	state Exp;
branches;
next	14.54;

14.54
date	2007.01.27.01.41.43;	author brlcad;	state Exp;
branches;
next	14.53;

14.53
date	2007.01.23.01.13.42;	author brlcad;	state Exp;
branches;
next	14.52;

14.52
date	2007.01.21.04.45.45;	author brlcad;	state Exp;
branches;
next	14.51;

14.51
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.50;

14.50
date	2006.08.29.20.12.50;	author bob1961;	state Exp;
branches;
next	14.49;

14.49
date	2006.08.24.02.35.20;	author brlcad;	state Exp;
branches;
next	14.48;

14.48
date	2006.08.24.01.39.33;	author brlcad;	state Exp;
branches;
next	14.47;

14.47
date	2006.08.20.14.10.25;	author brlcad;	state Exp;
branches;
next	14.46;

14.46
date	2006.08.20.13.56.24;	author brlcad;	state Exp;
branches;
next	14.45;

14.45
date	2006.08.13.23.28.44;	author brlcad;	state Exp;
branches;
next	14.44;

14.44
date	2006.08.13.23.21.35;	author brlcad;	state Exp;
branches;
next	14.43;

14.43
date	2006.08.11.12.54.23;	author brlcad;	state Exp;
branches;
next	14.42;

14.42
date	2006.08.08.02.54.44;	author brlcad;	state Exp;
branches;
next	14.41;

14.41
date	2006.07.28.03.13.05;	author brlcad;	state Exp;
branches;
next	14.40;

14.40
date	2006.07.11.15.35.25;	author brlcad;	state Exp;
branches;
next	14.39;

14.39
date	2006.07.09.19.17.16;	author brlcad;	state Exp;
branches;
next	14.38;

14.38
date	2006.07.09.18.25.32;	author brlcad;	state Exp;
branches;
next	14.37;

14.37
date	2006.06.27.14.24.44;	author bob1961;	state Exp;
branches;
next	14.36;

14.36
date	2006.06.26.02.40.54;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2006.06.22.15.56.11;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2006.06.22.15.51.51;	author brlcad;	state Exp;
branches;
next	14.33;

14.33
date	2006.06.22.14.52.06;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2006.06.08.18.36.09;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2006.06.01.14.53.43;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2006.05.21.16.15.33;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2006.05.12.16.47.26;	author twingy;	state Exp;
branches;
next	14.28;

14.28
date	2006.05.03.16.19.47;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2006.04.30.03.19.58;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2006.02.14.20.28.17;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2006.02.03.02.07.53;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.22;

14.22
date	2005.12.13.03.51.55;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2005.11.15.03.27.35;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2005.11.14.21.23.46;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2005.11.11.21.58.30;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2005.11.07.01.10.48;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2005.11.06.17.05.32;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.10.31.07.30.58;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.09.16.18.51.53;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.07.25.05.50.59;	author brlcad;	state Exp;
branches
	14.13.2.1
	14.13.4.1;
next	14.12;

14.12
date	2005.07.11.02.58.01;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2005.07.05.05.07.30;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.07.05.05.04.44;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.07.04.15.41.57;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.06.02.23.49.56;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.05.28.02.14.51;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.03.28.04.45.11;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.24.02.05.43;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.07.46.27;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.28.04.29.32;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.18.00.14;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.28;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.24;	author morrison;	state Exp;
branches;
next	;

14.12.2.1
date	2005.08.16.21.03.49;	author brlcad;	state Exp;
branches;
next	;

14.13.2.1
date	2005.09.08.16.09.50;	author bob1961;	state Exp;
branches;
next	;

14.13.4.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	14.13.4.2;

14.13.4.2
date	2005.11.14.21.27.54;	author brlcad;	state Exp;
branches;
next	;

14.68.2.1
date	2007.09.28.14.04.34;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.80
log
@convert all bzero calls to memset
@
text
@/*                           G E D . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file ged.c
 *
 * Mainline portion of the graphics editor
 *
 *  Functions -
 *	pr_prompt	print prompt
 *	main		Mainline portion of the graphics editor
 *	refresh		Internal routine to perform displaylist output writing
 *	log_event	Log an event in the log file
 *	mged_finish	Terminate with logging.  To be used instead of exit().
 *	quit		General Exit routine
 *	sig2		user interrupt catcher
 *	new_mats	derive inverse and editing matrices, as required
 *
 *  Authors -
 *	Michael John Muuss
 *	Charles M Kennedy
 *	Douglas A Gwyn
 *	Bob Suckling
 *	Gary Steven Moss
 *	Earl P Weaver
 *	Phil Dykstra
 *	Bob Parker
 *      Christopher Sean Morrison
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <signal.h>
#include <time.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif
#ifdef HAVE_SYS_STAT_H
#  include <sys/stat.h>
#endif

#include "tcl.h"
#include "tk.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "mater.h"
#include "libtermio.h"
#include "db.h"

/* private */
#include "./ged.h"
#include "./titles.h"
#include "./mged_solid.h"
#include "./sedit.h"
#include "./mged_dm.h"
#include "./cmd.h"
#include "brlcad_version.h"


char MGEDCopyRight_Notice[] = "@@(#) \
BRL-CAD is Open Source software. \
This software is Copyright (c) 1985-2007 by the United States Government \
as represented by the U.S. Army Research Laboratory.  All rights reserved.";


#ifdef DEBUG
#  ifndef _WIN32
#    ifndef LOGFILE
#      define LOGFILE	"mged.log"	/* usage log */
#    endif
#  else
#    ifndef LOGFILE
#      define LOGFILE	"C:\\mged.log"		/* usage log */
#    endif
#  endif
#else
#  define LOGFILE "/dev/null"
#endif

#define SPACES "                                                                                                                                                                                                                                                                                                           "

extern void mged_setup(void); /* setup.c */
extern void mged_global_variable_setup(Tcl_Interp *interp); /* cmd.c */

extern void view_ring_init(struct _view_state *vsp1, struct _view_state *vsp2); /* defined in chgview.c */

extern void draw_e_axes(void);
extern void draw_m_axes(void);
extern void draw_v_axes(void);

extern void draw_grid(void);		/* grid.c */

extern void draw_rect(void);		/* rect.c */
extern void paint_rect_area(void);

/* defined in predictor.c */
extern void predictor_init(void);

/* defined in chgmodel.c */
extern void set_localunit_TclVar(void);

/* defined in history.c */
extern struct bu_vls *history_prev(const char *);
extern struct bu_vls *history_cur(const char *);
extern struct bu_vls *history_next(const char *);

/* defined in dodraw.c */
extern unsigned char geometry_default_color[];

/* defined in set.c */
extern struct _mged_variables default_mged_variables;

/* defined in color_scheme.c */
extern struct _color_scheme default_color_scheme;

/* defined in grid.c */
extern struct _grid_state default_grid_state;

/* defined in axes.c */
extern struct _axes_state default_axes_state;

/* defined in rect.c */
extern struct _rubber_band default_rubber_band;


Tcl_Interp *interp = (Tcl_Interp *)NULL;

int pipe_out[2];
int pipe_err[2];
struct db_i *dbip = DBI_NULL;	/* database instance pointer */
struct rt_wdb *wdbp = RT_WDB_NULL;
struct dg_obj *dgop = RT_DGO_NULL;
int update_views = 0;
int (*cmdline_hook)() = NULL;
jmp_buf	jmp_env;		/* For non-local gotos */
double frametime;		/* time needed to draw last frame */

int             cmd_stuff_str(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
void		(*cur_sigint)();	/* Current SIGINT status */
void		sig2(int);
void		sig3(int);
void		reset_input_strings(void);
void		new_mats(void);
void		usejoy(double xangle, double yangle, double zangle);
void            slewview(fastf_t *view_pos);
int		interactive = 0;	/* >0 means interactive */
int             cbreak_mode = 0;        /* >0 means in cbreak_mode */
#if defined(DM_X) || defined(DM_TK) || defined(DM_OGL) || defined(DM_WGL)
int		classic_mged=0;
#else
int		classic_mged=1;
#endif
char		*dpy_string = (char *)NULL;
static int	mged_init_flag = 1;	/* >0 means in initialization stage */

struct bu_vls input_str, scratchline, input_str_prefix;
int input_str_index = 0;

/*
 * 0 - no warn
 * 1 - warn
 */
int db_warn = 0;

/*
 * 0 - no upgrade
 * 1 - upgrade
 */
int db_upgrade = 0;

/* force creation of specific database versions */
int db_version = 5;

static void     mged_insert_char(char ch);
static void	mged_process_char(char ch);
static int	do_rc(void);
static void	log_event(char *event, char *arg);

struct bn_tol		mged_tol;	/* calculation tolerance */
struct rt_tess_tol	mged_ttol;	/* XXX needs to replace mged_abs_tol, et.al. */

struct bu_vls mged_prompt;
void pr_prompt(void), pr_beep(void);
int mged_bomb_hook(genptr_t clientData, genptr_t str);

void mged_view_obj_callback(genptr_t clientData, struct view_obj *vop);

#ifdef USE_PROTOTYPES
#ifndef _WIN32
Tcl_FileProc stdin_input;
Tcl_FileProc std_out_or_err;
#else
void stdin_input(ClientData clientData,int mask);
void std_out_or_err(ClientData clientData,int mask);
#endif
#else
void stdin_input();
void std_out_or_err();
#endif

static void
notify_parent_done(int parent) {
    int buffer[2] = {0};

    if (write(parent, buffer, 1) == -1) {
	perror("Unable to write to communication pipe");
    }
    if (close(parent) == -1) {
	perror("Unable to close communication pipe");
    }

    return;
}


/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
    int	rateflag = 0;
    int	c;
    int	read_only_flag=0;

#ifndef _WIN32
    pid_t	pid;
#endif
    int	parent_pipe[2];
    int	use_pipe = 0;
    int run_in_foreground=0;

    Tcl_Channel chan;

#ifdef _WIN32
    _fmode = _O_BINARY;
    run_in_foreground=1;
#endif

    bu_setprogname(argv[0]);

    while ((c = bu_getopt(argc, argv, "d:hficnrx:X:")) != EOF)
	{
	    switch( c )
		{
		    case 'd':
			dpy_string = bu_optarg;
			break;
		    case 'r':
			read_only_flag = 1;
			break;
		    case 'n':		/* "not new" == "classic" */
		    case 'c':
#ifndef _WIN32
			classic_mged = 1;
#else
			MessageBox(NULL,"-c OPTION NOT AVAILABLE","NOT SUPPORTED",MB_OK);
#endif
			break;
		    case 'x':
			sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
			break;
		    case 'X':
			sscanf( bu_optarg, "%x", (unsigned int *)&bu_debug );
			break;
		    case 'f':
			run_in_foreground = 1;  /* run in foreground */
			break;
		    default:
			fprintf( stdout, "Unrecognized option (%c)\n", c );
			/* Fall through to help */
		    case 'h':
			fprintf(stdout, "Usage:  %s [-c] [-d display] [-h] [-r] [-x#] [-X#] [database [command]]\n", argv[0]);
			fflush(stdout);
			return(1);
		}
	}

    argc -= (bu_optind - 1);
    argv += (bu_optind - 1);

    /* Identify ourselves if interactive */
    if( argc <= 2 )  {
	if (isatty(fileno(stdin)) && isatty(fileno(stdout)))
	    interactive = 1;

	if (interactive && classic_mged){
	    fprintf(stdout, "%s\n", brlcad_ident("Geometry Editor (MGED)"));
	    fflush(stdout);

	    if (isatty(fileno(stdin)) && isatty(fileno(stdout))) {
#ifndef COMMAND_LINE_EDITING
#  define COMMAND_LINE_EDITING 1
#endif
#ifndef _WIN32
		/* Set up for character-at-a-time terminal IO. */
		cbreak_mode = COMMAND_LINE_EDITING;
		save_Tty(fileno(stdin));
#endif
	    }
	}
    }

#if defined(SIGPIPE) && defined(SIGINT)
    (void)signal( SIGPIPE, SIG_IGN );

    /*
     *  Sample and hold current SIGINT setting, so any commands that
     *  might be run (e.g., by .mgedrc) which establish cur_sigint
     *  as their signal handler get the initial behavior.
     *  This will change after setjmp() is called, below.
     */
    cur_sigint = signal( SIGINT, SIG_IGN );		/* sample */
    (void)signal( SIGINT, cur_sigint );		/* restore */
#endif /* SIGPIPE && SIGINT */

#ifdef HAVE_PIPE
    if( !classic_mged && !run_in_foreground ) {
	fprintf( stdout, "Initializing and backgrounding, please wait..." );
	fflush( stdout );

	if (pipe(parent_pipe) == -1) {
	    perror("pipe failed");
	} else {
	    use_pipe=1;
	}

	pid = fork();
	if( pid > 0 ) {
	    fd_set set;
	    struct timeval timeout;
	    int read_result;

	    /* just so it does not appear that MGED has died,
	     * wait until the gui is up before exiting the
	     * parent process (child sends us a byte after the
	     * window is displayed).
	     */
	    if (use_pipe) {

		FD_ZERO(&set);
		FD_SET(parent_pipe[0], &set);
		timeout.tv_sec = 90;
		timeout.tv_usec = 0;
		read_result = select(parent_pipe[0]+1, &set, NULL, NULL, &timeout);

		if (read_result == -1) {
		    perror("Unable to read from communication pipe");
		} else if (read_result == 0) {
		    fprintf(stdout, "Detached\n");
		} else {
		    fprintf(stdout, "Done\n");
		}

	    } else {
		/* no pipe, so just wait a little while */
		sleep(3);
	    }
	    /* exit instead of mged_finish as this is the
	     * parent process.
	     */
	    bu_exit( 0, NULL );
	}
    }
#endif /* HAVE_PIPE */

    /* If multiple processors might be used, initialize for it.
     * Do not run any commands before here.
     * Do not use bu_log() or bu_malloc() before here.
     */
    if( bu_avail_cpus() > 1 )  {
	rt_g.rtg_parallel = 1;
	bu_semaphore_init( RT_SEM_LAST );
    }

    /* Set up linked lists */
    BU_LIST_INIT(&HeadSolid.l);
    BU_LIST_INIT(&FreeSolid.l);
    BU_LIST_INIT(&rt_g.rtg_vlfree);
    BU_LIST_INIT(&rt_g.rtg_headwdb.l);
    BU_LIST_INIT(&head_run_rt.l);

    memset((void *)&head_cmd_list, 0, sizeof(struct cmd_list));
    BU_LIST_INIT(&head_cmd_list.l);
    bu_vls_init(&head_cmd_list.cl_name);
    bu_vls_init(&head_cmd_list.cl_more_default);
    bu_vls_strcpy(&head_cmd_list.cl_name, "mged");
    curr_cmd_list = &head_cmd_list;

    memset((void *)&head_dm_list, 0, sizeof(struct dm_list));
    BU_LIST_INIT( &head_dm_list.l );

    BU_GETSTRUCT(curr_dm_list, dm_list);
    BU_LIST_APPEND(&head_dm_list.l, &curr_dm_list->l);
    netfd = -1;

    /* initialize predictor stuff */
    BU_LIST_INIT(&curr_dm_list->dml_p_vlist);
    predictor_init();

    BU_GETSTRUCT(dmp, dm);
    *dmp = dm_Null;
    bu_vls_init(&pathName);
    bu_vls_init(&tkName);
    bu_vls_init(&dName);
    bu_vls_strcpy(&pathName, "nu");
    bu_vls_strcpy(&tkName, "nu");

    BU_GETSTRUCT(rubber_band, _rubber_band);
    *rubber_band = default_rubber_band;		/* struct copy */

    BU_GETSTRUCT(mged_variables, _mged_variables);
    *mged_variables = default_mged_variables;	/* struct copy */

    BU_GETSTRUCT(color_scheme, _color_scheme);
    *color_scheme = default_color_scheme;		/* struct copy */

    BU_GETSTRUCT(grid_state, _grid_state);
    *grid_state = default_grid_state;		/* struct copy */

    BU_GETSTRUCT(axes_state, _axes_state);
    *axes_state = default_axes_state;		/* struct copy */

    BU_GETSTRUCT(adc_state, _adc_state);
    adc_state->adc_rc = 1;
    adc_state->adc_a1 = adc_state->adc_a2 = 45.0;

    BU_GETSTRUCT(menu_state, _menu_state);
    menu_state->ms_rc = 1;

    BU_GETSTRUCT(dlist_state, _dlist_state);
    dlist_state->dl_rc = 1;

    BU_GETSTRUCT(view_state, _view_state);
    view_state->vs_rc = 1;
    view_ring_init(curr_dm_list->dml_view_state, (struct _view_state *)NULL);
    MAT_IDN( view_state->vs_ModelDelta );

    am_mode = AMM_IDLE;
    owner = 1;
    frametime = 1;

    MAT_IDN( identity );		/* Handy to have around */
    MAT_IDN( modelchanges );
    MAT_IDN( acc_rot_sol );

    state = ST_VIEW;
    es_edflag = -1;
    es_edclass = EDIT_CLASS_NULL;
    inpara = newedge = 0;

    /* These values match old GED.  Use 'tol' command to change them. */
    mged_tol.magic = BN_TOL_MAGIC;
    mged_tol.dist = 0.005;
    mged_tol.dist_sq = mged_tol.dist * mged_tol.dist;
    mged_tol.perp = 1e-6;
    mged_tol.para = 1 - mged_tol.perp;

    rt_init_resource( &rt_uniresource, 0, NULL );

    rt_prep_timer();		/* Initialize timer */

    es_edflag = -1;		/* no solid editing just now */

    bu_vls_init(&input_str);
    bu_vls_init(&input_str_prefix);
    bu_vls_init(&scratchline);
    bu_vls_init(&mged_prompt);
    input_str_index = 0;

    /* Initialize mged, adjust our path, get set up to use Tcl */
    mged_setup();
    new_mats();

    mmenu_init();
    btn_head_menu(0,0,0);
    mged_link_vars(curr_dm_list);


    {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "set version \"%s\"", brlcad_ident("Geometry Editor (MGED)"));
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
    }

    setview(0.0, 0.0, 0.0);

    if (dpy_string == (char *)NULL)
	dpy_string = getenv("DISPLAY");

    if (interactive && !classic_mged){
	int status;
	struct bu_vls vls;
	struct bu_vls error;

	bu_vls_init(&vls);
	bu_vls_init(&error);
	if(dpy_string != (char *)NULL)
	    bu_vls_printf(&vls, "loadtk %s", dpy_string);
	else
	    bu_vls_strcpy(&vls, "loadtk");

	status = Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_strcpy(&error, Tcl_GetStringResult(interp));
	bu_vls_free(&vls);

	if (status != TCL_OK && !dpy_string) {
	    /* failed to load tk, try localhost X11 if DISPLAY was not set */
	    status = Tcl_Eval(interp, "loadtk :0");
	}

	if (status != TCL_OK) {
	    if( !run_in_foreground && use_pipe ) {
		notify_parent_done(parent_pipe[1]);
	    }
	    bu_log("%s\nMGED Aborted.\n", bu_vls_addr(&error));
	    mged_finish(1);
	}
	bu_vls_free(&error);

#if !defined(_WIN32)
	/* bring application to focus if needed (Mac OS X only) */
	dm_applicationfocus();
#endif
    }

    if(argc >= 2){
	/* Open the database, attach a display manager */
	/* Command line may have more than 2 args, opendb only wants 2 */
	if(f_opendb( (ClientData)NULL, interp, 2, argv ) == TCL_ERROR) {
	    if( !run_in_foreground && use_pipe ) {
		notify_parent_done(parent_pipe[1]);
	    }
	    mged_finish(1);
	}
    }

    if( dbip != DBI_NULL && (read_only_flag || dbip->dbi_read_only) ) {
	dbip->dbi_read_only = 1;
	bu_log( "Opened in READ ONLY mode\n" );
    }

    pkg_init();

    /* --- Now safe to process commands. --- */
    if (interactive) {
	/* This is an interactive mged, process .mgedrc */
	do_rc();

	/*
	 * Initialze variables here in case the user specified changes
	 * to the defaults in their .mgedrc file.
	 */

	if (classic_mged) {
	    if( !run_in_foreground && use_pipe ) {
		notify_parent_done(parent_pipe[1]);
	    }

	    get_attached();
	} else {
	    struct bu_vls vls;
	    int status;

#ifdef HAVE_SETPGID
	    /* make this a process group leader */
	    setpgid(0, 0);
#endif

	    bu_vls_init(&vls);
	    bu_vls_strcpy(&vls, "gui");
	    status = Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);

	    /* if we are going to run in the background, let the
	     * parent process know that we are done initializing so
	     * that it may exit.
	     */
	    if( !run_in_foreground && use_pipe ) {
		notify_parent_done(parent_pipe[1]);
	    }

	    if (status != TCL_OK) {
		if (use_pipe) {
		    /* too late to fall back to classic, we forked and detached already */
		    bu_log("Unable to initialize an MGED graphical user interface.\nTry using foreground (-f) or classic-mode (-c) options to MGED.\n");
		    bu_log("%s\nMGED aborted.\n", Tcl_GetStringResult(interp));
		    pkg_terminate();
		    mged_finish(1);
		}
		bu_log("%s\nMGED unable to initialize gui, reverting to classic mode.\n", Tcl_GetStringResult(interp));
		classic_mged=1;
#ifndef _WIN32
		cbreak_mode = COMMAND_LINE_EDITING;
		save_Tty(fileno(stdin));
#endif
		get_attached();
	    } else {

		/* close out stdout/stderr as we're proceeding in GUI mode */
#ifdef HAVE_PIPE
		(void)pipe(pipe_out);
		(void)pipe(pipe_err);
#if 0
		/* Redirect stdout */
		(void)close(1);
		(void)dup(pipe_out[1]);
		(void)close(pipe_out[1]);

		/* Redirect stderr */
		(void)close(2);
		(void)dup(pipe_err[1]);
		(void)close(pipe_err[1]);
#endif
#endif  /* HAVE_PIPE */

		bu_add_hook(&bu_bomb_hook_list, mged_bomb_hook, GENPTR_NULL);
	    } /* status -- gui initialized */
	} /* classic */

    } else { /* !interactive */

	if( !run_in_foreground && use_pipe ) {
	    notify_parent_done(parent_pipe[1]);
	}

    } /* interactive */

    /* --- Now safe to process geometry. --- */

    /* If this is an argv[] invocation, do it now */
    if( argc > 2 )  {
	char *av[2];

	av[0] = "q";
	av[1] = NULL;

	/*
	  Call cmdline instead of calling mged_cmd directly
	  so that access to Tcl/Tk is possible.
	*/
	for(argc -= 2, argv += 2; argc; --argc, ++argv)
	    bu_vls_printf(&input_str, "%s ", *argv);

	cmdline(&input_str, TRUE);
	bu_vls_free(&input_str);

	f_quit((ClientData)NULL, interp, 1, av);
	/* NOTREACHED */
    }

#ifndef _WIN32
    if(classic_mged || !interactive){

#ifndef _WIN32
	ClientData stdin_file = STDIN_FILENO;
#else
	ClientData stdin_file = GetStdHandle(STD_INPUT_HANDLE);
#endif

	chan = Tcl_MakeFileChannel(stdin_file, TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE, stdin_input, stdin_file);

#ifdef SIGINT
	(void)signal( SIGINT, SIG_IGN );
#endif

	bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
	pr_prompt();

#ifndef _WIN32
	if (cbreak_mode) {
	    set_Cbreak(fileno(stdin));
	    clr_Echo(fileno(stdin));
	}
#endif
    } else {
#else
    {
#endif
	ClientData out, err;
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "output_hook output_callback");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

#ifndef _WIN32
	out = (ClientData)(size_t)pipe_out[0];
	err = (ClientData)(size_t)pipe_err[0];
#else
	out = (ClientData)GetStdHandle(STD_OUTPUT_HANDLE);
	err = (ClientData)GetStdHandle(STD_ERROR_HANDLE);
#endif

	chan = Tcl_MakeFileChannel(out, TCL_READABLE);
	Tcl_CreateChannelHandler(chan, TCL_READABLE, std_out_or_err, out);
	chan = Tcl_MakeFileChannel(err, TCL_READABLE);
	Tcl_CreateChannelHandler(chan, TCL_READABLE, std_out_or_err, err);
    }

    mged_init_flag = 0;	/* all done with initialization */

    /****************   M A I N   L O O P   *********************/
    while(1) {
	/* This test stops optimizers from complaining about an infinite loop */
	if( (rateflag = event_check( rateflag )) < 0 )  break;

	/*
	 * Cause the control portion of the displaylist to be
	 * updated to reflect the changes made above.
	 */
	refresh();
    }
    return(0);
}

void
pr_prompt(void)
{
    if( interactive )
	bu_log("%S", &mged_prompt);
}

void
pr_beep(void)
{
    bu_log("%c", 7);
}

/*
 * standard input handling
 *
 * When the Tk event handler sees input on standard input, it calls the
 * routine "stdin_input" (registered with the Tcl_CreateFileHandler call).
 * This routine simply appends the new input to a growing string until the
 * command is complete (it is assumed that the routine gets a fill line.)
 *
 * If the command is incomplete, then allow the user to hit ^C to start over,
 * by setting up the multi_line_sig routine as the SIGINT handler.
 */

/*
 * stdin_input
 *
 * Called when a single character is ready for reading on standard input
 * (or an entire line if the terminal is not in cbreak mode.)
 */

#ifndef _WIN32
void
stdin_input(ClientData clientData, int mask)
{
    int count;
    char ch;
    struct bu_vls temp;
#ifndef _WIN32
    long fd = (long)clientData;
#else
    HANDLE fd = (HANDLE)clientData;
#endif

    /* When not in cbreak mode, just process an entire line of input, and
       don't do any command-line manipulation. */

    if (!cbreak_mode) {
	bu_vls_init(&temp);

	/* Get line from stdin */
	if( bu_vls_gets(&temp, stdin) < 0 )
	    quit();				/* does not return */
	bu_vls_vlscat(&input_str, &temp);

	/* If there are any characters already in the command string (left
	   over from a CMD_MORE), then prepend them to the new input. */

	/* If no input and a default is supplied then use it */
	if(!bu_vls_strlen(&input_str) && bu_vls_strlen(&curr_cmd_list->cl_more_default))
	    bu_vls_printf(&input_str_prefix, "%s%S\n",
			  bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			  &curr_cmd_list->cl_more_default);
	else
	    bu_vls_printf(&input_str_prefix, "%s%S\n",
			  bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			  &input_str);

	bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);

	/* If a complete line was entered, attempt to execute command. */

	if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
	    curr_cmd_list = &head_cmd_list;
	    if(curr_cmd_list->cl_tie)
		curr_dm_list = curr_cmd_list->cl_tie;
	    if (cmdline_hook != NULL) {
		if ((*cmdline_hook)(&input_str))
		    pr_prompt();
		bu_vls_trunc(&input_str, 0);
		bu_vls_trunc(&input_str_prefix, 0);
		(void)signal( SIGINT, SIG_IGN );
	    } else {
		if (cmdline(&input_str_prefix, TRUE) == CMD_MORE) {
		    /* Remove newline */
		    bu_vls_trunc(&input_str_prefix,
				 bu_vls_strlen(&input_str_prefix)-1);
		    bu_vls_trunc(&input_str, 0);

		    (void)signal( SIGINT, sig2 );
		} else {
		    bu_vls_trunc(&input_str_prefix, 0);
		    bu_vls_trunc(&input_str, 0);
		    (void)signal( SIGINT, SIG_IGN );
		}
		pr_prompt();
	    }
	    input_str_index = 0;
	} else {
	    bu_vls_trunc(&input_str, 0);
	    /* Allow the user to hit ^C. */
	    (void)signal( SIGINT, sig2 );
	}
	bu_vls_free(&temp);
	return;
    }

    /*XXXXX*/
#define TRY_STDIN_INPUT_HACK
#ifdef TRY_STDIN_INPUT_HACK
    /* Grab everything --- assuming everything is <= 4096 */
    {
	char buf[4096];
	int index;
#  ifdef _WIN32
	ReadFile(fd, buf, 4096, &count, NULL);
#  else
	count = read((int)fd, (void *)buf, 4096);
#  endif

#else
	/* Grab single character from stdin */
	count = read((int)fd, (void *)&ch, 1);
#endif

	if (count < 0) {
	    perror("READ ERROR");
	}

	if (count <= 0 && feof(stdin)) {
	    char *av[2];

	    av[0] = "q";
	    av[1] = NULL;

	    f_quit((ClientData)NULL, interp, 1, av);
	}

#ifdef TRY_STDIN_INPUT_HACK
	/* Process everything in buf */
	for(index = 0, ch = buf[index]; index < count; ch = buf[++index]){
#endif
	    mged_process_char(ch);
#ifdef TRY_STDIN_INPUT_HACK
	}
    }
#endif
}

static void
do_tab_expansion()
{
    int ret;
    char *obj;
    char *cmd;
    Tcl_Obj *result;
    Tcl_Obj *newCommand;
    Tcl_Obj *matches;
    int numExpansions=0;
    struct bu_vls tab_expansion;

    bu_vls_init( &tab_expansion );
    bu_vls_printf( &tab_expansion, "tab_expansion {%s}", bu_vls_addr(&input_str) );
    ret = Tcl_Eval( interp, bu_vls_addr( &tab_expansion));
    if( ret == TCL_OK ){
        result = Tcl_GetObjResult( interp );
        Tcl_ListObjIndex(interp, result, 0, &newCommand);
        Tcl_ListObjIndex(interp, result, 1, &matches);
        Tcl_ListObjLength(interp, matches, &numExpansions );
        if( numExpansions > 1 ) {
            /* show the possible matches */
            bu_log( "\n%s\n", Tcl_GetString(matches));
            pr_prompt();
        }

	/* display the expanded line */
        /* first clear the current line */
        pr_prompt();
        bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
        pr_prompt();
        bu_vls_trunc(&input_str, 0);
        input_str_index = 0;
        bu_vls_trunc( &input_str, 0 );
        bu_vls_strcat( &input_str, Tcl_GetString(newCommand));
        input_str_index = bu_vls_strlen( &input_str );
        bu_log( "%s", bu_vls_addr(&input_str));
    } else {
        bu_vls_free( &tab_expansion );
        bu_log( "ERROR\n");
        bu_log( "%s\n", Tcl_GetStringResult(interp));
        return;
    }

    bu_vls_free( &tab_expansion );
}

/* Process character */
static void
mged_process_char(char ch)
{
    struct bu_vls *vp = (struct bu_vls *)NULL;
    struct bu_vls temp;
    static int escaped = 0;
    static int bracketed = 0;
    static int tilded = 0;
    static int freshline = 1;

#define CTRL_A      1
#define CTRL_B      2
#define CTRL_D      4
#define CTRL_E      5
#define CTRL_F      6
#define CTRL_K      11
#define CTRL_L      12
#define CTRL_N      14
#define CTRL_P      16
#define CTRL_T      20
#define CTRL_U      21
#define CTRL_W      '\027'
#define ESC         27
#define BACKSPACE   '\b'
#define DELETE      127


    /* bu_log("KEY: %d (esc=%d, brk=%d)\n", ch, escaped, bracketed); */

    /* ANSI sequence */
    if (escaped && bracketed) {

	/* arrow keys */
	if (ch == 'A') ch = CTRL_P;
	if (ch == 'B') ch = CTRL_N;
	if (ch == 'C') ch = CTRL_F;
	if (ch == 'D') ch = CTRL_B;

	/* Mac forward delete key */
	if (ch == '3') {
	    tilded = 1;
	    ch = CTRL_D;
	}

	escaped = bracketed = 0;
    }

    switch (ch) {
	case ESC:           /* Used for building up ANSI arrow keys */
	    escaped = 1;
	    break;
	case '\n':          /* Carriage return or line feed */
	case '\r':
	    bu_log("\n");   /* Display newline */

	    /* If there are any characters already in the command string (left
	       over from a CMD_MORE), then prepend them to the new input. */

	    /* If no input and a default is supplied then use it */
	    if(!bu_vls_strlen(&input_str) && bu_vls_strlen(&curr_cmd_list->cl_more_default))
		bu_vls_printf(&input_str_prefix, "%s%S\n",
			      bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			      &curr_cmd_list->cl_more_default);
	    else {
		if (curr_cmd_list->cl_quote_string)
		    bu_vls_printf(&input_str_prefix, "%s\"%S\"\n",
				  bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
				  &input_str);
		else
		    bu_vls_printf(&input_str_prefix, "%s%S\n",
				  bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
				  &input_str);
	    }

	    curr_cmd_list->cl_quote_string = 0;
	    bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);

	    /* If this forms a complete command (as far as the Tcl parser is
	       concerned) then execute it. */

	    if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
		curr_cmd_list = &head_cmd_list;
		if(curr_cmd_list->cl_tie)
		    curr_dm_list = curr_cmd_list->cl_tie;
		if (cmdline_hook) {  /* Command-line hooks don't do CMD_MORE */
		    reset_Tty(fileno(stdin));

		    if ((*cmdline_hook)(&input_str_prefix))
			pr_prompt();

		    set_Cbreak(fileno(stdin));
		    clr_Echo(fileno(stdin));

		    bu_vls_trunc(&input_str, 0);
		    bu_vls_trunc(&input_str_prefix, 0);
		    (void)signal( SIGINT, SIG_IGN );
		} else {
		    reset_Tty(fileno(stdin)); /* Backwards compatibility */
		    (void)signal( SIGINT, SIG_IGN );
		    if (cmdline(&input_str_prefix, TRUE) == CMD_MORE) {
			/* Remove newline */
			bu_vls_trunc(&input_str_prefix,
				     bu_vls_strlen(&input_str_prefix)-1);
			bu_vls_trunc(&input_str, 0);
			(void)signal( SIGINT, sig2 );
			/* *** The mged_prompt vls now contains prompt for more input. *** */
		    } else {
			/* All done; clear all strings. */
			bu_vls_trunc(&input_str_prefix, 0);
			bu_vls_trunc(&input_str, 0);
			(void)signal( SIGINT, SIG_IGN );
		    }
		    set_Cbreak(fileno(stdin)); /* Back to single-character mode */
		    clr_Echo(fileno(stdin));
		}
	    } else {
		bu_vls_trunc(&input_str, 0);
		bu_vls_strcpy(&mged_prompt, "\r? ");

		/* Allow the user to hit ^C */
		(void)signal( SIGINT, sig2 );
	    }
	    pr_prompt(); /* Print prompt for more input */
	    input_str_index = 0;
	    freshline = 1;
	    escaped = bracketed = 0;
	    break;
	case DELETE:
	case BACKSPACE:
	    if (input_str_index <= 0) {
		pr_beep();
		break;
	    }

	    if (input_str_index == bu_vls_strlen(&input_str)) {
		bu_log("\b \b");
		bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1);
	    } else {
		bu_vls_init(&temp);
		bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
		bu_vls_trunc(&input_str, input_str_index-1);
		bu_log("\b%S ", &temp);
		pr_prompt();
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		bu_vls_free(&temp);
	    }
	    --input_str_index;
	    escaped = bracketed = 0;
	    break;
        case '\t':                      /* do TAB expansion */
            do_tab_expansion();
            break;
	case CTRL_A:                    /* Go to beginning of line */
	    pr_prompt();
	    input_str_index = 0;
	    escaped = bracketed = 0;
	    break;
	case CTRL_E:                    /* Go to end of line */
	    if (input_str_index < bu_vls_strlen(&input_str)) {
		bu_log("%s", bu_vls_addr(&input_str)+input_str_index);
		input_str_index = bu_vls_strlen(&input_str);
	    }
	    escaped = bracketed = 0;
	    break;
	case CTRL_D:                    /* Delete character at cursor */
	    if (input_str_index == bu_vls_strlen(&input_str) && input_str_index != 0) {
		pr_beep(); /* Beep if at end of input string */
		break;
	    }
	    if (input_str_index == bu_vls_strlen(&input_str) && input_str_index == 0) {
		/* act like a usual shell, quit if the command prompt is empty */
		bu_log("exit\n");
		quit();
	    }
	    bu_vls_init(&temp);
	    bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index+1);
	    bu_vls_trunc(&input_str, input_str_index);
	    bu_log("%S ", &temp);
	    pr_prompt();
	    bu_log("%S", &input_str);
	    bu_vls_vlscat(&input_str, &temp);
	    bu_vls_free(&temp);
	    escaped = bracketed = 0;
	    break;
	case CTRL_U:                   /* Delete whole line */
	    pr_prompt();
	    bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
	    pr_prompt();
	    bu_vls_trunc(&input_str, 0);
	    input_str_index = 0;
	    escaped = bracketed = 0;
	    break;
	case CTRL_K:                    /* Delete to end of line */
	    bu_log("%*s", bu_vls_strlen(&input_str)-input_str_index, SPACES);
	    bu_vls_trunc(&input_str, input_str_index);
	    pr_prompt();
	    bu_log("%S", &input_str);
	    escaped = bracketed = 0;
	    break;
	case CTRL_L:                   /* Redraw line */
	    bu_log("\n");
	    pr_prompt();
	    bu_log("%S", &input_str);
	    if (input_str_index == bu_vls_strlen(&input_str))
		break;
	    pr_prompt();
	    bu_log("%*S", input_str_index, &input_str);
	    escaped = bracketed = 0;
	    break;
	case CTRL_B:                   /* Back one character */
	    if (input_str_index == 0) {
		pr_beep();
		break;
	    }
	    --input_str_index;
	    bu_log("\b"); /* hopefully non-destructive! */
	    escaped = bracketed = 0;
	    break;
	case CTRL_F:                   /* Forward one character */
	    if (input_str_index == bu_vls_strlen(&input_str)) {
		pr_beep();
		break;
	    }

	    bu_log("%c", bu_vls_addr(&input_str)[input_str_index]);
	    ++input_str_index;
	    escaped = bracketed = 0;
	    break;
	case CTRL_T:                  /* Transpose characters */
	    if (input_str_index == 0) {
		pr_beep();
		break;
	    }
	    if (input_str_index == bu_vls_strlen(&input_str)) {
		bu_log("\b");
		--input_str_index;
	    }
	    ch = bu_vls_addr(&input_str)[input_str_index];
	    bu_vls_addr(&input_str)[input_str_index] =
		bu_vls_addr(&input_str)[input_str_index - 1];
	    bu_vls_addr(&input_str)[input_str_index - 1] = ch;
	    bu_log("\b%*s", 2, bu_vls_addr(&input_str)+input_str_index-1);
	    ++input_str_index;
	    escaped = bracketed = 0;
	    break;
	case CTRL_N:                  /* Next history command */
	case CTRL_P:                  /* Last history command */
	    /* Work the history routines to get the right string */
	    curr_cmd_list = &head_cmd_list;
	    if (freshline) {
		if (ch == CTRL_P) {
		    vp = history_prev((const char *)NULL);
		    if (vp == NULL) {
			pr_beep();
			break;
		    }
		    bu_vls_trunc(&scratchline, 0);
		    bu_vls_vlscat(&scratchline, &input_str);
		    freshline = 0;
		} else {
		    pr_beep();
		    break;
		}
	    } else {
		if (ch == CTRL_P) {
		    vp = history_prev((const char *)NULL);
		    if (vp == NULL) {
			pr_beep();
			break;
		    }
		} else {
		    vp = history_next((const char *)NULL);
		    if (vp == NULL) {
			vp = &scratchline;
			freshline = 1;
		    }
		}
	    }
	    pr_prompt();
	    bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
	    pr_prompt();
	    bu_vls_trunc(&input_str, 0);
	    bu_vls_vlscat(&input_str, vp);
	    if (bu_vls_addr(&input_str)[bu_vls_strlen(&input_str)-1] == '\n')
		bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1); /* del \n */
	    bu_log("%S", &input_str);
	    input_str_index = bu_vls_strlen(&input_str);
	    escaped = bracketed = 0;
	    break;
	case CTRL_W:                   /* backward-delete-word */
	    {
		char *start;
		char *curr;
		int len;

		start = bu_vls_addr(&input_str);
		curr = start + input_str_index - 1;

		/* skip spaces */
		while(curr > start && *curr == ' ')
		    --curr;

		/* find next space */
		while(curr > start && *curr != ' ')
		    --curr;

		bu_vls_init(&temp);
		bu_vls_strcat(&temp, start+input_str_index);

		if(curr == start)
		    input_str_index = 0;
		else
		    input_str_index = curr - start + 1;

		len = bu_vls_strlen(&input_str);
		bu_vls_trunc(&input_str, input_str_index);
		pr_prompt();
		bu_log("%S%S%*s", &input_str, &temp, len - input_str_index, SPACES);
		pr_prompt();
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		bu_vls_free(&temp);
	    }

	    escaped = bracketed = 0;
	    break;
	case 'd':
	    if (escaped) {                /* delete-word */
		char *start;
		char *curr;
		int i;

		start = bu_vls_addr(&input_str);
		curr = start + input_str_index;

		/* skip spaces */
		while(*curr != '\0' && *curr == ' ')
		    ++curr;

		/* find next space */
		while(*curr != '\0' && *curr != ' ')
		    ++curr;

		i = curr - start;
		bu_vls_init(&temp);
		bu_vls_strcat(&temp, curr);
		bu_vls_trunc(&input_str, input_str_index);
		pr_prompt();
		bu_log("%S%S%*s", &input_str, &temp, i - input_str_index, SPACES);
		pr_prompt();
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		bu_vls_free(&temp);
	    }else
		mged_insert_char(ch);

	    escaped = bracketed = 0;
	    break;
	case 'f':
	    if (escaped) {                /* forward-word */
		char *start;
		char *curr;

		start = bu_vls_addr(&input_str);
		curr = start + input_str_index;

		/* skip spaces */
		while(*curr != '\0' && *curr == ' ')
		    ++curr;

		/* find next space */
		while(*curr != '\0' && *curr != ' ')
		    ++curr;

		input_str_index = curr - start;
		bu_vls_init(&temp);
		bu_vls_strcat(&temp, start+input_str_index);
		bu_vls_trunc(&input_str, input_str_index);
		pr_prompt();
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		bu_vls_free(&temp);
	    }else
		mged_insert_char(ch);

	    escaped = bracketed = 0;
	    break;
	case 'b':
	    if (escaped) {                /* backward-word */
		char *start;
		char *curr;

		start = bu_vls_addr(&input_str);
		curr = start + input_str_index - 1;

		/* skip spaces */
		while(curr > start && *curr == ' ')
		    --curr;

		/* find next space */
		while(curr > start && *curr != ' ')
		    --curr;

		if(curr == start)
		    input_str_index = 0;
		else
		    input_str_index = curr - start + 1;

		bu_vls_init(&temp);
		bu_vls_strcat(&temp, start+input_str_index);
		bu_vls_trunc(&input_str, input_str_index);
		pr_prompt();
		bu_log("%S", &input_str);
		bu_vls_vlscat(&input_str, &temp);
		bu_vls_free(&temp);
	    }else
		mged_insert_char(ch);

	    escaped = bracketed = 0;
	    break;
	case '[':
	    if (escaped) {
		bracketed = 1;
		break;
	    }
	case '~':
	    if (tilded) {
		/* we were in an escape sequence (Mac delete key), just ignore the trailing tilde */
		tilded = 0;
		break;
	    }
	    /* Fall through if not escaped! */
	default:
	    if (!isprint(ch))
		break;

	    mged_insert_char(ch);
	    escaped = bracketed = 0;
	    break;
    }
}

static void
mged_insert_char(char ch)
{
    if (input_str_index == bu_vls_strlen(&input_str)) {
	bu_log("%c", (int)ch);
	bu_vls_putc(&input_str, (int)ch);
	++input_str_index;
    } else {
	struct bu_vls temp;

	bu_vls_init(&temp);
	bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
	bu_vls_trunc(&input_str, input_str_index);
	bu_log("%c%S", (int)ch, &temp);
	pr_prompt();
	bu_vls_putc(&input_str, (int)ch);
	bu_log("%S", &input_str);
	bu_vls_vlscat(&input_str, &temp);
	++input_str_index;
	bu_vls_free(&temp);
    }
}
#endif


/* Stuff a string to stdout while leaving the current command-line alone */
int
cmd_stuff_str(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    int i;

    if(argc != 2){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel stuff_str");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if(classic_mged){
	bu_log("\r%s\n", argv[1]);
	pr_prompt();
	bu_log("%s", bu_vls_addr(&input_str));
	pr_prompt();
	for(i = 0; i < input_str_index; ++i)
	    bu_log("%c", bu_vls_addr(&input_str)[i]);
    }

    return TCL_OK;
}

void
std_out_or_err(ClientData clientData, int mask)
{
#ifndef _WIN32
    int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
#else
    HANDLE fd = clientData;
#endif
    int count;
    struct bu_vls vls;
    char line[RT_MAXLINE] = {0};
    Tcl_Obj *save_result;

    /* Get data from stdout or stderr */

#ifndef _WIN32
    count = read((int)fd, line, RT_MAXLINE);
#else
    ReadFile(fd, line, RT_MAXLINE, &count, 0);
#endif

    if(count <= 0) {
	if (count < 0) {
	    perror("READ ERROR");
	}
	return;
    }

    line[count] = '\0';

    save_result = Tcl_GetObjResult(interp);
    Tcl_IncrRefCount(save_result);

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "output_callback {%s}", line);
    (void)Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    Tcl_SetObjResult(interp, save_result);
    Tcl_DecrRefCount(save_result);
}

/*
 *			E V E N T _ C H E C K
 *
 *  Check for events, and dispatch them.
 *  Eventually, this will be done entirely by generating commands
 *
 *  Returns - recommended new value for non_blocking
 */

int
event_check( int non_blocking )
{
    register struct dm_list *p;
    struct dm_list *save_dm_list;
    int save_edflag;
    int handled = 0;

    /* Let cool Tk event handler do most of the work */

    if (non_blocking) {

	/* When in non_blocking-mode, we want to deal with as many events
	   as possible before the next redraw (multiple keypresses, redraw
	   events, etc... */

	while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT)) {
	    handled++;
	}
    } else {
	/* Wait for an event, then handle it */
	Tcl_DoOneEvent(TCL_ALL_EVENTS);

	/* Handle any other events in the queue */
	while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT)) {
	    handled++;
	}
    }

    if (bu_debug > 0) {
	bu_log("Handled %d events\n", handled);
    }

    non_blocking = 0;

    if (dbip == DBI_NULL)
	return non_blocking;

    /*********************************
     *  Handle rate-based processing *
     *********************************/
    save_dm_list = curr_dm_list;
    if( edit_rateflag_model_rotate ) {
	struct bu_vls vls;
	char save_coords;

	curr_dm_list = edit_rate_mr_dm_list;
	save_coords = mged_variables->mv_coords;
	mged_variables->mv_coords = 'm';

	if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
		es_edflag = SROT;
	}else{
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	}

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		      edit_rate_model_origin,
		      edit_rate_model_rotate[X],
		      edit_rate_model_rotate[Y],
		      edit_rate_model_rotate[Z]);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	mged_variables->mv_coords = save_coords;

	if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	else
	    edobj = save_edflag;
    }
    if( edit_rateflag_object_rotate ) {
	struct bu_vls vls;
	char save_coords;

	curr_dm_list = edit_rate_or_dm_list;
	save_coords = mged_variables->mv_coords;
	mged_variables->mv_coords = 'o';

	if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
		es_edflag = SROT;
	}else{
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	}

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		      edit_rate_object_origin,
		      edit_rate_object_rotate[X],
		      edit_rate_object_rotate[Y],
		      edit_rate_object_rotate[Z]);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	mged_variables->mv_coords = save_coords;

	if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	else
	    edobj = save_edflag;
    }
    if( edit_rateflag_view_rotate ) {
	struct bu_vls vls;
	char save_coords;

	curr_dm_list = edit_rate_vr_dm_list;
	save_coords = mged_variables->mv_coords;
	mged_variables->mv_coords = 'v';

	if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_ROTATE)
		es_edflag = SROT;
	}else{
	    save_edflag = edobj;
	    edobj = BE_O_ROTATE;
	}

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		      edit_rate_view_origin,
		      edit_rate_view_rotate[X],
		      edit_rate_view_rotate[Y],
		      edit_rate_view_rotate[Z]);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	mged_variables->mv_coords = save_coords;

	if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	else
	    edobj = save_edflag;
    }
    if( edit_rateflag_model_tran ) {
	char save_coords;
	struct bu_vls vls;

	curr_dm_list = edit_rate_mt_dm_list;
	save_coords = mged_variables->mv_coords;
	mged_variables->mv_coords = 'm';

	if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_TRAN)
		es_edflag = STRANS;
	}else{
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	}

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -e aX %f aY %f aZ %f\n",
		      edit_rate_model_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      edit_rate_model_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      edit_rate_model_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	mged_variables->mv_coords = save_coords;

	if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	else
	    edobj = save_edflag;
    }
    if( edit_rateflag_view_tran ) {
	char save_coords;
	struct bu_vls vls;

	curr_dm_list = edit_rate_vt_dm_list;
	save_coords = mged_variables->mv_coords;
	mged_variables->mv_coords = 'v';

	if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_TRAN)
		es_edflag = STRANS;
	}else{
	    save_edflag = edobj;
	    edobj = BE_O_XY;
	}

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -e aX %f aY %f aZ %f\n",
		      edit_rate_view_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      edit_rate_view_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      edit_rate_view_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	mged_variables->mv_coords = save_coords;

	if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	else
	    edobj = save_edflag;
    }
    if( edit_rateflag_scale ) {
	struct bu_vls vls;

	if(state == ST_S_EDIT){
	    save_edflag = es_edflag;
	    if(!SEDIT_SCALE)
		es_edflag = SSCALE;
	}else{
	    save_edflag = edobj;
	    if(!OEDIT_SCALE)
		edobj = BE_O_SCALE;
	}

	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "knob -i -e aS %f\n", edit_rate_scale * 0.01);

	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	if(state == ST_S_EDIT)
	    es_edflag = save_edflag;
	else
	    edobj = save_edflag;
    }

    FOR_ALL_DISPLAYS(p, &head_dm_list.l){
	if(!p->dml_owner)
	    continue;

	curr_dm_list = p;

	if( view_state->vs_rateflag_model_rotate ) {
	    struct bu_vls vls;

	    non_blocking++;
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "knob -o %c -i -m ax %f ay %f az %f\n",
			  view_state->vs_rate_model_origin,
			  view_state->vs_rate_model_rotate[X],
			  view_state->vs_rate_model_rotate[Y],
			  view_state->vs_rate_model_rotate[Z]);

	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	}
	if( view_state->vs_rateflag_model_tran ) {
	    struct bu_vls vls;

	    non_blocking++;
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "knob -i -m aX %f aY %f aZ %f\n",
			  view_state->vs_rate_model_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
			  view_state->vs_rate_model_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
			  view_state->vs_rate_model_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);

	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	}
	if( view_state->vs_rateflag_rotate )  {
	    struct bu_vls vls;

	    non_blocking++;
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "knob -o %c -i -v ax %f ay %f az %f\n",
			  view_state->vs_rate_origin,
			  view_state->vs_rate_rotate[X],
			  view_state->vs_rate_rotate[Y],
			  view_state->vs_rate_rotate[Z]);

	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	}
	if( view_state->vs_rateflag_tran )  {
	    struct bu_vls vls;

	    non_blocking++;
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "knob -i -v aX %f aY %f aZ %f",
			  view_state->vs_rate_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
			  view_state->vs_rate_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
			  view_state->vs_rate_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);

	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	}
	if( view_state->vs_rateflag_scale )  {
	    struct bu_vls vls;

	    non_blocking++;
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "zoom %f",
			  1.0 / (1.0 - (view_state->vs_rate_scale / 10.0)));
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	}

	curr_dm_list = save_dm_list;
    }

    return( non_blocking );
}

/*			R E F R E S H
 *
 * NOTE that this routine is not to be casually used to
 * refresh the screen.  The normal procedure for screen
 * refresh is to manipulate the necessary global variables,
 * and wait for refresh to be called at the bottom of the while loop
 * in main().  However, when it is absolutely necessary to
 * flush a change in the solids table out to the display in
 * the middle of a routine somewhere (such as the "B" command
 * processor), then this routine may be called.
 *
 * If you don't understand the ramifications of using this routine,
 * then you don't want to call it.
 */
void
refresh(void)
{
    struct dm_list *p;
    struct dm_list *save_dm_list;
    struct bu_vls overlay_vls;
    struct bu_vls tmp_vls;
    register int do_overlay = 1;
    double elapsed_time;
    int do_time = 0;

    bu_vls_init(&overlay_vls);
    bu_vls_init(&tmp_vls);
    rt_prep_timer();

    FOR_ALL_DISPLAYS(p, &head_dm_list.l) {
	if (!p->dml_view_state)
	    continue;
	if (update_views || p->dml_view_state->vs_flag)
	    p->dml_dirty = 1;
    }

    /*
     * This needs to be done separately
     * because dml_view_state may be shared.
     */
    FOR_ALL_DISPLAYS(p, &head_dm_list.l) {
	if (!p->dml_view_state)
	    continue;
	p->dml_view_state->vs_flag = 0;
    }

    update_views = 0;

    save_dm_list = curr_dm_list;
    FOR_ALL_DISPLAYS(p, &head_dm_list.l) {
	/*
	 * if something has changed, then go update the display.
	 * Otherwise, we are happy with the view we have
	 */
	curr_dm_list = p;
	if (mapped && dirty) {
	    dirty = 0;
	    do_time = 1;
	    VMOVE(geometry_default_color,color_scheme->cs_geo_def);

	    if(dbip != DBI_NULL){
		if(do_overlay){
		    bu_vls_trunc(&overlay_vls, 0);
		    create_text_overlay(&overlay_vls);
		    do_overlay = 0;
		}

		/* XXX VR hack */
		if( viewpoint_hook )  (*viewpoint_hook)();
	    }

	    if( mged_variables->mv_predictor )
		predictor_frame();

	    DM_DRAW_BEGIN(dmp);	/* update displaylist prolog */

	    if (dbip != DBI_NULL) {
		/* do framebuffer underlay */
		if (mged_variables->mv_fb && !mged_variables->mv_fb_overlay) {
		    if (mged_variables->mv_fb_all)
			fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
		    else if (mged_variables->mv_mouse_behavior != 'z')
			paint_rect_area();
		}

		/* do framebuffer overlay for entire window */
		if (mged_variables->mv_fb &&
		    mged_variables->mv_fb_overlay &&
		    mged_variables->mv_fb_all) {
		    fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
		} else {
		    /*  Draw each solid in it's proper place on the screen
		     *  by applying zoom, rotation, & translation.
		     *  Calls DM_LOADMATRIX() and DM_DRAW_VLIST().
		     */

		    if (dmp->dm_stereo == 0 ||
			mged_variables->mv_eye_sep_dist <= 0) {
			/* Normal viewing */
			dozoom(0);
		    } else {
			/* Stereo viewing */
			dozoom(1);
			dozoom(2);
		    }

		    /* do framebuffer overlay in rectangular area */
		    if (mged_variables->mv_fb &&
			mged_variables->mv_fb_overlay &&
			mged_variables->mv_mouse_behavior != 'z')
			paint_rect_area();
		}


		/* Restore to non-rotated, full brightness */
		DM_NORMAL(dmp);

		/* only if not doing overlay */
		if (!mged_variables->mv_fb ||
		    mged_variables->mv_fb_overlay != 2) {
		    if (rubber_band->rb_active || rubber_band->rb_draw)
			draw_rect();

		    if (grid_state->gr_draw)
			draw_grid();

		    /* Compute and display angle/distance cursor */
		    if (adc_state->adc_draw)
			adcursor();

		    if (axes_state->ax_view_draw)
			draw_v_axes();

		    if (axes_state->ax_model_draw)
			draw_m_axes();

		    if (axes_state->ax_edit_draw &&
			(state == ST_S_EDIT || state == ST_O_EDIT))
			draw_e_axes();

		    /* Display titles, etc., if desired */
		    bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
		    dotitles(&tmp_vls);
		    bu_vls_trunc(&tmp_vls, 0);
		}
	    }

	    /* only if not doing overlay */
	    if (!mged_variables->mv_fb ||
		mged_variables->mv_fb_overlay != 2) {
		/* Draw center dot */
		DM_SET_FGCOLOR(dmp,
			       color_scheme->cs_center_dot[0],
			       color_scheme->cs_center_dot[1],
			       color_scheme->cs_center_dot[2], 1, 1.0);
		DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
	    }

	    DM_DRAW_END(dmp);
	}
    }

    /* a frame was drawn */
    if(do_time){
	(void)rt_get_timer( (struct bu_vls *)0, &elapsed_time );
	/* Only use reasonable measurements */
	if( elapsed_time > 1.0e-5 && elapsed_time < 30 )  {
	    /* Smoothly transition to new speed */
	    frametime = 0.9 * frametime + 0.1 * elapsed_time;
	}
    }

    curr_dm_list = save_dm_list;

    bu_vls_free(&overlay_vls);
    bu_vls_free(&tmp_vls);
}

/*
 *			L O G _ E V E N T
 *
 * Logging routine
 */
static void
log_event(char *event, char *arg)
{
    struct bu_vls line;
    time_t now;
    char *timep;
    int logfd;
    char uname[256] = {0};

    /* let the user know that we're logging */
    static int notified = 0;

    /* disable for now until it can be tied to OPTIMIZED too */
    return;

    /* get the current time */
    (void)time( &now );
    timep = ctime( &now );	/* returns 26 char string */
    timep[24] = '\0';	/* Chop off \n */

    /* get the user name */
#ifdef _WIN32
    {
	DWORD dwNumBytes = 256;
	GetUserName(uname, &dwNumBytes);
    }
#else
    getlogin_r(uname, 256);
#endif

    bu_vls_init(&line);
    bu_vls_printf(&line, "%s (%ld) %s [%s] %s: %s\n",
		  timep,
		  (long)now,
		  event,
		  dmp->dm_name,
		  uname,
		  arg
		  );

#ifdef _WIN32
    logfd = open( LOGFILE, _O_WRONLY|_O_APPEND|O_CREAT, _S_IREAD|_S_IWRITE );
#else
    logfd = open( LOGFILE, O_WRONLY|O_APPEND|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP );
#endif

    if (!notified) {
	bu_log("Logging mged events to %s\n", LOGFILE);
	notified = 1;
    }

    if (logfd >= 0) {
	(void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
	(void)close( logfd );
    } else {
	if (notified) {
	    perror("Unable to open event log file");
	}
    }

    bu_vls_free(&line);
}

/*
 *			F I N I S H
 *
 * This routine should be called in place of exit() everywhere
 * in GED, to permit an accurate finish time to be recorded in
 * the (ugh) logfile, also to remove the device access lock.
 */
void
mged_finish(int exitcode)
{
    char place[64];
    register struct dm_list *p;
    register struct cmd_list *c;

    (void)sprintf(place, "exit_status=%d", exitcode );
    log_event( "CEASE", place );

    /* Release all displays */
    FOR_ALL_DISPLAYS(p, &head_dm_list.l){
	curr_dm_list = p;

	if (curr_dm_list && dmp) {
	    DM_CLOSE(dmp);
	}
    }

    for (BU_LIST_FOR(c, cmd_list, &head_cmd_list.l)) {
	bu_vls_free(&c->cl_name);
	bu_vls_free(&c->cl_more_default);
    }


    /* Be certain to close the database cleanly before exiting */
    Tcl_Preserve((ClientData)interp);
#if 0
    Tcl_Eval(interp, "db close");
    Tcl_Eval(interp, ".inmem close");
#else
    Tcl_Eval(interp, "rename db \"\"");
    Tcl_Eval(interp, "rename .inmem \"\"");
#endif
    Tcl_Release((ClientData)interp);

#if 0
    if (wdbp)
	wdb_close(wdbp);

    if (dbip)
	db_close(dbip);
#endif

    /* XXX should deallocate libbu semaphores */

    pkg_terminate();

    mged_global_variable_teardown(interp);

    /* 8.5 seems to have some bugs in their reference counting */
    /* Tcl_DeleteInterp(interp); */

#ifndef _WIN32
    if (cbreak_mode > 0)
	reset_Tty(fileno(stdin));
#endif

    Tcl_Exit(exitcode);
}


/*
 *			Q U I T
 *
 * Handles finishing up.  Also called upon EOF on STDIN.
 */
void
quit(void)
{
    mged_finish(0);
    /* NOTREACHED */
}


/*
 *  			S I G 2
 */
void
sig2(int sig)
{
    reset_input_strings();

    (void)signal( SIGINT, SIG_IGN );
}


/*
 *  			S I G 3
 */
void
sig3(int sig)
{
    (void)signal( SIGINT, SIG_IGN );
    longjmp( jmp_env, 1 );
}


void
reset_input_strings()
{
    if(BU_LIST_IS_HEAD(curr_cmd_list, &head_cmd_list.l)){
	/* Truncate input string */
	bu_vls_trunc(&input_str, 0);
	bu_vls_trunc(&input_str_prefix, 0);
	bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);
	input_str_index = 0;

	curr_cmd_list->cl_quote_string = 0;
	bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
	bu_log("\n");
	pr_prompt();
    }else{
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "reset_input_strings");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
    }
}


/*
 *  			N E W _ M A T S
 *
 *  Derive the inverse and editing matrices, as required.
 *  Centralized here to simplify things.
 */
void
new_mats(void)
{
    vo_update(view_state->vs_vop, interp, 0);
}

#ifdef DO_NEW_EDIT_MATS
void
new_edit_mats(void)
{
    register struct dm_list *p;
    struct dm_list *save_dm_list;

    save_dm_list = curr_dm_list;
    FOR_ALL_DISPLAYS(p, &head_dm_list.l){
	if(!p->dml_owner)
	    continue;

	curr_dm_list = p;
	bn_mat_mul( view_state->vs_model2objview, view_state->vs_vop->vo_model2view, modelchanges );
	bn_mat_inv( view_state->vs_objview2model, view_state->vs_model2objview );
	view_state->vs_flag = 1;
    }

    curr_dm_list = save_dm_list;
}
#endif

void
mged_view_obj_callback(genptr_t		clientData,
		       struct view_obj	*vop)
{
    struct _view_state *vsp = (struct _view_state *)clientData;

    if (state != ST_VIEW) {
	bn_mat_mul(vsp->vs_model2objview, vop->vo_model2view, modelchanges);
	bn_mat_inv(vsp->vs_objview2model, vsp->vs_model2objview);
    }
    vsp->vs_flag = 1;
}

/*
 *			D O _ R C
 *
 *  If an mgedrc file exists, open it and process the commands within.
 *  Look first for a Shell environment variable, then for a file in
 *  the user's home directory, and finally in the current directory.
 *
 *  Returns -
 *	-1	FAIL
 *	 0	OK
 */
static int
do_rc(void)
{
    FILE	*fp = NULL;
    char	*path;
    struct	bu_vls str;
    int bogus;

    bu_vls_init( &str );

#define ENVRC	"MGED_RCFILE"
#define RCFILE	".mgedrc"

    if( (path = getenv(ENVRC)) != (char *)NULL ) {
	if ((fp = fopen(path, "r")) != NULL ) {
	    bu_vls_strcpy( &str, path );
	}
    }

    if( !fp ) {
	if( (path = getenv("HOME")) != (char *)NULL )  {
	    bu_vls_strcpy( &str, path );
	    bu_vls_strcat( &str, "/" );
	    bu_vls_strcat( &str, RCFILE );

	    fp = fopen(bu_vls_addr(&str), "r");
	}
    }

    if( !fp ) {
	if( (fp = fopen( RCFILE, "r" )) != NULL )  {
	    bu_vls_strcpy( &str, RCFILE );
	}
    }

    /* At this point, if none of the above attempts panned out, give up. */

    if( !fp ){
	bu_vls_free(&str);
	return -1;
    }

    bogus = 0;
    while( !feof(fp) ) {
	char buf[80];

	/* Get beginning of line */
	bu_fgets( buf, 80, fp );
	/* If the user has a set command with an equal sign, remember to warn */
	if( strstr(buf, "set") != NULL )
	    if( strchr(buf, '=') != NULL ){
		bogus = 1;
		break;
	    }
    }

    fclose( fp );
    if( bogus ) {
	bu_log("\nWARNING: The new format of the \"set\" command is:\n");
	bu_log("    set varname value\n");
	bu_log("If you are setting variables in your %s, you will ", RCFILE);
	bu_log("need to change those\ncommands.\n\n");
    }
    if (Tcl_EvalFile( interp, bu_vls_addr(&str) ) != TCL_OK) {
	bu_log("Error reading %s:\n%s\n", RCFILE,
	       Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
    }

    bu_vls_free(&str);
    return 0;
}

/*
 *			F _ O P E N D B
 *
 *  Close the current database, if open, and then open a new database.
 *  May also open a display manager, if interactive and none selected yet.
 *
 *  argv[1] is the filename.
 *
 *  There are two invocations:
 *	main()
 *	cmdline()		Only one arg is permitted.
 *
 *  Returns TCL_OK if the database opened
 *  Returns TCL_ERROR if the database was not opened (and the user did
 *    not interactively abort)
 */
int
f_opendb(
	 ClientData clientData,
	 Tcl_Interp *interp,
	 int	argc,
	 char	**argv)
{
    struct db_i		*save_dbip = DBI_NULL;
    struct mater		*save_materp = MATER_NULL;
    struct bu_vls		vls;
    struct bu_vls		msg;	/* use this to hold returned message */
    int			create_new_db = 0;


    if( argc <= 1 )  {

	/* Invoked without args, return name of current database */
	if( dbip != DBI_NULL )  {
	    Tcl_AppendResult(interp, dbip->dbi_filename, (char *)NULL);
	    return TCL_OK;
	}

	Tcl_AppendResult(interp, "", (char *)NULL);
	return TCL_OK;
    }

    bu_vls_init(&vls);

    if(3 < argc || (strlen(argv[1]) == 0)){
	bu_vls_printf(&vls, "help opendb");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    bu_vls_init(&msg);

    if(argc == 3 &&
       strcmp("y", argv[2]) && strcmp("Y", argv[2]) &&
       strcmp("n", argv[2]) && strcmp("N", argv[2])){
	bu_vls_printf(&vls, "help opendb");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_ERROR;
    }

    save_dbip = dbip;
    dbip = DBI_NULL;
    save_materp = rt_material_head;
    rt_material_head = MATER_NULL;

    /* Get input file */
    if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
	((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
	char line[128];

	/*
	 * Check to see if we can access the database
	 */
	if (bu_file_exists(argv[1])) {
	    if (!bu_file_readable(argv[1])) {
		bu_log("ERROR: Unable to read from %s\n", argv[1]);
		return TCL_ERROR;
	    }
	    bu_log("ERROR: Unable to open %s as geometry database file \n", argv[1]);
	    return TCL_ERROR;
	}

	/* File does not exist */
	if (interactive) {
	    if(mged_init_flag){
		if(classic_mged){
		    bu_log("Create new database (y|n)[n]? ");
		    (void)bu_fgets(line, sizeof(line), stdin);
		    if( line[0] != 'y' && line[0] != 'Y' ) {
			bu_log("Warning: no database is currently opened!\n");
			bu_vls_free(&vls);
			bu_vls_free(&msg);
			return TCL_OK;
		    }
		} else{
		    int status;

		    if(dpy_string != (char *)NULL)
			bu_vls_printf(&vls, "cad_dialog .createdb %s \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
				      dpy_string, argv[1]);
		    else
			bu_vls_printf(&vls, "cad_dialog .createdb :0 \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
				      argv[1]);

		    status = Tcl_Eval(interp, bu_vls_addr(&vls));

		    if(status != TCL_OK || Tcl_GetStringResult(interp)[0] == '2') {
			bu_vls_free(&vls);
			bu_vls_free(&msg);
			return TCL_ERROR;
		    }

		    if(Tcl_GetStringResult(interp)[0] == '1') {
			bu_log("opendb: no database is currently opened!\n");
			bu_vls_free(&vls);
			bu_vls_free(&msg);
			return TCL_OK;
		    }
		}
	    } else { /* not initializing mged */
		if(argc == 2){
		    /* need to reset this before returning */
		    dbip = save_dbip;
		    rt_material_head = save_materp;
		    Tcl_AppendResult(interp, MORE_ARGS_STR, "Create new database (y|n)[n]? ",
				     (char *)NULL);
		    bu_vls_printf(&curr_cmd_list->cl_more_default, "n");
		    bu_vls_free(&vls);
		    bu_vls_free(&msg);
		    return TCL_ERROR;
		}

		if( *argv[2] != 'y' && *argv[2] != 'Y' ){
		    dbip = save_dbip; /* restore previous database */
		    rt_material_head = save_materp;
		    bu_vls_free(&vls);
		    bu_vls_free(&msg);
		    return TCL_OK;
		}
	    }
	}

	/* File does not exist, and should be created */
	if ((dbip = db_create(argv[1], db_version)) == DBI_NULL) {
	    dbip = save_dbip; /* restore previous database */
	    rt_material_head = save_materp;
	    bu_vls_free(&vls);
	    bu_vls_free(&msg);

	    if (mged_init_flag) {
		/* we need to use bu_log here */
		bu_log("opendb: failed to create %s\n", argv[1]);
		bu_log("opendb: no database is currently opened!\n");
		return TCL_OK;
	    }

	    Tcl_AppendResult(interp, "opendb: failed to create ", argv[1], "\n",\
			     (char *)NULL);
	    if (dbip == DBI_NULL)
		Tcl_AppendResult(interp, "opendb: no database is currently opened!", \
				 (char *)NULL);

	    return TCL_ERROR;
	}
	/* New database has already had db_dirbuild() by here */

	create_new_db = 1;
	bu_vls_printf(&msg, "The new database %s was successfully created.\n", argv[1]);
    } else {
	/* Opened existing database file */

	/* Scan geometry database and build in-memory directory */
	(void)db_dirbuild( dbip );
    }

    /* close out the old dbip */
    if( save_dbip )  {
	struct db_i *new_dbip;
	struct mater *new_materp;

	new_dbip = dbip;
	new_materp = rt_material_head;

	/* activate the 'saved' values so we can cleanly close the previous db */
	dbip = save_dbip;
	rt_material_head = save_materp;

	/* bye bye db */
	f_closedb(clientData, interp, 1, NULL);

	/* restore to the new db just opened */
	dbip = new_dbip;
	rt_material_head = new_materp;
    }

    {
	register struct dm_list *dmlp;

	/* update local2base and base2local variables for all view objects */
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
	    dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
	    dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
	}
    }

    if( dbip->dbi_read_only )
	bu_vls_printf(&msg, "%s: READ ONLY\n", dbip->dbi_filename);

    /* Quick -- before he gets away -- write a logfile entry! */
    log_event( "START", argv[1] );

    /* Provide LIBWDB C access to the on-disk database */
    if( (wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL )  {
	Tcl_AppendResult(interp, "wdb_dbopen() failed?\n", (char *)NULL);
	return TCL_ERROR;
    }

    /* increment use count for this db instance */
    (void)db_clone_dbi(dbip, NULL);

    /* Establish LIBWDB TCL access to both disk and in-memory databases */
    if (wdb_init_obj(interp, wdbp, MGED_DB_NAME) != TCL_OK) {
	bu_vls_printf(&msg, "%s\n%s\n",
		      Tcl_GetStringResult(interp),
		      Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
	Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_ERROR;
    }

    /* This creates a "db" command object */
    if (wdb_create_cmd(interp, wdbp, MGED_DB_NAME) != TCL_OK) {
	bu_vls_printf(&msg, "%s\n%s\n",
		      Tcl_GetStringResult(interp),
		      Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
	Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_ERROR;
    }

    /* This creates the ".inmem" in-memory geometry container */
    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "wdb_open %s inmem [get_dbip]", MGED_INMEM_NAME);
    if (Tcl_Eval( interp, bu_vls_addr(&vls) ) != TCL_OK) {
	bu_vls_printf(&msg, "%s\n%s\n",
		      Tcl_GetStringResult(interp),
		      Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
	Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
	bu_vls_free(&vls);
	bu_vls_free(&msg);
	return TCL_ERROR;
    }

    /* link the drawable geometry object to the (new) database object */
    dgop->dgo_wdbp = wdbp;

    /* Perhaps do something special with the GUI */
    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "opendb_callback %s", dbip->dbi_filename);
    (void)Tcl_Eval(interp, bu_vls_addr(&vls));

    bu_vls_strcpy(&vls, "local2base");
    Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
    Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&local2base,
		TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);

    bu_vls_strcpy(&vls, "base2local");
    Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
    Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&base2local,
		TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);

    set_localunit_TclVar();

    /* Print title/units information */
    if (interactive)
	bu_vls_printf(&msg, "%s (units=%s)\n", dbip->dbi_title,
		      bu_units_string(dbip->dbi_local2base));

    /*
     * We have an old database version AND
     * we're not in the process of
     * creating a new database.
     */
    if (dbip->dbi_version != 5 && !create_new_db) {
	if (db_upgrade) {
	    if (db_warn)
		bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tConverting to the new format.\n");

	    bu_vls_strcpy(&vls, "after idle dbupgrade -f y");
	    (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	} else {
	    if (db_warn) {
		if (classic_mged)
		    bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tSee the dbupgrade command.");
		else
		    bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tSelect Tools-->Upgrade Database for info.");
	    }
	}
    }

    Tcl_ResetResult( interp );
    Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);

    bu_vls_free(&vls);
    bu_vls_free(&msg);

#ifdef _WIN32
    /*XXX
     *    This combined with the mged.bat (which contains "mged.exe 2>&1 nul")
     *    causes Windows to pass the stdout/stderr to mged's command window.
     *    There must be a better way, but, I've run out of time (for now).
     */
    if (!strcmp(argv[1], "nul")) {
	Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
	dbip = DBI_NULL;
	rt_material_head = MATER_NULL;
    }
#endif

    return TCL_OK;
}


/*
 *			F _ C L O S E D B
 *
 *  Close the current database, if open.
 *
 */
int
f_closedb(
	  ClientData clientData,
	  Tcl_Interp *interp,
	  int	argc,
	  char	**argv)
{
    char *av[2];

    if( argc != 1 )  {
	Tcl_Eval(interp, "help closedb");
	return TCL_ERROR;
    }

    if (dbip == DBI_NULL) {
	Tcl_AppendResult(interp, "No database is open\n", (char *)NULL);
	return TCL_OK;
    }

    /* Clear out anything in the display */
    av[0] = "zap";
    av[1] = NULL;
    cmd_zap(clientData, interp, 1, av);

    /* Close the Tcl database objects */
#if 0
    Tcl_Eval(interp, "db close; .inmem close");
#else
    Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
#endif

    log_event( "CEASE", "(close)" );

    /* update any and all other displays */
    {
	register struct dm_list *dmlp;

	/* update local2base and base2local variables for all view objects */
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
	    dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
	    dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
	}
    }

    /* wipe out the global pointers */
    dbip = DBI_NULL;
    rt_material_head = MATER_NULL;

    return TCL_OK;
}


int
mged_bomb_hook(genptr_t clientData, genptr_t str)
{
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "set mbh_dialog [Dialog .#auto -modality application];");
    bu_vls_printf(&vls, "$mbh_dialog hide 1; $mbh_dialog hide 2; $mbh_dialog hide 3;");
    bu_vls_printf(&vls, "label [$mbh_dialog childsite].l -text {%s};", str);
    bu_vls_printf(&vls, "pack [$mbh_dialog childsite].l;");
    bu_vls_printf(&vls, "update; $mbh_dialog activate");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_OK;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.79
log
@use the new bu_file_readable() routine instead of access() along with bu_file_exists() when unable to open a new file.
@
text
@d415 1
a415 1
    bzero((void *)&head_cmd_list, sizeof(struct cmd_list));
d422 1
a422 1
    bzero((void *)&head_dm_list, sizeof(struct dm_list));
@


14.78
log
@pass bu_exit a NULL instead of an empty string
@
text
@d2399 6
a2404 2
	if ((access(argv[1], R_OK) != 0 || access(argv[1], W_OK) != 0)  && errno != ENOENT) {
	    perror(argv[1]);
@


14.77
log
@exit->bu_exit where applicable
@
text
@d394 1
a394 1
	    bu_exit( 0, "" );
d2066 1
a2066 1
 * This routine should be called in place of bu_exit(, "") everywhere
@


14.76
log
@Activate the fbserv capability on Windows.
@
text
@d394 1
a394 1
	    exit( 0 );
d2066 1
a2066 1
 * This routine should be called in place of exit() everywhere
@


14.75
log
@Minor mods for getting things compiled on Windows.
@
text
@a1892 1
#ifndef _WIN32
a1973 53
#else
	    if (dbip != DBI_NULL) {
		/*  Draw each solid in it's proper place on the screen
		 *  by applying zoom, rotation, & translation.
		 *  Calls DM_LOADMATRIX() and DM_DRAW_VLIST().
		 */

		if (dmp->dm_stereo == 0 ||
		    mged_variables->mv_eye_sep_dist <= 0) {
		    /* Normal viewing */
		    dozoom(0);
		} else {
		    /* Stereo viewing */
		    dozoom(1);
		    dozoom(2);
		}

		/* Restore to non-rotated, full brightness */
		DM_NORMAL(dmp);

		if (rubber_band->rb_active || rubber_band->rb_draw)
		    draw_rect();

		if (grid_state->gr_draw)
		    draw_grid();

		/* Compute and display angle/distance cursor */
		if (adc_state->adc_draw)
		    adcursor();

		if (axes_state->ax_view_draw)
		    draw_v_axes();

		if (axes_state->ax_model_draw)
		    draw_m_axes();

		if (axes_state->ax_edit_draw &&
		    (state == ST_S_EDIT || state == ST_O_EDIT))
		    draw_e_axes();

		/* Display titles, etc., if desired */
		bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
		dotitles(&tmp_vls);
		bu_vls_trunc(&tmp_vls, 0);

		/* Draw center dot */
		DM_SET_FGCOLOR(dmp,
			       color_scheme->cs_center_dot[0],
			       color_scheme->cs_center_dot[1],
			       color_scheme->cs_center_dot[2], 1, 1.0);
		DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
	    }
#endif
@


14.74
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d556 1
d559 1
@


14.73
log
@limits.h, locale.h, setjmp.g, and signal.h now all assumed as well as part of ongoing c89 migration.
@
text
@a48 8
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.72 2007/09/14 23:30:42 brlcad Exp $ (BRL)";
#endif

char MGEDCopyRight_Notice[] = "@@(#) \
BRL-CAD is Open Source software. \
This software is Copyright (c) 1985-2007 by the United States Government \
as represented by the U.S. Army Research Laboratory.  All rights reserved.";
d55 5
a62 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
a65 3
#include <ctype.h>
#include <signal.h>
#include <time.h>
d92 6
@


14.72
log
@don't check for errno.h, we can assume at least c89 compliance
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.71 2007/09/14 23:17:19 brlcad Exp $ (BRL)";
d341 1
a341 1
#ifdef HAVE_SIGNAL
d352 1
a352 1
#endif /* HAVE_SIGNAL */
d702 1
a702 1
#ifdef HAVE_SIGNAL
@


14.71
log
@don't bother checking for errno.h, it's c89
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.70 2007/09/14 20:06:49 brlcad Exp $ (BRL)";
a76 3
#ifdef HAVE_SYS_ERRNO_H
#  include <sys/errno.h>
#endif
@


14.70
log
@The c89 headers are all fair game since it's been a requirement since the move to ANSI c89 compliance.  So.. remove the HAVE_STDLIB_H checks and just use the header.  The headers <complex.h>, <fenv.h>, <inttypes.h>, <stdbool.h>, <stdint.h>, and <tgmath.h> were added with C99 and still need to be checked.  There are several other c89 headers that we could just use, though, that are still being checked.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.69 2007/09/14 15:21:09 erikgreenwald Exp $ (BRL)";
d62 1
a79 3
#ifdef HAVE_ERRNO_H
#  include <errno.h>
#endif
@


14.69
log
@removed trailing whitespace
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.68 2007/09/02 22:04:51 johnranderson Exp $ (BRL)";
d60 1
a81 3
#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#endif
@


14.68
log
@Added basic tab expansion by adding a binding for tab. Does not use readline
library (would require massive rewrite of ged.c and text.tcl). This may be
enough to satisfy the feature request for tab expansion.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.67 2007/07/30 19:09:40 brlcad Exp $ (BRL)";
d125 1
a125 1
        
@


14.68.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d49 8
a59 1
#include <stdlib.h>
a60 6
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <signal.h>
#include <time.h>

d64 5
d72 12
a109 6
char MGEDCopyRight_Notice[] = "@@(#) \
BRL-CAD is Open Source software. \
This software is Copyright (c) 1985-2007 by the United States Government \
as represented by the U.S. Army Research Laboratory.  All rights reserved.";


d125 1
a125 1

d348 1
a348 1
#if defined(SIGPIPE) && defined(SIGINT)
d359 1
a359 1
#endif /* SIGPIPE && SIGINT */
d709 1
a709 1
#ifdef SIGINT
@


14.67
log
@better handling of command-mode when the parent is forked and waiting on the done notification
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.66 2007/07/10 18:45:22 brlcad Exp $ (BRL)";
d124 2
d914 47
d988 1
a988 1
#define SPACES "                                                                                                                                                                                                                                                                                                           "
d1112 3
@


14.66
log
@make all platforms use the same code for creating std in/out/err file channel handlers, using the newer Tcl_MakeFileChannel instead of Tcl_CreateFileHandler.  keep track of how many events we process for debugging.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.65 2007/06/28 06:11:39 brlcad Exp $ (BRL)";
d326 1
a326 1
	if( isatty(fileno(stdin)) && isatty(fileno(stdout)) )
d329 1
a329 1
	if(interactive && classic_mged){
d533 1
a533 1
    if(dpy_string == (char *)NULL)
d536 1
a536 1
    if(interactive && !classic_mged){
d581 4
a584 5
    if( dbip != DBI_NULL && (read_only_flag || dbip->dbi_read_only) )
	{
	    dbip->dbi_read_only = 1;
	    bu_log( "Opened in READ ONLY mode\n" );
	}
d589 1
a589 1
    if(interactive){
d599 4
d663 7
@


14.65
log
@bring application to focus if needed via dm_applicationfocus()
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.64 2007/06/22 08:01:09 brlcad Exp $ (BRL)";
a274 1
#ifdef _WIN32
a275 2
#endif

d644 1
a644 1

d654 1
d689 1
a689 2
	Tcl_CreateFileHandler(STDIN_FILENO, TCL_READABLE,
			      stdin_input, (ClientData)STDIN_FILENO);
d691 1
a691 3
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_INPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
				 stdin_input, (ClientData)GetStdHandle(STD_INPUT_HANDLE));
d694 3
a724 4

	/* to catch output from routines that do not use bu_log */
	Tcl_CreateFileHandler(pipe_out[0], TCL_READABLE, std_out_or_err, out);
	Tcl_CreateFileHandler(pipe_err[0], TCL_READABLE, std_out_or_err, err);
d728 1
d730 4
a733 5
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_OUTPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE, std_out_or_err, out);
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_ERROR_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE, std_out_or_err, err);
#endif
d1453 1
d1463 3
a1465 1
	while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
d1471 7
a1477 1
	while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
@


14.64
log
@only try to use :0 if DISPLAY is not set.  if it's set and fails to load, that's user-intent.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.63 2007/06/16 21:17:25 johnranderson Exp $ (BRL)";
d568 3
@


14.63
log
@Eliminated direct access of interp->result (Not reliable since tcl 8.0).
See the comment in tcl.h.
This also fixes the "units" command.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.62 2007/06/11 05:41:27 brlcad Exp $ (BRL)";
d555 2
a556 2
	if (status != TCL_OK) {
	    /* failed to load tk, try localhost X11 */
@


14.62
log
@remove the disable the call to Tcl_DeleteInterp for release since there seems to be some reference counting issues in a6, remvoe the bu_semaphore_release call too as release pairs with acquire, not with init (there is presently no free routine that pairs with init)
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.61 2007/05/20 23:14:18 brlcad Exp $ (BRL)";
d552 1
a552 1
	bu_vls_strcpy(&error, interp->result);
d627 1
a627 1
		    bu_log("%s\nMGED aborted.\n", interp->result);
d631 1
a631 1
		bu_log("%s\nMGED unable to initialize gui, reverting to classic mode.\n", interp->result);
d2424 1
a2424 1
		    if(status != TCL_OK || interp->result[0] == '2') {
d2430 1
a2430 1
		    if(interp->result[0] == '1') {
d2541 1
a2541 1
		      interp->result,
d2552 1
a2552 1
		      interp->result,
d2565 1
a2565 1
		      interp->result,
@


14.61
log
@ack, pass mged_global_variable_teardown a freaking interpreter.  release our semaphores too.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.60 2007/05/20 22:46:24 brlcad Exp $ (BRL)";
d713 1
d722 3
d726 2
a727 4
	Tcl_CreateFileHandler(pipe_out[0], TCL_READABLE,
			      std_out_or_err, (ClientData)pipe_out[0]);
	Tcl_CreateFileHandler(pipe_err[0], TCL_READABLE,
			      std_out_or_err, (ClientData)pipe_err[0]);
d729 3
d733 1
a733 2
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
				 std_out_or_err, (ClientData)GetStdHandle(STD_OUTPUT_HANDLE));
d735 1
a735 2
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
				 std_out_or_err, (ClientData)GetStdHandle(STD_ERROR_HANDLE));
d2090 1
d2092 1
d2094 2
a2095 1
    Tcl_Eval(interp, "db close; .inmem close");
d2097 2
a2098 1
    Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
d2100 1
d2110 1
a2110 3
    if( bu_avail_cpus() > 1 )  {
	bu_semaphore_release( RT_SEM_LAST );
    }
d2116 2
a2117 1
    Tcl_DeleteInterp(interp);
@


14.60
log
@unlink the variables we link on shutdown so we can clean up memory tcl allocated for managing them.  delete the tcl interpreter on shutdown too.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.59 2007/05/20 22:30:14 brlcad Exp $ (BRL)";
d168 1
a168 1
Tcl_Interp *interp = NULL;
d2102 3
a2104 4
#ifndef _WIN32
    if (cbreak_mode > 0)
	reset_Tty(fileno(stdin));
#endif
d2108 1
a2108 1
    mged_global_variable_teardown();
d2112 5
@


14.59
log
@free allocated memory for cmd_list vls
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.58 2007/04/23 13:30:20 joevalleyfield Exp $ (BRL)";
d125 1
d2108 6
a2113 1
    exit( exitcode );
@


14.58
log
@preliminary support for unaccelerated mgen on aqua through dm-tk

configure.ac:
        - use two levels of expansion for BRLCAD_DATA
        - enable_aqua configure option
        - move X11 ac_ macro tests from argument check section
        - rely on AC_PATH_XTRA to figure out most of what we need to know about
                where to find X
        - no longer look for libICE, libXmu, or libXsm  AC_PATH_XTRA
                populates X_PRE_LIBS with these but they seem completely unused
                right now.
        - look for opengl libs and headers in all of the places AC_PATH_XTRA
                looked for the xlibs
        - use tk's xlib headers when using tk-aqua rather than x
        - remove X11 "ugly hack"
        - include tk flags where necessary
        - remove --disable-shared from subconfigs
        - forcibly add tcl and tk build dirs to libtool wrapper scripts
libdm/Makefile.am, dm-tk.[ch], dm.h, dm-generic.c, dm_obj.c, mged/Makefile.am,
                attach.c, dm-generic.c, dm-tk.c, ged.c:
        - use lower case when referring to tk
        - add support for using dm-tk
        - include X_CFLAGS with DM_X
irprep/Makefile.am, util/Makefile.am:
        - disable build of ir-X, pl-X when there is no X
dm-X.c:
        - no need to test for HAVE_X11_XLIB here; if we don't have it we
                shouldn't be building this file
libfb/Makefile.am, if_tk.c, libfb/tcl.c:
        - build if_tk.c
        - add preliminary hooks so if_tk can be called when ready
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.57 2007/04/18 04:03:55 brlcad Exp $ (BRL)";
d2067 1
d2081 5
@


14.57
log
@brlcad_version() name changed to brlcad_ident()
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.56 2007/04/17 01:05:46 brlcad Exp $ (BRL)";
d189 1
a189 1
#if defined(DM_X) || defined(DM_OGL) || defined(DM_WGL)
@


14.56
log
@convert over from using vers.sh and the global to using the new brlcad_version() interface to extract the version information
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.55 2007/02/20 08:19:49 brlcad Exp $ (BRL)";
d332 1
a332 1
	    fprintf(stdout, "%s\n", brlcad_version("Geometry Editor (MGED)"));
d528 1
a528 1
	bu_vls_printf(&vls, "set version \"%s\"", brlcad_version("Geometry Editor (MGED)"));
@


14.55
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.54 2007/01/27 01:41:43 brlcad Exp $ (BRL)";
d100 1
d107 2
a218 1
extern char	version[];		/* from vers.c */
d332 1
a332 1
	    fprintf(stdout, "%s\n", version+5);	/* skip @@(#) */
d528 1
a528 1
	bu_vls_printf(&vls, "set version \"%s\"", version+5);
@


14.54
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.53 2007/01/23 01:13:42 brlcad Exp $ (BRL)";
d2269 1
a2269 1
	fgets( buf, 80, fp );
d2380 1
a2380 1
		    (void)fgets(line, sizeof(line), stdin);
@


14.53
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.52 2007/01/21 04:45:45 brlcad Exp $ (BRL)";
d641 1
a641 1
		
d646 1
a646 1
		
d711 1
a711 1
	
d716 1
a716 1
	
d2097 1
a2097 1
	    
d2322 1
a2322 1
	
@


14.52
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.51 2007/01/20 14:36:57 brlcad Exp $ (BRL)";
@


14.51
log
@update copyright to 2007
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.50 2006/08/29 20:12:50 bob1961 Exp $ (BRL)";
d736 1
a736 1
    /****************  M A I N   L O O P   *********************/
@


14.50
log
@Mods to get things to natively compile on Windows.
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2006 United States Government as represented by
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.49 2006/08/24 02:35:20 brlcad Exp $ (BRL)";
d56 1
a56 1
This software is Copyright (c) 1985-2006 by the United States Government \
@


14.49
log
@prevent dereference crash if there is an uninitialized display
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.48 2006/08/24 01:39:33 brlcad Exp $ (BRL)";
d631 1
d634 1
d682 1
d708 3
@


14.48
log
@ctrl-d on an empty shell line now quits mged like one might expect for an interactive console shell.  this addresses sf bug report 1543495.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.47 2006/08/20 14:10:25 brlcad Exp $ (BRL)";
d1778 2
d1789 2
@


14.47
log
@break message into two lines on abort.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.46 2006/08/20 13:56:24 brlcad Exp $ (BRL)";
d1058 1
a1058 1
	    if (input_str_index == bu_vls_strlen(&input_str)) {
d1062 5
@


14.46
log
@if mged was started in interactive mode and fails to create a display manager, revert to classic mode.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.45 2006/08/13 23:28:44 brlcad Exp $ (BRL)";
d624 1
a624 1
		    bu_log("Unable to initialize an MGED gui.  Try using foreground (-f) or classic-mode (-c) options.\n");
@


14.45
log
@make the command history pattern arg const
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.44 2006/08/13 23:21:35 brlcad Exp $ (BRL)";
d622 13
a634 4
		bu_log("%s\nMGED Aborted.\n", interp->result);
		pkg_terminate();
		mged_finish(1);
	    }
d636 1
d638 12
a649 12
	    (void)pipe(pipe_out);
	    (void)pipe(pipe_err);

	    /* Redirect stdout */
	    (void)close(1);
	    (void)dup(pipe_out[1]);
	    (void)close(pipe_out[1]);

	    /* Redirect stderr */
	    (void)close(2);
	    (void)dup(pipe_err[1]);
	    (void)close(pipe_err[1]);
d652 4
a655 3
	    bu_add_hook(&bu_bomb_hook_list, mged_bomb_hook, GENPTR_NULL);
	}
    }
@


14.44
log
@refix the command-line history bug that was inadvertently undone by the mac delete key patch
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.43 2006/08/11 12:54:23 brlcad Exp $ (BRL)";
d61 1
d63 1
a63 1
# include <unistd.h>
a64 2

#include <stdio.h>
d141 5
a757 2
extern struct bu_vls *history_prev(char *), *history_cur(char *), *history_next(char *);

d1128 1
a1128 1
		    vp = history_prev((char *)NULL);
d1142 1
a1142 1
		    vp = history_prev((char *)NULL);
d1148 1
a1148 1
		    vp = history_next((char *)NULL);
@


14.43
log
@disable logging for now until it can be tied to OPTIMIZED too
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.42 2006/08/08 02:54:44 brlcad Exp $ (BRL)";
d754 1
a754 1
extern struct bu_vls *history_prev(void), *history_cur(void), *history_next(void);
d1126 1
a1126 1
		    vp = history_prev();
d1140 1
a1140 1
		    vp = history_prev();
d1146 1
a1146 1
		    vp = history_next();
@


14.42
log
@decouple DM_X from the other display manager interfaces, clean up the preprocessor logic so Windows does not need to declare DM_X but also to avoid using _WIN32 where possible as well.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.41 2006/07/28 03:13:05 brlcad Exp $ (BRL)";
d1975 1
a1975 1
#ifndef DEBUG
a1976 1
#endif
@


14.41
log
@ws
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.40 2006/07/11 15:35:25 brlcad Exp $ (BRL)";
d90 2
a91 5
#ifdef DM_X
#  include "tk.h"
#else
#  include "tcl.h"
#endif
d183 1
a183 1
#ifdef DM_X
a187 1
int		run_in_foreground=0;
d267 1
d276 1
d332 1
a332 1
#define COMMAND_LINE_EDITING 1
d343 1
a343 1
#ifndef _WIN32
d354 1
d356 1
d404 1
a404 1
#endif
a554 1
#ifndef _WIN32
a557 1
#endif
a593 1
#ifdef DM_X
a594 1
#endif
d599 1
a599 1
#ifndef _WIN32
a612 1
#ifndef _WIN32
a615 1
#endif
d623 1
a623 1
#ifndef _WIN32
d636 1
a636 6

#  if 0
	    /* close stdin */
	    (void)close(0);
#  endif
#endif  /* _WIN32 */
a664 1
#ifndef _WIN32
d666 1
d675 2
d678 1
d683 1
a687 1
    } else
d689 8
a696 8
	{
	    struct bu_vls vls;

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "output_hook output_callback");
	    Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);

d698 5
a702 5
	    /* to catch output from routines that do not use bu_log */
	    Tcl_CreateFileHandler(pipe_out[0], TCL_READABLE,
				  std_out_or_err, (ClientData)pipe_out[0]);
	    Tcl_CreateFileHandler(pipe_err[0], TCL_READABLE,
				  std_out_or_err, (ClientData)pipe_err[0]);
d704 6
a709 6
	    chan = Tcl_MakeFileChannel(GetStdHandle(STD_OUTPUT_HANDLE),TCL_READABLE);
	    Tcl_CreateChannelHandler(chan,TCL_READABLE,
				     std_out_or_err, (ClientData)GetStdHandle(STD_OUTPUT_HANDLE));
	    chan = Tcl_MakeFileChannel(GetStdHandle(STD_ERROR_HANDLE),TCL_READABLE);
	    Tcl_CreateChannelHandler(chan,TCL_READABLE,
				     std_out_or_err, (ClientData)GetStdHandle(STD_ERROR_HANDLE));
d711 1
a711 1
	}
d771 1
a771 7
    long fd;
#else
    HANDLE fd;
#endif

#ifndef _WIN32
    fd = (long)clientData;
d773 1
a773 1
    fd = (HANDLE)clientData;
a2343 6
#ifndef _WIN32
	if (access(argv[1], R_OK|W_OK) != 0 && errno != ENOENT) {
	    perror(argv[1]);
	    return TCL_ERROR;
	}
#else
a2347 1
#endif
@


14.40
log
@ged.h now declares the attach.c funcs
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.39 2006/07/09 19:17:16 brlcad Exp $ (BRL)";
d262 3
a264 3
	int	rateflag = 0;
	int	c;
	int	read_only_flag=0;
d267 1
a267 1
	pid_t	pid;
d269 2
a270 2
	int	parent_pipe[2];
	int	use_pipe = 0;
d273 1
a273 1
	Tcl_Channel chan;
d278 1
a278 1
	_fmode = _O_BINARY;
d281 1
a281 1
	bu_setprogname(argv[0]);
d283 1
a283 1
	while ((c = bu_getopt(argc, argv, "d:hficnrx:X:")) != EOF)
d285 1
a285 1
		switch( c )
d287 8
a294 8
			case 'd':
				dpy_string = bu_optarg;
				break;
			case 'r':
				read_only_flag = 1;
				break;
			case 'n':		/* "not new" == "classic" */
			case 'c':
d296 1
a296 1
				classic_mged = 1;
d298 1
a298 1
				MessageBox(NULL,"-c OPTION NOT AVAILABLE","NOT SUPPORTED",MB_OK);
d300 17
a316 17
				break;
			case 'x':
				sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
				break;
			case 'X':
	                        sscanf( bu_optarg, "%x", (unsigned int *)&bu_debug );
				break;
			case 'f':
				run_in_foreground = 1;  /* run in foreground */
				break;
			default:
				fprintf( stdout, "Unrecognized option (%c)\n", c );
				/* Fall through to help */
			case 'h':
				fprintf(stdout, "Usage:  %s [-c] [-d display] [-h] [-r] [-x#] [-X#] [database [command]]\n", argv[0]);
				fflush(stdout);
				return(1);
d320 2
a321 2
	argc -= (bu_optind - 1);
	argv += (bu_optind - 1);
d323 3
a325 3
	/* Identify ourselves if interactive */
	if( argc <= 2 )  {
	  if( isatty(fileno(stdin)) && isatty(fileno(stdout)) )
d328 1
a328 1
	  if(interactive && classic_mged){
d337 3
a339 3
	      /* Set up for character-at-a-time terminal IO. */
	      cbreak_mode = COMMAND_LINE_EDITING;
	      save_Tty(fileno(stdin));
a341 1
	  }
d343 1
d346 10
a355 1
	(void)signal( SIGPIPE, SIG_IGN );
d357 9
a365 8
	/*
	 *  Sample and hold current SIGINT setting, so any commands that
	 *  might be run (e.g., by .mgedrc) which establish cur_sigint
	 *  as their signal handler get the initial behavior.
	 *  This will change after setjmp() is called, below.
	 */
	cur_sigint = signal( SIGINT, SIG_IGN );		/* sample */
	(void)signal( SIGINT, cur_sigint );		/* restore */
d367 12
a378 3
	if( !classic_mged && !run_in_foreground ) {
		fprintf( stdout, "Initializing and backgrounding, please wait..." );
		fflush( stdout );
d380 10
a389 2
		if (pipe(parent_pipe) == -1) {
		    perror("pipe failed");
d391 1
a391 1
		    use_pipe=1;
d394 105
a498 12
		pid = fork();
		if( pid > 0 ) {
		    fd_set set;
		    struct timeval timeout;
		    int read_result;

		    /* just so it does not appear that MGED has died,
		     * wait until the gui is up before exiting the
		     * parent process (child sends us a byte after the
		     * window is displayed).
		     */
		    if (use_pipe) {
d500 1
a500 13
			FD_ZERO(&set);
			FD_SET(parent_pipe[0], &set);
			timeout.tv_sec = 90;
			timeout.tv_usec = 0;
			read_result = select(parent_pipe[0]+1, &set, NULL, NULL, &timeout);

			if (read_result == -1) {
			    perror("Unable to read from communication pipe");
			} else if (read_result == 0) {
			    fprintf(stdout, "Detached\n");
			} else {
			    fprintf(stdout, "Done\n");
			}
d502 1
a502 11
		    } else {
			/* no pipe, so just wait a little while */
			sleep(3);
		    }
		    /* exit instead of mged_finish as this is the
		     * parent process.
		     */
		    exit( 0 );
		}
	}
#endif
d504 5
a508 103
	/* If multiple processors might be used, initialize for it.
	 * Do not run any commands before here.
	 * Do not use bu_log() or bu_malloc() before here.
	 */
	if( bu_avail_cpus() > 1 )  {
	  rt_g.rtg_parallel = 1;
	  bu_semaphore_init( RT_SEM_LAST );
	}

	/* Set up linked lists */
	BU_LIST_INIT(&HeadSolid.l);
	BU_LIST_INIT(&FreeSolid.l);
	BU_LIST_INIT(&rt_g.rtg_vlfree);
	BU_LIST_INIT(&rt_g.rtg_headwdb.l);
	BU_LIST_INIT(&head_run_rt.l);

	bzero((void *)&head_cmd_list, sizeof(struct cmd_list));
	BU_LIST_INIT(&head_cmd_list.l);
	bu_vls_init(&head_cmd_list.cl_name);
	bu_vls_init(&head_cmd_list.cl_more_default);
	bu_vls_strcpy(&head_cmd_list.cl_name, "mged");
	curr_cmd_list = &head_cmd_list;

	bzero((void *)&head_dm_list, sizeof(struct dm_list));
	BU_LIST_INIT( &head_dm_list.l );

	BU_GETSTRUCT(curr_dm_list, dm_list);
	BU_LIST_APPEND(&head_dm_list.l, &curr_dm_list->l);
	netfd = -1;

	/* initialize predictor stuff */
	BU_LIST_INIT(&curr_dm_list->dml_p_vlist);
	predictor_init();

	BU_GETSTRUCT(dmp, dm);
	*dmp = dm_Null;
	bu_vls_init(&pathName);
	bu_vls_init(&tkName);
	bu_vls_init(&dName);
	bu_vls_strcpy(&pathName, "nu");
	bu_vls_strcpy(&tkName, "nu");

	BU_GETSTRUCT(rubber_band, _rubber_band);
	*rubber_band = default_rubber_band;		/* struct copy */

	BU_GETSTRUCT(mged_variables, _mged_variables);
	*mged_variables = default_mged_variables;	/* struct copy */

	BU_GETSTRUCT(color_scheme, _color_scheme);
	*color_scheme = default_color_scheme;		/* struct copy */

	BU_GETSTRUCT(grid_state, _grid_state);
	*grid_state = default_grid_state;		/* struct copy */

	BU_GETSTRUCT(axes_state, _axes_state);
	*axes_state = default_axes_state;		/* struct copy */

	BU_GETSTRUCT(adc_state, _adc_state);
	adc_state->adc_rc = 1;
	adc_state->adc_a1 = adc_state->adc_a2 = 45.0;

	BU_GETSTRUCT(menu_state, _menu_state);
	menu_state->ms_rc = 1;

	BU_GETSTRUCT(dlist_state, _dlist_state);
	dlist_state->dl_rc = 1;

	BU_GETSTRUCT(view_state, _view_state);
	view_state->vs_rc = 1;
	view_ring_init(curr_dm_list->dml_view_state, (struct _view_state *)NULL);
	MAT_IDN( view_state->vs_ModelDelta );

	am_mode = AMM_IDLE;
	owner = 1;
	frametime = 1;

	MAT_IDN( identity );		/* Handy to have around */
	MAT_IDN( modelchanges );
	MAT_IDN( acc_rot_sol );

	state = ST_VIEW;
	es_edflag = -1;
	es_edclass = EDIT_CLASS_NULL;
	inpara = newedge = 0;

	/* These values match old GED.  Use 'tol' command to change them. */
	mged_tol.magic = BN_TOL_MAGIC;
	mged_tol.dist = 0.005;
	mged_tol.dist_sq = mged_tol.dist * mged_tol.dist;
	mged_tol.perp = 1e-6;
	mged_tol.para = 1 - mged_tol.perp;

	rt_init_resource( &rt_uniresource, 0, NULL );

	rt_prep_timer();		/* Initialize timer */

	es_edflag = -1;		/* no solid editing just now */

	bu_vls_init(&input_str);
	bu_vls_init(&input_str_prefix);
	bu_vls_init(&scratchline);
	bu_vls_init(&mged_prompt);
	input_str_index = 0;
d510 7
a516 7
	/* Initialize mged, adjust our path, get set up to use Tcl */
	mged_setup();
	new_mats();

	mmenu_init();
	btn_head_menu(0,0,0);
	mged_link_vars(curr_dm_list);
d519 2
a520 2
	{
	  struct bu_vls vls;
d522 5
a526 5
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "set version \"%s\"", version+5);
	  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	}
d528 1
a528 1
	setview(0.0, 0.0, 0.0);
d530 2
a531 2
	if(dpy_string == (char *)NULL)
	  dpy_string = getenv("DISPLAY");
d533 4
a536 4
	if(interactive && !classic_mged){
	  int status;
	  struct bu_vls vls;
	  struct bu_vls error;
d538 3
a540 3
	  bu_vls_init(&vls);
	  bu_vls_init(&error);
	  if(dpy_string != (char *)NULL)
d542 1
a542 1
	  else
d545 8
a552 8
	  status = Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_strcpy(&error, interp->result);
	  bu_vls_free(&vls);

	  if (status != TCL_OK) {
	      /* failed to load tk, try localhost X11 */
	      status = Tcl_Eval(interp, "loadtk :0");
	  }
d554 1
a554 1
	  if (status != TCL_OK) {
d556 16
a571 18
	      if( !run_in_foreground && use_pipe ) {
		  notify_parent_done(parent_pipe[1]);
	      }
#endif
	      bu_log("%s\nMGED Aborted.\n", bu_vls_addr(&error));
	      mged_finish(1);
	  }
	  bu_vls_free(&error);
	}

	if(argc >= 2){
	  /* Open the database, attach a display manager */
	  /* Command line may have more than 2 args, opendb only wants 2 */
	    if(f_opendb( (ClientData)NULL, interp, 2, argv ) == TCL_ERROR) {
		if( !run_in_foreground && use_pipe ) {
		    notify_parent_done(parent_pipe[1]);
		}
		mged_finish(1);
d573 1
d575 1
d577 1
a577 1
	if( dbip != DBI_NULL && (read_only_flag || dbip->dbi_read_only) )
d579 2
a580 2
		dbip->dbi_read_only = 1;
		bu_log( "Opened in READ ONLY mode\n" );
d583 1
a583 1
	pkg_init();
d585 4
a588 4
	/* --- Now safe to process commands. --- */
	if(interactive){
	  /* This is an interactive mged, process .mgedrc */
	  do_rc();
d590 4
a593 4
	  /*
	   * Initialze variables here in case the user specified changes
	   * to the defaults in their .mgedrc file.
	   */
d595 1
a595 1
	  if (classic_mged) {
d599 1
a599 1
	  } else {
a649 1
	  }
d651 1
d653 1
a653 1
	/* --- Now safe to process geometry. --- */
d655 3
a657 3
	/* If this is an argv[] invocation, do it now */
	if( argc > 2 )  {
	  char *av[2];
d659 2
a660 2
	  av[0] = "q";
	  av[1] = NULL;
d662 5
a666 5
	  /*
	    Call cmdline instead of calling mged_cmd directly
	    so that access to Tcl/Tk is possible.
	    */
	  for(argc -= 2, argv += 2; argc; --argc, ++argv)
d669 2
a670 2
	  cmdline(&input_str, TRUE);
	  bu_vls_free(&input_str);
d672 3
a674 3
	  f_quit((ClientData)NULL, interp, 1, av);
	  /* NOTREACHED */
	}
d677 1
a677 1
	if(classic_mged || !interactive){
d679 2
a680 2
	  Tcl_CreateFileHandler(STDIN_FILENO, TCL_READABLE,
				stdin_input, (ClientData)STDIN_FILENO);
d684 1
a684 1
			      stdin_input, (ClientData)GetStdHandle(STD_INPUT_HANDLE));
d686 1
a686 1
	  (void)signal( SIGINT, SIG_IGN );
d688 2
a689 2
	  bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
	  pr_prompt();
d691 1
a691 1
	  if (cbreak_mode) {
d694 2
a695 2
	  }
	} else
d698 1
a698 1
	  struct bu_vls vls;
d700 4
a703 4
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "output_hook output_callback");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
d706 5
a710 5
	  /* to catch output from routines that do not use bu_log */
	  Tcl_CreateFileHandler(pipe_out[0], TCL_READABLE,
				std_out_or_err, (ClientData)pipe_out[0]);
	  Tcl_CreateFileHandler(pipe_err[0], TCL_READABLE,
				std_out_or_err, (ClientData)pipe_err[0]);
d712 6
a717 6
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_OUTPUT_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_OUTPUT_HANDLE));
	chan = Tcl_MakeFileChannel(GetStdHandle(STD_ERROR_HANDLE),TCL_READABLE);
	Tcl_CreateChannelHandler(chan,TCL_READABLE,
			      std_out_or_err, (ClientData)GetStdHandle(STD_ERROR_HANDLE));
d721 1
a721 1
	mged_init_flag = 0;	/* all done with initialization */
d723 4
a726 4
	/****************  M A I N   L O O P   *********************/
	while(1) {
		/* This test stops optimizers from complaining about an infinite loop */
		if( (rateflag = event_check( rateflag )) < 0 )  break;
d728 7
a734 7
		/*
		 * Cause the control portion of the displaylist to be
		 * updated to reflect the changes made above.
		 */
		refresh();
	}
	return(0);
d740 2
a741 2
	if( interactive )
		bu_log("%S", &mged_prompt);
d781 1
a781 1
	HANDLE fd;
d798 1
a798 1
    		quit();				/* does not return */
d806 3
a808 3
	  bu_vls_printf(&input_str_prefix, "%s%S\n",
			bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			&curr_cmd_list->cl_more_default);
d810 3
a812 3
	  bu_vls_printf(&input_str_prefix, "%s%S\n",
			bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
			&input_str);
d821 1
a821 1
	      curr_dm_list = curr_cmd_list->cl_tie;
d853 1
a853 1
/*XXXXX*/
d858 2
a859 2
      char buf[4096];
      int index;
d861 1
a861 1
      ReadFile(fd, buf, 4096, &count, NULL);
d863 1
a863 1
      count = read((int)fd, (void *)buf, 4096);
d867 2
a868 2
    /* Grab single character from stdin */
    count = read((int)fd, (void *)&ch, 1);
d871 3
a873 3
    if (count < 0) {
	perror("READ ERROR");
    }
d875 2
a876 2
    if (count <= 0 && feof(stdin)) {
      char *av[2];
d878 2
a879 2
      av[0] = "q";
      av[1] = NULL;
d881 2
a882 2
      f_quit((ClientData)NULL, interp, 1, av);
    }
d885 2
a886 2
    /* Process everything in buf */
    for(index = 0, ch = buf[index]; index < count; ch = buf[++index]){
d888 1
a888 1
      mged_process_char(ch);
d890 1
a890 1
    }
d899 6
a904 6
  struct bu_vls *vp = (struct bu_vls *)NULL;
  struct bu_vls temp;
  static int escaped = 0;
  static int bracketed = 0;
  static int tilded = 0;
  static int freshline = 1;
d923 1
a923 1
  /* bu_log("KEY: %d (esc=%d, brk=%d)\n", ch, escaped, bracketed); */
d925 2
a926 2
  /* ANSI sequence */
  if (escaped && bracketed) {
d928 41
a968 54
    /* arrow keys */
    if (ch == 'A') ch = CTRL_P;
    if (ch == 'B') ch = CTRL_N;
    if (ch == 'C') ch = CTRL_F;
    if (ch == 'D') ch = CTRL_B;

    /* Mac forward delete key */
    if (ch == '3') {
	tilded = 1;
	ch = CTRL_D;
    }

    escaped = bracketed = 0;
  }

  switch (ch) {
  case ESC:           /* Used for building up ANSI arrow keys */
    escaped = 1;
    break;
  case '\n':          /* Carriage return or line feed */
  case '\r':
    bu_log("\n");   /* Display newline */

    /* If there are any characters already in the command string (left
       over from a CMD_MORE), then prepend them to the new input. */

    /* If no input and a default is supplied then use it */
    if(!bu_vls_strlen(&input_str) && bu_vls_strlen(&curr_cmd_list->cl_more_default))
      bu_vls_printf(&input_str_prefix, "%s%S\n",
		    bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		    &curr_cmd_list->cl_more_default);
    else {
      if (curr_cmd_list->cl_quote_string)
	bu_vls_printf(&input_str_prefix, "%s\"%S\"\n",
		      bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		      &input_str);
      else
	bu_vls_printf(&input_str_prefix, "%s%S\n",
		      bu_vls_strlen(&input_str_prefix) > 0 ? " " : "",
		      &input_str);
    }

    curr_cmd_list->cl_quote_string = 0;
    bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);

    /* If this forms a complete command (as far as the Tcl parser is
       concerned) then execute it. */

    if (Tcl_CommandComplete(bu_vls_addr(&input_str_prefix))) {
      curr_cmd_list = &head_cmd_list;
      if(curr_cmd_list->cl_tie)
	curr_dm_list = curr_cmd_list->cl_tie;
      if (cmdline_hook) {  /* Command-line hooks don't do CMD_MORE */
	reset_Tty(fileno(stdin));
d970 2
a971 2
	if ((*cmdline_hook)(&input_str_prefix))
	  pr_prompt();
d973 2
a974 2
	set_Cbreak(fileno(stdin));
	clr_Echo(fileno(stdin));
d976 6
a981 25
	bu_vls_trunc(&input_str, 0);
	bu_vls_trunc(&input_str_prefix, 0);
	(void)signal( SIGINT, SIG_IGN );
      } else {
	reset_Tty(fileno(stdin)); /* Backwards compatibility */
	(void)signal( SIGINT, SIG_IGN );
	if (cmdline(&input_str_prefix, TRUE) == CMD_MORE) {
	  /* Remove newline */
	  bu_vls_trunc(&input_str_prefix,
		       bu_vls_strlen(&input_str_prefix)-1);
	  bu_vls_trunc(&input_str, 0);
	  (void)signal( SIGINT, sig2 );
	  /* *** The mged_prompt vls now contains prompt for more input. *** */
	} else {
	  /* All done; clear all strings. */
	  bu_vls_trunc(&input_str_prefix, 0);
	  bu_vls_trunc(&input_str, 0);
	  (void)signal( SIGINT, SIG_IGN );
	}
	set_Cbreak(fileno(stdin)); /* Back to single-character mode */
	clr_Echo(fileno(stdin));
      }
    } else {
      bu_vls_trunc(&input_str, 0);
      bu_vls_strcpy(&mged_prompt, "\r? ");
d983 2
a984 14
      /* Allow the user to hit ^C */
      (void)signal( SIGINT, sig2 );
    }
    pr_prompt(); /* Print prompt for more input */
    input_str_index = 0;
    freshline = 1;
    escaped = bracketed = 0;
    break;
  case DELETE:
  case BACKSPACE:
    if (input_str_index <= 0) {
      pr_beep();
      break;
    }
d986 2
a987 82
    if (input_str_index == bu_vls_strlen(&input_str)) {
      bu_log("\b \b");
      bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1);
    } else {
      bu_vls_init(&temp);
      bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
      bu_vls_trunc(&input_str, input_str_index-1);
      bu_log("\b%S ", &temp);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }
    --input_str_index;
    escaped = bracketed = 0;
    break;
  case CTRL_A:                    /* Go to beginning of line */
    pr_prompt();
    input_str_index = 0;
    escaped = bracketed = 0;
    break;
  case CTRL_E:                    /* Go to end of line */
    if (input_str_index < bu_vls_strlen(&input_str)) {
      bu_log("%s", bu_vls_addr(&input_str)+input_str_index);
      input_str_index = bu_vls_strlen(&input_str);
    }
    escaped = bracketed = 0;
    break;
  case CTRL_D:                    /* Delete character at cursor */
    if (input_str_index == bu_vls_strlen(&input_str)) {
      pr_beep(); /* Beep if at end of input string */
      break;
    }
    bu_vls_init(&temp);
    bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index+1);
    bu_vls_trunc(&input_str, input_str_index);
    bu_log("%S ", &temp);
    pr_prompt();
    bu_log("%S", &input_str);
    bu_vls_vlscat(&input_str, &temp);
    bu_vls_free(&temp);
    escaped = bracketed = 0;
    break;
  case CTRL_U:                   /* Delete whole line */
    pr_prompt();
    bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
    pr_prompt();
    bu_vls_trunc(&input_str, 0);
    input_str_index = 0;
    escaped = bracketed = 0;
    break;
  case CTRL_K:                    /* Delete to end of line */
    bu_log("%*s", bu_vls_strlen(&input_str)-input_str_index, SPACES);
    bu_vls_trunc(&input_str, input_str_index);
    pr_prompt();
    bu_log("%S", &input_str);
    escaped = bracketed = 0;
    break;
  case CTRL_L:                   /* Redraw line */
    bu_log("\n");
    pr_prompt();
    bu_log("%S", &input_str);
    if (input_str_index == bu_vls_strlen(&input_str))
      break;
    pr_prompt();
    bu_log("%*S", input_str_index, &input_str);
    escaped = bracketed = 0;
    break;
  case CTRL_B:                   /* Back one character */
    if (input_str_index == 0) {
      pr_beep();
      break;
    }
    --input_str_index;
    bu_log("\b"); /* hopefully non-destructive! */
    escaped = bracketed = 0;
    break;
  case CTRL_F:                   /* Forward one character */
    if (input_str_index == bu_vls_strlen(&input_str)) {
      pr_beep();
      break;
    }
d989 25
a1013 70
    bu_log("%c", bu_vls_addr(&input_str)[input_str_index]);
    ++input_str_index;
    escaped = bracketed = 0;
    break;
  case CTRL_T:                  /* Transpose characters */
    if (input_str_index == 0) {
      pr_beep();
      break;
    }
    if (input_str_index == bu_vls_strlen(&input_str)) {
      bu_log("\b");
      --input_str_index;
    }
    ch = bu_vls_addr(&input_str)[input_str_index];
    bu_vls_addr(&input_str)[input_str_index] =
      bu_vls_addr(&input_str)[input_str_index - 1];
    bu_vls_addr(&input_str)[input_str_index - 1] = ch;
    bu_log("\b%*s", 2, bu_vls_addr(&input_str)+input_str_index-1);
    ++input_str_index;
    escaped = bracketed = 0;
    break;
  case CTRL_N:                  /* Next history command */
  case CTRL_P:                  /* Last history command */
    /* Work the history routines to get the right string */
    curr_cmd_list = &head_cmd_list;
    if (freshline) {
      if (ch == CTRL_P) {
	vp = history_prev();
	if (vp == NULL) {
	  pr_beep();
	  break;
	}
	bu_vls_trunc(&scratchline, 0);
	bu_vls_vlscat(&scratchline, &input_str);
	freshline = 0;
      } else {
	pr_beep();
	break;
      }
    } else {
      if (ch == CTRL_P) {
	vp = history_prev();
	if (vp == NULL) {
	  pr_beep();
	  break;
	}
      } else {
	vp = history_next();
	if (vp == NULL) {
	  vp = &scratchline;
	  freshline = 1;
	}
      }
    }
    pr_prompt();
    bu_log("%*s", bu_vls_strlen(&input_str), SPACES);
    pr_prompt();
    bu_vls_trunc(&input_str, 0);
    bu_vls_vlscat(&input_str, vp);
    if (bu_vls_addr(&input_str)[bu_vls_strlen(&input_str)-1] == '\n')
      bu_vls_trunc(&input_str, bu_vls_strlen(&input_str)-1); /* del \n */
    bu_log("%S", &input_str);
    input_str_index = bu_vls_strlen(&input_str);
    escaped = bracketed = 0;
    break;
  case CTRL_W:                   /* backward-delete-word */
    {
      char *start;
      char *curr;
      int len;
d1015 14
a1028 2
      start = bu_vls_addr(&input_str);
      curr = start + input_str_index - 1;
d1030 82
a1111 3
      /* skip spaces */
      while(curr > start && *curr == ' ')
	--curr;
d1113 89
a1201 3
      /* find next space */
      while(curr > start && *curr != ' ')
	--curr;
d1203 9
a1211 2
      bu_vls_init(&temp);
      bu_vls_strcat(&temp, start+input_str_index);
d1213 116
a1328 131
      if(curr == start)
	input_str_index = 0;
      else
	input_str_index = curr - start + 1;

      len = bu_vls_strlen(&input_str);
      bu_vls_trunc(&input_str, input_str_index);
      pr_prompt();
      bu_log("%S%S%*s", &input_str, &temp, len - input_str_index, SPACES);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }

  escaped = bracketed = 0;
  break;
  case 'd':
    if (escaped) {                /* delete-word */
      char *start;
      char *curr;
      int i;

      start = bu_vls_addr(&input_str);
      curr = start + input_str_index;

      /* skip spaces */
      while(*curr != '\0' && *curr == ' ')
	++curr;

      /* find next space */
      while(*curr != '\0' && *curr != ' ')
	++curr;

      i = curr - start;
      bu_vls_init(&temp);
      bu_vls_strcat(&temp, curr);
      bu_vls_trunc(&input_str, input_str_index);
      pr_prompt();
      bu_log("%S%S%*s", &input_str, &temp, i - input_str_index, SPACES);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }else
      mged_insert_char(ch);

    escaped = bracketed = 0;
    break;
  case 'f':
    if (escaped) {                /* forward-word */
      char *start;
      char *curr;

      start = bu_vls_addr(&input_str);
      curr = start + input_str_index;

      /* skip spaces */
      while(*curr != '\0' && *curr == ' ')
	++curr;

      /* find next space */
      while(*curr != '\0' && *curr != ' ')
	++curr;

      input_str_index = curr - start;
      bu_vls_init(&temp);
      bu_vls_strcat(&temp, start+input_str_index);
      bu_vls_trunc(&input_str, input_str_index);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }else
      mged_insert_char(ch);

    escaped = bracketed = 0;
    break;
  case 'b':
    if (escaped) {                /* backward-word */
      char *start;
      char *curr;

      start = bu_vls_addr(&input_str);
      curr = start + input_str_index - 1;

      /* skip spaces */
      while(curr > start && *curr == ' ')
	--curr;

      /* find next space */
      while(curr > start && *curr != ' ')
	--curr;

      if(curr == start)
	input_str_index = 0;
      else
	input_str_index = curr - start + 1;

      bu_vls_init(&temp);
      bu_vls_strcat(&temp, start+input_str_index);
      bu_vls_trunc(&input_str, input_str_index);
      pr_prompt();
      bu_log("%S", &input_str);
      bu_vls_vlscat(&input_str, &temp);
      bu_vls_free(&temp);
    }else
      mged_insert_char(ch);

    escaped = bracketed = 0;
    break;
  case '[':
    if (escaped) {
      bracketed = 1;
      break;
    }
  case '~':
    if (tilded) {
	/* we were in an escape sequence (Mac delete key), just ignore the trailing tilde */
	tilded = 0;
	break;
    }
    /* Fall through if not escaped! */
  default:
    if (!isprint(ch))
      break;

    mged_insert_char(ch);
    escaped = bracketed = 0;
    break;
  }
d1334 6
a1339 6
  if (input_str_index == bu_vls_strlen(&input_str)) {
    bu_log("%c", (int)ch);
    bu_vls_putc(&input_str, (int)ch);
    ++input_str_index;
  } else {
    struct bu_vls temp;
d1341 11
a1351 11
    bu_vls_init(&temp);
    bu_vls_strcat(&temp, bu_vls_addr(&input_str)+input_str_index);
    bu_vls_trunc(&input_str, input_str_index);
    bu_log("%c%S", (int)ch, &temp);
    pr_prompt();
    bu_vls_putc(&input_str, (int)ch);
    bu_log("%S", &input_str);
    bu_vls_vlscat(&input_str, &temp);
    ++input_str_index;
    bu_vls_free(&temp);
  }
d1360 1
a1360 1
  int i;
d1362 2
a1363 2
  if(argc != 2){
    struct bu_vls vls;
d1365 6
a1370 6
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "helpdevel stuff_str");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }
d1372 8
a1379 8
  if(classic_mged){
    bu_log("\r%s\n", argv[1]);
    pr_prompt();
    bu_log("%s", bu_vls_addr(&input_str));
    pr_prompt();
    for(i = 0; i < input_str_index; ++i)
      bu_log("%c", bu_vls_addr(&input_str)[i]);
  }
d1381 1
a1381 1
  return TCL_OK;
d1388 1
a1388 1
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
d1390 1
a1390 1
  HANDLE fd = clientData;
d1392 4
a1395 4
  int count;
  struct bu_vls vls;
  char line[RT_MAXLINE] = {0};
  Tcl_Obj *save_result;
d1397 1
a1397 1
  /* Get data from stdout or stderr */
d1400 1
a1400 1
  count = read((int)fd, line, RT_MAXLINE);
d1402 1
a1402 1
  ReadFile(fd, line, RT_MAXLINE, &count, 0);
d1405 6
a1410 6
  if(count <= 0) {
      if (count < 0) {
	  perror("READ ERROR");
      }
      return;
  }
d1412 1
a1412 1
  line[count] = '\0';
d1414 2
a1415 2
  save_result = Tcl_GetObjResult(interp);
  Tcl_IncrRefCount(save_result);
d1417 4
a1420 4
  bu_vls_init(&vls);
  bu_vls_printf(&vls, "output_callback {%s}", line);
  (void)Tcl_Eval(interp, bu_vls_addr(&vls));
  bu_vls_free(&vls);
d1422 2
a1423 2
  Tcl_SetObjResult(interp, save_result);
  Tcl_DecrRefCount(save_result);
d1452 2
a1453 2
      /* Wait for an event, then handle it */
      Tcl_DoOneEvent(TCL_ALL_EVENTS);
d1455 2
a1456 2
      /* Handle any other events in the queue */
      while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
d1462 1
a1462 1
	    return non_blocking;
d1469 15
a1483 2
      struct bu_vls vls;
      char save_coords;
d1485 7
a1491 34
      curr_dm_list = edit_rate_mr_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'm';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		    edit_rate_model_origin,
		    edit_rate_model_rotate[X],
		    edit_rate_model_rotate[Y],
		    edit_rate_model_rotate[Z]);

      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_object_rotate ) {
      struct bu_vls vls;
      char save_coords;
d1493 2
a1494 34
      curr_dm_list = edit_rate_or_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'o';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		    edit_rate_object_origin,
		    edit_rate_object_rotate[X],
		    edit_rate_object_rotate[Y],
		    edit_rate_object_rotate[Z]);

      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_view_rotate ) {
      struct bu_vls vls;
      char save_coords;
d1496 1
a1496 34
      curr_dm_list = edit_rate_vr_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'v';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_ROTATE)
	  es_edflag = SROT;
      }else{
	save_edflag = edobj;
	edobj = BE_O_ROTATE;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -o %c -i -e ax %f ay %f az %f\n",
		    edit_rate_view_origin,
		    edit_rate_view_rotate[X],
		    edit_rate_view_rotate[Y],
		    edit_rate_view_rotate[Z]);

      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_model_tran ) {
      char save_coords;
      struct bu_vls vls;
d1498 4
a1501 29
      curr_dm_list = edit_rate_mt_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'm';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_TRAN)
	  es_edflag = STRANS;
      }else{
	save_edflag = edobj;
	edobj = BE_O_XY;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -i -e aX %f aY %f aZ %f\n",
		    edit_rate_model_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		    edit_rate_model_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		    edit_rate_model_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);

      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
d1503 3
a1505 3
    if( edit_rateflag_view_tran ) {
      char save_coords;
      struct bu_vls vls;
d1507 12
a1518 32
      curr_dm_list = edit_rate_vt_dm_list;
      save_coords = mged_variables->mv_coords;
      mged_variables->mv_coords = 'v';

      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_TRAN)
	  es_edflag = STRANS;
      }else{
	save_edflag = edobj;
	edobj = BE_O_XY;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -i -e aX %f aY %f aZ %f\n",
		    edit_rate_view_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		    edit_rate_view_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		    edit_rate_view_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);

      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      mged_variables->mv_coords = save_coords;

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
    if( edit_rateflag_scale ) {
      struct bu_vls vls;
d1520 7
a1526 22
      if(state == ST_S_EDIT){
	save_edflag = es_edflag;
	if(!SEDIT_SCALE)
	  es_edflag = SSCALE;
      }else{
	save_edflag = edobj;
	if(!OEDIT_SCALE)
	  edobj = BE_O_SCALE;
      }

      non_blocking++;
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "knob -i -e aS %f\n", edit_rate_scale * 0.01);

      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);

      if(state == ST_S_EDIT)
	es_edflag = save_edflag;
      else
	edobj = save_edflag;
    }
d1528 2
a1529 3
    FOR_ALL_DISPLAYS(p, &head_dm_list.l){
      if(!p->dml_owner)
	continue;
d1531 1
a1531 1
      curr_dm_list = p;
d1533 6
a1538 1
      if( view_state->vs_rateflag_model_rotate ) {
d1540 14
d1557 5
a1561 5
	bu_vls_printf(&vls, "knob -o %c -i -m ax %f ay %f az %f\n",
		      view_state->vs_rate_model_origin,
		      view_state->vs_rate_model_rotate[X],
		      view_state->vs_rate_model_rotate[Y],
		      view_state->vs_rate_model_rotate[Z]);
d1565 10
a1574 2
      }
      if( view_state->vs_rateflag_model_tran ) {
d1577 13
d1592 4
a1595 4
	bu_vls_printf(&vls, "knob -i -m aX %f aY %f aZ %f\n",
		      view_state->vs_rate_model_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      view_state->vs_rate_model_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      view_state->vs_rate_model_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);
d1599 10
a1608 2
      }
      if( view_state->vs_rateflag_rotate )  {
d1611 13
d1626 4
a1629 5
	bu_vls_printf(&vls, "knob -o %c -i -v ax %f ay %f az %f\n",
		      view_state->vs_rate_origin,
		      view_state->vs_rate_rotate[X],
		      view_state->vs_rate_rotate[Y],
		      view_state->vs_rate_rotate[Z]);
d1633 9
a1641 2
      }
      if( view_state->vs_rateflag_tran )  {
d1644 10
d1656 1
a1656 4
	bu_vls_printf(&vls, "knob -i -v aX %f aY %f aZ %f",
		      view_state->vs_rate_tran[X] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      view_state->vs_rate_tran[Y] * 0.05 * view_state->vs_vop->vo_scale * base2local,
		      view_state->vs_rate_tran[Z] * 0.05 * view_state->vs_vop->vo_scale * base2local);
a1659 3
      }
      if( view_state->vs_rateflag_scale )  {
	struct bu_vls vls;
d1661 76
a1736 7
	non_blocking++;
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "zoom %f",
		      1.0 / (1.0 - (view_state->vs_rate_scale / 10.0)));
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
      }
d1738 1
a1738 1
      curr_dm_list = save_dm_list;
d1761 16
a1776 26
  struct dm_list *p;
  struct dm_list *save_dm_list;
  struct bu_vls overlay_vls;
  struct bu_vls tmp_vls;
  register int do_overlay = 1;
  double elapsed_time;
  int do_time = 0;

  bu_vls_init(&overlay_vls);
  bu_vls_init(&tmp_vls);
  rt_prep_timer();

  FOR_ALL_DISPLAYS(p, &head_dm_list.l) {
      if (update_views || p->dml_view_state->vs_flag)
	  p->dml_dirty = 1;
  }

  /*
   * This needs to be done separately
   * because dml_view_state may be shared.
   */
  FOR_ALL_DISPLAYS(p, &head_dm_list.l) {
      p->dml_view_state->vs_flag = 0;
  }

  update_views = 0;
a1777 2
  save_dm_list = curr_dm_list;
  FOR_ALL_DISPLAYS(p, &head_dm_list.l) {
d1779 2
a1780 2
     * if something has changed, then go update the display.
     * Otherwise, we are happy with the view we have
d1782 24
a1805 16
    curr_dm_list = p;
    if (mapped && dirty) {
      dirty = 0;
      do_time = 1;
      VMOVE(geometry_default_color,color_scheme->cs_geo_def);

      if(dbip != DBI_NULL){
	if(do_overlay){
	    bu_vls_trunc(&overlay_vls, 0);
	    create_text_overlay(&overlay_vls);
	    do_overlay = 0;
	}

	/* XXX VR hack */
	if( viewpoint_hook )  (*viewpoint_hook)();
      }
d1807 3
a1809 2
      if( mged_variables->mv_predictor )
	predictor_frame();
d1811 4
a1814 1
      DM_DRAW_BEGIN(dmp);	/* update displaylist prolog */
d1817 81
a1897 81
      if (dbip != DBI_NULL) {
	      /* do framebuffer underlay */
	      if (mged_variables->mv_fb && !mged_variables->mv_fb_overlay) {
		      if (mged_variables->mv_fb_all)
			      fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
		      else if (mged_variables->mv_mouse_behavior != 'z')
			      paint_rect_area();
	      }

	      /* do framebuffer overlay for entire window */
	      if (mged_variables->mv_fb &&
		  mged_variables->mv_fb_overlay &&
		  mged_variables->mv_fb_all) {
		      fb_refresh(fbp, 0, 0, dmp->dm_width, dmp->dm_height);
	      } else {
		      /*  Draw each solid in it's proper place on the screen
		       *  by applying zoom, rotation, & translation.
		       *  Calls DM_LOADMATRIX() and DM_DRAW_VLIST().
		       */

		      if (dmp->dm_stereo == 0 ||
			  mged_variables->mv_eye_sep_dist <= 0) {
			      /* Normal viewing */
			      dozoom(0);
		      } else {
			      /* Stereo viewing */
			      dozoom(1);
			      dozoom(2);
		      }

		      /* do framebuffer overlay in rectangular area */
		      if (mged_variables->mv_fb &&
			  mged_variables->mv_fb_overlay &&
			  mged_variables->mv_mouse_behavior != 'z')
			      paint_rect_area();
	      }


	      /* Restore to non-rotated, full brightness */
	      DM_NORMAL(dmp);

	      /* only if not doing overlay */
	      if (!mged_variables->mv_fb ||
		  mged_variables->mv_fb_overlay != 2) {
		      if (rubber_band->rb_active || rubber_band->rb_draw)
			      draw_rect();

		      if (grid_state->gr_draw)
			      draw_grid();

		      /* Compute and display angle/distance cursor */
		      if (adc_state->adc_draw)
			      adcursor();

		      if (axes_state->ax_view_draw)
			      draw_v_axes();

		      if (axes_state->ax_model_draw)
			      draw_m_axes();

		      if (axes_state->ax_edit_draw &&
			  (state == ST_S_EDIT || state == ST_O_EDIT))
			      draw_e_axes();

		      /* Display titles, etc., if desired */
		      bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
		      dotitles(&tmp_vls);
		      bu_vls_trunc(&tmp_vls, 0);
	      }
      }

      /* only if not doing overlay */
      if (!mged_variables->mv_fb ||
	  mged_variables->mv_fb_overlay != 2) {
	      /* Draw center dot */
	      DM_SET_FGCOLOR(dmp,
			     color_scheme->cs_center_dot[0],
			     color_scheme->cs_center_dot[1],
			     color_scheme->cs_center_dot[2], 1, 1.0);
	      DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
      }
d1899 55
a1953 64
      if (dbip != DBI_NULL) {
	  /*  Draw each solid in it's proper place on the screen
	   *  by applying zoom, rotation, & translation.
	   *  Calls DM_LOADMATRIX() and DM_DRAW_VLIST().
	   */

	  if (dmp->dm_stereo == 0 ||
	      mged_variables->mv_eye_sep_dist <= 0) {
	      /* Normal viewing */
	      dozoom(0);
	  } else {
	      /* Stereo viewing */
	      dozoom(1);
	      dozoom(2);
	  }

	  /* Restore to non-rotated, full brightness */
	  DM_NORMAL(dmp);

	  if (rubber_band->rb_active || rubber_band->rb_draw)
	      draw_rect();

	  if (grid_state->gr_draw)
	      draw_grid();

	  /* Compute and display angle/distance cursor */
	  if (adc_state->adc_draw)
	      adcursor();

	  if (axes_state->ax_view_draw)
	      draw_v_axes();

	  if (axes_state->ax_model_draw)
	      draw_m_axes();

	  if (axes_state->ax_edit_draw &&
	      (state == ST_S_EDIT || state == ST_O_EDIT))
	      draw_e_axes();

	  /* Display titles, etc., if desired */
	  bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
	  dotitles(&tmp_vls);
	  bu_vls_trunc(&tmp_vls, 0);

	  /* Draw center dot */
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_center_dot[0],
			 color_scheme->cs_center_dot[1],
			 color_scheme->cs_center_dot[2], 1, 1.0);
	  DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
      }
#endif

      DM_DRAW_END(dmp);
    }
  }

  /* a frame was drawn */
  if(do_time){
    (void)rt_get_timer( (struct bu_vls *)0, &elapsed_time );
    /* Only use reasonable measurements */
    if( elapsed_time > 1.0e-5 && elapsed_time < 30 )  {
      /* Smoothly transition to new speed */
      frametime = 0.9 * frametime + 0.1 * elapsed_time;
a1954 1
  }
d1956 9
a1964 1
  curr_dm_list = save_dm_list;
d1966 4
a1969 2
  bu_vls_free(&overlay_vls);
  bu_vls_free(&tmp_vls);
d1980 5
a1984 5
	struct bu_vls line;
	time_t now;
	char *timep;
	int logfd;
	char uname[256] = {0};
d1986 2
a1987 2
	/* let the user know that we're logging */
	static int notified = 0;
d1990 1
a1990 1
	return;
d1993 4
a1996 4
	/* get the current time */
	(void)time( &now );
	timep = ctime( &now );	/* returns 26 char string */
	timep[24] = '\0';	/* Chop off \n */
d1998 1
a1998 1
	/* get the user name */
d2000 4
a2003 4
	{
	    DWORD dwNumBytes = 256;
	    GetUserName(uname, &dwNumBytes);
	}
d2005 1
a2005 1
	getlogin_r(uname, 256);
d2008 9
a2016 9
	bu_vls_init(&line);
	bu_vls_printf(&line, "%s (%ld) %s [%s] %s: %s\n",
		      timep,
		      (long)now,
		      event,
		      dmp->dm_name,
		      uname,
		      arg
	);
d2019 1
a2019 1
	logfd = open( LOGFILE, _O_WRONLY|_O_APPEND|O_CREAT, _S_IREAD|_S_IWRITE );
d2021 1
a2021 1
	logfd = open( LOGFILE, O_WRONLY|O_APPEND|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP );
d2024 4
a2027 4
	if (!notified) {
	    bu_log("Logging mged events to %s\n", LOGFILE);
	    notified = 1;
	}
d2029 6
a2034 7
	if (logfd >= 0) {
	    (void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
	    (void)close( logfd );
	} else {
	    if (notified) {
		perror("Unable to open event log file");
	    }
d2036 1
d2038 1
a2038 1
	bu_vls_free(&line);
d2051 2
a2052 2
	char place[64];
	register struct dm_list *p;
d2054 2
a2055 2
	(void)sprintf(place, "exit_status=%d", exitcode );
	log_event( "CEASE", place );
d2057 3
a2059 3
	/* Release all displays */
	FOR_ALL_DISPLAYS(p, &head_dm_list.l){
	  curr_dm_list = p;
d2061 2
a2062 3
	  if (curr_dm_list && dmp) {
	      DM_CLOSE(dmp);
	  }
d2064 1
d2066 1
a2066 1
	/* Be certain to close the database cleanly before exiting */
d2068 1
a2068 1
	Tcl_Eval(interp, "db close; .inmem close");
d2070 1
a2070 1
	Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
d2074 2
a2075 2
	if (wdbp)
		wdb_close(wdbp);
d2077 2
a2078 2
	if (dbip)
		db_close(dbip);
d2082 2
a2083 2
	if (cbreak_mode > 0)
	    reset_Tty(fileno(stdin));
d2086 2
a2087 2
	pkg_terminate();
	exit( exitcode );
d2099 2
a2100 2
	mged_finish(0);
	/* NOTREACHED */
d2110 1
a2110 1
  reset_input_strings();
d2112 1
a2112 1
  (void)signal( SIGINT, SIG_IGN );
d2122 2
a2123 2
  (void)signal( SIGINT, SIG_IGN );
  longjmp( jmp_env, 1 );
d2130 6
a2135 6
  if(BU_LIST_IS_HEAD(curr_cmd_list, &head_cmd_list.l)){
    /* Truncate input string */
    bu_vls_trunc(&input_str, 0);
    bu_vls_trunc(&input_str_prefix, 0);
    bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);
    input_str_index = 0;
d2137 6
a2142 6
    curr_cmd_list->cl_quote_string = 0;
    bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
    bu_log("\n");
    pr_prompt();
  }else{
    struct bu_vls vls;
d2144 5
a2148 5
    bu_vls_init(&vls);
    bu_vls_strcpy(&vls, "reset_input_strings");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
  }
d2161 1
a2161 1
	vo_update(view_state->vs_vop, interp, 0);
d2168 2
a2169 2
  register struct dm_list *p;
  struct dm_list *save_dm_list;
d2171 10
a2180 10
  save_dm_list = curr_dm_list;
  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
    if(!p->dml_owner)
      continue;

    curr_dm_list = p;
    bn_mat_mul( view_state->vs_model2objview, view_state->vs_vop->vo_model2view, modelchanges );
    bn_mat_inv( view_state->vs_objview2model, view_state->vs_model2objview );
    view_state->vs_flag = 1;
  }
d2182 1
a2182 1
  curr_dm_list = save_dm_list;
d2190 1
a2190 1
	struct _view_state *vsp = (struct _view_state *)clientData;
d2192 5
a2196 5
	if (state != ST_VIEW) {
		bn_mat_mul(vsp->vs_model2objview, vop->vo_model2view, modelchanges);
		bn_mat_inv(vsp->vs_objview2model, vsp->vs_model2objview);
	}
	vsp->vs_flag = 1;
d2213 4
a2216 4
	FILE	*fp = NULL;
	char	*path;
	struct	bu_vls str;
	int bogus;
d2218 1
a2218 1
	bu_vls_init( &str );
d2223 3
a2225 4
	if( (path = getenv(ENVRC)) != (char *)NULL ) {
		if ((fp = fopen(path, "r")) != NULL ) {
			bu_vls_strcpy( &str, path );
		}
d2227 1
d2229 5
a2233 5
	if( !fp ) {
		if( (path = getenv("HOME")) != (char *)NULL )  {
			bu_vls_strcpy( &str, path );
			bu_vls_strcat( &str, "/" );
			bu_vls_strcat( &str, RCFILE );
d2235 1
a2235 2
			fp = fopen(bu_vls_addr(&str), "r");
		}
d2237 1
d2239 3
a2241 4
	if( !fp ) {
		if( (fp = fopen( RCFILE, "r" )) != NULL )  {
			bu_vls_strcpy( &str, RCFILE );
		}
d2243 1
d2247 4
a2250 4
	if( !fp ){
	  bu_vls_free(&str);
	  return -1;
	}
d2252 13
a2264 13
	bogus = 0;
	while( !feof(fp) ) {
	    char buf[80];

	    /* Get beginning of line */
	    fgets( buf, 80, fp );
    /* If the user has a set command with an equal sign, remember to warn */
	    if( strstr(buf, "set") != NULL )
	      if( strchr(buf, '=') != NULL ){
		    bogus = 1;
		    break;
	      }
	}
d2266 11
a2276 11
	fclose( fp );
	if( bogus ) {
	    bu_log("\nWARNING: The new format of the \"set\" command is:\n");
	    bu_log("    set varname value\n");
	    bu_log("If you are setting variables in your %s, you will ", RCFILE);
	    bu_log("need to change those\ncommands.\n\n");
	}
	if (Tcl_EvalFile( interp, bu_vls_addr(&str) ) != TCL_OK) {
	    bu_log("Error reading %s:\n%s\n", RCFILE,
		Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
	}
d2278 2
a2279 2
	bu_vls_free(&str);
	return 0;
d2300 10
a2309 10
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	struct db_i		*save_dbip = DBI_NULL;
	struct mater		*save_materp = MATER_NULL;
	struct bu_vls		vls;
	struct bu_vls		msg;	/* use this to hold returned message */
	int			create_new_db = 0;
d2312 1
a2312 1
	if( argc <= 1 )  {
d2314 11
a2324 5
		/* Invoked without args, return name of current database */
		if( dbip != DBI_NULL )  {
			Tcl_AppendResult(interp, dbip->dbi_filename, (char *)NULL);
			return TCL_OK;
		}
d2326 6
a2331 3
		Tcl_AppendResult(interp, "", (char *)NULL);
		return TCL_OK;
	}
d2333 1
a2333 1
	bu_vls_init(&vls);
d2335 9
a2343 18
	if(3 < argc || (strlen(argv[1]) == 0)){
		bu_vls_printf(&vls, "help opendb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&msg);

	if(argc == 3 &&
	    strcmp("y", argv[2]) && strcmp("Y", argv[2]) &&
	    strcmp("n", argv[2]) && strcmp("N", argv[2])){
		bu_vls_printf(&vls, "help opendb");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}
d2345 9
a2353 4
	save_dbip = dbip;
	dbip = DBI_NULL;
	save_materp = rt_material_head;
	rt_material_head = MATER_NULL;
d2355 3
a2357 8
	/* Get input file */
	if( ((dbip = db_open( argv[1], "r+w" )) == DBI_NULL ) &&
	    ((dbip = db_open( argv[1], "r"   )) == DBI_NULL ) )  {
		char line[128];

		/*
	         * Check to see if we can access the database
	         */
d2359 4
a2362 4
		if (access(argv[1], R_OK|W_OK) != 0 && errno != ENOENT) {
			perror(argv[1]);
			return TCL_ERROR;
		}
d2364 4
a2367 4
		if ((access(argv[1], R_OK) != 0 || access(argv[1], W_OK) != 0)  && errno != ENOENT) {
			perror(argv[1]);
			return TCL_ERROR;
		}
d2370 8
a2377 64
	    	/* File does not exist */
		if (interactive) {
			if(mged_init_flag){
				if(classic_mged){
					bu_log("Create new database (y|n)[n]? ");
					(void)fgets(line, sizeof(line), stdin);
					if( line[0] != 'y' && line[0] != 'Y' ) {
						bu_log("Warning: no database is currently opened!\n");
						bu_vls_free(&vls);
						bu_vls_free(&msg);
						return TCL_OK;
					}
				} else{
					int status;

					if(dpy_string != (char *)NULL)
						bu_vls_printf(&vls, "cad_dialog .createdb %s \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
						    dpy_string, argv[1]);
					else
						bu_vls_printf(&vls, "cad_dialog .createdb :0 \"Create New Database?\" \"Create new database named %s?\" \"\" 0 Yes No Quit",
						    argv[1]);

					status = Tcl_Eval(interp, bu_vls_addr(&vls));

					if(status != TCL_OK || interp->result[0] == '2') {
						bu_vls_free(&vls);
						bu_vls_free(&msg);
						return TCL_ERROR;
					}

					if(interp->result[0] == '1') {
						bu_log("opendb: no database is currently opened!\n");
						bu_vls_free(&vls);
						bu_vls_free(&msg);
						return TCL_OK;
					}
				}
			} else { /* not initializing mged */
				if(argc == 2){
					/* need to reset this before returning */
					dbip = save_dbip;
					rt_material_head = save_materp;
					Tcl_AppendResult(interp, MORE_ARGS_STR, "Create new database (y|n)[n]? ",
					    (char *)NULL);
					bu_vls_printf(&curr_cmd_list->cl_more_default, "n");
					bu_vls_free(&vls);
					bu_vls_free(&msg);
					return TCL_ERROR;
				}

				if( *argv[2] != 'y' && *argv[2] != 'Y' ){
					dbip = save_dbip; /* restore previous database */
					rt_material_head = save_materp;
					bu_vls_free(&vls);
					bu_vls_free(&msg);
					return TCL_OK;
				}
			}
		}

	    	/* File does not exist, and should be created */
		if ((dbip = db_create(argv[1], db_version)) == DBI_NULL) {
			dbip = save_dbip; /* restore previous database */
			rt_material_head = save_materp;
d2380 11
d2392 1
a2392 12
			if (mged_init_flag) {
				/* we need to use bu_log here */
				bu_log("opendb: failed to create %s\n", argv[1]);
				bu_log("opendb: no database is currently opened!\n");
				return TCL_OK;
			}

			Tcl_AppendResult(interp, "opendb: failed to create ", argv[1], "\n",\
		       (char *)NULL);
			if (dbip == DBI_NULL)
				Tcl_AppendResult(interp, "opendb: no database is currently opened!", \
			 (char *)NULL);
d2394 3
d2398 20
a2418 1
	    	/* New database has already had db_dirbuild() by here */
d2420 29
a2448 4
		create_new_db = 1;
		bu_vls_printf(&msg, "The new database %s was successfully created.\n", argv[1]);
	} else {
		/* Opened existing database file */
d2450 1
a2450 2
		/* Scan geometry database and build in-memory directory */
		(void)db_dirbuild( dbip );
d2452 10
d2463 4
a2466 4
	/* close out the old dbip */
	if( save_dbip )  {
		struct db_i *new_dbip;
		struct mater *new_materp;
d2468 2
a2469 2
		new_dbip = dbip;
		new_materp = rt_material_head;
d2471 3
a2473 3
		/* activate the 'saved' values so we can cleanly close the previous db */
		dbip = save_dbip;
		rt_material_head = save_materp;
d2475 2
a2476 2
		/* bye bye db */
		f_closedb(clientData, interp, 1, NULL);
d2478 4
a2481 4
		/* restore to the new db just opened */
		dbip = new_dbip;
		rt_material_head = new_materp;
	}
d2483 2
a2484 2
	{
		register struct dm_list *dmlp;
d2486 4
a2489 5
		/* update local2base and base2local variables for all view objects */
		FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
			dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
			dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
		}
d2491 1
d2493 2
a2494 2
	if( dbip->dbi_read_only )
		bu_vls_printf(&msg, "%s: READ ONLY\n", dbip->dbi_filename);
d2496 2
a2497 2
	/* Quick -- before he gets away -- write a logfile entry! */
	log_event( "START", argv[1] );
d2499 5
a2503 51
	/* Provide LIBWDB C access to the on-disk database */
	if( (wdbp = wdb_dbopen( dbip, RT_WDB_TYPE_DB_DISK )) == RT_WDB_NULL )  {
		Tcl_AppendResult(interp, "wdb_dbopen() failed?\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* increment use count for this db instance */
	(void)db_clone_dbi(dbip, NULL);

	/* Establish LIBWDB TCL access to both disk and in-memory databases */
	if (wdb_init_obj(interp, wdbp, MGED_DB_NAME) != TCL_OK) {
		bu_vls_printf(&msg, "%s\n%s\n",
			      interp->result,
			      Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}

	/* This creates a "db" command object */
	if (wdb_create_cmd(interp, wdbp, MGED_DB_NAME) != TCL_OK) {
		bu_vls_printf(&msg, "%s\n%s\n",
			      interp->result,
			      Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}

	/* This creates the ".inmem" in-memory geometry container */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "wdb_open %s inmem [get_dbip]", MGED_INMEM_NAME);
	if (Tcl_Eval( interp, bu_vls_addr(&vls) ) != TCL_OK) {
		bu_vls_printf(&msg, "%s\n%s\n",
			      interp->result,
			      Tcl_GetVar(interp,"errorInfo", TCL_GLOBAL_ONLY) );
		Tcl_AppendResult(interp, bu_vls_addr(&msg), (char *)NULL);
		bu_vls_free(&vls);
		bu_vls_free(&msg);
		return TCL_ERROR;
	}

	/* link the drawable geometry object to the (new) database object */
	dgop->dgo_wdbp = wdbp;

	/* Perhaps do something special with the GUI */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "opendb_callback %s", dbip->dbi_filename);
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
d2505 2
a2506 16
	bu_vls_strcpy(&vls, "local2base");
	Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&local2base,
	    TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);

	bu_vls_strcpy(&vls, "base2local");
	Tcl_UnlinkVar(interp, bu_vls_addr(&vls));
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&base2local,
	    TCL_LINK_DOUBLE|TCL_LINK_READ_ONLY);

	set_localunit_TclVar();

	/* Print title/units information */
	if (interactive)
		bu_vls_printf(&msg, "%s (units=%s)\n", dbip->dbi_title,
			      bu_units_string(dbip->dbi_local2base));
d2508 10
a2517 9
	/*
	 * We have an old database version AND
	 * we're not in the process of
	 * creating a new database.
	 */
	if (dbip->dbi_version != 5 && !create_new_db) {
		if (db_upgrade) {
			if (db_warn)
				bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tConverting to the new format.\n");
d2519 10
a2528 11
			bu_vls_strcpy(&vls, "after idle dbupgrade -f y");
			(void)Tcl_Eval(interp, bu_vls_addr(&vls));
		} else {
			if (db_warn) {
				if (classic_mged)
					bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tSee the dbupgrade command.");
				else
					bu_vls_printf(&msg, "Warning:\n\tDatabase version is old.\n\tSelect Tools-->Upgrade Database for info.");
			}
		}
	}
d2530 7
a2536 1
	Tcl_ResetResult( interp );
a2537 1

d2540 55
d2597 10
a2606 10
	/*XXX
	 *    This combined with the mged.bat (which contains "mged.exe 2>&1 nul")
	 *    causes Windows to pass the stdout/stderr to mged's command window.
	 *    There must be a better way, but, I've run out of time (for now).
	 */
       if (!strcmp(argv[1], "nul")) {
	   Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
	   dbip = DBI_NULL;
	   rt_material_head = MATER_NULL;
       }
d2609 1
a2609 1
	return TCL_OK;
d2621 4
a2624 4
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
d2626 1
a2626 1
	char *av[2];
d2628 4
a2631 4
	if( argc != 1 )  {
		Tcl_Eval(interp, "help closedb");
		return TCL_ERROR;
	}
d2633 4
a2636 4
	if (dbip == DBI_NULL) {
		Tcl_AppendResult(interp, "No database is open\n", (char *)NULL);
		return TCL_OK;
	}
d2638 4
a2641 4
	/* Clear out anything in the display */
	av[0] = "zap";
	av[1] = NULL;
	cmd_zap(clientData, interp, 1, av);
d2643 1
a2643 1
	/* Close the Tcl database objects */
d2645 1
a2645 1
	Tcl_Eval(interp, "db close; .inmem close");
d2647 1
a2647 1
	Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
d2650 1
a2650 1
	log_event( "CEASE", "(close)" );
d2652 3
a2654 3
	/* update any and all other displays */
	{
		register struct dm_list *dmlp;
d2656 4
a2659 5
		/* update local2base and base2local variables for all view objects */
		FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
			dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
			dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
		}
d2661 1
d2663 3
a2665 3
	/* wipe out the global pointers */
	dbip = DBI_NULL;
	rt_material_head = MATER_NULL;
d2667 1
a2667 1
	return TCL_OK;
d2674 1
a2674 1
	struct bu_vls vls;
d2676 8
a2683 8
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "set mbh_dialog [Dialog .#auto -modality application];");
	bu_vls_printf(&vls, "$mbh_dialog hide 1; $mbh_dialog hide 2; $mbh_dialog hide 3;");
	bu_vls_printf(&vls, "label [$mbh_dialog childsite].l -text {%s};", str);
	bu_vls_printf(&vls, "pack [$mbh_dialog childsite].l;");
	bu_vls_printf(&vls, "update; $mbh_dialog activate");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
d2685 1
a2685 1
	return TCL_OK;
@


14.39
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.38 2006/07/09 18:25:32 brlcad Exp $ (BRL)";
a141 4
/* defined in attach.c */
extern int mged_link_vars(struct dm_list *p);
extern int is_dm_null(void);

@


14.38
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.37 2006/06/27 14:24:44 bob1961 Exp $ (BRL)";
d1398 1
a1398 1
  char line[MAXLINE] = {0};
d1404 1
a1404 1
  count = read((int)fd, line, MAXLINE);
d1406 1
a1406 1
  ReadFile(fd, line, MAXLINE,&count,0);
@


14.37
log
@Minor fix in log_event for _WIN32.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.36 2006/06/26 02:40:54 brlcad Exp $ (BRL)";
d865 1
a865 1
      ReadFile(fd,buf,4096,&count,NULL);
d875 4
d1398 1
a1398 1
  char line[MAXLINE];
d1404 1
a1404 1
  if((count = read((int)fd, line, MAXLINE)) <= 0)
d1406 1
a1406 1
  if((!ReadFile(fd, line, MAXLINE,&count,0)))
d1408 7
a1414 1
    return;
@


14.36
log
@er, unless i'm blind, there's no difference between the _WIN32 and non-_WIN32 section.  collapse into one
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.35 2006/06/22 15:56:11 brlcad Exp $ (BRL)";
d1994 4
a1997 2
	DWORD dwNumBytes = 256;
	GetUserName(uname, &dwNumBytes);
@


14.35
log
@prevent a bus error if read() returns -1 when reading from the provided file descriptor
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.34 2006/06/22 15:51:51 brlcad Exp $ (BRL)";
d182 2
a183 1
void		sig2(int), sig3(int);
d2082 1
d2095 1
a2098 1
#ifndef _WIN32
d2107 1
a2116 16
#else
void
sig2(int sig)
{
  reset_input_strings();

  (void)signal( SIGINT, SIG_IGN );
}

void
sig3(int sig)
{
  (void)signal( SIGINT, SIG_IGN );
  longjmp( jmp_env, 1 );
}
#endif
@


14.34
log
@add support for the Mac delete key (backwards and forwards should work now).  also fix vi command line editing mode history, quell warnings, pass null parameter.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.31 2006/06/01 14:53:43 brlcad Exp $ (BRL)";
d1399 1
a1399 1
  if((count = read((int)fd, line, MAXLINE)) == 0)
@


14.33
log
@bigger, better vi command line editing in mged provided by james (swcto).  this adds command history searching as well as pretty much full vi-mode command editing.  (sf patch 1377410 - Bigger, Better vi command line editing)
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.32 2006/06/08 18:36:09 brlcad Exp $ (BRL)";
d765 1
a765 2
extern struct bu_vls *history_prev(const char *);
extern struct bu_vls *history_next(const char *);
d902 1
d922 1
a922 1
  /* ANSI arrow keys */
d924 1
d926 2
d932 7
d1022 1
a1023 1
  case DELETE:
d1139 1
a1139 1
	vp = history_prev((char*)NULL);
d1153 1
a1153 1
	vp = history_prev((char *)NULL);
d1159 1
a1159 1
	vp = history_next((char *)NULL);
d1313 6
a1981 3
	/* XXX unconditionally disable for now */
	return;

@


14.32
log
@unconditionally disable for now
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.31 2006/06/01 14:53:43 brlcad Exp $ (BRL)";
d765 2
a766 1
extern struct bu_vls *history_prev(void), *history_cur(void), *history_next(void);
d1129 1
a1129 1
	vp = history_prev();
d1143 1
a1143 1
	vp = history_prev();
d1149 1
a1149 1
	vp = history_next();
@


14.31
log
@avoid incrementing the dbi_uses counter directly -- do a clientless clone of the dbip instead
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.30 2006/05/21 16:15:33 brlcad Exp $ (BRL)";
d1965 3
@


14.30
log
@make sure the curr_dm_list isn't null before trying to close the dm
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.29 2006/05/12 16:47:26 twingy Exp $ (BRL)";
d2494 1
a2494 1
	dbip->dbi_uses++;
@


14.29
log
@/dev/null should be in quotes, compiling with --disable-debug.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.28 2006/05/03 16:19:47 brlcad Exp $ (BRL)";
d2035 3
a2037 1
	  DM_CLOSE(dmp);
@


14.28
log
@john noticed that sys/stat.h is needed for S_IRUSR and a few other mode flags now being used if DEBUG is enabled
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.27 2006/04/30 03:19:58 brlcad Exp $ (BRL)";
d123 1
a123 1
#  define LOGFILE /dev/null
@


14.27
log
@fix the mged logging so that it actually works now and consistently writes events.  clean up the whitespace while refactoring the closure of a db to f_closedb() consistently.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.26 2006/02/14 20:28:17 brlcad Exp $ (BRL)";
d86 3
@


14.26
log
@don't attempt to call do_titles() with an overlay_vls that hasn't been initialized.  this 'also' fixes sf bug 1326045 that was fixed by another edit as well
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.25 2006/02/03 02:07:53 brlcad Exp $ (BRL)";
d109 9
a117 3
#ifndef _WIN32
#  ifndef LOGFILE
#    define LOGFILE	"/vld/lib/gedlog"	/* usage log */
d120 1
a120 3
#  ifndef LOGFILE
#    define LOGFILE	"C:\\gedlog"		/* usage log */
#  endif
d895 1
a895 1
  struct bu_vls *vp;
d1957 8
d1966 1
d1971 8
d1980 3
a1982 2
#ifndef _WIN32
	bu_vls_printf(&line, "%s [%s] time=%ld uid=%d (%s) %s\n",
d1985 1
a1985 3
		      (long)now,
		      getuid(),
		      timep,
d1988 3
d1992 1
a1992 12
	{
		char uname[256];
		DWORD dwNumBytes = 256;
		GetUserName(uname, &dwNumBytes);
		bu_vls_printf(&line, "%s [%s] time=%ld uid=%d (%s) %s\n",
		      event,
		      dmp->dm_name,
		      (long)now,
		      uname,
		      timep,
		      arg);
	}
d1995 3
a1997 4
#ifndef _WIN32
	if( (logfd = open( LOGFILE, O_WRONLY|O_APPEND )) >= 0 )  {
		(void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
		(void)close( logfd );
d1999 8
a2006 4
#else
	if( (logfd = open( LOGFILE, _O_WRONLY|_O_APPEND )) >= 0 )  {
		(void)write( logfd, bu_vls_addr(&line), (unsigned)bu_vls_strlen(&line) );
		(void)close( logfd );
a2007 2
#endif

d2288 2
a2289 2
	struct db_i		*save_dbip;
	struct mater		*save_materp;
d2446 1
a2447 1
		char *av[2];
d2451 2
a2452 2
		av[0] = "zap";
		av[1] = NULL;
d2454 1
a2454 1
		new_dbip = dbip;
a2455 1
		new_materp = rt_material_head;
d2458 2
a2459 9
		/* Clear out anything in the display */
		cmd_zap(clientData, interp, 1, av);

		/* Close the Tcl database objects */
#if 0
		Tcl_Eval(interp, "db close; .inmem close");
#else
		Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
#endif
d2461 1
a2463 2

		log_event( "CEASE", "(close)" );
d2492 1
a2492 3
	/* This creates "db" and ".inmem" Tcl objects */
	if (wdb_init_obj(interp, wdbp, MGED_DB_NAME) != TCL_OK ||
	    wdb_create_cmd(interp, wdbp, MGED_DB_NAME) != TCL_OK) {
d2501 13
d2526 1
a2526 1
	/* link the drawable geometry object to the database object */
d2556 1
a2556 1
	if (wdbp->dbip->dbi_version != 5 && !create_new_db) {
@


14.25
log
@use bu_getprogname/bu_setprogname instead of bu_argv0
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.24 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d1738 1
d1742 4
a1745 3
  FOR_ALL_DISPLAYS(p, &head_dm_list.l)
	  if (update_views || p->dml_view_state->vs_flag)
		  p->dml_dirty = 1;
d1751 3
a1753 2
  FOR_ALL_DISPLAYS(p, &head_dm_list.l)
	  p->dml_view_state->vs_flag = 0;
d1758 1
a1758 1
  FOR_ALL_DISPLAYS(p, &head_dm_list.l){
d1771 3
a1773 3
	  bu_vls_init(&overlay_vls);
	  create_text_overlay(&overlay_vls);
	  do_overlay = 0;
d1937 1
a1937 3
  if (!do_overlay)
      bu_vls_free(&overlay_vls);

@


14.24
log
@update copyright to 2006
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.23 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d277 1
a277 1
	bu_argv0(argv[0]);
@


14.23
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1993-2005 United States Government as represented by
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.22 2005/12/13 03:51:55 brlcad Exp $ (BRL)";
d56 1
a56 1
This software is Copyright (C) 1985-2005 by the United States Government \
@


14.22
log
@the Tcl_Interp *interp global is moved to ged.c since it's prevalent to all of mged; remove the PATH modification, moving it into mged_setup() (now in setup.c)
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.21 2005/11/15 03:27:35 brlcad Exp $ (BRL)";
a108 5
#ifdef _WIN32
#  define R_OK 2
#  define W_OK 4
#endif

a126 3
extern void fb_tclInit();  /* from in libfb/tcl.c */
extern int fb_refresh();

d137 1
a144 3
/* defined in libdm/dm-Null.c */
extern struct dm dm_Null;

d262 1
d264 2
a265 1
	int	parent_pipe[2] = {0};
d332 1
d336 1
a342 1
#endif
d400 1
d551 1
d555 1
d579 2
d599 1
a599 1

d602 1
d613 1
d617 1
d620 3
a622 2
	      bu_log("%s\nMGED Aborted.\n", interp->result);
	      mged_finish(1);
d672 1
d691 3
a693 1
	}else{
d767 1
d1328 1
d1738 1
a1768 1
	  bu_vls_init(&tmp_vls);
d1782 1
d1864 53
d1934 4
a1937 4
  if(!do_overlay){
    bu_vls_free(&overlay_vls);
    bu_vls_free(&tmp_vls);
  }
d2036 1
d2039 3
a2041 1

d2562 14
@


14.21
log
@disable the path modification as the putenv seems to confuse tcl
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.20 2005/11/14 21:23:46 brlcad Exp $ (BRL)";
d110 2
a111 2
#define R_OK 2
#define W_OK 4
d115 3
a117 3
#ifndef	LOGFILE
#define LOGFILE	"/vld/lib/gedlog"	/* usage log */
#endif
d119 3
a121 3
#ifndef	LOGFILE
#define LOGFILE	"C:\\gedlog"	/* usage log */
#endif
d124 1
a142 3
/* defined in cmd.c */
extern Tcl_Interp *interp;

d170 3
a407 1

d512 1
a512 1
	/* Get set up to use Tcl */
a582 30
#if 0 && defined(HAVE_GETENV) && defined (HAVE_PUTENV)
	/* append our own bin dir to (the end of) our search path */
	{
	    struct bu_vls newpath;
	    const char *path = getenv("PATH");
	    const char *binpath = bu_brlcad_root("bin", 1);

	    if (binpath) {
		
		bu_vls_init(&newpath);
		
		if (path) {
		    if (path[strlen(path)-1] == ':') {
		    bu_vls_printf(&newpath, "PATH=%s%s", path, binpath);
		    } else {
			bu_vls_printf(&newpath, "PATH=%s:%s", path, binpath);
		    }
		} else {
		    bu_vls_printf(&newpath, "PATH=%s", binpath);
		}
		
		if (putenv(bu_vls_addr(&newpath)) != 0) {
		    perror("putenv:");
		}
		
		bu_vls_free(&newpath);
	    }
	}
#endif

@


14.20
log
@dammit! remove the mged_finish() debug line so mged does not terminate early
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d583 1
a583 1
#if defined(HAVE_GETENV) && defined (HAVE_PUTENV)
@


14.19
log
@append the brl-cad bin directory to the end of the user's PATH during run-time to allow binaries to be automatically located without the user needing to append our location to their environment.  this will let the user invoke any brl-cad binary on the mged command-line even through an exec.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.18 2005/11/07 01:10:48 brlcad Exp $ (BRL)";
a611 1
		mged_finish(1);
@


14.18
log
@need to init the vls before first use, potential for crash.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.17 2005/11/06 17:05:32 brlcad Exp $ (BRL)";
d83 3
d538 1
d541 1
d548 1
d560 1
a560 1
	      bu_log("%s\nMGED Aborted.\n", interp->result);
d563 1
d583 31
@


14.17
log
@if tk fails to load, try a simple local port initialization.  replace the exit calls with mged_finish calls like we're supposed to.  if the database doesn't exist, notify the parent we're done before exiting so parent exits cleanly.
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.16 2005/10/31 07:30:58 brlcad Exp $ (BRL)";
d2208 1
d2222 2
d2227 1
a2230 1
	bu_vls_init(&vls);
@


14.16
log
@header cleanup, reorg, and general bug squashing including adding missing headers
@
text
@d44 1
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.15 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
d269 1
a269 1
	int	parent_pipe[2];
d397 3
d546 5
d555 1
a555 1
	      exit(1);
d562 6
a567 2
	  if(f_opendb( (ClientData)NULL, interp, 2, argv ) == TCL_ERROR)
	    mged_finish(1);
d613 1
a613 1
	      exit(1);
d2191 4
d2290 3
a2292 1
						mged_finish(0);
@


14.15
log
@trailing ws
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.14 2005/09/16 18:51:53 brlcad Exp $ (BRL)";
d96 2
a355 2
		int buffer[2] = {0};

@


14.14
log
@rework tkwin into cmd.c and profide the DM_X and DM_OGL defines to the build.  probably fixes a bug or two of some sort on the display manager.  also migrate the tolerance vars together along with other ws and header cleanup
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.13 2005/07/25 05:50:59 brlcad Exp $ (BRL)";
d63 1
a63 1
                                                                                                                                                                            
d255 1
a255 1
/* 
d328 1
a328 1
		
d377 1
a377 1
		    
d581 1
a581 1
	    
d584 1
a584 1
	    
d606 1
a606 1
	    
d611 1
a611 1
	    
d756 2
a757 2
#else	
    fd = (HANDLE)clientData;      
d787 1
a787 1
	
d858 1
a858 1
#endif	
d889 1
a889 1
    
d930 1
a930 1
	
d1067 1
a1067 1
    
d1138 1
a1138 1
      
d1141 1
a1141 1
      
d1145 1
a1145 1
      
d1149 1
a1149 1
      
d1152 1
a1152 1
      
d1157 1
a1157 1
      
d1167 1
a1167 1
  
d1339 1
a1339 1
#endif  
d1391 1
a1391 1
	
d1400 1
a1400 1
    
d1434 1
a1434 1
	
d1469 1
a1469 1
	
d1504 1
a1504 1
	
d1538 1
a1538 1
	
d1572 1
a1572 1
	
d1599 1
a1599 1
	
d1625 1
a1625 1
	
d1679 1
a1679 1
      
d1888 2
a1889 2
		char uname[256]; 
		DWORD dwNumBytes = 256; 
d1956 2
a1957 2
	    reset_Tty(fileno(stdin)); 
	    
d2039 1
a2039 1
 *  
d2150 1
a2150 1
	
d2509 1
a2509 1
	
d2515 1
a2515 1
		
d2522 1
a2522 1
	
d2544 1
a2544 1
	
@


14.13
log
@set bu's argv[0] so we can find our run-time location in brlcad_path routines
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.12 2005/07/11 02:58:01 brlcad Exp $ (BRL)";
a138 4
#ifdef DM_X
extern Tk_Window tkwin;
#endif

d218 2
a219 1
struct bn_tol	mged_tol;		/* calculation tolerance */
@


14.13.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@a43 1
 *      Christopher Sean Morrison
d50 1
a50 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d63 1
a63 1

a81 3
#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#endif
a95 2
#include "db.h"

d139 4
d222 1
a222 2
struct bn_tol		mged_tol;	/* calculation tolerance */
struct rt_tess_tol	mged_ttol;	/* XXX needs to replace mged_abs_tol, et.al. */
d258 1
a258 1
/*
d269 1
a269 1
	int	parent_pipe[2] = {0};
d331 1
a331 1

d357 2
d380 1
a380 1

a398 3
		    /* exit instead of mged_finish as this is the
		     * parent process.
		     */
a533 1
	  struct bu_vls error;
a535 1
	  bu_vls_init(&error);
a541 1
	  bu_vls_strcpy(&error, interp->result);
a544 5
	      /* failed to load tk, try localhost X11 */
	      status = Tcl_Eval(interp, "loadtk :0");
	  }

	  if (status != TCL_OK) {
d548 2
a549 2
	      bu_log("%s\nMGED Aborted.\n", bu_vls_addr(&error));
	      mged_finish(1);
a550 1
	  bu_vls_free(&error);
d556 2
a557 6
	    if(f_opendb( (ClientData)NULL, interp, 2, argv ) == TCL_ERROR) {
		if( !run_in_foreground && use_pipe ) {
		    notify_parent_done(parent_pipe[1]);
		}
		mged_finish(1);
	    }
a565 31
#if defined(HAVE_GETENV) && defined (HAVE_PUTENV)
	/* append our own bin dir to (the end of) our search path */
	{
	    struct bu_vls newpath;
	    const char *path = getenv("PATH");
	    const char *binpath = bu_brlcad_root("bin", 1);

	    if (binpath) {
		
		bu_vls_init(&newpath);
		
		if (path) {
		    if (path[strlen(path)-1] == ':') {
		    bu_vls_printf(&newpath, "PATH=%s%s", path, binpath);
		    } else {
			bu_vls_printf(&newpath, "PATH=%s:%s", path, binpath);
		    }
		} else {
		    bu_vls_printf(&newpath, "PATH=%s", binpath);
		}
		
		if (putenv(bu_vls_addr(&newpath)) != 0) {
		    perror("putenv:");
		}
		
		bu_vls_free(&newpath);
	    }
	}
#endif
		mged_finish(1);

d584 1
a584 1

d587 1
a587 1

d603 1
a603 1
	      mged_finish(1);
d609 1
a609 1

d614 1
a614 1

d759 2
a760 2
#else
    fd = (HANDLE)clientData;
d790 1
a790 1

d861 1
a861 1
#endif
d892 1
a892 1

d933 1
a933 1

d1070 1
a1070 1

d1141 1
a1141 1

d1144 1
a1144 1

d1148 1
a1148 1

d1152 1
a1152 1

d1155 1
a1155 1

d1160 1
a1160 1

d1170 1
a1170 1

d1342 1
a1342 1
#endif
d1394 1
a1394 1

d1403 1
a1403 1

d1437 1
a1437 1

d1472 1
a1472 1

d1507 1
a1507 1

d1541 1
a1541 1

d1575 1
a1575 1

d1602 1
a1602 1

d1628 1
a1628 1

d1682 1
a1682 1

d1891 2
a1892 2
		char uname[256];
		DWORD dwNumBytes = 256;
d1959 2
a1960 2
	    reset_Tty(fileno(stdin));

d2042 1
a2042 1
 *
d2153 1
a2153 1

a2180 4
 *
 *  Returns TCL_OK if the database opened
 *  Returns TCL_ERROR if the database was not opened (and the user did
 *    not interactively abort)
a2193 1
	
a2206 2
	bu_vls_init(&vls);

a2209 1
		bu_vls_free(&vls);
d2213 1
d2276 1
a2276 3
						bu_vls_free(&vls);
						bu_vls_free(&msg);
						return TCL_ERROR;
d2512 1
a2512 1

d2518 1
a2518 1

d2525 1
a2525 1

d2547 1
a2547 1

@


14.13.4.2
log
@merge bogus abort removal from HEAD
@
text
@d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.20 2005/11/14 21:23:46 brlcad Exp $ (BRL)";
d612 1
@


14.13.2.1
log
@Mods for windows port
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.13 2005/07/25 05:50:59 brlcad Exp $ (BRL)";
d103 5
d125 3
d152 3
a267 1
#ifndef _WIN32
a268 1
#endif
a335 1
#ifndef _WIN32
a338 1
#endif
d345 1
a401 1
#endif
a544 1
#ifndef _WIN32
a547 1
#endif
a565 2
	pkg_init();

a584 1
#ifndef _WIN32
d587 1
a587 2
#endif

a596 1
#ifndef _WIN32
a599 1
#endif
d602 2
a603 3
		bu_log("%s\nMGED Aborted.\n", interp->result);
		pkg_terminate();
		exit(1);
a652 1
#ifndef _WIN32
d671 1
a671 3
	} else
#endif
	{
a744 1
#ifndef _WIN32
a1304 1
#endif
a1713 1
  bu_vls_init(&tmp_vls);
d1744 1
a1757 1
#ifndef _WIN32
a1838 53
#else
      if (dbip != DBI_NULL) {
	  /*  Draw each solid in it's proper place on the screen
	   *  by applying zoom, rotation, & translation.
	   *  Calls DM_LOADMATRIX() and DM_DRAW_VLIST().
	   */

	  if (dmp->dm_stereo == 0 ||
	      mged_variables->mv_eye_sep_dist <= 0) {
	      /* Normal viewing */
	      dozoom(0);
	  } else {
	      /* Stereo viewing */
	      dozoom(1);
	      dozoom(2);
	  }

	  /* Restore to non-rotated, full brightness */
	  DM_NORMAL(dmp);

	  if (rubber_band->rb_active || rubber_band->rb_draw)
	      draw_rect();

	  if (grid_state->gr_draw)
	      draw_grid();

	  /* Compute and display angle/distance cursor */
	  if (adc_state->adc_draw)
	      adcursor();

	  if (axes_state->ax_view_draw)
	      draw_v_axes();

	  if (axes_state->ax_model_draw)
	      draw_m_axes();

	  if (axes_state->ax_edit_draw &&
	      (state == ST_S_EDIT || state == ST_O_EDIT))
	      draw_e_axes();

	  /* Display titles, etc., if desired */
	  bu_vls_strcpy(&tmp_vls, bu_vls_addr(&overlay_vls));
	  dotitles(&tmp_vls);
	  bu_vls_trunc(&tmp_vls, 0);

	  /* Draw center dot */
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_center_dot[0],
			 color_scheme->cs_center_dot[1],
			 color_scheme->cs_center_dot[2], 1, 1.0);
	  DM_DRAW_POINT_2D(dmp, 0.0, 0.0);
      }
#endif
d1856 4
a1859 4
  if (!do_overlay)
      bu_vls_free(&overlay_vls);

  bu_vls_free(&tmp_vls);
a1957 1
#ifndef _WIN32
a1959 1
#endif
a1960 1
	pkg_terminate();
a2471 14

#ifdef _WIN32
	/*XXX
	 *    This combined with the mged.bat (which contains "mged.exe 2>&1 nul")
	 *    causes Windows to pass the stdout/stderr to mged's command window.
	 *    There must be a better way, but, I've run out of time (for now).
	 */
       if (!strcmp(argv[1], "nul")) {
	   Tcl_Eval(interp, "rename db \"\"; rename .inmem \"\"");
	   dbip = DBI_NULL;
	   rt_material_head = MATER_NULL;
       }
#endif

@


14.12
log
@improve the parent/child startup process even more.  now the parent will wait up to 90 seconds for the window initialization, but the child will also inform the parent even when aborting early due to some error (like an unset DISPLAY).  make a clear statement that mged has quit if the client aborts.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.11 2005/07/05 05:07:30 brlcad Exp $ (BRL)";
d281 2
@


14.12.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.13 2005/07/25 05:50:59 brlcad Exp $ (BRL)";
a280 2
	bu_argv0(argv[0]);

@


14.11
log
@cull the blocking read now that select is selectively selecting appropriately
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.10 2005/07/05 05:04:44 brlcad Exp $ (BRL)";
d243 15
a260 1

d374 2
a375 1
		     * parent process (child sends us a byte).
d381 1
a381 1
			timeout.tv_sec = 10;
d388 1
a388 1
			    fprintf(stdout, "\nAborted\n");
d543 5
a547 2
	    bu_log("%s", interp->result);
	    exit(1);
d581 1
a581 1
	    int buffer[2] = {0};
a590 5
	    if (status != TCL_OK) {
	      bu_log("%s", interp->result);
	      exit(1);
	    }

d596 6
a601 6
		if (write(parent_pipe[1], buffer, 1) == -1) {
		    perror("Unable to write to communication pipe");
		}
		if (close(parent_pipe[1]) == -1) {
		    perror("Unable to close communication pipe");
		}
@


14.10
log
@dang it, nfds is off by one -- check our own pipe fd ya dolt.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.9 2005/07/04 15:41:57 brlcad Exp $ (BRL)";
a362 5
#if 0
			if (read(parent_pipe[0], buffer, 1) == -1) {
			    perror("Unable to read from communication pipe");
			}
#else
d377 1
a377 1
#endif
d386 1
a386 1
#if 1
a394 1
#endif
@


14.9
log
@perform a select on the pipe instead of a blocking read in case the parent dies/fails without sending a response (e.g. no X11 connectivity).  wait up to 10 seconds and then give up.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.8 2005/06/02 23:49:56 brlcad Exp $ (BRL)";
d373 1
a373 1
			read_result = select(parent_pipe[0], &set, NULL, NULL, &timeout);
@


14.8
log
@add a -f option to mged to prevent it from automatically detaching on startup -- this is often very useful for logging or debugging.  also, make the backgrounding notice wait until the gui is up and running before exiting instead of sleeping an arbitrary amount of time -- the child notifies the parent when the gui is up.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.7 2005/05/28 02:14:51 brlcad Exp $ (BRL)";
d354 4
d363 1
d367 16
a382 1
			fprintf(stdout, "done\n");
@


14.7
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.6 2005/03/28 04:45:11 bob1961 Exp $ (BRL)";
d194 1
d254 4
d267 1
a267 1
	while ((c = bu_getopt(argc, argv, "d:hicnrx:X:")) != EOF)
d291 3
d340 11
a350 2
	if( !classic_mged ) {
		pid_t pid;
d354 14
a367 3
			fprintf( stdout, "Backgrounding, please wait...\n" );
			sleep( 3 );	/* just so it does not appear that MGED has died */
			exit( 0 );
d549 1
d558 1
a558 1
	    
d564 13
@


14.6
log
@Added call to wdb_create_cmd() due to change in wdb_init_obj()
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.5 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
d103 1
a103 1
#ifdef WIN32
d108 1
a108 1
#ifndef WIN32
d230 1
a230 1
#ifndef WIN32
d253 1
a253 1
#ifdef WIN32
d258 1
a258 1
#ifdef WIN32
d274 1
a274 1
#ifndef WIN32
d319 1
a319 1
#ifndef WIN32
d535 1
a535 1
#ifndef WIN32
d553 1
a553 1
#endif  /* WIN32 */
d583 1
a583 1
#ifndef WIN32
d608 1
a608 1
#ifndef WIN32
d680 1
a680 1
#ifndef WIN32
d686 1
a686 1
#ifndef WIN32
d762 1
a762 1
#  ifdef WIN32
d1267 1
a1267 1
#ifndef WIN32
d1279 1
a1279 1
#ifndef WIN32
d1809 1
a1809 1
#ifndef WIN32
d1833 1
a1833 1
#ifndef WIN32
d1908 1
a1908 1
#ifndef WIN32
d2168 1
a2168 1
#ifndef WIN32
@


14.5
log
@update copyright to 2005
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.4 2004/12/24 02:05:43 brlcad Exp $ (BRL)";
d2327 2
a2328 1
	if (wdb_init_obj(interp, wdbp, MGED_DB_NAME) != TCL_OK) {
@


14.4
log
@properly continue the unterminated copyright string.
@
text
@d4 1
a4 1
 * Copyright (c) 1993-2004 United States Government as represented by
d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/ged.c,v 14.3 2004/12/21 07:46:27 morrison Exp $ (BRL)";
d55 1
a55 1
This software is Copyright (C) 1985-2004 by the United States Government \
@


14.3
log
@brl-cad is open source software now.
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/ged.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
d54 1
a54 1
BRL-CAD is Open Source software.
@


14.2
log
@GPL License changes
@
text
@d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/ged.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
d54 3
a56 5
Re-distribution of this software is restricted, as described in \
your 'Statement of Terms and Conditions for the Release of \
The BRL-CAD Pacakge' agreement. \
This software is Copyright (C) 1985,1987,1990,1993 by the United States Army \
in all countries except the USA.  All rights reserved.";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G E D . C
a47 9
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d50 1
a50 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/ged.c,v 1.6 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.6
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/ged.c,v 1.5 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d2470 10
@


1.5
log
@replace the wrapped config.h block with common.h
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/ged.c,v 1.4 2004/06/28 04:29:32 morrison Exp $ (BRL)";
d57 1
a57 1
#ifdef USE_STRING_H
@


1.4
log
@need errno.h on irix .. rework some of the other header inclusions too
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/ged.c,v 1.3 2004/06/09 18:00:14 erikg Exp $ (BRL)";
d50 1
a50 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.3
log
@include unistd.h for STDIN_FILENO
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/ged.c,v 1.2 2004/06/08 22:04:28 morrison Exp $ (BRL)";
d60 1
a60 1
#include <string.h>
d62 4
a65 1
#include <strings.h>
a66 1
#include <fcntl.h>
d70 5
a74 2
#ifndef WIN32
#include <sys/errno.h>
a97 2
#include <fcntl.h>
#include <errno.h>
@


1.2
log
@obliterate externs.h
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d54 4
a57 2


@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/ged.c,v 11.225 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a76 1
#include "externs.h"
@

