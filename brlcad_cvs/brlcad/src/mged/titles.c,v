head	14.13;
access;
symbols
	rel-7-10-4:14.12.2.1
	STABLE:14.12.0.2
	stable-branch:14.3
	rel-7-10-2:14.12
	rel-7-10-0:14.12
	rel-7-8-4:14.10
	rel-7-8-2:14.10
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.3
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.13
date	2007.09.15.16.23.18;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.23.01.13.42;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2007.01.20.14.36.58;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.05.15.20.19.17;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.02.14.20.23.07;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.02.04.16.08.37;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.02.04.15.38.55;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.09.16.18.51.53;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches
	14.3.6.1;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.29;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.28;	author morrison;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.18;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2007.09.28.14.04.35;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.13
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                        T I T L E S . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file titles.c
 *
 * Functions -
 *	dotitles	Output GED "faceplate" & titles.
 *
 *  Author -
 *	Michael John Muuss
 *	Kieth A. Applin
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
#include "common.h"

#include <stdio.h>
#include <math.h>
#include <string.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "./ged.h"
#include "./titles.h"
#include "./mged_solid.h"
#include "./sedit.h"
#include "./mged_dm.h"

#define USE_OLD_MENUS 0

int	state;
char	*state_str[] = {
    "-ZOT-",
    "VIEWING",
    "SOL PICK",
    "SOL EDIT",
    "OBJ PICK",
    "OBJ PATH",
    "OBJ EDIT",
    "VERTPICK",
    "UNKNOWN",
};

extern mat_t perspective_mat;  /* defined in dozoom.c */
extern struct rt_db_internal	es_int;

/*
 *			C R E A T E _ T E X T _ O V E R L A Y
 *
 *  Prepare the numerical display of the currently edited solid/object.
 */
void
create_text_overlay( struct bu_vls *vp )
{
    struct directory	*dp;
    struct bu_vls vls;

    BU_CK_VLS(vp);
    bu_vls_init(&vls);

    /*
     * Set up for character output.  For the best generality, we
     * don't assume that the display can process a CRLF sequence,
     * so each line is written with a separate call to DM_DRAW_STRING_2D().
     */

    /* print solid info at top of screen */
    if( es_edflag >= 0 ) {
	dp = LAST_SOLID(illump);

	bu_vls_strcat( vp, "** SOLID -- " );
	bu_vls_strcat( vp, dp->d_namep );
	bu_vls_strcat( vp, ": ");

	vls_solid( vp, &es_int, bn_mat_identity );

	if(illump->s_fullpath.fp_len > 1) {
	    bu_vls_strcat( vp, "\n** PATH --  ");
	    db_path_to_vls( vp, &illump->s_fullpath );
	    bu_vls_strcat( vp, ": " );

	    /* print the evaluated (path) solid parameters */
	    vls_solid( vp, &es_int, es_mat );
	}
    }

    /* display path info for object editing also */
    if( state == ST_O_EDIT ) {
	bu_vls_strcat( vp, "** PATH --  ");
	db_path_to_vls( vp, &illump->s_fullpath );
	bu_vls_strcat( vp, ": " );

	/* print the evaluated (path) solid parameters */
	if( illump->s_Eflag == 0 ) {
	    mat_t	new_mat;
	    /* NOT an evaluated region */
	    /* object edit option selected */
	    bn_mat_mul(new_mat, modelchanges, es_mat);

	    vls_solid( vp, &es_int, new_mat );
	}
    }

    {
	register char *start;
	register char *p;
	register int imax = 0;
	register int i = 0;
	register int j;
	struct bu_vls vls;

	start = bu_vls_addr( vp );
	/*
	 * Some display managers don't handle TABs properly, so
	 * we replace any TABs with spaces. Also, look for the
	 * maximum line length.
	 */
	for(p = start; *p != '\0'; ++p){
	    if(*p == '\t')
		*p = ' ';
	    else if(*p == '\n'){
		if(i > imax)
		    imax = i;
		i = 0;
	    }else
		++i;
	}

	if(i > imax)
	    imax = i;

	/* Prep string for use with Tcl/Tk */
	++imax;
	i = 0;
	bu_vls_init(&vls);
	for(p = start; *p != '\0'; ++p){
	    if(*p == '\n'){
		for(j = 0; j < imax - i; ++j)
		    bu_vls_putc(&vls, ' ');

		bu_vls_putc(&vls, *p);
		i = 0;
	    }else{
		bu_vls_putc(&vls, *p);
		++i;
	    }
	}

	Tcl_SetVar(interp, "edit_info", bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
	bu_vls_free(&vls);
    }
}

/*
 *			S C R E E N _ V L S
 *
 *  Output a vls string to the display manager,
 *  as a text overlay on the graphics area (ugh).
 *
 * Set up for character output.  For the best generality, we
 * don't assume that the display can process a CRLF sequence,
 * so each line is written with a separate call to DM_DRAW_STRING_2D().
 */
void
screen_vls(
	   int	xbase,
	   int	ybase,
	   struct bu_vls	*vp)
{
    register char	*start;
    register char	*end;
    register int	y;

    BU_CK_VLS( vp );
    y = ybase;

    DM_SET_FGCOLOR(dmp,
		   color_scheme->cs_edit_info[0],
		   color_scheme->cs_edit_info[1],
		   color_scheme->cs_edit_info[2], 1, 1.0);

    start = bu_vls_addr( vp );
    while( *start != '\0' )  {
	if( (end = strchr( start, '\n' )) == NULL )  return;

	*end = '\0';

	DM_DRAW_STRING_2D(dmp, start,
			  GED2PM1(xbase), GED2PM1(y), 0, 0);
	start = end+1;
	y += TEXT0_DY;
    }
}

/*
 *			D O T I T L E S
 *
 * Produce titles, etc, on the screen.
 * NOTE that this routine depends on being called AFTER dozoom();
 */
void
dotitles(struct bu_vls *overlay_vls)
{
    register int    i;
    register int    x, y;			/* for menu computations */
    static vect_t   temp;
    register int    yloc, xloc;
    int		scroll_ybot;
    struct bu_vls   vls;
    typedef char    c_buf[80];
    auto c_buf      cent_x, cent_y, cent_z, size, ang_x, ang_y, ang_z;
    int             ss_line_not_drawn=1; /* true if the second status line has not been drawn */
    fastf_t		tmp_val;

    if(dbip == DBI_NULL)
	return;

    bu_vls_init(&vls);

    /* Set the Tcl variables to the appropriate values. */

    if (illump != SOLID_NULL) {
	struct bu_vls path_lhs, path_rhs;
	register struct directory *dp;

	bu_vls_init(&path_lhs);
	bu_vls_init(&path_rhs);
	for (i = 0; i < ipathpos; i++) {
	    dp = DB_FULL_PATH_GET(&illump->s_fullpath,i);
	    if (dp && dp->d_namep) {
		bu_vls_printf(&path_lhs, "/%s", dp->d_namep);
	    }
	}
	for (; i < illump->s_fullpath.fp_len; i++) {
	    dp = DB_FULL_PATH_GET(&illump->s_fullpath,i);
	    if (dp && dp->d_namep) {
		bu_vls_printf(&path_rhs, "/%s", dp->d_namep);
	    }
	}

	bu_vls_printf(&vls, "%s(path_lhs)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&path_lhs), TCL_GLOBAL_ONLY);
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%s(path_rhs)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&path_rhs), TCL_GLOBAL_ONLY);
	bu_vls_free(&path_rhs);
	bu_vls_free(&path_lhs);
    } else {
	bu_vls_printf(&vls, "%s(path_lhs)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%s(path_rhs)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
    }

    /* take some care here to avoid buffer overrun */
    tmp_val = -view_state->vs_vop->vo_center[MDX]*base2local;
    if( fabs( tmp_val ) < 10e70 ) {
	sprintf(cent_x, "%.3f", tmp_val);
    } else {
	sprintf(cent_x, "%.3g", tmp_val);
    }
    tmp_val = -view_state->vs_vop->vo_center[MDY]*base2local;
    if( fabs( tmp_val ) < 10e70 ) {
	sprintf(cent_y, "%.3f", tmp_val);
    } else {
	sprintf(cent_y, "%.3g", tmp_val);
    }
    tmp_val = -view_state->vs_vop->vo_center[MDZ]*base2local;
    if( fabs( tmp_val ) < 10e70 ) {
	sprintf(cent_z, "%.3f", tmp_val);
    } else {
	sprintf(cent_z, "%.3g", tmp_val);
    }
    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "cent=(%s %s %s)", cent_x, cent_y, cent_z);
    Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_center_name),
	       bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

    tmp_val = view_state->vs_vop->vo_size*base2local;
    if( fabs( tmp_val ) < 10e70 ) {
	sprintf(size, "sz=%.3f", tmp_val);
    } else {
	sprintf(size, "sz=%.3g", tmp_val);
    }
    Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_size_name),
	       size, TCL_GLOBAL_ONLY);

    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "%s(units)", MGED_DISPLAY_VAR);
    Tcl_SetVar(interp, bu_vls_addr(&vls),
	       (char *)bu_units_string(dbip->dbi_local2base), TCL_GLOBAL_ONLY);

    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "az=%3.2f  el=%3.2f  tw=%3.2f", V3ARGS(view_state->vs_vop->vo_aet));
    Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_aet_name),
	       bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

    sprintf(ang_x, "%.2f", view_state->vs_rate_rotate[X]);
    sprintf(ang_y, "%.2f", view_state->vs_rate_rotate[Y]);
    sprintf(ang_z, "%.2f", view_state->vs_rate_rotate[Z]);

    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "ang=(%s %s %s)", ang_x, ang_y, ang_z);
    Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_ang_name),
	       bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

    DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 0);

    /* Label the vertices of the edited solid */
    if(es_edflag >= 0 || (state == ST_O_EDIT && illump->s_Eflag == 0))  {
	mat_t			xform;
	struct rt_point_labels	pl[8+1];
	point_t lines[2*4];	/* up to 4 lines to draw */
	int num_lines=0;

	if( view_state->vs_vop->vo_perspective <= 0)
	    bn_mat_mul( xform, view_state->vs_model2objview, es_mat );
	else{
	    mat_t tmat;

	    bn_mat_mul( tmat, view_state->vs_model2objview, es_mat );
	    bn_mat_mul( xform, perspective_mat, tmat );
	}

	label_edited_solid( &num_lines, lines,  pl, 8+1, xform, &es_int );

	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_geo_label[0],
		       color_scheme->cs_geo_label[1],
		       color_scheme->cs_geo_label[2], 1, 1.0);
	for( i=0 ; i<num_lines ; i++ )
	    DM_DRAW_LINE_2D( dmp,
			     GED2PM1(((int)(lines[i*2][X]*GED_MAX))),
			     GED2PM1(((int)(lines[i*2][Y]*GED_MAX)) * dmp->dm_aspect),
			     GED2PM1(((int)(lines[i*2+1][X]*GED_MAX))),
			     GED2PM1(((int)(lines[i*2+1][Y]*GED_MAX)) * dmp->dm_aspect) );
	for( i=0; i<8+1; i++ )  {
	    if( pl[i].str[0] == '\0' )  break;
	    DM_DRAW_STRING_2D( dmp, pl[i].str,
			       GED2PM1(((int)(pl[i].pt[X]*GED_MAX))+15),
			       GED2PM1(((int)(pl[i].pt[Y]*GED_MAX))+15), 0, 1 );
	}
    }

    if(mged_variables->mv_faceplate){
	/* Line across the bottom, above two bottom status lines */
	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_other_line[0],
		       color_scheme->cs_other_line[1],
		       color_scheme->cs_other_line[2], 1, 1.0);
	DM_DRAW_LINE_2D( dmp,
			 GED2PM1(XMIN), GED2PM1(TITLE_YBASE-TEXT1_DY),
			 GED2PM1(XMAX), GED2PM1(TITLE_YBASE-TEXT1_DY) );

	if(mged_variables->mv_orig_gui){
	    /* Enclose window in decorative box.  Mostly for alignment. */
	    DM_DRAW_LINE_2D( dmp,
			     GED2PM1(XMIN), GED2PM1(YMIN),
			     GED2PM1(XMAX), GED2PM1(YMIN) );
	    DM_DRAW_LINE_2D( dmp,
			     GED2PM1(XMAX), GED2PM1(YMIN),
			     GED2PM1(XMAX), GED2PM1(YMAX) );
	    DM_DRAW_LINE_2D( dmp,
			     GED2PM1(XMAX), GED2PM1(YMAX),
			     GED2PM1(XMIN), GED2PM1(YMAX) );
	    DM_DRAW_LINE_2D( dmp,
			     GED2PM1(XMIN), GED2PM1(YMAX),
			     GED2PM1(XMIN), GED2PM1(YMIN) );

	    /* Display scroll bars */
	    scroll_ybot = scroll_display( SCROLLY );
	    y = MENUY;
	    x = MENUX;

	    /* Display state and local unit in upper left corner, boxed */
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_state_text1[0],
			   color_scheme->cs_state_text1[1],
			   color_scheme->cs_state_text1[2], 1, 1.0);
	    DM_DRAW_STRING_2D(dmp, state_str[state],
			      GED2PM1(MENUX), GED2PM1(MENUY - MENU_DY), 1, 0 );
	}else{
	    scroll_ybot = SCROLLY;
	    x = XMIN + 20;
	    y = YMAX+TEXT0_DY;
	}

	/*
	 * Print information about object illuminated
	 */
	if( illump != SOLID_NULL &&
	    (state==ST_O_PATH || state==ST_O_PICK || state==ST_S_PICK) )  {
	    for( i=0; i < illump->s_fullpath.fp_len; i++ )  {
		if( i == ipathpos  &&  state == ST_O_PATH )  {
		    DM_SET_FGCOLOR(dmp,
				   color_scheme->cs_state_text1[0],
				   color_scheme->cs_state_text1[1],
				   color_scheme->cs_state_text1[2], 1, 1.0);
		    DM_DRAW_STRING_2D( dmp, "[MATRIX]",
				       GED2PM1(x), GED2PM1(y), 0, 0 );
		    y += MENU_DY;
		}
		DM_SET_FGCOLOR(dmp,
			       color_scheme->cs_state_text2[0],
			       color_scheme->cs_state_text2[1],
			       color_scheme->cs_state_text2[2], 1, 1.0);
		DM_DRAW_STRING_2D( dmp,
				   DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep,
				   GED2PM1(x), GED2PM1(y), 0, 0 );
		y += MENU_DY;
	    }
	}

	if(mged_variables->mv_orig_gui){
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_other_line[0],
			   color_scheme->cs_other_line[1],
			   color_scheme->cs_other_line[2], 1, 1.0);
	    DM_DRAW_LINE_2D(dmp,
			    GED2PM1(MENUXLIM), GED2PM1(y),
			    GED2PM1(MENUXLIM), GED2PM1(YMAX));	/* vert. */
	    /*
	     * The top of the menu (if any) begins at the Y value specified.
	     */
	    mmenu_display( y );

	    /* print parameter locations on screen */
	    if( state == ST_O_EDIT && illump->s_Eflag ) {
		/* region is a processed region */
		MAT4X3PNT(temp, view_state->vs_model2objview, es_keypoint);
		xloc = (int)(temp[X]*GED_MAX);
		yloc = (int)(temp[Y]*GED_MAX);
		DM_SET_FGCOLOR(dmp,
			       color_scheme->cs_edit_info[0],
			       color_scheme->cs_edit_info[1],
			       color_scheme->cs_edit_info[2], 1, 1.0);
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc+TEXT0_DY),
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc-TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc-TEXT0_DY),
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc+TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc+TEXT0_DY),
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc+TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc-TEXT0_DY),
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc-TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc+TEXT0_DY),
				GED2PM1(xloc+TEXT0_DY), GED2PM1(yloc-TEXT0_DY));
		DM_DRAW_LINE_2D(dmp,
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc+TEXT0_DY),
				GED2PM1(xloc-TEXT0_DY), GED2PM1(yloc-TEXT0_DY));
	    }
	}

	/*
	 * Prepare the numerical display of the currently edited solid/object.
	 */
	/*	create_text_overlay( &vls ); */
	if(mged_variables->mv_orig_gui){
	    screen_vls( SOLID_XBASE, scroll_ybot+TEXT0_DY, overlay_vls );
	}else{
	    screen_vls( x, y, overlay_vls );
	}

	/*
	 * General status information on first status line
	 */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls,
		      " cent=(%s, %s, %s), %s %s, ", cent_x, cent_y, cent_z,
		      size, bu_units_string(dbip->dbi_local2base));
	bu_vls_printf(&vls, "az=%3.2f el=%3.2f tw=%3.2f ang=(%s, %s, %s)", V3ARGS(view_state->vs_vop->vo_aet),
		      ang_x, ang_y, ang_z);
	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_status_text1[0],
		       color_scheme->cs_status_text1[1],
		       color_scheme->cs_status_text1[2], 1, 1.0);
	DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
			   GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE), 1, 0 );
    } /* if faceplate !0 */

    /*
     * Second status line
     */

    /* Priorities for what to display:
     *	1.  adc info
     *	2.  keypoint
     *	3.  illuminated path
     *
     * This way the adc info will be displayed during editing
     */

    if( adc_state->adc_draw ) {
	fastf_t f;

	f = view_state->vs_vop->vo_scale * base2local;
	/* Angle/Distance cursor */
	bu_vls_trunc(&vls, 0);
	bu_vls_printf( &vls,
		       " curs:  a1=%.1f,  a2=%.1f,  dst=%.3f,  cent=(%.3f, %.3f),  delta=(%.3f, %.3f)",
		       adc_state->adc_a1, adc_state->adc_a2,
		       adc_state->adc_dst * f,
		       adc_state->adc_pos_grid[X] * f, adc_state->adc_pos_grid[Y] * f,
		       adc_state->adc_pos_view[X] * f, adc_state->adc_pos_view[Y] * f);
	if(mged_variables->mv_faceplate){
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_status_text2[0],
			   color_scheme->cs_status_text2[1],
			   color_scheme->cs_status_text2[2], 1, 1.0);
	    DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
			       GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );
	}
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_adc_name),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
	ss_line_not_drawn = 0;
    }else{
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_adc_name), "", TCL_GLOBAL_ONLY);
    }

    if( state == ST_S_EDIT || state == ST_O_EDIT )  {
	struct bu_vls kp_vls;

	bu_vls_init(&kp_vls);
	bu_vls_printf( &kp_vls,
		       " Keypoint: %s %s: (%g, %g, %g)",
		       rt_functab[es_int.idb_type].ft_name+3,	/* Skip ID_ */
		       es_keytag,
		       es_keypoint[X] * base2local,
		       es_keypoint[Y] * base2local,
		       es_keypoint[Z] * base2local);
	if(mged_variables->mv_faceplate && ss_line_not_drawn){
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_status_text2[0],
			   color_scheme->cs_status_text2[1],
			   color_scheme->cs_status_text2[2], 1, 1.0);
	    DM_DRAW_STRING_2D( dmp, bu_vls_addr(&kp_vls),
			       GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );
	    ss_line_not_drawn = 0;
	}

	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%s(keypoint)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&kp_vls), TCL_GLOBAL_ONLY);

	bu_vls_free(&kp_vls);
    }else{
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%s(keypoint)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
    }

    if( illump != SOLID_NULL )  {
	if(mged_variables->mv_faceplate && ss_line_not_drawn){
	    bu_vls_trunc(&vls, 0);

	    /* Illuminated path */
	    bu_vls_strcat(&vls, " Path: ");
	    for( i=0; i < illump->s_fullpath.fp_len; i++ )  {
		if( i == ipathpos  &&
		    (state == ST_O_PATH || state == ST_O_EDIT) )
		    bu_vls_strcat( &vls, "/__MATRIX__" );
		bu_vls_printf(&vls, "/%s",
			      DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep );
	    }
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_status_text2[0],
			   color_scheme->cs_status_text2[1],
			   color_scheme->cs_status_text2[2], 1, 1.0);
	    DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
			       GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );

	    ss_line_not_drawn = 0;
	}
    }

    bu_vls_trunc(&vls, 0);
    bu_vls_printf(&vls, "%.2f fps", 1/frametime );
    if(mged_variables->mv_faceplate && ss_line_not_drawn){
	DM_SET_FGCOLOR(dmp,
		       color_scheme->cs_status_text2[0],
		       color_scheme->cs_status_text2[1],
		       color_scheme->cs_status_text2[2], 1, 1.0);
	DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
			   GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );
    }
    Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_fps_name),
	       bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

    bu_vls_free(&vls);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a33 6
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.11 2007/01/20 14:36:58 brlcad Exp $ (BRL)";
#endif

#define USE_OLD_MENUS 0

a37 1
#ifdef HAVE_STRING_H
a38 3
#else
#include <strings.h>
#endif
d51 2
@


14.12.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d34 6
d44 1
d46 3
a60 2
#define USE_OLD_MENUS 0

@


14.11
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.10 2006/05/15 20:19:17 brlcad Exp $ (BRL)";
@


14.10
log
@ugh, removed horrible usage of vls strings for things that can just be string constants.  also takes care of a memory leak as the vls was never released.  thanks to jim monte for noticing the problem.
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.9 2006/02/14 20:23:07 brlcad Exp $ (BRL)";
@


14.9
log
@mild sanity check, even if the directory pointer is valid, make sure the name is too before printfing
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.8 2006/02/04 16:08:37 brlcad Exp $ (BRL)";
d180 1
a180 2
	Tcl_SetVar(interp, bu_vls_addr(&edit_info_vls),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
@


14.8
log
@prevent crashing if we're unable to print the title of an illuminated path.  this fixes sf bug 1218812 reported by clock3.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.7 2006/02/04 15:38:55 brlcad Exp $ (BRL)";
d262 1
a262 1
	    if (dp) {
d268 1
a268 1
	    if (dp) {
@


14.7
log
@ws indent
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.6 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d256 1
d260 12
a271 4
	for (i = 0; i < ipathpos; i++)
	    bu_vls_printf(&path_lhs, "/%s", DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep);
	for (; i < illump->s_fullpath.fp_len; i++)
	    bu_vls_printf(&path_rhs, "/%s", DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep);
@


14.6
log
@update copyright to 2006
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.5 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
d64 9
a72 9
	"-ZOT-",
	"VIEWING",
	"SOL PICK",
	"SOL EDIT",
	"OBJ PICK",
	"OBJ PATH",
	"OBJ EDIT",
	"VERTPICK",
	"UNKNOWN",
d86 55
a140 1
	struct directory	*dp;
d143 1
a143 3
	BU_CK_VLS(vp);
	bu_vls_init(&vls);

d145 3
a147 3
	 * Set up for character output.  For the best generality, we
	 * don't assume that the display can process a CRLF sequence,
	 * so each line is written with a separate call to DM_DRAW_STRING_2D().
d149 1
a149 53

	/* print solid info at top of screen */
	if( es_edflag >= 0 ) {
		dp = LAST_SOLID(illump);

		bu_vls_strcat( vp, "** SOLID -- " );
		bu_vls_strcat( vp, dp->d_namep );
		bu_vls_strcat( vp, ": ");

		vls_solid( vp, &es_int, bn_mat_identity );

		if(illump->s_fullpath.fp_len > 1) {
			bu_vls_strcat( vp, "\n** PATH --  ");
			db_path_to_vls( vp, &illump->s_fullpath );
			bu_vls_strcat( vp, ": " );

			/* print the evaluated (path) solid parameters */
			vls_solid( vp, &es_int, es_mat );
		}
	}

	/* display path info for object editing also */
	if( state == ST_O_EDIT ) {
		bu_vls_strcat( vp, "** PATH --  ");
		db_path_to_vls( vp, &illump->s_fullpath );
		bu_vls_strcat( vp, ": " );

		/* print the evaluated (path) solid parameters */
		if( illump->s_Eflag == 0 ) {
			mat_t	new_mat;
			/* NOT an evaluated region */
			/* object edit option selected */
			bn_mat_mul(new_mat, modelchanges, es_mat);

			vls_solid( vp, &es_int, new_mat );
		}
	}

	{
	  register char *start;
	  register char *p;
	  register int imax = 0;
	  register int i = 0;
	  register int j;
	  struct bu_vls vls;

	  start = bu_vls_addr( vp );
	  /*
	   * Some display managers don't handle TABs properly, so
	   * we replace any TABs with spaces. Also, look for the
	   * maximum line length.
	   */
	  for(p = start; *p != '\0'; ++p){
d151 1
a151 1
	      *p = ' ';
d153 3
a155 3
	      if(i > imax)
		imax = i;
	      i = 0;
d157 2
a158 2
	      ++i;
	  }
d160 1
a160 1
	  if(i > imax)
d163 5
a167 5
	  /* Prep string for use with Tcl/Tk */
	  ++imax;
	  i = 0;
	  bu_vls_init(&vls);
	  for(p = start; *p != '\0'; ++p){
d169 2
a170 2
	      for(j = 0; j < imax - i; ++j)
		bu_vls_putc(&vls, ' ');
d172 2
a173 2
	      bu_vls_putc(&vls, *p);
	      i = 0;
d175 2
a176 2
	      bu_vls_putc(&vls, *p);
	      ++i;
d178 1
a178 1
	  }
d180 4
a183 4
	  Tcl_SetVar(interp, bu_vls_addr(&edit_info_vls),
		     bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
	  bu_vls_free(&vls);
	}
d198 3
a200 3
	int	xbase,
	int	ybase,
	struct bu_vls	*vp)
d202 23
a224 23
  register char	*start;
  register char	*end;
  register int	y;

  BU_CK_VLS( vp );
  y = ybase;

  DM_SET_FGCOLOR(dmp,
		 color_scheme->cs_edit_info[0],
		 color_scheme->cs_edit_info[1],
		 color_scheme->cs_edit_info[2], 1, 1.0);

  start = bu_vls_addr( vp );
  while( *start != '\0' )  {
    if( (end = strchr( start, '\n' )) == NULL )  return;

    *end = '\0';

    DM_DRAW_STRING_2D(dmp, start,
		      GED2PM1(xbase), GED2PM1(y), 0, 0);
    start = end+1;
    y += TEXT0_DY;
  }
d236 24
a259 24
	register int    i;
	register int    x, y;			/* for menu computations */
	static vect_t   temp;
	register int    yloc, xloc;
	int		scroll_ybot;
	struct bu_vls   vls;
	typedef char    c_buf[80];
	auto c_buf      cent_x, cent_y, cent_z, size, ang_x, ang_y, ang_z;
	int             ss_line_not_drawn=1; /* true if the second status line has not been drawn */
	fastf_t		tmp_val;

	if(dbip == DBI_NULL)
	  return;

	bu_vls_init(&vls);

	/* Set the Tcl variables to the appropriate values. */

	if (illump != SOLID_NULL) {
	  struct bu_vls path_lhs, path_rhs;

	  bu_vls_init(&path_lhs);
	  bu_vls_init(&path_rhs);
	  for (i = 0; i < ipathpos; i++)
d261 1
a261 1
	  for (; i < illump->s_fullpath.fp_len; i++)
d264 10
a273 34
	  bu_vls_printf(&vls, "%s(path_lhs)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&path_lhs), TCL_GLOBAL_ONLY);
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf(&vls, "%s(path_rhs)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&path_rhs), TCL_GLOBAL_ONLY);
	  bu_vls_free(&path_rhs);
	  bu_vls_free(&path_lhs);
	} else {
	  bu_vls_printf(&vls, "%s(path_lhs)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf(&vls, "%s(path_rhs)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
	}

	/* take some care here to avoid buffer overrun */
	tmp_val = -view_state->vs_vop->vo_center[MDX]*base2local;
	if( fabs( tmp_val ) < 10e70 ) {
		sprintf(cent_x, "%.3f", tmp_val);
	} else {
		sprintf(cent_x, "%.3g", tmp_val);
	}
	tmp_val = -view_state->vs_vop->vo_center[MDY]*base2local;
	if( fabs( tmp_val ) < 10e70 ) {
		sprintf(cent_y, "%.3f", tmp_val);
	} else {
		sprintf(cent_y, "%.3g", tmp_val);
	}
	tmp_val = -view_state->vs_vop->vo_center[MDZ]*base2local;
	if( fabs( tmp_val ) < 10e70 ) {
		sprintf(cent_z, "%.3f", tmp_val);
	} else {
		sprintf(cent_z, "%.3g", tmp_val);
	}
d275 69
a343 3
	bu_vls_printf(&vls, "cent=(%s %s %s)", cent_x, cent_y, cent_z);
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_center_name),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
d345 2
a346 5
	tmp_val = view_state->vs_vop->vo_size*base2local;
	if( fabs( tmp_val ) < 10e70 ) {
		sprintf(size, "sz=%.3f", tmp_val);
	} else {
		sprintf(size, "sz=%.3g", tmp_val);
a347 2
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_size_name),
		    size, TCL_GLOBAL_ONLY);
d349 1
a349 4
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%s(units)", MGED_DISPLAY_VAR);
	Tcl_SetVar(interp, bu_vls_addr(&vls),
		   (char *)bu_units_string(dbip->dbi_local2base), TCL_GLOBAL_ONLY);
d351 15
a365 50
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "az=%3.2f  el=%3.2f  tw=%3.2f", V3ARGS(view_state->vs_vop->vo_aet));
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_aet_name),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

	sprintf(ang_x, "%.2f", view_state->vs_rate_rotate[X]);
	sprintf(ang_y, "%.2f", view_state->vs_rate_rotate[Y]);
	sprintf(ang_z, "%.2f", view_state->vs_rate_rotate[Z]);

	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "ang=(%s %s %s)", ang_x, ang_y, ang_z);
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_ang_name),
		   bu_vls_addr(&vls), TCL_GLOBAL_ONLY);

	DM_SET_LINE_ATTR(dmp, mged_variables->mv_linewidth, 0);

	/* Label the vertices of the edited solid */
	if(es_edflag >= 0 || (state == ST_O_EDIT && illump->s_Eflag == 0))  {
		mat_t			xform;
		struct rt_point_labels	pl[8+1];
		point_t lines[2*4];	/* up to 4 lines to draw */
		int num_lines=0;

		if( view_state->vs_vop->vo_perspective <= 0)
		  bn_mat_mul( xform, view_state->vs_model2objview, es_mat );
		else{
		  mat_t tmat;

		  bn_mat_mul( tmat, view_state->vs_model2objview, es_mat );
		  bn_mat_mul( xform, perspective_mat, tmat );
		}

		label_edited_solid( &num_lines, lines,  pl, 8+1, xform, &es_int );

		DM_SET_FGCOLOR(dmp,
			       color_scheme->cs_geo_label[0],
			       color_scheme->cs_geo_label[1],
			       color_scheme->cs_geo_label[2], 1, 1.0);
		for( i=0 ; i<num_lines ; i++ )
			DM_DRAW_LINE_2D( dmp,
			   GED2PM1(((int)(lines[i*2][X]*GED_MAX))),
			   GED2PM1(((int)(lines[i*2][Y]*GED_MAX)) * dmp->dm_aspect),
			   GED2PM1(((int)(lines[i*2+1][X]*GED_MAX))),
			   GED2PM1(((int)(lines[i*2+1][Y]*GED_MAX)) * dmp->dm_aspect) );
		for( i=0; i<8+1; i++ )  {
			if( pl[i].str[0] == '\0' )  break;
			DM_DRAW_STRING_2D( dmp, pl[i].str,
					   GED2PM1(((int)(pl[i].pt[X]*GED_MAX))+15),
					   GED2PM1(((int)(pl[i].pt[Y]*GED_MAX))+15), 0, 1 );
		}
d367 1
d369 1
a369 1
if(mged_variables->mv_faceplate){
d380 26
a405 26
	  /* Enclose window in decorative box.  Mostly for alignment. */
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(XMIN), GED2PM1(YMIN),
			   GED2PM1(XMAX), GED2PM1(YMIN) );
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(XMAX), GED2PM1(YMIN),
			   GED2PM1(XMAX), GED2PM1(YMAX) );
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(XMAX), GED2PM1(YMAX),
			   GED2PM1(XMIN), GED2PM1(YMAX) );
	  DM_DRAW_LINE_2D( dmp,
			   GED2PM1(XMIN), GED2PM1(YMAX),
			   GED2PM1(XMIN), GED2PM1(YMIN) );

	  /* Display scroll bars */
	  scroll_ybot = scroll_display( SCROLLY );
	  y = MENUY;
	  x = MENUX;

	  /* Display state and local unit in upper left corner, boxed */
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_state_text1[0],
			 color_scheme->cs_state_text1[1],
			 color_scheme->cs_state_text1[2], 1, 1.0);
	  DM_DRAW_STRING_2D(dmp, state_str[state],
			    GED2PM1(MENUX), GED2PM1(MENUY - MENU_DY), 1, 0 );
d407 3
a409 3
	  scroll_ybot = SCROLLY;
	  x = XMIN + 20;
	  y = YMAX+TEXT0_DY;
d417 18
a434 9
	  for( i=0; i < illump->s_fullpath.fp_len; i++ )  {
	    if( i == ipathpos  &&  state == ST_O_PATH )  {
	      DM_SET_FGCOLOR(dmp,
			     color_scheme->cs_state_text1[0],
			     color_scheme->cs_state_text1[1],
			     color_scheme->cs_state_text1[2], 1, 1.0);
	      DM_DRAW_STRING_2D( dmp, "[MATRIX]",
				 GED2PM1(x), GED2PM1(y), 0, 0 );
	      y += MENU_DY;
a435 9
	    DM_SET_FGCOLOR(dmp,
			   color_scheme->cs_state_text2[0],
			   color_scheme->cs_state_text2[1],
			   color_scheme->cs_state_text2[2], 1, 1.0);
	    DM_DRAW_STRING_2D( dmp,
			DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep,
			GED2PM1(x), GED2PM1(y), 0, 0 );
	    y += MENU_DY;
	  }
d439 11
a449 11
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_other_line[0],
			 color_scheme->cs_other_line[1],
			 color_scheme->cs_other_line[2], 1, 1.0);
	  DM_DRAW_LINE_2D(dmp,
			  GED2PM1(MENUXLIM), GED2PM1(y),
			  GED2PM1(MENUXLIM), GED2PM1(YMAX));	/* vert. */
	  /*
	   * The top of the menu (if any) begins at the Y value specified.
	   */
	  mmenu_display( y );
d451 2
a452 2
	  /* print parameter locations on screen */
	  if( state == ST_O_EDIT && illump->s_Eflag ) {
d479 1
a479 1
	      }
d487 1
a487 1
	  screen_vls( SOLID_XBASE, scroll_ybot+TEXT0_DY, overlay_vls );
d489 1
a489 1
	  screen_vls( x, y, overlay_vls );
d507 1
a507 1
} /* if faceplate !0 */
d509 11
a519 3
	/*
	 * Second status line
	 */
d521 2
a522 7
	/* Priorities for what to display:
	 *	1.  adc info
	 *	2.  keypoint
	 *	3.  illuminated path
	 *
	 * This way the adc info will be displayed during editing
	 */
d524 16
a539 25
	if( adc_state->adc_draw ) {
	  fastf_t f;

	  f = view_state->vs_vop->vo_scale * base2local;
	  /* Angle/Distance cursor */
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf( &vls,
			 " curs:  a1=%.1f,  a2=%.1f,  dst=%.3f,  cent=(%.3f, %.3f),  delta=(%.3f, %.3f)",
			 adc_state->adc_a1, adc_state->adc_a2,
			 adc_state->adc_dst * f,
			 adc_state->adc_pos_grid[X] * f, adc_state->adc_pos_grid[Y] * f,
			 adc_state->adc_pos_view[X] * f, adc_state->adc_pos_view[Y] * f);
		if(mged_variables->mv_faceplate){
		  DM_SET_FGCOLOR(dmp,
				 color_scheme->cs_status_text2[0],
				 color_scheme->cs_status_text2[1],
				 color_scheme->cs_status_text2[2], 1, 1.0);
		  DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
				     GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );
		}
		Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_adc_name),
			    bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
		ss_line_not_drawn = 0;
	}else{
	  Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_adc_name), "", TCL_GLOBAL_ONLY);
d541 19
a559 13

	if( state == ST_S_EDIT || state == ST_O_EDIT )  {
	  struct bu_vls kp_vls;

	  bu_vls_init(&kp_vls);
	  bu_vls_printf( &kp_vls,
			 " Keypoint: %s %s: (%g, %g, %g)",
			 rt_functab[es_int.idb_type].ft_name+3,	/* Skip ID_ */
			 es_keytag,
			 es_keypoint[X] * base2local,
			 es_keypoint[Y] * base2local,
			 es_keypoint[Z] * base2local);
	  if(mged_variables->mv_faceplate && ss_line_not_drawn){
d567 1
a567 1
	  }
d569 3
a571 3
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf(&vls, "%s(keypoint)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), bu_vls_addr(&kp_vls), TCL_GLOBAL_ONLY);
d573 6
a578 6
	  bu_vls_free(&kp_vls);
	}else{
	  bu_vls_trunc(&vls, 0);
	  bu_vls_printf(&vls, "%s(keypoint)", MGED_DISPLAY_VAR);
	  Tcl_SetVar(interp, bu_vls_addr(&vls), "", TCL_GLOBAL_ONLY);
	}
d580 2
a581 2
	if( illump != SOLID_NULL )  {
	  if(mged_variables->mv_faceplate && ss_line_not_drawn){
d587 5
a591 5
	      if( i == ipathpos  &&
		  (state == ST_O_PATH || state == ST_O_EDIT) )
		bu_vls_strcat( &vls, "/__MATRIX__" );
	      bu_vls_printf(&vls, "/%s",
	    		DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep );
a600 1
	  }
d602 1
d604 12
a615 12
	bu_vls_trunc(&vls, 0);
	bu_vls_printf(&vls, "%.2f fps", 1/frametime );
	if(mged_variables->mv_faceplate && ss_line_not_drawn){
	  DM_SET_FGCOLOR(dmp,
			 color_scheme->cs_status_text2[0],
			 color_scheme->cs_status_text2[1],
			 color_scheme->cs_status_text2[2], 1, 1.0);
	  DM_DRAW_STRING_2D( dmp, bu_vls_addr(&vls),
			     GED2PM1(TITLE_XBASE), GED2PM1(TITLE_YBASE + TEXT1_DY), 1, 0 );
	}
	Tcl_SetVar(interp, bu_vls_addr(&curr_dm_list->dml_fps_name),
		    bu_vls_addr(&vls), TCL_GLOBAL_ONLY);
d617 1
a617 1
	bu_vls_free(&vls);
@


14.5
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.4 2005/09/16 18:51:53 brlcad Exp $ (BRL)";
@


14.4
log
@rework tkwin into cmd.c and profide the DM_X and DM_OGL defines to the build.  probably fixes a bug or two of some sort on the display manager.  also migrate the tolerance vars together along with other ws and header cleanup
@
text
@d29 1
a29 1
 *  
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
d251 1
a251 1
	
d395 1
a395 1
	  scroll_ybot = scroll_display( SCROLLY ); 
@


14.3
log
@update copyright to 2005
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/titles.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
a42 2


a59 1
#include "./mgedtcl.h"
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d43 2
d62 1
d254 1
a254 1

d398 1
a398 1
	  scroll_ybot = scroll_display( SCROLLY );
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/titles.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			T I T L E S . C
a33 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/titles.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/titles.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d607 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/titles.c,v 1.2 2004/06/08 22:04:29 morrison Exp $ (BRL)";
d32 1
a32 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 1
a26 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/titles.c,v 11.55 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a44 1
#include "externs.h"
@

