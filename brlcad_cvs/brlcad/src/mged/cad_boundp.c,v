head	14.18;
access;
symbols
	rel-7-10-4:14.12.2.1
	STABLE:14.12.0.2
	stable-branch:14.3
	rel-7-10-2:14.12
	rel-7-10-0:14.10
	rel-7-8-4:14.6
	rel-7-8-2:14.6
	rel-7-8-0:14.6
	trimnurbs-branch:14.6.0.2
	help:14.6
	temp_tag:14.4
	bobWinPort-20051223-freeze:14.3
	postmerge-20051223-bobWinPort:14.4
	premerge-20051223-bobWinPort:14.4
	rel-7-6-6:14.4
	rel-7-6-4:14.4
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.18
date	2007.12.22.19.38.39;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.12.02.22.05.05;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.12.02.21.51.10;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.11.21.20.49.09;	author erikgreenwald;	state Exp;
branches;
next	14.14;

14.14
date	2007.11.21.19.49.11;	author erikgreenwald;	state Exp;
branches;
next	14.13;

14.13
date	2007.09.15.16.23.16;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.07.26.01.13.58;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2007.04.18.02.55.14;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.02.20.08.19.49;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.27.01.41.43;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2007.01.23.01.13.41;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.23.06.20.27;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.05;	author brlcad;	state Exp;
branches
	14.3.6.1;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.26;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.21;	author morrison;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2007.09.28.14.04.33;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.18
log
@get rid of Mess, just did silly print-header-to-stderr+print-body-to-stdout that was mostly used for debugging.  just fprintf the output for now (consider bu_log later).
@
text
@/*                    C A D _ B O U N D P . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file cad_boundp.c
 *
 *	cad_boundp -- bounding polygon of two-dimensional view
 *
 *  Author -
 *	D A Gwyn
 *
 * NOTES FOR MAINTAINER:
 *
 *	This program is somewhat slow when operating on large input
 *	sets.  The following ideas should improve the speed, possibly
 *	at the expense of maximum data set size:
 *
 *	(1)  Merge the Chop() and Build() phases.  Since Chop() examines
 *	segment endpoints anyway, it is in a good position to build the
 *	linked lists used by Search().
 *
 *	(2)  Sort the input endpoints into a double tree on X and Y.
 *	This should cut Chop() from order N ^ 2 to N * log( N ).
 */

#include "common.h"

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "machine.h"
#include "bu.h"

#include "./vld_std.h"


typedef struct
	{
	/* The following are float instead of double, to save space: */
	float		x;		/* X coordinate */
	float		y;		/* Y coordinate */
}	coords; 		/* view-coordinates of point */

typedef struct segment
{
	struct segment	*links; 	/* segment list thread */
	coords		sxy;		/* (X,Y) coordinates of start */
	coords		exy;		/* (X,Y) coordinates of end */
}	segment;		/* entry in list of segments */

struct queue;				/* (to clear from name space) */

typedef struct point
{
	struct point	*linkp; 	/* point list thread */
	struct queue	*firstq;	/* NULL once output */
	coords		xy;		/* (X,Y) coordinates of point */
}	point;			/* entry in list of points */

typedef struct queue
{
	struct queue	*nextq; 	/* endpoint list thread */
	point		*endpoint;	/* -> endpt of ray from point */
}	queue;			/* entry in list of endpoints */

static bool_t	Build(void), Chop(void), EndPoint(register coords *p, register segment *segp), GetArgs(int argc, char **argv), Input(register segment *inp),
Near(register coords *ap, register coords *bp), Search(void), Split(coords *p, register segment *oldp, register segment *listh), Usage(void);
static coords	*Intersect(register segment *a, register segment *b);
static point	*LookUp(register coords *coop), *NewPoint(register coords *coop), *PutList(register coords *coop);
static pointer	Alloc(unsigned int size);
static queue	*Enqueue(register point *addp, register point *startp);
static void	Output(register coords *coop), Toss(register pointer ptr);

static bool_t	initial = true; 	/* false after first Output */
static bool_t	vflag = false;		/* set if "-v" option found */
static double	tolerance = 0.0;	/* point matching slop */
static double	tolsq = 0.0;		/* `tolerance' ^ 2 */
static point	*headp = NULL;		/* head of list of points */
static segment	seghead = {
	&seghead };	/* segment list head */


static bool_t
Usage(void) 				/* print usage message */
{
	return
	    fprintf(stderr, "usage: cad_boundp[ -i input][ -o output][ -t tolerance][ -v]" );
}


int
main(int argc, char **argv)			/* "cad_boundp" entry point */
				/* argument count */
				/* argument strings */
{
	if ( !GetArgs( argc, argv ) )	/* process command arguments */
		return 1;

	if ( !Chop() )			/* input; chop into segments */
		return 2;

	if ( !Build() ) 		/* build linked lists */
		return 3;

	if ( !Search() )		/* output bounding polygon */
		return 4;

	return 0;			/* success! */
}


static bool_t
GetArgs(int argc, char **argv)			/* process command arguments */
				/* argument count */
				/* argument strings */
{
	static bool_t	iflag = false;	/* set if "-i" option found */
	static bool_t	oflag = false;	/* set if "-o" option found */
	static bool_t	tflag = false;	/* set if "-t" option found */
	int		c;		/* option letter */

#ifdef	DEBUG
	fprintf(stderr, "\n\t\tGetArgs\n" );
#endif
	while ( (c = bu_getopt( argc, argv, "i:o:t:v" )) != EOF )
		switch ( c )
		{
		case 'i':
			if ( iflag )
				return
				    fprintf(stderr, "too many -i options" );
			iflag = true;

			if ( strcmp( bu_optarg, "-" ) != 0
			    && freopen( bu_optarg, "r", stdin ) == NULL
			    )
				return
				    fprintf(stderr, "can't open \"%s\"", bu_optarg );
			break;

		case 'o':
			if ( oflag )
				return
				    fprintf(stderr, "too many -o options" );
			oflag = true;

			if ( strcmp( bu_optarg, "-" ) != 0
			    && freopen( bu_optarg, "w", stdout ) == NULL
			    )
				return
				    fprintf(stderr, "can't create \"%s\"", bu_optarg );
			break;

		case 't':
			if ( tflag )
				return
				    fprintf(stderr, "too many -t options" );
			tflag = true;

			if ( sscanf( bu_optarg, "%le", &tolerance ) != 1 )
				return
				    fprintf(stderr, "bad tolerance: %s", bu_optarg );
			tolsq = tolerance * tolerance;
			break;

		case 'v':
			vflag = true;
			break;

		case '?':
			return Usage(); /* print usage message */
		}

	return true;
}


/*
	The following phase is required to chop up line segments that
	intersect; this guarantees that all polygon vertices will be
	found at segment endpoints.  Unfortunately, this is an N^2
	process.  It is also hard to do right; thus the elaborateness.
*/

static bool_t
Chop(void)					/* chop vectors into segments */
{
	segment *inp;			/* -> input whole segment */

#ifdef	DEBUG
	fprintf(stderr, "\n\t\tChop\n" );
#endif
	/* Although we try to Alloc() when no input remains, it is more
	   efficient than repeatedly copying the input into *inp.     */
	while ( (inp = (segment *)Alloc( (unsigned)sizeof(segment) )) != NULL
	    && Input( inp )
	    ) {
		register segment	*segp;	/* segment list entry */
		segment 		piecehead;
		/* list of inp pieces */
		register segment	*pp;	/* -> pieces of `inp' */

		/* Reverse the segment if necessary to get endpoints
		   in left-to-right order; speeds up range check. */

		if ( inp->sxy.x > inp->exy.x )
		{
			coords	temp;		/* store for swapping */

#ifdef	DEBUG
			fprintf(stderr, "endpoints swapped" );
#endif
			temp = inp->sxy;
			inp->sxy = inp->exy;
			inp->exy = temp;
		}

		/* Split input and segment list entries into pieces. */

		inp->links = &piecehead;
		piecehead.links = inp;	/* initially, one piece */

		/* Note:  Although the split-off pieces of `segp' are
		   linked in front of `segp', that's okay since they
		   cannot intersect `inp' again!		      */
		for ( segp = seghead.links; segp != &seghead;
		    segp = segp->links
		    )
			/* Similarly, once a piece of `inp' intersects
			   `segp', we can stop looking at the pieces. */
			for ( pp = piecehead.links; pp != &piecehead;
			    pp = pp->links
			    )	{
				register coords *i;	/* intersectn */

				/* Be careful; `i' -> static storage
				   internal to Intersect().	      */
				i = Intersect( pp, segp );
				if ( i != NULL )
				{
					if ( ( !EndPoint( i, pp  )
					    && !Split( i, pp, &piecehead ) )
					    || ( !EndPoint( i, segp )
					    && !Split( i, segp, &seghead ) )
					    )	/* out of memory */
						return false;

					break;	/* next `segp' */
				}
			}
#ifdef	DEBUG
		fprintf(stderr, "new input pieces:" );
		for ( pp = piecehead.links; pp != &piecehead;
		    pp = pp->links
		    )
			fprintf(stderr, "\t(%g,%g)->(%g,%g)",
			    (double)pp->sxy.x,
			    (double)pp->sxy.y,
			    (double)pp->exy.x,
			    (double)pp->exy.y
			    );
		fprintf(stderr, "other segments:" );
		for ( segp = seghead.links; segp != &seghead;
		    segp = segp->links
		    )
			fprintf(stderr, "\t(%g,%g)->(%g,%g)",
			    (double)segp->sxy.x,
			    (double)segp->sxy.y,
			    (double)segp->exy.x,
			    (double)segp->exy.y
			    );
#endif

		/* Put input segment pieces into segment list. */

		/* Note:  It is better to scan the pieces to find the
		   tail link than to waste storage on double links. */
		for ( pp = piecehead.links; pp->links != &piecehead;
		    pp = pp->links
		    )
			;
		pp->links = seghead.links;	/* last-piece link */
		seghead.links = piecehead.links;	/* add pieces */
	}
	Toss( (pointer)inp );		/* unused segment at EOF */

	return inp != NULL;
}


static bool_t
Split(coords *p, register segment *oldp, register segment *listh) 		/* split segment in two */
				/* -> break point */
				/* -> segment to be split */
				/* -> list to attach tail to */
{
	register segment	*newp;	/* -> new list entry */

#ifdef	DEBUG
	fprintf(stderr, "split (%g,%g)->(%g,%g) at (%g,%g)",
	    (double)oldp->sxy.x, (double)oldp->sxy.y,
	    (double)oldp->exy.x, (double)oldp->exy.y,
	    (double)p->x, (double)p->y
	    );
#endif
	if ( (newp = (segment *)Alloc( (unsigned)sizeof(segment) )) == NULL )
		return false;		/* out of heap space */
	newp->links = listh->links;
	newp->sxy = *p;
	newp->exy = oldp->exy;
	oldp->exy = *p; 		/* old entry, new endpoint */
	listh->links = newp;		/* attach to list head */

	return true;
}


static bool_t
Build(void) 				/* build linked lists */
{
	register segment	*listp; /* -> segment list entry */
	segment 		*deadp; /* -> list entry to be freed */

#ifdef	DEBUG
	fprintf(stderr, "\n\t\tBuild\n" );
#endif
	/* When we are finished, `seghead' will become invalid. */
	for ( listp = seghead.links; listp != &seghead;
	    deadp = listp, listp = listp->links, Toss( (pointer)deadp )
	    )	{
		register point	*startp, *endp; /* -> segment endpts */

		if ( (startp = PutList( &listp->sxy )) == NULL
		    || (endp   = PutList( &listp->exy )) == NULL
		    || Enqueue( startp, endp ) == NULL
		    || Enqueue( endp, startp ) == NULL
		    )
			return false;	/* out of heap space */
	}

	return	true;
}


static bool_t
Search(void)				/* output bounding polygon */
{
	double		from;		/* backward edge direction */
	register point	*currentp;	/* -> current (start) point */
	point		*previousp;	/* -> previous vertex point */

#ifdef	DEBUG
	fprintf(stderr, "\n\t\tSearch\n" );
#endif
	if ( headp == NULL )
		return true;		/* trivial case */

	/* Locate the lowest point; this is the first polygon vertex. */
	{
		float		miny;		/* smallest Y coordinate */
		register point	*listp; 	/* -> next point in list */

		currentp = listp = headp;
		miny = currentp->xy.y;
		while ( (listp = listp->linkp) != NULL )
			if ( listp->xy.y < miny )
			{
				miny = listp->xy.y;
				currentp = listp;
			}
	}
	previousp = NULL;		/* differs from currentp! */
	from = 270.0;

	/* Output point and look for next CCW point on periphery. */

	for ( ; ; )
	{
		coords		first;	/* first output if -v */
		double		mindir; /* smallest from->to angle */
		register point	*nextp = (point *)NULL; /* -> next perimeter point */
		queue		*endq;	/* -> endpoint queue entry */

#ifdef	DEBUG
		fprintf(stderr, "from %g", from );
#endif
		endq = currentp->firstq;
		if ( endq == NULL )
		{
			if ( vflag && !initial )
				Output( &first );	/* closure */

			return true;	/* been here before => done */
		}

		Output( &currentp->xy );	/* found vertex */
		if ( vflag && initial )
		{
			initial = false;
			first = currentp->xy;	/* save for closure */
		}

		/* Find the rightmost forward edge endpoint. */

		mindir = 362.0;
		do	{
			double		to;	/* forward edge dir */
			double		diff;	/* angle from->to */
			register point	*endp;	/* -> endpoint */

			endp = endq->endpoint;
			if ( endp == previousp	/* don't double back! */
			|| endp == currentp	/* don't stay here! */
			)
				continue;

			/* Note: it would be possible to save some calls
			   to atan2 by being clever about quadrants.  */
			if ( endp->xy.y == currentp->xy.y
			    && endp->xy.x == currentp->xy.x
			    )
				to = 0.0;	/* not supposed to happen */
			else
				to = atan2( (double)
				    (endp->xy.y - currentp->xy.y),
				    (double)
				    (endp->xy.x - currentp->xy.x)
				    ) * DEGRAD;
#ifdef	DEBUG
			fprintf(stderr, "to %g", to );
#endif
			diff = to - from;
			/* Note: Exact 360 (0) case is not supposed to
			   happen, but this algorithm copes with it.  */
			while ( diff <= 0.0 )
				diff += 360.0;

			if ( diff < mindir )
			{
#ifdef	DEBUG
				fprintf(stderr, "new min %g", diff );
#endif
				mindir = diff;
				nextp = endp;
			}
		} while ( (endq = endq->nextq) != NULL );

		if ( mindir > 361.0 )
			fprintf(stderr, "degenerate input" );

		currentp->firstq = NULL;	/* "visited" */
		previousp = currentp;
		currentp = nextp;

		from += mindir + 180.0; /* reverse of saved "to" */
		/* The following is needed only to improve accuracy: */
		while ( from > 360.0 )
			from -= 360.0;	/* reduce to range [0,360) */
	}
}


static point *
PutList(register coords *coop) 			/* return -> point in list */
				/* -> coordinates */
{
	register point	*p;		/* -> list entry */

	p = LookUp( coop );		/* may already be there */
	if ( p == NULL )		/* not yet in list */
	{			/* start new point group */
#ifdef	DEBUG
		fprintf(stderr, "new point group (%g,%g)",
		    (double)coop->x, (double)coop->y
		    );
#endif
		p = NewPoint( coop );
#if 0
			if ( p == NULL )
			return NULL;	/* out of heap space */
#endif
	}

	return p;			/* -> point list entry */
}


static point *
LookUp(register coords *coop)				/* find point group in list */
				/* -> coordinates */
{
	register point	*p;		/* -> list members */

	for ( p = headp; p != NULL; p = p->linkp )
		if ( Near( coop, &p->xy ) )
		{
#ifdef	DEBUG
			fprintf(stderr, "found (%g,%g) in list",
				(double)coop->x, (double)coop->y
				);
#endif
			return p;	/* found a match */
		}

	return NULL;			/* not yet in list */
}


static point *
NewPoint(register coords *coop)			/* add point to list */
				/* -> coordinates */
{
	register point	*newp;		/* newly allocated point */

	newp = (point *)Alloc( (unsigned)sizeof(point) );
	if ( newp == NULL )
		return NULL;

#ifdef	DEBUG
	fprintf(stderr, "add point (%g,%g)",
		(double)coop->x, (double)coop->y
		);
#endif
	newp->linkp = headp;
	newp->firstq = NULL;		/* empty endpoint queue */
	newp->xy = *coop;		/* coordinates */
	return headp = newp;
}


static queue *
Enqueue(register point *addp, register point *startp) 		/* add to endpoint queue */
				/* -> point being queued */
				/* -> point owning queue */
{
	register queue	*newq;		/* new queue element */

	newq = (queue *)Alloc( (unsigned)sizeof(queue) );
	if ( newq == NULL )
		return NULL;

#ifdef	DEBUG
	fprintf(stderr, "enqueue (%g,%g) on (%g,%g)",
		(double)addp->xy.x, (double)addp->xy.y,
		(double)startp->xy.x, (double)startp->xy.y
		);
#endif
	newq->nextq = startp->firstq;
	newq->endpoint = addp;
	return startp->firstq = newq;
}


static coords *
Intersect(register segment *a, register segment *b)			/* determine intersection */
				/* segments being tested */
{
	double			det;	/* determinant, 0 if parallel */
	double			xaeas, xbebs, yaeas, ybebs;
	/* coordinate differences */

	/* First perform range check, to eliminate most cases.	Note
	   that segments point left-to-right even after splitting. */

	if ( a->sxy.x > 		/* a left */
	b->exy.x + tolerance	/* b right */
	|| a->exy.x < 		/* a right */
	b->sxy.x - tolerance	/* b left */
	|| Min( a->sxy.y, a->exy.y ) >		/* a bottom */
	Max( b->sxy.y, b->exy.y ) + tolerance	/* b top */
	|| Max( a->sxy.y, a->exy.y ) <		/* a top */
	Min( b->sxy.y, b->exy.y ) - tolerance	/* b bottom */
	)	{
#ifdef	DEBUG
		fprintf(stderr, "ranges don't intersect");
#endif
		return NULL;		/* can't intersect */
	}

	/* Passed quick check, now comes the hard part. */

	xaeas = (double)a->exy.x - (double)a->sxy.x;
	xbebs = (double)b->exy.x - (double)b->sxy.x;
	yaeas = (double)a->exy.y - (double)a->sxy.y;
	ybebs = (double)b->exy.y - (double)b->sxy.y;

	det = xbebs * yaeas - xaeas * ybebs;

	{
		double	norm;			/* norm of coefficient matrix */
		double	t;			/* test value for norm */

		norm = 0.0;
		if ( (t = Abs( xaeas )) > norm )
			norm = t;
		if ( (t = Abs( xbebs )) > norm )
			norm = t;
		if ( (t = Abs( yaeas )) > norm )
			norm = t;
		if ( (t = Abs( ybebs )) > norm )
			norm = t;

#define EPSILON 1.0e-06 		/* relative `det' size thresh */
		if ( Abs( det ) <= EPSILON * norm * norm )
		{
#ifdef	DEBUG
			fprintf(stderr, "parallel: det=%g, norm=%g", det, norm );
#endif
			return NULL;		/* parallels don't intersect */
		}
#undef	EPSILON
	}
	{
		/* `p' must be static; Intersect returns a pointer to it! */
		static coords	p;		/* point of intersection */
		double		lambda, mu;	/* segment parameters */
		double		onemmu; 	/* 1.0 - mu, for efficiency */
		double		xbsas, ybsas;	/* more coord differences */

		xbsas = (double)b->sxy.x - (double)a->sxy.x;
		ybsas = (double)b->sxy.y - (double)a->sxy.y;

		mu = (xbebs * ybsas - xbsas * ybebs) / det;
		onemmu = 1.0 - mu;
		p.x = onemmu * a->sxy.x + mu * a->exy.x;
		p.y = onemmu * a->sxy.y + mu * a->exy.y;
		if ( (onemmu < 0.0 || mu < 0.0) && !EndPoint( &p, a ) )
		{
#ifdef	DEBUG
			fprintf(stderr, "intersect off (%g,%g)->(%g,%g): mu=%g",
				(double)a->sxy.x, (double)a->sxy.y,
				(double)a->exy.x, (double)a->exy.y,
				mu
				);
#endif
			return NULL;		/* not in segment *a */
		}

		lambda = (xaeas * ybsas - xbsas * yaeas) / det;
		if ( (lambda > 1.0 || lambda < 0.0) && !EndPoint( &p, b ) )
		{
#ifdef	DEBUG
			fprintf(stderr, "intersect off (%g,%g)->(%g,%g): lambda=%g",
				(double)b->sxy.x, (double)b->sxy.y,
				(double)b->exy.x, (double)b->exy.y,
				lambda
				);
#endif
			return NULL;		/* not in segment *b */
		}

#ifdef	DEBUG
		fprintf(stderr, "intersection is (%g,%g): mu=%g lambda=%g",
			(double)p.x, (double)p.y, mu, lambda
			);
#endif
		return &p;
	}
}


static bool_t
EndPoint(register coords *p, register segment *segp)			/* check for segment endpoint */
				/* -> point being tested */
				/* -> segment */
{
#ifdef	DEBUG
	if ( Near( p, &segp->sxy ) || Near( p, &segp->exy ) )
		fprintf(stderr, "(%g,%g) is endpt of (%g,%g)->(%g,%g)",
			(double)p->x, (double)p->y,
			(double)segp->sxy.x, (double)segp->sxy.y,
			(double)segp->exy.x, (double)segp->exy.y
			);
#endif
	return Near( p, &segp->sxy ) || Near( p, &segp->exy );
}


static bool_t
Near(register coords *ap, register coords *bp)				/* check if within tolerance */
				/* -> points being checked */
{
	double		xsq, ysq;	/* dist between coords ^ 2 */

	/* Originally this was an abs value test; this is neater. */

	xsq = ap->x - bp->x;
	xsq *= xsq;
	ysq = ap->y - bp->y;
	ysq *= ysq;

#ifdef	DEBUG
	if ( xsq + ysq <= tolsq )
		fprintf(stderr, "(%g,%g) is near (%g,%g)",
			(double)ap->x, (double)ap->y,
			(double)bp->x, (double)bp->y
			);
#endif
	return xsq + ysq <= tolsq;
}


static pointer
Alloc(unsigned int size)				/* allocate storage from heap */
				/* # bytes required */
{
	register pointer	ptr;	/* -> allocated storage */

	if ( (ptr = malloc( size * sizeof(char) )) == NULL )
		fprintf(stderr, "out of memory");

	return ptr;			/* (may be NULL) */
}


static void
Toss(register pointer ptr)				/* return storage to heap */
				/* -> allocated storage */
{
	if ( ptr != NULL )
		free( ptr );
}


static bool_t
Input(register segment *inp)				/* input stroke record */
				/* -> input segment */
{
	char			inbuf[82];	/* record buffer */

	while ( bu_fgets( inbuf, (int)sizeof inbuf, stdin ) != NULL )
	{			/* scan input record */
		register int	cvt;	/* # fields converted */

#ifdef	DEBUG
		fprintf(stderr, "input: %s", inbuf);
#endif
		cvt = sscanf( inbuf, " %e %e %e %e",
		    &inp->sxy.x, &inp->sxy.y,
		    &inp->exy.x, &inp->exy.y
		    );

		if ( cvt == 0 )
			continue;	/* skip color, comment, etc. */

		if ( cvt == 4 )
			return true;	/* successfully converted */

		fprintf(stderr, "bad input: %s", inbuf);
		bu_exit( 5, NULL );		/* return false insufficient */
	}

	return false;			/* EOF */
}


static void
Output(register coords *coop)				/* dump polygon vertex coords */
				/* -> coords to be output */
{
	static coords	last;		/* previous *coop */

	if ( vflag )
	{
		if ( !initial )
			printf( "%g %g %g %g\n",
			    (double)last.x, (double)last.y,
			    (double)coop->x, (double)coop->y
			    );

		last = *coop;		/* save for next start point */
	}
	else
		printf( "%g %g\n",
		    (double)coop->x, (double)coop->y
		    );
#ifdef	DEBUG
	fprintf(stderr, "output: %g %g", (double)coop->x, (double)coop->y);
#endif
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.17
log
@want the other HAVE_STDARG_H section
@
text
@a39 3
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.16 2007/12/02 21:51:10 brlcad Exp $ (BRL)";
#endif
a83 1
static bool_t	Mess(const char *fmt, ...);
d105 1
a105 1
	    Mess( "usage: cad_boundp[ -i input][ -o output][ -t tolerance][ -v]" );
d141 1
a141 1
	(void)Mess( "\n\t\tGetArgs\n" );
d149 1
a149 1
				    Mess( "too many -i options" );
d156 1
a156 1
				    Mess( "can't open \"%s\"", bu_optarg );
d162 1
a162 1
				    Mess( "too many -o options" );
d169 1
a169 1
				    Mess( "can't create \"%s\"", bu_optarg );
d175 1
a175 1
				    Mess( "too many -t options" );
d180 1
a180 1
				    Mess( "bad tolerance: %s", bu_optarg );
d209 1
a209 1
	(void)Mess( "\n\t\tChop\n" );
d229 1
a229 1
			(void)Mess( "endpoints swapped" );
d270 1
a270 1
		(void)Mess( "new input pieces:" );
d274 1
a274 1
			(void)Mess( "\t(%g,%g)->(%g,%g)",
d280 1
a280 1
		(void)Mess( "other segments:" );
d284 1
a284 1
			(void)Mess( "\t(%g,%g)->(%g,%g)",
d318 1
a318 1
	(void)Mess( "split (%g,%g)->(%g,%g) at (%g,%g)",
d343 1
a343 1
	(void)Mess( "\n\t\tBuild\n" );
d371 1
a371 1
	(void)Mess( "\n\t\tSearch\n" );
d403 1
a403 1
		(void)Mess( "from %g", from );
d448 1
a448 1
			(void)Mess( "to %g", to );
d459 1
a459 1
				(void)Mess( "new min %g", diff );
d467 1
a467 1
			return Mess( "degenerate input" );
d491 1
a491 1
		(void)Mess( "new point group (%g,%g)",
d516 3
a518 3
			(void)Mess( "found (%g,%g) in list",
			    (double)coop->x, (double)coop->y
			    );
d538 3
a540 3
	(void)Mess( "add point (%g,%g)",
	    (double)coop->x, (double)coop->y
	    );
d561 4
a564 4
	(void)Mess( "enqueue (%g,%g) on (%g,%g)",
	    (double)addp->xy.x, (double)addp->xy.y,
	    (double)startp->xy.x, (double)startp->xy.y
	    );
d593 1
a593 1
		(void)Mess( "ranges don't intersect" );
d625 1
a625 1
			(void)Mess( "parallel: det=%g, norm=%g", det, norm );
d648 5
a652 5
			(void)Mess( "intersect off (%g,%g)->(%g,%g): mu=%g",
			    (double)a->sxy.x, (double)a->sxy.y,
			    (double)a->exy.x, (double)a->exy.y,
			    mu
			    );
d661 5
a665 5
			(void)Mess( "intersect off (%g,%g)->(%g,%g): lambda=%g",
			    (double)b->sxy.x, (double)b->sxy.y,
			    (double)b->exy.x, (double)b->exy.y,
			    lambda
			    );
d671 3
a673 3
		(void)Mess( "intersection is (%g,%g): mu=%g lambda=%g",
		    (double)p.x, (double)p.y, mu, lambda
		    );
d687 5
a691 5
		(void)Mess( "(%g,%g) is endpt of (%g,%g)->(%g,%g)",
		    (double)p->x, (double)p->y,
		    (double)segp->sxy.x, (double)segp->sxy.y,
		    (double)segp->exy.x, (double)segp->exy.y
		    );
d712 4
a715 4
		(void)Mess( "(%g,%g) is near (%g,%g)",
		    (double)ap->x, (double)ap->y,
		    (double)bp->x, (double)bp->y
		    );
d728 1
a728 1
		(void)Mess( "out of memory" );
a743 18
Mess( const char *fmt, ... )			/* print error message */
{
	va_list		ap;		/* for accessing arguments */
	va_start( ap, fmt );

	(void)fflush( stdout );
	(void)fputs( "cad_boundp: ", stderr );

	(void)vprintf( fmt, ap );
	(void)fputc( '\n', stderr );

	va_end( ap );

	return false;
}


static bool_t
d754 1
a754 1
		(void)Mess( "input: %s", inbuf );
d767 1
a767 1
		(void)Mess( "bad input: %s", inbuf );
d796 1
a796 3
	(void)Mess( "output: %g %g",
	    (double)coop->x, (double)coop->y
	    );
@


14.16
log
@no longer need the pre-ansi hacks with c89 functionality assumption, remove the non stdard-based variable-length argument functions
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.15 2007/11/21 20:49:09 erikgreenwald Exp $ (BRL)";
a49 1

a746 1
/*VARARGS*/
d751 1
a751 3

	va_start( ap );
	fmt = va_arg( ap, char * );
@


14.15
log
@pass bu_exit a NULL instead of an empty string
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.14 2007/11/21 19:49:11 erikgreenwald Exp $ (BRL)";
d51 1
a51 5
#ifdef HAVE_STDARG_H
#  include <stdarg.h>
#else
#  include <varargs.h>
#endif
d88 1
a88 5
#ifdef HAVE_STDARG_H
static bool_t	Mess(char *fmt, ...);
#else
static bool_t	Mess();
#endif
d750 1
a750 6
#ifdef HAVE_STDARG_H
Mess( char *fmt, ... )			/* print error message */
#else
Mess( va_alist )			/* print error message */
va_dcl					/* format, optional arguments */
#endif
a752 2
#ifndef HAVE_STDARG_H
	register char	*fmt;		/* format */
d756 1
a756 3
#else
	va_start( ap, fmt );
#endif
d759 1
a759 1
#ifdef HAVE_VPRINTF
a760 3
#else
	(void) _doprnt( fmt, ap, stderr );
#endif
@


14.14
log
@exit->bu_exit where applicable
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.13 2007/09/15 16:23:16 brlcad Exp $ (BRL)";
d814 1
a814 1
		bu_exit( 5, "" );		/* return false insufficient */
@


14.13
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.12 2007/07/26 01:13:58 brlcad Exp $ (BRL)";
d814 1
a814 1
		exit( 5 );		/* return false insufficient */
@


14.12
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.11 2007/04/18 02:55:14 brlcad Exp $ (BRL)";
d49 2
a50 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.12.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.13 2007/09/15 16:23:16 brlcad Exp $ (BRL)";
d49 5
a53 2
#include <string.h>

@


14.11
log
@use bool_t instead of bool until a wholesale c99 conversion is made
@
text
@a26 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.10 2007/02/20 08:19:49 brlcad Exp $ (BRL)";
@


14.10
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.9 2007/01/27 01:41:43 brlcad Exp $ (BRL)";
d101 1
a101 1
static bool	Mess(char *fmt, ...);
d103 1
a103 1
static bool	Mess();
d105 1
a105 1
static bool	Build(void), Chop(void), EndPoint(register coords *p, register segment *segp), GetArgs(int argc, char **argv), Input(register segment *inp),
d113 2
a114 2
static bool	initial = true; 	/* false after first Output */
static bool	vflag = false;		/* set if "-v" option found */
d122 1
a122 1
static bool
d151 1
a151 1
static bool
d156 3
a158 3
	static bool	iflag = false;	/* set if "-i" option found */
	static bool	oflag = false;	/* set if "-o" option found */
	static bool	tflag = false;	/* set if "-t" option found */
d224 1
a224 1
static bool
d330 1
a330 1
static bool
d357 1
a357 1
static bool
d384 1
a384 1
static bool
d701 1
a701 1
static bool
d718 1
a718 1
static bool
d765 1
a765 1
static bool
d797 1
a797 1
static bool
@


14.9
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.8 2007/01/23 01:13:41 brlcad Exp $ (BRL)";
d803 1
a803 1
	while ( fgets( inbuf, (int)sizeof inbuf, stdin ) != NULL )
@


14.8
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.7 2007/01/20 14:36:57 brlcad Exp $ (BRL)";
d132 2
a133 2
   	     			/* argument count */
    	        		/* argument strings */
d153 2
a154 2
   		     		/* argument count */
    		        	/* argument strings */
d332 3
a334 3
      			   	/* -> break point */
                	      	/* -> segment to be split */
                	        /* -> list to attach tail to */
d504 1
a504 1
                      		/* -> coordinates */
d529 1
a529 1
                      		/* -> coordinates */
d550 1
a550 1
                      		/* -> coordinates */
d572 2
a573 2
              	      		/* -> point being queued */
              	        	/* -> point owning queue */
d595 1
a595 1
                	        /* segments being tested */
d703 2
a704 2
                	   	/* -> point being tested */
                	      	/* -> segment */
d720 1
a720 1
                         	/* -> points being checked */
d744 1
a744 1
        		     	/* # bytes required */
d757 1
a757 1
                	    	/* -> allocated storage */
d799 1
a799 1
                	     	/* -> input segment */
d831 1
a831 1
                      		/* -> coords to be output */
@


14.7
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.6 2006/01/23 06:20:27 brlcad Exp $ (BRL)";
@


14.6
log
@stdlib.h
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.5 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
@


14.5
log
@update copyright to 2006
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.4 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
d52 1
a52 2


d56 1
a56 1
#include <string.h>
d58 1
a58 1
#include <strings.h>
d61 1
a61 1
#include	<stdarg.h>
d63 1
a63 1
#include	<varargs.h>
d71 1
@


14.4
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.3 2005/01/30 20:31:05 brlcad Exp $ (BRL)";
@


14.3
log
@update copyright to 2005
@
text
@d27 1
a27 1
 *  
d32 1
a32 1
 *  
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cad_boundp.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
d119 1
a119 1
static segment	seghead = { 
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d27 1
a27 1
 *
d32 1
a32 1
 *
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d119 1
a119 1
static segment	seghead = {
@


14.2
log
@GPL License changes
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cad_boundp.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			C A D _ B O U N D P . C
a32 3
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
 *
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cad_boundp.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cad_boundp.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d840 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cad_boundp.c,v 1.2 2004/06/08 22:04:26 morrison Exp $ (BRL)";
d40 1
a40 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d34 1
a34 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/cad_boundp.c,v 11.9 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a54 1
#include "externs.h"
@

