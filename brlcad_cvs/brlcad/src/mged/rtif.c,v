head	14.37;
access;
symbols
	rel-7-10-4:14.27.2.1
	STABLE:14.27.0.2
	stable-branch:14.4
	rel-7-10-2:14.27
	rel-7-10-0:14.27
	rel-7-8-4:14.20
	rel-7-8-2:14.18
	rel-7-8-0:14.18
	trimnurbs-branch:14.17.0.2
	help:14.17
	temp_tag:14.15
	bobWinPort-20051223-freeze:14.7.2.1
	postmerge-20051223-bobWinPort:14.15
	premerge-20051223-bobWinPort:14.14
	rel-7-6-6:14.14
	rel-7-6-4:14.14
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.5
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.6
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.37
date	2007.12.19.22.32.38;	author brlcad;	state Exp;
branches;
next	14.36;

14.36
date	2007.12.02.22.34.23;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2007.11.21.20.49.09;	author erikgreenwald;	state Exp;
branches;
next	14.34;

14.34
date	2007.11.21.19.49.11;	author erikgreenwald;	state Exp;
branches;
next	14.33;

14.33
date	2007.11.08.19.16.50;	author bob1961;	state Exp;
branches;
next	14.32;

14.32
date	2007.10.22.19.53.30;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2007.10.19.19.54.54;	author bob1961;	state Exp;
branches;
next	14.30;

14.30
date	2007.10.14.01.17.30;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.09.15.16.23.17;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.09.14.15.21.09;	author erikgreenwald;	state Exp;
branches;
next	14.27;

14.27
date	2007.02.26.22.09.12;	author brlcad;	state Exp;
branches
	14.27.2.1;
next	14.26;

14.26
date	2007.02.26.21.06.35;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.02.20.08.19.49;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.27.01.41.44;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.26.03.33.44;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.23.01.13.42;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.07.09.19.17.16;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.07.09.18.25.32;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.04.06.20.50.03;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.01.28.00.36.29;	author brlcad;	state Exp;
branches
	14.17.2.1;
next	14.16;

14.16
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.14;

14.14
date	2005.11.07.04.42.34;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.11.07.01.07.50;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.10.31.07.30.58;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.31.07.04.00;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.30.21.58.57;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.09.16.18.51.53;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.07.08.00.27.51;	author brlcad;	state Exp;
branches
	14.7.2.1
	14.7.6.1;
next	14.6;

14.6
date	2005.06.24.23.23.20;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.05.28.02.14.52;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.03.24.17.32.20;	author bob1961;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.26.20.39.28;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.04.07.27.01;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.29;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.28;	author morrison;	state Exp;
branches;
next	;

14.7.2.1
date	2005.09.08.15.51.06;	author bob1961;	state Exp;
branches;
next	;

14.7.6.1
date	2005.11.13.13.46.18;	author brlcad;	state Exp;
branches;
next	;

14.17.2.1
date	2006.04.07.19.30.28;	author jlowenz;	state Exp;
branches;
next	;

14.27.2.1
date	2007.09.28.14.04.35;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.37
log
@manuallly null-terminate buffers after a strncat for sanity
@
text
@/*                          R T I F . C
 * BRL-CAD
 *
 * Copyright (c) 1988-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file rtif.c
 *
 *  Routines to interface to RT, and RT-style command files
 *
 * Functions -
 *	cmd_rt		ray-trace
 *	cmd_rrt		ray-trace using any program
 *	cmd_rtabort     abort ray-traces started through mged
 *	cmd_rtcheck	ray-trace to check for overlaps
 *	cmd_rtarea	ray-trace to report exposed area
 *	cmd_rtedge	ray-trace edges for an outline view
 *	cmd_rtweight	ray-trace to report weight/moments
 *	f_saveview	save the current view parameters
 *	f_loadview	load view parameters from a saveview file
 *	f_rmats		load views from a file
 *	f_savekey	save keyframe in file
 *	f_nirt          trace a single ray from current view
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.36 2007/12/02 22:34:23 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <signal.h>

#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>		/* For struct timeval */
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "mater.h"
#include "./sedit.h"
#include "./ged.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./qray.h"
#include "./cmd.h"

#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif


extern int mged_svbase(void);
extern void set_perspective(); /* from set.c */

/* from ged.c -- used to open databases quietly */
extern int interactive;

static void setup_rt(register char **vp, int printcmd);

static int tree_walk_needed;
struct run_rt head_run_rt;

struct rtcheck {
#ifdef _WIN32
	HANDLE			fd;
	HANDLE			hProcess;
	DWORD			pid;
#  ifdef TCL_OK
	Tcl_Channel		chan;
#  else
	genptr_t		chan;
#  endif
#else /* _WIN32 */
       int			fd;
       int			pid;
#endif /* _WIN32 */
	   FILE			*fp;
       struct bn_vlblock	*vbp;
       struct bu_list		*vhead;
       double			csize;
};

static vect_t	rtif_eye_model;
static mat_t	rtif_viewrot;
static struct bn_vlblock	*rtif_vbp;
static FILE	*rtif_fp;
static double	rtif_delay;
static struct _mged_variables    rtif_saved_state;       /* saved state variables */
static int	rtif_mode;
static int	rtif_desiredframe;
static int	rtif_finalframe;
static int	rtif_currentframe;

extern int	cm_start();
extern int	cm_vsize();
extern int	cm_eyept();
extern int	cm_lookat_pt();
extern int	cm_vrot();
extern int	cm_end();
extern int	cm_multiview();
extern int	cm_anim();
extern int	cm_tree();
extern int	cm_clean();
extern int	cm_set();
extern int	cm_ae();
extern int	cm_orientation();
extern int	cm_null();

/**
 * here we define a minimal table of commands that are supported by the
 * loadview command.  unsupported commands are those that have no bearing on
 * view restoration.
 */
struct command_tab view_cmdtab[] = {
    {"viewsize", "size in mm", "set view size",
     cm_vsize,	2, 2},
    {"eye_pt", "xyz of eye", "set eye point",
     cm_eyept,	4, 4},
    {"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
     cm_lookat_pt,	4, 5},
    {"viewrot", "4x4 matrix", "set view direction from matrix",
     cm_vrot,	17,17},
    {"orientation", "quaturnion", "set view direction from quaturnion",
     cm_orientation,	5, 5},
    {"set", 	"", "show or set parameters",
     cm_set,		1, 999},

    /* begin unsupported commands (for view loading) */

    {"start", "frame number", "start a new frame",
     cm_null,	2, 2},
    {"clean", "", "clean articulation from previous frame",
     cm_null,	1, 1},
    {"end", 	"", "end of frame setup, begin raytrace",
     cm_null,		1, 1},

    /* not output, by default in saveview */

    {"multiview", "", "produce stock set of views",
     cm_null,	1, 1},
    {"anim", 	"path type args", "specify articulation animation",
     cm_null,	4, 999},
    {"tree", 	"treetop(s)", "specify alternate list of tree tops",
     cm_null,	1, 999},
    {"ae", "azim elev", "specify view as azim and elev, in degrees",
     cm_null,		3, 3},
    {"opt", "-flags", "set flags, like on command line",
     cm_null,		2, 999},

    /* this is a quick hack used for quietly parsing the EOF delimiter in the
     * script files.
     */
    {"EOF", "", "End of file delimiter",
     cm_null,		1, 1},

    /* XXX support for the ae command is not included, though it probably should */
    {(char *)0, (char *)0, (char *)0,
     0,		0, 0	/* END */}
};


/**
 *			P R _ W A I T _ S T A T U S
 *
 *  Interpret the status return of a wait() system call,
 *  for the edification of the watching luser.
 *  Warning:  This may be somewhat system specific, most especially
 *  on non-UNIX machines.
 */
void
pr_wait_status(int status)
{
    int	sig = status & 0x7f;
    int	core = status & 0x80;
    int	ret = status >> 8;
    struct bu_vls tmp_vls;

    if( status == 0 )  {
	Tcl_AppendResult(interp, "Normal exit\n", (char *)NULL);
	return;
    }

    bu_vls_init(&tmp_vls);
    bu_vls_printf(&tmp_vls, "Abnormal exit x%x", status);

    if( core )
	bu_vls_printf(&tmp_vls, ", core dumped");

    if( sig )
	bu_vls_printf(&tmp_vls, ", terminating signal = %d", sig );
    else
	bu_vls_printf(&tmp_vls, ", return (exit) code = %d", ret );

    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), "\n", (char *)NULL);
    bu_vls_free(&tmp_vls);
}


/**
 *  			R T _ O L D W R I T E
 *
 *  Write out the information that RT's -M option needs to show current view.
 *  Note that the model-space location of the eye is a parameter,
 *  as it can be computed in different ways.
 *  The is the OLD format, needed only when sending to RT on a pipe,
 *  due to some oddball hackery in RT to determine old -vs- new format.
 */
HIDDEN void
rt_oldwrite(FILE *fp, fastf_t *eye_model)
{
    register int i;

    (void)fprintf(fp, "%.9e\n", view_state->vs_vop->vo_size);
    (void)fprintf(fp, "%.9e %.9e %.9e\n",
		  eye_model[X], eye_model[Y], eye_model[Z] );
    for( i=0; i < 16; i++ )  {
	(void)fprintf(fp, "%.9e ", view_state->vs_vop->vo_rotation[i]);
	if( (i%4) == 3 )
	    (void)fprintf(fp, "\n");
    }
    (void)fprintf(fp, "\n");
}


/**
 *  			R T _ W R I T E
 *
 *  Write out the information that RT's -M option needs to show current view.
 *  Note that the model-space location of the eye is a parameter,
 *  as it can be computed in different ways.
 */
HIDDEN void
rt_write(FILE *fp, fastf_t *eye_model)
{
    register int	i;
    quat_t		quat;
    register struct solid *sp;

    (void)fprintf(fp, "viewsize %.15e;\n", view_state->vs_vop->vo_size);
    quat_mat2quat(quat, view_state->vs_vop->vo_rotation);
    (void)fprintf(fp, "orientation %.15e %.15e %.15e %.15e;\n", V4ARGS(quat));
    (void)fprintf(fp, "eye_pt %.15e %.15e %.15e;\n",
		  eye_model[X], eye_model[Y], eye_model[Z] );

    (void)fprintf(fp, "start 0; clean;\n");
    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
	for (i=0;i<sp->s_fullpath.fp_len;i++) {
	    DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags &= ~DIR_USED;
	}
    }
    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
	for (i=0; i<sp->s_fullpath.fp_len; i++ ) {
	    struct directory *dp;
	    dp = DB_FULL_PATH_GET(&sp->s_fullpath,i);
	    if (!(dp->d_flags & DIR_USED)) {
		register struct animate *anp;
		for (anp = dp->d_animate; anp;
		     anp=anp->an_forw) {
		    db_write_anim(fp, anp);
		}
		dp->d_flags |= DIR_USED;
	    }
	}
    }

    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
	for (i=0;i<sp->s_fullpath.fp_len;i++) {
	    DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags &= ~DIR_USED;
	}
    }
#undef DIR_USED
    (void)fprintf(fp, "end;\n");
}


/**
 *  			R T _ R E A D
 *
 *  Read in one view in the old RT format.
 */
HIDDEN int
rt_read(FILE *fp, fastf_t *scale, fastf_t *eye, fastf_t *mat)
{
    register int i;
    double d;

    if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
    *scale = d*0.5;
    if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
    eye[X] = d;
    if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
    eye[Y] = d;
    if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
    eye[Z] = d;
    for( i=0; i < 16; i++ )  {
	if( fscanf( fp, "%lf", &d ) != 1 )
	    return(-1);
	mat[i] = d;
    }
    return(0);
}


/**
 *			B U I L D _ T O P S
 *
 *  Build a command line vector of the tops of all objects in view.
 */
int
build_tops(char **start, char **end)
{
    register char **vp = start;
    register struct solid *sp;

    /*
     * Find all unique top-level entries.
     *  Mark ones already done with s_wflag == UP
     */
    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
	sp->s_wflag = DOWN;
    }
    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
	register struct solid *forw;
	struct directory *dp = FIRST_SOLID(sp);

	if( sp->s_wflag == UP )
	    continue;
	if( dp->d_addr == RT_DIR_PHONY_ADDR )
	    continue;	/* Ignore overlays, predictor, etc */
	if( vp < end )
	    *vp++ = dp->d_namep;
	else  {
	    Tcl_AppendResult(interp, "mged: ran out of comand vector space at ",
			     dp->d_namep, "\n", (char *)NULL);
	    break;
	}
	sp->s_wflag = UP;
	for(BU_LIST_PFOR(forw, sp, solid, &dgop->dgo_headSolid)){
	    if( FIRST_SOLID(forw) == dp )
		forw->s_wflag = UP;
	}
    }
    *vp = (char *) 0;
    return vp-start;
}


/**
 *			S E T U P _ R T
 *
 *  Set up command line for one of the RT family of programs,
 *  with all objects in view enumerated.
 */
static char	*rt_cmd_vec[MAXARGS];
static int	rt_cmd_vec_len;
static char	rt_cmd_storage[MAXARGS*9];

static void
setup_rt(register char **vp, int printcmd)
{
    rt_cmd_vec_len = vp - rt_cmd_vec;
    rt_cmd_vec_len += build_tops(vp, &rt_cmd_vec[MAXARGS]);

    if(printcmd){
	/* Print out the command we are about to run */
	vp = &rt_cmd_vec[0];
	while( *vp )
	    Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

	Tcl_AppendResult(interp, "\n", (char *)NULL);
    }
}


/**
 *  C M D _ R T A B O R T
 *
 *  Abort any raytraces started through mged.
 */
int
cmd_rtabort(ClientData clientData,
	    Tcl_Interp *interp,
	    int argc,
	    char **argv)
{
    return dgo_rtabort_cmd(dgop, interp, argc, argv);
}


void
display_error()
{
#ifndef _WIN32
    perror("READ ERROR");
#else
    char* err;
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		  NULL,
		  GetLastError(),
		  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		  (LPTSTR) &err,
		  0,
		  NULL);
    MessageBox(NULL, err, "Error", MB_OK|MB_ICONINFORMATION);
    LocalFree(err);
#endif
}


void
rt_output_handler(ClientData clientData, int mask)
{
    struct run_rt *run_rtp = (struct run_rt *)clientData;
    int count;

    /* output buffer */
#ifndef _WIN32
    char line[RT_MAXLINE+1] = {0};
#else
    char line[5120+1] = {0};
#endif

    /* Get data from rt */
#ifndef _WIN32
    count = read((int)run_rtp->fd, line, RT_MAXLINE);
#else
    count = ReadFile(run_rtp->fd, line, 5120,&count,0);
#endif

    if (count <= 0) {
	int retcode;
	int rpid;
	int aborted;

	display_error();

	/* close the file handle */
#ifndef _WIN32
	Tcl_DeleteFileHandler(run_rtp->fd);
	close(run_rtp->fd);
#else
	Tcl_DeleteChannelHandler(run_rtp->chan,rt_output_handler,(ClientData)run_rtp);
	CloseHandle(run_rtp->fd);
#endif


	/* wait for the forked process */
#ifndef _WIN32
	while ((rpid = wait(&retcode)) != run_rtp->pid && rpid != -1)
	    pr_wait_status(retcode);
#else
	WaitForSingleObject( run_rtp->hProcess, INFINITE );
	if(GetLastError() == ERROR_PROCESS_ABORTED) {
	    run_rtp->aborted = 1;
	}
#endif

	aborted = run_rtp->aborted;

	/* free run_rtp */
	BU_LIST_DEQUEUE(&run_rtp->l);
	bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");

	if (aborted)
	    bu_log("Raytrace aborted.\n");
	else
	    bu_log("Raytrace complete.\n");
	return;
    }

    line[count] = '\0';

    /*XXX For now just blather to stderr */
    bu_log("%s", line);
}


static void
rt_set_eye_model(fastf_t *eye_model)
{
    if(dmp->dm_zclip || mged_variables->mv_perspective_mode){
	vect_t temp;

	VSET( temp, 0.0, 0.0, 1.0 );
	MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, temp);
    }else{ /* not doing zclipping, so back out of geometry */
	register struct solid *sp;
	register int i;
	double  t;
	double  t_in;
	vect_t  direction;
	vect_t  extremum[2];
	vect_t  minus, plus;    /* vers of this solid's bounding box */

	VSET(eye_model, -view_state->vs_vop->vo_center[MDX],
	     -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);

	for (i = 0; i < 3; ++i){
	    extremum[0][i] = INFINITY;
	    extremum[1][i] = -INFINITY;
	}
	FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid){
	    minus[X] = sp->s_center[X] - sp->s_size;
	    minus[Y] = sp->s_center[Y] - sp->s_size;
	    minus[Z] = sp->s_center[Z] - sp->s_size;
	    VMIN( extremum[0], minus );
	    plus[X] = sp->s_center[X] + sp->s_size;
	    plus[Y] = sp->s_center[Y] + sp->s_size;
	    plus[Z] = sp->s_center[Z] + sp->s_size;
	    VMAX( extremum[1], plus );
	}
	VMOVEN(direction, view_state->vs_vop->vo_rotation + 8, 3);
	VSCALE(direction, direction, -1.0);
	for(i = 0; i < 3; ++i)
	    if (NEAR_ZERO(direction[i], 1e-10))
		direction[i] = 0.0;
	if ((eye_model[X] >= extremum[0][X]) &&
	    (eye_model[X] <= extremum[1][X]) &&
	    (eye_model[Y] >= extremum[0][Y]) &&
	    (eye_model[Y] <= extremum[1][Y]) &&
	    (eye_model[Z] >= extremum[0][Z]) &&
	    (eye_model[Z] <= extremum[1][Z])){
	    t_in = -INFINITY;
	    for(i = 0; i < 6; ++i){
		if (direction[i%3] == 0)
		    continue;
		t = (extremum[i/3][i%3] - eye_model[i%3]) /
		    direction[i%3];
		if ((t < 0) && (t > t_in))
		    t_in = t;
	    }
	    VJOIN1(eye_model, eye_model, t_in, direction);
	}
    }
}


#ifndef _WIN32
/**
 *			R U N _ R T
 */
int
run_rt(void)
{
    register struct solid *sp;
    register int i;
    FILE *fp_in;
    int pipe_in[2];
    int pipe_err[2];
    vect_t eye_model;
    int		pid;
    struct run_rt	*run_rtp;

    if (strlen(rt_cmd_vec[0]) <= 0) {
	return -1;
    }

    (void)pipe( pipe_in );
    (void)pipe( pipe_err );
    (void)signal( SIGINT, SIG_IGN );
    if ((pid = fork()) == 0) {
	/* make this a process group leader */
	setpgid(0, 0);

	/* Redirect stdin and stderr */
	(void)close(0);
	(void)dup( pipe_in[0] );
	(void)close(2);
	(void)dup ( pipe_err[1] );

	/* close pipes */
	(void)close(pipe_in[0]);
	(void)close(pipe_in[1]);
	(void)close(pipe_err[0]);
	(void)close(pipe_err[1]);

	for( i=3; i < 20; i++ )
	    (void)close(i);

	(void)signal( SIGINT, SIG_DFL );
	(void)execvp( rt_cmd_vec[0], rt_cmd_vec );
	perror( rt_cmd_vec[0] );
	bu_exit(16, NULL);
    }

    /* As parent, send view information down pipe */
    (void)close( pipe_in[0] );
    fp_in = fdopen( pipe_in[1], "w" );

    (void)close( pipe_err[1] );

    rt_set_eye_model(eye_model);
    rt_write(fp_in, eye_model);
    (void)fclose( fp_in );

    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
	sp->s_wflag = DOWN;

    BU_GETSTRUCT(run_rtp, run_rt);
    BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
    run_rtp->fd = pipe_err[0];
    run_rtp->pid = pid;

    Tcl_CreateFileHandler(run_rtp->fd, TCL_READABLE,
			  rt_output_handler, (ClientData)run_rtp);

    return 0;
}
#else
int
run_rt(void)
{
    register struct solid *sp;
    register int i;
    FILE *fp_in;
    HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
    HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
    vect_t eye_model;
    struct run_rt	*run_rtp;

    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char line[RT_MAXLINE+1] = {0};
    char name[2048] = {0};

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

    /* Save the handle to the current STDOUT. */
    hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);

    /* Create a pipe for the child process's STDOUT. */
    CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

    /* Set a write handle to the pipe to be STDOUT. */
    SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);

    /* Create noninheritable read handle and close the inheritable read handle. */
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
		     GetCurrentProcess(),  &pipe_errDup ,
		     0,  FALSE,
		     DUPLICATE_SAME_ACCESS );
    CloseHandle( pipe_err[0] );

    /* The steps for redirecting child process's STDIN:
     *     1.  Save current STDIN, to be restored later.
     *     2.  Create anonymous pipe to be STDIN for child process.
     *     3.  Set STDIN of the parent to be the read handle to the
     *         pipe, so it is inherited by the child process.
     *     4.  Create a noninheritable duplicate of the write handle,
     *         and close the inheritable write handle.
     */

    /* Save the handle to the current STDIN. */
    hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);

    /* Create a pipe for the child process's STDIN. */
    CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
    /* Set a read handle to the pipe to be STDIN. */
    SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
    /* Duplicate the write handle to the pipe so it is not inherited. */
    DuplicateHandle(GetCurrentProcess(), pipe_in[1],
		    GetCurrentProcess(), &pipe_inDup,
		    0, FALSE,                  /* not inherited */
		    DUPLICATE_SAME_ACCESS );
    CloseHandle(pipe_in[1]);


    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;
    si.lpDesktop = NULL;
    si.dwFlags = 0;
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput   = pipe_in[0];
    si.hStdOutput  = pipe_err[1];
    si.hStdError   = pipe_err[1];


    snprintf(line, RT_MAXLINE+1, "%s ",rt_cmd_vec[0]);
    for(i=1;i<rt_cmd_vec_len;i++) {
	snprintf(name, 2048, "%s ",rt_cmd_vec[i]);
	strncat(line, name, RT_MAXLINE-strlen(line));
	line[2048-1] = '\0'; /* sanity */
    }


    if(CreateProcess( NULL,
		      line,
		      NULL,
		      NULL,
		      TRUE,
		      DETACHED_PROCESS,
		      NULL,
		      NULL,
		      &si,
		      &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStderr);
    }


    /* As parent, send view information down pipe */
    CloseHandle(pipe_in[0]);
    fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
    CloseHandle(pipe_err[1]);


    rt_set_eye_model(eye_model);
    rt_write(fp_in, eye_model);
    (void)fclose( fp_in );

    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
	sp->s_wflag = DOWN;

    BU_GETSTRUCT(run_rtp, run_rt);
    BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
    run_rtp->fd = pipe_errDup;
    run_rtp->hProcess = pi.hProcess;
    run_rtp->pid = pi.dwProcessId;
    run_rtp->aborted=0;

    run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
    Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			     rt_output_handler, (ClientData)run_rtp);

    return 0;
}
#endif


/**
 *  C M D _ R T
 */
int
cmd_rt(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
    char *ptr, buf[256] = {0};

    CHECK_DBI_NULL;

    /* skip past _mged_ */
    if (argv[0][0] == '_' && argv[0][1] == 'm' &&
	strncmp(argv[0], "_mged_", 6) == 0)
	argv[0] += 6;

    ptr = bu_brlcad_root("bin", 1);
    if (ptr) {
#ifdef _WIN32
	snprintf(buf, 256, "\"%s/%s\"", ptr, argv[0]);
#else
	snprintf(buf, 256, "%s/%s", ptr, argv[0]);
#endif
	argv[0] = buf;
    }

    return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
}


/**
 *  C M D _ R R T
 *
 *  Invoke any program with the current view & stuff, just like
 *  an "rt" command (above).
 *  Typically used to invoke a remote RT (hence the name).
 */
int
cmd_rrt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    register char **vp;
    register int i;

    CHECK_DBI_NULL;

    if(argc < 2 || MAXARGS < argc){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help rrt");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if( not_state( ST_VIEW, "Ray-trace of current view" ) )
	return TCL_ERROR;

    vp = &rt_cmd_vec[0];
    for( i=1; i < argc; i++ )
	*vp++ = argv[i];
    *vp++ = dbip->dbi_filename;

    setup_rt( vp, 1 );
    (void)run_rt();

    return TCL_OK;
}

#if 0
static void
rtcheck_vector_handler(ClientData clientData, int mask)
{
    int value;
    struct solid *sp;
    struct rtcheck *rtcp = (struct rtcheck *)clientData;

    /* Get vector output from rtcheck */
    if ((value = getc(rtcp->fp)) == EOF) {
	int retcode;
	int rpid;

	Tcl_DeleteFileHandler(rtcp->fd);
	fclose(rtcp->fp);

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
	    sp->s_wflag = DOWN;

	/* Add overlay */
	cvt_vlblock_to_solids( rtcp->vbp, "OVERLAPS", 0 );
	rt_vlblock_free(rtcp->vbp);

	/* wait for the forked process */
	while ((rpid = wait(&retcode)) != rtcp->pid && rpid != -1)
	    pr_wait_status(retcode);

	/* free rtcp */
	bu_free((genptr_t)rtcp, "rtcheck_vector_handler: rtcp");

	update_views = 1;
	return;
    }

    (void)rt_process_uplot_value( &rtcp->vhead,
				  rtcp->vbp,
				  rtcp->fp,
				  value,
				  rtcp->csize );
}

static void
rtcheck_output_handler(ClientData clientData, int mask)
{
    int count;
    char line[RT_MAXLINE+1] = {0};
    int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */

    /* Get textual output from rtcheck */
    count = read((int)fd, line, RT_MAXLINE-1);
    if (count <= 0) {
	if (count < 0) {
	    perror("READ ERROR");
	}
	Tcl_DeleteFileHandler(fd);
	close(fd);
	return;
    }

    line[count] = '\0';
    bu_log("%s", line);
}
#endif


/**
 *  C M D _ R T C H E C K
 *
 *  Run rtcheck command on the current view.
 */
int
cmd_rtcheck(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
    char *ptr, buf[256] = {0};
    CHECK_DBI_NULL;

    ptr = bu_brlcad_root("bin", 1);
    if (ptr) {
#ifdef _WIN32
	snprintf(buf, 256, "\"%s/%s\"", ptr, argv[0]);
#else
	snprintf(buf, 256, "%s/%s", ptr, argv[0]);
#endif
	argv[0] = buf;
    }

    return dgo_rtcheck_cmd(dgop, view_state->vs_vop, interp, argc, argv);
}


/**
 *  C M D _ R T A R E A
 *
 *  Run rtarea command on the current view.
 */
int
cmd_rtarea(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char	**argv)
{
    char *ptr, buf[256] = {0};
    CHECK_DBI_NULL;

    ptr = bu_brlcad_root("bin", 1);
    if (ptr) {
#ifdef _WIN32
	snprintf(buf, 256, "\"%s/%s\"", ptr, argv[0]);
#else
	snprintf(buf, 256, "%s/%s", ptr, argv[0]);
#endif
	argv[0] = buf;
    }

    return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
}


/**
 *  C M D _ R T E D G E
 *
 *  Run rtedge command on the current view.
 */
int
cmd_rtedge(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char	**argv)
{
    char *ptr, buf[256] = {0};
    CHECK_DBI_NULL;

    ptr = bu_brlcad_root("bin", 1);
    if (ptr) {
#ifdef _WIN32
	snprintf(buf, 256, "\"%s/%s\"", ptr, argv[0]);
#else
	snprintf(buf, 256, "%s/%s", ptr, argv[0]);
#endif
	argv[0] = buf;
    }

    return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
}


/**
 *  C M D _ R T W E I G H T
 *
 *  Run rtweight command on the current view.
 */
int
cmd_rtweight(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
    char *ptr, buf[256] = {0};
    CHECK_DBI_NULL;

    ptr = bu_brlcad_root("bin", 1);
    if (ptr) {
#ifdef _WIN32
	snprintf(buf, 256, "\"%s/%s\"", ptr, argv[0]);
#else
	snprintf(buf, 256, "%s/%s", ptr, argv[0]);
#endif
	argv[0] = buf;
    }

    return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
}


/**
 *			B A S E N A M E
 *
 *  Return basename of path, removing leading slashes and trailing suffix.
 */
HIDDEN char *
basename_without_suffix(register char *p1, register char *suff)
{
    register char *p2, *p3;
    static char buf[128];

    p2 = p1;
    while (*p1) {
	if (*p1++ == '/')
	    p2 = p1;
    }
    for(p3=suff; *p3; p3++)
	;
    while(p1>p2 && p3>suff)
	if(*--p3 != *--p1)
	    return(p2);
    strncpy( buf, p2, p1-p2 );
    return(buf);
}


/**
 *			F _ S A V E V I E W
 *
 *  Create a shell script to ray-trace this view.
 *  Any arguments to this command are passed as arguments to RT
 *  in the generated shell script
 */
int
f_saveview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    register struct solid *sp;
    register int i;
    register FILE *fp;
    char *base;

    CHECK_DBI_NULL;

    if(argc < 2){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help saveview");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if( (fp = fopen( argv[1], "a")) == NULL )  {
	perror(argv[1]);
	return TCL_ERROR;
    }

    if (!dbip->dbi_filename) {
	bu_log("Error: geometry file is not specified\n");
	return TCL_ERROR;
    }

    if (!bu_file_exists(dbip->dbi_filename)) {
	bu_log("Error: %s does not exist\n", dbip->dbi_filename);
	return TCL_ERROR;
    }

    base = basename_without_suffix( argv[1], ".sh" );
    (void)bu_fchmod(argv[1], fp, 0755);	/* executable */

    /* Do not specify -v option to rt; batch jobs must print everything. -Mike */
    (void)fprintf(fp, "#!/bin/sh\nrt -M ");
    if( view_state->vs_vop->vo_perspective > 0 )
	(void)fprintf(fp, "-p%g ", view_state->vs_vop->vo_perspective);
    for( i=2; i < argc; i++ )
	(void)fprintf(fp,"%s ", argv[i]);
    (void)fprintf(fp,"\\\n -o %s.pix\\\n $*\\\n", base);
    (void)fprintf(fp," %s\\\n ", dbip->dbi_filename);

    /* Find all unique top-level entries.
     *  Mark ones already done with s_wflag == UP
     */
    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
	sp->s_wflag = DOWN;
    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
	register struct solid *forw;	/* XXX */
	struct directory *dp = FIRST_SOLID(sp);

	if( sp->s_wflag == UP )
	    continue;
	if (dp->d_addr == RT_DIR_PHONY_ADDR) continue;
	(void)fprintf(fp, "'%s' ", dp->d_namep);
	sp->s_wflag = UP;
	for(BU_LIST_PFOR(forw, sp, solid, &dgop->dgo_headSolid)){
	    if( FIRST_SOLID(forw) == dp )
		forw->s_wflag = UP;
	}
    }
    (void)fprintf(fp,"\\\n 2>> %s.log\\\n", base);
    (void)fprintf(fp," <<EOF\n");

    {
	vect_t eye_model;

	rt_set_eye_model(eye_model);
	rt_write(fp, eye_model);
    }

    (void)fprintf(fp,"\nEOF\n");
    (void)fclose( fp );

    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
	sp->s_wflag = DOWN;

    return TCL_OK;
}


/**
 *			F _ L O A D V I E W
 *
 *  Load a ray-trace view shell script.  If a database is not open, the
 *  database listed in the script will attempted to be opened.  If a
 *  database is open, it must match (inode) the one in the saveview
 *  raytrace script for it to get used.
 *
 *  The actual raytrace functionality is ignored in scripts -- only the view
 *  is intended to be restored, if possible.
 */
int
f_loadview(ClientData clientData, Tcl_Interp *interp, int argc, char *argv[])
{
    register FILE *fp;
    char buffer[512] = {0};

    /* data pulled from script file */
    int perspective=-1;
#define MAX_DBNAME	2048
    char dbName[MAX_DBNAME] = {0};
    char objects[10000] = {0};
    char *editArgv[3];

    /* save previous interactive state */
    int prevInteractive = interactive;
    int prevPerspective =  mged_variables->mv_perspective;

#if 0
    /* for view orientation */
    vect_t xlate;
    mat_t new_cent;

    double viewsize;
    double orientation[4]={0.0, 0.0, 0.0, 0.0};
    vect_t eye_pt={0.0, 0.0, 0.0};
#endif

    /* We do not need to check *here* if a database is open, since we will be
     * loading one anyways.  we manually check when/if we find the database name.
     */
    /*	CHECK_DBI_NULL; */

    if(argc < 2){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help loadview");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    /* make sure the file exists */
    if (!bu_file_exists(argv[1])) {
	bu_log("Error: File %s does not exist\n", argv[1]);
	return TCL_ERROR;
    }

    /* open the file for reading */
    if ( (fp = fopen( argv[1], "r" )) == NULL ) {
	perror(argv[1]);
	return TCL_ERROR;
    }

    /* turn perspective mode off, by default.  A "-p" option in the
     * view script will turn it back on.
     */
    mged_variables->mv_perspective=-1;
    set_perspective();

    /* iterate over the contents of the raytrace script */
    while (!feof(fp)) {
	memset(buffer, 0, 512);
	fscanf(fp, "%512s", buffer);

	if (strncmp(buffer, "-p", 2)==0) {
	    /* we found perspective */

	    buffer[0]=' ';
	    buffer[1]=' ';
	    sscanf(buffer, "%d", &perspective);
	    /*      bu_log("perspective=%d\n", perspective);*/
	    mged_variables->mv_perspective=perspective;
	    /* !!! this does not update the menu variable.. */
	    set_perspective();

	} else if (strncmp(buffer, "$*", 2)==0) {
	    /* the next read is the file name, the objects come
	     * after that
	     */

	    memset(dbName, 0, MAX_DBNAME);
	    fscanf(fp, "%2048s", dbName); /* MAX_DBNAME */

	    /* if the last character is a line termination,
	     * remove it (it should always be unless the user
	     * modifies the file)
	     */
	    if ( *(dbName + strlen(dbName) - 1)=='\\' ) {
		memset(dbName+strlen(dbName)-1, 0, 1);
	    }
	    /*      bu_log("dbName=%s\n", dbName); */

	    /* if no database is open, we attempt to open the
	     * database listed in the script.  if a database is
	     * open, we compare the open database's inode number
	     * with the inode of the database listed in the script.
	     * If they match, we may proceed. otherwise we need
	     * to abort since the wrong database would be open.
	     */
	    if ( dbip == DBI_NULL ) {
		/* load the database */

		/* XXX could use better path handling instead of
		 * assuming rooted or . */

		/* turn off interactive mode so the f_opendb() call
		 * doesn't blather or attempt to create a new database
		 */
		interactive=0;
		editArgv[0]="";
		editArgv[1]=dbName;
		editArgv[2]=(char *)NULL;
		if (f_opendb( (ClientData)NULL, interp, 2, editArgv ) == TCL_ERROR) {
		    Tcl_AppendResult(interp, "Unable to load database: ", dbName, "\n", (char *)NULL);

		    /* restore state before leaving */
		    mged_variables->mv_perspective=prevPerspective;
		    set_perspective();

		    return TCL_ERROR;
		} else {
		    Tcl_AppendResult(interp, "Loading database: ", dbName, "\n", (char *)NULL);
		}
		interactive=prevInteractive;

	    } else {
		/* database is already open - compare inode numbers */
		if (!bu_same_file(dbip->dbi_filename, dbName)) {
		    /* stop here if they are not the same file,
		     * otherwise, we may proceed as expected, and load
		     * the objects.
		     */
		    Tcl_AppendResult(interp, "View script references a different database\nCannot load the view without closing the current database\n(i.e. run \"opendb ", dbName, "\")\n", (char *)NULL);

		    /* restore state before leaving */
		    mged_variables->mv_perspective=prevPerspective;
		    set_perspective();

		    return TCL_ERROR;
		}

	    }
	    /* end check for loaded database */

	    /* get rid of anything that may be displayed, since we
	     * will load objects that are listed in the script next.
	     */
	    (void)cmd_zap( (ClientData)NULL, interp, 1, NULL );

	    /* now get the objects listed */
	    fscanf(fp, "%10000s", objects);
	    /*		  bu_log("OBJECTS=%s\n", objects);*/
	    while ((!feof(fp)) && (strncmp(objects, "\\", 1)!=0)) {

		/* clean off the single quotes... */
		if (strncmp(objects, "'", 1)==0) {
		    objects[0]=' ';
		    memset(objects+strlen(objects)-1, ' ', 1);
		    sscanf(objects, "%10000s", objects);
		}

		editArgv[0] = "e";
		editArgv[1] = objects;
		editArgv[2] = (char *)NULL;
		if (edit_com( 2, editArgv, 1, 1 ) != 0) {
		    Tcl_AppendResult(interp, "Unable to load object: ", objects, "\n", (char *)NULL);
		}

		/* bu_log("objects=%s\n", objects);*/
		fscanf(fp, "%10000s", objects);
	    }

	    /* end iteration over reading in listed objects */
	} else if (strncmp(buffer, "<<EOF", 5)==0) {
	    char *cmdBuffer = NULL;
	    /* we are almost done .. read in the view commands */

	    while ( (cmdBuffer = rt_read_cmd( fp )) != NULL ) {
		/* even unsupported commands should return successfully as
		 * they should be calling cm_null()
		 */
		if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) {
		    Tcl_AppendResult(interp, "command failed: ", cmdBuffer, "\n", (char *)NULL);
		}
		bu_free( (genptr_t)cmdBuffer, "loadview cmdBuffer" );
	    }
	    /* end iteration over rt commands */

	}
	/* end check for non-view values (dbname, etc) */

    }
    /* end iteration over file until eof */
    fclose(fp);

    /* now we have to finish the eye point calculations that usually get
     * postponed until the end command runs.  Since we are at the "end"
     * of a commands section, we may finish the computations.
     */
    /* First step:  put eye at view center (view 0,0,0) */
    MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
    MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, rtif_eye_model);
    new_mats(); /* actually updates display here (maybe?) */

    /* XXX not sure why the correction factor is needed, but it works -- csm */
    /*  Second step:  put eye at view 0,0,1.
     *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
     VSET(xlate, 0.0, 0.0, -1.0);
     MAT4X3PNT(new_cent, view_state->vs_vop->vo_view2model, xlate);
     MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, new_cent);
     new_mats();
    */

    /* update the view next time through the event loop */
    update_views = 1;

    return TCL_OK;
}


/**
 *			F _ R M A T S
 *
 * Load view matrixes from a file.  rmats filename [mode]
 *
 * Modes:
 *	-1	put eye in viewcenter (default)
 *	0	put eye in viewcenter, don't rotate.
 *	1	leave view alone, animate solid named "EYE"
 */
int
f_rmats(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    register FILE *fp;
    register struct directory *dp;
    register struct solid *sp;
    vect_t	eye_model;
    vect_t	xlate;
    vect_t	sav_center;
    vect_t	sav_start;
    int	mode;
    fastf_t	scale;
    mat_t	rot;
    register struct bn_vlist *vp;

    CHECK_DBI_NULL;

    if(argc < 2 || 3 < argc){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help rmats");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if( not_state( ST_VIEW, "animate from matrix file") )
	return TCL_ERROR;

    if( (fp = fopen(argv[1], "r")) == NULL )  {
	perror(argv[1]);
	return TCL_ERROR;
    }

    sp = SOLID_NULL;

    mode = -1;
    if( argc > 2 )
	mode = atoi(argv[2]);
    switch(mode)  {
	case 1:
	    if( (dp = db_lookup(dbip, "EYE", LOOKUP_NOISY)) == DIR_NULL )  {
		mode = -1;
		break;
	    }
	    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		if( LAST_SOLID(sp) != dp )  continue;
		if( BU_LIST_IS_EMPTY( &(sp->s_vlist) ) )  continue;
		vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
		VMOVE( sav_start, vp->pt[vp->nused-1] );
		VMOVE( sav_center, sp->s_center );
		Tcl_AppendResult(interp, "animating EYE solid\n", (char *)NULL);
		goto work;
	    }
	    /* Fall through */
	default:
	case -1:
	    mode = -1;
	    Tcl_AppendResult(interp, "default mode:  eyepoint at (0,0,1) viewspace\n", (char *)NULL);
	    break;
	case 0:
	    Tcl_AppendResult(interp, "rotation supressed, center is eyepoint\n", (char *)NULL);
	    break;
    }
 work:
#if 0
    /* If user hits ^C, this will stop, but will leave hanging filedes */
    (void)signal(SIGINT, cur_sigint);
#else
    if( setjmp( jmp_env ) == 0 )
	(void)signal( SIGINT, sig3);  /* allow interupts */
    else
	return TCL_OK;
#endif
    while( !feof( fp ) &&
	   rt_read( fp, &scale, eye_model, rot ) >= 0 )  {
	switch(mode)  {
	    case -1:
		/* First step:  put eye in center */
		view_state->vs_vop->vo_scale = scale;
		MAT_COPY(view_state->vs_vop->vo_rotation, rot);
		MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, eye_model);
		new_mats();
		/* Second step:  put eye in front */
		VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
		MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, xlate);
		MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, eye_model);
		new_mats();
		break;
	    case 0:
		view_state->vs_vop->vo_scale = scale;
		MAT_IDN(view_state->vs_vop->vo_rotation);	/* top view */
		MAT_DELTAS_VEC_NEG( view_state->vs_vop->vo_center, eye_model);
		new_mats();
		break;
	    case 1:
		/* Adjust center for displaylist devices */
		VMOVE( sp->s_center, eye_model );

		/* Adjust vector list for non-dl devices */
		if( BU_LIST_IS_EMPTY( &(sp->s_vlist) ) )  break;
		vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
		VSUB2( xlate, eye_model, vp->pt[vp->nused-1] );
		for( BU_LIST_FOR( vp, bn_vlist, &(sp->s_vlist) ) )  {
		    register int	i;
		    register int	nused = vp->nused;
		    register int	*cmd = vp->cmd;
		    register point_t *pt = vp->pt;
		    for( i = 0; i < nused; i++,cmd++,pt++ )  {
			switch( *cmd )  {
			    case BN_VLIST_POLY_START:
			    case BN_VLIST_POLY_VERTNORM:
				break;
			    case BN_VLIST_LINE_MOVE:
			    case BN_VLIST_LINE_DRAW:
			    case BN_VLIST_POLY_MOVE:
			    case BN_VLIST_POLY_DRAW:
			    case BN_VLIST_POLY_END:
				VADD2( *pt, *pt, xlate );
				break;
			}
		    }
		}
		break;
	}
	view_state->vs_flag = 1;
	refresh();	/* Draw new display */
    }
    if( mode == 1 )  {
	VMOVE( sp->s_center, sav_center );
	if( BU_LIST_NON_EMPTY( &(sp->s_vlist) ) )  {
	    vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
	    VSUB2( xlate, sav_start, vp->pt[vp->nused-1] );
	    for( BU_LIST_FOR( vp, bn_vlist, &(sp->s_vlist) ) )  {
		register int	i;
		register int	nused = vp->nused;
		register int	*cmd = vp->cmd;
		register point_t *pt = vp->pt;
		for( i = 0; i < nused; i++,cmd++,pt++ )  {
		    switch( *cmd )  {
			case BN_VLIST_POLY_START:
			case BN_VLIST_POLY_VERTNORM:
			    break;
			case BN_VLIST_LINE_MOVE:
			case BN_VLIST_LINE_DRAW:
			case BN_VLIST_POLY_MOVE:
			case BN_VLIST_POLY_DRAW:
			case BN_VLIST_POLY_END:
			    VADD2( *pt, *pt, xlate );
			    break;
		    }
		}
	    }
	}
    }

    fclose(fp);
    (void)mged_svbase();

    (void)signal( SIGINT, SIG_IGN );
    return TCL_OK;
}


/**
 * Save a keyframe to a file
 */
int
f_savekey(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    register FILE *fp;
    fastf_t	time;
    vect_t	eye_model;
    vect_t temp;

    if(argc < 2 || 3 < argc){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help savekey");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if( (fp = fopen( argv[1], "a")) == NULL )  {
	perror(argv[1]);
	return TCL_ERROR;
    }
    if( argc > 2 ) {
	time = atof( argv[2] );
	(void)fprintf(fp,"%f\n", time);
    }
    /*
     *  Eye is in conventional place.
     */
    VSET( temp, 0.0, 0.0, 1.0 );
    MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, temp);
    rt_oldwrite(fp, eye_model);
    (void)fclose( fp );

    return TCL_OK;
}

extern int	cm_start(int argc, char **argv);
extern int	cm_vsize(int argc, char **argv);
extern int	cm_eyept(int argc, char **argv);
extern int	cm_lookat_pt(int argc, char **argv);
extern int	cm_vrot(int argc, char **argv);
extern int	cm_end(int argc, char **argv);
extern int	cm_multiview(int argc, char **argv);
extern int	cm_anim(int argc, char **argv);
extern int	cm_tree(int argc, char **argv);
extern int	cm_clean(int argc, char **argv);
extern int	cm_set(int argc, char **argv);
extern int	cm_orientation(int argc, char **argv);

/**
 * table of commands supported by the preview command
 */
static struct command_tab cmdtab[] = {
    {"start", "frame number", "start a new frame",
     cm_start,	2, 2},
    {"viewsize", "size in mm", "set view size",
     cm_vsize,	2, 2},
    {"eye_pt", "xyz of eye", "set eye point",
     cm_eyept,	4, 4},
    {"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
     cm_lookat_pt,	4, 5},
    {"orientation", "quaturnion", "set view direction from quaturnion",
     cm_orientation,	5, 5},
    {"viewrot", "4x4 matrix", "set view direction from matrix",
     cm_vrot,	17,17},
    {"end", 	"", "end of frame setup, begin raytrace",
     cm_end,		1, 1},
    {"multiview", "", "produce stock set of views",
     cm_multiview,	1, 1},
    {"anim", 	"path type args", "specify articulation animation",
     cm_anim,	4, 999},
    {"tree", 	"treetop(s)", "specify alternate list of tree tops",
     cm_tree,	1, 999},
    {"clean", "", "clean articulation from previous frame",
     cm_clean,	1, 1},
    {"set", 	"", "show or set parameters",
     cm_set,		1, 999},
    {"ae", "azim elev", "specify view as azim and elev, in degrees",
     cm_null,		3, 3},
    {"opt", "-flags", "set flags, like on command line",
     cm_null,		2, 999},
    {(char *)0, (char *)0, (char *)0,
     0,		0, 0}	/* END */
};


/**
 *			R T I F _ S I G I N T
 *
 *  Called on SIGINT from within preview.
 *  Close things down and abort.
 *
 *  WARNING:  If the ^C happened when bu_free() had already done a bu_semaphore_acquire,
 *  then any further calls to bu_free() will hang.
 *  It isn't clear how to handle this.
 */
static void
rtif_sigint(int num)
{
    if(dbip == DBI_NULL)
	return;

    write( 2, "rtif_sigint\n", 12);

    /* Restore state variables */
    *mged_variables = rtif_saved_state;	/* struct copy */

    if(rtif_vbp)  {
	rt_vlblock_free(rtif_vbp);
	rtif_vbp = (struct bn_vlblock *)NULL;
    }
    db_free_anim(dbip);	/* Forget any anim commands */
    sig3(num);			/* Call main SIGINT handler */
    /* NOTREACHED */
}


/**
 *			F _ P R E V I E W
 *
 *  Preview a new style RT animation scrtip.
 *  Note that the RT command parser code is used, rather than the
 *  MGED command parser, because of the differences in format.
 *  The RT parser expects command handlers of the form "cm_xxx()",
 *  and all communications are done via global variables.
 *
 *  For the moment, the only preview mode is the normal one,
 *  moving the eyepoint as directed.
 *  However, as a bonus, the eye path is left behind as a vector plot.
 */
int
f_preview(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    char	*cmd;
    int	c;
    vect_t	temp;

    CHECK_DBI_NULL;

    if(argc < 2){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help preview");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if( not_state( ST_VIEW, "animate viewpoint from new RT file") )
	return TCL_ERROR;

    /* Save any state variables we plan on changing */
    rtif_saved_state = *mged_variables;	/* struct copy */
    mged_variables->mv_autosize = 0;

    rtif_delay = 0;			/* Full speed, by default */
    rtif_mode = 1;			/* wireframe drawing */
    rtif_desiredframe = 0;
    rtif_finalframe = 0;

    /* Parse options */
    bu_optind = 1;			/* re-init bu_getopt() */
    while( (c=bu_getopt(argc,argv,"d:vD:K:")) != EOF )  {
	switch(c)  {
	    case 'd':
		rtif_delay = atof(bu_optarg);
		break;
	    case 'D':
		rtif_desiredframe = atof(bu_optarg);
		break;
	    case 'K':
		rtif_finalframe = atof(bu_optarg);
		break;
	    case 'v':
		rtif_mode = 3;	/* Like "ev" */
		break;
	    default:
		{
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "option '%c' unknown\n", c);
		    bu_vls_printf(&tmp_vls, "        -d#     inter-frame delay\n");
		    bu_vls_printf(&tmp_vls, "        -v      polygon rendering (visual)\n");
		    bu_vls_printf(&tmp_vls, "        -D#     desired starting frame\n");
		    bu_vls_printf(&tmp_vls, "        -K#     final frame\n");
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		}

		break;
	}
    }
    argc -= bu_optind-1;
    argv += bu_optind-1;

    /* If file is still open from last cmd getting SIGINT, close it */
    if(rtif_fp)  fclose(rtif_fp);
    if( (rtif_fp = fopen(argv[1], "r")) == NULL )  {
	perror(argv[1]);
	return TCL_ERROR;
    }

    /* Build list of top-level objects in view, in rt_cmd_vec[] */
    rt_cmd_vec[0] = "tree";
    setup_rt( &rt_cmd_vec[1], 1 );

    rtif_vbp = rt_vlblock_init();

    Tcl_AppendResult(interp, "eyepoint at (0,0,1) viewspace\n", (char *)NULL);

    /*
     *  Initialize the view to the current one in MGED
     *  in case a view specification is never given.
     */
    MAT_COPY(rtif_viewrot, view_state->vs_vop->vo_rotation);
    VSET(temp, 0.0, 0.0, 1.0);
    MAT4X3PNT(rtif_eye_model, view_state->vs_vop->vo_view2model, temp);

    if( setjmp( jmp_env ) == 0 )
	/* If user hits ^C, preview will stop, and clean up */
	(void)signal(SIGINT, rtif_sigint);
    else
	return TCL_OK;

    while( ( cmd = rt_read_cmd( rtif_fp )) != NULL )  {
	/* Hack to prevent running framedone scripts prematurely */
	if( cmd[0] == '!' )  {
	    if( rtif_currentframe < rtif_desiredframe ||
		(rtif_finalframe && rtif_currentframe > rtif_finalframe) )  {
		bu_free( (genptr_t)cmd, "preview ! cmd" );
		continue;
	    }
	}
	if( rt_do_cmd( (struct rt_i *)0, cmd, cmdtab ) < 0 )
	    Tcl_AppendResult(interp, "command failed: ", cmd,
			     "\n", (char *)NULL);
	bu_free( (genptr_t)cmd, "preview cmd" );
    }
    fclose(rtif_fp);
    rtif_fp = NULL;

    cvt_vlblock_to_solids( rtif_vbp, "EYE_PATH", 0 );
    if(rtif_vbp)  {
	rt_vlblock_free(rtif_vbp);
	rtif_vbp = (struct bn_vlblock *)NULL;
    }
    db_free_anim(dbip);	/* Forget any anim commands */

    /* Restore state variables */
    *mged_variables = rtif_saved_state;	/* struct copy */

    (void)mged_svbase();

    (void)signal( SIGINT, SIG_IGN );
    return TCL_OK;
}


/**
 *			F _ N I R T
 *
 *  Invoke nirt with the current view & stuff
 */
int
f_nirt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
#if 1
    char *ptr, buf[256];
    CHECK_DBI_NULL;

    ptr = bu_brlcad_root("bin", 1);
    if (ptr) {
#  ifdef _WIN32
	snprintf(buf, 256, "\"%s/%s\"", ptr, argv[0]);
#  else
	snprintf(buf, 256, "%s/%s", ptr, argv[0]);
#  endif
	argv[0] = buf;
    }


    return dgo_nirt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
#else
    register char **vp;
    FILE *fp_in;
    FILE *fp_out, *fp_err;
    int pid;
    int rpid;
    int retcode;
#  ifndef _WIN32
    int pipe_in[2] = {0, 0};
    int pipe_out[2] = {0, 0};
    int pipe_err[2] = {0, 0};
#  else
    HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
    HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
    HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SECURITY_ATTRIBUTES sa          = {0};
    char name[1024] = {0};
    char line1[2048] = {0};
#  endif
    int use_input_orig = 0;
    vect_t	center_model;
    vect_t dir;
    vect_t cml;
    register int i;
    register struct solid *sp;
    char line[RT_MAXLINE] = {0};
    char *val;
    struct bu_vls vls;
    struct bu_vls o_vls;
    struct bu_vls p_vls;
    struct bu_vls t_vls;
    struct bn_vlblock *vbp;
    struct qray_dataList *ndlp;
    struct qray_dataList HeadQRayData;
    char *ptr = (char *)NULL;
    char *buf[256];

    CHECK_DBI_NULL;

    if(argc < 1 || MAXARGS < argc){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
    }

    ptr = bu_brlcad_root("bin", 1);
    if (ptr) {
	/* argv[0] might be nirt or query_ray, so specify nirt
	 * specifically.
	 */
#  ifdef _WIN32
	snprintf(buf, 256, "\"%s/%s\"", ptr, "nirt");
#  else
	snprintf(buf, 256, "%s/%s", ptr, "nirt");
#  endif
	argv[0] = buf;
    }

    vp = &rt_cmd_vec[0];
    *vp++ = argv[0];

    /* swipe x, y, z off the end if present */
    if(argc > 3){
	if(sscanf(argv[argc-3], "%lf", &center_model[X]) == 1 &&
	   sscanf(argv[argc-2], "%lf", &center_model[Y]) == 1 &&
	   sscanf(argv[argc-1], "%lf", &center_model[Z]) == 1){
	    use_input_orig = 1;
	    argc -= 3;
	    VSCALE(center_model, center_model, local2base);
	}else if(adc_state->adc_draw)
	    *vp++ = "-b";
    }else if(adc_state->adc_draw)
	*vp++ = "-b";

    if(mged_variables->mv_use_air){
	*vp++ = "-u";
	*vp++ = "1";
    }

    /* Calculate point from which to fire ray */
    if(!use_input_orig && adc_state->adc_draw){
	vect_t  view_ray_orig;

	VSET(view_ray_orig, (fastf_t)adc_state->adc_dv_x, (fastf_t)adc_state->adc_dv_y, GED_MAX);
	VSCALE(view_ray_orig, view_ray_orig, INV_GED);
	MAT4X3PNT(center_model, view_state->vs_vop->vo_view2model, view_ray_orig);
    }else if(!use_input_orig){
	VSET(center_model, -view_state->vs_vop->vo_center[MDX],
	     -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);
    }

    if (mged_variables->mv_perspective_mode) {
	point_t pt, eye;

	/* get eye point */
	VSET(pt, 0.0, 0.0, 1.0);
	MAT4X3PNT(eye, view_state->vs_vop->vo_view2model, pt);
	VSCALE(eye, eye, base2local);

	/* point passed in is actually the aim point */
	VSCALE(cml, center_model, base2local);
	VSUB2(dir, cml, eye);
	VUNITIZE(dir);

	/* copy eye point to cml (cml is used for the "xyz" command to nirt */
	VMOVE(cml, eye);
    } else {
	VSCALE(cml, center_model, base2local);
	VMOVEN(dir, view_state->vs_vop->vo_rotation + 8, 3);
	VSCALE(dir, dir, -1.0);
    }

    bu_vls_init(&p_vls);
    bu_vls_printf(&p_vls, "xyz %lf %lf %lf;",
		  cml[X], cml[Y], cml[Z]);
    bu_vls_printf(&p_vls, "dir %lf %lf %lf; s",
		  dir[X], dir[Y], dir[Z]);

    i = 0;
    if(QRAY_GRAPHICS){

	*vp++ = "-e";
	*vp++ = QRAY_FORMAT_NULL;

	/* first ray  ---- returns partitions */
	*vp++ = "-e";
	*vp++ = QRAY_FORMAT_P;

	/* ray start, direction, and 's' command */
	*vp++ = "-e";
	*vp++ = bu_vls_addr(&p_vls);

	/* second ray  ---- returns overlaps */
	*vp++ = "-e";
	*vp++ = QRAY_FORMAT_O;

	/* ray start, direction, and 's' command */
	*vp++ = "-e";
	*vp++ = bu_vls_addr(&p_vls);

	if(QRAY_TEXT){
	    char *cp;
	    int count = 0;

	    bu_vls_init(&o_vls);

	    /* get 'r' format now; prepend its' format string with a newline */
	    val = bu_vls_addr(&qray_fmts[0].fmt);

	    /* find first '"' */
	    while(*val != '"' && *val != '\0')
		++val;

	    if(*val == '\0')
		goto done;
	    else
		++val;	    /* skip first '"' */

	    /* find last '"' */
	    cp = (char *)strrchr(val, '"');

	    if(cp != (char *)NULL) /* found it */
		count = cp - val;

	done:
	    if(*val == '\0') {
#ifndef _WIN32
		bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
#else
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
#endif
	    } else {
#ifndef _WIN32
		bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
#else
		bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
		if(count)
		    val += count + 1;
		bu_vls_printf(&o_vls, "%s", val);
	    }

	    i = 1;

	    *vp++ = "-e";
	    *vp++ = bu_vls_addr(&o_vls);
	}
    }

    if(QRAY_TEXT){

	bu_vls_init(&t_vls);

	/* load vp with formats for printing */
	for(; qray_fmts[i].type != (char)NULL; ++i)
	    bu_vls_printf(&t_vls, "fmt %c %s; ",
			  qray_fmts[i].type,
			  bu_vls_addr(&qray_fmts[i].fmt));

	*vp++ = "-e";
	*vp++ = bu_vls_addr(&t_vls);

	/* nirt does not like the trailing ';' */
	bu_vls_trunc(&t_vls, -2);
    }

    /* include nirt script string */
    if (bu_vls_strlen(&qray_script)) {
	*vp++ = "-e";
	*vp++ = bu_vls_addr(&qray_script);
    }

    *vp++ = "-e";
    *vp++ = bu_vls_addr(&p_vls);

    for( i=1; i < argc; i++ )
	*vp++ = argv[i];
#ifdef _WIN32
    {
	char buf[512];

	snprintf(buf, 512, "\"%s\"", dbip->dbi_filename);
	*vp++ = buf;
    }
#else
    *vp++ = dbip->dbi_filename;
#endif

    setup_rt( vp, qray_cmd_echo );

    if(use_input_orig){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "\nFiring from (%lf, %lf, %lf)...\n",
		      center_model[X], center_model[Y], center_model[Z]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
    } else if(adc_state->adc_draw) {
	Tcl_AppendResult(interp, "\nFiring through angle/distance cursor...\n",
			 (char *)NULL);
    } else {
	Tcl_AppendResult(interp, "\nFiring from view center...\n", (char *)NULL);
    }

#ifndef _WIN32
    (void)pipe( pipe_in );
    (void)pipe( pipe_out );
    (void)pipe( pipe_err );
    (void)signal( SIGINT, SIG_IGN );
    if ( ( pid = fork()) == 0 )  {
	/* Redirect stdin, stdout, stderr */
	(void)close(0);
	(void)dup( pipe_in[0] );
	(void)close(1);
	(void)dup( pipe_out[1] );
	(void)close(2);
	(void)dup ( pipe_err[1] );

	/* close pipes */
	(void)close(pipe_in[0]);
	(void)close(pipe_in[1]);
	(void)close(pipe_out[0]);
	(void)close(pipe_out[1]);
	(void)close(pipe_err[0]);
	(void)close(pipe_err[1]);
	for( i=3; i < 20; i++ )
	    (void)close(i);
	(void)signal( SIGINT, SIG_DFL );
	(void)execvp( rt_cmd_vec[0], rt_cmd_vec );
	perror( rt_cmd_vec[0] );
	bu_exit(16, NULL);
    }

    /* use fp_in to feed view info to nirt */
    (void)close( pipe_in[0] );
    fp_in = fdopen( pipe_in[1], "w" );

    /* use fp_out to read back the result */
    (void)close( pipe_out[1] );
    fp_out = fdopen( pipe_out[0], "r" );

    /* use fp_err to read any error messages */
    (void)close( pipe_err[1] );
    fp_err = fdopen( pipe_err[0], "r" );

    /* send quit command to nirt */
    fwrite( "q\n", 1, 2, fp_in );
    (void)fclose( fp_in );
#else
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

    /* Save the handle to the current STDOUT. */
    hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);

    /* Create a pipe for the child process's STDOUT. */
    CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

    /* Set a write handle to the pipe to be STDOUT. */
    SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);

    /* Create noninheritable read handle and close the inheritable read handle. */
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
		     GetCurrentProcess(),  &pipe_outDup ,
		     0,  FALSE,
		     DUPLICATE_SAME_ACCESS );
    CloseHandle( pipe_out[0] );

    /* Save the handle to the current STDERR. */
    hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);

    /* Create a pipe for the child process's STDERR. */
    CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

    /* Set a write handle to the pipe to be STDERR. */
    SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);

    /* Create noninheritable read handle and close the inheritable read handle. */
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
		     GetCurrentProcess(),  &pipe_errDup ,
		     0,  FALSE,
		     DUPLICATE_SAME_ACCESS );
    CloseHandle( pipe_err[0] );

    /* The steps for redirecting child process's STDIN:
     *     1.  Save current STDIN, to be restored later.
     *     2.  Create anonymous pipe to be STDIN for child process.
     *     3.  Set STDIN of the parent to be the read handle to the
     *         pipe, so it is inherited by the child process.
     *     4.  Create a noninheritable duplicate of the write handle,
     *         and close the inheritable write handle.
     */

    /* Save the handle to the current STDIN. */
    hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);

    /* Create a pipe for the child process's STDIN. */
    CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
    /* Set a read handle to the pipe to be STDIN. */
    SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
    /* Duplicate the write handle to the pipe so it is not inherited. */
    DuplicateHandle(GetCurrentProcess(), pipe_in[1],
		    GetCurrentProcess(), &pipe_inDup,
		    0, FALSE,                  /* not inherited */
		    DUPLICATE_SAME_ACCESS );
    CloseHandle(pipe_in[1]);


    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;
    si.lpDesktop = NULL;
    si.dwFlags = 0;
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput   = pipe_in[0];
    si.hStdOutput  = pipe_out[1];
    si.hStdError   = pipe_err[1];


    snprintf(line1, 2048, "%s ",rt_cmd_vec[0]);
    for(i=1;i<rt_cmd_vec_len;i++) {
	snprintf(name, 1024, "%s ",rt_cmd_vec[i]);
	strncat(line1, name, 2048-strlen(line1)-1);
	line1[1024-1] = '\0'; /* sanity */
	if(strstr(name,"-e") != NULL) {
	    i++;
	    snprintf(name, 1024, "\"%s\" ",rt_cmd_vec[i]);
	    name[1024-1] = '\0'; /* sanity */
	    strncat(line1, name, 2048-strlen(line1)-1);
	    line1[2048-1] = '\0'; /* sanity */
	}
    }

    if(CreateProcess( NULL, line1, NULL, NULL,TRUE, DETACHED_PROCESS, NULL, NULL, &si, &pi )) {
	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
    }

    /* use fp_in to feed view info to nirt */
    CloseHandle( pipe_in[0] );
    fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
    /*fp_in = fdopen( pipe_in[1], "w" ); */

    /* use fp_out to read back the result */
    CloseHandle( pipe_out[1] );
    /*fp_out = fdopen( pipe_out[0], "r" ); */
    fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );

    /* use fp_err to read any error messages */
    CloseHandle(pipe_err[1]);
    /*fp_err = fdopen( pipe_err[0], "r" ); */
    fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

    /* send quit command to nirt */
    fwrite( "q\n", 1, 2, fp_in );
    (void)fclose( fp_in );
#endif

    bu_vls_free(&p_vls);   /* use to form "partition" part of nirt command above */
    if(QRAY_GRAPHICS){

	if(QRAY_TEXT)
	    bu_vls_free(&o_vls); /* used to form "overlap" part of nirt command above */

	BU_LIST_INIT(&HeadQRayData.l);

	/* handle partitions */
	while(bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL){
	    if(line[0] == '\n'){
		Tcl_AppendResult(interp, line+1, (char *)NULL);
		break;
	    }

	    BU_GETSTRUCT(ndlp, qray_dataList);
	    BU_LIST_APPEND(HeadQRayData.l.back, &ndlp->l);

	    if(sscanf(line, "%le %le %le %le",
		      &ndlp->x_in, &ndlp->y_in, &ndlp->z_in, &ndlp->los) != 4)
		break;
	}

	vbp = rt_vlblock_init();
	qray_data_to_vlist(vbp, &HeadQRayData, dir, 0);
	bu_list_free(&HeadQRayData.l);
	cvt_vlblock_to_solids(vbp, bu_vls_addr(&qray_basename), 0);
	rt_vlblock_free(vbp);

	/* handle overlaps */
	while(bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL){
	    if(line[0] == '\n'){
		Tcl_AppendResult(interp, line+1, (char *)NULL);
		break;
	    }

	    BU_GETSTRUCT(ndlp, qray_dataList);
	    BU_LIST_APPEND(HeadQRayData.l.back, &ndlp->l);

	    if(sscanf(line, "%le %le %le %le",
		      &ndlp->x_in, &ndlp->y_in, &ndlp->z_in, &ndlp->los) != 4)
		break;
	}
	vbp = rt_vlblock_init();
	qray_data_to_vlist(vbp, &HeadQRayData, dir, 1);
	bu_list_free(&HeadQRayData.l);
	cvt_vlblock_to_solids(vbp, bu_vls_addr(&qray_basename), 0);
	rt_vlblock_free(vbp);

	update_views = 1;
    }

    if(QRAY_TEXT){
	bu_vls_free(&t_vls);

	while(bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL)
	    Tcl_AppendResult(interp, line, (char *)NULL);
    }

    (void)fclose(fp_out);

    while(bu_fgets(line, RT_MAXLINE, fp_err) != (char *)NULL)
	Tcl_AppendResult(interp, line, (char *)NULL);
    (void)fclose(fp_err);

#ifndef _WIN32

    /* Wait for program to finish */
    while ((rpid = wait(&retcode)) != pid && rpid != -1)
	;	/* NULL */

    if( retcode != 0 )
	pr_wait_status( retcode );
#else
    /* Wait for program to finish */
    WaitForSingleObject( pi.hProcess, INFINITE );

#endif

#if 0
    (void)signal(SIGINT, cur_sigint);
#endif

    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
	sp->s_wflag = DOWN;

    return TCL_OK;
#endif
}


int
f_vnirt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
#if 1
    char *ptr, buf[256];
    CHECK_DBI_NULL;

    ptr = bu_brlcad_root("bin", 1);
    if (ptr) {
#  ifdef _WIN32
	snprintf(buf, 256, "\"%s/%s\"", ptr, argv[0]);
#  else
	snprintf(buf, 256, "%s/%s", ptr, argv[0]);
#  endif
	argv[0] = buf;
    }


    return dgo_vnirt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
#else
    register int i;
    int status;
    fastf_t sf = 1.0 * INV_GED;
    vect_t view_ray_orig;
    vect_t center_model;
    struct bu_vls vls;
    struct bu_vls x_vls;
    struct bu_vls y_vls;
    struct bu_vls z_vls;
    char **av;

    CHECK_DBI_NULL;

    if(argc < 3){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
    }

    /*
     * The last two arguments are expected to be x,y in view coordinates.
     * It is also assumed that view z will be the front of the viewing cube.
     * These coordinates are converted to x,y,z in model coordinates and then
     * converted to local units before being handed to nirt. All other
     * arguments are passed straight through to nirt.
     */
    if(sscanf(argv[argc-2], "%lf", &view_ray_orig[X]) != 1 ||
       sscanf(argv[argc-1], "%lf", &view_ray_orig[Y]) != 1){
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "help %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
    }
    view_ray_orig[Z] = GED_MAX;
    argc -= 2;

    av = (char **)bu_malloc(sizeof(char *) * (argc + 4), "f_vnirt: av");

    /* Calculate point from which to fire ray */
    VSCALE(view_ray_orig, view_ray_orig, sf);
    MAT4X3PNT(center_model, view_state->vs_vop->vo_view2model, view_ray_orig);
    VSCALE(center_model, center_model, base2local);

    bu_vls_init(&x_vls);
    bu_vls_init(&y_vls);
    bu_vls_init(&z_vls);
    bu_vls_printf(&x_vls, "%lf", center_model[X]);
    bu_vls_printf(&y_vls, "%lf", center_model[Y]);
    bu_vls_printf(&z_vls, "%lf", center_model[Z]);

    /* pass remaining arguments to nirt */
    av[0] = "nirt";
    for(i = 1; i < argc; ++i)
	av[i] = argv[i];

    /* pass modified coordinates to nirt */
    av[i++] = bu_vls_addr(&x_vls);
    av[i++] = bu_vls_addr(&y_vls);
    av[i++] = bu_vls_addr(&z_vls);
    av[i] = (char *)NULL;

    status = f_nirt(clientData, interp, argc + 3, av);

    bu_vls_free(&x_vls);
    bu_vls_free(&y_vls);
    bu_vls_free(&z_vls);
    bu_free((genptr_t)av, "f_vnirt: av");

    return status;
#endif
}


int
cm_start(int argc, char **argv)
{
    if( argc < 2 )
	return(-1);
    rtif_currentframe = atoi(argv[1]);
    tree_walk_needed = 0;
    return(0);
}


int
cm_vsize(int argc, char **argv)
{
    if( argc < 2 )
	return(-1);
    /* for some reason, scale is supposed to be half of size... */
    view_state->vs_vop->vo_size = atof(argv[1]);
    view_state->vs_vop->vo_scale = view_state->vs_vop->vo_size * 0.5;
    view_state->vs_vop->vo_invSize = 1.0 / view_state->vs_vop->vo_size;
    return(0);
}


int
cm_eyept(int argc, char **argv)
{
    if( argc < 4 )
	return(-1);
    rtif_eye_model[X] = atof(argv[1]);
    rtif_eye_model[Y] = atof(argv[2]);
    rtif_eye_model[Z] = atof(argv[3]);
    /* Processing is deferred until cm_end() */
    return(0);
}


int
cm_lookat_pt(int argc, char **argv)
{
    point_t	pt;
    vect_t	dir;

    if( argc < 4 )
	return(-1);
    pt[X] = atof(argv[1]);
    pt[Y] = atof(argv[2]);
    pt[Z] = atof(argv[3]);

    VSUB2( dir, pt, rtif_eye_model );
    VUNITIZE( dir );

#if 1
    /*
      At the moment bn_mat_lookat will return NAN's if the direction vector
      is aligned with the Z axis. The following is a temporary workaround.
    */
    {
	vect_t neg_Z_axis;

	VSET(neg_Z_axis, 0.0, 0.0, -1.0);
	bn_mat_fromto( rtif_viewrot, dir, neg_Z_axis);
    }
#else
    bn_mat_lookat( rtif_viewrot, dir, yflip );
#endif

    /*  Final processing is deferred until cm_end(), but eye_pt
     *  must have been specified before here (for now)
     */
    return(0);
}


int
cm_vrot(int argc, char **argv)
{
    register int	i;

    if( argc < 17 )
	return(-1);
    for( i=0; i<16; i++ )
	rtif_viewrot[i] = atof(argv[i+1]);
    /* Processing is deferred until cm_end() */
    return(0);
}


int
cm_orientation(int argc, char **argv)
{
    register int	i;
    quat_t		quat;

    for( i=0; i<4; i++ )
	quat[i] = atof( argv[i+1] );
    quat_quat2mat( rtif_viewrot, quat );
    return(0);
}


/**
 *			C M _ E N D
 */
int
cm_end(int argc, char **argv)
{
    vect_t	xlate;
    vect_t	new_cent;
    vect_t	xv, yv;			/* view x, y */
    vect_t	xm, ym;			/* model x, y */
    struct bu_list		*vhead = &rtif_vbp->head[0];

    /* Only display the frames the user is interested in */
    if( rtif_currentframe < rtif_desiredframe )  return 0;
    if( rtif_finalframe && rtif_currentframe > rtif_finalframe )  return 0;

    /* Record eye path as a polyline.  Move, then draws */
    if( BU_LIST_IS_EMPTY( vhead ) )  {
	RT_ADD_VLIST( vhead, rtif_eye_model, BN_VLIST_LINE_MOVE );
    } else {
	RT_ADD_VLIST( vhead, rtif_eye_model, BN_VLIST_LINE_DRAW );
    }

    /* First step:  put eye at view center (view 0,0,0) */
    MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
    MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, rtif_eye_model);
    new_mats();

    /*
     * Compute camera orientation notch to right (+X) and up (+Y)
     * Done here, with eye in center of view.
     */
    VSET(xv, 0.05, 0.0, 0.0);
    VSET(yv, 0.0, 0.05, 0.0);
    MAT4X3PNT(xm, view_state->vs_vop->vo_view2model, xv);
    MAT4X3PNT(ym, view_state->vs_vop->vo_view2model, yv);
    RT_ADD_VLIST(vhead, xm, BN_VLIST_LINE_DRAW);
    RT_ADD_VLIST(vhead, rtif_eye_model, BN_VLIST_LINE_MOVE);
    RT_ADD_VLIST(vhead, ym, BN_VLIST_LINE_DRAW);
    RT_ADD_VLIST(vhead, rtif_eye_model, BN_VLIST_LINE_MOVE);

    /*  Second step:  put eye at view 0,0,1.
     *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
     */
    VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
    MAT4X3PNT(new_cent, view_state->vs_vop->vo_view2model, xlate);
    MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, new_cent);
    new_mats();

    /* If new treewalk is needed, get new objects into view. */
    if( tree_walk_needed )  {
	char *av[2];

	av[0] = "Z";
	av[1] = NULL;

	(void)cmd_zap( (ClientData)NULL, interp, 1, av );
	edit_com( rt_cmd_vec_len, rt_cmd_vec, rtif_mode, 0 );
    }

    view_state->vs_flag = 1;
    refresh();	/* Draw new display */
    view_state->vs_flag = 1;
    if( rtif_delay > 0 )  {
	struct timeval tv;
	fd_set readfds;

	FD_ZERO(&readfds);
	FD_SET(fileno(stdin), &readfds);
	tv.tv_sec = (long)rtif_delay;
	tv.tv_usec = (long)((rtif_delay - tv.tv_sec) * 1000000);
	select( fileno(stdin)+1, &readfds, (fd_set *)0, (fd_set *)0, &tv );
    }
    return(0);
}


int
cm_multiview(int argc, char **argv)
{
    return(-1);
}


/**
 *			C M _ A N I M
 *
 *  Parse any "anim" commands, and lodge their info in the directory structs.
 */
int
cm_anim(int argc, char **argv)
{

    if(dbip == DBI_NULL)
	return 0;

    if( db_parse_anim( dbip, argc, (const char **)argv ) < 0 )  {
	Tcl_AppendResult(interp, "cm_anim:  ", argv[1], " ", argv[2], " failed\n", (char *)NULL);
	return(-1);		/* BAD */
    }

    tree_walk_needed = 1;

    return(0);
}


/**
 *			C M _ T R E E
 *
 *  Replace list of top-level objects in rt_cmd_vec[].
 */
int
cm_tree(int argc, char **argv)
{
    register int	i = 1;
    char *cp = rt_cmd_storage;

    for( i = 1;  i < argc && i < MAXARGS; i++ )  {
	strncpy(cp, argv[i], (MAXARGS*9)-1);
	rt_cmd_vec[i] = cp;
	cp += strlen(cp) + 1;
    }
    rt_cmd_vec[i] = (char *)0;
    rt_cmd_vec_len = i;

    tree_walk_needed = 1;

    return(0);
}


/**
 *			C M _ C L E A N
 *
 *  Clear current view.
 */
int
cm_clean(int argc, char **argv)
{
    if(dbip == DBI_NULL)
	return 0;

    /*f_zap( (ClientData)NULL, interp, 0, (char **)0 );*/

    /* Free animation structures */
    db_free_anim(dbip);

    tree_walk_needed = 1;
    return 0;
}

int
cm_set(int argc, char **argv)
{
    return(-1);
}

extern char **skewer_solids (int argc, const char **argv, fastf_t *ray_orig, fastf_t *ray_dir, int full_path);

int
cmd_solids_on_ray (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    char			**snames;
    int				h = 0;
    int				v = 0;
    int				i;		/* Dummy loop index */
    register struct solid	*sp;
    double			t;
    double			t_in;
    struct bu_vls		vls;
    point_t			ray_orig;
    vect_t			ray_dir;
    point_t			extremum[2];
    point_t			minus, plus;	/* vrts of solid's bnding bx */
    vect_t			unit_H, unit_V;

    if(argc < 1 || 3 < argc){
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helpdevel solids_on_ray");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    if ((argc != 1) && (argc != 3))
	{
	    Tcl_AppendResult(interp, "Usage: 'solids_on_ray [h v]'", (char *)NULL);
	    return (TCL_ERROR);
	}
    if ((argc == 3) &&
	((Tcl_GetInt(interp, argv[1], &h) != TCL_OK)
	 || (Tcl_GetInt(interp, argv[2], &v) != TCL_OK)))
	{
	    Tcl_AppendResult(interp, "\nUsage: 'solids_on_ray h v'", NULL);
	    return (TCL_ERROR);
	}

    if (((int)GED_MIN > h)  || (h > (int)GED_MAX) || ((int)GED_MIN > v)  || (v > (int)GED_MAX))
	{
	    Tcl_AppendResult(interp, "Screen coordinates out of range\n",
			     "Must be between +/-2048", NULL);
	    return (TCL_ERROR);
	}

    VSET(ray_orig, -view_state->vs_vop->vo_center[MDX],
	 -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);
    /*
     * Compute bounding box of all objects displayed.
     * Borrowed from size_reset() in chgview.c
     */
    for (i = 0; i < 3; ++i)
	{
	    extremum[0][i] = INFINITY;
	    extremum[1][i] = -INFINITY;
	}
    FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid)
	{
	    minus[X] = sp->s_center[X] - sp->s_size;
	    minus[Y] = sp->s_center[Y] - sp->s_size;
	    minus[Z] = sp->s_center[Z] - sp->s_size;
	    VMIN( extremum[0], minus );
	    plus[X] = sp->s_center[X] + sp->s_size;
	    plus[Y] = sp->s_center[Y] + sp->s_size;
	    plus[Z] = sp->s_center[Z] + sp->s_size;
	    VMAX( extremum[1], plus );
	}
    VMOVEN(ray_dir, view_state->vs_vop->vo_rotation + 8, 3);
    VSCALE(ray_dir, ray_dir, -1.0);
    for (i = 0; i < 3; ++i)
	if (NEAR_ZERO(ray_dir[i], 1e-10))
	    ray_dir[i] = 0.0;
    if ((ray_orig[X] >= extremum[0][X]) &&
	(ray_orig[X] <= extremum[1][X]) &&
	(ray_orig[Y] >= extremum[0][Y]) &&
	(ray_orig[Y] <= extremum[1][Y]) &&
	(ray_orig[Z] >= extremum[0][Z]) &&
	(ray_orig[Z] <= extremum[1][Z]))
	{
	    t_in = -INFINITY;
	    for (i = 0; i < 6; ++i)
		{
		    if (ray_dir[i%3] == 0)
			continue;
		    t = (extremum[i/3][i%3] - ray_orig[i%3]) /
			ray_dir[i%3];
		    if ((t < 0) && (t > t_in))
			t_in = t;
		}
	    VJOIN1(ray_orig, ray_orig, t_in, ray_dir);
	}

    VMOVEN(unit_H, view_state->vs_vop->vo_model2view, 3);
    VMOVEN(unit_V, view_state->vs_vop->vo_model2view + 4, 3);
    VJOIN1(ray_orig, ray_orig, h * view_state->vs_vop->vo_scale * INV_GED, unit_H);
    VJOIN1(ray_orig, ray_orig, v * view_state->vs_vop->vo_scale * INV_GED, unit_V);

    /*
     *	Build a list of all the top-level objects currently displayed
     */
    rt_cmd_vec_len = build_tops(&rt_cmd_vec[0], &rt_cmd_vec[MAXARGS]);

    bu_vls_init(&vls);
    start_catching_output(&vls);
    snames = skewer_solids(rt_cmd_vec_len, (const char **)rt_cmd_vec, ray_orig, ray_dir, 1);
    stop_catching_output(&vls);

    if (snames == 0)
	{
	    Tcl_AppendResult(interp, "Error executing skewer_solids: ", (char *)NULL);
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);
	    return (TCL_ERROR);
	}

    bu_vls_free(&vls);

    for (i = 0; snames[i] != 0; ++i)
	Tcl_AppendElement(interp, snames[i]);

    bu_free((genptr_t) snames, "solid names");

    return TCL_OK;
}


/**
 * List the objects currently being drawn.
 */
int
cmd_who (ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    CHECK_DBI_NULL;

    return dgo_who_cmd(dgop, interp, argc, argv);
}


/**
 * any commands that are not supported or implemented may call this null
 * routine to avoid rt_do_cmd() "command not found" error reporting
 */
int
cm_null(int argc, char **argv)
{
    return(0);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.36
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.35 2007/11/21 20:49:09 erikgreenwald Exp $ (BRL)";
d725 2
a726 1
	strncat(line,name, RT_MAXLINE-strlen(line));
d2206 1
d2209 2
a2210 1
	    snprintf(name, 2048, "\"%s\" ",rt_cmd_vec[i]);
d2212 1
@


14.35
log
@pass bu_exit a NULL instead of an empty string
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.34 2007/11/21 19:49:11 erikgreenwald Exp $ (BRL)";
d722 1
a722 1
    sprintf(line,"%s ",rt_cmd_vec[0]);
d724 3
a726 2
	sprintf(name,"%s ",rt_cmd_vec[i]);
	strcat(line,name); }
d795 1
a795 1
	sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d797 1
a797 1
	sprintf(buf, "%s/%s", ptr, argv[0]);
d927 1
a927 1
	sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d929 1
a929 1
	sprintf(buf, "%s/%s", ptr, argv[0]);
d955 1
a955 1
	sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d957 1
a957 1
	sprintf(buf, "%s/%s", ptr, argv[0]);
d983 1
a983 1
	sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d985 1
a985 1
	sprintf(buf, "%s/%s", ptr, argv[0]);
d1011 1
a1011 1
	sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d1013 1
a1013 1
	sprintf(buf, "%s/%s", ptr, argv[0]);
d1215 1
a1215 1
	fscanf(fp, "%s", buffer);
d1234 2
a1235 1
	    fscanf(fp, "%s", dbName);
d1303 1
a1303 1
	    fscanf(fp, "%s", objects);
d1311 1
a1311 1
		    sscanf(objects, "%s", objects);
d1322 1
a1322 1
		fscanf(fp, "%s", objects);
d1827 1
a1827 1
	sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d1829 1
a1829 1
	sprintf(buf, "%s/%s", ptr, argv[0]);
d1892 1
a1892 1
	sprintf(buf, "\"%s/%s\"", ptr, "nirt");
d1894 1
a1894 1
	sprintf(buf, "%s/%s", ptr, "nirt");
d2062 1
a2062 1
	sprintf("\"%s\"", dbip->dbi_filename);
d2201 1
a2201 1
    sprintf(line1,"%s ",rt_cmd_vec[0]);
d2203 2
a2204 2
	sprintf(name,"%s ",rt_cmd_vec[i]);
	strcat(line1,name);
d2207 3
a2209 2
	    sprintf(name,"\"%s\" ",rt_cmd_vec[i]);
	    strcat(line1,name);}
d2339 1
a2339 1
	sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d2341 1
a2341 1
	sprintf(buf, "%s/%s", ptr, argv[0]);
d2647 1
a2647 1
	strcpy(cp, argv[i]);
@


14.34
log
@exit->bu_exit where applicable
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.33 2007/11/08 19:16:50 bob1961 Exp $ (BRL)";
d622 1
a622 1
	bu_exit(16, "");
d2108 1
a2108 1
	bu_exit(16, "");
@


14.33
log
@Using bu_fchmod() instead of fchmod.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.32 2007/10/22 19:53:30 brlcad Exp $ (BRL)";
d622 1
a622 1
	exit(16);
d2108 1
a2108 1
	exit(16);
@


14.32
log
@wrong direction bob.. working to remove _all_ instances of _WIN32 not in a core library.  besides, using chmod() is actually has a fundamental race condition flaw that is a security violation; and causes the new flawfinder regression test to fail.  hopefully msvc has _fchmod() like the other posix funcs it supports prefixed.  if not, need to add a libbu compatibility routine.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.31 2007/10/19 19:54:54 bob1961 Exp $ (BRL)";
d1090 1
a1090 1
    (void)fchmod( fileno(fp), 0755 );	/* executable */
@


14.31
log
@Minor mods for getting things compiled on Windows.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.30 2007/10/14 01:17:30 brlcad Exp $ (BRL)";
a1089 3
#if defined(_WIN32) && !defined(__CYGWIN__)
    (void)chmod(argv[1], 0755);	/* executable */
#else
d1091 1
a1091 1
#endif
@


14.30
log
@use fchmod() instead of chmod() to avoid race condition.  quell flawfinder warning
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.29 2007/09/15 16:23:17 brlcad Exp $ (BRL)";
d1090 3
d1094 1
@


14.29
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.28 2007/09/14 15:21:09 erikgreenwald Exp $ (BRL)";
a60 1
#include <sys/stat.h>		/* for chmod() */
d64 1
d1090 1
a1090 1
    (void)chmod( argv[1], 0755 );	/* executable */
@


14.28
log
@removed trailing whitespace
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.27 2007/02/26 22:09:12 brlcad Exp $ (BRL)";
d54 1
a54 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d57 1
@


14.27
log
@use bu_same_file() instead of stat() directly to compare whether the saveview script database and the current database are the same file
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.26 2007/02/26 21:06:35 brlcad Exp $ (BRL)";
d2022 1
a2022 1
	    
d2024 1
a2024 1
	    
d2029 1
a2029 1
    
d2334 1
a2334 1
    
d2344 2
a2345 2
    
    
d2358 1
a2358 1
    
d2360 1
a2360 1
    
d2366 1
a2366 1
	
@


14.27.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.29 2007/09/15 16:23:17 brlcad Exp $ (BRL)";
d54 5
a58 1
#include <string.h>
a60 1

d2022 1
a2022 1

d2024 1
a2024 1

d2029 1
a2029 1

d2334 1
a2334 1

d2344 2
a2345 2


d2358 1
a2358 1

d2360 1
a2360 1

d2366 1
a2366 1

@


14.26
log
@massive cleanup, ws, indentation, rewrite some of the _WIN32 sections so there are fewer duplicate code sections.  add a display_error function to report the windows read error via a dialog bog
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.25 2007/02/20 08:19:49 brlcad Exp $ (BRL)";
d1082 10
d1157 1
a1157 1
    char buffer[512];
a1169 4
    /* inodes used for database comparisons */
    struct stat dbInode;
    struct stat scriptInode;

d1195 6
d1279 6
a1284 9
		/* compare inode numbers */

		stat(dbip->dbi_filename, &dbInode);
		stat(dbName, &scriptInode);

		/* stop here if they are not the same file, otherwise,
		 * we may proceed as expected, and load the objects.
		 */
		if (dbInode.st_ino != scriptInode.st_ino) {
@


14.25
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.24 2007/01/27 01:41:44 brlcad Exp $ (BRL)";
d113 1
a113 1
	genptr_t chan;
d115 1
a115 1
#else
d118 1
a118 1
#endif
d151 2
a152 1
/* here we define a minimal table of commands that are supported by the
d157 34
a190 34
	{"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2},
	{"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4},
	{"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5},
	{"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17},
	{"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5},
	{"set", 	"", "show or set parameters",
		cm_set,		1, 999},

	/* begin unsupported commands (for view loading) */

	{"start", "frame number", "start a new frame",
		cm_null,	2, 2},
	{"clean", "", "clean articulation from previous frame",
		cm_null,	1, 1},
	{"end", 	"", "end of frame setup, begin raytrace",
		cm_null,		1, 1},

	/* not output, by default in saveview */

	{"multiview", "", "produce stock set of views",
		cm_null,	1, 1},
	{"anim", 	"path type args", "specify articulation animation",
		cm_null,	4, 999},
	{"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_null,	1, 999},
	{"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_null,		3, 3},
	{"opt", "-flags", "set flags, like on command line",
		cm_null,		2, 999},
d192 5
a196 5
	/* this is a quick hack used for quietly parsing the EOF delimiter in the
	 * script files.
	 */
	{"EOF", "", "End of file delimiter",
		cm_null,		1, 1},
d198 3
a200 3
	/* XXX support for the ae command is not included, though it probably should */
	{(char *)0, (char *)0, (char *)0,
		0,		0, 0	/* END */}
d204 1
a204 1
/*
d215 15
a229 20
  int	sig = status & 0x7f;
  int	core = status & 0x80;
  int	ret = status >> 8;
  struct bu_vls tmp_vls;

  if( status == 0 )  {
    Tcl_AppendResult(interp, "Normal exit\n", (char *)NULL);
    return;
  }

  bu_vls_init(&tmp_vls);
  bu_vls_printf(&tmp_vls, "Abnormal exit x%x", status);

  if( core )
    bu_vls_printf(&tmp_vls, ", core dumped");

  if( sig )
    bu_vls_printf(&tmp_vls, ", terminating signal = %d", sig );
  else
    bu_vls_printf(&tmp_vls, ", return (exit) code = %d", ret );
d231 7
a237 2
  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), "\n", (char *)NULL);
  bu_vls_free(&tmp_vls);
d240 2
a241 1
/*
d253 1
a253 1
	register int i;
d255 9
a263 9
	(void)fprintf(fp, "%.9e\n", view_state->vs_vop->vo_size);
	(void)fprintf(fp, "%.9e %.9e %.9e\n",
		eye_model[X], eye_model[Y], eye_model[Z] );
	for( i=0; i < 16; i++ )  {
		(void)fprintf(fp, "%.9e ", view_state->vs_vop->vo_rotation[i]);
		if( (i%4) == 3 )
			(void)fprintf(fp, "\n");
	}
	(void)fprintf(fp, "\n");
d266 2
a267 1
/*
d277 3
a279 3
	register int	i;
	quat_t		quat;
	register struct solid *sp;
d281 10
a290 11
	(void)fprintf(fp, "viewsize %.15e;\n", view_state->vs_vop->vo_size);
	quat_mat2quat(quat, view_state->vs_vop->vo_rotation);
	(void)fprintf(fp, "orientation %.15e %.15e %.15e %.15e;\n", V4ARGS(quat));
	(void)fprintf(fp, "eye_pt %.15e %.15e %.15e;\n",
		eye_model[X], eye_model[Y], eye_model[Z] );

	(void)fprintf(fp, "start 0; clean;\n");
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		for (i=0;i<sp->s_fullpath.fp_len;i++) {
			DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags &= ~DIR_USED;
		}
d292 10
a301 12
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		for (i=0; i<sp->s_fullpath.fp_len; i++ ) {
			struct directory *dp;
			dp = DB_FULL_PATH_GET(&sp->s_fullpath,i);
			if (!(dp->d_flags & DIR_USED)) {
				register struct animate *anp;
				for (anp = dp->d_animate; anp;
				    anp=anp->an_forw) {
					db_write_anim(fp, anp);
				}
				dp->d_flags |= DIR_USED;
			}
d303 2
d306 1
d308 3
a310 4
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid) {
		for (i=0;i<sp->s_fullpath.fp_len;i++) {
			DB_FULL_PATH_GET(&sp->s_fullpath,i)->d_flags &= ~DIR_USED;
		}
d312 1
d314 1
a314 1
	(void)fprintf(fp, "end;\n");
d317 2
a318 1
/*
d326 2
a327 2
	register int i;
	double d;
d329 14
a342 14
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	*scale = d*0.5;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[X] = d;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[Y] = d;
	if( fscanf( fp, "%lf", &d ) != 1 )  return(-1);
	eye[Z] = d;
	for( i=0; i < 16; i++ )  {
		if( fscanf( fp, "%lf", &d ) != 1 )
			return(-1);
		mat[i] = d;
	}
	return(0);
d345 3
a347 1
/*			B U I L D _ T O P S
d354 2
a355 2
	register char **vp = start;
	register struct solid *sp;
d357 26
a382 26
	/*
	 * Find all unique top-level entries.
	 *  Mark ones already done with s_wflag == UP
	 */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		register struct solid *forw;
		struct directory *dp = FIRST_SOLID(sp);

		if( sp->s_wflag == UP )
			continue;
		if( dp->d_addr == RT_DIR_PHONY_ADDR )
			continue;	/* Ignore overlays, predictor, etc */
		if( vp < end )
			*vp++ = dp->d_namep;
		else  {
		  Tcl_AppendResult(interp, "mged: ran out of comand vector space at ",
				   dp->d_namep, "\n", (char *)NULL);
		  break;
		}
		sp->s_wflag = UP;
		for(BU_LIST_PFOR(forw, sp, solid, &dgop->dgo_headSolid)){
			if( FIRST_SOLID(forw) == dp )
				forw->s_wflag = UP;
		}
d384 3
a386 2
	*vp = (char *) 0;
	return vp-start;
d388 3
a390 1
/*
d403 2
a404 2
  rt_cmd_vec_len = vp - rt_cmd_vec;
  rt_cmd_vec_len += build_tops(vp, &rt_cmd_vec[MAXARGS]);
d406 5
a410 5
  if(printcmd){
    /* Print out the command we are about to run */
    vp = &rt_cmd_vec[0];
    while( *vp )
      Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);
d412 2
a413 2
    Tcl_AppendResult(interp, "\n", (char *)NULL);
  }
d417 2
a418 1
/*  C M D _ R T A B O R T
d424 3
a426 3
	     Tcl_Interp *interp,
	     int argc,
	     char **argv)
d428 1
a428 1
	return dgo_rtabort_cmd(dgop, interp, argc, argv);
d432 3
d436 14
a449 26
static void
rt_output_handler(ClientData clientData, int mask)
{
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
	char line[RT_MAXLINE+1] = {0};

	/* Get data from rt */
	count = read((int)run_rtp->fd, line, RT_MAXLINE);
	if (count <= 0) {
		int retcode;
		int rpid;
		int aborted;

		if (count < 0) {
		    perror("READ ERROR");
		}

		Tcl_DeleteFileHandler(run_rtp->fd);
		close(run_rtp->fd);

		/* wait for the forked process */
		while ((rpid = wait(&retcode)) != run_rtp->pid && rpid != -1)
			pr_wait_status(retcode);

		aborted = run_rtp->aborted;
a450 3
		/* free run_rtp */
		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");
a451 13
		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}

	line[count] = '\0';

	/*XXX For now just blather to stderr */
	bu_log("%s", line);
}
#else
d455 2
a456 4
	struct run_rt *run_rtp = (struct run_rt *)clientData;
	int count;
#if 0
	char line[RT_MAXLINE+1];
d458 3
a460 2
	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, RT_MAXLINE,&count,0))) {
d462 2
a463 1
	char line[5120+1];
d465 6
d472 4
a475 4
	/* Get data from rt */
	if ((!ReadFile(run_rtp->fd, line, 5120,&count,0))) {
#endif
		int aborted;
d477 1
a477 2
		Tcl_DeleteChannelHandler(run_rtp->chan,rt_output_handler,(ClientData)run_rtp);
		CloseHandle(run_rtp->fd);
d479 8
a486 1
		/* wait for the forked process */
a487 1
		WaitForSingleObject( run_rtp->hProcess, INFINITE );
d489 10
a498 4
		if(GetLastError() == ERROR_PROCESS_ABORTED)
		{
			run_rtp->aborted = 1;
		}
d500 1
a500 1
		aborted = run_rtp->aborted;
d502 3
a504 3
		/* free run_rtp */
		BU_LIST_DEQUEUE(&run_rtp->l);
		bu_free((genptr_t)run_rtp, "rt_output_handler: run_rtp");
d506 6
a511 6
		if (aborted)
			bu_log("Raytrace aborted.\n");
		else
			bu_log("Raytrace complete.\n");
		return;
	}
d513 1
a513 1
	line[count] = '\0';
d515 2
a516 2
	/*XXX For now just blather to stderr */
	bu_log("%s", line);
d518 1
a518 1
#endif
d523 2
a524 2
  if(dmp->dm_zclip || mged_variables->mv_perspective_mode){
    vect_t temp;
d526 50
a575 49
    VSET( temp, 0.0, 0.0, 1.0 );
    MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, temp);
  }else{ /* not doing zclipping, so back out of geometry */
    register struct solid *sp;
    register int i;
    double  t;
    double  t_in;
    vect_t  direction;
    vect_t  extremum[2];
    vect_t  minus, plus;    /* vers of this solid's bounding box */

    VSET(eye_model, -view_state->vs_vop->vo_center[MDX],
	 -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);

    for (i = 0; i < 3; ++i){
      extremum[0][i] = INFINITY;
      extremum[1][i] = -INFINITY;
    }
    FOR_ALL_SOLIDS (sp, &dgop->dgo_headSolid){
      minus[X] = sp->s_center[X] - sp->s_size;
      minus[Y] = sp->s_center[Y] - sp->s_size;
      minus[Z] = sp->s_center[Z] - sp->s_size;
      VMIN( extremum[0], minus );
      plus[X] = sp->s_center[X] + sp->s_size;
      plus[Y] = sp->s_center[Y] + sp->s_size;
      plus[Z] = sp->s_center[Z] + sp->s_size;
      VMAX( extremum[1], plus );
    }
    VMOVEN(direction, view_state->vs_vop->vo_rotation + 8, 3);
    VSCALE(direction, direction, -1.0);
    for(i = 0; i < 3; ++i)
      if (NEAR_ZERO(direction[i], 1e-10))
	direction[i] = 0.0;
    if ((eye_model[X] >= extremum[0][X]) &&
	(eye_model[X] <= extremum[1][X]) &&
	(eye_model[Y] >= extremum[0][Y]) &&
	(eye_model[Y] <= extremum[1][Y]) &&
	(eye_model[Z] >= extremum[0][Z]) &&
	(eye_model[Z] <= extremum[1][Z])){
      t_in = -INFINITY;
      for(i = 0; i < 6; ++i){
	if (direction[i%3] == 0)
	  continue;
	t = (extremum[i/3][i%3] - eye_model[i%3]) /
	  direction[i%3];
	if ((t < 0) && (t > t_in))
	  t_in = t;
      }
      VJOIN1(eye_model, eye_model, t_in, direction);
a576 1
  }
d579 1
d581 1
a581 1
/*
d587 8
a594 8
	register struct solid *sp;
	register int i;
	FILE *fp_in;
	int pipe_in[2];
	int pipe_err[2];
	vect_t eye_model;
	int		pid;
	struct run_rt	*run_rtp;
d596 3
a598 3
	if (strlen(rt_cmd_vec[0]) <= 0) {
	    return -1;
	}
d600 18
a617 18
	(void)pipe( pipe_in );
	(void)pipe( pipe_err );
	(void)signal( SIGINT, SIG_IGN );
	if ((pid = fork()) == 0) {
	  /* make this a process group leader */
	  setpgid(0, 0);

	  /* Redirect stdin and stderr */
	  (void)close(0);
	  (void)dup( pipe_in[0] );
	  (void)close(2);
	  (void)dup ( pipe_err[1] );

	  /* close pipes */
	  (void)close(pipe_in[0]);
	  (void)close(pipe_in[1]);
	  (void)close(pipe_err[0]);
	  (void)close(pipe_err[1]);
d619 1
a619 1
	  for( i=3; i < 20; i++ )
d622 5
a626 5
	  (void)signal( SIGINT, SIG_DFL );
	  (void)execvp( rt_cmd_vec[0], rt_cmd_vec );
	  perror( rt_cmd_vec[0] );
	  exit(16);
	}
d628 9
a636 3
	/* As parent, send view information down pipe */
	(void)close( pipe_in[0] );
	fp_in = fdopen( pipe_in[1], "w" );
d638 2
a639 1
	(void)close( pipe_err[1] );
d641 4
a644 3
	rt_set_eye_model(eye_model);
	rt_write(fp_in, eye_model);
	(void)fclose( fp_in );
d646 2
a647 2
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;
d649 1
a649 9
	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
	run_rtp->fd = pipe_err[0];
	run_rtp->pid = pid;

	Tcl_CreateFileHandler(run_rtp->fd, TCL_READABLE,
			      rt_output_handler, (ClientData)run_rtp);

	return 0;
d652 2
a653 1
run_rt()
d655 13
a667 13
	register struct solid *sp;
	register int i;
	FILE *fp_in;
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	vect_t eye_model;
	struct run_rt	*run_rtp;

   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char line[RT_MAXLINE+1] = {0};
   char name[2048] = {0};
d673 2
a674 2
	/* Save the handle to the current STDOUT. */
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);
d676 2
a677 2
	/* Create a pipe for the child process's STDOUT. */
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);
d679 2
a680 2
	/* Set a write handle to the pipe to be STDOUT. */
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);
d682 1
a682 1
	/* Create noninheritable read handle and close the inheritable read handle. */
d684 13
a696 13
	GetCurrentProcess(),  &pipe_errDup ,
		0,  FALSE,
	DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );

	/* The steps for redirecting child process's STDIN:
	 *     1.  Save current STDIN, to be restored later.
	 *     2.  Create anonymous pipe to be STDIN for child process.
	 *     3.  Set STDIN of the parent to be the read handle to the
	 *         pipe, so it is inherited by the child process.
	 *     4.  Create a noninheritable duplicate of the write handle,
	 *         and close the inheritable write handle.
	 */
d698 2
a699 2
	/* Save the handle to the current STDIN. */
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);
d701 40
a740 40
	/* Create a pipe for the child process's STDIN. */
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	/* Set a read handle to the pipe to be STDIN. */
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	/* Duplicate the write handle to the pipe so it is not inherited. */
	DuplicateHandle(GetCurrentProcess(), pipe_in[1],
		GetCurrentProcess(), &pipe_inDup,
		0, FALSE,                  /* not inherited */
		DUPLICATE_SAME_ACCESS );
	CloseHandle(pipe_in[1]);


   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_err[1];
   si.hStdError   = pipe_err[1];


   sprintf(line,"%s ",rt_cmd_vec[0]);
   for(i=1;i<rt_cmd_vec_len;i++) {
	   sprintf(name,"%s ",rt_cmd_vec[i]);
	   strcat(line,name); }


   if(CreateProcess( NULL,
		     line,
		     NULL,
		     NULL,
		     TRUE,
		     DETACHED_PROCESS,
		     NULL,
		     NULL,
		     &si,
		     &pi )) {
d744 1
a744 1
}
d747 4
a750 4
	/* As parent, send view information down pipe */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	CloseHandle(pipe_err[1]);
d753 3
a755 3
	rt_set_eye_model(eye_model);
	rt_write(fp_in, eye_model);
	(void)fclose( fp_in );
d757 2
a758 2
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;
d760 10
a769 10
	BU_GETSTRUCT(run_rtp, run_rt);
	BU_LIST_APPEND(&head_run_rt.l, &run_rtp->l);
	run_rtp->fd = pipe_errDup;
	run_rtp->hProcess = pi.hProcess;
	run_rtp->pid = pi.dwProcessId;
	run_rtp->aborted=0;

	run_rtp->chan = Tcl_MakeFileChannel(run_rtp->fd,TCL_READABLE);
	Tcl_CreateChannelHandler(run_rtp->chan,TCL_READABLE,
			      rt_output_handler, (ClientData)run_rtp);
d771 1
a771 1
	return 0;
d776 1
a776 1
/*
d785 1
a785 1
    char *ptr, buf[256];
d787 1
a787 1
	CHECK_DBI_NULL;
d789 4
a792 4
	/* skip past _mged_ */
	if (argv[0][0] == '_' && argv[0][1] == 'm' &&
	    strncmp(argv[0], "_mged_", 6) == 0)
		argv[0] += 6;
d794 2
a795 2
	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
d797 1
a797 1
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d799 1
a799 1
	    sprintf(buf, "%s/%s", ptr, argv[0]);
d801 2
a802 2
	    argv[0] = buf;
	}
d804 1
a804 1
	return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
d807 2
a808 1
/*
d818 2
a819 2
	register char **vp;
	register int i;
d821 1
a821 1
	CHECK_DBI_NULL;
d823 2
a824 2
	if(argc < 2 || MAXARGS < argc){
	  struct bu_vls vls;
d826 6
a831 6
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help rrt");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}
d833 2
a834 2
	if( not_state( ST_VIEW, "Ray-trace of current view" ) )
	  return TCL_ERROR;
d836 4
a839 4
	vp = &rt_cmd_vec[0];
	for( i=1; i < argc; i++ )
		*vp++ = argv[i];
	*vp++ = dbip->dbi_filename;
d841 2
a842 2
	setup_rt( vp, 1 );
	(void)run_rt();
d844 1
a844 1
	return TCL_OK;
d849 5
a853 7
rtcheck_vector_handler(clientData, mask)
ClientData clientData;
int mask;
{
  int value;
  struct solid *sp;
  struct rtcheck *rtcp = (struct rtcheck *)clientData;
d855 4
a858 4
  /* Get vector output from rtcheck */
  if ((value = getc(rtcp->fp)) == EOF) {
    int retcode;
    int rpid;
d860 2
a861 2
    Tcl_DeleteFileHandler(rtcp->fd);
    fclose(rtcp->fp);
d863 2
a864 2
    FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
      sp->s_wflag = DOWN;
d866 7
a872 7
    /* Add overlay */
    cvt_vlblock_to_solids( rtcp->vbp, "OVERLAPS", 0 );
    rt_vlblock_free(rtcp->vbp);

    /* wait for the forked process */
    while ((rpid = wait(&retcode)) != rtcp->pid && rpid != -1)
      pr_wait_status(retcode);
d874 2
a875 2
    /* free rtcp */
    bu_free((genptr_t)rtcp, "rtcheck_vector_handler: rtcp");
d877 3
a879 3
    update_views = 1;
    return;
  }
d881 5
a885 5
  (void)rt_process_uplot_value( &rtcp->vhead,
				rtcp->vbp,
				rtcp->fp,
				value,
				rtcp->csize );
d889 1
a889 3
rtcheck_output_handler(clientData, mask)
ClientData clientData;
int mask;
d891 14
a904 14
  int count;
  char line[RT_MAXLINE+1] = {0};
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */

  /* Get textual output from rtcheck */
  count = read((int)fd, line, RT_MAXLINE-1);
  if (count <= 0) {
      if (count < 0) {
	  perror("READ ERROR");
      }
      Tcl_DeleteFileHandler(fd);
      close(fd);
      return;
  }
d906 2
a907 2
  line[count] = '\0';
  bu_log("%s", line);
d912 2
a913 1
/*  C M D _ R T C H E C K
d923 2
a924 2
    char *ptr, buf[256];
	CHECK_DBI_NULL;
d926 2
a927 2
	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
d929 1
a929 1
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d931 1
a931 1
	    sprintf(buf, "%s/%s", ptr, argv[0]);
d933 2
a934 3
	    argv[0] = buf;
	}

d936 1
a936 1
	return dgo_rtcheck_cmd(dgop, view_state->vs_vop, interp, argc, argv);
d940 2
a941 1
/*  C M D _ R T A R E A
d947 3
a949 3
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
d951 2
a952 2
    char *ptr, buf[256];
	CHECK_DBI_NULL;
d954 2
a955 2
	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
d957 1
a957 1
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d959 1
a959 1
	    sprintf(buf, "%s/%s", ptr, argv[0]);
d961 2
a962 2
	    argv[0] = buf;
	}
d964 1
a964 1
	return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
d968 2
a969 1
/*  C M D _ R T E D G E
d975 3
a977 3
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
d979 2
a980 2
    char *ptr, buf[256];
	CHECK_DBI_NULL;
d982 2
a983 2
	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
d985 1
a985 1
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d987 1
a987 1
	    sprintf(buf, "%s/%s", ptr, argv[0]);
d989 2
a990 2
	    argv[0] = buf;
	}
d992 1
a992 1
	return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
d996 2
a997 1
/*  C M D _ R T W E I G H T
d1003 3
a1005 3
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
d1007 2
a1008 2
    char *ptr, buf[256];
	CHECK_DBI_NULL;
d1010 2
a1011 2
	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
d1013 1
a1013 1
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d1015 1
a1015 1
	    sprintf(buf, "%s/%s", ptr, argv[0]);
d1017 2
a1018 2
	    argv[0] = buf;
	}
d1020 1
a1020 1
	return dgo_rt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
d1024 1
a1024 1
/*
d1032 2
a1033 2
	register char *p2, *p3;
	static char buf[128];
d1035 12
a1046 12
	p2 = p1;
	while (*p1) {
		if (*p1++ == '/')
			p2 = p1;
	}
	for(p3=suff; *p3; p3++)
		;
	while(p1>p2 && p3>suff)
		if(*--p3 != *--p1)
			return(p2);
	strncpy( buf, p2, p1-p2 );
	return(buf);
d1050 1
a1050 1
/*
d1060 6
a1065 4
	register struct solid *sp;
	register int i;
	register FILE *fp;
	char *base;
d1067 2
a1068 1
	CHECK_DBI_NULL;
d1070 6
a1075 2
	if(argc < 2){
	  struct bu_vls vls;
d1077 4
a1080 22
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help saveview");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (fp = fopen( argv[1], "a")) == NULL )  {
	  perror(argv[1]);
	  return TCL_ERROR;
	}

	base = basename_without_suffix( argv[1], ".sh" );
	(void)chmod( argv[1], 0755 );	/* executable */
	/* Do not specify -v option to rt; batch jobs must print everything. -Mike */
	(void)fprintf(fp, "#!/bin/sh\nrt -M ");
	if( view_state->vs_vop->vo_perspective > 0 )
		(void)fprintf(fp, "-p%g ", view_state->vs_vop->vo_perspective);
	for( i=2; i < argc; i++ )
		(void)fprintf(fp,"%s ", argv[i]);
	(void)fprintf(fp,"\\\n -o %s.pix\\\n $*\\\n", base);
	(void)fprintf(fp," %s\\\n ", dbip->dbi_filename);
d1082 10
a1091 8
	/* Find all unique top-level entries.
	 *  Mark ones already done with s_wflag == UP
	 */
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
		register struct solid *forw;	/* XXX */
		struct directory *dp = FIRST_SOLID(sp);
d1093 17
a1109 9
		if( sp->s_wflag == UP )
			continue;
		if (dp->d_addr == RT_DIR_PHONY_ADDR) continue;
		(void)fprintf(fp, "'%s' ", dp->d_namep);
		sp->s_wflag = UP;
		for(BU_LIST_PFOR(forw, sp, solid, &dgop->dgo_headSolid)){
			if( FIRST_SOLID(forw) == dp )
				forw->s_wflag = UP;
		}
d1111 3
a1113 2
	(void)fprintf(fp,"\\\n 2>> %s.log\\\n", base);
	(void)fprintf(fp," <<EOF\n");
d1115 2
a1116 2
	{
	  vect_t eye_model;
d1118 3
a1120 3
	  rt_set_eye_model(eye_model);
	  rt_write(fp, eye_model);
	}
d1122 2
a1123 2
	(void)fprintf(fp,"\nEOF\n");
	(void)fclose( fp );
d1125 2
a1126 2
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;
d1128 1
a1128 1
	return TCL_OK;
d1132 1
a1132 1
/*
d1146 2
a1147 2
	register FILE *fp;
	char buffer[512];
d1149 2
a1150 2
	/* data pulled from script file */
	int perspective=-1;
d1152 11
a1162 11
	char dbName[MAX_DBNAME] = {0};
	char objects[10000] = {0};
	char *editArgv[3];

	/* save previous interactive state */
	int prevInteractive = interactive;
	int prevPerspective =  mged_variables->mv_perspective;

	/* inodes used for database comparisons */
	struct stat dbInode;
	struct stat scriptInode;
d1165 3
a1167 3
	/* for view orientation */
	vect_t xlate;
	mat_t new_cent;
d1169 3
a1171 3
	double viewsize;
	double orientation[4]={0.0, 0.0, 0.0, 0.0};
	vect_t eye_pt={0.0, 0.0, 0.0};
d1174 4
a1177 4
	/* We do not need to check *here* if a database is open, since we will be
	 * loading one anyways.  we manually check when/if we find the database name.
	 */
	/*	CHECK_DBI_NULL; */
d1179 2
a1180 2
	if(argc < 2){
	  struct bu_vls vls;
d1182 6
a1187 6
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help loadview");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}
d1189 5
a1193 5
	/* open the file for reading */
	if ( (fp = fopen( argv[1], "r" )) == NULL ) {
		perror(argv[1]);
		return TCL_ERROR;
	}
d1195 5
a1199 5
	/* turn perspective mode off, by default.  A "-p" option in the
	 * view script will turn it back on.
	 */
	mged_variables->mv_perspective=-1;
	set_perspective();
d1201 20
a1220 64
	/* iterate over the contents of the raytrace script */
	while (!feof(fp)) {
		memset(buffer, 0, 512);
		fscanf(fp, "%s", buffer);

		if (strncmp(buffer, "-p", 2)==0) {
		  /* we found perspective */

		  buffer[0]=' ';
		  buffer[1]=' ';
		  sscanf(buffer, "%d", &perspective);
		  /*      bu_log("perspective=%d\n", perspective);*/
		  mged_variables->mv_perspective=perspective;
		  /* !!! this does not update the menu variable.. */
		  set_perspective();

		} else if (strncmp(buffer, "$*", 2)==0) {
		  /* the next read is the file name, the objects come
		   * after that
		   */

		  memset(dbName, 0, MAX_DBNAME);
		  fscanf(fp, "%s", dbName);
		  /* if the last character is a line termination,
		   * remove it (it should always be unless the user
		   * modifies the file)
		   */
		  if ( *(dbName + strlen(dbName) - 1)=='\\' ) {
		    memset(dbName+strlen(dbName)-1, 0, 1);
		  }
		  /*      bu_log("dbName=%s\n", dbName); */

		  /* if no database is open, we attempt to open the
		   * database listed in the script.  if a database is
		   * open, we compare the open database's inode number
		   * with the inode of the database listed in the script.
		   * If they match, we may proceed. otherwise we need
		   * to abort since the wrong database would be open.
		   */
		  if ( dbip == DBI_NULL ) {
		    /* load the database */

		    /* XXX could use better path handling instead of
		     * assuming rooted or . */

		    /* turn off interactive mode so the f_opendb() call
		     * doesn't blather or attempt to create a new database
		     */
		    interactive=0;
		    editArgv[0]="";
		    editArgv[1]=dbName;
		    editArgv[2]=(char *)NULL;
		    if (f_opendb( (ClientData)NULL, interp, 2, editArgv ) == TCL_ERROR) {
		      Tcl_AppendResult(interp, "Unable to load database: ", dbName, "\n", (char *)NULL);

		      /* restore state before leaving */
		      mged_variables->mv_perspective=prevPerspective;
		      set_perspective();

		      return TCL_ERROR;
		    } else {
		      Tcl_AppendResult(interp, "Loading database: ", dbName, "\n", (char *)NULL);
		    }
		    interactive=prevInteractive;
d1222 10
a1231 2
		  } else {
		    /* compare inode numbers */
d1233 9
a1241 2
		    stat(dbip->dbi_filename, &dbInode);
		    stat(dbName, &scriptInode);
d1243 2
a1244 5
		    /* stop here if they are not the same file, otherwise,
		     * we may proceed as expected, and load the objects.
		     */
		    if (dbInode.st_ino != scriptInode.st_ino) {
		      Tcl_AppendResult(interp, "View script references a different database\nCannot load the view without closing the current database\n(i.e. run \"opendb ", dbName, "\")\n", (char *)NULL);
d1246 19
a1264 3
		      /* restore state before leaving */
		      mged_variables->mv_perspective=prevPerspective;
		      set_perspective();
d1266 2
a1267 5
		      return TCL_ERROR;
		    }

		  }
		  /* end check for loaded database */
d1269 2
a1270 16
		  /* get rid of anything that may be displayed, since we
		   * will load objects that are listed in the script next.
		   */
		  (void)cmd_zap( (ClientData)NULL, interp, 1, NULL );

		  /* now get the objects listed */
		  fscanf(fp, "%s", objects);
		  /*		  bu_log("OBJECTS=%s\n", objects);*/
		  while ((!feof(fp)) && (strncmp(objects, "\\", 1)!=0)) {

		    /* clean off the single quotes... */
		    if (strncmp(objects, "'", 1)==0) {
		      objects[0]=' ';
		      memset(objects+strlen(objects)-1, ' ', 1);
		      sscanf(objects, "%s", objects);
		    }
d1272 5
a1276 6
		    editArgv[0] = "e";
		    editArgv[1] = objects;
		    editArgv[2] = (char *)NULL;
		    if (edit_com( 2, editArgv, 1, 1 ) != 0) {
		      Tcl_AppendResult(interp, "Unable to load object: ", objects, "\n", (char *)NULL);
		    }
d1278 3
a1280 19
		    /* bu_log("objects=%s\n", objects);*/
		    fscanf(fp, "%s", objects);
		  }

		  /* end iteration over reading in listed objects */
		} else if (strncmp(buffer, "<<EOF", 5)==0) {
		  char *cmdBuffer = NULL;
		  /* we are almost done .. read in the view commands */

		  while ( (cmdBuffer = rt_read_cmd( fp )) != NULL ) {
		    /* even unsupported commands should return successfully as
		     * they should be calling cm_null()
		     */
		    if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) {
		      Tcl_AppendResult(interp, "command failed: ", cmdBuffer, "\n", (char *)NULL);
		    }
		    bu_free( (genptr_t)cmdBuffer, "loadview cmdBuffer" );
		  }
		  /* end iteration over rt commands */
d1282 1
a1283 1
		/* end check for non-view values (dbname, etc) */
d1285 2
a1286 3
	}
	/* end iteration over file until eof */
	fclose(fp);
d1288 68
a1355 17
	/* now we have to finish the eye point calculations that usually get
	 * postponed until the end command runs.  Since we are at the "end"
	 * of a commands section, we may finish the computations.
	 */
	/* First step:  put eye at view center (view 0,0,0) */
	MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, rtif_eye_model);
	new_mats(); /* actually updates display here (maybe?) */

	/* XXX not sure why the correction factor is needed, but it works -- csm */
	/*  Second step:  put eye at view 0,0,1.
	 *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
	VSET(xlate, 0.0, 0.0, -1.0);
	MAT4X3PNT(new_cent, view_state->vs_vop->vo_view2model, xlate);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, new_cent);
	new_mats();
	 */
d1357 2
a1358 2
	/* update the view next time through the event loop */
	update_views = 1;
d1360 1
a1360 1
	return TCL_OK;
d1364 1
a1364 1
/*
d1377 11
a1387 11
	register FILE *fp;
	register struct directory *dp;
	register struct solid *sp;
	vect_t	eye_model;
	vect_t	xlate;
	vect_t	sav_center;
	vect_t	sav_start;
	int	mode;
	fastf_t	scale;
	mat_t	rot;
	register struct bn_vlist *vp;
d1389 1
a1389 1
	CHECK_DBI_NULL;
d1391 2
a1392 2
	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;
d1394 6
a1399 6
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help rmats");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}
d1401 2
a1402 2
	if( not_state( ST_VIEW, "animate from matrix file") )
	  return TCL_ERROR;
d1404 4
a1407 4
	if( (fp = fopen(argv[1], "r")) == NULL )  {
	  perror(argv[1]);
	  return TCL_ERROR;
	}
d1409 1
a1409 1
	sp = SOLID_NULL;
d1411 4
a1414 4
	mode = -1;
	if( argc > 2 )
		mode = atoi(argv[2]);
	switch(mode)  {
d1416 14
a1429 14
		if( (dp = db_lookup(dbip, "EYE", LOOKUP_NOISY)) == DIR_NULL )  {
			mode = -1;
			break;
		}
		FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)  {
			if( LAST_SOLID(sp) != dp )  continue;
			if( BU_LIST_IS_EMPTY( &(sp->s_vlist) ) )  continue;
			vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
			VMOVE( sav_start, vp->pt[vp->nused-1] );
			VMOVE( sav_center, sp->s_center );
			Tcl_AppendResult(interp, "animating EYE solid\n", (char *)NULL);
			goto work;
		}
		/* Fall through */
d1432 3
a1434 3
	  mode = -1;
	  Tcl_AppendResult(interp, "default mode:  eyepoint at (0,0,1) viewspace\n", (char *)NULL);
	  break;
d1436 4
a1439 4
	  Tcl_AppendResult(interp, "rotation supressed, center is eyepoint\n", (char *)NULL);
	  break;
	}
work:
d1441 2
a1442 2
	/* If user hits ^C, this will stop, but will leave hanging filedes */
	(void)signal(SIGINT, cur_sigint);
d1444 4
a1447 4
	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;
d1449 46
a1494 48
	while( !feof( fp ) &&
	    rt_read( fp, &scale, eye_model, rot ) >= 0 )  {
		switch(mode)  {
		case -1:
			/* First step:  put eye in center */
			view_state->vs_vop->vo_scale = scale;
			MAT_COPY(view_state->vs_vop->vo_rotation, rot);
			MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, eye_model);
			new_mats();
			/* Second step:  put eye in front */
			VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
			MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, xlate);
			MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, eye_model);
			new_mats();
			break;
		case 0:
			view_state->vs_vop->vo_scale = scale;
			MAT_IDN(view_state->vs_vop->vo_rotation);	/* top view */
			MAT_DELTAS_VEC_NEG( view_state->vs_vop->vo_center, eye_model);
			new_mats();
			break;
		case 1:
			/* Adjust center for displaylist devices */
			VMOVE( sp->s_center, eye_model );

			/* Adjust vector list for non-dl devices */
			if( BU_LIST_IS_EMPTY( &(sp->s_vlist) ) )  break;
			vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
			VSUB2( xlate, eye_model, vp->pt[vp->nused-1] );
			for( BU_LIST_FOR( vp, bn_vlist, &(sp->s_vlist) ) )  {
				register int	i;
				register int	nused = vp->nused;
				register int	*cmd = vp->cmd;
				register point_t *pt = vp->pt;
				for( i = 0; i < nused; i++,cmd++,pt++ )  {
					switch( *cmd )  {
					case BN_VLIST_POLY_START:
					case BN_VLIST_POLY_VERTNORM:
						break;
					case BN_VLIST_LINE_MOVE:
					case BN_VLIST_LINE_DRAW:
					case BN_VLIST_POLY_MOVE:
					case BN_VLIST_POLY_DRAW:
					case BN_VLIST_POLY_END:
						VADD2( *pt, *pt, xlate );
						break;
					}
				}
d1496 1
a1496 1
			break;
d1498 1
a1498 2
		view_state->vs_flag = 1;
		refresh();	/* Draw new display */
d1500 26
a1525 25
	if( mode == 1 )  {
		VMOVE( sp->s_center, sav_center );
		if( BU_LIST_NON_EMPTY( &(sp->s_vlist) ) )  {
			vp = BU_LIST_LAST( bn_vlist, &(sp->s_vlist) );
			VSUB2( xlate, sav_start, vp->pt[vp->nused-1] );
			for( BU_LIST_FOR( vp, bn_vlist, &(sp->s_vlist) ) )  {
				register int	i;
				register int	nused = vp->nused;
				register int	*cmd = vp->cmd;
				register point_t *pt = vp->pt;
				for( i = 0; i < nused; i++,cmd++,pt++ )  {
					switch( *cmd )  {
					case BN_VLIST_POLY_START:
					case BN_VLIST_POLY_VERTNORM:
						break;
					case BN_VLIST_LINE_MOVE:
					case BN_VLIST_LINE_DRAW:
					case BN_VLIST_POLY_MOVE:
					case BN_VLIST_POLY_DRAW:
					case BN_VLIST_POLY_END:
						VADD2( *pt, *pt, xlate );
						break;
					}
				}
			}
d1527 1
d1529 1
d1531 2
a1532 2
	fclose(fp);
	(void)mged_svbase();
d1534 2
a1535 2
	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
d1538 4
a1541 1
/* Save a keyframe to a file */
d1545 7
a1551 4
	register FILE *fp;
	fastf_t	time;
	vect_t	eye_model;
	vect_t temp;
d1553 6
a1558 2
	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;
d1560 15
a1574 22
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help savekey");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( (fp = fopen( argv[1], "a")) == NULL )  {
	  perror(argv[1]);
	  return TCL_ERROR;
	}
	if( argc > 2 ) {
	  time = atof( argv[2] );
	  (void)fprintf(fp,"%f\n", time);
	}
	/*
	 *  Eye is in conventional place.
	 */
	VSET( temp, 0.0, 0.0, 1.0 );
	MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, temp);
	rt_oldwrite(fp, eye_model);
	(void)fclose( fp );
d1576 1
a1576 1
	return TCL_OK;
d1592 2
a1593 1
/* table of commands supported by the preview command
d1596 30
a1625 30
	{"start", "frame number", "start a new frame",
		cm_start,	2, 2},
	{"viewsize", "size in mm", "set view size",
		cm_vsize,	2, 2},
	{"eye_pt", "xyz of eye", "set eye point",
		cm_eyept,	4, 4},
	{"lookat_pt", "x y z [yflip]", "set eye look direction, in X-Y plane",
		cm_lookat_pt,	4, 5},
	{"orientation", "quaturnion", "set view direction from quaturnion",
		cm_orientation,	5, 5},
	{"viewrot", "4x4 matrix", "set view direction from matrix",
		cm_vrot,	17,17},
	{"end", 	"", "end of frame setup, begin raytrace",
		cm_end,		1, 1},
	{"multiview", "", "produce stock set of views",
		cm_multiview,	1, 1},
	{"anim", 	"path type args", "specify articulation animation",
		cm_anim,	4, 999},
	{"tree", 	"treetop(s)", "specify alternate list of tree tops",
		cm_tree,	1, 999},
	{"clean", "", "clean articulation from previous frame",
		cm_clean,	1, 1},
	{"set", 	"", "show or set parameters",
		cm_set,		1, 999},
	{"ae", "azim elev", "specify view as azim and elev, in degrees",
		cm_null,		3, 3},
	{"opt", "-flags", "set flags, like on command line",
		cm_null,		2, 999},
	{(char *)0, (char *)0, (char *)0,
		0,		0, 0}	/* END */
d1629 1
a1629 1
/*
d1642 2
a1643 2
	if(dbip == DBI_NULL)
	  return;
d1645 1
a1645 1
	write( 2, "rtif_sigint\n", 12);
d1647 2
a1648 2
	/* Restore state variables */
	*mged_variables = rtif_saved_state;	/* struct copy */
d1650 7
a1656 7
	if(rtif_vbp)  {
		rt_vlblock_free(rtif_vbp);
		rtif_vbp = (struct bn_vlblock *)NULL;
	}
	db_free_anim(dbip);	/* Forget any anim commands */
	sig3(num);			/* Call main SIGINT handler */
	/* NOTREACHED */
d1660 1
a1660 1
/*
d1676 46
a1721 46
	char	*cmd;
	int	c;
	vect_t	temp;

	CHECK_DBI_NULL;

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help preview");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( not_state( ST_VIEW, "animate viewpoint from new RT file") )
	  return TCL_ERROR;

	/* Save any state variables we plan on changing */
	rtif_saved_state = *mged_variables;	/* struct copy */
	mged_variables->mv_autosize = 0;

	rtif_delay = 0;			/* Full speed, by default */
	rtif_mode = 1;			/* wireframe drawing */
	rtif_desiredframe = 0;
	rtif_finalframe = 0;

	/* Parse options */
	bu_optind = 1;			/* re-init bu_getopt() */
	while( (c=bu_getopt(argc,argv,"d:vD:K:")) != EOF )  {
		switch(c)  {
		case 'd':
			rtif_delay = atof(bu_optarg);
			break;
		case 'D':
			rtif_desiredframe = atof(bu_optarg);
			break;
		case 'K':
			rtif_finalframe = atof(bu_optarg);
			break;
		case 'v':
			rtif_mode = 3;	/* Like "ev" */
			break;
		default:
		  {
d1732 1
a1732 1
		  }
d1734 1
a1734 2
		  break;
		}
d1736 3
a1738 2
	argc -= bu_optind-1;
	argv += bu_optind-1;
d1740 6
a1745 6
	/* If file is still open from last cmd getting SIGINT, close it */
	if(rtif_fp)  fclose(rtif_fp);
	if( (rtif_fp = fopen(argv[1], "r")) == NULL )  {
	  perror(argv[1]);
	  return TCL_ERROR;
	}
d1747 3
a1749 3
	/* Build list of top-level objects in view, in rt_cmd_vec[] */
	rt_cmd_vec[0] = "tree";
	setup_rt( &rt_cmd_vec[1], 1 );
d1751 1
a1751 1
	rtif_vbp = rt_vlblock_init();
d1753 1
a1753 1
	Tcl_AppendResult(interp, "eyepoint at (0,0,1) viewspace\n", (char *)NULL);
d1755 13
a1767 13
	/*
	 *  Initialize the view to the current one in MGED
	 *  in case a view specification is never given.
	 */
	MAT_COPY(rtif_viewrot, view_state->vs_vop->vo_rotation);
	VSET(temp, 0.0, 0.0, 1.0);
	MAT4X3PNT(rtif_eye_model, view_state->vs_vop->vo_view2model, temp);

	if( setjmp( jmp_env ) == 0 )
	  /* If user hits ^C, preview will stop, and clean up */
	  (void)signal(SIGINT, rtif_sigint);
	else
	  return TCL_OK;
d1769 8
a1776 13
	while( ( cmd = rt_read_cmd( rtif_fp )) != NULL )  {
		/* Hack to prevent running framedone scripts prematurely */
		if( cmd[0] == '!' )  {
			if( rtif_currentframe < rtif_desiredframe ||
			    (rtif_finalframe && rtif_currentframe > rtif_finalframe) )  {
				bu_free( (genptr_t)cmd, "preview ! cmd" );
				continue;
			}
		}
		if( rt_do_cmd( (struct rt_i *)0, cmd, cmdtab ) < 0 )
		   Tcl_AppendResult(interp, "command failed: ", cmd,
				    "\n", (char *)NULL);
		bu_free( (genptr_t)cmd, "preview cmd" );
d1778 7
a1784 2
	fclose(rtif_fp);
	rtif_fp = NULL;
d1786 6
a1791 6
	cvt_vlblock_to_solids( rtif_vbp, "EYE_PATH", 0 );
	if(rtif_vbp)  {
		rt_vlblock_free(rtif_vbp);
		rtif_vbp = (struct bn_vlblock *)NULL;
	}
	db_free_anim(dbip);	/* Forget any anim commands */
d1793 2
a1794 2
	/* Restore state variables */
	*mged_variables = rtif_saved_state;	/* struct copy */
d1796 1
a1796 1
	(void)mged_svbase();
d1798 2
a1799 2
	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
d1802 2
a1803 1
/*
d1813 12
a1824 1
	CHECK_DBI_NULL;
d1826 1
a1826 4
	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
#ifdef _WIN32
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d1828 45
a1872 4
	    sprintf(buf, "%s/%s", ptr, argv[0]);
#endif
	    argv[0] = buf;
	}
d1874 2
d1877 12
a1888 63
	return dgo_nirt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
#else
	register char **vp;
	FILE *fp_in;
	FILE *fp_out, *fp_err;
	int pid;
	int rpid;
	int retcode;
#ifndef _WIN32
	int pipe_in[2] = {0, 0};
	int pipe_out[2] = {0, 0};
	int pipe_err[2] = {0, 0};
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si = {0};
	PROCESS_INFORMATION pi = {0};
	SECURITY_ATTRIBUTES sa          = {0};
	char name[1024] = {0};
	char line1[2048] = {0};
#endif
	int use_input_orig = 0;
	vect_t	center_model;
	vect_t dir;
	vect_t cml;
	register int i;
	register struct solid *sp;
	char line[RT_MAXLINE] = {0};
	char *val;
	struct bu_vls vls;
	struct bu_vls o_vls;
	struct bu_vls p_vls;
	struct bu_vls t_vls;
	struct bn_vlblock *vbp;
	struct qray_dataList *ndlp;
	struct qray_dataList HeadQRayData;
	char *ptr = (char *)NULL;
	char *buf[256];

	CHECK_DBI_NULL;

	if(argc < 1 || MAXARGS < argc){
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help %s", argv[0]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);

	  return TCL_ERROR;
	}

	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
	    /* argv[0] might be nirt or query_ray, so specify nirt
	     * specifically.
	     */
#ifdef _WIN32
	    sprintf(buf, "\"%s/%s\"", ptr, "nirt");
#else
	    sprintf(buf, "%s/%s", ptr, "nirt");
#endif
	    argv[0] = buf;
	}
d1890 2
a1891 2
	vp = &rt_cmd_vec[0];
	*vp++ = argv[0];
d1893 5
a1897 5
	/* swipe x, y, z off the end if present */
	if(argc > 3){
	  if(sscanf(argv[argc-3], "%lf", &center_model[X]) == 1 &&
	     sscanf(argv[argc-2], "%lf", &center_model[Y]) == 1 &&
	     sscanf(argv[argc-1], "%lf", &center_model[Z]) == 1){
d1901 1
a1901 1
	  }else if(adc_state->adc_draw)
d1903 49
a1951 2
	}else if(adc_state->adc_draw)
	  *vp++ = "-b";
d1953 2
a1954 4
	if(mged_variables->mv_use_air){
	  *vp++ = "-u";
	  *vp++ = "1";
	}
d1956 3
a1958 3
	/* Calculate point from which to fire ray */
	if(!use_input_orig && adc_state->adc_draw){
	  vect_t  view_ray_orig;
d1960 3
a1962 7
	  VSET(view_ray_orig, (fastf_t)adc_state->adc_dv_x, (fastf_t)adc_state->adc_dv_y, GED_MAX);
	  VSCALE(view_ray_orig, view_ray_orig, INV_GED);
	  MAT4X3PNT(center_model, view_state->vs_vop->vo_view2model, view_ray_orig);
	}else if(!use_input_orig){
	  VSET(center_model, -view_state->vs_vop->vo_center[MDX],
	       -view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);
	}
d1964 3
a1966 3
	if( mged_variables->mv_perspective_mode )
	{
		point_t pt, eye;
d1968 3
a1970 45
		/* get eye point */
		VSET(pt, 0.0, 0.0, 1.0);
		MAT4X3PNT(eye, view_state->vs_vop->vo_view2model, pt);
		VSCALE(eye, eye, base2local);

		/* point passed in is actually the aim point */
		VSCALE(cml, center_model, base2local);
		VSUB2(dir, cml, eye);
		VUNITIZE(dir);

		/* copy eye point to cml (cml is used for the "xyz" command to nirt */
		VMOVE(cml, eye);
	} else {
		VSCALE(cml, center_model, base2local);
		VMOVEN(dir, view_state->vs_vop->vo_rotation + 8, 3);
		VSCALE(dir, dir, -1.0);
	}

	bu_vls_init(&p_vls);
	bu_vls_printf(&p_vls, "xyz %lf %lf %lf;",
		cml[X], cml[Y], cml[Z]);
	bu_vls_printf(&p_vls, "dir %lf %lf %lf; s",
		dir[X], dir[Y], dir[Z]);

	i = 0;
	if(QRAY_GRAPHICS){

	  *vp++ = "-e";
	  *vp++ = QRAY_FORMAT_NULL;

	  /* first ray  ---- returns partitions */
	  *vp++ = "-e";
	  *vp++ = QRAY_FORMAT_P;

	  /* ray start, direction, and 's' command */
	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&p_vls);

	  /* second ray  ---- returns overlaps */
	  *vp++ = "-e";
	  *vp++ = QRAY_FORMAT_O;

	  /* ray start, direction, and 's' command */
	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&p_vls);
d1972 1
a1972 1
	  if(QRAY_TEXT){
d1983 1
a1983 1
	      ++val;
d1986 1
a1986 1
	      goto done;
d1988 1
a1988 1
	      ++val;	    /* skip first '"' */
d1994 1
a1994 1
	      count = cp - val;
d1996 2
a1997 1
done:
d1999 1
a1999 4
	    if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
a2000 1
	      if(*val == '\0')
d2002 5
a2006 1
	      else	{
d2009 3
a2011 3
	      if(count)
		val += count + 1;
	      bu_vls_printf(&o_vls, "%s", val);
d2013 1
a2013 1

d2015 1
a2015 1

a2017 1
	  }
d2019 3
d2023 1
a2023 3
	if(QRAY_TEXT){

	  bu_vls_init(&t_vls);
d2025 2
a2026 2
	  /* load vp with formats for printing */
	  for(; qray_fmts[i].type != (char)NULL; ++i)
d2031 2
a2032 2
	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&t_vls);
d2034 3
a2036 3
	  /* nirt does not like the trailing ';' */
	  bu_vls_trunc(&t_vls, -2);
	}
d2038 5
a2042 5
	/* include nirt script string */
	if (bu_vls_strlen(&qray_script)) {
	  *vp++ = "-e";
	  *vp++ = bu_vls_addr(&qray_script);
	}
d2044 2
a2045 2
	*vp++ = "-e";
	*vp++ = bu_vls_addr(&p_vls);
d2047 2
a2048 2
	for( i=1; i < argc; i++ )
		*vp++ = argv[i];
d2050 2
a2051 2
	{
	    char buf[512];
d2053 3
a2055 3
	    sprintf("\"%s\"", dbip->dbi_filename);
	    *vp++ = buf;
	}
d2057 1
a2057 1
	*vp++ = dbip->dbi_filename;
d2060 1
a2060 1
	setup_rt( vp, qray_cmd_echo );
d2062 12
a2073 11
	if(use_input_orig){
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "\nFiring from (%lf, %lf, %lf)...\n",
			center_model[X], center_model[Y], center_model[Z]);
	  Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	  bu_vls_free(&vls);
	}else if(adc_state->adc_draw)
	  Tcl_AppendResult(interp, "\nFiring through angle/distance cursor...\n",
			   (char *)NULL);
	else
	  Tcl_AppendResult(interp, "\nFiring from view center...\n", (char *)NULL);
d2076 88
a2163 88
	(void)pipe( pipe_in );
	(void)pipe( pipe_out );
	(void)pipe( pipe_err );
	(void)signal( SIGINT, SIG_IGN );
	if ( ( pid = fork()) == 0 )  {
		/* Redirect stdin, stdout, stderr */
		(void)close(0);
		(void)dup( pipe_in[0] );
		(void)close(1);
		(void)dup( pipe_out[1] );
		(void)close(2);
		(void)dup ( pipe_err[1] );

		/* close pipes */
		(void)close(pipe_in[0]);
		(void)close(pipe_in[1]);
		(void)close(pipe_out[0]);
		(void)close(pipe_out[1]);
		(void)close(pipe_err[0]);
		(void)close(pipe_err[1]);
		for( i=3; i < 20; i++ )
			(void)close(i);
		(void)signal( SIGINT, SIG_DFL );
		(void)execvp( rt_cmd_vec[0], rt_cmd_vec );
		perror( rt_cmd_vec[0] );
		exit(16);
	}

	/* use fp_in to feed view info to nirt */
	(void)close( pipe_in[0] );
	fp_in = fdopen( pipe_in[1], "w" );

	/* use fp_out to read back the result */
	(void)close( pipe_out[1] );
	fp_out = fdopen( pipe_out[0], "r" );

	/* use fp_err to read any error messages */
	(void)close( pipe_err[1] );
	fp_err = fdopen( pipe_err[0], "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );
#else
	sa.nLength = sizeof(sa);
	sa.bInheritHandle = TRUE;
	sa.lpSecurityDescriptor = NULL;

	/* Save the handle to the current STDOUT. */
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);

	/* Create a pipe for the child process's STDOUT. */
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	/* Set a write handle to the pipe to be STDOUT. */
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);

	/* Create noninheritable read handle and close the inheritable read handle. */
	DuplicateHandle( GetCurrentProcess(), pipe_out[0],
	GetCurrentProcess(),  &pipe_outDup ,
		0,  FALSE,
	DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );

	/* Save the handle to the current STDERR. */
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);

	/* Create a pipe for the child process's STDERR. */
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	/* Set a write handle to the pipe to be STDERR. */
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);

	/* Create noninheritable read handle and close the inheritable read handle. */
	DuplicateHandle( GetCurrentProcess(), pipe_err[0],
	GetCurrentProcess(),  &pipe_errDup ,
		0,  FALSE,
	DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );

	/* The steps for redirecting child process's STDIN:
	 *     1.  Save current STDIN, to be restored later.
	 *     2.  Create anonymous pipe to be STDIN for child process.
	 *     3.  Set STDIN of the parent to be the read handle to the
	 *         pipe, so it is inherited by the child process.
	 *     4.  Create a noninheritable duplicate of the write handle,
	 *         and close the inheritable write handle.
	 */
d2165 2
a2166 2
	/* Save the handle to the current STDIN. */
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);
d2168 29
a2196 29
	/* Create a pipe for the child process's STDIN. */
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);
	/* Set a read handle to the pipe to be STDIN. */
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
	/* Duplicate the write handle to the pipe so it is not inherited. */
	DuplicateHandle(GetCurrentProcess(), pipe_in[1],
			GetCurrentProcess(), &pipe_inDup,
			0, FALSE,                  /* not inherited */
			DUPLICATE_SAME_ACCESS );
	CloseHandle(pipe_in[1]);


	si.cb = sizeof(STARTUPINFO);
	si.lpReserved = NULL;
	si.lpReserved2 = NULL;
	si.cbReserved2 = 0;
	si.lpDesktop = NULL;
	si.dwFlags = 0;
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdInput   = pipe_in[0];
	si.hStdOutput  = pipe_out[1];
	si.hStdError   = pipe_err[1];


	sprintf(line1,"%s ",rt_cmd_vec[0]);
	for(i=1;i<rt_cmd_vec_len;i++) {
	  sprintf(name,"%s ",rt_cmd_vec[i]);
	  strcat(line1,name);
	  if(strstr(name,"-e") != NULL) {
d2200 1
a2200 1
	}
d2202 5
a2206 15
	if(CreateProcess( NULL, line1, NULL, NULL,TRUE, DETACHED_PROCESS, NULL, NULL, &si, &pi )) {
	  SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	  SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	  SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
	}

	/* use fp_in to feed view info to nirt */
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	/*fp_in = fdopen( pipe_in[1], "w" ); */

	/* use fp_out to read back the result */
	CloseHandle( pipe_out[1] );
	/*fp_out = fdopen( pipe_out[0], "r" ); */
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );
d2208 18
a2225 8
	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	/*fp_err = fdopen( pipe_err[0], "r" ); */
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose( fp_in );
d2228 2
a2229 2
	bu_vls_free(&p_vls);   /* use to form "partition" part of nirt command above */
	if(QRAY_GRAPHICS){
d2231 1
a2231 1
	  if(QRAY_TEXT)
d2234 1
a2234 1
	  BU_LIST_INIT(&HeadQRayData.l);
d2236 2
a2237 2
	  /* handle partitions */
	  while(bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL){
d2239 2
a2240 2
	      Tcl_AppendResult(interp, line+1, (char *)NULL);
	      break;
d2248 2
a2249 2
	      break;
	  }
d2251 5
a2255 5
	  vbp = rt_vlblock_init();
	  qray_data_to_vlist(vbp, &HeadQRayData, dir, 0);
	  bu_list_free(&HeadQRayData.l);
	  cvt_vlblock_to_solids(vbp, bu_vls_addr(&qray_basename), 0);
	  rt_vlblock_free(vbp);
d2257 2
a2258 2
	  /* handle overlaps */
	  while(bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL){
d2260 2
a2261 2
	      Tcl_AppendResult(interp, line+1, (char *)NULL);
	      break;
d2269 7
a2275 7
	      break;
	  }
	  vbp = rt_vlblock_init();
	  qray_data_to_vlist(vbp, &HeadQRayData, dir, 1);
	  bu_list_free(&HeadQRayData.l);
	  cvt_vlblock_to_solids(vbp, bu_vls_addr(&qray_basename), 0);
	  rt_vlblock_free(vbp);
d2277 2
a2278 2
	  update_views = 1;
	}
d2280 2
a2281 2
	if(QRAY_TEXT){
	  bu_vls_free(&t_vls);
d2283 1
a2283 1
	  while(bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL)
d2285 1
a2285 1
	}
d2287 1
a2287 1
	(void)fclose(fp_out);
d2289 3
a2291 3
	while(bu_fgets(line, RT_MAXLINE, fp_err) != (char *)NULL)
	  Tcl_AppendResult(interp, line, (char *)NULL);
	(void)fclose(fp_err);
d2295 3
a2297 3
	/* Wait for program to finish */
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;	/* NULL */
d2299 2
a2300 2
	if( retcode != 0 )
		pr_wait_status( retcode );
d2302 2
a2303 2
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );
d2308 1
a2308 1
	(void)signal(SIGINT, cur_sigint);
d2311 2
a2312 2
	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;
d2314 1
a2314 1
	return TCL_OK;
d2318 1
d2324 14
a2337 6
	CHECK_DBI_NULL;

	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
#ifdef _WIN32
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
d2339 21
a2359 4
	    sprintf(buf, "%s/%s", ptr, argv[0]);
#endif
	    argv[0] = buf;
	}
d2361 13
d2375 4
a2378 14
	return dgo_vnirt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
#else
  register int i;
  int status;
  fastf_t sf = 1.0 * INV_GED;
  vect_t view_ray_orig;
  vect_t center_model;
  struct bu_vls vls;
  struct bu_vls x_vls;
  struct bu_vls y_vls;
  struct bu_vls z_vls;
  char **av;

  CHECK_DBI_NULL;
d2380 1
a2380 5
  if(argc < 3){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
d2382 29
a2410 2
    return TCL_ERROR;
  }
d2412 1
a2412 52
  /*
   * The last two arguments are expected to be x,y in view coordinates.
   * It is also assumed that view z will be the front of the viewing cube.
   * These coordinates are converted to x,y,z in model coordinates and then
   * converted to local units before being handed to nirt. All other
   * arguments are passed straight through to nirt.
   */
  if(sscanf(argv[argc-2], "%lf", &view_ray_orig[X]) != 1 ||
     sscanf(argv[argc-1], "%lf", &view_ray_orig[Y]) != 1){
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help %s", argv[0]);
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);

    return TCL_ERROR;
  }
  view_ray_orig[Z] = GED_MAX;
  argc -= 2;

  av = (char **)bu_malloc(sizeof(char *) * (argc + 4), "f_vnirt: av");

  /* Calculate point from which to fire ray */
  VSCALE(view_ray_orig, view_ray_orig, sf);
  MAT4X3PNT(center_model, view_state->vs_vop->vo_view2model, view_ray_orig);
  VSCALE(center_model, center_model, base2local);

  bu_vls_init(&x_vls);
  bu_vls_init(&y_vls);
  bu_vls_init(&z_vls);
  bu_vls_printf(&x_vls, "%lf", center_model[X]);
  bu_vls_printf(&y_vls, "%lf", center_model[Y]);
  bu_vls_printf(&z_vls, "%lf", center_model[Z]);

  /* pass remaining arguments to nirt */
  av[0] = "nirt";
  for(i = 1; i < argc; ++i)
    av[i] = argv[i];

  /* pass modified coordinates to nirt */
  av[i++] = bu_vls_addr(&x_vls);
  av[i++] = bu_vls_addr(&y_vls);
  av[i++] = bu_vls_addr(&z_vls);
  av[i] = (char *)NULL;

  status = f_nirt(clientData, interp, argc + 3, av);

  bu_vls_free(&x_vls);
  bu_vls_free(&y_vls);
  bu_vls_free(&z_vls);
  bu_free((genptr_t)av, "f_vnirt: av");

  return status;
d2416 1
d2420 5
a2424 5
	if( argc < 2 )
		return(-1);
	rtif_currentframe = atoi(argv[1]);
	tree_walk_needed = 0;
	return(0);
d2427 1
d2431 7
a2437 7
	if( argc < 2 )
		return(-1);
	/* for some reason, scale is supposed to be half of size... */
	view_state->vs_vop->vo_size = atof(argv[1]);
	view_state->vs_vop->vo_scale = view_state->vs_vop->vo_size * 0.5;
	view_state->vs_vop->vo_invSize = 1.0 / view_state->vs_vop->vo_size;
	return(0);
d2440 1
d2444 7
a2450 7
	if( argc < 4 )
		return(-1);
	rtif_eye_model[X] = atof(argv[1]);
	rtif_eye_model[Y] = atof(argv[2]);
	rtif_eye_model[Z] = atof(argv[3]);
	/* Processing is deferred until cm_end() */
	return(0);
d2453 1
d2457 2
a2458 2
	point_t	pt;
	vect_t	dir;
d2460 5
a2464 5
	if( argc < 4 )
		return(-1);
	pt[X] = atof(argv[1]);
	pt[Y] = atof(argv[2]);
	pt[Z] = atof(argv[3]);
d2466 2
a2467 2
	VSUB2( dir, pt, rtif_eye_model );
	VUNITIZE( dir );
d2470 6
a2475 6
	/*
	   At the moment bn_mat_lookat will return NAN's if the direction vector
	   is aligned with the Z axis. The following is a temporary workaround.
	 */
	{
	  vect_t neg_Z_axis;
d2477 3
a2479 3
	  VSET(neg_Z_axis, 0.0, 0.0, -1.0);
	  bn_mat_fromto( rtif_viewrot, dir, neg_Z_axis);
	}
d2481 1
a2481 1
	bn_mat_lookat( rtif_viewrot, dir, yflip );
d2484 4
a2487 4
	/*  Final processing is deferred until cm_end(), but eye_pt
	 *  must have been specified before here (for now)
	 */
	return(0);
d2490 1
d2494 1
a2494 1
	register int	i;
d2496 6
a2501 6
	if( argc < 17 )
		return(-1);
	for( i=0; i<16; i++ )
		rtif_viewrot[i] = atof(argv[i+1]);
	/* Processing is deferred until cm_end() */
	return(0);
d2504 1
d2508 2
a2509 2
	register int	i;
	quat_t		quat;
d2511 4
a2514 4
	for( i=0; i<4; i++ )
		quat[i] = atof( argv[i+1] );
	quat_quat2mat( rtif_viewrot, quat );
	return(0);
d2517 2
a2518 1
/*
d2524 34
a2557 34
	vect_t	xlate;
	vect_t	new_cent;
	vect_t	xv, yv;			/* view x, y */
	vect_t	xm, ym;			/* model x, y */
	struct bu_list		*vhead = &rtif_vbp->head[0];

	/* Only display the frames the user is interested in */
	if( rtif_currentframe < rtif_desiredframe )  return 0;
	if( rtif_finalframe && rtif_currentframe > rtif_finalframe )  return 0;

	/* Record eye path as a polyline.  Move, then draws */
	if( BU_LIST_IS_EMPTY( vhead ) )  {
		RT_ADD_VLIST( vhead, rtif_eye_model, BN_VLIST_LINE_MOVE );
	} else {
		RT_ADD_VLIST( vhead, rtif_eye_model, BN_VLIST_LINE_DRAW );
	}

	/* First step:  put eye at view center (view 0,0,0) */
	MAT_COPY(view_state->vs_vop->vo_rotation, rtif_viewrot);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, rtif_eye_model);
	new_mats();

	/*
	 * Compute camera orientation notch to right (+X) and up (+Y)
	 * Done here, with eye in center of view.
	 */
	VSET(xv, 0.05, 0.0, 0.0);
	VSET(yv, 0.0, 0.05, 0.0);
	MAT4X3PNT(xm, view_state->vs_vop->vo_view2model, xv);
	MAT4X3PNT(ym, view_state->vs_vop->vo_view2model, yv);
	RT_ADD_VLIST(vhead, xm, BN_VLIST_LINE_DRAW);
	RT_ADD_VLIST(vhead, rtif_eye_model, BN_VLIST_LINE_MOVE);
	RT_ADD_VLIST(vhead, ym, BN_VLIST_LINE_DRAW);
	RT_ADD_VLIST(vhead, rtif_eye_model, BN_VLIST_LINE_MOVE);
d2559 11
a2569 11
	/*  Second step:  put eye at view 0,0,1.
	 *  For eye to be at 0,0,1, the old 0,0,-1 needs to become 0,0,0.
	 */
	VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
	MAT4X3PNT(new_cent, view_state->vs_vop->vo_view2model, xlate);
	MAT_DELTAS_VEC_NEG(view_state->vs_vop->vo_center, new_cent);
	new_mats();

	/* If new treewalk is needed, get new objects into view. */
	if( tree_walk_needed )  {
	  char *av[2];
d2571 2
a2572 2
	  av[0] = "Z";
	  av[1] = NULL;
d2574 3
a2576 3
	  (void)cmd_zap( (ClientData)NULL, interp, 1, av );
	  edit_com( rt_cmd_vec_len, rt_cmd_vec, rtif_mode, 0 );
	}
d2578 14
a2591 14
	view_state->vs_flag = 1;
	refresh();	/* Draw new display */
	view_state->vs_flag = 1;
	if( rtif_delay > 0 )  {
		struct timeval tv;
		fd_set readfds;

		FD_ZERO(&readfds);
		FD_SET(fileno(stdin), &readfds);
		tv.tv_sec = (long)rtif_delay;
		tv.tv_usec = (long)((rtif_delay - tv.tv_sec) * 1000000);
		select( fileno(stdin)+1, &readfds, (fd_set *)0, (fd_set *)0, &tv );
	}
	return(0);
d2594 1
d2598 1
a2598 1
	return(-1);
d2601 2
a2602 1
/*
d2611 2
a2612 2
  if(dbip == DBI_NULL)
    return 0;
d2614 4
a2617 4
  if( db_parse_anim( dbip, argc, (const char **)argv ) < 0 )  {
    Tcl_AppendResult(interp, "cm_anim:  ", argv[1], " ", argv[2], " failed\n", (char *)NULL);
    return(-1);		/* BAD */
  }
d2619 1
a2619 1
  tree_walk_needed = 1;
d2621 1
a2621 1
  return(0);
d2624 2
a2625 1
/*
d2633 2
a2634 2
	register int	i = 1;
	char *cp = rt_cmd_storage;
d2636 7
a2642 7
	for( i = 1;  i < argc && i < MAXARGS; i++ )  {
		strcpy(cp, argv[i]);
		rt_cmd_vec[i] = cp;
		cp += strlen(cp) + 1;
	}
	rt_cmd_vec[i] = (char *)0;
	rt_cmd_vec_len = i;
d2644 1
a2644 1
	tree_walk_needed = 1;
d2646 1
a2646 1
	return(0);
d2649 2
a2650 1
/*
d2658 2
a2659 2
	if(dbip == DBI_NULL)
	  return 0;
d2661 1
a2661 1
	/*f_zap( (ClientData)NULL, interp, 0, (char **)0 );*/
d2663 2
a2664 2
	/* Free animation structures */
	db_free_anim(dbip);
d2666 2
a2667 2
	tree_walk_needed = 1;
	return 0;
d2673 1
a2673 1
	return(-1);
d2696 1
a2696 1
      struct bu_vls vls;
d2698 5
a2702 5
      bu_vls_init(&vls);
      bu_vls_printf(&vls, "helpdevel solids_on_ray");
      Tcl_Eval(interp, bu_vls_addr(&vls));
      bu_vls_free(&vls);
      return TCL_ERROR;
d2706 4
a2709 4
    {
	Tcl_AppendResult(interp, "Usage: 'solids_on_ray [h v]'", (char *)NULL);
	return (TCL_ERROR);
    }
d2712 5
a2716 5
      || (Tcl_GetInt(interp, argv[2], &v) != TCL_OK)))
    {
	Tcl_AppendResult(interp, "\nUsage: 'solids_on_ray h v'", NULL);
	return (TCL_ERROR);
    }
d2719 5
a2723 5
    {
	Tcl_AppendResult(interp, "Screen coordinates out of range\n",
	    "Must be between +/-2048", NULL);
	return (TCL_ERROR);
    }
d2726 1
a2726 1
	-view_state->vs_vop->vo_center[MDY], -view_state->vs_vop->vo_center[MDZ]);
d2732 4
a2735 4
    {
	extremum[0][i] = INFINITY;
	extremum[1][i] = -INFINITY;
    }
d2737 1
a2737 1
    {
d2746 1
a2746 1
    }
a2757 3
    {
	t_in = -INFINITY;
	for (i = 0; i < 6; ++i)
d2759 11
a2769 6
	    if (ray_dir[i%3] == 0)
		continue;
	    t = (extremum[i/3][i%3] - ray_orig[i%3]) /
		    ray_dir[i%3];
	    if ((t < 0) && (t > t_in))
		t_in = t;
a2770 2
	VJOIN1(ray_orig, ray_orig, t_in, ray_dir);
    }
d2788 6
a2793 6
    {
	Tcl_AppendResult(interp, "Error executing skewer_solids: ", (char *)NULL);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);
	return (TCL_ERROR);
    }
d2806 1
a2806 1
/*
d2812 1
a2812 1
	CHECK_DBI_NULL;
d2814 1
a2814 1
	return dgo_who_cmd(dgop, interp, argc, argv);
d2817 3
a2819 1
/* any commands that are not supported or implemented may call this null
d2823 1
a2823 3
cm_null(argc, argv)
char	**argv;
int	argc;
d2825 1
a2825 1
  return(0);
@


14.24
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.23 2007/01/26 03:33:44 brlcad Exp $ (BRL)";
d2227 1
a2227 1
	  while(fgets(line, RT_MAXLINE, fp_out) != (char *)NULL){
d2248 1
a2248 1
	  while(fgets(line, RT_MAXLINE, fp_out) != (char *)NULL){
d2273 1
a2273 1
	  while(fgets(line, RT_MAXLINE, fp_out) != (char *)NULL)
d2279 1
a2279 1
	while(fgets(line, RT_MAXLINE, fp_err) != (char *)NULL)
@


14.23
log
@simplify, use MAT_DELTAS_VEC_NEG when setting translation elements to negative vector values
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.22 2007/01/23 01:13:42 brlcad Exp $ (BRL)";
d199 1
a199 1
	        0,		0, 0	/* END */}
d436 1
a436 1
		
d451 1
a451 1
 		BU_LIST_DEQUEUE(&run_rtp->l);
d501 1
a501 1
 		BU_LIST_DEQUEUE(&run_rtp->l);
d680 1
a680 1
        GetCurrentProcess(),  &pipe_errDup ,
d682 1
a682 1
        DUPLICATE_SAME_ACCESS );
d728 9
a736 9
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {
d1440 1
a1440 1
        if( setjmp( jmp_env ) == 0 )
d1442 1
a1442 1
        else
d1447 5
a1451 5
	    	switch(mode)  {
	    	case -1:
	    		/* First step:  put eye in center */
		       	view_state->vs_vop->vo_scale = scale;
		       	MAT_COPY(view_state->vs_vop->vo_rotation, rot);
d1453 4
a1456 4
	    		new_mats();
	    		/* Second step:  put eye in front */
	    		VSET(xlate, 0.0, 0.0, -1.0);	/* correction factor */
	    		MAT4X3PNT(eye_model, view_state->vs_vop->vo_view2model, xlate);
d1458 4
a1461 4
	    		new_mats();
	    		break;
	    	case 0:
		       	view_state->vs_vop->vo_scale = scale;
d1465 4
a1468 4
	    		break;
	    	case 1:
	    		/* Adjust center for displaylist devices */
	    		VMOVE( sp->s_center, eye_model );
d1470 2
a1471 2
	    		/* Adjust vector list for non-dl devices */
	    		if( BU_LIST_IS_EMPTY( &(sp->s_vlist) ) )  break;
d1473 1
a1473 1
	    		VSUB2( xlate, eye_model, vp->pt[vp->nused-1] );
d1494 2
a1495 2
	    		break;
	    	}
d1500 1
a1500 1
    		VMOVE( sp->s_center, sav_center );
d1503 1
a1503 1
	    		VSUB2( xlate, sav_start, vp->pt[vp->nused-1] );
d1767 1
a1767 1
			    	continue;
d2035 2
a2036 2
        *vp++ = "-e";
        *vp++ = bu_vls_addr(&p_vls);
d2071 1
a2071 1
 	        /* Redirect stdin, stdout, stderr */
d2125 1
a2125 1
        GetCurrentProcess(),  &pipe_outDup ,
d2127 1
a2127 1
        DUPLICATE_SAME_ACCESS );
d2141 1
a2141 1
        GetCurrentProcess(),  &pipe_errDup ,
d2143 1
a2143 1
        DUPLICATE_SAME_ACCESS );
d2689 1
a2689 1
        ((Tcl_GetInt(interp, argv[1], &h) != TCL_OK)
@


14.22
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.21 2007/01/20 14:36:57 brlcad Exp $ (BRL)";
d1452 1
a1452 4
			MAT_DELTAS(view_state->vs_vop->vo_center,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
d1457 1
a1457 4
			MAT_DELTAS(view_state->vs_vop->vo_center,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
d1463 1
a1463 4
			MAT_DELTAS( view_state->vs_vop->vo_center,
				-eye_model[X],
				-eye_model[Y],
				-eye_model[Z] );
@


14.21
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.20 2006/07/09 19:17:16 brlcad Exp $ (BRL)";
@


14.20
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2006 United States Government as represented by
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.19 2006/07/09 18:25:32 brlcad Exp $ (BRL)";
@


14.19
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.18 2006/04/06 20:50:03 brlcad Exp $ (BRL)";
d663 2
a664 2
   char line[2048];
   char name[256];
d892 1
a892 1
  char line[RT_MAXLINE] = {0};
d1148 3
a1150 2
	char dbName[512];
	char objects[1024];
d1219 1
a1219 1
		  memset(dbName, 0, 1024);
d1836 3
a1838 3
	int pipe_in[2];
	int pipe_out[2];
	int pipe_err[2];
d1846 2
a1847 2
	char name[1024];
	char line1[2048];
d1855 1
a1855 1
	char line[MAXLINE];
d1864 2
a1865 1
	char *ptr, buf[256] = {0};
d2237 1
a2237 1
	  while(fgets(line, MAXLINE, fp_out) != (char *)NULL){
d2258 1
a2258 1
	  while(fgets(line, MAXLINE, fp_out) != (char *)NULL){
d2283 1
a2283 1
	  while(fgets(line, MAXLINE, fp_out) != (char *)NULL)
d2289 1
a2289 1
	while(fgets(line, MAXLINE, fp_err) != (char *)NULL)
@


14.18
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.17 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
d429 1
a429 1
	char line[RT_MAXLINE+1];
d432 2
a433 1
	if ((count = read((int)run_rtp->fd, line, RT_MAXLINE)) == 0) {
d437 4
d892 1
a892 1
  char line[RT_MAXLINE];
d896 8
a903 9
#if 0
  if((count = read((int)fd, line, RT_MAXLINE)) == 0){
#else
  if((count = read((int)fd, line, 5120)) == 0){
#endif
    Tcl_DeleteFileHandler(fd);
    close(fd);

    return;
@


14.17
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.16 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d66 6
@


14.17.2.1
log
@update from HEAD
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.17 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
a65 6
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
@


14.16
log
@update copyright to 2006
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.15 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d53 1
@


14.15
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1988-2005 United States Government as represented by
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.14 2005/11/07 04:42:34 brlcad Exp $ (BRL)";
@


14.14
log
@don't presume that nirt is in the path, invoke it from the brlcad bin search order like the other commands
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.13 2005/11/07 01:07:50 brlcad Exp $ (BRL)";
d1800 17
d2302 1
d2308 17
d2399 1
@


14.13
log
@sanity check for null rt_cmd_vec
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.12 2005/10/31 07:30:58 brlcad Exp $ (BRL)";
d582 1
a582 1
	if (strlen(rt_cmd_vec) <= 0) {
d1835 1
d1848 13
d1862 1
a1862 1
	*vp++ = "nirt";
@


14.12
log
@header cleanup, reorg, and general bug squashing including adding missing headers
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.11 2005/10/31 07:04:00 brlcad Exp $ (BRL)";
d582 4
@


14.11
log
@remove unused chan1 var
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.10 2005/10/30 21:58:57 brlcad Exp $ (BRL)";
d65 3
@


14.10
log
@remove C++-style // comments as there's no assumption of c99 compiler compliance yet, only c89 (mostly aix compiler though other old compilers too)
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.9 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
a114 5
#ifdef TCL_OK
	Tcl_Channel chan1;
#else
	genptr_t chan1;
#endif
@


14.9
log
@trailing ws
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.8 2005/09/16 18:51:53 brlcad Exp $ (BRL)";
a114 1
//Tcl_Channel chan;
d656 1
a656 1
	// Save the handle to the current STDOUT.
d659 1
a659 1
	// Create a pipe for the child process's STDOUT.
d662 1
a662 1
	// Set a write handle to the pipe to be STDOUT.
d665 1
a665 1
	// Create noninheritable read handle and close the inheritable read handle.
d672 8
a679 7
	// The steps for redirecting child process's STDIN:
	//     1.  Save current STDIN, to be restored later.
	//     2.  Create anonymous pipe to be STDIN for child process.
	//     3.  Set STDIN of the parent to be the read handle to the
	//         pipe, so it is inherited by the child process.
	//     4.  Create a noninheritable duplicate of the write handle,
	//         and close the inheritable write handle.
d681 1
a681 1
	// Save the handle to the current STDIN.
d684 1
a684 1
	// Create a pipe for the child process's STDIN.
d686 1
a686 1
	// Set a read handle to the pipe to be STDIN.
d688 1
a688 1
	// Duplicate the write handle to the pipe so it is not inherited.
d691 1
a691 1
		0, FALSE,                  // not inherited
d2078 1
a2078 1
	// Save the handle to the current STDOUT.
d2081 1
a2081 1
	// Create a pipe for the child process's STDOUT.
d2084 1
a2084 1
	// Set a write handle to the pipe to be STDOUT.
d2087 1
a2087 1
	// Create noninheritable read handle and close the inheritable read handle.
d2094 1
a2094 1
	// Save the handle to the current STDERR.
d2097 1
a2097 1
	// Create a pipe for the child process's STDERR.
d2100 1
a2100 1
	// Set a write handle to the pipe to be STDERR.
d2103 1
a2103 1
	// Create noninheritable read handle and close the inheritable read handle.
d2110 8
a2117 7
	// The steps for redirecting child process's STDIN:
	//     1.  Save current STDIN, to be restored later.
	//     2.  Create anonymous pipe to be STDIN for child process.
	//     3.  Set STDIN of the parent to be the read handle to the
	//         pipe, so it is inherited by the child process.
	//     4.  Create a noninheritable duplicate of the write handle,
	//         and close the inheritable write handle.
d2119 1
a2119 1
	// Save the handle to the current STDIN.
d2122 1
a2122 1
	// Create a pipe for the child process's STDIN.
d2124 1
a2124 1
	// Set a read handle to the pipe to be STDIN.
d2126 1
a2126 1
	// Duplicate the write handle to the pipe so it is not inherited.
d2129 1
a2129 1
			0, FALSE,                  // not inherited
d2165 1
a2165 1
	//fp_in = fdopen( pipe_in[1], "w" );
d2169 1
a2169 1
	//fp_out = fdopen( pipe_out[0], "r" );
d2174 1
a2174 1
	//fp_err = fdopen( pipe_err[0], "r" );
@


14.8
log
@rework tkwin into cmd.c and profide the DM_X and DM_OGL defines to the build.  probably fixes a bug or two of some sort on the display manager.  also migrate the tolerance vars together along with other ws and header cleanup
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.7 2005/07/08 00:27:51 brlcad Exp $ (BRL)";
d107 1
a107 1
       int			fd;    
d113 1
a113 1
       double			csize;  
d150 1
a150 1
 * view restoration. 
d189 1
a189 1
	 * script files. 
d238 1
a238 1
 *  
d263 1
a263 1
 *  
d313 1
a313 1
 *  
d471 1
a471 1
	
d484 1
a484 1
		
d487 1
a487 1
			run_rtp->aborted = 1; 
d582 1
a582 1
	int		pid; 	 
d657 4
a660 4
	// Save the handle to the current STDOUT.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
d663 2
a664 2
	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  
d666 1
a666 1
	// Create noninheritable read handle and close the inheritable read handle. 
d668 1
a668 1
        GetCurrentProcess(),  &pipe_errDup , 
a671 8
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  
d673 7
a679 2
	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  
d681 4
a684 1
	// Create a pipe for the child process's STDIN.  
d686 1
a686 1
	// Set a read handle to the pipe to be STDIN.  
d688 6
a693 6
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 
d712 1
a712 1
	   
d1010 1
a1010 1
 *  
d1024 1
a1024 1
	for(p3=suff; *p3; p3++) 
d1108 1
a1108 1
	
d1119 2
a1120 2
 *  Load a ray-trace view shell script.  If a database is not open, the 
 *  database listed in the script will attempted to be opened.  If a 
d1151 1
a1151 1
	
d1197 2
a1198 2
		  /* !!! this does not update the menu variable.. */	
		  set_perspective(); 
d1202 1
a1202 1
		   * after that 
d1207 1
a1207 1
		  /* if the last character is a line termination, 
d1215 1
a1215 1
		  
d1228 1
a1228 1
		    
d1238 1
a1238 1
		      
d1248 1
a1248 1
		    
d1251 1
a1251 1
		    
d1254 1
a1254 1
		    
d1260 1
a1260 1
		      
d1264 1
a1264 1
		      
d1267 1
a1267 1
		    
d1270 1
a1270 1
		  
d1294 1
a1294 1
		    
d1303 1
a1303 1
			
d1308 1
a1308 1
		    if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) { 
d1330 1
a1330 1
	
d2078 4
a2081 4
	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
	// Create a pipe for the child process's STDOUT.  
d2084 2
a2085 2
	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  
d2087 1
a2087 1
	// Create noninheritable read handle and close the inheritable read handle. 
d2089 1
a2089 1
        GetCurrentProcess(),  &pipe_outDup , 
d2094 4
a2097 4
	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
	// Create a pipe for the child process's STDERR.  
d2100 2
a2101 2
	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  
d2103 1
a2103 1
	// Create noninheritable read handle and close the inheritable read handle. 
d2105 1
a2105 1
        GetCurrentProcess(),  &pipe_errDup , 
a2108 8
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  
d2110 7
a2116 2
	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  
d2118 4
a2121 1
	// Create a pipe for the child process's STDIN.  
d2123 1
a2123 1
	// Set a read handle to the pipe to be STDIN.  
d2125 6
a2130 6
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
			GetCurrentProcess(), &pipe_inDup, 
			0, FALSE,                  // not inherited       
			DUPLICATE_SAME_ACCESS ); 
	CloseHandle(pipe_in[1]); 
d2148 1
a2148 1
	  strcat(line1,name); 
d2152 1
a2152 1
	    strcat(line1,name);} 
d2160 1
a2160 1
 
d2510 1
a2510 1
	
d2703 1
a2703 1
    
d2721 1
a2721 1
    
d2731 1
a2731 1
int 
@


14.7
log
@use bu_brlcad_root now for bin dirs and bu_brlcad_data for data dirs
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.6 2005/06/24 23:23:20 brlcad Exp $ (BRL)";
a76 1
#include "./mgedtcl.h"
@


14.7.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a64 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
d77 1
d108 1
a108 1
       int			fd;
d114 1
a114 1
       double			csize;
d116 6
d151 1
a151 1
 * view restoration.
d190 1
a190 1
	 * script files.
d239 1
a239 1
 *
d264 1
a264 1
 *
d314 1
a314 1
 *
d472 1
a472 1

d485 1
a485 1

d488 1
a488 1
			run_rtp->aborted = 1;
d583 1
a583 1
	int		pid;
a585 4
	if (strlen(rt_cmd_vec[0]) <= 0) {
	    return -1;
	}

d658 4
a661 4
	/* Save the handle to the current STDOUT. */
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);

	/* Create a pipe for the child process's STDOUT. */
d664 2
a665 2
	/* Set a write handle to the pipe to be STDOUT. */
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);
d667 1
a667 1
	/* Create noninheritable read handle and close the inheritable read handle. */
d669 1
a669 1
        GetCurrentProcess(),  &pipe_errDup ,
d673 8
d682 2
a683 11
	/* The steps for redirecting child process's STDIN:
	 *     1.  Save current STDIN, to be restored later.
	 *     2.  Create anonymous pipe to be STDIN for child process.
	 *     3.  Set STDIN of the parent to be the read handle to the
	 *         pipe, so it is inherited by the child process.
	 *     4.  Create a noninheritable duplicate of the write handle,
	 *         and close the inheritable write handle.
	 */

	/* Save the handle to the current STDIN. */
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);
d685 1
a685 1
	/* Create a pipe for the child process's STDIN. */
d687 1
a687 1
	/* Set a read handle to the pipe to be STDIN. */
d689 6
a694 6
	/* Duplicate the write handle to the pipe so it is not inherited. */
	DuplicateHandle(GetCurrentProcess(), pipe_in[1],
		GetCurrentProcess(), &pipe_inDup,
		0, FALSE,                  /* not inherited */
		DUPLICATE_SAME_ACCESS );
	CloseHandle(pipe_in[1]);
d713 1
a713 1

d1011 1
a1011 1
 *
d1025 1
a1025 1
	for(p3=suff; *p3; p3++)
d1109 1
a1109 1

d1120 2
a1121 2
 *  Load a ray-trace view shell script.  If a database is not open, the
 *  database listed in the script will attempted to be opened.  If a
d1152 1
a1152 1

d1198 2
a1199 2
		  /* !!! this does not update the menu variable.. */
		  set_perspective();
d1203 1
a1203 1
		   * after that
d1208 1
a1208 1
		  /* if the last character is a line termination,
d1216 1
a1216 1

d1229 1
a1229 1

d1239 1
a1239 1

d1249 1
a1249 1

d1252 1
a1252 1

d1255 1
a1255 1

d1261 1
a1261 1

d1265 1
a1265 1

d1268 1
a1268 1

d1271 1
a1271 1

d1295 1
a1295 1

d1304 1
a1304 1

d1309 1
a1309 1
		    if ( rt_do_cmd( (struct rt_i *)0, cmdBuffer, view_cmdtab ) < 0 ) {
d1331 1
a1331 1

a1833 1
	char *ptr, buf[256] = {0};
a1845 13
	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
	    /* argv[0] might be nirt or query_ray, so specify nirt
	     * specifically.
	     */
#ifdef _WIN32
	    sprintf(buf, "\"%s/%s\"", ptr, "nirt");
#else
	    sprintf(buf, "%s/%s", ptr, "nirt");
#endif
	    argv[0] = buf;
	}

d1847 1
a1847 1
	*vp++ = argv[0];
d2079 4
a2082 4
	/* Save the handle to the current STDOUT. */
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);

	/* Create a pipe for the child process's STDOUT. */
d2085 2
a2086 2
	/* Set a write handle to the pipe to be STDOUT. */
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);
d2088 1
a2088 1
	/* Create noninheritable read handle and close the inheritable read handle. */
d2090 1
a2090 1
        GetCurrentProcess(),  &pipe_outDup ,
d2095 4
a2098 4
	/* Save the handle to the current STDERR. */
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);

	/* Create a pipe for the child process's STDERR. */
d2101 2
a2102 2
	/* Set a write handle to the pipe to be STDERR. */
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);
d2104 1
a2104 1
	/* Create noninheritable read handle and close the inheritable read handle. */
d2106 1
a2106 1
        GetCurrentProcess(),  &pipe_errDup ,
d2110 8
d2119 2
a2120 11
	/* The steps for redirecting child process's STDIN:
	 *     1.  Save current STDIN, to be restored later.
	 *     2.  Create anonymous pipe to be STDIN for child process.
	 *     3.  Set STDIN of the parent to be the read handle to the
	 *         pipe, so it is inherited by the child process.
	 *     4.  Create a noninheritable duplicate of the write handle,
	 *         and close the inheritable write handle.
	 */

	/* Save the handle to the current STDIN. */
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);
d2122 1
a2122 1
	/* Create a pipe for the child process's STDIN. */
d2124 1
a2124 1
	/* Set a read handle to the pipe to be STDIN. */
d2126 6
a2131 6
	/* Duplicate the write handle to the pipe so it is not inherited. */
	DuplicateHandle(GetCurrentProcess(), pipe_in[1],
			GetCurrentProcess(), &pipe_inDup,
			0, FALSE,                  /* not inherited */
			DUPLICATE_SAME_ACCESS );
	CloseHandle(pipe_in[1]);
d2149 1
a2149 1
	  strcat(line1,name);
d2153 1
a2153 1
	    strcat(line1,name);}
d2161 1
a2161 1

d2165 1
a2165 1
	/*fp_in = fdopen( pipe_in[1], "w" ); */
d2169 1
a2169 1
	/*fp_out = fdopen( pipe_out[0], "r" ); */
d2174 1
a2174 1
	/*fp_err = fdopen( pipe_err[0], "r" ); */
d2511 1
a2511 1

d2704 1
a2704 1

d2722 1
a2722 1

d2732 1
a2732 1
int
@


14.7.2.1
log
@Mods to use nirt from librt
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.7 2005/07/08 00:27:51 brlcad Exp $ (BRL)";
a1798 17
#if 1
    char *ptr, buf[256];
	CHECK_DBI_NULL;

	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
#ifdef _WIN32
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
#else
	    sprintf(buf, "%s/%s", ptr, argv[0]);
#endif
	    argv[0] = buf;
	}


	return dgo_nirt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
#else
a2268 1
#endif
a2273 17
#if 1
    char *ptr, buf[256];
	CHECK_DBI_NULL;

	ptr = bu_brlcad_root("bin", 1);
	if (ptr) {
#ifdef _WIN32
	    sprintf(buf, "\"%s/%s\"", ptr, argv[0]);
#else
	    sprintf(buf, "%s/%s", ptr, argv[0]);
#endif
	    argv[0] = buf;
	}


	return dgo_vnirt_cmd(dgop, view_state->vs_vop, interp, argc, argv);
#else
a2347 1
#endif
@


14.6
log
@add mged commands for rtarea and rtweight.  they all ultimately end up calling dgo_rt_cmd for consistency but retain their own cmd_ hook function.  update the comments to match the functions that were changed from f_ to cmd_ too
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.5 2005/05/28 02:14:52 brlcad Exp $ (BRL)";
d778 1
a778 1
	ptr = bu_brlcad_path("bin", 1);
d913 1
a913 1
	ptr = bu_brlcad_path("bin", 1);
d941 1
a941 1
	ptr = bu_brlcad_path("bin", 1);
d968 1
a968 1
	ptr = bu_brlcad_path("bin", 1);
d995 1
a995 1
	ptr = bu_brlcad_path("bin", 1);
@


14.5
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d26 7
a32 3
 *	f_rt		ray-trace
 *	f_rrt		ray-trace using any program
 *	f_rtcheck	ray-trace to check for overlaps
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.4 2005/03/24 17:32:20 bob1961 Exp $ (BRL)";
d405 5
d419 1
d759 1
d761 1
a761 1
 *			F _ R T
d792 1
a792 1
 *			F _ R R T
d799 1
a799 1
f_rrt(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d899 5
d928 81
d1034 1
@


14.4
log
@If Windows, use double-quotes around pathnames in case there are spaces.
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
a48 2


d51 1
a51 1
#include <string.h>
d53 1
a53 1
#include <strings.h>
d57 1
a57 1
#ifndef WIN32
d77 1
a77 1
#ifdef WIN32
d81 1
a84 4
#ifdef WIN32
#  include <fcntl.h>
#endif

d94 1
a94 1
#ifdef WIN32
d410 1
a410 1
#ifndef WIN32
d560 1
a560 1
#ifndef WIN32
d769 1
a769 1
#ifdef WIN32
d899 1
a899 1
#ifdef WIN32
d1707 1
a1707 1
#ifndef WIN32
d1856 1
a1856 1
#ifndef WIN32
d1907 1
a1907 1
#ifdef WIN32
d1932 1
a1932 1
#ifndef WIN32
d2149 1
a2149 1
#ifndef WIN32
@


14.3
log
@update copyright to 2005
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/rtif.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
d774 3
d778 1
d904 3
d908 1
d1912 8
d1921 1
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2004 United States Government as represented by
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/rtif.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			R T I F . C
a41 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/rtif.c,v 1.6 2004/10/26 20:39:28 butler Exp $ (BRL)";
@


1.6
log
@To eliminate BRLCAD_ROOT, we now use the install directory as defined at compile time.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/rtif.c,v 1.5 2004/09/04 07:27:01 morrison Exp $ (BRL)";
d2625 10
@


1.5
log
@basename redeclared as different kind of symbol due to string.h declaration, so rename our static function to not collide
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/rtif.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
d748 2
d757 6
d880 1
d882 7
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/rtif.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d884 1
a884 1
basename(register char *p1, register char *suff)
d935 1
a935 1
	base = basename( argv[1], ".sh" );
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/rtif.c,v 1.2 2004/06/08 22:04:29 morrison Exp $ (BRL)";
d37 1
a37 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d32 1
a32 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/rtif.c,v 11.108 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a56 1
#include "externs.h"
@

