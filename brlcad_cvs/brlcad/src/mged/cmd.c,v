head	14.62;
access;
symbols
	rel-7-10-4:14.50.2.1
	STABLE:14.50.0.2
	stable-branch:14.5
	rel-7-10-2:14.50
	rel-7-10-0:14.47
	rel-7-8-4:14.41
	rel-7-8-2:14.34
	rel-7-8-0:14.32
	trimnurbs-branch:14.31.0.2
	help:14.31
	temp_tag:14.26
	bobWinPort-20051223-freeze:14.14.2.1
	postmerge-20051223-bobWinPort:14.26
	premerge-20051223-bobWinPort:14.25
	rel-7-6-6:14.25
	rel-7-6-4:14.21
	rel-7-6-2:14.16
	rel-7-6-branch:14.16.0.2
	rel-7-6-0:14.16
	rel-7-4-2:14.12.2.1
	rel-7-4-branch:14.12.0.2
	bobWinPort:14.14.0.2
	rel-7-4-0:14.12
	rel-7-2-6:14.8
	rel-7-2-4:14.5
	rel-7-2-2:14.5
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.62
date	2007.12.22.20.23.28;	author brlcad;	state Exp;
branches;
next	14.61;

14.61
date	2007.12.22.20.20.56;	author brlcad;	state Exp;
branches;
next	14.60;

14.60
date	2007.12.18.19.39.10;	author bob1961;	state Exp;
branches;
next	14.59;

14.59
date	2007.12.16.18.53.50;	author brlcad;	state Exp;
branches;
next	14.58;

14.58
date	2007.12.16.15.59.40;	author brlcad;	state Exp;
branches;
next	14.57;

14.57
date	2007.12.02.22.34.22;	author brlcad;	state Exp;
branches;
next	14.56;

14.56
date	2007.11.21.15.52.58;	author erikgreenwald;	state Exp;
branches;
next	14.55;

14.55
date	2007.10.22.19.38.34;	author erikgreenwald;	state Exp;
branches;
next	14.54;

14.54
date	2007.10.17.01.36.23;	author brlcad;	state Exp;
branches;
next	14.53;

14.53
date	2007.10.12.01.21.50;	author johnranderson;	state Exp;
branches;
next	14.52;

14.52
date	2007.09.15.16.23.16;	author brlcad;	state Exp;
branches;
next	14.51;

14.51
date	2007.09.14.15.21.09;	author erikgreenwald;	state Exp;
branches;
next	14.50;

14.50
date	2007.07.10.18.39.58;	author brlcad;	state Exp;
branches
	14.50.2.1;
next	14.49;

14.49
date	2007.06.16.21.17.24;	author johnranderson;	state Exp;
branches;
next	14.48;

14.48
date	2007.05.20.22.46.24;	author brlcad;	state Exp;
branches;
next	14.47;

14.47
date	2007.03.06.23.02.48;	author brlcad;	state Exp;
branches;
next	14.46;

14.46
date	2007.01.27.01.41.43;	author brlcad;	state Exp;
branches;
next	14.45;

14.45
date	2007.01.23.01.13.41;	author brlcad;	state Exp;
branches;
next	14.44;

14.44
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.43;

14.43
date	2007.01.12.05.42.09;	author brlcad;	state Exp;
branches;
next	14.42;

14.42
date	2006.12.12.20.25.11;	author mjgillich;	state Exp;
branches;
next	14.41;

14.41
date	2006.08.29.23.26.51;	author brlcad;	state Exp;
branches;
next	14.40;

14.40
date	2006.08.29.23.15.36;	author brlcad;	state Exp;
branches;
next	14.39;

14.39
date	2006.08.29.21.51.26;	author brlcad;	state Exp;
branches;
next	14.38;

14.38
date	2006.08.29.20.12.50;	author bob1961;	state Exp;
branches;
next	14.37;

14.37
date	2006.08.28.12.51.24;	author brlcad;	state Exp;
branches;
next	14.36;

14.36
date	2006.08.08.06.15.45;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2006.08.08.02.54.44;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2006.05.15.20.19.17;	author brlcad;	state Exp;
branches;
next	14.33;

14.33
date	2006.05.15.20.02.23;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2006.04.06.20.50.03;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2006.01.28.22.46.19;	author brlcad;	state Exp;
branches
	14.31.2.1;
next	14.30;

14.30
date	2006.01.27.22.11.01;	author bob1961;	state Exp;
branches;
next	14.29;

14.29
date	2006.01.21.20.17.20;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2006.01.21.19.30.06;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.25;

14.25
date	2005.12.13.22.20.53;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2005.12.13.03.47.13;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2005.12.04.06.08.06;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2005.12.04.05.15.57;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2005.10.31.07.11.08;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2005.10.30.21.58.57;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2005.10.29.21.32.15;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2005.09.16.18.51.53;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.08.24.23.10.16;	author brlcad;	state Exp;
branches
	14.16.2.1;
next	14.15;

14.15
date	2005.08.21.13.56.30;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.07.18.05.09.28;	author brlcad;	state Exp;
branches
	14.14.2.1;
next	14.13;

14.13
date	2005.07.18.02.02.30;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.07.08.00.27.51;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2005.06.24.23.23.20;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.06.10.18.59.00;	author lbutler;	state Exp;
branches;
next	14.9;

14.9
date	2005.06.10.18.52.21;	author lbutler;	state Exp;
branches;
next	14.8;

14.8
date	2005.06.02.22.49.35;	author lbutler;	state Exp;
branches;
next	14.7;

14.7
date	2005.05.28.02.14.51;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.05.22.06.44.53;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.03.24.17.35.30;	author bob1961;	state Exp;
branches;
next	14.4;

14.4
date	2005.03.06.03.50.43;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.05;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.14.19.19.29;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.26;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.22;	author morrison;	state Exp;
branches;
next	;

14.12.2.1
date	2005.08.16.21.03.49;	author brlcad;	state Exp;
branches;
next	;

14.14.2.1
date	2005.09.08.16.09.50;	author bob1961;	state Exp;
branches;
next	;

14.16.2.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;

14.31.2.1
date	2006.04.07.19.30.28;	author jlowenz;	state Exp;
branches;
next	;

14.50.2.1
date	2007.09.28.14.04.33;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.62
log
@hook in the new dir2ae command
@
text
@/*                           C M D . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file cmd.c
 *
 *  The hooks to most of mged's commands when running in console mode.
 *
 *  Authors -
 *	Michael John Muuss
 *	Charles M. Kennedy
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <signal.h>
#include <time.h>
#include <string.h>

#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "tcl.h"
#include "tk.h"

#include "itcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "tclcad.h"

#include "./ged.h"
#include "./cmd.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./sedit.h"


int bv_zoomin(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_zoomout(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_rate_toggle(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_top(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_bottom(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_right(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_left(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_front(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_rear(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_vrestore(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_vsave(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_adcursor(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_reset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_45_45(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int bv_35_25(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_illuminate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_illuminate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_scale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_x(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_y(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_xy(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_rotate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_accept(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_reject(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_edit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_rotate(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_trans(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_s_scale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_xscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_yscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int be_o_zscale(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

void cmd_setup(void);
void mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first);
void mged_print_result(int status);
void mged_global_variable_setup(Tcl_Interp *interp);
void mged_global_variable_teardown(Tcl_Interp *interp);
int f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int f_bot_merge(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int f_bot_split(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

extern int f_hide();
extern int f_unhide();

extern void update_grids(fastf_t sf);			/* in grid.c */
extern void set_localunit_TclVar(void);		/* in chgmodel.c */
extern void init_qray(void);			/* in qray.c */
extern int gui_setup(char *dstr);				/* in attach.c */
extern int mged_default_dlist;			/* in attach.c */
extern int classic_mged;			/* in ged.c */
extern int bot_vertex_fuse(), bot_condense();
extern int cmd_bot_smooth();
struct cmd_list head_cmd_list;
struct cmd_list *curr_cmd_list;

extern int db_warn;	/* defined in ged.c */
extern int db_upgrade;	/* defined in ged.c */
extern int db_version;	/* defined in ged.c */

extern struct rt_tess_tol     mged_ttol; /* ged.c */
extern struct bn_tol	      mged_tol; /* ged.c */

int glob_compat_mode = 1;
int output_as_return = 1;
Tk_Window tkwin = NULL;

/* The following is for GUI output hooks: contains name of function to
 * run with output.
 */
static struct bu_vls tcl_output_hook;


int mged_cmd(int argc, char **argv, struct funtab *in_functions);


struct cmdtab {
	char *ct_name;
	int (*ct_func)();
};

#if 1
int f_test_bomb_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
#endif

static struct cmdtab cmdtab[] = {
	{"%", f_comm},
	{"35,25",	bv_35_25},
	{"3ptarb", f_3ptarb},
	{"45,45",	bv_45_45},
	{"accept",	be_accept},
	{"adc", f_adc},
	{"adjust",	cmd_adjust},
	{"ae", cmd_aetview},
	{"ae2dir", cmd_ae2dir},
	{"aip", f_aip},
	{"analyze", f_analyze},
	{"arb", f_arbdef},
	{"arced", f_arced},
	{"area", f_area},
	{"arot", cmd_arot},
	{"attach", f_attach},
	{"attr",	cmd_attr},
	{"autoview", cmd_autoview},
	{"B", cmd_blast},
	{"bev", f_bev},
#if 0
	{"import_body", cmd_import_body},
	{"export_body", cmd_export_body},
#endif
	{"bomb", f_bomb},
	{"bot_condense", f_bot_condense},
	{"bot_decimate", cmd_bot_decimate},
	{"bot_face_fuse", f_bot_face_fuse},
	{"bot_face_sort", cmd_bot_face_sort},
	{"bot_merge", f_bot_merge},
	{"bot_smooth", cmd_bot_smooth },
	{"bot_split", f_bot_split},
	{"bot_vertex_fuse", f_bot_fuse},
	{"bottom",	bv_bottom},
	{"c", cmd_comb_std},
	{"cat", cmd_cat},
	{"center", cmd_center},
	{"clone", f_clone},
	{"closedb", f_closedb},
	{"cmd_win", cmd_cmd_win},
	{"color", cmd_color},
	{"comb", cmd_comb},
	{"comb_color", f_comb_color},
	{"copyeval", cmd_copyeval},
	{"copymat", f_copymat},
	{"cp", cmd_copy},
	{"cpi", f_copy_inv},
	{"d", cmd_erase},
	{"dall", cmd_erase_all},
	{"db_glob", cmd_mged_glob},
	{"dbbinary", f_binary},
	{"dbconcat", cmd_concat},
	{"dbfind", cmd_find},
	{"dbip",	cmd_dbip},
	{"dbversion", cmd_dbversion},
	{"debugbu", f_debugbu},
	{"debugdir", f_debugdir},
	{"debuglib", f_debuglib},
	{"debugmem", f_debugmem},
	{"debugnmg", f_debugnmg},
	{"decompose", f_decompose},
	{"delay", f_delay},
	{"dir2ae", cmd_dir2ae},
	{"dump",	cmd_dump},
	{"dm", f_dm},
	{"draw", cmd_draw},
	{"dup", cmd_dup},
	{"E", cmd_E},
	{"e", cmd_draw},
	{"eac", f_eac},
	{"echo", cmd_echo},
	{"edcodes", f_edcodes},
	{"edcolor", f_edcolor},
	{"edcomb", f_edcomb},
	{"edgedir", f_edgedir},
	{"edmater", f_edmater},
	{"em", cmd_emuves},
	{"erase", cmd_erase},
	{"erase_all", cmd_erase_all},
	{"ev", cmd_ev},
	{"e_muves", f_e_muves},
	{"eqn", f_eqn},
	{"exit", f_quit},
	{"expand", cmd_expand},
	{"extrude", f_extrude},
	{"eye_pt", cmd_eye_pt},
	{"facedef", f_facedef},
	{"facetize", f_facetize},
	{"form",	cmd_form},
	{"fracture", f_fracture},
	{"front",	bv_front},
	{"g", cmd_group},
	{"get",		cmd_get},
	{"get_autoview", cmd_get_autoview},
	{"get_comb", cmd_get_comb},
	{"get_dbip", cmd_get_ptr},
	{"get_dm_list", f_get_dm_list},
	{"get_more_default", cmd_get_more_default},
	{"get_sed", f_get_sedit},
	{"get_sed_menus", f_get_sedit_menus},
	{"get_solid_keypoint", f_get_solid_keypoint},
	{"grid2model_lu", f_grid2model_lu},
	{"grid2view_lu", f_grid2view_lu},
#ifdef HIDELINE
	{"H", f_hideline},
#endif
	{"has_embedded_fb", cmd_has_embedded_fb},
	{"hide", cmd_hide },
	{"hist", cmd_hist},
	{"history", f_history},
	{"i", cmd_instance},
	{"idents", f_tables},
	{"ill", f_ill},
	{"in", f_in},
	{"inside", f_inside},
	{"item", f_itemair},
	{"joint", f_joint},
	{"journal", f_journal},
	{"keep", cmd_keep},
	{"keypoint", f_keypoint},
	{"kill", cmd_kill},
	{"killall", cmd_killall},
	{"killtree", cmd_killtree},
	{"knob", f_knob},
	{"l", cmd_list},
	{"l_muves", f_l_muves},
	{"labelvert", f_labelvert},
	{"left",		bv_left},
	{"lm", cmd_lm},
	{"lt", cmd_lt},
	{"loadtk", cmd_tk},
	{"listeval", cmd_pathsum},
	{"loadview", f_loadview},
	{"lookat", cmd_lookat},
	{"ls", cmd_ls},
	{"M", f_mouse},
	{"make", f_make},
	{"make_bb", cmd_make_bb},
	{"make_name", cmd_make_name},
	{"match",	cmd_match},
	{"mater", f_mater},
	{"matpick", f_matpick},
	{"memprint", f_memprint},
	{"mged_update", f_update},
	{"mged_wait", f_wait},
	{"mirface", f_mirface},
	{"mirror", f_mirror},
	{"mmenu_get", cmd_mmenu_get},
	{"mmenu_set", cmd_nop},
	{"model2grid_lu", f_model2grid_lu},
	{"model2view", f_model2view},
	{"model2view_lu", f_model2view_lu},
	{"mrot", cmd_mrot},
	{"mv", cmd_name},
	{"mvall", cmd_mvall},
	{"nirt", f_nirt},
	{"nmg_collapse", cmd_nmg_collapse},
	{"nmg_simplify", cmd_nmg_simplify},
	{"o_rotate",		be_o_rotate},
	{"o_scale",	be_o_scale},
	{"oed", cmd_oed},
	{"oed_apply", f_oedit_apply},
	{"oed_reset", f_oedit_reset},
	{"oill",		be_o_illuminate},
	{"opendb", f_opendb},
	{"orientation", cmd_orientation},
	{"orot", f_rot_obj},
	{"oscale", f_sc_obj},
	{"output_hook", cmd_output_hook},
	{"overlay", cmd_overlay},
	{"ox",		be_o_x},
	{"oxscale",	be_o_xscale},
	{"oxy",		be_o_xy},
	{"oy",		be_o_y},
	{"oyscale",	be_o_yscale},
	{"ozscale",	be_o_zscale},
	{"p", f_param},
	{"parse_points", cmd_parse_points},
	{"pathlist", cmd_pathlist},
	{"paths", cmd_pathsum},
	{"permute", f_permute},
	{"pl", f_pl},
	{"plot", f_plot},
	{"polybinout", f_polybinout},
	{"pov", cmd_pov},
	{"prcolor", cmd_prcolor},
	{"prefix", f_prefix},
	{"press", f_press},
	{"preview", f_preview},
	{"ps", f_ps},
	{"push", cmd_push},
	{"put",		cmd_put},
	{"put_comb", cmd_put_comb},
	{"put_sed", f_put_sedit},
	{"putmat", f_putmat},
	{"q", f_quit},
	{"qorot", f_qorot},
	{"qray", f_qray},
	{"query_ray", f_nirt},
	{"quit", f_quit},
	{"qvrot", f_qvrot},
	{"r", cmd_region},
	{"rate",		bv_rate_toggle},
	{"rcodes", f_rcodes},
	{"read_muves", f_read_muves},
	{"rear",	bv_rear},
	{"red", f_red},
	{"redraw_vlist", cmd_redraw_vlist},
	{"refresh", f_refresh},
	{"regdebug", f_regdebug},
	{"regdef", f_regdef},
	{"regions", f_tables},
	{"reject",	be_reject},
	{"release", f_release},
	{"reset",	bv_reset},
	{"restore",	bv_vrestore},
	{"rfarb", f_rfarb},
	{"right",	bv_right},
	{"rm", cmd_remove},
	{"rmater", f_rmater},
	{"rmats", f_rmats},
	{"rot", cmd_rot},
	{"rotobj", f_rot_obj},
	{"rrt", cmd_rrt},
	{"rset", f_rset},
	{"rt", cmd_rt},
	{"rt_gettrees", cmd_rt_gettrees},
	{"rtabort", cmd_rtabort},
	{"rtarea", cmd_rtarea},
	{"rtcheck", cmd_rtcheck},
	{"rtedge", cmd_rtedge},
	{"rtweight", cmd_rtweight},
	{"save",		bv_vsave},
	{"solid_report", cmd_solid_report},
#if 0
	{"savedit", f_savedit},
#endif
	{"savekey", f_savekey},
	{"saveview", f_saveview},
	{"sca", cmd_sca},
	{"sed", f_sed},
	{"sed_apply", f_sedit_apply},
	{"sed_reset", f_sedit_reset},
	{"sedit",	be_s_edit},
	{"set_more_default", cmd_set_more_default},
	{"setview", cmd_setview},
	{"shaded_mode", cmd_shaded_mode},
	{"shader", f_shader},
	{"share", f_share},
	{"shells", cmd_shells},
	{"showmats", cmd_showmats},
	{"sill",		be_s_illuminate},
	{"size", cmd_size},
	{"solid_report", cmd_solid_report},
	{"solids", f_tables},
	{"solids_on_ray", cmd_solids_on_ray},
	{"srot",		be_s_rotate},
	{"sscale",	be_s_scale},
	{"status", f_status},
	{"stuff_str", cmd_stuff_str},
	{"summary", cmd_summary},
	{"sv", f_slewview},
	{"svb", f_svbase},
	{"sxy",		be_s_trans},
	{"sync", f_sync},
	{"t", cmd_ls},
	{"t_muves", f_t_muves},
	{"ted", f_tedit},
	{"tie", f_tie},
	{"title", cmd_title},
	{"tol", cmd_tol},
	{"top",		bv_top},
	{"tops", cmd_tops},
	{"tra", cmd_tra},
	{"track", f_amtrack},
	{"tracker", f_tracker},
	{"translate", f_tr_obj},
	{"tree", cmd_tree},
	{"unhide", cmd_unhide},
	{"units", cmd_units},
	{"vars", f_set},
	{"vdraw", cmd_vdraw},
	{"view", f_view},
	{"view_ring", f_view_ring},
#if 0
	{"viewget", cmd_viewget},
	{"viewset", cmd_viewset},
#endif
	{"view2grid_lu", f_view2grid_lu},
	{"view2model", f_view2model},
	{"view2model_lu", f_view2model_lu},
	{"view2model_vec", f_view2model_vec},
	{"viewdir", cmd_viewdir},
	{"viewsize", cmd_size},		/* alias "size" for saveview scripts */
	{"vnirt", f_vnirt},
	{"vquery_ray", f_vnirt},
#if 0
	{"vrmgr", f_vrmgr},
#endif
	{"vrot", cmd_vrot},
#if 0
	{"vrot_center", f_vrot_center},
#endif
	{"wcodes", f_wcodes},
	{"whatid", cmd_whatid},
	{"which_shader", f_which_shader},
	{"whichair", cmd_which},
	{"whichid", cmd_which},
	{"who", cmd_who},
	{"winset", f_winset},
	{"wmater", f_wmater},
	{"x", cmd_solid_report},
	{"xpush", cmd_xpush},
	{"Z", cmd_zap},
	{"zoom", cmd_zoom},
	{"zoomin",	bv_zoomin},
	{"zoomout",	bv_zoomout},
	{0, 0}
};


/**
 *                        O U T P U T _ C A T C H
 *
 * Gets the output from bu_log and appends it to clientdata vls.
 */
HIDDEN int
output_catch(genptr_t clientdata, genptr_t str)
{
	register struct bu_vls *vp = (struct bu_vls *)clientdata;
	register int len;

	BU_CK_VLS(vp);
	len = bu_vls_strlen(vp);
	bu_vls_strcat(vp, str);
	len = bu_vls_strlen(vp) - len;

	return len;
}

/**
 *                 S T A R T _ C A T C H I N G _ O U T P U T
 *
 * Sets up hooks to bu_log so that all output is caught in the given vls.
 *
 */
void
start_catching_output(struct bu_vls *vp)
{
	bu_log_add_hook(output_catch, (genptr_t)vp);
}

/**
 *                 S T O P _ C A T C H I N G _ O U T P U T
 *
 * Turns off the output catch hook.
 */
void
stop_catching_output(struct bu_vls *vp)
{
	bu_log_delete_hook(output_catch, (genptr_t)vp);
}

/**
 *                            G U I _ O U T P U T
 *
 * Used as a hook for bu_log output.  Sends output to the Tcl procedure whose
 * name is contained in the vls "tcl_output_hook".  Useful for user interface
 * building.
 */
int
gui_output(genptr_t clientData, genptr_t str)
{
	Tcl_DString tclcommand;
	Tcl_Obj *save_result;
	static int level = 0;

	if (level > 50) {
		bu_log_delete_hook(gui_output, clientData);
		/* Now safe to run bu_log? */
		bu_log("Ack! Something horrible just happened recursively.\n");
		return 0;
	}

	Tcl_DStringInit(&tclcommand);
	(void)Tcl_DStringAppendElement(&tclcommand, bu_vls_addr(&tcl_output_hook));
	(void)Tcl_DStringAppendElement(&tclcommand, str);

	save_result = Tcl_GetObjResult(interp);
	Tcl_IncrRefCount(save_result);
	++level;
	Tcl_Eval((Tcl_Interp *)clientData, Tcl_DStringValue(&tclcommand));
	--level;
	Tcl_SetObjResult(interp, save_result);
	Tcl_DecrRefCount(save_result);

	Tcl_DStringFree(&tclcommand);
	return strlen(str);
}

/**
 *                     C M D _ T K
 *
 *  Command for initializing the Tk window and defaults.
 *
 *  Usage:  loadtk [displayname[.screennum]]
 */
int
cmd_tk(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int status;

	if(argc < 1 || 2 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help loadtk");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(argc == 1)
		status = gui_setup((char *)NULL);
	else
		status = gui_setup(argv[1]);

	return status;
}

/**
 *   C M D _ O U T P U T _ H O O K
 *
 *   Hooks the output to the given output hook.
 *   Removes the existing output hook!
 */
int
cmd_output_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls infocommand;
	int status;

	if(argc < 1 || 2 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel output_hook");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_log_delete_hook(gui_output, (genptr_t)interp);/* Delete the existing hook */

	if (argc < 2)
		return TCL_OK;

	/* Make sure the command exists before putting in the hook! */
	/* Note - the parameters to proc could be wrong and/or the proc could still disappear later */
	bu_vls_init(&infocommand);
	bu_vls_strcat(&infocommand, "info commands ");
	bu_vls_strcat(&infocommand, argv[1]);
	status = Tcl_Eval(interp, bu_vls_addr(&infocommand));
	bu_vls_free(&infocommand);

	if (status != TCL_OK || Tcl_GetStringResult(interp)[0] == '\0') {
		Tcl_AppendResult(interp, "command does not exist", (char *)NULL);
		return TCL_ERROR;
	}

	/* Also, don't allow silly infinite loops. */

	if (strcmp(argv[1], argv[0]) == 0) {
		Tcl_AppendResult(interp, "Don't be silly.", (char *)NULL);
		return TCL_ERROR;
	}

	/* Set up the hook! */
	bu_vls_init(&tcl_output_hook);
	bu_vls_strcpy(&tcl_output_hook, argv[1]);
	bu_log_add_hook(gui_output, (genptr_t)interp);

	Tcl_ResetResult(interp);
	return TCL_OK;
}


/**
 *			C M D _ N O P
 */
int
cmd_nop(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	return TCL_OK;
}


/**
 *			C M D _ G E T _ P T R
 *
 *  Returns an appropriately-formatted string that can later be reinterpreted
 *  (using atol() and a cast) as a a pointer.
 */
int
cmd_get_ptr(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	char buf[128];

	sprintf( buf, "%ld", (long)(*((void **)&dbip)) );
	Tcl_AppendResult( interp, buf, (char *)NULL );
	return TCL_OK;
}

/**
 * 			C M D _ S E T U P
 * Register all the MGED commands.
 */
void
cmd_setup(void)
{
	register struct cmdtab *ctp;
	struct bu_vls temp;
	struct bu_vls	vls;
	char		*pathname;

	bu_vls_init(&temp);
	for (ctp = cmdtab; ctp->ct_name != NULL; ctp++) {
#if 0
		bu_vls_strcpy(&temp, "info commands ");
		bu_vls_strcat(&temp, ctp->ct_name);
		if (Tcl_Eval(interp, bu_vls_addr(&temp)) != TCL_OK ||
		    Tcl_GetStringResult(interp)[0] != '\0') {
			bu_log("WARNING:  '%s' name collision (%s)\n", ctp->ct_name,
			       Tcl_GetStringResult(interp));
		}
#endif
		bu_vls_strcpy(&temp, "_mged_");
		bu_vls_strcat(&temp, ctp->ct_name);

		(void)Tcl_CreateCommand(interp, ctp->ct_name, ctp->ct_func,
					(ClientData)ctp, (Tcl_CmdDeleteProc *)NULL);
		(void)Tcl_CreateCommand(interp, bu_vls_addr(&temp), ctp->ct_func,
					(ClientData)ctp, (Tcl_CmdDeleteProc *)NULL);
	}

	/* overrides/wraps the built-in tree command */

	/* Locate the BRL-CAD-specific Tcl scripts */
	pathname = bu_brlcad_data("tclscripts", 1);

#ifdef _WIN32
	if (pathname) {
	    /* XXXXXXXXXXXXXXX UGLY XXXXXXXXXXXXXXXXXX*/
	    int i;
	    strcat(pathname,"/");
	    for (i=0;i<strlen(pathname);i++) {
		if(pathname[i]=='\\')
		    pathname[i]='/'; }

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "source %s/mged/tree.tcl", pathname);
	    (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
	}
#endif

	/* link some tcl variables to these corresponding globals */
	Tcl_LinkVar(interp, "glob_compat_mode", (char *)&glob_compat_mode, TCL_LINK_BOOLEAN);
	Tcl_LinkVar(interp, "output_as_return", (char *)&output_as_return, TCL_LINK_BOOLEAN);

	/* Provide Tcl interfaces to the fundamental BRL-CAD libraries */
#ifdef BRLCAD_DEBUG
	Bu_d_Init(interp);
	bn_tcl_setup( interp );
	Rt_d_Init(interp);
#else
	Bu_Init(interp);
	bn_tcl_setup( interp );
	Rt_Init(interp);
#endif

	tkwin = NULL;

	bu_vls_free(&temp);
}

int
cmd_cmd_win(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls vls;

	bu_vls_init(&vls);

	if(argc < 2){
		bu_vls_printf(&vls, "helpdevel cmd_win");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(strcmp(argv[1], "open") == 0){
		struct cmd_list *clp;
		int name_not_used = 1;

		if(argc != 3){
			bu_vls_printf(&vls, "helpdevel cmd_win");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* Search to see if there exists a command window with this name */
		for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
			if(!strcmp(argv[2], bu_vls_addr(&clp->cl_name))){
				name_not_used = 0;
				break;
			}

		if(name_not_used){
			clp = (struct cmd_list *)bu_malloc(sizeof(struct cmd_list), "cmd_list");
			memset((void *)clp, 0, sizeof(struct cmd_list));
			BU_LIST_APPEND(&head_cmd_list.l, &clp->l);
			clp->cl_cur_hist = head_cmd_list.cl_cur_hist;
			bu_vls_init(&clp->cl_more_default);
			bu_vls_init(&clp->cl_name);
			bu_vls_strcpy(&clp->cl_name, argv[2]);
		}

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(strcmp(argv[1], "close") == 0){
		struct cmd_list *clp;

		if(argc != 3){
			bu_vls_printf(&vls, "helpdevel cmd_win");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		/* First, search to see if there exists a command window with the name
		   in argv[2] */
		for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
			if(!strcmp(argv[2], bu_vls_addr(&clp->cl_name)))
				break;

		if(clp == &head_cmd_list){
			if(!strcmp(argv[2], "mged"))
				Tcl_AppendResult(interp, "cmd_close: not allowed to close \"mged\"",
								(char *)NULL);
			else
				Tcl_AppendResult(interp, "cmd_close: did not find \"", argv[2],
							"\"", (char *)NULL);
			return TCL_ERROR;
		}

		if(clp == curr_cmd_list)
			curr_cmd_list = &head_cmd_list;

		BU_LIST_DEQUEUE( &clp->l );
		if(clp->cl_tie != NULL)
			clp->cl_tie->dml_tie = CMD_LIST_NULL;
		bu_vls_free(&clp->cl_more_default);
		bu_vls_free(&clp->cl_name);
		bu_free((genptr_t)clp, "cmd_close: clp");

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(strcmp(argv[1], "get") == 0){
		if(argc != 2){
			bu_vls_printf(&vls, "helpdevel cmd_win");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);

			return TCL_ERROR;
		}

		Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_name));

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(strcmp(argv[1], "set") == 0){
		if(argc != 3){
			bu_vls_printf(&vls, "helpdevel cmd_win");
			Tcl_Eval(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_ERROR;
		}

		for( BU_LIST_FOR(curr_cmd_list, cmd_list, &head_cmd_list.l) ){
			if(strcmp(bu_vls_addr(&curr_cmd_list->cl_name), argv[2]))
				continue;

			break;
		}

		if(curr_cmd_list->cl_tie)
			curr_dm_list = curr_cmd_list->cl_tie;

		bu_vls_trunc(&curr_cmd_list->cl_more_default, 0);
		bu_vls_free(&vls);
		return TCL_OK;
	}

	bu_vls_printf(&vls, "helpdevel cmd_win");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

#if 0
cmd_get(clientData, interp, argc, argv)
	ClientData clientData;
	Tcl_Interp *interp;
	int argc;
	char **argv;
{
	struct dm_list *p;
	struct cmd_list *save_clp;
	struct bu_vls vls;
	int first = 1;

	if(argc != 1){
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel cmd_get");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	save_clp = curr_cmd_list;
	bu_vls_init(&vls);

	if(!curr_cmd_list->cl_tie){
		if(curr_dm_list->dml_tie){
			Tcl_AppendElement(interp, bu_vls_addr(&curr_dm_list->dml_tie->cl_name));
			curr_cmd_list = curr_dm_list->dml_tie;
			Tcl_AppendElement(interp, bu_vls_addr(&pathName));
		}else{
			Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_name));
			Tcl_AppendElement(interp, bu_vls_addr(&pathName));
			Tcl_AppendElement(interp, bu_vls_addr(&vls));
			bu_vls_free(&vls);
			return TCL_OK;
		}
	}else{
		Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_name));
		Tcl_AppendElement(interp, bu_vls_addr(&curr_cmd_list->cl_tie->dml_dmp->dm_pathName));
	}

	/* return all ids associated with the current command window */
	FOR_ALL_DISPLAYS(p, &head_dm_list.l){
		/* The display manager tied to the current command window shares
		   information with display manager p */
		if(curr_cmd_list->cl_tie->dml_view_state == p->dml_view_state)
			/* This display manager is tied to a command window */
			if(p->dml_tie)
				if(first){
					bu_vls_printf(&vls, "%S", &p->dml_tie->cl_name);
					first = 0;
				} else
					bu_vls_printf(&vls, " %S", &p->dml_tie->cl_name);
	}

	Tcl_AppendElement(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	curr_cmd_list = save_clp;
	return TCL_OK;
}
#endif

int
cmd_get_more_default(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	if(argc != 1){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel get_more_default");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	Tcl_AppendResult(interp, bu_vls_addr(&curr_cmd_list->cl_more_default), (char *)NULL);
	return TCL_OK;
}

int
cmd_set_more_default(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	if(argc != 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel set_more_default");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_strcpy(&curr_cmd_list->cl_more_default, argv[1]);
	return TCL_OK;
}


int
cmd_mged_glob(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct bu_vls dest, src;

	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help db_glob");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&src);
	bu_vls_init(&dest);
	bu_vls_strcpy(&src, argv[1]);
	mged_compat(&dest, &src, 0);
	Tcl_AppendResult(interp, bu_vls_addr(&dest), (char *)NULL);
	bu_vls_free(&src);
	bu_vls_free(&dest);

	return TCL_OK;
}


/**
 * debackslash, backslash_specials, mged_compat: routines for original
 *   mged emulation mode
 */
void
debackslash(struct bu_vls *dest, struct bu_vls *src)
{
	char *ptr;

	ptr = bu_vls_addr(src);
	while( *ptr ) {
		if( *ptr == '\\' )
			++ptr;
		if( *ptr == '\0' )
			break;
		bu_vls_putc( dest, *ptr++ );
	}
}

void
backslash_specials(struct bu_vls *dest, struct bu_vls *src)
{
	int backslashed;
	char *ptr, buf[2];

	buf[1] = '\0';
	backslashed = 0;
	for( ptr = bu_vls_addr( src ); *ptr; ptr++ ) {
		if( *ptr == '[' && !backslashed )
			bu_vls_strcat( dest, "\\[" );
		else if( *ptr == ']' && !backslashed )
			bu_vls_strcat( dest, "\\]" );
		else if( backslashed ) {
			bu_vls_strcat( dest, "\\" );
			buf[0] = *ptr;
			bu_vls_strcat( dest, buf );
			backslashed = 0;
		} else if( *ptr == '\\' )
			backslashed = 1;
		else {
			buf[0] = *ptr;
			bu_vls_strcat( dest, buf );
		}
	}
}


/**
 *                    M G E D _ C O M P A T
 *
 * This routine is called to perform wildcard expansion and character quoting
 * on the given vls (typically input from the keyboard.)
 */
void
mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first)
{
	char *start, *end;          /* Start and ends of words */
	int regexp;                 /* Set to TRUE when word is a regexp */
	int backslashed;
	int firstword;
	struct bu_vls word;         /* Current word being processed */
	struct bu_vls temp;

	if(dbip == DBI_NULL){
	  bu_vls_vlscat(dest, src);
	  return;
	}

	bu_vls_init( &word );
	bu_vls_init( &temp );

	start = end = bu_vls_addr( src );
	firstword = 1;
	while( *end != '\0' ) {            /* Run through entire string */

		/* First, pass along leading whitespace. */

		start = end;                   /* Begin where last word ended */
		while( *start != '\0' ) {
			if( *start == ' '  ||
			    *start == '\t' ||
			    *start == '\n' )
				bu_vls_putc( dest, *start++ );
			else
				break;
		}
		if( *start == '\0' )
			break;

		/* Next, advance "end" pointer to the end of the word, while adding
		   each character to the "word" vls.  Also make a note of any
		   unbackslashed wildcard characters. */

		end = start;
		bu_vls_trunc( &word, 0 );
		regexp = 0;
		backslashed = 0;
		while( *end != '\0' ) {
			if( *end == ' '  ||
			    *end == '\t' ||
			    *end == '\n' )
				break;
			if( (*end == '*' || *end == '?' || *end == '[') && !backslashed )
				regexp = 1;
			if( *end == '\\' && !backslashed )
				backslashed = 1;
			else
				backslashed = 0;
			bu_vls_putc( &word, *end++ );
		}

		if( firstword && !use_first )
			regexp = 0;

		/* Now, if the word was suspected of being a wildcard, try to match
		   it to the database. */

		if( regexp ) {
			bu_vls_trunc( &temp, 0 );
			if( db_regexp_match_all( &temp, dbip,
						 bu_vls_addr(&word) ) == 0 ) {
				debackslash( &temp, &word );
				backslash_specials( dest, &temp );
			} else
				bu_vls_vlscat( dest, &temp );
		} else {
			debackslash( dest, &word );
		}

		firstword = 0;
	}

	bu_vls_free( &temp );
	bu_vls_free( &word );
}

#ifdef _WIN32
/* limited to seconds only */
void gettimeofday(struct timeval *tp, struct timezone *tzp)
{

	time_t ltime;

	time( &ltime );

	tp->tv_sec = ltime;
	tp->tv_usec = 0;

}
#endif


/**
 *			C M D L I N E
 *
 *  This routine is called to process a vls full of commands.
 *  Each command is newline terminated.
 *  The input string will not be altered in any way.
 *
 *  Returns -
 *	!0	when a prompt needs to be printed.
 *	 0	no prompt needed.
 */
int
cmdline( struct bu_vls *vp, int record )
{
	int	status;
	struct bu_vls globbed;
	struct bu_vls tmp_vls;
	struct bu_vls save_vp;
	struct timeval start, finish;
	size_t len;
	extern struct bu_vls mged_prompt;
	char *cp;
	const char *result;

	BU_CK_VLS(vp);

	if (bu_vls_strlen(vp) <= 0)
		return CMD_OK;

	bu_vls_init(&globbed);
	bu_vls_init(&tmp_vls);
	bu_vls_init(&save_vp);
	bu_vls_vlscat(&save_vp, vp);

	/* MUST MAKE A BACKUP OF THE INPUT STRING AND USE THAT IN THE CALL TO
	   Tcl_Eval!!!

	   You never know who might change the string (append to it...)
	   (f_mouse is notorious for adding things to the input string)
	   If it were to change while it was still being evaluated, Horrible Things
	   could happen.
	*/

	if (glob_compat_mode) {
	    mged_compat(&globbed, vp, 0);
	} else {
	    bu_vls_vlscat(&globbed, vp);
	}

	gettimeofday(&start, (struct timezone *)NULL);
	status = Tcl_Eval(interp, bu_vls_addr(&globbed));
	gettimeofday(&finish, (struct timezone *)NULL);
	result = Tcl_GetStringResult(interp);

	/* Contemplate the result reported by the Tcl interpreter. */

	switch (status) {
	case TCL_RETURN:
	case TCL_OK:
		if( setjmp( jmp_env ) == 0 ){
			len = strlen(result);

			/* If the command had something to say, print it out. */
			if (len > 0){
				(void)signal( SIGINT, sig3);  /* allow interupts */

				bu_log("%s%s", result,
				       result[len-1] == '\n' ? "" : "\n");

				(void)signal( SIGINT, SIG_IGN );
			}

			/* A user typed this command so let everybody see, then record
			   it in the history. */
			if (record && tkwin != NULL) {
				bu_vls_printf(&tmp_vls, "distribute_text {} {%s} {%s}",
					      bu_vls_addr(&save_vp), result);
				Tcl_Eval(interp, bu_vls_addr(&tmp_vls));
				Tcl_SetResult(interp, "", TCL_STATIC);
			}

			if(record)
				history_record(&save_vp, &start, &finish, CMD_OK);

		}else{
/* XXXXXX */
			bu_semaphore_release(BU_SEM_SYSCALL);
			bu_log("\n");
		}

		bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
		status = CMD_OK;
		goto end;

	case TCL_ERROR:
	default:

		/* First check to see if it's a secret message. */

		if ((cp = strstr(result, MORE_ARGS_STR)) != NULL) {
			if(cp == result){
				bu_vls_trunc(&mged_prompt, 0);
				bu_vls_printf(&mged_prompt, "\r%s",
					      result+sizeof(MORE_ARGS_STR)-1);
			}else{
				len = cp - result;
				bu_log("%*s%s", len, result, result[len-1] == '\n' ? "" : "\n");
				bu_vls_trunc(&mged_prompt, 0);
				bu_vls_printf(&mged_prompt, "\r%s",
					      result+sizeof(MORE_ARGS_STR)-1+len);
			}

			status = CMD_MORE;
			goto end;
		}

		/* Otherwise, it's just a regular old error. */

		len = strlen(result);
		if (len > 0) bu_log("%s%s", result,
				    result[len-1] == '\n' ? "" : "\n");

		if (record)
			history_record(&save_vp, &start, &finish, CMD_BAD);

		bu_vls_strcpy(&mged_prompt, MGED_PROMPT);
		status = CMD_BAD;

		/* Fall through to end */
	}

 end:
	bu_vls_free(&globbed);
	bu_vls_free(&tmp_vls);
	bu_vls_free(&save_vp);

	return status;
}


void
mged_print_result(int status)
{
	int len;
	extern void pr_prompt(void);
	const char *result = Tcl_GetStringResult(interp);

#if 0
	switch (status) {
	case TCL_OK:
		len = strlen(result);

		/* If the command had something to say, print it out. */
		if (len > 0){
			bu_log("%s%s", result,
			       result[len-1] == '\n' ? "" : "\n");

			pr_prompt();
		}

		break;

	case TCL_ERROR:
	default:
		len = strlen(result);
		if (len > 0){
			bu_log("%s%s", result,
			       result[len-1] == '\n' ? "" : "\n");

			pr_prompt();
		}

		break;
	}
#else
	len = strlen(result);
	if (len > 0){
		bu_log("%s%s", result,
		       result[len-1] == '\n' ? "" : "\n");

		pr_prompt();
	}
#endif

	Tcl_ResetResult(interp);
}

/**
 *			M G E D _ C M D
 *
 *  Check a table for the command, check for the correct minimum and maximum
 *  number of arguments, and pass control to the proper function.  If the
 *  number of arguments is incorrect, print out a short help message.
 */
int
mged_cmd(
	int argc,
	char **argv,
	struct funtab in_functions[])
{
	register struct funtab *ftp;
	struct funtab *functions;

	if (argc == 0)
		return CMD_OK;	/* No command entered, that's fine */

	/* if no function table is provided, use the default mged function table */
	if( in_functions == (struct funtab *)NULL )
	{
		bu_log("mged_cmd: failed to supply function table!\n");
		return CMD_BAD;
	}
	else
		functions = in_functions;

	for (ftp = &functions[1]; ftp->ft_name; ftp++) {
		if (strcmp(ftp->ft_name, argv[0]) != 0)
			continue;
		/* We have a match */
		if ((ftp->ft_min <= argc) && (argc <= ftp->ft_max)) {
			/* Input has the right number of args.
			 * Call function listed in table, with
			 * main(argc, argv) style args
			 */

			switch (ftp->ft_func(argc, argv)) {
			case CMD_OK:
				return CMD_OK;
			case CMD_BAD:
				return CMD_BAD;
			case CMD_MORE:
				return CMD_MORE;
			default:
				Tcl_AppendResult(interp, "mged_cmd(): Invalid return from ",
						 ftp->ft_name, "\n", (char *)NULL);
				return CMD_BAD;
			}
		}

		Tcl_AppendResult(interp, "Usage: ", functions[0].ft_name, ftp->ft_name,
				 " ", ftp->ft_parms, "\n\t(", ftp->ft_comment,
				 ")\n", (char *)NULL);
		return CMD_BAD;
	}

	Tcl_AppendResult(interp, functions[0].ft_name, argv[0],
			 ": no such command, type '", functions[0].ft_name,
			 "?' for help\n", (char *)NULL);
	return CMD_BAD;
}

/**
 * Let the user temporarily escape from the editor
 * Format: %
 */
int
f_comm(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{

#ifndef _WIN32

	register int pid, rpid;
	int retcode;

	if(argc != 1 || !classic_mged || curr_cmd_list != &head_cmd_list){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	(void)signal( SIGINT, SIG_IGN );
	if ( ( pid = fork()) == 0 )  {
		(void)signal( SIGINT, SIG_DFL );
		(void)execl("/bin/sh","-",(char *)NULL);
		perror("/bin/sh");
		mged_finish( 11 );
	}

	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;

	Tcl_AppendResult(interp, "!\n", (char *)NULL);
#endif

	return TCL_OK;
}

/**
 * Quit and exit gracefully
 * Format: q
 */
int
f_quit(
	ClientData clientData,
	Tcl_Interp *interp,
	int	argc,
	char	**argv)
{
	if(argc < 1 || 1 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if( state != ST_VIEW )
		button( BE_REJECT );

	quit();			/* Exiting time */
	/* NOTREACHED */
	return TCL_OK;
}

/**
 * sync the database to disk
 */
int
f_sync(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{

	if(argc < 1 || 1 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help %s", argv[0]);
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(dbip != DBI_NULL){
	    db_sync(dbip);
	}

	return TCL_OK;
}

/**
 *			H E L P C O M M
 *
 *  Common code for help commands
 */
static int
helpcomm(int argc, char **argv, struct funtab *functions)
{
	register struct funtab *ftp;
	register int	i, bad;

	bad = 0;

	/* Help command(s) */
	for( i=1; i<argc; i++ )  {
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			if( strcmp( ftp->ft_name, argv[i] ) != 0 )
				continue;

			Tcl_AppendResult(interp, "Usage: ", functions->ft_name, ftp->ft_name,
					 " ", ftp->ft_parms, "\n\t(", ftp->ft_comment, ")\n", (char *)NULL);
			break;
		}
		if( !ftp->ft_name ) {
			Tcl_AppendResult(interp, functions->ft_name, argv[i],
					 ": no such command, type '", functions->ft_name,
					 "?' for help\n", (char *)NULL);
			bad = 1;
		}
	}

	return bad ? TCL_ERROR : TCL_OK;
}

/**
 *			F _ H E L P
 *
 *  Print a help message, two lines for each command.
 *  Or, help with the indicated commands.
 */
int
f_help2(int argc, char **argv, struct funtab *functions)
{
	register struct funtab *ftp;

	if( argc <= 1 )  {
		Tcl_AppendResult(interp, "The following commands are available:\n", (char *)NULL);
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			Tcl_AppendResult(interp,  functions->ft_name, ftp->ft_name, " ",
					 ftp->ft_parms, "\n\t(", ftp->ft_comment, ")\n", (char *)NULL);
		}
		return TCL_OK;
	}
	return helpcomm( argc, argv, functions );
}

int
f_fhelp2(int argc, char **argv, struct funtab *functions)
{
	register struct funtab *ftp;
	struct bu_vls		str;

	if( argc <= 1 )  {
		bu_vls_init(&str);
		Tcl_AppendResult(interp, "The following ", functions->ft_name,
				 " commands are available:\n", (char *)NULL);
		for( ftp = functions+1; ftp->ft_name; ftp++ )  {
			vls_col_item( &str, ftp->ft_name);
		}
		vls_col_eol( &str );
		Tcl_AppendResult(interp, bu_vls_addr( &str ), (char *)NULL);
		bu_vls_free(&str);
		return TCL_OK;
	}
	return helpcomm( argc, argv, functions );
}

int
cmd_summary(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_summary_cmd(wdbp, interp, argc, argv);
}

/**
 *                          C M D _ E C H O
 *
 * Concatenates its arguments and "bu_log"s the resulting string.
 */
int
cmd_echo(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;

	if(argc < 1){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help echo");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( i=1; i < argc; i++ )  {
		Tcl_AppendResult(interp, i==1 ? "" : " ", argv[i], (char *)NULL);
	}

	Tcl_AppendResult(interp, "\n", (char *)NULL);

	return TCL_OK;
}

#if 0
int
f_savedit(argc, argv)
	int	argc;
	char	*argv[];
{
	struct bu_vls str;
	char	line[35];
	int o_ipathpos;
	register struct solid *o_illump;

	o_illump = illump;
	bu_vls_init(&str);

	if(state == ST_S_EDIT){
		bu_vls_strcpy( &str, "press accept\npress sill\n" );
		cmdline(&str, 0);
		illump = o_illump;
		bu_vls_strcpy( &str, "M 1 0 0\n");
		cmdline(&str, 0);
		return CMD_OK;
	}else if(state == ST_O_EDIT){
		o_ipathpos = ipathpos;
		bu_vls_strcpy( &str, "press accept\npress oill\n" );
		cmdline(&str, 0);
		(void)chg_state( ST_O_PICK, ST_O_PATH, "savedit");
		illump = o_illump;
		ipathpos = o_ipathpos;
		bu_vls_strcpy( &str, "M 1 0 0\n");
		cmdline(&str, 0);
		return CMD_OK;
	}

	bu_log( "Savedit will only work in an edit state\n");
	bu_vls_free(&str);
	return CMD_BAD;
}
#endif

/**
 * SYNOPSIS
 *	tie [cw [dm]]
 *	tie -u cw
 *
 * DESCRIPTION
 *	This command ties/associates a command window (cw) to a display manager window (dm).
 *	When a command window is tied to a display manager window, all commands issued from
 *	this window will be directed at a particular display manager. Otherwise, the
 *	commands issued will be directed at the current display manager window.
 *
 * EXAMPLES
 *	tie		--->	returns a list of the command_window/display_manager associations
 *	tie cw1		--->	returns the display_manager, if it exists, associated with cw1
 *	tie cw1 dm1	--->	associated cw1 with dm1
 *	tie -u cw1	--->	removes the association, if it exists, cw1 has with a display manager
 */
int
f_tie(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int uflag = 0;		/* untie flag */
	struct cmd_list *clp;
	struct dm_list *dlp;
	struct bu_vls vls;

	bu_vls_init(&vls);

	if(argc < 1 || 3 < argc){
		bu_vls_printf(&vls, "helpdevel tie");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(argc == 1){
		for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) ){
			bu_vls_trunc(&vls, 0);
			if(clp->cl_tie){
				bu_vls_printf(&vls, "%S %S", &clp->cl_name,
						&clp->cl_tie->dml_dmp->dm_pathName);
				Tcl_AppendElement(interp, bu_vls_addr(&vls));
			}else{
				bu_vls_printf(&vls, "%S {}", &clp->cl_name);
				Tcl_AppendElement(interp, bu_vls_addr(&vls));
			}
		}

		bu_vls_trunc(&vls, 0);
		if(clp->cl_tie){
			bu_vls_printf(&vls, "%S %S", &clp->cl_name,
						&clp->cl_tie->dml_dmp->dm_pathName);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));
		}else{
			bu_vls_printf(&vls, "%S {}", &clp->cl_name);
			Tcl_AppendElement(interp, bu_vls_addr(&vls));
		}

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(argv[1][0] == '-' && argv[1][1] == 'u'){
		uflag = 1;
		--argc;
		++argv;
	}

	if(argc < 2){
		bu_vls_printf(&vls, "help tie");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	for( BU_LIST_FOR(clp, cmd_list, &head_cmd_list.l) )
		if(!strcmp(bu_vls_addr(&clp->cl_name), argv[1]))
			break;

	if(clp == &head_cmd_list &&
	   (strcmp(bu_vls_addr(&head_cmd_list.cl_name), argv[1]))){
		Tcl_AppendResult(interp, "f_tie: unrecognized command_window - ", argv[1],
				 "\n", (char *)NULL);
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if(uflag){
		if(clp->cl_tie)
			clp->cl_tie->dml_tie = (struct cmd_list *)NULL;

		clp->cl_tie = (struct dm_list *)NULL;

		bu_vls_free(&vls);
		return TCL_OK;
	}

	/* print out the display manager that we're tied to */
	if(argc == 2){
		if(clp->cl_tie)
			Tcl_AppendElement(interp, bu_vls_addr(&clp->cl_tie->dml_dmp->dm_pathName));
		else
			Tcl_AppendElement(interp, "");

		bu_vls_free(&vls);
		return TCL_OK;
	}

	if(*argv[2] != '.')
		bu_vls_printf(&vls, ".%s", argv[2]);
	else
		bu_vls_strcpy(&vls, argv[2]);

	FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
		if(!bu_vls_strcmp(&vls, &dlp->dml_dmp->dm_pathName))
			break;

	if(dlp == &head_dm_list){
		Tcl_AppendResult(interp, "f_tie: unrecognized pathName - ",
				 bu_vls_addr(&vls), "\n", (char *)NULL);
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* already tied */
	if(clp->cl_tie)
		clp->cl_tie->dml_tie = (struct cmd_list *)NULL;

	clp->cl_tie = dlp;

	/* already tied */
	if(dlp->dml_tie)
		dlp->dml_tie->cl_tie = (struct dm_list *)NULL;

	dlp->dml_tie = clp;

	bu_vls_free(&vls);
	return TCL_OK;
}

int
f_ps(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int status;
	char *av[2];
	struct dm_list *dml;
	struct _view_state *vsp;

	if (argc < 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help ps");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dml = curr_dm_list;
	status = mged_attach(&which_dm[DM_PS_INDEX], argc, argv);
	if(status == TCL_ERROR)
		return TCL_ERROR;

	vsp = view_state;  /* save state info pointer */

	bu_free((genptr_t)menu_state,"f_ps: menu_state");
	menu_state = dml->dml_menu_state;

	scroll_top = dml->dml_scroll_top;
	scroll_active = dml->dml_scroll_active;
	scroll_y = dml->dml_scroll_y;
	memmove((void *)scroll_array, (void *)dml->dml_scroll_array, sizeof(struct scroll_item *) * 6);

	dirty = 1;
	refresh();

	view_state = vsp;  /* restore state info pointer */
	av[0] = "release";
	av[1] = NULL;
	status = f_release(clientData, interp, 1, av);
	curr_dm_list = dml;

	return status;
}

/**
 * Experimental - like f_plot except we attach to dm-plot, passing along
 *                any arguments.
 */
int
f_pl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int status;
	char *av[2];
	struct dm_list *dml;
	struct _view_state *vsp;

	if(argc < 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help pl");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	dml = curr_dm_list;
	status = mged_attach(&which_dm[DM_PLOT_INDEX], argc, argv);
	if(status == TCL_ERROR)
		return TCL_ERROR;

	vsp = view_state;  /* save state info pointer */
	view_state = dml->dml_view_state;  /* use dml's state info */
	*mged_variables = *dml->dml_mged_variables; /* struct copy */

	bu_free((genptr_t)menu_state,"f_pl: menu_state");
	menu_state = dml->dml_menu_state;

	scroll_top = dml->dml_scroll_top;
	scroll_active = dml->dml_scroll_active;
	scroll_y = dml->dml_scroll_y;
	memmove((void *)scroll_array, (void *)dml->dml_scroll_array, sizeof(struct scroll_item *) * 6);

	dirty = 1;
	refresh();

	view_state = vsp;  /* restore state info pointer */
	av[0] = "release";
	av[1] = NULL;
	status = f_release(clientData, interp, 1, av);
	curr_dm_list = dml;

	return status;
}

int
f_winset(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register struct dm_list *p;

	if(argc < 1 || 2 < argc){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helpdevel winset");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* print pathname of drawing window with primary focus */
	if( argc == 1 ){
		Tcl_AppendResult(interp, bu_vls_addr(&pathName), (char *)NULL);
		return TCL_OK;
	}

	/* change primary focus to window argv[1] */
	FOR_ALL_DISPLAYS(p, &head_dm_list.l){
		if( !strcmp( argv[1], bu_vls_addr( &p->dml_dmp->dm_pathName ) ) ){
			curr_dm_list = p;

			if(curr_dm_list->dml_tie)
				curr_cmd_list = curr_dm_list->dml_tie;
			else
				curr_cmd_list = &head_cmd_list;

			return TCL_OK;
		}
	}

	Tcl_AppendResult(interp, "Unrecognized pathname - ", argv[1],
			 "\n", (char *)NULL);
	return TCL_ERROR;
}

void
mged_global_variable_setup(Tcl_Interp *interp)
{
	Tcl_LinkVar(interp, "mged_default(dlist)", (char *)&mged_default_dlist, TCL_LINK_INT);
	Tcl_LinkVar(interp, "mged_default(db_warn)", (char *)&db_warn, TCL_LINK_INT);
	Tcl_LinkVar(interp, "mged_default(db_upgrade)", (char *)&db_upgrade, TCL_LINK_INT);
	Tcl_LinkVar(interp, "mged_default(db_version)", (char *)&db_version, TCL_LINK_INT);

	Tcl_LinkVar(interp, "edit_class", (char *)&es_edclass, TCL_LINK_INT);
	Tcl_LinkVar(interp, "edit_solid_flag", (char *)&es_edflag, TCL_LINK_INT);
	Tcl_LinkVar(interp, "edit_object_flag", (char *)&edobj, TCL_LINK_INT);
}


void
mged_global_variable_teardown(Tcl_Interp *interp)
{
    Tcl_UnlinkVar(interp, "mged_default(dlist)");
    Tcl_UnlinkVar(interp, "mged_default(db_warn)");
    Tcl_UnlinkVar(interp, "mged_default(db_upgrade)");
    Tcl_UnlinkVar(interp, "mged_default(db_version)");

    Tcl_UnlinkVar(interp, "edit_class");
    Tcl_UnlinkVar(interp, "edit_solid_flag");
    Tcl_UnlinkVar(interp, "edit_object_flag");
}


int
f_bot_split(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *dp;
	struct rt_db_internal intern;
	struct rt_bot_internal **bots;
	struct rt_bot_internal *bot;
	int bot_count = 256;
	int edge, e, f ;
	int * edges;
	int face;


	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if (argc < 2) {
	  Tcl_AppendResult(interp, "Usage:\nbot_merge bot_dest bot1_src [botn_src]\n", (char *)NULL );
	  return TCL_ERROR;
	}


	bots = bu_calloc(sizeof(struct rt_bot_internal), bot_count, "bot internal");

	if ((dp = db_lookup(dbip, argv[1], LOOKUP_NOISY)) == DIR_NULL) {
	    return TCL_ERROR;
	}

	if( rt_db_get_internal( &intern, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 ) {
	    Tcl_AppendResult(interp, "rt_db_get_internal(", argv[1], ") error\n", (char *)NULL);
	    return TCL_ERROR;

	}

	if( intern.idb_type != ID_BOT ) 	{
	    Tcl_AppendResult(interp, argv[1], " is not a BOT solid!!!  skipping\n", (char *)NULL );
	    return TCL_ERROR;
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	edges = bu_calloc(bot->num_faces, 3, "num_edges");


	for (face=0 ; face < bot->num_faces ; face++) {
	    int *faceptr = &bot->faces[face*3];

	    for (edge=0 ; edge < 3 ; edge++) {

		for (f=face+1 ; f < bot->num_faces ; f++) {
		    int *fptr = &bot->faces[f*3];

		    for (e=0 ; e < 3 ; e++) {
			/* does e match edge? */

			if ( (fptr[e] == faceptr[edge] && fptr[ (e+1) % 3 ] == faceptr[ (edge+1) % 3 ]) ||
			     (fptr[e] == faceptr[ (edge+1) % 3 ] && fptr[ (e+1) % 3 ] == faceptr[edge]) ) {
			    /* edge match */
			    edges[face*3+edge]++;
			    edges[face*3+edge]++;
			}


		    }
		}
	    }
	}
	return TCL_OK;
}


int
f_bot_merge(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *dp, *new_dp;
	struct rt_db_internal intern;
	struct rt_bot_internal **bots;
	int i, idx, retval;
	int avail_vert, avail_face, face;


	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if (argc < 2) {
	  Tcl_AppendResult(interp, "Usage:\nbot_merge bot_dest bot1_src [botn_src]\n", (char *)NULL );
	  return TCL_ERROR;
	}

	bots = bu_calloc(sizeof(struct rt_bot_internal), argc, "bot internal");

	retval = TCL_OK;


	/* create a new bot */
	BU_GETSTRUCT(bots[0], rt_bot_internal);
	bots[0]->mode = 0;
	bots[0]->orientation = RT_BOT_UNORIENTED;
	bots[0]->bot_flags = 0;
	bots[0]->num_vertices = 0;
	bots[0]->num_faces = 0;
	bots[0]->faces = (int *)0;
	bots[0]->vertices = (fastf_t *)0;
	bots[0]->thickness = (fastf_t *)0;
	bots[0]->face_mode = (struct bu_bitv*)0;
	bots[0]->num_normals = 0;
	bots[0]->normals = (fastf_t *)0;
	bots[0]->num_face_normals = 0;
	bots[0]->face_normals = 0;
	bots[0]->magic = RT_BOT_INTERNAL_MAGIC;


	/* read in all the bots */
	for (idx=1,i=2 ; i < argc ; i++ ) {
	    if ((dp = db_lookup(dbip, argv[i], LOOKUP_NOISY)) == DIR_NULL) {
		continue;
	    }

	    if( rt_db_get_internal( &intern, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 ) {
		Tcl_AppendResult(interp, "rt_db_get_internal(", argv[i], ") error\n", (char *)NULL);
		retval = TCL_ERROR;
		continue;
	    }

	    if( intern.idb_type != ID_BOT ) 	{
		Tcl_AppendResult(interp, argv[i], " is not a BOT solid!!!  skipping\n", (char *)NULL );
		retval = TCL_ERROR;
		continue;
	    }

	    bots[idx] = (struct rt_bot_internal *)intern.idb_ptr;

	    intern.idb_ptr = (genptr_t)0;

	    RT_BOT_CK_MAGIC( bots[idx] );

	    bots[0]->num_vertices += bots[idx]->num_vertices;
	    bots[0]->num_faces += bots[idx]->num_faces;

	    idx++;
	}

	if (idx == 1) return TCL_ERROR;


	for (i=1 ; i < idx ; i++ ) {
	    /* check for surface normals */
	    if (bots[0]->mode) {
		if (bots[0]->mode != bots[i]->mode) {
		    bu_log("Warning: not all bots share same mode\n");
		}
	    } else {
		bots[0]->mode = bots[i]->mode;
	    }


	    if (bots[i]->bot_flags & RT_BOT_HAS_SURFACE_NORMALS) bots[0]->bot_flags |= RT_BOT_HAS_SURFACE_NORMALS;
	    if (bots[i]->bot_flags & RT_BOT_USE_NORMALS) bots[0]->bot_flags |= RT_BOT_USE_NORMALS;

	    if (bots[0]->orientation) {
		if (bots[i]->orientation == RT_BOT_UNORIENTED) {
		    bots[0]->orientation = RT_BOT_UNORIENTED;
		} else {
		    bots[i]->magic = 1; /* set flag to reverse order of faces */
		}
	    } else {
		bots[0]->orientation = bots[i]->orientation;
	    }
	}


	bots[0]->vertices = bu_calloc(bots[0]->num_vertices*3, sizeof(fastf_t), "verts");
	bots[0]->faces = bu_calloc(bots[0]->num_faces*3, sizeof(int), "verts");

	avail_vert = 0;
	avail_face = 0;


	for (i=1 ; i < idx ; i++ ) {
	    /* copy the vertices */
	    memcpy(&bots[0]->vertices[3*avail_vert], bots[i]->vertices, bots[i]->num_vertices*3*sizeof(fastf_t));

	    /* copy/convert the faces, potentially maintaining a common orientation */
	    if (bots[0]->orientation != RT_BOT_UNORIENTED && bots[i]->magic != RT_BOT_INTERNAL_MAGIC) {
		/* copy and reverse */
		for (face=0 ; face < bots[i]->num_faces ; face++) {
		    /* copy the 3 verts of this face and convert to new index */
		    bots[0]->faces[avail_face*3+face*3+2] = bots[i]->faces[face*3  ] + avail_vert;
		    bots[0]->faces[avail_face*3+face*3+1] = bots[i]->faces[face*3+1] + avail_vert;
		    bots[0]->faces[avail_face*3+face*3  ] = bots[i]->faces[face*3+2] + avail_vert;
		}
	    } else {
		/* just copy */
		for (face=0 ; face < bots[i]->num_faces ; face++) {
		    /* copy the 3 verts of this face and convert to new index */
		    bots[0]->faces[avail_face*3+face*3  ] = bots[i]->faces[face*3  ] + avail_vert;
		    bots[0]->faces[avail_face*3+face*3+1] = bots[i]->faces[face*3+1] + avail_vert;
		    bots[0]->faces[avail_face*3+face*3+2] = bots[i]->faces[face*3+2] + avail_vert;
		}
	    }

	    /* copy surface normals */
	    if (bots[0]->bot_flags == RT_BOT_HAS_SURFACE_NORMALS) {
		bu_log("not yet copying surface normals\n");
		if (bots[i]->bot_flags == RT_BOT_HAS_SURFACE_NORMALS) {
		} else {
		}
	    }


	    avail_vert += bots[i]->num_vertices;
	    avail_face += bots[i]->num_faces;
	}

	RT_INIT_DB_INTERNAL(&intern);
	intern.idb_type = ID_BOT;
	intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
	intern.idb_minor_type = DB5_MINORTYPE_BRLCAD_BOT;
	intern.idb_meth = &rt_functab[ID_BOT];
	intern.idb_ptr = (genptr_t)bots[0];

	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( new_dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}

	bu_free(bots, "bots");

	return retval;
}
int
f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *old_dp, *new_dp;
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc != 3){
	  Tcl_AppendResult(interp, "Usage:\nbot_face_fuse new_bot_solid old_bot_solid\n", (char *)NULL );
	  return TCL_ERROR;
	}

	if( (old_dp = db_lookup( dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( intern.idb_type != ID_BOT )
	{
		Tcl_AppendResult(interp, argv[2], " is not a BOT solid!!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	(void) rt_bot_face_fuse( bot );

	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( new_dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

int
f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *old_dp, *new_dp;
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;
	int count1=0;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc != 3){
	  Tcl_AppendResult(interp, "Usage:\nbot_fuse new_bot_solid old_bot_solid\n", (char *)NULL );
	  return TCL_ERROR;
	}

	if( (old_dp = db_lookup( dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( intern.idb_type != ID_BOT )
	{
		Tcl_AppendResult(interp, argv[2], " is not a BOT solid!!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	count1 = rt_bot_vertex_fuse( bot );
	if( count1 )
		(void)rt_bot_condense( bot );

	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( new_dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

int
f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct directory *old_dp, *new_dp;
	struct rt_db_internal intern;
	struct rt_bot_internal *bot;
	int count2=0;
	char count_str[255];

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc != 3){
	  Tcl_AppendResult(interp, "Usage:\nbot_condense new_bot_solid old_bot_solid\n", (char *)NULL );
	  return TCL_ERROR;
	}

	if( (old_dp = db_lookup( dbip, argv[2], LOOKUP_NOISY )) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &intern, old_dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
	  Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
	  return TCL_ERROR;
	}

	if( intern.idb_type != ID_BOT )
	{
		Tcl_AppendResult(interp, argv[2], " is not a BOT solid!!!\n", (char *)NULL );
		return TCL_ERROR;
	}

	bot = (struct rt_bot_internal *)intern.idb_ptr;
	RT_BOT_CK_MAGIC( bot );

	count2 = rt_bot_condense( bot );
	sprintf( count_str, "%d", count2 );
	Tcl_AppendResult(interp, count_str, " dead vertices eliminated\n", (char *)NULL );

	if( (new_dp=db_diradd( dbip, argv[1], -1L, 0, DIR_SOLID, (genptr_t)&intern.idb_type)) == DIR_NULL )
	{
		Tcl_AppendResult(interp, "Cannot add ", argv[1], " to directory\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( rt_db_put_internal( new_dp, dbip, &intern, &rt_uniresource ) < 0 )
	{
		rt_db_free_internal( &intern, &rt_uniresource );
		TCL_WRITE_ERR_return;
	}
	return TCL_OK;
}

int
f_bomb(ClientData clientData, Tcl_Interp *interp, int argc, const char *argv[])
{
    char buffer[1024] = {0};
    struct bu_vls vls;

    if (argc > 1) {
	argc--; argv++;

	bu_vls_init(&vls);
	bu_vls_from_argv(&vls, argc, argv);
	snprintf(buffer, 1024, "%s", bu_vls_addr(&vls));
	bu_vls_free(&vls);
    }

    bu_exit(EXIT_FAILURE, buffer);

    /* This is never reached */

    return TCL_OK;
}

int
cmd_adjust(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_adjust_cmd(wdbp, interp, argc, argv);
}

int
cmd_attr(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_attr_cmd(wdbp, interp, argc, argv);
}

int
cmd_dbip(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_dbip_cmd(wdbp, interp, argc, argv);
}

int
cmd_dump(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_dump_cmd(wdbp, interp, argc, argv);
}

int
cmd_form(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_form_cmd(wdbp, interp, argc, argv);
}

int
cmd_get(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_get_cmd(wdbp, interp, argc, argv);
}

int
cmd_match(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_match_cmd(wdbp, interp, argc, argv);
}

int
cmd_put(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_put_cmd(wdbp, interp, argc, argv);
}

int
cmd_rt_gettrees(ClientData	clientData,
		Tcl_Interp	*interp,
		int		argc,
		char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_rt_gettrees_cmd(wdbp, interp, argc, argv);
}

int
cmd_dbversion(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_version_cmd(wdbp, interp, argc, argv);
}

/**
 *		    C M D _ C O M B _ S T D
 *
 *	Input a combination in standard set-theoetic notation
 *
 *	Syntax: c [-gr] comb_name <boolean_expr>
 */
int
cmd_comb_std(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	CHECK_DBI_NULL;

	return wdb_comb_std_cmd(wdbp, interp, argc, argv);
}

int
cmd_nmg_collapse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	char *av[3];

	CHECK_DBI_NULL;

	if (wdb_nmg_collapse_cmd(wdbp, interp, argc, argv) == TCL_ERROR)
		return TCL_ERROR;

	av[0] = "e";
	av[1] = argv[2];
	av[2] = NULL;

	return cmd_draw(clientData, interp, 2, av);
}

/**
 *			F _ M A K E _ N A M E
 *
 * Generate an identifier that is guaranteed not to be the name
 * of any object currently in the database.
 *
 */
int
cmd_make_name(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_make_name_cmd(wdbp, interp, argc, argv);
}

int
cmd_shells(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_shells_cmd(wdbp, interp, argc, argv);
}

/**
 *  	F _ P A T H S U M :   does the following
 *		1.  produces path for purposes of matching
 *      	2.  gives all paths matching the input path OR
 *		3.  gives a summary of all paths matching the input path
 *		    including the final parameters of the solids at the bottom
 *		    of the matching paths
 */
int
cmd_pathsum(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int	ret;

	CHECK_DBI_NULL;

	if (argc < 2) {
		/* get the path */
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "Enter the path: ", (char *)NULL);
		return TCL_ERROR;
	}

#if 0
	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
	else
		return TCL_OK;
#endif

	ret = wdb_pathsum_cmd(wdbp, interp, argc, argv);

#if 0
	(void)signal( SIGINT, SIG_IGN );
#endif
	return ret;
}

/**
 *   	F _ C O P Y E V A L : copys an evaluated solid
 */
int
cmd_copyeval(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int ret;

	CHECK_DBI_NULL;

	if (argc < 3) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "Enter new_solid_name and full path to old_solid\n",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
	else
		return TCL_OK;

	ret = wdb_copyeval_cmd(wdbp, interp, argc, argv);

	(void)signal( SIGINT, SIG_IGN );
	return ret;
}


/**
 *			F _ P U S H
 *
 * The push command is used to move matrices from combinations
 * down to the solids. At some point, it is worth while thinking
 * about adding a limit to have the push go only N levels down.
 *
 * the -d flag turns on the treewalker debugging output.
 * the -P flag allows for multi-processor tree walking (not useful)
 * the -l flag is there to select levels even if it does not currently work.
 */
int
cmd_push(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_push_cmd(wdbp, interp, argc, argv);
}

int
cmd_hide(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_hide_cmd(wdbp, interp, argc, argv);
}

int
cmd_unhide(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_unhide_cmd(wdbp, interp, argc, argv);
}

int
cmd_xpush(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_xpush_cmd(wdbp, interp, argc, argv);
}

int
cmd_showmats(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_showmats_cmd(wdbp, interp, argc, argv);
}

int
cmd_nmg_simplify(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_nmg_simplify_cmd(wdbp, interp, argc, argv);
}

/**
 *			F _ M A K E _ B B
 *
 *	Build an RPP bounding box for the list of objects and/or paths passed to this routine
 */
int
cmd_make_bb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_make_bb_cmd(wdbp, interp, argc, argv);
}

int
cmd_whatid(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_whatid_cmd(wdbp, interp, argc, argv);
}

/**
 *      C M D _ W H I C H
 *
 *	Finds all regions with given region ids or air codes.
 */
int
cmd_which(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int		ret;

	CHECK_DBI_NULL;

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
	else
		return TCL_OK;

	ret = wdb_which_cmd(wdbp, interp, argc, argv);

	(void)signal(SIGINT, SIG_IGN);
	return ret;
}

/**
 *  			C M D _ T O P S
 *
 *  Find all top level objects.
 *  TODO:  Perhaps print all objects, sorted by use count, as an option?
 */
int
cmd_tops(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int		ret;

	CHECK_DBI_NULL;

	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
	else
		return TCL_OK;

	ret = wdb_tops_cmd(wdbp, interp, argc, argv);

	(void)signal(SIGINT, SIG_IGN);
	return ret;
}

/**
 *			C M D _ T R E E
 *
 *	Print out a list of all members and submembers of an object.
 */
int
cmd_tree(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	int		ret;

	CHECK_DBI_NULL;

#if 0
	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);  /* allow interupts */
	else
		return TCL_OK;
#endif

	/*
	 * The tree command is wrapped by tclscripts/tree.tcl and calls this
	 * routine with the name _mged_tree. So, we put back the original name.
	 */
	argv[0] = "tree";
	ret = dgo_tree_cmd(dgop, interp, argc, argv);

#if 0
	(void)signal(SIGINT, SIG_IGN);
#endif
	return ret;
}

/**
 *	C M D _ M V A L L
 *
 *	rename all occurences of an object
 *	format:	mvall oldname newname
 *
 */
int
cmd_mvall(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_move_all_cmd(wdbp, interp, argc, argv);
}

/**
 *			C M D _ D U P
 *
 *  Check for duplicate names in preparation for cat'ing of files
 *
 *  Usage:  dup file.g [prefix]
 *  becomes: db dup file.g [prefix]
 */
int
cmd_dup(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_dup_cmd(wdbp, interp, argc, argv);
}

/**
 *			C M D _ C O N C A T
 *
 *  Concatenate another GED file into the current file.
 *  Interrupts are not permitted during this function.
 *
 *  Usage:  dbconcat file.g [prefix]
 *  becomes: db concat file.g prefix
 *
 *  NOTE:  If a prefix is not given on the command line,
 *  then the users insist that they be prompted for the prefix,
 *  to prevent inadvertently sucking in a non-prefixed file.
 *  Slash ("/") specifies no prefix.
 */
int
cmd_concat(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	/* get any prefix */
	if (argc < 2) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "concat: Enter database: ",
				 (char *)NULL);
		return TCL_ERROR;
	}

	if (argc < 3) {
		Tcl_AppendResult(interp, MORE_ARGS_STR,
				 "concat: Enter prefix string or / for no prefix: ",
				 (char *)NULL);
		return TCL_ERROR;
	}

	/* replace dbconcat with concat */
	argv[0] = "concat";

	return wdb_concat_cmd(wdbp, interp, argc, argv);
}

/**
 * Rename an object
 * Format: mv oldname newname
 */
int
cmd_name(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_move_cmd(wdbp, interp, argc, argv);
}

/**
 * add solids to a region or create the region
 * and then add solids
 * Format: r regionname opr1 sol1 opr2 sol2 ... oprn soln
 */
int
cmd_region(ClientData	clientData,
	   Tcl_Interp	*interp,
	   int		argc,
	   char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_region_cmd(wdbp, interp, argc, argv);
}

/**
 * Delete members of a combination
 * Format: rm comb memb1 memb2 .... membn
 */
int
cmd_remove(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_remove_cmd(wdbp, interp, argc, argv);
}

/**
 *			C M D _ U N I T S
 *
 * Change the local units of the description.
 * Base unit is fixed in mm, so this just changes the current local unit
 * that the user works in.
 */
int
cmd_units(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	register struct dm_list *dmlp;
	int		ret;
	fastf_t		sf;

	CHECK_DBI_NULL;

	sf = dbip->dbi_base2local;
	ret = wdb_units_cmd(wdbp, interp, argc, argv);

	set_localunit_TclVar();
	sf = dbip->dbi_base2local / sf;
	update_grids(sf);
	update_views = 1;

	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l) {
		dmlp->dml_view_state->vs_vop->vo_local2base = dbip->dbi_local2base;
		dmlp->dml_view_state->vs_vop->vo_base2local = dbip->dbi_base2local;
	}

	return ret;
}

/**
 *	Change the current title of the description
 */
int
cmd_title(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	int	ret;

	CHECK_DBI_NULL;

	ret = wdb_title_cmd(wdbp, interp, argc, argv);
	view_state->vs_flag = 1;

	return ret;
}

/**
 *  			C M D _ P R C O L O R
 */
int
cmd_prcolor(ClientData	clientData,
	    Tcl_Interp	*interp,
	    int		argc,
	    char	**argv)
{
	return wdb_prcolor_cmd(wdbp, interp, argc, argv);
}

/** List object information, briefly
 * Format: cat object
 */
int
cmd_cat(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	int ret;

	CHECK_DBI_NULL;

#if 0
	if (setjmp(jmp_env) == 0)
		(void)signal(SIGINT, sig3);	/* allow interupts */
	else
		return TCL_OK;
#endif

	ret = wdb_cat_cmd(wdbp, interp, argc, argv);

#if 0
	(void)signal(SIGINT, SIG_IGN);
#endif
	return ret;
}

/**
 *  			C M D _ C O L O R
 *
 *  Add a color table entry.
 */
int
cmd_color(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	int ret;

	CHECK_DBI_NULL;

	ret = wdb_color_cmd(wdbp, interp, argc, argv);
	color_soltab();

	return ret;
}

/**
 *			C M D _ C O M B
 *
 *  Create or add to the end of a combination, with one or more solids,
 *  with explicitly specified operations.
 *
 *  Format: comb comb_name sol1 opr2 sol2 ... oprN solN
 */
int
cmd_comb(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	CHECK_DBI_NULL;

	return wdb_comb_cmd(wdbp, interp, argc, argv);
}

/** Copy an object
 * Format: cp oldname newname
 */
int
cmd_copy(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	int ret;
	char *av[3];

	CHECK_DBI_NULL;

	if ((ret = wdb_copy_cmd(wdbp, interp, argc, argv)) != TCL_OK)
		return ret;

	av[0] = "e";
	av[1] = argv[2]; /* depends on solid name being in argv[2] */
	av[2] = NULL;

	/* draw the new object */
	return cmd_draw(clientData, interp, 2, av);
}

/**
 *                C M D _ E X P A N D
 *
 * Performs wildcard expansion (matched to the database elements)
 * on its given arguments.  The result is returned by Tcl_GetStringResult(interp).
 */
int
cmd_expand(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    CHECK_DBI_NULL;

    return wdb_expand_cmd(wdbp, interp, argc, argv);
}

/**
 *			C M D _ L S
 *
 * This routine lists the names of all the objects accessible
 * in the object file.
 */
int
cmd_ls(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_ls_cmd(wdbp, interp, argc, argv);
}

/**
 *  			C M D _ F I N D
 *
 *  Find all references to the named objects.
 */
int
cmd_find(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_find_cmd(wdbp, interp, argc, argv);
}

/** Grouping command
 * Format: g groupname object1 object2 .... objectn
 */
int
cmd_group(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_group_cmd(wdbp, interp, argc, argv);
}

/** Create an instance of something
 * Format: i object combname [op]
 */
int
cmd_instance(ClientData	clientData,
	     Tcl_Interp *interp,
	     int	argc,
	     char	**argv)
{
	CHECK_DBI_NULL;

	return wdb_instance_cmd(wdbp, interp, argc, argv);
}

int
cmd_keep(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	CHECK_DBI_NULL;

	return wdb_keep_cmd(wdbp, interp, argc, argv);
}

/**
 *			C M D _ L I S T
 *
 *  List object information, verbose, in GIFT-compatible format.
 *  Format: l object
 */
int
cmd_list(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	int recurse=0;

	CHECK_DBI_NULL;

	if (argc > 1 && argv[1][0] == '-' && argv[1][1] == 'r' && argv[1][2] == '\0')
		recurse = 1;

	/*
	 * Here we have no usable arguments,
	 * so we better be in an edit state.
	 */
	if ((argc == 1 || (argc == 2 && recurse)) && illump != SOLID_NULL) {
		struct bu_vls	vls;
		int		ret;
		int		ac;
		char		*av[4];

		bu_vls_init(&vls);

		if (state == ST_S_EDIT)
			db_path_to_vls( &vls, &illump->s_fullpath );
		else if (state == ST_O_EDIT) {
			register int	i;
			for( i=0; i < ipathpos; i++ ) {
				bu_vls_printf(&vls, "/%s",
					      DB_FULL_PATH_GET(&illump->s_fullpath,i)->d_namep );
			}
		} else
			return TCL_ERROR;

		if (recurse) {
			av[0] = "l";
			av[1] = "-r";
			av[2] = bu_vls_addr(&vls);
			av[3] = (char *)NULL;
			ac = 3;
		} else {
			av[0] = "l";
			av[1] = bu_vls_addr(&vls);
			av[2] = (char *)NULL;
			ac = 2;
		}
		ret = wdb_list_cmd(wdbp, interp, ac, av);
		bu_vls_free(&vls);
		return ret;
	} else {
		return wdb_list_cmd(wdbp, interp, argc, argv);
	}
}

/**
 *			C M D _ L M
 *
 *	List regions based on values of their MUVES_Component attribute
 */
int
cmd_lm(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	struct bu_attribute_value_set avs;
	struct bu_vls vls;
	struct bu_ptbl *tbl;
	struct directory *dp;
	int i;
	int last_opt=0;
	int new_arg_count=1;
	int new_argc;
	int ret;
	char **new_argv;

	bu_vls_init( &vls );
	bu_vls_strcat( &vls, argv[0] );
	for( i=1 ; i<argc ; i++ ) {
		if( *argv[i] == '-' ) {
			bu_vls_putc( &vls, ' ' );
			bu_vls_strcat( &vls, argv[i] );
			last_opt = i;
			new_arg_count++;
		} else {
			break;
		}
	}

	bu_avs_init( &avs, argc - last_opt, "cmd_lm avs" );
	for( i=last_opt+1 ; i<argc ; i++ ) {
		bu_avs_add_nonunique( &avs, "MUVES_Component", argv[i] );
	}

	tbl = db_lookup_by_attr( dbip, DIR_REGION, &avs, 2 );
	if( !tbl ) {
		/* Error!!! */
		Tcl_AppendResult( interp, "Error: db_lookup_by_attr() failed!!\n", (char *)NULL );
		bu_vls_free( &vls );
		bu_avs_free( &avs );
		return TCL_ERROR;
	}

	if( BU_PTBL_LEN( tbl ) == 0 ) {
		/* no matches */
		bu_vls_free( &vls );
		bu_avs_free( &avs );
		bu_ptbl_free( tbl );
		bu_free( (char *)tbl, "cmd_lm ptbl" );
		return TCL_OK;
	}

	for( i=0 ; i<BU_PTBL_LEN( tbl ) ; i++ ) {
		dp = (struct directory *)BU_PTBL_GET( tbl, i );
		bu_vls_putc( &vls, ' ' );
		bu_vls_strcat( &vls, dp->d_namep );
		new_arg_count++;
	}

	bu_ptbl_free( tbl );
	bu_free( (char *)tbl, "cmd_lm ptbl" );

	/* create a new argc and argv to pass to the cmd_ls routine */
	new_argv = (char **)bu_calloc( new_arg_count + 1, sizeof( char *), "cmd_lm new_argv" );
	new_argc = bu_argv_from_string( new_argv, new_arg_count+1, bu_vls_addr( &vls ) );

	ret = cmd_ls( clientData, interp, new_argc, new_argv );

	bu_vls_free( &vls );
	bu_free( (char *)new_argv, "cmd_lm new_argv" );

	return( ret );
}


/**
 *			C M D _ L T
 *
 *  List object information in a tcl list. The
 *  tcl list is a list of {op obj} pairs.
 */
int
cmd_lt(ClientData	clientData,
       Tcl_Interp	*interp,
       int		argc,
       char		**argv)
{
	return wdb_lt_cmd(wdbp, interp, argc, argv);
}

/**
 *			F _ T O L
 *
 *  "tol"	displays current settings
 *  "tol abs #"	sets absolute tolerance.  # > 0.0
 *  "tol rel #"	sets relative tolerance.  0.0 < # < 1.0
 *  "tol norm #" sets normal tolerance, in degrees.
 *  "tol dist #" sets calculational distance tolerance
 *  "tol perp #" sets calculational normal tolerance.
 */
int
cmd_tol(ClientData	clientData,
	Tcl_Interp	*interp,
	int		argc,
	char		**argv)
{
	int ret;

	CHECK_DBI_NULL;

	ret = wdb_tol_cmd(wdbp, interp, argc, argv);

	/* hack to keep mged tolerance settings current */
	mged_ttol = wdbp->wdb_ttol;
	mged_tol = wdbp->wdb_tol;
	mged_abs_tol = mged_ttol.abs;
	mged_rel_tol = mged_ttol.rel;
	mged_nrm_tol = mged_ttol.norm;

	return( ret );
}

/* defined in chgview.c */
extern int edit_com(int argc, char **argv, int kind, int catch_sigint);

/**
 * ZAP the display -- then edit anew
 * Format: B object
 */
int
cmd_blast(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	char *av[2];

	av[0] = "Z";
	av[1] = (char *)0;

	if (cmd_zap(clientData, interp, 1, av) == TCL_ERROR)
		return TCL_ERROR;
        
        if( argc == 1 ) /* "B" alone is same as "Z" */
            return TCL_OK;

	return edit_com(argc, argv, 1, 1);
}

/**
 * Edit something (add to visible display)
 * Format: e object
 */
int
cmd_draw(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	return edit_com(argc, argv, 1, 1);
}

extern int emuves_com( int argc, char **argv );	/* from chgview.c */

/**
 * Add regions with attribute MUVES_Component haveing the specified values
 * Format: em value [value value ...]
 */
int
cmd_emuves(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char		**argv)
{
	return emuves_com(argc, argv);
}

/**
 * Format: ev objects
 */
int
cmd_ev(ClientData	clientData,
       Tcl_Interp *interp,
       int	argc,
       char	**argv)
{
	return edit_com(argc, argv, 3, 1);
}

/**
 *			C M D _ V D R A W
 */
int
cmd_vdraw(ClientData	clientData,
	  Tcl_Interp	*interp,
	  int		argc,
	  char		**argv)
{
	CHECK_DBI_NULL;

	return dgo_vdraw_cmd(dgop, interp, argc, argv);
}

/**
 *			C M D _ E
 *
 *  The "Big E" command.
 *  Evaluated Edit something (add to visible display)
 *  Usage: E object(s)
 */
int
cmd_E(ClientData	clientData,
	 Tcl_Interp	*interp,
	 int		argc,
	 char	**argv)
{
	int	initial_blank_screen;
	register struct dm_list *dmlp;
	register struct dm_list *save_dmlp;
	register struct cmd_list *save_cmd_list;
	int ret;

	CHECK_DBI_NULL;
	initial_blank_screen = BU_LIST_IS_EMPTY(&dgop->dgo_headSolid);

	if ((ret = dgo_E_cmd(dgop, interp, argc, argv)) != TCL_OK)
		return ret;

	update_views = 1;

	save_dmlp = curr_dm_list;
	save_cmd_list = curr_cmd_list;
	FOR_ALL_DISPLAYS(dmlp, &head_dm_list.l){
		curr_dm_list = dmlp;
		if (curr_dm_list->dml_tie)
			curr_cmd_list = curr_dm_list->dml_tie;
		else
			curr_cmd_list = &head_cmd_list;

		/* If we went from blank screen to non-blank, resize */
		if (mged_variables->mv_autosize  && initial_blank_screen &&
		    BU_LIST_NON_EMPTY(&dgop->dgo_headSolid)) {
			struct view_ring *vrp;

			size_reset();
			new_mats();
			(void)mged_svbase();

			for (BU_LIST_FOR(vrp, view_ring, &view_state->vs_headView.l))
				vrp->vr_scale = view_state->vs_vop->vo_scale;
		}
	}

	curr_dm_list = save_dmlp;
	curr_cmd_list = save_cmd_list;

	return TCL_OK;
}

int
cmd_bot_face_sort( ClientData	clientData,
	Tcl_Interp	*interp,
	int     	argc,
	char    	**argv)
{
	CHECK_DBI_NULL;
	return wdb_bot_face_sort_cmd( wdbp, interp, argc, argv );
}

int
cmd_bot_decimate( ClientData	clientData,
	Tcl_Interp	*interp,
	int     	argc,
	char    	**argv)
{
	CHECK_DBI_NULL;
	return wdb_bot_decimate_cmd( wdbp, interp, argc, argv );
}


int
cmd_shaded_mode(ClientData	clientData,
		Tcl_Interp	*interp,
		int     	argc,
		char    	**argv)
{
	/* check to see if we have -a or -auto */
	if (argc == 3 &&
	    strlen(argv[1]) >= 2 &&
	    argv[1][0] == '-' &&
	    argv[1][1] == 'a') {
	  struct bu_vls vls;

	  /* set zbuffer, zclip and lighting for all */
	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "mged_shaded_mode_helper %s", argv[2]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);

	  /* skip past -a */
	  --argc;
	  ++argv;
	}

	return dgo_shaded_mode_cmd(dgop, interp, argc, argv);
}

/* XXX needs to be provided from points header */
extern int parse_point_file(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

int
cmd_parse_points(ClientData	clientData,
		Tcl_Interp	*interp,
		int     	argc,
		char    	**argv)
{

#ifndef BC_WITH_PARSERS
    bu_log("parse_points was disabled in this compilation of mged due to system limitations\n");
    return TCL_ERROR;
#else
    if (argc != 2) {
	bu_log("parse_points only supports a single file name right now\n");
	bu_log("doing nothing\n");
	return TCL_ERROR;
    }
    return parse_point_file(clientData, interp, argc-1, &(argv[1]));
#endif
}

int
cmd_has_embedded_fb(ClientData	clientData,
		    Tcl_Interp	*interp,
		    int     	argc,
		    char    	**argv)
{
    Tcl_DString ds;

    Tcl_DStringInit(&ds);
#ifdef USE_FBSERV
    Tcl_DStringAppend(&ds, "1", -1);
#else
    Tcl_DStringAppend(&ds, "0", -1);
#endif
    Tcl_DStringResult(interp, &ds);

    return TCL_OK;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.61
log
@header cleanup
@
text
@d220 1
@


14.60
log
@Added the following two commands: ae2dir and viewdir.
@
text
@d22 1
a22 4
 * Functions -
 *	f_press		hook for displays with no buttons
 *	f_summary	do directory summary
 *	mged_cmd		Check arg counts, run a command
a26 5
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
a28 4
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.59 2007/12/16 18:53:50 brlcad Exp $ (BRL)";
#endif

@


14.59
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.58 2007/12/16 15:59:40 brlcad Exp $ (BRL)";
d178 1
d461 1
@


14.58
log
@convert all bzero calls to memset
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.57 2007/12/02 22:34:22 brlcad Exp $ (BRL)";
d1826 1
a1826 2
	bcopy((void *)dml->dml_scroll_array, (void *)scroll_array,
	      sizeof(struct scroll_item *) * 6);
d1877 1
a1877 2
	bcopy( (void *)dml->dml_scroll_array, (void *)scroll_array,
	       sizeof(struct scroll_item *) * 6);
d2138 1
a2138 1
	    memcpy( &bots[0]->vertices[3*avail_vert], bots[i]->vertices, bots[i]->num_vertices*3*sizeof(fastf_t));
@


14.57
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.56 2007/11/21 15:52:58 erikgreenwald Exp $ (BRL)";
d787 1
a787 1
			bzero((void *)clp, sizeof(struct cmd_list));
@


14.56
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.55 2007/10/22 19:38:34 erikgreenwald Exp $ (BRL)";
d2362 1
a2362 1
	snprintf(buffer, 1024, bu_vls_addr(&vls));
@


14.55
log
@move to using the new bu_vls_strcmp macro
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.54 2007/10/17 01:36:23 brlcad Exp $ (BRL)";
d2366 1
a2366 1
    bu_bomb(buffer);
@


14.54
log
@change wdb_tree_cmd() to dgo_tree_cmd() so that we can have access to the display geometry (particularly, to get access to the 'who' command).  modify the behavior of the mged 'tree' command so that if you don't provide it any options, it will display the tree for all objects displayed.  this is in response and inspired by a tcl snippet from david loman that needed this functionality to aid in analyzing gqa output.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.53 2007/10/12 01:21:50 johnranderson Exp $ (BRL)";
d1769 1
a1769 1
		if(!strcmp(bu_vls_addr(&vls), bu_vls_addr(&dlp->dml_dmp->dm_pathName)))
@


14.53
log
@"B -A" no longer acts like you gave it the wrong syntax if nothing matches.
Also, "B" commanad with no args now acts like "Z".
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.52 2007/09/15 16:23:16 brlcad Exp $ (BRL)";
d2767 1
a2767 1
	ret = wdb_tree_cmd(wdbp, interp, argc, argv);
@


14.52
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.51 2007/09/14 15:21:09 erikgreenwald Exp $ (BRL)";
d3344 3
@


14.51
log
@removed trailing whitespace
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.50 2007/07/10 18:39:58 brlcad Exp $ (BRL)";
d48 2
a49 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.50
log
@make 'bomb' an actual new command, passing through to bu_bomb().  very useful for debugging, tracing, and aborting from scripts abruptly.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.49 2007/06/16 21:17:24 johnranderson Exp $ (BRL)";
d1957 1
a1957 1
    
@


14.50.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.52 2007/09/15 16:23:16 brlcad Exp $ (BRL)";
d48 5
a52 2
#include <string.h>

d1957 1
a1957 1

@


14.49
log
@Eliminated direct access of interp->result (Not reliable since tcl 8.0).
See the comment in tcl.h.
This also fixes the "units" command.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.48 2007/05/20 22:46:24 brlcad Exp $ (BRL)";
a172 3
#if 1
	{"test_bomb_hook", f_test_bomb_hook},
#endif
d196 1
a2353 1
#if 1
d2355 1
a2355 1
f_test_bomb_hook(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d2357 5
a2361 1
	bu_bomb("\nTesting MGED's bomb hook!\n");
d2363 11
a2373 2
	/* This is never reached */
	return TCL_OK;
a2374 1
#endif
@


14.48
log
@unlink the variables we link on shutdown so we can clean up memory tcl allocated for managing them.  delete the tcl interpreter on shutdown too.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.47 2007/03/06 23:02:48 brlcad Exp $ (BRL)";
d637 1
a637 1
	if (status != TCL_OK || interp->result[0] == '\0') {
d703 1
a703 1
		    interp->result[0] != '\0') {
d705 1
a705 1
			       interp->result);
d1186 1
d1216 1
d1224 1
a1224 1
			len = strlen(interp->result);
d1230 2
a1231 2
				bu_log("%s%s", interp->result,
				       interp->result[len-1] == '\n' ? "" : "\n");
d1240 1
a1240 1
					      bu_vls_addr(&save_vp), interp->result);
d1263 2
a1264 2
		if ((cp = strstr(interp->result, MORE_ARGS_STR)) != NULL) {
			if(cp == interp->result){
d1267 1
a1267 1
					      interp->result+sizeof(MORE_ARGS_STR)-1);
d1269 2
a1270 2
				len = cp - interp->result;
				bu_log("%*s%s", len, interp->result, interp->result[len-1] == '\n' ? "" : "\n");
d1273 1
a1273 1
					      interp->result+sizeof(MORE_ARGS_STR)-1+len);
d1282 3
a1284 3
		len = strlen(interp->result);
		if (len > 0) bu_log("%s%s", interp->result,
				    interp->result[len-1] == '\n' ? "" : "\n");
d1309 1
d1314 1
a1314 1
		len = strlen(interp->result);
d1318 2
a1319 2
			bu_log("%s%s", interp->result,
			       interp->result[len-1] == '\n' ? "" : "\n");
d1328 1
a1328 1
		len = strlen(interp->result);
d1330 2
a1331 2
			bu_log("%s%s", interp->result,
			       interp->result[len-1] == '\n' ? "" : "\n");
d1339 1
a1339 1
	len = strlen(interp->result);
d1341 2
a1342 2
		bu_log("%s%s", interp->result,
		       interp->result[len-1] == '\n' ? "" : "\n");
d3046 1
a3046 1
 * on its given arguments.  The result is returned in interp->result.
@


14.47
log
@should no longer need the tcl-private tclInt.h header... (definitely needs more testing, but progress towards NOT using it)
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.46 2007/01/27 01:41:43 brlcad Exp $ (BRL)";
d122 1
d1948 15
@


14.46
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.45 2007/01/23 01:13:41 brlcad Exp $ (BRL)";
a68 1
#include "tclInt.h"
@


14.45
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.44 2007/01/20 14:36:57 brlcad Exp $ (BRL)";
d1708 1
a1708 1
                                                &clp->cl_tie->dml_dmp->dm_pathName);
d1726 4
a1729 4
                bu_vls_printf(&vls, "help tie");
                Tcl_Eval(interp, bu_vls_addr(&vls));
                bu_vls_free(&vls);
                return TCL_ERROR;
a2058 2


a2091 1

a2156 1

d2545 1
a2545 1
        else
d2576 1
a2576 1
        else
d2683 1
a2683 1
        else
d2707 1
a2707 1
        else
d2890 1
a2890 1
 	set_localunit_TclVar();
d3324 1
a3324 1
/** 
@


14.44
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.43 2007/01/12 05:42:09 brlcad Exp $ (BRL)";
@


14.43
log
@update c command help, the expression is not optional (it wants at least the first object name)
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.42 2006/12/12 20:25:11 mjgillich Exp $ (BRL)";
@


14.42
log
@Changed smooth_bot to bot_smooth inorder to match other bot commands and functions.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.41 2006/08/29 23:26:51 brlcad Exp $ (BRL)";
d2469 1
a2469 1
 *	Syntax: c [-gr] comb_name [boolean_expr]
@


14.41
log
@sync via db_sync instead of fsync'ing directly.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.40 2006/08/29 23:15:36 brlcad Exp $ (BRL)";
d140 1
a140 1
extern int cmd_smooth_bot();
d205 1
a205 1
	{"bot_smooth", cmd_smooth_bot },
@


14.40
log
@remove the sync() call.  instead just fsync() the currently open geometry database file.  doxygenify the comments while we're in here.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.39 2006/08/29 21:51:26 brlcad Exp $ (BRL)";
d1499 2
a1500 3
#ifdef HAVE_FSYNC
	if (dbip) {
	    fsync(dbip->dbi_fd);
a1501 1
#endif
@


14.39
log
@no need to forward declare it if we just move the definition up
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.38 2006/08/29 20:12:50 bob1961 Exp $ (BRL)";
a129 1

a132 4

#ifndef HAVE_UNISTD_H
extern void sync();
#endif
d494 1
a494 1
/*
a498 1

d513 1
a513 1
/*
a518 1

d525 1
a525 1
/*
a529 1

d536 1
a536 1
/*
a542 1

d573 1
a573 1
/*
d603 1
a603 1
/*
a608 1

d660 1
a660 1
/*
d670 1
a670 1
/*
a675 1

d686 2
a687 1
/* 			C M D _ S E T U P
d1013 1
a1013 1
/*
a1016 1

d1059 3
a1061 1
/*                    M G E D _ C O M P A T
a1065 1

d1164 2
a1165 1
/*
a1175 1

d1349 1
a1349 1
/*
a1355 1

d1413 4
a1416 3
/* Let the user temporarily escape from the editor */
/* Format: %	*/

d1453 4
a1456 3
/* Quit and exit gracefully */
/* Format: q	*/

d1482 3
a1484 2
/* wrapper for sync() */

d1493 1
a1493 1
		bu_vls_printf(&vls, "help sync");
d1498 5
a1502 3
/* XXXXXXXXXXXXXXX FIX LATER XXXXXXXXXXXXXXXXX */
#ifndef _WIN32
	sync();
d1508 1
a1508 1
/*
a1512 1

d1542 1
a1542 1
/*
a1547 1

d1593 1
a1593 1
/*
a1597 1

d1661 1
a1661 1
/*
d1846 1
a1846 1
/*
d2466 1
a2466 1
/*
d2501 2
a2502 1
/*			F _ M A K E _ N A M E
d2527 2
a2528 1
/*  	F _ P A T H S U M :   does the following
d2564 2
a2565 1
/*   	F _ C O P Y E V A L : copys an evaluated solid
a2566 1

d2593 2
a2594 1
/*			F _ P U S H
d2655 2
a2656 1
/*			F _ M A K E _ B B
a2659 1

d2676 1
a2676 1
/*
d2699 1
a2699 1
/*
d2723 1
a2723 1
/*
d2758 2
a2759 1
/*	C M D _ M V A L L
d2776 1
a2776 2
/*
 *
d2792 1
a2792 1
/*
d2832 4
a2835 2
/* Rename an object */
/* Format: mv oldname newname	*/
d2847 5
a2851 3
/* add solids to a region or create the region */
/* and then add solids */
/* Format: r regionname opr1 sol1 opr2 sol2 ... oprn soln */
d2863 4
a2866 2
/* Delete members of a combination */
/* Format: rm comb memb1 memb2 .... membn	*/
d2875 1
a2875 1
/*
d2910 1
a2910 1
/*
d2929 1
a2929 1
/*
d2941 3
a2943 2
/* List object information, briefly */
/* Format: cat object	*/
d2969 1
a2969 1
/*
d2990 1
a2990 1
/*
d3006 3
a3008 2
/* Copy an object */
/* Format: cp oldname newname	*/
d3031 1
a3031 1
/*
d3045 1
a3045 1
/*
d3062 1
a3062 1
/*
d3078 3
a3080 2
/* Grouping command */
/* Format: g groupname object1 object2 .... objectn	*/
d3092 3
a3094 2
/* Create an instance of something */
/* Format: i object combname [op]	*/
d3117 1
a3117 1
/*
d3179 1
a3179 1
/*
d3260 1
a3260 1
/*
d3275 1
a3275 1
/*
d3310 4
a3313 2
/* ZAP the display -- then edit anew */
/* Format: B object	*/
d3331 4
a3334 2
/* Edit something (add to visible display) */
/* Format: e object	*/
d3346 4
a3349 2
/* Add regions with attribute MUVES_Component haveing the specified values */
/* Format: em value [value value ...]	*/
d3359 3
a3361 1
/* Format: ev objects	*/
d3371 1
a3371 1
/*
d3385 1
a3385 1
/*
@


14.38
log
@Mods to get things to natively compile on Windows.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.37 2006/08/28 12:51:24 brlcad Exp $ (BRL)";
a129 4
#ifdef _WIN32
  /* limited to seconds only */
  void gettimeofday(struct timeval *tp, struct timezone *tzp);
#endif
d1159 15
a3448 15
#ifdef _WIN32
/* limited to seconds only */
void gettimeofday(struct timeval *tp, struct timezone *tzp)
{

	time_t ltime;

	time( &ltime );

	tp->tv_sec = ltime;
	tp->tv_usec = 0;

}
#endif

@


14.37
log
@ws
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.36 2006/08/08 06:15:45 brlcad Exp $ (BRL)";
d130 5
@


14.36
log
@enable the 'pov' command, getting rid of the peculiar undocumented TCP_FILES define.  move cmd_pov over to chgview.c like the comment suggests. (note that the command guts are over in librt)
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.35 2006/08/08 02:54:44 brlcad Exp $ (BRL)";
d1201 5
a1205 4
	if (glob_compat_mode)
		mged_compat(&globbed, vp, 0);
	else
		bu_vls_vlscat(&globbed, vp);
@


14.35
log
@decouple DM_X from the other display manager interfaces, clean up the preprocessor logic so Windows does not need to declare DM_X but also to avoid using _WIN32 where possible as well.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.34 2006/05/15 20:19:17 brlcad Exp $ (BRL)";
a361 1
#ifdef TCP_FILES
a362 1
#endif
@


14.34
log
@ugh, removed horrible usage of vls strings for things that can just be string constants.  also takes care of a memory leak as the vls was never released.  thanks to jim monte for noticing the problem.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.33 2006/05/15 20:02:23 brlcad Exp $ (BRL)";
d67 2
a68 5
#ifdef DM_X
#  include "tk.h"
#else
#  include "tcl.h"
#endif
d157 1
a157 1

a163 3
#if DM_X
Tk_Window tkwin = NULL;
#endif
a166 4
#ifdef _WIN32
void gettimeofday(struct timeval *tp, struct timezone *tzp);
#endif

a194 1
#ifdef DM_X
a195 1
#endif
a241 1
#ifdef DM_X
a242 1
#endif
a244 1
#ifdef DM_X
a245 1
#endif
a256 1
#ifdef DM_X
a257 1
#endif
a307 1
#ifdef DM_X
a308 1
#endif
a320 1
#ifdef DM_X
a322 1
#endif
a324 1
#ifdef DM_X
a326 1
#endif
a340 1
#ifdef DM_X
a341 1
#endif
a387 1
#ifdef DM_X
a388 1
#endif
@


14.33
log
@jim monte noticed that using a vls here was unnecessary for the Tcl_LinkVar'ing of glob_compat_mode and output_as_return
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.32 2006/04/06 20:50:03 brlcad Exp $ (BRL)";
d1963 8
a1970 21
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_strcpy(&vls, "mged_default(dlist)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&mged_default_dlist, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "mged_default(db_warn)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&db_warn, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "mged_default(db_upgrade)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&db_upgrade, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "mged_default(db_version)");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&db_version, TCL_LINK_INT);

	bu_vls_strcpy(&vls, "edit_class");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&es_edclass, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "edit_solid_flag");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&es_edflag, TCL_LINK_INT);
	bu_vls_strcpy(&vls, "edit_object_flag");
	Tcl_LinkVar(interp, bu_vls_addr(&vls), (char *)&edobj, TCL_LINK_INT);

	bu_vls_init(&edit_info_vls);
	bu_vls_strcpy(&edit_info_vls, "edit_info");
@


14.32
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.31 2006/01/28 22:46:19 brlcad Exp $ (BRL)";
d778 3
a780 6
	bu_vls_strcpy(&temp, "glob_compat_mode");
	Tcl_LinkVar(interp, bu_vls_addr(&temp), (char *)&glob_compat_mode,
		    TCL_LINK_BOOLEAN);
	bu_vls_strcpy(&temp, "output_as_return");
	Tcl_LinkVar(interp, bu_vls_addr(&temp), (char *)&output_as_return,
		    TCL_LINK_BOOLEAN);
@


14.31
log
@header cleanup, include stdlib.h for atol(). fixes some 64-bitness
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.30 2006/01/27 22:11:01 bob1961 Exp $ (BRL)";
d48 1
d57 6
a62 1
#include <time.h>
d1997 1
a1997 1
	int i, edge, e, f ;
d2018 1
a2018 1
	    Tcl_AppendResult(interp, "rt_db_get_internal(", argv[i], ") error\n", (char *)NULL);
d2024 1
a2024 1
	    Tcl_AppendResult(interp, argv[i], " is not a BOT solid!!!  skipping\n", (char *)NULL );
@


14.31.2.1
log
@update from HEAD
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.31 2006/01/28 22:46:19 brlcad Exp $ (BRL)";
a47 1
#include <time.h>
d56 1
a56 6
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
d1991 1
a1991 1
	int edge, e, f ;
d2012 1
a2012 1
	    Tcl_AppendResult(interp, "rt_db_get_internal(", argv[1], ") error\n", (char *)NULL);
d2018 1
a2018 1
	    Tcl_AppendResult(interp, argv[1], " is not a BOT solid!!!  skipping\n", (char *)NULL );
@


14.30
log
@Added cmd_has_embedded_fb().
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d44 1
@


14.29
log
@er, if BC_WITH_PARSERS is NOT defined..
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.28 2006/01/21 19:30:06 brlcad Exp $ (BRL)";
d295 1
d3537 19
@


14.28
log
@disable the parse_points command conditionally depending on new configure checks for yacc/lex, output a message if it was disabled
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.27 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d3523 1
a3523 1
#ifdef BC_WITH_PARSERS
@


14.27
log
@update copyright to 2006
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.26 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d3522 5
a3531 5

#ifdef _WIN32
    /*XXX Temporary, until this is working on Windows */
    return TCL_OK;
#else
@


14.26
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.25 2005/12/13 22:20:53 brlcad Exp $ (BRL)";
@


14.25
log
@revert back to a non-pointer bu_vls so we're not calling bu_vls_init() on a NULL pointer.  bu_vls_init() was updated to allow multiple init statements
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.24 2005/12/13 03:47:13 brlcad Exp $ (BRL)";
a717 1

d755 1
a755 1
	{
d762 5
a769 5
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "source %s/mged/tree.tcl", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

d778 5
d786 1
d3528 4
d3533 1
@


14.24
log
@move mged_setup() to it's own file setup.h.; make the tcl_output_hook static since it's not needed anywhere else; move the Tcl_Interp interp global to ged.c
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.23 2005/12/04 06:08:06 brlcad Exp $ (BRL)";
d158 1
a158 1
static struct bu_vls *tcl_output_hook = NULL;
d588 1
a588 1
	(void)Tcl_DStringAppendElement(&tclcommand, bu_vls_addr(tcl_output_hook));
d682 2
a683 5

	if (!tcl_output_hook) {
	    bu_vls_init(tcl_output_hook);
	}
	bu_vls_strcpy(tcl_output_hook, argv[1]);
@


14.23
log
@add clone and tracker commands from the newly added clone.c for unannounced internal testing
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.22 2005/12/04 05:15:57 brlcad Exp $ (BRL)";
d116 2
a117 1
void mged_setup(void), cmd_setup(void), mged_compat(struct bu_vls *dest, struct bu_vls *src, int use_first);
d125 3
a127 1
extern int f_hide(), f_unhide();
a143 2
extern void mged_view_obj_callback(genptr_t clientData, struct view_obj *vop);

a153 2
int mged_cmd(int argc, char **argv, struct funtab *in_functions);
struct bu_vls tcl_output_hook;
d155 5
a159 1
Tcl_Interp *interp = NULL;
d164 2
d588 1
a588 1
	(void)Tcl_DStringAppendElement(&tclcommand, bu_vls_addr(&tcl_output_hook));
d683 4
a686 1
	bu_vls_strcpy(&tcl_output_hook, argv[1]);
a720 78
/*
 *
 * Sets up the Tcl interpreter
 */
void
mged_setup(void)
{
	struct bu_vls str;

	/* The following is for GUI output hooks: contains name of function to
	   run with output */
	bu_vls_init(&tcl_output_hook);

	Tcl_FindExecutable(bu_argv0(NULL));

	/* Create the interpreter */
	interp = Tcl_CreateInterp();

	/* This runs the init.tcl script */
	if( Tcl_Init(interp) == TCL_ERROR )
		bu_log("Tcl_Init error %s\n", interp->result);

	/* Initialize [incr Tcl] */
	if (Itcl_Init(interp) == TCL_ERROR)
	  bu_log("Itcl_Init error %s\n", interp->result);

	/* Import [incr Tcl] commands into the global namespace. */
	if (Tcl_Import(interp, Tcl_GetGlobalNamespace(interp),
		       "::itcl::*", /* allowOverwrite */ 1) != TCL_OK)
	  bu_log("Tcl_Import error %s\n", interp->result);


	/* Initialize libbu */
	Bu_Init(interp);

	/* Initialize libbn */
	Bn_Init(interp);

	/* Initialize librt (includes database, drawable geometry and view objects) */
	if (Rt_Init(interp) == TCL_ERROR) {
		bu_log("Rt_Init error %s\n", interp->result);
	}

	/* initialize MGED's drawable geometry object */
	dgop = dgo_open_cmd("mged", wdbp);

	view_state->vs_vop = vo_open_cmd("");
	view_state->vs_vop->vo_callback = mged_view_obj_callback;
	view_state->vs_vop->vo_clientData = view_state;
	view_state->vs_vop->vo_scale = 500;
	view_state->vs_vop->vo_size = 2.0 * view_state->vs_vop->vo_scale;
	view_state->vs_vop->vo_invSize = 1.0 / view_state->vs_vop->vo_size;
	MAT_DELTAS_GET_NEG(view_state->vs_orig_pos, view_state->vs_vop->vo_center);

	/* register commands */
	cmd_setup();

	history_setup();
	mged_global_variable_setup(interp);
#if !TRY_NEW_MGED_VARS
	mged_variable_setup(interp);
#endif

	/* Locate the BRL-CAD-specific Tcl scripts, set the auto_path */
	tclcad_auto_path(interp);

	/* Tcl needs to write nulls onto subscripted variable names */
	bu_vls_init(&str);
	bu_vls_printf( &str, "%s(state)", MGED_DISPLAY_VAR );
	Tcl_SetVar(interp, bu_vls_addr(&str), state_str[state], TCL_GLOBAL_ONLY);

	/* initialize "Query Ray" variables */
	init_qray();

	Tcl_ResetResult(interp);

	bu_vls_free(&str);
}
@


14.22
log
@sort commands alphabetically
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.21 2005/10/31 07:11:08 brlcad Exp $ (BRL)";
d216 1
d470 1
@


14.21
log
@quell warnings
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.20 2005/10/30 21:58:57 brlcad Exp $ (BRL)";
d204 2
a205 3
	{"dbbinary", f_binary},
	{"bot_merge", f_bot_merge},
	{"bot_split", f_bot_split},
d208 1
a208 2
	{"bot_condense", f_bot_condense},
	{"bot_decimate", cmd_bot_decimate},
d210 1
d228 1
d231 1
a232 2
	{"dbip",	cmd_dbip},
	{"dump",	cmd_dump},
d240 1
d263 1
d266 1
a267 1
	{"expand", cmd_expand},
a268 1
	{"e_muves", f_e_muves},
d290 1
a291 1
	{"hist", cmd_hist},
a306 1
	{"lt", cmd_lt},
d311 1
d315 1
a326 1
	{"listeval", cmd_pathsum},
d361 1
a362 1
	{"oxscale",	be_o_xscale},
d367 1
d371 1
a372 1
	{"pl", f_pl},
d388 1
a391 1
	{"qorot", f_qorot},
a407 1
	{"solid_report", cmd_solid_report},
d410 1
a411 1
	{"rfarb", f_rfarb},
d417 1
d420 1
a420 1
	{"rrt", cmd_rrt},
d422 1
a423 1
	{"rtarea", cmd_rtarea},
a425 1
	{"rt_gettrees", cmd_rt_gettrees},
d427 1
a434 1
	{"sedit",	be_s_edit},
d437 1
d440 1
a442 1
	{"shaded_mode", cmd_shaded_mode},
d457 1
a458 1
	{"sxy",		be_s_trans},
d460 1
a470 1
	{"t_muves", f_t_muves},
a480 1
	{"viewsize", cmd_size},		/* alias "size" for saveview scripts */
d483 1
d485 1
a485 1
	{"view2model_lu", f_view2model_lu},
d497 1
a499 1
	{"which_shader", f_which_shader},
a508 1
	{"parse_points", cmd_parse_points},
@


14.20
log
@remove C++-style // comments as there's no assumption of c99 compiler compliance yet, only c89 (mostly aix compiler though other old compilers too)
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.19 2005/10/29 21:32:15 brlcad Exp $ (BRL)";
d2050 1
a2050 1
	struct directory *dp, *new_dp;
d2055 1
a2055 2
	int bot_used = 0;
	int i, idx, retval, edge, faces, e, f ;
d2057 1
a2057 1
	int avail_vert, avail_face, face;
d2113 1
a2113 1

d3579 3
@


14.19
log
@export the cmd_parse_points routine for parsing point files
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.18 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
d1580 1
a1580 1
// XXXXXXXXXXXXXXX FIX LATER XXXXXXXXXXXXXXXXXx
@


14.18
log
@trailing ws
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.17 2005/09/16 18:51:53 brlcad Exp $ (BRL)";
d508 1
d3580 15
@


14.17
log
@rework tkwin into cmd.c and profide the DM_X and DM_OGL defines to the build.  probably fixes a bug or two of some sort on the display manager.  also migrate the tolerance vars together along with other ws and header cleanup
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.16 2005/08/24 23:10:16 brlcad Exp $ (BRL)";
d677 1
a677 1
    
d713 1
a713 1
 */ 
d718 1
a718 1
	
d813 1
a813 1
	
d831 1
a831 1
		if(pathname[i]=='\\') 
d1182 1
a1182 1
    
d1247 1
a1247 1
    
d1276 1
a1276 1
		
d1284 1
a1284 1
       
d1308 1
a1308 1
			/* If the command had something to say, print it out. */	     
d1335 1
a1335 1
      
d1362 1
a1362 1
		/* Otherwise, it's just a regular old error. */    
d1397 1
a1397 1
		/* If the command had something to say, print it out. */	     
d1583 1
a1583 1
    
d1600 1
a1600 1
	
d2058 1
a2058 1
	
d2068 1
a2068 1
	
d2078 1
a2078 1
	    
d2125 1
a2125 1
	
d2268 1
a2268 1
	intern.idb_meth = &rt_functab[ID_BOT]; 
d2689 1
a2689 1
 * The push command is used to move matrices from combinations 
d2794 1
a2794 1
 *  
d2841 1
a2841 1
	 */ 
d3057 1
a3057 1
 *  
d3149 1
a3149 1
 *  
@


14.16
log
@it is important to run Tcl_FindExecutable BEFORE running the init funcs so that they can do a better job and finding their scripts (thx Enrique Perez-Terron).  use the argv[0] we stashed during startup into libbu.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a81 1
#include "./mgedtcl.h"
d147 1
a147 1
extern struct rt_tess_tol     mged_ttol; /* do_draw.c */
d157 3
a164 3
#ifdef DM_X
Tk_Window tkwin;
#endif
a852 1
#ifdef DM_X
a853 1
#endif
a1317 2

#ifdef DM_X
a1325 1
#endif
@


14.16.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d82 1
d148 1
a148 1
extern struct rt_tess_tol     mged_ttol; /* ged.c */
a157 3
#if DM_X
Tk_Window tkwin = NULL;
#endif
d163 3
a508 1
	{"parse_points", cmd_parse_points},
d678 1
a678 1

d714 1
a714 1
 */
d719 1
a719 1

d814 1
a814 1

d832 1
a832 1
		if(pathname[i]=='\\')
d854 1
d856 1
d1185 1
a1185 1

d1250 1
a1250 1

d1279 1
a1279 1

d1287 1
a1287 1

d1311 1
a1311 1
			/* If the command had something to say, print it out. */
d1321 2
d1331 1
d1341 1
a1341 1

d1368 1
a1368 1
		/* Otherwise, it's just a regular old error. */
d1403 1
a1403 1
		/* If the command had something to say, print it out. */
d1585 1
a1585 1
/* XXXXXXXXXXXXXXX FIX LATER XXXXXXXXXXXXXXXXX */
d1589 1
a1589 1

d1606 1
a1606 1

d2055 1
a2055 1
	struct directory *dp;
d2060 2
a2061 1
	int i, edge, e, f ;
d2063 2
a2064 2
	int face;

d2074 1
a2074 1

d2084 1
a2084 1

d2119 1
a2119 1
	return TCL_OK;
d2131 1
a2131 1

d2274 1
a2274 1
	intern.idb_meth = &rt_functab[ID_BOT];
d2695 1
a2695 1
 * The push command is used to move matrices from combinations
d2800 1
a2800 1
 *
d2847 1
a2847 1
	 */
d3063 1
a3063 1
 *
d3155 1
a3155 1
 *
a3584 18
/* XXX needs to be provided from points header */
extern int parse_point_file(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

int
cmd_parse_points(ClientData	clientData,
		Tcl_Interp	*interp,
		int     	argc,
		char    	**argv)
{
    if (argc != 2) {
	bu_log("parse_points only supports a single file name right now\n");
	bu_log("doing nothing\n");
	return TCL_ERROR;
    }

    return parse_point_file(clientData, interp, argc-1, &(argv[1]));
}

@


14.15
log
@quell warnings, add missing headers
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.14 2005/07/18 05:09:28 brlcad Exp $ (BRL)";
d724 2
a742 10
#ifdef _WIN32
#  ifdef _DEBUG
	Tcl_FindExecutable("mged_d");
#  else
	Tcl_FindExecutable("mged");
#  endif
#else
	Tcl_FindExecutable("mged");
#endif

@


14.14
log
@abstract out the auto_path crappage to libtclcad and make it a tclcad_auto_path call instead.  fix the other bu_brlcad_data call to specify the tclscripts dir instead of leaving it open-ended.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.13 2005/07/18 02:02:30 brlcad Exp $ (BRL)";
d56 3
@


14.14.2.1
log
@Mods for windows port
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.14 2005/07/18 05:09:28 brlcad Exp $ (BRL)";
a720 10
#ifdef _WIN32
#  ifdef _DEBUG
	Tcl_FindExecutable("mged_d");
#  else
	Tcl_FindExecutable("mged");
#  endif
#else
	Tcl_FindExecutable("mged");
#endif

d738 9
a746 6
#ifdef BRLCAD_DEBUG
	/* Initialize libbu */
	Bu_d_Init(interp);

	/* Initialize libbn */
	Bn_d_Init(interp);
a747 5
	/* Initialize librt (includes database, drawable geometry and view objects) */
	if (Rt_d_Init(interp) == TCL_ERROR) {
		bu_log("Rt_d_Init error %s\n", interp->result);
	}
#else
a757 1
#endif
d832 1
a832 1
	if (pathname) {
a838 5

	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "source %s/mged/tree.tcl", pathname);
	    (void)Tcl_Eval(interp, bu_vls_addr(&vls));
	    bu_vls_free(&vls);
d842 5
a854 5
#ifdef BRLCAD_DEBUG
	Bu_d_Init(interp);
	bn_tcl_setup( interp );
	Rt_d_Init(interp);
#else
a857 1
#endif
@


14.13
log
@search path enhancements, search for tclscripts explicitly and search even harder still when running from uninstalled
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.12 2005/07/08 00:27:51 brlcad Exp $ (BRL)";
d72 1
a715 1
	char *pathname;
d779 2
a780 13
	/* Locate the BRL-CAD-specific Tcl scripts */
	pathname = bu_brlcad_data( "tclscripts", 0 );

#ifdef _WIN32
	{
	  /* XXX - nasty little hack to convert paths */
	  int i;
	  strcat(pathname,"/");
	  for (i=0;i<strlen(pathname);i++) {
	    if(pathname[i]=='\\') 
	      pathname[i]='/'; }
	}
#endif
d782 1
a783 11
	if (pathname) {
	    bu_vls_printf(&str, "lappend auto_path \"%s\" \"%s/lib\" \"%s/util\" \"%s/mged\" \"%s/geometree\"", 
			  pathname, pathname, pathname, pathname, pathname);
	    (void)Tcl_Eval(interp, bu_vls_addr(&str));
	} else {
	    /* hunt for the tclscripts since we're probably just not installed yet */
	    (void)Tcl_Eval(interp, "lappend auto_path tclscripts tclscripts/lib tclscripts/util tclscripts/mged tclscripts/geometree src/tclscripts src/tclscripts/lib src/tclscripts/util src/tclscripts/mged src/tclscripts/geometree ../tclscripts ../tclscripts/lib ../tclscripts/util ../tclscripts/mged ../tclscripts/geometree ../src/tclscripts ../src/tclscripts/lib ../src/tclscripts/util ../src/tclscripts/mged ../src/tclscripts/geometree ../../tclscripts ../../tclscripts/lib ../../tclscripts/util ../../tclscripts/mged ../../tclscripts/geometree ../../src/tclscripts ../../src/tclscripts/lib ../../src/tclscripts/util ../../src/tclscripts/mged ../../src/tclscripts/geometree");
	}

	/* Tcl needs to write nulls onto subscripted variable names */
	bu_vls_trunc( &str, 0 );
d803 2
a826 3
	{
		struct bu_vls	vls;
		char		*pathname;
d828 2
a829 2
		/* Locate the BRL-CAD-specific Tcl scripts */
		pathname = bu_brlcad_data("", 0);
d833 4
a836 4
		/* XXXXXXXXXXXXXXX UGLY XXXXXXXXXXXXXXXXXX*/
	int i;
	strcat(pathname,"/");
	for (i=0;i<strlen(pathname);i++) {
d838 1
a838 1
			pathname[i]='/'; }
d842 4
a845 5
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "source %stclscripts/mged/tree.tcl", pathname);
		(void)Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
	}
@


14.12
log
@use bu_brlcad_root now for bin dirs and bu_brlcad_data for data dirs
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.11 2005/06/24 23:23:20 brlcad Exp $ (BRL)";
d715 1
a715 1
	char *filename;
a720 21
	/* Locate the BRL-CAD-specific Tcl scripts */
	filename = bu_brlcad_data( "", 0 );
#ifdef _WIN32
	{
	  /* XXX - nasty little hack to convert paths */
	  int i;
	  strcat(filename,"/");
	  for (i=0;i<strlen(filename);i++) {
	    if(filename[i]=='\\') 
	      filename[i]='/'; }
	}
#endif

#ifdef _WIN32
#ifdef _DEBUG
	Tcl_FindExecutable("mged_d");
#else
	Tcl_FindExecutable("mged");
#endif
#endif

d737 11
d779 3
a781 1
	bu_vls_init(&str);
d783 8
a790 4
	bu_vls_printf(&str,
		      "set auto_path [linsert $auto_path 0 \"%stclscripts/mged\" \"%stclscripts\" \"%stclscripts/lib\" \"%stclscripts/util\" \"%stclscripts/geometree\"]", filename, filename, filename, filename, filename);
#else
	bu_vls_printf(&str, "set auto_path [linsert $auto_path 0 %stclscripts/mged %stclscripts %stclscripts/lib %stclscripts/util %stclscripts/geometree]", filename, filename, filename, filename, filename);
d792 10
a801 1
	(void)Tcl_Eval(interp, bu_vls_addr(&str));
d806 1
a806 2
	Tcl_SetVar(interp, bu_vls_addr(&str), state_str[state],
		   TCL_GLOBAL_ONLY);
@


14.12.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.14 2005/07/18 05:09:28 brlcad Exp $ (BRL)";
a71 1
#include "tclcad.h"
d715 1
d721 21
a757 11

#ifdef _WIN32
#  ifdef _DEBUG
	Tcl_FindExecutable("mged_d");
#  else
	Tcl_FindExecutable("mged");
#  endif
#else
	Tcl_FindExecutable("mged");
#endif

d789 8
a796 2
	/* Locate the BRL-CAD-specific Tcl scripts, set the auto_path */
	tclcad_auto_path(interp);
d799 1
a799 1
	bu_vls_init(&str);
d801 2
a802 1
	Tcl_SetVar(interp, bu_vls_addr(&str), state_str[state], TCL_GLOBAL_ONLY);
a819 2
	struct bu_vls	vls;
	char		*pathname;
d842 3
d846 2
a847 2
	/* Locate the BRL-CAD-specific Tcl scripts */
	pathname = bu_brlcad_data("tclscripts", 1);
d851 4
a854 4
	    /* XXXXXXXXXXXXXXX UGLY XXXXXXXXXXXXXXXXXX*/
	    int i;
	    strcat(pathname,"/");
	    for (i=0;i<strlen(pathname);i++) {
d856 1
a856 1
		    pathname[i]='/'; }
d860 5
a864 4
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "source %s/mged/tree.tcl", pathname);
	(void)Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
@


14.11
log
@add mged commands for rtarea and rtweight.  they all ultimately end up calling dgo_rt_cmd for consistency but retain their own cmd_ hook function.  update the comments to match the functions that were changed from f_ to cmd_ too
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.10 2005/06/10 18:59:00 lbutler Exp $ (BRL)";
d722 1
a722 1
	filename = bu_brlcad_path( "", 0 );
d847 1
a847 1
		pathname = bu_brlcad_path("", 0);
@


14.10
log
@Removed debugging foo
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.9 2005/06/10 18:52:21 lbutler Exp $ (BRL)";
a413 1
	{"rrt", f_rrt},
d416 1
d419 3
a421 1
	{"rtedge", cmd_rt},
@


14.9
log
@added bot_merge to merge two bots together.  Since rt_db_put_internal
does the freeing for us
I deleted the calls to bu_free on data structures that are already free.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.8 2005/06/02 22:49:35 lbutler Exp $ (BRL)";
a2249 6
	bu_log("vert:%08x face:%08x\n", bots[0]->vertices, bots[0]->faces);


	bots[0]->vertices = bu_calloc(bots[0]->num_vertices*3, sizeof(fastf_t), "verts");
	bots[0]->faces = bu_calloc(bots[0]->num_faces*3, sizeof(int), "verts");

@


14.8
log
@First cut at a bot_merge command for MGED to allow user to combine multiple bots into 1
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.7 2005/05/28 02:14:51 brlcad Exp $ (BRL)";
d120 1
d203 1
d2075 71
d2250 7
a2316 14

	bu_free(bots[0]->vertices, "verts");
	bu_free(bots[0]->faces, "faces");
#if 0
	for (i=0 ; i < idx ; i++) {
	    if( bots[i]->thickness) bu_free(bots[i]->thickness, "thickness");
	    if( bots[i]->normals) bu_free(bots[i]->normals, "normals");
	    if( bots[i]->face_normals) bu_free(bots[i]->face_normals, "face_normals");
	    bu_free(bots[i]->vertices, "verts");
	    bu_free(bots[i]->faces, "faces");
	}
#else
	bu_log("leaking memory\n");
#endif
@


14.7
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.6 2005/05/22 06:44:53 brlcad Exp $ (BRL)";
d116 4
a119 1
int f_bot_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv), f_bot_condense(ClientData clientData, Tcl_Interp *interp, int argc, char **argv), f_bot_face_fuse(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d201 1
d2073 183
@


14.6
log
@ws
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.5 2005/03/24 17:35:30 bob1961 Exp $ (BRL)";
d52 1
a52 1
#ifndef WIN32
d151 1
a151 1
#ifdef WIN32
d715 1
a715 1
#ifdef WIN32
d726 1
a726 1
#ifdef WIN32
d782 1
a782 1
#ifdef WIN32
d841 1
a841 1
#ifdef WIN32
d1526 1
a1526 1
#ifndef WIN32
d1602 1
a1602 1
#ifndef WIN32
d3317 1
a3317 1
#ifdef WIN32
@


14.5
log
@If Windows, use double-quotes around pathnames in case there are spaces. Also, if Windows, call Tcl_FindExecutable before calling Tcl_CreateInterp
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.4 2005/03/06 03:50:43 brlcad Exp $ (BRL)";
a43 2


d48 1
a48 1
#include <string.h>
d50 1
a50 1
#include <strings.h>
d53 1
a53 1
#include <sys/time.h>
d72 1
d78 1
a79 1
#include "./mgedtcl.h"
@


14.4
log
@avoid segment violation on a short argv[1]
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.3 2005/01/30 20:31:05 brlcad Exp $ (BRL)";
d727 8
d783 4
d788 1
@


14.3
log
@update copyright to 2005
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/cmd.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
d3328 2
a3329 1
	if (argc == 3 && 
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cmd.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			C M D . C
a35 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cmd.c,v 1.5 2004/10/14 19:19:29 morrison Exp $ (BRL)";
@


1.5
log
@add an option to bu_brlcad_path to fail quietly, returning a NULL string instead of gobs of output and bu_bomb'ing
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cmd.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
d3331 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cmd.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d700 1
a700 1
	filename = bu_brlcad_path( "" );
d812 1
a812 1
		pathname = bu_brlcad_path("");
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/cmd.c,v 1.2 2004/06/08 22:04:26 morrison Exp $ (BRL)";
d34 1
a34 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/cmd.c,v 11.288 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a55 1
#include "externs.h"
@

