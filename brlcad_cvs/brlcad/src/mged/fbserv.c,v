head	14.17;
access;
symbols
	rel-7-10-4:14.12
	STABLE:14.12.0.2
	stable-branch:14.3
	rel-7-10-2:14.12
	rel-7-10-0:14.12
	rel-7-8-4:14.10
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.3.2.1
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.17
date	2007.12.16.15.59.40;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.11.21.21.46.15;	author erikgreenwald;	state Exp;
branches;
next	14.15;

14.15
date	2007.11.08.19.13.51;	author bob1961;	state Exp;
branches;
next	14.14;

14.14
date	2007.11.05.04.38.18;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.11.04.16.32.22;	author bob1961;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.23.01.13.41;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.08.28.00.55.25;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.02.05.17.47.59;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.22.11.00.29;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.31.07.30.58;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches
	14.3.2.1
	14.3.6.1;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.16.03.44.11;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.28;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.23;	author morrison;	state Exp;
branches;
next	;

14.3.2.1
date	2005.09.08.16.09.50;	author bob1961;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.17
log
@convert all bzero calls to memset
@
text
@/*                        F B S E R V . C
 * BRL-CAD
 *
 * Copyright (c) 1995-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file fbserv.c
 *
 *  This code was developed by modifying the stand-alone version of fbserv to work
 *  within MGED.
 *
 *  Author -
 *	Robert Parker
 *
 *  Authors of the stand-alone fbserv -
 *	Phillip Dykstra
 *	Michael John Muuss
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.16 2007/11/21 21:46:15 erikgreenwald Exp $ (ARL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#ifdef HAVE_WINSOCK_H
#  include <process.h>
#  include <winsock.h>
#  include <fcntl.h>
#  include <io.h>
#else
#  include <sys/socket.h>
#  include <netinet/in.h>		/* For htonl(), etc */
#endif

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "tcl.h"
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"

#include "./ged.h"
#include "./mged_dm.h"

#include "./fbserv.h"

#define NET_LONG_LEN	4	/* # bytes to network long */


void set_port(void);

#ifdef LOCAL_STATIC
#  undef LOCAL_STATIC
#endif
#define LOCAL_STATIC static

LOCAL_STATIC void drop_client(int sub);
#if defined(_WIN32) && !defined(__CYGWIN__)
LOCAL_STATIC void new_client(struct pkg_conn *pcp, Tcl_Channel chan);
LOCAL_STATIC void new_client_handler(ClientData clientData, Tcl_Channel chan, char *host, int port);
#else
LOCAL_STATIC void new_client(struct pkg_conn *pcp);
LOCAL_STATIC void new_client_handler(ClientData clientData, int mask);
#endif
LOCAL_STATIC void existing_client_handler(ClientData clientData, int mask);
LOCAL_STATIC void comm_error(char *str);
LOCAL_STATIC void setup_socket(int fd);


/*
 *			D R O P _ C L I E N T
 */
LOCAL_STATIC void
drop_client(int sub)
{
    if (clients[sub].c_pkg != PKC_NULL) {
	pkg_close(clients[sub].c_pkg);
#if defined(_WIN32) && !defined(__CYGWIN__)
	Tcl_DeleteChannelHandler(clients[sub].c_chan,
				 clients[sub].c_handler,
				 clients[sub].c_fd);
	Tcl_Close(dmp->dm_interp, clients[sub].c_chan);
	clients[sub].c_chan = NULL;
#else
	Tcl_DeleteFileHandler(clients[sub].c_fd);
#endif
	clients[sub].c_pkg = PKC_NULL;
	clients[sub].c_fd = 0;
    }
}

#if defined(_WIN32) && !defined(__CYGWIN__)
LOCAL_STATIC void
new_client(struct pkg_conn	*pcp,
	   Tcl_Channel		chan)
	   
{
    register int	i;

    if (pcp == PKC_ERROR)
	return;

    for (i = MAX_CLIENTS-1; i >= 0; i--) {
	if (clients[i].c_fd != 0)
	    continue;

	/* Found an available slot */
	clients[i].c_pkg = pcp;
	clients[i].c_fd = pcp->pkc_fd;
	setup_socket(pcp->pkc_fd);

	clients[i].c_chan = chan;
	clients[i].c_handler = existing_client_handler;
	Tcl_CreateChannelHandler(clients[i].c_chan, TCL_READABLE,
				 clients[i].c_handler,
				 (ClientData)clients[i].c_fd);

	return;
    }

    bu_log("new_client: too many clients\n");
    pkg_close(pcp);
}

/*
 *			S E T _ P O R T
 */
void
set_port(void)
{
    register int i;
    int save_port;
    int port;
    char hostname[32];

    /* Check to see if previously active --- if so then deactivate */
    if (netchan != NULL) {
	/* first drop all clients */
	for (i = 0; i < MAX_CLIENTS; ++i)
	    drop_client(i);

	Tcl_DeleteChannelHandler(netchan,
				 new_client_handler,
				 netfd);

	Tcl_Close(dmp->dm_interp, netchan);
	netchan = NULL;

	closesocket(netfd);
	netfd = -1;
    }

    if (!mged_variables->mv_listen)
	return;

    if (!mged_variables->mv_fb) {
	mged_variables->mv_listen = 0;
	return;
    }

    /*XXX hardwired for now */
    sprintf(hostname,"localhost");

#define MAX_PORT_TRIES 100

    save_port = mged_variables->mv_port;

    if(mged_variables->mv_port < 0)
	port = 5559;
    else if (mged_variables->mv_port < 1024)
	port = mged_variables->mv_port + 5559;
    else
	port = mged_variables->mv_port;

    /* Try a reasonable number of times to hang a listen */
    for (i = 0; i < MAX_PORT_TRIES; ++i) {
	/*
	 * Hang an unending listen for PKG connections
	 */
	netchan = Tcl_OpenTcpServer(dmp->dm_interp, port, hostname, new_client_handler, (ClientData)curr_dm_list);

	if (netchan == NULL)
	    ++port;
	else
	    break;
    }

    if (netchan == NULL) {
	mged_variables->mv_port = save_port;
	mged_variables->mv_listen = 0;
	bu_log("set_port: failed to hang a listen on ports %d - %d\n",
	       mged_variables->mv_port, mged_variables->mv_port + MAX_PORT_TRIES - 1);
    } else {
	mged_variables->mv_port = port;
	Tcl_GetChannelHandle(netchan, TCL_READABLE, &netfd);
    }
}

static struct pkg_conn *
fbserv_makeconn(int fd,
		const struct pkg_switch *switchp)
{
    register struct pkg_conn *pc;

    if ((pc = (struct pkg_conn *)malloc(sizeof(struct pkg_conn))) == PKC_NULL) {
	comm_error("fbserv_makeconn: malloc failure\n");
	return(PKC_ERROR);
    }

    memset((char *)pc, 0, sizeof(struct pkg_conn));
    pc->pkc_magic = PKG_MAGIC;
    pc->pkc_fd = fd;
    pc->pkc_switch = switchp;
    pc->pkc_errlog = 0;
    pc->pkc_left = -1;
    pc->pkc_buf = (char *)0;
    pc->pkc_curpos = (char *)0;
    pc->pkc_strpos = 0;
    pc->pkc_incur = pc->pkc_inend = 0;

    return pc;
}

LOCAL_STATIC void
new_client_handler(ClientData	 clientData,
		   Tcl_Channel	 chan,
		   char		 *host,
		   int		 port)
{
    struct dm_list *dlp = (struct dm_list *)clientData;
    struct dm_list *scdlp;  /* save current dm_list pointer */
    int fd;

    if (dlp == NULL)
	return;

    /* save */
    scdlp = curr_dm_list;

    curr_dm_list = dlp;

    if (Tcl_GetChannelHandle(chan, TCL_READABLE, &fd) == TCL_OK)
	new_client(fbserv_makeconn(fd, pkg_switch), chan);

    /* restore */
    curr_dm_list = scdlp;
}


#else /* defined(_WIN32) && !defined(__CYGWIN__) */

    
/*
 *			N E W _ C L I E N T
 */
LOCAL_STATIC void
new_client(struct pkg_conn *pcp)
{
    register int	i;

    if (pcp == PKC_ERROR)
	return;

    for (i = MAX_CLIENTS-1; i >= 0; i--) {
	if (clients[i].c_fd != 0)
	    continue;

	/* Found an available slot */
	clients[i].c_pkg = pcp;
	clients[i].c_fd = pcp->pkc_fd;
	setup_socket(pcp->pkc_fd);

	Tcl_CreateFileHandler(clients[i].c_fd, TCL_READABLE,
			      existing_client_handler, (ClientData)(size_t)clients[i].c_fd);

	return;
    }

    bu_log("new_client: too many clients\n");
    pkg_close(pcp);
}


/*
 *			S E T _ P O R T
 */
void
set_port(void)
{
    register int i;
    int save_port;
    char portname[32];

    /* Check to see if previously active --- if so then deactivate */
    if (netfd >= 0) {
	/* first drop all clients */
	for (i = 0; i < MAX_CLIENTS; ++i)
	    drop_client(i);

	Tcl_DeleteFileHandler(netfd);
	close(netfd);
	netfd = -1;
    }

    if (!mged_variables->mv_listen)
	return;

    if (!mged_variables->mv_fb) {
	mged_variables->mv_listen = 0;
	return;
    }

#define MAX_PORT_TRIES 100

    save_port = mged_variables->mv_port;
    if(mged_variables->mv_port < 0)
	mged_variables->mv_port = 0;

    /* Try a reasonable number of times to hang a listen */
    for(i = 0; i < MAX_PORT_TRIES; ++i){
	if(mged_variables->mv_port < 1024)
	    sprintf(portname,"%d", mged_variables->mv_port + 5559);
	else
	    sprintf(portname,"%d", mged_variables->mv_port);

	/*
	 * Hang an unending listen for PKG connections
	 */
	if ((netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0)
	    ++mged_variables->mv_port;
	else
	    break;
    }

    if (netfd < 0) {
	mged_variables->mv_port = save_port;
	mged_variables->mv_listen = 0;
	bu_log("set_port: failed to hang a listen on ports %d - %d\n",
	       mged_variables->mv_port, mged_variables->mv_port + MAX_PORT_TRIES - 1);
    } else
	Tcl_CreateFileHandler(netfd, TCL_READABLE,
			      new_client_handler, (ClientData)(size_t)netfd);
}


/*
 * Accept any new client connections.
 */
LOCAL_STATIC void
new_client_handler(ClientData clientData, int mask)
{
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
  struct dm_list *dlp;
  struct dm_list *scdlp;  /* save current dm_list pointer */

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l)
    if(fd == dlp->dml_netfd)
      goto found;

  return;

found:
  /* save */
  scdlp = curr_dm_list;

  curr_dm_list = dlp;
  new_client(pkg_getclient(fd, pkg_switch, comm_error, 0));

  /* restore */
  curr_dm_list = scdlp;
}
#endif  /* if defined(_WIN32) && !defined(__CYGWIN__) */

/*
 * Process arrivals from existing clients.
 */
LOCAL_STATIC void
existing_client_handler(ClientData clientData, int mask)
{
  register int i;
  int fd = (int)((long)clientData & 0xFFFF);	/* fd's will be small */
  int npp;			/* number of processed packages */
  struct dm_list *dlp;
  struct dm_list *scdlp;  /* save current dm_list pointer */

  FOR_ALL_DISPLAYS(dlp, &head_dm_list.l){
    for(i = MAX_CLIENTS-1; i >= 0; i--)
      if(fd == dlp->dml_clients[i].c_fd)
	goto found;
  }

  return;

found:
  /* save */
  scdlp = curr_dm_list;

  curr_dm_list = dlp;
  for(i = MAX_CLIENTS-1; i >= 0; i--){
    if(clients[i].c_fd == 0)
      continue;

    if((npp = pkg_process(clients[i].c_pkg)) < 0)
      bu_log("pkg_process error encountered (1)\n");

    if(npp > 0)
      dirty = 1;

    if(clients[i].c_fd != fd)
      continue;

    if(pkg_suckin(clients[i].c_pkg) <= 0){
      /* Probably EOF */
      drop_client(i);

      continue;
    }

    if((npp = pkg_process(clients[i].c_pkg)) < 0)
      bu_log("pkg_process error encountered (2)\n");

    if(npp > 0)
      dirty = 1;
  }

  /* restore */
  curr_dm_list = scdlp;
}

LOCAL_STATIC void
setup_socket(int fd)
{
  int on = 1;

#if defined(SO_KEEPALIVE)
  if(setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0){
    bu_log("setsockopt (SO_KEEPALIVE): %m\n");
  }
#endif
#if defined(SO_RCVBUF)
  /* try to set our buffers up larger */
  {
    int	m = -1, n = -1;
    int	val;
    int	size;

    for(size = 256; size > 16; size /= 2){
      val = size * 1024;
      m = setsockopt(fd, SOL_SOCKET, SO_RCVBUF,
		      (char *)&val, sizeof(val));
      val = size * 1024;
      n = setsockopt(fd, SOL_SOCKET, SO_SNDBUF,
		      (char *)&val, sizeof(val));
      if(m >= 0 && n >= 0)  break;
    }

    if(m < 0 || n < 0)
      bu_log("setup_socket: setsockopt() SO_RCVBUF/SO_SNDBUF failed: %m\n");
  }
#endif
}

/*
 *			C O M M _ E R R O R
 *
 *  Communication error.  An error occured on the PKG link.
 */
LOCAL_STATIC void
comm_error(char *str)
{
  bu_log(str);
}

/*
 * This is where we go for message types we don't understand.
 */
void
pkgfoo(struct pkg_conn *pcp, char *buf)
{
  bu_log("fbserv: unable to handle message type %d\n", pcp->pkc_type);
  (void)free(buf);
}

/******** Here's where the hooks lead *********/

void
rfbopen(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[5*NET_LONG_LEN+1];
  int	want;

  /* Don't really open a new framebuffer --- use existing one */
  (void)pkg_plong(&rbuf[0*NET_LONG_LEN], 0);	/* ret */
  (void)pkg_plong(&rbuf[1*NET_LONG_LEN], fbp->if_max_width);
  (void)pkg_plong(&rbuf[2*NET_LONG_LEN], fbp->if_max_height);
  (void)pkg_plong(&rbuf[3*NET_LONG_LEN], fbp->if_width);
  (void)pkg_plong(&rbuf[4*NET_LONG_LEN], fbp->if_height);

  want = 5*NET_LONG_LEN;
  if( pkg_send( MSG_RETURN, rbuf, want, pcp ) != want )
    comm_error("pkg_send fb_open reply\n");

  if(buf)
    (void)free(buf);
}

void
rfbclose(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[NET_LONG_LEN+1];

  /*
   * We are playing FB server so we don't really close the
   * frame buffer.  We should flush output however.
   */
  (void)fb_flush(fbp);
  (void)pkg_plong(&rbuf[0], 0);		/* return success */

  /* Don't check for errors, SGI linger mode or other events
   * may have already closed down all the file descriptors.
   * If communication has broken, other end will know we are gone.
   */
  (void)pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp);

  if(buf)
    (void)free(buf);
}

void
rfbfree(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[NET_LONG_LEN+1];

  /* Don't really free framebuffer */
  if(pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp) != NET_LONG_LEN)
    comm_error("pkg_send fb_free reply\n");

  if(buf)
    (void)free(buf);
}

void
rfbclear(struct pkg_conn *pcp, char *buf)
{
  RGBpixel bg;
  char	rbuf[NET_LONG_LEN+1];

  bg[RED] = buf[0];
  bg[GRN] = buf[1];
  bg[BLU] = buf[2];

  (void)pkg_plong(rbuf, fb_clear(fbp, bg));
  pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp);

  if(buf)
    (void)free(buf);
}

void
rfbread(struct pkg_conn *pcp, char *buf)
{
	int	x, y, num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	num = pkg_glong( &buf[2*NET_LONG_LEN] );

	if( num*sizeof(RGBpixel) > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num*sizeof(RGBpixel);
		if( buflen < 1024*sizeof(RGBpixel) )
			buflen = 1024*sizeof(RGBpixel);
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fb_read: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_read( fbp, x, y, scanbuf, num );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, (char *)scanbuf, ret*sizeof(RGBpixel), pcp );
	if( buf ) (void)free(buf);
}

void
rfbwrite(struct pkg_conn *pcp, char *buf)
{
	int	x, y, num;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	num = pkg_glong( &buf[2*NET_LONG_LEN] );
	type = pcp->pkc_type;
	ret = fb_write( fbp, x, y, (unsigned char *)&buf[3*NET_LONG_LEN], num );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*
 *			R F B R E A D R E C T
 */
void
rfbreadrect(struct pkg_conn *pcp, char *buf)
{
	int	xmin, ymin;
	int	width, height;
	int	num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	xmin = pkg_glong( &buf[0*NET_LONG_LEN] );
	ymin = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );
	num = width * height;

	if( num*sizeof(RGBpixel) > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num*sizeof(RGBpixel);
		if( buflen < 1024*sizeof(RGBpixel) )
			buflen = 1024*sizeof(RGBpixel);
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fb_read: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_readrect( fbp, xmin, ymin, width, height, scanbuf );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, (char *)scanbuf, ret*sizeof(RGBpixel), pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B W R I T E R E C T
 */
void
rfbwriterect(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	int	width, height;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );

	type = pcp->pkc_type;
	ret = fb_writerect( fbp, x, y, width, height,
		(unsigned char *)&buf[4*NET_LONG_LEN] );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*
 *			R F B B W R E A D R E C T
 */
void
rfbbwreadrect(struct pkg_conn *pcp, char *buf)
{
	int	xmin, ymin;
	int	width, height;
	int	num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	xmin = pkg_glong( &buf[0*NET_LONG_LEN] );
	ymin = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );
	num = width * height;

	if( num > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num;
		if( buflen < 1024 )
			buflen = 1024;
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("rfbbwreadrect: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_bwreadrect( fbp, xmin, ymin, width, height, scanbuf );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, (char *)scanbuf, ret, pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B B W W R I T E R E C T
 */
void
rfbbwwriterect(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	int	width, height;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );

	type = pcp->pkc_type;
	ret = fb_writerect( fbp, x, y, width, height,
		(unsigned char *)&buf[4*NET_LONG_LEN] );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

void
rfbcursor(struct pkg_conn *pcp, char *buf)
{
	int	mode, x, y;
	char	rbuf[NET_LONG_LEN+1];

	mode = pkg_glong( &buf[0*NET_LONG_LEN] );
	x = pkg_glong( &buf[1*NET_LONG_LEN] );
	y = pkg_glong( &buf[2*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_cursor( fbp, mode, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbgetcursor(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	mode, x, y;
	char	rbuf[4*NET_LONG_LEN+1];

	ret = fb_getcursor( fbp, &mode, &x, &y );
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], mode );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], x );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], y );
	pkg_send( MSG_RETURN, rbuf, 4*NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbsetcursor(struct pkg_conn *pcp, char *buf)
{
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	xbits, ybits;
	int	xorig, yorig;

	xbits = pkg_glong( &buf[0*NET_LONG_LEN] );
	ybits = pkg_glong( &buf[1*NET_LONG_LEN] );
	xorig = pkg_glong( &buf[2*NET_LONG_LEN] );
	yorig = pkg_glong( &buf[3*NET_LONG_LEN] );

	ret = fb_setcursor( fbp, (unsigned char *)&buf[4*NET_LONG_LEN],
		xbits, ybits, xorig, yorig );

	if( pcp->pkc_type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbscursor(struct pkg_conn *pcp, char *buf)
{
	int	mode, x, y;
	char	rbuf[NET_LONG_LEN+1];

	mode = pkg_glong( &buf[0*NET_LONG_LEN] );
	x = pkg_glong( &buf[1*NET_LONG_LEN] );
	y = pkg_glong( &buf[2*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_scursor( fbp, mode, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbwindow(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	char	rbuf[NET_LONG_LEN+1];

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_window( fbp, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*OLD*/
void
rfbzoom(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	char	rbuf[NET_LONG_LEN+1];

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_zoom( fbp, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbview(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	xcenter, ycenter, xzoom, yzoom;
	char	rbuf[NET_LONG_LEN+1];

	xcenter = pkg_glong( &buf[0*NET_LONG_LEN] );
	ycenter = pkg_glong( &buf[1*NET_LONG_LEN] );
	xzoom = pkg_glong( &buf[2*NET_LONG_LEN] );
	yzoom = pkg_glong( &buf[3*NET_LONG_LEN] );

	ret = fb_view( fbp, xcenter, ycenter, xzoom, yzoom );
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbgetview(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	xcenter, ycenter, xzoom, yzoom;
	char	rbuf[5*NET_LONG_LEN+1];

	ret = fb_getview( fbp, &xcenter, &ycenter, &xzoom, &yzoom );
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], xcenter );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], ycenter );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], xzoom );
	(void)pkg_plong( &rbuf[4*NET_LONG_LEN], yzoom );
	pkg_send( MSG_RETURN, rbuf, 5*NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbrmap(struct pkg_conn *pcp, char *buf)
{
	register int	i;
	char	rbuf[NET_LONG_LEN+1];
	ColorMap map;
	unsigned char	cm[256*2*3];

	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], fb_rmap( fbp, &map ) );
	for( i = 0; i < 256; i++ ) {
		(void)pkg_pshort( (char *)(cm+2*(0+i)), map.cm_red[i] );
		(void)pkg_pshort( (char *)(cm+2*(256+i)), map.cm_green[i] );
		(void)pkg_pshort( (char *)(cm+2*(512+i)), map.cm_blue[i] );
	}
	pkg_send( MSG_DATA, (char *)cm, sizeof(cm), pcp );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B W M A P
 *
 *  Accept a color map sent by the client, and write it to the framebuffer.
 *  Network format is to send each entry as a network (IBM) order 2-byte
 *  short, 256 red shorts, followed by 256 green and 256 blue, for a total
 *  of 3*256*2 bytes.
 */
void
rfbwmap(struct pkg_conn *pcp, char *buf)
{
	int	i;
	char	rbuf[NET_LONG_LEN+1];
	long	ret;
	ColorMap map;

	if( pcp->pkc_len == 0 )
		ret = fb_wmap( fbp, COLORMAP_NULL );
	else {
		for( i = 0; i < 256; i++ ) {
			map.cm_red[i] = pkg_gshort( buf+2*(0+i) );
			map.cm_green[i] = pkg_gshort( buf+2*(256+i) );
			map.cm_blue[i] = pkg_gshort( buf+2*(512+i) );
		}
		ret = fb_wmap( fbp, &map );
	}
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
rfbflush(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	char	rbuf[NET_LONG_LEN+1];

	ret = fb_flush( fbp );

	if( pcp->pkc_type < MSG_NORETURN ) {
		(void)pkg_plong( rbuf, ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

void
rfbpoll(struct pkg_conn *pcp, char *buf)
{
	(void)fb_poll( fbp );
	if( buf ) (void)free(buf);
}

/*
 *  At one time at least we couldn't send a zero length PKG
 *  message back and forth, so we receive a dummy long here.
 */
void
rfbhelp(struct pkg_conn *pcp, char *buf)
{
	long	ret;
	char	rbuf[NET_LONG_LEN+1];

	(void)pkg_glong( &buf[0*NET_LONG_LEN] );

	ret = fb_help(fbp);
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.16
log
@pad with 0's to keep the compiler from complaining about casting 32b int->ptr on 64b systems (and just hope we don't cross 4g)
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.15 2007/11/08 19:13:51 bob1961 Exp $ (ARL)";
d234 1
a234 1
    bzero((char *)pc, sizeof(struct pkg_conn));
@


14.15
log
@If windows call closesocket() instead of close().
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.14 2007/11/05 04:38:18 brlcad Exp $ (ARL)";
d298 1
a298 1
			      existing_client_handler, (ClientData)clients[i].c_fd);
d366 1
a366 1
			      new_client_handler, (ClientData)netfd);
@


14.14
log
@use the feature-specific HAVE_WINSOCK_H header define instead of platform-specific defines
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.13 2007/11/04 16:32:22 bob1961 Exp $ (ARL)";
a101 4
	clients[sub].c_pkg = PKC_NULL;
    }

    if (clients[sub].c_fd != 0) {
a105 1

d111 1
a111 1
	close(clients[sub].c_fd);
d173 1
a173 1
	close(netfd);
a256 1
    int ret;
@


14.13
log
@Mods to get the fbserv capability working on Windows. This required using Tcl_OpenTcpServer instead of pkg_permserver which beget other mods.
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.12 2007/01/23 01:13:41 brlcad Exp $ (ARL)";
d46 1
a46 1
#if defined(_WIN32) && !defined(__CYGWIN__)
@


14.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.11 2007/01/20 14:36:57 brlcad Exp $ (ARL)";
d46 6
a51 1
#ifndef _WIN32
a53 3
#else
#  include <process.h>
#  include <winsock.h>
d81 5
a86 1
LOCAL_STATIC void drop_client(int sub);
d88 1
d95 1
a95 1
 *			N E W _ C L I E N T
d98 28
a125 1
new_client(struct pkg_conn *pcp)
d141 1
a141 5
#ifndef _WIN32
	Tcl_CreateFileHandler(clients[i].c_fd, TCL_READABLE,
			      existing_client_handler, (ClientData)clients[i].c_fd);
#else
	clients[i].c_chan = Tcl_MakeTcpClientChannel(clients[i].c_fd);
a145 1
#endif
d155 130
a284 1
 *			D R O P _ C L I E N T
d287 1
a287 1
drop_client(int sub)
d289 18
a306 3
    if (clients[sub].c_pkg != PKC_NULL) {
	pkg_close(clients[sub].c_pkg);
	clients[sub].c_pkg = PKC_NULL;
d309 2
a310 11
    if (clients[sub].c_fd != 0) {
#ifndef _WIN32
	Tcl_DeleteFileHandler(clients[sub].c_fd);
#else
	Tcl_DeleteChannelHandler(clients[sub].c_chan,
				 clients[sub].c_handler,
				 clients[sub].c_fd);
#endif
	close(clients[sub].c_fd);
	clients[sub].c_fd = 0;
    }
d313 1
a329 1
#ifndef _WIN32
a330 5
#else
	Tcl_DeleteChannelHandler(netchan,
				 new_client_handler,
				 netfd);
#endif
a342 1
#if 1
d345 19
a363 10
  save_port = mged_variables->mv_port;
  if(mged_variables->mv_port < 0)
    mged_variables->mv_port = 0;

  /* Try a reasonable number of times to hang a listen */
  for(i = 0; i < MAX_PORT_TRIES; ++i){
    if(mged_variables->mv_port < 1024)
      sprintf(portname,"%d", mged_variables->mv_port + 5559);
    else
      sprintf(portname,"%d", mged_variables->mv_port);
d365 9
a373 14
    /*
     * Hang an unending listen for PKG connections
     */
    if( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 )
      ++mged_variables->mv_port;
    else
      break;
  }
#else
  if(mged_variables->mv_port < 0){
    mged_variables->mv_listen = 0;
    bu_log("set_port: invalid port number - %d\n", mged_variables->mv_port);
    return;
  }
a374 34
  if(mged_variables->mv_port < 1024)
     sprintf(portname,"%d", mged_variables->mv_port + 5559);
  else
    sprintf(portname,"%d", mged_variables->mv_port);

  /*
   * Hang an unending listen for PKG connections
   */
  if( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 ){
    bu_log("set_port: failed to hang a listen on port %d\n", mged_variables->mv_port);
    mged_variables->mv_listen = 0;

    return;
  }
#endif

  if (netfd < 0) {
      mged_variables->mv_port = save_port;
      mged_variables->mv_listen = 0;
      bu_log("set_port: failed to hang a listen on ports %d - %d\n",
	     mged_variables->mv_port, mged_variables->mv_port + MAX_PORT_TRIES - 1);
  } else {
#ifndef _WIN32
      Tcl_CreateFileHandler(netfd, TCL_READABLE,
			    new_client_handler, (ClientData)netfd);
#else
      netchan = Tcl_MakeTcpClientChannel(netfd);
      Tcl_CreateChannelHandler(netchan,
			       TCL_READABLE,
			       new_client_handler,
			       (ClientData)netfd);
#endif
  }
}
d402 1
@


14.11
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.10 2006/08/28 00:55:25 brlcad Exp $ (ARL)";
@


14.10
log
@quell libpkg warnings now that there are more comprehensive declarations.
@
text
@d4 1
a4 1
 * Copyright (c) 1995-2006 United States Government as represented by
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.9 2006/02/05 17:47:59 brlcad Exp $ (ARL)";
@


14.9
log
@need stdlib.h for malloc/free
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.8 2006/01/22 11:00:29 brlcad Exp $ (ARL)";
d490 1
a490 1
	pkg_send( MSG_RETURN, scanbuf, ret*sizeof(RGBpixel), pcp );
d551 1
a551 1
	pkg_send( MSG_RETURN, scanbuf, ret*sizeof(RGBpixel), pcp );
d619 1
a619 1
	pkg_send( MSG_RETURN, scanbuf, ret, pcp );
d796 3
a798 3
		(void)pkg_pshort( cm+2*(0+i), map.cm_red[i] );
		(void)pkg_pshort( cm+2*(256+i), map.cm_green[i] );
		(void)pkg_pshort( cm+2*(512+i), map.cm_blue[i] );
d800 1
a800 1
	pkg_send( MSG_DATA, cm, sizeof(cm), pcp );
@


14.8
log
@remove pkgtypes.h
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.7 2006/01/18 06:46:19 brlcad Exp $ (ARL)";
d43 1
@


14.7
log
@update copyright to 2006
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.6 2005/12/23 21:26:31 bob1961 Exp $ (ARL)";
a63 1
#include "../libfb/pkgtypes.h"
@


14.6
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1995-2005 United States Government as represented by
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.5 2005/10/31 07:30:58 brlcad Exp $ (ARL)";
@


14.5
log
@header cleanup, reorg, and general bug squashing including adding missing headers
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.4 2005/10/23 04:44:37 brlcad Exp $ (ARL)";
d46 8
a53 2
#include <sys/socket.h>
#include <netinet/in.h>		/* For htonl(), etc */
d67 1
a69 1

d94 1
a94 1
  register int	i;
d96 2
a97 2
  if( pcp == PKC_ERROR )
    return;
d99 19
a117 3
  for(i = MAX_CLIENTS-1; i >= 0; i--){
    if(clients[i].c_fd != 0)
      continue;
d119 2
a120 10
    /* Found an available slot */
    clients[i].c_pkg = pcp;
    clients[i].c_fd = pcp->pkc_fd;
    setup_socket(pcp->pkc_fd);

    Tcl_CreateFileHandler(clients[i].c_fd, TCL_READABLE,
			  existing_client_handler, (ClientData)clients[i].c_fd);

    return;
  }
d122 2
a123 2
  bu_log("new_client: too many clients\n");
  pkg_close(pcp);
d132 4
a135 4
  if(clients[sub].c_pkg != PKC_NULL)  {
    pkg_close(clients[sub].c_pkg);
    clients[sub].c_pkg = PKC_NULL;
  }
d137 11
a147 5
  if(clients[sub].c_fd != 0)  {
    Tcl_DeleteFileHandler(clients[sub].c_fd);
    close(clients[sub].c_fd);
    clients[sub].c_fd = 0;
  }
d156 9
a164 3
  register int i;
  int save_port;
  char portname[32];
d166 10
a175 5
  /* Check to see if previously active --- if so then deactivate */
  if(netfd >= 0){
    /* first drop all clients */
    for(i = 0; i < MAX_CLIENTS; ++i)
      drop_client(i);
d177 2
a178 4
    Tcl_DeleteFileHandler(netfd);
    close(netfd);
    netfd = -1;
  }
d180 4
a183 7
  if(!mged_variables->mv_listen)
    return;

  if(!mged_variables->mv_fb){
    mged_variables->mv_listen = 0;
    return;
  }
d230 17
a246 8
  if(netfd < 0){
    mged_variables->mv_port = save_port;
    mged_variables->mv_listen = 0;
    bu_log("set_port: failed to hang a listen on ports %d - %d\n",
	   mged_variables->mv_port, mged_variables->mv_port + MAX_PORT_TRIES - 1);
  }else
    Tcl_CreateFileHandler(netfd, TCL_READABLE,
			  new_client_handler, (ClientData)netfd);
@


14.4
log
@trailing ws
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (ARL)";
d48 3
@


14.3
log
@update copyright to 2005
@
text
@d32 1
a32 1
 *  
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (ARL)";
d375 1
a375 1
	
d397 1
a397 1
	
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a47 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
d375 1
a375 1

d397 1
a397 1

@


14.3.2.1
log
@Mods for windows port
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/fbserv.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (ARL)";
d46 2
a47 7
#ifndef _WIN32
#  include <sys/socket.h>
#  include <netinet/in.h>		/* For htonl(), etc */
#else
#  include <process.h>
#  include <winsock.h>
#endif
d58 1
a59 1
#include "./fbserv.h"
d85 8
a92 1
    register int	i;
d94 4
a97 2
    if (pcp == PKC_ERROR)
	return;
d99 2
a100 19
    for (i = MAX_CLIENTS-1; i >= 0; i--) {
	if (clients[i].c_fd != 0)
	    continue;

	/* Found an available slot */
	clients[i].c_pkg = pcp;
	clients[i].c_fd = pcp->pkc_fd;
	setup_socket(pcp->pkc_fd);

#ifndef _WIN32
	Tcl_CreateFileHandler(clients[i].c_fd, TCL_READABLE,
			      existing_client_handler, (ClientData)clients[i].c_fd);
#else
	clients[i].c_chan = Tcl_MakeTcpClientChannel(clients[i].c_fd);
	clients[i].c_handler = existing_client_handler;
	Tcl_CreateChannelHandler(clients[i].c_chan, TCL_READABLE,
				 clients[i].c_handler,
				 (ClientData)clients[i].c_fd);
#endif
d102 2
a103 2
	return;
    }
d105 2
a106 2
    bu_log("new_client: too many clients\n");
    pkg_close(pcp);
d115 4
a118 4
    if (clients[sub].c_pkg != PKC_NULL) {
	pkg_close(clients[sub].c_pkg);
	clients[sub].c_pkg = PKC_NULL;
    }
d120 5
a124 11
    if (clients[sub].c_fd != 0) {
#ifndef _WIN32
	Tcl_DeleteFileHandler(clients[sub].c_fd);
#else
	Tcl_DeleteChannelHandler(clients[sub].c_chan,
				 clients[sub].c_handler,
				 clients[sub].c_fd);
#endif
	close(clients[sub].c_fd);
	clients[sub].c_fd = 0;
    }
d133 9
a141 9
    register int i;
    int save_port;
    char portname[32];

    /* Check to see if previously active --- if so then deactivate */
    if (netfd >= 0) {
	/* first drop all clients */
	for (i = 0; i < MAX_CLIENTS; ++i)
	    drop_client(i);
d143 4
a146 10
#ifndef _WIN32
	Tcl_DeleteFileHandler(netfd);
#else
	Tcl_DeleteChannelHandler(netchan,
				 new_client_handler,
				 netfd);
#endif
	close(netfd);
	netfd = -1;
    }
d148 2
a149 2
    if (!mged_variables->mv_listen)
	return;
d151 4
a154 4
    if (!mged_variables->mv_fb) {
	mged_variables->mv_listen = 0;
	return;
    }
d201 8
a208 17
  if (netfd < 0) {
      mged_variables->mv_port = save_port;
      mged_variables->mv_listen = 0;
      bu_log("set_port: failed to hang a listen on ports %d - %d\n",
	     mged_variables->mv_port, mged_variables->mv_port + MAX_PORT_TRIES - 1);
  } else {
#ifndef _WIN32
      Tcl_CreateFileHandler(netfd, TCL_READABLE,
			    new_client_handler, (ClientData)netfd);
#else
      netchan = Tcl_MakeTcpClientChannel(netfd);
      Tcl_CreateChannelHandler(netchan,
			       TCL_READABLE,
			       new_client_handler,
			       (ClientData)netfd);
#endif
  }
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1995-2004 United States Government as represented by
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/fbserv.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			F B S E R V . C
a35 9
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/fbserv.c,v 1.4 2004/09/16 03:44:11 morrison Exp $ (ARL)";
@


1.4
log
@ws
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/fbserv.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (ARL)";
d827 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/fbserv.c,v 1.2 2004/06/08 22:04:28 morrison Exp $ (ARL)";
a32 2


d44 2
a47 1
#include "../libfb/pkgtypes.h"
d50 1
d53 1
d57 1
a57 1
#undef LOCAL_STATIC
@


1.2
log
@obliterate externs.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d31 1
a31 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/fbserv.c,v 1.16 2004/05/10 15:30:48 erikg Exp $ (ARL)";
a44 1
#include "externs.h"		/* For malloc, getopt */
@

