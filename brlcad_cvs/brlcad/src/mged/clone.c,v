head	1.53;
access;
symbols
	rel-7-10-4:1.25.2.3
	STABLE:1.25.0.2
	rel-7-10-2:1.25
	rel-7-10-0:1.24
	rel-7-8-4:1.18
	rel-7-8-2:1.10
	rel-7-8-0:1.10
	trimnurbs-branch:1.9.0.2
	help:1.9
	temp_tag:1.4
	postmerge-20051223-bobWinPort:1.4
	premerge-20051223-bobWinPort:1.3
	rel-7-6-6:1.3;
locks; strict;
comment	@ * @;


1.53
date	2007.12.07.17.47.37;	author erikgreenwald;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.02.23.16.31;	author brlcad;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.02.22.34.22;	author brlcad;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.21.15.52.58;	author erikgreenwald;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.08.15.32.47;	author erikgreenwald;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.29.03.27.59;	author erikgreenwald;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.28.05.41.47;	author brlcad;	state Exp;
branches;
next	1.46;

1.46
date	2007.10.22.20.11.20;	author erikgreenwald;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.22.19.58.39;	author erikgreenwald;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.22.19.48.32;	author erikgreenwald;	state Exp;
branches;
next	1.43;

1.43
date	2007.10.22.16.18.26;	author erikgreenwald;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.22.15.34.53;	author erikgreenwald;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.09.17.50.31;	author erikgreenwald;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.09.17.47.16;	author erikgreenwald;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.09.17.41.11;	author erikgreenwald;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.09.16.58.14;	author erikgreenwald;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.25.20.54.38;	author erikgreenwald;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.25.20.32.11;	author erikgreenwald;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.25.19.19.44;	author erikgreenwald;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.25.18.10.42;	author erikgreenwald;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.25.18.06.57;	author erikgreenwald;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.18.21.09.57;	author erikgreenwald;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.18.19.17.49;	author erikgreenwald;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.18.19.09.42;	author erikgreenwald;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.14.18.56.22;	author erikgreenwald;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.14.17.51.47;	author erikgreenwald;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.14.17.44.10;	author erikgreenwald;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.14.15.21.09;	author erikgreenwald;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.14.21.04.32;	author brlcad;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2007.02.20.08.19.49;	author brlcad;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.27.22.38.41;	author brlcad;	state Exp;
branches;
next	1.22;

1.22
date	2007.01.27.01.41.43;	author brlcad;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.23.01.13.41;	author brlcad;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.12.05.53.56;	author brlcad;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.14.13.16.56;	author brlcad;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.14.01.53.44;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.14.00.54.01;	author brlcad;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.13.23.34.53;	author brlcad;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.11.15.35.51;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.26.16.25.35;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.26.16.00.53;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.26.15.21.01;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.06.20.50.03;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.29.08.39.28;	author brlcad;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2006.01.28.00.36.28;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.20.21.16.47;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.20.20.06.47;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.15.11.33.11;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.13.03.59.16;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.04.06.04.27;	author brlcad;	state Exp;
branches;
next	;

1.9.2.1
date	2006.04.07.19.30.28;	author jlowenz;	state Exp;
branches;
next	;

1.25.2.1
date	2007.09.27.21.12.28;	author erikgreenwald;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2007.10.23.20.05.15;	author erikgreenwald;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2007.10.23.20.40.31;	author erikgreenwald;	state Exp;
branches;
next	;


desc
@@


1.53
log
@record Dwayne's wishlist
@
text
@/*	                  C L O N E . C
 * BRL-CAD
 *
 * Copyright (c) 2005-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file clone.c
 *
 * Functions -
 *	f_clone		clones an object, optionally
 *			rotating or translating the copies
 *	f_tracker	clones an object, evenly
 *			spacing the copies along a spline
 *
 * Author -
 *	Adam Ross (v4)
 *      Christopher Sean Morrison (v5)
 *      Erik Greenwald (v5)
 *
 * Source -
 *      Geometric Solutions, Inc.
 *
 * TODO:
 *   use bu_vls strings
 *   use bu_list lists
 *
 * ISSUES/TODO (for DK, ^D means done)
 *  1. No -c option.  This allows the increment given in the '-i' to
 *  act on the second number
 * D2. Remove 15 char name limit.  I ran into this today.
 *  3. No -p option.  I couldn't get this to work.  I re-centered the
 *     geometry, then it tried to work but I ran into the 15 char limit
 *     and had to kill the process (^C).
 *  4. Names - This tool is built around a naming convention.  Currently,
 *     the second number does not list properly (it just truncated the
 *     second number of the 'cut' prims so they ended up 'mess.s1.c' instead
 *     of 'mess.s1.c1').  And the '+' and '-' didn't work, I had to switch
 *     from 'mess.s1-1' to 'mess.s1.c1'.  Also, prims need to increment
 *     by the 'i' number but combs, regions, and assemblies (.c#, .r#, or
 *     just name with a # at the end) should increment by 1.  So you end
 *     up with widget_1, widget_2, widget_3   and not widget_1, widget_4,
 *     widget_7...
 *  5. Tree structure - please retain tree structure to the extent that
 *     you can and try not to re-create prims or combs used more than once.
 *     No warning needed for redundant copies.  Warnings can come later...
 * D6. Display - do display clones but do not resize or re-center view. 
 */

#include "common.h"

#include <stdlib.h>
#include <signal.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"

#include "./ged.h"
#include "./cmd.h"


#define CLONE_VERSION "Clone ver 4.0\n2006-08-08\n"
#define CLONE_BUFSIZE 512

/*
 * NOTE: in order to not shadow the global "dbip" pointer used
 * throughout mged, a "_dbip" is used for 'local' database instance
 * pointers to prevent proliferating the global dbip even further than
 * necessary.  the global is used at the hook functions only as a
 * starting point.
 */


/**
 * state structure used to keep track of what actions the user
 * requested and values necessary to perform the cloning operation.
 */
struct clone_state {
    Tcl_Interp *interp;                 /* Stash a pointer to the tcl interpreter for output */
    struct directory	*src;		/* Source object */
    int			incr;		/* Amount to increment between copies */
    int			n_copies;	/* Number of copies to make */
    int			draw_obj;	/* 1 if draw copied object */
    hvect_t		trans;		/* Translation between copies */
    hvect_t		rot;		/* Rotation between copies */
    hvect_t		rpnt;		/* Point to rotate about (default 0 0 0) */
    int			miraxis;	/* Axis to mirror copy */
    fastf_t		mirpos;		/* Point on axis to mirror copy */
    int			autoview;	/* Execute autoview after drawing all objects */
    int			updpos;		/* Position of number to update (for -c) */
};
#define INTERP state->interp

struct name {
    struct bu_vls src;		/* source object name */
    struct bu_vls *dest;	/* dest object names */
};

/**
 * structure used to store the names of objects that are to be
 * cloned.  space is preallocated via names with len and used keeping
 * track of space available and used.
 */
struct nametbl {
    struct name *names;
    int name_size;
    int names_len;
    int names_used;
};

struct nametbl obj_list;

/**
 * a polynamial value for representing knots
 */
struct knot {
    vect_t pt;
    fastf_t c[3][4];
};

/**
 * a spline path with various segments, break points, and polynamial
 *  values.
 */
struct spline {
    int n_segs;
    fastf_t *t; /* break points */
    struct knot *k; /* polynomials */
};

struct link {
    struct bu_vls name;
    fastf_t len;
    fastf_t pct;
};

/**
 * initialize the name list used for stashing destination names
 */
static void
init_list(struct nametbl *l, int s)
{
    int i, j;

    l->names = (struct name *)bu_calloc(10, sizeof(struct name), "alloc l->names");
    for (i = 0; i < 10; i++) {
	bu_vls_init(&l->names[i].src);
	l->names[i].dest = (struct bu_vls *)bu_calloc(s, sizeof(struct bu_vls), "alloc l->names.dest");
	for (j = 0; j < s; j++)
	    bu_vls_init(&l->names[i].dest[j]);
    }
    l->name_size = s;
    l->names_len = 10;
    l->names_used = 0;
}

/**
 * add a new name to the name list
 */
static int
add_to_list(struct nametbl *l, char *name)
{
    int i, j;

    /*
     * add more slots if adding 1 more new name will fill up all the
     * available slots.
     */
    if (l->names_len == (l->names_used+1)) {
	l->names_len += 10;
	l->names = (struct name *)bu_realloc(l->names, sizeof(struct name)*(l->names_len+1), "realloc l->names");
	for (i = l->names_used; i < l->names_len; i++) {
	    bu_vls_init(&l->names[i].src);
	    l->names[i].dest = (struct bu_vls *)bu_calloc(l->name_size,sizeof(struct bu_vls), "alloc l->names.dest");
	    for (j = 0; j < l->name_size; j++)
		bu_vls_init(&l->names[i].dest[j]);
	}
    }
    bu_vls_strcpy(&l->names[l->names_used++].src, name);
    return l->names_used-1; /* return number of available slots */
}

/**
 * returns the location of 'name' in the list if it exists, returns
 * -1 otherwise.
 */
static int
index_in_list(struct nametbl l, char *name)
{
    int i;

    for (i = 0; i < l.names_used; i++)
	if (!strcmp(bu_vls_addr(&l.names[i].src), name))
	    return i;
    return -1;
}

/**
 * returns truthfully if 'name' exists in the list
 */
static int
is_in_list(struct nametbl l, char *name)
{
    return index_in_list(l,name) != -1;
}

/**
 * returns the next available/unused name, using a consistent naming
 * convention specific to combinations/regions and solids.
 * state->incr is used for each number level increase.
 */
static struct bu_vls *
get_name(struct db_i *_dbip, struct directory *dp, struct clone_state *state, int iter)
{
    struct bu_vls *newname;
    char prefix[CLONE_BUFSIZE] = {0}, suffix[CLONE_BUFSIZE] = {0}, buf[CLONE_BUFSIZE] = {0}, suffix2[CLONE_BUFSIZE] = {0};
    int num = 0, i = 1, j = 0;

    newname = bu_vls_vlsinit();

    /* Ugh. This needs much repair/cleanup. */
    if( state->updpos == 0 ) {
	sscanf(dp->d_namep, "%[!-/,:-~]%d%[!-/,:-~]%512s", &prefix, &num, &suffix, &suffix2); /* CLONE_BUFSIZE */
	snprintf(suffix, CLONE_BUFSIZE, "%s", suffix2);
    } else if ( state->updpos == 1 ) {
	int num2 = 0;
	sscanf(dp->d_namep, "%[!-/,:-~]%d%[!-/,:-~]%d%[!-/,:-~]", &prefix, &num2, &suffix2, &num, &suffix);
	snprintf(prefix, CLONE_BUFSIZE, "%s%d%s", prefix, num2, suffix2);
    } else
	bu_exit(EXIT_FAILURE, "multiple -c options not supported yet.");

    do {
	/* choke the name back to the prefix */
	bu_vls_trunc(newname, 0);
	bu_vls_strcpy(newname, prefix);

        if ((dp->d_flags & DIR_SOLID) || (dp->d_flags & DIR_REGION)) {
    	/* primitives and regions */
    	    if (suffix[0] != 0)
    		if ((i == 1) && is_in_list(obj_list, buf)) {
    		    j = index_in_list(obj_list, buf);
    		    snprintf(buf, CLONE_BUFSIZE, "%s%d", prefix, num);	/* save the name for the next pass */
		    /* clear and set the name */
		    bu_vls_trunc(newname, 0);
		    bu_vls_printf(newname, "%s%s", obj_list.names[j].dest[iter], suffix);
    		} else
		    bu_vls_printf(newname, "%d%s", num+i*state->incr, suffix);
    	    else
    		bu_vls_printf(newname, "%d", num + i*state->incr);
	} else /* non-region combinations */
    	    bu_vls_printf(newname, "%d", (num==0)?2:num+i);
	i++;
    } while (db_lookup(_dbip, bu_vls_addr(newname), LOOKUP_QUIET) != NULL);
    return newname;
}

/**
 * make a copy of a v4 solid by adding it to our book-keeping list,
 * adding it to the db directory, and writing it out to disk.
 */
static void
copy_v4_solid(struct db_i *_dbip, struct directory *proto, struct clone_state *state, int idx)
{
    register struct directory *dp = (struct directory *)NULL;
    union record *rp = (union record *)NULL;
    int i, j;

    /* make n copies */
    for (i = 0; i < state->n_copies; i++) {
	struct bu_vls *name;

	if (i==0)
	    name = get_name(_dbip, proto, state, i);
	else {
	    dp = db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET);
	    if (!dp) {
		continue;
	    }
	    name = get_name(_dbip, dp, state, i);
	}

	/* XXX: this can probably be optimized. */
	bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(name));
	bu_vls_free(name);

	/* add the object to the directory */
	dp = db_diradd(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i]), RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, &proto->d_minor_type);
	if ((dp == DIR_NULL) || (db_alloc(_dbip, dp, proto->d_len) < 0)) {
	    TCL_ALLOC_ERR;
	    return;
	}

	/* get an in-memory reference to the object being copied */
	if ((rp = db_getmrec(_dbip, proto)) == (union record *)0) {
	    TCL_READ_ERR;
	    return;
	}

	if (rp->u_id == ID_SOLID) {
	    strncpy(rp->s.s_name, dp->d_namep, CLONE_BUFSIZE-1);

	    /* mirror */
	    if (state->miraxis != W) {
		/* XXX er, this seems rather wrong .. but it's v4 so punt */
		rp->s.s_values[state->miraxis] += 2 * (state->mirpos - rp->s.s_values[state->miraxis]);
		for (j = 3+state->miraxis; j < 24; j++)
		    rp->s.s_values[j] = -rp->s.s_values[j];
	    }
	    /* translate */
	    if (state->trans[W])
		/* assumes primitive's first parameter is it's position */
		VADD2(rp->s.s_values, rp->s.s_values, state->trans);
	    /* rotate */
	    if (state->rot[W]) {
		mat_t r;
		vect_t vec, ovec;

		if (state->rpnt[W])
		    VSUB2(rp->s.s_values, rp->s.s_values, state->rpnt);
		MAT_IDN(r);
		bn_mat_angles(r, state->rot[X], state->rot[Y], state->rot[Z]);
		for (j = 0; j < 24; j+=3) {
		    VMOVE(vec, rp->s.s_values+j);
		    MAT4X3VEC(ovec, r, vec);
		    VMOVE(rp->s.s_values+j, ovec);
		}
		if (state->rpnt[W])
		    VADD2(rp->s.s_values, rp->s.s_values, state->rpnt);
	    }
	} else
	    bu_log("mods not available on %s\n", proto->d_namep);

	/* write the object to disk */
	if (db_put(_dbip, dp, rp, 0, dp->d_len) < 0) {
	    bu_log("ERROR: clone internal error writing to the database\n");
	    return;
	}
    }
    if (rp)
	bu_free((char *)rp, "copy_solid record[]");

    return;
}

/**
 * make a copy of a v5 solid by adding it to our book-keeping list,
 * adding it to the db directory, and writing it out to disk.
 */
static void
copy_v5_solid(struct db_i *_dbip, struct directory *proto, struct clone_state *state, int idx)
{
    int i;
    mat_t matrix;
    MAT_IDN(matrix);

    /* mirror */
    if (state->miraxis != W) {
	/* matrix[5*state->miraxis] *= -1; */
	bu_log("WARNING: mirroring not implemented!");
    }

    /* translate */
    if (state->trans[W])
	MAT_DELTAS_ADD_VEC(matrix, state->trans);

    /* rotation */
    if (state->rot[W]) {
    	mat_t m2, t;
	bn_mat_angles(m2, state->rot[X], state->rot[Y], state->rot[Z]);
	bn_mat_mul(t, matrix, m2);
	MAT_COPY(matrix, t);
    }

    /* make n copies */
    for (i = 0; i < state->n_copies; i++) {
	char *argv[6] = {"wdb_copy", (char *)NULL, (char *)NULL, (char *)NULL, (char *)NULL, (char *)NULL};
	struct bu_vls *name;
	int ret;
	register struct directory *dp = (struct directory *)NULL;
	struct rt_db_internal intern;

	if (i==0)
	    dp = proto;
	else
	    dp = db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET);

	if (!dp) {
	    continue;
	}

	name = get_name(_dbip, dp, state, i); /* get new name */
	bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(name));

	/* actually copy the primitive to the new name */
	argv[1] = proto->d_namep;
	argv[2] = bu_vls_addr(name);
	ret = wdb_copy_cmd(_dbip->dbi_wdbp, INTERP, 3, argv);
	if (ret != TCL_OK)
	    bu_log("WARNING: failure cloning \"%s\" to \"%s\"\n", proto->d_namep, name);

	/* get the original objects matrix */
	if (rt_db_get_internal(&intern, dp, _dbip, matrix, &rt_uniresource) < 0) {
	    bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
	    bu_vls_free(name);
	    return;
	}
	RT_CK_DB_INTERNAL(&intern);
	/* pull the new name */
	dp = db_lookup(_dbip, bu_vls_addr(name), LOOKUP_QUIET);
	bu_vls_free(name);
	if (!dp) {
	    bu_vls_free(name);
	    continue;
	}

	/* write the new matrix to the new object */
	if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0)
	    bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
	rt_db_free_internal(&intern, &rt_uniresource);
    } /* end iteration over each copy */

    return;
}

/**
 * make n copies of a database combination by adding it to our
 * book-keeping list, adding it to the directory, then writing it out
 * to the db.
 */
static void
copy_solid(struct db_i *_dbip, struct directory *proto, genptr_t state)
{
    int idx;

    if (is_in_list(obj_list, proto->d_namep)) {
	bu_log("Solid primitive %s already cloned?\n", proto->d_namep);
	return;
    }

    idx = add_to_list(&obj_list, proto->d_namep);

    /* sanity check that the item was really added */
    if ((idx < 0) || !is_in_list(obj_list, proto->d_namep)) {
	bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
	return;
    }

    if (_dbip->dbi_version < 5)
	(void)copy_v4_solid(_dbip, proto, (struct clone_state *)state, idx);
    else
	(void)copy_v5_solid(_dbip, proto, (struct clone_state *)state, idx);
    return;
}

/**
 * make n copies of a v4 combination.
 */
static struct directory *
copy_v4_comb(struct db_i *_dbip, struct directory *proto, struct clone_state *state, int idx)
{
    register struct directory *dp = (struct directory *)NULL;
    union record *rp = (union record *)NULL;
    int i, j;

    /* make n copies */
    for (i = 0; i < state->n_copies; i++) {

	/* get a v4 in-memory reference to the object being copied */
	if ((rp = db_getmrec(_dbip, proto)) == (union record *)0) {
	    TCL_READ_ERR;
	    return NULL;
	}

	if (proto->d_flags & DIR_REGION) {
	    if (!is_in_list(obj_list, rp[1].M.m_instname)) {
		bu_log("ERROR: clone internal error looking up %s\n", rp[1].M.m_instname);
		return NULL;
	    }
	    bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(&obj_list.names[index_in_list(obj_list, rp[1].M.m_instname)].dest[i]));
	    /* bleh, odd convention going on here.. prefix regions with an 'r' */
	    *bu_vls_addr(&obj_list.names[idx].dest[i]) = 'r';
	} else {
	    struct bu_vls *name;
	    if (i==0)
		name = get_name(_dbip, proto, state, i);
	    else {
		dp = db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET);
		if (!dp) {
		    continue;
		}
		name = get_name(_dbip, dp, state, i);
	    }
	    bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(name));
	    bu_vls_free(name);
	}
	strncpy(rp[0].c.c_name, bu_vls_addr(&obj_list.names[idx].dest[i]), CLONE_BUFSIZE-1);

	/* add the object to the directory */
	dp = db_diradd(_dbip, rp->c.c_name, RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, &proto->d_minor_type);
	if ((dp == NULL) || (db_alloc(_dbip, dp, proto->d_len) < 0)) {
	    TCL_ALLOC_ERR;
	    return NULL;
	}

	for (j = 1; j < proto->d_len; j++) {
	    if (!is_in_list(obj_list, rp[j].M.m_instname)) {
		bu_log("ERROR: clone internal error looking up %s\n", rp[j].M.m_instname);
		return NULL;
	    }
	    snprintf(rp[j].M.m_instname, CLONE_BUFSIZE, "%s", obj_list.names[index_in_list(obj_list, rp[j].M.m_instname)].dest[i]);
	}

	/* write the object to disk */
	if (db_put(_dbip, dp, rp, 0, dp->d_len) < 0) {
	    bu_log("ERROR: clone internal error writing to the database\n");
	    return NULL;
	}

	/* our responsibility to free the record */
	bu_free((char *)rp, "deallocate copy_v4_comb() db_getmrec() record");
    }

    return dp;
}

/*
 * update the v5 combination tree with the new names.
 * DESTRUCTIVE RECURSIVE
 */
int
copy_v5_comb_tree(union tree *tree, int idx)
{
    char *buf;
    switch(tree->tr_op){
	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
	    /* copy right */
	    copy_v5_comb_tree(tree->tr_b.tb_right, idx);
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
	    /* copy left */
	    copy_v5_comb_tree(tree->tr_b.tb_left, idx);
	    break;
	case OP_DB_LEAF:
	    buf = tree->tr_l.tl_name;
	    tree->tr_l.tl_name = bu_strdup(bu_vls_addr(&obj_list.names[index_in_list(obj_list,buf)].dest[idx]));
	    bu_free(buf, "node name");
	    break;
	default:
	    bu_log("clone v5 - OPCODE NOT IMPLEMENTED: %d\n", tree->tr_op);
	    return -1;
    }
    return 0;
}

/**
 * make n copies of a v5 combination.
 */
static struct directory *
copy_v5_comb(struct db_i *_dbip, struct directory *proto, struct clone_state *state, int idx)
{
    register struct directory *dp = (struct directory *)NULL;
    struct bu_vls *name;
    int i;

    /* sanity */
    if (!proto) {
	bu_log("ERROR: clone internal consistency error\n");
	return (struct directory *)NULL;
    }

    /* make n copies */
    for (i = 0; i < state->n_copies; i++) {
	if (i==0)
	    name = get_name(_dbip, proto, state, i);
	else {
	    dp = db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET);
	    if (!dp) {
		continue;
	    }
	    name = get_name(_dbip, dp, state, i);
	}
	bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(name));

	/* we have a before and an after, do the copy */
	if (proto->d_namep && bu_vls_addr(name)) {
	    struct rt_db_internal dbintern;
	    struct rt_comb_internal *comb;

	    dp = db_lookup(_dbip, proto->d_namep, LOOKUP_QUIET);
	    if (!dp) {
		bu_vls_free(name);
		continue;
	    }
	    if (rt_db_get_internal(&dbintern, dp, _dbip, bn_mat_identity, &rt_uniresource) < 0) {
		bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
		return NULL;
	    }

	    if ((dp=db_diradd(wdbp->dbip, bu_vls_addr(name), -1, 0, proto->d_flags, (genptr_t)&proto->d_minor_type)) == DIR_NULL ) {
		bu_log("An error has occured while adding a new object to the database.");
		return NULL;
	    }

	    RT_CK_DB_INTERNAL(&dbintern);
	    comb = (struct rt_comb_internal *)dbintern.idb_ptr;
	    RT_CK_COMB(comb);
	    RT_CK_TREE(comb->tree);

	    /* recursively update the tree */
	    copy_v5_comb_tree(comb->tree, i);

	    if (rt_db_put_internal(dp, wdbp->dbip, &dbintern, &rt_uniresource) < 0) {
		bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
		bu_vls_free(name);
		return NULL;
	    }
	    bu_vls_free(name);
	    rt_db_free_internal(&dbintern, &rt_uniresource);
	}

	/* done with this name */
	bu_vls_free(name);
    }

    return dp;
}

/**
 * make n copies of a database combination by adding it to our
 * book-keeping list, adding it to the directory, then writing it out
 * to the db.
 */
static void
copy_comb(struct db_i *_dbip, struct directory *proto, genptr_t state)
{
    int idx;

    if (is_in_list(obj_list, proto->d_namep)) {
	bu_log("Combination %s already cloned?\n", proto->d_namep);
	return;
    }

    idx = add_to_list(&obj_list, proto->d_namep);

    /* sanity check that the item was really added to our bookkeeping */
    if ((idx < 0) || !is_in_list(obj_list, proto->d_namep)) {
	bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
	return;
    }

    if (_dbip->dbi_version < 5)
	(void)copy_v4_comb(_dbip, proto, (struct clone_state *)state, idx);
    else
	(void)copy_v5_comb(_dbip, proto, (struct clone_state *)state, idx);

    return;
}

/**
 * recursively copy a tree of geometry
 */
static struct directory *
copy_tree(struct db_i *_dbip, struct directory *dp, struct resource *resp, struct clone_state *state)
{
    register int i;
    register union record   *rp = (union record *)NULL;
    register struct directory *mdp = (struct directory *)NULL;
    register struct directory *copy = (struct directory *)NULL;

    struct bu_vls *copyname;
    struct bu_vls *nextname;

    /* get the name of what the object "should" get cloned to */
    copyname = get_name(_dbip, dp, state, 0);

    /* copy the object */
    if (dp->d_flags & DIR_COMB) {

	if (_dbip->dbi_version < 5) {
	    /* A v4 method of peeking into a combination */

	    int errors = 0;

	    /* get an in-memory record of this object */
	    if ((rp = db_getmrec(_dbip, dp)) == (union record *)0) {
		TCL_READ_ERR;
		goto done_copy_tree;
	    }
	    /*
	     * if it is a combination/region, copy the objects that
	     * make up the object.
	     */
	    for (i = 1; i < dp->d_len; i++ ) {
		if ((mdp = db_lookup(_dbip, rp[i].M.m_instname, LOOKUP_NOISY)) == DIR_NULL) {
		    errors++;
		    bu_log("WARNING: failed to locate \"%s\"\n", rp[i].M.m_instname);
		    continue;
		}
		copy = copy_tree(_dbip, mdp, resp, state);
		if (!copy) {
		    errors++;
		    bu_log("WARNING: unable to fully clone \"%s\"\n", rp[i].M.m_instname);
		}
	    }

	    if (errors) {
		bu_log("WARNING: some elements of \"%s\" could not be cloned\n", dp->d_namep);
	    }

	    /* copy this combination itself */
	    copy_comb(_dbip, dp, (genptr_t)state);
	} else
	    /* A v5 method of peeking into a combination */
	    db_functree(_dbip, dp, copy_comb, copy_solid, resp, (genptr_t)state);
    } else if (dp->d_flags & DIR_SOLID)
	/* leaf node -- make a copy the object */
	copy_solid(_dbip, dp, (genptr_t)state);
    else {
	Tcl_AppendResult(INTERP, "clone:  ", dp->d_namep, " is neither a combination or a primitive?\n", (char *)NULL);
	goto done_copy_tree;
    }

    nextname = get_name(_dbip, dp, state, 0);
    if (bu_vls_strcmp(copyname, nextname) == 0)
	bu_log("ERROR: unable to successfully clone \"%s\" to \"%s\"\n", dp->d_namep, copyname);
    else
	copy = db_lookup(_dbip, bu_vls_addr(copyname), LOOKUP_QUIET);

 done_copy_tree:
    if (rp)
	bu_free((char *)rp, "copy_tree record[]");
    if (copyname)
	bu_free((char *)copyname, "free get_name() copyname");
    if (nextname)
	bu_free((char *)nextname, "free get_name() copyname");

    return copy;
}

/**
 * copy an object, recursivley copying all of the object's contents
 * if it's a combination/region.
 */
static struct directory *
copy_object(struct db_i *_dbip, struct resource *resp, struct clone_state *state)
{
    struct directory *copy = (struct directory *)NULL;
    struct nametbl *curr = (struct nametbl *)NULL;
    int i, j, idx;

    init_list(&obj_list, state->n_copies);

    /* do the actual copying */
    copy = copy_tree(_dbip, state->src, resp, state);

    /* make sure it made what we hope/think it made */
    if (!copy || !is_in_list(obj_list, state->src->d_namep))
	return copy;

    /* display the cloned object(s) */
    if (state->draw_obj) {
	char *av[3] = {"e", NULL, NULL};

	idx = index_in_list(obj_list, state->src->d_namep);
	for (i = 0; i < (state->n_copies > obj_list.name_size ? obj_list.name_size : state->n_copies) ; i++) {
	    av[1] = bu_vls_addr(&obj_list.names[idx].dest[i]);
	    /* draw does not use clientdata */
	    cmd_draw( (ClientData)NULL, INTERP, 2, av );
	}
	if(state->autoview) {
	    av[0] = "autoview";
	    cmd_autoview((ClientData)NULL, INTERP, 1, av);
	}
    }

    /* release our name allocations */
    for (i = 0; i < obj_list.names_len; i++) {
	for (j = 0; j < obj_list.name_size; j++)
	    bu_vls_free(&obj_list.names[i].dest[j]);
	bu_free((char **)obj_list.names[i].dest, "free dest");
    }
    bu_free((struct name *)obj_list.names, "free names");

    /* better safe than sorry */
    obj_list.names = NULL;
    obj_list.name_size = obj_list.names_used = obj_list.names_len = 0;

    return copy;
}

/**
 * how to use clone.  blissfully simple interface.
 */
void
print_usage(Tcl_Interp *interp)
{
    Tcl_AppendResult(interp, "Usage: clone [-abfhimnprtv] <object>\n\n", (char *)NULL);
    Tcl_AppendResult(interp, "-a <n> <x> <y> <z>\t- Specifies a translation split between n copies.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-b <n> <x> <y> <z>\t- Specifies a rotation around x, y, and z axes \n\t\t\t  split between n copies.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-c\t\t\t- Increment the second number in object names.\n", (char *)NULL);
    Tcl_AppendResult(interp, "-f\t\t\t- Don't draw the new object.\n", (char *)NULL);
    Tcl_AppendResult(interp, "-g\t\t\t- Don't resize the view after drawing new objects.\n", (char *)NULL);
    Tcl_AppendResult(interp, "-h\t\t\t- Prints this message.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-i <n>\t\t\t- Specifies the increment between each copy.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-m <axis> <pos>\t\t- Specifies the axis and point to mirror the group.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-n <# copies>\t\t- Specifies the number of copies to make.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-p <x> <y> <z>\t\t- Specifies point to rotate around for -r. \n\t\t\t  Default is 0 0 0.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-r <x> <y> <z>\t\t- Specifies the rotation around x, y, and z axes.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-t <x> <y> <z>\t\t- Specifies translation between each copy.\n", (char*)NULL);
    Tcl_AppendResult(interp, "-v\t\t\t- Prints version info.\n", (char*)NULL);
    return;
}

/**
 * process the user-provided arguments. stash their operations into
 * our state structure.
 */
int
get_args(Tcl_Interp *interp, int argc, char **argv, struct clone_state *state)
{
    int i, k;

    bu_optind = 1;

    state->interp = interp;
    state->incr = 100;
    state->n_copies = 1;
    state->draw_obj = 1;
    state->autoview = 1;
    state->rot[W] = 0;
    state->rpnt[W] = 0;
    state->trans[W] = 0;
    state->miraxis = W;
    state->updpos = 0;
    while ((k = bu_getopt(argc, argv, "a:b:cfhgi:m:n:p:r:t:v")) != EOF) {
	switch (k) {
	    case 'a':
		state->n_copies = atoi(bu_optarg);
		state->trans[X] = atof(argv[bu_optind++]) / state->n_copies;
		state->trans[Y] = atof(argv[bu_optind++]) / state->n_copies;
		state->trans[Z] = atof(argv[bu_optind++]) / state->n_copies;
		state->trans[W] = 1;
		break;
	    case 'b':
		state->n_copies = atoi(bu_optarg);
		state->rot[X] = atof(argv[bu_optind++]) / state->n_copies;
		state->rot[Y] = atof(argv[bu_optind++]) / state->n_copies;
		state->rot[Z] = atof(argv[bu_optind++]) / state->n_copies;
		state->rot[W] = 1;
		break;
	    case 'c':
		/* I'd like to have an optional argument to -c, but for now,
		 * just let multiple -c's add it up as a hack. I believe the
		 * variant of this that was lost used this as a binary
		 * operation, so it SHOULD be functionally equivelant for a user
		 * who's dealt with this before. */
		state->updpos++;
		break;
	    case 'f':
		state->draw_obj = 0;
		break;
	    case 'g':
		state->autoview = 0;
		break;
	    case 'h':
		print_usage(interp);
		return TCL_ERROR;
		break;
	    case 'i':
		state->incr = atoi(bu_optarg);
		break;
	    case 'm':
		state->miraxis = bu_optarg[0] - 'x';
		state->mirpos = atof(argv[bu_optind++]);
		break;
	    case 'n':
		state->n_copies = atoi(bu_optarg);
		break;
	    case 'p':
		state->rpnt[X] = atof(bu_optarg);
		state->rpnt[Y] = atof(argv[bu_optind++]);
		state->rpnt[Z] = atof(argv[bu_optind++]);
		state->rpnt[W] = 1;
		break;
	    case 'r':
		state->rot[X] = atof(bu_optarg);
		state->rot[Y] = atof(argv[bu_optind++]);
		state->rot[Z] = atof(argv[bu_optind++]);
		state->rot[W] = 1;
		break;
	    case 't':
		state->trans[X] = atof(bu_optarg);
		state->trans[Y] = atof(argv[bu_optind++]);
		state->trans[Z] = atof(argv[bu_optind++]);
		state->trans[W] = 1;
		break;
	    case 'v':
		Tcl_AppendResult(interp, CLONE_VERSION, (char *)NULL);
		return TCL_ERROR;
		break;
	    default:
		print_usage(interp);
		return TCL_ERROR;
	}
    }

    /* make sure not too few/many args */
    if ((argc - bu_optind) == 0) {
	Tcl_AppendResult(interp, "clone:  Need to specify an <object> to be cloned.\n", (char*)NULL);
	print_usage(interp);
	return TCL_ERROR;
    } else if (bu_optind + 1 < argc) {
	Tcl_AppendResult(interp, "clone:  Can only clone exactly one <object> at a time right now.\n", (char*)NULL);
	print_usage(interp);
	return TCL_ERROR;
    }

    /* sanity */
    if (!argv[bu_optind])
	return TCL_ERROR;

    /* use global dbip; we make sure the lookup succeeded in f_clone() */
    state->src = db_lookup(dbip, argv[bu_optind], LOOKUP_QUIET);
    if (!state->src) {
	Tcl_AppendResult(interp, "clone:  Cannot find source object\n", (char*)NULL);
	return TCL_ERROR;
    }

    VSCALE(state->trans, state->trans, local2base);
    VSCALE(state->rpnt, state->rpnt, local2base);
    state->mirpos *= local2base;

    return TCL_OK;
}

/**
 * master hook function for the 'clone' command.
 */
int
f_clone(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    struct clone_state	state;

    /* allow interrupts */
    if( setjmp( jmp_env ) == 0 )
	(void)signal( SIGINT, sig3);
    else
	return TCL_OK;

    if (argc < 2) {
	Tcl_AppendResult(interp, "clone:  Not enough args.  Use -h for help\n", (char*)NULL);
	return TCL_ERROR;
    }

    /* validate user options */
    if (get_args(interp, argc, argv, &state) == TCL_ERROR)
	return TCL_ERROR;

    /* do it, use global dbip */
    (void)copy_object(dbip, &rt_uniresource, &state);

    (void)signal( SIGINT, SIG_IGN );
    return TCL_OK;
}

/**
 * helper function that computes where a point is along a spline
 * given some distance 't'.
 *
 * i.e. sets pt = Q(t) for the specified spline
 */
void
interp_spl(fastf_t t, struct spline spl, vect_t pt)
{
    int i = 0;
    fastf_t s, s2, s3;

    if (t == spl.t[spl.n_segs])
	t -= VUNITIZE_TOL;

    /* traverse to the spline segment interval */
    while (t >= spl.t[i+1])
	i++;

    /* compute the t offset */
    t -= spl.t[i];
    s = t; s2 = t*t; s3 = t*t*t;

    /* solve for the position */
    pt[X] = spl.k[i].c[X][0] + spl.k[i].c[X][1]*s + spl.k[i].c[X][2]*s2 + spl.k[i].c[X][3]*s3;
    pt[Y] = spl.k[i].c[Y][0] + spl.k[i].c[Y][1]*s + spl.k[i].c[Y][2]*s2 + spl.k[i].c[Y][3]*s3;
    pt[Z] = spl.k[i].c[Z][0] + spl.k[i].c[Z][1]*s + spl.k[i].c[Z][2]*s2 + spl.k[i].c[Z][3]*s3;
}

/**
 * master hook function for the 'tracker' command used to create
 * copies of objects along a spline path.
 */
int
f_tracker(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    struct spline s;
    vect_t *verts  = (vect_t *)NULL;
    struct link *links = (struct link *)NULL;
    int i, j, k, inc;
    int n_verts, n_links, arg = 1;
    FILE *points = (FILE *)NULL;
    char tok[81] = {0}, line[81] = {0};
    char ch;
    fastf_t totlen = 0.0;
    fastf_t len, olen;
    fastf_t dist_to_next;
    fastf_t min, max, mid;
    fastf_t pt[3] = {0}, rot[3] = {0};
    int no_draw = 0;

    /* allow interrupts */
    if( setjmp( jmp_env ) == 0 )
	(void)signal( SIGINT, sig3 );
    else
	return TCL_OK;

    bu_optind = 1;
    while ((i = bu_getopt(argc, argv, "fh")) != EOF)
	switch (i) {
	    case 'f':
		no_draw = 1;
		arg++;
		break;
	    case 'h':
		Tcl_AppendResult(interp, "tracker [-fh] [# links] [increment] [spline.iges] [link...]\n\n", (char *)NULL);
		Tcl_AppendResult(interp, "-f:\tDo not draw the links as they are made.\n", (char *)NULL);
		Tcl_AppendResult(interp, "-h:\tPrint this message.\n\n", (char *)NULL);
		Tcl_AppendResult(interp, "\tThe prototype link(s) should be placed so that one\n", (char *)NULL);
		Tcl_AppendResult(interp, "\tpin's vertex lies on the origin and points along the\n", (char *)NULL);
		Tcl_AppendResult(interp, "\ty-axis, and the link should lie along the positive x-axis.\n\n", (char *)NULL);
		Tcl_AppendResult(interp, "\tIf two or more sublinks comprise the link, they are specified in this manner:\n", (char *)NULL);
		Tcl_AppendResult(interp, "\t<link1> <%% of total link> <link2> <%% of total link> ....\n", (char *)NULL);
		return TCL_OK;
	}

    if (argc < arg+1) {
	Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter number of links: ", (char *)NULL);
	return TCL_ERROR;
    }
    n_verts = atoi(argv[arg++])+1;

    if (argc < arg+1) {
	Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter amount to increment parts by: ", (char *)NULL);
	return TCL_ERROR;
    }
    inc = atoi(argv[arg++]);

    if (argc < arg+1) {
	Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter spline file name: ", (char *)NULL);
	return TCL_ERROR;
    }
    if ((points = fopen(argv[arg++], "r")) == NULL) {
	fprintf(stdout, "tracker:  couldn't open points file %s.\n", argv[arg-1]);
	return TCL_ERROR;
    }

    if (argc < arg+1) {
	Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter prototype link name: ", (char *)NULL);
	return TCL_ERROR;
    }


    /* Prepare vert list *****************************/
    n_links = ((argc-3)/2)>1?((argc-3)/2):1;
    verts = (vect_t *)malloc(sizeof(vect_t) * n_verts * (n_links+2));

    /* Read in links names and link lengths **********/
    links = (struct link *)malloc(sizeof(struct link)*n_links);
    for (i = arg; i < argc; i+=2) {
	bu_vls_strcpy(&links[(i-arg)/2].name, argv[i]);
	if (argc > arg+1)
	    sscanf(argv[i+1], "%lf", &links[(i-arg)/2].pct);
	else
	    links[(i-arg)/2].pct = 1.0;
	totlen += links[(i-arg)/2].pct;
    }
    if (totlen != 1.0)
	fprintf(stdout, "ERROR\n");

    /* Read in knots from specified file *************/
    do
	bu_fgets(line, 81, points);
    while (strcmp(strtok(line, ","), "112") != 0);

    strncpy(tok, strtok(NULL, ","), 81-1);
    strncpy(tok, strtok(NULL, ","), 81-1);
    strncpy(tok, strtok(NULL, ","), 81-1);
    strncpy(tok, strtok(NULL, ","), 81-1);
    s.n_segs = atoi(tok);
    s.t = (fastf_t *)bu_malloc(sizeof(fastf_t) * (s.n_segs+1), "t");
    s.k = (struct knot *)bu_malloc(sizeof(struct knot) * (s.n_segs+1), "k");
    for (i = 0; i <= s.n_segs; i++) {
	strncpy(tok, strtok(NULL, ","), 81-1);
	if (strstr(tok, "P") != NULL) {
	    bu_fgets(line, 81, points);
	    bu_fgets(line, 81, points);
	    strncpy(tok, strtok(line, ","), 81-1);
	}
	s.t[i] = atof(tok);
    }
    for (i = 0; i <= s.n_segs; i++)
	for (j = 0; j < 3; j++) {
	    for (k = 0; k < 4; k++) {
		strncpy(tok, strtok(NULL, ","), 81-1);
		if (strstr(tok, "P") != NULL) {
		    bu_fgets(line, 81, points);
		    bu_fgets(line, 81, points);
		    strncpy(tok, strtok(line, ","), 81-1);
		}
		s.k[i].c[j][k] = atof(tok);
	    }
	    s.k[i].pt[j] = s.k[i].c[j][0];
	}
    fclose(points);

    /* Interpolate link vertices *********************/
    for (i = 0; i < s.n_segs; i++) /* determine initial track length */
	totlen += DIST_PT_PT(s.k[i].pt, s.k[i+1].pt);
    len = totlen/(n_verts-1);
    VMOVE(verts[0], s.k[0].pt);
    olen = 2*len;

    for (i = 0; (fabs(olen-len) >= VUNITIZE_TOL) && (i < 250); i++) { /* number of track iterations */
	fprintf(stdout, ".");
	fflush(stdout);
	for (j = 0; j < n_links; j++) /* set length of each link based on current track length */
	    links[j].len = len * links[j].pct;
	min = 0;
	max = s.t[s.n_segs];
	mid = 0;

	for (j = 0; j < n_verts+1; j++) /* around the track once */
	    for (k = 0; k < n_links; k++) { /* for each sub-link */
		if ((k == 0) && (j == 0)) {continue;} /* the first sub-link of the first link is already in position */
		min = mid;
		max = s.t[s.n_segs];
		mid = (min+max)/2;
		interp_spl(mid, s, pt);
		dist_to_next = (k > 0) ? links[k-1].len : links[n_links-1].len; /* links[k].len;*/
		while (fabs(DIST_PT_PT(verts[n_links*j+k-1], pt) - dist_to_next) >= VUNITIZE_TOL) {
		    if (DIST_PT_PT(verts[n_links*j+k-1], pt) > dist_to_next) {
			max = mid;
			mid = (min+max)/2;
		    } else {
			min = mid;
			mid = (min+max)/2;
		    }
		    interp_spl(mid, s, pt);
		    if (fabs(min-max) <= VUNITIZE_TOL) {break;}
		}
		interp_spl(mid, s, verts[n_links*j+k]);
	    }

	interp_spl(s.t[s.n_segs], s, verts[n_verts*n_links-1]);
	totlen = 0.0;
	for (j = 0; j < n_verts*n_links-1; j++)
	    totlen += DIST_PT_PT(verts[j], verts[j+1]);
	olen = len;
	len = totlen/(n_verts-1);
    }
    fprintf(stdout, "\n");

    /* Write out interpolation info ******************/
    fprintf(stdout, "%d Iterations; Final link lengths:\n", i);
    for (i = 0; i < n_links; i++)
	fprintf(stdout, "  %s\t%.15lf\n", links[i].name, links[i].len);
    fflush(stdin);
    /* Place links on vertices ***********************/
    fprintf(stdout, "Continue? [y/n]  ");
    fscanf(stdin, "%c", &ch);
    if (ch == 'y') {
	struct clone_state state;
	struct directory **dps = (struct directory **)NULL;
	fastf_t units[6] = {1, 1, 10, 1000, 25.4, 304.8};
	char *vargs[3];
	vect_t *rots;

	for (i = 0; i < 2; i++)
	    vargs[i] = (char *)bu_malloc(sizeof(char)*CLONE_BUFSIZE, "alloc vargs1");

	strcpy(vargs[0], "e");
	strncpy(vargs[1], bu_vls_addr(&links[j].name), CLONE_BUFSIZE-1);
	vargs[2] = NULL;

	state.interp = interp;
	state.incr = inc;
	state.n_copies = 1;
	state.draw_obj = 0;
	state.miraxis = W;

	dps = (struct directory **)bu_malloc(sizeof(struct directory *)*n_links, "alloc dps");
	/* rots = (vect_t *)bu_malloc(sizeof(vect_t)*n_links, "alloc rots");*/
	for (i = 0; i < n_links; i++) {
	    /* global dbip */
	    dps[i] = db_lookup(dbip, bu_vls_addr(&links[i].name), LOOKUP_QUIET);
	    /* VSET(rots[i], 0,0,0);*/
	}

	for (i = 0; i < n_verts-1; i++)
	    for (j = 0; j < n_links; j++) {
		if (i == 0) {
		    VSCALE(state.trans, verts[n_links*i+j], local2base);
		} else
		    VSUB2SCALE(state.trans, verts[n_links*(i-1)+j], verts[n_links*i+j], local2base);
		VSCALE(state.rpnt, verts[n_links*i+j], local2base);

		VSUB2(pt, verts[n_links*i+j], verts[n_links*i+j+1]);
		VSET(state.rot, 0, (M_PI - atan2(pt[Z], pt[X])),
		     -atan2(pt[Y], sqrt(pt[X]*pt[X]+pt[Z]*pt[Z])));
		VSCALE(state.rot, state.rot, radtodeg);
		/*
		VSUB2(state.rot, state.rot, rots[j]);
		VADD2(rots[j], state.rot, rots[j]);
		*/

		state.src = dps[j];
		/* global dbip */
		dps[j] = copy_object(dbip, &rt_uniresource, &state);
		strncpy(vargs[1], dps[j]->d_namep, CLONE_BUFSIZE-1);
		/* strcpy(vargs[1], obj_list.names[index_in_list(obj_list, links[j].name)].dest[0]);*/

		if (!no_draw || !is_dm_null()) {
		    drawtrees(2, vargs, 1);
		    size_reset();
		    new_mats();
		    color_soltab();
		    refresh();
		}
		fprintf(stdout, ".");
		fflush(stdout);
	    }
	fprintf(stdout, "\n");
	for (i = 0; i < 2; i++)
	    bu_free((char *)vargs[i], "free vargs[i]");
	free(dps);
    }

    free(s.t);
    free(s.k);
    free(links);
    free(verts);
    (void)signal(SIGINT, SIG_IGN);
    return TCL_OK;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.52
log
@make sure we check db_lookup() for a null return value throughout and do something sensible
@
text
@d39 21
@


1.51
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d270 7
a276 2
	else
	    name = get_name(_dbip, db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET), state, i);
d383 4
d407 5
d482 7
a488 2
	    else
		name = get_name(_dbip, db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET), state, i);
d575 7
a581 2
	else
	    name = get_name(_dbip, db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET), state, i);
d590 4
@


1.50
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d59 1
a59 1

d212 1
a212 1
    char prefix[BUFSIZ] = {0}, suffix[BUFSIZ] = {0}, buf[BUFSIZ] = {0}, suffix2[BUFSIZ] = {0};
d219 2
a220 2
	sscanf(dp->d_namep, "%[!-/,:-~]%d%[!-/,:-~]%s", &prefix, &num, &suffix, &suffix2);
	snprintf(suffix, BUFSIZ, "%s", suffix2);
d224 1
a224 1
	snprintf(prefix, BUFSIZ, "%s%d%s", prefix, num2, suffix2);
d238 1
a238 1
    		    snprintf(buf, BUFSIZ, "%s%d", prefix, num);	/* save the name for the next pass */
d291 1
a291 1
	    strncpy(rp->s.s_name, dp->d_namep, BUFSIZ);
d473 1
a473 1
	strncpy(rp[0].c.c_name, bu_vls_addr(&obj_list.names[idx].dest[i]), BUFSIZ);
d487 1
a487 1
	    snprintf(rp[j].M.m_instname, BUFSIZ, "%s", obj_list.names[index_in_list(obj_list, rp[j].M.m_instname)].dest[i]);
d1063 4
a1066 4
    strcpy(tok, strtok(NULL, ","));
    strcpy(tok, strtok(NULL, ","));
    strcpy(tok, strtok(NULL, ","));
    strcpy(tok, strtok(NULL, ","));
d1071 1
a1071 1
	strcpy(tok, strtok(NULL, ","));
d1075 1
a1075 1
	    strcpy(tok, strtok(line, ","));
d1082 1
a1082 1
		strcpy(tok, strtok(NULL, ","));
d1086 1
a1086 1
		    strcpy(tok, strtok(line, ","));
a1093 1

d1157 1
a1157 1
	    vargs[i] = (char *)bu_malloc(sizeof(char)*BUFSIZ, "alloc vargs1");
d1160 1
a1160 1
	strcpy(vargs[1], bu_vls_addr(&links[j].name));
d1197 1
a1197 1
		strcpy(vargs[1], dps[j]->d_namep);
@


1.49
log
@add a break; to the -p option (been missing since the original import from GSI, wow)
@
text
@d226 1
a226 1
	bu_bomb("multiple -c options not supported yet.");
d349 1
@


1.48
log
@I have no clue what a "BUFXIZE" is, but I know what BUFSIZ is...
@
text
@d855 1
@


1.47
log
@more flawfinder and bu_exit conversions
@
text
@d220 1
a220 1
	snprintf(suffix, BUFXIZE, "%s", suffix2);
@


1.46
log
@don't assume the suffix starts with a '.'
@
text
@d220 1
a220 1
	strncat(suffix, suffix2, BUFSIZ);
@


1.45
log
@retain 2nd (3rd? 87th?) number if no -c option is given
@
text
@d235 1
a235 1
    	    if (suffix[0] == '.')
@


1.44
log
@change get_name() to return a bu_vls instead of a char*
@
text
@d212 1
a212 1
    char prefix[BUFSIZ] = {0}, suffix[BUFSIZ] = {0}, buf[BUFSIZ] = {0};
d218 4
a221 3
    if( state->updpos == 0 )
	sscanf(dp->d_namep, "%[!-/,:-~]%d%[!-/,:-~]", &prefix, &num, &suffix);
    else if ( state->updpos == 1 ) {
a222 1
	char suffix2[BUFSIZ] = {0};
@


1.43
log
@crude -c functionality
@
text
@d208 1
a208 1
static const char *
d211 1
a211 1
    char *newname = NULL;
d215 1
a215 2
    if (!newname)
	newname = (char *)bu_calloc(BUFSIZ, sizeof(char), "alloc newname");
d229 4
d238 4
a241 2
    		    snprintf(buf, BUFSIZ, "%s%d", prefix, num);
    		    snprintf(newname, BUFSIZ, "%s%s", obj_list.names[j].dest[iter], suffix);
d243 1
a243 1
    		    snprintf(newname, BUFSIZ, "%s%d%s", prefix, num+i*state->incr, suffix);
d245 1
a245 1
    		snprintf(newname, BUFSIZ, "%s%d", prefix, num + i*state->incr);
d247 1
a247 1
    	    snprintf(newname, BUFSIZ, "%s%d", prefix, (num==0)?2:num+i);
d249 2
a250 2
    } while (db_lookup(_dbip, newname, LOOKUP_QUIET) != NULL);
    return bu_realloc(newname, strlen(newname) + 1, "get_name realloc");
d266 1
a266 1
	const char *name = (const char *)NULL;
d272 4
a275 2
	bu_vls_strcpy(&obj_list.names[idx].dest[i], name);
	bu_free((char *)name, "free get_name() name");
d367 1
a367 1
	const char *name = (char *)NULL;
d376 1
d378 1
a378 1
	bu_vls_strcpy(&obj_list.names[idx].dest[i], name);
d382 1
a382 1
	argv[2] = (char *)name;
d390 1
d395 2
a396 2
	dp = db_lookup(_dbip, name, LOOKUP_QUIET);
	bu_free((char *)name, "free get_name() name");
d464 1
a464 1
	    const char *name = (const char *)NULL;
d469 2
a470 2
	    bu_vls_strcpy(&obj_list.names[idx].dest[i], name);
	    bu_free((char *)name, "free get_name() name");
d542 1
a542 1
    const char *name = (const char *)NULL;
d557 1
a557 1
	bu_vls_strcpy(&obj_list.names[idx].dest[i], name);
d560 1
a560 1
	if (proto->d_namep && name) {
d570 1
a570 1
	    if ((dp=db_diradd(wdbp->dbip, name, -1, 0, proto->d_flags, (genptr_t)&proto->d_minor_type)) == DIR_NULL ) {
d585 1
d588 1
d593 1
a593 2
	bu_free((char *)name, "free get_name() name");
	name = (const char *)NULL;
d641 2
a642 2
    const char *copyname = (const char *)NULL;
    const char *nextname = (const char *)NULL;
d695 1
a695 1
    if (strcmp(copyname, nextname) == 0)
d698 1
a698 1
	copy = db_lookup(_dbip, copyname, LOOKUP_QUIET);
@


1.42
log
@start stubbing in the -c stuff
@
text
@a132 1

a152 1

d213 1
a213 1
    int num = 0, i = 1, j;
d217 11
a227 1
    sscanf(dp->d_namep, "%[!-/,:-~]%d%[!-/,:-~]", &prefix, &num, &suffix);
a328 1

a396 1

a426 1

a619 1

a700 1

a751 1

a774 1

d795 1
d813 6
a818 1
		/* XXX */
a895 1

a925 1

a954 1

@


1.41
log
@realloc() the new name to avoid wasting space
@
text
@d86 1
a239 1

d759 1
d794 1
a794 1
    while ((k = bu_getopt(argc, argv, "a:b:fhgi:m:n:p:r:t:v")) != EOF) {
d810 3
@


1.40
log
@use BUFSIZ instead of NAMESIZE to allow strings longer than 15 characters
@
text
@d236 1
a236 1
    return newname;
@


1.39
log
@minor cleanup/simplification of get_name()
@
text
@d213 1
a213 1
    char prefix[NAMESIZE] = {0}, suffix[NAMESIZE] = {0}, buf[NAMESIZE] = {0};
d217 1
a217 1
	newname = (char *)bu_calloc(NAMESIZE, sizeof(char), "alloc newname");
d226 2
a227 2
    		    snprintf(buf, NAMESIZE, "%s%d", prefix, num);
    		    snprintf(newname, NAMESIZE, "%s%s", obj_list.names[j].dest[iter], suffix);
d229 1
a229 1
    		    snprintf(newname, NAMESIZE, "%s%d%s", prefix, num+i*state->incr, suffix);
d231 1
a231 1
    		snprintf(newname, NAMESIZE, "%s%d", prefix, num + i*state->incr);
d233 1
a233 1
    	    snprintf(newname, NAMESIZE, "%s%d", prefix, (num==0)?2:num+i);
d276 1
a276 1
	    strncpy(rp->s.s_name, dp->d_namep, NAMESIZE);
d458 1
a458 1
	strncpy(rp[0].c.c_name, bu_vls_addr(&obj_list.names[idx].dest[i]), NAMESIZE);
d472 1
a472 1
	    snprintf(rp[j].M.m_instname, NAMESIZE, "%s", obj_list.names[index_in_list(obj_list, rp[j].M.m_instname)].dest[i]);
d1138 1
a1138 1
	    vargs[i] = (char *)bu_malloc(sizeof(char)*NAMESIZE, "alloc vargs1");
@


1.38
log
@add flag to disable autoview after drawing cloned objects
@
text
@d220 16
a235 20
    if ((dp->d_flags & DIR_SOLID) || (dp->d_flags & DIR_REGION))
	/* primitives and regions */
	do {
	    if (suffix[0] == '.')
		if ((i == 1) && is_in_list(obj_list, buf)) {
		    j = index_in_list(obj_list, buf);
		    snprintf(buf, NAMESIZE, "%s%d", prefix, num);
		    snprintf(newname, NAMESIZE, "%s%s", obj_list.names[j].dest[iter], suffix);
		} else
		    snprintf(newname, NAMESIZE, "%s%d%s", prefix, num+i*state->incr, suffix);
	    else
		snprintf(newname, NAMESIZE, "%s%d", prefix, num+i*state->incr);
	    i++;
	} while (db_lookup(_dbip, newname, LOOKUP_QUIET) != NULL);
    else
	/* non-region combinations */
	do {
	    snprintf(newname, NAMESIZE, "%s%d", prefix, (num==0)?2:num+i);
	    i++;
	} while (db_lookup(_dbip, newname, LOOKUP_QUIET) != NULL);
@


1.37
log
@use bu_vls_addr() instead of directly accessing the char*
@
text
@d85 1
d732 4
a735 2
	av[0] = "autoview";
	cmd_autoview((ClientData)NULL, INTERP, 1, av);
d764 1
d792 1
d797 1
a797 1
    while ((k = bu_getopt(argc, argv, "a:b:fhi:m:n:p:r:t:v")) != EOF) {
d816 3
@


1.36
log
@some move to bu_vls strings
@
text
@d189 1
a189 1
	if (!strcmp(l.names[i].src.vls_str, name))
d261 1
a261 1
	    name = get_name(_dbip, db_lookup(_dbip, obj_list.names[idx].dest[i-1].vls_str, LOOKUP_QUIET), state, i);
d266 1
a266 1
	dp = db_diradd(_dbip, obj_list.names[idx].dest[i].vls_str, RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, &proto->d_minor_type);
d364 1
a364 1
	    dp = db_lookup(_dbip, obj_list.names[idx].dest[i-1].vls_str, LOOKUP_QUIET);
d449 1
a449 1
	    bu_vls_strcpy(&obj_list.names[idx].dest[i], obj_list.names[index_in_list(obj_list, rp[1].M.m_instname)].dest[i].vls_str);
d451 1
a451 1
	    *obj_list.names[idx].dest[i].vls_str = 'r';
d457 1
a457 1
		name = get_name(_dbip, db_lookup(_dbip, obj_list.names[idx].dest[i-1].vls_str, LOOKUP_QUIET), state, i);
d461 1
a461 1
	strncpy(rp[0].c.c_name, obj_list.names[idx].dest[i].vls_str, NAMESIZE);
d514 1
a514 1
	    tree->tr_l.tl_name = bu_strdup(obj_list.names[index_in_list(obj_list,buf)].dest[idx].vls_str);
d545 1
a545 1
	    name = get_name(_dbip, db_lookup(_dbip, obj_list.names[idx].dest[i-1].vls_str, LOOKUP_QUIET), state, i);
d727 1
a727 1
	    av[1] = obj_list.names[idx].dest[i].vls_str;
d1137 1
a1137 1
	strcpy(vargs[1], links[j].name.vls_str);
d1150 1
a1150 1
	    dps[i] = db_lookup(dbip, links[i].name.vls_str, LOOKUP_QUIET);
@


1.35
log
@a mostly-functional v5 copy_v5_comb
@
text
@a87 1
/* XXX change from NAMESIZE to bu_vls */
d89 2
a90 2
    char src[NAMESIZE];	/* source object name */
    char **dest;		/* dest object names */
d126 1
a126 1
    char name[NAMESIZE];
d142 2
a143 1
	l->names[i].dest = (char **)bu_calloc(s, sizeof(char *), "alloc l->names.dest");
d145 1
a145 1
	    l->names[i].dest[j] = (char *)bu_calloc(NAMESIZE, sizeof(char), "alloc l->names.dest[j]");
d169 2
a170 1
	    l->names[i].dest = (char **)bu_calloc(l->name_size, sizeof(char *), "alloc l->names.dest");
d172 1
a172 1
		l->names[i].dest[j] = (char *)bu_calloc(NAMESIZE, sizeof(char), "alloc l->names.dest[j]");
d175 1
a175 1
    strncpy(l->names[l->names_used++].src, name, NAMESIZE);
d189 1
a189 1
	if (!strcmp(l.names[i].src, name))
d261 2
a262 2
	    name = get_name(_dbip, db_lookup(_dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET), state, i);
	strncpy(obj_list.names[idx].dest[i], name, NAMESIZE);
d266 1
a266 1
	dp = db_diradd(_dbip, obj_list.names[idx].dest[i], RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, &proto->d_minor_type);
d364 1
a364 1
	    dp = db_lookup(_dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET);
d366 1
a366 1
	strncpy(obj_list.names[idx].dest[i], name, NAMESIZE);
d449 1
a449 1
	    strncpy(obj_list.names[idx].dest[i], obj_list.names[index_in_list(obj_list, rp[1].M.m_instname)].dest[i], NAMESIZE);
d451 1
a451 1
	    obj_list.names[idx].dest[i][0] = 'r';
d457 2
a458 2
		name = get_name(_dbip, db_lookup(_dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET), state, i);
	    strncpy(obj_list.names[idx].dest[i], name, NAMESIZE);
d461 1
a461 1
	strncpy(rp[0].c.c_name, obj_list.names[idx].dest[i], NAMESIZE);
d514 1
a514 1
	    tree->tr_l.tl_name = bu_strdup(obj_list.names[index_in_list(obj_list,buf)].dest[idx]);
d545 2
a546 2
	    name = get_name(_dbip, db_lookup(_dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET), state, i);
	strncpy(obj_list.names[idx].dest[i], name, NAMESIZE);
d727 1
a727 1
	    av[1] = obj_list.names[idx].dest[i];
d738 1
a738 1
	    bu_free((char *)obj_list.names[i].dest[j], "free dest[j]");
d1024 1
a1024 1
	strcpy(links[(i-arg)/2].name, argv[i]);
d1137 1
a1137 1
	strcpy(vargs[1], links[j].name);
d1150 1
a1150 1
	    dps[i] = db_lookup(dbip, links[i].name, LOOKUP_QUIET);
@


1.34
log
@minor simplification
@
text
@a177 2


d331 1
a331 4
    register struct directory *dp = (struct directory *)NULL;
    int i, ret;
    char *argv[6] = {"wdb_copy", (char *)NULL, (char *)NULL, (char *)NULL, (char *)NULL, (char *)NULL};
    struct rt_db_internal intern;
d354 5
a358 1
	const char *name = (const char *)NULL;
d490 33
a529 1
    union record *rp = (union record *)NULL;
d531 1
a531 1
    int i, j;
a538 4
    /* XXX still non-functional, but closer */
    bu_log("ERROR: clone v5 IMPLEMENTATION INCOMPLETE, ABORTING\n");
    return (struct directory *)NULL;

d549 23
a571 3
	    const char*fromto[4] = {"wdb_copy", proto->d_namep, name, (const char*)NULL};
	    j = wdb_copy_cmd(_dbip->dbi_wdbp, NULL, 3, (char**)fromto);
	    if (j == TCL_ERROR) {
d573 1
a573 1
		return (struct directory *)NULL;
d575 1
a585 1

@


1.33
log
@pass a pointer instead of copying the string to stack
@
text
@a178 14
/**
 * returns truthfully if 'name' exists in the list
 */
static int
is_in_list(struct nametbl l, char *name)
{
    int i;

    for (i = 0; i < l.names_used; i++)
	if (!strcmp(l.names[i].src, name))
	    return 1;
    return 0;
}

d195 8
@


1.32
log
@Display all newly generated objects, not just the first. Autoview after display.
@
text
@d157 1
a157 1
add_to_list(struct nametbl *l, char name[NAMESIZE])
d183 1
a183 1
is_in_list(struct nametbl l, char name[NAMESIZE])
d199 1
a199 1
index_in_list(struct nametbl l, char name[NAMESIZE])
@


1.31
log
@rotation on v5 primivites
@
text
@d31 1
d684 1
a684 1
	for (i = 0; i < (state->n_copies > obj_list.names_used ? obj_list.names_used : state->n_copies) ; i++) {
d689 2
@


1.30
log
@Fixed a bug with funky matrix manipulation. Fixed a bug with the old object
being written with the new matrix applied.
@
text
@d347 1
d356 4
@


1.29
log
@minor cleanup
@
text
@d345 12
a373 1
	bu_free((char *)name, "free get_name() name");
d381 3
a383 13

	/* mirror */
	if (state->miraxis != W) {
	}

	/* translate */
	if (state->trans[W])
	    MAT_DELTAS_ADD_VEC(matrix, state->trans);

	/* rotation */
	if (state->rot[W]) {
	}

@


1.28
log
@pad out multi-line and doxygen comments
@
text
@d143 1
a143 1
	for (j = 0; j < s; j++) {
a144 1
	}
d169 1
a169 1
	    for (j = 0; j < l->name_size; j++) {
a170 1
	    }
d186 2
a187 2
    for (i = 0; i < l.names_used; i++) {
	if (!strcmp(l.names[i].src, name)) {
a188 2
	}
    }
d202 2
a203 2
    for (i = 0; i < l.names_used; i++) {
	if (!strcmp(l.names[i].src, name)) {
a204 2
	}
    }
d219 1
a219 1
    int num = 0, i, j;
d221 1
a221 1
    if (!newname) {
a222 1
    }
d225 1
a225 2
    i = 1;
    if ((dp->d_flags & DIR_SOLID) || (dp->d_flags & DIR_REGION)) {
d228 1
a228 2
	    if (suffix[0] == '.') {

d233 1
a233 1
		} else {
d235 1
a235 2
		}
	    } else {
a236 1
	    }
d239 1
a239 1
    } else {
a244 1
    }
d264 1
a264 1
	if (i==0) {
d266 1
a266 1
	} else {
a267 1
	}
d291 1
a291 1
		for (j = 3+state->miraxis; j < 24; j++) {
a292 1
		}
d295 1
a295 1
	    if (state->trans[W]) {
a297 1
	    }
d303 1
a303 1
		if (state->rpnt[W]) {
a304 1
		}
d312 1
a312 1
		if (state->rpnt[W]) {
a313 1
		}
d315 1
a315 1
	} else {
a316 1
	}
a322 1

d324 1
a324 1
    if (rp) {
a325 1
    }
d349 1
a349 1
	if (i==0) {
d351 1
a351 1
	} else {
a352 1
	}
d356 1
d360 1
a360 1
	if (ret != TCL_OK) {
a361 1
	}
d364 6
a369 2
	/* XXX incomplete, still needs transformation matrix */
	bu_log("WARNING: clone incomplete -- no transfomation matrix is applied\n");
a372 1
	    /* matrix[state->miraxis * ELEMENTS_PER_PLANE] += 2 * (state->mirpos - */
d374 1
d376 1
a376 1
	if (state->trans[W]) {
d378 1
a378 1
	}
d383 2
a384 2
	/* apply transformations on object */
	if (rt_db_get_internal(&intern, dp, _dbip, matrix, &rt_uniresource) < 0) {
a385 8
	    return;
	}
	RT_CK_DB_INTERNAL(&intern);
	if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0) {
	    bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
	    rt_db_free_internal(&intern, &rt_uniresource);
	    return;
	}
d416 1
a416 1
    if (_dbip->dbi_version < 5) {
d418 1
a418 1
    } else {
a419 2
    }

d453 1
a453 1
	    if (i==0) {
d455 1
a455 1
	    } else {
a456 1
	    }
d513 1
a513 1
	if (i==0) {
d515 1
a515 1
	} else {
a516 1
	}
d561 1
a561 1
    if (_dbip->dbi_version < 5) {
d563 1
a563 1
    } else {
a564 1
    }
d623 1
a623 1
	} else {
a624 1

d626 1
a626 3
	}

    } else if (dp->d_flags & DIR_SOLID) {
d629 1
a629 1
    } else {
d635 1
a635 1
    if (strcmp(copyname, nextname) == 0) {
d637 1
a637 1
    } else {
a638 1
    }
d641 1
a641 1
    if (rp) {
d643 1
a643 2
    }
    if (copyname) {
d645 1
a645 2
    }
    if (nextname) {
a646 1
    }
d669 1
a669 1
    if (!copy || !is_in_list(obj_list, state->src->d_namep)) {
a670 1
    }
d686 1
a686 1
	for (j = 0; j < obj_list.name_size; j++) {
a687 1
	}
d813 1
a813 1
    if (!argv[bu_optind]) {
a814 1
    }
d840 1
a840 1
    if( setjmp( jmp_env ) == 0 ) {
d842 1
a842 1
    } else {
a843 1
    }
d851 1
a851 1
    if (get_args(interp, argc, argv, &state) == TCL_ERROR) {
a852 1
    }
d874 1
a874 1
    if (t == spl.t[spl.n_segs]) {
a875 1
    }
d878 1
a878 1
    while (t >= spl.t[i+1]) {
a879 1
    }
d915 1
a915 1
    if( setjmp( jmp_env ) == 0 ) {
d917 1
a917 1
    } else {
a918 1
    }
d921 1
a921 1
    while ((i = bu_getopt(argc, argv, "fh")) != EOF) {
a937 1
    }
d974 1
a974 1
	if (argc > arg+1) {
d976 1
a976 1
	} else {
a977 1
	}
d980 1
a980 1
    if (totlen != 1.0) {
a981 2
    }

d984 1
a984 1
    do {
d986 1
a986 1
    } while (strcmp(strtok(line, ","), "112") != 0);
d1004 1
a1004 1
    for (i = 0; i <= s.n_segs; i++) {
a1016 1
    }
d1021 1
a1021 1
    for (i = 0; i < s.n_segs; i++) { /* determine initial track length */
a1022 1
    }
d1030 1
a1030 1
	for (j = 0; j < n_links; j++) { /* set length of each link based on current track length */
a1031 1
	}
d1036 1
a1036 1
	for (j = 0; j < n_verts+1; j++) { /* around the track once */
a1056 1
	}
d1060 1
a1060 1
	for (j = 0; j < n_verts*n_links-1; j++) {
a1061 1
	}
d1069 1
a1069 1
    for (i = 0; i < n_links; i++) {
a1070 1
    }
d1082 1
a1082 1
	for (i = 0; i < 2; i++) {
a1083 1
	}
d1096 1
a1096 1
	/*		rots = (vect_t *)bu_malloc(sizeof(vect_t)*n_links, "alloc rots");*/
d1100 1
a1100 1
	    /*			VSET(rots[i], 0,0,0);*/
d1103 1
a1103 1
	for (i = 0; i < n_verts-1; i++) {
d1107 1
a1107 1
		} else {
a1108 1
		}
d1115 4
a1118 3
		/*				VSUB2(state.rot, state.rot, rots[j]);
						VADD2(rots[j], state.rot, rots[j]);*/

d1124 1
a1124 1
		/*				strcpy(vargs[1], obj_list.names[index_in_list(obj_list, links[j].name)].dest[0]);*/
a1135 1
	}
d1137 1
a1137 1
	for (i = 0; i < 2; i++) {
a1138 1
	}
@


1.27
log
@change c++/c99 "//" comments to more portable c89 /* */ comments
@
text
@d60 2
a61 1
/* NOTE: in order to not shadow the global "dbip" pointer used
d69 3
a71 2
/** state structure used to keep track of what actions the user
 *  requested and values necessary to perform the cloning operation.
d93 4
a96 3
/** structure used to store the names of objects that are to be
 *  cloned.  space is preallocated via names with len and used keeping
 *  track of space available and used.
d107 3
a109 1
/** a polynamial value for representing knots */
d115 2
a116 1
/** a spline path with various segments, break points, and polynamial
d132 3
a134 1
/** initialize the name list used for stashing destination names */
d153 3
a155 1
/** add a new name to the name list */
d161 2
a162 1
    /* add more slots if adding 1 more new name will fill up all the
d180 3
a182 1
/** returns truthfully if 'name' exists in the list */
d197 2
a198 1
/** returns the location of 'name' in the list if it exists, returns
d215 2
a216 1
/** returns the next available/unused name, using a consistent naming
d261 3
a263 2
/** make a copy of a v4 solid by adding it to our book-keeping list,
 *  adding it to the db directory, and writing it out to disk.
d351 3
a353 2
/** make a copy of a v5 solid by adding it to our book-keeping list,
 *  adding it to the db directory, and writing it out to disk.
d418 4
a421 3
/** make n copies of a database combination by adding it to our
 *  book-keeping list, adding it to the directory, then writing it out
 *  to the db.
d451 2
a452 1
/** make n copies of a v4 combination.
d518 2
a519 1
/** make n copies of a v5 combination.
d567 4
a570 3
/** make n copies of a database combination by adding it to our
 *  book-keeping list, adding it to the directory, then writing it out
 *  to the db.
d600 3
a602 1
/** recursively copy a tree of geometry */
d630 2
a631 1
	    /* if it is a combination/region, copy the objects that
d689 3
a691 2
/** copy an object, recursivley copying all of the object's contents
 *  if it's a combination/region.
d739 3
a741 1
/** how to use clone.  blissfully simple interface. */
d761 3
a763 2
/** process the user-provided arguments. stash their operations into
 *  our state structure.
d871 3
a873 1
/** master hook function for the 'clone' command. */
d904 2
a905 1
/** helper function that computes where a point is along a spline
d936 3
a938 2
/** master hook function for the 'tracker' command used to create
 *  copies of objects along a spline path.
@


1.26
log
@removed trailing whitespace
@
text
@d373 1
a373 1
	    //	    matrix[state->miraxis * ELEMENTS_PER_PLANE] += 2 * (state->mirpos -
@


1.25
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d373 1
a373 1
	    //	    matrix[state->miraxis * ELEMENTS_PER_PLANE] += 2 * (state->mirpos - 
d396 1
a396 1
    
@


1.25.2.1
log
@merge of V5 implementation from HEAD
@
text
@a30 1
 *      Erik Greenwald (v5)
d60 1
a60 2
/*
 * NOTE: in order to not shadow the global "dbip" pointer used
d68 2
a69 3
/**
 * state structure used to keep track of what actions the user
 * requested and values necessary to perform the cloning operation.
d85 1
d87 2
a88 2
    struct bu_vls src;		/* source object name */
    struct bu_vls *dest;	/* dest object names */
d91 3
a93 4
/**
 * structure used to store the names of objects that are to be
 * cloned.  space is preallocated via names with len and used keeping
 * track of space available and used.
d104 1
a104 3
/**
 * a polynamial value for representing knots
 */
d110 1
a110 2
/**
 * a spline path with various segments, break points, and polynamial
d120 1
a120 1
    struct bu_vls name;
d126 1
a126 3
/**
 * initialize the name list used for stashing destination names
 */
d134 4
a137 4
	bu_vls_init(&l->names[i].src);
	l->names[i].dest = (struct bu_vls *)bu_calloc(s, sizeof(struct bu_vls), "alloc l->names.dest");
	for (j = 0; j < s; j++)
	    bu_vls_init(&l->names[i].dest[j]);
d145 1
a145 3
/**
 * add a new name to the name list
 */
d147 1
a147 1
add_to_list(struct nametbl *l, char *name)
d151 1
a151 2
    /*
     * add more slots if adding 1 more new name will fill up all the
d158 4
a161 4
	    bu_vls_init(&l->names[i].src);
	    l->names[i].dest = (struct bu_vls *)bu_calloc(l->name_size,sizeof(struct bu_vls), "alloc l->names.dest");
	    for (j = 0; j < l->name_size; j++)
		bu_vls_init(&l->names[i].dest[j]);
d164 1
a164 1
    bu_vls_strcpy(&l->names[l->names_used++].src, name);
d168 17
a184 2
/**
 * returns the location of 'name' in the list if it exists, returns
d188 1
a188 1
index_in_list(struct nametbl l, char *name)
d192 2
a193 2
    for (i = 0; i < l.names_used; i++)
	if (!strcmp(bu_vls_addr(&l.names[i].src), name))
d195 2
a199 8
/**
 * returns truthfully if 'name' exists in the list
 */
static int
is_in_list(struct nametbl l, char *name)
{
    return index_in_list(l,name) != -1;
}
d201 1
a201 2
/**
 * returns the next available/unused name, using a consistent naming
d210 1
a210 1
    int num = 0, i = 1, j;
d212 1
a212 1
    if (!newname)
d214 1
d217 2
a218 1
    if ((dp->d_flags & DIR_SOLID) || (dp->d_flags & DIR_REGION))
d221 2
a222 1
	    if (suffix[0] == '.')
d227 1
a227 1
		} else
d229 2
a230 1
	    else
d232 1
d235 1
a235 1
    else
d241 1
d246 2
a247 3
/**
 * make a copy of a v4 solid by adding it to our book-keeping list,
 * adding it to the db directory, and writing it out to disk.
d260 1
a260 1
	if (i==0)
d262 4
a265 3
	else
	    name = get_name(_dbip, db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET), state, i);
	bu_vls_strcpy(&obj_list.names[idx].dest[i], name);
d269 1
a269 1
	dp = db_diradd(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i]), RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, &proto->d_minor_type);
d288 1
a288 1
		for (j = 3+state->miraxis; j < 24; j++)
d290 1
d293 1
a293 1
	    if (state->trans[W])
d296 1
d302 1
a302 1
		if (state->rpnt[W])
d304 1
d312 1
a312 1
		if (state->rpnt[W])
d314 1
d316 1
a316 1
	} else
d318 1
d325 1
d327 1
a327 1
    if (rp)
d329 1
d335 2
a336 3
/**
 * make a copy of a v5 solid by adding it to our book-keeping list,
 * adding it to the db directory, and writing it out to disk.
d341 4
a344 1
    int i;
a347 17
    /* mirror */
    if (state->miraxis != W) {
	bu_log("WARNING: mirroring not implemented!");
    }

    /* translate */
    if (state->trans[W])
	MAT_DELTAS_ADD_VEC(matrix, state->trans);

    /* rotation */
    if (state->rot[W]) {
    	mat_t m2, t;
	bn_mat_angles(m2, state->rot[X], state->rot[Y], state->rot[Z]);
	bn_mat_mul(t, matrix, m2);
	MAT_COPY(matrix, t);
    }

d350 1
a350 5
	char *argv[6] = {"wdb_copy", (char *)NULL, (char *)NULL, (char *)NULL, (char *)NULL, (char *)NULL};
	const char *name = (char *)NULL;
	int ret;
	register struct directory *dp = (struct directory *)NULL;
	struct rt_db_internal intern;
d352 1
a352 1
	if (i==0)
d354 3
a356 2
	else
	    dp = db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET);
d358 1
a358 1
	bu_vls_strcpy(&obj_list.names[idx].dest[i], name);
a359 1
	/* actually copy the primitive to the new name */
d363 1
a363 1
	if (ret != TCL_OK)
d365 17
d383 1
a383 1
	/* get the original objects matrix */
d389 1
a389 5
	/* pull the new name */
	dp = db_lookup(_dbip, name, LOOKUP_QUIET);
	bu_free((char *)name, "free get_name() name");
	/* write the new matrix to the new object */
	if (rt_db_put_internal(dp, wdbp->dbip, &intern, &rt_uniresource) < 0)
d391 3
d396 1
a396 1

d401 3
a403 4
/**
 * make n copies of a database combination by adding it to our
 * book-keeping list, adding it to the directory, then writing it out
 * to the db.
d423 1
a423 1
    if (_dbip->dbi_version < 5)
d425 1
a425 1
    else
d427 2
d433 1
a433 2
/**
 * make n copies of a v4 combination.
d456 1
a456 1
	    bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(&obj_list.names[index_in_list(obj_list, rp[1].M.m_instname)].dest[i]));
d458 1
a458 1
	    *bu_vls_addr(&obj_list.names[idx].dest[i]) = 'r';
d461 1
a461 1
	    if (i==0)
d463 4
a466 3
	    else
		name = get_name(_dbip, db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET), state, i);
	    bu_vls_strcpy(&obj_list.names[idx].dest[i], name);
d469 1
a469 1
	strncpy(rp[0].c.c_name, bu_vls_addr(&obj_list.names[idx].dest[i]), NAMESIZE);
d499 1
a499 35
/*
 * update the v5 combination tree with the new names.
 * DESTRUCTIVE RECURSIVE
 */
int
copy_v5_comb_tree(union tree *tree, int idx)
{
    char *buf;
    switch(tree->tr_op){
	case OP_UNION:
	case OP_INTERSECT:
	case OP_SUBTRACT:
	case OP_XOR:
	    /* copy right */
	    copy_v5_comb_tree(tree->tr_b.tb_right, idx);
	case OP_NOT:
	case OP_GUARD:
	case OP_XNOP:
	    /* copy left */
	    copy_v5_comb_tree(tree->tr_b.tb_left, idx);
	    break;
	case OP_DB_LEAF:
	    buf = tree->tr_l.tl_name;
	    tree->tr_l.tl_name = bu_strdup(bu_vls_addr(&obj_list.names[index_in_list(obj_list,buf)].dest[idx]));
	    bu_free(buf, "node name");
	    break;
	default:
	    bu_log("clone v5 - OPCODE NOT IMPLEMENTED: %d\n", tree->tr_op);
	    return -1;
    }
    return 0;
}

/**
 * make n copies of a v5 combination.
d505 1
d507 1
a507 1
    int i;
d515 4
d521 1
a521 1
	if (i==0)
d523 4
a526 3
	else
	    name = get_name(_dbip, db_lookup(_dbip, bu_vls_addr(&obj_list.names[idx].dest[i-1]), LOOKUP_QUIET), state, i);
	bu_vls_strcpy(&obj_list.names[idx].dest[i], name);
d530 3
a532 5
	    struct rt_db_internal dbintern;
	    struct rt_comb_internal *comb;

	    dp = db_lookup(_dbip, proto->d_namep, LOOKUP_QUIET);
	    if (rt_db_get_internal(&dbintern, dp, _dbip, bn_mat_identity, &rt_uniresource) < 0) {
d534 1
a534 1
		return NULL;
a535 19

	    if ((dp=db_diradd(wdbp->dbip, name, -1, 0, proto->d_flags, (genptr_t)&proto->d_minor_type)) == DIR_NULL ) {
		bu_log("An error has occured while adding a new object to the database.");
		return NULL;
	    }

	    RT_CK_DB_INTERNAL(&dbintern);
	    comb = (struct rt_comb_internal *)dbintern.idb_ptr;
	    RT_CK_COMB(comb);
	    RT_CK_TREE(comb->tree);

	    /* recursively update the tree */
	    copy_v5_comb_tree(comb->tree, i);

	    if (rt_db_put_internal(dp, wdbp->dbip, &dbintern, &rt_uniresource) < 0) {
		bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
		return NULL;
	    }
	    rt_db_free_internal(&dbintern, &rt_uniresource);
d546 4
a549 4
/**
 * make n copies of a database combination by adding it to our
 * book-keeping list, adding it to the directory, then writing it out
 * to the db.
d569 1
a569 1
    if (_dbip->dbi_version < 5)
d571 1
a571 1
    else
d573 1
d579 1
a579 3
/**
 * recursively copy a tree of geometry
 */
d607 1
a607 2
	    /*
	     * if it is a combination/region, copy the objects that
d629 1
a629 1
	} else
d631 1
d633 3
a635 1
    } else if (dp->d_flags & DIR_SOLID)
d638 1
a638 1
    else {
d644 1
a644 1
    if (strcmp(copyname, nextname) == 0)
d646 1
a646 1
    else
d648 1
d651 1
a651 1
    if (rp)
d653 2
a654 1
    if (copyname)
d656 2
a657 1
    if (nextname)
d659 1
d665 2
a666 3
/**
 * copy an object, recursivley copying all of the object's contents
 * if it's a combination/region.
d681 1
a681 1
    if (!copy || !is_in_list(obj_list, state->src->d_namep))
d683 1
d690 2
a691 2
	for (i = 0; i < (state->n_copies > obj_list.name_size ? obj_list.name_size : state->n_copies) ; i++) {
	    av[1] = bu_vls_addr(&obj_list.names[idx].dest[i]);
a694 2
	av[0] = "autoview";
	cmd_autoview((ClientData)NULL, INTERP, 1, av);
d699 3
a701 2
	for (j = 0; j < obj_list.name_size; j++)
	    bu_vls_free(&obj_list.names[i].dest[j]);
d714 1
a714 3
/**
 * how to use clone.  blissfully simple interface.
 */
d734 2
a735 3
/**
 * process the user-provided arguments. stash their operations into
 * our state structure.
d824 1
a824 1
    if (!argv[bu_optind])
d826 1
d843 1
a843 3
/**
 * master hook function for the 'clone' command.
 */
d850 1
a850 1
    if( setjmp( jmp_env ) == 0 )
d852 1
a852 1
    else
d854 1
d862 1
a862 1
    if (get_args(interp, argc, argv, &state) == TCL_ERROR)
d864 1
d874 1
a874 2
/**
 * helper function that computes where a point is along a spline
d885 1
a885 1
    if (t == spl.t[spl.n_segs])
d887 1
d890 1
a890 1
    while (t >= spl.t[i+1])
d892 1
d905 2
a906 3
/**
 * master hook function for the 'tracker' command used to create
 * copies of objects along a spline path.
d927 1
a927 1
    if( setjmp( jmp_env ) == 0 )
d929 1
a929 1
    else
d931 1
d934 1
a934 1
    while ((i = bu_getopt(argc, argv, "fh")) != EOF)
d951 1
d987 2
a988 2
	bu_vls_strcpy(&links[(i-arg)/2].name, argv[i]);
	if (argc > arg+1)
d990 1
a990 1
	else
d992 1
d995 1
a995 1
    if (totlen != 1.0)
d997 2
d1001 1
a1001 1
    do
d1003 1
a1003 1
    while (strcmp(strtok(line, ","), "112") != 0);
d1021 1
a1021 1
    for (i = 0; i <= s.n_segs; i++)
d1034 1
d1039 1
a1039 1
    for (i = 0; i < s.n_segs; i++) /* determine initial track length */
d1041 1
d1049 1
a1049 1
	for (j = 0; j < n_links; j++) /* set length of each link based on current track length */
d1051 1
d1056 1
a1056 1
	for (j = 0; j < n_verts+1; j++) /* around the track once */
d1077 1
d1081 1
a1081 1
	for (j = 0; j < n_verts*n_links-1; j++)
d1083 1
d1091 1
a1091 1
    for (i = 0; i < n_links; i++)
d1093 1
d1105 1
a1105 1
	for (i = 0; i < 2; i++)
d1107 1
d1110 1
a1110 1
	strcpy(vargs[1], bu_vls_addr(&links[j].name));
d1120 1
a1120 1
	/* rots = (vect_t *)bu_malloc(sizeof(vect_t)*n_links, "alloc rots");*/
d1123 2
a1124 2
	    dps[i] = db_lookup(dbip, bu_vls_addr(&links[i].name), LOOKUP_QUIET);
	    /* VSET(rots[i], 0,0,0);*/
d1127 1
a1127 1
	for (i = 0; i < n_verts-1; i++)
d1131 1
a1131 1
		} else
d1133 1
d1140 3
a1142 4
		/*
		VSUB2(state.rot, state.rot, rots[j]);
		VADD2(rots[j], state.rot, rots[j]);
		*/
d1148 1
a1148 1
		/* strcpy(vargs[1], obj_list.names[index_in_list(obj_list, links[j].name)].dest[0]);*/
d1160 1
d1162 1
a1162 1
	for (i = 0; i < 2; i++)
d1164 1
@


1.25.2.2
log
@MFC
@
text
@a84 2
    int			autoview;	/* Execute autoview after drawing all objects */
    int			updpos;		/* Position of number to update (for -c) */
d131 1
d152 1
d208 1
a208 1
static struct bu_vls *
d211 28
a238 39
    struct bu_vls *newname;
    char prefix[BUFSIZ] = {0}, suffix[BUFSIZ] = {0}, buf[BUFSIZ] = {0}, suffix2[BUFSIZ] = {0};
    int num = 0, i = 1, j = 0;

    newname = bu_vls_vlsinit();

    /* Ugh. This needs much repair/cleanup. */
    if( state->updpos == 0 ) {
	sscanf(dp->d_namep, "%[!-/,:-~]%d%[!-/,:-~]%s", &prefix, &num, &suffix, &suffix2);
	strncat(suffix, suffix2, BUFSIZ);
    } else if ( state->updpos == 1 ) {
	int num2 = 0;
	sscanf(dp->d_namep, "%[!-/,:-~]%d%[!-/,:-~]%d%[!-/,:-~]", &prefix, &num2, &suffix2, &num, &suffix);
	snprintf(prefix, BUFSIZ, "%s%d%s", prefix, num2, suffix2);
    } else
	bu_bomb("multiple -c options not supported yet.");

    do {
	/* choke the name back to the prefix */
	bu_vls_trunc(newname, 0);
	bu_vls_strcpy(newname, prefix);

        if ((dp->d_flags & DIR_SOLID) || (dp->d_flags & DIR_REGION)) {
    	/* primitives and regions */
    	    if (suffix[0] != 0)
    		if ((i == 1) && is_in_list(obj_list, buf)) {
    		    j = index_in_list(obj_list, buf);
    		    snprintf(buf, BUFSIZ, "%s%d", prefix, num);	/* save the name for the next pass */
		    /* clear and set the name */
		    bu_vls_trunc(newname, 0);
		    bu_vls_printf(newname, "%s%s", obj_list.names[j].dest[iter], suffix);
    		} else
		    bu_vls_printf(newname, "%d%s", num+i*state->incr, suffix);
    	    else
    		bu_vls_printf(newname, "%d", num + i*state->incr);
	} else /* non-region combinations */
    	    bu_vls_printf(newname, "%d", (num==0)?2:num+i);
	i++;
    } while (db_lookup(_dbip, bu_vls_addr(newname), LOOKUP_QUIET) != NULL);
d242 1
d256 1
a256 1
	struct bu_vls *name;
d262 2
a263 4

	/* XXX: this can probably be optimized. */
	bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(name));
	bu_vls_free(name);
d279 1
a279 1
	    strncpy(rp->s.s_name, dp->d_namep, BUFSIZ);
d324 1
d356 1
a356 1
	struct bu_vls *name;
a364 1

d366 1
a366 1
	bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(name));
d370 1
a370 1
	argv[2] = bu_vls_addr(name);
a377 1
	    bu_vls_free(name);
d382 2
a383 2
	dp = db_lookup(_dbip, bu_vls_addr(name), LOOKUP_QUIET);
	bu_vls_free(name);
d393 1
d424 1
d453 1
a453 1
	    struct bu_vls *name;
d458 2
a459 2
	    bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(name));
	    bu_vls_free(name);
d461 1
a461 1
	strncpy(rp[0].c.c_name, bu_vls_addr(&obj_list.names[idx].dest[i]), BUFSIZ);
d475 1
a475 1
	    snprintf(rp[j].M.m_instname, BUFSIZ, "%s", obj_list.names[index_in_list(obj_list, rp[j].M.m_instname)].dest[i]);
d531 1
a531 1
    struct bu_vls *name;
d546 1
a546 1
	bu_vls_strcpy(&obj_list.names[idx].dest[i], bu_vls_addr(name));
d549 1
a549 1
	if (proto->d_namep && bu_vls_addr(name)) {
d559 1
a559 1
	    if ((dp=db_diradd(wdbp->dbip, bu_vls_addr(name), -1, 0, proto->d_flags, (genptr_t)&proto->d_minor_type)) == DIR_NULL ) {
a573 1
		bu_vls_free(name);
a575 1
	    bu_vls_free(name);
d580 2
a581 1
	bu_vls_free(name);
d618 1
d630 2
a631 2
    struct bu_vls *copyname;
    struct bu_vls *nextname;
d684 1
a684 1
    if (bu_vls_strcmp(copyname, nextname) == 0)
d687 1
a687 1
	copy = db_lookup(_dbip, bu_vls_addr(copyname), LOOKUP_QUIET);
d700 1
d731 2
a732 4
	if(state->autoview) {
	    av[0] = "autoview";
	    cmd_autoview((ClientData)NULL, INTERP, 1, av);
	}
d750 1
a759 1
    Tcl_AppendResult(interp, "-c\t\t\t- Increment the second number in object names.\n", (char *)NULL);
a760 1
    Tcl_AppendResult(interp, "-g\t\t\t- Don't resize the view after drawing new objects.\n", (char *)NULL);
d772 1
a787 1
    state->autoview = 1;
d792 1
a792 2
    state->updpos = 0;
    while ((k = bu_getopt(argc, argv, "a:b:cfhgi:m:n:p:r:t:v")) != EOF) {
a807 8
	    case 'c':
		/* I'd like to have an optional argument to -c, but for now,
		 * just let multiple -c's add it up as a hack. I believe the
		 * variant of this that was lost used this as a binary
		 * operation, so it SHOULD be functionally equivelant for a user
		 * who's dealt with this before. */
		state->updpos++;
		break;
a810 3
	    case 'g':
		state->autoview = 0;
		break;
d881 1
d912 1
d942 1
d1134 1
a1134 1
	    vargs[i] = (char *)bu_malloc(sizeof(char)*BUFSIZ, "alloc vargs1");
@


1.25.2.3
log
@back out the bu_vls_strcmp() macro as STABLE bu.h trails... a lot...
@
text
@d695 1
a695 1
    if (strcmp(bu_vls_addr(copyname), bu_vls_addr(nextname)) == 0)
@


1.24
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d305 2
a306 2
		mat_idn(r);
		mat_angles(r, state->rot[X], state->rot[Y], state->rot[Z]);
@


1.23
log
@one step closer, stub out the matrix transformation on solids
@
text
@d1002 1
a1002 1
	fgets(line, 81, points);
d1015 2
a1016 2
	    fgets(line, 81, points);
	    fgets(line, 81, points);
d1026 2
a1027 2
		    fgets(line, 81, points);
		    fgets(line, 81, points);
@


1.22
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d283 2
d286 1
d288 1
a288 1
		for (j = 3+state->miraxis; i < 24; i++) {
d292 1
d294 1
d297 1
d307 2
a308 2
		for (i = 0; i < 24; i+=3) {
		    VMOVE(vec, rp->s.s_values+i);
d310 1
a310 1
		    VMOVE(rp->s.s_values+i, ovec);
d343 4
a346 1
    char *argv[4] = {"wdb_copy", (char *)NULL, (char *)NULL, (char *)NULL};
d353 1
a353 1
	    name = get_name(_dbip, proto, state, i);
d355 1
a355 1
	    name = get_name(_dbip, db_lookup(_dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET), state, i);
d357 1
d368 4
a371 2
	/* !!! still need to apply transformation matrix */
#if 0
d373 1
a373 4
	    rp->s.s_values[state->miraxis] += 2 * (state->mirpos - rp->s.s_values[state->miraxis]);
	    for (j = 3+state->miraxis; i < 24; i++) {
		rp->s.s_values[j] = -rp->s.s_values[j];
	    }
d375 1
d377 1
a377 1
	    VADD2(rp->s.s_values, rp->s.s_values, state->trans);
d379 1
d381 1
a381 2
	    mat_t r;
	    vect_t vec, ovec;
d383 10
a392 13
	    if (state->rpnt[W]) {
		VSUB2(rp->s.s_values, rp->s.s_values, state->rpnt);
	    }
	    mat_idn(r);
	    mat_angles(r, state->rot[X], state->rot[Y], state->rot[Z]);
	    for (i = 0; i < 24; i+=3) {
		VMOVE(vec, rp->s.s_values+i);
		MAT4X3VEC(ovec, r, vec);
		VMOVE(rp->s.s_values+i, ovec);
	    }
	    if (state->rpnt[W]) {
		VADD2(rp->s.s_values, rp->s.s_values, state->rpnt);
	    }
d394 3
a396 3
#endif
    }

@


1.21
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d23 1
a23 1
 *	f_clone		clones an object, optionally 
d41 1
a41 1
  
d222 1
a222 1
		
d372 1
a372 1
	    
d389 1
a389 1
    
a425 1

d589 1
a589 1
	
d618 1
a618 1
	    } 
d820 1
a820 1
    
a1030 1

d1130 1
a1130 1
		VSET(state.rot, 0, (M_PI - atan2(pt[Z], pt[X])), 
d1136 1
a1136 1
					
@


1.20
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


1.19
log
@stub in initial details for copying a v5 combination object.  it's not functional yet, but this was a good breaking point.
@
text
@d4 1
a4 1
 * Copyright (c) 2005-2006 United States Government as represented by
@


1.18
log
@now makes n copies of a solid primitive, but does not yet apply a transformation matrix
@
text
@d353 1
a353 1
	ret = wdb_copy_cmd(_dbip->dbi_wdbp, state->interp, 3, argv);
d452 1
d501 1
d504 10
d516 20
a535 3
	/* not ready for v5 yet */
	bu_log("ERROR: UNIMPLEMENTED !!!\n");
	return (struct directory *)NULL;
@


1.17
log
@refactor the index
@
text
@d336 7
a342 2
    /* not ready for v5 yet */
    bu_log("ERROR: UNIMPLEMENTED !!!\n");
d344 47
@


1.16
log
@prepare for making v5 primitives, restore abort on v5 combinations.
@
text
@d251 1
a251 1
copy_v4_solid(struct db_i *_dbip, struct directory *proto, struct clone_state *state)
d255 1
a255 13
    int i, j, idx;

    if (is_in_list(obj_list, proto->d_namep)) {
	bu_log("Primitive solid %s already cloned?\n", proto->d_namep);
	return;
    }
    idx = add_to_list(&obj_list, proto->d_namep);

    /* sanity check that the item was really added */
    if ((idx < 0) || !is_in_list(obj_list, proto->d_namep)) {
	bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
	return;
    }
d334 1
a334 1
copy_v5_solid(struct db_i *_dbip, struct directory *proto, struct clone_state *state)
d350 2
d357 8
d366 1
a366 1
	(void)copy_v4_solid(_dbip, proto, (struct clone_state *)state);
d368 1
a368 1
	(void)copy_v5_solid(_dbip, proto, (struct clone_state *)state);
d379 1
a379 1
copy_v4_comb(struct db_i *_dbip, struct directory *proto, struct clone_state *state)
d383 1
a383 9
    int i, j, idx;

    idx = add_to_list(&obj_list, proto->d_namep);

    /* sanity check that the item was really added */
    if ((idx < 0) || !is_in_list(obj_list, proto->d_namep)) {
	bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
	return NULL;
    }
d444 1
a444 1
copy_v5_comb(struct db_i *_dbip, struct directory *proto, struct clone_state *state)
d448 1
a448 13
    int i, j, idx;

    if (is_in_list(obj_list, proto->d_namep)) {
	bu_log("Combination %s already cloned?\n", proto->d_namep);
	return NULL;
    }
    idx = add_to_list(&obj_list, proto->d_namep);

    /* sanity check that the item was really added */
    if ((idx < 0) || !is_in_list(obj_list, proto->d_namep)) {
	bu_log("ERROR: clone internal error copying %s\n", proto->d_namep);
	return NULL;
    }
d468 2
d475 8
d484 1
a484 1
	(void)copy_v4_comb(_dbip, proto, (struct clone_state *)state);
d486 1
a486 1
	(void)copy_v5_comb(_dbip, proto, (struct clone_state *)state);
@


1.15
log
@one step closer towards v5 database support, make function hooks match db_functree interface (last param wasn't genptr_t).  fix a memory leak related to get_name().  keep track of whether objects are correctly cloned via get_name lookups.
@
text
@d247 1
a247 1
/** make a copy of a solid by adding it to our book-keeping list,
d251 1
a251 1
copy_solid(struct db_i *_dbip, struct directory *proto, genptr_t genstate)
a255 1
    struct clone_state *state = (struct clone_state *)genstate;
a272 6
	/* get an in-memory reference to the object being copied */
	if ((rp = db_getmrec(_dbip, proto)) == (union record *)0) {
	    TCL_READ_ERR;
	    return;
	}

d287 7
d342 36
d474 3
a476 1
	/* !!! */
a489 2
    register struct directory *dp = (struct directory *)NULL;

a555 1
#if 0
a556 2
	    struct rt_db_internal in;
	    struct rt_comb_internal *comb = (struct rt_comb_internal *)NULL;
a557 6
	    if (rt_db_get_internal5( &in, dp, _dbip, NULL, NULL) < 0) {
		TCL_READ_ERR;
		goto done_copy_tree;
	    }
	    comb = (struct rt_comb_internal *)in.idb_ptr; /* got a copy of the combination */
#endif
a558 1
	    //	    rt_db_free_internal(&in, (struct resource *)NULL);
a607 1
	bu_log("ERROR: clone internal error, cannot find %s for editing\n", state->src->d_namep);
@


1.14
log
@ged.h declares is_dm_null() now, bump clone version in anticipation of getting it to work here shortly
@
text
@d30 2
a31 1
 *	Adam Ross
d35 4
d84 1
a84 1
#define INTERP state.interp
d201 4
a204 3
/** returns the next available/unused name, using a naming convention
 *  that increments a trailing or first embedded number.  state.incr
 *  is used for each number level increase.
d207 1
a207 1
get_name(struct db_i *_dbip, struct directory *dp, struct clone_state state, int iter)
d209 2
a210 2
    static char *newname = NULL;
    char tag[NAMESIZE] = {0}, post[NAMESIZE] = {0}, buf[NAMESIZE] = {0};
d216 1
a216 1
    sscanf(dp->d_namep, "%[!-/,:-~]%d%[!-/,:-~]", &tag, &num, &post);
d220 1
d222 1
a222 1
	    if (post[0] == '.') {
d226 2
a227 2
		    snprintf(buf, NAMESIZE, "%s%d", tag, num);
		    snprintf(newname, NAMESIZE, "%s%s", obj_list.names[j].dest[iter], post);
d229 1
a229 1
		    snprintf(newname, NAMESIZE, "%s%d%s", tag, num+i*state.incr, post);
d232 1
a232 1
		snprintf(newname, NAMESIZE, "%s%d", tag, num+i*state.incr);
d237 1
d239 1
a239 1
	    snprintf(newname, NAMESIZE, "%s%d", tag, (num==0)?2:num+i);
d247 2
a248 2
/** make a copy of a combination by adding it to our book-keeping list,
 *  adding it to the db directory, then writing it out to the db.
d250 2
a251 2
static struct directory *
copy_comb(struct db_i *_dbip, struct directory *proto, struct clone_state state)
d256 1
d259 77
a335 2
	bu_log("Combination %s already cloned?\n", proto->d_namep);
	return NULL;
d337 14
a358 1

d360 1
a360 1
    for (i = 0; i < state.n_copies; i++) {
d383 1
d408 2
a409 1
	bu_free((char *)rp, "copy_comb record[]");
d415 1
a415 3

/** make a copy of a solid by adding it to our book-keeping list,
 *  adding it to the db directory, and writing it out to disk.
d418 1
a418 1
copy_solid(struct db_i *_dbip, struct directory *proto, struct clone_state state)
d425 1
a425 1
	bu_log("Primitive solid %s already cloned?\n", proto->d_namep);
d437 3
a439 2
    for (i = 0; i < state.n_copies; i++) {
	const char *name = (const char *)NULL;
d441 2
a442 5
	/* get an in-memory reference to the object being copied */
	if ((rp = db_getmrec(_dbip, proto)) == (union record *)0) {
	    TCL_READ_ERR;
	    return NULL;
	}
a443 6
	if (i==0) {
	    name = get_name(_dbip, proto, state, i);
	} else {
	    name = get_name(_dbip, db_lookup(_dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET), state, i);
	}
	strncpy(obj_list.names[idx].dest[i], name, NAMESIZE);
d445 8
a452 20
	/* add the object to the directory */
	dp = db_diradd(_dbip, obj_list.names[idx].dest[i], RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, &proto->d_minor_type);
	if ((dp == DIR_NULL) || (db_alloc(_dbip, dp, proto->d_len) < 0)) {
	    TCL_ALLOC_ERR;
	    return NULL;
	}
	if (rp->u_id == ID_SOLID) {
	    strncpy(rp->s.s_name, dp->d_namep, NAMESIZE);
	    if (state.miraxis != W) {
		rp->s.s_values[state.miraxis] += 2 * (state.mirpos - rp->s.s_values[state.miraxis]);
		for (j = 3+state.miraxis; i < 24; i++) {
		    rp->s.s_values[j] = -rp->s.s_values[j];
		}
	    }
	    if (state.trans[W]) {
		VADD2(rp->s.s_values, rp->s.s_values, state.trans);
	    }
	    if (state.rot[W]) {
		mat_t r;
		vect_t vec, ovec;
d454 4
a457 23
		if (state.rpnt[W]) {
		    VSUB2(rp->s.s_values, rp->s.s_values, state.rpnt);
		}
		mat_idn(r);
		mat_angles(r, state.rot[X], state.rot[Y], state.rot[Z]);
		for (i = 0; i < 24; i+=3) {
		    VMOVE(vec, rp->s.s_values+i);
		    MAT4X3VEC(ovec, r, vec);
		    VMOVE(rp->s.s_values+i, ovec);
		}
		if (state.rpnt[W]) {
		    VADD2(rp->s.s_values, rp->s.s_values, state.rpnt);
		}
	    }
	} else {
	    bu_log("mods not available on %s\n", proto->d_namep);
	}

	/* write the object to disk */
	if (db_put(_dbip, dp, rp, 0, dp->d_len) < 0) {
	    bu_log("ERROR: clone internal error writing to the database\n");
	    return NULL;
	}
d459 4
a462 3
    }
    if (rp) {
	bu_free((char *)rp, "copy_solid record[]");
d465 1
a465 1
    return dp;
d471 1
a471 1
copy_tree(struct db_i *_dbip, struct directory *dp, struct resource *resp, struct clone_state state)
d478 6
d488 3
a490 1
	    /* A v4 method of getting the geometry */
d495 1
a495 1
		return NULL;
d497 3
a499 2
	    /* if it is a combination/region, recursively copy the objects
	       that make up the object */
d502 2
d507 4
d512 7
a518 1
	    
d520 2
a521 1
	    /* A v5 method of getting the geometry */
d527 1
a527 1
		return NULL;
d530 3
a532 3
	    Tcl_AppendResult(INTERP, "clone: command currently unimplemented for v5 geometry databases....proceeding by the seat of our pants\n");
	    //	    db_functree_subtree(_dbip, comb->tree, NULL /*comb_func*/, NULL /*leaf_func*/, (struct resource *)NULL, (ClientData)state);
	    rt_db_free_internal(&in, (struct resource *)NULL);
a534 2
	/* copy the combination itself */
	copy = copy_comb(_dbip, dp, state);
d537 1
a537 1
	copy = copy_solid(_dbip, dp, state);
d539 2
a540 1
	Tcl_AppendResult(INTERP, "clone:  ", dp->d_namep, " is neither COMB nor SOLID?\n", (char *)NULL);
d543 8
d554 7
d569 1
a569 1
copy_object(struct db_i *_dbip, struct resource *resp, struct clone_state state)
d575 1
a575 1
    init_list(&obj_list, state.n_copies);
d578 1
a578 1
    copy = copy_tree(_dbip, state.src, resp, state);
d581 2
a582 2
    if (!copy || !is_in_list(obj_list, state.src->d_namep)) {
	bu_log("ERROR: clone internal error, cannot find %s for editing\n", state.src->d_namep);
d587 1
a587 1
    if (state.draw_obj) {
d590 2
a591 2
	idx = index_in_list(obj_list, state.src->d_namep);
	for (i = 0; i < (state.n_copies > obj_list.names_used ? obj_list.names_used : state.n_copies) ; i++) {
d768 1
a768 1
    (void)copy_object(dbip, &rt_uniresource, state);
d1048 1
a1048 1
		dps[j] = copy_object(dbip, &rt_uniresource, state);
@


1.13
log
@one more restructuring step, this time propagating the dbip so that the copy_ functions have the right signature to be used as a db_functree callback.  instead of proliferating the usage of the dbip global pointer even further, only the top-level hook functions use the global then all other routines are using the one passed as an argument (denoted with _dbip instead of dbip to avoid shadowing).
@
text
@d48 1
d53 1
a53 3
#define CLONE_VERSION "Clone ver 3.0\n2005-12-12\n"

extern int is_dm_null(void);
@


1.12
log
@another restructuring step.  propagate a resource pointer for librt and don't pass around the tcl interpreter directly so that we can use thses functions directly as db_functree callbacks (instead stash the interp into our state client data structure).
@
text
@d57 8
d124 1
a124 1
void
d143 1
a143 1
int
d167 1
a167 1
int
d184 1
a184 1
int
a196 1

d201 2
a202 2
char *
get_name(struct directory *dp, struct clone_state state, int iter)
d229 1
a229 1
	} while (db_lookup(dbip, newname, LOOKUP_QUIET) != NULL);
d234 1
a234 1
	} while (db_lookup(dbip, newname, LOOKUP_QUIET) != NULL);
d244 1
a244 1
copy_comb(struct directory *proto, struct clone_state state)
d267 1
a267 1
	if ((rp = db_getmrec(dbip, proto)) == (union record *)0) {
d280 7
a286 1
	    strncpy(obj_list.names[idx].dest[i], get_name(((i==0) ? proto : db_lookup(dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET)), state, i), NAMESIZE);
d291 2
a292 2
	dp = db_diradd(dbip, rp->c.c_name, RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, &proto->d_minor_type);
	if ((dp == NULL) || (db_alloc(dbip, dp, proto->d_len) < 0)) {
d306 1
a306 1
	if (db_put(dbip, dp, rp, 0, dp->d_len) < 0) {
d322 1
a322 1
copy_solid(struct directory *proto, struct clone_state state)
d342 1
d345 1
a345 1
	if ((rp = db_getmrec(dbip, proto)) == (union record *)0) {
d350 6
a355 1
	strncpy(obj_list.names[idx].dest[i], get_name(((i==0) ? proto : db_lookup(dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET)), state, i), NAMESIZE);
d358 2
a359 2
	dp = db_diradd(dbip, obj_list.names[idx].dest[i], RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, &proto->d_minor_type);
	if ((dp == DIR_NULL) || (db_alloc(dbip, dp, proto->d_len) < 0)) {
d397 1
a397 1
	if (db_put(dbip, dp, rp, 0, dp->d_len) < 0) {
d413 1
a413 1
copy_tree(struct directory *dp, struct resource *resp, struct clone_state state)
d423 1
a423 1
	if (dbip->dbi_version < 5) {
d427 1
a427 1
	    if ((rp = db_getmrec(dbip, dp)) == (union record *)0) {
d434 1
a434 1
		if ((mdp = db_lookup(dbip, rp[i].M.m_instname, LOOKUP_NOISY)) == DIR_NULL) {
d437 1
a437 1
		copy = copy_tree(mdp, resp, state);
d445 1
a445 1
	    if (rt_db_get_internal5( &in, dp, dbip, NULL, NULL) < 0) {
d451 1
a451 1
	    //	    db_functree_subtree(dbip, comb->tree, NULL /*comb_func*/, NULL /*leaf_func*/, (struct resource *)NULL, (ClientData)state);
d456 1
a456 1
	copy = copy_comb(dp, state);
d459 1
a459 1
	copy = copy_solid(dp, state);
d475 1
a475 1
copy_object(struct resource *resp, struct clone_state state)
d484 1
a484 1
    copy = copy_tree(state.src, resp, state);
d635 1
a635 1
    /* we make sure the lookup succeeded in f_clone() */
d673 2
a674 2
    /* do it */
    (void)copy_object(&rt_uniresource, state);
d930 1
d953 2
a954 1
		dps[j] = copy_object(&rt_uniresource, state);
@


1.11
log
@begin efforts to port clone and tracker towards supporting v5 databases.  the db_getmrec() function and associated union records are v4 specific structures that don't apply to v5 so it basically needs to be reimplemented from scratch..  start by initializing all pointers to NULL and getting rid of the useless propagation of ClientData.
@
text
@d61 1
d72 1
d236 1
a236 1
struct directory *
d308 1
a308 1
struct directory *
d393 2
a394 2
struct directory *
copy_tree(Tcl_Interp *interp, struct clone_state state, struct directory *dp)
a403 1
	/* A v4 method of getting the geometry */
d405 2
d418 1
a418 1
		copy = copy_tree(interp, state, mdp);
d423 11
a433 1
	    Tcl_AppendResult(interp, "clone: command currently unimplemented for v5 geometry databases\n");
d442 1
a442 1
	Tcl_AppendResult(interp, "clone:  ", dp->d_namep, " is neither COMB nor SOLID?\n", (char *)NULL);
d455 2
a456 2
struct directory *
copy_object(Tcl_Interp *interp, struct clone_state state)
d465 1
a465 1
    copy = copy_tree(interp, state, state.src);
d481 1
a481 1
	    cmd_draw( (ClientData)NULL, interp, 2, av );
d532 1
d655 1
a655 1
    (void)copy_object(interp, state);
d902 1
d933 1
a933 1
		dps[j] = copy_object(interp, state);
@


1.10
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d237 2
a238 2
    register struct directory *dp;
    union record *rp;
d257 1
a257 1
	/* get an in-memory reference to the object being copied */
d309 2
a310 2
    register struct directory *dp;
    union record *rp;
d381 2
d392 1
a392 1
copy_tree(ClientData clientData, Tcl_Interp *interp, struct clone_state state, struct directory *dp)
d394 4
a397 9
    register union record   *rp;
    register int            i;
    register struct directory *mdp, *copy;

    /* get an in-memory record of this object */
    if ((rp = db_getmrec(dbip, dp)) == (union record *)0) {
	TCL_READ_ERR;
	return NULL;
    }
d401 7
a407 5
	/* if it is a combination/region, recursively copy the objects
	   that make up the object */
	for (i = 1; i < dp->d_len; i++ ) {
	    if ((mdp = db_lookup(dbip, rp[i].M.m_instname, LOOKUP_NOISY)) == DIR_NULL) {
		continue;
d409 12
a420 1
	    copy = copy_tree(clientData, interp, state, mdp);
d431 4
a434 1
    bu_free((char *)rp, "copy_tree record[]");
d443 1
a443 1
copy_object(ClientData clientData, Tcl_Interp *interp, struct clone_state state)
d445 2
a446 2
    struct directory *copy;
    struct nametbl *curr;
d452 1
a452 1
    copy = copy_tree(clientData, interp, state, state.src);
d467 2
a468 1
	    cmd_draw( clientData, interp, 2, av );
d491 1
a491 1
print_usage(ClientData clientData, Tcl_Interp *interp)
d513 1
a513 1
get_args(ClientData clientData, Tcl_Interp *interp, int argc, char **argv, struct clone_state *state)
d546 1
a546 1
		print_usage(clientData, interp);
d581 1
a581 1
		print_usage(clientData, interp);
d589 1
a589 1
	print_usage(clientData, interp);
d593 1
a593 1
	print_usage(clientData, interp);
d636 1
a636 1
    if (get_args(clientData, interp, argc, argv, &state) == TCL_ERROR) {
d641 1
a641 1
    (void)copy_object(clientData, interp, state);
d683 1
a683 5
f_tracker(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
d686 2
a687 2
    vect_t *verts;
    struct link *links;
d690 1
a690 1
    FILE *points;
d875 1
a875 1
	struct directory **dps;
d918 1
a918 1
		dps[j] = copy_object(clientData, interp, state);
@


1.9
log
@update to api changes from rt_* to bu_* for certain routines.
@
text
@d54 2
@


1.9.2.1
log
@update from HEAD
@
text
@a53 2
extern int is_dm_null(void);

@


1.8
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d294 1
a294 1
	rt_free((char *)rp, "copy_comb record[]");
d379 1
a379 1
	rt_free((char *)rp, "copy_solid record[]");
d419 1
a419 1
    rt_free((char *)rp, "copy_tree record[]");
@


1.7
log
@check clone args a little more consistently
@
text
@d38 1
@


1.6
log
@reuse VUNITIZE_TOL from vmath instead of something new
@
text
@d569 20
a588 4
    if (argv[bu_optind]) {
	/* XXX should make sure the lookup succeeded */
	state->src = db_lookup(dbip, argv[bu_optind], LOOKUP_QUIET);
    } else {
d623 2
a624 6
    /* do it (if we can) */
    if (state.src) {
	copy_object(clientData, interp, state);
    } else {
	Tcl_AppendResult(interp, "clone:  Cannot find source object\n", (char*)NULL);
    }
@


1.5
log
@update copyright to 2006
@
text
@a50 1
#define TOL 1E-12
d631 1
a631 1
	t -= TOL;
d796 1
a796 1
    for (i = 0; (fabs(olen-len) >= TOL) && (i < 250); i++) { /* number of track iterations */
d814 1
a814 1
		while (fabs(DIST_PT_PT(verts[n_links*j+k-1], pt) - dist_to_next) >= TOL) {
d823 1
a823 1
		    if (fabs(min-max) <= TOL) {break;}
@


1.4
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 2005 United States Government as represented by
@


1.3
log
@make sure the number of objects being displayed is not more than the number that were copied
@
text
@d48 1
@


1.2
log
@increment in steps of 100 instead of the previous 500 -- not likely to have 100 objects being cloned together; replace the dist function with the vmath.h DIST_PT_PT macro; add comments out the wazoo for what's going on; provide the correct minor_type for db_diradd(); add some sanity checks and debug printing; convert all the string manipulations to be strncmp, strncpy, etc (though they should be just bu_vls strings)
@
text
@d449 1
a449 1
	for (i = 0; i < state.n_copies; i++) {
@


1.1
log
@initial file.  adds initial support for the clone and tracker commands with
updates to the code applied for changes that have occurred over the
years.

these are the first of many contributions provided by the former GSI
with permission for inclusion in the open source release at last.  the
sources were found from an almost dead O2 external hard drive
enclosure.

thanks to Adam Ross for making the mods, to GSI for funding it and
ultimately returning the mods to the BRL-CAD community, and to Dwayne
Kregel for keeping up with the former GSI owners for permission and
with me to get the mods updated and added.
@
text
@d51 1
a51 1
#define CLONE_VERSION "Clone ver 2.0\n8-25-99\n"
d54 3
d69 1
d75 4
d88 1
d94 3
d110 1
d116 1
a116 1
    l->names = (struct name *)bu_malloc(sizeof(struct name)*10, "alloc l->names");
d118 1
a118 1
	l->names[i].dest = (char **)bu_malloc(sizeof(char *)*s, "alloc l->names.dest");
d120 1
a120 1
	    l->names[i].dest[j] = (char *)bu_malloc(sizeof(char)*NAMESIZE, "alloc l->names.desti");
d129 1
d135 3
d140 1
a140 1
	l->names = (struct name *)bu_realloc(l->names, sizeof(struct name)*(l->names_len+1), "realloc names");
d142 1
a142 1
	    l->names[i].dest = (char **)bu_malloc(sizeof(char *)*l->name_size, "alloc l->names.dest");
d144 1
a144 1
		l->names[i].dest[j] = (char *)bu_malloc(sizeof(char)*NAMESIZE, "alloc l->names.desti");
d148 2
a149 2
    strcpy(l->names[l->names_used++].src, name);
    return l->names_used-1;
d153 1
d161 17
d185 4
d193 1
a193 1
    char tag[NAMESIZE], post[NAMESIZE], buf[NAMESIZE];
d197 1
a197 1
	newname = (char *)bu_malloc(sizeof(char)*NAMESIZE, "alloc newname");
d205 5
a209 3
		if ((i == 1) && ((j = is_in_list(obj_list, buf)) != -1)) {
		    sprintf(buf, "%s%d", tag, num);
		    sprintf(newname, "%s%s", obj_list.names[j].dest[iter], post);
d211 1
a211 1
		    sprintf(newname, "%s%d%s", tag, num+i*state.incr, post);
d214 1
a214 1
		sprintf(newname, "%s%d", tag, num+i*state.incr);
d220 1
a220 1
	    sprintf(newname, "%s%d", tag, (num==0)?2:num+i);
d228 3
d238 2
a239 1
    if (is_in_list(obj_list, proto->d_namep) != -1) {
d244 8
d253 2
d259 1
d261 5
a265 1
	    strcpy(obj_list.names[idx].dest[i], obj_list.names[is_in_list(obj_list, rp[1].M.m_instname)].dest[i]);
a266 1
	    strcpy(rp[0].c.c_name, obj_list.names[idx].dest[i]);
d268 1
a268 2
	    strcpy(obj_list.names[idx].dest[i], get_name(((i==0) ? proto : db_lookup(dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET)), state, i));
	    strcpy(rp[0].c.c_name, obj_list.names[idx].dest[i]);
d270 5
a274 2
	if ((dp = db_diradd(dbip, rp->c.c_name, RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, NULL)) == DIR_NULL || 
	    db_alloc(dbip, dp, proto->d_len) < 0) {
d278 1
d280 11
a290 1
	    sprintf(rp[j].M.m_instname, "%s", obj_list.names[is_in_list(obj_list, rp[j].M.m_instname)].dest[i]);
d292 1
a292 1
	db_put(dbip, dp, rp, 0, dp->d_len);
d300 3
d310 2
a311 1
    if (is_in_list(obj_list, proto->d_namep) != -1) {
d316 3
a318 2
    if ((rp = db_getmrec(dbip, proto)) == (union record *)0) {
	TCL_READ_ERR;
d321 2
a323 1
	strcpy(obj_list.names[idx].dest[i], get_name(((i==0) ? proto : db_lookup(dbip, obj_list.names[idx].dest[i-1], LOOKUP_QUIET)), state, i));
d325 11
a335 2
	if ((dp = db_diradd(dbip, obj_list.names[idx].dest[i], RT_DIR_PHONY_ADDR, proto->d_len, proto->d_flags, NULL)) == DIR_NULL ||
	    db_alloc(dbip, dp, proto->d_len) < 0) {
d340 1
a340 1
	    strcpy(rp->s.s_name, dp->d_namep);
d369 1
a369 1
	    fprintf(stdout, "mods not available on %s\n", proto->d_namep);
d371 8
a378 1
	db_put(dbip, dp, rp, 0, dp->d_len);
a380 1
    rt_free((char *)rp, "copy_solid record[]");
d385 1
d393 1
d399 1
d401 2
d410 1
d413 1
d423 3
d435 1
d438 7
d446 1
a446 1
	char *av[3];
d448 1
a448 3
	av[0] = "e";
	av[2] = NULL;
	idx = is_in_list(obj_list, state.src->d_namep);
d455 1
d458 1
a458 1
	    bu_free((char *)obj_list.names[i].dest[j], "free destj");
d463 2
d472 1
d488 1
d492 3
d502 1
a502 1
    state->incr = 500;
d570 1
d584 1
d590 1
d602 1
d607 1
d619 2
a620 9
fastf_t
dist(vect_t pt1, vect_t pt2)
{
    return sqrt(pow(pt1[X]-pt2[X], 2) + pow(pt1[Y]-pt2[Y], 2) + pow(pt1[Z]-pt2[Z], 2));
}


/*
 * INTERP_SPL
d622 1
a622 1
 * sets pt = Q(t) for the specified spline
d634 6
a639 1
    while (t >= spl.t[i+1]) {i++;}
d643 1
d650 3
d666 1
a666 1
    char tok[81], line[81];
d672 1
a672 1
    fastf_t pt[3], rot[3];
d675 1
a675 1

d790 1
a790 1
	totlen += dist(s.k[i].pt, s.k[i+1].pt);
d814 2
a815 2
		while (fabs(dist(verts[n_links*j+k-1], pt) - dist_to_next) >= TOL) {
		    if (dist(verts[n_links*j+k-1], pt) > dist_to_next) {
d832 1
a832 1
	    totlen += dist(verts[j], verts[j+1]);
d895 1
a895 1
		/*				strcpy(vargs[1], obj_list.names[is_in_list(obj_list, links[j].name)].dest[0]);*/
@

