head	14.25;
access;
symbols
	rel-7-10-4:14.21.2.1
	STABLE:14.21.0.2
	stable-branch:14.6
	rel-7-10-2:14.21
	rel-7-10-0:14.20
	rel-7-8-4:14.16
	rel-7-8-2:14.15
	rel-7-8-0:14.15
	trimnurbs-branch:14.14.0.2
	help:14.14
	temp_tag:14.12
	bobWinPort-20051223-freeze:14.9.2.1
	postmerge-20051223-bobWinPort:14.12
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.6
	rel-7-6-0:14.9
	rel-7-4-2:14.9
	rel-7-4-branch:14.9.0.4
	bobWinPort:14.9.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.9
	rel-7-2-4:14.8
	rel-7-2-2:14.6
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.25
date	2007.12.16.15.59.40;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.12.14.13.11.28;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.12.02.22.34.23;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.09.15.16.23.18;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.07.26.01.13.58;	author brlcad;	state Exp;
branches
	14.21.2.1;
next	14.20;

14.20
date	2007.02.20.08.19.49;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.27.01.41.44;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.23.01.13.43;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.20.14.36.58;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.07.09.18.25.32;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.04.06.20.50.03;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.01.24.05.00.26;	author brlcad;	state Exp;
branches
	14.14.2.1;
next	14.13;

14.13
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.31.07.30.58;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.05.28.02.14.52;	author brlcad;	state Exp;
branches
	14.9.2.1
	14.9.6.1;
next	14.8;

14.8
date	2005.05.01.20.33.03;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.05.01.20.23.03;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.03.24.17.30.24;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.07.32.31;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.07.25.30;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.30;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.29;	author morrison;	state Exp;
branches;
next	;

14.9.2.1
date	2005.09.08.15.48.52;	author bob1961;	state Exp;
branches;
next	;

14.9.6.1
date	2005.11.13.13.46.18;	author brlcad;	state Exp;
branches;
next	;

14.14.2.1
date	2006.04.07.19.30.28;	author jlowenz;	state Exp;
branches;
next	;

14.21.2.1
date	2007.09.28.14.04.35;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.25
log
@convert all bzero calls to memset
@
text
@/*                      U T I L I T Y 1 . C
 * BRL-CAD
 *
 * Copyright (c) 1990-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file utility1.c
 *
 *  Functions -
 *	f_tables()	control routine for building ascii tables
 *	tables()	builds ascii summary tables
 *	f_edcodes()	control routine for editing region ident codes
 *	edcodes()	allows for easy editing of region ident codes
 *	f_which_id()	lists all regions with given ident number
 *
 *  Author -
 *	Keith A. Applin
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.24 2007/12/14 13:11:28 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_PWD_H
#  include <pwd.h>
#endif
#include <signal.h>
#include <math.h>
#include <time.h>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "raytrace.h"
#include "db.h"

#include "./ged.h"
#include "./sedit.h"
#include "./cmd.h"


extern struct bn_tol    mged_tol;       /* from ged.c */

int readcodes(), writecodes();
int loadcodes(), printcodes(FILE *fp, struct directory *dp, int pathpos);
void		tables(), edcodes(), changes(), prfield();

#define LINELEN 256
#define MAX_LEVELS 12
struct directory *path[MAX_LEVELS];

/* structure to distinguish new solids from existing (old) solids */
struct identt {
	int	i_index;
	char	i_name[NAMESIZE+1];
	mat_t	i_mat;
};
struct identt identt, idbuf;

#define ABORTED		-99
#define OLDSOLID	0
#define NEWSOLID	1
#define SOL_TABLE	1
#define REG_TABLE	2
#define ID_TABLE	3

/*
 *
 *	F _ T A B L E S :	control routine to build ascii tables
 */

char operate;
int regflag, numreg, lastmemb, numsol, old_or_new, oper_ok;
int idfd, rd_idfd;
int flag;	/* which type of table to make */
FILE	*tabptr;

char ctemp[7];

static char	tmpfil[MAXPATHLEN] = {0};

static int
id_compare( const void *p1, const void *p2 )
{
	int id1, id2;

	id1 = atoi( *(char **)p1 );
	id2 = atoi( *(char **)p2 );

	return( id1 - id2 );
}

static int
reg_compare( const void *p1, const void *p2 )
{
	char *reg1, *reg2;

	reg1 = strchr( *(char **)p1, '/' );
	reg2 = strchr( *(char **)p2, '/' );

	return( strcmp( reg1, reg2 ) );
}

/*
 *
 *	F _ E D C O D E S ( )
 *
 *		control routine for editing region ident codes
 */
int
f_edcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int i;
  int status;
  int sort_by_ident=0;
  int sort_by_region=0;
  int c;
  char **av;
  FILE *fp = NULL;

  CHECK_DBI_NULL;

  if(argc < 2){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help edcodes");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  bu_optind = 1;
  while ((c = bu_getopt(argc, argv, "ir")) != EOF) {
	  switch( c ) {
		  case 'i':
			  sort_by_ident = 1;
			  break;
		  case 'r':
			  sort_by_region = 1;
			  break;
	  }
  }

  if( (sort_by_ident + sort_by_region) > 1 ) {
	  Tcl_AppendResult(interp, "edcodes: can only sort by region or ident, not both\n",
			   (char *)NULL );
	  return TCL_ERROR;
  }

  argc -= (bu_optind - 1);
  argv += (bu_optind - 1);

  fp = bu_temp_file(tmpfil, MAXPATHLEN);
  if (!fp) {
    return TCL_ERROR;
  }

  av = (char **)bu_malloc(sizeof(char *)*(argc + 2), "f_edcodes: av");
  av[0] = "wcodes";
  av[1] = tmpfil;
  for(i = 2; i < argc + 1; ++i)
    av[i] = argv[i-1];

  av[i] = NULL;

  if( f_wcodes(clientData, interp, argc + 1, av) == TCL_ERROR ){
    (void)unlink(tmpfil);
    bu_free((genptr_t)av, "f_edcodes: av");
    return TCL_ERROR;
  }

	if( regflag == ABORTED )
	{
		Tcl_AppendResult(interp, "f_edcodes: nesting is too deep\n", (char *)NULL );
		(void)unlink(tmpfil);
		return TCL_ERROR;
	}

	if( sort_by_ident || sort_by_region ) {
		char **line_array;
		char aline[256];
		FILE *f_srt;
		int line_count=0;
		int j;

		if( (f_srt=fopen( tmpfil, "r+" ) ) == NULL ) {
			Tcl_AppendResult(interp, "edcodes: Failed to open temp file for sorting\n",
					 (char *)NULL );
			(void)unlink( tmpfil );
			return TCL_ERROR;
		}

		/* count lines */
		while( bu_fgets( aline, 256, f_srt ) ) {
			line_count++;
		}

		/* build array of lines */
		line_array = (char **)bu_calloc( line_count, sizeof( char *), "edcodes line array" );

		/* read lines and save into the array */
		rewind( f_srt );
		line_count = 0;
		while( bu_fgets( aline, 256, f_srt ) ) {
			line_array[line_count] = bu_strdup( aline );
			line_count++;
		}

		/* sort the array of lines */
		if( sort_by_ident ) {
			qsort( line_array, line_count, sizeof( char *), id_compare );
		} else {
			qsort( line_array, line_count, sizeof( char *), reg_compare );
		}

		/* rewrite the temp file using the sorted lines */
		rewind( f_srt );
		for( j=0 ; j<line_count ; j++ ) {
			fprintf( f_srt, "%s", line_array[j] );
			bu_free( line_array[j], "edcodes line array element" );
		}
		bu_free( (char *)line_array, "edcodes line array" );
		fclose( f_srt );
	}

  if( editit(tmpfil) ){
	  regflag = lastmemb = 0;

	  if (!dbip->dbi_read_only) {
		  av[0] = "rcodes";
		  av[2] = NULL;
		  status = f_rcodes(clientData, interp, 2, av);
	  } else {
		  Tcl_AppendResult(interp, "Because the database is READ-ONLY no changes were made.\n", (char *)NULL);
		  status = TCL_OK;
	  }
  }else
	  status = TCL_ERROR;

  if (fp) {
      fclose(fp);
      fp = NULL;
  }
  unlink(tmpfil);
  bu_free((genptr_t)av, "f_edcodes: av");
  return status;
}


/* write codes to a file */
int
f_wcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  register int i;
  int status;
  FILE *fp;
  register struct directory *dp;

  CHECK_DBI_NULL;

  if(argc < 3){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help wcodes");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if((fp = fopen(argv[1], "w")) == NULL){
    Tcl_AppendResult(interp, "f_wcodes: Failed to open file - ", argv[1], (char *)NULL);
    return TCL_ERROR;
  }

  regflag = lastmemb = 0;
  for(i = 2; i < argc; ++i){
    if( (dp = db_lookup( dbip, argv[i], LOOKUP_NOISY)) != DIR_NULL ){
      status = printcodes(fp, dp, 0);

      if(status == TCL_ERROR){
	(void)fclose(fp);
	return TCL_ERROR;
      }
    }
  }

  (void)fclose(fp);
  return TCL_OK;
}

/* read codes from a file and load them into the database */
int
f_rcodes(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  int item, air, mat, los;
  char name[256];
  char line[LINELEN];
  char *cp;
  FILE *fp;
  register struct directory *dp;
  struct rt_db_internal intern;
  struct rt_comb_internal *comb;

  CHECK_DBI_NULL;
  CHECK_READ_ONLY;

  if(argc < 2 || 2 < argc){
    struct bu_vls vls;

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "help rcodes");
    Tcl_Eval(interp, bu_vls_addr(&vls));
    bu_vls_free(&vls);
    return TCL_ERROR;
  }

  if((fp = fopen(argv[1], "r")) == NULL){
    Tcl_AppendResult(interp, "f_rcodes: Failed to read file - ", argv[1], (char *)NULL);
    return TCL_ERROR;
  }

  while(bu_fgets( line , LINELEN, fp ) != NULL){
	  int changed;

    if(sscanf(line, "%d%d%d%d%256s", &item, &air, &mat, &los, name) != 5)
      continue; /* not useful */

    /* skip over the path */
    if((cp = strrchr(name, (int)'/')) == NULL)
      cp = name;
    else
      ++cp;

    if(*cp == '\0')
      continue;

    if((dp = db_lookup( dbip, cp, LOOKUP_NOISY )) == DIR_NULL){
      Tcl_AppendResult(interp, "f_rcodes: Warning - ", cp, " not found in database.\n",
		       (char *)NULL);
      continue;
    }

	if( !(dp->d_flags & DIR_REGION) )
	{
		Tcl_AppendResult(interp, "f_rcodes: Warning ", cp, " not a region\n", (char *)NULL );
		continue;
	}

	if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) != ID_COMBINATION )
	{
		Tcl_AppendResult(interp, "f_rcodes: Warning ", cp, " not a region\n", (char *)NULL );
		continue;
	}

	comb = (struct rt_comb_internal *)intern.idb_ptr;

	/* make the changes */
	changed = 0;
	if( comb->region_id != item ) {
		comb->region_id = item;
		changed = 1;
	}
	if( comb->aircode != air ) {
		comb->aircode = air;
		changed = 1;
	}
	if( comb->GIFTmater != mat ) {
		comb->GIFTmater = mat;
		changed = 1;
	}
	if( comb->los != los ) {
		comb->los = los;
		changed = 1;
	}

	if( changed ) {
		/* write out all changes */
		if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) ) {
			Tcl_AppendResult(interp, "Database write error, aborting.\n",
					 (char *)NULL );
			TCL_ERROR_RECOVERY_SUGGESTION;
			rt_db_free_internal( &intern, &rt_uniresource );
			return TCL_ERROR;
		}
	}

  }

  return TCL_OK;
}

static void
Do_printnode(struct db_i *dbip, struct rt_comb_internal *comb, union tree *comb_leaf, genptr_t user_ptr1, genptr_t user_ptr2, genptr_t user_ptr3)
{
	FILE *fp;
	int *pathpos;
	struct directory *nextdp;

	RT_CK_DBI( dbip );
	RT_CK_TREE( comb_leaf );

	if( (nextdp=db_lookup( dbip, comb_leaf->tr_l.tl_name, LOOKUP_NOISY )) == DIR_NULL )
		return;

	fp = (FILE *)user_ptr1;
	pathpos = (int *)user_ptr2;

	/* recurse on combinations */
	if( nextdp->d_flags & DIR_COMB )
		(void)printcodes( fp, nextdp, (*pathpos)+1 );
}

int
printcodes(FILE *fp, struct directory *dp, int pathpos)
{
	int i;
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	int id;

	CHECK_DBI_NULL;

	if(pathpos >= MAX_LEVELS)
	{
		regflag = ABORTED;
		return TCL_ERROR;
	}

	if( !(dp->d_flags & DIR_COMB) )
		return( 0 );

	if( (id=rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) ) < 0 )
	{
		Tcl_AppendResult(interp, "printcodes: Cannot get records for ",
			dp->d_namep, "\n", (char *)NULL );
		return TCL_ERROR;
	}

	if( id != ID_COMBINATION )
		return TCL_OK;

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( comb->region_flag )
	{
		fprintf(fp, "%-6d %-3d %-3d %-4d  ",
			comb->region_id,
			comb->aircode,
			comb->GIFTmater,
			comb->los );
		for(i=0; i < pathpos; i++)
			fprintf(fp, "/%s",path[i]->d_namep);
		fprintf(fp, "/%s\n", dp->d_namep );
		rt_comb_ifree( &intern, &rt_uniresource );
		return TCL_OK;
	}

	if( comb->tree )
	{
		path[pathpos] = dp;
		db_tree_funcleaf( dbip, comb, comb->tree, Do_printnode,
			(genptr_t)fp, (genptr_t)&pathpos, (genptr_t)NULL );
	}

	rt_comb_ifree( &intern, &rt_uniresource );
	return TCL_OK;
}

/*    C H E C K      -     compares solids       returns 1 if they match
							 0 otherwise
 */

int
check(register char *a, register char *b)
{

	register int	c= sizeof( struct identt );

	while( c-- )	if( *a++ != *b++ ) return( 0 );	/* no match */
	return( 1 );	/* match */

}

struct id_names {
	struct bu_list l;
	struct bu_vls name;		/* name associated with region id */
};

struct id_to_names {
	struct bu_list l;
	int id;				/* starting id (i.e. region id or air code) */
	struct id_names headName;	/* head of list of names */
};

/*		F _ W H I C H _ S H A D E R
 *
 *	Finds all combinations using the given shaders
 */
int
f_which_shader(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int	i,j;
	register struct directory *dp;
	struct rt_db_internal	intern;
	struct rt_comb_internal	*comb;
	int sflag;
	int myArgc;
	char **myArgv;

	CHECK_DBI_NULL;

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;

	myArgc = argc;
	myArgv = argv;
	sflag = 0;

	if(myArgc > 1 && strcmp(myArgv[1], "-s") == 0){
	  --myArgc;
	  ++myArgv;
	  sflag = 1;
	}

	if(myArgc < 2){
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "help which_shader");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		(void)signal( SIGINT, SIG_IGN );
		return TCL_ERROR;
	}

	for( j=1; j<myArgc; j++) {

		if(!sflag)
		  Tcl_AppendResult(interp, "Combination[s] with shader ", myArgv[j],
				   ":\n", (char *)NULL);

		/* Examine all COMB nodes */
		FOR_ALL_DIRECTORY_START(dp, dbip) {
			if( !(dp->d_flags & DIR_COMB) )
				continue;

			if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
				(void)signal( SIGINT, SIG_IGN );
				TCL_READ_ERR_return;
			}
			comb = (struct rt_comb_internal *)intern.idb_ptr;

			if( !strstr( bu_vls_addr( &comb->shader ), myArgv[j] ) )
				continue;

			if(sflag)
			  Tcl_AppendElement(interp, dp->d_namep);
			else
			  Tcl_AppendResult(interp, "   ", dp->d_namep,
					   "\n", (char *)NULL);
			rt_comb_ifree( &intern, &rt_uniresource );
		} FOR_ALL_DIRECTORY_END;
	}

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}

/*		F _ D E C O M P O S E
 *
 *	decompose an NMG object into shells,
 *	making a new NMG object for each shell.
 *	This is not just copying each shell from the NMG object into a new
 *	object. The NMG object is actually disassembled and each face
 *	is placed into an appropriate shell so that the end product is a
 *	group of shell(s) that can be described as exterior shells and interior
 *	void shells.
 */

int
f_decompose(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	int count;
	struct bu_vls solid_name;
	char *nmg_solid_name;
	char *prefix;
	char *def_prefix="sh";
	struct model *m;
	struct nmgregion *r;
	struct model *new_m;
	struct nmgregion *tmp_r;
	struct shell *kill_s;
	struct directory *dp;
	struct rt_db_internal nmg_intern;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if(argc < 2 || 3 < argc){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help decompose");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;

	count = 0;
	nmg_solid_name = argv[1];

	if( argc > 2 )
	{
		prefix = argv[2];
		if( dbip->dbi_version < 5 && strlen( prefix ) >= (NAMESIZE-3) )
		{
			Tcl_AppendResult(interp, "Prefix ", prefix, " is too long", (char *)NULL );
			return TCL_ERROR;
		}
	}
	else
		prefix = def_prefix;;

	if( (dp=db_lookup( dbip, nmg_solid_name, LOOKUP_NOISY ) ) == DIR_NULL )
		return TCL_ERROR;

	if( rt_db_get_internal( &nmg_intern, dp, dbip, bn_mat_identity, &rt_uniresource ) < 0 )
	{
		Tcl_AppendResult(interp, "rt_db_get_internal() error\n", (char *)NULL);
		return TCL_ERROR;
	}

	if( nmg_intern.idb_type != ID_NMG )
	{
		Tcl_AppendResult(interp, nmg_solid_name, " is not an NMG solid!", (char *)NULL );
		return TCL_ERROR;
	}

	bu_vls_init( &solid_name );

	m = (struct model *)nmg_intern.idb_ptr;
	NMG_CK_MODEL(m);

	/* create temp region to hold duplicate shell */
	tmp_r = nmg_mrsv( m );	/* temp nmgregion to hold dup shells */
	kill_s = BU_LIST_FIRST( shell, &tmp_r->s_hd );
	(void)nmg_ks( kill_s );

	for( BU_LIST_FOR( r, nmgregion, &m->r_hd ) )
	{
		struct shell *s;

		if( r == tmp_r )
			continue;

		for( BU_LIST_FOR( s, shell, &r->s_hd ) )
		{
			struct shell *tmp_s;
			struct shell *decomp_s;
			long **trans_tbl;

			/* duplicate shell */
			tmp_s = (struct shell *)nmg_dup_shell( s, &trans_tbl, &mged_tol );
			bu_free( (char *)trans_tbl, "trans_tbl" );

			 /* move duplicate to temp region */
			(void) nmg_mv_shell_to_region( tmp_s, tmp_r );

			/* decompose this shell */
			(void) nmg_decompose_shell( tmp_s, &mged_tol );

			/* move each decomposed shell to yet another region */
			decomp_s = BU_LIST_FIRST( shell, &tmp_r->s_hd );
			while( BU_LIST_NOT_HEAD( &decomp_s->l, &tmp_r->s_hd ) )
			{
				struct shell *next_s;
				struct shell *new_s;
				struct rt_db_internal new_intern;
				struct directory *new_dp;
				struct nmgregion *decomp_r;
				char shell_no[32];
				int end_prefix;

				next_s = BU_LIST_NEXT( shell, &decomp_s->l );

				decomp_r = nmg_mrsv( m );
				kill_s = BU_LIST_FIRST( shell, &decomp_r->s_hd );
				(void)nmg_ks( kill_s );
				nmg_shell_a( decomp_s, &mged_tol );
				new_s = (struct shell *)nmg_dup_shell( decomp_s, &trans_tbl, &mged_tol );
				(void)nmg_mv_shell_to_region( new_s, decomp_r );

				/* move this region to a different model */
				new_m = (struct model *)nmg_mk_model_from_region( decomp_r, 1 );
				(void)nmg_rebound( new_m, &mged_tol );

				/* create name for this shell */
				count++;
				bu_vls_strcpy( &solid_name, prefix );
				sprintf( shell_no, "_%d", count );
				if( dbip->dbi_version < 5 ) {
					end_prefix = strlen( prefix );
					if( end_prefix + strlen( shell_no ) >= NAMESIZE )
						end_prefix = NAMESIZE - strlen( shell_no );
					bu_vls_trunc( &solid_name, end_prefix );
					bu_vls_strncat( &solid_name, shell_no, NAMESIZE-bu_vls_strlen(&solid_name)-1 );
				} else {
					bu_vls_strcat( &solid_name, shell_no );
				}

				if( db_lookup( dbip, bu_vls_addr( &solid_name ), LOOKUP_QUIET ) != DIR_NULL )
				{
					Tcl_AppendResult(interp, "decompose: cannot create unique solid name (",
							 bu_vls_addr( &solid_name ), ")", (char *)NULL );
					Tcl_AppendResult(interp, "decompose: failed" );
					return TCL_ERROR;
				}

				/* write this model as a seperate nmg solid */
				RT_INIT_DB_INTERNAL( &new_intern );
				new_intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
				new_intern.idb_type = ID_NMG;
				new_intern.idb_meth = &rt_functab[ID_NMG];
				new_intern.idb_ptr = (genptr_t)new_m;

				if( (new_dp=db_diradd( dbip, bu_vls_addr( &solid_name ), -1, 0, DIR_SOLID,
						       (genptr_t)&new_intern.idb_type)) == DIR_NULL ) {
					bu_vls_free( &solid_name );
					TCL_ALLOC_ERR;
					return TCL_ERROR;;
				}

				if( rt_db_put_internal( new_dp, dbip, &new_intern, &rt_uniresource ) < 0 )
				{
					(void)nmg_km( new_m );
					bu_vls_free( &solid_name );
					Tcl_AppendResult(interp, "rt_db_put_internal() failure\n", (char *)NULL);
					return TCL_ERROR;
				}

				(void)nmg_ks( decomp_s );
				decomp_s = next_s;
			}
		}
	}

	rt_db_free_internal( &nmg_intern, &rt_uniresource );
	bu_vls_free( &solid_name );

	(void)signal( SIGINT, SIG_IGN );
	return TCL_OK;
}

static int
sol_number(matp_t matrix, char *name, int *old)
{
	int i;
	struct identt idbuf1, idbuf2;
	int readval;

	memset(&idbuf1, 0, sizeof( struct identt ));
	(void)strncpy(idbuf1.i_name, name, NAMESIZE);
	MAT_COPY(idbuf1.i_mat, matrix);

	for( i=0 ; i<numsol ; i++ )
	{
		(void)lseek(rd_idfd, i*(long)sizeof identt, 0);
		readval = read(rd_idfd, &idbuf2, sizeof identt);

		if (readval < 0) {
		    perror("READ ERROR");
		}

		idbuf1.i_index = i + 1;

		if( check( (char *)&idbuf1, (char *)&idbuf2 ) == 1 )
		{
			*old = 1;
			return( idbuf2.i_index );
		}
	}
	numsol++;
	idbuf1.i_index = numsol;

	(void)lseek(idfd, (off_t)0L, 2);
	(void)write(idfd, &idbuf1, sizeof identt);

	*old = 0;
	return( idbuf1.i_index );
}

static void
new_tables(struct directory *dp, struct bu_ptbl *cur_path, fastf_t *old_mat, int flag)
{
	struct rt_db_internal intern;
	struct rt_comb_internal *comb;
	struct rt_tree_array *tree_list;
	int node_count;
	int actual_count;
	int i,k;

	if(dbip == DBI_NULL)
	  return;

	RT_CK_DIR( dp );
	BU_CK_PTBL( cur_path );

	if( !(dp->d_flags & DIR_COMB) )
		return;

	if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )
		READ_ERR_return;

	comb = (struct rt_comb_internal *)intern.idb_ptr;
	RT_CK_COMB( comb );

	if( comb->tree && db_ck_v4gift_tree( comb->tree ) < 0 )
	{
		db_non_union_push( comb->tree, &rt_uniresource );
		if( db_ck_v4gift_tree( comb->tree ) < 0 )
		{
			Tcl_AppendResult(interp, "Cannot flatten tree for editing\n", (char *)NULL );
			rt_comb_ifree( &intern, &rt_uniresource );
			return;
		}
	}

	if( !comb->tree )
	{
		/* empty combination */
		rt_comb_ifree( &intern, &rt_uniresource );
		return;
	}

	node_count = db_tree_nleaves( comb->tree );
	tree_list = (struct rt_tree_array *)bu_calloc( node_count,
		sizeof( struct rt_tree_array ), "tree list" );

	/* flatten tree */
	actual_count = (struct rt_tree_array *)db_flatten_tree( tree_list,
		comb->tree, OP_UNION, 0, &rt_uniresource ) - tree_list;
	BU_ASSERT_LONG( actual_count, ==, node_count );

	if( dp->d_flags & DIR_REGION )
	{
		numreg++;
		(void)fprintf( tabptr, " %-4d %4d %4d %4d %4d  ",
			numreg, comb->region_id, comb->aircode, comb->GIFTmater,
			comb->los );
		for( k=0 ; k<BU_PTBL_END( cur_path ) ; k++ )
		{
			struct directory *path_dp;

			path_dp = (struct directory *)BU_PTBL_GET( cur_path, k );
			RT_CK_DIR( path_dp );
			(void)fprintf( tabptr, "/%s", path_dp->d_namep );
		}
		(void)fprintf( tabptr, "/%s:\n", dp->d_namep );

		if( flag == ID_TABLE )
			goto out;

		for( i=0 ; i<actual_count ; i++ )
		{
			char op;
			int nsoltemp=0;
			struct rt_db_internal sol_intern;
			struct directory *sol_dp;
			mat_t temp_mat;
			struct bu_vls tmp_vls;
			int old;

			switch( tree_list[i].tl_op )
			{
				case OP_UNION:
					op = 'u';
					break;
				case OP_SUBTRACT:
					op = '-';
					break;
				case OP_INTERSECT:
					op = '+';
					break;
				default:
					bu_log( "unrecognized operation in region %s\n", dp->d_namep );
					op = '?';
					break;
			}

			if( (sol_dp=db_lookup( dbip, tree_list[i].tl_tree->tr_l.tl_name, LOOKUP_QUIET )) != DIR_NULL )
			{
				if( sol_dp->d_flags & DIR_COMB )
				{
					(void)fprintf(tabptr,"   RG %c %s\n",
						op, sol_dp->d_namep);
					continue;
				}
				else if( !(sol_dp->d_flags & DIR_SOLID) )
				{
					(void)fprintf( tabptr, "   ?? %c %s\n",
						op, sol_dp->d_namep);
					continue;
				}
				else
				{
					if( tree_list[i].tl_tree->tr_l.tl_mat )  {
						bn_mat_mul( temp_mat, old_mat,
							tree_list[i].tl_tree->tr_l.tl_mat );
					} else {
						MAT_COPY( temp_mat, old_mat );
					}
					if( rt_db_get_internal( &sol_intern, sol_dp, dbip, temp_mat, &rt_uniresource ) < 0 )
					{
						bu_log( "Could not import %s\n", tree_list[i].tl_tree->tr_l.tl_name );
						nsoltemp = 0;
					}
					nsoltemp = sol_number( temp_mat, tree_list[i].tl_tree->tr_l.tl_name, &old );
					(void)fprintf(tabptr,"   %c [%d] ", op, nsoltemp );
				}
			}
			else
			{
				nsoltemp = sol_number( old_mat, tree_list[i].tl_tree->tr_l.tl_name, &old );
				(void)fprintf(tabptr,"   %c [%d] ", op, nsoltemp );
				continue;
			}

			if( flag == REG_TABLE || old )
			{
				(void) fprintf( tabptr, "%s\n", tree_list[i].tl_tree->tr_l.tl_name );
				continue;
			}
			else
				(void) fprintf( tabptr, "%s:  ", tree_list[i].tl_tree->tr_l.tl_name );

			if( !old && (sol_dp->d_flags & DIR_SOLID) )
			{
				/* if we get here, we must be looking for a solid table */
				bu_vls_init_if_uninit( &tmp_vls );
				if( rt_functab[sol_intern.idb_type].ft_describe( &tmp_vls, &sol_intern, 1, base2local, &rt_uniresource, dbip ) < 0 )
				{
					Tcl_AppendResult(interp, tree_list[i].tl_tree->tr_l.tl_name,
						"describe error\n" , (char *)NULL );
				}
				fprintf( tabptr, "%s", bu_vls_addr(&tmp_vls));
				bu_vls_free( &tmp_vls );
			}
			if( nsoltemp && (sol_dp->d_flags & DIR_SOLID) )
				rt_db_free_internal( &sol_intern, &rt_uniresource );
		}
	}
	else if( dp->d_flags & DIR_COMB )
	{
		int cur_length;

		bu_ptbl_ins( cur_path, (long *)dp );
		cur_length = BU_PTBL_END( cur_path );

		for( i=0 ; i<actual_count ; i++ )
		{
			struct directory *nextdp;
			mat_t new_mat;

			if( (nextdp=db_lookup( dbip, tree_list[i].tl_tree->tr_l.tl_name,
				 LOOKUP_NOISY )) == DIR_NULL )
			{
				Tcl_AppendResult(interp, "\tskipping this object\n", (char *)NULL );
				continue;
			}

			/* recurse */
			if( tree_list[i].tl_tree->tr_l.tl_mat )  {
				bn_mat_mul( new_mat, old_mat, tree_list[i].tl_tree->tr_l.tl_mat );
			} else {
				MAT_COPY( new_mat, old_mat );
			}
			new_tables( nextdp, cur_path, new_mat, flag );
			bu_ptbl_trunc( cur_path, cur_length );
		}
	}
	else
	{
		Tcl_AppendResult(interp, "Illegal flags for ", dp->d_namep,
			"skipping\n", (char *)NULL );
		return;
	}

out:
	bu_free( (char *)tree_list, "new_tables: tree_list" );
	rt_comb_ifree( &intern, &rt_uniresource );
	return;
}

int
f_tables(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	static const char sortcmd[] = "sort -n +1 -2 -o /tmp/ord_id ";
	static const char catcmd[] = "cat /tmp/ord_id >> ";
	struct bu_vls tmp_vls;
	struct bu_vls	cmd;
	struct bu_ptbl	cur_path;
	int status;
	char *timep;
	time_t now;
	int i;

	CHECK_DBI_NULL;

	if(argc < 3){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help %s", argv[0]);
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	bu_vls_init(&tmp_vls);
	bu_vls_init( &cmd );
	bu_ptbl_init( &cur_path, 8, "f_tables: cur_path" );
	numreg = 0;
	numsol = 0;

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else{
	  bu_vls_free( &cmd );
	  bu_vls_free(&tmp_vls);
	  bu_ptbl_free( &cur_path );
	  return TCL_OK;
	}
	status = TCL_OK;

	/* find out which ascii table is desired */
	if( strcmp(argv[0], "solids") == 0 ) {
		/* complete summary - down to solids/paremeters */
		flag = SOL_TABLE;
	}
	else if( strcmp(argv[0], "regions") == 0 ) {
		/* summary down to solids as members of regions */
		flag = REG_TABLE;
	}
	else if( strcmp(argv[0], "idents") == 0 ) {
		/* summary down to regions */
		flag = ID_TABLE;
	}
	else {
		/* should never reach here */
	  Tcl_AppendResult(interp, "tables:  input error\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	/* open the file */
	if( (tabptr=fopen(argv[1], "w+")) == NULL ) {
	  Tcl_AppendResult(interp, "Can't open ", argv[1], "\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	if( flag == SOL_TABLE || flag == REG_TABLE ) {
		/* temp file for discrimination of solids */
		if( (idfd = creat("/tmp/mged_discr", 0600)) < 0 ) {
			perror( "/tmp/mged_discr" );
			status = TCL_ERROR;
			goto end;
		}
		rd_idfd = open( "/tmp/mged_discr", 2 );
	}

	(void)time( &now );
	timep = ctime( &now );
	timep[24] = '\0';
	(void)fprintf(tabptr,"1 -8    Summary Table {%s}  (written: %s)\n",argv[0],timep);
	(void)fprintf(tabptr,"2 -7         file name    : %s\n",dbip->dbi_filename);
	(void)fprintf(tabptr,"3 -6         \n");
	(void)fprintf(tabptr,"4 -5         \n");
#ifndef _WIN32
	(void)fprintf(tabptr,"5 -4         user         : %s\n", getpwuid(getuid())->pw_gecos);
#else
	{
	char uname[256];
	DWORD dwNumBytes = 256;
	if(GetUserName(uname, &dwNumBytes))
		(void)fprintf(tabptr,"5 -4         user         : %s\n",uname);
	else
		(void)fprintf(tabptr,"5 -4         user         : UNKNOWN\n");
	}
#endif
	(void)fprintf(tabptr,"6 -3         target title : %s\n",cur_title);
	(void)fprintf(tabptr,"7 -2         target units : %s\n",
		bu_units_string(dbip->dbi_local2base) );
	(void)fprintf(tabptr,"8 -1         objects      :");
	for(i=2; i<argc; i++) {
		if( (i%8) == 0 )
			(void)fprintf(tabptr,"\n                           ");
		(void)fprintf(tabptr," %s",argv[i]);
	}
	(void)fprintf(tabptr,"\n\n");

	/* make the tables */
	for( i=2 ; i<argc ; i++ )
	{
		struct directory *dp;

		bu_ptbl_reset( &cur_path );
		if( (dp = db_lookup( dbip, argv[i],LOOKUP_NOISY)) != DIR_NULL )
			new_tables( dp, &cur_path, identity, flag);
		else
			Tcl_AppendResult(interp, " skip this object\n", (char *)NULL);
	}

	Tcl_AppendResult(interp, "Summary written in: ", argv[1], "\n", (char *)NULL);

	if( flag == SOL_TABLE || flag == REG_TABLE ) {
		(void)unlink( "/tmp/mged_discr\0" );
		(void)fprintf(tabptr,"\n\nNumber Primitives = %d  Number Regions = %d\n",
				numsol,numreg);

		bu_vls_printf(&tmp_vls, "Processed %d Primitives and %d Regions\n",
			      numsol,numreg);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);

		(void)fclose( tabptr );
	}

	else {
		(void)fprintf(tabptr,"* 9999999\n* 9999999\n* 9999999\n* 9999999\n* 9999999\n");
		(void)fclose( tabptr );

		bu_vls_printf(&tmp_vls, "Processed %d Regions\n",numreg);
		Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);

		/* make ordered idents */
		bu_vls_strcpy( &cmd, sortcmd );
		bu_vls_strcat( &cmd, argv[1] );
		Tcl_AppendResult(interp, bu_vls_addr(&cmd), "\n", (char *)NULL);
		(void)system( bu_vls_addr(&cmd) );

		bu_vls_trunc( &cmd, 0 );
		bu_vls_strcpy( &cmd, catcmd );
		bu_vls_strcat( &cmd, argv[1] );
		Tcl_AppendResult(interp, bu_vls_addr(&cmd), "\n", (char *)NULL);
		(void)system( bu_vls_addr(&cmd) );

		(void)unlink( "/tmp/ord_id\0" );
	}

end:
	bu_vls_free( &cmd );
	bu_vls_free(&tmp_vls);
	bu_ptbl_free( &cur_path );
	(void)signal( SIGINT, SIG_IGN );
	return status;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.24
log
@more usage of bu_temp_file() instead of mktemp/mkstemp for better generalized temp file management.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.23 2007/12/02 22:34:23 brlcad Exp $ (BRL)";
d801 1
a801 1
	bzero( &idbuf1, sizeof( struct identt ) );
@


14.23
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.22 2007/09/15 16:23:18 brlcad Exp $ (BRL)";
d110 1
a110 6
static char	tmpfil[17];
#ifndef _WIN32
static char	*tmpfil_init = "/tmp/GED.aXXXXXX";
#else
static char	*tmpfil_init = "C:\\GED.aXXXXXX";
#endif
d149 1
d184 2
a185 9
  strncpy(tmpfil, tmpfil_init, 17-1);
#ifdef _WIN32
  (void)mktemp(tmpfil);
  i=creat(tmpfil, 0600);
#else
  i = mkstemp(tmpfil);
#endif
  if( i < 0 ){
    perror(tmpfil);
a188 2
  (void)close(i);

d271 5
a275 1
  (void)unlink(tmpfil);
@


14.22
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.21 2007/07/26 01:13:58 brlcad Exp $ (BRL)";
d188 1
a188 1
  strcpy(tmpfil, tmpfil_init);
d337 1
a337 1
  char name[MAX_LEVELS * NAMESIZE];
d366 1
a366 1
    if(sscanf(line, "%d%d%d%d%s", &item, &air, &mat, &los, name) != 5)
d994 1
a994 1
				(void)fprintf( tabptr, bu_vls_addr(&tmp_vls));
@


14.21
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.20 2007/02/20 08:19:49 brlcad Exp $ (BRL)";
d50 2
a51 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.21.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.22 2007/09/15 16:23:18 brlcad Exp $ (BRL)";
d50 5
a54 2
#include <string.h>

@


14.20
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@a31 4
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.19 2007/01/27 01:41:44 brlcad Exp $ (BRL)";
@


14.19
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.18 2007/01/23 01:13:43 brlcad Exp $ (BRL)";
d245 1
a245 1
		while( fgets( aline, 256, f_srt ) ) {
d255 1
a255 1
		while( fgets( aline, 256, f_srt ) ) {
d370 1
a370 1
  while(fgets( line , LINELEN, fp ) != NULL){
@


14.18
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.17 2007/01/20 14:36:58 brlcad Exp $ (BRL)";
d391 11
a401 11
  	if( !(dp->d_flags & DIR_REGION) )
  	{
  		Tcl_AppendResult(interp, "f_rcodes: Warning ", cp, " not a region\n", (char *)NULL );
  		continue;
  	}

  	if( rt_db_get_internal( &intern, dp, dbip, (matp_t)NULL, &rt_uniresource ) != ID_COMBINATION )
  	{
  		Tcl_AppendResult(interp, "f_rcodes: Warning ", cp, " not a region\n", (char *)NULL );
  		continue;
  	}
d403 1
a403 1
  	comb = (struct rt_comb_internal *)intern.idb_ptr;
d405 1
a405 1
  	/* make the changes */
d563 1
a563 1
        else
d662 1
a662 1
        else
@


14.17
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.16 2006/07/09 18:25:32 brlcad Exp $ (BRL)";
@


14.16
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2006 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.15 2006/04/06 20:50:03 brlcad Exp $ (BRL)";
@


14.15
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.14 2006/01/24 05:00:26 brlcad Exp $ (BRL)";
d441 1
a441 1
HIDDEN void
d811 1
a811 1
HIDDEN int
d816 1
d825 5
a829 1
		(void)read(rd_idfd, &idbuf2, sizeof identt);
d849 1
a849 1
HIDDEN void
@


14.14
log
@convert iteration over the array of linked list of directory nodes to FOR_ALL_DIRECTORY_START/FOR_ALL_DIRECTORY_END instead
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.13 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d44 1
@


14.14.2.1
log
@update from HEAD
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.14 2006/01/24 05:00:26 brlcad Exp $ (BRL)";
a43 1
#include <stdlib.h>
@


14.13
log
@update copyright to 2006
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.12 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d594 3
a596 4
		for( i = 0; i < RT_DBNHASH; i++ )  {
			for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
				if( !(dp->d_flags & DIR_COMB) )
					continue;
d598 5
a602 5
				if( rt_db_get_internal( &intern, dp, dbip, (fastf_t *)NULL, &rt_uniresource ) < 0 )  {
					(void)signal( SIGINT, SIG_IGN );
					TCL_READ_ERR_return;
				}
				comb = (struct rt_comb_internal *)intern.idb_ptr;
d604 2
a605 2
				if( !strstr( bu_vls_addr( &comb->shader ), myArgv[j] ) )
					continue;
d607 7
a613 8
				if(sflag)
				  Tcl_AppendElement(interp, dp->d_namep);
				else
				  Tcl_AppendResult(interp, "   ", dp->d_namep,
						   "\n", (char *)NULL);
				rt_comb_ifree( &intern, &rt_uniresource );
			}
		}
@


14.12
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1990-2005 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.11 2005/10/31 07:30:58 brlcad Exp $ (BRL)";
@


14.11
log
@header cleanup, reorg, and general bug squashing including adding missing headers
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.10 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
a80 6
/* bu_getopt parameters */
extern int	bu_opterr;
extern int	bu_optind;
extern int	bu_optopt;
extern char	*bu_optarg;

@


14.10
log
@trailing ws
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.9 2005/05/28 02:14:52 brlcad Exp $ (BRL)";
d62 3
d72 1
@


14.9
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d32 1
a32 1
 *  
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.8 2005/05/01 20:33:03 brlcad Exp $ (BRL)";
d850 1
a850 1
	struct rt_db_internal intern;	
d1131 1
a1131 1
	(void)fprintf(tabptr,"2 -7         file name    : %s\n",dbip->dbi_filename);    
d1138 2
a1139 2
	char uname[256]; 
	DWORD dwNumBytes = 256; 
@


14.9.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a61 3
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif
a68 1
#include "db.h"
d850 1
a850 1
	struct rt_db_internal intern;
d1131 1
a1131 1
	(void)fprintf(tabptr,"2 -7         file name    : %s\n",dbip->dbi_filename);
d1138 2
a1139 2
	char uname[256];
	DWORD dwNumBytes = 256;
@


14.9.2.1
log
@bu_opt??? declared in bu.h
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.9 2005/05/28 02:14:52 brlcad Exp $ (BRL)";
d77 6
@


14.8
log
@oops, if DEFINED.. not not defined.. might as well add sys/types.h too
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.7 2005/05/01 20:23:03 brlcad Exp $ (BRL)";
d120 1
a120 1
#ifndef WIN32
d198 1
a198 1
#ifdef WIN32
d1134 1
a1134 1
#ifndef WIN32
@


14.7
log
@windows does have unlink(), it is just called _unlink() through the compatibility interface.  the same goes for lseek (and pretty much all of the standard C library functions) -- so instead of having dual sections everwhere, a define is provided in include/config_win.h that makes them equivalent.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.6 2005/03/24 17:30:24 bob1961 Exp $ (BRL)";
d45 4
a48 1
#ifndef HAVE_PWD_H
d1135 1
a1135 1
	(void)fprintf(tabptr,"5 -4         user         : %s\n",getpwuid(getuid())->pw_gecos);
@


14.6
log
@If Windows, use remove() and _lseek
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.5 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
a43 2


d45 2
a46 5
#ifdef WIN32
#include <io.h>
#endif
#ifndef WIN32
#include <pwd.h>
d52 1
a52 1
#include <string.h>
d54 4
a57 1
#include <strings.h>
d66 1
d71 1
a216 3
#ifdef WIN32
    (void)remove(tmpfil);
#else
a217 1
#endif
a224 3
#ifdef WIN32
		(void)remove(tmpfil);
#else
a225 1
#endif
d239 1
a239 5
#ifdef WIN32
			(void)remove(tmpfil);
#else
			unlink( tmpfil );
#endif
a289 3
#ifdef WIN32
  (void)remove(tmpfil);
#else
a290 1
#endif
a822 3
#ifdef WIN32
		(void)_lseek(rd_idfd, i*(long)sizeof identt, 0);
#else
a823 1
#endif
a836 3
#ifdef WIN32
	(void)_lseek(idfd, 0L, 2);
#else
a837 1
#endif
a1168 3
#ifdef WIN32
		(void)remove( "/tmp/mged_discr\0" );
#else
a1169 1
#endif
a1198 3
#ifdef WIN32
		(void)remove( "/tmp/ord_id\0" );
#else
a1199 1
#endif
@


14.5
log
@update copyright to 2005
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/utility1.c,v 14.4 2004/12/21 07:32:31 morrison Exp $ (BRL)";
d47 3
d217 3
d221 1
d229 3
d233 1
d247 3
d251 1
d302 3
d306 1
d839 3
d843 1
d857 3
d861 1
d1193 3
d1197 1
d1227 3
d1231 1
@


14.4
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2004 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/utility1.c,v 14.3 2004/12/21 07:25:30 morrison Exp $ (BRL)";
@


14.3
log
@tidy up a lil bit
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/utility1.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
a146 2
 *
 *
@


14.2
log
@GPL License changes
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/utility1.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
a102 2
 *
 *
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			U T I L I T Y 1 . C
a36 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/utility1.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/utility1.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d1195 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/utility1.c,v 1.2 2004/06/08 22:04:30 morrison Exp $ (BRL)";
d38 1
a38 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/utility1.c,v 11.81 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a51 1
#include "externs.h"
@

