head	14.13;
access;
symbols
	rel-7-10-4:14.12.2.1
	STABLE:14.12.0.2
	stable-branch:14.3
	rel-7-10-2:14.12
	rel-7-10-0:14.12
	rel-7-8-4:14.9
	rel-7-8-2:14.8
	rel-7-8-0:14.8
	trimnurbs-branch:14.8.0.2
	help:14.8
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.3.2.1
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.13
date	2007.09.15.16.23.17;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.27.01.41.43;	author brlcad;	state Exp;
branches
	14.12.2.1;
next	14.11;

14.11
date	2007.01.23.01.13.42;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.08.18.19.07.55;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.28.00.36.29;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.31.07.30.58;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches
	14.3.2.1
	14.3.6.1;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.28;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.25;	author morrison;	state Exp;
branches;
next	;

14.3.2.1
date	2005.09.08.15.56.03;	author bob1961;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;

14.12.2.1
date	2007.09.28.14.04.34;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.13
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                        I N S I D E . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file inside.c
 *			I N S I D E
 *
 *	Given an outside solid and desired thicknesses, finds
 *	an inside solid to produce those thicknesses.
 *
 * Functions -
 *	f_inside	reads all the input required
 *	arbin		finds inside of arbs
 *	tgcin		finds inside of tgcs
 *	ellgin		finds inside of ellgs
 *	torin		finds inside of tors
 *
 *  Authors -
 *	Keith A Applin
 *	Michael Markowski
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.12 2007/01/27 01:41:43 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <signal.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "db.h"

#include "./ged.h"
#include "./sedit.h"
#include "./mged_solid.h"
#include "./mged_dm.h"
#include "./cmd.h"

extern struct rt_db_internal	es_int;	/* from edsol.c */
extern struct bn_tol		mged_tol;	/* from ged.c */

extern char	**promp;	/* pointer to a pointer to a char */

static char *p_arb4[] = {
	"Enter thickness for face 123: ",
	"Enter thickness for face 124: ",
	"Enter thickness for face 234: ",
	"Enter thickness for face 134: ",
};

static char *p_arb5[] = {
	"Enter thickness for face 1234: ",
	"Enter thickness for face 125: ",
	"Enter thickness for face 235: ",
	"Enter thickness for face 345: ",
	"Enter thickness for face 145: ",
};

static char *p_arb6[] = {
	"Enter thickness for face 1234: ",
	"Enter thickness for face 2356: ",
	"Enter thickness for face 1564: ",
	"Enter thickness for face 125: ",
	"Enter thickness for face 346: ",
};

static char *p_arb7[] = {
	"Enter thickness for face 1234: ",
	"Enter thickness for face 567: ",
	"Enter thickness for face 145: ",
	"Enter thickness for face 2376: ",
	"Enter thickness for face 1265: ",
	"Enter thickness for face 3475: ",
};

static char *p_arb8[] = {
	"Enter thickness for face 1234: ",
	"Enter thickness for face 5678: ",
	"Enter thickness for face 1485: ",
	"Enter thickness for face 2376: ",
	"Enter thickness for face 1265: ",
	"Enter thickness for face 3478: ",
};

static char *p_tgcin[] = {
	"Enter thickness for base (AxB): ",
	"Enter thickness for top (CxD): ",
	"Enter thickness for side: ",
};

static char *p_partin[] = {
	"Enter thickness for body: ",
};

static char *p_rpcin[] = {
	"Enter thickness for front plate (contains V): ",
	"Enter thickness for back plate: ",
	"Enter thickness for top plate: ",
	"Enter thickness for body: ",
};

static char *p_rhcin[] = {
	"Enter thickness for front plate (contains V): ",
	"Enter thickness for back plate: ",
	"Enter thickness for top plate: ",
	"Enter thickness for body: ",
};

static char *p_epain[] = {
	"Enter thickness for top plate: ",
	"Enter thickness for body: ",
};

static char *p_ehyin[] = {
	"Enter thickness for top plate: ",
	"Enter thickness for body: ",
};

static char *p_etoin[] = {
	"Enter thickness for body: ",
};

static char *p_nmgin[] = {
	"Enter thickness for shell: ",
};

/*	F _ I N S I D E ( ) :	control routine...reads all data
 */
int
f_inside(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;
	struct directory	*dp;
	struct directory	*outdp;
	mat_t newmat;
	int	cgtype;		/* cgtype ARB 4..8 */
	int	nface;
	fastf_t	thick[6];
	plane_t	planes[6];
	struct rt_db_internal	intern;
	char	*newname;
	int arg = 1;
	int status = TCL_OK;

	RT_INIT_DB_INTERNAL(&intern);

	CHECK_DBI_NULL;

	if(argc < 1){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help inside");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;

	/* SCHEME:
	 *	if in solid edit, use "edited" solid
	 *	if in object edit, use "key" solid
	 *	else get solid name to use
	 */

	if( state == ST_S_EDIT ) {
	  /* solid edit mode */
	  /* apply es_mat editing to parameters */
	  transform_editing_solid( &intern, es_mat, &es_int, 0 );
	  outdp = LAST_SOLID(illump);

	  if( argc < arg+1 ) {
		  Tcl_AppendResult(interp, "You are in Prim Edit mode, using edited primitive as outside primitive: ", (char *)NULL);
		  add_solid_path_to_result( interp, illump );
		  Tcl_AppendResult(interp, "\n", (char *)NULL);
	  }
	}  else if( state == ST_O_EDIT ) {
	  /* object edit mode */
	  if( illump->s_Eflag ) {
	     Tcl_AppendResult(interp, "Cannot find inside of a processed (E'd) region\n",
			      (char *)NULL);
	     status = TCL_ERROR;
	     goto end;
	  }
	  /* use the solid at bottom of path (key solid) */
	  /* apply es_mat and modelchanges editing to parameters */
	  bn_mat_mul(newmat, modelchanges, es_mat);
	  transform_editing_solid( &intern, newmat, &es_int, 0 );
	  outdp = LAST_SOLID(illump);
	  if( argc < arg+1 ) {
		  Tcl_AppendResult(interp, "You are in Object Edit mode, using key solid as outside solid: ", (char *)NULL);
		  add_solid_path_to_result( interp, illump );
		  Tcl_AppendResult(interp, "\n", (char *)NULL);
	  }
	} else {
	  /* Not doing any editing....ask for outside solid */
	  if( argc < arg+1 ) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter name of outside solid: ",
			     (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  if( (outdp = db_lookup( dbip,  argv[arg], LOOKUP_NOISY )) == DIR_NULL ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  ++arg;

	  if( rt_db_get_internal( &intern, outdp, dbip, bn_mat_identity, &rt_uniresource ) < 0 ) {
	    (void)signal( SIGINT, SIG_IGN );
	    TCL_READ_ERR_return;
	  }
	}

	if( intern.idb_type == ID_ARB8 )  {
	  /* find the comgeom arb type, & reorganize */
	  int uvec[8],svec[11];

	  if( rt_arb_get_cgtype( &cgtype , intern.idb_ptr, &mged_tol , uvec , svec ) == 0 ) {
	    Tcl_AppendResult(interp, outdp->d_namep, ": BAD ARB\n", (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }

	  /* must find new plane equations to account for
	   * any editing in the es_mat matrix or path to this solid.
	   */
	  if (rt_arb_calc_planes(interp, intern.idb_ptr, cgtype, planes, &mged_tol) < 0)  {
	    Tcl_AppendResult(interp, "rt_arb_calc_planes(", outdp->d_namep,
			     "): failed\n", (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	}
	/* "intern" is now loaded with the outside solid data */

	/* get the inside solid name */
	if( argc < arg+1 ) {
	  Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter name of the inside solid: ",
			   (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}
	if( db_lookup( dbip, argv[arg], LOOKUP_QUIET ) != DIR_NULL ) {
	  Tcl_AppendResult(interp, "you are attempting to use ", argv[arg],
		" as the inside solid.\n", "(Note that if you are in an edit mode",
		" the outside solid will be the solid you are editing)\n", (char *)NULL );
	  status = TCL_ERROR;
	  goto end;
	}
	if( dbip->dbi_version < 5 && (int)strlen(argv[arg]) >= NAMESIZE )  {
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);
	  bu_vls_printf(&tmp_vls, "Database version 4 names are limited to %d characters\n", NAMESIZE-1);
	  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	  bu_vls_free(&tmp_vls);
	  status = TCL_ERROR;
	  goto end;
	}
	newname = argv[arg];
	++arg;

	/* get thicknesses and calculate parameters for newrec */
	switch( intern.idb_type )  {

	case ID_ARB8:
	    {
		struct rt_arb_internal *arb =
			(struct rt_arb_internal *)intern.idb_ptr;

		nface = 6;

		switch( cgtype ) {
		case 8:
			promp = p_arb8;
			break;

		case 7:
			promp = p_arb7;
			break;

		case 6:
			promp = p_arb6;
			nface = 5;
			VMOVE( arb->pt[5], arb->pt[6] );
			break;

		case 5:
			promp = p_arb5;
			nface = 5;
			break;

		case 4:
			promp = p_arb4;
			nface = 4;
			VMOVE( arb->pt[3], arb->pt[4] );
			break;
		}

		for(i=0; i<nface; i++) {
		  if( argc < arg+1 ) {
		    Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
		    status = TCL_ERROR;
		    goto end;
		  }
		  thick[i] = atof(argv[arg]) * local2base;
		  ++arg;
		}

		if( arbin(&intern, thick, nface, cgtype, planes) ){
		  status = TCL_ERROR;
		  goto end;
		}
		break;
	    }

	case ID_TGC:
	  promp = p_tgcin;
	  for(i=0; i<3; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( tgcin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_ELL:
	  if( argc < arg+1 ) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter desired thickness: ", (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  thick[0] = atof( argv[arg] ) * local2base;
	  ++arg;

	  if( ellgin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_TOR:
	  if( argc < arg+1 ) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, "Enter desired thickness: ", (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  thick[0] = atof( argv[arg] ) * local2base;
	  ++arg;

	  if( torin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_PARTICLE:
	  promp = p_partin;
	  for (i = 0; i < 1; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( partin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_RPC:
	  promp = p_rpcin;
	  for (i = 0; i < 4; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( rpcin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_RHC:
	  promp = p_rhcin;
	  for (i = 0; i < 4; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( rhcin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_EPA:
	  promp = p_epain;
	  for (i = 0; i < 2; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( epain(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_EHY:
	  promp = p_ehyin;
	  for (i = 0; i < 2; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( ehyin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_ETO:
	  promp = p_etoin;
	  for (i = 0; i < 1; i++) {
	    if( argc < arg+1 ) {
	      Tcl_AppendResult(interp, MORE_ARGS_STR, promp[i], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	    thick[i] = atof( argv[arg] ) * local2base;
	    ++arg;
	  }

	  if( etoin(&intern, thick) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	case ID_NMG:
	  promp = p_nmgin;
	  if( argc < arg+1 ) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, promp[0], (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  thick[0] = atof( argv[arg] ) * local2base;
	  ++arg;
	  if( nmgin( &intern , thick[0] ) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;

	default:
	  Tcl_AppendResult(interp, "Cannot find inside for '",
			   rt_functab[intern.idb_type].ft_name, "' solid\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	/* don't allow interrupts while we update the database! */
	(void)signal( SIGINT, SIG_IGN);

	/* Add to in-core directory */
	if( (dp = db_diradd( dbip,  newname, -1, 0, DIR_SOLID, (genptr_t)&intern.idb_type )) == DIR_NULL )  {
	  (void)signal( SIGINT, SIG_IGN );
	  TCL_ALLOC_ERR_return;
	}
	if( rt_db_put_internal( dp, dbip, &intern, &rt_uniresource ) < 0 ) {
	  (void)signal( SIGINT, SIG_IGN );
	  TCL_WRITE_ERR_return;
	}

	/* Draw the new solid */
	{
		char	*arglist[3];
		arglist[0] = "e";
		arglist[1] = newname;
		arglist[2] = NULL;
		return cmd_draw(clientData, interp, 2, arglist );
	}
end:
	(void)signal( SIGINT, SIG_IGN );
	return status;
}


/* finds inside arbs */
int
arbin(
	struct rt_db_internal	*ip,
	fastf_t	thick[6],
	int	nface,
	int	cgtype,		/* # of points, 4..8 */
	plane_t	planes[6])
{
	struct rt_arb_internal	*arb = (struct rt_arb_internal *)ip->idb_ptr;
	point_t		center_pt;
	int		num_pts=8;	/* number of points to solve using rt_arb_3face_intersect */
	int		i;

	RT_ARB_CK_MAGIC(arb);

	/* find reference point (center_pt[3]) to find direction of normals */
	rt_arb_centroid( center_pt, arb, cgtype );

	/* move new face planes for the desired thicknesses
	 * don't do this yet for an arb7 */
	if( cgtype != 7 )
	{
		for(i=0; i<nface; i++) {
			if( (planes[i][3] - VDOT(center_pt, &planes[i][0])) > 0.0 )
				thick[i] *= -1.0;
			planes[i][3] += thick[i];
		}
	}

	if( cgtype == 5 )
		num_pts = 4;	/* use rt_arb_3face_intersect for first 4 points */
	else if( cgtype == 7 )
		num_pts = 0;	/* don't use rt_arb_3face_intersect for any points */

	/* find the new vertices by intersecting the new face planes */
	for(i=0; i<num_pts; i++) {
	  if( rt_arb_3face_intersect( arb->pt[i], (const plane_t *)planes, cgtype, i*3 ) < 0 )  {
	    Tcl_AppendResult(interp, "cannot find inside arb\n", (char *)NULL);
	    return(1);
	  }
	}

	/* The following is code for the special cases of arb5 and arb7
	 * These arbs have a vertex that is the intersection of four planes, and
	 * the inside solid may have a single vertex or an edge replacing this vertex
	 */
	if( cgtype == 5 )
	{
	  /* Here we are only concerned with the one vertex where 4 planes intersect
	   * in the original solid
	   */
	  point_t pt[4];
	  fastf_t dist0,dist1;
	  struct bu_vls tmp_vls;

	  bu_vls_init(&tmp_vls);

	  /* calculate the four possible intersect points */
	  if( bn_mkpoint_3planes( pt[0] , planes[1] , planes[2] , planes[3] ) )
	    {
	      bu_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      bu_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 0:\n" );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	      bu_vls_free(&tmp_vls);
	      return( 1 );
	    }
	  if( bn_mkpoint_3planes( pt[1] , planes[2] , planes[3] , planes[4] ) )
	    {
	      bu_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      bu_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 1:\n" );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	      bu_vls_free(&tmp_vls);
	      return( 1 );
	    }
	  if( bn_mkpoint_3planes( pt[2] , planes[3] , planes[4] , planes[1] ) )
	    {
	      bu_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      bu_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 2:\n" );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[3] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	      bu_vls_free(&tmp_vls);
	      return( 1 );
	    }
	  if( bn_mkpoint_3planes( pt[3] , planes[4] , planes[1] , planes[2] ) )
	    {
	      bu_vls_printf(&tmp_vls, "Cannot find inside arb5\n" );
	      bu_vls_printf(&tmp_vls, "Cannot find intersection of three planes for point 3:\n" );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[4] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[1] ) );
	      bu_vls_printf(&tmp_vls, "\t%f %f %f %f\n" , V4ARGS( planes[2] ) );
	      Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	      bu_vls_free(&tmp_vls);
	      return( 1 );
	    }

		if( bn_pt3_pt3_equal( pt[0] , pt[1] , &mged_tol ) )
		{
			/* if any two of the calculates intersection points are equal,
			 * then all four must be equal
			 */
			for( i=4 ; i<8 ; i++ )
				VMOVE( arb->pt[i] , pt[0] );

			return( 0 );
		}

		/* There will be an edge where the four planes come together
		 * Two edges of intersection have been calculated
		 *     pt[0]<->pt[2]
		 *     pt[1]<->pt[3]
		 * the one closest to the non-invloved plane (planes[0]) is the
		 * one we want
		 */

		dist0 = DIST_PT_PLANE( pt[0] , planes[0] );
		if( dist0 < 0.0 )
			dist0 = (-dist0);

		dist1 = DIST_PT_PLANE( pt[1] , planes[0] );
		if( dist1 < 0.0 )
			dist1 = (-dist1);

		if( dist0 < dist1 )
		{
			VMOVE( arb->pt[5] , pt[0] );
			VMOVE( arb->pt[6] , pt[0] );
			VMOVE( arb->pt[4] , pt[2] );
			VMOVE( arb->pt[7] , pt[2] );
		}
		else
		{
			VMOVE( arb->pt[4] , pt[3] );
			VMOVE( arb->pt[5] , pt[3] );
			VMOVE( arb->pt[6] , pt[1] );
			VMOVE( arb->pt[7] , pt[1] );
		}
	}
	else if( cgtype == 7 )
	{
		struct model *m;
		struct nmgregion *r;
		struct shell *s = NULL;
		struct faceuse *fu;
		struct rt_tess_tol ttol;
		struct bu_ptbl vert_tab;
		struct rt_bot_internal  *bot;

		ttol.magic = RT_TESS_TOL_MAGIC;
		ttol.abs = mged_abs_tol;
		ttol.rel = mged_rel_tol;
		ttol.norm = mged_nrm_tol;

		/* Make a model to hold the inside solid */
		m = nmg_mm();

		/* get an NMG version of this arb7 */
		if( rt_functab[ip->idb_type].ft_tessellate( &r , m , ip , &ttol , &mged_tol ) )
		{
		  Tcl_AppendResult(interp, "Cannot tessellate arb7\n", (char *)NULL);
		  rt_db_free_internal( ip, &rt_uniresource );
		  return( 1 );
		}

		/* move face planes */
		for( i=0 ; i<nface ; i++ )
		{
			int found=0;

			/* look for the face plane with the same geometry as the arb7 planes */
			s = BU_LIST_FIRST( shell , &r->s_hd );
			for( BU_LIST_FOR( fu , faceuse , &s->fu_hd ) )
			{
				struct face_g_plane *fg;
				plane_t pl;

				NMG_CK_FACEUSE( fu );
				if( fu->orientation != OT_SAME )
					continue;

				NMG_GET_FU_PLANE( pl , fu );
				if( bn_coplanar( planes[i] , pl , &mged_tol ) > 0 )
				{
					/* found the NMG face geometry that matches arb face i */
					found = 1;
					fg = fu->f_p->g.plane_p;
					NMG_CK_FACE_G_PLANE( fg );

					/* move the face by distance "thick[i]" */
					if( fu->f_p->flip )
						fg->N[3] += thick[i];
					else
						fg->N[3] -= thick[i];

					break;
				}
			}
			if( !found )
			{
			  struct bu_vls tmp_vls;

			  bu_vls_init(&tmp_vls);
			  bu_vls_printf(&tmp_vls,"Could not move face plane for arb7, face #%d\n",
					i );
			  Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
			  bu_vls_free(&tmp_vls);
			  nmg_km( m );
			  return( 1 );
			}
		}

		/* solve for new vertex geometry
		 * This does all the vertices
		 */
		bu_ptbl( &vert_tab , BU_PTBL_INIT , (long *)NULL );
		nmg_vertex_tabulate( &vert_tab , &m->magic );
		for( i=0 ; i<BU_PTBL_END( &vert_tab ) ; i++ )
		{
			struct vertex *v;

			v = (struct vertex *)BU_PTBL_GET( &vert_tab , i );
			NMG_CK_VERTEX( v );

			if( nmg_in_vert( v , 0 , &mged_tol ) )
			{
			  Tcl_AppendResult(interp, "Could not find coordinates for inside arb7\n",
					   (char *)NULL);
			  nmg_km( m );
			  bu_ptbl( &vert_tab , BU_PTBL_FREE , (long *)NULL );
			  return( 1 );
			}
		}
		bu_ptbl( &vert_tab , BU_PTBL_FREE , (long *)NULL );

		/* rebound model */
		nmg_rebound( m , &mged_tol );

		nmg_extrude_cleanup( s , 0 , &mged_tol );

		/* free old ip pointer */
		rt_db_free_internal( ip, &rt_uniresource );

		/* convert the NMG to a BOT */
		bot = (struct rt_bot_internal *)nmg_bot( s, &mged_tol );
		nmg_km( m );

		/* put new solid in "ip" */
		ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
		ip->idb_type = ID_BOT;
		ip->idb_meth = &rt_functab[ID_BOT];
		ip->idb_ptr = (genptr_t)bot;
	}

	return(0);
}

/*	Calculates inside TGC
 *
 * thick[0] is thickness for base (AxB)
 * thick[1] is thickness for top (CxD)
 * thick[2] is thickness for side
 */
int
tgcin(struct rt_db_internal *ip, fastf_t thick[6])
{
	struct rt_tgc_internal	*tgc = (struct rt_tgc_internal *)ip->idb_ptr;
	vect_t norm;		/* unit vector normal to base */
	fastf_t normal_height;	/* height in direction normal to base */
	vect_t v,h;		/* parameters for inside TGC */
	point_t top;		/* vertex at top of inside TGC */
	fastf_t mag_a,mag_b,mag_c,mag_d; /* lengths of original semi-radii */
	fastf_t new_mag_a,new_mag_b,new_mag_c,new_mag_d; /* new lengths */
	vect_t unit_a,unit_b,unit_c,unit_d; /* unit vectors along semi radii */
	fastf_t ratio;

	RT_TGC_CK_MAGIC(tgc);

	VCROSS( norm, tgc->a, tgc->b )
	VUNITIZE( norm )

	normal_height = VDOT( norm, tgc->h );
	if( normal_height < 0.0 )
	{
		normal_height = (-normal_height);
		VREVERSE( norm, norm )
	}

	if( (thick[0] + thick[1]) >= normal_height )
	{
		Tcl_AppendResult(interp, "TGC shorter than base and top thicknesses\n", (char *)NULL);
		return( 1 );
	}

	mag_a = MAGNITUDE( tgc->a );
	mag_b = MAGNITUDE( tgc->b );
	mag_c = MAGNITUDE( tgc->c );
	mag_d = MAGNITUDE( tgc->d );

	if(( mag_a < VDIVIDE_TOL && mag_c < VDIVIDE_TOL ) ||
	   ( mag_b < VDIVIDE_TOL && mag_d < VDIVIDE_TOL ) )
	{
		Tcl_AppendResult(interp, "TGC is too small too create inside solid", (char *)NULL );
		return( 1 );
	}

	if( mag_a >= VDIVIDE_TOL )
		VSCALE( unit_a, tgc->a, 1.0/mag_a )
	else if( mag_c >= VDIVIDE_TOL )
		VSCALE( unit_a, tgc->c, 1.0/mag_c )

	if( mag_c >= VDIVIDE_TOL )
		VSCALE( unit_c, tgc->c, 1.0/mag_c )
	else if( mag_a >= VDIVIDE_TOL )
		VSCALE( unit_c, tgc->a, 1.0/mag_a )

	if( mag_b >= VDIVIDE_TOL )
		VSCALE( unit_b, tgc->b, 1.0/mag_b )
	else if( mag_d >= VDIVIDE_TOL )
		VSCALE( unit_b, tgc->d, 1.0/mag_d )

	if( mag_d >= VDIVIDE_TOL )
		VSCALE( unit_d, tgc->d, 1.0/mag_d )
	else if( mag_c >= VDIVIDE_TOL )
		VSCALE( unit_d, tgc->b, 1.0/mag_b )

	/* Calculate new vertex from base thickness */
	if( thick[0] != 0.0 )
	{
		/* calculate new vertex using similar triangles */
		ratio = thick[0]/normal_height;
		VJOIN1( v, tgc->v, ratio, tgc->h )

		/* adjust lengths of a and c to account for new vertex position */
		new_mag_a = mag_a + (mag_c - mag_a)*ratio;
		new_mag_b = mag_b + (mag_d - mag_b)*ratio;
	}
	else /* just copy the existing values */
	{
		VMOVE( v, tgc->v )
		new_mag_a = mag_a;
		new_mag_b = mag_b;
	}

	/* calculate new height vector */
	if( thick[1] != 0.0 )
	{
		/* calculate new height vector using simialr triangles */
		ratio = thick[1]/normal_height;
		VJOIN1( top, tgc->v, 1.0 - ratio, tgc->h )

		/* adjust lengths of c and d */
		new_mag_c = mag_c + (mag_a - mag_c)*ratio;
		new_mag_d = mag_d + (mag_b - mag_d)*ratio;
	}
	else /* just copy existing values */
	{
		VADD2( top, tgc->v, tgc->h )
		new_mag_c = mag_c;
		new_mag_d = mag_d;
	}

	/* calculate new height vector based on new vertex and top */
	VSUB2( h, top, v )

	if( thick[2] != 0.0 )	/* ther is a side thickness */
	{
		vect_t ctoa;	/* unit vector from tip of C to tip of A */
		vect_t dtob;	/* unit vector from tip of D to tip of B */
		point_t pt_a, pt_b, pt_c, pt_d;	/* points at tips of semi radii */
		fastf_t delta_ac, delta_bd;	/* radius change for thickness */
		fastf_t dot;	/* dot product */
		fastf_t ratio1,ratio2;

		if( (thick[2] >= new_mag_a || thick[2] >= new_mag_b) &&
		    (thick[2] >= new_mag_c || thick[2] >= new_mag_d) )
		{
			/* can't make a small enough TGC */
			Tcl_AppendResult(interp, "Side thickness too large\n", (char *)NULL );
			return( 1 );
		}

		/* approach this as two 2D problems. One is in the plane containing
		 * the a, h, and c vectors. The other is in the plane containing
		 * the b, h, and d vectors.
		 * In the ahc plane:
		 * Calculate the amount that both a and c must be changed to produce
		 * a normal thickness of thick[2]. Use the vector from tip of c to tip
		 * of a and the unit_a vector to get sine of angle that the normal
		 * side thickness makes with vector a (and so also with vector c).
		 * The amount vectors a and c must change is thick[2]/(cosine of that angle).
		 * Similar for the bhd plane.
		 */

		/* Calculate unit vectors from tips of c/d to tips of a/b */
		VJOIN1( pt_a, v, new_mag_a, unit_a )
		VJOIN1( pt_b, v, new_mag_b, unit_b )
		VJOIN2( pt_c, v, 1.0, h, new_mag_c, unit_c )
		VJOIN2( pt_d, v, 1.0, h, new_mag_d, unit_d )
		VSUB2( ctoa, pt_a, pt_c )
		VSUB2( dtob, pt_b, pt_d )
		VUNITIZE( ctoa )
		VUNITIZE( dtob )

		/* Calculate amount vectors a and c must change */
		dot = VDOT( ctoa, unit_a );
		delta_ac = thick[2]/sqrt( 1.0 - dot*dot );

		/* Calculate amount vectors d and d must change */
		dot = VDOT( dtob, unit_b );
		delta_bd = thick[2]/sqrt( 1.0 - dot*dot );

		if( (delta_ac > new_mag_a || delta_bd > new_mag_b) &&
		    (delta_ac > new_mag_c || delta_bd > new_mag_d) )
		{
			/* Can't make TGC small enough */
			Tcl_AppendResult(interp, "Side thickness too large\n", (char *)NULL );
			return( 1 );
		}

		/* Check if changes will make vectors a or d lengths negative */
		if( delta_ac >= new_mag_c || delta_bd >= new_mag_d )
		{
			/* top vertex (height) must move. Calculate similar triangle ratios */
			if( delta_ac >= new_mag_c )
				ratio1 = (new_mag_a - delta_ac)/(new_mag_a - new_mag_c);
			else
				ratio1 = 1.0;

			if( delta_bd >= new_mag_d )
				ratio2 = (new_mag_b - delta_bd)/(new_mag_b - new_mag_d);
			else
				ratio2 = 1.0;

			/* choose the smallest similar triangle for setting new top vertex */
			if( ratio1 < ratio2 )
				ratio = ratio1;
			else
				ratio = ratio2;

			if( ratio1 == ratio && ratio1 < 1.0 ) /* c vector must go to zero */
				new_mag_c = SQRT_SMALL_FASTF;
			else if( ratio1 > ratio && ratio < 1.0 )
			{
				/* vector d will go to zero, but vector c will not */

				/* calculate original length of vector c at new top vertex */
				new_mag_c = new_mag_c + (new_mag_a - new_mag_c)*( 1.0 - ratio);

				/* now just subtract delta */
				new_mag_c -= delta_ac;
			}
			else /* just change c vector length by delta */
				new_mag_c -= delta_ac;

			if( ratio2 == ratio && ratio2 < 1.0 ) /* vector d must go to zero */
				new_mag_d = SQRT_SMALL_FASTF;
			else if( ratio2 > ratio && ratio < 1.0 )
			{
				/* calculate vector length at new top vertex */
				new_mag_d = new_mag_d + (new_mag_b - new_mag_d)*(1.0 - ratio);

				/* now just subtract delta */
				new_mag_d -= delta_bd;
			}
			else /* just adjust length */
				new_mag_d -= delta_bd;

			VSCALE( h, h, ratio )
			new_mag_a -= delta_ac;
			new_mag_b -= delta_bd;
		}
		else if( delta_ac >= new_mag_a || delta_bd >= new_mag_b)
		{
			/* base vertex (v) must move */

			/* Calculate similar triangle ratios */
			if( delta_ac >= new_mag_a )
				ratio1 = (new_mag_c - delta_ac)/(new_mag_c - new_mag_a);
			else
				ratio1 = 1.0;

			if( delta_bd >= new_mag_b )
				ratio2 = (new_mag_d - delta_bd)/(new_mag_d - new_mag_b);
			else
				ratio2 = 1.0;

			/* select smallest triangle to set new base vertex */
			if( ratio1 < ratio2 )
				ratio = ratio1;
			else
				ratio = ratio2;

			if( ratio1 == ratio && ratio1 < 1.0 ) /* vector a must go to zero */
				new_mag_a = SQRT_SMALL_FASTF;
			else if( ratio1 > ratio && ratio < 1.0 )
			{
				/* calculate length of vector a if it were at new base location */
				new_mag_a = new_mag_c + (new_mag_a - new_mag_c)*ratio;

				/* now just subtract delta */
				new_mag_a -= delta_ac;
			}
			else /* just subtract delta */
				new_mag_a -= delta_ac;

			if( ratio2 == ratio && ratio2 < 1.0 ) /* vector b must go to zero */
				new_mag_b = SQRT_SMALL_FASTF;
			else if( ratio2 > ratio && ratio < 1.0 )
			{
				/* Calculate length of b if it were at new base vector */
				new_mag_b = new_mag_d + (new_mag_b - new_mag_d)*ratio;

				/* now just subtract delta */
				new_mag_b -= delta_bd;
			}
			else /* just subtract delta */
				new_mag_b -= delta_bd;

			/* adjust height vector using smallest similar triangle ratio */
			VJOIN1( v, v, 1.0-ratio, h )
			VSUB2( h, top, v )
			new_mag_c -= delta_ac;
			new_mag_d -= delta_bd;
		}
		else /* just change the vector lengths */
		{
			new_mag_a -= delta_ac;
			new_mag_b -= delta_bd;
			new_mag_c -= delta_ac;
			new_mag_d -= delta_bd;
		}
	}

	/* copy new values into the TGC */
	VMOVE( tgc->v, v )
	VMOVE( tgc->h, h)
	VSCALE( tgc->a, unit_a, new_mag_a )
	VSCALE( tgc->b, unit_b, new_mag_b )
	VSCALE( tgc->c, unit_c, new_mag_c )
	VSCALE( tgc->d, unit_d, new_mag_d )

	return( 0 );
}

/* finds inside of torus */
int
torin(struct rt_db_internal *ip, fastf_t thick[6] )
{
	struct rt_tor_internal	*tor = (struct rt_tor_internal *)ip->idb_ptr;

	RT_TOR_CK_MAGIC(tor);
	if( thick[0] == 0.0 )
		return(0);

	if( thick[0] < 0 ) {
	  if( (tor->r_h - thick[0]) > (tor->r_a + .01) ) {
	    Tcl_AppendResult(interp, "cannot do: r2 > r1\n", (char *)NULL);
	    return(1);
	  }
	}
	if( thick[0] >= tor->r_h ) {
	  Tcl_AppendResult(interp, "cannot do: r2 <= 0\n", (char *)NULL);
	  return(1);
	}

	tor->r_h = tor->r_h - thick[0];
	return(0);
}


/* finds inside ellg */
int
ellgin(struct rt_db_internal *ip, fastf_t thick[6])
{
	struct rt_ell_internal	*ell = (struct rt_ell_internal *)ip->idb_ptr;
	int i, j, k, order[3];
	fastf_t mag[3], nmag[3];
	fastf_t ratio;

	if( thick[0] <= 0.0 )
		return(0);
	thick[2] = thick[1] = thick[0];	/* uniform thickness */

	RT_ELL_CK_MAGIC(ell);
	mag[0] = MAGNITUDE(ell->a);
	mag[1] = MAGNITUDE(ell->b);
	mag[2] = MAGNITUDE(ell->c);

	for(i=0; i<3; i++) {
		order[i] = i;
	}

	for(i=0; i<2; i++) {
		k = i + 1;
		for(j=k; j<3; j++) {
			if(mag[i] < mag[j])
				order[i] = j;
		}
	}

	if( (ratio = mag[order[1]] / mag[order[0]]) < .8 )
		thick[order[1]] = thick[order[1]]/(1.016447*pow(ratio,.071834));
	if( (ratio = mag[order[2]] / mag[order[1]]) < .8 )
		thick[order[2]] = thick[order[2]]/(1.016447*pow(ratio,.071834));

	for(i=0; i<3; i++) {
	  if( (nmag[i] = mag[i] - thick[i]) <= 0.0 ){
	    struct bu_vls tmp_vls;

	    bu_vls_init(&tmp_vls);
	    bu_vls_printf(&tmp_vls, "Warning: new vector [%d] length <= 0 \n", i);
	    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	    bu_vls_free(&tmp_vls);
	  }
	}
	VSCALE(ell->a, ell->a, nmag[0]/mag[0]);
	VSCALE(ell->b, ell->b, nmag[1]/mag[1]);
	VSCALE(ell->c, ell->c, nmag[2]/mag[2]);
	return(0);
}

/* find inside of particle solid */
int
partin(struct rt_db_internal *ip, fastf_t *thick )
{
	struct rt_part_internal	*part = (struct rt_part_internal *)ip->idb_ptr;

	RT_PART_CK_MAGIC( part );

	if(*thick >= part->part_vrad || *thick >= part->part_hrad)
	  return(1);    /* BAD */

	part->part_vrad -= *thick;
	part->part_hrad -= *thick;

	return(0);
}

/* finds inside of rpc, not quite right - r needs to be smaller */
int
rpcin(struct rt_db_internal *ip, fastf_t thick[4])
{
	struct rt_rpc_internal	*rpc = (struct rt_rpc_internal *)ip->idb_ptr;
	fastf_t			b;
	vect_t			Bu, Hu, Ru;

	RT_RPC_CK_MAGIC(rpc);

	/* get unit coordinate axes */
	VMOVE( Bu, rpc->rpc_B );
	VMOVE( Hu, rpc->rpc_H );
	VCROSS( Ru, Hu, Bu );
	VUNITIZE( Bu );
	VUNITIZE( Hu );
	VUNITIZE( Ru );

	b = MAGNITUDE(rpc->rpc_B);
	VJOIN2( rpc->rpc_V, rpc->rpc_V, thick[0], Hu, thick[2], Bu );
	VSCALE( rpc->rpc_H, Hu, MAGNITUDE(rpc->rpc_H) - thick[0] - thick[1] );
	VSCALE( rpc->rpc_B, Bu, b - thick[2] - thick[3] );
#if 0
	bp = b - thick[2] - thick[3];
	rp = rpc->rpc_r - thick[3];	/* !!! ESTIMATE !!! */
	yp = rp * sqrt( (bp - thick[2])/bp );
	VSET( Norm,
		0.,
		2 * bp * yp/(rp * rp),
		-1.);
	VUNITIZE(Norm)
	th = thick[3] / Norm[Y];
	rpc->rpc_r -= th;
#endif
	rpc->rpc_r -= thick[3];

	return(0);
}

/* XXX finds inside of rhc, not quite right */
int
rhcin(struct rt_db_internal *ip, fastf_t thick[4])
{
	struct rt_rhc_internal	*rhc = (struct rt_rhc_internal *)ip->idb_ptr;
	vect_t			Bn, Hn, Bu, Hu, Ru;

	RT_RHC_CK_MAGIC(rhc);

	VMOVE( Bn, rhc->rhc_B );
	VMOVE( Hn, rhc->rhc_H );

	/* get unit coordinate axes */
	VMOVE( Bu, Bn );
	VMOVE( Hu, Hn );
	VCROSS( Ru, Hu, Bu );
	VUNITIZE( Bu );
	VUNITIZE( Hu );
	VUNITIZE( Ru );

	VJOIN2( rhc->rhc_V, rhc->rhc_V, thick[0], Hu, thick[2], Bu );
	VSCALE( rhc->rhc_H, Hu, MAGNITUDE(rhc->rhc_H) - thick[0] - thick[1] );
	VSCALE( rhc->rhc_B, Bu, MAGNITUDE(rhc->rhc_B) - thick[2] - thick[3] );
	rhc->rhc_r -= thick[3];

	return(0);
}

/* finds inside of epa, not quite right */
int
epain(struct rt_db_internal *ip, fastf_t thick[2])
{
	struct rt_epa_internal	*epa = (struct rt_epa_internal *)ip->idb_ptr;
	vect_t			Hu;

	RT_EPA_CK_MAGIC(epa);

	VMOVE( Hu, epa->epa_H );
	VUNITIZE( Hu );

	VJOIN1( epa->epa_V, epa->epa_V, thick[0], Hu );
	VSCALE( epa->epa_H, Hu, MAGNITUDE(epa->epa_H) - thick[0] - thick[1] );
	epa->epa_r1 -= thick[1];
	epa->epa_r2 -= thick[1];

	return(0);
}

/* finds inside of ehy, not quite right, */
int
ehyin(struct rt_db_internal *ip, fastf_t thick[2])
{
	struct rt_ehy_internal	*ehy = (struct rt_ehy_internal *)ip->idb_ptr;
	vect_t			Hu;

	RT_EHY_CK_MAGIC(ehy);

	VMOVE( Hu, ehy->ehy_H );
	VUNITIZE( Hu );

	VJOIN1( ehy->ehy_V, ehy->ehy_V, thick[0], Hu );
	VSCALE( ehy->ehy_H, Hu, MAGNITUDE(ehy->ehy_H) - thick[0] - thick[1] );
	ehy->ehy_r1 -= thick[1];
	ehy->ehy_r2 -= thick[1];

	return(0);
}

/* finds inside of eto */
int
etoin(struct rt_db_internal *ip, fastf_t thick[1])
{
	fastf_t			c;
	struct rt_eto_internal	*eto = (struct rt_eto_internal *)ip->idb_ptr;

	RT_ETO_CK_MAGIC(eto);

	c = 1. - thick[0]/MAGNITUDE(eto->eto_C);
	VSCALE( eto->eto_C, eto->eto_C, c );
	eto->eto_rd -= thick[0];

	return(0);
}

/* find inside for NMG */
int
nmgin( struct rt_db_internal *ip, fastf_t thick )
{
	struct model *m;
	struct nmgregion *r;

	if( ip->idb_type != ID_NMG )
		return( 1 );

	m = (struct model *)ip->idb_ptr;
	NMG_CK_MODEL( m );

	r = BU_LIST_FIRST( nmgregion ,  &m->r_hd );
	while( BU_LIST_NOT_HEAD( r , &m->r_hd ) )
	{
		struct nmgregion *next_r;
		struct shell *s;

		NMG_CK_REGION( r );

		next_r = BU_LIST_PNEXT( nmgregion , &r->l );

		s = BU_LIST_FIRST( shell , &r->s_hd );
		while( BU_LIST_NOT_HEAD( s , &r->s_hd ) )
		{
			struct shell *next_s;

			next_s = BU_LIST_PNEXT( shell , &s->l );

			nmg_shell_coplanar_face_merge( s, &mged_tol, 1 );
			if( !nmg_kill_cracks( s ) )
				(void)nmg_extrude_shell( s , thick , 0 , 0 , &mged_tol );

			s = next_s;
		}

		if( BU_LIST_IS_EMPTY( &r->s_hd ) )
			nmg_kr( r );

		r = next_r;
	}

	if( BU_LIST_IS_EMPTY( &m->r_hd ) )
	{
	  Tcl_AppendResult(interp, "No inside created\n", (char *)NULL);
	  nmg_km( m );
	  return( 1 );
	}
	else
	  return( 0 );
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.12
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.11 2007/01/23 01:13:42 brlcad Exp $ (BRL)";
d52 1
a52 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.12.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.13 2007/09/15 16:23:17 brlcad Exp $ (BRL)";
d52 5
a56 1
#include <string.h>
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.10 2007/01/20 14:36:57 brlcad Exp $ (BRL)";
d195 1
a195 1
        else
d307 1
a307 1
	    	struct rt_arb_internal *arb =
a560 1

@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.9 2006/08/18 19:07:55 brlcad Exp $ (BRL)";
@


14.9
log
@should always initialize structures that utilize magic number checking prior to any use including being passed around as function arguments.  initialize a variety of struct rt_db_internal that were being passed to transform_editing_solid() uninitialized.
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.8 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
@


14.8
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.7 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d180 2
@


14.7
log
@update copyright to 2006
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.6 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d49 1
a49 2


d54 1
a54 1
#include <string.h>
d56 1
a56 1
#include <strings.h>
@


14.6
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.5 2005/10/31 07:30:58 brlcad Exp $ (BRL)";
@


14.5
log
@header cleanup, reorg, and general bug squashing including adding missing headers
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.4 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
a74 2
BU_EXTERN( void nmg_invert_shell , ( struct shell *s , const struct bn_tol *tol ) );

d266 1
a266 1
	  if( rt_arb_calc_planes( planes, intern.idb_ptr, cgtype, &mged_tol ) < 0 )  {
@


14.4
log
@trailing ws
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
d67 2
@


14.3
log
@update copyright to 2005
@
text
@d22 1
a22 1
 *			I N S I D E 
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
d421 1
a421 1
	  
d487 1
a487 1
	  
d536 1
a536 1
 
d592 1
a592 1
	if( cgtype == 5 ) 
d619 1
a619 1
	  
d665 1
a665 1
			
d1149 1
a1149 1
	if( thick[0] <= 0.0 ) 
d1255 1
a1255 1
	
d1258 1
a1258 1
	
d1283 1
a1283 1
	
d1303 1
a1303 1
	
d1306 1
a1306 1
	
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d22 1
a22 1
 *			I N S I D E
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a66 2
#include "db.h"

d421 1
a421 1

d487 1
a487 1

d536 1
a536 1

d592 1
a592 1
	if( cgtype == 5 )
d619 1
a619 1

d665 1
a665 1

d1149 1
a1149 1
	if( thick[0] <= 0.0 )
d1255 1
a1255 1

d1258 1
a1258 1

d1283 1
a1283 1

d1303 1
a1303 1

d1306 1
a1306 1

@


14.3.2.1
log
@Mods to use rt_arb_calc_planes from librt
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/inside.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
d73 2
d266 1
a266 1
	  if (rt_arb_calc_planes(interp, intern.idb_ptr, cgtype, planes, &mged_tol) < 0)  {
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/inside.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
a41 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/inside.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/inside.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d1367 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/inside.c,v 1.2 2004/06/08 22:04:28 morrison Exp $ (BRL)";
d38 1
a38 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d31 1
a31 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/inside.c,v 11.49 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a54 1
#include "externs.h"
@

