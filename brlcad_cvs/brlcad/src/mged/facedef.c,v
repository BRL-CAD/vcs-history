head	14.12;
access;
symbols
	rel-7-10-4:14.12
	STABLE:14.12.0.2
	stable-branch:14.3
	rel-7-10-2:14.12
	rel-7-10-0:14.11
	rel-7-8-4:14.8
	rel-7-8-2:14.7
	rel-7-8-0:14.7
	trimnurbs-branch:14.7.0.2
	help:14.7
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.3.2.1
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.4
	rel-7-6-6:14.4
	rel-7-6-4:14.4
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.12
date	2007.07.26.01.13.58;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.27.01.41.43;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.23.01.13.41;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.20.14.36.57;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.08.18.19.07.55;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.28.00.36.29;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.4;

14.4
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches
	14.3.2.1
	14.3.6.1;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.28;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.23;	author morrison;	state Exp;
branches;
next	;

14.3.2.1
date	2005.09.08.15.56.03;	author bob1961;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.12
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@/*                       F A C E D E F . C
 * BRL-CAD
 *
 * Copyright (c) 1986-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file facedef.c
 *  Authors -
 *	Daniel C. Dender
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.11 2007/01/27 01:41:43 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <signal.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "./ged.h"
#include "./sedit.h"
#include "./mged_solid.h"

extern struct rt_db_internal	es_int;	/* from edsol.c */
extern struct bn_tol		mged_tol;		/* from ged.c */

char *p_rotfb[] = {
	"Enter rot, fb angles: ",
	"Enter fb angle: ",
	"Enter fixed vertex(v#) or point(X Y Z): ",
	"Enter Y, Z of point: ",
	"Enter Z of point: "
};

char *p_3pts[] = {
	"Enter X,Y,Z of point",
	"Enter Y,Z of point",
	"Enter Z of point"
};

char *p_pleqn[] = {
	"Enter A,B,C,D of plane equation: ",
	"Enter B,C,D of plane equation: ",
	"Enter C,D of plane equation: ",
	"Enter D of plane equation: "
};

char *p_nupnt[] = {
	"Enter X,Y,Z of fixed point: ",
	"Enter Y,Z of fixed point: ",
	"Enter Z of fixed point: "
};

static void	get_pleqn(fastf_t *plane, char **argv), get_rotfb(fastf_t *plane, char **argv, const struct rt_arb_internal *arb), get_nupnt(fastf_t *plane, char **argv);
static int	get_3pts(fastf_t *plane, char **argv, const struct bn_tol *tol);

/*
 *			F _ F A C E D E F
 *
 * Redefines one of the defining planes for a GENARB8. Finds
 * which plane to redefine and gets input, then shuttles the process over to
 * one of four functions before calculating new vertices.
 */
int
f_facedef(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	short int 	i;
	int		face,prod,plane;
	struct rt_db_internal	intern;
	struct rt_arb_internal	*arb;
	struct rt_arb_internal	*arbo;
	plane_t		planes[6];
	int status = TCL_OK;

	RT_INIT_DB_INTERNAL(&intern);

	if(argc < 2){
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help facedef");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	if( setjmp( jmp_env ) == 0 )
	  (void)signal( SIGINT, sig3);  /* allow interupts */
	else
	  return TCL_OK;

	if( state != ST_S_EDIT ){
	  Tcl_AppendResult(interp, "Facedef: must be in solid edit mode\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}
	if( es_int.idb_type != ID_ARB8 )  {
	   Tcl_AppendResult(interp, "Facedef: solid type must be ARB\n");
	   status = TCL_ERROR;
	   goto end;
	}

	/* apply es_mat editing to parameters.  "new way" */
	transform_editing_solid( &intern, es_mat, &es_int, 0 );

	arb = (struct rt_arb_internal *)intern.idb_ptr;
	RT_ARB_CK_MAGIC(arb);

	/* find new planes to account for any editing */
	if (rt_arb_calc_planes(interp, arb, es_type, planes, &mged_tol)) {
	  Tcl_AppendResult(interp, "Unable to determine plane equations\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	/* get face, initialize args and argcnt */
	face = atoi( argv[1] );

	/* use product of vertices to distinguish faces */
	for(i=0,prod=1;i<4;i++)  {
		if( face > 0 ){
			prod *= face%10;
			face /= 10;
		}
	}

	switch( prod ){
		case    6:			/* face  123 of arb4 */
		case   24:plane=0;		/* face 1234 of arb8 */
						/* face 1234 of arb7 */
						/* face 1234 of arb6 */
						/* face 1234 of arb5 */
			  if(es_type==4 && prod==24)
				plane=2; 	/* face  234 of arb4 */
			  break;
		case    8:			/* face  124 of arb4 */
		case  180: 			/* face 2365 of arb6 */
		case  210:			/* face  567 of arb7 */
		case 1680:plane=1;      	/* face 5678 of arb8 */
			  break;
		case   30:			/* face  235 of arb5 */
		case  120:			/* face 1564 of arb6 */
		case   20:      		/* face  145 of arb7 */
		case  160:plane=2;		/* face 1584 of arb8 */
			  if(es_type==5)
				plane=4; 	/* face  145 of arb5 */
			  break;
		case   12:			/* face  134 of arb4 */
		case   10:			/* face  125 of arb6 */
		case  252:plane=3;		/* face 2376 of arb8 */
						/* face 2376 of arb7 */
			  if(es_type==5)
				plane=1; 	/* face  125 of arb5 */
			  break;
		case   72:               	/* face  346 of arb6 */
		case   60:plane=4;	 	/* face 1265 of arb8 */
						/* face 1265 of arb7 */
			  if(es_type==5)
				plane=3; 	/* face  345 of arb5 */
			  break;
		case  420:			/* face 4375 of arb7 */
		case  672:plane=5;		/* face 4378 of arb8 */
			  break;
		default:
		  {
		    struct bu_vls tmp_vls;

		    bu_vls_init(&tmp_vls);
		    bu_vls_printf(&tmp_vls, "bad face (product=%d)\n", prod);
		    Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
		    bu_vls_free(&tmp_vls);
		    status = TCL_ERROR;
		    goto end;
		  }
	}

	if( argc < 3 ){
	  /* menu of choices for plane equation definition */
	  Tcl_AppendResult(interp,
			   "\ta   planar equation\n",
			   "\tb   3 points\n",
			   "\tc   rot,fb angles + fixed pt\n",
			   "\td   same plane thru fixed pt\n",
			   "\tq   quit\n\n",
			   MORE_ARGS_STR, "Enter form of new face definition: ", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	switch( argv[2][0] ){
	case 'a':
	  /* special case for arb7, because of 2 4-pt planes meeting */
	  if( es_type == 7 )
	    if( plane!=0 && plane!=3 ){
	      Tcl_AppendResult(interp, "Facedef: can't redefine that arb7 plane\n", (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	  if( argc < 7 ){  	/* total # of args under this option */
	    Tcl_AppendResult(interp, MORE_ARGS_STR, p_pleqn[argc-3], (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  get_pleqn( planes[plane], &argv[3] );
	  break;
	case 'b':
	  /* special case for arb7, because of 2 4-pt planes meeting */
	  if( es_type == 7 )
	    if( plane!=0 && plane!=3 ){
	      Tcl_AppendResult(interp, "Facedef: can't redefine that arb7 plane\n", (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	  if( argc < 12 ){           /* total # of args under this option */
	    struct bu_vls tmp_vls;

	     bu_vls_init(&tmp_vls);
	     bu_vls_printf(&tmp_vls, "%s%s %d: ", MORE_ARGS_STR, p_3pts[(argc-3)%3], argc/3);
	     Tcl_AppendResult(interp, bu_vls_addr(&tmp_vls), (char *)NULL);
	     bu_vls_free(&tmp_vls);
	     status = TCL_ERROR;
	     goto end;
	  }
	  if( get_3pts( planes[plane], &argv[3], &mged_tol) ){
	    status = TCL_ERROR;
	    goto end;
	  }
	  break;
	case 'c':
	  /* special case for arb7, because of 2 4-pt planes meeting */
	  if( es_type == 7 && (plane != 0 && plane != 3) ) {
	    if( argc < 5 ){ 	/* total # of args under this option */
	      Tcl_AppendResult(interp, MORE_ARGS_STR, p_rotfb[argc-3], (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }

	    argv[5] = "Release 6";
	    Tcl_AppendResult(interp, "Fixed point is vertex five.\n");
	  }
	  /* total # of as under this option */
	  else if( argc < 8 && (argc > 5 ? argv[5][0] != 'R' : 1)) {
	    Tcl_AppendResult(interp, MORE_ARGS_STR, p_rotfb[argc-3], (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  get_rotfb(planes[plane], &argv[3], arb);
	  break;
	case 'd':
	  /* special case for arb7, because of 2 4-pt planes meeting */
	  if( es_type == 7 )
	    if( plane!=0 && plane!=3 ){
	      Tcl_AppendResult(interp, "Facedef: can't redefine that arb7 plane\n", (char *)NULL);
	      status = TCL_ERROR;
	      goto end;
	    }
	  if( argc < 6 ){  	/* total # of args under this option */
	    Tcl_AppendResult(interp, MORE_ARGS_STR, p_nupnt[argc-3], (char *)NULL);
	    status = TCL_ERROR;
	    goto end;
	  }
	  get_nupnt(planes[plane], &argv[3]);
	  break;
	case 'q':
	  return TCL_OK;
	default:
	  Tcl_AppendResult(interp, "Facedef: '", argv[2], "' is not an option\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}

	/* find all vertices from the plane equations */
	if( rt_arb_calc_points( arb, es_type, planes, &mged_tol ) < 0 )  {
	  Tcl_AppendResult(interp, "facedef:  unable to find points\n", (char *)NULL);
	  status = TCL_ERROR;
	  goto end;
	}
	/* Now have 8 points, which is the internal form of an ARB8. */

	/* Transform points back before es_mat changes */
	/* This is the "new way" */
	arbo = (struct rt_arb_internal *)es_int.idb_ptr;
	RT_ARB_CK_MAGIC(arbo);

	for(i=0; i<8; i++){
		MAT4X3PNT( arbo->pt[i], es_invmat, arb->pt[i] );
	}
	rt_db_free_internal(&intern, &rt_uniresource);

	/* draw the new solid */
	replot_editing_solid();

end:
	(void)signal( SIGINT, SIG_IGN );
	return status;
}


/*
 * 			G E T _ P L E Q N
 *
 * Gets the planar equation from the array argv[]
 * and puts the result into 'plane'.
 */
static void
get_pleqn(fastf_t *plane, char **argv)
{
	int i;

	if(dbip == DBI_NULL)
	  return;

	for(i=0; i<4; i++)
		plane[i]= atof(argv[i]);
	VUNITIZE( &plane[0] );
	plane[3] *= local2base;
	return;
}


/*
 * 			G E T _ 3 P T S
 *
 *  Gets three definite points from the array argv[]
 *  and finds the planar equation from these points.
 *  The resulting plane equation is stored in 'plane'.
 *
 *  Returns -
 *	 0	success
 *	-1	failure
 */
static int
get_3pts(fastf_t *plane, char **argv, const struct bn_tol *tol)
{
	int i;
	point_t	a,b,c;

	CHECK_DBI_NULL;

	for(i=0; i<3; i++)
		a[i] = atof(argv[0+i]) * local2base;
	for(i=0; i<3; i++)
		b[i] = atof(argv[3+i]) * local2base;
	for(i=0; i<3; i++)
		c[i] = atof(argv[6+i]) * local2base;

	if( bn_mk_plane_3pts( plane, a, b, c, tol ) < 0 )  {
	  Tcl_AppendResult(interp, "Facedef: not a plane\n", (char *)NULL);
	  return(-1);		/* failure */
	}
	return(0);			/* success */
}

/*
 * 			G E T _ R O T F B
 *
 * Gets information from the array argv[].
 * Finds the planar equation given rotation and fallback angles, plus a
 * fixed point. Result is stored in 'plane'. The vertices
 * pointed to by 's_recp' are used if a vertex is chosen as fixed point.
 */
static void
get_rotfb(fastf_t *plane, char **argv, const struct rt_arb_internal *arb)
{
	fastf_t rota, fb;
	short int i,temp;
	point_t		pt;

	if(dbip == DBI_NULL)
	  return;

	rota= atof(argv[0]) * degtorad;
	fb  = atof(argv[1]) * degtorad;

	/* calculate normal vector (length=1) from rot,fb */
	plane[0] = cos(fb) * cos(rota);
	plane[1] = cos(fb) * sin(rota);
	plane[2] = sin(fb);

	if( argv[2][0] == 'v' ){     	/* vertex given */
		/* strip off 'v', subtract 1 */
		temp = atoi(argv[2]+1) - 1;
		plane[3]= VDOT(&plane[0], arb->pt[temp]);
	} else {		         /* definite point given */
		for(i=0; i<3; i++)
			pt[i]=atof(argv[2+i]) * local2base;
		plane[3]=VDOT(&plane[0], pt);
	}
}

/*
 * 			G E T _ N U P N T
 *
 * Gets a point from the three strings in the 'argv' array.
 * The value of D of 'plane' is changed such that the plane
 * passes through the input point.
 */
static void
get_nupnt(fastf_t *plane, char **argv)
{
	int	i;
	point_t	pt;

	if(dbip == DBI_NULL)
	  return;

	for(i=0; i<3; i++)
		pt[i] = atof(argv[i]) * local2base;
	plane[3] = VDOT(&plane[0], pt);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.11
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a23 4
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.10 2007/01/23 01:13:41 brlcad Exp $ (BRL)";
@


14.10
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.9 2007/01/20 14:36:57 brlcad Exp $ (BRL)";
d179 1
a179 1
		 	  break;
@


14.9
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.8 2006/08/18 19:07:55 brlcad Exp $ (BRL)";
@


14.8
log
@should always initialize structures that utilize magic number checking prior to any use including being passed around as function arguments.  initialize a variety of struct rt_db_internal that were being passed to transform_editing_solid() uninitialized.
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2006 United States Government as represented by
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.7 2006/01/28 00:36:29 brlcad Exp $ (BRL)";
@


14.7
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.6 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d101 2
@


14.6
log
@update copyright to 2006
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.5 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d36 1
a36 2


d40 1
@


14.5
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1986-2005 United States Government as represented by
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.4 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
@


14.4
log
@trailing ws
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
d134 1
a134 1
	if( rt_arb_calc_planes( planes, arb, es_type, &mged_tol ) < 0 )  {
@


14.3
log
@update copyright to 2005
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
d125 1
a125 1
	}	
d142 1
a142 1
	
d215 1
a215 1
	case 'a': 
d230 1
a230 1
	case 'b': 
d253 1
a253 1
	case 'c': 
d266 1
a266 1
	  else if( argc < 8 && (argc > 5 ? argv[5][0] != 'R' : 1)) { 
d273 1
a273 1
	case 'd': 
d288 1
a288 1
	case 'q': 
d341 1
a341 1
	return;	
d377 1
a377 1
	
d398 1
a398 1
	
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d125 1
a125 1
	}
d142 1
a142 1

d215 1
a215 1
	case 'a':
d230 1
a230 1
	case 'b':
d253 1
a253 1
	case 'c':
d266 1
a266 1
	  else if( argc < 8 && (argc > 5 ? argv[5][0] != 'R' : 1)) {
d273 1
a273 1
	case 'd':
d288 1
a288 1
	case 'q':
d341 1
a341 1
	return;
d377 1
a377 1

d398 1
a398 1

@


14.3.2.1
log
@Mods to use rt_arb_calc_planes from librt
@
text
@d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/facedef.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
d134 1
a134 1
	if (rt_arb_calc_planes(interp, arb, es_type, planes, &mged_tol)) {
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2004 United States Government as represented by
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/facedef.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			F A C E D E F . C
a28 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
d31 1
a31 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/facedef.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/facedef.c,v 1.2 2004/06/08 22:04:28 morrison Exp $ (BRL)";
d420 10
@


1.2
log
@obliterate externs.h
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d19 1
a19 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d16 1
a16 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/facedef.c,v 11.28 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a28 1
#include "externs.h"
@

