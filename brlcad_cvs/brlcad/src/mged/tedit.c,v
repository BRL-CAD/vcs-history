head	14.31;
access;
symbols
	rel-7-10-4:14.20.2.1
	STABLE:14.20.0.2
	stable-branch:14.3
	rel-7-10-2:14.19
	rel-7-10-0:14.17
	rel-7-8-4:14.12
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.8.0.2
	help:14.8
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.6
	rel-7-6-2:14.5
	rel-7-6-branch:14.5.0.2
	rel-7-6-0:14.5
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.31
date	2007.12.15.09.09.42;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.12.14.13.11.28;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.12.02.22.34.23;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.11.21.20.49.09;	author erikgreenwald;	state Exp;
branches;
next	14.27;

14.27
date	2007.11.21.19.49.12;	author erikgreenwald;	state Exp;
branches;
next	14.26;

14.26
date	2007.10.31.08.39.03;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.10.29.05.27.33;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.09.27.22.36.09;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.09.18.19.36.57;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.09.15.16.23.18;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.09.15.03.26.47;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.08.30.05.16.52;	author brlcad;	state Exp;
branches
	14.20.2.1;
next	14.19;

14.19
date	2007.05.20.20.21.16;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.04.23.13.30.20;	author joevalleyfield;	state Exp;
branches;
next	14.17;

14.17
date	2007.02.20.07.46.30;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.02.20.00.49.48;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.44;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.42;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.58;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.09.08.36.38;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.07.16.04.39;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.07.09.19.17.16;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.04.06.20.50.03;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.23.06.32.37;	author brlcad;	state Exp;
branches
	14.8.2.1;
next	14.7;

14.7
date	2006.01.18.06.46.19;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.08.21.13.56.30;	author brlcad;	state Exp;
branches
	14.5.2.1;
next	14.4;

14.4
date	2005.05.28.02.14.52;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.06;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.17.27;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.29;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.28;	author morrison;	state Exp;
branches;
next	;

14.5.2.1
date	2005.11.13.13.46.18;	author brlcad;	state Exp;
branches;
next	;

14.8.2.1
date	2006.04.07.19.30.28;	author jlowenz;	state Exp;
branches;
next	;

14.20.2.1
date	2007.09.28.14.04.35;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.31
log
@we have getenv()
@
text
@/*                         T E D I T . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file tedit.c
 *
 * Functions -
 *	f_tedit		Run text editor on numerical parameters of solid
 *	writesolid	Write numerical parameters of solid into a file
 *	readsolid	Read numerical parameters of solid from file
 *	editit		Run $EDITOR on temp file
 *
 *  Author -
 *	Michael John Muuss
 *	(Inspired by 4.2 BSD program "vipw")
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.30 2007/12/14 13:11:28 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>

#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"

#include "./ged.h"
#include "./sedit.h"
#include "./mged_dm.h"


#define V3BASE2LOCAL( _pt )	(_pt)[X]*base2local , (_pt)[Y]*base2local , (_pt)[Z]*base2local
#define V4BASE2LOCAL( _pt )	(_pt)[X]*base2local , (_pt)[Y]*base2local , (_pt)[Z]*base2local , (_pt)[W]*base2local

/* editors to test, in order of discovery preference (EDITOR overrides) */
#define WIN_EDITOR "notepad"
#define MAC_EDITOR "/Applications/TextEdit.app/Contents/MacOS/TextEdit"
#define	EMACS_EDITOR "/usr/bin/emacs"
#define	VIM_EDITOR "/usr/bin/vim"
#define	VI_EDITOR "/usr/bin/vi"
#define	ED_EDITOR "/bin/ed"

/* used to invoke the above editor if X11 is in use */
#define XTERM_BINARY "/usr/X11R6/bin/xterm"

extern struct rt_db_internal	es_int;
extern struct rt_db_internal	es_int_orig;

static char	tmpfil[MAXPATHLEN] = {0};

int writesolid(void), readsolid(void);
int editit(const char *file);

int
f_tedit(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	register int i;
	FILE *fp;

	CHECK_DBI_NULL;
	CHECK_READ_ONLY;

	if (argc < 1 || 1 < argc) {
	  struct bu_vls vls;

	  bu_vls_init(&vls);
	  bu_vls_printf(&vls, "help ted");
	  Tcl_Eval(interp, bu_vls_addr(&vls));
	  bu_vls_free(&vls);
	  return TCL_ERROR;
	}

	/* Only do this if in solid edit state */
	if (not_state(ST_S_EDIT, "Primitive Text Edit"))
	  return TCL_ERROR;

	fp = bu_temp_file(tmpfil, MAXPATHLEN);
	if (fp == NULL) {
	  return TCL_ERROR;
	}

	if (writesolid()) {
	  (void)unlink(tmpfil);
	  return TCL_ERROR;
	}

	if (editit(tmpfil)) {
		if (readsolid()) {
		  (void)unlink(tmpfil);
		  return TCL_ERROR;
		}

		/* Update the display */
		replot_editing_solid();
		view_state->vs_flag = 1;
		Tcl_AppendResult(interp, "done\n", (char *)NULL);
	}

	if (fp) {
	    fclose(fp);
	    fp = NULL;
	}
	unlink(tmpfil);

	return TCL_OK;
}

/* Write numerical parameters of a solid into a file */
int
writesolid(void)
{
	register int i;
	FILE *fp;

	CHECK_DBI_NULL;

	fp = fopen(tmpfil, "w");

	/* Print solid parameters, 1 vector or point per line */
	switch( es_int.idb_type )
	{
		struct rt_tor_internal *tor;
		struct rt_tgc_internal *tgc;
		struct rt_ell_internal *ell;
		struct rt_arb_internal *arb;
		struct rt_half_internal *haf;
		struct rt_grip_internal *grip;
		struct rt_rpc_internal *rpc;
		struct rt_rhc_internal *rhc;
		struct rt_epa_internal *epa;
		struct rt_ehy_internal *ehy;
		struct rt_eto_internal *eto;
		struct rt_part_internal *part;
		struct rt_superell_internal *superell;

		default:
		  Tcl_AppendResult(interp, "Cannot text edit this solid type\n", (char *)NULL);
		  (void)fclose(fp);
		  return( 1 );
		case ID_TOR:
			tor = (struct rt_tor_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( tor->v ) );
			(void)fprintf( fp , "Normal: %.9f %.9f %.9f\n", V3BASE2LOCAL( tor->h ) );
			(void)fprintf( fp , "radius_1: %.9f\n", tor->r_a*base2local );
			(void)fprintf( fp , "radius_2: %.9f\n", tor->r_h*base2local );
			break;
		case ID_TGC:
		case ID_REC:
			tgc = (struct rt_tgc_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->v ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->h ) );
			(void)fprintf( fp , "A: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->a ) );
			(void)fprintf( fp , "B: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->b ) );
			(void)fprintf( fp , "C: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->c ) );
			(void)fprintf( fp , "D: %.9f %.9f %.9f\n", V3BASE2LOCAL( tgc->d ) );
			break;
		case ID_ELL:
		case ID_SPH:
			ell = (struct rt_ell_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( ell->v ) );
			(void)fprintf( fp , "A: %.9f %.9f %.9f\n", V3BASE2LOCAL( ell->a ) );
			(void)fprintf( fp , "B: %.9f %.9f %.9f\n", V3BASE2LOCAL( ell->b ) );
			(void)fprintf( fp , "C: %.9f %.9f %.9f\n", V3BASE2LOCAL( ell->c ) );
			break;
		case ID_ARB8:
			arb = (struct rt_arb_internal *)es_int.idb_ptr;
			for( i=0 ; i<8 ; i++ )
				(void)fprintf( fp , "pt[%d]: %.9f %.9f %.9f\n", i+1 , V3BASE2LOCAL( arb->pt[i] ) );
			break;
		case ID_HALF:
			haf = (struct rt_half_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Plane: %.9f %.9f %.9f %.9f\n" , V4BASE2LOCAL( haf->eqn ) );
			break;
		case ID_GRIP:
			grip = (struct rt_grip_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Center: %.9f %.9f %.9f\n" , V3BASE2LOCAL( grip->center ) );
			(void)fprintf( fp , "Normal: %.9f %.9f %.9f\n" , V3BASE2LOCAL( grip->normal ) );
			(void)fprintf( fp , "Magnitude: %.9f\n" , grip->mag*base2local );
			break;
		case ID_PARTICLE:
			part = (struct rt_part_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( part->part_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( part->part_H ) );
			(void)fprintf( fp , "v radius: %.9f\n", part->part_vrad * base2local );
			(void)fprintf( fp , "h radius: %.9f\n", part->part_hrad * base2local );
			break;
		case ID_RPC:
			rpc = (struct rt_rpc_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rpc->rpc_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rpc->rpc_H ) );
			(void)fprintf( fp , "Breadth: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rpc->rpc_B ) );
			(void)fprintf( fp , "Half-width: %.9f\n" , rpc->rpc_r * base2local );
			break;
		case ID_RHC:
			rhc = (struct rt_rhc_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rhc->rhc_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rhc->rhc_H ) );
			(void)fprintf( fp , "Breadth: %.9f %.9f %.9f\n" , V3BASE2LOCAL( rhc->rhc_B ) );
			(void)fprintf( fp , "Half-width: %.9f\n" , rhc->rhc_r * base2local );
			(void)fprintf( fp , "Dist_to_asymptotes: %.9f\n" , rhc->rhc_c * base2local );
			break;
		case ID_EPA:
			epa = (struct rt_epa_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( epa->epa_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( epa->epa_H ) );
			(void)fprintf( fp , "Semi-major axis: %.9f %.9f %.9f\n" , V3ARGS( epa->epa_Au ) );
			(void)fprintf( fp , "Semi-major length: %.9f\n" , epa->epa_r1 * base2local );
			(void)fprintf( fp , "Semi-minor length: %.9f\n" , epa->epa_r2 * base2local );
			break;
		case ID_EHY:
			ehy = (struct rt_ehy_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( ehy->ehy_V ) );
			(void)fprintf( fp , "Height: %.9f %.9f %.9f\n" , V3BASE2LOCAL( ehy->ehy_H ) );
			(void)fprintf( fp , "Semi-major axis: %.9f %.9f %.9f\n" , V3ARGS( ehy->ehy_Au ) );
			(void)fprintf( fp , "Semi-major length: %.9f\n" , ehy->ehy_r1 * base2local );
			(void)fprintf( fp , "Semi-minor length: %.9f\n" , ehy->ehy_r2 * base2local );
			(void)fprintf( fp , "Dist to asymptotes: %.9f\n" , ehy->ehy_c * base2local );
			break;
		case ID_ETO:
			eto = (struct rt_eto_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n" , V3BASE2LOCAL( eto->eto_V ) );
			(void)fprintf( fp , "Normal: %.9f %.9f %.9f\n" , V3BASE2LOCAL( eto->eto_N ) );
			(void)fprintf( fp , "Semi-major axis: %.9f %.9f %.9f\n" , V3BASE2LOCAL( eto->eto_C ) );
			(void)fprintf( fp , "Semi-minor length: %.9f\n" , eto->eto_rd * base2local );
			(void)fprintf( fp , "Radius of roation: %.9f\n" , eto->eto_r * base2local );
			break;
		case ID_SUPERELL:
			superell = (struct rt_superell_internal *)es_int.idb_ptr;
			(void)fprintf( fp , "Vertex: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->v ) );
			(void)fprintf( fp , "A: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->a ) );
			(void)fprintf( fp , "B: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->b ) );
			(void)fprintf( fp , "C: %.9f %.9f %.9f\n", V3BASE2LOCAL( superell->c ) );
			(void)fprintf( fp , "<n,e>: <%.9f, %.9f>\n", superell->n, superell->e);
			break;
	}

	(void)fclose(fp);
	return( 0 );
}

static char *
Get_next_line(FILE *fp)
{
	static char line[RT_MAXLINE];
	int i;
	int len;

	if( bu_fgets( line , sizeof( line ) , fp ) == NULL )
		return( (char *)NULL );

	len = strlen( line );

	i = 0;
	while( i<len && line[i++] != ':' );

	if( i == len || line[i] == '\0' )
		return( (char *)NULL );

	return( &line[i] );
}

/* Read numerical parameters of solid from file */
int
readsolid(void)
{
	register int i;
	FILE *fp;
	int ret_val=0;

	CHECK_DBI_NULL;

	fp = fopen(tmpfil, "r");
	if( fp == NULL )  {
		perror(tmpfil);
		return 1;	/* FAIL */
	}

	switch( es_int.idb_type )
	{
		struct rt_tor_internal *tor;
		struct rt_tgc_internal *tgc;
		struct rt_ell_internal *ell;
		struct rt_arb_internal *arb;
		struct rt_half_internal *haf;
		struct rt_grip_internal *grip;
		struct rt_rpc_internal *rpc;
		struct rt_rhc_internal *rhc;
		struct rt_epa_internal *epa;
		struct rt_ehy_internal *ehy;
		struct rt_eto_internal *eto;
		struct rt_part_internal *part;
		struct rt_superell_internal *superell;
		char *str;
		double a,b,c,d;

		default:
		  Tcl_AppendResult(interp, "Cannot text edit this solid type\n", (char *)NULL);
		  ret_val = 1;
		  break;
		case ID_TOR:
			tor = (struct rt_tor_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tor->v , a , b , c );
			VSCALE( tor->v , tor->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tor->h , a , b , c );
			VUNITIZE( tor->h );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			tor->r_a = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			tor->r_h = a * local2base;
			break;
		case ID_TGC:
		case ID_REC:
			tgc = (struct rt_tgc_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->v , a , b , c );
			VSCALE( tgc->v , tgc->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->h , a , b , c );
			VSCALE( tgc->h , tgc->h , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->a , a , b , c );
			VSCALE( tgc->a , tgc->a , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->b , a , b , c );
			VSCALE( tgc->b , tgc->b , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->c , a , b , c );
			VSCALE( tgc->c , tgc->c , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( tgc->d , a , b , c );
			VSCALE( tgc->d , tgc->d , local2base );

			break;
		case ID_ELL:
		case ID_SPH:
			ell = (struct rt_ell_internal *)es_int.idb_ptr;

			fprintf(stderr, "ID_SPH\n");

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ell->v , a , b , c );
			VSCALE( ell->v , ell->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ell->a , a , b , c );
			VSCALE( ell->a , ell->a , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ell->b , a , b , c );
			VSCALE( ell->b , ell->b , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ell->c , a , b , c );
			VSCALE( ell->c , ell->c , local2base );
			break;
		case ID_ARB8:
			arb = (struct rt_arb_internal *)es_int.idb_ptr;
			for( i=0 ; i<8 ; i++ )
			{
				if( (str=Get_next_line( fp )) == NULL )
				{
					ret_val = 1;
					break;
				}
				(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
				VSET( arb->pt[i] , a , b , c );
				VSCALE( arb->pt[i] , arb->pt[i] , local2base );
			}
			break;
		case ID_HALF:
			haf = (struct rt_half_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf %lf" , &a , &b , &c , &d );
			VSET( haf->eqn , a , b , c );
			haf->eqn[W] = d * local2base;
			break;
		case ID_GRIP:
			grip = (struct rt_grip_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( grip->center , a , b , c );
			VSCALE( grip->center , grip->center , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( grip->normal , a , b , c );
			break;
		case ID_PARTICLE:
			part = (struct rt_part_internal *)es_int.idb_ptr;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( part->part_V , a , b , c );
			VSCALE( part->part_V , part->part_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( part->part_H , a , b , c );
			VSCALE( part->part_H , part->part_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			part->part_vrad = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			part->part_hrad = a * local2base;

			break;
		case ID_RPC:
			rpc = (struct rt_rpc_internal *)es_int.idb_ptr;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rpc->rpc_V , a , b , c );
			VSCALE( rpc->rpc_V , rpc->rpc_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rpc->rpc_H , a , b , c );
			VSCALE( rpc->rpc_H , rpc->rpc_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rpc->rpc_B , a , b , c );
			VSCALE( rpc->rpc_B , rpc->rpc_B , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			rpc->rpc_r = a * local2base;
			break;
		case ID_RHC:
			rhc = (struct rt_rhc_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rhc->rhc_V , a , b , c );
			VSCALE( rhc->rhc_V , rhc->rhc_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rhc->rhc_H , a , b , c );
			VSCALE( rhc->rhc_H , rhc->rhc_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( rhc->rhc_B , a , b , c );
			VSCALE( rhc->rhc_B , rhc->rhc_B , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			rhc->rhc_r = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			rhc->rhc_c = a * local2base;
			break;
		case ID_EPA:
			epa = (struct rt_epa_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( epa->epa_V , a , b , c );
			VSCALE( epa->epa_V , epa->epa_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( epa->epa_H , a , b , c );
			VSCALE( epa->epa_H , epa->epa_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( epa->epa_Au , a , b , c );
			VUNITIZE( epa->epa_Au );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			epa->epa_r1 = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			epa->epa_r2 = a * local2base;
			break;
		case ID_EHY:
			ehy = (struct rt_ehy_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ehy->ehy_V , a , b , c );
			VSCALE( ehy->ehy_V , ehy->ehy_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ehy->ehy_H , a , b , c );
			VSCALE( ehy->ehy_H , ehy->ehy_H , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( ehy->ehy_Au , a , b , c );
			VUNITIZE( ehy->ehy_Au );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			ehy->ehy_r1 = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			ehy->ehy_r2 = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			ehy->ehy_c = a * local2base;
			break;
		case ID_ETO:
			eto = (struct rt_eto_internal *)es_int.idb_ptr;
			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( eto->eto_V , a , b , c );
			VSCALE( eto->eto_V , eto->eto_V , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( eto->eto_N , a , b , c );
			VUNITIZE( eto->eto_N );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( eto->eto_C , a , b , c );
			VSCALE( eto->eto_C , eto->eto_C , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			eto->eto_rd = a * local2base;

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf" , &a );
			eto->eto_r = a * local2base;
			break;
		case ID_SUPERELL:
			superell = (struct rt_superell_internal *)es_int.idb_ptr;

			fprintf(stderr, "ID_SUPERELL\n");

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->v , a , b , c );
			VSCALE( superell->v , superell->v , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->a , a , b , c );
			VSCALE( superell->a , superell->a , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->b , a , b , c );
			VSCALE( superell->b , superell->b , local2base );

			if( (str=Get_next_line( fp )) == NULL )
			{
				ret_val = 1;
				break;
			}
			(void)sscanf( str , "%lf %lf %lf" , &a , &b , &c );
			VSET( superell->c , a , b , c );
			VSCALE( superell->c , superell->c , local2base );

			if ( (str=Get_next_line( fp )) == NULL ) {
			  ret_val = 1;
			  break;
			}
			(void) sscanf( str, "%lf %lf", &superell->n, &superell->e);
			break;
	}

	(void)fclose(fp);
	return( ret_val );
}


/* Run $EDITOR on temp file, defaulting to various system-specific
 * editors otherwise if unset.
 *
 * BUGS -- right now we only check at compile time whether or not to
 * pop up an X window to display into (for editors that do not open
 * their own window like vi or jove).  If we have X support, we
 * automatically use xterm (regardless of whether the user is running
 * mged in console mode!)
 */
int
editit(const char *file)
{
	register int pid = 0;
	register int xpid = 0;
	char buffer[RT_MAXLINE] = {0};
	const char *editor = (char *)NULL;
	int stat = 0;
	void (*s2)();
	void (*s3)();

	editor = Tcl_GetVar(interp,"editor", TCL_GLOBAL_ONLY);
	if(!editor || editor[0] == '\0')
	    editor = Tcl_GetVar(interp,"EDITOR", TCL_GLOBAL_ONLY);

	if(!editor || editor[0] == '\0')
	    editor = getenv("EDITOR");

	/* still unset? try windows */
	if (!editor || editor[0] == '\0') {
#ifdef DM_WGL
	    editor = WIN_EDITOR;
#else
	    editor = (char *)NULL;
#endif
	}

	/* still unset? try mac os x */
	if (!editor || editor[0] == '\0') {
	    if (bu_file_exists(MAC_EDITOR)) {
		editor = MAC_EDITOR;
	    }
	}

	/* still unset? try emacs */
	if (!editor || editor[0] == '\0') {
	    if (bu_file_exists(EMACS_EDITOR)) {
		editor = EMACS_EDITOR;
	    }
	}

	/* still unset? try vim */
	if (!editor || editor[0] == '\0') {
	    if (bu_file_exists(VIM_EDITOR)) {
		editor = VIM_EDITOR;
	    }
	}

	/* still unset? try vi */
	if (!editor || editor[0] == '\0') {
	    if (bu_file_exists(VI_EDITOR)) {
		editor = VI_EDITOR;
	    }
	}

	/* still unset? try ed */
	if (!editor || editor[0] == '\0') {
	    if (bu_file_exists(ED_EDITOR)) {
		editor = ED_EDITOR;
	    }
	}

	/* still unset? default to jove */
	if (!editor || editor[0] == '\0') {
	    const char *binpath = bu_brlcad_root("bin", 1);
	    editor = "jove";
	    if (!binpath) {
		snprintf(buffer, RT_MAXLINE, "%s/%s", binpath, editor);
		if (bu_file_exists(buffer)) {
		    editor = buffer;
		} else {
		    const char *dirn = bu_dirname(bu_argv0());
		    if (dirn) {
			snprintf(buffer, RT_MAXLINE, "%s/%s", dirn, editor);
			if (bu_file_exists(buffer)) {
			    editor = buffer;
			}
		    }
		}
	    }
	}

	bu_log("Invoking %s on %s\n", editor, file);
	bu_log("NOTE: YOU MUST QUIT %s BEFORE MGED WILL RESPOND AND CONTINUE\n", bu_basename(editor));

#if defined(SIGINT) && defined(SIGQUIT)
	s2 = signal( SIGINT, SIG_IGN );
	s3 = signal( SIGQUIT, SIG_IGN );
#endif

#ifdef HAVE_UNISTD_H
	if ((pid = fork()) < 0) {
		perror("fork");
		return (0);
	}
#endif

	if (pid == 0) {
		/* Don't call bu_log() here in the child! */

#if defined(SIGINT) && defined(SIGQUIT)
		/* deja vu */
		(void)signal( SIGINT, SIG_DFL );
		(void)signal( SIGQUIT, SIG_DFL );
#endif

		{
#if defined(DM_WGL)
		    STARTUPINFO si = {0};
		    PROCESS_INFORMATION pi = {0};
		    si.cb = sizeof(STARTUPINFO);
		    si.lpReserved = NULL;
		    si.lpReserved2 = NULL;
		    si.cbReserved2 = 0;
		    si.lpDesktop = NULL;
		    si.dwFlags = 0;

		    snprintf(buffer, RT_MAXLINE, "%s %s", editor, file);

		    CreateProcess(NULL, buffer, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi);
		    WaitForSingleObject( pi.hProcess, INFINITE );
		    return 0;
#else /* !DM_WGL */

#  if defined(DM_X) || defined(DM_OGL)
		    /* if we have x support, pop open the editor in an
		     * xterm.  otherwise, use whatever the user gave.
		     */
		    if (bu_file_exists(XTERM_BINARY)) {
			(void)execlp(XTERM_BINARY, XTERM_BINARY, "-e", editor, file, (char *)0);
		    }
#  endif /* DM_X || DM_OGL */
		    (void)execlp(editor, editor, file, NULL);

#endif /* DM_WGL */
		    /* should not reach */
		    perror(editor);
		    bu_exit(1, NULL);
		}
	}

#ifdef HAVE_UNISTD_H
	/* wait for the editor to terminate */
	while ((xpid = wait(&stat)) >= 0) {
	    if (xpid == pid) {
		break;
	    }
	}
#endif

#if defined(SIGINT) && defined(SIGQUIT)
	(void)signal(SIGINT, s2);
	(void)signal(SIGQUIT, s3);
#endif

	return (!stat);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.30
log
@more usage of bu_temp_file() instead of mktemp/mkstemp for better generalized temp file management.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.29 2007/12/02 22:34:23 brlcad Exp $ (BRL)";
a859 1
#ifdef HAVE_GETENV
a861 1
#endif
@


14.29
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.28 2007/11/21 20:49:09 erikgreenwald Exp $ (BRL)";
d87 1
a87 6
static char	tmpfil[17];
#ifndef _WIN32
static char	*tmpfil_init = "/tmp/GED.aXXXXXX";
#else
static char	*tmpfil_init = "c:\\GED.aXXXXXX";
#endif
d96 1
d101 1
a101 1
	if(argc < 1 || 1 < argc){
d112 1
a112 1
	if( not_state( ST_S_EDIT, "Primitive Text Edit" ) )
d115 2
a116 10
	strncpy(tmpfil, tmpfil_init, 17-1);
#ifdef _WIN32
	(void)mktemp(tmpfil);
	i=creat(tmpfil, 0600);
#else
	i = mkstemp(tmpfil);
#endif
	if( i < 0 )
	{
	  perror(tmpfil);
a118 1
	(void)close(i);
d120 1
a120 2
	if( writesolid() )
	{
d125 2
a126 4
	if( editit( tmpfil ) )
	{
		if( readsolid() )
		{
d136 6
a141 1
	(void)unlink(tmpfil);
@


14.28
log
@pass bu_exit a NULL instead of an empty string
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.27 2007/11/21 19:49:12 erikgreenwald Exp $ (BRL)";
d119 1
a119 1
	strcpy(tmpfil, tmpfil_init);
d925 1
a925 1
		sprintf(buffer, "%s/%s", binpath, editor);
d931 1
a931 1
			sprintf(buffer, "%s/%s", dirn, editor);
d975 1
a975 1
		    sprintf(buffer, "%s %s", editor, file);
@


14.27
log
@exit->bu_exit where applicable
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.26 2007/10/31 08:39:03 brlcad Exp $ (BRL)";
d995 1
a995 1
		    bu_exit(1, "");
@


14.26
log
@quell warnings
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.25 2007/10/29 05:27:33 brlcad Exp $ (BRL)";
d995 1
a995 1
		    exit(1);
@


14.25
log
@quell constness warnings, make the editor string const
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.24 2007/09/27 22:36:09 brlcad Exp $ (BRL)";
a955 1
		register int i;
d990 1
a990 1
		    (void)execlp(editor, editor, file, 0);
@


14.24
log
@only report the basename of the editor
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.23 2007/09/18 19:36:57 erikgreenwald Exp $ (BRL)";
d862 1
a862 1
	char *editor = (char *)NULL;
@


14.23
log
@search the tcl environment for an editor variable
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.22 2007/09/15 16:23:18 brlcad Exp $ (BRL)";
d941 1
a941 1
	bu_log("NOTE: YOU MUST QUIT %s BEFORE MGED WILL RESPOND AND CONTINUE\n", editor);
@


14.22
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.21 2007/09/15 03:26:47 brlcad Exp $ (BRL)";
d867 4
d872 2
a873 1
	editor = getenv("EDITOR");
@


14.21
log
@limits.h, locale.h, setjmp.g, and signal.h now all assumed as well as part of ongoing c89 migration.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.20 2007/08/30 05:16:52 brlcad Exp $ (BRL)";
d46 2
a47 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.20
log
@check for vim before looking for vi, add comments on order preference, and don't invoke xterm if we're IF_TK.  this fixes sf feature request 1219084 (default editor vim instead of vi suggested)
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.19 2007/05/20 20:21:16 brlcad Exp $ (BRL)";
d941 1
a941 1
#ifdef HAVE_SIGNAL_H
d957 1
a957 1
#ifdef HAVE_SIGNAL_H
d1007 1
a1007 1
#ifdef HAVE_SIGNAL_H
@


14.20.2.1
log
@more merging from HEAD.  bring in build system tweakage updates that should fix some library symbol problems from croping up post-release.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.24 2007/09/27 22:36:09 brlcad Exp $ (BRL)";
d46 5
a50 2
#include <string.h>

a869 4
	editor = Tcl_GetVar(interp,"editor", TCL_GLOBAL_ONLY);
	if(!editor || editor[0] == '\0')
	    editor = Tcl_GetVar(interp,"EDITOR", TCL_GLOBAL_ONLY);

d871 1
a871 2
	if(!editor || editor[0] == '\0')
	    editor = getenv("EDITOR");
d939 1
a939 1
	bu_log("NOTE: YOU MUST QUIT %s BEFORE MGED WILL RESPOND AND CONTINUE\n", bu_basename(editor));
d941 1
a941 1
#if defined(SIGINT) && defined(SIGQUIT)
d957 1
a957 1
#if defined(SIGINT) && defined(SIGQUIT)
d1007 1
a1007 1
#if defined(SIGINT) && defined(SIGQUIT)
@


14.19
log
@change bu_argv0() to not take any parameters, preferring instead that apps only use bu_setprogname(), passing the full argv[0].
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.18 2007/04/23 13:30:20 joevalleyfield Exp $ (BRL)";
d76 1
a76 4
#define	ED_EDITOR "/bin/ed"
#define	VI_EDITOR "/usr/bin/vi"
#define	EMACS_EDITOR "/usr/bin/emacs"
#define XTERM_EDITOR "/usr/X11R6/bin/xterm"
d79 7
a884 1
#ifdef __APPLE__
a887 3
#else
	    editor = (char *)NULL;
#endif
d897 7
d981 1
a981 1
#  if defined(DM_X) || defined(DM_TK) || defined(DM_OGL)
d985 2
a986 2
		    if (bu_file_exists(XTERM_EDITOR)) {
			(void)execlp(XTERM_EDITOR, XTERM_EDITOR, "-e", editor, file, (char *)0);
@


14.18
log
@preliminary support for unaccelerated mgen on aqua through dm-tk

configure.ac:
        - use two levels of expansion for BRLCAD_DATA
        - enable_aqua configure option
        - move X11 ac_ macro tests from argument check section
        - rely on AC_PATH_XTRA to figure out most of what we need to know about
                where to find X
        - no longer look for libICE, libXmu, or libXsm  AC_PATH_XTRA
                populates X_PRE_LIBS with these but they seem completely unused
                right now.
        - look for opengl libs and headers in all of the places AC_PATH_XTRA
                looked for the xlibs
        - use tk's xlib headers when using tk-aqua rather than x
        - remove X11 "ugly hack"
        - include tk flags where necessary
        - remove --disable-shared from subconfigs
        - forcibly add tcl and tk build dirs to libtool wrapper scripts
libdm/Makefile.am, dm-tk.[ch], dm.h, dm-generic.c, dm_obj.c, mged/Makefile.am,
                attach.c, dm-generic.c, dm-tk.c, ged.c:
        - use lower case when referring to tk
        - add support for using dm-tk
        - include X_CFLAGS with DM_X
irprep/Makefile.am, util/Makefile.am:
        - disable build of ir-X, pl-X when there is no X
dm-X.c:
        - no need to test for HAVE_X11_XLIB here; if we don't have it we
                shouldn't be building this file
libfb/Makefile.am, if_tk.c, libfb/tcl.c:
        - build if_tk.c
        - add preliminary hooks so if_tk can be called when ready
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.17 2007/02/20 07:46:30 brlcad Exp $ (BRL)";
d920 1
a920 1
		    const char *dirn = bu_dirname(bu_argv0(NULL));
@


14.17
log
@oop, bu_argv0 requires an argument
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.16 2007/02/20 00:49:48 brlcad Exp $ (BRL)";
d974 1
a974 1
#  if defined(DM_X) || defined(DM_OGL)
@


14.16
log
@searching for a text editor.. needs the path on argv0, not just the name of the binary unless it's going to go hunting for it with bu_which().
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.15 2007/01/27 01:41:44 brlcad Exp $ (BRL)";
d296 1
a296 1
	if( fgets( line , sizeof( line ) , fp ) == NULL )
d920 1
a920 1
		    const char *dirn = bu_dirname(bu_argv0());
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.14 2007/01/23 01:13:42 brlcad Exp $ (BRL)";
d920 1
a920 1
		    const char *dirn = bu_dirname(bu_getprogname());
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.13 2007/01/20 14:36:58 brlcad Exp $ (BRL)";
d869 1
a869 1
	
d966 1
a966 1
		    
@


14.13
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.12 2006/08/09 08:36:38 brlcad Exp $ (BRL)";
@


14.12
log
@fairly comprehensive rewrite of tedit() for the ted command that merges the windows version in with the unix version in what should be a pretty platform independent manner.  this version tries a lot harder to find a usable editor other than /bin/ed including checking EDITOR even on Windows (there was some bug report for this, but can't find it atm).  it'll also kick off TextEdit on Mac OS X now as well as trying emacs and vi, before falling back on jove as the editor if it can find it.  still doesn't do run-time checking of the editor itself, but it should be more consistent.  also removed the closing of descriptors which lets console editors work and allows gui editors to be aborted
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.11 2006/08/07 16:04:39 brlcad Exp $ (BRL)";
@


14.11
log
@add explicit code for DM_WGL and IF_WGL for Windows GL support instead of piggybacking off of the OGL interface
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.10 2006/07/09 19:17:16 brlcad Exp $ (BRL)";
a73 2
#define LINELEN		256	/* max length of input line */
#define	DEFEDITOR	"/bin/ed"
d77 7
d293 1
a293 1
	static char line[LINELEN];
d847 2
a848 39
/* XXX should merge with editit() below */
#ifdef _WIN32

/* Run $EDITOR on temp file */
editit( file )
const char *file;
{
   STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   char line[RT_MAXLINE] = {0};

   sprintf(line,"notepad %s",file);


      si.cb = sizeof(STARTUPINFO);
      si.lpReserved = NULL;
      si.lpReserved2 = NULL;
      si.cbReserved2 = 0;
      si.lpDesktop = NULL;
      si.dwFlags = 0;

      CreateProcess( NULL,
                     line,
                     NULL,
                     NULL,
                     TRUE,
                     NORMAL_PRIORITY_CLASS,
                     NULL,
                     NULL,
                     &si,
                     &pi );
      WaitForSingleObject( pi.hProcess, INFINITE );

	return 1;
}

#else /* !_WIN32 */

/* Run $EDITOR on temp file
d850 5
a854 5
 * BUGS -- right now we only check at compile time whether or not to pop up an
 *         X window to display into (for editors that do not open their own
 *         window like vi or jove).  If we have X support, we automatically use
 *         xterm (regardless of whether the user is running mged in console
 *         mode!)
d859 31
a889 8
	register int pid, xpid;
	register char *ed;
	int stat;
	void (*s2)(), (*s3)();

	if ((ed = getenv("EDITOR")) == (char *)0)
		ed = DEFEDITOR;
	bu_log("Invoking %s %s\n", ed, file);
d891 45
d938 3
d945 2
d951 2
a952 13
		/* XXX do not want to close all io if we are in console mode
		 * and the editor needs to use stdout...
		 */
#	if defined(DM_X) || defined(DM_OGL)
		/* close all stdout/stderr (XXX except do not close 0==stdin) */
		for( i=1; i < 20; i++ )
			(void)close(i);
#	else
		/* leave stdin/out/err alone */
		for( i=3; i < 20; i++ )
			(void)close(i);
#	endif

d955 1
d957 33
a989 10
		/* if we have x support, we pop open the editor in an xterm.
		 * otherwise, we use whatever the user gave as EDITOR
		 */
#	if defined(DM_X) || defined(DM_OGL)
		(void)execlp("xterm", "xterm", "-e", ed, file, (char *)0);
#	else
		(void)execlp(ed, ed, file, 0);
#	endif
		perror(ed);
		exit(1);
d992 8
d1001 1
a1001 4
	while ((xpid = wait(&stat)) >= 0)
		if (xpid == pid)
			break;

d1004 1
a1007 1
#endif /* _WIN32 */
@


14.10
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.9 2006/04/06 20:50:03 brlcad Exp $ (BRL)";
d842 1
d878 1
a878 2
#else
/* else win32 is not defined */
d948 1
a948 2
#endif
/* end check if win32 defined */
@


14.9
log
@quell/fix issues raised by the Intel compiler on Altix
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.8 2006/01/23 06:32:37 brlcad Exp $ (BRL)";
d850 1
a850 1
   char line[1024];
@


14.8
log
@stdlib.h for alloc/getenv funcs
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.7 2006/01/18 06:46:19 brlcad Exp $ (BRL)";
d52 6
@


14.8.2.1
log
@update from HEAD
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.8 2006/01/23 06:32:37 brlcad Exp $ (BRL)";
a51 6
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
@


14.7
log
@update copyright to 2006
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.6 2005/10/23 04:44:37 brlcad Exp $ (BRL)";
d44 1
@


14.6
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.5 2005/08/21 13:56:30 brlcad Exp $ (BRL)";
@


14.5
log
@quell warnings, add missing headers
@
text
@d32 1
a32 1
 *  
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.4 2005/05/28 02:14:52 brlcad Exp $ (BRL)";
d273 1
a273 1
	
d821 1
a821 1
			
d827 1
a827 1
			break;	
d847 1
a847 1
   
d866 1
a866 1
   
d873 2
a874 2
/* Run $EDITOR on temp file 
 * 
@


14.5.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d273 1
a273 1

d821 1
a821 1

d827 1
a827 1
			break;
d847 1
a847 1

d866 1
a866 1

d873 2
a874 2
/* Run $EDITOR on temp file
 *
@


14.4
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.3 2005/01/30 20:31:06 brlcad Exp $ (BRL)";
a43 2


d47 1
a47 1
#include <string.h>
d49 4
a52 1
#include <strings.h>
d54 1
d61 1
d66 1
@


14.3
log
@update copyright to 2005
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/mged/tedit.c,v 14.2 2004/12/21 04:17:27 butler Exp $ (BRL)";
d72 1
a72 1
#ifndef WIN32
d104 1
a104 1
#ifdef WIN32
d831 1
a831 1
#ifdef WIN32
@


14.2
log
@GPL License changes
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/tedit.c,v 14.1 2004/11/16 19:42:17 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *  			T E D I T . C
a36 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/tedit.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/tedit.c,v 1.3 2004/08/02 23:01:51 morrison Exp $ (BRL)";
d924 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/mged/tedit.c,v 1.2 2004/06/08 22:04:29 morrison Exp $ (BRL)";
d33 1
a33 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/mged/tedit.c,v 11.34 2004/05/10 15:30:48 erikg Exp $ (BRL)";
a42 1
#include "externs.h"
@

