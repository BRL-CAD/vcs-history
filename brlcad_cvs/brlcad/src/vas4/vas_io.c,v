head	14.14;
access;
symbols
	rel-7-10-4:14.12
	STABLE:14.12.0.2
	rel-7-10-2:14.12
	rel-7-10-0:14.11
	rel-7-8-4:14.9
	rel-7-8-2:14.6
	rel-7-8-0:14.6
	trimnurbs-branch:14.6.0.2
	help:14.6
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.14
date	2007.11.21.20.49.14;	author erikgreenwald;	state Exp;
branches;
next	14.13;

14.13
date	2007.11.21.19.49.12;	author erikgreenwald;	state Exp;
branches;
next	14.12;

14.12
date	2007.07.26.01.14.00;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.57;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.37.07;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.07.12.14.50.29;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.07.10.01.25.39;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.07.09.18.25.33;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.18.06.46.29;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.39;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.35;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.21.07.18.59;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.36.36;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.32;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.53;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.22.01;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.21;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.14
log
@pass bu_exit a NULL instead of an empty string
@
text
@/*                        V A S _ I O . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file vas_io.c
 *
 *  I/O routines to talk to a Lyon-Lamb VAS IV video animation controller.
 *
 *
 *  Authors -
 *	Steve Satterfield, USNA
 *	Joe Johnson, USNA
 *	Michael John Muuss, BRL
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.13 2007/11/21 19:49:12 erikgreenwald Exp $ (BRL)";
#endif

#include "common.h"

#if HAVE_UNISTD_H
#  include <unistd.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>

#if defined(HAVE_XOPEN)
#  include <termios.h>

static struct termios	vtty;

#  if defined(__bsdi__)
#    include <sys/ioctl_compat.h>
#    define TAB3 (TAB1|TAB2)
#    define OCRNL   0000010
#  endif

#else	/* !defined(HAVE_XOPEN) */

#  ifdef HAVE_TERMIO_H
#    include <termio.h>
struct termio vtty;
#  else /* !HAVE_TERMIO_H */
#    ifdef HAVE_SGTTY_H
#      include <sgtty.h>
struct sgttyb vtty;
#    endif
#  endif /* HAVE_TERMIO_H */

#endif /* HAVE_XOPEN */

#include "./vas4.h"

#define VAS_PORT	"/dev/vas"
#define BAUD		B300

void	vas_response(char c);

int vas_fd;
extern int debug;

/*
 * vas_open - attach to the VAS serial line
 *
 *	return a file descriptor of NULL on error
 */
void
vas_open(void)
{

	/* Open VAS Port */
	if((vas_fd=open(VAS_PORT,O_RDWR)) < 0){
		perror(VAS_PORT);
		bu_exit(1, NULL);
	}

	/* Setup VAS line */

#ifdef HAVE_TERMIO_H

	vtty.c_cflag = BAUD | CS8;      /* Character size = 8 bits */
	vtty.c_cflag &= ~CSTOPB;         /* One stop bit */
	vtty.c_cflag |= CREAD;           /* Enable the reader */
	vtty.c_cflag &= ~PARENB;         /* Parity disable */
	vtty.c_cflag &= ~HUPCL;          /* No hangup on close */
	vtty.c_cflag |= CLOCAL;          /* Line has no modem control */

	vtty.c_iflag &= ~(BRKINT|ICRNL|INLCR|IXON|IXANY|IXOFF);
	vtty.c_iflag |= IGNBRK|IGNPAR;

	vtty.c_oflag &= ~(OPOST|ONLCR|OCRNL);    /* Turn off all post-processing */
	vtty.c_oflag |= TAB3;		/* output tab expansion ON */
	vtty.c_cc[VMIN] = 1;
	vtty.c_cc[VTIME] = 0;

	vtty.c_lflag &= ~ICANON;         /* Raw mode */
	vtty.c_lflag &= ~ISIG;           /* Signals OFF */
	vtty.c_lflag &= ~(ECHO|ECHOE|ECHOK);     /* Echo mode OFF */

	if( ioctl(vas_fd, TCSETA, &vtty) < 0 ) {
		perror(VAS_PORT);
		bu_exit(1, NULL);
	}

	/* Be certain the FNDELAY is off */
	if( fcntl(vas_fd, F_SETFL, 0) < 0 )  {
		perror(VAS_PORT);
		bu_exit(2, NULL);
	}

#else /* !HAVE_TERMIO_H */
#  ifdef HAVE_SGTTY_H

	vtty.sg_ispeed = BAUD;
	vtty.sg_ospeed = BAUD;
	vtty.sg_flags = RAW|EVENP|ODDP;
	ioctl(vas_fd,TIOCSETP,&vtty);
	ioctl(vas_fd,TIOCEXCL,&vtty);	/* exclusive use */

#  endif /* HAVE_SGTTY_H */
#endif /* HAVE_TERMIO_H */

#ifdef HAVE_XOPEN
	vtty.c_cflag = BAUD | CS8;      /* Character size = 8 bits */
	vtty.c_cflag &= ~CSTOPB;         /* One stop bit */
	vtty.c_cflag |= CREAD;           /* Enable the reader */
	vtty.c_cflag &= ~PARENB;         /* Parity disable */
	vtty.c_cflag &= ~HUPCL;          /* No hangup on close */
	vtty.c_cflag |= CLOCAL;          /* Line has no modem control */

	vtty.c_iflag &= ~(BRKINT|ICRNL|INLCR|IXON|IXANY|IXOFF);
	vtty.c_iflag |= IGNBRK|IGNPAR;

	vtty.c_oflag &= ~(OPOST|ONLCR|OCRNL);    /* Turn off all post-processing */
	vtty.c_oflag |= TAB3;		/* output tab expansion ON */
	vtty.c_cc[VMIN] = 1;
	vtty.c_cc[VTIME] = 0;

	vtty.c_lflag &= ~ICANON;         /* Raw mode */
	vtty.c_lflag &= ~ISIG;           /* Signals OFF */
	vtty.c_lflag &= ~(ECHO|ECHOE|ECHOK);     /* Echo mode OFF */

	if( tcsetattr( vas_fd, TCSAFLUSH, &vtty ) < 0 )  {
		perror(VAS_PORT);
		bu_exit(1, NULL);
	}

	/* Be certain the FNDELAY is off */
	if( fcntl(vas_fd, F_SETFL, 0) < 0 )  {
		perror(VAS_PORT);
		bu_exit(2, NULL);
	}
#endif
}

/*
 *			V A S _ R A W P U T C
 *
 *  Defeat the (typically desirable) ack/rexmit behavior of the
 *  vas_putc() routine.  Useful mostly for the 'V' (get_vtr_status)
 *  command, and the 'A' (send current activity) commands.
 */
int
vas_rawputc(char c)
{
	int	got;

	got = write(vas_fd, &c, 1);
	if (got != 1)  {
		perror("VAS Write");
		return(got);
		/* Error recovery?? */
	}
	if(debug) fprintf(stderr,"vas_rawputc 0%o '%c'\n",c,c);
	return(got);
}

/*
 *			V A S _ P U T C
 *
 *  Output the specified character to the VAS.
 *  Wait for a 006 (^F) ACK of this character,
 *  or for an "activity state" character,
 *  else retransmit.
 */
int
vas_putc(char c)
{
	int	got;
	int	reply;
	int	count;

	for( count=0; count<20; count++ )  {
		got = write(vas_fd, &c, 1);
		if (got < 1)  {
			perror("VAS Write");
			return(got);
			/* Error recovery?? */
		}
		if(debug) fprintf(stderr,"vas_putc 0%o '%c'\n",c,c);

reread:
		reply=vas_getc();
		if( reply == 006 )
			return(got);		/* ACK */
		if( reply >= 0x60 && reply <= 0x78 )  {
			vas_response(reply);
			return(got);
		}
		if( reply == 007 )  {
			if(count>4) fprintf(stderr, "retry\n");
			sleep(1);
			continue;		/* NACK, please repeat */
		}
		fprintf(stderr,"vas4:  non-ACK rcvd for cmd %c\n",c);
		vas_response(reply);
		goto reread;		/* See if ACK is buffered up */
	}
	fprintf(stderr,"vas4:  unable to perform cmd %c after retries\n", c);
	return(-1);
}

/*
 *			V A S _ P U T S
 *
 *  Output a null terminated string to the VAS.
 */
void
vas_puts(char *s)
{
	while (*s != '\0' ) {
		vas_putc(*s++);
	}
}

/*
 *			V A S _ P U T N U M
 *
 *  Output a number in decimal to the VAS.
 */
void
vas_putnum(int n)
{
	char	buf[32];

	sprintf(buf,"%d",n);
	vas_puts(buf);
}


/*
 *			V A S _ G E T C
 *
 * Read a single character from the VAS, return EOF on error
 */
int
vas_getc(void)
{
	char c;
	int readval = read(vas_fd, &c, 1);

	if (readval > 0)  {
	    if(debug)fprintf(stderr,"vas_getc: 0%o %c\n", c&0377, c&0377);
	    return(c & 0377);
	}
	if (readval < 0) {
	    perror("READ ERROR");
	}
	return(EOF);
}

/*
 *			V A S _ C L O S E
 */
void
vas_close(void)
{
	close(vas_fd);
	vas_fd = -1;
}

/*
 *			V A S _ A W A I T
 *
 *  Slurp up input characters, until designated one comes along.
 *  If too much time has been spent waiting, we should consider
 *  some way of bailing out.  Error recovery needs more attention.
 *
 *  Returns -
 *	0	all is well
 *	-1	failure
 */
int
vas_await(int c, int sec)
{
	int	reply;
	int	count;

	for(count=0; count<20; count++)  {
		reply = vas_getc();
		if(debug) vas_response(reply);
		if( reply == c )  return(0);	/* OK */
		if(!debug) vas_response(reply);
	}
	return(-1);			/* BAD:  too many bad chars */
}

/*
 *			V A S _ R E S P O N S E
 *
 *  Attempt to interpret a reply as something sensible.
 *  This may not work in all cases (such as a multi-character response),
 *  but certainly beats looking at single-character codes.
 */
void
vas_response(char c)
{
	fprintf(stderr,"---Got 0%o '%c' ", c, c);
	switch(c)  {
	case 6:
		fprintf(stderr,"last command accepted\n");
		break;
	case 7:
		fprintf(stderr,"***Command ignored at current activity level\n");
		break;
	case 'I':
		fprintf(stderr,"Initialized.  Controller is ready for operation\n");
		break;
	case 'P':
		fprintf(stderr,"Program cmd accepted\n");
		break;
	case 'F':
		fprintf(stderr,"Frame rate cmd accepted\n");
		break;
	case 'E':
		fprintf(stderr,"Update cmd accepted\n");
		break;
	case 'U':
		fprintf(stderr,"Update cmd accepted\n");
		break;
	case 'S':
		fprintf(stderr,"Search command accepted, ready for E/E\n");
		break;
	case 'W':
		fprintf(stderr,"After E/E, search began, scene is not correct\n");
		break;
	case 'B':
		fprintf(stderr,"After E/E, search began, frame code lost while checking scene\n");
		break;
	case 'N':
		fprintf(stderr,"After E/E, search for frame fails (preceding frame not found)\n");
		break;
	case 'R':
		fprintf(stderr,"Ready to accept Record command\n");
		break;
	case 'M':
		fprintf(stderr,"Preroll fails after Record cmd, backspace for retry begins\n");
		break;
	case 'X':
		fprintf(stderr,"Notice:  2 frames before cut-in\n");
		break;
	case 'Y':
		fprintf(stderr,"Notice:  2 frames before cut-out\n");
		break;
	case 'D':
		fprintf(stderr,"Recording done, starting backspacing for next preroll\n");
		break;
	case 'J':
		fprintf(stderr,"Jaunt:  standby timeout;  tape moving back to Title\n");
		break;
	case 'T':
		fprintf(stderr,"Trash:  recording interrupted by STOP\n");
		break;
	case 'Q':
		fprintf(stderr,"Quit:  Ending EDIT mode\n");
		break;
	case 'L':
		fprintf(stderr,"Located sought frame\n");
		break;
	case 'K':
		fprintf(stderr,"Knave:  Search-for-frame failed\n");
		break;

	/**** Current activity states ****/
	/**** These are all suspect, as they don't match the BRL manual ***/
	case '`':
		fprintf(stderr,"Idling:  Power-on condition or newly initialized\n");
		break;
	case 'a':
		fprintf(stderr,"Register function is active\n");
		break;
	case 'b':
		fprintf(stderr,"Accepting programming for a recording\n");
		break;
	case 'c':
		fprintf(stderr,"Accepting programming for an edit recording\n");
		break;
	case 'd':
		fprintf(stderr,"Flashing E/E switch; ready to search for frame\n");
		break;
	case 'e':
		fprintf(stderr,"Checking for position on correct scene\n");
		break;
	case 'f':
		fprintf(stderr,"Ready to record next recording or TITLE\n");
		break;
	case 'g':
		fprintf(stderr,"Prerolling, about to make recording\n");
		break;
	case 'h':
		fprintf(stderr,"Recording in progress\n");
		break;
	case 'i':
		fprintf(stderr,"Backspacing for next preroll and recording\n");
		break;
	case 'j':
		fprintf(stderr,"Searching for frame preceding next to record\n");
		break;
	case 'k':
		fprintf(stderr,"Accepting programming for Frame Change\n");
		break;
	case 'l':
		fprintf(stderr,"Accepting programming for HOLD\n");
		break;
	case 'm':
		fprintf(stderr,"Displaying a warning message\n");
		break;
	case 'n':
		fprintf(stderr,"Ready to record first recording on old scene\n");
		break;
	case 'o':
		fprintf(stderr,"Holding momentarily before allowing to RECORD\n");
		break;

	default:
		fprintf(stderr,"???unknown???\n");
		break;
	}
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.13
log
@exit->bu_exit where applicable
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.12 2007/07/26 01:14:00 brlcad Exp $ (BRL)";
d91 1
a91 1
		bu_exit(1, "");
d119 1
a119 1
		bu_exit(1, "");
d125 1
a125 1
		bu_exit(2, "");
d162 1
a162 1
		bu_exit(1, "");
d168 1
a168 1
		bu_exit(2, "");
@


14.12
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.11 2007/01/23 01:13:57 brlcad Exp $ (BRL)";
d91 1
a91 1
		exit(1);
d119 1
a119 1
		exit(1);
d125 1
a125 1
		exit(2);
d162 1
a162 1
		exit(1);
d168 1
a168 1
		exit(2);
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a29 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.10 2007/01/20 14:37:07 brlcad Exp $ (BRL)";
@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.9 2006/07/12 14:50:29 brlcad Exp $ (BRL)";
@


14.9
log
@clean up the logic on termio.h vs sgtty.h .. can't use both together
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.8 2006/07/10 01:25:39 brlcad Exp $ (BRL)";
@


14.8
log
@remove/rewrite a bunch of the old SYSV preprocessor symbol sections
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.7 2006/07/09 18:25:33 brlcad Exp $ (BRL)";
d66 3
a68 3
#  endif
#  ifdef HAVE_SGTTY_H
#    include <sgtty.h>
d70 2
a71 1
#  endif
d73 1
a73 1
#endif /* _POSIX_SOURCE */
d101 1
a101 7
#ifdef HAVE_SGTTY_H
	vtty.sg_ispeed = BAUD;
	vtty.sg_ospeed = BAUD;
	vtty.sg_flags = RAW|EVENP|ODDP;
	ioctl(vas_fd,TIOCSETP,&vtty);
	ioctl(vas_fd,TIOCEXCL,&vtty);	/* exclusive use */
#endif
d103 1
d133 13
a145 1
#endif
@


14.7
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.6 2006/01/18 06:46:29 brlcad Exp $ (BRL)";
a42 2


d44 1
a44 1
#include <unistd.h>
a45 1

a50 2
#  undef SYSV
#  undef BSD
d55 5
a59 5
#if defined(__bsdi__)
#	include <sys/ioctl_compat.h>
#	define TAB3 (TAB1|TAB2)
#	define OCRNL   0000010
#endif
d63 2
a64 2
#ifdef SYSV
#  include <termio.h>
d66 3
a68 3
#endif
#ifdef BSD
#  include <sgtty.h>
d70 1
a70 1
#endif
d100 1
a100 1
#ifdef BSD
d107 1
a107 1
#ifdef SYSV
@


14.6
log
@update copyright to 2006
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.5 2005/10/23 04:44:39 brlcad Exp $ (BRL)";
d280 1
d282 8
a289 5
	if (read(vas_fd, &c, 1) > 0)  {
		if(debug)fprintf(stderr,"vas_getc: 0%o %c\n", c&0377, c&0377);
		return(c & 0377);
	}  else
		return(EOF);
@


14.5
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.4 2005/01/30 20:31:35 brlcad Exp $ (BRL)";
@


14.4
log
@update copyright to 2005
@
text
@d30 1
a30 1
 *  
d35 1
a35 1
 *  
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/vas4/vas_io.c,v 14.3 2004/12/21 07:18:59 morrison Exp $ (BRL)";
d119 1
a119 1
 
d122 1
a122 1
 
d132 1
a132 1
	if( ioctl(vas_fd, TCSETA, &vtty) < 0 ) { 
d150 1
a150 1
 
d153 1
a153 1
 
d202 1
a202 1
 *  Wait for a 006 (^F) ACK of this character, 
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d30 1
a30 1
 *
d35 1
a35 1
 *
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d119 1
a119 1

d122 1
a122 1

d132 1
a132 1
	if( ioctl(vas_fd, TCSETA, &vtty) < 0 ) {
d150 1
a150 1

d153 1
a153 1

d202 1
a202 1
 *  Wait for a 006 (^F) ACK of this character,
@


14.3
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vas4/vas_io.c,v 14.2 2004/12/21 03:36:36 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL
@
text
@a35 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimitied.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vas4/vas_io.c,v 14.1 2004/11/16 19:42:32 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			V A S _ I O . C
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vas4/vas_io.c,v 1.2 2004/08/02 23:01:53 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/vas4/vas_io.c,v 1.1 2004/05/20 15:22:01 morrison Exp $ (BRL)";
d439 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/vas4/vas_io.c,v 11.6 2004/05/10 15:30:51 erikg Exp $ (BRL)";
d24 1
a24 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

