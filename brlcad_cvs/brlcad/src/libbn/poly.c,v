head	14.21;
access;
symbols
	rel-7-10-4:14.18
	STABLE:14.18.0.2
	stable-branch:14.6
	rel-7-10-2:14.16
	rel-7-10-0:14.14
	rel-7-8-4:14.10
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.21
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.12.17.02.16.53;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.11.28.14.11.25;	author erikgreenwald;	state Exp;
branches;
next	14.18;

14.18
date	2007.08.30.18.44.27;	author erikgreenwald;	state Exp;
branches;
next	14.17;

14.17
date	2007.08.17.19.59.51;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.05.18.20.20.37;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.05.17.04.14.31;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.33;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.09.04.04.42.40;	author lbutler;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.31;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.28.35;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.44;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.01.52.15;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.24.02;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.29;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.21
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                          P O L Y . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup poly */
/** @@{ */
/** @@file poly.c
 *
 *	Library for dealing with polynomials.
 *
 *  Author -
 *	Jeff Hanes
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#include "common.h"

#include <stdio.h>
#include <math.h>
#include <signal.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"


#define Abs( a )		((a) >= 0 ? (a) : -(a))
#define Max( a, b )		((a) > (b) ? (a) : (b))

#ifndef M_PI
#  define M_PI	3.14159265358979323846
#endif
#define PI_DIV_3	(M_PI/3.0)

#define SQRT3			1.732050808
#define THIRD			0.333333333333333333333333333
#define INV_TWENTYSEVEN		0.037037037037037037037037037
#define	CUBEROOT( a )	(( (a) >= 0.0 ) ? pow( a, THIRD ) : -pow( -(a), THIRD ))

static const struct bn_poly	bn_Zero_poly = { BN_POLY_MAGIC, 0, {0.0} };
static int	bn_expecting_fpe = 0;
static jmp_buf	bn_abort_buf;


HIDDEN void bn_catch_FPE(int sig)
{
    if( !bn_expecting_fpe )
	bu_bomb("bn_catch_FPE() unexpected SIGFPE!");
    if( !bu_is_parallel() )
	(void)signal(SIGFPE, bn_catch_FPE);	/* Renew handler */
    longjmp(bn_abort_buf, 1);	/* return error code */
}


/**
 *	bn_poly_mul
 *
 * @@brief multiply two polynomials
 */
struct bn_poly *
bn_poly_mul(register struct bn_poly *product, register const struct bn_poly *m1, register const struct bn_poly *m2)
{
    if( m1->dgr == 1 && m2->dgr == 1 )  {
	product->dgr = 2;
	product->cf[0] = m1->cf[0] * m2->cf[0];
	product->cf[1] = m1->cf[0] * m2->cf[1] +
	    m1->cf[1] * m2->cf[0];
	product->cf[2] = m1->cf[1] * m2->cf[1];
	return product;
    }
    if( m1->dgr == 2 && m2->dgr == 2 )  {
	product->dgr = 4;
	product->cf[0] = m1->cf[0] * m2->cf[0];
	product->cf[1] = m1->cf[0] * m2->cf[1] +
	    m1->cf[1] * m2->cf[0];
	product->cf[2] = m1->cf[0] * m2->cf[2] +
	    m1->cf[1] * m2->cf[1] +
	    m1->cf[2] * m2->cf[0];
	product->cf[3] = m1->cf[1] * m2->cf[2] +
	    m1->cf[2] * m2->cf[1];
	product->cf[4] = m1->cf[2] * m2->cf[2];
	return product;
    }

    /* Not one of the common (or easy) cases. */
    {
	register int		ct1, ct2;

	*product = bn_Zero_poly;

	/* If the degree of the product will be larger than the
	 * maximum size allowed in "polyno.h", then return a null
	 * pointer to indicate failure.
	 */
	if ( (product->dgr = m1->dgr + m2->dgr) > BN_MAX_POLY_DEGREE )
	    return BN_POLY_NULL;

	for ( ct1=0; ct1 <= m1->dgr; ++ct1 ){
	    for ( ct2=0; ct2 <= m2->dgr; ++ct2 ){
		product->cf[ct1+ct2] +=
		    m1->cf[ct1] * m2->cf[ct2];
	    }
	}
    }
    return product;
}


/**
 *	bn_poly_scale
 * @@brief
 * scale a polynomial
 */
struct bn_poly *
bn_poly_scale(register struct bn_poly *eqn, double factor)
{
    register int		cnt;

    for ( cnt=0; cnt <= eqn->dgr; ++cnt ){
	eqn->cf[cnt] *= factor;
    }
    return eqn;
}


/**
 *	bn_poly_add
 * @@brief
 * add two polynomials
 */
struct bn_poly *
bn_poly_add(register struct bn_poly *sum, register const struct bn_poly *poly1, register const struct bn_poly *poly2)
{
    struct bn_poly	tmp;
    register int		i, offset;

    offset = Abs(poly1->dgr - poly2->dgr);

    tmp = bn_Zero_poly;

    if ( poly1->dgr >= poly2->dgr ){
	*sum = *poly1;
	for ( i=0; i <= poly2->dgr; ++i ){
	    tmp.cf[i+offset] = poly2->cf[i];
	}
    } else {
	*sum = *poly2;
	for ( i=0; i <= poly1->dgr; ++i ){
	    tmp.cf[i+offset] = poly1->cf[i];
	}
    }

    for ( i=0; i <= sum->dgr; ++i ){
	sum->cf[i] += tmp.cf[i];
    }
    return sum;
}


/**
 *	bn_poly_sub
 * @@brief
 * subtract two polynomials
 */
struct bn_poly *
bn_poly_sub(register struct bn_poly *diff, register const struct bn_poly *poly1, register const struct bn_poly *poly2)
{
    struct bn_poly	tmp;
    register int		i, offset;

    offset = Abs(poly1->dgr - poly2->dgr);

    *diff = bn_Zero_poly;
    tmp = bn_Zero_poly;

    if ( poly1->dgr >= poly2->dgr ){
	*diff = *poly1;
	for ( i=0; i <= poly2->dgr; ++i ){
	    tmp.cf[i+offset] = poly2->cf[i];
	}
    } else {
	diff->dgr = poly2->dgr;
	for ( i=0; i <= poly1->dgr; ++i ){
	    diff->cf[i+offset] = poly1->cf[i];
	}
	tmp = *poly2;
    }

    for ( i=0; i <= diff->dgr; ++i ){
	diff->cf[i] -= tmp.cf[i];
    }
    return diff;
}


/**
 *	s y n D i v
 * @@brief
 *	Divides any polynomial into any other polynomial using synthetic
 *	division.  Both polynomials must have real coefficients.
 */
void
bn_poly_synthetic_division(register struct bn_poly *quo, register struct bn_poly *rem, register const struct bn_poly *dvdend, register const struct bn_poly *dvsor)
{
    register int	div;
    register int	n;

    *quo = *dvdend;
    *rem = bn_Zero_poly;

    if ((quo->dgr = dvdend->dgr - dvsor->dgr) < 0)
	quo->dgr = -1;
    if ((rem->dgr = dvsor->dgr - 1) > dvdend->dgr)
	rem->dgr = dvdend->dgr;

    for ( n=0; n <= quo->dgr; ++n){
	quo->cf[n] /= dvsor->cf[0];
	for ( div=1; div <= dvsor->dgr; ++div){
	    quo->cf[n+div] -= quo->cf[n] * dvsor->cf[div];
	}
    }
    for ( n=1; n<=(rem->dgr+1); ++n){
	rem->cf[n-1] = quo->cf[quo->dgr+n];
	quo->cf[quo->dgr+n] = 0;
    }
}


/**
 * b n _ p o l y _ q u a d r a t i c _ r o o t s
 *@@brief
 * Uses the quadratic formula to find the roots (in `complex' form) of
 * any quadratic equation with real coefficients.
 *
 *	@@return 1 for success
 *	@@return 0 for fail.
 */
int
bn_poly_quadratic_roots(register struct bn_complex *roots, register const struct bn_poly *quadrat)
{
    fastf_t discrim, denom, rad;
    const fastf_t small = SMALL_FASTF;

    if( NEAR_ZERO( quadrat->cf[0], small ) )  {
	/* root = -cf[2] / cf[1] */
	if( NEAR_ZERO( quadrat->cf[1], small ) )  {
	    /* No solution.  Now what? */
	    /*	    bu_log("bn_poly_quadratic_roots(): ERROR, no solution\n"); */
	    return 0;
	}
	/* Fake it as a repeated root. */
	roots[0].re = roots[1].re = -quadrat->cf[2]/quadrat->cf[1];
	roots[0].im = roots[1].im = 0.0;
	return 1;	/* OK - repeated root */
    }

    discrim = quadrat->cf[1]*quadrat->cf[1] - 4.0* quadrat->cf[0]*quadrat->cf[2];
    denom = 0.5 / quadrat->cf[0];
#if 0
    bu_log("discrim=%.20f cf0=%.20f cf1=%.20f cf2=%.20f; ", discrim, quadrat->cf[0], quadrat->cf[1], quadrat->cf[2]);
#endif
    if (discrim > 0.0) {
	rad = sqrt( discrim );

	if (NEAR_ZERO(quadrat->cf[1], small)) {
	    double r = fabs(rad * denom);
	    roots[0].re = r;
	    roots[1].re = -r;
	} else {
	    double t, r1, r2;

	    if (quadrat->cf[1] > 0.0) {
		t = -0.5 * (quadrat->cf[1] + rad);
	    } else {
		t = -0.5 * (quadrat->cf[1] - rad);
	    }
	    r1 = t / quadrat->cf[0];
	    r2 = quadrat->cf[2] / t;

	    if (r1 < r2) {
		roots[0].re = r1;
		roots[1].re = r2;
	    } else {
		roots[0].re = r2;
		roots[1].re = r1;
	    }
	}
	roots[1].im = roots[0].im = 0.0;
    } else if (NEAR_ZERO(discrim, small)) {
	roots[1].re = roots[0].re = -quadrat->cf[1] * denom;
	roots[1].im = roots[0].im = 0.0;
    } else {
	roots[1].re = roots[0].re = -quadrat->cf[1] * denom;
	roots[1].im = -(roots[0].im = sqrt( -discrim ) * denom);
    }
    return 1;		/* OK */
}


/**
 *	b n _ p o l y _ c u b i c _ r o o t s
 *@@brief
 *	Uses the cubic formula to find the roots ( in `complex' form )
 *	of any cubic equation with real coefficients.
 *
 *	to solve a polynomial of the form:
 *
 *		X**3 + c1*X**2 + c2*X + c3 = 0,
 *
 *	first reduce it to the form:
 *
 *		Y**3 + a*Y + b = 0,
 *
 *	where
 *		Y = X + c1/3,
 *	and
 *		a = c2 - c1**2/3,
 *		b = ( 2*c1**3 - 9*c1*c2 + 27*c3 )/27.
 *
 *	Then we define the value delta,   D = b**2/4 + a**3/27.
 *
 *	If D > 0, there will be one real root and two conjugate
 *	complex roots.
 *	If D = 0, there will be three real roots at least two of
 *	which are equal.
 *	If D < 0, there will be three unequal real roots.
 *
 *	Returns 1 for success, 0 for fail.
 */
int
bn_poly_cubic_roots(register struct bn_complex *roots, register const struct bn_poly *eqn)
{
    fastf_t	a, b, c1, c1_3rd, delta;
    register int	i;
    static int	first_time = 1;

    if( !bu_is_parallel() ) {
	/* bn_abort_buf is NOT parallel! */
	if( first_time )  {
	    first_time = 0;
	    (void)signal(SIGFPE, bn_catch_FPE);
	}
	bn_expecting_fpe = 1;
	if( setjmp( bn_abort_buf ) )  {
	    (void)signal(SIGFPE, bn_catch_FPE);
	    bu_log("bn_poly_cubic_roots() Floating Point Error\n");
	    return 0;	/* FAIL */
	}
    }

    c1 = eqn->cf[1];
    if( Abs(c1) > SQRT_MAX_FASTF )  return 0;	/* FAIL */

    c1_3rd = c1 * THIRD;
    a = eqn->cf[2] - c1*c1_3rd;
    if( Abs(a) > SQRT_MAX_FASTF )  return 0;	/* FAIL */
    b = (2.0*c1*c1*c1 - 9.0*c1*eqn->cf[2] + 27.0*eqn->cf[3])*INV_TWENTYSEVEN;
    if( Abs(b) > SQRT_MAX_FASTF )  return 0;	/* FAIL */

    if( (delta = a*a) > SQRT_MAX_FASTF ) return 0;	/* FAIL */
    delta = b*b*0.25 + delta*a*INV_TWENTYSEVEN;

    if ( delta > 0.0 ){
	fastf_t		r_delta, A, B;

	r_delta = sqrt( delta );
	A = B = -0.5 * b;
	A += r_delta;
	B -= r_delta;

	A = CUBEROOT( A );
	B = CUBEROOT( B );

	roots[2].re = roots[1].re = -0.5 * ( roots[0].re = A + B );

	roots[0].im = 0.0;
	roots[2].im = -( roots[1].im = (A - B)*SQRT3*0.5 );
    } else if ( delta == 0.0 ){
	fastf_t	b_2;
	b_2 = -0.5 * b;

	roots[0].re = 2.0* CUBEROOT( b_2 );
	roots[2].re = roots[1].re = -0.5 * roots[0].re;
	roots[2].im = roots[1].im = roots[0].im = 0.0;
    } else {
	fastf_t		phi, fact;
	fastf_t		cs_phi, sn_phi_s3;

	if( a >= 0.0 )  {
	    fact = 0.0;
	    phi = 0.0;
	    cs_phi = 1.0;		/* cos( phi ); */
	    sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
	} else {
	    register fastf_t	f;
	    a *= -THIRD;
	    fact = sqrt( a );
	    if( (f = b * (-0.5) / (a*fact)) >= 1.0 )  {
		phi = 0.0;
		cs_phi = 1.0;		/* cos( phi ); */
		sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
	    }  else if( f <= -1.0 )  {
		phi = PI_DIV_3;
		cs_phi = cos( phi );
		sn_phi_s3 = sin( phi ) * SQRT3;
	    }  else  {
		phi = acos( f ) * THIRD;
		cs_phi = cos( phi );
		sn_phi_s3 = sin( phi ) * SQRT3;
	    }
	}

	roots[0].re = 2.0*fact*cs_phi;
	roots[1].re = fact*(  sn_phi_s3 - cs_phi);
	roots[2].re = fact*( -sn_phi_s3 - cs_phi);
	roots[2].im = roots[1].im = roots[0].im = 0.0;
    }
    for ( i=0; i < 3; ++i )
	roots[i].re -= c1_3rd;

    if( !bu_is_parallel() )
	bn_expecting_fpe = 0;

    return 1;		/* OK */
}


/**
 *	b n _ p o l y _ q u a r t i c _ r o o t s
 *@@brief
 *	Uses the quartic formula to find the roots ( in `complex' form )
 *	of any quartic equation with real coefficients.
 *
 *	@@return 1 for success
 *	@@return 0 for fail.
 */
int
bn_poly_quartic_roots(register struct bn_complex *roots, register const struct bn_poly *eqn)
{
    struct bn_poly	cube, quad1, quad2;
    bn_complex_t	u[3];
    fastf_t		U, p, q, q1, q2;

    /* something considerably larger than squared floating point fuss */
    const fastf_t small = 1.0e-8;

#define Max3(a,b,c) ((c)>((a)>(b)?(a):(b)) ? (c) : ((a)>(b)?(a):(b)))

    cube.dgr = 3;
    cube.cf[0] = 1.0;
    cube.cf[1] = -eqn->cf[2];
    cube.cf[2] = eqn->cf[3]*eqn->cf[1]
	- 4*eqn->cf[4];
    cube.cf[3] = -eqn->cf[3]*eqn->cf[3]
	- eqn->cf[4]*eqn->cf[1]*eqn->cf[1]
	+ 4*eqn->cf[4]*eqn->cf[2];

    if (!bn_poly_cubic_roots( u, &cube )) {
	return 0;		/* FAIL */
    }
    if (u[1].im != 0.0) {
	U = u[0].re;
    } else {
	U = Max3( u[0].re, u[1].re, u[2].re );
    }

    p = eqn->cf[1]*eqn->cf[1]*0.25 + U - eqn->cf[2];
    U *= 0.5;
    q = U*U - eqn->cf[4];
    if (p < 0) {
	if (p < -small) {
	    return 0;	/* FAIL */
	}
	p = 0;
    } else {
	p = sqrt( p );
    }
    if (q < 0 )  {
	if (q < -small) {
	    return 0;	/* FAIL */
	}
	q = 0;
    } else {
	q = sqrt( q );
    }

    quad1.dgr = quad2.dgr = 2;
    quad1.cf[0] = quad2.cf[0] = 1.0;
    quad1.cf[1] = eqn->cf[1]*0.5;
    quad2.cf[1] = quad1.cf[1] + p;
    quad1.cf[1] -= p;

    q1 = U - q;
    q2 = U + q;

    p = quad1.cf[1]*q2 + quad2.cf[1]*q1 - eqn->cf[3];
    if (NEAR_ZERO(p, small)) {
	quad1.cf[2] = q1;
	quad2.cf[2] = q2;
    } else {
	q = quad1.cf[1]*q1 + quad2.cf[1]*q2 - eqn->cf[3];
	if (NEAR_ZERO(q, small)) {
	    quad1.cf[2] = q2;
	    quad2.cf[2] = q1;
	} else {
	    return 0;	/* FAIL */
	}
    }

    bn_poly_quadratic_roots( &roots[0], &quad1 );
    bn_poly_quadratic_roots( &roots[2], &quad2 );
    return 1;		/* SUCCESS */
}


/**
 *	b n _ p r _ p o l y
 *
 * Print out the polynomial.
 */
void
bn_pr_poly(const char *title, register const struct bn_poly *eqn)
{
    register int	n;
    register int	exp;
    struct bu_vls	str;
    char		buf[48];

    bu_vls_init( &str );
    bu_vls_extend( &str, 196 );
    bu_vls_strcat( &str, title );
    snprintf(buf, 48, " polynomial, degree = %d\n", eqn->dgr);
    bu_vls_strcat( &str, buf );

    exp = eqn->dgr;
    for ( n=0; n<=eqn->dgr; n++,exp-- )  {
	register double coeff = eqn->cf[n];
	if( n > 0 )  {
	    if( coeff < 0 )  {
		bu_vls_strcat( &str, " - " );
		coeff = -coeff;
	    }  else  {
		bu_vls_strcat( &str, " + " );
	    }
	}
	bu_vls_printf( &str, "%g", coeff );
	if( exp > 1 )  {
	    bu_vls_printf( &str, " *X^%d", exp );
	} else if( exp == 1 )  {

	    bu_vls_strcat( &str, " *X" );
	} else {
	    /* For constant term, add nothing */
	}
    }
    bu_vls_strcat( &str, "\n" );
    bu_log( "%s", bu_vls_addr(&str) );
    bu_vls_free( &str );
}

/**
 * b n _ p r _ r o o t s
 *
 * Print out the roots of a given polynomial (complex numbers)
 */
void
bn_pr_roots(const char *title, const struct bn_complex *roots, int n)
{
    register int	i;

    bu_log("%s: %d roots:\n", title, n );
    for( i=0; i<n; i++ )  {
	bu_log("%4d %e + i * %e\n", i, roots[i].re, roots[i].im );
    }
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.20
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@a33 4
#ifndef lint
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.19 2007/11/28 14:11:25 erikgreenwald Exp $ (ARL)";
#endif

d153 1
a153 1
    static struct bn_poly	tmp;
d187 1
a187 1
    static struct bn_poly	tmp;
d260 1
a260 1
    static fastf_t discrim, denom, rad;
d352 1
a352 1
    static fastf_t	a, b, c1, c1_3rd, delta;
d383 1
a383 1
	static fastf_t		r_delta, A, B;
d398 1
a398 1
	static fastf_t	b_2;
d405 2
a406 2
	static fastf_t		phi, fact;
	static fastf_t		cs_phi, sn_phi_s3;
d459 3
a461 3
    static struct bn_poly	cube, quad1, quad2;
    static bn_complex_t	u[3];
    static fastf_t		U, p, q, q1, q2;
@


14.19
log
@LOCAL->static, per machine.h deprecation list
@
text
@d35 1
a35 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.18 2007/08/30 18:44:27 erikgreenwald Exp $ (ARL)";
d418 1
a418 1
	    FAST fastf_t	f;
@


14.18
log
@various minor fixes from "flawfinder" and compiler warnings
@
text
@d35 1
a35 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.17 2007/08/17 19:59:51 brlcad Exp $ (ARL)";
d157 1
a157 1
    LOCAL struct bn_poly	tmp;
d191 1
a191 1
    LOCAL struct bn_poly	tmp;
d264 1
a264 1
    LOCAL fastf_t discrim, denom, rad;
d356 1
a356 1
    LOCAL fastf_t	a, b, c1, c1_3rd, delta;
d387 1
a387 1
	LOCAL fastf_t		r_delta, A, B;
d402 1
a402 1
	LOCAL fastf_t	b_2;
d409 2
a410 2
	LOCAL fastf_t		phi, fact;
	LOCAL fastf_t		cs_phi, sn_phi_s3;
d463 3
a465 3
    LOCAL struct bn_poly	cube, quad1, quad2;
    LOCAL bn_complex_t	u[3];
    LOCAL fastf_t		U, p, q, q1, q2;
@


14.17
log
@rework the quadratic root solver to handle some additional exceptional cases where either the coefficients or the discriminate are zero.  ideally we could presume we're solving equations that don't have floating point fuzz, and could check for for ieee zero equivalence but alas we cannot without causing additional instability.
@
text
@d35 1
a35 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.16 2007/05/18 20:20:37 brlcad Exp $ (ARL)";
d282 3
a284 1
    //    bu_log("discrim=%.20f cf0=%.20f cf1=%.20f cf2=%.20f; ", discrim, quadrat->cf[0], quadrat->cf[1], quadrat->cf[2]);
d555 1
a555 1
    sprintf(buf, " polynomial, degree = %d\n", eqn->dgr);
@


14.16
log
@commentification
@
text
@d35 1
a35 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.15 2007/05/17 04:14:31 brlcad Exp $ (ARL)";
d92 1
a92 1
	return(product);
d105 1
a105 1
	return(product);
d257 3
d264 2
a265 1
    LOCAL fastf_t	discrim, denom, rad;
d267 1
a267 1
    if( NEAR_ZERO( quadrat->cf[0], SQRT_SMALL_FASTF ) )  {
d269 1
a269 1
	if( NEAR_ZERO( quadrat->cf[1], SQRT_SMALL_FASTF ) )  {
d271 2
a272 2
	    bu_log("bn_poly_quadratic_roots(): ERROR, no solution\n");
	    return -1;
a278 1
    /* What to do if cf[1] > SQRT_MAX_FASTF ? */
d282 2
a283 1
    if ( discrim >= 0.0 ){
d285 27
a311 2
	roots[0].re = ( -quadrat->cf[1] + rad ) * denom;
	roots[1].re = ( -quadrat->cf[1] - rad ) * denom;
d317 1
a317 1
    return 0;		/* OK */
d368 1
a368 1
	    return(0);	/* FAIL */
d373 1
a373 1
    if( Abs(c1) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
d377 1
a377 1
    if( Abs(a) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
d379 1
a379 1
    if( Abs(b) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
d381 1
a381 1
    if( (delta = a*a) > SQRT_MAX_FASTF ) return(0);	/* FAIL */
d445 1
a445 1
    return(1);		/* OK */
d464 4
d479 2
a480 2
    if( !bn_poly_cubic_roots( u, &cube ) )  {
	return( 0 );		/* FAIL */
d482 1
a482 1
    if ( u[1].im != 0.0 ){
d491 3
a493 3
    if( p < 0 )  {
	if( p < -1.0e-8 )  {
	    return(0);	/* FAIL */
d499 3
a501 3
    if( q < 0 )  {
	if( q < -1.0e-8 )  {
	    return(0);	/* FAIL */
d518 1
a518 1
    if( Abs( p ) < 1.0e-8){
d523 1
a523 1
	if( Abs( q ) < 1.0e-8 ){
d527 1
a527 1
	    return(0);	/* FAIL */
d533 1
a533 1
    return(1);		/* SUCCESS */
@


14.15
log
@ws
@
text
@d35 1
a35 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.14 2007/01/27 01:41:36 brlcad Exp $ (ARL)";
d58 5
d64 12
d219 2
a220 1
/**	s y n D i v ( )
d252 2
a253 1
/**	q u a d r a t i c ( )
d255 2
a256 2
 *	Uses the quadratic formula to find the roots (in `complex' form)
 *	of any quadratic equation with real coefficients.
d292 2
a293 6
#define SQRT3			1.732050808
#define THIRD			0.333333333333333333333333333
#define INV_TWENTYSEVEN		0.037037037037037037037037037
#define	CUBEROOT( a )	(( (a) >= 0.0 ) ? pow( a, THIRD ) : -pow( -(a), THIRD ))

/**	c u b i c ( )
a321 14
static int	bn_expecting_fpe = 0;
static jmp_buf	bn_abort_buf;
HIDDEN void bn_catch_FPE(int sig)
{
    if( !bn_expecting_fpe )
	bu_bomb("bn_catch_FPE() unexpected SIGFPE!");
    if( !bu_is_parallel() )
	(void)signal(SIGFPE, bn_catch_FPE);	/* Renew handler */
    longjmp(bn_abort_buf, 1);	/* return error code */
}

/*
 *			B N _ P O L Y _ C U B I C _ R O O T S
 */
d421 1
a421 1
 *			B N _ P O L Y _ Q U A R T I C _ R O O T S
d505 3
a507 1
 *			B N _ P R _ P O L Y
d549 4
a552 2
/*
 *			B N _ P R _ R O O T S
@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a33 1

d35 1
a35 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.13 2007/01/23 01:13:33 brlcad Exp $ (ARL)";
a39 1

d43 1
d49 1
d54 1
a54 1
#define M_PI	3.14159265358979323846
d60 1
d69 40
a108 41
	if( m1->dgr == 1 && m2->dgr == 1 )  {
		product->dgr = 2;
		product->cf[0] = m1->cf[0] * m2->cf[0];
		product->cf[1] = m1->cf[0] * m2->cf[1] +
				 m1->cf[1] * m2->cf[0];
		product->cf[2] = m1->cf[1] * m2->cf[1];
		return(product);
	}
	if( m1->dgr == 2 && m2->dgr == 2 )  {
		product->dgr = 4;
		product->cf[0] = m1->cf[0] * m2->cf[0];
		product->cf[1] = m1->cf[0] * m2->cf[1] +
				 m1->cf[1] * m2->cf[0];
		product->cf[2] = m1->cf[0] * m2->cf[2] +
				 m1->cf[1] * m2->cf[1] +
				 m1->cf[2] * m2->cf[0];
		product->cf[3] = m1->cf[1] * m2->cf[2] +
				 m1->cf[2] * m2->cf[1];
		product->cf[4] = m1->cf[2] * m2->cf[2];
		return(product);
	}

	/* Not one of the common (or easy) cases. */
	{
		register int		ct1, ct2;

		*product = bn_Zero_poly;

		/* If the degree of the product will be larger than the
		 * maximum size allowed in "polyno.h", then return a null
		 * pointer to indicate failure.
		 */
		if ( (product->dgr = m1->dgr + m2->dgr) > BN_MAX_POLY_DEGREE )
			return BN_POLY_NULL;

		for ( ct1=0; ct1 <= m1->dgr; ++ct1 ){
			for ( ct2=0; ct2 <= m2->dgr; ++ct2 ){
				product->cf[ct1+ct2] +=
					m1->cf[ct1] * m2->cf[ct2];
			}
		}
d110 2
a111 1
	return product;
d123 1
a123 1
	register int		cnt;
d125 4
a128 4
	for ( cnt=0; cnt <= eqn->dgr; ++cnt ){
		eqn->cf[cnt] *= factor;
	}
	return eqn;
d140 2
a141 2
	LOCAL struct bn_poly	tmp;
	register int		i, offset;
d143 1
a143 1
	offset = Abs(poly1->dgr - poly2->dgr);
d145 1
a145 1
	tmp = bn_Zero_poly;
d147 9
a155 10
	if ( poly1->dgr >= poly2->dgr ){
		*sum = *poly1;
		for ( i=0; i <= poly2->dgr; ++i ){
			tmp.cf[i+offset] = poly2->cf[i];
		}
	} else {
		*sum = *poly2;
		for ( i=0; i <= poly1->dgr; ++i ){
			tmp.cf[i+offset] = poly1->cf[i];
		}
d157 1
d159 4
a162 4
	for ( i=0; i <= sum->dgr; ++i ){
		sum->cf[i] += tmp.cf[i];
	}
	return sum;
d174 2
a175 2
	LOCAL struct bn_poly	tmp;
	register int		i, offset;
d177 1
a177 1
	offset = Abs(poly1->dgr - poly2->dgr);
d179 2
a180 2
	*diff = bn_Zero_poly;
	tmp = bn_Zero_poly;
d182 17
a198 17
	if ( poly1->dgr >= poly2->dgr ){
		*diff = *poly1;
		for ( i=0; i <= poly2->dgr; ++i ){
			tmp.cf[i+offset] = poly2->cf[i];
		}
	} else {
		diff->dgr = poly2->dgr;
		for ( i=0; i <= poly1->dgr; ++i ){
			diff->cf[i+offset] = poly1->cf[i];
		}
		tmp = *poly2;
	}

	for ( i=0; i <= diff->dgr; ++i ){
		diff->cf[i] -= tmp.cf[i];
	}
	return diff;
d210 2
a211 2
	register int	div;
	register int	n;
d213 2
a214 2
	*quo = *dvdend;
	*rem = bn_Zero_poly;
d216 15
a230 15
	if ((quo->dgr = dvdend->dgr - dvsor->dgr) < 0)
		quo->dgr = -1;
	if ((rem->dgr = dvsor->dgr - 1) > dvdend->dgr)
		rem->dgr = dvdend->dgr;

	for ( n=0; n <= quo->dgr; ++n){
		quo->cf[n] /= dvsor->cf[0];
		for ( div=1; div <= dvsor->dgr; ++div){
			quo->cf[n+div] -= quo->cf[n] * dvsor->cf[div];
		}
	}
	for ( n=1; n<=(rem->dgr+1); ++n){
		rem->cf[n-1] = quo->cf[quo->dgr+n];
		quo->cf[quo->dgr+n] = 0;
	}
d242 1
a242 1
	LOCAL fastf_t	discrim, denom, rad;
d244 26
a269 26
	if( NEAR_ZERO( quadrat->cf[0], SQRT_SMALL_FASTF ) )  {
		/* root = -cf[2] / cf[1] */
		if( NEAR_ZERO( quadrat->cf[1], SQRT_SMALL_FASTF ) )  {
			/* No solution.  Now what? */
			bu_log("bn_poly_quadratic_roots(): ERROR, no solution\n");
			return -1;
		}
		/* Fake it as a repeated root. */
		roots[0].re = roots[1].re = -quadrat->cf[2]/quadrat->cf[1];
		roots[0].im = roots[1].im = 0.0;
		return 1;	/* OK - repeated root */
	}
	/* What to do if cf[1] > SQRT_MAX_FASTF ? */

	discrim = quadrat->cf[1]*quadrat->cf[1] - 4.0* quadrat->cf[0]*quadrat->cf[2];
	denom = 0.5 / quadrat->cf[0];
	if ( discrim >= 0.0 ){
		rad = sqrt( discrim );
		roots[0].re = ( -quadrat->cf[1] + rad ) * denom;
		roots[1].re = ( -quadrat->cf[1] - rad ) * denom;
		roots[1].im = roots[0].im = 0.0;
	} else {
		roots[1].re = roots[0].re = -quadrat->cf[1] * denom;
		roots[1].im = -(roots[0].im = sqrt( -discrim ) * denom);
	}
	return 0;		/* OK */
d311 5
a315 5
	if( !bn_expecting_fpe )
		bu_bomb("bn_catch_FPE() unexpected SIGFPE!");
	if( !bu_is_parallel() )
		(void)signal(SIGFPE, bn_catch_FPE);	/* Renew handler */
	longjmp(bn_abort_buf, 1);	/* return error code */
d324 61
a384 52
	LOCAL fastf_t	a, b, c1, c1_3rd, delta;
	register int	i;
	static int	first_time = 1;

	if( !bu_is_parallel() ) {
		/* bn_abort_buf is NOT parallel! */
		if( first_time )  {
			first_time = 0;
			(void)signal(SIGFPE, bn_catch_FPE);
		}
		bn_expecting_fpe = 1;
		if( setjmp( bn_abort_buf ) )  {
			(void)signal(SIGFPE, bn_catch_FPE);
			bu_log("bn_poly_cubic_roots() Floating Point Error\n");
			return(0);	/* FAIL */
		}
	}

	c1 = eqn->cf[1];
	if( Abs(c1) > SQRT_MAX_FASTF )  return(0);	/* FAIL */

	c1_3rd = c1 * THIRD;
	a = eqn->cf[2] - c1*c1_3rd;
	if( Abs(a) > SQRT_MAX_FASTF )  return(0);	/* FAIL */
	b = (2.0*c1*c1*c1 - 9.0*c1*eqn->cf[2] + 27.0*eqn->cf[3])*INV_TWENTYSEVEN;
	if( Abs(b) > SQRT_MAX_FASTF )  return(0);	/* FAIL */

	if( (delta = a*a) > SQRT_MAX_FASTF ) return(0);	/* FAIL */
	delta = b*b*0.25 + delta*a*INV_TWENTYSEVEN;

	if ( delta > 0.0 ){
		LOCAL fastf_t		r_delta, A, B;

		r_delta = sqrt( delta );
		A = B = -0.5 * b;
		A += r_delta;
		B -= r_delta;

		A = CUBEROOT( A );
		B = CUBEROOT( B );

		roots[2].re = roots[1].re = -0.5 * ( roots[0].re = A + B );

		roots[0].im = 0.0;
		roots[2].im = -( roots[1].im = (A - B)*SQRT3*0.5 );
	} else if ( delta == 0.0 ){
		LOCAL fastf_t	b_2;
		b_2 = -0.5 * b;

		roots[0].re = 2.0* CUBEROOT( b_2 );
		roots[2].re = roots[1].re = -0.5 * roots[0].re;
		roots[2].im = roots[1].im = roots[0].im = 0.0;
d386 25
a410 2
		LOCAL fastf_t		phi, fact;
		LOCAL fastf_t		cs_phi, sn_phi_s3;
d412 2
a413 31
		if( a >= 0.0 )  {
			fact = 0.0;
			phi = 0.0;
			cs_phi = 1.0;		/* cos( phi ); */
			sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
		} else {
			FAST fastf_t	f;
			a *= -THIRD;
			fact = sqrt( a );
			if( (f = b * (-0.5) / (a*fact)) >= 1.0 )  {
				phi = 0.0;
				cs_phi = 1.0;		/* cos( phi ); */
				sn_phi_s3 = 0.0;	/* sin( phi ) * SQRT3; */
			}  else if( f <= -1.0 )  {
				phi = PI_DIV_3;
				cs_phi = cos( phi );
				sn_phi_s3 = sin( phi ) * SQRT3;
			}  else  {
				phi = acos( f ) * THIRD;
				cs_phi = cos( phi );
				sn_phi_s3 = sin( phi ) * SQRT3;
			}
		}

		roots[0].re = 2.0*fact*cs_phi;
		roots[1].re = fact*(  sn_phi_s3 - cs_phi);
		roots[2].re = fact*( -sn_phi_s3 - cs_phi);
		roots[2].im = roots[1].im = roots[0].im = 0.0;
	}
	for ( i=0; i < 3; ++i )
		roots[i].re -= c1_3rd;
d415 1
a415 4
	if( !bu_is_parallel() )
		bn_expecting_fpe = 0;

	return(1);		/* OK */
d431 3
a433 3
	LOCAL struct bn_poly	cube, quad1, quad2;
	LOCAL bn_complex_t	u[3];
	LOCAL fastf_t		U, p, q, q1, q2;
d436 56
a491 51
	cube.dgr = 3;
	cube.cf[0] = 1.0;
	cube.cf[1] = -eqn->cf[2];
	cube.cf[2] = eqn->cf[3]*eqn->cf[1]
			- 4*eqn->cf[4];
	cube.cf[3] = -eqn->cf[3]*eqn->cf[3]
			- eqn->cf[4]*eqn->cf[1]*eqn->cf[1]
			+ 4*eqn->cf[4]*eqn->cf[2];

	if( !bn_poly_cubic_roots( u, &cube ) )  {
		return( 0 );		/* FAIL */
	}
	if ( u[1].im != 0.0 ){
		U = u[0].re;
	} else {
		U = Max3( u[0].re, u[1].re, u[2].re );
	}

	p = eqn->cf[1]*eqn->cf[1]*0.25 + U - eqn->cf[2];
	U *= 0.5;
	q = U*U - eqn->cf[4];
	if( p < 0 )  {
		if( p < -1.0e-8 )  {
			return(0);	/* FAIL */
		}
		p = 0;
	} else {
		p = sqrt( p );
	}
	if( q < 0 )  {
		if( q < -1.0e-8 )  {
			return(0);	/* FAIL */
		}
		q = 0;
	} else {
		q = sqrt( q );
	}

	quad1.dgr = quad2.dgr = 2;
	quad1.cf[0] = quad2.cf[0] = 1.0;
	quad1.cf[1] = eqn->cf[1]*0.5;
	quad2.cf[1] = quad1.cf[1] + p;
	quad1.cf[1] -= p;

	q1 = U - q;
	q2 = U + q;

	p = quad1.cf[1]*q2 + quad2.cf[1]*q1 - eqn->cf[3];
	if( Abs( p ) < 1.0e-8){
		quad1.cf[2] = q1;
		quad2.cf[2] = q2;
d493 1
a493 7
		q = quad1.cf[1]*q1 + quad2.cf[1]*q2 - eqn->cf[3];
		if( Abs( q ) < 1.0e-8 ){
			quad1.cf[2] = q2;
			quad2.cf[2] = q1;
		} else {
			return(0);	/* FAIL */
		}
d495 1
d497 3
a499 3
	bn_poly_quadratic_roots( &roots[0], &quad1 );
	bn_poly_quadratic_roots( &roots[2], &quad2 );
	return(1);		/* SUCCESS */
d509 35
a543 35
	register int	n;
	register int	exp;
	struct bu_vls	str;
	char		buf[48];

	bu_vls_init( &str );
	bu_vls_extend( &str, 196 );
	bu_vls_strcat( &str, title );
	sprintf(buf, " polynomial, degree = %d\n", eqn->dgr);
	bu_vls_strcat( &str, buf );

	exp = eqn->dgr;
	for ( n=0; n<=eqn->dgr; n++,exp-- )  {
		register double coeff = eqn->cf[n];
		if( n > 0 )  {
			if( coeff < 0 )  {
				bu_vls_strcat( &str, " - " );
				coeff = -coeff;
			}  else  {
				bu_vls_strcat( &str, " + " );
			}
		}
		bu_vls_printf( &str, "%g", coeff );
		if( exp > 1 )  {
			bu_vls_printf( &str, " *X^%d", exp );
		} else if( exp == 1 )  {

			bu_vls_strcat( &str, " *X" );
		} else {
			/* For constant term, add nothing */
		}
	}
	bu_vls_strcat( &str, "\n" );
	bu_log( "%s", bu_vls_addr(&str) );
	bu_vls_free( &str );
d552 1
a552 1
	register int	i;
d554 4
a557 4
	bu_log("%s: %d roots:\n", title, n );
	for( i=0; i<n; i++ )  {
		bu_log("%4d %e + i * %e\n", i, roots[i].re, roots[i].im );
	}
d559 1
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d36 1
a36 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.12 2007/01/21 04:45:41 brlcad Exp $ (ARL)";
a41 1

d61 1
a61 1
 *	bn_poly_mul 
d115 1
a115 1
 *	bn_poly_scale 
d132 1
a132 1
 *	bn_poly_add 
d166 1
a166 1
 *	bn_poly_sub 
@


14.12
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d36 1
a36 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.11 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.11
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup poly */
/*@@{*/
d24 1
a32 1
 *
d37 1
a37 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.10 2006/09/04 04:42:40 lbutler Exp $ (ARL)";
d560 1
a560 1
/*@@}*/
@


14.10
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d38 1
a38 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
@


14.9
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup libbn */
d35 1
a35 1
/*@@}*/
d38 1
a38 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.8 2005/10/23 04:44:31 brlcad Exp $ (ARL)";
d63 4
a66 2
/*
 *	bn_poly_mul -- multiply two polynomials
d117 4
a120 2
/*
 *	bn_poly_scale -- scale a polynomial
d134 4
a137 2
/*
 *	bn_poly_add -- add two polynomials
d168 4
a171 2
/*
 *	bn_poly_sub -- subtract two polynomials
d204 2
a205 1
/*	s y n D i v ( )
d236 2
a237 2
/*	q u a d r a t i c ( )
 *
d280 2
a281 2
/*	c u b i c ( )
 *
d421 1
a421 1
/*
d423 1
a423 1
 *
d427 2
a428 1
 *	Returns 1 for success, 0 for fail.
d505 1
a505 1
/*
d561 1
a561 1

@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d38 1
a38 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.7 2005/08/12 22:28:35 lbutler Exp $ (ARL)";
@


14.7
log
@Doxygen changes
@
text
@d29 1
a29 1
 *  
d33 1
a33 1
 *  
d38 1
a38 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.6 2005/01/30 20:30:44 brlcad Exp $ (ARL)";
d320 1
a320 1
	
d471 1
a471 1
	
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d33 1
a33 1
 *
d38 1
a38 1
static const char RCSpoly[] = "@@(#)$Header$ (ARL)";
d320 1
a320 1

d471 1
a471 1

@


14.6
log
@update copyright to 2005
@
text
@d21 3
a24 1
 *
d35 2
d38 1
a38 1
static const char RCSpoly[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/poly.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d34 1
a34 1
static const char RCSpoly[] = "@@(#)$Header: /cvs/brlcad/src/libbn/poly.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a31 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d34 1
a34 1
static const char RCSpoly[] = "@@(#)$Header: /cvs/brlcad/src/libbn/poly.c,v 14.3 2004/12/21 05:45:20 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d36 1
a36 1
static const char RCSpoly[] = "@@(#)$Header: /cvs/brlcad/src/libbn/poly.c,v 14.2 2004/12/21 01:52:15 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d36 1
a36 1
static const char RCSpoly[] = "@@(#)$Header: /cvs/brlcad/src/libbn/poly.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *  			P O L Y . C
d36 1
a36 1
static const char RCSpoly[] = "@@(#)$Header: /cvs/brlcad/src/libbn/poly.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (ARL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /cvs/brlcad/src/libbn/poly.c,v 1.2 2004/06/08 19:24:02 morrison Exp $ (ARL)";
d530 10
@


1.2
log
@bye bye externs.h
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header$ (ARL)";
d20 1
a20 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d17 1
a17 1
static const char RCSpoly[] = "@@(#)$Header: /cvs/brlcad/libbn/poly.c,v 1.10 2004/05/10 15:30:43 erikg Exp $ (ARL)";
a29 1
#include "externs.h"
@

