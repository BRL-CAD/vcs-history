head	14.29;
access;
symbols
	rel-7-10-4:14.28
	STABLE:14.28.0.2
	stable-branch:14.10
	rel-7-10-2:14.27
	rel-7-10-0:14.25
	rel-7-8-4:14.21
	rel-7-8-2:14.19
	rel-7-8-0:14.19
	trimnurbs-branch:14.18.0.2
	help:14.18
	temp_tag:14.14
	bobWinPort-20051223-freeze:14.11
	postmerge-20051223-bobWinPort:14.14
	premerge-20051223-bobWinPort:14.14
	rel-7-6-6:14.14
	rel-7-6-4:14.14
	rel-7-6-2:14.11
	rel-7-6-branch:14.11.0.4
	rel-7-6-0:14.11
	rel-7-4-2:14.10
	rel-7-4-branch:14.10.0.2
	bobWinPort:14.11.0.2
	rel-7-4-0:14.10
	rel-7-2-6:14.10
	rel-7-2-4:14.10
	rel-7-2-2:14.10
	rel-7-2-0:14.9
	rel-7-0-4:14.8
	rel-7-0-2:14.8
	rel-7-0-1:14.8
	opensource-post:14.8
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.29
date	2007.09.15.16.23.07;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.08.30.18.44.27;	author erikgreenwald;	state Exp;
branches;
next	14.27;

14.27
date	2007.06.18.04.48.12;	author johnranderson;	state Exp;
branches;
next	14.26;

14.26
date	2007.04.16.21.15.36;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.01.27.01.41.35;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.23.01.13.33;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.20.14.36.50;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2006.09.07.01.19.17;	author lbutler;	state Exp;
branches;
next	14.20;

14.20
date	2006.08.01.15.02.55;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.03.24.22.18.49;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.02.27.07.44.11;	author brlcad;	state Exp;
branches
	14.18.2.1;
next	14.17;

14.17
date	2006.01.28.00.36.28;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.01.22.18.44.29;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.11.08.14.51.07;	author lbutler;	state Exp;
branches;
next	14.13;

14.13
date	2005.10.23.04.44.31;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.10.07.14.27.26;	author d_rossberg;	state Exp;
branches;
next	14.11;

14.11
date	2005.08.12.22.28.35;	author lbutler;	state Exp;
branches
	14.11.4.1;
next	14.10;

14.10
date	2005.03.24.16.05.57;	author bob1961;	state Exp;
branches;
next	14.9;

14.9
date	2005.01.30.20.30.44;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2004.12.21.07.32.30;	author morrison;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.25.29;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.32;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.01.52.15;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.14.05.50.32;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.27;	author morrison;	state Exp;
branches;
next	;

14.11.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.18.2.1
date	2006.04.07.19.30.15;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.29
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                        B N _ T C L . C
 * BRL-CAD
 *
 * Copyright (c) 1995-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup bntcl */
/** @@{ */
/** @@file bn_tcl.c
 *
 * @@brief
 *  Tcl interfaces to all the LIBBN math routines.
 *
 *  @@author
 *	Glenn Durfee
 *
 *  @@par Source
 *	The U. S. Army Research Laboratory
 *  @@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */


#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.28 2007/08/30 18:44:27 erikgreenwald Exp $ (ARL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "tcl.h"

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"

/* Support routines for the math functions */

/* XXX Really need a decode_array function that uses atof(),
 * XXX so that junk like leading { and commas between inputs
 * XXX don't spoil the conversion.
 */

int
bn_decode_mat(fastf_t *m, const char *str)
{
	if( strcmp( str, "I" ) == 0 )  {
		MAT_IDN( m );
		return 16;
	}
	if( *str == '{' )  str++;

	return sscanf(str,
	    "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
	    &m[0], &m[1], &m[2], &m[3], &m[4], &m[5], &m[6], &m[7],
	    &m[8], &m[9], &m[10], &m[11], &m[12], &m[13], &m[14], &m[15]);
}

int
bn_decode_quat(fastf_t *q, const char *str)
{
	if( *str == '{' )  str++;
	return sscanf(str, "%lf %lf %lf %lf", &q[0], &q[1], &q[2], &q[3]);
}

int
bn_decode_vect(fastf_t *v, const char *str)
{
	if( *str == '{' )  str++;
	return sscanf(str, "%lf %lf %lf", &v[0], &v[1], &v[2]);
}

int
bn_decode_hvect(fastf_t *v, const char *str)
{
	if( *str == '{' )  str++;
	return sscanf(str, "%lf %lf %lf %lf", &v[0], &v[1], &v[2], &v[3]);
}

void
bn_encode_mat(struct bu_vls *vp, const mat_t m)
{
	if( m == NULL )  {
		bu_vls_putc(vp, 'I');
		return;
	}

	bu_vls_printf(vp, "%g %g %g %g  %g %g %g %g  %g %g %g %g  %g %g %g %g",
	    m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7],
	    m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
}

void
bn_encode_quat(struct bu_vls *vp, const mat_t q)
{
	bu_vls_printf(vp, "%g %g %g %g", V4ARGS(q));
}

void
bn_encode_vect(struct bu_vls *vp, const mat_t v)
{
	bu_vls_printf(vp, "%g %g %g", V3ARGS(v));
}

void
bn_encode_hvect(struct bu_vls *vp, const mat_t v)
{
	bu_vls_printf(vp, "%g %g %g %g", V4ARGS(v));
}

void
bn_quat_distance_wrapper(double *dp, mat_t q1, mat_t q2)
{
	*dp = quat_distance(q1, q2);
}

void
bn_mat_scale_about_pt_wrapper(int *statusp, mat_t mat, const point_t pt, const double scale)
{
	*statusp = bn_mat_scale_about_pt(mat, pt, scale);
}

static void
bn_mat4x3pnt(fastf_t *o, mat_t m, point_t i)
{
	MAT4X3PNT(o, m, i);
}

static void
bn_mat4x3vec(fastf_t *o, mat_t m, vect_t i)
{
	MAT4X3VEC(o, m, i);
}

static void
bn_hdivide(fastf_t *o, const mat_t i)
{
	HDIVIDE(o, i);
}

static void
bn_vjoin1(fastf_t *o, const point_t pnt, double scale, const vect_t dir)
{
	VJOIN1( o, pnt, scale, dir );
}


static void bn_vblend(mat_t a, fastf_t b, mat_t c, fastf_t d, mat_t e)
{
	VBLEND2( a, b, c, d, e );
}

/**
 *			B N _ M A T H _ C M D
 *@@brief
 * Tcl wrappers for the math functions.
 *
 * This is where you should put clauses, in the below "if" statement, to add
 * Tcl support for the LIBBN math routines.
 */

int
bn_math_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	void (*math_func)();
	struct bu_vls result;

	math_func = (void (*)())clientData; /* object-to-function cast */
	bu_vls_init(&result);

	if (math_func == bn_mat_mul) {
		mat_t o, a, b;
		if (argc < 3 || bn_decode_mat(a, argv[1]) < 16 ||
		    bn_decode_mat(b, argv[2]) < 16) {
			bu_vls_printf(&result, "usage: %s matA matB", argv[0]);
			goto error;
		}
		bn_mat_mul(o, a, b);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_inv || math_func == bn_mat_trn) {
		mat_t o, a;

		if (argc < 2 || bn_decode_mat(a, argv[1]) < 16) {
			bu_vls_printf(&result, "usage: %s mat", argv[0]);
			goto error;
		}
		(*math_func)(o, a);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_matXvec) {
		mat_t m;
		hvect_t i, o;
		if (argc < 3 || bn_decode_mat(m, argv[1]) < 16 ||
		    bn_decode_hvect(i, argv[2]) < 4) {
			bu_vls_printf(&result, "usage: %s mat hvect", argv[0]);
			goto error;
		}
		bn_matXvec(o, m, i);
		bn_encode_hvect(&result, o);
	} else if (math_func == bn_mat4x3pnt) {
		mat_t m;
		point_t i, o;
		if (argc < 3 || bn_decode_mat(m, argv[1]) < 16 ||
		    bn_decode_vect(i, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s mat point", argv[0]);
			goto error;
		}
		bn_mat4x3pnt(o, m, i);
		bn_encode_vect(&result, o);
	} else if (math_func == bn_mat4x3vec) {
		mat_t m;
		vect_t i, o;
		if (argc < 3 || bn_decode_mat(m, argv[1]) < 16 ||
		    bn_decode_vect(i, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s mat vect", argv[0]);
			goto error;
		}
		bn_mat4x3vec(o, m, i);
		bn_encode_vect(&result, o);
	} else if (math_func == bn_hdivide) {
		hvect_t i;
		vect_t o;
		if (argc < 2 || bn_decode_hvect(i, argv[1]) < 4) {
			bu_vls_printf(&result, "usage: %s hvect", argv[0]);
			goto error;
		}
		bn_hdivide(o, i);
		bn_encode_vect(&result, o);
	} else if (math_func == bn_vjoin1) {
		point_t o;
		point_t b, d;
		fastf_t c;

		if (argc < 4) {
			bu_vls_printf(&result, "usage: %s pnt scale dir", argv[0]);
			goto error;
		}
		if( bn_decode_vect(b, argv[1]) < 3) goto error;
		if (Tcl_GetDouble(interp, argv[2], &c) != TCL_OK) goto error;
		if( bn_decode_vect(d, argv[3]) < 3) goto error;

		VJOIN1( o, b, c, d );	/* bn_vjoin1( o, b, c, d ) */
		bn_encode_vect(&result, o);

	} else if ( math_func == bn_vblend) {
		point_t a, c, e;
		fastf_t b, d;

		if( argc < 5 ) {
			bu_vls_printf(&result, "usage: %s scale pnt scale pnt", argv[0]);
			goto error;
		}

		if( Tcl_GetDouble(interp, argv[1], &b) != TCL_OK) goto error;
		if( bn_decode_vect( c, argv[2] ) < 3) goto error;
		if( Tcl_GetDouble(interp, argv[3], &d) != TCL_OK) goto error;
		if( bn_decode_vect( e, argv[4] ) < 3) goto error;

		VBLEND2( a, b, c, d, e )
		bn_encode_vect( &result, a );

	} else if (math_func == bn_mat_ae) {
		mat_t o;
		double az, el;

		if (argc < 3) {
			bu_vls_printf(&result, "usage: %s azimuth elevation", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[1], &az) != TCL_OK) goto error;
		if (Tcl_GetDouble(interp, argv[2], &el) != TCL_OK) goto error;

		bn_mat_ae(o, (fastf_t)az, (fastf_t)el);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_ae_vec) {
		fastf_t az, el;
		vect_t v;

		if (argc < 2 || bn_decode_vect(v, argv[1]) < 3) {
			bu_vls_printf(&result, "usage: %s vect", argv[0]);
			goto error;
		}

		bn_ae_vec(&az, &el, v);
		bu_vls_printf(&result, "%g %g", az, el);
	} else if (math_func == bn_aet_vec) {
		fastf_t az, el, twist, accuracy;
		vect_t vec_ae, vec_twist;

		if (argc < 4 || bn_decode_vect(vec_ae, argv[1]) < 3 ||
		    bn_decode_vect(vec_twist, argv[2]) < 3 ||
		    sscanf(argv[3], "%lf", &accuracy) < 1) {
		  bu_vls_printf(&result, "usage: %s vec_ae vec_twist accuracy",
				argv[0]);
		  goto error;
		}

		bn_aet_vec(&az, &el, &twist, vec_ae, vec_twist, accuracy);
		bu_vls_printf(&result, "%g %g %g", az, el, twist);
	} else if (math_func == bn_mat_angles) {
		mat_t o;
		double alpha, beta, ggamma;

		if (argc < 4) {
			bu_vls_printf(&result, "usage: %s alpha beta gamma", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[1], &alpha) != TCL_OK)  goto error;
		if (Tcl_GetDouble(interp, argv[2], &beta) != TCL_OK)   goto error;
		if (Tcl_GetDouble(interp, argv[3], &ggamma) != TCL_OK) goto error;

		bn_mat_angles(o, alpha, beta, ggamma);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_eigen2x2) {
		fastf_t val1, val2;
		vect_t vec1, vec2;
		double a, b, c;

		if (argc < 4) {
			bu_vls_printf(&result, "usage: %s a b c", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[1], &a) != TCL_OK) goto error;
		if (Tcl_GetDouble(interp, argv[2], &c) != TCL_OK) goto error;
		if (Tcl_GetDouble(interp, argv[3], &b) != TCL_OK) goto error;

		bn_eigen2x2(&val1, &val2, vec1, vec2, (fastf_t)a, (fastf_t)b,
		    (fastf_t)c);
		bu_vls_printf(&result, "%g %g {%g %g %g} {%g %g %g}", val1, val2,
		    V3ARGS(vec1), V3ARGS(vec2));
	} else if (math_func == bn_mat_fromto) {
		mat_t o;
		vect_t from, to;

		if (argc < 3 || bn_decode_vect(from, argv[1]) < 3 ||
		    bn_decode_vect(to, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s vecFrom vecTo", argv[0]);
			goto error;
		}
		bn_mat_fromto(o, from, to);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_xrot || math_func == bn_mat_yrot ||
	    math_func == bn_mat_zrot) {
		mat_t o;
		double s, c;
		if (argc < 3) {
			bu_vls_printf(&result, "usage: %s sinAngle cosAngle", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[1], &s) != TCL_OK) goto error;
		if (Tcl_GetDouble(interp, argv[2], &c) != TCL_OK) goto error;

		(*math_func)(o, s, c);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_lookat) {
		mat_t o;
		vect_t dir;
		int yflip;
		if (argc < 3 || bn_decode_vect(dir, argv[1]) < 3) {
			bu_vls_printf(&result, "usage: %s dir yflip", argv[0]);
			goto error;
		}
		if (Tcl_GetBoolean(interp, argv[2], &yflip) != TCL_OK) goto error;

		bn_mat_lookat(o, dir, yflip);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_vec_ortho || math_func == bn_vec_perp) {
		vect_t ov, vec;

		if (argc < 2 || bn_decode_vect(vec, argv[1]) < 3) {
			bu_vls_printf(&result, "usage: %s vec", argv[0]);
			goto error;
		}

		(*math_func)(ov, vec);
		bn_encode_vect(&result, ov);
	} else if (math_func == bn_mat_scale_about_pt_wrapper) {
		mat_t o;
		vect_t v;
		double scale;
		int status;

		if (argc < 3 || bn_decode_vect(v, argv[1]) < 3) {
			bu_vls_printf(&result, "usage: %s pt scale", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[2], &scale) != TCL_OK) goto error;

		bn_mat_scale_about_pt_wrapper(&status, o, v, scale);
		if (status != 0) {
			bu_vls_printf(&result, "error performing calculation");
			goto error;
		}
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_xform_about_pt) {
		mat_t o, xform;
		vect_t v;

		if (argc < 3 || bn_decode_mat(xform, argv[1]) < 16 ||
		    bn_decode_vect(v, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s xform pt", argv[0]);
			goto error;
		}

		bn_mat_xform_about_pt(o, xform, v);
		bn_encode_mat(&result, o);
	} else if (math_func == bn_mat_arb_rot) {
		mat_t o;
		point_t pt;
		vect_t dir;
		double angle;

		if (argc < 4 || bn_decode_vect(pt, argv[1]) < 3 ||
		    bn_decode_vect(dir, argv[2]) < 3) {
			bu_vls_printf(&result, "usage: %s pt dir angle", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[3], &angle) != TCL_OK)
			return TCL_ERROR;

		bn_mat_arb_rot(o, pt, dir, (fastf_t)angle);
		bn_encode_mat(&result, o);
	} else if (math_func == quat_mat2quat) {
		mat_t mat;
		quat_t quat;

		if (argc < 2 || bn_decode_mat(mat, argv[1]) < 16) {
			bu_vls_printf(&result, "usage: %s mat", argv[0]);
			goto error;
		}

		quat_mat2quat(quat, mat);
		bn_encode_quat(&result, quat);
	} else if (math_func == quat_quat2mat) {
		mat_t mat;
		quat_t quat;

		if (argc < 2 || bn_decode_quat(quat, argv[1]) < 4) {
			bu_vls_printf(&result, "usage: %s quat", argv[0]);
			goto error;
		}

		quat_quat2mat(mat, quat);
		bn_encode_mat(&result, mat);
	} else if (math_func == bn_quat_distance_wrapper) {
		quat_t q1, q2;
		double d;

		if (argc < 3 || bn_decode_quat(q1, argv[1]) < 4 ||
		    bn_decode_quat(q2, argv[2]) < 4) {
			bu_vls_printf(&result, "usage: %s quatA quatB", argv[0]);
			goto error;
		}

		bn_quat_distance_wrapper(&d, q1, q2);
		bu_vls_printf(&result, "%g", d);
	} else if (math_func == quat_double || math_func == quat_bisect ||
	    math_func == quat_make_nearest) {
		quat_t oqot, q1, q2;

		if (argc < 3 || bn_decode_quat(q1, argv[1]) < 4 ||
		    bn_decode_quat(q2, argv[2]) < 4) {
			bu_vls_printf(&result, "usage: %s quatA quatB", argv[0]);
			goto error;
		}

		(*math_func)(oqot, q1, q2);
		bn_encode_quat(&result, oqot);
	} else if (math_func == quat_slerp) {
		quat_t oq, q1, q2;
		double d;

		if (argc < 4 || bn_decode_quat(q1, argv[1]) < 4 ||
		    bn_decode_quat(q2, argv[2]) < 4) {
			bu_vls_printf(&result, "usage: %s quat1 quat2 factor", argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[3], &d) != TCL_OK) goto error;

		quat_slerp(oq, q1, q2, d);
		bn_encode_quat(&result, oq);
	} else if (math_func == quat_sberp) {
		quat_t oq, q1, qa, qb, q2;
		double d;

		if (argc < 6 || bn_decode_quat(q1, argv[1]) < 4 ||
		    bn_decode_quat(qa, argv[2]) < 4 || bn_decode_quat(qb, argv[3]) < 4 ||
		    bn_decode_quat(q2, argv[4]) < 4) {
			bu_vls_printf(&result, "usage: %s quat1 quatA quatB quat2 factor",
			    argv[0]);
			goto error;
		}
		if (Tcl_GetDouble(interp, argv[5], &d) != TCL_OK) goto error;

		quat_sberp(oq, q1, qa, qb, q2, d);
		bn_encode_quat(&result, oq);
	} else if (math_func == quat_exp || math_func == quat_log) {
		quat_t qout, qin;

		if (argc < 2 || bn_decode_quat(qin, argv[1]) < 4) {
			bu_vls_printf(&result, "usage: %s quat", argv[0]);
			goto error;
		}

		(*math_func)(qout, qin);
		bn_encode_quat(&result, qout);
	} else if (math_func == (void (*)())bn_isect_line3_line3) {
	    double t, u;
	    point_t pt, a;
	    vect_t dir, c;
	    int i;
	    static const struct bn_tol tol = {
		BN_TOL_MAGIC, 0.005, 0.005*0.005, 1e-6, 1-1e-6
	    };
	    if (argc != 5) {
		bu_vls_printf(&result,
		      "Usage: bn_isect_line3_line3 pt dir pt dir (%d args specified)",
			      argc-1);
		goto error;
	    }

	    if (bn_decode_vect(pt, argv[1]) < 3) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no pt: %s\n", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(dir, argv[2]) < 3) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no dir: %s\n", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(a, argv[3]) < 3) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no a pt: %s\n", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(c, argv[4]) < 3) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no c dir: %s\n", argv[0]);
		goto error;
	    }
	    i = bn_isect_line3_line3(&t, &u, pt, dir, a, c, &tol);
	    if (i != 1) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no intersection: %s\n", argv[0]);
		goto error;
	    }

	    VJOIN1(a, pt, t, dir);
	    bn_encode_vect(&result, a);

	} else if (math_func == (void (*)())bn_isect_line2_line2) {
	    double dist[2];
	    point_t pt, a;
	    vect_t dir, c;
	    int i;
	    static const struct bn_tol tol = {
		BN_TOL_MAGIC, 0.005, 0.005*0.005, 1e-6, 1-1e-6
	    };

	    if (argc != 5) {
		bu_vls_printf(&result,
		      "Usage: bn_isect_line2_line2 pt dir pt dir (%d args specified)",
			      argc-1);
		goto error;
	    }

	    /* i = bn_isect_line2_line2 {0 0} {1 0} {1 1} {0 -1} */

	    VSETALL(pt, 0.0);
	    VSETALL(dir, 0.0);
	    VSETALL(a, 0.0);
	    VSETALL(c, 0.0);

	    if (bn_decode_vect(pt, argv[1]) < 2) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no pt: %s\n", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(dir, argv[2]) < 2) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no dir: %s\n", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(a, argv[3]) < 2) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no a pt: %s\n", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(c, argv[4]) < 2) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no c dir: %s\n", argv[0]);
		goto error;
	    }
	    i = bn_isect_line2_line2(dist, pt, dir, a, c, &tol);
	    if (i != 1) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no intersection: %s\n", argv[0]);
		goto error;
	    }

	    VJOIN1(a, pt, dist[0], dir);
	    bu_vls_printf(&result, "%g %g", a[0], a[1]);

	} else {
		bu_vls_printf(&result, "libbn/bn_tcl.c: math function %s not supported yet\n", argv[0]);
		goto error;
	}

	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;

error:
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_ERROR;
}

static struct math_func_link {
	char *name;
	void (*func)();
} math_funcs[] = {
    {"bn_isect_line2_line2",	(void (*)())bn_isect_line2_line2},
    {"bn_isect_line3_line3",	(void (*)())bn_isect_line3_line3},
	{"mat_mul",            bn_mat_mul},
	{"mat_inv",            bn_mat_inv},
	{"mat_trn",            bn_mat_trn},
	{"matXvec",            bn_matXvec},
	{"mat4x3vec",          bn_mat4x3vec},
	{"mat4x3pnt",          bn_mat4x3pnt},
	{"hdivide",            bn_hdivide},
	{"vjoin1",	      bn_vjoin1},
	{"vblend",		bn_vblend},
	{"mat_ae",             bn_mat_ae},
	{"mat_ae_vec",         bn_ae_vec},
	{"mat_aet_vec",        bn_aet_vec},
	{"mat_angles",         bn_mat_angles},
	{"mat_eigen2x2",       bn_eigen2x2},
	{"mat_fromto",         bn_mat_fromto},
	{"mat_xrot",           bn_mat_xrot},
	{"mat_yrot",           bn_mat_yrot},
	{"mat_zrot",           bn_mat_zrot},
	{"mat_lookat",         bn_mat_lookat},
	{"mat_vec_ortho",      bn_vec_ortho},
	{"mat_vec_perp",       bn_vec_perp},
	{"mat_scale_about_pt", bn_mat_scale_about_pt_wrapper},
	{"mat_xform_about_pt", bn_mat_xform_about_pt},
	{"mat_arb_rot",        bn_mat_arb_rot},
	{"quat_mat2quat",      quat_mat2quat},
	{"quat_quat2mat",      quat_quat2mat},
	{"quat_distance",      bn_quat_distance_wrapper},
	{"quat_double",        quat_double},
	{"quat_bisect",        quat_bisect},
	{"quat_slerp",         quat_slerp},
	{"quat_sberp",         quat_sberp},
	{"quat_make_nearest",  quat_make_nearest},
	{"quat_exp",           quat_exp},
	{"quat_log",           quat_log},
	{0, 0}
};

int
bn_cmd_noise_perlin(ClientData clientData,
		  Tcl_Interp *interp,
		  int argc,
		  char **argv)
{
	point_t pt;
	double	v;

	if (argc != 4) {
		Tcl_AppendResult(interp, "wrong # args: should be \"",
				 argv[0], " X Y Z \"",
				 NULL);
		return TCL_ERROR;
	}

	pt[X] = atof(argv[1]);
	pt[Y] = atof(argv[2]);
	pt[Z] = atof(argv[3]);

	v = bn_noise_perlin( pt );
	Tcl_SetObjResult( interp, Tcl_NewDoubleObj(v) );

	return TCL_OK;
}

/*
 *  usage: bn_noise_fbm X Y Z h_val lacunarity octaves
 *
 */
int
bn_cmd_noise(ClientData clientData,
		 Tcl_Interp *interp,
		 int argc,
		 char **argv)
{
	point_t pt;
	double h_val;
	double lacunarity;
	double octaves;
	double val;

	if (argc != 7) {
		Tcl_AppendResult(interp, "wrong # args: should be \"",
				 argv[0], " X Y Z h_val lacunarity octaves\"",
				 NULL);
		return TCL_ERROR;
	}

	pt[0] = atof(argv[1]);
	pt[1] = atof(argv[2]);
	pt[2] = atof(argv[3]);

	h_val = atof(argv[4]);
	lacunarity = atof(argv[5]);
	octaves = atof(argv[6]);


	if (!strcmp("bn_noise_turb", argv[0])) {
		val = bn_noise_turb(pt, h_val, lacunarity, octaves);

		Tcl_SetObjResult( interp, Tcl_NewDoubleObj(val) );
	} else 	if (!strcmp("bn_noise_fbm", argv[0])) {
		val = bn_noise_fbm(pt, h_val, lacunarity, octaves);
		Tcl_SetObjResult( interp, Tcl_NewDoubleObj(val) );
	} else {
		Tcl_AppendResult(interp, "Unknown noise type \"",
				 argv[0], "\"",	 NULL);
		return TCL_ERROR;
	}
	return TCL_OK;
}


/**
 * @@brief
 *	usage: noise_slice xdim ydim inv h_val lac octaves dX dY dZ sX [sY sZ]
 *
 *	The idea here is to get a whole slice of noise at once, thereby
 *	avoiding the overhead of doing this in Tcl.
 */
int
bn_cmd_noise_slice(ClientData clientData,
		  Tcl_Interp *interp,
		  int argc,
		  char **argv)
{
	double h_val;
	double lacunarity;
	double octaves;

	vect_t delta; 	/* translation to noise space */
	vect_t scale; 	/* scale to noise space */
	unsigned xdim;	/* # samples X direction */
	unsigned ydim;	/* # samples Y direction */
	unsigned xval, yval;
#define NOISE_FBM 0
#define NOISE_TURB 1

	int noise_type = NOISE_FBM;
	double val;
	point_t pt;

	if (argc != 7) {
		Tcl_AppendResult(interp, "wrong # args: should be \"",
				 argv[0], " Xdim Ydim Zval h_val lacunarity octaves\"",
				 NULL);
		return TCL_ERROR;
	}

	xdim = atoi(argv[0]);
	ydim = atoi(argv[1]);
	VSETALL(delta, 0.0);
	VSETALL(scale, 1.);
	pt[Z] = delta[Z] = atof(argv[2]);
	h_val = atof(argv[3]);
	lacunarity = atof(argv[4]);
	octaves = atof(argv[5]);

	switch (noise_type) {
	case NOISE_FBM:
		for (yval = 0 ; yval < ydim ; yval++) {

		    pt[Y] = yval * scale[Y] + delta[Y];

		    for (xval = 0 ; xval < xdim ; xval++) {
			pt[X] = xval * scale[X] + delta[X];

			val = bn_noise_fbm(pt, h_val, lacunarity, octaves);

		    }
		}
		break;
	case NOISE_TURB:
		for (yval = 0 ; yval < ydim ; yval++) {

		    pt[Y] = yval * scale[Y] + delta[Y];

		    for (xval = 0 ; xval < xdim ; xval++) {
			pt[X] = xval * scale[X] + delta[X];

			val = bn_noise_turb(pt, h_val, lacunarity, octaves);

		    }
		}
		break;
	}


	pt[0] = atof(argv[1]);
	pt[1] = atof(argv[2]);
	pt[2] = atof(argv[3]);

	h_val = atof(argv[4]);
	lacunarity = atof(argv[5]);
	octaves = atof(argv[6]);


	if (!strcmp("bn_noise_turb", argv[0])) {
		val = bn_noise_turb(pt, h_val, lacunarity, octaves);
		Tcl_SetObjResult( interp, Tcl_NewDoubleObj(val) );
	} else 	if (!strcmp("bn_noise_fbm", argv[0])) {
		val = bn_noise_fbm(pt, h_val, lacunarity, octaves);
		Tcl_SetObjResult( interp, Tcl_NewDoubleObj(val) );
	} else {
		Tcl_AppendResult(interp, "Unknown noise type \"",
				 argv[0], "\"",	 NULL);
		return TCL_ERROR;
	}
	return TCL_OK;
}


int
bn_cmd_random(ClientData clientData,
		  Tcl_Interp *interp,
		  int argc,
		  char **argv)
{
	int val;
	const char *str;
	double rnd;
	char buf[32];

	if (argc != 2) {
		Tcl_AppendResult(interp, "Wrong # args:  Should be \"",
				 argv[0], " varname\"", NULL);
		return TCL_ERROR;
	}

	if (! (str=Tcl_GetVar(interp, argv[1], 0))) {
		Tcl_AppendResult(interp, "Error getting variable ",
				 argv[1], NULL);
		return TCL_ERROR;
	}
	val = atoi(str);

	if (val < 0) val = 0;

	rnd = BN_RANDOM(val);

	snprintf(buf, 32, "%d", val);

	if (!Tcl_SetVar(interp, argv[1], buf, 0)) {
		Tcl_AppendResult(interp, "Error setting variable ",
				 argv[1], NULL);
		return TCL_ERROR;
	}

	snprintf(buf, 32, "%g", rnd);
	Tcl_AppendResult(interp, buf, NULL);
	return TCL_OK;
}

/**
 *			B N _ M A T _ P R I N T
 */
void
bn_tcl_mat_print(Tcl_Interp		*interp,
		 const char		*title,
		 const mat_t		m)
{
	char		obuf[1024];	/* sprintf may be non-PARALLEL */

	bn_mat_print_guts(title, m, obuf, 1024);
	Tcl_AppendResult(interp, obuf, "\n", (char *)NULL);
}


/**
 *			B N _ T C L _ S E T U P
 *@@brief
 *  Add all the supported Tcl interfaces to LIBBN routines to
 *  the list of commands known by the given interpreter.
 */
void
bn_tcl_setup(Tcl_Interp *interp)
{
	struct math_func_link *mp;

	for (mp = math_funcs; mp->name != NULL; mp++) {
		(void)Tcl_CreateCommand(interp, mp->name,
		    (Tcl_CmdProc *)bn_math_cmd,
		    (ClientData)mp->func, /* Function-to-Object pointer cast */
		    (Tcl_CmdDeleteProc *)NULL);
	}

	(void)Tcl_CreateCommand(interp, "bn_noise_perlin",
		(Tcl_CmdProc *)bn_cmd_noise_perlin, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_noise_turb",
		(Tcl_CmdProc *)bn_cmd_noise, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_noise_fbm",
		(Tcl_CmdProc *)bn_cmd_noise, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_noise_slice",
		(Tcl_CmdProc *)bn_cmd_noise_slice, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

	(void)Tcl_CreateCommand(interp, "bn_random",
		(Tcl_CmdProc *)bn_cmd_random, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);
}


/**
 *			B N _ I N I T
 *@@brief
 *  Allows LIBBN to be dynamically loade to a vanilla tclsh/wish with
 *  "load /usr/brlcad/lib/libbn.so"
 *
 *  The name of this function is specified by TCL.
 */
int
#ifdef BRLCAD_DEBUG
Bn_d_Init(Tcl_Interp *interp)
#else
Bn_Init(Tcl_Interp *interp)
#endif
{
	bn_tcl_setup(interp);
	return TCL_OK;
}


double bn_noise_fbm(point_t point,double h_val,double lacunarity,double octaves);
double bn_noise_turb(point_t point,double h_val,double lacunarity,double octaves);
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.28
log
@various minor fixes from "flawfinder" and compiler warnings
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.27 2007/06/18 04:48:12 johnranderson Exp $ (ARL)";
d45 1
a45 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.27
log
@Eliminated more instances of direct access of interp->result (not allowed
since tcl 8.0)
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.26 2007/04/16 21:15:36 brlcad Exp $ (ARL)";
d532 1
a532 1
	    const static struct bn_tol tol = {
d572 1
a572 1
	    const static struct bn_tol tol = {
d874 1
a874 1
	sprintf(buf, "%d", val);
d882 1
a882 1
	sprintf(buf, "%g", rnd);
d897 1
a897 1
	bn_mat_print_guts(title, m, obuf);
@


14.26
log
@revamp BRL-CAD's versioning setup.  no longer rely upon the vers.sh script, allowing for a more unified cross-platform configuration.  instead of globals, provide per-library functions that return the version string.  the version numbers are now stored in files in include/conf/.
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.25 2007/01/27 01:41:35 brlcad Exp $ (ARL)";
d694 1
a694 1
	sprintf(interp->result, "%g", v );
d734 1
a734 1
		sprintf(interp->result, "%g", val );
d737 1
a737 1
		sprintf(interp->result, "%g", val );
d833 1
a833 2

		sprintf(interp->result, "%g", val );
d836 1
a836 1
		sprintf(interp->result, "%g", val );
@


14.25
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.24 2007/01/23 01:13:33 brlcad Exp $ (ARL)";
d902 1
d940 1
a942 3
	Tcl_SetVar(interp, "bn_version", (char *)bn_version+5, TCL_GLOBAL_ONLY);
}

@


14.24
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.23 2007/01/21 04:45:41 brlcad Exp $ (ARL)";
d536 1
a536 1
		bu_vls_printf(&result, 
d577 1
a577 1
		bu_vls_printf(&result, 
@


14.23
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.22 2007/01/20 14:36:50 brlcad Exp $ (ARL)";
@


14.22
log
@update copyright to 2007
@
text
@d21 2
a22 2
/** \addtogroup bntcl */
/*@@{*/
d24 1
d33 1
a33 1
 *@@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.21 2006/09/07 01:19:17 lbutler Exp $ (ARL)";
d967 1
a967 1
/*@@}*/
@


14.21
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1995-2006 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.20 2006/08/01 15:02:55 brlcad Exp $ (ARL)";
@


14.20
log
@refactor the three asize.c implementations (libbn, libfb, & canon) into just one.  libbn had the most comprehensive and updated version, but the logic belongs in libfb.  so, the bn_common autosizing functions are now consolidated to libfb, refactoring accordingly.
@
text
@d21 1
a21 1
/** \addtogroup libbn */
d24 1
d27 1
a27 1
 *  Author -
d30 1
a30 1
 *  Source -
d32 1
a32 1
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
d34 1
a34 1
/*@@}*/
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.19 2006/03/24 22:18:49 brlcad Exp $ (ARL)";
d174 1
a174 1
/*
d176 1
a176 1
 *
d747 2
a748 1
/*
d888 1
a888 1
/*
d902 1
a902 1
/*
d904 1
a904 1
 *
d944 1
a944 1
/*
d946 1
a946 1
 *
d966 1
a966 1

@


14.19
log
@ack, missing the %s for a slew of printfings, quell intel compiler warnings
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.18 2006/02/27 07:44:11 brlcad Exp $ (ARL)";
a671 27
/*
 *			B N _ C M D _ C O M M O N _ F I L E _ S I Z E
 */
int
bn_cmd_common_file_size(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    unsigned long int width, height;
    int pixel_size = 3;

    if (argc != 2 && argc != 3) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
			 " fileName [#bytes/pixel]\"", NULL);
	return TCL_ERROR;
    }

    if( argc >= 3 )  pixel_size = atoi(argv[2]);

    if (bn_common_file_size(&width, &height, argv[1], pixel_size) > 0) {
	sprintf(interp->result, "%lu %lu", width, height);
	return TCL_OK;
    }

    /* Signal error */
    Tcl_SetResult(interp, "0 0", TCL_STATIC);
    return TCL_OK;
}

a933 4
	(void)Tcl_CreateCommand(interp, "bn_common_file_size",
		(Tcl_CmdProc *)bn_cmd_common_file_size, (ClientData)NULL,
		(Tcl_CmdDeleteProc *)NULL);

@


14.18
log
@common file size is unsigned
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.17 2006/01/28 00:36:28 brlcad Exp $ (ARL)";
d542 1
a542 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no pt", argv[0]);
d546 1
a546 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no dir", argv[0]);
d550 1
a550 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no a pt", argv[0]);
d554 1
a554 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no c dir", argv[0]);
d559 1
a559 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no intersection", argv[0]);
d590 1
a590 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no pt", argv[0]);
d594 1
a594 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no dir", argv[0]);
d598 1
a598 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no a pt", argv[0]);
d602 1
a602 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no c dir", argv[0]);
d607 1
a607 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no intersection", argv[0]);
d615 1
a615 1
		bu_vls_printf(&result, "libbn/bn_tcl.c: math function %s not supported yet", argv[0]);
d690 1
a690 1
	sprintf(interp->result, "%d %d", width, height);
@


14.18.2.1
log
@update from HEAD
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.18 2006/02/27 07:44:11 brlcad Exp $ (ARL)";
d542 1
a542 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no pt: %s\n", argv[0]);
d546 1
a546 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no dir: %s\n", argv[0]);
d550 1
a550 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no a pt: %s\n", argv[0]);
d554 1
a554 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no c dir: %s\n", argv[0]);
d559 1
a559 1
		bu_vls_printf(&result, "bn_isect_line3_line3 no intersection: %s\n", argv[0]);
d590 1
a590 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no pt: %s\n", argv[0]);
d594 1
a594 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no dir: %s\n", argv[0]);
d598 1
a598 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no a pt: %s\n", argv[0]);
d602 1
a602 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no c dir: %s\n", argv[0]);
d607 1
a607 1
		bu_vls_printf(&result, "bn_isect_line2_line2 no intersection: %s\n", argv[0]);
d615 1
a615 1
		bu_vls_printf(&result, "libbn/bn_tcl.c: math function %s not supported yet\n", argv[0]);
d690 1
a690 1
	sprintf(interp->result, "%lu %lu", width, height);
@


14.17
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.16 2006/01/22 18:44:29 brlcad Exp $ (ARL)";
d678 1
a678 1
    long int width, height;
@


14.16
log
@common file size uses longs now
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.15 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d41 1
@


14.15
log
@update copyright to 2006
@
text
@a20 1

d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.14 2005/11/08 14:51:07 lbutler Exp $ (ARL)";
a38 1

a40 2


d44 1
a44 1
#include <string.h>
d46 1
a46 1
#include <strings.h>
d677 1
a677 1
    int width, height;
@


14.14
log
@Exposed two additional routines in the Tcl interface:
	bn_isect_line2_line2
	bn_isect_line3_line3
This allows us to process data from the Arcsecond Vulcan(tm) in Tcl scripts
instead of C code.
@
text
@d4 1
a4 1
 * Copyright (C) 1995-2005 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.13 2005/10/23 04:44:31 brlcad Exp $ (ARL)";
@


14.13
log
@trailing ws
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.12 2005/10/07 14:27:26 d_rossberg Exp $ (ARL)";
d529 88
d636 2
@


14.12
log
@initialize scale structure
@
text
@d29 1
a29 1
 *  
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.11 2005/08/12 22:28:35 lbutler Exp $ (ARL)";
d593 1
a593 1
    
d731 1
a731 1
	case NOISE_FBM: 
d758 1
a758 1
	 
d803 1
a803 1
		Tcl_AppendResult(interp, "Error getting variable ", 
@


14.11
log
@Doxygen changes
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.10 2005/03/24 16:05:57 bob1961 Exp $ (ARL)";
d724 1
@


14.11.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
a528 88
	} else if (math_func == (void (*)())bn_isect_line3_line3) {
	    double t, u;
	    point_t pt, a;
	    vect_t dir, c;
	    int i;
	    const static struct bn_tol tol = {
		BN_TOL_MAGIC, 0.005, 0.005*0.005, 1e-6, 1-1e-6
	    };
	    if (argc != 5) {
		bu_vls_printf(&result, 
		      "Usage: bn_isect_line3_line3 pt dir pt dir (%d args specified)",
			      argc-1);
		goto error;
	    }

	    if (bn_decode_vect(pt, argv[1]) < 3) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no pt", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(dir, argv[2]) < 3) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no dir", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(a, argv[3]) < 3) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no a pt", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(c, argv[4]) < 3) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no c dir", argv[0]);
		goto error;
	    }
	    i = bn_isect_line3_line3(&t, &u, pt, dir, a, c, &tol);
	    if (i != 1) {
		bu_vls_printf(&result, "bn_isect_line3_line3 no intersection", argv[0]);
		goto error;
	    }

	    VJOIN1(a, pt, t, dir);
	    bn_encode_vect(&result, a);

	} else if (math_func == (void (*)())bn_isect_line2_line2) {
	    double dist[2];
	    point_t pt, a;
	    vect_t dir, c;
	    int i;
	    const static struct bn_tol tol = {
		BN_TOL_MAGIC, 0.005, 0.005*0.005, 1e-6, 1-1e-6
	    };

	    if (argc != 5) {
		bu_vls_printf(&result, 
		      "Usage: bn_isect_line2_line2 pt dir pt dir (%d args specified)",
			      argc-1);
		goto error;
	    }

	    /* i = bn_isect_line2_line2 {0 0} {1 0} {1 1} {0 -1} */

	    VSETALL(pt, 0.0);
	    VSETALL(dir, 0.0);
	    VSETALL(a, 0.0);
	    VSETALL(c, 0.0);

	    if (bn_decode_vect(pt, argv[1]) < 2) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no pt", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(dir, argv[2]) < 2) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no dir", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(a, argv[3]) < 2) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no a pt", argv[0]);
		goto error;
	    }
	    if (bn_decode_vect(c, argv[4]) < 2) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no c dir", argv[0]);
		goto error;
	    }
	    i = bn_isect_line2_line2(dist, pt, dir, a, c, &tol);
	    if (i != 1) {
		bu_vls_printf(&result, "bn_isect_line2_line2 no intersection", argv[0]);
		goto error;
	    }

	    VJOIN1(a, pt, dist[0], dir);
	    bu_vls_printf(&result, "%g %g", a[0], a[1]);

a547 2
    {"bn_isect_line2_line2",	(void (*)())bn_isect_line2_line2},
    {"bn_isect_line3_line3",	(void (*)())bn_isect_line3_line3},
d593 1
a593 1

a723 1
	VSETALL(scale, 1.);
d730 1
a730 1
	case NOISE_FBM:
d757 1
a757 1

d802 1
a802 1
		Tcl_AppendResult(interp, "Error getting variable ",
@


14.10
log
@Add cpp directives to optionally compile Bn_d_Init
@
text
@d21 3
a24 1
 *
d34 2
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.9 2005/01/30 20:30:44 brlcad Exp $ (ARL)";
@


14.9
log
@update copyright to 2005
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/bn_tcl.c,v 14.8 2004/12/21 07:32:30 morrison Exp $ (ARL)";
d890 3
d894 1
@


14.8
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1995-2004 United States Government as represented by
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 14.7 2004/12/21 07:25:29 morrison Exp $ (ARL)";
@


14.7
log
@tidy up a lil bit
@
text
@a30 2
 *  
 *
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 14.6 2004/12/21 06:58:42 morrison Exp $ (ARL)";
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 14.5 2004/12/21 06:44:32 morrison Exp $ (ARL)";
a638 2
 *
 *
@


14.5
log
@remove the old distribution notice section
@
text
@a32 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a31 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 14.3 2004/12/21 05:45:20 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 14.2 2004/12/21 01:52:15 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			B N _ T C L . C
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 1.4 2004/10/14 05:50:32 morrison Exp $ (ARL)";
@


1.4
log
@quell a slew of ansi conversion warnings caught somehow by mipspro on o32.  the ansi converter seemed to prefer converting mat_t's to fastf_t *'s -- which while technically should be just fine, there is a different implicit meaning in brl-cad.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 1.3 2004/09/03 23:30:57 morrison Exp $ (ARL)";
d891 10
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 1.2 2004/08/02 23:01:48 morrison Exp $ (ARL)";
d90 1
a90 1
bn_encode_mat(struct bu_vls *vp, const fastf_t *m)
d103 1
a103 1
bn_encode_quat(struct bu_vls *vp, const fastf_t *q)
d109 1
a109 1
bn_encode_vect(struct bu_vls *vp, const fastf_t *v)
d115 1
a115 1
bn_encode_hvect(struct bu_vls *vp, const fastf_t *v)
d121 1
a121 1
bn_quat_distance_wrapper(double *dp, fastf_t *q1, fastf_t *q2)
d127 1
a127 1
bn_mat_scale_about_pt_wrapper(int *statusp, fastf_t *mat, const fastf_t *pt, const double scale)
d133 1
a133 1
bn_mat4x3pnt(fastf_t *o, fastf_t *m, fastf_t *i)
d139 1
a139 1
bn_mat4x3vec(fastf_t *o, fastf_t *m, fastf_t *i)
d145 1
a145 1
bn_hdivide(fastf_t *o, const fastf_t *i)
d151 1
a151 1
bn_vjoin1(fastf_t *o, const fastf_t *pnt, double scale, const fastf_t *dir)
d157 1
a157 1
static void bn_vblend(fastf_t *a, fastf_t b, fastf_t *c, fastf_t d, fastf_t *e)
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/bn_tcl.c,v 1.1 2004/05/20 15:19:27 morrison Exp $ (ARL)";
d33 1
a33 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/bn_tcl.c,v 1.49 2004/05/10 15:30:43 erikg Exp $ (ARL)";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

