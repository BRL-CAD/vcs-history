head	14.16;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.6
	rel-7-10-2:14.16
	rel-7-10-0:14.15
	rel-7-8-4:14.11
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.4
	rel-7-6-0:14.8
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.8.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.16
date	2007.07.26.01.13.55;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.33;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.09.04.04.42.40;	author lbutler;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.31;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.08.15.21.18.14;	author bob1961;	state Exp;
branches
	14.8.4.1;
next	14.7;

14.7
date	2005.08.12.22.28.35;	author lbutler;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.44;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.01.52.15;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.24.02;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.29;	author morrison;	state Exp;
branches;
next	;

14.8.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@/*                         P L O T 3 . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup plot */
/** @@{ */
/** @@file plot3.c
 *
 * @@brief
 *  A public-domain UNIX plot library, for 2-D and 3-D plotting in
 *  16-bit VAX signed integer spaces, or 64-bit IEEE floating point.
 *
 *  These routines generate "UNIX plot" output (with the addition
 *  of 3-D commands).  They behave almost exactly like the regular
 *  libplot routines, except:
 *
 *  -# These all take a stdio file pointer, and can thus be used to create multiple plot files simultaneously.
 *  -# There are 3-D versions of most commands.
 *  -# There are IEEE floating point versions of the commands.
 *  -# The names have been changed.
 *
 *  The 3-D extensions are those of Doug Gwyn, from his System V extensions.
 *
 *  Author -
 *	Phillip Dykstra
 *	24 Sep 1986
 */


#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.15 2007/01/27 01:41:36 brlcad Exp $ (BRL)";
#endif

#include "common.h"


#include <stdio.h>

#include "machine.h"
#include "vmath.h"
#include "plot3.h"


static int pl_outputMode = PL_OUTPUT_MODE_BINARY;

/* For the sake of efficiency, we trust putc() to write only one byte */
/*#define putsi(a)	putc(a&0377,plotfp); putc((a>>8)&0377,plotfp)*/
#define putsi(a)	putc(a,plotfp); putc((a>>8),plotfp)


/*
 *  These interfaces provide the standard UNIX-Plot functionality
 */

int
pl_getOutputMode() {
    return pl_outputMode;
}

void
pl_setOutputMode(int mode) {
    pl_outputMode = mode;
}

/**
 * @@brief
 * plot a point
 */
void
pl_point(register FILE *plotfp, int x, int y)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'p', plotfp );
	putsi( x );
	putsi( y );
    } else {
	fprintf(plotfp, "p %d %d\n", x, y);
    }
}

void
pl_line(register FILE *plotfp, int x1, int y1, int x2, int y2)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'l', plotfp );
	putsi( x1 );
	putsi( y1 );
	putsi( x2 );
	putsi( y2 );
    } else {
	fprintf(plotfp, "l %d %d %d %d\n", x1, y1, x2, y2);
    }
}

void
pl_linmod(register FILE *plotfp, register char *s)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'f', plotfp );
	while( *s )
		putc( *s++, plotfp );
	putc( '\n', plotfp );
    } else {
	fprintf(plotfp, "f %s\n", s);
    }
}

void
pl_move(register FILE *plotfp, int x, int y)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'm', plotfp );
	putsi( x );
	putsi( y );
    } else {
	fprintf(plotfp, "m %d %d\n", x, y);
    }
}

void
pl_cont(register FILE *plotfp, int x, int y)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'n', plotfp );
	putsi( x );
	putsi( y );
    } else {
	fprintf(plotfp, "n %d %d\n", x, y);
    }
}

void
pl_label(register FILE *plotfp, register char *s)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 't', plotfp );
	while( *s )
		putc( *s++, plotfp );
	putc( '\n', plotfp );
    } else {
	fprintf(plotfp, "t %s\n", s);
    }
}

void
pl_space(register FILE *plotfp, int x1, int y1, int x2, int y2)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 's', plotfp );
	putsi( x1 );
	putsi( y1 );
	putsi( x2 );
	putsi( y2 );
    } else {
	fprintf(plotfp, "s %d %d %d %d\n", x1, y1, x2, y2);
    }
}

void
pl_erase(register FILE *plotfp)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY)
	putc( 'e', plotfp );
    else
	fprintf(plotfp, "e\n");
}

void
pl_circle(register FILE *plotfp, int x, int y, int r)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'c', plotfp );
	putsi( x );
	putsi( y );
	putsi( r );
    } else {
	fprintf(plotfp, "c %d %d %d\n", x, y, r);
    }
}

void
pl_arc(register FILE *plotfp, int xc, int yc, int x1, int y1, int x2, int y2)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'a', plotfp );
	putsi( xc );
	putsi( yc );
	putsi( x1 );
	putsi( y1 );
	putsi( x2 );
	putsi( y2 );
    } else {
	fprintf(plotfp, "a %d %d %d %d %d %d\n", xc, yc, x1, y1, x2, y2);
    }
}

void
pl_box(register FILE *plotfp, int x1, int y1, int x2, int y2)
{
	pl_move( plotfp, x1, y1 );
	pl_cont( plotfp, x1, y2 );
	pl_cont( plotfp, x2, y2 );
	pl_cont( plotfp, x2, y1 );
	pl_cont( plotfp, x1, y1 );
	pl_move( plotfp, x2, y2 );
}

/*
 * Here lie the BRL 3-D extensions.
 */

/* Warning: r, g, b are ints.  The output is chars. */
void
pl_color(register FILE *plotfp, int r, int g, int b)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'C', plotfp );
	putc( r, plotfp );
	putc( g, plotfp );
	putc( b, plotfp );
    } else {
	fprintf(plotfp, "C %d %d %d\n", r, g, b);
    }
}

void
pl_flush(register FILE *plotfp)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'F', plotfp );
    } else {
	fprintf(plotfp, "F\n");
    }

    fflush( plotfp );
}

void
pl_3space(register FILE *plotfp, int x1, int y1, int z1, int x2, int y2, int z2)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'S', plotfp );
	putsi( x1 );
	putsi( y1 );
	putsi( z1 );
	putsi( x2 );
	putsi( y2 );
	putsi( z2 );
    } else {
	fprintf(plotfp, "S %d %d %d %d %d %d\n", x1, y1, z1, x2, y2, z2);
    }
}

void
pl_3point(register FILE *plotfp, int x, int y, int z)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'P', plotfp );
	putsi( x );
	putsi( y );
	putsi( z );
    } else {
	fprintf(plotfp, "P %d %d %d\n", x, y, z);
    }
}

void
pl_3move(register FILE *plotfp, int x, int y, int z)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'M', plotfp );
	putsi( x );
	putsi( y );
	putsi( z );
    } else {
	fprintf(plotfp, "M %d %d %d\n", x, y, z);
    }
}

void
pl_3cont(register FILE *plotfp, int x, int y, int z)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'N', plotfp );
	putsi( x );
	putsi( y );
	putsi( z );
    } else {
	fprintf(plotfp, "N %d %d %d\n", x, y, z);
    }
}

void
pl_3line(register FILE *plotfp, int x1, int y1, int z1, int x2, int y2, int z2)
{
    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	putc( 'L', plotfp );
	putsi( x1 );
	putsi( y1 );
	putsi( z1 );
	putsi( x2 );
	putsi( y2 );
	putsi( z2 );
    } else {
	fprintf(plotfp, "L %d %d %d %d %d %d\n", x1, y1, z1, x2, y2, z2);
    }
}

void
pl_3box(register FILE *plotfp, int x1, int y1, int z1, int x2, int y2, int z2)
{
	pl_3move( plotfp, x1, y1, z1 );
	/* first side */
	pl_3cont( plotfp, x1, y2, z1 );
	pl_3cont( plotfp, x1, y2, z2 );
	pl_3cont( plotfp, x1, y1, z2 );
	pl_3cont( plotfp, x1, y1, z1 );
	/* across */
	pl_3cont( plotfp, x2, y1, z1 );
	/* second side */
	pl_3cont( plotfp, x2, y2, z1 );
	pl_3cont( plotfp, x2, y2, z2 );
	pl_3cont( plotfp, x2, y1, z2 );
	pl_3cont( plotfp, x2, y1, z1 );
	/* front edge */
	pl_3move( plotfp, x1, y2, z1 );
	pl_3cont( plotfp, x2, y2, z1 );
	/* bottom back */
	pl_3move( plotfp, x1, y1, z2 );
	pl_3cont( plotfp, x2, y1, z2 );
	/* top back */
	pl_3move( plotfp, x1, y2, z2 );
	pl_3cont( plotfp, x2, y2, z2 );
}

/*
 * Double floating point versions
 */

void
pd_point(register FILE *plotfp, double x, double y)
{
    double	in[2];
    unsigned char	out[2*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x;
	in[1] = y;
	htond( &out[1], (unsigned char *)in, 2 );

	out[0] = 'x';
	fwrite( out, 1, 2*8+1, plotfp );
    } else {
	fprintf(plotfp, "x %g %g\n", x, y);
    }
}

void
pd_line(register FILE *plotfp, double x1, double y1, double x2, double y2)
{
    double	in[4];
    unsigned char	out[4*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x1;
	in[1] = y1;
	in[2] = x2;
	in[3] = y2;
	htond( &out[1], (unsigned char *)in, 4 );

	out[0] = 'v';
	fwrite( out, 1, 4*8+1, plotfp );
    } else {
	fprintf(plotfp, "v %g %g %g %g\n", x1, y1, x2, y2);
    }
}

/* Note: no pd_linmod(), just use pl_linmod() */

void
pd_move(register FILE *plotfp, double x, double y)
{
    double	in[2];
    unsigned char	out[2*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x;
	in[1] = y;
	htond( &out[1], (unsigned char *)in, 2 );

	out[0] = 'o';
	fwrite( out, 1, 2*8+1, plotfp );
    } else {
	fprintf(plotfp, "o %g %g\n", x, y);
    }
}

void
pd_cont(register FILE *plotfp, double x, double y)
{
    double	in[2];
    unsigned char	out[2*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x;
	in[1] = y;
	htond( &out[1], (unsigned char *)in, 2 );

	out[0] = 'q';
	fwrite( out, 1, 2*8+1, plotfp );
    } else {
	fprintf(plotfp, "q %g %g\n", x, y);
    }
}

void
pd_space(register FILE *plotfp, double x1, double y1, double x2, double y2)
{
    double	in[4];
    unsigned char	out[4*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x1;
	in[1] = y1;
	in[2] = x2;
	in[3] = y2;
	htond( &out[1], (unsigned char *)in, 4 );

	out[0] = 'w';
	fwrite( out, 1, 4*8+1, plotfp );
    } else {
	fprintf(plotfp, "w %g %g %g %g\n", x1, y1, x2, y2);
    }
}

void
pd_circle(register FILE *plotfp, double x, double y, double r)
{
    double	in[3];
    unsigned char	out[3*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x;
	in[1] = y;
	in[2] = r;
	htond( &out[1], (unsigned char *)in, 3 );

	out[0] = 'i';
	fwrite( out, 1, 3*8+1, plotfp );
    } else {
	fprintf(plotfp, "i %g %g %g\n", x, y, r);
    }
}

void
pd_arc(register FILE *plotfp, double xc, double yc, double x1, double y1, double x2, double y2)
{
    double	in[6];
    unsigned char	out[6*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = xc;
	in[1] = yc;
	in[2] = x1;
	in[3] = y1;
	in[4] = x2;
	in[5] = y2;
	htond( &out[1], (unsigned char *)in, 6 );

	out[0] = 'r';
	fwrite( out, 1, 6*8+1, plotfp );
    } else {
	fprintf(plotfp, "r %g %g %g %g %g %g\n", xc, yc, x1, y1, x2, y2);
    }
}

void
pd_box(register FILE *plotfp, double x1, double y1, double x2, double y2)
{
	pd_move( plotfp, x1, y1 );
	pd_cont( plotfp, x1, y2 );
	pd_cont( plotfp, x2, y2 );
	pd_cont( plotfp, x2, y1 );
	pd_cont( plotfp, x1, y1 );
	pd_move( plotfp, x2, y2 );
}

/* Double 3-D, both in vector and enumerated versions */
void
pdv_3space(register FILE *plotfp, const fastf_t *min, const fastf_t *max)
{
    unsigned char	out[6*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	htond( &out[1], (unsigned char *)min, 3 );
	htond( &out[3*8+1], (unsigned char *)max, 3 );

	out[0] = 'W';
	fwrite( out, 1, 6*8+1, plotfp );
    } else {
	fprintf(plotfp, "W %g %g %g %g %g %g\n", V3ARGS(min), V3ARGS(max));
    }
}

void
pd_3space(register FILE *plotfp, double x1, double y1, double z1, double x2, double y2, double z2)
{
    double	in[6];
    unsigned char	out[6*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x1;
	in[1] = y1;
	in[2] = z1;
	in[3] = x2;
	in[4] = y2;
	in[5] = z2;
	htond( &out[1], (unsigned char *)in, 6 );

	out[0] = 'W';
	fwrite( out, 1, 6*8+1, plotfp );
    } else {
	fprintf(plotfp, "W %g %g %g %g %g %g\n", x1, y1, z1, x2, y2, z2);
    }
}

void
pdv_3point(register FILE *plotfp, const fastf_t *pt)
{
    unsigned char	out[3*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	htond( &out[1], (unsigned char *)pt, 3 );

	out[0] = 'X';
	fwrite( out, 1, 3*8+1, plotfp );
    } else {
	fprintf(plotfp, "X %g %g %g\n", V3ARGS(pt));
    }
}

void
pd_3point(register FILE *plotfp, double x, double y, double z)
{
    double	in[3];
    unsigned char	out[3*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x;
	in[1] = y;
	in[2] = z;
	htond( &out[1], (unsigned char *)in, 3 );

	out[0] = 'X';
	fwrite( out, 1, 3*8+1, plotfp );
    } else {
	fprintf(plotfp, "X %g %g %g\n", x, y, z);
    }
}

void
pdv_3move(register FILE *plotfp, const fastf_t *pt)
{
    unsigned char	out[3*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	htond( &out[1], (unsigned char *)pt, 3 );

	out[0] = 'O';
	fwrite( out, 1, 3*8+1, plotfp );
    } else {
	fprintf(plotfp, "O %g %g %g\n", V3ARGS(pt));
    }
}

void
pd_3move(register FILE *plotfp, double x, double y, double z)
{
    double	in[3];
    unsigned char	out[3*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x;
	in[1] = y;
	in[2] = z;
	htond( &out[1], (unsigned char *)in, 3 );

	out[0] = 'O';
	fwrite( out, 1, 3*8+1, plotfp );
    } else {
	fprintf(plotfp, "O %g %g %g\n", x, y, z);
    }
}

void
pdv_3cont(register FILE *plotfp, const fastf_t *pt)
{
    unsigned char	out[3*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	htond( &out[1], (unsigned char *)pt, 3 );

	out[0] = 'Q';
	fwrite( out, 1, 3*8+1, plotfp );
    } else {
	fprintf(plotfp, "Q %g %g %g\n", V3ARGS(pt));
    }
}

void
pd_3cont(register FILE *plotfp, double x, double y, double z)
{
    double	in[3];
    unsigned char	out[3*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x;
	in[1] = y;
	in[2] = z;
	htond( &out[1], (unsigned char *)in, 3 );

	out[0] = 'Q';
	fwrite( out, 1, 3*8+1, plotfp );
    } else {
	fprintf(plotfp, "Q %g %g %g\n", x, y, z);
    }
}

void
pdv_3line(register FILE *plotfp, const fastf_t *a, const fastf_t *b)
{
    unsigned char	out[6*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	htond( &out[1], (unsigned char *)a, 3 );
	htond( &out[3*8+1], (unsigned char *)b, 3 );

	out[0] = 'V';
	fwrite( out, 1, 6*8+1, plotfp );
    } else {
	fprintf(plotfp, "V %g %g %g %g %g %g\n", V3ARGS(a), V3ARGS(b));
    }
}

void
pd_3line(register FILE *plotfp, double x1, double y1, double z1, double x2, double y2, double z2)
{
    double	in[6];
    unsigned char	out[6*8+1];

    if (pl_outputMode == PL_OUTPUT_MODE_BINARY) {
	in[0] = x1;
	in[1] = y1;
	in[2] = z1;
	in[3] = x2;
	in[4] = y2;
	in[5] = z2;
	htond( &out[1], (unsigned char *)in, 6 );

	out[0] = 'V';
	fwrite( out, 1, 6*8+1, plotfp );
    } else {
	fprintf(plotfp, "V %g %g %g %g %g %g\n", x1, y1, z1, x2, y2, z2);
    }
}

void
pdv_3box(register FILE *plotfp, const fastf_t *a, const fastf_t *b)
{
	pd_3move( plotfp, a[X], a[Y], a[Z] );
	/* first side */
	pd_3cont( plotfp, a[X], b[Y], a[Z] );
	pd_3cont( plotfp, a[X], b[Y], b[Z] );
	pd_3cont( plotfp, a[X], a[Y], b[Z] );
	pd_3cont( plotfp, a[X], a[Y], a[Z] );
	/* across */
	pd_3cont( plotfp, b[X], a[Y], a[Z] );
	/* second side */
	pd_3cont( plotfp, b[X], b[Y], a[Z] );
	pd_3cont( plotfp, b[X], b[Y], b[Z] );
	pd_3cont( plotfp, b[X], a[Y], b[Z] );
	pd_3cont( plotfp, b[X], a[Y], a[Z] );
	/* front edge */
	pd_3move( plotfp, a[X], b[Y], a[Z] );
	pd_3cont( plotfp, b[X], b[Y], a[Z] );
	/* bottom back */
	pd_3move( plotfp, a[X], a[Y], b[Z] );
	pd_3cont( plotfp, b[X], a[Y], b[Z] );
	/* top back */
	pd_3move( plotfp, a[X], b[Y], b[Z] );
	pd_3cont( plotfp, b[X], b[Y], b[Z] );
}

void
pd_3box(register FILE *plotfp, double x1, double y1, double z1, double x2, double y2, double z2)
{
	pd_3move( plotfp, x1, y1, z1 );
	/* first side */
	pd_3cont( plotfp, x1, y2, z1 );
	pd_3cont( plotfp, x1, y2, z2 );
	pd_3cont( plotfp, x1, y1, z2 );
	pd_3cont( plotfp, x1, y1, z1 );
	/* across */
	pd_3cont( plotfp, x2, y1, z1 );
	/* second side */
	pd_3cont( plotfp, x2, y2, z1 );
	pd_3cont( plotfp, x2, y2, z2 );
	pd_3cont( plotfp, x2, y1, z2 );
	pd_3cont( plotfp, x2, y1, z1 );
	/* front edge */
	pd_3move( plotfp, x1, y2, z1 );
	pd_3cont( plotfp, x2, y2, z1 );
	/* bottom back */
	pd_3move( plotfp, x1, y1, z2 );
	pd_3cont( plotfp, x2, y1, z2 );
	/* top back */
	pd_3move( plotfp, x1, y2, z2 );
	pd_3cont( plotfp, x2, y2, z2 );
}

/**
 *  Draw a ray
 */
void
pdv_3ray(FILE *fp, const fastf_t *pt, const fastf_t *dir, double t)
{
	point_t	tip;

	VJOIN1( tip, pt, t, dir );
	pdv_3move( fp, pt );
	pdv_3cont( fp, tip );
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a41 6
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.14 2007/01/23 01:13:33 brlcad Exp $ (BRL)";
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.13 2007/01/21 04:45:41 brlcad Exp $ (BRL)";
a57 1

@


14.13
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.12 2007/01/20 14:36:51 brlcad Exp $ (BRL)";
@


14.12
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup plot */
/*@@{*/
d24 1
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.11 2006/09/04 04:42:40 lbutler Exp $ (BRL)";
d757 1
a757 1
/*@@}*/
@


14.11
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.10 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
@


14.10
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup libbn */
d25 1
d50 1
a50 1
/*@@}*/
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.9 2005/10/23 04:44:31 brlcad Exp $ (BRL)";
d88 4
d744 1
a744 1
/*
d757 1
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.8 2005/08/15 21:18:14 bob1961 Exp $ (BRL)";
@


14.8
log
@Add code to set/get the plot's output mode (i.e. binary or text)
@
text
@d42 1
a42 1
 *  
d47 1
a47 1
 *  
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.7 2005/08/12 22:28:35 lbutler Exp $ (BRL)";
@


14.8.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d42 1
a42 1
 *
d47 1
a47 1
 *
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


14.7
log
@Doxygen changes
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.6 2005/01/30 20:30:44 brlcad Exp $ (BRL)";
d65 3
d77 10
d90 1
d94 3
d102 1
d108 3
d116 1
d121 3
d129 1
d133 3
d141 1
d145 3
d153 1
d158 3
d166 1
d172 3
d180 1
d182 2
d189 1
d194 3
d202 1
d210 3
d234 1
d239 3
d247 1
d249 5
a253 1
	fflush( plotfp );
d259 1
d267 3
d275 1
d280 3
d288 1
d293 3
d301 1
d306 3
d314 1
d322 3
d361 2
a362 2
	double	in[2];
	unsigned char	out[2*8+1];
d364 1
d371 3
d379 2
a380 2
	double	in[4];
	unsigned char	out[4*8+1];
d382 1
d391 3
d401 2
a402 2
	double	in[2];
	unsigned char	out[2*8+1];
d404 1
d411 3
d419 2
a420 2
	double	in[2];
	unsigned char	out[2*8+1];
d422 1
d429 3
d437 2
a438 2
	double	in[4];
	unsigned char	out[4*8+1];
d440 1
d449 3
d457 2
a458 2
	double	in[3];
	unsigned char	out[3*8+1];
d460 1
d468 3
d476 2
a477 2
	double	in[6];
	unsigned char	out[6*8+1];
d479 1
d490 3
d510 1
a510 1
	unsigned char	out[6*8+1];
d512 1
d518 3
d526 2
a527 2
	double	in[6];
	unsigned char	out[6*8+1];
d529 1
d540 3
d548 1
a548 1
	unsigned char	out[3*8+1];
d550 1
d555 3
d563 2
a564 2
	double	in[3];
	unsigned char	out[3*8+1];
d566 1
d574 3
d582 1
a582 1
	unsigned char	out[3*8+1];
d584 1
d589 3
d597 2
a598 2
	double	in[3];
	unsigned char	out[3*8+1];
d600 1
d608 3
d616 1
a616 1
	unsigned char	out[3*8+1];
d618 1
d623 3
d631 2
a632 2
	double	in[3];
	unsigned char	out[3*8+1];
d634 1
d642 3
d650 1
a650 1
	unsigned char	out[6*8+1];
d652 1
d658 3
d666 2
a667 2
	double	in[6];
	unsigned char	out[6*8+1];
d669 1
d680 3
@


14.6
log
@update copyright to 2005
@
text
@d21 3
a24 1
 *
d32 4
a35 5
 *  (1) These all take a stdio file pointer, and can thus be used to
 *      create multiple plot files simultaneously.
 *  (2) There are 3-D versions of most commands.
 *  (3) There are IEEE floating point versions of the commands.
 *  (4) The names have been changed.
d49 2
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbn/plot3.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (BRL)";
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/plot3.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a46 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/plot3.c,v 14.3 2004/12/21 05:45:20 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/plot3.c,v 14.2 2004/12/21 01:52:15 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/plot3.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			L I B P L O T 3 . C
d51 1
a51 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/plot3.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbn/plot3.c,v 1.2 2004/06/08 19:24:02 morrison Exp $ (BRL)";
d582 10
@


1.2
log
@bye bye externs.h
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d35 1
a35 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d32 1
a32 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbn/plot3.c,v 11.10 2004/05/10 15:30:43 erikg Exp $ (BRL)";
a44 1
#include "externs.h"
@

