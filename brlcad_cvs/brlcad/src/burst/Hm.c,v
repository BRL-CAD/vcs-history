head	14.14;
access;
symbols
	rel-7-10-4:14.13
	STABLE:14.13.0.2
	stable-branch:14.4
	rel-7-10-2:14.13
	rel-7-10-0:14.12
	rel-7-8-4:14.9
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.14
date	2007.12.31.17.35.36;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.07.26.01.13.50;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.27.01.41.31;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.24;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.36.42;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.12;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.11.04.14.50.56;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.11.04.10.43.04;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.31.06.28.43;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.30.15;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.18.06.50.49;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.01.52.36;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.42;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.14
log
@remove the __STDC__ protections, c89 is a given
@
text
@/*                            H M . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file Hm.c
 *	Author:	Gary S. Moss
 *
 * This code is derived in part from menuhit(9.3) in AT&T 9th Edition UNIX,
 *	Version 1 Programmer's Manual.
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.13 2007/07/26 01:13:50 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <signal.h>
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "./Sc.h"
#include "./Hm.h"
#include "./Mm.h"
#include "./extern.h"


#define ErLog	brst_log

#define HmDEBUG		0

#ifndef Max
#  define Max(_a,_b)	((_a)<(_b)?(_b):(_a))
#  define Min(_a,_b)	((_a)>(_b)?(_b):(_a))
#endif

#define HmRingbell()	(void) putchar( '\07' ),  (void) fflush( stdout )

/* Keys for manipulating menus. */
#define Ctrl(c_)	((c_)&037)
#define M_DEBUG		Ctrl('?')
#define M_DOWN		'd'
#define M_HELP		'h'
#define M_MYXMOUSE	Ctrl('X')
#define M_NOSELECT	'q'
#define M_REDRAW	Ctrl('L')
#define M_SELECT	' '
#define M_UP		'u'


/* Alternate keys for conformance to standard conventions. */
#define A_UP		Ctrl('P')
#define A_DOWN		Ctrl('N')
#define A_HELP		'?'

#define P_OFF		(0)
#define P_ON		(1)
#define P_FORCE		(1<<1)

#define  PutMenuChar(_c,_co,_ro,_map,_bit)\
		{	static int	lro = -1, lco = -1;\
		if( (_map) & (_bit) || (_bit) == 0 )\
			{\
			if( lco++ != (_co)-1 || lro != (_ro) )\
				{\
				(void) ScMvCursor( _co, _ro );\
				lco = _co;\
				}\
			(void) putchar( (_c) );\
			}\
		(_bit) <<= 1;\
		(_co)++;\
		}\

static boolean	HmDirty = 0;
static boolean	HmMyxflag = 0;
static boolean	HmPkgInit = 0;

static HmWindow	*windows = NULL;

#define HmENTRY		(itemp-win->menup->item)
#define HmHEIGHT	Min(win->height,HmMaxVis)
typedef struct nmllist HmLList;
struct nmllist
	{
	HmItem	*itemp;
	HmLList	*next;
	};

/*
	void    HmBanner( char *pgmname, int borderchr )

	Print program name and row of border characters to delimit the top
		of the scrolling region.
 */
void
HmBanner( char *pgmname, int borderchr )
{
    register int    co;
    register char   *p;
#define HmBUFLEN	81
		static char     HmPgmName[HmBUFLEN] = "No name";
		static int      HmBorderChr = '_';
	if( pgmname != NULL )
		{
		(void) strncpy( HmPgmName, pgmname, HmBUFLEN );
		HmBorderChr = borderchr;
		}
	(void) ScMvCursor( HmLftMenu, HmYBORDER );
	for( co = 1; co <= 3; co++ )
		(void) putc( HmBorderChr, stdout );
	for( p = HmPgmName; co <= ScCO && *p != '\0'; co++, p++ )
		(void) putc( (int)(*p), stdout );
	for( ; co <= ScCO; co++ )
		(void) putc( HmBorderChr, stdout );
	return;
	}

/*
	void	HmPrntItem( HmItem *itemp )	(DEBUG)

	Print contents of itemp.
 */
static void
HmPrntItem( HmItem *itemp )
{
	(void) ErLog( "\t\tHmPrntItem(0x%x)\n", itemp );
	for( ; itemp->text != (char *) NULL; itemp++ )
		{
		(void) ErLog( "\t\t\ttext=\"%s\"\n", itemp->text );
		(void) ErLog( "\t\t\thelp=\"%s\"\n", itemp->help == (char *) NULL ? "(null)" : itemp->help );
		(void) ErLog( "\t\t\tnext=0x%x\n", itemp->next );
		(void) ErLog( "\t\t\tdfn=0x%x\n", itemp->dfn );
		(void) ErLog( "\t\t\tbfn=0x%x\n", itemp->bfn );
		(void) ErLog( "\t\t\thfn=0x%x\n", itemp->hfn );
		(void) ErLog( "\t\t\tdata=%d\n", itemp->data );
		(void) ErLog( "\t\t\t----\n" );
		}
	(void) ErLog( "\t\t\ttext=0x%x\n", itemp->text );
	return;
	}

/*
	void	HmPrntMenu( menup )	(DEBUG)

	Print "windows" stack.
 */
static void
HmPrntMenu( HmMenu *menup )
{
	(void) ErLog( "\tHmPrntMenu( 0x%x )\n", menup );
	(void) ErLog( "\t\tgenerator=0x%x\n", menup->generator );
	(void) ErLog( "\t\tprevtop=%d\n", menup->prevtop );
	(void) ErLog( "\t\tprevhit=%d\n", menup->prevhit );
	(void) ErLog( "\t\tsticky=%s\n", menup->sticky ? "true" : "false" );
	HmPrntItem( menup->item );
	return;
	}

/*
	void	HmPrntWindows( void )	(DEBUG)

	Print "windows" stack.
 */
static void
HmPrntWindows( void )
{
    register HmWindow	*win;
	(void) ErLog( "HmPrntWindows()\n" );
	for( win = windows; win != (HmWindow *) NULL; win = win->next )
		{
		(void) ErLog( "\twin=0x%x\n", win );
		(void) ErLog( "\tmenup=0x%x\n", win->menup );
		(void) ErLog( "\tmenux=%d\n", win->menux );
		(void) ErLog( "\tmenuy=%d\n", win->menuy );
		(void) ErLog( "\twidth=%d\n", win->width );
		(void) ErLog( "\theight=%d\n", win->height );
		(void) ErLog( "\tdirty=0x%x\n", win->dirty );
		(void) ErLog( "\tnext=0x%x\n", win->next );
		HmPrntMenu( win->menup );
		}
	return;
	}

/*
	void	HmPrntLList( HmLList *listp )	(DEBUG)

	Print all HmItem's in listp.
 */
static void
HmPrntLList( HmLList *listp )
{
	if( listp == (HmLList *) NULL )
		return;
	HmPrntItem( listp->itemp );
	HmPrntLList( listp->next );
	return;
	}

/*
	void	HmFreeItems( Hmitem *itemp )

	Free storage (allocated with malloc) for an array of HmItem's.
 */
static void
HmFreeItems( HmItem *itemp )
{
    register HmItem	*citemp;
    register int	count;
	for(	citemp = itemp, count = 1;
		citemp->text != (char *) NULL;
		citemp++, count++
		)
		{
		MmStrFree( citemp->text );
		if( citemp->help != (char *) NULL )
			MmStrFree( citemp->help );
		}
	MmVFree( count, HmItem, itemp );
	return;
	}

/*
	void	HmFreeLList( HmLList *listp )

	Free storage (allocated with malloc) for a linked-list of
	HmItem's.
 */
static void
HmFreeLList( HmLList *listp )
{
    register HmLList	*tp;
    for( ; listp != (HmLList *) NULL; listp = tp )
		{
		MmFree( HmItem, listp->itemp );
		tp = listp->next;
		MmFree( HmLList, listp );
		}
	return;
	}

/*
	void	HmPutItem( register HmWindow *win, register HmItem *itemp, int flag )

	Display menu entry itemp.

	Win is the menu control structure for itemp.

	Flag is a bit flag and the following bits are meaningful:

		P_FORCE means draw the entire entry regardless of the
			value of the dirty bitmap.
		P_ON	means this entry is current so highlight it.
 */
static void
HmPutItem( register HmWindow *win, register HmItem *itemp, int flag )
{
    register int	label_len = strlen( itemp->text );
    static char	buf[HmMAXLINE];
		register char	*p = buf;
		register int	col = win->menux;
		register int	row = win->menuy+
					(HmENTRY-win->menup->prevtop)+1;
		register int	width = win->width;
		register int	bitmap = flag & P_FORCE ?
					~0 : win->dirty[row-win->menuy];
				/*	~0 : win->dirty[HmENTRY+1];*/
		register int	bit = 1;
		register int	writemask = 0;
	if( bitmap == 0 )
		return;
	if( itemp->text[0] & 0200 )	/* right-justified */
		{	register int	i;
		label_len--;
		for( i = 0; i < width - label_len; i++ )
			*p++ = itemp->text[0] & 0177;
		for( i = 1; itemp->text[i] != '\0'; i++ )
			*p++ = itemp->text[i];
		}
	else				/* left-justified */
	if( itemp->text[label_len-1] & 0200 )
		{	register int	i;
		label_len--;
		for( i = 0; !(itemp->text[i] & 0200); i++ )
			*p++ = itemp->text[i];
		for( ; i < width; i++ )
			*p++ = itemp->text[label_len] & 0177;
		}
	else				/* centered */
		{	register int	i, j;
		for( i = 0; i < (width - label_len)/2; i++ )
			*p++ = ' ';
		for( j = 0; itemp->text[j] != '\0'; j++ )
			*p++ = itemp->text[j];
		for( i += j; i < width; i++ )
			*p++ = ' ';
		}
	*p = '\0';

	PutMenuChar( '|', col, row, bitmap, bit );
	if( flag & P_ON )
		(void) ScSetStandout();
	else
		(void) ScClrStandout();

	/* Optimized printing of entry.				*/
	{
	if( bitmap == ~0 )
		{
		(void) fputs( buf, stdout );
		col += p-buf;
		bit <<= p-buf;
		}
	else
		{	register int	i;
		for( i = 0; i < p-buf; i++ )
			writemask |= 1<<(i+1);
		for( i = 0; i < p-buf; i++ )
			{
			if( (bitmap & writemask) == writemask )
				break;
			writemask &= ~bit;
			PutMenuChar( buf[i], col, row, bitmap, bit );
			}
		if( i < p-buf )
			{
			(void) ScMvCursor( col, row );
			(void) fputs( &buf[i], stdout );
			col += (p-buf) - i;
			bit <<= (p-buf) - i;
			}
		}
	}

	if( flag & P_ON )
		(void) ScClrStandout();
	PutMenuChar( '|', col, row, bitmap, bit );
	return;
	}

/*
	void	HmPutBorder( register HmWindow *win, register row, char mark )

	Draw the horizontal border for row of win->menup using mark
	for the corner characters.
 */
static void
HmPutBorder( register HmWindow *win, register int row, char mark )
{
    register int	i;
    register int	bit = 1;
		register int	col = win->menux;
		register int	bitmap = win->dirty[row - win->menuy];
		static char	buf[HmMAXLINE];
		register char	*p = buf;
	if( bitmap == 0 )
		return; /* No dirty bits. */
	*p++ = mark;
	for( i = 0; i < win->width; i++ )
		*p++ = '-';
	*p++ = mark;
	*p = '\0';
	if( bitmap == ~0 )
		{	/* All bits dirty. */
		(void) ScMvCursor( col, row );
		(void) fputs( buf, stdout );
		}
	else
		{
		for( i = 0; i < p - buf; i++ )
			PutMenuChar( buf[i], col, row, bitmap, bit );
		}
	return;
	}

/*
	void	HmSetbit( register HmWindow *win, int col, int row )

	Mark as dirty, the bit in win->dirty that corresponds to
	col and row of the screen.
*/
static void
HmSetbit( register HmWindow *win, int col, int row )
{
    register int	bit = col - win->menux;
#if HmDEBUG && 0
	(void) ErLog(	"HmSetbit:menu{<%d,%d>,<%d,%d>}col=%d,row=%d\n",
			win->menux, win->menux+win->width+1,
			win->menuy, win->menuy+HmHEIGHT+1,
			col, row
			);
#endif
	win->dirty[row-win->menuy] |= bit == 0 ? 1 : 1 << bit;
#if HmDEBUG && 0
	(void) ErLog( 	"\tdirty[%d]=0x%x\r\n",
			row-win->menuy, win->dirty[row-win->menuy]
			);
#endif
	return;
	}

/*
	void	HmClrmap( HmWindow *win )

	Mark as clean, the entire dirty bitmap for win.
 */
static void
HmClrmap( HmWindow *win )
{
    register int	row;
    register int	height = HmHEIGHT;
	for( row = 0; row <= height+1; row++ )
		win->dirty[row] = 0;
	return;
	}

/*
	void	HmSetmap( HmWindow *win )

	Mark as dirty the entire dirty bitmap for win.
 */
static void
HmSetmap( HmWindow *win )
{
    register int	row;
    register int	height = HmHEIGHT;
	for( row = 0; row <= height+1; row++ )
		win->dirty[row] = ~0; /* 0xffff... */
	return;
	}

/*
	HmWindow *HmInWin( register  x, register y, register HmWindow *win )

	Return pointer to top window in stack, starting with win whose
	boundaries contain the screen coordinate <x,y>.  If the point
	is outside of all these windows, return 0.
 */
static HmWindow	*
HmInWin( register int x, register int y, register HmWindow *win )
{
#if HmDEBUG && 0
	if( win != (HmWindow *) NULL )
		(void) ErLog(	"HmInWin:x=%d y=%d win{<%d,%d>,<%d,%d>}\r\n",
				x, y,
				win->menux, win->menux+win->width+1,
				win->menuy, win->menuy+HmHEIGHT+1
				);
#endif
	for( ; win != (HmWindow *) NULL; win = win->next )
		{	register int	height = HmHEIGHT;
		if( !	(x < win->menux || x > win->menux + win->width + 1 ||
			 y < win->menuy || y > win->menuy + height + 1)
			)
			return	win;
		}
	return	(HmWindow *) NULL;
	}

/*
	void	HmDrawWin( register HmWindow *win )

	Draw win->menup on screen.  Actually, only characters flagged as
	dirty are drawn.
 */
static void
HmDrawWin( register HmWindow *win )
{
    register HmItem	*itemp;
    int	height;

#if HmDEBUG && 1
	(void) ErLog(	"HmDrawWin:win{<%d,%d>,<%d,%d>}\r\n",
			win->menux, win->menux+win->width+1,
			win->menuy, win->menuy+HmHEIGHT+1
			);
	{	register int	i;
	for( i = 0; i <= HmHEIGHT+1; i++ )
		(void) ErLog( "\tdirty[%d]=0x%x\r\n", i, win->dirty[i] );
	}
#endif
	HmPutBorder( win, win->menuy, win->menup->prevtop > 0 ? '^' : '+' );
	for(	itemp = win->menup->item + win->menup->prevtop;
		HmENTRY-win->menup->prevtop < HmMaxVis && itemp->text != (char *) NULL;
		itemp++
		)
		HmPutItem(	win, itemp,
				HmENTRY == win->menup->prevhit ? P_ON : P_OFF
				);
	height = HmHEIGHT;
	HmPutBorder( win, win->menuy+height+1, HmENTRY < win->height ? 'v' : '+' );
	HmClrmap( win );
	(void) fflush( stdout );
	return;
	}

/*
	void	HmHelp( register HmWindow *win, int entry )

	Display help message for item indexed by entry in win->menup
	on line HmYCOMMO.  This message will be erased when the user
	strikes a key (or uses the mouse).
 */
static void
HmHelp( register HmWindow *win, int entry )
{
	(void) ScMvCursor( HmLftMenu, HmYCOMMO );
	(void) ScClrEOL();
	(void) ScSetStandout();
	(void) printf( "%s", win->menup->item[entry].help );
	(void) ScClrStandout();
	(void) fflush( stdout );
	return;
	}

/*
	void	HmError( char *str )

	Display str on line HmYCOMMO.
 */
void
HmError( char *str )
{
	(void) ScMvCursor( HmLftMenu, HmYCOMMO );
	(void) ScClrEOL();
	(void) ScSetStandout();
	(void) fputs( str, stdout );
	(void) ScClrStandout();
	(void) fflush( stdout );
	return;
	}

/*
	void	HmLiftWin( register HmWindow *win )

	Remove win->menup from screen, marking any occluded portions
	of other menus as dirty so that they will be redrawn by HmHit().
 */
static void
HmLiftWin( register HmWindow *win )
{
    register int	row, col;
    register int	lastcol = -1, lastrow = -1;
		register int	endcol = win->menux + win->width + 2;
		register int	endrow = win->menuy +
				  HmHEIGHT + HmHGTBORDER;
#if HmDEBUG && 1
	(void) ErLog( "HmLiftWin:win{<%d,%d>,<%d,%d>}\r\n",
			win->menux, win->menux+win->width+1,
			win->menuy, win->menuy+HmHEIGHT+1
			);
#endif
	for( row = win->menuy; row < endrow; row++ )
		{
		for( col = win->menux; col < endcol; col++ )
			{	register HmWindow	*olwin;
			if( (olwin = HmInWin( col, row, win->next ))
				!= (HmWindow *) NULL
				)
				{
				HmSetbit( olwin, col, row );
				HmDirty = 1;
				}
			else
				{
				if( lastcol != col-1 || lastrow != row )
					(void) ScMvCursor( col, row );
				lastcol = col; lastrow = row;
				(void) putchar( ' ' );
				}
			}
		}
	(void) fflush( stdout );
	return;
	}

/*
	void	HmPushWin( HmWindow *win )

	Add window to top of "windows" stack.
*/
static void
HmPushWin( HmWindow *win )
{
	win->next = windows;
	windows = win;
	return;
	}

/*
	void	HmPopWin( HmWindow *win )

	Delete window from top of "windows" stack.
*/
static void
HmPopWin( HmWindow *win )
{
	windows = win->next;
	return;
	}

/*
	void	HmRefreshWin( HmWindow *win )

	Draw any dirty portions of all windows in stack starting at win.
*/
static void
HmRefreshWin( HmWindow *win )
{
	if( win == (HmWindow *) NULL )
		{
		HmDirty = 0;
		return;
		}
	HmRefreshWin( win->next );
	HmDrawWin( win );
	return;
	}
/*
	void	HmRedraw( void )

	Force a redraw of all active menus.
 */
void
HmRedraw( void )
{
    register HmWindow	*win;
    register int		reset = 0;

#if HmDEBUG && 1
	HmPrntWindows();
#endif
	(void) ScClrText();	/* clear entire screen */

	/* See if we changed the maximum items displayed parameter. */
	if( HmMaxVis != HmLastMaxVis )
		reset = 1;
	for( win = windows; win != (HmWindow *) NULL; win = win->next )
		{
		if( reset ) /* Correct window to reflect new maximum. */
			{
			/* Reset scrolling state-info in each window. */
			if( win->menup->prevhit >= HmMaxVis )
				win->menup->prevtop = win->menup->prevhit -
							HmMaxVis + 1;
			else
				win->menup->prevtop = 0;
			/* Must reallocate "dirty" bit map to fit new size. */
			MmVFree( Min(win->height,HmLastMaxVis)+HmHGTBORDER,
				 int, win->dirty );
			if(	(win->dirty =
				MmVAllo( HmHEIGHT+HmHGTBORDER, int )
				) == NULL )
				{
				return;
				}
			}
		HmSetmap( win ); /* force all bits on in "dirty" bitmap */
		}
	HmLastMaxVis = HmMaxVis;
	HmRefreshWin( windows );	/* redisplay all windows */
	HmBanner( (char *) NULL, 0 );	/* redraw banner */
	return;
	}

/*
	void	HmTtySet( void )

	Set up terminal handler and MYX-menu options for menu interaction.
 */
void
HmTtySet( void )
{
	set_Cbreak( HmTtyFd );
	clr_Echo( HmTtyFd );
	clr_Tabs( HmTtyFd );
	if( HmMyxflag )
		{
		/* Send escape codes to push current toggle settings,
			and turn on "editor ptr". */
		(void) fputs( "\033[?1;2Z", stdout );
		(void) fputs( "\033[?1;00000010000Z", stdout );
		(void) fflush( stdout );
		}
	return;
	}

/*
	void	HmTtyReset( void )

	Reset terminal handler and MYX-menu options to user settings.
*/
void
HmTtyReset( void )
{
	if( HmMyxflag )
		{
		/* Send escape codes to pop old toggle settings. */
		(void) fputs( "\033[?1;3Z", stdout );
		(void) fflush( stdout );
		}
	reset_Tty( HmTtyFd );
	return;
	}

/*
	void	HmInit( int x, int y, int maxvis )

	Initialize position of top-level menu.  Specify maximum
	number of menu items visable at once.  Place these values
	in global variables.  Determine as best we can whether MYX
	is available and place boolean result in HmMyxflag.  Return
	true for success and false for failure to open "/dev/tty".
 */
boolean
HmInit( int x, int y, int maxvis )
{
	if(	(HmTtyFd = open( "/dev/tty", O_RDONLY )) == (-1)
	    ||	(HmTtyFp = fdopen( HmTtyFd, "r" )) == NULL
		)
		{
		HmError( "Can't open /dev/tty for reading." );
		return	0;
		}
	save_Tty( HmTtyFd );
	HmPkgInit = 1;
	HmLftMenu = x;
	HmTopMenu = y;
	HmMaxVis = maxvis;

	return	1;
	}

/*
	void	HmWidHgtMenu( register HmWindow *win )

	Determine width and height of win->menup, and store in win.
 */
static void
HmWidHgtMenu( register HmWindow *win )
{
    register HmItem	*itemp;
    
    /* Determine width of menu, allowing for border.		*/
    for( itemp = win->menup->item; itemp->text != (char *) NULL; itemp++ ) {
	register int	len = 0;
	register int	i;
	for( i = 0; itemp->text[i] != '\0' ; i++ ) {
	    if( ! (itemp->text[i] & 0200) )
		len++;
	}
	win->width = Max( win->width, len );
    }
    win->height = HmENTRY;
    return;
}

/*
	boolean HmFitMenu( register HmWindow *nwin, register HmWindow *cwin )

	If nwin->menup will fit below cwin->menup on screen, store
	position in nwin, and return 1.  Otherwise, return 0.
 */
static boolean
HmFitMenu( register HmWindow *nwin, register HmWindow *cwin  )
{
	if( cwin == (HmWindow *) NULL )
		return	0;
	else
	if( HmFitMenu( nwin, cwin->next ) )
		return	1;
	else
	/* Look for space underneath this menu.				*/
	if(	cwin->menux + nwin->width + 1 <= ScCO
	    &&	cwin->menuy + cwin->height + nwin->height + HmHGTBORDER
			< HmMaxVis + HmTopMenu
		)
		{
		nwin->menux = cwin->menux;
		nwin->menuy = cwin->menuy + cwin->height + HmHGTBORDER - 1;
		return	1;
		}
	else
		{
		return	0;
		}
	}

/*
	void	HmPosMenu( register HmWindow *win )

	Find best screen position for win->menup.
 */
static void
HmPosMenu( register HmWindow *win )
{
	/* Determine origin (top-left corner) of menu.			*/
	if( win->next != (HmWindow *) NULL )
		{
		win->menux = win->next->menux + win->next->width + 1;
		win->menuy = win->next->menuy;
		if( win->menux + win->width + 2 > ScCO )
			{
			if( ! HmFitMenu( win, win->next ) )
				{
				/* No space, so overlap top-level menu.	*/
				win->menux = HmLftMenu;
				win->menuy = HmTopMenu;
				}
			}
		}
	else /* Top-level menu. */
		{
		win->menux = HmLftMenu;
		win->menuy = HmTopMenu;
		}
	return;
	}

/*
	void	HmMyxMouse( register int *x, register int *y )

	Read and decode screen coordinates from MYX "editor ptr".
	Implicit return in x and y.
 */
static void
HmMyxMouse( register int *x, register int *y )
{
    register int	c;

    c = HmGetchar();
    switch( c )
		{
	case Ctrl('A') :
		*x = HmGetchar() - ' ' + 96;
		break;
	case Ctrl('B') :
		*x = HmGetchar() - ' ' + 192;
		break;
	default :
		*x = c - ' ';
		break;
		}
	c = HmGetchar();
	switch( c )
		{
	case Ctrl('A') :
		*y = HmGetchar() - ' ' + 96;
		break;
	case Ctrl('B') :
		*y = HmGetchar() - ' ' + 192;
		break;
	default :
		*y = c - ' ';
		break;
		}
	(*x)++;
	(*y)++;
	return;
	}

/*
	HmItem	*HmHit( HmMenu *menup )

	Present menup to the user and return a pointer to the selected
	item, or 0 if there was no selection made.  For more details,
	see "Hm.h".
 */
HmItem *
HmHit( HmMenu *menup )
{
    register HmItem	*itemp;
    HmItem		*retitemp = NULL;
		HmWindow	*win;
		register int	done = 0;
		int		dynamic = 0;
		static int	HmLevel = 0;

#if HmDEBUG
	ErLog( "HmHit(0x%x)\n", menup );
#endif
	if( HmPkgInit == 0 )
		{
		HmInit( HmLftMenu, HmTopMenu, HmMaxVis );
		HmPkgInit = 1;
		}
	if( ++HmLevel == 1 )
		HmTtySet();

	/* If generator function is provided, dynamically allocate the
		menu items.
	 */
	if( (dynamic = (menup->item == (HmItem *) NULL) ))
		{	register int	i;
			register HmItem	*gitemp;
			HmLList	llhead, **listp;
		for(	i = 0, listp = &llhead.next;
			;
			i++,   listp = &(*listp)->next
			)
			{
			if(	(*listp = MmAllo( HmLList )) == NULL
			     ||	((*listp)->itemp = MmAllo( HmItem )) == NULL
				)
				{
				goto	clean_exit;
				}
			itemp = (*listp)->itemp;
			if( (gitemp = (*menup->generator)( i )) == (HmItem *) NULL )
				{
				itemp->text = (char *) NULL;
				(*listp)->next = (HmLList *) NULL;
				break;
				}
			if( gitemp->text != (char *) NULL )
				{
				if( (itemp->text = MmStrDup( gitemp->text ))
					== (char *) NULL
					)
					{
					goto	clean_exit;
					}
				}
			else
				itemp->text = (char *) NULL;
			if( gitemp->help != (char *) NULL )
				{
				if( (itemp->help = MmStrDup( gitemp->help ))
					== (char *) NULL
					)
					{
					goto	clean_exit;
					}
				}
			else
				itemp->help = (char *) NULL;
			itemp->next = gitemp->next;
			itemp->dfn = gitemp->dfn;
			itemp->bfn = gitemp->bfn;
			itemp->hfn = gitemp->hfn;
			itemp->data = gitemp->data;
#if HmDEBUG && 0
			HmPrntItem( itemp );
#endif
			}
#if HmDEBUG && 0
		HmPrntLList( llhead.next );
#endif
		/* Steal the field that the user isn't using temporarily to
			emulate the static allocation of menu items.
		 */
		if( i > 0 )
			{	register int		ii;
				register HmLList	*lp;
			if( (menup->item = MmVAllo( i+1, HmItem )) == NULL )
				{
				goto	clean_exit;
				}
			for(	ii = 0, lp = llhead.next;
				lp != (HmLList *) NULL;
				ii++,   lp = lp->next
				)
				menup->item[ii] = *lp->itemp;
			}
		HmFreeLList( llhead.next );
		if( i == 0 ) /* Zero items, so return NULL */
			goto	clean_exit;
		}
	if( (win = MmAllo( HmWindow )) == NULL )
		{
#if HmDEBUG
		ErLog( "HmHit, BUG: memory pool possibly corrupted.\n" );
#endif
		goto	clean_exit;
		}
	win->menup = menup;
	win->width = 0;
	HmPushWin( win );
	HmWidHgtMenu( win );
	HmPosMenu( win );

	if( menup->prevhit < 0 || menup->prevhit >= win->height )
		menup->prevhit = 0;
	itemp = &menup->item[menup->prevhit];

	if( (win->dirty = MmVAllo( HmHEIGHT+HmHGTBORDER, int )) == NULL )
		{
		goto	clean_exit;
		}
	if( HmDirty )
		HmRefreshWin( windows );
	HmSetmap( win );
	HmDrawWin( win );
	while( ! done )
		{	int	c;
		if( HmDirty )
			HmRefreshWin( windows );
		(void) ScMvCursor( HmXPROMPT, HmYPROMPT );
		(void) ScClrEOL();
		(void) ScMvCursor(win->menux+win->width+2,
				  win->menuy+(HmENTRY-win->menup->prevtop)+1 );
		(void) fflush( stdout );
		c = HmGetchar();
		(void) ScMvCursor( HmLftMenu, HmYCOMMO );
		(void) ScClrEOL();
		switch( c )
			{
		case M_UP :
		case A_UP :
			if( HmENTRY == 0 )
				HmRingbell();
			else
				{
				HmPutItem( win, itemp, P_OFF | P_FORCE );
				itemp--;
				menup->prevhit = HmENTRY;
				if( HmENTRY < win->menup->prevtop )
					{
					win->menup->prevtop -=
						HmENTRY > HmMaxVis/2 ?
						HmMaxVis/2+1 : HmENTRY+1;
					HmSetmap( win );
					HmDrawWin( win );
					}
				else
					HmPutItem( win, itemp, P_ON | P_FORCE );
				}
			break;
		case M_DOWN :
		case A_DOWN :
			if( HmENTRY >= win->height-1 )
				HmRingbell();
			else
				{
				HmPutItem( win, itemp, P_OFF | P_FORCE );
				itemp++;
				menup->prevhit = HmENTRY;
				if( HmENTRY - win->menup->prevtop >= HmMaxVis )
					{
					win->menup->prevtop +=
						win->height-HmENTRY > HmMaxVis/2 ?
						HmMaxVis/2 : win->height-HmENTRY;
					HmSetmap( win );
					HmDrawWin( win );
					}
				else
					HmPutItem( win, itemp, P_ON | P_FORCE );
				}
			break;
		case M_MYXMOUSE :
			{	static int	mousex, mousey;
				register HmItem	*lastitemp;
			if( HmGetchar() != Ctrl('_') || HmGetchar() != '1' )
				goto	m_badinput;
			HmMyxMouse( &mousex, &mousey );
			if( HmInWin( mousex, mousey, win ) != win )
				{ /* Mouse cursor outside of menu. */
				HmRingbell();
				break;
				}
			if( mousey == win->menuy && win->menup->prevtop == 0 )
				{ /* Top border of menu and can't scroll. */
				goto	m_noselect;
				}
			if(	mousey == win->menuy + HmHEIGHT + 1
			    &&	win->height <= HmMaxVis + win->menup->prevtop
				)
				{ /* Bottom border of menu and can't scroll. */
				HmRingbell();
				break;
				}
			lastitemp = itemp;
			itemp = win->menup->item +
					win->menup->prevtop +
					(mousey - (win->menuy + 1));
			if( itemp == lastitemp )
				/* User hit item twice in a row, so select it. */
				goto	m_select;
			HmPutItem( win, lastitemp, P_OFF | P_FORCE );
			menup->prevhit = HmENTRY;
			if( HmENTRY - win->menup->prevtop >= HmMaxVis )
				{
				win->menup->prevtop +=
					win->height-HmENTRY > HmMaxVis/2 ?
					HmMaxVis/2 : win->height-HmENTRY;
				HmSetmap( win );
				HmDrawWin( win );
				}
			else
			if( HmENTRY < win->menup->prevtop )
				{
				win->menup->prevtop -=
					HmENTRY > HmMaxVis/2 ?
					HmMaxVis/2+1 : HmENTRY+1;
				HmSetmap( win );
				HmDrawWin( win );
				}
			else
				{
				HmPutItem( win, itemp, P_ON | P_FORCE );
				}
			break;
			}
		case M_HELP :
		case A_HELP :
			HmHelp( win, HmENTRY );
			break;
		m_select :
		case M_SELECT :
			if( itemp->next != (HmMenu *) NULL )
				{	HmItem	*subitemp;
				if( itemp->dfn != (void (*)()) NULL )
					{	int	level = HmLevel;
					HmTtyReset();
					HmLevel = 0;
					(*itemp->dfn)( itemp );
					HmLevel = level;
					HmTtySet();
					}
				subitemp = HmHit( itemp->next );
				if( itemp->bfn != (void (*)()) NULL )
					{	int	level = HmLevel;
					HmTtyReset();
					HmLevel = 0;
					(*itemp->bfn)( itemp );
					HmLevel = level;
					HmTtySet();
					}
				if( subitemp != (HmItem *) NULL )
					{
					retitemp = subitemp;
					done = ! menup->sticky;
					}
				}
			else
				{
				retitemp = itemp;
				if( itemp->hfn != (void (*)()) NULL )
					{	int	level = HmLevel;
					HmTtyReset();
					HmLevel = 0;
					(*itemp->hfn)( itemp );
					HmLevel = level;
					HmTtySet();
					}
				done = ! menup->sticky;
				}
			break;
		m_noselect :
		case M_NOSELECT :
			done = 1;
			break;
		case M_REDRAW :
			HmRedraw();
			break;
		case M_DEBUG :
			HmPrntWindows();
			break;
		m_badinput :
		default :
			HmError( "Type 'd' down, 'u' up, 'h' help, <space> to select, 'q' no selection." );
			break;
			}
		(void) fflush( stdout );
		}
	/* Free storage of dynamic menu.				*/
	if( dynamic )
		{
		if( retitemp != (HmItem *) NULL )
			{ /* Must make copy of item we are returning. */
				static HmItem	dynitem;
			dynitem = *retitemp;
			retitemp = &dynitem;
			}
		HmFreeItems( menup->item );
		menup->item = 0;
		}

	HmLiftWin( win );
	HmPopWin( win );
	MmVFree( HmHEIGHT+HmHGTBORDER, int, win->dirty );
	MmFree( HmWindow, win );
clean_exit :
	if( HmLevel-- == 1 )
		HmTtyReset();
	return	retitemp;
	}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.13
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.12 2007/01/27 01:41:31 brlcad Exp $ (BRL)";
d33 1
d38 3
a48 15
#if __STDC__
extern void	exit( int s );
extern unsigned alarm( unsigned s );
#else
extern void	exit();
extern unsigned alarm();
#endif

#ifndef _POSIX_SOURCE
#if __STDC__
extern FILE    *fdopen(int, const char *);
#else
extern FILE    *fdopen();
#endif
#endif
d53 2
a54 2
#define Max(_a,_b)	((_a)<(_b)?(_b):(_a))
#define Min(_a,_b)	((_a)>(_b)?(_b):(_a))
d56 1
a116 1
#if __STDC__
d118 3
a120 7
#else
HmBanner( pgmname, borderchr )
char *pgmname;
int borderchr;
#endif
	{       register int    co;
		register char   *p;
a144 1
#if __STDC__
d146 1
a146 5
#else
HmPrntItem( itemp )
register HmItem	*itemp;
#endif
	{
a168 1
#if __STDC__
d170 1
a170 5
#else
HmPrntMenu( menup )
HmMenu	*menup;
#endif
	{
a185 1
#if __STDC__
d187 2
a188 4
#else
HmPrntWindows()
#endif
	{	register HmWindow	*win;
a210 1
#if __STDC__
d212 1
a212 5
#else
HmPrntLList( listp )
HmLList	*listp;
#endif
	{
a225 1
#if __STDC__
d227 3
a229 6
#else
HmFreeItems( itemp )
HmItem	*itemp;
#endif
	{	register HmItem	*citemp;
		register int	count;
a249 1
#if __STDC__
d251 3
a253 6
#else
HmFreeLList( listp )
register HmLList	*listp;
#endif
	{	register HmLList	*tp;
	for( ; listp != (HmLList *) NULL; listp = tp )
a275 1
#if __STDC__
d277 3
a279 8
#else
HmPutItem( win, itemp, flag )
register HmWindow	*win;
register HmItem		*itemp;
int			flag;
#endif
	{	register int	label_len = strlen( itemp->text );
		static char	buf[HmMAXLINE];
a367 1
#if __STDC__
d369 3
a371 8
#else
HmPutBorder( win, row, mark )
register HmWindow	*win;
register int		row;
char			mark;
#endif
	{	register int	i;
		register int	bit = 1;
a402 1
#if __STDC__
d404 2
a405 6
#else
HmSetbit( win, col, row )
register HmWindow	*win;
int			col, row;
#endif
	{	register int	bit = col - win->menux;
a427 1
#if __STDC__
d429 3
a431 6
#else
HmClrmap( win )
HmWindow	*win;
#endif
	{	register int	row;
		register int	height = HmHEIGHT;
a442 1
#if __STDC__
d444 3
a446 6
#else
HmSetmap( win )
HmWindow	*win;
#endif
	{	register int	row;
		register int	height = HmHEIGHT;
a459 1
#if __STDC__
d461 1
a461 6
#else
HmInWin( x, y, win )
register int		x, y;
register HmWindow	*win;
#endif
	{
a486 1
#if __STDC__
d488 4
a491 6
#else
HmDrawWin( win )
register HmWindow	*win;
#endif
	{	register HmItem	*itemp;
		int	height;
a524 1
#if __STDC__
d526 1
a526 6
#else
HmHelp( win, entry )
register HmWindow	*win;
int	entry;
#endif
	{
a541 1
#if __STDC__
d543 1
a543 5
#else
HmError( str )
char	*str;
#endif
	{
a559 1
#if __STDC__
d561 3
a563 6
#else
HmLiftWin( win )
register HmWindow	*win;
#endif
	{	register int	row, col;
		register int	lastcol = -1, lastrow = -1;
a602 1
#if __STDC__
d604 1
a604 5
#else
HmPushWin( win )
HmWindow	*win;
#endif
	{
a615 1
#if __STDC__
d617 1
a617 5
#else
HmPopWin( win )
HmWindow	*win;
#endif
	{
a627 1
#if __STDC__
d629 1
a629 5
#else
HmRefreshWin( win )
HmWindow	*win;
#endif
	{
a644 1
#if __STDC__
d646 4
a649 5
#else
HmRedraw()
#endif
	{	register HmWindow	*win;
		register int		reset = 0;
a691 1
#if __STDC__
d693 1
a693 4
#else
HmTtySet()
#endif
	{
a713 1
#if __STDC__
d715 1
a715 4
#else
HmTtyReset()
#endif
	{
a735 1
#if __STDC__
d737 1
a737 6
#else
HmInit( x, y, maxvis )
int	x, y;
int	maxvis;
#endif
	{
a759 1
#if __STDC__
d761 16
a776 17
#else
HmWidHgtMenu( win )
register HmWindow	*win;
#endif
	{	register HmItem	*itemp;
	/* Determine width of menu, allowing for border.		*/
	for( itemp = win->menup->item; itemp->text != (char *) NULL; itemp++ )
		{	register int	len = 0;
			register int	i;
		for( i = 0; itemp->text[i] != '\0' ; i++ )
			if( ! (itemp->text[i] & 0200) )
				len++;
		win->width = Max( win->width, len );
		}
	win->height = HmENTRY;
	return;
	}
a784 1
#if __STDC__
d786 1
a786 5
#else
HmFitMenu( nwin, cwin  )
register HmWindow	*nwin, *cwin;
#endif
	{
a814 1
#if __STDC__
d816 1
a816 5
#else
HmPosMenu( win )
register HmWindow	*win;
#endif
	{
a846 1
#if __STDC__
d848 5
a852 7
#else
HmMyxMouse( x, y )
register int	*x, *y;
#endif
	{	register int	c;
	c = HmGetchar();
	switch( c )
a889 1
#if __STDC__
d891 3
a893 6
#else
HmHit( menup )
HmMenu	*menup;			/* -> first HmItem in array.		*/
#endif
	{	register HmItem	*itemp;
		HmItem		*retitemp = NULL;
d898 1
@


14.12
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d22 5
a26 11
	Author:	Gary S. Moss
		U. S. Army Ballistic Research Laboratory
		Aberdeen Proving Ground
		Maryland 21005-5066

	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.11 2007/01/23 01:13:24 brlcad Exp $ (BRL)

	This code is derived in part from menuhit(9.3) in AT&T 9th Edition UNIX,
		Version 1 Programmer's Manual.

*/
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.11 2007/01/23 01:13:24 brlcad Exp $ (BRL)";
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d27 1
a27 1
	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.10 2007/01/20 14:36:42 brlcad Exp $ (BRL)
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.10 2007/01/20 14:36:42 brlcad Exp $ (BRL)";
d375 1
a375 1
	 	(void) ScSetStandout();
@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d27 1
a27 1
	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.9 2006/01/18 06:46:12 brlcad Exp $ (BRL)
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.9 2006/01/18 06:46:12 brlcad Exp $ (BRL)";
@


14.9
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d28 1
a28 1
	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.8 2005/11/04 14:50:56 brlcad Exp $ (BRL)
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.8 2005/11/04 14:50:56 brlcad Exp $ (BRL)";
@


14.8
log
@burst the non-ansi-yet-willing-to-pretend-we-are-c99 bubble that the burst code likes to use.  that is, use static instead of STATIC and don't clobber the bool/true/false reserved words of the c++ compilers.  clean up the headers to support this.
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d28 1
a28 1
	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.7 2005/11/04 10:43:04 brlcad Exp $ (BRL)
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.7 2005/11/04 10:43:04 brlcad Exp $ (BRL)";
@


14.7
log
@DEBUG/NDEBUG cleanup, pull the value from and include common.h before system headers
@
text
@d28 1
a28 1
	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.6 2005/10/31 06:28:43 brlcad Exp $ (BRL)
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.6 2005/10/31 06:28:43 brlcad Exp $ (BRL)";
d68 1
a68 1
#define HmDEBUG		false
d112 3
a114 3
static bool	HmDirty = false;
static bool	HmMyxflag = false;
static bool	HmPkgInit = false;
d166 1
a166 1
STATIC void
d195 1
a195 1
STATIC void
d217 1
a217 1
STATIC void
d245 1
a245 1
STATIC void
d265 1
a265 1
STATIC void
d293 1
a293 1
STATIC void
d323 1
a323 1
STATIC void
d421 1
a421 1
STATIC void
d462 1
a462 1
STATIC void
d471 1
a471 1
#if HmDEBUG && false
d479 1
a479 1
#if HmDEBUG && false
d492 1
a492 1
STATIC void
d511 1
a511 1
STATIC void
d532 1
a532 1
STATIC HmWindow	*
d541 1
a541 1
#if HmDEBUG && false
d565 1
a565 1
STATIC void
d574 1
a574 1
#if HmDEBUG && true
d606 1
a606 1
STATIC void
d652 1
a652 1
STATIC void
d664 1
a664 1
#if HmDEBUG && true
d679 1
a679 1
				HmDirty = true;
d699 1
a699 1
STATIC void
d717 1
a717 1
STATIC void
d734 1
a734 1
STATIC void
d744 1
a744 1
		HmDirty = false;
d763 2
a764 2
		register int		reset = false;
#if HmDEBUG && true
d771 1
a771 1
		reset = true;
d857 1
a857 1
bool
d871 1
a871 1
		return	false;
d874 1
a874 1
	HmPkgInit = true;
d879 1
a879 1
	return	true;
d887 1
a887 1
STATIC void
d909 1
a909 1
	bool HmFitMenu( register HmWindow *nwin, register HmWindow *cwin )
d912 1
a912 1
	position in nwin, and return true.  Otherwise, return false.
d914 1
a914 1
STATIC bool
d949 1
a949 1
STATIC void
d986 1
a986 1
STATIC void
d1042 2
a1043 2
		register int	done = false;
		int		dynamic = false;
d1048 1
a1048 1
	if( HmPkgInit == false )
d1051 1
a1051 1
		HmPkgInit = true;
d1108 1
a1108 1
#if HmDEBUG && false
d1112 1
a1112 1
#if HmDEBUG && false
@


14.6
log
@remove the deprecated Tc terminal capabilities routines/defines  that were converted to use libtermio -- just use libtermio directly now making the Tc routines officially obsoleted
@
text
@d28 1
a28 1
	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.5 2005/10/23 04:44:29 brlcad Exp $ (BRL)
a33 1
/*LINTLIBRARY*/
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.5 2005/10/23 04:44:29 brlcad Exp $ (BRL)";
d38 1
a38 6
#ifndef DEBUG
#define NDEBUG
#define STATIC static
#else
#define STATIC
#endif
d49 2
@


14.5
log
@trailing ws
@
text
@d28 1
a28 1
	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.4 2005/01/30 20:30:15 brlcad Exp $ (BRL)
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.4 2005/01/30 20:30:15 brlcad Exp $ (BRL)";
d816 3
a818 3
	TcSetCbreak( HmTtyFd );
	TcClrEcho( HmTtyFd );
	TcClrTabs( HmTtyFd );
d848 1
a848 1
	TcResetTty( HmTtyFd );
d877 1
a877 1
	TcSaveTty( HmTtyFd );
@


14.4
log
@update copyright to 2005
@
text
@d28 1
a28 1
	$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.3 2004/12/18 06:50:49 morrison Exp $ (BRL)
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/Hm.c,v 14.3 2004/12/18 06:50:49 morrison Exp $ (BRL)";
d268 1
a268 1
 */ 
d442 1
a442 1
	*p++ = mark; 
d632 1
a632 1
 */ 
d843 1
a843 1
		{ 
d860 1
a860 1
 */	
d917 1
a917 1
 */ 
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
	$Header$ (BRL)
d34 1
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d39 6
a44 1
#include "common.h"
a54 2


d72 1
a72 1
#define HmDEBUG		0
d116 3
a118 3
static boolean	HmDirty = 0;
static boolean	HmMyxflag = 0;
static boolean	HmPkgInit = 0;
d170 1
a170 1
static void
d199 1
a199 1
static void
d221 1
a221 1
static void
d249 1
a249 1
static void
d268 2
a269 2
 */
static void
d297 1
a297 1
static void
d327 1
a327 1
static void
d425 1
a425 1
static void
d442 1
a442 1
	*p++ = mark;
d466 1
a466 1
static void
d475 1
a475 1
#if HmDEBUG && 0
d483 1
a483 1
#if HmDEBUG && 0
d496 1
a496 1
static void
d515 1
a515 1
static void
d536 1
a536 1
static HmWindow	*
d545 1
a545 1
#if HmDEBUG && 0
d569 1
a569 1
static void
d578 1
a578 1
#if HmDEBUG && 1
d610 1
a610 1
static void
d632 1
a632 1
 */
d656 1
a656 1
static void
d668 1
a668 1
#if HmDEBUG && 1
d683 1
a683 1
				HmDirty = 1;
d703 1
a703 1
static void
d721 1
a721 1
static void
d738 1
a738 1
static void
d748 1
a748 1
		HmDirty = 0;
d767 2
a768 2
		register int		reset = 0;
#if HmDEBUG && 1
d775 1
a775 1
		reset = 1;
d816 3
a818 3
	set_Cbreak( HmTtyFd );
	clr_Echo( HmTtyFd );
	clr_Tabs( HmTtyFd );
d843 1
a843 1
		{
d848 1
a848 1
	reset_Tty( HmTtyFd );
d860 2
a861 2
 */
boolean
d875 1
a875 1
		return	0;
d877 2
a878 2
	save_Tty( HmTtyFd );
	HmPkgInit = 1;
d883 1
a883 1
	return	1;
d891 1
a891 1
static void
d913 1
a913 1
	boolean HmFitMenu( register HmWindow *nwin, register HmWindow *cwin )
d916 3
a918 3
	position in nwin, and return 1.  Otherwise, return 0.
 */
static boolean
d953 1
a953 1
static void
d990 1
a990 1
static void
d1046 2
a1047 2
		register int	done = 0;
		int		dynamic = 0;
d1052 1
a1052 1
	if( HmPkgInit == 0 )
d1055 1
a1055 1
		HmPkgInit = 1;
d1112 1
a1112 1
#if HmDEBUG && 0
d1116 1
a1116 1
#if HmDEBUG && 0
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d28 1
a28 1
	$Header: /cvs/brlcad/src/burst/Hm.c,v 14.2 2004/12/18 01:52:36 morrison Exp $ (BRL)
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/Hm.c,v 14.2 2004/12/18 01:52:36 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file Hm.c
d28 1
a28 1
	$Header: /cvs/brlcad/src/burst/Hm.c,v 14.1 2004/11/16 19:42:12 morrison Exp $ (BRL)
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/Hm.c,v 14.1 2004/11/16 19:42:12 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
d27 1
a27 1
	$Header: /cvs/brlcad/src/burst/Hm.c,v 1.1 2004/05/20 15:18:42 morrison Exp $ (BRL)
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/Hm.c,v 1.1 2004/05/20 15:18:42 morrison Exp $ (BRL)";
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d7 1
a7 1
	$Header: /cvs/brlcad/burst/Hm.c,v 1.13 2001/10/17 07:39:59 morrison Exp $ (BRL)
d15 1
a15 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/burst/Hm.c,v 1.13 2001/10/17 07:39:59 morrison Exp $ (BRL)";
d1337 10
@

