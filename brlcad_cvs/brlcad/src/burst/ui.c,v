head	14.19;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.4
	rel-7-10-2:14.15
	rel-7-10-0:14.14
	rel-7-8-4:14.10
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.5
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.5
	rel-7-6-branch:14.5.0.6
	rel-7-6-0:14.5
	rel-7-4-2:14.5
	rel-7-4-branch:14.5.0.4
	bobWinPort:14.5.0.2
	rel-7-4-0:14.5
	rel-7-2-6:14.5
	rel-7-2-4:14.5
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.19
date	2007.12.01.21.47.12;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.10.18.09.11.56;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.10.14.22.15.54;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.10.14.08.01.46;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.07.26.01.13.50;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.02.20.08.19.47;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.27.01.41.31;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.23.01.13.24;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.42;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.07.10.19.06.22;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.11.04.14.50.57;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.11.04.10.43.04;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.04.27.02.24.28;	author brlcad;	state Exp;
branches
	14.5.6.1;
next	14.4;

14.4
date	2005.01.30.20.30.16;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.49;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.01.52.36;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.44;	author morrison;	state Exp;
branches;
next	;

14.5.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.19
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@/*                            U I . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file ui.c
 *	Author:		Gary S. Moss
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.18 2007/10/18 09:11:56 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <assert.h>
#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"

#include "./Sc.h"
#include "./Mm.h"
#include "./burst.h"
#include "./trie.h"
#include "./ascii.h"
#include "./extern.h"


#define DEBUG_UI	0

static char promptbuf[LNBUFSZ];
static const char *bannerp = "BURST (2.2)";

#define AddCmd( nm, f )\
	{	Trie	*p;\
	if( (p = addTrie( nm, &cmdtrie )) == TRIE_NULL )\
		prntScr( "BUG: addTrie(%s) returned NULL.", nm );\
	else	p->l.t_func = f;\
	}

#define GetBool( var, ptr ) \
	if( getInput( ptr ) ) \
		{ \
		if( ptr->buffer[0] == 'y' ) \
			var = 1; \
		else \
		if( ptr->buffer[0] == 'n' ) \
			var = 0; \
		else \
			{ \
			(void) snprintf( scrbuf, LNBUFSZ, "Illegal input \"%s\".", ptr->buffer ); \
			warning( scrbuf ); \
			return; \
			} \
		(ptr)++; \
		}

#define GetVar( var, ptr, conv )\
	{\
	if( ! batchmode )\
		{\
		(void) snprintf( (ptr)->buffer, LNBUFSZ, (ptr)->fmt, var*conv );\
		(void) getInput( ptr );\
		if( (sscanf( (ptr)->buffer, (ptr)->fmt, &(var) )) != 1 )\
			{\
			(void) strcpy( (ptr)->buffer, "" );\
			return;\
			}\
		(ptr)++;\
		}\
	else\
		{	char *tokptr = strtok( cmdptr, WHITESPACE );\
		if(	tokptr == NULL\
		    ||	sscanf( tokptr, (ptr)->fmt, &(var) ) != 1 )\
			{\
			brst_log( "ERROR -- command syntax:\n" );\
			brst_log( "\t%s\n", cmdbuf );\
			brst_log( "\tcommand (%s): argument (%s) is of wrong type, %s expected.\n",\
				cmdptr, tokptr == NULL ? "(null)" : tokptr,\
				(ptr)->fmt );\
			}\
		cmdptr = NULL;\
		}\
	}

typedef struct
	{
	char *prompt;
	char buffer[LNBUFSZ];
	char *fmt;
	char *range;
	}
Input;

/* local menu functions, names all start with M */
static void MattackDir();
static void MautoBurst();
static void MburstArmor();
static void MburstAir();
static void MburstDist();
static void MburstFile();
static void McellSize();
static void McolorFile();
static void Mcomment();
static void MconeHalfAngle();
static void McritComp();
static void MdeflectSpallCone();
static void Mdither();
static void MenclosePortion();
static void MencloseTarget();
static void MerrorFile();
static void Mexecute();
static void MfbFile();
static void MgedFile();
static void MgridFile();
static void MgroundPlane();
static void MhistFile();
static void Minput2dShot();
static void Minput3dShot();
static void MinputBurst();
static void MmaxBarriers();
static void MmaxSpallRays();
static void Mnop();
static void Mobjects();
static void Moverlaps();
static void MplotFile();
static void Mread2dShotFile();
static void Mread3dShotFile();
static void MreadBurstFile();
static void MreadCmdFile();
static void MshotlineFile();
static void Munits();
static void MwriteCmdFile();

/* local utility functions */
static HmMenu *addMenu();
static int getInput();
static int unitStrToInt();
static void addItem();
static void banner();

typedef struct ftable Ftable;
struct ftable
	{
	char *name;
	char *help;
	Ftable *next;
	Func *func;
	};

Ftable	shot2dmenu[] =
	{
	{ "read-2d-shot-file",
		"input shotline coordinates from file",
		0, Mread2dShotFile },
	{ "input-2d-shot",
		"type in shotline coordinates",
		0, Minput2dShot },
	{ "execute", "begin ray tracing", 0, Mexecute },
	{ 0 },
	};

Ftable	shot3dmenu[] =
	{
	{ "read-3d-shot-file",
		"input shotline coordinates from file",
		0, Mread3dShotFile },
	{ "input-3d-shot",
		"type in shotline coordinates",
		0, Minput3dShot },
	{ "execute", "begin ray tracing", 0, Mexecute },
	{ 0 },
	};

Ftable	shotcoordmenu[] =
	{
	{ "target coordinate system",
		"specify shotline location in model coordinates (3-d)",
		shot3dmenu, 0 },
	{ "shotline coordinate system",
		"specify shotline location in attack coordinates (2-d)",
		shot2dmenu, 0 },
	{ 0 }
	};

Ftable	gridmenu[] =
	{
	{ "enclose-target",
		"generate a grid which covers the entire target",
		0, MencloseTarget },
	{ "enclose-portion",
		"generate a grid which covers a portion of the target",
		0, MenclosePortion },
	{ "execute", "begin ray tracing", 0, Mexecute },
	{ 0 }
	};

Ftable	locoptmenu[] =
	{
	{ "envelope",
		"generate a grid of shotlines", gridmenu, 0 },
	{ "discrete shots",
		"specify each shotline by coordinates", shotcoordmenu, 0 },
	{ 0 }
	};

Ftable	burstcoordmenu[] =
	{
	{ "read-burst-file",
		"input burst coordinates from file",
		0, MreadBurstFile },
	{ "burst-coordinates",
		"specify each burst point in target coordinates (3-d)",
		0, MinputBurst },
	{ "execute", "begin ray tracing", 0, Mexecute },
	{ 0 },
	};

Ftable	burstoptmenu[] =
	{
	{ "burst-distance",
		"fuzing distance to burst point from impact",
		0, MburstDist },
	{ "cone-half-angle",
		"degrees from spall cone axis to limit burst rays",
		0, MconeHalfAngle },
	{ "deflect-spall-cone",
		"spall cone axis perturbed halfway to normal direction",
		0, MdeflectSpallCone },
	{ "max-spall-rays",
		"maximum rays generated per burst point (ray density)",
		0, MmaxSpallRays },
	{ "max-barriers",
		"maximum number of shielding components along spall ray",
		0, MmaxBarriers },
	{ 0 }
	};

Ftable	burstlocmenu[] =
	{
	{ "burst point coordinates",
		"input explicit burst points in 3-d target coordinates",
		burstcoordmenu, 0 },
	{ "ground-plane",
		"burst on impact with ground plane",
		0, MgroundPlane },
	{ "shotline-burst",
		"burst along shotline on impact with critical components",
		0, MautoBurst },
	{ 0 }
	};

Ftable	burstmenu[] =
	{
	{ "bursting method",
		"choose method of creating burst points",
		burstlocmenu, 0 },
	{ "bursting parameters",
		"configure spall cone generation options",
		burstoptmenu, 0 },
	{ 0 }
	};

Ftable	shotlnmenu[] =
	{
	{ "attack-direction",
		"shotline orientation WRT target", 0, MattackDir },
	{ "cell-size",
		"shotline separation or coverage (1-D)", 0, McellSize },
	{ "dither-cells",
		"randomize location of shotline within grid cell",
		0, Mdither },
	{ "shotline location",
		"positioning of shotlines", locoptmenu, 0 },
	{ 0 }
	};

Ftable	targetmenu[] =
	{
	{ "target-file",
		"MGED data base file name", 0, MgedFile },
	{ "target-objects",
		"objects to read from MGED file", 0, Mobjects },
	{ "burst-air-file",
		"file containing space codes for triggering burst points",
		0, MburstAir },
	{ "burst-armor-file",
		"file containing armor codes for triggering burst points",
		0, MburstArmor },
	{ "critical-comp-file", "file containing critical component codes",
		0, McritComp },
	{ "color-file", "file containing component ident to color mappings",
		0, McolorFile },
	{ 0 }
	};

Ftable	prefmenu[] =
	{
	{ "report-overlaps",
		"enable or disable the reporting of overlaps",
		0, Moverlaps },
	{ 0 }
	};

Ftable	filemenu[] =
	{
	{ "read-input-file",
		"read commands from a file", 0, MreadCmdFile },
	{ "shotline-file",
		"name shotline output file", 0, MshotlineFile },
	{ "burst-file",
		"name burst point output file", 0, MburstFile },
	{ "error-file",
		"redirect error diagnostics to file", 0, MerrorFile },
	{ "histogram-file",
		"name file for graphing hits on critical components",
		0, MhistFile },
	{ "grid-file",
		"name file for storing grid points",
		0, MgridFile },
	{ "image-file",
		"name frame buffer device", 0, MfbFile },
	{ "plot-file",
		"name UNIX plot output file", 0, MplotFile },
	{ "write-input-file",
		"save input up to this point in a session file",
		0, MwriteCmdFile },
	{ 0 }
	};

Ftable	mainmenu[] =
	{
	{ "units",
		"units for input and output interpretation", 0, Munits },
	{ "project files",
		"set up input/output files for this analysis",
		filemenu, 0 },
	{ "target files",
		"identify target-specific input files", targetmenu, 0 },
	{ "shotlines",
		"shotline generation (grid specification)", shotlnmenu, 0 },
	{ "burst points",
		"burst point generation", burstmenu, 0 },
	{ CMD_COMMENT, "add a comment to the session file", 0, Mcomment },
	{ "execute", "begin ray tracing", 0, Mexecute },
	{ "preferences",
		"options for tailoring behavior of user interface",
		prefmenu, 0 },
	{ 0 }
	};

static void
addItem( tp, itemp )
Ftable *tp;
HmItem *itemp;
	{
	itemp->text = tp->name;
	itemp->help = tp->help;
	itemp->next = addMenu( tp->next );
	itemp->dfn = 0;
	itemp->bfn = 0;
	itemp->hfn = tp->func;
	return;
	}

static HmMenu *
addMenu( tp )
Ftable *tp;
	{	register HmMenu	*menup;
		register HmItem *itemp;
		register Ftable	*ftp = tp;
		register int cnt;
		register boolean done = 0;
	if( ftp == NULL )
		return	NULL;
	for( cnt = 0; ftp->name != NULL; ftp++ )
		cnt++;
	cnt++; /* Must include space for NULL entry. */
	menup = MmAllo( HmMenu );
	menup->item = MmVAllo( cnt, HmItem );
	menup->generator = 0;
	menup->prevtop = 0;
	menup->prevhit = 0;
	menup->sticky = 1;
	/* menup->item should now be as long as tp. */
	for(	ftp = tp, itemp = menup->item;
		! done;
		ftp++, itemp++
		)
		{
		addItem( ftp, itemp );
		if( ftp->name == NULL ) /* Must include NULL entry. */
			done = 1;
		}
	return	menup;
	}

/*
	void banner( void )

	Display program name and version on one line with BORDER_CHRs
	to border the top of the scrolling region.
 */
static void
banner()
	{
	(void) snprintf( scrbuf, LNBUFSZ, "%s", bannerp );
	HmBanner( scrbuf, BORDER_CHR );
	return;
	}

void
closeUi()
	{
	ScMvCursor( 1, ScLI );
	return;
	}

static int
getInput( ip )
Input *ip;
	{
	if( ! batchmode )
		{	register int c;
			register char *p;
			char *defaultp = ip->buffer;
		if( *defaultp == NUL )
			defaultp = "no default";
		if( ip->range != NULL )
			(void) snprintf( promptbuf, LNBUFSZ, "%s ? (%s)[%s] ",
					ip->prompt, ip->range, defaultp );
		else
			(void) snprintf( promptbuf, LNBUFSZ, "%s ? [%s] ",
					ip->prompt, defaultp );
		prompt( promptbuf );
		for( p = ip->buffer; (c = HmGetchar()) != '\n'; )
			if( p - ip->buffer < LNBUFSZ-1 )
				*p++ = c;
		/* In case user hit CR only, do not disturb buffer. */
		if( p != ip->buffer )
			*p = '\0';
		prompt( (char *) NULL );
		}
	else
		{	char *str = strtok( cmdptr, WHITESPACE );
		if( str == NULL )
			return	0;
		(void) strncpy( ip->buffer, str, LNBUFSZ );
		cmdptr = NULL;
		}
	return  1;
	}

/*
	void initCmds( void )

	Initialize the keyword commands.
 */
static void
initCmds( tp )
register Ftable *tp;
	{
	for( ; tp->name != NULL; tp++ )
		{
		if( tp->next != NULL )
			initCmds( tp->next );
		else
			AddCmd( tp->name, tp->func );
		}
	return;
	}

/*
	void initMenus( void )

	Initialize the hierarchical menus.
 */
static void
initMenus( tp )
register Ftable	*tp;
	{
	mainhmenu = addMenu( tp );
	return;
	}

boolean
initUi()
	{
	if( tty )
		{
		if( ! ScInit( stdout ) )
			return	0;
		if( ScSetScrlReg( SCROLL_TOP, SCROLL_BTM ) )
			(void) ScClrScrlReg();
		else
		if( ScDL == NULL )
			{
			prntScr(
		 "This terminal has no scroll region or delete line capability."
				);
			return  0;
			}
		(void) ScClrText();	/* wipe screen */
		HmInit( MENU_LFT, MENU_TOP, MENU_MAXVISITEMS );
		banner();
		}
	initMenus( mainmenu );
	initCmds( mainmenu );
	return	1;
	}

static int
unitStrToInt( str )
char *str;
	{
	if( strcmp( str, UNITS_INCHES ) == 0 )
		return	U_INCHES;
	if( strcmp( str, UNITS_FEET ) == 0 )
		return	U_FEET;
	if( strcmp( str, UNITS_MILLIMETERS ) == 0 )
		return	U_MILLIMETERS;
	if( strcmp( str, UNITS_CENTIMETERS ) == 0 )
		return	U_CENTIMETERS;
	if( strcmp( str, UNITS_METERS ) == 0 )
		return	U_METERS;
	return	U_BAD;
	}

/*ARGSUSED*/
static void
MattackDir( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Attack azimuth", "", "%lf", "degrees" },
			{ "Attack elevation", "", "%lf", "degrees" },
			};
		register Input *ip = input;
	GetVar( viewazim, ip, DEGRAD );
	GetVar( viewelev, ip, DEGRAD );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t%g %g",
			itemp != NULL ? itemp->text : cmdname,
			viewazim, viewelev );
	logCmd( scrbuf );
	viewazim /= DEGRAD;
	viewelev /= DEGRAD;
	return;
	}

/*ARGSUSED*/
static void
MautoBurst( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Burst along shotline", "n", "%d", "y or n" },
			{ "Require burst air", "y", "%d", "y or n" }
			};
		register Input *ip = input;
	GetBool( shotburst, ip );
	if( shotburst )
		{
		GetBool( reqburstair, ip );
		(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s %s",
				itemp != NULL ? itemp->text : cmdname,
				shotburst ? "yes" : "no",
				reqburstair ? "yes" : "no" );
		}
	else
		(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
				itemp != NULL ? itemp->text : cmdname,
				shotburst ? "yes" : "no" );
	logCmd( scrbuf );

	if( shotburst )
		firemode &= ~FM_BURST; /* disable discrete burst points */
	return;
	}

/*ARGSUSED*/
static void
MburstAir( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of burst air file", "", "%s", 0 },
			};
		register Input *ip = input;
		FILE *airfp;
	if( getInput( ip ) )
		(void) strncpy( airfile, ip->buffer, LNBUFSZ );
	else
		airfile[0] = NUL;
	if( (airfp = fopen( airfile, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				airfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			airfile );
	logCmd( scrbuf );
	notify( "Reading burst air idents", NOTIFY_APPEND );
	readIdents( &airids, airfp );
	(void) fclose( airfp );
	notify( NULL, NOTIFY_DELETE );
	return;
	}

/*ARGSUSED*/
static void
MburstArmor( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of burst armor file", "", "%s", 0 },
			};
		register Input *ip = input;
		FILE *armorfp;
	if( getInput( ip ) )
		(void) strncpy( armorfile, ip->buffer, LNBUFSZ );
	else
		armorfile[0] = NUL;
	if( (armorfp = fopen( armorfile, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				armorfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t%s",
			itemp != NULL ? itemp->text : cmdname,
			armorfile );
	logCmd( scrbuf );
	notify( "Reading burst armor idents", NOTIFY_APPEND );
	readIdents( &armorids, armorfp );
	(void) fclose( armorfp );
	notify( NULL, NOTIFY_DELETE );
	return;
	}

/*ARGSUSED*/
static void
MburstDist( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Burst distance", "", "%lf", 0 },
			};
		register Input *ip = input;
	GetVar( bdist, ip, unitconv );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%g",
			itemp != NULL ? itemp->text : cmdname,
			bdist );
	logCmd( scrbuf );
	bdist /= unitconv; /* convert to millimeters */
	return;
	}

/*ARGSUSED*/
static void
MburstFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of burst output file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( outfile, ip->buffer, LNBUFSZ );
	else
		outfile[0] = NUL;
	if( (outfp = fopen( outfile, "w" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Write access denied for \"%s\"",
				outfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			outfile );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
McellSize( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Cell size", "", "%lf", 0 }
			};
		register Input *ip = input;
	GetVar( cellsz, ip, unitconv );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%g",
			itemp != NULL ? itemp->text : cmdname,
			cellsz );
	logCmd( scrbuf );
	cellsz /= unitconv; /* convert to millimeters */
	return;
	}

/*ARGSUSED*/
static void
McolorFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of ident-to-color mapping file",
				"", "%s", 0 },
			};
		register Input *ip = input;
		FILE *colorfp;
	if( getInput( ip ) )
		(void) strncpy( colorfile, ip->buffer, LNBUFSZ );
	else
		colorfile[0] = NUL;
	if( (colorfp = fopen( colorfile, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				colorfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			colorfile );
	logCmd( scrbuf );
	notify( "Reading ident-to-color mappings", NOTIFY_APPEND );
	readColors( &colorids, colorfp );
	notify( NULL, NOTIFY_DELETE );
	return;
	}

/*ARGSUSED*/
static void
Mcomment( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Comment", " ", "%s", 0 },
			};
		register Input *ip = input;
	if( ! batchmode )
		{
		if( getInput( ip ) )
			{
			(void) snprintf( scrbuf, LNBUFSZ, "%c%s",
					CHAR_COMMENT, ip->buffer );
			logCmd( scrbuf );
			(void) strcpy( ip->buffer, " " ); /* restore default */
			}
		}
	else
		logCmd( cmdptr );
	return;
	}

/*ARGSUSED*/
static void
MconeHalfAngle( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Cone angle", "", "%lf", "degrees" },
			};
		register Input *ip = input;
	GetVar( conehfangle, ip, DEGRAD );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%g",
			itemp != NULL ? itemp->text : cmdname,
			conehfangle );
	logCmd( scrbuf );
	conehfangle /= DEGRAD;
	return;
	}

/*ARGSUSED*/
static void
McritComp( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of critical component file", "", "%s", 0 },
			};
		register Input *ip = input;
		FILE *critfp;
	if( getInput( ip ) )
		(void) strncpy( critfile, ip->buffer, LNBUFSZ );
	else
		critfile[0] = NUL;
	if( (critfp = fopen( critfile, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				critfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t%s",
			itemp != NULL ? itemp->text : cmdname,
			critfile );
	logCmd( scrbuf );
	notify( "Reading critical component idents", NOTIFY_APPEND );
	readIdents( &critids, critfp );
	(void) fclose( critfp );
	notify( NULL, NOTIFY_DELETE );
	return;
	}


/*ARGSUSED*/
static void
MdeflectSpallCone( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Deflect cone", "n", "%d", "y or n" },
			};
		register Input *ip = input;
	GetBool( deflectcone, ip );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t%s",
			itemp != NULL ? itemp->text : cmdname,
			deflectcone ? "yes" : "no" );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
Mdither( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Dither cells", "n", "%d", "y or n" },
			};
		register Input *ip = input;
	GetBool( dithercells, ip );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			dithercells ? "yes" : "no" );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
MenclosePortion( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Left border of grid", "", "%lf", 0 },
			{ "Right border of grid", "", "%lf", 0 },
			{ "Bottom border of grid", "", "%lf", 0 },
			{ "Top border of grid", "", "%lf", 0 },
			};
		register Input *ip = input;
	GetVar( gridlf, ip, unitconv );
	GetVar( gridrt, ip, unitconv );
	GetVar( griddn, ip, unitconv );
	GetVar( gridup, ip, unitconv );
	(void) snprintf( scrbuf,LNBUFSZ, 
			"%s\t\t%g %g %g %g",
			itemp != NULL ? itemp->text : cmdname,
			gridlf, gridrt, griddn, gridup );
	logCmd( scrbuf );
	gridlf /= unitconv; /* convert to millimeters */
	gridrt /= unitconv;
	griddn /= unitconv;
	gridup /= unitconv;
	firemode = FM_PART;
	return;
	}

/*ARGSUSED*/
static void
MencloseTarget( itemp )
HmItem *itemp;
	{
	    (void) snprintf( scrbuf, LNBUFSZ, 
			"%s",
			itemp != NULL ? itemp->text : cmdname );
	logCmd( scrbuf );
	firemode = FM_GRID;
	return;
	}

static void
MerrorFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of error output file", "", "%s", 0 },
			};
		register Input *ip = input;
		static int errfd = -1;
	if( getInput( ip ) )
		(void) strncpy( errfile, ip->buffer, LNBUFSZ );
	else
		(void) strncpy( errfile, "/dev/tty", LNBUFSZ );
	/* insure that error log is truncated */
	errfd = open( errfile, O_TRUNC|O_CREAT|O_WRONLY, 0644 );
	if (errfd == -1)
		{
		locPerror( errfile );
		return;
		}
	(void) close( 2 );
	if( fcntl( errfd, F_DUPFD, 2 ) == -1 )
		{
		locPerror( "fcntl" );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			errfile );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
Mexecute( itemp )
HmItem *itemp;
	{	static boolean	gottree = 0;
		boolean		loaderror = 0;
		(void) snprintf( scrbuf, LNBUFSZ, 
			"%s",
			itemp != NULL ? itemp->text : cmdname );
	logCmd( scrbuf );
	if( gedfile[0] == NUL )
		{
		warning( "No target file has been specified." );
		return;
		}
	notify( "Reading target data base", NOTIFY_APPEND );
	rt_prep_timer();
	if(	rtip == RTI_NULL
	    && (rtip = rt_dirbuild( gedfile, title, TITLE_LEN ))
		     == RTI_NULL )
		{
		warning( "Ray tracer failed to read the target file." );
		return;
		}
	prntTimer( "dir" );
	notify( NULL, NOTIFY_DELETE );
	/* Add air into boolean trees, must be set after rt_dirbuild() and
		before rt_gettree().
	 */
	rtip->useair = 1;
	if( ! gottree )
		{	char *ptr, *obj;
		rt_prep_timer();
		for(	ptr = objects;
			(obj = strtok( ptr, WHITESPACE )) != NULL;
			ptr = NULL
			)
			{
			(void) snprintf( scrbuf, LNBUFSZ, "Loading \"%s\"", obj );
			notify( scrbuf, NOTIFY_APPEND );
			if( rt_gettree( rtip, obj ) != 0 )
				{
				    (void) snprintf( scrbuf, LNBUFSZ, 
						"Bad object \"%s\".",
						obj );
				warning( scrbuf );
				loaderror = 1;
				}
			notify( NULL, NOTIFY_DELETE );
			}
		gottree = 1;
		prntTimer( "load" );
		}
	if( loaderror )
		return;
	if( rtip->needprep )
		{
		notify( "Prepping solids", NOTIFY_APPEND );
		rt_prep_timer();
		rt_prep( rtip );
		prntTimer( "prep" );
		notify( NULL, NOTIFY_DELETE );
		}
	gridInit();
	if( nriplevels > 0 )
		spallInit();
	(void) signal( SIGINT, abort_sig );
	gridModel();
	(void) signal( SIGINT, norml_sig );
	return;
	}

/*ARGSUSED*/
static void
MfbFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of frame buffer device", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( fbfile, ip->buffer, LNBUFSZ );
	else
		fbfile[0] = NUL;
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			fbfile );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
MgedFile( itemp )
HmItem *itemp;
{
    struct stat sb;
    static Input input[] = {
	{ "Name of target (MGED) file", "", "%s", 0 },
    };
    register Input *ip = input;

    if( getInput( ip ) )
	(void) strncpy( gedfile, ip->buffer, LNBUFSZ );

    if (!bu_file_exists(gedfile)) {
	(void) snprintf( scrbuf, LNBUFSZ, 
			 "Unable to find file \"%s\"",
			 gedfile );
	warning( scrbuf );
	return;
    }
    (void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
		     itemp != NULL ? itemp->text : cmdname,
		     gedfile );
    logCmd( scrbuf );
    return;
}

/*ARGSUSED*/
static void
MgridFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of grid file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( gridfile, ip->buffer, LNBUFSZ );
	else
		histfile[0] = NUL;
	if( (gridfp = fopen( gridfile, "w" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Write access denied for \"%s\"",
				gridfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			gridfile );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
MgroundPlane( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Activate ground plane bursting",
				"n", "%d", "y or n" },
			{ "Distance of target origin above ground plane",
				"", "%lf", 0 },
			{ "Distance out positive X-axis of target to edge",
				"", "%lf", 0 },
			{ "Distance out negative X-axis of target to edge",
				"", "%lf", 0 },
			{ "Distance out positive Y-axis of target to edge",
				"", "%lf", 0 },
			{ "Distance out negative Y-axis of target to edge",
				"", "%lf", 0 },
			};
		register Input *ip = input;
	GetBool( groundburst, ip );
	if( groundburst )
		{
		GetVar( grndht, ip, unitconv );
		GetVar( grndfr, ip, unitconv );
		GetVar( grndbk, ip, unitconv );
		GetVar( grndlf, ip, unitconv );
		GetVar( grndrt, ip, unitconv );
		(void) snprintf( scrbuf, LNBUFSZ, "%s\t\tyes %g %g %g %g %g",
				itemp != NULL ? itemp->text : cmdname,
				grndht, grndfr, grndbk, grndlf, grndrt );
		grndht /= unitconv; /* convert to millimeters */
		grndfr /= unitconv;
		grndbk /= unitconv;
		grndlf /= unitconv;
		grndrt /= unitconv;
		}
	else
		(void) snprintf( scrbuf, LNBUFSZ, "%s\t\tno",
				itemp != NULL ? itemp->text : cmdname
				);
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
MhistFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of histogram file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( histfile, ip->buffer, LNBUFSZ );
	else
		histfile[0] = NUL;
	if( (histfp = fopen( histfile, "w" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Write access denied for \"%s\"",
				histfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			histfile );
	logCmd( scrbuf );
	return;
	}

static void
MinputBurst( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "X-coordinate of burst point", "", "%lf", 0 },
			{ "Y-coordinate of burst point", "", "%lf", 0 },
			{ "Z-coordinate of burst point", "", "%lf", 0 },
			};
		register Input *ip = input;
	GetVar( burstpoint[X], ip, unitconv );
	GetVar( burstpoint[Y], ip, unitconv );
	GetVar( burstpoint[Z], ip, unitconv );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t%g %g %g",
			itemp != NULL ? itemp->text : cmdname,
			burstpoint[X], burstpoint[Y], burstpoint[Z] );
	logCmd( scrbuf );
	burstpoint[X] /= unitconv; /* convert to millimeters */
	burstpoint[Y] /= unitconv;
	burstpoint[Z] /= unitconv;
	firemode = FM_BURST | FM_3DIM;
	return;
	}

/*ARGSUSED*/
static void
Minput2dShot( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Y'-coordinate of shotline", "", "%lf", 0 },
			{ "Z'-coordinate of shotline", "", "%lf", 0 },
			};
		register Input *ip = input;
	GetVar( fire[X], ip, unitconv );
	GetVar( fire[Y], ip, unitconv );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%g %g",
			itemp != NULL ? itemp->text : cmdname,
			fire[X], fire[Y] );
	logCmd( scrbuf );
	fire[X] /= unitconv; /* convert to millimeters */
	fire[Y] /= unitconv;
	firemode = FM_SHOT;
	return;
	}

/*ARGSUSED*/
static void
Minput3dShot( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "X-coordinate of shotline", "", "%lf", 0 },
			{ "Y-coordinate of shotline", "", "%lf", 0 },
			{ "Z-coordinate of shotline", "", "%lf", 0 },
			};
		register Input *ip = input;
	GetVar( fire[X], ip, unitconv );
	GetVar( fire[Y], ip, unitconv );
	GetVar( fire[Z], ip, unitconv );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%g %g %g",
			itemp != NULL ? itemp->text : cmdname,
			fire[X], fire[Y], fire[Z] );
	logCmd( scrbuf );
	fire[X] /= unitconv; /* convert to millimeters */
	fire[Y] /= unitconv;
	fire[Z] /= unitconv;
	firemode = FM_SHOT | FM_3DIM;
	return;
	}

/*ARGSUSED*/
static void
Mnop( itemp )
HmItem *itemp;
	{
	return;
	}

/*ARGSUSED*/
static void
Mobjects( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "List of objects from target file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( objects, ip->buffer, LNBUFSZ );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			objects );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
Moverlaps( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Report overlaps", "y", "%d", "y or n" },
			};
		register Input *ip = input;
	GetBool( reportoverlaps, ip );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			reportoverlaps ? "yes" : "no" );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
MmaxBarriers( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Maximum spall barriers per ray", "", "%d", 0 },
			};
		register Input *ip = input;
	GetVar( nbarriers, ip, 1 );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%d",
			itemp != NULL ? itemp->text : cmdname,
			nbarriers );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
MmaxSpallRays( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Maximum rays per burst", "", "%d", 0 },
			};
		register Input *ip = input;
	GetVar( nspallrays, ip, 1 );
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%d",
			itemp != NULL ? itemp->text : cmdname,
			nspallrays );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
MplotFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of UNIX plot file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( plotfile, ip->buffer, LNBUFSZ );
	else
		plotfile[0] = NUL;
	if( (plotfp = fopen( plotfile, "w" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Write access denied for \"%s\"",
				plotfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			plotfile );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
Mread2dShotFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of 2-D shot input file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( shotfile, ip->buffer, LNBUFSZ );
	if( (shotfp = fopen( shotfile, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				shotfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t%s",
			itemp != NULL ? itemp->text : cmdname,
			shotfile );
	logCmd( scrbuf );
	firemode = FM_SHOT | FM_FILE ;
	return;
	}

/*ARGSUSED*/
static void
Mread3dShotFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of 3-D shot input file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( shotfile, ip->buffer, LNBUFSZ );
	if( (shotfp = fopen( shotfile, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				shotfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t%s",
			itemp != NULL ? itemp->text : cmdname,
			shotfile );
	logCmd( scrbuf );
	firemode = FM_SHOT | FM_FILE | FM_3DIM;
	return;
	}

/*ARGSUSED*/
static void
MreadBurstFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of 3-D burst input file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( burstfile, ip->buffer, LNBUFSZ );
	if( (burstfp = fopen( burstfile, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				burstfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			burstfile );
	logCmd( scrbuf );
	firemode = FM_BURST | FM_3DIM | FM_FILE ;
	return;
	}

/*ARGSUSED*/
static void
MreadCmdFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of command file", "", "%s", 0 },
			};
		register Input *ip = input;
		char cmdfile[LNBUFSZ];
		FILE *cmdfp;
	if( getInput( ip ) )
		(void) strncpy( cmdfile, ip->buffer, LNBUFSZ );
	if( (cmdfp = fopen( cmdfile, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				cmdfile );
		warning( scrbuf );
		return;
		}
	readBatchInput( cmdfp );
	(void) fclose( cmdfp );
	return;
	}

/*ARGSUSED*/
static void
MshotlineFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of shotline output file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( shotlnfile, ip->buffer, LNBUFSZ );
	else
		shotlnfile[0] = NUL;
	if( (shotlnfp = fopen( shotlnfile, "w" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ,
				"Write access denied for \"%s\"",
				shotlnfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			shotlnfile );
	logCmd( scrbuf );
	return;
	}

HmItem units_items[] =
	{
	{ UNITS_MILLIMETERS,
		"interpret inputs and convert outputs to millimeters",
		0, 0, 0, Mnop },
	{ UNITS_CENTIMETERS,
		"interpret inputs and convert outputs to centimeters",
		0, 0, 0, Mnop },
	{ UNITS_METERS,
		"interpret inputs and convert outputs to meters",
		0, 0, 0, Mnop },
	{ UNITS_INCHES,
		"interpret inputs and convert outputs to inches",
		0, 0, 0, Mnop },
	{ UNITS_FEET,
		"interpret inputs and convert outputs to feet",
		0, 0, 0, Mnop },
	{ 0 }
	};
HmMenu	units_hmenu = { units_items, 0, 0, 0, 0 };

/*ARGSUSED*/
static void
Munits( itemp )
HmItem *itemp;
	{	char *unitstr;
		HmItem *itemptr;
	if( itemp != NULL )
		{
		if( (itemptr = HmHit( &units_hmenu )) == (HmItem *) NULL )
			return;
		unitstr = itemptr->text;
		}
	else
		unitstr = strtok( cmdptr, WHITESPACE );
	units = unitStrToInt( unitstr );
	if( units == U_BAD )
		{
		(void) snprintf( scrbuf, LNBUFSZ, "Illegal units \"%s\"", unitstr );
		warning( scrbuf );
		return;
		}
	switch( units )
		{
	case U_INCHES :
		unitconv = 3.937008e-02;
		break;
	case U_FEET :
		unitconv = 3.280840e-03;
		break;
	case U_MILLIMETERS :
		unitconv = 1.0;
		break;
	case U_CENTIMETERS :
		unitconv = 1.0e-01;
		break;
	case U_METERS :
		unitconv = 1.0e-03;
		break;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			unitstr );
	logCmd( scrbuf );
	return;
	}

/*ARGSUSED*/
static void
MwriteCmdFile( itemp )
HmItem *itemp;
	{	static Input input[] =
			{
			{ "Name of command file", "", "%s", 0 },
			};
		register Input *ip = input;
		char cmdfile[LNBUFSZ];
		FILE *cmdfp;
		FILE *inpfp;
	if( getInput( ip ) )
		(void) strncpy( cmdfile, ip->buffer, LNBUFSZ );
	if( (cmdfp = fopen( cmdfile, "w" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Write access denied for \"%s\"",
				cmdfile );
		warning( scrbuf );
		return;
		}
	if( (inpfp = fopen( tmpfname, "r" )) == NULL )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				tmpfname );
		warning( scrbuf );
		(void) fclose( cmdfp );
		return;
		}
	while( bu_fgets( scrbuf, LNBUFSZ, inpfp ) != NULL )
		fputs( scrbuf, cmdfp );
	(void) fclose( cmdfp );
	(void) fclose( inpfp );
	return;
	}

void
intr_sig( int sig )
	{	static Input input[] =
			{
			{ "Really quit ? ", "n", "%d", "y or n" },
			};
		register Input *ip = input;
	(void) signal( SIGINT, intr_sig );
	if( getInput( ip ) )
		{
		if( ip->buffer[0] == 'y' )
			exitCleanly( SIGINT );
		else
		if( ip->buffer[0] != 'n' )
			{
			    (void) snprintf( scrbuf, LNBUFSZ,
					"Illegal input \"%s\".",
					ip->buffer );
			warning( scrbuf );
			return;
			}
		}
	return;
	}

void
logCmd( cmd )
char *cmd;
	{
	prntScr( "%s", cmd ); /* avoid possible problems with '%' in string */
	if( fprintf( tmpfp, "%s\n", cmd ) < 0 )
		{
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	else
		(void) fflush( tmpfp );
	return;
	}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.18
log
@more quellings of level 4 flawfinder issues
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.17 2007/10/14 22:15:54 brlcad Exp $ (BRL)";
d71 1
a71 3
			(void) snprintf( scrbuf, LNBUFSZ, \
					"Illegal input \"%s\".", \
					ptr->buffer ); \
@


14.17
log
@more level 4 flawfinder issues.  mostly string length clampages.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.16 2007/10/14 08:01:46 brlcad Exp $ (BRL)";
d52 1
a52 2
static const char *bannerp = "BURST (%s)";
static const char *pgmverp = "2.2";
d429 1
a429 1
	(void) snprintf( scrbuf, LNBUFSZ, bannerp, pgmverp );
@


14.16
log
@take care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.15 2007/07/26 01:13:50 brlcad Exp $ (BRL)";
d34 2
d1047 23
a1069 21
	{	static Input input[] =
			{
			{ "Name of target (MGED) file", "", "%s", 0 },
			};
		register Input *ip = input;
	if( getInput( ip ) )
		(void) strncpy( gedfile, ip->buffer, LNBUFSZ );
	if( access( gedfile, 04 ) == -1 )
		{
		    (void) snprintf( scrbuf, LNBUFSZ, 
				"Read access denied for \"%s\"",
				gedfile );
		warning( scrbuf );
		return;
		}
	(void) snprintf( scrbuf, LNBUFSZ, "%s\t\t%s",
			itemp != NULL ? itemp->text : cmdname,
			gedfile );
	logCmd( scrbuf );
	return;
	}
@


14.15
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.14 2007/02/20 08:19:47 brlcad Exp $ (BRL)";
d50 2
a51 2
static char *bannerp = "BURST (%s)";
static char *pgmverp = "2.2";
d70 1
a70 1
			(void) sprintf( scrbuf, \
d83 1
a83 1
		(void) sprintf( (ptr)->buffer, (ptr)->fmt, var*conv );\
d428 1
a428 1
	(void) sprintf(	scrbuf,	bannerp, pgmverp );
d451 1
a451 1
			(void) sprintf( promptbuf, "%s ? (%s)[%s] ",
d454 1
a454 1
			(void) sprintf( promptbuf, "%s ? [%s] ",
d469 1
a469 1
		(void) strcpy( ip->buffer, str );
d562 1
a562 1
	(void) sprintf( scrbuf, "%s\t%g %g",
d585 1
a585 1
		(void) sprintf( scrbuf, "%s\t\t%s %s",
d591 1
a591 1
		(void) sprintf( scrbuf, "%s\t\t%s",
d612 1
a612 1
		(void) strcpy( airfile, ip->buffer );
d617 1
a617 1
		(void) sprintf( scrbuf,
d623 1
a623 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d645 1
a645 1
		(void) strcpy( armorfile, ip->buffer );
d650 1
a650 1
		(void) sprintf( scrbuf,
d656 1
a656 1
	(void) sprintf( scrbuf, "%s\t%s",
d677 1
a677 1
	(void) sprintf( scrbuf, "%s\t\t%g",
d695 1
a695 1
		(void) strcpy( outfile, ip->buffer );
d700 1
a700 1
		(void) sprintf( scrbuf,
d706 1
a706 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d723 1
a723 1
	(void) sprintf( scrbuf, "%s\t\t%g",
d743 1
a743 1
		(void) strcpy( colorfile, ip->buffer );
d748 1
a748 1
		(void) sprintf( scrbuf,
d754 1
a754 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d777 1
a777 1
			(void) sprintf( scrbuf, "%c%s",
d798 1
a798 1
	(void) sprintf( scrbuf, "%s\t\t%g",
d817 1
a817 1
		(void) strcpy( critfile, ip->buffer );
d822 1
a822 1
		(void) sprintf( scrbuf,
d828 1
a828 1
	(void) sprintf( scrbuf, "%s\t%s",
d850 1
a850 1
	(void) sprintf( scrbuf, "%s\t%s",
d867 1
a867 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d890 1
a890 1
	(void) sprintf( scrbuf,
d908 1
a908 1
	(void) sprintf( scrbuf,
d926 1
a926 1
		(void) strcpy( errfile, ip->buffer );
d942 1
a942 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d955 1
a955 1
	(void) sprintf( scrbuf,
d987 1
a987 1
			(void) sprintf( scrbuf, "Loading \"%s\"", obj );
d991 1
a991 1
				(void) sprintf( scrbuf,
d1031 1
a1031 1
		(void) strcpy( fbfile, ip->buffer );
d1034 1
a1034 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d1051 1
a1051 1
		(void) strcpy( gedfile, ip->buffer );
d1054 1
a1054 1
		(void) sprintf( scrbuf,
d1060 1
a1060 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d1077 1
a1077 1
		(void) strcpy( gridfile, ip->buffer );
d1082 1
a1082 1
		(void) sprintf( scrbuf,
d1088 1
a1088 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d1123 1
a1123 1
		(void) sprintf( scrbuf, "%s\t\tyes %g %g %g %g %g",
d1133 1
a1133 1
		(void) sprintf( scrbuf, "%s\t\tno",
d1150 1
a1150 1
		(void) strcpy( histfile, ip->buffer );
d1155 1
a1155 1
		(void) sprintf( scrbuf,
d1161 1
a1161 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d1181 1
a1181 1
	(void) sprintf( scrbuf, "%s\t%g %g %g",
d1204 1
a1204 1
	(void) sprintf( scrbuf, "%s\t\t%g %g",
d1228 1
a1228 1
	(void) sprintf( scrbuf, "%s\t\t%g %g %g",
d1257 2
a1258 2
		(void) strcpy( objects, ip->buffer );
	(void) sprintf( scrbuf, "%s\t\t%s",
d1275 1
a1275 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d1292 1
a1292 1
	(void) sprintf( scrbuf, "%s\t\t%d",
d1309 1
a1309 1
	(void) sprintf( scrbuf, "%s\t\t%d",
d1326 1
a1326 1
		(void) strcpy( plotfile, ip->buffer );
d1331 1
a1331 1
		(void) sprintf( scrbuf,
d1337 1
a1337 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d1354 1
a1354 1
		(void) strcpy( shotfile, ip->buffer );
d1357 1
a1357 1
		(void) sprintf( scrbuf,
d1363 1
a1363 1
	(void) sprintf( scrbuf, "%s\t%s",
d1381 1
a1381 1
		(void) strcpy( shotfile, ip->buffer );
d1384 1
a1384 1
		(void) sprintf( scrbuf,
d1390 1
a1390 1
	(void) sprintf( scrbuf, "%s\t%s",
d1408 1
a1408 1
		(void) strcpy( burstfile, ip->buffer );
d1411 1
a1411 1
		(void) sprintf( scrbuf,
d1417 1
a1417 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d1437 1
a1437 1
		(void) strcpy( cmdfile, ip->buffer );
d1440 1
a1440 1
		(void) sprintf( scrbuf,
d1461 1
a1461 1
		(void) strcpy( shotlnfile, ip->buffer );
d1466 1
a1466 1
		(void) sprintf( scrbuf,
d1472 1
a1472 1
	(void) sprintf( scrbuf, "%s\t\t%s",
d1517 1
a1517 1
		(void) sprintf( scrbuf, "Illegal units \"%s\"", unitstr );
d1539 1
a1539 1
	(void) sprintf( scrbuf, "%s\t\t\t%s",
d1559 1
a1559 1
		(void) strcpy( cmdfile, ip->buffer );
d1562 1
a1562 1
		(void) sprintf( scrbuf,
d1570 1
a1570 1
		(void) sprintf( scrbuf,
d1599 1
a1599 1
			(void) sprintf( scrbuf,
@


14.14
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d22 1
a22 4
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.13 2007/01/27 01:41:31 brlcad Exp $ (BRL)";
@


14.13
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.12 2007/01/23 01:13:24 brlcad Exp $ (BRL)";
d1580 1
a1580 1
	while( fgets( scrbuf, LNBUFSZ, inpfp ) != NULL )
@


14.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.11 2007/01/20 14:36:42 brlcad Exp $ (BRL)";
d423 1
a423 1
        void banner( void )
d425 1
a425 1
        Display program name and version on one line with BORDER_CHRs
d430 2
a431 2
        {
        (void) sprintf(	scrbuf,	bannerp, pgmverp );
d433 2
a434 2
        return;
        }
d517 1
a517 1
 		if( ScSetScrlReg( SCROLL_TOP, SCROLL_BTM ) )
d932 1
a932 1
        /* insure that error log is truncated */
d934 12
a945 12
        if (errfd == -1)
                {
                locPerror( errfile );
                return;
                }
        (void) close( 2 );
        if( fcntl( errfd, F_DUPFD, 2 ) == -1 )
                {
                locPerror( "fcntl" );
                return;
                }
  	(void) sprintf( scrbuf, "%s\t\t%s",
d979 1
a979 1
                before rt_gettree().
@


14.11
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.10 2006/07/10 19:06:22 brlcad Exp $ (BRL)";
@


14.10
log
@refactor away the old BSD block defines among other simple cleanup
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.9 2006/01/18 06:46:13 brlcad Exp $ (BRL)";
@


14.9
log
@update copyright to 2006
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.8 2005/11/04 14:50:57 brlcad Exp $ (BRL)";
d934 2
a935 7
        if(     (errfd =
#ifdef BSD
                creat( errfile, 0644 )) == -1
#else
                open( errfile, O_TRUNC|O_CREAT|O_WRONLY, 0644 )) == -1
#endif
                )
@


14.8
log
@burst the non-ansi-yet-willing-to-pretend-we-are-c99 bubble that the burst code likes to use.  that is, use static instead of STATIC and don't clobber the bool/true/false reserved words of the c++ compilers.  clean up the headers to support this.
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.7 2005/11/04 10:43:04 brlcad Exp $ (BRL)";
@


14.7
log
@DEBUG/NDEBUG cleanup, pull the value from and include common.h before system headers
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.6 2005/10/23 04:44:29 brlcad Exp $ (BRL)";
d68 1
a68 1
			var = true; \
d71 1
a71 1
			var = false; \
d121 38
a158 38
STATIC void MattackDir();
STATIC void MautoBurst();
STATIC void MburstArmor();
STATIC void MburstAir();
STATIC void MburstDist();
STATIC void MburstFile();
STATIC void McellSize();
STATIC void McolorFile();
STATIC void Mcomment();
STATIC void MconeHalfAngle();
STATIC void McritComp();
STATIC void MdeflectSpallCone();
STATIC void Mdither();
STATIC void MenclosePortion();
STATIC void MencloseTarget();
STATIC void MerrorFile();
STATIC void Mexecute();
STATIC void MfbFile();
STATIC void MgedFile();
STATIC void MgridFile();
STATIC void MgroundPlane();
STATIC void MhistFile();
STATIC void Minput2dShot();
STATIC void Minput3dShot();
STATIC void MinputBurst();
STATIC void MmaxBarriers();
STATIC void MmaxSpallRays();
STATIC void Mnop();
STATIC void Mobjects();
STATIC void Moverlaps();
STATIC void MplotFile();
STATIC void Mread2dShotFile();
STATIC void Mread3dShotFile();
STATIC void MreadBurstFile();
STATIC void MreadCmdFile();
STATIC void MshotlineFile();
STATIC void Munits();
STATIC void MwriteCmdFile();
d161 5
a165 5
STATIC HmMenu *addMenu();
STATIC int getInput();
STATIC int unitStrToInt();
STATIC void addItem();
STATIC void banner();
d377 1
a377 1
STATIC void
d391 1
a391 1
STATIC HmMenu *
d398 1
a398 1
		register bool done = false;
d409 1
a409 1
	menup->sticky = true;
d418 1
a418 1
			done = true;
d429 1
a429 1
STATIC void
d444 1
a444 1
STATIC int
d472 1
a472 1
			return	false;
d476 1
a476 1
	return  true;
d484 1
a484 1
STATIC void
d503 1
a503 1
STATIC void
d511 1
a511 1
bool
d517 1
a517 1
			return	false;
d526 1
a526 1
			return  false;
d534 1
a534 1
	return	true;
d537 1
a537 1
STATIC int
d555 1
a555 1
STATIC void
d576 1
a576 1
STATIC void
d606 1
a606 1
STATIC void
d639 1
a639 1
STATIC void
d672 1
a672 1
STATIC void
d690 1
a690 1
STATIC void
d718 1
a718 1
STATIC void
d736 1
a736 1
STATIC void
d769 1
a769 1
STATIC void
d793 1
a793 1
STATIC void
d811 1
a811 1
STATIC void
d845 1
a845 1
STATIC void
d862 1
a862 1
STATIC void
d879 1
a879 1
STATIC void
d908 1
a908 1
STATIC void
d920 1
a920 1
STATIC void
d959 1
a959 1
STATIC void
d962 2
a963 2
	{	static bool	gottree = false;
		bool		loaderror = false;
d987 1
a987 1
	rtip->useair = true;
d1004 1
a1004 1
				loaderror = true;
d1008 1
a1008 1
		gottree = true;
d1031 1
a1031 1
STATIC void
d1051 1
a1051 1
STATIC void
d1077 1
a1077 1
STATIC void
d1105 1
a1105 1
STATIC void
d1150 1
a1150 1
STATIC void
d1177 1
a1177 1
STATIC void
d1202 1
a1202 1
STATIC void
d1224 1
a1224 1
STATIC void
d1249 1
a1249 1
STATIC void
d1257 1
a1257 1
STATIC void
d1275 1
a1275 1
STATIC void
d1292 1
a1292 1
STATIC void
d1309 1
a1309 1
STATIC void
d1326 1
a1326 1
STATIC void
d1354 1
a1354 1
STATIC void
d1381 1
a1381 1
STATIC void
d1408 1
a1408 1
STATIC void
d1435 1
a1435 1
STATIC void
d1461 1
a1461 1
STATIC void
d1507 1
a1507 1
HmMenu	units_hmenu = { units_items, 0, 0, 0, false };
d1510 1
a1510 1
STATIC void
d1556 1
a1556 1
STATIC void
@


14.6
log
@trailing ws
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.5 2005/04/27 02:24:28 brlcad Exp $ (BRL)";
d32 1
a32 6
#ifndef DEBUG
#define NDEBUG
#define STATIC static
#else
#define STATIC
#endif
a34 1

d39 3
a41 3
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
d50 1
@


14.5
log
@get rid of the old STD_SIGNAL_DECLS define since an ansi compliant compiler is necessary now.  if a broken impl is found that needs to be accounted for, it can return as a proper configure check.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.4 2005/01/30 20:30:16 brlcad Exp $ (BRL)";
d604 1
a604 1
	
d940 1
a940 1
#ifdef BSD      
d942 1
a942 1
#else    
d944 1
a944 1
#endif 
d1539 2
a1540 2
		break;   
	case U_FEET : 
d1542 1
a1542 1
		break;   
d1545 1
a1545 1
		break;   
d1552 1
a1552 1
		}     
@


14.5.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d32 6
a37 1
#include "common.h"
d40 1
d45 3
a47 3
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
a55 1

d73 1
a73 1
			var = 1; \
d76 1
a76 1
			var = 0; \
d126 38
a163 38
static void MattackDir();
static void MautoBurst();
static void MburstArmor();
static void MburstAir();
static void MburstDist();
static void MburstFile();
static void McellSize();
static void McolorFile();
static void Mcomment();
static void MconeHalfAngle();
static void McritComp();
static void MdeflectSpallCone();
static void Mdither();
static void MenclosePortion();
static void MencloseTarget();
static void MerrorFile();
static void Mexecute();
static void MfbFile();
static void MgedFile();
static void MgridFile();
static void MgroundPlane();
static void MhistFile();
static void Minput2dShot();
static void Minput3dShot();
static void MinputBurst();
static void MmaxBarriers();
static void MmaxSpallRays();
static void Mnop();
static void Mobjects();
static void Moverlaps();
static void MplotFile();
static void Mread2dShotFile();
static void Mread3dShotFile();
static void MreadBurstFile();
static void MreadCmdFile();
static void MshotlineFile();
static void Munits();
static void MwriteCmdFile();
d166 5
a170 5
static HmMenu *addMenu();
static int getInput();
static int unitStrToInt();
static void addItem();
static void banner();
d382 1
a382 1
static void
d396 1
a396 1
static HmMenu *
d403 1
a403 1
		register boolean done = 0;
d414 1
a414 1
	menup->sticky = 1;
d423 1
a423 1
			done = 1;
d434 1
a434 1
static void
d449 1
a449 1
static int
d477 1
a477 1
			return	0;
d481 1
a481 1
	return  1;
d489 1
a489 1
static void
d508 1
a508 1
static void
d516 1
a516 1
boolean
d522 1
a522 1
			return	0;
d531 1
a531 1
			return  0;
d539 1
a539 1
	return	1;
d542 1
a542 1
static int
d560 1
a560 1
static void
d581 1
a581 1
static void
d604 1
a604 1

d611 1
a611 1
static void
d644 1
a644 1
static void
d677 1
a677 1
static void
d695 1
a695 1
static void
d723 1
a723 1
static void
d741 1
a741 1
static void
d774 1
a774 1
static void
d798 1
a798 1
static void
d816 1
a816 1
static void
d850 1
a850 1
static void
d867 1
a867 1
static void
d884 1
a884 1
static void
d913 1
a913 1
static void
d925 1
a925 1
static void
d940 1
a940 1
#ifdef BSD
d942 1
a942 1
#else
d944 1
a944 1
#endif
d964 1
a964 1
static void
d967 2
a968 2
	{	static boolean	gottree = 0;
		boolean		loaderror = 0;
d992 1
a992 1
	rtip->useair = 1;
d1009 1
a1009 1
				loaderror = 1;
d1013 1
a1013 1
		gottree = 1;
d1036 1
a1036 1
static void
d1056 1
a1056 1
static void
d1082 1
a1082 1
static void
d1110 1
a1110 1
static void
d1155 1
a1155 1
static void
d1182 1
a1182 1
static void
d1207 1
a1207 1
static void
d1229 1
a1229 1
static void
d1254 1
a1254 1
static void
d1262 1
a1262 1
static void
d1280 1
a1280 1
static void
d1297 1
a1297 1
static void
d1314 1
a1314 1
static void
d1331 1
a1331 1
static void
d1359 1
a1359 1
static void
d1386 1
a1386 1
static void
d1413 1
a1413 1
static void
d1440 1
a1440 1
static void
d1466 1
a1466 1
static void
d1512 1
a1512 1
HmMenu	units_hmenu = { units_items, 0, 0, 0, 0 };
d1515 1
a1515 1
static void
d1539 2
a1540 2
		break;
	case U_FEET :
d1542 1
a1542 1
		break;
d1545 1
a1545 1
		break;
d1552 1
a1552 1
		}
d1561 1
a1561 1
static void
@


14.4
log
@update copyright to 2005
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/ui.c,v 14.3 2004/12/18 06:50:49 morrison Exp $ (BRL)";
a1597 2
#if STD_SIGNAL_DECLS
/*ARGSUSED*/
d1599 1
a1599 5
#else
int
#endif
intr_sig( sig )
int sig;
a1619 1
#if STD_SIGNAL_DECLS
a1620 3
#else
	return	sig;
#endif
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/ui.c,v 14.2 2004/12/18 01:52:36 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file ui.c
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/ui.c,v 14.1 2004/11/16 19:42:12 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/ui.c,v 1.1 2004/05/20 15:18:44 morrison Exp $ (BRL)";
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/burst/ui.c,v 1.15 2000/08/24 23:12:45 mike Exp $ (BRL)";
d1626 10
@

