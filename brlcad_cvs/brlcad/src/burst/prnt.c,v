head	14.24;
access;
symbols
	rel-7-10-4:14.20
	STABLE:14.20.0.2
	stable-branch:14.5
	rel-7-10-2:14.20
	rel-7-10-0:14.19
	rel-7-8-4:14.16
	rel-7-8-2:14.16
	rel-7-8-0:14.16
	trimnurbs-branch:14.16.0.2
	help:14.16
	temp_tag:14.15
	bobWinPort-20051223-freeze:14.10
	postmerge-20051223-bobWinPort:14.15
	premerge-20051223-bobWinPort:14.15
	rel-7-6-6:14.15
	rel-7-6-4:14.15
	rel-7-6-2:14.10
	rel-7-6-branch:14.10.0.4
	rel-7-6-0:14.10
	rel-7-4-2:14.9.2.1
	rel-7-4-branch:14.9.0.2
	bobWinPort:14.10.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.9
	rel-7-2-4:14.8
	rel-7-2-2:14.5
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.24
date	2007.12.15.08.44.39;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.12.06.14.09.26;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.12.03.22.57.58;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.10.14.08.01.46;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.07.26.01.13.50;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.27.01.41.31;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.23.01.13.24;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.20.14.36.42;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.11.04.20.27.11;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.11.04.14.50.57;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.11.04.10.43.04;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.10.31.06.28.43;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.07.26.04.40.53;	author brlcad;	state Exp;
branches
	14.10.4.1;
next	14.9;

14.9
date	2005.05.28.02.14.49;	author brlcad;	state Exp;
branches
	14.9.2.1;
next	14.8;

14.8
date	2005.05.11.21.48.54;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.05.03.05.18.30;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.04.27.02.02.12;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.03.28.16.47.37;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.30.16;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.49;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.01.52.36;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.24.15.07.35;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.44;	author morrison;	state Exp;
branches;
next	;

14.9.2.1
date	2005.08.16.21.03.47;	author brlcad;	state Exp;
branches;
next	;

14.10.4.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.24
log
@strerror is c89, and does work on windows at least with vc8 so drop the obsolete and error-prone sys_errlist array alternates and configure check
@
text
@/*                          P R N T . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file prnt.c
 *	Author:		Gary S. Moss
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.23 2007/12/06 14:09:26 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <signal.h>
#include <errno.h>

#include "./vecmath.h"
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "libtermio.h"

#include "./Sc.h"
#include "./ascii.h"
#include "./extern.h"


#define MAX_COLS	128

#define PHANTOM_ARMOR	111

static fastf_t getNormThickness();

int
doMore( linesp )
int	*linesp;
	{	register int	ret = 1;
	if( ! tty )
		return	1;
	save_Tty( HmTtyFd );
	set_Raw( HmTtyFd );
	clr_Echo( HmTtyFd );
	ScSetStandout();
	prompt( "-- More -- " );
	ScClrStandout();
	(void) fflush( stdout );
	switch( HmGetchar() )
		{
	case 'q' :
	case 'n' :
		ret = 0;
		break;
	case LF :
	case CR :
		*linesp = 1;
		break;
	default :
		*linesp = (PROMPT_Y-SCROLL_TOP);
		break;
		}
	reset_Tty( HmTtyFd );
	return	ret;
	}

static int
f_Nerror( ap )
struct application *ap;
	{
	brst_log( "Couldn't compute thickness or exit point %s.\n",
		"along normal direction" );
	V_Print( "\tpnt", ap->a_ray.r_pt, brst_log );
	V_Print( "\tdir", ap->a_ray.r_dir, brst_log );
	ap->a_rbeam = 0.0;
	return	0;
	}

/*	f_Normal()

	Shooting from surface of object along reversed entry normal to
	compute exit point along normal direction and normal thickness.
	Thickness returned in "a_rbeam".
 */
static int
f_Normal( ap, pt_headp, segp )
struct application *ap;
struct partition *pt_headp;
struct seg *segp;
	{	register struct partition *pp = pt_headp->pt_forw;
		register struct partition *cp;
		register struct hit *ohitp;
	for(	cp = pp->pt_forw;
		cp != pt_headp && SameCmp( pp->pt_regionp, cp->pt_regionp );
		cp = cp->pt_forw
		)
		;
	ohitp = cp->pt_back->pt_outhit;
	ap->a_rbeam = ohitp->hit_dist - pp->pt_inhit->hit_dist;
#ifdef VDEBUG
	brst_log( "f_Normal: thickness=%g dout=%g din=%g\n",
		ap->a_rbeam*unitconv, ohitp->hit_dist, pp->pt_inhit->hit_dist );
#endif
	return	1;
	}


void
locPerror( msg )
char    *msg;
	{
	if( errno > 0 )
		brst_log( "%s: %s\n", msg, strerror(errno) );
	else
		brst_log( "BUG: errno not set, shouldn't call perror.\n" );
	return;
	}

int
notify( str, mode )
char    *str;
int	mode;
	{       register int    i;
		static int      lastlen = -1;
		register int    len;
		static char	buf[LNBUFSZ] = { 0 };
		register char	*p='\0';
	if( ! tty )
		return	0;
	switch( mode )
		{
	case NOTIFY_APPEND :
		p = buf + lastlen;
		break;
	case NOTIFY_DELETE :
		for( p = buf+lastlen; p > buf && *p != NOTIFY_DELIM; p-- )
			;
		break;
	case NOTIFY_ERASE :
		p = buf;
		break;
		}
	if( str != NULL )
		{
		if( p > buf )
			*p++ = NOTIFY_DELIM;
		(void) strncpy( p, str, LNBUFSZ );
		}
	else
		*p = NUL;
	(void) ScMvCursor( PROMPT_X, PROMPT_Y );
	len = strlen( buf );
	if( len > 0 )
		{
		(void) ScSetStandout();
		(void) fputs( buf, stdout );
		(void) ScClrStandout();
		}

	/* Blank out remainder of previous command. */
	for( i = len; i < lastlen; i++ )
		(void) putchar( ' ' );
	(void) ScMvCursor( PROMPT_X, PROMPT_Y );
	(void) fflush( stdout );
	lastlen = len;
	return	1;
	}

/*
	void prntAspectInit( void )

	Burst Point Library and Shotline file: header record for each view.
	Ref. Figure 20., Line Number 1 and Figure 19., Line Number 1 of ICD.
 */
void
prntAspectInit()
	{	fastf_t projarea;	/* projected area */
	/* Convert to user units before squaring cell size. */
	projarea = cellsz*unitconv;
	projarea *= projarea;
	if(	outfile[0] != NUL
	    &&	fprintf(outfp,
			"%c % 9.4f % 8.4f % 5.2f % 10.2f %-6s % 9.6f\n",
			PB_ASPECT_INIT,
			viewazim*DEGRAD, /* attack azimuth in degrees */
			viewelev*DEGRAD, /* attack elevation in degrees */
			bdist*unitconv,  /* BDIST */
			projarea, /* projected area associated with burst pt. */
			units == U_INCHES ?      "inches" :
			units == U_FEET ?        "feet" :
			units == U_MILLIMETERS ? "mm" :
			units == U_CENTIMETERS ? "cm" :
			units == U_METERS ?      "meters" : "units?",
			raysolidangle
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if(	shotlnfile[0] != NUL
	    &&	fprintf(shotlnfp,
		     "%c % 9.4f % 8.4f % 7.2f % 7.2f %7.2f %7.2f %7.2f %-6s\n",
			PS_ASPECT_INIT,
			viewazim*DEGRAD, /* attack azimuth in degrees */
			viewelev*DEGRAD, /* attack elevation in degrees */
			cellsz*unitconv, /* shotline separation */
			modlrt*unitconv, /* maximum Y'-coordinate of target */
			modllf*unitconv, /* minimum Y'-coordinate of target */
			modlup*unitconv, /* maximum Z'-coordinate of target */
			modldn*unitconv, /* minimum Z'-coordinate of target */
			units == U_INCHES ?      "inches" :
			units == U_FEET ?        "feet" :
			units == U_MILLIMETERS ? "mm" :
			units == U_CENTIMETERS ? "cm" :
			units == U_METERS ?      "meters" : "units?"
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", shotlnfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	return;
	}

/*
	void prntBurstHdr( fastf_t *bpt, fastf_t *shotdir )

	This routine must be called before bursting when doing either a
	ground plane burst or bursting at user-specified coordinates.  The
	purpose is to output fake PB_CELL_IDENT and PB_RAY_INTERSECT records
	to the Burst Point Library so that the coordinates of the burst point
	can be made available.

 */
void
prntBurstHdr( bpt, shotdir )
fastf_t *bpt;		/* burst point in model coords */
fastf_t *shotdir;	/* shotline direction vector */
	{	fastf_t vec[3];
	/* Transform burst point (model coordinate system) into the shotline
	   coordinate system. */
	vec[Y] = Dot( gridhor, bpt );	/* Y' */
	vec[Z] = Dot( gridver, bpt );	/* Z' */
	vec[X] = -Dot( shotdir, bpt );	/* X' - shotdir is reverse of X' */

	if(	outfile[0] != NUL
	    &&	fprintf(outfp,
			"%c % 8.3f % 8.3f\n",
			PB_CELL_IDENT,
			vec[Y]*unitconv,
				/* horizontal coordinate of burst point (Y') */
			vec[Z]*unitconv
				/* vertical coordinate of burst point (Z') */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if(	outfile[0] != NUL
	    &&	fprintf( outfp,
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.2f % 7.3f %c\n",
			PB_RAY_INTERSECT,
			vec[X]*unitconv, /* X' coordinate of burst point */
			0.0,		/* LOS thickness of component */
			9999,		/* dummy component code number */
			9,		/* dummy space code */
			0.0,		/* N/A */
			0.0,		/* N/A */
			0.0,		/* N/A */
			'1'		/* burst was generated */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	}

/*
	void prntCellIdent( struct application *ap )

	Burst Point Library and Shotline file: information about shotline.
	Ref. Figure 20., Line Number 2 and Figure 19., Line Number 2 of ICD.

	NOTE: field width of first 2 floats compatible with PB_RAY_HEADER
	record.
 */
void
prntCellIdent( ap )
register struct application *ap;
	{
	if(	outfile[0] != NUL
	    &&	fprintf(outfp,
			"%c % 8.3f % 8.3f\n",
			PB_CELL_IDENT,
			ap->a_uvec[X]*unitconv,
				/* horizontal coordinate of shotline (Y') */
			ap->a_uvec[Y]*unitconv
				/* vertical coordinate of shotline (Z') */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if(	shotlnfile[0] != NUL
	    &&	fprintf(shotlnfp,
			"%c % 8.3f % 8.3f\n",
			PS_CELL_IDENT,
			ap->a_uvec[X]*unitconv,
				/* horizontal coordinate of shotline (Y') */
			ap->a_uvec[Y]*unitconv
				/* vertical coordinate of shotline (Z') */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", shotlnfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	return;
	}

/*
	void prntSeg( struct application *ap, struct partition *cpp, int space,
			fastf_t entrynorm[3], fastf_t exitnorm[3],
			boolean burstflag )

	Burst Point Library and Shotline file: information about each component
	hit along path of main penetrator (shotline).
	Ref. Figure 20., Line Number 3 and Figure 19., Line Number 2 of ICD.
 */
void
prntSeg( ap, cpp, space, entrynorm, exitnorm, burstflag )
register struct application *ap;
register struct partition *cpp;		/* component partition */
int space;
fastf_t entrynorm[3];
fastf_t exitnorm[3];
boolean burstflag; /* Was a burst generated by this partition? */
	{	fastf_t icosobliquity;	/* cosine of obliquity at entry */
		fastf_t ocosobliquity;	/* cosine of obliquity at exit */
		fastf_t	entryangle;	/* obliquity angle at entry */
		fastf_t exitangle;	/* obliquity angle at exit */
		fastf_t los;		/* line-of-sight thickness */
		fastf_t normthickness;	/* normal thickness */
		fastf_t	rotangle;	/* rotation angle */
		fastf_t sinfbangle;	/* sine of fall back angle */

	/* This *should* give negative of desired result. */
	icosobliquity = Dot( ap->a_ray.r_dir, entrynorm );
	icosobliquity = -icosobliquity;

	ocosobliquity = Dot( ap->a_ray.r_dir, exitnorm );

	if( exitnorm[Y] == 0.0 && exitnorm[X] == 0.0 )
		rotangle = 0.0;
	else
		{
		rotangle = atan2( exitnorm[Y], exitnorm[X] );
		rotangle *= DEGRAD; /* convert to degrees */
		if( rotangle < 0.0 )
			rotangle += 360.0;
		}
	/* Compute sine of fallback angle.  NB: the Air Force measures the
		fallback angle from the horizontal (X-Y) plane. */
	sinfbangle = Dot( exitnorm, zaxis );

	los = (cpp->pt_outhit->hit_dist-cpp->pt_inhit->hit_dist)*unitconv;
#ifdef VDEBUG
	brst_log( "prntSeg: los=%g dout=%g din=%g\n",
		los, cpp->pt_outhit->hit_dist, cpp->pt_inhit->hit_dist );
#endif

	if(	outfile[0] != NUL
	    &&	fprintf( outfp,
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.2f % 7.3f %c\n",
			PB_RAY_INTERSECT,
			(standoff - cpp->pt_inhit->hit_dist)*unitconv,
					/* X'-coordinate of intersection */
			los,		/* LOS thickness of component */
			cpp->pt_regionp->reg_regionid,
					/* component code number */
			space,		/* space code */
			sinfbangle,	/* sine of fallback angle at exit */
			rotangle,	/* rotation angle in degrees at exit */
			icosobliquity,	/* cosine of obliquity angle at entry */
			burstflag ? '1' : '0' /* flag generation of burst */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if( shotlnfile[0] == NUL )
		return;
	entryangle = AproxEq( icosobliquity, 1.0, COS_TOL ) ?
			0.0 : acos( icosobliquity ) * DEGRAD;
	if(	(normthickness =
		 getNormThickness( ap, cpp, icosobliquity, entrynorm )) <= 0.0
	    &&	fatalerror )
		{
		brst_log( "Couldn't compute normal thickness.\n" );
		brst_log( "\tshotline coordinates <%g,%g>\n",
			ap->a_uvec[X]*unitconv,
			ap->a_uvec[Y]*unitconv
			);
		brst_log( "\tregion name '%s' solid name '%s'\n",
			cpp->pt_regionp->reg_name,
			cpp->pt_inseg->seg_stp->st_name );
		return;
		}
	exitangle = AproxEq( ocosobliquity, 1.0, COS_TOL ) ?
			0.0 : acos( ocosobliquity ) * DEGRAD;
	if( fprintf( shotlnfp,
	       "%c % 8.2f % 7.3f % 7.2f %4d % 8.2f % 8.2f %2d % 7.2f % 7.2f\n",
			PS_SHOT_INTERSECT,
			(standoff - cpp->pt_inhit->hit_dist)*unitconv,
					/* X'-coordinate of intersection */
			sinfbangle,	/* sine of fallback angle at exit */
			rotangle,	/* rotation angle in degrees at exit */
			cpp->pt_regionp->reg_regionid,
					/* component code number */
			normthickness*unitconv,
					/* normal thickness of component */
			los,		/* LOS thickness of component */
			space,		/* space code */
			entryangle,	/* entry obliquity angle in degrees */
			exitangle	/* exit obliquity angle in degrees */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", shotlnfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	}

/*
	void prntRayHeader( fastf_t *raydir, fastf_t *shotdir, unsigned rayno )

	Burst Point Library: information about burst ray.  All angles are
	WRT the shotline coordinate system, represented by X', Y' and Z'.
	Ref. Figure 20., Line Number 19 of ICD.

	NOTE: field width of first 2 floats compatible with PB_CELL_IDENT
	record.
 */
void
prntRayHeader( raydir, shotdir, rayno )
fastf_t	*raydir;	/* burst ray direction vector */
fastf_t *shotdir;	/* shotline direction vector */
unsigned rayno;		/* ray number for this burst point */
	{	double cosxr;	 /* cosine of angle between X' and raydir */
		double cosyr;	 /* cosine of angle between Y' and raydir */
		fastf_t azim;	 /* ray azim in radians */
		fastf_t sinelev; /* sine of ray elevation */
	if( outfile[0] == NUL )
		return;
	cosxr = -Dot( shotdir, raydir ); /* shotdir is reverse of X' */
	cosyr = Dot( gridhor, raydir );
	if( cosyr == 0.0 && cosxr == 0.0 )
		azim = 0.0;
	else
		azim = atan2( cosyr, cosxr );
	sinelev = Dot( gridver, raydir );
	if(	fprintf( outfp,
			"%c %8.3f %8.3f %6u\n",
			PB_RAY_HEADER,
			azim,   /* ray azimuth angle WRT shotline (radians). */
			sinelev, /* sine of ray elevation angle WRT shotline. */
			rayno
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	}

/*
	void prntRegionHdr( struct application *ap, struct partition *pt_headp,
				struct partition *pp, fastf_t entrynorm[3],
				fastf_t exitnorm[3] )

	Burst Point Libary: intersection along burst ray.
	Ref. Figure 20., Line Number 20 of ICD.
 */
void
prntRegionHdr( ap, pt_headp, pp, entrynorm, exitnorm )
struct application *ap;
struct partition *pt_headp;
struct partition *pp;
fastf_t entrynorm[3], exitnorm[3];
	{	fastf_t	cosobliquity;
		fastf_t normthickness;
		register struct hit *ihitp = pp->pt_inhit;
		register struct hit *ohitp = pp->pt_outhit;
		register struct region *regp = pp->pt_regionp;
		register struct xray *rayp = &ap->a_ray;
	/* Get entry/exit normals and fill in hit points */
	getRtHitNorm( ihitp, pp->pt_inseg->seg_stp, rayp,
		(boolean) pp->pt_inflip, entrynorm );
	if( ! chkEntryNorm( pp, rayp, entrynorm,
		"spall ray component entry normal" ) )
		{
#ifdef DEBUG
		prntDbgPartitions( ap, pt_headp,
			"prntRegionHdr: entry normal flipped." );
#endif
		}
	getRtHitNorm( ohitp, pp->pt_outseg->seg_stp, rayp,
		(boolean) pp->pt_outflip, exitnorm );
	if( ! chkExitNorm( pp, rayp, exitnorm,
		"spall ray component exit normal" ) )
		{
#ifdef DEBUG
		prntDbgPartitions( ap, pt_headp,
			"prntRegionHdr: exit normal flipped." );
#endif
		}


	/* calculate cosine of obliquity angle */
	cosobliquity = Dot( ap->a_ray.r_dir, entrynorm );
	cosobliquity = -cosobliquity;
#if DEBUG
	if( cosobliquity - COS_TOL > 1.0 )
		{
		brst_log( "cosobliquity=%12.8f\n", cosobliquity );
		brst_log( "normal=<%g,%g,%g>\n",
			entrynorm[X],
			entrynorm[Y],
			entrynorm[Z]
			);
		brst_log( "ray direction=<%g,%g,%g>\n",
			ap->a_ray.r_dir[X],
			ap->a_ray.r_dir[Y],
			ap->a_ray.r_dir[Z]
			);
		brst_log( "region name '%s'\n", regp->reg_name );
		}
#endif
	if( outfile[0] == NUL )
		return;


	/* Now we must find normal thickness through component. */
	normthickness = getNormThickness( ap, pp, cosobliquity, entrynorm );
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	if(	fprintf( outfp,
			"%c % 10.3f % 9.3f % 9.3f %4d %4d % 6.3f\n",
			PB_REGION_HEADER,
			ihitp->hit_dist*unitconv, /* distance from burst pt. */
			(ohitp->hit_dist - ihitp->hit_dist)*unitconv, /* LOS */
			normthickness*unitconv,	  /* normal thickness */
			pp->pt_forw == pt_headp ?
				EXIT_AIR : pp->pt_forw->pt_regionp->reg_aircode,
			regp->reg_regionid,
			cosobliquity
			) < 0
		)
		{
		bu_semaphore_release( BU_SEM_SYSCALL );	/* unlock */
		brst_log( "Write failed to file (%s)!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	bu_semaphore_release( BU_SEM_SYSCALL );	/* unlock */
	}

/*
	fastf_t getNormThickness( struct application *ap, struct partition *pp,
				fastf_t cosobliquity, fastf_t normvec[3] )

	Given a partition structure with entry hit point and a private copy
	of the associated normal vector, the current application structure
	and the cosine of the obliquity at entry to the component, return
	the normal thickness through the component at the given hit point.

 */
static fastf_t
getNormThickness( ap, pp, cosobliquity, normvec )
register struct application *ap;
register struct partition *pp;
fastf_t cosobliquity;
fastf_t normvec[3];
	{
#ifdef VDEBUG
	brst_log( "getNormThickness() pp 0x%x normal %g,%g,%g\n",
		pp, normvec[X], normvec[Y], normvec[Z] );
#endif
	if( AproxEq( cosobliquity, 1.0, COS_TOL ) )
		{ /* Trajectory was normal to surface, so no need
			to shoot another ray. */
			fastf_t	thickness = pp->pt_outhit->hit_dist -
					pp->pt_inhit->hit_dist;
#ifdef VDEBUG
		brst_log( "getNormThickness: using existing partitions.\n" );
		brst_log( "\tthickness=%g dout=%g din=%g normal=%g,%g,%g\n",
			thickness*unitconv,
			pp->pt_outhit->hit_dist, pp->pt_inhit->hit_dist,
			normvec[X], normvec[Y], normvec[Z] );
#endif
		return	thickness;
		}
	else
		{ /* need to shoot ray */
			struct application a_thick;
			register struct hit *ihitp = pp->pt_inhit;
			register struct region *regp = pp->pt_regionp;
		a_thick = *ap;
		a_thick.a_hit = f_Normal;
		a_thick.a_miss = f_Nerror;
		a_thick.a_level++;
		a_thick.a_user = regp->reg_regionid;
		a_thick.a_purpose = "normal thickness";
		CopyVec( a_thick.a_ray.r_pt, ihitp->hit_point );
		Scale2Vec( normvec, -1.0, a_thick.a_ray.r_dir );
		if( rt_shootray( &a_thick ) == -1 && fatalerror )
			{ /* Fatal error in application routine. */
			brst_log( "Fatal error: raytracing aborted.\n" );
			return	0.0;
			}
		return	a_thick.a_rbeam;
		}
	/*NOTREACHED*/
	}

void
prntDbgPartitions( ap, pt_headp, label )
struct application *ap;
struct partition *pt_headp;
char *label;
	{	struct partition *dpp;
	brst_log( "%s (0x%x)\n", label, pt_headp );
	if( ap != NULL )
		brst_log( "\tPnt %g,%g,%g Dir %g,%g,%g\n",
			ap->a_ray.r_pt[X],
			ap->a_ray.r_pt[Y],
			ap->a_ray.r_pt[Z],
			ap->a_ray.r_dir[X],
			ap->a_ray.r_dir[Y],
			ap->a_ray.r_dir[Z] );
	for( dpp = pt_headp->pt_forw; dpp != pt_headp; dpp = dpp->pt_forw )
		{
		brst_log( "\t0x%x: reg \"%s\" sols \"%s\",\"%s\" in %g out %g\n",
			dpp,
			dpp->pt_regionp->reg_name,
			dpp->pt_inseg->seg_stp->st_name,
			dpp->pt_outseg->seg_stp->st_name,
			dpp->pt_inhit->hit_dist,
			dpp->pt_outhit->hit_dist );
		brst_log( "\tinstp 0x%x outstp 0x%x inhit 0x%x outhit 0x%x\n",
			dpp->pt_inseg->seg_stp, dpp->pt_outseg->seg_stp,
			dpp->pt_inhit, dpp->pt_outhit );
		}
	brst_log( "--\n" );
	}

/*
	void prntShieldComp( struct application *ap, struct partition *pt_headp,
				Pt_Queue *qp )
 */
void
prntShieldComp( ap, pt_headp, qp )
struct application *ap;
struct partition *pt_headp;
register Pt_Queue *qp;
	{	fastf_t entrynorm[3], exitnorm[3];
	if( outfile[0] == NUL )
		return;
	if( qp == PT_Q_NULL )
		return;
	prntShieldComp( ap, pt_headp, qp->q_next );
	prntRegionHdr( ap, pt_headp, qp->q_part, entrynorm, exitnorm );
	}
void
prntColors( colorp, str )
register Colors	*colorp;
char	*str;
	{
	brst_log( "%s:\n", str );
	for(	colorp = colorp->c_next;
		colorp != COLORS_NULL;
		colorp = colorp->c_next )
		{
		brst_log( "\t%d..%d\t%d,%d,%d\n",
			(int)colorp->c_lower,
			(int)colorp->c_upper,
			(int)colorp->c_rgb[0],
			(int)colorp->c_rgb[1],
			(int)colorp->c_rgb[2]
			);
		}
	}

/*
	void prntFiringCoords( register fastf_t *vec )

	If the user has asked for grid coordinates to be saved, write
	them to the output stream 'gridfp'.
 */
void
prntFiringCoords( vec )
register fastf_t *vec;
	{
	if( gridfile[0] == '\0' )
		return;
	assert( gridfp != (FILE *) NULL );
	if( fprintf( gridfp, "%7.2f %7.2f\n", vec[X]*unitconv, vec[Y]*unitconv )
		< 0 )
		{
		brst_log( "Write failed to file (%s)!\n", gridfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	}

void
prntGridOffsets( x, y )
int	x, y;
	{
	if( ! tty )
		return;
	(void) ScMvCursor( GRID_X, GRID_Y );
	(void) printf( "[% 4d:% 4d,% 4d:% 4d]",
			x, gridxfin, y, gridyfin
			);
	(void) fflush( stdout );
	return;
	}

void
prntIdents( idp, str )
register Ids	*idp;
char	*str;
	{
	brst_log( "%s:\n", str );
	for( idp = idp->i_next ; idp != IDS_NULL; idp = idp->i_next )
		{
		if( idp->i_lower == idp->i_upper )
			brst_log( "\t%d\n", (int) idp->i_lower );
		else
			brst_log( "\t%d..%d\n",
				(int)idp->i_lower,
				(int)idp->i_upper
				);
		}
	return;
	}

/**/
void
prntPagedMenu( menu )
register char	**menu;
	{	register int	done = 0;
		int		lines =	(PROMPT_Y-SCROLL_TOP);
	if( ! tty )
		{
		for( ; *menu != NULL; menu++ )
			brst_log( "%s\n", *menu );
		return;
		}
	for( ; *menu != NULL && ! done;  )
		{
		for( ; lines > 0 && *menu != NULL; menu++, --lines )
			brst_log( "%-*s\n", co, *menu );
		if( *menu != NULL )
			done = ! doMore( &lines );
		prompt( "" );
		}
	(void) fflush( stdout );
	return;
	}

/*
	void prntPhantom( struct hit *hitp, int space, fastf_t los )

	Output "phantom armor" pseudo component.  This component has no
	surface normal or thickness, so many zero fields are used for
	conformity with the normal component output formats.
 */
/*ARGSUSED*/
void
prntPhantom( hitp, space, los )
struct hit *hitp;	/* ptr. to phantom's intersection information */
int space;		/* space code behind phantom */
fastf_t	los;		/* LOS of space */
	{
	if(	outfile[0] != NUL
	    &&	fprintf( outfp,
			"%c % 8.2f % 8.2f %4d %2d % 7.3f % 7.3f % 7.3f %c\n",
			PB_RAY_INTERSECT,
			(standoff-hitp->hit_dist)*unitconv,
				/* X'-coordinate of intersection */
			0.0,	/* LOS thickness of component */
			PHANTOM_ARMOR, /* component code number */
			space,	/* space code */
			0.0,	/* sine of fallback angle */
			0.0,	/* rotation angle (degrees) */
			0.0, /* cosine of obliquity angle at entry */
			'0'	/* no burst from phantom armor */
			) < 0
		)
		{
		brst_log( "Write failed to file!\n", outfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	if(	shotlnfile[0] != NUL
	    &&	fprintf( shotlnfp,
	       "%c % 8.2f % 7.3f % 7.3f %4d % 8.2f % 8.2f %2d % 7.2f % 7.2f\n",
			PS_SHOT_INTERSECT,
			(standoff-hitp->hit_dist)*unitconv,
					/* X'-coordinate of intersection */
			0.0,		/* sine of fallback angle */
			0.0,		/* rotation angle in degrees */
			PHANTOM_ARMOR,	/* component code number */
			0.0,		/* normal thickness of component */
			0.0,		/* LOS thickness of component */
			space,		/* space code */
			0.0,		/* entry obliquity angle in degrees */
			0.0		/* exit obliquity angle in degrees */
			) < 0
		)
		{
		brst_log( "Write failed to file (%s)!\n", shotlnfile );
		locPerror( "fprintf" );
		exitCleanly( 1 );
		}
	return;
	}
void
prntScr( const char *format, ... )
	{
		va_list	ap;

	va_start( ap, format );
	format  = va_arg( ap, char * );

	if( tty )
		{
		clr_Tabs( HmTtyFd );
		if( ScDL != NULL )
			{
			(void) ScMvCursor( 1, SCROLL_TOP );
			(void) ScDeleteLn();
			(void) ScMvCursor( 1, SCROLL_BTM );
			(void) ScClrEOL();
			(void) vprintf( format, ap );
			}
		else
		if( ScSetScrlReg( SCROLL_TOP, SCROLL_BTM+1 ) )
			{	char buf[LNBUFSZ];
			(void) ScMvCursor( 1, SCROLL_BTM+1 );
			(void) ScClrEOL();
			/* Work around for problem with vprintf(): it doesn't
				cause the screen to scroll, don't know why. */
			(void) vsnprintf( buf, LNBUFSZ, format, ap );
			(void) puts( buf );
			/*(void) vprintf( format, ap );*/
			(void) ScMvCursor( 1, SCROLL_BTM+1 );
			(void) ScClrScrlReg();
			}
		else
			{
			(void) vprintf( format, ap );
			(void) fputs( "\n", stdout );
			}
		(void) fflush( stdout );
		}
	else
		{
		(void) vfprintf( stderr, format, ap );
		(void) fputs( "\n", stderr );
		}
	va_end( ap );
	return;
	}


/*
	void	prntTimer( char *str )
 */
void
prntTimer( str )
char    *str;
	{
	(void) rt_read_timer( timer, TIMER_LEN-1 );
	if( tty )
		{
		(void) ScMvCursor( TIMER_X, TIMER_Y );
		if( str == NULL )
			(void) printf( "%s", timer );
		else
			(void) printf( "%s:\t%s", str, timer );
		(void) ScClrEOL();
		(void) fflush( stdout );
		}
	else
		brst_log( "%s:\t%s\n", str == NULL ? "(null)" : str, timer );
	}

void
prntTitle( title )
char	*title;
	{
	if( ! tty || RT_G_DEBUG )
		brst_log( "%s\n", title == NULL ? "(null)" : title );
	}

static char	*usage[] =
	{
	"Usage: burst [-b]",
	"\tThe -b option suppresses the screen display (for batch jobs).",
	NULL
	};
void
prntUsage()
	{	register char   **p = usage;
	while( *p != NULL )
		(void) fprintf( stderr, "%s\n", *p++ );
	}

void
prompt( str )
char    *str;
	{
	(void) ScMvCursor( PROMPT_X, PROMPT_Y );
	if( str == (char *) NULL )
		(void) ScClrEOL();
	else
		{
		(void) ScSetStandout();
		(void) fputs( str, stdout );
		(void) ScClrStandout();
		}
	(void) fflush( stdout );
	}

int
qAdd( pp, qpp )
struct partition	*pp;
Pt_Queue		**qpp;
	{	Pt_Queue	*newq;
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	if( (newq = (Pt_Queue *) malloc( sizeof(Pt_Queue) )) == PT_Q_NULL )
		{
		Malloc_Bomb( sizeof(Pt_Queue) );
		bu_semaphore_release( BU_SEM_SYSCALL );
		return	0;
		}
	bu_semaphore_release( BU_SEM_SYSCALL );
	newq->q_next = *qpp;
	newq->q_part = pp;
	*qpp = newq;
	return	1;
	}

void
qFree( qp )
Pt_Queue	*qp;
	{
	if( qp == PT_Q_NULL )
		return;
	qFree( qp->q_next );
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	free( (char *) qp );
	bu_semaphore_release( BU_SEM_SYSCALL );
	}

void
warning( str )
char	*str;
	{
	if( tty )
		HmError( str );
	else
		prntScr( str );
	}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@const format specifier
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.22 2007/12/03 22:57:58 brlcad Exp $ (BRL)";
a133 1
#ifdef HAVE_STRERROR
a134 3
#else
		brst_log( "%s: %s\n", msg, sys_errlist[errno] );
#endif
@


14.22
log
@c89 simplification.  assume stdarg is a given.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.21 2007/10/14 08:01:46 brlcad Exp $ (BRL)";
d869 1
a869 1
prntScr( char *format, ... )
@


14.21
log
@take care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.20 2007/07/26 01:13:50 brlcad Exp $ (BRL)";
a867 2
#if defined(HAVE_STDARG_H)
/* STDARG */
d872 1
a873 9
#else
/* VARARGS */
void
prntScr( va_alist )
va_dcl
	{	register char *format; /* picked up by va_arg() */
		va_list	ap;
	va_start( ap );
#endif
d875 1
@


14.20
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.19 2007/01/27 01:41:31 brlcad Exp $ (BRL)";
d172 1
a172 1
		(void) strcpy( p, str );
d903 1
a903 1
			(void) vsprintf( buf, format, ap );
@


14.19
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d22 2
a23 5
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
*/
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.18 2007/01/23 01:13:24 brlcad Exp $ (BRL)";
@


14.18
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.17 2007/01/20 14:36:42 brlcad Exp $ (BRL)";
d282 1
a282 1
			 	/* horizontal coordinate of burst point (Y') */
d284 1
a284 1
			 	/* vertical coordinate of burst point (Z') */
d331 1
a331 1
			 	/* horizontal coordinate of shotline (Y') */
d333 1
a333 1
			 	/* vertical coordinate of shotline (Z') */
d346 1
a346 1
			 	/* horizontal coordinate of shotline (Y') */
d348 1
a348 1
			 	/* vertical coordinate of shotline (Z') */
a928 1

@


14.17
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.16 2006/01/18 06:46:13 brlcad Exp $ (BRL)";
@


14.16
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.15 2005/11/04 20:27:11 brlcad Exp $ (BRL)";
@


14.15
log
@sys_errlist is defined as _sys_errlist in include/config_win.h so no need for the duplicated WIN32 sections
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.14 2005/11/04 14:50:57 brlcad Exp $ (BRL)";
@


14.14
log
@burst the non-ansi-yet-willing-to-pretend-we-are-c99 bubble that the burst code likes to use.  that is, use static instead of STATIC and don't clobber the bool/true/false reserved words of the c++ compilers.  clean up the headers to support this.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.13 2005/11/04 10:43:04 brlcad Exp $ (BRL)";
a140 3
#  ifdef _WIN32
		brst_log( "%s: %s\n", msg, _sys_errlist[errno] );
#  else
a141 1
#  endif
@


14.13
log
@DEBUG/NDEBUG cleanup, pull the value from and include common.h before system headers
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.12 2005/10/31 06:28:43 brlcad Exp $ (BRL)";
d59 1
a59 1
STATIC fastf_t getNormThickness();
d64 1
a64 1
	{	register int	ret = true;
d66 1
a66 1
		return	true;
d78 1
a78 1
		ret = false;
d92 1
a92 1
STATIC int
d110 1
a110 1
STATIC int
d162 1
a162 1
		return	false;
d199 1
a199 1
	return	true;
d367 1
a367 1
			bool burstflag )
d380 1
a380 1
bool burstflag; /* Was a burst generated by this partition? */
d545 1
a545 1
		(bool) pp->pt_inflip, entrynorm );
d555 1
a555 1
		(bool) pp->pt_outflip, exitnorm );
d624 1
a624 1
STATIC fastf_t
d799 1
a799 1
	{	register int	done = false;
@


14.12
log
@remove the deprecated Tc terminal capabilities routines/defines  that were converted to use libtermio -- just use libtermio directly now making the Tc routines officially obsoleted
@
text
@a27 1

d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.11 2005/10/23 04:44:29 brlcad Exp $ (BRL)";
a33 7
#ifndef DEBUG
#  define NDEBUG
#  define STATIC static
#else
#  define STATIC
#endif

a34 1

@


14.11
log
@trailing ws
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.10 2005/07/26 04:40:53 brlcad Exp $ (BRL)";
d76 3
a78 3
	TcSaveTty( HmTtyFd );
	TcSetRaw( HmTtyFd );
	TcClrEcho( HmTtyFd );
d97 1
a97 1
	TcResetTty( HmTtyFd );
d904 1
a904 1
		TcClrTabs( HmTtyFd );
@


14.10
log
@make sure to include the errno.h header before any usage of the errno global just in case so bad things don't happen (like on fedora core)
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.9 2005/05/28 02:14:49 brlcad Exp $ (BRL)";
d495 1
a495 1
	
d598 1
a598 1
	
d658 1
a658 1
	else     
d666 1
a666 1
		a_thick.a_level++;     
@


14.10.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d35 7
d43 1
d68 1
a68 1
static fastf_t getNormThickness();
d73 1
a73 1
	{	register int	ret = 1;
d75 4
a78 4
		return	1;
	save_Tty( HmTtyFd );
	set_Raw( HmTtyFd );
	clr_Echo( HmTtyFd );
d87 1
a87 1
		ret = 0;
d97 1
a97 1
	reset_Tty( HmTtyFd );
d101 1
a101 1
static int
d119 1
a119 1
static int
d150 3
d154 1
d171 1
a171 1
		return	0;
d208 1
a208 1
	return	1;
d376 1
a376 1
			boolean burstflag )
d389 1
a389 1
boolean burstflag; /* Was a burst generated by this partition? */
d495 1
a495 1

d554 1
a554 1
		(boolean) pp->pt_inflip, entrynorm );
d564 1
a564 1
		(boolean) pp->pt_outflip, exitnorm );
d598 1
a598 1

d633 1
a633 1
static fastf_t
d658 1
a658 1
	else
d666 1
a666 1
		a_thick.a_level++;
d808 1
a808 1
	{	register int	done = 0;
d904 1
a904 1
		clr_Tabs( HmTtyFd );
@


14.9
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.8 2005/05/11 21:48:54 brlcad Exp $ (BRL)";
d49 1
a140 3
#include <errno.h>
/* These aren't defined in BSD errno.h.					*/
extern int	errno;
@


14.9.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.10 2005/07/26 04:40:53 brlcad Exp $ (BRL)";
a48 1
#include <errno.h>
d140 3
@


14.8
log
@avoid sys_nerr for solaris
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.7 2005/05/03 05:18:30 brlcad Exp $ (BRL)";
d152 1
a152 1
#  ifdef WIN32
@


14.7
log
@more config.h references converted to brlcad_config.h (or common.h where appropriate) that apparently slipped under the radar
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.6 2005/04/27 02:02:12 brlcad Exp $ (BRL)";
d148 1
a148 1
	if( errno > 0 && errno < sys_nerr )
@


14.6
log
@and sure enough, solaris sneaks back into the picture so it's time to refix the sys_errlist problem.  solaris wants strerror, win32 can use _sys_errlist.  these should eventually get refactored into some sort of libbu facility/macro some day.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.5 2005/03/28 16:47:37 brlcad Exp $ (BRL)";
d33 1
a33 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
d36 2
a37 2
#define NDEBUG
#define STATIC static
d39 1
a39 1
#define STATIC
a49 3
#include "common.h"


@


14.5
log
@make HAVE_SYS_ERRLIST_DECL go away.  there's a better way to check for it, so fix when solaris returns to the rotation (where it'll probably be a problem).  windows gets _sys_errlist from stdlib.h so make sure that's included too.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.4 2005/01/30 20:30:16 brlcad Exp $ (BRL)";
d154 6
d161 2
@


14.4
log
@update copyright to 2005
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/burst/prnt.c,v 14.3 2004/12/18 06:50:49 morrison Exp $ (BRL)";
d46 1
a147 4
#if !HAVE_SYS_ERRLIST_DECL
extern int	sys_nerr;
extern char	*sys_errlist[];
#endif
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/prnt.c,v 14.2 2004/12/18 01:52:36 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file prnt.c
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/prnt.c,v 14.1 2004/11/16 19:42:12 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/prnt.c,v 1.3 2004/09/24 15:07:35 erikg Exp $ (BRL)";
@


1.3
log
@use config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/prnt.c,v 1.2 2004/08/02 23:01:47 morrison Exp $ (BRL)";
d1024 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d7 1
d9 5
a13 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/burst/prnt.c,v 1.1 2004/05/20 15:18:44 morrison Exp $ (BRL)";
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d8 1
a8 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/burst/prnt.c,v 1.31 2004/05/10 15:30:41 erikg Exp $ (BRL)";
d25 1
a25 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

