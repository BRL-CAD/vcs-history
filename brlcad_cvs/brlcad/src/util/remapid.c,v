head	14.28;
access;
symbols
	rel-7-10-4:14.19
	STABLE:14.19.0.2
	rel-7-10-2:14.19
	rel-7-10-0:14.17
	rel-7-8-4:14.14
	rel-7-8-2:14.14
	rel-7-8-0:14.13
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.6
	rel-7-6-0:14.8
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.4
	bobWinPort:14.8.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.28
date	2007.12.09.00.49.02;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.12.03.22.57.58;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.12.02.22.34.25;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.11.21.20.49.14;	author erikgreenwald;	state Exp;
branches;
next	14.24;

14.24
date	2007.11.21.20.38.24;	author erikgreenwald;	state Exp;
branches;
next	14.23;

14.23
date	2007.11.21.18.55.37;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.11.21.15.29.35;	author erikgreenwald;	state Exp;
branches;
next	14.21;

14.21
date	2007.09.15.16.23.23;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.09.14.20.06.50;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.05.22.18.44.36;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.14.23.16.38;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.27.01.41.55;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.57;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.37.07;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.06.04.14.01.39;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.02.27.10.08.41;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.24.05.00.26;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.28;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.39;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.09.21.19.05.37;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.07.07.06.10.07;	author brlcad;	state Exp;
branches
	14.8.6.1;
next	14.7;

14.7
date	2005.06.30.00.08.37;	author erikgreenwald;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.31.34;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.32.32;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.58.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.44.34;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.45.41;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.32;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.14.19.19.29;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.53;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.47;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.21.59;	author morrison;	state Exp;
branches;
next	;

14.8.6.1
date	2005.11.13.13.46.21;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.28
log
@looks like the libbu/file.c functions were just dumped into here.  rename the functions to not look like they're still bu_ functions.  ugly hacked file.  no donut for pjt.
@
text
@/*                       R E M A P I D . C
 * BRL-CAD
 *
 * Copyright (c) 1997-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file remapid.c
 *
 *	Perform batch modifications of region IDs for BRL-CAD
 *	(or TANKILL) geometry
 *
 *	The program reads a .g (or TANKILL) file and a spec file
 *	indicating which region IDs to change to which new values.
 *	For a .g file, the specified changes are made to that file;
 *	For a TANKILL file, a modified model is written to stdout.
 *
 *  Author -
 *	Paul J. Tanenbaum
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db.h"
#include "raytrace.h"


/*
 *	General I/O for ASCII files: remapid_file support
 */
struct remapid_file  {
	long		file_magic;
	FILE		*file_ptr;	/* the actual file */
	char		*file_name;
	struct bu_vls	file_buf;	/* contents of current line */
	char		*file_bp;	/* pointer into current line */
	int		file_needline;	/* time to grab another line? */
	int		file_linenm;
	int		file_comment;	/* the comment character */
	int		file_buflen;	/* length of intact buffer */
};
typedef struct remapid_file		REMAPID_FILE;
#define REMAPID_FILE_MAGIC		0x6275666c
#define BU_CK_FILE(_fp)		BU_CKMAG(_fp, REMAPID_FILE_MAGIC, "remapid_file")

#define bu_stdin		(&bu_iob[0])
extern REMAPID_FILE			bu_iob[1];
#define REMAPID_FILE_NO_COMMENT	-1


/*
 *	XXX - The following initialization of bu_stdin is essentially
 *	an inline version of remapid_fopen() and bu_vls_init().  As
 *	such, it depends heavily on the definitions of struct
 *	remapid_file and struct bu_vls in ../h/bu.h
 */
char	dmy_eos = '\0';
REMAPID_FILE	bu_iob[1] = {
    {
	REMAPID_FILE_MAGIC,
#if 0
	stdin,		/* this won't work on Linux, others */
#else
	NULL,
#endif
	"stdin",
	{
	    BU_VLS_MAGIC, (char *) 0, 0, 0, 0
	},
	&dmy_eos, 1, 0, '#', -1
    }
};


REMAPID_FILE *remapid_fopen (register char *fname, register char *type)
{
    REMAPID_FILE	*bfp;
    FILE	*fp;

    if ((fp = fopen(fname, type)) == NULL)
	return (NULL);

    bfp = (REMAPID_FILE *) bu_malloc(sizeof(REMAPID_FILE), "remapid_file struct");

    bfp->file_magic = REMAPID_FILE_MAGIC;
    bfp->file_ptr = fp;
    bfp->file_name = fname;
    bu_vls_init(&(bfp->file_buf));
    bfp->file_bp = bu_vls_addr(&(bfp->file_buf));
    bfp->file_needline = 1;
    bfp->file_linenm = 0;
    bfp->file_comment = '#';
    bfp->file_buflen = -1;

    return (bfp);
}

/*
 *	Close the file and free the associated memory
 */
int
remapid_fclose (register REMAPID_FILE *bfp)
{
    int	close_status;

    BU_CK_FILE(bfp);

    close_status = fclose(bfp->file_ptr);

    if (bfp != bu_stdin)
    {
	bfp->file_magic = 0;
	bfp->file_ptr = NULL;
	bfp->file_name = (char *) 0;
	bfp->file_bp = (char *) 0;
	bu_vls_free(&(bfp->file_buf));
	bu_free((genptr_t) bfp, "remapid_file struct");
    }
    return (close_status);
}


int
remapid_fgetc (register REMAPID_FILE *bfp)
{
    char	*cp = (char *)NULL;
    int		comment_char;	/* The comment character */
    int		strip_comments;	/* Should I strip comments? */

    BU_CK_FILE(bfp);

    strip_comments = isprint(comment_char = bfp->file_comment);

    /*
     *	If buffer is empty, note that it's time for a new line of input
     */
    if ((*(bfp->file_bp) == '\0') && ! (bfp->file_needline))
    {
	bfp->file_needline = 1;
	return ('\n');
    }

    /*
     *    If it's time to grab a line of input from the file, do so.
     */
    while (bfp->file_needline)
    {
	bu_vls_trunc(&(bfp->file_buf), 0);
	if (bu_vls_gets(&(bfp->file_buf), bfp->file_ptr) == -1)
	    return (EOF);
	bfp->file_bp = bu_vls_addr(&(bfp->file_buf));
	++(bfp->file_linenm);
	if (bu_vls_strlen(&(bfp->file_buf)) == 0)
	    continue;

	if (strip_comments)
	{
	    bfp->file_buflen = -1;
	    for (cp = bfp->file_bp; *cp != '\0'; ++cp)
		if (*cp == comment_char)
		{
		    bfp->file_buflen = (bfp->file_buf).vls_len;
		    bu_vls_trunc(&(bfp->file_buf), cp - bfp->file_bp);
		    break;
		}
	}
	if (cp == bfp->file_bp)
	    return ('\n');
	bfp->file_needline = 0;
    }

    return (*(bfp->file_bp)++);
}

/*
 *	Diagnostic routine to print out the contents of a struct remapid_file
 */
static void
remapid_printfile (register REMAPID_FILE *bfp)
{
    BU_CK_FILE(bfp);

    bu_log("File     '%s'...\n", bfp->file_name);
    bu_log("  ptr      %x\n", bfp->file_ptr);
    bu_log("  buf      '%s'\n", bu_vls_addr(&(bfp->file_buf)));
    bu_log("  bp       %d", bfp->file_bp - bu_vls_addr(&(bfp->file_buf)));
    bu_log(": '%c' (%03o)\n", *(bfp->file_bp), *(bfp->file_bp));
    bu_log("  needline %d\n", bfp->file_needline);
    bu_log("  linenm   %d\n", bfp->file_linenm);
    bu_log("  comment  '%c' (%d)\n",
	bfp->file_comment, bfp->file_comment);
    bu_log("  buflen   %d\n", bfp->file_buflen);
}

/*
 *	Print out a syntax error message about a REMAPID_FILE
 */
void
remapid_file_err (register REMAPID_FILE *bfp, register char *text1, register char *text2, register int cursor_pos)
{
    char		*cp;
    int			buflen;
    int			i;
    int			stripped_length;

    BU_CK_FILE(bfp);

    /*
     *	Show any trailing comments
     */
    if ((buflen = bfp->file_buflen) > -1)
    {
	stripped_length = (bfp->file_buf).vls_len;
	*(bu_vls_addr(&(bfp->file_buf)) + stripped_length) =
	    bfp->file_comment;
	(bfp->file_buf).vls_len = buflen;
    }
    else
	stripped_length = -1;

    /*
     *	Print out the first line of the error message
     */
    if (text1 && (*text1 != '\0'))
	bu_log("%s: ", text1);
    bu_log("Error: file %s, line %d: %s\n",
	bfp->file_name, bfp->file_linenm, text2);
    bu_log("%s\n", bu_vls_addr(&(bfp->file_buf)));

    /*
     *	Print out position-indicating arrow, if requested
     */
    if ((cursor_pos >= 0)
     && (cursor_pos < bu_vls_strlen(&(bfp->file_buf))))
    {
	cp = bu_vls_addr(&(bfp->file_buf));
	for (i = 0; i < cursor_pos; ++i)
	    if (*cp++ == '\t')
		bu_log("\t");
	    else
		bu_log("-");
	bu_log("^\n");
    }

    /*
     *	Hide the comments again
     */
    if (stripped_length > -1)
	bu_vls_trunc(&(bfp->file_buf), stripped_length);
}

/*
 * ******************** Hack
 */


bu_rb_tree		*assignment;	/* Remapping assignment */
struct db_i	*dbip;		/* Instance of BRL-CAD database */


/************************************************************************
 *									*
 *			The Algorithm					*
 *									*
 *									*
 *  The remapping assignment is read from a specification file		*
 *  containing commands, the grammar for which looks something like:	*
 *									*
 *	 command --> id_list ':' id					*
 *	 id_list --> id_block | id_block ',' id_list			*
 *	id_block --> id | id '-' id					*
 *	   id    --> [0-9]+						*
 *									*
 *  The semantics of a command is:  For every region in the database	*
 *  whose region ID appears in the id_list before the ':', change its	*
 *  region ID to the value appearing after the ':'.			*
 *									*
 *  Consider all the (current) region IDs in the id_list of any		*
 *  command.  For each one, the corresponding curr_id structure is	*
 *  looked up in the red-black tree (and created, if necessary).	*
 *  As they're found, the curr_id's are stored in a list, so that	*
 *  when their new ID is found at the end of the command, it can be	*
 *  recorded in each of them.  All this processing of the specification	*
 *  file is performed by the function read_spec().			*
 *									*
 *  After the specification file has been processed, we read through	*
 *  the entire database, find every region and its (current) region ID,	*
 *  and add the region to the list of regions currently sharing that	*
 *  ID.  This is done by the function db_init().			*
 *									*
 *  At that point, it's a simple matter for main() to perform an	*
 *  inorder traversal of the red-black tree, writing to the database	*
 *  all the new region IDs.						*
 *									*
 *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  *
 *									*
 *			The Data Structures				*
 *									*
 *  assignment points to the red-black tree of curr_id structures,	*
 *  each of which records a region ID and all the regions in the	*
 *  database that currently sport that ID, in a remap_reg structure	*
 *  per region).							*
 *									*
 *									*
 *				        +-+				*
 *	       bu_rb_tree		        | |				*
 *				        +-+				*
 *				       /   \				*
 *				   +-+/     \+-+			*
 *				   | |       | |			*
 *				   +-+       +-+			*
 *				   / \       / \			*
 *				 +-+ +-+   +-+ +-+			*
 *	  curr_id structures	 | | | |   | | | |			*
 *	  			 +-+ +-+   +-+ +-+			*
 *				  |					*
 *				  | ...					*
 *				  |					*
 *	 			+---+   +---+   +---+   +---+		*
 *	 remap_reg structures	|   |-->|   |-->|   |-->|   |--+	*
 *				+---+   +---+   +---+   +---+  |	*
 *				  ^                            |	*
 *				  |                            |	*
 *				  +----------------------------+	*
 *									*
 ************************************************************************/

struct curr_id
{
    struct bu_list	l;
    int			ci_id;		/* The region ID */
    struct bu_list	ci_regions;	/* Regions now holding this ID */
    int			ci_newid;	/* Replacement ID for the regions */
};
#define	ci_magic	l.magic
#define	CURR_ID_NULL	((struct curr_id *) 0)
#define	CURR_ID_MAGIC	0x63726964

struct remap_reg
{
    struct bu_list		l;
    char			*rr_name;
    struct directory		*rr_dp;
    struct rt_db_internal	*rr_ip;
};
#define	rr_magic	l.magic
#define	REMAP_REG_NULL	((struct remap_reg *) 0)
#define	REMAP_REG_MAGIC	0x726d7267

static int		debug = 0;

/************************************************************************
 *									*
 *	  Helper routines for manipulating the data structures		*
 *									*
 ************************************************************************/

/*
 *			     M K _ C U R R _ I D ( )
 *
 */
struct curr_id *mk_curr_id (int region_id)
{
    struct curr_id	*cip;

    cip = (struct curr_id *) bu_malloc(sizeof(struct curr_id), "curr_id");

    cip->ci_magic = CURR_ID_MAGIC;
    cip->ci_id = region_id;
    BU_LIST_INIT(&(cip->ci_regions));
    cip->ci_newid = region_id;

    return (cip);
}

/*
 *			  P R I N T _ C U R R _ I D ( )
 *
 */
void print_curr_id (void *v, int depth)
{
    struct curr_id	*cip = (struct curr_id *) v;
    struct remap_reg	*rp;

    BU_CKMAG(cip, CURR_ID_MAGIC, "curr_id");

    bu_log(" curr_id <x%x> %d %d...\n",
	cip, cip->ci_id, cip->ci_newid);
    for (BU_LIST_FOR(rp, remap_reg, &(cip->ci_regions)))
    {
	BU_CKMAG(rp, REMAP_REG_MAGIC, "remap_reg");

	bu_log("  %s\n", rp->rr_name);
    }
}

/*
 *		P R I N T _ N O N E M P T Y _ C U R R _ I D ( )
 *
 */
void print_nonempty_curr_id (void *v, int depth)
{
    struct curr_id	*cip = (struct curr_id *) v;
    struct remap_reg	*rp;

    BU_CKMAG(cip, CURR_ID_MAGIC, "curr_id");

    if (BU_LIST_NON_EMPTY(&(cip->ci_regions)))
    {
	bu_log(" curr_id <x%x> %d %d...\n",
	    cip, cip->ci_id, cip->ci_newid);
	for (BU_LIST_FOR(rp, remap_reg, &(cip->ci_regions)))
	{
	    BU_CKMAG(rp, REMAP_REG_MAGIC, "remap_reg");

	    bu_log("  %s\n", rp->rr_name);
	}
    }
}

/*
 *		F R E E _ C U R R _ I D ( )
 *
 */
void free_curr_id (struct curr_id *cip)
{
    BU_CKMAG(cip, CURR_ID_MAGIC, "curr_id");
    bu_free((genptr_t) cip, "curr_id");
}

/*
 *		L O O K U P _ C U R R _ I D ( )
 *
 *	Scrounge for a particular region in the red-black tree.
 *	If it's not found there, add it to the tree.  In either
 *	event, return a pointer to it.
 */
struct curr_id *lookup_curr_id(int region_id)
{
    int			rc;	/* Return code from bu_rb_insert() */
    struct curr_id	*qcip;	/* The query */
    struct curr_id	*cip;	/* Value to return */

    /*
     *	Prepare the query
     */
    qcip = mk_curr_id(region_id);

    /*
     *	Perform the query by attempting an insertion...
     *	If the query succeeds (i.e., the insertion fails!),
     *	then we have our curr_id.
     *	Otherwise, we must create a new curr_id.
     */
    switch (rc = bu_rb_insert(assignment, (void *) qcip))
    {
	case -1:
	    cip = (struct curr_id *) bu_rb_curr1(assignment);
	    free_curr_id(qcip);
	    break;
	case 0:
	    cip = qcip;
	    break;
	default:
	    bu_exit (1, "bu_rb_insert() returns %d:  This should not happen\n", rc);
    }

    return (cip);
}

/*
 *		M K _ R E M A P _ R E G ( )
 *
 */
struct remap_reg *mk_remap_reg (char *region_name)
{
    struct remap_reg	*rp;

    rp = (struct remap_reg *) bu_malloc(sizeof(struct remap_reg), "remap_reg");

    rp->rr_magic = REMAP_REG_MAGIC;

    rp->rr_name = (char *) bu_malloc(strlen(region_name) + 1, "region name");
    strncpy(rp->rr_name, region_name, strlen(region_name));

    rp->rr_dp = DIR_NULL;
    rp->rr_ip = (struct rt_db_internal *) 0;

    return (rp);
}

/*
 *		F R E E _ R E M A P _ R E G ( )
 *
 */
void free_remap_reg (struct remap_reg *rp)
{
    BU_CKMAG(rp, REMAP_REG_MAGIC, "remap_reg");
    bu_free((genptr_t) rp->rr_name, "region name");
    bu_free((genptr_t) rp->rr_ip, "rt_db_internal");
    bu_free((genptr_t) rp, "remap_reg");
}

/************************************************************************
 *									*
 *	  	The comparison callback for libredblack(3)		*
 *									*
 ************************************************************************/

/*
 *		C O M P A R E _ C U R R _ I D S ( )
 */
int compare_curr_ids (void *v1, void *v2)
{
    struct curr_id	*id1 = (struct curr_id *) v1;
    struct curr_id	*id2 = (struct curr_id *) v2;

    BU_CKMAG(id1, CURR_ID_MAGIC, "curr_id");
    BU_CKMAG(id2, CURR_ID_MAGIC, "curr_id");

    return (id1->ci_id  -  id2->ci_id);
}

/************************************************************************
 *									*
 *	  Routines for reading the specification file			*
 *									*
 ************************************************************************/

/*
 *			  R E A D _ I N T ( )
 */
int read_int (REMAPID_FILE *sfp, int *ch, int *n)


			/* The result */

{
    int	got_digit = 0;	/* Did we actually succeed in reading a number? */
    int	result;

    BU_CK_FILE(sfp);

    while (isspace(*ch))
	*ch = remapid_fgetc(sfp);

    for (result = 0; isdigit(*ch); *ch = remapid_fgetc(sfp))
    {
	got_digit = 1;
	result *= 10;
	result += *ch - '0';
    }

    if (got_digit)
    {
	*n = result;
	return (1);
    }
    else if (*ch == EOF)
	remapid_file_err(sfp, "remapid",
	    "Encountered EOF while expecting an integer", -1);
    else
	remapid_file_err(sfp, "remapid:read_int()",
	    "Encountered nondigit",
	(int)(    (sfp->file_bp) - bu_vls_addr(&(sfp->file_buf)) - 1));
    return (-1);
}

/*
 *			  R E A D _ B L O C K ( )
 */
int read_block (REMAPID_FILE *sfp, int *ch, int *n1, int *n2)
{
    BU_CK_FILE(sfp);

    if (read_int(sfp, ch, n1) != 1)
	return (-1);

    while (isspace(*ch))
	*ch = remapid_fgetc(sfp);
    switch (*ch)
    {
	case ',':
	case ':':
	    return (1);
	case '-':
	    *ch = remapid_fgetc(sfp);
	    if (read_int(sfp, ch, n2) != 1)
		return (-1);
	    else
		return (2);
	default:
	    remapid_file_err(sfp, "remapid:read_block()",
		"Syntax error",
	(int)(	(sfp->file_bp) - bu_vls_addr(&(sfp->file_buf)) - 1) );
	    return (-1);
    }
}

/*
 *			  R E A D _ S P E C ( )
 */
int read_spec (REMAPID_FILE *sfp, char *sf_name)
{
    int			ch;
    int			i;
    int			num1, num2;
    int			newid;
    struct bu_list	cids;
    struct curr_id	*cip;

    if ((sfp == NULL) && ((sfp = remapid_fopen(sf_name, "r")) == NULL))
	bu_exit (1, "Cannot open specification file '%s'\n", sf_name);
    BU_CK_FILE(sfp);

    BU_LIST_INIT(&cids);

    for ( ; ; )
    {
	/*
	 *  Read in guy(s) to be assigned a particular new regionid
	 */
	for ( ; ; )
	{
	    while (isspace(ch = remapid_fgetc(sfp)))
		;
	    if (ch == EOF)
		return (1);
	    switch (read_block(sfp, &ch, &num1, &num2))
	    {
		case 1:
		    cip = lookup_curr_id(num1);
		    BU_LIST_INSERT(&cids, &(cip->l));
		    break;
		case 2:
		    if (num1 >= num2)
		    {
			remapid_file_err(sfp, "remapid:read_spec()",
			    "Range out of order",
			(int)(    (sfp->file_bp) - bu_vls_addr(&(sfp->file_buf))
			    - 1) );
			bu_exit (-1, NULL);
		    }
		    for (i = num1; i <= num2; ++i)
		    {
			cip = lookup_curr_id(i);
			BU_LIST_INSERT(&cids, &(cip->l));
		    }
		    break;
		default:
		    return (-1);
	    }
	    while (isspace(ch))
		ch = remapid_fgetc(sfp);

	    switch (ch)
	    {
		case ',':
		    continue;
		case ':':
		    ch = remapid_fgetc(sfp);
		    if (read_int(sfp, &ch, &newid) != 1)
			return (-1);
		    break;
		default:
		    remapid_file_err(sfp, "remapid:read_spec()",
			"Syntax error",
			(int)((sfp->file_bp) - bu_vls_addr(&(sfp->file_buf))
			- 1) );
		    bu_exit (-1, NULL);
	    }
	    break;
	}

	/*
	 *	Tell each of these current regionids
	 *	about it's going to get the new regionid value
	 */
	while (BU_LIST_WHILE(cip, curr_id, &cids))
	{
	    cip->ci_newid = newid;
	    BU_LIST_DEQUEUE(&(cip->l));
	}
    }
}

/************************************************************************
 *									*
 *	  Routines for procesing the geometry databases			*
 *									*
 ************************************************************************/

void record_region (char *region_name, int region_id, struct directory *dp, struct rt_db_internal *ip)
{
    struct curr_id	*cip;
    struct remap_reg	*rp;

    cip = lookup_curr_id(region_id);
    rp = mk_remap_reg(region_name);
    rp->rr_dp = dp;
    rp->rr_ip = ip;
    BU_LIST_INSERT(&(cip->ci_regions), &(rp->l));
}

void db_init(char *db_name)
{
    struct directory		*dp;
    struct rt_comb_internal	*comb;
    struct rt_db_internal	*ip;

    if ((dbip = db_open(db_name, "r+w")) == DBI_NULL)
	bu_exit (1, "Cannot open database file '%s'\n", db_name);
    db_dirbuild(dbip);

    FOR_ALL_DIRECTORY_START(dp, dbip) {
	if (!(dp->d_flags & DIR_REGION))
	    continue;
	ip = (struct rt_db_internal *) bu_malloc(sizeof(struct rt_db_internal), "rt_db_internal");
	if (rt_db_get_internal(ip, dp, dbip, (fastf_t *) NULL, &rt_uniresource) < 0) {
	    bu_log("remapid: rt_db_get_internal(%s) failed.  ",
		   dp->d_namep);
	    bu_exit (1, "This shouldn't happen\n");
	}
	comb = (struct rt_comb_internal *) (ip->idb_ptr);
	RT_CK_COMB(comb);
	record_region(dp->d_namep, comb->region_id, dp, ip);
    } FOR_ALL_DIRECTORY_END;
}

/*
 *		W R I T E _ A S S I G N M E N T ( )
 *
 */
void write_assignment (void *v, int depth)
{
    int				region_id;
    struct curr_id		*cip = (struct curr_id *) v;
    struct remap_reg		*rp;
    struct rt_comb_internal	*comb;

    BU_CKMAG(cip, CURR_ID_MAGIC, "curr_id");

    if (BU_LIST_NON_EMPTY(&(cip->ci_regions)))
    {
	region_id = cip->ci_newid;
	for (BU_LIST_FOR(rp, remap_reg, &(cip->ci_regions)))
	{
	    BU_CKMAG(rp, REMAP_REG_MAGIC, "remap_reg");
	    RT_CK_DB_INTERNAL(rp->rr_ip);

	    comb = (struct rt_comb_internal *) rp->rr_ip->idb_ptr;
	    RT_CK_COMB(comb);
	    comb->region_id = region_id;
	    if (rt_db_put_internal(rp->rr_dp, dbip, rp->rr_ip, &rt_uniresource) < 0)
	    {
		bu_log("remapid: rt_db_put_internal(%s) failed.  ",
		    rp->rr_dp->d_namep);
		bu_exit (1, "This shouldn't happen\n");
	    }
	}
    }
}

static void
tankill_reassign(char *db_name)
{
	FILE *fd_in;
	int vertex_count, id, surr_code;
	struct curr_id *id_map, *cip;

	/* open TANKILL model */
	if( (fd_in=fopen( db_name, "r" )) == NULL )
	{
		bu_log( "Cannot open TANKILL database (%s)\n", db_name );
		perror( "remapid" );
		bu_exit( EXIT_FAILURE, "Cannot open TANKILL database\n" );
	}

	/* make a 'curr_id' structure to feed to bu_rb_search */
	cip = mk_curr_id( 0 );

	/* filter TANKILL model, changing ids as we go */
	while( fscanf( fd_in, "%d %d %d", &vertex_count, &id, &surr_code ) != EOF )
	{
		int coord_no=0;
		int in_space=1;
		int ch;

		cip->ci_id = id;
		id_map = (struct curr_id *)bu_rb_search( assignment, 0, (void *)cip );
		if( !id_map )
			printf( "%d %d %d", vertex_count, id, surr_code );
		else
			printf( "%d %d %d", vertex_count, id_map->ci_newid, surr_code );

		/* just copy the rest of the component */
		while( coord_no < 3*vertex_count || !in_space )
		{
			ch = fgetc( fd_in );
			if( ch == EOF && coord_no < 3*vertex_count )
			{
				bu_log( "Unexpected EOF while processing ident %d\n", id );
				bu_exit( EXIT_FAILURE, "Unexpected EOF\n" );
			}

			if( isspace( ch ) )
				in_space = 1;
			else if( in_space )
			{
				in_space = 0;
				coord_no++;
			}
			putchar( ch );
		}
	}
}

/************************************************************************
 *									*
 *	  	And finally... the main program				*
 *									*
 ************************************************************************/

/*
 *			   P R I N T _ U S A G E ( )
 */
void print_usage (void)
{
#define OPT_STRING	"gt?"

    bu_log("Usage: 'remapid [-{g|t}] {file.g|file.tankill} [spec_file]'\n\
	%sNote: The '-g' option modifies file.g in place\n\
	%sthe '-t' option writes a modified file.tankill to stdout\n",
	"  ", "        ");
}

/*
 *                                M A I N ( )
 */
int
main (int argc, char **argv)
{
    char		*db_name;	/* Name of database */
    char		*sf_name = NULL;	/* Name of spec file */
    REMAPID_FILE		*sfp = NULL;	/* Spec file */
    int			ch;		/* Command-line character */
    int			tankill = 0;	/* TANKILL format (vs. BRL-CAD)? */

    extern int	bu_optind;			/* index from bu_getopt(3C) */

    bu_stdin->file_ptr = stdin;		/* LINUX-required init */

    while ((ch = bu_getopt(argc, argv, OPT_STRING)) != EOF)
	switch (ch)
	{
	    case 'g':
		tankill = 0;
		break;
	    case 't':
		tankill = 1;
		break;
	    case '?':
	    default:
		print_usage();
		exit (ch != '?');
		return(0);
	}

    switch (argc - bu_optind)
    {
	case 1:
	    sf_name = "stdin";
	    sfp = bu_stdin;
	    /* Break intentionally missing */
	case 2:
	    break;
	default:
	    print_usage();
	    bu_exit (1, NULL);
    }

	rt_init_resource( &rt_uniresource, 0, NULL );

    /*
     *	Open database and specification file, as necessary
     */
    db_name = argv[bu_optind++];
    if (sfp == NULL)
	sf_name = argv[bu_optind];

    /*
     *	Initialize the assignment
     */
    assignment = bu_rb_create1("Remapping assignment", compare_curr_ids);
    bu_rb_uniq_on1(assignment);

    /*
     *	Read in the specification for the reassignment
     */
    read_spec (sfp, sf_name);

    /*
     *	Make the specified reassignment
     */
    if( tankill )
	tankill_reassign( db_name );
    else
    {
	db_init(db_name);

	if (debug)
	    bu_rb_walk1(assignment, print_nonempty_curr_id, INORDER);
	else
	    bu_rb_walk1(assignment, write_assignment, INORDER);
    }
    return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.27
log
@c89 simplification.  assume stdarg is a given.
@
text
@d43 1
d58 1
a58 1
 * ******************** Hack
d60 1
a60 10

BU_EXTERN(struct bu_file	*bu_fopen, (char *fname, char *type) );
BU_EXTERN(int			bu_fclose, (struct bu_file *bfp) );
BU_EXTERN(int			bu_fgetc, (struct bu_file *bfp) );
BU_EXTERN(void			bu_printfile, (struct bu_file *bfp) );

/*
 *	General I/O for ASCII files: bu_file support
 */
struct bu_file  {
d71 3
a73 3
typedef struct bu_file		BU_FILE;
#define BU_FILE_MAGIC		0x6275666c
#define BU_CK_FILE(_fp)		BU_CKMAG(_fp, BU_FILE_MAGIC, "bu_file")
d76 2
a77 2
extern BU_FILE			bu_iob[1];
#define BU_FILE_NO_COMMENT	-1
d81 4
a84 31
 *			F I L E . C
 *
 *  General I/O for ASCII files
 *
 *  Author -
 *	Paul Tanenbaum
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#include "common.h"

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdarg.h>

#include "machine.h"
#include "bu.h"

/*
 *		XXX	Warning!	XXX
 *
 *	The following initialization of bu_stdin is essentially
 *	an inline version of bu_fopen() and bu_vls_init().  As such,
 *	it depends heavily on the definitions of struct bu_file and
 *	struct bu_vls in ../h/bu.h
 *
 *		XXX			XXX
d87 1
a87 1
BU_FILE	bu_iob[1] = {
d89 1
a89 1
	BU_FILE_MAGIC,
d103 2
a104 5
/*
 *			B U _ F O P E N
 *
 */
BU_FILE *bu_fopen (register char *fname, register char *type)
d106 1
a106 1
    BU_FILE	*bfp;
d112 1
a112 1
    bfp = (BU_FILE *) bu_malloc(sizeof(BU_FILE), "bu_file struct");
d114 1
a114 1
    bfp->file_magic = BU_FILE_MAGIC;
a127 2
 *			B U _ F C L O S E
 *
d130 2
a131 1
int bu_fclose (register BU_FILE *bfp)
d146 1
a146 1
	bu_free((genptr_t) bfp, "bu_file struct");
d151 3
a153 5
/*
 *			B U _ F G E T C
 *
 */
int bu_fgetc (register BU_FILE *bfp)
d205 1
a205 3
 *			B U _ P R I N T F I L E
 *
 *	Diagnostic routine to print out the contents of a struct bu_file
d207 2
a208 1
void bu_printfile (register BU_FILE *bfp)
d225 1
a225 3
 *			B U _ F I L E _ E R R
 *
 *	Print out a syntax error message about a BU_FILE
d227 2
a228 1
void bu_file_err (register BU_FILE *bfp, register char *text1, register char *text2, register int cursor_pos)
d289 1
d562 1
a562 1
int read_int (BU_FILE *sfp, int *ch, int *n)
d574 1
a574 1
	*ch = bu_fgetc(sfp);
d576 1
a576 1
    for (result = 0; isdigit(*ch); *ch = bu_fgetc(sfp))
d589 1
a589 1
	bu_file_err(sfp, "remapid",
d592 1
a592 1
	bu_file_err(sfp, "remapid:read_int()",
d601 1
a601 1
int read_block (BU_FILE *sfp, int *ch, int *n1, int *n2)
d609 1
a609 1
	*ch = bu_fgetc(sfp);
d616 1
a616 1
	    *ch = bu_fgetc(sfp);
d622 1
a622 1
	    bu_file_err(sfp, "remapid:read_block()",
d632 1
a632 1
int read_spec (BU_FILE *sfp, char *sf_name)
d641 1
a641 1
    if ((sfp == NULL) && ((sfp = bu_fopen(sf_name, "r")) == NULL))
d654 1
a654 1
	    while (isspace(ch = bu_fgetc(sfp)))
d667 1
a667 1
			bu_file_err(sfp, "remapid:read_spec()",
d683 1
a683 1
		ch = bu_fgetc(sfp);
d690 1
a690 1
		    ch = bu_fgetc(sfp);
d695 1
a695 1
		    bu_file_err(sfp, "remapid:read_spec()",
d874 1
a874 1
    BU_FILE		*sfp = NULL;	/* Spec file */
@


14.26
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d106 1
a106 4

#if defined(HAVE_STDARG_H)
#  include <stdarg.h>
#endif
@


14.25
log
@pass bu_exit a NULL instead of an empty string
@
text
@d558 1
a558 1
    strcpy(rp->rr_name, region_name);
@


14.24
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d716 1
a716 1
			bu_exit (-1, "");
d744 1
a744 1
		    bu_exit (-1, "");
d953 1
a953 1
	    bu_exit (1, "");
@


14.23
log
@exit->bu_exit where applicable
@
text
@d539 1
a539 2
	    bu_log("bu_rb_insert() returns %d:  This should not happen\n", rc);
	    bu_exit (1, "");
d687 1
a687 4
    {
	bu_log("Cannot open specification file '%s'\n", sf_name);
	bu_exit (1, "");
    }
d786 1
a786 4
    {
	bu_log("Cannot open database file '%s'\n", db_name);
	bu_exit (1, "");
    }
d796 1
a796 2
	    bu_log("This shouldn't happen\n");
	    bu_exit (1, "");
d832 1
a832 2
		bu_log("This shouldn't happen\n");
		bu_exit (1, "");
@


14.22
log
@change bu_bomb to bu_exit when the sky isn't really falling
@
text
@d540 1
a540 1
	    exit (1);
d690 1
a690 1
	exit (1);
d720 1
a720 1
			exit (-1);
d748 1
a748 1
		    exit (-1);
d792 1
a792 1
	exit (1);
d804 1
a804 1
	    exit (1);
d841 1
a841 1
		exit (1);
d962 1
a962 1
	    exit (1);
@


14.21
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d859 1
a859 1
		bu_bomb( "Cannot open TANKILL database\n" );
d886 1
a886 1
				bu_bomb( "Unexpected EOF\n" );
@


14.20
log
@The c89 headers are all fair game since it's been a requirement since the move to ANSI c89 compliance.  So.. remove the HAVE_STDLIB_H checks and just use the header.  The headers <complex.h>, <fenv.h>, <inttypes.h>, <stdbool.h>, <stdint.h>, and <tgmath.h> were added with C99 and still need to be checked.  There are several other c89 headers that we could just use, though, that are still being checked.
@
text
@a36 3
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.19 2007/05/22 18:44:36 brlcad Exp $ (ARL)";
#endif
d43 1
a99 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.19 2007/05/22 18:44:36 brlcad Exp $ (BRL)";
d105 2
a106 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d108 1
a108 1
# include <stdarg.h>
@


14.19
log
@s/ -> /->/
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.18 2007/05/14 23:16:38 brlcad Exp $ (ARL)";
d102 1
a102 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.18 2007/05/14 23:16:38 brlcad Exp $ (BRL)";
d109 1
a109 1
#include <string.h>
d111 1
a111 1
#include <strings.h>
@


14.18
log
@redblack.h is no longer needed -- facilities are provided for by bu.h
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.17 2007/01/27 01:41:55 brlcad Exp $ (ARL)";
d102 1
a102 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.17 2007/01/27 01:41:55 brlcad Exp $ (BRL)";
d161 9
a169 9
    bfp -> file_magic = BU_FILE_MAGIC;
    bfp -> file_ptr = fp;
    bfp -> file_name = fname;
    bu_vls_init(&(bfp -> file_buf));
    bfp -> file_bp = bu_vls_addr(&(bfp -> file_buf));
    bfp -> file_needline = 1;
    bfp -> file_linenm = 0;
    bfp -> file_comment = '#';
    bfp -> file_buflen = -1;
d185 1
a185 1
    close_status = fclose(bfp -> file_ptr);
d189 5
a193 5
	bfp -> file_magic = 0;
	bfp -> file_ptr = NULL;
	bfp -> file_name = (char *) 0;
	bfp -> file_bp = (char *) 0;
	bu_vls_free(&(bfp -> file_buf));
d211 1
a211 1
    strip_comments = isprint(comment_char = bfp -> file_comment);
d216 1
a216 1
    if ((*(bfp -> file_bp) == '\0') && ! (bfp -> file_needline))
d218 1
a218 1
	bfp -> file_needline = 1;
d225 1
a225 1
    while (bfp -> file_needline)
d227 2
a228 2
	bu_vls_trunc(&(bfp -> file_buf), 0);
	if (bu_vls_gets(&(bfp -> file_buf), bfp -> file_ptr) == -1)
d230 3
a232 3
	bfp -> file_bp = bu_vls_addr(&(bfp -> file_buf));
	++(bfp -> file_linenm);
	if (bu_vls_strlen(&(bfp -> file_buf)) == 0)
d237 2
a238 2
	    bfp -> file_buflen = -1;
	    for (cp = bfp -> file_bp; *cp != '\0'; ++cp)
d241 2
a242 2
		    bfp -> file_buflen = (bfp -> file_buf).vls_len;
		    bu_vls_trunc(&(bfp -> file_buf), cp - bfp -> file_bp);
d246 1
a246 1
	if (cp == bfp -> file_bp)
d248 1
a248 1
	bfp -> file_needline = 0;
d251 1
a251 1
    return (*(bfp -> file_bp)++);
d263 7
a269 7
    bu_log("File     '%s'...\n", bfp -> file_name);
    bu_log("  ptr      %x\n", bfp -> file_ptr);
    bu_log("  buf      '%s'\n", bu_vls_addr(&(bfp -> file_buf)));
    bu_log("  bp       %d", bfp -> file_bp - bu_vls_addr(&(bfp -> file_buf)));
    bu_log(": '%c' (%03o)\n", *(bfp -> file_bp), *(bfp -> file_bp));
    bu_log("  needline %d\n", bfp -> file_needline);
    bu_log("  linenm   %d\n", bfp -> file_linenm);
d271 2
a272 2
	bfp -> file_comment, bfp -> file_comment);
    bu_log("  buflen   %d\n", bfp -> file_buflen);
d292 1
a292 1
    if ((buflen = bfp -> file_buflen) > -1)
d294 4
a297 4
	stripped_length = (bfp -> file_buf).vls_len;
	*(bu_vls_addr(&(bfp -> file_buf)) + stripped_length) =
	    bfp -> file_comment;
	(bfp -> file_buf).vls_len = buflen;
d308 2
a309 2
	bfp -> file_name, bfp -> file_linenm, text2);
    bu_log("%s\n", bu_vls_addr(&(bfp -> file_buf)));
d315 1
a315 1
     && (cursor_pos < bu_vls_strlen(&(bfp -> file_buf))))
d317 1
a317 1
	cp = bu_vls_addr(&(bfp -> file_buf));
d330 1
a330 1
	bu_vls_trunc(&(bfp -> file_buf), stripped_length);
d448 4
a451 4
    cip -> ci_magic = CURR_ID_MAGIC;
    cip -> ci_id = region_id;
    BU_LIST_INIT(&(cip -> ci_regions));
    cip -> ci_newid = region_id;
d468 2
a469 2
	cip, cip -> ci_id, cip -> ci_newid);
    for (BU_LIST_FOR(rp, remap_reg, &(cip -> ci_regions)))
d473 1
a473 1
	bu_log("  %s\n", rp -> rr_name);
d488 1
a488 1
    if (BU_LIST_NON_EMPTY(&(cip -> ci_regions)))
d491 2
a492 2
	    cip, cip -> ci_id, cip -> ci_newid);
	for (BU_LIST_FOR(rp, remap_reg, &(cip -> ci_regions)))
d496 1
a496 1
	    bu_log("  %s\n", rp -> rr_name);
d562 1
a562 1
    rp -> rr_magic = REMAP_REG_MAGIC;
d564 2
a565 2
    rp -> rr_name = (char *) bu_malloc(strlen(region_name) + 1, "region name");
    strcpy(rp -> rr_name, region_name);
d567 2
a568 2
    rp -> rr_dp = DIR_NULL;
    rp -> rr_ip = (struct rt_db_internal *) 0;
d580 2
a581 2
    bu_free((genptr_t) rp -> rr_name, "region name");
    bu_free((genptr_t) rp -> rr_ip, "rt_db_internal");
d602 1
a602 1
    return (id1 -> ci_id  -  id2 -> ci_id);
d646 1
a646 1
	(int)(    (sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf)) - 1));
d676 1
a676 1
	(int)(	(sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf)) - 1) );
d717 1
a717 1
		    BU_LIST_INSERT(&cids, &(cip -> l));
d724 1
a724 1
			(int)(    (sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf))
d731 1
a731 1
			BU_LIST_INSERT(&cids, &(cip -> l));
d752 1
a752 1
			(int)((sfp -> file_bp) - bu_vls_addr(&(sfp -> file_buf))
d765 2
a766 2
	    cip -> ci_newid = newid;
	    BU_LIST_DEQUEUE(&(cip -> l));
d784 3
a786 3
    rp -> rr_dp = dp;
    rp -> rr_ip = ip;
    BU_LIST_INSERT(&(cip -> ci_regions), &(rp -> l));
d803 1
a803 1
	if (!(dp -> d_flags & DIR_REGION))
d808 1
a808 1
		   dp -> d_namep);
d812 1
a812 1
	comb = (struct rt_comb_internal *) (ip -> idb_ptr);
d814 1
a814 1
	record_region(dp -> d_namep, comb -> region_id, dp, ip);
d831 1
a831 1
    if (BU_LIST_NON_EMPTY(&(cip -> ci_regions)))
d833 2
a834 2
	region_id = cip -> ci_newid;
	for (BU_LIST_FOR(rp, remap_reg, &(cip -> ci_regions)))
d837 1
a837 1
	    RT_CK_DB_INTERNAL(rp -> rr_ip);
d839 1
a839 1
	    comb = (struct rt_comb_internal *) rp -> rr_ip -> idb_ptr;
d841 2
a842 2
	    comb -> region_id = region_id;
	    if (rt_db_put_internal(rp -> rr_dp, dbip, rp -> rr_ip, &rt_uniresource) < 0)
d845 1
a845 1
		    rp -> rr_dp -> d_namep);
@


14.17
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.16 2007/01/23 01:13:57 brlcad Exp $ (ARL)";
a55 1
#include "redblack.h"
d102 1
a102 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.16 2007/01/23 01:13:57 brlcad Exp $ (BRL)";
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.15 2007/01/20 14:37:07 brlcad Exp $ (ARL)";
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.15 2007/01/20 14:37:07 brlcad Exp $ (BRL)";
d138 1
a138 1
    	NULL,
a338 2


d618 1
a618 2

   	   		/* The result */
@


14.15
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.14 2006/06/04 14:01:39 brlcad Exp $ (ARL)";
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.14 2006/06/04 14:01:39 brlcad Exp $ (BRL)";
@


14.14
log
@quell more warnings
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2006 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.13 2006/02/27 10:08:41 brlcad Exp $ (ARL)";
d104 1
a104 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.13 2006/02/27 10:08:41 brlcad Exp $ (BRL)";
@


14.13
log
@stdlib.h and exit()
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.12 2006/01/24 05:00:26 brlcad Exp $ (ARL)";
d104 1
a104 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.12 2006/01/24 05:00:26 brlcad Exp $ (BRL)";
a795 1
    int				i;
@


14.12
log
@convert iteration over the array of linked list of directory nodes to FOR_ALL_DIRECTORY_START/FOR_ALL_DIRECTORY_END instead
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.11 2006/01/18 06:46:28 brlcad Exp $ (ARL)";
d44 1
a46 1

d48 1
a48 1
# include <unistd.h>
d59 1
d104 1
a104 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.11 2006/01/18 06:46:28 brlcad Exp $ (BRL)";
@


14.11
log
@update copyright to 2006
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.10 2005/10/23 04:44:39 brlcad Exp $ (ARL)";
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.10 2005/10/23 04:44:39 brlcad Exp $ (BRL)";
d807 9
a815 17
    for (i = 0; i < RT_DBNHASH; ++i)
	for (dp = dbip -> dbi_Head[i]; dp != DIR_NULL; dp = dp -> d_forw)
	{
	    if (!(dp -> d_flags & DIR_REGION))
		continue;
	    ip = (struct rt_db_internal *)
		bu_malloc(sizeof(struct rt_db_internal), "rt_db_internal");
	    if (rt_db_get_internal(ip, dp, dbip, (fastf_t *) NULL, &rt_uniresource) < 0)
	    {
		bu_log("remapid: rt_db_get_internal(%s) failed.  ",
		    dp -> d_namep);
		bu_log("This shouldn't happen\n");
		exit (1);
	    }
	    comb = (struct rt_comb_internal *) (ip -> idb_ptr);
	    RT_CK_COMB(comb);
	    record_region(dp -> d_namep, comb -> region_id, dp, ip);
d817 4
@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1997-2005 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.9 2005/09/21 19:05:37 brlcad Exp $ (ARL)";
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.9 2005/09/21 19:05:37 brlcad Exp $ (BRL)";
@


14.9
log
@needs bu.h for bu_getopt
@
text
@d33 1
a33 1
 *  
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.8 2005/07/07 06:10:07 brlcad Exp $ (ARL)";
d60 1
a60 1
 * ******************** Hack 
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.8 2005/07/07 06:10:07 brlcad Exp $ (BRL)";
d251 1
a251 1
    
d335 1
a335 1
 * ******************** Hack 
d413 1
a413 1
    struct bu_list	l;		
d619 2
a620 2
       	     
   	    
d631 1
a631 1
    
@


14.8
log
@duplicate extern declarations of brlcad_path.c funcs
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.7 2005/06/30 00:08:37 erikgreenwald Exp $ (ARL)";
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.7 2005/06/30 00:08:37 erikgreenwald Exp $ (BRL)";
d947 1
a947 1
    extern int	optind;			/* index from getopt(3C) */
d951 1
a951 1
    while ((ch = getopt(argc, argv, OPT_STRING)) != EOF)
d967 1
a967 1
    switch (argc - optind)
d985 1
a985 1
    db_name = argv[optind++];
d987 1
a987 1
	sf_name = argv[optind];
@


14.8.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d33 1
a33 1
 *
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d60 1
a60 1
 * ******************** Hack
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header$ (BRL)";
d251 1
a251 1

d335 1
a335 1
 * ******************** Hack
d413 1
a413 1
    struct bu_list	l;
d619 2
a620 2


d631 1
a631 1

d947 1
a947 1
    extern int	bu_optind;			/* index from bu_getopt(3C) */
d951 1
a951 1
    while ((ch = bu_getopt(argc, argv, OPT_STRING)) != EOF)
d967 1
a967 1
    switch (argc - bu_optind)
d985 1
a985 1
    db_name = argv[bu_optind++];
d987 1
a987 1
	sf_name = argv[bu_optind];
@


14.7
log
@added missing includes
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.6 2005/01/30 20:31:34 brlcad Exp $ (ARL)";
a67 3
/* brlcad_path.c */
BU_EXTERN(int			bu_file_exists, (const char *path) );
BU_EXTERN(char			*bu_brlcad_path, (const char *rhs, int fail_quietly) );
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.6 2005/01/30 20:31:34 brlcad Exp $ (BRL)";
@


14.6
log
@update copyright to 2005
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.5 2004/12/21 07:32:32 morrison Exp $ (ARL)";
d46 5
d106 1
a106 1
static const char RCSrtstring[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/remapid.c,v 14.5 2004/12/21 07:32:32 morrison Exp $ (BRL)";
@


14.5
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2004 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 14.4 2004/12/21 06:58:44 morrison Exp $ (ARL)";
d101 1
a101 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 14.4 2004/12/21 06:58:44 morrison Exp $ (BRL)";
@


14.4
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 14.3 2004/12/21 06:44:34 morrison Exp $ (ARL)";
a99 2
 *  
 *
d101 1
a101 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 14.3 2004/12/21 06:44:34 morrison Exp $ (BRL)";
@


14.3
log
@remove the old distribution notice section
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 14.2 2004/12/21 03:45:41 butler Exp $ (ARL)";
a101 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d103 1
a103 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 14.2 2004/12/21 03:45:41 butler Exp $ (BRL)";
@


14.2
log
@GPL license changes
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 14.1 2004/11/16 19:42:32 morrison Exp $ (ARL)";
a100 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
d106 1
a106 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 14.1 2004/11/16 19:42:32 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			R E M A P I D . C
a36 9
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 1.4 2004/10/14 19:19:29 morrison Exp $ (ARL)";
d110 1
a110 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 1.4 2004/10/14 19:19:29 morrison Exp $ (BRL)";
@


1.4
log
@add an option to bu_brlcad_path to fail quietly, returning a NULL string instead of gobs of output and bu_bomb'ing
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 1.3 2004/08/02 23:01:53 morrison Exp $ (ARL)";
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 1.3 2004/08/02 23:01:53 morrison Exp $ (BRL)";
d1013 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 1.2 2004/06/08 22:04:47 morrison Exp $ (ARL)";
d55 1
a55 1
BU_EXTERN(char			*bu_brlcad_path, (const char *rhs) );
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/src/util/remapid.c,v 1.2 2004/06/08 22:04:47 morrison Exp $ (BRL)";
@


1.2
log
@obliterate externs.h
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d32 1
a32 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
d100 1
a100 1
static const char RCSrtstring[] = "@@(#)$Header$ (BRL)";
d102 1
a102 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/remapid.c,v 1.29 2004/05/10 15:30:51 erikg Exp $ (ARL)";
a35 1

a38 1
#include "externs.h"			/* for getopt() */
d102 1
a102 1
static const char RCSrtstring[] = "@@(#)$Header: /cvs/brlcad/util/remapid.c,v 1.29 2004/05/10 15:30:51 erikg Exp $ (BRL)";
a107 2


a119 1
#include "externs.h"
@

