head	14.16;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	rel-7-10-2:14.15
	rel-7-10-0:14.14
	rel-7-8-4:14.11
	rel-7-8-2:14.6
	rel-7-8-0:14.6
	trimnurbs-branch:14.6.0.2
	help:14.6
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.16
date	2007.09.15.16.23.23;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.07.26.01.13.59;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.53;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.55;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.37.05;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.07.11.13.55.42;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.07.10.19.06.23;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.07.10.01.25.39;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.07.09.18.25.32;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.07.09.10.10.29;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.18.06.46.27;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.39;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.06.30.00.08.37;	author erikgreenwald;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2005.01.30.20.31.33;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.45.40;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.32;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.53;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.44;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.21.44;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.20;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                      D U N N C O M M . C
 * BRL-CAD
 *
 * Copyright (c) 1986-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file dunncomm.c
 *
 *	Common routines needed for both dunncolor and dunnsnap
 *
 *  Author -
 *	Don Merritt
 *	August 1985
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.15 2007/07/26 01:13:59 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <sys/time.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef __NetBSD__
#  define USE_OLD_TTY
#  include <sys/ioctl_compat.h>
#endif
#if defined(__bsdi__)
#  include <sys/ioctl_compat.h>
#  define OCRNL   0000010
#endif

#include "machine.h"

/*
 *  This file will work IFF one of these three flags is set:
 *	HAVE_TERMIOS_H	use POSIX termios and tcsetattr() call with XOPEN flags
 *	BSD		use Version 7 / BSD sgttyb and TIOCSETP ioctl
 */

#ifdef HAVE_TERMIOS_H
#  include <termios.h>
static struct termios	tty;

#else	/* !defined(HAVE_TERMIOS_H) */

#  ifdef HAVE_SYS_IOCTL_H
#    include <sys/ioctl.h>
struct	sgttyb	tty;
#    define TCSETA	TIOCSETP
#    define TCGETA	TIOCGETP
#  endif

#  ifdef HAVE_TERMIO_H
#    include <termio.h>
struct	termio	tty;
#  endif

#endif /* _POSIX_SOURCE */

#ifndef OCRNL
#  define OCRNL 0x00000008
#endif

#ifndef TAB1
#  define TAB1 0x00000400
#endif

#ifndef TAB2
#  define TAB2 0x00000800
#endif

#ifndef	XTABS
#  define XTABS (TAB1 | TAB2)
#endif /* XTABS */

int fd;
char cmd;
unsigned char	status[4];
unsigned char	values[21];
fd_set	readfds;
int	polaroid = 0;		/* 0 = aux camera, 1 = Polaroid 8x10 */

void
unsnooze(int x)
{
	printf("\007dunnsnap: request timed out, aborting\n");
	exit(1);
}

/*
 *			D U N N O P E N
 */
void
dunnopen(void)
{

	/* open the camera device */

#ifdef HAVE_TERMIOS_H
	if( (fd = open("/dev/camera", O_RDWR | O_NONBLOCK)) < 0 )
#else
	if( (fd = open("/dev/camera", O_RDWR | O_NDELAY)) < 0 )
#endif
	{
		printf("\007dunnopen: can't open /dev/camera\n");
		close(fd);
		exit(10);
	}
#ifdef HAVE_TERMIOS_H
	if( tcgetattr( fd, &tty ) < 0 )
#else
	if( ioctl(fd, TCGETA, &tty) < 0)
#endif
	{
		printf("\007dunnopen: can't open /dev/camera\n");
		close(fd);
		exit(10);
	}

	/* set up the camera device */

#if defined(HAVE_SYS_IOCTL_H) || defined(HAVE_TERMIOS_H)
	tty.c_cflag = B9600 | CS8;	/* Character size = 8 bits */
	tty.c_cflag &= ~CSTOPB;		/* One stop bit */
	tty.c_cflag |= CREAD;		/* Enable the reader */
	tty.c_cflag &= ~PARENB;		/* Parity disable */
	tty.c_cflag &= ~HUPCL;		/* No hangup on close */
	tty.c_cflag |= CLOCAL;		/* Line has no modem control */

	tty.c_iflag &= ~(BRKINT|ICRNL|INLCR|IXON|IXANY|IXOFF);
	tty.c_iflag |= IGNBRK|IGNPAR;

	tty.c_oflag &= ~(OPOST|ONLCR|OCRNL);	/* Turn off all post-processing */
#  if defined(XTABS)
	tty.c_oflag |= XTABS;		/* output tab expansion ON */
#  endif
	tty.c_cc[VMIN] = 1;
	tty.c_cc[VTIME] = 0;

	tty.c_lflag &= ~ICANON;		/* Raw mode */
	tty.c_lflag &= ~ISIG;		/* Signals OFF */
	tty.c_lflag &= ~(ECHO|ECHOE|ECHOK);	/* Echo mode OFF */
#else
	tty.sg_ispeed = tty.sg_ospeed = B9600;
	tty.sg_flags = RAW | EVENP | ODDP | XTABS;
#endif

#if HAVE_TERMIOS_H
	if( tcsetattr( fd, TCSAFLUSH, &tty ) < 0 )
#else
	if( ioctl(fd, TCSETA, &tty) < 0 )
#endif
	{
		perror("/dev/camera");
		exit(20);
	}

	/* Be certain the FNDELAY is off */
	if( fcntl(fd, F_SETFL, 0) < 0 )  {
		perror("/dev/camera");
		exit(21);
	}

	/* Set up alarm clock catcher */
	(void)signal( SIGALRM, unsnooze );
}


/*
 *			G O O D S T A T U S
 *
 *	Checks the status of the Dunn camera and returns 1 for good status
 *	and 0 for bad status.
 *
 */
int
goodstatus(void)
{
	struct timeval waittime, *timeout;
	int readval;

	timeout = &waittime;
	timeout->tv_sec = 10;
	timeout->tv_usec = 0;

	cmd = ';';	/* status request cmd */
	write(fd, &cmd, 1);
	FD_ZERO(&readfds);
	FD_SET(fd, &readfds);
	select(fd+1, &readfds, (fd_set *)0, (fd_set *)0, timeout);
	if( FD_ISSET(fd, &readfds) ==0 ) {
		printf("\007dunnsnap: status request timed out\n");
		return(0);
	}

	readval = bu_mread(fd, status, 4);
	if (readval < 0) {
	    perror("READ ERROR");
	}
	alarm(0);

	if (status[0]&0x1)  printf("No vertical sync\n");
	if (status[0]&0x2)  printf("8x10 not ready\n");
	if (status[0]&0x4)  printf("Expose in wrong mode\n");
	if (status[0]&0x8)  printf("Aux camera out of film\n");
	if (status[1]&0x1)  printf("B/W mode\n");
	if (status[1]&0x2)  printf("Separate mode\n");
	if (status[2]&0x1)  printf("Y-smoothing off\n");

	if ((status[0]&0xf) == 0x0 &&
	    (status[1]&0x3) == 0x0 &&
	    (status[3]&0x7f)== '\r')
		return 1;	/* status is ok */

	printf("\007dunnsnap: status error from camera\n");
	printf("status[0]= 0x%x [1]= 0x%x [2]= 0x%x [3]= 0x%x\n",
		status[0]&0x7f,status[1]&0x7f,
		status[2]&0x7f,status[3]&0x7f);
	return 0;	/* status is bad or request timed out */
}

/*
 *			H A N G T E N
 *
 *	Provides a 10 millisecond delay when called
 *
 */
void
hangten(void)
{
	static struct timeval delaytime = { 0, 10000}; /* set timeout to 10mS*/

	select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &delaytime);
}

/*
 *			R E A D Y
 *
 *	Sends a ready test command to the Dunn camera and returns 1 if the
 *	camera is ready or 0 if the camera is not ready after waiting the
 *	number of seconds specified by the argument.
 *
 */
int
ready(int nsecs)
{
	register int i;

	struct timeval waittime, *timeout;
	timeout = &waittime;
	timeout->tv_sec = nsecs;
	timeout->tv_usec = 0;

	cmd = ':';	/* ready test command */
	write(fd, &cmd, 1);

	FD_ZERO(&readfds);
	FD_SET(fd, &readfds);
	select(fd+1, &readfds, (fd_set *)0, (fd_set *)0, timeout);
	if ( FD_ISSET(fd, &readfds) ) {
		return 0;	/* timeout after n secs */
	}
	status[0] = status[1] = '\0';
	/* This loop is needed to skip leading nulls in input stream */
	do {
		i = read(fd, &status[0], 1);
		if( i != 1 )  {
		    if (i < 0) {
			perror("dunnsnap READ ERROR");
		    } else {
			printf("dunnsnap: unexpected EOF\n");
		    }
		    return 0;
		}
	} while( status[0] == '\0' );

	i = read(fd, &status[1], 1);
	if (i != 1) {
	    if (i < 0) {
		perror("dunnsnap READ ERROR");
	    } else {
		printf("dunnsnap: unexpected EOF\n");
	    }
	    return 0;
	}

	if((status[0]&0x7f) == 'R' && (status[1]&0x7f) == '\r') {
	    /* camera is ready */
	    return 1;
	}

	/* camera is not ready */
	printf("dunnsnap/ready():  unexpected camera status 0%o 0%o\n", status[0]&0x7f, status[1]&0x7f);
	return 0;
}

/*
 *			G E T E X P O S U R E
 *
 *  Get and print the current exposure
 */
void
getexposure(char *title)
{
	struct timeval waittime;
	int readval;

	waittime.tv_sec = 20;
	waittime.tv_usec = 0;

	if(!ready(20)) {
		printf("dunncolor: (getexposure) camera not ready\n");
		exit(60);
	}

	if(polaroid)
		cmd = '<';	/* req 8x10 exposure values */
	else
		cmd = '=';	/* request AUX exposure values */
	write(fd, &cmd, 1);
	FD_ZERO(&readfds);
	FD_SET(fd, &readfds);
	select(fd+1, &readfds, (fd_set *)0, (fd_set *)0, &waittime);
	if( FD_ISSET(fd, &readfds) ) {
		printf("dunncolor:\007 %s request exposure value cmd: timed out\n", title);
		exit(40);
	}

	readval = bu_mread(fd, values, 20);
	if (readval < 0) {
	    perror("READ ERROR");
	}

	values[20] = '\0';
	printf("dunncolor: %s = %s\n", title, values);
}

/*
 *			D U N N S E N D
 *
 */
int
dunnsend(char color, int val)
{
	char digit;

	if(val < 0 || val > 255) {
		printf("dunncolor: bad value %d\n",val);
		return(-1);
	}

	if(!ready(5)) {
		printf("dunncolor: dunnsend(), camera not ready\n");
		return(-1);
	}

	if( polaroid )
		cmd = 'K';	/* set 8x10 exposure values */
	else
		cmd = 'L';	/* set AUX exposure values */
	write(fd, &cmd, 1);
	hangten();
	write(fd, &color, 1);
	hangten();
	digit = (val/100 + 0x30)&0x7f;
	write(fd, &digit, 1);
	hangten();
	val = val%100;
	digit = (val/10 + 0x30)&0x7f;
	write(fd, &digit, 1);
	hangten();
	digit = (val%10 + 0x30)&0x7f;
	write(fd, &digit,1);
	hangten();
	return(0);		/* OK */
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.14 2007/01/27 01:41:53 brlcad Exp $ (BRL)";
d39 2
a40 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
a44 2

#include <sys/time.h>
@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a27 4
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.13 2007/01/23 01:13:55 brlcad Exp $ (BRL)";
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.12 2007/01/20 14:37:05 brlcad Exp $ (BRL)";
d136 1
a136 1
	     	printf("\007dunnopen: can't open /dev/camera\n");
d146 1
a146 1
	     	printf("\007dunnopen: can't open /dev/camera\n");
@


14.12
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.11 2006/07/11 13:55:42 brlcad Exp $ (BRL)";
@


14.11
log
@tty.sg_* is not mixable with ioctl/termios so make it a #else
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2006 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.10 2006/07/10 19:06:23 brlcad Exp $ (BRL)";
@


14.10
log
@refactor away the old BSD block defines among other simple cleanup
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.9 2006/07/10 01:25:39 brlcad Exp $ (BRL)";
a153 3
	tty.sg_ispeed = tty.sg_ospeed = B9600;
	tty.sg_flags = RAW | EVENP | ODDP | XTABS;

d166 1
a166 1
#if defined(XTABS)
d168 1
a168 1
#endif
d175 3
@


14.9
log
@remove/rewrite a bunch of the old SYSV preprocessor symbol sections
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.8 2006/07/09 18:25:32 brlcad Exp $ (BRL)";
a153 1
#ifdef BSD
d156 1
a156 1
#endif
@


14.8
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.7 2006/07/09 10:10:29 brlcad Exp $ (BRL)";
d45 1
a45 1
#include <string.h>
d47 1
a47 1
#include <strings.h>
d51 1
a51 1
# include <unistd.h>
d56 2
a57 2
#	define USE_OLD_TTY
#	include <sys/ioctl_compat.h>
d60 2
a61 2
#	include <sys/ioctl_compat.h>
#	define OCRNL   0000010
a68 1
 *	SYSV		use SysV Rel3 termio and TCSETA ioctl
d72 1
a72 3
#if defined(HAVE_TERMIOS_H)
#  undef SYSV
#  undef BSD
d74 1
a74 2

	static struct termios	tty;
d78 1
a78 1
#  ifdef BSD
d80 1
a80 1
     struct	sgttyb	tty;
d83 1
a83 1
#  endif	/* BSD */
d85 4
a88 12
#  ifdef SYSV
#if 0
#	if !defined(__sparc) && !defined(CRAY)
		struct timeval {
			int	tv_sec;
			int	tv_usec;
	};
#	endif
#endif
#   include <termio.h>
    struct	termio	tty;
#  endif /* SYSV */
d93 1
a93 1
#define OCRNL 0x00000008
d97 1
a97 1
#define TAB1 0x00000400
d101 1
a101 1
#define TAB2 0x00000800
d105 1
a105 1
#	define	XTABS	(TAB1 | TAB2)
d158 1
a158 1
#if defined(SYSV) || defined(HAVE_TERMIOS_H)
@


14.7
log
@refactor the mread() calls to the new bu_mread() call.  the bu_mread() function doesn't call perror for you, so the caller may need to if they expected it before.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.6 2006/01/18 06:46:27 brlcad Exp $ (BRL)";
d313 6
a318 2
			printf("dunnsnap:  unexpected EOF %d\n", i);
			return(0);
a320 1
	(void)read(fd, &status[1], 1);
d322 18
a339 6
	if((status[0]&0x7f) == 'R' && (status[1]&0x7f) == '\r')
		return 1;	/* camera is ready */

	printf("dunnsnap/ready():  unexpected camera status 0%o 0%o\n",
		status[0]&0x7f, status[1]&0x7f);
	return 0;	/* camera is not ready */
@


14.6
log
@update copyright to 2006
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.5 2005/10/23 04:44:39 brlcad Exp $ (BRL)";
a212 27
/*
 *			M R E A D
 *
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because pipes
 * and network connections don't deliver data with the same
 * grouping as it is written with.
 */
static int
mread(int fd, register unsigned char *bufp, unsigned int n)
{
	register unsigned	count = 0;
	register int		nread;

	do {
		nread = read(fd, bufp, n-count);
		if(nread == -1)
			return(nread);
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}
d225 1
d241 4
a244 1
	(void)mread(fd, status, 4);
d336 1
d359 4
a362 1
	(void)mread(fd, values, 20);
@


14.5
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1986-2005 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.4 2005/06/30 00:08:37 erikgreenwald Exp $ (BRL)";
@


14.4
log
@added missing includes
@
text
@d28 1
a28 1
 *  
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.3 2005/01/30 20:31:33 brlcad Exp $ (BRL)";
d163 1
a163 1
	
d165 1
a165 1
	
d256 1
a256 1
	
d258 1
a258 1
	write(fd, &cmd, 1);	
d291 1
a291 1
 *			H A N G T E N 
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d163 1
a163 1

d165 1
a165 1

d256 1
a256 1

d258 1
a258 1
	write(fd, &cmd, 1);
d291 1
a291 1
 *			H A N G T E N
@


14.3
log
@update copyright to 2005
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/util/dunncomm.c,v 14.2 2004/12/21 03:45:40 butler Exp $ (BRL)";
d41 1
d50 4
@


14.2
log
@GPL license changes
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2004 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/dunncomm.c,v 14.1 2004/11/16 19:42:32 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			D U N N C O M M . C
a32 4
 *  
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/dunncomm.c,v 1.3 2004/08/02 23:01:53 morrison Exp $ (BRL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/util/dunncomm.c,v 1.2 2004/06/08 22:04:44 morrison Exp $ (BRL)";
d406 10
@


1.2
log
@obliterate externs.h
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/util/dunncomm.c,v 11.12 2004/05/10 15:30:50 erikg Exp $ (BRL)";
a26 2


a46 1
#include "externs.h"
@

