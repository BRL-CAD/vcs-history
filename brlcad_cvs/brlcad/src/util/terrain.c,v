head	14.16;
access;
symbols
	rel-7-10-4:14.14
	STABLE:14.14.0.2
	rel-7-10-2:14.14
	rel-7-10-0:14.14
	rel-7-8-4:14.10
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.6
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.6
	premerge-20051223-bobWinPort:14.6
	rel-7-6-6:14.6
	rel-7-6-4:14.6
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.16
date	2007.11.21.20.49.14;	author erikgreenwald;	state Exp;
branches;
next	14.15;

14.15
date	2007.11.21.18.55.37;	author erikgreenwald;	state Exp;
branches;
next	14.14;

14.14
date	2007.02.02.08.48.30;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.27.01.41.55;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.23.01.13.57;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.37.07;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.02.27.10.08.41;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.28.00.36.30;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.23.07.47.59;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.18.06.46.28;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.10.23.04.44.39;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.09.21.19.05.37;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.31.34;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.21.07.25.31;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.45.41;	author butler;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.32;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.21.59;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.21;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@pass bu_exit a NULL instead of an empty string
@
text
@/*                       T E R R A I N . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file terrain.c
 *
 */

/*	T E R R A I N . C --- generate pseudo-terrain
 *
 *	Options
 *	w	number of postings in X direction
 *	n	number of postings in Y direction
 *	s	number of postings in X,Y direction
 *	L	Noise Lacunarity
 *	H	Noise H value
 *	O	Noise Octaves
 *	S	Noise Scale
 *	V	Noise Vector scale (affine scale)
 *	D	Noise Delta
 *	f	noise function (f=fbm t=turb T=1.0-turb)
 *	c	toggle host-net conversion
 *	o	offset
 */
#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"


/* declarations to support use of bu_getopt() system call */
char *options = "w:n:s:L:H:O:S:V:D:f:co:v";
extern char *bu_optarg;
extern int bu_optind, bu_opterr, bu_getopt(int, char *const *, const char *);

int do_convert = 1;
char *progname = "(noname)";
unsigned xdim = 256;
unsigned ydim = 256;

double fbm_lacunarity = 2.1753974;		/* noise_lacunarity */
double fbm_h = 1.0;
double fbm_octaves = 7.0;
double fbm_size = 1.0;
vect_t fbm_vscale = {0.0125, 0.0125, 0.0125};
vect_t fbm_delta = {1000.0, 1000.0, 1000.0};
double fbm_offset = 1.0;
int quiet = 0;

int debug;

/* transform a point in integer X,Y,Z space to appropriate noise space */
static void
xform(point_t t, point_t pt)
{
	t[X] = fbm_delta[X] + pt[X] * fbm_vscale[X];
	t[Y] = fbm_delta[Y] + pt[Y] * fbm_vscale[Y];
	t[Z] = fbm_delta[Z] + pt[Z] * fbm_vscale[Z];
}

/*
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void
usage(char *s)
{
	if (s) (void)fputs(s, stderr);

	(void) fprintf(stderr, "Usage: %s [ flags ] > outfile]\nFlags:\n%s\n",
		       progname,
"\t-w #\t\tnumber of postings in X direction\n\
\t-n #\t\tnumber of postings in Y direction\n\
\t-s #\t\tnumber of postings in X,Y direction\n\
\t-L #\t\tNoise Lacunarity\n\
\t-H #\t\tNoise H value\n\
\t-O #\t\tNoise Octaves\n\
\t-S #\t\tNoise Scale\n\
\t-V #,#,#\tNoise Vector scale (affine scale)\n\
\t-D #,#,#\tNoise Delta\n\
\t-f func\t\tNoise function:\n\
\t\t\t\tf:fbm t:turb T:1.0-turb m:multi r:ridged");

	bu_exit (-1, NULL);
}


/***********************************************************************
 *
 *	func_fbm
 *
 *	Fractional Brownian motion noise
 */
void
func_fbm(unsigned short *buf)
{
	point_t pt;
	int x, y;
	vect_t t;
	double v;

	if (debug) bu_log("fbm\n");

	pt[Z] = 0.0;
	for (y=0 ; y < ydim ; y++) {
		pt[Y] = y;
		for (x=0  ; x < xdim ; x++) {
			pt[X] = x;

			xform(t, pt);
			v = bn_noise_fbm(t, fbm_h,fbm_lacunarity, fbm_octaves);
			if (v > 1.0 || v < -1.0)
				if (debug) bu_log("clamping noise value %g \n", v);
			v = v * 0.5 + 0.5;
			CLAMP(v, 0.0, 1.0);

			buf[y*xdim + x] = 1.0 + 65534.0 * v;
		}
	}
}
/***********************************************************************
 *
 *	func_turb
 *
 *	Turbulence noise
 */
void
func_turb(unsigned short *buf)
{
	point_t pt;
	int x, y;
	vect_t t;
	double v;

	if (debug) bu_log("turb\n");

	pt[Z] = 0.0;
	for (y=0 ; y < ydim ; y++) {
		pt[Y] = y;
		for (x=0  ; x < xdim ; x++) {
			pt[X] = x;

			xform(t, pt);

			v = bn_noise_turb(t, fbm_h,
					  fbm_lacunarity, fbm_octaves);

			if (v > 1.0 || v < 0.0)
				if (debug) bu_log("clamping noise value %g \n", v);
			CLAMP(v, 0.0, 1.0);
			buf[y*xdim + x] = 1.0 + 65534.0 * v;
		}
	}
}

/***********************************************************************
 *
 *	func_turb_up
 *
 *	Upside-down turbulence noise
 */
void
func_turb_up(short *buf)
{
	point_t pt;
	int x, y;
	vect_t t;
	double v;

	if (debug) bu_log("1.0 - turb\n");

	pt[Z] = 0.0;
	for (y=0 ; y < ydim ; y++) {
		pt[Y] = y;
		for (x=0  ; x < xdim ; x++) {
			pt[X] = x;

			xform(t, pt);

			v = bn_noise_turb(t, fbm_h,
					  fbm_lacunarity, fbm_octaves);
			CLAMP(v, 0.0, 1.0);
			v = 1.0 - v;

			if (v > 1.0 || v < 0.0)
				if (debug) bu_log("clamping noise value %g \n", v);
			buf[y*xdim + x] = 1 + 65535.0 * v;
		}
	}
}


/***********************************************************************
 *
 *	func_multi
 *
 *	Multi-fractal
 */
void
func_multi(short *buf)
{
	point_t pt;
	int x, y;
	vect_t t;
	double v;
	double min_V, max_V;

	if (debug) bu_log("multi\n");

	min_V = 10.0;
	max_V =  -10.0;

	pt[Z] = 0.0;
	for (y=0 ; y < ydim ; y++) {
		pt[Y] = y;
		for (x=0  ; x < xdim ; x++) {
			pt[X] = x;

			xform(t, pt);

			v = bn_noise_mf(t, fbm_h,
					fbm_lacunarity, fbm_octaves,
					fbm_offset);

			v -= .3;
			v *= 0.8;
			if (v < min_V) min_V = v;
			if (v > max_V) max_V = v;

			if (v > 1.0 || v < 0.0) {
				if (debug) bu_log("clamping noise value %g \n", v);
				CLAMP(v, 0.0, 1.0);
			}
			buf[y*xdim + x] = 1 + 65534000.0 * v;
		}
	}
	if (debug) bu_log("min_V: %g   max_V: %g\n", min_V, max_V);

}
/***********************************************************************
 *
 *	func_ridged
 *
 *	Ridged multi-fractal
 */
void
func_ridged(unsigned short *buf)
{
	point_t pt;
	int x, y;
	vect_t t;
	double v;
	double lo, hi;

	if (debug) bu_log("ridged\n");

	lo = 10.0;
	hi = -10.0;

	pt[Z] = 0.0;
	for (y=0 ; y < ydim ; y++) {
		pt[Y] = y;
		for (x=0  ; x < xdim ; x++) {
			pt[X] = x;

			xform(t, pt);

			v = bn_noise_ridged(t, fbm_h,
					  fbm_lacunarity, fbm_octaves,
					    fbm_offset);
			if (v < lo) lo = v;
			if (v > hi) hi = v;
			v *= 0.5;

			if (v > 1.0 || v < 0.0)
				if (debug) bu_log("clamping noise value %g \n", v);
			CLAMP(v, 0.0, 1.0);
			buf[y*xdim + x] = 1.0 + 65534.0 * v;
		}
	}
}

#define PSCALE(_p, _s) _p[0] *= _s; _p[1] *= _s; _p[2] *= _s
#define PCOPY(_d, _s) _d[0] = _s[0]; _d[1] = _s[1]; _d[2] = _s[2]
double
fiord(point_t point, double h, double lacunarity, double octaves, double offset)
{
	int i = 0;
	point_t pt;
	double weight, signal, freq, result;

	if (debug) bu_log("fiord\n");

	PCOPY(pt, point);
	freq = weight = .5;
	result = 0.0;

	do {
		signal = fabs(bn_noise_perlin(pt)) * pow(freq, -h);
		result += signal * weight;
		weight = result;
		freq *= lacunarity;
		PSCALE(pt, lacunarity);
	} while (++i < octaves);

	return result;
}

double
ice(point_t point, double h, double lacunarity, double octaves, double offset)
{
	int i = 0;
	point_t pt;
	double weight, signal, freq, result;
	static double lo = 10.0;
	static double hi = -10.0;

	if (debug) bu_log("ice\n");

	PCOPY(pt, point);
	freq =  1.0;
	weight = 1.0;
	result = 0.0;

	do {
		signal = fabs(bn_noise_perlin(pt)) * pow(freq, -h);

		if (signal < lo) {
			lo = signal;
			if (debug) bu_log("new low %g\n", lo);
		}
		if (signal > hi) {
			hi = signal;
			if (debug) bu_log("new high %g\n", hi);
		}

		result += signal * weight;
		weight -= result;
		freq *= lacunarity;
		PSCALE(pt, lacunarity);
	} while (++i < octaves);

	return 1.0 - result;
}

double
lunar2(point_t point, double h, double lacunarity, double octaves, double offset)
{
	int i = 0;
	point_t pt;
	double weight, signal, freq, result;
	static double lo = 10.0;
	static double hi = -10.0;

	if (debug) bu_log("lunar2\n");

	PCOPY(pt, point);
	freq =  1.0;
	weight = 1.0;
	result = 0.0;

	do {
		signal = fabs(bn_noise_perlin(pt));
		signal *= signal;

		if (signal < lo) {
			lo = signal;
			if (debug) bu_log("new low %g\n", lo);
		}
		if (signal > hi) {
			hi = signal;
			if (debug) bu_log("new high %g\n", hi);
		}

		result += signal * pow(freq, -h);
		weight -= signal;
		freq *= lacunarity;
		PSCALE(pt, lacunarity);
	} while (++i < octaves);

	return 1.0 - result;
}
/***********************************************************************
 * This one's got detail on the peaks
 */
double
land(point_t point, double h, double lacunarity, double octaves, double offset)
{
	int i = 0;
	point_t pt;
	double weight, signal, freq, result;

	if (debug) bu_log("land\n");

	PCOPY(pt, point);
	freq =  1.0;
	weight = 1.0;
	result = 0.0;

	do {
		signal = fabs(bn_noise_perlin(pt));
		signal *= weight;

		result += signal * pow(freq, -h);
		weight = 0.5 - result;
		CLAMP(weight, 0.0, 1.0);
		freq *= lacunarity;
		PSCALE(pt, lacunarity);
	} while (++i < octaves);


	return 1.0 - result;
}
/***********************************************************************
 * This one's got detail on the peaks and in the valleys, but not on the
 * slopes
 *
 */
double
lee(point_t point, double h, double lacunarity, double octaves, double offset)
{
	int i = 0;
	point_t pt;
	double weight, signal, freq, result;

	if (debug) bu_log("lee\n");

	PCOPY(pt, point);
	freq =  1.0;
	weight = 1.0;
	result = 0.0;

	do {
		signal = fabs(bn_noise_perlin(pt));
		signal *=  1.5 * weight;


		result += signal * pow(freq, -h);
		weight = .6 - result;
		freq *= lacunarity;
		PSCALE(pt, lacunarity);
	} while (++i < octaves);


	return 1.2 - result;
}

/***********************************************************************
 *
 *	func_lee
 *
 *	Ridged multi-fractal
 */
void
func_lee(unsigned short *buf)
{
	point_t pt;
	int x, y;
	vect_t t;
	double v;
	double lo, hi;

	if (debug) bu_log("func_lee\n");

	lo = 10.0;
	hi = -10.0;

	pt[Z] = 0.0;
	for (y=0 ; y < ydim ; y++) {
		pt[Y] = y;
		for (x=0  ; x < xdim ; x++) {
			pt[X] = x;

			xform(t, pt);

			v = lee(t, fbm_h,
					  fbm_lacunarity, fbm_octaves,
					    fbm_offset);
			if (v < lo) lo = v;
			if (v > hi) hi = v;
			v *= 0.5;

			if (v > 1.0 || v < 0.0)
				if (debug) bu_log("clamping noise value %g \n", v);
			CLAMP(v, 0.0, 1.0);
			buf[y*xdim + x] = 1.0 + 65534.0 * v;
		}
	}
	if (debug) bu_log("min: %g max: %g\n", lo, hi);
}


/***********************************************************************
 *
 *	func_lee
 *
 *	Ridged multi-fractal
 */
void
func_lunar(unsigned short *buf)
{
	point_t pt;
	int x, y;
	vect_t t;
	double v;
	double lo, hi;

	if (debug) bu_log("lee\n");

	lo = 10.0;
	hi = -10.0;

	pt[Z] = 0.0;
	for (y=0 ; y < ydim ; y++) {
		pt[Y] = y;
		for (x=0  ; x < xdim ; x++) {
			pt[X] = x;

			xform(t, pt);

			/*
1 fiord
2 lunar2
3 ice
4 land
5 lee

			*/
			v = fiord(t, fbm_h,
					  fbm_lacunarity, fbm_octaves,
					    fbm_offset);
			if (v < lo) lo = v;
			if (v > hi) hi = v;

			if (v > 1.0 || v < 0.0)
				if (debug) bu_log("clamping noise value %g \n", v);
			CLAMP(v, 0.0, 1.0);
			buf[y*xdim + x] = 1.0 + 65534.0 * v;
		}
	}
	if (debug) bu_log("min: %g max: %g\n", lo, hi);
}


/* function to call to generate the terrain.  Default noise pattern is fBm */
void (*terrain_func)() = func_fbm;

/*
 *	P A R S E _ A R G S --- Parse through command line flags
 */
int
parse_args(int ac, char **av)
{
	int  c;
	char *strrchr(const char *, int);
	double v;

	if (  ! (progname=strrchr(*av, '/'))  )
		progname = *av;
	else
		++progname;

	/* Turn off bu_getopt's error messages */
	bu_opterr = 0;

	/* get all the option flags from the command line */
	while ((c=bu_getopt(ac,av,options)) != EOF)
		switch (c) {
		case 'v': debug = !debug; break;
		case 'c': do_convert = !do_convert; break;
		case 'w': if ((c=atoi(bu_optarg)) > 0) xdim = c;
			break;
		case 'n': if ((c=atoi(bu_optarg)) > 0) ydim = c;
			break;
		case 'q' : quiet = !quiet; break;
		case 's': if ((c=atoi(bu_optarg)) > 0) xdim = ydim = c;
			break;
		case 'L': if ((v=atof(bu_optarg)) >  0.0) fbm_lacunarity = v;
			break;
		case 'H': if ((v=atof(bu_optarg)) >  0.0) fbm_h = v;
			break;
		case 'O': if ((v=atof(bu_optarg)) >  0.0) fbm_octaves = v;
			break;

		case 'S': if ((v=atof(bu_optarg)) >  0.0) { VSETALL(fbm_vscale, v); }
			break;

		case 'V': sscanf(bu_optarg, "%lg,%lg,%lg",
			       &fbm_vscale[0], &fbm_vscale[1], &fbm_vscale[2]);
			break;
		case 'D': sscanf(bu_optarg, "%lg,%lg,%lg",
			       &fbm_delta[0], &fbm_delta[1], &fbm_delta[2]);
			break;
		case 'o': fbm_offset = atof(bu_optarg);
			break;
		case 'f':
			switch (*bu_optarg) {
			case 'L': terrain_func = func_lunar;
				break;
			case 'l': terrain_func = func_lee;
				break;
			case 'f': terrain_func = func_fbm;
				break;
			case 't': terrain_func = func_turb;
				break;
			case 'T': terrain_func = func_turb_up;
				break;
			case 'm': terrain_func = func_multi;
				break;
			case 'r': terrain_func = func_ridged;
				break;
			default:
				fprintf(stderr,
					"Unknown noise terrain_function: \"%s\"\n",
					bu_optarg);
				bu_exit (-1, NULL);
				break;
			}
			break;
		case '?'	:
		case 'h'	:
		default		: usage("Bad or help flag specified\n"); break;
		}

	return(bu_optind);
}

/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments, then
 *	produce the noise field selected.  Write out binary in network order.
 */
int
main(int ac, char **av)
{
	int arg_count;
	unsigned short *buf;
	int in_cookie, out_cookie;
	int count;

	arg_count = parse_args(ac, av);

	if (arg_count+1 < ac) usage("Excess arguments on cmd line\n");

	if (isatty(fileno(stdout))) usage("Redirect standard output\n");

	if (arg_count < ac)
		fprintf(stderr, "Excess command line arguments ignored\n");

	count = xdim*ydim;
	buf = bu_malloc(sizeof(*buf) * count, "buf");

	if (! terrain_func) {
		if (debug) bu_log("terrain func not specified\n");
		return 10;
	}

	terrain_func(buf);

	if (do_convert) {
	/* make sure the output is going as network unsigned shorts */

		in_cookie = bu_cv_cookie("hus");

		out_cookie = bu_cv_cookie("nus");

		if (bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie) ) {
			if (debug) bu_log("converting to network order\n");
			bu_cv_w_cookie(buf, out_cookie, count*sizeof(*buf),
				       buf, in_cookie, count);
		}
	}

	fwrite(buf, sizeof(*buf), count, stdout);
	return 0;
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@exit->bu_exit where applicable
@
text
@d107 1
a107 1
	bu_exit (-1, "");
d639 1
a639 1
				bu_exit (-1, "");
@


14.14
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d107 1
a107 1
	exit(1);
d639 1
a639 1
				exit(-1);
@


14.13
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d58 1
a58 1
extern int bu_optind, opterr, bu_getopt(int, char *const *, const char *);
d587 1
a587 1
	opterr = 0;
@


14.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a215 1

@


14.11
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.10
log
@stdlib.h and exit()
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


14.9
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d41 3
d55 1
d681 1
a681 1
		exit(-1);
@


14.8
log
@libbu for allocations
@
text
@a41 1
#include <unistd.h>
d43 4
@


14.7
log
@update copyright to 2006
@
text
@d670 1
a670 5
	buf = malloc(sizeof(*buf) * count);
	if (! buf) {
		fprintf(stderr, "malloc error\n");
		exit(-1);
	}
@


14.6
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


14.5
log
@needs bu.h for bu_getopt
@
text
@d88 1
a88 1
		       progname, 
d162 1
a162 1
			v = bn_noise_turb(t, fbm_h, 
d197 1
a197 1
			v = bn_noise_turb(t, fbm_h, 
d239 1
a239 1
			v = bn_noise_mf(t, fbm_h, 
d286 2
a287 2
			v = bn_noise_ridged(t, fbm_h, 
					  fbm_lacunarity, fbm_octaves, 
d429 1
a429 1
	
d462 1
a462 1
	
d494 2
a495 2
			v = lee(t, fbm_h, 
					  fbm_lacunarity, fbm_octaves, 
d547 2
a548 2
			v = fiord(t, fbm_h, 
					  fbm_lacunarity, fbm_octaves, 
d562 1
a562 1
 
d631 1
a631 1
				fprintf(stderr, 
d659 1
a659 1
	 
d661 1
a661 1
	
d692 1
a692 1
			bu_cv_w_cookie(buf, out_cookie, count*sizeof(*buf), 
@


14.4
log
@update copyright to 2005
@
text
@d49 1
a49 1
/* declarations to support use of getopt() system call */
d51 2
a52 2
extern char *optarg;
extern int optind, opterr, getopt(int, char *const *, const char *);
d581 1
a581 1
	/* Turn off getopt's error messages */
d585 1
a585 1
	while ((c=getopt(ac,av,options)) != EOF)
d589 1
a589 1
		case 'w': if ((c=atoi(optarg)) > 0) xdim = c;
d591 1
a591 1
		case 'n': if ((c=atoi(optarg)) > 0) ydim = c;
d594 1
a594 1
		case 's': if ((c=atoi(optarg)) > 0) xdim = ydim = c;
d596 1
a596 1
		case 'L': if ((v=atof(optarg)) >  0.0) fbm_lacunarity = v;
d598 1
a598 1
		case 'H': if ((v=atof(optarg)) >  0.0) fbm_h = v;
d600 1
a600 1
		case 'O': if ((v=atof(optarg)) >  0.0) fbm_octaves = v;
d603 1
a603 1
		case 'S': if ((v=atof(optarg)) >  0.0) { VSETALL(fbm_vscale, v); }
d606 1
a606 1
		case 'V': sscanf(optarg, "%lg,%lg,%lg",
d609 1
a609 1
		case 'D': sscanf(optarg, "%lg,%lg,%lg",
d612 1
a612 1
		case 'o': fbm_offset = atof(optarg);
d615 1
a615 1
			switch (*optarg) {
d633 1
a633 1
					optarg);
d643 1
a643 1
	return(optind);
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d49 1
a49 1
/* declarations to support use of bu_getopt() system call */
d51 2
a52 2
extern char *bu_optarg;
extern int bu_optind, opterr, bu_getopt(int, char *const *, const char *);
d88 1
a88 1
		       progname,
d162 1
a162 1
			v = bn_noise_turb(t, fbm_h,
d197 1
a197 1
			v = bn_noise_turb(t, fbm_h,
d239 1
a239 1
			v = bn_noise_mf(t, fbm_h,
d286 2
a287 2
			v = bn_noise_ridged(t, fbm_h,
					  fbm_lacunarity, fbm_octaves,
d429 1
a429 1

d462 1
a462 1

d494 2
a495 2
			v = lee(t, fbm_h,
					  fbm_lacunarity, fbm_octaves,
d547 2
a548 2
			v = fiord(t, fbm_h,
					  fbm_lacunarity, fbm_octaves,
d562 1
a562 1

d581 1
a581 1
	/* Turn off bu_getopt's error messages */
d585 1
a585 1
	while ((c=bu_getopt(ac,av,options)) != EOF)
d589 1
a589 1
		case 'w': if ((c=atoi(bu_optarg)) > 0) xdim = c;
d591 1
a591 1
		case 'n': if ((c=atoi(bu_optarg)) > 0) ydim = c;
d594 1
a594 1
		case 's': if ((c=atoi(bu_optarg)) > 0) xdim = ydim = c;
d596 1
a596 1
		case 'L': if ((v=atof(bu_optarg)) >  0.0) fbm_lacunarity = v;
d598 1
a598 1
		case 'H': if ((v=atof(bu_optarg)) >  0.0) fbm_h = v;
d600 1
a600 1
		case 'O': if ((v=atof(bu_optarg)) >  0.0) fbm_octaves = v;
d603 1
a603 1
		case 'S': if ((v=atof(bu_optarg)) >  0.0) { VSETALL(fbm_vscale, v); }
d606 1
a606 1
		case 'V': sscanf(bu_optarg, "%lg,%lg,%lg",
d609 1
a609 1
		case 'D': sscanf(bu_optarg, "%lg,%lg,%lg",
d612 1
a612 1
		case 'o': fbm_offset = atof(bu_optarg);
d615 1
a615 1
			switch (*bu_optarg) {
d631 1
a631 1
				fprintf(stderr,
d633 1
a633 1
					bu_optarg);
d643 1
a643 1
	return(bu_optind);
d659 1
a659 1

d661 1
a661 1

d692 1
a692 1
			bu_cv_w_cookie(buf, out_cookie, count*sizeof(*buf),
@


14.3
log
@tidy up a lil bit
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
@


14.2
log
@GPL license changes
@
text
@a402 2
 *
 *
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 24
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d679 10
@

