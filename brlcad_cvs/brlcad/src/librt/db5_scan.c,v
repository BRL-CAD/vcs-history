head	14.20;
access;
symbols
	rel-7-10-4:14.19
	STABLE:14.19.0.2
	stable-branch:14.6
	rel-7-10-2:14.19
	rel-7-10-0:14.16
	rel-7-8-4:14.13
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.4
	rel-7-6-0:14.8
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.2
	bobWinPort:14.8.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.20
date	2007.09.15.16.23.12;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.05.25.05.37.36;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.25.05.10.18;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.19.01.33.25;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.06.08.42.14;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.11.07.01.18.28;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.08.12.22.31.07;	author lbutler;	state Exp;
branches
	14.8.4.1;
next	14.7;

14.7
date	2005.05.11.02.39.41;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.57;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.58;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.19;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.57;	author morrison;	state Exp;
branches;
next	;

14.8.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.20
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                      D B 5 _ S C A N . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup db5 */
/** @@{ */
/** @@file db5_scan.c
 *
 *  Scan a v5 database, sending each object off to a handler.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.19 2007/05/25 05:37:36 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdio.h>
#include <string.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "db5.h"
#include "raytrace.h"

#include "./debug.h"


/**
 *			D B 5 _ S C A N
 *
 * Returns -
 *	 0	Success
 *	-1	Fatal Error
 */
int
db5_scan(
	 struct db_i	*dbip,
	 void		(*handler)(struct db_i *,
				   const struct db5_raw_internal *,
				   long addr, genptr_t client_data ),
	 genptr_t	client_data )
{
    unsigned char	header[8];
    struct db5_raw_internal	raw;
    int			got;
    long			nrec;
    long			addr;

    RT_CK_DBI(dbip);
    if(RT_G_DEBUG&DEBUG_DB) bu_log("db5_scan( x%x, x%x )\n", dbip, handler);

    raw.magic = DB5_RAW_INTERNAL_MAGIC;
    nrec = 0L;

    /* Fast-path when file is already memory-mapped */
    if( dbip->dbi_mf )  {
	const unsigned char	*cp = (const unsigned char *)dbip->dbi_inmem;
	long	eof;

	BU_CK_MAPPED_FILE(dbip->dbi_mf);
	eof = dbip->dbi_mf->buflen;

	if( db5_header_is_valid( cp ) == 0 )  {
	    bu_log("db5_scan ERROR:  %s is lacking a proper BRL-CAD v5 database header\n", dbip->dbi_filename);
	    goto fatal;
	}
	cp += sizeof(header);
	addr = sizeof(header);
	while( addr < eof )  {
	    if( (cp = db5_get_raw_internal_ptr( &raw, cp )) == NULL )  {
		goto fatal;
	    }
	    (*handler)(dbip, &raw, addr, client_data);
	    nrec++;
	    addr += raw.object_length;
	}
	dbip->dbi_eof = addr;
	BU_ASSERT_LONG( dbip->dbi_eof, ==, dbip->dbi_mf->buflen );
    }  else  {
	/* In a totally portable way, read the database with stdio */
	rewind( dbip->dbi_fp );
	if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  ||
	    db5_header_is_valid( header ) == 0 )  {
	    bu_log("db5_scan ERROR:  %s is lacking a proper BRL-CAD v5 database header\n", dbip->dbi_filename);
	    goto fatal;
	}
	for(;;)  {
	    addr = ftell( dbip->dbi_fp );
	    if( (got = db5_get_raw_internal_fp( &raw, dbip->dbi_fp )) < 0 )  {
		if( got == -1 )  break;		/* EOF */
		goto fatal;
	    }
	    (*handler)(dbip, &raw, addr, client_data);
	    nrec++;
	    if(raw.buf)  {
		bu_free(raw.buf, "raw v5 object");
		raw.buf = NULL;
	    }
	}
	dbip->dbi_eof = ftell( dbip->dbi_fp );
	rewind( dbip->dbi_fp );
    }

    dbip->dbi_nrec = nrec;		/* # obj in db, not inc. header */
    return 0;			/* success */

 fatal:
    dbip->dbi_read_only = 1;	/* Writing could corrupt it worse */
    return -1;			/* fatal error */
}


struct directory *
db_diradd5(
	   struct db_i				*dbip,
	   const char				*name,
	   long					laddr,
	   unsigned char			major_type,
	   unsigned char 			minor_type,
	   unsigned char			name_hidden,
	   long					object_length,
	   struct bu_attribute_value_set	*avs)
{
    struct directory **headp;
    register struct directory *dp;
    struct bu_vls local;

    RT_CK_DBI( dbip );

    bu_vls_init(&local);
    bu_vls_strcpy(&local, name);
    if (db_dircheck(dbip, &local, 0, &headp) < 0) {
	bu_vls_free(&local);
	return DIR_NULL;
    }

    if( rt_uniresource.re_magic == 0 )
	rt_init_resource( &rt_uniresource, 0, NULL );

    /* Duplicates the guts of db_diradd() */
    RT_GET_DIRECTORY( dp, &rt_uniresource );
    RT_CK_DIR(dp);
    BU_LIST_INIT( &dp->d_use_hd );
    RT_DIR_SET_NAMEP(dp, bu_vls_addr( &local ));	/* sets d_namep */
    bu_vls_free( &local );
    dp->d_un.ptr = NULL;
    dp->d_un.file_offset = laddr;
    dp->d_major_type = major_type;
    dp->d_minor_type = minor_type;
    switch( major_type )  {
	case DB5_MAJORTYPE_BRLCAD:
	    if( minor_type == ID_COMBINATION )  {

		dp->d_flags = DIR_COMB;
		if( !avs || avs->count == 0 )  break;
		/*
		 *  check for the "region=" attribute.
		 */
		if( bu_avs_get( avs, "region" ) != NULL )
		    dp->d_flags = DIR_COMB|DIR_REGION;
	    } else {
		dp->d_flags = DIR_SOLID;
	    }
	    break;
	case DB5_MAJORTYPE_BINARY_EXPM:
	case DB5_MAJORTYPE_BINARY_UNIF:
	case DB5_MAJORTYPE_BINARY_MIME:
	    /* XXX Do we want to define extra flags for this? */
	    dp->d_flags = DIR_NON_GEOM;
	    break;
	case DB5_MAJORTYPE_ATTRIBUTE_ONLY:
	    dp->d_flags = 0;
    }
    if( name_hidden )
	dp->d_flags |= DIR_HIDDEN;
    dp->d_len = object_length;		/* in bytes */
    BU_LIST_INIT( &dp->d_use_hd );
    dp->d_animate = NULL;
    dp->d_nref = 0;
    dp->d_uses = 0;
    dp->d_forw = *headp;
    *headp = dp;

    return( dp );
}


struct directory *
db5_diradd(struct db_i			*dbip,
	   const struct db5_raw_internal *rip,
	   long				laddr,
	   genptr_t			client_data )
{
    struct directory **headp;
    register struct directory *dp;
    struct bu_vls local;

    RT_CK_DBI( dbip );

    bu_vls_init(&local);
    bu_vls_strcpy(&local, rip->name.ext_buf);
    if (db_dircheck(dbip, &local, 0, &headp) < 0) {
	bu_vls_free(&local);
	return DIR_NULL;
    }

    if( rt_uniresource.re_magic == 0 )
	rt_init_resource( &rt_uniresource, 0, NULL );

    /* Duplicates the guts of db_diradd() */
    RT_GET_DIRECTORY( dp, &rt_uniresource ); /* allocates a new dir */
    RT_CK_DIR(dp);
    BU_LIST_INIT( &dp->d_use_hd );
    RT_DIR_SET_NAMEP(dp, bu_vls_addr(&local));	/* sets d_namep */
    bu_vls_free(&local);
    dp->d_un.file_offset = laddr;
    dp->d_major_type = rip->major_type;
    dp->d_minor_type = rip->minor_type;
    switch( rip->major_type )  {
	case DB5_MAJORTYPE_BRLCAD:
	    if( rip->minor_type == ID_COMBINATION )  {
		struct bu_attribute_value_set	avs;

		bu_avs_init_empty(&avs);

		dp->d_flags = DIR_COMB;
		if( rip->attributes.ext_nbytes == 0 )  break;
		/*
		 *  Crack open the attributes to
		 *  check for the "region=" attribute.
		 */
		if( db5_import_attributes( &avs, &rip->attributes ) < 0 )  {
		    bu_log("db5_diradd_handler: Bad attributes on combination '%s'\n",
			   rip->name);
		    break;
		}
		if( bu_avs_get( &avs, "region" ) != NULL )
		    dp->d_flags = DIR_COMB|DIR_REGION;
		bu_avs_free( &avs );
	    } else {
		dp->d_flags = DIR_SOLID;
	    }
	    break;
	case DB5_MAJORTYPE_BINARY_EXPM:
	case DB5_MAJORTYPE_BINARY_UNIF:
	case DB5_MAJORTYPE_BINARY_MIME:
	    /* XXX Do we want to define extra flags for this? */
	    dp->d_flags = DIR_NON_GEOM;
	    break;
	case DB5_MAJORTYPE_ATTRIBUTE_ONLY:
	    dp->d_flags = 0;
    }
    if( rip->h_name_hidden )
	dp->d_flags |= DIR_HIDDEN;
    dp->d_len = rip->object_length;		/* in bytes */
    BU_LIST_INIT( &dp->d_use_hd );
    dp->d_animate = NULL;
    dp->d_nref = 0;
    dp->d_uses = 0;
    dp->d_forw = *headp;
    *headp = dp;

    return( dp );
}


/**
 *			D B 5 _ D I R A D D _ H A N D L E R
 *
 * In support of db5_scan, add a named entry to the directory.
 */
HIDDEN void
db5_diradd_handler(
		   struct db_i		*dbip,
		   const struct db5_raw_internal *rip,
		   long			laddr,
		   genptr_t		client_data )	/* unused client_data from db5_scan() */
{
    RT_CK_DBI(dbip);

    if( rip->h_dli == DB5HDR_HFLAGS_DLI_HEADER_OBJECT )  return;
    if( rip->h_dli == DB5HDR_HFLAGS_DLI_FREE_STORAGE )  {
	/* Record available free storage */
	rt_memfree( &(dbip->dbi_freep), rip->object_length, laddr );
	return;
    }

    /* If somehow it doesn't have a name, ignore it */
    if( rip->name.ext_buf == NULL )  return;

    if(RT_G_DEBUG&DEBUG_DB)  {
	bu_log("db5_diradd_handler(dbip=x%x, name='%s', addr=x%x, len=%d)\n",
	       dbip, rip->name, laddr, rip->object_length );
    }

    db5_diradd( dbip, rip, laddr, client_data );

    return;
}


/**
 *			D B _ D I R B U I L D
 *
 *  A generic routine to determine the type of the database,
 *  (v4 or v5)
 *  and to invoke the appropriate db_scan()-like routine to
 *  build the in-memory directory.
 *
 *  It is the caller's responsibility to close the database in case of error.
 *
 *  Called from rt_dirbuild(), and g_submodel.c
 *
 *  Returns -
 *	0	OK
 *	-1	failure
 */
int
db_dirbuild( struct db_i *dbip )
{
    unsigned char	header[8];

    if (!dbip) {
	return -1;
    }

    RT_CK_DBI(dbip);

    if (!dbip->dbi_fp) {
	return -1;
    }

    /* First, determine what version database this is */
    rewind(dbip->dbi_fp);
    if (fread(header, sizeof(header), 1, dbip->dbi_fp) != 1) {
	bu_log("db_dirbuild(%s) ERROR, file too short to be BRL-CAD database\n", dbip->dbi_filename);
	return -1;
    }

    if (db5_header_is_valid(header)) {
	struct directory	*dp;
	struct bu_external	ext;
	struct db5_raw_internal	raw;
	struct bu_attribute_value_set	avs;
	const char		*cp;

	bu_avs_init_empty(&avs);

	/* File is v5 format */
	dbip->dbi_version = 5;
	if (db5_scan(dbip, db5_diradd_handler, NULL) < 0) {
	    bu_log("db_dirbuild(%s): db5_scan() failed\n", dbip->dbi_filename);
	    return -1;
	}

	/* Need to retrieve _GLOBAL object and obtain title and units */
	if ((dp = db_lookup( dbip, DB5_GLOBAL_OBJECT_NAME, LOOKUP_NOISY)) == DIR_NULL) {
	    bu_log("db_dirbuild(%s): improper database, no %s object\n",
		   dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
	    dbip->dbi_title = bu_strdup(DB5_GLOBAL_OBJECT_NAME);
	    /* Missing _GLOBAL object so create it and set default title and units */
	    db5_update_ident(dbip, "Untitled BRL-CAD Database",1.0);
	    return 0;	/* not a fatal error, user may have deleted it */
	}
	BU_INIT_EXTERNAL(&ext);
	if (db_get_external( &ext, dp, dbip) < 0 ||
	    db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL) {
	    bu_log("db_dirbuild(%s): improper database, unable to read %s object\n",
		   dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME);
	    return -1;
	}
	if (raw.major_type != DB5_MAJORTYPE_ATTRIBUTE_ONLY) {
	    bu_log("db_dirbuild(%s): improper database, %s exists but is not an attribute-only object\n",
		   dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME);
	    dbip->dbi_title = bu_strdup(DB5_GLOBAL_OBJECT_NAME);
	    return 0;	/* not a fatal error, need to let user proceed to fix it */
	}
	if (db5_import_attributes( &avs, &raw.attributes) < 0) {
	    bu_log("db_dirbuild(%s): improper database, corrupted attribute-only %s object\n",
		   dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME);
	    bu_free_external(&ext);
	    return -1;	/* this is fatal */
	}
	BU_CK_AVS(&avs);

	/* Parse out the attributes */
	if ((cp = bu_avs_get( &avs, "title" )) != NULL) {
	    dbip->dbi_title = bu_strdup(cp);
	} else {
	    dbip->dbi_title = bu_strdup("Untitled BRL-CAD database");
	}
	if ((cp = bu_avs_get(&avs, "units")) != NULL) {
	    double	dd;
	    if (sscanf( cp, "%lf", &dd) != 1 || NEAR_ZERO(dd, VUNITIZE_TOL))  {
		bu_log("db_dirbuild(%s): improper database, %s object attribute 'units'=%s is invalid\n",
		       dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME, cp);
		/* Not fatal, just stick with default value from db_open() */
	    } else {
		dbip->dbi_local2base = dd;
		dbip->dbi_base2local = 1/dd;
	    }
	}
	if ((cp = bu_avs_get( &avs, "regionid_colortable")) != NULL) {
	    /* Import the region-id coloring table */
	    db5_import_color_table((char *)cp);
	}
	bu_avs_free(&avs);
	bu_free_external(&ext);	/* not until after done with avs! */
	return 0;
    }

    /* Make a very simple check for a v4 database */
    if (header[0] == 'I') {
	dbip->dbi_version = 4;
	if (db_scan( dbip, (int (*)())db_diradd, 1, NULL) < 0) {
	    dbip->dbi_version = 0;
	    return -1;
	}
	return 0;		/* ok */
    }

    bu_log("db_dirbuild(%s) ERROR, file is not in BRL-CAD geometry database format\n",
	   dbip->dbi_filename);
    return -1;
}


int
db_get_version(struct db_i *dbip)
{
    unsigned char	header[8];

    if (!dbip) {
	return -1;
    }

    RT_CK_DBI(dbip);

    if (!dbip->dbi_fp) {
	return -1;
    }

    rewind(dbip->dbi_fp);
    if (fread( header, sizeof(header), 1, dbip->dbi_fp) != 1) {
	bu_log("db_get_version ERROR, file (%s) too short to be BRL-CAD database\n", dbip->dbi_filename);
	return -1;
    }

    if (db5_header_is_valid(header)) {
	return 5;
    } else if (header[0] == 'I') {
	return 4;
    }

    return( -1 );
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.19
log
@return quietly if dbip is null or if the file pointer isn't set, plus some ws
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.18 2007/05/25 05:10:18 brlcad Exp $ (ARL)";
d41 1
a41 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.18
log
@quietly return -1 if given null or there is no file pointer opened
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.17 2007/05/19 01:33:25 brlcad Exp $ (ARL)";
d352 4
d358 4
d364 2
a365 3
    if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  )  {
	bu_log("db_dirbuild(%s) ERROR, file too short to be BRL-CAD database\n",
	       dbip->dbi_filename);
d369 1
a369 1
    if( db5_header_is_valid( header ) )  {
d380 2
a381 3
	if( db5_scan( dbip, db5_diradd_handler, NULL ) < 0 )  {
	    bu_log("db_dirbuild(%s): db5_scan() failed\n",
		   dbip->dbi_filename);
d386 1
a386 1
	if( (dp = db_lookup( dbip, DB5_GLOBAL_OBJECT_NAME, LOOKUP_NOISY )) == DIR_NULL )  {
d395 2
a396 2
	if( db_get_external( &ext, dp, dbip ) < 0 ||
	    db5_get_raw_internal_ptr( &raw, ext.ext_buf ) == NULL )  {
d398 1
a398 1
		   dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
d401 1
a401 1
	if( raw.major_type != DB5_MAJORTYPE_ATTRIBUTE_ONLY )  {
d403 1
a403 1
		   dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
d407 1
a407 1
	if( db5_import_attributes( &avs, &raw.attributes ) < 0 )  {
d409 1
a409 1
		   dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
d413 1
a413 1
	BU_CK_AVS( &avs );
d416 2
a417 2
	if( (cp = bu_avs_get( &avs, "title" )) != NULL )  {
	    dbip->dbi_title = bu_strdup( cp );
d419 1
a419 1
	    dbip->dbi_title = bu_strdup( "Untitled BRL-CAD database" );
d421 1
a421 1
	if( (cp = bu_avs_get( &avs, "units" )) != NULL )  {
d423 1
a423 2
	    if( sscanf( cp, "%lf", &dd ) != 1 ||
		NEAR_ZERO( dd, VUNITIZE_TOL ) )  {
d425 1
a425 2
		       dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME,
		       cp );
d432 1
a432 1
	if( (cp = bu_avs_get( &avs, "regionid_colortable")) != NULL )  {
d434 1
a434 1
	    db5_import_color_table( (char *)cp);
d436 1
a436 1
	bu_avs_free( &avs );
d442 1
a442 1
    if( header[0] == 'I' )  {
d444 1
a444 1
	if( db_scan( dbip, (int (*)())db_diradd, 1, NULL ) < 0 )  {
@


14.17
log
@meh
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.16 2007/01/23 01:13:36 brlcad Exp $ (ARL)";
d458 10
d469 2
a470 3
    if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  )  {
	bu_log("db_get_version ERROR, file (%s) too short to be BRL-CAD database\n",
	       dbip->dbi_filename);
d474 5
a478 6
    if( db5_header_is_valid( header ) )
	return( 5 );
    else if( header[0] == 'I' )
	return( 4 );
    else
	return( -1 );
d480 1
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.15 2007/01/21 04:45:43 brlcad Exp $ (ARL)";
d137 1
a137 1
    dbip->dbi_read_only = 1;	/* Writing would corrupt it worse */
d240 1
a240 1
    RT_GET_DIRECTORY( dp, &rt_uniresource );
@


14.15
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.14 2007/01/20 14:36:54 brlcad Exp $ (ARL)";
@


14.14
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 1
/*@@{*/
d24 1
a32 1
 *
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.13 2006/09/16 02:04:24 lbutler Exp $ (ARL)";
d475 1
a475 1
/*@@}*/
@


14.13
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.12 2006/01/18 06:46:17 brlcad Exp $ (ARL)";
@


14.12
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup db5 */
a34 1
/*@@}*/
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.11 2006/01/06 08:42:14 brlcad Exp $ (ARL)";
d476 1
@


14.11
log
@init the rt_uniresource structure if it hasn't been initialized yet so that we can call db_dirbuild() directly without necessarily needing to worry about initializing a resource structure.  this mimicks the behavior and initialization that rt_dirbuild() performas as well.
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.10 2005/11/07 01:18:28 brlcad Exp $ (ARL)";
@


14.10
log
@remove stale notification that files are v5 format, everything is v5
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.9 2005/10/23 04:44:35 brlcad Exp $ (ARL)";
a42 2


d45 1
a45 1
#include <string.h>
d47 1
a47 1
#include <strings.h>
d59 1
d69 5
a73 5
	struct db_i	*dbip,
	void		(*handler)(struct db_i *,
				const struct db5_raw_internal *,
				long addr, genptr_t client_data ),
	genptr_t	client_data )
d75 68
a142 60
	unsigned char	header[8];
	struct db5_raw_internal	raw;
	int			got;
	long			nrec;
	long			addr;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db5_scan( x%x, x%x )\n", dbip, handler);

	raw.magic = DB5_RAW_INTERNAL_MAGIC;
	nrec = 0L;

	/* Fast-path when file is already memory-mapped */
	if( dbip->dbi_mf )  {
		const unsigned char	*cp = (const unsigned char *)dbip->dbi_inmem;
		long	eof;

		BU_CK_MAPPED_FILE(dbip->dbi_mf);
		eof = dbip->dbi_mf->buflen;

		if( db5_header_is_valid( cp ) == 0 )  {
			bu_log("db5_scan ERROR:  %s is lacking a proper BRL-CAD v5 database header\n", dbip->dbi_filename);
		    	goto fatal;
		}
		cp += sizeof(header);
		addr = sizeof(header);
		while( addr < eof )  {
			if( (cp = db5_get_raw_internal_ptr( &raw, cp )) == NULL )  {
				goto fatal;
			}
			(*handler)(dbip, &raw, addr, client_data);
			nrec++;
			addr += raw.object_length;
		}
		dbip->dbi_eof = addr;
		BU_ASSERT_LONG( dbip->dbi_eof, ==, dbip->dbi_mf->buflen );
	}  else  {
		/* In a totally portable way, read the database with stdio */
		rewind( dbip->dbi_fp );
		if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  ||
		    db5_header_is_valid( header ) == 0 )  {
			bu_log("db5_scan ERROR:  %s is lacking a proper BRL-CAD v5 database header\n", dbip->dbi_filename);
		    	goto fatal;
		}
		for(;;)  {
			addr = ftell( dbip->dbi_fp );
			if( (got = db5_get_raw_internal_fp( &raw, dbip->dbi_fp )) < 0 )  {
				if( got == -1 )  break;		/* EOF */
				goto fatal;
			}
			(*handler)(dbip, &raw, addr, client_data);
			nrec++;
			if(raw.buf)  {
				bu_free(raw.buf, "raw v5 object");
				raw.buf = NULL;
			}
		}
		dbip->dbi_eof = ftell( dbip->dbi_fp );
		rewind( dbip->dbi_fp );
	}
a143 7
	dbip->dbi_nrec = nrec;		/* # obj in db, not inc. header */
	return 0;			/* success */

fatal:
	dbip->dbi_read_only = 1;	/* Writing would corrupt it worse */
	return -1;			/* fatal error */
}
d156 27
a182 24
	struct directory **headp;
	register struct directory *dp;
	struct bu_vls local;

	RT_CK_DBI( dbip );

	bu_vls_init(&local);
	bu_vls_strcpy(&local, name);
	if (db_dircheck(dbip, &local, 0, &headp) < 0) {
		bu_vls_free(&local);
		return DIR_NULL;
	}

	/* Duplicates the guts of db_diradd() */
	RT_GET_DIRECTORY( dp, &rt_uniresource );
	RT_CK_DIR(dp);
	BU_LIST_INIT( &dp->d_use_hd );
	RT_DIR_SET_NAMEP(dp, bu_vls_addr( &local ));	/* sets d_namep */
	bu_vls_free( &local );
	dp->d_un.ptr = NULL;
	dp->d_un.file_offset = laddr;
	dp->d_major_type = major_type;
	dp->d_minor_type = minor_type;
	switch( major_type )  {
d184 1
a184 1
		if( minor_type == ID_COMBINATION )  {
d186 11
a196 11
			dp->d_flags = DIR_COMB;
			if( !avs || avs->count == 0 )  break;
			/*
			 *  check for the "region=" attribute.
			 */
			if( bu_avs_get( avs, "region" ) != NULL )
				dp->d_flags = DIR_COMB|DIR_REGION;
		} else {
			dp->d_flags = DIR_SOLID;
		}
		break;
d200 3
a202 3
		/* XXX Do we want to define extra flags for this? */
		dp->d_flags = DIR_NON_GEOM;
		break;
d204 11
a214 11
		dp->d_flags = 0;
	}
	if( name_hidden )
		dp->d_flags |= DIR_HIDDEN;
	dp->d_len = object_length;		/* in bytes */
	BU_LIST_INIT( &dp->d_use_hd );
	dp->d_animate = NULL;
	dp->d_nref = 0;
	dp->d_uses = 0;
	dp->d_forw = *headp;
	*headp = dp;
d216 1
a216 1
	return( dp );
d219 1
d226 9
a234 18
	struct directory **headp;
	register struct directory *dp;
	struct bu_vls local;

	RT_CK_DBI( dbip );

	bu_vls_init(&local);
	bu_vls_strcpy(&local, rip->name.ext_buf);
	if (db_dircheck(dbip, &local, 0, &headp) < 0) {
		bu_vls_free(&local);
		return DIR_NULL;
	}

	/* Duplicates the guts of db_diradd() */
	RT_GET_DIRECTORY( dp, &rt_uniresource );
	RT_CK_DIR(dp);
	BU_LIST_INIT( &dp->d_use_hd );
	RT_DIR_SET_NAMEP(dp, bu_vls_addr(&local));	/* sets d_namep */
d236 16
a251 4
	dp->d_un.file_offset = laddr;
	dp->d_major_type = rip->major_type;
	dp->d_minor_type = rip->minor_type;
	switch( rip->major_type )  {
d253 2
a254 2
		if( rip->minor_type == ID_COMBINATION )  {
			struct bu_attribute_value_set	avs;
d256 1
a256 1
			bu_avs_init_empty(&avs);
d258 10
a267 16
			dp->d_flags = DIR_COMB;
			if( rip->attributes.ext_nbytes == 0 )  break;
			/*
			 *  Crack open the attributes to
			 *  check for the "region=" attribute.
			 */
			if( db5_import_attributes( &avs, &rip->attributes ) < 0 )  {
				bu_log("db5_diradd_handler: Bad attributes on combination '%s'\n",
					rip->name);
				break;
			}
			if( bu_avs_get( &avs, "region" ) != NULL )
				dp->d_flags = DIR_COMB|DIR_REGION;
			bu_avs_free( &avs );
		} else {
			dp->d_flags = DIR_SOLID;
d269 7
a275 1
		break;
d279 3
a281 3
		/* XXX Do we want to define extra flags for this? */
		dp->d_flags = DIR_NON_GEOM;
		break;
d283 11
a293 11
		dp->d_flags = 0;
	}
	if( rip->h_name_hidden )
		dp->d_flags |= DIR_HIDDEN;
	dp->d_len = rip->object_length;		/* in bytes */
	BU_LIST_INIT( &dp->d_use_hd );
	dp->d_animate = NULL;
	dp->d_nref = 0;
	dp->d_uses = 0;
	dp->d_forw = *headp;
	*headp = dp;
d295 1
a295 1
	return( dp );
d298 1
d306 4
a309 4
	struct db_i		*dbip,
	const struct db5_raw_internal *rip,
	long			laddr,
	genptr_t		client_data )	/* unused client_data from db5_scan() */
d311 1
a311 1
	RT_CK_DBI(dbip);
d313 6
a318 6
	if( rip->h_dli == DB5HDR_HFLAGS_DLI_HEADER_OBJECT )  return;
	if( rip->h_dli == DB5HDR_HFLAGS_DLI_FREE_STORAGE )  {
		/* Record available free storage */
		rt_memfree( &(dbip->dbi_freep), rip->object_length, laddr );
		return;
	}
d320 2
a321 2
	/* If somehow it doesn't have a name, ignore it */
	if( rip->name.ext_buf == NULL )  return;
d323 4
a326 4
	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db5_diradd_handler(dbip=x%x, name='%s', addr=x%x, len=%d)\n",
			dbip, rip->name, laddr, rip->object_length );
	}
d328 1
a328 1
	db5_diradd( dbip, rip, laddr, client_data );
d330 1
a330 1
	return;
d333 1
d353 1
a353 1
	unsigned char	header[8];
d355 1
a355 1
	RT_CK_DBI(dbip);
d357 7
a363 14
	/* First, determine what version database this is */
	rewind(dbip->dbi_fp);
	if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  )  {
		bu_log("db_dirbuild(%s) ERROR, file too short to be BRL-CAD database\n",
			dbip->dbi_filename);
		return -1;
	}

	if( db5_header_is_valid( header ) )  {
		struct directory	*dp;
		struct bu_external	ext;
		struct db5_raw_internal	raw;
		struct bu_attribute_value_set	avs;
		const char		*cp;
d365 6
a370 1
		bu_avs_init_empty(&avs);
d372 1
a372 7
		/* File is v5 format */
		dbip->dbi_version = 5;
		if( db5_scan( dbip, db5_diradd_handler, NULL ) < 0 )  {
			bu_log("db_dirbuild(%s): db5_scan() failed\n",
				dbip->dbi_filename);
			return -1;
		}
d374 80
a453 29
		/* Need to retrieve _GLOBAL object and obtain title and units */
		if( (dp = db_lookup( dbip, DB5_GLOBAL_OBJECT_NAME, LOOKUP_NOISY )) == DIR_NULL )  {
			bu_log("db_dirbuild(%s): improper database, no %s object\n",
				dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
			dbip->dbi_title = bu_strdup(DB5_GLOBAL_OBJECT_NAME);
			/* Missing _GLOBAL object so create it and set default title and units */
			db5_update_ident(dbip, "Untitled BRL-CAD Database",1.0);
			return 0;	/* not a fatal error, user may have deleted it */
		}
		BU_INIT_EXTERNAL(&ext);
		if( db_get_external( &ext, dp, dbip ) < 0 ||
		    db5_get_raw_internal_ptr( &raw, ext.ext_buf ) == NULL )  {
			bu_log("db_dirbuild(%s): improper database, unable to read %s object\n",
				dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
			return -1;
		}
		if( raw.major_type != DB5_MAJORTYPE_ATTRIBUTE_ONLY )  {
			bu_log("db_dirbuild(%s): improper database, %s exists but is not an attribute-only object\n",
				dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
			dbip->dbi_title = bu_strdup(DB5_GLOBAL_OBJECT_NAME);
			return 0;	/* not a fatal error, need to let user proceed to fix it */
		}
		if( db5_import_attributes( &avs, &raw.attributes ) < 0 )  {
			bu_log("db_dirbuild(%s): improper database, corrupted attribute-only %s object\n",
				dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME );
		    	bu_free_external(&ext);
			return -1;	/* this is fatal */
		}
		BU_CK_AVS( &avs );
a454 42
		/* Parse out the attributes */
		if( (cp = bu_avs_get( &avs, "title" )) != NULL )  {
			dbip->dbi_title = bu_strdup( cp );
		} else {
			dbip->dbi_title = bu_strdup( "Untitled BRL-CAD database" );
		}
		if( (cp = bu_avs_get( &avs, "units" )) != NULL )  {
			double	dd;
			if( sscanf( cp, "%lf", &dd ) != 1 ||
			    NEAR_ZERO( dd, VUNITIZE_TOL ) )  {
			    	bu_log("db_dirbuild(%s): improper database, %s object attribute 'units'=%s is invalid\n",
					dbip->dbi_filename, DB5_GLOBAL_OBJECT_NAME,
				    	cp );
			    	/* Not fatal, just stick with default value from db_open() */
			} else {
				dbip->dbi_local2base = dd;
				dbip->dbi_base2local = 1/dd;
			}
		}
		if( (cp = bu_avs_get( &avs, "regionid_colortable")) != NULL )  {
			/* Import the region-id coloring table */
			db5_import_color_table( (char *)cp);
		}
		bu_avs_free( &avs );
		bu_free_external(&ext);	/* not until after done with avs! */
		return 0;
	}

	/* Make a very simple check for a v4 database */
	if( header[0] == 'I' )  {
		dbip->dbi_version = 4;
		if( db_scan( dbip, (int (*)())db_diradd, 1, NULL ) < 0 )  {
			dbip->dbi_version = 0;
		    	return -1;
		}
		return 0;		/* ok */
	}

	bu_log("db_dirbuild(%s) ERROR, file is not in BRL-CAD geometry database format\n",
		dbip->dbi_filename);
	return -1;
}
d459 1
a459 1
	unsigned char	header[8];
d461 6
a466 6
	rewind(dbip->dbi_fp);
	if( fread( header, sizeof header, 1, dbip->dbi_fp ) != 1  )  {
		bu_log("db_get_version ERROR, file (%s) too short to be BRL-CAD database\n",
			dbip->dbi_filename);
		return -1;
	}
d468 6
a473 6
	if( db5_header_is_valid( header ) )
		return( 5 );
	else if( header[0] == 'I' )
		return( 4 );
	else
		return( -1 );
@


14.9
log
@trailing ws
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.8 2005/08/12 22:31:07 lbutler Exp $ (ARL)";
a365 3
#if 0
		bu_log("NOTICE:  %s is BRL-CAD v5 format.\n", dbip->dbi_filename);
#endif
@


14.8
log
@Doxygen changes
@
text
@d29 1
a29 1
 *  
d33 1
a33 1
 *  
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.7 2005/05/11 02:39:41 brlcad Exp $ (ARL)";
d311 1
a311 1
	
d467 1
a467 1
	
@


14.8.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d33 1
a33 1
 *
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d311 1
a311 1

d366 3
d467 1
a467 1

@


14.7
log
@contrary to popular evidence, initialize the avs structs to empty anyways.
@
text
@d21 3
a24 1
 *
d35 2
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.6 2005/01/30 20:30:57 brlcad Exp $ (ARL)";
d61 1
a61 1
/*
d291 1
a291 1
/*
d325 1
a325 1
/*
@


14.6
log
@update copyright to 2005
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_scan.c,v 14.5 2004/12/21 07:18:58 morrison Exp $ (ARL)";
d213 1
a213 2
db5_diradd(
	   struct db_i			*dbip,
d245 2
d359 2
d363 1
a363 1
bu_log("NOTICE:  %s is BRL-CAD v5 format.\n", dbip->dbi_filename);
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_scan.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a31 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_scan.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_scan.c,v 14.2 2004/12/21 04:18:19 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_scan.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			D B 5 _ S C A N . C
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_scan.c,v 1.3 2004/09/03 23:30:58 morrison Exp $ (ARL)";
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_scan.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (ARL)";
d445 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_scan.c,v 1.1 2004/05/20 15:19:57 morrison Exp $ (ARL)";
d25 1
a25 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db5_scan.c,v 11.41 2004/05/10 15:30:46 erikg Exp $ (ARL)";
d20 1
a20 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

