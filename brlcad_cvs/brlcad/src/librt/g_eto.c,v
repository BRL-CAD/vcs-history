head	14.24;
access;
symbols
	rel-7-10-4:14.20
	STABLE:14.20.0.2
	stable-branch:14.6
	rel-7-10-2:14.19
	rel-7-10-0:14.19
	rel-7-8-4:14.14
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.11
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.11
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.24
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.12.17.02.16.54;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.11.28.14.11.27;	author erikgreenwald;	state Exp;
branches;
next	14.21;

14.21
date	2007.09.15.16.23.12;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.08.23.00.29.12;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.27.01.41.40;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.26.05.28.47;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.22.23.37.39;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.11.24.14.28.22;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.9.4.1;
next	14.8;

14.8
date	2005.05.02.00.49.38;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.04.29.14.22.52;	author lbutler;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.59;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.00;	author morrison;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.24
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                         G _ E T O . C
 * BRL-CAD
 *
 * Copyright (c) 1992-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_eto.c
 *
 *	Intersect a ray with an Elliptical Torus.
 *
 * Authors -
 *	Michael Markowski	(Programming)
 *	ERIM GIFT code		(ETO Eqn)
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */

#include "common.h"

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

/*
 * The ETO has the following input fields:
 *	V	V from origin to center.
 *	N	Normal to plane of eto.
 *	C	Semi-major axis of elliptical cross section.
 *      r	Radius of revolution.
 *	rd	Semi-minor axis of elliptical cross section.
 *
 */

/*
 *  Algorithm:
 *
 *  Given V, N, C, r, and rd, there is a set of points on this eto
 *
 *  { (x,y,z) | (x,y,z) is on eto defined by V, N, C, r, rd }
 *
 *  Through a series of  Transformations, this set will be
 *  transformed into a set of points on an eto centered at the origin
 *  which lies on the X-Y plane (ie, N is on the Z axis).
 *
 *  { (x',y',z') | (x',y',z') is an eto at origin }
 *
 *  The transformation from X to X' is accomplished by:
 *
 *  X' = R( X - V )
 *
 *  where R(X) =  ( B/(|B|) )
 *  		 (  A/(|A|)  ) . X
 *  		  ( N/(|N|) )
 *
 *  To find the intersection of a line with the eto, consider
 *  the parametric line L:
 *
 *  	L : { P(n) | P + t(n) . D }
 *
 *  Call W the actual point of intersection between L and the eto.
 *  Let W' be the point of intersection between L' and the unit eto.
 *
 *  	L' : { P'(n) | P' + t(n) . D' }
 *
 *  W = invR( W' ) + V
 *
 *  Where W' = k D' + P'.
 *
 *
 *  Given a line and a ratio, alpha, finds the equation of the
 *  unit eto in terms of the variable 't'.
 *
 *  Given that the equation for the eto is:
 *
 *            _______                           _______
 *           / 2    2              2           / 2    2               2
 *  [Eu(+- \/ x  + y   - R) + Ev z]  + [Fu(+-\/ x  + y   - R) + Fv z ]
 * --------------------------------    -------------------------------  = 1
 *               2                                      2
 *             Rc                                     Rd
 *
 *  First, find X, Y, and Z in terms of 't' for this line, then
 *  substitute them into the equation above.
 *
 *  	Wx = Dx*t + Px
 *
 *  	Wx**2 = Dx**2 * t**2  +  2 * Dx * Px  +  Px**2
 *
 *  The real roots of the equation in 't' are the intersect points
 *  along the parameteric line.
 *
 *  NORMALS.  Given the point W on the eto, what is the vector
 *  normal to the tangent plane at that point?
 *
 *  Map W onto the eto, ie:  W' = R( W - V ).
 *  In this case, we find W' by solving the parameteric line given k.
 *
 *  The gradient of the eto at W' is in fact the
 *  normal vector.
 *
 *  For f(x,y,z) = 0, the gradient of f() is ( df/dx, df/dy, df/dz ).
 *
 *  Note that the normal vector (gradient) produced above will not have
 *  unit length.  Also, to make this useful for the original eto, it will
 *  have to be rotated back to the orientation of the original eto.
 */

struct eto_specific {
	vect_t	eto_V;		/* Vector to center of eto */
	vect_t	eto_N;		/* unit normal to plane of eto */
	vect_t	eto_C;		/* semi-major axis of ellipse */
	fastf_t	eto_r;		/* radius of revolution */
	fastf_t	eto_rc;		/* semi-major axis of ellipse */
	fastf_t	eto_rd;		/* semi-minor axis of ellipse */
	mat_t	eto_R;		/* Rot(vect) */
	mat_t	eto_invR;	/* invRot(vect') */
	fastf_t	eu, ev, fu, fv;
};

const struct bu_structparse rt_eto_parse[] = {
    { "%f", 3, "V",   bu_offsetof(struct rt_eto_internal, eto_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "N",   bu_offsetof(struct rt_eto_internal, eto_N[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C",   bu_offsetof(struct rt_eto_internal, eto_C[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r",   bu_offsetof(struct rt_eto_internal, eto_r),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_d", bu_offsetof(struct rt_eto_internal, eto_rd),   BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
 };

/**
 *  			R T _ E T O _ P R E P
 *
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid eto, and if so, precompute various
 *  terms of the formula.
 *
 *  Returns -
 *  	0	ETO is OK
 *  	!0	Error in description
 *
 *  Implicit return -
 *  	A struct eto_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_eto_shot().
 */
int
rt_eto_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct eto_specific *eto;

	vect_t	P, w1;	/* for RPP calculation */
	vect_t	Au, Bu, Cu, Nu;
	fastf_t	ch, cv, dh, f, phi;
	struct rt_eto_internal	*tip;

	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	/* Solid is OK, compute constant terms now */
	BU_GETSTRUCT( eto, eto_specific );
	stp->st_specific = (genptr_t)eto;

	eto->eto_r = tip->eto_r;
	eto->eto_rd = tip->eto_rd;
	eto->eto_rc = MAGNITUDE( tip->eto_C );
	if ( NEAR_ZERO(eto->eto_r, 0.0001) || NEAR_ZERO(eto->eto_rd, 0.0001)
		|| NEAR_ZERO(eto->eto_rc, 0.0001)) {
		bu_log("eto(%s): r, rd, or rc zero length\n", stp->st_name);
		return(1);
	}

	VMOVE( eto->eto_V, tip->eto_V );
	VMOVE( eto->eto_N, tip->eto_N );
	VMOVE( eto->eto_C, tip->eto_C );
	VMOVE( Nu, tip->eto_N );
	VUNITIZE( Nu );		/* z axis of coord sys */
	bn_vec_ortho( Bu, Nu );	/* x axis */
	VUNITIZE( Bu );
	VCROSS( Au, Nu, Bu );	/* y axis */
	VMOVE( Cu, tip->eto_C );
	VUNITIZE( Cu );

	/* get horizontal and vertical components of C and Rd */
	cv = VDOT( eto->eto_C, Nu );
	ch = sqrt( VDOT( eto->eto_C, eto->eto_C ) - cv * cv );
	/* angle between C and Nu */
	phi = acos( cv / eto->eto_rc );
	dh = eto->eto_rd * cos(phi);
	/* make sure ellipse doesn't overlap itself when revolved */
	if (ch > eto->eto_r || dh > eto->eto_r) {
		bu_log("eto(%s): revolved ellipse overlaps itself\n",
			stp->st_name);
		return(1);
	}

	eto->ev = fabs( VDOT( Cu, Nu ) );	/* vertical component of Cu */
	eto->eu = sqrt( 1.0 - eto->ev * eto->ev );	/* horiz component */
	eto->fu = -eto->ev;
	eto->fv =  eto->eu;

	/* Compute R and invR matrices */
	MAT_IDN( eto->eto_R );
	VMOVE( &eto->eto_R[0], Bu );
	VMOVE( &eto->eto_R[4], Au );
	VMOVE( &eto->eto_R[8], Nu );
	bn_mat_inv( eto->eto_invR, eto->eto_R );

	stp->st_aradius = stp->st_bradius = eto->eto_r + eto->eto_rc;

	/*
	 *  Compute the bounding RPP planes for a circular eto.
	 *
	 *  Given a circular eto with vertex V, vector N, and
	 *  radii r and |C|.  A bounding plane with direction
	 *  vector P will touch the surface of the eto at the
	 *  points:  V +/- [|C| + r * |N x P|] P
	 */

	/* X */
	VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
	VCROSS( w1, Nu, P );	/* for sin(angle N P) */
	f = eto->eto_rc + eto->eto_r * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[X] );
	stp->st_min[X] = eto->eto_V[X] - f;
	stp->st_max[X] = eto->eto_V[X] + f;

	/* Y */
	VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
	VCROSS( w1, Nu, P );	/* for sin(angle N P) */
	f = eto->eto_rc + eto->eto_r * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[Y] );
	stp->st_min[Y] = eto->eto_V[Y] - f;
	stp->st_max[Y] = eto->eto_V[Y] + f;

	/* Z */
	VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
	VCROSS( w1, Nu, P );	/* for sin(angle N P) */
	f = eto->eto_rc + eto->eto_r * MAGNITUDE(w1);
	VSCALE( w1, P, f );
	f = fabs( w1[Z] );
	stp->st_min[Z] = eto->eto_V[Z] - f;
	stp->st_max[Z] = eto->eto_V[Z] + f;

	return(0);			/* OK */
}

/**
 *			R T _ E T O _ P R I N T
 */
void
rt_eto_print(register const struct soltab *stp)
{
	register const struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;

	VPRINT("V", eto->eto_V);
	VPRINT("N", eto->eto_N);
	VPRINT("C", eto->eto_C);
	bu_log("r = %f\n", eto->eto_r);
	bu_log("rc = %f\n", eto->eto_rc);
	bu_log("rd = %f\n", eto->eto_rd);
	bn_mat_print("R", eto->eto_R );
	bn_mat_print("invR", eto->eto_invR );
	bu_log( "rpp: (%g, %g, %g) to (%g, %g, %g)\n",
		stp->st_min[X], stp->st_min[Y], stp->st_min[Z],
		stp->st_max[X], stp->st_max[Y], stp->st_max[Z]);
}

/**
 *  			R T _ E T O _ S H O T
 *
 *  Intersect a ray with an eto, where all constant terms have
 *  been precomputed by rt_eto_prep().  If an intersection occurs,
 *  one or two struct seg(s) will be acquired and filled in.
 *
 *  NOTE:  All lines in this function are represented parametrically
 *  by a point,  P( x0, y0, z0 ) and a direction normal,
 *  D = ax + by + cz.  Any point on a line can be expressed
 *  by one variable 't', where
 *
 *	X = a*t + x0,	eg,  X = Dx*t + Px
 *	Y = b*t + y0,
 *	Z = c*t + z0.
 *
 *  First, convert the line to the coordinate system of a "stan-
 *  dard" eto.  This is a eto which lies in the X-Y plane
 *  and circles the origin.  The semimajor axis is C.
 *
 *  Then find the equation of that line and the standard eto,
 *  which turns out to be a quartic equation in 't'.  Solve the
 *  equation using a general polynomial root finder.  Use those
 *  values of 't' to compute the points of intersection in the
 *  original coordinate system.
 *
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_eto_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;
	register struct seg *segp;
	vect_t	dprime;		/* D' */
	vect_t	pprime;		/* P' */
	vect_t	work;		/* temporary vector */
	bn_poly_t	C;		/* The final equation */
	bn_complex_t	val[4];	/* The complex roots */
	double	k[4];		/* The real roots */
	register int	i;
	int	j;
	vect_t	cor_pprime;	/* new ray origin */
	fastf_t	cor_proj;
	fastf_t	A1,A2,A3,A4,A5,A6,A7,A8,B1,B2,B3,C1,C2,C3,D1,term;

	/* Convert vector into the space of the unit eto */
	MAT4X3VEC( dprime, eto->eto_R, rp->r_dir );
	VUNITIZE( dprime );

	VSUB2( work, rp->r_pt, eto->eto_V );
	MAT4X3VEC( pprime, eto->eto_R, work );

	/* normalize distance from eto.  substitute
	 * corrected pprime which contains a translation along ray
	 * direction to closest approach to vertex of eto.
	 * Translating ray origin along direction of ray to closest pt. to
	 * origin of solid's coordinate system, new ray origin is
	 * 'cor_pprime'.
	 */
	cor_proj = VDOT( pprime, dprime );
	VSCALE( cor_pprime, dprime, cor_proj );
	VSUB2( cor_pprime, pprime, cor_pprime );

	/*
	 *  NOTE: The following code is based on code in
	 *        eto.f by ERIM for GIFT.
	 *
	 *  Given a line, finds the equation of the
	 *  eto in terms of the variable 't'.
	 *
	 *  The equation for the eto is:
	 *
	    _______                           ________
	   / 2    2              2           / 2    2               2
  [Eu(+- \/ x  + y   - R) + Ev z]  + [Fu(+-\/ x  + y   - R) + Fv z ]
 --------------------------------    -------------------------------  = 1
	       2                                      2
	     Rc                                     Rd
	 *
	 *                  ^   ^
	 *       where Ev = C . N
	 *
	 *                  ^   ^
	 *             Eu = C . A
	 *
	 *                  ^   ^
	 *             Fv = C . A
	 *
	 *                  ^   ^
	 *             Fu =-C . N.
	 *
	 *  First, find X, Y, and Z in terms of 't' for this line, then
	 *  substitute them into the equation above.
	 *
	 *  	Wx = Dx*t + Px, etc.
	 *
	 *  Regrouping coefficients and constants, the equation can then
	 *  be rewritten as:
	 *
	 *  [A1*sqrt(C1 + C2*t + C3*t^2) + A2 + A3*t]^2  +
	 *  [B1*sqrt(C1 + C2*t + C3*t^2) + B2 + B3*t]^2  - D1 = 0
	 *
	 *  where, (variables defined in code below)
	 */
	A1 = eto->eto_rd * eto->eu;
	B1 = eto->eto_rc * eto->fu;
	C1 = cor_pprime[X] * cor_pprime[X] + cor_pprime[Y] * cor_pprime[Y];
	C2 = 2 * (dprime[X] * cor_pprime[X] + dprime[Y] * cor_pprime[Y]);
	C3 = dprime[X] * dprime[X] + dprime[Y] * dprime[Y];
	A2 = -eto->eto_rd * eto->eto_r * eto->eu + eto->eto_rd * eto->ev * cor_pprime[Z];
	B2 = -eto->eto_rc * eto->eto_r * eto->fu + eto->eto_rc * eto->fv * cor_pprime[Z];
	A3 = eto->eto_rd * eto->ev * dprime[Z];
	B3 = eto->eto_rc * eto->fv * dprime[Z];
	D1 = eto->eto_rc * eto->eto_rc * eto->eto_rd * eto->eto_rd;

	/*
	 *  Squaring the two terms above and again regrouping coefficients
	 *  the equation now becomes:
	 *
	 *  A6*t^2 + A5*t + A4 = -(A8*t + A7)*sqrt(C1 + C2*t + C3*t^2)
	 *
	 *  where, (variables defined in code)
	 */
	A4 = A1*A1*C1 + B1*B1*C1 + A2*A2 + B2*B2 - D1;
	A5 = A1*A1*C2 + B1*B1*C2 + 2*A2*A3 + 2*B2*B3;
	A6 = A1*A1*C3 + B1*B1*C3 + A3*A3 + B3*B3;
	A7 = 2*(A1*A2 + B1*B2);
	A8 = 2*(A1*A3 + B1*B3);
	term = A6*A6 - A8*A8*C3;

	/*
	 *  Squaring both sides and subtracting RHS from LHS yields:
	 */
	C.dgr=4;
	C.cf[4] = (A4*A4 - A7*A7*C1);			/* t^0 */
	C.cf[3] = (2*A4*A5 - A7*A7*C2 - 2*A7*A8*C1);	/* t^1 */
	C.cf[2] = (2*A4*A6 + A5*A5 - A7*A7*C3 - 2*A7*A8*C2 - A8*A8*C1);	/* t^2 */
	C.cf[1] = (2*A5*A6 - 2*A7*A8*C3 - A8*A8*C2);	/* t^3 */
	C.cf[0] = term;					/* t^4 */
	/* NOTE: End of ERIM based code */

	/*  It is known that the equation is 4th order.  Therefore,
	 *  if the root finder returns other than 4 roots, error.
	 */
	if ( (i = rt_poly_roots( &C, val, stp->st_dp->d_namep )) != 4 ){
		if( i > 0 )  {
			bu_log("eto:  rt_poly_roots() 4!=%d\n", i);
			bn_pr_roots( stp->st_name, val, i );
		} else if (i < 0) {
		    static int reported=0;
		    bu_log("The root solver failed to converge on a solution for %s\n", stp->st_dp->d_namep);
		    if (!reported) {
			VPRINT("while shooting from:\t", rp->r_pt);
			VPRINT("while shooting at:\t", rp->r_dir);
			bu_log("Additional elliptical torus convergence failure details will be suppressed.\n");
			reported=1;
		    }
		}
		return(0);		/* MISS */
	}

	/*  Only real roots indicate an intersection in real space.
	 *
	 *  Look at each root returned; if the imaginary part is zero
	 *  or sufficiently close, then use the real part as one value
	 *  of 't' for the intersections
	 */
	for ( j=0, i=0; j < 4; j++ ){
		if( NEAR_ZERO( val[j].im, 0.0001 ) )
			k[i++] = val[j].re;
	}

	/* reverse above translation by adding distance to all 'k' values. */
	for( j = 0; j < i; ++j )
		k[j] -= cor_proj;

	/* Here, 'i' is number of points found */
	switch( i )  {
	case 0:
		return(0);		/* No hit */

	default:
		bu_log("rt_eto_shot: reduced 4 to %d roots\n",i);
		bn_pr_roots( stp->st_name, val, 4 );
		return(0);		/* No hit */

	case 2:
		{
			/* Sort most distant to least distant. */
			fastf_t	u;
			if( (u=k[0]) < k[1] )  {
				/* bubble larger towards [0] */
				k[0] = k[1];
				k[1] = u;
			}
		}
		break;
	case 4:
		{
			register short	n;
			register short	lim;

			/*  Inline rt_pt_sort().  Sorts k[] into descending order. */
			for( lim = i-1; lim > 0; lim-- )  {
				for( n = 0; n < lim; n++ )  {
					fastf_t	u;
					if( (u=k[n]) < k[n+1] )  {
						/* bubble larger towards [0] */
						k[n] = k[n+1];
						k[n+1] = u;
					}
				}
			}
		}
		break;
	}

	/* Now, t[0] > t[npts-1] */
	/* k[1] is entry point, and k[0] is farthest exit point */
	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = k[1];
	segp->seg_out.hit_dist = k[0];
	/* Set aside vector for rt_eto_norm() later */
	VJOIN1( segp->seg_in.hit_vpriv, pprime, k[1], dprime );
	VJOIN1( segp->seg_out.hit_vpriv, pprime, k[0], dprime );
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );

	if( i == 2 )
		return(2);			/* HIT */

	/* 4 points */
	/* k[3] is entry point, and k[2] is exit point */
	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	segp->seg_in.hit_dist = k[3];
	segp->seg_out.hit_dist = k[2];
	VJOIN1( segp->seg_in.hit_vpriv, pprime, k[3], dprime );
	VJOIN1( segp->seg_out.hit_vpriv, pprime, k[2], dprime );
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(4);			/* HIT */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;
/**
 *			R T _ E T O _ V S H O T
 *
 *  This is the Becker vector version
 */
void
rt_eto_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
			       /* An array of solid pointers */
			       /* An array of ray pointers */
			       /* array of segs (results returned) */
			       /* Number of ray/object pairs */

{
}

/**
 *			R T _ E T O _ N O R M
 *
 *  Compute the normal to the eto,
 *  given a point on the eto centered at the origin on the X-Y plane.
 *  The gradient of the eto at that point is in fact the
 *  normal vector, which will have to be given unit length.
 *  To make this useful for the original eto, it will have
 *  to be rotated back to the orientation of the original eto.
 *  The equation for the eto is:
 *
 *            _______                           ________
 *           / 2    2              2           / 2    2               2
 *  [Eu(+- \/ x  + y   - R) + Ev z]  + [Fu(+-\/ x  + y   - R) + Fv z ]
 * --------------------------------    -------------------------------  = 1
 *               2                                      2
 *             Rc                                     Rd
 *
 *  The normal is the gradient of f(x,y,z) = 0 or
 *
 *	(df/dx, df/dy, df/dz)
 */
void
rt_eto_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;
	fastf_t sqrt_x2y2, efact, ffact, xcomp, ycomp, zcomp;
	vect_t normp;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );

	sqrt_x2y2 = sqrt( hitp->hit_vpriv[X] * hitp->hit_vpriv[X]
			+ hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] );

	efact = 2 * eto->eto_rd * eto->eto_rd * (eto->eu *
		(sqrt_x2y2 - eto->eto_r) + eto->ev * hitp->hit_vpriv[Z]);

	ffact = 2 * eto->eto_rc * eto->eto_rc * (eto->fu *
		(sqrt_x2y2 - eto->eto_r) + eto->fv * hitp->hit_vpriv[Z]);

	xcomp = (efact * eto->eu + ffact * eto->fu) / sqrt_x2y2;

	ycomp = hitp->hit_vpriv[Y] * xcomp;
	xcomp = hitp->hit_vpriv[X] * xcomp;
	zcomp = efact * eto->ev + ffact * eto->fv;

	VSET( normp, xcomp, ycomp, zcomp );
	VUNITIZE( normp );
	MAT3X3VEC( hitp->hit_normal, eto->eto_invR, normp );
}

/**
 *			R T _ E T O _ C U R V E
 *
 *  Return the curvature of the eto.
 */
void
rt_eto_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	fastf_t	a, b, ch, cv, dh, dv, k_circ, k_ell, phi, rad, xp,
		yp1, yp2, work;
	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;
	vect_t	Cp, Dp, Hit_Ell, Nu, Radius, Ru;

	a = eto->eto_rc;
	b = eto->eto_rd;
	VMOVE( Nu, eto->eto_N );
	VUNITIZE( Nu );

	/* take elliptical slice of eto at hit point */
	VSET( Ru, hitp->hit_vpriv[X], hitp->hit_vpriv[Y], 0. );
	VUNITIZE( Ru );
	VSCALE( Radius, Ru, eto->eto_r );

	/* get horizontal and vertical components of C and Rd */
	cv = VDOT( eto->eto_C, Nu );
	ch = sqrt( VDOT( eto->eto_C, eto->eto_C ) - cv * cv );
	/* angle between C and Nu */
	phi = acos( cv / MAGNITUDE(eto->eto_C) );
	dv = eto->eto_rd * sin(phi);
	dh = -eto->eto_rd * cos(phi);

	/* build coord system for ellipse: x,y directions are Dp,Cp */
	VCOMB2( Cp, ch, Ru, cv, Nu );
	VCOMB2( Dp, dh, Ru, dv, Nu );
	VUNITIZE( Cp );
	VUNITIZE( Dp );

	/* put hit point in cross sectional coordinates */
	VSUB2( Hit_Ell, hitp->hit_vpriv, Radius );
	xp = VDOT( Hit_Ell, Dp );
	/* yp = VDOT( Hit_Ell, Cp ); */

	/* calculate curvature along ellipse */
	/* k = y'' / (1 + y'^2) ^ 3/2 */
	rad = 1. / sqrt(1. - xp*xp/(a*a));
	yp1 = -b/(a*a)*xp*rad;
	yp2 = -b/(a*a)*rad*(xp*xp*rad*rad + 1.);
	work = 1 + yp1*yp1;
	k_ell = yp2 / (work*sqrt(work));

	/* calculate curvature along radial circle */
	k_circ = -1. / MAGNITUDE(Radius);

	if (fabs(k_ell) < fabs(k_circ)) {
		/* use 1st deriv for principle dir of curvature */
		VCOMB2( cvp->crv_pdir, xp, Dp, yp1, Cp );
		cvp->crv_c1 = k_ell;
		cvp->crv_c2 = k_circ;
	} else {
		VCROSS( cvp->crv_pdir, hitp->hit_normal, Radius );
		cvp->crv_c1 = k_circ;
		cvp->crv_c2 = k_ell;
	}
	VUNITIZE( cvp->crv_pdir );
}

/**
 *			R T _ E T O _ U V
 */
void
rt_eto_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	fastf_t	horz, theta_u, theta_v, vert;
	vect_t	Hit_Ell, Nu, Radius, Ru;

	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;

	/* take elliptical slice of eto at hit point */
	VSET( Ru, hitp->hit_vpriv[X], hitp->hit_vpriv[Y], 0. );
	VUNITIZE( Ru );
	VSCALE( Radius, Ru, eto->eto_r );
	/* put cross sectional ellipse at origin */
	VSUB2( Hit_Ell, hitp->hit_vpriv, Radius );

	/* find angle between Ru and Hit_Ell
	   (better for circle than ellipse...) */
	VMOVE( Nu, eto->eto_N );
	VUNITIZE( Nu );
	vert = VDOT( Hit_Ell, Nu );
	horz = VDOT( Hit_Ell, Ru );
	theta_u = atan2(vert, -horz);	/* tuck seam on eto inner diameter */

	/* find angle between hitp and x axis */
	theta_v = atan2(hitp->hit_vpriv[Y], hitp->hit_vpriv[X]);

	/* normalize to [0, 2pi] */
	if (theta_u < 0.)
		theta_u += bn_twopi;
	if (theta_v < 0.)
		theta_v += bn_twopi;

	/* normalize to [0, 1] */
	uvp->uv_u = theta_u/bn_twopi;
	uvp->uv_v = theta_v/bn_twopi;
	uvp->uv_du = uvp->uv_dv = 0;
}

/**
 *			R T _ E T O _ F R E E
 */
void
rt_eto_free(struct soltab *stp)
{
	register struct eto_specific *eto =
		(struct eto_specific *)stp->st_specific;

	bu_free( (char *)eto, "eto_specific");
}

int
rt_eto_class(void)
{
	return(0);
}

/**
 *			R T _ E T O _ P L O T
 *
 * The ETO has the following input fields:
 *	eto_V	V from origin to center
 *	eto_r	Radius scalar
 *	eto_N	Normal to plane of eto
 *	eto_C	Semimajor axis (vector) of eto cross section
 *	eto_rd	Semiminor axis length (scalar) of eto cross section
 *
 */
int
rt_eto_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	fastf_t		a, b;	/* axis lengths of ellipse */
	fastf_t		ang, ch, cv, dh, dv, ntol, dtol, phi, theta;
	fastf_t		*eto_ells;
	int		i, j, npts, nells;
	point_t		*ell;	/* array of ellipse points */
	point_t		Ell_V;	/* vertex of an ellipse */
	point_t		*rt_mk_ell();
	struct rt_eto_internal	*tip;
	vect_t		Au, Bu, Nu, Cp, Dp, Xu;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	a = MAGNITUDE( tip->eto_C );
	b = tip->eto_rd;

	if ( NEAR_ZERO(tip->eto_r, 0.0001) || NEAR_ZERO(b, 0.0001)
		|| NEAR_ZERO(a, 0.0001)) {
		bu_log("eto_plot: r, rd, or rc zero length\n");
		return(1);
	}

	/* Establish tolerances */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		dtol = 0.0;		/* none */
	} else {
		/*
		 * Convert relative to absolute by scaling smallest of
		 * radius and semi-minor axis
		 */
		if (tip->eto_r < b)
			dtol = ttol->rel * 2 * tip->eto_r;
		else
			dtol = ttol->rel * 2 * b;
	}
	if( ttol->abs <= 0.0 )  {
		if( dtol <= 0.0 )  {
			/* No tolerance given, use a default */
			if (tip->eto_r < b)
				dtol = 2 * 0.10 * tip->eto_r;	/* 10% */
			else
				dtol = 2 * 0.10 * b;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || dtol > ttol->abs )
			dtol = ttol->abs;
	}
	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 )
		ntol = ttol->norm;
	else
		/* tolerate everything */
		ntol = bn_pi;

	/* (x, y) coords for an ellipse */
	ell = rt_mk_ell( &npts, a, b, dtol, ntol );
	/* generate coordinate axes */
	VMOVE( Nu, tip->eto_N );
	VUNITIZE( Nu );			/* z axis of coord sys */
	bn_vec_ortho( Bu, Nu );		/* x axis */
	VUNITIZE( Bu );
	VCROSS( Au, Nu, Bu );		/* y axis */

	/* number of segments required in eto circles */
	nells = rt_num_circular_segments( dtol, tip->eto_r );
	theta = bn_twopi / nells;	/* put ellipse every theta rads */
	/* get horizontal and vertical components of C and Rd */
	cv = VDOT( tip->eto_C, Nu );
	ch = sqrt( VDOT( tip->eto_C, tip->eto_C ) - cv * cv );
	/* angle between C and Nu */
	phi = acos( cv / MAGNITUDE(tip->eto_C) );
	dv = tip->eto_rd * sin(phi);
	dh = -tip->eto_rd * cos(phi);

	/* make sure ellipse doesn't overlap itself when revolved */
	if (ch > tip->eto_r || dh > tip->eto_r) {
		bu_log("eto_plot: revolved ellipse overlaps itself\n");
		return(1);
	}

	/* get memory for nells ellipses */
	eto_ells = (fastf_t *)bu_malloc(nells * npts * sizeof(point_t), "ells[]");

	/* place each ellipse properly to make eto */
	for (i = 0, ang = 0.; i < nells; i++, ang += theta) {
		/* direction of current ellipse */
		VCOMB2( Xu, cos(ang), Bu, sin(ang), Au );
		VUNITIZE( Xu );
		/* vertex of ellipse */
		VJOIN1( Ell_V, tip->eto_V, tip->eto_r, Xu );
		/* coord system for ellipse: x,y directions are Dp,Cp */
		VCOMB2( Cp, ch, Xu, cv, Nu );
		VCOMB2( Dp, dh, Xu, dv, Nu );
		VUNITIZE( Cp );
		VUNITIZE( Dp );

/* convert 2D address to index into 1D array */
#define ETO_PT(www,lll)	((((www)%nells)*npts)+((lll)%npts))
#define ETO_PTA(ww,ll)	(&eto_ells[ETO_PT(ww,ll)*3])
#define ETO_NMA(ww,ll)	(norms[ETO_PT(ww,ll)])

		/* make ellipse */
		for (j = 0; j < npts; j++) {
			VJOIN2( ETO_PTA(i,j),
				Ell_V, ell[j][X], Dp, ell[j][Y], Cp );
		}
	}

	/* draw ellipses */
	for (i = 0; i < nells; i++) {
		RT_ADD_VLIST( vhead, ETO_PTA(i,npts-1), BN_VLIST_LINE_MOVE );
		for( j = 0; j < npts; j++ )
			RT_ADD_VLIST( vhead, ETO_PTA(i,j), BN_VLIST_LINE_DRAW );
	}

	/* draw connecting circles */
	for (i = 0; i < npts; i++) {
		RT_ADD_VLIST( vhead, ETO_PTA(nells-1,i), BN_VLIST_LINE_MOVE );
		for( j = 0; j < nells; j++ )
			RT_ADD_VLIST( vhead, ETO_PTA(j,i), BN_VLIST_LINE_DRAW );
	}

	bu_free( (char *)eto_ells, "ells[]" );
	return(0);
}

/**
 *	R T _ E L L 4
 *
 *	Approximate one fourth (1st quadrant) of an ellipse with line
 *	segments.  The initial single segment is broken at the point
 *	farthest from the ellipse if that point is not aleady within the
 *	distance and normal error tolerances.  The two resulting segments are
 *	passed recursively to this routine until each segment is within
 *	tolerance.
 */
int
rt_ell4(struct rt_pt_node *pts, fastf_t a, fastf_t b, fastf_t dtol, fastf_t ntol)
{
	fastf_t	dist, intr, m, theta0, theta1;
	int	n;
	point_t	mpt, p0, p1;
	vect_t	norm_line, norm_ell;
	struct rt_pt_node *new, *rt_ptalloc(void);

	/* endpoints of segment approximating ellipse */
	VMOVE( p0, pts->p );
	VMOVE( p1, pts->next->p );
	/* slope and intercept of segment */
	m = ( p1[X] - p0[X] ) / ( p1[Y] - p0[Y] );
	intr = p0[X] - m * p0[Y];
	/* point on ellipse with max dist between ellipse and line */
	mpt[Y] = a / sqrt( b*b / (m*m*a*a) + 1 );
	mpt[X] = b * sqrt( 1 - mpt[Y] * mpt[Y] / (a*a) );
	mpt[Z] = 0;
	/* max distance between that point and line */
	dist = fabs( m * mpt[Y] - mpt[X] + intr ) / sqrt( m * m + 1 );
	/* angles between normal of line and of ellipse at line endpoints */
	VSET( norm_line, m, -1., 0.);
	VSET( norm_ell, b * b * p0[Y], a * a * p0[X], 0. );
	VUNITIZE( norm_line );
	VUNITIZE( norm_ell );
	theta0 = fabs( acos( VDOT( norm_line, norm_ell )));
	VSET( norm_ell, b * b * p1[Y], a * a * p1[X], 0. );
	VUNITIZE( norm_ell );
	theta1 = fabs( acos( VDOT( norm_line, norm_ell )));
	/* split segment at widest point if not within error tolerances */
	if ( dist > dtol || theta0 > ntol || theta1 > ntol ) {
		/* split segment */
		new = rt_ptalloc();
		VMOVE( new->p, mpt );
		new->next = pts->next;
		pts->next = new;
		/* keep track of number of pts added */
		n = 1;
		/* recurse on first new segment */
		n += rt_ell4( pts, a, b, dtol, ntol );
		/* recurse on second new segment */
		n += rt_ell4( new, a, b, dtol, ntol );
	} else
		n  = 0;
	return( n );
}

/**
 *	R T _ M K _ E L L
 *
 *	Return pointer an array of points approximating an ellipse
 *	with semi-major and semi-minor axes a and b.  The line
 *	segments fall within the normal and distance tolerances
 *	of ntol and dtol.
 */
point_t *
rt_mk_ell( n, a, b, dtol, ntol )
int	*n;
fastf_t	a, b, dtol, ntol;
{
	int		i;
	point_t		*ell;
	struct rt_pt_node	*ell_quad, *oldpos, *pos, *rt_ptalloc(void);

	ell_quad = rt_ptalloc();
	VSET( ell_quad->p, b, 0., 0. );
	ell_quad->next = rt_ptalloc();
	VSET( ell_quad->next->p, 0., a, 0. );
	ell_quad->next->next = NULL;

	*n = rt_ell4( ell_quad, a, b, dtol, ntol );
	ell = (point_t *)bu_malloc(4*(*n+1)*sizeof(point_t), "rt_mk_ell pts");

	/* put 1st quad of ellipse into an array */
	pos = ell_quad;
	for (i = 0; i < *n+2; i++) {
		VMOVE( ell[i], pos->p );
		oldpos = pos;
		pos = pos->next;
		bu_free( (char *)oldpos, "rt_pt_node" );
	}
	/* mirror 1st quad to make 2nd */
	for (i = (*n+1)+1; i < 2*(*n+1); i++) {
		VMOVE( ell[i], ell[(*n*2+2)-i] );
		ell[i][X] = -ell[i][X];
	}
	/* mirror 2nd quad to make 3rd */
	for (i = 2*(*n+1); i < 3*(*n+1); i++) {
		VMOVE( ell[i], ell[i-(*n*2+2)] );
		ell[i][X] = -ell[i][X];
		ell[i][Y] = -ell[i][Y];
	}
	/* mirror 3rd quad to make 4th */
	for (i = 3*(*n+1); i < 4*(*n+1); i++) {
		VMOVE( ell[i], ell[i-(*n*2+2)] );
		ell[i][X] = -ell[i][X];
		ell[i][Y] = -ell[i][Y];
	}
	*n = 4*(*n + 1);
	return(ell);
}

/**
 *			R T _ E T O _ T E S S
 */
int
rt_eto_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	fastf_t		a, b;	/* axis lengths of ellipse */
	fastf_t		ang, ch, cv, dh, dv, ntol, dtol, phi, theta;
	fastf_t		*eto_ells = NULL;
	int		i, j, nfaces, npts, nells;
	point_t		*ell = NULL;	/* array of ellipse points */
	point_t		Ell_V;	/* vertex of an ellipse */
	point_t		*rt_mk_ell();
	struct rt_eto_internal	*tip;
	struct shell	*s;
	struct vertex	**verts = NULL;
	struct faceuse	**faces = NULL;
	struct vertex	**vertp[4];
	vect_t		Au, Bu, Nu, Cp, Dp, Xu;
	vect_t		*norms = NULL;	/* normal vectors for each vertex */
	int		fail=0;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	a = MAGNITUDE( tip->eto_C );
	b = tip->eto_rd;

	if ( NEAR_ZERO(tip->eto_r, 0.0001) || NEAR_ZERO(b, 0.0001)
		|| NEAR_ZERO(a, 0.0001)) {
		bu_log("eto_tess: r, rd, or rc zero length\n");
		fail = (-2);
		goto failure;
	}

	/* Establish tolerances */
	if( ttol->rel <= 0.0 || ttol->rel >= 1.0 )  {
		dtol = 0.0;		/* none */
	} else {
		/*
		 * Convert relative to absolute by scaling smallest of
		 * radius and semi-minor axis
		 */
		if (tip->eto_r < b)
			dtol = ttol->rel * 2 * tip->eto_r;
		else
			dtol = ttol->rel * 2 * b;
	}
	if( ttol->abs <= 0.0 )  {
		if( dtol <= 0.0 )  {
			/* No tolerance given, use a default */
			if (tip->eto_r < b)
				dtol = 2 * 0.10 * tip->eto_r;	/* 10% */
			else
				dtol = 2 * 0.10 * b;	/* 10% */
		} else {
			/* Use absolute-ized relative tolerance */
		}
	} else {
		/* Absolute tolerance was given, pick smaller */
		if( ttol->rel <= 0.0 || dtol > ttol->abs )
			dtol = ttol->abs;
	}
	/* To ensure normal tolerance, remain below this angle */
	if( ttol->norm > 0.0 )
		ntol = ttol->norm;
	else
		/* tolerate everything */
		ntol = bn_pi;

	/* (x, y) coords for an ellipse */
	ell = rt_mk_ell( &npts, a, b, dtol, ntol );
	/* generate coordinate axes */
	VMOVE( Nu, tip->eto_N );
	VUNITIZE( Nu );			/* z axis of coord sys */
	bn_vec_ortho( Bu, Nu );		/* x axis */
	VUNITIZE( Bu );
	VCROSS( Au, Nu, Bu );		/* y axis */

	/* number of segments required in eto circles */
	nells = rt_num_circular_segments( dtol, tip->eto_r );
	theta = bn_twopi / nells;	/* put ellipse every theta rads */
	/* get horizontal and vertical components of C and Rd */
	cv = VDOT( tip->eto_C, Nu );
	ch = sqrt( VDOT( tip->eto_C, tip->eto_C ) - cv * cv );
	/* angle between C and Nu */
	phi = acos( cv / MAGNITUDE(tip->eto_C) );
	dv = tip->eto_rd * sin(phi);
	dh = -tip->eto_rd * cos(phi);

	/* make sure ellipse doesn't overlap itself when revolved */
	if (ch > tip->eto_r || dh > tip->eto_r) {
		bu_log("eto_tess: revolved ellipse overlaps itself\n");
		fail = (-3);
		goto failure;
	}

	/* get memory for nells ellipses */
	eto_ells = (fastf_t *)bu_malloc(nells * npts * sizeof(point_t), "ells[]");
	norms = (vect_t *)bu_calloc( nells*npts , sizeof( vect_t ) , "rt_eto_tess: norms" );

	/* place each ellipse properly to make eto */
	for (i = 0, ang = 0.; i < nells; i++, ang += theta) {
		/* direction of current ellipse */
		VCOMB2( Xu, cos(ang), Bu, sin(ang), Au );
		VUNITIZE( Xu );
		/* vertex of ellipse */
		VJOIN1( Ell_V, tip->eto_V, tip->eto_r, Xu );
		/* coord system for ellipse: x,y directions are Dp,Cp */
		VCOMB2( Cp, ch, Xu, cv, Nu );
		VCOMB2( Dp, dh, Xu, dv, Nu );
		VUNITIZE( Cp );
		VUNITIZE( Dp );
		/* make ellipse */
		for (j = 0; j < npts; j++) {
			VJOIN2( ETO_PTA(i,j),
				Ell_V, ell[j][X], Dp, ell[j][Y], Cp );
			VBLEND2( ETO_NMA(i,j),
				a*a*ell[j][X], Dp , b*b*ell[j][Y], Cp );
			VUNITIZE( ETO_NMA(i,j) );
		}
	}

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	verts = (struct vertex **)bu_calloc( npts*nells, sizeof(struct vertex *),
		"rt_eto_tess *verts[]" );
	faces = (struct faceuse **)bu_calloc( npts*nells, sizeof(struct faceuse *),
		"rt_eto_tess *faces[]" );

	/* Build the topology of the eto */
	nfaces = 0;
	for( i = 0; i < nells; i++ )  {
		for( j = 0; j < npts; j++ )  {
			vertp[0] = &verts[ ETO_PT(i+0,j+0) ];
			vertp[1] = &verts[ ETO_PT(i+0,j+1) ];
			vertp[2] = &verts[ ETO_PT(i+1,j+1) ];
			vertp[3] = &verts[ ETO_PT(i+1,j+0) ];
			if( (faces[nfaces++] = nmg_cmface( s, vertp, 4 )) == (struct faceuse *)0 )  {
				bu_log("rt_eto_tess() nmg_cmface failed, i=%d/%d, j=%d/%d\n",
					i, nells, j, npts );
				nfaces--;
			}
		}
	}

	/* Associate vertex geometry */
	for( i = 0; i < nells; i++ )  {
		for( j = 0; j < npts; j++ )  {
			nmg_vertex_gv( verts[ETO_PT(i,j)], ETO_PTA(i,j) );
		}
	}

	/* Associate face geometry */
	for( i=0; i < nfaces; i++ )  {
		if( nmg_fu_planeeqn( faces[i], tol ) < 0 )
		{
			fail = (-1);
			goto failure;
		}
	}

	/* associate vertexuse normals */
	for( i=0 ; i<nells ; i++ )
	{
		for( j=0 ; j<npts ; j++ )
		{
			struct vertexuse *vu;
			vect_t rev_norm;

			VREVERSE( rev_norm , ETO_NMA(i,j) );

			NMG_CK_VERTEX( verts[ETO_PT(i,j)] );

			for( BU_LIST_FOR( vu , vertexuse , &verts[ETO_PT(i,j)]->vu_hd ) )
			{
				struct faceuse *fu;

				NMG_CK_VERTEXUSE( vu );

				fu = nmg_find_fu_of_vu( vu );
				NMG_CK_FACEUSE( fu );

				if( fu->orientation == OT_SAME )
					nmg_vertexuse_nv( vu , ETO_NMA(i,j) );
				else if( fu->orientation == OT_OPPOSITE )
					nmg_vertexuse_nv( vu , rev_norm );
			}
		}
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

failure:
	bu_free( (char *)ell, "rt_mk_ell pts" );
	bu_free( (char *)eto_ells, "ells[]" );
	bu_free( (char *)verts, "rt_eto_tess *verts[]" );
	bu_free( (char *)faces, "rt_eto_tess *faces[]" );
	bu_free( (char *)norms, "rt_eto_tess: norms[]" );

	return( fail );
}

/**
 *			R T _ E T O _ I M P O R T
 *
 *  Import a eto from the database format to the internal format.
 *  Apply modeling transformations at the same time.
 */
int
rt_eto_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_eto_internal	*tip;
	union record		*rp;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_eto_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ETO;
	ip->idb_meth = &rt_functab[ID_ETO];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_eto_internal), "rt_eto_internal");
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	tip->eto_magic = RT_ETO_INTERNAL_MAGIC;

	/* Apply modeling transformations */
	if (mat == NULL) mat = bn_mat_identity;
	MAT4X3PNT( tip->eto_V, mat, &rp->s.s_values[0*3] );
	MAT4X3VEC( tip->eto_N, mat, &rp->s.s_values[1*3] );
	MAT4X3VEC( tip->eto_C, mat, &rp->s.s_values[2*3] );
	tip->eto_r  = rp->s.s_values[3*3] / mat[15];
	tip->eto_rd = rp->s.s_values[3*3+1] / mat[15];

	if( tip->eto_r <= SMALL || tip->eto_rd <= SMALL )  {
		bu_log("rt_eto_import:  zero length R or Rd vector\n");
		return(-1);
	}

	return(0);		/* OK */
}

/**
 *			R T _ E T O _ E X P O R T
 *
 *  The name will be added by the caller.
 */
int
rt_eto_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_eto_internal	*tip;
	union record		*eto;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ETO )  return(-1);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "eto external");
	eto = (union record *)ep->ext_buf;

	eto->s.s_id = ID_SOLID;
	eto->s.s_type = ETO;

	if (MAGNITUDE(tip->eto_C) < RT_LEN_TOL
		|| MAGNITUDE(tip->eto_N) < RT_LEN_TOL
		|| tip->eto_r < RT_LEN_TOL
		|| tip->eto_rd < RT_LEN_TOL) {
		bu_log("rt_eto_export: not all dimensions positive!\n");
		return(-1);
	}

	if (tip->eto_rd > MAGNITUDE(tip->eto_C) ) {
		bu_log("rt_eto_export: semi-minor axis cannot be longer than semi-major axis!\n");
		return(-1);
	}

	/* Warning:  type conversion */
	VSCALE( &eto->s.s_values[0*3], tip->eto_V, local2mm );
	VSCALE( &eto->s.s_values[1*3], tip->eto_N, local2mm );
	VSCALE( &eto->s.s_values[2*3], tip->eto_C, local2mm );
	eto->s.s_values[3*3] = tip->eto_r * local2mm;
	eto->s.s_values[3*3+1] = tip->eto_rd * local2mm;

	return(0);
}

/**
 *			R T _ E T O _ I M P O R T 5
 *
 *  Import a eto from the database format to the internal format.
 *  Apply modeling transformations at the same time.
 */
int
rt_eto_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_eto_internal	*tip;
	fastf_t			vec[11];

	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 11 );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ETO;
	ip->idb_meth = &rt_functab[ID_ETO];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_eto_internal), "rt_eto_internal");

	tip = (struct rt_eto_internal *)ip->idb_ptr;
	tip->eto_magic = RT_ETO_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 11 );

	/* Apply modeling transformations */
	if (mat == NULL) mat = bn_mat_identity;
	MAT4X3PNT( tip->eto_V, mat, &vec[0*3] );
	MAT4X3VEC( tip->eto_N, mat, &vec[1*3] );
	MAT4X3VEC( tip->eto_C, mat, &vec[2*3] );
	tip->eto_r  = vec[3*3] / mat[15];
	tip->eto_rd = vec[3*3+1] / mat[15];

	if( tip->eto_r <= SMALL || tip->eto_rd <= SMALL )  {
		bu_log("rt_eto_import:  zero length R or Rd vector\n");
		return(-1);
	}

	return(0);		/* OK */
}

/**
 *			R T _ E T O _ E X P O R T 5
 *
 *  The name will be added by the caller.
 */
int
rt_eto_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_eto_internal	*tip;
	fastf_t			vec[11];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ETO )  return(-1);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 11;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "eto external");

	if (MAGNITUDE(tip->eto_C) < RT_LEN_TOL
		|| MAGNITUDE(tip->eto_N) < RT_LEN_TOL
		|| tip->eto_r < RT_LEN_TOL
		|| tip->eto_rd < RT_LEN_TOL) {
		bu_log("rt_eto_export: not all dimensions positive!\n");
		return(-1);
	}

	if (tip->eto_rd > MAGNITUDE(tip->eto_C) ) {
		bu_log("rt_eto_export: semi-minor axis cannot be longer than semi-major axis!\n");
		return(-1);
	}

	/* scale 'em into local buffer */
	VSCALE( &vec[0*3], tip->eto_V, local2mm );
	VSCALE( &vec[1*3], tip->eto_N, local2mm );
	VSCALE( &vec[2*3], tip->eto_C, local2mm );
	vec[3*3] = tip->eto_r * local2mm;
	vec[3*3+1] = tip->eto_rd * local2mm;

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 11 );

	return(0);
}

/**
 *			R T _ E T O _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_eto_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_eto_internal	*tip =
		(struct rt_eto_internal *)ip->idb_ptr;
	char				buf[256];

	RT_ETO_CK_MAGIC(tip);
	bu_vls_strcat( str, "Elliptical Torus (ETO)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		INTCLAMP(tip->eto_V[X] * mm2local),
		INTCLAMP(tip->eto_V[Y] * mm2local),
		INTCLAMP(tip->eto_V[Z] * mm2local) );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tN=(%g, %g, %g)\n",
		INTCLAMP(tip->eto_N[X] * mm2local),
		INTCLAMP(tip->eto_N[Y] * mm2local),
		INTCLAMP(tip->eto_N[Z] * mm2local) );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC=(%g, %g, %g) mag=%g\n",
		INTCLAMP(tip->eto_C[X] * mm2local),
		INTCLAMP(tip->eto_C[Y] * mm2local),
		INTCLAMP(tip->eto_C[Z] * mm2local),
		INTCLAMP(MAGNITUDE(tip->eto_C) * mm2local) );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tr=%g\n", INTCLAMP(tip->eto_r * mm2local));
	bu_vls_strcat( str, buf );

	sprintf(buf, "\td=%g\n", INTCLAMP(tip->eto_rd * mm2local));
	bu_vls_strcat( str, buf );

	return(0);
}

/**
 *			R T _ E T O _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_eto_ifree(struct rt_db_internal *ip)
{
	register struct rt_eto_internal	*tip;

	RT_CK_DB_INTERNAL(ip);
	tip = (struct rt_eto_internal *)ip->idb_ptr;
	RT_ETO_CK_MAGIC(tip);

	bu_free( (char *)tip, "eto ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@a36 4
#ifndef lint
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.22 2007/11/28 14:11:27 erikgreenwald Exp $ (BRL)";
#endif

d176 3
a178 2
	static vect_t	P, w1;	/* for RPP calculation */
	static vect_t	Au, Bu, Cu, Nu;
d333 6
a338 6
	static vect_t	dprime;		/* D' */
	static vect_t	pprime;		/* P' */
	static vect_t	work;		/* temporary vector */
	static bn_poly_t	C;		/* The final equation */
	static bn_complex_t	val[4];	/* The complex roots */
	static double	k[4];		/* The real roots */
d340 4
a343 4
	static int	j;
	static vect_t	cor_pprime;	/* new ray origin */
	static fastf_t	cor_proj;
	static fastf_t	A1,A2,A3,A4,A5,A6,A7,A8,B1,B2,B3,C1,C2,C3,D1,term;
d587 1
a587 1
	static vect_t normp;
@


14.22
log
@LOCAL->static, per machine.h deprecation list
@
text
@d38 1
a38 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.21 2007/09/15 16:23:12 brlcad Exp $ (BRL)";
d182 1
a182 1
	FAST fastf_t	ch, cv, dh, f, phi;
d492 1
a492 1
			FAST fastf_t	u;
d508 1
a508 1
					FAST fastf_t	u;
d589 1
a589 1
	FAST fastf_t sqrt_x2y2, efact, ffact, xcomp, ycomp, zcomp;
@


14.21
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d38 1
a38 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.20 2007/08/23 00:29:12 brlcad Exp $ (BRL)";
d180 2
a181 2
	LOCAL vect_t	P, w1;	/* for RPP calculation */
	LOCAL vect_t	Au, Bu, Cu, Nu;
d336 6
a341 6
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	work;		/* temporary vector */
	LOCAL bn_poly_t	C;		/* The final equation */
	LOCAL bn_complex_t	val[4];	/* The complex roots */
	LOCAL double	k[4];		/* The real roots */
d343 4
a346 4
	LOCAL int	j;
	LOCAL vect_t	cor_pprime;	/* new ray origin */
	LOCAL fastf_t	cor_proj;
	LOCAL fastf_t	A1,A2,A3,A4,A5,A6,A7,A8,B1,B2,B3,C1,C2,C3,D1,term;
d590 1
a590 1
	LOCAL vect_t normp;
@


14.20
log
@change behavior by 1.0e-77 or 1.0e-39 such that we now consistently check whether values are > or <= SMALL (or SMALL_FASTF) instead of just < in some places and > in others.  did not change the SQRT_SMALL_FASTFs (other than those via SMALL) just to make sure there are not any unexpected results with this batch first.  this should of course only tweak edge cases that are well within floating point fuss, but they should be all treated consistently regardless.
@
text
@d38 1
a38 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.19 2007/01/27 01:41:40 brlcad Exp $ (BRL)";
d45 1
a45 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.19
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.18 2007/01/26 05:28:47 brlcad Exp $ (BRL)";
d1244 1
a1244 1
	if( tip->eto_r < SMALL || tip->eto_rd < SMALL )  {
d1335 1
a1335 1
	if( tip->eto_r < SMALL || tip->eto_rd < SMALL )  {
@


14.18
log
@allow the import function transformation matrix argument to be NULL, use an identity matrix in that situation.
@
text
@d38 1
a38 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.17 2007/01/23 01:13:36 brlcad Exp $ (BRL)";
d379 2
a380 2
            _______                           ________
           / 2    2              2           / 2    2               2
d383 2
a384 2
               2                                      2
             Rc                                     Rd
d417 1
a417 1
   	B2 = -eto->eto_rc * eto->eto_r * eto->fu + eto->eto_rc * eto->fv * cor_pprime[Z];
d558 4
a561 4
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
@


14.17
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.16 2007/01/21 04:45:43 brlcad Exp $ (BRL)";
d1237 1
d1328 1
@


14.16
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d38 1
a38 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.15 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.15
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 1
/*@@{*/
d24 1
d39 1
a39 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.14 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
d1451 1
a1451 1
/*@@}*/
@


14.14
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1992-2006 United States Government as represented by
d39 1
a39 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.13 2006/01/22 23:37:39 brlcad Exp $ (BRL)";
@


14.13
log
@missing stddef.h for offsetof, convert references to offsetof to bu_offsetof
@
text
@d22 1
a22 1
/** \addtogroup g */
a36 1
/*@@}*/
d39 1
a39 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.12 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
d1451 1
@


14.12
log
@update copyright to 2006
@
text
@d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.11 2005/11/24 14:28:22 brlcad Exp $ (BRL)";
d45 1
a45 2


d48 3
a50 1
#include <string.h>
d53 1
d159 5
a163 5
    { "%f", 3, "V",   offsetof(struct rt_eto_internal, eto_V[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "N",   offsetof(struct rt_eto_internal, eto_N[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C",   offsetof(struct rt_eto_internal, eto_C[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r",   offsetof(struct rt_eto_internal, eto_r),    BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "r_d", offsetof(struct rt_eto_internal, eto_rd),   BU_STRUCTPARSE_FUNC_NULL },
@


14.11
log
@clamp the number being printed by the describe function to their closest integer if it's within hardware tolerance of an integer.  this is done only in the describe function for now so it's only cosmetic, though it could conceivably happen on store/load too.  (addresses sf 'bug'/request 1359253)
@
text
@d4 1
a4 1
 * Copyright (C) 1992-2005 United States Government as represented by
d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.10 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
@


14.10
log
@trailing ws
@
text
@d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.9 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
d1405 3
a1407 3
		tip->eto_V[X] * mm2local,
		tip->eto_V[Y] * mm2local,
		tip->eto_V[Z] * mm2local);
d1411 3
a1413 3
		tip->eto_N[X] * mm2local,
		tip->eto_N[Y] * mm2local,
		tip->eto_N[Z] * mm2local );
d1417 4
a1420 4
		tip->eto_C[X] * mm2local,
		tip->eto_C[Y] * mm2local,
		tip->eto_C[Z] * mm2local,
		MAGNITUDE(tip->eto_C) * mm2local);
d1423 1
a1423 1
	sprintf(buf, "\tr=%g\n", tip->eto_r * mm2local);
d1426 1
a1426 1
	sprintf(buf, "\td=%g\n", tip->eto_rd * mm2local);
@


14.9
log
@Doxygen changes
@
text
@d35 1
a35 1
 *  
d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.8 2005/05/02 00:49:38 brlcad Exp $ (BRL)";
d72 1
a72 1
 *  
d74 1
a74 1
 *  
d76 1
a76 1
 *  
d80 1
a80 1
 *  
d82 1
a82 1
 *  
d84 1
a84 1
 *  
d86 1
a86 1
 *  
d93 1
a93 1
 *  
d95 1
a95 1
 *  
d98 1
a98 1
 *  
d100 1
a100 1
 *  
d102 1
a102 1
 *  
d104 1
a104 1
 *  
d127 1
a127 1
 *  
d130 1
a130 1
 *  
d133 1
a133 1
 *  
d167 1
a167 1
 *  
d171 1
a171 1
 *  
d175 1
a175 1
 *  
d228 1
a228 1
	
d300 1
a300 1
		stp->st_min[X], stp->st_min[Y], stp->st_min[Z], 
d306 1
a306 1
 *  
d329 1
a329 1
 *  
d537 1
a537 1
				
d550 1
a550 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
d562 1
a562 1
                  	    
d606 1
a606 1
	
d608 1
a608 1
	
d612 1
a612 1
	
d668 1
a668 1
	
d842 1
a842 1
	
d870 1
a870 1
	
d877 1
a877 1
	
d1099 1
a1099 1
	
d1198 1
a1198 1
failure:	
d1282 1
a1282 1
	
d1368 1
a1368 1
	
d1422 1
a1422 1
	
d1425 1
a1425 1
	
@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d35 1
a35 1
 *
d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header$ (BRL)";
d72 1
a72 1
 *
d74 1
a74 1
 *
d76 1
a76 1
 *
d80 1
a80 1
 *
d82 1
a82 1
 *
d84 1
a84 1
 *
d86 1
a86 1
 *
d93 1
a93 1
 *
d95 1
a95 1
 *
d98 1
a98 1
 *
d100 1
a100 1
 *
d102 1
a102 1
 *
d104 1
a104 1
 *
d127 1
a127 1
 *
d130 1
a130 1
 *
d133 1
a133 1
 *
d167 1
a167 1
 *
d171 1
a171 1
 *
d175 1
a175 1
 *
d228 1
a228 1

d300 1
a300 1
		stp->st_min[X], stp->st_min[Y], stp->st_min[Z],
d306 1
a306 1
 *
d329 1
a329 1
 *
d537 1
a537 1

d550 1
a550 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;
d562 1
a562 1

d606 1
a606 1

d608 1
a608 1

d612 1
a612 1

d668 1
a668 1

d842 1
a842 1

d870 1
a870 1

d877 1
a877 1

d1099 1
a1099 1

d1198 1
a1198 1
failure:
d1282 1
a1282 1

d1368 1
a1368 1

d1422 1
a1422 1

d1425 1
a1425 1

@


14.8
log
@since the root solver returns a negative result when convergence fails, we can use that to print out additional information such as the ray starting point and ray direction.  needs some more testing, of course, and the static declaration may need to be moved. (sf request 1185997)
@
text
@d21 3
d25 1
a25 3
 *
 * Purpose -
 *	Intersect a ray with an Elliptical Torus
d37 2
d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.7 2005/04/29 14:22:52 lbutler Exp $ (BRL)";
d165 1
a165 1
/*
d282 1
a282 1
/*
d304 1
a304 1
/*
d551 1
a551 1
/*
d566 1
a566 1
/*
d618 1
a618 1
/*
d685 1
a685 1
/*
d727 1
a727 1
/*
d745 1
a745 1
/*
d889 1
a889 1
/*
d947 1
a947 1
/*
d1002 1
a1002 1
/*
d1208 1
a1208 1
/*
d1251 1
a1251 1
/*
d1298 1
a1298 1
/*
d1341 1
a1341 1
/*
d1387 1
a1387 1
/*
d1432 1
a1432 1
/*
@


14.7
log
@When the root finder rt_poly_findroot cannot find roots, it now tells you the name of the primitive.
This is not always an error.  Frequently, this results from a ray grazing the primitve.  However, it is
reasonable for the user to want to know and examine the primitive, and asses the impact on the analysis
being performed.
@
text
@d37 1
a37 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.6 2005/01/30 20:30:59 brlcad Exp $ (BRL)";
d449 1
a449 1
		if( i != 0 )  {
d452 9
@


14.6
log
@update copyright to 2005
@
text
@d37 1
a37 1
static const char RCSeto[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_eto.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
d448 1
a448 1
	if ( (i = rt_poly_roots( &C, val )) != 4 ){
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1992-2004 United States Government as represented by
d37 1
a37 1
static const char RCSeto[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_eto.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a34 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1992-2004 by the United States Army.
 *	All rights reserved.
d37 1
a37 1
static const char RCSeto[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_eto.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_eto.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_eto.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ E T O . C
d40 1
a40 1
static const char RCSeto[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_eto.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_eto.c,v 1.1 2004/05/20 15:20:00 morrison Exp $ (BRL)";
d1421 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d21 1
a21 1
static const char RCSeto[] = "@@(#)$Header: /cvs/brlcad/librt/g_eto.c,v 11.24 2004/05/10 15:30:46 erikg Exp $ (BRL)";
d24 1
a24 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

