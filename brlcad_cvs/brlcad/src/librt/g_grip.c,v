head	14.13;
access;
symbols
	rel-7-10-4:14.13
	STABLE:14.13.0.2
	stable-branch:14.1
	rel-7-10-2:14.12
	rel-7-10-0:14.11
	rel-7-8-4:14.6
	rel-7-8-2:14.5
	rel-7-8-0:14.5
	trimnurbs-branch:14.5.0.2
	help:14.5
	temp_tag:14.4
	bobWinPort-20051223-freeze:14.2
	postmerge-20051223-bobWinPort:14.4
	premerge-20051223-bobWinPort:14.4
	rel-7-6-6:14.4
	rel-7-6-4:14.3
	rel-7-6-2:14.2
	rel-7-6-branch:14.2.0.4
	rel-7-6-0:14.2
	rel-7-4-2:14.1
	rel-7-4-branch:14.1.0.2
	bobWinPort:14.2.0.2
	rel-7-4-0:14.1
	rel-7-2-6:14.1
	rel-7-2-4:14.1
	rel-7-2-2:14.1
	rel-7-2-0:14.1
	rel-7-0-4:14.1
	rel-7-0-2:14.1
	rel-7-0-1:14.1
	opensource-post:14.1
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.13
date	2007.08.23.00.29.12;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.05.18.04.13.48;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.27.01.41.40;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.26.05.28.47;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.24.19.36.35;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.5;

14.5
date	2006.01.22.23.37.39;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.11.24.14.28.22;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.2.4.1;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.57.53;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.01;	author morrison;	state Exp;
branches;
next	;

14.2.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.13
log
@change behavior by 1.0e-77 or 1.0e-39 such that we now consistently check whether values are > or <= SMALL (or SMALL_FASTF) instead of just < in some places and > in others.  did not change the SQRT_SMALL_FASTFs (other than those via SMALL) just to make sure there are not any unexpected results with this batch first.  this should of course only tweak edge cases that are well within floating point fuss, but they should be all treated consistently regardless.
@
text
@/*                        G _ G R I P . C
 * BRL-CAD
 *
 * Copyright (c) 1993-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_grip.c
 *
 *  Intersect a ray with a "grip" and return nothing.
 *
 *  A GRIP is defiend by a direction normal, a center and a
 *  height/magnitued vector.  The center is the control point used
 *  for all grip movements.
 *
 *  All Ray intersections return "missed"
 *
 *  The bounding box for a grip is emtpy.
 *
 *  Authors -
 *	Christopher T. Johnson
 *      Geometric Solutions, Inc.
 */

#ifndef lint
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.12 2007/05/18 04:13:48 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stddef.h>
#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nmg.h"
#include "db.h"
#include "rtgeom.h"
#include "./debug.h"

struct grip_specific {
	long	grip_magic;
	vect_t	grip_center;
	vect_t	grip_normal;
	fastf_t	grip_mag;
};
#define	GRIP_NULL	((struct grip_specific *)0)

const struct bu_structparse rt_grp_parse[] = {
	{ "%f", 3, "V", bu_offsetof(struct rt_grip_internal, center[X]), BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 3, "N", bu_offsetof(struct rt_grip_internal, normal[X]), BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 1, "L", bu_offsetof(struct rt_grip_internal, mag), BU_STRUCTPARSE_FUNC_NULL },
	{ {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
};

/**
 *  			R T _ G R P _ P R E P
 */
int
rt_grp_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_grip_internal *gip;
	register struct grip_specific *gripp;

	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	BU_GETSTRUCT( gripp, grip_specific);
	stp->st_specific = (genptr_t)gripp;

	VMOVE(gripp->grip_normal, gip->normal);
	VMOVE(gripp->grip_center, gip->center);
	gripp->grip_mag = gip->mag;

	/* No bounding sphere or bounding RPP is possible */
	VSETALL( stp->st_min, 0.0);
	VSETALL( stp->st_max, 0.0);

	stp->st_aradius = 0.0;
	stp->st_bradius = 0.0;
	return 0;		/* OK */
}

/**
 *  			R T _ G R P _ P R I N T
 */
void
rt_grp_print(register const struct soltab *stp)
{
	register const struct grip_specific *gripp =
		(struct grip_specific *)stp->st_specific;

	if( gripp == GRIP_NULL )  {
		bu_log("grip(%s):  no data?\n", stp->st_name);
		return;
	}
	VPRINT( "Center", gripp->grip_center);
	VPRINT( "Normal", gripp->grip_normal);
	bu_log( "mag = %f\n", gripp->grip_mag);
}

/**
 *			R T _ G R P _ S H O T
 *
 * Function -
 *	Shoot a ray at a GRIP
 *
 * Algorithm -
 * 	The intersection distance is computed.
 *
 * Returns -
 *	0	MISS
 *	>0	HIT
 */
int
rt_grp_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	return 0;	/* this has got to be the easiest */
			/* RT routine I've written */
}

#define RT_HALF_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/**
 *			R T _ G R P _ V S H O T
 *
 *  Vectorizing version.
 */
void
rt_grp_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
			       /* An array of solid pointers */
			       /* An array of ray pointers */
			       /* array of segs (results returned) */
			       /* Number of ray/object pairs */

{
	return;
}

/**
 *  			R T _ G R P _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 *  The normal is already filled in.
 */
void
rt_grp_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	bu_bomb("rt_grp_norm: grips should never be hit.\n");
}
/**
 *			R T _ G R P _ C U R V E
 *
 *  Return the "curvature" of the grip.
 */
void
rt_grp_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	bu_bomb("rt_grp_curve: nobody should be asking for curve of a grip.\n");
}

/**
 *  			R T _ G R P _ U V
 *
 *  For a hit on a face of an HALF, return the (u,v) coordinates
 *  of the hit point.  0 <= u,v <= 1.
 *  u extends along the Xbase direction
 *  v extends along the "Ybase" direction
 *  Note that a "toroidal" map is established, varying each from
 *  0 up to 1 and then back down to 0 again.
 */
void
rt_grp_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	bu_bomb("rt_grp_uv: nobody should be asking for UV of a grip.\n");
}

/**
 *			R T _ G R P _ F R E E
 */
void
rt_grp_free(struct soltab *stp)
{
	register struct grip_specific *gripp =
		(struct grip_specific *)stp->st_specific;

	bu_free( (char *)gripp, "grip_specific");
}

int
rt_grp_class(void)
{
	return(0);
}

/**
 *			R T _ G R P _ P L O T
 *
 * We represent a GRIP as a pyramid.  The center describes where
 * the center of the base is.  The normal describes which direction
 * the tip of the pyramid is.  Mag describes the distence from the
 * center to the tip. 1/4 of the width is the length of a base side.
 *
 */
int
rt_grp_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_grip_internal	*gip;
	vect_t xbase, ybase;	/* perpendiculars to normal */
	vect_t x1, x2;
	vect_t y1, y2;
	vect_t tip;

	RT_CK_DB_INTERNAL(ip);
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	/* The use of "x" and "y" here is not related to the axis */
	bn_vec_perp( xbase, gip->normal );
	VCROSS( ybase, xbase, gip->normal );

	/* Arrange for the cross to be 2 meters across */
	VUNITIZE( xbase );
	VUNITIZE( ybase);
	VSCALE( xbase, xbase, gip->mag/4.0 );
	VSCALE( ybase, ybase, gip->mag/4.0 );

	VADD2( x1, gip->center, xbase );
	VSUB2( x2, gip->center, xbase );
	VADD2( y1, gip->center, ybase );
	VSUB2( y2, gip->center, ybase );

	RT_ADD_VLIST( vhead, x1, BN_VLIST_LINE_MOVE );	/* the base */
	RT_ADD_VLIST( vhead, y1, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x2, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y2, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x1, BN_VLIST_LINE_DRAW );

	VSCALE( tip, gip->normal, gip->mag );
	VADD2( tip, gip->center, tip );

	RT_ADD_VLIST( vhead, x1,  BN_VLIST_LINE_MOVE ); /* the sides */
	RT_ADD_VLIST( vhead, tip, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, x2,  BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y1,  BN_VLIST_LINE_MOVE );
	RT_ADD_VLIST( vhead, tip, BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, y2,  BN_VLIST_LINE_DRAW );
	return(0);
}

/**
 *			R T _ G R P _ I M P O R T
 *
 *  Returns -
 *	-1	failure
 *	 0	success
 */
int
rt_grp_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_grip_internal	*gip;
	union record	*rp;

	fastf_t		orig_eqn[3*3];
	register double	f,t;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_grp_import: defective record, id=x%x\n", rp->u_id);
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_GRIP;
	ip->idb_meth = &rt_functab[ID_GRIP];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_grip_internal), "rt_grip_internal");
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	gip->magic = RT_GRIP_INTERNAL_MAGIC;

	rt_fastf_float( orig_eqn, rp->s.s_values, 3 );	/* 2 floats to many */

	/* Transform the point, and the normal */
	if (mat == NULL) mat = bn_mat_identity;
	MAT4X3PNT( gip->center, mat, &orig_eqn[0] );
	MAT4X3VEC( gip->normal, mat, &orig_eqn[3] );
	if ( NEAR_ZERO(mat[15], 0.001) ) {
		bu_bomb("rt_grip_import, scale factor near zero.");
	}
	gip->mag = orig_eqn[6]/mat[15];

	/* Verify that normal has unit length */
	f = MAGNITUDE( gip->normal );
	if( f <= SMALL )  {
		bu_log("rt_grp_import:  bad normal, len=%g\n", f );
		return(-1);		/* BAD */
	}
	t = f - 1.0;
	if( !NEAR_ZERO( t, 0.001 ) )  {
		/* Restore normal to unit length */
		f = 1/f;
		VSCALE( gip->normal, gip->normal, f );
	}
	return 0;			/* OK */
}

/**
 *			R T _ G R P _ E X P O R T
 */
int
rt_grp_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_grip_internal	*gip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_GRIP )  return(-1);
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "grip external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = GRP;
	VMOVE(&rec->s.s_grip_N, gip->normal);
	VMOVE(&rec->s.s_grip_C, gip->center);
	rec->s.s_grip_m = gip->mag;

	return(0);
}

int
rt_grp_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_grip_internal *gip;
	fastf_t			vec[7];
	register double		f,t;

	RT_CK_DB_INTERNAL( ip );
	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 7 );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_GRIP;
	ip->idb_meth = &rt_functab[ID_GRIP];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_grip_internal), "rt_grip_internal");

	gip = (struct rt_grip_internal *)ip->idb_ptr;
	gip->magic = RT_GRIP_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, 7 );

	/* Transform the point, and the normal */
	if (mat == NULL) mat = bn_mat_identity;
	MAT4X3PNT( gip->center, mat, &vec[0] );
	MAT4X3VEC( gip->normal, mat, &vec[3] );
	if ( NEAR_ZERO(mat[15], 0.001) ) {
		bu_bomb("rt_grip_import5, scale factor near zero.");
	}
	gip->mag = vec[6]/mat[15];

	/* Verify that normal has unit length */
	f = MAGNITUDE( gip->normal );
	if( f <= SMALL )  {
		bu_log("rt_grp_import:  bad normal, len=%g\n", f );
		return(-1);		/* BAD */
	}
	t = f - 1.0;
	if( !NEAR_ZERO( t, 0.001 ) )  {
		/* Restore normal to unit length */
		f = 1/f;
		VSCALE( gip->normal, gip->normal, f );
	}
	return 0;		/* OK */
}

/**
 *			R T _ G R I P _ E X P O R T 5
 *
 */
int
rt_grp_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_grip_internal *gip;
	fastf_t			vec[7];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_GRIP )  return(-1);
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * 7;
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "grip external");

	VSCALE( &vec[0], gip->center, local2mm );
	VMOVE( &vec[3], gip->normal );
	vec[6] = gip->mag * local2mm;

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, 7 );

	return 0;
}

/**
 *			R T _ G R P _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_grp_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_grip_internal	*gip =
		(struct rt_grip_internal *)ip->idb_ptr;
	char	buf[256];

	RT_GRIP_CK_MAGIC(gip);
	bu_vls_strcat( str, "grip\n");

	sprintf(buf, "\tN (%g, %g, %g)\n",
		V3INTCLAMPARGS(gip->normal));		/* should have unit length */

	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC (%g %g %g) mag=%g\n",
		INTCLAMP(gip->center[0]*mm2local),
		INTCLAMP(gip->center[1]*mm2local),
		INTCLAMP(gip->center[2]*mm2local),
		INTCLAMP(gip->mag*mm2local) );

	bu_vls_strcat( str, buf);
	return(0);
}

/**
 *			R T _ G R P _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_grp_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "grip ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/**
 *			R T _ G R P _ T E S S
 */
int
rt_grp_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_grip_internal	*gip;

	RT_CK_DB_INTERNAL(ip);
	gip = (struct rt_grip_internal *)ip->idb_ptr;
	RT_GRIP_CK_MAGIC(gip);

	/* XXX tess routine needed */
	return(-1);
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.12
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d40 1
a40 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.11 2007/01/27 01:41:40 brlcad Exp $ (BRL)";
d311 1
a311 1
	if( f < SMALL )  {
d386 1
a386 1
	if( f < SMALL )  {
@


14.11
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d40 1
a40 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.10 2007/01/26 05:28:47 brlcad Exp $ (BRL)";
d165 1
a165 1
	rt_bomb("rt_grp_norm: grips should never be hit.\n");
d175 1
a175 1
	rt_bomb("rt_grp_curve: nobody should be asking for curve of a grip.\n");
d191 1
a191 1
	rt_bomb("rt_grp_uv: nobody should be asking for UV of a grip.\n");
d305 1
a305 1
		rt_bomb("rt_grip_import, scale factor near zero.");
d380 1
a380 1
		rt_bomb("rt_grip_import5, scale factor near zero.");
@


14.10
log
@allow the import function transformation matrix argument to be NULL, use an identity matrix in that situation.
@
text
@d40 1
a40 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.9 2007/01/24 19:36:35 brlcad Exp $ (BRL)";
d147 4
a150 4
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
d451 1
a451 1
		INTCLAMP(gip->center[0]*mm2local), 
@


14.9
log
@seems to be a header that didn't update correctly -- accept implicit assignment of copyright via former brl-cad agreement, while retaining authorship details even though GSI is sadly now defunct.
@
text
@d40 1
a40 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.8 2007/01/23 01:13:37 brlcad Exp $ (BRL)";
d301 1
d376 1
@


14.8
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2007 United States Government as represented by
d36 1
a36 4
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1993 by Geometric Solutions, Inc.
 *	All rights reserved.
d40 1
a40 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.7 2007/01/21 04:45:43 brlcad Exp $ (BRL)";
@


14.7
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d43 1
a43 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.6 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
@


14.6
log
@Doxygen updates
@
text
@d1 20
d22 1
a22 1
/*@@{*/
d24 1
a26 1
 *
a37 1
 *
d44 1
a44 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.5 2006/01/22 23:37:39 brlcad Exp $ (BRL)";
d491 1
a491 1
/*@@}*/
@


14.5
log
@missing stddef.h for offsetof, convert references to offsetof to bu_offsetof
@
text
@d1 1
a1 1
/** \addtogroup g */
d3 1
a3 1
/** \file g_grip.c
a22 1
/*@@}*/
d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.4 2005/11/24 14:28:22 brlcad Exp $ (BRL)";
d472 1
@


14.4
log
@clamp the number being printed by the describe function to their closest integer if it's within hardware tolerance of an integer.  this is done only in the describe function for now so it's only cosmetic, though it could conceivably happen on store/load too.  (addresses sf 'bug'/request 1359253)
@
text
@d26 1
a26 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.3 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
d31 1
a31 2


d34 1
d52 3
a54 3
	{ "%f", 3, "V", offsetof(struct rt_grip_internal, center[X]), BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 3, "N", offsetof(struct rt_grip_internal, normal[X]), BU_STRUCTPARSE_FUNC_NULL },
	{ "%f", 1, "L", offsetof(struct rt_grip_internal, mag), BU_STRUCTPARSE_FUNC_NULL },
@


14.3
log
@trailing ws
@
text
@d26 1
a26 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.2 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
d430 1
a430 1
		V3ARGS(gip->normal));		/* should have unit length */
d435 4
a438 2
		gip->center[0]*mm2local, gip->center[1]*mm2local,
		gip->center[2]*mm2local, gip->mag*mm2local);
@


14.2
log
@Doxygen changes
@
text
@d14 1
a14 1
 *  
d17 2
a18 2
 *  
 *  
d26 1
a26 1
static const char RCSgrip[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_grip.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
d106 1
a106 1
 *  
d112 1
a112 1
 *  
d137 1
a137 1
                  	    
d166 1
a166 1
 *  
@


14.2.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d14 1
a14 1
 *
d17 2
a18 2
 *
 *
d26 1
a26 1
static const char RCSgrip[] = "@@(#)$Header$ (BRL)";
d106 1
a106 1
 *
d112 1
a112 1
 *
d137 1
a137 1

d166 1
a166 1
 *
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 4
a4 5
/*
 *			G _ G R I P . C
 *  
 *  Function -
 *  	Intersect a ray with a "grip" and return nothing.
d23 2
d26 1
a26 1
static const char RCSgrip[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_grip.c,v 1.3 2004/08/02 23:01:49 morrison Exp $ (BRL)";
d58 1
a58 1
/*
d86 1
a86 1
/*
d104 1
a104 1
/*
d126 1
a126 1
/*
d142 1
a142 1
/*
d153 1
a153 1
/*
d164 1
a164 1
/*
d180 1
a180 1
/*
d198 1
a198 1
/*
d253 1
a253 1
/*
d309 1
a309 1
/*
d383 1
a383 1
/*
d412 1
a412 1
/*
d442 1
a442 1
/*
d455 1
a455 1
/*
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_grip.c,v 1.2 2004/06/08 19:57:53 morrison Exp $ (BRL)";
d469 10
@


1.2
log
@bye bye externs.h
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header$ (BRL)";
d28 1
a28 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d25 1
a25 1
static const char RCSgrip[] = "@@(#)$Header: /cvs/brlcad/librt/g_grip.c,v 11.17 2004/05/10 15:30:46 erikg Exp $ (BRL)";
a36 1
#include "externs.h"
@

