head	14.27;
access;
symbols
	rel-7-10-4:14.23
	STABLE:14.23.0.2
	stable-branch:14.6
	rel-7-10-2:14.23
	rel-7-10-0:14.22
	rel-7-8-4:14.19
	rel-7-8-2:14.15
	rel-7-8-0:14.15
	trimnurbs-branch:14.15.0.2
	help:14.15
	temp_tag:14.13
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.13
	premerge-20051223-bobWinPort:14.13
	rel-7-6-6:14.13
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.27
date	2007.12.19.21.42.41;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.09.25.05.59.36;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.09.25.05.25.32;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.09.15.16.23.12;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.07.26.01.13.57;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.18;

14.18
date	2006.08.31.05.48.33;	author lbutler;	state Exp;
branches;
next	14.17;

14.17
date	2006.08.21.03.10.02;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.07.10.19.06.23;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.01.16.18.21.36;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.12.04.18.59.11;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.12.04.15.54.15;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.12.04.04.09.41;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.12.04.02.33.13;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.12.04.02.31.08;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.31.07;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.58;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.57;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.27
log
@fixed empty name crash when using mged 'lt' command.  this should fix a bug encountered in some crash logs that Craig Barker had and some mged crashes that he reported with 7.10.4.  the problem was an empty name being passed to lt which ended up getting passed to db_lookup and later bu_log as a null ... argument, which subequently caused the fwrite to fail and bu_bomb to kick off.
@
text
@/*                     D B _ L O O K U P . C
 * BRL-CAD
 *
 * Copyright (c) 1988-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup dbio */
/** @@{ */
/** @@file db_lookup.c
 *
 * Functions -
 *	db_dirhash	Compute hashing function
 *	db_lookup	Convert an object name into directory pointer
 *	db_diradd	Add entry to the directory
 *	db_dirdelete	Delete entry from directory
 *	db_rename	Change name string of a directory entry
 *	db_pr_dir	Print contents of database directory
 *
 *
 *  Authors -
 *	Michael John Muuss
 *
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.26 2007/09/25 05:59:36 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"

#include "./debug.h"


/**
 *			D B _ I S _ D I R E C T O R Y _ N O N _ E M P T Y
 *
 *  Returns -
 *	0	if the in-memory directory is empty
 *	1	if the in-memory directory has entries,
 *		which implies that a db_scan() has already been performed.
 */
int
db_is_directory_non_empty(const struct db_i	*dbip)
{
    register int	i;

    RT_CK_DBI(dbip);

    for (i = 0; i < RT_DBNHASH; i++)  {
	if( dbip->dbi_Head[i] != DIR_NULL )
	    return 1;
    }
    return 0;
}

/**
 *			D B _ G E T _ D I R E C T O R Y _ S I Z E
 *
 *  Return the number of "struct directory" nodes in the given database.
 */
int
db_get_directory_size(const struct db_i *dbip)
{
    register struct directory *dp;
    register int	count = 0;
    int		i;

    RT_CK_DBI(dbip);

    for (i = 0; i < RT_DBNHASH; i++)  {
	for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
	    count++;
    }
    return count;
}

/**
 *			D B _ C K _ D I R E C T O R Y
 *
 *  For debugging, ensure that all the linked-lists for the directory
 *  structure are intact.
 */
void
db_ck_directory(const struct db_i *dbip)
{
    register struct directory *dp;
    int		i;

    RT_CK_DBI(dbip);

    for (i = 0; i < RT_DBNHASH; i++)  {
	for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
	    RT_CK_DIR(dp);
    }
}

/**
 *			D B _ D I R H A S H
 *
 *  Internal function to return pointer to head of hash chain
 *  corresponding to the given string.
 */
int
db_dirhash(const char *str)
{
    register const unsigned char *s = (unsigned char *)str;
    register long sum;
    register int i;

    sum = 0;
    /* BSD name hashing starts i=0, discarding first char.  why? */
    for( i=1; *s; )
	sum += *s++ * i++;

    return( RT_DBHASH(sum) );
}

/**
 *  Name -
 *	D B _ D I R C H E C K
 *
 *  Description -
 *	This routine ensures that ret_name is not already in the
 *	directory. If it is, it tries a fixed number of times to
 *	modify ret_name before giving up. Note - most of the time,
 *	the hash for ret_name is computed once.
 *
 *  Inputs -
 *	dbip		database instance pointer
 *	ret_name	the original name
 *	noisy		to blather or not
 *
 *  Outputs -
 *	ret_name	the name to use
 *	headp		pointer to the first (struct directory *) in the bucket
 *
 *  Returns -
 *	 0	success
 *	<0	fail
 */
int
db_dircheck(struct db_i		*dbip,
	    struct bu_vls	*ret_name,
	    int			noisy,
	    struct directory	***headp)
{
    register struct directory	*dp;
    register char			*cp = bu_vls_addr(ret_name);
    register char			n0 = cp[0];
    register char			n1 = cp[1];

    /* Compute hash only once (almost always the case) */
    *headp = &(dbip->dbi_Head[db_dirhash(cp)]);

    for (dp = **headp; dp != DIR_NULL; dp=dp->d_forw) {
	register char	*this;
	if (n0 == *(this=dp->d_namep)  &&	/* speed */
	    n1 == this[1]  &&			/* speed */
	    strcmp(cp, this) == 0) {
	    /* Name exists in directory already */
	    register int	c;

	    bu_vls_strcpy(ret_name, "A_");
	    bu_vls_strcat(ret_name, this);

	    for (c = 'A'; c <= 'Z'; c++) {
		*cp = c;
		if (db_lookup(dbip, cp, noisy) == DIR_NULL)
		    break;
	    }
	    if (c > 'Z') {
		bu_log("db_dircheck: Duplicate of name '%s', ignored\n",
		       cp);
		return -1;	/* fail */
	    }
	    bu_log("db_dircheck: Duplicate of '%s', given temporary name '%s'\n",
		   cp+2, cp);

	    /* no need to recurse, simply recompute the hash and break */
	    *headp = &(dbip->dbi_Head[db_dirhash(cp)]);
	    break;
	}
    }

    return 0;	/* success */
}


/**
 *			D B _ L O O K U P
 *
 * This routine takes a name and looks it up in the
 * directory table.  If the name is present, a pointer to
 * the directory struct element is returned, otherwise
 * NULL is returned.
 *
 * If noisy is non-zero, a print occurs, else only
 * the return code indicates failure.
 *
 *  Returns -
 *	struct directory	if name is found
 *	DIR_NULL		on failure
 */
struct directory *
db_lookup(const struct db_i *dbip, register const char *name, int noisy)
{
    register struct directory *dp;
    register char	n0;
    register char	n1;

    if (!name || name[0] == '\0') {
	if (noisy || RT_G_DEBUG&DEBUG_DB)
	    bu_log("db_lookup received NULL or empty name\n");
	return (DIR_NULL);
    }

    n0 = name[0];
    n1 = name[1];

    RT_CK_DBI(dbip);

    dp = dbip->dbi_Head[db_dirhash(name)];
    for(; dp != DIR_NULL; dp=dp->d_forw) {
	register char	*this;

	/* first two checks are for speed */
	if ( (n0 == *(this=dp->d_namep)) && (n1 == this[1]) && (strcmp( name, this ) == 0) ) {
	    if (RT_G_DEBUG&DEBUG_DB)
		bu_log("db_lookup(%s) x%x\n", name, dp);
	    return(dp);
	}
    }

    if (noisy || RT_G_DEBUG&DEBUG_DB)
	bu_log("db_lookup(%s) failed: %s does not exist\n", name, name);

    return( DIR_NULL );
}


/**
 *			D B _ D I R A D D
 *
 * Add an entry to the directory.
 * Try to make the regular path through the code as fast as possible,
 * to speed up building the table of contents.
 *
 * dbip is a pointer to a valid/opened database instance
 * name is the string name of the object being added
 * laddr is the long offset into the file to the object
 * len is the length of the object, number of db granules used
 * flags are defined in raytrace.h (DIR_SOLID, DIR_COMB, DIR_REGION, RT_DIR_INMEM, etc)
 * for db version 5, ptr is the minor_type (non-null pointer to valid unsigned char code)
 *
 * an laddr of RT_DIR_PHONY_ADDR (-1L) means that database storage has
 * not been allocated yet.
 */
struct directory *
db_diradd(register struct db_i *dbip, register const char *name, long int laddr, int len, int flags, genptr_t ptr)
{
    struct directory **headp;
    register struct directory *dp;
    char *tmp_ptr;
    struct bu_vls	local;

    RT_CK_DBI(dbip);

    if(RT_G_DEBUG&DEBUG_DB)  {
	bu_log("db_diradd(dbip=0x%x, name='%s', addr=0x%x, len=%d, flags=0x%x, ptr=0x%x)\n",
	       dbip, name, laddr, len, flags, ptr );
    }

    if( (tmp_ptr=strchr( name, '/' )) != NULL )  {
	/* if this is a version 4 database and the offending char is beyond NAMESIZE
	 * then it is not really a problem
	 */
	if( dbip->dbi_version < 5 && (tmp_ptr - name) < 16 ) {
	    bu_log("db_diradd() object named '%s' is illegal, ignored\n", name );
	    return DIR_NULL;
	}
    }

    bu_vls_init(&local);
    if( dbip->dbi_version < 5 ) {
	bu_vls_strncpy(&local, name, NAMESIZE);
    } else {
	/* must provide a valid minor type */
	if (!ptr) {
	    bu_log("WARNING: db_diradd() called with a null minor type pointer for object %s\nIgnoring %s\n", name, name);
	    bu_vls_free(&local);
	    return DIR_NULL;
	}
	bu_vls_strcpy(&local, name);
    }
    if (db_dircheck(dbip, &local, 0, &headp) < 0) {
	bu_vls_free(&local);
	return DIR_NULL;
    }

    /* 'name' not found in directory, add it */
    RT_GET_DIRECTORY(dp, &rt_uniresource);
    RT_CK_DIR(dp);
    RT_DIR_SET_NAMEP(dp, bu_vls_addr(&local));	/* sets d_namep */
    dp->d_un.file_offset = laddr;
    dp->d_flags = flags & ~(RT_DIR_INMEM);
    dp->d_len = len;
    dp->d_forw = *headp;
    BU_LIST_INIT( &dp->d_use_hd );
    *headp = dp;
    dp->d_animate = NULL;
    dp->d_nref = 0;
    dp->d_uses = 0;
    if( dbip->dbi_version > 4 ) {
	dp->d_major_type = DB5_MAJORTYPE_BRLCAD;
	dp->d_minor_type = *(unsigned char *)ptr;
    }
    bu_vls_free(&local);
    return( dp );
}


/**
 *  			D B _ D I R D E L E T E
 *
 *  Given a pointer to a directory entry, remove it from the
 *  linked list, and free the associated memory.
 *
 *  It is the responsibility of the caller to have released whatever
 *  structures have been hung on the d_use_hd bu_list, first.
 *
 *  Returns -
 *	 0	on success
 *	-1	on failure
 */
int
db_dirdelete(register struct db_i *dbip, register struct directory *dp)
{
    register struct directory *findp;
    register struct directory **headp;

    RT_CK_DBI(dbip);
    RT_CK_DIR(dp);

    headp = &(dbip->dbi_Head[db_dirhash(dp->d_namep)]);

    if( dp->d_flags & RT_DIR_INMEM )
	{
	    if( dp->d_un.ptr != NULL )
		bu_free( dp->d_un.ptr, "db_dirdelete() inmem ptr" );
	}

    if( *headp == dp )  {
	RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */
	*headp = dp->d_forw;

	/* Put 'dp' back on the freelist */
	dp->d_forw = rt_uniresource.re_directory_hd;
	rt_uniresource.re_directory_hd = dp;
	return(0);
    }
    for( findp = *headp; findp != DIR_NULL; findp = findp->d_forw )  {
	if( findp->d_forw != dp )
	    continue;
	RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */
	findp->d_forw = dp->d_forw;

	/* Put 'dp' back on the freelist */
	dp->d_forw = rt_uniresource.re_directory_hd;
	rt_uniresource.re_directory_hd = dp;
	return(0);
    }
    return(-1);
}

/**
 *			D B _ R E N A M E
 *
 *  Change the name string of a directory entry.
 *  Because of the hashing function, this takes some extra work.
 *
 *  Returns -
 *	 0	on success
 *	-1	on failure
 */
int
db_rename(register struct db_i *dbip, register struct directory *dp, const char *newname)
{
    register struct directory *findp;
    register struct directory **headp;

    RT_CK_DBI(dbip);
    RT_CK_DIR(dp);

    /* Remove from linked list */
    headp = &(dbip->dbi_Head[db_dirhash(dp->d_namep)]);
    if( *headp == dp )  {
	/* Was first on list, dequeue */
	*headp = dp->d_forw;
    } else {
	for( findp = *headp; findp != DIR_NULL; findp = findp->d_forw )  {
	    if( findp->d_forw != dp )
		continue;
	    /* Dequeue */
	    findp->d_forw = dp->d_forw;
	    goto out;
	}
	return(-1);		/* ERROR: can't find */
    }

 out:
    /* Effect new name */
    RT_DIR_FREE_NAMEP(dp);			/* frees d_namep */
    RT_DIR_SET_NAMEP( dp, newname );	/* sets d_namep */

    /* Add to new linked list */
    headp = &(dbip->dbi_Head[db_dirhash(newname)]);
    dp->d_forw = *headp;
    *headp = dp;
    return(0);
}

/**
 *			D B _ P R _ D I R
 *
 *  For debugging, print the entire contents of the database directory.
 */
void
db_pr_dir(register const struct db_i *dbip)
{
    register const struct directory *dp;
    register char		*flags;
    register int		i;

    RT_CK_DBI(dbip);

    bu_log("db_pr_dir(x%x):  Dump of directory for file %s [%s]\n",
	   dbip, dbip->dbi_filename,
	   dbip->dbi_read_only ? "READ-ONLY" : "Read/Write" );

    bu_log("Title = %s\n", dbip->dbi_title);
    /* units ? */

    for( i = 0; i < RT_DBNHASH; i++ )  {
	for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp=dp->d_forw )  {
	    if( dp->d_flags & DIR_SOLID )
		flags = "SOL";
	    else if( (dp->d_flags & (DIR_COMB|DIR_REGION)) ==
		     (DIR_COMB|DIR_REGION) )
		flags = "REG";
	    else if( (dp->d_flags & (DIR_COMB|DIR_REGION)) ==
		     DIR_COMB )
		flags = "COM";
	    else
		flags = "Bad";
	    bu_log("x%.8x %s %s=x%.8x len=%.5d use=%.2d nref=%.2d %s",
		   dp,
		   flags,
		   dp->d_flags & RT_DIR_INMEM ? "  ptr " : "d_addr",
		   dp->d_addr,
		   dp->d_len,
		   dp->d_uses,
		   dp->d_nref,
		   dp->d_namep );
	    if( dp->d_animate )
		bu_log(" anim=x%x\n", dp->d_animate );
	    else
		bu_log("\n");
	}
    }
}


/**
 *  			D B _ G E T _ D I R E C T O R Y
 *
 *  This routine is called by the RT_GET_DIRECTORY macro when the freelist
 *  is exhausted.  Rather than simply getting one additional structure,
 *  we get a whole batch, saving overhead.
 */
void
db_get_directory(register struct resource *resp)
{
    register struct directory	*dp;
    register int		bytes;

    RT_CK_RESOURCE(resp);
    BU_CK_PTBL( &resp->re_directory_blocks );

    BU_ASSERT_PTR( resp->re_directory_hd, ==, NULL );

    /* Get a BIG block */
    bytes = bu_malloc_len_roundup(1024*sizeof(struct directory));
    dp = (struct directory *)bu_malloc(bytes, "re_directory_blocks from db_get_directory() " BU_FLSTR);

    /* Record storage for later */
    bu_ptbl_ins( &resp->re_directory_blocks, (long *)dp );

    while( bytes >= sizeof(struct directory) )  {
	dp->d_magic = RT_DIR_MAGIC;
	dp->d_forw = resp->re_directory_hd;
	resp->re_directory_hd = dp;
	dp++;
	bytes -= sizeof(struct directory);
    }
}

/**
 *			D B _ L O O K U P _ B Y _ A T T R
 *
 * lookup directory entries based on directory flags (dp->d_flags) and
 * attributes the "dir_flags" arg is a mask for the directory flags
 * the *"avs" is an attribute value set used to select from the
 * objects that *pass the flags mask. if "op" is 1, then the object
 * must have all the *attributes and values that appear in "avs" in
 * order to be *selected. If "op" is 2, then the object must have at
 * least one of *the attribute/value pairs from "avs".
 *
 * dir_flags are in the form used in struct directory (d_flags)
 *
 * for op:
 * 1 -> all attribute name/value pairs must be present and match
 * 2 -> at least one of the name/value pairs must be present and match
 *
 * returns a ptbl list of selected directory pointers an empty list
 * means nothing met the requirements a NULL return means something
 * went wrong.
 */
struct bu_ptbl *
db_lookup_by_attr(struct db_i *dbip, int dir_flags, struct bu_attribute_value_set *avs, int op)
{
    struct bu_attribute_value_set obj_avs;
    struct directory *dp;
    struct bu_ptbl *tbl;
    int match_count=0;
    int attr_count;
    int i,j;
    int draw;

    RT_CK_DBI(dbip);

    if( avs ) {
	BU_CK_AVS( avs );
	attr_count = avs->count;
    } else {
	attr_count = 0;
    }

    tbl = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ), "wdb_get_by_attr ptbl" );
    bu_ptbl_init( tbl, 128, "wdb_get_by_attr ptbl_init" );

    FOR_ALL_DIRECTORY_START(dp,dbip) {

	if( (dp->d_flags & dir_flags) == 0 ) continue;

	if(attr_count ) {
	    bu_avs_init_empty(&obj_avs);
	    if( db5_get_attributes( dbip, &obj_avs, dp ) < 0 ) {
		bu_log( "ERROR: failed to get attributes for %s\n", dp->d_namep );
		return( (struct bu_ptbl *)NULL );
	    }
	    
	    draw = 0;
	    match_count = 0;
	    for( i=0 ; i<avs->count ; i++ ) {
		for( j=0 ; j<obj_avs.count ; j++ ) {
		    if( !strcmp( avs->avp[i].name, obj_avs.avp[j].name ) ) {
			if( !strcmp( avs->avp[i].value, obj_avs.avp[j].value ) ) {
			    if( op == 2 ) {
				draw = 1;
				break;
			    } else {
				match_count++;
			    }
			}
		    }
		}
		if( draw ) break;
	    }

	    bu_avs_free( &obj_avs );
	} else {
	    draw = 1;
	}
	if( draw || match_count == attr_count ) {
	    bu_ptbl_ins( tbl , (long *)dp );
	}
    } FOR_ALL_DIRECTORY_END;

    return( tbl );
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.26
log
@prevent a crash if we're using db5_get_attributes() and the object doesn't have any of the attributes we're looking for.  we need to at least initialize the avs to empty, otherwise bu_avs_free will abort on a magic number check.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.25 2007/09/25 05:25:32 brlcad Exp $ (BRL)";
d232 3
a234 2
    if (!name) {
	bu_log("db_lookup received NULL name\n");
d244 1
a244 1
    for(; dp != DIR_NULL; dp=dp->d_forw )  {
d246 5
a250 6
	if(
	   n0 == *(this=dp->d_namep)  &&	/* speed */
	   n1 == this[1]  &&	/* speed */
	   strcmp( name, this ) == 0
	   )  {
	    if(RT_G_DEBUG&DEBUG_DB) bu_log("db_lookup(%s) x%x\n", name, dp);
d255 3
a257 1
    if(noisy || RT_G_DEBUG&DEBUG_DB) bu_log("db_lookup(%s) failed: %s does not exist\n", name, name);
d261 1
@


14.25
log
@add braces for proper indent
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.24 2007/09/15 16:23:12 brlcad Exp $ (BRL)";
d565 1
d574 1
d597 1
@


14.24
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.23 2007/07/26 01:13:57 brlcad Exp $ (BRL)";
d567 3
a569 1
    FOR_ALL_DIRECTORY_START(dp,dbip)
a570 5
    if(attr_count ) {
	if( db5_get_attributes( dbip, &obj_avs, dp ) < 0 ) {
	    bu_log( "ERROR: failed to get attributes for %s\n", dp->d_namep );
	    return( (struct bu_ptbl *)NULL );
	}
d572 18
a589 11
	draw = 0;
	match_count = 0;
	for( i=0 ; i<avs->count ; i++ ) {
	    for( j=0 ; j<obj_avs.count ; j++ ) {
		if( !strcmp( avs->avp[i].name, obj_avs.avp[j].name ) ) {
		    if( !strcmp( avs->avp[i].value, obj_avs.avp[j].value ) ) {
			if( op == 2 ) {
			    draw = 1;
			    break;
			} else {
			    match_count++;
d593 1
d595 3
a597 1
	    if( draw ) break;
d599 4
a602 8
	bu_avs_free( &obj_avs );
    } else {
	draw = 1;
    }
    if( draw || match_count == attr_count ) {
	bu_ptbl_ins( tbl , (long *)dp );
    }
    FOR_ALL_DIRECTORY_END
d604 1
a604 1
	return( tbl );
@


14.23
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.22 2007/01/23 01:13:36 brlcad Exp $ (BRL)";
d45 1
a45 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.22
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a35 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.21 2007/01/21 04:45:43 brlcad Exp $ (BRL)";
@


14.21
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.20 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.20
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.19 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
d614 1
a614 1
/*@@}*/
@


14.19
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2006 United States Government as represented by
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.18 2006/08/31 05:48:33 lbutler Exp $ (BRL)";
@


14.18
log
@added BU_FLSTR to malloc/free to help track down memory creation/leaks
@
text
@d22 1
a22 1
/** \addtogroup db */
a44 1
/*@@}*/
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.17 2006/08/21 03:10:02 brlcad Exp $ (BRL)";
d616 1
@


14.17
log
@s/RT_RESOURCE_CHECK/RT_CK_RESOURCE/g .. we really don't need two macros that do the exact same check.  consolidate to just one sans a deprecation warning, using the prevalent CK convention instead.
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.16 2006/07/10 19:06:23 brlcad Exp $ (BRL)";
d524 1
a524 1
    dp = (struct directory *)bu_malloc(bytes, "db_get_directory()");
@


14.16
log
@refactor away the old BSD block defines among other simple cleanup
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.15 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
d517 1
a517 1
    RT_RESOURCE_CHECK(resp);
@


14.15
log
@update copyright to 2006
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.14 2006/01/16 18:21:36 brlcad Exp $ (BRL)";
d145 1
a145 1
    /* BSD namei hashing starts i=0, discarding first char.  why? */
@


14.14
log
@begin consolidating the in-memory-only database geometry support into one plcae.  move db_inmem() to its own db_inmem.c file, adding two new routines for opening/creating in-memory databases via db_open_inmem() and db_create_inmem().  difference between the two being that create adds a _GLOBAL while open does not.
@
text
@d4 1
a4 1
 * Copyright (C) 1988-2005 United States Government as represented by
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.13 2005/12/04 18:59:11 brlcad Exp $ (BRL)";
@


14.13
log
@abort earlier instead of later and make it a runtime failure instead of a hard application abort
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.12 2005/12/04 15:54:15 brlcad Exp $ (BRL)";
a351 26
/**
 *			D B _ I N M E M
 *
 *  Transmogrify an existing directory entry to be an in-memory-only
 *  one, stealing the external representation from 'ext'.
 */
void
db_inmem(struct directory *dp, struct bu_external *ext, int flags, struct db_i *dbip)
{
    BU_CK_EXTERNAL(ext);
    RT_CK_DIR(dp);

    if( dp->d_flags & RT_DIR_INMEM )
	bu_free( dp->d_un.ptr, "db_inmem() ext ptr" );
    dp->d_un.ptr = ext->ext_buf;
    if( dbip->dbi_version < 5 ) {
	dp->d_len = ext->ext_nbytes / 128;	/* DB_MINREC granule size */
    } else {
	dp->d_len = ext->ext_nbytes;
    }
    dp->d_flags = flags | RT_DIR_INMEM;

    /* Empty out the external structure, but leave it w/valid magic */
    ext->ext_buf = (genptr_t)NULL;
    ext->ext_nbytes = 0;
}
@


14.12
log
@protect from crashing by aborting if a db_diradd caller passes a null minor type
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.11 2005/12/04 04:09:41 brlcad Exp $ (BRL)";
d284 1
a284 1
 * for db version 5, ptr is the minor_type (pointer to unsigned char code)
d318 6
a345 4
	if (!ptr) {
	    bu_log("ERROR: db_diradd called with a null minor type pointer for object %s", bu_vls_addr(&local));
	    bu_bomb("must specify minor type");
	}
@


14.11
log
@comment on what the arguments to db_diradd mean
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.10 2005/12/04 02:33:13 brlcad Exp $ (BRL)";
d300 2
a301 2
	bu_log("db_diradd(dbip=x%x, name='%s', addr=x%x, len=%d, flags=x%x)\n",
	       dbip, name, laddr, len, flags );
a328 1
    bu_vls_free(&local);
d340 4
d346 1
@


14.10
log
@M-x indent-region
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.9 2005/12/04 02:31:08 brlcad Exp $ (BRL)";
d279 9
a287 1
 * for db version 5, ptr is a pointer to an unsigned char (minor_type)
@


14.9
log
@ws and comment formatting
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.8 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
d79 1
a79 1
	register int	i;
d81 1
a81 1
	RT_CK_DBI(dbip);
d83 5
a87 5
	for (i = 0; i < RT_DBNHASH; i++)  {
		if( dbip->dbi_Head[i] != DIR_NULL )
			return 1;
	}
	return 0;
d98 11
a108 11
	register struct directory *dp;
	register int	count = 0;
	int		i;

	RT_CK_DBI(dbip);

	for (i = 0; i < RT_DBNHASH; i++)  {
		for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
			count++;
	}
	return count;
d120 2
a121 2
	register struct directory *dp;
	int		i;
d123 1
a123 1
	RT_CK_DBI(dbip);
d125 4
a128 4
	for (i = 0; i < RT_DBNHASH; i++)  {
		for (dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw)
			RT_CK_DIR(dp);
	}
d140 8
a147 8
	register const unsigned char *s = (unsigned char *)str;
	register long sum;
	register int i;

	sum = 0;
	/* BSD namei hashing starts i=0, discarding first char.  why? */
	for( i=1; *s; )
		sum += *s++ * i++;
d149 1
a149 1
	return( RT_DBHASH(sum) );
d181 35
a215 36
	register struct directory	*dp;
	register char			*cp = bu_vls_addr(ret_name);
	register char			n0 = cp[0];
	register char			n1 = cp[1];

	/* Compute hash only once (almost always the case) */
	*headp = &(dbip->dbi_Head[db_dirhash(cp)]);

	for (dp = **headp; dp != DIR_NULL; dp=dp->d_forw) {
		register char	*this;
		if (n0 == *(this=dp->d_namep)  &&	/* speed */
		    n1 == this[1]  &&			/* speed */
		    strcmp(cp, this) == 0) {
			/* Name exists in directory already */
			register int	c;

			bu_vls_strcpy(ret_name, "A_");
			bu_vls_strcat(ret_name, this);

			for (c = 'A'; c <= 'Z'; c++) {
				*cp = c;
				if (db_lookup(dbip, cp, noisy) == DIR_NULL)
					break;
			}
			if (c > 'Z') {
				bu_log("db_dircheck: Duplicate of name '%s', ignored\n",
				       cp);
				return -1;	/* fail */
			}
			bu_log("db_dircheck: Duplicate of '%s', given temporary name '%s'\n",
			       cp+2, cp);

			/* no need to recurse, simply recompute the hash and break */
			*headp = &(dbip->dbi_Head[db_dirhash(cp)]);
			break;
		}
d217 1
d219 1
a219 1
	return 0;	/* success */
d241 24
a264 7
	register struct directory *dp;
	register char	n0;
	register char	n1;

	if (!name) {
	  bu_log("db_lookup received NULL name\n");
	  return (DIR_NULL);
d266 1
d268 2
a269 20
	n0 = name[0];
	n1 = name[1];

	RT_CK_DBI(dbip);

	dp = dbip->dbi_Head[db_dirhash(name)];
	for(; dp != DIR_NULL; dp=dp->d_forw )  {
		register char	*this;
		if(
			n0 == *(this=dp->d_namep)  &&	/* speed */
			n1 == this[1]  &&	/* speed */
			strcmp( name, this ) == 0
		)  {
			if(RT_G_DEBUG&DEBUG_DB) bu_log("db_lookup(%s) x%x\n", name, dp);
			return(dp);
		}
	}

	if(noisy || RT_G_DEBUG&DEBUG_DB) bu_log("db_lookup(%s) failed: %s does not exist\n", name, name);
	return( DIR_NULL );
d284 32
a315 21
	struct directory **headp;
	register struct directory *dp;
	char *tmp_ptr;
	struct bu_vls	local;

	RT_CK_DBI(dbip);

	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db_diradd(dbip=x%x, name='%s', addr=x%x, len=%d, flags=x%x)\n",
			dbip, name, laddr, len, flags );
	}

	if( (tmp_ptr=strchr( name, '/' )) != NULL )  {
		/* if this is a version 4 database and the offending char is beyond NAMESIZE
		 * then it is not really a problem
		 */
		if( dbip->dbi_version < 5 && (tmp_ptr - name) < 16 ) {
			bu_log("db_diradd() object named '%s' is illegal, ignored\n", name );
			return DIR_NULL;
		}
	}
d317 19
a335 30
	bu_vls_init(&local);
	if( dbip->dbi_version < 5 ) {
		bu_vls_strncpy(&local, name, NAMESIZE);
	} else {
		bu_vls_strcpy(&local, name);
	}
	if (db_dircheck(dbip, &local, 0, &headp) < 0) {
		bu_vls_free(&local);
		return DIR_NULL;
	}

	/* 'name' not found in directory, add it */
	RT_GET_DIRECTORY(dp, &rt_uniresource);
	RT_CK_DIR(dp);
	RT_DIR_SET_NAMEP(dp, bu_vls_addr(&local));	/* sets d_namep */
	bu_vls_free(&local);
	dp->d_un.file_offset = laddr;
	dp->d_flags = flags & ~(RT_DIR_INMEM);
	dp->d_len = len;
	dp->d_forw = *headp;
	BU_LIST_INIT( &dp->d_use_hd );
	*headp = dp;
	dp->d_animate = NULL;
	dp->d_nref = 0;
	dp->d_uses = 0;
	if( dbip->dbi_version > 4 ) {
		dp->d_major_type = DB5_MAJORTYPE_BRLCAD;
		dp->d_minor_type = *(unsigned char *)ptr;
	}
	return( dp );
d347 2
a348 12
	BU_CK_EXTERNAL(ext);
	RT_CK_DIR(dp);

	if( dp->d_flags & RT_DIR_INMEM )
		bu_free( dp->d_un.ptr, "db_inmem() ext ptr" );
	dp->d_un.ptr = ext->ext_buf;
	if( dbip->dbi_version < 5 ) {
		dp->d_len = ext->ext_nbytes / 128;	/* DB_MINREC granule size */
	} else {
		dp->d_len = ext->ext_nbytes;
	}
	dp->d_flags = flags | RT_DIR_INMEM;
d350 13
a362 3
	/* Empty out the external structure, but leave it w/valid magic */
	ext->ext_buf = (genptr_t)NULL;
	ext->ext_nbytes = 0;
d381 2
a382 2
	register struct directory *findp;
	register struct directory **headp;
d384 2
a385 2
	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
d387 1
a387 1
	headp = &(dbip->dbi_Head[db_dirhash(dp->d_namep)]);
d389 1
a389 1
	if( dp->d_flags & RT_DIR_INMEM )
d391 2
a392 2
		if( dp->d_un.ptr != NULL )
			bu_free( dp->d_un.ptr, "db_dirdelete() inmem ptr" );
d395 21
a415 21
	if( *headp == dp )  {
		RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */
		*headp = dp->d_forw;

		/* Put 'dp' back on the freelist */
		dp->d_forw = rt_uniresource.re_directory_hd;
		rt_uniresource.re_directory_hd = dp;
		return(0);
	}
	for( findp = *headp; findp != DIR_NULL; findp = findp->d_forw )  {
		if( findp->d_forw != dp )
			continue;
		RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */
		findp->d_forw = dp->d_forw;

		/* Put 'dp' back on the freelist */
		dp->d_forw = rt_uniresource.re_directory_hd;
		rt_uniresource.re_directory_hd = dp;
		return(0);
	}
	return(-1);
d431 2
a432 2
	register struct directory *findp;
	register struct directory **headp;
d434 2
a435 2
	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
d437 26
a462 26
	/* Remove from linked list */
	headp = &(dbip->dbi_Head[db_dirhash(dp->d_namep)]);
	if( *headp == dp )  {
		/* Was first on list, dequeue */
		*headp = dp->d_forw;
	} else {
		for( findp = *headp; findp != DIR_NULL; findp = findp->d_forw )  {
			if( findp->d_forw != dp )
				continue;
			/* Dequeue */
			findp->d_forw = dp->d_forw;
			goto out;
		}
		return(-1);		/* ERROR: can't find */
	}

out:
	/* Effect new name */
	RT_DIR_FREE_NAMEP(dp);			/* frees d_namep */
	RT_DIR_SET_NAMEP( dp, newname );	/* sets d_namep */

	/* Add to new linked list */
	headp = &(dbip->dbi_Head[db_dirhash(newname)]);
	dp->d_forw = *headp;
	*headp = dp;
	return(0);
d473 38
a510 39
	register const struct directory *dp;
	register char		*flags;
	register int		i;

	RT_CK_DBI(dbip);

	bu_log("db_pr_dir(x%x):  Dump of directory for file %s [%s]\n",
		dbip, dbip->dbi_filename,
		dbip->dbi_read_only ? "READ-ONLY" : "Read/Write" );

	bu_log("Title = %s\n", dbip->dbi_title);
	/* units ? */

	for( i = 0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp=dp->d_forw )  {
			if( dp->d_flags & DIR_SOLID )
				flags = "SOL";
			else if( (dp->d_flags & (DIR_COMB|DIR_REGION)) ==
			    (DIR_COMB|DIR_REGION) )
				flags = "REG";
			else if( (dp->d_flags & (DIR_COMB|DIR_REGION)) ==
			    DIR_COMB )
				flags = "COM";
			else
				flags = "Bad";
			bu_log("x%.8x %s %s=x%.8x len=%.5d use=%.2d nref=%.2d %s",
				dp,
				flags,
				dp->d_flags & RT_DIR_INMEM ? "  ptr " : "d_addr",
				dp->d_addr,
				dp->d_len,
				dp->d_uses,
				dp->d_nref,
				dp->d_namep );
			if( dp->d_animate )
				bu_log(" anim=x%x\n", dp->d_animate );
			else
				bu_log("\n");
		}
d512 1
d526 2
a527 2
	register struct directory	*dp;
	register int		bytes;
d529 2
a530 2
	RT_RESOURCE_CHECK(resp);
	BU_CK_PTBL( &resp->re_directory_blocks );
d532 1
a532 1
	BU_ASSERT_PTR( resp->re_directory_hd, ==, NULL );
d534 14
a547 14
	/* Get a BIG block */
	bytes = bu_malloc_len_roundup(1024*sizeof(struct directory));
	dp = (struct directory *)bu_malloc(bytes, "db_get_directory()");

	/* Record storage for later */
	bu_ptbl_ins( &resp->re_directory_blocks, (long *)dp );

	while( bytes >= sizeof(struct directory) )  {
		dp->d_magic = RT_DIR_MAGIC;
		dp->d_forw = resp->re_directory_hd;
		resp->re_directory_hd = dp;
		dp++;
		bytes -= sizeof(struct directory);
	}
d574 37
a610 42
	struct bu_attribute_value_set obj_avs;
	struct directory *dp;
	struct bu_ptbl *tbl;
	int match_count=0;
	int attr_count;
	int i,j;
	int draw;

	RT_CK_DBI(dbip);

	if( avs ) {
		BU_CK_AVS( avs );
		attr_count = avs->count;
	} else {
		attr_count = 0;
	}
	tbl = (struct bu_ptbl *)bu_malloc( sizeof( struct bu_ptbl ), "wdb_get_by_attr ptbl" );
	bu_ptbl_init( tbl, 128, "wdb_get_by_attr ptbl_init" );
	FOR_ALL_DIRECTORY_START(dp,dbip)
		if( (dp->d_flags & dir_flags) == 0 ) continue;
		if(attr_count ) {
			if( db5_get_attributes( dbip, &obj_avs, dp ) < 0 ) {
				bu_log( "ERROR: failed to get attributes for %s\n", dp->d_namep );
				return( (struct bu_ptbl *)NULL );
			}

			draw = 0;
			match_count = 0;
			for( i=0 ; i<avs->count ; i++ ) {
				for( j=0 ; j<obj_avs.count ; j++ ) {
					if( !strcmp( avs->avp[i].name, obj_avs.avp[j].name ) ) {
						if( !strcmp( avs->avp[i].value, obj_avs.avp[j].value ) ) {
							if( op == 2 ) {
								draw = 1;
								break;
							} else {
								match_count++;
							}
						}
					}
				}
				if( draw ) break;
d612 1
a612 3
			bu_avs_free( &obj_avs );
		} else {
			draw = 1;
d614 11
a624 4
		if( draw || match_count == attr_count ) {
			bu_ptbl_ins( tbl , (long *)dp );
		}
	FOR_ALL_DIRECTORY_END
@


14.8
log
@trailing ws
@
text
@d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.7 2005/08/12 22:31:07 lbutler Exp $ (BRL)";
a52 2


d55 1
a55 1
#include <string.h>
d57 1
a57 1
#include <strings.h>
d278 2
a282 6





        		    		/* for db version 5, this is a pointer to an unsigned char (minor_type) */
d553 17
a569 10
 *	lookup directory entries based on directory flags (dp->d_flags) and attributes
 *	the "dir_flags" arg is a mask for the directory flags
 *	the "avs" is an attribute value set used to select from the objects that pass
 *	the flags mask. if "op" is 1, then the object must have all the attributes and
 *	values that appear in "avs" in order to be selected. If "op" is 2, then the object
 *	must have at least one of the attribute/value pairs from "avs".
 *
 *	returns a ptbl list of selected directory pointers
 *		an empty list means nothing met the requirements
 *		a NULL return means something went wrong
a572 5

              			/* flags of the form used in struct directory (d_flags) */

       	/* 1 -> all attribute name/value pairs must be present and match */
        /* 2 -> at least one of the name/value pairs must be present and match */
@


14.7
log
@Doxygen changes
@
text
@d38 1
a38 1
 *  
d43 1
a43 1
 *  
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.6 2005/01/30 20:30:58 brlcad Exp $ (BRL)";
d135 1
a135 1
 *  
d283 5
a287 5
                    	      
                   	      
    			      
   			    
   			      
d524 1
a524 1
 *  
d572 1
a572 1
                  
d574 1
a574 1
                                   
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d38 1
a38 1
 *
d43 1
a43 1
 *
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d135 1
a135 1
 *
d283 5
a287 5





d524 1
a524 1
 *
d572 1
a572 1

d574 1
a574 1

@


14.6
log
@update copyright to 2005
@
text
@d21 4
d45 2
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_lookup.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
d70 1
a70 1
/*
d92 1
a92 1
/*
d113 1
a113 1
/*
d133 1
a133 1
/*
d154 1
a154 1
/*
d225 1
a225 1
/*
d274 1
a274 1
/*
d344 1
a344 1
/*
d371 1
a371 1
/*
d424 1
a424 1
/*
d471 1
a471 1
/*
d522 1
a522 1
/*
d556 1
a556 1
/*
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2004 United States Government as represented by
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_lookup.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a39 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_lookup.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_lookup.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_lookup.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			D B _ L O O K U P . C
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_lookup.c,v 1.3 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_lookup.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
d610 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_lookup.c,v 1.1 2004/05/20 15:19:57 morrison Exp $ (BRL)";
d34 1
a34 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_lookup.c,v 11.37 2004/05/10 15:30:46 erikg Exp $ (BRL)";
d29 1
a29 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

