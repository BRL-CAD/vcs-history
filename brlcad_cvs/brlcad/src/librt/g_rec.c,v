head	14.22;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.6
	rel-7-10-2:14.15
	rel-7-10-0:14.15
	rel-7-8-4:14.11
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.4
	rel-7-6-0:14.8
	rel-7-4-2:14.6.2.1
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.8.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.22
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.12.17.02.16.54;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.11.28.14.11.27;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.22.21.06.48;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.13;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.08.17.09.05.56;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.41;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.21.04.45.44;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.8.4.1;
next	14.7;

14.7
date	2005.07.27.20.11.31;	author johnranderson;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.59;	author brlcad;	state Exp;
branches
	14.6.2.1;
next	14.5;

14.5
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.02;	author morrison;	state Exp;
branches;
next	;

14.6.2.1
date	2005.08.16.21.03.49;	author brlcad;	state Exp;
branches;
next	;

14.8.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.22
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                         G _ R E C . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_rec.c
 *
 *	Intersect a ray with a Right Eliptical Cylinder.
 *	This is a special (but common) case of the TGC,
 *	which is handled separately.
 *
 *  Algorithm -
 *
 *  Given V, H, A, and B, there is a set of points on this cylinder
 *
 *  { (x,y,z) | (x,y,z) is on cylinder }
 *
 *  Through a series of Affine Transformations, this set of points will be
 *  transformed into a set of points on a unit cylinder located at the origin
 *  with a radius of 1, and a height of +1 along the +Z axis.
 *
 *  { (x',y',z') | (x',y',z') is on cylinder at origin }
 *
 *  The transformation from X to X' is accomplished by:
 *
 *  X' = S(R( X - V ))
 *
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( H/(|H|) )
 *
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|B|   0    ) . X
 *  		 (   0      0   1/|H| )
 *
 *  To find the intersection of a line with the surface of the cylinder,
 *  consider the parametric line L:
 *
 *  	L : { P(n) | P + t(n) . D }
 *
 *  Call W the actual point of intersection between L and the cylinder.
 *  Let W' be the point of intersection between L' and the unit cylinder.
 *
 *  	L' : { P'(n) | P' + t(n) . D' }
 *
 *  W = invR( invS( W' ) ) + V
 *
 *  Where W' = k D' + P'.
 *
 *  If Dx' and Dy' are both 0, then there is no hit on the cylinder;
 *  but the end plates need checking.
 *
 *  Line L' hits the infinitely tall unit cylinder at W' when
 *
 *	k**2 + b * k + c = 0
 *
 *  where
 *
 *  b = 2 * ( Dx' * Px' + Dy' * Py' ) / ( Dx'**2 + Dy'**2 )
 *  c = ( ( Px'**2 + Py'**2 ) - r**2 ) / ( Dx'**2 + Dy'**2 )
 *  r = 1.0
 *
 *  The qudratic formula yields k (which is constant):
 *
 *  k = [ -b +/- sqrt( b**2 - 4 * c ] / 2.0
 *
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *
 *  Substituting,
 *
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *
 *  The hit at ``k'' is a hit on the height=1 unit cylinder IFF
 *  0 <= Wz' <= 1.
 *
 *  NORMALS.  Given the point W on the surface of the cylinder,
 *  what is the vector normal to the tangent plane at that point?
 *
 *  Map W onto the unit cylinder, ie:  W' = S( R( W - V ) ).
 *
 *  Plane on unit cylinder at W' has a normal vector N' of the same value
 *  as W' in x and y, with z set to zero, ie, (Wx', Wy', 0)
 *
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the original cylinder) has a normal vector of N, viz:
 *
 *  N = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *  Note that the normal vector produced above will not have unit length.
 *
 *  THE END PLATES.
 *
 *  If Dz' == 0, line L' is parallel to the end plates, so there is no hit.
 *
 *  Otherwise, the line L' hits the bottom plate with k = (0 - Pz') / Dz',
 *  and hits the top plate with k = (1 - Pz') / Dz'.
 *
 *  The solution W' is within the end plate IFF
 *
 *	Wx'**2 + Wy'**2 <= 1.0
 *
 *  The normal for a hit on the bottom plate is -Hunit, and
 *  the normal for a hit on the top plate is +Hunit.
 *
 *  Authors -
 *	Edwin O. Davisson	(Analysis)
 *	Michael John Muuss	(Programming)
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */

#include "common.h"

#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

struct rec_specific {
	vect_t	rec_V;		/* Vector to center of base of cylinder  */
	vect_t	rec_Hunit;	/* Unit H vector */
	mat_t	rec_SoR;	/* Scale(Rot(vect)) */
	mat_t	rec_invRoS;	/* invRot(Scale(vect)) */
	vect_t	rec_A;		/* One axis of ellipse */
	vect_t	rec_B;		/* Other axis of ellipse */
	fastf_t	rec_iAsq;	/* 1/MAGSQ(A) */
	fastf_t	rec_iBsq;	/* 1/MAGSQ(B) */
};

/**
 *  			R E C _ P R E P
 *
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid REC,
 *  and if so, precompute various terms of the formulas.
 *
 *  Returns -
 *  	0	REC is OK
 *  	!0	Error in description
 *
 *  Implicit return -
 *  	A struct rec_specific is created,
 *	and it's address is stored in
 *  	stp->st_specific for use by rt_rec_shot().
 *	If the TGC is really an REC, stp->st_id is modified to ID_REC.
 */
int
rt_rec_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_tgc_internal	*tip;
	register struct rec_specific *rec;
	double	magsq_h, magsq_a, magsq_b, magsq_c, magsq_d;
	double	mag_h, mag_a, mag_b;
	mat_t	R;
	mat_t	Rinv;
	mat_t	S;
	vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|Hv|**2) ] */
	vect_t	work;
	fastf_t	f;

	tip = (struct rt_tgc_internal *)ip->idb_ptr;
	RT_TGC_CK_MAGIC(tip);

	/* Validate that |H| > 0, compute |A| |B| |C| |D| */
	mag_h = sqrt( magsq_h = MAGSQ( tip->h ) );
	mag_a = sqrt( magsq_a = MAGSQ( tip->a ) );
	mag_b = sqrt( magsq_b = MAGSQ( tip->b ) );
	magsq_c = MAGSQ( tip->c );
	magsq_d = MAGSQ( tip->d );

	/* Check for |H| > 0, |A| > 0, |B| > 0 */
	if( NEAR_ZERO(mag_h, RT_LEN_TOL) || NEAR_ZERO(mag_a, RT_LEN_TOL)
	 || NEAR_ZERO(mag_b, RT_LEN_TOL) )  {
		return(1);		/* BAD, too small */
	}

	/* Make sure that A == C, B == D */
	VSUB2( work, tip->a, tip->c );
	f = MAGNITUDE( work );
	if( ! NEAR_ZERO(f, RT_LEN_TOL) )  {
		return(1);		/* BAD, !cylinder */
	}
	VSUB2( work, tip->b, tip->d );
	f = MAGNITUDE( work );
	if( ! NEAR_ZERO(f, RT_LEN_TOL) )  {
		return(1);		/* BAD, !cylinder */
	}

	/* Check for A.B == 0, H.A == 0 and H.B == 0 */
	f = VDOT( tip->a, tip->b ) / (mag_a * mag_b);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(1);		/* BAD */
	}
	f = VDOT( tip->h, tip->a ) / (mag_h * mag_a);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(1);		/* BAD */
	}
	f = VDOT( tip->h, tip->b ) / (mag_h * mag_b);
	if( ! NEAR_ZERO(f, RT_DOT_TOL) )  {
		return(1);		/* BAD */
	}

	/*
	 *  This TGC is really an REC
	 */
	stp->st_id = ID_REC;		/* "fix" soltab ID */
	stp->st_meth = &rt_functab[ID_REC];

	BU_GETSTRUCT( rec, rec_specific );
	stp->st_specific = (genptr_t)rec;

	VMOVE( rec->rec_Hunit, tip->h );
	VUNITIZE( rec->rec_Hunit );

	VMOVE( rec->rec_V, tip->v );
	VMOVE( rec->rec_A, tip->a );
	VMOVE( rec->rec_B, tip->b );
	rec->rec_iAsq = 1.0/magsq_a;
	rec->rec_iBsq = 1.0/magsq_b;

	VSET( invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_h );

	/* Compute R and Rinv matrices */
	MAT_IDN( R );
	f = 1.0/mag_a;
	VSCALE( &R[0], tip->a, f );
	f = 1.0/mag_b;
	VSCALE( &R[4], tip->b, f );
	f = 1.0/mag_h;
	VSCALE( &R[8], tip->h, f );
	bn_mat_trn( Rinv, R );			/* inv of rot mat is trn */

	/* Compute S */
	MAT_IDN( S );
	S[ 0] = sqrt( invsq[0] );
	S[ 5] = sqrt( invsq[1] );
	S[10] = sqrt( invsq[2] );

	/* Compute SoR and invRoS */
	bn_mat_mul( rec->rec_SoR, S, R );
	bn_mat_mul( rec->rec_invRoS, Rinv, S );

	/* Compute bounding sphere and RPP */
	{
		fastf_t	dx, dy, dz;	/* For bounding sphere */
		vect_t	P, w1;
		fastf_t	f, tmp, z;

		/* X */
		VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
		MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
		/* 1st end ellipse (no Z part) */
		tmp = magsq_a * w1[X] * w1[X] + magsq_b * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		stp->st_min[X] = rec->rec_V[X] - f;	/* V.P +/- f */
		stp->st_max[X] = rec->rec_V[X] + f;
		/* 2nd end ellipse */
		z = w1[Z] * mag_h;		/* Z part */
		tmp = magsq_c * w1[X] * w1[X] + magsq_d * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		if( rec->rec_V[X] - f + z < stp->st_min[X] )
			stp->st_min[X] = rec->rec_V[X] - f + z;
		if( rec->rec_V[X] + f + z > stp->st_max[X] )
			stp->st_max[X] = rec->rec_V[X] + f + z;

		/* Y */
		VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
		MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
		/* 1st end ellipse (no Z part) */
		tmp = magsq_a * w1[X] * w1[X] + magsq_b * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		stp->st_min[Y] = rec->rec_V[Y] - f;	/* V.P +/- f */
		stp->st_max[Y] = rec->rec_V[Y] + f;
		/* 2nd end ellipse */
		z = w1[Z] * mag_h;		/* Z part */
		tmp = magsq_c * w1[X] * w1[X] + magsq_d * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		if( rec->rec_V[Y] - f + z < stp->st_min[Y] )
			stp->st_min[Y] = rec->rec_V[Y] - f + z;
		if( rec->rec_V[Y] + f + z > stp->st_max[Y] )
			stp->st_max[Y] = rec->rec_V[Y] + f + z;

		/* Z */
		VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
		MAT3X3VEC( w1, R, P );		/* map plane into local coord syst */
		/* 1st end ellipse (no Z part) */
		tmp = magsq_a * w1[X] * w1[X] + magsq_b * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		stp->st_min[Z] = rec->rec_V[Z] - f;	/* V.P +/- f */
		stp->st_max[Z] = rec->rec_V[Z] + f;
		/* 2nd end ellipse */
		z = w1[Z] * mag_h;		/* Z part */
		tmp = magsq_c * w1[X] * w1[X] + magsq_d * w1[Y] * w1[Y];
		if( tmp > SMALL )
			f = sqrt(tmp);		/* XY part */
		else
			f = 0;
		if( rec->rec_V[Z] - f + z < stp->st_min[Z] )
			stp->st_min[Z] = rec->rec_V[Z] - f + z;
		if( rec->rec_V[Z] + f + z > stp->st_max[Z] )
			stp->st_max[Z] = rec->rec_V[Z] + f + z;

		VSET( stp->st_center,
			(stp->st_max[X] + stp->st_min[X])/2,
			(stp->st_max[Y] + stp->st_min[Y])/2,
			(stp->st_max[Z] + stp->st_min[Z])/2 );

		dx = (stp->st_max[X] - stp->st_min[X])/2;
		f = dx;
		dy = (stp->st_max[Y] - stp->st_min[Y])/2;
		if( dy > f )  f = dy;
		dz = (stp->st_max[Z] - stp->st_min[Z])/2;
		if( dz > f )  f = dz;
		stp->st_aradius = f;
		stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	}
	return(0);			/* OK */
}

/**
 *  			R E C _ P R I N T
 */
void
rt_rec_print(register const struct soltab *stp)
{
	register const struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;

	VPRINT("V", rec->rec_V);
	VPRINT("Hunit", rec->rec_Hunit);
	bn_mat_print("S o R", rec->rec_SoR );
	bn_mat_print("invR o S", rec->rec_invRoS );
}

/* hit_surfno is set to one of these */
#define	REC_NORM_BODY	(1)		/* compute normal */
#define	REC_NORM_TOP	(2)		/* copy tgc_N */
#define	REC_NORM_BOT	(3)		/* copy reverse tgc_N */

/**
 *  			R E C _ S H O T
 *
 *  Intersect a ray with a right elliptical cylinder,
 *  where all constant terms have
 *  been precomputed by rt_rec_prep().  If an intersection occurs,
 *  a struct seg will be acquired and filled in.
 *
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_rec_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;
	vect_t	dprime;		/* D' */
	vect_t	pprime;		/* P' */
	fastf_t	k1, k2;		/* distance constants of solution */
	vect_t	xlated;		/* translated vector */
	struct hit hits[4];	/* 4 potential hit points */
	register struct hit *hitp;	/* pointer to hit point */
	int		nhits = 0;	/* Number of hit points */

	hitp = &hits[0];

	/* out, Mat, vect */
	MAT4X3VEC( dprime, rec->rec_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, rec->rec_V );
	MAT4X3VEC( pprime, rec->rec_SoR, xlated );

	if( NEAR_ZERO(dprime[X], SMALL) && NEAR_ZERO(dprime[Y], SMALL) )
		goto check_plates;

	/* Find roots of the equation, using forumla for quadratic w/ a=1 */
	{
		fastf_t	b;		/* coeff of polynomial */
		fastf_t	root;		/* root of radical */
		fastf_t	dx2dy2;

		b = 2 * ( dprime[X]*pprime[X] + dprime[Y]*pprime[Y] ) *
		   (dx2dy2 = 1 / (dprime[X]*dprime[X] + dprime[Y]*dprime[Y]));
		if( (root = b*b - 4 * dx2dy2 *
		    (pprime[X]*pprime[X] + pprime[Y]*pprime[Y] - 1)) <= 0 )
			goto check_plates;
		root = sqrt(root);

		k1 = (root-b) * 0.5;
		k2 = (root+b) * (-0.5);
	}

	/*
	 *  k1 and k2 are potential solutions to intersection with side.
	 *  See if they fall in range.
	 */
	VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );		/* hit' */
	if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 ) {
		hitp->hit_magic = RT_HIT_MAGIC;
		hitp->hit_dist = k1;
		hitp->hit_surfno = REC_NORM_BODY;	/* compute N */
		hitp++; nhits++;
	}

	VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );		/* hit' */
	if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 )  {
		hitp->hit_magic = RT_HIT_MAGIC;
		hitp->hit_dist = k2;
		hitp->hit_surfno = REC_NORM_BODY;	/* compute N */
		hitp++; nhits++;
	}

	/*
	 * Check for hitting the end plates.
	 */
check_plates:
	if( nhits < 2  &&  !NEAR_ZERO(dprime[Z], SMALL) )  {
		/* 0 or 1 hits so far, this is worthwhile */
		k1 = -pprime[Z] / dprime[Z];		/* bottom plate */
		k2 = (1.0 - pprime[Z]) / dprime[Z];	/* top plate */

		VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
		if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
		    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = k1;
			hitp->hit_surfno = REC_NORM_BOT;	/* -H */
			hitp++; nhits++;
		}

		VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );	/* hit' */
		if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
		    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
			hitp->hit_magic = RT_HIT_MAGIC;
			hitp->hit_dist = k2;
			hitp->hit_surfno = REC_NORM_TOP;	/* +H */
			hitp++; nhits++;
		}
	}
	if( nhits == 0 )  return 0;	/* MISS */
	if( nhits == 2 )  {
hit:
		if( hits[0].hit_dist < hits[1].hit_dist )  {
			/* entry is [0], exit is [1] */
			register struct seg *segp;

			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[0];		/* struct copy */
			segp->seg_out = hits[1];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		} else {
			/* entry is [1], exit is [0] */
			register struct seg *segp;

			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[1];		/* struct copy */
			segp->seg_out = hits[0];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
		return 2;			/* HIT */
	}
	if( nhits == 1 )  {
		if( hits[0].hit_surfno != REC_NORM_BODY )
			bu_log("rt_rec_shot(%s): 1 intersection with end plate?\n", stp->st_name );
		/*
		 *  Ray is tangent to body of cylinder,
		 *  or a single hit on on an end plate (??)
		 *  This could be considered a MISS,
		 *  but to signal the condition, return 0-thickness hit.
		 */
		hits[1] = hits[0];	/* struct copy */
		nhits++;
		goto hit;
	}
	if( nhits == 3 )  {
		fastf_t tol_dist = ap->a_rt_i->rti_tol.dist;
		/*
		 *  Check for case where two of the three hits
		 *  have the same distance, e.g. hitting at the rim.
		 */
		k1 = hits[0].hit_dist - hits[1].hit_dist;
		if( NEAR_ZERO( k1, tol_dist ) )  {
			if(RT_G_DEBUG&DEBUG_ARB8)bu_log("rt_rec_shot(%s): 3 hits, collapsing 0&1\n", stp->st_name);
			hits[1] = hits[2];	/* struct copy */
			nhits--;
			goto hit;
		}
		k1 = hits[1].hit_dist - hits[2].hit_dist;
		if( NEAR_ZERO( k1, tol_dist ) )  {
			if(RT_G_DEBUG&DEBUG_ARB8)bu_log("rt_rec_shot(%s): 3 hits, collapsing 1&2\n", stp->st_name);
			nhits--;
			goto hit;
		}
		k1 = hits[0].hit_dist - hits[2].hit_dist;
		if( NEAR_ZERO( k1, tol_dist ) )  {
			if(RT_G_DEBUG&DEBUG_ARB8)bu_log("rt_rec_shot(%s): 3 hits, collapsing 1&2\n", stp->st_name);
			nhits--;
			goto hit;
		}
	}
	/*  nhits >= 3 */
	bu_log("rt_rec_shot(%s): %d unique hits?!?  %g, %g, %g, %g\n",
		stp->st_name, nhits,
		hits[0].hit_dist,
		hits[1].hit_dist,
		hits[2].hit_dist,
		hits[3].hit_dist);

	/* count just the first two, to have something */
	goto hit;
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;
/**
 *			R E C _ V S H O T
 *
 *  This is the Becker vector version
 */
void
rt_rec_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
			       /* An array of solid pointers */
			       /* An array of ray pointers */
			       /* array of segs (results returned) */
			       /* Number of ray/object pairs */

{
	register int    i;
	register struct rec_specific *rec;
	vect_t	dprime;		/* D' */
	vect_t	pprime;		/* P' */
	fastf_t	k1, k2;		/* distance constants of solution */
	vect_t	xlated;		/* translated vector */
	struct hit hits[3];	/* 4 potential hit points */
	register struct hit *hitp;	/* pointer to hit point */
	fastf_t	b;		/* coeff of polynomial */
	fastf_t	root;		/* root of radical */
	fastf_t	dx2dy2;

	/* for each ray/right_eliptical_cylinder pair */
	for(i = 0; i < n; i++){
		if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */

		rec = (struct rec_specific *)stp[i]->st_specific;
		hitp = &hits[0];

		/* out, Mat, vect */
		MAT4X3VEC( dprime, rec->rec_SoR, rp[i]->r_dir );
		VSUB2( xlated, rp[i]->r_pt, rec->rec_V );
		MAT4X3VEC( pprime, rec->rec_SoR, xlated );

		if( NEAR_ZERO(dprime[X], SMALL) && NEAR_ZERO(dprime[Y], SMALL) )
			goto check_plates;

		/* Find roots of eqn, using forumla for quadratic w/ a=1 */
		b = 2 * ( dprime[X]*pprime[X] + dprime[Y]*pprime[Y] ) *
		   (dx2dy2 = 1 / (dprime[X]*dprime[X] + dprime[Y]*dprime[Y]));
		if( (root = b*b - 4 * dx2dy2 *
		    (pprime[X]*pprime[X] + pprime[Y]*pprime[Y] - 1)) <= 0 )
			goto check_plates;

		root = sqrt(root);
		k1 = (root-b) * 0.5;
		k2 = (root+b) * (-0.5);

		/*
		 *  k1 and k2 are potential solutions to intersection with side.
		 *  See if they fall in range.
		 */
		VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );	/* hit' */
		if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 ) {
			hitp->hit_dist = k1;
			hitp->hit_surfno = REC_NORM_BODY;	/* compute N */
			hitp++;
		}

		VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );		/* hit' */
		if( hitp->hit_vpriv[Z] >= 0.0 && hitp->hit_vpriv[Z] <= 1.0 )  {
			hitp->hit_dist = k2;
			hitp->hit_surfno = REC_NORM_BODY;	/* compute N */
			hitp++;
		}

		/*
		 * Check for hitting the end plates.
		 */
check_plates:
		if( hitp < &hits[2]  &&  !NEAR_ZERO(dprime[Z], SMALL) )  {
			/* 0 or 1 hits so far, this is worthwhile */
			k1 = -pprime[Z] / dprime[Z];	/* bottom plate */
			k2 = (1.0 - pprime[Z]) / dprime[Z];	/* top plate */

			VJOIN1( hitp->hit_vpriv, pprime, k1, dprime );/* hit' */
			if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
			    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
				hitp->hit_dist = k1;
				hitp->hit_surfno = REC_NORM_BOT;	/* -H */
				hitp++;
			}

			VJOIN1( hitp->hit_vpriv, pprime, k2, dprime );/* hit' */
			if( hitp->hit_vpriv[X] * hitp->hit_vpriv[X] +
			    hitp->hit_vpriv[Y] * hitp->hit_vpriv[Y] <= 1.0 )  {
				hitp->hit_dist = k2;
				hitp->hit_surfno = REC_NORM_TOP;	/* +H */
				hitp++;
			}
		}

		if( hitp != &hits[2] ) {
			SEG_MISS(segp[i]);		/* MISS */
		} else {
			segp[i].seg_stp = stp[i];

			if( hits[0].hit_dist < hits[1].hit_dist )  {
				/* entry is [0], exit is [1] */
				VMOVE(segp[i].seg_in.hit_vpriv, hits[0].hit_vpriv);
				segp[i].seg_in.hit_dist = hits[0].hit_dist;
				segp[i].seg_in.hit_surfno = hits[0].hit_surfno;
				VMOVE(segp[i].seg_out.hit_vpriv, hits[1].hit_vpriv);
				segp[i].seg_out.hit_dist = hits[1].hit_dist;
				segp[i].seg_out.hit_surfno = hits[1].hit_surfno;
			} else {
				/* entry is [1], exit is [0] */
				VMOVE(segp[i].seg_in.hit_vpriv, hits[1].hit_vpriv);
				segp[i].seg_in.hit_dist = hits[1].hit_dist;
				segp[i].seg_in.hit_surfno = hits[1].hit_surfno;
				VMOVE(segp[i].seg_out.hit_vpriv, hits[0].hit_vpriv);
				segp[i].seg_out.hit_dist = hits[0].hit_dist;
				segp[i].seg_out.hit_surfno = hits[0].hit_surfno;
			}
		}
	}
}

/**
 *  			R E C _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 *  hit_surfno is a flag indicating if normal needs to be computed or not.
 */
void
rt_rec_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	switch( hitp->hit_surfno )  {
	case REC_NORM_BODY:
		/* compute it */
		hitp->hit_vpriv[Z] = 0.0;
		MAT4X3VEC( hitp->hit_normal, rec->rec_invRoS,
			hitp->hit_vpriv );
		VUNITIZE( hitp->hit_normal );
		break;
	case REC_NORM_TOP:
		VMOVE( hitp->hit_normal, rec->rec_Hunit );
		break;
	case REC_NORM_BOT:
		VREVERSE( hitp->hit_normal, rec->rec_Hunit );
		break;
	default:
		bu_log("rt_rec_norm: surfno=%d bad\n", hitp->hit_surfno);
		break;
	}
}

/**
 *			R E C _ C U R V E
 *
 *  Return the "curvature" of the cylinder.  If an endplate,
 *  pick a principle direction orthogonal to the normal, and
 *  indicate no curvature.  Otherwise, compute curvature.
 *  Normal must have been computed before calling this routine.
 */
void
rt_rec_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;
	vect_t	uu;
	fastf_t	ax, bx, q;

	switch( hitp->hit_surfno )  {
	case REC_NORM_BODY:
		/* This could almost certainly be simpler if we used
		 * inverse A rather than inverse A squared, right Ed?
		 */
		VMOVE( cvp->crv_pdir, rec->rec_Hunit );
		VSUB2( uu, hitp->hit_point, rec->rec_V );
		cvp->crv_c1 = 0;
		ax = VDOT( uu, rec->rec_A ) * rec->rec_iAsq;
		bx = VDOT( uu, rec->rec_B ) * rec->rec_iBsq;
		q = sqrt( ax * ax * rec->rec_iAsq + bx * bx * rec->rec_iBsq );
		cvp->crv_c2 = - rec->rec_iAsq * rec->rec_iBsq / (q*q*q);
		break;
	case REC_NORM_TOP:
	case REC_NORM_BOT:
		bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
		cvp->crv_c1 = cvp->crv_c2 = 0;
		break;
	default:
		bu_log("rt_rec_curve: bad surfno %d\n", hitp->hit_surfno);
		break;
	}
}

/**
 *  			R E C _ U V
 *
 *  For a hit on the surface of an REC, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *
 *  u is the rotation around the cylinder, and
 *  v is the displacement along H.
 */
void
rt_rec_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;

	vect_t work;
	vect_t pprime;
	fastf_t len;
	fastf_t ratio;

	/* hit_point is on surface;  project back to unit cylinder,
	 * creating a vector from vertex to hit point.
	 */
	VSUB2( work, hitp->hit_point, rec->rec_V );
	MAT4X3VEC( pprime, rec->rec_SoR, work );

	switch( hitp->hit_surfno )  {
	case REC_NORM_BODY:
		/* Skin.  x,y coordinates define rotation.  radius = 1 */
		ratio = pprime[Y];
		if( ratio > 1.0 )
			ratio = 1.0;
		if( ratio < -1.0 )
			ratio = -1.0;
		uvp->uv_u = acos(ratio) * bn_inv2pi;
		uvp->uv_v = pprime[Z];		/* height */
		break;
	case REC_NORM_TOP:
		/* top plate */
		len = sqrt(pprime[X]*pprime[X]+pprime[Y]*pprime[Y]);
		ratio = pprime[Y]/len;
		if( ratio > 1.0 )
			ratio = 1.0;
		if( ratio < -1.0 )
			ratio = -1.0;
		uvp->uv_u = acos(ratio) * bn_inv2pi;
		uvp->uv_v = len;		/* rim v = 1 */
		break;
	case REC_NORM_BOT:
		/* bottom plate */
		len = sqrt(pprime[X]*pprime[X]+pprime[Y]*pprime[Y]);
		ratio = pprime[Y]/len;
		if( ratio > 1.0 )
			ratio = 1.0;
		if( ratio < -1.0 )
			ratio = -1.0;
		uvp->uv_u = acos(ratio) * bn_inv2pi;
		uvp->uv_v = 1 - len;	/* rim v = 0 */
		break;
	}
	/* Handle other half of acos() domain */
	if( pprime[X] < 0 )
		uvp->uv_u = 1.0 - uvp->uv_u;

	if( uvp->uv_u < 0 )  uvp->uv_u = 0;
	else if( uvp->uv_u > 1 )  uvp->uv_u = 1;
	if( uvp->uv_v < 0 )  uvp->uv_v = 0;
	else if( uvp->uv_v > 1 )  uvp->uv_v = 1;

	/* XXX uv_du should be relative to rotation, uv_dv relative to height */
	uvp->uv_du = uvp->uv_dv = 0;
}

/**
 *			R E C _ F R E E
 */
void
rt_rec_free(struct soltab *stp)
{
	register struct rec_specific *rec =
		(struct rec_specific *)stp->st_specific;

	bu_free( (char *)rec, "rec_specific");
}

int
rt_rec_class(void)
{
	return(0);
}

/* plot and tess are handled by g_tgc.c */
/* import, export, ifree, and describe are also handled by g_tgc.c */

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@a141 4
#ifndef lint
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.20 2007/11/28 14:11:27 erikgreenwald Exp $ (BRL)";
#endif

d187 8
a194 8
	static double	magsq_h, magsq_a, magsq_b, magsq_c, magsq_d;
	static double	mag_h, mag_a, mag_b;
	static mat_t	R;
	static mat_t	Rinv;
	static mat_t	S;
	static vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|Hv|**2) ] */
	static vect_t	work;
	static fastf_t	f;
d280 3
a282 3
		static fastf_t	dx, dy, dz;	/* For bounding sphere */
		static vect_t	P, w1;
		static fastf_t	f, tmp, z;
d407 5
a411 5
	static vect_t	dprime;		/* D' */
	static vect_t	pprime;		/* P' */
	static fastf_t	k1, k2;		/* distance constants of solution */
	static vect_t	xlated;		/* translated vector */
	static struct hit hits[4];	/* 4 potential hit points */
d580 5
a584 5
	static vect_t	dprime;		/* D' */
	static vect_t	pprime;		/* P' */
	static fastf_t	k1, k2;		/* distance constants of solution */
	static vect_t	xlated;		/* translated vector */
	static struct hit hits[3];	/* 4 potential hit points */
d773 3
a775 2
	static vect_t work;
	static vect_t pprime;
@


14.20
log
@LOCAL->static, per machine.h deprecation list
@
text
@d143 1
a143 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.19 2007/10/22 21:06:48 brlcad Exp $ (BRL)";
d431 3
a433 3
		FAST fastf_t	b;		/* coeff of polynomial */
		FAST fastf_t	root;		/* root of radical */
		FAST fastf_t	dx2dy2;
d590 3
a592 3
	FAST fastf_t	b;		/* coeff of polynomial */
	FAST fastf_t	root;		/* root of radical */
	FAST fastf_t	dx2dy2;
d779 2
a780 2
	FAST fastf_t len;
	FAST fastf_t ratio;
@


14.19
log
@removed the non-ansi/stc compliant noalias.h and noalias-prag.h headers that were used with the cray (and alliant) to make pragma decls before loops.  made obsolete long ago with the move to ansi compliance.
@
text
@d143 1
a143 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.18 2007/10/22 20:59:55 brlcad Exp $ (BRL)";
d191 8
a198 8
	LOCAL double	magsq_h, magsq_a, magsq_b, magsq_c, magsq_d;
	LOCAL double	mag_h, mag_a, mag_b;
	LOCAL mat_t	R;
	LOCAL mat_t	Rinv;
	LOCAL mat_t	S;
	LOCAL vect_t	invsq;	/* [ 1/(|A|**2), 1/(|B|**2), 1/(|Hv|**2) ] */
	LOCAL vect_t	work;
	LOCAL fastf_t	f;
d284 3
a286 3
		LOCAL fastf_t	dx, dy, dz;	/* For bounding sphere */
		LOCAL vect_t	P, w1;
		LOCAL fastf_t	f, tmp, z;
d411 5
a415 5
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL struct hit hits[4];	/* 4 potential hit points */
d584 5
a588 5
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL struct hit hits[3];	/* 4 potential hit points */
d777 2
a778 2
	LOCAL vect_t work;
	LOCAL vect_t pprime;
@


14.18
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d143 1
a143 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.17 2007/09/15 16:23:13 brlcad Exp $ (BRL)";
a594 1
#	include "noalias.h"
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d143 1
a143 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.16 2007/08/17 09:05:56 brlcad Exp $ (BRL)";
a596 1
#if !CRAY /* XXX currently prevents vectorization on cray */
a597 1
#endif
@


14.16
log
@fixed a bug encountered when ray-tracing really tiny TGC objects (sub-millimeter size) caused by the REC prep routine thinking it was a valid right elliptical cone (when it wasn't).  the problem was due to a bad magnitude check and an insufficient hard-coded 'smallness' constant.  the result was rays that would miss portions of the tgc entirely, only counting the 'middle' portion that would have corresponded with an REC.
@
text
@d143 1
a143 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.15 2007/01/27 01:41:41 brlcad Exp $ (BRL)";
a147 1

a148 1
#ifdef HAVE_STRING_H
a149 1
#endif
d151 1
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d143 1
a143 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.14 2007/01/23 01:13:37 brlcad Exp $ (BRL)";
d220 2
a221 2
	f = MAGSQ( work );
	if( ! NEAR_ZERO(f, 0.0001) )  {
d225 2
a226 2
	f = MAGSQ( work );
	if( ! NEAR_ZERO(f, 0.0001) )  {
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d143 1
a143 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.13 2007/01/21 04:45:44 brlcad Exp $ (BRL)";
a148 1

d578 4
a581 4
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
d600 1
a600 1
	 	if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */
@


14.13
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d143 1
a143 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.12 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.12
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 1
/*@@{*/
d24 1
d144 1
a144 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.11 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
d863 1
a863 1
/*@@}*/
@


14.11
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d144 1
a144 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.10 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
@


14.10
log
@update copyright to 2006
@
text
@d22 1
a22 4
/** \defgroup cc ConesAndCylinders
 * \ingroup g */

/** \addtogroup cc */
a141 1
/*@@}*/
d144 1
a144 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.9 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
d863 1
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d148 1
a148 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.8 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
@


14.8
log
@Doxygen changes
@
text
@d33 1
a33 1
 *  
d35 1
a35 1
 *  
d37 1
a37 1
 *  
d41 1
a41 1
 *  
d43 1
a43 1
 *  
d45 1
a45 1
 *  
d47 1
a47 1
 *  
d51 1
a51 1
 *  
d55 1
a55 1
 *  
d58 1
a58 1
 *  
d60 1
a60 1
 *  
d63 1
a63 1
 *  
d65 1
a65 1
 *  
d67 1
a67 1
 *  
d69 1
a69 1
 *  
d82 1
a82 1
 *  
d86 1
a86 1
 *  
d89 1
a89 1
 *  
d91 1
a91 1
 *  
d96 1
a96 1
 *  
d102 1
a102 1
 *  
d105 1
a105 1
 *  
d107 1
a107 1
 *  
d110 1
a110 1
 *  
d113 1
a113 1
 *  
d143 1
a143 1
 *  
d148 1
a148 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.7 2005/07/27 20:11:31 johnranderson Exp $ (BRL)";
d179 1
a179 1
 *  
d183 1
a183 1
 *  
d187 1
a187 1
 *  
d404 1
a404 1
 *  
d409 1
a409 1
 *  
d443 1
a443 1
		b = 2 * ( dprime[X]*pprime[X] + dprime[Y]*pprime[Y] ) * 
d576 1
a576 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
d588 1
a588 1
                  	    
d621 1
a621 1
		b = 2 * ( dprime[X]*pprime[X] + dprime[Y]*pprime[Y] ) * 
d738 1
a738 1
 *  pick a principle direction orthogonal to the normal, and 
d776 1
a776 1
 *  
@


14.8.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d33 1
a33 1
 *
d35 1
a35 1
 *
d37 1
a37 1
 *
d41 1
a41 1
 *
d43 1
a43 1
 *
d45 1
a45 1
 *
d47 1
a47 1
 *
d51 1
a51 1
 *
d55 1
a55 1
 *
d58 1
a58 1
 *
d60 1
a60 1
 *
d63 1
a63 1
 *
d65 1
a65 1
 *
d67 1
a67 1
 *
d69 1
a69 1
 *
d82 1
a82 1
 *
d86 1
a86 1
 *
d89 1
a89 1
 *
d91 1
a91 1
 *
d96 1
a96 1
 *
d102 1
a102 1
 *
d105 1
a105 1
 *
d107 1
a107 1
 *
d110 1
a110 1
 *
d113 1
a113 1
 *
d143 1
a143 1
 *
d148 1
a148 1
static const char RCSrec[] = "@@(#)$Header$ (BRL)";
d179 1
a179 1
 *
d183 1
a183 1
 *
d187 1
a187 1
 *
d404 1
a404 1
 *
d409 1
a409 1
 *
d443 1
a443 1
		b = 2 * ( dprime[X]*pprime[X] + dprime[Y]*pprime[Y] ) *
d576 1
a576 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;
d588 1
a588 1

d621 1
a621 1
		b = 2 * ( dprime[X]*pprime[X] + dprime[Y]*pprime[Y] ) *
d738 1
a738 1
 *  pick a principle direction orthogonal to the normal, and
d776 1
a776 1
 *
@


14.7
log
@Fixed a bug where 3 hits were found and checking for duplicates was done, but not all the
duplicate possibilities were checked
@
text
@d21 6
a27 2
 *
 *  Purpose -
d145 2
d148 1
a148 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.6 2005/01/30 20:30:59 brlcad Exp $ (BRL)";
d177 1
a177 1
/*
d382 1
a382 1
/*
d402 1
a402 1
/*
d577 1
a577 1
/*
d701 1
a701 1
/*
d734 1
a734 1
/*
d774 1
a774 1
/*
d846 1
a846 1
/*
@


14.6
log
@update copyright to 2005
@
text
@d142 1
a142 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.5 2004/12/21 06:38:21 morrison Exp $ (BRL)";
d551 6
@


14.6.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@d142 1
a142 1
static const char RCSrec[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_rec.c,v 14.7 2005/07/27 20:11:31 johnranderson Exp $ (BRL)";
a550 6
		k1 = hits[0].hit_dist - hits[2].hit_dist;
		if( NEAR_ZERO( k1, tol_dist ) )  {
			if(RT_G_DEBUG&DEBUG_ARB8)bu_log("rt_rec_shot(%s): 3 hits, collapsing 1&2\n", stp->st_name);
			nhits--;
			goto hit;
		}
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d142 1
a142 1
static const char RCSrec[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_rec.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a139 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d142 1
a142 1
static const char RCSrec[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_rec.c,v 14.3 2004/12/21 05:45:24 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d145 1
a145 1
static const char RCSrec[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_rec.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d145 1
a145 1
static const char RCSrec[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_rec.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ R E C . C
d145 1
a145 1
static const char RCSrec[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_rec.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_rec.c,v 1.1 2004/05/20 15:20:02 morrison Exp $ (BRL)";
d838 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d126 1
a126 1
static const char RCSrec[] = "@@(#)$Header: /cvs/brlcad/librt/g_rec.c,v 11.18 2004/05/10 15:30:46 erikg Exp $ (BRL)";
d129 1
a129 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

