head	14.48;
access;
symbols
	rel-7-10-4:14.47
	STABLE:14.47.0.2
	rel-7-10-2:14.47
	rel-7-10-0:14.21;
locks; strict;
comment	@// @;


14.48
date	2007.09.14.15.21.07;	author erikgreenwald;	state Exp;
branches;
next	14.47;

14.47
date	2007.07.13.20.27.55;	author jlowenz;	state Exp;
branches;
next	14.46;

14.46
date	2007.07.11.21.23.39;	author jlowenz;	state Exp;
branches;
next	14.45;

14.45
date	2007.07.11.13.00.34;	author d_rossberg;	state Exp;
branches;
next	14.44;

14.44
date	2007.07.09.21.15.00;	author jlowenz;	state Exp;
branches;
next	14.43;

14.43
date	2007.07.03.20.48.45;	author jlowenz;	state Exp;
branches;
next	14.42;

14.42
date	2007.07.02.21.10.51;	author jlowenz;	state Exp;
branches;
next	14.41;

14.41
date	2007.06.29.19.33.36;	author jlowenz;	state Exp;
branches;
next	14.40;

14.40
date	2007.06.28.20.49.06;	author jlowenz;	state Exp;
branches;
next	14.39;

14.39
date	2007.06.28.17.10.10;	author jlowenz;	state Exp;
branches;
next	14.38;

14.38
date	2007.06.26.21.27.51;	author jlowenz;	state Exp;
branches;
next	14.37;

14.37
date	2007.06.25.20.33.16;	author jlowenz;	state Exp;
branches;
next	14.36;

14.36
date	2007.06.21.20.37.34;	author jlowenz;	state Exp;
branches;
next	14.35;

14.35
date	2007.06.20.20.53.49;	author jlowenz;	state Exp;
branches;
next	14.34;

14.34
date	2007.06.19.19.14.34;	author jlowenz;	state Exp;
branches;
next	14.33;

14.33
date	2007.06.19.11.39.33;	author d_rossberg;	state Exp;
branches;
next	14.32;

14.32
date	2007.06.18.20.18.03;	author jlowenz;	state Exp;
branches;
next	14.31;

14.31
date	2007.06.12.18.56.24;	author jlowenz;	state Exp;
branches;
next	14.30;

14.30
date	2007.06.06.20.20.57;	author jlowenz;	state Exp;
branches;
next	14.29;

14.29
date	2007.06.05.20.44.53;	author jlowenz;	state Exp;
branches;
next	14.28;

14.28
date	2007.06.04.20.19.59;	author jlowenz;	state Exp;
branches;
next	14.27;

14.27
date	2007.05.31.21.06.38;	author jlowenz;	state Exp;
branches;
next	14.26;

14.26
date	2007.05.30.18.39.32;	author jlowenz;	state Exp;
branches;
next	14.25;

14.25
date	2007.05.29.20.42.27;	author jlowenz;	state Exp;
branches;
next	14.24;

14.24
date	2007.05.03.12.13.37;	author d_rossberg;	state Exp;
branches;
next	14.23;

14.23
date	2007.04.20.20.37.10;	author jlowenz;	state Exp;
branches;
next	14.22;

14.22
date	2007.04.19.19.44.46;	author jlowenz;	state Exp;
branches;
next	14.21;

14.21
date	2007.04.03.09.41.52;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.03.29.07.40.12;	author d_rossberg;	state Exp;
branches;
next	14.19;

14.19
date	2007.03.28.18.20.22;	author jlowenz;	state Exp;
branches;
next	14.18;

14.18
date	2007.03.28.13.00.46;	author d_rossberg;	state Exp;
branches;
next	14.17;

14.17
date	2007.03.27.21.59.04;	author jlowenz;	state Exp;
branches;
next	14.16;

14.16
date	2007.03.23.20.23.05;	author jlowenz;	state Exp;
branches;
next	14.15;

14.15
date	2007.03.16.10.57.37;	author d_rossberg;	state Exp;
branches;
next	14.14;

14.14
date	2007.03.15.20.19.20;	author jlowenz;	state Exp;
branches;
next	14.13;

14.13
date	2007.03.14.11.59.00;	author d_rossberg;	state Exp;
branches;
next	14.12;

14.12
date	2007.03.09.20.45.35;	author jlowenz;	state Exp;
branches;
next	14.11;

14.11
date	2007.03.08.06.54.23;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.02.28.16.12.19;	author jlowenz;	state Exp;
branches;
next	14.9;

14.9
date	2007.02.23.16.51.46;	author jlowenz;	state Exp;
branches;
next	14.8;

14.8
date	2007.02.23.16.05.31;	author jlowenz;	state Exp;
branches;
next	14.7;

14.7
date	2007.02.22.15.04.08;	author jlowenz;	state Exp;
branches;
next	14.6;

14.6
date	2007.02.15.21.37.47;	author jlowenz;	state Exp;
branches;
next	14.5;

14.5
date	2007.01.27.01.41.40;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2007.01.16.12.40.37;	author d_rossberg;	state Exp;
branches;
next	14.1;

14.1
date	2007.01.16.12.33.01;	author d_rossberg;	state Exp;
branches;
next	;


desc
@@


14.48
log
@removed trailing whitespace
@
text
@/*                     G _ B R E P . C P P
 * BRL-CAD
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_brep.cpp
 *
 */

#include "common.h"
#include "brep.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "vector.h"

#ifdef write
#   undef write
#endif

#ifdef read
#   undef read
#endif

#include <vector>
#include <list>
#include <iostream>
#include <algorithm>
#include <set>
#include <utility>

#ifdef __cplusplus
extern "C" {
#endif

int
rt_brep_prep(struct soltab *stp, struct rt_db_internal* ip, struct rt_i* rtip);
void
rt_brep_print(register const struct soltab *stp);
int
rt_brep_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead);
void
rt_brep_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp);
void
rt_brep_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp);
int
rt_brep_class();
void
rt_brep_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp);
void
rt_brep_free(register struct soltab *stp);
int
rt_brep_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol);
int
rt_brep_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol);
int
rt_brep_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip);
int
rt_brep_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip);
void
rt_brep_ifree(struct rt_db_internal *ip);
int
rt_brep_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local);
int
rt_brep_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr);
int
rt_brep_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv);

#ifdef __cplusplus
  }
#endif

/********************************************************************************
 * Auxiliary functions
 ********************************************************************************/


using namespace brlcad;

ON_Ray toXRay(struct xray* rp) {
    ON_3dPoint pt(rp->r_pt);
    ON_3dVector dir(rp->r_dir);
    return ON_Ray(pt, dir);
}

//--------------------------------------------------------------------------------
// specific
struct brep_specific*
brep_specific_new()
{
    return (struct brep_specific*)bu_calloc(1, sizeof(struct brep_specific),"brep_specific_new");
}

void
brep_specific_delete(struct brep_specific* bs)
{
    if (bs != NULL) {
	delete bs->bvh;
	bu_free(bs,"brep_specific_delete");
    }
}




//--------------------------------------------------------------------------------
// prep

/**
 * Given a list of face bounding volumes for an entire brep, build up
 * an appropriate hierarchy to make it efficient (binary may be a
 * reasonable choice, for example).
 */
void
brep_bvh_subdivide(BBNode* parent, const std::list<SurfaceTree*>& face_trees)
{
    // XXX this needs to handle a threshold and some reasonable space
    // partitioning
//     for (BVList::const_iterator i = face_bvs.begin(); i != face_bvs.end(); i++) {
// 	parent->gs_insert(*i);
//     }
    for (std::list<SurfaceTree*>::const_iterator i = face_trees.begin(); i != face_trees.end(); i++) {
	parent->addChild((*i)->getRootNode());
    }
}

inline void
distribute(const int count, const ON_3dVector* v, double x[], double y[], double z[])
{
    for (int i = 0; i < count; i++) {
	x[i] = v[i].x;
	y[i] = v[i].y;
	z[i] = v[i].z;
    }
}

bool
brep_pt_trimmed(pt2d_t pt, const ON_BrepFace& face) {
    TRACE1("brep_pt_trimmed: " << PT2(pt));
    // for each loop
    const ON_Surface* surf = face.SurfaceOf();
    double umin, umax;
    ON_2dPoint from, to;
    from.x = pt[0];
    from.y = to.y = pt[1];
    surf->GetDomain(0, &umin, &umax);
    to.x = umax + 1;
    ON_Line ray(from,to);
    int intersections = 0;
    for (int i = 0; i < face.LoopCount(); i++) {
	ON_BrepLoop* loop = face.Loop(i);
	// for each trim
	for (int j = 0; j < loop->m_ti.Count(); j++) {
	    ON_BrepTrim& trim = face.Brep()->m_T[loop->m_ti[j]];
	    const ON_Curve* trimCurve = trim.TrimCurveOf();
	    // intersections += brep_count_intersections(ray, trimCurve);
	    //ray.IntersectCurve(trimCurve, intersections, 0.0001);
	    intersections += trimCurve->NumIntersectionsWith(ray);
	}
    }
    // the point is trimmed if the # of intersections is even
    return (intersections % 2) == 0;
}

// XXX - most of this function is broken :-( except for the bezier span caching
// need to fix it! - could provide real performance benefits...
void
brep_preprocess_trims(const ON_BrepFace& face, SurfaceTree* tree) {

    list<BBNode*> leaves;
    tree->getLeaves(leaves);

    for (list<BBNode*>::iterator i = leaves.begin(); i != leaves.end(); i++) {
	SubsurfaceBBNode* bb = dynamic_cast<SubsurfaceBBNode*>(*i);


	// XXX - TODO: check to see if this portion of the surface
	// needs to be checked for trims
	pt2d_t test[] = {{bb->m_u.Min(),bb->m_v.Min()},
			 {bb->m_u.Max(),bb->m_v.Min()},
			 {bb->m_u.Max(),bb->m_v.Max()},
			 {bb->m_u.Min(),bb->m_v.Max()}};


	// check to see if the bbox encloses a trim
	ON_3dPoint uvmin(bb->m_u.Min(),bb->m_v.Min(),0);
	ON_3dPoint uvmax(bb->m_u.Max(),bb->m_v.Max(),0);
	ON_BoundingBox bbox(uvmin,uvmax);
	bool internalTrim = false;
	for (int i = 0; i < face.Brep()->m_L.Count(); i++) {
	    ON_BrepLoop& loop = face.Brep()->m_L[i];
	    // for each trim
	    for (int j = 0; j < loop.m_ti.Count(); j++) {
		ON_BrepTrim& trim = face.Brep()->m_T[loop.m_ti[j]];
		if (bbox.Intersection(trim.m_pbox)) internalTrim = true;

		// tell the NURBS curves to cache their Bezier spans
		// (used in trimming routines, and not thread safe)
		const ON_Curve* c = trim.TrimCurveOf();
		if (c->ClassId()->IsDerivedFrom(&ON_NurbsCurve::m_ON_NurbsCurve_class_id)) {
		    ON_NurbsCurve::Cast(c)->CacheBezierSpans();
		}
	    }
	}
	bb->m_checkTrim = true; // XXX - ack, hardcode for now
	// for this node to be completely trimmed, all four corners
	// must be trimmed and the depth of the tree needs to be > 0,
	// since 0 means there is just a single leaf - and since
	// "internal" outer loops will be make a single node seem
	// trimmed, we must account for it.
	bb->m_trimmed = false; // XXX - ack, hardcode for now
    }
}

int
brep_build_bvh(struct brep_specific* bs, struct rt_brep_internal* bi)
{
    ON_TextLog tl(stderr);
    ON_Brep* brep = bs->brep;
    if (brep == NULL || !brep->IsValid(&tl)) {
	bu_log("brep is NOT valid");
	return -1;
    }

    bs->bvh = new BBNode(brep->BoundingBox());

    // need to extract faces, and build bounding boxes for each face,
    // then combine the face BBs back up, combining them together to
    // better split the hierarchy
    std::list<SurfaceTree*> surface_trees;
    ON_BrepFaceArray& faces = brep->m_F;
    for (int i = 0; i < faces.Count(); i++) {
        TRACE1("Face: " << i);
	ON_BrepFace& face = faces[i];

	SurfaceTree* st = new SurfaceTree(&face);
	face.m_face_user.p = st;
	brep_preprocess_trims(face, st);

	// add the surface bounding volumes to a list, so we can build
	// down a hierarchy from the brep bounding volume
	surface_trees.push_back(st);
    }

    brep_bvh_subdivide(bs->bvh, surface_trees);

    return 0;
}

void
brep_calculate_cdbitems(struct brep_specific* bs, struct rt_brep_internal* bi)
{

}


/********************************************************************************
 * BRL-CAD Primitive interface
 ********************************************************************************/
/**
 *   			R T _ B R E P _ P R E P
 *
 *  Given a pointer of a GED database record, and a transformation
 *  matrix, determine if this is a valid NURB, and if so, prepare the
 *  surface so the intersections will work.
 */
int
rt_brep_prep(struct soltab *stp, struct rt_db_internal* ip, struct rt_i* rtip)
{
    TRACE1("rt_brep_prep");
    /* This prepares the NURBS specific data structures to be used
       during intersection... i.e. acceleration data structures and
       whatever else is needed.

       Abert's paper (Direct and Fast Ray Tracing of NURBS Surfaces)
       suggests using a bounding volume hierarchy (instead of KD-tree)
       and building it down to a satisfactory flatness criterion
       (which they do not give information about).
    */
    struct rt_brep_internal* bi;
    struct brep_specific* bs;

    RT_CK_DB_INTERNAL(ip);
    bi = (struct rt_brep_internal*)ip->idb_ptr;
    RT_BREP_CK_MAGIC(bi);

    if ((bs = (struct brep_specific*)stp->st_specific) == NULL) {
	bs = (struct brep_specific*)bu_malloc(sizeof(struct brep_specific), "brep_specific");
	bs->brep = bi->brep;
	bi->brep = NULL;
	stp->st_specific = (genptr_t)bs;
    }

    if (brep_build_bvh(bs, bi) < 0) {
	return -1;
    }

    point_t adjust;
    VSETALL(adjust,1);
    bs->bvh->GetBBox(stp->st_min, stp->st_max);
    // expand outer bounding box...
    VSUB2(stp->st_min,stp->st_min,adjust);
    VADD2(stp->st_max,stp->st_max,adjust);
    VADD2SCALE(stp->st_center, stp->st_min, stp->st_max, 0.5);
    vect_t work;
    VSUB2SCALE(work, stp->st_max, stp->st_min, 0.5);
    fastf_t f = work[X];
    V_MAX(f,work[Y]);
    V_MAX(f,work[Z]);
    stp->st_aradius = f;
    stp->st_bradius = MAGNITUDE(work);

    brep_calculate_cdbitems(bs, bi);


    return 0;
}


/**
 *			R T _ B R E P _ P R I N T
 */
void
rt_brep_print(register const struct soltab *stp)
{
}

//================================================================================
// shot support

class plane_ray {
public:
    vect_t n1;
    fastf_t d1;

    vect_t n2;
    fastf_t d2;
};

// void
// brep_intersect_bv(IsectList& inters, struct xray* r, BoundingVolume* bv)
// {
//     fastf_t tnear, tfar;
//     bool intersects = bv->intersected_by(r,&tnear,&tfar);
//     if (intersects && bv->is_leaf() && !dynamic_cast<SurfaceBV*>(bv)->isTrimmed()) {
// 	inters.push_back(IRecord(bv,tnear));
//     }
//     else if (intersects)
// 	for (BVList::iterator i = bv->children.begin(); i != bv->children.end(); i++) {
// 	    brep_intersect_bv(inters, r, *i);
// 	}
// }

void
brep_get_plane_ray(ON_Ray& r, plane_ray& pr)
{
    vect_t v1;
    VMOVE(v1, r.m_dir);
    fastf_t min = MAX_FASTF;
    int index = -1;
    for (int i = 0; i < 3; i++) { // find the smallest component
	if (fabs(v1[i]) < min) {
	    min = fabs(v1[i]);
	    index = i;
	}
    }
    v1[index] += 1; // alter the smallest component
    VCROSS(pr.n1, v1, r.m_dir); // n1 is perpendicular to v1
    VUNITIZE(pr.n1);
    VCROSS(pr.n2, pr.n1, r.m_dir);       // n2 is perpendicular to v1 and n1
    VUNITIZE(pr.n2);
    pr.d1 = VDOT(pr.n1,r.m_origin);
    pr.d2 = VDOT(pr.n2,r.m_origin);
    TRACE1("n1:" << ON_PRINT3(pr.n1) << " n2:" << ON_PRINT3(pr.n2) << " d1:" << pr.d1 << " d2:" << pr.d2);
}


class brep_hit {
public:
    const ON_BrepFace& face;
    point_t origin;
    point_t point;
    vect_t  normal;
    pt2d_t  uv;
    bool    trimmed;
    bool    closeToEdge;
    bool    oob;
    // XXX - calculate the dot of the dir with the normal here!
    SubsurfaceBBNode const * sbv;

    brep_hit(const ON_BrepFace& f, const point_t orig, const point_t p, const vect_t n, const pt2d_t _uv)
	: face(f), trimmed(false), closeToEdge(false), oob(false), sbv(NULL)
    {
	VMOVE(origin, orig);
	VMOVE(point, p);
	VMOVE(normal, n);
	move(uv, _uv);
    }

    brep_hit(const brep_hit& h)
	: face(h.face), trimmed(h.trimmed), closeToEdge(h.closeToEdge), oob(h.oob), sbv(h.sbv)
    {
	VMOVE(origin, h.origin);
	VMOVE(point, h.point);
	VMOVE(normal, h.normal);
	move(uv, h.uv);
    }

    brep_hit& operator=(const brep_hit& h) {
	const_cast<ON_BrepFace&>(face) = h.face;
	VMOVE(origin, h.origin);
	VMOVE(point, h.point);
	VMOVE(normal, h.normal);
	move(uv, h.uv);
	trimmed = h.trimmed;
	closeToEdge = h.closeToEdge;
	oob = h.oob;
	sbv = h.sbv;

        return *this;
    }

    bool operator==(const brep_hit& h) {
	return NEAR_ZERO(DIST_PT_PT(point,h.point), BREP_SAME_POINT_TOLERANCE);
    }

    bool operator<(const brep_hit& h) {
	return DIST_PT_PT(point,origin) < DIST_PT_PT(h.point,origin);
    }
};
typedef std::list<brep_hit> HitList;

// class HitSorter : public std::less<brep_hit>
// {
//     point_t origin;
// public:
//     HitSorter(point_t o) {
// 	VMOVE(origin, o);
//     }

//     bool operator()(const brep_hit& left, const brep_hit& right) {
// 	return DIST_PT_PT(left.point,origin) < DIST_PT_PT(right.point,origin);
//     }
// };

void
brep_r(const ON_Surface* surf, plane_ray& pr, pt2d_t uv, ON_3dPoint& pt, ON_3dVector& su, ON_3dVector& sv, pt2d_t R)
{
    assert(surf->Ev1Der(uv[0], uv[1], pt, su, sv));
    R[0] = VDOT(pr.n1,((fastf_t*)pt)) - pr.d1;
    R[1] = VDOT(pr.n2,((fastf_t*)pt)) - pr.d2;
}

void
brep_newton_iterate(const ON_Surface* surf, plane_ray& pr, pt2d_t R, ON_3dVector& su, ON_3dVector& sv, pt2d_t uv, pt2d_t out_uv)
{
    mat2d_t jacob = { VDOT(pr.n1,((fastf_t*)su)), VDOT(pr.n1,((fastf_t*)sv)),
		      VDOT(pr.n2,((fastf_t*)su)), VDOT(pr.n2,((fastf_t*)sv)) };
    mat2d_t inv_jacob;
    if (mat2d_inverse(inv_jacob, jacob)) { // check inverse validity
	pt2d_t tmp;
	mat2d_pt2d_mul(tmp, inv_jacob, R);
	pt2dsub(out_uv, uv, tmp);
    }
    else {
	TRACE2("inverse failed"); // XXX how to handle this?
	move(out_uv,uv);
    }
}

#define BREP_INTERSECT_RIGHT_OF_EDGE            -5
#define BREP_INTERSECT_MISSED_EDGE              -4
#define BREP_INTERSECT_ROOT_ITERATION_LIMIT  	-3
#define BREP_INTERSECT_ROOT_DIVERGED            -2
#define BREP_INTERSECT_OOB       		-1
#define BREP_INTERSECT_TRIMMED     		0
#define BREP_INTERSECT_FOUND   	    		1

static const char* BREP_INTERSECT_REASONS[] = {
    "grazed to the right of the edge",
    "missed the edge altogether (outside tolerance)",
    "hit root iteration limit",
    "root diverged",
    "out of subsurface bounds",
    "trimmed",
    "found"};
#define BREP_INTERSECT_GET_REASON(i) BREP_INTERSECT_REASONS[(i)+5]

int
brep_edge_check(int reason,
		const SubsurfaceBBNode* sbv,
		const ON_BrepFace* face,
		const ON_Surface* surf,
		const ON_Ray& r,
		HitList& hits)
{
    // if the intersection was not found for any reason, we need to
    // check and see if we are close to any topological edges; we may
    // have hit a crack...

    // the proper way to do this is to only look at edges
    // interesecting with the subsurface bounding box... but for
    // now, we'll look at the edges associated with the face for the bounding box...

    // XXX - optimize this

    set<ON_BrepEdge*> edges;
    ON_3dPoint pt;
    for (int i = 0; i < face->LoopCount(); i++) {
	ON_BrepLoop* loop = face->Loop(i);
	for (int j = 0; j < loop->TrimCount(); j++) {
	    ON_BrepTrim* trim = loop->Trim(j);
	    ON_BrepEdge* edge = trim->Edge();
	    pair<set<ON_BrepEdge*>::iterator, bool> res = edges.insert(edge);
	    //	    if (res.second) {
	    // only check if its the first time we've seen this
	    // edge
	    const ON_Curve* curve = edge->EdgeCurveOf();
	    Sample s;
	    if (curve->CloseTo(ON_3dPoint(hits.back().point), BREP_EDGE_MISS_TOLERANCE, s)) {
		TRACE1("CLOSE TO EDGE");
		hits.back().closeToEdge = true;
		return BREP_INTERSECT_FOUND;
	    }
	}
    }
    return BREP_INTERSECT_TRIMMED;
}


int
brep_intersect(const SubsurfaceBBNode* sbv, const ON_BrepFace* face, const ON_Surface* surf, pt2d_t uv, ON_Ray& ray, HitList& hits)
{
    int found = BREP_INTERSECT_ROOT_ITERATION_LIMIT;
    fastf_t Dlast = MAX_FASTF;
    int diverge_iter = 0;
    pt2d_t Rcurr;
    pt2d_t new_uv;
    ON_3dPoint pt;
    ON_3dVector su;
    ON_3dVector sv;
    plane_ray pr;
    brep_get_plane_ray(ray, pr);
    for (int i = 0; i < BREP_MAX_ITERATIONS; i++) {
	brep_r(surf,pr,uv,pt,su,sv,Rcurr);
	//fastf_t d = v2mag(Rcurr);
	fastf_t d = DIST_PT_PT(pt,ray.m_origin);
	//if (d < BREP_INTERSECTION_ROOT_EPSILON) {
	if (NEAR_ZERO(d-Dlast,BREP_INTERSECTION_ROOT_EPSILON)) {
	    TRACE1("R:"<<ON_PRINT2(Rcurr));
	    found = BREP_INTERSECT_FOUND; break;
	} else if (d > Dlast) {
	    found = BREP_INTERSECT_ROOT_DIVERGED; //break;
	    diverge_iter++;
	    if (diverge_iter > 10)
		break;
		//return brep_edge_check(found, sbv, face, surf, ray, hits);
	}
	brep_newton_iterate(surf, pr, Rcurr, su, sv, uv, new_uv);
	move(uv, new_uv);
	Dlast = d;
    }
    if (found > 0) {
	fastf_t l,h;

	ON_3dPoint _pt;
	ON_3dVector _norm;
	surf->EvNormal(uv[0],uv[1],_pt,_norm);
	if (face->m_bRev) _norm.Reverse();
	hits.push_back(brep_hit(*face,(const fastf_t*)ray.m_origin,(const fastf_t*)_pt,(const fastf_t*)_norm, uv));
	hits.back().sbv = sbv;

 	if (!sbv->m_u.Includes(uv[0]) || !sbv->m_v.Includes(uv[1])) {
// 	    if (!sbv->m_u.Includes(uv[0]-BREP_SAME_POINT_TOLERANCE) ||
// 		!sbv->m_v.Includes(uv[1]-BREP_SAME_POINT_TOLERANCE)) {
	    hits.back().oob = true;
	    return BREP_INTERSECT_OOB;
	}


	if (sbv->doTrimming() && brep_pt_trimmed(uv, *face)) {
	    hits.back().trimmed = true;
	    TRACE1("Should be TRIMMED!");
	    // if the point was trimmed, see if it is close to the edge before removing it
	    return brep_edge_check(BREP_INTERSECT_TRIMMED, sbv, face, surf, ray, hits);
	    //return BREP_INTERSECT_TRIMMED;
	}
    }

    return found;
}


static void
opposite(const SubsurfaceBBNode* sbv, pt2d_t uv)
{
    if (uv[1] > sbv->m_v.Mid()) {
	// quadrant I or II
	uv[1] = sbv->m_v.Min();
	if (uv[0] > sbv->m_u.Mid())
	    // quad I
	    uv[0] = sbv->m_u.Min();
	else
	    // quad II
	    uv[0] = sbv->m_u.Max();
    } else {
	uv[1] = sbv->m_v.Max();
	if (uv[0] > sbv->m_u.Mid())
	    uv[0] = sbv->m_u.Min();
	else
	    uv[0] = sbv->m_u.Max();
    }
}

typedef std::pair<int,int> ip_t;
typedef std::list<ip_t> MissList;

static int
sign(double val) {
    if (val >= 0.0) return 1;
    else return -1;
}

#define PLOTTING 1
#if PLOTTING

#include "plot3.h"

static int pcount = 0;
static FILE* plot = NULL;
static FILE*
plot_file() {
    if (plot == NULL) {
	plot = fopen("out.pl","w");
	point_t min, max;
	VSET(min,-2048,-2048,-2048);
	VSET(max,2048,2048,2048);
	pdv_3space(plot,min,max);
    }
    return plot;
}

#define COLOR_PLOT(r,g,b) pl_color(plot_file(),(r),(g),(b))
#define PT_PLOT(p) 	{ 			\
    point_t 	pp; 				\
    VSCALE(pp,p,1.001); 			\
    pdv_3box(plot_file(),p,pp); 		\
}
#define LINE_PLOT(p1,p2) pdv_3move(plot_file(),p1); pdv_3line(plot_file(),p1,p2)
#define BB_PLOT(p1,p2) pdv_3box(plot_file(),p1,p2)
#endif

/**
 *  			R T _ B R E P _ S H O T
 *
 *  Intersect a ray with a brep.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_brep_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
    //TRACE1("rt_brep_shot origin:" << ON_PRINT3(rp->r_pt) << " dir:" << ON_PRINT3(rp->r_dir));
    TRACE("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
    vect_t invdir;
    struct brep_specific* bs = (struct brep_specific*)stp->st_specific;

    // check the hierarchy to see if we have a hit at a leaf node
    BBNode::IsectList inters;
    ON_Ray r = toXRay(rp);
    bs->bvh->intersectsHierarchy(r, &inters);

    if (inters.size() == 0) return 0; // MISS
    TRACE1("bboxes: " << inters.size());

    // find all the hits (XXX very inefficient right now!)
    HitList all_hits; // record all hits
    MissList misses; // XXX - get rid of this stuff (for debugging)
    int s = 0;
    for (BBNode::IsectList::iterator i = inters.begin(); i != inters.end(); i++) {
	const SubsurfaceBBNode* sbv = dynamic_cast<SubsurfaceBBNode*>((*i).m_node);
	const ON_BrepFace* f = sbv->m_face;
	const ON_Surface* surf = f->SurfaceOf();
	brep_hit* hit;
	pt2d_t uv = {sbv->m_u.Mid(),sbv->m_v.Mid()};
	TRACE1("surface: " << s);
	int status = brep_intersect(sbv, f, surf, uv, r, all_hits);
	if (status == BREP_INTERSECT_FOUND) {
	    TRACE("INTERSECTION: " << PT(all_hits.back().point) << all_hits.back().trimmed << ", " << all_hits.back().closeToEdge << ", " << all_hits.back().oob);
	} else {
	    TRACE1("dammit");
	    misses.push_back(ip_t(all_hits.size()-1,status));
	}
	s++;
    }


    HitList hits = all_hits;

    // sort the hits
    hits.sort();

    int num = 0;
    for (HitList::iterator i = hits.begin(); i != hits.end(); ++i) {
	TRACE("hit " << num << ": " << PT(i->point) << " [" << VDOT(i->normal,rp->r_dir) << "] " << i->trimmed << ", " << i->closeToEdge << ", " << i->oob);
	++num;
    }


    TRACE("---");
    num = 0;
    for (HitList::iterator i = hits.begin(); i != hits.end(); ++i) {
	if ((i->trimmed && !i->closeToEdge) || i->oob || NEAR_ZERO(VDOT(i->normal,rp->r_dir),RT_DOT_TOL)) { // remove what we were removing earlier
	    if (i->oob) {
		TRACE("\toob u: " << i->uv[0] << ", " << IVAL(i->sbv->m_u));
		TRACE("\toob v: " << i->uv[1] << ", " << IVAL(i->sbv->m_v));
	    }
	    i = hits.erase(i); --i;
	    continue;
	}
	TRACE("hit " << num << ": " << PT(i->point) << " [" << VDOT(i->normal,rp->r_dir) << "]");
	++num;
    }

    {
	// we should have "valid" points now, remove duplicates or grazes
	HitList::iterator last = hits.begin();
	HitList::iterator i = hits.begin();
	++i;
	while (i != hits.end()) {
	    if ((*i) == (*last)) {
		double lastDot = VDOT(last->normal,rp->r_dir);
		double iDot = VDOT(i->normal,rp->r_dir);

		if (sign(lastDot) != sign(iDot)) {
		    // delete them both
		    i = hits.erase(last);
		    i = hits.erase(i);
		    last = i;
		    ++i;
		} else {
		    // just delete the second
		    i = hits.erase(i);
		}
	    } else {
		last = i;
		++i;
	    }
	}
    }

    // remove "duplicate" points
//     HitList::iterator new_end = unique(hits.begin(), hits.end());
//     hits.erase(new_end, hits.end());

    if (hits.size() > 1 && (hits.size() % 2) != 0) {
	cerr << "WTF???" << endl;
#if PLOTTING
	pcount++;
	if (pcount > -1) {
	    point_t ray;
	    point_t vscaled;
	    VSCALE(vscaled,rp->r_dir,100);
	    VADD2(ray,rp->r_pt,vscaled);
	    COLOR_PLOT(200,200,200);
	    LINE_PLOT(rp->r_pt,ray);
	}
#endif

	num = 0;
	int lastSign = 0;
	MissList::iterator m = misses.begin();
	for (HitList::iterator i = all_hits.begin(); i != all_hits.end(); ++i) {
	    double dot = VDOT(i->normal,rp->r_dir);

#if PLOTTING
	    if (pcount > -1) {
		// set the color of point and normal
		if (i->trimmed && i->closeToEdge) {
		    COLOR_PLOT(0,0,255); // blue is trimmed but close to edge
		} else if (i->trimmed) {
		    COLOR_PLOT(255,255,0); // yellow trimmed
		} else if (i->oob) {
		    COLOR_PLOT(255,0,0); // red is oob
		} else if (NEAR_ZERO(VDOT(i->normal,rp->r_dir),RT_DOT_TOL)) {
		    COLOR_PLOT(0,255,255); // purple is grazing
		} else {
		    COLOR_PLOT(0,255,0); // green is regular surface
		}

		// draw normal
		point_t v;
		VADD2(v,i->point,i->normal);
		LINE_PLOT(i->point,v);

		// draw intersection
		PT_PLOT(i->point);

		// draw bounding box
		BB_PLOT(i->sbv->m_node.m_min,i->sbv->m_node.m_max);
		fflush(plot_file());
	    }
#endif

// 	    if ((num == 0 && dot > 0) || sign(dot) == lastSign) { // remove hits with "bad" normals
// 		i = hits.erase(i);
// 		--i;
// 		TRACE("removed a hit!");
// 		continue;
// 	    } else {
// 		lastSign = sign(dot);
// 	    }

	    TRACE("hit " << num << ": " << ON_PRINT3(i->point) << " [" << dot << "]");
	    while (m->first == num) {
		TRACE("miss " << num << ": " << BREP_INTERSECT_GET_REASON(m->second));
		++m;
	    }
	    num++;
	}
	while (m != misses.end()) {
	    TRACE("miss " << BREP_INTERSECT_GET_REASON(m->second));
	    ++m;
	}
    }

    bool hit = false;
    if (hits.size() > 0) {
	if (hits.size() % 2 == 0) {
	    // take each pair as a segment
	    for (HitList::iterator i = hits.begin(); i != hits.end(); ++i) {
		brep_hit& in = *i;
		i++;
		brep_hit& out = *i;

		register struct seg* segp;
		RT_GET_SEG(segp, ap->a_resource);
		segp->seg_stp = stp;

		VMOVE(segp->seg_in.hit_point, in.point);
		VMOVE(segp->seg_in.hit_normal, in.normal);
		segp->seg_in.hit_dist = DIST_PT_PT(rp->r_pt,in.point);
		segp->seg_in.hit_surfno = in.face.m_face_index;
		VSET(segp->seg_in.hit_vpriv,in.uv[0],in.uv[1],0.0);

		VMOVE(segp->seg_out.hit_point, out.point);
		VMOVE(segp->seg_out.hit_normal, out.normal);
		segp->seg_out.hit_dist = DIST_PT_PT(rp->r_pt,out.point);
		segp->seg_out.hit_surfno = out.face.m_face_index;
		VSET(segp->seg_out.hit_vpriv,out.uv[0],out.uv[1],0.0);

		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	    }
	    hit = true;
	}
	else {
	    TRACE2("screen xy: " << ap->a_x << "," << ap->a_y);
	}
    }

    return (hit) ? hits.size() : 0; // MISS
}


/**
 *  			R T _ B R E P _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_brep_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{

}


/**
 *			R T _ B R E P _ C U R V E
 *
 *  Return the curvature of the nurb.
 */
void
rt_brep_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
    /* XXX todo */
}

/**
 *                      R T _ B R E P _ C L A S S
 *
 *  Don't know what this is supposed to do...
 *
 *  Looking at g_arb.c, seems the actual signature is:
 *    class(const struct soltab* stp,
 *          const fastf_t* min,
 *          const fastf_t* max,
 *          const struct bn_tol* tol)
 *
 *  Hmmm...
 */
int
rt_brep_class()
{
  return RT_CLASSIFY_UNIMPLEMENTED;
}


/**
 *  			R T _ B R E P _ U V
 *
 *  For a hit on the surface of an nurb, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_brep_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
    uvp->uv_u = hitp->hit_vpriv[0];
    uvp->uv_v = hitp->hit_vpriv[1];
}


/**
 *		R T _ B R E P _ F R E E
 */
void
rt_brep_free(register struct soltab *stp)
{
    TRACE1("rt_brep_free");
    struct brep_specific* bs = (struct brep_specific*)stp->st_specific;
    brep_specific_delete(bs);
}


void
plot_bbnode(BBNode* node, struct bu_list* vhead) {
  ON_3dPoint min = node->m_node.m_min;
  ON_3dPoint max = node->m_node.m_max;
  point_t verts[] = {{min[0],min[1],min[2]},
		     {min[0],max[1],min[2]},
		     {min[0],max[1],max[2]},
		     {min[0],min[1],max[2]},
		     {max[0],min[1],min[2]},
		     {max[0],max[1],min[2]},
		     {max[0],max[1],max[2]},
		     {max[0],min[1],max[2]}};

  if (node->isLeaf()) {

  for (int i = 0; i <= 4; i++) {
    RT_ADD_VLIST(vhead, verts[i%4], (i == 0) ? BN_VLIST_LINE_MOVE : BN_VLIST_LINE_DRAW);
  }
  for (int i = 0; i <= 4; i++) {
    RT_ADD_VLIST(vhead, verts[(i%4)+4], (i == 0) ? BN_VLIST_LINE_MOVE : BN_VLIST_LINE_DRAW);
  }
  for (int i = 0; i < 4; i++) {
    RT_ADD_VLIST(vhead, verts[i], BN_VLIST_LINE_MOVE);
    RT_ADD_VLIST(vhead, verts[i+4], BN_VLIST_LINE_DRAW);
  }

  }

  for (int i = 0; i < node->m_children.size(); i++) {
    plot_bbnode(node->m_children[i], vhead);
  }
}

/**
 *			R T _ B R E P _ P L O T
 */
int
rt_brep_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
    TRACE1("rt_brep_plot");
    struct rt_brep_internal* bi;

    RT_CK_DB_INTERNAL(ip);
    bi = (struct rt_brep_internal*)ip->idb_ptr;
    RT_BREP_CK_MAGIC(bi);

    // XXX below does NOT work for non-trivial faces, in addition to
    // the fact that openNURBS does NOT support meshes!
    //
    // XXX currently not handling the tolerance
    //     ON_MeshParameters mp;
    //     mp.JaggedAndFasterMeshParameters();

    //     ON_SimpleArray<ON_Mesh*> mesh_list;
    //     bi->brep->CreateMesh(mp, mesh_list);

    //     point_t pt1, pt2;
    //     ON_SimpleArray<ON_2dex> edges;
    //     for (int i = 0; i < mesh_list.Count(); i++) {
    // 	const ON_Mesh* mesh = mesh_list[i];
    // 	mesh->GetMeshEdges(edges);
    // 	for (int j = 0; j < edges.Count(); j++) {
    // 	    ON_MeshVertexRef v1 = mesh->VertexRef(edges[j].i);
    // 	    ON_MeshVertexRef v2 = mesh->VertexRef(edges[j].j);
    // 	    VSET(pt1, v1.Point().x, v1.Point().y, v1.Point().z);
    // 	    VSET(pt2, v2.Point().x, v2.Point().y, v2.Point().z);
    // 	    RT_ADD_VLIST(vhead, pt1, BN_VLIST_LINE_MOVE);
    // 	    RT_ADD_VLIST(vhead, pt2, BN_VLIST_LINE_DRAW);
    // 	}
    // 	edges.Empty();
    //     }

    // So we'll do it by hand by grabbing each topological edge from
    // the brep and rendering it that way...
    ON_Brep* brep = bi->brep;

    point_t pt1, pt2;
//     for (int i = 0; i < brep->m_F.Count(); i++) {
//       ON_BrepFace& f = brep->m_F[i];
//       SurfaceTree st(&f);
//       plot_bbnode(st.getRootNode(), vhead);
//     }

    for (int i = 0; i < bi->brep->m_E.Count(); i++) {
	ON_BrepEdge& e = brep->m_E[i];
	const ON_Curve* crv = e.EdgeCurveOf();

	if (crv->IsLinear()) {
	    ON_BrepVertex& v1 = brep->m_V[e.m_vi[0]];
	    ON_BrepVertex& v2 = brep->m_V[e.m_vi[1]];
	    VMOVE(pt1, v1.Point());
	    VMOVE(pt2, v2.Point());
	    RT_ADD_VLIST(vhead, pt1, BN_VLIST_LINE_MOVE);
	    RT_ADD_VLIST(vhead, pt2, BN_VLIST_LINE_DRAW);
	} else {
	    ON_Interval dom = crv->Domain();
	    // XXX todo: dynamically sample the curve
	    for (int i = 0; i <= 10; i++) {
		ON_3dPoint p = crv->PointAt(dom.ParameterAt((double)i/10.0));
		VMOVE(pt1, p);
		if (i == 0) {
		    RT_ADD_VLIST(vhead, pt1, BN_VLIST_LINE_MOVE);
		}
		else {
		    RT_ADD_VLIST(vhead, pt1, BN_VLIST_LINE_DRAW);
		}
	    }
	}
    }

    return 0;
}


/**
 *			R T _ B R E P _ T E S S
 */
int
rt_brep_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
    return -1;
}


/* XXX In order to facilitate exporting the ON_Brep object without a
 * whole lot of effort, we're going to (for now) extend the
 * ON_BinaryArchive to support an "in-memory" representation of a
 * binary archive. Currently, the openNURBS library only supports
 * file-based archiving operations. This implies the
 */

class ON_CLASS RT_MemoryArchive : public ON_BinaryArchive
{
public:
  RT_MemoryArchive();
  RT_MemoryArchive(genptr_t memory, size_t len);
  virtual ~RT_MemoryArchive();

  // ON_BinaryArchive overrides
  size_t CurrentPosition() const;
  bool SeekFromCurrentPosition(int);
  bool SeekFromStart(size_t);
  bool AtEnd() const;

  size_t Size() const;
  /**
   * Generate a byte-array copy of this memory archive.
   * Allocates memory using bu_malloc, so must be freed with bu_free
   */
  genptr_t CreateCopy() const;

protected:
  size_t Read(size_t, void*);
  size_t Write(size_t, const void*);
  bool Flush();

private:
  size_t pos;
  std::vector<char> m_buffer;
};

RT_MemoryArchive::RT_MemoryArchive()
  : ON_BinaryArchive(ON::write3dm), pos(0)
{
}

RT_MemoryArchive::RT_MemoryArchive(genptr_t memory, size_t len)
  : ON_BinaryArchive(ON::read3dm), pos(0)
{
  m_buffer.reserve(len);
  for (int i = 0; i < len; i++) {
    m_buffer.push_back(((char*)memory)[i]);
  }
}

RT_MemoryArchive::~RT_MemoryArchive()
{
}

size_t
RT_MemoryArchive::CurrentPosition() const
{
  return pos;
}

bool
RT_MemoryArchive::SeekFromCurrentPosition(int seek_to)
{
  if (pos + seek_to > m_buffer.size()) return false;
  pos += seek_to;
  return true;
}

bool
RT_MemoryArchive::SeekFromStart(size_t seek_to)
{
  if (seek_to > m_buffer.size()) return false;
  pos = seek_to;
  return true;
}

bool
RT_MemoryArchive::AtEnd() const
{
  return pos >= m_buffer.size();
}

size_t
RT_MemoryArchive::Size() const
{
  return m_buffer.size();
}

genptr_t
RT_MemoryArchive::CreateCopy() const
{
  genptr_t memory = (genptr_t)bu_malloc(m_buffer.size()*sizeof(char),"rt_memoryarchive createcopy");
  const int size = m_buffer.size();
  for (int i = 0; i < size; i++) {
    ((char*)memory)[i] = m_buffer[i];
  }
  return memory;
}

size_t
RT_MemoryArchive::Read(size_t amount, void* buf)
{
    const int read_amount = (pos + amount > m_buffer.size()) ? m_buffer.size()-pos : amount;
    const int start = pos;
    for (; pos < (start+read_amount); pos++) {
	((char*)buf)[pos-start] = m_buffer[pos];
    }
    return read_amount;
}

size_t
RT_MemoryArchive::Write(const size_t amount, const void* buf)
{
    // the write can come in at any position!
    const int start = pos;
    // resize if needed to support new data
    if (m_buffer.size() < (start+amount)) {
	m_buffer.resize(start+amount);
    }
    for (; pos < (start+amount); pos++) {
	m_buffer[pos] = ((char*)buf)[pos-start];
    }
    return amount;
}

bool
RT_MemoryArchive::Flush()
{
  return true;
}

#include <iostream>
/**
 *			R T _ B R E P _ E X P O R T 5
 */
int
rt_brep_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
    TRACE1("rt_brep_export5");
    struct rt_brep_internal* bi;

    RT_CK_DB_INTERNAL(ip);
    if (ip->idb_type != ID_BREP) return -1;
    bi = (struct rt_brep_internal*)ip->idb_ptr;
    RT_BREP_CK_MAGIC(bi);

    BU_INIT_EXTERNAL(ep);

    RT_MemoryArchive archive;
    /* XXX what to do about the version */
    ONX_Model model;

    {
	ON_Layer default_layer;
	default_layer.SetLayerIndex(0);
	default_layer.SetLayerName("Default");
	model.m_layer_table.Reserve(1);
	model.m_layer_table.Append(default_layer);
    }

    ONX_Model_Object& mo = model.m_object_table.AppendNew();
    mo.m_object = bi->brep;
    mo.m_attributes.m_layer_index = 0;
    mo.m_attributes.m_name = "brep";
    fprintf(stderr, "m_object_table count: %d\n", model.m_object_table.Count());

    model.m_properties.m_RevisionHistory.NewRevision();
    model.m_properties.m_Application.m_application_name = "BRL-CAD B-Rep primitive";

    model.Polish();
    ON_TextLog err(stderr);
    bool ok = model.Write(archive, 4, "export5", &err);
    if (ok) {
	ep->ext_nbytes = archive.Size();
	ep->ext_buf = archive.CreateCopy();
	return 0;
    } else {
	return -1;
    }
}


/**
 *			R T _ B R E P _ I M P O R T 5
 */
int
rt_brep_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
    ON::Begin();
    TRACE1("rt_brep_import5");
    struct rt_brep_internal* bi;
    BU_CK_EXTERNAL(ep);
    RT_CK_DB_INTERNAL(ip);
    ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
    ip->idb_type = ID_BREP;
    ip->idb_meth = &rt_functab[ID_BREP];
    ip->idb_ptr = bu_malloc(sizeof(struct rt_brep_internal), "rt_brep_internal");

    bi = (struct rt_brep_internal*)ip->idb_ptr;
    bi->magic = RT_BREP_INTERNAL_MAGIC;

    RT_MemoryArchive archive(ep->ext_buf, ep->ext_nbytes);
    ONX_Model model;
    ON_TextLog dump(stderr);
    //archive.Dump3dmChunk(dump);
    model.Read(archive, &dump);

    if (model.IsValid(&dump)) {
	ONX_Model_Object mo = model.m_object_table[0];
	// XXX does openNURBS force us to copy? it seems the answer is
	// YES due to the const-ness
	bi->brep = new ON_Brep(*ON_Brep::Cast(mo.m_object));
	return 0;
    } else {
	return -1;
    }
}


/**
 *			R T _ B R E P _ I F R E E
 */
void
rt_brep_ifree(struct rt_db_internal *ip)
{
    TRACE1("rt_brep_ifree");
    struct rt_brep_internal* bi;
    RT_CK_DB_INTERNAL(ip);
    bi = (struct rt_brep_internal*)ip->idb_ptr;
    RT_BREP_CK_MAGIC(bi);
    if (bi->brep != NULL)
	delete bi->brep;
    bu_free(bi, "rt_brep_internal free");
    ip->idb_ptr = GENPTR_NULL;
}


/**
 *			R T _ B R E P _ D E S C R I B E
 */
int
rt_brep_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
    return 0;
}

/**
 *                      R T _ B R E P _ T C L G E T
 */
int
rt_brep_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
    return 0;
}


/**
 *                      R T _ B R E P _ T C L A D J U S T
 */
int
rt_brep_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
    return 0;
}

/** @@} */

/*
 * Local Variables:
 * mode: C++
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.47
log
@add more data for debugging and hit processing (i.e. label oob hits and record the subsurface bounding volume); add plotting routines for debugging shotlines graphically in MGED
@
text
@d142 1
a142 1
inline void 
d152 1
a152 1
bool 
d161 1
a161 1
    surf->GetDomain(0, &umin, &umax);    
d171 1
a171 1
	    // intersections += brep_count_intersections(ray, trimCurve);	    
d182 1
a182 1
void 
d190 2
a191 2
	
	
d208 1
a208 1
	    for (int j = 0; j < loop.m_ti.Count(); j++) {	    
d211 1
a211 1
		
d268 1
a268 1
    
d330 1
a330 1
    
d350 1
a350 1
    
d355 2
a356 2
// void 
// brep_intersect_bv(IsectList& inters, struct xray* r, BoundingVolume* bv) 
d369 1
a369 1
void 
d405 2
a406 2
    
    brep_hit(const ON_BrepFace& f, const point_t orig, const point_t p, const vect_t n, const pt2d_t _uv) 
d409 1
a409 1
	VMOVE(origin, orig); 
d415 1
a415 1
    brep_hit(const brep_hit& h) 
d421 1
a421 1
	move(uv, h.uv);	
d429 1
a429 1
	move(uv, h.uv);	
d506 3
a508 3
		const SubsurfaceBBNode* sbv, 
		const ON_BrepFace* face, 
		const ON_Surface* surf, 
d515 1
a515 1
    
d519 1
a519 1
    
d539 1
a539 1
	    } 
d541 1
a541 1
    }    
d546 1
a546 1
int 
d561 1
a561 1
	//fastf_t d = v2mag(Rcurr);	
d566 1
a566 1
	    found = BREP_INTERSECT_FOUND; break; 
d573 1
a573 1
	}	
d577 1
a577 1
    }    
d588 2
a589 2
 	if (!sbv->m_u.Includes(uv[0]) || !sbv->m_v.Includes(uv[1])) {	    
// 	    if (!sbv->m_u.Includes(uv[0]-BREP_SAME_POINT_TOLERANCE) || 
d603 1
a603 1
    } 
d609 2
a610 2
static void 
opposite(const SubsurfaceBBNode* sbv, pt2d_t uv) 
d646 1
a646 1
static FILE* 
d702 2
a703 2
	const ON_Surface* surf = f->SurfaceOf();       
	brep_hit* hit; 
d722 1
a722 1
    int num = 0;    
d726 1
a726 1
    }    
d742 1
a742 1
    }    
d767 1
a767 1
	    }	    
d771 1
a771 1
    // remove "duplicate" points      
d774 1
a774 1
    
d809 1
a809 1
		
d814 1
a814 1
		
d817 1
a817 1
		
d844 1
a844 1
    }    
d854 1
a854 1
		
d871 1
a871 1
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );		
d874 1
a874 1
	} 
d879 1
a879 1
    
d892 1
a892 1
    
d1002 1
a1002 1
    // the fact that openNURBS does NOT support meshes! 
d1007 1
a1007 1
    
d1010 1
a1010 1
    
d1029 1
a1029 1
    ON_Brep* brep = bi->brep;    
d1064 1
a1064 1
    
d1277 1
a1277 1
    
d1280 1
a1280 1
    
d1286 1
a1286 1
    
@


14.46
log
@add support for plotting rays and intersection points to stdout during debug - see why we get the wrong thing! still can't see the individual points yet
@
text
@d314 1
a314 1
    VSETALL(adjust,0.02);
d402 3
d407 1
a407 1
	: face(f), trimmed(false), closeToEdge(false)
d416 1
a416 1
	: face(h.face), trimmed(h.trimmed), closeToEdge(h.closeToEdge)
d432 2
d439 1
a439 1
	return NEAR_ZERO(DIST_PT_PT(point,h.point), 2*BREP_EDGE_MISS_TOLERANCE);
d464 1
a464 1
    surf->Ev1Der(uv[0], uv[1], pt, su, sv);
d481 1
a481 1
	TRACE1("inverse failed"); // XXX how to handle this?
d563 1
a563 1
	//	if (d < BREP_INTERSECTION_ROOT_EPSILON) {
d570 1
a570 1
	    if (diverge_iter > 10) 
a580 3
	if (!sbv->m_u.Includes(uv[0]) || !sbv->m_v.Includes(uv[1])) 
	    return BREP_INTERSECT_OOB;

d586 9
a604 1

d644 13
d658 8
a665 3
#define COLOR_PLOT(r,g,b) pl_color(stdout,(r),(g),(b))
#define PT_PLOT(p) pd_3point(stdout,(p)[0],(p)[1],(p)[2])
#define LINE_PLOT(p1,p2) pdv_3move(stdout,p1); pdv_3line(stdout,p1,p2)
d708 1
a708 1
	    TRACE1("INTERSECTION: " << PT(hits.back().point));
d710 1
d724 1
a724 1
	TRACE("hit " << num << ": " << PT(i->point) << " [" << VDOT(i->normal,rp->r_dir) << "]");
d732 5
a736 1
	if (i->trimmed && !i->closeToEdge) { // remove what we were removing earlier
d744 27
d772 2
a773 2
    HitList::iterator new_end = unique(hits.begin(), hits.end());
    hits.erase(new_end, hits.end());
d775 1
a775 1
    if (hits.size() > 0 && (hits.size() % 2) != 0) {
d778 9
a786 11
	point_t min, max;
	VSET(min,-2048,-2048,-2048);
	VSET(max,2048,2048,2048);
	pdv_3space(stdout,min,max);

	point_t ray;
	point_t vscaled;
	VSCALE(vscaled,rp->r_dir,10);
	VADD2(ray,rp->r_pt,vscaled);
	COLOR_PLOT(200,200,200);
	LINE_PLOT(rp->r_pt,ray);
d796 25
a820 13
	    // draw normal
	    point_t v;
	    VADD2(v,i->point,i->normal);
	    COLOR_PLOT(100,100,100);
	    LINE_PLOT(i->point,v);

	    // draw intersection
	    if (i->trimmed && i->closeToEdge) {
		COLOR_PLOT(0,0,255);
	    } else if (i->trimmed) {
		COLOR_PLOT(255,255,0);
	    } else {
		COLOR_PLOT(255,0,0);
a821 2
	    PT_PLOT(i->point);
	    fflush(stdout);
d876 1
a876 1
	    TRACE("screen xy: " << ap->a_x << "," << ap->a_y);
@


14.45
log
@added missing return statement
made sign() static
@
text
@d400 2
d404 1
a404 1
	: face(f)
d413 1
a413 1
	: face(h.face)
d418 1
a418 1
	move(uv, h.uv);
d426 3
a428 1
	move(uv, h.uv);
a518 1
    bool close = false;
a530 3
		TRACE1("NOT CLOSE TO EDGE");
		close = true;
	    } else {
d532 3
a534 1
	    }
d537 1
a537 5
    if (!close) {
	hits.pop_back();
	return BREP_INTERSECT_TRIMMED;
    }
    return BREP_INTERSECT_FOUND;
d586 1
d599 1
a599 1
void 
d629 11
d668 2
a669 2
    HitList hits;
    MissList misses;
d678 1
a678 1
	int status = brep_intersect(sbv, f, surf, uv, r, hits);
d682 1
a682 5
// 	    if (status == BREP_INTERSECT_TRIMMED || 
// 		status == BREP_INTERSECT_ROOT_ITERATION_LIMIT ||
// 		status == BREP_INTERSECT_RIGHT_OF_EDGE) continue;
//  	    TRACE("NO INTERSECTION: " << BREP_INTERSECT_GET_REASON(status));
	    misses.push_back(ip_t(hits.size()-1,status));
d688 2
d693 1
a693 1
    int num = 0;
a698 3
    // remove "duplicate" points      
    HitList::iterator new_end = unique(hits.begin(), hits.end());
    hits.erase(new_end, hits.end());
d703 4
d710 4
a714 1
    // check signs
d717 14
d734 1
a734 1
	for (HitList::iterator i = hits.begin(); i != hits.end(); ++i) {
d736 20
d1215 1
a1215 1
    ON_TextLog dump(stdout);
@


14.44
log
@remove dead code; fix edge check bug - not properly checking all edges; still debugging shot routine
@
text
@d425 2
d624 1
a624 1
int
@


14.43
log
@debug edge_check routine; simplify to closeness check (remove left-of check)
@
text
@d513 1
d521 10
a530 63
		// only check if its the first time we've seen this
		// edge
		const ON_Curve* curve = edge->EdgeCurveOf();
		Sample s;
		if (!curve->CloseTo(ON_3dPoint(hits.back().point), BREP_EDGE_MISS_TOLERANCE, s)) {
		    hits.pop_back();
		    return reason;
		}

// 		    // since the ray is within tolerance, we need to
// 		    // find out on which side of the curve it
// 		    // passes. If it's on the left side, then we've
// 		    // hit the surface
// 		    double curve_t = s.t, ray_t = s.ray_t;
// 		    // XXX - should probably use the gradient here		    
// // 		    double curve_t_forward = 
// // 			(trim->m_bRev3d) ? 
// // 			(curve_t - curve->Domain().Length() * 1e-2) 
// // 			: (curve_t + curve->Domain().Length() * 1e-2);
// // 		    ON_3dPoint c1 = curve->PointAt(curve_t);
// // 		    ON_3dPoint c2 = curve->PointAt(curve_t_forward);
// // 		    double ray_t_forward = ray_t + 1e-2;
//  		    ON_3dPoint r1 = r.PointAt(ray_t);
// // 		    ON_3dPoint r2 = r.PointAt(ray_t_forward);
// 		    ON_3dVector a = curve->TangentAt(curve_t);
// 		    if (trim->m_bRev3d) a.Reverse();
// 		    ON_3dVector b = r1 - s.pt;
// 		    b.Unitize();
// 		    ON_3dVector n = ON_CrossProduct(a,b);
// 		    // neg: right
// 		    // pos: left
		    
// 		    // below is the simplified version of:
// 		    //   b \dot (a \cross ( a \cross b ) )
// 		    // or
// 		    //   b * (a x (a x b))		    
// 		    // XXX - vectorize?
// // 		    double dir = 
// // 			4 * a[0] * a[1] * b[0] * b[1] - (a[1] * b[0] + a[0] * b[1]) * (a[1] * b[0] + a[0] * b[1]) +
// // 			4 * a[0] * a[2] * b[0] * b[2] - (a[2] * b[0] + a[0] * b[2]) * (a[2] * b[0] + a[0] * b[2]) +
// // 			4 * a[1] * a[2] * b[1] * b[2] - (a[2] * b[1] + a[1] * b[2]) * (a[2] * b[1] + a[1] * b[2]);		    

// 		    // if (dir < 0) { // rv is left of cv
// 		    if ((n * r.m_dir) > 0) {
// 			// now we need to find the closest point on the surface
// 			ON_2dPoint uv;
// 			get_closest_point(uv, 
// 					  const_cast<ON_BrepFace*>(face), 
// 					  r.PointAt(ray_t),
// 					  (SurfaceTree*)face->m_face_user.p);
// 			ON_3dPoint hit;
// 			ON_3dVector norm;
// 			face->SurfaceOf()->EvNormal(uv[0],uv[1], hit, norm);
// 			hits.push_back(brep_hit(*face, (const fastf_t*)r.m_origin, (const fastf_t*)hit, (const fastf_t*)norm, (const fastf_t*)uv));
// 			return BREP_INTERSECT_FOUND;
// 		    } else 
// 			return BREP_INTERSECT_RIGHT_OF_EDGE;
// 		} else {
// 		    return BREP_INTERSECT_MISSED_EDGE;
// 		}
		// }


d533 5
a537 1
    return reason;
a578 1

d585 2
a586 1
	if (sbv->doTrimming() && brep_pt_trimmed(uv, *face)) 
d589 2
d622 6
d658 1
d665 1
d676 1
a676 1
	
d692 7
d700 1
d704 1
d707 11
a717 1
	    TRACE("hit " << num << ": " << ON_PRINT3(i->point) << " [" << VDOT(i->normal,rp->r_dir) << "]");
d760 1
@


14.42
log
@attempting to debug edge_check code; added return states for edge check; removed some dead code
@
text
@d427 4
d519 1
a519 1
	    if (res.second) {
d524 27
a550 21
		if (curve->CloseTo(r, BREP_EDGE_MISS_TOLERANCE, s)) {
		    // since the ray is within tolerance, we need to
		    // find out on which side of the curve it
		    // passes. If it's on the left side, then we've
		    // hit the surface
		    double curve_t = s.t, ray_t = s.ray_t;
		    // XXX - should probably use the gradient here		    
// 		    double curve_t_forward = 
// 			(trim->m_bRev3d) ? 
// 			(curve_t - curve->Domain().Length() * 1e-2) 
// 			: (curve_t + curve->Domain().Length() * 1e-2);
// 		    ON_3dPoint c1 = curve->PointAt(curve_t);
// 		    ON_3dPoint c2 = curve->PointAt(curve_t_forward);
// 		    double ray_t_forward = ray_t + 1e-2;
// 		    ON_3dPoint r1 = r.PointAt(ray_t);
// 		    ON_3dPoint r2 = r.PointAt(ray_t_forward);
		    ON_3dVector a = curve->TangentAt(curve_t);
		    if (trim->m_bRev3d) a.Reverse();
		    ON_3dVector b = r.m_dir;
		    // neg: right
		    // pos: left
d552 31
a582 28
		    // below is the simplified version of:
		    //   b \dot (a \cross ( a \cross b ) )
		    // or
		    //   b * (a x (a x b))		    
		    // XXX - vectorize?
		    double dir = 
			4 * a[0] * a[1] * b[0] * b[1] - (a[1] * b[0] + a[0] * b[1]) * (a[1] * b[0] + a[0] * b[1]) +
			4 * a[0] * a[2] * b[0] * b[2] - (a[2] * b[0] + a[0] * b[2]) * (a[2] * b[0] + a[0] * b[2]) +
			4 * a[1] * a[2] * b[1] * b[2] - (a[2] * b[1] + a[1] * b[2]) * (a[2] * b[1] + a[1] * b[2]);		    

		    if (dir < 0) { // rv is left of cv
			// now we need to find the closest point on the surface
			ON_2dPoint uv;
			get_closest_point(uv, 
					  const_cast<ON_BrepFace*>(face), 
					  r.PointAt(ray_t),
					  (SurfaceTree*)face->m_face_user.p);
			ON_3dPoint hit;
			ON_3dVector norm;
			face->SurfaceOf()->EvNormal(uv[0],uv[1], hit, norm);
			hits.push_back(brep_hit(*face, (const fastf_t*)r.m_origin, (const fastf_t*)hit, (const fastf_t*)norm, (const fastf_t*)uv));
			return BREP_INTERSECT_FOUND;
		    } else 
			return BREP_INTERSECT_RIGHT_OF_EDGE;
		} else {
		    return BREP_INTERSECT_MISSED_EDGE;
		}
	    }
d614 2
a615 1
		return brep_edge_check(found, sbv, face, surf, ray, hits);
d625 2
a626 3
	    return brep_edge_check(BREP_INTERSECT_OOB, sbv, face, surf, ray, hits);
	if (sbv->doTrimming() && brep_pt_trimmed(uv, *face)) 
	    return brep_edge_check(BREP_INTERSECT_TRIMMED, sbv, face, surf, ray, hits);
d631 1
d633 4
d683 1
a683 1
    TRACE1("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
d712 1
a712 1
	    misses.push_back(ip_t(hits.size(),status));
d720 11
d733 1
a733 1
	int num = 0;
d737 1
a737 1
	    while (m->first == 0) {
d747 1
a747 1
    }
a763 4
		if (VDOT(rp->r_dir,in.normal) < 0) {
		    TRACE1("WRONG in normal!");
		    VSCALE(segp->seg_in.hit_normal,in.normal,-1);
		}
a769 4
		if (VDOT(rp->r_dir,out.normal) > 0) {
		    TRACE1("WRONG out normal!");
		    VSCALE(segp->seg_out.hit_normal,out.normal,-1);
		}
@


14.41
log
@update CloseTo signature (takes a Sample (rename to ON_CurveSample or something) to return the closes point)
@
text
@d471 2
d479 9
a487 6
static const char* BREP_INTERSECT_REASONS[] = {"hit root iteration limit",
					       "root diverged",
					       "out of subsurface bounds",
					       "trimmed",
					       "found"};
#define BREP_INTERSECT_GET_REASON(i) BREP_INTERSECT_REASONS[(i)+3]
a518 1
		double curve_t, ray_t;
d525 14
a538 14

		    // XXX - should probably use the gradient here
		    double curve_t_forward = 
			(trim->m_bRev3d) ? 
			(curve_t - curve->Domain().Length() * 1e-2) 
			: (curve_t + curve->Domain().Length() * 1e-2);
		    ON_3dPoint c1 = curve->PointAt(curve_t);
		    ON_3dPoint c2 = curve->PointAt(curve_t_forward);
		    double ray_t_forward = ray_t + 1e-2;
		    ON_3dPoint r1 = r.PointAt(ray_t);
		    ON_3dPoint r2 = r.PointAt(ray_t_forward);
		    ON_3dVector a = c2 - c1;
		    ON_3dVector b = r2 - r1;
		    
d552 1
a552 1
		    if (dir > 0) { // rv is left of cv
d557 1
a557 1
					  r1,
d564 4
a567 1
		    }
d600 2
a601 1
	    if (diverge_iter > 5) break;
d647 3
d679 1
d690 5
a694 1
	    TRACE1("NO INTERSECTION: " << BREP_INTERSECT_GET_REASON(status));
a696 15
	// XXX - how to minimize this extra intersection???
	// perhaps compare to the normal of the surface
// 	if (status == BREP_INTERSECT_FOUND) {
// 	    opposite(sbv, uv);
// 	    int status_b = brep_intersect(sbv, f, surf, uv, r, hits);
// 	    if (status_b == BREP_INTERSECT_FOUND) {
// 		TRACE("INTERSECTION: " << PT(hits.back().point));
// 	    } else {
// 		TRACE("NO INTERSECTION: " << BREP_INTERSECT_GET_REASON(status_b));
// 	    }
// 	}
	
	//	if (status < 0 && status > BREP_INTERSECT_ROOT_ITERATION_LIMIT) {
	//	    TRACE("no intersection: " << BREP_INTERSECT_GET_REASON(status));
	//	}       
d699 1
d702 18
a719 22
    int num = 0;
//     TRACE1("____");
//     for (HitList::iterator i = hits.begin(); i != hits.end(); ++i) {
// 	TRACE1("hit " << num << ": " << ON_PRINT3(i->point));
// 	num++;
//     }
//     TRACE1("----");
//     HitList::iterator i = hits.begin();
//     brep_hit last = *i;
//     ++i;
//     while (i != hits.end()) {
// 	brep_hit curr = *i;
// 	TRACE("comparing " << PT(last.point) << " to " << PT(curr.point));
// 	if (VAPPROXEQUAL(last.point,curr.point,BREP_INTERSECTION_ROOT_EPSILON)) {
// 	    TRACE("removing curr");
// 	    i = hits.erase(i);
// 	} else {
// 	    last = *i;
// 	    ++i;
// 	}
//     }
    
d735 4
d745 4
a757 5
	    int num = 0;
	    for (HitList::iterator i = hits.begin(); i != hits.end(); i++) {
	        TRACE("hit " << num << ": " << ON_PRINT3(i->point));
		num++;
	    }
@


14.40
log
@turn on edge curve check (begin implementing CloseTo)
@
text
@d515 2
a516 1
		if (curve->CloseTo(r, BREP_EDGE_MISS_TOLERANCE, curve_t, ray_t)) {
@


14.39
log
@debug acne problems, sort hits properly; continue to flesh out edge detection
@
text
@d502 31
a532 29
//     set<ON_BrepEdge*> edges;
//     ON_3dPoint pt;
//     for (int i = 0; i < face->LoopCount(); i++) {
// 	ON_BrepLoop* loop = face->Loop(i);
// 	for (int j = 0; j < loop->TrimCount(); j++) {
// 	    ON_BrepTrim* trim = loop->Trim(j);
// 	    ON_BrepEdge* edge = trim->Edge();
// 	    pair<set<ON_BrepEdge*>::iterator, bool> res = edges.insert(edge);
// 	    if (res.second) {
// 		// only check if its the first time we've seen this
// 		// edge
// 		const ON_Curve* curve = edge->EdgeCurveOf();
// 		double curve_t, ray_t;
// 		if (curve->CloseTo(r, BREP_EDGE_MISS_TOLERANCE, curve_t, ray_t)) {
// 		    // since the ray is within tolerance, we need to
// 		    // find out on which side of the curve it
// 		    // passes. If it's on the left side, then we've
// 		    // hit the surface

// 		    // XXX - should probably use the gradient here
// 		    double curve_t_forward = 
// 			(trim->m_bRev3d) ? (curve_t - curve->Domain().Length() * 1e-2) : (curve_t + curve->Domain().Length() * 1e-2);
// 		    ON_3dPoint c1 = curve->PointAt(curve_t);
// 		    ON_3dPoint c2 = curve->PointAt(curve_t_forward);
// 		    double ray_t_forward = ray_t + 1e-2;
// 		    ON_3dPoint r1 = r.PointAt(ray_t);
// 		    ON_3dPoint r2 = r.PointAt(ray_t_forward);
// 		    ON_3dVector a = c2 - c1;
// 		    ON_3dVector b = r2 - r1;
d534 2
a535 2
// 		    // neg: right
// 		    // pos: left
d537 27
a563 26
// 		    // below is the simplified version of:
// 		    //   b \dot (a \cross ( a \cross b ) )
// 		    // or
// 		    //   b * (a x (a x b))		    
// 		    double dir = 
// 			4 * a[0] * a[1] * b[0] * b[1] - (a[1] * b[0] + a[0] * b[1]) * (a[1] * b[0] + a[0] * b[1]) +
// 			4 * a[0] * a[2] * b[0] * b[2] - (a[2] * b[0] + a[0] * b[2]) * (a[2] * b[0] + a[0] * b[2]) +
// 			4 * a[1] * a[2] * b[1] * b[2] - (a[2] * b[1] + a[1] * b[2]) * (a[2] * b[1] + a[1] * b[2]);		    

// 		    if (dir > 0) { // rv is left of cv
// 			// now we need to find the closest point on the surface
// 			ON_2dPoint uv;
// 			get_closest_point(uv, 
// 					  const_cast<ON_BrepFace*>(face), 
// 					  r1,
// 					  (SurfaceTree*)face->m_face_user.p);
// 			ON_3dPoint hit;
// 			ON_3dVector norm;
// 			face->SurfaceOf()->EvNormal(uv[0],uv[1], hit, norm);
// 			hits.insert(brep_hit(*face, (const fastf_t*)r.m_origin, (const fastf_t*)hit, (const fastf_t*)norm, (const fastf_t*)uv));
// 			return BREP_INTERSECT_FOUND;
// 		    }
// 		}
// 	    }
// 	}
//     }    
@


14.38
log
@start work on jungle gym algo, implemented in brep_edge_check method (try to prevent acne due to tracing through a crack in the manifold)
@
text
@d221 1
a221 1
	// for this node to be completely trimmed, all for corners
a392 1
// XXX - todo: use static allocation instead
d396 1
d401 1
a401 1
    brep_hit(const ON_BrepFace& f, point_t p, vect_t n, pt2d_t _uv) 
d404 1
d413 1
d421 1
d426 4
d433 13
d520 4
a523 1
// 		    double curve_t_forward = curve_t + curve.Domain().Length() * 1e-2;
d529 16
a544 3
// 		    ON_3dVector cv(c1, c2);
// 		    ON_3dVector rv(r1, r2);
// 		    if (cv.Cross(rv) < 0) { // rv is left of cv
d551 5
a555 1
// 			face->SurfaceOf()->PointAt(uv[0],uv[1]);
d560 1
a560 2
//     }
    
d570 1
d580 4
a583 2
	fastf_t d = v2mag(Rcurr);
	if (d < BREP_INTERSECTION_ROOT_EPSILON) {
d587 3
a589 1
	    found = BREP_INTERSECT_ROOT_DIVERGED; break;
d606 1
a606 1
	hits.push_back(brep_hit(*face, (fastf_t*)_pt,(fastf_t*)_norm, uv));
d613 3
a615 1
class HitSorter : public std::greater<brep_hit>
d617 15
a631 4
    point_t m_origin;
public:
    HitSorter(point_t origin) {
	VMOVE(m_origin, origin);
d633 1
a633 5
    
    bool operator()(brep_hit& left, brep_hit& right) {
	return DIST_PT_PT(left.point, m_origin) < DIST_PT_PT(right.point, m_origin);
    }
};
d649 2
a650 1
    TRACE1("rt_brep_shot origin:" << ON_PRINT3(rp->r_pt) << " dir:" << ON_PRINT3(rp->r_dir));
d660 1
d671 5
d677 15
a691 3
	if (status < 0 && status > BREP_INTERSECT_ROOT_ITERATION_LIMIT) {
	    TRACE("no intersection: " << BREP_INTERSECT_GET_REASON(status));
	}
d695 22
a716 2
    HitSorter hs(rp->r_pt);
    hits.sort(hs);
@


14.37
log
@Add prep code to cache bezier spans of trimming curves; Remove dead code; add some debugging diagnostics
@
text
@d42 4
a91 3
#include <list>
#include <iostream>
#include <algorithm>
a249 6
// 	const ON_Surface* surf = face.SurfaceOf();
// 	TRACE1("Surf: " << surf);

// 	ON_Interval u = surf->Domain(0);
// 	ON_Interval v = surf->Domain(1);
// 	BoundingVolume* bv = brep_surface_subdivide(face, u, v, 0);
d252 1
d268 1
a268 1

d370 1
a370 1
brep_get_plane_ray(struct xray* r, plane_ray& pr)
d373 1
a373 1
    VMOVE(v1, r->r_dir);
d383 1
a383 1
    VCROSS(pr.n1, v1, r->r_dir); // n1 is perpendicular to v1
d385 1
a385 1
    VCROSS(pr.n2, pr.n1, r->r_dir);       // n2 is perpendicular to v1 and n1
d387 2
a388 2
    pr.d1 = VDOT(pr.n1,r->r_pt);
    pr.d2 = VDOT(pr.n2,r->r_pt);
a429 1
//     TRACE1("\tpt" << ON_PRINT3(pt) << ", su" << ON_PRINT3(su) << ", sv" ON_PRINT3(sv));
a436 2
//     TRACE1("brep_newton_iterate: " << ON_PRINT2(uv));

a442 1
// 	TRACE1("\tuv:"<<ON_PRINT2(uv)<<" tmp:"<<ON_PRINT2(tmp));
d464 62
d527 1
a527 1
brep_intersect(const SubsurfaceBBNode* sbv, const ON_BrepFace* face, const ON_Surface* surf, pt2d_t uv, plane_ray& pr, HitList& hits)
d536 2
d554 4
a557 4
	if (!sbv->m_u.Includes(uv[0])) return BREP_INTERSECT_OOB;
	if (!sbv->m_v.Includes(uv[1])) return BREP_INTERSECT_OOB;

	if (sbv->doTrimming() && brep_pt_trimmed(uv, *face)) return BREP_INTERSECT_TRIMMED;
d563 3
a565 1
    }    
a603 2
    //inters.sort();
    TRACE1("found " << inters.size() << " intersections!");    
a606 3
    plane_ray pr;
    brep_get_plane_ray(rp, pr);    

d615 2
a616 1
	int status = brep_intersect(sbv, f, surf, uv, pr, hits);
@


14.36
log
@make brep_hit a value object (no dynamic alloc); now dropping hit points if they don't fall within subsurface bbox; turned off bbox plotting
@
text
@a150 35
const int CASE_A = 1;
const int CASE_B = 2;
const int CASE_C = 3;

int 
brep_process_caseb(const ON_LineCurve& ray, const ON_Curve* trim_curve) {
    // XXX todo
    return 0;
}

int 
brep_process_casec(const ON_LineCurve& ray, const ON_Curve* trim_curve) {
    // XXX todo
    return 0;
}

int
brep_classify_curve(const ON_LineCurve& ray, const ON_Curve* trim_curve) {
    return CASE_A;
}

int
brep_count_intersections(const ON_LineCurve& ray, const ON_Curve* trim_curve) {
    int quad_case = brep_classify_curve(ray, trim_curve);
    switch (quad_case) {
    case CASE_A:
	return 0;
    case CASE_B:
	return brep_process_caseb(ray, trim_curve);
    case CASE_C:
	return brep_process_casec(ray, trim_curve);	
    }
    throw new exception();
}

d179 2
d191 2
a192 1
	// check to see if this portion of the surface needs to be checked for trims
d197 2
a198 6
	int count = 0; 
	for (int i = 0; i < 4; i++) {
	    if (brep_pt_trimmed(test[i], face)) {
		count++;
	    }
	}
d210 7
d219 1
a219 2
	std::cout << "INTERNAL TRIM: " << internalTrim << std::endl;
	bb->m_checkTrim = internalTrim;
d225 1
a225 1
	bb->m_trimmed = count == 4 && tree->depth() > 0; 
d334 1
d459 14
a472 1
bool 
d475 1
a475 1
    bool found = false;
d487 1
a487 1
	    found = true; break; 
d489 1
a489 1
	    break;
d494 2
a495 2
    }
    if (found) {
d498 2
a499 2
	if (!sbv->m_u.Includes(uv[0])) return false;
	if (!sbv->m_v.Includes(uv[1])) return false;
d501 1
a501 1
	if (sbv->doTrimming() && brep_pt_trimmed(uv, *face)) return false; 
d562 4
a565 2
	TRACE1("uv: " << ON_PRINT2(uv));	
	brep_intersect(sbv, f, surf, uv, pr, hits);
a570 18
//     if (hits.size() > 1) {
// 	TRACE("num hits: " << hits.size());
// 	brep_hit* a = hits.front();
// 	HitList::iterator i = hits.begin();
// 	for (++i; i != hits.end(); ++i) {
// 	    assert(i != NULL);
// 	    brep_hit* b = *i;
// 	    while (VAPPROXEQUAL(a->point, b->point, 1e-1)) {
// 		delete b;
// 		i = hits.erase(i);
// 		b = *i;
// 	    }
// 	    TRACE("last point: " << ON_PRINT3(a->point));
// 	    TRACE("curr point: " << ON_PRINT3(b->point));
// 	    a = b;
// 	}
//     }

@


14.35
log
@added bounding-box plotting for debugging purposes; fixed memory leak
in shot routine; debugging acne/odd hit count problems (currently not
finished!!); renamed existing debug statements (should just remove them!)
@
text
@d440 15
a454 1
	TRACE1("hit: " << ON_PRINT3(p) << " " << ON_PRINT3(n));
d457 1
a457 1
typedef std::list<brep_hit*> HitList;
d489 1
a489 1
brep_intersect(const SubsurfaceBBNode* sbv, const ON_BrepFace* face, const ON_Surface* surf, pt2d_t uv, plane_ray& pr, brep_hit** hit)
d513 3
a515 6
 	surf->GetDomain(0,&l,&h);
 	if (uv[0] < l || uv[0] > h) { TRACE1("out of U bounds"); return false; } // oob
 	else {
 	    surf->GetDomain(1,&l,&h);
 	    if (uv[1] < l || uv[1] > h) { TRACE1("out of V bounds"); return false; } // oob
 	}
d522 1
a522 1
	*hit = new brep_hit(*face, (fastf_t*)_pt,(fastf_t*)_norm, uv);
d527 1
a527 1
class HitSorter : public std::greater<brep_hit*>
d535 2
a536 2
    bool operator()(brep_hit*& left, brep_hit*& right) {
	return DIST_PT_PT(left->point, m_origin) < DIST_PT_PT(right->point, m_origin);
d562 1
a562 1
    inters.sort();
d570 1
d579 1
a579 8
	if (brep_intersect(sbv, f, surf, uv, pr, &hit)) {
	    if (VAPPROXEQUAL(hits.back()->point, hit->point, 1)) continue;
	    else {
		TRACE("last point: " << ON_PRINT3(hits.back()->point));
		TRACE("curr point: " << ON_PRINT3(hit->point));
	    }
	    hits.push_back(hit);
	}
d585 18
d608 2
a609 2
	    for (HitList::iterator i = hits.begin(); i != hits.end(); i++) {
		brep_hit* in = *i;
d611 1
a611 1
		brep_hit* out = *i;
d617 11
a627 11
		VMOVE(segp->seg_in.hit_point, in->point);
		VMOVE(segp->seg_in.hit_normal, in->normal);
		segp->seg_in.hit_dist = DIST_PT_PT(rp->r_pt,in->point);
		segp->seg_in.hit_surfno = in->face.m_face_index;
		VSET(segp->seg_in.hit_vpriv,in->uv[0],in->uv[1],0.0);

		VMOVE(segp->seg_out.hit_point, out->point);
		VMOVE(segp->seg_out.hit_normal, out->normal);
		segp->seg_out.hit_dist = DIST_PT_PT(rp->r_pt,out->point);
		segp->seg_out.hit_surfno = out->face.m_face_index;
		VSET(segp->seg_out.hit_vpriv,out->uv[0],out->uv[1],0.0);
d636 1
a636 1
	        TRACE("hit " << num << ": " << ON_PRINT3((*i)->point));
d642 1
a642 5
    int num_hits = hits.size();
    for (HitList::iterator i = hits.begin(); i != hits.end(); i++) {
	delete (*i);
    }
    return (hit) ? num_hits : 0; // MISS
d794 5
a798 5
    for (int i = 0; i < brep->m_F.Count(); i++) {
      ON_BrepFace& f = brep->m_F[i];
      SurfaceTree st(&f);
      plot_bbnode(st.getRootNode(), vhead);
    }
@


14.34
log
@fix plot routine to now show edge curves better (still needs refinement, e.g. dynamic sampling)
@
text
@a91 9
#ifndef TRACE
//#define TRACE(s) std::cout << "TRACE: " << s << std::endl
#define TRACE(s)
#endif
#define ON_PRINT4(p) "[" << (p)[0] << "," << (p)[1] << "," << (p)[2] << "," << (p)[3] << "]"
#define ON_PRINT3(p) "(" << (p)[0] << "," << (p)[1] << "," << (p)[2] << ")"
#define ON_PRINT2(p) "(" << (p)[0] << "," << (p)[1] << ")"


d188 1
a188 1
    TRACE("brep_pt_trimmed: " << PT2(pt));
d277 1
a277 1
        TRACE("Face: " << i);
d280 1
a280 1
// 	TRACE("Surf: " << surf);
d319 1
a319 1
    TRACE("rt_brep_prep");
d422 1
a422 1
    TRACE("n1:" << ON_PRINT3(pr.n1) << " n2:" << ON_PRINT3(pr.n2) << " d1:" << pr.d1 << " d2:" << pr.d2);
d426 1
a426 1

d440 1
a440 1
	TRACE("hit: " << ON_PRINT3(p) << " " << ON_PRINT3(n));
d449 1
a449 1
//     TRACE("\tpt" << ON_PRINT3(pt) << ", su" << ON_PRINT3(su) << ", sv" ON_PRINT3(sv));
d457 1
a457 1
//     TRACE("brep_newton_iterate: " << ON_PRINT2(uv));
d465 1
a465 1
// 	TRACE("\tuv:"<<ON_PRINT2(uv)<<" tmp:"<<ON_PRINT2(tmp));
d469 1
a469 1
	TRACE("inverse failed"); // XXX how to handle this?
d488 1
a488 1
	    TRACE("R:"<<ON_PRINT2(Rcurr));
d500 1
a500 1
 	if (uv[0] < l || uv[0] > h) { TRACE("out of U bounds"); return false; } // oob
d503 1
a503 1
 	    if (uv[1] < l || uv[1] > h) { TRACE("out of V bounds"); return false; } // oob
d543 1
a543 1
    TRACE("rt_brep_shot origin:" << ON_PRINT3(rp->r_pt) << " dir:" << ON_PRINT3(rp->r_dir));
a550 1
    //brep_intersect_bv( inters, rp, bs->bvh);
d552 1
a552 1
    TRACE("found " << inters.size() << " intersections!");    
d566 1
a566 1
	TRACE("uv: " << ON_PRINT2(uv));
d568 5
d578 2
a579 2
//     HitSorter hs(rp->r_pt);
//     hits.sort(hs);
d581 1
d589 1
d606 9
a614 1
		BU_LIST_INSERT( &(seghead->l), &(segp->l) );
a615 4
	    return hits.size();
	} else {
 	    std::cout << "ACK! found " << hits.size() << " number of intersection points. XXX Handle this!\n" << std::endl;
	    std::cout << "It's really not acceptable to just print inane statements :-)\n" << std::endl;
d618 6
a623 2

    return 0; // MISS
d692 1
a692 1
    TRACE("rt_brep_free");
d698 33
d737 1
a737 1
    TRACE("rt_brep_plot");
d773 1
d775 6
d961 1
a961 1
    TRACE("rt_brep_export5");
d1012 1
a1012 1
    TRACE("rt_brep_import5");
d1048 1
a1048 1
    TRACE("rt_brep_ifree");
@


14.33
log
@VC++ 6.0 adaptions: missing return statement, parent class, etc.
@
text
@d562 1
a562 1
    TRACE("found " << inters.size() << " intersections!");
d583 2
a584 2
    HitSorter hs(rp->r_pt);
    hits.sort(hs);
d738 23
a760 6
	ON_BrepVertex& v1 = brep->m_V[e.m_vi[0]];
	ON_BrepVertex& v2 = brep->m_V[e.m_vi[1]];
	VMOVE(pt1, v1.Point());
	VMOVE(pt2, v2.Point());
	RT_ADD_VLIST(vhead, pt1, BN_VLIST_LINE_MOVE);
	RT_ADD_VLIST(vhead, pt2, BN_VLIST_LINE_DRAW);
@


14.32
log
@sort the hits (need to look into this further); remove some debugging output
@
text
@d26 1
d525 1
a525 1
class HitSorter 
@


14.31
log
@Change brep_pt_trimmed to use NumIntersectionsWith() method in openNURBS. will make the unfinished brep_count_intersections() function obsolete...
@
text
@d457 1
a457 1
    TRACE("\tpt" << ON_PRINT3(pt) << ", su" << ON_PRINT3(su) << ", sv" ON_PRINT3(sv));
d465 1
a465 1
    TRACE("brep_newton_iterate: " << ON_PRINT2(uv));
d473 1
a473 1
	TRACE("\tuv:"<<ON_PRINT2(uv)<<" tmp:"<<ON_PRINT2(tmp));
d524 13
a550 5
    mat2d_t test = {2,3,4,5};
    mat2d_t inv;
    mat2d_inverse(inv, test);
    TRACE("inverse: " << ON_PRINT4(inv));

d581 4
@


14.30
log
@Finish implementation of preprocess_trims, start implementation on trim support methods (count_intersections), since openNURBS leaves the curve intersection routines unimplemented
@
text
@d175 2
a176 3
int 
brep_classify_trim(const ON_LineCurve& ray, const ON_Curve* trim_curve) {
    // XXX todo
a179 1

d182 1
a182 1
    int quad_case = brep_classify_trim(ray, trim_curve);
d205 1
a205 1
    ON_LineCurve ray(from,to);
d213 1
a213 1
	    intersections += brep_count_intersections(ray, trimCurve);
d215 1
@


14.29
log
@Fix brep plot() problem with non-trivial faces (i.e. those coming from IGES), perform simplified edge rendering (still needs to be fleshed out to handle non-linear curves)
@
text
@d159 36
d198 1
d208 3
a210 3
    ON_SimpleArray<ON_X_EVENT> intersections;
    for (int i = 0; i < face.Brep()->m_L.Count(); i++) {
	ON_BrepLoop& loop = face.Brep()->m_L[i];
d212 2
a213 2
	for (int j = 0; j < loop.m_ti.Count(); j++) {	    
	    ON_BrepTrim& trim = face.Brep()->m_T[loop.m_ti[j]];
d215 2
a216 1
	    ray.IntersectCurve(trimCurve, intersections, 0.0001);
d220 1
a220 1
    return intersections.Count() > 0 && (intersections.Count() % 2) == 0;
d224 19
a242 10
brep_preprocess_trims(const ON_BrepFace& face, const ON_Interval& u, const ON_Interval& v) {
    // check to see if this portion of the surface needs to be checked for trims
    pt2d_t test[] = {{u.Min(),v.Min()},
		     {u.Max(),v.Min()},
		     {u.Max(),v.Max()},
		     {u.Min(),v.Max()}};
    int count = 0; 
    for (int i = 0; i < 4; i++) {
	if (brep_pt_trimmed(test[i], face)) {
	    count++;
d244 12
a255 12
    }
    // check to see if the bbox encloses a trim
    ON_3dPoint uvmin(u.Min(),v.Min(),0);
    ON_3dPoint uvmax(u.Max(),v.Max(),0);
    ON_BoundingBox bb(uvmin,uvmax);
    bool internalTrim = false;
    for (int i = 0; i < face.Brep()->m_L.Count(); i++) {
	ON_BrepLoop& loop = face.Brep()->m_L[i];
	// for each trim
	for (int j = 0; j < loop.m_ti.Count(); j++) {	    
	    ON_BrepTrim& trim = face.Brep()->m_T[loop.m_ti[j]];
	    if (bb.Intersection(trim.m_pbox)) internalTrim = true;
d257 8
a265 1
    std::cout << "INTERNAL TRIM: " << internalTrim << std::endl;    
d296 1
@


14.28
log
@Debug IGES parsing/handling and openNURBS extensions. Still not building a simple B-Rep correctly (trim vertices not agreeing)
@
text
@d639 3
d643 25
a667 6
    ON_MeshParameters mp;
    mp.JaggedAndFasterMeshParameters();

    ON_SimpleArray<ON_Mesh*> mesh_list;
    bi->brep->CreateMesh(mp, mesh_list);

d669 8
a676 13
    ON_SimpleArray<ON_2dex> edges;
    for (int i = 0; i < mesh_list.Count(); i++) {
	const ON_Mesh* mesh = mesh_list[i];
	mesh->GetMeshEdges(edges);
	for (int j = 0; j < edges.Count(); j++) {
	    ON_MeshVertexRef v1 = mesh->VertexRef(edges[j].i);
	    ON_MeshVertexRef v2 = mesh->VertexRef(edges[j].j);
	    VSET(pt1, v1.Point().x, v1.Point().y, v1.Point().z);
	    VSET(pt2, v2.Point().x, v2.Point().y, v2.Point().z);
	    RT_ADD_VLIST(vhead, pt1, BN_VLIST_LINE_MOVE);
	    RT_ADD_VLIST(vhead, pt2, BN_VLIST_LINE_DRAW);
	}
	edges.Empty();
d678 1
a678 1

@


14.27
log
@Move vector point/matrix functions to vector.h. Fix some pointer/reference passing issues.
@
text
@d91 1
d94 1
d99 1
@


14.26
log
@Remove commented code
@
text
@a98 53
//--------------------------------------------------------------------------------
// MATH / VECTOR ops
// XXX put in VMATH?
typedef fastf_t pt2d_t[2] VEC_ALIGN;
typedef fastf_t mat2d_t[4] VEC_ALIGN; // row-major 
inline
bool mat2d_inverse(mat2d_t inv, mat2d_t m) {
    pt2d_t _a = {m[0],m[1]};
    pt2d_t _b = {m[3],m[2]};
    dvec<2> a(_a);
    dvec<2> b(_b);
    dvec<2> c = a*b;
    fastf_t det = c.foldr(0,dvec<2>::sub());
    if (NEAR_ZERO(det,VUNITIZE_TOL)) return false;
    fastf_t scale = 1.0 / det;
    double tmp[4] VEC_ALIGN = {m[3],-m[1],-m[2],m[0]};
    dvec<4> iv(tmp);
    dvec<4> sv(scale);
    dvec<4> r = iv * sv;
    r.a_store(inv);
    return true;
}
inline 
void mat2d_pt2d_mul(pt2d_t r, mat2d_t m, pt2d_t p) {
    pt2d_t _a = {m[0],m[2]};
    pt2d_t _b = {m[1],m[3]};
    dvec<2> x(p[0]);
    dvec<2> y(p[1]);
    dvec<2> a(_a);
    dvec<2> b(_b);
    dvec<2> c = a*x + b*y;
    c.a_store(r);
}
inline
void pt2dsub(pt2d_t r, pt2d_t a, pt2d_t b) {
    dvec<2> va(a);
    dvec<2> vb(b);
    dvec<2> vr = va - vb;
    vr.a_store(r);
}

inline
fastf_t v2mag(pt2d_t p) {
    dvec<2> a(p);
    dvec<2> sq = a*a;
    return sqrt(sq.foldr(0,dvec<2>::add()));
}
inline
void move(pt2d_t a, pt2d_t b) {
    a[0] = b[0];
    a[1] = b[1];
}

d426 1
a426 1
brep_intersect(const SubsurfaceBBNode* sbv, const ON_BrepFace& face, const ON_Surface* surf, pt2d_t uv, plane_ray& pr, brep_hit** hit)
d457 1
a457 1
	if (sbv->doTrimming() && brep_pt_trimmed(uv, face)) return false; 
d462 1
a462 1
	*hit = new brep_hit(face, (fastf_t*)_pt,(fastf_t*)_norm, uv);
d506 2
a507 2
	const ON_BrepFace& f = sbv->m_face;
	const ON_Surface* surf = f.SurfaceOf();       
@


14.25
log
@Replace primitive-only bounding volume hierarchy with opennurbs_ext surface tree. Will remove commented code later.
@
text
@a96 219
//--------------------------------------------------------------------------------
// Bounding volume classes
// namespace brep {
//     inline void swap(fastf_t& a, fastf_t& b) {
// 	fastf_t t = b;
// 	b = a;
// 	a = t;
//     }
    
//     class BoundingVolume {	
//     public:

// 	BoundingVolume(const point_t min, const point_t max);
// 	BoundingVolume(const point_t mina, const point_t maxa, const point_t minb, const point_t maxb);
// 	BoundingVolume(const BoundingVolume& bv);
// 	virtual ~BoundingVolume();

// 	BoundingVolume& operator=(const BoundingVolume& bv);

// 	virtual bool is_leaf() const;

// 	fastf_t width() const;
// 	fastf_t height() const;
// 	fastf_t depth() const;
// 	void get_bbox(point_t min, point_t max) const;

// 	fastf_t surface_area() const;	
// 	fastf_t combined_surface_area(const BoundingVolume& vol) const;
// 	BoundingVolume combine(const BoundingVolume& vol) const;

// 	// slab intersection routine
// 	bool intersected_by(struct xray* r);
// 	bool intersected_by(struct xray* r, fastf_t* tnear, fastf_t* tfar);

// 	// Goldsmith & Salmon "Automatic generation of trees"
// 	BoundingVolume* gs_insert(BoundingVolume* node);
	
// 	std::list<BoundingVolume*> children;

//     private:
// 	point_t _min;
// 	point_t _max;
// 	fastf_t _area;
//     };

//     class SurfaceBV : public BoundingVolume {
//     public:

// 	SurfaceBV(const ON_BrepFace& face, 
// 		  point_t min, point_t max, 
// 		  const ON_Interval& u, 
// 		  const ON_Interval& v, 
// 		  bool checkTrim, 
// 		  bool trimmed);
// 	bool is_leaf() const; // override BoundingVolume::is_leaf();
// 	const ON_BrepFace& face() const { return _face; }
// 	const fastf_t u_center() const { return _u.Mid(); }
// 	const fastf_t v_center() const { return _v.Mid(); }
// 	const bool doTrimming() const { return _doTrim; }
// 	const bool isTrimmed() const { return _isTrimmed; }

//     private:
// 	const ON_BrepFace& _face;
// 	ON_Interval _u;
// 	ON_Interval _v;
// 	bool _doTrim;
// 	bool _isTrimmed;
//     }; 
    
//     //--------------------------------------------------------------------------------
//     // implementation
    
//     inline
//     BoundingVolume::BoundingVolume(const point_t min, const point_t max)
//     {
// 	VMOVE(_min, min);
// 	VMOVE(_max, max);
// 	_area = 2*width()*height() + 2*width()*depth() + 2*height()*depth();
//     }

//     inline
//     BoundingVolume::BoundingVolume(const point_t mina, const point_t maxa, const point_t minb, const point_t maxb)
//     {
// 	VMOVE(_min,mina);
// 	VMOVE(_max,maxa);
// 	VMIN(_min,minb);
// 	VMAX(_max,maxb);
// 	_area = 2*width()*height() + 2*width()*depth() + 2*height()*depth();
//     }

//     inline BoundingVolume& 
//     BoundingVolume::operator=(const BoundingVolume& bv) {
// 	VMOVE(_min,bv._min);
// 	VMOVE(_max,bv._max);
// 	_area = bv._area;

//         return *this;
//     }

//     inline 
//     BoundingVolume::~BoundingVolume() {
// 	for (std::list<BoundingVolume*>::iterator i = children.begin(); i != children.end(); i++) {
// 	    delete *i;
// 	}
//     }

//     inline bool
//     BoundingVolume::is_leaf() const { return false; }

//     inline fastf_t
//     BoundingVolume::width() const { return _max[X]-_min[X]; }	
//     inline fastf_t
//     BoundingVolume::height() const { return _max[Y]-_min[Y]; }
//     inline fastf_t
//     BoundingVolume::depth() const { return _max[Z]-_min[Z]; }

//     inline void 
//     BoundingVolume::get_bbox(point_t min, point_t max) const {
// 	VMOVE(min, _min);
// 	VMOVE(max, _max);
//     }
    
//     inline bool 
//     BoundingVolume::intersected_by(struct xray* r) {
// 	fastf_t tnear, tfar;
// 	return intersected_by(r, &tnear, &tfar);
//     }

//     inline bool 
//     BoundingVolume::intersected_by(struct xray* r, fastf_t* tnear, fastf_t* tfar) {
// 	*tnear = -MAX_FASTF;
// 	*tfar = MAX_FASTF;
// 	for (int i = 0; i < 3; i++) {
// 	    if (NEAR_ZERO(r->r_dir[i],VUNITIZE_TOL)) {
// 		if (r->r_pt[i] < _min[i] || r->r_pt[i] > _max[i])
// 		    return false;
// 	    }
// 	    else {
// 		fastf_t t1 = (_min[i]-r->r_pt[i]) / r->r_dir[i];
// 		fastf_t t2 = (_max[i]-r->r_pt[i]) / r->r_dir[i];
// 		if (t1 > t2) swap(t1,t2);
// 		if (t1 > *tnear) *tnear = t1;
// 		if (t2 < *tfar) *tfar = t2;
// 		if (*tnear > *tfar) /* box is missed */ return false;
// 		if (*tfar < 0) /* box is behind ray */ return false;
// 	    }
// 	}
// 	return true;
//     }

//     inline fastf_t
//     BoundingVolume::surface_area() const { return _area; }
    
//     inline fastf_t
//     BoundingVolume::combined_surface_area(const BoundingVolume& vol) const { 
// 	BoundingVolume combined(_min,_max,vol._min,vol._max);
// 	return combined.surface_area();
//     }

//     inline BoundingVolume
//     BoundingVolume::combine(const BoundingVolume& vol) const {
// 	return BoundingVolume(_min,_max,vol._min,vol._max);
//     }

//     BoundingVolume*
//     BoundingVolume::gs_insert(BoundingVolume* node)
//     {
// 	// XXX todo - later!
// 	if (is_leaf()) {
// 	    // create a new parent 
// 	} else {

// 	}

//         return this;
//     }

//     inline 
//     SurfaceBV::SurfaceBV(const ON_BrepFace& face, 
// 			 point_t min, 
// 			 point_t max, 
// 			 const ON_Interval& u, 
// 			 const ON_Interval& v,
// 			 bool checkTrim,
// 			 bool isTrimmed) 
// 	: BoundingVolume(min,max), _face(face), _u(u), _v(v), _doTrim(checkTrim), _isTrimmed(isTrimmed)
//     {
//     }

//     inline bool
//     SurfaceBV::is_leaf() const { return true; }

//     class IRecord {
//     public:
// 	BoundingVolume* bv;
// 	fastf_t dist;

// 	IRecord()
// 	    : bv(NULL), dist(0.0) {}

// 	IRecord(BoundingVolume* bv, fastf_t dist) : bv(bv), dist(dist) {}
// 	IRecord(const IRecord& r) : bv(r.bv), dist(r.dist) {}
	
// 	IRecord& operator=(const IRecord& r) {
// 	    bv = r.bv;
// 	    dist = r.dist;

//             return *this;
// 	}
	
// 	bool operator<(const IRecord& r) {
// 	    return dist < r.dist;
// 	}	
//     };
//     typedef std::list<BoundingVolume*> BVList;
//     typedef std::list<IRecord> IsectList;
// };

// using namespace brep;
d563 1
@


14.24
log
@adapt the for loop variables to not standard conform compilers
@
text
@d40 1
d99 6
a104 6
namespace brep {
    inline void swap(fastf_t& a, fastf_t& b) {
	fastf_t t = b;
	b = a;
	a = t;
    }
d106 2
a107 2
    class BoundingVolume {	
    public:
d109 4
a112 4
	BoundingVolume(const point_t min, const point_t max);
	BoundingVolume(const point_t mina, const point_t maxa, const point_t minb, const point_t maxb);
	BoundingVolume(const BoundingVolume& bv);
	virtual ~BoundingVolume();
d114 1
a114 1
	BoundingVolume& operator=(const BoundingVolume& bv);
d116 1
a116 1
	virtual bool is_leaf() const;
d118 4
a121 4
	fastf_t width() const;
	fastf_t height() const;
	fastf_t depth() const;
	void get_bbox(point_t min, point_t max) const;
d123 3
a125 3
	fastf_t surface_area() const;	
	fastf_t combined_surface_area(const BoundingVolume& vol) const;
	BoundingVolume combine(const BoundingVolume& vol) const;
d127 3
a129 3
	// slab intersection routine
	bool intersected_by(struct xray* r);
	bool intersected_by(struct xray* r, fastf_t* tnear, fastf_t* tfar);
d131 2
a132 2
	// Goldsmith & Salmon "Automatic generation of trees"
	BoundingVolume* gs_insert(BoundingVolume* node);
d134 1
a134 1
	std::list<BoundingVolume*> children;
d136 29
a164 29
    private:
	point_t _min;
	point_t _max;
	fastf_t _area;
    };

    class SurfaceBV : public BoundingVolume {
    public:

	SurfaceBV(const ON_BrepFace& face, 
		  point_t min, point_t max, 
		  const ON_Interval& u, 
		  const ON_Interval& v, 
		  bool checkTrim, 
		  bool trimmed);
	bool is_leaf() const; // override BoundingVolume::is_leaf();
	const ON_BrepFace& face() const { return _face; }
	const fastf_t u_center() const { return _u.Mid(); }
	const fastf_t v_center() const { return _v.Mid(); }
	const bool doTrimming() const { return _doTrim; }
	const bool isTrimmed() const { return _isTrimmed; }

    private:
	const ON_BrepFace& _face;
	ON_Interval _u;
	ON_Interval _v;
	bool _doTrim;
	bool _isTrimmed;
    }; 
d166 2
a167 2
    //--------------------------------------------------------------------------------
    // implementation
d169 26
a194 7
    inline
    BoundingVolume::BoundingVolume(const point_t min, const point_t max)
    {
	VMOVE(_min, min);
	VMOVE(_max, max);
	_area = 2*width()*height() + 2*width()*depth() + 2*height()*depth();
    }
d196 6
a201 25
    inline
    BoundingVolume::BoundingVolume(const point_t mina, const point_t maxa, const point_t minb, const point_t maxb)
    {
	VMOVE(_min,mina);
	VMOVE(_max,maxa);
	VMIN(_min,minb);
	VMAX(_max,maxb);
	_area = 2*width()*height() + 2*width()*depth() + 2*height()*depth();
    }

    inline BoundingVolume& 
    BoundingVolume::operator=(const BoundingVolume& bv) {
	VMOVE(_min,bv._min);
	VMOVE(_max,bv._max);
	_area = bv._area;

        return *this;
    }

    inline 
    BoundingVolume::~BoundingVolume() {
	for (std::list<BoundingVolume*>::iterator i = children.begin(); i != children.end(); i++) {
	    delete *i;
	}
    }
d203 2
a204 2
    inline bool
    BoundingVolume::is_leaf() const { return false; }
d206 12
a217 12
    inline fastf_t
    BoundingVolume::width() const { return _max[X]-_min[X]; }	
    inline fastf_t
    BoundingVolume::height() const { return _max[Y]-_min[Y]; }
    inline fastf_t
    BoundingVolume::depth() const { return _max[Z]-_min[Z]; }

    inline void 
    BoundingVolume::get_bbox(point_t min, point_t max) const {
	VMOVE(min, _min);
	VMOVE(max, _max);
    }
d219 5
a223 5
    inline bool 
    BoundingVolume::intersected_by(struct xray* r) {
	fastf_t tnear, tfar;
	return intersected_by(r, &tnear, &tfar);
    }
d225 21
a245 21
    inline bool 
    BoundingVolume::intersected_by(struct xray* r, fastf_t* tnear, fastf_t* tfar) {
	*tnear = -MAX_FASTF;
	*tfar = MAX_FASTF;
	for (int i = 0; i < 3; i++) {
	    if (NEAR_ZERO(r->r_dir[i],VUNITIZE_TOL)) {
		if (r->r_pt[i] < _min[i] || r->r_pt[i] > _max[i])
		    return false;
	    }
	    else {
		fastf_t t1 = (_min[i]-r->r_pt[i]) / r->r_dir[i];
		fastf_t t2 = (_max[i]-r->r_pt[i]) / r->r_dir[i];
		if (t1 > t2) swap(t1,t2);
		if (t1 > *tnear) *tnear = t1;
		if (t2 < *tfar) *tfar = t2;
		if (*tnear > *tfar) /* box is missed */ return false;
		if (*tfar < 0) /* box is behind ray */ return false;
	    }
	}
	return true;
    }
d247 2
a248 2
    inline fastf_t
    BoundingVolume::surface_area() const { return _area; }
d250 5
a254 5
    inline fastf_t
    BoundingVolume::combined_surface_area(const BoundingVolume& vol) const { 
	BoundingVolume combined(_min,_max,vol._min,vol._max);
	return combined.surface_area();
    }
d256 4
a259 4
    inline BoundingVolume
    BoundingVolume::combine(const BoundingVolume& vol) const {
	return BoundingVolume(_min,_max,vol._min,vol._max);
    }
d261 7
a267 7
    BoundingVolume*
    BoundingVolume::gs_insert(BoundingVolume* node)
    {
	// XXX todo - later!
	if (is_leaf()) {
	    // create a new parent 
	} else {
d269 1
a269 1
	}
d271 2
a272 2
        return this;
    }
d274 11
a284 11
    inline 
    SurfaceBV::SurfaceBV(const ON_BrepFace& face, 
			 point_t min, 
			 point_t max, 
			 const ON_Interval& u, 
			 const ON_Interval& v,
			 bool checkTrim,
			 bool isTrimmed) 
	: BoundingVolume(min,max), _face(face), _u(u), _v(v), _doTrim(checkTrim), _isTrimmed(isTrimmed)
    {
    }
d286 2
a287 2
    inline bool
    SurfaceBV::is_leaf() const { return true; }
d289 4
a292 4
    class IRecord {
    public:
	BoundingVolume* bv;
	fastf_t dist;
d294 2
a295 2
	IRecord()
	    : bv(NULL), dist(0.0) {}
d297 2
a298 2
	IRecord(BoundingVolume* bv, fastf_t dist) : bv(bv), dist(dist) {}
	IRecord(const IRecord& r) : bv(r.bv), dist(r.dist) {}
d300 3
a302 3
	IRecord& operator=(const IRecord& r) {
	    bv = r.bv;
	    dist = r.dist;
d304 2
a305 2
            return *this;
	}
d307 7
a313 7
	bool operator<(const IRecord& r) {
	    return dist < r.dist;
	}	
    };
    typedef std::list<BoundingVolume*> BVList;
    typedef std::list<IRecord> IsectList;
};
d315 2
a316 1
using namespace brep;
d371 5
d394 3
d406 1
a406 1
brep_bvh_subdivide(BoundingVolume* parent, const BVList& face_bvs)
d413 2
a414 2
    for (BVList::const_iterator i = face_bvs.begin(); i != face_bvs.end(); i++) {
	parent->children.push_back(*i);
d418 2
a419 1
inline void distribute(const int count, const ON_3dVector* v, double x[], double y[], double z[])
a427 91
/**
 * Determine whether a given surface is flat enough, i.e. it falls
 * beneath our simple flatness constraints. The flatness constraint in
 * this case is a sampling of normals across the surface such that
 * the product of their combined dot products is close to 1.
 *
 * \Product_{i=1}^{7} n_i \dot n_{i+1} = 1
 *
 * Would be a perfectly flat surface. Generally something in the range
 * 0.8-0.9 should suffice (according to Abert, 2005).
 *
 *   	 +-------------------------+
 *	 |           	           |
 *	 |            +            |
 *	 |                         |
 *    V  |       +         +       |
 *	 |                         |
 *	 |            +            |
 *	 |                         |
 *	 +-------------------------+
 *                    U
 *                     
 * The "+" indicates the normal sample.
 */
bool
brep_is_flat(const ON_Surface* surf, const ON_Interval& u, const ON_Interval& v)
{
    ON_3dVector normals[8];    

    bool fail = false;
    // corners    
    if (!surf->EvNormal(u.Min(),v.Min(),normals[0]) ||
	!surf->EvNormal(u.Max(),v.Min(),normals[1]) ||
	!surf->EvNormal(u.Max(),v.Max(),normals[2]) ||
	!surf->EvNormal(u.Min(),v.Max(),normals[3]) ||

	// interior
	!surf->EvNormal(u.ParameterAt(0.5),v.ParameterAt(0.25),normals[4]) ||
	!surf->EvNormal(u.ParameterAt(0.75),v.ParameterAt(0.5),normals[5]) ||
	!surf->EvNormal(u.ParameterAt(0.5),v.ParameterAt(0.75),normals[6]) ||
	!surf->EvNormal(u.ParameterAt(0.25),v.ParameterAt(0.5),normals[7])) {
	bu_bomb("Could not evaluate a normal on the surface"); // XXX fix this
    }

    double product = 1.0;

#ifdef DO_VECTOR    
    double ax[4] VEC_ALIGN;
    double ay[4] VEC_ALIGN;
    double az[4] VEC_ALIGN;

    double bx[4] VEC_ALIGN;
    double by[4] VEC_ALIGN;
    double bz[4] VEC_ALIGN;

    distribute(4, normals, ax, ay, az);
    distribute(4, &normals[1], bx, by, bz);
    
    // how to get the normals in here?
    {
	dvec<4> xa(ax);
	dvec<4> ya(ay);
	dvec<4> za(az);
	dvec<4> xb(bx);
	dvec<4> yb(by);
	dvec<4> zb(bz);
	dvec<4> dots = xa * xb + ya * yb + za * zb;
	product *= dots.foldr(1,dvec<4>::mul());
	if (product < 0.0) return false;
    }    
    // try the next set of normals
    {
	distribute(3, &normals[4], ax, ay, az);
	distribute(3, &normals[5], bx, by, bz);
	dvec<4> xa(ax);
	dvec<4> xb(bx);
	dvec<4> ya(ay); 
	dvec<4> yb(by);
	dvec<4> za(az);
	dvec<4> zb(bz);
	dvec<4> dots = xa * xb + ya * yb + za * zb;
	product *= dots.foldr(1,dvec<4>::mul(),3);
    }
#else
    for (int i = 0; i < 7; i++) {
	product *= (normals[i] * normals[i+1]);
    }
#endif

    return product >= BREP_SURFACE_FLATNESS;
}
d454 2
a455 22
BoundingVolume*
brep_surface_bbox(const ON_BrepFace& face, const ON_Interval& u, const ON_Interval& v)
{
    TRACE("brep_surface_bbox");
    ON_3dPoint corners[4];
    const ON_Surface* surf = face.SurfaceOf();

    TRACE("  surf: " << surf);
    if (!surf->EvPoint(u.Min(),v.Min(),corners[0]) ||
	!surf->EvPoint(u.Max(),v.Min(),corners[1]) ||
	!surf->EvPoint(u.Max(),v.Max(),corners[2]) ||
	!surf->EvPoint(u.Min(),v.Max(),corners[3])) {
	bu_bomb("Could not evaluate a point on surface"); // XXX fix this message
    }

    point_t min, max;
    VSETALL(min, MAX_FASTF);
    VSETALL(max, -MAX_FASTF);
    for (int i1 = 0; i1 < 4; i1++) 
	VMINMAX(min,max,((double*)corners[i1]));
    TRACE("bb: " << ON_PRINT3(min) << " -> " << ON_PRINT3(max));
    
d462 2
a463 2
    for (int i2 = 0; i2 < 4; i2++) {
	if (brep_pt_trimmed(test[0], face)) {
d472 2
a473 2
    for (int i3 = 0; i3 < face.Brep()->m_L.Count(); i3++) {
	ON_BrepLoop& loop = face.Brep()->m_L[i3];
d480 1
a480 27
    std::cout << "INTERNAL TRIM: " << internalTrim << std::endl;

    return new SurfaceBV(face,min,max,u,v,count>0 || internalTrim, count==4);
}

BoundingVolume*
brep_surface_subdivide(const ON_BrepFace& face, const ON_Interval& u, const ON_Interval& v, int depth)
{
    TRACE("brep_surface_subdivide");
    const ON_Surface* surf = face.SurfaceOf();
    BoundingVolume* parent = brep_surface_bbox(face, u, v);
    if (brep_is_flat(surf, u, v) || depth >= BREP_MAX_FT_DEPTH) {
	return parent;
    } else {
	BoundingVolume* quads[4];
	ON_Interval first(0,0.5);
	ON_Interval second(0.5,1.0);
	quads[0] = brep_surface_subdivide(face, u.ParameterAt(first),  v.ParameterAt(first),  depth+1);
	quads[1] = brep_surface_subdivide(face, u.ParameterAt(second), v.ParameterAt(first),  depth+1);
	quads[2] = brep_surface_subdivide(face, u.ParameterAt(second), v.ParameterAt(second), depth+1);
	quads[3] = brep_surface_subdivide(face, u.ParameterAt(first),  v.ParameterAt(second), depth+1);

	for (int i = 0; i < 4; i++)
	    parent->children.push_back(quads[i]);

	return parent;
    }
d493 1
a493 4
    point_t min, max;
    brep->GetBBox(min, max);

    bs->bvh = new BoundingVolume(min,max);
d498 1
a498 1
    BVList surface_bvs;
d503 6
a508 2
	const ON_Surface* surf = face.SurfaceOf();
	TRACE("Surf: " << surf);
d510 1
a510 3
	ON_Interval u = surf->Domain(0);
	ON_Interval v = surf->Domain(1);
	BoundingVolume* bv = brep_surface_subdivide(face, u, v, 0);
d514 1
a514 1
	surface_bvs.push_back(bv);
d517 1
a517 1
    brep_bvh_subdivide(bs->bvh, surface_bvs);
d572 1
a572 1
    bs->bvh->get_bbox(stp->st_min, stp->st_max);
d611 13
a623 13
void brep_intersect_bv(IsectList& inters, struct xray* r, BoundingVolume* bv) 
{
    fastf_t tnear, tfar;
    bool intersects = bv->intersected_by(r,&tnear,&tfar);
    if (intersects && bv->is_leaf() && !dynamic_cast<SurfaceBV*>(bv)->isTrimmed()) {
	inters.push_back(IRecord(bv,tnear));
    }
    else if (intersects)
	for (BVList::iterator i = bv->children.begin(); i != bv->children.end(); i++) {
	    brep_intersect_bv(inters, r, *i);
	}
}

d625 2
a626 1
void brep_get_plane_ray(struct xray* r, plane_ray& pr)
d698 1
a698 1
brep_intersect(const SurfaceBV* sbv, const ON_BrepFace& face, const ON_Surface* surf, pt2d_t uv, plane_ray& pr, brep_hit** hit)
d763 4
a766 2
    IsectList inters;
    brep_intersect_bv(inters, rp, bs->bvh);
d776 3
a778 3
    for (IsectList::iterator i = inters.begin(); i != inters.end(); i++) {	
	const SurfaceBV* sbv = dynamic_cast<SurfaceBV*>((*i).bv);
	const ON_BrepFace& f = sbv->face();
d781 1
a781 1
	pt2d_t uv = {sbv->u_center(),sbv->v_center()};
@


14.23
log
@Add initial (currently untested) support for trimming
@
text
@d552 2
a553 2
    for (int i = 0; i < 4; i++) 
	VMINMAX(min,max,((double*)corners[i]));
d562 1
a562 1
    for (int i = 0; i < 4; i++) {
d572 2
a573 2
    for (int i = 0; i < face.Brep()->m_L.Count(); i++) {
	ON_BrepLoop& loop = face.Brep()->m_L[i];
@


14.22
log
@fix parameter bounding, suppress debug statements. yay! untrimmed breps raytrace!
@
text
@d144 6
a149 1
	SurfaceBV(const ON_BrepFace& face, point_t min, point_t max, const ON_Interval& u, const ON_Interval& v);
d154 2
d161 2
d274 8
a281 2
    SurfaceBV::SurfaceBV(const ON_BrepFace& face, point_t min, point_t max, const ON_Interval& u, const ON_Interval& v) 
	: BoundingVolume(min,max), _face(face), _u(u), _v(v)
d317 54
d509 25
d555 28
a582 1
    return new SurfaceBV(face,min,max,u,v);
d742 1
a742 1
    if (intersects && bv->is_leaf()) {	
a773 50
// XXX put in VMATH?
typedef fastf_t pt2d_t[2] VEC_ALIGN;
typedef fastf_t mat2d_t[4] VEC_ALIGN; // row-major 
inline
bool mat2d_inverse(mat2d_t inv, mat2d_t m) {
    pt2d_t _a = {m[0],m[1]};
    pt2d_t _b = {m[3],m[2]};
    dvec<2> a(_a);
    dvec<2> b(_b);
    dvec<2> c = a*b;
    fastf_t det = c.foldr(0,dvec<2>::sub());
    if (NEAR_ZERO(det,VUNITIZE_TOL)) return false;
    fastf_t scale = 1.0 / det;
    double tmp[4] VEC_ALIGN = {m[3],-m[1],-m[2],m[0]};
    dvec<4> iv(tmp);
    dvec<4> sv(scale);
    dvec<4> r = iv * sv;
    r.a_store(inv);
    return true;
}
inline 
void mat2d_pt2d_mul(pt2d_t r, mat2d_t m, pt2d_t p) {
    pt2d_t _a = {m[0],m[2]};
    pt2d_t _b = {m[1],m[3]};
    dvec<2> x(p[0]);
    dvec<2> y(p[1]);
    dvec<2> a(_a);
    dvec<2> b(_b);
    dvec<2> c = a*x + b*y;
    c.a_store(r);
}
inline
void pt2dsub(pt2d_t r, pt2d_t a, pt2d_t b) {
    dvec<2> va(a);
    dvec<2> vb(b);
    dvec<2> vr = va - vb;
    vr.a_store(r);
}

inline
fastf_t v2mag(pt2d_t p) {
    dvec<2> a(p);
    dvec<2> sq = a*a;
    return sqrt(sq.foldr(0,dvec<2>::add()));
}
inline
void move(pt2d_t a, pt2d_t b) {
    a[0] = b[0];
    a[1] = b[1];
}
a822 6
bool
brep_is_trimmed(const ON_BrepFace& face, const ON_Surface* surf, pt2d_t uv) 
{

}

d824 1
a824 1
brep_intersect(const ON_BrepFace& face, const ON_Surface* surf, pt2d_t uv, plane_ray& pr, brep_hit** hit)
d855 1
a855 1
	if (brep_is_trimmed(face, surf, uv)) return false; 
d906 1
a906 1
	if (brep_intersect(f, surf, uv, pr, &hit)) {
@


14.21
log
@get rid of fmax() and use V_MAX() instead
@
text
@d90 5
a94 1
#define TRACE(s) std::cout << "TRACE: " << s << std::endl
d460 1
a629 3
#define ON_PRINT4(p) "[" << (p)[0] << "," << (p)[1] << "," << (p)[2] << "," << (p)[3] << "]"
#define ON_PRINT3(p) "(" << (p)[0] << "," << (p)[1] << "," << (p)[2] << ")"
#define ON_PRINT2(p) "(" << (p)[0] << "," << (p)[1] << ")"
a744 7
	fastf_t l,h;
// 	surf->GetDomain(0,&l,&h);
// 	if (new_uv[0] < l || new_uv[0] > h) move(new_uv,old_uv);
// 	else {
// 	    surf->GetDomain(1,&l,&h);
// 	    if (new_uv[1] < l || new_uv[1] > h) move(new_uv,old_uv);
// 	}
d747 1
a747 1
	TRACE("inverse failed");
d752 5
d782 10
d873 2
a874 2
	    bu_log("ACK! found odd number of intersection points. XXX Handle this!\n");
	    bu_log("It's really not acceptable to just print inane statements :-)\n");
@


14.20
log
@VC++ 6.0 does not like near, far (obsolete keyword error)
operator= should return a reference to *this
@
text
@d580 3
a582 2
    fastf_t f = fmax(work[X],work[Y]);
    f = fmax(f,work[Z]);
@


14.19
log
@bug fixes - simple brep cube now renders (some acne, though). twisted brep still has problems, argh.
@
text
@d124 1
a124 1
	bool intersected_by(struct xray* r, fastf_t* tnear, fastf_t* far);
d178 2
d280 1
a280 1
	IRecord operator=(const IRecord& r) {
d283 2
d613 2
a614 2
    fastf_t near, far;
    bool intersects = bv->intersected_by(r,&near,&far);
d616 1
a616 1
	inters.push_back(IRecord(bv,near));
@


14.18
log
@move does not return a value
@
text
@d88 1
d267 20
d288 1
d607 1
a607 1
void brep_intersect_bv(BVList& inters, struct xray* r, BoundingVolume* bv) 
d609 2
a610 1
    bool intersects = bv->intersected_by(r);
d612 1
a612 1
	inters.push_back(bv);
d620 4
d631 2
a632 2
	if (v1[i] < min) {
	    min = v1[i];
d638 3
a640 2
    VCROSS(pr.n2, v1, pr.n1);       // n2 is perpendicular to v1 and n1
    // ??? do they need to be normalized - Ed doesn't think so...
d643 1
a645 4
#define ON_PRINT4(p) "[" << (p)[0] << "," << (p)[1] << "," << (p)[2] << "," << (p)[3] << "]"
#define ON_PRINT3(p) "(" << (p)[0] << "," << (p)[1] << "," << (p)[2] << ")"
#define ON_PRINT2(p) "(" << (p)[0] << "," << (p)[1] << ")"

d717 1
a717 1
brep_newton_iterate(const ON_Surface* surf, plane_ray& pr, pt2d_t old_uv, pt2d_t new_uv, pt2d_t new_R) 
d719 5
a723 5
    TRACE("brep_newton_iterate: " << ON_PRINT2(old_uv));
    ON_3dPoint _pt;
    ON_3dVector _su, _sv;
    surf->Ev1Der(old_uv[0], old_uv[1], _pt, _su, _sv);
    TRACE("\tpt" << ON_PRINT3(_pt) << ", su" << ON_PRINT3(_su) << ", sv" ON_PRINT3(_sv));
d725 4
a728 2
    new_R[0] = VDOT(pr.n1,((fastf_t*)_pt)) + pr.d1;
    new_R[1] = VDOT(pr.n2,((fastf_t*)_pt)) + pr.d2;
d730 2
a731 2
    mat2d_t jacob = { VDOT(pr.n1,((fastf_t*)_su)), VDOT(pr.n1,((fastf_t*)_sv)),
		      VDOT(pr.n2,((fastf_t*)_su)), VDOT(pr.n2,((fastf_t*)_sv)) };
d735 3
a737 2
	mat2d_pt2d_mul(tmp, inv_jacob, new_R);
	pt2dsub(new_uv, old_uv, tmp);
d739 6
a744 6
	surf->GetDomain(0,&l,&h);
	if (new_uv[0] < l || new_uv[0] > h) move(new_uv,new_R);
	else {
	    surf->GetDomain(1,&l,&h);
	    if (new_uv[1] < l || new_uv[1] > h) move(new_uv,new_R);
	}
d747 2
a748 1
	move(new_uv,new_R);
a749 1
    TRACE("\t" << ON_PRINT2(new_R) << ", " << ON_PRINT2(new_uv));
d760 3
d764 1
a764 1
	brep_newton_iterate(surf, pr, uv, new_uv, Rcurr);
d767 1
a768 2
	} else if (d == Dlast) {
	    found = true; break;
d771 2
a772 1
	}
d774 1
d779 2
a780 2
	surf->EvNormal(new_uv[0],new_uv[1],_pt,_norm);
	*hit = new brep_hit(face, (fastf_t*)_pt,(fastf_t*)_norm, new_uv);
d809 1
a809 1
    BVList inters;
d811 1
d820 2
a821 2
    for (BVList::iterator i = inters.begin(); i != inters.end(); i++) {
	const SurfaceBV* sbv = dynamic_cast<SurfaceBV*>((*i));
@


14.17
log
@debug shot routine (not returning the right answers yet ;-)
@
text
@d667 1
a667 1
fastf_t move(pt2d_t a, pt2d_t b) {
@


14.16
log
@add bv intersection routines. add rough initial rt_shot implementation using openNURBS functionality. needs testing!
@
text
@d87 3
d213 2
a214 2
	    if (NEAR_ZERO(r->r_dir[i],VUNITIZE_TOL)) 
		if (r->r_pt[i] < _min[i] && r->r_pt[i] > _max[i])
d216 10
a225 9
		else {
		    fastf_t t1 = (_min[i]-r->r_pt[i]) / r->r_dir[i];
		    fastf_t t2 = (_max[i]-r->r_pt[i]) / r->r_dir[i];
		    if (t1 > t2) swap(t1,t2);
		    if (t1 > *tnear) *tnear = t1;
		    if (t2 < *tfar) *tfar = t2;
		    if (*tnear > *tfar) /* box is missed */ return false;
		    if (*tfar < 0) /* box is behind ray */ return false;
		}
d385 1
a385 1
	product *= dots.fold(1,dvec<4>::mul());
d399 1
a399 1
	product *= dots.fold(1,dvec<4>::mul(),3);
d413 1
d417 1
d436 1
d461 1
a461 1
    ON_Brep* brep = bi->brep;
d478 1
d481 1
d517 1
d536 2
d545 2
d548 3
d617 3
a619 1

d625 1
a625 1
void mat2d_inverse(mat2d_t inv, mat2d_t m) {
d631 3
a633 1
    fastf_t scale = 1.0 / c.fold(0,dvec<2>::sub());
d639 1
d664 1
a664 1
    return sqrt(sq.fold(0,dvec<2>::add()));
d672 1
d686 1
d692 3
a694 1
brep_newton_iterate(const ON_Surface* surf, plane_ray& pr, pt2d_t old_uv, pt2d_t new_uv, pt2d_t new_R) {
d698 1
d706 17
a722 1
    mat2d_inverse(inv_jacob, jacob);
a723 4
    pt2d_t tmp;
    mat2d_pt2d_mul(tmp, inv_jacob, new_R);
    pt2dsub(new_uv, old_uv, tmp);
}
d737 2
d767 6
d779 1
d802 2
a803 1
		brep_hit* in = (*i)++;
d820 2
d823 1
d825 2
a826 2
	    bu_log("ACK! found odd number of intersection points. XXX Handle this!");
	    bu_log("It's really not acceptable to just print inane statements :-)");
d842 1
a842 1
    /* no-op */
d899 1
d911 1
d1094 1
d1144 28
a1171 26
  struct rt_brep_internal* bi;
  BU_CK_EXTERNAL(ep);
  RT_CK_DB_INTERNAL(ip);
  ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
  ip->idb_type = ID_BREP;
  ip->idb_meth = &rt_functab[ID_BREP];
  ip->idb_ptr = bu_malloc(sizeof(struct rt_brep_internal), "rt_brep_internal");

  bi = (struct rt_brep_internal*)ip->idb_ptr;
  bi->magic = RT_BREP_INTERNAL_MAGIC;

  RT_MemoryArchive archive(ep->ext_buf, ep->ext_nbytes);
  ONX_Model model;
  ON_TextLog dump(stdout);
  //archive.Dump3dmChunk(dump);
  model.Read(archive, &dump);

  if (model.IsValid(&dump)) {
      ONX_Model_Object mo = model.m_object_table[0];
      // XXX does openNURBS force us to copy? it seems the answer is
      // YES due to the const-ness
      bi->brep = new ON_Brep(*ON_Brep::Cast(mo.m_object));
      return 0;
  } else {
      return -1;
  }
d1181 1
@


14.15
log
@missing return statement added
@
text
@d91 6
d118 4
d138 3
d199 27
d556 155
d729 20
a748 1
    // check the hierarchy to see if we have a hit at a leaf node    
d750 27
a776 2
    // intersect with aabb
    // rt_in_rpp(rp, invdir, 
d778 1
a778 1
    return 0;
d790 1
d802 1
d836 2
@


14.14
log
@implement the bounding volumes in C++, leaf nodes point to faces in brep model. add support for implementation of goldsmith and salmon's bvh heuristic (not completed).
@
text
@d209 2
@


14.13
log
@missing return statements added
min and max initialized
@
text
@d86 2
d89 27
a115 7
// bounding volume
brep_bv* 
brep_bv_new()
{
    brep_bv* bv = (brep_bv*)bu_malloc(sizeof(brep_bv), "brep_bv_new");
    BU_LIST_INIT(&bv->l);
    BU_LIST_INIT(&bv->children);
d117 52
a168 2
    return bv;
}
d170 2
a171 6
brep_bv*
brep_bv_new(point_t min, point_t max)
{
    brep_bv* bv = brep_bv_new();
    VMOVE(bv->min, min);
    VMOVE(bv->max, max);
d173 34
a206 2
    return bv;
}
a207 7
void 
brep_bv_delete(brep_bv* bv)
{
    if (bv != NULL) {
	brep_bv* child;
	BU_LIST_EACH(&bv->children,child,brep_bv) {
	    brep_bv_delete(child);
a208 1
	bu_free(bv, "brep_bv_delete");
d210 14
a223 1
}
d227 1
a227 1
struct brep_specific* 
d237 1
a237 1
	brep_bv_delete(bs->bvh);
d245 5
d251 1
a251 1
brep_bvh_subdivide(brep_bv* parent, struct bu_list* face_bvs)
d253 17
a269 1
    // XXX todo
d272 24
d299 63
a361 2
    // XXX todo
    return true;
d364 2
a365 2
brep_bv* 
brep_surface_bbox(const ON_Surface* surf, const ON_Interval& u, const ON_Interval& v)
d368 2
a369 1
    
d378 5
a382 9

    VSETALL(min, MAX_FASTF)
    VSETALL(max, -MAX_FASTF)

    VMINMAX(min,max,((double*)corners[0]));
    VMINMAX(min,max,((double*)corners[1]));
    VMINMAX(min,max,((double*)corners[2]));
    VMINMAX(min,max,((double*)corners[3]));
    return brep_bv_new(min,max);    
d385 2
a386 2
brep_bv* 
brep_surface_subdivide(const ON_Surface* surf, const ON_Interval& u, const ON_Interval& v, int depth)
d388 2
a389 1
    brep_bv* parent = brep_surface_bbox(surf, u, v);
d393 1
a393 1
	brep_bv* quads[4];
d396 4
a399 4
	quads[0] = brep_surface_subdivide(surf, u.ParameterAt(first),  v.ParameterAt(first),  depth+1);
	quads[1] = brep_surface_subdivide(surf, u.ParameterAt(second), v.ParameterAt(first),  depth+1);
	quads[2] = brep_surface_subdivide(surf, u.ParameterAt(second), v.ParameterAt(second), depth+1);
	quads[3] = brep_surface_subdivide(surf, u.ParameterAt(first),  v.ParameterAt(second), depth+1);
d402 2
a403 1
	    BU_LIST_INSERT(&parent->children, &quads[i]->l);
d417 1
a417 1
    
d420 3
a422 3
    
    bs->bvh = brep_bv_new(min, max);
    
d426 1
a426 2
    struct bu_list surface_bvs;
    BU_LIST_INIT(&surface_bvs);
d434 2
a435 2
	brep_bv* bv = brep_surface_subdivide(surf, u, v, 0);
	
d438 1
a438 1
	BU_LIST_INSERT(&surface_bvs, &bv->l);
d440 3
a442 3
    
    brep_bvh_subdivide(bs->bvh, &surface_bvs);
    
d477 1
a477 1
    
d483 1
a483 1
	bs = (struct brep_specific*)bu_malloc(sizeof(struct brep_specific), "brep_specific");       
d485 2
a486 2
    }    
    
d488 1
a488 1
	return -1; 
d490 10
d518 1
a518 1
 *  Intersect a ray with a nurb.
d529 8
d618 1
a618 1
    
d637 1
a637 1
	    RT_ADD_VLIST(vhead, pt2, BN_VLIST_LINE_DRAW); 
d808 1
a808 1
    { 
d824 1
a824 1
    
d851 1
a851 1
  
d860 1
a860 1
  
@


14.12
log
@begin implementation of rt_brep_prep: construct BVH, and precalculate cdbitems
@
text
@d94 2
d104 2
d164 1
d166 4
@


14.11
log
@use []'s instead of .at() for portability.. and with that minor edit, g_brep actually compiles under irix (gcc) now.  the header b0rkage from a couple weeks ago is apparently /dev/null'd through all the rewrites and changes
@
text
@d82 3
d86 152
d241 3
a243 3
 *  Given a pointer of a GED database record, and a transformation matrix,
 *  determine if this is a valid NURB, and if so, prepare the surface
 *  so the intersections will work.
d254 2
a255 2
       and building it down to a satisfactory flatness criterion (which
       they do not give information about).
d257 16
a272 1
    struct rt_brep_internal* sip;
d366 2
@


14.10
log
@explicitly include vector at compilation unit.
@
text
@d369 1
a369 1
	m_buffer.at(pos) = ((char*)buf)[pos-start];
@


14.9
log
@Begin implementation of brep plot routine. actually use vlist to draw mesh.
@
text
@d29 1
d82 1
@


14.8
log
@Begin implementation of brep plot routine. start with coarse mesh from openNURBS.
@
text
@d209 1
d216 15
a230 1
    
@


14.7
log
@fix several bugs in the implementation of RT_MemoryArchive. remove use of dynamic_cast.
@
text
@d203 14
@


14.6
log
@implement brep primitive import and export routines. still having problems with opennurbs (can't read 3dmProperties segment), still trying to determine if it's my fault or theirs.
@
text
@d217 1
a217 1
/* XXX In order to facilitate exporting the ON_BRep object without a
d297 1
a297 1
  return pos == m_buffer.size();
d320 1
a320 1
    const int read_amount = (pos + amount > m_buffer.size()) ? m_buffer.size()-(pos+amount) : amount;
d331 1
d333 4
d338 1
a338 1
	m_buffer.push_back(((char*)buf)[pos-start]);
d426 1
a426 2
      bi->brep = new ON_Brep(*dynamic_cast<const ON_Brep*>(mo.m_object)); 
      delete mo.m_object;
a430 10
//   ON_Object* b;
//   int rc = archive.ReadObject(&b);
//   if (rc == 1) {
//       bi->brep = dynamic_cast<ON_Brep*>(b);
//       return 0;
//   } else {
//       fprintf(stderr, "Error reading brep: %s", ((rc == 3) ? "UUID not registered" : "file IO problems"));
//       bi->brep = NULL;
//       return -1;
//   }
@


14.5
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
#include <sstream>
d228 1
d237 7
d250 2
a251 1
  std::stringstream m_buffer;
d255 1
a255 1
  : ON_BinaryArchive(ON::write), m_buffer(std::stringstream::out)
d259 9
d275 1
a275 1
  return 0; // XXX FIX me, because tellg() in std::istream is NOT const!!!! stupidity
d281 3
a283 4
  std::streampos p = seek_to;
  m_buffer.seekg(m_buffer.tellg()+p);
  m_buffer.seekp(m_buffer.tellp()+p);
  return m_buffer.good();
d289 3
a291 3
  m_buffer.seekg(seek_to);
  m_buffer.seekp(seek_to);
  return m_buffer.good();
d297 18
a314 1
  return m_buffer.eof();
d320 6
a325 2
  m_buffer.read((char*)buf, amount);
  return m_buffer.gcount();
d329 1
a329 1
RT_MemoryArchive::Write(size_t amount, const void* buf)
d331 5
a335 2
  m_buffer.write((const char*)buf, amount);
  return (m_buffer.good()) ? amount : 0;
d341 1
a341 2
  m_buffer.flush();
  return m_buffer.good();
d344 1
a344 1

d351 1
a351 1
    struct rt_brep_internal* oni;
d355 2
a356 2
    oni = (struct rt_brep_internal*)ip->idb_ptr;
    RT_BREP_CK_MAGIC(oni);
a358 2
    ep->ext_nbytes = 0;

d360 31
a390 1
    return 0;
d400 37
a436 2

    return 0;
d446 8
d489 1
a489 1
 * mode: C
@


14.4
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a321 1

a325 2


@


14.3
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
@


14.2
log
@undef the former for WIN32 defined read and write
@
text
@d22 1
a22 1
/*@@{*/
d378 1
a378 1
/*@@}*/
@


14.1
log
@rename g_brep.cc to g_brep.cpp for compatibility reasons with MS Visual Studio
@
text
@d30 9
d45 1
a45 1
int 
d47 1
a47 1
void 
d95 1
a95 1
     
d161 3
a163 3
 *    class(const struct soltab* stp, 
 *          const fastf_t* min, 
 *          const fastf_t* max, 
d169 1
a169 1
rt_brep_class() 
d171 1
a171 1
  return RT_CLASSIFY_UNIMPLEMENTED; 
d222 1
a222 1
 * file-based archiving operations. This implies the 
d230 1
a230 1
  
d236 1
a236 1
  
d241 1
a241 1
  
d255 1
a255 1
size_t 
d270 1
a270 1
bool 
d278 1
a278 1
bool 
d284 1
a284 1
size_t 
d291 1
a291 1
size_t 
d298 1
a298 1
bool 
d304 1
a304 1
 
d313 1
a313 1
    
d321 2
a322 2
    
    
@

