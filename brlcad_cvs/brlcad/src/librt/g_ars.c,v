head	14.22;
access;
symbols
	rel-7-10-4:14.18
	STABLE:14.18.0.2
	stable-branch:14.6
	rel-7-10-2:14.17
	rel-7-10-0:14.17
	rel-7-8-4:14.12
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.22
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.12.17.02.16.54;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.11.28.14.11.26;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.09.15.16.23.12;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.09.07.21.04.31;	author erikgreenwald;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.27.01.41.40;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.26.05.28.47;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.03.24.23.21.34;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches
	14.10.2.1;
next	14.9;

14.9
date	2005.11.24.14.28.22;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.31.07;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.58;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.59;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;

14.10.2.1
date	2006.04.07.19.30.25;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.22
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                         G _ A R S . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_ars.c
 *
 *	Intersect a ray with an ARS (Arbitrary faceted solid).
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

#include "machine.h"
#include "tcl.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"
#include "./bot.h"


#define TRI_NULL	((struct tri_specific *)0)

/* Describe algorithm here */

extern int rt_bot_minpieces;

/* from g_bot.c */
extern int rt_bot_prep( struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip );
extern void rt_bot_ifree( struct rt_db_internal *ip );

int rt_ars_tess( struct nmgregion **r, struct model *m, struct rt_db_internal *ip,
		 const struct rt_tess_tol *ttol, const struct bn_tol *tol );

void
rt_ars_free( register struct soltab *stp )
{
    bu_bomb("rt_ars_free s/b rt_bot_free\n");
}
int
rt_ars_class(const struct soltab	*stp,
	     const vect_t		min,
	     const vect_t		max,
	     const struct bn_tol	*tol)
{
    bu_bomb("rt_ars_class s/b rt_bot_class\n");
    return 0; /* not reached */
}


/**
 *			R T _ A R S _ R D _ C U R V E
 *
 *  rt_ars_rd_curve() reads a set of ARS B records and returns a pointer
 *  to a malloc()'ed memory area of fastf_t's to hold the curve.
 */
fastf_t *
rt_ars_rd_curve(union record *rp, int npts)
{
	int lim;
	fastf_t *base;
	register fastf_t *fp;		/* pointer to temp vector */
	register int i;
	union record *rr;
	int	rec;

	/* Leave room for first point to be repeated */
	base = fp = (fastf_t *)bu_malloc(
	    (npts+1) * sizeof(fastf_t) * ELEMENTS_PER_VECT,
	    "ars curve" );

	rec = 0;
	for( ; npts > 0; npts -= 8 )  {
		rr = &rp[rec++];
		if( rr->b.b_id != ID_ARS_B )  {
			bu_log("rt_ars_rd_curve():  non-ARS_B record!\n");
			break;
		}
		lim = (npts>8) ? 8 : npts;
		for( i=0; i<lim; i++ )  {
			/* cvt from dbfloat_t */
			VMOVE( fp, (&(rr->b.b_values[i*3])) );
			fp += ELEMENTS_PER_VECT;
		}
	}
	return( base );
}


/**
 *			R T _ A R S _ I M P O R T
 *
 *  Read all the curves in as a two dimensional array.
 *  The caller is responsible for freeing the dynamic memory.
 *
 *  Note that in each curve array, the first point is replicated
 *  as the last point, to make processing the data easier.
 */
int
rt_ars_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_ars_internal *ari;
	union record	*rp;
	register int	i, j;
	vect_t	base_vect;
	int		currec;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_ARS_A )  {
		bu_log("rt_ars_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ARS;
	ip->idb_meth = &rt_functab[ID_ARS];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_ars_internal), "rt_ars_internal");
	ari = (struct rt_ars_internal *)ip->idb_ptr;
	ari->magic = RT_ARS_INTERNAL_MAGIC;
	ari->ncurves = rp[0].a.a_m;
	ari->pts_per_curve = rp[0].a.a_n;

	/*
	 * Read all the curves into internal form.
	 */
	ari->curves = (fastf_t **)bu_malloc(
		(ari->ncurves+1) * sizeof(fastf_t **), "ars curve ptrs" );
	currec = 1;
	for( i=0; i < ari->ncurves; i++ )  {
		ari->curves[i] =
			rt_ars_rd_curve( &rp[currec], ari->pts_per_curve );
		currec += (ari->pts_per_curve+7)/8;
	}

	/*
	 * Convert from vector to point notation IN PLACE
	 * by rotating vectors and adding base vector.
	 * Observe special treatment for base vector.
	 */
	if (mat == NULL) mat = bn_mat_identity;
	for( i = 0; i < ari->ncurves; i++ )  {
		register fastf_t *v;

		v = ari->curves[i];
		for( j = 0; j < ari->pts_per_curve; j++ )  {
			vect_t	homog;

			if( i==0 && j == 0 )  {
				/* base vector */
				VMOVE( homog, v );
				MAT4X3PNT( base_vect, mat, homog );
				VMOVE( v, base_vect );
			}  else  {
				MAT4X3VEC( homog, mat, v );
				VADD2( v, base_vect, homog );
			}
			v += ELEMENTS_PER_VECT;
		}
		VMOVE( v, ari->curves[i] );		/* replicate first point */
	}
	return( 0 );
}

/**
 *			R T _ A R S _ E X P O R T
 *
 *  The name will be added by the caller.
 *  Generally, only libwdb will set conv2mm != 1.0
 */
int
rt_ars_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_ars_internal	*arip;
	union record		*rec;
	point_t		base_pt;
	int		per_curve_grans;
	int		cur;		/* current curve number */
	int		gno;		/* current granule number */

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ARS )  return(-1);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	per_curve_grans = (arip->pts_per_curve+7)/8;

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = (1 + per_curve_grans * arip->ncurves) *
		sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "ars external");
	rec = (union record *)ep->ext_buf;

	rec[0].a.a_id = ID_ARS_A;
	rec[0].a.a_type = ARS;			/* obsolete? */
	rec[0].a.a_m = arip->ncurves;
	rec[0].a.a_n = arip->pts_per_curve;
	rec[0].a.a_curlen = per_curve_grans;
	rec[0].a.a_totlen = per_curve_grans * arip->ncurves;

	VMOVE( base_pt, &arip->curves[0][0] );
	gno = 1;
	for( cur=0; cur<arip->ncurves; cur++ )  {
		register fastf_t	*fp;
		int			npts;
		int			left;

		fp = arip->curves[cur];
		left = arip->pts_per_curve;
		for( npts=0; npts < arip->pts_per_curve; npts+=8, left -= 8 )  {
			register int	el;
			register int	lim;
			register struct ars_ext	*bp = &rec[gno].b;

			bp->b_id = ID_ARS_B;
			bp->b_type = ARSCONT;	/* obsolete? */
			bp->b_n = cur+1;		/* obsolete? */
			bp->b_ngranule = (npts/8)+1; /* obsolete? */

			lim = (left > 8 ) ? 8 : left;
			for( el=0; el < lim; el++ )  {
				vect_t	diff;
				if( cur==0 && npts==0 && el==0 )
					VSCALE( diff , fp , local2mm )
				else
					VSUB2SCALE( diff, fp, base_pt, local2mm )
				/* NOTE: also type converts to dbfloat_t */
				VMOVE( &(bp->b_values[el*3]), diff );
				fp += ELEMENTS_PER_VECT;
			}
			gno++;
		}
	}
	return(0);
}


/**
 *			R T _ A R S _ I M P O R T 5
 *
 *  Read all the curves in as a two dimensional array.
 *  The caller is responsible for freeing the dynamic memory.
 *
 *  Note that in each curve array, the first point is replicated
 *  as the last point, to make processing the data easier.
 */
int
rt_ars_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_ars_internal *ari;
	register int		i, j;
	register unsigned char	*cp;
	vect_t			tmp_vec;
	register fastf_t	*fp;

	BU_CK_EXTERNAL( ep );
	RT_CK_DB_INTERNAL( ip );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_ARS;
	ip->idb_meth = &rt_functab[ID_ARS];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_ars_internal), "rt_ars_internal");

	ari = (struct rt_ars_internal *)ip->idb_ptr;
	ari->magic = RT_ARS_INTERNAL_MAGIC;

	cp = (unsigned char *)ep->ext_buf;
	ari->ncurves = bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;
	ari->pts_per_curve = bu_glong( cp );
	cp += SIZEOF_NETWORK_LONG;

	/*
	 * Read all the curves into internal form.
	 */
	ari->curves = (fastf_t **)bu_calloc(
		(ari->ncurves+1), sizeof(fastf_t *), "ars curve ptrs" );
	if (mat == NULL) mat = bn_mat_identity;
	for( i=0; i < ari->ncurves; i++ )  {
		ari->curves[i] = (fastf_t *)bu_calloc( (ari->pts_per_curve + 1) * 3,
			sizeof( fastf_t ), "ARS points" );
		fp = ari->curves[i];
		for( j=0 ; j<ari->pts_per_curve ; j++ ) {
			ntohd( (unsigned char *)tmp_vec, cp, 3 );
			MAT4X3PNT( fp, mat, tmp_vec );
			cp += 3 * SIZEOF_NETWORK_DOUBLE;
			fp += ELEMENTS_PER_VECT;
		}
		VMOVE( fp, ari->curves[i] );	/* duplicate first point */
	}
	return( 0 );
}

/**
 *			R T _ A R S _ E X P O R T 5
 *
 *  The name will be added by the caller.
 *  Generally, only libwdb will set conv2mm != 1.0
 */
int
rt_ars_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_ars_internal	*arip;
	unsigned char	*cp;
	vect_t		tmp_vec;
	int		cur;		/* current curve number */

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ARS )  return(-1);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = 2 * SIZEOF_NETWORK_LONG +
		3 * arip->ncurves * arip->pts_per_curve * SIZEOF_NETWORK_DOUBLE;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "ars external");
	cp = (unsigned char *)ep->ext_buf;

	(void)bu_plong( cp, arip->ncurves );
	cp += SIZEOF_NETWORK_LONG;
	(void)bu_plong( cp, arip->pts_per_curve );
	cp += SIZEOF_NETWORK_LONG;

	for( cur=0; cur<arip->ncurves; cur++ )  {
		register fastf_t	*fp;
		int			npts;

		fp = arip->curves[cur];
		for( npts=0; npts < arip->pts_per_curve; npts++ )  {
			VSCALE( tmp_vec, fp, local2mm );
			ntohd( cp, (unsigned char *)tmp_vec, 3 );
			cp += 3 * SIZEOF_NETWORK_DOUBLE;
			fp += ELEMENTS_PER_VECT;
		}
	}
	return(0);
}

/**
 *			R T _ A R S _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_ars_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register int			j;
	register struct rt_ars_internal	*arip =
		(struct rt_ars_internal *)ip->idb_ptr;
	char				buf[256];
	int				i;

	RT_ARS_CK_MAGIC(arip);
	bu_vls_strcat( str, "arbitrary rectangular solid (ARS)\n");

	sprintf(buf, "\t%d curves, %d points per curve\n",
		arip->ncurves, arip->pts_per_curve );
	bu_vls_strcat( str, buf );

	if( arip->ncurves > 0 ) {
		sprintf(buf, "\tV (%g, %g, %g)\n",
			INTCLAMP(arip->curves[0][X] * mm2local),
			INTCLAMP(arip->curves[0][Y] * mm2local),
			INTCLAMP(arip->curves[0][Z] * mm2local) );
		bu_vls_strcat( str, buf );
	}

	if( !verbose )  return(0);

	/* Print out all the points */
	for( i=0; i < arip->ncurves; i++ )  {
		register fastf_t *v = arip->curves[i];

		sprintf( buf, "\tCurve %d:\n", i );
		bu_vls_strcat( str, buf );
		for( j=0; j < arip->pts_per_curve; j++ )  {
			sprintf(buf, "\t\t(%g, %g, %g)\n",
				INTCLAMP(v[X] * mm2local),
				INTCLAMP(v[Y] * mm2local),
				INTCLAMP(v[Z] * mm2local) );
			bu_vls_strcat( str, buf );
			v += ELEMENTS_PER_VECT;
		}
	}

	return(0);
}

/**
 *			R T _ A R S _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_ars_ifree(struct rt_db_internal *ip)
{
	register struct rt_ars_internal	*arip;
	register int			i;

	RT_CK_DB_INTERNAL(ip);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	/*
	 *  Free storage for faces
	 */
	for( i = 0; i < arip->ncurves; i++ )  {
		bu_free( (char *)arip->curves[i], "ars curve" );
	}
	bu_free( (char *)arip->curves, "ars curve ptrs" );
	arip->magic = 0;		/* sanity */
	arip->ncurves = 0;
	bu_free( (char *)arip, "ars ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/**
 *			R T _ A R S _ P R E P
 *
 *  This routine is used to prepare a list of planar faces for
 *  being shot at by the ars routines.
 *
 * Process an ARS, which is represented as a vector
 * from the origin to the first point, and many vectors
 * from the first point to the remaining points.
 *
 *  This routine is unusual in that it has to read additional
 *  database records to obtain all the necessary information.
 */
int
rt_ars_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
#if 1
    struct rt_db_internal intern;
    struct rt_bot_internal *bot;
    struct model *m;
    struct nmgregion *r;
    struct shell *s;
    int ret;

    m = nmg_mm();
    r = BU_LIST_FIRST( nmgregion, &m->r_hd );

    if( rt_ars_tess( &r, m, ip, &rtip->rti_ttol, &rtip->rti_tol) ) {
	    bu_log( "Failed to tessellate ARS (%s)\n", stp->st_dp->d_namep );
	    nmg_km( m );
	    return( -1 );
    }
    rt_ars_ifree( ip );

    s = BU_LIST_FIRST( shell, &r->s_hd );
    bot = nmg_bot( s, &rtip->rti_tol );

    if( !bot ) {
	    bu_log( "Failed to convert ARS to BOT (%s)\n", stp->st_dp->d_namep );
	    nmg_km( m );
	    return( -1 );
    }

    nmg_km( m );

    intern.idb_magic = RT_DB_INTERNAL_MAGIC;
    intern.idb_major_type = DB5_MAJORTYPE_BRLCAD;
    intern.idb_minor_type = ID_BOT;
    intern.idb_meth = &rt_functab[ID_BOT];
    intern.idb_ptr = (genptr_t)bot;
    bu_avs_init( &intern.idb_avs, 0, "ARS to a BOT for prep" );

    ret = rt_bot_prep( stp, &intern, rtip );

    rt_bot_ifree( &intern );

    return( ret );
#else
    fastf_t	dx, dy, dz;	/* For finding the bounding spheres */
    int	i, j, ntri;
    fastf_t	f;
    struct rt_ars_internal	*arip;
    struct bot_specific	*bot;
    const struct bn_tol		*tol = &rtip->rti_tol;
    int ncv;

    arip = (struct rt_ars_internal *)ip->idb_ptr;
    RT_ARS_CK_MAGIC(arip);

    /* initialize the Bag-'o-triangles structure we need */
    BU_GETSTRUCT( bot, bot_specific );
    stp->st_specific = (genptr_t)bot;
    bot->bot_mode = RT_BOT_SOLID;
    bot->bot_orientation = RT_BOT_UNORIENTED;
    bot->bot_errmode = (unsigned char)NULL;
    bot->bot_thickness = (fastf_t *)NULL;
    bot->bot_facemode = (struct bu_bitv *)NULL;
    bot->bot_facelist = (struct tri_specific *)NULL;

    /*
     * Compute bounding sphere.
     * Find min and max of the point co-ordinates.
     */
    VSETALL( stp->st_max, -INFINITY );
    VSETALL( stp->st_min,  INFINITY );

    for( i = 0; i < arip->ncurves; i++ )  {
	register fastf_t *v;

	v = arip->curves[i];
	for( j = 0; j < arip->pts_per_curve; j++ )  {
	    VMINMAX( stp->st_min, stp->st_max, v );
	    v += ELEMENTS_PER_VECT;
	}
    }
    VSET( stp->st_center,
	  (stp->st_max[X] + stp->st_min[X])/2,
	  (stp->st_max[Y] + stp->st_min[Y])/2,
	  (stp->st_max[Z] + stp->st_min[Z])/2 );

    dx = (stp->st_max[X] - stp->st_min[X])/2;
    f = dx;
    dy = (stp->st_max[Y] - stp->st_min[Y])/2;
    if( dy > f )  f = dy;
    dz = (stp->st_max[Z] - stp->st_min[Z])/2;
    if( dz > f )  f = dz;
    stp->st_aradius = f;
    stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);


    /*
     *  Compute planar faces
     *  Will examine curves[i][pts_per_curve], provided by rt_ars_rd_curve.
     */
    ncv = arip->ncurves-2;
    ntri = 0;
    for(i=0; i <= ncv; i++ )  {
	register fastf_t *v1, *v2;

	v1 = arip->curves[i];
	v2 = arip->curves[i+1];
	for( j = 0; j < arip->pts_per_curve;
	     j++, v1 += ELEMENTS_PER_VECT, v2 += ELEMENTS_PER_VECT )  {

	    /* XXX make sure the faces are actual triangles */


	    /* carefully make faces, w/inward pointing normals */
	    /* [0][0] [1][1], [0][1] */
	    if (i != 0 &&
		rt_botface(stp, bot, &v1[0], &v2[ELEMENTS_PER_VECT],
			   &v1[ELEMENTS_PER_VECT], ntri, tol) > 0)   ntri++;

	    /* [1][0] [1][1] [0][0] */
	    if (i < ncv &&
		rt_botface(stp, bot, &v2[0], &v2[ELEMENTS_PER_VECT],
			   &v1[0], ntri, tol) > 0)   ntri++;
	}
    }


    if( bot->bot_facelist == (struct tri_specific *)0 )  {
	bu_log("ars(%s):  no faces\n", stp->st_name);
	return(-1);             /* BAD */
    }

    bot->bot_ntri = ntri;


    /*
     *  Support for solid 'pieces'
     *  For now, each triangle is considered a separate piece.
     *  These array allocations can't be made until the number of
     *  triangles are known.
     *
     *  If the number of triangles is too small,
     *  don't bother making pieces, the overhead isn't worth it.
     *
     *  To disable BoT pieces, on the RT command line specify:
     *	-c "set rt_bot_minpieces=0"
     */
    if( rt_bot_minpieces <= 0 )  return 0;
    if( ntri < rt_bot_minpieces )  return 0;


    rt_bot_prep_pieces(bot, stp, ntri, tol);

    rt_ars_ifree( ip );


    return(0);		/* OK */
#endif
}


/**
 *  			R T _ A R S _ P R I N T
 */
void
rt_ars_print(register const struct soltab *stp)
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;

	if( trip == TRI_NULL )  {
		bu_log("ars(%s):  no faces\n", stp->st_name);
		return;
	}
	do {
		VPRINT( "A", trip->tri_A );
		VPRINT( "B-A", trip->tri_BA );
		VPRINT( "C-A", trip->tri_CA );
		VPRINT( "BA x CA", trip->tri_wn );
		VPRINT( "Normal", trip->tri_N );
		bu_log("\n");
	} while( (trip = trip->tri_forw) );
}

/**
 *			R T _ A R S _ S H O T
 *
 * Function -
 *	Shoot a ray at an ARS.
 *
 * Returns -
 *	0	MISS
 *  	!0	HIT
 */
int
rt_ars_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;
#define RT_ARS_MAXHITS 128		/* # surfaces hit, must be even */
	struct hit hits[RT_ARS_MAXHITS];
	register struct hit *hp;
	int	nhits;

	nhits = 0;
	hp = &hits[0];

	/* consider each face */
	for( ; trip; trip = trip->tri_forw )  {
		fastf_t	dn;		/* Direction dot Normal */
		fastf_t	abs_dn;
		fastf_t	k;
		fastf_t	alpha, beta;
		fastf_t	ds;
		vect_t	wxb;		/* vertex - ray_start */
		vect_t	xp;		/* wxb cross ray_dir */

		/*
		 *  Ray Direction dot N.  (wn is inward pointing normal)
		 */
		dn = VDOT( trip->tri_wn, rp->r_dir );
		if( RT_G_DEBUG & DEBUG_ARB8 )
			bu_log("N.Dir=%g ", dn );

		/*
		 *  If ray lies directly along the face, drop this face.
		 */
		abs_dn = dn >= 0.0 ? dn : (-dn);
		if( abs_dn < 1.0e-10 )
			continue;
		VSUB2( wxb, trip->tri_A, rp->r_pt );
		VCROSS( xp, wxb, rp->r_dir );

		/* Check for exceeding along the one side */
		alpha = VDOT( trip->tri_CA, xp );
		if( dn < 0.0 )  alpha = -alpha;
		if( alpha < 0.0 || alpha > abs_dn )
			continue;

		/* Check for exceeding along the other side */
		beta = VDOT( trip->tri_BA, xp );
		if( dn > 0.0 )  beta = -beta;
		if( beta < 0.0 || beta > abs_dn )
			continue;
		if( alpha+beta > abs_dn )
			continue;
		ds = VDOT( wxb, trip->tri_wn );
		k = ds / dn;		/* shot distance */

		/* For hits other than the first one, might check
		 *  to see it this is approx. equal to previous one */

		/*  If dn < 0, we should be entering the solid.
		 *  However, we just assume in/out sorting later will work.
		 */
		hp->hit_magic = RT_HIT_MAGIC;
		hp->hit_dist = k;
		hp->hit_private = (char *)trip;
		hp->hit_vpriv[X] = dn;
		hp->hit_rayp = rp;

		if(RT_G_DEBUG&DEBUG_ARB8) bu_log("ars: dist k=%g, ds=%g, dn=%g\n", k, ds, dn );

		/* Bug fix: next line was "nhits++".  This caused rt_hitsort
			to exceed bounds of "hits" array by one member and
			clobber some stack variables i.e. "stp" -- GSM */
		if( ++nhits >= RT_ARS_MAXHITS )  {
			bu_log("ars(%s): too many hits\n", stp->st_name);
			break;
		}
		hp++;
	}
	if( nhits == 0 )
		return(0);		/* MISS */

	/* Sort hits, Near to Far */
	rt_hitsort( hits, nhits );

	/* Remove duplicate hits.
	   We remove one of a pair of hits when they are
		1) close together, and
		2) both "entry" or both "exit" occurrences.
	   Two immediate "entry" or two immediate "exit" hits suggest
	   that we hit both of two joined faces, while we want to hit only
	   one.  An "entry" followed by an "exit" (or vice versa) suggests
	   that we grazed an edge, and thus we should leave both
	   in the hit list. */

	{
		register int i, j;

		if( nhits )
			RT_HIT_NORM( &hits[0], stp, 0 )

		for( i=0 ; i<nhits-1 ; i++ )
		{
			fastf_t dist;

			RT_HIT_NORM( &hits[i+1], stp, 0 )
			dist = hits[i].hit_dist - hits[i+1].hit_dist;
			if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) &&
				VDOT( hits[i].hit_normal, rp->r_dir ) *
				VDOT( hits[i+1].hit_normal, rp->r_dir) > 0)
			{
				for( j=i ; j<nhits-1 ; j++ )
					hits[j] = hits[j+1];
				nhits--;
				i--;
			}
		}
	}

	if( nhits&1 )  {
		register int i;
		/*
		 * If this condition exists, it is almost certainly due to
		 * the dn==0 check above.  Just log error.
		 */
		bu_log("ERROR: ars(%s): %d hits odd, skipping solid\n",
			stp->st_name, nhits);
		for(i=0; i < nhits; i++ )
			bu_log("k=%g dn=%g\n",
				hits[i].hit_dist, hp->hit_vpriv[X]);
		return(0);		/* MISS */
	}

	/* nhits is even, build segments */
	{
		register struct seg *segp;
		register int	i,j;

		/* Check in/out properties */
		for( i=nhits; i > 0; i -= 2 )  {
			if( hits[i-2].hit_vpriv[X] >= 0 )
				continue;		/* seg_in */
			if( hits[i-1].hit_vpriv[X] <= 0 )
				continue;		/* seg_out */

#ifndef CONSERVATIVE
			/* if this segment is small enough, just swap the in/out hits */
			if( (hits[i-1].hit_dist - hits[i-2].hit_dist) < 200.0*RT_LEN_TOL )
			{
				struct hit temp;
				fastf_t temp_dist;

				temp_dist = hits[i-1].hit_dist;
				hits[i-1].hit_dist = hits[i-2].hit_dist;
				hits[i-2].hit_dist = temp_dist;

				temp = hits[i-1];	/* struct copy */
				hits[i-1] = hits[i-2];	/* struct copy */
				hits[i-2] = temp;	/* struct copy */
				continue;
			}
#endif
			bu_log("ars(%s): in/out error\n", stp->st_name );
			for( j=nhits-1; j >= 0; j-- )  {
				bu_log("%d %s dist=%g dn=%g\n",
					j,
					((hits[j].hit_vpriv[X] > 0) ?
						" In" : "Out" ),
					hits[j].hit_dist,
					hits[j].hit_vpriv[X] );
				if( j>0 )
					bu_log( "\tseg length = %g\n", hits[j].hit_dist - hits[j-1].hit_dist );
			}
#ifdef CONSERVATIVE
			return(0);
#else
			/* For now, just chatter, and return *something* */
			break;
#endif
		}

		for( i=nhits; i > 0; i -= 2 )  {
			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[i-2];	/* struct copy */
			segp->seg_out = hits[i-1];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
	}
	return(nhits);			/* HIT */
}

/**
 *			R T _ H I T S O R T
 *
 *  Sort an array of hits into ascending order.
 */
void
rt_hitsort(register struct hit *h, register int nh)
{
	register int i, j;
	struct hit temp;

	for( i=0; i < nh-1; i++ )  {
		for( j=i+1; j < nh; j++ )  {
			if( h[i].hit_dist <= h[j].hit_dist )
				continue;
			temp = h[j];		/* struct copy */
			h[j] = h[i];		/* struct copy */
			h[i] = temp;		/* struct copy */
		}
	}
}

/**
 *  			R T _ A R S _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_ars_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct tri_specific *trip =
		(struct tri_specific *)hitp->hit_private;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	VMOVE( hitp->hit_normal, trip->tri_N );
}

/**
 *			R T _ A R S _ C U R V E
 *
 *  Return the "curvature" of the ARB face.
 *  Pick a principle direction orthogonal to normal, and
 *  indicate no curvature.
 */
void
rt_ars_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
/*	register struct tri_specific *trip =
 *		(struct tri_specific *)hitp->hit_private;
 */
	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/**
 *  			R T _ A R S _ U V
 *
 *  For a hit on a face of an ARB, return the (u,v) coordinates
 *  of the hit point.  0 <= u,v <= 1.
 *  u extends along the Xbasis direction defined by B-A,
 *  v extends along the "Ybasis" direction defined by (B-A)xN.
 */
void
rt_ars_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct tri_specific *trip =
		(struct tri_specific *)hitp->hit_private;
	vect_t P_A;
	fastf_t r;
	fastf_t xxlen, yylen;

	xxlen = MAGNITUDE(trip->tri_BA);
	yylen = MAGNITUDE(trip->tri_CA);

	VSUB2( P_A, hitp->hit_point, trip->tri_A );
	/* Flipping v is an artifact of how the faces are built */
	uvp->uv_u = VDOT( P_A, trip->tri_BA ) * xxlen;
	uvp->uv_v = 1.0 - ( VDOT( P_A, trip->tri_CA ) * yylen );
	if( uvp->uv_u < 0 || uvp->uv_v < 0 )  {
		if( RT_G_DEBUG )
			bu_log("rt_ars_uv: bad uv=%g,%g\n", uvp->uv_u, uvp->uv_v);
		/* Fix it up */
		if( uvp->uv_u < 0 )  uvp->uv_u = (-uvp->uv_u);
		if( uvp->uv_v < 0 )  uvp->uv_v = (-uvp->uv_v);
	}
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
	uvp->uv_du = r * xxlen;
	uvp->uv_dv = r * yylen;
}


/**
 *			R T _ A R S _ P L O T
 */
int
rt_ars_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	register int	j;
	struct rt_ars_internal	*arip;

	RT_CK_DB_INTERNAL(ip);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	/*
	 *  Draw the "waterlines", by tracing each curve.
	 *  n+1th point is first point replicated by code above.
	 */
	for( i = 0; i < arip->ncurves; i++ )  {
		register fastf_t *v1;

		v1 = arip->curves[i];
		RT_ADD_VLIST( vhead, v1, BN_VLIST_LINE_MOVE );
		v1 += ELEMENTS_PER_VECT;
		for( j = 1; j <= arip->pts_per_curve; j++, v1 += ELEMENTS_PER_VECT )
			RT_ADD_VLIST( vhead, v1, BN_VLIST_LINE_DRAW );
	}

	/*
	 *  Connect the Ith points on each curve, to make a mesh.
	 */
	for( i = 0; i < arip->pts_per_curve; i++ )  {
		RT_ADD_VLIST( vhead, &arip->curves[0][i*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
		for( j = 1; j < arip->ncurves; j++ )
			RT_ADD_VLIST( vhead, &arip->curves[j][i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	return(0);
}

#define IJ(ii,jj)	(((i+(ii))*(arip->pts_per_curve+1))+(j+(jj)))
#define ARS_PT(ii,jj)	(&arip->curves[i+(ii)][(j+(jj))*ELEMENTS_PER_VECT])
#define FIND_IJ(a,b)	\
	if( !(verts[IJ(a,b)]) )  { \
		verts[IJ(a,b)] = \
		nmg_find_pt_in_shell( s, ARS_PT(a,b), tol ); \
	}
#define ASSOC_GEOM(corn, a,b)	\
	if( !((*corners[corn])->vg_p) )  { \
		nmg_vertex_gv( *(corners[corn]), ARS_PT(a,b) ); \
	}
/**
 *			R T _ A R S _ T E S S
 */
int
rt_ars_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	register int	j;
	register int	k;
	struct rt_ars_internal	*arip;
	struct shell	*s;
	struct vertex	**verts;
	struct faceuse	*fu;
	struct bu_ptbl	kill_fus;
	int		bad_ars=0;

	RT_CK_DB_INTERNAL(ip);
	arip = (struct rt_ars_internal *)ip->idb_ptr;
	RT_ARS_CK_MAGIC(arip);

	/* Check for a legal ARS */
	for( i = 0; i < arip->ncurves-1; i++ )
	{
		for( j = 2; j < arip->pts_per_curve; j++ )
		{
			fastf_t dist;
			vect_t pca;
			int code;

			if( VAPPROXEQUAL( ARS_PT(0,-2), ARS_PT(0,-1), tol->dist ) )
				continue;

			code = bn_dist_pt3_lseg3( &dist, pca, ARS_PT(0,-2), ARS_PT(0,-1), ARS_PT(0,0), tol );

			if( code < 2 )
			{
				bu_log( "ARS curve backtracks on itself!!!\n" );
				bu_log( "\tCurve #%d, points #%d through %d are:\n", i, j-2, j );
				bu_log( "\t\t%d (%f %f %f)\n", j-2, V3ARGS( ARS_PT(0,-2) ) );
				bu_log( "\t\t%d (%f %f %f)\n", j-1, V3ARGS( ARS_PT(0,-1) ) );
				bu_log( "\t\t%d (%f %f %f)\n", j, V3ARGS( ARS_PT(0,0) ) );
				bad_ars = 1;
				j++;
			}
		}
	}

	if( bad_ars )
	{
		bu_log( "TESSELATION FAILURE: This ARS solid has not been tesselated.\n\tAny result you may obtain is incorrect.\n" );
		return( -1 );
	}

	bu_ptbl_init( &kill_fus, 64, " &kill_fus");

	/* Build the topology of the ARS.  Start by allocating storage */

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	verts = (struct vertex **)bu_calloc( arip->ncurves * (arip->pts_per_curve+1),
		sizeof(struct vertex *),
		"rt_tor_tess *verts[]" );

	/*
	 *  Draw the "waterlines", by tracing each curve.
	 *  n+1th point is first point replicated by import code.
	 */
	k = arip->pts_per_curve-2;	/* next to last point on curve */
	for( i = 0; i < arip->ncurves-1; i++ )  {
		int double_ended;

		if( k != 1 && VAPPROXEQUAL( &arip->curves[i][1*ELEMENTS_PER_VECT], &arip->curves[i][k*ELEMENTS_PER_VECT], tol->dist ) )
			double_ended = 1;
		else
			double_ended = 0;

		for( j = 0; j < arip->pts_per_curve; j++ )  {
			struct vertex **corners[3];


			if( double_ended &&
			     i != 0 &&
			     ( j == 0 || j == k || j == arip->pts_per_curve-1 ) )
					continue;

			/*
			 *  First triangular face
			 */
			if( bn_3pts_distinct( ARS_PT(0,0), ARS_PT(1,1),
				ARS_PT(0,1), tol )
			   && !bn_3pts_collinear( ARS_PT(0,0), ARS_PT(1,1),
				ARS_PT(0,1), tol )
			)  {
				/* Locate these points, if previously mentioned */
				FIND_IJ(0, 0);
				FIND_IJ(1, 1);
				FIND_IJ(0, 1);

				/* Construct first face topology, CCW order */
				corners[0] = &verts[IJ(0,0)];
				corners[1] = &verts[IJ(0,1)];
				corners[2] = &verts[IJ(1,1)];

				if( (fu = nmg_cmface( s, corners, 3 )) == (struct faceuse *)0 )  {
					bu_log("rt_ars_tess() nmg_cmface failed, skipping face a[%d][%d]\n",
						i,j);
				}

				/* Associate vertex geometry, if new */
				ASSOC_GEOM( 0, 0, 0 );
				ASSOC_GEOM( 1, 0, 1 );
				ASSOC_GEOM( 2, 1, 1 );
				if( nmg_calc_face_g( fu ) )
				{
					bu_log( "Degenerate face created, will kill it later\n" );
					bu_ptbl_ins( &kill_fus, (long *)fu );
				}
			}

			/*
			 *  Second triangular face
			 */
			if( bn_3pts_distinct( ARS_PT(1,0), ARS_PT(1,1),
				ARS_PT(0,0), tol )
			   && !bn_3pts_collinear( ARS_PT(1,0), ARS_PT(1,1),
				ARS_PT(0,0), tol )
			)  {
				/* Locate these points, if previously mentioned */
				FIND_IJ(1, 0);
				FIND_IJ(1, 1);
				FIND_IJ(0, 0);

				/* Construct second face topology, CCW */
				corners[0] = &verts[IJ(1,0)];
				corners[1] = &verts[IJ(0,0)];
				corners[2] = &verts[IJ(1,1)];

				if( (fu = nmg_cmface( s, corners, 3 )) == (struct faceuse *)0 )  {
					bu_log("rt_ars_tess() nmg_cmface failed, skipping face b[%d][%d]\n",
						i,j);
				}

				/* Associate vertex geometry, if new */
				ASSOC_GEOM( 0, 1, 0 );
				ASSOC_GEOM( 1, 0, 0 );
				ASSOC_GEOM( 2, 1, 1 );
				if( nmg_calc_face_g( fu ) )
				{
					bu_log( "Degenerate face created, will kill it later\n" );
					bu_ptbl_ins( &kill_fus, (long *)fu );
				}
			}
		}
	}

	bu_free( (char *)verts, "rt_ars_tess *verts[]" );

	/* kill any degenerate faces that may have been created */
	for( i=0 ; i<BU_PTBL_END( &kill_fus ) ; i++ )
	{
		fu = (struct faceuse *)BU_PTBL_GET( &kill_fus, i );
		NMG_CK_FACEUSE( fu );
		(void)nmg_kfu( fu );
	}

	/* ARS solids are often built with incorrect face normals.
	 * Don't depend on them to be correct.
	 */
	nmg_fix_normals( s , tol );

	/* set edge's is_real flag */
	nmg_mark_edges_real( &s->l.magic );

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	return(0);
}

int
rt_ars_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
	register struct rt_ars_internal *ars=(struct rt_ars_internal *)intern->idb_ptr;
	Tcl_DString	ds;
	struct bu_vls	vls;
	int		i,j;

	RT_ARS_CK_MAGIC( ars );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL ) {
		bu_vls_strcpy( &vls, "ars" );
		bu_vls_printf( &vls, " NC %d PPC %d", ars->ncurves, ars->pts_per_curve );
		for( i=0 ; i<ars->ncurves ; i++ ) {
			bu_vls_printf( &vls, " C%d {", i );
			for( j=0 ; j<ars->pts_per_curve ; j++ ) {
				bu_vls_printf( &vls, " { %.25g %.25g %.25g }",
					       V3ARGS( &ars->curves[i][j*3] ) );
			}
			bu_vls_printf( &vls, " }" );
		}
	}
	else if( !strcmp( attr, "NC" ) ) {
		bu_vls_printf( &vls, "%d", ars->ncurves );
	}
	else if( !strcmp( attr, "PPC" ) ) {
		bu_vls_printf( &vls, "%d", ars->pts_per_curve );
	}
	else if( attr[0] == 'C' ) {
		char *ptr;

		if( attr[1] == '\0' ) {
			/* all the curves */
			for( i=0 ; i<ars->ncurves ; i++ ) {
				bu_vls_printf( &vls, " C%d {", i );
				for( j=0 ; j<ars->pts_per_curve ; j++ ) {
					bu_vls_printf( &vls, " { %.25g %.25g %.25g }",
						       V3ARGS( &ars->curves[i][j*3] ) );
				}
				bu_vls_printf( &vls, " }" );
			}
		}
		else if( !isdigit( attr[1] ) ) {
			Tcl_SetResult( interp,
			      "ERROR: illegal argument, must be NC, PPC, C, C#, or C#P#\n",
			      TCL_STATIC );
			return( TCL_ERROR );
		}

		if( (ptr=strchr( attr, 'P' )) ) {
			/* a specific point on a specific curve */
			if( !isdigit( *(ptr+1) ) ) {
			   Tcl_SetResult( interp,
			       "ERROR: illegal argument, must be NC, PPC, C, C#, or C#P#\n",
				TCL_STATIC );
			   return( TCL_ERROR );
			}
			j = atoi( (ptr+1) );
			*ptr = '\0';
			i = atoi( &attr[1] );
			bu_vls_printf( &vls, "%.25g %.25g %.25g",
				 V3ARGS( &ars->curves[i][j*3] ) );
		}
		else {
			/* the entire curve */
			i = atoi( &attr[1] );
			for( j=0 ; j<ars->pts_per_curve ; j++ ) {
				bu_vls_printf( &vls, " { %.25g %.25g %.25g }",
					       V3ARGS( &ars->curves[i][j*3] ) );
			}
		}
	}
	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );
	return( TCL_OK );
}

int
rt_ars_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
	struct rt_ars_internal		*ars;
	int				i,j,k;
	int				len;
	fastf_t				*array;

	RT_CK_DB_INTERNAL( intern );

	ars = (struct rt_ars_internal *)intern->idb_ptr;
	RT_ARS_CK_MAGIC( ars );

	while( argc >= 2 ) {
		if( !strcmp( argv[0], "NC" ) ) {
			/* change number of curves */
			i = atoi( argv[1] );
			if( i < ars->ncurves ) {
				for( j=i ; j<ars->ncurves ; j++ )
					bu_free( (char *)ars->curves[j], "ars->curves[j]" );
				ars->curves = (fastf_t **)bu_realloc( ars->curves,
						    i*sizeof( fastf_t *), "ars->curves" );
				ars->ncurves = i;
			}
			else if( i > ars->ncurves ) {
				ars->curves = (fastf_t **)bu_realloc( ars->curves,
						    i*sizeof( fastf_t *), "ars->curves" );
				if( ars->pts_per_curve ) {
					/* new curves are duplicates of the last */
					for( j=ars->ncurves ; j<i ; j++ ) {
					    ars->curves[j] = (fastf_t *)bu_malloc(
						 ars->pts_per_curve * 3 * sizeof( fastf_t ),
								    "ars->curves[j]" );
					    for( k=0 ; k<ars->pts_per_curve ; k++ ) {
						 if ( j ) {
							 VMOVE( &ars->curves[j][k*3],
								&ars->curves[j-1][k*3] );
						 }
						 else {
							 VSETALL(&ars->curves[j][k*3], 0.0);
						 }
					    }
					}
				}
				else {
					for( j=ars->ncurves ; j<i ; j++ ) {
						ars->curves[j] = NULL;
					}
				}
				ars->ncurves = i;
			}
		}
		else if( !strcmp( argv[0], "PPC" ) ) {
			/* change the number of points per curve */
			i = atoi( argv[1] );
			if( i < 3 ) {
				Tcl_SetResult( interp,
				      "ERROR: must have at least 3 points per curve\n",
				      TCL_STATIC );
				return( TCL_ERROR );
			}
			if( i < ars->pts_per_curve ) {
				for( j=0 ; j<ars->ncurves ; j++ ) {
					ars->curves[j] = bu_realloc( ars->curves[j],
						    i * 3 * sizeof( fastf_t ),
						    "ars->curves[j]" );
				}
				ars->pts_per_curve = i;
			}
			else if( i > ars->pts_per_curve ) {
				for( j=0 ; j<ars->ncurves ; j++ ) {
					ars->curves[j] = bu_realloc( ars->curves[j],
						    i * 3 * sizeof( fastf_t ),
						    "ars->curves[j]" );
					/* new points are duplicates of last */
					for( k=ars->pts_per_curve ; k<i ; k++ ) {
						if( k ) {
							VMOVE( &ars->curves[j][k*3],
							       &ars->curves[j][(k-1)*3] );
						}
						else {
							VSETALL( &ars->curves[j][k*3], 0 );
						}
					}
				}
				ars->pts_per_curve = i;
			}
		}
		else if( argv[0][0] == 'C' ) {
			if( isdigit( argv[0][1] ) ) {
				char *ptr;

				/* a specific curve */
				if( (ptr=strchr( argv[0], 'P' )) ) {
					/* a specific point on this curve */
					i = atoi( &argv[0][1] );
					j = atoi( ptr+1 );
					len = 3;
					array = &ars->curves[i][j*3];
					if( tcl_list_to_fastf_array( interp, argv[1],
						   &array,
						   &len )!= len ) {
						Tcl_SetResult( interp,
						    "WARNING: incorrect number of parameters provided for a point\n",
						       TCL_STATIC );
					}
				}
				else {
					/* one complete curve */
					i = atoi( &argv[0][1] );
					len = ars->pts_per_curve * 3;
					ptr = argv[1];
					while( *ptr ) {
						if( *ptr == '{' || *ptr == '}' )
							*ptr = ' ';
						ptr++;
					}
					if( !ars->curves[i] ) {
						ars->curves[i] = (fastf_t *)bu_calloc(
								  ars->pts_per_curve * 3,
								  sizeof( fastf_t ),
								  "ars->curves[i]" );
					}
					if( tcl_list_to_fastf_array( interp, argv[1],
						   &ars->curves[i],
						   &len ) != len ) {
						Tcl_SetResult( interp,
						    "WARNING: incorrect number of parameters provided for a curve\n",
						       TCL_STATIC );
					}
				}
			}
			else {
				Tcl_SetResult( interp,
				  "ERROR: Illegal argument, must be NC, PPC, C#, or C#P#\n",
				  TCL_STATIC );
				return( TCL_ERROR );
			}
		}
		else {
			Tcl_SetResult( interp,
				 "ERROR: Illegal argument, must be NC, PPC, C#, or C#P#\n",
				 TCL_STATIC );
			return( TCL_ERROR );
		}
		argc -= 2;
		argv += 2;
	}

	return( TCL_OK );
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@a35 4
#ifndef lint
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.20 2007/11/28 14:11:26 erikgreenwald Exp $ (BRL)";
#endif

d93 2
a94 2
	static int lim;
	static fastf_t *base;
d97 1
a97 1
	static union record *rr;
d138 1
a138 1
	static vect_t	base_vect;
d181 1
a181 1
			static vect_t	homog;
d511 1
a511 1
    static fastf_t	dx, dy, dz;	/* For finding the bounding spheres */
d513 1
a513 1
    static fastf_t	f;
d667 1
a667 1
	static struct hit hits[RT_ARS_MAXHITS];
d669 1
a669 1
	static int	nhits;
d677 1
a677 1
		static fastf_t	abs_dn;
d679 4
a682 4
		static fastf_t	alpha, beta;
		static fastf_t	ds;
		static vect_t	wxb;		/* vertex - ray_start */
		static vect_t	xp;		/* wxb cross ray_dir */
d861 1
a861 1
	static struct hit temp;
d919 3
a921 3
	static vect_t P_A;
	static fastf_t r;
	static fastf_t xxlen, yylen;
@


14.20
log
@LOCAL->static, per machine.h deprecation list
@
text
@d37 1
a37 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.19 2007/09/15 16:23:12 brlcad Exp $ (BRL)";
d680 1
a680 1
		FAST fastf_t	dn;		/* Direction dot Normal */
d682 1
a682 1
		FAST fastf_t	k;
@


14.19
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d37 1
a37 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.18 2007/09/07 21:04:31 erikgreenwald Exp $ (BRL)";
d97 2
a98 2
	LOCAL int lim;
	LOCAL fastf_t *base;
d101 1
a101 1
	LOCAL union record *rr;
d142 1
a142 1
	LOCAL vect_t	base_vect;
d185 1
a185 1
			LOCAL vect_t	homog;
d515 1
a515 1
    LOCAL fastf_t	dx, dy, dz;	/* For finding the bounding spheres */
d517 1
a517 1
    LOCAL fastf_t	f;
d671 1
a671 1
	LOCAL struct hit hits[RT_ARS_MAXHITS];
d673 1
a673 1
	LOCAL int	nhits;
d681 1
a681 1
		LOCAL fastf_t	abs_dn;
d683 4
a686 4
		LOCAL fastf_t	alpha, beta;
		LOCAL fastf_t	ds;
		LOCAL vect_t	wxb;		/* vertex - ray_start */
		LOCAL vect_t	xp;		/* wxb cross ray_dir */
d865 1
a865 1
	LOCAL struct hit temp;
d923 3
a925 3
	LOCAL vect_t P_A;
	LOCAL fastf_t r;
	LOCAL fastf_t xxlen, yylen;
@


14.18
log
@migrated the contents of src/librt/plane.r to include/bn.h
@
text
@d37 1
a37 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.17 2007/01/27 01:41:40 brlcad Exp $ (BRL)";
d44 1
a44 3
#ifdef HAVE_STRING_H
#  include <string.h>
#endif
@


14.17
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d37 1
a37 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.16 2007/01/26 05:28:47 brlcad Exp $ (BRL)";
a57 1
#include "./plane.h"
@


14.16
log
@allow the import function transformation matrix argument to be NULL, use an identity matrix in that situation.
@
text
@d37 1
a37 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.15 2007/01/23 01:13:36 brlcad Exp $ (BRL)";
a129 2


d776 1
a776 1
			        VDOT( hits[i+1].hit_normal, rp->r_dir) > 0)
d829 1
a829 1
		   	bu_log("ars(%s): in/out error\n", stp->st_name );
d831 1
a831 1
		   		bu_log("%d %s dist=%g dn=%g\n",
d834 2
a835 2
		   				" In" : "Out" ),
			   		hits[j].hit_dist,
d839 1
a839 1
		   	}
d841 1
a841 1
		   	return(0);
d1291 1
a1291 1
				        /* new curves are duplicates of the last */
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d37 1
a37 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.14 2007/01/21 04:45:43 brlcad Exp $ (BRL)";
d184 1
d321 1
@


14.14
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d37 1
a37 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.13 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.13
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d24 1
d38 1
a38 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.12 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
d1416 1
a1416 1
/*@@}*/
@


14.12
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d39 1
a39 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.11 2006/03/24 23:21:34 brlcad Exp $ (BRL)";
@


14.11
log
@lots of intel 9 for altix compiler warning quellings
@
text
@d22 1
a22 1
/** \addtogroup g */
a36 1
/*@@}*/
d39 1
a39 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.10 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
d1417 1
@


14.10
log
@update copyright to 2006
@
text
@d40 1
a40 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.9 2005/11/24 14:28:22 brlcad Exp $ (BRL)";
d45 1
a45 2


d48 1
a48 1
#include <string.h>
d52 2
a54 1
#include "machine.h"
d63 2
@


14.10.2.1
log
@update from HEAD
@
text
@d40 1
a40 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.10 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
d45 2
a46 1
#include <stdlib.h>
d49 1
a49 1
#  include <string.h>
d53 1
a53 1

a54 1
#include "tcl.h"
a62 2


@


14.9
log
@clamp the number being printed by the describe function to their closest integer if it's within hardware tolerance of an integer.  this is done only in the describe function for now so it's only cosmetic, though it could conceivably happen on store/load too.  (addresses sf 'bug'/request 1359253)
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d40 1
a40 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.8 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
@


14.8
log
@trailing ws
@
text
@d40 1
a40 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.7 2005/08/12 22:31:07 lbutler Exp $ (BRL)";
d406 3
a408 3
			arip->curves[0][X] * mm2local,
			arip->curves[0][Y] * mm2local,
			arip->curves[0][Z] * mm2local );
d422 3
a424 3
				v[X] * mm2local,
				v[Y] * mm2local,
				v[Z] * mm2local );
@


14.7
log
@Doxygen changes
@
text
@d27 1
a27 1
 *  
d30 1
a30 1
 *  
d35 1
a35 1
 *  
d40 1
a40 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.6 2005/01/30 20:30:58 brlcad Exp $ (BRL)";
d175 1
a175 1
		ari->curves[i] = 
d463 1
a463 1
 *  
d470 1
a470 1
 *  
d590 1
a590 1
	    if (i != 0 && 
d661 1
a661 1
 *  
d664 1
a664 1
 *  
d762 1
a762 1
	
d901 1
a901 1
 *  Pick a principle direction orthogonal to normal, and 
d916 1
a916 1
 *  
d1246 1
a1246 1
				 V3ARGS( &ars->curves[i][j*3] ) );      
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d27 1
a27 1
 *
d30 1
a30 1
 *
d35 1
a35 1
 *
d40 1
a40 1
static const char RCSars[] = "@@(#)$Header$ (BRL)";
d175 1
a175 1
		ari->curves[i] =
d463 1
a463 1
 *
d470 1
a470 1
 *
d590 1
a590 1
	    if (i != 0 &&
d661 1
a661 1
 *
d664 1
a664 1
 *
d762 1
a762 1

d901 1
a901 1
 *  Pick a principle direction orthogonal to normal, and
d916 1
a916 1
 *
d1246 1
a1246 1
				 V3ARGS( &ars->curves[i][j*3] ) );
@


14.6
log
@update copyright to 2005
@
text
@d21 4
d26 1
a26 3
 *
 *  Function -
 *	Intersect a ray with an ARS (Arbitrary faceted solid)
d37 2
d40 1
a40 1
static const char RCSars[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_ars.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
d92 1
a92 1
/*
d133 1
a133 1
/*
d208 1
a208 1
/*
d281 1
a281 1
/*
d336 1
a336 1
/*
d381 1
a381 1
/*
d433 1
a433 1
/*
d461 1
a461 1
/*
d636 1
a636 1
/*
d659 1
a659 1
/*
d860 1
a860 1
/*
d882 1
a882 1
/*
d897 1
a897 1
/*
d914 1
a914 1
/*
d951 1
a951 1
/*
d1002 1
a1002 1
/*
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d36 1
a36 1
static const char RCSars[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_ars.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a33 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d36 1
a36 1
static const char RCSars[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_ars.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d39 1
a39 1
static const char RCSars[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_ars.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d39 1
a39 1
static const char RCSars[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_ars.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ A R S . C
d39 1
a39 1
static const char RCSars[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_ars.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_ars.c,v 1.1 2004/05/20 15:19:59 morrison Exp $ (BRL)";
d1395 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char RCSars[] = "@@(#)$Header: /cvs/brlcad/librt/g_ars.c,v 11.36 2004/05/10 15:30:46 erikg Exp $ (BRL)";
d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

