head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	2007.01.12.19.05.35;	author jlowenz;	state dead;
branches;
next	1.2;

1.2
date	2007.01.10.03.20.32;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.09.21.04.15;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Rename g_on_nurb.c to g_brep.cc for clarity and to trigger proper C++ compilation. Add C placeholder for C++ openNURBS class needed in rt_brep_internal structure.
@
text
@/*                     G _ O N _ N U R B . C
 * BRL-CAD
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/*@@{*/
/** @@file g_on_nurb.c
 *
 */

#include "on_nurb.h"

/**
 *  			R T _ N U R B _ P R E P
 *
 *  Given a pointer of a GED database record, and a transformation matrix,
 *  determine if this is a valid NURB, and if so, prepare the surface
 *  so the intersections will work.
 */
int
rt_on_nurb_prep(struct soltab *stp, struct rt_db_internal* ip, struct rt_i* rtip)
{
    /* This prepares the NURBS specific data structures to be used
       during intersection... i.e. acceleration data structures and
       whatever else is needed.
     
       Abert's paper (Direct and Fast Ray Tracing of NURBS Surfaces)
       suggests using a bounding volume hierarchy (instead of KD-tree)
       and building it down to a satisfactory flatness criterion (which
       they do not give information about).
    */
  
    return 0;
}


/**
 *			R T _ N U R B _ P R I N T
 */
void
rt_on_nurb_print(register const struct soltab *stp)
{
}


/**
 *  			R T _ N U R B _ S H O T
 *
 *  Intersect a ray with a nurb.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_on_nurb_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
    return 0;
}


/**
 *  			R T _ N U R B _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_on_nurb_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
}


/**
 *			R T _ N U R B _ C U R V E
 *
 *  Return the curvature of the nurb.
 */
void
rt_on_nurb_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
}

/**
 *  			R T _ N U R B _ U V
 *
 *  For a hit on the surface of an nurb, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_on_nurb_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
}


/**
 *		R T _ N U R B _ F R E E
 */
void
rt_on_nurb_free(register struct soltab *stp)
{
}


/**
 *			R T _ N U R B _ P L O T
 */
int
rt_on_nurb_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
    return 0;
}


/**
 *			R T _ N U R B _ T E S S
 */
int
rt_on_nurb_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
    return -1;
}


/**
 *			R T _ N U R B _ E X P O R T 5
 */
int
rt_on_nurb_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
    return 0;
}


/**
 *			R T _ N U R B _ I M P O R T 5
 */
int
rt_on_nurb_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
    return 0;
}


/**
 *			R T _ N U R B _ I F R E E
 */
void
rt_on_nurb_ifree(struct rt_db_internal *ip)
{
}


/**
 *			R T _ N U R B _ D E S C R I B E
 */
int
rt_on_nurb_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
    return 0;
}

/**
 *                      R T _ N U R B _ T C L G E T
 */
int
rt_on_nurb_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr)
{
    return 0;
}


/**
 *                      R T _ N U R B _ T C L A D J U S T
 */
int
rt_on_nurb_tcladjust(Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv)
{
    return 0;
}

/*@@}*/

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.2
log
@standard header and footer, M-x indent region
@
text
@@


1.1
log
@Begin work on openNURBS-based primitive. OpenNURBS contains no intersection routines, so will be working off the Abert et al paper "Direct and Fast Ray Tracing of NURBS Surfaces" to implement intersection.
@
text
@d1 26
d39 3
a41 3
  /* This prepares the NURBS specific data structures to be used
     during intersection... i.e. acceleration data structures and
     whatever else is needed.
d43 5
a47 5
     Abert's paper (Direct and Fast Ray Tracing of NURBS Surfaces)
     suggests using a bounding volume hierarchy (instead of KD-tree)
     and building it down to a satisfactory flatness criterion (which
     they do not give information about).
  */
d49 1
a49 1
  return 0;
d76 1
a76 1
  return 0;
d130 1
a130 1
  return 0;
d140 1
a140 1
  return -1;
d150 1
a150 1
  return 0;
d160 1
a160 1
  return 0;
d179 1
a179 1
  return 0;
d188 1
a188 1
  return 0;
d198 1
a198 1
  return 0;
d201 1
d203 9
@

