head	14.25;
access;
symbols
	rel-7-10-4:14.21
	STABLE:14.21.0.2
	stable-branch:14.6
	rel-7-10-2:14.21
	rel-7-10-0:14.21
	rel-7-8-4:14.16
	rel-7-8-2:14.15
	rel-7-8-0:14.15
	trimnurbs-branch:14.15.0.2
	help:14.15
	temp_tag:14.13
	bobWinPort-20051223-freeze:14.10
	postmerge-20051223-bobWinPort:14.13
	premerge-20051223-bobWinPort:14.13
	rel-7-6-6:14.13
	rel-7-6-4:14.12
	rel-7-6-2:14.10
	rel-7-6-branch:14.10.0.4
	rel-7-6-0:14.10
	rel-7-4-2:14.9
	rel-7-4-branch:14.9.0.2
	bobWinPort:14.10.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.25
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.12.17.02.16.54;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.11.28.14.11.27;	author erikgreenwald;	state Exp;
branches;
next	14.22;

14.22
date	2007.09.15.16.23.13;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.27.01.41.41;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.26.05.28.48;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.21.04.45.44;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.09.16.02.04.25;	author lbutler;	state Exp;
branches;
next	14.15;

14.15
date	2006.01.22.23.37.39;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.11.24.14.28.22;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.10.30.21.58.57;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.10.4.1;
next	14.9;

14.9
date	2005.07.04.02.56.06;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.05.02.00.49.38;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.04.29.14.22.53;	author lbutler;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.31.00;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.02;	author morrison;	state Exp;
branches;
next	;

14.10.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.25
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                    G _ S U P E R E L L . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_superell.c
 *
 * Intersect a ray with a Superquadratic Ellipsoid.
 *
 *      NOTICE: this primitive is incomplete and should beconsidered
 *              experimental.  this primitive will exhibit several
 *              instabilities in the existing root solver method.
 *
 *
 *
 *  Authors -
 *      Christopher Sean Morrison (Programming)
 *      Edwin O. Davisson (Mathematics)
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
/** @@} */

#include "common.h"

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "./debug.h"

const struct bu_structparse rt_superell_parse[] = {
    { "%f", 3, "V", bu_offsetof(struct rt_superell_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A", bu_offsetof(struct rt_superell_internal, a[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", bu_offsetof(struct rt_superell_internal, b[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C", bu_offsetof(struct rt_superell_internal, c[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "n", bu_offsetof(struct rt_superell_internal, n), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "e", bu_offsetof(struct rt_superell_internal, e), BU_STRUCTPARSE_FUNC_NULL },
    { {'\0','\0','\0','\0'}, 0, (char *)NULL, 0, BU_STRUCTPARSE_FUNC_NULL }
 };


/*
 *  Algorithm:
 *
 *  Given V, A, B, and C, there is a set of points on this superellipsoid
 *
 *  { (x,y,z) | (x,y,z) is on superellipsoid defined by V, A, B, C }
 *
 *  Through a series of Affine Transformations, this set will be
 *  transformed into a set of points on a unit sphere at the origin
 *
 *  { (x',y',z') | (x',y',z') is on Sphere at origin }
 *
 *  The transformation from X to X' is accomplished by:
 *
 *  X' = S(R( X - V ))
 *
 *  where R(X) =  ( A/(|A|) )
 *  		 (  B/(|B|)  ) . X
 *  		  ( C/(|C|) )
 *
 *  and S(X) =	 (  1/|A|   0     0   )
 *  		(    0    1/|B|   0    ) . X
 *  		 (   0      0   1/|C| )
 *
 *  To find the intersection of a line with the superellipsoid, consider
 *  the parametric line L:
 *
 *  	L : { P(n) | P + t(n) . D }
 *
 *  Call W the actual point of intersection between L and the superellipsoid.
 *  Let W' be the point of intersection between L' and the unit sphere.
 *
 *  	L' : { P'(n) | P' + t(n) . D' }
 *
 *  W = invR( invS( W' ) ) + V
 *
 *  Where W' = k D' + P'.
 *
 *  Let dp = D' dot P'
 *  Let dd = D' dot D'
 *  Let pp = P' dot P'
 *
 *  and k = [ -dp +/- sqrt( dp*dp - dd * (pp - 1) ) ] / dd
 *  which is constant.
 *
 *  Now, D' = S( R( D ) )
 *  and  P' = S( R( P - V ) )
 *
 *  Substituting,
 *
 *  W = V + invR( invS[ k *( S( R( D ) ) ) + S( R( P - V ) ) ] )
 *    = V + invR( ( k * R( D ) ) + R( P - V ) )
 *    = V + k * D + P - V
 *    = k * D + P
 *
 *  Note that ``k'' is constant, and is the same in the formulations
 *  for both W and W'.
 *
 *  NORMALS.  Given the point W on the superellipsoid, what is the vector
 *  normal to the tangent plane at that point?
 *
 *  Map W onto the unit sphere, ie:  W' = S( R( W - V ) ).
 *
 *  Plane on unit sphere at W' has a normal vector of the same value(!).
 *  N' = W'
 *
 *  The plane transforms back to the tangent plane at W, and this
 *  new plane (on the superellipsoid) has a normal vector of N, viz:
 *
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *
 *  because if H is perpendicular to plane Q, and matrix M maps from
 *  Q to Q', then inverse[ transpose(M) ] (H) is perpendicular to Q'.
 *  Here, H and Q are in "prime space" with the unit sphere.
 *  [Somehow, the notation here is backwards].
 *  So, the mapping matrix M = inverse( S o R ), because
 *  S o R maps from normal space to the unit sphere.
 *
 *  N = inverse[ transpose( inverse[ S o R ] ) ] ( N' )
 *    = inverse[ transpose(invR o invS) ] ( N' )
 *    = inverse[ transpose(invS) o transpose(invR) ] ( N' )
 *    = inverse[ inverse(S) o R ] ( N' )
 *    = invR o S ( N' )
 *
 *    = invR o S ( W' )
 *    = invR( S( S( R( W - V ) ) ) )
 *
 *  because inverse(R) = transpose(R), so R = transpose( invR ),
 *  and S = transpose( S ).
 *
 *  Note that the normal vector N produced above will not have unit length.
 */

struct superell_specific {
  vect_t superell_V; /* Vector to center of superellipsoid */
  vect_t superell_Au; /* unit-length A vector */
  vect_t superell_Bu;
  vect_t superell_Cu;
  double superell_n; /* north-south curvature power */
  double superell_e; /* east-west curvature power */
  double superell_invmsAu; /* 1.0 / |Au|^2 */
  double superell_invmsBu; /* 1.0 / |Bu|^2 */
  double superell_invmsCu; /* 1.0 / |Cu|^2 */
  vect_t superell_invsq;
  mat_t	superell_SoR; /* matrix for local cordinate system, Scale(Rotate(V))*/
  mat_t superell_invRSSR; /* invR(Scale(Scale(Rot(V)))) */
  mat_t superell_invR; /* transposed rotation matrix */
};
#define SUPERELL_NULL	((struct superell_specific *)0)

/**
 *  			R T _ S U P E R E L L _ P R E P
 *
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid superellipsoid, and if so, precompute various
 *  terms of the formula.
 *
 *  Returns -
 *  	0	SUPERELL is OK
 *  	!0	Error in description
 *
 *  Implicit return -
 *  	A struct superell_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_superell_shot().
 */
int
rt_superell_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{

  register struct superell_specific *superell;
  struct rt_superell_internal	*eip;
  fastf_t	magsq_a, magsq_b, magsq_c;
  mat_t	R, TEMP;
  vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
  vect_t	w1, w2, P;	/* used for bounding RPP */
  fastf_t	f;

  eip = (struct rt_superell_internal *)ip->idb_ptr;
  RT_SUPERELL_CK_MAGIC(eip);

  /* Validate that |A| > 0, |B| > 0, |C| > 0 */
  magsq_a = MAGSQ( eip->a );
  magsq_b = MAGSQ( eip->b );
  magsq_c = MAGSQ( eip->c );

  if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
    bu_log("superell(%s):  near-zero length A(%g), B(%g), or C(%g) vector\n",
	   stp->st_name, magsq_a, magsq_b, magsq_c );
    return(1);		/* BAD */
  }
  if (eip->n < rtip->rti_tol.dist || eip->e < rtip->rti_tol.dist) {
    bu_log("superell(%s):  near-zero length <n,e> curvature (%g, %g) causes problems\n",
	   stp->st_name, eip->n, eip->e);
    /* BAD */
  }
  if (eip->n > 10000.0 || eip->e > 10000.0) {
    bu_log("superell(%s):  very large <n,e> curvature (%g, %g) causes problems\n",
	   stp->st_name, eip->n, eip->e);
    /* BAD */
  }

  /* Create unit length versions of A,B,C */
  f = 1.0/sqrt(magsq_a);
  VSCALE( Au, eip->a, f );
  f = 1.0/sqrt(magsq_b);
  VSCALE( Bu, eip->b, f );
  f = 1.0/sqrt(magsq_c);
  VSCALE( Cu, eip->c, f );

  /* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
  f = VDOT( Au, Bu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }
  f = VDOT( Bu, Cu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }
  f = VDOT( Au, Cu );
  if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
    bu_log("superell(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
    return(1);		/* BAD */
  }

  /* Solid is OK, compute constant terms now */

  BU_GETSTRUCT( superell, superell_specific );
  stp->st_specific = (genptr_t)superell;

  superell->superell_n = eip->n;
  superell->superell_e = eip->e;

  VMOVE( superell->superell_V, eip->v );

  VSET( superell->superell_invsq, 1.0/magsq_a, 1.0/magsq_b, 1.0/magsq_c );
  VMOVE( superell->superell_Au, Au );
  VMOVE( superell->superell_Bu, Bu );
  VMOVE( superell->superell_Cu, Cu );

  /* compute the inverse magnitude square for equations during shot */
  superell->superell_invmsAu = 1.0 / magsq_a;
  superell->superell_invmsBu = 1.0 / magsq_b;
  superell->superell_invmsCu = 1.0 / magsq_c;

  /* compute the rotation matrix */
  MAT_IDN(R);
  VMOVE( &R[0], Au );
  VMOVE( &R[4], Bu );
  VMOVE( &R[8], Cu );
  bn_mat_trn( superell->superell_invR, R );

  /* computer invRSSR */
  MAT_IDN(superell->superell_invRSSR);
  MAT_IDN(TEMP);
  TEMP[0] = superell->superell_invsq[0];
  TEMP[5] = superell->superell_invsq[1];
  TEMP[10] = superell->superell_invsq[2];
  bn_mat_mul(TEMP, TEMP, R);
  bn_mat_mul(superell->superell_invRSSR, superell->superell_invR, TEMP);

  /* compute Scale(Rotate(vect)) */
  MAT_IDN(superell->superell_SoR);
  VSCALE( &superell->superell_SoR[0], eip->a, superell->superell_invsq[0]);
  VSCALE( &superell->superell_SoR[4], eip->b, superell->superell_invsq[1]);
  VSCALE( &superell->superell_SoR[8], eip->c, superell->superell_invsq[2]);

  /* Compute bounding sphere */
  VMOVE( stp->st_center, eip->v );
  f = magsq_a;
  if( magsq_b > f )
    f = magsq_b;
  if( magsq_c > f )
    f = magsq_c;
  stp->st_aradius = stp->st_bradius = sqrt(f);

  /* Compute bounding RPP */
  VSET( w1, magsq_a, magsq_b, magsq_c );

  /* X */
  VSET( P, 1.0, 0, 0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[X] = superell->superell_V[X] - f;	/* V.P +/- f */
  stp->st_max[X] = superell->superell_V[X] + f;

  /* Y */
  VSET( P, 0, 1.0, 0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[Y] = superell->superell_V[Y] - f;	/* V.P +/- f */
  stp->st_max[Y] = superell->superell_V[Y] + f;

  /* Z */
  VSET( P, 0, 0, 1.0 );		/* bounding plane normal */
  MAT3X3VEC( w2, R, P );		/* map plane to local coord syst */
  VELMUL( w2, w2, w2 );		/* square each term */
  f = VDOT( w1, w2 );
  f = sqrt(f);
  stp->st_min[Z] = superell->superell_V[Z] - f;	/* V.P +/- f */
  stp->st_max[Z] = superell->superell_V[Z] + f;

  return(0);			/* OK */
}

/**
 *			R T _ S U P E R E L L _ P R I N T
 */
void
rt_superell_print(register const struct soltab *stp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;

	VPRINT("V", superell->superell_V);
}

/* Equation of a superellipsoid:
 *
 * f(x) = [ (x^(2/e2) + y^(2/e2))^(e2/e1) + z^(2/e1) ]^(e1/2) - 1
 */

/*
 *  			R T _ S U P E R E L L _ S H O T
 *
 *  Intersect a ray with an superellipsoid, where all constant terms have
 *  been precomputed by rt_superell_prep().  If an intersection occurs,
 *  a struct seg will be acquired and filled in.
 *
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_superell_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
  static int counter=10;

  register struct superell_specific *superell = (struct superell_specific *)stp->st_specific;
  bn_poly_t equation; /* equation of superell to be solved */
  vect_t translated;  /* translated shot vector */
  vect_t newShotPoint; /* P' */
  vect_t newShotDir; /* D' */
  vect_t normalizedShotPoint; /* P' with normalized dist from superell */
  bn_complex_t complexRoot[4]; /* roots returned from poly solver */
  double realRoot[4];  /* real ray distance values */
  register int i,j;
  register struct seg *segp;

  /* translate ray point */
  /*  VSUB2(translated, rp->r_pt, superell->superell_V); */
  (translated)[X] = (rp->r_pt)[X] - (superell->superell_V)[X];
  (translated)[Y] = (rp->r_pt)[Y] - (superell->superell_V)[Y];
  (translated)[Z] = (rp->r_pt)[Z] - (superell->superell_V)[Z];

  /* scale and rotate point to get P' */

  /*  MAT4X3VEC(newShotPoint, superell->superell_SoR, translated); */
  newShotPoint[X] = (superell->superell_SoR[0]*translated[X] + superell->superell_SoR[1]*translated[Y] + superell->superell_SoR[ 2]*translated[Z]) * 1.0/(superell->superell_SoR[15]);
  newShotPoint[Y] = (superell->superell_SoR[4]*translated[X] + superell->superell_SoR[5]*translated[Y] + superell->superell_SoR[ 6]*translated[Z]) * 1.0/(superell->superell_SoR[15]);
  newShotPoint[Z] = (superell->superell_SoR[8]*translated[X] + superell->superell_SoR[9]*translated[Y] + superell->superell_SoR[10]*translated[Z]) * 1.0/(superell->superell_SoR[15]);

  /* translate ray direction vector */
  MAT4X3VEC(newShotDir, superell->superell_SoR, rp->r_dir);
  VUNITIZE(newShotDir);

  /* normalize distance from the superell.  substitues a corrected ray
   * point, which contains a translation along the ray direction to the
   * closest approach to vertex of the superell.  Translating the ray
   * along the direction of the ray to the closest point near the
   * primitives center vertex.  New ray origin is hence, normalized.
   */
  VSCALE( normalizedShotPoint, newShotDir,
	  VDOT( newShotPoint, newShotDir ));
  VSUB2( normalizedShotPoint, newShotPoint, normalizedShotPoint );

  /* Now generate the polynomial equation for passing to the root finder */

  equation.dgr = 2;

  /* (x^2 / A) + (y^2 / B) + (z^2 / C) - 1 */
  equation.cf[0] = newShotPoint[X] * newShotPoint[X] * superell->superell_invmsAu + newShotPoint[Y] * newShotPoint[Y] * superell->superell_invmsBu + newShotPoint[Z] * newShotPoint[Z] * superell->superell_invmsCu - 1;
  /* (2xX / A) + (2yY / B) + (2zZ / C) */
  equation.cf[1] = 2 * newShotDir[X] * newShotPoint[X] * superell->superell_invmsAu + 2 * newShotDir[Y] * newShotPoint[Y] * superell->superell_invmsBu + 2 * newShotDir[Z] * newShotPoint[Z] * superell->superell_invmsCu;
  /* (X^2 / A) + (Y^2 / B) + (Z^2 / C) */
  equation.cf[2] = newShotDir[X] * newShotDir[X] * superell->superell_invmsAu  + newShotDir[Y] * newShotDir[Y] * superell->superell_invmsBu + newShotDir[Z] * newShotDir[Z] * superell->superell_invmsCu;

  if ( (i = rt_poly_roots( &equation, complexRoot, stp->st_dp->d_namep)) != 2 ) {
      if (i > 0) {
	  bu_log("superell: rt_poly_roots() 2 != %d\n", i);
	  bn_pr_roots(stp->st_name, complexRoot, i);
      } else if (i < 0) {
	  static int reported=0;
	  bu_log("The root solver failed to converge on a solution for %s\n", stp->st_dp->d_namep);
	  if (!reported) {
	      VPRINT("while shooting from:\t", rp->r_pt);
	      VPRINT("while shooting at:\t", rp->r_dir);
	      bu_log("Additional superellipsoid convergence failure details will be suppressed.\n");
	      reported=1;
	  }
      }
      return (0); /* MISS */
  }

  /* XXX BEGIN CUT */
  /*  Only real roots indicate an intersection in real space.
   *
   *  Look at each root returned; if the imaginary part is zero
   *  or sufficiently close, then use the real part as one value
   *  of 't' for the intersections
   */
  for ( j=0, i=0; j < 2; j++ ){
    if( NEAR_ZERO( complexRoot[j].im, 0.001 ) )
      realRoot[i++] = complexRoot[j].re;
  }

  /* reverse above translation by adding distance to all 'k' values. */
  /*  for( j = 0; j < i; ++j )
      realRoot[j] -= VDOT(newShotPoint, newShotDir);
  */

  /* Here, 'i' is number of points found */
  switch( i )  {
  case 0:
    return(0);		/* No hit */

  default:
    bu_log("rt_superell_shot: reduced 4 to %d roots\n",i);
    bn_pr_roots( stp->st_name, complexRoot, 4 );
    return(0);		/* No hit */

  case 2:
    {
      /* Sort most distant to least distant. */
      fastf_t	u;
      if( (u=realRoot[0]) < realRoot[1] )  {
	/* bubble larger towards [0] */
	realRoot[0] = realRoot[1];
	realRoot[1] = u;
      }
    }
    break;
  case 4:
    {
      register short	n;
      register short	lim;

      /*  Inline rt_pt_sort().  Sorts realRoot[] into descending order. */
      for( lim = i-1; lim > 0; lim-- )  {
	for( n = 0; n < lim; n++ )  {
	  fastf_t	u;
	  if( (u=realRoot[n]) < realRoot[n+1] )  {
	    /* bubble larger towards [0] */
	    realRoot[n] = realRoot[n+1];
	    realRoot[n+1] = u;
	  }
	}
      }
    }
    break;
  }

  if (counter > 0) {
    bu_log("realroot: in %d  out %d\n", realRoot[1], realRoot[0]);
    counter--;
  }


  /* Now, t[0] > t[npts-1] */
  /* realRoot[1] is entry point, and realRoot[0] is farthest exit point */
  RT_GET_SEG(segp, ap->a_resource);
  segp->seg_stp = stp;
  segp->seg_in.hit_dist = realRoot[1];
  segp->seg_out.hit_dist = realRoot[0];
  /*  segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 0; */
  /* Set aside vector for rt_superell_norm() later */
  /*  VJOIN1( segp->seg_in.hit_vpriv, newShotPoint, realRoot[1], newShotDir ); */
  /*  VJOIN1( segp->seg_out.hit_vpriv, newShotPoint, realRoot[0], newShotDir ); */
  BU_LIST_INSERT( &(seghead->l), &(segp->l) );

  if( i == 2 ) {
    return(2);			/* HIT */
  }

  /* 4 points */
  /* realRoot[3] is entry point, and realRoot[2] is exit point */
  RT_GET_SEG(segp, ap->a_resource);
  segp->seg_stp = stp;
  segp->seg_in.hit_dist = realRoot[3]*superell->superell_e;
  segp->seg_out.hit_dist = realRoot[2]*superell->superell_e;
  segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 1;
  VJOIN1( segp->seg_in.hit_vpriv, newShotPoint, realRoot[3], newShotDir );
  VJOIN1( segp->seg_out.hit_vpriv, newShotPoint, realRoot[2], newShotDir );
  BU_LIST_INSERT( &(seghead->l), &(segp->l) );
  return(4);			/* HIT */
  /* XXX END CUT */

  /* Is there any possibility of hitting another segment?  Only when there
   * is a concave curvature (<n,e> > <2.0, 2.0>).
   */
  if ( (superell->superell_n > 2.0) || (superell->superell_e > 2.0) ) {

  }

  return 1;
}


/**
 *			R T _ S U P E R E L L _ V S H O T
 *
 *  This is the Becker vector version.
 */
void
rt_superell_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
			       /* An array of solid pointers */
			       /* An array of ray pointers */
			       /* array of segs (results returned) */
			       /* Number of ray/object pairs */

{
  return;
}


/**
 *  			R T _ S U P E R E L L _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_superell_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
  register struct superell_specific *superell =
    (struct superell_specific *)stp->st_specific;

  vect_t xlated;
  fastf_t scale;

  VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
  VSUB2( xlated, hitp->hit_point, superell->superell_V );
  MAT4X3VEC( hitp->hit_normal, superell->superell_invRSSR, xlated );
  scale = 1.0 / MAGNITUDE( hitp->hit_normal );
  VSCALE( hitp->hit_normal, hitp->hit_normal, scale );

  return;
}


/**
 *			R T _ S U P E R E L L _ C U R V E
 *
 *  Return the curvature of the superellipsoid.
 */
void
rt_superell_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
  bu_log("called rt_superell_curve!\n");
  return;
}


/**
 *  			R T _ S U P E R E L L _ U V
 *
 *  For a hit on the surface of an SUPERELL, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_superell_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
  bu_log("called rt_superell_uv!\n");
  return;
}

/**
 *			R T _ S U P E R E L L _ F R E E
 */
void
rt_superell_free(register struct soltab *stp)
{
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;

	bu_free( (char *)superell, "superell_specific" );
}


int
rt_superell_class(void)
{
	return(0);
}


/**
 *			R T _ S U P E R E L L _ 1 6 P T S
 *
 * Also used by the TGC code
 */
#define SUPERELLOUT(n)	ov+(n-1)*3
void
rt_superell_16pts(register fastf_t *ov,
	     register fastf_t *V,
	     fastf_t *A,
	     fastf_t *B)
{
	static fastf_t c, d, e, f,g,h;

	e = h = .92388;			/* cos(22.5) */
	c = d = .707107;		/* cos(45) */
	g = f = .382683;		/* cos(67.5) */

	/*
	 * For angle theta, compute surface point as
	 *
	 *	V  +  cos(theta) * A  + sin(theta) * B
	 *
	 * note that sin(theta) is cos(90-theta).
	 */

	VADD2( SUPERELLOUT(1), V, A );
	VJOIN2( SUPERELLOUT(2), V, e, A, f, B );
	VJOIN2( SUPERELLOUT(3), V, c, A, d, B );
	VJOIN2( SUPERELLOUT(4), V, g, A, h, B );
	VADD2( SUPERELLOUT(5), V, B );
	VJOIN2( SUPERELLOUT(6), V, -g, A, h, B );
	VJOIN2( SUPERELLOUT(7), V, -c, A, d, B );
	VJOIN2( SUPERELLOUT(8), V, -e, A, f, B );
	VSUB2( SUPERELLOUT(9), V, A );
	VJOIN2( SUPERELLOUT(10), V, -e, A, -f, B );
	VJOIN2( SUPERELLOUT(11), V, -c, A, -d, B );
	VJOIN2( SUPERELLOUT(12), V, -g, A, -h, B );
	VSUB2( SUPERELLOUT(13), V, B );
	VJOIN2( SUPERELLOUT(14), V, g, A, -h, B );
	VJOIN2( SUPERELLOUT(15), V, c, A, -d, B );
	VJOIN2( SUPERELLOUT(16), V, e, A, -f, B );
}

/**
 *			R T _ S U P E R E L L _ P L O T
 */
int
rt_superell_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int		i;
	struct rt_superell_internal	*eip;
	fastf_t top[16*3];
	fastf_t middle[16*3];
	fastf_t bottom[16*3];

	RT_CK_DB_INTERNAL(ip);
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(eip);

	rt_superell_16pts( top, eip->v, eip->a, eip->b );
	rt_superell_16pts( bottom, eip->v, eip->b, eip->c );
	rt_superell_16pts( middle, eip->v, eip->a, eip->c );

	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}

	RT_ADD_VLIST( vhead, &middle[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ )  {
		RT_ADD_VLIST( vhead, &middle[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	}
	return(0);
}

#if 0
static point_t	octa_verts[6] = {
	{ 1, 0, 0 },	/* XPLUS */
	{-1, 0, 0 },	/* XMINUS */
	{ 0, 1, 0 },	/* YPLUS */
	{ 0,-1, 0 },	/* YMINUS */
	{ 0, 0, 1 },	/* ZPLUS */
	{ 0, 0,-1 }	/* ZMINUS */
};

#define XPLUS 0
#define XMIN  1
#define YPLUS 2
#define YMIN  3
#define ZPLUS 4
#define ZMIN  5
#endif

/* Vertices of a unit octahedron */
/* These need to be organized properly to give reasonable normals */
/* static struct usvert {
 * 	int	a;
 * 	int	b;
 * 	int	c;
 * } octahedron[8] = {
 *     { XPLUS, ZPLUS, YPLUS },
 *     { YPLUS, ZPLUS, XMIN  },
 *     { XMIN , ZPLUS, YMIN  },
 *     { YMIN , ZPLUS, XPLUS },
 *     { XPLUS, YPLUS, ZMIN  },
 *     { YPLUS, XMIN , ZMIN  },
 *     { XMIN , YMIN , ZMIN  },
 *     { YMIN , XPLUS, ZMIN  }
 * };
 */
struct superell_state {
	struct shell	*s;
	struct rt_superell_internal	*eip;
	mat_t		invRinvS;
	mat_t		invRoS;
	fastf_t		theta_tol;
};

struct superell_vert_strip {
	int		nverts_per_strip;
	int		nverts;
	struct vertex	**vp;
	vect_t		*norms;
	int		nfaces;
	struct faceuse	**fu;
};

/**
 *			R T _ S U P E R E L L _ T E S S
 *
 *  Tesssuperellate an superellipsoid.
 *
 *  The strategy is based upon the approach of Jon Leech 3/24/89,
 *  from program "sphere", which generates a polygon mesh
 *  approximating a sphere by
 *  recursive subdivision. First approximation is an octahedron;
 *  each level of refinement increases the number of polygons by
 *  a factor of 4.
 *  Level 3 (128 polygons) is a good tradeoff if gouraud
 *  shading is used to render the database.
 *
 *  At the start, points ABC lie on surface of the unit sphere.
 *  Pick DEF as the midpoints of the three edges of ABC.
 *  Normalize the new points to lie on surface of the unit sphere.
 *
 *	  1
 *	  B
 *	 /\
 *    3 /  \ 4
 *    D/____\E
 *    /\    /\
 *   /	\  /  \
 *  /____\/____\
 * A      F     C
 * 0      5     2
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tesssuperellation.
 */
int
rt_superell_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
  bu_log("rt_superell_tess called!\n");
  return -1;
}

/**
 *			R T _ S U P E R E L L _ I M P O R T
 *
 *  Import an superellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as wsuperell.
 */
int
rt_superell_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	union record		*rp;
	fastf_t	vec[3*4 + 2];

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_superell_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SUPERELL;
	ip->idb_meth = &rt_functab[ID_SUPERELL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_superell_internal), "rt_superell_internal");
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	eip->magic = RT_SUPERELL_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	rt_fastf_float( vec, rp->s.s_values, 4 );

	/* Apply modeling transformations */
	if (mat == NULL) mat = bn_mat_identity;
	MAT4X3PNT( eip->v, mat, &vec[0*3] );
	MAT4X3VEC( eip->a, mat, &vec[1*3] );
	MAT4X3VEC( eip->b, mat, &vec[2*3] );
	MAT4X3VEC( eip->c, mat, &vec[3*3] );
	eip->n = rp->s.s_values[12];
	eip->e = rp->s.s_values[13];

	return(0);		/* OK */
}

/**
 *			R T _ S U P E R E L L _ E X P O R T
 */
int
rt_superell_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_superell_internal	*tip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SUPERELL )  return(-1);
	tip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "superell external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = SUPERELL;

	/* NOTE: This also converts to dbfloat_t */
	VSCALE( &rec->s.s_values[0], tip->v, local2mm );
	VSCALE( &rec->s.s_values[3], tip->a, local2mm );
	VSCALE( &rec->s.s_values[6], tip->b, local2mm );
	VSCALE( &rec->s.s_values[9], tip->c, local2mm );

	printf("SUPERELL: %g %g\n", tip->n, tip->e);

	rec->s.s_values[12] = tip->n;
	rec->s.s_values[13] = tip->e;

	return(0);
}

/**
 *			R T _ S U P E R E L L _ I M P O R T 5
 *
 *  Import an superellipsoid/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as wsuperell.
 */
int
rt_superell_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	fastf_t			vec[ELEMENTS_PER_VECT*4 + 2];

	RT_CK_DB_INTERNAL( ip );
	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * (ELEMENTS_PER_VECT*4 + 2));

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SUPERELL;
	ip->idb_meth = &rt_functab[ID_SUPERELL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_superell_internal), "rt_superell_internal");

	eip = (struct rt_superell_internal *)ip->idb_ptr;
	eip->magic = RT_SUPERELL_INTERNAL_MAGIC;

	/* Convert from database (network) to internal (host) format */
	ntohd( (unsigned char *)vec, ep->ext_buf, ELEMENTS_PER_VECT*4 + 2);

	/* Apply modeling transformations */
	if (mat == NULL) mat = bn_mat_identity;
	MAT4X3PNT( eip->v, mat, &vec[0*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->a, mat, &vec[1*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->b, mat, &vec[2*ELEMENTS_PER_VECT] );
	MAT4X3VEC( eip->c, mat, &vec[3*ELEMENTS_PER_VECT] );
	eip->n = vec[4*ELEMENTS_PER_VECT];
	eip->e = vec[4*ELEMENTS_PER_VECT + 1];

	return 0;		/* OK */
}

/**
 *			R T _ S U P E R E L L _ E X P O R T 5
 *
 *  The external format is:
 *	V point
 *	A vector
 *	B vector
 *	C vector
 */
int
rt_superell_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_superell_internal	*eip;
	fastf_t			vec[ELEMENTS_PER_VECT*4 + 2];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_SUPERELL )  return(-1);
	eip = (struct rt_superell_internal *)ip->idb_ptr;
	RT_SUPERELL_CK_MAGIC(eip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * (ELEMENTS_PER_VECT*4 + 2);
	ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "superell external");

	/* scale 'em into local buffer */
	VSCALE( &vec[0*ELEMENTS_PER_VECT], eip->v, local2mm );
	VSCALE( &vec[1*ELEMENTS_PER_VECT], eip->a, local2mm );
	VSCALE( &vec[2*ELEMENTS_PER_VECT], eip->b, local2mm );
	VSCALE( &vec[3*ELEMENTS_PER_VECT], eip->c, local2mm );

	vec[4*ELEMENTS_PER_VECT] = eip->n;
	vec[4*ELEMENTS_PER_VECT + 1] = eip->e;

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, ELEMENTS_PER_VECT*4 + 2 );

	return 0;
}

/**
 *			R T _ S U P E R E L L _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_superell_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register struct rt_superell_internal	*tip =
		(struct rt_superell_internal *)ip->idb_ptr;
	fastf_t	mag_a, mag_b, mag_c;
	char	buf[256];
	double	angles[5];
	vect_t	unitv;

	RT_SUPERELL_CK_MAGIC(tip);
	bu_vls_strcat( str, "superellipsoid (SUPERELL)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		INTCLAMP(tip->v[X] * mm2local),
		INTCLAMP(tip->v[Y] * mm2local),
		INTCLAMP(tip->v[Z] * mm2local) );
	bu_vls_strcat( str, buf );

	mag_a = MAGNITUDE(tip->a);
	mag_b = MAGNITUDE(tip->b);
	mag_c = MAGNITUDE(tip->c);

	sprintf(buf, "\tA (%g, %g, %g) mag=%g\n",
		INTCLAMP(tip->a[X] * mm2local),
		INTCLAMP(tip->a[Y] * mm2local),
		INTCLAMP(tip->a[Z] * mm2local),
		INTCLAMP(mag_a * mm2local) );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tB (%g, %g, %g) mag=%g\n",
		INTCLAMP(tip->b[X] * mm2local),
		INTCLAMP(tip->b[Y] * mm2local),
		INTCLAMP(tip->b[Z] * mm2local),
		INTCLAMP(mag_b * mm2local) );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tC (%g, %g, %g) mag=%g\n",
		INTCLAMP(tip->c[X] * mm2local),
		INTCLAMP(tip->c[Y] * mm2local),
		INTCLAMP(tip->c[Z] * mm2local),
		INTCLAMP(mag_c * mm2local) );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\t<n,e> (%g, %g)\n", INTCLAMP(tip->n), INTCLAMP(tip->e));
	bu_vls_strcat(str, buf);

	if( !verbose )  return(0);

	VSCALE( unitv, tip->a, 1/mag_a );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tA", angles );

	VSCALE( unitv, tip->b, 1/mag_b );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tB", angles );

	VSCALE( unitv, tip->c, 1/mag_c );
	rt_find_fallback_angle( angles, unitv );
	rt_pr_fallback_angle( str, "\tC", angles );

	return(0);
}

/**
 *			R T _ S U P E R E L L _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_superell_ifree(struct rt_db_internal *ip)
{
	RT_CK_DB_INTERNAL(ip);
	bu_free( ip->idb_ptr, "superell ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/*  The U parameter runs south to north.
 *  In order to orient loop CCW, need to start with 0,1-->0,0 transition
 *  at the south pole.
 */
static const fastf_t rt_superell_uvw[5*ELEMENTS_PER_VECT] = {
	0, 1, 0,
	0, 0, 0,
	1, 0, 0,
	1, 1, 0,
	0, 1, 0
};

/**
 *			R T _ S U P E R E L L _ T N U R B
 */
int
rt_superell_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
  bu_log("rt_superell_tnurb called!\n");
	return 0;
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.24
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@a43 4
#ifndef lint
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.23 2007/11/28 14:11:27 erikgreenwald Exp $ (BRL)";
#endif

d202 5
a206 5
  static fastf_t	magsq_a, magsq_b, magsq_c;
  static mat_t	R, TEMP;
  static vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
  static vect_t	w1, w2, P;	/* used for bounding RPP */
  static fastf_t	f;
d375 7
a381 7
  static bn_poly_t equation; /* equation of superell to be solved */
  static vect_t translated;  /* translated shot vector */
  static vect_t newShotPoint; /* P' */
  static vect_t newShotDir; /* D' */
  static vect_t normalizedShotPoint; /* P' with normalized dist from superell */
  static bn_complex_t complexRoot[4]; /* roots returned from poly solver */
  static double realRoot[4];  /* real ray distance values */
d572 2
a573 2
  static vect_t xlated;
  static fastf_t scale;
d818 1
a818 1
	static fastf_t	vec[3*4 + 2];
@


14.23
log
@LOCAL->static, per machine.h deprecation list
@
text
@d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.22 2007/09/15 16:23:13 brlcad Exp $ (BRL)";
d474 1
a474 1
      FAST fastf_t	u;
d490 1
a490 1
	  FAST fastf_t	u;
@


14.22
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.21 2007/01/27 01:41:41 brlcad Exp $ (BRL)";
d206 5
a210 5
  LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
  LOCAL mat_t	R, TEMP;
  LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
  LOCAL vect_t	w1, w2, P;	/* used for bounding RPP */
  LOCAL fastf_t	f;
d379 7
a385 7
  LOCAL bn_poly_t equation; /* equation of superell to be solved */
  LOCAL vect_t translated;  /* translated shot vector */
  LOCAL vect_t newShotPoint; /* P' */
  LOCAL vect_t newShotDir; /* D' */
  LOCAL vect_t normalizedShotPoint; /* P' with normalized dist from superell */
  LOCAL bn_complex_t complexRoot[4]; /* roots returned from poly solver */
  LOCAL double realRoot[4];  /* real ray distance values */
d576 2
a577 2
  LOCAL vect_t xlated;
  LOCAL fastf_t scale;
d822 1
a822 1
	LOCAL fastf_t	vec[3*4 + 2];
@


14.21
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.20 2007/01/26 05:28:48 brlcad Exp $ (BRL)";
d52 1
a52 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.20
log
@allow the import function transformation matrix argument to be NULL, use an identity matrix in that situation.
@
text
@d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.19 2007/01/23 01:13:37 brlcad Exp $ (BRL)";
d559 4
a562 4
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
@


14.19
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.18 2007/01/21 04:45:44 brlcad Exp $ (BRL)";
d848 1
d925 1
@


14.18
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.17 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.17
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d24 1
d43 1
a43 1
/*@@}*/
d46 1
a46 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.16 2006/09/16 02:04:25 lbutler Exp $ (BRL)";
@


14.16
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.15 2006/01/22 23:37:39 brlcad Exp $ (BRL)";
@


14.15
log
@missing stddef.h for offsetof, convert references to offsetof to bu_offsetof
@
text
@d22 1
a22 1
/** \addtogroup g */
d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.14 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
@


14.14
log
@update copyright to 2006
@
text
@d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.13 2005/11/24 14:28:22 brlcad Exp $ (BRL)";
d52 1
a52 2


d55 3
a57 1
#include <string.h>
d60 1
d71 6
a76 6
    { "%f", 3, "V", offsetof(struct rt_superell_internal, v[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "A", offsetof(struct rt_superell_internal, a[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "B", offsetof(struct rt_superell_internal, b[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 3, "C", offsetof(struct rt_superell_internal, c[X]), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "n", offsetof(struct rt_superell_internal, n), BU_STRUCTPARSE_FUNC_NULL },
    { "%f", 1, "e", offsetof(struct rt_superell_internal, e), BU_STRUCTPARSE_FUNC_NULL },
@


14.13
log
@clamp the number being printed by the describe function to their closest integer if it's within hardware tolerance of an integer.  this is done only in the describe function for now so it's only cosmetic, though it could conceivably happen on store/load too.  (addresses sf 'bug'/request 1359253)
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.12 2005/10/30 21:58:57 brlcad Exp $ (BRL)";
@


14.12
log
@remove C++-style // comments as there's no assumption of c99 compiler compliance yet, only c89 (mostly aix compiler though other old compilers too)
@
text
@d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.11 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
d994 3
a996 3
		tip->v[X] * mm2local,
		tip->v[Y] * mm2local,
		tip->v[Z] * mm2local );
d1004 4
a1007 4
		tip->a[X] * mm2local,
		tip->a[Y] * mm2local,
		tip->a[Z] * mm2local,
		mag_a * mm2local);
d1011 4
a1014 4
		tip->b[X] * mm2local,
		tip->b[Y] * mm2local,
		tip->b[Z] * mm2local,
		mag_b * mm2local);
d1018 4
a1021 4
		tip->c[X] * mm2local,
		tip->c[Y] * mm2local,
		tip->c[Z] * mm2local,
		mag_c * mm2local);
d1024 1
a1024 1
	sprintf(buf, "\t<n,e> (%g, %g)\n", tip->n, tip->e);
@


14.11
log
@trailing ws
@
text
@d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.10 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
d461 3
a463 2
  //  for( j = 0; j < i; ++j )
  //    realRoot[j] -= VDOT(newShotPoint, newShotDir);
d518 1
a518 1
  //  segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 0;
d520 2
a521 2
  //  VJOIN1( segp->seg_in.hit_vpriv, newShotPoint, realRoot[1], newShotDir );
  //  VJOIN1( segp->seg_out.hit_vpriv, newShotPoint, realRoot[0], newShotDir );
@


14.10
log
@Doxygen changes
@
text
@d31 2
a32 2
 *       
 *	
d37 1
a37 1
 *  
d42 1
a42 1
 *  
d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.9 2005/07/04 02:56:06 brlcad Exp $ (BRL)";
d81 1
a81 1
 *  
d83 1
a83 1
 *  
d85 1
a85 1
 *  
d88 1
a88 1
 *  
d90 1
a90 1
 *  
d92 1
a92 1
 *  
d94 1
a94 1
 *  
d98 1
a98 1
 *  
d102 1
a102 1
 *  
d105 1
a105 1
 *  
d107 1
a107 1
 *  
d110 1
a110 1
 *  
d112 1
a112 1
 *  
d114 1
a114 1
 *  
d116 1
a116 1
 *  
d120 1
a120 1
 *  
d123 1
a123 1
 *  
d126 1
a126 1
 *  
d128 1
a128 1
 *  
d133 1
a133 1
 *  
d136 1
a136 1
 *  
d139 1
a139 1
 *  
d141 1
a141 1
 *  
d144 1
a144 1
 *  
d147 1
a147 1
 *  
d191 1
a191 1
 *  
d195 1
a195 1
 *  
d199 1
a199 1
 *  
d207 1
a207 1
  
d215 1
a215 1
  
d218 1
a218 1
  
d223 1
a223 1
  
d230 1
a230 1
    bu_log("superell(%s):  near-zero length <n,e> curvature (%g, %g) causes problems\n", 
d235 1
a235 1
    bu_log("superell(%s):  very large <n,e> curvature (%g, %g) causes problems\n", 
d239 1
a239 1
  
d247 1
a247 1
  
d264 1
a264 1
  
d315 1
a315 1
  
d318 1
a318 1
  
d327 1
a327 1
  
d336 1
a336 1
  
d345 1
a345 1
  
d368 1
a368 1
 *  
d372 1
a372 1
 *  
d411 1
a411 1
   * point, which contains a translation along the ray direction to the 
d416 1
a416 1
  VSCALE( normalizedShotPoint, newShotDir, 
d459 1
a459 1
  
d463 1
a463 1
  
d468 1
a468 1
    
d473 1
a473 1
    
d489 1
a489 1
      
d522 1
a522 1
  
d526 1
a526 1
  
d539 1
a539 1
  
d544 1
a544 1
    
d562 1
a562 1
                  	    
d570 1
a570 1
 *  
d607 1
a607 1
 *  
@


14.10.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d31 2
a32 2
 *
 *
d37 1
a37 1
 *
d42 1
a42 1
 *
d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header$ (BRL)";
d81 1
a81 1
 *
d83 1
a83 1
 *
d85 1
a85 1
 *
d88 1
a88 1
 *
d90 1
a90 1
 *
d92 1
a92 1
 *
d94 1
a94 1
 *
d98 1
a98 1
 *
d102 1
a102 1
 *
d105 1
a105 1
 *
d107 1
a107 1
 *
d110 1
a110 1
 *
d112 1
a112 1
 *
d114 1
a114 1
 *
d116 1
a116 1
 *
d120 1
a120 1
 *
d123 1
a123 1
 *
d126 1
a126 1
 *
d128 1
a128 1
 *
d133 1
a133 1
 *
d136 1
a136 1
 *
d139 1
a139 1
 *
d141 1
a141 1
 *
d144 1
a144 1
 *
d147 1
a147 1
 *
d191 1
a191 1
 *
d195 1
a195 1
 *
d199 1
a199 1
 *
d207 1
a207 1

d215 1
a215 1

d218 1
a218 1

d223 1
a223 1

d230 1
a230 1
    bu_log("superell(%s):  near-zero length <n,e> curvature (%g, %g) causes problems\n",
d235 1
a235 1
    bu_log("superell(%s):  very large <n,e> curvature (%g, %g) causes problems\n",
d239 1
a239 1

d247 1
a247 1

d264 1
a264 1

d315 1
a315 1

d318 1
a318 1

d327 1
a327 1

d336 1
a336 1

d345 1
a345 1

d368 1
a368 1
 *
d372 1
a372 1
 *
d411 1
a411 1
   * point, which contains a translation along the ray direction to the
d416 1
a416 1
  VSCALE( normalizedShotPoint, newShotDir,
d459 1
a459 1

d461 3
a463 4
  /*  for( j = 0; j < i; ++j )
      realRoot[j] -= VDOT(newShotPoint, newShotDir);
  */

d468 1
a468 1

d473 1
a473 1

d489 1
a489 1

d517 1
a517 1
  /*  segp->seg_in.hit_surfno = segp->seg_out.hit_surfno = 0; */
d519 2
a520 2
  /*  VJOIN1( segp->seg_in.hit_vpriv, newShotPoint, realRoot[1], newShotDir ); */
  /*  VJOIN1( segp->seg_out.hit_vpriv, newShotPoint, realRoot[0], newShotDir ); */
d522 1
a522 1

d526 1
a526 1

d539 1
a539 1

d544 1
a544 1

d562 1
a562 1

d570 1
a570 1
 *
d607 1
a607 1
 *
@


14.9
log
@add the equation of an ellipsoid in the comments
@
text
@d21 4
d26 1
a26 2
 *
 *  Purpose -
d32 1
a32 1
 *	Intersect a ray with a Superquadratic Ellipsoid
d44 2
d47 1
a47 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.8 2005/05/02 00:49:38 brlcad Exp $ (BRL)";
d189 1
a189 1
/*
d349 1
a349 1
/*
d551 1
a551 1
/*
d568 1
a568 1
/*
d592 1
a592 1
/*
d605 1
a605 1
/*
d620 1
a620 1
/*
d640 1
a640 1
/*
d684 1
a684 1
/*
d773 1
a773 1
/*
d813 1
a813 1
/*
d857 1
a857 1
/*
d893 1
a893 1
/*
d933 1
a933 1
/*
d972 1
a972 1
/*
d1043 1
a1043 1
/*
d1068 1
a1068 1
/*
@


14.8
log
@since the root solver returns a negative result when convergence fails, we can use that to print out additional information such as the ray starting point and ray direction.  needs some more testing, of course, and the static declaration may need to be moved. (sf request 1185997)
@
text
@d42 1
a42 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.7 2005/04/29 14:22:53 lbutler Exp $ (BRL)";
d356 5
d416 1
a416 1
  
d419 1
d421 1
d423 1
@


14.7
log
@When the root finder rt_poly_findroot cannot find roots, it now tells you the name of the primitive.
This is not always an error.  Frequently, this results from a ray grazing the primitve.  However, it is
reasonable for the user to want to know and examine the primitive, and asses the impact on the analysis
being performed.
@
text
@d42 1
a42 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.6 2005/01/30 20:31:00 brlcad Exp $ (BRL)";
d220 1
a220 1
    bu_log("superell(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
d225 1
a225 1
    bu_log("superell(%s):  zero length <n,e> curvature (%g, %g) causes problems\n", 
a371 1
#if 1
d419 14
a432 5
    if (i != 0) {
      bu_log("superell: rt_poly_roots() 2 != %d\n", i);
      bn_pr_roots(stp->st_name, complexRoot, i);
    }
    return (0); /* MISS */
a534 56
#else
  /* XXX ell code */
	register struct superell_specific *superell =
		(struct superell_specific *)stp->st_specific;
	register struct seg *segp;
	LOCAL vect_t	dprime;		/* D' */
	LOCAL vect_t	pprime;		/* P' */
	LOCAL vect_t	xlated;		/* translated vector */
	LOCAL fastf_t	dp, dd;		/* D' dot P', D' dot D' */
	LOCAL fastf_t	k1, k2;		/* distance constants of solution */
	FAST fastf_t	root;		/* root of radical */

	/* out, Mat, vect */
	MAT4X3VEC( dprime, superell->superell_SoR, rp->r_dir );
	VSUB2( xlated, rp->r_pt, superell->superell_V );
	MAT4X3VEC( pprime, superell->superell_SoR, xlated );

	dp = VDOT( dprime, pprime );
	dd = VDOT( dprime, dprime );

	if( (root = dp*dp - dd * (VDOT(pprime,pprime)-1.0)) < 0 )
		return(0);		/* No hit */
	root = sqrt(root);

	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;
	if( (k1=(-dp+root)/dd) <= (k2=(-dp-root)/dd) )  {
		/* k1 is entry, k2 is exit */
		segp->seg_in.hit_dist = k1;
		segp->seg_out.hit_dist = k2;

		/* !!! please room */
		if (counter > 0) {
		  bu_log("realroot: in %d  out %d\n", k1, k2);
		  counter--;
		}

	} else {
		/* k2 is entry, k1 is exit */
		segp->seg_in.hit_dist = k2;
		segp->seg_out.hit_dist = k1;

		/* !!! please room */
		if (counter > 0) {
		  bu_log("realroot: in %d  out %d\n", k2, k1);
		  counter--;
		}

	}


	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(2);			/* HIT */


#endif
@


14.6
log
@update copyright to 2005
@
text
@d42 1
a42 1
static const char RCSsuperell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_superell.c,v 14.5 2004/12/21 06:38:21 morrison Exp $ (BRL)";
d419 1
a419 1
  if ( (i = rt_poly_roots( &equation, complexRoot)) != 2 ) {
d421 1
a421 1
      bu_log("superell, rt_poly_roots() 2 != %d\n", i);
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d42 1
a42 1
static const char RCSsuperell[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_superell.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a39 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985 by the United States Army.
 *	All rights reserved.
d42 1
a42 1
static const char RCSsuperell[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_superell.c,v 14.3 2004/12/21 05:45:24 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_superell.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_superell.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ S U P E R E L L . C
d45 1
a45 1
static const char RCSsuperell[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_superell.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d26 1
a26 1
static const char RCSsuperell[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_superell.c,v 1.1 2004/05/20 15:20:02 morrison Exp $ (BRL)";
d1097 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d26 1
a26 1
static const char RCSsuperell[] = "@@(#)$Header: /cvs/brlcad/librt/g_superell.c,v 11.2 2004/05/10 15:30:46 erikg Exp $ (BRL)";
d29 1
a29 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

