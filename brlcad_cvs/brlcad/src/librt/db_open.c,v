head	14.36;
access;
symbols
	rel-7-10-4:14.33
	STABLE:14.33.0.2
	stable-branch:14.7
	rel-7-10-2:14.33
	rel-7-10-0:14.26
	rel-7-8-4:14.22
	rel-7-8-2:14.18
	rel-7-8-0:14.16
	trimnurbs-branch:14.16.0.2
	help:14.16
	temp_tag:14.11
	bobWinPort-20051223-freeze:14.10
	postmerge-20051223-bobWinPort:14.11
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.10
	rel-7-6-branch:14.10.0.4
	rel-7-6-0:14.10
	rel-7-4-2:14.9
	rel-7-4-branch:14.9.0.2
	bobWinPort:14.10.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.9
	rel-7-2-4:14.8
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.6
	rel-7-0-2:14.6
	rel-7-0-1:14.6
	opensource-post:14.6
	opensource-pre:1.6
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.36
date	2007.11.13.21.15.09;	author bob1961;	state Exp;
branches;
next	14.35;

14.35
date	2007.11.13.09.51.31;	author d_rossberg;	state Exp;
branches;
next	14.34;

14.34
date	2007.09.15.16.23.12;	author brlcad;	state Exp;
branches;
next	14.33;

14.33
date	2007.07.26.01.13.57;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.06.03.23.02.35;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2007.05.26.01.18.22;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.05.25.05.25.57;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.05.25.05.25.25;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.05.19.01.32.52;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.04.14.01.16.02;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.01.27.01.41.39;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.21;

14.21
date	2006.08.29.23.26.08;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.08.29.23.20.36;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.08.29.23.01.29;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.06.01.14.51.03;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.06.01.12.57.20;	author d_rossberg;	state Exp;
branches;
next	14.16;

14.16
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.01.15.20.36.08;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.01.11.22.42.59;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.11.21.24.11;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.11.19.18.57;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.08.12.22.31.07;	author lbutler;	state Exp;
branches
	14.10.4.1;
next	14.9;

14.9
date	2005.05.28.02.14.51;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.05.11.02.38.46;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.01.30.20.30.58;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.11.24.01.15.07;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.03.20.42.29;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.16.12.48.02;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.57.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.57;	author morrison;	state Exp;
branches;
next	;

14.10.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.36
log
@Initialize dbip->dbi_fd in db_open() to -1.
@
text
@/*                       D B _ O P E N . C
 * BRL-CAD
 *
 * Copyright (c) 1988-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup dbio */
/** @@{ */
/** @@file db_open.c
 *
 * Functions -
 *	db_open		Open the database
 *	db_create	Create a new database
 *	db_close	Close a database, releasing dynamic memory
 *	db_clone_dbi	Clone a given database instance
 *
 *  Authors -
 *	Michael John Muuss
 *	Robert Jon Reschly Jr.
 *
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.35 2007/11/13 09:51:31 d_rossberg Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>
#include <fcntl.h>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_UNIX_IO
#  include <sys/types.h>
#  include <sys/stat.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "db.h"
#include "wdb.h"

#include "./debug.h"

#ifndef SEEK_SET
# define SEEK_SET	0
#endif

#define DEFAULT_DB_TITLE "Untitled BRL-CAD Database"


/**
 *  			D B _ O P E N
 *
 *  Open the named database.
 *  The 'mode' parameter specifies read-only or read-write mode.
 *
 *  As a convenience, dbi_filepath is a C-style argv array of dirs to search
 *  when attempting to open related files (such as data files for EBM
 *  solids or texture-maps).  The default values are "." and the
 *  directory containing the ".g" file.  They may be overriden by
 *  setting the environment variable BRLCAD_FILE_PATH.
 *
 *  Returns:
 *	DBI_NULL	error
 *	db_i *		success
 */
struct db_i *
db_open(const char *name, const char *mode)
{
    register struct db_i	*dbip = DBI_NULL;
    register int		i;
    char **argv;

    if (RT_G_DEBUG & DEBUG_DB) {
	bu_log("db_open(%s, %s)\n", name, mode );
    }

    if (mode && mode[0] == 'r' && mode[1] == '\0') {
	struct bu_mapped_file	*mfp;

	/* Read-only mode */
	mfp = bu_open_mapped_file( name, "db_i" );
	if (mfp == NULL)
	    goto fail;

	/* Is this a re-use of a previously mapped file? */
	if (mfp->apbuf) {
	    dbip = (struct db_i *)mfp->apbuf;
	    RT_CK_DBI(dbip);
	    dbip->dbi_uses++;

	    /*
	     * decrement the mapped file reference counter by 1,
	     * references are already counted in dbip->dbi_uses
	     */
	    bu_close_mapped_file(mfp);

	    if (RT_G_DEBUG & DEBUG_DB) {
		bu_log("db_open(%s) dbip=x%x: reused previously mapped file\n", name, dbip);
	    }

	    return dbip;
	}

	BU_GETSTRUCT( dbip, db_i );
	dbip->dbi_mf = mfp;
	dbip->dbi_eof = mfp->buflen;
	dbip->dbi_inmem = mfp->buf;
	dbip->dbi_mf->apbuf = (genptr_t)dbip;
	dbip->dbi_fd = -1;

#ifdef HAVE_UNIX_IO
	/* Do this too, so we can seek around on the file */
	if( (dbip->dbi_fd = open( name, O_RDONLY )) < 0 )
	    goto fail;
	if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "rb" )) == NULL )
	    goto fail;
#else /* HAVE_UNIX_IO */
	if( (dbip->dbi_fp = fopen( name, "rb")) == NULL )
	    goto fail;
	dbip->dbi_fd = -1;
#endif
	dbip->dbi_read_only = 1;
    }  else  {
	/* Read-write mode */
	BU_GETSTRUCT( dbip, db_i );
	dbip->dbi_eof = -1L;
	dbip->dbi_fd = -1;

#ifdef HAVE_UNIX_IO
	if( (dbip->dbi_fd = open( name, O_RDWR )) < 0 )
	    goto fail;
	if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "r+w" )) == NULL )
	    goto fail;
#else /* HAVE_UNIX_IO */
	if( (dbip->dbi_fp = fopen( name, "r+b")) == NULL )
	    goto fail;
	dbip->dbi_fd = -1;
#endif
	dbip->dbi_read_only = 0;
    }

    /* Initialize fields */
    for( i=0; i<RT_DBNHASH; i++ )
	dbip->dbi_Head[i] = DIR_NULL;

    dbip->dbi_local2base = 1.0;		/* mm */
    dbip->dbi_base2local = 1.0;
    dbip->dbi_title = (char *)0;
    dbip->dbi_uses = 1;

    /* Record the filename and file path */
    dbip->dbi_filename = bu_strdup(name);

    /* XXX At some point, expand with getenv("BRLCAD_FILE_PATH"); */
    argv = (char **)bu_malloc( 3 * sizeof(char *), "dbi_filepath[3]" );
    argv[0] = bu_strdup( "." );
    argv[1] = bu_dirname( name );
    argv[2] = NULL;
    dbip->dbi_filepath = argv;

    bu_ptbl_init( &dbip->dbi_clients, 128, "dbi_clients[]" );
    dbip->dbi_magic = DBI_MAGIC;		/* Now it's valid */

    /* determine version */
    dbip->dbi_version = db_get_version( dbip );

    if (RT_G_DEBUG & DEBUG_DB) {
	bu_log("db_open(%s) dbip=x%x version=%d\n", dbip->dbi_filename, dbip, dbip->dbi_version);
    }

    return dbip;

 fail:
    if (RT_G_DEBUG & DEBUG_DB) {
	bu_log("db_open(%s) FAILED\n", name);
    }

    if (dbip && dbip->dbi_fd >= 0) {
	(void)close(dbip->dbi_fd);
	dbip->dbi_fd = -1;
    }
    if (dbip && dbip->dbi_fp) {
	(void)fclose(dbip->dbi_fp);
	dbip->dbi_fp = (FILE *)NULL;
    }

    if (dbip) {
	bu_free( (char *)dbip, "struct db_i" );
    }

    return DBI_NULL;
}

/**
 *			D B _ C R E A T E
 *
 *  Create a new database containing just a header record,
 *  regardless of whether the database previously existed or not,
 *  and open it for reading and writing.
 *
 *  New in BRL-CAD Release 6.0 is that this routine also calls
 *  db_dirbuild(), so the caller shouldn't.
 *
 *
 *  Returns:
 *	DBI_NULL	error
 *	db_i *		success
 */
struct db_i *
db_create(const char *name,
	  int	     version)
{
    FILE	*fp;
    struct db_i	*dbip;
    int result;

    if (RT_G_DEBUG & DEBUG_DB)
	bu_log("db_create(%s, %d)\n", name, version );

    fp = fopen( name, "w+b" );

    if (fp == NULL )  {
	perror(name);
	return(DBI_NULL);
    }

    if (version == 5) {
	result = db5_fwrite_ident(fp, DEFAULT_DB_TITLE, 1.0);
    } else if (version == 4) {
	result = db_fwrite_ident(fp, DEFAULT_DB_TITLE, 1.0);
    } else {
	bu_log("WARNING: db_create() was provided an unrecognized version number: %d\n", version);
	result = db5_fwrite_ident(fp, DEFAULT_DB_TITLE, 1.0);
    }

    (void)fclose(fp);

    if (result < 0)
	return DBI_NULL;

    if( (dbip = db_open( name, "r+w" ) ) == DBI_NULL )
	return DBI_NULL;

    /* Do a quick scan to determine version, find _GLOBAL, etc. */
    if( db_dirbuild( dbip ) < 0 )
	return DBI_NULL;

    return dbip;
}

/**
 *			D B _ C L O S E _ C L I E N T
 *
 *  De-register a client of this database instance, if provided, and
 *  close out the instance.
 */
void
db_close_client(struct db_i *dbip, long int *client)
{
    RT_CK_DBI(dbip);
    if (client) {
	(void)bu_ptbl_rm( &dbip->dbi_clients, client );
    }
    db_close(dbip);
}

/**
 *			D B _ C L O S E
 *
 *  Close a database, releasing dynamic memory
 *  Wait until last user is done, though.
 */
void
db_close(register struct db_i *dbip)
{
    register int		i;
    register struct directory *dp, *nextdp;

    RT_CK_DBI(dbip);
    if(RT_G_DEBUG&DEBUG_DB) bu_log("db_close(%s) x%x uses=%d\n",
				   dbip->dbi_filename, dbip, dbip->dbi_uses );

    bu_semaphore_acquire(BU_SEM_LISTS);
    if( (--dbip->dbi_uses) > 0 )  {
	bu_semaphore_release(BU_SEM_LISTS);
	/* others are still using this database */
	return;
    }
    bu_semaphore_release(BU_SEM_LISTS);

    /* ready to free the database -- use count is now zero */

    /* free up any mapped files */
    if( dbip->dbi_mf )  {
	/*
	 *  We're using an instance of a memory mapped file.
	 *  We have two choices:
	 *  Either deassociate from the memory mapped file
	 *  by clearing dbi_mf->apbuf, or
	 *  keeping our already-scanned dbip ready for
	 *  further use, with our dbi_uses counter at 0.
	 *  For speed of re-open, at the price of some address space,
	 *  the second choice is taken.
	 */
	bu_close_mapped_file( dbip->dbi_mf );
	bu_free_mapped_files( 0 );
	dbip->dbi_mf = (struct bu_mapped_file *)NULL;
    }

    /* try to ensure/encourage that the file is written out */
    db_sync(dbip);

#ifdef HAVE_UNIX_IO
    (void)close( dbip->dbi_fd );
#endif
    if (dbip->dbi_fp) {
	fclose( dbip->dbi_fp );
    }
    if( dbip->dbi_title )
	bu_free( dbip->dbi_title, "dbi_title" );
    if( dbip->dbi_filename )
	bu_free( dbip->dbi_filename, "dbi_filename" );

    db_free_anim( dbip );
    rt_color_free();		/* Free MaterHead list */

    /* Release map of database holes */
    rt_mempurge( &(dbip->dbi_freep) );
    rt_memclose();

    dbip->dbi_inmem = NULL;		/* sanity */

    bu_ptbl_free(&dbip->dbi_clients);

    /* Free all directory entries */
    for( i=0; i < RT_DBNHASH; i++ )  {
	for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; )  {
	    RT_CK_DIR(dp);
	    nextdp = dp->d_forw;
	    RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */

	    /* Put 'dp' back on the freelist */
	    dp->d_forw = rt_uniresource.re_directory_hd;
	    rt_uniresource.re_directory_hd = dp;

	    /* null'ing the forward pointer here is a huge
	     * memory leak as it causes the loss of all
	     * nodes on the freelist except the first.
	     * (so don't do it)
	     */

	    dp = nextdp;
	}
	dbip->dbi_Head[i] = DIR_NULL;	/* sanity*/
    }

    if (dbip->dbi_filepath != NULL) {
	if (dbip->dbi_filepath[0] != NULL)
	    bu_free((char *)dbip->dbi_filepath[0], "dbip->dbi_filepath[0]");
	if (dbip->dbi_filepath[1] != NULL)
	    bu_free((char *)dbip->dbi_filepath[1], "dbip->dbi_filepath[1]");
	bu_free((char *)dbip->dbi_filepath, "dbip->dbi_filepath");
    }

    bu_free( (char *)dbip, "struct db_i" );
}

/**
 *			D B _ D U M P
 *
 *  Dump a full copy of one database into another.
 *  This is a good way of committing a ".inmem" database to a ".g" file.
 *  The input is a database instance, the output is a LIBWDB object,
 *  which could be a disk file or another database instance.
 *
 *  Returns -
 *	-1	error
 *	0	success
 */
int
db_dump(struct rt_wdb *wdbp, struct db_i *dbip)
     /* output */
     /* input */
{
    register int		i;
    register struct directory *dp;
    struct bu_external	ext;

    RT_CK_DBI(dbip);
    RT_CK_WDB(wdbp);

    /* Output all directory entries */
    for( i=0; i < RT_DBNHASH; i++ )  {
	for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
	    RT_CK_DIR(dp);
	    /* XXX Need to go to internal form, if database versions don't match */
	    if( db_get_external( &ext, dp, dbip ) < 0 )  {
		bu_log("db_dump() read failed on %s, skipping\n", dp->d_namep );
		continue;
	    }
	    if( wdb_export_external( wdbp, &ext, dp->d_namep, dp->d_flags, dp->d_minor_type ) < 0 )  {
		bu_log("db_dump() write failed on %s, aborting\n", dp->d_namep);
		bu_free_external( &ext );
		return -1;
	    }
	    bu_free_external( &ext );
	}
    }
    return 0;
}

/**
 *			D B _ C L O N E _ D B I
 *
 *  Obtain an additional instance of this same database.  A new client
 *  is registered at the same time if one is specified.
 */
struct db_i *
db_clone_dbi(struct db_i *dbip, long int *client)
{
    RT_CK_DBI(dbip);

    dbip->dbi_uses++;
    if (client) {
	bu_ptbl_ins_unique( &dbip->dbi_clients, client );
    }
    return dbip;
}

/**
 *			D B _ S Y N C
 *
 *  Ensure that the on-disk database has been completely written
 *  out of the operating system's cache.
 */
void
db_sync(struct db_i *dbip)
{
    RT_CK_DBI(dbip);

    bu_semaphore_acquire(BU_SEM_SYSCALL);

    /* flush the file */
    (void)fflush(dbip->dbi_fp);

#ifdef HAVE_FSYNC
    /* make sure it's written out */
    (void)fsync(dbip->dbi_fd);
#else
#  ifdef HAVE_SYNC
    /* try the whole filesystem if sans fsync() */
    sync();
#  endif
#endif

    bu_semaphore_release(BU_SEM_SYSCALL);
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.35
log
@It is hard to decide in db_close if bu_close_mapped_file should be called or not:
db_open calls bu_open_mapped_file, db_clone_dbi does not.
Now, db_open calls bu_close_mapped_file if it is a re-use of a previously mapped file.
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.34 2007/09/15 16:23:12 brlcad Exp $ (BRL)";
d128 1
d146 1
@


14.34
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.33 2007/07/26 01:13:57 brlcad Exp $ (BRL)";
d110 6
@


14.33
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.32 2007/06/03 23:02:35 brlcad Exp $ (BRL)";
d43 3
a48 6
#include <fcntl.h>
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d50 2
a51 2
# include <sys/types.h>
# include <sys/stat.h>
@


14.32
log
@don't dereference null if we're failing early
@
text
@a33 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.31 2007/05/26 01:18:22 brlcad Exp $ (BRL)";
@


14.31
log
@db_get_version() was intentionally getting passed a partially initialized dbip -- require it be initialized before we pass it around anywywhere.  clean up during failure cleanup on db_open() while we're at it.
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.30 2007/05/25 05:25:57 brlcad Exp $ (BRL)";
d148 1
a148 1
#		ifdef HAVE_UNIX_IO
d153 1
a153 1
#		else /* HAVE_UNIX_IO */
d157 1
a157 1
#		endif
d197 1
a197 1
    if (dbip->dbi_fd >= 0) {
d201 1
a201 1
    if (dbip->dbi_fp) {
@


14.30
log
@ws
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.29 2007/05/25 05:25:25 brlcad Exp $ (BRL)";
d94 1
a94 2
db_open(const char *name,
	const char *mode)
d100 3
a102 1
    if(RT_G_DEBUG&DEBUG_DB) bu_log("db_open(%s, %s)\n", name, mode );
d104 1
a104 1
    if( mode && mode[0] == 'r' && mode[1] == '\0' )  {
d106 1
d109 2
a110 1
	if( mfp == NULL )  goto fail;
d113 1
a113 1
	if( mfp->apbuf )  {
d117 2
a118 1
	    if(RT_G_DEBUG&DEBUG_DB)
d120 2
d180 3
d186 3
a188 2
    bu_ptbl_init( &dbip->dbi_clients, 128, "dbi_clients[]" );
    dbip->dbi_magic = DBI_MAGIC;		/* Now it's valid */
a189 2
    if(RT_G_DEBUG&DEBUG_DB)
	bu_log("db_open(%s) dbip=x%x\n", dbip->dbi_filename, dbip);
d191 1
d193 1
a193 1
    if(RT_G_DEBUG&DEBUG_DB)
d195 15
a209 1
    if(dbip) bu_free( (char *)dbip, "struct db_i" );
@


14.29
log
@condense the windows section, using the 'b' mode identifier is fine on non-_WIN32 platforms (c90 defines it to do nothing)
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.28 2007/05/19 01:32:52 brlcad Exp $ (BRL)";
d97 27
a123 27
	register struct db_i	*dbip = DBI_NULL;
	register int		i;
	char **argv;

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_open(%s, %s)\n", name, mode );

	if( mode && mode[0] == 'r' && mode[1] == '\0' )  {
		struct bu_mapped_file	*mfp;
		/* Read-only mode */
		mfp = bu_open_mapped_file( name, "db_i" );
		if( mfp == NULL )  goto fail;

		/* Is this a re-use of a previously mapped file? */
		if( mfp->apbuf )  {
			dbip = (struct db_i *)mfp->apbuf;
			RT_CK_DBI(dbip);
			dbip->dbi_uses++;
			if(RT_G_DEBUG&DEBUG_DB)
				bu_log("db_open(%s) dbip=x%x: reused previously mapped file\n", name, dbip);
			return dbip;
		}

		BU_GETSTRUCT( dbip, db_i );
		dbip->dbi_mf = mfp;
		dbip->dbi_eof = mfp->buflen;
		dbip->dbi_inmem = mfp->buf;
		dbip->dbi_mf->apbuf = (genptr_t)dbip;
d126 5
a130 5
		/* Do this too, so we can seek around on the file */
		if( (dbip->dbi_fd = open( name, O_RDONLY )) < 0 )
			goto fail;
		if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "rb" )) == NULL )
			goto fail;
d132 3
a134 3
		if( (dbip->dbi_fp = fopen( name, "rb")) == NULL )
			goto fail;
		dbip->dbi_fd = -1;
d136 5
a140 5
		dbip->dbi_read_only = 1;
	}  else  {
		/* Read-write mode */
		BU_GETSTRUCT( dbip, db_i );
		dbip->dbi_eof = -1L;
d143 4
a146 4
			if( (dbip->dbi_fd = open( name, O_RDWR )) < 0 )
				goto fail;
			if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "r+w" )) == NULL )
				goto fail;
d148 3
a150 3
			if( (dbip->dbi_fp = fopen( name, "r+b")) == NULL )
				goto fail;
			dbip->dbi_fd = -1;
d152 2
a153 2
		dbip->dbi_read_only = 0;
	}
d155 33
a187 33
	/* Initialize fields */
	for( i=0; i<RT_DBNHASH; i++ )
		dbip->dbi_Head[i] = DIR_NULL;

	dbip->dbi_local2base = 1.0;		/* mm */
	dbip->dbi_base2local = 1.0;
	dbip->dbi_title = (char *)0;
	dbip->dbi_uses = 1;

	/* Record the filename and file path */
	dbip->dbi_filename = bu_strdup(name);

	/* XXX At some point, expand with getenv("BRLCAD_FILE_PATH"); */
	argv = (char **)bu_malloc( 3 * sizeof(char *), "dbi_filepath[3]" );
	argv[0] = bu_strdup( "." );
	argv[1] = bu_dirname( name );
	argv[2] = NULL;
	dbip->dbi_filepath = argv;

	/* determine version */
	dbip->dbi_version = db_get_version( dbip );

	bu_ptbl_init( &dbip->dbi_clients, 128, "dbi_clients[]" );
	dbip->dbi_magic = DBI_MAGIC;		/* Now it's valid */

	if(RT_G_DEBUG&DEBUG_DB)
		bu_log("db_open(%s) dbip=x%x\n", dbip->dbi_filename, dbip);
	return dbip;
fail:
	if(RT_G_DEBUG&DEBUG_DB)
		bu_log("db_open(%s) FAILED\n", name);
	if(dbip) bu_free( (char *)dbip, "struct db_i" );
	return DBI_NULL;
d209 22
a230 13
	FILE	*fp;
	struct db_i	*dbip;
	int result;

	if (RT_G_DEBUG & DEBUG_DB)
	    bu_log("db_create(%s, %d)\n", name, version );

	fp = fopen( name, "w+b" );

	if (fp == NULL )  {
	    perror(name);
	    return(DBI_NULL);
	}
d232 1
a232 8
	if (version == 5) {
	    result = db5_fwrite_ident(fp, DEFAULT_DB_TITLE, 1.0);
	} else if (version == 4) {
	    result = db_fwrite_ident(fp, DEFAULT_DB_TITLE, 1.0);
	} else {
	    bu_log("WARNING: db_create() was provided an unrecognized version number: %d\n", version);
	    result = db5_fwrite_ident(fp, DEFAULT_DB_TITLE, 1.0);
	}
d234 2
a235 1
	(void)fclose(fp);
d237 2
a238 2
	if (result < 0)
	    return DBI_NULL;
d240 3
a242 2
	if( (dbip = db_open( name, "r+w" ) ) == DBI_NULL )
	    return DBI_NULL;
d244 1
a244 5
	/* Do a quick scan to determine version, find _GLOBAL, etc. */
	if( db_dirbuild( dbip ) < 0 )
	    return DBI_NULL;

	return dbip;
d256 5
a260 5
	RT_CK_DBI(dbip);
	if (client) {
	    (void)bu_ptbl_rm( &dbip->dbi_clients, client );
	}
	db_close(dbip);
d272 2
a273 2
	register int		i;
	register struct directory *dp, *nextdp;
d275 6
a280 10
	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_close(%s) x%x uses=%d\n",
		dbip->dbi_filename, dbip, dbip->dbi_uses );

	bu_semaphore_acquire(BU_SEM_LISTS);
	if( (--dbip->dbi_uses) > 0 )  {
	    bu_semaphore_release(BU_SEM_LISTS);
	    /* others are still using this database */
	    return;
	}
d282 23
d306 2
a307 21
	/* ready to free the database -- use count is now zero */

	/* free up any mapped files */
	if( dbip->dbi_mf )  {
		/*
		 *  We're using an instance of a memory mapped file.
		 *  We have two choices:
		 *  Either deassociate from the memory mapped file
		 *  by clearing dbi_mf->apbuf, or
		 *  keeping our already-scanned dbip ready for
		 *  further use, with our dbi_uses counter at 0.
		 *  For speed of re-open, at the price of some address space,
		 *  the second choice is taken.
		 */
		bu_close_mapped_file( dbip->dbi_mf );
		bu_free_mapped_files( 0 );
		dbip->dbi_mf = (struct bu_mapped_file *)NULL;
	}

	/* try to ensure/encourage that the file is written out */
	db_sync(dbip);
d310 1
a310 1
	(void)close( dbip->dbi_fd );
d312 37
a348 39
	if (dbip->dbi_fp) {
	    fclose( dbip->dbi_fp );
	}
	if( dbip->dbi_title )
		bu_free( dbip->dbi_title, "dbi_title" );
	if( dbip->dbi_filename )
		bu_free( dbip->dbi_filename, "dbi_filename" );

	db_free_anim( dbip );
	rt_color_free();		/* Free MaterHead list */

	/* Release map of database holes */
	rt_mempurge( &(dbip->dbi_freep) );
	rt_memclose();

	dbip->dbi_inmem = NULL;		/* sanity */

	bu_ptbl_free(&dbip->dbi_clients);

	/* Free all directory entries */
	for( i=0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; )  {
			RT_CK_DIR(dp);
			nextdp = dp->d_forw;
			RT_DIR_FREE_NAMEP(dp);	/* frees d_namep */

			/* Put 'dp' back on the freelist */
			dp->d_forw = rt_uniresource.re_directory_hd;
			rt_uniresource.re_directory_hd = dp;

			/* null'ing the forward pointer here is a huge
			 * memory leak as it causes the loss of all
			 * nodes on the freelist except the first.
			 * (so don't do it)
			 */

			dp = nextdp;
		}
		dbip->dbi_Head[i] = DIR_NULL;	/* sanity*/
d350 2
d353 2
a354 2
	if (dbip->dbi_filepath != NULL) {
	  if (dbip->dbi_filepath[0] != NULL)
d356 1
a356 1
	  if (dbip->dbi_filepath[1] != NULL)
d358 2
a359 2
	  bu_free((char *)dbip->dbi_filepath, "dbip->dbi_filepath");
	}
d361 1
a361 1
	bu_free( (char *)dbip, "struct db_i" );
d378 2
a379 2
				/* output */
				/* input */
d381 22
a402 23
	register int		i;
	register struct directory *dp;
	struct bu_external	ext;

	RT_CK_DBI(dbip);
	RT_CK_WDB(wdbp);

	/* Output all directory entries */
	for( i=0; i < RT_DBNHASH; i++ )  {
		for( dp = dbip->dbi_Head[i]; dp != DIR_NULL; dp = dp->d_forw )  {
			RT_CK_DIR(dp);
/* XXX Need to go to internal form, if database versions don't match */
			if( db_get_external( &ext, dp, dbip ) < 0 )  {
				bu_log("db_dump() read failed on %s, skipping\n", dp->d_namep );
				continue;
			}
			if( wdb_export_external( wdbp, &ext, dp->d_namep, dp->d_flags, dp->d_minor_type ) < 0 )  {
				bu_log("db_dump() write failed on %s, aborting\n", dp->d_namep);
				bu_free_external( &ext );
				return -1;
			}
			bu_free_external( &ext );
		}
d404 2
a405 1
	return 0;
d417 1
a417 1
	RT_CK_DBI(dbip);
d419 5
a423 5
	dbip->dbi_uses++;
	if (client) {
	    bu_ptbl_ins_unique( &dbip->dbi_clients, client );
	}
	return dbip;
d435 1
a435 1
	RT_CK_DBI(dbip);
d437 1
a437 1
	bu_semaphore_acquire(BU_SEM_SYSCALL);
d439 2
a440 2
	/* flush the file */
	(void)fflush(dbip->dbi_fp);
d443 2
a444 2
	/* make sure it's written out */
	(void)fsync(dbip->dbi_fd);
d447 2
a448 2
	/* try the whole filesystem if sans fsync() */
	sync();
d452 1
a452 1
	bu_semaphore_release(BU_SEM_SYSCALL);
@


14.28
log
@differentiate allocation
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.27 2007/04/14 01:16:02 brlcad Exp $ (BRL)";
d129 1
a129 1
		if( (dbip->dbi_fp = fdopen( dbip->dbi_fd, "r" )) == NULL )
a147 1
#if defined(_WIN32) && !defined(__CYGWIN__)
a149 4
#else
			if( (dbip->dbi_fp = fopen( name, "r+w")) == NULL )
				goto fail;
#endif
a215 1
#if defined(_WIN32) && !defined(__CYGWIN__)
d217 1
a217 3
#else
	fp = fopen( name, "w" );
#endif
d446 1
a446 1
#  ifndef _WIN32
d449 1
a449 1
#  endif /* _WIN32 */
@


14.27
log
@remove the WIN32 conditionals relating to the binary mode specifier on file opens.  just keep the rb/wb mode since ISO/IEC 9899:1990 does specify it.
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.26 2007/01/27 01:41:39 brlcad Exp $ (BRL)";
a354 1
			/* dp->d_forw = NULL; */
d363 1
a363 1
	    bu_free((char *)dbip->dbi_filepath[0], "dbip->dbi_filepath");
d365 1
a365 1
	    bu_free((char *)dbip->dbi_filepath[1], "dbip->dbi_filepath");
@


14.26
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.25 2007/01/23 01:13:36 brlcad Exp $ (BRL)";
a131 1
#if defined(_WIN32) && !defined(__CYGWIN__)
a133 4
#else
		if( (dbip->dbi_fp = fopen( name, "r")) == NULL )
			goto fail;
#endif
@


14.25
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.24 2007/01/21 04:45:43 brlcad Exp $ (BRL)";
d314 1
a314 1
        	bu_close_mapped_file( dbip->dbi_mf );
d392 2
a393 2
             	      		/* output */
           	      		/* input */
@


14.24
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.23 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.23
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.22 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
d470 1
a470 1
/*@@}*/
@


14.22
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2006 United States Government as represented by
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.21 2006/08/29 23:26:08 brlcad Exp $ (BRL)";
@


14.21
log
@sync via db_sync in db_close instead of manually duplicating what is conceptually db_sync's job
@
text
@d22 1
a22 1
/** \addtogroup db */
a42 1
/*@@}*/
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.20 2006/08/29 23:20:36 brlcad Exp $ (BRL)";
d472 1
@


14.20
log
@rework db_sync() so that it always flushs and tries fsync() if available and only sync() as last resort.
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.19 2006/08/29 23:01:29 brlcad Exp $ (BRL)";
d323 3
a326 1
	(void)fsync(dbip->dbi_fd);
d458 1
a458 1
	fflush(dbip->dbi_fp);
d462 1
a462 1
	fsync(dbip->dbi_fd);
@


14.19
log
@fsync the file before closing it just to be safe
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.18 2006/06/01 14:51:03 brlcad Exp $ (BRL)";
d455 1
a455 1
#ifdef _WIN32
d457 3
a459 1
#elif defined(HAVE_UNIX_IO)
d462 2
d465 2
a466 1
#endif /* _WIN32 */
@


14.18
log
@allow for clientless cloning and closing of dbip instances where only the uses count is of interest.  no need to stash null clients even though the ptbl will record them, just ignore them.
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.17 2006/06/01 12:57:20 d_rossberg Exp $ (BRL)";
d248 1
a248 1
	    
d324 1
@


14.17
log
@do not close a mapped file while the database instance is still in use
as db_clone_dbi does not increment dbi_mf->uses
@
text
@d31 1
a31 1
 *
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.16 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
d267 2
a268 1
 *  De-register a client of this database instance, and close out the instance.
d274 3
a276 1
	(void)bu_ptbl_rm( &dbip->dbi_clients, client );
d426 2
a427 2
 *  Obtain an additional instance of this same database.
 *  The new client is registered at the same time.
d435 3
a437 1
	bu_ptbl_ins_unique( &dbip->dbi_clients, client );
@


14.16
log
@update copyright to 2006
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.15 2006/01/15 20:36:08 brlcad Exp $ (BRL)";
a292 3
	/* one less paying attention to the mapped file */
	if(dbip->dbi_mf) bu_close_mapped_file( dbip->dbi_mf );

d315 1
@


14.15
log
@ack, make sure the file pointer isn't null before trying to fclose it
@
text
@d4 1
a4 1
 * Copyright (C) 1988-2005 United States Government as represented by
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.14 2006/01/11 22:42:59 brlcad Exp $ (BRL)";
@


14.14
log
@clean up db_create()'s logic considerably.  annoyingly, the version check for writing out the ident can't go away since db_fwrite_ident() has no means to determine the version (need some wrapper interface)
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.13 2006/01/11 21:24:11 brlcad Exp $ (BRL)";
d325 3
a327 1
	fclose( dbip->dbi_fp );
@


14.13
log
@remove dead init line, dbi_eof is set to something else two lines after.
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.12 2006/01/11 19:18:57 brlcad Exp $ (BRL)";
d78 3
d225 1
d227 2
a228 1
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_create(%s, %d)\n", name, version );
d231 1
a231 4
	if( (fp = fopen( name, "w+b" )) == NULL )  {
		perror(name);
		return(DBI_NULL);
	}
d233 5
a237 3
	if( (fp = fopen( name, "w" )) == NULL )  {
		perror(name);
		return(DBI_NULL);
a238 1
#endif
d240 7
a246 16
	switch( version )  {
	default:
	case 5:
		/* Create a v5 database */
		if( db5_fwrite_ident(fp,"Untitled BRL-CAD Database",1.0)<0){
			(void)fclose(fp);
			return DBI_NULL;
		}
		break;
	case 4:
		/* Create a v4 database */
		if(db_fwrite_ident(fp,"Untitled BRL-CAD Database",1.0)<0) {
			(void)fclose(fp);
			return DBI_NULL;
		}
		break;
d248 2
d251 2
a252 1
	(void)fclose(fp);
d255 1
a255 2
		return DBI_NULL;

d259 2
a260 1
		return DBI_NULL;
@


14.12
log
@prevent a segfault if caller provides a null mode to db_open()
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.11 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
a120 1
		dbip->dbi_eof = -1L;
@


14.11
log
@trailing ws
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.10 2005/08/12 22:31:07 lbutler Exp $ (BRL)";
d104 1
a104 1
	if( mode[0] == 'r' && mode[1] == '\0' )  {
@


14.10
log
@Doxygen changes
@
text
@d36 1
a36 1
 *  
d41 1
a41 1
 *  
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.9 2005/05/28 02:14:51 brlcad Exp $ (BRL)";
@


14.10.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d36 1
a36 1
 *
d41 1
a41 1
 *
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


14.9
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d21 4
d43 2
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.8 2005/05/11 02:38:46 brlcad Exp $ (BRL)";
d78 1
a78 1
/*
d202 1
a202 1
/*
d268 1
a268 1
/*
d281 1
a281 1
/*
d380 1
a380 1
/*
d424 1
a424 1
/*
d440 1
a440 1
/*
@


14.8
log
@no need to embed the scope in the middle of the function for the argv array.. hope that thing is getting free'd somewhere
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.7 2005/01/30 20:30:58 brlcad Exp $ (BRL)";
d128 1
a128 1
#if defined(WIN32) && !defined(__CYGWIN__)
d149 1
a149 1
#if defined(WIN32) && !defined(__CYGWIN__)
d220 1
a220 1
#if defined(WIN32) && !defined(__CYGWIN__)
d447 1
a447 1
#ifdef WIN32
d453 1
a453 1
#endif /* WIN32 */
@


14.7
log
@update copyright to 2005
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_open.c,v 14.6 2004/12/21 06:38:20 morrison Exp $ (BRL)";
a44 2


d47 1
a47 1
#include <unistd.h>
d51 1
a51 1
#include <string.h>
d53 1
a53 1
#include <strings.h>
a54 3

#include "machine.h"

d60 1
d94 1
d174 5
a178 7
	{
		char **argv = (char **)bu_malloc( 3 * sizeof(char *), "dbi_filepath[3]" );
		argv[0] = bu_strdup( "." );
		argv[1] = bu_dirname( name );
		argv[2] = NULL;
		dbip->dbi_filepath = argv;
	}
@


14.6
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2004 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_open.c,v 14.5 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.5
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a37 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_open.c,v 14.4 2004/12/21 05:45:23 morrison Exp $ (BRL)";
@


14.4
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_open.c,v 14.3 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.3
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_open.c,v 14.2 2004/11/24 01:15:07 morrison Exp $ (BRL)";
@


14.2
log
@semaphore protect the mapped file usage count to avoid not freeing the rest of the dbi when we should
@
text
@d1 21
a21 2
/*
 *			D B _ O P E N . C
d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/src/librt/db_open.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_open.c,v 1.6 2004/09/03 23:30:58 morrison Exp $ (BRL)";
d280 4
d285 3
a287 2
		if(dbip->dbi_mf) bu_close_mapped_file( dbip->dbi_mf );
		return;
d289 3
a291 1
	/* Use count is now zero */
d293 1
a304 1
		bu_close_mapped_file( dbip->dbi_mf );
@


1.6
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_open.c,v 1.5 2004/08/03 20:42:29 morrison Exp $ (BRL)";
d439 10
@


1.5
log
@apply Bob's provided patches from 20040630.  this includes itcl namespace scoping, windows DLL exporting, and wdb arb edit support
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_open.c,v 1.3 2004/07/16 12:48:02 morrison Exp $ (BRL)";
d36 1
a36 1
#ifdef USE_STRING_H
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d77 2
a78 1
db_open(const char *name, const char *mode)
d115 4
d121 1
d136 4
d142 1
d201 2
a202 1
db_create( const char *name, int version )
d209 6
d219 1
d429 1
a429 1
#  ifdef WIN32
d431 1
a431 1
#  elif defined(HAVE_UNIX_IO)
d433 1
a433 1
#  else
d435 1
a435 1
#  endif /* WIN32 */
@


1.3
log
@parker finds an oops .. don't null'ify the forward pointer when free'ing directory entries of you'll lose all nodes on the freelist except the first.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/src/librt/db_open.c,v 1.2 2004/06/08 19:57:52 morrison Exp $ (BRL)";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@bye bye externs.h
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d315 7
a321 1
			dp->d_forw = NULL;
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_open.c,v 11.47 2004/05/10 15:30:46 erikg Exp $ (BRL)";
a50 1
#include "externs.h"
@

