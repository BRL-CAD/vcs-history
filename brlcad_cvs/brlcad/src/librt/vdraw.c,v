head	14.22;
access;
symbols
	rel-7-10-4:14.18
	STABLE:14.18.0.2
	stable-branch:14.6
	rel-7-10-2:14.18
	rel-7-10-0:14.15
	rel-7-8-4:14.11
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.22
date	2007.12.01.21.47.13;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.11.08.04.15.47;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.10.14.04.41.23;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.09.15.16.23.14;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.06.30.04.04.56;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.14.21.04.32;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.05.12.01.17.58;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.42;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.39;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.21.04.45.45;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.56;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.09.16.02.04.26;	author lbutler;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.28.00.36.28;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.36;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.03.24.16.57.58;	author bob1961;	state Exp;
branches;
next	14.5;

14.5
date	2005.01.30.20.31.03;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.48;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.21;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.57.55;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.11;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.22
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@/*                         V D R A W . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup librt */
/** @@{ */
/** @@file vdraw.c
 *
 * Edit vector lists and display them as pseudosolids.

OPEN COMMAND
vdraw	open			- with no argument, asks if there is
				  an open vlist (1 yes, 0 no)

		name		- opens the specified vlist
				  returns 1 if creating new vlist
					  0 if opening an existing vlist

EDITING COMMANDS - no return value

vdraw	write	i	c x y z	- write params into i-th vector
		next	c x y z	- write params to end of vector list

vdraw	insert	i	c x y z	- insert params in front of i-th vector

vdraw	delete 	i		- delete i-th vector
		last		- delete last vector on list
		all		- delete all vectors on list

PARAMETER SETTING COMMAND - no return value
vdraw	params	color		- set the current color with 6 hex digits
				  representing rrggbb
		name		- change the name of the current vlist

QUERY COMMAND
vdraw	read	i		- returns contents of i-th vector "c x y z"
		color		- return the current color in hex
		length		- return number of vectors in list
		name		- return name of current vlist

DISPLAY COMMAND -
vdraw	send			- send the current vlist to the display
				  returns 0 on success, -1 if the name
				  conflicts with an existing true solid

CURVE COMMANDS
vdraw	vlist	list		- return list of all existing vlists
		delete	name	- delete the named vlist

All textual arguments can be replaced by their first letter.
(e.g. "vdraw d a" instead of "vdraw delete all"

In the above listing:
"i" refers to an integer
"c" is an integer representing one of the following bn_vlist commands:
	 BN_VLIST_LINE_MOVE	0	/ begin new line /
	 BN_VLIST_LINE_DRAW	1	/ draw line /
	 BN_VLIST_POLY_START	2	/ pt[] has surface normal /
	 BN_VLIST_POLY_MOVE	3	/ move to first poly vertex /
	 BN_VLIST_POLY_DRAW	4	/ subsequent poly vertex /
	 BN_VLIST_POLY_END	5	/ last vert (repeats 1st), draw poly /
	 BN_VLIST_POLY_VERTNORM	6	/ per-vertex normal, for interpolation /

"x y z" refer to floating point values which represent a point or normal
	vector. For commands 0,1,3,4, and 5, they represent a point, while
	for commands 2 and 6 they represent normal vectors

author - Carl Nuzman

Example Use -
	vdraw open rays
	vdraw delete all
	foreach partition $ray {
		...stuff...
		vdraw write next 0 $inpt
		vdraw write next 1 $outpt
	}
	vdraw send

Acknowledgements:
  Modifications by Bob Parker:
	*- adapt for use in LIBRT's "Drawable Geometry" object
	*- build separate vdraw commands

********************************************************************/
/** @@} */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <signal.h>
#include "tcl.h"

#include "machine.h"
#include "cmd.h"
#include "vmath.h"
#include "mater.h"
#include "nmg.h"
#include "raytrace.h"


#ifndef M_SQRT2
#define M_SQRT2		1.41421356237309504880
#endif

#define REV_BU_LIST_FOR(p,structure,hp)	\
	(p)=BU_LIST_LAST(structure,hp);	\
	BU_LIST_NOT_HEAD(p,hp);		\
	(p)=BU_LIST_PLAST(structure,p)

/* defined in librt/dg_obj.c */
extern int dgo_invent_solid(struct dg_obj *dgop, Tcl_Interp *interp, char *name, struct bu_list *vhead, long int rgb, int copy, fastf_t transparency, int dmode);
extern void dgo_notify(struct dg_obj *dgop, Tcl_Interp *interp);

static int vdraw_write_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vdraw_insert_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vdraw_delete_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vdraw_read_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vdraw_send_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vdraw_params_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vdraw_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int vdraw_vlist_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

struct bu_cmdtab vdraw_cmds[] = {
	{"write",		vdraw_write_tcl},
	{"insert",		vdraw_insert_tcl},
	{"delete",		vdraw_delete_tcl},
	{"read",		vdraw_read_tcl},
	{"send",		vdraw_send_tcl},
	{"params",		vdraw_params_tcl},
	{"open",		vdraw_open_tcl},
	{"vlist",		vdraw_vlist_tcl},
	{(char *)0,		(int (*)())0 }
};

/*
 * Usage:
 *        write i|next c x y z
 */
static int
vdraw_write_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	int index, uind;
	struct bn_vlist *vp, *cp;

	if (!dgop->dgo_currVHead) {
		Tcl_AppendResult(interp, "vdraw write: no vlist is currently open.", (char *)NULL);
		return TCL_ERROR;
	}
	if (argc < 4) {
		Tcl_AppendResult(interp, "vdraw write: not enough args\n", (char *)NULL);
		return TCL_ERROR;
	}
	if (argv[1][0] == 'n') { /* next */
		for (REV_BU_LIST_FOR(vp, bn_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
			if (vp->nused > 0) {
				break;
			}
		}
		if (BU_LIST_IS_HEAD(vp,&(dgop->dgo_currVHead->vdc_vhd))) {
				/* we went all the way through */
			vp = BU_LIST_PNEXT(bn_vlist, vp);
			if (BU_LIST_IS_HEAD(vp,&(dgop->dgo_currVHead->vdc_vhd))) {
				RT_GET_VLIST(vp);
				BU_LIST_INSERT(&(dgop->dgo_currVHead->vdc_vhd), &(vp->l));
			}
		}
		if (vp->nused >= BN_VLIST_CHUNK) {
			vp = BU_LIST_PNEXT(bn_vlist, vp);
			if (BU_LIST_IS_HEAD(vp,&(dgop->dgo_currVHead->vdc_vhd))) {
				RT_GET_VLIST(vp);
				BU_LIST_INSERT(&(dgop->dgo_currVHead->vdc_vhd),&(vp->l));
			}
		}
		cp = vp;
		index = vp->nused;
	} else if (sscanf(argv[1], "%d", &uind) < 1) {
		Tcl_AppendResult(interp, "vdraw: write index not an integer\n", (char *)NULL);
		return TCL_ERROR;
	} else {
		/* uind holds user-specified index */
		/* only allow one past the end */

		for (BU_LIST_FOR(vp, bn_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
			if (uind < BN_VLIST_CHUNK){
				/* this is the right vlist */
				break;
			}
			if (vp->nused == 0){
				break;
			}
			uind -= vp->nused;
		}

		if (BU_LIST_IS_HEAD(vp,&(dgop->dgo_currVHead->vdc_vhd))) {
			if (uind > 0) {
				Tcl_AppendResult(interp, "vdraw: write out of range\n", (char *)NULL);
				return TCL_ERROR;
			}
			RT_GET_VLIST(vp);
			BU_LIST_INSERT(&(dgop->dgo_currVHead->vdc_vhd),&(vp->l));
		}
		if (uind > vp->nused) {
			Tcl_AppendResult(interp, "vdraw: write out of range\n", (char *)NULL);
			return TCL_ERROR;
		}
		cp = vp;
		index = uind;
	}

	if (sscanf(argv[2],"%d",&(cp->cmd[index])) < 1) {
		Tcl_AppendResult(interp, "vdraw: cmd not an integer\n", (char *)NULL);
		return TCL_ERROR;
	}
	if (argc == 6) {
		cp->pt[index][0] = atof(argv[3]);
		cp->pt[index][1] = atof(argv[4]);
		cp->pt[index][2] = atof(argv[5]);
	} else {
		if (argc != 4 ||
		    bn_decode_vect(cp->pt[index], argv[3]) != 3) {
			Tcl_AppendResult(interp,
					 "vdraw write: wrong # args, need either x y z or {x y z}\n", (char *)NULL);
			return TCL_ERROR;
		}
	}
	/* increment counter only if writing onto end */
	if (index == cp->nused)
		cp->nused++;

	return TCL_OK;
}

/*
 * Usage:
 *        insert i c x y z
 */
int
vdraw_insert_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct bn_vlist *vp, *cp, *wp;
	int i;
	int index;
	int uind;

	if (!dgop->dgo_currVHead) {
		Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
		return TCL_ERROR;
	}
	if (argc < 6) {
		Tcl_AppendResult(interp, "vdraw: not enough args", (char *)NULL);
		return TCL_ERROR;
	}
	if (sscanf(argv[2], "%d", &uind) < 1) {
		Tcl_AppendResult(interp, "vdraw: insert index not an integer\n", (char *)NULL);
		return TCL_ERROR;
	}

	/* uinds hold user specified index */
	for (BU_LIST_FOR(vp, bn_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
		if (uind < BN_VLIST_CHUNK) {
				/* this is the right vlist */
			break;
		}
		if (vp->nused == 0){
			break;
		}
		uind -= vp->nused;
	}

	if (BU_LIST_IS_HEAD(vp,&(dgop->dgo_currVHead->vdc_vhd))) {
		if (uind > 0) {
			Tcl_AppendResult(interp, "vdraw: insert out of range\n", (char *)NULL);
			return TCL_ERROR;
		}
		RT_GET_VLIST(vp);
		BU_LIST_INSERT(&(dgop->dgo_currVHead->vdc_vhd),&(vp->l));
	}
	if (uind > vp->nused) {
		Tcl_AppendResult(interp, "vdraw: insert out of range\n", (char *)NULL);
		return TCL_ERROR;
	}


	cp = vp;
	index = uind;

	vp = BU_LIST_LAST(bn_vlist, &(dgop->dgo_currVHead->vdc_vhd));
	vp->nused++;

	while (vp != cp) {
		for (i = vp->nused-1; i > 0; i--) {
			vp->cmd[i] = vp->cmd[i-1];
			VMOVE(vp->pt[i],vp->pt[i-1]);
		}
		wp = BU_LIST_PLAST(bn_vlist,vp);
		vp->cmd[0] = wp->cmd[BN_VLIST_CHUNK-1];
		VMOVE(vp->pt[0],wp->pt[BN_VLIST_CHUNK-1]);
		vp = wp;
	}

	for (i=vp->nused-1; i>index; i--) {
		vp->cmd[i] = vp->cmd[i-1];
		VMOVE(vp->pt[i],vp->pt[i-1]);
	}
	if (sscanf(argv[2],"%d",&(vp->cmd[index])) < 1) {
		Tcl_AppendResult(interp, "vdraw: cmd not an integer\n", (char *)NULL);
		return TCL_ERROR;
	}
	vp->pt[index][0] = atof(argv[3]);
	vp->pt[index][1] = atof(argv[4]);
	vp->pt[index][2] = atof(argv[5]);

	return TCL_OK;
}

/*
 * Usage:
 *        delete i|last|all
 */
int
vdraw_delete_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct bn_vlist *vp, *wp;
	int i;
	int uind;

	if (!dgop->dgo_currVHead) {
		Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
		return TCL_ERROR;
	}
	if (argc < 2) {
		Tcl_AppendResult(interp, "vdraw: not enough args\n", (char *)NULL);
		return TCL_ERROR;
	}
	if (argv[1][0] == 'a') {
		/* delete all */
		for (BU_LIST_FOR(vp, bn_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
			vp->nused = 0;
		}
		return TCL_OK;
	}
	if (argv[1][0] == 'l') {
		/* delete last */
		for (REV_BU_LIST_FOR(vp, bn_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
			if (vp->nused > 0) {
				vp->nused--;
				break;
			}
		}
		return TCL_OK;
	}
	if (sscanf(argv[1], "%d", &uind) < 1) {
		Tcl_AppendResult(interp, "vdraw: delete index not an integer\n", (char *)NULL);
		return TCL_ERROR;
	}

	for (BU_LIST_FOR(vp, bn_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
		if (uind < BN_VLIST_CHUNK) {
				/* this is the right vlist */
			break;
		}
		if ( vp->nused == 0) {
				/* no point going further */
			break;
		}
		uind -= vp->nused;
	}

	if (uind >= vp->nused) {
		Tcl_AppendResult(interp, "vdraw: delete out of range\n", (char *)NULL);
		return TCL_ERROR;
	}

	for (i = uind; i < vp->nused - 1; i++) {
		vp->cmd[i] = vp->cmd[i+1];
		VMOVE(vp->pt[i],vp->pt[i+1]);
	}

	wp = BU_LIST_PNEXT(bn_vlist, vp);
	while (BU_LIST_NOT_HEAD(wp, &(dgop->dgo_currVHead->vdc_vhd))) {
		if (wp->nused == 0) {
			break;
		}

		vp->cmd[BN_VLIST_CHUNK-1] = wp->cmd[0];
		VMOVE(vp->pt[BN_VLIST_CHUNK-1],wp->pt[0]);

		for (i=0; i< wp->nused - 1; i++) {
			wp->cmd[i] = wp->cmd[i+1];
			VMOVE(wp->pt[i],wp->pt[i+1]);
		}
		vp = wp;
		wp = BU_LIST_PNEXT(bn_vlist, vp);
	}

	if (vp->nused <= 0) {
		/* this shouldn't happen */
		Tcl_AppendResult(interp, "vdraw: vlist corrupt", (char *)NULL);
		return TCL_ERROR;
	}
	vp->nused--;

	return TCL_OK;
}

/*
 * Usage:
 *        read i|color|length|name
 */
static int
vdraw_read_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct bn_vlist *vp;
	struct bu_vls vls;
	int uind;
	int length;

	if (!dgop->dgo_currVHead) {
		Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
		return TCL_ERROR;
	}
	if (argc < 2) {
		Tcl_AppendResult(interp, "vdraw: need index to read\n", (char *)NULL);
		return TCL_ERROR;
	}
	if (argv[1][0] == 'c') {
		/* read color of current solid */
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%.6lx", dgop->dgo_currVHead->vdc_rgb);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}
	if (argv[1][0] == 'n') {
		/*read name of currently open solid*/
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%.89s", dgop->dgo_currVHead->vdc_name);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}
	if (argv[1][0] == 'l') {
		/* return lenght of list */
		length = 0;
		vp = BU_LIST_FIRST(bn_vlist, &(dgop->dgo_currVHead->vdc_vhd));
		while (!BU_LIST_IS_HEAD(vp, &(dgop->dgo_currVHead->vdc_vhd))) {
			length += vp->nused;
			vp = BU_LIST_PNEXT(bn_vlist, vp);
		}
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d", length);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	}
	if (sscanf(argv[1], "%d", &uind) < 1) {
		Tcl_AppendResult(interp, "vdraw: read index not an integer\n", (char *)NULL);
		return TCL_ERROR;
	}

	for (BU_LIST_FOR(vp, bn_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
		if (uind < BN_VLIST_CHUNK) {
				/* this is the right vlist */
			break;
		}
		if ( vp->nused == 0) {
				/* no point going further */
			break;
		}
		uind -= vp->nused;
	}

	if (uind >= vp->nused) {
		Tcl_AppendResult(interp, "vdraw: read out of range\n", (char *)NULL);
		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%d %.12e %.12e %.12e",
		vp->cmd[uind], vp->pt[uind][0],
		vp->pt[uind][1],vp->pt[uind][2]);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Usage:
 *        send
 */
static int
vdraw_send_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct directory *dp;
	struct bu_vls vls;
	char solid_name [RT_VDRW_MAXNAME+RT_VDRW_PREFIX_LEN+1];
	int index;
	int real_flag;

	if (!dgop->dgo_currVHead) {
		Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
		return TCL_ERROR;
	}

	snprintf(solid_name, RT_VDRW_MAXNAME+RT_VDRW_PREFIX_LEN+1, "%s%s", RT_VDRW_PREFIX, dgop->dgo_currVHead->vdc_name);
	if ((dp = db_lookup(dgop->dgo_wdbp->dbip, solid_name, LOOKUP_QUIET)) == DIR_NULL) {
		real_flag = 0;
	} else {
		real_flag = (dp->d_addr == RT_DIR_PHONY_ADDR) ? 0 : 1;
	}

	if (real_flag) {
		/* solid exists - don't kill */
		Tcl_AppendResult(interp, "-1", (char *)NULL);
		return TCL_OK;
	}

	/* 0 means OK, -1 means conflict with real solid name */
	index = dgo_invent_solid(dgop,
				 interp,
				 solid_name,
				 &(dgop->dgo_currVHead->vdc_vhd),
				 dgop->dgo_currVHead->vdc_rgb,
				 1, 0.0, 0);
	dgo_notify(dgop, interp);

	bu_vls_init(&vls);
	bu_vls_printf(&vls,"%d",index);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 * Usage:
 *        params color|name
 */
static int
vdraw_params_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct vd_curve *rcp;
	unsigned long rgb;

	if (!dgop->dgo_currVHead) {
		Tcl_AppendResult(interp, "vdraw: no vlist is currently open.", (char *)NULL);
		return TCL_ERROR;
	}
	if (argc < 3) {
		Tcl_AppendResult(interp, "vdraw: need params to set\n", (char *)NULL);
		return TCL_ERROR;
	}
	if (argv[1][0] == 'c') {
		if (sscanf(argv[2],"%lx", &rgb)>0)
			dgop->dgo_currVHead->vdc_rgb = rgb;
		return TCL_OK;
	}
	if (argv[1][0] == 'n') {
		/* check for conflicts with existing vlists*/
		for (BU_LIST_FOR(rcp, vd_curve, &dgop->dgo_headVDraw)) {
			if (!strncmp( rcp->vdc_name, argv[1], RT_VDRW_MAXNAME)) {
				struct bu_vls vls;

				bu_vls_init(&vls);
				bu_vls_printf(&vls, "vdraw: name %.40s is already in use\n", argv[1]);
				Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
				return TCL_ERROR;
			}
		}
		/* otherwise name not yet used */
		strncpy(dgop->dgo_currVHead->vdc_name, argv[2], RT_VDRW_MAXNAME);
		dgop->dgo_currVHead->vdc_name[RT_VDRW_MAXNAME] = '\0';
		Tcl_AppendResult(interp,"0",(char *)NULL);
		return TCL_OK;
	}

	return TCL_OK;
}

/*
 * Usage:
 *        open [name]
 */
static int
vdraw_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct vd_curve *rcp;
	struct bn_vlist *vp;
	char temp_name[RT_VDRW_MAXNAME+1];

	if (argc < 1 || 2 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib vdraw_open");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	if (argc == 1) {
		if (dgop->dgo_currVHead) {
			Tcl_AppendResult(interp, "1", (char *)NULL);
			return TCL_OK;
		} else {
			Tcl_AppendResult(interp, "0", (char *)NULL);
			return TCL_OK;
		}
	}

	strncpy(temp_name, argv[1], RT_VDRW_MAXNAME);
	temp_name[RT_VDRW_MAXNAME] = '\0';
	dgop->dgo_currVHead = (struct vd_curve *) NULL;
	for (BU_LIST_FOR(rcp, vd_curve, &dgop->dgo_headVDraw)) {
		if (!strncmp(rcp->vdc_name, temp_name, RT_VDRW_MAXNAME)) {
			dgop->dgo_currVHead = rcp;
			break;
		}
	}

	if (!dgop->dgo_currVHead) { /* create new entry */
		BU_GETSTRUCT(rcp, vd_curve);
		BU_LIST_APPEND(&dgop->dgo_headVDraw, &(rcp->l));
		strncpy(rcp->vdc_name, temp_name, RT_VDRW_MAXNAME-1);
		rcp->vdc_name[RT_VDRW_MAXNAME] = '\0';
		rcp->vdc_rgb = RT_VDRW_DEF_COLOR;
		BU_LIST_INIT(&(rcp->vdc_vhd));
		RT_GET_VLIST(vp);
		BU_LIST_APPEND(&(rcp->vdc_vhd), &(vp->l));
		dgop->dgo_currVHead = rcp;
		/* 1 means new entry */
		Tcl_AppendResult(interp, "1", (char *)NULL);
		return TCL_OK;
	} else { /* entry already existed */
		if (BU_LIST_IS_EMPTY(&(dgop->dgo_currVHead->vdc_vhd))) {
			RT_GET_VLIST(vp);
			BU_LIST_APPEND(&(dgop->dgo_currVHead->vdc_vhd), &(vp->l));
		}
		dgop->dgo_currVHead->vdc_name[RT_VDRW_MAXNAME] = '\0'; /*safety*/
		/* 0 means entry already existed*/
		Tcl_AppendResult(interp, "0", (char *)NULL);
		return TCL_OK;
	}
}

/*
 * Usage:
 *        vlist list
 *        vlist delete name
 */
static int
vdraw_vlist_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct dg_obj *dgop = (struct dg_obj *)clientData;
	struct vd_curve *rcp, *rcp2;
	struct bu_vls vls;

	if (argc < 2) {
		Tcl_AppendResult(interp,"vdraw: need more args",(char *)NULL);
		return TCL_ERROR;
	}

	switch  (argv[1][0]) {
	case 'l':
		bu_vls_init(&vls);
		for (BU_LIST_FOR(rcp, vd_curve, &dgop->dgo_headVDraw)) {
			bu_vls_strcat(&vls, rcp->vdc_name);
			bu_vls_strcat(&vls, " ");
		}

		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
		return TCL_OK;
	case 'd':
		if (argc < 3) {
			Tcl_AppendResult(interp,"vdraw: need name of vlist to delete", (char *)NULL);
			return TCL_ERROR;
		}
		rcp2 = (struct vd_curve *)NULL;
		for (BU_LIST_FOR(rcp, vd_curve, &dgop->dgo_headVDraw)) {
			if (!strncmp(rcp->vdc_name,argv[2],RT_VDRW_MAXNAME)) {
				rcp2 = rcp;
				break;
			}
		}
		if (!rcp2) {
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "vdraw: vlist %.40s not found", argv[2]);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);
			return TCL_ERROR;
		}
		BU_LIST_DEQUEUE(&(rcp2->l));
		if (dgop->dgo_currVHead == rcp2) {
			if (BU_LIST_IS_EMPTY(&dgop->dgo_headVDraw)) {
				dgop->dgo_currVHead = (struct vd_curve *)NULL;
			} else {
				dgop->dgo_currVHead = BU_LIST_LAST(vd_curve,&dgop->dgo_headVDraw);
			}
		}
		RT_FREE_VLIST(&(rcp2->vdc_vhd));
		bu_free((genptr_t) rcp2, "vd_curve");
		return TCL_OK;
	default:
		Tcl_AppendResult(interp,"vdraw: unknown option to vdraw vlist", (char *)NULL);
		return TCL_ERROR;
	}
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@minor tweaks, preventive null terminating of strncmp'd strings
@
text
@d652 1
a652 1
		strcpy(rcp->vdc_name, temp_name);
@


14.20
log
@don't need to make two calls, avoid strncat.  quell level 5 flawfinder
@
text
@d598 1
a598 1
		dgop->dgo_currVHead->vdc_name[RT_VDRW_MAXNAME] = (char)0;
d640 1
a640 1
	temp_name[RT_VDRW_MAXNAME] = (char)0;
d653 1
a653 1
		rcp->vdc_name[RT_VDRW_MAXNAME] = (char)0;
d667 1
a667 1
		dgop->dgo_currVHead->vdc_name[RT_VDRW_MAXNAME] = (char)0; /*safety*/
@


14.19
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d530 1
a530 2
	sprintf(solid_name, RT_VDRW_PREFIX);
	strncat(solid_name, dgop->dgo_currVHead->vdc_name, RT_VDRW_MAXNAME);
@


14.18
log
@NULL != 0, quell warnings
@
text
@d107 1
a107 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.17
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d603 1
a603 1
		dgop->dgo_currVHead->vdc_name[RT_VDRW_MAXNAME] = (char) NULL;
d645 1
a645 1
	temp_name[RT_VDRW_MAXNAME] = (char) NULL;
d658 1
a658 1
		rcp->vdc_name[RT_VDRW_MAXNAME] = (char) NULL;
d672 1
a672 1
		dgop->dgo_currVHead->vdc_name[RT_VDRW_MAXNAME] = (char) NULL; /*safety*/
@


14.16
log
@remove dead code
@
text
@d70 8
a77 8
"c" is an integer representing one of the following rt_vlist commands:
	 RT_VLIST_LINE_MOVE	0	/ begin new line /
	 RT_VLIST_LINE_DRAW	1	/ draw line /
	 RT_VLIST_POLY_START	2	/ pt[] has surface normal /
	 RT_VLIST_POLY_MOVE	3	/ move to first poly vertex /
	 RT_VLIST_POLY_DRAW	4	/ subsequent poly vertex /
	 RT_VLIST_POLY_END	5	/ last vert (repeats 1st), draw poly /
	 RT_VLIST_POLY_VERTNORM	6	/ per-vertex normal, for interpolation /
d167 1
a167 1
	struct rt_vlist *vp, *cp;
d178 1
a178 1
		for (REV_BU_LIST_FOR(vp, rt_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
d185 1
a185 1
			vp = BU_LIST_PNEXT(rt_vlist, vp);
d191 2
a192 2
		if (vp->nused >= RT_VLIST_CHUNK) {
			vp = BU_LIST_PNEXT(rt_vlist, vp);
d207 2
a208 2
		for (BU_LIST_FOR(vp, rt_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
			if (uind < RT_VLIST_CHUNK){
d265 1
a265 1
	struct rt_vlist *vp, *cp, *wp;
d284 2
a285 2
	for (BU_LIST_FOR(vp, rt_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
		if (uind < RT_VLIST_CHUNK) {
d312 1
a312 1
	vp = BU_LIST_LAST(rt_vlist, &(dgop->dgo_currVHead->vdc_vhd));
d320 3
a322 3
		wp = BU_LIST_PLAST(rt_vlist,vp);
		vp->cmd[0] = wp->cmd[RT_VLIST_CHUNK-1];
		VMOVE(vp->pt[0],wp->pt[RT_VLIST_CHUNK-1]);
d349 1
a349 1
	struct rt_vlist *vp, *wp;
d363 1
a363 1
		for (BU_LIST_FOR(vp, rt_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
d370 1
a370 1
		for (REV_BU_LIST_FOR(vp, rt_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
d383 2
a384 2
	for (BU_LIST_FOR(vp, rt_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
		if (uind < RT_VLIST_CHUNK) {
d405 1
a405 1
	wp = BU_LIST_PNEXT(rt_vlist, vp);
d411 2
a412 2
		vp->cmd[RT_VLIST_CHUNK-1] = wp->cmd[0];
		VMOVE(vp->pt[RT_VLIST_CHUNK-1],wp->pt[0]);
d419 1
a419 1
		wp = BU_LIST_PNEXT(rt_vlist, vp);
d440 1
a440 1
	struct rt_vlist *vp;
d472 1
a472 1
		vp = BU_LIST_FIRST(rt_vlist, &(dgop->dgo_currVHead->vdc_vhd));
d475 1
a475 1
			vp = BU_LIST_PNEXT(rt_vlist, vp);
d488 2
a489 2
	for (BU_LIST_FOR(vp, rt_vlist, &(dgop->dgo_currVHead->vdc_vhd))) {
		if (uind < RT_VLIST_CHUNK) {
d620 1
a620 1
	struct rt_vlist *vp;
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a547 13
#if 0
	{
		char *av[4];

		av[0] = "kill";
		av[1] = "-f";
		av[2] = solid_name;
		av[3] = NULL;

		(void)f_kill(clientData, interp, 3, av);
	}
#endif

@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d28 1
a28 1
	  			  an open vlist (1 yes, 0 no)
d32 1
a32 1
				          0 if opening an existing vlist
d97 1
a97 1
        *- adapt for use in LIBRT's "Drawable Geometry" object
@


14.13
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.12
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 1
/*@@{*/
d24 1
d102 1
a102 1
/*@@}*/
@


14.11
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


14.10
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d22 1
a22 1
/** \addtogroup librt */
@


14.9
log
@update copyright to 2006
@
text
@d103 1
d106 1
a115 3
#if 0
#include "tk.h"
#endif
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


14.7
log
@Doxygen changes
@
text
@d34 1
a34 1
	
d57 1
a57 1
DISPLAY COMMAND - 
d70 1
a70 1
"i" refers to an integer 
d283 1
a283 1
	} 
d326 2
a327 2
	} 
		
d369 1
a369 1
	} 
d383 1
a383 1
	}  
d396 1
a396 1
		
d406 1
a406 1
		
d501 1
a501 1
		
d508 1
a508 1
	bu_vls_printf(&vls, "%d %.12e %.12e %.12e", 
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d34 1
a34 1

d57 1
a57 1
DISPLAY COMMAND -
d70 1
a70 1
"i" refers to an integer
d283 1
a283 1
	}
d326 2
a327 2
	}

d369 1
a369 1
	}
d383 1
a383 1
	}
d396 1
a396 1

d406 1
a406 1

d501 1
a501 1

d508 1
a508 1
	bu_vls_printf(&vls, "%d %.12e %.12e %.12e",
@


14.6
log
@Add transparency and dmode parameters to dgo_invent_solid
@
text
@d21 3
d25 1
a25 2
 *
 edit vector lists and display them as pseudosolids.
d102 1
a102 1

@


14.5
log
@update copyright to 2005
@
text
@d134 1
a134 1
extern int dgo_invent_solid(struct dg_obj *dgop, Tcl_Interp *interp, char *name, struct bu_list *vhead, long int rgb, int copy);
d567 1
a567 1
				 1);
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 23
a23 3
/*******************************************************************

CMD_VDRAW - edit vector lists and display them as pseudosolids
d100 1
a102 2


d105 1
a105 1
#include <string.h>
d107 1
a107 1
#include <strings.h>
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d736 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d85 1
a85 1
#ifdef USE_STRING_H
@


1.2
log
@bye bye externs.h
@
text
@d80 1
a80 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a99 1
#include "externs.h"
@

