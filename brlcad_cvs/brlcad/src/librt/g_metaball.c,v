head	14.30;
access;
symbols
	rel-7-10-4:14.29
	STABLE:14.29.0.2
	rel-7-10-2:14.29
	rel-7-10-0:14.29
	rel-7-8-4:14.18;
locks; strict;
comment	@ * @;


14.30
date	2007.09.15.16.23.12;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.03.16.14.22.47;	author erikgreenwald;	state Exp;
branches;
next	14.28;

14.28
date	2007.03.08.19.57.39;	author erikgreenwald;	state Exp;
branches;
next	14.27;

14.27
date	2007.03.08.19.24.55;	author erikgreenwald;	state Exp;
branches;
next	14.26;

14.26
date	2007.03.07.22.02.26;	author erikgreenwald;	state Exp;
branches;
next	14.25;

14.25
date	2007.01.27.01.41.41;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.26.05.28.47;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.10.25.14.14.31;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2006.10.20.19.45.10;	author erikgreenwald;	state Exp;
branches;
next	14.18;

14.18
date	2006.10.12.14.24.55;	author erikgreenwald;	state Exp;
branches;
next	14.17;

14.17
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.16;

14.16
date	2006.08.29.17.29.36;	author erikgreenwald;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.29.17.13.35;	author erikgreenwald;	state Exp;
branches;
next	14.14;

14.14
date	2006.08.14.17.26.15;	author erikgreenwald;	state Exp;
branches;
next	14.13;

14.13
date	2006.08.11.16.50.52;	author erikgreenwald;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.04.15.46.17;	author erikgreenwald;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.03.18.06.04;	author erikgreenwald;	state Exp;
branches;
next	14.10;

14.10
date	2006.08.02.20.59.15;	author erikgreenwald;	state Exp;
branches;
next	14.9;

14.9
date	2006.08.01.20.51.00;	author erikgreenwald;	state Exp;
branches;
next	14.8;

14.8
date	2006.08.01.19.18.25;	author erikgreenwald;	state Exp;
branches;
next	14.7;

14.7
date	2006.07.26.16.42.55;	author erikgreenwald;	state Exp;
branches;
next	14.6;

14.6
date	2006.07.26.15.33.32;	author erikgreenwald;	state Exp;
branches;
next	14.5;

14.5
date	2006.07.25.20.02.10;	author erikgreenwald;	state Exp;
branches;
next	14.4;

14.4
date	2006.07.25.16.34.35;	author erikgreenwald;	state Exp;
branches;
next	14.3;

14.3
date	2006.07.19.19.29.39;	author erikgreenwald;	state Exp;
branches;
next	14.2;

14.2
date	2006.07.19.18.50.03;	author erikgreenwald;	state Exp;
branches;
next	14.1;

14.1
date	2006.07.14.15.52.24;	author erikgreenwald;	state Exp;
branches;
next	;


desc
@@


14.30
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*			G _ M E T A B A L L . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_metaball.c
 *
 * Intersect a ray with a metaball implicit surface.
 *
 * NOTICE: this primitive is incomplete and should be considered
 *	  experimental.
 *
 * Authors -
 *	Erik Greenwald <erikg@@arl.army.mil>
 *
 * Source -
 *	ARL/SLAD/SDB Bldg 238
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
/** @@} */

#ifndef lint
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.29 2007/03/16 14:22:47 erikgreenwald Exp $ (BRL)";
#endif

#include "common.h"

#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "nurb.h"
#include "rtgeom.h"
#include "wdb.h"
#include "./debug.h"


/*
 *  Algorithm:
 *	completely punted at the moment :D
 */

/* compute the bounding sphere for a metaball cluster. center is filled, and the
 * radius is returned. */
fastf_t rt_metaball_get_bounding_sphere(point_t *center, fastf_t threshold, struct bu_list *points)
{
	struct wdb_metaballpt *mbpt, *mbpt2;
	point_t min, max, d;
	fastf_t r = 0.0, dist, mag;
	int i;

	/* find a bounding box for the POINTS (NOT the surface) */
	VSETALL(min,+INFINITY);
	VSETALL(max,-INFINITY);
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, points))
		for(i=0;i<3;i++) {
			if(mbpt->coord[i] < min[i])
				min[i] = mbpt->coord[i];
			if (mbpt->coord[i] > max[i])
				max[i] = mbpt->coord[i];
		}
	/* return -1 if no points are defined. */
	if(min[X] == +INFINITY)
	    return -1;

	/* compute the center of the generated box, call that the center */
	VADD2(*center, min, max);
	VSCALE(*center, *center, 0.5);

	/* start looking for the radius... */
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, points)){
		VSUB2(d,mbpt->coord,*center);
		/* since the surface is where threshold=fldstr/mag,
		   mag=fldstr/threshold, so make that the initial value */
		dist = MAGNITUDE(d) + mbpt->fldstr/threshold;
		/* and add all the contribution */
		for(BU_LIST_FOR(mbpt2, wdb_metaballpt, points))
			if(mbpt2 != mbpt){
				fastf_t additive;
				VSUB2(d, mbpt2->coord, mbpt->coord);
				mag = MAGNITUDE(d) + dist;
				additive = (mbpt2->fldstr*mbpt2->fldstr) / mag;
				dist += additive;
			}
		/* then see if this is a 'defining' point */
		if(dist > r)
			r = dist;
	}
	return r;
}

/**
 *  			R T _ M E T A B A L L _ P R E P
 *
 * prep and build bounding volumes... unfortunately, generating the bounding
 * sphere is too 'loose' (I think) and O(n^2).
 */
int
rt_metaball_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_metaball_internal *mb, *nmb;
	struct wdb_metaballpt *mbpt, *nmbpt;
	int i;

	mb = ip->idb_ptr;
	RT_METABALL_CK_MAGIC(mb);

	/* generate a copy of the metaball */
	nmb = bu_malloc(sizeof(struct rt_metaball_internal), "rt_metaball_prep: nmb");
	nmb->magic = RT_METABALL_INTERNAL_MAGIC;
	BU_LIST_INIT( &nmb->metaball_ctrl_head );
	nmb->threshold = mb->threshold;

	/* and copy the list of control points */
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_ctrl_head)) {
		nmbpt = (struct wdb_metaballpt *)bu_malloc(sizeof(struct wdb_metaballpt), "rt_metaball_prep: nmbpt");
		nmbpt->fldstr = mbpt->fldstr;
		VMOVE(nmbpt->coord,mbpt->coord);
		BU_LIST_INSERT( &nmb->metaball_ctrl_head, &nmbpt->l );
	}

	/* find the bounding sphere */
	stp->st_aradius = rt_metaball_get_bounding_sphere(&stp->st_center, mb->threshold, &mb->metaball_ctrl_head);
	stp->st_bradius = stp->st_aradius * 1.01;
	/* generate a bounding box around the sphere...
	 * XXX this can be optimized greatly to reduce the BSP presense... */
	VSET(stp->st_min,
		stp->st_center[X] - stp->st_aradius,
		stp->st_center[Y] - stp->st_aradius,
		stp->st_center[Z] - stp->st_aradius);
	VSET(stp->st_max,
		stp->st_center[X] + stp->st_aradius,
		stp->st_center[Y] + stp->st_aradius,
		stp->st_center[Z] + stp->st_aradius);
	stp->st_specific = (void *)nmb;
	return 0;
}

/**
 *			R T _ M E T A B A L L _ P R I N T
 */
void
rt_metaball_print(register const struct soltab *stp)
{
	int metaball_count = 0;
	struct rt_metaball_internal *mb;
	struct wdb_metaballpt *mbpt;

	if(stp==NULL){ bu_log("soltab is null\n"); return; }
	mb = (struct rt_metaball_internal *)stp->st_specific;
	RT_METABALL_CK_MAGIC(mb);
	for( BU_LIST_FOR( mbpt, wdb_metaballpt, &mb->metaball_ctrl_head)) ++metaball_count;
	bu_log("Metaball with %d points and a threshold of %g (method %d)\n", metaball_count, mb->threshold, mb->method);
	metaball_count=0;
	for( BU_LIST_FOR( mbpt, wdb_metaballpt, &mb->metaball_ctrl_head))
		bu_log("\t%d: %g field strength at (%g, %g, %g)\n", ++metaball_count, mbpt->fldstr, V3ARGS(mbpt->coord));
	return;
}

/**
 *			R T _ M E T A B A L L P T _ P R I N T
 */
void
rt_metaballpt_print( const struct wdb_metaballpt *metaball, double mm2local )
{
	point_t p1;

	bu_log( "Metaball Point:\n" );
	VSCALE( p1, metaball->coord, mm2local );
	bu_log( "\tat (%g %g %g)\n", V3ARGS( p1 ) );
	bu_log( "\tfield strength = %g\n", metaball->fldstr*mm2local );
}

fastf_t
rt_metaball_point_value(point_t *p, struct bu_list *points)
{
	struct wdb_metaballpt *mbpt;
	fastf_t ret = 0.0;
	point_t v;

	for(BU_LIST_FOR(mbpt, wdb_metaballpt, points)) {
		VSUB2(v, mbpt->coord, *p);
		ret += mbpt->fldstr / MAGSQ(v);	/* f/r^2 */
	}
	return ret;
}

/*
 *  			R T _ M E T A B A L L _ S H O T
 */
int
rt_metaball_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	int stat=0, retval = 0, segsleft = abs(ap->a_onehit);
	struct rt_metaball_internal *mb = (struct rt_metaball_internal *)stp->st_specific;
	struct seg *segp = NULL;
	point_t p, inc, delta;
	fastf_t initstep = stp->st_aradius / 20.0, finalstep = stp->st_aradius / 1e8, step = initstep, distleft = (rp->r_max-rp->r_min);

	VJOIN1(p, rp->r_pt, rp->r_min, rp->r_dir);
	VSCALE(inc, rp->r_dir, step); /* assume it's normalized and we want to creep at step */

/* we hit, but not as fine-grained as we want. So back up one step, cut the
 * step size in half and start over... Note that once we're happily inside, we
 * do NOT change the step size back! */
#define STEPBACK { distleft += step; VSUB2(p, p, inc); step *= .5; VSCALE(inc,inc,.5); }
#define STEPIN(x) { --segsleft; ++retval; VSUB2(delta, p, rp->r_pt); segp->seg_##x.hit_dist = MAGNITUDE(delta); }
	while( distleft >= 0.0 ) {
		distleft -= step;
		VADD2(p, p, inc);
		if(stat == 1) {
			if(rt_metaball_point_value(&p, &mb->metaball_ctrl_head) < mb->threshold ) {
				if(step<=finalstep) {
					STEPIN(out);
					stat = 0;
					if(segsleft <= 0) {
					    return retval;
					}
				} else
					STEPBACK
			}
		} else {
			if(rt_metaball_point_value(&p, &mb->metaball_ctrl_head) > mb->threshold ) {
				if(step<=finalstep) {
					RT_GET_SEG(segp, ap->a_resource);
					segp->seg_stp = stp;
					STEPIN(in);
					segp->seg_out.hit_dist = segp->seg_in.hit_dist + .1; /* cope with silliness */
					BU_LIST_INSERT( &(seghead->l), &(segp->l) );
					if(segsleft <= 0){	/* exit now if we're one-hit (like visual rendering) */
						return retval;
					}
					/* reset the ray-walk shtuff */
					stat = 1;
					VSUB2(p, p, inc);
					VSCALE(inc, rp->r_dir, step);
					step = initstep;
				} else
					STEPBACK
			}
		}
	}
#undef STEPBACK
#undef STEPIN
	return retval;
}

/**
 *  			R T _ M E T A B A L L _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_metaball_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	struct rt_metaball_internal *mb = stp->st_specific;
	struct wdb_metaballpt *mbpt;
	vect_t v;
	fastf_t f, a;

	VSETALL(hitp->hit_normal, 0);
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_ctrl_head)){
		VSUB2(v, hitp->hit_point, mbpt->coord);
		f = mbpt->fldstr * mbpt->fldstr;	/* f^2 */
		a = MAGNITUDE(v);
		f /= (a*a*a);				/* f^2 / r^3 */
		VUNITIZE(v);
		VJOIN1(hitp->hit_normal, hitp->hit_normal, f, v);
	}
	VUNITIZE(hitp->hit_normal);
	return;
}

/**
 *			R T _ M E T A B A L L _ C U R V E
 *
 *  Return the curvature of the metaball.
 */
void
rt_metaball_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	bu_log("called rt_metaball_curve!\n");
	return;
}


/**
 *  			R T _ M E T A B A L L _ U V
 *
 *  For a hit on the surface of an METABALL, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_metaball_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	bu_log("called rt_metaball_uv!\n");
	return;
}

/**
 *			R T _ M E T A B A L L _ F R E E
 */
void
rt_metaball_free(register struct soltab *stp)
{
	/* seems to be unused? */
	bu_log("rt_metaball_free called\n");
	return;
}


/* I have no clue what this function is supposed to do */
int
rt_metaball_class(void)
{
	return RT_CLASSIFY_UNIMPLEMENTED;	/* "assume the worst" */
}


void
rt_metaball_plot_sph(struct bu_list *vhead, point_t *center, fastf_t radius)
{
	fastf_t top[16*3], middle[16*3], bottom[16*3];
	point_t a, b, c;
	int i;

	VSET(a, radius, 0, 0);
	VSET(b, 0, radius, 0);
	VSET(c, 0, 0, radius);
	rt_ell_16pts( top, *center, a, b );
	rt_ell_16pts( bottom, *center, b, c );
	rt_ell_16pts( middle, *center, a, c );

	RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ ) RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ ) RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
	RT_ADD_VLIST( vhead, &middle[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
	for( i=0; i<16; i++ ) RT_ADD_VLIST( vhead, &middle[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
}

/**
 *			R T _ M E T A B A L L _ P L O T
 */
int
rt_metaball_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	struct rt_metaball_internal *mb;
	struct wdb_metaballpt *mbpt;
	point_t bsc;
	fastf_t rad;

	RT_CK_DB_INTERNAL(ip);
	mb = (struct rt_metaball_internal *)ip->idb_ptr;
	RT_METABALL_CK_MAGIC(mb);
	rad = rt_metaball_get_bounding_sphere(&bsc, mb->threshold, &mb->metaball_ctrl_head);
	/* cope with the case where 0 points are defined. */
	if(rad<0)
	    return 0;
#if PLOT_THE_BIG_BOUNDING_SPHERE
	rt_metaball_plot_sph(vhead, &bsc, rad);
#endif
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_ctrl_head))
		rt_metaball_plot_sph(vhead, &mbpt->coord, mbpt->fldstr / mb->threshold);
	return 0;
}

/**
 *			R T _ M E T A B A L L _ T E S S
 *
 *  Tessellate a metaball.
 */
int
rt_metaball_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	bu_log("rt_metaball_tess called!\n");
	return -1;
}

/**
 *			R T _ M E T A B A L L _ I M P O R T 5
 *
 *  Import an metaball/sphere from the database format to the internal
 *  structure. Apply modeling transformations as well.
 */
int
rt_metaball_import5(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	struct wdb_metaballpt *mbpt;
	struct rt_metaball_internal *mb;
	fastf_t *buf;
	int metaball_count = 0, i;

	BU_CK_EXTERNAL( ep );
	metaball_count = bu_glong((unsigned char *)ep->ext_buf);
	buf = (fastf_t *)bu_malloc((metaball_count*4+1)*SIZEOF_NETWORK_DOUBLE,"rt_metaball_import5: buf");
	ntohd((unsigned char *)buf, (unsigned char *)ep->ext_buf+2*SIZEOF_NETWORK_LONG, metaball_count*4+1);

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_METABALL;
	ip->idb_meth = &rt_functab[ID_METABALL];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_metaball_internal), "rt_metaball_internal");
	mb = (struct rt_metaball_internal *)ip->idb_ptr;
	mb->magic = RT_METABALL_INTERNAL_MAGIC;
	mb->method = bu_glong((unsigned char *)ep->ext_buf + SIZEOF_NETWORK_LONG);
	mb->threshold = buf[0];
	BU_LIST_INIT( &mb->metaball_ctrl_head );
	if (mat == NULL) mat = bn_mat_identity;
	for(i=1; i<=metaball_count*4 ; i+=4) {
			/* Apply modeling transformations */
		BU_GETSTRUCT( mbpt, wdb_metaballpt );
		mbpt->l.magic = WDB_METABALLPT_MAGIC;
		MAT4X3PNT( mbpt->coord, mat, &buf[i] );
		mbpt->fldstr = buf[i+3] / mat[15];
		BU_LIST_INSERT( &mb->metaball_ctrl_head, &mbpt->l );
	}

	bu_free((genptr_t)buf, "rt_metaball_import5: buf");
	return 0;		/* OK */
}

/**
 *			R T _ M E T A B A L L _ E X P O R T 5
 *
 * storage is something like
 * long		numpoints
 * long		method
 * fastf_t	threshold
 *	fastf_t	X1	(start point)
 *	fastf_t	Y1
 *	fastf_t	Z1
 *	fastf_t	fldstr1 (end point)
 *	fastf_t	X2	(start point)
 *	...
 */
int
rt_metaball_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_metaball_internal *mb;
	struct wdb_metaballpt *mbpt;
	int metaball_count = 0, i = 1;
	fastf_t *buf = NULL;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_METABALL )
		return(-1);
	mb = (struct rt_metaball_internal *)ip->idb_ptr;
	RT_METABALL_CK_MAGIC(mb);
	if (mb->metaball_ctrl_head.magic == 0) return -1;

	/* Count number of points */
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_ctrl_head)) metaball_count++;

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE*(1+4*metaball_count) + 2*SIZEOF_NETWORK_LONG;
	ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes, "metaball external");
	if(ep->ext_buf == NULL)
	    bu_bomb("Failed to allocate DB space!\n");
	bu_plong((unsigned char *)ep->ext_buf, metaball_count);
	bu_plong((unsigned char *)ep->ext_buf + SIZEOF_NETWORK_LONG, mb->method);

	/* pack the point data */
	buf = (fastf_t *)bu_malloc((metaball_count*4+1)*SIZEOF_NETWORK_DOUBLE,"rt_metaball_export5: buf");
	buf[0] = mb->threshold;
	for(BU_LIST_FOR( mbpt, wdb_metaballpt, &mb->metaball_ctrl_head), i+=4){
		VSCALE(&buf[i], mbpt->coord, local2mm);
		buf[i+3] = mbpt->fldstr * local2mm;
	}
	htond((unsigned char *)ep->ext_buf + 2*SIZEOF_NETWORK_LONG, (unsigned char *)buf, 2 + 4 * metaball_count);
	bu_free((genptr_t)buf,"rt_metaball_export5: buf");
	return 0;
}

/**
 *			R T _ M E T A B A L L _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid. First line
 *  describes type of solid. Additional lines are indented one tab, and give
 *  parameter values.
 */
int
rt_metaball_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	int metaball_count = 0;
	char buf[BUFSIZ];
	struct rt_metaball_internal *mb;
	struct wdb_metaballpt *mbpt;

	RT_CK_DB_INTERNAL(ip);
	mb = (struct rt_metaball_internal *)ip->idb_ptr;
	RT_METABALL_CK_MAGIC(mb);
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_ctrl_head)) metaball_count++;

	snprintf(buf, BUFSIZ, "Metaball with %d points and a threshold of %g (method %d)\n", metaball_count, mb->threshold, mb->method);
	bu_vls_strcat(str,buf);
	if(!verbose)return 0;
	metaball_count=0;
	for( BU_LIST_FOR( mbpt, wdb_metaballpt, &mb->metaball_ctrl_head)){
		snprintf(buf,BUFSIZ,"\t%d: %g field strength at (%g, %g, %g)\n",
			++metaball_count, mbpt->fldstr, V3ARGS(mbpt->coord));
		bu_vls_strcat(str,buf);
	}
	return 0;
}

/**
 *			R T _ M E T A B A L L _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 *  This only effects the in-memory copy.
 */
void
rt_metaball_ifree(struct rt_db_internal *ip)
{
	register struct rt_metaball_internal	*metaball;
	register struct wdb_metaballpt	*mbpt;

	RT_CK_DB_INTERNAL(ip);
	metaball = (struct rt_metaball_internal*)ip->idb_ptr;
	RT_METABALL_CK_MAGIC(metaball);

	if (metaball->metaball_ctrl_head.magic != 0)
		while(BU_LIST_WHILE(mbpt, wdb_metaballpt, &metaball->metaball_ctrl_head)) {
			BU_LIST_DEQUEUE(&(mbpt->l));
			bu_free((char *)mbpt, "wdb_metaballpt");
		}
	bu_free( ip->idb_ptr, "metaball ifree" );
	ip->idb_ptr = GENPTR_NULL;
}

/**
 *			R T _ M E T A B A L L _ T N U R B
 */
int
rt_metaball_tnurb(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct bn_tol *tol)
{
	bu_log("rt_metaball_tnurb called!\n");
	return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.29
log
@disable the "big bounding sphere" in plot as it confuses users.
@
text
@d41 1
a41 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.28 2007/03/08 19:57:39 erikgreenwald Exp $ (BRL)";
d48 1
a48 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.28
log
@tweak the point eval formula a tiny bit to allow negative points
@
text
@d41 1
a41 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.27 2007/03/08 19:24:55 erikgreenwald Exp $ (BRL)";
d390 1
d392 1
@


14.27
log
@shift segment to fix method bug
@
text
@d41 1
a41 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.26 2007/03/07 22:02:26 erikgreenwald Exp $ (BRL)";
d211 1
a211 1
		ret += (mbpt->fldstr*mbpt->fldstr) / MAGSQ(v);	/* f^2/r^2 */
@


14.26
log
@reorder things in the record to keep like types together (breaks binary compatability with previous metaball primitives)
@
text
@d41 1
a41 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.25 2007/01/27 01:41:41 brlcad Exp $ (BRL)";
d425 1
a425 1
	ntohd((unsigned char *)buf, (unsigned char *)ep->ext_buf+SIZEOF_NETWORK_LONG, metaball_count*4+1);
d498 1
a498 1
	htond((unsigned char *)ep->ext_buf + SIZEOF_NETWORK_LONG, (unsigned char *)buf, 2 + 4 * metaball_count);
@


14.25
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d41 1
a41 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.24 2007/01/26 05:28:47 brlcad Exp $ (BRL)";
d424 2
a425 2
	buf = (fastf_t *)bu_malloc((metaball_count*4+2)*SIZEOF_NETWORK_DOUBLE,"rt_metaball_import5: buf");
	ntohd((unsigned char *)buf, (unsigned char *)ep->ext_buf+SIZEOF_NETWORK_LONG, metaball_count*4+2);
d434 1
a435 1
	mb->method = ((long *)buf)[1];
d438 1
a438 1
	for(i=2 ; i<=metaball_count*4 ; i+=4) {
d456 1
a457 1
 * long		method
d470 2
a471 2
	int metaball_count = 0, i = 2;
	fastf_t *buf;
d486 2
d489 1
a493 1
	((long *)buf)[1] = mb->method;
d499 1
a499 2
	bu_free(buf,"rt_metaball_export5: buf");

@


14.24
log
@allow the import function transformation matrix argument to be NULL, use an identity matrix in that situation.
@
text
@d41 1
a41 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.23 2007/01/23 01:13:37 brlcad Exp $ (BRL)";
d153 1
a153 1
	/* generate a bounding box around the sphere... 
d155 3
a157 3
	VSET(stp->st_min, 
		stp->st_center[X] - stp->st_aradius, 
		stp->st_center[Y] - stp->st_aradius, 
d159 3
a161 3
	VSET(stp->st_max, 
		stp->st_center[X] + stp->st_aradius, 
		stp->st_center[Y] + stp->st_aradius, 
d178 1
a178 1
        mb = (struct rt_metaball_internal *)stp->st_specific;
d227 1
a227 1
	
d231 1
a231 1
/* we hit, but not as fine-grained as we want. So back up one step, cut the 
d237 1
a237 1
		distleft -= step; 
d263 1
a263 1
					VSUB2(p, p, inc); 
d295 2
a296 2
		VUNITIZE(v);						
		VJOIN1(hitp->hit_normal, hitp->hit_normal, f, v);	
d298 1
a298 1
	VUNITIZE(hitp->hit_normal);					
d388 1
a388 1
	if(rad<0) 
d411 1
a411 1
 *  Import an metaball/sphere from the database format to the internal 
d474 1
a474 1
	if( ip->idb_type != ID_METABALL )  
d505 2
a506 2
 *  Make human-readable formatted presentation of this solid. First line 
 *  describes type of solid. Additional lines are indented one tab, and give 
@


14.23
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d41 1
a41 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.22 2007/01/21 04:45:43 brlcad Exp $ (BRL)";
d437 1
@


14.22
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d41 1
a41 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.21 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.21
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d24 1
d39 1
a39 1
/*@@}*/
d42 1
a42 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.20 2006/10/25 14:14:31 erikgreenwald Exp $ (BRL)";
@


14.20
log
@cope with a zero point metaball
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.19 2006/10/20 19:45:10 erikgreenwald Exp $ (BRL)";
@


14.19
log
@More print capability. Fixed missing magic in st_specific.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.18 2006/10/12 14:24:55 erikgreenwald Exp $ (BRL)";
d92 3
d389 3
@


14.18
log
@Scale sphere size against threshhold for 'plot'.
Print render method in 'describe'.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.17 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
d137 1
d172 12
a183 1
	bu_log("rt_metaball_print called\n");
d187 14
@


14.17
log
@Doxygen updates
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.16 2006/08/29 17:29:36 erikgreenwald Exp $ (BRL)";
d362 1
a362 1
		rt_metaball_plot_sph(vhead, &mbpt->coord, mbpt->fldstr);
d491 1
a491 1
	snprintf(buf, BUFSIZ, "Metaball with %d points and a threshold of %g\n", metaball_count, mb->threshold);
@


14.16
log
@fix a crash in the exporter...
@
text
@d22 1
a22 1
/** \addtogroup g */
d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.15 2006/08/29 17:13:35 erikgreenwald Exp $ (BRL)";
@


14.15
log
@Added "method" to metaball struct. Changed some language.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.14 2006/08/14 17:26:15 erikgreenwald Exp $ (BRL)";
d453 1
a453 1
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE*(2+4*metaball_count) + SIZEOF_NETWORK_LONG;
d458 1
a458 1
	buf = (fastf_t *)bu_malloc((metaball_count*4+2)*SIZEOF_NETWORK_DOUBLE,"rt_metaball_export5: buf");
@


14.14
log
@Alter point value to be f^2/r^2.
Set normalization routine to use f^2/r^3 to fix flipped normals.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.13 2006/08/11 16:50:52 erikgreenwald Exp $ (BRL)";
d75 1
a75 1
fastf_t rt_metaball_get_bounding_sphere(point_t *center, fastf_t threshhold, struct bu_list *points)
d100 3
a102 3
		/* since the surface is where threshhold=fldstr/mag,
		   mag=fldstr/threshhold, so make that the initial value */
		dist = MAGNITUDE(d) + mbpt->fldstr/threshhold;
d137 2
a138 2
	BU_LIST_INIT( &nmb->metaball_pt_head );
	nmb->threshhold = mb->threshhold;
d141 1
a141 1
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_pt_head)) {
d145 1
a145 1
		BU_LIST_INSERT( &nmb->metaball_pt_head, &nmbpt->l );
d149 1
a149 1
	stp->st_aradius = rt_metaball_get_bounding_sphere(&stp->st_center, mb->threshhold, &mb->metaball_pt_head);
d213 1
a213 1
			if(rt_metaball_point_value(&p, &mb->metaball_pt_head) < mb->threshhold ) {
d224 1
a224 1
			if(rt_metaball_point_value(&p, &mb->metaball_pt_head) > mb->threshhold ) {
d263 1
a263 1
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_pt_head)){
d359 1
a359 1
	rad = rt_metaball_get_bounding_sphere(&bsc, mb->threshhold, &mb->metaball_pt_head);
d361 1
a361 1
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_pt_head))
d394 2
a395 2
	buf = (fastf_t *)bu_malloc((metaball_count*4+1)*SIZEOF_NETWORK_DOUBLE,"rt_metaball_import5: buf");
	ntohd((unsigned char *)buf, (unsigned char *)ep->ext_buf+SIZEOF_NETWORK_LONG, metaball_count*4+1);
d404 4
a407 3
	mb->threshhold = buf[0];
	BU_LIST_INIT( &mb->metaball_pt_head );
	for(i=1 ; i<=metaball_count*4 ; i+=4) {
d413 1
a413 1
		BU_LIST_INSERT( &mb->metaball_pt_head, &mbpt->l );
d425 2
a426 1
 * fastf_t	threshhold
d439 1
a439 1
	int metaball_count = 0, i = 1;
d447 1
a447 1
	if (mb->metaball_pt_head.magic == 0) return -1;
d450 1
a450 1
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_pt_head)) metaball_count++;
d453 1
a453 1
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE*(1+4*metaball_count) + SIZEOF_NETWORK_LONG;
d458 4
a461 3
	buf = (fastf_t *)bu_malloc((metaball_count*4+1)*SIZEOF_NETWORK_DOUBLE,"rt_metaball_export5: buf");
	buf[0] = mb->threshhold;
	for(BU_LIST_FOR( mbpt, wdb_metaballpt, &mb->metaball_pt_head), i+=4){
d465 1
a465 1
	htond((unsigned char *)ep->ext_buf + SIZEOF_NETWORK_LONG, (unsigned char *)buf, 1 + 4 * metaball_count);
d489 1
a489 1
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_pt_head)) metaball_count++;
d491 1
a491 1
	snprintf(buf, BUFSIZ, "Metaball with %d points and a threshhold of %g\n", metaball_count, mb->threshhold);
d495 1
a495 1
	for( BU_LIST_FOR( mbpt, wdb_metaballpt, &mb->metaball_pt_head)){
d519 2
a520 2
	if (metaball->metaball_pt_head.magic != 0)
		while(BU_LIST_WHILE(mbpt, wdb_metaballpt, &metaball->metaball_pt_head)) {
@


14.13
log
@minor clean, and changed some logic in shot to fix a memory leak.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.12 2006/08/04 15:46:17 erikgreenwald Exp $ (BRL)";
d109 1
a109 1
				additive = mbpt2->fldstr / mag;
d260 1
a260 1
	fastf_t f;
d264 6
a269 4
		VSUB2(v, mbpt->coord, hitp->hit_point);
		f = mbpt->fldstr / MAGSQ(v);
		VUNITIZE(v);
		VJOIN1(hitp->hit_normal, hitp->hit_normal, f, v);
d271 1
a271 1
	VUNITIZE(hitp->hit_normal);
@


14.12
log
@Fixed point value function (f^2/r^2 instead of f/r^2).  Fixed steppers
"dist left" concept. (those two fix 'large' object rendering). Renamed
and deleted variables for readability.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.11 2006/08/03 18:06:04 erikgreenwald Exp $ (BRL)";
a194 2
	struct rt_metaball_internal *mb;
	point_t p, inc;
d196 4
a199 4
	register struct seg *segp = NULL;
	fastf_t initstep = stp->st_aradius / 20.0, finalstep = stp->st_aradius / 1e8;
	fastf_t step = initstep;
	fastf_t distleft = (rp->r_max-rp->r_min);
a200 1
	mb = (struct rt_metaball_internal *)stp->st_specific;
d204 7
a210 1
	while( (distleft -= step) > 0.0 ) {
d212 1
a212 1
		if(stat) {
d215 7
a221 15
					point_t delta;
					VSUB2(delta, p, rp->r_pt);
					segp->seg_out.hit_dist = sqrt(MAGSQ(delta));
					BU_LIST_INSERT( &(seghead->l), &(segp->l) );
					--segsleft;
					if(!segsleft)
					    break;
					retval = 2;
					continue;
				} else {
					distleft += step;
					VSUB2(p, p, inc); 
					step *= .5;
					VSCALE(inc,inc,.5);
				}
a225 4
					point_t delta;

					--segsleft;
					VSUB2(delta, p, rp->r_pt);
d228 5
a232 5
					segp->seg_in.hit_dist = sqrt(MAGSQ(delta));
					if(!segsleft){	/* exit now if we're one-hit (like visual rendering) */
						segp->seg_out.hit_dist = segp->seg_in.hit_dist + .1; /* cope with silliness */
						BU_LIST_INSERT( &(seghead->l), &(segp->l) );
						return 2;
d235 1
a235 1
					++stat;
d239 2
a240 11
				} else {
					/* we hit, but not as fine-grained as we
					 * want. So back up one step, cut the step
					 * size in half and start over... Note that
					 * once we're happily inside, we do NOT
					 * change the step size back! */
					distleft += step;
					VSUB2(p, p, inc); 
					step *= .5;
					VSCALE(inc,inc,.5);
				}
d244 2
@


14.11
log
@Major fixes to bounding sphere generation.
Break bigger functions down a bit for reuse and easier reading.
Draw the bounding sphere in rt_metaball_plot (may be backed out later).
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.10 2006/08/02 20:59:15 erikgreenwald Exp $ (BRL)";
d80 1
a80 1
	int i, cnt = 0;
a98 1
		cnt++;
d149 2
a150 2
	stp->st_aradius = stp->st_bradius = rt_metaball_get_bounding_sphere(&stp->st_center, mb->threshhold, &mb->metaball_pt_head);

d184 1
a184 1
		ret += mbpt->fldstr / MAGSQ(v);
d199 1
a199 1
	fastf_t initstep = stp->st_bradius / 20, finalstep = stp->st_bradius / 10000000000.0;
d201 1
a201 1
	fastf_t i = (rp->r_max-rp->r_min)/step;
d204 1
a204 1
	VMOVE(p, rp->r_pt);
d207 1
a207 1
	while( (i -= step) > 0.0 ) {
d222 1
a222 1
					i += step;
d254 1
a254 1
					i += step;
@


14.10
log
@Implemented rt_metaball_class. Fixed a_onehit handling in rt_metaball_shot.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.9 2006/08/01 20:51:00 erikgreenwald Exp $ (BRL)";
d70 1
a70 1
 *
d73 46
d130 1
a130 3
	struct wdb_metaballpt *mbpt, *mbpt2, *nmbpt;
	point_t p, max, min;
	fastf_t r = 0.0;
a132 1
	VSETALL(p,0);
d135 2
d140 3
a142 1
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_pt_head)){
a146 5
		for(i=0;i<3;i++)
			if(mbpt->coord[i] < min[i])
				min[i] = mbpt->coord[i];
			else if (mbpt->coord[i] > max[i])
				max[i] = mbpt->coord[i];
a147 4
	VADD2(stp->st_center,min,max);
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_pt_head)){
		point_t d;
		fastf_t dist;
d149 2
a150 5
		VSUB2(d,mbpt->coord,p);
		dist = MAGSQ(d) + mb->threshhold/mbpt->fldstr;
		for(BU_LIST_FOR(mbpt2, wdb_metaballpt, &mb->metaball_pt_head))
			if(mbpt2 != mbpt){
				fastf_t mag;
d152 10
a161 12
				VSUB2(d, mbpt2->coord, mbpt->coord);
				mag = MAGSQ(d);
				dist += mbpt2->fldstr / (mag>.001?mag:1.0);
			}
		if(dist > r)
			r = dist;
	}
	r = sqrt(r);
	stp->st_aradius = r;
	stp->st_bradius = r;
	VSET(stp->st_min, p[X]-r, p[Y]-r, p[Z]-r);
	VSET(stp->st_max, p[X]+r, p[Y]+r, p[Z]+r);
d337 23
d368 2
a369 5
	fastf_t top[16*3];
	fastf_t middle[16*3];
	fastf_t bottom[16*3];
	point_t a, b, c;
	int i;
d374 4
a377 25
	for(BU_LIST_FOR(mbpt, wdb_metaballpt, &mb->metaball_pt_head)) {
		/* the fldstr may need to be amped up to better approximate? */
		VSET(a, mbpt->fldstr, 0, 0);
		VSET(b, 0, mbpt->fldstr, 0);
		VSET(c, 0, 0, mbpt->fldstr);
		rt_ell_16pts( top, mbpt->coord, a, b );
		rt_ell_16pts( bottom, mbpt->coord, b, c );
		rt_ell_16pts( middle, mbpt->coord, a, c );

		RT_ADD_VLIST( vhead, &top[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
		for( i=0; i<16; i++ )  {
			RT_ADD_VLIST( vhead, &top[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
		}

		RT_ADD_VLIST( vhead, &bottom[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
		for( i=0; i<16; i++ )  {
			RT_ADD_VLIST( vhead, &bottom[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
		}

		RT_ADD_VLIST( vhead, &middle[15*ELEMENTS_PER_VECT], BN_VLIST_LINE_MOVE );
		for( i=0; i<16; i++ )  {
			RT_ADD_VLIST( vhead, &middle[i*ELEMENTS_PER_VECT], BN_VLIST_LINE_DRAW );
		}
	}

@


14.9
log
@Shoot all the way through if ap->a_onehit is not true (opposed to through the first in/out pair).
Apply the 'stepping' optimization to walking after the first hit.
Minor cleanup for -Wall -Werror -ansi -pedantic.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.8 2006/08/01 19:18:25 erikgreenwald Exp $ (BRL)";
d165 1
a165 1
	int stat=0, retval = 0;
d184 3
d200 2
d206 2
a207 1
					if(ap->a_onehit){	/* exit now if we're one-hit (like visual rendering) */
d297 1
d301 1
a301 2
	bu_log("rt_metaball_class called\n");
	return 0;
@


14.8
log
@Drastically improved bounding sphere computation (better center and fit).
Fix for 'garbage' normals resulting in noisy images in some situations.
Obey the 'one-hit' flag in the shot routine.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.7 2006/07/26 16:42:55 erikgreenwald Exp $ (BRL)";
d143 1
a143 1
inline HIDDEN fastf_t
a146 1
	struct rt_metaball_internal *mb;
a148 1
	int metaball_count = 0;
d165 1
a165 2
	int stat=0;
	struct wdb_metaballpt *mbpt;
d167 1
a167 1
	fastf_t initstep = stp->st_bradius / 20, finalstep = stp->st_bradius / 1000000.0;
a170 1

d179 1
d184 8
a191 1
					return 2;		/* hit */
d201 1
a201 2
					++stat;
					if(ap->a_onehit){
d205 5
d224 1
a224 1
	return 0; /* miss */
d366 1
a366 1
	fastf_t *buf, threshhold;
@


14.7
log
@Initial plot impl.
Removed the 16pt stub (use ell's instead).
Minor indentation cleanup.
@
text
@d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.6 2006/07/26 15:33:32 erikgreenwald Exp $ (BRL)";
d85 3
a87 2
	point_t p;
	fastf_t cnt = 0.0, r = 0.0;
d89 1
a89 1
	VSET(p,0,0,0);
d100 5
a104 2
		cnt++;
		VJOIN1(p,p,mbpt->fldstr,mbpt->coord);
d106 1
a106 2
	VSCALE(p,p,-cnt);
	VMOVE(stp->st_center, p);
d114 2
a115 2
		if(mbpt2 != mbpt){
			fastf_t mag;
d117 4
a120 4
			VSUB2(d, mbpt2->coord, mbpt->coord);
			mag = MAGSQ(d);
			dist += mbpt2->fldstr / (mag>.00001?mag:1.0);
		}
d122 1
a122 1
		r = dist;
d124 1
d170 1
a170 31
#if 0
	const static fastf_t step = .01;
	fastf_t i = (rp->r_max-rp->r_min)/step;

	mb = (struct rt_metaball_internal *)stp->st_specific;
	VMOVE(p, rp->r_pt);
	VSCALE(inc, rp->r_dir, step); /* assume it's normalized and we want to creep at step */

	while( (i -= step) > 0.0 ) {
		VADD2(p, p, inc);
		if(stat) {
			if(rt_metaball_point_value(&p, &mb->metaball_pt_head) < mb->threshhold ) {
				point_t delta;
				VSUB2(delta, p, rp->r_pt);
				segp->seg_out.hit_dist = sqrt(MAGSQ(delta));
				BU_LIST_INSERT( &(seghead->l), &(segp->l) );
				return 2;		/* hit */
			}
		} else {
			if(rt_metaball_point_value(&p, &mb->metaball_pt_head) > mb->threshhold ) {
				point_t delta;
				VSUB2(delta, p, rp->r_pt);
				RT_GET_SEG(segp, ap->a_resource);
				segp->seg_stp = stp;
				segp->seg_in.hit_dist = sqrt(MAGSQ(delta));
				++stat;
			}
		}
	}
#else
	const static fastf_t initstep = .2, finalstep = .01;
d173 1
d183 5
a187 5
				point_t delta;
				VSUB2(delta, p, rp->r_pt);
				segp->seg_out.hit_dist = sqrt(MAGSQ(delta));
				BU_LIST_INSERT( &(seghead->l), &(segp->l) );
				return 2;		/* hit */
d198 4
a212 1
					
a215 1
#endif
d232 1
d312 1
a312 1
		rt_ell_16pts( top,    mbpt->coord, a, b );
@


14.6
log
@minor shot hack for performance, with a tweaked up "final step", this is about 104x faster on my test case
@
text
@d1 1
a1 1
/*                    G _ M E T A B A L L . C
d28 2
a29 3
 *      NOTICE: this primitive is incomplete and should beconsidered
 *              experimental.  this primitive will exhibit several
 *              instabilities in the existing root solver method.
d31 2
d34 1
a34 4
 *  Authors -
 *      Erik Greenwald <erikg@@arl.army.mil>
 *
 *  Source -
d43 1
a43 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.5 2006/07/25 20:02:10 erikgreenwald Exp $ (BRL)";
d105 2
a106 2
	    point_t d;
	    fastf_t dist;
d108 3
a110 3
	    VSUB2(d,mbpt->coord,p);
	    dist = MAGSQ(d) + mb->threshhold/mbpt->fldstr;
	    for(BU_LIST_FOR(mbpt2, wdb_metaballpt, &mb->metaball_pt_head))
d112 1
a112 1
		    fastf_t mag;
d114 3
a116 3
		    VSUB2(d, mbpt2->coord, mbpt->coord);
		    mag = MAGSQ(d);
		    dist += mbpt2->fldstr / (mag>.00001?mag:1.0);
d118 1
a118 1
	    if(dist > r)
d136 1
a136 1
    return;
d234 1
a234 1
				    
d273 2
a274 2
  bu_log("called rt_metaball_curve!\n");
  return;
d289 2
a290 2
  bu_log("called rt_metaball_uv!\n");
  return;
a311 14

/**
 *			R T _ M E T A B A L L _ 1 6 P T S
 *
 * Also used by the TGC code
 */
#define METABALLOUT(n)	ov+(n-1)*3
void
rt_metaball_16pts(register fastf_t *ov, register fastf_t *V, fastf_t *A, fastf_t *B)
{
	bu_log("rt_metaball_16pts called\n");
	return;
}

d318 36
a353 1
	bu_log("rt_metaball_plot called\n");
d365 2
a366 2
  bu_log("rt_metaball_tess called!\n");
  return -1;
d433 1
a433 1
	    return(-1);
d484 3
a486 3
	    snprintf(buf,BUFSIZ,"\t%d: %g field strength at (%g, %g, %g)\n",
		    ++metaball_count, mbpt->fldstr, V3ARGS(mbpt->coord));
	    bu_vls_strcat(str,buf);
d508 4
a511 4
	    while(BU_LIST_WHILE(mbpt, wdb_metaballpt, &metaball->metaball_pt_head))  {
		BU_LIST_DEQUEUE(&(mbpt->l));
		bu_free((char *)mbpt, "wdb_metaballpt");
	    }
@


14.5
log
@Fixed the prep so it has 'real' bounding volume generation.
Change the STEP define to a step var in preparation for a possible optimization.
@
text
@d45 1
a45 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.4 2006/07/25 16:34:35 erikgreenwald Exp $ (BRL)";
a164 2
	const static fastf_t step = .05;
	fastf_t i = (rp->r_max-rp->r_min)/step;
d168 3
d180 3
a182 1
				segp->seg_out.hit_dist = (rp->r_max-rp->r_min)/step - i;
d188 2
d192 1
a192 1
				segp->seg_in.hit_dist = (rp->r_max-rp->r_min)/step - i;
d197 44
@


14.4
log
@Prep, render, shot, and normal implemented (but quite slow).
Fixed an offset bug in the import5 func.
@
text
@d45 1
a45 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.3 2006/07/19 19:29:39 erikgreenwald Exp $ (BRL)";
d78 3
d86 5
a90 2
	struct wdb_metaballpt *mbpt, *nmbpt;
	
a92 5
	VSET(stp->st_min, -4, -4, -4);
	VSET(stp->st_max, 4, 4, 4);
	VSET(stp->st_center, 0, 0, 0);
	stp->st_aradius = 4;
	stp->st_bradius = 4;
d101 21
d123 4
d165 2
a166 2
#define STEP .05
	fastf_t i = (rp->r_max-rp->r_min)/STEP;
d173 1
a173 1
	VSCALE(inc, rp->r_dir, STEP); /* assume it's normalized and we want to creep at STEP */
d175 1
a175 1
	while( (i-=STEP) > 0.0 ) {
d179 1
a179 1
				segp->seg_out.hit_dist = (rp->r_max-rp->r_min)/STEP - i;
d187 1
a187 1
				segp->seg_in.hit_dist = (rp->r_max-rp->r_min)/STEP - i;
a191 1
#undef STEP
@


14.3
log
@minor bugfix, implemented "describe" and "ifree"
@
text
@d45 1
a45 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.2 2006/07/19 18:50:03 erikgreenwald Exp $ (BRL)";
d82 21
a102 2
	bu_log("rt_metaball_prep called\n");
  return 0;			/* OK */
d115 16
d137 31
a167 2
	bu_log("rt_metaball_shot called\n");
  return 1;
d178 13
a190 2
	bu_log("rt_metaball_norm called\n");
  return;
d304 1
a304 1
	for(i=0 ; i<metaball_count*4 ; i+=4) {
@


14.2
log
@v5 import/export implemented. Removed v4 stubs. Made all stubs log.
@
text
@d45 1
a45 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.1 2006/07/14 15:52:24 erikgreenwald Exp $ (BRL)";
a117 1

d152 1
d204 2
a205 3
 *  Import an metaball/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as wmetaball.
d224 1
a224 1
	ip->idb_ptr = bu_malloc( sizeof(struct rt_pipe_internal), "rt_metaball_internal");
d226 1
d244 1
d294 3
a296 3
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
d301 19
a319 1
	bu_log("rt_metaball_describe called\n");
d327 1
d332 14
a345 1
	bu_log("rt_metaball_ifree called\n");
@


14.1
log
@initial metaball support (skeletal)
@
text
@d45 1
a45 1
static const char RCSmetaball[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_metaball.c,v 14.15 2006/01/22 23:37:39 brlcad Exp $ (BRL)";
d66 1
d82 1
d92 1
d102 1
d114 1
d153 2
a154 1
    return;
d161 1
d175 1
d185 1
a201 22
 *			R T _ M E T A B A L L _ I M P O R T
 *
 *  Import an metaball/sphere from the database format to
 *  the internal structure.
 *  Apply modeling transformations as wmetaball.
 */
int
rt_metaball_import(struct rt_db_internal *ip, const struct bu_external *ep, register const fastf_t *mat, const struct db_i *dbip)
{
	return 0;		/* OK */
}

/**
 *			R T _ M E T A B A L L _ E X P O R T
 */
int
rt_metaball_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	return 0;
}

/**
d211 28
d244 9
a252 6
 *
 *  The external format is:
 *	V point
 *	A vector
 *	B vector
 *	C vector
d257 30
d300 1
d312 1
d321 1
a321 1
  bu_log("rt_metaball_tnurb called!\n");
@

