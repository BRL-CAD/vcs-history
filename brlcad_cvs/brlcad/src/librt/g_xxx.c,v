head	14.22;
access;
symbols
	rel-7-10-4:14.20
	STABLE:14.20.0.2
	stable-branch:14.6
	rel-7-10-2:14.20
	rel-7-10-0:14.19
	rel-7-8-4:14.14
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.22
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.11.28.14.11.28;	author erikgreenwald;	state Exp;
branches;
next	14.20;

14.20
date	2007.07.26.01.13.57;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.27.01.41.41;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.26.05.28.48;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.21.04.45.44;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.09.16.02.04.25;	author lbutler;	state Exp;
branches;
next	14.13;

14.13
date	2006.08.08.05.15.24;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.07.06.17.38.08;	author erikgreenwald;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.12.08.01.18.48;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.11.24.14.28.22;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.31.00;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.03;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.22
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                         G _ X X X . C
 * BRL-CAD
 *
 * Copyright (c) 1990-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_xxx.c
 *
 *	Intersect a ray with a.
 *
 * Adding a new solid type:
 *	Design disk record
 *
 *	define rt_xxx_internal --- parameters for solid
 *	define xxx_specific --- raytracing form, possibly w/precomuted terms
 *	define rt_xxx_parse --- struct bu_structparse for "db get", "db adjust", ...
 *
 *	code import/export/describe/print/ifree/plot/prep/shot/curve/uv/tess
 *
 *	edit db.h add solidrec s_type define
 *	edit rtgeom.h to add rt_xxx_internal
 *	edit table.c:
 *		RT_DECLARE_INTERFACE()
 *		struct rt_functab entry
 *		rt_id_solid()
 *	edit raytrace.h to make ID_XXX, increment ID_MAXIMUM
 *	edit db_scan.c to add the new solid to db_scan()
 *	edit Makefile.am to add g_xxx.c to compile
 *
 *	Then:
 *	go to src/libwdb and create mk_xxx() routine
 *	go to src/conv and edit g2asc.c and asc2g.c to support the new solid
 *	go to src/librt and edit tcl.c to add the new solid to
 *		rt_solid_type_lookup[]
 *		also add the interface table and to rt_id_solid() in table.c
 *	go to src/mged and create the edit support
 *
 *  Authors -
 *
 */
/** @@} */

#include "common.h"

/* system headers */
#include <stdio.h>
#include <math.h>

/* interface headers */
#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "raytrace.h"
#include "rtgeom.h"

/* local headers */
#include "./debug.h"


#if 0
/* parameters for solid, internal representation
 * This goes in rtgeom.h
 */
/* parameters for solid, internal representation */
struct rt_xxx_internal {
	long	magic;
	vect_t	v;
};
#  define RT_XXX_INTERNAL_MAGIC	0xxx
#  define RT_XXX_CK_MAGIC(_p)	BU_CKMAG(_p,RT_XXX_INTERNAL_MAGIC,"rt_xxx_internal")
#endif

/* ray tracing form of solid, including precomputed terms */
struct xxx_specific {
	vect_t	xxx_V;
};


/**
 *  			R T _ X X X _ P R E P
 *
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid XXX, and if so, precompute various
 *  terms of the formula.
 *
 *  Returns -
 *  	0	XXX is OK
 *  	!0	Error in description
 *
 *  Implicit return -
 *  	A struct xxx_specific is created, and it's address is stored in
 *  	stp->st_specific for use by xxx_shot().
 */
int
rt_xxx_prep( struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip )
{
	struct rt_xxx_internal		*xxx_ip;
	register struct xxx_specific	*xxx;
	const struct bn_tol		*tol = &rtip->rti_tol;

	RT_CK_DB_INTERNAL(ip);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);
}

/**
 *			R T _ X X X _ P R I N T
 */
void
rt_xxx_print( const struct soltab *stp )
{
	register const struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;
}

/**
 *  			R T _ X X X _ S H O T
 *
 *  Intersect a ray with a xxx.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_xxx_shot( struct soltab *stp, struct xray *rp, struct application *ap, struct seg *seghead )
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;
	register struct seg *segp;
	const struct bn_tol	*tol = &ap->a_rt_i->rti_tol;

	return(0);			/* MISS */
}

#define RT_XXX_SEG_MISS(SEG)	(SEG).seg_stp=RT_SOLTAB_NULL

/**
 *			R T _ X X X _ V S H O T
 *
 *  Vectorized version.
 */
void
rt_xxx_vshot(struct soltab *stp[],	/* An array of solid pointers */
	     struct xray *rp[],		/* An array of ray pointers */
	     struct seg segp[],		/* array of segs (results returned) */
	     int n,			/* Number of ray/object pairs */
	     struct application *ap)
{
	rt_vstub( stp, rp, segp, n, ap );
}

/**
 *  			R T _ X X X _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_xxx_norm( struct hit *hitp, struct soltab *stp, struct xray *rp )
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
}

/**
 *			R T _ X X X _ C U R V E
 *
 *  Return the curvature of the xxx.
 */
void
rt_xxx_curve( struct curvature *cvp, struct hit *hitp, struct soltab *stp )
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;

	cvp->crv_c1 = cvp->crv_c2 = 0;

	/* any tangent direction */
	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/**
 *  			R T _ X X X _ U V
 *
 *  For a hit on the surface of an xxx, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_xxx_uv( struct application *ap, struct soltab *stp, struct hit *hitp, struct uvcoord *uvp )
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;
}

/**
 *		R T _ X X X _ F R E E
 */
void
rt_xxx_free( struct soltab *stp )
{
	register struct xxx_specific *xxx =
		(struct xxx_specific *)stp->st_specific;

	bu_free( (char *)xxx, "xxx_specific" );
}

/**
 *			R T _ X X X _ C L A S S
 */
int
rt_xxx_class( const struct soltab *stp, const vect_t min, const vect_t max, const struct bn_tol *tol )
{
	return RT_CLASSIFY_UNIMPLEMENTED;
}

/**
 *			R T _ X X X _ P L O T
 */
int
rt_xxx_plot( struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol )
{
	struct rt_xxx_internal	*xxx_ip;

	RT_CK_DB_INTERNAL(ip);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);

	return(-1);
}

/**
 *			R T _ X X X _ T E S S
 *
 *  Returns -
 *	-1	failure
 *	 0	OK.  *r points to nmgregion that holds this tessellation.
 */
int
rt_xxx_tess( struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol )
{
	struct rt_xxx_internal	*xxx_ip;

	RT_CK_DB_INTERNAL(ip);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);

	return(-1);
}

/**
 *			R T _ X X X _ I M P O R T
 *
 *  Import an XXX from the database format to the internal format.
 *  Apply modeling transformations as well.
 */
int
rt_xxx_import( struct rt_db_internal *ip, const struct bu_external *ep, const mat_t mat, const struct db_i *dbip )
{
	struct rt_xxx_internal	*xxx_ip;
	union record			*rp;

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	/* Check record type */
	if( rp->u_id != ID_SOLID )  {
		bu_log("rt_xxx_import: defective record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_XXX;
	ip->idb_meth = &rt_functab[ID_XXX];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_xxx_internal), "rt_xxx_internal");
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	xxx_ip->magic = RT_XXX_INTERNAL_MAGIC;

	if (mat == NULL) mat = bn_mat_identity;
	MAT4X3PNT( xxx_ip->xxx_V, mat, &rp->s.s_values[0] );

	return(0);			/* OK */
}

/**
 *			R T _ X X X _ E X P O R T
 *
 *  The name is added by the caller, in the usual place.
 */
int
rt_xxx_export( struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip )
{
	struct rt_xxx_internal	*xxx_ip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_XXX )  return(-1);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "xxx external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = XXX;	/* GED primitive type from db.h */

	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */


	/* convert from local editing units to mm and export
	 * to database record format
	 *
	 * Warning: type conversion: double to float
	 */
	VSCALE( &rec->s.s_values[0], xxx_ip->xxx_V, local2mm );
	rec->s.s_values[3] = xxx_ip->xxx_radius * local2mm;

	return(0);
}


/**
 *			R T _ X X X _ I M P O R T 5
 *
 *  Import an XXX from the database format to the internal format.
 *  Note that the data read will be in network order.  This means
 *  Big-Endian integers and IEEE doubles for floating point.
 *
 *  Apply modeling transformations as well.
 *
 */
int
rt_xxx_import5( struct rt_db_internal  *ip, const struct bu_external *ep, const mat_t mat, const struct db_i *dbip )
{
	struct rt_xxx_internal	*xxx_ip;
	fastf_t				vv[ELEMENTS_PER_VECT*1];

	RT_CK_DB_INTERNAL(ip)
	BU_CK_EXTERNAL( ep );

	BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 3*4 );

	/* set up the internal structure */
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_XXX;
	ip->idb_meth = &rt_functab[ID_XXX];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_xxx_internal), "rt_xxx_internal");
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	xxx_ip->magic = RT_XXX_INTERNAL_MAGIC;

	/* Convert the data in ep->ext_buf into internal format.
	 * Note the conversion from network data
	 * (Big Endian ints, IEEE double floating point) to host local data
	 * representations.
	 */
	ntohd( (unsigned char *)&vv, (char *)ep->ext_buf, ELEMENTS_PER_VECT*1 );

	/* Apply the modeling transformation */
	if (mat == NULL) mat = bn_mat_identity;
	MAT4X3PNT( xxx_ip->v, mat, vv );

	return(0);			/* OK */
}

/**
 *			R T _ X X X _ E X P O R T 5
 *
 *  Export an XXX from internal form to external format.
 *  Note that this means converting all integers to Big-Endian format
 *  and floating point data to IEEE double.
 *
 *  Apply the transformation to mm units as well.
 */
int
rt_xxx_export5( struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip )
{
	struct rt_xxx_internal	*xxx_ip;
	fastf_t			vec[ELEMENTS_PER_VECT];

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_XXX )  return(-1);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = SIZEOF_NETWORK_DOUBLE * ELEMENTS_PER_VECT;
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "xxx external");


	/* Since libwdb users may want to operate in units other
	 * than mm, we offer the opportunity to scale the solid
	 * (to get it into mm) on the way out.
	 */
	VSCALE( vec, xxx_ip->v, local2mm );

	/* Convert from internal (host) to database (network) format */
	htond( ep->ext_buf, (unsigned char *)vec, ELEMENTS_PER_VECT*1 );

	return 0;
}

/**
 *			R T _ X X X _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_xxx_describe( struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local )
{
	register struct rt_xxx_internal	*xxx_ip =
		(struct rt_xxx_internal *)ip->idb_ptr;
	char	buf[256];

	RT_XXX_CK_MAGIC(xxx_ip);
	bu_vls_strcat( str, "truncated general xxx (XXX)\n");

	sprintf(buf, "\tV (%g, %g, %g)\n",
		INTCLAMP(xxx_ip->v[X] * mm2local),
		INTCLAMP(xxx_ip->v[Y] * mm2local),
		INTCLAMP(xxx_ip->v[Z] * mm2local) );
	bu_vls_strcat( str, buf );

	return(0);
}

/**
 *			R T _ X X X _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_xxx_ifree( struct rt_db_internal *ip )
{
	register struct rt_xxx_internal	*xxx_ip;

	RT_CK_DB_INTERNAL(ip);
	xxx_ip = (struct rt_xxx_internal *)ip->idb_ptr;
	RT_XXX_CK_MAGIC(xxx_ip);
	xxx_ip->magic = 0;			/* sanity */

	bu_free( (char *)xxx_ip, "xxx ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/**
 *			R T _ X X X _ X F O R M
 *
 *  Create transformed version of internal form.  Free *ip if requested.
 *  Implement this if it's faster than doing an export/import cycle.
 */
int
rt_xxx_xform( struct rt_db_internal *op, const mat_t mat, struct rt_db_internal *ip, int free )
{
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@LOCAL->static, per machine.h deprecation list
@
text
@a57 4
#ifndef lint
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.20 2007/07/26 01:13:57 brlcad Exp $ (BRL)";
#endif

d244 1
a244 1
	static struct rt_xxx_internal	*xxx_ip;
d263 1
a263 1
	static struct rt_xxx_internal	*xxx_ip;
d281 1
a281 1
	static struct rt_xxx_internal	*xxx_ip;
d361 1
a361 1
	static struct rt_xxx_internal	*xxx_ip;
@


14.20
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d59 1
a59 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.19 2007/01/27 01:41:41 brlcad Exp $ (BRL)";
d248 1
a248 1
	LOCAL struct rt_xxx_internal	*xxx_ip;
d267 1
a267 1
	LOCAL struct rt_xxx_internal	*xxx_ip;
d285 1
a285 1
	LOCAL struct rt_xxx_internal	*xxx_ip;
d365 1
a365 1
	LOCAL struct rt_xxx_internal	*xxx_ip;
@


14.19
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a54 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d59 1
a59 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.18 2007/01/26 05:28:48 brlcad Exp $ (BRL)";
@


14.18
log
@allow the import function transformation matrix argument to be NULL, use an identity matrix in that situation.
@
text
@d64 1
a64 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.17 2007/01/23 01:13:37 brlcad Exp $ (BRL)";
d205 1
a205 1
 	cvp->crv_c1 = cvp->crv_c2 = 0;
d208 1
a208 1
 	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
a356 1

@


14.17
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d64 1
a64 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.16 2007/01/21 04:45:44 brlcad Exp $ (BRL)";
d309 1
d395 1
@


14.16
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d64 1
a64 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.15 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.15
log
@update copyright to 2007
@
text
@d22 1
a22 2

/*@@{*/
d24 1
d62 1
a62 1
/*@@}*/
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.14 2006/09/16 02:04:25 lbutler Exp $ (BRL)";
@


14.14
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2006 United States Government as represented by
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.13 2006/08/08 05:15:24 brlcad Exp $ (BRL)";
@


14.13
log
@get rid of the old 'cad' path references/assumptions
@
text
@d21 1
a21 1
/** \addtogroup g */
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.12 2006/07/06 17:38:08 erikgreenwald Exp $ (BRL)";
@


14.12
log
@we don't use cake anymore (comment fix)
@
text
@d47 3
a49 3
 *	go to /cad/libwdb and create mk_xxx() routine
 *	go to /cad/conv and edit g2asc.c and asc2g.c to support the new solid
 *	go to /cad/librt and edit tcl.c to add the new solid to
d52 1
a52 1
 *	go to /cad/mged and create the edit support
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.11 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
@


14.11
log
@update copyright to 2006
@
text
@d44 1
a44 1
 *	edit Cakefile to add g_xxx.c to compile
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.10 2005/12/08 01:18:48 brlcad Exp $ (BRL)";
@


14.10
log
@k&r -> ansi
@
text
@d4 1
a4 1
 * Copyright (C) 1990-2005 United States Government as represented by
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.9 2005/11/24 14:28:22 brlcad Exp $ (BRL)";
@


14.9
log
@clamp the number being printed by the describe function to their closest integer if it's within hardware tolerance of an integer.  this is done only in the describe function for now so it's only cosmetic, though it could conceivably happen on store/load too.  (addresses sf 'bug'/request 1359253)
@
text
@d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.8 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
d70 1
a70 2


d73 2
d81 2
d85 1
d95 2
a96 2
#define RT_XXX_INTERNAL_MAGIC	0xxx
#define RT_XXX_CK_MAGIC(_p)	BU_CKMAG(_p,RT_XXX_INTERNAL_MAGIC,"rt_xxx_internal")
d104 1
d121 1
a121 4
rt_xxx_prep( stp, ip, rtip )
struct soltab		*stp;
struct rt_db_internal	*ip;
struct rt_i		*rtip;
d136 1
a136 2
rt_xxx_print( stp )
register const struct soltab *stp;
d154 1
a154 5
rt_xxx_shot( stp, rp, ap, seghead )
struct soltab		*stp;
register struct xray	*rp;
struct application	*ap;
struct seg		*seghead;
d172 5
a176 6
rt_xxx_vshot( stp, rp, segp, n, ap )
struct soltab	       *stp[]; /* An array of solid pointers */
struct xray		*rp[]; /* An array of ray pointers */
struct  seg            segp[]; /* array of segs (results returned) */
int		  	    n; /* Number of ray/object pairs */
struct application	*ap;
d187 1
a187 4
rt_xxx_norm( hitp, stp, rp )
register struct hit	*hitp;
struct soltab		*stp;
register struct xray	*rp;
d201 1
a201 4
rt_xxx_curve( cvp, hitp, stp )
register struct curvature *cvp;
register struct hit	*hitp;
struct soltab		*stp;
d221 1
a221 5
rt_xxx_uv( ap, stp, hitp, uvp )
struct application	*ap;
struct soltab		*stp;
register struct hit	*hitp;
register struct uvcoord	*uvp;
d231 1
a231 2
rt_xxx_free( stp )
register struct soltab *stp;
d243 1
a243 4
rt_xxx_class( stp, min, max, tol )
const struct soltab    *stp;
const vect_t		min, max;
const struct bn_tol    *tol;
d252 1
a252 5
rt_xxx_plot( vhead, ip, ttol, tol )
struct bu_list		*vhead;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d271 1
a271 6
rt_xxx_tess( r, m, ip, ttol, tol )
struct nmgregion	**r;
struct model		*m;
struct rt_db_internal	*ip;
const struct rt_tess_tol *ttol;
const struct bn_tol	*tol;
d289 1
a289 5
rt_xxx_import( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d321 1
a321 5
rt_xxx_export( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d369 1
a369 5
rt_xxx_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
d410 1
a410 5
rt_xxx_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
d445 1
a445 5
rt_xxx_describe( str, ip, verbose, mm2local )
struct bu_vls		*str;
const struct rt_db_internal	*ip;
int			verbose;
double			mm2local;
d469 1
a469 2
rt_xxx_ifree( ip )
struct rt_db_internal	*ip;
d489 1
a489 5
rt_xxx_xform( op, mat, ip, free )
struct rt_db_internal	*op;
const mat_t		mat;
struct rt_db_internal	*ip;
int			free;
@


14.8
log
@trailing ws
@
text
@d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.7 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
d502 3
a504 3
		xxx_ip->v[X] * mm2local,
		xxx_ip->v[Y] * mm2local,
		xxx_ip->v[Z] * mm2local );
@


14.7
log
@Doxygen changes
@
text
@d25 1
a25 1
 *	Intersect a ray with a. 
d49 1
a49 1
 *	go to /cad/librt and edit tcl.c to add the new solid to 
d55 1
a55 1
 *  
d60 1
a60 1
 *  
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.6 2005/01/30 20:31:00 brlcad Exp $ (BRL)";
d102 1
a102 1
 *  
d106 1
a106 1
 *  
d110 1
a110 1
 *  
d143 1
a143 1
 *  
d147 1
a147 1
 *  
d187 1
a187 1
 *  
d224 1
a224 1
 *  
d427 1
a427 1
	 * Note the conversion from network data 
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d25 1
a25 1
 *	Intersect a ray with a.
d49 1
a49 1
 *	go to /cad/librt and edit tcl.c to add the new solid to
d55 1
a55 1
 *
d60 1
a60 1
 *
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header$ (BRL)";
d102 1
a102 1
 *
d106 1
a106 1
 *
d110 1
a110 1
 *
d143 1
a143 1
 *
d147 1
a147 1
 *
d187 1
a187 1
 *
d224 1
a224 1
 *
d427 1
a427 1
	 * Note the conversion from network data
@


14.6
log
@update copyright to 2005
@
text
@d21 3
d25 1
a25 3
 *
 *  Purpose -
 *	Intersect a ray with a 
d62 2
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_xxx.c,v 14.5 2004/12/21 06:38:21 morrison Exp $ (BRL)";
d100 1
a100 1
/*
d130 1
a130 1
/*
d141 1
a141 1
/*
d169 1
a169 1
/*
d185 1
a185 1
/*
d202 1
a202 1
/*
d222 1
a222 1
/*
d241 1
a241 1
/*
d254 1
a254 1
/*
d266 1
a266 1
/*
d285 1
a285 1
/*
d309 1
a309 1
/*
d346 1
a346 1
/*
d393 1
a393 1
/*
d439 1
a439 1
/*
d480 1
a480 1
/*
d510 1
a510 1
/*
d530 1
a530 1
/*
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2004 United States Government as represented by
d62 1
a62 1
static const char RCSxxx[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_xxx.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a59 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1990-2004 by the United States Army.
 *	All rights reserved.
d62 1
a62 1
static const char RCSxxx[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_xxx.c,v 14.3 2004/12/21 05:45:24 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_xxx.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_xxx.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ X X X . C
d65 1
a65 1
static const char RCSxxx[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_xxx.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_xxx.c,v 1.1 2004/05/20 15:20:03 morrison Exp $ (BRL)";
d525 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d46 1
a46 1
static const char RCSxxx[] = "@@(#)$Header: /cvs/brlcad/librt/g_xxx.c,v 11.22 2004/05/10 15:30:46 erikg Exp $ (BRL)";
d49 1
a49 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

