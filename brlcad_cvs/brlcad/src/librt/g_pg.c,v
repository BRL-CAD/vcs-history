head	14.22;
access;
symbols
	rel-7-10-4:14.18
	STABLE:14.18.0.2
	stable-branch:14.6
	rel-7-10-2:14.17
	rel-7-10-0:14.16
	rel-7-8-4:14.11
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.22
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.12.17.02.16.54;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.11.28.14.11.27;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.22.21.06.48;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.09.07.21.04.31;	author erikgreenwald;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.14.21.04.32;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.41;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.26.05.28.47;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.21.04.45.44;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.11.24.14.28.22;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.59;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.01;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.22
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                          G _ P G . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_  */
/** @@{ */
/** @@file g_pg.c
 *
 *	Intersect a ray with a Polygonal Object
 *	that has no explicit topology.
 *	It is assumed that the solid has no holes.
 *
 *  Author -
 *	Michael John Muuss
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
/** @@} */

#include "common.h"

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"

#include "./debug.h"

#define TRI_NULL	((struct tri_specific *)0)

HIDDEN int rt_pgface(struct soltab *stp, fastf_t *ap, fastf_t *bp, fastf_t *cp, const struct bn_tol *tol);

/* Describe algorithm here */


/**
 *			R T _ P G _ P R E P
 *
 *  This routine is used to prepare a list of planar faces for
 *  being shot at by the triangle routines.
 *
 * Process a PG, which is represented as a vector
 * from the origin to the first point, and many vectors
 * from the first point to the remaining points.
 *
 */
int
rt_pg_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	struct rt_pg_internal	*pgp;
	register int	i;
	int		p;

	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	for( p = 0; p < pgp->npoly; p++ )  {
		vect_t	work[3];

		VMOVE( work[0], &pgp->poly[p].verts[0*3] );
		VMINMAX( stp->st_min, stp->st_max, work[0] );
		VMOVE( work[1], &pgp->poly[p].verts[1*3] );
		VMINMAX( stp->st_min, stp->st_max, work[1] );

		for( i=2; i < pgp->poly[p].npts; i++ )  {
			VMOVE( work[2], &pgp->poly[p].verts[i*3] );
			VMINMAX( stp->st_min, stp->st_max, work[2] );

			/* output a face */
			(void)rt_pgface( stp,
				work[0], work[1], work[2], &rtip->rti_tol );

			/* Chop off a triangle, and continue */
			VMOVE( work[1], work[2] );
		}
	}
	if( stp->st_specific == (genptr_t)0 )  {
		bu_log("pg(%s):  no faces\n", stp->st_name);
		return(-1);		/* BAD */
	}

	{
		fastf_t dx, dy, dz;
		fastf_t	f;

		VADD2SCALE( stp->st_center, stp->st_max, stp->st_min, 0.5 );

		dx = (stp->st_max[X] - stp->st_min[X])/2;
		f = dx;
		dy = (stp->st_max[Y] - stp->st_min[Y])/2;
		if( dy > f )  f = dy;
		dz = (stp->st_max[Z] - stp->st_min[Z])/2;
		if( dz > f )  f = dz;
		stp->st_aradius = f;
		stp->st_bradius = sqrt(dx*dx + dy*dy + dz*dz);
	}

	return(0);		/* OK */
}

/**
 *			R T _ P G F A C E
 *
 *  This function is called with pointers to 3 points,
 *  and is used to prepare PG faces.
 *  ap, bp, cp point to vect_t points.
 *
 * Return -
 *	0	if the 3 points didn't form a plane (eg, colinear, etc).
 *	# pts	(3) if a valid plane resulted.
 */
HIDDEN int
rt_pgface(struct soltab *stp, fastf_t *ap, fastf_t *bp, fastf_t *cp, const struct bn_tol *tol)
{
	register struct tri_specific *trip;
	vect_t work;
	fastf_t m1, m2, m3, m4;

	BU_GETSTRUCT( trip, tri_specific );
	VMOVE( trip->tri_A, ap );
	VSUB2( trip->tri_BA, bp, ap );
	VSUB2( trip->tri_CA, cp, ap );
	VCROSS( trip->tri_wn, trip->tri_BA, trip->tri_CA );

	/* Check to see if this plane is a line or pnt */
	m1 = MAGNITUDE( trip->tri_BA );
	m2 = MAGNITUDE( trip->tri_CA );
	VSUB2( work, bp, cp );
	m3 = MAGNITUDE( work );
	m4 = MAGNITUDE( trip->tri_wn );
	if( m1 < tol->dist || m2 < tol->dist ||
	    m3 < tol->dist || m4 < tol->dist )  {
		bu_free( (char *)trip, "getstruct tri_specific");
		if( RT_G_DEBUG & DEBUG_ARB8 )
			bu_log("pg(%s): degenerate facet\n", stp->st_name);
		return(0);			/* BAD */
	}

	/*  wn is a normal of not necessarily unit length.
	 *  N is an outward pointing unit normal.
	 *  We depend on the points being given in CCW order here.
	 */
	VMOVE( trip->tri_N, trip->tri_wn );
	VUNITIZE( trip->tri_N );

	/* Add this face onto the linked list for this solid */
	trip->tri_forw = (struct tri_specific *)stp->st_specific;
	stp->st_specific = (genptr_t)trip;
	return(3);				/* OK */
}

/**
 *  			R T _ P G _ P R I N T
 */
void
rt_pg_print(register const struct soltab *stp)
{
	register const struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;

	if( trip == TRI_NULL )  {
		bu_log("pg(%s):  no faces\n", stp->st_name);
		return;
	}
	do {
		VPRINT( "A", trip->tri_A );
		VPRINT( "B-A", trip->tri_BA );
		VPRINT( "C-A", trip->tri_CA );
		VPRINT( "BA x CA", trip->tri_wn );
		VPRINT( "Normal", trip->tri_N );
		bu_log("\n");
	} while( (trip = trip->tri_forw) );
}

/**
 *			R T _ P G _ S H O T
 *
 * Function -
 *	Shoot a ray at a polygonal object.
 *
 * Returns -
 *	0	MISS
 *	>0	HIT
 */
int
rt_pg_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;
#define MAXHITS 128		/* # surfaces hit, must be even */
	struct hit hits[MAXHITS];
	register struct hit *hp;
	int	nhits;

	nhits = 0;
	hp = &hits[0];

	/* consider each face */
	for( ; trip; trip = trip->tri_forw )  {
		fastf_t	dn;		/* Direction dot Normal */
		fastf_t	abs_dn;
		fastf_t	k;
		fastf_t	alpha, beta;
		vect_t	wxb;		/* vertex - ray_start */
		vect_t	xp;		/* wxb cross ray_dir */

		/*
		 *  Ray Direction dot N.  (N is outward-pointing normal)
		 *  wn points inwards, and is not unit length.
		 */
		dn = VDOT( trip->tri_wn, rp->r_dir );

		/*
		 *  If ray lies directly along the face, (ie, dot product
		 *  is zero), drop this face.
		 */
		abs_dn = dn >= 0.0 ? dn : (-dn);
		if( abs_dn < SQRT_SMALL_FASTF )
			continue;
		VSUB2( wxb, trip->tri_A, rp->r_pt );
		VCROSS( xp, wxb, rp->r_dir );

		/* Check for exceeding along the one side */
		alpha = VDOT( trip->tri_CA, xp );
		if( dn < 0.0 )  alpha = -alpha;
		if( alpha < 0.0 || alpha > abs_dn )
			continue;

		/* Check for exceeding along the other side */
		beta = VDOT( trip->tri_BA, xp );
		if( dn > 0.0 )  beta = -beta;
		if( beta < 0.0 || beta > abs_dn )
			continue;
		if( alpha+beta > abs_dn )
			continue;
		k = VDOT( wxb, trip->tri_wn ) / dn;

		/* For hits other than the first one, might check
		 *  to see it this is approx. equal to previous one */

		/*  If dn < 0, we should be entering the solid.
		 *  However, we just assume in/out sorting later will work.
		 *  Really should mark and check this!
		 */
		VJOIN1( hp->hit_point, rp->r_pt, k, rp->r_dir );

		/* HIT is within planar face */
		hp->hit_magic = RT_HIT_MAGIC;
		hp->hit_dist = k;
		VMOVE( hp->hit_normal, trip->tri_N );
		if( ++nhits >= MAXHITS )  {
			bu_log("rt_pg_shot(%s): too many hits (%d)\n", stp->st_name, nhits);
			break;
		}
		hp++;
	}
	if( nhits == 0 )
		return(0);		/* MISS */

	/* Sort hits, Near to Far */
	rt_hitsort( hits, nhits );

	/* Remove duplicate hits.
	   We remove one of a pair of hits when they are
		1) close together, and
		2) both "entry" or both "exit" occurrences.
	   Two immediate "entry" or two immediate "exit" hits suggest
	   that we hit both of two joined faces, while we want to hit only
	   one.  An "entry" followed by an "exit" (or vice versa) suggests
	   that we grazed an edge, and thus we should leave both
	   in the hit list. */

	{
		register int i, j;

		for( i=0 ; i<nhits-1 ; i++ )
		{
			fastf_t dist;

			dist = hits[i].hit_dist - hits[i+1].hit_dist;
			if( NEAR_ZERO( dist, ap->a_rt_i->rti_tol.dist ) &&
				VDOT( hits[i].hit_normal, rp->r_dir ) *
				VDOT( hits[i+1].hit_normal, rp->r_dir) > 0)
			{
				for( j=i ; j<nhits-1 ; j++ )
					hits[j] = hits[j+1];
				nhits--;
				i--;
			}
		}
	}


	if( nhits == 1 )
		nhits = 0;

	if( nhits&1 )  {
		register int i;
		static int nerrors = 0;		/* message counter */
		/*
		 * If this condition exists, it is almost certainly due to
		 * the dn==0 check above.  Thus, we will make the last
		 * surface rather thin.
		 * This at least makes the
		 * presence of this solid known.  There may be something
		 * better we can do.
		 */

		if( nerrors++ < 6 )  {
			bu_log("rt_pg_shot(%s): WARNING %d hits:\n", stp->st_name, nhits);
			bu_log( "\tray start = (%g %g %g) ray dir = (%g %g %g)\n",
				V3ARGS( rp->r_pt ), V3ARGS( rp->r_dir ) );
			for(i=0; i < nhits; i++ )
			{
				point_t tmp_pt;

				VJOIN1( tmp_pt, rp->r_pt, hits[i].hit_dist, rp->r_dir );
				if( VDOT( rp->r_dir, hits[i].hit_normal ) < 0.0 )
					bu_log("\tentrance at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
				else
					bu_log("\texit at dist=%f (%g %g %g)\n", hits[i].hit_dist, V3ARGS( tmp_pt ) );
			}
		}

		if( nhits > 2 )
		{
			fastf_t dot1,dot2;
			int j;

			/* likely an extra hit,
			 * look for consecutive entrances or exits */

			dot2 = 1.0;
			i = 0;
			while( i<nhits )
			{
				dot1 = dot2;
				dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
				if( dot1 > 0.0 && dot2 > 0.0 )
				{
					/* two consectutive exits,
					 * manufacture an entrance at same distance
					 * as second exit.
					 */
					for( j=nhits ; j>i ; j-- )
						hits[j] = hits[j-1];	/* struct copy */

					VREVERSE( hits[i].hit_normal, hits[i].hit_normal );
					dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
					nhits++;
					bu_log( "\t\tadding fictitious entry at %f (%s)\n", hits[i].hit_dist, stp->st_name );
				}
				else if( dot1 < 0.0 && dot2 < 0.0 )
				{
					/* two consectutive entrances,
					 * manufacture an exit between them.
					 */

					for( j=nhits ; j>i ; j-- )
						hits[j] = hits[j-1];	/* struct copy */

					hits[i] = hits[i-1];	/* struct copy */
					VREVERSE( hits[i].hit_normal, hits[i-1].hit_normal );
					dot2 = VDOT( rp->r_dir, hits[i].hit_normal );
					nhits++;
					bu_log( "\t\tadding fictitious exit at %f (%s)\n", hits[i].hit_dist, stp->st_name );
				}
				i++;
			}

		}
		else
		{
			hits[nhits] = hits[nhits-1];	/* struct copy */
			VREVERSE( hits[nhits].hit_normal, hits[nhits-1].hit_normal );
			bu_log( "\t\tadding fictitious hit at %f (%s)\n", hits[nhits].hit_dist, stp->st_name );
			nhits++;
		}
	}

	if( nhits&1 )
	{
		if( nhits < MAXHITS )
		{
			hits[nhits] = hits[nhits-1];	/* struct copy */
			VREVERSE( hits[nhits].hit_normal, hits[nhits-1].hit_normal );
			bu_log( "\t\tadding fictitious hit at %f (%s)\n", hits[nhits].hit_dist, stp->st_name );
			nhits++;
		}
		else
			nhits--;
	}

	/* nhits is even, build segments */
	{
		register struct seg *segp;
		register int	i;
		for( i=0; i < nhits; i += 2 )  {
			RT_GET_SEG(segp, ap->a_resource);
			segp->seg_stp = stp;
			segp->seg_in = hits[i];		/* struct copy */
			segp->seg_out = hits[i+1];	/* struct copy */
			BU_LIST_INSERT( &(seghead->l), &(segp->l) );
		}
	}
	return(nhits);			/* HIT */
}

/**
 *			R T _ P G _ F R E E
 */
void
rt_pg_free(struct soltab *stp)
{
	register struct tri_specific *trip =
		(struct tri_specific *)stp->st_specific;

	while( trip != TRI_NULL )  {
		register struct tri_specific *nexttri = trip->tri_forw;

		bu_free( (char *)trip, "pg tri_specific");
		trip = nexttri;
	}
}

/**
 *			R T _ P G _ N O R M
 */
void
rt_pg_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	/* Normals computed in rt_pg_shot, nothing to do here */
}

/**
 *			R T _ P G _ U V
 */
void
rt_pg_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	/* Do nothing.  Really, should do what ARB does. */
	uvp->uv_u = uvp->uv_v = 0;
	uvp->uv_du = uvp->uv_dv = 0;
}

/**
 *			R T _ P G _ C L A S S
 */
int
rt_pg_class(void)
{
	return(0);
}

/**
 *			R T _ P G _ P L O T
 */
int
rt_pg_plot(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	register int	p;	/* current polygon number */
	struct rt_pg_internal	*pgp;

	RT_CK_DB_INTERNAL(ip);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	for( p = 0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;

		pp = &pgp->poly[p];
		RT_ADD_VLIST( vhead, &pp->verts[3*(pp->npts-1)],
			BN_VLIST_LINE_MOVE );
		for( i=0; i < pp->npts; i++ )  {
			RT_ADD_VLIST( vhead, &pp->verts[3*i],
				BN_VLIST_LINE_DRAW );
		}
	}
	return(0);		/* OK */
}

/**
 *			R T _ P G _ P L O T _ P O L Y
 *
 *  Convert to vlist, draw as polygons.
 */
int
rt_pg_plot_poly(struct bu_list *vhead, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	register int	p;	/* current polygon number */
	struct rt_pg_internal	*pgp;

	RT_CK_DB_INTERNAL(ip);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	for( p = 0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;
		vect_t aa, bb, norm;

		pp = &pgp->poly[p];
		if (pp->npts < 3)
			continue;
		VSUB2( aa, &pp->verts[3*(0)], &pp->verts[3*(1)] );
		VSUB2( bb, &pp->verts[3*(0)], &pp->verts[3*(2)] );
		VCROSS( norm, aa, bb );
		VUNITIZE(norm);
		RT_ADD_VLIST(vhead, norm, BN_VLIST_POLY_START);

		RT_ADD_VLIST(vhead, &pp->verts[3*(pp->npts-1)], BN_VLIST_POLY_MOVE);
		for (i=0; i < pp->npts-1; i++) {
			RT_ADD_VLIST(vhead, &pp->verts[3*i], BN_VLIST_POLY_DRAW);
		}
		RT_ADD_VLIST(vhead, &pp->verts[3*(pp->npts-1)], BN_VLIST_POLY_END);
	}
	return(0);		/* OK */
}

/**
 *			R T _ P G _ C U R V E
 */
void
rt_pg_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
	cvp->crv_c1 = cvp->crv_c2 = 0;
}

/**
 *			R T _ P G _ T E S S
 */
int
rt_pg_tess(struct nmgregion **r, struct model *m, struct rt_db_internal *ip, const struct rt_tess_tol *ttol, const struct bn_tol *tol)
{
	register int	i;
	struct shell	*s;
	struct vertex	**verts;	/* dynamic array of pointers */
	struct vertex	***vertp;/* dynamic array of ptrs to pointers */
	struct faceuse	*fu;
	register int	p;	/* current polygon number */
	struct rt_pg_internal	*pgp;

	RT_CK_DB_INTERNAL(ip);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	*r = nmg_mrsv( m );	/* Make region, empty shell, vertex */
	s = BU_LIST_FIRST(shell, &(*r)->s_hd);

	verts = (struct vertex **)bu_malloc(
		pgp->max_npts * sizeof(struct vertex *), "pg_tess verts[]");
	vertp = (struct vertex ***)bu_malloc(
		pgp->max_npts * sizeof(struct vertex **), "pg_tess vertp[]");
	for( i=0; i < pgp->max_npts; i++ )
		vertp[i] = &verts[i];

	for( p = 0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;

		pp = &pgp->poly[p];

		/* Locate these points, if previously mentioned */
		for( i=0; i < pp->npts; i++ )  {
			verts[i] = nmg_find_pt_in_shell( s,
				&pp->verts[3*i], tol );
		}

		/* Construct the face.  Verts should be in CCW order */
		if( (fu = nmg_cmface( s, vertp, pp->npts )) == (struct faceuse *)0 )  {
			bu_log("rt_pg_tess() nmg_cmface failed, skipping face %d\n",
				p);
		}

		/* Associate vertex geometry, where none existed before */
		for( i=0; i < pp->npts; i++ )  {
			if( verts[i]->vg_p )  continue;
			nmg_vertex_gv( verts[i], &pp->verts[3*i] );
		}

		/* Associate face geometry */
		if( nmg_calc_face_g( fu ) )
		{
			nmg_pr_fu_briefly( fu, "" );
			bu_free( (char *)verts, "pg_tess verts[]" );
			bu_free( (char *)vertp, "pg_tess vertp[]" );
			return -1;			/* FAIL */
		}
	}

	/* Compute "geometry" for region and shell */
	nmg_region_a( *r, tol );

	/* Polysolids are often built with incorrect face normals.
	 * Don't depend on them here.
	 */
	nmg_fix_normals( s , tol );
#if 0
	/* mark edges as real */
	(void)nmg_mark_edges_real( &s->l );
#endif
	bu_free( (char *)verts, "pg_tess verts[]" );
	bu_free( (char *)vertp, "pg_tess vertp[]" );

	return(0);		/* OK */
}

/**
 *			R T _ P G _ I M P O R T
 *
 *  Read all the polygons in as a complex dynamic structure.
 *  The caller is responsible for freeing the dynamic memory.
 *  (vid rt_pg_ifree).
 */
int
rt_pg_import(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	struct rt_pg_internal	*pgp;
	union record		*rp;
	register int		i;
	int			rno;		/* current record number */
	int			p;		/* current polygon index */

	BU_CK_EXTERNAL( ep );
	rp = (union record *)ep->ext_buf;
	if( rp->u_id != ID_P_HEAD )  {
		bu_log("rt_pg_import: defective header record\n");
		return(-1);
	}

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_POLY;
	ip->idb_meth = &rt_functab[ID_POLY];
	ip->idb_ptr = bu_malloc(sizeof(struct rt_pg_internal), "rt_pg_internal");
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	pgp->magic = RT_PG_INTERNAL_MAGIC;

	pgp->npoly = (ep->ext_nbytes - sizeof(union record)) /
		sizeof(union record);
	if( pgp->npoly <= 0 )  {
		bu_log("rt_pg_import: polysolid with no polygons!\n");
		return -1;
	}
	if( pgp->npoly )
		pgp->poly = (struct rt_pg_face_internal *)bu_malloc(
			pgp->npoly * sizeof(struct rt_pg_face_internal), "rt_pg_face_internal");
	pgp->max_npts = 0;

	if (mat == NULL) mat = bn_mat_identity;
	for( p=0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;

		pp = &pgp->poly[p];
		rno = p+1;
		if( rp[rno].q.q_id != ID_P_DATA )  {
			bu_log("rt_pg_import: defective data record\n");
			return -1;
		}
		pp->npts = rp[rno].q.q_count;
		pp->verts = (fastf_t *)bu_malloc(
			pp->npts * 3 * sizeof(fastf_t), "pg verts[]" );
		pp->norms = (fastf_t *)bu_malloc(
			pp->npts * 3 * sizeof(fastf_t), "pg norms[]" );
		for( i=0; i < pp->npts; i++ )  {
			/* Note:  side effect of importing dbfloat_t */
			MAT4X3PNT( &pp->verts[i*3], mat,
				rp[rno].q.q_verts[i] );
			MAT4X3VEC( &pp->norms[i*3], mat,
				rp[rno].q.q_norms[i] );
		}
		if( pp->npts > pgp->max_npts )  pgp->max_npts = pp->npts;
	}
	if( pgp->max_npts < 3 )  {
		bu_log("rt_pg_import: polysolid with all polygons of less than %d vertices!\n", pgp->max_npts);
		/* XXX free storage */
		return -1;
	}
	return( 0 );
}

/**
 *			R T _ P G _ E X P O R T
 *
 *  The name will be added by the caller.
 *  Generally, only libwdb will set conv2mm != 1.0
 */
int
rt_pg_export(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	struct rt_pg_internal	*pgp;
	union record		*rec;
	register int		i;
	int			rno;		/* current record number */
	int			p;		/* current polygon index */

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_POLY )  return(-1);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = (1 + pgp->npoly) * sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "pg external");
	rec = (union record *)ep->ext_buf;

	rec[0].p.p_id = ID_P_HEAD;

	for( p=0; p < pgp->npoly; p++ )  {
		register struct rt_pg_face_internal	*pp;

		rno = p+1;
		pp = &pgp->poly[p];
		if( pp->npts < 3 || pp->npts > 5 )  {
			bu_log("rt_pg_export:  unable to support npts=%d\n",
				pp->npts);
			return(-1);
		}

		rec[rno].q.q_id = ID_P_DATA;
		rec[rno].q.q_count = pp->npts;
		for( i=0; i < pp->npts; i++ )  {
			/* NOTE: type conversion to dbfloat_t */
			VSCALE( rec[rno].q.q_verts[i],
				&pp->verts[i*3], local2mm );
			VMOVE( rec[rno].q.q_norms[i], &pp->norms[i*3] );
		}
	}
	return(0);
}

int
rt_pg_import5(struct rt_db_internal *ip, const struct bu_external *ep, const fastf_t *mat, const struct db_i *dbip)
{
	bu_log( "As of release 6.0 the polysolid is superceded by the BOT primitive.\n" );
	bu_log( "\tTo convert polysolids to BOT primitives, use 'dbupgrade'.\n");
	/* The rt_pg_to_bot() routine can also be used. */
	return -1;
}

int
rt_pg_export5(struct bu_external *ep, const struct rt_db_internal *ip, double local2mm, const struct db_i *dbip)
{
	bu_log( "As of release 6.0 the polysolid is superceded by the BOT primitive.\n" );
	bu_log( "\tTo convert polysolids to BOT primitives, use 'dbupgrade'.\n" );
	/* The rt_pg_to_bot() routine can also be used. */
	return -1;
}

/**
 *			R T _ P G _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this solid.
 *  First line describes type of solid.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_pg_describe(struct bu_vls *str, const struct rt_db_internal *ip, int verbose, double mm2local)
{
	register int			j;
	register struct rt_pg_internal	*pgp =
		(struct rt_pg_internal *)ip->idb_ptr;
	char				buf[256];
	int				i;

	RT_PG_CK_MAGIC(pgp);
	bu_vls_strcat( str, "polygon solid with no topology (POLY)\n");

	sprintf(buf, "\t%d polygons (faces)\n",
		pgp->npoly );
	bu_vls_strcat( str, buf );

	sprintf(buf, "\tMost complex face has %d vertices\n",
		pgp->max_npts );
	bu_vls_strcat( str, buf );

	if( pgp->npoly )
	{
		sprintf(buf, "\tFirst vertex (%g, %g, %g)\n",
			INTCLAMP(pgp->poly[0].verts[X] * mm2local),
			INTCLAMP(pgp->poly[0].verts[Y] * mm2local),
			INTCLAMP(pgp->poly[0].verts[Z] * mm2local) );
		bu_vls_strcat( str, buf );
	}

	if( !verbose )  return(0);

	/* Print out all the vertices of all the faces */
	for( i=0; i < pgp->npoly; i++ )  {
		register fastf_t *v = pgp->poly[i].verts;
		register fastf_t *n = pgp->poly[i].norms;

		sprintf( buf, "\tPolygon %d: (%d pts)\n",
			i, pgp->poly[i].npts );
		bu_vls_strcat( str, buf );
		for( j=0; j < pgp->poly[i].npts; j++ )  {
			sprintf(buf, "\t\tV (%g, %g, %g)\n\t\t N (%g, %g, %g)\n",
				INTCLAMP(v[X] * mm2local),
				INTCLAMP(v[Y] * mm2local),
				INTCLAMP(v[Z] * mm2local),
				INTCLAMP(n[X] * mm2local),
				INTCLAMP(n[Y] * mm2local),
				INTCLAMP(n[Z] * mm2local) );
			bu_vls_strcat( str, buf );
			v += ELEMENTS_PER_VECT;
			n += ELEMENTS_PER_VECT;
		}
	}

	return(0);
}

/**
 *			R T _ P G _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this solid.
 */
void
rt_pg_ifree(struct rt_db_internal *ip)
{
	register struct rt_pg_internal	*pgp;
	register int			i;

	RT_CK_DB_INTERNAL(ip);
	pgp = (struct rt_pg_internal *)ip->idb_ptr;
	RT_PG_CK_MAGIC(pgp);

	/*
	 *  Free storage for each polygon
	 */
	for( i=0; i < pgp->npoly; i++ )  {
		bu_free( (char *)pgp->poly[i].verts, "pg verts[]");
		bu_free( (char *)pgp->poly[i].norms, "pg norms[]");
	}
	if( pgp->npoly )
		bu_free( (char *)pgp->poly, "pg poly[]" );
	pgp->magic = 0;			/* sanity */
	pgp->npoly = 0;
	bu_free( (char *)pgp, "pg ifree" );
	ip->idb_ptr = GENPTR_NULL;	/* sanity */
}

/**
 *			R T _ P G _ T O _ B O T
 *
 *  Convert in-memory form of a polysolid (pg) to a bag of triangles (BoT)
 *  There is no record in the V5 database for a polysolid.
 *
 *  Depends on the "max_npts" parameter having been set.
 *
 *  Returns -
 *	-1	FAIL
 *	0	OK
 */
int
rt_pg_to_bot( struct rt_db_internal *ip, const struct bn_tol *tol, struct resource *resp )
{
	struct rt_pg_internal *ip_pg;
	struct rt_bot_internal *ip_bot;
	int max_pts;
	int max_tri;
	int p, i;

	RT_CK_DB_INTERNAL(ip);
	BN_CK_TOL( tol );
	RT_CK_RESOURCE( resp );

	if( ip->idb_type != ID_POLY )
	{
		bu_log( "ERROR: rt_pt_to_bot() called with a non-polysolid!!!\n" );
		return -1;
	}
	ip_pg = (struct rt_pg_internal *)ip->idb_ptr;

	RT_PG_CK_MAGIC( ip_pg );

	ip_bot = (struct rt_bot_internal *)bu_malloc( sizeof( struct rt_bot_internal ), "BOT internal" );
	ip_bot->magic = RT_BOT_INTERNAL_MAGIC;
	ip_bot->mode = RT_BOT_SOLID;
	ip_bot->orientation = RT_BOT_CCW;
	ip_bot->bot_flags = 0;

	/* maximum possible vertices */
	max_pts = ip_pg->npoly * ip_pg->max_npts;
	BU_ASSERT_LONG( max_pts, >, 0 );

	/* maximum possible triangular faces */
	max_tri = ip_pg->npoly * 3;
	BU_ASSERT_LONG( max_tri, >, 0 );

	ip_bot->num_vertices = 0;
	ip_bot->num_faces = 0;
	ip_bot->thickness = (fastf_t *)NULL;
	ip_bot->face_mode = (struct bu_bitv *)NULL;

	ip_bot->vertices = (fastf_t *)bu_calloc( max_pts * 3, sizeof( fastf_t ), "BOT vertices" );
	ip_bot->faces = (int *)bu_calloc( max_tri * 3, sizeof( int ), "BOT faces" );

	for( p=0 ; p<ip_pg->npoly ; p++ )
	{
		vect_t work[3], tmp;
		struct tri_specific trip;
		fastf_t m1, m2, m3, m4;
		int first, v0=0, v2=0;

		first = 1;
		VMOVE( work[0], &ip_pg->poly[p].verts[0*3] );
		VMOVE( work[1], &ip_pg->poly[p].verts[1*3] );

		for( i=2; i < ip_pg->poly[p].npts; i++ )  {
			VMOVE( work[2], &ip_pg->poly[p].verts[i*3] );

			VSUB2( trip.tri_BA, work[1], work[0] );
			VSUB2( trip.tri_CA, work[2], work[0] );
			VCROSS( trip.tri_wn, trip.tri_BA, trip.tri_CA );

			/* Check to see if this plane is a line or pnt */
			m1 = MAGNITUDE( trip.tri_BA );
			m2 = MAGNITUDE( trip.tri_CA );
			VSUB2( tmp, work[1], work[2] );
			m3 = MAGNITUDE( tmp );
			m4 = MAGNITUDE( trip.tri_wn );
			if( m1 >= tol->dist && m2 >= tol->dist &&
			    m3 >= tol->dist && m4 >= tol->dist )  {

				/* add this triangle to the BOT */
				if( first ) {
					ip_bot->faces[ip_bot->num_faces * 3] = ip_bot->num_vertices;
					VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[0] );
					v0 = ip_bot->num_vertices;
					ip_bot->num_vertices++;

					ip_bot->faces[ip_bot->num_faces * 3 + 1] = ip_bot->num_vertices;
					VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[1] );
					ip_bot->num_vertices++;
					first = 0;
				} else {
					ip_bot->faces[ip_bot->num_faces * 3] = v0;
					ip_bot->faces[ip_bot->num_faces * 3 + 1] = v2;
				}
				VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[2] );
				ip_bot->faces[ip_bot->num_faces * 3 + 2] = ip_bot->num_vertices;
				v2 = ip_bot->num_vertices;
				ip_bot->num_vertices++;

				ip_bot->num_faces++;
			}

			/* Chop off a triangle, and continue */
			VMOVE( work[1], work[2] );
		}
	}

	(void)rt_bot_vertex_fuse( ip_bot );
	(void)rt_bot_condense( ip_bot );

	ip_bot->faces = (int *)bu_realloc( ip_bot->faces, ip_bot->num_faces * 3 * sizeof( int ), "BOT faces" );

	rt_db_free_internal( ip, resp );

	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_BOT;
	ip->idb_meth = &rt_functab[ID_BOT];
	ip->idb_ptr = ip_bot;

	return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@a38 4
#ifndef lint
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.20 2007/11/28 14:11:27 erikgreenwald Exp $ (BRL)";
#endif

d82 1
a82 1
		static vect_t	work[3];
d107 2
a108 2
		static fastf_t dx, dy, dz;
		static fastf_t	f;
d141 1
a141 1
	static fastf_t m1, m2, m3, m4;
d215 1
a215 1
	static struct hit hits[MAXHITS];
d217 1
a217 1
	static int	nhits;
d225 1
a225 1
		static fastf_t	abs_dn;
d227 3
a229 3
		static fastf_t	alpha, beta;
		static vect_t	wxb;		/* vertex - ray_start */
		static vect_t	xp;		/* wxb cross ray_dir */
d926 4
a929 4
		static vect_t work[3], tmp;
		static struct tri_specific trip;
		static fastf_t m1, m2, m3, m4;
		static int first, v0=0, v2=0;
@


14.20
log
@LOCAL->static, per machine.h deprecation list
@
text
@d40 1
a40 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.19 2007/10/22 21:06:48 brlcad Exp $ (BRL)";
d228 1
a228 1
		FAST fastf_t	dn;		/* Direction dot Normal */
d230 1
a230 1
		FAST fastf_t	k;
@


14.19
log
@removed the non-ansi/stc compliant noalias.h and noalias-prag.h headers that were used with the cray (and alliant) to make pragma decls before loops.  made obsolete long ago with the move to ansi compliance.
@
text
@d40 1
a40 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.18 2007/09/07 21:04:31 erikgreenwald Exp $ (BRL)";
d86 1
a86 1
		LOCAL vect_t	work[3];
d111 2
a112 2
		LOCAL fastf_t dx, dy, dz;
		LOCAL fastf_t	f;
d145 1
a145 1
	LOCAL fastf_t m1, m2, m3, m4;
d219 1
a219 1
	LOCAL struct hit hits[MAXHITS];
d221 1
a221 1
	LOCAL int	nhits;
d229 1
a229 1
		LOCAL fastf_t	abs_dn;
d231 3
a233 3
		LOCAL fastf_t	alpha, beta;
		LOCAL vect_t	wxb;		/* vertex - ray_start */
		LOCAL vect_t	xp;		/* wxb cross ray_dir */
d930 4
a933 4
		LOCAL vect_t work[3], tmp;
		LOCAL struct tri_specific trip;
		LOCAL fastf_t m1, m2, m3, m4;
		LOCAL int first, v0=0, v2=0;
@


14.18
log
@migrated the contents of src/librt/plane.r to include/bn.h
@
text
@d40 1
a40 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.17 2007/05/14 21:04:32 brlcad Exp $ (BRL)";
a693 1
#		include "noalias.h"
a750 1
#		include "noalias.h"
@


14.17
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d40 1
a40 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.16 2007/01/27 01:41:41 brlcad Exp $ (BRL)";
a55 1
#include "./plane.h"
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d40 1
a40 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.15 2007/01/26 05:28:47 brlcad Exp $ (BRL)";
a44 1

d47 1
d54 1
d897 1
a897 1
	RT_CK_TOL( tol );
@


14.15
log
@allow the import function transformation matrix argument to be NULL, use an identity matrix in that situation.
@
text
@d40 1
a40 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.14 2007/01/23 01:13:37 brlcad Exp $ (BRL)";
a45 1

d311 1
a311 1
			        VDOT( hits[i+1].hit_normal, rp->r_dir) > 0)
d957 1
a957 1
			    	/* add this triangle to the BOT */
d972 2
a973 2
			    	VMOVE( &ip_bot->vertices[ip_bot->num_vertices * 3], work[2] );
			    	ip_bot->faces[ip_bot->num_faces * 3 + 2] = ip_bot->num_vertices;
d975 1
a975 1
			    	ip_bot->num_vertices++;
d977 1
a977 1
			    	ip_bot->num_faces++;
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d40 1
a40 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.13 2007/01/21 04:45:44 brlcad Exp $ (BRL)";
d680 1
@


14.13
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d40 1
a40 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.12 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.12
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d24 1
d38 1
a38 1
/*@@}*/
d41 1
a41 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.11 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
@


14.11
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d42 1
a42 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.10 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
@


14.10
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup g */
d42 1
a42 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.9 2005/11/24 14:28:22 brlcad Exp $ (BRL)";
d141 1
a141 1
 *	#pts	(3) if a valid plane resulted.
@


14.9
log
@clamp the number being printed by the describe function to their closest integer if it's within hardware tolerance of an integer.  this is done only in the describe function for now so it's only cosmetic, though it could conceivably happen on store/load too.  (addresses sf 'bug'/request 1359253)
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d42 1
a42 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.8 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
@


14.8
log
@trailing ws
@
text
@d42 1
a42 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.7 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
d813 3
a815 3
			pgp->poly[0].verts[X] * mm2local,
			pgp->poly[0].verts[Y] * mm2local,
			pgp->poly[0].verts[Z] * mm2local );
d831 6
a836 6
				v[X] * mm2local,
				v[Y] * mm2local,
				v[Z] * mm2local,
				n[X] * mm2local,
				n[Y] * mm2local,
				n[Z] * mm2local );
@


14.7
log
@Doxygen changes
@
text
@d29 1
a29 1
 *  
d32 1
a32 1
 *  
d37 1
a37 1
 *  
d42 1
a42 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.6 2005/01/30 20:30:59 brlcad Exp $ (BRL)";
d69 1
a69 1
 *  
d76 1
a76 1
 *  
d168 1
a168 1
	}		
d208 1
a208 1
 *  
d211 1
a211 1
 *  
d303 1
a303 1
	
d980 1
a980 1
			}		
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d32 1
a32 1
 *
d37 1
a37 1
 *
d42 1
a42 1
static const char RCSpg[] = "@@(#)$Header$ (BRL)";
d69 1
a69 1
 *
d76 1
a76 1
 *
d168 1
a168 1
	}
d208 1
a208 1
 *
d211 1
a211 1
 *
d303 1
a303 1

d980 1
a980 1
			}
@


14.6
log
@update copyright to 2005
@
text
@d21 4
a25 2
 *
 *  Function -
d39 2
d42 1
a42 1
static const char RCSpg[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_pg.c,v 14.5 2004/12/21 06:38:21 morrison Exp $ (BRL)";
d67 1
a67 1
/*
d132 1
a132 1
/*
d183 1
a183 1
/*
d206 1
a206 1
/*
d440 1
a440 1
/*
d457 1
a457 1
/*
d466 1
a466 1
/*
d477 1
a477 1
/*
d486 1
a486 1
/*
d514 1
a514 1
/*
d552 1
a552 1
/*
d562 1
a562 1
/*
d640 1
a640 1
/*
d714 1
a714 1
/*
d783 1
a783 1
/*
d846 1
a846 1
/*
d876 1
a876 1
/*
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d38 1
a38 1
static const char RCSpg[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_pg.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a35 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d38 1
a38 1
static const char RCSpg[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_pg.c,v 14.3 2004/12/21 05:45:24 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d41 1
a41 1
static const char RCSpg[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_pg.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d41 1
a41 1
static const char RCSpg[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_pg.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ P G . C
d41 1
a41 1
static const char RCSpg[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_pg.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_pg.c,v 1.1 2004/05/20 15:20:01 morrison Exp $ (BRL)";
d981 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d22 1
a22 1
static const char RCSpg[] = "@@(#)$Header: /cvs/brlcad/librt/g_pg.c,v 11.46 2004/05/10 15:30:46 erikg Exp $ (BRL)";
d25 1
a25 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

