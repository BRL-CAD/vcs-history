head	14.15;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.6
	rel-7-10-2:14.15
	rel-7-10-0:14.14
	rel-7-8-4:14.10
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.15
date	2007.05.18.04.13.50;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.41;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.38;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.21.04.45.45;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.55;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.09.16.02.04.25;	author lbutler;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches
	14.9.2.1;
next	14.8;

14.8
date	2005.10.23.04.44.36;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.31.03;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.47;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.07;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;

14.9.2.1
date	2006.04.20.13.11.43;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.15
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@/*                     N U R B _ K N O T . C
 * BRL-CAD
 *
 * Copyright (c) 1990-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup nurb */
/** @@{ */
/** @@file nurb_knot.c
 *
 * Various knot vector routines.
 *
 * Author -
 *     Paul R. Stay
 *
 * Source -
 *     SECAD/VLD Computing Consortium, Bldg 394
 *     The U.S. Army Ballistic Research Laboratory
 *     Aberdeen Proving Ground, Maryland 21005
 *
 */
/** @@} */

#include "common.h"


#include <stdio.h>
#include <math.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "nurb.h"

/* rt_nurb_kvknot()
 * Generate a open knot vector with n=order knots at the beginning of
 * the sequence and n knots at the end of the sequence with a lower,
 * and an upper value and num knots in between
 */

void
rt_nurb_kvknot(register struct knot_vector *new_knots, int order, fastf_t lower, fastf_t upper, int num, struct resource *res)
{
	register int	i;
	int	total;
	fastf_t knot_step;

	total = order * 2 + num;

	knot_step = (upper - lower) / ( num + 1 );

	new_knots->k_size = total;

	new_knots->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * total,
		    "rt_nurb_kvknot: new knots values");

	for ( i = 0; i < order; i++)
		new_knots->knots[i] = lower;

	for ( i = order; i <= (num + order - 1); i++)
		new_knots->knots[i] = new_knots->knots[i-1] + knot_step;

	for ( i = ( num + order ) ; i < total; i++)
		new_knots->knots[i] = upper;
}


/* rt_nurb_kvmult()
 *	Construct a new knot vector which is the same as the passed in
 * knot vector except it has multiplicity of num of val. It checks to see if
 * val already is a multiple knot.
 */
void
rt_nurb_kvmult(struct knot_vector *new_kv, const struct knot_vector *kv, int num, register fastf_t val, struct resource *res)
{
	int	n;
	register int	i;
	struct knot_vector check;

	n = rt_nurb_kvcheck( val, kv );

	check.k_size = num - n;
	if( check.k_size <= 0 )  {
		bu_log("rt_nurb_kvmult(new_kv=x%x, kv=x%x, num=%d, val=%g)\n",
			new_kv, kv, num, val);
		rt_nurb_pr_kv(kv);
		bu_bomb("rt_nurb_kvmult\n");
	}

	check.knots = (fastf_t * ) bu_malloc( sizeof(fastf_t) * check.k_size,
		    "rt_nurb_kvmult: check knots");

	for ( i = 0; i < num - n; i++)
		check.knots[i] = val;

	rt_nurb_kvmerge( new_kv, &check, kv, res);

	/* free up old knot values */
	bu_free((char *)check.knots, "rt_nurb_kvmult:check knots");
}


/* rt_nurb_kvgen( )
 * 	Generate a knot vector with num knots from lower value to
 * 	the upper  value.
 */

void
rt_nurb_kvgen(register struct knot_vector *kv, fastf_t lower, fastf_t upper, int num, struct resource *res)
{
	register int	i;
	register fastf_t inc;

	inc = (upper - lower) / ( num + 1 );

	kv->k_size = num;

	kv->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * num,
		    "rt_nurb_kvgen: kv knots");

	for ( i = 1; i <= num; i++)
		kv->knots[i-1] = lower + i * inc;
}


/* rt_nurb_kvmerge()
 *	Merge two knot vectors together and return the new resulting
 *	knot vector.
 */

void
rt_nurb_kvmerge(struct knot_vector *new_knots, const struct knot_vector *kv1, const struct knot_vector *kv2, struct resource *res)
{
	int	kv1_ptr = 0;
	int	kv2_ptr = 0;
	int	new_ptr;

	new_knots->k_size = kv1->k_size + kv2->k_size;

	new_knots->knots = (fastf_t * ) bu_malloc(
		    sizeof (fastf_t) * new_knots->k_size,
		    "rt_nurb_kvmerge: new knot values");

	for ( new_ptr = 0; new_ptr < new_knots->k_size; new_ptr++) {
		if ( kv1_ptr >= kv1->k_size )
			new_knots->knots[new_ptr] = kv2->knots[kv2_ptr++];
		else if ( kv2_ptr >= kv2->k_size )
			new_knots->knots[new_ptr] = kv1->knots[kv1_ptr++];
		else if ( kv1->knots[kv1_ptr] < kv2->knots[kv2_ptr])
			new_knots->knots[new_ptr] = kv1->knots[kv1_ptr++];
		else
			new_knots->knots[new_ptr] = kv2->knots[kv2_ptr++];
	}
}


/* rt_nurb_kvcheck()
 *	Checks to see if the knot (val) exists in the Knot Vector and
 *	returns its multiplicity.
 */

int
rt_nurb_kvcheck(fastf_t val, register const struct knot_vector *kv)
{
	register int	kv_num = 0;
	register int	i;

	for ( i = 0; i < kv->k_size; i++) {
		if ( val == kv->knots[i] )
			kv_num++;
	}

	return kv_num;
}


/* rt_nurb_kvextract()
 *	Extract the portion of the knot vector from kv->knots[lower] to
 *	kv->knots[upper]
 */

void
rt_nurb_kvextract(struct knot_vector *new_kv, register const struct knot_vector *kv, int lower, int upper, struct resource *res)
{
	register int	i;
	register fastf_t *ptr;

	new_kv->knots = (fastf_t * ) bu_malloc (
		    sizeof (fastf_t) * (upper - lower),
		    "spl_kvextract: nkw kv values" );

	new_kv->k_size = upper - lower;
	ptr = new_kv->knots;

	for ( i = lower; i < upper; i++)
		*ptr++ = kv->knots[i];
}


/* rt_nurb_kvcopy()
 *	Generic copy the knot vector and pass a new one in.
 */

void
rt_nurb_kvcopy(struct knot_vector *new_kv, register const struct knot_vector *old_kv, struct resource *res)
{
	register int	i;

	new_kv->k_size = old_kv->k_size;

	new_kv->knots = (fastf_t * ) bu_malloc( sizeof( fastf_t) *
		    new_kv->k_size, "spl_kvcopy: new knot values");

	for ( i = 0; i < new_kv->k_size; i++)
		new_kv->knots[i] = old_kv->knots[i];
}


/* rt_nurb_kvnorm()
 *	Normalize the knot vector so its values are from zero to one.
 */

/* XXX Need to check to see if the lower value is zero */
void
rt_nurb_kvnorm(register struct knot_vector *kv)
{
	register fastf_t upper;
	register int	i;

	upper = kv->knots[kv->k_size - 1];
	if( NEAR_ZERO( upper, SMALL ) )
		upper = 0;
	else
		upper = 1 / upper;

	for ( i = 0; i < kv->k_size; i++)
		kv->knots[i] *= upper;
}


/* knot_index()
 *	Calculates and returns the index of the value for the knot vector
 *
 * XXX It is hard to know what tolerance to use here for the comparisons.
 */

int
rt_nurb_knot_index(const struct knot_vector *kv, fastf_t k_value, int order)
{
	int	i;
	fastf_t  knt;
	int	k_index;

	if ( k_value < ( knt = *(kv->knots + order - 1))) {
		if (fabs( k_value - knt) < 0.0001) {
			k_value = knt;
		} else
			return - 1;
	}

	if ( k_value > ( knt = *(kv->knots + kv->k_size - order + 1)) ) {
		if (fabs( k_value - knt) < 0.0001) {
			k_value = knt;
		} else
			return - 1;
	}

	if ( k_value == kv->knots[ kv->k_size - order + 1] )
		k_index = kv->k_size - order - 1;
	else if ( k_value == kv->knots[ order - 1] )
		k_index = order - 1;
	else
	 {
		k_index = 0;
		for ( i = 0; i < kv->k_size - 1; i++)
			if ( kv->knots[i] < k_value && k_value <= kv->knots[i+1] )
				k_index = i;

	}

	return k_index;
}


/* rt_nurb_gen_knot_vector()
 * Generate a open knot vector with n=order knots at the beginning of
 * the sequence and n knots at the end of the sequence.
 */

void
rt_nurb_gen_knot_vector(register struct knot_vector *new_knots, int order, fastf_t lower, fastf_t upper, struct resource *res)
{
    register int i;
    int total;

    total = order * 2;

    new_knots->k_size = total;

    new_knots->knots = (fastf_t *) bu_malloc ( sizeof( fastf_t) * total,
		"rt_nurb_gen_knot_vector: new knots values");

    for ( i = 0; i < order; i++)
	new_knots->knots[i] = lower;

    for ( i = order; i < total; i++)
	new_knots->knots[i] = upper;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d99 1
a99 1
		rt_bomb("rt_nurb_kvmult\n");
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a39 1

d316 1
a316 1
        new_knots->knots[i] = lower;
d319 1
a319 1
        new_knots->knots[i] = upper;
@


14.12
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.11
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 1
/*@@{*/
d24 1
d36 1
a36 1
/*@@}*/
@


14.10
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2006 United States Government as represented by
@


14.9
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup nurb */
@


14.9.2.1
log
@logging updates
@
text
@d98 2
a99 2
		bu_log("rt_nurb_kvmult(new_kv=x%x, kv=x%x, num=%d, val=%g, n=%d)\n",
		       new_kv, kv, num, val, n);
d101 1
a101 1
		bu_bomb("rt_nurb_kvmult failed: check.k_size <= 0\n");
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1990-2005 United States Government as represented by
@


14.7
log
@Doxygen changes
@
text
@d26 1
a26 1
 * 
d84 2
a85 2
 * knot vector except it has multiplicity of num of val. It checks to see if 
 * val already is a multiple knot. 
d118 1
a118 1
 * 	Generate a knot vector with num knots from lower value to 
d132 1
a132 1
	kv->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * num, 
d141 1
a141 1
 *	Merge two knot vectors together and return the new resulting 
d154 1
a154 1
	new_knots->knots = (fastf_t * ) bu_malloc( 
d202 1
a202 1
	new_kv->knots = (fastf_t * ) bu_malloc ( 
d225 1
a225 1
	new_kv->knots = (fastf_t * ) bu_malloc( sizeof( fastf_t) * 
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d26 1
a26 1
 *
d84 2
a85 2
 * knot vector except it has multiplicity of num of val. It checks to see if
 * val already is a multiple knot.
d118 1
a118 1
 * 	Generate a knot vector with num knots from lower value to
d132 1
a132 1
	kv->knots = (fastf_t * ) bu_malloc ( sizeof( fastf_t) * num,
d141 1
a141 1
 *	Merge two knot vectors together and return the new resulting
d154 1
a154 1
	new_knots->knots = (fastf_t * ) bu_malloc(
d202 1
a202 1
	new_kv->knots = (fastf_t * ) bu_malloc (
d225 1
a225 1
	new_kv->knots = (fastf_t * ) bu_malloc( sizeof( fastf_t) *
@


14.6
log
@update copyright to 2005
@
text
@d21 3
d25 1
a25 8
 *
 */

/* 
 *       N U R B _ K N O T . C
 *
 * Function -
 *     Various knot vector routines.
d36 1
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1990-2004 United States Government as represented by
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a38 3
 * Copyright Notice -
 *     This software is Copyright (C) 1990-2004 by the United States Army.
 *     All rights reserved.
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 24
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d305 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

