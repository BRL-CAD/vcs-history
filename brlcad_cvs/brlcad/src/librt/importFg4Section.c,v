head	1.17;
access;
symbols
	rel-7-10-4:1.15
	STABLE:1.15.0.2
	stable-branch:1.3
	rel-7-10-2:1.15
	rel-7-10-0:1.14
	rel-7-8-4:1.10
	rel-7-8-2:1.8
	rel-7-8-0:1.8
	trimnurbs-branch:1.8.0.2
	help:1.8
	temp_tag:1.6
	bobWinPort-20051223-freeze:1.4.2.1
	postmerge-20051223-bobWinPort:1.6
	premerge-20051223-bobWinPort:1.5
	rel-7-6-6:1.5
	rel-7-6-4:1.5
	rel-7-6-2:1.4
	rel-7-6-branch:1.4.0.4
	rel-7-6-0:1.4
	rel-7-4-2:1.3
	rel-7-4-branch:1.3.0.2
	bobWinPort:1.4.0.2
	rel-7-4-0:1.3
	rel-7-2-6:1.3
	rel-7-2-4:1.3
	rel-7-2-2:1.3;
locks; strict;
comment	@ * @;


1.17
date	2007.12.16.18.53.50;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.15.16.23.13;	author brlcad;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.18.04.13.49;	author brlcad;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.24.19.33.05;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.21.04.45.44;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.16.02.04.25;	author lbutler;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.30.17.30.00;	author bob1961;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.28.00.36.28;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2005.03.28.18.59.53;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.28.05.51.03;	author bob1961;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.24.17.08.43;	author bob1961;	state Exp;
branches;
next	;

1.4.2.1
date	2005.10.17.20.04.33;	author bob1961;	state Exp;
branches;
next	;

1.4.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.17
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*              I M P O R T F G 4 S E C T I O N . C
 * BRL-CAD
 *
 * Copyright (c) 1994-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup librt */
/** @@{ */
/** @@file importFg4Section.c
 *      Some of this code was taken from conv/fast4-g.c and libwdb/bot.c
 *      and modified to behave as a method of the BRL-CAD database object
 *      that imports a Fastgen4 section from a string. This section can
 *      only contain GRIDs, CTRIs and CQUADs.
 *
 *  Author of fast4-g.c -
 *      John R. Anderson
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.16 2007/09/15 16:23:13 brlcad Exp $";
#endif

#include "common.h"

/* system headers */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#else
#  ifdef HAVE_SYS_UNISTD_H
#    include <sys/unistd.h>
#  endif
#endif

/* interface headers */
#include "machine.h"
#include "db.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "plot3.h"

/* local headers */
#include "../librt/debug.h"


static int	grid_size;		/* Number of points that will fit in current grid_pts array */
static int	max_grid_no=0;		/* Maximum grid number used */
static int	mode=0;			/* Plate mode (1) or volume mode (2), of current component */
static int	group_id=(-1);		/* Group identification number from SECTION card */
static int	comp_id=(-1);		/* Component identification number from SECTION card */
static int	region_id=0;		/* Region id number (group id no X 1000 + component id no) */
static char	field[9];		/* Space for storing one field from an input line */
static int	name_count;		/* Count of number of times this name_name has been used */
static int	bot=0;			/* Flag: >0 -> There are BOT's in current component */
static int	warnings=0;		/* Flag: >0 -> Print warning messages */
static int	debug=0;		/* Debug flag */
static int	rt_debug=0;		/* RT_G_DEBUG */
static int	quiet=0;		/* flag to not blather */
static int	comp_count=0;		/* Count of components in FASTGEN4 file */

static int		*faces=NULL;	/* one triplet per face indexing three grid points */
static fastf_t		*thickness;	/* thickness of each face */
static char		*facemode;	/* mode for each face */
static int		face_size=0;	/* actual length of above arrays */
static int		face_count=0;	/* number of faces in above arrays */

static int	*int_list;		/* Array of integers */
static int	int_list_count=0;	/* Number of ints in above array */
static int	int_list_length=0;	/* Length of int_list array */

#define		PLATE_MODE	1
#define		VOLUME_MODE	2

#define		POS_CENTER	1	/* face positions for facets */
#define		POS_FRONT	2

#define		END_OPEN	1	/* End closure codes for cones */
#define		END_CLOSED	2

#define		GRID_BLOCK	256	/* allocate space for grid points in blocks of 256 points */

#define		CLINE		'l'
#define		CHEX1		'p'
#define		CHEX2		'b'
#define		CTRI		't'
#define		CQUAD		'q'
#define		CCONE1		'c'
#define		CCONE2		'd'
#define		CCONE3		'e'
#define		CSPHERE		's'
#define		NMG		'n'
#define		BOT		't'
#define		COMPSPLT	'h'

point_t *grid_pts;

void do_grid(char *line);
void do_tri(char *line);
void do_quad(char *line);
void make_bot_object(char		*name,
		     struct rt_wdb	*wdbp);

/*************************** code from libwdb/bot.c ***************************/

static int
rt_mk_bot_w_normals(
	struct rt_wdb *fp,
	const char *name,
	unsigned char	mode,
	unsigned char	orientation,
	unsigned char	flags,
	int		num_vertices,
	int		num_faces,
	fastf_t		*vertices,	/* array of floats for vertices [num_vertices*3] */
	int		*faces,		/* array of ints for faces [num_faces*3] */
	fastf_t		*thickness,	/* array of plate mode thicknesses (corresponds to array of faces)
					 * NULL for modes RT_BOT_SURFACE and RT_BOT_SOLID.
					 */
	struct bu_bitv	*face_mode,	/* a flag for each face indicating thickness is appended to hit point,
					 * otherwise thickness is centered about hit point
					 */
	int		num_normals,	/* number of unit normals in normals array */
	fastf_t		*normals,	/* array of floats for normals [num_normals*3] */
	int		*face_normals )	/* array of ints (indices into normals array), must have 3*num_faces entries */
{
	struct rt_bot_internal *bot;
	int i;

	if( (num_normals > 0) && (fp->dbip->dbi_version < 5 ) ) {
		bu_log( "You are using an old database format which does not support surface normals for BOT primitives\n" );
		bu_log( "You are attempting to create a BOT primitive named \"%s\" with surface normals\n" );
		bu_log( "The surface normals will not be saved\n" );
		bu_log( "Please upgrade to the current database format by using \"dbupgrade\"\n" );
	}

	BU_GETSTRUCT( bot, rt_bot_internal );
	bot->magic = RT_BOT_INTERNAL_MAGIC;
	bot->mode = mode;
	bot->orientation = orientation;
	bot->bot_flags = flags;
	bot->num_vertices = num_vertices;
	bot->num_faces = num_faces;
	bot->vertices = (fastf_t *)bu_calloc( num_vertices * 3, sizeof( fastf_t ), "bot->vertices" );
	for( i=0 ; i<num_vertices*3 ; i++ )
		bot->vertices[i] = vertices[i];
	bot->faces = (int *)bu_calloc( num_faces * 3, sizeof( int ), "bot->faces" );
	for( i=0 ; i<num_faces*3 ; i++ )
		bot->faces[i] = faces[i];
	if( mode == RT_BOT_PLATE )
	{
		bot->thickness = (fastf_t *)bu_calloc( num_faces, sizeof( fastf_t ), "bot->thickness" );
		for( i=0 ; i<num_faces ; i++ )
			bot->thickness[i] = thickness[i];
		bot->face_mode = bu_bitv_dup( face_mode );
	}
	else
	{
		bot->thickness = (fastf_t *)NULL;
		bot->face_mode = (struct bu_bitv *)NULL;
	}

	if( (num_normals > 0) && (fp->dbip->dbi_version >= 5 ) ) {
		bot->num_normals = num_normals;
		bot->num_face_normals = bot->num_faces;
		bot->normals = (fastf_t *)bu_calloc( bot->num_normals * 3, sizeof( fastf_t ), "BOT normals" );
		bot->face_normals = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "BOT face normals" );
		memcpy(bot->normals, normals, bot->num_normals * 3 * sizeof( fastf_t ));
		memcpy(bot->face_normals, face_normals, bot->num_faces * 3 * sizeof( int ));
	} else {
		bot->bot_flags = 0;
		bot->num_normals = 0;
		bot->num_face_normals = 0;
		bot->normals = (fastf_t *)NULL;
		bot->face_normals = (int *)NULL;
	}

	return wdb_export(fp, name, (genptr_t)bot, ID_BOT, 1.0);
}

static int
rt_mk_bot(
	struct rt_wdb *fp,
	const char *name,
	unsigned char	mode,
	unsigned char	orientation,
	unsigned char	flags,
	int		num_vertices,
	int		num_faces,
	fastf_t		*vertices,	/* array of floats for vertices [num_vertices*3] */
	int		*faces,		/* array of ints for faces [num_faces*3] */
	fastf_t		*thickness,	/* array of plate mode thicknesses (corresponds to array of faces)
					 * NULL for modes RT_BOT_SURFACE and RT_BOT_SOLID.
					 */
	struct bu_bitv	*face_mode )	/* a flag for each face indicating thickness is appended to hit point,
					 * otherwise thickness is centered about hit point
					 */
{
	return( rt_mk_bot_w_normals( fp, name, mode, orientation, flags, num_vertices, num_faces, vertices,
				  faces, thickness, face_mode, 0, NULL, NULL ) );
}

/*************************** code from conv/fast4-g.c ***************************/

void
do_grid(char *line)
{
	int grid_no;
	fastf_t x,y,z;

	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at start of do_grid\n" );

	strncpy( field , &line[8] , 8 );
	grid_no = atoi( field );

	if( grid_no < 1 )
	{
		bu_log( "ERROR: grid id number = %d\n" , grid_no );
		bu_bomb( "BAD GRID ID NUMBER\n" );
	}

	strncpy( field , &line[24] , 8 );
	x = atof( field );

	strncpy( field , &line[32] , 8 );
	y = atof( field );

	strncpy( field , &line[40] , 8 );
	z = atof( field );

	while( grid_no > grid_size - 1 )
	{
		grid_size += GRID_BLOCK;
		grid_pts = (point_t *)bu_realloc( (char *)grid_pts , grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
	}

	VSET( grid_pts[grid_no] , x*25.4 , y*25.4 , z*25.4 );

	if( grid_no > max_grid_no )
		max_grid_no = grid_no;
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at end of do_grid\n" );
}

void
Add_bot_face(int pt1, int pt2, int pt3, fastf_t thick, int pos)
{

	if( pt1 == pt2 || pt2 == pt3 || pt1 == pt3 )
	{
		bu_log( "Add_bot_face: ignoring degenerate triangle in group %d component %d\n", group_id, comp_id );
		return;
	}

	if( pos == 0 )	/* use default */
		pos = POS_FRONT;

	if( mode == PLATE_MODE )
	{
		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "Add_bot_face: illegal postion parameter (%d), must be one or two (ignoring face for group %d component %d)\n" , pos, group_id, comp_id );
			return;
		}
	}

	if( face_count >= face_size )
	{
		face_size += GRID_BLOCK;
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted before realloc of faces, thickness, and facemode\n" );
		faces = (int *)bu_realloc( (void *)faces,  face_size*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_realloc( (void *)thickness, face_size*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_realloc( (void *)facemode, face_size*sizeof( char ), "facemode" );
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted after realloc of faces, thickness, and facemode\n" );
	}

	faces[face_count*3] = pt1;
	faces[face_count*3+1] = pt2;
	faces[face_count*3+2] = pt3;

	if( mode == PLATE_MODE )
	{
		thickness[face_count] = thick;
		facemode[face_count] = pos;
	}
	else
	{
		thickness[face_count] = 0,0;
		facemode[face_count] = 0;
	}

	face_count++;

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted at end of Add_bot_face()\n" );
}

void
do_tri(char *line)
{
	int element_id;
	int pt1,pt2,pt3;
	fastf_t thick;
	int pos;

	if( debug )
		bu_log( "do_tri: %s\n" , line );

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !bot )
		bot = element_id;

	if( faces == NULL )
	{
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted before malloc of faces\n" );
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted after malloc of faces , thickness, and facemode\n" );
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	thick = 0.0;
	pos = 0;

	if( mode == PLATE_MODE )
	{
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;

		strncpy( field , &line[64] , 8 );
		pos = atoi( field );
		if( pos == 0 )
			pos = POS_FRONT;

		if( debug )
			bu_log( "\tplate mode: thickness = %f\n" , thick );

	}

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted before call to Add_bot_face()\n" );

	Add_bot_face( pt1, pt2, pt3, thick, pos );

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted after call to Add_bot_face()\n" );
}

void
do_quad(char *line)
{
	int element_id;
	int pt1,pt2,pt3,pt4;
	fastf_t thick = 0.0;
	int pos = 0;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( debug )
		bu_log( "do_quad: %s\n" , line );

	if( !bot )
		bot = element_id;

	if( faces == NULL )
	{
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	strncpy( field , &line[48] , 8 );
	pt4 = atoi( field );

	if( mode == PLATE_MODE )
	{
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;

		strncpy( field , &line[64] , 8 );
		pos = atoi( field );

		if( pos == 0 )	/* use default */
			pos = POS_FRONT;

		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "do_quad: illegal postion parameter (%d), must be one or two\n" , pos );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
	}

	Add_bot_face( pt1, pt2, pt3, thick, pos );
	Add_bot_face( pt1, pt3, pt4, thick, pos );
}

void
make_bot_object(char		*name,
		struct rt_wdb	*wdbp)
{
	int i;
	int max_pt=0, min_pt=999999;
	int num_vertices;
	struct bu_bitv *bv=NULL;
	int bot_mode;
	int element_id=bot;
	int count;
	struct rt_bot_internal bot_ip;

	bot_ip.magic = RT_BOT_INTERNAL_MAGIC;
	for( i=0 ; i<face_count ; i++ )
	{
		V_MIN( min_pt, faces[i*3] );
		V_MAX( max_pt, faces[i*3] );
		V_MIN( min_pt, faces[i*3+1] );
		V_MAX( max_pt, faces[i*3+1] );
		V_MIN( min_pt, faces[i*3+2] );
		V_MAX( max_pt, faces[i*3+2] );
	}

	num_vertices = max_pt - min_pt + 1;
	bot_ip.num_vertices = num_vertices;
	bot_ip.vertices = (fastf_t *)bu_calloc( num_vertices*3, sizeof( fastf_t ), "BOT vertices" );
	for( i=0 ; i<num_vertices ; i++ )
		VMOVE( &bot_ip.vertices[i*3], grid_pts[min_pt+i] )

	for( i=0 ; i<face_count*3 ; i++ )
		faces[i] -= min_pt;
	bot_ip.num_faces = face_count;
	bot_ip.faces = bu_calloc( face_count*3, sizeof( int ), "BOT faces" );
	for( i=0 ; i<face_count*3 ; i++ )
		bot_ip.faces[i] = faces[i];

	bot_ip.face_mode = (struct bu_bitv *)NULL;
	bot_ip.thickness = (fastf_t *)NULL;
	if( mode == PLATE_MODE )
	{
		bot_mode = RT_BOT_PLATE;
		bv = bu_bitv_new( face_count );
		bu_bitv_clear( bv );
		for( i=0 ; i<face_count ; i++ )
		{
			if( facemode[i] == POS_FRONT )
				BU_BITSET( bv, i );
		}
		bot_ip.face_mode = bv;
		bot_ip.thickness = (fastf_t *)bu_calloc( face_count, sizeof( fastf_t ), "BOT thickness" );
		for( i=0 ; i<face_count ; i++ )
			bot_ip.thickness[i] = thickness[i];
	}
	else
		bot_mode = RT_BOT_SOLID;

	bot_ip.mode = bot_mode;
	bot_ip.orientation = RT_BOT_UNORIENTED;
	bot_ip.bot_flags = 0;

	count = rt_bot_vertex_fuse( &bot_ip );
	if( count )
		(void)rt_bot_condense( &bot_ip );

	count = rt_bot_face_fuse( &bot_ip );
	if( count )
		bu_log( "WARNING: %d duplicate faces eliminated from group %d component %d\n", count, group_id, comp_id );

	rt_mk_bot(wdbp, name, bot_mode, RT_BOT_UNORIENTED, 0,
	       bot_ip.num_vertices, bot_ip.num_faces, bot_ip.vertices,
	       bot_ip.faces, bot_ip.thickness, bot_ip.face_mode);

	if( mode == PLATE_MODE )
	{
		bu_free( (char *)bot_ip.thickness, "BOT thickness" );
		bu_free( (char *)bot_ip.face_mode, "BOT face_mode" );
	}
	bu_free( (char *)bot_ip.vertices, "BOT vertices" );
	bu_free( (char *)bot_ip.faces, "BOT faces" );
}


/*************************** Start of new code. ***************************/

#define FIND_NEWLINE(_cp,_eosFlag) \
    while (*(_cp) != '\0' && \
	   *(_cp) != '\n') \
	++(_cp); \
\
    if (*(_cp) == '\0') \
	_eosFlag = 1; \
    else \
	*(_cp) = '\0';

int
wdb_importFg4Section_cmd(struct rt_wdb	*wdbp,
			 Tcl_Interp	*interp,
			 int		argc,
			 char 		**argv)
{
    char *cp;
    char *line;
    char *lines;
    int eosFlag = 0;

    if (argc != 3) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias wdb_importFg4Section %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    grid_size = GRID_BLOCK;
    grid_pts = (point_t *)bu_malloc(grid_size * sizeof(point_t) ,
				    "importFg4Section: grid_pts");

    lines = strdup(argv[2]);
    cp = line = lines;

    FIND_NEWLINE(cp,eosFlag);

    strncpy(field, line+8, 8);
    group_id = atoi(field);

    strncpy(field, line+16, 8);
    comp_id = atoi(field);

    region_id = group_id * 1000 + comp_id;

    if (comp_id > 999) {
	bu_log( "Illegal component id number %d, changed to 999\n" , comp_id );
	comp_id = 999;
    }

    strncpy(field, line+24, 8);
    mode = atoi(field);
    if (mode != 1 && mode != 2) {
	bu_log("Illegal mode (%d) for group %d component %d, using volume mode\n",
	       mode, group_id, comp_id);
	mode = 2;
    }

    while (!eosFlag) {
	++cp;
	line = cp;
	FIND_NEWLINE(cp,eosFlag);

	if (!strncmp(line , "GRID" , 4))
	    do_grid(line);
	else if (!strncmp(line , "CTRI" , 4))
	    do_tri(line);
	else if (!strncmp(line , "CQUAD" , 4))
	    do_quad(line);
    }

    make_bot_object(argv[1], wdbp);
    free((void *)lines);
    bu_free((void *)grid_pts, "importFg4Section: grid_pts");

    /* free memory associated with globals */
    bu_free((void *)faces, "importFg4Section: faces");
    bu_free((void *)thickness, "importFg4Section: thickness");
    bu_free((void *)facemode, "importFg4Section: facemode");

    faces = NULL;
    thickness = NULL;
    facemode = NULL;

    return TCL_OK;
}
/** @@} */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.15 2007/05/18 04:13:49 brlcad Exp $";
d193 2
a194 2
		memcpy( bot->normals, normals, bot->num_normals * 3 * sizeof( fastf_t ) );
		memcpy( bot->face_normals, face_normals, bot->num_faces * 3 * sizeof( int ) );
@


1.15
log
@rt_bomb() has been deprecated since before 7.0, but even our sources weren't properly updated to reflect this change.  update all of our sources to use bu_bomb() now.
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.14 2007/01/24 19:33:05 brlcad Exp $";
d46 1
a46 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d49 2
a50 1
#if defined(HAVE_UNISTD_H)
d53 1
a53 1
#  if defined(HAVE_SYS_UNISTD_H)
@


1.14
log
@copyright was acquired (by non-gov't) and later assigned to the government prior to open sourcing.  remove old clause
@
text
@d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.13 2007/01/23 01:13:37 brlcad Exp $";
d248 1
a248 1
		rt_bomb( "BAD GRID ID NUMBER\n" );
@


1.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a33 9
 *
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (c) 1994-2007 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d37 1
a37 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.12 2007/01/21 04:45:44 brlcad Exp $";
@


1.12
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 1
 * as published by the Free Software Foundation.
d46 1
a46 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.11 2007/01/20 14:36:54 brlcad Exp $";
@


1.11
log
@update copyright to 2007
@
text
@d1 19
d21 1
a21 1
/*@@{*/
d46 1
a46 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.10 2006/09/16 02:04:25 lbutler Exp $";
d639 11
a649 1
/*@@}*/
@


1.10
log
@Doxygen updates
@
text
@d22 1
a22 1
 *	This software is Copyright (c) 1994-2006 by the United States Army
d27 1
a27 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.9 2006/06/30 17:30:00 bob1961 Exp $";
@


1.9
log
@Always compile the fastgen4 import stuff.
@
text
@d1 1
a1 1
/** \addtogroup librt */
d3 1
a3 1
/** \file importFg4Section.
a24 1
/*@@}*/
d27 1
a27 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.8 2006/01/28 00:36:28 brlcad Exp $";
d620 1
@


1.8
log
@header cleanup, atof() requires stdlib.h on altix/posix, fix 64-bitness
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.7 2006/01/18 06:46:17 brlcad Exp $";
a541 1
#ifdef IMPORT_FASTGEN4_SECTION
a620 1
#endif
@


1.7
log
@update copyright to 2006
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.6 2005/12/23 21:26:31 bob1961 Exp $";
d34 1
d38 1
a38 1
#include <string.h>
d40 1
a40 1
#include <strings.h>
@


1.6
log
@Merge of bobWinPort
@
text
@d22 1
a22 1
 *	This software is Copyright (C) 1994-2004 by the United States Army
d28 1
a28 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.5 2005/10/23 04:44:35 brlcad Exp $";
@


1.5
log
@trailing ws
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.4 2005/08/12 22:31:08 lbutler Exp $";
d196 1
a196 1
	return wdb_export(fp, name, (genptr_t)bot, ID_BOT, fp->dbip->dbi_local2base);
@


1.4
log
@Doxygen changes
@
text
@d11 1
a11 1
 *  
d15 1
a15 1
 *  
d28 1
a28 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.3 2005/03/28 18:59:53 brlcad Exp $";
@


1.4.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d11 1
a11 1
 *
d15 1
a15 1
 *
d28 1
a28 1
static const char RCSid[] = "$Header$";
@


1.4.2.1
log
@Scaling of bot is not necessary here (it's already in base units)
@
text
@d28 1
a28 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.4 2005/08/12 22:31:08 lbutler Exp $";
d196 1
a196 1
	return wdb_export(fp, name, (genptr_t)bot, ID_BOT, 1.0);
@


1.3
log
@remove \r carriage returns, should only be \n. windows editors should be set to output 'unix' line endings, otherwise obscure problems ensue.
@
text
@d1 3
a3 2
/*
 *  Bob Parker mods:
d25 1
d28 1
a28 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.2 2005/03/28 05:51:03 bob1961 Exp $";
@


1.2
log
@Change mk_bot to rt_mk_bot to avoid name collision with routines in libwdb
@
text
@d1 619
a619 619
/*
 *  Bob Parker mods:
 *      Some of this code was taken from conv/fast4-g.c and libwdb/bot.c
 *      and modified to behave as a method of the BRL-CAD database object
 *      that imports a Fastgen4 section from a string. This section can
 *      only contain GRIDs, CTRIs and CQUADs.
 *
 *  Author of fast4-g.c -
 *      John R. Anderson
 *  
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Pacakge" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1994-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
 */

#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/librt/importFg4Section.c,v 1.1 2005/03/24 17:08:43 bob1961 Exp $";
#endif

#include "common.h"

/* system headers */
#include <stdio.h>
#include <math.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <ctype.h>
#include <errno.h>
#if defined(HAVE_UNISTD_H)
#  include <unistd.h>
#else
#  if defined(HAVE_SYS_UNISTD_H)
#    include <sys/unistd.h>
#  endif
#endif

/* interface headers */
#include "machine.h"
#include "db.h"
#include "vmath.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "wdb.h"
#include "plot3.h"

/* local headers */
#include "../librt/debug.h"


static int	grid_size;		/* Number of points that will fit in current grid_pts array */
static int	max_grid_no=0;		/* Maximum grid number used */
static int	mode=0;			/* Plate mode (1) or volume mode (2), of current component */
static int	group_id=(-1);		/* Group identification number from SECTION card */
static int	comp_id=(-1);		/* Component identification number from SECTION card */
static int	region_id=0;		/* Region id number (group id no X 1000 + component id no) */
static char	field[9];		/* Space for storing one field from an input line */
static int	name_count;		/* Count of number of times this name_name has been used */
static int	bot=0;			/* Flag: >0 -> There are BOT's in current component */
static int	warnings=0;		/* Flag: >0 -> Print warning messages */
static int	debug=0;		/* Debug flag */
static int	rt_debug=0;		/* RT_G_DEBUG */
static int	quiet=0;		/* flag to not blather */
static int	comp_count=0;		/* Count of components in FASTGEN4 file */

static int		*faces=NULL;	/* one triplet per face indexing three grid points */
static fastf_t		*thickness;	/* thickness of each face */
static char		*facemode;	/* mode for each face */
static int		face_size=0;	/* actual length of above arrays */
static int		face_count=0;	/* number of faces in above arrays */

static int	*int_list;		/* Array of integers */
static int	int_list_count=0;	/* Number of ints in above array */
static int	int_list_length=0;	/* Length of int_list array */

#define		PLATE_MODE	1
#define		VOLUME_MODE	2

#define		POS_CENTER	1	/* face positions for facets */
#define		POS_FRONT	2

#define		END_OPEN	1	/* End closure codes for cones */
#define		END_CLOSED	2

#define		GRID_BLOCK	256	/* allocate space for grid points in blocks of 256 points */

#define		CLINE		'l'
#define		CHEX1		'p'
#define		CHEX2		'b'
#define		CTRI		't'
#define		CQUAD		'q'
#define		CCONE1		'c'
#define		CCONE2		'd'
#define		CCONE3		'e'
#define		CSPHERE		's'
#define		NMG		'n'
#define		BOT		't'
#define		COMPSPLT	'h'

point_t *grid_pts;

void do_grid(char *line);
void do_tri(char *line);
void do_quad(char *line);
void make_bot_object(char		*name,
		     struct rt_wdb	*wdbp);

/*************************** code from libwdb/bot.c ***************************/

static int
rt_mk_bot_w_normals(
	struct rt_wdb *fp,
	const char *name,
	unsigned char	mode,
	unsigned char	orientation,
	unsigned char	flags,
	int		num_vertices,
	int		num_faces,
	fastf_t		*vertices,	/* array of floats for vertices [num_vertices*3] */
	int		*faces,		/* array of ints for faces [num_faces*3] */
	fastf_t		*thickness,	/* array of plate mode thicknesses (corresponds to array of faces)
					 * NULL for modes RT_BOT_SURFACE and RT_BOT_SOLID.
					 */
	struct bu_bitv	*face_mode,	/* a flag for each face indicating thickness is appended to hit point,
					 * otherwise thickness is centered about hit point
					 */
	int		num_normals,	/* number of unit normals in normals array */
	fastf_t		*normals,	/* array of floats for normals [num_normals*3] */
	int		*face_normals )	/* array of ints (indices into normals array), must have 3*num_faces entries */
{
	struct rt_bot_internal *bot;
	int i;

	if( (num_normals > 0) && (fp->dbip->dbi_version < 5 ) ) {
		bu_log( "You are using an old database format which does not support surface normals for BOT primitives\n" );
		bu_log( "You are attempting to create a BOT primitive named \"%s\" with surface normals\n" );
		bu_log( "The surface normals will not be saved\n" );
		bu_log( "Please upgrade to the current database format by using \"dbupgrade\"\n" );
	}

	BU_GETSTRUCT( bot, rt_bot_internal );
	bot->magic = RT_BOT_INTERNAL_MAGIC;
	bot->mode = mode;
	bot->orientation = orientation;
	bot->bot_flags = flags;
	bot->num_vertices = num_vertices;
	bot->num_faces = num_faces;
	bot->vertices = (fastf_t *)bu_calloc( num_vertices * 3, sizeof( fastf_t ), "bot->vertices" );
	for( i=0 ; i<num_vertices*3 ; i++ )
		bot->vertices[i] = vertices[i];
	bot->faces = (int *)bu_calloc( num_faces * 3, sizeof( int ), "bot->faces" );
	for( i=0 ; i<num_faces*3 ; i++ )
		bot->faces[i] = faces[i];
	if( mode == RT_BOT_PLATE )
	{
		bot->thickness = (fastf_t *)bu_calloc( num_faces, sizeof( fastf_t ), "bot->thickness" );
		for( i=0 ; i<num_faces ; i++ )
			bot->thickness[i] = thickness[i];
		bot->face_mode = bu_bitv_dup( face_mode );
	}
	else
	{
		bot->thickness = (fastf_t *)NULL;
		bot->face_mode = (struct bu_bitv *)NULL;
	}

	if( (num_normals > 0) && (fp->dbip->dbi_version >= 5 ) ) {
		bot->num_normals = num_normals;
		bot->num_face_normals = bot->num_faces;
		bot->normals = (fastf_t *)bu_calloc( bot->num_normals * 3, sizeof( fastf_t ), "BOT normals" );
		bot->face_normals = (int *)bu_calloc( bot->num_faces * 3, sizeof( int ), "BOT face normals" );
		memcpy( bot->normals, normals, bot->num_normals * 3 * sizeof( fastf_t ) );
		memcpy( bot->face_normals, face_normals, bot->num_faces * 3 * sizeof( int ) );
	} else {
		bot->bot_flags = 0;
		bot->num_normals = 0;
		bot->num_face_normals = 0;
		bot->normals = (fastf_t *)NULL;
		bot->face_normals = (int *)NULL;
	}

	return wdb_export(fp, name, (genptr_t)bot, ID_BOT, fp->dbip->dbi_local2base);
}

static int
rt_mk_bot(
	struct rt_wdb *fp,
	const char *name,
	unsigned char	mode,
	unsigned char	orientation,
	unsigned char	flags,
	int		num_vertices,
	int		num_faces,
	fastf_t		*vertices,	/* array of floats for vertices [num_vertices*3] */
	int		*faces,		/* array of ints for faces [num_faces*3] */
	fastf_t		*thickness,	/* array of plate mode thicknesses (corresponds to array of faces)
					 * NULL for modes RT_BOT_SURFACE and RT_BOT_SOLID.
					 */
	struct bu_bitv	*face_mode )	/* a flag for each face indicating thickness is appended to hit point,
					 * otherwise thickness is centered about hit point
					 */
{
	return( rt_mk_bot_w_normals( fp, name, mode, orientation, flags, num_vertices, num_faces, vertices,
				  faces, thickness, face_mode, 0, NULL, NULL ) );
}

/*************************** code from conv/fast4-g.c ***************************/

void
do_grid(char *line)
{
	int grid_no;
	fastf_t x,y,z;

	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at start of do_grid\n" );

	strncpy( field , &line[8] , 8 );
	grid_no = atoi( field );

	if( grid_no < 1 )
	{
		bu_log( "ERROR: grid id number = %d\n" , grid_no );
		rt_bomb( "BAD GRID ID NUMBER\n" );
	}

	strncpy( field , &line[24] , 8 );
	x = atof( field );

	strncpy( field , &line[32] , 8 );
	y = atof( field );

	strncpy( field , &line[40] , 8 );
	z = atof( field );

	while( grid_no > grid_size - 1 )
	{
		grid_size += GRID_BLOCK;
		grid_pts = (point_t *)bu_realloc( (char *)grid_pts , grid_size * sizeof( point_t ) , "fast4-g: grid_pts" );
	}

	VSET( grid_pts[grid_no] , x*25.4 , y*25.4 , z*25.4 );

	if( grid_no > max_grid_no )
		max_grid_no = grid_no;
	if( RT_G_DEBUG&DEBUG_MEM_FULL &&  bu_mem_barriercheck() )
		bu_log( "ERROR: bu_mem_barriercheck failed at end of do_grid\n" );
}

void
Add_bot_face(int pt1, int pt2, int pt3, fastf_t thick, int pos)
{

	if( pt1 == pt2 || pt2 == pt3 || pt1 == pt3 )
	{
		bu_log( "Add_bot_face: ignoring degenerate triangle in group %d component %d\n", group_id, comp_id );
		return;
	}

	if( pos == 0 )	/* use default */
		pos = POS_FRONT;

	if( mode == PLATE_MODE )
	{
		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "Add_bot_face: illegal postion parameter (%d), must be one or two (ignoring face for group %d component %d)\n" , pos, group_id, comp_id );
			return;
		}
	}

	if( face_count >= face_size )
	{
		face_size += GRID_BLOCK;
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted before realloc of faces, thickness, and facemode\n" );
		faces = (int *)bu_realloc( (void *)faces,  face_size*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_realloc( (void *)thickness, face_size*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_realloc( (void *)facemode, face_size*sizeof( char ), "facemode" );
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted after realloc of faces, thickness, and facemode\n" );
	}

	faces[face_count*3] = pt1;
	faces[face_count*3+1] = pt2;
	faces[face_count*3+2] = pt3;

	if( mode == PLATE_MODE )
	{
		thickness[face_count] = thick;
		facemode[face_count] = pos;
	}
	else
	{
		thickness[face_count] = 0,0;
		facemode[face_count] = 0;
	}

	face_count++;

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted at end of Add_bot_face()\n" );
}

void
do_tri(char *line)
{
	int element_id;
	int pt1,pt2,pt3;
	fastf_t thick;
	int pos;

	if( debug )
		bu_log( "do_tri: %s\n" , line );

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( !bot )
		bot = element_id;

	if( faces == NULL )
	{
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted before malloc of faces\n" );
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
		if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
			bu_log( "memory corrupted after malloc of faces , thickness, and facemode\n" );
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	thick = 0.0;
	pos = 0;

	if( mode == PLATE_MODE )
	{
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;

		strncpy( field , &line[64] , 8 );
		pos = atoi( field );
		if( pos == 0 )
			pos = POS_FRONT;

		if( debug )
			bu_log( "\tplate mode: thickness = %f\n" , thick );

	}

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted before call to Add_bot_face()\n" );

	Add_bot_face( pt1, pt2, pt3, thick, pos );

	if(bu_debug&BU_DEBUG_MEM_CHECK &&  bu_mem_barriercheck() )
		bu_log( "memory corrupted after call to Add_bot_face()\n" );
}

void
do_quad(char *line)
{
	int element_id;
	int pt1,pt2,pt3,pt4;
	fastf_t thick = 0.0;
	int pos = 0;

	strncpy( field , &line[8] , 8 );
	element_id = atoi( field );

	if( debug )
		bu_log( "do_quad: %s\n" , line );

	if( !bot )
		bot = element_id;

	if( faces == NULL )
	{
		faces = (int *)bu_malloc( GRID_BLOCK*3*sizeof( int ), "faces" );
		thickness = (fastf_t *)bu_malloc( GRID_BLOCK*sizeof( fastf_t ), "thickness" );
		facemode = (char *)bu_malloc( GRID_BLOCK*sizeof( char ), "facemode" );
		face_size = GRID_BLOCK;
		face_count = 0;
	}

	strncpy( field , &line[24] , 8 );
	pt1 = atoi( field );

	strncpy( field , &line[32] , 8 );
	pt2 = atoi( field );

	strncpy( field , &line[40] , 8 );
	pt3 = atoi( field );

	strncpy( field , &line[48] , 8 );
	pt4 = atoi( field );

	if( mode == PLATE_MODE )
	{
		strncpy( field , &line[56] , 8 );
		thick = atof( field ) * 25.4;

		strncpy( field , &line[64] , 8 );
		pos = atoi( field );

		if( pos == 0 )	/* use default */
			pos = POS_FRONT;

		if( pos != POS_CENTER && pos != POS_FRONT )
		{
			bu_log( "do_quad: illegal postion parameter (%d), must be one or two\n" , pos );
			bu_log( "\telement %d, component %d, group %d\n" , element_id , comp_id , group_id );
			return;
		}
	}

	Add_bot_face( pt1, pt2, pt3, thick, pos );
	Add_bot_face( pt1, pt3, pt4, thick, pos );
}

void
make_bot_object(char		*name,
		struct rt_wdb	*wdbp)
{
	int i;
	int max_pt=0, min_pt=999999;
	int num_vertices;
	struct bu_bitv *bv=NULL;
	int bot_mode;
	int element_id=bot;
	int count;
	struct rt_bot_internal bot_ip;

	bot_ip.magic = RT_BOT_INTERNAL_MAGIC;
	for( i=0 ; i<face_count ; i++ )
	{
		V_MIN( min_pt, faces[i*3] );
		V_MAX( max_pt, faces[i*3] );
		V_MIN( min_pt, faces[i*3+1] );
		V_MAX( max_pt, faces[i*3+1] );
		V_MIN( min_pt, faces[i*3+2] );
		V_MAX( max_pt, faces[i*3+2] );
	}

	num_vertices = max_pt - min_pt + 1;
	bot_ip.num_vertices = num_vertices;
	bot_ip.vertices = (fastf_t *)bu_calloc( num_vertices*3, sizeof( fastf_t ), "BOT vertices" );
	for( i=0 ; i<num_vertices ; i++ )
		VMOVE( &bot_ip.vertices[i*3], grid_pts[min_pt+i] )

	for( i=0 ; i<face_count*3 ; i++ )
		faces[i] -= min_pt;
	bot_ip.num_faces = face_count;
	bot_ip.faces = bu_calloc( face_count*3, sizeof( int ), "BOT faces" );
	for( i=0 ; i<face_count*3 ; i++ )
		bot_ip.faces[i] = faces[i];

	bot_ip.face_mode = (struct bu_bitv *)NULL;
	bot_ip.thickness = (fastf_t *)NULL;
	if( mode == PLATE_MODE )
	{
		bot_mode = RT_BOT_PLATE;
		bv = bu_bitv_new( face_count );
		bu_bitv_clear( bv );
		for( i=0 ; i<face_count ; i++ )
		{
			if( facemode[i] == POS_FRONT )
				BU_BITSET( bv, i );
		}
		bot_ip.face_mode = bv;
		bot_ip.thickness = (fastf_t *)bu_calloc( face_count, sizeof( fastf_t ), "BOT thickness" );
		for( i=0 ; i<face_count ; i++ )
			bot_ip.thickness[i] = thickness[i];
	}
	else
		bot_mode = RT_BOT_SOLID;

	bot_ip.mode = bot_mode;
	bot_ip.orientation = RT_BOT_UNORIENTED;
	bot_ip.bot_flags = 0;

	count = rt_bot_vertex_fuse( &bot_ip );
	if( count )
		(void)rt_bot_condense( &bot_ip );

	count = rt_bot_face_fuse( &bot_ip );
	if( count )
		bu_log( "WARNING: %d duplicate faces eliminated from group %d component %d\n", count, group_id, comp_id );

	rt_mk_bot(wdbp, name, bot_mode, RT_BOT_UNORIENTED, 0,
	       bot_ip.num_vertices, bot_ip.num_faces, bot_ip.vertices,
	       bot_ip.faces, bot_ip.thickness, bot_ip.face_mode);

	if( mode == PLATE_MODE )
	{
		bu_free( (char *)bot_ip.thickness, "BOT thickness" );
		bu_free( (char *)bot_ip.face_mode, "BOT face_mode" );
	}
	bu_free( (char *)bot_ip.vertices, "BOT vertices" );
	bu_free( (char *)bot_ip.faces, "BOT faces" );
}


/*************************** Start of new code. ***************************/

#define FIND_NEWLINE(_cp,_eosFlag) \
    while (*(_cp) != '\0' && \
	   *(_cp) != '\n') \
	++(_cp); \
\
    if (*(_cp) == '\0') \
	_eosFlag = 1; \
    else \
	*(_cp) = '\0';

#ifdef IMPORT_FASTGEN4_SECTION
int
wdb_importFg4Section_cmd(struct rt_wdb	*wdbp,
			 Tcl_Interp	*interp,
			 int		argc,
			 char 		**argv)
{
    char *cp;
    char *line;
    char *lines;
    int eosFlag = 0;

    if (argc != 3) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias wdb_importFg4Section %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
    }

    grid_size = GRID_BLOCK;
    grid_pts = (point_t *)bu_malloc(grid_size * sizeof(point_t) ,
				    "importFg4Section: grid_pts");

    lines = strdup(argv[2]);
    cp = line = lines;

    FIND_NEWLINE(cp,eosFlag);

    strncpy(field, line+8, 8);
    group_id = atoi(field);

    strncpy(field, line+16, 8);
    comp_id = atoi(field);

    region_id = group_id * 1000 + comp_id;

    if (comp_id > 999) {
	bu_log( "Illegal component id number %d, changed to 999\n" , comp_id );
	comp_id = 999;
    }

    strncpy(field, line+24, 8);
    mode = atoi(field);
    if (mode != 1 && mode != 2) {
	bu_log("Illegal mode (%d) for group %d component %d, using volume mode\n",
	       mode, group_id, comp_id);
	mode = 2;
    }

    while (!eosFlag) {
	++cp;
	line = cp;
	FIND_NEWLINE(cp,eosFlag);

	if (!strncmp(line , "GRID" , 4))
	    do_grid(line);
	else if (!strncmp(line , "CTRI" , 4))
	    do_tri(line);
	else if (!strncmp(line , "CQUAD" , 4))
	    do_quad(line);
    }

    make_bot_object(argv[1], wdbp);
    free((void *)lines);
    bu_free((void *)grid_pts, "importFg4Section: grid_pts");

    /* free memory associated with globals */
    bu_free((void *)faces, "importFg4Section: faces");
    bu_free((void *)thickness, "importFg4Section: thickness");
    bu_free((void *)facemode, "importFg4Section: facemode");

    faces = NULL;
    thickness = NULL;
    facemode = NULL;

    return TCL_OK;
}
#endif
@


1.1
log
@Initial check-in of code that imports a fg4 section from a string. This adds a method to the database object.
@
text
@d26 1
a26 1
static const char RCSid[] = "$Header: /n/xoff/cvs/brlcad/src/conv/fast4-g.c,v 1.5 2004/08/02 23:01:47 morrison Exp $";
d123 1
a123 1
mk_bot_w_normals(
d198 1
a198 1
mk_bot(
d215 1
a215 1
	return( mk_bot_w_normals( fp, name, mode, orientation, flags, num_vertices, num_faces, vertices,
d513 1
a513 1
	mk_bot(wdbp, name, bot_mode, RT_BOT_UNORIENTED, 0,
@

