head	14.21;
access;
symbols
	rel-7-10-4:14.19
	STABLE:14.19.0.2
	stable-branch:14.6
	rel-7-10-2:14.19
	rel-7-10-0:14.17
	rel-7-8-4:14.13
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.8.2.1
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.4
	rel-7-6-0:14.8
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.2
	bobWinPort:14.8.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.21
date	2007.12.16.18.53.49;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.09.14.15.21.07;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.07.26.01.13.57;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.19.02.05.24;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.27.01.41.38;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.12;

14.12
date	2006.03.24.23.21.34;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches
	14.11.2.1;
next	14.10;

14.10
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.08.12.22.31.07;	author lbutler;	state Exp;
branches
	14.8.2.1
	14.8.4.1;
next	14.7;

14.7
date	2005.05.08.05.49.07;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.57;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.19;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.56;	author morrison;	state Exp;
branches;
next	;

14.8.2.1
date	2005.09.08.16.23.20;	author bob1961;	state Exp;
branches;
next	;

14.8.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;

14.11.2.1
date	2006.04.07.19.30.23;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.21
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                       D B 5 _ B I N . C
 * BRL-CAD
 *
 * Copyright (c) 2000-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup db5 */
/** @@{ */
/** @@file db5_bin.c
 *	Handle bulk binary objects
 *
 *  Author -
 *	Paul J. Tanenbaum
 *
 */
/** @@} */

#ifndef lint
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.20 2007/09/14 15:21:07 erikgreenwald Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "db5.h"
#include "nmg.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "nurb.h"
#include "./debug.h"


/* this array depends on the values of the definitions of the DB5_MINORTYPE_BINU_... in db5.h */
const char *binu_types[]={
	NULL,
	NULL,
	"binary(float)",
	"binary(double)",
	"binary(u_8bit_int)",
	"binary(u_16bit_int)",
	"binary(u_32bit_int)",
	"binary(u_64bit_int)",
	NULL,
	NULL,
	NULL,
	NULL,
	"binary(8bit_int)",
	"binary(16bit_int)",
	"binary(32bit_int)",
	"binary(64bit_int)"
};

/* size of each element (in bytes) for the different BINUNIF types */
/* this array depends on the values of the definitions of the DB5_MINORTYPE_BINU_... in db5.h */
const int binu_sizes[]={
	0,
	0,
	SIZEOF_NETWORK_FLOAT,
	SIZEOF_NETWORK_DOUBLE,
	1,
	2,
	4,
	8,
	0,
	0,
	0,
	0,
	1,
	2,
	4,
	8
};
/*
 * XXX these are the interface routines needed for table.c
 */
int
rt_bin_expm_export5(struct bu_external *ep,
			const struct rt_db_internal *ip,
			double local2mm,
			const struct db_i *dbip,
			struct resource *resp)
{
	bu_log("rt_bin_expm_export5() not implemented\n");
	return -1;
}

int
rt_bin_unif_export5(struct bu_external *ep,
			const struct rt_db_internal *ip,
			double local2mm,
			const struct db_i *dbip,
			struct resource *resp)
{
	bu_log("rt_bin_unif_export5() not implemented\n");
	return -1;
}
int
rt_bin_unif_import5(struct rt_db_internal * ip,
			const struct bu_external *ep,
			const mat_t mat,
			const struct db_i *dbip,
			      struct resource *resp)
{
	bu_log("rt_bin_unif_import5() not implemented\n");
	return -1;
}
int
rt_bin_expm_import5(struct rt_db_internal * ip,
			const struct bu_external *ep,
			const mat_t mat,
			const struct db_i *dbip,
			      struct resource *resp)
{
	bu_log("rt_bin_expm_import5() not implemented\n");
	return -1;
}

int
rt_bin_mime_import5(struct rt_db_internal * ip,
			const struct bu_external *ep,
			const mat_t mat,
			const struct db_i *dbip,
			      struct resource *resp)
{
	bu_log("rt_bin_mime_import5() not implemented\n");
	return -1;
}

/**
 *			R T _ B I N U N I F _ I M P O R T 5
 *
 *  Import a uniform-array binary object from the database format to
 *  the internal structure.
 */
int
rt_binunif_import5( struct rt_db_internal	*ip,
		    const struct bu_external	*ep,
		    const mat_t			mat,
		    const struct db_i		*dbip,
		    struct resource		*resp,
		    const int			minor_type)
{
	struct rt_binunif_internal	*bip;
	int				i;
	unsigned char			*srcp;
	unsigned long			*ldestp;
	int				in_cookie, out_cookie;
	int				gotten;

	BU_CK_EXTERNAL( ep );

	/*
	 *	There's no particular size to expect
	 *
	 * BU_ASSERT_LONG( ep->ext_nbytes, ==, SIZEOF_NETWORK_DOUBLE * 3*4 );
	 */

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BINARY_UNIF;
	ip->idb_minor_type = minor_type;
	ip->idb_meth = &rt_functab[ID_BINUNIF];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_binunif_internal),
	    "rt_binunif_internal");

	bip = (struct rt_binunif_internal *)ip->idb_ptr;
	bip->magic = RT_BINUNIF_INTERNAL_MAGIC;
	bip->type = minor_type;

	/*
	 * Convert from database (network) to internal (host) format
	 */
	switch (bip->type) {
	    case DB5_MINORTYPE_BINU_FLOAT:
		bip->count = ep->ext_nbytes/SIZEOF_NETWORK_FLOAT;
		bip->u.uint8 = (unsigned char *) bu_malloc( bip->count * sizeof(float),
		    "rt_binunif_internal" );
		ntohf( (unsigned char *) bip->u.uint8,
			ep->ext_buf, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_DOUBLE:
		bip->count = ep->ext_nbytes/SIZEOF_NETWORK_DOUBLE;
		bip->u.uint8 = (unsigned char *) bu_malloc( bip->count * sizeof(double),
		    "rt_binunif_internal" );
		ntohd( (unsigned char *) bip->u.uint8,
			ep->ext_buf, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_8BITINT:
	    case DB5_MINORTYPE_BINU_8BITINT_U:
		bip->count = ep->ext_nbytes;
		bip->u.uint8 = (unsigned char *) bu_malloc( ep->ext_nbytes,
		    "rt_binunif_internal" );
		memcpy((char *) bip->u.uint8, (char *) ep->ext_buf, ep->ext_nbytes);
		break;
	    case DB5_MINORTYPE_BINU_16BITINT:
	    case DB5_MINORTYPE_BINU_16BITINT_U:
		bip->count = ep->ext_nbytes/2;
		bip->u.uint8 = (unsigned char *) bu_malloc( ep->ext_nbytes,
		    "rt_binunif_internal" );
#if 0
		srcp = (unsigned char *) ep->ext_buf;
		sdestp = (unsigned short *) bip->u.uint8;
		for (i = 0; i < bip->count; ++i, ++sdestp, srcp += 2) {
		    *sdestp = bu_gshort( srcp );
		    bu_log("Just got %d", *sdestp);
		}
#endif
		in_cookie = bu_cv_cookie("nus");
		out_cookie = bu_cv_cookie("hus");
		if (bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie)) {
		    gotten =
		    bu_cv_w_cookie((genptr_t)bip->u.uint8, out_cookie,
				   ep->ext_nbytes,
				   ep->ext_buf, in_cookie, bip->count);
		    if (gotten != bip->count) {
			bu_log("%s:%d: Tried to convert %d, did %d",
			    __FILE__, __LINE__, bip->count, gotten);
			bu_bomb("\n");
		    }
		} else
		    memcpy((char *) bip->u.uint8,
			   (char *) ep->ext_buf,
			   ep->ext_nbytes );
		break;
	    case DB5_MINORTYPE_BINU_32BITINT:
	    case DB5_MINORTYPE_BINU_32BITINT_U:
		bip->count = ep->ext_nbytes/4;
		bip->u.uint8 = (unsigned char *) bu_malloc( ep->ext_nbytes,
		    "rt_binunif_internal" );
		srcp = (unsigned char *) ep->ext_buf;
		ldestp = (unsigned long *) bip->u.uint8;
		for (i = 0; i < bip->count; ++i, ++ldestp, srcp += 4) {
		    *ldestp = bu_glong( srcp );
		    bu_log("Just got %ld", *ldestp);
		}
		break;
	    case DB5_MINORTYPE_BINU_64BITINT:
	    case DB5_MINORTYPE_BINU_64BITINT_U:
		bu_log("rt_binunif_import5() Can't handle 64-bit integers yet\n");
		return -1;
	}

	return 0;		/* OK */
}

/**
 *			R T _ B I N U N I F _ D U M P
 *
 *  Diagnostic routine
 */
void
rt_binunif_dump( struct rt_binunif_internal *bip) {
    RT_CK_BINUNIF(bip);
    bu_log("rt_bin_unif_internal <%x>...\n", bip);
    bu_log("  type = x%x = %d", bip -> type, bip -> type);
    bu_log("  count = %ld  first = 0x%02x", bip -> count,
	   bip->u.uint8[0] & 0x0ff);
    bu_log("- - - - -\n");
}


/**
 *			R T _ B I N E X P M _ I M P O R T 5
 *
 *  Import an experimental binary object from the database format to
 *  the internal structure.
 */
int
rt_binexpm_import5( struct rt_db_internal	*ip,
		    const unsigned char		minor_type,
		    const struct bu_external	*ep,
		    const struct db_i		*dbip )
{
	bu_log("rt_binexpm_import5() not implemented yet\n");
	return -1;
}


/**
 *			R T _ B I N M I M E _ I M P O R T 5
 *
 *  Import a MIME-typed binary object from the database format to
 *  the internal structure.
 */
int
rt_binmime_import5( struct rt_db_internal	*ip,
		    const unsigned char		minor_type,
		    const struct bu_external	*ep,
		    const struct db_i		*dbip )
{
	bu_log("rt_binmime_import5() not implemented yet\n");
	return -1;
}


/**
 *			R T _ B I N _ I M P O R T 5
 *
 *  Wrapper for importing binary objects from the database format to
 *  the internal structure.
 */
int
rt_bin_import5( struct rt_db_internal		*ip,
		const unsigned char		major_type,
		const unsigned char		minor_type,
		const struct bu_external	*ep,
		const struct db_i		*dbip )
{
    RT_CK_DB_INTERNAL(ip);

    switch (major_type) {
	case DB5_MAJORTYPE_BINARY_EXPM:
	    return rt_binexpm_import5( ip, minor_type, ep, dbip );
	case DB5_MAJORTYPE_BINARY_UNIF:
	    return rt_binunif_import5( ip, ep, 0, dbip, 0, minor_type );
	case DB5_MAJORTYPE_BINARY_MIME:
	    return rt_binmime_import5( ip, minor_type, ep, dbip );
    }
    return -1;
}

/**
 *			R T _ B I N U N I F _ E X P O R T 5
 *
 *	Create the "body" portion of external form
 */
int
rt_binunif_export5( struct bu_external		*ep,
		    const struct rt_db_internal	*ip,
		    double			local2mm,	/* we ignore */
		    const struct db_i		*dbip,
		    struct resource		*resp,
		    const int			minor_type )
{
	struct rt_binunif_internal	*bip;
	int				i;
	unsigned char			*destp;
	unsigned long			*lsrcp;
	int				in_cookie, out_cookie;
	int				gotten;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_minor_type != minor_type ) {
		bu_log("ip->idb_minor_type(%d) != minor_type(%d)\n",
		       ip->idb_minor_type, minor_type );
		return -1;
	}
	bip = (struct rt_binunif_internal *)ip->idb_ptr;
	RT_CK_BINUNIF(bip);
	if( bip->type != minor_type ) {
		bu_log("bip->type(%d) != minor_type(%d)\n",
		       bip->type, minor_type );
		return -1;
	}

	BU_INIT_EXTERNAL(ep);

	/*
	 * Convert from internal (host) to database (network) format
	 */
	switch (bip->type) {
	    case DB5_MINORTYPE_BINU_FLOAT:
		ep->ext_nbytes = bip->count * SIZEOF_NETWORK_FLOAT;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
		htonf( ep->ext_buf, (unsigned char *) bip->u.uint8, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_DOUBLE:
		ep->ext_nbytes = bip->count * SIZEOF_NETWORK_DOUBLE;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
		htond( ep->ext_buf, (unsigned char *) bip->u.uint8, bip->count );
		break;
	    case DB5_MINORTYPE_BINU_8BITINT:
	    case DB5_MINORTYPE_BINU_8BITINT_U:
		ep->ext_nbytes = bip->count;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
		memcpy((char *) ep->ext_buf, (char *) bip->u.uint8, bip->count);
		break;
	    case DB5_MINORTYPE_BINU_16BITINT:
	    case DB5_MINORTYPE_BINU_16BITINT_U:
		ep->ext_nbytes = bip->count * 2;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "binunif external");
		in_cookie = bu_cv_cookie("hus");
		out_cookie = bu_cv_cookie("nus");
		if (bu_cv_optimize(in_cookie) != bu_cv_optimize(out_cookie)) {
		    gotten =
			    bu_cv_w_cookie(ep->ext_buf, out_cookie,
					   ep->ext_nbytes,
					   (genptr_t) bip->u.uint8, in_cookie,
					   bip->count);

		    if (gotten != bip->count) {
			bu_log("%s:%d: Tried to convert %d, did %d",
			    __FILE__, __LINE__, bip->count, gotten);
			bu_bomb("\n");
		    }
		} else {
		    memcpy((char *) ep->ext_buf,
			   (char *) bip->u.uint8,
			   ep->ext_nbytes );
		}
		break;
	    case DB5_MINORTYPE_BINU_32BITINT:
	    case DB5_MINORTYPE_BINU_32BITINT_U:
		ep->ext_nbytes = bip->count * 4;
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes, "binunif external");

		lsrcp = (unsigned long *) bip->u.uint8;
		destp = (unsigned char *) ep->ext_buf;
		for (i = 0; i < bip->count; ++i, ++destp, ++lsrcp) {
		    (void) bu_plong( destp, *lsrcp );
		}
		break;
	    case DB5_MINORTYPE_BINU_64BITINT:
	    case DB5_MINORTYPE_BINU_64BITINT_U:
		bu_log("rt_binunif_export5() Can't handle 64-bit integers yet\n");
		return -1;
	}

	return 0;
}

/**
 *			R T _ B I N U N I F _ D E S C R I B E
 *
 *  Make human-readable formatted presentation of this object.
 *  First line describes type of object.
 *  Additional lines are indented one tab, and give parameter values.
 */
int
rt_binunif_describe( struct bu_vls		*str,
		    const struct rt_db_internal	*ip,
		    int				verbose,
		    double			mm2local )
{
	register struct rt_binunif_internal	*bip;
	char					buf[256];
	unsigned short				wid;

	bip = (struct rt_binunif_internal *) ip->idb_ptr;
	RT_CK_BINUNIF(bip);
	bu_vls_strcat( str, "uniform-array binary object (BINUNIF)\n");
	wid = (bip->type & DB5_MINORTYPE_BINU_WID_MASK) >> 4;
	switch (wid) {
	    case 0:
		sprintf( buf, "%ld ", bip->count ); break;
	    case 1:
		sprintf( buf, "%ld pairs of ", bip->count / 2 ); break;
	    case 2:
		sprintf( buf, "%ld triples of ", bip->count / 3 ); break;
	    case 3:
		sprintf( buf, "%ld quadruples of ", bip->count / 4 ); break;
	}
	bu_vls_strcat( str, buf );
	switch (bip->type & DB5_MINORTYPE_BINU_ATM_MASK) {
	    case DB5_MINORTYPE_BINU_FLOAT:
		bu_vls_strcat( str, "floats\n"); break;
	    case DB5_MINORTYPE_BINU_DOUBLE:
		bu_vls_strcat( str, "doubles\n"); break;
	    case DB5_MINORTYPE_BINU_8BITINT:
		bu_vls_strcat( str, "8-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_16BITINT:
		bu_vls_strcat( str, "16-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_32BITINT:
		bu_vls_strcat( str, "32-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_64BITINT:
		bu_vls_strcat( str, "64-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_8BITINT_U:
		bu_vls_strcat( str, "unsigned 8-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_16BITINT_U:
		bu_vls_strcat( str, "unsigned 16-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_32BITINT_U:
		bu_vls_strcat( str, "unsigned 32-bit ints\n"); break;
	    case DB5_MINORTYPE_BINU_64BITINT_U:
		bu_vls_strcat( str, "unsigned 64-bit ints\n"); break;
	    default:
		bu_log("%s:%d: This shouldn't happen", __FILE__, __LINE__);
		return(1);
	}

	return(0);
}

/**
 *		R T _ B I N U N I F _ F R E E
 *
 *	Free the storage associated with a binunif_internal object
 */
void
rt_binunif_free( struct rt_binunif_internal *bip) {
	RT_CK_BINUNIF(bip);
	bu_free( (genptr_t) bip->u.uint8, "binunif free uint8" );
	bu_free( bip, "binunif free");
	bip = GENPTR_NULL; /* sanity */
}

/**
 *			R T _ B I N U N I F _ I F R E E
 *
 *  Free the storage associated with the rt_db_internal version of this thing.
 */
void
rt_binunif_ifree( struct rt_db_internal	*ip )
{
	struct rt_binunif_internal	*bip;

	RT_CK_DB_INTERNAL(ip);
	bip = (struct rt_binunif_internal *)ip->idb_ptr;
	RT_CK_BINUNIF(bip);
	bu_free( (genptr_t) bip->u.uint8, "binunif ifree" );
	bu_free( ip->idb_ptr, "binunif ifree" );
	ip->idb_ptr = GENPTR_NULL;
}


int
rt_retrieve_binunif(struct rt_db_internal *intern,
		    struct db_i	*dbip,
		    char *name)
{
	register struct directory	*dp;
	struct rt_binunif_internal	*bip;
	struct bu_external		ext;
	struct db5_raw_internal		raw;
	char				*tmp;

	/*
	 *	Find the guy we're told to write
	 */
	if( (dp = db_lookup( dbip, name, LOOKUP_NOISY)) == DIR_NULL )
		return -1;

	RT_INIT_DB_INTERNAL(intern);
	if ( rt_db_get_internal5( intern, dp, dbip, NULL, &rt_uniresource)
	     != ID_BINUNIF     || db_get_external( &ext, dp, dbip ) < 0 )
		return -1;

	if (db5_get_raw_internal_ptr(&raw, ext.ext_buf) == NULL) {
	    bu_log("%s:%d\n", __FILE__, __LINE__);
		bu_free_external( &ext );
		return -1;
	}
	if (db5_type_descrip_from_codes(&tmp, raw.major_type, raw.minor_type))
		tmp = 0;

	if (RT_G_DEBUG & DEBUG_VOL)
		bu_log("get_body() sees type (%d, %d)='%s'\n",
		       raw.major_type, raw.minor_type, tmp);

	if (raw.major_type != DB5_MAJORTYPE_BINARY_UNIF)
		return -1;

	bip = intern->idb_ptr;
	RT_CK_BINUNIF(bip);
	if (RT_G_DEBUG & DEBUG_HF)
		rt_binunif_dump(bip);

	if (RT_G_DEBUG & DEBUG_VOL)
		bu_log("cmd_export_body() thinks bip->count=%d\n",
		       bip->count);

	switch (bip -> type) {
	case DB5_MINORTYPE_BINU_FLOAT:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... float");
		break;
	case DB5_MINORTYPE_BINU_DOUBLE:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... double");
		break;
	case DB5_MINORTYPE_BINU_8BITINT:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 8bitint");
		break;
	case DB5_MINORTYPE_BINU_8BITINT_U:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 8bituint");
		break;
	case DB5_MINORTYPE_BINU_16BITINT:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 16bituint");
		break;
	case DB5_MINORTYPE_BINU_16BITINT_U:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 16bitint");
		break;
	case DB5_MINORTYPE_BINU_32BITINT:
	case DB5_MINORTYPE_BINU_32BITINT_U:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 32bitint");
		break;
	case DB5_MINORTYPE_BINU_64BITINT:
	case DB5_MINORTYPE_BINU_64BITINT_U:
		if (RT_G_DEBUG & DEBUG_VOL)
			bu_log("bip->type switch... 64bitint");
		break;
	default:
		/* XXX	This shouln't happen!!    */
		bu_log("bip->type switch... default");
		break;
	}

	bu_free_external( &ext );

	return 0;
}

void
rt_binunif_make(const struct rt_functab *ftp, struct rt_db_internal *intern, double diameter)
{
	struct rt_binunif_internal *bip;

	intern->idb_type = DB5_MINORTYPE_BINU_8BITINT;
	intern->idb_major_type = DB5_MAJORTYPE_BINARY_UNIF;
	BU_ASSERT(&rt_functab[ID_BINUNIF] == ftp);

	intern->idb_meth = ftp;
	bip = (struct rt_binunif_internal *)bu_calloc( sizeof( struct rt_binunif_internal), 1,
						       "rt_binunif_make");
	intern->idb_ptr = (genptr_t) bip;
	bip->magic = RT_BINUNIF_INTERNAL_MAGIC;
	bip->type = DB5_MINORTYPE_BINU_8BITINT;
	bip->count = 0;
	bip->u.int8 = NULL;
}

int
rt_binunif_tclget(Tcl_Interp *interp, const struct rt_db_internal *intern, const char *attr )
{
	register struct rt_binunif_internal *bip=(struct rt_binunif_internal *)intern->idb_ptr;
	struct bu_external	ext;
	Tcl_DString		ds;
	struct bu_vls		vls;
	int			status=TCL_OK;
	int			i;
	unsigned char		*c;

	RT_CHECK_BINUNIF( bip );

	Tcl_DStringInit( &ds );
	bu_vls_init( &vls );

	if( attr == (char *)NULL )
	{
		/* export the object to get machine independent form */
		if( rt_binunif_export5( &ext, intern, 1.0, NULL, NULL, intern->idb_minor_type ) ) {
			bu_vls_strcpy( &vls, "Failed to export binary object!!\n" );
			status = TCL_ERROR;
		} else {
			bu_vls_strcpy( &vls, "binunif" );
			bu_vls_printf( &vls, " T %d D {", bip->type );
			c = ext.ext_buf;
			for( i=0 ; i<ext.ext_nbytes ; i++,c++ ) {
				if( i%40 == 0 ) bu_vls_strcat( &vls, "\n" );
				bu_vls_printf( &vls, "%2.2x", *c );
			}
			bu_vls_strcat( &vls, "}" );
			bu_free_external( &ext );
		}

	} else {
		if( !strcmp( attr, "T" ) ) {
			bu_vls_printf( &vls, "%d", bip->type );
		} else if( !strcmp( attr, "D" ) ) {
			/* export the object to get machine independent form */
			if( rt_binunif_export5( &ext, intern, 1.0, NULL, NULL,
						intern->idb_minor_type ) ) {
				bu_vls_strcpy( &vls, "Failed to export binary object!!\n" );
				status = TCL_ERROR;
			} else {
				c = ext.ext_buf;
				for( i=0 ; i<ext.ext_nbytes ; i++,c++ ) {
					if( i != 0 && i%40 == 0 ) bu_vls_strcat( &vls, "\n" );
					bu_vls_printf( &vls, "%2.2x", *c );
				}
				bu_free_external( &ext );
			}
		} else {
			bu_vls_printf( &vls, "Binary object has no attribute '%s'", attr );
			status = TCL_ERROR;
		}
	}

	Tcl_DStringAppend( &ds, bu_vls_addr( &vls ), -1 );
	Tcl_DStringResult( interp, &ds );
	Tcl_DStringFree( &ds );
	bu_vls_free( &vls );

	return( status );
}

int
rt_binunif_tcladjust( Tcl_Interp *interp, struct rt_db_internal *intern, int argc, char **argv )
{
	struct rt_binunif_internal *bip;
	int i;

	RT_CK_DB_INTERNAL( intern );
	bip = (struct rt_binunif_internal *)intern->idb_ptr;
	RT_CHECK_BINUNIF( bip );

	while( argc >= 2 ) {
		if( !strcmp( argv[0], "T" ) ) {
			int new_type=-1;
			char *c;
			int type_is_digit=1;

			c = argv[1];
			while( *c != '\0' ) {
				if( !isdigit( *c ) ) {
					type_is_digit = 0;
					break;
				}
				c++;
			}

			if( type_is_digit ) {
				new_type = atoi( argv[1] );
			} else {
				if( argv[1][1] != '\0' ) {
					Tcl_AppendResult( interp, "Illegal type: ",
					   argv[1],
					   ", must be 'f', 'd', 'c', 'i', 'l', 'C', 'S', 'I', or 'L'",
					   (char *)NULL );
					return TCL_ERROR;
				}
				switch( argv[1][0] ) {
					case 'f':
						new_type = 2;
						break;
					case 'd':
						new_type = 3;
						break;
					case 'c':
						new_type = 4;
						break;
					case 's':
						new_type = 5;
						break;
					case 'i':
						new_type = 6;
						break;
					case 'l':
						new_type = 7;
						break;
					case 'C':
						new_type = 12;
						break;
					case 'S':
						new_type = 13;
						break;
					case 'I':
						new_type = 14;
						break;
					case 'L':
						new_type = 15;
						break;
				}
			}
			if( new_type < 0 ||
			    new_type > DB5_MINORTYPE_BINU_64BITINT ||
			    binu_types[new_type] == NULL ) {
				/* Illegal value for type */
				Tcl_AppendResult( interp, "Illegal value for binary type: ", argv[1],
						  (char *)NULL );
				return TCL_ERROR;
			} else {
				if( bip->u.uint8 ) {
					int new_count;
					int old_byte_count, new_byte_count;
					int remainder;

					old_byte_count = bip->count * binu_sizes[bip->type];
					new_count = old_byte_count / binu_sizes[new_type];
					remainder = old_byte_count % binu_sizes[new_type];
					if( remainder ) {
						new_count++;
						new_byte_count = new_count * binu_sizes[new_type];
					} else {
						new_byte_count = old_byte_count;
					}

					if( new_byte_count != old_byte_count ) {
						bip->u.uint8 = bu_realloc( bip->u.uint8,
									   new_byte_count,
									   "new bytes for binunif" );
						/* zero out the new bytes */
						for( i=old_byte_count ; i<new_byte_count ; i++ ) {
							bip->u.uint8[i] = 0;
						}
					}
					bip->count = new_count;
				}
				bip->type = new_type;
				intern->idb_type = new_type;
			}
		} else if( !strcmp( argv[0], "D" ) ) {
			Tcl_Obj *obj, *list, **obj_array;
			int list_len;
			unsigned char *buf, *d;
			char *s;
			int hexlen;
			unsigned int h;

			obj = Tcl_NewStringObj( argv[1], -1 );
			list = Tcl_NewListObj( 0, NULL );
			Tcl_ListObjAppendList( interp, list, obj );
			(void)Tcl_ListObjGetElements( interp, list, &list_len, &obj_array );

			hexlen = 0;
			for( i=0 ; i<list_len ; i++ ) {
				hexlen += Tcl_GetCharLength( obj_array[i] );
			}

			if( hexlen % 2 ) {
				Tcl_AppendResult( interp,
				    "Hex form of binary data must have an even number of hex digits",
				    (char *)NULL );
				return TCL_ERROR;
			}

			buf = (unsigned char *)bu_malloc( hexlen / 2, "tcladjust binary data" );
			d = buf;
			for( i=0 ; i<list_len ; i++ ) {
				s = Tcl_GetString( obj_array[i] );
				while( *s ) {
					sscanf( s, "%2x", &h );
					*d++ = h;
					s += 2;
				}
			}
			Tcl_DecrRefCount( list );

			if( bip->u.uint8 ) {
				bu_free( bip->u.uint8, "binary data" );
			}
			bip->u.uint8 = buf;
			bip->count = hexlen / 2 / binu_sizes[bip->type];
		}

		argc -= 2;
		argv += 2;
	}

	return TCL_OK;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.20
log
@removed trailing whitespace
@
text
@d32 1
a32 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.19 2007/07/26 01:13:57 brlcad Exp $ (BRL)";
d213 1
a213 1
		memcpy( (char *) bip->u.uint8, (char *) ep->ext_buf, ep->ext_nbytes );
d399 1
a399 1
		memcpy( (char *) ep->ext_buf, (char *) bip->u.uint8, bip->count );
@


14.19
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d32 1
a32 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.18 2007/05/19 02:05:24 brlcad Exp $ (BRL)";
d421 1
a421 1
			   (char *) bip->u.uint8, 
@


14.18
log
@welcome to 1990, replace calls to bcopy with memcpy.  interestingly enough, valgrind on amd64 linux is showing bcopy() reading more than len bytes (reading to aligned memory internally)
@
text
@a27 3
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
d32 1
a32 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.17 2007/01/27 01:41:38 brlcad Exp $ (BRL)";
@


14.17
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.16 2007/01/23 01:13:36 brlcad Exp $ (BRL)";
d216 1
a216 1
		bcopy( (char *) ep->ext_buf, (char *) bip->u.uint8, ep->ext_nbytes );
d244 3
a246 2
		    bcopy( (char *) ep->ext_buf, (char *) bip->u.uint8,
			ep->ext_nbytes );
d402 1
a402 1
		bcopy( (char *) bip->u.uint8, (char *) ep->ext_buf, bip->count );
d423 3
a425 2
		    bcopy( (char *) bip->u.uint8, (char *) ep->ext_buf,
			ep->ext_nbytes );
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.15 2007/01/21 04:45:43 brlcad Exp $ (BRL)";
d123 2
a124 2
 			const struct bu_external *ep,
 			const mat_t mat,
d133 2
a134 2
 			const struct bu_external *ep,
 			const mat_t mat,
d144 2
a145 2
 			const struct bu_external *ep,
 			const mat_t mat,
@


14.15
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d35 1
a35 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.14 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.14
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
a31 1
 *
d33 1
a33 1
/*@@}*/
d36 1
a36 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.13 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
@


14.13
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2006 United States Government as represented by
d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.12 2006/03/24 23:21:34 brlcad Exp $ (BRL)";
@


14.12
log
@lots of intel 9 for altix compiler warning quellings
@
text
@d22 1
a22 1
/** \addtogroup db5 */
d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.11 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
@


14.11
log
@update copyright to 2006
@
text
@d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.10 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d44 1
@


14.11.2.1
log
@update from HEAD
@
text
@d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.11 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
a43 1
#include <stdlib.h>
@


14.10
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 2000-2005 United States Government as represented by
d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.9 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
@


14.9
log
@trailing ws
@
text
@d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.8 2005/08/12 22:31:07 lbutler Exp $ (BRL)";
d54 1
a56 1
#include "rtgeom.h"
@


14.8
log
@Doxygen changes
@
text
@d34 1
a34 1
 *  
d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.7 2005/05/08 05:49:07 brlcad Exp $ (BRL)";
d511 1
a511 1
 *		R T _ B I N U N I F _ F R E E 
d560 1
a560 1
	if ( rt_db_get_internal5( intern, dp, dbip, NULL, &rt_uniresource) 
@


14.8.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d34 1
a34 1
 *
d39 1
a39 1
static const char RCSell[] = "@@(#)$Header$ (BRL)";
d511 1
a511 1
 *		R T _ B I N U N I F _ F R E E
d560 1
a560 1
	if ( rt_db_get_internal5( intern, dp, dbip, NULL, &rt_uniresource)
@


14.8.2.1
log
@Mods for windows port
@
text
@d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.8 2005/08/12 22:31:07 lbutler Exp $ (BRL)";
a53 1
#include "rtgeom.h"
d56 1
@


14.7
log
@remove some old code cruft and debug printing.
@
text
@d21 4
a25 2
 *
 *  Purpose -
d36 2
d39 1
a39 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.6 2005/01/30 20:30:57 brlcad Exp $ (BRL)";
d156 1
a156 1
/*
d271 1
a271 1
/*
d287 1
a287 1
/*
d304 1
a304 1
/*
d321 1
a321 1
/*
d347 1
a347 1
/*
d449 1
a449 1
/*
d510 1
a510 1
/*
d523 1
a523 1
/*
@


14.6
log
@update copyright to 2005
@
text
@d35 1
a35 1
static const char RCSell[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db5_bin.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
a39 2


d44 1
d55 1
d405 1
a405 10
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
#if 0
		ssrcp = (unsigned short *) bip->u.uint8;
		destp = (unsigned char *) ep->ext_buf;
		for (i = 0; i < bip->count; ++i, ++destp, ++ssrcp) {
		    (void) bu_pshort( destp, *ssrcp );
		    bu_log("Just put from %d", *ssrcp);
		}
#else
a423 1
#endif
d428 1
a428 2
		ep->ext_buf = (genptr_t)bu_malloc( ep->ext_nbytes,
		    "binunif external");
a433 1
		    bu_log("Just put from %ld", *lsrcp);
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2004 United States Government as represented by
d35 1
a35 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_bin.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a32 3
 *  Copyright Notice -
 *	This software is Copyright (C) 2000-2004 by the United States Army.
 *	All rights reserved.
d35 1
a35 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_bin.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_bin.c,v 14.2 2004/12/21 04:18:19 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d38 1
a38 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_bin.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			D B 5 _ B I N . C
d38 1
a38 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_bin.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/src/librt/db5_bin.c,v 1.1 2004/05/20 15:19:56 morrison Exp $ (BRL)";
d865 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d19 1
a19 1
static const char RCSell[] = "@@(#)$Header: /cvs/brlcad/librt/db5_bin.c,v 1.25 2004/05/10 15:30:45 erikg Exp $ (BRL)";
d22 1
a22 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

