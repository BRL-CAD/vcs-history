head	14.27;
access;
symbols
	rel-7-10-4:14.23
	STABLE:14.23.0.2
	stable-branch:14.6
	rel-7-10-2:14.23
	rel-7-10-0:14.21
	rel-7-8-4:14.16
	rel-7-8-2:14.15
	rel-7-8-0:14.15
	trimnurbs-branch:14.14.0.2
	help:14.14
	temp_tag:14.12
	bobWinPort-20051223-freeze:14.9.2.1
	postmerge-20051223-bobWinPort:14.12
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.27
date	2007.12.18.07.07.12;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.12.01.21.47.12;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.10.14.01.17.30;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.09.15.16.23.13;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.06.30.04.04.56;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.06.27.09.18.20;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.02.20.08.19.49;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.27.01.41.41;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.21.04.45.44;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.20.14.36.55;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.09.16.02.04.25;	author lbutler;	state Exp;
branches;
next	14.15;

14.15
date	2006.03.24.23.21.34;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.02.27.08.20.11;	author brlcad;	state Exp;
branches
	14.14.2.1;
next	14.13;

14.13
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.12.23.21.26.31;	author bob1961;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.30.21.58.57;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.08.15.21.39.44;	author bob1961;	state Exp;
branches
	14.9.2.1
	14.9.4.1;
next	14.8;

14.8
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches;
next	14.7;

14.7
date	2005.05.28.02.14.51;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.31.00;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.46;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.15.05.18.15;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.57.53;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.04;	author morrison;	state Exp;
branches;
next	;

14.9.2.1
date	2005.09.08.16.23.20;	author bob1961;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;

14.14.2.1
date	2006.04.07.19.30.25;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.27
log
@null-terminate strncat'd buffers for sanity sake since we don't usually check if we filled/truncated
@
text
@/*                          N I R T . C
 * BRL-CAD
 *
 * Copyright (c) 1988-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup librt */
/** @@{ */
/** @@file nirt.c
 *
 *  Routines to interface to nirt.
 *
 *  Functions -
 *	dgo_nirt_cmd          trace a single ray from current view
 *
 *  Author -
 *	Michael John Muuss
 *	Robert G. Parker
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 *
 *  Description -
 *	This code was imported from MGED's/rtif.c and modified to work as part
 * 	of the drawable geometry object.
 *
 */
/** @@} */

#ifndef lint
static const char RCSid[] = "@@(#)$Header$ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <signal.h>

#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>		/* For struct timeval */
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#include <sys/stat.h>
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif

#include "tcl.h"
#include "machine.h"
#include "cmd.h"			/* includes bu.h */
#include "vmath.h"
#include "raytrace.h"
#include "solid.h"
#include "./qray.h"


/* defined in qray.c */
extern void dgo_qray_data_to_vlist(struct dg_obj *dgop, struct bn_vlblock *vbp, struct dg_qray_dataList *headp, fastf_t *dir, int do_overlaps);

/* defined in dg_obj.c */
extern int dgo_build_tops(Tcl_Interp *interp, struct solid *hsp, char **start, register char **end);
extern void dgo_cvt_vlblock_to_solids(struct dg_obj *dgop, Tcl_Interp *interp, struct bn_vlblock *vbp, char *name, int copy);
extern void dgo_pr_wait_status(Tcl_Interp *interp, int status);

/*
 *			F _ N I R T
 *
 *  Invoke nirt with the current view & stuff
 */
int
dgo_nirt_cmd(struct dg_obj	*dgop,
	     struct view_obj	*vop,
	     Tcl_Interp		*interp,
	     int		argc,
	     char		**argv)
{
	register char **vp;
	FILE *fp_in;
	FILE *fp_out, *fp_err;
	int pid, rpid;
	int retcode;
#ifndef _WIN32
	int pipe_in[2];
	int pipe_out[2];
	int pipe_err[2];
#else
	HANDLE pipe_in[2],hSaveStdin,pipe_inDup;
	HANDLE pipe_out[2],hSaveStdout,pipe_outDup;
	HANDLE pipe_err[2],hSaveStderr,pipe_errDup;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	SECURITY_ATTRIBUTES sa;
	char name[1024];
	char line1[2048];
	int rem = 2048;
#endif
	int use_input_orig = 0;
	vect_t	center_model;
	vect_t dir;
	vect_t cml;
	register int i;
	register struct solid *sp;
	char line[RT_MAXLINE];
	char *val;
	struct bu_vls vls;
	struct bu_vls o_vls;
	struct bu_vls p_vls;
	struct bu_vls t_vls;
	struct bn_vlblock *vbp;
	struct dg_qray_dataList *ndlp;
	struct dg_qray_dataList HeadQRayData;

	vp = &dgop->dgo_rt_cmd[0];
	*vp++ = "nirt";

	/* swipe x, y, z off the end if present */
	if (argc > 3) {
		if (sscanf(argv[argc-3], "%lf", &center_model[X]) == 1 &&
		    sscanf(argv[argc-2], "%lf", &center_model[Y]) == 1 &&
		    sscanf(argv[argc-1], "%lf", &center_model[Z]) == 1){
			use_input_orig = 1;
			argc -= 3;
			VSCALE(center_model, center_model, dgop->dgo_wdbp->dbip->dbi_local2base);
		}
	}

	/* Calculate point from which to fire ray */
	if (!use_input_orig) {
		VSET(center_model, -vop->vo_center[MDX],
		     -vop->vo_center[MDY], -vop->vo_center[MDZ]);
	}

#if 0
	if (mged_variables->mv_perspective_mode) {
		point_t pt, eye;

		/* get eye point */
		VSET(pt, 0.0, 0.0, 1.0);
		MAT4X3PNT(eye, vop->vo_view2model, pt);
		VSCALE(eye, eye, base2local);

		/* point passed in is actually the aim point */
		VSCALE(cml, center_model, base2local);
		VSUB2(dir, cml, eye);
		VUNITIZE(dir);

		/* copy eye point to cml (cml is used for the "xyz" command to nirt */
		VMOVE(cml, eye);
	} else {
		VSCALE(cml, center_model, base2local);
		VMOVEN(dir, vop->vo_rotation + 8, 3);
		VSCALE(dir, dir, -1.0);
	}
#else
	VSCALE(cml, center_model, dgop->dgo_wdbp->dbip->dbi_base2local);
	VMOVEN(dir, vop->vo_rotation + 8, 3);
	VSCALE(dir, dir, -1.0);
#endif

	bu_vls_init(&p_vls);
	bu_vls_printf(&p_vls, "xyz %lf %lf %lf;",
		cml[X], cml[Y], cml[Z]);
	bu_vls_printf(&p_vls, "dir %lf %lf %lf; s",
		dir[X], dir[Y], dir[Z]);

	i = 0;
	if (DG_QRAY_GRAPHICS(dgop)) {

		*vp++ = "-e";
		*vp++ = DG_QRAY_FORMAT_NULL;

		/* first ray  ---- returns partitions */
		*vp++ = "-e";
		*vp++ = DG_QRAY_FORMAT_P;

		/* ray start, direction, and 's' command */
		*vp++ = "-e";
		*vp++ = bu_vls_addr(&p_vls);

		/* second ray  ---- returns overlaps */
		*vp++ = "-e";
		*vp++ = DG_QRAY_FORMAT_O;

		/* ray start, direction, and 's' command */
		*vp++ = "-e";
		*vp++ = bu_vls_addr(&p_vls);

		if (DG_QRAY_TEXT(dgop)) {
			char *cp;
			int count = 0;

			bu_vls_init(&o_vls);

			/* get 'r' format now; prepend its' format string with a newline */
			val = bu_vls_addr(&dgop->dgo_qray_fmts[0].fmt);

			/* find first '"' */
			while(*val != '"' && *val != '\0')
				++val;

			if(*val == '\0')
				goto done;
			else
				++val;	    /* skip first '"' */

			/* find last '"' */
			cp = (char *)strrchr(val, '"');

			if (cp != (char *)NULL) /* found it */
				count = cp - val;

done:
			if(*val == '\0')
			    bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
			else{
			    bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);

			    if (count)
				val += count + 1;
			    bu_vls_printf(&o_vls, "%s", val);
			}

			i = 1;

			*vp++ = "-e";
			*vp++ = bu_vls_addr(&o_vls);
		}
	}

	if (DG_QRAY_TEXT(dgop)) {

		bu_vls_init(&t_vls);

		/* load vp with formats for printing */
		for(; dgop->dgo_qray_fmts[i].type != (char)0; ++i)
			bu_vls_printf(&t_vls, "fmt %c %s; ",
				      dgop->dgo_qray_fmts[i].type,
				      bu_vls_addr(&dgop->dgo_qray_fmts[i].fmt));

		*vp++ = "-e";
		*vp++ = bu_vls_addr(&t_vls);

		/* nirt does not like the trailing ';' */
		bu_vls_trunc(&t_vls, -2);
	}

	/* include nirt script string */
	if (bu_vls_strlen(&dgop->dgo_qray_script)) {
		*vp++ = "-e";
		*vp++ = bu_vls_addr(&dgop->dgo_qray_script);
	}

	*vp++ = "-e";
	*vp++ = bu_vls_addr(&p_vls);

	for (i=1; i < argc; i++)
		*vp++ = argv[i];
	*vp++ = dgop->dgo_wdbp->dbip->dbi_filename;

	dgop->dgo_rt_cmd_len = vp - dgop->dgo_rt_cmd;

	/* Note - dgo_build_tops sets the last vp to (char *)0 */
	dgop->dgo_rt_cmd_len += dgo_build_tops(interp,
					       (struct solid *)&dgop->dgo_headSolid,
					       vp,
					       &dgop->dgo_rt_cmd[RT_MAXARGS]);

	if (dgop->dgo_qray_cmd_echo) {
		/* Print out the command we are about to run */
		vp = &dgop->dgo_rt_cmd[0];
		while (*vp)
			Tcl_AppendResult(interp, *vp++, " ", (char *)NULL);

		Tcl_AppendResult(interp, "\n", (char *)NULL);
	}

	if (use_input_orig) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "\nFiring from (%lf, %lf, %lf)...\n",
			      center_model[X], center_model[Y], center_model[Z]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);
	} else
		Tcl_AppendResult(interp, "\nFiring from view center...\n", (char *)NULL);

#ifndef _WIN32
	(void)pipe(pipe_in);
	(void)pipe(pipe_out);
	(void)pipe(pipe_err);
	(void)signal(SIGINT, SIG_IGN);
	if ((pid = fork()) == 0) {
		/* Redirect stdin, stdout, stderr */
		(void)close(0);
		(void)dup( pipe_in[0] );
		(void)close(1);
		(void)dup( pipe_out[1] );
		(void)close(2);
		(void)dup ( pipe_err[1] );

		/* close pipes */
		(void)close(pipe_in[0]);
		(void)close(pipe_in[1]);
		(void)close(pipe_out[0]);
		(void)close(pipe_out[1]);
		(void)close(pipe_err[0]);
		(void)close(pipe_err[1]);
		for (i=3; i < 20; i++)
			(void)close(i);
		(void)signal(SIGINT, SIG_DFL);
		(void)execvp(dgop->dgo_rt_cmd[0], dgop->dgo_rt_cmd);
		perror (dgop->dgo_rt_cmd[0]);
		exit(16);
	}

	/* use fp_in to feed view info to nirt */
	(void)close(pipe_in[0]);
	fp_in = fdopen(pipe_in[1], "w");

	/* use fp_out to read back the result */
	(void)close(pipe_out[1]);
	fp_out = fdopen(pipe_out[0], "r");

	/* use fp_err to read any error messages */
	(void)close(pipe_err[1]);
	fp_err = fdopen(pipe_err[0], "r");

	/* send quit command to nirt */
	fwrite("q\n", 1, 2, fp_in);
	(void)fclose(fp_in);

#else
	memset((void *)&si, 0, sizeof(STARTUPINFO));
	memset((void *)&pi, 0, sizeof(PROCESS_INFORMATION));
	memset((void *)&sa, 0, sizeof(SECURITY_ATTRIBUTES));

	sa.nLength = sizeof(sa);
	sa.bInheritHandle = TRUE;
	sa.lpSecurityDescriptor = NULL;

	/* Create a pipe for the child process's STDOUT. */
	CreatePipe( &pipe_out[0], &pipe_out[1], &sa, 0);

	/* Create noninheritable read handle and close the inheritable read handle. */
	DuplicateHandle(GetCurrentProcess(), pipe_out[0],
			GetCurrentProcess(),  &pipe_outDup ,
			0,  FALSE,
			DUPLICATE_SAME_ACCESS);
	CloseHandle(pipe_out[0]);

	/* Create a pipe for the child process's STDERR. */
	CreatePipe( &pipe_err[0], &pipe_err[1], &sa, 0);

	/* Create noninheritable read handle and close the inheritable read handle. */
	DuplicateHandle(GetCurrentProcess(), pipe_err[0],
			GetCurrentProcess(),  &pipe_errDup ,
			0,  FALSE,
			DUPLICATE_SAME_ACCESS);
	CloseHandle(pipe_err[0]);

	/* The steps for redirecting child process's STDIN:
	 *     1.  Save current STDIN, to be restored later.
	 *     2.  Create anonymous pipe to be STDIN for child process.
	 *     3.  Set STDIN of the parent to be the read handle to the
	 *         pipe, so it is inherited by the child process.
	 *     4.  Create a noninheritable duplicate of the write handle,
	 *         and close the inheritable write handle.
	 */

	/* Create a pipe for the child process's STDIN. */
	CreatePipe(&pipe_in[0], &pipe_in[1], &sa, 0);

	/* Duplicate the write handle to the pipe so it is not inherited. */
	DuplicateHandle(GetCurrentProcess(), pipe_in[1],
			GetCurrentProcess(), &pipe_inDup,
			0, FALSE,                  /* not inherited */
			DUPLICATE_SAME_ACCESS);
	CloseHandle(pipe_in[1]);

	si.cb = sizeof(STARTUPINFO);
	si.lpReserved = NULL;
	si.lpReserved2 = NULL;
	si.cbReserved2 = 0;
	si.lpDesktop = NULL;
	si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
	si.hStdInput   = pipe_in[0];
	si.hStdOutput  = pipe_out[1];
	si.hStdError   = pipe_err[1];
	si.wShowWindow = SW_HIDE;

	snprintf(line1, rem, "%s ", dgop->dgo_rt_cmd[0]);
	rem -= strlen(line1) - 1;

	for (i=1; i<dgop->dgo_rt_cmd_len; i++) {
	    /* skip commands */
	    if (strstr(dgop->dgo_rt_cmd[i], "-e") != NULL)
		++i;
	    else { /* append other arguments (i.e. options, file and obj(s)) */
		snprintf(name, 1024, "\"%s\" ", dgop->dgo_rt_cmd[i]);
		if (rem - strlen(name) < 1) {
		    bu_log("Ran out of buffer space!");
		    return TCL_ERROR;
		}
		strncat(line1, name, rem-1);
		rem -= strlen(name);
	    }
	}
	line1[2048-1] = '\0'; /* sanity */

	CreateProcess(NULL, line1, NULL, NULL, TRUE,
		      DETACHED_PROCESS, NULL, NULL,
		      &si, &pi);

	/* use fp_in to feed view info to nirt */
	CloseHandle(pipe_in[0]);
	fp_in = _fdopen(_open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "wb");
	_setmode(_fileno(fp_in), _O_BINARY);

	/* send commands down the pipe */
	for (i=1; i<dgop->dgo_rt_cmd_len-2; i++)
	    if (strstr(dgop->dgo_rt_cmd[i], "-e") != NULL)
		fprintf(fp_in, "%s\n", dgop->dgo_rt_cmd[++i]);

	/* use fp_out to read back the result */
	CloseHandle(pipe_out[1]);
	fp_out = _fdopen(_open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "rb");
	_setmode(_fileno(fp_out), _O_BINARY);

	/* use fp_err to read any error messages */
	CloseHandle(pipe_err[1]);
	fp_err = _fdopen(_open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "rb");
	_setmode(_fileno(fp_err), _O_BINARY);

	/* send quit command to nirt */
	fwrite( "q\n", 1, 2, fp_in );
	(void)fclose(fp_in);

#endif

	bu_vls_free(&p_vls);   /* use to form "partition" part of nirt command above */
	if (DG_QRAY_GRAPHICS(dgop)) {

		if (DG_QRAY_TEXT(dgop))
			bu_vls_free(&o_vls); /* used to form "overlap" part of nirt command above */

		BU_LIST_INIT(&HeadQRayData.l);

		/* handle partitions */
		while (bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL) {
			if (line[0] == '\n') {
				Tcl_AppendResult(interp, line+1, (char *)NULL);
				break;
			}

			BU_GETSTRUCT(ndlp, dg_qray_dataList);
			BU_LIST_APPEND(HeadQRayData.l.back, &ndlp->l);

			if (sscanf(line, "%le %le %le %le",
				   &ndlp->x_in, &ndlp->y_in, &ndlp->z_in, &ndlp->los) != 4)
				break;
		}

		vbp = rt_vlblock_init();
		dgo_qray_data_to_vlist(dgop, vbp, &HeadQRayData, dir, 0);
		bu_list_free(&HeadQRayData.l);
		dgo_cvt_vlblock_to_solids(dgop, interp, vbp, bu_vls_addr(&dgop->dgo_qray_basename), 0);
		rt_vlblock_free(vbp);

		/* handle overlaps */
		while (bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL) {
			if (line[0] == '\n') {
				Tcl_AppendResult(interp, line+1, (char *)NULL);
				break;
			}

			BU_GETSTRUCT(ndlp, dg_qray_dataList);
			BU_LIST_APPEND(HeadQRayData.l.back, &ndlp->l);

			if (sscanf(line, "%le %le %le %le",
				   &ndlp->x_in, &ndlp->y_in, &ndlp->z_in, &ndlp->los) != 4)
				break;
		}
		vbp = rt_vlblock_init();
		dgo_qray_data_to_vlist(dgop, vbp, &HeadQRayData, dir, 1);
		bu_list_free(&HeadQRayData.l);
		dgo_cvt_vlblock_to_solids(dgop, interp, vbp, bu_vls_addr(&dgop->dgo_qray_basename), 0);
		rt_vlblock_free(vbp);
	}

	/*
	 * Notify observers, if any, before generating textual output since
	 * such an act (observer notification) wipes out whatever gets stuffed
	 * into the result.
	 */
	dgo_notify(dgop, interp);

	if (DG_QRAY_TEXT(dgop)) {
		bu_vls_free(&t_vls);

		while (bu_fgets(line, RT_MAXLINE, fp_out) != (char *)NULL)
			Tcl_AppendResult(interp, line, (char *)NULL);
	}

	(void)fclose(fp_out);

	while (bu_fgets(line, RT_MAXLINE, fp_err) != (char *)NULL)
		Tcl_AppendResult(interp, line, (char *)NULL);
	(void)fclose(fp_err);


#ifndef _WIN32

	/* Wait for program to finish */
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;	/* NULL */

	if( retcode != 0 )
		dgo_pr_wait_status(interp, retcode);
#else
	/* Wait for program to finish */
	WaitForSingleObject( pi.hProcess, INFINITE );

#endif

	FOR_ALL_SOLIDS(sp, &dgop->dgo_headSolid)
		sp->s_wflag = DOWN;

	return TCL_OK;
}

int
dgo_vnirt_cmd(struct dg_obj	*dgop,
	      struct view_obj	*vop,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv) {
    register int i;
    int status;
    fastf_t sf = 1.0 * DG_INV_GED;
    vect_t view_ray_orig;
    vect_t center_model;
    struct bu_vls x_vls;
    struct bu_vls y_vls;
    struct bu_vls z_vls;
    char **av;

    if (argc < 3 || MAXARGS < argc) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dgo_vnirt %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
    }

    /*
     * The last two arguments are expected to be x,y in view coordinates.
     * It is also assumed that view z will be the front of the viewing cube.
     * These coordinates are converted to x,y,z in model coordinates and then
     * converted to local units before being handed to nirt. All other
     * arguments are passed straight through to nirt.
     */
    if(sscanf(argv[argc-2], "%lf", &view_ray_orig[X]) != 1 ||
       sscanf(argv[argc-1], "%lf", &view_ray_orig[Y]) != 1){
	return TCL_ERROR;
    }
    view_ray_orig[Z] = DG_GED_MAX;
    argc -= 2;

    av = (char **)bu_malloc(sizeof(char *) * (argc + 4), "dgo_vnirt_cmd: av");

    /* Calculate point from which to fire ray */
    VSCALE(view_ray_orig, view_ray_orig, sf);
    MAT4X3PNT(center_model, vop->vo_view2model, view_ray_orig);
    VSCALE(center_model, center_model, dgop->dgo_wdbp->dbip->dbi_base2local);

    bu_vls_init(&x_vls);
    bu_vls_init(&y_vls);
    bu_vls_init(&z_vls);
    bu_vls_printf(&x_vls, "%lf", center_model[X]);
    bu_vls_printf(&y_vls, "%lf", center_model[Y]);
    bu_vls_printf(&z_vls, "%lf", center_model[Z]);

    /* pass remaining arguments to nirt */
    av[0] = "nirt";
    for(i = 1; i < argc; ++i)
	av[i] = argv[i];

    /* pass modified coordinates to nirt */
    av[i++] = bu_vls_addr(&x_vls);
    av[i++] = bu_vls_addr(&y_vls);
    av[i++] = bu_vls_addr(&z_vls);
    av[i] = (char *)NULL;

    status = dgo_nirt_cmd(dgop, vop, interp, argc + 3, av);

    bu_vls_free(&x_vls);
    bu_vls_free(&y_vls);
    bu_vls_free(&z_vls);
    bu_free((genptr_t)av, "dgo_vnirt_cmd: av");

    return status;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.26
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.25 2007/10/14 01:17:30 brlcad Exp $ (BRL)";
d434 1
@


14.25
log
@use fchmod() instead of chmod() to avoid race condition.  quell flawfinder warning
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.24 2007/09/15 16:23:13 brlcad Exp $ (BRL)";
d122 1
d417 3
a419 1
	sprintf(line1,"%s ", dgop->dgo_rt_cmd[0]);
d425 7
a431 2
		sprintf(name,"\"%s\" ", dgop->dgo_rt_cmd[i]);
		strcat(line1, name);
@


14.24
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.23 2007/06/30 04:04:56 brlcad Exp $ (BRL)";
a60 1
#include <sys/stat.h>		/* for chmod() */
d70 1
@


14.23
log
@NULL != 0, quell warnings
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.22 2007/06/27 09:18:20 brlcad Exp $ (BRL)";
d54 1
a54 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
d57 1
@


14.22
log
@remove the final few remaining references to interp->result (both comments and code)
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.21 2007/02/20 08:19:49 brlcad Exp $ (BRL)";
d264 1
a264 1
		for(; dgop->dgo_qray_fmts[i].type != (char)NULL; ++i)
@


14.21
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.20 2007/01/27 01:41:41 brlcad Exp $ (BRL)";
d513 1
a513 1
	 * into interp->result.
@


14.20
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.19 2007/01/23 01:13:37 brlcad Exp $ (BRL)";
d469 1
a469 1
		while (fgets(line, RT_MAXLINE, fp_out) != (char *)NULL) {
d490 1
a490 1
		while (fgets(line, RT_MAXLINE, fp_out) != (char *)NULL) {
d520 1
a520 1
		while (fgets(line, RT_MAXLINE, fp_out) != (char *)NULL)
d526 1
a526 1
	while (fgets(line, RT_MAXLINE, fp_err) != (char *)NULL)
@


14.19
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.18 2007/01/21 04:45:44 brlcad Exp $ (BRL)";
d282 2
a283 2
        *vp++ = "-e";
        *vp++ = bu_vls_addr(&p_vls);
d321 1
a321 1
 	        /* Redirect stdin, stdout, stderr */
@


14.18
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.17 2007/01/20 14:36:55 brlcad Exp $ (BRL)";
@


14.17
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d24 1
d45 1
a45 1
/*@@}*/
d48 1
a48 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.16 2006/09/16 02:04:25 lbutler Exp $ (BRL)";
@


14.16
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2006 United States Government as represented by
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.15 2006/03/24 23:21:34 brlcad Exp $ (BRL)";
@


14.15
log
@lots of intel 9 for altix compiler warning quellings
@
text
@d22 1
a22 1
/** \addtogroup librt */
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.14 2006/02/27 08:20:11 brlcad Exp $ (BRL)";
@


14.14
log
@stdlib.h warning quelling, conversions to bu_bomb instead of aborting
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.13 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
d70 9
@


14.14.2.1
log
@update from HEAD
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.14 2006/02/27 08:20:11 brlcad Exp $ (BRL)";
a69 9
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif
@


14.13
log
@update copyright to 2006
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.12 2005/12/23 21:26:31 bob1961 Exp $ (BRL)";
d54 1
a66 1

d79 1
@


14.12
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1988-2005 United States Government as represented by
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.11 2005/10/30 21:58:57 brlcad Exp $ (BRL)";
@


14.11
log
@remove C++-style // comments as there's no assumption of c99 compiler compliance yet, only c89 (mostly aix compiler though other old compilers too)
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.10 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
d73 1
a73 1
#include "bu.h"
d559 11
@


14.10
log
@trailing ws
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.9 2005/08/15 21:39:44 bob1961 Exp $ (BRL)";
d361 1
a361 1
	// Create a pipe for the child process's STDOUT.
d364 1
a364 1
	// Create noninheritable read handle and close the inheritable read handle.
d371 1
a371 1
	// Create a pipe for the child process's STDERR.
d374 1
a374 1
	// Create noninheritable read handle and close the inheritable read handle.
d381 8
a388 7
	// The steps for redirecting child process's STDIN:
	//     1.  Save current STDIN, to be restored later.
	//     2.  Create anonymous pipe to be STDIN for child process.
	//     3.  Set STDIN of the parent to be the read handle to the
	//         pipe, so it is inherited by the child process.
	//     4.  Create a noninheritable duplicate of the write handle,
	//         and close the inheritable write handle.
d390 1
a390 1
	// Create a pipe for the child process's STDIN.
d393 1
a393 1
	// Duplicate the write handle to the pipe so it is not inherited.
d396 1
a396 1
			0, FALSE,                  // not inherited
@


14.9
log
@Mods for Windows port
@
text
@d39 1
a39 1
 *  
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.8 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
d361 1
a361 1
	// Create a pipe for the child process's STDOUT.  
d364 1
a364 1
	// Create noninheritable read handle and close the inheritable read handle. 
d366 1
a366 1
			GetCurrentProcess(),  &pipe_outDup , 
d371 1
a371 1
	// Create a pipe for the child process's STDERR.  
d374 1
a374 1
	// Create noninheritable read handle and close the inheritable read handle. 
d376 1
a376 1
			GetCurrentProcess(),  &pipe_errDup , 
a379 8
	
	// The steps for redirecting child process's STDIN: 
	//     1.  Save current STDIN, to be restored later. 
	//     2.  Create anonymous pipe to be STDIN for child process. 
	//     3.  Set STDIN of the parent to be the read handle to the 
	//         pipe, so it is inherited by the child process. 
	//     4.  Create a noninheritable duplicate of the write handle, 
	//         and close the inheritable write handle.  
d381 9
a389 1
	// Create a pipe for the child process's STDIN.  
d392 6
a397 6
	// Duplicate the write handle to the pipe so it is not inherited.  
	DuplicateHandle(GetCurrentProcess(), pipe_in[1], 
			GetCurrentProcess(), &pipe_inDup, 
			0, FALSE,                  // not inherited       
			DUPLICATE_SAME_ACCESS); 
	CloseHandle(pipe_in[1]); 
d418 1
a418 1
	    } 
d424 1
a424 1
 
d521 1
a521 1
	
@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d39 1
a39 1
 *
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d361 1
a361 1
	/* Create a pipe for the child process's STDOUT. */
d364 1
a364 1
	/* Create noninheritable read handle and close the inheritable read handle. */
d366 1
a366 1
			GetCurrentProcess(),  &pipe_outDup ,
d371 1
a371 1
	/* Create a pipe for the child process's STDERR. */
d374 1
a374 1
	/* Create noninheritable read handle and close the inheritable read handle. */
d376 1
a376 1
			GetCurrentProcess(),  &pipe_errDup ,
d380 8
d389 1
a389 10
	/* The steps for redirecting child process's STDIN:
	 *     1.  Save current STDIN, to be restored later.
	 *     2.  Create anonymous pipe to be STDIN for child process.
	 *     3.  Set STDIN of the parent to be the read handle to the
	 *         pipe, so it is inherited by the child process.
	 *     4.  Create a noninheritable duplicate of the write handle,
	 *         and close the inheritable write handle.
	 */

	/* Create a pipe for the child process's STDIN. */
d392 6
a397 6
	/* Duplicate the write handle to the pipe so it is not inherited. */
	DuplicateHandle(GetCurrentProcess(), pipe_in[1],
			GetCurrentProcess(), &pipe_inDup,
			0, FALSE,                  /* not inherited */
			DUPLICATE_SAME_ACCESS);
	CloseHandle(pipe_in[1]);
d418 1
a418 1
	    }
d424 1
a424 1

d521 1
a521 1

@


14.9.2.1
log
@Mods for windows port
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.9 2005/08/15 21:39:44 bob1961 Exp $ (BRL)";
d73 1
a73 1
#include "cmd.h"			/* includes bu.h */
a557 11
    if (argc < 3 || MAXARGS < argc) {
	struct bu_vls vls;

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib_alias dgo_vnirt %s", argv[0]);
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
    }

@


14.8
log
@Doxygen changes
@
text
@d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.7 2005/05/28 02:14:51 brlcad Exp $ (BRL)";
d112 5
a116 5
	STARTUPINFO si = {0};
   PROCESS_INFORMATION pi = {0};
   SECURITY_ATTRIBUTES sa          = {0};
   char name[1024];
   char line1[2048];
d118 1
a118 1
   int use_input_orig = 0;
d234 8
a241 14
#ifndef _WIN32
	    if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \"\\n\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \"\\n%*s\" ", count, val);
#else
		if(*val == '\0')
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n\\\" ");
	    else{
	      bu_vls_printf(&o_vls, " fmt r \\\"\\\\n%*s\\\" ", count, val);
#endif
				if (count)
					val += count + 1;
				bu_vls_printf(&o_vls, "%s", val);
d353 7
a359 3
		sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;
a360 3
	// Save the handle to the current STDOUT.  
	hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);  
	
a363 3
	// Set a write handle to the pipe to be STDOUT.  
	SetStdHandle(STD_OUTPUT_HANDLE, pipe_out[1]);  

d365 5
a369 5
    DuplicateHandle( GetCurrentProcess(), pipe_out[0],
        GetCurrentProcess(),  &pipe_outDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_out[0] );
a370 3
	// Save the handle to the current STDERR.  
	hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);  
	
a373 3
	// Set a write handle to the pipe to be STDERR.  
	SetStdHandle(STD_ERROR_HANDLE, pipe_err[1]);  

d375 5
a379 5
    DuplicateHandle( GetCurrentProcess(), pipe_err[0],
        GetCurrentProcess(),  &pipe_errDup , 
		0,  FALSE,
        DUPLICATE_SAME_ACCESS );
	CloseHandle( pipe_err[0] );
a388 3
	// Save the handle to the current STDIN. 
	hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);  

d391 1
a391 2
	// Set a read handle to the pipe to be STDIN.  
	SetStdHandle(STD_INPUT_HANDLE, pipe_in[0]);
d394 3
a396 3
		GetCurrentProcess(), &pipe_inDup, 
		0, FALSE,                  // not inherited       
		DUPLICATE_SAME_ACCESS ); 
d399 21
d421 3
a423 37
   si.cb = sizeof(STARTUPINFO);
   si.lpReserved = NULL;
   si.lpReserved2 = NULL;
   si.cbReserved2 = 0;
   si.lpDesktop = NULL;
   si.dwFlags = 0;
   si.dwFlags = STARTF_USESTDHANDLES;
   si.hStdInput   = pipe_in[0];
   si.hStdOutput  = pipe_out[1];
   si.hStdError   = pipe_err[1];


   sprintf(line1,"%s ",dgop->dgo_rt_cmd[0]);
   for(i=1;i<dgop->dgo_rt_cmd_len;i++) {
	   sprintf(name,"%s ",dgop->dgo_rt_cmd[i]);
	   strcat(line1,name); 
	   if(strstr(name,"-e") != NULL) {
		   i++;
		   sprintf(name,"\"%s\" ",dgop->dgo_rt_cmd[i]);
			strcat(line1,name);} 
   }
   
   if(CreateProcess( NULL,
                     line1,
                     NULL,
                     NULL,
                     TRUE,
                     DETACHED_PROCESS,
                     NULL,
                     NULL,
                     &si,
                     &pi )) {

	SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
	SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
	SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);
}
d426 8
a433 3
	CloseHandle( pipe_in[0] );
	fp_in = _fdopen( _open_osfhandle((HFILE)pipe_inDup,_O_TEXT), "w" );
	//fp_in = fdopen( pipe_in[1], "w" );
d436 3
a438 3
	CloseHandle( pipe_out[1] );
	//fp_out = fdopen( pipe_out[0], "r" );
	fp_out = _fdopen( _open_osfhandle((HFILE)pipe_outDup,_O_TEXT), "r" );
d442 2
a443 2
	//fp_err = fdopen( pipe_err[0], "r" );
	fp_err = _fdopen( _open_osfhandle((HFILE)pipe_errDup,_O_TEXT), "r" );
d447 1
a447 1
	(void)fclose( fp_in );
@


14.7
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d21 4
a25 1
 *
d46 2
d49 1
a49 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.6 2005/01/30 20:31:00 brlcad Exp $ (BRL)";
@


14.6
log
@update copyright to 2005
@
text
@d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/nirt.c,v 14.5 2004/12/21 06:38:21 morrison Exp $ (BRL)";
a48 2


d51 1
a51 1
#include <string.h>
d53 1
a53 1
#include <strings.h>
d57 2
a58 2
#ifndef WIN32
#include <sys/time.h>		/* For struct timeval */
d62 4
a66 1

a73 4
#ifdef WIN32
#include <fcntl.h>
#endif

d99 1
a99 1
#ifndef WIN32
d229 1
a229 1
#ifndef WIN32
d308 1
a308 1
#ifndef WIN32
d543 1
a543 1
#ifndef WIN32
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2004 United States Government as represented by
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/nirt.c,v 14.4 2004/12/21 06:18:46 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a36 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/nirt.c,v 14.3 2004/12/21 05:45:24 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/nirt.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/nirt.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			N I R T . C
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/nirt.c,v 1.5 2004/09/15 05:18:15 morrison Exp $ (BRL)";
@


1.5
log
@arg 2 of dgo_build_tops was of an incompatible pointer type .. so make it compatible (ia64 quelling)
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/nirt.c,v 1.4 2004/09/03 23:30:58 morrison Exp $ (BRL)";
d614 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/nirt.c,v 1.3 2004/08/02 23:01:49 morrison Exp $ (BRL)";
d273 1
a273 1
					       &dgop->dgo_headSolid,
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/nirt.c,v 1.2 2004/06/08 19:57:53 morrison Exp $ (BRL)";
d36 1
a36 1
#ifdef USE_STRING_H
@


1.2
log
@bye bye externs.h
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d31 1
a31 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/nirt.c,v 1.9 2004/05/10 15:30:46 erikg Exp $ (BRL)";
a55 1
#include "externs.h"
@

