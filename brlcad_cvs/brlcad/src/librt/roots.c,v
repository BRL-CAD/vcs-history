head	14.24;
access;
symbols
	rel-7-10-4:14.24
	STABLE:14.24.0.2
	stable-branch:14.6
	rel-7-10-2:14.24
	rel-7-10-0:14.16
	rel-7-8-4:14.12
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.24
date	2007.05.26.22.12.14;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.05.17.04.02.20;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.05.17.04.00.56;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.05.16.20.38.15;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.05.16.20.22.36;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.05.16.06.26.34;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.15.03.52.33;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.14.21.04.32;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.42;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.39;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.21.04.45.45;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.55;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.09.16.02.04.26;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.36;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.9.4.1;
next	14.8;

14.8
date	2005.05.01.22.56.08;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.04.29.14.22.53;	author lbutler;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.31.03;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.48;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.21;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.10;	author morrison;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.17;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.24
log
@FAST and LOCAL are no longer really useful, adding more burden than they provide, so begin a move towards deprecation.
@
text
@/*                         R O O T S . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup librt */
/** @@{ */
/** @@file roots.c
 *
 * Find the roots of a polynomial
 *
 *  Author -
 *	Jeff Hanes
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 */
/** @@} */

#ifndef lint
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.23 2007/05/17 04:02:20 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"


static const bn_poly_t bn_Zero_poly = { BN_POLY_MAGIC, 0, {0.0} };


/**
 * R T _ P O L Y _ E V A L _ W _ 2 D E R I V A T I V E S
 *
 * Evaluates p(Z), p'(Z), and p''(Z) for any Z (real or complex).
 * Given an equation of the form:
 *
 *	p(Z) = a0*Z^n + a1*Z^(n-1) +... an != 0,
 *
 * the function value and derivatives needed for the iterations can be
 * computed by synthetic division using the formulas
 *
 *	p(Z) = bn,    p'(Z) = c(n-1),    p''(Z) = d(n-2),
 *
 * where
 *
 *	b0 = a0,	bi = b(i-1)*Z + ai,	i = 1,2,...n
 *	c0 = b0,	ci = c(i-1)*Z + bi,	i = 1,2,...n-1
 *	d0 = c0,	di = d(i-1)*Z + ci,	i = 1,2,...n-2
 */
void
rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d)
     /* input */
     /* input */
     /* outputs */
{
    register int	n;
    register int	m;

    bn_cx_cons(b,eqn->cf[0],0.0);
    *c = *b;
    *d = *c;

    for ( n=1; ( m = eqn->dgr - n ) >= 0; ++n){
	bn_cx_mul( b, cZ );
	b->re += eqn->cf[n];
	if ( m > 0 ){
	    bn_cx_mul( c, cZ );
	    bn_cx_add( c, b );
	}
	if ( m > 1 ){
	    bn_cx_mul( d, cZ );
	    bn_cx_add( d, c );
	}
    }
}


/**
 * R T _ P O L Y _ F I N D R O O T
 *
 * Calculates one root of a polynomial ( p(Z) ) using Laguerre's
 * method.  This is an iterative technique which has very good global
 * convergence properties.  The formulas for this method are
 *
 *				n * p(Z)
 *	newZ  =  Z  -  -----------------------  ,
 *			p'(Z) +- sqrt( H(Z) )
 *
 * where
 *	H(Z) = (n-1) [ (n-1)(p'(Z))^2 - n p(Z)p''(Z) ],
 *
 * where n is the degree of the polynomial.  The sign in the
 * denominator is chosen so that |newZ - Z| is as small as possible.
 */
int
rt_poly_findroot(register bn_poly_t *eqn, /* polynomial */
		 register bn_complex_t *nxZ, /* initial guess for root	*/
		 const char *str)
{
    bn_complex_t  p0, p1, p2;	/* evaluated polynomial+derivatives */
    bn_complex_t  p1_H;		/* p1 - H, temporary */
    bn_complex_t  cZ, cH;		/* 'Z' and H(Z) in comment	*/
    bn_complex_t  T;		/* temporary for making H */
    fastf_t	diff=0.0;		/* test values for convergence	*/
    fastf_t	b=0.0;		/* floating temps */
    int	n;
    register int	i;		/* iteration counter		*/

    for( i=0; i < 20; i++ ) {
	cZ = *nxZ;
	rt_poly_eval_w_2derivatives( &cZ, eqn, &p0, &p1, &p2 );

	/* Compute H for Laguerre's method. */
	n = eqn->dgr-1;
	bn_cx_mul2( &cH, &p1, &p1 );
	bn_cx_scal( &cH, (double)(n*n) );
	bn_cx_mul2( &T, &p2, &p0 );
	bn_cx_scal( &T, (double)(eqn->dgr*n) );
	bn_cx_sub( &cH, &T );

	/* Calculate the next iteration for Laguerre's method.
	 * Test to see whether addition or subtraction gives the
	 * larger denominator for the next 'Z' , and use the
	 * appropriate value in the formula.
	 */
	bn_cx_sqrt( &cH, &cH );
	p1_H = p1;
	bn_cx_sub( &p1_H, &cH );
	bn_cx_add( &p1, &cH );		/* p1 <== p1+H */
	bn_cx_scal( &p0, (double)(eqn->dgr) );
	if ( bn_cx_amplsq( &p1_H ) > bn_cx_amplsq( &p1 ) ){
	    bn_cx_div( &p0, &p1_H);
	    bn_cx_sub( nxZ, &p0 );
	} else {
	    bn_cx_div( &p0, &p1 );
	    bn_cx_sub( nxZ, &p0 );
	}

	/* Use proportional convergence test to allow very small
	 * roots and avoid wasting time on large roots.
	 * The original version used bn_cx_ampl(), which requires
	 * a square root.  Using bn_cx_amplsq() saves lots of cycles,
	 * but changes loop termination conditions somewhat.
	 *
	 * diff is |p0|**2.  nxZ = Z - p0.
	 *
	 * SGI XNS IRIS 3.5 compiler fails if following 2 assignments
	 * are imbedded in the IF statement, as before.
	 */
	b = bn_cx_amplsq( nxZ );
	diff = bn_cx_amplsq( &p0 );
	if( b < diff )
	    continue;
	if( (b-diff) == b )
	    return(i);		/* OK -- can't do better */
	if( diff > (b - diff)*1.0e-5 )
	    continue;
	return(i);			/* OK */
    }

    /* If the thing hasn't converged yet, it probably won't. */
    bu_log("rt_poly_findroot: solving for %s didn't converge in %d iterations, b=%g, diff=%g\n",
	   str, i, b, diff);
    bu_log("nxZ=%gR+%gI, p0=%gR+%gI\n", nxZ->re, nxZ->im, p0.re, p0.im);
    return(-1);		/* ERROR */
}


/**
 * R T _ P O L Y _ C H E C K R O O T S
 *
 * Evaluates p(Z) for any Z (real or complex).  In this case, test all
 * "nroots" entries of roots[] to ensure that they are roots (zeros)
 * of this polynomial.
 *
 * Returns -
 *	0	all roots are true zeros
 *	1	at least one "root[]" entry is not a true zero
 *
 *	Given an equation of the form
 *
 *		p(Z) = a0*Z^n + a1*Z^(n-1) +... an != 0,
 *
 *	the function value can be computed using the formula
 *
 *		p(Z) = bn,	where
 *
 *		b0 = a0,	bi = b(i-1)*Z + ai,	i = 1,2,...n
 */
int
rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots)
{
    register fastf_t	er, ei;		/* "epoly" */
    register fastf_t	zr, zi;		/* Z value to evaluate at */
    register int	n;
    int		m;

    for ( m=0; m < nroots; ++m ){
	/* Select value of Z to evaluate at */
	zr = bn_cx_real( &roots[m] );
	zi = bn_cx_imag( &roots[m] );

	/* Initialize */
	er = eqn->cf[0];
	/* ei = 0.0; */

	/* n=1 step.  Broken out because ei = 0.0 */
	ei = er*zi;		/* must come before er= */
	er = er*zr + eqn->cf[1];

	/* Remaining steps */
	for ( n=2; n <= eqn->dgr; ++n)  {
	    register fastf_t	tr, ti;	/* temps */
	    tr = er*zr - ei*zi + eqn->cf[n];
	    ti = er*zi + ei*zr;
	    er = tr;
	    ei = ti;
	}
	if ( fabs( er ) > 1.0e-5 || fabs( ei ) > 1.0e-5 )
	    return 1;	/* FAIL */
    }
    /* Evaluating polynomial for all Z values gives zero */
    return 0;			/* OK */
}


/**
 * R T _ P O L Y _ D E F L A T E
 *
 * Deflates a polynomial by a given root.
 */
void
rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root)
{
    bn_poly_t div = bn_Zero_poly;
    bn_poly_t rem = bn_Zero_poly;

    /* Make a polynomial out of the given root:  Linear for a real
     * root, Quadratic for a complex root (since they come in con-
     * jugate pairs).
     */
    if ( NEAR_ZERO( root->im, SMALL) ) {
	/*  root is real		*/
	div.dgr = 1;
	div.cf[0] = 1;
	div.cf[1] = - root->re;
    } else {
	/*  root is complex		*/
	div.dgr = 2;
	div.cf[0] = 1;
	div.cf[1] = -2 * root->re;
	div.cf[2] = bn_cx_amplsq( root );
    }

    /* Use synthetic division to find the quotient (new polynomial)
     * and the remainder (should be zero if the root was really a
     * root).
     */
    bn_poly_synthetic_division(oldP, &rem, oldP, &div);
}


/**
 * R T _ P O L Y _ R O O T S
 *
 * WARNING: The polynomial given as input is destroyed by this
 * routine.  The caller must save it if it is important!
 *
 * NOTE : This routine is written for polynomials with real
 * coefficients ONLY.  To use with complex coefficients, the Complex
 * Math library should be used throughout.  Some changes in the
 * algorithm will also be required.
 */
int
rt_poly_roots(register bn_poly_t	*eqn,	/* equation to be solved */
	      register bn_complex_t	roots[], /* space to put roots found */
	      const char *name) /* name of the primitive being checked */
{
    register int	n;		/* number of roots found	*/
    fastf_t	factor;		/* scaling factor for copy	*/

    /* Remove leading coefficients which are too close to zero,
     * to prevent the polynomial factoring from blowing up, below.
     */
    while( NEAR_ZERO( eqn->cf[0], SMALL ) )  {
	for ( n=0; n <= eqn->dgr; n++ ){
	    eqn->cf[n] = eqn->cf[n+1];
	}
	if ( --eqn->dgr <= 0 )
	    return 0;
    }

    /* Factor the polynomial so the first coefficient is one
     * for ease of handling.
     */
    factor = 1.0 / eqn->cf[0];
    (void) bn_poly_scale( eqn, factor );
    n = 0;		/* Number of roots found */

    /* A trailing coefficient of zero indicates that zero
     * is a root of the equation.
     */
    while( NEAR_ZERO( eqn->cf[eqn->dgr], SMALL ) )  {
	roots[n].re = roots[n].im = 0.0;
	--eqn->dgr;
	++n;
    }

    while ( eqn->dgr > 2 ){
	if ( eqn->dgr == 4 )  {
	    if( bn_poly_quartic_roots(&roots[n], eqn) )  {
		if( rt_poly_checkroots( eqn, &roots[n], 4 ) == 0 )  {
		    return( n+4 );
		}
	    }
	} else if ( eqn->dgr == 3 )  {
	    if( bn_poly_cubic_roots( &roots[n], eqn ) )  {
		if ( rt_poly_checkroots( eqn, &roots[n], 3 ) == 0 )  {
		    return ( n+3 );
		}
	    }
	}

	/*
	 *  Set initial guess for root to almost zero.
	 *  This method requires a small nudge off the real axis.
	 */
	bn_cx_cons( &roots[n], 0.0, SMALL );
	if ( (rt_poly_findroot( eqn, &roots[n], name )) < 0 )
	    return(n);	/* return those we found, anyways */

	if ( fabs(roots[n].im) > 1.0e-5* fabs(roots[n].re) ){
	    /* If root is complex, its complex conjugate is
	     * also a root since complex roots come in con-
	     * jugate pairs when all coefficients are real.
	     */
	    ++n;
	    roots[n] = roots[n-1];
	    bn_cx_conj(&roots[n]);
	} else {
	    /* Change 'practically real' to real		*/
	    roots[n].im = 0.0;
	}

	rt_poly_deflate( eqn, &roots[n] );
	++n;
    }

    /* For polynomials of lower degree, iterative techniques
     * are an inefficient way to find the roots.
     */
    if ( eqn->dgr == 1 ){
	roots[n].re = -(eqn->cf[1]);
	roots[n].im = 0.0;
	++n;
    } else if ( eqn->dgr == 2 ){
	bn_poly_quadratic_roots(&roots[n], eqn);
	n += 2;
    }
    return n;
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@ws
@
text
@d37 1
a37 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.22 2007/05/17 04:00:56 brlcad Exp $ (BRL)";
d52 1
a52 1
static const struct bn_poly	bn_Zero_poly = { BN_POLY_MAGIC, 0, {0.0} };
d124 7
a130 7
    LOCAL bn_complex_t  p0, p1, p2;	/* evaluated polynomial+derivatives */
    LOCAL bn_complex_t  p1_H;		/* p1 - H, temporary */
    LOCAL bn_complex_t  cZ, cH;		/* 'Z' and H(Z) in comment	*/
    LOCAL bn_complex_t  T;		/* temporary for making H */
    FAST fastf_t	diff=0.0;		/* test values for convergence	*/
    FAST fastf_t	b=0.0;		/* floating temps */
    LOCAL int	n;
d259 2
a260 2
    LOCAL bn_poly_t	div = bn_Zero_poly;
    LOCAL bn_poly_t rem = bn_Zero_poly;
d304 1
a304 1
    LOCAL fastf_t	factor;		/* scaling factor for copy	*/
@


14.22
log
@initialize the structs for good measure, even though bn_poly_synthetic_division() will too
@
text
@d37 1
a37 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.21 2007/05/16 20:38:15 brlcad Exp $ (BRL)";
d76 3
a78 3
					/* input */
					/* input */
					/* outputs */
d80 2
a81 2
	register int	n;
	register int	m;
d83 14
a96 15
	bn_cx_cons(b,eqn->cf[0],0.0);
	*c = *b;
	*d = *c;

	for ( n=1; ( m = eqn->dgr - n ) >= 0; ++n){
		bn_cx_mul( b, cZ );
		b->re += eqn->cf[n];
		if ( m > 0 ){
			bn_cx_mul( c, cZ );
			bn_cx_add( c, b );
		}
		if ( m > 1 ){
			bn_cx_mul( d, cZ );
			bn_cx_add( d, c );
		}
d98 1
d124 37
a160 59
	LOCAL bn_complex_t  p0, p1, p2;	/* evaluated polynomial+derivatives */
	LOCAL bn_complex_t  p1_H;		/* p1 - H, temporary */
	LOCAL bn_complex_t  cZ, cH;		/* 'Z' and H(Z) in comment	*/
	LOCAL bn_complex_t  T;		/* temporary for making H */
	FAST fastf_t	diff=0.0;		/* test values for convergence	*/
	FAST fastf_t	b=0.0;		/* floating temps */
	LOCAL int	n;
	register int	i;		/* iteration counter		*/

	for( i=0; i < 20; i++ ) {
		cZ = *nxZ;
		rt_poly_eval_w_2derivatives( &cZ, eqn, &p0, &p1, &p2 );

		/* Compute H for Laguerre's method. */
		n = eqn->dgr-1;
		bn_cx_mul2( &cH, &p1, &p1 );
		bn_cx_scal( &cH, (double)(n*n) );
		bn_cx_mul2( &T, &p2, &p0 );
		bn_cx_scal( &T, (double)(eqn->dgr*n) );
		bn_cx_sub( &cH, &T );

		/* Calculate the next iteration for Laguerre's method.
		 * Test to see whether addition or subtraction gives the
		 * larger denominator for the next 'Z' , and use the
		 * appropriate value in the formula.
		 */
		bn_cx_sqrt( &cH, &cH );
		p1_H = p1;
		bn_cx_sub( &p1_H, &cH );
		bn_cx_add( &p1, &cH );		/* p1 <== p1+H */
		bn_cx_scal( &p0, (double)(eqn->dgr) );
		if ( bn_cx_amplsq( &p1_H ) > bn_cx_amplsq( &p1 ) ){
			bn_cx_div( &p0, &p1_H);
			bn_cx_sub( nxZ, &p0 );
		} else {
			bn_cx_div( &p0, &p1 );
			bn_cx_sub( nxZ, &p0 );
		}

		/* Use proportional convergence test to allow very small
		 * roots and avoid wasting time on large roots.
		 * The original version used bn_cx_ampl(), which requires
		 * a square root.  Using bn_cx_amplsq() saves lots of cycles,
		 * but changes loop termination conditions somewhat.
		 *
		 * diff is |p0|**2.  nxZ = Z - p0.
		 *
		 * SGI XNS IRIS 3.5 compiler fails if following 2 assignments
		 * are imbedded in the IF statement, as before.
		 */
		b = bn_cx_amplsq( nxZ );
		diff = bn_cx_amplsq( &p0 );
		if( b < diff )
			continue;
		if( (b-diff) == b )
			return(i);		/* OK -- can't do better */
		if( diff > (b - diff)*1.0e-5 )
			continue;
		return(i);			/* OK */
d163 27
a189 5
	/* If the thing hasn't converged yet, it probably won't. */
	bu_log("rt_poly_findroot: solving for %s didn't converge in %d iterations, b=%g, diff=%g\n",
		str, i, b, diff);
	bu_log("nxZ=%gR+%gI, p0=%gR+%gI\n", nxZ->re, nxZ->im, p0.re, p0.im);
	return(-1);		/* ERROR */
d217 25
a241 28
	register fastf_t	er, ei;		/* "epoly" */
	register fastf_t	zr, zi;		/* Z value to evaluate at */
	register int	n;
	int		m;

	for ( m=0; m < nroots; ++m ){
		/* Select value of Z to evaluate at */
		zr = bn_cx_real( &roots[m] );
		zi = bn_cx_imag( &roots[m] );

		/* Initialize */
		er = eqn->cf[0];
		/* ei = 0.0; */

		/* n=1 step.  Broken out because ei = 0.0 */
		ei = er*zi;		/* must come before er= */
		er = er*zr + eqn->cf[1];

		/* Remaining steps */
		for ( n=2; n <= eqn->dgr; ++n)  {
			register fastf_t	tr, ti;	/* temps */
			tr = er*zr - ei*zi + eqn->cf[n];
			ti = er*zi + ei*zr;
			er = tr;
			ei = ti;
		}
		if ( fabs( er ) > 1.0e-5 || fabs( ei ) > 1.0e-5 )
			return 1;	/* FAIL */
d243 5
a247 2
	/* Evaluating polynomial for all Z values gives zero */
	return 0;			/* OK */
d259 2
a260 19
	LOCAL bn_poly_t	div = bn_Zero_poly;
	LOCAL bn_poly_t rem = bn_Zero_poly;

	/* Make a polynomial out of the given root:  Linear for a real
	 * root, Quadratic for a complex root (since they come in con-
	 * jugate pairs).
	 */
	if ( NEAR_ZERO( root->im, SMALL) ) {
		/*  root is real		*/
		div.dgr = 1;
		div.cf[0] = 1;
		div.cf[1] = - root->re;
	} else {
		/*  root is complex		*/
		div.dgr = 2;
		div.cf[0] = 1;
		div.cf[1] = -2 * root->re;
		div.cf[2] = bn_cx_amplsq( root );
	}
d262 22
a283 5
	/* Use synthetic division to find the quotient (new polynomial)
	 * and the remainder (should be zero if the root was really a
	 * root).
	 */
	bn_poly_synthetic_division(oldP, &rem, oldP, &div);
d303 2
a304 2
	register int	n;		/* number of roots found	*/
	LOCAL fastf_t	factor;		/* scaling factor for copy	*/
d306 6
a311 9
	/* Remove leading coefficients which are too close to zero,
	 * to prevent the polynomial factoring from blowing up, below.
	 */
	while( NEAR_ZERO( eqn->cf[0], SMALL ) )  {
		for ( n=0; n <= eqn->dgr; n++ ){
			eqn->cf[n] = eqn->cf[n+1];
		}
		if ( --eqn->dgr <= 0 )
			return 0;
d313 25
a337 30

	/* Factor the polynomial so the first coefficient is one
	 * for ease of handling.
	 */
	factor = 1.0 / eqn->cf[0];
	(void) bn_poly_scale( eqn, factor );
	n = 0;		/* Number of roots found */

	/* A trailing coefficient of zero indicates that zero
	 * is a root of the equation.
	 */
	while( NEAR_ZERO( eqn->cf[eqn->dgr], SMALL ) )  {
		roots[n].re = roots[n].im = 0.0;
		--eqn->dgr;
		++n;
	}

	while ( eqn->dgr > 2 ){
		if ( eqn->dgr == 4 )  {
			if( bn_poly_quartic_roots(&roots[n], eqn) )  {
				if( rt_poly_checkroots( eqn, &roots[n], 4 ) == 0 )  {
					return( n+4 );
				}
			}
		} else if ( eqn->dgr == 3 )  {
			if( bn_poly_cubic_roots( &roots[n], eqn ) )  {
				if ( rt_poly_checkroots( eqn, &roots[n], 3 ) == 0 )  {
					return ( n+3 );
				}
			}
d339 5
a343 20

		/*
		 *  Set initial guess for root to almost zero.
		 *  This method requires a small nudge off the real axis.
		 */
		bn_cx_cons( &roots[n], 0.0, SMALL );
		if ( (rt_poly_findroot( eqn, &roots[n], name )) < 0 )
			return(n);	/* return those we found, anyways */

		if ( fabs(roots[n].im) > 1.0e-5* fabs(roots[n].re) ){
			/* If root is complex, its complex conjugate is
			 * also a root since complex roots come in con-
			 * jugate pairs when all coefficients are real.
			 */
			++n;
			roots[n] = roots[n-1];
			bn_cx_conj(&roots[n]);
		} else {
			/* Change 'practically real' to real		*/
			roots[n].im = 0.0;
d345 1
a345 3

		rt_poly_deflate( eqn, &roots[n] );
		++n;
d348 3
a350 2
	/* For polynomials of lower degree, iterative techniques
	 * are an inefficient way to find the roots.
d352 15
a366 7
	if ( eqn->dgr == 1 ){
		roots[n].re = -(eqn->cf[1]);
		roots[n].im = 0.0;
		++n;
	} else if ( eqn->dgr == 2 ){
		bn_poly_quadratic_roots(&roots[n], eqn);
		n += 2;
d368 17
a384 1
	return n;
@


14.21
log
@apparently, I lied -- they weren't in order yet.  now they are, and include doxygenified comments
@
text
@d37 1
a37 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.20 2007/05/16 20:22:36 brlcad Exp $ (BRL)";
d52 3
d259 2
a260 1
	LOCAL bn_poly_t	div, rem;
@


14.20
log
@remove forward decls, they're already in usage order
@
text
@d37 1
a37 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.19 2007/05/16 06:26:34 brlcad Exp $ (BRL)";
d52 12
a63 2
/*
 *			R T _ P O L Y _ R O O T S
d65 1
a65 2
 *	WARNING:  The polynomial given as input is destroyed by this
 *		routine.  The caller must save it if it is important!
d67 3
a69 4
 *	NOTE :  This routine is written for polynomials with real coef-
 *		ficients ONLY.  To use with complex coefficients, the
 *		Complex Math library should be used throughout.
 *		Some changes in the algorithm will also be required.
d71 5
a75 4
int
rt_poly_roots(register bn_poly_t	*eqn,	/* equation to be solved */
	      register bn_complex_t	roots[], /* space to put roots found */
	      const char *name) /* name of the primitive being checked */
d77 2
a78 2
	register int	n;		/* number of roots found	*/
	LOCAL fastf_t	factor;		/* scaling factor for copy	*/
d80 3
a82 10
	/* Remove leading coefficients which are too close to zero,
	 * to prevent the polynomial factoring from blowing up, below.
	 */
	while( NEAR_ZERO( eqn->cf[0], SMALL ) )  {
		for ( n=0; n <= eqn->dgr; n++ ){
			eqn->cf[n] = eqn->cf[n+1];
		}
		if ( --eqn->dgr <= 0 )
			return 0;
	}
d84 6
a89 29
	/* Factor the polynomial so the first coefficient is one
	 * for ease of handling.
	 */
	factor = 1.0 / eqn->cf[0];
	(void) bn_poly_scale( eqn, factor );
	n = 0;		/* Number of roots found */

	/* A trailing coefficient of zero indicates that zero
	 * is a root of the equation.
	 */
	while( NEAR_ZERO( eqn->cf[eqn->dgr], SMALL ) )  {
		roots[n].re = roots[n].im = 0.0;
		--eqn->dgr;
		++n;
	}

	while ( eqn->dgr > 2 ){
		if ( eqn->dgr == 4 )  {
			if( bn_poly_quartic_roots(&roots[n], eqn) )  {
				if( rt_poly_checkroots( eqn, &roots[n], 4 ) == 0 )  {
					return( n+4 );
				}
			}
		} else if ( eqn->dgr == 3 )  {
			if( bn_poly_cubic_roots( &roots[n], eqn ) )  {
				if ( rt_poly_checkroots( eqn, &roots[n], 3 ) == 0 )  {
					return ( n+3 );
				}
			}
d91 3
a93 20

		/*
		 *  Set initial guess for root to almost zero.
		 *  This method requires a small nudge off the real axis.
		 */
		bn_cx_cons( &roots[n], 0.0, SMALL );
		if ( (rt_poly_findroot( eqn, &roots[n], name )) < 0 )
			return(n);	/* return those we found, anyways */

		if ( fabs(roots[n].im) > 1.0e-5* fabs(roots[n].re) ){
			/* If root is complex, its complex conjugate is
			 * also a root since complex roots come in con-
			 * jugate pairs when all coefficients are real.
			 */
			++n;
			roots[n] = roots[n-1];
			bn_cx_conj(&roots[n]);
		} else {
			/* Change 'practically real' to real		*/
			roots[n].im = 0.0;
a94 3

		rt_poly_deflate( eqn, &roots[n] );
		++n;
d96 1
a97 13
	/* For polynomials of lower degree, iterative techniques
	 * are an inefficient way to find the roots.
	 */
	if ( eqn->dgr == 1 ){
		roots[n].re = -(eqn->cf[1]);
		roots[n].im = 0.0;
		++n;
	} else if ( eqn->dgr == 2 ){
		bn_poly_quadratic_roots(&roots[n], eqn);
		n += 2;
	}
	return n;
}
d99 10
a108 2
/*
 *			R T _ P O L Y _ F I N D R O O T
d110 2
a111 15
 *	Calculates one root of a polynomial ( p(Z) ) using Laguerre's
 *	method.  This is an iterative technique which has very good
 *	global convergence properties.  The formulas for this method
 *	are
 *
 *					n * p(Z)
 *		newZ  =  Z  -  -----------------------  ,
 *				p'(Z) +- sqrt( H(Z) )
 *
 *	where
 *		H(Z) = (n-1) [ (n-1)(p'(Z))^2 - n p(Z)p''(Z) ],
 *
 *	where n is the degree of the polynomial.  The sign in the
 *	denominator is chosen so that  |newZ - Z|  is as small as
 *	possible.
d113 2
d190 2
a191 50
/*
 *			R T _ P O L Y _ E V A L _ W _ 2 D E R I V A T I V E S
 *
 *	Evaluates p(Z), p'(Z), and p''(Z) for any Z (real or complex).
 *	Given an equation of the form
 *
 *		p(Z) = a0*Z^n + a1*Z^(n-1) +... an != 0,
 *
 *	the function value and derivatives needed for the iterations
 *	can be computed by synthetic division using the formulas
 *
 *		p(Z) = bn,    p'(Z) = c(n-1),    p''(Z) = d(n-2),
 *
 *	where
 *
 *		b0 = a0,	bi = b(i-1)*Z + ai,	i = 1,2,...n
 *		c0 = b0,	ci = c(i-1)*Z + bi,	i = 1,2,...n-1
 *		d0 = c0,	di = d(i-1)*Z + ci,	i = 1,2,...n-2
 *
 */
void
rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d)
					/* input */
					/* input */
					/* outputs */
{
	register int	n;
	register int	m;

	bn_cx_cons(b,eqn->cf[0],0.0);
	*c = *b;
	*d = *c;

	for ( n=1; ( m = eqn->dgr - n ) >= 0; ++n){
		bn_cx_mul( b, cZ );
		b->re += eqn->cf[n];
		if ( m > 0 ){
			bn_cx_mul( c, cZ );
			bn_cx_add( c, b );
		}
		if ( m > 1 ){
			bn_cx_mul( d, cZ );
			bn_cx_add( d, c );
		}
	}
}


/*
 *			R T _ P O L Y _ C H E C K R O O T S
d193 3
a195 3
 *	Evaluates p(Z) for any Z (real or complex).
 *	In this case, test all "nroots" entries of roots[] to ensure
 *	that they are roots (zeros) of this polynomial.
a209 1
 *
d248 2
a249 2
/*
 *			R T _ P O L Y _ D E F L A T E
d251 1
a251 2
 *
 *	Deflates a polynomial by a given root.
d282 102
@


14.19
log
@gah, unbreak the root solver -- compat4 params are swapped like the others, just in a pair.  thx john!
@
text
@a32 1
 *
d37 1
a37 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.18 2007/05/15 03:52:33 brlcad Exp $ (BRL)";
a41 1

d44 1
a50 5
int	rt_poly_roots(register bn_poly_t *eqn, register bn_complex_t *roots, const char *name);
void	rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d);
void	rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root);
int	rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ, const char *str);
int	rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots);
@


14.18
log
@bn_poly_ root solver routines have the equation as the second param
@
text
@d38 1
a38 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.17 2007/05/14 21:04:32 brlcad Exp $ (BRL)";
d391 1
a391 1
	bn_poly_synthetic_division( oldP, &div, oldP, &rem );
@


14.17
log
@gah, pick up where someone left off over half a decade ago.  finish updating all of the compat4 symbols throughout the code to their new names.  finally. it's done.  make the deprecated headers obsolete -- make compat4.h obsolete too so we can be sure that all of the changes are now picked up by the compiler as errors.  this change will likely impact muves if they've similarly not updated to the new names too, so the headers are kept with a #warning for now (though will likely disappear down the road entirely).
@
text
@d38 1
a38 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.16 2007/01/27 01:41:42 brlcad Exp $ (BRL)";
d106 1
a106 1
			if( bn_poly_quartic_roots( eqn, &roots[n] ) )  {
d112 1
a112 1
			if( bn_poly_cubic_roots( eqn, &roots[n] ) )  {
d152 1
a152 1
		bn_poly_quadratic_roots( eqn, &roots[n] );
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.15 2007/01/23 01:13:39 brlcad Exp $ (BRL)";
d106 1
a106 1
			if( rt_poly_quartic_roots( eqn, &roots[n] ) )  {
d112 1
a112 1
			if( rt_poly_cubic_roots( eqn, &roots[n] ) )  {
d152 1
a152 1
		rt_poly_quadratic_roots( eqn, &roots[n] );
d391 1
a391 1
	rt_poly_synthetic_division( oldP, &div, oldP, &rem );
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.14 2007/01/21 04:45:45 brlcad Exp $ (BRL)";
a43 1

d274 3
a276 3
                     	    		/* input */
                  	     		/* input */
                     	           	/* outputs */
@


14.14
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d38 1
a38 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.13 2007/01/20 14:36:55 brlcad Exp $ (BRL)";
@


14.13
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 1
/*@@{*/
d24 1
d36 1
a36 1
/*@@}*/
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.12 2006/09/16 02:04:26 lbutler Exp $ (BRL)";
@


14.12
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.11 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
@


14.11
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup librt */
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.10 2005/10/23 04:44:36 brlcad Exp $ (BRL)";
@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.9 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
@


14.9
log
@Doxygen changes
@
text
@d29 1
a29 1
 *  
d34 1
a34 1
 *  
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.8 2005/05/01 22:56:08 brlcad Exp $ (BRL)";
d62 1
a62 1
 *	
d175 1
a175 1
 *	where n is the degree of the polynomial.  The sign in the 
d241 1
a241 1
		if( diff > (b - diff)*1.0e-5 ) 
@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d34 1
a34 1
 *
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header$ (BRL)";
d62 1
a62 1
 *
d175 1
a175 1
 *	where n is the degree of the polynomial.  The sign in the
d241 1
a241 1
		if( diff > (b - diff)*1.0e-5 )
@


14.8
log
@reword the convergence failure message
@
text
@d21 3
d25 1
a25 3
 *
 *  Functions -
 *	rt_poly_roots		Find the roots of a polynomial
d36 2
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.7 2005/04/29 14:22:53 lbutler Exp $ (BRL)";
@


14.7
log
@When the root finder rt_poly_findroot cannot find roots, it now tells you the name of the primitive.
This is not always an error.  Frequently, this results from a ray grazing the primitve.  However, it is
reasonable for the user to want to know and examine the primitive, and asses the impact on the analysis
being performed.
@
text
@d36 1
a36 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.6 2005/01/30 20:31:03 brlcad Exp $ (BRL)";
d70 2
a71 2
	      register bn_complex_t	roots[],
	      const char *name)/* space to put roots found */
d244 2
a245 2
	bu_log("rt_poly_findroot:  didn't converge in %d iterations, b=%g, diff=%g  %s\n",
		i, b, diff, str);
@


14.6
log
@update copyright to 2005
@
text
@d36 1
a36 1
static const char RCSroots[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/roots.c,v 14.5 2004/12/21 06:38:21 morrison Exp $ (BRL)";
d51 5
a55 3
int		rt_poly_roots(register bn_poly_t *eqn, register bn_complex_t *roots);
void	rt_poly_eval_w_2derivatives(register bn_complex_t *cZ, register bn_poly_t *eqn, register bn_complex_t *b, register bn_complex_t *c, register bn_complex_t *d), rt_poly_deflate(register bn_poly_t *oldP, register bn_complex_t *root);
int	rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ), rt_poly_checkroots(register bn_poly_t *eqn, bn_complex_t *roots, register int nroots);
d70 2
a71 1
	      register bn_complex_t	roots[])/* space to put roots found */
d123 1
a123 1
		if ( (rt_poly_findroot( eqn, &roots[n] )) < 0 )
d178 3
a180 3
rt_poly_findroot(register bn_poly_t *eqn, register bn_complex_t *nxZ)
                  	     	/* polynomial			*/
                     	     	/* initial guess for root	*/
d244 2
a245 2
	bu_log("rt_poly_findroot:  didn't converge in %d iterations, b=%g, diff=%g\n",
		i, b, diff);
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d36 1
a36 1
static const char RCSroots[] = "@@(#)$Header: /cvs/brlcad/src/librt/roots.c,v 14.4 2004/12/21 06:18:48 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a33 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d36 1
a36 1
static const char RCSroots[] = "@@(#)$Header: /cvs/brlcad/src/librt/roots.c,v 14.3 2004/12/21 05:45:24 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvs/brlcad/src/librt/roots.c,v 14.2 2004/12/21 04:18:21 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvs/brlcad/src/librt/roots.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *  			R O O T S . C
d39 1
a39 1
static const char RCSroots[] = "@@(#)$Header: /cvs/brlcad/src/librt/roots.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /cvs/brlcad/src/librt/roots.c,v 1.1 2004/05/20 15:20:10 morrison Exp $ (BRL)";
d373 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char RCSroots[] = "@@(#)$Header: /cvs/brlcad/librt/roots.c,v 11.13 2004/05/10 15:30:47 erikg Exp $ (BRL)";
d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

