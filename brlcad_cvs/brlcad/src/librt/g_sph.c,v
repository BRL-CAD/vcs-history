head	14.20;
access;
symbols
	rel-7-10-4:14.14
	STABLE:14.14.0.2
	stable-branch:14.6
	rel-7-10-2:14.14
	rel-7-10-0:14.14
	rel-7-8-4:14.10
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.20
date	2007.12.17.07.53.18;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.12.17.02.16.54;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.11.28.14.11.27;	author erikgreenwald;	state Exp;
branches;
next	14.17;

14.17
date	2007.10.22.21.06.48;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.09.15.16.23.13;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.41;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.37;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.21.04.45.44;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.31.08;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.31.00;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.21;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.24;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.16;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.02;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.20
log
@my bad deprecation instruction, revert/remove the LOCAL -> static conversion.  LOCAL is only static for non-SMP systems, but usually auto.
@
text
@/*                         G _ S P H . C
 * BRL-CAD
 *
 * Copyright (c) 1985-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup g_ */
/** @@{ */
/** @@file g_sph.c
 *
 *	Intersect a ray with a Sphere.
 *	Special case of the Generalized Ellipsoid
 *
 *  Authors -
 *	Phillip Dykstra
 *	Dave Becker		(Vectorization)
 *
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 */
/** @@} */

#include "common.h"

#include <stdio.h>
#include <string.h>
#include <math.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "rtgeom.h"
#include "./debug.h"

/*
 *  Algorithm:
 *
 *  Given V, A, where |A| = Radius, there is a set of points on this sphere
 *
 *  { (x,y,z) | (x,y,z) is on sphere defined by V, A }
 *
 *  To find the intersection of a line with the sphere, consider
 *  the parametric line L:
 *
 *  	L : { P(n) | P + t(n) . D }
 *
 *  Call W the actual point of intersection between L and the sphere.
 *
 *  NORMALS.  Given the point W on the sphere, what is the vector
 *  normal to the tangent plane at that point?
 *
 *  N = (W - V) / |A|
 */

struct sph_specific {
	vect_t	sph_V;		/* Vector to center of sphere */
	fastf_t	sph_radsq;	/* Radius squared */
	fastf_t	sph_invrad;	/* Inverse radius (for normal) */
	fastf_t	sph_rad;	/* Radius */
	mat_t	sph_SoR;	/* Rotate and scale for UV mapping */
};

/**
 *  			R T _ S P H _ P R E P
 *
 *  Given a pointer to a GED database record, and a transformation matrix,
 *  determine if this is a valid sphere, and if so, precompute various
 *  terms of the formula.
 *
 *  Returns -
 *  	0	SPH is OK
 *  	!0	Error in description
 *
 *  Implicit return -
 *  	A struct sph_specific is created, and it's address is stored in
 *  	stp->st_specific for use by rt_sph_shot().
 *	If the ELL is really a SPH, stp->st_id is modified to ID_SPH.
 */
int
rt_sph_prep(struct soltab *stp, struct rt_db_internal *ip, struct rt_i *rtip)
{
	register struct sph_specific *sph;
	fastf_t	magsq_a, magsq_b, magsq_c;
	vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	fastf_t	f;
	struct rt_ell_internal	*eip;

	eip = (struct rt_ell_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(eip);

	/* Validate that |A| > 0, |B| > 0, |C| > 0 */
	magsq_a = MAGSQ( eip->a );
	magsq_b = MAGSQ( eip->b );
	magsq_c = MAGSQ( eip->c );
	if( magsq_a < rtip->rti_tol.dist || magsq_b < rtip->rti_tol.dist || magsq_c < rtip->rti_tol.dist ) {
		bu_log("sph(%s):  zero length A(%g), B(%g), or C(%g) vector\n",
			stp->st_name, magsq_a, magsq_b, magsq_c );
		return(1);		/* BAD */
	}

	/* Validate that |A|, |B|, and |C| are nearly equal */
	if( fabs(magsq_a - magsq_b) > 0.0001
	    || fabs(magsq_a - magsq_c) > 0.0001 ) {
#if 0
		/* Ordinarily, don't say anything here, will handle as ELL */
		bu_log("sph(%s):  non-equal length A, B, C vectors\n",
			stp->st_name );
#endif
		return(1);		/* ELL, not SPH */
	}

	/* Create unit length versions of A,B,C */
	f = 1.0/sqrt(magsq_a);
	VSCALE( Au, eip->a, f );
	f = 1.0/sqrt(magsq_b);
	VSCALE( Bu, eip->b, f );
	f = 1.0/sqrt(magsq_c);
	VSCALE( Cu, eip->c, f );

	/* Validate that A.B == 0, B.C == 0, A.C == 0 (check dir only) */
	f = VDOT( Au, Bu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("sph(%s):  A not perpendicular to B, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( Bu, Cu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("sph(%s):  B not perpendicular to C, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}
	f = VDOT( Au, Cu );
	if( ! NEAR_ZERO(f, rtip->rti_tol.dist) )  {
		bu_log("sph(%s):  A not perpendicular to C, f=%f\n",stp->st_name, f);
		return(1);		/* BAD */
	}

	/*
	 *  This ELL is really an SPH
	 */
	stp->st_id = ID_SPH;		/* "fix" soltab ID */
	stp->st_meth = &rt_functab[ID_SPH];

	/* Solid is OK, compute constant terms now */
	BU_GETSTRUCT( sph, sph_specific );
	stp->st_specific = (genptr_t)sph;

	VMOVE( sph->sph_V, eip->v );

	sph->sph_radsq = magsq_a;
	sph->sph_rad = sqrt(sph->sph_radsq);
	sph->sph_invrad = 1.0 / sph->sph_rad;

	/*
	 * Save the matrix which rotates our ABC to world
	 * XYZ respectively, and scales points on surface
	 * to unit length.  Used here in UV mapping.
	 * See ell.c for details.
	 */
	MAT_IDN( sph->sph_SoR );
	VSCALE( &sph->sph_SoR[0], eip->a, 1.0/magsq_a );
	VSCALE( &sph->sph_SoR[4], eip->b, 1.0/magsq_b );
	VSCALE( &sph->sph_SoR[8], eip->c, 1.0/magsq_c );

	/* Compute bounding sphere */
	VMOVE( stp->st_center, sph->sph_V );
	stp->st_aradius = stp->st_bradius = sph->sph_rad;

	/* Compute bounding RPP */
	stp->st_min[X] = sph->sph_V[X] - sph->sph_rad;
	stp->st_max[X] = sph->sph_V[X] + sph->sph_rad;
	stp->st_min[Y] = sph->sph_V[Y] - sph->sph_rad;
	stp->st_max[Y] = sph->sph_V[Y] + sph->sph_rad;
	stp->st_min[Z] = sph->sph_V[Z] - sph->sph_rad;
	stp->st_max[Z] = sph->sph_V[Z] + sph->sph_rad;

	return(0);			/* OK */
}

/**
 *			R T _ S P H _ P R I N T
 */
void
rt_sph_print(register const struct soltab *stp)
{
	register const struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;

	VPRINT("V", sph->sph_V);
	bu_log("Rad %g\n", sph->sph_rad);
	bu_log("Radsq %g\n", sph->sph_radsq);
	bu_log("Invrad %g\n", sph->sph_invrad);
	bn_mat_print("S o R", sph->sph_SoR );
}

/**
 *  			R T _ S P H _ S H O T
 *
 *  Intersect a ray with a sphere.
 *  If an intersection occurs, a struct seg will be acquired
 *  and filled in.
 *  Notes: In the quadratic equation,
 *   A is MAGSQ(r_dir) which is always equal to 1, so it does not appear.
 *   The sign of B is reversed (vector is reversed) to save negation.
 *   We have factored out the 2 and 4 constants.
 *  Claim: The straight quadratic formula leads to precision problems
 *   if either A or C are small.  In our case A is always 1.  C is a
 *   radial distance of the ray origin from the sphere surface.  Thus
 *   if we are shooting from near the surface we may have problems.
 *   XXX - investigate this.
 *
 *  Returns -
 *  	0	MISS
 *	>0	HIT
 */
int
rt_sph_shot(struct soltab *stp, register struct xray *rp, struct application *ap, struct seg *seghead)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;
	register struct seg *segp;

	vect_t	ov;		/* ray orgin to center (V - P) */
	fastf_t	magsq_ov;	/* length squared of ov */
	fastf_t	b;		/* second term of quadratic eqn */
	fastf_t	root;		/* root of radical */

	VSUB2( ov, sph->sph_V, rp->r_pt );
	b = VDOT( rp->r_dir, ov );
	magsq_ov = MAGSQ(ov);

	if( magsq_ov >= sph->sph_radsq ) {
		/* ray origin is outside of sphere */
		if( b < 0 ) {
			/* ray direction is away from sphere */
			return(0);		/* No hit */
		}
		root = b*b - magsq_ov + sph->sph_radsq;
		if( root <= 0 ) {
			/* no real roots */
			return(0);		/* No hit */
		}
	} else {
		root = b*b - magsq_ov + sph->sph_radsq;
	}
	root = sqrt(root);

	RT_GET_SEG(segp, ap->a_resource);
	segp->seg_stp = stp;

	/* we know root is positive, so we know the smaller t */
	segp->seg_in.hit_dist = b - root;
	segp->seg_out.hit_dist = b + root;
	BU_LIST_INSERT( &(seghead->l), &(segp->l) );
	return(2);			/* HIT */
}

#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;
/**
 *			R T _ S P H _ V S H O T
 *
 *  This is the Becker vectorized version
 */
void
rt_sph_vshot(struct soltab **stp, struct xray **rp, struct seg *segp, int n, struct application *ap)
			       /* An array of solid pointers */
			       /* An array of ray pointers */
			       /* array of segs (results returned) */
			       /* Number of ray/object pairs */

{
	register struct sph_specific *sph;
	register int    i;

	vect_t	ov;		/* ray orgin to center (V - P) */
	fastf_t	magsq_ov;	/* length squared of ov */
	fastf_t	b;		/* second term of quadratic eqn */
	fastf_t	root;		/* root of radical */

	/* for each ray/sphere pair */
	for(i = 0; i < n; i++){
		if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */

		sph = (struct sph_specific *)stp[i]->st_specific;
		VSUB2( ov, sph->sph_V, rp[i]->r_pt );
		b = VDOT( rp[i]->r_dir, ov );
		magsq_ov = MAGSQ(ov);

		if( magsq_ov >= sph->sph_radsq ) {
			/* ray origin is outside of sphere */
			if( b < 0 ) {
				/* ray direction is away from sphere */
				SEG_MISS(segp[i]);		/* No hit */
				continue;
			}
			root = b*b - magsq_ov + sph->sph_radsq;
			if( root <= 0 ) {
				/* no real roots */
				SEG_MISS(segp[i]);		/* No hit */
				continue;
			}
		} else {
			root = b*b - magsq_ov + sph->sph_radsq;
		}
		root = sqrt(root);

		segp[i].seg_stp = stp[i];

		/* we know root is positive, so we know the smaller t */
		segp[i].seg_in.hit_dist = b - root;
		segp[i].seg_out.hit_dist = b + root;
	}
}

/**
 *  			R T _ S P H _ N O R M
 *
 *  Given ONE ray distance, return the normal and entry/exit point.
 */
void
rt_sph_norm(register struct hit *hitp, struct soltab *stp, register struct xray *rp)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;

	VJOIN1( hitp->hit_point, rp->r_pt, hitp->hit_dist, rp->r_dir );
	VSUB2( hitp->hit_normal, hitp->hit_point, sph->sph_V );
	VSCALE( hitp->hit_normal, hitp->hit_normal, sph->sph_invrad );
}

/**
 *			R T _ S P H _ C U R V E
 *
 *  Return the curvature of the sphere.
 */
void
rt_sph_curve(register struct curvature *cvp, register struct hit *hitp, struct soltab *stp)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;

	cvp->crv_c1 = cvp->crv_c2 = - sph->sph_invrad;

	/* any tangent direction */
	bn_vec_ortho( cvp->crv_pdir, hitp->hit_normal );
}

/**
 *  			R T _ S P H _ U V
 *
 *  For a hit on the surface of an SPH, return the (u,v) coordinates
 *  of the hit point, 0 <= u,v <= 1.
 *  u = azimuth
 *  v = elevation
 */
void
rt_sph_uv(struct application *ap, struct soltab *stp, register struct hit *hitp, register struct uvcoord *uvp)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;
	fastf_t r;
	vect_t work;
	vect_t pprime;

	/* hit_point is on surface;  project back to unit sphere,
	 * creating a vector from vertex to hit point which always
	 * has length=1.0
	 */
	VSUB2( work, hitp->hit_point, sph->sph_V );
	MAT4X3VEC( pprime, sph->sph_SoR, work );
	/* Assert that pprime has unit length */

	/* U is azimuth, atan() range: -pi to +pi */
	uvp->uv_u = bn_atan2( pprime[Y], pprime[X] ) * bn_inv2pi;
	if( uvp->uv_u < 0 )
		uvp->uv_u += 1.0;
	/*
	 *  V is elevation, atan() range: -pi/2 to +pi/2,
	 *  because sqrt() ensures that X parameter is always >0
	 */
	uvp->uv_v = bn_atan2( pprime[Z],
		sqrt( pprime[X] * pprime[X] + pprime[Y] * pprime[Y]) ) *
		bn_invpi + 0.5;

	/* approximation: r / (circumference, 2 * pi * aradius) */
	r = ap->a_rbeam + ap->a_diverge * hitp->hit_dist;
	uvp->uv_du = uvp->uv_dv =
		bn_inv2pi * r / stp->st_aradius;
}

/**
 *		R T _ S P H _ F R E E
 */
void
rt_sph_free(register struct soltab *stp)
{
	register struct sph_specific *sph =
		(struct sph_specific *)stp->st_specific;

	bu_free( (char *)sph, "sph_specific" );
}

int
rt_sph_class(void)
{
	return(0);
}

/* ELL versions of the plot and tess functions are used */


#if 0
/**
 *			R T _ S P H _ I M P O R T 5
 *
 *  Import a sphere from the v5 database format to
 *  the internal structure.
 *  Apply modeling transformations as well.
 */
int
rt_sph_import5( ip, ep, mat, dbip )
struct rt_db_internal		*ip;
const struct bu_external	*ep;
register const mat_t		mat;
const struct db_i		*dbip;
{
	struct rt_sph_internal	*sip;
	fastf_t		vec[3+1];

	BU_CK_EXTERNAL( ep );

	RT_CK_DB_INTERNAL( ip );
	ip->idb_major_type = DB5_MAJORTYPE_BRLCAD;
	ip->idb_type = ID_SPH;
	ip->idb_meth = &rt_functab[ID_SPH];
	ip->idb_ptr = bu_malloc( sizeof(struct rt_sph_internal), "rt_sph_internal");

	sip = (struct rt_sph_internal *)ip->idb_ptr;
	sip->magic = RT_SPH_INTERNAL_MAGIC;

	/* Convert from database to internal format */
	htond( vec, ep->ext_buf, 3+1 );

	/* Apply modeling transformations */
	MAT4X3PNT( sip->v, mat, &vec[0*3] );
	MAT4XSCALOR( sip->r, mat, vec[1*3] );

	return(0);		/* OK */
}

/**
 *			R T _ S P H _ E X P O R T 5
 */
int
rt_sph_export5( ep, ip, local2mm, dbip )
struct bu_external		*ep;
const struct rt_db_internal	*ip;
double				local2mm;
const struct db_i		*dbip;
{
	struct rt_sph_internal	*tip;
	union record		*rec;

	RT_CK_DB_INTERNAL(ip);
	if( ip->idb_type != ID_ELL )  return(-1);
	tip = (struct rt_sph_internal *)ip->idb_ptr;
	RT_ELL_CK_MAGIC(tip);

	BU_CK_EXTERNAL(ep);
	ep->ext_nbytes = sizeof(union record);
	ep->ext_buf = (genptr_t)bu_calloc( 1, ep->ext_nbytes, "sph external");
	rec = (union record *)ep->ext_buf;

	rec->s.s_id = ID_SOLID;
	rec->s.s_type = GENELL;

	/* NOTE: This also converts to dbfloat_t */
	VSCALE( &rec->s.s_values[0], tip->v, local2mm );
	VSCALE( &rec->s.s_values[3], tip->a, local2mm );
	VSCALE( &rec->s.s_values[6], tip->b, local2mm );
	VSCALE( &rec->s.s_values[9], tip->c, local2mm );

	return(0);
}
#endif

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.19
log
@removal of the FAST declaration throughout.  now using register or letting the compiler sort things out.
@
text
@a37 3
#ifndef lint
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.18 2007/11/28 14:11:27 erikgreenwald Exp $ (BRL)";
#endif
d99 3
a101 3
	static fastf_t	magsq_a, magsq_b, magsq_c;
	static vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	static fastf_t	f;
d237 2
a238 1
	static vect_t	ov;		/* ray orgin to center (V - P) */
d288 3
a290 1
	static vect_t	ov;		/* ray orgin to center (V - P) */
a293 1
	register int    i;
d376 3
a378 3
	static fastf_t r;
	static vect_t work;
	static vect_t pprime;
d443 1
a443 1
	static fastf_t		vec[3+1];
@


14.18
log
@LOCAL->static, per machine.h deprecation list
@
text
@d39 1
a39 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.17 2007/10/22 21:06:48 brlcad Exp $ (BRL)";
d241 3
a243 3
	FAST fastf_t	magsq_ov;	/* length squared of ov */
	FAST fastf_t	b;		/* second term of quadratic eqn */
	FAST fastf_t	root;		/* root of radical */
d291 3
a293 3
	FAST fastf_t	magsq_ov;	/* length squared of ov */
	FAST fastf_t	b;		/* second term of quadratic eqn */
	FAST fastf_t	root;		/* root of radical */
@


14.17
log
@removed the non-ansi/stc compliant noalias.h and noalias-prag.h headers that were used with the cray (and alliant) to make pragma decls before loops.  made obsolete long ago with the move to ansi compliance.
@
text
@d39 1
a39 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.16 2007/10/22 20:59:55 brlcad Exp $ (BRL)";
d102 3
a104 3
	LOCAL fastf_t	magsq_a, magsq_b, magsq_c;
	LOCAL vect_t	Au, Bu, Cu;	/* A,B,C with unit length */
	LOCAL fastf_t	f;
d240 1
a240 1
	LOCAL vect_t	ov;		/* ray orgin to center (V - P) */
d290 1
a290 1
	LOCAL vect_t	ov;		/* ray orgin to center (V - P) */
d377 3
a379 3
	LOCAL fastf_t r;
	LOCAL vect_t work;
	LOCAL vect_t pprime;
d444 1
a444 1
	LOCAL fastf_t		vec[3+1];
@


14.16
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d39 1
a39 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.15 2007/09/15 16:23:13 brlcad Exp $ (BRL)";
a296 1
#	include "noalias.h"
@


14.15
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d39 1
a39 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.14 2007/01/27 01:41:41 brlcad Exp $ (BRL)";
a298 1
#if !CRAY	/* XXX currently prevents vectorization on cray */
a299 1
#endif
@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d39 1
a39 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.13 2007/01/23 01:13:37 brlcad Exp $ (BRL)";
a43 1

a44 1
#ifdef HAVE_STRING_H
a45 1
#endif
d47 1
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d39 1
a39 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.12 2007/01/21 04:45:44 brlcad Exp $ (BRL)";
a44 1

d126 1
a126 1
	    	/* Ordinarily, don't say anything here, will handle as ELL */
d285 4
a288 4
             	               /* An array of solid pointers */
           		       /* An array of ray pointers */
                               /* array of segs (results returned) */
   		  	       /* Number of ray/object pairs */
d302 1
a302 1
	 	if (stp[i] == 0) continue; /* stp[i] == 0 signals skip ray */
d308 1
a308 1
	        magsq_ov = MAGSQ(ov);
d363 1
a363 1
 	cvp->crv_c1 = cvp->crv_c2 = - sph->sph_invrad;
@


14.12
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d39 1
a39 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.11 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.11
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d24 1
d38 1
a38 1
/*@@}*/
d40 1
a40 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.10 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
@


14.10
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2006 United States Government as represented by
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.9 2006/01/18 06:46:17 brlcad Exp $ (BRL)";
@


14.9
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup ellipsoids */
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.8 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1985-2005 United States Government as represented by
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.7 2005/08/12 22:31:08 lbutler Exp $ (BRL)";
@


14.7
log
@Doxygen changes
@
text
@d32 1
a32 1
 *  
d37 1
a37 1
 *  
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.6 2005/01/30 20:31:00 brlcad Exp $ (BRL)";
d61 1
a61 1
 *  
d63 1
a63 1
 *  
d65 1
a65 1
 *  
d68 1
a68 1
 *  
d70 1
a70 1
 *  
d75 1
a75 1
 *  
d89 1
a89 1
 *  
d93 1
a93 1
 *  
d97 1
a97 1
 *  
d128 1
a128 1
#if 0	    	
d221 1
a221 1
 *  
d234 1
a234 1
 *  
d280 1
a280 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;	
d292 1
a292 1
                  	    
d341 1
a341 1
 *  
d374 1
a374 1
 *  
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d37 1
a37 1
 *
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header$ (BRL)";
d61 1
a61 1
 *
d63 1
a63 1
 *
d65 1
a65 1
 *
d68 1
a68 1
 *
d70 1
a70 1
 *
d75 1
a75 1
 *
d89 1
a89 1
 *
d93 1
a93 1
 *
d97 1
a97 1
 *
d128 1
a128 1
#if 0
d221 1
a221 1
 *
d234 1
a234 1
 *
d280 1
a280 1
#define SEG_MISS(SEG)		(SEG).seg_stp=(struct soltab *) 0;
d292 1
a292 1

d341 1
a341 1
 *
d374 1
a374 1
 *
@


14.6
log
@update copyright to 2005
@
text
@d21 4
d26 1
a26 3
 *
 *  Purpose -
 *	Intersect a ray with a Sphere
d39 1
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/g_sph.c,v 14.5 2004/12/21 06:38:21 morrison Exp $ (BRL)";
d87 1
a87 1
/*
d203 1
a203 1
/*
d219 1
a219 1
/*
d281 1
a281 1
/*
d339 1
a339 1
/*
d355 1
a355 1
/*
d372 1
a372 1
/*
d415 1
a415 1
/*
d437 1
a437 1
/*
d475 1
a475 1
/*
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1985-2004 United States Government as represented by
d38 1
a38 1
static const char RCSsph[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_sph.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a35 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1985-2004 by the United States Army.
 *	All rights reserved.
d38 1
a38 1
static const char RCSsph[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_sph.c,v 14.3 2004/12/21 05:45:24 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_sph.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_sph.c,v 14.1 2004/11/16 19:42:16 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			G _ S P H . C
d41 1
a41 1
static const char RCSsph[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_sph.c,v 1.2 2004/08/02 23:01:49 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /cvs/brlcad/src/librt/g_sph.c,v 1.1 2004/05/20 15:20:02 morrison Exp $ (BRL)";
d491 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d22 1
a22 1
static const char RCSsph[] = "@@(#)$Header: /cvs/brlcad/librt/g_sph.c,v 11.17 2004/05/10 15:30:46 erikg Exp $ (BRL)";
d25 1
a25 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

