head	14.27;
access;
symbols
	rel-7-10-4:14.25
	STABLE:14.25.0.2
	stable-branch:14.6
	rel-7-10-2:14.25
	rel-7-10-0:14.23
	rel-7-8-4:14.19
	rel-7-8-2:14.15
	rel-7-8-0:14.15
	trimnurbs-branch:14.15.0.2
	help:14.15
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.9
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.27
date	2007.12.16.18.53.50;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.09.15.16.23.12;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.07.26.01.13.57;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.05.19.02.05.24;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.27.01.41.39;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.23.01.13.36;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.20.14.36.54;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.09.16.02.04.24;	author lbutler;	state Exp;
branches;
next	14.18;

14.18
date	2006.08.14.00.16.27;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.07.09.18.25.32;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.06.26.14.35.54;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.02.03.17.44.15;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.01.24.15.44.21;	author bob1961;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.18.06.46.17;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.15.23.48.52;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.11.22.45.23;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.12.09.04.34.30;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.35;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.21.12.55.46;	author d_rossberg;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.31.07;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.58;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.45;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.23;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.04.18.20;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.58;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.03.20.42.29;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.49;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.57.52;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.57;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.16;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.27
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                         D B _ I O . C
 * BRL-CAD
 *
 * Copyright (c) 1988-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup db4 */
/** @@{ */
/** @@file db_io.c
 *
 * Functions -
 *	db_getmrec	Read all records into malloc()ed memory chunk
 *	db_get		Get records from database
 *	db_put		Put records to database
 *
 *
 *  Authors -
 *	Michael John Muuss
 *
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.26 2007/09/15 16:23:12 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif

#include "machine.h"
#include "vmath.h"
#include "db.h"
#include "raytrace.h"

#include "./debug.h"

/**
 *			D B _ R E A D
 *
 *  Reads 'count' bytes at file offset 'offset' into buffer at 'addr'.
 *  A wrapper for the UNIX read() sys-call that takes into account
 *  syscall semaphores, stdio-only machines, and in-memory buffering.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
/* should be HIDDEN */
int
db_read(const struct db_i *dbip, genptr_t addr, long int count, long int offset)
				/* byte count */
				/* byte offset from start of file */
{
	register int	got;
#ifdef HAVE_UNIX_IO
	register long	s;
#endif

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db_read(dbip=x%x, addr=x%x, count=%d., offset=x%x)\n",
			dbip, addr, count, offset );
	}
	if( count <= 0 || offset < 0 )  {
		return(-1);
	}
	if( offset+count > dbip->dbi_eof )  {
	    /* Attempt to read off the end of the file */
	    bu_log("db_read(%s) ERROR offset=%d, count=%d, dbi_eof=%d\n",
		   dbip->dbi_filename,
		   offset, count, dbip->dbi_eof );
	    return -1;
	}
	if( dbip->dbi_inmem )  {
		memcpy(addr, ((char *)dbip->dbi_inmem) + offset, count);
		return(0);
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );
#ifdef HAVE_LSEEK
	if ((s=(long)lseek( dbip->dbi_fd, (off_t)offset, 0 )) != offset) {
		bu_log("db_read: lseek returns %d not %d\n", s, offset);
		bu_bomb("db_read: Goodbye");
	}
	got = read( dbip->dbi_fd, addr, count );
#else
	if (fseek( dbip->dbi_fp, offset, 0 ))
		bu_bomb("db_read: fseek error\n");
	got = fread( addr, 1, count, dbip->dbi_fp );
#endif
	bu_semaphore_release( BU_SEM_SYSCALL );

	if( got != count )  {
	    if (got < 0) {
		perror(dbip->dbi_filename);
	    }
	    bu_log("db_read(%s):  read error.  Wanted %d, got %d bytes\n",
		   dbip->dbi_filename, count, got );
	    return(-1);
	}
	return(0);			/* OK */
}

/**
 *  			D B _ G E T M R E C
 *
 *  Retrieve all records in the database pertaining to an object,
 *  and place them in malloc()'ed storage, which the caller is
 *  responsible for free()'ing.
 *
 *  This loads the combination into a local record buffer.
 *  This is in external v4 format.
 *
 *  Returns -
 *	union record *		OK
 *	(union record *)0	failure
 */
union record *
db_getmrec(const struct db_i *dbip, const struct directory *dp)
{
	union record	*where;

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);

	if( dbip->dbi_version >= 5 ) {
	    /* can't get an mrec on a v5 */
	    return (union record *)NULL;
	}

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_getmrec(%s) x%x, x%x\n",
		dp->d_namep, dbip, dp );

	if( dp->d_addr < 0 )
		return( (union record *)0 );	/* was dummy DB entry */
	where = (union record *)bu_malloc(
		dp->d_len * sizeof(union record),
		"db_getmrec record[]");

	if( dp->d_flags & RT_DIR_INMEM )  {
		memcpy((char *)where, dp->d_un.ptr, dp->d_len * sizeof(union record));
		return where;
	}

	if( db_read( dbip, (char *)where,
	    (long)dp->d_len * sizeof(union record),
	    dp->d_addr ) < 0 )  {
		bu_free( (genptr_t)where, "db_getmrec record[]" );
		return( (union record *)0 );	/* VERY BAD */
	}
	return( where );
}

/**
 *  			D B _ G E T
 *
 *  Retrieve 'len' records from the database,
 *  "offset" granules into this entry.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
db_get(const struct db_i *dbip, const struct directory *dp, union record *where, int offset, int len)
{

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_get(%s) x%x, x%x x%x off=%d len=%d\n",
		dp->d_namep, dbip, dp, where, offset, len );

	if( dp->d_addr < 0 )  {
		where->u_id = '\0';	/* undefined id */
		return(-1);
	}
	if( offset < 0 || offset+len > dp->d_len )  {
		bu_log("db_get(%s):  xfer %d..%x exceeds 0..%d\n",
			dp->d_namep, offset, offset+len, dp->d_len );
		where->u_id = '\0';	/* undefined id */
		return(-1);
	}

	if( dp->d_flags & RT_DIR_INMEM )  {
	    memcpy((char *)where,
		   ((char *)dp->d_un.ptr) + offset * sizeof(union record),
		   len * sizeof(union record) );
	    return 0;		/* OK */
	}

	if( db_read( dbip, (char *)where, (long)len * sizeof(union record),
	    dp->d_addr + offset * sizeof(union record) ) < 0 )  {
		where->u_id = '\0';	/* undefined id */
		return(-1);
	}
	return(0);			/* OK */
}

/**
 *			D B _ W R I T E
 *
 *  Writes 'count' bytes into at file offset 'offset' from buffer at 'addr'.
 *  A wrapper for the UNIX write() sys-call that takes into account
 *  syscall semaphores, stdio-only machines, and in-memory buffering.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
/* should be HIDDEN */
int
db_write(struct db_i *dbip, const genptr_t addr, long int count, long int offset)
{
	register int	got;

	RT_CK_DBI(dbip);
	if(RT_G_DEBUG&DEBUG_DB)  {
		bu_log("db_write(dbip=x%x, addr=x%x, count=%d., offset=x%x)\n",
			dbip, addr, count, offset );
	}
	if( dbip->dbi_read_only )  {
		bu_log("db_write(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return(-1);
	}
	if( count <= 0 || offset < 0 )  {
		return(-1);
	}
	if( dbip->dbi_inmem )  {
		bu_log("db_write() in memory?\n");
		return(-1);
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );
#ifdef HAVE_UNIX_IO
	(void)lseek( dbip->dbi_fd, offset, 0 );
	got = write( dbip->dbi_fd, addr, count );
#else
	(void)fseek( dbip->dbi_fp, offset, 0 );
	got = fwrite( addr, 1, count, dbip->dbi_fp );
	fflush(dbip->dbi_fp);
#endif
	bu_semaphore_release( BU_SEM_SYSCALL );
	if( got != count )  {
		perror("db_write");
		bu_log("db_write(%s):  write error.  Wanted %d, got %d bytes.\nFile forced read-only.\n",
			dbip->dbi_filename, count, got );
		dbip->dbi_read_only = 1;
		return(-1);
	}
	return(0);			/* OK */
}

/**
 *  			D B _ P U T
 *
 *  Store 'len' records to the database,
 *  "offset" granules into this entry.
 *
 *  Returns -
 *	 0	OK
 *	-1	failure
 */
int
db_put(struct db_i *dbip, const struct directory *dp, union record *where, int offset, int len)
{

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_put(%s) x%x, x%x x%x off=%d len=%d\n",
		dp->d_namep, dbip, dp, where, offset, len );

	if( offset < 0 || offset+len > dp->d_len )  {
		bu_log("db_put(%s):  xfer %d..%x exceeds 0..%d\n",
			dp->d_namep, offset, offset+len, dp->d_len );
		return(-1);
	}

	if( dp->d_flags & RT_DIR_INMEM )  {
	    memcpy(((char *)dp->d_un.ptr) + offset * sizeof(union record),
		   (char *)where,
		   len * sizeof(union record) );
	    return 0;		/* OK */
	}

	if( dbip->dbi_read_only )  {
		bu_log("db_put(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return(-1);
	}

	if( db_write( dbip, (char *)where, (long)len * sizeof(union record),
	    dp->d_addr + offset * sizeof(union record) ) < 0 )  {
		return(-1);
	}
	return(0);
}


/**
 *			D B _ G E T _ E X T E R N A L
 *
 *  Obtains a object from the database, leaving it in external (on-disk)
 *  format.
 *  The bu_external structure represented by 'ep' is initialized here,
 *  the caller need not pre-initialize it.  On error, 'ep' is left
 *  un-initialized and need not be freed, to simplify error recovery.
 *  On success, the caller is responsible for calling bu_free_external(ep);
 *
 *  Returns -
 *	-1	error
 *	 0	success
 */
int
db_get_external(register struct bu_external *ep, const struct directory *dp, const struct db_i *dbip)
{
	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_get_external(%s) ep=x%x, dbip=x%x, dp=x%x\n",
		dp->d_namep, ep, dbip, dp );

	if( (dp->d_flags & RT_DIR_INMEM) == 0 && dp->d_addr < 0 )
		return( -1 );		/* was dummy DB entry */

	BU_INIT_EXTERNAL(ep);
	if( dbip->dbi_version <= 4 )
		ep->ext_nbytes = dp->d_len * sizeof(union record);
	else
		ep->ext_nbytes = dp->d_len;
	ep->ext_buf = (genptr_t)bu_malloc(ep->ext_nbytes, "db_get_ext ext_buf");

	if( dp->d_flags & RT_DIR_INMEM )  {
		memcpy((char *)ep->ext_buf, dp->d_un.ptr, ep->ext_nbytes);
		return 0;
	}

	if( db_read( dbip, (char *)ep->ext_buf,
	    (long)ep->ext_nbytes, dp->d_addr ) < 0 )  {
		bu_free( ep->ext_buf, "db_get_ext ext_buf" );
		ep->ext_buf = (genptr_t)NULL;
		ep->ext_nbytes = 0;
		return( -1 );	/* VERY BAD */
	}
	return(0);
}

/**
 *
 *			D B _ P U T _ E X T E R N A L
 *
 *  Given that caller already has an external representation of
 *  the database object,  update it to have a new name
 *  (taken from dp->d_namep) in that external representation,
 *  and write the new object into the database, obtaining different storage if
 *  the size has changed.
 *
 *  Caller is responsible for freeing memory of external representation,
 *  using bu_free_external().
 *
 *  This routine is used to efficiently support MGED's "cp" and "keep"
 *  commands, which don't need to import objects just to rename and copy them.
 *
 *  Returns -
 *	-1	error
 *	 0	success
 */
int
db_put_external(struct bu_external *ep, struct directory *dp, struct db_i *dbip)
{

	RT_CK_DBI(dbip);
	RT_CK_DIR(dp);
	BU_CK_EXTERNAL(ep);
	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_put_external(%s) ep=x%x, dbip=x%x, dp=x%x\n",
		dp->d_namep, ep, dbip, dp );


	if( dbip->dbi_read_only )  {
		bu_log("db_put_external(%s):  READ-ONLY file\n",
			dbip->dbi_filename);
		return(-1);
	}

	if( dbip->dbi_version == 5 )
		return db_put_external5( ep, dp, dbip );

	if( dbip->dbi_version <= 4 )  {
		int	ngran;

		ngran = (ep->ext_nbytes+sizeof(union record)-1)/sizeof(union record);
		if( ngran != dp->d_len )  {
			if( dp->d_addr != -1L )  {
				if( db_delete( dbip, dp ) < 0 )
					return -2;
			}
			if( db_alloc( dbip, dp, ngran ) < 0 )  {
				return -3;
			}
		}
		/* Sanity check */
		if( ngran != dp->d_len )  {
			bu_log("db_put_external(%s) ngran=%d != dp->d_len %d\n",
				dp->d_namep, ngran, dp->d_len );
			bu_bomb("db_io.c: db_put_external()");
		}

		db_wrap_v4_external( ep, dp->d_namep );
	} else
		bu_bomb("db_put_external(): unknown dbi_version\n");

	if( dp->d_flags & RT_DIR_INMEM )  {
		memcpy(dp->d_un.ptr, (char *)ep->ext_buf, ep->ext_nbytes);
		return 0;
	}

	if( db_write( dbip, (char *)ep->ext_buf, ep->ext_nbytes, dp->d_addr ) < 0 )  {
		return(-1);
	}
	return(0);
}


/**
 *
 *			D B _ F W R I T E _ E X T E R N A L
 *
 *  Add name from dp->d_namep to external representation of solid,
 *  and write it into a file.
 *
 *  Caller is responsible for freeing memory of external representation,
 *  using bu_free_external().
 *
 *  The 'name' field of the external representation is modified to
 *  contain the desired name.
 *
 *  Returns -
 *	<0	error
 *	0	OK
 *
 *  NOTE:  Callers of this should be using wdb_export_external() instead.
 */
int
db_fwrite_external(FILE *fp, const char *name, struct bu_external *ep)


						/* can't be const */
{

	if(RT_G_DEBUG&DEBUG_DB) bu_log("db_fwrite_external(%s) ep=x%x\n",
		name, ep);

	BU_CK_EXTERNAL(ep);

	db_wrap_v4_external( ep, name );

	return bu_fwrite_external( fp, ep );
}

/**
 *			D B _ F R E E _ E X T E R N A L
 *
 *  XXX This is a leftover.  You should call bu_free_external() instead.
 */
void
db_free_external(register struct bu_external *ep)
{
	BU_CK_EXTERNAL(ep);
	bu_free_external(ep);
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.26
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.25 2007/07/26 01:13:57 brlcad Exp $ (BRL)";
d96 1
a96 1
		memcpy( addr, ((char *)dbip->dbi_inmem) + offset, count );
d161 1
a161 1
		memcpy( (char *)where, dp->d_un.ptr, dp->d_len * sizeof(union record) );
d352 1
a352 1
		memcpy( (char *)ep->ext_buf, dp->d_un.ptr, ep->ext_nbytes );
d431 1
a431 1
		memcpy( dp->d_un.ptr, (char *)ep->ext_buf, ep->ext_nbytes );
@


14.25
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.24 2007/05/19 02:05:24 brlcad Exp $ (BRL)";
d42 2
a49 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.24
log
@welcome to 1990, replace calls to bcopy with memcpy.  interestingly enough, valgrind on amd64 linux is showing bcopy() reading more than len bytes (reading to aligned memory internally)
@
text
@a32 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.23 2007/01/27 01:41:39 brlcad Exp $ (BRL)";
@


14.23
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.22 2007/01/23 01:13:36 brlcad Exp $ (BRL)";
d169 1
a169 1
		bcopy( dp->d_un.ptr, (char *)where, dp->d_len * sizeof(union record) );
d213 4
a216 4
		bcopy( ((char *)dp->d_un.ptr) + offset * sizeof(union record),
			(char *)where,
			len * sizeof(union record) );
		return 0;		/* OK */
d307 4
a310 4
		bcopy( (char *)where,
			((char *)dp->d_un.ptr) + offset * sizeof(union record),
			len * sizeof(union record) );
		return 0;		/* OK */
d360 1
a360 1
		bcopy( dp->d_un.ptr, (char *)ep->ext_buf, ep->ext_nbytes );
d439 1
a439 1
		bcopy( (char *)ep->ext_buf, dp->d_un.ptr, ep->ext_nbytes );
@


14.22
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.21 2007/01/21 04:45:43 brlcad Exp $ (BRL)";
d80 2
a81 2
    		      		/* byte count */
    		       		/* byte offset from start of file */
a326 1

d367 2
a368 2
	    	ep->ext_buf = (genptr_t)NULL;
	    	ep->ext_nbytes = 0;
d424 1
a424 1
			    	return -3;
d473 1
a473 1
                  	    			/* can't be const */
@


14.21
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.20 2007/01/20 14:36:54 brlcad Exp $ (BRL)";
@


14.20
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 2

/*@@{*/
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.19 2006/09/16 02:04:24 lbutler Exp $ (BRL)";
d500 1
a500 1
/*@@}*/
@


14.19
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2006 United States Government as represented by
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.18 2006/08/14 00:16:27 brlcad Exp $ (BRL)";
@


14.18
log
@can't get an mrec of a v5 database
@
text
@d22 1
a22 1
/** \addtogroup db */
a41 1
/*@@}*/
d44 1
a44 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.17 2006/07/09 18:25:32 brlcad Exp $ (BRL)";
d502 1
@


14.17
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.16 2006/06/26 14:35:54 brlcad Exp $ (BRL)";
d157 6
@


14.16
log
@comment that db_getmrec loads records into a buffer in v4 format
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.15 2006/02/03 17:44:15 brlcad Exp $ (BRL)";
d126 6
a131 4
		perror("db_read");
		bu_log("db_read(%s):  read error.  Wanted %d, got %d bytes\n",
			dbip->dbi_filename, count, got );
		return(-1);
@


14.15
log
@lseek's use of off_t requires sys/types.h
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.14 2006/01/24 15:44:21 bob1961 Exp $ (BRL)";
a83 2


d141 3
@


14.14
log
@Remove USE_SURVICE_MODS ifdef/endif that was guarding a fflush in db_write().
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d54 3
d114 1
a114 1
#ifdef HAVE_UNIX_IO
@


14.13
log
@update copyright to 2006
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.12 2006/01/15 23:48:52 brlcad Exp $ (BRL)";
a259 1
#ifdef USE_SURVICE_MODS
a261 1
#endif
@


14.12
log
@ws
@
text
@d4 1
a4 1
 * Copyright (C) 1988-2005 United States Government as represented by
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.11 2006/01/11 22:45:23 brlcad Exp $ (BRL)";
@


14.11
log
@ws
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.10 2005/12/09 04:34:30 brlcad Exp $ (BRL)";
d352 1
a352 2
	ep->ext_buf = (genptr_t)bu_malloc(
		ep->ext_nbytes, "db_get_ext ext_buf");
@


14.10
log
@lseek() function allows the file offset to be set beyond the end of file so make sure we check that the offset provided to db_read is not larger than the size of the file
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.9 2005/10/23 04:44:35 brlcad Exp $ (BRL)";
a49 2


d52 1
a52 1
#include <unistd.h>
d55 1
a55 1
#include <string.h>
d57 1
a57 1
#include <strings.h>
@


14.9
log
@trailing ws
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.8 2005/10/21 12:55:46 d_rossberg Exp $ (BRL)";
d101 7
a108 7
		if( offset+count > dbip->dbi_eof )  {
			/* Attempt to read off the end of the (mapped) file */
			bu_log("db_read(%s) ERROR offset=%d, count=%d, dbi_eof=%d\n",
				dbip->dbi_filename,
				offset, count, dbip->dbi_eof );
			return -1;
		}
@


14.8
log
@variable s only if HAVE_UNIX_IO
@
text
@d35 1
a35 1
 *  
d40 1
a40 1
 *  
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.7 2005/08/12 22:31:07 lbutler Exp $ (BRL)";
d83 2
a84 2
                 	      
        	     
d469 2
a470 2
    			    
          		      
@


14.7
log
@Doxygen changes
@
text
@d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.6 2005/01/30 20:30:58 brlcad Exp $ (BRL)";
d89 1
d91 1
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d35 1
a35 1
 *
d40 1
a40 1
 *
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d83 2
a84 2


a88 1
#ifdef HAVE_UNIX_IO
a89 1
#endif
d467 2
a468 2


@


14.6
log
@update copyright to 2005
@
text
@d21 4
d42 2
d45 1
a45 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/librt/db_io.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
d69 1
a69 1
/*
d133 1
a133 1
/*
d174 1
a174 1
/*
d219 1
a219 1
/*
d275 1
a275 1
/*
d322 1
a322 1
/*
d370 1
a370 1
/*
d446 1
a446 1
/*
d482 1
a482 1
/*
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1988-2004 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_io.c,v 14.4 2004/12/21 06:18:45 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a36 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1988-2004 by the United States Army.
 *	All rights reserved.
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_io.c,v 14.3 2004/12/21 05:45:23 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_io.c,v 14.2 2004/12/21 04:18:20 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_io.c,v 14.1 2004/11/16 19:42:15 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			D B _ I O . C
d42 1
a42 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_io.c,v 1.5 2004/09/03 23:30:58 morrison Exp $ (BRL)";
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_io.c,v 1.4 2004/08/03 20:42:29 morrison Exp $ (BRL)";
d471 10
@


1.4
log
@apply Bob's provided patches from 20040630.  this includes itcl namespace scoping, windows DLL exporting, and wdb arb edit support
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/librt/db_io.c,v 1.2 2004/06/08 19:57:52 morrison Exp $ (BRL)";
d34 1
a34 1
#ifdef USE_STRING_H
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d238 3
@


1.2
log
@bye bye externs.h
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d26 1
a26 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d23 1
a23 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/librt/db_io.c,v 11.31 2004/05/10 15:30:46 erikg Exp $ (BRL)";
a42 1
#include "externs.h"
@

