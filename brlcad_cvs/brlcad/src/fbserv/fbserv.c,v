head	14.31;
access;
symbols
	rel-7-10-4:14.20
	STABLE:14.20.0.2
	stable-branch:14.3
	rel-7-10-2:14.20
	rel-7-10-0:14.20
	rel-7-8-4:14.17
	rel-7-8-2:14.14
	rel-7-8-0:14.14
	trimnurbs-branch:14.14.0.2
	help:14.14
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.7.2.1
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.31
date	2007.12.15.08.44.39;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.12.06.17.54.25;	author erikgreenwald;	state Exp;
branches;
next	14.29;

14.29
date	2007.12.04.01.36.14;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.12.01.21.47.12;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.11.21.20.49.08;	author erikgreenwald;	state Exp;
branches;
next	14.26;

14.26
date	2007.11.21.19.28.06;	author erikgreenwald;	state Exp;
branches;
next	14.25;

14.25
date	2007.11.08.19.20.15;	author bob1961;	state Exp;
branches;
next	14.24;

14.24
date	2007.11.04.17.12.59;	author bob1961;	state Exp;
branches;
next	14.23;

14.23
date	2007.10.18.09.11.58;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.09.15.03.26.47;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.27.01.41.34;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.23.01.13.32;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.20.14.36.49;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.08.01.15.20.22;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.07.10.19.06.22;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.07.10.01.25.39;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.02.27.10.37.29;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.02.27.09.10.29;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.23.17.56.48;	author bob1961;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.22.10.40.11;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.12.23.21.26.30;	author bob1961;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.06.15.04.34.52;	author brlcad;	state Exp;
branches
	14.7.2.1
	14.7.6.1;
next	14.6;

14.6
date	2005.05.11.01.46.28;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.04.26.07.56.01;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.04.26.07.54.08;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.30.37;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.20.20.20.33;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.16.03.43.59;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.14;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.08;	author morrison;	state Exp;
branches;
next	;

14.7.2.1
date	2005.09.14.19.28.15;	author bob1961;	state Exp;
branches;
next	;

14.7.6.1
date	2005.11.13.13.46.14;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.31
log
@strerror is c89, and does work on windows at least with vc8 so drop the obsolete and error-prone sys_errlist array alternates and configure check
@
text
@/*                        F B S E R V . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file fbserv.c
 *
 *  Remote libfb server (originally rfbd).
 *
 *  There are three ways this program can be run:
 *  Inetd Daemon - every PKG connection invokes a new copy of us,
 *	courtesy of inetd.  We process a single frame buffer
 *	open/process/close cycle and then exit.  A full installation
 *	includes setting up inetd and /etc/services to start one
 *	of these, with these entries:
 *
 * remotefb stream tcp     nowait  nobody   /usr/brlcad/bin/fbserv  fbserv
 * remotefb        5558/tcp                        # remote frame buffer
 *
 *  Stand-Alone Daemon - once started we run forever, forking a
 *	copy of ourselves for each new connection.  Each child is
 *	essentially like above, i.e. one open/process/close cycle.
 *	Useful for running a daemon on a totally "unmodified" system,
 *	or when inetd is not available.
 *	A child process is necessary because different framebuffers
 *	may be specified in each open.
 *
 *  Single-Frame-Buffer Server - we open a particular frame buffer
 *	at invocation time and leave it open.  We will accept
 *	multiple connections for this frame buffer.
 *	Frame buffer open and close requests are effectively ignored.
 *	Major purpose is to create "reattachable" frame buffers when
 *	using libfb on a window system.  In this case there is no
 *	hardware to preserve "state" information (image data, color
 *	maps, etc.).  By leaving the frame buffer open, the daemon
 *	keeps this state in memory.
 *	Requests can be interleaved from different clients.
 *
 *  Authors -
 *	Phillip Dykstra
 *	Michael John Muuss
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.30 2007/12/06 17:54:25 erikgreenwald Exp $ (ARL)";
#endif

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <time.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#if HAVE_SYSLOG_H
#  include <syslog.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#  include <sys/socket.h>
#endif
#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>		/* For htonl(), etc */
#endif
#ifdef HAVE_WINSOCK_H
#  include <process.h>
#  include <winsock.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif

#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>		/* For struct timeval */
#endif

#include "machine.h"
#include "fb.h"
#include "pkg.h"
#include "bu.h"
#include "fbmsg.h"


fd_set	select_list;			/* master copy */
int	max_fd;

static  void	main_loop(void);
static	void	comm_error(char *str);
static	void	init_syslog(void);
static	void	setup_socket(int fd);
static	int	use_syslog;	/* error messages to stderr if 0 */

static	char	*framebuffer = NULL;	/* frame buffer name */
static	int	width = 0;		/* use default size */
static	int	height = 0;
static	int	port = 0;
static	int	port_set = 0;		/* !0 if user supplied port num */
static	int	once_only = 0;
static 	int	netfd;

#define OUTBUFSZ 4096

#define MAX_CLIENTS	32
struct pkg_conn	*clients[MAX_CLIENTS];

int	verbose = 0;

/* from server.c */
extern const struct pkg_switch fb_server_pkg_switch[];
extern FBIO	*fb_server_fbp;
extern fd_set	*fb_server_select_list;
extern int	*fb_server_max_fd;
extern int	fb_server_got_fb_free;       /* !0 => we have received an fb_free */
extern int	fb_server_refuse_fb_free;    /* !0 => don't accept fb_free() */
extern int	fb_server_retain_on_close;   /* !0 => we are holding a reusable FB open */


/* Hidden args: -p<port_num> -F<frame_buffer> */
static char usage[] = "\
Usage: fbserv port_num\n\
	  (for a stand-alone daemon)\n\
   or  fbserv [-v] [-h] [-S squaresize]\n\
	  [-W width] [-N height] port_num frame_buffer\n\
	  (for a single-frame-buffer server)\n\
";

int
get_args(int argc, register char **argv)
{
	register int c;

	while ( (c = bu_getopt( argc, argv, "hvF:s:w:n:S:W:N:p:" )) != EOF )  {
		switch( c )  {
		case 'v':
			verbose = 1;
			break;
		case 'h':
			/* high-res */
			height = width = 1024;
			break;
		case 'F':
			framebuffer = bu_optarg;
			break;
		case 's':
		case 'S':
			height = width = atoi(bu_optarg);
			break;
		case 'w':
		case 'W':
			width = atoi(bu_optarg);
			break;
		case 'n':
		case 'N':
			height = atoi(bu_optarg);
			break;
		case 'p':
			port = atoi(bu_optarg);
			port_set = 1;
			break;

		default:		/* '?' */
			return(0);
		}
	}
	/* If no "-p port", port comes from 1st extra */
	if( (bu_optind < argc) && (port_set == 0) ) {
		port = atoi(argv[bu_optind++]);
		port_set = 1;
	}
	/* If no "-F framebuffer", fb comes from 2nd extra */
	if( (bu_optind < argc) && (framebuffer == NULL) ) {
		framebuffer = argv[bu_optind++];
	}
	if( argc > bu_optind )
		return(0);	/* print usage */

	return(1);		/* OK */
}

/*
 *			I S _ S O C K E T
 *
 * Determine if a file descriptor corresponds to an open socket.
 * Used to detect when we are started from INETD which gives us an
 * open socket connection on fd 0.
 */
int
is_socket(int fd)
{
	struct sockaddr saddr;
	socklen_t namelen;

	if( getsockname(fd,&saddr,&namelen) == 0 ) {
		return	1;
	}
	return	0;
}

#ifdef SIGALRM
static void
sigalarm(int code)
{
	printf("alarm %s\n", fb_server_fbp ? "FBP" : "NULL");
	if( fb_server_fbp != FBIO_NULL ) {
		fb_poll(fb_server_fbp);
	}
#ifdef SIGALRM
	(void)signal( SIGALRM, sigalarm );	/* some systems remove handler */
#endif
	alarm(1);
}
#endif

/*
 *			N E W _ C L I E N T
 */
void
new_client(struct pkg_conn *pcp)
{
	register int	i;

	if( pcp == PKC_ERROR )
		return;

	for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
		if( clients[i] != NULL )  continue;
		/* Found an available slot */
		clients[i] = pcp;
		FD_SET(pcp->pkc_fd, &select_list);
		if( pcp->pkc_fd > max_fd )  max_fd = pcp->pkc_fd;
		setup_socket( pcp->pkc_fd );
		return;
	}
	fprintf(stderr,"fbserv: too many clients\n");
	pkg_close(pcp);
}

/*
 *			D R O P _ C L I E N T
 */
void
drop_client(int sub)
{
	int fd = clients[sub]->pkc_fd;

	if( clients[sub] == PKC_NULL )  return;

	FD_CLR( fd, &select_list );
	pkg_close( clients[sub] );
	clients[sub] = PKC_NULL;
#if 0
	(void)close( fd );			/* double-safety */
#endif
}

/*
 *			M A I N
 */
int
main(int argc, char **argv)
{
#define PORTSZ 32
	char	portname[PORTSZ];

	max_fd = 0;

	/* No disk files on remote machine */
	_fb_disk_enable = 0;
	memset((void *)clients, 0, sizeof(struct pkg_conn *) * MAX_CLIENTS);

#ifdef SIGALRM
	(void)signal( SIGPIPE, SIG_IGN );
	(void)signal( SIGALRM, sigalarm );
#endif
	/*alarm(1)*/

	FD_ZERO(&select_list);
	fb_server_select_list = &select_list;
	fb_server_max_fd = &max_fd;

#ifndef _WIN32
	/*
	 * Inetd Daemon.
	 * Check to see if we were invoked by /etc/inetd.  If so
	 * we will have an open network socket on fd=0.  Become
	 * a Transient PKG server if this is so.
	 */
	netfd = 0;
	if( is_socket(netfd) ) {
		init_syslog();
		new_client( pkg_transerver( fb_server_pkg_switch, comm_error ) );
		max_fd = 8;
		once_only = 1;
		main_loop();
		bu_exit(0, NULL);
	}
#endif

	/* for now, make them set a port_num, for usage message */
	if ( !get_args( argc, argv ) || !port_set ) {
		(void)fputs(usage, stderr);
		bu_exit( 1, NULL );
	}

	/* Single-Frame-Buffer Server */
	if( framebuffer != NULL ) {
	    if (pkg_init() != 0) {
		bu_exit(1, NULL);
	    }
		fb_server_retain_on_close = 1;	/* don't ever close the frame buffer */

		/* open a frame buffer */
		if( (fb_server_fbp = fb_open(framebuffer, width, height)) == FBIO_NULL )
			bu_exit(1, NULL);
		if( fb_server_fbp->if_selfd > 0 )  {
			FD_SET(fb_server_fbp->if_selfd, &select_list);
			max_fd = fb_server_fbp->if_selfd;
		}

		/* check/default port */
		if( port_set ) {
			if( port < 1024 )
				port += 5559;
		}
		snprintf(portname, PORTSZ, "%d",port);

		/*
		 * Hang an unending listen for PKG connections
		 */
		if( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 )
			bu_exit(-1, NULL);
		FD_SET(netfd, &select_list);
		if (netfd > max_fd)
			max_fd = netfd;

		main_loop();
		bu_exit(0, NULL);
	}

#ifndef _WIN32
	/*
	 * Stand-Alone Daemon
	 */
	/* check/default port */
	if( port_set ) {
		if( port < 1024 )
			port += 5559;
		sprintf(portname,"%d",port);
	} else {
		snprintf(portname, PORTSZ, "%s","remotefb");
	}

	init_syslog();
	while( (netfd = pkg_permserver(portname, 0, 0, comm_error)) < 0 ) {
	    static int error_count=0;
	    sleep(1);
	    if (error_count++ < 60) {
		continue;
	    }
	    comm_error("Unable to start the stand-alone framebuffer daemon after 60 seconds, giving up.");
	    bu_exit(1, NULL);
	}

	while(1) {
		int stat;
		struct pkg_conn	*pcp;

		pcp = pkg_getclient( netfd, fb_server_pkg_switch, comm_error, 0 );
		if( pcp == PKC_ERROR )
			break;		/* continue is unlikely to work */

		if( fork() == 0 )  {
			/* 1st level child process */
			(void)close(netfd);	/* Child is not listener */

			/* Create 2nd level child process, "double detatch" */
			if( fork() == 0 )  {
				/* 2nd level child -- start work! */
				new_client( pcp );
				once_only = 1;
				main_loop();
				bu_exit(0, NULL);
			} else {
				/* 1st level child -- vanish */
				bu_exit(1, NULL);
			}
		} else {
			/* Parent: lingering server daemon */
			pkg_close(pcp);	/* Daemon is not the server */
			/* Collect status from 1st level child */
			(void)wait( &stat );
		}
	}
#endif  /* _WIN32 */

	bu_exit(2, NULL);	/* ERROR exit */
}

/*
 *			M A I N _ L O O P
 *
 *  Loop forever handling clients as they come and go.
 *  Access to the framebuffer may be interleaved, if the user
 *  wants it that way.
 */
static void
main_loop(void)
{
	int	nopens = 0;
	int	ncloses = 0;

	while( !fb_server_got_fb_free ) {
		fd_set infds;
		struct timeval tv;
		register int	i;

		infds = select_list;	/* struct copy */

#ifdef _WIN32
		tv.tv_sec = 0L;
		tv.tv_usec = 250L;
#else
		tv.tv_sec = 60L;
		tv.tv_usec = 0L;
#endif
		if ((select( max_fd+1, &infds, (fd_set *)0, (fd_set *)0, (void *)&tv ) == 0)) {
			/* Process fb events while waiting for client */
			/*printf("select timeout waiting for client\n");*/
			if(fb_server_fbp) {
			    if (fb_poll(fb_server_fbp)) {
				return;
			    }
			}
			continue;
		}
		/* Handle any events from the framebuffer */
		if (fb_server_fbp && fb_server_fbp->if_selfd > 0 && FD_ISSET(fb_server_fbp->if_selfd, &infds)) {
			fb_poll(fb_server_fbp);
		}

		/* Accept any new client connections */
		if (netfd > 0 && FD_ISSET(netfd, &infds)) {
			new_client( pkg_getclient( netfd, fb_server_pkg_switch, comm_error, 0 ) );
			nopens++;
		}

		/* Process arrivals from existing clients */
		/* First, pull the data out of the kernel buffers */
		for (i = MAX_CLIENTS-1; i >= 0; i--) {
			if (clients[i] == NULL )  continue;
			if (pkg_process( clients[i] ) < 0) {
				fprintf(stderr,"pkg_process error encountered (1)\n");
			}
			if (! FD_ISSET( clients[i]->pkc_fd, &infds )) continue;
			if (pkg_suckin( clients[i] ) <= 0) {
				/* Probably EOF */
				drop_client( i );
				ncloses++;
				continue;
			}
		}
		/* Second, process all the finished ones that we just got */
		for (i = MAX_CLIENTS-1; i >= 0; i--) {
			if (clients[i] == NULL )  continue;
			if (pkg_process( clients[i] ) < 0) {
				fprintf(stderr,"pkg_process error encountered (2)\n");
			}
		}
		if (once_only && nopens > 1 && ncloses > 1)
			return;
	}
}

#ifndef _WIN32
static void
init_syslog(void)
{
	use_syslog = 1;
#if defined(LOG_NOWAIT) && defined(LOG_DAEMON)
	openlog( "fbserv", LOG_PID|LOG_NOWAIT, LOG_DAEMON );	/* 4.3 style */
#else
	openlog( "fbserv", LOG_PID );				/* 4.2 style */
#endif
}
#endif

static void
setup_socket(int fd)
{
	int	on = 1;

#ifdef SO_KEEPALIVE
	if( setsockopt( fd, SOL_SOCKET, SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0 ) {
#  ifdef HAVE_SYSLOG_H
		syslog( LOG_WARNING, "setsockopt (SO_KEEPALIVE): %s", strerror(errno) );
#  endif
	}
#endif
#ifdef SO_RCVBUF
	/* try to set our buffers up larger */
	{
		int	m = 0;
		int	n = 0;
		int	val;
		int	size;

		for( size = 256; size > 16; size /= 2 )  {
			val = size * 1024;
			m = setsockopt( fd, SOL_SOCKET, SO_RCVBUF,
				(char *)&val, sizeof(val) );
			val = size * 1024;
			n = setsockopt( fd, SOL_SOCKET, SO_SNDBUF,
				(char *)&val, sizeof(val) );
			if( m >= 0 && n >= 0 )  break;
		}
		if( m < 0 || n < 0 )  perror("fbserv setsockopt()");
	}
#endif
}

/*
 *			C O M M _ E R R O R
 *
 *  Communication error.  An error occured on the PKG link.
 *  It may be local, or it may be between us and the client we are serving.
 *  We send a copy to syslog or stderr.
 *  Don't send one down the wire, this can cause loops.
 */
static void
comm_error(char *str)
{
#if defined(HAVE_SYSLOG_H)
    if( use_syslog ) {
	syslog( LOG_ERR, "%s", str );
    } else {
	fprintf( stderr, "%s", str );
    }
#else
    fprintf( stderr, "%s", str );
#endif
    if(verbose) {
	fprintf( stderr, "%s", str );
    }
}

#ifndef _WIN32
/*
 *			F B _ L O G
 *
 *  Handles error or log messages from the frame buffer library.
 *  We route these back to all clients in an ERROR packet.  Note that
 *  this is a replacement for the default fb_log function in libfb
 *  (which just writes to stderr).
 *
 *  Log an FB library event, when _doprnt() is not available.
 *  This version should work on practically any machine, but
 *  it serves to highlight the the grossness of the varargs package
 *  requiring the size of a parameter to be known at compile time.
 */
void
fb_log( const char *fmt, ... )
{
	va_list ap;
	char	outbuf[OUTBUFSZ];			/* final output string */
	int	want;
	int	i;
	int	nsent = 0;

	va_start( ap, fmt );
	(void)vsprintf( outbuf, fmt, ap );
	va_end(ap);

	want = strlen(outbuf)+1;
	for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
		if( clients[i] == NULL )  continue;
		if( pkg_send( MSG_ERROR, outbuf, want, clients[i] ) != want )  {
			comm_error("pkg_send error in fb_log, message was:\n");
			comm_error(outbuf);
		} else {
			nsent++;
		}
	}
	if( nsent == 0 || verbose )  {
		/* No PKG connection open yet! */
		fputs( outbuf, stderr );
		fflush(stderr);
	}
}

#endif /* _WIN32 */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.30
log
@change fb_log definition to match the prototype in fb.h
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.29 2007/12/04 01:36:14 brlcad Exp $ (ARL)";
d516 1
a516 1
#if defined(SO_KEEPALIVE)
d518 1
a518 1
#  if defined(HAVE_SYSLOG_H) && defined(HAVE_STRERROR)
d523 1
a523 1
#if defined(SO_RCVBUF)
@


14.29
log
@remove the last traces of stdarg/vararg testing.  c89 conformance provides the stdarg interface.
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.28 2007/12/01 21:47:12 brlcad Exp $ (ARL)";
d585 1
a585 1
fb_log( char *fmt, ... )
@


14.28
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.27 2007/11/21 20:49:08 erikgreenwald Exp $ (ARL)";
d69 1
d79 1
a79 6
#if defined(HAVE_STDARG_H)
#  include <stdarg.h>
#endif
#if !defined(HAVE_STDARG_H) && defined(HAVE_VARARGS_H)
#  include <varargs.h>
#endif
a583 1
#if defined(HAVE_STDARG_H)
d614 1
a614 125
/* VARARGS */
#elif !defined(HAVE_STDARG_H) && defined(HAVE_VARARGS_H)

void
fb_log( va_alist )
va_dcl
{
	va_list ap;
	register char	*sp;			/* start pointer */
	register char	*ep;			/* end pointer */
	int	longify;
	char	fbuf[64];			/* % format buffer */
	char	nfmt[256];
	char	outbuf[OUTBUFSZ];			/* final output string */
	char	*op;				/* output buf pointer */
	int	want, got;
	int	i;
	int	nsent = 0;

	/* prefix all messages with "hostname: " */
	gethostname( outbuf, sizeof(outbuf) );
	op = &outbuf[strlen(outbuf)];
	*op++ = ':';
	*op++ = ' ';

	va_start(ap);
	sp = va_arg(ap,char *);
	while( *sp )  {
		/* Initial state:  just printing chars */
		if( *sp != '%' )  {
			*op++ = *sp;
			if( *sp == '\n' && *(sp+1) ) {
				/* newline plus text, output hostname */
				gethostname( op, sizeof(outbuf) );
				op += strlen(op);
				*op++ = ':';
				*op++ = ' ';
			}
			sp++;
			continue;
		}

		/* Saw a percent sign, find end of fmt specifier */
		longify = 0;
		ep = sp+1;
		while( *ep )  {
			if( isalpha(*ep) )
				break;
			ep++;
		}

		/* Check for digraphs, eg "%ld" */
		if( *ep == 'l' )  {
			ep++;
			longify = 1;
		}

		/* Copy off the format string */
		{
			register int len;
			len = ep-sp+1;
			strncpy( fbuf, sp, len );
			fbuf[len] = '\0';
		}

		/* Grab parameter from arg list, and print it */
		switch( *ep )  {
		case 'e':
		case 'E':
		case 'f':
		case 'g':
		case 'G':
			/* All floating point ==> "double" */
			{
				register double d;
				d = va_arg(ap, double);
				snprintf( op, OUTBUFSZ-strlen(outbuf)-1, fbuf, d );
				op = &outbuf[strlen(outbuf)];
			}
			break;

		default:
			if( longify )  {
				register long ll;
				/* Long int */
				ll = va_arg(ap, long);
				snprintf( op, OUTBUFSZ-strlen(outbuf)-1, fbuf, ll );
				op = &outbuf[strlen(outbuf)];
			} else {
				register int i;
				/* Regular int */
				i = va_arg(ap, int);
				snprintf( op, OUTBUFSZ-strlen(outbuf)-1, fbuf, i );
				op = &outbuf[strlen(outbuf)];
			}
			break;
		}
		sp = ep+1;
	}
	va_end(ap);
	*op = NULL;


	want = strlen(outbuf)+1;
	for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
		if( clients[i] == NULL )  continue;
		if( pkg_send( MSG_ERROR, outbuf, want, clients[i] ) != want )  {
			comm_error("pkg_send error in fb_log, message was:\n");
			comm_error(outbuf);
		} else {
			nsent++;
		}
	}
	if( nsent == 0 || verbose )  {
		/* No PKG connection open yet! */
		fputs( outbuf, stderr );
		fflush(stderr);
	}
}
#else

#error /* no stdarg and no vararg */

#endif /* !have_stdarg_h */
#endif /* !_WIN32 */
@


14.27
log
@pass bu_exit a NULL instead of an empty string
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.26 2007/11/21 19:28:06 erikgreenwald Exp $ (ARL)";
d378 1
a378 1
		sprintf(portname,"%s","remotefb");
@


14.26
log
@exit->bu_exit where applicable
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.25 2007/11/08 19:20:15 bob1961 Exp $ (ARL)";
d323 1
a323 1
		bu_exit(0, "");
d330 1
a330 1
		bu_exit( 1, "" );
d336 1
a336 1
		bu_exit(1, "");
d342 1
a342 1
			bu_exit(1, "");
d359 1
a359 1
			bu_exit(-1, "");
d365 1
a365 1
		bu_exit(0, "");
d389 1
a389 1
	    bu_exit(1, "");
d410 1
a410 1
				bu_exit(0, "");
d413 1
a413 1
				bu_exit(1, "");
d424 1
a424 1
	bu_exit(2, "");	/* ERROR exit */
@


14.25
log
@No longer calling close() in drop_client() because the call to pkg_close() already does this.
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.24 2007/11/04 17:12:59 bob1961 Exp $ (ARL)";
d323 1
a323 1
		exit(0);
d330 1
a330 1
		exit( 1 );
d336 1
a336 1
		exit(1);
d342 1
a342 1
			exit(1);
d359 1
a359 1
			exit(-1);
d365 1
a365 1
		exit(0);
d389 1
a389 1
	    exit(1);
d410 1
a410 1
				exit(0);
d413 1
a413 1
				exit(1);
d424 1
a424 1
	exit(2);	/* ERROR exit */
@


14.24
log
@Mods to get things working on Windows.
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.23 2007/10/18 09:11:58 brlcad Exp $ (ARL)";
d279 1
d281 1
@


14.23
log
@more quellings of level 4 flawfinder issues
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.22 2007/09/15 16:23:06 brlcad Exp $ (ARL)";
a114 2
extern	int	_fb_disk_enable;

d227 1
d240 1
d500 1
d511 1
@


14.22
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.21 2007/09/15 03:26:47 brlcad Exp $ (ARL)";
d131 2
d288 2
a289 1
	char	portname[32];
d351 1
a351 1
		sprintf(portname,"%d",port);
d558 1
a558 1
	syslog( LOG_ERR, str );
d589 1
a589 1
	char	outbuf[4096];			/* final output string */
d628 1
a628 1
	char	outbuf[4096];			/* final output string */
d691 1
a691 1
				sprintf( op, fbuf, d );
d701 1
a701 1
				sprintf( op, fbuf, ll );
d707 1
a707 1
				sprintf( op, fbuf, i );
@


14.21
log
@limits.h, locale.h, setjmp.g, and signal.h now all assumed as well as part of ongoing c89 migration.
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.20 2007/01/27 01:41:34 brlcad Exp $ (ARL)";
a68 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
d72 2
d75 3
a83 1

a86 1

a96 6

#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
a103 1
#include <time.h>
@


14.20
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.19 2007/01/23 01:13:32 brlcad Exp $ (ARL)";
d241 1
a241 1
#ifdef HAVE_SIGNAL
d301 1
a301 1
#ifdef HAVE_SIGNAL
@


14.19
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.18 2007/01/20 14:36:49 brlcad Exp $ (ARL)";
d156 1
a156 1
          (for a stand-alone daemon)\n\
d158 2
a159 2
          [-W width] [-N height] port_num frame_buffer\n\
          (for a single-frame-buffer server)\n\
d226 1
a226 1
        socklen_t namelen;
@


14.18
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d62 1
a62 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.17 2006/08/01 15:20:22 brlcad Exp $ (ARL)";
@


14.17
log
@refactor fbserv.c and fbserv_win.c so that there is only one file that supports/contains all of the mods that fbserv_win.c was presuming.  this needs testing but is more functionally clean, relying on configure-style tests/defines instead of WIN32 where easily possible
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.16 2006/07/10 19:06:22 brlcad Exp $ (ARL)";
@


14.16
log
@refactor away the old BSD block defines among other simple cleanup
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.15 2006/07/10 01:25:39 brlcad Exp $ (ARL)";
d70 3
a72 1
#include <unistd.h>
d88 11
a98 2
#include <sys/socket.h>
#include <netinet/in.h>		/* For htonl(), etc */
d108 4
a111 1
#include <sys/time.h>		/* For struct timeval */
d115 2
a117 1
#include "pkg.h"
d168 1
a168 1
	while ( (c = getopt( argc, argv, "hvF:s:w:n:S:W:N:p:" )) != EOF )  {
d178 1
a178 1
			framebuffer = optarg;
d182 1
a182 1
			height = width = atoi(optarg);
d186 1
a186 1
			width = atoi(optarg);
d190 1
a190 1
			height = atoi(optarg);
d193 1
a193 1
			port = atoi(optarg);
d202 2
a203 2
	if( (optind < argc) && (port_set == 0) ) {
		port = atoi(argv[optind++]);
d207 2
a208 2
	if( (optind < argc) && (framebuffer == NULL) ) {
		framebuffer = argv[optind++];
d210 1
a210 1
	if( argc > optind )
a226 1
	/* Should be: socklen_t namelen but SGI's are complaining... */
d229 1
a229 1
	if( getsockname(fd,&saddr,&namelen) == 0 )
d231 2
a232 2
	else
		return	0;
d239 1
a239 1
	if( fb_server_fbp != FBIO_NULL )
d241 2
d244 1
d296 2
d302 1
d305 1
d312 1
d328 1
d338 3
d370 2
d425 2
d450 4
d456 2
a457 2
		if( (select( max_fd+1, &infds, (fd_set *)0, (fd_set *)0,
			     (void *)&tv )) == 0 ) {
d460 5
a464 1
			if(fb_server_fbp) fb_poll(fb_server_fbp);
d468 1
a468 1
		if (fb_server_fbp && fb_server_fbp->if_selfd > 0 && FD_ISSET(fb_server_fbp->if_selfd, &infds))
d470 1
d473 1
a473 1
		if( netfd > 0 && FD_ISSET(netfd, &infds))  {
d480 3
a482 3
		for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
			if( clients[i] == NULL )  continue;
			if( pkg_process( clients[i] ) < 0 ) {
d485 2
a486 2
			if( ! FD_ISSET( clients[i]->pkc_fd, &infds ) )  continue;
			if( pkg_suckin( clients[i] ) <= 0 )  {
d494 3
a496 3
		for( i = MAX_CLIENTS-1; i >= 0; i-- )  {
			if( clients[i] == NULL )  continue;
			if( pkg_process( clients[i] ) < 0 ) {
d500 1
a500 1
		if( once_only && nopens > 1 && ncloses > 1 )
d575 1
d744 1
@


14.15
log
@remove/rewrite a bunch of the old SYSV preprocessor symbol sections
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.14 2006/02/27 10:37:29 brlcad Exp $ (ARL)";
d470 1
a470 2
#if defined(BSD) && !defined(CRAY2)
#   ifdef LOG_DAEMON
d472 1
a472 1
#   else
d474 1
a474 2
#   endif
#endif /* BSD && !CRAY2 */
d484 1
a484 1
#if		defined(BSD) && !defined(CRAY2)
d486 1
a486 1
#		endif
d522 6
a527 5
#if defined(BSD) && !defined(CRAY2)
	if( use_syslog )
		syslog( LOG_ERR, str );
	else
		fprintf( stderr, "%s", str );
d529 3
d533 1
a533 2
#endif
	if(verbose) fprintf( stderr, "%s", str );
@


14.14
log
@delint the socklent
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.13 2006/02/27 09:10:29 brlcad Exp $ (ARL)";
d227 1
a227 1
	(void)signal( SIGALRM, sigalarm );	/* SYSV removes handler */
@


14.13
log
@stdlib.h warning quelling
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.12 2006/01/23 17:56:48 bob1961 Exp $ (ARL)";
d213 1
a213 1
        socklent_t namelen;
@


14.12
log
@Provide declarations for variables that live in server.c
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d213 1
a213 1
	int namelen;
@


14.11
log
@declare the fb_server_pkg_switch server callback switch table provided in server.c
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.10 2006/01/18 06:46:15 brlcad Exp $ (ARL)";
d131 6
@


14.10
log
@update copyright to 2006
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.9 2005/12/23 21:26:30 bob1961 Exp $ (ARL)";
d101 1
a103 2
#include "../libfb/pkgtypes.h"

d129 3
@


14.9
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.8 2005/10/23 04:44:30 brlcad Exp $ (ARL)";
@


14.8
log
@trailing ws
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.7 2005/06/15 04:34:52 brlcad Exp $ (ARL)";
a105 8
/* These symbols are provided by libfb/server.c */
extern struct pkg_switch fb_server_pkg_switch[];
extern FBIO	*fb_server_fbp;
extern fd_set	*fb_server_select_list;			/* master copy */
extern int	*fb_server_max_fd;
extern	int	fb_server_retain_on_close;	/* !0 => we are holding a reusable FB open */
extern	int	fb_server_got_fb_free;	/* !0 => we have received an fb_free */

@


14.7
log
@protect the sys/wait.h headers with HAVE_SYS_WAIT_H since not all systems (e.g. mingw) have it.
@
text
@d57 1
a57 1
 *  
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.6 2005/05/11 01:46:28 brlcad Exp $ (ARL)";
d422 1
a422 1
		if( (select( max_fd+1, &infds, (fd_set *)0, (fd_set *)0, 
d643 1
a643 1
		
@


14.7.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d57 1
a57 1
 *
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d422 1
a422 1
		if( (select( max_fd+1, &infds, (fd_set *)0, (fd_set *)0,
d643 1
a643 1

@


14.7.2.1
log
@Remove declarations that are now in fb.h
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.7 2005/06/15 04:34:52 brlcad Exp $ (ARL)";
d106 8
@


14.6
log
@instead of sleeping 5 seconds indefinately, retry every second up to a minute before giving up on starting the stand-alone daemon.
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.5 2005/04/26 07:56:01 brlcad Exp $ (ARL)";
d93 3
a95 1
#include <sys/wait.h>
@


14.5
log
@use HAVE_SYSLOG_H define from configure
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.4 2005/04/26 07:54:08 brlcad Exp $ (ARL)";
d356 3
a358 1
		sleep(5);
d360 3
a362 1
		/*exit(1);*/
@


14.4
log
@if/when someone compiles on irix 5 again, we can refactor the build logic for a proper configure check instead of defining _BSD_COMPAT for undocumented reasons
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.3 2005/01/30 20:30:37 brlcad Exp $ (ARL)";
d82 1
a82 1
#if defined(BSD) && !defined(CRAY2)
@


14.3
log
@update copyright to 2005
@
text
@d63 1
a63 5
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fbserv/fbserv.c,v 14.2 2004/12/20 20:20:33 morrison Exp $ (ARL)";
#endif

#if defined(IRIX) && IRIX==5
#  define	_BSD_COMPAT
@


14.2
log
@assign copyright and GPL license
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fbserv/fbserv.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			F B S E R V . C
a60 9
 *  
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
 *
 *  Copyright Notice -
 *	This software is Copyright (C) 1995-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fbserv/fbserv.c,v 1.4 2004/09/16 03:43:59 morrison Exp $ (ARL)";
@


1.4
log
@ws
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fbserv/fbserv.c,v 1.3 2004/08/02 23:01:47 morrison Exp $ (ARL)";
d691 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fbserv/fbserv.c,v 1.2 2004/06/08 22:04:14 morrison Exp $ (ARL)";
d57 1
a57 1
#define	_BSD_COMPAT
a61 2


d70 1
a70 1
# include <stdarg.h>
d73 1
a73 1
# include <varargs.h>
d77 1
a77 1
#	include <syslog.h>
d83 1
a83 1
#include <string.h>
d85 1
a85 1
#include <strings.h>
d96 1
@


1.2
log
@obliterate externs.h
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d60 1
a60 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fbserv/fbserv.c,v 11.27 2004/05/10 15:30:42 erikg Exp $ (ARL)";
a95 1
#include "externs.h"		/* For malloc, getopt */
@

