head	14.24;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.7
	rel-7-10-2:14.16
	rel-7-10-0:14.16
	rel-7-8-4:14.12
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.6
	rel-7-6-0:14.7
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.4
	bobWinPort:14.7.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.7
	rel-7-2-0:14.7
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.24
date	2007.12.16.18.53.47;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.12.16.15.59.37;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.11.21.20.49.05;	author erikgreenwald;	state Exp;
branches;
next	14.21;

14.21
date	2007.11.21.19.28.05;	author erikgreenwald;	state Exp;
branches;
next	14.20;

14.20
date	2007.10.14.09.08.19;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.14.08.01.46;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.09.15.16.23.04;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.14.20.06.49;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.02.02.08.48.28;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.31;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.24;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.43;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.11.21.30.36;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.07.09.19.17.15;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.09.09.09.44.08;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.02.14.04.43.07;	author brlcad;	state Exp;
branches
	14.7.6.1;
next	14.6;

14.6
date	2005.01.30.20.30.18;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.25.29;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.50;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.15.32;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.25.14.43.21;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.46;	author morrison;	state Exp;
branches;
next	;

14.7.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.24
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                      C A N O N L I B . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file canonlib.c
 *
 *  Author -
 *	Lee A. Butler
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>
#include <string.h>
#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
#endif

#include "machine.h"
#include "bu.h"

#include "./canon.h"

#define BUFSIZE 262144	/* 256Kbytes size of image transfer buffer */


int ipu_debug = 0;

/* this is from some imaginary libds.so ?
 * was extern'd, but without that lib, it failed... so we punt.
 */
int dsdebug = 0;

static void
toshort(dest, src)
     u_char	*dest;
     int	src;
{
    dest[0] = (u_char)(src >> 8);
    dest[1] = (u_char)src;
}
static void
toint(dest, src)
     u_char	*dest;
     int	src;
{
    dest[0] = (u_char)(src >> 24);
    dest[1] = (u_char)(src >> 16);
    dest[2] = (u_char)(src >> 8);
    dest[3] = (u_char)src;
}
#if defined(IRIX) && (IRIX == 4 || IRIX == 5 || IRIX == 6)
static void scsi_perror(int val, struct dsreq *dsp)
{
    fprintf(stderr, "doscsicmd retuns: %d ds_ret: 0x%02x   ds_status: 0x%02x  ds_msg: 0x%02x\n",
	    val,
	    dsp->ds_ret,
	    dsp->ds_status,
	    dsp->ds_msg);
    switch(dsp->ds_status) {
    case  0:
	fprintf(stderr, "scsi cmd finished normally\n");
	break;
    case  0x02:
	fprintf(stderr, "scsi cmd aborted, check\n");
	break;
    case  0x08:
	fprintf(stderr, "scsi cmd aborted, unit busy\n");
	break;
    case  0x10:
	fprintf(stderr, "scsi cmd with link finished\n");
	break;
    case  0x18:
	fprintf(stderr, "scsi unit aborted, reserved\n");
	break;
    }
}
/*	I P U _ A C Q U I R E
 *
 *	Wait for the IPU to finish what it was doing.  Exit program if IPU
 *	is unavailable.
 */
void
ipu_acquire(struct dsreq *dsp,
	    int timeout)
{
    int i=0;
    u_char buf[48];
    char *p;

    if (ipu_debug) fprintf(stderr, "ipu_acquire(%d)\n", timeout);

    while (testunitready00(dsp) && i < timeout)
	if (RET(dsp)==DSRT_NOSEL) {
	    fprintf(stderr, "IPU not responding\n");
	    bu_exit(-1, NULL);
	} else {
	    /* IPU busy */
	    if (ipu_debug)
		fprintf(stderr, "ipu_acquire() sleeping at %d\r", i);

	    sleep(5);
	    i += 5;
	}


    if (ipu_debug)
	fprintf(stderr, "\n");

    if (i >= timeout) {
	fprintf(stderr, "IPU timeout after %d seconds\n", i);
	bu_exit(-1, NULL);
    }

    /* now let's make sure we're talking to a "CANON IPU-" somthing */

    memset(p=CMDBUF(dsp), 0, 16);
    memset(buf, 0, sizeof(buf));
    p[0] = 0x12;
    p[4] = (u_char)sizeof(buf);
    CMDLEN(dsp) = 6;
    filldsreq(dsp, buf, sizeof(buf), DSRQ_READ|DSRQ_SENSE);

    if (!doscsireq(getfd(dsp), dsp) &&
	bcmp(&buf[8], "CANON   IPU-", 12)) {
	fprintf(stderr,
		"ipu_inquire() device is not IPU-10/CLC500!\n%s\n",
		&buf[8]);
	bu_exit(-1, NULL);
    }
}


/*	I P U _ I N Q U I R E
 *
 *	returns
 *		static string describing device
 */
char *
ipu_inquire(struct dsreq *dsp)
{
    static char response[64];
    u_char buf[36];
    char *p;

    if (ipu_debug) fprintf(stderr, "inquire()\n");


    /* up to 11 characters of status */
    if (testunitready00(dsp) != 0) {
	if (RET(dsp)==DSRT_NOSEL)
	    strcpy(response, "no response from device");
	else
	    strcpy(response, "device not ready");
	return response;
    }

    memset(p=CMDBUF(dsp), 0, 16);
    p[0] = 0x12;
    p[4] = (u_char)sizeof(buf);
    CMDLEN(dsp) = 6;
    filldsreq(dsp, buf, sizeof(buf), DSRQ_READ|DSRQ_SENSE);

    memset(response, 0, sizeof(response));
    if (!doscsireq(getfd(dsp), dsp)) {
	/* 32 characters */
	(void)sprintf(response,
		      "ISO Ver(%1u)  ECMA Ver(%1u) ANSI(%1u) ",
		      buf[2] >> 6,
		      (buf[2]>>3)&0x07,
		      buf[2] & 0x07);

	/* 20 characters of Vendor/Product ID */
	memcpy(&response[strlen(response)], &buf[8], 20);
	if (bcmp(&buf[8], "CANON   IPU-", 12)) {
	    fprintf(stderr,
		    "ipu_inquire() device is not IPU-10/CLC500!\n%s\n",
		    response);
	    bu_exit(-1, NULL);
	}
    }

    return response;
}

/*	I P U _ R E M O T E
 *
 *	Puts copier in "remote" mode.  In this mode copier functions
 *	are fully controllable by the IPU.
 *
 *	Can be used to "poll" printer done status.
 */
int
ipu_remote(struct dsreq *dsp)
{
    register char *p;
    int i;

    if (ipu_debug) fprintf(stderr, "ipu_remote()\n");

    memset(p=CMDBUF(dsp), 0, 16);
    p[0] = 0xc7;

    CMDLEN(dsp) = 12;

    filldsreq(dsp, (u_char *)NULL, 0, DSRQ_SENSE);

    if (i=doscsireq(getfd(dsp), dsp)) {
	fprintf(stderr, "ipu_remote failed\n");
	scsi_perror(i, dsp);
	return -1;
    }
    return 0;
}

int ipu_ready(struct dsreq *dsp)
{
    return(testunitready00(dsp));
}


/*	I P U _ C R E A T E _ F I L E
 *
 *	create a file in the IPU
 *
 *	Parameters
 *
 *	id	file id	(1-16 for palette/RGB files, 0 for bit-map)
 *	type	{ IPU_RGB_FILE | IPU_BITMAP_FILE | IPU_PALETTE_FILE }
 *	width	file image width
 *	height	file image height
 */
void
ipu_create_file(struct dsreq *dsp,
		u_char id, 		/* file identifier */
		u_char type, 		/* file type */
		int width,
		int height,
		char clear)		/* boolean: clear file memory */
{
    char *p;
    u_char file_params[8];
    int i;

    if (ipu_debug)
	fprintf(stderr, "ipu_create_file(%d, t=%d %dx%d, %d)\n",
		id, type, width, height, clear);

    memset(p=CMDBUF(dsp), 0, 16);
    p[0] = 0xc4;
    p[9] = 8;
    CMDLEN(dsp) = 12;

    memset(file_params, 0, sizeof(file_params));
    file_params[0] = (u_char)id;
    file_params[1] = type;
    if (!clear) file_params[2] = 0x80;
    toshort(&file_params[4], width);
    toshort(&file_params[6], height);

    filldsreq(dsp, file_params, sizeof(file_params),
	      DSRQ_WRITE|DSRQ_SENSE);

    if ( i=doscsireq(getfd(dsp), dsp) )  {
	fprintf(stderr, "create_file(%d, %d by %d) failed\n",
		(int)id, width, height);
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    }
}

/*	I P U _ D E L E T E _ F I L E
 *
 *	Parameters
 *
 *	id	id of file to delete
 */
void
ipu_delete_file(struct dsreq *dsp,
		u_char id)
{
    register char *p;
    static short ids;
    int i;

    if (ipu_debug) fprintf(stderr, "ipu_delete_file(%d)\n", id);

    memset(p=CMDBUF(dsp), 0, 16);
    p[0] = 0xc5;
    p[9] = 2;
    CMDLEN(dsp) = 12;

    ids = (id << 8) + id;

    filldsreq(dsp, (u_char *)&ids, 2, DSRQ_WRITE|DSRQ_SENSE);

    if (i=doscsireq(getfd(dsp), dsp)) {
	fprintf(stderr, "delete_file(%d) failed\n",
		id);
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);;
    }
}

/*	I P U _ G E T _ I M A G E
 *
 *	Copy image fragment from IPU buffer to host computer.
 *	No format conversion is performed
 */
u_char *
ipu_get_image(struct dsreq *dsp,
	      char id, 		/* file  id */
	      int sx, int sy, 	/* upper left corner of image */
	      int w, int h)	/* width/height of image portion to retrieve */
{
    register u_char *p;
    u_char		*img;
    int size;
    int i;

    if (ipu_debug) fprintf(stderr, "ipu_get_image()\n");

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0xc3;
    p[2] = id;
    CMDLEN(dsp) = 12;

    toshort(&p[3], sx);
    toshort(&p[5], sy);
    toshort(&p[7], w);
    toshort(&p[9], h);

    size = w * h * 3;

    if ((img = malloc( size )) == NULL) {
	fprintf(stderr, "malloc error\n");
	bu_exit(-1, NULL);
    }

    filldsreq(dsp, img, size, DSRQ_READ|DSRQ_SENSE);
    if ( i=doscsireq(getfd(dsp), dsp) )  {
	fprintf(stderr, "get_image(%d, %d,%d, %d,%d) failed\n",
		(int)id, sx, sy, w, h);
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    }

    return img;
}


/*
 *			I P U _  P U T _ I M A G E _ F R A G
 *
 *  Write image fragment from host to IPU buffer, in IPU format.
 *  The amount to be sent must be small enough to fit in a single
 *  SCSI transfer of 256k bytes.
 *  No format conversion is performed.
 */
void
ipu_put_image_frag(struct dsreq *dsp,
		   char id, 		/* file  id */
		   int sx, int sy, 	/* upper left corner of image */
		   int w, int h,	/* width/height of image portion to retrieve */
		   u_char *img)
{
    u_char	*p;
    int	i;
    int	nbytes;

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0xc2;			/* put image */
    p[2] = id;			/* file id */
    toshort(&p[3], sx);
    toshort(&p[5], sy);
    toshort(&p[7], w);		/* ipu img width */
    toshort(&p[9], h);		/* ipu img height */
    CMDLEN(dsp) = 12;

    nbytes = w * ipu_bytes_per_pixel * h;
    if( nbytes > (256 * 1024 - 2) )  {
	fprintf(stderr, "ipu_put_image_frag() nbytes=%d exceeds SCSI maximum transfer\n",
		nbytes);
	return;
    }

    filldsreq(dsp, img, nbytes, DSRQ_WRITE|DSRQ_SENSE);

    if ( i=doscsireq(getfd(dsp), dsp) )  {
	fprintf(stderr,
		"\nipu_put_image_frag(%d, %d,%d, %d,%d) failed\n",
		(int)id, sx, sy, w, h);
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    } else if ( ipu_debug )  {
	fprintf(stderr, "buffer y=%d  \r", sy);
    }
}


/*	I P U _ P U T _ I M A G E
 *
 *	load a BRL-CAD PIX(5) image into an IPU file.
 *	The entire image must be memory resident.
 *	Format conversion is performed.
 *
 *	Parameters
 *
 *	id	file id
 *	w	image width
 *	h	image height
 *	img	pointer to image data
 */
void
ipu_put_image(struct dsreq *dsp,
	      char id,
	      int w, int h,
	      u_char *img)
{
    u_char *ipubuf;
    int saved_debug;

    int bytes_per_line, lines_per_buf, bytes_per_buf, img_line;
    int buf_no, buf_line, orphan_lines, fullbuffers, pixel, ip;
    u_char *scanline, *red, *grn, *blu, *r, *g, *b;
    struct timeval tp1, tp2;
    struct timezone tz;
    FILE *fd;

    saved_debug = dsdebug;
    dsdebug = 0;

    if (ipu_debug) {
	fprintf(stderr, "ipu_put_image(id:%d, w:%d  h:%d)\n",
		id, w, h);
	if (dsdebug)
	    fd = fopen("put_image", "w");
    }
    bytes_per_line = w * ipu_bytes_per_pixel;
    lines_per_buf = BUFSIZE / bytes_per_line;
    bytes_per_buf = bytes_per_line * lines_per_buf;

    if ((ipubuf = malloc(bytes_per_buf)) == NULL) {
	fprintf(stderr, "malloc error in ipu_put_image()\n");
	bu_exit(-1, NULL);
    }

    fullbuffers = h / lines_per_buf;
    orphan_lines = h % lines_per_buf;

    red = &ipubuf[0];
    grn = &ipubuf[lines_per_buf*w];
    blu = &ipubuf[lines_per_buf*w*2];

    if (ipu_debug) {
	fprintf(stderr, "%d buffers of %d lines, 1 buffer of %d lines\n",
		fullbuffers, lines_per_buf, orphan_lines);
	memset(&tp1, 0, sizeof(struct timeval));
	memset(&tp2, 0, sizeof(struct timeval));
	if (gettimeofday(&tp1, &tz))
	    perror("gettimeofday()");
    }

    img_line = 0;
    for (buf_no=0 ; buf_no < fullbuffers ; buf_no++) {
	/* fill a full buffer */
	if( ipu_bytes_per_pixel == 3 )  {
	    for (buf_line = lines_per_buf ; buf_line-- > 0 ; img_line++) {
		/* move img_line to buf_line */
		scanline = &img[img_line*bytes_per_line];

		r = & red[buf_line*w];
		g = & grn[buf_line*w];
		b = & blu[buf_line*w];

		for (pixel=0,ip=0 ; pixel < w ; pixel++ ) {
		    r[pixel] = scanline[ip++];
		    g[pixel] = scanline[ip++];
		    b[pixel] = scanline[ip++];
		}
	    }
	} else {
	    /* Monochrome */
	    for (buf_line = lines_per_buf ; buf_line-- > 0 ; img_line++) {
		/* move img_line to buf_line */
		scanline = &img[img_line*bytes_per_line];
		r = & red[buf_line*w];

		memcpy(r, scanline, bytes_per_line);
	    }
	}

	if (dsdebug)
	    fwrite(ipubuf, bytes_per_buf, 1, fd);

	/* send buffer to IPU */
	ipu_put_image_frag(dsp, id, 0, h-img_line, w, lines_per_buf, ipubuf);
    }


    if (orphan_lines) {
	grn = & ipubuf[orphan_lines*w];
	blu = & ipubuf[orphan_lines*w*2];

	if (ipu_debug)
	    fprintf(stderr, "\nDoing %d orphans (img_line %d)\n",
		    orphan_lines, img_line);

	if( ipu_bytes_per_pixel == 3 )  {
	    for (buf_line = orphan_lines ; buf_line-- > 0 ; img_line++) {
		scanline = &img[img_line*bytes_per_line];
		r = & red[buf_line*w];
		g = & grn[buf_line*w];
		b = & blu[buf_line*w];

		for (pixel=0 ; pixel < w ; pixel++ ) {
		    r[pixel] = scanline[pixel*3];
		    g[pixel] = scanline[pixel*3+1];
		    b[pixel] = scanline[pixel*3+2];
		}
	    }
	}  else  {
	    /* Monochrome */
	    for (buf_line = orphan_lines ; buf_line-- > 0 ; img_line++) {
		scanline = &img[img_line*bytes_per_line];
		r = & red[buf_line*w];

		memcpy(r, scanline, bytes_per_line);
	    }
	}

	if (dsdebug)
	    fwrite(ipubuf, orphan_lines*bytes_per_line, 1, fd);

	/* send buffer to IPU
	 * y offset is implicitly 0
	 */
	ipu_put_image_frag(dsp, id, 0, 0, w, orphan_lines, ipubuf);
	if (ipu_debug)
	    fprintf(stderr, "\n");
    }

    if (tp1.tv_sec && ipu_debug) {
	if (gettimeofday(&tp2, &tz))
	    perror("gettimeofday()");
	else
	    fprintf(stderr, "image transferred in %ld sec.\n",
		    (long)(tp2.tv_sec - tp1.tv_sec));
    }

    if (dsdebug)
	fclose(fd);
    free(ipubuf);
    dsdebug = saved_debug;
}

static unsigned char ipu_units[] = {
    0x23,	/* Page Code "print measurement parameters" */
    6,	/* Parameter Length */
    IPU_UNITS_INCH,
    0,	/* Reserved */
    1,	/* divisor MSB */
    0x90,	/* divisor LSB */
    0,	/* Reserved */
    0	/* Reserved */
};

static unsigned char pr_mode[12] = {
    0x25,	/* Page Code "Print Mode Parameters" */
    0x0a,	/* Parameter Length */
    0,	/* Size Conv */
    0,	/* Repeat mode */
    0,	/* Gamma Compensation type */
    0,	/* Paper tray selection */
    0, 0,	/* Upper/Lower tray paper codes */
    0, 0, 0, 0	/* Reserved */
};

/*	I P U _ P R I N T _ C O N F I G
 *
 *	Set configuration parameters for printer
 *
 *	units	IPU_UNITS_INCH | IPU_UNITS_MM
 *	divisor	1 10 100 132 400
 *	conv	IPU_AUTOSCALE IPU_AUTOSCALE_IND IPU_MAG_FACTOR IPU_RESOLUTION
 *	mosaic	boolean: perform mosaic
 *	gamma	style { IPU_GAMMA_STANDARD | IPU_GAMMA_RGB | IPU_GAMMA_CG }
 *	tray	tray selection
 */
void
ipu_print_config(struct dsreq *dsp,
		 char units,
		 int divisor,
		 u_char conv, u_char mosaic, u_char ipu_gamma,
		 int tray)
{
    register u_char *p;
    u_char params[255];
    int bytes;
    int save;
    int i;

    if (ipu_debug)
	fprintf(stderr,
		"ipu_print_config(0x%0x, 0x%0x, 0x%0x, 0x%0x, 0x%0x, 0x%0x)\n",
		units, divisor, conv, mosaic, ipu_gamma, tray);

    save = dsdebug;

    pr_mode[2] = conv;
    if (mosaic) pr_mode[3] = 1;
    else pr_mode[3] = 0;
    pr_mode[4] = ipu_gamma;
    pr_mode[5] = (u_char)tray;

    ipu_units[2] = 0x23;	/* print mode parameters */
    ipu_units[2] = units;
    toshort(&ipu_units[4], divisor);

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0x15;		/* MODE SELECT */
    p[1] = 0x10;
    CMDLEN(dsp) = 6;

    memset(params, 0, sizeof(params));
    bytes = 4;	/* leave room for the mode parameter header */

    memcpy(&params[bytes], ipu_units, sizeof(ipu_units));
    bytes += sizeof(ipu_units);

    memcpy(&params[bytes], pr_mode, sizeof(pr_mode));
    bytes += sizeof(pr_mode);

    p[4] = (u_char)bytes;
    params[3] = (u_char)(bytes - 4);

    filldsreq(dsp, params, bytes, DSRQ_WRITE|DSRQ_SENSE);

    if ( i=doscsireq(getfd(dsp), dsp) )  {
	fprintf(stderr, "error doing print config.\n");
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    }
    dsdebug = save;

}

/*	I P U _ P R I N T _ F I L E
 *
 *	id	IPU file id of image to print
 *	copies	# of prints of file
 *	wait	sync/async printing
 */
void
ipu_print_file(struct dsreq *dsp,
	       char id,
	       int copies,
	       int wait,
	       int sx, int sy,
	       int sw, int sh,
	       union ipu_prsc_param *pr_param)
{
    register u_char *p;
    char buf[18];
    int i;

    if (ipu_debug) fprintf(stderr,
			   "ipu_print_file(id=%d copies=%d wait=%d sx=%d sy=%d sw=%d sh=%d\n\
	0x%x 0x%x 0x%x 0x%x)\n", id, copies, wait, sx, sy, sw, sh,
			   pr_param->c[0],pr_param->c[1],pr_param->c[2],pr_param->c[3]);


    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0xc1;
    toint(&p[6], (int)sizeof(buf));
    CMDLEN(dsp) = 12;

    memset(buf, 0, sizeof(buf));
    buf[0] = id;
    if (copies < 0) {
	fprintf(stderr, "Cannot print %d copies\n", copies);
	bu_exit(-1, NULL);
    } else if (copies > 99) {
	fprintf(stderr, "Cannot print more than 99 copies at once\n");
	bu_exit(-1, NULL);
    }
    toshort(&buf[1], copies);
    if (!wait) buf[3] = 0x080;	/* quick return */
    toshort(&buf[6], sx);
    toshort(&buf[8], sy);
    toshort(&buf[10], sw);
    toshort(&buf[12], sh);
    memcpy(&buf[14], pr_param, 4);

    filldsreq(dsp, (u_char *)buf, sizeof(buf), DSRQ_WRITE|DSRQ_SENSE);
    if ( i=doscsireq(getfd(dsp), dsp) )  {
	fprintf(stderr, "error printing file %d\n", id);
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    }
}
static unsigned char sc_mode[6] = {
    0x24,	/* Page Code "Scan Mode Parameters" */
    0x04,	/* Parameter Length */
    0,	/* Size Conv */
    0,	/* Scan */
    0, 0	/* Analog Input Rotation */
};
/*	I P U _ S C A N _ C O N F I G
 *
 *	Set configuration parameters for scanning
 *
 *	units	IPU_UNITS_INCH | IPU_UNITS_MM
 *	divisor	1 10 100 132 400
 *	conv	IPU_AUTOSCALE IPU_AUTOSCALE_IND IPU_MAG_FACTOR IPU_RESOLUTION
 *	field	boolean:  Frame scan / Field scan
 *	rotation	angle of image rotation (multiple of 90 degrees)
 */
void
ipu_scan_config(struct dsreq *dsp,
		char units,
		int divisor,
		char conv,
		char field,
		short rotation)
{
    register u_char *p;
    u_char params[255];
    int bytes;
    int i;

    if (ipu_debug) fprintf(stderr, "ipu_scan_config()\n");

    ipu_units[2] = units;
    toshort(&ipu_units[4], divisor);

    sc_mode[2] = conv;
    if (field) sc_mode[3] = 1;
    else sc_mode[3] = 0;

    rotation = rotation % 360;
    if (rotation != 0 && rotation != 90 && rotation != 180 &&
	rotation != 270) {
	fprintf(stderr,
		"image rotation in 90 degree increments only\n");
	bu_exit(-1, NULL);
    }
    toshort(&sc_mode[4], rotation);

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0x15;			/* MODE SELECT */
    p[1] = 0x10;
    CMDLEN(dsp) = 6;

    memset(params, 0, sizeof(params));
    bytes = 4;	/* leave room for the mode parameter header */

    memcpy(&params[bytes], ipu_units, sizeof(ipu_units));
    bytes += sizeof(ipu_units);

    memcpy(&params[bytes], sc_mode, sizeof(sc_mode));
    bytes += sizeof(sc_mode);

    p[4] = (u_char)bytes;
    params[3] = (u_char)(bytes - 4);

    filldsreq(dsp, params, bytes, DSRQ_WRITE|DSRQ_SENSE);

    if ( i=doscsireq(getfd(dsp), dsp) )  {
	fprintf(stderr, "error doing scan config.\n");
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    }
}

/*	I P U _ S C A N _ F I L E
 */
void
ipu_scan_file(struct dsreq *dsp,
	      char id,
	      char wait,
	      int sx, int sy,
	      int w, int h,
	      union ipu_prsc_param *sc_param)
{
    register u_char *p;
    char buf[18];
    int i;

    if (ipu_debug) fprintf(stderr,
			   "ipu_scan_file(id=%d wait=%d sx=%d sy=%d sw=%d sh=%d\n\
		0x%x 0x%x 0x%x 0x%x)\n", id, wait, sx, sy, w, h,
			   sc_param->c[0],sc_param->c[1],
			   sc_param->c[2],sc_param->c[3]);

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0xc0;
    toint(&p[6], (int)sizeof(buf));
    CMDLEN(dsp) = 12;

    memset(buf, 0, (int)sizeof(buf));
    buf[0] = id;

    if (!wait) buf[3] = 0x080;	/* quick return */
    toshort(&buf[6], sx);
    toshort(&buf[8], sy);
    toshort(&buf[10], w);
    toshort(&buf[12], h);
    memcpy(&buf[14], sc_param, 4);

    filldsreq(dsp, (u_char *)buf, sizeof(buf), DSRQ_WRITE|DSRQ_SENSE);
    if ( i=doscsireq(getfd(dsp), dsp) )  {
	fprintf(stderr, "error scanning file %d.\n", id);
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    }
}

/*	I P U _ L I S T _ F I L E S
 *
 *	list files in the IPU
 *
 *	returns a null terminated, newline separated list of files and
 *		associated file dimensions.
 */
char *
ipu_list_files(struct dsreq *dsp)
{
#define IPU_FILE_DESC_SIZE 16	/* # bytes for file description */
#define IPU_LFPH_LEN 8		/* List File Parameters Header Length */
    u_char *p;
    static char buf[IPU_LFPH_LEN + IPU_MAX_FILES*IPU_FILE_DESC_SIZE];
    int len;
    int i;
    int file_count;

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0xc6;
    toint(&p[6], (int)sizeof(buf));
    CMDLEN(dsp) = 12;

    filldsreq(dsp, (u_char *)buf, sizeof(buf), DSRQ_READ|DSRQ_SENSE);

    if (i=doscsireq(getfd(dsp), dsp)) {
	fprintf(stderr, "error in ipu_list_files().\n");
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    }

    len = ((int)buf[0]<<8) + buf[1] + 2;
    file_count = (len - 8) / buf[2];

    if ((p=malloc(file_count*19+1)) == NULL) {
	fprintf(stderr, "malloc error in ipu_list_files()\n");
	bu_exit(-1, NULL);
    } else {
	memset(p, 0, file_count*19+1);
    }

    for (i = 8 ; i < len ; i += buf[2]) {
	register char t;
	if (buf[i+1] == 0) t = 'B';
	else if (buf[i+1] == 2) t = 'R';
	else if (buf[i+1] == 3) t = 'P';
	else t = '?';

	sprintf((char *)&p[strlen( (char *)p)], "%1x.%c\t%4dx%4d\n",
		buf[i], t,
		((int)buf[i+2]<<8)+(int)buf[i+3],
		((int)buf[i+4]<<8)+(int)buf[i+5]);
    }

    return (char *)p;
}

/*	I P U _ S T O P
 *
 * Parameters
 *	dsp	SCSI interface ptr;
 *	halt	boolean:  Halt printing (or just report status)
 *
 * returns number of pages which have been printed
 */
int
ipu_stop(struct dsreq *dsp,
	 int halt)
{
    register char *p;
    char buf[18];
    int i;

    if (ipu_debug) fprintf(stderr, "ipu_stop(%d)\n", halt);

    memset(p=CMDBUF(dsp), 0, 16);
    p[0] = 0xcc;	/* scan file */
    if (halt)
	p[2] = 0x80;
    p[9] = 18;	/* param list len */
    CMDLEN(dsp) = 12;

    memset(buf, 0, sizeof(buf));
    filldsreq(dsp, (u_char *)buf, sizeof(buf), DSRQ_READ|DSRQ_SENSE);

    if ((i=doscsireq(getfd(dsp), dsp)) == -1) {
	fprintf(stderr, "Error doing ipu_stop().\n");
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);
    }

    return ((int)buf[1] << 8) + (int)buf[2];
}


int
ipu_get_conf(struct dsreq *dsp)
{
    register u_char *p;
    u_char params[255];
    int i;

    if (ipu_debug) fprintf(stderr, "ipu_config_printer()\n");

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0x1a;			/* mode sense */
    p[2] = 0x23;
    p[4] = sizeof(params);
    CMDLEN(dsp) = 6;

    memset(params, 0, sizeof(params));
    filldsreq(dsp, params, sizeof(params), DSRQ_READ|DSRQ_SENSE);

    if ((i=doscsireq(getfd(dsp), dsp)) == -1) {
	fprintf(stderr, "Error reading IPU configuration.\n");
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);;
    }

    if (params[0] == 11 && params[4] == 0x23) {
	p = & params[4];

	switch (p[2]) {
	case IPU_UNITS_INCH	:fprintf(stderr, "Units=Inch  ");
	    break;
	case IPU_UNITS_MM	:fprintf(stderr, "Units=mm  ");
	    break;
	default			:fprintf(stderr, "Units=??  ");
	    break;
	}

	i = ((int)p[4] << 8) + (int)p[5];
	fprintf(stderr, "Divisor=%d(0x%x)\n", i, i);
    }

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0x1a;			/* mode sense */
    p[2] = 0x25;
    p[4] = sizeof(params);
    CMDLEN(dsp) = 6;

    memset(params, 0, sizeof(params));
    filldsreq(dsp, params, sizeof(params), DSRQ_READ|DSRQ_SENSE);

    if ((i=doscsireq(getfd(dsp), dsp)) == -1) {
	fprintf(stderr, "Error reading IPU configuration.\n");
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);;
    }

    if (params[0] == 15 && params[4] == 0x25) {
	p = & params[4];
	switch (p[2]) {
	case IPU_AUTOSCALE : fprintf(stderr, "conv=Autoscale  ");
	    break;
	case IPU_AUTOSCALE_IND : fprintf(stderr, "conv=Autoscale_ind  ");
	    break;
	case IPU_MAG_FACTOR : fprintf(stderr, "conv=Mag Factor  ");
	    break;
	case IPU_RESOLUTION : fprintf(stderr, "conv=Resolution  ");
	    break;
	default	: fprintf(stderr, "conv=Unknown conv.");
	    break;
	}

	fprintf(stderr, "Repeat=%d  ", p[3]);

	switch (p[4]) {
	case IPU_GAMMA_STANDARD: fprintf(stderr, "gamma=std  ");
	    break;
	case IPU_GAMMA_RGB: fprintf(stderr, "gamma=rgb  ");
	    break;
	case IPU_GAMMA_CG: fprintf(stderr, "gamma=cg  ");
	    break;
	default: fprintf(stderr, "Unknown gamma  ");
	    break;
	}

	switch (p[5]) {
	case IPU_UPPER_CASSETTE : fprintf(stderr, "tray=upper\n");
	    break;
	case IPU_LOWER_CASSETTE : fprintf(stderr, "tray=lower\n");
	    break;
	case IPU_MANUAL_FEED : fprintf(stderr, "tray=Manual_Feed\n");
	    break;
	default: fprintf(stderr, "tray=Unknown (%d)\n", p[5]);
	    break;
	}

	fprintf(stderr, "Upper cassette paper=");
	switch (p[6]) {
	case 0x6: fputs("A3  ", stderr); break;
	case 0x8: fputs("A4R  ", stderr); break;
	case 0x18: fputs("B4  ", stderr); break;
	case 0x1a: fputs("B5R  ", stderr); break;
	case 0x28: fputs("A4  ", stderr); break;
	case 0x46: fputs("11\"x17\"  ", stderr); break;
	case 0x48: fputs("Letter R  ", stderr); break;
	case 0x58: fputs("Legal  ", stderr); break;
	case 0x68: fputs("Letter  ", stderr); break;
	case 0x80: fputs("Manual Feed  ", stderr); break;
	case 0xff: fputs("No cassette  ", stderr); break;
	default : fputs("unknown  ", stderr); break;
	}
	fprintf(stderr, "Lower cassette paper=");
	switch (p[7]) {
	case 0x6: fputs("A3\n", stderr); break;
	case 0x8: fputs("A4R\n", stderr); break;
	case 0x18: fputs("B4\n", stderr); break;
	case 0x1a: fputs("B5R\n", stderr); break;
	case 0x28: fputs("A4\n", stderr); break;
	case 0x46: fputs("11\"x17\"\n", stderr); break;
	case 0x48: fputs("Letter R\n", stderr); break;
	case 0x58: fputs("Legal\n", stderr); break;
	case 0x68: fputs("Letter\n", stderr); break;
	case 0x80: fputs("Manual Feed\n", stderr); break;
	case 0xff: fputs("No cassette\n", stderr); break;
	default : fputs("unknown\n", stderr); break;
	}
    }
    return 0;
}

int
ipu_get_conf_long(struct dsreq *dsp)
{
    register u_char *p;
    static u_char params[65535];
    int i;

    if (ipu_debug) fprintf(stderr, "ipu_config_printer()\n");

    memset(p=(u_char *)CMDBUF(dsp), 0, 16);
    p[0] = 0x5a;			/* mode sense */
    p[2] = 0x23;
    toint(&p[7], (int)sizeof(params));
    CMDLEN(dsp) = 10;

    memset(params, 0, sizeof(params));
    filldsreq(dsp, params, sizeof(params), DSRQ_READ|DSRQ_SENSE);

    if ((i=doscsireq(getfd(dsp), dsp)) == -1) {
	fprintf(stderr, "Error reading IPU configuration.\n");
	scsi_perror(i, dsp);
	bu_exit(-1, NULL);;
    }

    (void)fprintf(stderr, "Sense Data Length %u\n",
		  ((unsigned)params[0] << 8) + params[1]);

    (void)fprintf(stderr, "Block Descriptor Length %u\n",
		  ((unsigned)params[6] << 8) + params[7]);
    return 0;
}

/*
 *			I P U _ S E T _ P A L E T T E
 *
 *  For 8-bit mode, program the color palette.
 *  Works in the same manner as LIBFB color maps.
 *
 *  If 'cmap' is NULL, then linear ramp is used.
 *  If 'cmap' is non-NULL, then it points to a 768 byte array
 *  arranged as r0, g0, b0, r1, g1, b1, ...
 */
void
ipu_set_palette( dsp, cmap )
     struct dsreq	*dsp;
     unsigned char	*cmap;		/* NULL or [768] */
{
    register caddr_t p;
    unsigned char	linear[768];
    int		i;
    int		ret;

    if (ipu_debug) fprintf(stderr, "ipu_set_palette(cmap=x%lx)\n", (long)cmap);
    if( cmap == NULL )  {
	register int	j;
	register unsigned char *cp = linear;
	for( j=0; j < 256; j++ )  {
	    *cp++ = j;
	    *cp++ = j;
	    *cp++ = j;
	}
	cmap = linear;
    }

    /* The Palette has to be sent in 4 parts */
    for( i=0; i < 4; i++ )  {
	unsigned char	buf[4+2+192];

	memset(p=CMDBUF(dsp), 0, 16);
	p[0] = 0x15;		/* MODE SELECT, Group code 0 (6 byte) */
	/* Lun 0=scanner, Lun 3=printer */
	p[1] = (3<<5) | 0x10;	/* Lun, PF=1 (page format) */
	p[4] = sizeof(buf);
	CMDLEN(dsp) = 6;

	/* buf[0]:  Parameter header, 4 bytes long. */
	toint( buf, 192+2 );

	/* buf[4]: MODE PARAMETERS, block(s) of page codes. */
	buf[4] = 0x30 + i;	/* PAGE CODE "Color Palette Parameters" */
	buf[5] = 0xC0;		/* 192 bytes follow */
	memcpy(buf+4+2, cmap+i*192, 192);

	filldsreq(dsp, buf, sizeof(buf), DSRQ_WRITE|DSRQ_SENSE);

	if ( ret=doscsireq(getfd(dsp), dsp) )  {
	    fprintf(stderr, "ipu_set_palette(%d) failed\n", i);
	    scsi_perror(ret, dsp);
	    bu_exit(-1, NULL);
	}
    }
}

#endif /* __sgi__ */

char *options = "P:p:Q:q:acd:g:hmn:s:t:vw:zAC:M:R:D:N:S:W:X:Y:U:V#:";
extern char *bu_optarg;

char *progname = "(noname)";
char scsi_device[1024] = "/dev/scsi/sc0d6l3";
char ipu_gamma = IPU_GAMMA_CG;
int  ipu_filetype = IPU_RGB_FILE;
int  ipu_bytes_per_pixel = 3;
char tray = IPU_UPPER_CASSETTE;
char conv = IPU_AUTOSCALE;
char clear = 0;
int width = 512;
int height = 512;
int zoom = 0;
int scr_width;
int scr_height;
int scr_xoff;
int scr_yoff;
int copies = 1;
int autosize = 0;
int units = IPU_UNITS_INCH;
int divisor = 0x190;
int mosaic = 0;

union ipu_prsc_param param;

#define MAX_ARGS	64
static char arg_buf[10000] = {0};
static int  len;
char	*arg_v[MAX_ARGS];
int	arg_c;
char *print_queue = "canon";

/*
 *	U S A G E --- tell user how to invoke this program, then exit
 */
void usage(s)
     char *s;
{
    if (s) (void)fputs(s, stderr);

    (void) fprintf(stderr, "Usage: %s [options] [pixfile]\nOptions:\n%s", progname,
		   "	[-h] [-n scanlines] [-w width] [-s squareimagesize]\n\
	[-N outputheight] [-W outputwidth] [-S outputsquaresize]\n\
	[-X PageXOffset] [-Y PageYOffset] [-# bytes_pixel]\n\
	[-a(utosize_input)] [-g(amma) { s | r | c }]\n\
	[-z(oom)] [-t { u | l | m }] [-C(opies) {1-99}] [-m(osaic)]\n\
	[ -A(utoscale_output) | -M xmag:ymag | -R dpi ]\n\
	[-u(nits) { i|m } ] [-D divisor]\n\
	[-c(lear)] [-d SCSI_device] [-v(erbose)] [-V(erboser)]\n\
	[-q queue] [-p printer]\n");

    bu_exit(1, NULL);
}

/*
 *	P A R S E _ A R G S --- Parse through command line flags
 */
int parse_args(ac, av)
     int ac;
     char *av[];
{
    int  c;
    char *p;

    if (  ! (progname=strrchr(*av, '/'))  )
	progname = *av;
    else
	++progname;

    strncpy(arg_buf, progname, 10000);
    len = strlen(arg_buf) + 1;
    arg_v[arg_c = 0] = arg_buf;
    arg_v[++arg_c] = (char *)NULL;

    /* Turn off bu_getopt's error messages */
    bu_opterr = 0;

    /* get all the option flags from the command line */
    while ((c=bu_getopt(ac,av,options)) != EOF) {
	/* slup off a printer queue name */
	if (c == 'q' ||  c == 'p') {
	    print_queue = bu_optarg;
	    continue;
	}

	/* add option & arg to arg_v */
	if (p=strchr(options, c)) {
	    arg_v[arg_c++] = &arg_buf[len];
	    arg_v[arg_c] = (char *)NULL;
	    (void)sprintf(&arg_buf[len], "-%c", c);
	    len += strlen(&arg_buf[len]) + 1;
	    if (p[1] == ':') {
		arg_v[arg_c++] = &arg_buf[len];
		arg_v[arg_c] = (char *)NULL;
		(void)snprintf(&arg_buf[len], 10000, "%s", bu_optarg);
		len += strlen(&arg_buf[len]) + 1;
	    }
	}

	switch (c) {
	case 'a'	: autosize = !autosize; break;
	case 'c'	: clear = !clear; break;
	case 'd'	: if (isprint(*bu_optarg)) {
	    memset(scsi_device, 0, sizeof(scsi_device));
	    strncpy(scsi_device,bu_optarg,sizeof(scsi_device)-1);
	} else
	    usage("-d scsi_device_name\n");
	    break;
	case 'g'	: if (*bu_optarg == 's')
	    ipu_gamma = IPU_GAMMA_STANDARD;
	else if (*bu_optarg == 'r')
	    ipu_gamma = IPU_GAMMA_RGB;
	else if (*bu_optarg == 'c')
	    ipu_gamma = IPU_GAMMA_CG;
	else
	    usage("-g {std|rgb|cg}\n");
	    break;
	case 'h'	: width = height = 1024; break;
	case 'm'	: mosaic = !mosaic; break;
	case 'n'	: if ((c=atoi(bu_optarg)) > 0)
	    height = c;
	else
	    usage("-n scanlines\n");
	    break;
	case 's'	: if ((c=atoi(bu_optarg)) > 0)
	    width = height = c;
	else
	    usage("-s squareimagesize\n");
	    break;
	case 'w'	: if ((c=atoi(bu_optarg)) > 0)
	    width = c;
	else
	    usage("-w imagewidth\n");
	    break;
	case 't'	:switch (*bu_optarg) {
	case 'u'	:
	case 'U'	: tray = IPU_UPPER_CASSETTE;
	    break;
	case 'l'	:
	case 'L'	: tray = IPU_LOWER_CASSETTE;
	    break;
	case 'm'	:
	case 'M'	: tray = IPU_MANUAL_FEED;
	    break;
	default:
	    usage("-t {u|l|m}\n");
	    break;
	}
	    break;
	case 'U'	: if (*bu_optarg == 'i')
	    units = IPU_UNITS_INCH;
	else if (*bu_optarg == 'm')
	    units = IPU_UNITS_MM;
	else
	    usage("invalid units\n");
	    break;
	case 'z'	: zoom = !zoom;
	    scr_width= scr_height= scr_xoff= scr_yoff= 0;
	    break;
	case 'A'	: conv = IPU_AUTOSCALE;
	    memset((char *)&param, 0, sizeof(union ipu_prsc_param));
	    break;
	case 'M'	: conv = IPU_MAG_FACTOR;
	    if ((c=atoi(bu_optarg)) < 100 || c > 2000)
		usage("X Mag factor out of range 100-2000\n");
	    param.s[0] = c & 0x0ffff;
	    while (*bu_optarg && *bu_optarg++ != ':')
		;
	    if ((c = atoi(bu_optarg)) < 100 || c > 2000)
		usage("Y Mag factor out of range 100-2000\n");
	    param.s[1] = c & 0x0ffff;
	    break;
	case 'R'	: if ((c=atoi(bu_optarg)) > 0) {
	    param.i = c;
	    conv = IPU_RESOLUTION;
	} else {
	    fprintf(stderr,
		    "Resolution error (%d)\n",c);
	    bu_exit(-1, NULL);
	}
	    if (ipu_debug)
		fprintf(stderr,
			"Res: %d 0%02x 0%02x 0%02x 0%02x\n",
			c, param.c[0], param.c[1], param.c[2],
			param.c[3]);
	    break;
	case 'C'	: if ((c=atoi(bu_optarg)) > 0 && c < 99)
	    copies = c;
	else
	    usage("-C [1-99]\n");
	    break;
	case 'D'	: if ((c=atoi(bu_optarg)) > 0)
	    divisor = c;
	else
	    usage("-D divisor\n");
	    break;
	case 'N'	: if ((c=atoi(bu_optarg)) > 0)
	    scr_height = c;
	else
	    usage("-N outputlines\n");
	    break;
	case 'S'	: if ((c=atoi(bu_optarg)) > 0)
	    scr_width = scr_height = c;
	else
	    usage("-S outputsquaresize\n");
	    break;
	case 'W'	: if ((c=atoi(bu_optarg)) > 0)
	    scr_width = c;
	else
	    usage("-W outputwidth\n");
	    break;
	case 'X'	: if ((c=atoi(bu_optarg)) >= 0)
	    scr_xoff = c;
	else
	    usage("-X pageXoffset\n");
	    break;
	case 'Y'	: if ((c=atoi(bu_optarg)) >= 0)
	    scr_yoff = c;
	else
	    usage("-X pageYoffset\n");
	    break;
	case 'V'	: dsdebug = ! dsdebug;
	case 'v'	: ipu_debug = !ipu_debug; break;
	case '#'	: c = atoi(bu_optarg);
	    switch(c)  {
	    case 3:
		ipu_filetype = IPU_RGB_FILE;
		ipu_bytes_per_pixel = 3;
		break;
	    case 1:
		ipu_filetype = IPU_PALETTE_FILE;
		ipu_bytes_per_pixel = 1;
		break;
	    default:
		fprintf(stderr, "Bad value %d for bytes_per_pixel\n", c);
		break;
	    }
	    break;
	case '?'	:
	default		: fprintf(stderr, "Bad or help flag specified '%c'\n", c); break;
	}
    }
    return(bu_optind);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@convert all bzero calls to memset
@
text
@d198 1
a198 1
	bcopy(&buf[8], &response[strlen(response)], 20);
d513 1
a513 1
		memcpy( r, scanline, bytes_per_line );
d552 1
a552 1
		memcpy( r, scanline, bytes_per_line );
d652 1
a652 1
    bcopy(ipu_units, &params[bytes], sizeof(ipu_units));
d655 1
a655 1
    bcopy(pr_mode, &params[bytes], sizeof(pr_mode));
d717 1
a717 1
    bcopy(pr_param, &buf[14], 4);
d782 1
a782 1
    bcopy(ipu_units, &params[bytes], sizeof(ipu_units));
d785 1
a785 1
    bcopy(sc_mode, &params[bytes], sizeof(sc_mode));
d833 1
a833 1
    bcopy(sc_param, &buf[14], 4);
d1147 1
a1147 1
	bcopy( cmap+i*192, buf+4+2, 192 );
@


14.22
log
@pass bu_exit a NULL instead of an empty string
@
text
@d141 2
a142 2
    bzero(p=CMDBUF(dsp), 16);
    bzero(buf, sizeof(buf));
d182 1
a182 1
    bzero(p=CMDBUF(dsp), 16);
d188 1
a188 1
    bzero(response, sizeof(response));
d225 1
a225 1
    bzero(p=CMDBUF(dsp), 16);
d273 1
a273 1
    bzero(p=CMDBUF(dsp), 16);
d278 1
a278 1
    bzero(file_params, sizeof(file_params));
d312 1
a312 1
    bzero(p=CMDBUF(dsp), 16);
d347 1
a347 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d395 1
a395 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d482 2
a483 2
	bzero(&tp1, sizeof(struct timeval));
	bzero(&tp2, sizeof(struct timeval));
d644 1
a644 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d649 1
a649 1
    bzero(params, sizeof(params));
d697 1
a697 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d702 1
a702 1
    bzero(buf, sizeof(buf));
d774 1
a774 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d779 1
a779 1
    bzero(params, sizeof(params));
d820 1
a820 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d825 1
a825 1
    bzero(buf, (int)sizeof(buf));
d861 1
a861 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d881 1
a881 1
	bzero(p, file_count*19+1);
d918 1
a918 1
    bzero(p=CMDBUF(dsp), 16);
d925 1
a925 1
    bzero(buf, sizeof(buf));
d947 1
a947 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d953 1
a953 1
    bzero(params, sizeof(params));
d978 1
a978 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d984 1
a984 1
    bzero(params, sizeof(params));
d1075 1
a1075 1
    bzero(p=(u_char *)CMDBUF(dsp), 16);
d1081 1
a1081 1
    bzero(params, sizeof(params));
d1134 1
a1134 1
	bzero(p=CMDBUF(dsp), 16);
d1322 1
a1322 1
	    bzero( (char *)&param, sizeof(union ipu_prsc_param));
@


14.21
log
@exit->bu_exit where applicable
@
text
@d120 1
a120 1
	    bu_exit(-1, "");
d136 1
a136 1
	bu_exit(-1, "");
d153 1
a153 1
	bu_exit(-1, "");
d203 1
a203 1
	    bu_exit(-1, "");
d292 1
a292 1
	bu_exit(-1, "");
d325 1
a325 1
	bu_exit(-1, "");;
d361 1
a361 1
	bu_exit(-1, "");
d369 1
a369 1
	bu_exit(-1, "");
d418 1
a418 1
	bu_exit(-1, "");
d469 1
a469 1
	bu_exit(-1, "");
d666 1
a666 1
	bu_exit(-1, "");
d706 1
a706 1
	bu_exit(-1, "");
d709 1
a709 1
	bu_exit(-1, "");
d723 1
a723 1
	bu_exit(-1, "");
d770 1
a770 1
	bu_exit(-1, "");
d796 1
a796 1
	bu_exit(-1, "");
d839 1
a839 1
	bu_exit(-1, "");
d871 1
a871 1
	bu_exit(-1, "");
d879 1
a879 1
	bu_exit(-1, "");
d931 1
a931 1
	bu_exit(-1, "");
d959 1
a959 1
	bu_exit(-1, "");;
d990 1
a990 1
	bu_exit(-1, "");;
d1087 1
a1087 1
	bu_exit(-1, "");;
d1154 1
a1154 1
	    bu_exit(-1, "");
d1213 1
a1213 1
    bu_exit(1, "");
d1340 1
a1340 1
	    bu_exit(-1, "");
@


14.20
log
@more taking care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d120 1
a120 1
	    exit(-1);
d136 1
a136 1
	exit(-1);
d153 1
a153 1
	exit(-1);
d203 1
a203 1
	    exit(-1);
d292 1
a292 1
	exit(-1);
d325 1
a325 1
	exit(-1);;
d361 1
a361 1
	exit(-1);
d369 1
a369 1
	exit(-1);
d418 1
a418 1
	exit(-1);
d469 1
a469 1
	exit(-1);
d666 1
a666 1
	exit(-1);
d706 1
a706 1
	exit(-1);
d709 1
a709 1
	exit(-1);
d723 1
a723 1
	exit(-1);
d770 1
a770 1
	exit(-1);
d796 1
a796 1
	exit(-1);
d839 1
a839 1
	exit(-1);
d871 1
a871 1
	exit(-1);
d879 1
a879 1
	exit(-1);
d931 1
a931 1
	exit(-1);
d959 1
a959 1
	exit(-1);;
d990 1
a990 1
	exit(-1);;
d1087 1
a1087 1
	exit(-1);;
d1154 1
a1154 1
	    exit(-1);
d1213 1
a1213 1
    exit(1);
d1340 1
a1340 1
	    exit(-1);
@


14.19
log
@take care of a slew of level 4 flawfinder issues related to adding length parameters to string and i/o functions
@
text
@d1256 1
a1256 1
		(void)snprintf(&arg_buf[len], "%10000s", bu_optarg);
@


14.18
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d1231 1
a1231 1
    strcpy(arg_buf, progname);
d1256 1
a1256 1
		(void)sprintf(&arg_buf[len], "%s", bu_optarg);
@


14.17
log
@The c89 headers are all fair game since it's been a requirement since the move to ANSI c89 compliance.  So.. remove the HAVE_STDLIB_H checks and just use the header.  The headers <complex.h>, <fenv.h>, <inttypes.h>, <stdbool.h>, <stdint.h>, and <tgmath.h> were added with C99 and still need to be checked.  There are several other c89 headers that we could just use, though, that are still being checked.
@
text
@a30 3
#ifndef lint
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.16 2007/02/02 08:48:28 brlcad Exp $ (ARL)";
#endif
a35 1
#include <sys/time.h>
d38 3
a40 4
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
a42 1

@


14.16
log
@convert all of the lingering getopt calls to bu_getopt (as well as the related getopt globals optind, opterr, optarg) -- libbu's getopt has the benefit of being re-entrant and is portable to environments where getopt() may not be available.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.15 2007/01/27 01:41:31 brlcad Exp $ (ARL)";
d37 1
a40 3
#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#endif
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.14 2007/01/23 01:13:24 brlcad Exp $ (ARL)";
d52 1
d1170 1
a1170 2
extern char *optarg;
extern int optind, opterr, getopt();
d1244 2
a1245 2
    /* Turn off getopt's error messages */
    opterr = 0;
d1248 1
a1248 1
    while ((c=getopt(ac,av,options)) != EOF) {
d1251 1
a1251 1
	    print_queue = optarg;
d1264 1
a1264 1
		(void)sprintf(&arg_buf[len], "%s", optarg);
d1272 1
a1272 1
	case 'd'	: if (isprint(*optarg)) {
d1274 1
a1274 1
	    strncpy(scsi_device,optarg,sizeof(scsi_device)-1);
d1278 1
a1278 1
	case 'g'	: if (*optarg == 's')
d1280 1
a1280 1
	else if (*optarg == 'r')
d1282 1
a1282 1
	else if (*optarg == 'c')
d1289 1
a1289 1
	case 'n'	: if ((c=atoi(optarg)) > 0)
d1294 1
a1294 1
	case 's'	: if ((c=atoi(optarg)) > 0)
d1299 1
a1299 1
	case 'w'	: if ((c=atoi(optarg)) > 0)
d1304 1
a1304 1
	case 't'	:switch (*optarg) {
d1319 1
a1319 1
	case 'U'	: if (*optarg == 'i')
d1321 1
a1321 1
	else if (*optarg == 'm')
d1333 1
a1333 1
	    if ((c=atoi(optarg)) < 100 || c > 2000)
d1336 1
a1336 1
	    while (*optarg && *optarg++ != ':')
d1338 1
a1338 1
	    if ((c = atoi(optarg)) < 100 || c > 2000)
d1342 1
a1342 1
	case 'R'	: if ((c=atoi(optarg)) > 0) {
d1356 1
a1356 1
	case 'C'	: if ((c=atoi(optarg)) > 0 && c < 99)
d1361 1
a1361 1
	case 'D'	: if ((c=atoi(optarg)) > 0)
d1366 1
a1366 1
	case 'N'	: if ((c=atoi(optarg)) > 0)
d1371 1
a1371 1
	case 'S'	: if ((c=atoi(optarg)) > 0)
d1376 1
a1376 1
	case 'W'	: if ((c=atoi(optarg)) > 0)
d1381 1
a1381 1
	case 'X'	: if ((c=atoi(optarg)) >= 0)
d1386 1
a1386 1
	case 'Y'	: if ((c=atoi(optarg)) >= 0)
d1393 1
a1393 1
	case '#'	: c = atoi(optarg);
d1412 1
a1412 1
    return(optind);
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.13 2007/01/20 14:36:43 brlcad Exp $ (ARL)";
a252 1

@


14.13
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d32 1
a32 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.12 2006/08/11 21:30:36 brlcad Exp $ (ARL)";
@


14.12
log
@header cleanup
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.11 2006/07/09 19:17:15 brlcad Exp $ (ARL)";
@


14.11
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.10 2006/01/18 06:46:13 brlcad Exp $ (ARL)";
a38 1
#include <sys/types.h>
d42 1
a42 1
#include <stdlib.h>
d46 1
a46 1
#include <string.h>
d48 1
a48 1
#include <strings.h>
@


14.10
log
@update copyright to 2006
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.9 2005/10/23 04:44:29 brlcad Exp $ (ARL)";
d1199 1
a1199 1
static char arg_buf[1024];
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.8 2005/09/09 09:44:08 brlcad Exp $ (ARL)";
@


14.8
log
@BRL-CAD not BRLCAD, consistency
@
text
@d26 1
a26 1
 *  
d30 1
a30 1
 *  
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.7 2005/02/14 04:43:07 brlcad Exp $ (ARL)";
d117 1
a117 1
ipu_acquire(struct dsreq *dsp, 
d238 1
a238 1
	
d268 1
a268 1
ipu_create_file(struct dsreq *dsp, 
d271 2
a272 2
		int width, 
		int height, 
d313 1
a313 1
ipu_delete_file(struct dsreq *dsp, 
d345 1
a345 1
ipu_get_image(struct dsreq *dsp, 
d395 1
a395 1
ipu_put_image_frag(struct dsreq *dsp, 
d449 3
a451 3
ipu_put_image(struct dsreq *dsp, 
	      char id, 
	      int w, int h, 
d625 4
a628 4
ipu_print_config(struct dsreq *dsp, 
		 char units, 
		 int divisor, 
		 u_char conv, u_char mosaic, u_char ipu_gamma, 
d689 6
a694 6
ipu_print_file(struct dsreq *dsp, 
	       char id, 
	       int copies, 
	       int wait, 
	       int sx, int sy, 
	       int sw, int sh, 
d705 1
a705 1
	                                        
d754 5
a758 5
ipu_scan_config(struct dsreq *dsp, 
		char units, 
		int divisor, 
		char conv, 
		char field, 
d813 5
a817 5
ipu_scan_file(struct dsreq *dsp, 
	      char id, 
	      char wait, 
	      int sx, int sy, 
	      int w, int h, 
d901 1
a901 1
	sprintf((char *)&p[strlen( (char *)p)], "%1x.%c\t%4dx%4d\n", 
d919 1
a919 1
ipu_stop(struct dsreq *dsp, 
d974 1
a974 1
		
d1019 1
a1019 1
		
d1213 1
a1213 1
    (void) fprintf(stderr, "Usage: %s [options] [pixfile]\nOptions:\n%s", progname, 
@


14.7
log
@M-x indent-region
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.6 2005/01/30 20:30:18 brlcad Exp $ (ARL)";
d437 1
a437 1
 *	load a BRLCAD PIX(5) image into an IPU file.
@


14.7.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d26 1
a26 1
 *
d30 1
a30 1
 *
d33 1
a33 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d117 1
a117 1
ipu_acquire(struct dsreq *dsp,
d238 1
a238 1

d268 1
a268 1
ipu_create_file(struct dsreq *dsp,
d271 2
a272 2
		int width,
		int height,
d313 1
a313 1
ipu_delete_file(struct dsreq *dsp,
d345 1
a345 1
ipu_get_image(struct dsreq *dsp,
d395 1
a395 1
ipu_put_image_frag(struct dsreq *dsp,
d437 1
a437 1
 *	load a BRL-CAD PIX(5) image into an IPU file.
d449 3
a451 3
ipu_put_image(struct dsreq *dsp,
	      char id,
	      int w, int h,
d625 4
a628 4
ipu_print_config(struct dsreq *dsp,
		 char units,
		 int divisor,
		 u_char conv, u_char mosaic, u_char ipu_gamma,
d689 6
a694 6
ipu_print_file(struct dsreq *dsp,
	       char id,
	       int copies,
	       int wait,
	       int sx, int sy,
	       int sw, int sh,
d705 1
a705 1

d754 5
a758 5
ipu_scan_config(struct dsreq *dsp,
		char units,
		int divisor,
		char conv,
		char field,
d813 5
a817 5
ipu_scan_file(struct dsreq *dsp,
	      char id,
	      char wait,
	      int sx, int sy,
	      int w, int h,
d901 1
a901 1
	sprintf((char *)&p[strlen( (char *)p)], "%1x.%c\t%4dx%4d\n",
d919 1
a919 1
ipu_stop(struct dsreq *dsp,
d974 1
a974 1

d1019 1
a1019 1

d1213 1
a1213 1
    (void) fprintf(stderr, "Usage: %s [options] [pixfile]\nOptions:\n%s", progname,
@


14.6
log
@update copyright to 2005
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/canon/canonlib.c,v 14.5 2004/12/21 07:25:29 morrison Exp $ (ARL)";
d62 3
a64 3
	/* this is from some imaginary libds.so ?
	 * was extern'd, but without that lib, it failed... so we punt.
	 */
d69 2
a70 2
u_char	*dest;
int	src;
d72 2
a73 2
	dest[0] = (u_char)(src >> 8);
	dest[1] = (u_char)src;
d77 2
a78 2
u_char	*dest;
int	src;
d80 4
a83 4
	dest[0] = (u_char)(src >> 24);
	dest[1] = (u_char)(src >> 16);
	dest[2] = (u_char)(src >> 8);
	dest[3] = (u_char)src;
d88 22
a109 22
	fprintf(stderr, "doscsicmd retuns: %d ds_ret: 0x%02x   ds_status: 0x%02x  ds_msg: 0x%02x\n",
		val,
		dsp->ds_ret,
		dsp->ds_status,
		dsp->ds_msg);
	switch(dsp->ds_status) {
	case  0:
		fprintf(stderr, "scsi cmd finished normally\n");
		break;
	case  0x02:
		fprintf(stderr, "scsi cmd aborted, check\n");
		break;
	case  0x08:
		fprintf(stderr, "scsi cmd aborted, unit busy\n");
		break;
	case  0x10:
		fprintf(stderr, "scsi cmd with link finished\n");
		break;
	case  0x18:
		fprintf(stderr, "scsi unit aborted, reserved\n");
		break;
	}
d120 17
a136 26
	int i=0;
	u_char buf[48];
	char *p;

	if (ipu_debug) fprintf(stderr, "ipu_acquire(%d)\n", timeout);

	while (testunitready00(dsp) && i < timeout)
		if (RET(dsp)==DSRT_NOSEL) {
			fprintf(stderr, "IPU not responding\n");
			exit(-1);
		} else {
			/* IPU busy */
			if (ipu_debug)
				fprintf(stderr, "ipu_acquire() sleeping at %d\r", i);

			sleep(5);
			i += 5;
		}


	if (ipu_debug)
		fprintf(stderr, "\n");

	if (i >= timeout) {
		fprintf(stderr, "IPU timeout after %d seconds\n", i);
		exit(-1);
a138 1
	/* now let's make sure we're talking to a "CANON IPU-" somthing */
d140 24
a163 14
	bzero(p=CMDBUF(dsp), 16);
	bzero(buf, sizeof(buf));
	p[0] = 0x12;
	p[4] = (u_char)sizeof(buf);
	CMDLEN(dsp) = 6;
	filldsreq(dsp, buf, sizeof(buf), DSRQ_READ|DSRQ_SENSE);

	if (!doscsireq(getfd(dsp), dsp) &&
	    bcmp(&buf[8], "CANON   IPU-", 12)) {
		fprintf(stderr,
			"ipu_inquire() device is not IPU-10/CLC500!\n%s\n",
			&buf[8]);
		exit(-1);
	}
d175 3
a177 5
	static char response[64];
	u_char buf[36];
	char *p;

	if (ipu_debug) fprintf(stderr, "inquire()\n");
d179 1
a180 8
	/* up to 11 characters of status */
	if (testunitready00(dsp) != 0) {
		if (RET(dsp)==DSRT_NOSEL)
			strcpy(response, "no response from device");
		else
			strcpy(response, "device not ready");
		return response;
	}
d182 8
a189 5
	bzero(p=CMDBUF(dsp), 16);
	p[0] = 0x12;
	p[4] = (u_char)sizeof(buf);
	CMDLEN(dsp) = 6;
	filldsreq(dsp, buf, sizeof(buf), DSRQ_READ|DSRQ_SENSE);
d191 22
a212 17
	bzero(response, sizeof(response));
	if (!doscsireq(getfd(dsp), dsp)) {
		/* 32 characters */
		(void)sprintf(response,
			"ISO Ver(%1u)  ECMA Ver(%1u) ANSI(%1u) ",
			buf[2] >> 6,
			(buf[2]>>3)&0x07,
			buf[2] & 0x07);

		/* 20 characters of Vendor/Product ID */
		bcopy(&buf[8], &response[strlen(response)], 20);
		if (bcmp(&buf[8], "CANON   IPU-", 12)) {
		    fprintf(stderr,
			"ipu_inquire() device is not IPU-10/CLC500!\n%s\n",
			response);
		    exit(-1);
		}
d214 1
d216 1
a216 1
	return response;
d229 2
a230 2
	register char *p;
	int i;
d232 1
a232 1
	if (ipu_debug) fprintf(stderr, "ipu_remote()\n");
d234 2
a235 2
	bzero(p=CMDBUF(dsp), 16);
	p[0] = 0xc7;
d237 1
a237 1
	CMDLEN(dsp) = 12;
d239 1
a239 1
	filldsreq(dsp, (u_char *)NULL, 0, DSRQ_SENSE);
d241 6
a246 6
	if (i=doscsireq(getfd(dsp), dsp)) {
		fprintf(stderr, "ipu_remote failed\n");
		scsi_perror(i, dsp);
		return -1;
	}
	return 0;
d251 1
a251 1
	return(testunitready00(dsp));
d275 29
a303 29
	char *p;
	u_char file_params[8];
	int i;

	if (ipu_debug)
		fprintf(stderr, "ipu_create_file(%d, t=%d %dx%d, %d)\n",
			id, type, width, height, clear);

	bzero(p=CMDBUF(dsp), 16);
	p[0] = 0xc4;
	p[9] = 8;
	CMDLEN(dsp) = 12;

	bzero(file_params, sizeof(file_params));
	file_params[0] = (u_char)id;
	file_params[1] = type;
	if (!clear) file_params[2] = 0x80;
	toshort(&file_params[4], width);
	toshort(&file_params[6], height);

	filldsreq(dsp, file_params, sizeof(file_params),
		DSRQ_WRITE|DSRQ_SENSE);

	if ( i=doscsireq(getfd(dsp), dsp) )  {
		fprintf(stderr, "create_file(%d, %d by %d) failed\n",
			(int)id, width, height);
		scsi_perror(i, dsp);
		exit(-1);
	}
d316 21
a336 21
	register char *p;
	static short ids;
	int i;

	if (ipu_debug) fprintf(stderr, "ipu_delete_file(%d)\n", id);

	bzero(p=CMDBUF(dsp), 16);
	p[0] = 0xc5;
	p[9] = 2;
	CMDLEN(dsp) = 12;

	ids = (id << 8) + id;

	filldsreq(dsp, (u_char *)&ids, 2, DSRQ_WRITE|DSRQ_SENSE);

	if (i=doscsireq(getfd(dsp), dsp)) {
		fprintf(stderr, "delete_file(%d) failed\n",
			id);
		scsi_perror(i, dsp);
		exit(-1);;
	}
d350 31
a380 23
	register u_char *p;
	u_char		*img;
	int size;
	int i;

	if (ipu_debug) fprintf(stderr, "ipu_get_image()\n");

	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0xc3;
	p[2] = id;
	CMDLEN(dsp) = 12;

	toshort(&p[3], sx);
	toshort(&p[5], sy);
	toshort(&p[7], w);
	toshort(&p[9], h);

	size = w * h * 3;

	if ((img = malloc( size )) == NULL) {
		fprintf(stderr, "malloc error\n");
		exit(-1);
	}
d382 1
a382 9
	filldsreq(dsp, img, size, DSRQ_READ|DSRQ_SENSE);
	if ( i=doscsireq(getfd(dsp), dsp) )  {
		fprintf(stderr, "get_image(%d, %d,%d, %d,%d) failed\n",
			(int)id, sx, sy, w, h);
		scsi_perror(i, dsp);
		exit(-1);
	}

	return img;
d396 36
a431 36
	      char id, 		/* file  id */
	      int sx, int sy, 	/* upper left corner of image */
	      int w, int h,	/* width/height of image portion to retrieve */
	      u_char *img)
{
	u_char	*p;
	int	i;
	int	nbytes;

	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0xc2;			/* put image */
	p[2] = id;			/* file id */
	toshort(&p[3], sx);
	toshort(&p[5], sy);
	toshort(&p[7], w);		/* ipu img width */
	toshort(&p[9], h);		/* ipu img height */
	CMDLEN(dsp) = 12;

	nbytes = w * ipu_bytes_per_pixel * h;
	if( nbytes > (256 * 1024 - 2) )  {
		fprintf(stderr, "ipu_put_image_frag() nbytes=%d exceeds SCSI maximum transfer\n",
			nbytes);
		return;
	}

	filldsreq(dsp, img, nbytes, DSRQ_WRITE|DSRQ_SENSE);

	if ( i=doscsireq(getfd(dsp), dsp) )  {
		fprintf(stderr,
		    "\nipu_put_image_frag(%d, %d,%d, %d,%d) failed\n",
		    (int)id, sx, sy, w, h);
		scsi_perror(i, dsp);
		exit(-1);
	} else if ( ipu_debug )  {
		fprintf(stderr, "buffer y=%d  \r", sy);
	}
d454 2
a455 2
	u_char *ipubuf;
	int saved_debug;
d457 65
a521 27
	int bytes_per_line, lines_per_buf, bytes_per_buf, img_line;
	int buf_no, buf_line, orphan_lines, fullbuffers, pixel, ip;
	u_char *scanline, *red, *grn, *blu, *r, *g, *b;
	struct timeval tp1, tp2;
	struct timezone tz;
	FILE *fd;

	saved_debug = dsdebug;
	dsdebug = 0;

	if (ipu_debug) {
		fprintf(stderr, "ipu_put_image(id:%d, w:%d  h:%d)\n",
			id, w, h);
		if (dsdebug)
			fd = fopen("put_image", "w");
	}
	bytes_per_line = w * ipu_bytes_per_pixel;
	lines_per_buf = BUFSIZE / bytes_per_line;
	bytes_per_buf = bytes_per_line * lines_per_buf;

	if ((ipubuf = malloc(bytes_per_buf)) == NULL) {
		fprintf(stderr, "malloc error in ipu_put_image()\n");
		exit(-1);
	}

	fullbuffers = h / lines_per_buf;
	orphan_lines = h % lines_per_buf;
d523 2
a524 11
	red = &ipubuf[0];
	grn = &ipubuf[lines_per_buf*w];
       	blu = &ipubuf[lines_per_buf*w*2];

	if (ipu_debug) {
		fprintf(stderr, "%d buffers of %d lines, 1 buffer of %d lines\n",
			fullbuffers, lines_per_buf, orphan_lines);
		bzero(&tp1, sizeof(struct timeval));
		bzero(&tp2, sizeof(struct timeval));
		if (gettimeofday(&tp1, &tz))
			perror("gettimeofday()");
d527 2
a528 24
	img_line = 0;
	for (buf_no=0 ; buf_no < fullbuffers ; buf_no++) {
		/* fill a full buffer */
		if( ipu_bytes_per_pixel == 3 )  {
			for (buf_line = lines_per_buf ; buf_line-- > 0 ; img_line++) {
				/* move img_line to buf_line */
				scanline = &img[img_line*bytes_per_line];

				r = & red[buf_line*w];
				g = & grn[buf_line*w];
				b = & blu[buf_line*w];

				for (pixel=0,ip=0 ; pixel < w ; pixel++ ) {
					r[pixel] = scanline[ip++];
					g[pixel] = scanline[ip++];
					b[pixel] = scanline[ip++];
				}
			}
		} else {
			/* Monochrome */
			for (buf_line = lines_per_buf ; buf_line-- > 0 ; img_line++) {
				/* move img_line to buf_line */
				scanline = &img[img_line*bytes_per_line];
				r = & red[buf_line*w];
d530 3
a532 3
				memcpy( r, scanline, bytes_per_line );
			}
		}
a533 2
		if (dsdebug)
			fwrite(ipubuf, bytes_per_buf, 1, fd);
d535 3
a537 3
		/* send buffer to IPU */
		ipu_put_image_frag(dsp, id, 0, h-img_line, w, lines_per_buf, ipubuf);
	}
d539 3
d543 11
a553 29
	if (orphan_lines) {
		grn = & ipubuf[orphan_lines*w];
		blu = & ipubuf[orphan_lines*w*2];

		if (ipu_debug)
			fprintf(stderr, "\nDoing %d orphans (img_line %d)\n",
				orphan_lines, img_line);

		if( ipu_bytes_per_pixel == 3 )  {
			for (buf_line = orphan_lines ; buf_line-- > 0 ; img_line++) {
				scanline = &img[img_line*bytes_per_line];
				r = & red[buf_line*w];
				g = & grn[buf_line*w];
				b = & blu[buf_line*w];

				for (pixel=0 ; pixel < w ; pixel++ ) {
					r[pixel] = scanline[pixel*3];
					g[pixel] = scanline[pixel*3+1];
					b[pixel] = scanline[pixel*3+2];
				}
			}
		}  else  {
			/* Monochrome */
			for (buf_line = orphan_lines ; buf_line-- > 0 ; img_line++) {
				scanline = &img[img_line*bytes_per_line];
				r = & red[buf_line*w];

				memcpy( r, scanline, bytes_per_line );
			}
d555 6
d562 3
a564 2
		if (dsdebug)
			fwrite(ipubuf, orphan_lines*bytes_per_line, 1, fd);
d566 2
a567 7
		/* send buffer to IPU
		 * y offset is implicitly 0
		 */
		ipu_put_image_frag(dsp, id, 0, 0, w, orphan_lines, ipubuf);
		if (ipu_debug)
			fprintf(stderr, "\n");
	}
d569 7
a575 7
	if (tp1.tv_sec && ipu_debug) {
		if (gettimeofday(&tp2, &tz))
			perror("gettimeofday()");
		else
			fprintf(stderr, "image transferred in %ld sec.\n",
				(long)(tp2.tv_sec - tp1.tv_sec));
	}
d577 12
a588 4
	if (dsdebug)
		fclose(fd);
	free(ipubuf);
	dsdebug = saved_debug;
d592 8
a599 8
	0x23,	/* Page Code "print measurement parameters" */
	6,	/* Parameter Length */
	IPU_UNITS_INCH,
	0,	/* Reserved */
	1,	/* divisor MSB */
	0x90,	/* divisor LSB */
	0,	/* Reserved */
	0	/* Reserved */
d603 8
a610 8
	0x25,	/* Page Code "Print Mode Parameters" */
	0x0a,	/* Parameter Length */
	0,	/* Size Conv */
	0,	/* Repeat mode */
	0,	/* Gamma Compensation type */
	0,	/* Paper tray selection */
	0, 0,	/* Upper/Lower tray paper codes */
	0, 0, 0, 0	/* Reserved */
d631 5
a635 5
	register u_char *p;
	u_char params[255];
	int bytes;
	int save;
	int i;
d637 2
a638 2
	if (ipu_debug)
		fprintf(stderr,
d642 1
a642 30
	save = dsdebug;

	pr_mode[2] = conv;
	if (mosaic) pr_mode[3] = 1;
	else pr_mode[3] = 0;
	pr_mode[4] = ipu_gamma;
	pr_mode[5] = (u_char)tray;

	ipu_units[2] = 0x23;	/* print mode parameters */
	ipu_units[2] = units;
	toshort(&ipu_units[4], divisor);

	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0x15;		/* MODE SELECT */
	p[1] = 0x10;
	CMDLEN(dsp) = 6;

	bzero(params, sizeof(params));
	bytes = 4;	/* leave room for the mode parameter header */

	bcopy(ipu_units, &params[bytes], sizeof(ipu_units));
	bytes += sizeof(ipu_units);

	bcopy(pr_mode, &params[bytes], sizeof(pr_mode));
	bytes += sizeof(pr_mode);

	p[4] = (u_char)bytes;
	params[3] = (u_char)(bytes - 4);

	filldsreq(dsp, params, bytes, DSRQ_WRITE|DSRQ_SENSE);
d644 35
a678 6
	if ( i=doscsireq(getfd(dsp), dsp) )  {
		fprintf(stderr, "error doing print config.\n");
		scsi_perror(i, dsp);
		exit(-1);
	}
	dsdebug = save;
d697 3
a699 3
	register u_char *p;
	char buf[18];
	int i;
d701 2
a702 2
	if (ipu_debug) fprintf(stderr,
	"ipu_print_file(id=%d copies=%d wait=%d sx=%d sy=%d sw=%d sh=%d\n\
d704 1
a704 1
	pr_param->c[0],pr_param->c[1],pr_param->c[2],pr_param->c[3]);
d707 28
a734 28
	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0xc1;
	toint(&p[6], (int)sizeof(buf));
	CMDLEN(dsp) = 12;

	bzero(buf, sizeof(buf));
	buf[0] = id;
	if (copies < 0) {
		fprintf(stderr, "Cannot print %d copies\n", copies);
		exit(-1);
	} else if (copies > 99) {
		fprintf(stderr, "Cannot print more than 99 copies at once\n");
		exit(-1);
	}
	toshort(&buf[1], copies);
	if (!wait) buf[3] = 0x080;	/* quick return */
	toshort(&buf[6], sx);
	toshort(&buf[8], sy);
	toshort(&buf[10], sw);
	toshort(&buf[12], sh);
	bcopy(pr_param, &buf[14], 4);

	filldsreq(dsp, (u_char *)buf, sizeof(buf), DSRQ_WRITE|DSRQ_SENSE);
	if ( i=doscsireq(getfd(dsp), dsp) )  {
		fprintf(stderr, "error printing file %d\n", id);
		scsi_perror(i, dsp);
		exit(-1);
	}
d737 5
a741 5
	0x24,	/* Page Code "Scan Mode Parameters" */
	0x04,	/* Parameter Length */
	0,	/* Size Conv */
	0,	/* Scan */
	0, 0	/* Analog Input Rotation */
d761 47
a807 47
	register u_char *p;
	u_char params[255];
	int bytes;
	int i;

	if (ipu_debug) fprintf(stderr, "ipu_scan_config()\n");

	ipu_units[2] = units;
	toshort(&ipu_units[4], divisor);

	sc_mode[2] = conv;
	if (field) sc_mode[3] = 1;
	else sc_mode[3] = 0;

	rotation = rotation % 360;
	if (rotation != 0 && rotation != 90 && rotation != 180 &&
	    rotation != 270) {
		fprintf(stderr,
		    "image rotation in 90 degree increments only\n");
		exit(-1);
	}
	toshort(&sc_mode[4], rotation);

	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0x15;			/* MODE SELECT */
	p[1] = 0x10;
	CMDLEN(dsp) = 6;

	bzero(params, sizeof(params));
	bytes = 4;	/* leave room for the mode parameter header */

	bcopy(ipu_units, &params[bytes], sizeof(ipu_units));
	bytes += sizeof(ipu_units);

	bcopy(sc_mode, &params[bytes], sizeof(sc_mode));
	bytes += sizeof(sc_mode);

	p[4] = (u_char)bytes;
	params[3] = (u_char)(bytes - 4);

	filldsreq(dsp, params, bytes, DSRQ_WRITE|DSRQ_SENSE);

	if ( i=doscsireq(getfd(dsp), dsp) )  {
		fprintf(stderr, "error doing scan config.\n");
		scsi_perror(i, dsp);
		exit(-1);
	}
d820 3
a822 3
	register u_char *p;
	char buf[18];
	int i;
d824 2
a825 2
	if (ipu_debug) fprintf(stderr,
		"ipu_scan_file(id=%d wait=%d sx=%d sy=%d sw=%d sh=%d\n\
d827 2
a828 2
		sc_param->c[0],sc_param->c[1],
		sc_param->c[2],sc_param->c[3]);
d830 21
a850 21
	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0xc0;
	toint(&p[6], (int)sizeof(buf));
	CMDLEN(dsp) = 12;

	bzero(buf, (int)sizeof(buf));
	buf[0] = id;

	if (!wait) buf[3] = 0x080;	/* quick return */
	toshort(&buf[6], sx);
	toshort(&buf[8], sy);
	toshort(&buf[10], w);
	toshort(&buf[12], h);
	bcopy(sc_param, &buf[14], 4);

	filldsreq(dsp, (u_char *)buf, sizeof(buf), DSRQ_WRITE|DSRQ_SENSE);
	if ( i=doscsireq(getfd(dsp), dsp) )  {
		fprintf(stderr, "error scanning file %d.\n", id);
		scsi_perror(i, dsp);
		exit(-1);
	}
d865 41
a905 28
	u_char *p;
	static char buf[IPU_LFPH_LEN + IPU_MAX_FILES*IPU_FILE_DESC_SIZE];
	int len;
	int i;
	int file_count;

	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0xc6;
	toint(&p[6], (int)sizeof(buf));
	CMDLEN(dsp) = 12;

	filldsreq(dsp, (u_char *)buf, sizeof(buf), DSRQ_READ|DSRQ_SENSE);

	if (i=doscsireq(getfd(dsp), dsp)) {
		fprintf(stderr, "error in ipu_list_files().\n");
		scsi_perror(i, dsp);
		exit(-1);
	}

	len = ((int)buf[0]<<8) + buf[1] + 2;
	file_count = (len - 8) / buf[2];

	if ((p=malloc(file_count*19+1)) == NULL) {
		fprintf(stderr, "malloc error in ipu_list_files()\n");
		exit(-1);
	} else {
		bzero(p, file_count*19+1);
	}
d907 1
a907 14
	for (i = 8 ; i < len ; i += buf[2]) {
		register char t;
		if (buf[i+1] == 0) t = 'B';
		else if (buf[i+1] == 2) t = 'R';
		else if (buf[i+1] == 3) t = 'P';
		else t = '?';

		sprintf((char *)&p[strlen( (char *)p)], "%1x.%c\t%4dx%4d\n", 
			buf[i], t,
			((int)buf[i+2]<<8)+(int)buf[i+3],
			((int)buf[i+4]<<8)+(int)buf[i+5]);
	}

	return (char *)p;
d922 21
a942 21
	register char *p;
	char buf[18];
	int i;

	if (ipu_debug) fprintf(stderr, "ipu_stop(%d)\n", halt);

	bzero(p=CMDBUF(dsp), 16);
	p[0] = 0xcc;	/* scan file */
	if (halt)
		p[2] = 0x80;
	p[9] = 18;	/* param list len */
	CMDLEN(dsp) = 12;

	bzero(buf, sizeof(buf));
	filldsreq(dsp, (u_char *)buf, sizeof(buf), DSRQ_READ|DSRQ_SENSE);

	if ((i=doscsireq(getfd(dsp), dsp)) == -1) {
		fprintf(stderr, "Error doing ipu_stop().\n");
		scsi_perror(i, dsp);
		exit(-1);
	}
d944 1
a944 1
	return ((int)buf[1] << 8) + (int)buf[2];
d951 20
a970 20
	register u_char *p;
	u_char params[255];
	int i;

	if (ipu_debug) fprintf(stderr, "ipu_config_printer()\n");

	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0x1a;			/* mode sense */
	p[2] = 0x23;
	p[4] = sizeof(params);
	CMDLEN(dsp) = 6;

	bzero(params, sizeof(params));
	filldsreq(dsp, params, sizeof(params), DSRQ_READ|DSRQ_SENSE);

	if ((i=doscsireq(getfd(dsp), dsp)) == -1) {
		fprintf(stderr, "Error reading IPU configuration.\n");
		scsi_perror(i, dsp);
		exit(-1);;
	}
d972 2
a973 2
	if (params[0] == 11 && params[4] == 0x23) {
		p = & params[4];
d975 41
a1015 11
		switch (p[2]) {
		case IPU_UNITS_INCH	:fprintf(stderr, "Units=Inch  ");
					break;
		case IPU_UNITS_MM	:fprintf(stderr, "Units=mm  ");
					break;
		default			:fprintf(stderr, "Units=??  ");
					break;
		}

		i = ((int)p[4] << 8) + (int)p[5];
		fprintf(stderr, "Divisor=%d(0x%x)\n", i, i);
d1018 1
a1018 31
	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0x1a;			/* mode sense */
	p[2] = 0x25;
	p[4] = sizeof(params);
	CMDLEN(dsp) = 6;

	bzero(params, sizeof(params));
	filldsreq(dsp, params, sizeof(params), DSRQ_READ|DSRQ_SENSE);

	if ((i=doscsireq(getfd(dsp), dsp)) == -1) {
		fprintf(stderr, "Error reading IPU configuration.\n");
		scsi_perror(i, dsp);
		exit(-1);;
	}

	if (params[0] == 15 && params[4] == 0x25) {
		p = & params[4];
		switch (p[2]) {
		case IPU_AUTOSCALE : fprintf(stderr, "conv=Autoscale  ");
					break;
		case IPU_AUTOSCALE_IND : fprintf(stderr, "conv=Autoscale_ind  ");
					break;
		case IPU_MAG_FACTOR : fprintf(stderr, "conv=Mag Factor  ");
					break;
		case IPU_RESOLUTION : fprintf(stderr, "conv=Resolution  ");
					break;
		default	: fprintf(stderr, "conv=Unknown conv.");
					break;
		}

		fprintf(stderr, "Repeat=%d  ", p[3]);
d1020 51
a1070 52
		switch (p[4]) {
		case IPU_GAMMA_STANDARD: fprintf(stderr, "gamma=std  ");
					break;
		case IPU_GAMMA_RGB: fprintf(stderr, "gamma=rgb  ");
					break;
		case IPU_GAMMA_CG: fprintf(stderr, "gamma=cg  ");
					break;
		default: fprintf(stderr, "Unknown gamma  ");
					break;
		}

		switch (p[5]) {
		case IPU_UPPER_CASSETTE : fprintf(stderr, "tray=upper\n");
			break;
		case IPU_LOWER_CASSETTE : fprintf(stderr, "tray=lower\n");
			break;
		case IPU_MANUAL_FEED : fprintf(stderr, "tray=Manual_Feed\n");
			break;
		default: fprintf(stderr, "tray=Unknown (%d)\n", p[5]);
			break;
		}

		fprintf(stderr, "Upper cassette paper=");
		switch (p[6]) {
		case 0x6: fputs("A3  ", stderr); break;
		case 0x8: fputs("A4R  ", stderr); break;
		case 0x18: fputs("B4  ", stderr); break;
		case 0x1a: fputs("B5R  ", stderr); break;
		case 0x28: fputs("A4  ", stderr); break;
		case 0x46: fputs("11\"x17\"  ", stderr); break;
		case 0x48: fputs("Letter R  ", stderr); break;
		case 0x58: fputs("Legal  ", stderr); break;
		case 0x68: fputs("Letter  ", stderr); break;
		case 0x80: fputs("Manual Feed  ", stderr); break;
		case 0xff: fputs("No cassette  ", stderr); break;
		default : fputs("unknown  ", stderr); break;
		}
		fprintf(stderr, "Lower cassette paper=");
		switch (p[7]) {
		case 0x6: fputs("A3\n", stderr); break;
		case 0x8: fputs("A4R\n", stderr); break;
		case 0x18: fputs("B4\n", stderr); break;
		case 0x1a: fputs("B5R\n", stderr); break;
		case 0x28: fputs("A4\n", stderr); break;
		case 0x46: fputs("11\"x17\"\n", stderr); break;
		case 0x48: fputs("Letter R\n", stderr); break;
		case 0x58: fputs("Legal\n", stderr); break;
		case 0x68: fputs("Letter\n", stderr); break;
		case 0x80: fputs("Manual Feed\n", stderr); break;
		case 0xff: fputs("No cassette\n", stderr); break;
		default : fputs("unknown\n", stderr); break;
		}
d1072 2
a1073 1
	return 0;
d1079 27
a1105 27
	register u_char *p;
	static u_char params[65535];
	int i;

	if (ipu_debug) fprintf(stderr, "ipu_config_printer()\n");

	bzero(p=(u_char *)CMDBUF(dsp), 16);
	p[0] = 0x5a;			/* mode sense */
	p[2] = 0x23;
	toint(&p[7], (int)sizeof(params));
	CMDLEN(dsp) = 10;

	bzero(params, sizeof(params));
	filldsreq(dsp, params, sizeof(params), DSRQ_READ|DSRQ_SENSE);

	if ((i=doscsireq(getfd(dsp), dsp)) == -1) {
		fprintf(stderr, "Error reading IPU configuration.\n");
		scsi_perror(i, dsp);
		exit(-1);;
	}

	(void)fprintf(stderr, "Sense Data Length %u\n",
		((unsigned)params[0] << 8) + params[1]);

	(void)fprintf(stderr, "Block Descriptor Length %u\n",
		((unsigned)params[6] << 8) + params[7]);
	return 0;
d1120 2
a1121 2
struct dsreq	*dsp;
unsigned char	*cmap;		/* NULL or [768] */
d1123 30
a1152 16
	register caddr_t p;
	unsigned char	linear[768];
	int		i;
	int		ret;

	if (ipu_debug) fprintf(stderr, "ipu_set_palette(cmap=x%lx)\n", (long)cmap);
	if( cmap == NULL )  {
		register int	j;
		register unsigned char *cp = linear;
		for( j=0; j < 256; j++ )  {
			*cp++ = j;
			*cp++ = j;
			*cp++ = j;
		}
		cmap = linear;
	}
d1154 11
a1164 26
	/* The Palette has to be sent in 4 parts */
	for( i=0; i < 4; i++ )  {
		unsigned char	buf[4+2+192];

		bzero(p=CMDBUF(dsp), 16);
		p[0] = 0x15;		/* MODE SELECT, Group code 0 (6 byte) */
		/* Lun 0=scanner, Lun 3=printer */
		p[1] = (3<<5) | 0x10;	/* Lun, PF=1 (page format) */
		p[4] = sizeof(buf);
		CMDLEN(dsp) = 6;

		/* buf[0]:  Parameter header, 4 bytes long. */
		toint( buf, 192+2 );

		/* buf[4]: MODE PARAMETERS, block(s) of page codes. */
		buf[4] = 0x30 + i;	/* PAGE CODE "Color Palette Parameters" */
		buf[5] = 0xC0;		/* 192 bytes follow */
		bcopy( cmap+i*192, buf+4+2, 192 );

		filldsreq(dsp, buf, sizeof(buf), DSRQ_WRITE|DSRQ_SENSE);

		if ( ret=doscsireq(getfd(dsp), dsp) )  {
			fprintf(stderr, "ipu_set_palette(%d) failed\n", i);
			scsi_perror(ret, dsp);
			exit(-1);
		}
d1166 1
d1209 1
a1209 1
char *s;
d1211 1
a1211 1
	if (s) (void)fputs(s, stderr);
d1213 2
a1214 2
	(void) fprintf(stderr, "Usage: %s [options] [pixfile]\nOptions:\n%s", progname, 
"	[-h] [-n scanlines] [-w width] [-s squareimagesize]\n\
d1224 1
a1224 1
	exit(1);
d1231 2
a1232 2
int ac;
char *av[];
d1234 2
a1235 2
	int  c;
	char *p;
d1237 89
a1325 2
	if (  ! (progname=strrchr(*av, '/'))  )
		progname = *av;
d1327 86
a1412 174
		++progname;

	strcpy(arg_buf, progname);
	len = strlen(arg_buf) + 1;
	arg_v[arg_c = 0] = arg_buf;
	arg_v[++arg_c] = (char *)NULL;

	/* Turn off getopt's error messages */
	opterr = 0;

	/* get all the option flags from the command line */
	while ((c=getopt(ac,av,options)) != EOF) {
		/* slup off a printer queue name */
		if (c == 'q' ||  c == 'p') {
			print_queue = optarg;
			continue;
		}

		/* add option & arg to arg_v */
		if (p=strchr(options, c)) {
			arg_v[arg_c++] = &arg_buf[len];
			arg_v[arg_c] = (char *)NULL;
			(void)sprintf(&arg_buf[len], "-%c", c);
			len += strlen(&arg_buf[len]) + 1;
			if (p[1] == ':') {
				arg_v[arg_c++] = &arg_buf[len];
				arg_v[arg_c] = (char *)NULL;
				(void)sprintf(&arg_buf[len], "%s", optarg);
				len += strlen(&arg_buf[len]) + 1;
			}
		}

		switch (c) {
		case 'a'	: autosize = !autosize; break;
		case 'c'	: clear = !clear; break;
		case 'd'	: if (isprint(*optarg)) {
					memset(scsi_device, 0, sizeof(scsi_device));
					strncpy(scsi_device,optarg,sizeof(scsi_device)-1);
				  } else
				  	usage("-d scsi_device_name\n");
				break;
		case 'g'	: if (*optarg == 's')
					ipu_gamma = IPU_GAMMA_STANDARD;
				   else if (*optarg == 'r')
					ipu_gamma = IPU_GAMMA_RGB;
				   else if (*optarg == 'c')
					ipu_gamma = IPU_GAMMA_CG;
				   else
				   	usage("-g {std|rgb|cg}\n");
				break;
		case 'h'	: width = height = 1024; break;
		case 'm'	: mosaic = !mosaic; break;
		case 'n'	: if ((c=atoi(optarg)) > 0)
					height = c;
				  else
				  	usage("-n scanlines\n");
				  break;
		case 's'	: if ((c=atoi(optarg)) > 0)
					width = height = c;
				  else
				  	usage("-s squareimagesize\n");
				  break;
		case 'w'	: if ((c=atoi(optarg)) > 0)
					width = c;
				  else
				  	usage("-w imagewidth\n");
				  break;
		case 't'	:switch (*optarg) {
				case 'u'	:
				case 'U'	: tray = IPU_UPPER_CASSETTE;
						break;
				case 'l'	:
				case 'L'	: tray = IPU_LOWER_CASSETTE;
						break;
				case 'm'	:
				case 'M'	: tray = IPU_MANUAL_FEED;
						break;
				default:
					usage("-t {u|l|m}\n");
					break;
				}
				break;
		case 'U'	: if (*optarg == 'i')
					units = IPU_UNITS_INCH;
				  else if (*optarg == 'm')
				  	units = IPU_UNITS_MM;
				  else
				  	usage("invalid units\n");
				break;
		case 'z'	: zoom = !zoom;
				scr_width= scr_height= scr_xoff= scr_yoff= 0;
				break;
		case 'A'	: conv = IPU_AUTOSCALE;
				  bzero( (char *)&param, sizeof(union ipu_prsc_param));
				  break;
		case 'M'	: conv = IPU_MAG_FACTOR;
				  if ((c=atoi(optarg)) < 100 || c > 2000)
				  	usage("X Mag factor out of range 100-2000\n");
				  param.s[0] = c & 0x0ffff;
				  while (*optarg && *optarg++ != ':')
					;
				  if ((c = atoi(optarg)) < 100 || c > 2000)
				  	usage("Y Mag factor out of range 100-2000\n");
				  param.s[1] = c & 0x0ffff;
				  break;
		case 'R'	: if ((c=atoi(optarg)) > 0) {
					param.i = c;
					conv = IPU_RESOLUTION;
				} else {
					fprintf(stderr,
						"Resolution error (%d)\n",c);
					exit(-1);
				}
				if (ipu_debug)
					fprintf(stderr,
					"Res: %d 0%02x 0%02x 0%02x 0%02x\n",
					c, param.c[0], param.c[1], param.c[2],
					param.c[3]);
				break;
		case 'C'	: if ((c=atoi(optarg)) > 0 && c < 99)
					copies = c;
				else
					usage("-C [1-99]\n");
				break;
		case 'D'	: if ((c=atoi(optarg)) > 0)
					divisor = c;
				else
					usage("-D divisor\n");
				break;
		case 'N'	: if ((c=atoi(optarg)) > 0)
					scr_height = c;
				else
					usage("-N outputlines\n");
				break;
		case 'S'	: if ((c=atoi(optarg)) > 0)
					scr_width = scr_height = c;
				else
					usage("-S outputsquaresize\n");
				break;
		case 'W'	: if ((c=atoi(optarg)) > 0)
					scr_width = c;
				else
					usage("-W outputwidth\n");
				break;
		case 'X'	: if ((c=atoi(optarg)) >= 0)
					scr_xoff = c;
				else
					usage("-X pageXoffset\n");
				break;
		case 'Y'	: if ((c=atoi(optarg)) >= 0)
					scr_yoff = c;
				else
					usage("-X pageYoffset\n");
				break;
		case 'V'	: dsdebug = ! dsdebug;
		case 'v'	: ipu_debug = !ipu_debug; break;
		case '#'	: c = atoi(optarg);
				switch(c)  {
				case 3:
					ipu_filetype = IPU_RGB_FILE;
					ipu_bytes_per_pixel = 3;
					break;
				case 1:
					ipu_filetype = IPU_PALETTE_FILE;
					ipu_bytes_per_pixel = 1;
					break;
				default:
					fprintf(stderr, "Bad value %d for bytes_per_pixel\n", c);
					break;
				}
				break;
		case '?'	:
		default		: fprintf(stderr, "Bad or help flag specified '%c'\n", c); break;
		}
d1414 2
a1415 1
	return(optind);
@


14.5
log
@tidy up a lil bit
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/canon/canonlib.c,v 14.4 2004/12/21 07:18:57 morrison Exp $ (ARL)";
@


14.4
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/canon/canonlib.c,v 14.3 2004/12/18 06:50:50 morrison Exp $ (ARL)";
a810 2
 *
 *
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@a30 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d33 1
a33 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/canon/canonlib.c,v 14.2 2004/12/18 02:15:32 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file canonlib.c
d35 1
a35 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/canon/canonlib.c,v 14.1 2004/11/16 19:42:12 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			C A N O N L I B . C
d34 1
a34 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/canon/canonlib.c,v 1.4 2004/09/03 23:30:56 morrison Exp $ (ARL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/canon/canonlib.c,v 1.3 2004/08/25 14:43:21 erikg Exp $ (ARL)";
d1401 10
@


1.3
log
@was expecting an extern int 'dsdebug' from some libds.a that I cannot find...
changed it to a local int to avoid compilation failures...
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/canon/canonlib.c,v 1.2 2004/08/02 23:01:47 morrison Exp $ (ARL)";
a19 2


d28 1
a28 1
#ifdef USE_STRING_H
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/canon/canonlib.c,v 1.1 2004/05/20 15:18:46 morrison Exp $ (ARL)";
d46 4
a49 1
extern int dsdebug;		/* from libds.a */
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d15 1
a15 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/canon/canonlib.c,v 11.10 2004/05/10 15:30:41 erikg Exp $ (ARL)";
d18 1
a18 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

