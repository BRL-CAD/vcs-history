head	14.9;
access;
symbols
	stable-branch:14.5
	rel-7-8-2:14.8
	rel-7-8-0:14.8
	trimnurbs-branch:14.8.0.2
	help:14.8
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.7
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.6
	rel-7-6-0:14.6
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.4
	bobWinPort:14.6.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.5
	rel-7-2-4:14.5
	rel-7-2-2:14.5
	rel-7-2-0:14.5
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.1
	rel-7-0-branch:1.1.0.2
	rel-7-0:1.1;
locks; strict;
comment	@ * @;


14.9
date	2006.07.02.19.05.10;	author brlcad;	state dead;
branches;
next	14.8;

14.8
date	2006.01.18.06.46.13;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.29;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.06.15.04.34.52;	author brlcad;	state Exp;
branches
	14.6.6.1;
next	14.5;

14.5
date	2005.02.14.04.43.07;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.30.18;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.18.06.50.50;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.02.15.32;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.12;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.18.46;	author morrison;	state Exp;
branches;
next	;

14.6.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.9
log
@removed the canonserver target, the sources for this binary are dependent upon headers and libraries that are not evidently available; similarly it hasn't been compiled/distributed since at least the new build system has been in place.
@
text
@/*                   C A N O N S E R V E R . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2006 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file canonserver.c
 *
 * MDQS interface for Canon CLC500 on SGI SCSI bus
 *
 *	Options
 *	h	help
 */
#include <stdio.h>
#include <ctype.h>
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif

#include "queue.h"
#include "qreplys.h"

#define DEBUG
extern char	*Qdatadir;	/* queue file directory name */
static int  lpoptions = 0;	/* line-printer style options */
static char *progname = "(noname)";

static char ipu_prog[64] = "/usr/brlcad/bin/pix-ipu";

int
print(file, copies)
     char *file;
     int copies;
{
#define MAXARGS 200
    char *argv[MAXARGS];
    int argc;
    char linebuf[1024];
    char *p;
    pid_t pid, rpid;
    int retcode;

#ifdef DEBUG
    (void)fprintf(stderr, "Printing %d copies of \"%s\"\n", copies, file);
    (void)fflush(stderr);
#endif
    if ((pid = fork()) == 0) {
	/* child */
	(void)close(3);
	(void)close(4);

	/* open the data file */
	if (freopen(file, "r", stdin) == (FILE *)NULL)
	    exit(2000);

	/* read command line arguments from head of data file */
	fgets(linebuf, sizeof(linebuf)-1, stdin);
	if ( *(p = &linebuf[strlen(linebuf)-1]) == '\n')
	    *p = '\0';

	/* create argv for exec() */
	argc = 1;
	p = linebuf;

	if (strncmp(p, "CLC500", 6)) {
	    fprintf(stderr, "Bad Magic number in image request\n");
	    retmsg( RP_FATAL, "Bad Magic number in image request\n");
	    exit( 10 );
	}
	p += 6;

	while (*p && argc < MAXARGS-1) {
	    /* skip initial white space */
	    while (*p && isascii(*p) && isspace(*p))
		p++;

	    argv[argc++] = p;

	    /* find the end of a word */
	    while (*p && isascii(*p) && !isspace(*p))
		p++;

	    *p++ = '\0';
	}
	argv[argc] = (char *)NULL;
	argv[0] = "pix-ipu";

#ifdef DEBUG
	fprintf(stderr,
		"execl(\"%s\") ", ipu_prog);

	for (argc=0 ; argv[argc] != (char *)NULL ; argc++)
	    fprintf(stderr, ", \"%s\"", argv[argc]);

	fprintf(stderr, ")\n");
	fflush(stderr);
#endif

	/* hack the kernel's idea of my file pointer to be at
	 * the begining of the image data
	 */
	lseek(fileno(stdin), ftell(stdin), 0);

	execv(ipu_prog, argv);
	perror(ipu_prog);
	exit(16);
    }

    while ((rpid = wait(&retcode)) != pid && rpid != -1)
	;

    return(retcode);
}


/*
 *	M A I N
 *
 *	Call parse_args to handle command line arguments first, then
 *	process input.
 */
int main(ac,av)
     int ac;
     char *av[];
{
    int arg_index;
    int c;
    char ans='\0';
    char	linebuf[LINESIZ];
    char	filename[LINESIZ];
    struct request r;


#ifdef DEBUG
    (void)freopen("/tmp/canonlog", "a", stderr);
#endif
    if (gethdr( stdin, &r ) == NULL ) {
	(void)fprintf(stderr, "%s: \"%s\"\n", progname,
		      "error reading request header");
	retmsg( RP_FATAL, "error reading request header");
	exit( 10 );
    }
    while ( fgets( linebuf, (int)sizeof linebuf, stdin ) != NULL ) {
	register char *cp;

	if ( *(cp = &linebuf[strlen( linebuf ) - 1]) == '\n' )
	    *cp = '\0';

	cp = &linebuf[0];
#ifdef DEBUG
	fprintf(stderr, "%s\n", cp);
#endif
	switch ( *cp++ ) {
	case 'B' :	/* ignore and remove banner */
	    filename[sizeof(filename)-1] = '\0';
	    strncpy(filename, Qdatadir, sizeof(filename)-1);
	    strncat(filename, cp,
		    sizeof(filename)-strlen(filename)-1);

	    if ( unlink(filename) != 0 )
		(void)fprintf(stderr,
			      "couldn't unlink banner \"%s\"\n",
			      filename);
	    break;
	case 'D' :	/* change working directory */
	    if ( chdir( cp ) != 0 ) {
		(void)fprintf(stderr,
			      "%s: chdir error\n", progname);
		(void)chdir( "/tmp" );	/* safe */
	    }
	    break;
	case 'F' :	/* print user file */
	    if (print(cp, r.r_copies)
		&& lpoptions & NOKEEP
		&& unlink( cp ) ) {
		fprintf(stderr,
			"couldn't unlink data file \"%s\"\n",
			cp);
	    }
	    break;
	case 'I':		/* print spooled file */
	    filename[sizeof(filename)-1] = '\0';
	    strncpy(filename, Qdatadir, sizeof(filename)-1);
	    strncat(filename, cp,
		    sizeof(filename)-strlen(filename)-1);

	    print(filename, r.r_copies);
	    if ( unlink( filename ) != 0 )
		fprintf(stderr,
			"couldn't unlink spooled file \"%s\"\n",
			filename );
	    break;
	case 'O':		/* line-printer style options */
	    lpoptions |= atoi( cp );
	    break;
	case 'X':		/* extended options */
	case 'U':		/* user name */
	case 'H':		/* print header */
	case 'T':		/* title */
	default:		/* ignore unknown controls */
	    break;
	}
    }

    retmsg( RP_OK, (char *)0 );

    return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.8
log
@update copyright to 2006
@
text
@@


14.7
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


14.6
log
@protect the sys/wait.h headers with HAVE_SYS_WAIT_H since not all systems (e.g. mingw) have it.
@
text
@d160 1
a160 1
		
d192 1
a192 1
			"couldn't unlink data file \"%s\"\n", 
@


14.6.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d160 1
a160 1

d192 1
a192 1
			"couldn't unlink data file \"%s\"\n",
@


14.5
log
@M-x indent-region
@
text
@d31 3
a33 1
#include <sys/wait.h>
@


14.4
log
@update copyright to 2005
@
text
@d45 2
a46 2
char *file;
int copies;
d49 6
a54 6
	char *argv[MAXARGS];
	int argc;
	char linebuf[1024];
	char *p;
	pid_t pid, rpid;
	int retcode;
d57 2
a58 2
	(void)fprintf(stderr, "Printing %d copies of \"%s\"\n", copies, file);
	(void)fflush(stderr);
d60 40
a99 40
	if ((pid = fork()) == 0) {
		/* child */
		(void)close(3);
		(void)close(4);

		/* open the data file */
		if (freopen(file, "r", stdin) == (FILE *)NULL)
			exit(2000);

		/* read command line arguments from head of data file */
		fgets(linebuf, sizeof(linebuf)-1, stdin);
		if ( *(p = &linebuf[strlen(linebuf)-1]) == '\n')
			*p = '\0';

		/* create argv for exec() */
		argc = 1;
		p = linebuf;

		if (strncmp(p, "CLC500", 6)) {
			fprintf(stderr, "Bad Magic number in image request\n");
			retmsg( RP_FATAL, "Bad Magic number in image request\n");
			exit( 10 );
		}
		p += 6;

		while (*p && argc < MAXARGS-1) {
			/* skip initial white space */
			while (*p && isascii(*p) && isspace(*p))
				p++;

			argv[argc++] = p;

			/* find the end of a word */
			while (*p && isascii(*p) && !isspace(*p))
				p++;

			*p++ = '\0';
		}
		argv[argc] = (char *)NULL;
		argv[0] = "pix-ipu";
d102 2
a103 2
		fprintf(stderr,
			"execl(\"%s\") ", ipu_prog);
d105 2
a106 2
		for (argc=0 ; argv[argc] != (char *)NULL ; argc++)
			fprintf(stderr, ", \"%s\"", argv[argc]);
d108 2
a109 2
		fprintf(stderr, ")\n");
		fflush(stderr);
d112 9
a120 9
		/* hack the kernel's idea of my file pointer to be at
		 * the begining of the image data
		 */
		lseek(fileno(stdin), ftell(stdin), 0);

		execv(ipu_prog, argv);
		perror(ipu_prog);
		exit(16);
	}
d122 2
a123 2
	while ((rpid = wait(&retcode)) != pid && rpid != -1)
		;
d125 1
a125 1
	return(retcode);
d136 2
a137 2
int ac;
char *av[];
d139 6
a144 6
	int arg_index;
	int c;
	char ans='\0';
	char	linebuf[LINESIZ];
	char	filename[LINESIZ];
	struct request r;
d148 1
a148 1
	(void)freopen("/tmp/canonlog", "a", stderr);
d150 8
a157 8
	if (gethdr( stdin, &r ) == NULL ) {
		(void)fprintf(stderr, "%s: \"%s\"\n", progname,
			"error reading request header");
		retmsg( RP_FATAL, "error reading request header");
		exit( 10 );
	}
	while ( fgets( linebuf, (int)sizeof linebuf, stdin ) != NULL ) {
		register char *cp;
d159 2
a160 2
		if ( *(cp = &linebuf[strlen( linebuf ) - 1]) == '\n' )
			*cp = '\0';
d162 1
a162 1
		cp = &linebuf[0];
d164 1
a164 1
		fprintf(stderr, "%s\n", cp);
d166 49
a214 50
		switch ( *cp++ ) {
		case 'B' :	/* ignore and remove banner */
			filename[sizeof(filename)-1] = '\0';
			strncpy(filename, Qdatadir, sizeof(filename)-1);
			strncat(filename, cp,
				sizeof(filename)-strlen(filename)-1);

			if ( unlink(filename) != 0 )
				(void)fprintf(stderr,
					"couldn't unlink banner \"%s\"\n",
					filename);
			break;
		case 'D' :	/* change working directory */
			if ( chdir( cp ) != 0 ) {
				(void)fprintf(stderr,
					"%s: chdir error\n", progname);
				(void)chdir( "/tmp" );	/* safe */
			}
			break;
		case 'F' :	/* print user file */
			if (print(cp, r.r_copies)
			    && lpoptions & NOKEEP
			    && unlink( cp ) ) {
				fprintf(stderr,
					"couldn't unlink data file \"%s\"\n", 
					cp);
			}
			break;
		case 'I':		/* print spooled file */
			filename[sizeof(filename)-1] = '\0';
			strncpy(filename, Qdatadir, sizeof(filename)-1);
			strncat(filename, cp,
				sizeof(filename)-strlen(filename)-1);

			print(filename, r.r_copies);
			if ( unlink( filename ) != 0 )
				fprintf(stderr,
				    "couldn't unlink spooled file \"%s\"\n",
				    filename );
			break;
		case 'O':		/* line-printer style options */
			lpoptions |= atoi( cp );
			break;
		case 'X':		/* extended options */
		case 'U':		/* user name */
		case 'H':		/* print header */
		case 'T':		/* title */
		default:		/* ignore unknown controls */
			break;
		}
d216 1
d218 1
a218 1
	retmsg( RP_OK, (char *)0 );
d220 1
a220 1
	return 0;
@


14.3
log
@break up the doxygen marker to appease emacs M-x indent-region'ing
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
@


14.2
log
@assign copyright and GPL license
@
text
@d21 2
a22 1
 **//** @@file canonserver.c
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 23
a23 1
/*	Canonserver.c --- MDQS interface for Canon CLC500 on SGI SCSI bus
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d199 10
@

