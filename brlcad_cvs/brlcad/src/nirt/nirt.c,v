head	14.24;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.3
	rel-7-10-2:14.16
	rel-7-10-0:14.14
	rel-7-8-4:14.11
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.7
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.6
	rel-7-6-0:14.6
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.4
	bobWinPort:14.6.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.4
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.24
date	2007.12.18.00.13.09;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.12.17.23.05.47;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.12.02.22.34.23;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.11.21.20.49.10;	author erikgreenwald;	state Exp;
branches;
next	14.20;

14.20
date	2007.11.21.20.38.23;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.11.21.19.49.12;	author erikgreenwald;	state Exp;
branches;
next	14.18;

14.18
date	2007.11.08.04.15.47;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.18;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.04.18.04.03.56;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.04.17.01.30.21;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.44;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.44;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.58;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.07.09.19.17.16;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.02.27.10.08.40;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.12.08.01.34.59;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.06.30.00.17.45;	author erikgreenwald;	state Exp;
branches
	14.6.6.1;
next	14.5;

14.5
date	2005.06.24.19.00.21;	author bob1961;	state Exp;
branches;
next	14.4;

14.4
date	2005.05.28.02.14.54;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.31.08;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.02.40.25;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.16.04.56.41;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.59;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.30;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.34;	author morrison;	state Exp;
branches;
next	;

14.6.6.1
date	2005.11.13.13.46.18;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.24
log
@say it's natalie's
@
text
@/*                          N I R T . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file nirt.c
 *
 * This program is Natalie's Interactive Ray-Tracer
 *
 * Author:
 *   Natalie L. Barker
 *
 * Date:
 *   Jan 90
 *
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"

/* private */
#include "./nirt.h"
#include "./usrfmt.h"
#include "brlcad_version.h"


extern void	cm_libdebug();
extern void	cm_debug();
extern void	cm_attr();


char	usage[] = "\
Usage: 'nirt [options] model.g objects...'\n\
Options:\n\
 -b        back out of geometry before first shot\n\
 -B n      set rt_bot_minpieces=n\n\
 -e script run script before interacting\n\
 -f sfile  run script sfile before interacting\n\
 -M        read matrix, cmds on stdin\n\
 -O action handle overlap claims via action\n\
 -s        run in short (non-verbose) mode\n\
 -u n      set use_air=n (default 0)\n\
 -v        run in verbose mode\n\
 -x v      set librt(3) diagnostic flag=v\n\
 -X v      set nirt diagnostic flag=v\n\
";

char		*db_name;	/* the name of the BRL-CAD geometry file */
com_table	ComTab[] = {
    { "attr", cm_attr, "select attributes", "<-f(flush) | -p(print) | attribute_name>" },
    { "ae", az_el, "set/query azimuth and elevation",
      "azimuth elevation" },
    { "dir", dir_vect, "set/query direction vector",
      "x-component y-component z-component" },
    { "hv", grid_coor, "set/query gridplane coordinates",
      "horz vert [dist]" },
    { "xyz", target_coor, "set/query target coordinates",
      "X Y Z" },
    { "s", shoot, "shoot a ray at the target" },
    { "backout", backout, "back out of model" },
    { "useair", use_air, "set/query use of air",
      "<0|1|2|...>" },
    { "units", nirt_units, "set/query local units",
      "<mm|cm|m|in|ft>" },
    { "overlap_claims", do_overlap_claims,
      "set/query overlap rebuilding/retention",
      "<0|1|2|3>" },
    { "fmt", format_output, "set/query output formats",
      "{rhpfmo} format item item ..." },
    { "dest", direct_output, "set/query output destination",
      "file/pipe" },
    { "statefile", state_file,
      "set/query name of state file", "file" },
    { "dump", dump_state,
      "write current state of NIRT to the state file" },
    { "load", load_state,
      "read new state for NIRT from the state file" },
    { "print", print_item, "query an output item",
      "item" },
    { "bot_minpieces", bot_minpieces,
      "Get/Set value for rt_bot_minpieces (0 means do not use pieces, default is 32)",
      "min_pieces" },
    { "libdebug", cm_libdebug,
      "set/query librt debug flags", "hex_flag_value" },
    { "debug", cm_debug,
      "set/query nirt debug flags", "hex_flag_value" },
    { "!", sh_esc, "escape to the shell" },
    { "q", quit, "quit" },
    { "?", show_menu, "display this help menu" },
    { (char *)NULL, NULL, (char *)NULL, (char *)NULL }
};


struct script_rec
{
    struct bu_list	l;
    int			sr_type;	/* Direct or indirect */
    struct bu_vls	sr_script;	/* Literal or file name */
};
#define	SCRIPT_REC_NULL	((struct script_rec *) 0)
#define SCRIPT_REC_MAGIC	0x73637270
#define	sr_magic		l.magic


int		do_backout = 0;			/* Backout before shooting? */
int		overlap_claims = OVLP_RESOLVE;	/* Rebuild/retain overlaps? */
char		*ocname[4];
int		silent_flag = SILENT_UNSET;	/* Refrain from babbling? */
int		nirt_debug = 0;			/* Control of diagnostics */

/* Parallel structures needed for operation w/ and w/o air */
struct rt_i		*rti_tab[2];
struct rt_i		*rtip;
struct resource		res_tab;

struct application	ap;

int need_prep = 1;
attr_table a_tab;


void printusage(void)
{
    bu_log("%s", usage);
}


void
attrib_print(void)
{
    int i;

    for (i=0 ; i < a_tab.attrib_use ; i++) {
	bu_log("\"%s\"\n", a_tab.attrib[i]);
    }
}


/**
 * flush the list of desired attributes
 */
void
attrib_flush(void)
{
    int i;

    a_tab.attrib_use = 0;
    for (i=0 ; i < a_tab.attrib_use; i++ )
	bu_free(a_tab.attrib[i], "strdup");
}


void
attrib_add(char *a)
{
    char *p;

    if (!a) {
	bu_log("attrib_add null arg\n");
	return; /* null char ptr */
    }

    p = strtok(a, "\t ");
    while (p) {

	/* make sure we have space */
	if (!a_tab.attrib || a_tab.attrib_use >= (a_tab.attrib_cnt-1)) {
	    a_tab.attrib_cnt += 16;
	    a_tab.attrib = bu_realloc(a_tab.attrib,
				      a_tab.attrib_cnt * sizeof(char *),
				      "attrib_tab");
	}

	/* add the attribute name(s) */
	a_tab.attrib[a_tab.attrib_use] = bu_strdup(p);
	/* bu_log("attrib[%d]=\"%s\"\n", attrib_use, attrib[attrib_use]); */
	a_tab.attrib[++a_tab.attrib_use] = (char *)NULL;

	p = strtok((char *)NULL, "\t ");
	need_prep = 1;
    }
}



/**
 * string is a literal or a file name
 */
static void enqueue_script (struct bu_list *qp, int type, char *string)
{
    struct script_rec	*srp;

    BU_CK_LIST_HEAD(qp);

    srp = (struct script_rec *)
	    bu_malloc(sizeof(struct script_rec), "script record");
    srp->sr_magic = SCRIPT_REC_MAGIC;
    srp->sr_type = type;
    bu_vls_init(&(srp->sr_script));
    bu_vls_strcat(&(srp->sr_script), string);

    BU_LIST_INSERT(qp, &(srp->l));
}


/**
 * text is for the title line
 */
static void show_scripts (struct bu_list *sl, char *text)
{
    int			i;
    struct script_rec	*srp;

    BU_CK_LIST_HEAD(sl);

    i = 0;
    bu_log("- - - - - - - The command-line scripts %s\n");
    for (BU_LIST_FOR(srp, script_rec, sl)) {
	BU_CKMAG(srp, SCRIPT_REC_MAGIC, "script record");

	bu_log("%d. script %s '%s'\n",
	    ++i,
	    (srp->sr_type == READING_STRING) ? "string" :
	    (srp->sr_type == READING_FILE) ? "file" : "???",
	    bu_vls_addr(&(srp->sr_script)));
    }
    bu_log("- - - - - - - - - - - - - - - - - - - - - - - - - -\n");
}


static void free_script (struct script_rec *srp)
{
    BU_CKMAG(srp, SCRIPT_REC_MAGIC, "script record");

    bu_vls_free(&(srp->sr_script));
    bu_free((genptr_t) srp, "script record");
}


static void run_scripts (struct bu_list *sl)
{
    struct script_rec	*srp;
    char		*cp;
    FILE		*fPtr;

    if (nirt_debug & DEBUG_SCRIPTS)
	show_scripts(sl, "before running them");

    while (BU_LIST_WHILE(srp, script_rec, sl)) {
	BU_LIST_DEQUEUE(&(srp->l));
	BU_CKMAG(srp, SCRIPT_REC_MAGIC, "script record");
	cp = bu_vls_addr(&(srp->sr_script));

	if (nirt_debug & DEBUG_SCRIPTS) {
	    bu_log("  Attempting to run %s '%s'\n",
		   (srp->sr_type == READING_STRING) ? "literal" :
		   (srp->sr_type == READING_FILE) ? "file" : "???",
		   cp);
	}

	switch (srp->sr_type) {
	case READING_STRING:
	    interact(READING_STRING, cp);
	    break;
	case READING_FILE:
	    if ((fPtr = fopen(cp, "r")) == NULL) {
		bu_log("Cannot open script file '%s'\n", cp);
	    } else {
		interact(READING_FILE, fPtr);
		fclose(fPtr);
	    }
	    break;
	default:
	    bu_exit (1, "%s:%d: script of type %d.  This shouldn't happen\n", __FILE__, __LINE__, srp->sr_type);
	}
	free_script(srp);
    }

    if (nirt_debug & DEBUG_SCRIPTS)
	show_scripts(sl, "after running them");
}


int
main (int argc, char **argv)
{
    char                db_title[TITLE_LEN+1];/* title from MGED file      */
    const char		*tmp_str;
    extern char		local_u_name[];
    extern double	base2local;
    extern double	local2base;
    FILE		*fPtr;
    int			Ch;		/* Option name */
    int			mat_flag = 0;	/* Read matrix from stdin? */
    int			use_of_air = 0;
    char		ocastring[1024] = {0};
    struct bu_list	script_list;	/* For -e and -f options */
    struct script_rec	*srp;
    extern outval	ValTab[];

    /* FUNCTIONS */
    void                   do_rt_gettrees(struct rt_i *rtip, char **object_name, int nm_objects);
    void		   grid2targ(void);
    void		   targ2grid(void);
    void		   ae2dir(void);
    void		   dir2ae(void);
    void	           set_diameter(struct rt_i *rtip);
    int	           	   str_dbl(char *buf, double *Result);
    void		   az_el();
    void		   sh_esc();
    void		   grid_coor();
    void		   target_coor();
    void		   dir_vect();
    void		   backout();
    void		   quit();
    void		   show_menu();
    void		   print_item(char *buffer, com_table *ctp);
    void		   shoot();

    /* callback functions for overlap, hit, and miss shots */
    int                    if_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *InputHdp);
    int             	   if_hit(struct application *ap, struct partition *part_head, struct seg *finished_segs);
    int             	   if_miss(struct application *ap);

#ifdef _WIN32
    _setmode(_fileno(stdin), _O_BINARY);
    _setmode(_fileno(stdout), _O_BINARY);
    _setmode(_fileno(stderr), _O_BINARY);
#endif

    BU_LIST_INIT(&script_list);

    ocname[OVLP_RESOLVE] = "resolve";
    ocname[OVLP_REBUILD_FASTGEN] = "rebuild_fastgen";
    ocname[OVLP_REBUILD_ALL] = "rebuild_all";
    ocname[OVLP_RETAIN] = "retain";
    *ocastring = '\0';

    bu_optind = 1;		/* restart */

    /* Handle command-line options */
    while ((Ch = bu_getopt(argc, argv, OPT_STRING)) != EOF) {
	switch (Ch) {
	case 'A':
	    attrib_add(bu_optarg);
	    break;
	case 'B':
	    rt_bot_minpieces = atoi( bu_optarg );
	    break;
	case 'b':
	    do_backout = 1;
	    break;
	case 'E':
	    if (nirt_debug & DEBUG_SCRIPTS)
		show_scripts(&script_list, "before erasure");
	    while (BU_LIST_WHILE(srp, script_rec, &script_list)) {
		BU_LIST_DEQUEUE(&(srp->l));
		free_script(srp);
	    }
	    if (nirt_debug & DEBUG_SCRIPTS)
		show_scripts(&script_list, "after erasure");
	    break;
	case 'e':
	    enqueue_script(&script_list, READING_STRING, bu_optarg);
	    if (nirt_debug & DEBUG_SCRIPTS)
		show_scripts(&script_list, "after enqueueing a literal");
	    break;
	case 'f':
	    enqueue_script(&script_list, READING_FILE, bu_optarg);
	    if (nirt_debug & DEBUG_SCRIPTS)
		show_scripts(&script_list, "after enqueueing a file name");
	    break;
	case 'M':
	    mat_flag = 1;
	    break;
	case 'O':
	    sscanf(bu_optarg, "%1024s", ocastring);
	    break;
	case 's':
	    silent_flag = SILENT_YES;	/* Positively yes */
	    break;
	case 'v':
	    silent_flag = SILENT_NO;	/* Positively no */
	    break;
	case 'x':
	    sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
	    break;
	case 'X':
	    sscanf( bu_optarg, "%x", (unsigned int *)&nirt_debug );
	    break;
	case 'u':
	    if (sscanf(bu_optarg, "%d", &use_of_air) != 1) {
		(void) fprintf(stderr,
			       "Illegal use-air specification: '%s'\n", bu_optarg);
		return 1;
	    }
	    break;
	case '?':
	default:
	    printusage();
	    bu_exit (Ch != '?', NULL);
	}
    } /* end while getopt */

    if (argc - bu_optind < 2) {
	printusage();
	return 1;
    }

    if (isatty(0)) {
	if (silent_flag != SILENT_YES)
	    silent_flag = SILENT_NO;
    } else {
	/* stdin is not a TTY */
	if (silent_flag != SILENT_NO)
	    silent_flag = SILENT_YES;
    }
    if (silent_flag != SILENT_YES)
	(void) fputs(brlcad_ident("Natalie's Interactive Ray Tracer"), stdout);

    if (use_of_air && (use_of_air != 1)) {
	fprintf(stderr,
		"Warning: useair=%d specified, will set to 1\n", use_of_air);
	use_of_air = 1;
    }

    switch (*ocastring) {
    case '\0':
	overlap_claims = OVLP_RESOLVE;
	break;
    case '0':
    case '1':
    case '2':
    case '3':
	if (ocastring[1] == '\0') {
	    sscanf(ocastring, "%d", &overlap_claims);
	} else {
	    fprintf(stderr,
		    "Illegal overlap_claims specification: '%s'\n", ocastring);
	    return 1;
	}
	break;
    case 'r':
	if (strcmp(ocastring, "resolve") == 0)
	    overlap_claims = OVLP_RESOLVE;
	else if (strcmp(ocastring, "rebuild_fastgen") == 0)
	    overlap_claims = OVLP_REBUILD_FASTGEN;
	else if (strcmp(ocastring, "rebuild_all") == 0)
	    overlap_claims = OVLP_REBUILD_ALL;
	else if (strcmp(ocastring, "retain") == 0)
	    overlap_claims = OVLP_RETAIN;
	else {
	    fprintf(stderr,
		    "Illegal overlap_claims specification: '%s'\n", ocastring);
	    return 1;
	}
	break;
    default:
	fprintf(stderr,
		"Illegal overlap_claims specification: '%s'\n", ocastring);
	return 1;
    }

    db_name = argv[bu_optind];

    /* build directory for target object */
    if (silent_flag != SILENT_YES) {
	printf("Database file:  '%s'\n", db_name);
	printf("Building the directory...");
    }
    if ((rtip = rt_dirbuild( db_name , db_title, TITLE_LEN )) == RTI_NULL) {
	fflush(stdout);
	fprintf(stderr, "Could not load file %s\n", db_name);
	return 1;
    }

    rti_tab[use_of_air] = rtip;
    rti_tab[1 - use_of_air] = RTI_NULL;
    rtip->useair = use_of_air;
    rtip->rti_save_overlaps = (overlap_claims > 0);

    ++bu_optind;
    do_rt_gettrees (rtip, argv + bu_optind, argc - bu_optind);

    /* Initialize the table of resource structures */
    rt_init_resource( &res_tab, 0, rtip );

    /* initialization of the application structure */
    RT_APPLICATION_INIT(&ap);
    ap.a_hit = if_hit;        /* branch to if_hit routine            */
    ap.a_miss = if_miss;      /* branch to if_miss routine           */
    ap.a_overlap = if_overlap;/* branch to if_overlap routine        */
    ap.a_logoverlap = rt_silent_logoverlap;
    ap.a_onehit = 0;          /* continue through shotline after hit */
    ap.a_resource = &res_tab;
    ap.a_purpose = "NIRT ray";
    ap.a_rt_i = rtip;         /* rt_i pointer                        */
    ap.a_zero1 = 0;           /* sanity check, sayth raytrace.h      */
    ap.a_zero2 = 0;           /* sanity check, sayth raytrace.h      */
    ap.a_uptr = (genptr_t)a_tab.attrib;

    /* initialize variables */
    azimuth() = 0.0;
    elevation() = 0.0;
    direct(X) = -1.0;
    direct(Y) = 0.0;
    direct(Z) = 0.0;
    grid(HORZ) = 0.0;
    grid(VERT) = 0.0;
    grid(DIST) = 0.0;
    grid2targ();
    set_diameter(rtip);

    /* initialize the output specification */
    default_ospec();

    /* initialize NIRT's local units */
    base2local = rtip->rti_dbip->dbi_base2local;
    local2base = rtip->rti_dbip->dbi_local2base;
    tmp_str = bu_units_string(local2base);
    if( tmp_str ) {
	    strncpy(local_u_name, bu_units_string(local2base), 64);
	    local_u_name[64] = '\0'; /* just in case, buf is 65 */
    } else {
	    strcpy( local_u_name, "Unknown units" );
    }

    if (silent_flag != SILENT_YES) {
	printf("Database title: '%s'\n", db_title);
	printf("Database units: '%s'\n", local_u_name);
	printf("model_min = (%g, %g, %g)    model_max = (%g, %g, %g)\n",
	       rtip->mdl_min[X] * base2local,
	       rtip->mdl_min[Y] * base2local,
	       rtip->mdl_min[Z] * base2local,
	       rtip->mdl_max[X] * base2local,
	       rtip->mdl_max[Y] * base2local,
	       rtip->mdl_max[Z] * base2local);
    }

    /* Run the run-time configuration file, if it exists */
    if ((fPtr = fopenrc()) != NULL) {
	interact(READING_FILE, fPtr);
	fclose(fPtr);
    }

    /*	Run all scripts specified on the command line */
    run_scripts(&script_list);

    /* Perform the user interface */
    if (mat_flag) {
	read_mat();
	return 0;
    } else {
	interact(READING_FILE, stdin);
    }

    return 0;
}


void
do_rt_gettrees (struct rt_i *rtip, char **object_name, int nm_objects)
{
    static char	**prev_names = 0;
    static int	prev_nm = 0;
    int i;

    if (object_name == NULL) {
	if ((object_name = prev_names) == 0)
	    bu_exit (1, "%s:%d: This shouldn't happen\n", __FILE__, __LINE__);
	nm_objects = prev_nm;
    }

    if (prev_names == 0) {
	prev_names = object_name;
	prev_nm = nm_objects;
    }

    if (silent_flag != SILENT_YES) {
	printf("\nGet trees...");
	fflush(stdout);
    }

    i = rt_gettrees_and_attrs(rtip, (const char **)a_tab.attrib, nm_objects, (const char **) object_name, 1);
    if (i) {
	fflush(stdout);
	bu_exit (1, "rt_gettrees() failed\n");
    }

    if( need_prep ) {
	if (silent_flag != SILENT_YES) {
	    printf("\nPrepping the geometry...");
	    fflush(stdout);
	}
	rt_prep( rtip );
	need_prep = 0;
    }

    if (silent_flag != SILENT_YES) {
	printf("\n%s", (nm_objects == 1) ? "Object" : "Objects");
	for (i = 0; i < nm_objects; ++i)
	    printf(" '%s'", object_name[i]);
	printf(" processed\n");
    }
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@major ws and style consistency cleanup
@
text
@d22 1
a22 1
 * This program is an Interactive Ray-Tracer
@


14.22
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d22 1
a22 1
 *       This program is an Interactive Ray-Tracer
d24 2
d27 2
a28 11
 *       Written by:  Natalie L. Barker <barker@@brl>
 *                    U.S. Army Ballistic Research Laboratory
 *
 *       Date:  Jan 90 -
 *
 *       To compile:  /bin/cc -I/usr/include/brlcad nirt.c
 *                    /usr/brlcad/lib/librt.a -lm -o nirt
 *
 *       To run:  nirt [-options] file.g object[s]
 *
 *       Help menu:  nirt -?
a30 3
#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.21 2007/11/21 20:49:10 erikgreenwald Exp $";
#endif
d80 56
a135 44
com_table	ComTab[] =
		{
		    { "attr", cm_attr, "select attributes", "<-f(flush) | -p(print) | attribute_name>" },
		    { "ae", az_el, "set/query azimuth and elevation",
			"azimuth elevation" },
		    { "dir", dir_vect, "set/query direction vector",
			"x-component y-component z-component" },
		    { "hv", grid_coor, "set/query gridplane coordinates",
			"horz vert [dist]" },
		    { "xyz", target_coor, "set/query target coordinates",
			"X Y Z" },
		    { "s", shoot, "shoot a ray at the target" },
		    { "backout", backout, "back out of model" },
		    { "useair", use_air, "set/query use of air",
			"<0|1|2|...>" },
		    { "units", nirt_units, "set/query local units",
			"<mm|cm|m|in|ft>" },
		    { "overlap_claims", do_overlap_claims,
			"set/query overlap rebuilding/retention",
			"<0|1|2|3>" },
		    { "fmt", format_output, "set/query output formats",
			"{rhpfmo} format item item ..." },
		    { "dest", direct_output, "set/query output destination",
			"file/pipe" },
		    { "statefile", state_file,
			"set/query name of state file", "file" },
		    { "dump", dump_state,
			"write current state of NIRT to the state file" },
		    { "load", load_state,
			"read new state for NIRT from the state file" },
		    { "print", print_item, "query an output item",
			"item" },
		    { "bot_minpieces", bot_minpieces,
		      "Get/Set value for rt_bot_minpieces (0 means do not use pieces, default is 32)",
		      "min_pieces" },
		    { "libdebug", cm_libdebug,
			"set/query librt debug flags", "hex_flag_value" },
		    { "debug", cm_debug,
			"set/query nirt debug flags", "hex_flag_value" },
		    { "!", sh_esc, "escape to the shell" },
		    { "q", quit, "quit" },
		    { "?", show_menu, "display this help menu" },
		    { (char *)NULL, NULL, (char *)NULL, (char *)NULL }
		};
d155 1
a155 1
    (void) fputs(usage, stderr);
d167 1
a168 1
}
d170 3
a176 1
    /* flush the list of desired attributs */
d181 1
a182 2
    return;
}
a212 1

a215 9
struct script_rec
{
    struct bu_list	l;
    int			sr_type;	/* Direct or indirect */
    struct bu_vls	sr_script;	/* Literal or file name */
};
#define	SCRIPT_REC_NULL	((struct script_rec *) 0)
#define SCRIPT_REC_MAGIC	0x73637270
#define	sr_magic		l.magic
d217 3
a220 4


				/* Literal or file name */

d228 4
a231 4
    srp -> sr_magic = SCRIPT_REC_MAGIC;
    srp -> sr_type = type;
    bu_vls_init(&(srp -> sr_script));
    bu_vls_strcat(&(srp -> sr_script), string);
d233 1
a233 1
    BU_LIST_INSERT(qp, &(srp -> l));
d236 4
a240 4


				/* for title line */

d249 1
a249 2
    for (BU_LIST_FOR(srp, script_rec, sl))
    {
d254 3
a256 3
	    (srp -> sr_type == READING_STRING) ? "string" :
	    (srp -> sr_type == READING_FILE) ? "file" : "???",
	    bu_vls_addr(&(srp -> sr_script)));
d261 1
d266 1
a266 1
    bu_vls_free(&(srp -> sr_script));
d270 1
d279 3
a281 3
    while (BU_LIST_WHILE(srp, script_rec, sl))
    {
	BU_LIST_DEQUEUE(&(srp -> l));
d283 3
a285 2
	cp = bu_vls_addr(&(srp -> sr_script));
	if (nirt_debug & DEBUG_SCRIPTS)
d287 19
a305 19
		(srp -> sr_type == READING_STRING) ? "literal" :
		(srp -> sr_type == READING_FILE) ? "file" : "???",
		cp);
	switch (srp -> sr_type)
	{
	    case READING_STRING:
		interact(READING_STRING, cp);
		break;
	    case READING_FILE:
		if ((fPtr = fopen(cp, "r")) == NULL)
		    bu_log("Cannot open script file '%s'\n", cp);
		else
		{
		    interact(READING_FILE, fPtr);
		    fclose(fPtr);
		}
		break;
	    default:
		bu_exit (1, "%s:%d: script of type %d.  This shouldn't happen\n", __FILE__, __LINE__, srp -> sr_type);
d309 1
d314 1
d331 1
a332 3
    int                    if_overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2, struct partition *InputHdp);    /* routine if you overlap         */
    int             	   if_hit(struct application *ap, struct partition *part_head, struct seg *finished_segs);        /* routine if you hit target      */
    int             	   if_miss(struct application *ap);       /* routine if you miss target     */
d351 5
a356 1
#if 1
a359 3
#else
    _fmode = _O_BINARY;
#endif
d373 60
a432 63
    while ((Ch = bu_getopt(argc, argv, OPT_STRING)) != EOF)
	switch (Ch)
	{
	    case 'A':
		attrib_add(bu_optarg);
		break;
	    case 'B':
		rt_bot_minpieces = atoi( bu_optarg );
		break;
	    case 'b':
		do_backout = 1;
		break;
	    case 'E':
		if (nirt_debug & DEBUG_SCRIPTS)
		    show_scripts(&script_list, "before erasure");
		while (BU_LIST_WHILE(srp, script_rec, &script_list))
		{
		    BU_LIST_DEQUEUE(&(srp -> l));
		    free_script(srp);
		}
		if (nirt_debug & DEBUG_SCRIPTS)
		    show_scripts(&script_list, "after erasure");
		break;
	    case 'e':
		enqueue_script(&script_list, READING_STRING, bu_optarg);
		if (nirt_debug & DEBUG_SCRIPTS)
		    show_scripts(&script_list, "after enqueueing a literal");
		break;
	    case 'f':
		enqueue_script(&script_list, READING_FILE, bu_optarg);
		if (nirt_debug & DEBUG_SCRIPTS)
		    show_scripts(&script_list, "after enqueueing a file name");
		break;
	    case 'M':
		mat_flag = 1;
		break;
	    case 'O':
		sscanf(bu_optarg, "%1024s", ocastring);
		break;
	    case 's':
		silent_flag = SILENT_YES;	/* Positively yes */
		break;
	    case 'v':
		silent_flag = SILENT_NO;	/* Positively no */
		break;
	    case 'x':
		sscanf( bu_optarg, "%x", (unsigned int *)&rt_g.debug );
		break;
	    case 'X':
		sscanf( bu_optarg, "%x", (unsigned int *)&nirt_debug );
		break;
	    case 'u':
		if (sscanf(bu_optarg, "%d", &use_of_air) != 1)
		{
		    (void) fprintf(stderr,
			"Illegal use-air specification: '%s'\n", bu_optarg);
		    return 1;
		}
		break;
	    case '?':
	    default:
		printusage();
		bu_exit (Ch != '?', NULL);
d434 3
a436 2
    if (argc - bu_optind < 2)
    {
d440 2
a441 2
    if (isatty(0))
    {
d444 2
a445 3
    }
    else	/* stdin is not a TTY */
    {
d452 1
a452 2
    if (use_of_air && (use_of_air != 1))
    {
d454 1
a454 1
	    "Warning: useair=%d specified, will set to 1\n", use_of_air);
d458 18
a475 3
    switch (*ocastring)
    {
	case '\0':
d477 8
a484 10
	    break;
	case '0':
	case '1':
	case '2':
	case '3':
	    if (ocastring[1] == '\0')
		sscanf(ocastring, "%d", &overlap_claims);
	    else
	    {
		(void) fprintf(stderr,
d486 5
a490 21
		return 1;
	    }
	    break;
	case 'r':
	    if (strcmp(ocastring, "resolve") == 0)
		overlap_claims = OVLP_RESOLVE;
	    else if (strcmp(ocastring, "rebuild_fastgen") == 0)
		overlap_claims = OVLP_REBUILD_FASTGEN;
	    else if (strcmp(ocastring, "rebuild_all") == 0)
		overlap_claims = OVLP_REBUILD_ALL;
	    else if (strcmp(ocastring, "retain") == 0)
		overlap_claims = OVLP_RETAIN;
	    else
	    {
		(void) fprintf(stderr,
		    "Illegal overlap_claims specification: '%s'\n", ocastring);
		return 1;
	    }
	    break;
	default:
	    (void) fprintf(stderr,
d492 1
a492 1
	    return 1;
d498 1
a498 2
    if (silent_flag != SILENT_YES)
    {
d502 1
a502 2
    if ((rtip = rt_dirbuild( db_name , db_title, TITLE_LEN )) == RTI_NULL)
    {
d507 1
d510 2
a511 2
    rtip -> useair = use_of_air;
    rtip -> rti_save_overlaps = (overlap_claims > 0);
d549 2
a550 2
    base2local = rtip -> rti_dbip -> dbi_base2local;
    local2base = rtip -> rti_dbip -> dbi_local2base;
d559 1
a559 2
    if (silent_flag != SILENT_YES)
    {
d563 6
a568 6
	    rtip -> mdl_min[X] * base2local,
	    rtip -> mdl_min[Y] * base2local,
	    rtip -> mdl_min[Z] * base2local,
	    rtip -> mdl_max[X] * base2local,
	    rtip -> mdl_max[Y] * base2local,
	    rtip -> mdl_max[Z] * base2local);
d572 1
a572 2
    if ((fPtr = fopenrc()) != NULL)
    {
d591 1
d597 1
d599 1
a599 2
    if (object_name == NULL)
    {
d604 2
a605 2
    if (prev_names == 0)
    {
d611 2
a612 2
	    printf("\nGet trees...");
	    fflush(stdout);
d615 2
a616 2
    if (rt_gettrees_and_attrs(rtip, (const char **)a_tab.attrib, nm_objects, (const char **) object_name, 1))
    {
d618 1
a618 2
	fprintf(stderr, "rt_gettrees() failed\n");
	bu_exit (1, NULL);
d622 6
a627 6
	    if (silent_flag != SILENT_YES) {
		    printf("\nPrepping the geometry...");
		    fflush(stdout);
	    }
	    rt_prep( rtip );
	    need_prep = 0;
d630 1
a630 4
    if (silent_flag != SILENT_YES)
    {
	int	i;

d636 1
a638 2
}

@


14.21
log
@pass bu_exit a NULL instead of an empty string
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.20 2007/11/21 20:38:23 erikgreenwald Exp $";
d415 1
a415 1
		sscanf(bu_optarg, "%s", ocastring);
@


14.20
log
@collapse bu_log();bu_exit(#,""); as much as possible
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.19 2007/11/21 19:49:12 erikgreenwald Exp $";
d440 1
a440 1
		bu_exit (Ch != '?', "");
d633 1
a633 1
	bu_exit (1, "");
@


14.19
log
@exit->bu_exit where applicable
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.18 2007/11/08 04:15:47 brlcad Exp $";
d311 1
a311 3
		bu_log("%s:%d: script of type %d.  This shouldn't happen\n",
		    __FILE__, __LINE__, srp -> sr_type);
		bu_exit (1, "");
d615 1
a615 4
	{
	    bu_log("%s:%d: This shouldn't happen\n", __FILE__, __LINE__);
	    bu_exit (1, "");
	}
@


14.18
log
@minor tweaks, preventive null terminating of strncmp'd strings
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.17 2007/09/15 16:23:18 brlcad Exp $";
d313 1
a313 1
		exit (1);
d442 1
a442 1
		exit (Ch != '?');
d619 1
a619 1
	    exit (1);
d638 1
a638 1
	exit (1);
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.16 2007/04/18 04:03:56 brlcad Exp $";
d569 1
@


14.16
log
@brlcad_version() name changed to brlcad_ident()
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.15 2007/04/17 01:30:21 brlcad Exp $";
d48 2
a49 5
#if HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.15
log
@convert over from using vers.sh and the global to using the new brlcad_version() interface to extract the version information
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.14 2007/01/27 01:41:44 brlcad Exp $";
d463 1
a463 1
	(void) fputs(brlcad_version("Natalie's Interactive Ray Tracer"), stdout);
@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.13 2007/01/23 01:13:44 brlcad Exp $";
d64 2
d68 1
a70 1
extern char	version[];		/* from vers.c */
d463 1
a463 1
	(void) fputs(version + 5, stdout);	/* skip @@(#) */
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.12 2007/01/20 14:36:58 brlcad Exp $";
d204 1
a204 1
    	a_tab.attrib[a_tab.attrib_use] = bu_strdup(p);
a214 9









d228 1
a228 2

    		        	/* Literal or file name */
d248 1
a248 1
    		      		/* for title line */
d382 2
a383 2
        switch (Ch)
        {
d426 1
a426 1
            case 'x':
d429 1
a429 1
            case 'X':
d432 5
a436 5
            case 'u':
                if (sscanf(bu_optarg, "%d", &use_of_air) != 1)
                {
                    (void) fprintf(stderr,
                        "Illegal use-air specification: '%s'\n", bu_optarg);
d438 3
a440 3
                }
                break;
            case '?':
d442 3
a444 3
                printusage();
                exit (Ch != '?');
        }
@


14.12
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d39 1
a39 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.11 2006/07/09 19:17:16 brlcad Exp $";
@


14.11
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.10 2006/02/27 10:08:40 brlcad Exp $";
@


14.10
log
@stdlib.h and exit()
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.9 2006/01/18 06:46:23 brlcad Exp $";
d345 1
a345 1
    char		ocastring[1024];
@


14.9
log
@update copyright to 2006
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.8 2005/12/08 01:34:59 brlcad Exp $";
d45 1
d48 1
a53 2
#include <math.h>

a56 1

d74 17
a148 1

d152 7
a353 1
    void                   printusage(void);
d448 1
a448 1
                    exit (1);
d459 1
a459 1
	exit (1);
d496 1
a496 1
		exit (1);
d512 1
a512 1
		exit (1);
d518 1
a518 1
	    exit (1);
d533 1
a533 1
	exit(1);
d609 1
a609 2
    if (mat_flag)
    {
d611 3
a613 1
	exit (0);
d615 1
a615 2
    else
	interact(READING_FILE, stdin);
a618 21
char	usage[] = "\
Usage: 'nirt [options] model.g objects...'\n\
Options:\n\
 -b        back out of geometry before first shot\n\
 -B n      set rt_bot_minpieces=n\n\
 -e script run script before interacting\n\
 -f sfile  run script sfile before interacting\n\
 -M        read matrix, cmds on stdin\n\
 -O action handle overlap claims via action\n\
 -s        run in short (non-verbose) mode\n\
 -u n      set use_air=n (default 0)\n\
 -v        run in verbose mode\n\
 -x v      set librt(3) diagnostic flag=v\n\
 -X v      set nirt diagnostic flag=v\n\
";

void printusage(void)
{
    (void) fputs(usage, stderr);
}

@


14.8
log
@RT_APPLICATION_INIT
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.7 2005/10/23 04:44:37 brlcad Exp $";
@


14.7
log
@trailing ws
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.6 2005/06/30 00:17:45 erikgreenwald Exp $";
d526 1
@


14.6
log
@added missing includes
@
text
@d24 1
a24 1
 *       
d30 2
a31 2
 * 
 *       To compile:  /bin/cc -I/usr/include/brlcad nirt.c 
d34 1
a34 1
 *       To run:  nirt [-options] file.g object[s] 
d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.5 2005/06/24 19:00:21 bob1961 Exp $";
d79 1
a79 1
		    { "ae", az_el, "set/query azimuth and elevation", 
d81 1
a81 1
		    { "dir", dir_vect, "set/query direction vector", 
d85 1
a85 1
		    { "xyz", target_coor, "set/query target coordinates", 
d177 1
a177 1
	    a_tab.attrib = bu_realloc(a_tab.attrib, 
d215 2
a216 2
              	    
   		     
d236 1
a236 1
              	    
d338 1
a338 1
    int	           	   str_dbl(char *buf, double *Result);	
d541 1
a541 1
    direct(X) = -1.0; 
d596 1
a596 1
 
@


14.6.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d24 1
a24 1
 *
d30 2
a31 2
 *
 *       To compile:  /bin/cc -I/usr/include/brlcad nirt.c
d34 1
a34 1
 *       To run:  nirt [-options] file.g object[s]
d40 1
a40 1
static const char RCSid[] = "$Header$";
d79 1
a79 1
		    { "ae", az_el, "set/query azimuth and elevation",
d81 1
a81 1
		    { "dir", dir_vect, "set/query direction vector",
d85 1
a85 1
		    { "xyz", target_coor, "set/query target coordinates",
d177 1
a177 1
	    a_tab.attrib = bu_realloc(a_tab.attrib,
d215 2
a216 2


d236 1
a236 1

d338 1
a338 1
    int	           	   str_dbl(char *buf, double *Result);
d541 1
a541 1
    direct(X) = -1.0;
d596 1
a596 1

@


14.5
log
@Modified main to use bu_getopt
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.4 2005/05/28 02:14:54 brlcad Exp $";
d54 4
@


14.4
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.3 2005/01/30 20:31:08 brlcad Exp $";
a65 2
extern int	rt_bot_minpieces;	/* from g_bot.c */

a322 3
    extern int 		optind;		/* index from getopt(3C) */
    extern char		*optarg;	/* argument from getopt(3C) */

d347 7
a353 1
	_fmode = _O_BINARY;
a355 1

d364 2
d367 1
a367 1
    while ((Ch = getopt(argc, argv, OPT_STRING)) != EOF)
d371 1
a371 1
		attrib_add(optarg);
d374 1
a374 1
		rt_bot_minpieces = atoi( optarg );
d391 1
a391 1
		enqueue_script(&script_list, READING_STRING, optarg);
d396 1
a396 1
		enqueue_script(&script_list, READING_FILE, optarg);
d404 1
a404 1
		sscanf(optarg, "%s", ocastring);
d413 1
a413 1
		sscanf( optarg, "%x", (unsigned int *)&rt_g.debug );
d416 1
a416 1
		sscanf( optarg, "%x", (unsigned int *)&nirt_debug );
d419 1
a419 1
                if (sscanf(optarg, "%d", &use_of_air) != 1)
d422 1
a422 1
                        "Illegal use-air specification: '%s'\n", optarg);
d431 1
a431 1
    if (argc - optind < 2)
d496 1
a496 1
    db_name = argv[optind];
d515 2
a516 2
    ++optind;
    do_rt_gettrees (rtip, argv + optind, argc - optind);
@


14.3
log
@update copyright to 2005
@
text
@d40 1
a40 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/nirt.c,v 14.2 2004/12/21 02:40:25 morrison Exp $";
a44 2


d48 1
a48 1
# include <string.h>
d50 1
a50 1
# include <strings.h>
d54 4
a64 5
#ifdef WIN32
#include <fcntl.h>
#endif


d351 1
a351 1
	#ifdef WIN32
d353 1
a353 1
	#endif
@


14.2
log
@assign copyright and GPL
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d40 1
a40 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/nirt.c,v 14.1 2004/11/16 19:42:17 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*                        NIRT
d40 1
a40 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/nirt.c,v 1.5 2004/09/16 04:56:41 morrison Exp $";
@


1.5
log
@quell warnings
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/nirt.c,v 1.4 2004/09/03 23:30:59 morrison Exp $";
d649 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/nirt.c,v 1.3 2004/08/02 23:01:51 morrison Exp $";
d314 1
a314 1
    int             	   if_miss(void);       /* routine if you miss target     */
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/nirt.c,v 1.2 2004/06/08 22:04:30 morrison Exp $";
d29 1
a29 1
#if USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header$";
d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char RCSid[] = "$Header: /cvs/brlcad/nirt/nirt.c,v 11.27 2004/05/10 15:30:49 erikg Exp $";
a38 1
#include "externs.h"
@

