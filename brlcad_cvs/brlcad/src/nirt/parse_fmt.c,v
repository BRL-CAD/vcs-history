head	14.20;
access;
symbols
	rel-7-10-4:14.14
	STABLE:14.14.0.2
	stable-branch:14.3
	rel-7-10-2:14.12
	rel-7-10-0:14.12
	rel-7-8-4:14.9
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.20
date	2007.12.22.19.39.08;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.12.18.00.14.25;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.12.02.22.34.23;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.11.21.20.49.10;	author erikgreenwald;	state Exp;
branches;
next	14.16;

14.16
date	2007.11.21.19.49.12;	author erikgreenwald;	state Exp;
branches;
next	14.15;

14.15
date	2007.09.15.16.23.18;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.08.17.02.11.12;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.08.16.21.39.28;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.27.01.41.44;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.44;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.36.58;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.29.08.39.28;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.23.07.29.03;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2006.01.23.07.06.29;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.18.06.46.23;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.10.23.04.44.37;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.04.27.02.29.22;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2005.01.30.20.31.08;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.02.40.25;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.17;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.59;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.51;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.30;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.20.35;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.18;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.20
log
@-> ws
@
text
@/*                     P A R S E _ F M T . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file parse_fmt.c
 *
 * Parse the output formatter
 *
 * Author:
 *   Natalie L. Barker
 *
 * Date:
 *   Jan 90
 *
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./nirt.h"
#include "./usrfmt.h"


/* The table of output values */
outval ValTab[] = {
    { 0, VTI_LITERAL },
    { "x_orig", VTI_X_ORIG, OIT_FLOAT },
    { "y_orig", VTI_Y_ORIG, OIT_FLOAT },
    { "z_orig", VTI_Z_ORIG, OIT_FLOAT },
    { "h", VTI_H, OIT_FLOAT },
    { "v", VTI_V, OIT_FLOAT },
    { "d_orig", VTI_D_ORIG, OIT_FLOAT },
    { "x_dir", VTI_X_DIR, OIT_FNOUNIT },
    { "y_dir", VTI_Y_DIR, OIT_FNOUNIT },
    { "z_dir", VTI_Z_DIR, OIT_FNOUNIT },
    { "a", VTI_A, OIT_FNOUNIT },
    { "e", VTI_E, OIT_FNOUNIT },
    { "x_in", VTI_X_IN, OIT_FLOAT },
    { "y_in", VTI_Y_IN, OIT_FLOAT },
    { "z_in", VTI_Z_IN, OIT_FLOAT },
    { "d_in", VTI_D_IN, OIT_FLOAT },
    { "x_out", VTI_X_OUT, OIT_FLOAT },
    { "y_out", VTI_Y_OUT, OIT_FLOAT },
    { "z_out", VTI_Z_OUT, OIT_FLOAT },
    { "d_out", VTI_D_OUT, OIT_FLOAT },
    { "los", VTI_LOS, OIT_FLOAT },
    { "scaled_los", VTI_SLOS, OIT_FLOAT },
    { "path_name", VTI_PATH_NAME, OIT_STRING },
    { "reg_name", VTI_REG_NAME, OIT_STRING },
    { "reg_id", VTI_REG_ID, OIT_INT },
    { "obliq_in", VTI_OBLIQ_IN, OIT_FNOUNIT },
    { "obliq_out", VTI_OBLIQ_OUT, OIT_FNOUNIT },
    { "nm_x_in", VTI_NM_X_IN, OIT_FNOUNIT },
    { "nm_y_in", VTI_NM_Y_IN, OIT_FNOUNIT },
    { "nm_z_in", VTI_NM_Z_IN, OIT_FNOUNIT },
    { "nm_d_in", VTI_NM_D_IN, OIT_FNOUNIT },
    { "nm_h_in", VTI_NM_H_IN, OIT_FNOUNIT },
    { "nm_v_in", VTI_NM_V_IN, OIT_FNOUNIT },
    { "nm_x_out", VTI_NM_X_OUT, OIT_FNOUNIT },
    { "nm_y_out", VTI_NM_Y_OUT, OIT_FNOUNIT },
    { "nm_z_out", VTI_NM_Z_OUT, OIT_FNOUNIT },
    { "nm_d_out", VTI_NM_D_OUT, OIT_FNOUNIT },
    { "nm_h_out", VTI_NM_H_OUT, OIT_FNOUNIT },
    { "nm_v_out", VTI_NM_V_OUT, OIT_FNOUNIT },
    { "ov_reg1_name", VTI_OV_REG1_NAME, OIT_STRING },
    { "ov_reg1_id", VTI_OV_REG1_ID, OIT_INT },
    { "ov_reg2_name", VTI_OV_REG2_NAME, OIT_STRING },
    { "ov_reg2_id", VTI_OV_REG2_ID, OIT_INT },
    { "ov_sol_in", VTI_OV_SOL_IN, OIT_STRING },
    { "ov_sol_out", VTI_OV_SOL_OUT, OIT_STRING },
    { "ov_los", VTI_OV_LOS, OIT_FLOAT },
    { "ov_x_in", VTI_OV_X_IN, OIT_FLOAT },
    { "ov_y_in", VTI_OV_Y_IN, OIT_FLOAT },
    { "ov_z_in", VTI_OV_Z_IN, OIT_FLOAT },
    { "ov_d_in", VTI_OV_D_IN, OIT_FLOAT },
    { "ov_x_out", VTI_OV_X_OUT, OIT_FLOAT },
    { "ov_y_out", VTI_OV_Y_OUT, OIT_FLOAT },
    { "ov_z_out", VTI_OV_Z_OUT, OIT_FLOAT },
    { "ov_d_out", VTI_OV_D_OUT, OIT_FLOAT },
    { "surf_num_in", VTI_SURF_NUM_IN, OIT_INT },
    { "surf_num_out", VTI_SURF_NUM_OUT, OIT_INT },
    { "claimant_count", VTI_CLAIMANT_COUNT, OIT_INT },
    { "claimant_list", VTI_CLAIMANT_LIST, OIT_STRING },
    { "claimant_listn", VTI_CLAIMANT_LISTN, OIT_STRING },
    { "attributes", VTI_ATTRIBUTES, OIT_STRING },
    { 0 }
};

outitem		*oi_list[FMT_NONE];
static char	def_dest_string[] = "stdout";
char		*dest_string = def_dest_string;
static char	def_sf_name[] = DEF_SF_NAME;
char		*sf_name = def_sf_name;		/* Name of state file */

FILE		*outf = (FILE *)NULL;
char		*def_fmt[] = {
    "\"Origin (x y z) = (%.8f %.8f %.8f)  (h v d) = (%.4f %.4f %.4f)\nDirection (x y z) = (%.8f %.8f %.8f)  (az el) = (%.8f %.8f)\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e",
    "\"    Region Name               Entry (x y z)              LOS  Obliq_in Attrib\n\"",
    "\"%-20s (%9.4f %9.4f %9.4f) %8.4f %8.4f %s\n\" reg_name x_in y_in z_in los obliq_in attributes",
    "\"\"",
    "\"You missed the target\n\"",
    "\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\n\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"
};

void				free_ospec(outitem *oil);

extern double			base2local;
extern struct application	ap;
extern char			local_u_name[];
extern int			overlap_claims;
extern char			*ocname[];


void
format_output (char *buffer, com_table	*ctp)
{
    char	*bp = buffer;	/* was  + 1; */
    int		fmt_type = FMT_NONE;
    int		i;
    int		use_defaults = 0;

    void	parse_fmt(char *uoutspec, int outcom_type);
    void	show_ospec(outitem *oil);

    /* Handle no args, arg=='?', and obvious bad arg */
    if (*bp != '\0')
	++bp;
    while (isspace(*bp))
	++bp;
    switch (*bp) {
    case 'r':
	fmt_type = FMT_RAY;
	break;
    case 'h':
	fmt_type = FMT_HEAD;
	break;
    case 'p':
	fmt_type = FMT_PART;
	break;
    case 'f':
	fmt_type = FMT_FOOT;
	break;
    case 'm':
	fmt_type = FMT_MISS;
	break;
    case 'o':
	fmt_type = FMT_OVLP;
	break;
    default:
	--bp;
	break;
    }
    while (isspace(*++bp))
	;
    
    switch (*bp) {
    case '\0':     /* display current output specs */
	if (fmt_type == FMT_NONE)
	    fprintf(stderr, "Error: No output-statement type specified\n");
	else
	    show_ospec(oi_list[fmt_type]);
	return;
    case '"':
	if (fmt_type == FMT_NONE) {
	    fprintf(stderr, "Error: No output-statement type specified\n");
	    return;
	}
	break;
    default:
	if (strncmp(bp, "default", 7) == 0) {
	    use_defaults = 1;
	    break;
	}
	fprintf(stderr, "Error: Illegal format specifiation: '%s'\n", buffer);
	/* fall through here */
    case '?':
	com_usage(ctp);
	return;
    }

    if (use_defaults) {
	if (fmt_type == FMT_NONE) {
	    for (i = 0; i < FMT_NONE; ++i) {
		parse_fmt(def_fmt[i], i);
	    }
	} else {
	    parse_fmt(def_fmt[fmt_type], fmt_type);
	}
    } else {
	parse_fmt(bp, fmt_type);
    }
}


/**
 * uoutspect is the user's output specification (format & args).
 * outcom_type is the type of output command
 */
void
parse_fmt(char *uoutspec, int outcom_type)
{
    char	*of;		/* Format for current output item */
    char	*up;
    char	*mycopy;	/* Solely for handing to bu_free() */
    char	*uos;
    int		nm_cs;		/* Number of conversion specifications */
    outitem	*oil = OUTITEM_NULL;
    outitem	*oip;
    outitem	*prev_oip = OUTITEM_NULL;
    outval	*vtp;

    /* N.B. bu_malloc() only returns upon successful allocation */

    mycopy = uos = bu_malloc(strlen(uoutspec) + 1, "uos");
    strncpy(uos, uoutspec, strlen(uoutspec));
    /* Break up the format specification into pieces,
     * one per conversion specification (and, hopefully)
     * one per argument.
     */
    if (*uos != '"') {
	fprintf(stderr,
		"parse_fmt sees first character `%c`.  Shouldn't happen.\n",
		*uos);
	bu_free(mycopy, "Copy of user's output spec");
	return;
    }
    ++uos;
    while (*uos != '"') {
	nm_cs = 0;
	/* Allocate storage for the next item in the output list */
	oip = (outitem *) bu_malloc(sizeof(outitem), "output item");
	oip->next = OUTITEM_NULL;

	for (up = uos; *uos != '"'; ++uos) {
	    if (*uos == '%') {
		if (*(uos + 1) == '%')
		    ++uos;
		else if (nm_cs == 1)
		    break;
		else /* nm_cs == 0 */
		    ++nm_cs;
	    }
	    if (*uos == '\\')
		if (*(uos + 1) == '"')
		    ++uos;
	}
	
	/* Allocate memory for and store the format.
	 * The code_nm field will be used at this point
	 * to record whether this format specification
	 * needs an output item or not (i.e. whether it
	 * contains 1 conversion spec vs. none)
	 */
	oip->format = bu_malloc(uos - up + 1, "format");
	of = oip->format;
	while (up != uos) {
	    if (*up == '\\') {
		switch (*(up + 1)) {
		case 'n':
		    *of++ = '\n';
		    up += 2;
		    break;
		case '\042':
		case '\047':
		case '\134':
		    *of++ = *(up + 1);
		    up += 2;
		    break;
		default:
		    *of++ = *up++;
		    break;
		}
	    } else {
		*of++ = *up++;
	    }
	}
	*of = '\0';
	oip->code_nm = nm_cs;

	if (prev_oip == OUTITEM_NULL)
	    oil = oip;
	else
	    prev_oip->next = oip;
	prev_oip = oip;
    }
    
    /* Skip any garbage beyond the close quote */
    for (up = ++uos; (! isspace(*uos)) && (*uos != '\0'); ++uos)
	;

    if (up != uos) {
	*uos = '\0';
	fprintf(stderr,
		"Warning: suffix '%s' after format specification ignored\n",
		up);
    }

    /* Read in the list of objects to output */
    for (oip = oil; oip != OUTITEM_NULL; oip = oip->next) {
	if (oip->code_nm == 0)
	    continue;		/* outitem's format has no conversion spec */
	
	while (isspace(*uos))
	    ++uos;
	if (*uos == '\0') {
	    fprintf(stderr,
		    "Error: Fewer output items than conversion specs\n");
	    bu_free(mycopy, "Copy of user's output spec");
	    return;
	}
	for (up = uos; (! isspace(*uos)) && (*uos != '\0'); ++uos)
	    ;

	if (*uos != '\0')
	    *uos++ = '\0';

	oip->code_nm = 0;
	for (vtp = ValTab + 1; vtp->name; ++vtp) {
	    if (strcmp(vtp->name, up) == 0) {
		oip->code_nm = vtp->code_nm;
		break;
	    }
	}

	if (vtp->name == '\0') {
	    fprintf(stderr, "Error: Invalid output item '%s'\n", up);
	    bu_free(mycopy, "Copy of user's output spec");
	    return;
	}
    }

    while (isspace(*uos))
	++uos;

    if (*uos != '\0') {
	fprintf(stderr, "Error: More output items than conversion specs\n");
	fprintf( stderr, "Offending spec:\n\t%s\n", mycopy );
	bu_free(mycopy, "Copy of user's output spec");
	return;
    }

    check_conv_spec(oil);

    /* We are now satisfied that oil is a valid list of output items,
     * so it's time to install it as such
     */
    free_ospec(oi_list[outcom_type]);
    oi_list[outcom_type] = oil;

    bu_free(mycopy, "Copy of user's output spec");
}

void
default_ospec (void)
{
    int	i;

    for (i = 0; i < FMT_NONE; ++i) {
	oi_list[i] = OUTITEM_NULL;
	parse_fmt(def_fmt[i], i);
    }
}


/**
 * oil is a list of output items
 */
void
show_ospec (outitem *oil)
{
    outitem	*oip;		/* Pointer into list of output items */
    char	*c;

    /* Display the format specification */
    printf("Format: \"");
    for (oip = oil; oip != OUTITEM_NULL; oip = oip->next) {
	for (c = oip->format; *c != '\0'; ++c) {
	    if (*c == '\n')
		printf("\\n");
	    else
		putchar(*c);
	}
    }
    printf("\"\n");

    /* Display the list of item names */
    printf("Item(s):");
    for (oip = oil; oip != OUTITEM_NULL; oip = oip->next) {
	if (ValTab[oip->code_nm].name)
	    printf(" %s", ValTab[oip->code_nm].name);
    }
    printf("\n");
}


void
report(int outcom_type)
{
    outitem	*oip;

    if ((outcom_type < 0) || (outcom_type >= FMT_NONE)) {
	fprintf(stderr,
		"Illegal output-statement type: %d.  Shouldn't happen\n",
		outcom_type);
	return;
    }
    if( outf == (FILE *)NULL )
	outf = stdout;

    for (oip = oi_list[outcom_type]; oip != OUTITEM_NULL; oip = oip->next) {
	switch (ValTab[oip->code_nm].type) {
	case OIT_INT:
	    fprintf(outf, oip->format, ValTab[oip->code_nm].value.ival);
	    break;
	case OIT_FLOAT:
	    fprintf(outf, oip->format,
		    ValTab[oip->code_nm].value.fval * base2local);
	    break;
	case OIT_FNOUNIT:
	    fprintf(outf, oip->format,
		    ValTab[oip->code_nm].value.fval);
	    break;
	case OIT_STRING:
	    fprintf(outf, oip->format, ValTab[oip->code_nm].value.sval);
	    break;
	default:
	    fflush(stdout);
	    fprintf(stderr, "Fatal: Invalid item type %d.  ",
		    ValTab[oip->code_nm].type);
	    fprintf(stderr, "This shouldn't happen\n");
	    bu_exit (1, NULL);
	}
    }
    fflush(outf);
}


void
print_item (char *buffer, com_table *ctp)
{
    char	*bp = buffer;
    char	*bp0;
    outval	*vtp;


    /* Handle no args, arg=='?', and obvious bad arg */
    if (*bp != '\0')
	++bp;

    while (isspace(*bp))
	++bp;

    switch (*bp) {
    case '\0':
    case '?':
	com_usage(ctp);
	return;
    }

    /* Read in the list of objects to output */
    while (*bp != '\0') {
	while (isspace(*bp))
	    ++bp;

	for (bp0 = bp; (! isspace(*bp)) && (*bp != '\0'); ++bp)
	    ;

	if (*bp != '\0')
	    *bp++ = '\0';

	for (vtp = ValTab + 1; vtp->name; ++vtp) {
	    if (strcmp(vtp->name, bp0) == 0) {
		switch (vtp->type) {
		case OIT_INT:
		    printf("%d\n", vtp->value.ival);
		    break;
		case OIT_FLOAT:
		    printf("%g\n", vtp->value.fval * base2local);
		    break;
		case OIT_FNOUNIT:
		    printf("%g\n", vtp->value.fval);
		    break;
		case OIT_STRING:
		    printf("'%s'\n", vtp->value.sval);
		    break;
		default:
		    fflush(stdout);
		    fprintf(stderr, "Fatal: Invalid item type %d.  ",
			    ValTab[vtp->code_nm].type);
		    fprintf(stderr, "This shouldn't happen\n");
		    bu_exit (1, NULL);
		}
		break;
	    }
	}

	if (vtp->name == '\0') {
	    fprintf(stderr, "Error: Invalid output item '%s'\n", bp0);
	    return;
	}
    }
}

FILE *
fopenrc(void)
{
    char	*rc_file_name;
    char	*home;
    FILE	*fPtr;
    int len;

    if ((fPtr = fopen(DEF_RCF_NAME, "r")) == NULL) {
	if ((home = getenv("HOME")) != NULL) {
	    len = strlen(home) + strlen(DEF_RCF_NAME) + 2;
	    rc_file_name = bu_malloc(len, "rc_file_name");
	    snprintf(rc_file_name, len, "%s/%s", home, DEF_RCF_NAME);
	    fPtr = fopen(rc_file_name, "r");
	}
    }
    return (fPtr);
}

int
check_conv_spec (outitem *oip)
{
    char	*cp;
    int		oi_type;
    int		warnings = 0;

    for ( ; oip != OUTITEM_NULL; oip = oip->next) {
	for (cp = oip->format; *cp != '\0'; ++cp) {
	    if (*cp == '%') {
		if (*(cp + 1) == '%') {
		    ++cp;
		} else {
		    ++cp;
		    break;
		}
	    }
	}

	if (*cp == '\0')		/* Added 8 Jun 90 */
	    continue;

	/* Skip optional crud */
	if (*cp == '-')
	    ++cp;
	while (isdigit(*cp))
	    ++cp;
	if (*cp == '.')
	    ++cp;
	while (isdigit(*cp))
	    ++cp;

	oi_type = ValTab[oip->code_nm].type;
	switch (*cp) {
	case 'd':
	case 'o':
	case 'u':
	case 'x':
	    if (oi_type != OIT_INT) {
		++warnings;
		fprintf(stderr,
			"Warning: Conversion type '%%%c' specified",
			*cp);
		fprintf(stderr,
			" for item %s, which is %s\n",
			ValTab[oip->code_nm].name, oit_name(oi_type));
	    }
	    break;
	case 'f':
	case 'e':
	case 'E':
	case 'g':
	case 'G':
	    if ((oi_type != OIT_FLOAT) && (oi_type != OIT_FNOUNIT)) {
		++warnings;
		fprintf(stderr,
			"Warning: Conversion type '%%%c' specified",
			*cp);
		fprintf(stderr,
			" for item %s, which is %s\n",
			ValTab[oip->code_nm].name, oit_name(oi_type));
	    }
	    break;
	case 's':
	    if (oi_type != OIT_STRING) {
		++warnings;
		fprintf(stderr,
			"Warning: Conversion type '%%%c' specified",
			*cp);
		fprintf(stderr,
			" for item %s, which is %s\n",
			ValTab[oip->code_nm].name, oit_name(oi_type));
	    }
	    break;
	case 'c':
	    ++warnings;
	    fprintf(stderr,
		    "Warning: Conversion type '%%%c' specified", *cp);
	    fprintf(stderr,
		    " for item %s, which is a %s\n",
		    ValTab[oip->code_nm].name, oit_name(oi_type));
	    break;
	default:
	    ++warnings;
	    fprintf(stderr,
		    "Warning: Unknown conversion type '%%%c'\n", *cp);
	    break;
	}
    }
    return (warnings);
}


void
direct_output(char *buffer, com_table *ctp)
{
    int 	i = 0;      /* current position on the *buffer        */
    FILE	*newf;
    static char	*new_dest;
    static FILE	*(*openfunc)() = 0;

    while (isspace(*(buffer+i)))
	    ++i;

    if (*(buffer+i) == '\0') {
	/* display current destination */
	printf("destination = %s%s'\n",
	    (openfunc == popen) ? "'| " : "'", dest_string);
	return;
    }

    if (strcmp(buffer + i, "?") == 0) {
	com_usage(ctp);
	return;
    }

    if (strcmp(buffer + i, "default") == 0) {
	newf = stdout;
	new_dest = def_dest_string;
	openfunc = 0;
    } else {
	if (*(buffer + i) == '|') {
	    openfunc=popen;
	    ++i;
	} else {
	    openfunc=fopen;
	}

	new_dest = bu_malloc(strlen(buffer + i)+1,"new_dest");

	snprintf(new_dest, strlen(buffer+i), "%s", buffer + i);
	if ((newf = (*openfunc)(new_dest, "w")) == NULL) {
	    fprintf(stderr, "Cannot open %s '%s'\n",
		(openfunc == popen) ? "pipe" : "file", new_dest);
	    fprintf(stderr, "Destination remains = '%s'\n", dest_string);

	    bu_free(new_dest, "new(now old)dest");
	    return;
	}


    }

    /* Clean up from previous output destination */
    if (outf != (FILE *)NULL && outf != stdout)
	fclose(outf);

    if (dest_string != def_dest_string)
	bu_free(dest_string, "free dest_string");

    /* Establish the new destination */
    outf = newf;
    dest_string = new_dest;
}


void
state_file(char *buffer, com_table *ctp)
{
    int 	i = 0;      /* current position on the *buffer        */
    static char	*new_name;

    while (isspace(*(buffer+i)))
	    ++i;

    if (*(buffer+i) == '\0') {
	/* display current state name */
	printf("statefile = '%s'\n", sf_name);
	return;
    }

    if (strcmp(buffer + i, "?") == 0) {
	com_usage(ctp);
	return;
    }

    if (strcmp(buffer + i, "default") == 0) {
	new_name = def_sf_name;
    } else {
	new_name = bu_malloc(strlen(buffer + i)+1, "new_state_filename");
	snprintf(new_name, strlen(buffer+i), "%s", buffer + i);
    }

    /* Clean up from previous output destination */
    if (sf_name != def_sf_name)
	bu_free(sf_name, "new(now old)statefile");

    /* Establish the new destination */
    sf_name = new_name;
}


void
dump_state(char *buffer, com_table *ctp)
{
    char	*c;
    static char	fmt_char[] = {'r', 'h', 'p', 'f', 'm', 'o'};
    FILE	*sfPtr;
    int		f;
    outitem	*oip;		/* Pointer into list of output items */

    if ((sfPtr = fopen(sf_name, "w")) == NULL) {
	fprintf(stderr, "Cannot open statefile '%s'\n", sf_name);
	return;
    }

    printf("Dumping NIRT state to file '%s'...", sf_name);
    fprintf(sfPtr, "%c file created by the dump command of nirt\n", CMT_CHAR);
    fprintf(sfPtr, "xyz %g %g %g\n", target(X), target(Y), target(Z));
    fprintf(sfPtr, "dir %g %g %g\n", direct(X), direct(Y), direct(Z));
    fprintf(sfPtr, "useair %d\n", ap.a_rt_i->useair);
    fprintf(sfPtr, "units %s\n", local_u_name);
    if (strcmp(dest_string, "stdout") == 0)
	fputs("dest default\n", sfPtr);
    else
	fprintf(sfPtr, "dest %s\n", dest_string);
    fprintf(sfPtr, "overlap_claims %s\n", ocname[overlap_claims]);

    for (f = 0; f < FMT_NONE; ++f) {
	fprintf(sfPtr, "fmt %c \"", fmt_char[f]);
	/* Display the conversion specifications */
	for (oip = oi_list[f]; oip != OUTITEM_NULL; oip = oip->next)
	    for (c = oip->format; *c != '\0'; ++c)
		if (*c == '\n')
		    fprintf(sfPtr, "\\n");
		else
		    fputc(*c, sfPtr);
	fprintf(sfPtr, "\"");

	/* Display the item name */
	for (oip = oi_list[f]; oip != OUTITEM_NULL; oip = oip->next)
	    if (ValTab[oip->code_nm].name)
		fprintf(sfPtr, " %s", ValTab[oip->code_nm].name);
	fprintf(sfPtr, "\n");
    }
    printf("\n");
    fclose(sfPtr);
}


void
load_state(char *buffer, com_table *ctp)
{
    FILE	*sfPtr;

    if ((sfPtr = fopen(sf_name, "r")) == NULL) {
	fprintf(stderr, "Cannot open statefile '%s'\n", sf_name);
	return;
    }
    bu_log("Loading NIRT state from file '%s'...", sf_name);
    interact(READING_FILE, sfPtr);
    bu_log("\n");
    fclose(sfPtr);
}


/**
 * oil is a list of output items
 */
void
free_ospec (outitem *oil)
{
    outitem	*next = oil;	/* Pointer to next output item */
    outitem	*oip;		/* Pointer to output item to free */

    while (next != OUTITEM_NULL) {
	oip = next;
	next = oip->next;
	bu_free(oip->format, "outitem.format");
	if (oip != oil)
	    bu_free((char *) oip, "outitem");
    }
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.19
log
@ws and style consistency cleanup
@
text
@d254 1
a254 1
	oip -> next = OUTITEM_NULL;
d277 1
a277 1
	of = oip -> format;
d300 1
a300 1
	oip -> code_nm = nm_cs;
d305 1
a305 1
	    prev_oip -> next = oip;
d321 2
a322 2
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next) {
	if (oip -> code_nm == 0)
d339 4
a342 4
	oip -> code_nm = 0;
	for (vtp = ValTab + 1; vtp -> name; ++vtp) {
	    if (strcmp(vtp -> name, up) == 0) {
		oip -> code_nm = vtp -> code_nm;
d347 1
a347 1
	if (vtp -> name == '\0') {
d398 2
a399 2
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next) {
	for (c = oip -> format; *c != '\0'; ++c) {
d410 3
a412 3
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next) {
	if (ValTab[oip -> code_nm].name)
	    printf(" %s", ValTab[oip -> code_nm].name);
d432 2
a433 2
    for (oip = oi_list[outcom_type]; oip != OUTITEM_NULL; oip = oip -> next) {
	switch (ValTab[oip -> code_nm].type) {
d435 1
a435 1
	    fprintf(outf, oip -> format, ValTab[oip -> code_nm].value.ival);
d438 2
a439 2
	    fprintf(outf, oip -> format,
		    ValTab[oip -> code_nm].value.fval * base2local);
d442 2
a443 2
	    fprintf(outf, oip -> format,
		    ValTab[oip -> code_nm].value.fval);
d446 1
a446 1
	    fprintf(outf, oip -> format, ValTab[oip -> code_nm].value.sval);
d451 1
a451 1
		    ValTab[oip -> code_nm].type);
d493 3
a495 3
	for (vtp = ValTab + 1; vtp -> name; ++vtp) {
	    if (strcmp(vtp -> name, bp0) == 0) {
		switch (vtp -> type) {
d497 1
a497 1
		    printf("%d\n", vtp -> value.ival);
d500 1
a500 1
		    printf("%g\n", vtp -> value.fval * base2local);
d503 1
a503 1
		    printf("%g\n", vtp -> value.fval);
d506 1
a506 1
		    printf("'%s'\n", vtp -> value.sval);
d511 1
a511 1
			    ValTab[vtp -> code_nm].type);
d519 1
a519 1
	if (vtp -> name == '\0') {
d552 2
a553 2
    for ( ; oip != OUTITEM_NULL; oip = oip -> next) {
	for (cp = oip -> format; *cp != '\0'; ++cp) {
d577 1
a577 1
	oi_type = ValTab[oip -> code_nm].type;
d590 1
a590 1
			ValTab[oip -> code_nm].name, oit_name(oi_type));
d605 1
a605 1
			ValTab[oip -> code_nm].name, oit_name(oi_type));
d616 1
a616 1
			ValTab[oip -> code_nm].name, oit_name(oi_type));
d625 1
a625 1
		    ValTab[oip -> code_nm].name, oit_name(oi_type));
d755 1
a755 1
    fprintf(sfPtr, "useair %d\n", ap.a_rt_i -> useair);
d766 2
a767 2
	for (oip = oi_list[f]; oip != OUTITEM_NULL; oip = oip -> next)
	    for (c = oip -> format; *c != '\0'; ++c)
d775 3
a777 3
	for (oip = oi_list[f]; oip != OUTITEM_NULL; oip = oip -> next)
	    if (ValTab[oip -> code_nm].name)
		fprintf(sfPtr, " %s", ValTab[oip -> code_nm].name);
d812 2
a813 2
	next = oip -> next;
	bu_free(oip -> format, "outitem.format");
@


14.18
log
@woo hoo, finally got through most of the flawfinder level 4 issues related to string buffer limits (leaving issues that can probably/mostly be ignored).  these changes mostly invovlved using the n-variants of the various string processing functions so that the buffers being written to are properly clamped.
@
text
@d22 8
a30 3
#ifndef lint
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.17 2007/11/21 20:49:10 erikgreenwald Exp $";
#endif
d45 1
d47 64
a110 64
outval		ValTab[] =
		{
		    { 0, VTI_LITERAL },
		    { "x_orig", VTI_X_ORIG, OIT_FLOAT },
		    { "y_orig", VTI_Y_ORIG, OIT_FLOAT },
		    { "z_orig", VTI_Z_ORIG, OIT_FLOAT },
		    { "h", VTI_H, OIT_FLOAT },
		    { "v", VTI_V, OIT_FLOAT },
		    { "d_orig", VTI_D_ORIG, OIT_FLOAT },
		    { "x_dir", VTI_X_DIR, OIT_FNOUNIT },
		    { "y_dir", VTI_Y_DIR, OIT_FNOUNIT },
		    { "z_dir", VTI_Z_DIR, OIT_FNOUNIT },
		    { "a", VTI_A, OIT_FNOUNIT },
		    { "e", VTI_E, OIT_FNOUNIT },
		    { "x_in", VTI_X_IN, OIT_FLOAT },
		    { "y_in", VTI_Y_IN, OIT_FLOAT },
		    { "z_in", VTI_Z_IN, OIT_FLOAT },
		    { "d_in", VTI_D_IN, OIT_FLOAT },
		    { "x_out", VTI_X_OUT, OIT_FLOAT },
		    { "y_out", VTI_Y_OUT, OIT_FLOAT },
		    { "z_out", VTI_Z_OUT, OIT_FLOAT },
		    { "d_out", VTI_D_OUT, OIT_FLOAT },
		    { "los", VTI_LOS, OIT_FLOAT },
		    { "scaled_los", VTI_SLOS, OIT_FLOAT },
		    { "path_name", VTI_PATH_NAME, OIT_STRING },
		    { "reg_name", VTI_REG_NAME, OIT_STRING },
		    { "reg_id", VTI_REG_ID, OIT_INT },
		    { "obliq_in", VTI_OBLIQ_IN, OIT_FNOUNIT },
		    { "obliq_out", VTI_OBLIQ_OUT, OIT_FNOUNIT },
		    { "nm_x_in", VTI_NM_X_IN, OIT_FNOUNIT },
		    { "nm_y_in", VTI_NM_Y_IN, OIT_FNOUNIT },
		    { "nm_z_in", VTI_NM_Z_IN, OIT_FNOUNIT },
		    { "nm_d_in", VTI_NM_D_IN, OIT_FNOUNIT },
		    { "nm_h_in", VTI_NM_H_IN, OIT_FNOUNIT },
		    { "nm_v_in", VTI_NM_V_IN, OIT_FNOUNIT },
		    { "nm_x_out", VTI_NM_X_OUT, OIT_FNOUNIT },
		    { "nm_y_out", VTI_NM_Y_OUT, OIT_FNOUNIT },
		    { "nm_z_out", VTI_NM_Z_OUT, OIT_FNOUNIT },
		    { "nm_d_out", VTI_NM_D_OUT, OIT_FNOUNIT },
		    { "nm_h_out", VTI_NM_H_OUT, OIT_FNOUNIT },
		    { "nm_v_out", VTI_NM_V_OUT, OIT_FNOUNIT },
		    { "ov_reg1_name", VTI_OV_REG1_NAME, OIT_STRING },
		    { "ov_reg1_id", VTI_OV_REG1_ID, OIT_INT },
		    { "ov_reg2_name", VTI_OV_REG2_NAME, OIT_STRING },
		    { "ov_reg2_id", VTI_OV_REG2_ID, OIT_INT },
		    { "ov_sol_in", VTI_OV_SOL_IN, OIT_STRING },
		    { "ov_sol_out", VTI_OV_SOL_OUT, OIT_STRING },
		    { "ov_los", VTI_OV_LOS, OIT_FLOAT },
		    { "ov_x_in", VTI_OV_X_IN, OIT_FLOAT },
		    { "ov_y_in", VTI_OV_Y_IN, OIT_FLOAT },
		    { "ov_z_in", VTI_OV_Z_IN, OIT_FLOAT },
		    { "ov_d_in", VTI_OV_D_IN, OIT_FLOAT },
		    { "ov_x_out", VTI_OV_X_OUT, OIT_FLOAT },
		    { "ov_y_out", VTI_OV_Y_OUT, OIT_FLOAT },
		    { "ov_z_out", VTI_OV_Z_OUT, OIT_FLOAT },
		    { "ov_d_out", VTI_OV_D_OUT, OIT_FLOAT },
		    { "surf_num_in", VTI_SURF_NUM_IN, OIT_INT },
		    { "surf_num_out", VTI_SURF_NUM_OUT, OIT_INT },
		    { "claimant_count", VTI_CLAIMANT_COUNT, OIT_INT },
		    { "claimant_list", VTI_CLAIMANT_LIST, OIT_STRING },
		    { "claimant_listn", VTI_CLAIMANT_LISTN, OIT_STRING },
		    { "attributes", VTI_ATTRIBUTES, OIT_STRING },
		    { 0 }
		};
d118 8
a125 9
char		*def_fmt[] =
		{
		    "\"Origin (x y z) = (%.8f %.8f %.8f)  (h v d) = (%.4f %.4f %.4f)\nDirection (x y z) = (%.8f %.8f %.8f)  (az el) = (%.8f %.8f)\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e",
		    "\"    Region Name               Entry (x y z)              LOS  Obliq_in Attrib\n\"",
		    "\"%-20s (%9.4f %9.4f %9.4f) %8.4f %8.4f %s\n\" reg_name x_in y_in z_in los obliq_in attributes",
		    "\"\"",
		    "\"You missed the target\n\"",
		    "\"OVERLAP: '%s' and '%s' xyz_in=(%g %g %g) los=%g\n\" ov_reg1_name ov_reg2_name ov_x_in ov_y_in ov_z_in ov_los"
		};
d135 1
d152 22
a173 23
    switch (*bp)
    {
	case 'r':
	    fmt_type = FMT_RAY;
	    break;
	case 'h':
	    fmt_type = FMT_HEAD;
	    break;
	case 'p':
	    fmt_type = FMT_PART;
	    break;
	case 'f':
	    fmt_type = FMT_FOOT;
	    break;
	case 'm':
	    fmt_type = FMT_MISS;
	    break;
	case 'o':
	    fmt_type = FMT_OVLP;
	    break;
	default:
	    --bp;
	    break;
d177 11
a187 8

    switch (*bp)
    {
	case '\0':     /* display current output specs */
	    if (fmt_type == FMT_NONE)
		fprintf(stderr, "Error: No output-statement type specified\n");
	    else
		show_ospec(oi_list[fmt_type]);
d189 5
a193 6
	case '"':
	    if (fmt_type == FMT_NONE)
	    {
		fprintf(stderr, "Error: No output-statement type specified\n");
		return;
	    }
d195 6
a200 12
	default:
	    if (strncmp(bp, "default", 7) == 0)
	    {
		use_defaults = 1;
		break;
	    }
	    fprintf(stderr, "Error: Illegal format specifiation: '%s'\n",
		buffer);
	    /* fall through here */
	case '?':
	    com_usage(ctp);
	    return;
d221 2
a222 1
void parse_fmt(char *uoutspec, int outcom_type)
d242 1
a242 2
    if (*uos != '"')
    {
d244 2
a245 2
	    "parse_fmt sees first character `%c`.  Shouldn't happen.\n",
	    *uos);
d250 1
a250 2
    while (*uos != '"')
    {
d256 12
a267 13
	for (up = uos; *uos != '"'; ++uos)
	{
		if (*uos == '%') {
			if (*(uos + 1) == '%')
				++uos;
			else if (nm_cs == 1)
				break;
			else /* nm_cs == 0 */
				++nm_cs;
		}
		if (*uos == '\\')
			if (*(uos + 1) == '"')
				++uos;
d269 1
a269 1

d278 16
a293 18
	while (up != uos)
	{
	    if (*up == '\\')
		switch (*(up + 1))
		{
		    case 'n':
			*of++ = '\n';
			up += 2;
			break;
		    case '\042':
		    case '\047':
		    case '\134':
			*of++ = *(up + 1);
			up += 2;
			break;
		    default:
			*of++ = *up++;
			break;
d295 1
a295 1
	    else
d297 1
d308 1
a308 1

d312 2
a313 2
    if (up != uos)
    {
d316 2
a317 2
	    "Warning: suffix '%s' after format specification ignored\n",
	    up);
d321 1
a321 2
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next)
    {
d324 1
a324 1

d327 1
a327 2
	if (*uos == '\0')
	{
d329 1
a329 1
		"Error: Fewer output items than conversion specs\n");
d340 2
a341 3
	for (vtp = ValTab + 1; vtp -> name; ++vtp)
	    if (strcmp(vtp -> name, up) == 0)
	    {
d345 1
d347 1
a347 2
	if (vtp -> name == '\0')
	{
d356 2
a357 2
    if (*uos != '\0')
    {
d375 2
a376 1
void default_ospec (void)
d380 1
a380 2
    for (i = 0; i < FMT_NONE; ++i)
    {
a385 3
void show_ospec (outitem *oil)

				/* List of output items */
d387 5
d398 2
a399 2
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next)
	for (c = oip -> format; *c != '\0'; ++c)
d404 2
d410 1
a410 1
    for (oip = oil; oip != OUTITEM_NULL; oip = oip -> next)
d413 1
d418 2
a419 1
void report(int outcom_type)
d423 1
a423 2
    if ((outcom_type < 0) || (outcom_type >= FMT_NONE))
    {
d425 2
a426 2
	    "Illegal output-statement type: %d.  Shouldn't happen\n",
	    outcom_type);
d429 10
a438 9
    if( outf == (FILE *)NULL )  outf = stdout;
    for (oip = oi_list[outcom_type]; oip != OUTITEM_NULL; oip = oip -> next)
	switch (ValTab[oip -> code_nm].type)
	{
	    case OIT_INT:
		fprintf(outf, oip -> format, ValTab[oip -> code_nm].value.ival);
		break;
	    case OIT_FLOAT:
		fprintf(outf, oip -> format,
d440 3
a442 3
		break;
	    case OIT_FNOUNIT:
		fprintf(outf, oip -> format,
d444 7
a450 7
		break;
	    case OIT_STRING:
		fprintf(outf, oip -> format, ValTab[oip -> code_nm].value.sval);
		break;
	    default:
		fflush(stdout);
		fprintf(stderr, "Fatal: Invalid item type %d.  ",
d452 2
a453 2
		fprintf(stderr, "This shouldn't happen\n");
		bu_exit (1, NULL);
d455 1
d459 3
a461 1
void print_item (char *buffer, com_table *ctp)
d471 1
d474 6
a479 6
    switch (*bp)
    {
	case '\0':
	case '?':
	    com_usage(ctp);
	    return;
d483 1
a483 2
    while (*bp != '\0')
    {
d493 18
a510 20
	for (vtp = ValTab + 1; vtp -> name; ++vtp)
	    if (strcmp(vtp -> name, bp0) == 0)
	    {
		switch (vtp -> type)
		{
		    case OIT_INT:
			printf("%d\n", vtp -> value.ival);
			break;
		    case OIT_FLOAT:
			printf("%g\n", vtp -> value.fval * base2local);
			break;
		    case OIT_FNOUNIT:
			printf("%g\n", vtp -> value.fval);
			break;
		    case OIT_STRING:
			printf("'%s'\n", vtp -> value.sval);
			break;
		    default:
			fflush(stdout);
			fprintf(stderr, "Fatal: Invalid item type %d.  ",
d512 2
a513 2
			fprintf(stderr, "This shouldn't happen\n");
			bu_exit (1, NULL);
d517 1
d519 1
a519 2
	if (vtp -> name == '\0')
	{
d526 2
a527 1
FILE *fopenrc(void)
d534 2
a535 4
    if ((fPtr = fopen(DEF_RCF_NAME, "r")) == NULL)
    {
	if ((home = getenv("HOME")) != NULL)
	{
d545 2
a546 1
int check_conv_spec (outitem *oip)
d552 8
a559 11
    for ( ; oip != OUTITEM_NULL; oip = oip -> next)
    {
	for (cp = oip -> format; *cp != '\0'; ++cp)
		if (*cp == '%') {
			if (*(cp + 1) == '%')
				++cp;
			else
			{
				++cp;
				break;
			}
d561 2
d578 8
a585 10
	switch (*cp)
	{
	    case 'd':
	    case 'o':
	    case 'u':
	    case 'x':
		if (oi_type != OIT_INT)
		{
		    ++warnings;
		    fprintf(stderr,
d588 1
a588 1
		    fprintf(stderr,
d591 10
a600 11
		}
		break;
	    case 'f':
	    case 'e':
	    case 'E':
	    case 'g':
	    case 'G':
		if ((oi_type != OIT_FLOAT) && (oi_type != OIT_FNOUNIT))
		{
		    ++warnings;
		    fprintf(stderr,
d603 1
a603 1
		    fprintf(stderr,
d606 6
a611 7
		}
		break;
	    case 's':
		if (oi_type != OIT_STRING)
		{
		    ++warnings;
		    fprintf(stderr,
d614 1
a614 1
		    fprintf(stderr,
d617 5
a621 5
		}
		break;
	    case 'c':
		++warnings;
		fprintf(stderr,
d623 7
a629 7
		fprintf(stderr,
			" for item %s, which is a %s\n",
			ValTab[oip -> code_nm].name, oit_name(oi_type));
		break;
	    default:
		++warnings;
		fprintf(stderr,
d631 1
a631 1
		break;
d637 3
a639 1
void direct_output(char *buffer, com_table *ctp)
d649 2
a650 2
    if (*(buffer+i) == '\0')     /* display current destination */
    {
d656 1
a656 2
    if (strcmp(buffer + i, "?") == 0)
    {
d669 1
a669 1
	} else
d671 1
d700 3
a702 1
void state_file(char *buffer, com_table *ctp)
d709 3
a711 2
    if (*(buffer+i) == '\0')     /* display current state name */
    {
d716 1
a716 2
    if (strcmp(buffer + i, "?") == 0)
    {
d721 1
a721 1
    if (strcmp(buffer + i, "default") == 0)
d723 1
a723 2
    else
    {
d736 3
a738 1
void dump_state(char *buffer, com_table *ctp)
d746 1
a746 2
    if ((sfPtr = fopen(sf_name, "w")) == NULL)
    {
d763 1
a763 2
    for (f = 0; f < FMT_NONE; ++f)
    {
d784 3
a786 1
void load_state(char *buffer, com_table *ctp)
d790 1
a790 2
    if ((sfPtr = fopen(sf_name, "r")) == NULL)
    {
a799 3
void free_ospec (outitem *oil)

				/* List of output items */
d801 5
d810 1
a810 2
    while (next != OUTITEM_NULL)
    {
@


14.17
log
@pass bu_exit a NULL instead of an empty string
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.16 2007/11/21 19:49:12 erikgreenwald Exp $";
d235 1
a235 1
    strcpy(uos, uoutspec);
d529 1
d535 3
a537 3
	    rc_file_name = bu_malloc(strlen(home) + strlen(DEF_RCF_NAME) + 2,
				"rc_file_name");
	    sprintf(rc_file_name, "%s/%s", home, DEF_RCF_NAME);
d676 1
a676 1
	sprintf(new_dest, "%s", buffer + i);
d725 1
a725 1
	sprintf(new_name, "%s", buffer + i);
@


14.16
log
@exit->bu_exit where applicable
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.15 2007/09/15 16:23:18 brlcad Exp $";
d452 1
a452 1
		bu_exit (1, "");
d511 1
a511 1
			bu_exit (1, "");
@


14.15
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.14 2007/08/17 02:11:12 brlcad Exp $";
d452 1
a452 1
		exit (1);
d511 1
a511 1
			exit (1);
@


14.14
log
@comments and curlies
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.13 2007/08/16 21:39:28 brlcad Exp $";
d31 1
a31 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.13
log
@increased output precision from nirt/query_ray to 8 digits after the decimal.  was previously 2 to 4 digits depending on the field, which was particularly detrimental for reproducing shots using the limited az el values or for seeing what floating point fuzz is relevant on the origin and shot direction.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.12 2007/01/27 01:41:44 brlcad Exp $";
d206 3
a208 3
    if (use_defaults)
	if (fmt_type == FMT_NONE)
	    for (i = 0; i < FMT_NONE; ++i)
d210 2
a211 1
	else
d213 2
a214 1
    else
d216 1
d219 5
a224 4

			/* The user's output specification (format & args) */
			/* Type of output command */

@


14.12
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.11 2007/01/23 01:13:44 brlcad Exp $";
d118 1
a118 1
		    "\"Origin (x y z) = (%.2f %.2f %.2f)  (h v d) = (%.2f %.2f %.2f)\nDirection (x y z) = (%.4f %.4f %.4f)  (az el) = (%.2f %.2f)\n\" x_orig y_orig z_orig h v d_orig x_dir y_dir z_dir a e",
d120 1
a120 1
		    "\"%-20s (%9.3f %9.3f %9.3f) %8.2f %8.3f %s\n\" reg_name x_in y_in z_in los obliq_in attributes",
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d24 1
a24 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.10 2007/01/20 14:36:58 brlcad Exp $";
d218 2
a219 2
    	          	/* The user's output specification (format & args) */
   	            	/* Type of output command */
d277 1
a277 1
    	oip->format = bu_malloc(uos - up + 1, "format");
d393 1
a393 1
       		     		/* List of output items */
d535 1
a535 1
	    			"rc_file_name");
d800 1
a800 1
       		     		/* List of output items */
@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d24 1
a24 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.9 2006/01/29 08:39:28 brlcad Exp $";
@


14.9
log
@update to api changes from rt_* to bu_* for certain routines.
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d25 1
a25 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.8 2006/01/23 07:29:03 brlcad Exp $";
@


14.8
log
@stdlib.h for getenv
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.7 2006/01/23 07:06:29 brlcad Exp $";
d225 1
a225 1
    char	*mycopy;	/* Solely for handing to rt_free() */
d246 1
a246 1
	rt_free(mycopy, "Copy of user's output spec");
d335 1
a335 1
	    rt_free(mycopy, "Copy of user's output spec");
d355 1
a355 1
	    rt_free(mycopy, "Copy of user's output spec");
d366 1
a366 1
	rt_free(mycopy, "Copy of user's output spec");
d378 1
a378 1
    rt_free(mycopy, "Copy of user's output spec");
d682 1
a682 1
	    rt_free(new_dest, "new(now old)dest");
d694 1
a694 1
	rt_free(dest_string, "free dest_string");
d730 1
a730 1
	rt_free(sf_name, "new(now old)statefile");
d811 1
a811 1
	rt_free(oip -> format, "outitem.format");
d813 1
a813 1
	    rt_free((char *) oip, "outitem");
@


14.7
log
@s/rt_malloc/bu_malloc
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.6 2006/01/18 06:46:23 brlcad Exp $";
d30 1
@


14.6
log
@update copyright to 2006
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.5 2005/10/23 04:44:37 brlcad Exp $";
a29 2


a30 1

d32 1
a32 1
#include <string.h>
d34 1
a34 1
#include <strings.h>
d36 1
a37 1
#include <ctype.h>
d232 1
a232 1
    /* N.B. rt_malloc() only returns upon successful allocation */
d234 1
a234 1
    mycopy = uos = rt_malloc(strlen(uoutspec) + 1, "uos");
d253 1
a253 1
	oip = (outitem *) rt_malloc(sizeof(outitem), "output item");
d277 1
a277 1
    	oip->format = rt_malloc(uos - up + 1, "format");
d534 1
a534 1
	    rc_file_name = rt_malloc(strlen(home) + strlen(DEF_RCF_NAME) + 2,
d673 1
a673 1
	new_dest = rt_malloc(strlen(buffer + i)+1,"new_dest");
d723 1
a723 1
	new_name = rt_malloc(strlen(buffer + i)+1, "new_state_filename");
@


14.5
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d25 1
a25 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.4 2005/04/27 02:29:22 brlcad Exp $";
@


14.4
log
@get rid of HAVE_POPEN_DECL since ansi compliant compilers are expected to have it.  when we find one that's not, we can add a better dynamic check.
@
text
@d22 1
a22 1
 *	
d25 1
a25 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.3 2005/01/30 20:31:08 brlcad Exp $";
d115 1
a115 1
static char	def_sf_name[] = DEF_SF_NAME;	
d137 1
a137 1
void 
d313 1
a313 1
    
d330 1
a330 1
	
d532 1
a532 1
    
d658 1
a658 1
    
d715 1
a715 1
    
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d22 1
a22 1
 *
d25 1
a25 1
static const char RCSid[] = "$Header$";
d115 1
a115 1
static char	def_sf_name[] = DEF_SF_NAME;
d137 1
a137 1
void
d313 1
a313 1

d330 1
a330 1

d532 1
a532 1

d658 1
a658 1

d715 1
a715 1

@


14.3
log
@update copyright to 2005
@
text
@d25 1
a25 1
static const char RCSid[] = "$Header: /cvsroot/brlcad/brlcad/src/nirt/parse_fmt.c,v 14.2 2004/12/21 02:40:25 morrison Exp $";
a646 3
#if !defined(HAVE_POPEN_DECL) && !defined(CRAY2)
    RT_EXTERN(FILE *popen, (const char *command, const char *type) );
#endif
@


14.2
log
@assign copyright and GPL
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d25 1
a25 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/parse_fmt.c,v 14.1 2004/11/16 19:42:17 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 2
a2 1
/*		P A R S E _ F M T . C
d4 18
d25 1
a25 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/parse_fmt.c,v 1.4 2004/09/03 23:30:59 morrison Exp $";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/parse_fmt.c,v 1.3 2004/08/02 23:01:51 morrison Exp $";
d802 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /cvs/brlcad/src/nirt/parse_fmt.c,v 1.2 2004/06/08 22:04:30 morrison Exp $";
d15 1
a15 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header$";
d9 1
a9 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d6 1
a6 1
static const char RCSid[] = "$Header: /cvs/brlcad/nirt/parse_fmt.c,v 11.16 2004/05/10 15:30:49 erikg Exp $";
a26 1
#include "externs.h"
@

