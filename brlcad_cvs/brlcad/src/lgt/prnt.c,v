head	14.14;
access;
symbols
	rel-7-10-4:14.10
	STABLE:14.10.0.2
	stable-branch:14.3
	rel-7-10-2:14.10
	rel-7-10-0:14.9
	rel-7-8-4:14.6
	rel-7-8-2:14.6
	rel-7-8-0:14.6
	trimnurbs-branch:14.6.0.2
	help:14.6
	temp_tag:14.5
	bobWinPort-20051223-freeze:14.3
	postmerge-20051223-bobWinPort:14.5
	premerge-20051223-bobWinPort:14.5
	rel-7-6-6:14.5
	rel-7-6-4:14.5
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.14
date	2007.12.06.15.15.34;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.12.03.22.57.58;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.12.01.20.21.10;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.10.26.21.51.26;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.07.26.01.13.55;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.01.27.01.41.35;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2007.01.23.01.13.33;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2007.01.20.14.36.50;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.11.11.21.29.56;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.10.23.04.44.31;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.30.43;	author brlcad;	state Exp;
branches
	14.3.6.1;
next	14.2;

14.2
date	2004.12.21.01.23.58;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.18;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.25;	author morrison;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.14;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.14
log
@constness
@
text
@/*                          P R N T . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@file prnt.c
	Author:		Gary S. Moss
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.13 2007/12/03 22:57:58 brlcad Exp $ (BRL)";
#endif

#include "common.h"


#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <stdarg.h>

#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./tree.h"
#include "./screen.h"
#include "./ascii.h"

static char	*usage[] =
	{
"",
"Usage:",
"",
"lgt [-IOjovw file][-AGKTXacefiknps n][-G \"s c g v\"][-b \"R G B\"][-dtD \"x y\"][-xy \"a b\"] file.g object...",
"",
"The options may appear in any order; however, their parameters must",
"be present, are positional, and if there is more than one parameter",
"for an option, they must be supplied as a single argument (e.g.,",
"inside double-quotes as shown).",
"",
0
	};
static char	*lgt_menu[] =
	{
"                BRL Lighting Model (LGT) : global command set",
"",
"A factor             anti-aliasing thru over-sampling by factor (i.e. 2)",
"a roll               specify roll (angle around viewing axis) rotation to grid",
"B                    submit batch run using current context",
"b R G B              specify background-color",
"C                    use cursor input module",
"c flag               enable or disable tracking cursor",
"D x y                translate image when raytracing (WRT viewport)",
"E                    clear display",
"e bitmask            set debug flag (hexidecimal bitmask)",
"F                    animate",
"f distance           specify distance from origin of grid to model centroid",
"G size cflag gflag view_size    grid configuration",
"        if cflag == 0, size refers to no. of rays across image (default)",
"        otherwise it refers to cell size (ray separation) in millimeters.",
"        if gflag == 0, grid origin will be aligned WRT model RPP (default)",
"        otherwise it will be aligned WRT model origin",
"        if viewsize > 0.0 the field of view will be set accordingly",
"        otherwise it will be set relative to the model RPP (default)",
"H file               save frame buffer image",
"h file               read frame buffer image",
"J                    make a movie (prompts for parameters)",
"j file               input key-frame from file (as output by mged(1))",
"K bounces            maximum level of recursion in raytracing",
"k flag               enable or disable hidden line drawing",
"        if flag == 0, a lighting model image is produced (default)",
"        otherwise a hidden line drawing is produced",
"        if flag == 2, a reverse video (white-on-black) drawing is generated",
"L id                 modify light source entry id (0 to 10)",
"l id                 print light source entry id (0 to 10) or all",
"M id                 modify material data base entry id (0 to 99)",
"m id                 print material data base entry id (0 to 99) or all",
"n processors         number of processors to use (parallel environment)",
"O file               re-direct errors to specified output file",
"o file               image (output file for picture)",
"p factor             adjust perspective (0.0 to infinity)",
"q or ^D              quit",
"R                    raytrace (generate image) within current rectangle",
"r                    redraw screen",
"S file               script (save current option settings in file)",
"s                    enter infrared module",
"T size               size of frame buffer display (pixels across)",
"        By default the display window fits the grid size.  If zooming",
"        is desired, size should be a multiple of the grid size. To turn",
"        off manual sizing, set size to zero.",
"t x y                translate grid when raytracing (WRT model)",
"V file               write light source data base",
"v file               read light source data base",
"W file               write material attribute data base",
"w file               read material attribute data base",
"X flag               enable or disable reporting of overlaps",
"x start finish       set left and right border of current rectangle",
"y start finish       set bottom and top border of current rectangle",
"z ulen vlen width    size of texture map (plus width of padded lines)",
"?                    print this menu",
"! arg(s)             feed arg(s) to /bin/sh or $SHELL if set",
". flag               set buffered pixel I/O flag",
"# anything           comment or NOP (useful in preparing input files)",
	NULL
	};
static char	*ir_menu[] =
	{
"",
"                       Infrared Module: local commands",
"",
"d x y                specify automatic IR mapping offsets",
"I file               read and display IR data",
"i noise              specify noise threshold for IR data",
"N temperature        specify temperature for IR painting",
"P                    print GED regions and associated IR mappings",
"Q                    enter temperature for GED region or group",
"s                    exit IR module",
"U file               write IR data base file",
"u file               read IR data base file",
"Z                    display pseudo-color IR mapping scale",
	NULL
	};

char	screen[TOP_SCROLL_WIN+1][TEMPLATE_COLS+1];

/*	pad_Strcpy -- WARNING: this routine does NOT nul-terminate the
	destination buffer, but pads it with blanks.
 */
static void
pad_Strcpy(register char *des, register char *src, register int len)
{
	while( len > 0 && *src != '\0' )
		{
		*des++ = *src++;
		len--;
		}
	while( len-- > 0 )
		*des++ = ' ';
	return;
	}

/*	i n i t _ S t a t u s ( )					*/
void
init_Status(void)
{	register int	row, col;
	for( row = 0; row <= TOP_SCROLL_WIN; row++ )
		for( col = 0; col <= TEMPLATE_COLS; col++ )
			screen[row][col] = '\0';
	return;
	}

/*	p r n t _ S t a t u s ( )					*/
void
prnt_Status(void)
{	static char	scratchbuf[TEMPLATE_COLS+1];
	pad_Strcpy( TITLE_PTR, title, TITLE_LEN - 1 );
	pad_Strcpy( TIMER_PTR, timer, TIMER_LEN - 1 );
	pad_Strcpy( F_SCRIPT_PTR, script_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", view_size );
	(void) strncpy( VU_SIZE_PTR, scratchbuf, strlen( scratchbuf ) );
	pad_Strcpy( F_ERRORS_PTR, err_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", grid_dist );
	(void) strncpy( GRID_DIS_PTR, scratchbuf, strlen( scratchbuf ) );
	pad_Strcpy( F_MAT_DB_PTR, mat_db_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", x_grid_offset );
	(void) strncpy( GRID_XOF_PTR, scratchbuf, strlen( scratchbuf ) );
	pad_Strcpy( F_LGT_DB_PTR, lgt_db_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", y_grid_offset );
	(void) strncpy( GRID_YOF_PTR, scratchbuf, strlen( scratchbuf ) );
	pad_Strcpy( F_RASTER_PTR, fb_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", modl_radius );
	(void) strncpy( MODEL_RA_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%3d %3d %3d",
			background[0], background[1], background[2] );
	(void) strncpy( BACKGROU_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) snprintf( scratchbuf, TEMPLATE_COLS+1,
			"%4s",	pix_buffered == B_PAGE ? "PAGE" :
				pix_buffered == B_PIO ? "PIO" :
				pix_buffered == B_LINE ? "LINE" : "?"
				);
	(void) strncpy( BUFFERED_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "0x%06x", RT_G_DEBUG );
	(void) strncpy( DEBUGGER_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%-2d", max_bounce );
	(void) strncpy( MAX_BOUN_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) snprintf( scratchbuf, TEMPLATE_COLS+1, " LGT %s", version );
	(void) strncpy( PROGRAM_NM_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) snprintf( scratchbuf, TEMPLATE_COLS+1, " %s ",
			ged_file == NULL ? "(null)" : ged_file );
	(void) strncpy( F_GED_DB_PTR, scratchbuf,
			Min( strlen( scratchbuf ), 26 ) );
	(void) sprintf( scratchbuf, " [%04d-", grid_x_org );
	(void) strncpy( GRID_PIX_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%04d,", grid_x_fin );
	(void) strncpy( GRID_SIZ_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%04d-", grid_y_org );
	(void) strncpy( GRID_SCN_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%04d:", grid_y_fin );
	(void) strncpy( GRID_FIN_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%04d] ", frame_no );
	(void) strncpy( FRAME_NO_PTR, scratchbuf, strlen( scratchbuf ) );
	update_Screen();
	return;
	}

void
update_Screen(void)
{	register int	tem_co, row, col;
	tem_co = Min( co, TEMPLATE_COLS );
	for( row = 0; template[row][0] != '\0'; row++ )
		{	register int	lastcol = -2;
		if( template[row+1] == NULL )
			(void) SetStandout();
		for( col = 0; col < tem_co; col++ )
			if( screen[row][col] != template[row][col] )
				{
				if( col != lastcol+1 )
					MvCursor( col+1, row+1 );
				lastcol = col;
				(void) putchar( template[row][col] );
				screen[row][col] = template[row][col];
				}
		}
	(void) ClrStandout();
	EVENT_MOVE();
	(void) fflush( stdout );
	return;
	}

/*	p r n t _ P a g e d _ M e n u ( )				*/
void
prnt_Paged_Menu(register char **menu)
{	register int	done = FALSE;
		int		lines =	(PROMPT_LINE-TOP_SCROLL_WIN);
	if( ! tty )
		{
		for( ; *menu != NULL; menu++ )
			bu_log( "%s\n", *menu );
		return;
		}
	for( ; *menu != NULL && ! done;  )
		{
		for( ; lines > 0 && *menu != NULL; menu++, --lines )
			prnt_Scroll( "%-*s\n", co, *menu );
		if( *menu != NULL )
			done = ! do_More( &lines );
		prnt_Prompt( "" );
		}
	(void) fflush( stdout );
	return;
	}

int
do_More(int *linesp)
{	register int	ret = TRUE;
	if( ! tty )
		return	TRUE;
	save_Tty( 0 );
	set_Raw( 0 );
	clr_Echo( 0 );
	SetStandout();
	prnt_Prompt( "More ? [n|<return>|<space>] " );
	ClrStandout();
	(void) fflush( stdout );
	switch( hm_getchar() )
		{
	case 'Q' :
	case 'q' :
	case 'N' :
	case 'n' :
		ret = FALSE;
		break;
	case LF :
	case CR :
		*linesp = 1;
		break;
	default :
		*linesp = (PROMPT_LINE-TOP_SCROLL_WIN);
		break;
		}
	reset_Tty( 0 );
	return	ret;
	}


/*	p r n t _ M e n u ( )						*/
void
prnt_Menu(void)
{
	prnt_Paged_Menu( lgt_menu );
	if( ir_mapping )
		prnt_Paged_Menu( ir_menu );
	hmredraw();
	return;
	}

/*	p r n t _ P r o m p t ( )					*/
void
prnt_Prompt(char *prompt)
{
	if( tty )
		{
		PROMPT_MOVE();
		(void) ClrEOL();
		(void) SetStandout();
		(void) printf( "%s", prompt );
		(void) ClrStandout();
		(void) fflush( stdout );
		}
	return;
	}

/*	p r n t _ T i m e r ( )						*/
void
prnt_Timer(char *eventstr)
{
	(void) rt_read_timer( timer, TIMER_LEN-1 );
	if( tty )
		{
		pad_Strcpy( TIMER_PTR, timer, TIMER_LEN-1 );
		update_Screen();
		}
	else
		bu_log( "(%s) %s\n", eventstr == NULL ? "(null)" : eventstr, timer );
	return;
	}

/*	p r n t _ E v e n t ( )						*/
void
prnt_Event(char *s)
{	static int	lastlen = 0;
		register int	i;
	if( ! tty )
		return;
	EVENT_MOVE();
	if( s != NULL )
		{	register int len = strlen( s );
		(void) fputs( s, stdout );
		/* Erase last message. */
		for( i = len; i < lastlen; i++ )
			(void) putchar( ' ' );
		lastlen = len;
		}
	else
		{
		/* Erase last message. */
		for( i = 0; i < lastlen; i++ )
			(void) putchar( ' ' );
		lastlen = 0;
		}
	IDLE_MOVE();
	(void) fflush( stdout );
	return;
	}

/*	p r n t _ T i t l e ( )						*/
void
prnt_Title(char *titleptr)
{
	if( ! tty || RT_G_DEBUG )
		bu_log( "%s\n", titleptr == NULL ? "(null)" : titleptr );
	return;
	}

/*	p r n t _ U s a g e ( )
	Print usage message.
 */
void
prnt_Usage(void)
{	register char	**p = usage;
	while( *p != NULL )
		(void) fprintf( stderr, "%s\n", *p++ );
	return;
	}

/*	p r n t _ S c r o l l ( )					*/
void
prnt_Scroll(const char *fmt, ... ) {
    va_list		ap;
    /* We use the same lock as malloc.  Sys-call or mem lock, really */
    bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
    va_start( ap, fmt );
    if( tty )
	{ /* Only move cursor and scroll if newline is output.	*/
	    static int	newline = 1;
	    if( CS != NULL )
		{
		    (void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
		    if( newline )
			{
			    SCROLL_PR_MOVE();
			    (void) ClrEOL();
			}
		    (void)vfprintf( stdout, fmt, ap );
		    (void) ResetScrlReg();
		}
	    else
		if( DL != NULL )
		    {
			if( newline )
			    {
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
			    }
			(void)vfprintf( stdout, fmt, ap );
		    }
		else
		    (void)vfprintf( stdout, fmt, ap );
	    /* End of line detected by existance of a newline.	*/
	    newline = fmt[strlen( fmt )-1] == '\n';
	    hmredraw();
	}
    else
	(void)vfprintf( stderr, fmt, ap );
    va_end( ap );
    bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
    return;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.13
log
@c89 simplification.  assume stdarg is a given.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.12 2007/12/01 20:21:10 brlcad Exp $ (BRL)";
d396 1
a396 1
prnt_Scroll( char *fmt, ... ) {
@


14.12
log
@mass simplification since we can assume stdarg is available, it's c89.  remove the alternatives.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.11 2007/10/26 21:51:26 brlcad Exp $ (BRL)";
a32 1
#if defined(HAVE_STDARG_H)
a33 3
#elif defined(HAVE_VARARGS_H)
#include <varargs.h>
#endif
@


14.11
log
@yet another surge of level 4 flawfinder string length checks. somewhere around 30-40% done.
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.10 2007/07/26 01:13:55 brlcad Exp $ (BRL)";
a397 1
#if defined(HAVE_STDARG_H)
a398 1
/* VARARGS */
d400 12
a411 9
prnt_Scroll( char *fmt, ... )
	{	va_list		ap;
	/* We use the same lock as malloc.  Sys-call or mem lock, really */
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start( ap, fmt );
	if( tty )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
d413 2
a414 8
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void)vfprintf( stdout, fmt, ap );
			(void) ResetScrlReg();
d416 4
a419 1
		else
d421 1
a421 1
			{
d423 1
a423 1
				{
d428 1
a428 1
				}
d430 1
a430 47
			}
		else
			(void)vfprintf( stdout, fmt, ap );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		(void)vfprintf( stderr, fmt, ap );
	va_end( ap );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	return;
	}

#elif !defined(HAVE_VARARGS_H)

void
prnt_Scroll(fmt, a,b,c,d,e,f,g,h,i)
char *fmt;
{
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	if( tty )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
			}
d432 10
a441 8
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
a442 50
#else
/*	p r n t _ S c r o l l ( )					*/
/* VARARGS */
void
prnt_Scroll( fmt, va_alist )
char	*fmt;
va_dcl
	{	va_list		ap;
	/* We use the same lock as malloc.  Sys-call or mem lock, really */
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start( ap );
	if( tty )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) _doprnt( fmt, ap, stdout );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) _doprnt( fmt, ap, stdout );
			}
		else
			(void) _doprnt( fmt, ap, stdout );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		(void) _doprnt( fmt, ap, stderr );
	va_end( ap );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	return;
	}
#endif /* HAVE_STDARG_H */
@


14.10
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.9 2007/01/27 01:41:35 brlcad Exp $ (BRL)";
d198 1
a198 1
	(void) sprintf( scratchbuf,
d208 1
a208 1
	(void) sprintf( scratchbuf, " LGT %s", version );
d210 1
a210 1
	(void) sprintf( scratchbuf, " %s ",
@


14.9
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a21 4
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
d24 1
a24 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.8 2007/01/23 01:13:33 brlcad Exp $ (BRL)";
@


14.8
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.7 2007/01/20 14:36:50 brlcad Exp $ (BRL)";
a33 1

@


14.7
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d28 1
a28 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.6 2006/01/18 06:46:15 brlcad Exp $ (BRL)";
@


14.6
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.5 2005/11/11 21:29:56 brlcad Exp $ (BRL)";
@


14.5
log
@convert STATIC to static and obliterate the NDEBUG hacks now that it's consistent provided throughout the package via configure
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.4 2005/10/23 04:44:31 brlcad Exp $ (BRL)";
@


14.4
log
@trailing ws
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.3 2005/01/30 20:30:43 brlcad Exp $ (BRL)";
d157 1
a157 1
STATIC void
@


14.3
log
@update copyright to 2005
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/lgt/prnt.c,v 14.2 2004/12/21 01:23:58 morrison Exp $ (BRL)";
d363 1
a363 1
	EVENT_MOVE();	
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d157 1
a157 1
static void
d363 1
a363 1
	EVENT_MOVE();
@


14.2
log
@assign copyright and GPL
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/lgt/prnt.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 1
/*
d29 1
a29 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/lgt/prnt.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/lgt/prnt.c,v 1.2 2004/06/08 22:04:18 morrison Exp $ (BRL)";
d525 10
@


1.2
log
@obliterate externs.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 1
a12 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/prnt.c,v 11.9 2004/05/10 15:30:43 erikg Exp $ (BRL)";
a27 1
#include "externs.h"
@

