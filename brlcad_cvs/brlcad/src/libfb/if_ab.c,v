head	14.28;
access;
symbols
	rel-7-10-4:14.24.2.1
	STABLE:14.24.0.2
	stable-branch:14.6
	rel-7-10-2:14.23
	rel-7-10-0:14.19
	rel-7-8-4:14.15
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.6
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.28
date	2007.12.16.18.53.48;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.10.26.21.51.26;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.09.15.16.23.10;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.08.18.03.15.11;	author brlcad;	state Exp;
branches
	14.24.2.1;
next	14.23;

14.23
date	2007.07.26.01.13.56;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.05.14.18.13.41;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.05.14.18.10.53;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.05.14.18.09.51;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.08.06.47.05;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.07.10.19.06.23;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.07.09.18.25.31;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.07.09.10.53.15;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.07.09.09.50.24;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.09.16.19.14.20;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.30.12;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.48;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.58.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.15.06.41.24;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.20.04.53;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.21;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.41;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.24.2.1
date	2007.09.28.14.07.48;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.28
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                         I F _ A B . C
 * BRL-CAD
 *
 * Copyright (c) 1989-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup if */
/** @@{ */
/** @@file if_ab.c
 *
 *  Communicate with an Abekas A60 digital videodisk as if it was
 *  a framebuffer, to ease the task of loading and storing images.
 *
 *  Authors -
 *	Michael John Muuss
 *	Phillip Dykstra
 *
 */
/** @@} */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.27 2007/12/16 15:59:38 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <math.h>
#include <time.h>
#include <fcntl.h>
#include <string.h>

#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "machine.h"
#include "fb.h"


HIDDEN void	ab_log(FBIO *ifp, char *str);
HIDDEN int	ab_get_reply(int fd);
HIDDEN void	ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len);
HIDDEN void	ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len);
HIDDEN int	ab_yuvio(int, char *, char *, int, int, int);
HIDDEN int	ab_open(register FBIO *ifp, register char *file, int width, int height);
HIDDEN int	ab_close(FBIO *ifp);
HIDDEN int	ab_clear(FBIO *ifp, unsigned char *bgpp);
HIDDEN int	ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count);
HIDDEN int	ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count);
HIDDEN int	ab_rmap(register FBIO *ifp, register ColorMap *cmap);
HIDDEN int	ab_wmap(register FBIO *ifp, const ColorMap *cmap);
HIDDEN int	ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom);
HIDDEN int	ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom);
HIDDEN int	ab_cursor(FBIO *ifp, int mode, int x, int y);
HIDDEN int	ab_getcursor(FBIO *ifp, int *mode, int *x, int *y);
HIDDEN int	ab_help(FBIO *ifp);

FBIO abekas_interface = {
    0,
    ab_open,
    ab_close,
    ab_clear,
    ab_read,
    ab_write,
    ab_rmap,
    ab_wmap,
    ab_view,
    ab_getview,
    fb_null_setcursor,		/* setcursor */
    ab_cursor,
    ab_getcursor,
    fb_sim_readrect,
    fb_sim_writerect,
    fb_sim_bwreadrect,
    fb_sim_bwwriterect,
    fb_null,			/* poll */
    fb_null,			/* flush */
    ab_close,			/* free */
    ab_help,
    "Abekas A60 Videodisk, via Ethernet",
    720,				/* max width */
    486,				/* max height */
    "/dev/ab",
    720,				/* current/default width */
    486,				/* current/default height */
    -1,				/* select fd */
    -1,				/* file descriptor */
    1, 1,				/* zoom */
    360, 243,			/* window center */
    0, 0, 0,			/* cursor */
    PIXEL_NULL,			/* page_base */
    PIXEL_NULL,			/* page_curp */
    PIXEL_NULL,			/* page_endp */
    -1,				/* page_no */
    0,				/* page_ref */
    0L,				/* page_curpos */
    0L,				/* page_pixels */
    0				/* debug */
};

#define if_frame	u1.l		/* frame number on A60 disk */
#define if_mode		u2.l		/* see MODE_ and STATE_ defines */
#define if_yuv		u3.p		/* YUV image, 4th quadrant */
#define if_rgb		u4.p		/* RGB image, 1st quadrant */
#define if_host		u5.p		/* Hostname */
#define if_xyoff	u6.l		/* (x<<16) | y pixel offsets */

/*
 *  The mode has several independent bits:
 *	Center -vs- lower-left
 *	Output-only (or well-behaved read-write) -vs- conservative read-write
 *
 *  Also, the state bits ride in some of the upper bits.
 */
#define MODE_1MASK	(1<<0)
#define MODE_1CENTER	(0<<0)
#define MODE_1LOWERLEFT	(1<<0)

#define MODE_2MASK	(1<<1)
#define MODE_2READFIRST	(0<<1)
#define MODE_2OUTONLY	(1<<1)

#define MODE_3MASK	(1<<2)
#define MODE_3QUIET	(0<<2)
#define MODE_3VERBOSE	(1<<2)

#define MODE_4MASK	(1<<3)
#define MODE_4NETWORK	(0<<3)
#define MODE_4DISK	(1<<3)

#define STATE_FRAME_WAS_READ	(1<<8)
#define STATE_USER_HAS_READ	(1<<9)
#define STATE_USER_HAS_WRITTEN	(1<<10)

static struct modeflags {
    char	c;
    long	mask;
    long	value;
    char	*help;
} modeflags[] = {
    { 'l',	MODE_1MASK, MODE_1LOWERLEFT,
      "Lower left;  default=center" },
    { 'o',	MODE_2MASK, MODE_2OUTONLY,
      "Output only (in before out); default=always read first" },
    { 'v',	MODE_3MASK, MODE_3VERBOSE,
      "Verbose logging; default=quiet" },
    { 'f',	MODE_4MASK, MODE_4DISK,
      "Read/write YUV to disk file given by @@#; default=use EtherNet" },
    { '\0', 0, 0, "" }
};


/*
 *			A B _ O P E N
 *
 *  The device name is expected to have a fairly rigid format:
 *
 *	/dev/abco@@host#300
 *
 *  ie, options follow first (if any),
 *  "@@host" gives target host (else use environment variable),
 *  "#300" gives frame number (else use default frame).
 *
 *  It is intentional that the frame number is last in the sequence;
 *  this should make changing it easier with tcsh, etc.
 *
 */
HIDDEN int
ab_open(register FBIO *ifp, register char *file, int width, int height)
{
    register char	*cp;
    register int	i;
    char	message[128];
    int	mode;

    FB_CK_FBIO(ifp);
    mode = 0;

    if( file == NULL )  {
	fb_log( "ab_open: NULL device string\n" );
	return(-1);
    }

    if( strncmp( file, "/dev/ab", 7 ) != 0 )  {
	fb_log("ab_open: bad device '%s'\n", file );
	return(-1);
    }

    /* Process any options */
    for( cp = &file[7]; *cp != '\0'; cp++)  {
	register struct	modeflags *mfp;

	if( *cp == '@@' || *cp == '#' )  break;
	for( mfp = modeflags; mfp->c != '\0'; mfp++ )  {
	    if( mfp->c != *cp )  continue;
	    mode = (mode & ~(mfp->mask)) | mfp->value;
	    break;
	}
	if( mfp->c == '\0' )  {
	    fb_log("ab_open: unknown option '%c' ignored\n", *cp);
	}
    }
    ifp->if_mode = mode;

    /* Process host name */
    if( *cp == '@@' )  {
	register char	*ep;

	cp++;			/* advance over '@@' */

	/* Measure length, allocate memory for string */
	for( ep=cp; *ep != '\0' && *ep != '#'; ep++ ) /* NULL */ ;
	ifp->if_host = (char *)malloc(ep-cp+2);

	ep = ifp->if_host;
	for( ; *cp != '\0' && *cp != '#'; )
	    *ep++ = *cp++;
	*ep++ = '\0';
    } else if( *cp != '#' && *cp != '\0' )  {
	fb_log("ab_open: error in file spec '%s'\n", cp);
	return(-1);
    } else {
	/* Get hostname from environment variable */
	if( (ifp->if_host = getenv("ABEKAS")) == NULL )  {
	    if( (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK )  {
		fb_log("ab_open: hostname not given and ABEKAS environment variable not set\n");
		return(-1);
	    } else {
		/* Here, "host" is a filename prefix. */
		ifp->if_host = "";
	    }
	}
    }

    /* Process frame number */
    ifp->if_frame = -1;		/* default to frame store */
    if( *cp == '#' )  {
	register int	i;

	i = atoi(cp+1);
	if( (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK )  {
	    /* Perform validity checking on frame numbers */
	    if( i >= 50*30 )  {
		fb_log("ab_open: frame %d out of range\n", i);
		return(-1);
	    }
	    if( i < 0 ) {
		fb_log("ab_open: frame < 0, using frame store\n");
	    }
	}
	ifp->if_frame = i;
    } else if( *cp != '\0' )  {
	fb_log("ab_open: error in file spec '%s'\n", cp);
	return(-1);
    }

    /* Allocate memory for YUV and RGB buffers */
    if( (ifp->if_yuv = malloc(720*486*2)) == NULL ||
	(ifp->if_rgb = malloc(720*486*3)) == NULL )  {
	fb_log("ab_open: unable to malloc buffer\n");
	return(-1);
    }

    /* Handle size defaulting and checking */
    if( width <= 0 )
	width = ifp->if_width;
    if( height <= 0 )
	height = ifp->if_height;
    if ( width > ifp->if_max_width )
	width = ifp->if_max_width;
    if ( height > ifp->if_max_height)
	height = ifp->if_max_height;
    ifp->if_width = width;
    ifp->if_height = height;

    /* X and Y offsets if centering & non-full size */
    ifp->if_xyoff = 0;
    if( (ifp->if_mode & MODE_1MASK) == MODE_1CENTER )  {
	if( width < ifp->if_max_width )  {
	    i = (ifp->if_max_width - width)/2;
	    ifp->if_xyoff = i<<16;
	}
	if( height < ifp->if_max_height )  {
	    i = (ifp->if_max_height - height)/2;
	    i &= ~1;	/* preserve field alignment */
	    ifp->if_xyoff |= i;
	}
    }


    /*
     *  If "output-only" mode was set, clear the frame to black.
     */
    if( (ifp->if_mode & MODE_2MASK) == MODE_2OUTONLY )  {
	(void)ab_clear( ifp, PIXEL_NULL );
	/* This sets STATE_USER_HAS_WRITTEN */
    }

    if( ifp->if_xyoff )  {
	sprintf(message,"ab_open %d*%d xoff=%ld yoff=%ld",
		ifp->if_width, ifp->if_height,
		ifp->if_xyoff>>16, ifp->if_xyoff&0xFFFF );
    } else {
	sprintf(message,"ab_open %d*%d",
		ifp->if_width, ifp->if_height);
    }
    ab_log(ifp, message);

    return( 0 );			/* OK */
}

/*
 *			A B _ L O G
 *
 *  If verbose mode is enabled, print the time and a message
 */
HIDDEN void ab_log(FBIO *ifp, char *str)
{
    time_t		now;
    struct tm	*tmp;

    if( (ifp->if_mode & MODE_3MASK) != MODE_3VERBOSE )  return;

    (void)time( &now );
    tmp = localtime( &now );
    if( ifp->if_frame < 0 ) {
	fb_log("%2.2d:%2.2d:%2.2d %s frame store: %s\n",
	       tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
	       ifp->if_host, str );
    } else {
	fb_log("%2.2d:%2.2d:%2.2d %s frame %d: %s\n",
	       tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
	       ifp->if_host, ifp->if_frame, str );
    }
}

/*
 *			A B _ R E A D F R A M E
 */
HIDDEN int
ab_readframe(FBIO *ifp)
{
    register int	y;

    ab_log(ifp, "Reading frame");
    if( ab_yuvio( 0, ifp->if_host, ifp->if_yuv,
		  720*486*2, ifp->if_frame,
		  (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK
		  ) != 720*486*2 )  {
	fb_log("ab_readframe(%d): unable to get frame from %s!\n",
	       ifp->if_frame, ifp->if_host);
	return(-1);
    }

    /* convert YUV to RGB */
    ab_log(ifp, "Converting YUV to RGB");
    for( y=0; y < 486; y++ )  {
	unsigned char *rgb = (unsigned char *)&ifp->if_rgb[(486-1-y)*720*3];
	unsigned char *yuv = (unsigned char *)&ifp->if_yuv[y*720*2];
	ab_yuv_to_rgb(rgb, yuv, 720);
    }
    ab_log(ifp, "Conversion done");

    ifp->if_mode |= STATE_FRAME_WAS_READ;
    return(0);			/* OK */
}

/*
 *			A B _ C L O S E
 */
HIDDEN int
ab_close(FBIO *ifp)
{
    int	ret = 0;

    if( ifp->if_mode & STATE_USER_HAS_WRITTEN )  {
	register int y;		/* in Abekas coordinates */

	/* Convert RGB to YUV */
	ab_log(ifp, "Converting RGB to YUV");
	for( y=0; y < 486; y++ )  {
	    unsigned char *yuv = (unsigned char *)&ifp->if_yuv[y*720*2];
	    unsigned char *rgb = (unsigned char *)&ifp->if_rgb[(486-1-y)*720*3];
	    ab_rgb_to_yuv(yuv, rgb, 720);
	}
	ab_log(ifp, "Writing frame");

	if( ab_yuvio( 1, ifp->if_host, ifp->if_yuv,
		      720*486*2, ifp->if_frame,
		      (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK
		      ) != 720*486*2 )  {
	    fb_log("ab_close: unable to send frame %d to A60 %s!\n",
		   ifp->if_frame, ifp->if_host);
	    ret = -1;
	}
	ab_log(ifp, "Transmission done");
    }

    /* Free dynamic memory */
    free( ifp->if_yuv );
    ifp->if_yuv = NULL;
    free( ifp->if_rgb );
    ifp->if_rgb = NULL;

    ab_log(ifp, "ab_close");
    return(ret);
}

/*
 *			A B _ C L E A R
 */
HIDDEN int
ab_clear(FBIO *ifp, unsigned char *bgpp)
{
    register int	r,g,b;
    register int	count;
    register char	*cp;

    if( bgpp == PIXEL_NULL )  {
	/* Clear to black */
	memset(ifp->if_rgb, 0, 720*486*3);
    } else {
	r = (bgpp)[RED];
	g = (bgpp)[GRN];
	b = (bgpp)[BLU];

	cp = ifp->if_rgb;
	for( count = 720*486-1; count >= 0; count-- )  {
	    *cp++ = r;
	    *cp++ = g;
	    *cp++ = b;
	}
    }

    ifp->if_mode |= STATE_USER_HAS_WRITTEN;
    return(0);
}

/*
 *			A B _ R E A D
 */
HIDDEN int
ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count)
{
    register short		scan_count;	/* # pix on this scanline */
    register char		*cp;
    int			ret;
    int			xoff, yoff;

    if( count <= 0 )
	return(0);

    if( x < 0 || x > ifp->if_width ||
	y < 0 || y > ifp->if_height)
	return(-1);

    if( (ifp->if_mode & STATE_FRAME_WAS_READ) == 0 )  {
	if( (ifp->if_mode & STATE_USER_HAS_WRITTEN) != 0 )  {
	    fb_log("ab_read:  WARNING out-only mode set & pixels were written.  Subsequent read operation is unsafe\n");
	    /* Give him whatever is in the buffer */
	} else {
	    /* Read in the frame */
	    if( ab_readframe(ifp) < 0 )  return(-1);
	}
    }

    xoff = ifp->if_xyoff>>16;
    yoff = ifp->if_xyoff & 0xFFFF;

    /* Copy from if_rgb[] */
    ret = 0;
    cp = (char *)(pixelp);

    while( count )  {
	if( y >= ifp->if_height )
	    break;

	if ( count >= ifp->if_width-x )
	    scan_count = ifp->if_width-x;
	else
	    scan_count = count;

	memcpy(cp, &ifp->if_rgb[((y+yoff)*720+(x+xoff))*3], scan_count*3);
	cp += scan_count * 3;
	ret += scan_count;
	count -= scan_count;
	/* Advance upwards */
	x = 0;
	y++;
    }
    ifp->if_mode |= STATE_USER_HAS_READ;
    return(ret);
}

/*
 *			A B _ W R I T E
 */
HIDDEN int
ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
{
    register short		scan_count;	/* # pix on this scanline */
    register const unsigned char	*cp;
    int			ret;
    int			xoff, yoff;

    if( count <= 0 )
	return(0);

    if( x < 0 || x > ifp->if_width ||
	y < 0 || y > ifp->if_height)
	return(-1);

    /*
     *  If this is the first write, and the frame has not
     *  yet been read, then read it.
     */
    if( (ifp->if_mode & STATE_FRAME_WAS_READ) == 0 &&
	(ifp->if_mode & STATE_USER_HAS_WRITTEN) == 0 )  {
	/* Read in the frame first */
	(void)ab_readframe(ifp);
    }

    xoff = ifp->if_xyoff>>16;
    yoff = ifp->if_xyoff & 0xFFFF;

    /* Copy from if_rgb[] */
    ret = 0;
    cp = (pixelp);

    while( count )  {
	if( y >= ifp->if_height )
	    break;

	if ( count >= ifp->if_width-x )
	    scan_count = ifp->if_width-x;
	else
	    scan_count = count;

	memcpy(&ifp->if_rgb[((y+yoff)*720+(x+xoff))*3], (char *)cp, scan_count*sizeof(RGBpixel));
	cp += scan_count * sizeof(RGBpixel);
	ret += scan_count;
	count -= scan_count;
	/* Advance upwards */
	x = 0;
	y++;
    }
    ifp->if_mode |= STATE_USER_HAS_WRITTEN;
    return(ret);
}

/*
 */
HIDDEN int
ab_cursor(FBIO *ifp, int mode, int x, int y)
{
    fb_sim_cursor(ifp, mode, x, y);

    return(-1);
}

/*
 */
HIDDEN int
ab_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
    fb_sim_getcursor(ifp, mode, x, y);

    return(-1);
}

/*
 */
HIDDEN int
ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
    fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);

    return(-1);
}

/*
 */
HIDDEN int
ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
    fb_sim_getview(ifp, xcenter, ycenter, xzoom, yzoom);

    return(-1);
}

HIDDEN int
ab_rmap(register FBIO *ifp, register ColorMap *cmap)
{
    register int	i;

    for( i = 0; i < 256; i++ ) {
	cmap->cm_red[i] = i<<8;
	cmap->cm_green[i] = i<<8;
	cmap->cm_blue[i] = i<<8;
    }
    return(0);
}

HIDDEN int
ab_wmap(register FBIO *ifp, const ColorMap *cmap)
{
    /* Just pretend it worked OK */
    return(0);
}

/*
 *			A B _ H E L P
 */
HIDDEN int
ab_help(FBIO *ifp)
{
    struct	modeflags *mfp;

    fb_log( "Abekas A60 Ethernet Interface\n" );
    fb_log( "Device: %s\n", ifp->if_name );
    fb_log( "Maximum width height: %d %d\n",
	    ifp->if_max_width,
	    ifp->if_max_height );
    fb_log( "Default width height: %d %d\n",
	    ifp->if_width,
	    ifp->if_height );
    fb_log( "A60 Host: %s\n", ifp->if_host );
    if( ifp->if_frame < 0 ) {
	fb_log( "Frame: store\n" );
    } else {
	fb_log( "Frame: %d\n", ifp->if_frame );
    }
    fb_log( "Usage: /dev/ab[options][@@host][#framenumber]\n" );
    fb_log( "       If no framenumber is given, the frame store is used\n" );
    for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
	fb_log( "   %c   %s\n", mfp->c, mfp->help );
    }

    return(0);
}

/*
 *			A B _ Y U V I O
 *
 *  Input or output a full frame image from the Abekas using the RCP
 *  protocol.
 *
 *  Returns -
 *	-1	error
 *	len	successful count
 */
int
ab_yuvio(int output, char *host, char *buf, int len, int frame, int to_network)
     /* 0=read(input), 1=write(output) */
     /* frame number */
{
    struct sockaddr_in	sinme;		/* Client */
    struct sockaddr_in	sinhim;		/* Server */
    struct servent		*rlogin_service;
    struct hostent		*hp;
    char			xmit_buf[128] = {0};
    int			n;
    int			netfd;
    int			got;

    if( !to_network )  {
	if( frame >= 0 )
	    snprintf( xmit_buf, 128, "%s%d.yuv", host, frame );
	else
	    snprintf( xmit_buf, 128, "%s.yuv", host);
	if( output )
	    netfd = creat( xmit_buf, 0444 );
	else
	    netfd = open( xmit_buf, 0 );
	if( netfd < 0 )  {
	    perror( xmit_buf );
	    return -1;
	}
	if( output )
	    got = write( netfd, buf, len );
	else
	    got = bu_mread( netfd, buf, len );
	if( got != len )  {
	    perror("read/write");
	    fb_log("ab_yuvio file read/write error, len=%d, got=%d\n", len, got );
	    goto err;
	}
	(void)close(netfd);
	return got;		/* OK */
    }

    memset((char *)&sinhim, 0, sizeof(sinhim));
    memset((char *)&sinme, 0, sizeof(sinme));

    if( (rlogin_service = getservbyname("shell", "tcp")) == NULL )  {
	fb_log("getservbyname(shell,tcp) fail\n");
	return(-1);
    }
    sinhim.sin_port = rlogin_service->s_port;

    if( atoi( host ) > 0 )  {
	/* Numeric */
	sinhim.sin_family = AF_INET;
	sinhim.sin_addr.s_addr = inet_addr(host);
    } else {
	if( (hp = gethostbyname(host)) == NULL )  {
	    fb_log("gethostbyname(%s) fail\n", host);
	    return(-1);
	}
	sinhim.sin_family = hp->h_addrtype;
	memcpy((char *)&sinhim.sin_addr, hp->h_addr, hp->h_length);
    }

    if( (netfd = socket(sinhim.sin_family, SOCK_STREAM, 0)) < 0 )  {
	perror("socket()");
	return(-1);
    }
    sinme.sin_port = 0;		/* let kernel pick it */

    if( bind(netfd, (struct sockaddr *)&sinme, sizeof(sinme)) < 0 )  {
	perror("bind()");
	goto err;
    }

    if( connect(netfd, (struct sockaddr *)&sinhim, sizeof(sinhim)) < 0 ) {
	perror("connect()");
	goto err;
    }

    /*
     *  Connection established.  Now, speak the RCP protocol.
     */

    /* Indicate that standard error is not connected */
    if( write( netfd, "\0", 1 ) != 1 )  {
	perror("write()");
	goto err;
    }

    /* Write local and remote user names, null terminated */
    if( write( netfd, "a60libfb\0", 9 ) != 9 )  {
	perror("write()");
	goto err;
    }
    if( write( netfd, "a60libfb\0", 9 ) != 9 )  {
	perror("write()");
	goto err;
    }
    if( ab_get_reply(netfd) < 0 )  goto err;

    if( output )  {
	/* Output from buffer to A60 */
	/* Send command, null-terminated */
	if( frame < 0 )
	    sprintf( xmit_buf, "rcp -t store.yuv" );
	else
	    sprintf( xmit_buf, "rcp -t %d.yuv", frame );
	n = strlen(xmit_buf)+1;		/* include null */
	if( write( netfd, xmit_buf, n ) != n )  {
	    perror("write()");
	    goto err;
	}
	if( ab_get_reply(netfd) < 0 )  goto err;

	/* Send Access flags, length, old name */
	if( frame < 0 )
	    sprintf( xmit_buf, "C0664 %d store.yuv\n", len );
	else
	    sprintf( xmit_buf, "C0664 %d %d.yuv\n", len, frame );
	n = strlen(xmit_buf);
	if( write( netfd, xmit_buf, n ) != n )  {
	    perror("write()");
	    goto err;
	}
	if( ab_get_reply(netfd) < 0 )  goto err;

	if( (got = write( netfd, buf, len )) != len )  {
	    perror("write()");
	    goto err;
	}

	/* Send final go-ahead */
	if( (got = write( netfd, "\0", 1 )) != 1 )  {
	    fb_log("go-ahead write got %d\n", got);
	    perror("write()");
	    goto err;
	}
	if( (got = ab_get_reply(netfd)) < 0 )  {
	    fb_log("get_reply got %d\n", got);
	    goto err;
	}

	(void)close(netfd);
	return(len);		/* OK */
    } else {
	register char	*cp;
	int		perm;
	int		src_size;
	/* Input from A60 into buffer */
	/* Send command, null-terminated */
	if( frame < 0 )
	    sprintf( xmit_buf, "rcp -f store.yuv" );
	else
	    sprintf( xmit_buf, "rcp -f %d.yuv", frame );
	n = strlen(xmit_buf)+1;		/* include null */
	if( write( netfd, xmit_buf, n ) != n )  {
	    perror("write()");
	    goto err;
	}

	/* Send go-ahead */
	if( write( netfd, "\0", 1 ) != 1 )  {
	    perror("write()");
	    goto err;
	}

	/* Read up to a newline */
	cp = xmit_buf;
	for(;;)  {
	    if( read( netfd, cp, 1 ) != 1 )  {
		perror("read()");
		goto err;
	    }
	    if( *cp == '\n' )  break;
	    cp++;
	    if( (cp - xmit_buf) >= sizeof(xmit_buf) )  {
		fb_log("cmd buffer overrun\n");
		goto err;
	    }
	}
	*cp++ = '\0';
	/* buffer will contain old permission, size, old name */
	src_size = 0;
	if( sscanf( xmit_buf, "C%o %d", (unsigned int *)&perm, &src_size ) != 2 )  {
	    fb_log("sscanf error\n");
	    goto err;
	}

	/* Send go-ahead */
	if( write( netfd, "\0", 1 ) != 1 )  {
	    perror("write()");
	    goto err;
	}

	/* Read data */
	if( (got = bu_mread( netfd, buf, len )) != len )  {
	    fb_log("bu_mread len=%d, got %d\n", len, got );
	    goto err;
	}

	/* Send go-ahead */
	if( write( netfd, "\0", 1 ) != 1 )  {
	    perror("write()");
	    goto err;
	}
	(void)close(netfd);
	return(len);		/* OK */
    }

 err:
    (void)close(netfd);
    return(-1);
}

HIDDEN int
ab_get_reply(int fd)
{
    char	rep_buf[128];
    int	got;

    if( (got = read( fd, rep_buf, sizeof(rep_buf) )) < 0 )  {
	perror("ab_get_reply()/read()");
	fb_log("ab_get_reply() read error\n");
	return(-1);
    }

    if( got == 0 )  {
	fb_log("ab_get_reply() unexpected EOF\n");
	return(-2);		/* EOF seen */
    }

    /* got >= 1 */
    if( rep_buf[0] == 0 )
	return(0);		/* OK */

    if( got == 1 )  {
	fb_log("ab_get_reply() error reply code, no attached message\n");
	return(-3);
    }

    /* Print error code received from other end */
    fb_log("ab_get_reply() error='%s'\n", &rep_buf[1] );
    return(-4);
}


/*************************************************************************
 *************************************************************************
 *  Herein lies the conversion between YUV and RGB
 *************************************************************************
 *************************************************************************
 */
/*  A 4:2:2 framestore uses 2 bytes per pixel.  The even pixels (from 0)
 *  hold Cb and Y, the odd pixels Cr and Y.  Thus a scan line has:
 *      Cb Y Cr Y Cb Y Cr Y ...
 *  If we are at an even pixel, we use the Cr value following it.  If
 *  we are at an odd pixel, we use the Cb value following it.
 *
 *  Y:       0 .. 219 range, offset by 16   [16 .. 235]
 *  U, V: -112 .. +112 range, offset by 128 [16 .. 240]
 */

#define	VDOT(a,b)	(a[0]*b[0]+a[1]*b[1]+a[2]*b[2])
#define	V5DOT(a,b)	(a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]+a[4]*b[4])
#define	CLIP(out,in)		{ register int t; \
		if( (t = (in)) < 0 )  (out) = 0; \
		else if( t >= 255 )  (out) = 255; \
		else (out) = t; }

#define	LINE_LENGTH	720
#define	FRAME_LENGTH	486

static double	y_weights[] = {  0.299,   0.587,   0.114 };
static double	u_weights[] = { -0.1686, -0.3311,  0.4997 };
static double	v_weights[] = {  0.4998, -0.4185, -0.0813 };

static double	y_filter[] = { -0.05674, 0.01883, 1.07582, 0.01883, -0.05674 };
static double	u_filter[] = {  0.14963, 0.22010, 0.26054, 0.22010,  0.14963 };
static double	v_filter[] = {  0.14963, 0.22010, 0.26054, 0.22010,  0.14963 };

static double	ybuf[724];
static double	ubuf[724];
static double	vbuf[724];

/* RGB to YUV */
HIDDEN void
ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len)
{
    register unsigned char *cp;
    register double	*yp, *up, *vp;
    register int	i;
    static int	first=1;

    if(first)  {
	/* SETUP */
	for( i = 0; i < 5; i++ ) {
	    y_filter[i] *= 219.0/255.0;
	    u_filter[i] *= 224.0/255.0;
	    v_filter[i] *= 224.0/255.0;
	}
	first = 0;
    }

    /* Matrix RGB's into separate Y, U, and V arrays */
    yp = &ybuf[2];
    up = &ubuf[2];
    vp = &vbuf[2];
    cp = rgb_buf;
    for( i = len; i; i-- ) {
	*yp++ = VDOT( y_weights, cp );
	*up++ = VDOT( u_weights, cp );
	*vp++ = VDOT( v_weights, cp );
	cp += 3;
    }

    /* filter, scale, and sample YUV arrays */
    yp = ybuf;
    up = ubuf;
    vp = vbuf;
    cp = yuv_buf;
    for( i = len/2; i; i-- ) {
	*cp++ = V5DOT(u_filter,up) + 128.0;	/* u */
	*cp++ = V5DOT(y_filter,yp) + 16.0;	/* y */
	*cp++ = V5DOT(v_filter,vp) + 128.0;	/* v */
	yp++;
	*cp++ = V5DOT(y_filter,yp) + 16.0;	/* y */
	yp++;
	up += 2;
	vp += 2;
    }
}

/* YUV to RGB */
HIDDEN void
ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len)
{
    register unsigned char *rgbp;
    register unsigned char *yuvp;
    register double	y;
    register double	u = 0.0;
    register double	v;
    register int	pixel;
    int		last;

    /* Input stream looks like:  uy  vy  uy  vy  */

    rgbp = rgb_buf;
    yuvp = yuv_buf;
    last = len/2;
    for( pixel = last; pixel; pixel-- ) {
	/* even pixel, get y and next v */
	if( pixel == last ) {
	    u = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);
	}
	y = ((double)(((int)*yuvp++) - 16)) * (255.0/219.0);
	v = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);

	CLIP( *rgbp++, y + 1.4026 * v);			/* R */
	CLIP( *rgbp++, y - 0.3444 * u - 0.7144 * v);	/* G */
	CLIP( *rgbp++, y + 1.7730 * u);			/* B */

	/* odd pixel, got v already, get y and next u */
	y = ((double)(((int)*yuvp++) - 16)) * (255.0/219.0);
	if( pixel != 1 ) {
	    u = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);
	}

	CLIP( *rgbp++, y + 1.4026 * v);			/* R */
	CLIP( *rgbp++, y - 0.3444 * u - 0.7144 * v);	/* G */
	CLIP( *rgbp++, y + 1.7730 * u);			/* B */
    }
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.27
log
@convert all bzero calls to memset
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.26 2007/10/26 21:51:26 brlcad Exp $ (BRL)";
d502 1
a502 2
	bcopy( &ifp->if_rgb[((y+yoff)*720+(x+xoff))*3], cp,
	       scan_count*3 );
d558 1
a558 2
	bcopy( (char *)cp, &ifp->if_rgb[((y+yoff)*720+(x+xoff))*3],
	       scan_count*sizeof(RGBpixel) );
d730 1
a730 1
	bcopy(hp->h_addr, (char *)&sinhim.sin_addr, hp->h_length);
@


14.26
log
@yet another surge of level 4 flawfinder string length checks. somewhere around 30-40% done.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.25 2007/09/15 16:23:10 brlcad Exp $ (BRL)";
d440 1
a440 1
	bzero( ifp->if_rgb, 720*486*3 );
d713 2
a714 2
    bzero((char *)&sinhim, sizeof(sinhim));
    bzero((char *)&sinme, sizeof(sinme));
@


14.25
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.24 2007/08/18 03:15:11 brlcad Exp $ (BRL)";
d689 1
a689 1
	    sprintf( xmit_buf, "%s%d.yuv", host, frame );
d691 1
a691 1
	    sprintf( xmit_buf, "%s.yuv", host);
@


14.24
log
@remove the fblocal.h header file.  it was only used in three places (two files) and only contained one macro (wrapper to fb_log an error), so keep it simple until it's really needed.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.23 2007/07/26 01:13:56 brlcad Exp $ (BRL)";
d47 1
a54 6
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif

@


14.24.2.1
log
@merge from head, make linger the default framebuffer action instead of transient for all windowing framebuffer interfaces.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.25 2007/09/15 16:23:10 brlcad Exp $ (BRL)";
a46 1
#include <string.h>
d54 6
@


14.23
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.22 2007/05/14 18:13:41 brlcad Exp $ (BRL)";
a61 1
#include "./fblocal.h"
@


14.22
log
@one decl per line
@
text
@a30 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.21 2007/05/14 18:10:53 brlcad Exp $ (BRL)";
@


14.21
log
@ws
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.20 2007/05/14 18:09:51 brlcad Exp $ (BRL)";
d75 12
a86 13

HIDDEN int	ab_open(register FBIO *ifp, register char *file, int width, int height),
    ab_close(FBIO *ifp),
    ab_clear(FBIO *ifp, unsigned char *bgpp),
    ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count),
    ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
    ab_rmap(register FBIO *ifp, register ColorMap *cmap),
    ab_wmap(register FBIO *ifp, const ColorMap *cmap),
    ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
    ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
    ab_cursor(FBIO *ifp, int mode, int x, int y),
    ab_getcursor(FBIO *ifp, int *mode, int *x, int *y),
    ab_help(FBIO *ifp);
@


14.20
log
@quell warning about char* to unsigned char* conversion
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.19 2007/01/27 01:41:37 brlcad Exp $ (BRL)";
d77 11
a87 11
		ab_close(FBIO *ifp),
		ab_clear(FBIO *ifp, unsigned char *bgpp),
		ab_read(register FBIO *ifp, int x, register int y, unsigned char *pixelp, int count),
		ab_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		ab_rmap(register FBIO *ifp, register ColorMap *cmap),
		ab_wmap(register FBIO *ifp, const ColorMap *cmap),
		ab_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		ab_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		ab_cursor(FBIO *ifp, int mode, int x, int y),
		ab_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		ab_help(FBIO *ifp);
d90 40
a129 40
	0,
	ab_open,
	ab_close,
	ab_clear,
	ab_read,
	ab_write,
	ab_rmap,
	ab_wmap,
	ab_view,
	ab_getview,
	fb_null_setcursor,		/* setcursor */
	ab_cursor,
	ab_getcursor,
	fb_sim_readrect,
	fb_sim_writerect,
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	fb_null,			/* poll */
	fb_null,			/* flush */
	ab_close,			/* free */
	ab_help,
	"Abekas A60 Videodisk, via Ethernet",
	720,				/* max width */
	486,				/* max height */
	"/dev/ab",
	720,				/* current/default width */
	486,				/* current/default height */
	-1,				/* select fd */
	-1,				/* file descriptor */
	1, 1,				/* zoom */
	360, 243,			/* window center */
	0, 0, 0,			/* cursor */
	PIXEL_NULL,			/* page_base */
	PIXEL_NULL,			/* page_curp */
	PIXEL_NULL,			/* page_endp */
	-1,				/* page_no */
	0,				/* page_ref */
	0L,				/* page_curpos */
	0L,				/* page_pixels */
	0				/* debug */
d167 4
a170 4
	char	c;
	long	mask;
	long	value;
	char	*help;
d172 9
a180 9
	{ 'l',	MODE_1MASK, MODE_1LOWERLEFT,
		"Lower left;  default=center" },
	{ 'o',	MODE_2MASK, MODE_2OUTONLY,
		"Output only (in before out); default=always read first" },
	{ 'v',	MODE_3MASK, MODE_3VERBOSE,
		"Verbose logging; default=quiet" },
	{ 'f',	MODE_4MASK, MODE_4DISK,
		"Read/write YUV to disk file given by @@#; default=use EtherNet" },
	{ '\0', 0, 0, "" }
d202 4
a205 4
	register char	*cp;
	register int	i;
	char	message[128];
	int	mode;
d207 2
a208 2
	FB_CK_FBIO(ifp);
	mode = 0;
d210 4
a213 4
	if( file == NULL )  {
		fb_log( "ab_open: NULL device string\n" );
		return(-1);
	}
d215 4
a218 4
	if( strncmp( file, "/dev/ab", 7 ) != 0 )  {
		fb_log("ab_open: bad device '%s'\n", file );
		return(-1);
	}
d220 38
a257 32
	/* Process any options */
	for( cp = &file[7]; *cp != '\0'; cp++)  {
		register struct	modeflags *mfp;

		if( *cp == '@@' || *cp == '#' )  break;
		for( mfp = modeflags; mfp->c != '\0'; mfp++ )  {
			if( mfp->c != *cp )  continue;
			mode = (mode & ~(mfp->mask)) | mfp->value;
			break;
		}
		if( mfp->c == '\0' )  {
			fb_log("ab_open: unknown option '%c' ignored\n", *cp);
		}
	}
	ifp->if_mode = mode;

	/* Process host name */
	if( *cp == '@@' )  {
		register char	*ep;

		cp++;			/* advance over '@@' */

		/* Measure length, allocate memory for string */
		for( ep=cp; *ep != '\0' && *ep != '#'; ep++ ) /* NULL */ ;
		ifp->if_host = (char *)malloc(ep-cp+2);

		ep = ifp->if_host;
		for( ; *cp != '\0' && *cp != '#'; )
			*ep++ = *cp++;
		*ep++ = '\0';
	} else if( *cp != '#' && *cp != '\0' )  {
		fb_log("ab_open: error in file spec '%s'\n", cp);
d259 11
a269 34
	} else {
		/* Get hostname from environment variable */
		if( (ifp->if_host = getenv("ABEKAS")) == NULL )  {
			if( (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK )  {
				fb_log("ab_open: hostname not given and ABEKAS environment variable not set\n");
				return(-1);
			} else {
				/* Here, "host" is a filename prefix. */
				ifp->if_host = "";
			}
		}
	}

	/* Process frame number */
	ifp->if_frame = -1;		/* default to frame store */
	if( *cp == '#' )  {
		register int	i;

		i = atoi(cp+1);
		if( (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK )  {
			/* Perform validity checking on frame numbers */
			if( i >= 50*30 )  {
				fb_log("ab_open: frame %d out of range\n", i);
				return(-1);
			}
			if( i < 0 ) {
				fb_log("ab_open: frame < 0, using frame store\n");
			}
		}
		ifp->if_frame = i;
	} else if( *cp != '\0' )  {
		fb_log("ab_open: error in file spec '%s'\n", cp);
		return(-1);
	}
d271 5
a275 4
	/* Allocate memory for YUV and RGB buffers */
	if( (ifp->if_yuv = malloc(720*486*2)) == NULL ||
	    (ifp->if_rgb = malloc(720*486*3)) == NULL )  {
		fb_log("ab_open: unable to malloc buffer\n");
d277 10
a286 27
	}

	/* Handle size defaulting and checking */
	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	if ( width > ifp->if_max_width )
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height)
		height = ifp->if_max_height;
	ifp->if_width = width;
	ifp->if_height = height;

	/* X and Y offsets if centering & non-full size */
	ifp->if_xyoff = 0;
	if( (ifp->if_mode & MODE_1MASK) == MODE_1CENTER )  {
		if( width < ifp->if_max_width )  {
			i = (ifp->if_max_width - width)/2;
			ifp->if_xyoff = i<<16;
		}
		if( height < ifp->if_max_height )  {
			i = (ifp->if_max_height - height)/2;
			i &= ~1;	/* preserve field alignment */
			ifp->if_xyoff |= i;
		}
	}
d288 6
d295 44
a338 17
	/*
	 *  If "output-only" mode was set, clear the frame to black.
	 */
	if( (ifp->if_mode & MODE_2MASK) == MODE_2OUTONLY )  {
		(void)ab_clear( ifp, PIXEL_NULL );
		/* This sets STATE_USER_HAS_WRITTEN */
	}

	if( ifp->if_xyoff )  {
		sprintf(message,"ab_open %d*%d xoff=%ld yoff=%ld",
			ifp->if_width, ifp->if_height,
			ifp->if_xyoff>>16, ifp->if_xyoff&0xFFFF );
	} else {
		sprintf(message,"ab_open %d*%d",
			ifp->if_width, ifp->if_height);
	}
	ab_log(ifp, message);
d340 1
a340 1
	return( 0 );			/* OK */
d350 2
a351 2
	time_t		now;
	struct tm	*tmp;
d353 1
a353 1
	if( (ifp->if_mode & MODE_3MASK) != MODE_3VERBOSE )  return;
d355 11
a365 11
	(void)time( &now );
	tmp = localtime( &now );
	if( ifp->if_frame < 0 ) {
		fb_log("%2.2d:%2.2d:%2.2d %s frame store: %s\n",
			tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
			ifp->if_host, str );
	} else {
		fb_log("%2.2d:%2.2d:%2.2d %s frame %d: %s\n",
			tmp->tm_hour, tmp->tm_min, tmp->tm_sec,
			ifp->if_host, ifp->if_frame, str );
	}
d374 1
a374 1
	register int	y;
d376 9
a384 9
	ab_log(ifp, "Reading frame");
	if( ab_yuvio( 0, ifp->if_host, ifp->if_yuv,
	    720*486*2, ifp->if_frame,
	    (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK
	    ) != 720*486*2 )  {
		fb_log("ab_readframe(%d): unable to get frame from %s!\n",
			ifp->if_frame, ifp->if_host);
		return(-1);
	}
d386 8
a393 8
	/* convert YUV to RGB */
	ab_log(ifp, "Converting YUV to RGB");
	for( y=0; y < 486; y++ )  {
	    unsigned char *rgb = (unsigned char *)&ifp->if_rgb[(486-1-y)*720*3];
	    unsigned char *yuv = (unsigned char *)&ifp->if_yuv[y*720*2];
	    ab_yuv_to_rgb(rgb, yuv, 720);
	}
	ab_log(ifp, "Conversion done");
d395 2
a396 2
	ifp->if_mode |= STATE_FRAME_WAS_READ;
	return(0);			/* OK */
d405 1
a405 1
	int	ret = 0;
d407 2
a408 2
	if( ifp->if_mode & STATE_USER_HAS_WRITTEN )  {
		register int y;		/* in Abekas coordinates */
d410 25
a434 25
		/* Convert RGB to YUV */
		ab_log(ifp, "Converting RGB to YUV");
		for( y=0; y < 486; y++ )  {
		    unsigned char *yuv = (unsigned char *)&ifp->if_yuv[y*720*2];
		    unsigned char *rgb = (unsigned char *)&ifp->if_rgb[(486-1-y)*720*3];
		    ab_rgb_to_yuv(yuv, rgb, 720);
		}
		ab_log(ifp, "Writing frame");

		if( ab_yuvio( 1, ifp->if_host, ifp->if_yuv,
		    720*486*2, ifp->if_frame,
		    (ifp->if_mode & MODE_4MASK) == MODE_4NETWORK
		    ) != 720*486*2 )  {
			fb_log("ab_close: unable to send frame %d to A60 %s!\n",
				ifp->if_frame, ifp->if_host);
			ret = -1;
		}
		ab_log(ifp, "Transmission done");
	}

	/* Free dynamic memory */
	free( ifp->if_yuv );
	ifp->if_yuv = NULL;
	free( ifp->if_rgb );
	ifp->if_rgb = NULL;
d436 2
a437 2
	ab_log(ifp, "ab_close");
	return(ret);
d446 17
a462 18
	register int	r,g,b;
	register int	count;
	register char	*cp;

	if( bgpp == PIXEL_NULL )  {
		/* Clear to black */
		bzero( ifp->if_rgb, 720*486*3 );
	} else {
		r = (bgpp)[RED];
		g = (bgpp)[GRN];
		b = (bgpp)[BLU];

		cp = ifp->if_rgb;
		for( count = 720*486-1; count >= 0; count-- )  {
			*cp++ = r;
			*cp++ = g;
			*cp++ = b;
		}
d464 1
d466 2
a467 2
	ifp->if_mode |= STATE_USER_HAS_WRITTEN;
	return(0);
d476 4
a479 4
	register short		scan_count;	/* # pix on this scanline */
	register char		*cp;
	int			ret;
	int			xoff, yoff;
d481 2
a482 2
	if( count <= 0 )
		return(0);
d484 3
a486 3
	if( x < 0 || x > ifp->if_width ||
	    y < 0 || y > ifp->if_height)
		return(-1);
d488 7
a494 34
	if( (ifp->if_mode & STATE_FRAME_WAS_READ) == 0 )  {
		if( (ifp->if_mode & STATE_USER_HAS_WRITTEN) != 0 )  {
			fb_log("ab_read:  WARNING out-only mode set & pixels were written.  Subsequent read operation is unsafe\n");
			/* Give him whatever is in the buffer */
		} else {
			/* Read in the frame */
			if( ab_readframe(ifp) < 0 )  return(-1);
		}
	}

	xoff = ifp->if_xyoff>>16;
	yoff = ifp->if_xyoff & 0xFFFF;

	/* Copy from if_rgb[] */
	ret = 0;
	cp = (char *)(pixelp);

	while( count )  {
		if( y >= ifp->if_height )
			break;

		if ( count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = count;

		bcopy( &ifp->if_rgb[((y+yoff)*720+(x+xoff))*3], cp,
			scan_count*3 );
		cp += scan_count * 3;
		ret += scan_count;
		count -= scan_count;
		/* Advance upwards */
		x = 0;
		y++;
d496 29
a524 2
	ifp->if_mode |= STATE_USER_HAS_READ;
	return(ret);
d533 4
a536 4
	register short		scan_count;	/* # pix on this scanline */
	register const unsigned char	*cp;
	int			ret;
	int			xoff, yoff;
d538 2
a539 2
	if( count <= 0 )
		return(0);
d541 3
a543 3
	if( x < 0 || x > ifp->if_width ||
	    y < 0 || y > ifp->if_height)
		return(-1);
d545 37
a581 37
	/*
	 *  If this is the first write, and the frame has not
	 *  yet been read, then read it.
	 */
	if( (ifp->if_mode & STATE_FRAME_WAS_READ) == 0 &&
	    (ifp->if_mode & STATE_USER_HAS_WRITTEN) == 0 )  {
		/* Read in the frame first */
		(void)ab_readframe(ifp);
	}

	xoff = ifp->if_xyoff>>16;
	yoff = ifp->if_xyoff & 0xFFFF;

	/* Copy from if_rgb[] */
	ret = 0;
	cp = (pixelp);

	while( count )  {
		if( y >= ifp->if_height )
			break;

		if ( count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = count;

		bcopy( (char *)cp, &ifp->if_rgb[((y+yoff)*720+(x+xoff))*3],
			scan_count*sizeof(RGBpixel) );
		cp += scan_count * sizeof(RGBpixel);
		ret += scan_count;
		count -= scan_count;
		/* Advance upwards */
		x = 0;
		y++;
	}
	ifp->if_mode |= STATE_USER_HAS_WRITTEN;
	return(ret);
d589 1
a589 1
	fb_sim_cursor(ifp, mode, x, y);
d591 1
a591 1
	return(-1);
d599 1
a599 1
	fb_sim_getcursor(ifp, mode, x, y);
d601 1
a601 1
	return(-1);
d609 1
a609 1
	fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);
d611 1
a611 1
	return(-1);
d619 1
a619 1
	fb_sim_getview(ifp, xcenter, ycenter, xzoom, yzoom);
d621 1
a621 1
	return(-1);
d627 1
a627 1
	register int	i;
d629 6
a634 6
	for( i = 0; i < 256; i++ ) {
		cmap->cm_red[i] = i<<8;
		cmap->cm_green[i] = i<<8;
		cmap->cm_blue[i] = i<<8;
	}
	return(0);
d640 2
a641 2
	/* Just pretend it worked OK */
	return(0);
d650 1
a650 1
	struct	modeflags *mfp;
d652 19
a670 19
	fb_log( "Abekas A60 Ethernet Interface\n" );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Maximum width height: %d %d\n",
		ifp->if_max_width,
		ifp->if_max_height );
	fb_log( "Default width height: %d %d\n",
		ifp->if_width,
		ifp->if_height );
	fb_log( "A60 Host: %s\n", ifp->if_host );
	if( ifp->if_frame < 0 ) {
		fb_log( "Frame: store\n" );
	} else {
		fb_log( "Frame: %d\n", ifp->if_frame );
	}
	fb_log( "Usage: /dev/ab[options][@@host][#framenumber]\n" );
	fb_log( "       If no framenumber is given, the frame store is used\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}
d672 1
a672 1
	return(0);
d687 2
a688 2
			/* 0=read(input), 1=write(output) */
			/* frame number */
d690 30
a719 33
	struct sockaddr_in	sinme;		/* Client */
	struct sockaddr_in	sinhim;		/* Server */
	struct servent		*rlogin_service;
	struct hostent		*hp;
	char			xmit_buf[128] = {0};
	int			n;
	int			netfd;
	int			got;

	if( !to_network )  {
		if( frame >= 0 )
			sprintf( xmit_buf, "%s%d.yuv", host, frame );
		else
			sprintf( xmit_buf, "%s.yuv", host);
		if( output )
			netfd = creat( xmit_buf, 0444 );
		else
			netfd = open( xmit_buf, 0 );
		if( netfd < 0 )  {
			perror( xmit_buf );
			return -1;
		}
		if( output )
			got = write( netfd, buf, len );
		else
			got = bu_mread( netfd, buf, len );
		if( got != len )  {
			perror("read/write");
			fb_log("ab_yuvio file read/write error, len=%d, got=%d\n", len, got );
			goto err;
		}
		(void)close(netfd);
		return got;		/* OK */
d721 6
d728 5
a732 2
	bzero((char *)&sinhim, sizeof(sinhim));
	bzero((char *)&sinme, sizeof(sinme));
d734 61
a794 3
	if( (rlogin_service = getservbyname("shell", "tcp")) == NULL )  {
		fb_log("getservbyname(shell,tcp) fail\n");
		return(-1);
d796 1
a796 1
	sinhim.sin_port = rlogin_service->s_port;
d798 9
a806 11
	if( atoi( host ) > 0 )  {
		/* Numeric */
		sinhim.sin_family = AF_INET;
		sinhim.sin_addr.s_addr = inet_addr(host);
	} else {
		if( (hp = gethostbyname(host)) == NULL )  {
			fb_log("gethostbyname(%s) fail\n", host);
			return(-1);
		}
		sinhim.sin_family = hp->h_addrtype;
		bcopy(hp->h_addr, (char *)&sinhim.sin_addr, hp->h_length);
d808 1
d810 3
a812 3
	if( (netfd = socket(sinhim.sin_family, SOCK_STREAM, 0)) < 0 )  {
		perror("socket()");
		return(-1);
a813 1
	sinme.sin_port = 0;		/* let kernel pick it */
d815 9
a823 3
	if( bind(netfd, (struct sockaddr *)&sinme, sizeof(sinme)) < 0 )  {
		perror("bind()");
		goto err;
d826 16
a841 3
	if( connect(netfd, (struct sockaddr *)&sinhim, sizeof(sinhim)) < 0 ) {
		perror("connect()");
		goto err;
d844 1
a844 5
	/*
	 *  Connection established.  Now, speak the RCP protocol.
	 */

	/* Indicate that standard error is not connected */
d846 2
a847 2
		perror("write()");
		goto err;
d850 11
a860 3
	/* Write local and remote user names, null terminated */
	if( write( netfd, "a60libfb\0", 9 ) != 9 )  {
		perror("write()");
d862 1
d864 6
a869 3
	if( write( netfd, "a60libfb\0", 9 ) != 9 )  {
		perror("write()");
		goto err;
a870 1
	if( ab_get_reply(netfd) < 0 )  goto err;
d872 5
a876 41
	if( output )  {
		/* Output from buffer to A60 */
		/* Send command, null-terminated */
		if( frame < 0 )
			sprintf( xmit_buf, "rcp -t store.yuv" );
		else
			sprintf( xmit_buf, "rcp -t %d.yuv", frame );
		n = strlen(xmit_buf)+1;		/* include null */
		if( write( netfd, xmit_buf, n ) != n )  {
			perror("write()");
			goto err;
		}
		if( ab_get_reply(netfd) < 0 )  goto err;

		/* Send Access flags, length, old name */
		if( frame < 0 )
			sprintf( xmit_buf, "C0664 %d store.yuv\n", len );
		else
			sprintf( xmit_buf, "C0664 %d %d.yuv\n", len, frame );
		n = strlen(xmit_buf);
		if( write( netfd, xmit_buf, n ) != n )  {
			perror("write()");
			goto err;
		}
		if( ab_get_reply(netfd) < 0 )  goto err;

		if( (got = write( netfd, buf, len )) != len )  {
			perror("write()");
			goto err;
		}

		/* Send final go-ahead */
		if( (got = write( netfd, "\0", 1 )) != 1 )  {
			fb_log("go-ahead write got %d\n", got);
			perror("write()");
			goto err;
		}
		if( (got = ab_get_reply(netfd)) < 0 )  {
			fb_log("get_reply got %d\n", got);
			goto err;
		}
d878 4
a881 65
		(void)close(netfd);
		return(len);		/* OK */
	} else {
		register char	*cp;
		int		perm;
		int		src_size;
		/* Input from A60 into buffer */
		/* Send command, null-terminated */
		if( frame < 0 )
			sprintf( xmit_buf, "rcp -f store.yuv" );
		else
			sprintf( xmit_buf, "rcp -f %d.yuv", frame );
		n = strlen(xmit_buf)+1;		/* include null */
		if( write( netfd, xmit_buf, n ) != n )  {
			perror("write()");
			goto err;
		}

		/* Send go-ahead */
		if( write( netfd, "\0", 1 ) != 1 )  {
			perror("write()");
			goto err;
		}

		/* Read up to a newline */
		cp = xmit_buf;
		for(;;)  {
			if( read( netfd, cp, 1 ) != 1 )  {
				perror("read()");
				goto err;
			}
			if( *cp == '\n' )  break;
			cp++;
			if( (cp - xmit_buf) >= sizeof(xmit_buf) )  {
				fb_log("cmd buffer overrun\n");
				goto err;
			}
		}
		*cp++ = '\0';
		/* buffer will contain old permission, size, old name */
		src_size = 0;
		if( sscanf( xmit_buf, "C%o %d", (unsigned int *)&perm, &src_size ) != 2 )  {
			fb_log("sscanf error\n");
			goto err;
		}

		/* Send go-ahead */
		if( write( netfd, "\0", 1 ) != 1 )  {
			perror("write()");
			goto err;
		}

		/* Read data */
		if( (got = bu_mread( netfd, buf, len )) != len )  {
			fb_log("bu_mread len=%d, got %d\n", len, got );
			goto err;
		}

		/* Send go-ahead */
		if( write( netfd, "\0", 1 ) != 1 )  {
			perror("write()");
			goto err;
		}
		(void)close(netfd);
		return(len);		/* OK */
d884 5
a888 1
err:
d890 6
a895 1
	return(-1);
d901 2
a902 2
	char	rep_buf[128];
	int	got;
d904 5
a908 14
	if( (got = read( fd, rep_buf, sizeof(rep_buf) )) < 0 )  {
		perror("ab_get_reply()/read()");
		fb_log("ab_get_reply() read error\n");
		return(-1);
	}

	if( got == 0 )  {
		fb_log("ab_get_reply() unexpected EOF\n");
		return(-2);		/* EOF seen */
	}

	/* got >= 1 */
	if( rep_buf[0] == 0 )
		return(0);		/* OK */
d910 17
a926 8
	if( got == 1 )  {
		fb_log("ab_get_reply() error reply code, no attached message\n");
		return(-3);
	}

	/* Print error code received from other end */
	fb_log("ab_get_reply() error='%s'\n", &rep_buf[1] );
	return(-4);
d972 42
a1013 42
	register unsigned char *cp;
	register double	*yp, *up, *vp;
	register int	i;
	static int	first=1;

	if(first)  {
		/* SETUP */
		for( i = 0; i < 5; i++ ) {
			y_filter[i] *= 219.0/255.0;
			u_filter[i] *= 224.0/255.0;
			v_filter[i] *= 224.0/255.0;
		}
		first = 0;
	}

	/* Matrix RGB's into separate Y, U, and V arrays */
	yp = &ybuf[2];
	up = &ubuf[2];
	vp = &vbuf[2];
	cp = rgb_buf;
	for( i = len; i; i-- ) {
		*yp++ = VDOT( y_weights, cp );
		*up++ = VDOT( u_weights, cp );
		*vp++ = VDOT( v_weights, cp );
		cp += 3;
	}

	/* filter, scale, and sample YUV arrays */
	yp = ybuf;
	up = ubuf;
	vp = vbuf;
	cp = yuv_buf;
	for( i = len/2; i; i-- ) {
		*cp++ = V5DOT(u_filter,up) + 128.0;	/* u */
		*cp++ = V5DOT(y_filter,yp) + 16.0;	/* y */
		*cp++ = V5DOT(v_filter,vp) + 128.0;	/* v */
		yp++;
		*cp++ = V5DOT(y_filter,yp) + 16.0;	/* y */
		yp++;
		up += 2;
		vp += 2;
	}
d1020 35
a1054 35
	register unsigned char *rgbp;
	register unsigned char *yuvp;
	register double	y;
	register double	u = 0.0;
	register double	v;
	register int	pixel;
	int		last;

	/* Input stream looks like:  uy  vy  uy  vy  */

	rgbp = rgb_buf;
	yuvp = yuv_buf;
	last = len/2;
	for( pixel = last; pixel; pixel-- ) {
		/* even pixel, get y and next v */
		if( pixel == last ) {
			u = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);
		}
		y = ((double)(((int)*yuvp++) - 16)) * (255.0/219.0);
		v = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);

		CLIP( *rgbp++, y + 1.4026 * v);			/* R */
		CLIP( *rgbp++, y - 0.3444 * u - 0.7144 * v);	/* G */
		CLIP( *rgbp++, y + 1.7730 * u);			/* B */

		/* odd pixel, got v already, get y and next u */
		y = ((double)(((int)*yuvp++) - 16)) * (255.0/219.0);
		if( pixel != 1 ) {
			u = ((double)(((int)*yuvp++) - 128)) * (255.0/224.0);
		}

		CLIP( *rgbp++, y + 1.4026 * v);			/* R */
		CLIP( *rgbp++, y - 0.3444 * u - 0.7144 * v);	/* G */
		CLIP( *rgbp++, y + 1.7730 * u);			/* B */
	}
@


14.19
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.18 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
d389 3
a391 4
		ab_yuv_to_rgb(
		    &ifp->if_rgb[(486-1-y)*720*3],
		    &ifp->if_yuv[y*720*2],
		    720 );
d413 3
a415 4
			ab_rgb_to_yuv(
			    &ifp->if_yuv[y*720*2],
			    &ifp->if_rgb[(486-1-y)*720*3],
			    720 );
@


14.18
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.17 2007/01/21 04:45:42 brlcad Exp $ (BRL)";
d427 1
a427 1
		    	ret = -1;
d689 2
a690 2
   	       		/* 0=read(input), 1=write(output) */
   	      		/* frame number */
@


14.17
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.16 2007/01/20 14:36:52 brlcad Exp $ (BRL)";
@


14.16
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup if */
/*@@{*/
d24 1
d38 1
a38 1
/*@@}*/
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.15 2006/08/08 06:47:05 brlcad Exp $ (BRL)";
@


14.15
log
@get rid of the libfb-specific _LOCAL_ macro, instead using HIDDEN like everyone else (currently still provided by machine.h)
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2006 United States Government as represented by
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.14 2006/07/10 19:06:23 brlcad Exp $ (BRL)";
@


14.14
log
@refactor away the old BSD block defines among other simple cleanup
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.13 2006/07/09 18:25:31 brlcad Exp $ (BRL)";
d71 5
a75 5
static void	ab_log(FBIO *ifp, char *str);
static int	ab_get_reply(int fd);
static void	ab_yuv_to_rgb(unsigned char *rgb_buf, unsigned char *yuv_buf, int len);
static void	ab_rgb_to_yuv(unsigned char *yuv_buf, unsigned char *rgb_buf, int len);
static int	ab_yuvio(int, char *, char *, int, int, int);
d77 1
a77 1
_LOCAL_ int	ab_open(register FBIO *ifp, register char *file, int width, int height),
d200 1
a200 1
_LOCAL_ int
d349 1
a349 1
static void ab_log(FBIO *ifp, char *str)
d372 1
a372 1
static int
d404 1
a404 1
_LOCAL_ int
d446 1
a446 1
_LOCAL_ int
d476 1
a476 1
_LOCAL_ int
d533 1
a533 1
_LOCAL_ int
d589 1
a589 1
_LOCAL_ int
d599 1
a599 1
_LOCAL_ int
d609 1
a609 1
_LOCAL_ int
d619 1
a619 1
_LOCAL_ int
d627 1
a627 1
_LOCAL_ int
d640 1
a640 1
_LOCAL_ int
d650 1
a650 1
_LOCAL_ int
d901 1
a901 1
static int
d972 1
a972 1
static void
d1020 1
a1020 1
static void
@


14.13
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.12 2006/07/09 10:53:15 brlcad Exp $ (BRL)";
a53 5
#ifdef BSD
#  define __BSDbackup BSD
#  undef BSD
#endif

a59 5
#ifdef __BSDbackup
#  undef BSD
#  define BSD __BSDbackup
#endif

d61 1
a61 1
#include <string.h>
d63 1
a63 1
#include <strings.h>
d70 1
@


14.12
log
@more mread() cleanup.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.11 2006/07/09 09:50:24 brlcad Exp $ (BRL)";
a699 3



a700 1

d706 1
a706 1
	char			xmit_buf[128];
@


14.11
log
@refactor utilizing bu_mread now from libbu
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.10 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
d896 1
a896 1
			fb_log("mread len=%d, got %d\n", len, got );
@


14.10
log
@update copyright to 2006
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.9 2005/10/23 04:44:34 brlcad Exp $ (BRL)";
a81 1
static int	ab_mread(int fd, register char *bufp, int n);
d731 1
a731 1
			got = ab_mread( netfd, buf, len );
d895 2
a896 2
		if( (got = ab_mread( netfd, buf, len )) != len )  {
			fb_log("ab_mread len=%d, got %d\n", len, got );
a944 30
/*
 *			M R E A D
 *
 * Internal.
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because pipes
 * and network connections don't deliver data with the same
 * grouping as it is written with.  Written by Robert S. Miles, BRL.
 */
static int
ab_mread(int fd, register char *bufp, int n)
{
	register int	count = 0;
	register int	nread;

	do {
		nread = read(fd, bufp, (unsigned)n-count);
		if(nread < 0)  {
			perror("ab_mread");
			return(-1);
		}
		if(nread == 0)
			return((int)count);
		count += (unsigned)nread;
		bufp += nread;
	 } while(count < n);

	return((int)count);
}
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1989-2005 United States Government as represented by
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.8 2005/09/16 19:14:20 brlcad Exp $ (BRL)";
@


14.8
log
@remove the shadowing floor define, just use the math floor() instead
@
text
@d36 1
a36 1
 *  
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.7 2005/08/12 22:30:12 lbutler Exp $ (BRL)";
d701 3
a703 3
    	      
    	     
   	    
d705 1
a705 1
   	           
@


14.7
log
@Doxygen changes
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.6 2005/01/30 20:30:48 brlcad Exp $ (BRL)";
a45 2


a994 1
#define	floor(d)	(d>=0?(int)d:((int)d==d?d:(int)(d-1.0)))
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d36 1
a36 1
 *
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d46 2
d703 3
a705 3



d707 1
a707 1

d997 1
@


14.6
log
@update copyright to 2005
@
text
@d21 3
a24 1
 *
d38 2
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ab.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2004 United States Government as represented by
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a34 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
d37 1
a37 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 14.3 2004/12/21 05:45:22 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 14.2 2004/12/21 03:58:27 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			I F _ A B . C
d40 1
a40 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 1.6 2004/09/15 06:41:24 morrison Exp $ (BRL)";
@


1.6
log
@quell warning -- constness
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 1.5 2004/09/03 23:30:57 morrison Exp $ (BRL)";
d1086 10
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 1.4 2004/08/02 23:01:48 morrison Exp $ (BRL)";
d75 1
a75 1
		ab_wmap(register FBIO *ifp, register ColorMap *cmap),
d633 1
a633 1
ab_wmap(register FBIO *ifp, register ColorMap *cmap)
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 1.3 2004/06/09 20:04:53 erikg Exp $ (BRL)";
d52 1
a52 1
#ifdef USE_STRING_H
@


1.3
log
@warning fixes
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ab.c,v 1.2 2004/06/08 22:04:21 morrison Exp $ (BRL)";
d24 1
a24 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d31 1
d239 1
a239 1
		ifp->if_host = malloc(ep-cp+2);
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d21 1
a21 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_ab.c,v 11.14 2004/05/10 15:30:44 erikg Exp $ (BRL)";
a59 1
#include "externs.h"			/* For malloc */
@

