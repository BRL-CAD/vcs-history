head	14.19;
access;
symbols
	rel-7-10-4:14.16.2.1
	STABLE:14.16.0.2
	stable-branch:14.6
	rel-7-10-2:14.15
	rel-7-10-0:14.14
	rel-7-8-4:14.10
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.19
date	2007.12.16.18.53.48;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.10;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.08.18.03.15.11;	author brlcad;	state Exp;
branches
	14.16.2.1;
next	14.15;

14.15
date	2007.07.26.01.13.56;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.08.08.06.47.05;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.30.12;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.48;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.58.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.08.19.44.21;	author kermit;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.21;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.42;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.16.2.1
date	2007.09.28.14.07.48;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.19
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                        I F _ M E M . C
 * BRL-CAD
 *
 * Copyright (c) 1989-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup if */
/** @@{ */
/** @@file if_mem.c
 *
 *  A Memory (virtual) Frame Buffer Interface.
 *
 *  Authors -
 *	Phillip Dykstra
 *
 */
/** @@} */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.18 2007/12/16 15:59:38 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "machine.h"
#include "fb.h"


HIDDEN int	mem_open(FBIO *ifp, char *file, int width, int height),
		mem_close(FBIO *ifp),
		mem_clear(FBIO *ifp, unsigned char *pp),
		mem_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		mem_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		mem_rmap(FBIO *ifp, ColorMap *cmp),
		mem_wmap(FBIO *ifp, const ColorMap *cmp),
		mem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		mem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		mem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		mem_cursor(FBIO *ifp, int mode, int x, int y),
		mem_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		mem_poll(FBIO *ifp),
		mem_flush(FBIO *ifp),
		mem_help(FBIO *ifp);

/* This is the ONLY thing that we normally "export" */
FBIO memory_interface =  {
	0,
	mem_open,		/* device_open		*/
	mem_close,		/* device_close		*/
	mem_clear,		/* device_clear		*/
	mem_read,		/* buffer_read		*/
	mem_write,		/* buffer_write		*/
	mem_rmap,		/* colormap_read	*/
	mem_wmap,		/* colormap_write	*/
	mem_view,		/* set view		*/
	mem_getview,		/* get view		*/
	mem_setcursor,		/* define cursor	*/
	mem_cursor,		/* set cursor		*/
	mem_getcursor,		/* get cursor		*/
	fb_sim_readrect,	/* rectangle read	*/
	fb_sim_writerect,	/* rectangle write	*/
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	mem_poll,		/* poll			*/
	mem_flush,		/* flush		*/
	mem_close,		/* free			*/
	mem_help,		/* help message		*/
	"Memory Buffer",	/* device description	*/
	8192,			/* max width		*/
	8192,			/* max height		*/
	"/dev/mem",		/* short device name	*/
	512,			/* default/current width  */
	512,			/* default/current height */
	-1,			/* select fd		*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	256, 256,		/* window center	*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
};

/* Per connection private info */
struct	meminfo {
	FBIO	*fbp;		/* attached frame buffer (if any) */
	unsigned char *mem;	/* memory frame buffer */
	ColorMap cmap;		/* color map buffer */
	int	mem_dirty;	/* !0 implies unflushed written data */
	int	cmap_dirty;	/* !0 implies unflushed written cmap */
	int	write_thru;	/* !0 implies pass-thru write mode */
};
#define	MI(ptr) ((struct meminfo *)((ptr)->u1.p))
#define	MIL(ptr) ((ptr)->u1.p)		/* left hand side version */

#define MODE_1MASK	(1<<1)
#define MODE_1BUFFERED	(0<<1)		/* output flushed only at close */
#define MODE_1IMMEDIATE	(1<<1)		/* pass-through writes */

#define MODE_2MASK	(1<<2)
#define MODE_2CLEAR	(0<<2)		/* assume fb opens clear */
#define MODE_2PREREAD	(1<<2)		/* pre-read data from fb */

static struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'w',	MODE_1MASK, MODE_1IMMEDIATE,
		"Write thru mode - pass writes directly to attached frame buffer" },
	{ 'r',  MODE_2MASK, MODE_2PREREAD,
		"Pre-Read attached frame buffer data - else assumes clear" },
	{ '\0', 0, 0, "" }
};

HIDDEN int
mem_open(FBIO *ifp, char *file, int width, int height)
{
	int	mode;
	char	*cp;
	FBIO	*fbp;

	FB_CK_FBIO(ifp);

	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/mem###"
	 *  The default mode is zero.
	 */
	mode = 0;

	if( file != NULL )  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if( strncmp(file, "/dev/mem", 8) ) {
			/* How did this happen?? */
			mode = 0;
		}
		else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[8];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
				}
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_mem: unknown option '%c' ignored\n", *cp );
				}
				cp++;
			}
			*mp = '\0';
			if( !alpha )
				mode = atoi( modebuf );
		}
	}

	/* build a local static info struct */
	if( (MIL(ifp) = (char *)calloc( 1, sizeof(struct meminfo) )) == NULL )  {
		fb_log("mem_open:  meminfo malloc failed\n");
		return(-1);
	}
	cp = &file[strlen("/dev/mem")];
	while( *cp != '\0' && *cp != ' ' && *cp != '\t' )
		cp++;	/* skip suffix */
	while( *cp != '\0' && (*cp == ' ' || *cp == '\t' || *cp == ';') )
		cp++;	/* skip blanks and separators */

	if( *cp ) {
		/* frame buffer device specified */
		if( (fbp = fb_open(cp, width, height)) == FBIO_NULL ) {
			free( MIL(ifp) );
			return( -1 );
		}
		MI(ifp)->fbp = fbp;
		ifp->if_width = fbp->if_width;
		ifp->if_height = fbp->if_height;
		ifp->if_selfd = fbp->if_selfd;
		if( (mode & MODE_1MASK) == MODE_1IMMEDIATE )
			MI(ifp)->write_thru = 1;
	} else {
		/* no frame buffer specified */
		if( width > 0 )
			ifp->if_width = width;
		if( height > 0 )
			ifp->if_height = height;
	}
	if( (MI(ifp)->mem = (unsigned char *)calloc( ifp->if_width*ifp->if_height, 3 )) == NULL ) {
		fb_log("mem_open:  memory buffer malloc failed\n");
		(void)free( MIL(ifp) );
		return(-1);
	}
	if( (MI(ifp)->fbp != FBIO_NULL)
	 && (mode & MODE_2MASK) == MODE_2PREREAD ) {
		/* Pre read all of the image data and cmap */
		int got;
		got = fb_readrect( MI(ifp)->fbp, 0, 0,
			ifp->if_width, ifp->if_height,
			(unsigned char *)MI(ifp)->mem );
		if( got != ifp->if_width * ifp->if_height )  {
			fb_log("if_mem:  WARNING: pre-read of %d only got %d, your image is truncated.\n",
				ifp->if_width * ifp->if_height, got );
		}
		if( fb_rmap( MI(ifp)->fbp, &(MI(ifp)->cmap) ) < 0 )
			fb_make_linear_cmap( &(MI(ifp)->cmap) );
	} else {
		/* Image data begins black, colormap linear */
		fb_make_linear_cmap( &(MI(ifp)->cmap) );
	}

	return(0);
}

HIDDEN int
mem_close(FBIO *ifp)
{
	/*
	 * Flush memory/cmap to attached frame buffer if any
	 */
	if( MI(ifp)->fbp != FBIO_NULL ) {
		if( MI(ifp)->cmap_dirty ) {
			fb_wmap( MI(ifp)->fbp, &(MI(ifp)->cmap) );
		}
		if( MI(ifp)->mem_dirty ) {
			fb_writerect( MI(ifp)->fbp, 0, 0,
				ifp->if_width, ifp->if_height, (unsigned char *)MI(ifp)->mem );
		}
		fb_close( MI(ifp)->fbp );
		MI(ifp)->fbp = FBIO_NULL;
	}
	(void)free( (char *)MI(ifp)->mem );
	(void)free( (char *)MIL(ifp) );

	return(0);
}

HIDDEN int
mem_clear(FBIO *ifp, unsigned char *pp)
{
	RGBpixel v;
	register int n;
	register unsigned char *cp;

	if( pp == RGBPIXEL_NULL ) {
		v[RED] = v[GRN] = v[BLU] = 0;
	} else {
		v[RED] = (pp)[RED];
		v[GRN] = (pp)[GRN];
		v[BLU] = (pp)[BLU];
	}

	cp = MI(ifp)->mem;
	if( v[RED] == v[GRN] && v[RED] == v[BLU] ) {
		int	bytes = ifp->if_width*ifp->if_height*3;
		if( v[RED] == 0 )
			memset((char *)cp, 0, bytes);	/* all black */
		else
			memset(cp, v[RED], bytes);	/* all grey */
	} else {
		for( n = ifp->if_width*ifp->if_height; n; n-- ) {
			*cp++ = v[RED];
			*cp++ = v[GRN];
			*cp++ = v[BLU];
		}
	}
	if( MI(ifp)->write_thru ) {
		return fb_clear( MI(ifp)->fbp, pp );
	} else {
		MI(ifp)->mem_dirty = 1;
	}
	return(0);
}

HIDDEN int
mem_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
{
	int	pixels_to_end;

	if( x < 0 || x >= ifp->if_width || y < 0 || y >= ifp->if_height )
		return( -1 );

	/* make sure we don't run off the end of the buffer */
	pixels_to_end = ifp->if_width*ifp->if_height - (y*ifp->if_width + x);
	if( pixels_to_end < count )
		count = pixels_to_end;

	memcpy((char *)pixelp, &(MI(ifp)->mem[(y*ifp->if_width + x)*3]), count*3);

	return(count);
}

HIDDEN int
mem_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
{
	int	pixels_to_end;

	if( x < 0 || x >= ifp->if_width || y < 0 || y >= ifp->if_height )
		return( -1 );

	/* make sure we don't run off the end of the buffer */
	pixels_to_end = ifp->if_width*ifp->if_height - (y*ifp->if_width + x);
	if( pixels_to_end < count )
		count = pixels_to_end;

	memcpy(&(MI(ifp)->mem[(y*ifp->if_width + x)*3]), (char *)pixelp, count*3);

	if( MI(ifp)->write_thru ) {
		return fb_write( MI(ifp)->fbp, x, y, pixelp, count );
	} else {
		MI(ifp)->mem_dirty = 1;
	}
	return(count);
}

HIDDEN int
mem_rmap(FBIO *ifp, ColorMap *cmp)
{
	*cmp = MI(ifp)->cmap;		/* struct copy */
	return(0);
}

HIDDEN int
mem_wmap(FBIO *ifp, const ColorMap *cmp)
{
	if( cmp == COLORMAP_NULL )  {
		fb_make_linear_cmap( &(MI(ifp)->cmap) );
	} else {
		MI(ifp)->cmap = *cmp;		/* struct copy */
	}

	if( MI(ifp)->write_thru ) {
		return fb_wmap( MI(ifp)->fbp, cmp );
	} else {
		MI(ifp)->cmap_dirty = 1;
	}
	return(0);
}

HIDDEN int
mem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	fb_sim_view( ifp, xcenter, ycenter, xzoom, yzoom );
	if( MI(ifp)->write_thru ) {
		return fb_view( MI(ifp)->fbp, xcenter, ycenter,
			xzoom, yzoom );
	}
	return(0);
}

HIDDEN int
mem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
	if( MI(ifp)->write_thru ) {
		return fb_getview( MI(ifp)->fbp, xcenter, ycenter,
			xzoom, yzoom );
	}
	fb_sim_getview( ifp, xcenter, ycenter, xzoom, yzoom );
	return(0);
}

HIDDEN int
mem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	if( MI(ifp)->write_thru ) {
		return fb_setcursor( MI(ifp)->fbp,
			bits, xbits, ybits, xorig, yorig );
	}
	return(0);
}

HIDDEN int
mem_cursor(FBIO *ifp, int mode, int x, int y)
{
	fb_sim_cursor( ifp, mode, x, y );
	if( MI(ifp)->write_thru ) {
		return fb_cursor( MI(ifp)->fbp, mode, x, y );
	}
	return(0);
}

HIDDEN int
mem_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
	if( MI(ifp)->write_thru ) {
		return fb_getcursor( MI(ifp)->fbp, mode, x, y );
	}
	fb_sim_getcursor( ifp, mode, x, y );
	return(0);
}

HIDDEN int
mem_poll(FBIO *ifp)
{
	if( MI(ifp)->write_thru ) {
		return fb_poll( MI(ifp)->fbp );
	}
	return(0);
}

HIDDEN int
mem_flush(FBIO *ifp)
{
	/*
	 * Flush memory/cmap to attached frame buffer if any
	 */
	if( MI(ifp)->fbp != FBIO_NULL ) {
		if( MI(ifp)->cmap_dirty ) {
			fb_wmap( MI(ifp)->fbp, &(MI(ifp)->cmap) );
			MI(ifp)->cmap_dirty = 0;
		}
		if( MI(ifp)->mem_dirty ) {
			fb_writerect( MI(ifp)->fbp, 0, 0,
				ifp->if_width, ifp->if_height, (unsigned char *)MI(ifp)->mem );
			MI(ifp)->mem_dirty = 0;
		}
		return	fb_flush( MI(ifp)->fbp );
	}

	MI(ifp)->cmap_dirty = 0;
	MI(ifp)->mem_dirty = 0;
	return	0;	/* success */
}

HIDDEN int
mem_help(FBIO *ifp)
{
	struct	modeflags *mfp;

	fb_log( "Description: %s\n", memory_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		memory_interface.if_max_width,
		memory_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		memory_interface.if_width,
		memory_interface.if_height );
	fb_log( "Usage: /dev/mem[options] [attached_framebuffer]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}
	return(0);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.18
log
@convert all bzero calls to memset
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.17 2007/09/15 16:23:10 brlcad Exp $ (BRL)";
d326 1
a326 2
	bcopy( &(MI(ifp)->mem[(y*ifp->if_width + x)*3]), (char *)pixelp,
		count*3 );
d344 1
a344 2
	bcopy( (char *)pixelp, &(MI(ifp)->mem[(y*ifp->if_width + x)*3]),
		count*3 );
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.16 2007/08/18 03:15:11 brlcad Exp $ (BRL)";
d295 1
a295 1
			bzero( (char *)cp, bytes );	/* all black */
d297 1
a297 1
			memset( cp, v[RED], bytes );	/* all grey */
@


14.16
log
@remove the fblocal.h header file.  it was only used in three places (two files) and only contained one macro (wrapper to fb_log an error), so keep it simple until it's really needed.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.15 2007/07/26 01:13:56 brlcad Exp $ (BRL)";
d41 1
a41 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.16.2.1
log
@merge from head, make linger the default framebuffer action instead of transient for all windowing framebuffer interfaces.
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.17 2007/09/15 16:23:10 brlcad Exp $ (BRL)";
d41 5
a45 1
#include <string.h>
@


14.15
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.14 2007/01/27 01:41:37 brlcad Exp $ (BRL)";
a49 2
#include "./fblocal.h"

@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a28 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d33 1
a33 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.13 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.12 2007/01/21 04:45:42 brlcad Exp $ (BRL)";
d246 1
a246 1
	 	int got;
d250 4
a253 4
	 	if( got != ifp->if_width * ifp->if_height )  {
	 		fb_log("if_mem:  WARNING: pre-read of %d only got %d, your image is truncated.\n",
	 			ifp->if_width * ifp->if_height, got );
	 	}
@


14.12
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.11 2007/01/20 14:36:52 brlcad Exp $ (BRL)";
@


14.11
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup if */
/*@@{*/
d24 1
d36 1
a36 1
/*@@}*/
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.10 2006/08/08 06:47:05 brlcad Exp $ (BRL)";
@


14.10
log
@get rid of the libfb-specific _LOCAL_ macro, instead using HIDDEN like everyone else (currently still provided by machine.h)
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2006 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
@


14.9
log
@update copyright to 2006
@
text
@d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.8 2005/10/23 04:44:34 brlcad Exp $ (BRL)";
a43 1

d48 1
a48 1
#include <string.h>
d50 1
a50 1
#include <strings.h>
d52 1
d55 1
d58 2
a59 1
_LOCAL_ int	mem_open(FBIO *ifp, char *file, int width, int height),
d152 1
a152 1
_LOCAL_ int
d265 1
a265 1
_LOCAL_ int
d288 1
a288 1
_LOCAL_ int
d325 1
a325 1
_LOCAL_ int
d344 1
a344 1
_LOCAL_ int
d368 1
a368 1
_LOCAL_ int
d375 1
a375 1
_LOCAL_ int
d392 1
a392 1
_LOCAL_ int
d403 1
a403 1
_LOCAL_ int
d414 1
a414 1
_LOCAL_ int
d424 1
a424 1
_LOCAL_ int
d434 1
a434 1
_LOCAL_ int
d444 1
a444 1
_LOCAL_ int
d453 1
a453 1
_LOCAL_ int
d477 1
a477 1
_LOCAL_ int
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1989-2005 United States Government as represented by
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.7 2005/08/12 22:30:12 lbutler Exp $ (BRL)";
@


14.7
log
@Doxygen changes
@
text
@d34 1
a34 1
 *  
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.6 2005/01/30 20:30:48 brlcad Exp $ (BRL)";
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d34 1
a34 1
 *
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


14.6
log
@update copyright to 2005
@
text
@d21 3
a24 1
 *
d36 2
d39 1
a39 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_mem.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2004 United States Government as represented by
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_mem.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a32 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_mem.c,v 14.3 2004/12/21 05:45:22 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_mem.c,v 14.2 2004/12/21 03:58:27 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_mem.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			I F _ M E M . C
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_mem.c,v 1.4 2004/09/08 19:44:21 kermit Exp $ (BRL)";
@


1.4
log
@Added <stdlib.h> to fix implicit cast (for IA64 architecture).
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_mem.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
d474 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_mem.c,v 1.2 2004/06/08 22:04:21 morrison Exp $ (BRL)";
d25 1
a25 1

@


1.2
log
@obliterate externs.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 1
a22 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_mem.c,v 11.10 2004/05/10 15:30:45 erikg Exp $ (BRL)";
a35 1
#include "externs.h"			/* For calloc */
@

