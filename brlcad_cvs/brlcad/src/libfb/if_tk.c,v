head	14.10;
access;
symbols
	rel-7-10-4:14.9
	STABLE:14.9.0.2
	rel-7-10-2:14.8
	rel-7-10-0:14.4
	rel-7-8-4:14.1;
locks; strict;
comment	@ * @;


14.10
date	2007.12.03.15.34.01;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2007.08.18.03.15.11;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2007.05.26.21.57.47;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2007.05.06.18.00.35;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2007.05.01.19.19.20;	author erikgreenwald;	state Exp;
branches;
next	14.5;

14.5
date	2007.04.23.13.30.20;	author joevalleyfield;	state Exp;
branches;
next	14.4;

14.4
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2007.01.23.01.13.35;	author brlcad;	state Exp;
branches;
next	14.2;

14.2
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.1;

14.1
date	2006.08.10.01.06.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.10
log
@quell empty compilation unit warning
@
text
@/*                         I F _ T K . C
 * BRL-CAD
 *
 * Copyright (c) 2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup if */
/** @@{ */
/** @@file if_tk.c
 *
 * Tk libfb interface.
 *
 * Author -
 *   Tim J. Myers
 */
/** @@} */

#include "common.h"

#ifdef IF_TK

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include <tcl.h>
#include <tk.h>

#include "machine.h"
#include "fb.h"


Tcl_Interp *fbinterp;
Tk_Window fbwin;
Tk_PhotoHandle fbphoto;

HIDDEN int	fb_tk_open(FBIO *ifp, char *file, int width, int height),
    fb_tk_close(FBIO *ifp),
    tk_clear(FBIO *ifp, unsigned char *pp),
    tk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
    tk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
    tk_rmap(FBIO *ifp, ColorMap *cmp),
    tk_wmap(FBIO *ifp, const ColorMap *cmp),
    tk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
    tk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
    tk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
    tk_cursor(FBIO *ifp, int mode, int x, int y),
    tk_getcursor(FBIO *ifp, int *mode, int *x, int *y),
    tk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
    tk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
    tk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
    tk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
    tk_poll(FBIO *ifp),
    tk_flush(FBIO *ifp),
    tk_free(FBIO *ifp),
    tk_help(FBIO *ifp);

/* This is the ONLY thing that we "export" */
FBIO tk_interface = {
    0,
    fb_tk_open,
    fb_tk_close,
    tk_clear,
    tk_read,
    tk_write,
    tk_rmap,
    tk_wmap,
    tk_view,
    tk_getview,
    tk_setcursor,
    tk_cursor,
    tk_getcursor,
    tk_readrect,
    tk_writerect,
    tk_bwreadrect,
    tk_bwwriterect,
    tk_poll,
    tk_flush,
    tk_free,
    tk_help,
    "Debugging Interface",
    32*1024,		/* max width */
    32*1024,		/* max height */
    "/dev/tk",
    512,			/* current/default width */
    512,			/* current/default height */
    -1,			/* select fd */
    -1,			/* file descriptor */
    1, 1,			/* zoom */
    256, 256,		/* window center */
    0, 0, 0,		/* cursor */
    PIXEL_NULL,		/* page_base */
    PIXEL_NULL,		/* page_curp */
    PIXEL_NULL,		/* page_endp */
    -1,			/* page_no */
    0,			/* page_ref */
    0L,			/* page_curpos */
    0L,			/* page_pixels */
    0			/* debug */
};


HIDDEN int
fb_tk_open(FBIO *ifp, char *file, int width, int height)
{
    FB_CK_FBIO(ifp);
    if( file == (char *)NULL )
	fb_log( "fb_open( 0x%lx, NULL, %d, %d )\n",
		(unsigned long)ifp, width, height );
    else
	fb_log( "fb_open( 0x%lx, \"%s\", %d, %d )\n",
		(unsigned long)ifp, file, width, height );

    /* check for default size */
    if( width <= 0 )
	width = ifp->if_width;
    if( height <= 0 )
	height = ifp->if_height;

    /* set debug bit vector */
    if( file != NULL ) {
	char *cp;
	for( cp = file; *cp != '\0' && !isdigit(*cp); cp++ ) ;
	sscanf( cp, "%d", &ifp->if_debug );
    } else {
	ifp->if_debug = 0;
    }

    /* Give the user whatever width was asked for */
    ifp->if_width = width;
    ifp->if_height = height;

    fbinterp = Tcl_CreateInterp();
    const char *cmd = "package require Tk";

    if (Tcl_Init(fbinterp) == TCL_ERROR) {
	fb_log( "Tcl_Init returned error in fb_open." );
    }

    if (Tcl_Eval(fbinterp, cmd) != TCL_OK) {
	fb_log( "Error returned attempting to start tk in fb_open." );
    }


    fbwin = Tk_MainWindow(fbinterp);

    Tk_GeometryRequest(fbwin, width, height);

    Tk_MakeWindowExist(fbwin);

    char image_create_cmd[255];
    sprintf(image_create_cmd,
	    "image create photo fb_tk_photo -height %d -width %d",
	    width, height);

    if (Tcl_Eval(fbinterp, image_create_cmd) != TCL_OK) {
	fb_log( "Error returned attempting to create image in fb_open." );
    }

    if ((fbphoto = Tk_FindPhoto(fbinterp, "fb_tk_photo")) == NULL ) {
	fb_log( "Image creation unsuccessful in fb_open." );
    }

    char canvas_create_cmd[255];
    sprintf(canvas_create_cmd,
	    "canvas .fb_tk_canvas -height %d -width %d", width, height);

    if (Tcl_Eval(fbinterp, canvas_create_cmd) != TCL_OK) {
	fb_log( "Error returned attempting to create canvas in fb_open." );
    }

    const char canvas_pack_cmd[255] =
	"pack .fb_tk_canvas -fill both -expand true";

    if (Tcl_Eval(fbinterp, canvas_pack_cmd) != TCL_OK) {
	fb_log( "Error returned attempting to pack canvas in fb_open. %s",
		Tcl_GetStringResult(fbinterp));
    }

    const char place_image_cmd[255] =
	".fb_tk_canvas create image 0 0 -image fb_tk_photo -anchor nw";
    if (Tcl_Eval(fbinterp, place_image_cmd) != TCL_OK) {
	fb_log( "Error returned attempting to place image in fb_open. %s",
		Tcl_GetStringResult(fbinterp));
    }

    while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));

    return	0;
}

HIDDEN int
fb_tk_close(FBIO *ifp)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_close( 0x%lx )\n", (unsigned long)ifp );
    return	0;
}

HIDDEN int
tk_clear(FBIO *ifp, unsigned char *pp)
{
    FB_CK_FBIO(ifp);
    if( pp == 0 )
	fb_log( "fb_clear( 0x%lx, NULL )\n", (unsigned long)ifp );
    else
	fb_log( "fb_clear( 0x%lx, &[%d %d %d] )\n",
		(unsigned long)ifp,
		(int)(pp[RED]), (int)(pp[GRN]),
		(int)(pp[BLU]) );
    return	0;
}

HIDDEN int
tk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_read( 0x%lx,%4d,%4d, 0x%lx, %d )\n",
	    (unsigned long)ifp, x, y,
	    (unsigned long)pixelp, count );
    return	count;
}

HIDDEN int
tk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count)
{
    int	i;
    unsigned char pixp = *pixelp;

    FB_CK_FBIO(ifp);
    fb_log( "fb_write( 0x%lx,%4d,%4d, 0x%lx, %d )\n",
	    (unsigned long)ifp, x, y,
	    (unsigned long)pixelp, count );

    /* write them out, four per line */
    if( ifp->if_debug & FB_DEBUG_RW ) {
	for( i = 0; i < count; i++ ) {
	    if( i % 4 == 0 )
		fb_log( "%4d:", i );
	    fb_log( "  [%3d,%3d,%3d]", *(pixelp+(i*3)+RED),
		    *(pixelp+(i*3)+GRN), *(pixelp+(i*3)+BLU) );
	    if( i % 4 == 3 )
		fb_log( "\n" );
	}
	if( i % 4 != 0 )
	    fb_log( "\n" );
    }

    Tk_PhotoImageBlock block = {
	&pixp,
	count,
	1,
	3 * ifp->if_width,
	3,
	{
	    RED,
	    GRN,
	    BLU,
	    0
	}
    };

    Tk_PhotoPutBlock(fbinterp, fbphoto, &block, x, ifp->if_height-y, count, 1, TK_PHOTO_COMPOSITE_SET);

    return	count;
}

HIDDEN int
tk_rmap(FBIO *ifp, ColorMap *cmp)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_rmap( 0x%lx, 0x%lx )\n",
	    (unsigned long)ifp, (unsigned long)cmp );
    return	0;
}

HIDDEN int
tk_wmap(FBIO *ifp, const ColorMap *cmp)
{
    int	i;

    FB_CK_FBIO(ifp);
    if( cmp == NULL )
	fb_log( "fb_wmap( 0x%lx, NULL )\n",
		(unsigned long)ifp );
    else
	fb_log( "fb_wmap( 0x%lx, 0x%lx )\n",
		(unsigned long)ifp, (unsigned long)cmp );

    if( ifp->if_debug & FB_DEBUG_CMAP && cmp != NULL ) {
	for( i = 0; i < 256; i++ ) {
	    fb_log( "%3d: [ 0x%4lx, 0x%4lx, 0x%4lx ]\n",
		    i,
		    (unsigned long)cmp->cm_red[i],
		    (unsigned long)cmp->cm_green[i],
		    (unsigned long)cmp->cm_blue[i] );
	}
    }

    return	0;
}

HIDDEN int
tk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_view( 0x%lx,%4d,%4d,%4d,%4d )\n",
	    (unsigned long)ifp, xcenter, ycenter, xzoom, yzoom );
    fb_sim_view( ifp, xcenter, ycenter, xzoom, yzoom );
    return	0;
}

HIDDEN int
tk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_getview( 0x%lx, 0x%x, 0x%x, 0x%x, 0x%x )\n",
	    (unsigned long)ifp, xcenter, ycenter, xzoom, yzoom );
    fb_sim_getview( ifp, xcenter, ycenter, xzoom, yzoom );
    fb_log( " <= %d %d %d %d\n",
	    *xcenter, *ycenter, *xzoom, *yzoom );
    return	0;
}

HIDDEN int
tk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_setcursor( 0x%lx, 0x%lx, %d, %d, %d, %d )\n",
	    (unsigned long)ifp, bits, xbits, ybits, xorig, yorig );
    return	0;
}

HIDDEN int
tk_cursor(FBIO *ifp, int mode, int x, int y)
{
    fb_log( "fb_cursor( 0x%lx, %d,%4d,%4d )\n",
	    (unsigned long)ifp, mode, x, y );
    fb_sim_cursor( ifp, mode, x, y );
    return	0;
}

HIDDEN int
tk_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_getcursor( 0x%lx, 0x%x,0x%x,0x%x )\n",
	    (unsigned long)ifp, mode, x, y );
    fb_sim_getcursor( ifp, mode, x, y );
    fb_log( " <= %d %d %d\n", *mode, *x, *y );
    return	0;
}

HIDDEN int
tk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_readrect( 0x%lx, (%4d,%4d), %4d,%4d, 0x%lx )\n",
	    (unsigned long)ifp, xmin, ymin, width, height,
	    (unsigned long)pp );
    return( width*height );
}

HIDDEN int
tk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_writerect( 0x%lx,%4d,%4d,%4d,%4d, 0x%lx )\n",
	    (unsigned long)ifp, xmin, ymin, width, height,
	    (unsigned long)pp );
    return( width*height );
}

HIDDEN int
tk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_bwreadrect( 0x%lx, (%4d,%4d), %4d,%4d, 0x%lx )\n",
	    (unsigned long)ifp, xmin, ymin, width, height,
	    (unsigned long)pp );
    return( width*height );
}

HIDDEN int
tk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_bwwriterect( 0x%lx,%4d,%4d,%4d,%4d, 0x%lx )\n",
	    (unsigned long)ifp, xmin, ymin, width, height,
	    (unsigned long)pp );
    return( width*height );
}

HIDDEN int
tk_poll(FBIO *ifp)
{
    FB_CK_FBIO(ifp);
    while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
    fb_log( "fb_poll( 0x%lx )\n", (unsigned long)ifp );
    return	0;
}

HIDDEN int
tk_flush(FBIO *ifp)
{
    FB_CK_FBIO(ifp);
    fb_log( "if_flush( 0x%lx )\n", (unsigned long)ifp );
    return	0;
}

HIDDEN int
tk_free(FBIO *ifp)
{
    FB_CK_FBIO(ifp);
    fb_log( "fb_free( 0x%lx )\n", (unsigned long)ifp );
    return	0;
}

/*ARGSUSED*/
HIDDEN int
tk_help(FBIO *ifp)
{
    FB_CK_FBIO(ifp);
    fb_log( "Description: %s\n", tk_interface.if_type );
    fb_log( "Device: %s\n", ifp->if_name );
    fb_log( "Max width/height: %d %d\n",
	    tk_interface.if_max_width,
	    tk_interface.if_max_height );
    fb_log( "Default width/height: %d %d\n",
	    tk_interface.if_width,
	    tk_interface.if_height );
    fb_log( "\
Usage: /dev/tk[#]\n\
  where # is a optional bit vector from:\n\
    1    debug buffered I/O calls\n\
    2    show colormap entries in rmap/wmap calls\n\
    4    show actual pixel values in read/write calls\n" );
    /*8    buffered read/write values - ifdef'd out*/

    return	0;
}

#else

/* quell empty-compilation unit warnings */
static const int unused = 0;

#endif /* IF_TK */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.9
log
@remove the fblocal.h header file.  it was only used in three places (two files) and only contained one macro (wrapper to fb_log an error), so keep it simple until it's really needed.
@
text
@d456 5
@


14.8
log
@libfb interface files are conditionally empty, so add the appropriate IF_TK protection
@
text
@d44 1
a44 1
#include "./fblocal.h"
@


14.7
log
@protect against duplicate symbols with libdm
@
text
@d1 1
a1 1
/*                      I F _ D E B U G . C
d4 1
a4 1
 * Copyright (c) 2004-2007 United States Government as represented by
d20 2
d24 4
a27 1
 *  Reports all calls to fb_log().
d29 1
a29 3
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_tk.c,v 14.6 2007/05/01 19:19:20 erikgreenwald Exp $ (BRL)";
#endif
d33 2
d39 3
a45 3
#include <tcl.h>
#include <tk.h>

d51 19
a69 19
		fb_tk_close(FBIO *ifp),
		tk_clear(FBIO *ifp, unsigned char *pp),
		tk_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		tk_write(FBIO *ifp, int x, int y, const unsigned char *pixelp, int count),
		tk_rmap(FBIO *ifp, ColorMap *cmp),
		tk_wmap(FBIO *ifp, const ColorMap *cmp),
		tk_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		tk_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		tk_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		tk_cursor(FBIO *ifp, int mode, int x, int y),
		tk_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		tk_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		tk_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		tk_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		tk_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		tk_poll(FBIO *ifp),
		tk_flush(FBIO *ifp),
		tk_free(FBIO *ifp),
		tk_help(FBIO *ifp);
d73 40
a112 40
	0,
	fb_tk_open,
	fb_tk_close,
	tk_clear,
	tk_read,
	tk_write,
	tk_rmap,
	tk_wmap,
	tk_view,
	tk_getview,
	tk_setcursor,
	tk_cursor,
	tk_getcursor,
	tk_readrect,
	tk_writerect,
	tk_bwreadrect,
	tk_bwwriterect,
	tk_poll,
	tk_flush,
	tk_free,
	tk_help,
	"Debugging Interface",
	32*1024,		/* max width */
	32*1024,		/* max height */
	"/dev/tk",
	512,			/* current/default width */
	512,			/* current/default height */
	-1,			/* select fd */
	-1,			/* file descriptor */
	1, 1,			/* zoom */
	256, 256,		/* window center */
	0, 0, 0,		/* cursor */
	PIXEL_NULL,		/* page_base */
	PIXEL_NULL,		/* page_curp */
	PIXEL_NULL,		/* page_endp */
	-1,			/* page_no */
	0,			/* page_ref */
	0L,			/* page_curpos */
	0L,			/* page_pixels */
	0			/* debug */
d119 65
a183 42
	FB_CK_FBIO(ifp);
	if( file == (char *)NULL )
		fb_log( "fb_open( 0x%lx, NULL, %d, %d )\n",
			(unsigned long)ifp, width, height );
	else
		fb_log( "fb_open( 0x%lx, \"%s\", %d, %d )\n",
			(unsigned long)ifp, file, width, height );

	/* check for default size */
	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;

	/* set debug bit vector */
	if( file != NULL ) {
		char *cp;
		for( cp = file; *cp != '\0' && !isdigit(*cp); cp++ ) ;
		sscanf( cp, "%d", &ifp->if_debug );
	} else {
		ifp->if_debug = 0;
	}

	/* Give the user whatever width was asked for */
	ifp->if_width = width;
	ifp->if_height = height;

	fbinterp = Tcl_CreateInterp();
	const char *cmd = "package require Tk";

	if (Tcl_Init(fbinterp) == TCL_ERROR) {
	    fb_log( "Tcl_Init returned error in fb_open." );
	}

	if (Tcl_Eval(fbinterp, cmd) != TCL_OK) {
	    fb_log( "Error returned attempting to start tk in fb_open." );
	}


	fbwin = Tk_MainWindow(fbinterp);

	Tk_GeometryRequest(fbwin, width, height);
d185 2
a186 1
	Tk_MakeWindowExist(fbwin);
d188 2
a189 26
	char image_create_cmd[255];
	sprintf(image_create_cmd,
		"image create photo fb_tk_photo -height %d -width %d",
		 width, height);

	if (Tcl_Eval(fbinterp, image_create_cmd) != TCL_OK) {
	    fb_log( "Error returned attempting to create image in fb_open." );
	}

	if ((fbphoto = Tk_FindPhoto(fbinterp, "fb_tk_photo")) == NULL ) {
	    fb_log( "Image creation unsuccessful in fb_open." );
	}

	char canvas_create_cmd[255];
	sprintf(canvas_create_cmd,
		"canvas .fb_tk_canvas -height %d -width %d", width, height);

	if (Tcl_Eval(fbinterp, canvas_create_cmd) != TCL_OK) {
	    fb_log( "Error returned attempting to create canvas in fb_open." );
	}

	const char canvas_pack_cmd[255] =
		"pack .fb_tk_canvas -fill both -expand true";

	if (Tcl_Eval(fbinterp, canvas_pack_cmd) != TCL_OK) {
	    fb_log( "Error returned attempting to pack canvas in fb_open. %s",
d191 1
a191 1
	}
d193 4
a196 4
	const char place_image_cmd[255] =
		".fb_tk_canvas create image 0 0 -image fb_tk_photo -anchor nw";
	if (Tcl_Eval(fbinterp, place_image_cmd) != TCL_OK) {
	    fb_log( "Error returned attempting to place image in fb_open. %s",
d198 1
a198 1
	}
d200 1
a200 1
	while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
d202 1
a202 1
	return	0;
d208 3
a210 3
	FB_CK_FBIO(ifp);
	fb_log( "fb_close( 0x%lx )\n", (unsigned long)ifp );
	return	0;
d216 9
a224 9
	FB_CK_FBIO(ifp);
	if( pp == 0 )
		fb_log( "fb_clear( 0x%lx, NULL )\n", (unsigned long)ifp );
	else
		fb_log( "fb_clear( 0x%lx, &[%d %d %d] )\n",
			(unsigned long)ifp,
			(int)(pp[RED]), (int)(pp[GRN]),
			(int)(pp[BLU]) );
	return	0;
d230 5
a234 5
	FB_CK_FBIO(ifp);
	fb_log( "fb_read( 0x%lx,%4d,%4d, 0x%lx, %d )\n",
		(unsigned long)ifp, x, y,
		(unsigned long)pixelp, count );
	return	count;
d240 2
a241 2
	int	i;
	unsigned char pixp = *pixelp;
d243 14
a256 17
	FB_CK_FBIO(ifp);
	fb_log( "fb_write( 0x%lx,%4d,%4d, 0x%lx, %d )\n",
		(unsigned long)ifp, x, y,
		(unsigned long)pixelp, count );

	/* write them out, four per line */
	if( ifp->if_debug & FB_DEBUG_RW ) {
		for( i = 0; i < count; i++ ) {
			if( i % 4 == 0 )
				fb_log( "%4d:", i );
			fb_log( "  [%3d,%3d,%3d]", *(pixelp+(i*3)+RED),
				*(pixelp+(i*3)+GRN), *(pixelp+(i*3)+BLU) );
			if( i % 4 == 3 )
				fb_log( "\n" );
		}
		if( i % 4 != 0 )
			fb_log( "\n" );
d258 17
d276 1
a276 15
	Tk_PhotoImageBlock block = {
		&pixp,
		count,
		1,
		3 * ifp->if_width,
		3,
		{
		    RED,
		    GRN,
		    BLU,
		    0
		}
	};

	Tk_PhotoPutBlock(fbinterp, fbphoto, &block, x, ifp->if_height-y, count, 1, TK_PHOTO_COMPOSITE_SET);
d278 1
a278 1
	return	count;
d284 4
a287 4
	FB_CK_FBIO(ifp);
	fb_log( "fb_rmap( 0x%lx, 0x%lx )\n",
		(unsigned long)ifp, (unsigned long)cmp );
	return	0;
d293 9
a301 1
	int	i;
d303 7
a309 16
	FB_CK_FBIO(ifp);
	if( cmp == NULL )
		fb_log( "fb_wmap( 0x%lx, NULL )\n",
			(unsigned long)ifp );
	else
		fb_log( "fb_wmap( 0x%lx, 0x%lx )\n",
			(unsigned long)ifp, (unsigned long)cmp );

	if( ifp->if_debug & FB_DEBUG_CMAP && cmp != NULL ) {
		for( i = 0; i < 256; i++ ) {
			fb_log( "%3d: [ 0x%4lx, 0x%4lx, 0x%4lx ]\n",
				i,
				(unsigned long)cmp->cm_red[i],
				(unsigned long)cmp->cm_green[i],
				(unsigned long)cmp->cm_blue[i] );
		}
d311 1
d313 1
a313 1
	return	0;
d319 5
a323 5
	FB_CK_FBIO(ifp);
	fb_log( "fb_view( 0x%lx,%4d,%4d,%4d,%4d )\n",
		(unsigned long)ifp, xcenter, ycenter, xzoom, yzoom );
	fb_sim_view( ifp, xcenter, ycenter, xzoom, yzoom );
	return	0;
d329 7
a335 7
	FB_CK_FBIO(ifp);
	fb_log( "fb_getview( 0x%lx, 0x%x, 0x%x, 0x%x, 0x%x )\n",
		(unsigned long)ifp, xcenter, ycenter, xzoom, yzoom );
	fb_sim_getview( ifp, xcenter, ycenter, xzoom, yzoom );
	fb_log( " <= %d %d %d %d\n",
		*xcenter, *ycenter, *xzoom, *yzoom );
	return	0;
d341 4
a344 4
	FB_CK_FBIO(ifp);
	fb_log( "fb_setcursor( 0x%lx, 0x%lx, %d, %d, %d, %d )\n",
		(unsigned long)ifp, bits, xbits, ybits, xorig, yorig );
	return	0;
d350 4
a353 4
	fb_log( "fb_cursor( 0x%lx, %d,%4d,%4d )\n",
		(unsigned long)ifp, mode, x, y );
	fb_sim_cursor( ifp, mode, x, y );
	return	0;
d359 6
a364 6
	FB_CK_FBIO(ifp);
	fb_log( "fb_getcursor( 0x%lx, 0x%x,0x%x,0x%x )\n",
		(unsigned long)ifp, mode, x, y );
	fb_sim_getcursor( ifp, mode, x, y );
	fb_log( " <= %d %d %d\n", *mode, *x, *y );
	return	0;
d370 5
a374 5
	FB_CK_FBIO(ifp);
	fb_log( "fb_readrect( 0x%lx, (%4d,%4d), %4d,%4d, 0x%lx )\n",
		(unsigned long)ifp, xmin, ymin, width, height,
		(unsigned long)pp );
	return( width*height );
d380 5
a384 5
	FB_CK_FBIO(ifp);
	fb_log( "fb_writerect( 0x%lx,%4d,%4d,%4d,%4d, 0x%lx )\n",
		(unsigned long)ifp, xmin, ymin, width, height,
		(unsigned long)pp );
	return( width*height );
d390 5
a394 5
	FB_CK_FBIO(ifp);
	fb_log( "fb_bwreadrect( 0x%lx, (%4d,%4d), %4d,%4d, 0x%lx )\n",
		(unsigned long)ifp, xmin, ymin, width, height,
		(unsigned long)pp );
	return( width*height );
d400 5
a404 5
	FB_CK_FBIO(ifp);
	fb_log( "fb_bwwriterect( 0x%lx,%4d,%4d,%4d,%4d, 0x%lx )\n",
		(unsigned long)ifp, xmin, ymin, width, height,
		(unsigned long)pp );
	return( width*height );
d410 4
a413 4
	FB_CK_FBIO(ifp);
	while (Tcl_DoOneEvent(TCL_ALL_EVENTS|TCL_DONT_WAIT));
	fb_log( "fb_poll( 0x%lx )\n", (unsigned long)ifp );
	return	0;
d419 3
a421 3
	FB_CK_FBIO(ifp);
	fb_log( "if_flush( 0x%lx )\n", (unsigned long)ifp );
	return	0;
d427 3
a429 3
	FB_CK_FBIO(ifp);
	fb_log( "fb_free( 0x%lx )\n", (unsigned long)ifp );
	return	0;
d436 10
a445 10
	FB_CK_FBIO(ifp);
	fb_log( "Description: %s\n", tk_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		tk_interface.if_max_width,
		tk_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		tk_interface.if_width,
		tk_interface.if_height );
	fb_log( "\
d451 1
a451 1
	/*8    buffered read/write values - ifdef'd out*/
d453 1
a453 1
	return	0;
d456 2
@


14.6
log
@PhotoPutBlock seems to take the interpreter as the first arg now?
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_tk.c,v 14.5 2007/04/23 13:30:20 joevalleyfield Exp $ (BRL)";
d45 2
a46 2
HIDDEN int	tk_open(FBIO *ifp, char *file, int width, int height),
		tk_close(FBIO *ifp),
d69 2
a70 2
	tk_open,
	tk_close,
d112 1
a112 1
tk_open(FBIO *ifp, char *file, int width, int height)
d201 1
a201 1
tk_close(FBIO *ifp)
@


14.5
log
@preliminary support for unaccelerated mgen on aqua through dm-tk

configure.ac:
        - use two levels of expansion for BRLCAD_DATA
        - enable_aqua configure option
        - move X11 ac_ macro tests from argument check section
        - rely on AC_PATH_XTRA to figure out most of what we need to know about
                where to find X
        - no longer look for libICE, libXmu, or libXsm  AC_PATH_XTRA
                populates X_PRE_LIBS with these but they seem completely unused
                right now.
        - look for opengl libs and headers in all of the places AC_PATH_XTRA
                looked for the xlibs
        - use tk's xlib headers when using tk-aqua rather than x
        - remove X11 "ugly hack"
        - include tk flags where necessary
        - remove --disable-shared from subconfigs
        - forcibly add tcl and tk build dirs to libtool wrapper scripts
libdm/Makefile.am, dm-tk.[ch], dm.h, dm-generic.c, dm_obj.c, mged/Makefile.am,
                attach.c, dm-generic.c, dm-tk.c, ged.c:
        - use lower case when referring to tk
        - add support for using dm-tk
        - include X_CFLAGS with DM_X
irprep/Makefile.am, util/Makefile.am:
        - disable build of ir-X, pl-X when there is no X
dm-X.c:
        - no need to test for HAVE_X11_XLIB here; if we don't have it we
                shouldn't be building this file
libfb/Makefile.am, if_tk.c, libfb/tcl.c:
        - build if_tk.c
        - add preliminary hooks so if_tk can be called when ready
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_tk.c,v 14.4 2007/01/27 01:41:37 brlcad Exp $ (BRL)";
d271 1
a271 1
	Tk_PhotoPutBlock(fbphoto, &block, x, ifp->if_height-y, count, 1, TK_PHOTO_COMPOSITE_SET);
@


14.4
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_tk.c,v 14.3 2007/01/23 01:13:35 brlcad Exp $ (BRL)";
d45 1
a45 1
_LOCAL_ int	tk_open(FBIO *ifp, char *file, int width, int height),
d111 1
a111 1
_LOCAL_ int
d200 1
a200 1
_LOCAL_ int
d208 1
a208 1
_LOCAL_ int
d222 1
a222 1
_LOCAL_ int
d232 1
a232 1
_LOCAL_ int
d276 1
a276 1
_LOCAL_ int
d285 1
a285 1
_LOCAL_ int
d311 1
a311 1
_LOCAL_ int
d321 1
a321 1
_LOCAL_ int
d333 1
a333 1
_LOCAL_ int
d342 1
a342 1
_LOCAL_ int
d351 1
a351 1
_LOCAL_ int
d362 1
a362 1
_LOCAL_ int
d372 1
a372 1
_LOCAL_ int
d382 1
a382 1
_LOCAL_ int
d392 1
a392 1
_LOCAL_ int
d402 1
a402 1
_LOCAL_ int
d411 1
a411 1
_LOCAL_ int
d419 1
a419 1
_LOCAL_ int
d428 1
a428 1
_LOCAL_ int
@


14.3
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_tk.c,v 14.2 2007/01/20 14:36:52 brlcad Exp $ (BRL)";
d151 1
a151 1
	
d156 1
a156 1
	
d160 1
a160 1
	sprintf(image_create_cmd, 
d173 1
a173 1
	sprintf(canvas_create_cmd, 
d180 1
a180 1
	const char canvas_pack_cmd[255] = 
d184 1
a184 1
	    fb_log( "Error returned attempting to pack canvas in fb_open. %s", 
d188 1
a188 1
	const char place_image_cmd[255] = 
d191 1
a191 1
	    fb_log( "Error returned attempting to place image in fb_open. %s", 
@


14.2
log
@update copyright to 2007
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d25 1
a25 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_tk.c,v 14.1 2006/08/10 01:06:15 brlcad Exp $ (BRL)";
@


14.1
log
@add an initial Tk framebuffer interface (implemented by Tim Myers), disabled from the build for now
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d26 1
a26 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_debug.c,v 14.5 2005/01/30 20:30:48 brlcad Exp $ (BRL)";
@

