head	14.43;
access;
symbols
	rel-7-10-4:14.37.2.1
	STABLE:14.37.0.2
	stable-branch:14.7
	rel-7-10-2:14.36
	rel-7-10-0:14.32
	rel-7-8-4:14.27
	rel-7-8-2:14.23
	rel-7-8-0:14.23
	trimnurbs-branch:14.22.0.2
	help:14.22
	temp_tag:14.19
	bobWinPort-20051223-freeze:14.17
	postmerge-20051223-bobWinPort:14.19
	premerge-20051223-bobWinPort:14.19
	rel-7-6-6:14.19
	rel-7-6-4:14.19
	rel-7-6-2:14.17
	rel-7-6-branch:14.17.0.4
	rel-7-6-0:14.17
	rel-7-4-2:14.16
	rel-7-4-branch:14.16.0.2
	bobWinPort:14.17.0.2
	rel-7-4-0:14.16
	rel-7-2-6:14.16
	rel-7-2-4:14.15
	rel-7-2-2:14.7
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.43
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.42;

14.42
date	2007.12.03.15.34.01;	author brlcad;	state Exp;
branches;
next	14.41;

14.41
date	2007.10.26.21.51.26;	author brlcad;	state Exp;
branches;
next	14.40;

14.40
date	2007.09.26.21.09.29;	author brlcad;	state Exp;
branches;
next	14.39;

14.39
date	2007.09.26.19.05.22;	author brlcad;	state Exp;
branches;
next	14.38;

14.38
date	2007.09.15.16.23.10;	author brlcad;	state Exp;
branches;
next	14.37;

14.37
date	2007.08.18.03.15.11;	author brlcad;	state Exp;
branches
	14.37.2.1;
next	14.36;

14.36
date	2007.08.11.05.24.41;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2007.08.03.22.14.59;	author erikgreenwald;	state Exp;
branches;
next	14.34;

14.34
date	2007.08.03.21.39.59;	author erikgreenwald;	state Exp;
branches;
next	14.33;

14.33
date	2007.05.12.22.23.05;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.02.02.08.24.18;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2006.08.08.22.47.15;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2006.08.08.06.47.05;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2006.08.07.18.10.46;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2006.08.07.17.55.16;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2006.03.25.00.03.48;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches
	14.22.2.1;
next	14.21;

14.21
date	2006.01.04.05.41.00;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2005.12.29.08.13.08;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2005.09.16.19.33.37;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2005.08.12.22.30.12;	author lbutler;	state Exp;
branches
	14.17.4.1;
next	14.16;

14.16
date	2005.06.02.13.22.07;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.05.09.19.28.56;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.05.09.18.21.47;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.05.09.17.57.21;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.05.09.17.24.31;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.05.09.14.32.34;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.05.08.19.40.12;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.04.26.08.14.58;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.04.25.22.42.46;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.03.20.00.19.56;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.48;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.58;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.58.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.21;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.42;	author morrison;	state Exp;
branches;
next	;

14.17.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.22.2.1
date	2006.04.07.19.30.18;	author jlowenz;	state Exp;
branches;
next	;

14.37.2.1
date	2007.09.28.14.07.48;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.43
log
@convert all bzero calls to memset
@
text
@/*                        I F _ O G L . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup if */
/** @@{ */
/** @@file if_ogl.c
 *
 *  Frame Buffer Library interface for OpenGL.
 *
 *  There are several different Frame Buffer modes supported.
 *  Set your environment FB_FILE to the appropriate type.
 *  Note that some of the /dev/sgi modes are not supported, and there are
 *  some new modes.
 *  (see the modeflag definitions below).
 *	/dev/ogl[options]
 *
 *  This code is basically a port of the 4d Framebuffer interface from
 *  IRIS GL to OpenGL.
 *
 *  Authors -
 *	Carl Nuzman
 *	Bob Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */
/** @@} */

#ifndef lint
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.42 2007/12/03 15:34:01 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#ifdef IF_OGL

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <signal.h>
#include <errno.h>
#include <X11/keysym.h>
#include <X11/StringDefs.h>
#ifdef HAVE_GL_GLX_H
#  include <GL/glx.h>
#endif
#ifdef HAVE_GL_GL_H
#  include <GL/gl.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif

#undef RED

#include "machine.h"
#include "bu.h"
#include "fb.h"


#define CJDEBUG 0

/*WWW these come from Iris gl gl.h*/
#define XMAXSCREEN	1279
#define YMAXSCREEN	1023

/* Internal callbacks etc.*/
HIDDEN void		ogl_do_event(FBIO *ifp);
HIDDEN void		expose_callback(FBIO *ifp, XEvent *eventPtr);
void ogl_configureWindow FB_ARGS((FBIO *ifp, int width, int height));

/* Other Internal routines */
HIDDEN void		ogl_clipper(register FBIO *ifp);
HIDDEN int		ogl_getmem(FBIO *ifp);
HIDDEN void		backbuffer_to_screen(register FBIO *ifp, int one_y);
HIDDEN void		ogl_cminit(register FBIO *ifp);
#if 0
HIDDEN void		reorder_cursor();
#endif
HIDDEN XVisualInfo *	fb_ogl_choose_visual(FBIO *ifp);
HIDDEN int		is_linear_cmap(register FBIO *ifp);

HIDDEN int	ogl_nwindows = 0; 	/* number of open windows */
HIDDEN int	multiple_windows = 0;	/* someone wants to be ready
					 * for multiple windows, at the
					 * expense of speed.
					 */
HIDDEN	XColor	color_cell[256];		/* used to set colormap */

int ogl_refresh(FBIO *ifp, int x, int y, int w, int h);
int ogl_open_existing(FBIO *ifp, int argc, char **argv);
int ogl_close_existing(FBIO *ifp);
int _ogl_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, XVisualInfo *vip, int width, int height, GLXContext glxc, int double_buffer, int soft_cmap);

HIDDEN int fb_ogl_open(FBIO *ifp, char *file, int width, int height);
HIDDEN int fb_ogl_close(FBIO *ifp);
HIDDEN int ogl_clear(FBIO *ifp, unsigned char *pp);
HIDDEN int ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count);
HIDDEN int ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count);
HIDDEN int ogl_rmap(register FBIO *ifp, register ColorMap *cmp);
HIDDEN int ogl_wmap(register FBIO *ifp, register const ColorMap *cmp);
HIDDEN int ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom);
HIDDEN int ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom);
HIDDEN int ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig);
HIDDEN int ogl_cursor(FBIO *ifp, int mode, int x, int y);
#if 0
HIDDEN int ogl_getcursor();
HIDDEN int ogl_readrect();
HIDDEN int fb_cnull();
#endif
HIDDEN int ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp);
HIDDEN int ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp);
HIDDEN int ogl_poll(FBIO *ifp);
HIDDEN int ogl_flush(FBIO *ifp);
HIDDEN int ogl_free(FBIO *ifp);
HIDDEN int ogl_help(FBIO *ifp);

/* This is the ONLY thing that we normally "export" */
FBIO ogl_interface =
    {
	0,			/* magic number slot	*/
	fb_ogl_open,		/* open device		*/
	fb_ogl_close,		/* close device		*/
	ogl_clear,		/* clear device		*/
	ogl_read,		/* read	pixels		*/
	ogl_write,		/* write pixels		*/
	ogl_rmap,		/* read colormap	*/
	ogl_wmap,		/* write colormap	*/
	ogl_view,		/* set view		*/
	ogl_getview,		/* get view		*/
	ogl_setcursor,		/* define cursor	*/
	ogl_cursor,		/* set cursor		*/
	fb_sim_getcursor,	/* get cursor		*/
	fb_sim_readrect,	/* read rectangle	*/
	ogl_writerect,		/* write rectangle	*/
	fb_sim_bwreadrect,
	ogl_bwwriterect,	/* write rectangle	*/
	ogl_poll,		/* process events	*/
	ogl_flush,		/* flush output		*/
	ogl_free,		/* free resources	*/
	ogl_help,		/* help message		*/
	"Silicon Graphics OpenGL",	/* device description	*/
	XMAXSCREEN+1,			/* max width		*/
	YMAXSCREEN+1,			/* max height		*/
	"/dev/ogl",		/* short device name	*/
	512,			/* default/current width  */
	512,			/* default/current height */
	-1,			/* select file desc	*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	256, 256,		/* window center	*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
    };


/*
 *  Structure of color map in shared memory region.
 *  Has exactly the same format as the SGI hardware "gammaramp" map
 *  Note that only the lower 8 bits are significant.
 */
struct ogl_cmap {
    short	cmr[256];
    short	cmg[256];
    short	cmb[256];
};

/*
 *  This defines the format of the in-memory framebuffer copy.
 *  The alpha component and reverse order are maintained for
 *  compatibility with /dev/sgi
 */
struct ogl_pixel {
    unsigned char alpha;
    unsigned char blue;
    unsigned char green;
    unsigned char red;
};

/* Clipping structure for zoom/pan operations */
struct ogl_clip {
    int	xpixmin;	/* view clipping planes clipped to pixel memory space*/
    int	xpixmax;
    int	ypixmin;
    int	ypixmax;
    int	xscrmin;	/* view clipping planes */
    int	xscrmax;
    int	yscrmin;
    int	yscrmax;
    double	oleft;		/* glOrtho parameters */
    double	oright;
    double	otop;
    double	obottom;

};

/*
 *  Per window state information, overflow area.
 */
struct sgiinfo {
    short	mi_curs_on;
    short	mi_cmap_flag;		/* enabled when there is a non-linear map in memory */
    int	mi_shmid;
    int	mi_memwidth;		/* width of scanline in if_mem */
    short	mi_xoff;		/* X viewport offset, rel. window*/
    short	mi_yoff;		/* Y viewport offset, rel. window*/
    int	mi_pid;			/* for multi-cpu check */
    int	mi_parent;		/* PID of linger-mode process */
    int	mi_doublebuffer;	/* 0=singlebuffer 1=doublebuffer */
    struct ogl_pixel mi_scanline[XMAXSCREEN+1];	/* one scanline */
};

/*
 *  Per window state information particular to the OpenGL interface
 */
struct oglinfo {
    GLXContext	glxc;
    Display	       *dispp;		/* pointer to X display connection */
    Window		wind;		/* Window identifier */
    int		firstTime;
    int		alive;
    long		event_mask;	/* event types to be received */
    short		front_flag;	/* front buffer being used (b-mode) */
    short		copy_flag;	/* pan and zoom copied from backbuffer */
    short		soft_cmap_flag;	/* use software colormapping */
    int		cmap_size;	/* hardware colormap size */
    int 		win_width;	/* actual window width */
    int		win_height;	/* actual window height */
    int		vp_width;	/* actual viewport width */
    int		vp_height;	/* actual viewport height */
    struct ogl_clip	clip;		/* current view clipping */
    Window		cursor;
    XVisualInfo    *vip;		/* pointer to info on current visual */
    Colormap	xcmap;		/* xstyle color map */
    int		use_ext_ctrl;	/* for controlling the Ogl graphics engine externally */
};

#define	SGI(ptr)	((struct sgiinfo *)((ptr)->u1.p))
#define	SGIL(ptr)	((ptr)->u1.p)		/* left hand side version */
#define	OGL(ptr)	((struct oglinfo *)((ptr)->u6.p))
#define	OGLL(ptr)	((ptr)->u6.p)		/* left hand side version */
#define if_mem		u2.p			/* shared memory pointer */
#define if_cmap		u3.p			/* color map in shared memory */
#define CMR(x)		((struct ogl_cmap *)((x)->if_cmap))->cmr
#define CMG(x)		((struct ogl_cmap *)((x)->if_cmap))->cmg
#define CMB(x)		((struct ogl_cmap *)((x)->if_cmap))->cmb
#define if_zoomflag	u4.l			/* zoom > 1 */
#define if_mode		u5.l			/* see MODE_* defines */

#define MARGIN	4			/* # pixels margin to screen edge */

#define CLIP_XTRA 1

#define WIN_L (ifp->if_max_width - ifp->if_width - MARGIN)
#define WIN_T (ifp->if_max_height - ifp->if_height - MARGIN)

/*
 *  The mode has several independent bits:
 *	SHARED -vs- MALLOC'ed memory for the image
 *	TRANSIENT -vs- LINGERING windows
 *	Windowed -vs- Centered Full screen
 *	Suppress dither -vs- dither
 *	Double -vs- Single buffered
 *	DrawPixels -vs- CopyPixels
 */
#define MODE_1MASK	(1<<0)
#define MODE_1SHARED	(0<<0)		/* Use Shared memory */
#define MODE_1MALLOC	(1<<0)		/* Use malloc memory */

#define MODE_2MASK	(1<<1)
#define MODE_2TRANSIENT	(0<<1)
#define MODE_2LINGERING (1<<1)		/* leave window up after closing*/

#define MODE_3MASK	(1<<2)
#define MODE_3WINDOW	(0<<2)		/* window mode */
#define MODE_3FULLSCR	(1<<2)		/* full screen mode */

#define MODE_4MASK	(1<<3)
#define MODE_4NORMAL	(0<<3)		/* dither if it seems necessary */
#define MODE_4NODITH	(1<<3)		/* suppress any dithering */

#define MODE_5MASK	(1<<4)
#define MODE_5NORMAL	(0<<4)	 	/* fast - assume no multiple windows */
#define MODE_5MULTI	(1<<4)		/* be ready for multiple windows */

#define MODE_7MASK	(1<<6)
#define MODE_7NORMAL	(0<<6)		/* install colormap in hardware if possible*/
#define MODE_7SWCMAP	(1<<6)		/* use software colormapping */

#define MODE_9MASK	(1<<8)
#define MODE_9NORMAL	(0<<8)		/* doublebuffer if possible */
#define MODE_9SINGLEBUF	(1<<8)		/* singlebuffer only */

#define MODE_11MASK	(1<<10)
#define MODE_11NORMAL	(0<<10)		/* always draw from mem. to window*/
#define MODE_11COPY	(1<<10)		/* keep full image on back buffer,*/

#define MODE_12MASK	(1<<11)
#define MODE_12NORMAL	(0<<11)
#define MODE_12DELAY_WRITES_TILL_FLUSH	(1<<11)
/* and copy current view to front */
#define MODE_15MASK	(1<<14)
#define MODE_15NORMAL	(0<<14)
#define MODE_15ZAP	(1<<14)		/* zap the shared memory segment */

HIDDEN struct modeflags {
    char	c;
    long	mask;
    long	value;
    char	*help;
} modeflags[] = {
    { 'p',	MODE_1MASK, MODE_1MALLOC,
      "Private memory - else shared" },
    { 'l',	MODE_2MASK, MODE_2LINGERING,
      "Lingering window" },
    { 't',	MODE_2MASK, MODE_2TRANSIENT,
      "Transient window" },
    { 'f',	MODE_3MASK, MODE_3FULLSCR,
      "Full centered screen - else windowed" },
    { 'd',  MODE_4MASK, MODE_4NODITH,
      "Suppress dithering - else dither if not 24-bit buffer" },
    { 'm',  MODE_5MASK, MODE_5MULTI,
      "Be ready for multiple windows - else optimize for single windows" },
    { 'c',	MODE_7MASK, MODE_7SWCMAP,
      "Perform software colormap - else use hardware colormap if possible" },
    { 's',	MODE_9MASK, MODE_9SINGLEBUF,
      "Single buffer -  else double buffer if possible" },
    { 'b',	MODE_11MASK, MODE_11COPY,
      "Fast pan and zoom using backbuffer copy -  else normal " },
    { 'D',	MODE_12DELAY_WRITES_TILL_FLUSH, MODE_12DELAY_WRITES_TILL_FLUSH,
      "Don't update screen until fb_flush() is called.  (Double buffer sim)" },
    { 'z',	MODE_15MASK, MODE_15ZAP,
      "Zap (free) shared memory.  Can also be done with fbfree command" },
    { '\0', 0, 0, "" }
};


/************************************************************************/
/************************************************************************/
/************************************************************************/
/******************* Shared Memory Support ******************************/
/************************************************************************/
/************************************************************************/
/************************************************************************/

/*
 *			O G L _ G E T M E M
 *
 *			not changed from
 *
 *			S G I _ G E T M E M
 *
 *  Because there is no hardware zoom or pan, we need to repaint the
 *  screen (with big pixels) to implement these operations.
 *  This means that the actual "contents" of the frame buffer need
 *  to be stored somewhere else.  If possible, we allocate a shared
 *  memory segment to contain that image.  This has several advantages,
 *  the most important being that when operating the display in 12-bit
 *  output mode, pixel-readbacks still give the full 24-bits of color.
 *  System V shared memory persists until explicitly killed, so this
 *  also means that in MEX mode, the previous contents of the frame
 *  buffer still exist, and can be again accessed, even though the
 *  MEX windows are transient, per-process.
 *
 *  There are a few oddities, however.  The worst is that System V will
 *  not allow the break (see sbrk(2)) to be set above a shared memory
 *  segment, and shmat(2) does not seem to allow the selection of any
 *  reasonable memory address (like 6 Mbytes up) for the shared memory.
 *  In the initial version of this routine, that prevented subsequent
 *  calls to malloc() from succeeding, quite a drawback.  The work-around
 *  used here is to increase the current break to a large value,
 *  attach to the shared memory, and then return the break to its
 *  original value.  This should allow most reasonable requests for
 *  memory to be satisfied.  In special cases, the values used here
 *  might need to be increased.
 */
HIDDEN int
ogl_getmem(FBIO *ifp)
{
#define SHMEM_KEY	42
    int	pixsize;
    int	size;
    int	i;
#if defined(IRIX) && IRIX < 5
    char	*old_brk;
    char	*new_brk;
#endif
    char	*sp;
    int	new = 0;

    errno = 0;

    if( (ifp->if_mode & MODE_1MASK) == MODE_1MALLOC )  {
	/*
	 *  In this mode, only malloc as much memory as is needed.
	 */
	SGI(ifp)->mi_memwidth = ifp->if_width;
	pixsize = ifp->if_height * ifp->if_width * sizeof(struct ogl_pixel);
	size = pixsize + sizeof(struct ogl_cmap);

	sp = calloc( 1, size );
	if( sp == 0 )  {
	    fb_log("ogl_getmem: frame buffer memory malloc failed\n");
	    goto fail;
	}
	new = 1;
	goto success;
    }

    /* The shared memory section never changes size */
    SGI(ifp)->mi_memwidth = ifp->if_max_width;

    /*
     *  On Irix 5 with Indigo EXPRESS graphics,
     *  lrectwrite() runs off the end!
     *  So, provide a pad area of 2 scanlines.
     *  (1 line is enough, but this avoids risk of damage to colormap table.)
     */
    pixsize = (ifp->if_max_height+2) * ifp->if_max_width *
	sizeof(struct ogl_pixel);

    size = pixsize + sizeof(struct ogl_cmap);
    size = (size + getpagesize()-1) & ~(getpagesize()-1);

    /* First try to attach to an existing one */
    if( (SGI(ifp)->mi_shmid = shmget( SHMEM_KEY, size, 0 )) < 0 )  {
	/* No existing one, create a new one */
	if( (SGI(ifp)->mi_shmid = shmget(
					 SHMEM_KEY, size, IPC_CREAT|0666 )) < 0 )  {
	    fb_log("ogl_getmem: shmget failed, errno=%d\n", errno);
	    goto fail;
	}
	new = 1;
    }

    /* WWW this is unnecessary in this version? */
#if defined(IRIX) && IRIX < 5
    /* Move up the existing break, to leave room for later malloc()s */
    old_brk = sbrk(0);
    new_brk = (char *)(6 * (XMAXSCREEN+1) * 1024L);
    if( new_brk <= old_brk )
	new_brk = old_brk + (XMAXSCREEN+1) * 1024;
    new_brk = (char *)((((long)new_brk) + getpagesize()-1) & ~(getpagesize()-1));
    if( brk( new_brk ) < 0 )  {
	fb_log("ogl_getmem: new brk(x%x) failure, errno=%d\n", new_brk, errno);
	goto fail;
    }

    /* Open the segment Read/Write, near the current break */
    if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1L) )  {
	fb_log("ogl_getmem: shmat returned x%x, errno=%d\n", sp, errno );
	goto fail;
    }

    /* Restore the old break */
    if( brk( old_brk ) < 0 )  {
	fb_log("ogl_getmem: restore brk(x%x) failure, errno=%d\n", old_brk, errno);
	/* Take the memory and run */
    }
#else
    /* Open the segment Read/Write */
    /* On Irix 5, this gets mapped in at a high address, no problem. */
    if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1L) )  {
	fb_log("ogl_getmem: shmat returned x%x, errno=%d\n", sp, errno );
	goto fail;
    }
#endif

 success:
    ifp->if_mem = sp;
    ifp->if_cmap = sp + pixsize;	/* cmap at end of area */
    i = CMB(ifp)[255];		/* try to deref last word */
    CMB(ifp)[255] = i;

    /* Provide non-black colormap on creation of new shared mem */
    if(new)
	ogl_cminit( ifp );
    return(0);
 fail:
    fb_log("ogl_getmem:  Unable to attach to shared memory.\n");
    if( (sp = calloc( 1, size )) == NULL )  {
	fb_log("ogl_getmem:  malloc failure\n");
	return(-1);
    }
    new = 1;
    goto success;
}


/*
 *			O G L _ Z A P M E M
 */
void
ogl_zapmem(void)
{
    int shmid;
    int i;

    if( (shmid = shmget( SHMEM_KEY, 0, 0 )) < 0 )  {
	fb_log("ogl_zapmem shmget failed, errno=%d\n", errno);
	return;
    }

    i = shmctl( shmid, IPC_RMID, 0 );
    if( i < 0 )  {
	fb_log("ogl_zapmem shmctl failed, errno=%d\n", errno);
	return;
    }
    fb_log("if_ogl: shared memory released\n");
}


/*
 *			S I G K I D
 */
HIDDEN void
#if _XOPEN_SOURCE
sigkid(int pid)

#else
     sigkid(int pid)
#endif
{
    exit(0);
}


/* 			O G L _ X M I T _ S C A N L I N E S
 *
 * Note: unlike sgi_xmit_scanlines, this function updates an arbitrary
 * rectangle of the frame buffer
 */
HIDDEN void
ogl_xmit_scanlines(register FBIO *ifp, int ybase, int nlines, int xbase, int npix)
{
    register int	y;
    register int	n;
    int		sw_cmap;	/* !0 => needs software color map */
    struct ogl_clip	*clp;

    /* Caller is expected to handle attaching context, etc. */

    clp = &(OGL(ifp)->clip);

    if( OGL(ifp)->soft_cmap_flag  && SGI(ifp)->mi_cmap_flag )  {
	sw_cmap = 1;
    } else {
	sw_cmap = 0;
    }

    if(xbase > clp->xpixmax || ybase > clp->ypixmax)
	return;
    if(xbase < clp->xpixmin)
	xbase = clp->xpixmin;
    if(ybase < clp->ypixmin)
	ybase = clp->ypixmin;

    if((xbase + npix -1 ) > clp->xpixmax)
	npix = clp->xpixmax - xbase + 1;
    if((ybase + nlines - 1) > clp->ypixmax)
	nlines = clp->ypixmax - ybase + 1;

    if(!OGL(ifp)->use_ext_ctrl){
	if (!OGL(ifp)->copy_flag){
	    /*
	     * Blank out areas of the screen around the image, if exposed.
	     * In COPY mode, this is done in backbuffer_to_screen().
	     */

	    /* Blank out area left of image */
	    glColor3b( 0, 0, 0 );
	    if( clp->xscrmin < 0 )  glRecti(clp->xscrmin - CLIP_XTRA,
					    clp->yscrmin - CLIP_XTRA,
					    CLIP_XTRA,
					    clp->yscrmax + CLIP_XTRA);

	    /* Blank out area below image */
	    if( clp->yscrmin < 0 )  glRecti(clp->xscrmin - CLIP_XTRA,
					    clp->yscrmin - CLIP_XTRA,
					    clp->xscrmax + CLIP_XTRA,
					    CLIP_XTRA);

	    /* Blank out area right of image */
	    if( clp->xscrmax >= ifp->if_width )  glRecti(ifp->if_width - CLIP_XTRA,
							 clp->yscrmin - CLIP_XTRA,
							 clp->xscrmax + CLIP_XTRA,
							 clp->yscrmax + CLIP_XTRA);

	    /* Blank out area above image */
	    if( clp->yscrmax >= ifp->if_height )  glRecti(clp->xscrmin - CLIP_XTRA,
							  ifp->if_height- CLIP_XTRA,
							  clp->xscrmax + CLIP_XTRA,
							  clp->yscrmax + CLIP_XTRA);

	} else if (OGL(ifp)->front_flag) {
	    /* in COPY mode, always draw full sized image into backbuffer.
	     * backbuffer_to_screen() is used to update the front buffer
	     */
	    glDrawBuffer(GL_BACK);
	    OGL(ifp)->front_flag = 0;
	    glMatrixMode(GL_PROJECTION);
	    glPushMatrix();	/* store current view clipping matrix*/
	    glLoadIdentity();
	    glOrtho( -0.25, ((GLdouble) OGL(ifp)->vp_width)-0.25,
		     -0.25, ((GLdouble) OGL(ifp)->vp_height)-0.25,
		     -1.0, 1.0);
	    glPixelZoom( 1.0, 1.0);
	}
    }

    if( sw_cmap ) {
	/* Software colormap each line as it's transmitted */
	register int	x;
	register struct ogl_pixel	*oglp;
	register struct ogl_pixel	*op;

	y = ybase;
	if(CJDEBUG) printf("Doing sw colormap xmit\n");
	/* Perform software color mapping into temp scanline */
	op = SGI(ifp)->mi_scanline;
	for( n=nlines; n>0; n--, y++ )  {
	    oglp = (struct ogl_pixel *)&ifp->if_mem[
						    (y*SGI(ifp)->mi_memwidth)*
						    sizeof(struct ogl_pixel) ];
	    for( x=xbase+npix-1; x>=xbase; x-- )  {
		op[x].red   = CMR(ifp)[oglp[x].red];
		op[x].green = CMG(ifp)[oglp[x].green];
		op[x].blue  = CMB(ifp)[oglp[x].blue];
	    }

	    glPixelStorei(GL_UNPACK_SKIP_PIXELS,xbase);
	    glRasterPos2i(xbase,y);
	    glDrawPixels(npix,1,GL_ABGR_EXT,GL_UNSIGNED_BYTE,
			 (const GLvoid *) op);

	}

    } else  {
	/* No need for software colormapping */

	glPixelStorei(GL_UNPACK_ROW_LENGTH,SGI(ifp)->mi_memwidth);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS,xbase);
	glPixelStorei(GL_UNPACK_SKIP_ROWS,ybase);

	glRasterPos2i(xbase,ybase);
	glDrawPixels(npix,nlines,GL_ABGR_EXT,GL_UNSIGNED_BYTE,
		     (const GLvoid *) ifp->if_mem);
    }
}


HIDDEN int
fb_ogl_open(FBIO *ifp, char *file, int width, int height)
{

    int		f;
    int		status;
    static char	title[128];
    int		mode, i, direct;
    long		valuemask;
    XSetWindowAttributes swa;

    FB_CK_FBIO(ifp);

    /*
     *  First, attempt to determine operating mode for this open,
     *  based upon the "unit number" or flags.
     *  file = "/dev/ogl###"
     */
    mode = MODE_2LINGERING;

    if( file != NULL )  {
	register char *cp;
	char	modebuf[80];
	char	*mp;
	int	alpha;
	struct	modeflags *mfp;

	if (strncmp(file, ifp->if_name, strlen(ifp->if_name))) {
	    /* How did this happen? */
	    mode = 0;
	} else {
	    /* Parse the options */
	    alpha = 0;
	    mp = &modebuf[0];
	    cp = &file[8];
	    while( *cp != '\0' && !isspace(*cp) ) {
		*mp++ = *cp;	/* copy it to buffer */
		if( isdigit(*cp) ) {
		    cp++;
		    continue;
		}
		alpha++;
		for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		    if( mfp->c == *cp ) {
			mode = (mode&~mfp->mask)|mfp->value;
			break;
		    }
		}
		if( mfp->c == '\0' && *cp != '-' ) {
		    fb_log( "if_ogl: unknown option '%c' ignored\n", *cp );
		}
		cp++;
	    }
	    *mp = '\0';
	    if( !alpha ) {
		mode |= atoi( modebuf );
	    }
	}

	if( (mode & MODE_15MASK) == MODE_15ZAP ) {
	    /* Only task: Attempt to release shared memory segment */
	    ogl_zapmem();
	    return(-1);
	}
    }
    ifp->if_mode = mode;

    /*
     *  Allocate extension memory sections,
     *  addressed by SGI(ifp)->mi_xxx and OGL(ifp)->xxx
     */

    if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
	fb_log("fb_ogl_open:  sgiinfo malloc failed\n");
	return(-1);
    }
    if( (OGLL(ifp) = (char *)calloc( 1, sizeof(struct oglinfo) )) == NULL )  {
	fb_log("fb_ogl_open:  oglinfo malloc failed\n");
	return(-1);
    }

    SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */

    if (ogl_nwindows && !multiple_windows){
	fb_log("Warning - fb_ogl_open: Multiple windows opened. Use /dev/oglm for first window!");
    }

    /* Anyone can turn this on; no one can turn it off */
    if( (ifp->if_mode & MODE_5MASK) == MODE_5MULTI )
	multiple_windows = 1;

    /* the Silicon Graphics Library Window management routines
     * use shared memory. This causes lots of problems when you
     * want to pass a window structure to a child process.
     * One hack to get around this is to immediately fork
     * and create a child process and sleep until the child
     * sends a kill signal to the parent process. (in FBCLOSE)
     * This allows us to use the traditional fb utility programs
     * as well as allow the frame buffer window to remain around
     * until killed by the menu subsystem.
     */

    if( (ifp->if_mode & MODE_2MASK) == MODE_2LINGERING )  {
	/* save parent pid for later signalling */
	SGI(ifp)->mi_parent = bu_process_id();

	signal( SIGUSR1, sigkid);

	if( (f = fork()) != 0 )  {
	    /* Parent process */
	    int k;

	    /* parent doesn't need these any more */
	    for (k=0; k < 20; k++) {
		close(k);
	    }

	    /*
	     *  Wait until the child dies, of whatever cause,
	     *  or until the child kills us.
	     *  Pretty vicious, this computer society.
	     */
	    while( (k = wait(&status)) != -1 && k != f )
		/* NULL */ ;

	    exit(0);
	    /* NOTREACHED */
	} else if( f < 0 )  {
	    fb_log("fb_ogl_open:  linger-mode fork failure\n");
	    return(-1);
	}
	/* Child Process falls through */
    }

    if( (ifp->if_mode & MODE_3MASK) == MODE_3FULLSCR )  {
	/* Bump default size up to full screen, since we have it all */
	ifp->if_width = XMAXSCREEN+1;		/* 1280 */
	ifp->if_height = YMAXSCREEN+1;		/* 1024 */
    }

    /* use defaults if invalid width and height specified */
    if( width <= 0 )
	width = ifp->if_width;
    if( height <= 0 )
	height = ifp->if_height;
    /* use max values if width and height are greater */
    if ( width > ifp->if_max_width )
	width = ifp->if_max_width;
    if ( height > ifp->if_max_height)
	height = ifp->if_max_height;

    ifp->if_width = width;
    ifp->if_height = height;


    if( (ifp->if_mode & MODE_3MASK) == MODE_3WINDOW )  {
	SGI(ifp)->mi_curs_on = 1;
    }  else  {
	/* MODE_3MASK == MODE_3FULLSCR */
	SGI(ifp)->mi_curs_on = 0;
    }

    /* Build a descriptive window title bar */
    (void)snprintf( title, 128, "BRL-CAD /dev/ogl %s, %s",
		   ((ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT) ?
		   "Transient Win":
		   "Lingering Win",
		   ((ifp->if_mode & MODE_1MASK) == MODE_1MALLOC) ?
		   "Private Mem" :
		   "Shared Mem" );


    /* initialize window state variables before calling ogl_getmem */
    ifp->if_zoomflag = 0;
    ifp->if_xzoom = 1;	/* for zoom fakeout */
    ifp->if_yzoom = 1;	/* for zoom fakeout */
    ifp->if_xcenter = width/2;
    ifp->if_ycenter = height/2;
    SGI(ifp)->mi_pid = bu_process_id();

    /* Attach to shared memory, potentially with a screen repaint */
    if( ogl_getmem(ifp) < 0 )
	return(-1);

    /* Open an X connection to the display.  Sending NULL to XOpenDisplay
       tells it to use the DISPLAY environment variable. */
    if( (OGL(ifp)->dispp = XOpenDisplay(NULL)) == NULL ) {
	fb_log("fb_ogl_open: Failed to open display.  Check DISPLAY environment variable.\n");
	return (-1);
    }
    ifp->if_selfd = ConnectionNumber(OGL(ifp)->dispp);
    if( CJDEBUG ) {
	printf("Connection opened to X display on fd %d.\n",
	       ConnectionNumber(OGL(ifp)->dispp));
    }

    /* Choose an appropriate visual. */
    if( (OGL(ifp)->vip = fb_ogl_choose_visual(ifp)) == NULL ) {
	fb_log("fb_ogl_open: Couldn't find an appropriate visual.  Exiting.\n");
	return (-1);
    }

    /* Open an OpenGL context with this visual*/
    if (multiple_windows) {	/* force indirect context */
	OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,
					  OGL(ifp)->vip, 0, False);
    } else {		/* try direct context */
	OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,
					  OGL(ifp)->vip, 0, True);
    }
    direct = glXIsDirect(OGL(ifp)->dispp,OGL(ifp)->glxc);
    if (!direct) {
	/* we failed to get a direct context, so we must acquire/release the context */
	multiple_windows=1;
    }

    if (CJDEBUG) {
	fb_log("Framebuffer drawing context is %s.\n", direct ? "direct" : "indirect");
    }

    /* Create a colormap for this visual */
    SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
    if (!OGL(ifp)->soft_cmap_flag) {
	OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp,
					  RootWindow(OGL(ifp)->dispp,
						     OGL(ifp)->vip->screen),
					  OGL(ifp)->vip->visual,
					  AllocAll);
	/* initialize virtual colormap - it will be loaded into
	 * the hardware. This code has not yet been tested.
	 */
	if(CJDEBUG) printf("Loading read/write colormap.\n");
	for (i = 0; i < 256; i++) {
	    color_cell[i].pixel = i;
	    color_cell[i].red = CMR(ifp)[i];
	    color_cell[i].green = CMG(ifp)[i];
	    color_cell[i].blue = CMB(ifp)[i];
	    color_cell[i].flags = DoRed | DoGreen | DoBlue;
	}
	XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell,256);
    } else { /* read only colormap */
	if( CJDEBUG ) {
	    printf("Allocating read-only colormap.");
	}
	OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp,
					  RootWindow(OGL(ifp)->dispp,
						     OGL(ifp)->vip->screen),
					  OGL(ifp)->vip->visual,
					  AllocNone);
    }

    XSync(OGL(ifp)->dispp, 0);

    /* Create a window. */
    memset(&swa, 0, sizeof(swa));

    valuemask = CWBackPixel | CWBorderPixel | CWEventMask | CWColormap;

    swa.background_pixel = BlackPixel(OGL(ifp)->dispp,
				      OGL(ifp)->vip->screen);
    swa.border_pixel = BlackPixel(OGL(ifp)->dispp,
				  OGL(ifp)->vip->screen);
    swa.event_mask = OGL(ifp)->event_mask =
	ExposureMask | KeyPressMask | KeyReleaseMask |
	ButtonPressMask | ButtonReleaseMask;
    swa.colormap = OGL(ifp)->xcmap;

#define XCreateWindowDebug(display, parent, x, y, width, height, \
			   border_width, depth, class, visual, valuemask, \
			   attributes) \
	(printf("XCreateWindow( display = %08X,\n", (long)display), \
	printf("                parent = %08X,\n", (long)parent), \
	printf("                     x = %d,\n", x), \
	printf("                     y = %d,\n", y), \
	printf("                 width = %d,\n", width), \
	printf("                height = %d,\n", height), \
	printf("          border_width = %d,\n", border_width), \
	printf("                 depth = %d,\n", depth), \
	printf("                 class = %d,\n", class), \
	printf("                visual = %08X,\n", (long)visual), \
	printf("             valuemask = %08X,\n", valuemask), \
	printf("            attributes = {"), \
	(valuemask & CWBackPixmap) ? printf(" background_pixmap = %08X ", (long)((attributes)->background_pixmap)) : 0, \
	(valuemask & CWBackPixel) ? printf(" background_pixel = %08X ", (attributes)->background_pixel) : 0, \
	(valuemask & CWBorderPixmap) ? printf(" border_pixmap = %08X ", (long)((attributes)->border_pixmap)) : 0, \
	(valuemask & CWBorderPixel) ? printf(" border_pixel = %08X ", (attributes)->border_pixel) : 0, \
	(valuemask & CWBitGravity) ? printf(" bit_gravity = %d ", (attributes)->bit_gravity) : 0, \
	(valuemask & CWWinGravity) ? printf(" win_gravity = %d ", (attributes)->win_gravity) : 0, \
	(valuemask & CWBackingStore) ? printf(" backing_store = %d ", (attributes)->backing_store) : 0, \
	(valuemask & CWBackingPlanes) ? printf(" backing_planes = %d ", (attributes)->backing_planes) : 0, \
	(valuemask & CWBackingPixel) ? printf(" backing_pixel = %08X ", (attributes)->backing_pixel) : 0, \
	(valuemask & CWOverrideRedirect) ? printf(" override_redirect = %d ", (attributes)->override_redirect) : 0, \
	(valuemask & CWSaveUnder) ? printf(" save_under = %d ", (attributes)->save_under) : 0, \
	(valuemask & CWEventMask) ? printf(" event_mask = %08X ", (attributes)->event_mask) : 0, \
	(valuemask & CWDontPropagate) ? printf(" do_not_propagate_mask = %08X ", (attributes)->do_not_propagate_mask) : 0, \
	(valuemask & CWColormap) ? printf(" colormap = %08X ", (long)((attributes)->colormap)) : 0, \
	(valuemask & CWCursor) ? printf(" cursor = %08X ", (long)((attributes)->cursor)) : 0, \
	printf(" }\n")) > 0 ? XCreateWindow(display, parent, x, y, width, height, border_width, depth, class, visual, valuemask, attributes) : -1;

    OGL(ifp)->wind = XCreateWindow(OGL(ifp)->dispp,
				   RootWindow(OGL(ifp)->dispp,
					      OGL(ifp)->vip->screen),
				   0, 0, ifp->if_width, ifp->if_height, 0,
				   OGL(ifp)->vip->depth,
				   InputOutput,
				   OGL(ifp)->vip->visual,
				   valuemask, &swa);

    XStoreName(OGL(ifp)->dispp, OGL(ifp)->wind, title);

    /* count windows */
    ogl_nwindows++;
    XMapRaised(OGL(ifp)->dispp, OGL(ifp)->wind);

    OGL(ifp)->alive = 1;
    OGL(ifp)->firstTime = 1;

    /* Loop through events until first exposure event is processed */
    while (OGL(ifp)->firstTime == 1)
	ogl_do_event(ifp);

    return 0;
}


int
ogl_open_existing(FBIO *ifp, int argc, char **argv)
{
    Display *dpy;
    Window win;
    Colormap cmap;
    XVisualInfo *vip;
    int width;
    int height;
    GLXContext glxc;
    int double_buffer;
    int soft_cmap;

    if(argc != 10)
	return -1;

    if(sscanf(argv[1], "%lu", (unsigned long *)&dpy) != 1)
	return -1;

    if(sscanf(argv[2], "%lu", (unsigned long *)&win) != 1)
	return -1;

    if(sscanf(argv[3], "%lu", (unsigned long *)&cmap) != 1)
	return -1;

    if(sscanf(argv[4], "%lu", (unsigned long *)&vip) != 1)
	return -1;

    if(sscanf(argv[5], "%d", &width) != 1)
	return -1;

    if(sscanf(argv[6], "%d", &height) != 1)
	return -1;

    if(sscanf(argv[7], "%lu", (unsigned long *)&glxc) != 1)
	return -1;

    if(sscanf(argv[8], "%d", &double_buffer) != 1)
	return -1;

    if(sscanf(argv[9], "%d", &soft_cmap) != 1)
	return -1;

    return _ogl_open_existing(ifp, dpy, win, cmap, vip, width, height,
			      glxc, double_buffer, soft_cmap);
}


int
_ogl_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, XVisualInfo *vip, int width, int height, GLXContext glxc, int double_buffer, int soft_cmap)
{

    /*XXX for now use private memory */
    ifp->if_mode = MODE_1MALLOC;

    /*
     *  Allocate extension memory sections,
     *  addressed by SGI(ifp)->mi_xxx and OGL(ifp)->xxx
     */

    if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
	fb_log("fb_ogl_open:  sgiinfo malloc failed\n");
	return -1;
    }
    if( (OGLL(ifp) = (char *)calloc( 1, sizeof(struct oglinfo) )) == NULL )  {
	fb_log("fb_ogl_open:  oglinfo malloc failed\n");
	return -1;
    }

    OGL(ifp)->use_ext_ctrl = 1;

    SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */
    multiple_windows = 1;
    ifp->if_width = ifp->if_max_width = width;
    ifp->if_height = ifp->if_max_height = height;

    OGL(ifp)->win_width = OGL(ifp)->vp_width = width;
    OGL(ifp)->win_height = OGL(ifp)->vp_height = height;

    SGI(ifp)->mi_curs_on = 1;

    /* initialize window state variables before calling ogl_getmem */
    ifp->if_zoomflag = 0;
    ifp->if_xzoom = 1;	/* for zoom fakeout */
    ifp->if_yzoom = 1;	/* for zoom fakeout */
    ifp->if_xcenter = width/2;
    ifp->if_ycenter = height/2;
    SGI(ifp)->mi_pid = bu_process_id();

    /* Attach to shared memory, potentially with a screen repaint */
    if(ogl_getmem(ifp) < 0)
	return -1;

    OGL(ifp)->dispp = dpy;
    ifp->if_selfd = ConnectionNumber(OGL(ifp)->dispp);

    OGL(ifp)->vip = vip;
    OGL(ifp)->glxc = glxc;
    SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
    OGL(ifp)->soft_cmap_flag = soft_cmap;
    SGI(ifp)->mi_doublebuffer = double_buffer;
    OGL(ifp)->xcmap = cmap;

    OGL(ifp)->wind = win;
    ++ogl_nwindows;

    OGL(ifp)->alive = 1;
    OGL(ifp)->firstTime = 1;

    ogl_clipper(ifp);

    return 0;
}

HIDDEN int
ogl_final_close(FBIO *ifp)
{

    if( CJDEBUG ) {
	printf("ogl_final_close: All done...goodbye!\n");
    }

    if(OGL(ifp)->cursor)
	XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);

    XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->wind);
    XFreeColormap(OGL(ifp)->dispp, OGL(ifp)->xcmap);

    if( SGIL(ifp) != NULL ) {
	/* free up memory associated with image */
	if( SGI(ifp)->mi_shmid != -1 ) {
	    /* detach from shared memory */
	    if( shmdt( ifp->if_mem ) == -1 ) {
		fb_log("fb_ogl_close shmdt failed, errno=%d\n",
		       errno);
		return -1;
	    }
	} else {
	    /* free private memory */
	    (void)free( ifp->if_mem );
	}
	/* free state information */
	(void)free( (char *)SGIL(ifp) );
	SGIL(ifp) = NULL;
    }

    if( OGLL(ifp) != NULL) {
	(void) free( (char *)OGLL(ifp) );
	OGLL(ifp) = NULL;
    }

    ogl_nwindows--;
    return(0);
}


HIDDEN int
fb_ogl_close(FBIO *ifp)
{

    ogl_flush( ifp );

    /* only the last open window can linger -
     * call final_close if not lingering
     */
    if( ogl_nwindows > 1 ||
	(ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT )
	return ogl_final_close( ifp );

    if( CJDEBUG )
	printf("fb_ogl_close: remaining open to linger awhile.\n");

    /*
     *  else:
     *  LINGER mode.  Don't return to caller until user mouses "close"
     *  menu item.  This may delay final processing in the calling
     *  function for some time, but the assumption is that the user
     *  wishes to compare this image with others.
     *
     *  Since we plan to linger here, long after our invoker
     *  expected us to be gone, be certain that no file descriptors
     *  remain open to associate us with pipelines, network
     *  connections, etc., that were ALREADY ESTABLISHED before
     *  the point that fb_open() was called.
     *
     *  The simple for i=0..20 loop will not work, because that
     *  smashes some window-manager files.  Therefore, we content
     *  ourselves with eliminating stdin and stdout (fd 0,1), in the
     *  hopes that this will successfully terminate any pipes or
     *  network connections.  Standard error/out may be used to print
     *  framebuffer debug messages, so they're kept around.
     */
    fclose( stdin );

    /* Ignore likely signals, perhaps in the background,
     * from other typing at the keyboard
     */
    (void)signal( SIGHUP, SIG_IGN );
    (void)signal( SIGINT, SIG_IGN );
    (void)signal( SIGQUIT, SIG_IGN );
    (void)signal( SIGALRM, SIG_IGN );

    while( 0 < OGL(ifp)->alive ) {
	ogl_do_event(ifp);
    }

    return 0;
}

int
ogl_close_existing(FBIO *ifp)
{
    if(OGL(ifp)->cursor)
	XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);

    if( SGIL(ifp) != NULL ) {
	/* free up memory associated with image */
	if( SGI(ifp)->mi_shmid != -1 ) {
	    /* detach from shared memory */
	    if( shmdt( ifp->if_mem ) == -1 ) {
		fb_log("fb_ogl_close: shmdt failed, errno=%d\n",
		       errno);
		return -1;
	    }
	} else {
	    /* free private memory */
	    (void)free( ifp->if_mem );
	}
	/* free state information */
	(void)free( (char *)SGIL(ifp) );
	SGIL(ifp) = NULL;
    }

    if( OGLL(ifp) != NULL) {
	(void) free( (char *)OGLL(ifp) );
	OGLL(ifp) = NULL;
    }

    return 0;
}


/*
 *			O G L _ P O L L
 *
 *	Handle any pending input events
 */
HIDDEN int
ogl_poll(FBIO *ifp)
{
    ogl_do_event(ifp);

    if (OGL(ifp)->alive < 0)
	return(1);
    else
	return(0);
}


/*
 *			O G L _ F R E E
 *
 *  Free shared memory resources, and close.
 */
HIDDEN int
ogl_free(FBIO *ifp)
{
    int	ret;

    if(CJDEBUG) printf("entering  ogl_free\n");
    /* Close the framebuffer */
    ret = ogl_final_close( ifp );

    if( (ifp->if_mode & MODE_1MASK) == MODE_1SHARED ) {
	/* If shared mem, release the shared memory segment */
	ogl_zapmem();
    }
    return ret;
}


HIDDEN int
ogl_clear(FBIO *ifp, unsigned char *pp)

     /* pointer to beginning of memory segment*/
{
    struct ogl_pixel		bg;
    register struct ogl_pixel      *oglp;
    register int			cnt;
    register int			y;

    if( CJDEBUG ) printf("entering ogl_clear\n");

    if (multiple_windows) {
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
	    fb_log("Warning, ogl_clear: glXMakeCurrent unsuccessful.\n");
	}
    }

    /* Set clear colors */
    if ( pp != RGBPIXEL_NULL)  {
	bg.alpha = 0;
	bg.red   = (pp)[RED];
	bg.green = (pp)[GRN];
	bg.blue  = (pp)[BLU];
	glClearColor( pp[RED]/255.0, pp[GRN]/255.0, pp[BLU]/255.0, 0.0 );
    } else {
	bg.alpha = 0;
	bg.red   = 0;
	bg.green = 0;
	bg.blue  = 0;
	glClearColor( 0, 0, 0, 0 );
    }

    /* Flood rectangle in shared memory */
    for( y=0; y < ifp->if_height; y++ )  {
	oglp = (struct ogl_pixel *)&ifp->if_mem[
						(y*SGI(ifp)->mi_memwidth+0)*sizeof(struct ogl_pixel) ];
	for( cnt=ifp->if_width-1; cnt >= 0; cnt-- )  {
	    *oglp++ = bg;	/* struct copy */
	}
    }


    /* Update screen */
    if(OGL(ifp)->use_ext_ctrl){
	glClear(GL_COLOR_BUFFER_BIT);
    }else{
	if ( OGL(ifp)->copy_flag){
	    /* COPY mode: clear both buffers */
	    if (OGL(ifp)->front_flag){
		glDrawBuffer(GL_BACK);
		glClear(GL_COLOR_BUFFER_BIT);
		glDrawBuffer(GL_FRONT);
		glClear(GL_COLOR_BUFFER_BIT);
	    } else {
		glDrawBuffer(GL_FRONT);
		glClear(GL_COLOR_BUFFER_BIT);
		glDrawBuffer(GL_BACK);
		glClear(GL_COLOR_BUFFER_BIT);
	    }
	} else {
	    glClear(GL_COLOR_BUFFER_BIT);
	    if(SGI(ifp)->mi_doublebuffer){
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	    }
	}

	if (multiple_windows) {
	    /* unattach context for other threads to use */
	    glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
    }

    return(0);
}


/*
 *			O G L _ V I E W
 */
HIDDEN int
ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
    struct ogl_clip *clp;

    if(CJDEBUG) printf("entering ogl_view\n");

    if( xzoom < 1 ) xzoom = 1;
    if( yzoom < 1 ) yzoom = 1;
    if( ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	&& ifp->if_xzoom == xzoom && ifp->if_yzoom == yzoom )
	return(0);

    if( xcenter < 0 || xcenter >= ifp->if_width )
	return(-1);
    if( ycenter < 0 || ycenter >= ifp->if_height )
	return(-1);
    if( xzoom >= ifp->if_width || yzoom >= ifp->if_height )
	return(-1);

    ifp->if_xcenter = xcenter;
    ifp->if_ycenter = ycenter;
    ifp->if_xzoom = xzoom;
    ifp->if_yzoom = yzoom;

    if( ifp->if_xzoom > 1 || ifp->if_yzoom > 1 )
	ifp->if_zoomflag = 1;
    else	ifp->if_zoomflag = 0;


    if(OGL(ifp)->use_ext_ctrl){
	ogl_clipper(ifp);
    }else{
	if (multiple_windows) {
	    if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_view: glXMakeCurrent unsuccessful.\n");
	    }
	}

	/* Set clipping matrix  and zoom level */
	glMatrixMode(GL_PROJECTION);
	if (OGL(ifp)->copy_flag && !OGL(ifp)->front_flag){
	    /* COPY mode - no changes to backbuffer copy - just
	     * need to update front buffer
	     */
	    glPopMatrix();
	    glDrawBuffer(GL_FRONT);
	    OGL(ifp)->front_flag = 1;
	}
	glLoadIdentity();

	ogl_clipper(ifp);
	clp = &(OGL(ifp)->clip);
	glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop, -1.0, 1.0);
	glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);

	if (OGL(ifp)->copy_flag){
	    backbuffer_to_screen(ifp,-1);
	} else {
	    ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	    if(SGI(ifp)->mi_doublebuffer){
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	    }
	}

	if (multiple_windows) {
	    /* unattach context for other threads to use */
	    glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
    }

    return(0);
}


/*
 *			O G L _ G E T V I E W
 */
HIDDEN int
ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
    if(CJDEBUG) printf("entering ogl_getview\n");

    *xcenter = ifp->if_xcenter;
    *ycenter = ifp->if_ycenter;
    *xzoom = ifp->if_xzoom;
    *yzoom = ifp->if_yzoom;

    return(0);
}


/*read count pixels into pixelp starting at x,y*/
HIDDEN int
ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count)
{
    register short		scan_count;	/* # pix on this scanline */
    register unsigned char	*cp;
    int			ret;
    register unsigned int	n;
    register struct ogl_pixel	*oglp;

    if(CJDEBUG) printf("entering ogl_read\n");

    if( x < 0 || x >= ifp->if_width ||
	y < 0 || y >= ifp->if_height)
	return(-1);

    ret = 0;
    cp = (unsigned char *)(pixelp);

    while( count )  {
	if( y >= ifp->if_height )
	    break;

	if ( count >= ifp->if_width-x )
	    scan_count = ifp->if_width-x;
	else
	    scan_count = count;

	oglp = (struct ogl_pixel *)&ifp->if_mem[
						(y*SGI(ifp)->mi_memwidth+x)*sizeof(struct ogl_pixel) ];

	n = scan_count;
	while( n )  {
	    cp[RED] = oglp->red;
	    cp[GRN] = oglp->green;
	    cp[BLU] = oglp->blue;
	    oglp++;
	    cp += 3;
	    n--;
	}
	ret += scan_count;
	count -= scan_count;
	x = 0;
	/* Advance upwards */
	if( ++y >= ifp->if_height )
	    break;
    }
    return(ret);
}


/*write count pixels from pixelp starting at xstart,ystart*/
HIDDEN int
ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count)
{
    register short		scan_count;	/* # pix on this scanline */
    register unsigned char	*cp;
    int			ret;
    int			ybase;
    register int		pix_count;	/* # pixels to send */
    register int		x;
    register int		y;

    if(CJDEBUG) printf("entering ogl_write\n");

    /* fast exit cases */
    if( (pix_count = count) == 0 )
	return 0;	/* OK, no pixels transferred */
    if( pix_count < 0 )
	return -1;	/* ERROR */

    x = xstart;
    ybase = y = ystart;

    if( x < 0 || x >= ifp->if_width ||
	y < 0 || y >= ifp->if_height)
	return(-1);

    ret = 0;
    cp = (unsigned char *)(pixelp);

    while( pix_count )  {
	register unsigned int n;
	register struct ogl_pixel	*oglp;

	if( y >= ifp->if_height )
	    break;

	if ( pix_count >= ifp->if_width-x )
	    scan_count = ifp->if_width-x;
	else
	    scan_count = pix_count;

	oglp = (struct ogl_pixel *)&ifp->if_mem[
						(y*SGI(ifp)->mi_memwidth+x)*sizeof(struct ogl_pixel) ];

	n = scan_count;
	if( (n & 3) != 0 )  {
	    /* This code uses 60% of all CPU time */
	    while( n )  {
		/* alpha channel is always zero */
		oglp->red   = cp[RED];
		oglp->green = cp[GRN];
		oglp->blue  = cp[BLU];
		oglp++;
		cp += 3;
		n--;
	    }
	} else {
	    while( n )  {
		/* alpha channel is always zero */
		oglp[0].red   = cp[RED+0*3];
		oglp[0].green = cp[GRN+0*3];
		oglp[0].blue  = cp[BLU+0*3];
		oglp[1].red   = cp[RED+1*3];
		oglp[1].green = cp[GRN+1*3];
		oglp[1].blue  = cp[BLU+1*3];
		oglp[2].red   = cp[RED+2*3];
		oglp[2].green = cp[GRN+2*3];
		oglp[2].blue  = cp[BLU+2*3];
		oglp[3].red   = cp[RED+3*3];
		oglp[3].green = cp[GRN+3*3];
		oglp[3].blue  = cp[BLU+3*3];
		oglp += 4;
		cp += 3*4;
		n -= 4;
	    }
	}
	ret += scan_count;
	pix_count -= scan_count;
	x = 0;
	if( ++y >= ifp->if_height )
	    break;
    }

    if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
	return ret;

    if (multiple_windows) {
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
	    fb_log("Warning, ogl_write: glXMakeCurrent unsuccessful.\n");
	}
    }

    if(!OGL(ifp)->use_ext_ctrl){
	if( xstart + count <= ifp->if_width  )  {
	    /* "Fast path" case for writes of less than one scanline.
	     * The assumption is that there will be a lot of short
	     * writes, and it's best just to ignore the backbuffer
	     */
	    if ( SGI(ifp)->mi_doublebuffer ) {
		/* "turn off" doublebuffering*/
		SGI(ifp)->mi_doublebuffer = 0;
		glDrawBuffer(GL_FRONT);
	    }
	    ogl_xmit_scanlines( ifp, ybase, 1, xstart, count );
	    if (OGL(ifp)->copy_flag){
		/* repaint one scanline from backbuffer */
		backbuffer_to_screen(ifp,ybase);
	    }
	} else {
	    /* Normal case -- multi-pixel write */
	    if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	    }
	    else { /* just write rectangle */
		ogl_xmit_scanlines( ifp, ybase, y-ybase, 0, ifp->if_width );
		if (OGL(ifp)->copy_flag){
		    backbuffer_to_screen(ifp,-1);
		}
	    }
	}

	if (multiple_windows) {
	    /* unattach context for other threads to use */
	    glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
    }

    return(ret);

}

/*
 *			O G L _ W R I T E R E C T
 *
 *  The task of this routine is to reformat the pixels into
 *  SGI internal form, and then arrange to have them sent to
 *  the screen separately.
 */
HIDDEN int
ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
    register int		x;
    register int		y;
    register unsigned char	*cp;
    register struct ogl_pixel	*oglp;

    if(CJDEBUG) printf("entering ogl_writerect\n");


    if( width <= 0 || height <= 0 )
	return(0);  /* do nothing */
    if( xmin < 0 || xmin+width > ifp->if_width ||
	ymin < 0 || ymin+height > ifp->if_height )
	return(-1); /* no can do */

    cp = (unsigned char *)(pp);
    for( y = ymin; y < ymin+height; y++ )  {
	oglp = (struct ogl_pixel *)&ifp->if_mem[
						(y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct ogl_pixel) ];
	for( x = xmin; x < xmin+width; x++ )  {
	    /* alpha channel is always zero */
	    oglp->red   = cp[RED];
	    oglp->green = cp[GRN];
	    oglp->blue  = cp[BLU];
	    oglp++;
	    cp += 3;
	}
    }

    if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
	return width*height;

    if(!OGL(ifp)->use_ext_ctrl){
	if (multiple_windows) {
	    if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_writerect: glXMakeCurrent unsuccessful.\n");
	    }
	}

	if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
	    ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	    glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	}
	else { /* just write rectangle*/
	    ogl_xmit_scanlines( ifp, ymin, height, xmin, width );
	    if (OGL(ifp)->copy_flag){
		backbuffer_to_screen(ifp,-1);
	    }
	}

	if (multiple_windows) {
	    /* unattach context for other threads to use */
	    glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
    }

    return(width*height);
}


/*
 *			O G L _ B W W R I T E R E C T
 *
 *  The task of this routine is to reformat the pixels into
 *  SGI internal form, and then arrange to have them sent to
 *  the screen separately.
 */
HIDDEN int
ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
    register int		x;
    register int		y;
    register unsigned char	*cp;
    register struct ogl_pixel	*oglp;

    if(CJDEBUG) printf("entering ogl_bwwriterect\n");


    if( width <= 0 || height <= 0 )
	return(0);  /* do nothing */
    if( xmin < 0 || xmin+width > ifp->if_width ||
	ymin < 0 || ymin+height > ifp->if_height )
	return(-1); /* no can do */

    cp = (unsigned char *)(pp);
    for( y = ymin; y < ymin+height; y++ )  {
	oglp = (struct ogl_pixel *)&ifp->if_mem[
						(y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct ogl_pixel) ];
	for( x = xmin; x < xmin+width; x++ )  {
	    register int	val;
	    /* alpha channel is always zero */
	    oglp->red   = (val = *cp++);
	    oglp->green = val;
	    oglp->blue  = val;
	    oglp++;
	}
    }

    if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
	return width*height;

    if(!OGL(ifp)->use_ext_ctrl){
	if (multiple_windows) {
	    if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_writerect: glXMakeCurrent unsuccessful.\n");
	    }
	}

	if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
	    ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	    glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	}
	else { /* just write rectangle*/
	    ogl_xmit_scanlines( ifp, ymin, height, xmin, width );
	    if (OGL(ifp)->copy_flag){
		backbuffer_to_screen(ifp,-1);
	    }
	}

	if (multiple_windows) {
	    /* unattach context for other threads to use */
	    glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
    }

    return(width*height);
}


HIDDEN int
ogl_rmap(register FBIO *ifp, register ColorMap *cmp)
{
    register int i;

    if(CJDEBUG) printf("entering ogl_rmap\n");

    /* Just parrot back the stored colormap */
    for( i = 0; i < 256; i++)  {
	cmp->cm_red[i]   = CMR(ifp)[i]<<8;
	cmp->cm_green[i] = CMG(ifp)[i]<<8;
	cmp->cm_blue[i]  = CMB(ifp)[i]<<8;
    }
    return(0);
}

/*
 *			I S _ L I N E A R _ C M A P
 *
 *  Check for a color map being linear in R, G, and B.
 *  Returns 1 for linear map, 0 for non-linear map
 *  (ie, non-identity map).
 */
HIDDEN int
is_linear_cmap(register FBIO *ifp)
{
    register int i;

    for( i=0; i<256; i++ )  {
	if( CMR(ifp)[i] != i )  return(0);
	if( CMG(ifp)[i] != i )  return(0);
	if( CMB(ifp)[i] != i )  return(0);
    }
    return(1);
}

/*
 *			O G L _ C M I N I T
 */
HIDDEN void
ogl_cminit(register FBIO *ifp)
{
    register int	i;

    for( i = 0; i < 256; i++)  {
	CMR(ifp)[i] = i;
	CMG(ifp)[i] = i;
	CMB(ifp)[i] = i;
    }
}

/*
 *			 O G L _ W M A P
 */
HIDDEN int
ogl_wmap(register FBIO *ifp, register const ColorMap *cmp)
{
    register int	i;
    int		prev;	/* !0 = previous cmap was non-linear */

    if(CJDEBUG) printf("entering ogl_wmap\n");

    prev = SGI(ifp)->mi_cmap_flag;
    if ( cmp == COLORMAP_NULL)  {
	ogl_cminit( ifp );
    } else {
	for(i = 0; i < 256; i++)  {
	    CMR(ifp)[i] = cmp-> cm_red[i]>>8;
	    CMG(ifp)[i] = cmp-> cm_green[i]>>8;
	    CMB(ifp)[i] = cmp-> cm_blue[i]>>8;
	}
    }
    SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);


    if(!OGL(ifp)->use_ext_ctrl){
	if( OGL(ifp)->soft_cmap_flag )  {
	    /* if current and previous maps are linear, return */
	    if( SGI(ifp)->mi_cmap_flag == 0 && prev == 0 )  return(0);

	    /* Software color mapping, trigger a repaint */

	    if (multiple_windows) {
		if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		    fb_log("Warning, ogl_wmap: glXMakeCurrent unsuccessful.\n");
		}
	    }

	    ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	    if(SGI(ifp)->mi_doublebuffer){
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	    } else if (OGL(ifp)->copy_flag) {
		backbuffer_to_screen(ifp,-1);
	    }
	    if (multiple_windows) {
		/* unattach context for other threads to use, also flushes */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	    }
	} else {
	    /* Send color map to hardware */
	    /* This code has yet to be tested */

	    for (i = 0; i < 256; i++) {
		color_cell[i].pixel = i;
		color_cell[i].red = CMR(ifp)[i];
		color_cell[i].green = CMG(ifp)[i];
		color_cell[i].blue = CMB(ifp)[i];
		color_cell[i].flags = DoRed | DoGreen | DoBlue;
	    }
	    XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell, 256);
	}
    }

    return(0);
}

/*
 *			O G L _ H E L P
 */
HIDDEN int
ogl_help(FBIO *ifp)
{
    struct	modeflags *mfp;
    XVisualInfo *visual = OGL(ifp)->vip;

    fb_log( "Description: %s\n", ifp->if_type );
    fb_log( "Device: %s\n", ifp->if_name );
    fb_log( "Max width height: %d %d\n",
	    ifp->if_max_width,
	    ifp->if_max_height );
    fb_log( "Default width height: %d %d\n",
	    ifp->if_width,
	    ifp->if_height );
    fb_log( "Usage: /dev/ogl[option letters]\n" );
    for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
	fb_log( "   %c   %s\n", mfp->c, mfp->help );
    }

    fb_log( "\nCurrent internal state:\n");
    fb_log( "	mi_doublebuffer=%d\n", SGI(ifp)->mi_doublebuffer );
    fb_log( "	mi_cmap_flag=%d\n", SGI(ifp)->mi_cmap_flag );
    fb_log( "	ogl_nwindows=%d\n", ogl_nwindows );
    fb_log( "	multiple_windows=%d\n", multiple_windows );

    fb_log("X11 Visual:\n");

    switch(visual->class) {
	case DirectColor:
	    fb_log("\tDirectColor: Alterable RGB maps, pixel RGB subfield indicies\n");
	    fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
		   visual->green_mask, visual->blue_mask);
	    break;
	case TrueColor:
	    fb_log("\tTrueColor: Fixed RGB maps, pixel RGB subfield indicies\n");
	    fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
		   visual->green_mask, visual->blue_mask);
	    break;
	case PseudoColor:
	    fb_log("\tPseudoColor: Alterable RGB maps, single index\n");
	    break;
	case StaticColor:
	    fb_log("\tStaticColor: Fixed RGB maps, single index\n");
	    break;
	case GrayScale:
	    fb_log("\tGrayScale: Alterable map (R=G=B), single index\n");
	    break;
	case StaticGray:
	    fb_log("\tStaticGray: Fixed map (R=G=B), single index\n");
	    break;
	default:
	    fb_log("\tUnknown visual class %d\n",
		   visual->class);
	    break;
    }
    fb_log("\tColormap Size: %d\n", visual->colormap_size);
    fb_log("\tBits per RGB: %d\n", visual->bits_per_rgb);
    fb_log("\tscreen: %d\n", visual->screen);
    fb_log("\tdepth (total bits per pixel): %d\n", visual->depth);
    if( visual->depth < 24 )
	fb_log("\tWARNING: unable to obtain full 24-bits of color, image will be quantized.\n");

    return 0;
}


HIDDEN int
ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
    return 0;
}


HIDDEN int
ogl_cursor(FBIO *ifp, int mode, int x, int y)
{
    if(mode){
	register int xx, xy;
	register int delta;

	/* If we don't have a cursor, create it */
	if (!OGL(ifp)->cursor) {
	    XSetWindowAttributes xswa;
	    XColor rgb_db_def;
	    XColor bg, bd;

	    XAllocNamedColor(OGL(ifp)->dispp, OGL(ifp)->xcmap, "black",
			     &rgb_db_def, &bg);
	    XAllocNamedColor(OGL(ifp)->dispp, OGL(ifp)->xcmap, "white",
			     &rgb_db_def, &bd);
	    xswa.background_pixel = bg.pixel;
	    xswa.border_pixel = bd.pixel;
	    xswa.colormap = OGL(ifp)->xcmap;
	    xswa.save_under = True;

	    OGL(ifp)->cursor = XCreateWindow(OGL(ifp)->dispp, OGL(ifp)->wind,
					     0, 0, 4, 4, 2, OGL(ifp)->vip->depth, InputOutput,
					     OGL(ifp)->vip->visual, CWBackPixel | CWBorderPixel |
					     CWSaveUnder | CWColormap, &xswa);
	}

	delta = ifp->if_width/ifp->if_xzoom/2;
	xx = x - (ifp->if_xcenter - delta);
	xx *= ifp->if_xzoom;
	xx += ifp->if_xzoom/2;  /* center cursor */

	delta = ifp->if_height/ifp->if_yzoom/2;
	xy = y - (ifp->if_ycenter - delta);
	xy *= ifp->if_yzoom;
	xy += ifp->if_yzoom/2;  /* center cursor */
	xy = OGL(ifp)->win_height - xy;

	/* Move cursor into place; make it visible if it isn't */
	XMoveWindow(OGL(ifp)->dispp, OGL(ifp)->cursor, xx - 4, xy - 4);

	/* if cursor window is currently not mapped, map it */
	if (!ifp->if_cursmode)
	    XMapRaised(OGL(ifp)->dispp, OGL(ifp)->cursor);
    } else {
	/* If we have a cursor and it's mapped, unmap it */
	if (OGL(ifp)->cursor && ifp->if_cursmode)
	    XUnmapWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);
    }

    /* Without this flush, cursor movement is sluggish */
    XFlush(OGL(ifp)->dispp);

    /* Update position of cursor */
    ifp->if_cursmode = mode;
    ifp->if_xcurs = x;
    ifp->if_ycurs = y;

    return(0);
}


HIDDEN int
ogl_flush(FBIO *ifp)
{
    if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )  {
	if (multiple_windows) {
	    if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_flush: glXMakeCurrent unsuccessful.\n");
	    }
	}
	/* Send entire in-memory buffer to the screen, all at once */
	ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	if ( SGI(ifp)->mi_doublebuffer) {
	    glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	} else {
	    if (OGL(ifp)->copy_flag){
		backbuffer_to_screen(ifp,-1);
	    }
	}
    }
    XFlush(OGL(ifp)->dispp);
    glFlush();
    return(0);
}

#if 0
HIDDEN int
fb_cnull(ifp)
     FBIO *ifp;
{
    return(0);
}
#endif

/*
 * O G L _ C L I P P E R ( )
 *
 * Given:- the size of the viewport in pixels (vp_width, vp_height)
 *	 - the size of the framebuffer image (if_width, if_height)
 *	 - the current view center (if_xcenter, if_ycenter)
 * 	 - the current zoom (if_xzoom, if_yzoom)
 * Calculate:
 *	 - the position of the viewport in image space
 *		(xscrmin,xscrmax,yscrmin,yscrmax)
 *	 - the portion of the image which is visible in the viewport
 *		(xpixmin,xpixmax,ypixmin,ypixmax)
 */
void
ogl_clipper(register FBIO *ifp)
{
    register struct ogl_clip *clp;
    register int	i;
    double pixels;

    clp = &(OGL(ifp)->clip);

    i = OGL(ifp)->vp_width/(2*ifp->if_xzoom);
    clp->xscrmin = ifp->if_xcenter - i;
    i = OGL(ifp)->vp_width/ifp->if_xzoom;
    clp->xscrmax = clp->xscrmin + i;
    pixels = (double) i;
    clp->oleft = ((double) clp->xscrmin) - 0.25*pixels/((double) OGL(ifp)->vp_width);
    clp->oright = clp->oleft + pixels;

    i = OGL(ifp)->vp_height/(2*ifp->if_yzoom);
    clp->yscrmin = ifp->if_ycenter - i;
    i = OGL(ifp)->vp_height/ifp->if_yzoom;
    clp->yscrmax = clp->yscrmin + i;
    pixels = (double) i;
    clp->obottom = ((double) clp->yscrmin) - 0.25*pixels/((double) OGL(ifp)->vp_height);
    clp->otop = clp->obottom + pixels;

    clp->xpixmin = clp->xscrmin;
    clp->xpixmax = clp->xscrmax;
    clp->ypixmin = clp->yscrmin;
    clp->ypixmax = clp->yscrmax;

    if( clp->xpixmin < 0 )  {
	clp->xpixmin = 0;
    }

    if( clp->ypixmin < 0 )  {
	clp->ypixmin = 0;
    }

    /* In copy mode, the backbuffer copy image is limited
     * to the viewport size; use that for clipping.
     * Otherwise, use size of framebuffer memory segment
     */
    if (OGL(ifp)->copy_flag) {
	if( clp->xpixmax > OGL(ifp)->vp_width-1 )  {
	    clp->xpixmax = OGL(ifp)->vp_width-1;
	}
	if( clp->ypixmax > OGL(ifp)->vp_height-1 )  {
	    clp->ypixmax = OGL(ifp)->vp_height-1;
	}
    } else {
	if( clp->xpixmax > ifp->if_width-1 )  {
	    clp->xpixmax = ifp->if_width-1;
	}
	if( clp->ypixmax > ifp->if_height-1 )  {
	    clp->ypixmax = ifp->if_height-1;
	}
    }

}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *	Call back routines and so on				   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 */

HIDDEN void
ogl_do_event(FBIO *ifp)
{
    XEvent event;

    while (XCheckWindowEvent(OGL(ifp)->dispp, OGL(ifp)->wind,
			     OGL(ifp)->event_mask, &event)) {
	switch (event.type) {
	    case Expose:
		if(!OGL(ifp)->use_ext_ctrl)
		    expose_callback(ifp, &event);
		break;
	    case ButtonPress:
		{
		    int button = (int) event.xbutton.button;
		    if (button == Button1) {
			/* Check for single button mouse remap.
			 * ctrl-1 => 2
			 * meta-1 => 3
			 */
			if (event.xbutton.state & ControlMask)
			    button = Button2;
			else if (event.xbutton.state & Mod1Mask)
			    button = Button3;
		    }

		    switch(button){
			case Button1:
			    break;
			case Button2:
			    {
				int	x, y;
				int	ix, iy;
				unsigned char	cp[3] = {0};

				x = event.xbutton.x;
				y = event.xbutton.y;

				if(x < 0 || y < 0){
				    fb_log("No RGB (outside image viewport)\n");
				    break;
				}

				fb_log("At image (%d, %d), real RGB=(%3d %3d %3d) UNIMPLEMENTED\n",
				       x, y, cp[RED], cp[GRN], cp[BLU]);

				break;
			    }
			case Button3:
			    OGL(ifp)->alive = 0;
			    break;
			default:
			    fb_log("unhandled mouse event\n");
			    break;
		    }
		    break;
		}
	    case ConfigureNotify:
		{
		    XConfigureEvent *conf = (XConfigureEvent *)&event;

		    if(conf->width == OGL(ifp)->win_width &&
		       conf->height == OGL(ifp)->win_height)
			return;

		    ogl_configureWindow(ifp, conf->width, conf->height);
		}
	    default:
		break;
	}
    }
}

HIDDEN void
expose_callback(FBIO *ifp, XEvent *eventPtr)
{
    XWindowAttributes xwa;
    struct ogl_clip *clp;

    if( CJDEBUG ) fb_log("entering expose_callback()\n");


    if( multiple_windows || OGL(ifp)->firstTime ) {
	if( glXMakeCurrent(OGL(ifp)->dispp, OGL(ifp)->wind,
			   OGL(ifp)->glxc) == False) {
	    fb_log("Warning, libfb/expose_callback: glXMakeCurrent unsuccessful.\n");
	}
    }

    if( OGL(ifp)->firstTime ) {
	OGL(ifp)->firstTime = 0;

	/* just in case the configuration is double buffered but
	 * we want to pretend it's not
	 */

	if( !SGI(ifp)->mi_doublebuffer ) {
	    glDrawBuffer(GL_FRONT);
	}

	if( (ifp->if_mode & MODE_4MASK) == MODE_4NODITH ) {
	    glDisable(GL_DITHER);
	}

	/* set copy mode if possible and requested */
	if( SGI(ifp)->mi_doublebuffer &&
	    ((ifp->if_mode & MODE_11MASK)==MODE_11COPY) ) {
	    /* Copy mode only works if there are two
	     * buffers to use. It conflicts with
	     * double buffering
	     */
	    OGL(ifp)->copy_flag = 1;
	    SGI(ifp)->mi_doublebuffer = 0;
	    OGL(ifp)->front_flag = 1;
	    glDrawBuffer(GL_FRONT);
	} else {
	    OGL(ifp)->copy_flag = 0;
	}

	XGetWindowAttributes(OGL(ifp)->dispp, OGL(ifp)->wind, &xwa);
	OGL(ifp)->win_width = xwa.width;
	OGL(ifp)->win_height = xwa.height;

	/* clear entire window */
	glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);
	glClearColor(0,0,0,0);
	glClear(GL_COLOR_BUFFER_BIT);

	/* Set normal viewport size to minimum of actual window
	 * size and requested framebuffer size
	 */
	OGL(ifp)->vp_width = (OGL(ifp)->win_width < ifp->if_width) ?
	    OGL(ifp)->win_width : ifp->if_width;
	OGL(ifp)->vp_height = (OGL(ifp)->win_height < ifp->if_height) ?
	    OGL(ifp)->win_height : ifp->if_height;
	ifp->if_xcenter = OGL(ifp)->vp_width/2;
	ifp->if_ycenter = OGL(ifp)->vp_height/2;

	/* center viewport in window */
	SGI(ifp)->mi_xoff=(OGL(ifp)->win_width-OGL(ifp)->vp_width)/2;
	SGI(ifp)->mi_yoff=(OGL(ifp)->win_height-OGL(ifp)->vp_height)/2;
	glViewport(SGI(ifp)->mi_xoff,
		   SGI(ifp)->mi_yoff,
		   OGL(ifp)->vp_width,
		   OGL(ifp)->vp_height);
	/* initialize clipping planes and zoom */
	ogl_clipper(ifp);
	clp = &(OGL(ifp)->clip);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop,
		 -1.0,1.0);
	glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
    } else if( (OGL(ifp)->win_width > ifp->if_width) ||
	       (OGL(ifp)->win_height > ifp->if_height) ) {
	/* clear whole buffer if window larger than framebuffer */
	if( OGL(ifp)->copy_flag && !OGL(ifp)->front_flag ) {
	    glDrawBuffer(GL_FRONT);
	    glViewport(0, 0, OGL(ifp)->win_width,
		       OGL(ifp)->win_height);
	    glClearColor(0,0,0,0);
	    glClear(GL_COLOR_BUFFER_BIT);
	    glDrawBuffer(GL_BACK);
	} else {
	    glViewport(0, 0, OGL(ifp)->win_width,
		       OGL(ifp)->win_height);
	    glClearColor(0,0,0,0);
	    glClear(GL_COLOR_BUFFER_BIT);
	}
	/* center viewport */
	glViewport(SGI(ifp)->mi_xoff,
		   SGI(ifp)->mi_yoff,
		   OGL(ifp)->vp_width,
		   OGL(ifp)->vp_height);
    }

    /* repaint entire image */
    ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
    if( SGI(ifp)->mi_doublebuffer ) {
	glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
    } else if( OGL(ifp)->copy_flag ) {
	backbuffer_to_screen(ifp,-1);
    }

    if( CJDEBUG ) {
	int dbb,db,view[4],getster,getaux;
	glGetIntegerv(GL_VIEWPORT, view);
	glGetIntegerv(GL_DOUBLEBUFFER,&dbb);
	glGetIntegerv(GL_DRAW_BUFFER,&db);
	fb_log("Viewport: x %d y %d width %d height %d\n",view[0],
	       view[1],view[2],view[3]);
	fb_log("expose: double buffered: %d, draw buffer %d\n",dbb,db);
	fb_log("front %d\tback%d\n",GL_FRONT,GL_BACK);
	glGetIntegerv(GL_STEREO,&getster);
	glGetIntegerv(GL_AUX_BUFFERS,&getaux);
	fb_log("double %d, stereo %d, aux %d\n",dbb,getster,getaux);
    }

    if( multiple_windows ) {
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
    }
#if 0
    XFlush(OGL(ifp)->dispp);
    glFlush();
#endif
}

void
ogl_configureWindow(FBIO *ifp, int width, int height)
{
    if(width == OGL(ifp)->win_width &&
       height == OGL(ifp)->win_height)
	return;

    ifp->if_width = ifp->if_max_width = width;
    ifp->if_height = ifp->if_max_height = height;

    OGL(ifp)->win_width = OGL(ifp)->vp_width = width;
    OGL(ifp)->win_height = OGL(ifp)->vp_height = height;

    ifp->if_zoomflag = 0;
    ifp->if_xzoom = 1;
    ifp->if_yzoom = 1;
    ifp->if_xcenter = width/2;
    ifp->if_ycenter = height/2;

    ogl_getmem(ifp);
    ogl_clipper(ifp);
}

#if 0
/* reorder_cursor - reverses the order of the scanlines.
 * scanlines are byte aligned, the specified cursor is xbits
 * by ybits bits in size.
 *
 */
HIDDEN void
reorder_cursor(char *dst,char *src, int xbits, int ybits)
{
    int xbytes;
    int i,j,k;

    if( (xbytes = xbits /8) * 8 != xbits)
	xbytes++;

    for (j=0, k=(ybits-1)*xbytes; j < ybits*xbytes; j+=xbytes, k-=xbytes){
	for (i=0; i < xbytes; i++){
	    dst[j+i] = src[k+i];
	}
    }

}
#endif

/* BACKBUFFER_TO_SCREEN - copy pixels from copy on the backbuffer
 * to the front buffer. Do one scanline specified by one_y, or whole
 * screen if one_y equals -1.
 */
HIDDEN void
backbuffer_to_screen(register FBIO *ifp, int one_y)
{
    struct ogl_clip *clp;

    if (!(OGL(ifp)->front_flag)){
	OGL(ifp)->front_flag = 1;
	glDrawBuffer(GL_FRONT);
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
    }

    clp = &(OGL(ifp)->clip);

    if (one_y > clp->ypixmax) {
	return;
    } else if (one_y < 0) { /* do whole visible screen */

	/* Blank out area left of image */
	glColor3b( 0, 0, 0 );
	if( clp->xscrmin < 0 )  glRecti(clp->xscrmin - CLIP_XTRA,
					clp->yscrmin - CLIP_XTRA,
					CLIP_XTRA,
					clp->yscrmax + CLIP_XTRA);

	/* Blank out area below image */
	if( clp->yscrmin < 0 )  glRecti(clp->xscrmin - CLIP_XTRA,
					clp->yscrmin - CLIP_XTRA,
					clp->xscrmax + CLIP_XTRA,
					CLIP_XTRA);

	/* We are in copy mode, so we use vp_width rather
	 * than if_width
	 */
	/* Blank out area right of image */
	if( clp->xscrmax >= OGL(ifp)->vp_width )  glRecti(ifp->if_width - CLIP_XTRA,
							  clp->yscrmin - CLIP_XTRA,
							  clp->xscrmax + CLIP_XTRA,
							  clp->yscrmax + CLIP_XTRA);

	/* Blank out area above image */
	if( clp->yscrmax >= OGL(ifp)->vp_height )  glRecti(clp->xscrmin - CLIP_XTRA,
							   OGL(ifp)->vp_height - CLIP_XTRA,
							   clp->xscrmax + CLIP_XTRA,
							   clp->yscrmax + CLIP_XTRA);

	/* copy image from backbuffer */
	glRasterPos2i(clp->xpixmin,clp->ypixmin);
	glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
		     SGI(ifp)->mi_yoff + clp->ypixmin,
		     clp->xpixmax - clp->xpixmin +1,
		     clp->ypixmax - clp->ypixmin +1,
		     GL_COLOR);


    } else if (one_y < clp->ypixmin) {
	return;
    } else { /* draw one scanline */
	glRasterPos2i(clp->xpixmin,one_y);
	glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
		     SGI(ifp)->mi_yoff + one_y,
		     clp->xpixmax - clp->xpixmin +1,
		     1,
		     GL_COLOR);
    }
}

/* 		O G L _ C H O O S E _ V I S U A L
 *
 * Select an appropriate visual, and set flags.
 *
 * The user requires support for:
 *    	-OpenGL rendering in RGBA mode
 *
 * The user may desire support for:
 *	-a single-buffered OpenGL context
 *	-a double-buffered OpenGL context
 *	-hardware colormapping (DirectColor)
 *
 * We first try to satisfy all requirements and desires. If that fails,
 * we remove the desires one at a time until we succeed or until only
 * requirements are left. If at any stage more than one visual meets the
 * current criteria, the visual with the greatest depth is chosen.
 *
 * The following flags are set:
 * 	SGI(ifp)->mi_doublebuffer
 *	OGL(ifp)->soft_cmap_flag
 *
 * Return NULL on failure.
 */
HIDDEN XVisualInfo *
fb_ogl_choose_visual(FBIO *ifp)
{

    XVisualInfo *vip, *vibase, *maxvip, template;
#define NGOOD 200
    int good[NGOOD];
    int num, i, j;
    int m_hard_cmap, m_sing_buf, m_doub_buf;
    int use, rgba, dbfr;

    m_hard_cmap = ((ifp->if_mode & MODE_7MASK)==MODE_7NORMAL);
    m_sing_buf  = ((ifp->if_mode & MODE_9MASK)==MODE_9SINGLEBUF);
    m_doub_buf =  !m_sing_buf;

    memset((void *)&template, 0, sizeof(XVisualInfo));

    /* get a list of all visuals on this display */
    vibase = XGetVisualInfo(OGL(ifp)->dispp, 0, &template, &num);
    while (1) {

	/* search for all visuals matching current criteria */
	for (i=0, j=0, vip=vibase; i<num; i++, vip++){
	    /* requirements */
	    glXGetConfig(OGL(ifp)->dispp,vip,GLX_USE_GL,&use);
	    if( !use)
		continue;
	    glXGetConfig(OGL(ifp)->dispp,vip,GLX_RGBA,&rgba);
	    if (!rgba)
		continue;
	    /* desires */
	    /* X_CreateColormap needs a DirectColor visual */
	    /* There should be some way of handling this with TrueColor,
	     * for example:
	     visual id:    0x50
	     class:    TrueColor
	     depth:    24 planes
	     available colormap entries:    256 per subfield
	     red, green, blue masks:    0xff0000, 0xff00, 0xff
	     significant bits in color specification:    8 bits
	    */
	    if ( (m_hard_cmap) && (vip->class!=DirectColor))
		continue;
	    if ( (m_hard_cmap) && (vip->colormap_size<256))
		continue;
	    glXGetConfig(OGL(ifp)->dispp,vip,GLX_DOUBLEBUFFER,&dbfr);
	    if ( (m_doub_buf) && (!dbfr) )
		continue;
	    if ( (m_sing_buf) && (dbfr) )
		continue;

	    /* this visual meets criteria */
	    if( j >= NGOOD-1 )  {
		fb_log("fb_ogl_open:  More than %d candidate visuals!\n", NGOOD);
		break;
	    }
	    good[j++] = i;
	}

	/* from list of acceptable visuals,
	 * choose the visual with the greatest depth */
	if (j>=1){
	    maxvip = vibase + good[0];
	    for (i=1; i<j; i++) {
		vip = vibase + good[i];
		if (vip->depth >= maxvip->depth) {
		    maxvip = vip;
		}
	    }
	    /* set flags and return choice */
	    OGL(ifp)->soft_cmap_flag = !m_hard_cmap;
	    SGI(ifp)->mi_doublebuffer = m_doub_buf;
	    return (maxvip);
	}

	/* if no success at this point,
	 * relax one of the criteria and try again.
	 */
	if (m_hard_cmap) {
	    /* relax hardware colormap requirement */
	    m_hard_cmap = 0;
	    fb_log("fb_ogl_open: hardware colormapping not available. Using software colormap.\n");
	} else if (m_sing_buf) {
	    /* relax single buffering requirement.
	     * no need for any warning - we'll just use
	     * the front buffer
	     */
	    m_sing_buf = 0;
	} else if (m_doub_buf) {
	    /* relax double buffering requirement. */
	    m_doub_buf = 0;
	    fb_log("fb_ogl_open: double buffering not available. Using single buffer.\n");
	} else {
	    /* nothing else to relax */
	    return(NULL);
	}

    }

}

int
ogl_refresh(FBIO *ifp, int x, int y, int w, int h)
{
    int mm;
    struct ogl_clip *clp;

    if(w < 0){
	w = -w;
	x -= w;
    }

    if(h < 0){
	h = -h;
	y -= h;
    }

#if 0
    if(glIsEnabled(GL_DEPTH_TEST)){
	glDisable(GL_DEPTH_TEST);
	dflag = 1;
    }
#endif

    glGetIntegerv(GL_MATRIX_MODE, &mm);
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();

#if 0
    glOrtho(0.0, OGL(ifp)->win_width, 0.0, OGL(ifp)->win_height, -1.0, 1.0);
#else
    ogl_clipper(ifp);
    clp = &(OGL(ifp)->clip);
    glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop, -1.0, 1.0);
    glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
#endif
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();
#if 0
    glTranslatef(0.0, 0.0, -1.0);
#endif
    glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);
    ogl_xmit_scanlines(ifp, y, h, x, w);
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
    glMatrixMode(mm);

#if 0
    if(dflag)
	glEnable(GL_DEPTH_TEST);
#endif

    glFlush();
    return 0;
}

#else

/* quell empty-compilation unit warnings */
static const int unused = 0;

#endif /* IF_OGL */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.42
log
@quell empty compilation unit warning
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.41 2007/10/26 21:51:26 brlcad Exp $ (ARL)";
d2516 1
a2516 1
    bzero((void *)&template, sizeof(XVisualInfo));
@


14.41
log
@yet another surge of level 4 flawfinder string length checks. somewhere around 30-40% done.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.40 2007/09/26 21:09:29 brlcad Exp $ (ARL)";
d2661 5
@


14.40
log
@BAM! .. lingering windows is now the default.  it only took hundreds of complaints and 20 years of development.  this change makes it the default for most of the existing active framebuffer interface types, also adding a \\t\ option to complement the existing \\l\ option to allow folks to obtain the previous behavior if needed.  all this mode code really should be consolidated and made consistent, but that is a chore for another day.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.39 2007/09/26 19:05:22 brlcad Exp $ (ARL)";
d847 1
a847 1
    (void)sprintf( title, "BRL-CAD /dev/ogl %s, %s",
@


14.39
log
@don't assume that stdout isn't being used, bu_log will likely someday be changed to log to out instead of err
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.38 2007/09/15 16:23:10 brlcad Exp $ (ARL)";
d347 3
a349 1
      "Lingering window - else transient" },
a700 1
     *  The default mode is zero.
d702 1
a702 1
    mode = 0;
d711 2
a712 2
	if( strncmp(file, "/dev/ogl", 8) ) {
	    /* How did this happen?? */
d738 3
a740 2
	    if( !alpha )
		mode = atoi( modebuf );
@


14.38
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.37 2007/08/18 03:15:11 brlcad Exp $ (ARL)";
d1196 2
a1197 2
     *  network connections.  Standard error is used to print
     *  framebuffer debug messages, so it's kept around.
a1199 1
    fclose( stdout );
@


14.37
log
@remove the fblocal.h header file.  it was only used in three places (two files) and only contained one macro (wrapper to fb_log an error), so keep it simple until it's really needed.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.36 2007/08/11 05:24:41 brlcad Exp $ (ARL)";
d56 1
a56 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.37.2.1
log
@merge from head, make linger the default framebuffer action instead of transient for all windowing framebuffer interfaces.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.40 2007/09/26 21:09:29 brlcad Exp $ (ARL)";
d56 5
a60 1
#include <string.h>
d351 1
a351 3
      "Lingering window" },
    { 't',	MODE_2MASK, MODE_2TRANSIENT,
      "Transient window" },
d703 1
d705 1
a705 1
    mode = MODE_2LINGERING;
d714 2
a715 2
	if (strncmp(file, ifp->if_name, strlen(ifp->if_name))) {
	    /* How did this happen? */
d741 2
a742 3
	    if( !alpha ) {
		mode |= atoi( modebuf );
	    }
d1200 2
a1201 2
     *  network connections.  Standard error/out may be used to print
     *  framebuffer debug messages, so they're kept around.
d1204 1
@


14.36
log
@there is just one IF_ per interface -- if you don't want the ogl interface, then don't define IF_OGL .. this has nothing to do with IF_WGL
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.35 2007/08/03 22:14:59 erikgreenwald Exp $ (ARL)";
a87 1
#include "./fblocal.h"
@


14.35
log
@oops, "and", not "or"
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.34 2007/08/03 21:39:59 erikgreenwald Exp $ (ARL)";
d53 1
a53 2
/* Windows is handled by if_wgl.c */
#if defined(IF_OGL) && !defined(IF_WGL)
@


14.34
log
@Skip if windows, if_wgl.c is for that
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.33 2007/05/12 22:23:05 brlcad Exp $ (ARL)";
d54 1
a54 1
#if defined(IF_OGL) || !defined(IF_WGL)
@


14.33
log
@use new bu_process_id() function to get the pid now
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.32 2007/02/02 08:24:18 brlcad Exp $ (ARL)";
d53 2
a54 1
#ifdef IF_OGL
@


14.32
log
@rename ogl_open, ogl_close, and ogl_choose_visual to have an fb_ prefix to avoid namespace collisions with libdm.  this should probably be done more comprehensively, but gets past the linking error du jour.  declare funcs one per line while we're in here.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.31 2007/01/27 01:41:37 brlcad Exp $ (ARL)";
d791 1
a791 1
	SGI(ifp)->mi_parent = getpid();
d865 1
a865 1
    SGI(ifp)->mi_pid = getpid();
d1099 1
a1099 1
    SGI(ifp)->mi_pid = getpid();
@


14.31
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.30 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d110 1
a110 1
HIDDEN XVisualInfo *	ogl_choose_visual(FBIO *ifp);
d125 11
a135 11
HIDDEN int	ogl_open(FBIO *ifp, char *file, int width, int height),
    ogl_close(FBIO *ifp),
    ogl_clear(FBIO *ifp, unsigned char *pp),
    ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
    ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count),
    ogl_rmap(register FBIO *ifp, register ColorMap *cmp),
    ogl_wmap(register FBIO *ifp, register const ColorMap *cmp),
    ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
    ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
    ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
    ogl_cursor(FBIO *ifp, int mode, int x, int y),
d137 3
a139 3
    ogl_getcursor(),
    ogl_readrect(),
    fb_cnull(),
d141 6
a146 6
    ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
    ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
    ogl_poll(FBIO *ifp),
    ogl_flush(FBIO *ifp),
    ogl_free(FBIO *ifp),
    ogl_help(FBIO *ifp);
d152 2
a153 2
	ogl_open,		/* open device		*/
	ogl_close,		/* close device		*/
d688 1
a688 1
ogl_open(FBIO *ifp, char *file, int width, int height)
d760 1
a760 1
	fb_log("ogl_open:  sgiinfo malloc failed\n");
d764 1
a764 1
	fb_log("ogl_open:  oglinfo malloc failed\n");
d771 1
a771 1
	fb_log("Warning - ogl_open: Multiple windows opened. Use /dev/oglm for first window!");
d815 1
a815 1
	    fb_log("ogl_open:  linger-mode fork failure\n");
d874 1
a874 1
	fb_log("ogl_open: Failed to open display.  Check DISPLAY environment variable.\n");
d884 2
a885 2
    if( (OGL(ifp)->vip = ogl_choose_visual(ifp)) == NULL ) {
	fb_log("ogl_open: Couldn't find an appropriate visual.  Exiting.\n");
d1073 1
a1073 1
	fb_log("ogl_open:  sgiinfo malloc failed\n");
d1077 1
a1077 1
	fb_log("ogl_open:  oglinfo malloc failed\n");
d1145 1
a1145 1
		fb_log("ogl_close shmdt failed, errno=%d\n",
d1169 1
a1169 1
ogl_close(FBIO *ifp)
d1182 1
a1182 1
	printf("ogl_close: remaining open to linger awhile.\n");
d1233 1
a1233 1
		fb_log("ogl_close shmdt failed, errno=%d\n",
d2506 1
a2506 1
ogl_choose_visual(FBIO *ifp)
d2558 1
a2558 1
		fb_log("ogl_open:  More than %d candidate visuals!\n", NGOOD);
d2586 1
a2586 1
	    fb_log("ogl_open: hardware colormapping not available. Using software colormap.\n");
d2596 1
a2596 1
	    fb_log("ogl_open: double buffering not available. Using single buffer.\n");
@


14.30
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.29 2007/01/21 04:45:42 brlcad Exp $ (ARL)";
d967 1
a967 1
        printf("             valuemask = %08X,\n", valuemask), \
a1787 1

a2042 1

@


14.29
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.28 2007/01/20 14:36:52 brlcad Exp $ (ARL)";
@


14.28
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup if */
/*@@{*/
d24 1
d46 1
a46 1
/*@@}*/
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.27 2006/08/08 22:47:15 brlcad Exp $ (ARL)";
@


14.27
log
@avoid debug mode namespace conflicts when multiple interfaces are compiled and HIDDEN becomes /**/)
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.26 2006/08/08 06:47:05 brlcad Exp $ (ARL)";
@


14.26
log
@get rid of the libfb-specific _LOCAL_ macro, instead using HIDDEN like everyone else (currently still provided by machine.h)
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.25 2006/08/07 18:10:46 brlcad Exp $ (ARL)";
d99 1
a99 1
HIDDEN void		do_event(FBIO *ifp);
d1007 1
a1007 1
	do_event(ifp);
d1217 1
a1217 1
	do_event(ifp);
d1264 1
a1264 1
    do_event(ifp);
d2159 1
a2159 1
do_event(FBIO *ifp)
@


14.25
log
@reword away if_4d.c
@
text
@d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.24 2006/08/07 17:55:16 brlcad Exp $ (ARL)";
d91 1
d99 2
a100 2
_LOCAL_ void		do_event(FBIO *ifp);
_LOCAL_ void		expose_callback(FBIO *ifp, XEvent *eventPtr);
d104 4
a107 4
_LOCAL_ void		ogl_clipper(register FBIO *ifp);
_LOCAL_ int		ogl_getmem(FBIO *ifp);
_LOCAL_ void		backbuffer_to_screen(register FBIO *ifp, int one_y);
_LOCAL_ void		ogl_cminit(register FBIO *ifp);
d109 1
a109 1
_LOCAL_ void		reorder_cursor();
d111 2
a112 2
_LOCAL_ XVisualInfo *	ogl_choose_visual(FBIO *ifp);
_LOCAL_ int		is_linear_cmap(register FBIO *ifp);
d114 2
a115 2
_LOCAL_ int	ogl_nwindows = 0; 	/* number of open windows */
_LOCAL_ int	multiple_windows = 0;	/* someone wants to be ready
d119 1
a119 1
_LOCAL_	XColor	color_cell[256];		/* used to set colormap */
d126 1
a126 1
_LOCAL_ int	ogl_open(FBIO *ifp, char *file, int width, int height),
d344 1
a344 1
_LOCAL_ struct modeflags {
d413 1
a413 1
_LOCAL_ int
d552 1
a552 1
static void
d569 1
a569 1
_LOCAL_ void
d688 1
a688 1
_LOCAL_ int
d1127 1
a1127 1
_LOCAL_ int
d1169 1
a1169 1
_LOCAL_ int
d1261 1
a1261 1
_LOCAL_ int
d1278 1
a1278 1
_LOCAL_ int
d1295 1
a1295 1
_LOCAL_ int
d1375 1
a1375 1
_LOCAL_ int
d1453 1
a1453 1
_LOCAL_ int
d1468 1
a1468 1
_LOCAL_ int
d1519 1
a1519 1
_LOCAL_ int
d1658 1
a1658 1
_LOCAL_ int
d1727 1
a1727 1
_LOCAL_ int
d1790 1
a1790 1
_LOCAL_ int
d1813 1
a1813 1
_LOCAL_ int
d1829 1
a1829 1
_LOCAL_ void
d1844 1
a1844 1
_LOCAL_ int
d1909 1
a1909 1
_LOCAL_ int
d1975 1
a1975 1
_LOCAL_ int
d1982 1
a1982 1
_LOCAL_ int
d2046 1
a2046 1
_LOCAL_ int
d2071 1
a2071 1
_LOCAL_ int
d2158 1
a2158 1
_LOCAL_ void
d2231 1
a2231 1
_LOCAL_ void
d2395 1
a2395 1
_LOCAL_ void
d2417 1
a2417 1
_LOCAL_ void
d2508 1
a2508 1
_LOCAL_ XVisualInfo *
@


14.24
log
@IF_4D interface is not really shipped any more, don't talk about it
@
text
@d34 2
a35 1
 *  This code is basically a port of if_4d.c from IRIS GL to OpenGL.
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.23 2006/03/25 00:03:48 brlcad Exp $ (ARL)";
@


14.23
log
@quell intel on altix compiler warnings
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.22 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
a234 1
 *  Structure members have the same meaning as in the if_4d.c code.
d736 1
a736 1
		    fb_log( "if_4d: unknown option '%c' ignored\n", *cp );
@


14.22
log
@update copyright to 2006
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.21 2006/01/04 05:41:00 brlcad Exp $ (ARL)";
d76 7
@


14.22.2.1
log
@update from HEAD
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.22 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
a75 7
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif

@


14.21
log
@there is no saveifp, should be ifp
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.20 2005/12/29 08:13:08 brlcad Exp $ (ARL)";
@


14.20
log
@copy some of the event/alive checking that was added to if_ogl_win32.c for the if_ogl.c interface too.
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.19 2005/10/23 04:44:34 brlcad Exp $ (ARL)";
d1258 1
a1258 1
    if (OGL(saveifp)->alive < 0)
@


14.19
log
@trailing ws
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.18 2005/09/16 19:33:37 brlcad Exp $ (ARL)";
d1208 1
a1208 1
    while( OGL(ifp)->alive ) {
a1209 1
	sleep(1);
d1257 5
a1261 1
    return(0);
@


14.18
log
@wrap the interface headers in their respective IF_ defines so that they'll compile regardless of being available
@
text
@d29 2
a30 2
 *  Note that some of the /dev/sgi modes are not supported, and there are 
 *  some new modes. 
d39 1
a39 1
 *  
d43 1
a43 1
 *  
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.17 2005/08/12 22:30:12 lbutler Exp $ (ARL)";
d55 1
a55 1
#include <stdio.h> 
d61 1
a61 1
#include <stdlib.h>  
d68 2
a69 2
#include <X11/keysym.h> 
#include <X11/StringDefs.h> 
d87 1
a87 1
#define YMAXSCREEN	1023	
d141 1
a141 1
FBIO ogl_interface =  
d197 1
a197 1
/* 
d223 1
a223 1
	
d227 1
a227 1
 *  Per window state information, overflow area. 
d392 1
a392 1
 * 
d547 1
a547 1
        
d549 1
a549 1
     sigkid(int pid)        
d616 1
a616 1
		
d622 1
a622 1
		
d626 1
a626 1
	     */ 
d639 1
a639 1
    if( sw_cmap ) { 
d646 1
a646 1
	if(CJDEBUG) printf("Doing sw colormap xmit\n");		
d658 1
a658 1
			
d672 1
a672 1
		
d777 1
a777 1
     * This allows us to use the traditional fb utility programs 
d1119 1
a1119 1
_LOCAL_ int 
d1286 1
a1286 1
    	     
d1371 1
a1371 1
    if( xzoom < 1 ) xzoom = 1; 
d1406 1
a1406 1
	    /* COPY mode - no changes to backbuffer copy - just 
d1509 1
a1509 1
ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count) 
d1779 1
a1779 1
_LOCAL_ int	
d1838 1
a1838 1
	
d1847 1
a1847 1
	    CMG(ifp)[i] = cmp-> cm_green[i]>>8; 
d2060 1
a2060 1
_LOCAL_ int 
d2069 2
a2070 2
 * O G L _ C L I P P E R ( ) 
 * 
d2222 1
a2222 1
{    
d2238 1
a2238 1
		
d2252 1
a2252 1
	if( SGI(ifp)->mi_doublebuffer && 
d2254 1
a2254 1
	    /* Copy mode only works if there are two 
d2300 1
a2300 1
    } else if( (OGL(ifp)->win_width > ifp->if_width) || 
d2306 1
a2306 1
		       OGL(ifp)->win_height);      
d2312 1
a2312 1
		       OGL(ifp)->win_height);      
d2353 1
a2353 1
}  
d2379 1
a2379 1
/* reorder_cursor - reverses the order of the scanlines. 
d2384 1
a2384 1
_LOCAL_ void	
d2418 1
a2418 1
	
d2446 1
a2446 1
		
d2477 1
a2477 1
 * 
d2480 1
a2480 1
 * 	
d2485 1
a2485 1
 *	
d2490 1
a2490 1
 * 
d2507 1
a2507 1
	
d2513 2
a2514 2
	
    /* get a list of all visuals on this display */	
d2555 1
a2555 1
		
d2581 2
a2582 2
	     * no need for any warning - we'll just use 
	     * the front buffer 
d2595 1
a2595 1
		
@


14.17
log
@Doxygen changes
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.16 2005/06/02 13:22:07 brlcad Exp $ (ARL)";
d53 2
d2657 2
@


14.17.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 2
a30 2
 *  Note that some of the /dev/sgi modes are not supported, and there are
 *  some new modes.
d39 1
a39 1
 *
d43 1
a43 1
 *
d48 1
a48 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d53 1
a53 3
#ifdef IF_OGL

#include <stdio.h>
d59 1
a59 1
#include <stdlib.h>
d66 2
a67 2
#include <X11/keysym.h>
#include <X11/StringDefs.h>
d85 1
a85 1
#define YMAXSCREEN	1023
d139 1
a139 1
FBIO ogl_interface =
d195 1
a195 1
/*
d221 1
a221 1

d225 1
a225 1
 *  Per window state information, overflow area.
d390 1
a390 1
 *
d545 1
a545 1

d547 1
a547 1
     sigkid(int pid)
d614 1
a614 1

d620 1
a620 1

d624 1
a624 1
	     */
d637 1
a637 1
    if( sw_cmap ) {
d644 1
a644 1
	if(CJDEBUG) printf("Doing sw colormap xmit\n");
d656 1
a656 1

d670 1
a670 1

d775 1
a775 1
     * This allows us to use the traditional fb utility programs
d1117 1
a1117 1
_LOCAL_ int
d1284 1
a1284 1

d1369 1
a1369 1
    if( xzoom < 1 ) xzoom = 1;
d1404 1
a1404 1
	    /* COPY mode - no changes to backbuffer copy - just
d1507 1
a1507 1
ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count)
d1777 1
a1777 1
_LOCAL_ int
d1836 1
a1836 1

d1845 1
a1845 1
	    CMG(ifp)[i] = cmp-> cm_green[i]>>8;
d2058 1
a2058 1
_LOCAL_ int
d2067 2
a2068 2
 * O G L _ C L I P P E R ( )
 *
d2220 1
a2220 1
{
d2236 1
a2236 1

d2250 1
a2250 1
	if( SGI(ifp)->mi_doublebuffer &&
d2252 1
a2252 1
	    /* Copy mode only works if there are two
d2298 1
a2298 1
    } else if( (OGL(ifp)->win_width > ifp->if_width) ||
d2304 1
a2304 1
		       OGL(ifp)->win_height);
d2310 1
a2310 1
		       OGL(ifp)->win_height);
d2351 1
a2351 1
}
d2377 1
a2377 1
/* reorder_cursor - reverses the order of the scanlines.
d2382 1
a2382 1
_LOCAL_ void
d2416 1
a2416 1

d2444 1
a2444 1

d2475 1
a2475 1
 *
d2478 1
a2478 1
 *
d2483 1
a2483 1
 *
d2488 1
a2488 1
 *
d2505 1
a2505 1

d2511 2
a2512 2

    /* get a list of all visuals on this display */
d2553 1
a2553 1

d2579 2
a2580 2
	     * no need for any warning - we'll just use
	     * the front buffer
d2593 1
a2593 1

a2654 2
#endif /* IF_OGL */

@


14.16
log
@removed unused defines from 4d carryover
@
text
@d21 3
a24 1
 *
d45 2
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.15 2005/05/09 19:28:56 brlcad Exp $ (ARL)";
@


14.15
log
@glXCreateContext might not be able to make a direct context, so don't presume that it will.  if it's not, we need to turn on the multiple_windows flag so that the context is properly acquired/released.  this fixes a bus error crash on the macs, as well as other oddities on some other platforms.  this is possibly related to sf bug 925427 where the entire X display would go black until the raytrace completes.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.14 2005/05/09 18:21:47 brlcad Exp $ (ARL)";
a81 4
#define XMAXMEDIUM	1023
#define YMAXMEDIUM	767
#define XMAX170		645
#define YMAX170		484
@


14.14
log
@throttle the linger idle event loop so that we don't end up calling XCheckWindowEvent as fast as possible.
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.13 2005/05/09 17:57:21 brlcad Exp $ (ARL)";
d881 1
a881 1
    if (multiple_windows){	/* force indirect context */
d883 1
a883 1
					  OGL(ifp)->vip, 0, GL_FALSE);
d886 6
a891 1
					  OGL(ifp)->vip, 0, GL_TRUE);
d894 2
a895 3
    if (CJDEBUG){
	direct = glXIsDirect(OGL(ifp)->dispp,OGL(ifp)->glxc);
	printf("Context is %s.\n", direct ? "direct" : "indirect");
a897 1

@


14.13
log
@BRL frambuffers are just framebuffers now
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.12 2005/05/09 17:24:31 brlcad Exp $ (ARL)";
d1203 1
a1203 1
    while( OGL(ifp)->alive )
d1205 2
@


14.12
log
@do not let any key press or mouse release make the lingering framebuffer disappear (!).  also do not close stderr since that is what the child uses when fb_logging.  stub in the same behavior as the X24 interface where it reports the rgb value at a particular coordinate.
@
text
@d23 1
a23 1
 *  BRL Frame Buffer Library interface for OpenGL.
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.11 2005/05/09 14:32:34 brlcad Exp $ (ARL)";
@


14.11
log
@M-x indent-region and other ws
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.10 2005/05/08 19:40:12 brlcad Exp $ (ARL)";
d786 1
a786 1
	if( (f = fork()) > 0 )  {
d790 3
a792 2
	    for(k=0; k< 20; k++)  {
		(void) close(k);
a794 1

d1187 4
a1190 3
     *  ourselves with eliminating stdin, stdout, and stderr,
     *  (fd 0,1,2), in the hopes that this will successfully
     *  terminate any pipes or network connections.  
a1193 1
    fclose( stderr );
d2153 44
a2196 9
		break;
	    case ButtonRelease:
		OGL(ifp)->alive = 0;
		break;
	    case KeyPress:
		break;
	    case KeyRelease:
		OGL(ifp)->alive = 0;
		break;
@


14.10
log
@get rid of outdated comment
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.9 2005/04/26 08:14:58 brlcad Exp $ (ARL)";
d116 10
a125 10
		ogl_close(FBIO *ifp),
		ogl_clear(FBIO *ifp, unsigned char *pp),
		ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count),
		ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count),
		ogl_rmap(register FBIO *ifp, register ColorMap *cmp),
		ogl_wmap(register FBIO *ifp, register const ColorMap *cmp),
		ogl_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		ogl_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		ogl_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		ogl_cursor(FBIO *ifp, int mode, int x, int y),
d127 3
a129 3
		ogl_getcursor(),
		ogl_readrect(),
		fb_cnull(),
d131 6
a136 6
		ogl_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		ogl_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		ogl_poll(FBIO *ifp),
		ogl_flush(FBIO *ifp),
		ogl_free(FBIO *ifp),
		ogl_help(FBIO *ifp);
d140 1
a140 1
	{
d181 1
a181 1
};
d190 3
a192 3
	short	cmr[256];
	short	cmg[256];
	short	cmb[256];
d201 4
a204 4
	unsigned char alpha;
	unsigned char blue;
	unsigned char green;
	unsigned char red;
d209 12
a220 12
	int	xpixmin;	/* view clipping planes clipped to pixel memory space*/
	int	xpixmax;
	int	ypixmin;
	int	ypixmax;
	int	xscrmin;	/* view clipping planes */
	int	xscrmax;
	int	yscrmin;
	int	yscrmax;
	double	oleft;		/* glOrtho parameters */
	double	oright;
	double	otop;
	double	obottom;
d229 10
a238 10
	short	mi_curs_on;
	short	mi_cmap_flag;		/* enabled when there is a non-linear map in memory */
	int	mi_shmid;
	int	mi_memwidth;		/* width of scanline in if_mem */
	short	mi_xoff;		/* X viewport offset, rel. window*/
	short	mi_yoff;		/* Y viewport offset, rel. window*/
	int	mi_pid;			/* for multi-cpu check */
	int	mi_parent;		/* PID of linger-mode process */
	int	mi_doublebuffer;	/* 0=singlebuffer 1=doublebuffer */
	struct ogl_pixel mi_scanline[XMAXSCREEN+1];	/* one scanline */
d245 19
a263 19
	GLXContext	glxc;
	Display	       *dispp;		/* pointer to X display connection */
	Window		wind;		/* Window identifier */
	int		firstTime;
	int		alive;
	long		event_mask;	/* event types to be received */
	short		front_flag;	/* front buffer being used (b-mode) */
	short		copy_flag;	/* pan and zoom copied from backbuffer */
	short		soft_cmap_flag;	/* use software colormapping */
	int		cmap_size;	/* hardware colormap size */
	int 		win_width;	/* actual window width */
	int		win_height;	/* actual window height */
	int		vp_width;	/* actual viewport width */
	int		vp_height;	/* actual viewport height */
	struct ogl_clip	clip;		/* current view clipping */
	Window		cursor;
	XVisualInfo    *vip;		/* pointer to info on current visual */
	Colormap	xcmap;		/* xstyle color map */
	int		use_ext_ctrl;	/* for controlling the Ogl graphics engine externally */
d329 1
a329 1
					/* and copy current view to front */
d335 4
a338 4
	char	c;
	long	mask;
	long	value;
	char	*help;
d340 21
a360 21
	{ 'p',	MODE_1MASK, MODE_1MALLOC,
		"Private memory - else shared" },
	{ 'l',	MODE_2MASK, MODE_2LINGERING,
		"Lingering window - else transient" },
	{ 'f',	MODE_3MASK, MODE_3FULLSCR,
		"Full centered screen - else windowed" },
	{ 'd',  MODE_4MASK, MODE_4NODITH,
		"Suppress dithering - else dither if not 24-bit buffer" },
	{ 'm',  MODE_5MASK, MODE_5MULTI,
		"Be ready for multiple windows - else optimize for single windows" },
	{ 'c',	MODE_7MASK, MODE_7SWCMAP,
		"Perform software colormap - else use hardware colormap if possible" },
	{ 's',	MODE_9MASK, MODE_9SINGLEBUF,
		"Single buffer -  else double buffer if possible" },
	{ 'b',	MODE_11MASK, MODE_11COPY,
		"Fast pan and zoom using backbuffer copy -  else normal " },
	{ 'D',	MODE_12DELAY_WRITES_TILL_FLUSH, MODE_12DELAY_WRITES_TILL_FLUSH,
		"Don't update screen until fb_flush() is called.  (Double buffer sim)" },
	{ 'z',	MODE_15MASK, MODE_15ZAP,
		"Zap (free) shared memory.  Can also be done with fbfree command" },
	{ '\0', 0, 0, "" }
d407 3
a409 3
	int	pixsize;
	int	size;
	int	i;
d411 2
a412 2
	char	*old_brk;
	char	*new_brk;
d414 2
a415 4
	char	*sp;
	int	new = 0;

	errno = 0;
d417 1
a417 19
	if( (ifp->if_mode & MODE_1MASK) == MODE_1MALLOC )  {
		/*
		 *  In this mode, only malloc as much memory as is needed.
		 */
		SGI(ifp)->mi_memwidth = ifp->if_width;
		pixsize = ifp->if_height * ifp->if_width * sizeof(struct ogl_pixel);
		size = pixsize + sizeof(struct ogl_cmap);

		sp = calloc( 1, size );
		if( sp == 0 )  {
			fb_log("ogl_getmem: frame buffer memory malloc failed\n");
			goto fail;
		}
		new = 1;
		goto success;
	}

	/* The shared memory section never changes size */
	SGI(ifp)->mi_memwidth = ifp->if_max_width;
d419 1
d421 1
a421 4
	 *  On Irix 5 with Indigo EXPRESS graphics,
	 *  lrectwrite() runs off the end!
	 *  So, provide a pad area of 2 scanlines.
	 *  (1 line is enough, but this avoids risk of damage to colormap table.)
d423 2
a424 3
	pixsize = (ifp->if_max_height+2) * ifp->if_max_width *
		sizeof(struct ogl_pixel);

a425 1
	size = (size + getpagesize()-1) & ~(getpagesize()-1);
d427 4
a430 9
	/* First try to attach to an existing one */
	if( (SGI(ifp)->mi_shmid = shmget( SHMEM_KEY, size, 0 )) < 0 )  {
		/* No existing one, create a new one */
		if( (SGI(ifp)->mi_shmid = shmget(
		    SHMEM_KEY, size, IPC_CREAT|0666 )) < 0 )  {
			fb_log("ogl_getmem: shmget failed, errno=%d\n", errno);
			goto fail;
		}
		new = 1;
d432 3
d436 27
a462 1
/* WWW this is unnecessary in this version? */
d464 22
a485 22
	/* Move up the existing break, to leave room for later malloc()s */
	old_brk = sbrk(0);
	new_brk = (char *)(6 * (XMAXSCREEN+1) * 1024L);
	if( new_brk <= old_brk )
		new_brk = old_brk + (XMAXSCREEN+1) * 1024;
	new_brk = (char *)((((long)new_brk) + getpagesize()-1) & ~(getpagesize()-1));
	if( brk( new_brk ) < 0 )  {
		fb_log("ogl_getmem: new brk(x%x) failure, errno=%d\n", new_brk, errno);
		goto fail;
	}

	/* Open the segment Read/Write, near the current break */
	if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1L) )  {
		fb_log("ogl_getmem: shmat returned x%x, errno=%d\n", sp, errno );
		goto fail;
	}

	/* Restore the old break */
	if( brk( old_brk ) < 0 )  {
		fb_log("ogl_getmem: restore brk(x%x) failure, errno=%d\n", old_brk, errno);
		/* Take the memory and run */
	}
d487 6
a492 6
	/* Open the segment Read/Write */
	/* On Irix 5, this gets mapped in at a high address, no problem. */
	if( (sp = shmat( SGI(ifp)->mi_shmid, 0, 0 )) == (char *)(-1L) )  {
		fb_log("ogl_getmem: shmat returned x%x, errno=%d\n", sp, errno );
		goto fail;
	}
d495 18
a512 18
success:
	ifp->if_mem = sp;
	ifp->if_cmap = sp + pixsize;	/* cmap at end of area */
	i = CMB(ifp)[255];		/* try to deref last word */
	CMB(ifp)[255] = i;

	/* Provide non-black colormap on creation of new shared mem */
	if(new)
		ogl_cminit( ifp );
	return(0);
fail:
	fb_log("ogl_getmem:  Unable to attach to shared memory.\n");
	if( (sp = calloc( 1, size )) == NULL )  {
		fb_log("ogl_getmem:  malloc failure\n");
		return(-1);
	}
	new = 1;
	goto success;
d515 1
d522 2
a523 2
	int shmid;
	int i;
d525 4
a528 4
	if( (shmid = shmget( SHMEM_KEY, 0, 0 )) < 0 )  {
		fb_log("ogl_zapmem shmget failed, errno=%d\n", errno);
		return;
	}
d530 6
a535 6
	i = shmctl( shmid, IPC_RMID, 0 );
	if( i < 0 )  {
		fb_log("ogl_zapmem shmctl failed, errno=%d\n", errno);
		return;
	}
	fb_log("if_ogl: shared memory released\n");
d538 1
d550 1
a550 1
	exit(0);
a553 1

d562 4
a565 4
	register int	y;
	register int	n;
	int		sw_cmap;	/* !0 => needs software color map */
	struct ogl_clip	*clp;
d567 1
a567 1
	/* Caller is expected to handle attaching context, etc. */
d569 1
a569 1
	clp = &(OGL(ifp)->clip);
d571 5
a575 5
	if( OGL(ifp)->soft_cmap_flag  && SGI(ifp)->mi_cmap_flag )  {
	    	sw_cmap = 1;
	} else {
		sw_cmap = 0;
	}
d577 11
a587 11
	if(xbase > clp->xpixmax || ybase > clp->ypixmax)
		return;
	if(xbase < clp->xpixmin)
		xbase = clp->xpixmin;
	if(ybase < clp->ypixmin)
		ybase = clp->ypixmin;

	if((xbase + npix -1 ) > clp->xpixmax)
		npix = clp->xpixmax - xbase + 1;
	if((ybase + nlines - 1) > clp->ypixmax)
		nlines = clp->ypixmax - ybase + 1;
d589 1
a589 1
	if(!OGL(ifp)->use_ext_ctrl){
d591 23
a613 26
		/*
		 * Blank out areas of the screen around the image, if exposed.
		 * In COPY mode, this is done in backbuffer_to_screen().
		 */

		/* Blank out area left of image */
		glColor3b( 0, 0, 0 );
		if( clp->xscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* Blank out area below image */
		if( clp->yscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			CLIP_XTRA);

		/* Blank out area right of image */
		if( clp->xscrmax >= ifp->if_width )  glRecti(
			ifp->if_width - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);
d615 5
a619 6
		/* Blank out area above image */
		if( clp->yscrmax >= ifp->if_height )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			ifp->if_height- CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);
d622 12
a633 13
		/* in COPY mode, always draw full sized image into backbuffer.
		 * backbuffer_to_screen() is used to update the front buffer
		 */ 
		glDrawBuffer(GL_BACK);
		OGL(ifp)->front_flag = 0;
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();	/* store current view clipping matrix*/
		glLoadIdentity();
		glOrtho( -0.25, ((GLdouble) OGL(ifp)->vp_width)-0.25,
			-0.25, ((GLdouble) OGL(ifp)->vp_height)-0.25,
			-1.0, 1.0);
		glPixelZoom( 1.0, 1.0);
	}
d635 7
d643 13
a655 19
	if( sw_cmap ) { 
		/* Software colormap each line as it's transmitted */
		register int	x;
		register struct ogl_pixel	*oglp;
		register struct ogl_pixel	*op;

		y = ybase;
		if(CJDEBUG) printf("Doing sw colormap xmit\n");		
		/* Perform software color mapping into temp scanline */
		op = SGI(ifp)->mi_scanline;
		for( n=nlines; n>0; n--, y++ )  {
			oglp = (struct ogl_pixel *)&ifp->if_mem[
				(y*SGI(ifp)->mi_memwidth)*
				sizeof(struct ogl_pixel) ];
			for( x=xbase+npix-1; x>=xbase; x-- )  {
				op[x].red   = CMR(ifp)[oglp[x].red];
				op[x].green = CMG(ifp)[oglp[x].green];
				op[x].blue  = CMB(ifp)[oglp[x].blue];
			}
d657 4
a660 4
			glPixelStorei(GL_UNPACK_SKIP_PIXELS,xbase);
			glRasterPos2i(xbase,y);
			glDrawPixels(npix,1,GL_ABGR_EXT,GL_UNSIGNED_BYTE,
					(const GLvoid *) op);
d662 1
a662 1
		}
d664 2
a665 2
	} else  {
		/* No need for software colormapping */
d667 3
a669 3
		glPixelStorei(GL_UNPACK_ROW_LENGTH,SGI(ifp)->mi_memwidth);
		glPixelStorei(GL_UNPACK_SKIP_PIXELS,xbase);
		glPixelStorei(GL_UNPACK_SKIP_ROWS,ybase);
d671 4
a674 4
		glRasterPos2i(xbase,ybase);
		glDrawPixels(npix,nlines,GL_ABGR_EXT,GL_UNSIGNED_BYTE,
				(const GLvoid *) ifp->if_mem);
	}
d682 62
a743 6
	int		f;
	int		status;
	static char	title[128];
	int		mode, i, direct;
	long		valuemask;
	XSetWindowAttributes swa;
d745 13
a757 1
	FB_CK_FBIO(ifp);
d759 1
a759 7
	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/ogl###"
	 *  The default mode is zero.
	 */
	mode = 0;
d761 3
a763 37
	if( file != NULL )  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if( strncmp(file, "/dev/ogl", 8) ) {
			/* How did this happen?? */
			mode = 0;
		} else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[8];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
				}
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_4d: unknown option '%c' ignored\n", *cp );
				}
				cp++;
			}
			*mp = '\0';
			if( !alpha )
				mode = atoi( modebuf );
		}
d765 43
a807 5
		if( (mode & MODE_15MASK) == MODE_15ZAP ) {
			/* Only task: Attempt to release shared memory segment */
			ogl_zapmem();
			return(-1);
		}
d809 30
a838 1
	ifp->if_mode = mode;
d840 33
a872 4
	/*
	 *  Allocate extension memory sections,
	 *  addressed by SGI(ifp)->mi_xxx and OGL(ifp)->xxx
	 */
d874 5
a878 61
	if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
		fb_log("ogl_open:  sgiinfo malloc failed\n");
		return(-1);
	}
	if( (OGLL(ifp) = (char *)calloc( 1, sizeof(struct oglinfo) )) == NULL )  {
		fb_log("ogl_open:  oglinfo malloc failed\n");
		return(-1);
	}

	SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */

	if (ogl_nwindows && !multiple_windows){
		fb_log("Warning - ogl_open: Multiple windows opened. Use /dev/oglm for first window!");
	}

	/* Anyone can turn this on; no one can turn it off */
	if( (ifp->if_mode & MODE_5MASK) == MODE_5MULTI )
		multiple_windows = 1;

	/* the Silicon Graphics Library Window management routines
	 * use shared memory. This causes lots of problems when you
	 * want to pass a window structure to a child process.
	 * One hack to get around this is to immediately fork
	 * and create a child process and sleep until the child
	 * sends a kill signal to the parent process. (in FBCLOSE)
	 * This allows us to use the traditional fb utility programs 
	 * as well as allow the frame buffer window to remain around
	 * until killed by the menu subsystem.
    	 */

	if( (ifp->if_mode & MODE_2MASK) == MODE_2LINGERING )  {
		/* save parent pid for later signalling */
		SGI(ifp)->mi_parent = getpid();

		signal( SIGUSR1, sigkid);

		if( (f = fork()) > 0 )  {
			/* Parent process */
			int k;

			for(k=0; k< 20; k++)  {
				(void) close(k);
			}


			/*
			 *  Wait until the child dies, of whatever cause,
			 *  or until the child kills us.
			 *  Pretty vicious, this computer society.
			 */
			while( (k = wait(&status)) != -1 && k != f )
				/* NULL */ ;

			exit(0);
			/* NOTREACHED */
		} else if( f < 0 )  {
			fb_log("ogl_open:  linger-mode fork failure\n");
			return(-1);
		}
		/* Child Process falls through */
	}
d880 8
a887 61
	if( (ifp->if_mode & MODE_3MASK) == MODE_3FULLSCR )  {
		/* Bump default size up to full screen, since we have it all */
		ifp->if_width = XMAXSCREEN+1;		/* 1280 */
		ifp->if_height = YMAXSCREEN+1;		/* 1024 */
	}

	/* use defaults if invalid width and height specified */
	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	/* use max values if width and height are greater */
	if ( width > ifp->if_max_width )
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height)
		height = ifp->if_max_height;

	ifp->if_width = width;
	ifp->if_height = height;


	if( (ifp->if_mode & MODE_3MASK) == MODE_3WINDOW )  {
		SGI(ifp)->mi_curs_on = 1;
	}  else  {
		/* MODE_3MASK == MODE_3FULLSCR */
		SGI(ifp)->mi_curs_on = 0;
	}

	/* Build a descriptive window title bar */
	(void)sprintf( title, "BRL-CAD /dev/ogl %s, %s",
		((ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT) ?
			"Transient Win":
			"Lingering Win",
		((ifp->if_mode & MODE_1MASK) == MODE_1MALLOC) ?
			"Private Mem" :
			"Shared Mem" );


	/* initialize window state variables before calling ogl_getmem */
	ifp->if_zoomflag = 0;
	ifp->if_xzoom = 1;	/* for zoom fakeout */
	ifp->if_yzoom = 1;	/* for zoom fakeout */
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;
	SGI(ifp)->mi_pid = getpid();

	/* Attach to shared memory, potentially with a screen repaint */
	if( ogl_getmem(ifp) < 0 )
		return(-1);

	/* Open an X connection to the display.  Sending NULL to XOpenDisplay
	   tells it to use the DISPLAY environment variable. */
	if( (OGL(ifp)->dispp = XOpenDisplay(NULL)) == NULL ) {
		fb_log("ogl_open: Failed to open display.  Check DISPLAY environment variable.\n");
		return (-1);
	}
	ifp->if_selfd = ConnectionNumber(OGL(ifp)->dispp);
	if( CJDEBUG ) {
		printf("Connection opened to X display on fd %d.\n",
		       ConnectionNumber(OGL(ifp)->dispp));
	}
d889 4
a892 19
	/* Choose an appropriate visual. */
	if( (OGL(ifp)->vip = ogl_choose_visual(ifp)) == NULL ) {
		fb_log("ogl_open: Couldn't find an appropriate visual.  Exiting.\n");
		return (-1);
	}

	/* Open an OpenGL context with this visual*/
	if (multiple_windows){	/* force indirect context */
		OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,
					OGL(ifp)->vip, 0, GL_FALSE);
	} else {		/* try direct context */
		OGL(ifp)->glxc = glXCreateContext(OGL(ifp)->dispp,
					OGL(ifp)->vip, 0, GL_TRUE);
	}

	if (CJDEBUG){
		direct = glXIsDirect(OGL(ifp)->dispp,OGL(ifp)->glxc);
		printf("Context is %s.\n", direct ? "direct" : "indirect");
	}
d895 23
a917 29
	/* Create a colormap for this visual */
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
	if (!OGL(ifp)->soft_cmap_flag) {
		OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp,
					RootWindow(OGL(ifp)->dispp,
						OGL(ifp)->vip->screen),
					OGL(ifp)->vip->visual,
					AllocAll);
		/* initialize virtual colormap - it will be loaded into
		 * the hardware. This code has not yet been tested.
		 */
		if(CJDEBUG) printf("Loading read/write colormap.\n");
	    	for (i = 0; i < 256; i++) {
	    		color_cell[i].pixel = i;
	    		color_cell[i].red = CMR(ifp)[i];
	    		color_cell[i].green = CMG(ifp)[i];
	    		color_cell[i].blue = CMB(ifp)[i];
	    		color_cell[i].flags = DoRed | DoGreen | DoBlue;
	    	}
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell,256);
	} else { /* read only colormap */
		if( CJDEBUG ) {
			printf("Allocating read-only colormap.");
		}
		OGL(ifp)->xcmap = XCreateColormap(OGL(ifp)->dispp,
					RootWindow(OGL(ifp)->dispp,
						   OGL(ifp)->vip->screen),
					OGL(ifp)->vip->visual,
					AllocNone);
d919 6
d926 1
a926 1
 	XSync(OGL(ifp)->dispp, 0);
d928 2
a929 2
	/* Create a window. */
	memset(&swa, 0, sizeof(swa));
d931 1
a931 1
	valuemask = CWBackPixel | CWBorderPixel | CWEventMask | CWColormap;
d933 1
a933 3
	swa.background_pixel = BlackPixel(OGL(ifp)->dispp,
					  OGL(ifp)->vip->screen);
	swa.border_pixel = BlackPixel(OGL(ifp)->dispp,
d935 6
a940 4
	swa.event_mask = OGL(ifp)->event_mask =
		ExposureMask | KeyPressMask | KeyReleaseMask |
 		ButtonPressMask | ButtonReleaseMask;
	swa.colormap = OGL(ifp)->xcmap;
d974 17
a990 21
	OGL(ifp)->wind = XCreateWindow(OGL(ifp)->dispp,
				       RootWindow(OGL(ifp)->dispp,
						  OGL(ifp)->vip->screen),
				       0, 0, ifp->if_width, ifp->if_height, 0,
				       OGL(ifp)->vip->depth,
				       InputOutput,
				       OGL(ifp)->vip->visual,
				       valuemask, &swa);

	XStoreName(OGL(ifp)->dispp, OGL(ifp)->wind, title);

	/* count windows */
	ogl_nwindows++;
	XMapRaised(OGL(ifp)->dispp, OGL(ifp)->wind);

	OGL(ifp)->alive = 1;
	OGL(ifp)->firstTime = 1;

	/* Loop through events until first exposure event is processed */
	while (OGL(ifp)->firstTime == 1)
		do_event(ifp);
d992 5
a996 1
	return 0;
d999 1
d1003 9
a1011 9
  Display *dpy;
  Window win;
  Colormap cmap;
  XVisualInfo *vip;
  int width;
  int height;
  GLXContext glxc;
  int double_buffer;
  int soft_cmap;
d1013 2
a1014 2
  if(argc != 10)
    return -1;
d1016 2
a1017 2
  if(sscanf(argv[1], "%lu", (unsigned long *)&dpy) != 1)
    return -1;
d1019 2
a1020 2
  if(sscanf(argv[2], "%lu", (unsigned long *)&win) != 1)
    return -1;
d1022 2
a1023 2
  if(sscanf(argv[3], "%lu", (unsigned long *)&cmap) != 1)
    return -1;
d1025 2
a1026 2
  if(sscanf(argv[4], "%lu", (unsigned long *)&vip) != 1)
    return -1;
d1028 2
a1029 2
  if(sscanf(argv[5], "%d", &width) != 1)
    return -1;
d1031 2
a1032 2
  if(sscanf(argv[6], "%d", &height) != 1)
    return -1;
d1034 2
a1035 2
  if(sscanf(argv[7], "%lu", (unsigned long *)&glxc) != 1)
    return -1;
d1037 2
a1038 2
  if(sscanf(argv[8], "%d", &double_buffer) != 1)
    return -1;
d1040 2
a1041 2
  if(sscanf(argv[9], "%d", &soft_cmap) != 1)
    return -1;
d1043 2
a1044 2
  return _ogl_open_existing(ifp, dpy, win, cmap, vip, width, height,
			    glxc, double_buffer, soft_cmap);
d1047 1
d1052 43
a1094 2
  /*XXX for now use private memory */
  ifp->if_mode = MODE_1MALLOC;
d1096 6
a1101 50
  /*
   *  Allocate extension memory sections,
   *  addressed by SGI(ifp)->mi_xxx and OGL(ifp)->xxx
   */

  if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
    fb_log("ogl_open:  sgiinfo malloc failed\n");
    return -1;
  }
  if( (OGLL(ifp) = (char *)calloc( 1, sizeof(struct oglinfo) )) == NULL )  {
    fb_log("ogl_open:  oglinfo malloc failed\n");
    return -1;
  }

  OGL(ifp)->use_ext_ctrl = 1;

  SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */
  multiple_windows = 1;
  ifp->if_width = ifp->if_max_width = width;
  ifp->if_height = ifp->if_max_height = height;

  OGL(ifp)->win_width = OGL(ifp)->vp_width = width;
  OGL(ifp)->win_height = OGL(ifp)->vp_height = height;

  SGI(ifp)->mi_curs_on = 1;

  /* initialize window state variables before calling ogl_getmem */
  ifp->if_zoomflag = 0;
  ifp->if_xzoom = 1;	/* for zoom fakeout */
  ifp->if_yzoom = 1;	/* for zoom fakeout */
  ifp->if_xcenter = width/2;
  ifp->if_ycenter = height/2;
  SGI(ifp)->mi_pid = getpid();

  /* Attach to shared memory, potentially with a screen repaint */
  if(ogl_getmem(ifp) < 0)
    return -1;

  OGL(ifp)->dispp = dpy;
  ifp->if_selfd = ConnectionNumber(OGL(ifp)->dispp);

  OGL(ifp)->vip = vip;
  OGL(ifp)->glxc = glxc;
  SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
  OGL(ifp)->soft_cmap_flag = soft_cmap;
  SGI(ifp)->mi_doublebuffer = double_buffer;
  OGL(ifp)->xcmap = cmap;

  OGL(ifp)->wind = win;
  ++ogl_nwindows;
d1103 2
a1104 2
  OGL(ifp)->alive = 1;
  OGL(ifp)->firstTime = 1;
d1106 2
a1107 1
  ogl_clipper(ifp);
d1109 3
a1111 1
  return 0;
d1118 31
a1148 22
  if( CJDEBUG ) {
    printf("ogl_final_close: All done...goodbye!\n");
  }

  if(OGL(ifp)->cursor)
    XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);

  XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->wind);
  XFreeColormap(OGL(ifp)->dispp, OGL(ifp)->xcmap);

  if( SGIL(ifp) != NULL ) {
    /* free up memory associated with image */
    if( SGI(ifp)->mi_shmid != -1 ) {
      /* detach from shared memory */
      if( shmdt( ifp->if_mem ) == -1 ) {
	fb_log("ogl_close shmdt failed, errno=%d\n",
	       errno);
	return -1;
      }
    } else {
      /* free private memory */
      (void)free( ifp->if_mem );
a1149 9
    /* free state information */
    (void)free( (char *)SGIL(ifp) );
    SGIL(ifp) = NULL;
  }

  if( OGLL(ifp) != NULL) {
    (void) free( (char *)OGLL(ifp) );
    OGLL(ifp) = NULL;
  }
d1151 2
a1152 2
  ogl_nwindows--;
  return(0);
d1160 1
a1160 8
	ogl_flush( ifp );

	/* only the last open window can linger -
	 * call final_close if not lingering
	 */
	if( ogl_nwindows > 1 ||
	    (ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT )
		return ogl_final_close( ifp );
d1162 40
a1201 2
	if( CJDEBUG )
		printf("ogl_close: remaining open to linger awhile.\n");
d1203 2
a1204 33
	/*
	 *  else:
	 *  LINGER mode.  Don't return to caller until user mouses "close"
	 *  menu item.  This may delay final processing in the calling
	 *  function for some time, but the assumption is that the user
	 *  wishes to compare this image with others.
	 *
	 *  Since we plan to linger here, long after our invoker
	 *  expected us to be gone, be certain that no file descriptors
	 *  remain open to associate us with pipelines, network
	 *  connections, etc., that were ALREADY ESTABLISHED before
	 *  the point that fb_open() was called.
	 *
	 *  The simple for i=0..20 loop will not work, because that
	 *  smashes some window-manager files.  Therefore, we content
	 *  ourselves with eliminating stdin, stdout, and stderr,
	 *  (fd 0,1,2), in the hopes that this will successfully
	 *  terminate any pipes or network connections.  
	 */
	fclose( stdin );
	fclose( stdout );
	fclose( stderr );

	/* Ignore likely signals, perhaps in the background,
	 * from other typing at the keyboard
	 */
	(void)signal( SIGHUP, SIG_IGN );
	(void)signal( SIGINT, SIG_IGN );
	(void)signal( SIGQUIT, SIG_IGN );
	(void)signal( SIGALRM, SIG_IGN );

	while( OGL(ifp)->alive )
		do_event(ifp);
d1206 1
a1206 1
	return 0;
d1212 2
a1213 2
  if(OGL(ifp)->cursor)
    XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);
d1215 21
a1235 12
  if( SGIL(ifp) != NULL ) {
    /* free up memory associated with image */
    if( SGI(ifp)->mi_shmid != -1 ) {
      /* detach from shared memory */
      if( shmdt( ifp->if_mem ) == -1 ) {
	fb_log("ogl_close shmdt failed, errno=%d\n",
	       errno);
	return -1;
      }
    } else {
      /* free private memory */
      (void)free( ifp->if_mem );
a1236 9
    /* free state information */
    (void)free( (char *)SGIL(ifp) );
    SGIL(ifp) = NULL;
  }

  if( OGLL(ifp) != NULL) {
    (void) free( (char *)OGLL(ifp) );
    OGLL(ifp) = NULL;
  }
d1238 1
a1238 1
  return 0;
d1241 1
d1250 2
a1251 2
	do_event(ifp);
	return(0);
d1254 1
d1263 1
a1263 1
	int	ret;
d1265 9
a1273 9
	if(CJDEBUG) printf("entering  ogl_free\n");
	/* Close the framebuffer */
	ret = ogl_final_close( ifp );

	if( (ifp->if_mode & MODE_1MASK) == MODE_1SHARED ) {
		/* If shared mem, release the shared memory segment */
		ogl_zapmem();
	}
	return ret;
d1280 1
a1280 1
             	    		/* pointer to beginning of memory segment*/
d1282 4
a1285 4
	struct ogl_pixel		bg;
	register struct ogl_pixel      *oglp;
	register int			cnt;
	register int			y;
d1287 1
a1287 1
	if( CJDEBUG ) printf("entering ogl_clear\n");
d1289 3
a1291 4
	if (multiple_windows) {
		if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_clear: glXMakeCurrent unsuccessful.\n");
		}
d1293 1
d1295 14
a1308 14
	/* Set clear colors */
	if ( pp != RGBPIXEL_NULL)  {
		bg.alpha = 0;
		bg.red   = (pp)[RED];
		bg.green = (pp)[GRN];
		bg.blue  = (pp)[BLU];
		glClearColor( pp[RED]/255.0, pp[GRN]/255.0, pp[BLU]/255.0, 0.0 );
	} else {
		bg.alpha = 0;
		bg.red   = 0;
		bg.green = 0;
		bg.blue  = 0;
		glClearColor( 0, 0, 0, 0 );
	}
d1310 6
a1315 7
	/* Flood rectangle in shared memory */
	for( y=0; y < ifp->if_height; y++ )  {
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+0)*sizeof(struct ogl_pixel) ];
		for( cnt=ifp->if_width-1; cnt >= 0; cnt-- )  {
			*oglp++ = bg;	/* struct copy */
		}
d1317 1
d1320 10
a1329 2
	/* Update screen */
	if(OGL(ifp)->use_ext_ctrl){
d1331 6
a1336 14
	}else{
	if ( OGL(ifp)->copy_flag){
		/* COPY mode: clear both buffers */
		if (OGL(ifp)->front_flag){
			glDrawBuffer(GL_BACK);
			glClear(GL_COLOR_BUFFER_BIT);
			glDrawBuffer(GL_FRONT);
			glClear(GL_COLOR_BUFFER_BIT);
		} else {
			glDrawBuffer(GL_FRONT);
			glClear(GL_COLOR_BUFFER_BIT);
			glDrawBuffer(GL_BACK);
			glClear(GL_COLOR_BUFFER_BIT);
		}
d1338 4
a1341 4
		glClear(GL_COLOR_BUFFER_BIT);
		if(SGI(ifp)->mi_doublebuffer){
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		}
d1345 2
a1346 3
		/* unattach context for other threads to use */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
d1348 1
d1350 1
a1350 1
	return(0);
d1360 25
a1384 1
	struct ogl_clip *clp;
a1385 1
	if(CJDEBUG) printf("entering ogl_view\n");
d1387 3
a1389 26
	if( xzoom < 1 ) xzoom = 1; 
	if( yzoom < 1 ) yzoom = 1;
	if( ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	  && ifp->if_xzoom == xzoom && ifp->if_yzoom == yzoom )
		return(0);

	if( xcenter < 0 || xcenter >= ifp->if_width )
		return(-1);
	if( ycenter < 0 || ycenter >= ifp->if_height )
		return(-1);
	if( xzoom >= ifp->if_width || yzoom >= ifp->if_height )
		return(-1);

	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = ycenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;

	if( ifp->if_xzoom > 1 || ifp->if_yzoom > 1 )
		ifp->if_zoomflag = 1;
	else	ifp->if_zoomflag = 0;


	if(OGL(ifp)->use_ext_ctrl){
		ogl_clipper(ifp);
	}else{
d1391 3
a1393 3
		if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
			fb_log("Warning, ogl_view: glXMakeCurrent unsuccessful.\n");
		}
d1399 6
a1404 6
		/* COPY mode - no changes to backbuffer copy - just 
		 * need to update front buffer
		 */
		glPopMatrix();
		glDrawBuffer(GL_FRONT);
		OGL(ifp)->front_flag = 1;
d1414 1
a1414 1
		backbuffer_to_screen(ifp,-1);
d1416 4
a1419 4
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if(SGI(ifp)->mi_doublebuffer){
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		}
d1423 2
a1424 3
		/* unattach context for other threads to use */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
d1426 1
d1428 1
a1428 1
	return(0);
d1431 1
d1438 1
a1438 1
	if(CJDEBUG) printf("entering ogl_getview\n");
d1440 4
a1443 4
	*xcenter = ifp->if_xcenter;
	*ycenter = ifp->if_ycenter;
	*xzoom = ifp->if_xzoom;
	*yzoom = ifp->if_yzoom;
d1445 1
a1445 1
	return(0);
d1449 1
d1451 47
a1497 11
ogl_read(FBIO *ifp, int x, int y, unsigned char *pixelp, int count) /*read count pixels into pixelp starting at x,y*/
    	     
   	     
             	        
   	      
{
	register short		scan_count;	/* # pix on this scanline */
	register unsigned char	*cp;
	int			ret;
	register unsigned int	n;
	register struct ogl_pixel	*oglp;
a1498 1
	if(CJDEBUG) printf("entering ogl_read\n");
d1500 26
a1525 3
	if( x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
		return(-1);
d1527 2
a1528 2
	ret = 0;
	cp = (unsigned char *)(pixelp);
d1530 3
a1532 3
	while( count )  {
		if( y >= ifp->if_height )
			break;
d1534 2
a1535 26
		if ( count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = count;

		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct ogl_pixel) ];

		n = scan_count;
		while( n )  {
			cp[RED] = oglp->red;
			cp[GRN] = oglp->green;
			cp[BLU] = oglp->blue;
			oglp++;
			cp += 3;
			n--;
		}
		ret += scan_count;
		count -= scan_count;
		x = 0;
		/* Advance upwards */
		if( ++y >= ifp->if_height )
			break;
	}
	return(ret);
}
d1537 46
d1584 2
d1587 3
a1589 94
_LOCAL_ int
ogl_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, int count) /*write count pixels from pixelp starting at xstart,ystart*/
    	     
   	               
                   	        
   	      
{
	register short		scan_count;	/* # pix on this scanline */
	register unsigned char	*cp;
	int			ret;
	int			ybase;
	register int		pix_count;	/* # pixels to send */
	register int		x;
	register int		y;

	if(CJDEBUG) printf("entering ogl_write\n");

	/* fast exit cases */
	if( (pix_count = count) == 0 )
		return 0;	/* OK, no pixels transferred */
	if( pix_count < 0 )
		return -1;	/* ERROR */

	x = xstart;
	ybase = y = ystart;

	if( x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
		return(-1);

	ret = 0;
	cp = (unsigned char *)(pixelp);

	while( pix_count )  {
		register unsigned int n;
		register struct ogl_pixel	*oglp;

		if( y >= ifp->if_height )
			break;

		if ( pix_count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = pix_count;

		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct ogl_pixel) ];

		n = scan_count;
		if( (n & 3) != 0 )  {
			/* This code uses 60% of all CPU time */
			while( n )  {
				/* alpha channel is always zero */
				oglp->red   = cp[RED];
				oglp->green = cp[GRN];
				oglp->blue  = cp[BLU];
				oglp++;
				cp += 3;
				n--;
			}
		} else {
			while( n )  {
				/* alpha channel is always zero */
				oglp[0].red   = cp[RED+0*3];
				oglp[0].green = cp[GRN+0*3];
				oglp[0].blue  = cp[BLU+0*3];
				oglp[1].red   = cp[RED+1*3];
				oglp[1].green = cp[GRN+1*3];
				oglp[1].blue  = cp[BLU+1*3];
				oglp[2].red   = cp[RED+2*3];
				oglp[2].green = cp[GRN+2*3];
				oglp[2].blue  = cp[BLU+2*3];
				oglp[3].red   = cp[RED+3*3];
				oglp[3].green = cp[GRN+3*3];
				oglp[3].blue  = cp[BLU+3*3];
				oglp += 4;
				cp += 3*4;
				n -= 4;
			}
		}
		ret += scan_count;
		pix_count -= scan_count;
		x = 0;
		if( ++y >= ifp->if_height )
			break;
	}

	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return ret;

	if (multiple_windows) {
		if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
			fb_log("Warning, ogl_write: glXMakeCurrent unsuccessful.\n");
		}
d1591 1
d1593 1
a1593 1
	if(!OGL(ifp)->use_ext_ctrl){
d1595 22
a1616 10
		/* "Fast path" case for writes of less than one scanline.
		 * The assumption is that there will be a lot of short
		 * writes, and it's best just to ignore the backbuffer
		 */
		if ( SGI(ifp)->mi_doublebuffer ) {
			/* "turn off" doublebuffering*/
			SGI(ifp)->mi_doublebuffer = 0;
			glDrawBuffer(GL_FRONT);
		}
		ogl_xmit_scanlines( ifp, ybase, 1, xstart, count );
d1618 1
a1618 14
			/* repaint one scanline from backbuffer */
			backbuffer_to_screen(ifp,ybase);
		}
	} else {
		/* Normal case -- multi-pixel write */
		if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
			ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		}
		else { /* just write rectangle */
			ogl_xmit_scanlines( ifp, ybase, y-ybase, 0, ifp->if_width );
			if (OGL(ifp)->copy_flag){
				backbuffer_to_screen(ifp,-1);
			}
d1620 1
d1624 2
a1625 3
		/* unattach context for other threads to use */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
d1627 1
d1629 1
a1629 1
	return(ret);
d1643 25
a1667 26
	register int		x;
	register int		y;
	register unsigned char	*cp;
	register struct ogl_pixel	*oglp;

	if(CJDEBUG) printf("entering ogl_writerect\n");


	if( width <= 0 || height <= 0 )
		return(0);  /* do nothing */
	if( xmin < 0 || xmin+width > ifp->if_width ||
	    ymin < 0 || ymin+height > ifp->if_height )
		return(-1); /* no can do */

	cp = (unsigned char *)(pp);
	for( y = ymin; y < ymin+height; y++ )  {
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct ogl_pixel) ];
		for( x = xmin; x < xmin+width; x++ )  {
			/* alpha channel is always zero */
			oglp->red   = cp[RED];
			oglp->green = cp[GRN];
			oglp->blue  = cp[BLU];
			oglp++;
			cp += 3;
		}
d1669 1
d1671 2
a1672 2
	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return width*height;
d1674 1
a1674 1
	if(!OGL(ifp)->use_ext_ctrl){
d1676 1
a1676 1
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
d1678 1
a1678 1
	}
d1682 2
a1683 2
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
d1686 4
a1689 4
		ogl_xmit_scanlines( ifp, ymin, height, xmin, width );
		if (OGL(ifp)->copy_flag){
			backbuffer_to_screen(ifp,-1);
		}
d1693 2
a1694 3
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
d1696 1
d1698 1
a1698 1
	return(width*height);
d1712 25
a1736 26
	register int		x;
	register int		y;
	register unsigned char	*cp;
	register struct ogl_pixel	*oglp;

	if(CJDEBUG) printf("entering ogl_bwwriterect\n");


	if( width <= 0 || height <= 0 )
		return(0);  /* do nothing */
	if( xmin < 0 || xmin+width > ifp->if_width ||
	    ymin < 0 || ymin+height > ifp->if_height )
		return(-1); /* no can do */

	cp = (unsigned char *)(pp);
	for( y = ymin; y < ymin+height; y++ )  {
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct ogl_pixel) ];
		for( x = xmin; x < xmin+width; x++ )  {
			register int	val;
			/* alpha channel is always zero */
			oglp->red   = (val = *cp++);
			oglp->green = val;
			oglp->blue  = val;
			oglp++;
		}
d1738 1
d1740 2
a1741 2
	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return width*height;
d1743 1
a1743 1
	if(!OGL(ifp)->use_ext_ctrl){
d1745 1
a1745 1
	if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
d1747 1
a1747 1
	}
d1751 2
a1752 2
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
d1755 4
a1758 4
		ogl_xmit_scanlines( ifp, ymin, height, xmin, width );
		if (OGL(ifp)->copy_flag){
			backbuffer_to_screen(ifp,-1);
		}
d1762 2
a1763 3
	/* unattach context for other threads to use */
	glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
d1765 1
d1767 1
a1767 1
	return(width*height);
d1775 1
a1775 1
	register int i;
d1777 1
a1777 1
	if(CJDEBUG) printf("entering ogl_rmap\n");
d1779 7
a1785 7
	/* Just parrot back the stored colormap */
	for( i = 0; i < 256; i++)  {
		cmp->cm_red[i]   = CMR(ifp)[i]<<8;
		cmp->cm_green[i] = CMG(ifp)[i]<<8;
		cmp->cm_blue[i]  = CMB(ifp)[i]<<8;
	}
	return(0);
d1798 1
a1798 1
	register int i;
d1800 6
a1805 6
	for( i=0; i<256; i++ )  {
		if( CMR(ifp)[i] != i )  return(0);
		if( CMG(ifp)[i] != i )  return(0);
		if( CMB(ifp)[i] != i )  return(0);
	}
	return(1);
d1814 1
a1814 1
	register int	i;
d1816 5
a1820 5
	for( i = 0; i < 256; i++)  {
		CMR(ifp)[i] = i;
		CMG(ifp)[i] = i;
		CMB(ifp)[i] = i;
	}
d1829 2
a1830 2
	register int	i;
	int		prev;	/* !0 = previous cmap was non-linear */
d1832 1
a1832 1
	if(CJDEBUG) printf("entering ogl_wmap\n");
d1834 8
a1841 9
	prev = SGI(ifp)->mi_cmap_flag;
	if ( cmp == COLORMAP_NULL)  {
		ogl_cminit( ifp );
	} else {
		for(i = 0; i < 256; i++)  {
			CMR(ifp)[i] = cmp-> cm_red[i]>>8;
			CMG(ifp)[i] = cmp-> cm_green[i]>>8; 
			CMB(ifp)[i] = cmp-> cm_blue[i]>>8;
		}
d1843 2
a1844 1
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
d1847 1
a1847 1
	if(!OGL(ifp)->use_ext_ctrl){
d1849 2
a1850 2
		/* if current and previous maps are linear, return */
		if( SGI(ifp)->mi_cmap_flag == 0 && prev == 0 )  return(0);
d1852 1
a1852 1
		/* Software color mapping, trigger a repaint */
d1854 1
a1854 1
		if (multiple_windows) {
d1856 1
a1856 2
			fb_log("Warning, ogl_wmap: glXMakeCurrent unsuccessful.\n");
		}
d1858 1
d1860 7
a1866 7
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if(SGI(ifp)->mi_doublebuffer){
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		} else if (OGL(ifp)->copy_flag) {
			backbuffer_to_screen(ifp,-1);
		}
		if (multiple_windows) {
d1869 1
a1869 1
		}
d1871 2
a1872 2
		/* Send color map to hardware */
		/* This code has yet to be tested */
d1874 8
a1881 9
	    	for (i = 0; i < 256; i++) {
	    		color_cell[i].pixel = i;
	    		color_cell[i].red = CMR(ifp)[i];
	    		color_cell[i].green = CMG(ifp)[i];
	    		color_cell[i].blue = CMB(ifp)[i];
	    		color_cell[i].flags = DoRed | DoGreen | DoBlue;
	    	}
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell, 256);
	}
d1883 1
d1885 1
a1885 1
	return(0);
d1894 15
a1908 2
	struct	modeflags *mfp;
	XVisualInfo *visual = OGL(ifp)->vip;
d1910 5
a1914 18
	fb_log( "Description: %s\n", ifp->if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width height: %d %d\n",
		ifp->if_max_width,
		ifp->if_max_height );
	fb_log( "Default width height: %d %d\n",
		ifp->if_width,
		ifp->if_height );
	fb_log( "Usage: /dev/ogl[option letters]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}

	fb_log( "\nCurrent internal state:\n");
	fb_log( "	mi_doublebuffer=%d\n", SGI(ifp)->mi_doublebuffer );
	fb_log( "	mi_cmap_flag=%d\n", SGI(ifp)->mi_cmap_flag );
	fb_log( "	ogl_nwindows=%d\n", ogl_nwindows );
	fb_log( "	multiple_windows=%d\n", multiple_windows );
d1916 1
a1916 1
	fb_log("X11 Visual:\n");
d1918 1
a1918 1
	switch(visual->class) {
d1920 4
a1923 4
		fb_log("\tDirectColor: Alterable RGB maps, pixel RGB subfield indicies\n");
		fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
		       visual->green_mask, visual->blue_mask);
		break;
d1925 4
a1928 4
		fb_log("\tTrueColor: Fixed RGB maps, pixel RGB subfield indicies\n");
		fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
		       visual->green_mask, visual->blue_mask);
		break;
d1930 2
a1931 2
		fb_log("\tPseudoColor: Alterable RGB maps, single index\n");
		break;
d1933 2
a1934 2
		fb_log("\tStaticColor: Fixed RGB maps, single index\n");
		break;
d1936 2
a1937 2
		fb_log("\tGrayScale: Alterable map (R=G=B), single index\n");
		break;
d1939 2
a1940 2
		fb_log("\tStaticGray: Fixed map (R=G=B), single index\n");
		break;
d1942 10
a1951 10
		fb_log("\tUnknown visual class %d\n",
		       visual->class);
		break;
	}
	fb_log("\tColormap Size: %d\n", visual->colormap_size);
	fb_log("\tBits per RGB: %d\n", visual->bits_per_rgb);
	fb_log("\tscreen: %d\n", visual->screen);
	fb_log("\tdepth (total bits per pixel): %d\n", visual->depth);
	if( visual->depth < 24 )
		fb_log("\tWARNING: unable to obtain full 24-bits of color, image will be quantized.\n");
d1953 1
a1953 1
	return 0;
d1960 1
a1960 1
  return 0;
d1967 50
a2016 55
  if(mode){
    register int xx, xy;
    register int delta;

    /* If we don't have a cursor, create it */
    if (!OGL(ifp)->cursor) {
      XSetWindowAttributes xswa;
      XColor rgb_db_def;
      XColor bg, bd;

      XAllocNamedColor(OGL(ifp)->dispp, OGL(ifp)->xcmap, "black",
		       &rgb_db_def, &bg);
      XAllocNamedColor(OGL(ifp)->dispp, OGL(ifp)->xcmap, "white",
		       &rgb_db_def, &bd);
      xswa.background_pixel = bg.pixel;
      xswa.border_pixel = bd.pixel;
      xswa.colormap = OGL(ifp)->xcmap;
      xswa.save_under = True;

      OGL(ifp)->cursor = XCreateWindow(OGL(ifp)->dispp, OGL(ifp)->wind,
				     0, 0, 4, 4, 2, OGL(ifp)->vip->depth, InputOutput,
				     OGL(ifp)->vip->visual, CWBackPixel | CWBorderPixel |
				     CWSaveUnder | CWColormap, &xswa);
    }

    delta = ifp->if_width/ifp->if_xzoom/2;
    xx = x - (ifp->if_xcenter - delta);
    xx *= ifp->if_xzoom;
    xx += ifp->if_xzoom/2;  /* center cursor */

    delta = ifp->if_height/ifp->if_yzoom/2;
    xy = y - (ifp->if_ycenter - delta);
    xy *= ifp->if_yzoom;
    xy += ifp->if_yzoom/2;  /* center cursor */
    xy = OGL(ifp)->win_height - xy;

    /* Move cursor into place; make it visible if it isn't */
    XMoveWindow(OGL(ifp)->dispp, OGL(ifp)->cursor, xx - 4, xy - 4);

    /* if cursor window is currently not mapped, map it */
    if (!ifp->if_cursmode)
      XMapRaised(OGL(ifp)->dispp, OGL(ifp)->cursor);
  } else {
    /* If we have a cursor and it's mapped, unmap it */
    if (OGL(ifp)->cursor && ifp->if_cursmode)
      XUnmapWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);
  }

  /* Without this flush, cursor movement is sluggish */
  XFlush(OGL(ifp)->dispp);

  /* Update position of cursor */
  ifp->if_cursmode = mode;
  ifp->if_xcurs = x;
  ifp->if_ycurs = y;
d2018 6
a2023 1
  return(0);
d2031 14
a2044 15
	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )  {
		if (multiple_windows) {
			if (glXMakeCurrent(OGL(ifp)->dispp,OGL(ifp)->wind,OGL(ifp)->glxc)==False){
				fb_log("Warning, ogl_flush: glXMakeCurrent unsuccessful.\n");
			}
		}
		/* Send entire in-memory buffer to the screen, all at once */
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if ( SGI(ifp)->mi_doublebuffer) {
			glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
		} else {
			if (OGL(ifp)->copy_flag){
				backbuffer_to_screen(ifp,-1);
			}
		}
d2046 4
a2049 3
	XFlush(OGL(ifp)->dispp);
	glFlush();
	return(0);
d2055 1
a2055 1
FBIO *ifp;
d2057 1
a2057 1
	return(0);
d2077 30
a2106 3
	register struct ogl_clip *clp;
	register int	i;
	double pixels;
d2108 3
a2110 1
	clp = &(OGL(ifp)->clip);
d2112 17
a2128 47
	i = OGL(ifp)->vp_width/(2*ifp->if_xzoom);
	clp->xscrmin = ifp->if_xcenter - i;
	i = OGL(ifp)->vp_width/ifp->if_xzoom;
	clp->xscrmax = clp->xscrmin + i;
	pixels = (double) i;
	clp->oleft = ((double) clp->xscrmin) - 0.25*pixels/((double) OGL(ifp)->vp_width);
	clp->oright = clp->oleft + pixels;

	i = OGL(ifp)->vp_height/(2*ifp->if_yzoom);
	clp->yscrmin = ifp->if_ycenter - i;
	i = OGL(ifp)->vp_height/ifp->if_yzoom;
	clp->yscrmax = clp->yscrmin + i;
	pixels = (double) i;
	clp->obottom = ((double) clp->yscrmin) - 0.25*pixels/((double) OGL(ifp)->vp_height);
	clp->otop = clp->obottom + pixels;

	clp->xpixmin = clp->xscrmin;
	clp->xpixmax = clp->xscrmax;
	clp->ypixmin = clp->yscrmin;
	clp->ypixmax = clp->yscrmax;

	if( clp->xpixmin < 0 )  {
		clp->xpixmin = 0;
	}

	if( clp->ypixmin < 0 )  {
		clp->ypixmin = 0;
	}

	/* In copy mode, the backbuffer copy image is limited
	 * to the viewport size; use that for clipping.
	 * Otherwise, use size of framebuffer memory segment
	 */
	if (OGL(ifp)->copy_flag) {
		if( clp->xpixmax > OGL(ifp)->vp_width-1 )  {
			clp->xpixmax = OGL(ifp)->vp_width-1;
		}
		if( clp->ypixmax > OGL(ifp)->vp_height-1 )  {
			clp->ypixmax = OGL(ifp)->vp_height-1;
		}
	} else {
		if( clp->xpixmax > ifp->if_width-1 )  {
			clp->xpixmax = ifp->if_width-1;
		}
		if( clp->ypixmax > ifp->if_height-1 )  {
			clp->ypixmax = ifp->if_height-1;
		}
d2130 1
d2143 1
a2143 1
  XEvent event;
d2145 30
a2174 29
  while (XCheckWindowEvent(OGL(ifp)->dispp, OGL(ifp)->wind,
			   OGL(ifp)->event_mask, &event)) {
    switch (event.type) {
    case Expose:
      if(!OGL(ifp)->use_ext_ctrl)
	expose_callback(ifp, &event);
      break;
    case ButtonPress:
      break;
    case ButtonRelease:
      OGL(ifp)->alive = 0;
      break;
    case KeyPress:
      break;
    case KeyRelease:
      OGL(ifp)->alive = 0;
      break;
    case ConfigureNotify:
      {
	XConfigureEvent *conf = (XConfigureEvent *)&event;

	if(conf->width == OGL(ifp)->win_width &&
	   conf->height == OGL(ifp)->win_height)
	  return;

	ogl_configureWindow(ifp, conf->width, conf->height);
      }
    default:
      break;
a2175 1
  }
d2181 2
a2182 2
	XWindowAttributes xwa;
	struct ogl_clip *clp;
d2184 1
a2184 1
	if( CJDEBUG ) fb_log("entering expose_callback()\n");
d2187 4
a2190 5
	if( multiple_windows || OGL(ifp)->firstTime ) {
		if( glXMakeCurrent(OGL(ifp)->dispp, OGL(ifp)->wind,
				   OGL(ifp)->glxc) == False) {
			fb_log("Warning, libfb/expose_callback: glXMakeCurrent unsuccessful.\n");
		}
d2192 1
d2194 2
a2195 2
	if( OGL(ifp)->firstTime ) {
		OGL(ifp)->firstTime = 0;
d2197 7
a2203 3
		/* just in case the configuration is double buffered but
		 * we want to pretend it's not
		 */
d2205 3
a2207 3
		if( !SGI(ifp)->mi_doublebuffer ) {
			glDrawBuffer(GL_FRONT);
		}
d2209 14
a2222 3
		if( (ifp->if_mode & MODE_4MASK) == MODE_4NODITH ) {
			glDisable(GL_DITHER);
		}
d2224 3
a2226 14
		/* set copy mode if possible and requested */
		if( SGI(ifp)->mi_doublebuffer && 
		    ((ifp->if_mode & MODE_11MASK)==MODE_11COPY) ) {
			/* Copy mode only works if there are two 
			 * buffers to use. It conflicts with
			 * double buffering
			 */
			OGL(ifp)->copy_flag = 1;
			SGI(ifp)->mi_doublebuffer = 0;
			OGL(ifp)->front_flag = 1;
			glDrawBuffer(GL_FRONT);
		} else {
			OGL(ifp)->copy_flag = 0;
		}
d2228 4
a2231 8
		XGetWindowAttributes(OGL(ifp)->dispp, OGL(ifp)->wind, &xwa);
		OGL(ifp)->win_width = xwa.width;
		OGL(ifp)->win_height = xwa.height;

		/* clear entire window */
		glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);
		glClearColor(0,0,0,0);
		glClear(GL_COLOR_BUFFER_BIT);
d2233 47
a2279 47
		/* Set normal viewport size to minimum of actual window
		 * size and requested framebuffer size
		 */
		OGL(ifp)->vp_width = (OGL(ifp)->win_width < ifp->if_width) ?
				OGL(ifp)->win_width : ifp->if_width;
		OGL(ifp)->vp_height = (OGL(ifp)->win_height < ifp->if_height) ?
				OGL(ifp)->win_height : ifp->if_height;
		ifp->if_xcenter = OGL(ifp)->vp_width/2;
		ifp->if_ycenter = OGL(ifp)->vp_height/2;

		/* center viewport in window */
		SGI(ifp)->mi_xoff=(OGL(ifp)->win_width-OGL(ifp)->vp_width)/2;
		SGI(ifp)->mi_yoff=(OGL(ifp)->win_height-OGL(ifp)->vp_height)/2;
		glViewport(SGI(ifp)->mi_xoff,
			   SGI(ifp)->mi_yoff,
			   OGL(ifp)->vp_width,
			   OGL(ifp)->vp_height);
		/* initialize clipping planes and zoom */
		ogl_clipper(ifp);
		clp = &(OGL(ifp)->clip);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop,
				-1.0,1.0);
		glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
	} else if( (OGL(ifp)->win_width > ifp->if_width) || 
		   (OGL(ifp)->win_height > ifp->if_height) ) {
		/* clear whole buffer if window larger than framebuffer */
	 	if( OGL(ifp)->copy_flag && !OGL(ifp)->front_flag ) {
	 		glDrawBuffer(GL_FRONT);
			glViewport(0, 0, OGL(ifp)->win_width,
				   OGL(ifp)->win_height);      
			glClearColor(0,0,0,0);
			glClear(GL_COLOR_BUFFER_BIT);
	 		glDrawBuffer(GL_BACK);
	 	} else {
			glViewport(0, 0, OGL(ifp)->win_width,
				   OGL(ifp)->win_height);      
			glClearColor(0,0,0,0);
			glClear(GL_COLOR_BUFFER_BIT);
	 	}
	 	/* center viewport */
		glViewport(SGI(ifp)->mi_xoff,
			   SGI(ifp)->mi_yoff,
			   OGL(ifp)->vp_width,
			   OGL(ifp)->vp_height);
	}
d2281 7
a2287 7
	/* repaint entire image */
	ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	if( SGI(ifp)->mi_doublebuffer ) {
		glXSwapBuffers( OGL(ifp)->dispp, OGL(ifp)->wind);
	} else if( OGL(ifp)->copy_flag ) {
		backbuffer_to_screen(ifp,-1);
	}
d2289 13
a2301 13
	if( CJDEBUG ) {
		int dbb,db,view[4],getster,getaux;
		glGetIntegerv(GL_VIEWPORT, view);
		glGetIntegerv(GL_DOUBLEBUFFER,&dbb);
		glGetIntegerv(GL_DRAW_BUFFER,&db);
		fb_log("Viewport: x %d y %d width %d height %d\n",view[0],
		       view[1],view[2],view[3]);
		fb_log("expose: double buffered: %d, draw buffer %d\n",dbb,db);
		fb_log("front %d\tback%d\n",GL_FRONT,GL_BACK);
		glGetIntegerv(GL_STEREO,&getster);
		glGetIntegerv(GL_AUX_BUFFERS,&getaux);
		fb_log("double %d, stereo %d, aux %d\n",dbb,getster,getaux);
	}
d2303 4
a2306 4
	if( multiple_windows ) {
		/* unattach context for other threads to use */
		glXMakeCurrent(OGL(ifp)->dispp,None,NULL);
	}
d2308 2
a2309 2
	XFlush(OGL(ifp)->dispp);
	glFlush();
d2316 15
a2330 15
  if(width == OGL(ifp)->win_width &&
     height == OGL(ifp)->win_height)
    return;

  ifp->if_width = ifp->if_max_width = width;
  ifp->if_height = ifp->if_max_height = height;

  OGL(ifp)->win_width = OGL(ifp)->vp_width = width;
  OGL(ifp)->win_height = OGL(ifp)->vp_height = height;

  ifp->if_zoomflag = 0;
  ifp->if_xzoom = 1;
  ifp->if_yzoom = 1;
  ifp->if_xcenter = width/2;
  ifp->if_ycenter = height/2;
d2332 2
a2333 2
  ogl_getmem(ifp);
  ogl_clipper(ifp);
d2345 2
a2346 2
	int xbytes;
	int i,j,k;
d2348 2
a2349 2
	if( (xbytes = xbits /8) * 8 != xbits)
		xbytes++;
d2351 3
a2353 4
	for (j=0, k=(ybits-1)*xbytes; j < ybits*xbytes; j+=xbytes, k-=xbytes){
		for (i=0; i < xbytes; i++){
			dst[j+i] = src[k+i];
		}
d2355 1
d2367 1
a2367 1
	struct ogl_clip *clp;
d2369 7
a2375 7
	if (!(OGL(ifp)->front_flag)){
		OGL(ifp)->front_flag = 1;
		glDrawBuffer(GL_FRONT);
		glMatrixMode(GL_PROJECTION);
		glPopMatrix();
		glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
	}
d2377 18
a2394 1
	clp = &(OGL(ifp)->clip);
d2396 8
a2403 28
	if (one_y > clp->ypixmax) {
		return;
	} else if (one_y < 0) { /* do whole visible screen */

		/* Blank out area left of image */
		glColor3b( 0, 0, 0 );
		if( clp->xscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* Blank out area below image */
		if( clp->yscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			CLIP_XTRA);

		/* We are in copy mode, so we use vp_width rather
		 * than if_width
		 */
		/* Blank out area right of image */
		if( clp->xscrmax >= OGL(ifp)->vp_width )  glRecti(
			ifp->if_width - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);
d2405 25
a2429 26
		/* Blank out area above image */
		if( clp->yscrmax >= OGL(ifp)->vp_height )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			OGL(ifp)->vp_height - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* copy image from backbuffer */
		glRasterPos2i(clp->xpixmin,clp->ypixmin);
		glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
			SGI(ifp)->mi_yoff + clp->ypixmin,
			clp->xpixmax - clp->xpixmin +1,
			clp->ypixmax - clp->ypixmin +1,
			GL_COLOR);


	} else if (one_y < clp->ypixmin) {
		return;
	} else { /* draw one scanline */
		glRasterPos2i(clp->xpixmin,one_y);
		glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
			SGI(ifp)->mi_yoff + one_y,
			clp->xpixmax - clp->xpixmin +1,
			1,
			GL_COLOR);
	}
d2459 1
a2459 1
	XVisualInfo *vip, *vibase, *maxvip, template;
d2461 4
a2464 4
	int good[NGOOD];
	int num, i, j;
	int m_hard_cmap, m_sing_buf, m_doub_buf;
	int use, rgba, dbfr;
d2466 3
a2468 3
	m_hard_cmap = ((ifp->if_mode & MODE_7MASK)==MODE_7NORMAL);
	m_sing_buf  = ((ifp->if_mode & MODE_9MASK)==MODE_9SINGLEBUF);
	m_doub_buf =  !m_sing_buf;
d2470 1
a2470 1
	bzero((void *)&template, sizeof(XVisualInfo));
d2472 41
a2512 41
	/* get a list of all visuals on this display */	
	vibase = XGetVisualInfo(OGL(ifp)->dispp, 0, &template, &num);
	while (1) {

		/* search for all visuals matching current criteria */
		for (i=0, j=0, vip=vibase; i<num; i++, vip++){
			/* requirements */
			glXGetConfig(OGL(ifp)->dispp,vip,GLX_USE_GL,&use);
			if( !use)
				continue;
			glXGetConfig(OGL(ifp)->dispp,vip,GLX_RGBA,&rgba);
			if (!rgba)
				continue;
			/* desires */
			/* X_CreateColormap needs a DirectColor visual */
			/* There should be some way of handling this with TrueColor,
			 * for example:
			    visual id:    0x50
			    class:    TrueColor
			    depth:    24 planes
			    available colormap entries:    256 per subfield
			    red, green, blue masks:    0xff0000, 0xff00, 0xff
			    significant bits in color specification:    8 bits
			 */
			if ( (m_hard_cmap) && (vip->class!=DirectColor))
				continue;
			if ( (m_hard_cmap) && (vip->colormap_size<256))
				continue;
			glXGetConfig(OGL(ifp)->dispp,vip,GLX_DOUBLEBUFFER,&dbfr);
			if ( (m_doub_buf) && (!dbfr) )
				continue;
			if ( (m_sing_buf) && (dbfr) )
				continue;

			/* this visual meets criteria */
			if( j >= NGOOD-1 )  {
				fb_log("ogl_open:  More than %d candidate visuals!\n", NGOOD);
				break;
			}
			good[j++] = i;
		}
d2514 15
a2528 15
		/* from list of acceptable visuals,
		 * choose the visual with the greatest depth */
		if (j>=1){
			maxvip = vibase + good[0];
			for (i=1; i<j; i++) {
				vip = vibase + good[i];
				if (vip->depth >= maxvip->depth) {
					maxvip = vip;
				}
			}
			/* set flags and return choice */
			OGL(ifp)->soft_cmap_flag = !m_hard_cmap;
			SGI(ifp)->mi_doublebuffer = m_doub_buf;
			return (maxvip);
		}
d2530 21
a2550 21
		/* if no success at this point,
		 * relax one of the criteria and try again.
		 */
		if (m_hard_cmap) {
			/* relax hardware colormap requirement */
			m_hard_cmap = 0;
			fb_log("ogl_open: hardware colormapping not available. Using software colormap.\n");
		} else if (m_sing_buf) {
			/* relax single buffering requirement.
			 * no need for any warning - we'll just use 
			 * the front buffer 
			 */
			m_sing_buf = 0;
		} else if (m_doub_buf) {
			/* relax double buffering requirement. */
			m_doub_buf = 0;
			fb_log("ogl_open: double buffering not available. Using single buffer.\n");
		} else {
			/* nothing else to relax */
			return(NULL);
		}
d2552 1
a2552 1
	}
d2559 7
a2565 2
  int mm;
  struct ogl_clip *clp;
d2567 4
a2570 9
  if(w < 0){
    w = -w;
    x -= w;
  }

  if(h < 0){
    h = -h;
    y -= h;
  }
d2573 4
a2576 4
  if(glIsEnabled(GL_DEPTH_TEST)){
    glDisable(GL_DEPTH_TEST);
    dflag = 1;
  }
d2579 4
a2582 4
  glGetIntegerv(GL_MATRIX_MODE, &mm);
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
d2585 1
a2585 1
  glOrtho(0.0, OGL(ifp)->win_width, 0.0, OGL(ifp)->win_height, -1.0, 1.0);
d2587 4
a2590 4
  ogl_clipper(ifp);
  clp = &(OGL(ifp)->clip);
  glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop, -1.0, 1.0);
  glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
d2592 3
a2594 3
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
d2596 1
a2596 1
  glTranslatef(0.0, 0.0, -1.0);
d2598 7
a2604 7
  glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);
  ogl_xmit_scanlines(ifp, y, h, x, w);
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode(mm);
d2607 2
a2608 2
  if(dflag)
    glEnable(GL_DEPTH_TEST);
d2611 2
a2612 2
  glFlush();
  return 0;
@


14.9
log
@make sure the irix define is defined before parsing a value via #if
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.8 2005/04/25 22:42:46 brlcad Exp $ (ARL)";
d506 1
a506 1
	fb_log("ogl_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_4d.c for details\n");
@


14.8
log
@make sure the IRIX preprocessor symbol is even defined before jumping into an if IRIX < value section or we can get in when we shouldn't
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.7 2005/03/20 00:19:56 brlcad Exp $ (ARL)";
a416 7
#if 0
	if( sizeof(struct ogl_pixel) != sizeof(long) )  {
		fb_log("Warning, ogl_pixel=%d, long=%d bytes\n",
			sizeof(struct ogl_pixel), sizeof(long) );
	}
#endif

@


14.7
log
@bye bye USE_MESA_GL .. needs some good testing on the ogl interface
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.6 2005/01/30 20:30:48 brlcad Exp $ (ARL)";
d410 1
a410 1
#if IRIX < 5
d470 1
a470 1
#if IRIX < 5
@


14.6
log
@update copyright to 2005
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl.c,v 14.5 2004/12/21 07:18:58 morrison Exp $ (ARL)";
a48 2


d51 1
a51 1
#include <string.h>
d53 1
a53 1
#include <strings.h>
d64 6
a69 2
#include <GL/glx.h>
#include <GL/gl.h>
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ogl.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a41 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ogl.c,v 14.3 2004/12/21 05:45:22 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ogl.c,v 14.2 2004/12/21 03:58:27 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ogl.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			I F _ O G L . C
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ogl.c,v 1.4 2004/09/03 23:30:57 morrison Exp $ (ARL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ogl.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (ARL)";
d2611 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_ogl.c,v 1.2 2004/06/08 22:04:21 morrison Exp $ (ARL)";
d35 1
a35 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header$ (ARL)";
d30 1
a30 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d27 1
a27 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_ogl.c,v 1.39 2004/05/10 15:30:45 erikg Exp $ (ARL)";
a55 1
#include "externs.h"
@

