head	14.27;
access;
symbols
	rel-7-10-4:14.23.2.1
	STABLE:14.23.0.2
	stable-branch:14.6
	rel-7-10-2:14.22
	rel-7-10-0:14.21
	rel-7-8-4:14.17
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.7.2.1
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.27
date	2007.12.19.22.41.58;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.11.06.20.37.30;	author bob1961;	state Exp;
branches;
next	14.25;

14.25
date	2007.10.26.21.51.26;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.09.15.16.23.10;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.08.18.03.15.11;	author brlcad;	state Exp;
branches
	14.23.2.1;
next	14.22;

14.22
date	2007.07.26.01.13.56;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.08.24.20.51.34;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.08.08.06.47.05;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.07.17.55.16;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.07.09.19.17.16;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.02.27.08.31.53;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.22.10.37.18;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.12.29.08.16.08;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.12.23.21.26.30;	author bob1961;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.30.12;	author lbutler;	state Exp;
branches
	14.7.2.1
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.53;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.58.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.15.06.40.51;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.21;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.43;	author morrison;	state Exp;
branches;
next	;

14.7.2.1
date	2005.09.08.15.30.23;	author bob1961;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.23.2.1
date	2007.09.28.14.07.48;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.27
log
@ws and style cleanup on rem_open, init vars
@
text
@/*                     I F _ R E M O T E . C
 * BRL-CAD
 *
 * Copyright (c) 1986-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup if */
/** @@{ */
/** @@file if_remote.c
 *
 *  Remote libfb interface.
 *
 *  Duplicates the functions in libfb via communication
 *  with a remote server (fbserv).
 *
 *  Note that internal errors are returned as -2 and below, because
 *  most remote errors (unpacked by fbgetlong) will be -1
 *  (although they could be anything).
 *
 *  Authors -
 *	Phillip Dykstra
 *	Gary S. Moss
 *
 */
/** @@} */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.26 2007/11/06 20:37:30 bob1961 Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef HAVE_WRITEV
#  include <sys/uio.h>		/* for struct iovec */
#endif
#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>		/* for htons(), etc */
#endif
#ifdef HAVE_SYS_SOCKET_H
#  include <sys/socket.h>
#endif

#include "machine.h"
#include "pkg.h"
#include "fb.h"
#include "fbmsg.h"


#define NET_LONG_LEN	4	/* # bytes to network long */

#define MAX_HOSTNAME	128
#define	PCP(ptr)	((struct pkg_conn *)((ptr)->u1.p))
#define	PCPL(ptr)	((ptr)->u1.p)	/* left hand side version */

/* Package Handlers. */
static void	pkgerror(struct pkg_conn *pcpp, char *buf);	/* error message handler */
static struct pkg_switch pkgswitch[] = {
	{ MSG_ERROR, pkgerror, "Error Message" },
	{ 0, NULL, NULL }
};

HIDDEN int	rem_open(register FBIO *ifp, register char *file, int width, int height),
		rem_close(FBIO *ifp),
		rem_clear(FBIO *ifp, unsigned char *bgpp),
		rem_read(register FBIO *ifp, int x, int y, unsigned char *pixelp, int num),
		rem_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int num),
		rem_rmap(register FBIO *ifp, register ColorMap *cmap),
		rem_wmap(register FBIO *ifp, const ColorMap *cmap),
		rem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		rem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom),
		rem_cursor(FBIO *ifp, int mode, int x, int y),
		rem_getcursor(FBIO *ifp, int *mode, int *x, int *y),
		rem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		rem_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		rem_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		rem_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp),
		rem_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp),
		rem_poll(FBIO *ifp),
		rem_flush(FBIO *ifp),
		rem_free(FBIO *ifp),
		rem_help(FBIO *ifp);

FBIO remote_interface = {
	0,
	rem_open,
	rem_close,
	rem_clear,
	rem_read,
	rem_write,
	rem_rmap,
	rem_wmap,
	rem_view,
	rem_getview,
	rem_setcursor,
	rem_cursor,
	rem_getcursor,
	rem_readrect,
	rem_writerect,
	rem_bwreadrect,
	rem_bwwriterect,
	rem_poll,
	rem_flush,
	rem_free,
	rem_help,
	"Remote Device Interface",	/* should be filled in	*/
	32*1024,				/* " */
	32*1024,				/* " */
	"host:[dev]",
	512,
	512,
	-1,				/* select fd */
	-1,
	1, 1,				/* zoom */
	256, 256,			/* window center */
	0, 0, 0,			/* cursor */
	PIXEL_NULL,
	PIXEL_NULL,
	PIXEL_NULL,
	-1,
	0,
	0L,
	0L,
	0
};

void	pkg_queue(), flush_queue();

/* from getput.c */
extern unsigned short fbgetshort(char *msgp);
extern unsigned long fbgetlong(char *msgp);
extern char *fbputshort(register short unsigned int s, register char *msgp), *fbputlong(register long unsigned int l, register char *msgp);

/* True if the non-null string s is all digits */
HIDDEN int
numeric(register char *s)
{
	if( s == (char *)0 || *s == 0 )
		return	0;

	while( *s ) {
		if( *s < '0' || *s > '9' )
			return	0;
		s++;
	}

	return	1;
}

/*
 *  Break up a file specification into its component parts.
 *  We try to be infinitely flexible here which makes this complicated.
 *  Handle any of the following:
 *
 *	File			Host		Port		Dev
 *	0			localhost	0		NULL
 *	0:[dev]			localhost	0		dev
 *	:0			localhost	0		NULL
 *	host:[dev]		host		remotefb	dev
 *	host:0			host		0		NULL
 *	host:0:[dev]		host		0		dev
 *
 *  Return -1 on error, else 0.
 */
static int
parse_file(char *file, char *host, int *portp, char *device, int length)
		/* input file spec */
		/* host part */
		/* port number */
		/* device part */
{
	int	port;
	char	prefix[256];
	char	*rest;
	char	*dev;
	char	*colon;

	if( numeric(file) ) {
		/* 0 */
		port = atoi(file);
		strncpy( host, "localhost", length );
		dev = "";
		goto done;
	}
	if( (colon = strchr(file, ':')) != NULL ) {
		strncpy( prefix, file, colon-file );
		prefix[colon-file] = '\0';
		rest = colon+1;
		if( numeric(prefix) ) {
			/* 0:[dev] */
			port = atoi(prefix);
			strncpy( host, "localhost", length );
			dev = rest;
			goto done;
		} else {
			/* :[dev] or host:[dev] */
			strncpy( host, prefix, length );
			if( numeric(rest) ) {
				/* :0 or host:0 */
				port = atoi(rest);
				dev = "";
				goto done;
			} else {
				/* check for [host]:0:[dev] */
				if( (colon = strchr(rest, ':')) != NULL ) {
					strncpy( prefix, rest, colon-rest );
					prefix[colon-rest] = '\0';
					if( numeric(prefix) ) {
						port = atoi(prefix);
						dev = colon+1;
						goto done;
					} else {
						/* No port given! */
						dev = rest;
						port = 5558;	/*XXX*/
						goto done;
					}
				} else {
					/* No port given */
					dev = rest;
					port = 5558;		/*XXX*/
					goto done;
				}
			}
		}
	}
	/* bad file spec */
	return	-1;

done:
	/* Default hostname */
	if( strlen(host) == 0 ) {
		strncpy( host, "localhost", length );
	}
	/* Magic port number mapping */
	if( port < 0 )
		return	-1;
	if( port < 1024 )
		port += 5559;
	/*
	 * In the spirit of X, let "unix" be an alias for the "localhost".
	 * Eventually this may invoke UNIX Domain PKG (if we can figure
	 * out what to do about socket pathnames).
	 */
	if( strcmp(host,"unix") == 0 )
		strncpy( host, "localhost", length );

	/* copy out port and device */
	*portp = port;
	strncpy( device, dev, length );

	return( 0 );
}

HIDDEN void
rem_log(char *msg)
{
    fb_log(msg);
}


/*
 * Open a connection to the remotefb.
 * We send NET_LONG_LEN bytes of mode, NET_LONG_LEN bytes of size, then the
 *  devname (or NULL if default).
 */
HIDDEN int
rem_open(register FBIO *ifp, register char *file, int width, int height)
{
    register int	i;
    struct pkg_conn *pc;
    char	buf[128] = {0};
    char	hostname[MAX_HOSTNAME] = {0};
    char	portname[MAX_HOSTNAME] = {0};
    char	device[MAX_HOSTNAME] = {0};
    int	port = 0;
    
    FB_CK_FBIO(ifp);
    
    if (file == NULL || parse_file(file, hostname, &port, device, MAX_HOSTNAME) < 0) {
	/* too wild for our tastes */
	fb_log("rem_open: bad device name \"%s\"\n", file == NULL ? "(null)" : file );
	return -2;
    }
    /*printf("hostname = \"%s\", port = %d, device = \"%s\"\n", hostname, port, device);*/
    
    if (port != 5558) {
	sprintf(portname, "%d", port);
	if ((pc = pkg_open( hostname, portname, 0, 0, 0, pkgswitch, rem_log )) == PKC_ERROR) {
	    fb_log("rem_open: can't connect to fb server on host \"%s\", port \"%s\".\n", hostname, portname );
	    return -3;
	}
    } else {
	pc = pkg_open(hostname, "remotefb", 0, 0, 0, pkgswitch, rem_log);
	if (pc == PKC_ERROR) {
	    pc = pkg_open( hostname, "5558", 0, 0, 0, pkgswitch, rem_log);
	    if (pc == PKC_ERROR) {
		fb_log("rem_open: can't connect to remotefb server on host \"%s\".\n", hostname);
		return -4;
	    }
	}
    }
    PCPL(ifp) = (char *)pc;		/* stash in u1 */
    ifp->if_fd = pc->pkc_fd;		/* unused */
	
#ifdef HAVE_SYS_SOCKET_H
    {
	int	n;
	int	val;
	val = 32767;
	n = setsockopt(pc->pkc_fd, SOL_SOCKET, SO_SNDBUF, (char *)&val, sizeof(val));
	if (n < 0) 
	    perror("setsockopt: SO_SNDBUF");
	
	val = 32767;
	n = setsockopt(pc->pkc_fd, SOL_SOCKET, SO_RCVBUF, (char *)&val, sizeof(val));
	if (n < 0)
	    perror("setsockopt: SO_RCVBUF");
    }
#endif
    
    (void)fbputlong( width, &buf[0*NET_LONG_LEN] );
    (void)fbputlong( height, &buf[1*NET_LONG_LEN] );
    (void) strncpy(&buf[2*NET_LONG_LEN], device, 128-2*NET_LONG_LEN);

    i = strlen(device)+2*NET_LONG_LEN;
    if( pkg_send( MSG_FBOPEN, buf, i, pc ) != i )
	return -5;
    
    /* return code, max_width, max_height, width, height as longs */
    if( pkg_waitfor( MSG_RETURN, buf, sizeof(buf), pc ) < 5*NET_LONG_LEN )
	return -6;

    ifp->if_max_width = fbgetlong( &buf[1*NET_LONG_LEN] );
    ifp->if_max_height = fbgetlong( &buf[2*NET_LONG_LEN] );
    ifp->if_width = fbgetlong( &buf[3*NET_LONG_LEN] );
    ifp->if_height = fbgetlong( &buf[4*NET_LONG_LEN] );

    if( fbgetlong( &buf[0*NET_LONG_LEN] ) != 0 )
	return -7;		/* fail */

    return( 0 );		/* OK */
}

HIDDEN int
rem_close(FBIO *ifp)
{
	char	buf[NET_LONG_LEN+1];

	/* send a close package to remote */
	if( pkg_send( MSG_FBCLOSE, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;
	/*
	 *  When some libfb interfaces with a "linger mode" window
	 *  gets it's fb_close() call here, it closes down the network
	 *  file descriptor, and so the PKG connection is terminated
	 *  at this point.  If there was no transmission error noted
	 *  in the pkg_send() above, but the pkg_waitfor() here gets
	 *  an error, clean up and declare this a successful close()
	 *  operation.
	 */
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )  {
		pkg_close( PCP(ifp) );
		return	0;
	}
	pkg_close( PCP(ifp) );
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

HIDDEN int
rem_free(FBIO *ifp)
{
	char	buf[NET_LONG_LEN+1];

	/* send a free package to remote */
	if( pkg_send( MSG_FBFREE, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	pkg_close( PCP(ifp) );
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

HIDDEN int
rem_clear(FBIO *ifp, unsigned char *bgpp)
{
	char	buf[NET_LONG_LEN+1];

	/* send a clear package to remote */
	if( bgpp == PIXEL_NULL )  {
		buf[0] = buf[1] = buf[2] = 0;	/* black */
	} else {
		buf[0] = (bgpp)[RED];
		buf[1] = (bgpp)[GRN];
		buf[2] = (bgpp)[BLU];
	}
	if( pkg_send( MSG_FBCLEAR, buf, 3, PCP(ifp) ) < 3 )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( buf ) );
}

/*
 *  Send as longs:  x, y, num
 */
HIDDEN int
rem_read(register FBIO *ifp, int x, int y, unsigned char *pixelp, int num)
{
	int	ret;
	char	buf[3*NET_LONG_LEN+1];

	if( num <= 0 )
		return(0);
	/* Send Read Command */
	(void)fbputlong( x, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( num, &buf[2*NET_LONG_LEN] );
	if( pkg_send( MSG_FBREAD, buf, 3*NET_LONG_LEN, PCP(ifp) ) < 3*NET_LONG_LEN )
		return	-2;

	/* Get response;  0 len means failure */
	ret = pkg_waitfor( MSG_RETURN, (char *)pixelp,
		num*sizeof(RGBpixel), PCP(ifp) );
	if( ret <= 0 )  {
		fb_log( "rem_read: read %d at <%d,%d> failed, ret=%d.\n",
			num, x, y, ret );
		return	-3;
	}
	return( ret/sizeof(RGBpixel) );
}

/*
 * As longs, x, y, num
 */
HIDDEN int
rem_write(register FBIO *ifp, int x, int y, const unsigned char *pixelp, int num)
{
	int	ret;
	char	buf[3*NET_LONG_LEN+1];

	if( num <= 0 )  return	num;

	/* Send Write Command */
	(void)fbputlong( x, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( num, &buf[2*NET_LONG_LEN] );
	ret = pkg_2send( MSG_FBWRITE+MSG_NORETURN,
		buf, 3*NET_LONG_LEN,
		(char *)pixelp, num*sizeof(RGBpixel),
		PCP(ifp) );
	ret -= 3*NET_LONG_LEN;
	if( ret < 0 )
		return	-1;	/* Error from libpkg */
	return	ret/sizeof(RGBpixel);
	/* No reading an error return package, sacrificed for speed. */
}

/*
 *			R E M _ R E A D R E C T
 */
HIDDEN int
rem_readrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);
	/* Send Read Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	if( pkg_send( MSG_FBREADRECT, buf, 4*NET_LONG_LEN, PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-2;

	/* Get response;  0 len means failure */
	ret = pkg_waitfor( MSG_RETURN, (char *)pp,
			num*sizeof(RGBpixel), PCP(ifp) );
	if( ret <= 0 )  {
		fb_log( "rem_rectread: read %d at <%d,%d> failed, ret=%d.\n",
			num, xmin, ymin, ret );
		return	-3;
	}
	return( ret/sizeof(RGBpixel) );
}

/*
 *			R E M _ W R I T E R E C T
 */
HIDDEN int
rem_writerect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);

	/* Send Write Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	ret = pkg_2send( MSG_FBWRITERECT+MSG_NORETURN,
		buf, 4*NET_LONG_LEN,
		(char *)pp, num*sizeof(RGBpixel),
		PCP(ifp) );
	ret -= 4*NET_LONG_LEN;
	if( ret < 0 )
		return	-4;	/* Error from libpkg */
	return	ret/sizeof(RGBpixel);
	/* No reading an error return package, sacrificed for speed. */
}

/*
 *			R E M _ B W R E A D R E C T
 *
 *  Issue:  Determining if other end has support for this yet.
 */
HIDDEN int
rem_bwreadrect(FBIO *ifp, int xmin, int ymin, int width, int height, unsigned char *pp)
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);
	/* Send Read Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	if( pkg_send( MSG_FBBWREADRECT, buf, 4*NET_LONG_LEN, PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-2;

	/* Get response;  0 len means failure */
	ret = pkg_waitfor( MSG_RETURN, (char *)pp, num, PCP(ifp) );
	if( ret <= 0 )  {
		fb_log( "rem_bwrectread: read %d at <%d,%d> failed, ret=%d.\n",
			num, xmin, ymin, ret );
		return	-3;
	}
	return ret;
}

/*
 *			R E M _ B W W R I T E R E C T
 */
HIDDEN int
rem_bwwriterect(FBIO *ifp, int xmin, int ymin, int width, int height, const unsigned char *pp)
{
	int	num;
	int	ret;
	char	buf[4*NET_LONG_LEN+1];

	num = width*height;
	if( num <= 0 )
		return(0);

	/* Send Write Command */
	(void)fbputlong( xmin, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ymin, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( width, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[3*NET_LONG_LEN] );
	ret = pkg_2send( MSG_FBBWWRITERECT+MSG_NORETURN,
		buf, 4*NET_LONG_LEN,
		(char *)pp, num,
		PCP(ifp) );
	ret -= 4*NET_LONG_LEN;
	if( ret < 0 )
		return	-4;	/* Error from libpkg */
	return	ret;
	/* No reading an error return package, sacrificed for speed. */
}

/*
 *  32-bit longs: mode, x, y
 */
HIDDEN int
rem_cursor(FBIO *ifp, int mode, int x, int y)
{
	char	buf[3*NET_LONG_LEN+1];

	/* Send Command */
	(void)fbputlong( mode, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( x, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( y, &buf[2*NET_LONG_LEN] );
	if( pkg_send( MSG_FBCURSOR, buf, 3*NET_LONG_LEN, PCP(ifp) ) < 3*NET_LONG_LEN )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( buf ) );
}

/*
 */
HIDDEN int
rem_getcursor(FBIO *ifp, int *mode, int *x, int *y)
{
	char	buf[4*NET_LONG_LEN+1];

	/* Send Command */
	if( pkg_send( MSG_FBGETCURSOR, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;

	/* return code, xcenter, ycenter, xzoom, yzoom as longs */
	if( pkg_waitfor( MSG_RETURN, buf, sizeof(buf), PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-3;
	*mode = fbgetlong( &buf[1*NET_LONG_LEN] );
	*x = fbgetlong( &buf[2*NET_LONG_LEN] );
	*y = fbgetlong( &buf[3*NET_LONG_LEN] );
	if( fbgetlong( &buf[0*NET_LONG_LEN] ) != 0 )
		return	-4;		/* fail */
	return( 0 );			/* OK */
}

/*
 *			R E M _ S E T C U R S O R
 *
 *  Program the "shape" of the cursor.
 *
 *  bits[] has xbits*ybits bits in it, rounded up to next largest byte.
 *
 *  Do not confuse this routine with the old fb_scursor() call.
 */
HIDDEN int
rem_setcursor(FBIO *ifp, const unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	char	buf[4*NET_LONG_LEN+1];
	int	ret;

	(void)fbputlong( xbits, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ybits, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( xorig, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( yorig, &buf[3*NET_LONG_LEN] );

	ret = pkg_2send( MSG_FBSETCURSOR+MSG_NORETURN,
		buf, 4*NET_LONG_LEN,
		(char *)bits, (xbits*ybits+7)>>3,
		PCP(ifp) );
	ret -= 4*NET_LONG_LEN;
	if( ret < 0 )
		return	-1;	/* Error from libpkg */

#if 0
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-2;
	return( fbgetlong( buf ) );
#else
	/* Since this call got somehow overlooked until Release 4.3,
	 * older 'fbserv' programs won't have support for this request.
	 * Rather than dooming LGT users to endless frustration,
	 * simply launch off the request and tell our caller that all is well.
	 * LGT never actually checks the return code of this routine anyway.
	 */
	return 0;
#endif
}

/*
 */
HIDDEN int
rem_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	char	buf[4*NET_LONG_LEN+1];

	/* Send Command */
	(void)fbputlong( xcenter, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( ycenter, &buf[1*NET_LONG_LEN] );
	(void)fbputlong( xzoom, &buf[2*NET_LONG_LEN] );
	(void)fbputlong( yzoom, &buf[3*NET_LONG_LEN] );
	if( pkg_send( MSG_FBVIEW, buf, 4*NET_LONG_LEN, PCP(ifp) ) < 4*NET_LONG_LEN )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( buf ) );
}

/*
 */
HIDDEN int
rem_getview(FBIO *ifp, int *xcenter, int *ycenter, int *xzoom, int *yzoom)
{
	char	buf[5*NET_LONG_LEN+1];

	/* Send Command */
	if( pkg_send( MSG_FBGETVIEW, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;

	/* return code, xcenter, ycenter, xzoom, yzoom as longs */
	if( pkg_waitfor( MSG_RETURN, buf, sizeof(buf), PCP(ifp) ) < 5*NET_LONG_LEN )
		return	-3;
	*xcenter = fbgetlong( &buf[1*NET_LONG_LEN] );
	*ycenter = fbgetlong( &buf[2*NET_LONG_LEN] );
	*xzoom = fbgetlong( &buf[3*NET_LONG_LEN] );
	*yzoom = fbgetlong( &buf[4*NET_LONG_LEN] );
	if( fbgetlong( &buf[0*NET_LONG_LEN] ) != 0 )
		return	-4;		/* fail */
	return( 0 );			/* OK */
}

#define REM_CMAP_BYTES	(256*3*2)

HIDDEN int
rem_rmap(register FBIO *ifp, register ColorMap *cmap)
{
	register int	i;
	char	buf[NET_LONG_LEN+1];
	char	cm[REM_CMAP_BYTES+4];

	if( pkg_send( MSG_FBRMAP, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;
	if( pkg_waitfor( MSG_DATA, cm, REM_CMAP_BYTES, PCP(ifp) ) < REM_CMAP_BYTES )
		return	-3;
	for( i = 0; i < 256; i++ ) {
		cmap->cm_red[i] = fbgetshort( cm+2*(0+i) );
		cmap->cm_green[i] = fbgetshort( cm+2*(256+i) );
		cmap->cm_blue[i] = fbgetshort( cm+2*(512+i) );
	}
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-4;
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

HIDDEN int
rem_wmap(register FBIO *ifp, const ColorMap *cmap)
{
	register int	i;
	char	buf[NET_LONG_LEN+1];
	char	cm[REM_CMAP_BYTES+4];

	if( cmap == COLORMAP_NULL ) {
		if( pkg_send( MSG_FBWMAP, (char *)0, 0, PCP(ifp) ) < 0 )
			return	-2;
	} else {
		for( i = 0; i < 256; i++ ) {
			(void)fbputshort( cmap->cm_red[i], cm+2*(0+i) );
			(void)fbputshort( cmap->cm_green[i], cm+2*(256+i) );
			(void)fbputshort( cmap->cm_blue[i], cm+2*(512+i) );
		}
		if( pkg_send( MSG_FBWMAP, cm, REM_CMAP_BYTES, PCP(ifp) ) < REM_CMAP_BYTES )
			return	-3;
	}
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-4;
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

/*
 *  Poll tells the remote end to handle input events.
 *  There is no need to wait for a reply (FLUSH can be
 *  used for synchronization.
 *  In fact, we may not want to send polls at all....
 */
HIDDEN int
rem_poll(FBIO *ifp)
{
	/* send a poll package to remote */
	if( pkg_send( MSG_FBPOLL, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-1;
	return( 0 );
}

HIDDEN int
rem_flush(FBIO *ifp)
{
	char	buf[NET_LONG_LEN+1];

	/* send a flush package to remote */
	if( pkg_send( MSG_FBFLUSH, (char *)0, 0, PCP(ifp) ) < 0 )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

/*
 *			R E M _ H E L P
 */
HIDDEN int
rem_help(FBIO *ifp)
{
	char	buf[1*NET_LONG_LEN+1];

	fb_log( "Remote Interface:\n" );

	/* Send Command */
	(void)fbputlong( 0L, &buf[0*NET_LONG_LEN] );
	if( pkg_send( MSG_FBHELP, buf, 1*NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-2;
	if( pkg_waitfor( MSG_RETURN, buf, NET_LONG_LEN, PCP(ifp) ) < 1*NET_LONG_LEN )
		return	-3;
	return( fbgetlong( &buf[0*NET_LONG_LEN] ) );
}

/*
 *			P K G E R R O R
 *
 *  This is where we come on asynchronous error or log messages.
 *  We are counting on the remote machine now to prefix his own
 *  name to messages, so we don't touch them ourselves.
 */
HIDDEN void
pkgerror(struct pkg_conn *pcpp, char *buf)
{
	fb_log( "%s", buf );
	free(buf);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.26
log
@Fixed call to strncpy so as not to overwrite buf.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.25 2007/10/26 21:51:26 brlcad Exp $ (BRL)";
d286 36
a321 39
	register int	i;
	struct pkg_conn *pc;
	char	buf[128];
	char	hostname[MAX_HOSTNAME];
	char	portname[MAX_HOSTNAME];
	char	device[MAX_HOSTNAME];
	int	port;

	FB_CK_FBIO(ifp);

	hostname[0] = '\0';
	portname[0] = '\0';
	port = 0;

	if( file == NULL || parse_file(file, hostname, &port, device, MAX_HOSTNAME) < 0 ) {
		/* too wild for our tastes */
		fb_log( "rem_open: bad device name \"%s\"\n",
			file == NULL ? "(null)" : file );
		return	-2;
	}
	/*printf("hostname = \"%s\", port = %d, device = \"%s\"\n", hostname, port, device );*/

	if( port != 5558 ) {
		sprintf(portname, "%d", port);
		if( (pc = pkg_open( hostname, portname, 0, 0, 0, pkgswitch, rem_log )) == PKC_ERROR ) {
			fb_log(	"rem_open: can't connect to fb server on host \"%s\", port \"%s\".\n",
				hostname, portname );
			return	-3;
		}
	} else
	if( (pc = pkg_open( hostname, "remotefb", 0, 0, 0, pkgswitch, rem_log )) == PKC_ERROR &&
	    (pc = pkg_open( hostname, "5558", 0, 0, 0, pkgswitch, rem_log )) == PKC_ERROR ) {
		fb_log(	"rem_open: can't connect to remotefb server on host \"%s\".\n",
			hostname );
		return	-4;
	}
	PCPL(ifp) = (char *)pc;			/* stash in u1 */
	ifp->if_fd = pc->pkc_fd;		/* unused */

d323 13
a335 13
	{
		int	n;
		int	val;
		val = 32767;
		n = setsockopt( pc->pkc_fd, SOL_SOCKET,
			SO_SNDBUF, (char *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_SNDBUF");

		val = 32767;
		n = setsockopt( pc->pkc_fd, SOL_SOCKET,
			SO_RCVBUF, (char *)&val, sizeof(val) );
		if( n < 0 )  perror("setsockopt: SO_RCVBUF");
	}
d337 20
d358 1
a358 17
	(void)fbputlong( width, &buf[0*NET_LONG_LEN] );
	(void)fbputlong( height, &buf[1*NET_LONG_LEN] );
	(void) strncpy(&buf[2*NET_LONG_LEN], device, 128-2*NET_LONG_LEN);
	i = strlen(device)+2*NET_LONG_LEN;
	if( pkg_send( MSG_FBOPEN, buf, i, pc ) != i )
		return	-5;

	/* return code, max_width, max_height, width, height as longs */
	if( pkg_waitfor( MSG_RETURN, buf, sizeof(buf), pc ) < 5*NET_LONG_LEN )
		return	-6;
	ifp->if_max_width = fbgetlong( &buf[1*NET_LONG_LEN] );
	ifp->if_max_height = fbgetlong( &buf[2*NET_LONG_LEN] );
	ifp->if_width = fbgetlong( &buf[3*NET_LONG_LEN] );
	ifp->if_height = fbgetlong( &buf[4*NET_LONG_LEN] );
	if( fbgetlong( &buf[0*NET_LONG_LEN] ) != 0 )
		return	-7;		/* fail */
	return( 0 );			/* OK */
@


14.25
log
@yet another surge of level 4 flawfinder string length checks. somewhere around 30-40% done.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.24 2007/09/15 16:23:10 brlcad Exp $ (BRL)";
d343 1
a343 1
	(void) strncpy( &buf[2*NET_LONG_LEN], device, 128 );
@


14.24
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.23 2007/08/18 03:15:11 brlcad Exp $ (BRL)";
d181 2
a182 2
int
parse_file(char *file, char *host, int *portp, char *device)
d197 1
a197 1
		strcpy( host, "localhost" );
d208 1
a208 1
			strcpy( host, "localhost" );
d213 1
a213 1
			strcpy( host, prefix );
d249 1
a249 1
		strcpy( host, "localhost" );
d262 1
a262 1
		strcpy( host, "localhost" );
d266 1
a266 1
	strcpy( device, dev );
d300 1
a300 1
	if( file == NULL || parse_file(file, hostname, &port, device) < 0 ) {
d343 1
a343 1
	(void) strcpy( &buf[2*NET_LONG_LEN], device );
@


14.23
log
@remove the fblocal.h header file.  it was only used in three places (two files) and only contained one macro (wrapper to fb_log an error), so keep it simple until it's really needed.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.22 2007/07/26 01:13:56 brlcad Exp $ (BRL)";
d48 2
a58 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.23.2.1
log
@merge from head, make linger the default framebuffer action instead of transient for all windowing framebuffer interfaces.
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.24 2007/09/15 16:23:10 brlcad Exp $ (BRL)";
a47 2
#include <string.h>

d57 5
@


14.22
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.21 2007/01/27 01:41:37 brlcad Exp $ (BRL)";
a65 2
#include "./fblocal.h"

@


14.21
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a36 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d41 1
a41 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.20 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
@


14.20
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.19 2007/01/21 04:45:42 brlcad Exp $ (BRL)";
d193 4
a196 4
           	/* input file spec */
           	/* host part */
            	/* port number */
             	/* device part */
@


14.19
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.18 2007/01/20 14:36:52 brlcad Exp $ (BRL)";
@


14.18
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup if */
/*@@{*/
d24 1
d44 1
a44 1
/*@@}*/
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.17 2006/08/24 20:51:34 brlcad Exp $ (BRL)";
@


14.17
log
@quell prototype warnings by making the errlog callback function match the signature via a simple passthrough to a rem_log().
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2006 United States Government as represented by
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.16 2006/08/08 06:47:05 brlcad Exp $ (BRL)";
@


14.16
log
@get rid of the libfb-specific _LOCAL_ macro, instead using HIDDEN like everyone else (currently still provided by machine.h)
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.15 2006/08/07 17:55:16 brlcad Exp $ (BRL)";
d282 7
d321 1
a321 1
		if( (pc = pkg_open( hostname, portname, 0, 0, 0, pkgswitch, fb_log )) == PKC_ERROR ) {
d327 2
a328 2
	if( (pc = pkg_open( hostname, "remotefb", 0, 0, 0, pkgswitch, fb_log )) == PKC_ERROR &&
	    (pc = pkg_open( hostname, "5558", 0, 0, 0, pkgswitch, fb_log )) == PKC_ERROR ) {
@


14.15
log
@IF_4D interface is not really shipped any more, don't talk about it
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.14 2006/07/09 19:17:16 brlcad Exp $ (BRL)";
d90 1
a90 1
_LOCAL_ int	rem_open(register FBIO *ifp, register char *file, int width, int height),
d162 1
a162 1
static int
d287 1
a287 1
_LOCAL_ int
d364 1
a364 1
_LOCAL_ int
d389 1
a389 1
_LOCAL_ int
d403 1
a403 1
_LOCAL_ int
d426 1
a426 1
_LOCAL_ int
d455 1
a455 1
_LOCAL_ int
d481 1
a481 1
_LOCAL_ int
d513 1
a513 1
_LOCAL_ int
d545 1
a545 1
_LOCAL_ int
d576 1
a576 1
_LOCAL_ int
d606 1
a606 1
_LOCAL_ int
d624 1
a624 1
_LOCAL_ int
d653 1
a653 1
_LOCAL_ int
d689 1
a689 1
_LOCAL_ int
d708 1
a708 1
_LOCAL_ int
d731 1
a731 1
_LOCAL_ int
d752 1
a752 1
_LOCAL_ int
d782 1
a782 1
_LOCAL_ int
d791 1
a791 1
_LOCAL_ int
d807 1
a807 1
_LOCAL_ int
d830 1
a830 1
static void
@


14.14
log
@increase and initialize some buffer sizes to something larger in order to minimize hitting buffer limits while processing.
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.13 2006/02/27 08:31:53 brlcad Exp $ (BRL)";
d373 7
a379 6
	 *  When if_4d with a "linger mode" window gets it's fb_close()
	 *  call here, it closes down the network file descriptor,
	 *  and so the PKG connection is terminated at this point.
	 *  If there was no transmission error noted in the pkg_send() above,
	 *  but the pkg_waitfor() here gets an error, clean up and
	 *  declare this a successful close() operation.
@


14.13
log
@stdlib.h warning quelling
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.12 2006/01/22 10:37:18 brlcad Exp $ (BRL)";
d134 2
a135 2
	1024,				/* " */
	1024,				/* " */
@


14.12
log
@use fbmsg.h instead of pkgtypes.h (renamed and moved)
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.11 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
d52 1
a56 1

a58 1
#else
a59 1

a62 1

a70 1

d76 1
@


14.11
log
@update copyright to 2006
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.10 2005/12/29 08:16:08 brlcad Exp $ (BRL)";
d74 1
a74 1
#include "./pkgtypes.h"
d78 1
@


14.10
log
@use the HAVE_NETINET_IN_H header define instead of !_WIN32
@
text
@d4 1
a4 1
 * Copyright (C) 1986-2005 United States Government as represented by
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.9 2005/12/23 21:26:30 bob1961 Exp $ (BRL)";
@


14.9
log
@Merge of bobWinPort
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.8 2005/10/23 04:44:34 brlcad Exp $ (BRL)";
a51 2


d54 1
a54 1
#include <sys/uio.h>		/* for struct iovec */
d57 1
a57 1
#ifndef _WIN32
d63 1
a63 1
# include <sys/socket.h>
d67 1
a67 1
#include <string.h>
d69 1
a69 1
#include <strings.h>
d78 1
@


14.8
log
@trailing ws
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.7 2005/08/12 22:30:12 lbutler Exp $ (BRL)";
d59 4
a62 1
#include <netinet/in.h>		/* for htons(), etc */
@


14.7
log
@Doxygen changes
@
text
@d42 1
a42 1
 *  
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.6 2005/01/30 20:30:53 brlcad Exp $ (BRL)";
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d42 1
a42 1
 *
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
@


14.7.2.1
log
@Mods for windows port
@
text
@d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.7 2005/08/12 22:30:12 lbutler Exp $ (BRL)";
d59 1
a59 4
#ifndef _WIN32
#  include <netinet/in.h>		/* for htons(), etc */
#else
#endif
@


14.6
log
@update copyright to 2005
@
text
@d21 3
a24 1
 *
d44 2
d47 1
a47 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_remote.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2004 United States Government as represented by
d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_remote.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a40 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
d43 1
a43 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_remote.c,v 14.3 2004/12/21 05:45:22 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_remote.c,v 14.2 2004/12/21 03:58:27 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_remote.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *		I F _ R E M O T E . C
d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_remote.c,v 1.5 2004/09/15 06:40:51 morrison Exp $ (BRL)";
@


1.5
log
@quell warning -- constness
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_remote.c,v 1.4 2004/09/03 23:30:57 morrison Exp $ (BRL)";
d815 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_remote.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
d76 1
a76 1
		rem_wmap(register FBIO *ifp, register ColorMap *cmap),
d732 1
a732 1
rem_wmap(register FBIO *ifp, register ColorMap *cmap)
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_remote.c,v 1.2 2004/06/08 22:04:21 morrison Exp $ (BRL)";
d45 1
a45 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d30 1
a30 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d27 1
a27 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_remote.c,v 11.9 2004/05/10 15:30:45 erikg Exp $ (BRL)";
a53 1
#include "externs.h"
@

