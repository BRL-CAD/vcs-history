head	14.20;
access;
symbols
	rel-7-10-4:14.20
	STABLE:14.20.0.2
	stable-branch:14.8
	rel-7-10-2:14.20
	rel-7-10-0:14.20
	rel-7-8-4:14.16
	rel-7-8-2:14.15
	rel-7-8-0:14.15
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.11
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.11
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.8
	rel-7-0-4:14.7
	rel-7-0-2:14.7
	rel-7-0-1:14.7
	opensource-post:14.7
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.20
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.08.08.06.47.04;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.03.30.00.03.59;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.03.25.00.03.48;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.23.00.07.35;	author brlcad;	state Exp;
branches
	14.13.2.1;
next	14.12;

14.12
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.09.16.19.16.30;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.08.12.22.30.12;	author lbutler;	state Exp;
branches
	14.9.4.1;
next	14.8;

14.8
date	2005.01.30.20.30.48;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.32.30;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.32;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.58.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.08.22.45.03;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.20;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.40;	author morrison;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.13.2.1
date	2006.04.07.19.30.18;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.20
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@/*                        F B _ O B J . C
 * BRL-CAD
 *
 * Copyright (c) 1997-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup fb */
/** @@{ */
/** @@file fb_obj.c
 *
 * A framebuffer object contains the attributes and
 * methods for controlling  framebuffers.
 *
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Authors -
 *	Robert G. Parker
 *	Ronald Bowers
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
/** @@} */

#include "common.h"

#include <stdlib.h>

#include "tcl.h"
#include "machine.h"
#include "cmd.h"                  /* includes bu.h */
#include "fb.h"
#include "fbserv_obj.h"

/* defined in libfb/tcl.c */
extern int fb_refresh(FBIO *ifp, int x, int y, int w, int h);

static int fbo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_cell_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_close_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_cursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getcursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getheight_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getsize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_getwidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_pixel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_listen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_refresh_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_rect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
static int fbo_coords_ok(Tcl_Interp *interp, FBIO *fbp, int x, int y);
static int fbo_tcllist2color(Tcl_Interp *interp, char *string, unsigned char *pixel);

#define FBO_CONSTRAIN(_v, _a, _b)\
	((_v > _a) ? (_v < _b ? _v : _b) : _a)

struct fb_obj {
	struct bu_list		l;
	struct bu_vls		fbo_name;	/* framebuffer object name/cmd */
	struct fbserv_obj	fbo_fbs;	/* fbserv object */
};

static struct fb_obj HeadFBObj;			/* head of display manager object list */

static struct bu_cmdtab fbo_cmds[] = {
       {"cell",		fbo_cell_tcl},
       {"clear",	fbo_clear_tcl},
       {"close",	fbo_close_tcl},
       {"configure",	fbo_configure_tcl},
       {"cursor",	fbo_cursor_tcl},
       {"pixel",	fbo_pixel_tcl},
       {"flush",	fbo_flush_tcl},
       {"getcursor",	fbo_getcursor_tcl},
       {"getheight",	fbo_getheight_tcl},
       {"getsize",	fbo_getsize_tcl},
       {"getwidth",	fbo_getwidth_tcl},
       {"listen",	fbo_listen_tcl},
       {"rect",		fbo_rect_tcl},
       {"refresh",	fbo_refresh_tcl},
       {(char *)0,	(int (*)())0}
};

/*
 *			F B O _ C M D
 *
 * Generic interface for framebuffer object routines.
 * Usage:
 *        procname cmd ?args?
 *
 * Returns: result of FB command.
 */
HIDDEN int
fbo_cmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	return bu_cmd(clientData, interp, argc, argv, fbo_cmds, 1);
}

int
Fbo_Init(Tcl_Interp *interp)
{
	BU_LIST_INIT(&HeadFBObj.l);
	(void)Tcl_CreateCommand(interp, "fb_open", (Tcl_CmdProc *)fbo_open_tcl,
				(ClientData)NULL, (Tcl_CmdDeleteProc *)NULL);

	return TCL_OK;
}

/*
 * Called by Tcl when the object is destroyed.
 */
HIDDEN void
fbo_deleteProc(ClientData clientData)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;

	/* close framebuffer */
	fb_close(fbop->fbo_fbs.fbs_fbp);

	bu_vls_free(&fbop->fbo_name);
	BU_LIST_DEQUEUE(&fbop->l);
	bu_free((genptr_t)fbop, "fbo_deleteProc: fbop");
}

/*
 * Close a framebuffer object.
 *
 * Usage:
 *	  procname close
 */
HIDDEN int
fbo_close_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_close");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* Among other things, this will call dmo_deleteProc. */
	Tcl_DeleteCommand(interp, bu_vls_addr(&fbop->fbo_name));

	return TCL_OK;
}

/*
 * Open/create a framebuffer object.
 *
 * Usage:
 *	  fb_open [name device [args]]
 */
HIDDEN int
fbo_open_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop;
	FBIO *ifp;
	int width = 512;
	int height = 512;
	register int c;
	struct bu_vls vls;

	if (argc == 1) {
		/* get list of framebuffer objects */
		for (BU_LIST_FOR(fbop, fb_obj, &HeadFBObj.l))
			Tcl_AppendResult(interp, bu_vls_addr(&fbop->fbo_name), " ", (char *)NULL);

		return TCL_OK;
	}

	if (argc < 3) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_open");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	/* process args */
	bu_optind = 3;
	bu_opterr = 0;
	while ((c = bu_getopt(argc, argv, "w:W:s:S:n:N:")) != EOF)  {
		switch (c) {
		case 'W':
		case 'w':
			width = atoi(bu_optarg);
			break;
		case 'N':
		case 'n':
			height = atoi(bu_optarg);
			break;
		case 'S':
		case 's':
			width = atoi(bu_optarg);
			height = width;
			break;
		case '?':
		default:
			Tcl_AppendResult(interp, "fb_open: bad option - ",
					 bu_optarg, (char *)NULL);
			return TCL_ERROR;
		}
	}

	if ((ifp = fb_open(argv[2], width, height)) == FBIO_NULL) {
		Tcl_AppendResult(interp, "fb_open: bad device - ",
				 argv[2], (char *)NULL);
	}

	if (fb_ioinit(ifp) != 0) {
		Tcl_AppendResult(interp, "fb_open: fb_ioinit() failed.", (char *) NULL);
		return TCL_ERROR;
	}

	BU_GETSTRUCT(fbop, fb_obj);
	bu_vls_init(&fbop->fbo_name);
	bu_vls_strcpy(&fbop->fbo_name, argv[1]);
	fbop->fbo_fbs.fbs_fbp = ifp;
	fbop->fbo_fbs.fbs_listener.fbsl_fbsp = &fbop->fbo_fbs;
	fbop->fbo_fbs.fbs_listener.fbsl_fd = -1;
	fbop->fbo_fbs.fbs_listener.fbsl_port = -1;

	/* append to list of fb_obj's */
	BU_LIST_APPEND(&HeadFBObj.l,&fbop->l);

	(void)Tcl_CreateCommand(interp,
				bu_vls_addr(&fbop->fbo_name),
				(Tcl_CmdProc *)fbo_cmd,
				(ClientData)fbop,
				fbo_deleteProc);

	/* Return new function name as result */
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, bu_vls_addr(&fbop->fbo_name), (char *)NULL);
	return TCL_OK;
}

/*
 * Clear the framebuffer with the specified color.
 * Otherwise, clear the framebuffer with black.
 *
 * Usage:
 *	  procname clear [rgb]
 */
HIDDEN int
fbo_clear_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int status;
	RGBpixel pixel;
	unsigned char *ms;


	if (argc < 2 || 3 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_clear");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc == 3) {
		/*
		 * Decompose the color list into its constituents.
		 * For now must be in the form of rrr ggg bbb.
		 */
		if (fbo_tcllist2color(interp, argv[6], pixel) == TCL_ERROR) {
			Tcl_AppendResult(interp, "fb_cell: invalid color spec: ", argv[6], ".",
					 (char *)NULL);
			return TCL_ERROR;
		}

		ms = pixel;
	}else
		ms = RGBPIXEL_NULL;

	status = fb_clear(fbop->fbo_fbs.fbs_fbp, ms);

	if(status < 0)
		return TCL_ERROR;

	return TCL_OK;
}

/*
 *
 * Usage:
 *	  procname cursor mode x y
 */
HIDDEN int
fbo_cursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int mode;
	int x, y;
	int status;
	struct bu_vls vls;

	if (argc != 5) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_cursor");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
	}

	if (sscanf(argv[2], "%d", &mode) != 1) {
		Tcl_AppendResult(interp, "fb_cursor: bad mode - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &x) != 1) {
		Tcl_AppendResult(interp, "fb_cursor: bad x value - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[4], "%d", &y) != 1) {
		Tcl_AppendResult(interp, "fb_cursor: bad y value - ",
				 argv[4], (char *)NULL);
		return TCL_ERROR;
	}

	status = fb_cursor(fbop->fbo_fbs.fbs_fbp, mode, x, y);
	if (status == 0)
		return TCL_OK;

	return TCL_ERROR;
}

/*
 *
 * Usage:
 *	  procname getcursor
 */
HIDDEN int
fbo_getcursor_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int status;
	int mode;
	int x, y;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_getcursor");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	status = fb_getcursor(fbop->fbo_fbs.fbs_fbp, &mode, &x, &y);
	if (status == 0) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d %d %d", mode, x, y);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	return TCL_ERROR;
}

/*
 * Refresh the entire framebuffer or that part specified by
 * a rectangle (i.e. x y width height)
 * Usage:
 *	  procname refresh [rect]
 */
HIDDEN int
fbo_refresh_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int x, y, w, h;		       /* rectangle to be refreshed */

	if (argc < 2 || 3 < argc) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_refresh");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (argc == 2) {  /* refresh the whole display */
		x = y = 0;
		w = fbop->fbo_fbs.fbs_fbp->if_width;
		h = fbop->fbo_fbs.fbs_fbp->if_height;
	} else if (sscanf(argv[2], "%d %d %d %d", &x, &y, &w, &h) != 4) { /* refresh rectanglar area */
		Tcl_AppendResult(interp, "fb_refresh: bad rectangle - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

#if 1
	return fb_refresh(fbop->fbo_fbs.fbs_fbp, x, y, w, h);
#else
	return fbop->fbo_fbs.fbs_fbp->if_refresh(fbop->fbo_fbs.fbs_fbp, x, y, w, h)
#endif
}

/*
 * Listen for framebuffer clients.
 *
 * Usage:
 *	  procname listen port
 *
 * Returns the port number actually used.
 *
 */
HIDDEN int
fbo_listen_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	bu_vls_init(&vls);

	if (fbop->fbo_fbs.fbs_fbp == FBIO_NULL) {
		bu_vls_printf(&vls, "%s listen: framebuffer not open!\n", argv[0]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_ERROR;
	}

	/* return the port number */
	if (argc == 2) {
		bu_vls_printf(&vls, "%d", fbop->fbo_fbs.fbs_listener.fbsl_port);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	if (argc == 3) {
		int port;

		if (sscanf(argv[2], "%d", &port) != 1) {
			Tcl_AppendResult(interp, "listen: bad value - ", argv[2], "\n", (char *)NULL);
			return TCL_ERROR;
		}

		if (port >= 0)
			fbs_open(interp, &fbop->fbo_fbs, port);
		else {
			fbs_close(interp, &fbop->fbo_fbs);
		}
		bu_vls_printf(&vls, "%d", fbop->fbo_fbs.fbs_listener.fbsl_port);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	bu_vls_printf(&vls, "helplib fb_listen");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);

	return TCL_ERROR;
}

/*
 * Set/get the pixel value at position (x, y).
 *
 * Usage:
 *	  procname pixel x y [rgb]
 */
HIDDEN int
fbo_pixel_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;
	int x, y; 	/* pixel position */
	RGBpixel pixel;


	if (argc < 4)
		goto error;

	/* get pixel position */
	if (sscanf(argv[2], "%d", &x) != 1) {
		Tcl_AppendResult(interp, "fb_pixel: bad x value - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &y) != 1) {
		Tcl_AppendResult(interp, "fb_pixel: bad y value - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	/* check pixel position */
	if (!fbo_coords_ok(interp, fbop->fbo_fbs.fbs_fbp, x, y)) {
		Tcl_AppendResult(interp,
				 "fb_pixel: coordinates (", argv[2], ", ", argv[3],
				 ") are invalid.", (char *)NULL);
		return TCL_ERROR;
	}

	/* get pixel value */
	if (argc == 4) {
		fb_rpixel(fbop->fbo_fbs.fbs_fbp, pixel);
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "%d %d %d", pixel[RED], pixel[GRN], pixel[BLU]);
		Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
		bu_vls_free(&vls);

		return TCL_OK;
	}

	/* set pixel value */
	if (argc == 5) {
		/*
		 * Decompose the color list into its constituents.
		 * For now must be in the form of rrr ggg bbb.
		 */

		if (fbo_tcllist2color(interp, argv[4], pixel) == TCL_ERROR) {
			Tcl_AppendResult(interp, "fb_pixel: invalid color spec - ", argv[4], ".",
					 (char *)NULL);
			return TCL_ERROR;
		}

		fb_write(fbop->fbo_fbs.fbs_fbp, x, y, pixel, 1);

		return TCL_OK;
	}

error:
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "helplib fb_pixel");
	Tcl_Eval(interp, bu_vls_addr(&vls));
	bu_vls_free(&vls);
	return TCL_ERROR;
}

/*
 *
 * Usage:
 *	  procname cell xmin ymin width height color
 */
HIDDEN int
fbo_cell_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;
	int xmin, ymin;
	int width;
	int height;
	int i;
	RGBpixel pixel;
	unsigned char *pp;


	if (argc != 7) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_cell");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%d", &xmin) != 1) {
		Tcl_AppendResult(interp, "fb_cell: bad xmin value - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &ymin) != 1) {
		Tcl_AppendResult(interp, "fb_cell: bad ymin value - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	/*  check coordinates */
	if (!fbo_coords_ok(interp, fbop->fbo_fbs.fbs_fbp, xmin, ymin)) {
		Tcl_AppendResult(interp,
				 "fb_cell: coordinates (", argv[2], ", ", argv[3],
				 ") are invalid.", (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[4], "%d", &width) != 1) {
		Tcl_AppendResult(interp, "fb_cell: bad width - ",
				 argv[4], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[5], "%d", &height) != 1) {
		Tcl_AppendResult(interp, "fb_cell: bad height - ",
				 argv[5], (char *)NULL);
		return TCL_ERROR;
	}


	/* check width and height */
	if (width <=0  || height <=0) {
		Tcl_AppendResult(interp, "fb_cell: width and height must be > 0", (char *)NULL);
		return TCL_ERROR;
	}

	/*
	 * Decompose the color list into its constituents.
	 * For now must be in the form of rrr ggg bbb.
	 */
	if (fbo_tcllist2color(interp, argv[6], pixel) == TCL_ERROR) {
		Tcl_AppendResult(interp, "fb_cell: invalid color spec: ", argv[6], ".",
				 (char *)NULL);
		return TCL_ERROR;
	}

	pp = (unsigned char *)calloc(width*height, sizeof(RGBpixel));
	for (i = 0; i < width*height*sizeof(RGBpixel); i+=sizeof(RGBpixel)) {
		pp[i] = pixel[0];
		pp[i+1] = pixel[1];
		pp[i+2] = pixel[2];
	}
	fb_writerect(fbop->fbo_fbs.fbs_fbp, xmin, ymin, width, height, pp);
	free((void *)pp);

	return TCL_OK;
}

/*
 *
 * Usage:
 *	  procname flush
 */
HIDDEN int
fbo_flush_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;


	if (argc != 2) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_flush");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	fb_flush(fbop->fbo_fbs.fbs_fbp);

	return TCL_OK;
}

/*
 *
 * Usage:
 *	  procname getheight
 */
HIDDEN int
fbo_getheight_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_getheight");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%d", fb_getheight(fbop->fbo_fbs.fbs_fbp));
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 *
 * Usage:
 *	  procname getwidth
 */
HIDDEN int
fbo_getwidth_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_getwidth");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%d", fb_getwidth(fbop->fbo_fbs.fbs_fbp));
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
}

/*
 *
 * Usage:
 *	  procname getsize
 */
HIDDEN int
fbo_getsize_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	if (argc != 2) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_getsize");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%d %d",
		      fb_getwidth(fbop->fbo_fbs.fbs_fbp),
		      fb_getheight(fbop->fbo_fbs.fbs_fbp));
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);


	return TCL_OK;
}

/*
 *
 * Usage:
 *	  procname cell xmin ymin width height color
 */
HIDDEN int
fbo_rect_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;
	int xmin, ymin;
	int xmax, ymax;
	int width;
	int height;
	int i;
	RGBpixel pixel;

	if (argc != 7) {
		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_rect");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%d", &xmin) != 1) {
		Tcl_AppendResult(interp, "fb_rect: bad xmin value - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &ymin) != 1) {
		Tcl_AppendResult(interp, "fb_rect: bad ymin value - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	/*  check coordinates */
	if (!fbo_coords_ok(interp, fbop->fbo_fbs.fbs_fbp, xmin, ymin)) {
		Tcl_AppendResult(interp,
				 "fb_rect: coordinates (", argv[2], ", ", argv[3],
				 ") are invalid.", (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[4], "%d", &width) != 1) {
		Tcl_AppendResult(interp, "fb_rect: bad width - ",
				 argv[4], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[5], "%d", &height) != 1) {
		Tcl_AppendResult(interp, "fb_rect: bad height - ",
				 argv[5], (char *)NULL);
		return TCL_ERROR;
	}


	/* check width and height */
	if (width <=0  || height <=0) {
		Tcl_AppendResult(interp, "fb_rect: width and height must be > 0", (char *)NULL);
		return TCL_ERROR;
	}

	/*
	 * Decompose the color list into its constituents.
	 * For now must be in the form of rrr ggg bbb.
	 */
	if (fbo_tcllist2color(interp, argv[6], pixel) == TCL_ERROR) {
		Tcl_AppendResult(interp, "fb_rect: invalid color spec: ", argv[6], ".",
				 (char *)NULL);
		return TCL_ERROR;
	}

	xmax = xmin + width;
	ymax = ymin + height;

	/* draw horizontal lines */
	for (i = xmin; i <= xmax; ++i) {
		/* working on bottom line */
		fb_write(fbop->fbo_fbs.fbs_fbp, i, ymin, pixel, 1);

		/* working on top line */
		fb_write(fbop->fbo_fbs.fbs_fbp, i, ymax, pixel, 1);
	}

	/* draw vertical lines */
	for (i = ymin; i <= ymax; ++i) {
		/* working on left line */
		fb_write(fbop->fbo_fbs.fbs_fbp, xmin, i, pixel, 1);

		/* working on right line */
		fb_write(fbop->fbo_fbs.fbs_fbp, xmax, i, pixel, 1);
	}

	return TCL_OK;
}

/*
 * Usage:
 *	  procname configure width height
 */
int
fbo_configure_tcl(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	int width, height;

	if (argc != 4) {
		struct bu_vls vls;

		bu_vls_init(&vls);
		bu_vls_printf(&vls, "helplib fb_configure");
		Tcl_Eval(interp, bu_vls_addr(&vls));
		bu_vls_free(&vls);
		return TCL_ERROR;
	}

	if (sscanf(argv[2], "%d", &width) != 1) {
		Tcl_AppendResult(interp, "fb_configure: bad width - ",
				 argv[2], (char *)NULL);
		return TCL_ERROR;
	}

	if (sscanf(argv[3], "%d", &height) != 1) {
		Tcl_AppendResult(interp, "fb_configure: bad height - ",
				 argv[3], (char *)NULL);
		return TCL_ERROR;
	}

	/* configure the framebuffer window */
	if (fbop->fbo_fbs.fbs_fbp != FBIO_NULL)
		fb_configureWindow(fbop->fbo_fbs.fbs_fbp, width, height);

	return TCL_OK;
}
#if 0
/*
 *
 * Usage:
 *	  procname
 */
int
fbo__tcl(clientData, interp, argc, argv)
     ClientData clientData;
     Tcl_Interp *interp;
     int argc;
     char **argv;
{
	struct fb_obj *fbop = (struct fb_obj *)clientData;
	struct bu_vls vls;

	return TCL_OK;
}
#endif

/****************** utility routines ********************/
HIDDEN int
fbo_coords_ok(Tcl_Interp *interp, FBIO *fbp, int x, int y)
{
	int	    width;
	int	    height;
	int	    errors;
	width = fb_getwidth(fbp);
	height = fb_getheight(fbp);

	errors = 0;

	if (x < 0) {
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: X value < 0\n",
				 (char *)NULL);
		++errors;
	}

	if (y < 0) {
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: Y value < 0\n",
				 (char *)NULL);
		++errors;
	}

	if (x > width - 1) {
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: X value too large\n",
				 (char *)NULL);
		++errors;
	}

	if (y > height - 1) {
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: Y value too large\n",
				 (char *)NULL);
		++errors;
	}

	if ( errors ) {
		return 0;
	} else {
		return 1;
	}
}

HIDDEN int
fbo_tcllist2color(Tcl_Interp *interp, char *string, unsigned char *pixel)
{
    int r, g, b;

    if (sscanf(string, "%d %d %d", &r, &g, &b) != 3) {
	    Tcl_AppendResult(interp,
			     "fb_clear: bad color spec - ",
			     string, (char *)NULL);
	    return TCL_ERROR;
    }

    pixel[RED] = FBO_CONSTRAIN (r, 0, 255);
    pixel[GRN] = FBO_CONSTRAIN (g, 0, 255);
    pixel[BLU] = FBO_CONSTRAIN (b, 0, 255);

    return TCL_OK;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.19
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@a583 1

@


14.18
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.17
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup fb */
/*@@{*/
d24 1
d41 1
a41 1
/*@@}*/
@


14.16
log
@get rid of the libfb-specific _LOCAL_ macro, instead using HIDDEN like everyone else (currently still provided by machine.h)
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2006 United States Government as represented by
@


14.15
log
@revert the libbu memory management changes to libpkg just to be safe.  if someone happens to call bu_semaphore_acquire on a BU_SEM_SYSCALL semaphore, the call will block since libbu utilizes that semaphore internally (and it's expected that callers know this..).
@
text
@d112 1
a112 1
static int
d131 1
a131 1
static void
d150 1
a150 1
static int
d176 1
a176 1
static int
d268 1
a268 1
static int
d315 1
a315 1
static int
d361 1
a361 1
static int
d397 1
a397 1
static int
d439 1
a439 1
static int
d497 1
a497 1
static int
d572 1
a572 1
static int
d660 1
a660 1
static int
d686 1
a686 1
static int
d713 1
a713 1
static int
d740 1
a740 1
static int
d770 1
a770 1
static int
d922 1
a922 1
static int
d964 1
a964 1
static int
@


14.14
log
@quell intel on altix compiler warnings
@
text
@d643 1
a643 1
	pp = (unsigned char *)bu_calloc(width*height, sizeof(RGBpixel), "pixel array");
d650 1
a650 1
	bu_free((void *)pp, "pixel array");
@


14.13
log
@use bu_calloc and bu_free instead of calloc
@
text
@d45 2
@


14.13.2.1
log
@update from HEAD
@
text
@a44 2
#include <stdlib.h>

d641 1
a641 1
	pp = (unsigned char *)calloc(width*height, sizeof(RGBpixel));
d648 1
a648 1
	free((void *)pp);
@


14.12
log
@update copyright to 2006
@
text
@d641 1
a641 1
	pp = (unsigned char *)calloc(width*height, sizeof(RGBpixel));
d648 1
a648 1
	free((void *)pp);
@


14.11
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1997-2005 United States Government as represented by
@


14.10
log
@ws
@
text
@d27 1
a27 1
 * 
d291 1
a291 1
			Tcl_AppendResult(interp, "fb_cell: invalid color spec: ", argv[6], ".", 
d545 1
a545 1
    
d547 1
a547 1
			Tcl_AppendResult(interp, "fb_pixel: invalid color spec - ", argv[4], ".", 
d583 1
a583 1
    
d591 1
a591 1
    
d630 1
a630 1
    
d636 1
a636 1
		Tcl_AppendResult(interp, "fb_cell: invalid color spec: ", argv[6], ".", 
d650 1
a650 1
	return TCL_OK;    
d676 1
a676 1
	return TCL_OK;    
d703 1
a703 1
	return TCL_OK;    
d730 1
a730 1
	return TCL_OK;    
d760 1
a760 1
	return TCL_OK;    
d787 1
a787 1
    
d826 1
a826 1
    
d832 1
a832 1
		Tcl_AppendResult(interp, "fb_rect: invalid color spec: ", argv[6], ".", 
d858 1
a858 1
	return TCL_OK;    
d897 1
a897 1
	return TCL_OK;    
d903 1
a903 1
 *	  procname 
d915 1
a915 1
	return TCL_OK;    
d932 1
a932 1
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: X value < 0\n", 
d936 1
a936 1
    
d938 1
a938 1
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: Y value < 0\n", 
d944 1
a944 1
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: X value too large\n", 
d950 1
a950 1
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: Y value too large\n", 
@


14.9
log
@Doxygen changes
@
text
@a44 2


@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d27 1
a27 1
 *
d45 2
d293 1
a293 1
			Tcl_AppendResult(interp, "fb_cell: invalid color spec: ", argv[6], ".",
d547 1
a547 1

d549 1
a549 1
			Tcl_AppendResult(interp, "fb_pixel: invalid color spec - ", argv[4], ".",
d585 1
a585 1

d593 1
a593 1

d632 1
a632 1

d638 1
a638 1
		Tcl_AppendResult(interp, "fb_cell: invalid color spec: ", argv[6], ".",
d652 1
a652 1
	return TCL_OK;
d678 1
a678 1
	return TCL_OK;
d705 1
a705 1
	return TCL_OK;
d732 1
a732 1
	return TCL_OK;
d762 1
a762 1
	return TCL_OK;
d789 1
a789 1

d828 1
a828 1

d834 1
a834 1
		Tcl_AppendResult(interp, "fb_rect: invalid color spec: ", argv[6], ".",
d860 1
a860 1
	return TCL_OK;
d899 1
a899 1
	return TCL_OK;
d905 1
a905 1
 *	  procname
d917 1
a917 1
	return TCL_OK;
d934 1
a934 1
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: X value < 0\n",
d938 1
a938 1

d940 1
a940 1
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: Y value < 0\n",
d946 1
a946 1
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: X value too large\n",
d952 1
a952 1
		Tcl_AppendResult(interp, "fbo_coords_ok: Error!: Y value too large\n",
@


14.8
log
@update copyright to 2005
@
text
@d21 3
a24 1
 *
d41 1
@


14.7
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2004 United States Government as represented by
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a37 2
 *  
 *
@


14.5
log
@remove the old distribution notice section
@
text
@a39 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a38 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *				F B _ O B J . C
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d969 10
@


1.3
log
@quell Tcl_CmdProc * warning
@
text
@d30 1
a30 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d111 1
a111 1
	(void)Tcl_CreateCommand(interp, "fb_open", fbo_open_tcl,
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a37 1
#include "externs.h"
@

