head	1.17;
access;
symbols
	rel-7-10-4:1.11.2.1
	STABLE:1.11.0.2
	rel-7-10-2:1.10
	rel-7-10-0:1.9
	rel-7-8-4:1.5;
locks; strict;
comment	@ * @;


1.17
date	2007.12.03.15.34.01;	author brlcad;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.06.20.27.56;	author bob1961;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.04.17.42.27;	author bob1961;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.26.21.51.26;	author brlcad;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.26.21.09.29;	author brlcad;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.26.19.06.46;	author brlcad;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.18.03.15.11;	author brlcad;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2007.05.12.22.23.05;	author brlcad;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.23.01.13.35;	author brlcad;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.08.22.47.15;	author brlcad;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.08.06.47.06;	author brlcad;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.07.17.55.16;	author brlcad;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.01.16.20.50;	author brlcad;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.01.16.00.59;	author brlcad;	state Exp;
branches;
next	;

1.11.2.1
date	2007.09.28.14.07.48;	author brlcad;	state Exp;
branches;
next	;


desc
@@


1.17
log
@quell empty compilation unit warning
@
text
@/*                       I F _ W G L . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup if */
/** @@{ */
/** @@file if_wgl.c
 *
 *  Frame Buffer Library interface for Windows OpenGL.
 *
 *  There are several different Frame Buffer modes supported.
 *  Set your environment FB_FILE to the appropriate type.
 *  Note that some of the /dev/sgi modes are not supported, and there are
 *  some new modes.
 *  (see the modeflag definitions below).
 *	/dev/wgl[options]
 *
 *  This code is basically a port of if_ogl.c from OpenGL to Windows GL
 *
 *  Authors -
 *	Bob Parker
 *
 *  Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */
/** @@} */

#ifndef lint
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.16 2007/11/06 20:27:56 bob1961 Exp $ (ARL)";
#endif

#include "common.h"

#ifdef IF_WGL

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#ifdef HAVE_GL_GL_H
#  include <GL/gl.h>
#endif
#undef RED

#include "tk.h"
#include "tkPlatDecls.h"
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "rtgeom.h"
#include "raytrace.h"
#include "fb.h"


#define CJDEBUG 0

/*WWW these come from Iris gl gl.h*/
#define XMAXSCREEN	1279
#define YMAXSCREEN	1023
#define XMAXMEDIUM	1023
#define YMAXMEDIUM	767
#define XMAX170		645
#define YMAX170		484


/* Internal callbacks etc.*/
HIDDEN void		wgl_do_event();
HIDDEN void		expose_callback();
void wgl_configureWindow FB_ARGS((FBIO *ifp, int width, int height));

/* Other Internal routines */
HIDDEN void		wgl_clipper();
HIDDEN int		wgl_getmem();
HIDDEN void		backbuffer_to_screen();
HIDDEN void		wgl_cminit();
#if 0
HIDDEN void		reorder_cursor();
#endif
HIDDEN PIXELFORMATDESCRIPTOR *	wgl_choose_visual();
HIDDEN int		is_linear_cmap();

HIDDEN int	wgl_nwindows = 0; 	/* number of open windows */
HIDDEN int	multiple_windows = 0;	/* someone wants to be ready
					 * for multiple windows, at the
					 * expense of speed.
					 */
/*HIDDEN	XColor	color_cell[256];*/		/* used to set colormap */

int wgl_refresh();
int wgl_open_existing();
int wgl_close_existing();
int _wgl_open_existing();

HIDDEN int	wgl_open(),
		wgl_close(),
		wgl_clear(),
		wgl_read(),
		wgl_write(),
		wgl_rmap(),
		wgl_wmap(),
		wgl_view(),
		wgl_getview(),
		wgl_setcursor(),
		wgl_cursor(),
#if 0
		wgl_getcursor(),
		wgl_readrect(),
		fb_cnull(),
#endif
		wgl_writerect(),
		wgl_bwwriterect(),
		wgl_poll(),
		wgl_flush(),
		wgl_free(),
		wgl_help();

/* This is the ONLY thing that we normally "export" */
FBIO wgl_interface =
	{
	0,			/* magic number slot	*/
	wgl_open,		/* open device		*/
	wgl_close,		/* close device		*/
	wgl_clear,		/* clear device		*/
	wgl_read,		/* read	pixels		*/
	wgl_write,		/* write pixels		*/
	wgl_rmap,		/* read colormap	*/
	wgl_wmap,		/* write colormap	*/
	wgl_view,		/* set view		*/
	wgl_getview,		/* get view		*/
	wgl_setcursor,		/* define cursor	*/
	wgl_cursor,		/* set cursor		*/
	fb_sim_getcursor,	/* get cursor		*/
	fb_sim_readrect,	/* read rectangle	*/
	wgl_writerect,		/* write rectangle	*/
	fb_sim_bwreadrect,
	wgl_bwwriterect,	/* write rectangle	*/
	wgl_poll,		/* process events	*/
	wgl_flush,		/* flush output		*/
	wgl_free,		/* free resources	*/
	wgl_help,		/* help message		*/
	"Microsoft Windows OpenGL",	/* device description	*/
	XMAXSCREEN+1,			/* max width		*/
	YMAXSCREEN+1,			/* max height		*/
	"/dev/wgl",		/* short device name	*/
	512,			/* default/current width  */
	512,			/* default/current height */
	-1,			/* select file desc	*/
	-1,			/* file descriptor	*/
	1, 1,			/* zoom			*/
	256, 256,		/* window center	*/
	0, 0, 0,		/* cursor		*/
	PIXEL_NULL,		/* page_base		*/
	PIXEL_NULL,		/* page_curp		*/
	PIXEL_NULL,		/* page_endp		*/
	-1,			/* page_no		*/
	0,			/* page_dirty		*/
	0L,			/* page_curpos		*/
	0L,			/* page_pixels		*/
	0			/* debug		*/
};

FBIO	*saveifp;

/*
 *  Structure of color map in shared memory region.
 *  Has exactly the same format as the SGI hardware "gammaramp" map
 *  Note that only the lower 8 bits are significant.
 */
struct wgl_cmap {
	short	cmr[256];
	short	cmg[256];
	short	cmb[256];
};

/*
 *  This defines the format of the in-memory framebuffer copy.
 *  The alpha component and reverse order are maintained for
 *  compatibility with /dev/sgi
 */
struct wgl_pixel {
	unsigned char blue;
	unsigned char green;
	unsigned char red;
	unsigned char alpha;

};

/* Clipping structure for zoom/pan operations */
struct wgl_clip {
	int	xpixmin;	/* view clipping planes clipped to pixel memory space*/
	int	xpixmax;
	int	ypixmin;
	int	ypixmax;
	int	xscrmin;	/* view clipping planes */
	int	xscrmax;
	int	yscrmin;
	int	yscrmax;
	double	oleft;		/* glOrtho parameters */
	double	oright;
	double	otop;
	double	obottom;

};

/*
 *  Per window state information, overflow area.
 */
struct sgiinfo {
	short	mi_curs_on;
	short	mi_cmap_flag;		/* enabled when there is a non-linear map in memory */
	int	mi_shmid;
	int	mi_memwidth;		/* width of scanline in if_mem */
	short	mi_xoff;		/* X viewport offset, rel. window*/
	short	mi_yoff;		/* Y viewport offset, rel. window*/
	int	mi_pid;			/* for multi-cpu check */
	int	mi_parent;		/* PID of linger-mode process */
	int	mi_doublebuffer;	/* 0=singlebuffer 1=doublebuffer */
	struct wgl_pixel mi_scanline[XMAXSCREEN+1];	/* one scanline */
};

/*
 *  Per window state information particular to the OpenGL interface
 */
struct wglinfo {
	HGLRC	glxc;
	Display	       *dispp;		/* pointer to X display connection */
	Window		wind;		/* Window identifier */
	int		firstTime;
	int		alive;
	long		event_mask;	/* event types to be received */
	short		front_flag;	/* front buffer being used (b-mode) */
	short		copy_flag;	/* pan and zoom copied from backbuffer */
	short		soft_cmap_flag;	/* use software colormapping */
	int		cmap_size;	/* hardware colormap size */
	int 		win_width;	/* actual window width */
	int		win_height;	/* actual window height */
	int		vp_width;	/* actual viewport width */
	int		vp_height;	/* actual viewport height */
	struct wgl_clip	clip;		/* current view clipping */
	Window		cursor;
	PIXELFORMATDESCRIPTOR    *vip;		/* pointer to info on current visual */
	Colormap	xcmap;		/* xstyle color map */
	int		use_ext_ctrl;	/* for controlling the Wgl graphics engine externally */
	HDC		hdc;
	HWND	hwnd;

};

#define	SGI(ptr)	((struct sgiinfo *)((ptr)->u1.p))
#define	SGIL(ptr)	((ptr)->u1.p)		/* left hand side version */
#define	WGL(ptr)	((struct wglinfo *)((ptr)->u6.p))
#define	WGLL(ptr)	((ptr)->u6.p)		/* left hand side version */
#define if_mem		u2.p			/* shared memory pointer */
#define if_cmap		u3.p			/* color map in shared memory */
#define CMR(x)		((struct wgl_cmap *)((x)->if_cmap))->cmr
#define CMG(x)		((struct wgl_cmap *)((x)->if_cmap))->cmg
#define CMB(x)		((struct wgl_cmap *)((x)->if_cmap))->cmb
#define if_zoomflag	u4.l			/* zoom > 1 */
#define if_mode		u5.l			/* see MODE_* defines */

#define MARGIN	4			/* # pixels margin to screen edge */

#define CLIP_XTRA 1

#define WIN_L (ifp->if_max_width - ifp->if_width - MARGIN)
#define WIN_T (ifp->if_max_height - ifp->if_height - MARGIN)

/*
 *  The mode has several independent bits:
 *	SHARED -vs- MALLOC'ed memory for the image
 *	TRANSIENT -vs- LINGERING windows
 *	Windowed -vs- Centered Full screen
 *	Suppress dither -vs- dither
 *	Double -vs- Single buffered
 *	DrawPixels -vs- CopyPixels
 */
#define MODE_1MASK	(1<<0)
#define MODE_1SHARED	(0<<0)		/* Use Shared memory */
#define MODE_1MALLOC	(1<<0)		/* Use malloc memory */

#define MODE_2MASK	(1<<1)
#define MODE_2TRANSIENT	(0<<1)
#define MODE_2LINGERING (1<<1)		/* leave window up after closing*/

#define MODE_3MASK	(1<<2)
#define MODE_3WINDOW	(0<<2)		/* window mode */
#define MODE_3FULLSCR	(1<<2)		/* full screen mode */

#define MODE_4MASK	(1<<3)
#define MODE_4NORMAL	(0<<3)		/* dither if it seems necessary */
#define MODE_4NODITH	(1<<3)		/* suppress any dithering */

#define MODE_5MASK	(1<<4)
#define MODE_5NORMAL	(0<<4)	 	/* fast - assume no multiple windows */
#define MODE_5MULTI	(1<<4)		/* be ready for multiple windows */

#define MODE_7MASK	(1<<6)
#define MODE_7NORMAL	(0<<6)		/* install colormap in hardware if possible*/
#define MODE_7SWCMAP	(1<<6)		/* use software colormapping */

#define MODE_9MASK	(1<<8)
#define MODE_9NORMAL	(0<<8)		/* doublebuffer if possible */
#define MODE_9SINGLEBUF	(1<<8)		/* singlebuffer only */

#define MODE_11MASK	(1<<10)
#define MODE_11NORMAL	(0<<10)		/* always draw from mem. to window*/
#define MODE_11COPY	(1<<10)		/* keep full image on back buffer,*/

#define MODE_12MASK	(1<<11)
#define MODE_12NORMAL	(0<<11)
#define MODE_12DELAY_WRITES_TILL_FLUSH	(1<<11)
					/* and copy current view to front */
#define MODE_15MASK	(1<<14)
#define MODE_15NORMAL	(0<<14)
#define MODE_15ZAP	(1<<14)		/* zap the shared memory segment */

HIDDEN struct modeflags {
	char	c;
	long	mask;
	long	value;
	char	*help;
} modeflags[] = {
	{ 'p',	MODE_1MASK, MODE_1MALLOC,
		"Private memory - else shared" },
	{ 'l',	MODE_2MASK, MODE_2LINGERING,
		"Lingering window" },
	{ 't',	MODE_2MASK, MODE_2TRANSIENT,
		"Transient window" },
	{ 'f',	MODE_3MASK, MODE_3FULLSCR,
		"Full centered screen - else windowed" },
	{ 'd',  MODE_4MASK, MODE_4NODITH,
		"Suppress dithering - else dither if not 24-bit buffer" },
	{ 'm',  MODE_5MASK, MODE_5MULTI,
		"Be ready for multiple windows - else optimize for single windows" },
	{ 'c',	MODE_7MASK, MODE_7SWCMAP,
		"Perform software colormap - else use hardware colormap if possible" },
	{ 's',	MODE_9MASK, MODE_9SINGLEBUF,
		"Single buffer -  else double buffer if possible" },
	{ 'b',	MODE_11MASK, MODE_11COPY,
		"Fast pan and zoom using backbuffer copy -  else normal " },
	{ 'D',	MODE_12DELAY_WRITES_TILL_FLUSH, MODE_12DELAY_WRITES_TILL_FLUSH,
		"Don't update screen until fb_flush() is called.  (Double buffer sim)" },
	{ 'z',	MODE_15MASK, MODE_15ZAP,
		"Zap (free) shared memory.  Can also be done with fbfree command" },
	{ '\0', 0, 0, "" }
};


/************************************************************************/
/************************************************************************/
/************************************************************************/
/******************* Shared Memory Support ******************************/
/************************************************************************/
/************************************************************************/
/************************************************************************/

/*
 *			W G L _ G E T M E M
 *
 *			not changed from
 *
 *			S G I _ G E T M E M
 *
 *  Because there is no hardware zoom or pan, we need to repaint the
 *  screen (with big pixels) to implement these operations.
 *  This means that the actual "contents" of the frame buffer need
 *  to be stored somewhere else.  If possible, we allocate a shared
 *  memory segment to contain that image.  This has several advantages,
 *  the most important being that when operating the display in 12-bit
 *  output mode, pixel-readbacks still give the full 24-bits of color.
 *  System V shared memory persists until explicitly killed, so this
 *  also means that in MEX mode, the previous contents of the frame
 *  buffer still exist, and can be again accessed, even though the
 *  MEX windows are transient, per-process.
 *
 *  There are a few oddities, however.  The worst is that System V will
 *  not allow the break (see sbrk(2)) to be set above a shared memory
 *  segment, and shmat(2) does not seem to allow the selection of any
 *  reasonable memory address (like 6 Mbytes up) for the shared memory.
 *  In the initial version of this routine, that prevented subsequent
 *  calls to malloc() from succeeding, quite a drawback.  The work-around
 *  used here is to increase the current break to a large value,
 *  attach to the shared memory, and then return the break to its
 *  original value.  This should allow most reasonable requests for
 *  memory to be satisfied.  In special cases, the values used here
 *  might need to be increased.
 */
HIDDEN int
wgl_getmem( ifp )
FBIO	*ifp;
{
	int	pixsize;
	int	size;
	int	i;
	char	*sp;
	int	new = 0;

	errno = 0;

/*	if( (ifp->if_mode & MODE_1MASK) == MODE_1MALLOC )  */{
		/*
		 *  In this mode, only malloc as much memory as is needed.
		 */
		SGI(ifp)->mi_memwidth = ifp->if_width;
		pixsize = ifp->if_height * ifp->if_width * sizeof(struct wgl_pixel);
		size = pixsize + sizeof(struct wgl_cmap);

		sp = calloc( 1, size );
		if( sp == 0 )  {
			fb_log("wgl_getmem: frame buffer memory malloc failed\n");
			goto fail;
		}
		new = 1;
		goto success;
	}

success:
	ifp->if_mem = sp;
	ifp->if_cmap = sp + pixsize;	/* cmap at end of area */
	i = CMB(ifp)[255];		/* try to deref last word */
	CMB(ifp)[255] = i;

	/* Provide non-black colormap on creation of new shared mem */
	if(new)
		wgl_cminit( ifp );
	return(0);
fail:
	fb_log("wgl_getmem:  Unable to attach to shared memory.\n");
	if( (sp = calloc( 1, size )) == NULL )  {
		fb_log("wgl_getmem:  malloc failure\n");
		return(-1);
	}
	new = 1;
	goto success;
}

/*
 *			W G L _ Z A P M E M
 */
void
wgl_zapmem()
{
}

/*
 *			S I G K I D
 */
HIDDEN void
#if _XOPEN_SOURCE
sigkid( pid )
int pid;
#else
sigkid()
#endif
{
	exit(0);
}


/* 			W G L _ X M I T _ S C A N L I N E S
 *
 * Note: unlike sgi_xmit_scanlines, this function updates an arbitrary
 * rectangle of the frame buffer
 */
HIDDEN void
wgl_xmit_scanlines( ifp, ybase, nlines, xbase, npix )
register FBIO	*ifp;
int		ybase;
int		nlines;
int		xbase;
int		npix;
{
	register int	y;
	register int	n;
	int		sw_cmap;	/* !0 => needs software color map */
	struct wgl_clip	*clp;

	/* Caller is expected to handle attaching context, etc. */

	clp = &(WGL(ifp)->clip);

	if( WGL(ifp)->soft_cmap_flag  && SGI(ifp)->mi_cmap_flag )  {
		sw_cmap = 1;
	} else {
		sw_cmap = 0;
	}

	if(xbase > clp->xpixmax || ybase > clp->ypixmax)
		return;
	if(xbase < clp->xpixmin)
		xbase = clp->xpixmin;
	if(ybase < clp->ypixmin)
		ybase = clp->ypixmin;

	if((xbase + npix -1 ) > clp->xpixmax)
		npix = clp->xpixmax - xbase + 1;
	if((ybase + nlines - 1) > clp->ypixmax)
		nlines = clp->ypixmax - ybase + 1;

	if(!WGL(ifp)->use_ext_ctrl){
	if (!WGL(ifp)->copy_flag){
		/*
		 * Blank out areas of the screen around the image, if exposed.
		 * In COPY mode, this is done in backbuffer_to_screen().
		 */

		/* Blank out area left of image */
		glColor3b( 0, 0, 0 );
		if( clp->xscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* Blank out area below image */
		if( clp->yscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			CLIP_XTRA);

		/* Blank out area right of image */
		if( clp->xscrmax >= ifp->if_width )  glRecti(
			ifp->if_width - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* Blank out area above image */
		if( clp->yscrmax >= ifp->if_height )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			ifp->if_height- CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

	} else if (WGL(ifp)->front_flag) {
		/* in COPY mode, always draw full sized image into backbuffer.
		 * backbuffer_to_screen() is used to update the front buffer
		 */
		glDrawBuffer(GL_BACK);
		WGL(ifp)->front_flag = 0;
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();	/* store current view clipping matrix*/
		glLoadIdentity();
		glOrtho( -0.25, ((GLdouble) WGL(ifp)->vp_width)-0.25,
			-0.25, ((GLdouble) WGL(ifp)->vp_height)-0.25,
			-1.0, 1.0);
		glPixelZoom( 1.0, 1.0);
	}
	}

	if( sw_cmap ) {
		/* Software colormap each line as it's transmitted */
		register int	x;
		register struct wgl_pixel	*wglp;
		register struct wgl_pixel	*op;

		y = ybase;
		if(CJDEBUG) printf("Doing sw colormap xmit\n");
		/* Perform software color mapping into temp scanline */
		op = SGI(ifp)->mi_scanline;
		for( n=nlines; n>0; n--, y++ )  {
			wglp = (struct wgl_pixel *)&ifp->if_mem[
				(y*SGI(ifp)->mi_memwidth)*
				sizeof(struct wgl_pixel) ];
			for( x=xbase+npix-1; x>=xbase; x-- )  {
				op[x].red   = CMR(ifp)[wglp[x].red];
				op[x].green = CMG(ifp)[wglp[x].green];
				op[x].blue  = CMB(ifp)[wglp[x].blue];
			}

			glPixelStorei(GL_UNPACK_SKIP_PIXELS,xbase);
			glRasterPos2i(xbase,y);
			glDrawPixels(npix,1,GL_BGRA_EXT,GL_UNSIGNED_BYTE,
					(const GLvoid *) op);

		}

	} else  {
		/* No need for software colormapping */

		glPixelStorei(GL_UNPACK_ROW_LENGTH,SGI(ifp)->mi_memwidth);
		glPixelStorei(GL_UNPACK_SKIP_PIXELS,xbase);
		glPixelStorei(GL_UNPACK_SKIP_ROWS,ybase);

		glRasterPos2i(xbase,ybase);
		glDrawPixels(npix,nlines,GL_BGRA_EXT,GL_UNSIGNED_BYTE,
				(const GLvoid *) ifp->if_mem);
	}
}

LONG WINAPI MainWndProc (
    HWND    hWnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch (uMsg) {
    case WM_PAINT:
#if 0
	fprintf(stderr, "XXXMainWndProc: msg - WM_PAINT\n");
#endif
	if(!WGL(saveifp)->use_ext_ctrl)
	    expose_callback(saveifp,0);
	break;
    case WM_LBUTTONDOWN:
	break;
    case WM_RBUTTONDOWN:
	break;
    case WM_MBUTTONDOWN:
	break;
    case WM_CLOSE:
#if 0
	fprintf(stderr, "XXXMainWndProc: msg - WM_CLOSE\n");
#endif
	WGL(saveifp)->alive = -1;
	break;
    case WM_LBUTTONUP:
	WGL(saveifp)->alive = 0;
	break;
    case WM_RBUTTONUP:
	WGL(saveifp)->alive = 0;
	break;
    case WM_MBUTTONUP:
	WGL(saveifp)->alive = 0;
	break;
    case WM_KEYDOWN:
	break;
    case WM_KEYUP:
#if 0
	fprintf(stderr, "XXXMainWndProc: msg - WM_KEYUP\n");
#endif
	WGL(saveifp)->alive = 0;
	break;
    case WM_SIZE:
	{
#if 0
	    if(conf->width == WGL(ifp)->win_width &&
	       conf->height == WGL(ifp)->win_height)
		return;

	    wgl_configureWindow(ifp, conf->width, conf->height);
#endif
	}
    default:
      return DefWindowProc (hWnd, uMsg, wParam, lParam);
    }

    return 1;
}
HIDDEN int
wgl_open( ifp, file, width, height )
FBIO	*ifp;
char	*file;
int	width, height;
{
	static char	title[128];
	int		mode,  ret;
	HWND hwnd;
	HDC hdc;
	HGLRC glxc;
	HINSTANCE hinstance;
	DWORD Dword;
	WNDCLASS   wndclass;

	FB_CK_FBIO(ifp);

	saveifp = ifp;


	/*
	 *  First, attempt to determine operating mode for this open,
	 *  based upon the "unit number" or flags.
	 *  file = "/dev/wgl###"
	 */
	mode = MODE_2LINGERING;

	if( file != NULL )  {
		register char *cp;
		char	modebuf[80];
		char	*mp;
		int	alpha;
		struct	modeflags *mfp;

		if (strncmp(file, ifp->if_name, strlen(ifp->if_name))) {
			/* How did this happen? */
			mode = 0;
		} else {
			/* Parse the options */
			alpha = 0;
			mp = &modebuf[0];
			cp = &file[8];
			while( *cp != '\0' && !isspace(*cp) ) {
				*mp++ = *cp;	/* copy it to buffer */
				if( isdigit(*cp) ) {
					cp++;
					continue;
				}
				alpha++;
				for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
					if( mfp->c == *cp ) {
						mode = (mode&~mfp->mask)|mfp->value;
						break;
					}
				}
				if( mfp->c == '\0' && *cp != '-' ) {
					fb_log( "if_wgl: unknown option '%c' ignored\n", *cp );
				}
				cp++;
			}
			*mp = '\0';
			if( !alpha )
				mode |= atoi( modebuf );
		}

		if( (mode & MODE_15MASK) == MODE_15ZAP ) {
			/* Only task: Attempt to release shared memory segment */
			wgl_zapmem();
			return(-1);
		}
	}
	ifp->if_mode = mode;

	/*
	 *  Allocate extension memory sections,
	 *  addressed by SGI(ifp)->mi_xxx and WGL(ifp)->xxx
	 */

	if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
		fb_log("wgl_open:  sgiinfo malloc failed\n");
		return(-1);
	}
	if( (WGLL(ifp) = (char *)calloc( 1, sizeof(struct wglinfo) )) == NULL )  {
		fb_log("wgl_open:  wglinfo malloc failed\n");
		return(-1);
	}

	SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */

	if (wgl_nwindows && !multiple_windows){
		fb_log("Warning - wgl_open: Multiple windows opened. Use /dev/wglm for first window!");
	}

	/* Anyone can turn this on; no one can turn it off */
	if( (ifp->if_mode & MODE_5MASK) == MODE_5MULTI )
		multiple_windows = 1;

	/* the Silicon Graphics Library Window management routines
	 * use shared memory. This causes lots of problems when you
	 * want to pass a window structure to a child process.
	 * One hack to get around this is to immediately fork
	 * and create a child process and sleep until the child
	 * sends a kill signal to the parent process. (in FBCLOSE)
	 * This allows us to use the traditional fb utility programs
	 * as well as allow the frame buffer window to remain around
	 * until killed by the menu subsystem.
	 */

	if( (ifp->if_mode & MODE_3MASK) == MODE_3FULLSCR )  {
		/* Bump default size up to full screen, since we have it all */
		ifp->if_width = XMAXSCREEN+1;		/* 1280 */
		ifp->if_height = YMAXSCREEN+1;		/* 1024 */
	}

	/* use defaults if invalid width and height specified */
	if( width <= 0 )
		width = ifp->if_width;
	if( height <= 0 )
		height = ifp->if_height;
	/* use max values if width and height are greater */
	if ( width > ifp->if_max_width )
		width = ifp->if_max_width;
	if ( height > ifp->if_max_height)
		height = ifp->if_max_height;

	ifp->if_width = width;
	ifp->if_height = height;


	if( (ifp->if_mode & MODE_3MASK) == MODE_3WINDOW )  {
		SGI(ifp)->mi_curs_on = 1;
	}  else  {
		/* MODE_3MASK == MODE_3FULLSCR */
		SGI(ifp)->mi_curs_on = 0;
	}

	/* Build a descriptive window title bar */
	(void)snprintf( title, 128, "BRL-CAD /dev/wgl %s, %s",
		((ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT) ?
			"Transient Win":
			"Lingering Win",
		((ifp->if_mode & MODE_1MASK) == MODE_1MALLOC) ?
			"Private Mem" :
			"Shared Mem" );


	/* initialize window state variables before calling wgl_getmem */
	ifp->if_zoomflag = 0;
	ifp->if_xzoom = 1;	/* for zoom fakeout */
	ifp->if_yzoom = 1;	/* for zoom fakeout */
	ifp->if_xcenter = width/2;
	ifp->if_ycenter = height/2;
	SGI(ifp)->mi_pid = bu_process_id();

	/* Attach to shared memory, potentially with a screen repaint */
	if( wgl_getmem(ifp) < 0 )
		return(-1);

	/* Register the frame class */
    wndclass.style         = 0;
    wndclass.lpfnWndProc   = (WNDPROC)MainWndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = Tk_GetHINSTANCE();
    wndclass.hIcon         = LoadIcon (Tk_GetHINSTANCE(), "Win OpenGL");
    wndclass.hCursor       = LoadCursor (NULL,IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wndclass.lpszMenuName  = "Win OpenGL";
    wndclass.lpszClassName = "Win OpenGL";

	ret = RegisterClass (&wndclass);

	WGL(ifp)->hwnd =  CreateWindow(
  "Win OpenGL",  /* pointer to registered class name */
  title, /* pointer to window name */
  WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,        /* window style */
  CW_USEDEFAULT,                /* horizontal position of window */
  CW_USEDEFAULT,                /* vertical position of window */
  ifp->if_width,           /* window width */
  ifp->if_height,          /* window height */
  NULL,      /* handle to parent or owner window */
  NULL,          /* handle to menu or child-window identifier */
  Tk_GetHINSTANCE(),     /* handle to application instance */
  NULL        /* pointer to window-creation data */
);

	Dword = GetLastError();

	hinstance=Tk_GetHINSTANCE();
	hwnd = WGL(ifp)->hwnd;
	WGL(ifp)->hdc = GetDC(WGL(ifp)->hwnd);
	hdc = WGL(ifp)->hdc;


	/* Choose an appropriate visual. */
	if( (WGL(ifp)->vip = wgl_choose_visual(ifp)) == NULL ) {
		fb_log("wgl_open: Couldn't find an appropriate visual.  Exiting.\n");
		return (-1);
	}

	WGL(ifp)->glxc = wglCreateContext(WGL(ifp)->hdc);
	glxc = WGL(ifp)->glxc;

	/* count windows */
	wgl_nwindows++;

	WGL(ifp)->alive = 1;
	WGL(ifp)->firstTime = 1;

	ShowWindow(WGL(ifp)->hwnd,SW_SHOW);
	UpdateWindow(WGL(ifp)->hwnd);


	/* Loop through events until first exposure event is processed */
	/*	while (WGL(ifp)->firstTime == 1)
		wgl_do_event(ifp);
	*/

	return 0;

}


int
wgl_open_existing(ifp, argc, argv)
FBIO *ifp;
int argc;
char **argv;
{
    Display *dpy;
    Window win;
    Colormap cmap;
    PIXELFORMATDESCRIPTOR *vip;
    HDC hdc;
    int width;
    int height;
    HGLRC glxc;
    int double_buffer;
    int soft_cmap;

    if(argc != 11)
	return -1;

    if(sscanf(argv[1], "%llu", (unsigned __int64 *)&dpy) != 1)
	return -1;

    if(sscanf(argv[2], "%llu", (unsigned __int64 *)&win) != 1)
	return -1;

    if(sscanf(argv[3], "%llu", (unsigned __int64 *)&cmap) != 1)
	return -1;

    if(sscanf(argv[4], "%llu", (unsigned __int64 *)&vip) != 1)
	return -1;

    if(sscanf(argv[5], "%llu", (unsigned __int64 *)&hdc) != 1)
	return -1;

    if(sscanf(argv[8], "%llu", (unsigned __int64 *)&glxc) != 1)
	return -1;

    if(sscanf(argv[6], "%d", &width) != 1)
	return -1;

    if(sscanf(argv[7], "%d", &height) != 1)
	return -1;

    if(sscanf(argv[9], "%d", &double_buffer) != 1)
	return -1;

    if(sscanf(argv[10], "%d", &soft_cmap) != 1)
	return -1;

  return _wgl_open_existing(ifp, dpy, win, cmap, vip, hdc, width, height,
			    glxc, double_buffer, soft_cmap);
}

#if 0
FBIO *ifp;
Display *dpy;
Window win;
Colormap cmap;
PIXELFORMATDESCRIPTOR *vip;
int width;
int height;
HGLRC glxc;
int double_buffer;
int soft_cmap;
#endif

int
_wgl_open_existing(FBIO *ifp,
		   Display *dpy,
		   Window win,
		   Colormap cmap,
		   PIXELFORMATDESCRIPTOR *vip,
		   HDC hdc,
		   int width,
		   int height,
		   HGLRC glxc,
		   int double_buffer,
		   int soft_cmap)
{

  /*XXX for now use private memory */
  ifp->if_mode = MODE_1MALLOC;

  /*
   *  Allocate extension memory sections,
   *  addressed by SGI(ifp)->mi_xxx and WGL(ifp)->xxx
   */

  if( (SGIL(ifp) = (char *)calloc( 1, sizeof(struct sgiinfo) )) == NULL )  {
    fb_log("wgl_open:  sgiinfo malloc failed\n");
    return -1;
  }
  if( (WGLL(ifp) = (char *)calloc( 1, sizeof(struct wglinfo) )) == NULL )  {
    fb_log("wgl_open:  wglinfo malloc failed\n");
    return -1;
  }

  WGL(ifp)->use_ext_ctrl = 1;

  SGI(ifp)->mi_shmid = -1;	/* indicate no shared memory */
  multiple_windows = 1;
  ifp->if_width = ifp->if_max_width = width;
  ifp->if_height = ifp->if_max_height = height;

  WGL(ifp)->win_width = WGL(ifp)->vp_width = width;
  WGL(ifp)->win_height = WGL(ifp)->vp_height = height;

  SGI(ifp)->mi_curs_on = 1;

  /* initialize window state variables before calling wgl_getmem */
  ifp->if_zoomflag = 0;
  ifp->if_xzoom = 1;	/* for zoom fakeout */
  ifp->if_yzoom = 1;	/* for zoom fakeout */
  ifp->if_xcenter = width/2;
  ifp->if_ycenter = height/2;
  SGI(ifp)->mi_pid = bu_process_id();

  /* Attach to shared memory, potentially with a screen repaint */
  if(wgl_getmem(ifp) < 0)
    return -1;

  WGL(ifp)->dispp = dpy;
  /* ifp->if_selfd = ConnectionNumber(WGL(ifp)->dispp); */

  WGL(ifp)->vip = vip;
  WGL(ifp)->glxc = glxc;
  SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);
  WGL(ifp)->soft_cmap_flag = soft_cmap;
  SGI(ifp)->mi_doublebuffer = double_buffer;
  WGL(ifp)->xcmap = cmap;

  WGL(ifp)->wind = win;
  WGL(ifp)->hdc = hdc;
  ++wgl_nwindows;

  WGL(ifp)->alive = 1;
  WGL(ifp)->firstTime = 1;

  wgl_clipper(ifp);

  return 0;
}

HIDDEN int
wgl_final_close( ifp )
FBIO	*ifp;
{

  if( CJDEBUG ) {
      printf("wgl_final_close: All done...goodbye!\n");
  }

  if (WGL(ifp)->glxc) {
      wglDeleteContext(WGL(ifp)->glxc);
  }
  if (WGL(ifp)->hdc) {
      ReleaseDC(WGL(ifp)->hwnd, WGL(ifp)->hdc);
  }
  DestroyWindow(WGL(ifp)->hwnd);

  if( SGIL(ifp) != NULL ) {
      /* free up memory associated with image */
      
      /* free private memory */
      (void)free( ifp->if_mem );
      /* free state information */
      (void)free( (char *)SGIL(ifp) );
      SGIL(ifp) = NULL;
  }

  if( WGLL(ifp) != NULL) {
      (void) free( (char *)WGLL(ifp) );
      WGLL(ifp) = NULL;
  }

  wgl_nwindows--;
  return(0);
}


HIDDEN int
wgl_close( ifp )
FBIO	*ifp;
{

	wgl_flush( ifp );

	/* only the last open window can linger -
	 * call final_close if not lingering
	 */
	if( wgl_nwindows > 1 ||
	    (ifp->if_mode & MODE_2MASK) == MODE_2TRANSIENT )
		return wgl_final_close( ifp );

	if( CJDEBUG )
		printf("wgl_close: remaining open to linger awhile.\n");

	/*
	 *  else:
	 *  LINGER mode.  Don't return to caller until user mouses "close"
	 *  menu item.  This may delay final processing in the calling
	 *  function for some time, but the assumption is that the user
	 *  wishes to compare this image with others.
	 *
	 *  Since we plan to linger here, long after our invoker
	 *  expected us to be gone, be certain that no file descriptors
	 *  remain open to associate us with pipelines, network
	 *  connections, etc., that were ALREADY ESTABLISHED before
	 *  the point that fb_open() was called.
	 *
	 *  The simple for i=0..20 loop will not work, because that
	 *  smashes some window-manager files.  Therefore, we content
	 *  ourselves with eliminating stdin.
	 */
	fclose( stdin );

	/* Ignore likely signals, perhaps in the background,
	 * from other typing at the keyboard
	 */
	/*
	  (void)signal( SIGHUP, SIG_IGN );
	  (void)signal( SIGINT, SIG_IGN );
	  (void)signal( SIGQUIT, SIG_IGN );
	  (void)signal( SIGALRM, SIG_IGN );
	*/

	while (0 < WGL(ifp)->alive)
	    wgl_do_event(ifp);

	return 0;
}

int
wgl_close_existing(FBIO *ifp)
{
    /*
      if(WGL(ifp)->cursor)
	  XDestroyWindow(WGL(ifp)->dispp, WGL(ifp)->cursor);
    */

  if( SGIL(ifp) != NULL ) {
    /* free up memory associated with image */
      /* free private memory */
      (void)free( ifp->if_mem );
    /* free state information */
    (void)free( (char *)SGIL(ifp) );
    SGIL(ifp) = NULL;
  }

  if( WGLL(ifp) != NULL) {
    (void) free( (char *)WGLL(ifp) );
    WGLL(ifp) = NULL;
  }

  return 0;
}

/*
 *			W G L _ P O L L
 *
 *	Handle any pending input events
 */
HIDDEN int
wgl_poll(ifp)
FBIO	*ifp;
{
	wgl_do_event(ifp);

	if (WGL(ifp)->alive < 0)
	    return(1);
	else
	    return(0);
}

/*
 *			W G L _ F R E E
 *
 *  Free shared memory resources, and close.
 */
HIDDEN int
wgl_free( ifp )
FBIO	*ifp;
{
	int	ret;

	if(CJDEBUG) printf("entering  wgl_free\n");
	/* Close the framebuffer */
	ret = wgl_final_close( ifp );

	if( (ifp->if_mode & MODE_1MASK) == MODE_1SHARED ) {
		/* If shared mem, release the shared memory segment */
		wgl_zapmem();
	}
	return ret;
}


HIDDEN int
wgl_clear( ifp, pp )
FBIO	*ifp;
unsigned char	*pp;		/* pointer to beginning of memory segment*/
{
	struct wgl_pixel		bg;
	register struct wgl_pixel      *wglp;
	register int			cnt;
	register int			y;

	if( CJDEBUG ) printf("entering wgl_clear\n");

	if (multiple_windows) {
		if (wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc)==False){
		fb_log("Warning, wgl_clear: wglMakeCurrent unsuccessful.\n");
		}
	}

	/* Set clear colors */
	if ( pp != RGBPIXEL_NULL)  {
		bg.alpha = 0;
		bg.red   = (pp)[RED];
		bg.green = (pp)[GRN];
		bg.blue  = (pp)[BLU];
		glClearColor( pp[RED]/255.0, pp[GRN]/255.0, pp[BLU]/255.0, 0.0 );
	} else {
		bg.alpha = 0;
		bg.red   = 0;
		bg.green = 0;
		bg.blue  = 0;
		glClearColor( 0, 0, 0, 0 );
	}

	/* Flood rectangle in shared memory */
	for( y=0; y < ifp->if_height; y++ )  {
		wglp = (struct wgl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+0)*sizeof(struct wgl_pixel) ];
		for( cnt=ifp->if_width-1; cnt >= 0; cnt-- )  {
			*wglp++ = bg;	/* struct copy */
		}
	}


	/* Update screen */
	if(WGL(ifp)->use_ext_ctrl){
		glClear(GL_COLOR_BUFFER_BIT);
	}else{
	if ( WGL(ifp)->copy_flag){
		/* COPY mode: clear both buffers */
		if (WGL(ifp)->front_flag){
			glDrawBuffer(GL_BACK);
			glClear(GL_COLOR_BUFFER_BIT);
			glDrawBuffer(GL_FRONT);
			glClear(GL_COLOR_BUFFER_BIT);
		} else {
			glDrawBuffer(GL_FRONT);
			glClear(GL_COLOR_BUFFER_BIT);
			glDrawBuffer(GL_BACK);
			glClear(GL_COLOR_BUFFER_BIT);
		}
	} else {
		glClear(GL_COLOR_BUFFER_BIT);
		if(SGI(ifp)->mi_doublebuffer){
			SwapBuffers( WGL(ifp)->hdc);
		}
	}

	if (multiple_windows) {
		/* unattach context for other threads to use */
		wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc);
	}
	}

	return(0);
}


/*
 *			W G L _ V I E W
 */
HIDDEN int
wgl_view( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	xcenter, ycenter;
int	xzoom, yzoom;
{
	struct wgl_clip *clp;

	if(CJDEBUG) printf("entering wgl_view\n");

	if( xzoom < 1 ) xzoom = 1;
	if( yzoom < 1 ) yzoom = 1;
	if( ifp->if_xcenter == xcenter && ifp->if_ycenter == ycenter
	  && ifp->if_xzoom == xzoom && ifp->if_yzoom == yzoom )
		return(0);

	if( xcenter < 0 || xcenter >= ifp->if_width )
		return(-1);
	if( ycenter < 0 || ycenter >= ifp->if_height )
		return(-1);
	if( xzoom >= ifp->if_width || yzoom >= ifp->if_height )
		return(-1);

	ifp->if_xcenter = xcenter;
	ifp->if_ycenter = ycenter;
	ifp->if_xzoom = xzoom;
	ifp->if_yzoom = yzoom;

	if( ifp->if_xzoom > 1 || ifp->if_yzoom > 1 )
		ifp->if_zoomflag = 1;
	else	ifp->if_zoomflag = 0;


	if(WGL(ifp)->use_ext_ctrl){
		wgl_clipper(ifp);
	}else{
	if (multiple_windows) {
		if (wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc)==False){
			fb_log("Warning, wgl_view: wglMakeCurrent unsuccessful.\n");
		}
	}

	/* Set clipping matrix  and zoom level */
	glMatrixMode(GL_PROJECTION);
	if (WGL(ifp)->copy_flag && !WGL(ifp)->front_flag){
		/* COPY mode - no changes to backbuffer copy - just
		 * need to update front buffer
		 */
		glPopMatrix();
		glDrawBuffer(GL_FRONT);
		WGL(ifp)->front_flag = 1;
	}
	glLoadIdentity();

	wgl_clipper(ifp);
	clp = &(WGL(ifp)->clip);
	glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop, -1.0, 1.0);
	glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);

	if (WGL(ifp)->copy_flag){
		backbuffer_to_screen(ifp,-1);
	} else {
		wgl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if(SGI(ifp)->mi_doublebuffer){
			SwapBuffers( WGL(ifp)->hdc);
		}
	}

	if (multiple_windows) {
		/* unattach context for other threads to use */
		wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc);
	}
	}

	return(0);
}

/*
 *			W G L _ G E T V I E W
 */
HIDDEN int
wgl_getview( ifp, xcenter, ycenter, xzoom, yzoom )
FBIO	*ifp;
int	*xcenter, *ycenter;
int	*xzoom, *yzoom;
{
	if(CJDEBUG) printf("entering wgl_getview\n");

	*xcenter = ifp->if_xcenter;
	*ycenter = ifp->if_ycenter;
	*xzoom = ifp->if_xzoom;
	*yzoom = ifp->if_yzoom;

	return(0);
}


HIDDEN int
wgl_read( ifp, x, y, pixelp, count ) /*read count pixels into pixelp starting at x,y*/
FBIO	*ifp;
int	x, y;
unsigned char	*pixelp;
int	count;
{
	register short		scan_count;	/* # pix on this scanline */
	register unsigned char	*cp;
	int			ret;
	register unsigned int	n;
	register struct wgl_pixel	*wglp;

	if(CJDEBUG) printf("entering wgl_read\n");

	if( x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
		return(-1);

	ret = 0;
	cp = (unsigned char *)(pixelp);

	while( count )  {
		if( y >= ifp->if_height )
			break;

		if ( count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = count;

		wglp = (struct wgl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct wgl_pixel) ];

		n = scan_count;
		while( n )  {
			cp[RED] = wglp->red;
			cp[GRN] = wglp->green;
			cp[BLU] = wglp->blue;
			wglp++;
			cp += 3;
			n--;
		}
		ret += scan_count;
		count -= scan_count;
		x = 0;
		/* Advance upwards */
		if( ++y >= ifp->if_height )
			break;
	}
	return(ret);
}


HIDDEN int
wgl_write( ifp, xstart, ystart, pixelp, count ) /*write count pixels from pixelp starting at xstart,ystart*/
FBIO	*ifp;
int	xstart, ystart;
const unsigned char	*pixelp;
int	count;
{
	register short		scan_count;	/* # pix on this scanline */
	register unsigned char	*cp;
	int			ret;
	int			ybase;
	register int		pix_count;	/* # pixels to send */
	register int		x;
	register int		y;

	if(CJDEBUG) printf("entering wgl_write\n");

	/* fast exit cases */
	if( (pix_count = count) == 0 )
		return 0;	/* OK, no pixels transferred */
	if( pix_count < 0 )
		return -1;	/* ERROR */

	x = xstart;
	ybase = y = ystart;

	if( x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
		return(-1);

	ret = 0;
	cp = (unsigned char *)(pixelp);

	while( pix_count )  {
		register unsigned int n;
		register struct wgl_pixel	*wglp;

		if( y >= ifp->if_height )
			break;

		if ( pix_count >= ifp->if_width-x )
			scan_count = ifp->if_width-x;
		else
			scan_count = pix_count;

		wglp = (struct wgl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct wgl_pixel) ];

		n = scan_count;
		if( (n & 3) != 0 )  {
			/* This code uses 60% of all CPU time */
			while( n )  {
				/* alpha channel is always zero */
				wglp->red   = cp[RED];
				wglp->green = cp[GRN];
				wglp->blue  = cp[BLU];
				wglp++;
				cp += 3;
				n--;
			}
		} else {
			while( n )  {
				/* alpha channel is always zero */
				wglp[0].red   = cp[RED+0*3];
				wglp[0].green = cp[GRN+0*3];
				wglp[0].blue  = cp[BLU+0*3];
				wglp[1].red   = cp[RED+1*3];
				wglp[1].green = cp[GRN+1*3];
				wglp[1].blue  = cp[BLU+1*3];
				wglp[2].red   = cp[RED+2*3];
				wglp[2].green = cp[GRN+2*3];
				wglp[2].blue  = cp[BLU+2*3];
				wglp[3].red   = cp[RED+3*3];
				wglp[3].green = cp[GRN+3*3];
				wglp[3].blue  = cp[BLU+3*3];
				wglp += 4;
				cp += 3*4;
				n -= 4;
			}
		}
		ret += scan_count;
		pix_count -= scan_count;
		x = 0;
		if( ++y >= ifp->if_height )
			break;
	}

	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return ret;

	if (multiple_windows) {
		if (wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc)==False){
		    fb_log("Warning, wgl_write: wglMakeCurrent unsuccessful.\n");
		}
	}

	if(!WGL(ifp)->use_ext_ctrl){
	if( xstart + count <= ifp->if_width  )  {
		/* "Fast path" case for writes of less than one scanline.
		 * The assumption is that there will be a lot of short
		 * writes, and it's best just to ignore the backbuffer
		 */
#if 0
		if ( SGI(ifp)->mi_doublebuffer ) {
			/* "turn off" doublebuffering*/
			SGI(ifp)->mi_doublebuffer = 0;
			glDrawBuffer(GL_FRONT);
		}
#endif
		wgl_xmit_scanlines( ifp, ybase, 1, xstart, count );
		if (WGL(ifp)->copy_flag){
			/* repaint one scanline from backbuffer */
			backbuffer_to_screen(ifp,ybase);
		}
	} else {
		/* Normal case -- multi-pixel write */
		if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
			wgl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
			SwapBuffers( WGL(ifp)->hdc);
		}
		else { /* just write rectangle */
			wgl_xmit_scanlines( ifp, ybase, y-ybase, 0, ifp->if_width );
			if (WGL(ifp)->copy_flag){
				backbuffer_to_screen(ifp,-1);
			}
		}
	}

	if (multiple_windows) {
	    /* unattach context for other threads to use */
	    wglMakeCurrent(WGL(ifp)->hdc,NULL);
	}
	}

	return(ret);

}

/*
 *			W G L _ W R I T E R E C T
 *
 *  The task of this routine is to reformat the pixels into
 *  SGI internal form, and then arrange to have them sent to
 *  the screen separately.
 */
HIDDEN int
wgl_writerect(FBIO *ifp,
	      int xmin,
	      int ymin,
	      int width,
	      int height,
	      const unsigned char *pp)
{
	register int		x;
	register int		y;
	register unsigned char	*cp;
	register struct wgl_pixel	*wglp;

	if(CJDEBUG) printf("entering wgl_writerect\n");


	if( width <= 0 || height <= 0 )
		return(0);  /* do nothing */
	if( xmin < 0 || xmin+width > ifp->if_width ||
	    ymin < 0 || ymin+height > ifp->if_height )
		return(-1); /* no can do */

	cp = (unsigned char *)(pp);
	for( y = ymin; y < ymin+height; y++ )  {
		wglp = (struct wgl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct wgl_pixel) ];
		for( x = xmin; x < xmin+width; x++ )  {
			/* alpha channel is always zero */
			wglp->red   = cp[RED];
			wglp->green = cp[GRN];
			wglp->blue  = cp[BLU];
			wglp++;
			cp += 3;
		}
	}

	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return width*height;

	if(!WGL(ifp)->use_ext_ctrl){
	if (multiple_windows) {
	if (wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc)==False){
		fb_log("Warning, wgl_writerect: wglMakeCurrent unsuccessful.\n");
	}
	}

	if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
		wgl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		SwapBuffers( WGL(ifp)->hdc);
	}
	else { /* just write rectangle*/
		wgl_xmit_scanlines( ifp, ymin, height, xmin, width );
		if (WGL(ifp)->copy_flag){
			backbuffer_to_screen(ifp,-1);
		}
	}

	if (multiple_windows) {
	/* unattach context for other threads to use */
	wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc);
	}
	}

	return(width*height);
}


/*
 *			W G L _ B W W R I T E R E C T
 *
 *  The task of this routine is to reformat the pixels into
 *  SGI internal form, and then arrange to have them sent to
 *  the screen separately.
 */
HIDDEN int
wgl_bwwriterect(FBIO *ifp,
		int xmin,
		int ymin,
		int width,
		int height,
		const unsigned char *pp)
{
	register int		x;
	register int		y;
	register unsigned char	*cp;
	register struct wgl_pixel	*wglp;

	if(CJDEBUG) printf("entering wgl_bwwriterect\n");


	if( width <= 0 || height <= 0 )
		return(0);  /* do nothing */
	if( xmin < 0 || xmin+width > ifp->if_width ||
	    ymin < 0 || ymin+height > ifp->if_height )
		return(-1); /* no can do */

	cp = (unsigned char *)(pp);
	for( y = ymin; y < ymin+height; y++ )  {
		wglp = (struct wgl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct wgl_pixel) ];
		for( x = xmin; x < xmin+width; x++ )  {
			register int	val;
			/* alpha channel is always zero */
			wglp->red   = (val = *cp++);
			wglp->green = val;
			wglp->blue  = val;
			wglp++;
		}
	}

	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )
		return width*height;

	if(!WGL(ifp)->use_ext_ctrl){
	if (multiple_windows) {
	if (wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc)==False){
		fb_log("Warning, wgl_writerect: wglMakeCurrent unsuccessful.\n");
	}
	}

	if ( SGI(ifp)->mi_doublebuffer) { /* refresh whole screen */
		wgl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		SwapBuffers( WGL(ifp)->hdc);
	}
	else { /* just write rectangle*/
		wgl_xmit_scanlines( ifp, ymin, height, xmin, width );
		if (WGL(ifp)->copy_flag){
			backbuffer_to_screen(ifp,-1);
		}
	}

	if (multiple_windows) {
	/* unattach context for other threads to use */
	wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc);
	}
	}

	return(width*height);
}


HIDDEN int
wgl_rmap(register FBIO *ifp,
	 register ColorMap *cmp)
{
	register int i;

	if(CJDEBUG) printf("entering wgl_rmap\n");

	/* Just parrot back the stored colormap */
	for( i = 0; i < 256; i++)  {
		cmp->cm_red[i]   = CMR(ifp)[i]<<8;
		cmp->cm_green[i] = CMG(ifp)[i]<<8;
		cmp->cm_blue[i]  = CMB(ifp)[i]<<8;
	}
	return(0);
}

/*
 *			I S _ L I N E A R _ C M A P
 *
 *  Check for a color map being linear in R, G, and B.
 *  Returns 1 for linear map, 0 for non-linear map
 *  (ie, non-identity map).
 */
HIDDEN int
is_linear_cmap(register FBIO *ifp)
{
	register int i;

	for( i=0; i<256; i++ )  {
		if( CMR(ifp)[i] != i )  return(0);
		if( CMG(ifp)[i] != i )  return(0);
		if( CMB(ifp)[i] != i )  return(0);
	}
	return(1);
}

/*
 *			W G L _ C M I N I T
 */
HIDDEN void
wgl_cminit(register FBIO *ifp)
{
	register int	i;

	for( i = 0; i < 256; i++)  {
		CMR(ifp)[i] = i;
		CMG(ifp)[i] = i;
		CMB(ifp)[i] = i;
	}
}

/*
 *			 W G L _ W M A P
 */
HIDDEN int
wgl_wmap(register FBIO *ifp,
	 register const ColorMap *cmp)
{
	register int	i;
	int		prev;	/* !0 = previous cmap was non-linear */

	if(CJDEBUG) printf("entering wgl_wmap\n");

	prev = SGI(ifp)->mi_cmap_flag;
	if ( cmp == COLORMAP_NULL)  {
		wgl_cminit( ifp );
	} else {
		for(i = 0; i < 256; i++)  {
			CMR(ifp)[i] = cmp-> cm_red[i]>>8;
			CMG(ifp)[i] = cmp-> cm_green[i]>>8;
			CMB(ifp)[i] = cmp-> cm_blue[i]>>8;
		}
	}
	SGI(ifp)->mi_cmap_flag = !is_linear_cmap(ifp);


	if(!WGL(ifp)->use_ext_ctrl){
	if( WGL(ifp)->soft_cmap_flag )  {
		/* if current and previous maps are linear, return */
		if( SGI(ifp)->mi_cmap_flag == 0 && prev == 0 )  return(0);

		/* Software color mapping, trigger a repaint */

		if (multiple_windows) {
		if (wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc)==False){
			fb_log("Warning, wgl_wmap: wglMakeCurrent unsuccessful.\n");
		}
		}

		wgl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if(SGI(ifp)->mi_doublebuffer){
			SwapBuffers( WGL(ifp)->hdc);
		} else if (WGL(ifp)->copy_flag) {
			backbuffer_to_screen(ifp,-1);
		}
		if (multiple_windows) {
		/* unattach context for other threads to use, also flushes */
		wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc);
		}
	} else {
		/* Send color map to hardware */
		/* This code has yet to be tested */

/*	    	for (i = 0; i < 256; i++) {
			color_cell[i].pixel = i;
			color_cell[i].red = CMR(ifp)[i];
			color_cell[i].green = CMG(ifp)[i];
			color_cell[i].blue = CMB(ifp)[i];
			color_cell[i].flags = DoRed | DoGreen | DoBlue;
		}
		XStoreColors(WGL(ifp)->dispp, WGL(ifp)->xcmap, color_cell, 256);*/
	}
	}

	return(0);
}

/*
 *			W G L _ H E L P
 */
HIDDEN int
wgl_help(FBIO *ifp)
{
	struct	modeflags *mfp;
	PIXELFORMATDESCRIPTOR *visual = WGL(ifp)->vip;

	fb_log( "Description: %s\n", ifp->if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width height: %d %d\n",
		ifp->if_max_width,
		ifp->if_max_height );
	fb_log( "Default width height: %d %d\n",
		ifp->if_width,
		ifp->if_height );
	fb_log( "Usage: /dev/wgl[option letters]\n" );
	for( mfp = modeflags; mfp->c != '\0'; mfp++ ) {
		fb_log( "   %c   %s\n", mfp->c, mfp->help );
	}

	fb_log( "\nCurrent internal state:\n");
	fb_log( "	mi_doublebuffer=%d\n", SGI(ifp)->mi_doublebuffer );
	fb_log( "	mi_cmap_flag=%d\n", SGI(ifp)->mi_cmap_flag );
	fb_log( "	wgl_nwindows=%d\n", wgl_nwindows );
	fb_log( "	multiple_windows=%d\n", multiple_windows );

	fb_log("X11 Visual:\n");

/*	switch(visual->class) {
	case DirectColor:
		fb_log("\tDirectColor: Alterable RGB maps, pixel RGB subfield indicies\n");
		fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
		       visual->green_mask, visual->blue_mask);
		break;
	case TrueColor:
		fb_log("\tTrueColor: Fixed RGB maps, pixel RGB subfield indicies\n");
		fb_log("\tRGB Masks: 0x%x 0x%x 0x%x\n", visual->red_mask,
		       visual->green_mask, visual->blue_mask);
		break;
	case PseudoColor:
		fb_log("\tPseudoColor: Alterable RGB maps, single index\n");
		break;
	case StaticColor:
		fb_log("\tStaticColor: Fixed RGB maps, single index\n");
		break;
	case GrayScale:
		fb_log("\tGrayScale: Alterable map (R=G=B), single index\n");
		break;
	case StaticGray:
		fb_log("\tStaticGray: Fixed map (R=G=B), single index\n");
		break;
	default:
		fb_log("\tUnknown visual class %d\n",
		       visual->class);
		break;
	}
	fb_log("\tColormap Size: %d\n", visual->colormap_size);
	fb_log("\tBits per RGB: %d\n", visual->bits_per_rgb);
	fb_log("\tscreen: %d\n", visual->screen);
	fb_log("\tdepth (total bits per pixel): %d\n", visual->depth);
	if( visual->depth < 24 )
		fb_log("\tWARNING: unable to obtain full 24-bits of color, image will be quantized.\n");
*/
	return 0;
}


HIDDEN int
wgl_setcursor(FBIO *ifp,
	      const unsigned char *bits,
	      int xbits,
	      int ybits,
	      int xorig,
	      int yorig)
{
  return 0;
}


HIDDEN int
wgl_cursor(FBIO *ifp, int mode, int x, int y)
{
return 0;
}


HIDDEN int
wgl_flush(FBIO *ifp)
{
	if( (ifp->if_mode & MODE_12MASK) == MODE_12DELAY_WRITES_TILL_FLUSH )  {
		if (multiple_windows) {
			if (wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc)==False){
				fb_log("Warning, wgl_flush: wglMakeCurrent unsuccessful.\n");
			}
		}
		/* Send entire in-memory buffer to the screen, all at once */
		wgl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		if ( SGI(ifp)->mi_doublebuffer) {
			SwapBuffers( WGL(ifp)->hdc);
		} else {
			if (WGL(ifp)->copy_flag){
				backbuffer_to_screen(ifp,-1);
			}
		}
	}
	/* XFlush(WGL(ifp)->dispp); */
	glFlush();
	return(0);
}

#if 0
HIDDEN int
fb_cnull(FBIO *ifp)
{
	return(0);
}
#endif

/*
 * W G L _ C L I P P E R ( )
 *
 * Given:- the size of the viewport in pixels (vp_width, vp_height)
 *	 - the size of the framebuffer image (if_width, if_height)
 *	 - the current view center (if_xcenter, if_ycenter)
 * 	 - the current zoom (if_xzoom, if_yzoom)
 * Calculate:
 *	 - the position of the viewport in image space
 *		(xscrmin,xscrmax,yscrmin,yscrmax)
 *	 - the portion of the image which is visible in the viewport
 *		(xpixmin,xpixmax,ypixmin,ypixmax)
 */
void
wgl_clipper(register FBIO *ifp)
{
	register struct wgl_clip *clp;
	register int	i;
	double pixels;

	clp = &(WGL(ifp)->clip);

	i = WGL(ifp)->vp_width/(2*ifp->if_xzoom);
	clp->xscrmin = ifp->if_xcenter - i;
	i = WGL(ifp)->vp_width/ifp->if_xzoom;
	clp->xscrmax = clp->xscrmin + i;
	pixels = (double) i;
	clp->oleft = ((double) clp->xscrmin) - 0.25*pixels/((double) WGL(ifp)->vp_width);
	clp->oright = clp->oleft + pixels;

	i = WGL(ifp)->vp_height/(2*ifp->if_yzoom);
	clp->yscrmin = ifp->if_ycenter - i;
	i = WGL(ifp)->vp_height/ifp->if_yzoom;
	clp->yscrmax = clp->yscrmin + i;
	pixels = (double) i;
	clp->obottom = ((double) clp->yscrmin) - 0.25*pixels/((double) WGL(ifp)->vp_height);
	clp->otop = clp->obottom + pixels;

	clp->xpixmin = clp->xscrmin;
	clp->xpixmax = clp->xscrmax;
	clp->ypixmin = clp->yscrmin;
	clp->ypixmax = clp->yscrmax;

	if( clp->xpixmin < 0 )  {
		clp->xpixmin = 0;
	}

	if( clp->ypixmin < 0 )  {
		clp->ypixmin = 0;
	}

	/* In copy mode, the backbuffer copy image is limited
	 * to the viewport size; use that for clipping.
	 * Otherwise, use size of framebuffer memory segment
	 */
	if (WGL(ifp)->copy_flag) {
		if( clp->xpixmax > WGL(ifp)->vp_width-1 )  {
			clp->xpixmax = WGL(ifp)->vp_width-1;
		}
		if( clp->ypixmax > WGL(ifp)->vp_height-1 )  {
			clp->ypixmax = WGL(ifp)->vp_height-1;
		}
	} else {
		if( clp->xpixmax > ifp->if_width-1 )  {
			clp->xpixmax = ifp->if_width-1;
		}
		if( clp->ypixmax > ifp->if_height-1 )  {
			clp->ypixmax = ifp->if_height-1;
		}
	}

}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *	Call back routines and so on				   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 */

HIDDEN void
wgl_do_event(FBIO *ifp)
{
	MSG msg;
	BOOL bRet;
	/* Check and Dispatch any messages. */

    if( (bRet = GetMessage( &msg, NULL, 0, 0 )) != 0)
    {
	if (bRet == -1)
	{
	    /* handle the error and possibly exit */
	}
	else
	{
	    TranslateMessage(&msg);
	    DispatchMessage(&msg);
	}
    }

    /* let's not starve the processor */
    Sleep( 250 );
}

HIDDEN void
expose_callback(FBIO *ifp,
		int eventPtr)
{
    /*	XWindowAttributes xwa; */
	struct wgl_clip *clp;

	if( CJDEBUG ) fb_log("entering expose_callback()\n");


	if( multiple_windows || WGL(ifp)->firstTime ) {
		if( wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc) == False) {
			fb_log("Warning, libfb/expose_callback: wglMakeCurrent unsuccessful.\n");
		}
	}

	if( WGL(ifp)->firstTime ) {
		WGL(ifp)->firstTime = 0;

		/* just in case the configuration is double buffered but
		 * we want to pretend it's not
		 */

		if( !SGI(ifp)->mi_doublebuffer ) {
			glDrawBuffer(GL_FRONT);
		}

		if( (ifp->if_mode & MODE_4MASK) == MODE_4NODITH ) {
			glDisable(GL_DITHER);
		}

		/* set copy mode if possible and requested */
		if( SGI(ifp)->mi_doublebuffer &&
		    ((ifp->if_mode & MODE_11MASK)==MODE_11COPY) ) {
			/* Copy mode only works if there are two
			 * buffers to use. It conflicts with
			 * double buffering
			 */
			WGL(ifp)->copy_flag = 1;
			SGI(ifp)->mi_doublebuffer = 0;
			WGL(ifp)->front_flag = 1;
			glDrawBuffer(GL_FRONT);
		} else {
			WGL(ifp)->copy_flag = 0;
		}

		WGL(ifp)->win_width=ifp->if_width;
		WGL(ifp)->win_height=ifp->if_height;

		/* clear entire window */
		glViewport(0, 0, WGL(ifp)->win_width, WGL(ifp)->win_height);
		glClearColor(0,0,0,0);
		glClear(GL_COLOR_BUFFER_BIT);

		/* Set normal viewport size to minimum of actual window
		 * size and requested framebuffer size
		 */
		WGL(ifp)->vp_width = (WGL(ifp)->win_width < ifp->if_width) ?
				WGL(ifp)->win_width : ifp->if_width;
		WGL(ifp)->vp_height = (WGL(ifp)->win_height < ifp->if_height) ?
				WGL(ifp)->win_height : ifp->if_height;
		ifp->if_xcenter = WGL(ifp)->vp_width/2;
		ifp->if_ycenter = WGL(ifp)->vp_height/2;

		/* center viewport in window */
		SGI(ifp)->mi_xoff=(WGL(ifp)->win_width-WGL(ifp)->vp_width)/2;
		SGI(ifp)->mi_yoff=(WGL(ifp)->win_height-WGL(ifp)->vp_height)/2;
		glViewport(SGI(ifp)->mi_xoff,
			   SGI(ifp)->mi_yoff,
			   WGL(ifp)->vp_width,
			   WGL(ifp)->vp_height);
		/* initialize clipping planes and zoom */
		wgl_clipper(ifp);
		clp = &(WGL(ifp)->clip);
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop,
				-1.0,1.0);
		glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
	} else if( (WGL(ifp)->win_width > ifp->if_width) ||
		   (WGL(ifp)->win_height > ifp->if_height) ) {
		/* clear whole buffer if window larger than framebuffer */
		if( WGL(ifp)->copy_flag && !WGL(ifp)->front_flag ) {
			glDrawBuffer(GL_FRONT);
			glViewport(0, 0, WGL(ifp)->win_width,
				   WGL(ifp)->win_height);
			glClearColor(0,0,0,0);
			glClear(GL_COLOR_BUFFER_BIT);
			glDrawBuffer(GL_BACK);
		} else {
			glViewport(0, 0, WGL(ifp)->win_width,
				   WGL(ifp)->win_height);
			glClearColor(0,0,0,0);
			glClear(GL_COLOR_BUFFER_BIT);
		}
		/* center viewport */
		glViewport(SGI(ifp)->mi_xoff,
			   SGI(ifp)->mi_yoff,
			   WGL(ifp)->vp_width,
			   WGL(ifp)->vp_height);
	}

	/* repaint entire image */
	wgl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
	if( SGI(ifp)->mi_doublebuffer ) {
		SwapBuffers( WGL(ifp)->hdc);
	} else if( WGL(ifp)->copy_flag ) {
		backbuffer_to_screen(ifp,-1);
	}

	if( CJDEBUG ) {
		int dbb,db,view[4],getster,getaux;
		glGetIntegerv(GL_VIEWPORT, view);
		glGetIntegerv(GL_DOUBLEBUFFER,&dbb);
		glGetIntegerv(GL_DRAW_BUFFER,&db);
		fb_log("Viewport: x %d y %d width %d height %d\n",view[0],
		       view[1],view[2],view[3]);
		fb_log("expose: double buffered: %d, draw buffer %d\n",dbb,db);
		fb_log("front %d\tback%d\n",GL_FRONT,GL_BACK);
		glGetIntegerv(GL_STEREO,&getster);
		glGetIntegerv(GL_AUX_BUFFERS,&getaux);
		fb_log("double %d, stereo %d, aux %d\n",dbb,getster,getaux);
	}

	if( multiple_windows ) {
		/* unattach context for other threads to use */
		wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc);
	}

#if 0
	XFlush(WGL(ifp)->dispp);
	glFlush();
#endif
}

void
wgl_configureWindow(FBIO *ifp,
		    int width,
		    int height)
{
  if(width == WGL(ifp)->win_width &&
     height == WGL(ifp)->win_height)
    return;

  ifp->if_width = ifp->if_max_width = width;
  ifp->if_height = ifp->if_max_height = height;

  WGL(ifp)->win_width = WGL(ifp)->vp_width = width;
  WGL(ifp)->win_height = WGL(ifp)->vp_height = height;

  ifp->if_zoomflag = 0;
  ifp->if_xzoom = 1;
  ifp->if_yzoom = 1;
  ifp->if_xcenter = width/2;
  ifp->if_ycenter = height/2;

  wgl_getmem(ifp);
  wgl_clipper(ifp);
}

#if 0
/* reorder_cursor - reverses the order of the scanlines.
 * scanlines are byte aligned, the specified cursor is xbits
 * by ybits bits in size.
 *
 */
HIDDEN void
reorder_cursor(char *dst,
	       char *src,
	       int xbits,
	       int ybits)
{
	int xbytes;
	int i,j,k;

	if( (xbytes = xbits /8) * 8 != xbits)
		xbytes++;

	for (j=0, k=(ybits-1)*xbytes; j < ybits*xbytes; j+=xbytes, k-=xbytes){
		for (i=0; i < xbytes; i++){
			dst[j+i] = src[k+i];
		}
	}

}
#endif

/* BACKBUFFER_TO_SCREEN - copy pixels from copy on the backbuffer
 * to the front buffer. Do one scanline specified by one_y, or whole
 * screen if one_y equals -1.
 */
HIDDEN void
backbuffer_to_screen(register FBIO *ifp,
		     int one_y)
{
	struct wgl_clip *clp;

	if (!(WGL(ifp)->front_flag)){
		WGL(ifp)->front_flag = 1;
		glDrawBuffer(GL_FRONT);
		glMatrixMode(GL_PROJECTION);
		glPopMatrix();
		glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
	}

	clp = &(WGL(ifp)->clip);

	if (one_y > clp->ypixmax) {
		return;
	} else if (one_y < 0) { /* do whole visible screen */

		/* Blank out area left of image */
		glColor3b( 0, 0, 0 );
		if( clp->xscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* Blank out area below image */
		if( clp->yscrmin < 0 )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			CLIP_XTRA);

		/* We are in copy mode, so we use vp_width rather
		 * than if_width
		 */
		/* Blank out area right of image */
		if( clp->xscrmax >= WGL(ifp)->vp_width )  glRecti(
			ifp->if_width - CLIP_XTRA,
			clp->yscrmin - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* Blank out area above image */
		if( clp->yscrmax >= WGL(ifp)->vp_height )  glRecti(
			clp->xscrmin - CLIP_XTRA,
			WGL(ifp)->vp_height - CLIP_XTRA,
			clp->xscrmax + CLIP_XTRA,
			clp->yscrmax + CLIP_XTRA);

		/* copy image from backbuffer */
		glRasterPos2i(clp->xpixmin,clp->ypixmin);
		glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
			SGI(ifp)->mi_yoff + clp->ypixmin,
			clp->xpixmax - clp->xpixmin +1,
			clp->ypixmax - clp->ypixmin +1,
			GL_COLOR);


	} else if (one_y < clp->ypixmin) {
		return;
	} else { /* draw one scanline */
		glRasterPos2i(clp->xpixmin,one_y);
		glCopyPixels(SGI(ifp)->mi_xoff + clp->xpixmin,
			SGI(ifp)->mi_yoff + one_y,
			clp->xpixmax - clp->xpixmin +1,
			1,
			GL_COLOR);
	}
}

/* 		W G L _ C H O O S E _ V I S U A L
 *
 * Select an appropriate visual, and set flags.
 *
 * The user requires support for:
 *    	-OpenGL rendering in RGBA mode
 *
 * The user may desire support for:
 *	-a single-buffered OpenGL context
 *	-a double-buffered OpenGL context
 *	-hardware colormapping (DirectColor)
 *
 * We first try to satisfy all requirements and desires. If that fails,
 * we remove the desires one at a time until we succeed or until only
 * requirements are left. If at any stage more than one visual meets the
 * current criteria, the visual with the greatest depth is chosen.
 *
 * The following flags are set:
 * 	SGI(ifp)->mi_doublebuffer
 *	WGL(ifp)->soft_cmap_flag
 *
 * Return NULL on failure.
 */
HIDDEN PIXELFORMATDESCRIPTOR *
wgl_choose_visual(FBIO *ifp)
{
	int iPixelFormat ;
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
	BOOL good;

	ppfd = &pfd;

/*  ppfd = (PIXELFORMATDESCRIPTOR *)malloc(sizeof(PIXELFORMATDESCRIPTOR)); */
  iPixelFormat  = GetPixelFormat(WGL(ifp)->hdc);
  ppfd->nSize = sizeof(PIXELFORMATDESCRIPTOR);
  ppfd->nVersion = 1;
  ppfd->dwFlags =  PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER | PFD_TYPE_RGBA | PFD_STEREO;
  ppfd->iPixelType = PFD_TYPE_RGBA;
  ppfd->cColorBits = 24;
  ppfd->cRedBits = 0;
  ppfd->cRedShift = 0;
  ppfd->cGreenBits = 0;
  ppfd->cGreenShift = 0;
  ppfd->cBlueBits = 0;
  ppfd->cBlueShift = 0;
  ppfd->cAlphaBits = 0;
  ppfd->cAlphaShift = 0;
  ppfd->cAccumBits = 0;
  ppfd->cAccumRedBits = 0;
  ppfd->cAccumGreenBits = 0;
  ppfd->cAccumBlueBits = 0;
  ppfd->cAccumAlphaBits = 0;
  ppfd->cDepthBits = 32;
  ppfd->cStencilBits = 0;
  ppfd->cAuxBuffers = 0 ;
  ppfd->iLayerType = PFD_MAIN_PLANE;
  ppfd->bReserved = 0;
  ppfd->dwLayerMask = 0;
  ppfd->dwVisibleMask = 0;
  ppfd->dwDamageMask = 0;

  iPixelFormat = ChoosePixelFormat(WGL(ifp)->hdc, ppfd);
  good = SetPixelFormat(WGL(ifp)->hdc, iPixelFormat, ppfd);


  SGI(ifp)->mi_doublebuffer = 1;
  WGL(ifp)->soft_cmap_flag = 0;

  if(good) return ppfd;
  else return (PIXELFORMATDESCRIPTOR *)NULL;
}

int
wgl_refresh(FBIO *ifp,
	    int x,
	    int y,
	    int w,
	    int h)
{
  int mm;
  struct wgl_clip *clp;

  if(w < 0){
    w = -w;
    x -= w;
  }

  if(h < 0){
    h = -h;
    y -= h;
  }

#if 0
  if(glIsEnabled(GL_DEPTH_TEST)){
    glDisable(GL_DEPTH_TEST);
    dflag = 1;
  }
#endif

  glGetIntegerv(GL_MATRIX_MODE, &mm);
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();

#if 0
  glOrtho(0.0, WGL(ifp)->win_width, 0.0, WGL(ifp)->win_height, -1.0, 1.0);
#else
  wgl_clipper(ifp);
  clp = &(WGL(ifp)->clip);
  glOrtho( clp->oleft, clp->oright, clp->obottom, clp->otop, -1.0, 1.0);
  glPixelZoom((float) ifp->if_xzoom,(float) ifp->if_yzoom);
#endif
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
#if 0
  glTranslatef(0.0, 0.0, -1.0);
#endif
  glViewport(0, 0, WGL(ifp)->win_width, WGL(ifp)->win_height);
  wgl_xmit_scanlines(ifp, y, h, x, w);
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode(mm);

#if 0
  if(dflag)
    glEnable(GL_DEPTH_TEST);
#endif

  glFlush();
  return 0;
}

#else

/* quell empty-compilation unit warnings */
static const int unused = 0;

#endif /* IF_WGL */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


1.16
log
@We don't need to check for Windows in this file ;-).
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.15 2007/11/04 17:42:27 bob1961 Exp $ (ARL)";
d2448 5
@


1.15
log
@Mods to accommodate the new hdc parameter to _wgl_open_existing().
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.14 2007/10/26 21:51:26 brlcad Exp $ (ARL)";
a912 1
#if defined(_WIN32) && !defined(__CYGWIN__)
a929 19
#else
    if(sscanf(argv[1], "%llu", (unsigned long long *)&dpy) != 1)
	return -1;

    if(sscanf(argv[2], "%llu", (unsigned long long *)&win) != 1)
	return -1;

    if(sscanf(argv[3], "%llu", (unsigned long long *)&cmap) != 1)
	return -1;

    if(sscanf(argv[4], "%llu", (unsigned long long *)&vip) != 1)
	return -1;

    if(sscanf(argv[5], "%llu", (unsigned long long *)&hdc) != 1)
	return -1;

    if(sscanf(argv[8], "%llu", (unsigned long long *)&glxc) != 1)
	return -1;
#endif
@


1.14
log
@yet another surge of level 4 flawfinder string length checks. somewhere around 30-40% done.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.13 2007/09/26 21:09:29 brlcad Exp $ (ARL)";
d899 23
a921 9
  Display *dpy;
  Window win;
  Colormap cmap;
  PIXELFORMATDESCRIPTOR *vip;
  int width;
  int height;
  HGLRC glxc;
  int double_buffer;
  int soft_cmap;
d923 11
a933 2
  if(argc != 10)
    return -1;
d935 2
a936 2
  if(sscanf(argv[1], "%lu", (unsigned long *)&dpy) != 1)
   return -1;
d938 2
a939 2
  if(sscanf(argv[2], "%lu", (unsigned long *)&win) != 1)
    return -1;
d941 2
a942 2
  if(sscanf(argv[3], "%lu", (unsigned long *)&cmap) != 1)
    return -1;
d944 2
a945 2
  if(sscanf(argv[4], "%lu", (unsigned long *)&vip) != 1)
    return -1;
d947 3
a949 2
  if(sscanf(argv[5], "%d", &width) != 1)
    return -1;
d951 2
a952 2
  if(sscanf(argv[6], "%d", &height) != 1)
    return -1;
d954 2
a955 2
  if(sscanf(argv[7], "%lu", (unsigned long *)&glxc) != 1)
    return -1;
d957 2
a958 2
  if(sscanf(argv[8], "%d", &double_buffer) != 1)
    return -1;
d960 2
a961 2
  if(sscanf(argv[9], "%d", &soft_cmap) != 1)
    return -1;
d963 1
a963 1
  return _wgl_open_existing(ifp, dpy, win, cmap, vip, width, height,
d986 1
d1046 1
d1534 1
a1534 1
			fb_log("Warning, wgl_write: wglMakeCurrent unsuccessful.\n");
d1571 2
a1572 2
		/* unattach context for other threads to use */
		wglMakeCurrent(WGL(ifp)->hdc,WGL(ifp)->glxc);
@


1.13
log
@BAM! .. lingering windows is now the default.  it only took hundreds of complaints and 20 years of development.  this change makes it the default for most of the existing active framebuffer interface types, also adding a \\t\ option to complement the existing \\l\ option to allow folks to obtain the previous behavior if needed.  all this mode code really should be consolidated and made consistent, but that is a chore for another day.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.12 2007/09/26 19:06:46 brlcad Exp $ (ARL)";
d807 1
a807 1
	(void)sprintf( title, "BRL-CAD /dev/wgl %s, %s",
@


1.12
log
@do the same on windows, don't close our output channels
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.11 2007/08/18 03:15:11 brlcad Exp $ (ARL)";
d345 3
a347 1
		"Lingering window - else transient" },
a693 1
	 *  The default mode is zero.
d695 1
a695 1
	mode = 0;
d704 2
a705 2
		if( strncmp(file, "/dev/wgl", 8) ) {
			/* How did this happen?? */
d732 1
a732 1
				mode = atoi( modebuf );
d1037 1
a1037 1
    printf("wgl_final_close: All done...goodbye!\n");
d1040 7
a1046 14
  /* if(WGL(ifp)->cursor)
     XDestroyWindow(WGL(ifp)->dispp, WGL(ifp)->cursor);
  */

  /* XDestroyWindow(WGL(ifp)->dispp, WGL(ifp)->wind);
     XFreeColormap(WGL(ifp)->dispp, WGL(ifp)->xcmap);
  */

  if (WGL(ifp)->glxc)
	  wglDeleteContext(WGL(ifp)->glxc);
  if (WGL(ifp)->hdc)
	  ReleaseDC(WGL(ifp)->hwnd, WGL(ifp)->hdc);
	DestroyWindow(WGL(ifp)->hwnd);

d1049 2
a1050 2
    /* free up memory associated with image */

d1053 3
a1055 3
    /* free state information */
    (void)free( (char *)SGIL(ifp) );
    SGIL(ifp) = NULL;
d1059 2
a1060 2
    (void) free( (char *)WGLL(ifp) );
    WGLL(ifp) = NULL;
@


1.11
log
@remove the fblocal.h header file.  it was only used in three places (two files) and only contained one macro (wrapper to fb_log an error), so keep it simple until it's really needed.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.10 2007/05/12 22:23:05 brlcad Exp $ (ARL)";
d1106 1
a1106 3
	 *  ourselves with eliminating stdin, stdout, and stderr,
	 *  (fd 0,1,2), in the hopes that this will successfully
	 *  terminate any pipes or network connections.
a1108 2
	fclose( stdout );
	fclose( stderr );
@


1.11.2.1
log
@merge from head, make linger the default framebuffer action instead of transient for all windowing framebuffer interfaces.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.13 2007/09/26 21:09:29 brlcad Exp $ (ARL)";
d345 1
a345 3
		"Lingering window" },
	{ 't',	MODE_2MASK, MODE_2TRANSIENT,
		"Transient window" },
d692 1
d694 1
a694 1
	mode = MODE_2LINGERING;
d703 2
a704 2
		if (strncmp(file, ifp->if_name, strlen(ifp->if_name))) {
			/* How did this happen? */
d731 1
a731 1
				mode |= atoi( modebuf );
d1036 1
a1036 1
      printf("wgl_final_close: All done...goodbye!\n");
d1039 14
a1052 7
  if (WGL(ifp)->glxc) {
      wglDeleteContext(WGL(ifp)->glxc);
  }
  if (WGL(ifp)->hdc) {
      ReleaseDC(WGL(ifp)->hwnd, WGL(ifp)->hdc);
  }
  DestroyWindow(WGL(ifp)->hwnd);
d1055 2
a1056 2
      /* free up memory associated with image */
      
d1059 3
a1061 3
      /* free state information */
      (void)free( (char *)SGIL(ifp) );
      SGIL(ifp) = NULL;
d1065 2
a1066 2
      (void) free( (char *)WGLL(ifp) );
      WGLL(ifp) = NULL;
d1106 3
a1108 1
	 *  ourselves with eliminating stdin.
d1111 2
@


1.10
log
@use new bu_process_id() function to get the pid now
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.9 2007/01/27 01:41:37 brlcad Exp $ (ARL)";
d72 1
a72 1
#include "./fblocal.h"
@


1.9
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.8 2007/01/23 01:13:35 brlcad Exp $ (ARL)";
d821 1
a821 1
	/* SGI(ifp)->mi_pid = getpid(); */
d1003 1
a1003 1
  /* SGI(ifp)->mi_pid = getpid(); */
@


1.8
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.7 2007/01/21 04:45:43 brlcad Exp $ (ARL)";
a476 1

d500 1
a500 1
	    	sw_cmap = 1;
d775 1
a775 1
    	 */
a862 1

d1135 1
a1135 1
          XDestroyWindow(WGL(ifp)->dispp, WGL(ifp)->cursor);
a1425 1

a1711 1

d1817 7
a1823 7
	    		color_cell[i].pixel = i;
	    		color_cell[i].red = CMR(ifp)[i];
	    		color_cell[i].green = CMG(ifp)[i];
	    		color_cell[i].blue = CMB(ifp)[i];
	    		color_cell[i].flags = DoRed | DoGreen | DoBlue;
	    	}
    		XStoreColors(WGL(ifp)->dispp, WGL(ifp)->xcmap, color_cell, 256);*/
a1917 1

d2038 3
a2040 8
        if (bRet == -1)
        {
            /* handle the error and possibly exit */
        }
        else
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
d2042 6
a2047 1
    } 
d2135 2
a2136 2
	 	if( WGL(ifp)->copy_flag && !WGL(ifp)->front_flag ) {
	 		glDrawBuffer(GL_FRONT);
d2141 2
a2142 2
	 		glDrawBuffer(GL_BACK);
	 	} else {
d2147 2
a2148 2
	 	}
	 	/* center viewport */
@


1.7
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d46 1
a46 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.6 2007/01/20 14:36:52 brlcad Exp $ (ARL)";
@


1.6
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup if */
/*@@{*/
d44 1
a44 1
/*@@}*/
d47 1
a47 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.5 2006/08/08 22:47:15 brlcad Exp $ (ARL)";
@


1.5
log
@avoid debug mode namespace conflicts when multiple interfaces are compiled and HIDDEN becomes /**/)
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.4 2006/08/08 06:47:06 brlcad Exp $ (ARL)";
@


1.4
log
@get rid of the libfb-specific _LOCAL_ macro, instead using HIDDEN like everyone else (currently still provided by machine.h)
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.3 2006/08/07 17:55:16 brlcad Exp $ (ARL)";
d88 1
a88 1
HIDDEN void		do_event();
d888 1
a888 1
		do_event(ifp);
d1129 1
a1129 1
	    do_event(ifp);
d1168 1
a1168 1
	do_event(ifp);
d2037 1
a2037 1
do_event(FBIO *ifp)
@


1.3
log
@IF_4D interface is not really shipped any more, don't talk about it
@
text
@d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.2 2006/08/01 16:20:50 brlcad Exp $ (ARL)";
d88 2
a89 2
_LOCAL_ void		do_event();
_LOCAL_ void		expose_callback();
d93 4
a96 4
_LOCAL_ void		wgl_clipper();
_LOCAL_ int		wgl_getmem();
_LOCAL_ void		backbuffer_to_screen();
_LOCAL_ void		wgl_cminit();
d98 1
a98 1
_LOCAL_ void		reorder_cursor();
d100 2
a101 2
_LOCAL_ PIXELFORMATDESCRIPTOR *	wgl_choose_visual();
_LOCAL_ int		is_linear_cmap();
d103 2
a104 2
_LOCAL_ int	wgl_nwindows = 0; 	/* number of open windows */
_LOCAL_ int	multiple_windows = 0;	/* someone wants to be ready
d108 1
a108 1
/*_LOCAL_	XColor	color_cell[256];*/		/* used to set colormap */
d115 1
a115 1
_LOCAL_ int	wgl_open(),
d338 1
a338 1
_LOCAL_ struct modeflags {
d407 1
a407 1
_LOCAL_ int
d467 1
a467 1
static void
d485 1
a485 1
_LOCAL_ void
d671 1
a671 1
_LOCAL_ int
d1034 1
a1034 1
_LOCAL_ int
d1078 1
a1078 1
_LOCAL_ int
d1164 1
a1164 1
_LOCAL_ int
d1181 1
a1181 1
_LOCAL_ int
d1199 1
a1199 1
_LOCAL_ int
d1279 1
a1279 1
_LOCAL_ int
d1359 1
a1359 1
_LOCAL_ int
d1376 1
a1376 1
_LOCAL_ int
d1431 1
a1431 1
_LOCAL_ int
d1576 1
a1576 1
_LOCAL_ int
d1650 1
a1650 1
_LOCAL_ int
d1718 1
a1718 1
_LOCAL_ int
d1742 1
a1742 1
_LOCAL_ int
d1758 1
a1758 1
_LOCAL_ void
d1773 1
a1773 1
_LOCAL_ int
d1839 1
a1839 1
_LOCAL_ int
d1905 1
a1905 1
_LOCAL_ int
d1917 1
a1917 1
_LOCAL_ int
d1925 1
a1925 1
_LOCAL_ int
d1950 1
a1950 1
_LOCAL_ int
d2036 1
a2036 1
_LOCAL_ void
d2060 1
a2060 1
_LOCAL_ void
d2226 1
a2226 1
_LOCAL_ void
d2251 1
a2251 1
_LOCAL_ void
d2347 1
a2347 1
_LOCAL_ PIXELFORMATDESCRIPTOR *
@


1.2
log
@update names, s/ogl/wgl/
@
text
@d35 1
a35 1
 *  This code is basically a port of if_4d.c from IRIS GL to OpenGL.
a37 1
 *	Carl Nuzman
d48 1
a48 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_wgl.c,v 1.1 2006/08/01 16:00:59 brlcad Exp $ (ARL)";
a227 1
 *  Structure members have the same meaning as in the if_4d.c code.
d447 1
a447 1
	fb_log("wgl_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_4d.c for details\n");
d728 1
a728 1
					fb_log( "if_4d: unknown option '%c' ignored\n", *cp );
@


1.1
log
@initial stub of a libfb IF_WGL 'wgl' interface to replace usage of 'ogl' on Windows.  this is done to support the libdm design intent of interfaces for each style of display manager, instead of piggy-backing on top of 'ogl' and complicating the code with preprocessor WIN32 checks everywhere.  haven't updated the names/code yet.. just a stub file.
@
text
@d1 1
a1 1
/*                  I F _ O G L _ W I N 3 2 . C
d24 3
a26 2
/** @@file if_ogl_win32.c
 *  Frame Buffer Library interface for OpenGL.
d33 1
a33 1
 *	/dev/ogl[options]
d49 1
a49 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_ogl_win32.c,v 14.15 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d54 2
d91 1
a91 1
void ogl_configureWindow FB_ARGS((FBIO *ifp, int width, int height));
d94 2
a95 2
_LOCAL_ void		ogl_clipper();
_LOCAL_ int		ogl_getmem();
d97 1
a97 1
_LOCAL_ void		ogl_cminit();
d101 1
a101 1
_LOCAL_ PIXELFORMATDESCRIPTOR *	ogl_choose_visual();
d104 1
a104 1
_LOCAL_ int	ogl_nwindows = 0; 	/* number of open windows */
d111 16
a126 16
int ogl_refresh();
int ogl_open_existing();
int ogl_close_existing();
int _ogl_open_existing();

_LOCAL_ int	ogl_open(),
		ogl_close(),
		ogl_clear(),
		ogl_read(),
		ogl_write(),
		ogl_rmap(),
		ogl_wmap(),
		ogl_view(),
		ogl_getview(),
		ogl_setcursor(),
		ogl_cursor(),
d128 2
a129 2
		ogl_getcursor(),
		ogl_readrect(),
d132 6
a137 6
		ogl_writerect(),
		ogl_bwwriterect(),
		ogl_poll(),
		ogl_flush(),
		ogl_free(),
		ogl_help();
d140 1
a140 1
FBIO ogl_interface =
d143 11
a153 11
	ogl_open,		/* open device		*/
	ogl_close,		/* close device		*/
	ogl_clear,		/* clear device		*/
	ogl_read,		/* read	pixels		*/
	ogl_write,		/* write pixels		*/
	ogl_rmap,		/* read colormap	*/
	ogl_wmap,		/* write colormap	*/
	ogl_view,		/* set view		*/
	ogl_getview,		/* get view		*/
	ogl_setcursor,		/* define cursor	*/
	ogl_cursor,		/* set cursor		*/
d156 1
a156 1
	ogl_writerect,		/* write rectangle	*/
d158 5
a162 5
	ogl_bwwriterect,	/* write rectangle	*/
	ogl_poll,		/* process events	*/
	ogl_flush,		/* flush output		*/
	ogl_free,		/* free resources	*/
	ogl_help,		/* help message		*/
d166 1
a166 1
	"/dev/ogl",		/* short device name	*/
d191 1
a191 1
struct ogl_cmap {
d202 1
a202 1
struct ogl_pixel {
d211 1
a211 1
struct ogl_clip {
d241 1
a241 1
	struct ogl_pixel mi_scanline[XMAXSCREEN+1];	/* one scanline */
d247 1
a247 1
struct oglinfo {
d262 1
a262 1
	struct ogl_clip	clip;		/* current view clipping */
d266 1
a266 1
	int		use_ext_ctrl;	/* for controlling the Ogl graphics engine externally */
d274 2
a275 2
#define	OGL(ptr)	((struct oglinfo *)((ptr)->u6.p))
#define	OGLL(ptr)	((ptr)->u6.p)		/* left hand side version */
d278 3
a280 3
#define CMR(x)		((struct ogl_cmap *)((x)->if_cmap))->cmr
#define CMG(x)		((struct ogl_cmap *)((x)->if_cmap))->cmg
#define CMB(x)		((struct ogl_cmap *)((x)->if_cmap))->cmb
d379 1
a379 1
 *			O G L _ G E T M E M
d410 1
a410 1
ogl_getmem( ifp )
d426 2
a427 2
		pixsize = ifp->if_height * ifp->if_width * sizeof(struct ogl_pixel);
		size = pixsize + sizeof(struct ogl_cmap);
d431 1
a431 1
			fb_log("ogl_getmem: frame buffer memory malloc failed\n");
d446 1
a446 1
		ogl_cminit( ifp );
d449 1
a449 1
	fb_log("ogl_getmem:  Unable to attach to shared memory.\nConsult comment in cad/libfb/if_4d.c for details\n");
d451 1
a451 1
		fb_log("ogl_getmem:  malloc failure\n");
d459 1
a459 1
 *			O G L _ Z A P M E M
d462 1
a462 1
ogl_zapmem()
d482 1
a482 1
/* 			O G L _ X M I T _ S C A N L I N E S
d488 1
a488 1
ogl_xmit_scanlines( ifp, ybase, nlines, xbase, npix )
d498 1
a498 1
	struct ogl_clip	*clp;
d502 1
a502 1
	clp = &(OGL(ifp)->clip);
d504 1
a504 1
	if( OGL(ifp)->soft_cmap_flag  && SGI(ifp)->mi_cmap_flag )  {
d522 2
a523 2
	if(!OGL(ifp)->use_ext_ctrl){
	if (!OGL(ifp)->copy_flag){
d558 1
a558 1
	} else if (OGL(ifp)->front_flag) {
d563 1
a563 1
		OGL(ifp)->front_flag = 0;
d567 2
a568 2
		glOrtho( -0.25, ((GLdouble) OGL(ifp)->vp_width)-0.25,
			-0.25, ((GLdouble) OGL(ifp)->vp_height)-0.25,
d577 2
a578 2
		register struct ogl_pixel	*oglp;
		register struct ogl_pixel	*op;
d585 1
a585 1
			oglp = (struct ogl_pixel *)&ifp->if_mem[
d587 1
a587 1
				sizeof(struct ogl_pixel) ];
d589 3
a591 3
				op[x].red   = CMR(ifp)[oglp[x].red];
				op[x].green = CMG(ifp)[oglp[x].green];
				op[x].blue  = CMB(ifp)[oglp[x].blue];
d625 1
a625 1
	if(!OGL(saveifp)->use_ext_ctrl)
d638 1
a638 1
	OGL(saveifp)->alive = -1;
d641 1
a641 1
	OGL(saveifp)->alive = 0;
d644 1
a644 1
	OGL(saveifp)->alive = 0;
d647 1
a647 1
	OGL(saveifp)->alive = 0;
d655 1
a655 1
	OGL(saveifp)->alive = 0;
d660 2
a661 2
	    if(conf->width == OGL(ifp)->win_width &&
	       conf->height == OGL(ifp)->win_height)
d664 1
a664 1
	    ogl_configureWindow(ifp, conf->width, conf->height);
d674 1
a674 1
ogl_open( ifp, file, width, height )
d696 1
a696 1
	 *  file = "/dev/ogl###"
d708 1
a708 1
		if( strncmp(file, "/dev/ogl", 8) ) {
d741 1
a741 1
			ogl_zapmem();
d749 1
a749 1
	 *  addressed by SGI(ifp)->mi_xxx and OGL(ifp)->xxx
d753 1
a753 1
		fb_log("ogl_open:  sgiinfo malloc failed\n");
d756 2
a757 2
	if( (OGLL(ifp) = (char *)calloc( 1, sizeof(struct oglinfo) )) == NULL )  {
		fb_log("ogl_open:  oglinfo malloc failed\n");
d763 2
a764 2
	if (ogl_nwindows && !multiple_windows){
		fb_log("Warning - ogl_open: Multiple windows opened. Use /dev/oglm for first window!");
d811 1
a811 1
	(void)sprintf( title, "BRL-CAD /dev/ogl %s, %s",
d820 1
a820 1
	/* initialize window state variables before calling ogl_getmem */
d829 1
a829 1
	if( ogl_getmem(ifp) < 0 )
d846 1
a846 1
	OGL(ifp)->hwnd =  CreateWindow(
d863 3
a865 3
	hwnd = OGL(ifp)->hwnd;
	OGL(ifp)->hdc = GetDC(OGL(ifp)->hwnd);
	hdc = OGL(ifp)->hdc;
d870 2
a871 2
	if( (OGL(ifp)->vip = ogl_choose_visual(ifp)) == NULL ) {
		fb_log("ogl_open: Couldn't find an appropriate visual.  Exiting.\n");
d875 2
a876 2
	OGL(ifp)->glxc = wglCreateContext(OGL(ifp)->hdc);
	glxc = OGL(ifp)->glxc;
d879 1
a879 1
	ogl_nwindows++;
d881 2
a882 2
	OGL(ifp)->alive = 1;
	OGL(ifp)->firstTime = 1;
d884 2
a885 2
	ShowWindow(OGL(ifp)->hwnd,SW_SHOW);
	UpdateWindow(OGL(ifp)->hwnd);
d889 1
a889 1
	/*	while (OGL(ifp)->firstTime == 1)
d899 1
a899 1
ogl_open_existing(ifp, argc, argv)
d944 1
a944 1
  return _ogl_open_existing(ifp, dpy, win, cmap, vip, width, height,
d962 1
a962 1
_ogl_open_existing(FBIO *ifp,
d979 1
a979 1
   *  addressed by SGI(ifp)->mi_xxx and OGL(ifp)->xxx
d983 1
a983 1
    fb_log("ogl_open:  sgiinfo malloc failed\n");
d986 2
a987 2
  if( (OGLL(ifp) = (char *)calloc( 1, sizeof(struct oglinfo) )) == NULL )  {
    fb_log("ogl_open:  oglinfo malloc failed\n");
d991 1
a991 1
  OGL(ifp)->use_ext_ctrl = 1;
d998 2
a999 2
  OGL(ifp)->win_width = OGL(ifp)->vp_width = width;
  OGL(ifp)->win_height = OGL(ifp)->vp_height = height;
d1003 1
a1003 1
  /* initialize window state variables before calling ogl_getmem */
d1012 1
a1012 1
  if(ogl_getmem(ifp) < 0)
d1015 2
a1016 2
  OGL(ifp)->dispp = dpy;
  /* ifp->if_selfd = ConnectionNumber(OGL(ifp)->dispp); */
d1018 2
a1019 2
  OGL(ifp)->vip = vip;
  OGL(ifp)->glxc = glxc;
d1021 1
a1021 1
  OGL(ifp)->soft_cmap_flag = soft_cmap;
d1023 1
a1023 1
  OGL(ifp)->xcmap = cmap;
d1025 2
a1026 2
  OGL(ifp)->wind = win;
  ++ogl_nwindows;
d1028 2
a1029 2
  OGL(ifp)->alive = 1;
  OGL(ifp)->firstTime = 1;
d1031 1
a1031 1
  ogl_clipper(ifp);
d1037 1
a1037 1
ogl_final_close( ifp )
d1042 1
a1042 1
    printf("ogl_final_close: All done...goodbye!\n");
d1045 2
a1046 2
  /* if(OGL(ifp)->cursor)
     XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);
d1049 2
a1050 2
  /* XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->wind);
     XFreeColormap(OGL(ifp)->dispp, OGL(ifp)->xcmap);
d1053 5
a1057 5
  if (OGL(ifp)->glxc)
	  wglDeleteContext(OGL(ifp)->glxc);
  if (OGL(ifp)->hdc)
	  ReleaseDC(OGL(ifp)->hwnd, OGL(ifp)->hdc);
	DestroyWindow(OGL(ifp)->hwnd);
d1070 3
a1072 3
  if( OGLL(ifp) != NULL) {
    (void) free( (char *)OGLL(ifp) );
    OGLL(ifp) = NULL;
d1075 1
a1075 1
  ogl_nwindows--;
d1081 1
a1081 1
ogl_close( ifp )
d1085 1
a1085 1
	ogl_flush( ifp );
d1090 1
a1090 1
	if( ogl_nwindows > 1 ||
d1092 1
a1092 1
		return ogl_final_close( ifp );
d1095 1
a1095 1
		printf("ogl_close: remaining open to linger awhile.\n");
d1130 1
a1130 1
	while (0 < OGL(ifp)->alive)
d1137 1
a1137 1
ogl_close_existing(FBIO *ifp)
d1140 2
a1141 2
      if(OGL(ifp)->cursor)
          XDestroyWindow(OGL(ifp)->dispp, OGL(ifp)->cursor);
d1153 3
a1155 3
  if( OGLL(ifp) != NULL) {
    (void) free( (char *)OGLL(ifp) );
    OGLL(ifp) = NULL;
d1162 1
a1162 1
 *			O G L _ P O L L
d1167 1
a1167 1
ogl_poll(ifp)
d1172 1
a1172 1
	if (OGL(ifp)->alive < 0)
d1179 1
a1179 1
 *			O G L _ F R E E
d1184 1
a1184 1
ogl_free( ifp )
d1189 1
a1189 1
	if(CJDEBUG) printf("entering  ogl_free\n");
d1191 1
a1191 1
	ret = ogl_final_close( ifp );
d1195 1
a1195 1
		ogl_zapmem();
d1202 1
a1202 1
ogl_clear( ifp, pp )
d1206 2
a1207 2
	struct ogl_pixel		bg;
	register struct ogl_pixel      *oglp;
d1211 1
a1211 1
	if( CJDEBUG ) printf("entering ogl_clear\n");
d1214 2
a1215 2
		if (wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_clear: wglMakeCurrent unsuccessful.\n");
d1236 2
a1237 2
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+0)*sizeof(struct ogl_pixel) ];
d1239 1
a1239 1
			*oglp++ = bg;	/* struct copy */
d1245 1
a1245 1
	if(OGL(ifp)->use_ext_ctrl){
d1248 1
a1248 1
	if ( OGL(ifp)->copy_flag){
d1250 1
a1250 1
		if (OGL(ifp)->front_flag){
d1264 1
a1264 1
			SwapBuffers( OGL(ifp)->hdc);
d1270 1
a1270 1
		wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc);
d1279 1
a1279 1
 *			O G L _ V I E W
d1282 1
a1282 1
ogl_view( ifp, xcenter, ycenter, xzoom, yzoom )
d1287 1
a1287 1
	struct ogl_clip *clp;
d1289 1
a1289 1
	if(CJDEBUG) printf("entering ogl_view\n");
d1314 2
a1315 2
	if(OGL(ifp)->use_ext_ctrl){
		ogl_clipper(ifp);
d1318 2
a1319 2
		if (wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc)==False){
			fb_log("Warning, ogl_view: wglMakeCurrent unsuccessful.\n");
d1325 1
a1325 1
	if (OGL(ifp)->copy_flag && !OGL(ifp)->front_flag){
d1331 1
a1331 1
		OGL(ifp)->front_flag = 1;
d1335 2
a1336 2
	ogl_clipper(ifp);
	clp = &(OGL(ifp)->clip);
d1340 1
a1340 1
	if (OGL(ifp)->copy_flag){
d1343 1
a1343 1
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
d1345 1
a1345 1
			SwapBuffers( OGL(ifp)->hdc);
d1351 1
a1351 1
		wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc);
d1359 1
a1359 1
 *			O G L _ G E T V I E W
d1362 1
a1362 1
ogl_getview( ifp, xcenter, ycenter, xzoom, yzoom )
d1367 1
a1367 1
	if(CJDEBUG) printf("entering ogl_getview\n");
d1379 1
a1379 1
ogl_read( ifp, x, y, pixelp, count ) /*read count pixels into pixelp starting at x,y*/
d1389 1
a1389 1
	register struct ogl_pixel	*oglp;
d1391 1
a1391 1
	if(CJDEBUG) printf("entering ogl_read\n");
d1409 2
a1410 2
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct ogl_pixel) ];
d1414 4
a1417 4
			cp[RED] = oglp->red;
			cp[GRN] = oglp->green;
			cp[BLU] = oglp->blue;
			oglp++;
d1434 1
a1434 1
ogl_write( ifp, xstart, ystart, pixelp, count ) /*write count pixels from pixelp starting at xstart,ystart*/
d1448 1
a1448 1
	if(CJDEBUG) printf("entering ogl_write\n");
d1468 1
a1468 1
		register struct ogl_pixel	*oglp;
d1478 2
a1479 2
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+x)*sizeof(struct ogl_pixel) ];
d1486 4
a1489 4
				oglp->red   = cp[RED];
				oglp->green = cp[GRN];
				oglp->blue  = cp[BLU];
				oglp++;
d1496 13
a1508 13
				oglp[0].red   = cp[RED+0*3];
				oglp[0].green = cp[GRN+0*3];
				oglp[0].blue  = cp[BLU+0*3];
				oglp[1].red   = cp[RED+1*3];
				oglp[1].green = cp[GRN+1*3];
				oglp[1].blue  = cp[BLU+1*3];
				oglp[2].red   = cp[RED+2*3];
				oglp[2].green = cp[GRN+2*3];
				oglp[2].blue  = cp[BLU+2*3];
				oglp[3].red   = cp[RED+3*3];
				oglp[3].green = cp[GRN+3*3];
				oglp[3].blue  = cp[BLU+3*3];
				oglp += 4;
d1524 2
a1525 2
		if (wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc)==False){
			fb_log("Warning, ogl_write: wglMakeCurrent unsuccessful.\n");
d1529 1
a1529 1
	if(!OGL(ifp)->use_ext_ctrl){
d1542 2
a1543 2
		ogl_xmit_scanlines( ifp, ybase, 1, xstart, count );
		if (OGL(ifp)->copy_flag){
d1550 2
a1551 2
			ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
			SwapBuffers( OGL(ifp)->hdc);
d1554 2
a1555 2
			ogl_xmit_scanlines( ifp, ybase, y-ybase, 0, ifp->if_width );
			if (OGL(ifp)->copy_flag){
d1563 1
a1563 1
		wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc);
d1572 1
a1572 1
 *			O G L _ W R I T E R E C T
d1579 1
a1579 1
ogl_writerect(FBIO *ifp,
d1589 1
a1589 1
	register struct ogl_pixel	*oglp;
d1591 1
a1591 1
	if(CJDEBUG) printf("entering ogl_writerect\n");
d1602 2
a1603 2
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct ogl_pixel) ];
d1606 4
a1609 4
			oglp->red   = cp[RED];
			oglp->green = cp[GRN];
			oglp->blue  = cp[BLU];
			oglp++;
d1617 1
a1617 1
	if(!OGL(ifp)->use_ext_ctrl){
d1619 2
a1620 2
	if (wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_writerect: wglMakeCurrent unsuccessful.\n");
d1625 2
a1626 2
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		SwapBuffers( OGL(ifp)->hdc);
d1629 2
a1630 2
		ogl_xmit_scanlines( ifp, ymin, height, xmin, width );
		if (OGL(ifp)->copy_flag){
d1637 1
a1637 1
	wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc);
d1646 1
a1646 1
 *			O G L _ B W W R I T E R E C T
d1653 1
a1653 1
ogl_bwwriterect(FBIO *ifp,
d1663 1
a1663 1
	register struct ogl_pixel	*oglp;
d1665 1
a1665 1
	if(CJDEBUG) printf("entering ogl_bwwriterect\n");
d1676 2
a1677 2
		oglp = (struct ogl_pixel *)&ifp->if_mem[
		    (y*SGI(ifp)->mi_memwidth+xmin)*sizeof(struct ogl_pixel) ];
d1681 4
a1684 4
			oglp->red   = (val = *cp++);
			oglp->green = val;
			oglp->blue  = val;
			oglp++;
d1691 1
a1691 1
	if(!OGL(ifp)->use_ext_ctrl){
d1693 2
a1694 2
	if (wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc)==False){
		fb_log("Warning, ogl_writerect: wglMakeCurrent unsuccessful.\n");
d1699 2
a1700 2
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
		SwapBuffers( OGL(ifp)->hdc);
d1703 2
a1704 2
		ogl_xmit_scanlines( ifp, ymin, height, xmin, width );
		if (OGL(ifp)->copy_flag){
d1711 1
a1711 1
	wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc);
d1721 1
a1721 1
ogl_rmap(register FBIO *ifp,
d1726 1
a1726 1
	if(CJDEBUG) printf("entering ogl_rmap\n");
d1758 1
a1758 1
 *			O G L _ C M I N I T
d1761 1
a1761 1
ogl_cminit(register FBIO *ifp)
d1773 1
a1773 1
 *			 O G L _ W M A P
d1776 1
a1776 1
ogl_wmap(register FBIO *ifp,
d1782 1
a1782 1
	if(CJDEBUG) printf("entering ogl_wmap\n");
d1786 1
a1786 1
		ogl_cminit( ifp );
d1797 2
a1798 2
	if(!OGL(ifp)->use_ext_ctrl){
	if( OGL(ifp)->soft_cmap_flag )  {
d1805 2
a1806 2
		if (wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc)==False){
			fb_log("Warning, ogl_wmap: wglMakeCurrent unsuccessful.\n");
d1810 1
a1810 1
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
d1812 2
a1813 2
			SwapBuffers( OGL(ifp)->hdc);
		} else if (OGL(ifp)->copy_flag) {
d1818 1
a1818 1
		wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc);
d1831 1
a1831 1
    		XStoreColors(OGL(ifp)->dispp, OGL(ifp)->xcmap, color_cell, 256);*/
d1839 1
a1839 1
 *			O G L _ H E L P
d1842 1
a1842 1
ogl_help(FBIO *ifp)
d1845 1
a1845 1
	PIXELFORMATDESCRIPTOR *visual = OGL(ifp)->vip;
d1855 1
a1855 1
	fb_log( "Usage: /dev/ogl[option letters]\n" );
d1863 1
a1863 1
	fb_log( "	ogl_nwindows=%d\n", ogl_nwindows );
d1908 1
a1908 1
ogl_setcursor(FBIO *ifp,
d1920 1
a1920 1
ogl_cursor(FBIO *ifp, int mode, int x, int y)
d1928 1
a1928 1
ogl_flush(FBIO *ifp)
d1932 2
a1933 2
			if (wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc)==False){
				fb_log("Warning, ogl_flush: wglMakeCurrent unsuccessful.\n");
d1937 1
a1937 1
		ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
d1939 1
a1939 1
			SwapBuffers( OGL(ifp)->hdc);
d1941 1
a1941 1
			if (OGL(ifp)->copy_flag){
d1946 1
a1946 1
	/* XFlush(OGL(ifp)->dispp); */
d1960 1
a1960 1
 * O G L _ C L I P P E R ( )
d1973 1
a1973 1
ogl_clipper(register FBIO *ifp)
d1975 1
a1975 1
	register struct ogl_clip *clp;
d1979 1
a1979 1
	clp = &(OGL(ifp)->clip);
d1981 1
a1981 1
	i = OGL(ifp)->vp_width/(2*ifp->if_xzoom);
d1983 1
a1983 1
	i = OGL(ifp)->vp_width/ifp->if_xzoom;
d1986 1
a1986 1
	clp->oleft = ((double) clp->xscrmin) - 0.25*pixels/((double) OGL(ifp)->vp_width);
d1989 1
a1989 1
	i = OGL(ifp)->vp_height/(2*ifp->if_yzoom);
d1991 1
a1991 1
	i = OGL(ifp)->vp_height/ifp->if_yzoom;
d1994 1
a1994 1
	clp->obottom = ((double) clp->yscrmin) - 0.25*pixels/((double) OGL(ifp)->vp_height);
d2014 3
a2016 3
	if (OGL(ifp)->copy_flag) {
		if( clp->xpixmax > OGL(ifp)->vp_width-1 )  {
			clp->xpixmax = OGL(ifp)->vp_width-1;
d2018 2
a2019 2
		if( clp->ypixmax > OGL(ifp)->vp_height-1 )  {
			clp->ypixmax = OGL(ifp)->vp_height-1;
d2067 1
a2067 1
	struct ogl_clip *clp;
d2072 2
a2073 2
	if( multiple_windows || OGL(ifp)->firstTime ) {
		if( wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc) == False) {
d2078 2
a2079 2
	if( OGL(ifp)->firstTime ) {
		OGL(ifp)->firstTime = 0;
d2100 1
a2100 1
			OGL(ifp)->copy_flag = 1;
d2102 1
a2102 1
			OGL(ifp)->front_flag = 1;
d2105 1
a2105 1
			OGL(ifp)->copy_flag = 0;
d2108 2
a2109 2
		OGL(ifp)->win_width=ifp->if_width;
		OGL(ifp)->win_height=ifp->if_height;
d2112 1
a2112 1
		glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);
d2119 6
a2124 6
		OGL(ifp)->vp_width = (OGL(ifp)->win_width < ifp->if_width) ?
				OGL(ifp)->win_width : ifp->if_width;
		OGL(ifp)->vp_height = (OGL(ifp)->win_height < ifp->if_height) ?
				OGL(ifp)->win_height : ifp->if_height;
		ifp->if_xcenter = OGL(ifp)->vp_width/2;
		ifp->if_ycenter = OGL(ifp)->vp_height/2;
d2127 2
a2128 2
		SGI(ifp)->mi_xoff=(OGL(ifp)->win_width-OGL(ifp)->vp_width)/2;
		SGI(ifp)->mi_yoff=(OGL(ifp)->win_height-OGL(ifp)->vp_height)/2;
d2131 2
a2132 2
			   OGL(ifp)->vp_width,
			   OGL(ifp)->vp_height);
d2134 2
a2135 2
		ogl_clipper(ifp);
		clp = &(OGL(ifp)->clip);
d2141 2
a2142 2
	} else if( (OGL(ifp)->win_width > ifp->if_width) ||
		   (OGL(ifp)->win_height > ifp->if_height) ) {
d2144 1
a2144 1
	 	if( OGL(ifp)->copy_flag && !OGL(ifp)->front_flag ) {
d2146 2
a2147 2
			glViewport(0, 0, OGL(ifp)->win_width,
				   OGL(ifp)->win_height);
d2152 2
a2153 2
			glViewport(0, 0, OGL(ifp)->win_width,
				   OGL(ifp)->win_height);
d2160 2
a2161 2
			   OGL(ifp)->vp_width,
			   OGL(ifp)->vp_height);
d2165 1
a2165 1
	ogl_xmit_scanlines( ifp, 0, ifp->if_height, 0, ifp->if_width );
d2167 2
a2168 2
		SwapBuffers( OGL(ifp)->hdc);
	} else if( OGL(ifp)->copy_flag ) {
d2188 1
a2188 1
		wglMakeCurrent(OGL(ifp)->hdc,OGL(ifp)->glxc);
d2192 1
a2192 1
	XFlush(OGL(ifp)->dispp);
d2198 1
a2198 1
ogl_configureWindow(FBIO *ifp,
d2202 2
a2203 2
  if(width == OGL(ifp)->win_width &&
     height == OGL(ifp)->win_height)
d2209 2
a2210 2
  OGL(ifp)->win_width = OGL(ifp)->vp_width = width;
  OGL(ifp)->win_height = OGL(ifp)->vp_height = height;
d2218 2
a2219 2
  ogl_getmem(ifp);
  ogl_clipper(ifp);
d2257 1
a2257 1
	struct ogl_clip *clp;
d2259 2
a2260 2
	if (!(OGL(ifp)->front_flag)){
		OGL(ifp)->front_flag = 1;
d2267 1
a2267 1
	clp = &(OGL(ifp)->clip);
d2292 1
a2292 1
		if( clp->xscrmax >= OGL(ifp)->vp_width )  glRecti(
d2299 1
a2299 1
		if( clp->yscrmax >= OGL(ifp)->vp_height )  glRecti(
d2301 1
a2301 1
			OGL(ifp)->vp_height - CLIP_XTRA,
d2326 1
a2326 1
/* 		O G L _ C H O O S E _ V I S U A L
d2345 1
a2345 1
 *	OGL(ifp)->soft_cmap_flag
d2350 1
a2350 1
ogl_choose_visual(FBIO *ifp)
d2359 1
a2359 1
  iPixelFormat  = GetPixelFormat(OGL(ifp)->hdc);
d2387 2
a2388 2
  iPixelFormat = ChoosePixelFormat(OGL(ifp)->hdc, ppfd);
  good = SetPixelFormat(OGL(ifp)->hdc, iPixelFormat, ppfd);
d2392 1
a2392 1
  OGL(ifp)->soft_cmap_flag = 0;
d2399 1
a2399 1
ogl_refresh(FBIO *ifp,
d2406 1
a2406 1
  struct ogl_clip *clp;
d2431 1
a2431 1
  glOrtho(0.0, OGL(ifp)->win_width, 0.0, OGL(ifp)->win_height, -1.0, 1.0);
d2433 2
a2434 2
  ogl_clipper(ifp);
  clp = &(OGL(ifp)->clip);
d2444 2
a2445 2
  glViewport(0, 0, OGL(ifp)->win_width, OGL(ifp)->win_height);
  ogl_xmit_scanlines(ifp, y, h, x, w);
d2461 2
@

