head	14.16;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.6
	rel-7-10-2:14.15
	rel-7-10-0:14.15
	rel-7-8-4:14.11
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.5
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.16
date	2007.08.18.03.15.11;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.08.06.47.05;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.07.09.18.25.32;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.30.12;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.04.13.01.43.20;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.01.30.20.30.53;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.58.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.43;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@remove the fblocal.h header file.  it was only used in three places (two files) and only contained one macro (wrapper to fb_log an error), so keep it simple until it's really needed.
@
text
@/*                        I F _ R A T . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup if */
/** @@{ */
/** @@file if_rat.c
 *
 *  FrameBuffer library interface for Raster Technology One/80 with
 *  24-bit RGB memory.
 *
 *  Authors -
 *	Brant A. Ross
 *
 *  Source -
 * 	General Motors Military Vehicles Operation
 *      P.O. Box 420  Mail Code O01
 *	Indianapolis, IN  46206-0420
 *
 *  BRL NOTE: We have not been able to test this interface in a long
 *   time.  LIBFB has changed several times since then so this code
 *   may not even compile any longer.  If you make changes to this
 *   please let us know.
 */
/** @@} */

#ifndef lint
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.15 2007/01/27 01:41:37 brlcad Exp $ (BRL)";
#endif

#include "common.h"


#include <stdio.h>
#include <fcntl.h>

#include "machine.h"
#include "fb.h"


/* typedef unsigned char	u_char;	*/
int	_fbfd;
int	_fbsize = 512;
#define Max( a, b )	((a) < (b) ? (b) : (a))
#define Min( a, b )	((a) > (b) ? (b) : (a))

#define Rat_Cvt( x, y )	x -= _fbsize/2, y -= _fbsize/2
#define Rat_Write( cmd, buff ) \
	{	register int	ct, i; \
	if( write( _fbfd, buff, sizeof(buff) ) == -1 ) \
		{ \
		(void) fprintf( stderr, "%s : write failed!\n", cmd ); \
		return	0; \
		} \
	}
#define Round_N( a, n )	{ register int f = a%n; a = f<10 ? a-f : a+(n-f); }
#define PAD		0xA
#define	MAX_RAT_BUFF	(12*1024L)
#define	MAX_RAT_READ	1024
int		rat_debug = 0;
static int	zoom_factor = 1;

HIDDEN int	cload(int creg, int x, int y),
		debug(int flag), entergraphics(void), flood(void), lutrmp(int code, int sind, int eind, int sval, int eval), lut8(int index, u_char r, u_char g, u_char b),
		memsel(int unit), movabs(register int x, register int y), pixels(int rows, int cols, register u_char *pix_buf, int bytes, FBIO *ifp), quit(void),
		rdmask(int bitm), rdmode(int flag), rdpixr(int vreg), readf(int func), readw(int rows, int cols, int bf), readvr(int vreg),
		rgbtru(int flag), scrorg(int x, int y), value(u_char red, u_char green, u_char blue), vidform(int mode, int flag),
		warm(void), wrmask(int bitm, int bankm), xhair(int num, int flag), zoom(int factor);

HIDDEN int	rat_open(FBIO *ifp, char *file, int width, int height),
		rat_close(FBIO *ifp),
		rat_clear(FBIO *ifp, RGBpixel (*pp)),
		rat_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count),
		rat_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count),
		rat_rmap(FBIO *ifp, ColorMap *cmp),
		rat_wmap(FBIO *ifp, ColorMap *cmp),
		rat_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom),
		rat_window_set(FBIO *ifp, int x, int y),	/* OLD */
		rat_zoom_set(FBIO *ifp, int x, int y),		/* OLD */
		rat_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig),
		rat_cursor(FBIO *ifp, int mode, int x, int y),
		rat_getcursor(),
		rat_help(FBIO *ifp);

/* This is the ONLY thing that we normally "export" */
FBIO rat_interface =  {
	0,
	rat_open,			/* device_open		*/
	rat_close,			/* device_close		*/
	rat_clear,			/* device_clear		*/
	rat_read,			/* buffer_read		*/
	rat_write,			/* buffer_write		*/
	rat_rmap,			/* colormap_read	*/
	rat_wmap,			/* colormap_write	*/
	rat_view,			/* set view		*/
	fb_sim_getview,			/* get view		*/
	rat_setcursor,			/* define cursor	*/
	rat_cursor,			/* set cursor		*/
	fb_sim_getcursor,		/* get cursor		*/
	fb_sim_readrect,		/* read rectangle	*/
	fb_sim_writerect,		/* write rectangle	*/
	fb_sim_bwreadrect,
	fb_sim_bwwriterect,
	fb_null,			/* handle events	*/
	fb_null,			/* flush output		*/
	rat_close,			/* free resources	*/
	rat_help,			/* help function	*/
	"Raster Technology One/80",	/* device description	*/
	1024,				/* max width		*/
	1024,				/* max height		*/
	"/dev/rt",			/* short device name	*/
	512,				/* default/current width  */
	512,				/* default/current height */
	-1,				/* select fd		*/
	-1,				/* file descriptor	*/
	1, 1,				/* zoom			*/
	256, 256,			/* window center	*/
	0, 0, 0,			/* cursor		*/
	PIXEL_NULL,			/* page_base		*/
	PIXEL_NULL,			/* page_curp		*/
	PIXEL_NULL,			/* page_endp		*/
	-1,				/* page_no		*/
	0,				/* page_dirty		*/
	0L,				/* page_curpos		*/
	0L,				/* page_pixels		*/
	0				/* debug		*/
};

HIDDEN int
rat_open(FBIO *ifp, char *file, int width, int height)
{
	FB_CK_FBIO(ifp);
	if( (ifp->if_fd = open( file, O_RDWR, 0 )) == -1)
		{
		perror(file);
		return -1;  }
	_fbfd = ifp->if_fd;
	_fbsize = width;
	if( width == 1024)
		{ ifp->if_width = width;
		  ifp->if_height = height; }
	_rat_init(ifp);
	return ifp->if_fd;
}

HIDDEN int
rat_close(FBIO *ifp)

/*	_ r a t _ c l o s e ( )
	Issue quit command, and close connection.
 */
{
	if(  !	quit()
	    ||	close( ifp->if_fd ) == -1
		)
		{
		(void) fprintf( stderr, "_rat_close() close failed!\n" );
		return	-1;
		}
	return	0;
}


HIDDEN int
rat_clear(FBIO *ifp, RGBpixel (*pp))


/*	_ r a t _ c l e a r ( )
	Clear the Raster Tech. to the background color.
 */
{
	if(	pp != NULL
	    &&	value(	(*pp)[RED],(*pp)[GRN],(*pp)[BLU] )
	    &&	flood()  )
		return	0;
	else
	    if ( !(value( 0, 0, 0 ) && flood() ) )
		return	1;
	return	0;
}

HIDDEN int
rat_read(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count)


/*	_ r a t _ r e a d ( )
 */
{
	register int	nrows;
	register int	bytes;
	register int	load;
	register u_char	*p;
	static u_char	pix_buf[MAX_RAT_BUFF];
	int readval;

	/* If first scanline is a partial, input it seperately.		*/
	if( x > 0 || x + count <= _fbsize )
		{	register int	i;
		if( ! movabs( x, y ) )
			return	-1;
		y++;
		if( x + count <= _fbsize )
			i = count;	/* Only 1 scanline is involved.	*/
		else
			i = _fbsize - x; /* First scan is a partial.	*/
		if( ! readw( 1, i, 1 ) )
			return	-1;
		for(	bytes = i * 3, p = pix_buf;
			bytes > 0;
			bytes -= load, p += load
			) {
		    if( bytes > MAX_RAT_READ )
			load = MAX_RAT_READ;
		    else
			load = bytes;
		    readval = read( ifp->if_fd, p, load );
		    if( readval < load ) {
			if (readval < 0) {
			    perror("READ ERROR");
			}
			(void) fprintf( stderr, "_rat_read() read failed\n" );
			return -1;
		    }
		}
		for( p = pix_buf; i > 0; i--, pixelp++, count-- )
			{
			(*pixelp)[RED] = *p++;
			(*pixelp)[GRN] = *p++;
			(*pixelp)[BLU] = *p++;
			}
		}
	/* Do all full scanlines.					*/
	while( (nrows = count / _fbsize) != 0 )
		{	register int	i;
		if( ! movabs( 0, y ) )
			return	-1;
		if( nrows * _fbsize * 3 > MAX_RAT_BUFF )
			nrows = MAX_RAT_BUFF / (_fbsize * 3);
		i = nrows * _fbsize;
		y += nrows;
		if( ! readw( nrows, _fbsize, 1 ) )
			return	-1;
		for(	bytes = i * 3, p = pix_buf;
			bytes > 0;
			bytes -= load, p += load
			) {
			if( bytes > MAX_RAT_READ )
				load = MAX_RAT_READ;
			else
				load = bytes;
			{ register int	ii;
			for( ii = 0; ii < load; ii++ )
				p[ii] = 100;
			}
			readval = read( ifp->if_fd, p, load );
			if( readval < load ) {
			    if (readval < 0) {
				perror("READ ERROR");
			    }
			    (void) fprintf( stderr, "_rat_read() read failed\n" );
			    return -1;
			}
		}
		for(	p = pix_buf;
			i > 0;
			i--, pixelp++, count--
			)
			{
			(*pixelp)[RED] = *p++;
			(*pixelp)[GRN] = *p++;
			(*pixelp)[BLU] = *p++;
			}
		}
	if( count > 0 )
		{ /* Do partial scanline.				*/
			register int	i;
			register u_char	*p = pix_buf;

		/*(void) fprintf( stderr, "doing partial scan at end\n" );*/
		if(   !	movabs( 0, y )
		   || ! readw( 1, count, 1 )
			)
			return	-1;
		for(	bytes = count * 3, p = pix_buf;
			bytes > 0;
			bytes -= load, p += load
			) {
		    if( bytes > MAX_RAT_READ ) {
			load = MAX_RAT_READ;
		    } else {
			load = bytes;
		    }
		    readval = read( ifp->if_fd, p, load );
		    if( readval < load ) {
			if (readval < 0) {
			    perror("READ ERROR");
			}
			(void) fprintf( stderr, "_rat_read() read failed\n");
			return -1;
		    }
		}
		for( p = pix_buf; count > 0; pixelp++, count-- )
			{
			(*pixelp)[RED] = *p++;
			(*pixelp)[GRN] = *p++;
			(*pixelp)[BLU] = *p++;
			}
		}
	return	0;
}

HIDDEN int
rat_write(FBIO *ifp, int x, int y, RGBpixel (*pixelp), int count)


/*	_ r a t _ w r i t e ( )
 */
{
	register int	nrows;
	int		ncols;
	static u_char	pix_buf[MAX_RAT_BUFF+1];

	/* If first scanline is a partial, output it separately.	*/
	if( x > 0 || x + count <= _fbsize )
		{	register int	bytes, i;
			register u_char	*p = pix_buf;
		if( ! movabs( x, y ) )
			return	-1;
		if( x + count <= _fbsize )
			ncols = i = count;  /* Only 1 scanline is involved.  */
		else			/* First scan is a partial.	*/
			ncols = i = _fbsize - x;
		y++;
		for( bytes = 0; i > 0; i--, pixelp++, bytes += 3, count-- )
			{
			*p++ = (*pixelp)[RED];
			*p++ = (*pixelp)[GRN];
			*p++ = (*pixelp)[BLU];
			}
		if( ! pixels( 1, ncols, pix_buf, bytes, ifp ) )
			return	-1;
		}
	/* Do all full scanlines.					*/
	while( (nrows = count / _fbsize) != 0 )
		{	register int	bytes, i, j;
			register u_char	*p = pix_buf,*p1;
		if( nrows * _fbsize * 3 > MAX_RAT_BUFF )
			nrows = MAX_RAT_BUFF / (_fbsize * 3);
		y += nrows;
		if( ! movabs( 0, y-1 ) )
			return	-1;
		for(	j = nrows , bytes = 0; j > 0; j-- )
		    {
		   p1 = p + ( (j-1)*_fbsize*3 );
		   for(	i = _fbsize; i > 0;
			i--, pixelp++, bytes += 3, count-- )
			{
			*p1++ = (*pixelp)[RED];
			*p1++ = (*pixelp)[GRN];
			*p1++ = (*pixelp)[BLU];
			}
		    }
		if( ! pixels( nrows, _fbsize, pix_buf, bytes, ifp ) )
			return	-1;
		}
	/* If partial scanline remains, finish up.			*/
	if( count > 0 )
		{	register int	bytes, i;
			register u_char	*p = pix_buf;
		if( ! movabs( 0, y ) )
			return	-1;
		ncols = count;
		for( bytes = 0; count > 0; pixelp++, bytes += 3, count-- )
			{
			*p++ = (*pixelp)[RED];
			*p++ = (*pixelp)[GRN];
			*p++ = (*pixelp)[BLU];
			}
		if( ! pixels( 1, ncols, pix_buf, bytes, ifp ) )
			return	-1;
		}
	return	0;
}

HIDDEN int
rat_rmap(FBIO *ifp, ColorMap *cmp)
{
	return(0);
}

HIDDEN int
rat_wmap(FBIO *ifp, ColorMap *cmp)


/*	_ r a t _ w m a p ( )
	Load the color map into the frame buffer.
 */
{
	{
	register int	i;

	/* If cmp is NULL, write standard map.				*/
	if( cmp == (ColorMap *) NULL )
/*		if( ! lutrmp( 7, 0, 255, 0, 255 ) )       */
/*			return	-1;         */
/*		else                   */
			return	0;
	else
		{
/*		for( i = 0; i < 256; i++ )
			if( ! lut8(	i,
					cmp->cm_red[i],
					cmp->cm_green[i],
					cmp->cm_blue[i]
					)
				)
				return	-1;
 */
		}
	return	0;
	}
}

HIDDEN int
rat_view(FBIO *ifp, int xcenter, int ycenter, int xzoom, int yzoom)
{
	rat_window_set(ifp, xcenter, ycenter);
	rat_zoom_set(ifp, xzoom, yzoom);
	fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);
	return	0;
}

HIDDEN int
rat_window_set(FBIO *ifp, int x, int y)


/*	_ r a t _ w i n d o w ( )
	This routine takes advantage of the fact that there is only 1
	scaling parameter available (equal scaling in x and y).
 */
{
	Rat_Cvt( x, y );
	Round_N( x, 20 );
	return	scrorg( x, y ) ? 0 : -1;
}

HIDDEN int
rat_zoom_set(FBIO *ifp, int x, int y)


/*	_ r a t _ z o o m ( )
	 The Raster Tech does not scale independently in x and y.
		Also addressing is the same in low and high res. so
		must zoom twice for low res.
 */
{
	zoom_factor = Max( x, y );
	zoom_factor = Min( zoom_factor, 16 );
	zoom_factor = Max( zoom_factor, 1 );
	return	zoom(	ifp->if_width == 512 && zoom_factor < 16 ?
			zoom_factor * 2 :
			zoom_factor
			) ? 0 : -1;
}

HIDDEN int
rat_setcursor(FBIO *ifp, unsigned char *bits, int xbits, int ybits, int xorig, int yorig)
{
	return	0;
}

HIDDEN int
rat_cursor(FBIO *ifp, int mode, int x, int y)
/*	Place cursor at image (pixel) coordinates x & y
 */


{
	fb_sim_cursor(ifp, mode, x, y);
/*	if(   !	cload( 5, x, y )  ||  ! xhair( 0, mode ) )
		return	-1;	*/
	if(   !	cload(17, x, y )  ||  ! cursor( 0, mode ) )
		return	-1;
	return	0;
}

/*	_ r a t _ i n i t ( )
	Reset, enter graphics mode, set interlace on, turn on 24 bit color.
	Set origin and zoom factor.
 */
_rat_init(FBIO *ifp)
{
	static unsigned char firstcmds[] = {0x10,0x01,0xFD,0x00};

	static unsigned char buff[] =
		{0x01,0x00,		/* Enter graphics	*/
		0x48,0x00,		/* MEMSEL 0		*/
		0x9D,0xFF,0x07,0x00};	/* WRMASK 255 7		*/

	if( warm()
	    &&	entergraphics()
/*	    &&	vidform( 0, 1 )   only if interlace needed  */
/*	    &&	memsel( 0 )		*/
/*	    &&	rgbtru( 1 )		*/
	    &&	wrmask( 255, 7 )	/* enable all bits & channels.	*/
	    &&	rdmask( 255 )		/* enable for reading.		*/
	    &&	readf( 0 )
	    &&	rdmode( 1 )
	    &&	rat_zoom_set( ifp, 1, 1 ) == 0
	    &&	scrorg( 0, 0 )
		)
		return	0;
	else
		return	-1;
	}


HIDDEN int
cload(int creg, int x, int y)
{
	u_char	buff[8];

	Rat_Cvt( x, y );
	buff[0] = 0xA0;
	buff[1] = creg;
	buff[2] = (x>>8)&0x0FF;		/* high_x, low_x.	*/
	buff[3] = x&0x0FF;
	buff[4] = (y>>8)&0x0FF;		/* high_y, low_y.	*/
	buff[5] = y&0x0FF;
	buff[6] = PAD;
	buff[7] = PAD;
	Rat_Write( "cload", buff );
	return	1;
	}

HIDDEN int
debug(int flag)
{
	u_char	buff[2];

	buff[0] = 0xA8;
	buff[1] = flag;
	Rat_Write( "debug", buff );
	return	1;
	}

HIDDEN int
entergraphics(void)
{
	u_char	buff[2];

	buff[0] = 0x01;
	buff[1] = PAD;

	Rat_Write( "entergraphics", buff );
	return	1;
	}

HIDDEN int
flood(void)
{
	u_char	buff[2];

	buff[0] = 0x07;
	buff[1] = PAD;
	Rat_Write( "flood", buff );
	return	1;
	}

HIDDEN int
lutrmp(int code, int sind, int eind, int sval, int eval)
{
	u_char	buff[6];

	buff[0] = 0x01d;
	buff[1] = code;
	buff[2] = sind;
	buff[3] = eind;
	buff[4] = sval;
	buff[5] = eval;
/*	Rat_Write( "lutrmp", buff );   */
	return	1;
	}

HIDDEN int
lut8(int index, u_char r, u_char g, u_char b)
{
	u_char	buff[6];

	buff[0] = 0x01c;
	buff[1] = index;
	buff[2] = r;
	buff[3] = g;
	buff[4] = b;
	buff[5] = PAD;
/*	Rat_Write( "lut8", buff );   */
	return	1;
	}

/*	m e m s e l ( )
	Select a memory unit.
	Since the RLE format splits up the colors running in RGBTRU OFF
	and selecting the unit for each color is the easiest way to go.
 */
HIDDEN int
memsel(int unit)
{
	u_char	buff[2];

	buff[0] = 0x48;
	buff[1] = unit;
/*	Rat_Write( "memsel", buff );    */
	return	1;
	}

/*	m o v a b s ( )
	Set the current position (CREG 0) to (x, y).
	The generic device has its origin in the upper left corner (modeled
	after the Ikonas or a UNIX file)...


	(0,      0)........................(ifp->if_width,         0)
	.							   .
	.							   .
	.							   .
	.							   .
	.							   .
	.                                          		   .
	(0, ifp->if_width).................(ifp->if_width, ifp->if_width)


	The Raster Tech. is a 4-quadrant cartesian device, so its origin is at
	screen center...


	(-_fbsize/2, _fbsize/2)......(_fbsize/2, _fbsize/2)
	.                                                 .
	.                                                 .
	.                                                 .
	.                      (0, 0)                     .
	.                                                 .
	.                                                 .
	.                                                 .
	(-_fbsize/2, -_fbsize/2).....(_fbsize/2, -_fbsize/2)
 */
HIDDEN int
movabs(register int x, register int y)
{
	u_char	buff[8];

	Rat_Cvt( x, y );
	buff[0] = 0x1;
	buff[1] = (x>>8)&0x0FF;		/* high_x, low_x.	*/
	buff[2] = x&0x0FF;
	buff[3] = (y>>8)&0x0FF;		/* high_y, low_y.	*/
	buff[4] = y&0x0FF;
	buff[5] = PAD;
	buff[6] = PAD;
	buff[7] = PAD;
	Rat_Write( "movabs", buff );
	return	1;
	}

HIDDEN int
pixels(int rows, int cols, register u_char *pix_buf, int bytes, FBIO *ifp)
{
	static u_char	buff[MAX_RAT_BUFF+6];
	register int	i, ct;

	if( rat_debug == 1 )
		debug( 0 );
	ct = bytes & 1 ? 5 + bytes : 6 + bytes; /* Insure even count.	*/
	buff[0] = 0x28;
	buff[1] = rows>>8 & 0xFF;
	buff[2] = rows & 0xFF;
	buff[3] = cols>>8 & 0xFF;
	buff[4] = cols & 0xFF;
	for( i = 5; i < ct; i++ )
		buff[i] = *pix_buf++;
	if( ! (bytes & 1) )
		buff[ct-1] = PAD;
	if( write( ifp->if_fd, buff, ct ) == -1 )
		{
		(void) fprintf( stderr, "pixels : write failed!\n" );
		return	0;
		}
	if( rat_debug == 1 )
		debug( rat_debug );
	return	1;
	}

HIDDEN int
quit(void)
{
	u_char	buff[2];

	buff[0] = 0xFF;
	buff[1] = PAD;
	Rat_Write( "quit", buff );
	return	1;
	}

/*	r d m a s k ( )
	Set read mask.
 */
HIDDEN int
rdmask(int bitm)
{
	u_char	buff[2];

	buff[0] = 0x9E;
	buff[1] = bitm;
	Rat_Write( "rdmask", buff );
	return	1;
	}

/*	r d m o d e ( )
 */
HIDDEN int
rdmode(int flag)
{
	u_char	buff[2];

	buff[0] = 0xD3;
	buff[1] = flag;
	Rat_Write( "rdmode", buff );
	return	1;
	}

HIDDEN int
rdpixr(int vreg)
{
	u_char	buff[2];

	buff[0] = 0xAF;
	buff[1] = vreg;
	Rat_Write( "rdpixr", buff );
	return	1;
	}

HIDDEN int
readf(int func)
{
	u_char	buff[2];

	buff[0] = 0x27;
	buff[1] = func;
	Rat_Write( "readf", buff );
	return	1;
	}

HIDDEN int
readvr(int vreg)
{
	u_char	buff[2];

	buff[0] = 0x99;
	buff[1] = vreg;
	Rat_Write( "readvr", buff );
	return	1;
	}

HIDDEN int
readw(int rows, int cols, int bf)
{
	u_char	buff[6];

	buff[0] = 0x96;
	buff[1] = rows>>8 & 0xFF;
	buff[2] = rows & 0xFF;
	buff[3] = cols>>8 & 0xFF;
	buff[4] = cols & 0xFF;
	buff[5] = bf;
	Rat_Write( "readw", buff );
	return	1;
	}

HIDDEN int
rgbtru(int flag)
{
	u_char	buff[2];

	buff[0] = 0x4e;
	buff[1] = flag;
	Rat_Write( "rgbtru", buff );
	return	1;
	}


/*	s c r o r g ( )
	Set the screen-center coordinate (CREG 4) to (x, y).
 */
HIDDEN int
scrorg(int x, int y)
{
	u_char	buff[6];

	buff[0] = 0x36;
	buff[1] = (x>>8) & 0x0FF;		/* high_x, low_x.	*/
	buff[2] = x & 0x0FF;
	buff[3] = (y>>8) & 0x0FF;		/* high_y, low_y.	*/
	buff[4] = y & 0x0FF;
	buff[5] = PAD;
	Rat_Write( "scrorg", buff );
	return	1;
	}

HIDDEN int
value(u_char red, u_char green, u_char blue)
{
	char	buff[4];

	buff[0] = 0x06;
	buff[1] = red;
	buff[2] = green;
	buff[3] = blue;
	Rat_Write( "value", buff );
	return	1;
	}

HIDDEN int
vidform(int mode, int flag)
{
	u_char	buff[4];

	buff[0] = 0x08;
	buff[1] = mode;
	buff[2] = flag;
	buff[3] = PAD;
	Rat_Write( "vidform", buff );
	return	1;
	}

HIDDEN int
warm(void)
{
	u_char	buff[2];

	buff[0] = 0x10;
	buff[1] = PAD;
	Rat_Write( "warm", buff );
	return	1;
	}

/*	w r m a s k ( )
	Set write mask.
 */
HIDDEN int
wrmask(int bitm, int bankm)
{
	u_char	buff[4];

	buff[0] = 0x9D;
	buff[1] = bitm;
	buff[2] = bankm;
	buff[3] = PAD;
	Rat_Write( "wrmask", buff );
	return	1;
	}

HIDDEN int
cursor(int num, int flag)
{
	u_char	buff[4];

	buff[0] = 0x4A;
	buff[1] = num;
	buff[2] = flag;
	buff[3] = PAD;
	Rat_Write( "cursor", buff );
	return	1;
	}


HIDDEN int
xhair(int num, int flag)
{
	u_char	buff[4];

	buff[0] = 0x9C;
	buff[1] = num;
	buff[2] = flag;
	buff[3] = PAD;
	Rat_Write( "xhair", buff );
	return	1;
	}

HIDDEN int
zoom(int factor)
{
	u_char	buff[2];

	buff[0] = 0x34;
	buff[1] = factor;
	Rat_Write( "zoom", buff );
	return	1;
	}

HIDDEN int
rat_help(FBIO *ifp)
{
	fb_log( "Description: %s\n", rat_interface.if_type );
	fb_log( "Device: %s\n", ifp->if_name );
	fb_log( "Max width/height: %d %d\n",
		rat_interface.if_max_width,
		rat_interface.if_max_height );
	fb_log( "Default width/height: %d %d\n",
		rat_interface.if_width,
		rat_interface.if_height );
	return(0);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.14 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
d54 1
a54 1
#include "./fblocal.h"
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.13 2007/01/21 04:45:42 brlcad Exp $ (BRL)";
a48 1

a200 2


a330 2


a492 1

a532 4




@


14.13
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d43 1
a43 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.12 2007/01/20 14:36:52 brlcad Exp $ (BRL)";
@


14.12
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup if */
/*@@{*/
d24 1
d41 1
a41 1
/*@@}*/
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.11 2006/08/08 06:47:05 brlcad Exp $ (BRL)";
@


14.11
log
@get rid of the libfb-specific _LOCAL_ macro, instead using HIDDEN like everyone else (currently still provided by machine.h)
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.10 2006/07/09 18:25:32 brlcad Exp $ (BRL)";
@


14.10
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
d80 1
a80 1
static int	cload(int creg, int x, int y),
d87 1
a87 1
_LOCAL_ int	rat_open(FBIO *ifp, char *file, int width, int height),
d146 1
a146 1
_LOCAL_ int
d163 1
a163 1
_LOCAL_ int
d181 1
a181 1
_LOCAL_ int
d199 1
a199 1
_LOCAL_ int
d331 1
a331 1
_LOCAL_ int
d406 1
a406 1
_LOCAL_ int
d412 1
a412 1
_LOCAL_ int
d445 1
a445 1
_LOCAL_ int
d454 1
a454 1
_LOCAL_ int
d468 1
a468 1
_LOCAL_ int
d487 1
a487 1
_LOCAL_ int
d493 1
a493 1
_LOCAL_ int
d544 1
a544 1
static int
d562 1
a562 1
static int
d573 1
a573 1
static int
d585 1
a585 1
static int
d596 1
a596 1
static int
d611 1
a611 1
static int
d631 1
a631 1
static int
d672 1
a672 1
static int
d690 1
a690 1
static int
d718 1
a718 1
static int
d732 1
a732 1
static int
d745 1
a745 1
static int
d756 1
a756 1
static int
d767 1
a767 1
static int
d778 1
a778 1
static int
d789 1
a789 1
static int
d804 1
a804 1
static int
d819 1
a819 1
static int
d834 1
a834 1
static int
d847 1
a847 1
static int
d860 1
a860 1
static int
d874 1
a874 1
static int
d887 1
a887 1
static int
d901 1
a901 1
static int
d914 1
a914 1
static int
d925 1
a925 1
_LOCAL_ int
@


14.9
log
@update copyright to 2006
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.8 2005/10/23 04:44:34 brlcad Exp $ (BRL)";
d213 1
d230 9
a238 13
			)
			{
			if( bytes > MAX_RAT_READ )
				load = MAX_RAT_READ;
			else
				load = bytes;
			if( read( ifp->if_fd, p, load ) < load )
				{
				(void) fprintf( stderr,
						"_rat_read() read failed\n"
						);
				return	-1;
				}
d240 4
d265 1
a265 2
			)
			{
d274 7
a280 7
			if( read( ifp->if_fd, p, load ) < load )
				{
				(void) fprintf( stderr,
						"_rat_read() read failed\n"
						);
				return	-1;
				}
d282 1
d306 10
a315 13
			)
			{
			if( bytes > MAX_RAT_READ )
				load = MAX_RAT_READ;
			else
				load = bytes;
			if( read( ifp->if_fd, p, load ) < load )
				{
				(void) fprintf( stderr,
						"_rat_read() read failed\n"
						);
				return	-1;
				}
d317 4
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.7 2005/08/12 22:30:12 lbutler Exp $ (BRL)";
@


14.7
log
@Doxygen changes
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.6 2005/04/13 01:43:20 brlcad Exp $ (BRL)";
d165 1
a165 1
    	     
d183 2
a184 2
    	     
        	    
d201 4
a204 4
    	     
   	     
        	        
   	      
d234 1
a234 1
				load = bytes;		
d269 1
a269 1
				load = bytes;		
d310 1
a310 1
				load = bytes;		
d331 4
a334 4
    	     
   	     
        	        
   	      
d412 2
a413 2
    	     
        	     
d420 1
a420 1
	
d431 1
a431 1
					cmp->cm_red[i], 
d454 2
a455 2
    	     
   	     
d468 2
a469 2
    	     
   	     
d495 3
a497 3
    	     
   	     
   	     
d674 1
a674 1
	
d775 1
a775 1
	
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d44 1
a44 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d165 1
a165 1

d183 2
a184 2


d201 4
a204 4




d234 1
a234 1
				load = bytes;
d269 1
a269 1
				load = bytes;
d310 1
a310 1
				load = bytes;
d331 4
a334 4




d412 2
a413 2


d420 1
a420 1

d431 1
a431 1
					cmp->cm_red[i],
d454 2
a455 2


d468 2
a469 2


d495 3
a497 3



d674 1
a674 1

d775 1
a775 1

@


14.6
log
@remove specific references to ARL addresses.  instead use brlcad.org mail aliases and the new sf.net mailing lists.
@
text
@d21 3
a24 1
 *
d41 2
d44 1
a44 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.5 2005/01/30 20:30:53 brlcad Exp $ (BRL)";
@


14.5
log
@update copyright to 2005
@
text
@d37 1
a37 1
 *   please let us know. <phil@@brl.mil>
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libfb/if_rat.c,v 14.4 2004/12/21 06:18:44 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_rat.c,v 14.3 2004/12/21 05:45:22 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_rat.c,v 14.2 2004/12/21 03:58:27 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_rat.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *                     I F _ R A T . C
d40 1
a40 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_rat.c,v 1.2 2004/08/02 23:01:48 morrison Exp $ (BRL)";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libfb/if_rat.c,v 1.1 2004/05/20 15:19:43 morrison Exp $ (BRL)";
d913 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d21 1
a21 1
static char RCSid[] = "@@(#)$Header: /cvs/brlcad/libfb/if_rat.c,v 11.6 2004/05/10 15:30:45 erikg Exp $ (BRL)";
d24 1
a24 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

