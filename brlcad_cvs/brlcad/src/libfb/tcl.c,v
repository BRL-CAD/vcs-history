head	14.35;
access;
symbols
	rel-7-10-4:14.32.2.1
	STABLE:14.32.0.2
	stable-branch:14.9
	rel-7-10-2:14.32
	rel-7-10-0:14.26
	rel-7-8-4:14.22
	rel-7-8-2:14.17
	rel-7-8-0:14.17
	trimnurbs-branch:14.15.0.2
	help:14.15
	temp_tag:14.12
	bobWinPort-20051223-freeze:14.11.2.1
	postmerge-20051223-bobWinPort:14.12
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.11
	rel-7-6-branch:14.11.0.4
	rel-7-6-0:14.11
	rel-7-4-2:14.10
	rel-7-4-branch:14.10.0.2
	bobWinPort:14.11.0.2
	rel-7-4-0:14.10
	rel-7-2-6:14.10
	rel-7-2-4:14.9
	rel-7-2-2:14.9
	rel-7-2-0:14.8
	rel-7-0-4:14.7
	rel-7-0-2:14.7
	rel-7-0-1:14.7
	opensource-post:14.7
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.35
date	2007.11.04.16.58.17;	author bob1961;	state Exp;
branches;
next	14.34;

14.34
date	2007.10.26.21.51.26;	author brlcad;	state Exp;
branches;
next	14.33;

14.33
date	2007.09.15.16.23.10;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.06.27.02.36.21;	author johnranderson;	state Exp;
branches
	14.32.2.1;
next	14.31;

14.31
date	2007.04.25.22.40.23;	author joevalleyfield;	state Exp;
branches;
next	14.30;

14.30
date	2007.04.23.13.30.20;	author joevalleyfield;	state Exp;
branches;
next	14.29;

14.29
date	2007.04.18.05.46.32;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.04.18.04.47.19;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.04.16.21.15.36;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.01.23.01.13.35;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.21.04.45.43;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.20.14.36.53;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2006.08.07.20.21.47;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2006.08.03.17.34.19;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.08.01.15.02.55;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.07.28.03.09.51;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2006.07.10.00.42.42;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.03.30.00.04.00;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.03.25.00.03.48;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.02.05.17.31.41;	author brlcad;	state Exp;
branches
	14.15.2.1;
next	14.14;

14.14
date	2006.01.23.00.02.15;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.12.23.21.26.30;	author bob1961;	state Exp;
branches;
next	14.11;

14.11
date	2005.08.12.22.30.12;	author lbutler;	state Exp;
branches
	14.11.2.1;
next	14.10;

14.10
date	2005.05.28.02.14.51;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.03.28.05.43.21;	author bob1961;	state Exp;
branches;
next	14.8;

14.8
date	2005.01.30.20.30.53;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.25.29;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.32;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.58.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.15;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.22;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.45;	author morrison;	state Exp;
branches;
next	;

14.11.2.1
date	2005.09.08.15.30.23;	author bob1961;	state Exp;
branches;
next	;

14.15.2.1
date	2006.04.07.19.30.18;	author jlowenz;	state Exp;
branches;
next	;

14.32.2.1
date	2007.09.28.14.07.48;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.35
log
@Mods to get the embedded fbserv working in the cadwidgets.
@
text
@/*                           T C L . C
 * BRL-CAD
 *
 * Copyright (c) 1997-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup libfb */
/** @@{ */
/** @@file ./libfb/tcl.c
 *
 *  LIBFB's Tcl interface.
 *
 *  Authors -
 *	Robert G. Parker
 *
 *	Source -
 *		The U. S. Army Research Laboratory
 *		Aberdeen Proving Ground, Maryland  21005-5068  USA
 */
/** @@} */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "tcl.h"
#include "machine.h"
#include "cmd.h"                  /* includes bu.h */
#include "fb.h"
#include "bu.h"

/* private headers */
#include "brlcad_version.h"


#define FB_TCL_CKMAG(_ptr, _magic, _str){ \
	struct bu_vls _fb_vls; \
\
	if(!(_ptr)){ \
		bu_vls_init(&_fb_vls); \
		bu_vls_printf(&_fb_vls, "ERROR: null %s ptr, file %s, line %d\n", \
			_str, __FILE__, __LINE__ ); \
		Tcl_AppendResult(interp, bu_vls_addr(&_fb_vls), (char *)NULL); \
		bu_vls_free(&_fb_vls); \
\
		return TCL_ERROR; \
	}else if(*((long *)(_ptr)) != (_magic)){ \
		bu_vls_init(&_fb_vls); \
		bu_vls_printf(&_fb_vls, "ERROR: bad %s ptr x%lx, s/b x%x, was x%lx, file %s, line %d\n", \
		_str, (long)_ptr, _magic, (long)*((long *)(_ptr)), __FILE__, __LINE__); \
		Tcl_AppendResult(interp, bu_vls_addr(&_fb_vls), (char *)NULL); \
		bu_vls_free(&_fb_vls); \
\
		return TCL_ERROR; \
	} \
}

#define FB_TCL_CK_FBIO(_p) FB_TCL_CKMAG(_p, FB_MAGIC, "FBIO")

/* from libfb/fb_obj.c */
extern int Fbo_Init(Tcl_Interp *interp);

/* XXX -- At some point these routines should be moved to FBIO */
#ifdef IF_WGL
extern int wgl_open_existing();
extern int wgl_close_existing();
extern FBIO wgl_interface;
extern void wgl_configureWindow();
extern int wgl_refresh();
#endif

#ifdef IF_OGL
extern int ogl_open_existing();
extern int ogl_close_existing();
extern FBIO ogl_interface;
extern void ogl_configureWindow();
extern int ogl_refresh();
#endif

#ifdef IF_X
extern void X24_configureWindow();
extern int X24_refresh();
extern int X24_open_existing();
extern int X24_close_existing();
extern FBIO X24_interface;
#endif

#ifdef IF_TK
#if 0
/*XXX TJM implement this interface */
extern void tk_configureWindow();
extern int tk_refresh();
extern int tk_open_existing();
extern int tk_close_existing();
extern FBIO tk_interface;
#endif
#endif

int fb_cmd_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int fb_cmd_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int fb_cmd_common_file_size(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);

static struct bu_cmdtab cmdtab[] = {
	{"fb_open_existing",	 fb_cmd_open_existing},
	{"fb_close_existing",	 fb_cmd_close_existing},
	{"fb_common_file_size",	 fb_cmd_common_file_size},
	{(char *)0, (int (*)())0}
};

/* XXX this device list shouldn't be in here */
static const char *X_device_name = "/dev/X";
static const char *tk_device_name = "/dev/tk";
static const char *ogl_device_name = "/dev/ogl";
static const char *wgl_device_name = "/dev/wgl";


int
fb_cmd_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    register FBIO *ifp;
    struct bu_vls vls;
    int found = 0;

    if(argc < 2){
	Tcl_AppendResult(interp, "XXXfb_open_existing: wrong number of args\n", (char *)NULL);
	return TCL_ERROR;
    }

    if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
	Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n", (char *)NULL);
	return TCL_ERROR;
    }

#ifdef IF_X
    if(strcasecmp(argv[1], X_device_name) == 0) {
	found=1;
	*ifp = X24_interface; /* struct copy */

	ifp->if_name = malloc((unsigned)strlen(X_device_name) + 1);
	(void)strncpy(ifp->if_name, X_device_name, strlen(X_device_name)+1);

	/* Mark OK by filling in magic number */
	ifp->if_magic = FB_MAGIC;

	if((X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	    ifp->if_magic = 0; /* sanity */
	    free((void *) ifp->if_name);
	    free((void *) ifp);
	    Tcl_AppendResult(interp, "fb_open_existing: failed to open X framebuffer\n", (char *)NULL);
	    return TCL_ERROR;
	}
    }
#endif  /* IF_X */

#ifdef IF_TK
#if 0
/* XXX TJM implment tk_open_existing */
    if(strcasecmp(argv[1], tk_device_name) == 0) {
	found=1;
	*ifp = tk_interface; /* struct copy */

	ifp->if_name = malloc((unsigned)strlen(tk_device_name) + 1);
	(void)strncpy(ifp->if_name, tk_device_name, strlen(tk_device_name)+1);

	/* Mark OK by filling in magic number */
	ifp->if_magic = FB_MAGIC;

	if((tk_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	    ifp->if_magic = 0; /* sanity */
	    free((void *) ifp->if_name);
	    free((void *) ifp);
	    Tcl_AppendResult(interp, "fb_open_existing: failed to open tk framebuffer\n", (char *)NULL);
	    return TCL_ERROR;
	}
    }
#endif
#endif  /* IF_TK */

#ifdef IF_WGL
    if(strcasecmp(argv[1], wgl_device_name) == 0) {
	found=1;
	*ifp = wgl_interface; /* struct copy */

	ifp->if_name = malloc((unsigned)strlen(wgl_device_name) + 1);
	(void)strncpy(ifp->if_name, wgl_device_name, strlen(wgl_device_name)+1);

	/* Mark OK by filling in magic number */
	ifp->if_magic = FB_MAGIC;

	if((wgl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	    ifp->if_magic = 0; /* sanity */
	    free((void *) ifp->if_name);
	    free((void *) ifp);
	    Tcl_AppendResult(interp, "fb_open_existing: failed to open wgl framebuffer\n", (char *)NULL);
	    return TCL_ERROR;
	}
    }
#endif  /* IF_WGL */

#ifdef IF_OGL
    if(strcasecmp(argv[1], ogl_device_name) == 0) {
	found=1;
	*ifp = ogl_interface; /* struct copy */

	ifp->if_name = malloc((unsigned)strlen(ogl_device_name) + 1);
	(void)strncpy(ifp->if_name, ogl_device_name, strlen(ogl_device_name)+1);

	/* Mark OK by filling in magic number */
	ifp->if_magic = FB_MAGIC;

	if((ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	    ifp->if_magic = 0; /* sanity */
	    free((void *) ifp->if_name);
	    free((void *) ifp);
	    Tcl_AppendResult(interp, "fb_open_existing: failed to open ogl framebuffer\n", (char *)NULL);
	    return TCL_ERROR;
	}
    }
#endif  /* IF_OGL */

    if (found) {
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_OK;
    }

    ifp->if_magic = 0; /* sanity */
    free((void *) ifp->if_name);
    free((void *) ifp);

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "fb_open_existing: supports only the following device types\n");
#ifdef IF_X
    bu_vls_strcat(&vls, X_device_name);
    bu_vls_strcat( &vls, "\n" );
#endif  /* IF_X */
#ifdef IF_WGL
    bu_vls_strcat(&vls, wgl_device_name);
    bu_vls_strcat( &vls, "\n" );
#endif  /* IF_WGL */
#ifdef IF_OGL
    bu_vls_strcat(&vls, ogl_device_name);
    bu_vls_strcat( &vls, "\n" );
#endif  /* IF_OGL */
#ifdef IF_TK
    bu_vls_strcat(&vls, tk_device_name);
    bu_vls_strcat( &vls, "\n" );
#endif  /* IF_TK */
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_ERROR;
}

int
fb_cmd_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    FBIO *ifp;
    struct bu_vls vls;
    int status;

    if(argc != 2){
	/* XXX need help message */
	return TCL_ERROR;
    }

    if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
	Tcl_AppendResult(interp, "fb_close_existing: failed to provide ifp\n", (char *)NULL);
	return TCL_ERROR;
    }

    FB_TCL_CK_FBIO(ifp);
    _fb_pgflush(ifp);
#ifdef IF_X
    if(strcasecmp(ifp->if_name, X_device_name) == 0) {
	if((status = X24_close_existing(ifp)) <= -1){
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
			  ifp->if_name, status);
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);

	    return TCL_ERROR;
	}
	if(ifp->if_pbase != PIXEL_NULL) {
	    free((void *)ifp->if_pbase);
	}
	free((void *)ifp->if_name);
	free((void *)ifp);
	return TCL_OK;
    }
#endif  /* IF_X */

#ifdef IF_WGL
    if(strcasecmp(ifp->if_name, wgl_device_name) == 0) {
	if((status = wgl_close_existing(ifp)) <= -1){
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
			  ifp->if_name, status);
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);

	    return TCL_ERROR;
	}
	if(ifp->if_pbase != PIXEL_NULL)
	    free((void *)ifp->if_pbase);
	free((void *)ifp->if_name);
	free((void *)ifp);
	return TCL_OK;
    }
#endif  /* IF_WGL */

#ifdef IF_OGL
    if(strcasecmp(ifp->if_name, ogl_device_name) == 0) {
	if((status = ogl_close_existing(ifp)) <= -1){
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
			  ifp->if_name, status);
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);

	    return TCL_ERROR;
	}
	if(ifp->if_pbase != PIXEL_NULL)
	    free((void *)ifp->if_pbase);
	free((void *)ifp->if_name);
	free((void *)ifp);
	return TCL_OK;
    }
#endif  /* IF_OGL */

#ifdef IF_TK
#if 0
/* XXX TJM: not yet */
    if(strcasecmp(ifp->if_name, tk_device_name) == 0) {
	if((status = tk_close_existing(ifp)) <= -1){
	    bu_vls_init(&vls);
	    bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
			  ifp->if_name, status);
	    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	    bu_vls_free(&vls);

	    return TCL_ERROR;
	}
	if(ifp->if_pbase != PIXEL_NULL)
	    free((void *)ifp->if_pbase);
	free((void *)ifp->if_name);
	free((void *)ifp);
	return TCL_OK;
    }
#endif
#endif  /* IF_TK */

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "fb_close_existing: can not close device\nifp: %s    device name: %s\n",
		  argv[1], ifp->if_name);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    return TCL_ERROR;
}

void
fb_configureWindow(FBIO *ifp, int width, int height)
{
#ifdef IF_X
    if (!strncmp(ifp->if_name, X_device_name, strlen(X_device_name))) {
	X24_configureWindow(ifp, width, height);
    }
#endif /* IF_X */
#ifdef IF_WGL
    if (!strncmp(ifp->if_name, wgl_device_name, strlen(wgl_device_name))) {
	wgl_configureWindow(ifp, width, height);
    }
#endif  /* IF_WGL */
#ifdef IF_OGL
    if (!strncmp(ifp->if_name, ogl_device_name, strlen(ogl_device_name))) {
	ogl_configureWindow(ifp, width, height);
    }
#endif  /* IF_OGL */
#ifdef IF_TK
#if 0
/* XXX TJM implement tk_configureWindow */
    if (!strncmp(ifp->if_name, tk_device_name, strlen(tk_device_name))) {
	tk_configureWindow(ifp, width, height);
    }
#endif
#endif  /* IF_TK */
}

int
fb_refresh(FBIO *ifp, int x, int y, int w, int h)
{
    int status=0;

#if 1
    if (w == 0 || h == 0)
	return TCL_OK;
#else
    if (w <= 0 || h <= 0) {
	/* nothing to refresh */
	return TCL_OK;
    }
#endif

    if (!ifp || !ifp->if_name) {
	/* unset/unknown framebuffer */
	return TCL_OK;
    }

#ifdef IF_X
    status = -1;
    if(!strncmp(ifp->if_name, X_device_name, strlen( X_device_name))) {
	status = X24_refresh(ifp, x, y, w, h);
    }
#endif /* IF_X */
#ifdef IF_WGL
    status = -1;
    if(!strncmp(ifp->if_name, wgl_device_name, strlen( wgl_device_name))) {
	status = wgl_refresh(ifp, x, y, w, h);
    }
#endif  /* IF_WGL */
#ifdef IF_OGL
    status = -1;
    if(!strncmp(ifp->if_name, ogl_device_name, strlen( ogl_device_name))) {
	status = ogl_refresh(ifp, x, y, w, h);
    }
#endif  /* IF_OGL */
#ifdef IF_TK
#if 0
/* XXX TJM implement tk_refresh */
    status = -1;
    if(!strncmp(ifp->if_name, tk_device_name, strlen( tk_device_name))) {
	status = tk_refresh(ifp, x, y, w, h);
    }
#endif
#endif  /* IF_TK */

    if(status < 0) {
	return TCL_ERROR;
    }

    return TCL_OK;
}


/** fb_cmd_common_file_size
 *
 * Hook function wrapper to the fb_common_file_size Tcl command
 */
int
fb_cmd_common_file_size(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
    unsigned long int width, height;
    int pixel_size = 3;

    if (argc != 2 && argc != 3) {
	Tcl_AppendResult(interp, "wrong #args: should be \"", argv[0], " fileName [#bytes/pixel]\"", NULL);
	return TCL_ERROR;
    }

    if (argc >= 3) {
	pixel_size = atoi(argv[2]);
    }

    if (fb_common_file_size(&width, &height, argv[1], pixel_size) > 0) {
	struct bu_vls vls;
	bu_vls_init( &vls );
	bu_vls_printf( &vls, "%lu %lu", width, height );
	Tcl_SetObjResult( interp,
	    Tcl_NewStringObj(bu_vls_addr( &vls ), bu_vls_strlen(&vls)) );
	bu_vls_free( &vls );
	return TCL_OK;
    }

    /* Signal error */
    Tcl_SetResult(interp, "0 0", TCL_STATIC);
    return TCL_OK;
}


/*
 *			F B _ I N I T
 *
 *  Allows LIBFB to be dynamically loade to a vanilla tclsh/wish with
 *  "load /usr/brlcad/lib/libfb.so"
 *
 *  The name of this function is specified by TCL.
 */
int
#ifdef BRLCAD_DEBUG
Fb_d_Init(Tcl_Interp *interp)
#else
Fb_Init(Tcl_Interp *interp)
#endif
{
	/* register commands */
	bu_register_cmds(interp, cmdtab);

	/* initialize framebuffer object code */
	Fbo_Init(interp);

	Tcl_PkgProvide(interp,  "Fb", brlcad_version());

	return TCL_OK;
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.34
log
@yet another surge of level 4 flawfinder string length checks. somewhere around 30-40% done.
@
text
@d415 4
d423 1
@


14.33
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d156 1
a156 1
	(void)strcpy(ifp->if_name, X_device_name);
d179 1
a179 1
	(void)strcpy(ifp->if_name, tk_device_name);
d201 1
a201 1
	(void)strcpy(ifp->if_name, wgl_device_name);
d222 1
a222 1
	(void)strcpy(ifp->if_name, ogl_device_name);
@


14.32
log
@Eliminated more direct access of interp->result
@
text
@d40 1
a40 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.32.2.1
log
@merge from head, make linger the default framebuffer action instead of transient for all windowing framebuffer interfaces.
@
text
@d40 5
a44 1
#include <string.h>
@


14.31
log
@tk_close_existing doesn't exist yet; temporarily remove references thereto.
@
text
@d485 6
a490 1
	sprintf(interp->result, "%lu %lu", width, height);
@


14.30
log
@preliminary support for unaccelerated mgen on aqua through dm-tk

configure.ac:
        - use two levels of expansion for BRLCAD_DATA
        - enable_aqua configure option
        - move X11 ac_ macro tests from argument check section
        - rely on AC_PATH_XTRA to figure out most of what we need to know about
                where to find X
        - no longer look for libICE, libXmu, or libXsm  AC_PATH_XTRA
                populates X_PRE_LIBS with these but they seem completely unused
                right now.
        - look for opengl libs and headers in all of the places AC_PATH_XTRA
                looked for the xlibs
        - use tk's xlib headers when using tk-aqua rather than x
        - remove X11 "ugly hack"
        - include tk flags where necessary
        - remove --disable-shared from subconfigs
        - forcibly add tcl and tk build dirs to libtool wrapper scripts
libdm/Makefile.am, dm-tk.[ch], dm.h, dm-generic.c, dm_obj.c, mged/Makefile.am,
                attach.c, dm-generic.c, dm-tk.c, ged.c:
        - use lower case when referring to tk
        - add support for using dm-tk
        - include X_CFLAGS with DM_X
irprep/Makefile.am, util/Makefile.am:
        - disable build of ir-X, pl-X when there is no X
dm-X.c:
        - no need to test for HAVE_X11_XLIB here; if we don't have it we
                shouldn't be building this file
libfb/Makefile.am, if_tk.c, libfb/tcl.c:
        - build if_tk.c
        - add preliminary hooks so if_tk can be called when ready
@
text
@d356 2
d374 1
@


14.29
log
@need brlcad_version.h header
@
text
@d108 11
d132 1
d175 24
d268 4
d355 19
d401 8
d444 9
@


14.28
log
@BRLCAD_VERSION is now obsolete, remove all references, use brlcad_version() instead for the triplet.
@
text
@d52 4
@


14.27
log
@revamp BRL-CAD's versioning setup.  no longer rely upon the vers.sh script, allowing for a more unified cross-platform configuration.  instead of globals, provide per-library functions that return the version string.  the version numbers are now stored in files in include/conf/.
@
text
@d433 1
a433 1
	Tcl_PkgProvide(interp,  "Fb", BRLCAD_VERSION);
@


14.26
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a426 2
	const char *version_number;

d433 1
a433 5

	Tcl_SetVar(interp, "fb_version", (char *)fb_version+5, TCL_GLOBAL_ONLY);
	Tcl_Eval(interp, "lindex $fb_version 2");
	version_number = Tcl_GetStringResult(interp);
	Tcl_PkgProvide(interp,  "Fb", version_number);
@


14.25
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d200 1
a200 1
    
d213 1
a213 1
    
@


14.24
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.23
log
@update copyright to 2007
@
text
@d21 2
a22 4

/** \addtogroup libfb */
/*@@{*/

d24 1
d34 1
a34 1
/*@@}*/
@


14.22
log
@decouple IF_X from the other framebuffer interfaces (ogl and wgl in particular).  Windows should not define IF_X unless they want the X11 interface.
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2006 United States Government as represented by
@


14.21
log
@add support for the new 'wgl' WindowsGL interface
@
text
@d98 1
a98 1
#if defined(IF_X) && !defined(_WIN32)
d120 1
a125 1
#ifdef IF_X
d128 1
d140 1
a140 1
#ifndef _WIN32
d142 1
d159 1
a159 1
#endif  /* _WIN32 */
d163 1
d184 1
d202 9
d215 1
a215 1

d218 1
a218 1
#if !defined(_WIN32)
d221 1
a221 1
#endif  /* !_WIN32 */
a233 8

    bu_vls_init(&vls);
    bu_vls_printf(&vls, "%lu", (unsigned long)ifp);
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);
#endif  /* IF_X */

    return TCL_OK;
a238 1
#ifdef IF_X
d255 1
a255 1
#ifndef _WIN32
d273 1
a273 1
#endif  /* _WIN32 */
a319 1
#endif  /* IF_X */
a325 2

#ifndef _WIN32
d329 1
a329 1
#endif
a339 1
#endif  /* IF_X */
a357 1
#  ifndef _WIN32
d362 2
a363 2
#  endif
#  ifdef IF_WGL
d368 2
a369 2
#  endif  /* IF_WGL */
#  ifdef IF_OGL
d374 1
a374 2
#  endif  /* IF_OGL */
#endif
@


14.20
log
@refactor the three asize.c implementations (libbn, libfb, & canon) into just one.  libbn had the most comprehensive and updated version, but the logic belongs in libfb.  so, the bn_common autosizing functions are now consolidated to libfb, refactoring accordingly.
@
text
@d82 8
d159 20
d209 4
d271 19
d308 1
d329 5
d364 6
@


14.19
log
@go ahead and check for valid parameters to fb_refresh even if this isn't IF_X
@
text
@d98 3
a100 2
int fb_tcl_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
int fb_tcl_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv);
d103 3
a105 2
	{"fb_open_existing",	 fb_tcl_open_existing},
	{"fb_close_existing",	 fb_tcl_close_existing},
d115 1
a115 24
#ifdef BRLCAD_DEBUG
Fb_d_Init(Tcl_Interp *interp)
#else
Fb_Init(Tcl_Interp *interp)
#endif
{
	const char *version_number;

	/* register commands */
	bu_register_cmds(interp, cmdtab);

	/* initialize framebuffer object code */
	Fbo_Init(interp);

	Tcl_SetVar(interp, "fb_version", (char *)fb_version+5, TCL_GLOBAL_ONLY);
	Tcl_Eval(interp, "lindex $fb_version 2");
	version_number = Tcl_GetStringResult(interp);
	Tcl_PkgProvide(interp,  "Fb", version_number);

	return TCL_OK;
}

int
fb_tcl_open_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d200 1
a200 1
fb_tcl_close_existing(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
d322 64
@


14.18
log
@add some error checking to fb_refresh in case there is a caller that passes a null or unnamed framebuffer, or nothing left to do with a non-positive width/height rect
@
text
@d309 1
a309 2
#ifdef IF_X
    int status=-1;
d321 1
d323 1
d329 1
d334 1
a339 2
#endif  /* IF_X */

@


14.17
log
@revert the libbu memory management changes to libpkg just to be safe.  if someone happens to call bu_semaphore_acquire on a BU_SEM_SYSCALL semaphore, the call will block since libbu utilizes that semaphore internally (and it's expected that callers know this..).
@
text
@d229 1
a229 1
	/*XXX need help message */
d251 1
a251 1
	if(ifp->if_pbase != PIXEL_NULL)
d253 1
d294 1
a294 1
    if (!strncmp(ifp->if_name, X_device_name, strlen(X_device_name)))
d296 1
d299 1
a299 1
    if (!strncmp(ifp->if_name, ogl_device_name, strlen(ogl_device_name)))
d301 1
d310 12
a321 1
	int status=-1;
d323 3
a325 3
	if(!strncmp(ifp->if_name, X_device_name, strlen( X_device_name))) {
		status = X24_refresh(ifp, x, y, w, h);
	}
d328 3
a330 3
	if(!strncmp(ifp->if_name, ogl_device_name, strlen( ogl_device_name))) {
		status = ogl_refresh(ifp, x, y, w, h);
	}
d333 3
a335 2
	if(status < 0)
		return TCL_ERROR;
d339 1
a339 1
	return TCL_OK;
@


14.16
log
@quell intel on altix compiler warnings
@
text
@d147 4
a150 1
    ifp = (FBIO *)bu_calloc(sizeof(FBIO), 1, "FBIO: fb_open_existing");
d156 1
a156 1
	ifp->if_name = bu_malloc((unsigned)strlen(X_device_name) + 1, "if_name");
d164 1
a164 1
	    bu_free((void *) ifp->if_name, "if_name");
d176 1
a176 1
	ifp->if_name = (char *)bu_malloc((unsigned)strlen(ogl_device_name) + 1, "if_name");
d184 1
a184 1
	    bu_free((void *) ifp->if_name, "if_name");
d193 1
a193 1
    bu_free((void *) ifp->if_name, "if_name");
d253 2
a254 2
	bu_free((void *)ifp->if_name, "if_name");
	bu_free((void *)ifp, "FBIO: fb_tcl_close_existing");
d272 2
a273 2
	bu_free((void *)ifp->if_name, "if_name");
	bu_free((void *)ifp, "FBIO: fb_tcl_close_existing");
@


14.15
log
@need stdlib for free(), change to libbu memory management in other places
@
text
@d67 2
a68 2
		bu_vls_printf(&_fb_vls, "ERROR: bad %s ptr x%x, s/b x%x, was x%x, file %s, line %d\n", \
		_str, _ptr, _magic, *((long *)(_ptr)), __FILE__, __LINE__); \
@


14.15.2.1
log
@update from HEAD
@
text
@d67 2
a68 2
		bu_vls_printf(&_fb_vls, "ERROR: bad %s ptr x%lx, s/b x%x, was x%lx, file %s, line %d\n", \
		_str, (long)_ptr, _magic, (long)*((long *)(_ptr)), __FILE__, __LINE__); \
d147 1
a147 4
    if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
	Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n", (char *)NULL);
	return TCL_ERROR;
    }
d153 1
a153 1
	ifp->if_name = malloc((unsigned)strlen(X_device_name) + 1);
d161 1
a161 1
	    free((void *) ifp->if_name);
d173 1
a173 1
	ifp->if_name = malloc((unsigned)strlen(ogl_device_name) + 1);
d181 1
a181 1
	    free((void *) ifp->if_name);
d190 1
a190 1
    free((void *) ifp->if_name);
d250 2
a251 2
	free((void *)ifp->if_name);
	free((void *)ifp);
d269 2
a270 2
	free((void *)ifp->if_name);
	free((void *)ifp);
@


14.14
log
@use bu_malloc and bu_free instead of malloc
@
text
@d39 1
d147 1
a147 4
    if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
	Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n", (char *)NULL);
	return TCL_ERROR;
    }
d251 1
a251 1
	free((void *)ifp);
d270 1
a270 1
	free((void *)ifp);
@


14.13
log
@update copyright to 2006
@
text
@a38 2


d42 1
a42 1
#include <string.h>
d44 1
a44 1
#include <strings.h>
d51 1
d155 1
a155 1
	ifp->if_name = malloc((unsigned)strlen(X_device_name) + 1);
d163 1
a163 1
	    free((void *) ifp->if_name);
d175 1
a175 1
	ifp->if_name = malloc((unsigned)strlen(ogl_device_name) + 1);
d183 1
a183 1
	    free((void *) ifp->if_name);
d192 1
a192 1
    free((void *) ifp->if_name);
d252 1
a252 1
	free((void *)ifp->if_name);
d271 1
a271 1
	free((void *)ifp->if_name);
@


14.12
log
@Merge of bobWinPort
@
text
@d4 1
a4 1
 * Copyright (C) 1997-2005 United States Government as represented by
@


14.11
log
@Doxygen changes
@
text
@d113 3
d117 1
@


14.11.2.1
log
@Mods for windows port
@
text
@a112 3
#ifdef BRLCAD_DEBUG
Fb_d_Init(Tcl_Interp *interp)
#else
a113 1
#endif
@


14.10
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d21 5
a25 2
/** @@file tcl.c
 *
d35 1
@


14.9
log
@If Windows, use _stricmp and strnicmp instead of strcasecmp and strncmp, respectively
@
text
@d86 1
a86 1
#if defined(IF_X) && !defined(WIN32)
d144 1
a144 1
#ifndef WIN32
d162 1
a162 1
#endif  /* WIN32 */
a164 3
#ifdef WIN32
    if(_stricmp(argv[1], ogl_device_name) == 0) {
#else
a165 1
#endif  /* WIN32 */
d190 1
a190 1
#if !defined(WIN32)
d193 1
a193 1
#endif  /* !WIN32 */
d232 1
a232 1
#ifndef WIN32
d249 1
a249 1
#endif  /* WIN32 */
a251 3
#ifdef WIN32
    if(_stricmp(ifp->if_name, ogl_device_name) == 0) {
#else
a252 1
#endif
d284 1
a284 1
#ifndef WIN32
a288 4
#ifdef WIN32	
    if (!_strnicmp(ifp->if_name, ogl_device_name, strlen(ogl_device_name)))
	ogl_configureWindow(ifp, width, height);
#else
a290 1
#endif /* WIN32 */
d300 1
a300 1
#  ifndef WIN32
a305 5
#    ifdef WIN32	
	if(!_strnicmp(ifp->if_name, ogl_device_name, strlen( ogl_device_name))) {
		status = ogl_refresh(ifp, x, y, w, h);
	}
#    else
a308 1
#    endif  /* WIN32 */
@


14.8
log
@update copyright to 2005
@
text
@d131 2
a132 2
  register FBIO *ifp;
  struct bu_vls vls;
d134 4
a137 4
  if(argc < 2){
    Tcl_AppendResult(interp, "XXXfb_open_existing: wrong number of args\n", (char *)NULL);
    return TCL_ERROR;
  }
d139 4
a142 4
  if((ifp = (FBIO *)calloc(sizeof(FBIO), 1)) == FBIO_NULL){
    Tcl_AppendResult(interp, "fb_open_existing: failed to allocate ifp memory\n", (char *)NULL);
    return TCL_ERROR;
  }
d144 19
a162 9
#  ifndef WIN32
  if(strcasecmp(argv[1], X_device_name) == 0) {
    *ifp = X24_interface; /* struct copy */

    ifp->if_name = malloc((unsigned)strlen(X_device_name) + 1);
    (void)strcpy(ifp->if_name, X_device_name);

    /* Mark OK by filling in magic number */
    ifp->if_magic = FB_MAGIC;
d164 4
a167 12
    if((X24_open_existing(ifp, argc - 1, argv + 1)) <= -1){
      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);
      Tcl_AppendResult(interp, "fb_open_existing: failed to open X framebuffer\n", (char *)NULL);
      return TCL_ERROR;
    }
  }
  
#  endif  /* WIN32 */

#  ifdef IF_OGL
d169 2
a170 1
      *ifp = ogl_interface; /* struct copy */
d172 2
a173 2
      ifp->if_name = malloc((unsigned)strlen(ogl_device_name) + 1);
      (void)strcpy(ifp->if_name, ogl_device_name);
d175 2
a176 2
      /* Mark OK by filling in magic number */
      ifp->if_magic = FB_MAGIC;
d178 7
a184 7
      if((ogl_open_existing(ifp, argc - 1, argv + 1)) <= -1){
	ifp->if_magic = 0; /* sanity */
	free((void *) ifp->if_name);
	free((void *) ifp);
	Tcl_AppendResult(interp, "fb_open_existing: failed to open ogl framebuffer\n", (char *)NULL);
	return TCL_ERROR;
      }
d186 5
a190 1
#  endif  /* IF_OGL */
d192 12
a203 16
      ifp->if_magic = 0; /* sanity */
      free((void *) ifp->if_name);
      free((void *) ifp);

      bu_vls_init(&vls);
      bu_vls_printf(&vls, "fb_open_existing: supports only the following device types\n");
#  if defined(IF_X) && !defined(WIN32)
      bu_vls_strcat(&vls, X_device_name);
      bu_vls_strcat( &vls, "\n" );
#  endif  /* IF_X && !WIN32 */
#  ifdef IF_OGL
      bu_vls_strcat(&vls, ogl_device_name);
      bu_vls_strcat( &vls, "\n" );
#  endif  /* IF_OGL */
      Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
      bu_vls_free(&vls);
d205 1
a205 1
      return TCL_ERROR;
d220 3
a222 3
	FBIO *ifp;
	struct bu_vls vls;
	int status;
d224 4
a227 4
	if(argc != 2){
		/*XXX need help message */
		return TCL_ERROR;
	}
d229 4
a232 4
	if(sscanf(argv[1], "%lu", (unsigned long *)&ifp) != 1){
		Tcl_AppendResult(interp, "fb_close_existing: failed to provide ifp\n", (char *)NULL);
		return TCL_ERROR;
	}
d234 20
a253 20
	FB_TCL_CK_FBIO(ifp);
	_fb_pgflush(ifp);
#  ifndef WIN32
	if(strcasecmp(ifp->if_name, X_device_name) == 0) {
		if((status = X24_close_existing(ifp)) <= -1){
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
				      ifp->if_name, status);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}
		if(ifp->if_pbase != PIXEL_NULL)
			free((void *)ifp->if_pbase);
		free((void *)ifp->if_name);
		free((void *)ifp);
		return TCL_OK;
	}
#  endif  /* WIN32 */
d255 27
a281 25
#  ifdef IF_OGL
	if(strcasecmp(ifp->if_name, ogl_device_name) == 0) {
		if((status = ogl_close_existing(ifp)) <= -1){
			bu_vls_init(&vls);
			bu_vls_printf(&vls, "fb_close_existing: can not close device \"%s\", ret=%d.\n",
				      ifp->if_name, status);
			Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
			bu_vls_free(&vls);

			return TCL_ERROR;
		}
		if(ifp->if_pbase != PIXEL_NULL)
			free((void *)ifp->if_pbase);
		free((void *)ifp->if_name);
		free((void *)ifp);
		return TCL_OK;
	}
#  endif  /* IF_OGL */
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "fb_close_existing: can not close device\nifp: %s    device name: %s\n",
			      argv[1], ifp->if_name);
	Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	return TCL_ERROR;
d283 1
a284 1

d292 13
a304 13
#  ifndef WIN32
	if (!strncmp(ifp->if_name, X_device_name, strlen(X_device_name)))
		X24_configureWindow(ifp, width, height);
#  endif
#  ifdef IF_OGL
#    ifdef WIN32	
	if (!strnicmp(ifp->if_name, ogl_device_name, strlen(ogl_device_name)))
		ogl_configureWindow(ifp, width, height);
#    else
	if (!strncmp(ifp->if_name, ogl_device_name, strlen(ogl_device_name)))
		ogl_configureWindow(ifp, width, height);
#    endif /* WIN32 */
#  endif  /* IF_OGL */
d320 1
a320 1
	if(!strnicmp(ifp->if_name, ogl_device_name, strlen( ogl_device_name))) {
@


14.7
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1997-2004 United States Government as represented by
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a30 2
 *
 *
@


14.5
log
@remove the old distribution notice section
@
text
@a32 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1997-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a31 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *                      T C L . C
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d322 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d29 1
a29 1
#ifdef USE_STRING_H
@


1.2
log
@obliterate externs.h
@
text
@d23 1
a23 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a38 1
#include "externs.h"
@

