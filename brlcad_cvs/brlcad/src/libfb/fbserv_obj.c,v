head	14.23;
access;
symbols
	rel-7-10-4:14.19
	STABLE:14.19.0.2
	stable-branch:14.5
	rel-7-10-2:14.19
	rel-7-10-0:14.19
	rel-7-8-4:14.16
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.11.0.2
	help:14.11
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.7
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.4
	rel-7-6-0:14.6
	rel-7-4-2:14.5
	rel-7-4-branch:14.5.0.2
	bobWinPort:14.6.0.2
	rel-7-4-0:14.5
	rel-7-2-6:14.5
	rel-7-2-4:14.5
	rel-7-2-2:14.5
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.23
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.11.06.20.41.44;	author bob1961;	state Exp;
branches;
next	14.21;

14.21
date	2007.11.05.04.38.17;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.11.04.17.02.24;	author bob1961;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.20.14.36.52;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.08.28.00.55.25;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.08.06.47.04;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.07.09.18.25.31;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.03.30.00.03.59;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.03.25.00.03.48;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.23.00.04.36;	author brlcad;	state Exp;
branches
	14.11.2.1;
next	14.10;

14.10
date	2006.01.22.10.20.20;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.21.17.02.45;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.34;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.08.12.22.30.12;	author lbutler;	state Exp;
branches
	14.6.4.1;
next	14.5;

14.5
date	2005.01.30.20.30.48;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.44;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.22;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.58.27;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.20;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.40;	author morrison;	state Exp;
branches;
next	;

14.6.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.11.2.1
date	2006.04.07.19.30.18;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.23
log
@convert all bzero calls to memset
@
text
@/*                    F B S E R V _ O B J . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup fb */
/** @@{ */
/** @@file fbserv_obj.c
 *
 * A framebuffer server object contains the attributes and
 * methods for implementing an fbserv. This code was developed
 * in large part by modifying the stand-alone version of fbserv.
 *
 * Source -
 *	SLAD CAD Team
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
 *
 * Author -
 *	Robert G. Parker
 *
 * Authors of fbserv -
 *	Phillip Dykstra
 *	Michael John Muuss
 *
 */
/** @@} */
#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#ifdef HAVE_WINSOCK_H
#  include <process.h>
#  include <winsock.h>
#  include <fcntl.h>
#  include <io.h>
#else
#  include <sys/socket.h>
#  include <netinet/in.h>		/* For htonl(), etc */
#endif

#include "tcl.h"
#include "machine.h"
#include "bu.h"
#include "vmath.h"
#include "raytrace.h"
#include "dm.h"

#include "fbmsg.h"
#include "fbserv_obj.h"

HIDDEN void drop_client(struct fbserv_obj *fbsp, int sub);
#if defined(_WIN32) && !defined(__CYGWIN__)
HIDDEN void new_client(struct fbserv_obj *fbsp, struct pkg_conn *pcp, Tcl_Channel chan);
HIDDEN void new_client_handler(ClientData clientData, Tcl_Channel chan, char *host, int port);
#else
HIDDEN void new_client(struct fbserv_obj *fbsp, struct pkg_conn *pcp);
HIDDEN void new_client_handler(ClientData clientData, int mask);
#endif
HIDDEN void existing_client_handler(ClientData clientData, int mask);
HIDDEN void comm_error(char *str);
HIDDEN void setup_socket(int fd);

/*
 * Package Handlers.
 */
void fbs_pkgfoo(struct pkg_conn *pcp, char *buf);	/* foobar message handler */
void fbs_rfbopen(struct pkg_conn *pcp, char *buf);
void fbs_rfbclose(struct pkg_conn *pcp, char *buf);
void fbs_rfbclear(struct pkg_conn *pcp, char *buf);
void fbs_rfbread(struct pkg_conn *pcp, char *buf);
void fbs_rfbwrite(struct pkg_conn *pcp, char *buf);
void fbs_rfbcursor(struct pkg_conn *pcp, char *buf);
void fbs_rfbgetcursor(struct pkg_conn *pcp, char *buf);
void fbs_rfbrmap(struct pkg_conn *pcp, char *buf);
void fbs_rfbwmap(struct pkg_conn *pcp, char *buf);
void fbs_rfbhelp(struct pkg_conn *pcp, char *buf);
void fbs_rfbreadrect(struct pkg_conn *pcp, char *buf);
void fbs_rfbwriterect(struct pkg_conn *pcp, char *buf);
void fbs_rfbbwreadrect(struct pkg_conn *pcp, char *buf);
void fbs_rfbbwwriterect(struct pkg_conn *pcp, char *buf);
void fbs_rfbpoll(struct pkg_conn *pcp, char *buf);
void fbs_rfbflush(struct pkg_conn *pcp, char *buf);
void fbs_rfbfree(struct pkg_conn *pcp, char *buf);
void fbs_rfbview(struct pkg_conn *pcp, char *buf);
void fbs_rfbgetview(struct pkg_conn *pcp, char *buf);
void fbs_rfbsetcursor(struct pkg_conn *pcp, char *buf);
/* Old Routines */
void fbs_rfbscursor(struct pkg_conn *pcp, char *buf);
void fbs_rfbwindow(struct pkg_conn *pcp, char *buf);
void fbs_rfbzoom(struct pkg_conn *pcp, char *buf);

static struct pkg_switch pkg_switch[] = {
	{ MSG_FBOPEN,		fbs_rfbopen,	"Open Framebuffer" },
	{ MSG_FBCLOSE,		fbs_rfbclose,	"Close Framebuffer" },
	{ MSG_FBCLEAR,		fbs_rfbclear,	"Clear Framebuffer" },
	{ MSG_FBREAD,		fbs_rfbread,	"Read Pixels" },
	{ MSG_FBWRITE,		fbs_rfbwrite,	"Write Pixels" },
	{ MSG_FBWRITE + MSG_NORETURN,	fbs_rfbwrite,	"Asynch write" },
	{ MSG_FBCURSOR,		fbs_rfbcursor,	"Cursor" },
	{ MSG_FBGETCURSOR,	fbs_rfbgetcursor,	"Get Cursor" },	   /*NEW*/
	{ MSG_FBSCURSOR,	fbs_rfbscursor,	"Screen Cursor" }, /*OLD*/
	{ MSG_FBWINDOW,		fbs_rfbwindow,	"Window" },	   /*OLD*/
	{ MSG_FBZOOM,		fbs_rfbzoom,	"Zoom" },	   /*OLD*/
	{ MSG_FBVIEW,		fbs_rfbview,	"View" },	   /*NEW*/
	{ MSG_FBGETVIEW,	fbs_rfbgetview,	"Get View" },	   /*NEW*/
	{ MSG_FBRMAP,		fbs_rfbrmap,	"R Map" },
	{ MSG_FBWMAP,		fbs_rfbwmap,	"W Map" },
	{ MSG_FBHELP,		fbs_rfbhelp,	"Help Request" },
	{ MSG_ERROR,		fbs_pkgfoo,		"Error Message" },
	{ MSG_CLOSE,		fbs_pkgfoo,		"Close Connection" },
	{ MSG_FBREADRECT, 	fbs_rfbreadrect,	"Read Rectangle" },
	{ MSG_FBWRITERECT,	fbs_rfbwriterect,	"Write Rectangle" },
	{ MSG_FBWRITERECT + MSG_NORETURN, fbs_rfbwriterect,"Write Rectangle" },
	{ MSG_FBBWREADRECT, 	fbs_rfbbwreadrect,"Read BW Rectangle" },
	{ MSG_FBBWWRITERECT,	fbs_rfbbwwriterect,"Write BW Rectangle" },
	{ MSG_FBBWWRITERECT+MSG_NORETURN, fbs_rfbbwwriterect,"Write BW Rectangle" },
	{ MSG_FBFLUSH,		fbs_rfbflush,	"Flush Output" },
	{ MSG_FBFLUSH + MSG_NORETURN, fbs_rfbflush, "Flush Output" },
	{ MSG_FBFREE,		fbs_rfbfree,	"Free Resources" },
	{ MSG_FBPOLL,		fbs_rfbpoll,	"Handle Events" },
	{ MSG_FBSETCURSOR,	fbs_rfbsetcursor,	"Set Cursor Shape" },
	{ MSG_FBSETCURSOR + MSG_NORETURN, fbs_rfbsetcursor, "Set Cursor Shape" },
	{ 0,			NULL,		NULL }
};

static FBIO *curr_fbp;		/* current framebuffer pointer */

#if defined(_WIN32) && !defined(__CYGWIN__)
int
fbs_open(struct fbserv_obj *fbsp, int port)
{
    struct bu_vls vls;
    char hostname[32];
    register int i;
    Tcl_DString ds;

    /* Already listening; nothing more to do. */
    if (fbsp->fbs_listener.fbsl_chan != NULL) {
	return TCL_OK;
    }

    /*XXX hardwired for now */
    sprintf(hostname,"localhost");

    if (port < 0)
	port = 5559;
    else if (port < 1024)
	port += 5559;

    Tcl_DStringInit(&ds);

    /* Try a reasonable number of times to hang a listen */
    for (i = 0; i < MAX_PORT_TRIES; ++i) {
	/*
	 * Hang an unending listen for PKG connections
	 */
	fbsp->fbs_listener.fbsl_chan = Tcl_OpenTcpServer(fbsp->fbs_interp,
							 port,
							 hostname,
							 new_client_handler,
							 (ClientData)&fbsp->fbs_listener);

	if (fbsp->fbs_listener.fbsl_chan == NULL) {
	    /* This clobbers the result string which probably has junk related to the failed open */
	    Tcl_DStringResult(fbsp->fbs_interp, &ds);
	    ++port;
	} else
	    break;
    }

    if (fbsp->fbs_listener.fbsl_chan == NULL) {
	bu_vls_init(&vls);
	bu_vls_printf(&vls, "fbs_open: failed to hang a listen on ports %d - %d\n",
		      fbsp->fbs_listener.fbsl_port, fbsp->fbs_listener.fbsl_port + MAX_PORT_TRIES - 1);
	Tcl_AppendResult(fbsp->fbs_interp, bu_vls_addr(&vls), (char *)NULL);
	bu_vls_free(&vls);

	fbsp->fbs_listener.fbsl_port = -1;

	return TCL_ERROR;
    }

    fbsp->fbs_listener.fbsl_port = port;
    Tcl_GetChannelHandle(fbsp->fbs_listener.fbsl_chan, TCL_READABLE, &fbsp->fbs_listener.fbsl_fd);

    return TCL_OK;
}

/*
 *			N E W _ C L I E N T
 */
HIDDEN void
new_client(struct fbserv_obj *fbsp, struct pkg_conn *pcp, Tcl_Channel chan)
{
    register int	i;

    if (pcp == PKC_ERROR)
	return;

    for (i = MAX_CLIENTS-1; i >= 0; i--) {
	/* this slot is being used */
	if (fbsp->fbs_clients[i].fbsc_fd != 0)
	    continue;

	/* Found an available slot */
	fbsp->fbs_clients[i].fbsc_fd = pcp->pkc_fd;
	fbsp->fbs_clients[i].fbsc_pkg = pcp;
	fbsp->fbs_clients[i].fbsc_fbsp = fbsp;
	setup_socket(pcp->pkc_fd);

	fbsp->fbs_clients[i].fbsc_chan = chan;
	fbsp->fbs_clients[i].fbsc_handler = existing_client_handler;
	Tcl_CreateChannelHandler(fbsp->fbs_clients[i].fbsc_chan, TCL_READABLE,
				 fbsp->fbs_clients[i].fbsc_handler,
				 (ClientData)&fbsp->fbs_clients[i]);

	return;
    }

    bu_log("new_client: too many clients\n");
    pkg_close(pcp);
}


static struct pkg_conn *
fbserv_makeconn(int fd,
		const struct pkg_switch *switchp)
{
    register struct pkg_conn *pc;

    if ((pc = (struct pkg_conn *)malloc(sizeof(struct pkg_conn))) == PKC_NULL) {
	comm_error("fbserv_makeconn: malloc failure\n");
	return(PKC_ERROR);
    }

    memset((char *)pc, 0, sizeof(struct pkg_conn));
    pc->pkc_magic = PKG_MAGIC;
    pc->pkc_fd = fd;
    pc->pkc_switch = switchp;
    pc->pkc_errlog = 0;
    pc->pkc_left = -1;
    pc->pkc_buf = (char *)0;
    pc->pkc_curpos = (char *)0;
    pc->pkc_strpos = 0;
    pc->pkc_incur = pc->pkc_inend = 0;

    return pc;
}

HIDDEN void
new_client_handler(ClientData	 clientData,
		   Tcl_Channel	 chan,
		   char		 *host,
		   int		 port)
{
    struct fbserv_listener *fbslp = (struct fbserv_listener *)clientData;
    struct fbserv_obj *fbsp = fbslp->fbsl_fbsp;
    int fd;

    if (Tcl_GetChannelHandle(chan, TCL_READABLE, &fd) == TCL_OK)
	new_client(fbsp, fbserv_makeconn(fd, pkg_switch), chan);
}

#else /* if defined(_WIN32) && !defined(__CYGWIN__) */

int
fbs_open(struct fbserv_obj *fbsp, int port)
{
  struct bu_vls vls;
  char portname[32];
  register int i;

  /* Already listening; nothing more to do. */
  if (fbsp->fbs_listener.fbsl_fd >= 0) {
    return TCL_OK;
  }

  fbsp->fbs_listener.fbsl_port = port;

  /* Try a reasonable number of times to hang a listen */
  for (i = 0; i < MAX_PORT_TRIES; ++i) {
    if (fbsp->fbs_listener.fbsl_port < 1024)
      sprintf(portname,"%d", fbsp->fbs_listener.fbsl_port + 5559);
    else
      sprintf(portname,"%d", fbsp->fbs_listener.fbsl_port);

    /*
     * Hang an unending listen for PKG connections
     */
    if ((fbsp->fbs_listener.fbsl_fd = pkg_permserver(portname, 0, 0, comm_error)) < 0)
      ++fbsp->fbs_listener.fbsl_port;
    else
      break;
  }

  if (fbsp->fbs_listener.fbsl_fd < 0) {
    bu_vls_init(&vls);
    bu_vls_printf(&vls, "fbs_open: failed to hang a listen on ports %d - %d\n",
	   fbsp->fbs_listener.fbsl_port, fbsp->fbs_listener.fbsl_port + MAX_PORT_TRIES - 1);
    Tcl_AppendResult(fbsp->fbs_interp, bu_vls_addr(&vls), (char *)NULL);
    bu_vls_free(&vls);

    fbsp->fbs_listener.fbsl_port = -1;

    return TCL_ERROR;
  }

  Tcl_CreateFileHandler(fbsp->fbs_listener.fbsl_fd, TCL_READABLE,
			new_client_handler, (ClientData)&fbsp->fbs_listener);

  return TCL_OK;
}

/*
 *			N E W _ C L I E N T
 */
HIDDEN void
new_client(struct fbserv_obj *fbsp, struct pkg_conn *pcp)
{
    register int	i;

    if (pcp == PKC_ERROR)
	return;

    for (i = MAX_CLIENTS-1; i >= 0; i--) {
	/* this slot is being used */
	if (fbsp->fbs_clients[i].fbsc_fd != 0)
	    continue;

	/* Found an available slot */
	fbsp->fbs_clients[i].fbsc_fd = pcp->pkc_fd;
	fbsp->fbs_clients[i].fbsc_pkg = pcp;
	fbsp->fbs_clients[i].fbsc_fbsp = fbsp;
	setup_socket(pcp->pkc_fd);

	Tcl_CreateFileHandler(fbsp->fbs_clients[i].fbsc_fd, TCL_READABLE,
			      existing_client_handler, (ClientData)&fbsp->fbs_clients[i]);

	return;
    }

    bu_log("new_client: too many clients\n");
    pkg_close(pcp);
}


/*
 * Accept any new client connections.
 */
HIDDEN void
new_client_handler(ClientData clientData, int mask)
{
    struct fbserv_listener *fbslp = (struct fbserv_listener *)clientData;
    struct fbserv_obj *fbsp = fbslp->fbsl_fbsp;
    int fd = fbslp->fbsl_fd;

    new_client(fbsp, pkg_getclient(fd, pkg_switch, comm_error, 0));
}
#endif  /* if defined(_WIN32) && !defined(__CYGWIN__) */


int
fbs_close(struct fbserv_obj *fbsp)
{
    register int i;

    /* first drop all clients */
    for(i = 0; i < MAX_CLIENTS; ++i)
	drop_client(fbsp, i);

#if defined(_WIN32) && !defined(__CYGWIN__)
    if (fbsp->fbs_listener.fbsl_chan != NULL) {
	Tcl_DeleteChannelHandler(fbsp->fbs_listener.fbsl_chan,
				 new_client_handler,
				 fbsp->fbs_listener.fbsl_fd);

	Tcl_Close(fbsp->fbs_interp, fbsp->fbs_listener.fbsl_chan);
	fbsp->fbs_listener.fbsl_chan = NULL;
    }
#else
    Tcl_DeleteFileHandler(fbsp->fbs_listener.fbsl_fd);
#endif

    if (0 <= fbsp->fbs_listener.fbsl_fd)
	close(fbsp->fbs_listener.fbsl_fd);
    fbsp->fbs_listener.fbsl_fd = -1;
    fbsp->fbs_listener.fbsl_port = -1;

    return TCL_OK;
}


/*
 *			D R O P _ C L I E N T
 */
HIDDEN void
drop_client(struct fbserv_obj *fbsp, int sub)
{
    if(fbsp->fbs_clients[sub].fbsc_pkg != PKC_NULL)  {
	pkg_close(fbsp->fbs_clients[sub].fbsc_pkg);
	fbsp->fbs_clients[sub].fbsc_pkg = PKC_NULL;
    }

    if(fbsp->fbs_clients[sub].fbsc_fd != 0)  {
#if defined(_WIN32) && !defined(__CYGWIN__)
	Tcl_DeleteChannelHandler(fbsp->fbs_clients[sub].fbsc_chan,
				 fbsp->fbs_clients[sub].fbsc_handler,
				 fbsp->fbs_clients[sub].fbsc_fd);

	Tcl_Close(fbsp->fbs_interp, fbsp->fbs_clients[sub].fbsc_chan);
	fbsp->fbs_clients[sub].fbsc_chan = NULL;
#else
	Tcl_DeleteFileHandler(fbsp->fbs_clients[sub].fbsc_fd);
#endif

#if 0
	/* This has already been closed in call to pkg_close above */
	close(fbsp->fbs_clients[sub].fbsc_fd);
#endif
	fbsp->fbs_clients[sub].fbsc_fd = 0;
    }
}


/*
 * Process arrivals from existing clients.
 */
HIDDEN void
existing_client_handler(ClientData clientData, int mask)
{
  register int i;
  struct fbserv_client *fbscp = (struct fbserv_client *)clientData;
  struct fbserv_obj *fbsp = fbscp->fbsc_fbsp;
  int fd = fbscp->fbsc_fd;

  curr_fbp = fbsp->fbs_fbp;

  for (i = MAX_CLIENTS-1; i >= 0; i--) {
    if (fbsp->fbs_clients[i].fbsc_fd == 0)
      continue;

    if ((pkg_process(fbsp->fbs_clients[i].fbsc_pkg)) < 0)
      bu_log("pkg_process error encountered (1)\n");

    if (fbsp->fbs_clients[i].fbsc_fd != fd)
      continue;

    if (pkg_suckin(fbsp->fbs_clients[i].fbsc_pkg) <= 0) {
      /* Probably EOF */
      drop_client(fbsp, i);

      continue;
    }

    if ((pkg_process(fbsp->fbs_clients[i].fbsc_pkg)) < 0)
      bu_log("pkg_process error encountered (2)\n");
  }

  if (fbsp->fbs_callback != FBS_CALLBACK_NULL)
    fbsp->fbs_callback(fbsp->fbs_clientData);
}

HIDDEN void
setup_socket(int fd)
{
  int on = 1;

#if defined(SO_KEEPALIVE)
  if(setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *)&on, sizeof(on)) < 0){
    bu_log("setsockopt (SO_KEEPALIVE): %m");
  }
#endif
#if defined(SO_RCVBUF)
  /* try to set our buffers up larger */
  {
    int	m = -1;
    int n = -1;
    int	val;
    int	size;

    for(size = 256; size > 16; size /= 2){
      val = size * 1024;
      m = setsockopt(fd, SOL_SOCKET, SO_RCVBUF,
		      (char *)&val, sizeof(val));
      val = size * 1024;
      n = setsockopt(fd, SOL_SOCKET, SO_SNDBUF,
		      (char *)&val, sizeof(val));
      if(m >= 0 && n >= 0)  break;
    }

    if(m < 0 || n < 0)
      bu_log("setup_socket: setsockopt()");
  }
#endif
}

/*
 *			C O M M _ E R R O R
 *
 *  Communication error.  An error occured on the PKG link.
 */
HIDDEN void
comm_error(char *str)
{
  bu_log(str);
}

/*
 * This is where we go for message types we don't understand.
 */
void
fbs_pkgfoo(struct pkg_conn *pcp, char *buf)
{
  bu_log("fbserv: unable to handle message type %d\n", pcp->pkc_type);
  (void)free(buf);
}

/******** Here's where the hooks lead *********/

void
fbs_rfbopen(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[5*NET_LONG_LEN+1];
  int	want;

  /* Don't really open a new framebuffer --- use existing one */
  (void)pkg_plong(&rbuf[0*NET_LONG_LEN], 0);	/* ret */
  (void)pkg_plong(&rbuf[1*NET_LONG_LEN], curr_fbp->if_max_width);
  (void)pkg_plong(&rbuf[2*NET_LONG_LEN], curr_fbp->if_max_height);
  (void)pkg_plong(&rbuf[3*NET_LONG_LEN], curr_fbp->if_width);
  (void)pkg_plong(&rbuf[4*NET_LONG_LEN], curr_fbp->if_height);

  want = 5*NET_LONG_LEN;
  if( pkg_send( MSG_RETURN, rbuf, want, pcp ) != want )
    comm_error("pkg_send fb_open reply\n");

  if(buf)
    (void)free(buf);
}

void
fbs_rfbclose(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[NET_LONG_LEN+1];

  /*
   * We are playing FB server so we don't really close the
   * frame buffer.  We should flush output however.
   */
  (void)fb_flush(curr_fbp);
  (void)pkg_plong(&rbuf[0], 0);		/* return success */

  /* Don't check for errors, SGI linger mode or other events
   * may have already closed down all the file descriptors.
   * If communication has broken, other end will know we are gone.
   */
  (void)pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp);

  if(buf)
    (void)free(buf);
}

void
fbs_rfbfree(struct pkg_conn *pcp, char *buf)
{
  char	rbuf[NET_LONG_LEN+1];

  /* Don't really free framebuffer */
  if(pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp) != NET_LONG_LEN)
    comm_error("pkg_send fb_free reply\n");

  if(buf)
    (void)free(buf);
}

void
fbs_rfbclear(struct pkg_conn *pcp, char *buf)
{
  RGBpixel bg;
  char	rbuf[NET_LONG_LEN+1];

  bg[RED] = buf[0];
  bg[GRN] = buf[1];
  bg[BLU] = buf[2];

  (void)pkg_plong(rbuf, fb_clear(curr_fbp, bg));
  pkg_send(MSG_RETURN, rbuf, NET_LONG_LEN, pcp);

  if(buf)
    (void)free(buf);
}

void
fbs_rfbread(struct pkg_conn *pcp, char *buf)
{
	int	x, y, num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	num = pkg_glong( &buf[2*NET_LONG_LEN] );

	if( num*sizeof(RGBpixel) > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num*sizeof(RGBpixel);
		if( buflen < 1024*sizeof(RGBpixel) )
			buflen = 1024*sizeof(RGBpixel);
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fb_read: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_read( curr_fbp, x, y, scanbuf, num );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, (char *)scanbuf, ret*sizeof(RGBpixel), pcp );
	if( buf ) (void)free(buf);
}

void
fbs_rfbwrite(struct pkg_conn *pcp, char *buf)
{
	int	x, y, num;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	num = pkg_glong( &buf[2*NET_LONG_LEN] );
	type = pcp->pkc_type;
	ret = fb_write( curr_fbp, x, y, (unsigned char *)&buf[3*NET_LONG_LEN], num );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*
 *			R F B R E A D R E C T
 */
void
fbs_rfbreadrect(struct pkg_conn *pcp, char *buf)
{
	int	xmin, ymin;
	int	width, height;
	int	num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	xmin = pkg_glong( &buf[0*NET_LONG_LEN] );
	ymin = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );
	num = width * height;

	if( num*sizeof(RGBpixel) > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num*sizeof(RGBpixel);
		if( buflen < 1024*sizeof(RGBpixel) )
			buflen = 1024*sizeof(RGBpixel);
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fb_read: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_readrect( curr_fbp, xmin, ymin, width, height, scanbuf );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, (char *)scanbuf, ret*sizeof(RGBpixel), pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B W R I T E R E C T
 */
void
fbs_rfbwriterect(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	int	width, height;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );

	type = pcp->pkc_type;
	ret = fb_writerect( curr_fbp, x, y, width, height,
		(unsigned char *)&buf[4*NET_LONG_LEN] );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*
 *			R F B B W R E A D R E C T
 */
void
fbs_rfbbwreadrect(struct pkg_conn *pcp, char *buf)
{
	int	xmin, ymin;
	int	width, height;
	int	num;
	int	ret;
	static unsigned char	*scanbuf = NULL;
	static int	buflen = 0;

	xmin = pkg_glong( &buf[0*NET_LONG_LEN] );
	ymin = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );
	num = width * height;

	if( num > buflen ) {
		if( scanbuf != NULL )
			free( (char *)scanbuf );
		buflen = num;
		if( buflen < 1024 )
			buflen = 1024;
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
			fb_log("fbs_rfbbwreadrect: malloc failed!");
			if( buf ) (void)free(buf);
			buflen = 0;
			return;
		}
	}

	ret = fb_bwreadrect( curr_fbp, xmin, ymin, width, height, scanbuf );
	if( ret < 0 )  ret = 0;		/* map error indications */
	/* sending a 0-length package indicates error */
	pkg_send( MSG_RETURN, (char *)scanbuf, ret, pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B B W W R I T E R E C T
 */
void
fbs_rfbbwwriterect(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	int	width, height;
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	type;

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );
	width = pkg_glong( &buf[2*NET_LONG_LEN] );
	height = pkg_glong( &buf[3*NET_LONG_LEN] );

	type = pcp->pkc_type;
	ret = fb_writerect( curr_fbp, x, y, width, height,
		(unsigned char *)&buf[4*NET_LONG_LEN] );

	if( type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

void
fbs_rfbcursor(struct pkg_conn *pcp, char *buf)
{
	int	mode, x, y;
	char	rbuf[NET_LONG_LEN+1];

	mode = pkg_glong( &buf[0*NET_LONG_LEN] );
	x = pkg_glong( &buf[1*NET_LONG_LEN] );
	y = pkg_glong( &buf[2*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_cursor( curr_fbp, mode, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
fbs_rfbgetcursor(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	mode, x, y;
	char	rbuf[4*NET_LONG_LEN+1];

	ret = fb_getcursor( curr_fbp, &mode, &x, &y );
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], mode );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], x );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], y );
	pkg_send( MSG_RETURN, rbuf, 4*NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
fbs_rfbsetcursor(struct pkg_conn *pcp, char *buf)
{
	char	rbuf[NET_LONG_LEN+1];
	int	ret;
	int	xbits, ybits;
	int	xorig, yorig;

	xbits = pkg_glong( &buf[0*NET_LONG_LEN] );
	ybits = pkg_glong( &buf[1*NET_LONG_LEN] );
	xorig = pkg_glong( &buf[2*NET_LONG_LEN] );
	yorig = pkg_glong( &buf[3*NET_LONG_LEN] );

	ret = fb_setcursor( curr_fbp, (unsigned char *)&buf[4*NET_LONG_LEN],
		xbits, ybits, xorig, yorig );

	if( pcp->pkc_type < MSG_NORETURN ) {
		(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

/*OLD*/
void
fbs_rfbscursor(struct pkg_conn *pcp, char *buf)
{
	int	mode, x, y;
	char	rbuf[NET_LONG_LEN+1];

	mode = pkg_glong( &buf[0*NET_LONG_LEN] );
	x = pkg_glong( &buf[1*NET_LONG_LEN] );
	y = pkg_glong( &buf[2*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_scursor( curr_fbp, mode, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*OLD*/
void
fbs_rfbwindow(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	char	rbuf[NET_LONG_LEN+1];

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_window( curr_fbp, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*OLD*/
void
fbs_rfbzoom(struct pkg_conn *pcp, char *buf)
{
	int	x, y;
	char	rbuf[NET_LONG_LEN+1];

	x = pkg_glong( &buf[0*NET_LONG_LEN] );
	y = pkg_glong( &buf[1*NET_LONG_LEN] );

	(void)pkg_plong( &rbuf[0], fb_zoom( curr_fbp, x, y ) );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
fbs_rfbview(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	xcenter, ycenter, xzoom, yzoom;
	char	rbuf[NET_LONG_LEN+1];

	xcenter = pkg_glong( &buf[0*NET_LONG_LEN] );
	ycenter = pkg_glong( &buf[1*NET_LONG_LEN] );
	xzoom = pkg_glong( &buf[2*NET_LONG_LEN] );
	yzoom = pkg_glong( &buf[3*NET_LONG_LEN] );

	ret = fb_view( curr_fbp, xcenter, ycenter, xzoom, yzoom );
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
fbs_rfbgetview(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	int	xcenter, ycenter, xzoom, yzoom;
	char	rbuf[5*NET_LONG_LEN+1];

	ret = fb_getview( curr_fbp, &xcenter, &ycenter, &xzoom, &yzoom );
	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], ret );
	(void)pkg_plong( &rbuf[1*NET_LONG_LEN], xcenter );
	(void)pkg_plong( &rbuf[2*NET_LONG_LEN], ycenter );
	(void)pkg_plong( &rbuf[3*NET_LONG_LEN], xzoom );
	(void)pkg_plong( &rbuf[4*NET_LONG_LEN], yzoom );
	pkg_send( MSG_RETURN, rbuf, 5*NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
fbs_rfbrmap(struct pkg_conn *pcp, char *buf)
{
	register int	i;
	char	rbuf[NET_LONG_LEN+1];
	ColorMap map;
	unsigned char	cm[256*2*3];

	(void)pkg_plong( &rbuf[0*NET_LONG_LEN], fb_rmap( curr_fbp, &map ) );
	for( i = 0; i < 256; i++ ) {
		(void)pkg_pshort( (char *)(cm+2*(0+i)), map.cm_red[i] );
		(void)pkg_pshort( (char *)(cm+2*(256+i)), map.cm_green[i] );
		(void)pkg_pshort( (char *)(cm+2*(512+i)), map.cm_blue[i] );
	}
	pkg_send( MSG_DATA, (char *)cm, sizeof(cm), pcp );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*
 *			R F B W M A P
 *
 *  Accept a color map sent by the client, and write it to the framebuffer.
 *  Network format is to send each entry as a network (IBM) order 2-byte
 *  short, 256 red shorts, followed by 256 green and 256 blue, for a total
 *  of 3*256*2 bytes.
 */
void
fbs_rfbwmap(struct pkg_conn *pcp, char *buf)
{
	int	i;
	char	rbuf[NET_LONG_LEN+1];
	long	ret;
	ColorMap map;

	if( pcp->pkc_len == 0 )
		ret = fb_wmap( curr_fbp, COLORMAP_NULL );
	else {
		for( i = 0; i < 256; i++ ) {
			map.cm_red[i] = pkg_gshort( buf+2*(0+i) );
			map.cm_green[i] = pkg_gshort( buf+2*(256+i) );
			map.cm_blue[i] = pkg_gshort( buf+2*(512+i) );
		}
		ret = fb_wmap( curr_fbp, &map );
	}
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

void
fbs_rfbflush(struct pkg_conn *pcp, char *buf)
{
	int	ret;
	char	rbuf[NET_LONG_LEN+1];

	ret = fb_flush( curr_fbp );

	if( pcp->pkc_type < MSG_NORETURN ) {
		(void)pkg_plong( rbuf, ret );
		pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	}
	if( buf ) (void)free(buf);
}

void
fbs_rfbpoll(struct pkg_conn *pcp, char *buf)
{
	(void)fb_poll( curr_fbp );
	if( buf ) (void)free(buf);
}

/*
 *  At one time at least we couldn't send a zero length PKG
 *  message back and forth, so we receive a dummy long here.
 */
void
fbs_rfbhelp(struct pkg_conn *pcp, char *buf)
{
	long	ret;
	char	rbuf[NET_LONG_LEN+1];

	(void)pkg_glong( &buf[0*NET_LONG_LEN] );

	ret = fb_help(curr_fbp);
	(void)pkg_plong( &rbuf[0], ret );
	pkg_send( MSG_RETURN, rbuf, NET_LONG_LEN, pcp );
	if( buf ) (void)free(buf);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.22
log
@Check fbsl_fd before closing.
@
text
@d253 1
a253 1
    bzero((char *)pc, sizeof(struct pkg_conn));
@


14.21
log
@use the feature-specific HAVE_WINSOCK_H header define instead of platform-specific defines
@
text
@d401 2
a402 1
    close(fbsp->fbs_listener.fbsl_fd);
d432 3
d436 1
@


14.20
log
@Mods to get the fbserv capability working on Windows. This required using Tcl_OpenTcpServer instead of pkg_permserver which beget other mods.
@
text
@d48 1
a48 1
#if defined(_WIN32) && !defined(__CYGWIN__)
@


14.19
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d48 9
a56 2
#include <sys/socket.h>
#include <netinet/in.h>		/* For htonl(), etc */
d66 1
d68 5
a72 3
int fbs_open(Tcl_Interp *interp, struct fbserv_obj *fbsp, int port);
int fbs_close(Tcl_Interp *interp, struct fbserv_obj *fbsp);

a73 1
HIDDEN void drop_client(struct fbserv_obj *fbsp, int sub);
d75 1
d145 138
d284 1
a284 1
fbs_open(Tcl_Interp *interp, struct fbserv_obj *fbsp, int port)
d317 1
a317 1
    Tcl_AppendResult(interp, bu_vls_addr(&vls), (char *)NULL);
d331 5
a335 2
int
fbs_close(Tcl_Interp *interp, struct fbserv_obj *fbsp)
d337 18
a354 1
  register int i;
d356 2
a357 8
  /* first drop all clients */
  for(i = 0; i < MAX_CLIENTS; ++i)
    drop_client(fbsp, i);

  Tcl_DeleteFileHandler(fbsp->fbs_listener.fbsl_fd);
  close(fbsp->fbs_listener.fbsl_fd);
  fbsp->fbs_listener.fbsl_fd = -1;
  fbsp->fbs_listener.fbsl_port = -1;
d359 2
a360 1
  return TCL_OK;
d363 1
d365 1
a365 1
 *			N E W _ C L I E N T
d368 1
a368 1
new_client(struct fbserv_obj *fbsp, struct pkg_conn *pcp)
d370 3
a372 1
  register int	i;
d374 3
a376 2
  if (pcp == PKC_ERROR)
    return;
a377 4
  for (i = MAX_CLIENTS-1; i >= 0; i--) {
    /* this slot is being used */
    if (fbsp->fbs_clients[i].fbsc_fd != 0)
      continue;
d379 14
a392 5
    /* Found an available slot */
    fbsp->fbs_clients[i].fbsc_fd = pcp->pkc_fd;
    fbsp->fbs_clients[i].fbsc_pkg = pcp;
    fbsp->fbs_clients[i].fbsc_fbsp = fbsp;
    setup_socket(pcp->pkc_fd);
d394 6
a399 2
    Tcl_CreateFileHandler(fbsp->fbs_clients[i].fbsc_fd, TCL_READABLE,
			  existing_client_handler, (ClientData)&fbsp->fbs_clients[i]);
d401 3
a403 2
    return;
  }
d405 1
a405 2
  bu_log("new_client: too many clients\n");
  pkg_close(pcp);
d408 1
d415 4
a418 4
  if(fbsp->fbs_clients[sub].fbsc_pkg != PKC_NULL)  {
    pkg_close(fbsp->fbs_clients[sub].fbsc_pkg);
    fbsp->fbs_clients[sub].fbsc_pkg = PKC_NULL;
  }
d420 14
a433 5
  if(fbsp->fbs_clients[sub].fbsc_fd != 0)  {
    Tcl_DeleteFileHandler(fbsp->fbs_clients[sub].fbsc_fd);
    close(fbsp->fbs_clients[sub].fbsc_fd);
    fbsp->fbs_clients[sub].fbsc_fd = 0;
  }
a435 12
/*
 * Accept any new client connections.
 */
HIDDEN void
new_client_handler(ClientData clientData, int mask)
{
  struct fbserv_listener *fbslp = (struct fbserv_listener *)clientData;
  struct fbserv_obj *fbsp = fbslp->fbsl_fbsp;
  int fd = fbslp->fbsl_fd;

  new_client(fbsp, pkg_getclient(fd, pkg_switch, comm_error, 0));
}
@


14.18
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
@


14.17
log
@update copyright to 2007
@
text
@d21 2
a22 2
/** \addtogroup fb */
/*@@{*/
d24 1
d42 1
a42 1
/*@@}*/
@


14.16
log
@quell libpkg warnings now that there are more comprehensive declarations.
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
@


14.15
log
@get rid of the libfb-specific _LOCAL_ macro, instead using HIDDEN like everyone else (currently still provided by machine.h)
@
text
@d460 1
a460 1
	pkg_send( MSG_RETURN, scanbuf, ret*sizeof(RGBpixel), pcp );
d521 1
a521 1
	pkg_send( MSG_RETURN, scanbuf, ret*sizeof(RGBpixel), pcp );
d589 1
a589 1
	pkg_send( MSG_RETURN, scanbuf, ret, pcp );
d766 3
a768 3
		(void)pkg_pshort( cm+2*(0+i), map.cm_red[i] );
		(void)pkg_pshort( cm+2*(256+i), map.cm_green[i] );
		(void)pkg_pshort( cm+2*(512+i), map.cm_blue[i] );
d770 1
a770 1
	pkg_send( MSG_DATA, cm, sizeof(cm), pcp );
@


14.14
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d63 6
a68 6
static void new_client(struct fbserv_obj *fbsp, struct pkg_conn *pcp);
static void drop_client(struct fbserv_obj *fbsp, int sub);
static void new_client_handler(ClientData clientData, int mask);
static void existing_client_handler(ClientData clientData, int mask);
static void comm_error(char *str);
static void setup_socket(int fd);
d203 1
a203 1
static void
d235 1
a235 1
static void
d253 1
a253 1
static void
d266 1
a266 1
static void
d301 1
a301 1
static void
d340 1
a340 1
static void
@


14.13
log
@revert the libbu memory management changes to libpkg just to be safe.  if someone happens to call bu_semaphore_acquire on a BU_SEM_SYSCALL semaphore, the call will block since libbu utilizes that semaphore internally (and it's expected that callers know this..).
@
text
@d73 21
a93 10
void	fbs_pkgfoo(struct pkg_conn *pcp, char *buf);	/* foobar message handler */
void	fbs_rfbopen(struct pkg_conn *pcp, char *buf), fbs_rfbclose(struct pkg_conn *pcp, char *buf), fbs_rfbclear(struct pkg_conn *pcp, char *buf), fbs_rfbread(struct pkg_conn *pcp, char *buf), fbs_rfbwrite(struct pkg_conn *pcp, char *buf);
void	fbs_rfbcursor(struct pkg_conn *pcp, char *buf), fbs_rfbgetcursor(struct pkg_conn *pcp, char *buf);
void	fbs_rfbrmap(struct pkg_conn *pcp, char *buf), fbs_rfbwmap(struct pkg_conn *pcp, char *buf);
void	fbs_rfbhelp(struct pkg_conn *pcp, char *buf);
void	fbs_rfbreadrect(struct pkg_conn *pcp, char *buf), fbs_rfbwriterect(struct pkg_conn *pcp, char *buf);
void	fbs_rfbbwreadrect(struct pkg_conn *pcp, char *buf), fbs_rfbbwwriterect(struct pkg_conn *pcp, char *buf);
void	fbs_rfbpoll(struct pkg_conn *pcp, char *buf), fbs_rfbflush(struct pkg_conn *pcp, char *buf), fbs_rfbfree(struct pkg_conn *pcp, char *buf);
void	fbs_rfbview(struct pkg_conn *pcp, char *buf), fbs_rfbgetview(struct pkg_conn *pcp, char *buf);
void	fbs_rfbsetcursor(struct pkg_conn *pcp, char *buf);
d95 3
a97 1
void	fbs_rfbscursor(struct pkg_conn *pcp, char *buf), fbs_rfbwindow(struct pkg_conn *pcp, char *buf), fbs_rfbzoom(struct pkg_conn *pcp, char *buf);
@


14.12
log
@quell intel on altix compiler warnings
@
text
@d432 1
a432 1
			bu_free( (char *)scanbuf, "scanbuf" );
d436 1
a436 1
		if( (scanbuf = (unsigned char *)bu_malloc( buflen, "scanbuf" )) == NULL ) {
d493 1
a493 1
			bu_free( (char *)scanbuf, "scanbuf" );
d497 1
a497 1
		if( (scanbuf = (unsigned char *)bu_malloc( buflen, "scanbuf" )) == NULL ) {
d561 1
a561 1
			bu_free( (char *)scanbuf, "scanbuf" );
d565 1
a565 1
		if( (scanbuf = (unsigned char *)bu_malloc( buflen, "scanbuf" )) == NULL ) {
@


14.11
log
@use bu_malloc and bu_free instead of malloc
@
text
@d44 1
@


14.11.2.1
log
@update from HEAD
@
text
@a43 1
#include <stdlib.h>
d431 1
a431 1
			free( (char *)scanbuf );
d435 1
a435 1
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
d492 1
a492 1
			free( (char *)scanbuf );
d496 1
a496 1
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
d560 1
a560 1
			free( (char *)scanbuf );
d564 1
a564 1
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
@


14.10
log
@change from HIDDEN to static, ws, use fbmsg.h
@
text
@d431 1
a431 1
			free( (char *)scanbuf );
d435 1
a435 1
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
d492 1
a492 1
			free( (char *)scanbuf );
d496 1
a496 1
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
d560 1
a560 1
			free( (char *)scanbuf );
d564 1
a564 1
		if( (scanbuf = (unsigned char *)malloc( buflen )) == NULL ) {
@


14.9
log
@pkgtypes.h is in current dir, no need to couple to the directory name
@
text
@a20 1

a41 1

a43 2


d57 1
a57 1
#include "./pkgtypes.h"
d62 6
a67 6
HIDDEN void new_client(struct fbserv_obj *fbsp, struct pkg_conn *pcp);
HIDDEN void drop_client(struct fbserv_obj *fbsp, int sub);
HIDDEN void new_client_handler(ClientData clientData, int mask);
HIDDEN void existing_client_handler(ClientData clientData, int mask);
HIDDEN void comm_error(char *str);
HIDDEN void setup_socket(int fd);
d119 1
a119 1
HIDDEN FBIO *curr_fbp;		/* current framebuffer pointer */
d189 1
a189 1
HIDDEN void
d221 1
a221 1
HIDDEN void
d239 1
a239 1
HIDDEN void
d252 1
a252 1
HIDDEN void
d287 1
a287 1
HIDDEN void
d326 1
a326 1
HIDDEN void
@


14.8
log
@update copyright to 2006
@
text
@d60 2
a61 1
#include "../libfb/pkgtypes.h"
@


14.7
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
@


14.6
log
@Doxygen changes
@
text
@d28 1
a28 1
 * 
d372 1
a372 1
	
d394 1
a394 1
	
@


14.6.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d28 1
a28 1
 *
d372 1
a372 1

d394 1
a394 1

@


14.5
log
@update copyright to 2005
@
text
@d21 3
a24 1
 *
d42 1
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *				F B S E R V _ O B J . C
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d812 10
@


1.2
log
@obliterate externs.h
@
text
@d22 1
a22 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a35 1
#include "externs.h"		/* For malloc, getopt */
@

