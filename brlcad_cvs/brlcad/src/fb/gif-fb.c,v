head	14.22;
access;
symbols
	rel-7-10-4:14.14
	STABLE:14.14.0.2
	stable-branch:14.3
	rel-7-10-2:14.14
	rel-7-10-0:14.12
	rel-7-8-4:14.9
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.3
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.3
	rel-7-6-branch:14.3.0.6
	rel-7-6-0:14.3
	rel-7-4-2:14.3
	rel-7-4-branch:14.3.0.4
	bobWinPort:14.3.0.2
	rel-7-4-0:14.3
	rel-7-2-6:14.3
	rel-7-2-4:14.3
	rel-7-2-2:14.3
	rel-7-2-0:14.3
	rel-7-0-4:14.2
	rel-7-0-2:14.2
	rel-7-0-1:14.2
	opensource-post:14.2
	opensource-pre:1.6
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.22
date	2007.12.20.20.31.42;	author bob1961;	state Exp;
branches;
next	14.21;

14.21
date	2007.12.16.18.53.48;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.12.06.14.44.25;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.12.03.22.57.58;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.12.01.21.47.12;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.11.21.20.49.07;	author erikgreenwald;	state Exp;
branches;
next	14.16;

14.16
date	2007.11.21.19.09.24;	author erikgreenwald;	state Exp;
branches;
next	14.15;

14.15
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.04.18.02.54.01;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.04.14.01.16.02;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.27.01.41.34;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.31;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.36.48;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.11.11.21.41.59;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.09.21.19.00.27;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.09.21.17.17.18;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.09.09.05.07.46;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2005.01.30.20.30.21;	author brlcad;	state Exp;
branches
	14.3.6.1;
next	14.2;

14.2
date	2004.12.18.06.09.12;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.08.20.31.24;	author kermit;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.17.56.22;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.12;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.03;	author morrison;	state Exp;
branches;
next	;

14.3.6.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.22
log
@Mods to get things compiling on windows.
@
text
@/*                        G I F - F B . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file gif-fb.c
	gif-fb -- convert a GIF file to (overlaid) frame buffer images

	created:	89/04/29	D A Gwyn

	Typical compilation:	cc -O -I/usr/brlcad/include -o gif-fb \
					gif-fb.c /usr/brlcad/lib/libfb.a
	Add -DNO_VFPRINTF, -DNO_MEMCPY, or -DNO_STRRCHR if vfprintf(),
	memcpy(), or strrchr() are not present in your C library
	(e.g. on 4BSD-based systems).

	This is a full implementation of the (noninteractive) GIF format
	conversion as specified in "A Standard Defining a Mechanism for
	the Storage and Transmission of Raster-Based Graphics Information",
	June 15, 1987 by CompuServe Incorporated.  This spec is far from
	ideal, but it is a standard that has had wide influence in the PC
	arena, and there are a lot of images available in GIF format.  Most
	small computer systems have GIF translators available for them, so
	this program provides a means of getting most PC images into the
	BRL-CAD domain.

	Options:

	-F fb_file	outputs to the specified frame buffer file instead
			of the one specified by the FB_FILE environment
			variable (the default frame buffer, if no FB_FILE)

	-c		overrides the GIF file's specified color resolution,
			using all 8 bits for each R, G, and B channel.

	-i image#	outputs just the specified image number (starting
			at 1) to the frame buffer, instead of all images

	-o		"overlay": skips the initial clearing of the frame
			buffer to the background color

	-v		"verbose": prints information about the images on
			the standard error output

	-z		zoom up the framebuffer, keeping image aspect square

	gif_file	GIF input file to be translated (standard input if
			no explicit GIF file name is specified)
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.21 2007/12/16 18:53:48 brlcad Exp $ (BRL)";
#endif

#include "common.h"

#include	<assert.h>
#include	<signal.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<string.h>
#include	<stdarg.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "bu.h"
#include "fb.h"


#define	USAGE	"gif-fb [-F fb_file] [-c] [-i image#] [-o] [-v] [-z] [gif_file]"
#define	OPTSTR	"F:ci:ovz"

typedef int	bool_t;

static bool_t	clear = 1;		/* set iff clear to background wanted */
static bool_t	ign_cr = 0;		/* set iff 8-bit color resoln. forced */
static bool_t	verbose = 0;	/* set for GIF-file info printout */
static bool_t	do_zoom = 0;	/* set to zoom framebuffer */
static int	image = 0;		/* # of image to display (0 => all) */
static char	*gif_file = NULL;	/* GIF file name */
static FILE	*gfp = NULL;		/* GIF input stream handle */
static char	*fb_file = NULL;	/* frame buffer name */
static FBIO	*fbp = FBIO_NULL;	/* frame buffer handle */
static int	ht;			/* virtual frame buffer height */
static int	width, height;		/* overall "screen" size */
static int	write_width;		/* used width of screen, <= width */
static int	left, top, right, bottom;	/* image boundary */
static bool_t	M_bit;			/* set iff color map provided */
static bool_t	I_bit;			/* set iff image interlaced */
static int	cr;			/* # bits of color resolution */
static int	cr_mask;		/* mask to strip all but high cr bits */
static int	g_pixel;		/* global # bits/pixel in image */
static int	pixel;			/* local # bits/pixel in image */
static int	background;		/* color index of screen background */
static int	entries;		/* # of global color map entries */
static RGBpixel	*g_cmap;		/* malloc()ed global color map */
static RGBpixel	*cmap;			/* malloc()ed local color map */
/* NOTE:  Relies on R,G,B order and also on RGBpixel being 3 unsigned chars. */

#define	GIF_EXTENSION	'!'
#define	GIF_IMAGE	','
#define	GIF_TERMINATOR	';'

/* in ioutil.c */
void Message( const char *format, ... );
void Fatal( FBIO *fbp, const char *format, ... );


static void
Sig_Catcher(int sig)
{
	(void)signal( sig, SIG_DFL );

	/* The following is not guaranteed to work, but it's worth a try. */
	Fatal(fbp, "Interrupted by signal %d", sig );
	}


static void
Skip(void)					/* skip over raster data */
	{
	register int	c;

	if ( (c = getc( gfp )) == EOF )
		Fatal(fbp, "Error reading code size" );

	while ( (c = getc( gfp )) != 0 )
		if ( c == EOF )
			Fatal(fbp, "Error reading block byte count" );
		else
			do
				if ( getc( gfp ) == EOF )
					Fatal(fbp, "Error reading data byte" );
			while ( --c > 0 );
	}


/*
	The raster output loop is inverted, because it is simpler to
	let the LZW decompression drive pixel writing than vice versa.
 */

static int	start_row[5] = { 0, 4, 2, 1, 0 };
static int	step[5] = { 8, 8, 4, 2, 1 };
static int	row, col;		/* current pixel coordinates */
static int	pass;			/* current pass */
static int	stop;			/* final pass + 1 */
static unsigned char	*pixbuf;		/* malloc()ed scan line buffer */


static void
PutPixel(register int value)
{
	if ( pass == stop )
		Fatal(fbp, "Too much raster data for image size" );

	if ( value > entries )
		Fatal(fbp, "Decoded color index %d exceeds color map size", value );

	pixbuf[col*3+RED] = cmap[value][RED];	/* stuff pixel */
	pixbuf[col*3+GRN] = cmap[value][GRN];
	pixbuf[col*3+BLU] = cmap[value][BLU];

	if ( ++col == right )
		{
		/*
		   Note that BRL-CAD frame buffers are upside-down.
		   The following produces a right-side-up image at
		   the bottom of the available frame buffer.
		 */

		if ( fb_write( fbp, 0, ht - row, pixbuf, write_width ) < 0
		   )
			Message( "Error writing scan line to frame buffer" );

		col = left;

		if ( (row += step[pass]) >= bottom
		  && ++pass < stop
		   )
			row = start_row[pass];
		}
	}


/*
	Limpel-Ziv-Welch decompression, based on "A Technique for
	High-Performance Data Compression" by Terry A. Welch in IEEE
	Computer, June 1984, pp. 8-19.

	GIF format usurps the first two "compression codes" for use
	as "reset" and "end of information".  The initial "code size"
	varies from 2 through (incremented) pixel, a maximum of 8.
	The LZW code data starts out 1 bit wider than the GIF "code
	size", and grows occasionally, up to 12 bits per code "chunk".
	LZW codes from 0 through (clear_code-1) are raw colormap
	index values, while those from clear_code on up are indices
	into the string-chaining table.

	This is my own implementation, using recursion instead of an
	explicit stack to expand the strings.
 */

static int	code_size;		/* initial LZW chunk size, in bits */
static int	chunk_size;		/* current LZW chunk size, in bits */
static int	chunk_mask;		/* bit mask for extracting chunks */
static int	compress_code;		/* first compression code value */
static int	k;			/* extension character */
static struct
	{
	short		pfx;		/* prefix string's table index */
	short		ext;		/* extension value */
	}	table[1 << 12];		/* big enough for 12-bit codes */
/* Unlike the example in Welch's paper, our table contains no atomic values. */

static int	bytecnt;		/* # of bytes remaining in block */
static int	rem_bits;		/* data bits left over from last call */
static int	bits_on_hand;		/* # of bits left over from last call */


static int
GetCode(void)
{
	register int	next_val;

	while ( bits_on_hand < chunk_size )
		{
		/* Read 8 more bits from the GIF file. */

		while ( bytecnt == 0 )
			{
			/* Start new data block. */

			if ( (bytecnt = getc( gfp )) == EOF )
				Fatal(fbp, "%s at start of new LZW data block",
				       feof( gfp ) ? "EOF" : "Error"
				     );

			if ( bytecnt == 0 )
				Message( "Warning: 0-byte data block" );
			/* Should this abort the image?  GIF spec is unclear. */
			}

		if ( (next_val = getc( gfp )) == EOF )
			Fatal(fbp, "%s while reading LZW data block",
			       feof( gfp ) ? "EOF" : "Error"
			     );

		--bytecnt;		/* used up another byte of input */
		rem_bits |= next_val << bits_on_hand;
		bits_on_hand += 8;
		}

	/* Now have enough bits to extract the next LZW code. */

	next_val = rem_bits & chunk_mask;

	/* Prepare for next entry. */

	rem_bits >>= chunk_size;
	bits_on_hand -= chunk_size;

	return next_val;
	}


#ifdef	USE_RECURSION

/* WARNING:  This recursion could get pretty deep (2047 nested calls)! */
static void
Expand( c )
	register int	c;		/* LZW code */
	{
	if ( c < compress_code )	/* "atomic", i.e. raw color index */
		PutPixel( k = c );	/* first atom in string */
	else	{			/* "molecular"; follow chain */
		Expand( table[c].pfx );
		PutPixel( table[c].ext );
		}
	}

#else	/* The non-recursive version is usually faster. */

static short	exp_buffer[(1 << 11) - 2];	/* reverse-order atomic codes */

/* Non-recursive version, for wimpy systems: */
static void
Expand(register int c)
					/* LZW code */
	{
	register short	*bp = exp_buffer;

	while ( c >= compress_code )	/* "molecular"; follow chain */
		{
		assert(bp < &exp_buffer[2046]);
		*bp++ = table[c].ext;
		c = table[c].pfx;
		}

	/* current `c' is "atomic", i.e. raw color index */

	PutPixel( k = c );		/* first atom in string */

	while ( bp > exp_buffer )
		PutPixel( (int)*--bp );
	}

#endif	/* USE_RECURSION */


static void
LZW(void)
{
	register int	c;		/* input LZW code, also input byte */
	register int	w;		/* prefix code */
	register int	next_code;	/* next available table index */
	register int	max_code;	/* limit at which LZW chunk must grow */
	int		eoi_code;	/* end of LZW stream */
	int		clear_code;	/* table reset code */

	if ( (code_size = getc( gfp )) == EOF )
		Fatal(fbp, "Error reading code size" );

	if ( code_size < pixel )
		Message( "Warning: initial code size smaller than colormap" );

	if ( code_size > pixel && !(pixel == 1 && code_size == 2) )
		Message( "Warning: initial code size greater than colormap" );
	/* This case will probably eventually trigger Fatal() in PutPixel(). */

	/* Initialize GetCode() parameters. */

	bytecnt = 0;			/* need a new data block */
	bits_on_hand = 0;		/* there was no "last call" */

	/* Initialize LZW algorithm parameters. */

	clear_code = 1 << code_size;
	eoi_code = clear_code + 1;
	compress_code = clear_code + 2;

	if ( (chunk_size = code_size + 1) > 12 )	/* LZW chunk size */
		Fatal(fbp, "GIF spec's LZW code size limit (12) violated" );

	max_code = 1 << chunk_size;	/* LZW chunk will grow at this point */
	chunk_mask = max_code - 1;
	next_code = compress_code;	/* empty chain-code table */
	w = -1;				/* we use -1 for "nil" */

	while ( (c = GetCode()) != eoi_code )
		if ( c == clear_code )
			{
			/* Reinitialize LZW parameters. */

			chunk_size = code_size + 1;
			max_code = 1 << chunk_size;	/* growth trigger */
			chunk_mask = max_code - 1;
			next_code = compress_code;	/* empty code table */
			w = -1;		/* we use -1 for "nil" */
			}
		else	{
			if ( c > next_code )
				Fatal(fbp, "LZW code impossibly large  (%x > %x, diff: %d)",
					c, next_code, c-next_code);

			if ( c == next_code )
				{	/* KwKwK special case */
				if ( w < 0 )	/* w supposedly previous code */
					Fatal(fbp, "initial LZW KwKwK code??" );

				Expand( w );	/* sets `k' */
				PutPixel( k );
				}
			else		/* normal case */
				Expand( c );	/* sets `k' */

			if ( w >= 0 && next_code < 1 << 12 )
				{
				table[next_code].pfx = w;
				table[next_code].ext = k;

				if ( ++next_code == max_code
				  && chunk_size < 12
				   )	{
					++chunk_size;
					max_code <<= 1;
					chunk_mask = max_code - 1;
					}
				}

			w = c;
			}

	/* EOI code encountered. */

	if ( bytecnt > 0 )
		{
		Message( "Warning: unused raster data present" );

		do
			if ( (c == getc( gfp )) == EOF )
				Fatal(fbp, "Error reading extra raster data" );
		while ( --bytecnt > 0 );
		}

	/* Strange data format in the GIF spec! */

	if ( (c = getc( gfp )) != 0 )
		Fatal(fbp, "Zero byte count missing" );
	}


static void
Rasters(void)				/* process (convert) raster data */
	{
	/* Initialize inverted-loop parameters. */

	pass = I_bit ? 0 : 4;		/* current pass */
	stop = I_bit ? 4 : 5;		/* final pass + 1 */

	row = top + start_row[pass];	/* next pixel row */
	col = left;			/* next pixel column */

	/* Process rasters in possibly interlaced order. */

	LZW();				/* uncompress LZW data & write pixels */
	}


int
main(int argc, char **argv)
{
	/* Plant signal catcher. */
	{
	static int	getsigs[] =	/* signals to catch */
		{
#ifdef SIGHUP
		SIGHUP,			/* hangup */
#endif
#ifdef SIGINT
		SIGINT,			/* interrupt */
#endif
#ifdef SIGQUIT
		SIGQUIT,		/* quit */
#endif
#ifdef SIGPIPE
		SIGPIPE,		/* write on a broken pipe */
#endif
#ifdef SIGTERM
		SIGTERM,		/* software termination signal */
#endif
		0
		};
	register int	i;

	for ( i = 0; getsigs[i] != 0; ++i )
		if ( signal( getsigs[i], SIG_IGN ) != SIG_IGN )
			(void)signal( getsigs[i], Sig_Catcher );
	}

	/* Process arguments. */

	{
		register int	c;
		register bool_t	errors = 0;

		while ( (c = bu_getopt( argc, argv, OPTSTR )) != EOF )
			switch( c )
				{
			default:	/* '?': invalid option */
				errors = 1;
				break;

			case 'F':	/* -F fb_file */
				fb_file = bu_optarg;
				break;

			case 'c':	/* -c */
				ign_cr = 1;
				break;

			case 'i':	/* -i image# */
				image = atoi( bu_optarg );
				break;

			case 'o':	/* -o */
				clear = 0;
				break;

			case 'v':	/* -v */
				verbose = 1;
				break;
			case 'z':
				do_zoom = 1;
				break;
				}

		if ( errors )
			Fatal(fbp, "Usage: %s", USAGE );
	}

	if ( bu_optind < argc )		/* gif_file */
		{
		if ( bu_optind < argc - 1 )
			{
			Message( "Usage: %s", USAGE );
			Fatal(fbp, "Can't handle multiple GIF files" );
			}

		if ( (gfp = fopen( gif_file = argv[bu_optind], "rb" )) == NULL )
			Fatal(fbp, "Couldn't open GIF file \"%s\"", gif_file );
		}
	else
		gfp = stdin;

	/* Process GIF signature. */

	{
		/* Scan until "GIF" seen, to skip over additional headers
		   (e.g., from Macintosh BBSes). */

		register int	state;	/* FSA state */
#define			ST_INITIAL	0	/* initial state of FSA */
#define			ST_G_SEEN	1	/* just after 'G' */
#define			ST_I_SEEN	2	/* just after 'I' */
#define			ST_F_SEEN	3	/* just after 'F' */

		for ( state = ST_INITIAL; state != ST_F_SEEN; )
			/* In theory, the signature should be mapped to ASCII
			   as it is read.  However, non-ASCII systems are
			   expected to have other problems anyway, so we don't
			   worry about that in this implementation. */

			switch ( getc( gfp ) )
				{
			case EOF:
				Fatal(fbp, "File does not contain \"GIF\" header" );

			case 'G':
				state = ST_G_SEEN;
				break;

			case 'I':
				if ( state != ST_G_SEEN )
					state = ST_INITIAL;
				else
					state = ST_I_SEEN;
				break;

			case 'F':
				if ( state != ST_I_SEEN )
					state = ST_INITIAL;
				else	{
					char	ver[3];
					/* GIF version (assume 8-bit bytes) */

					state = ST_F_SEEN;	/* ends loop */

					if ( fread( ver, 1, 3, gfp ) != 3 )
					    Fatal(fbp,
						   "Error reading GIF signature"
						     );

					if ( strncmp( ver, "87a", 3 ) != 0 )
						Message(
			     "GIF version \"%3.3s\" not known, \"87a\" assumed",
							 ver
						       );
					}
				break;
				}
	}

	/* Process screen descriptor. */

	{
		unsigned char	desc[7];	/* packed screen descriptor */

		if ( fread( desc, 1, 7, gfp ) != 7 )
			Fatal(fbp, "Error reading screen descriptor" );

		width = desc[1] << 8 | desc[0];
		height = desc[3] << 8 | desc[2];
		M_bit = (desc[4] & 0x80) != 0;
		cr = (desc[4] >> 4 & 0x07) + 1;
		g_pixel = (desc[4] & 0x07) + 1;
		background = desc[5];

		if ( verbose )
			{
			Message( "screen %dx%d", width, height );

			if ( M_bit )
				Message( "global color map provided" );

			Message( "%d bits of color resolution", cr );
			Message( "%d default bits per pixel", g_pixel );
			Message( "background color index %d", background );
			}

		if ( (desc[5] & 0x08) != 0x00 )
			Message( "Screen descriptor byte 6 bit 3 unknown" );

		if ( desc[6] != 0x00 )
			Message( "Screen descriptor byte 7 = %2.2x unknown",
				 desc[6]
			       );

		if ( ign_cr )
			cr = 8;		/* override value from GIF file */
	}

	/* Process global color map. */

	if ( (g_cmap = (RGBpixel *)malloc( 256 * sizeof(RGBpixel) )) == NULL
	  || (cmap = (RGBpixel *)malloc( 256 * sizeof(RGBpixel) )) == NULL
	   )
		Fatal(fbp, "Insufficient memory for color maps" );

	entries = 1 << g_pixel;

	if ( M_bit )
		{
		register int	i;
		register double	expand;	/* dynamic range expansion factor ~ 1 */

		/* Read in global color map. */

		if ( verbose )
			Message( "global color map has %d entries", entries );

		if ( fread( g_cmap, 3, entries, gfp ) != entries )
			Fatal(fbp, "Error reading global color map" );

		/* Mask off low-order "noise" bits found in some GIF files,
		   and expand dynamic range to support pure white and black. */

		if ( cr == 8 )
			cr_mask = ~0;	/* shift by 0 can tickle compiler bug */
		else
			cr_mask = ~0 << (8 - cr);

		expand = 255.0 / (double)(0xFF & cr_mask);

		for ( i = 0; i < entries; ++i )
			{
			g_cmap[i][RED] = (((int)g_cmap[i][RED]) & cr_mask) * expand
				       + 0.5;
			g_cmap[i][GRN] = (((int)g_cmap[i][GRN]) & cr_mask) * expand
				       + 0.5;
			g_cmap[i][BLU] = (((int)g_cmap[i][BLU]) & cr_mask) * expand
				       + 0.5;
			}
		}
	else	{
		register int	i;

		/* Set up default linear grey scale global color map.
		   GIF specs for this case are utterly nonsensical. */

		if ( verbose )
			Message( "default global color map has %d grey values",
				 entries
			       );

		for ( i = 0; i < entries; ++i )
			g_cmap[i][RED] =
			g_cmap[i][GRN] =
			g_cmap[i][BLU] = i * 255.0 / (entries - 1) + 0.5;
		}

	/* Open frame buffer for unbuffered output. */

	if ( (pixbuf = (unsigned char *)malloc( width * sizeof(RGBpixel) )) == NULL )
		Fatal(fbp, "Insufficient memory for scan line buffer" );

	if ( (fbp = fb_open( fb_file, width, height )) == FBIO_NULL )
		Fatal(fbp, "Couldn't open frame buffer" );

	{
		register int	wt = fb_getwidth( fbp );
		int zoom;

		ht = fb_getheight( fbp );

		if ( wt < width || ht < height )
			Message( "Frame buffer too small (%dx%d); %dx%d needed",
			       wt, ht, width, height
			     );

		if ( verbose && (wt > width || ht > height) )
			Message( "Frame buffer (%dx%d) larger than GIF screen",
				 wt, ht
			       );

		write_width = width;
		if( write_width > wt )  write_width = wt;

		zoom = fb_getwidth(fbp)/width;
		if( fb_getheight(fbp)/height < zoom )
			zoom = fb_getheight(fbp)/height;
		if( do_zoom && zoom > 1 )  {
			(void)fb_view( fbp, width/2, height/2,
				zoom, zoom );
		} else {
			/* Unzoomed, full screen */
			(void)fb_view( fbp,
				fb_getwidth(fbp)/2, fb_getheight(fbp)/2,
				1, 1 );
		}

		ht = height - 1;	/* for later use as (ht - row) */
	}

	/* Fill frame buffer with background color. */

	if ( clear && fb_clear( fbp, g_cmap[background] ) == -1 )
		Fatal(fbp, "Error clearing frame buffer to background" );

	/* Fill scanline buffer with background color too */
	{
		register int i;
		for( i=0 ; i < width; i++ )  {
			COPYRGB(&pixbuf[i*3], g_cmap[background]);
		}
	}

	/* Convert images.  GIF spec says no pauses between them. */

	for ( ; ; )
		{
		register int	c;

		if ( (c = getc( gfp )) == EOF )  {
			Fatal(fbp, "Missing GIF terminator" );
			break;
		}

		switch( c )
			{
		default:
			Message( "Warning: unknown separator 0x%2.2x", c );
			continue;	/* so says the GIF spec */

		case GIF_TERMINATOR:	/* GIF terminator */
    terminate:
			/* GIF spec suggests pause and wait for go-ahead here,
			   also "screen clear", but they're impractical. */

			if ( fb_close( fbp ) == -1 )
				{
				fbp = FBIO_NULL;	/* avoid second try */
				Fatal(fbp, "Error closing frame buffer" );
				}

			fbp = FBIO_NULL;

			if ( image > 0 )
				Fatal(fbp, "Specified image not found" );

			bu_exit( EXIT_SUCCESS, NULL );

		case GIF_EXTENSION:	/* GIF extension block introducer */
			{
			register int	i;

			if ( (i = getc( gfp )) == EOF )
				Fatal(fbp, "Error reading extension function code"
				     );

			Message( "Extension function code %d unknown", i );

			while ( (i = getc( gfp )) != 0 )
				{
				if ( i == EOF )
					Fatal(fbp,
				      "Error reading extension block byte count"
					     );

				do
					if ( getc( gfp ) == EOF )
						Fatal(fbp,
						 "Error reading extension block"
						     );
				while ( --i > 0 );
				}
			}
			break;

		case GIF_IMAGE:		/* image separator */
			{
				unsigned char	desc[9];  /* image descriptor */

				if ( fread( desc, 1, 9, gfp ) != 9 )
					Fatal(fbp, "Error reading image descriptor"
					     );

				left = desc[1] << 8 | desc[0];
				top = desc[3] << 8 | desc[2];
				right = desc[5] << 8 | desc[4];
				bottom = desc[7] << 8 | desc[6];
				M_bit = (desc[8] & 0x80) != 0;
				I_bit = (desc[8] & 0x40) != 0;

				pixel = M_bit ? (desc[8] & 0x07) + 1 : g_pixel;

				if ( verbose )
					{
					Message( "image (%d,%d,%d,%d)",
						 left, top, right, bottom
					       );

					if ( M_bit )
						{
						Message(
						      "local color map provided"
						       );
						Message( "%d bits per pixel",
							 pixel
						       );
						}

					Message( I_bit ? "interlaced"
						       : "sequential"
					       );
					}

				if ( left < 0 || right > width || left >= right
				  || top < 0 || bottom > height || top >= bottom
				   )
					Fatal(fbp, "Absurd image (%d,%d,%d,%d)",
					       left, top, right, bottom
					     );
			}

			/* Process local color map. */

			entries = 1 << pixel;

			if ( M_bit )
				{
				register int	i;
				register double	expand;	/* range expansion */

				/* Read in local color map. */

				if ( verbose )
					Message(
					       "local color map has %d entries",
						 entries
					       );

				if ( fread( cmap, 3, entries, gfp ) != entries )
					Fatal(fbp, "Error reading local color map"
					     );

				/* Mask off low-order "noise" bits,
				   and expand dynamic range. */

				expand = 255.0 / (double)(0xFF & cr_mask);

				for ( i = 0; i < entries; ++i )
					{
					cmap[i][RED] = (((int)cmap[i][RED]) & cr_mask)
						     * expand + 0.5;
					cmap[i][GRN] = (((int)cmap[i][GRN]) & cr_mask)
						     * expand + 0.5;
					cmap[i][BLU] = (((int)cmap[i][BLU]) & cr_mask)
						     * expand + 0.5;
					}
				}
			else	{
				/* Use default global color map. */

				if ( verbose )
					Message( "global color map used" );

				(void)memcpy((char *)cmap, (char *)g_cmap, 3 * entries);
				}

			/* `image' is 0 if all images are to be displayed;
			   otherwise it is a down-counter to the image wanted */
			if ( image <= 1 )
				{
				Rasters();	/* process the raster data */

				if ( image != 0 )
					goto terminate;	/* that's all, folks */
				}
			else	{
				--image;	/* desperately seeking Susan? */
				Skip();	/* skip over the raster data */
				}

			break;
			}
		}
	/* [not reached] */
	bu_exit(1, NULL);
	}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.20 2007/12/06 14:44:25 brlcad Exp $ (BRL)";
d454 1
d456 2
d459 2
d462 2
d465 2
d468 1
@


14.20
log
@refactor the handful of failure and printing functions that are common to gif-fb, fbfade, and fbstretch into their own ioutil.c file to reduce the repetition. clean-up the interface while we're at it with some constness.
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.19 2007/12/03 22:57:58 brlcad Exp $ (BRL)";
d885 1
a885 1
				(void)bcopy( (char *)g_cmap, (char *)cmap, 3 * entries );
@


14.19
log
@c89 simplification.  assume stdarg is a given.
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.18 2007/12/01 21:47:12 brlcad Exp $ (BRL)";
a91 1
static char	*arg0;			/* argv[0] for error message */
d121 3
a123 46

static char *
Simple(char *path)
{
	register char	*s;		/* -> past last '/' in path */

	return (s = strrchr( path, '/' )) == NULL || *++s == '\0' ? path : s;
	}


static void
VMessage(char *format, va_list ap)
{
	(void)fprintf( stderr, "%s: ", arg0 );
	(void)vfprintf( stderr, format, ap );
	(void)putc( '\n', stderr );
	(void)fflush( stderr );
	}


static void
Message( char *format, ... )
	{
	va_list		ap;

	va_start( ap, format );
	VMessage( format, ap );
	va_end( ap );
	}


static void
Fatal( char *format, ... )
	{
	va_list		ap;

	va_start( ap, format );
	VMessage( format, ap );
	va_end( ap );

	if ( fbp != FBIO_NULL && fb_close( fbp ) == -1 )
		Message( "Error closing frame buffer" );

	bu_exit( EXIT_FAILURE, NULL );
	/*NOTREACHED*/
	}
d132 1
a132 1
	Fatal( "Interrupted by signal %d", sig );
d142 1
a142 1
		Fatal( "Error reading code size" );
d146 1
a146 1
			Fatal( "Error reading block byte count" );
d150 1
a150 1
					Fatal( "Error reading data byte" );
d172 1
a172 1
		Fatal( "Too much raster data for image size" );
d175 1
a175 1
		Fatal( "Decoded color index %d exceeds color map size", value );
d252 1
a252 1
				Fatal( "%s at start of new LZW data block",
d262 1
a262 1
			Fatal( "%s while reading LZW data block",
d339 1
a339 1
		Fatal( "Error reading code size" );
d360 1
a360 1
		Fatal( "GIF spec's LZW code size limit (12) violated" );
d380 1
a380 1
				Fatal("LZW code impossibly large  (%x > %x, diff: %d)",
d386 1
a386 1
					Fatal( "initial LZW KwKwK code??" );
d419 1
a419 1
				Fatal( "Error reading extra raster data" );
d426 1
a426 1
		Fatal( "Zero byte count missing" );
a469 2
	arg0 = Simple( argv[0] );	/* save for possible error message */

d506 1
a506 1
			Fatal( "Usage: %s", USAGE );
d514 1
a514 1
			Fatal( "Can't handle multiple GIF files" );
d518 1
a518 1
			Fatal( "Couldn't open GIF file \"%s\"", gif_file );
d544 1
a544 1
				Fatal( "File does not contain \"GIF\" header" );
d567 1
a567 1
						Fatal(
d587 1
a587 1
			Fatal( "Error reading screen descriptor" );
d625 1
a625 1
		Fatal( "Insufficient memory for color maps" );
d640 1
a640 1
			Fatal( "Error reading global color map" );
d682 1
a682 1
		Fatal( "Insufficient memory for scan line buffer" );
d685 1
a685 1
		Fatal( "Couldn't open frame buffer" );
d725 1
a725 1
		Fatal( "Error clearing frame buffer to background" );
d742 1
a742 1
			Fatal( "Missing GIF terminator" );
d760 1
a760 1
				Fatal( "Error closing frame buffer" );
d766 1
a766 1
				Fatal( "Specified image not found" );
d775 1
a775 1
				Fatal( "Error reading extension function code"
d783 1
a783 1
					Fatal(
d789 1
a789 1
						Fatal(
d802 1
a802 1
					Fatal( "Error reading image descriptor"
d838 1
a838 1
					Fatal( "Absurd image (%d,%d,%d,%d)",
d861 1
a861 1
					Fatal( "Error reading local color map"
@


14.18
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.17 2007/11/21 20:49:07 erikgreenwald Exp $ (BRL)";
d76 1
a80 5
#if defined(HAVE_STDARG_H)
#  include	<stdarg.h>
#else
#  include	<varargs.h>
#endif
a141 1
#if defined(HAVE_STDARG_H)
a143 5
#else
static void
Message( va_alist )
	va_dcl
#endif
a144 3
#if !defined(HAVE_STDARG_H)
	register char	*format;	/* must be picked up by va_arg() */
#endif
a146 1
#if defined(HAVE_STDARG_H)
a147 4
#else
	va_start( ap );
	format = va_arg( ap, char * );
#endif
a152 1
#if defined(HAVE_STDARG_H)
a154 5
#else
static void
Fatal( va_alist )
	va_dcl
#endif
a155 3
#if !defined(HAVE_STDARG_H)
	register char	*format;	/* must be picked up by va_arg() */
#endif
a157 1
#if defined(HAVE_STDARG_H)
a158 4
#else
	va_start( ap );
	format = va_arg( ap, char * );
#endif
@


14.17
log
@pass bu_exit a NULL instead of an empty string
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.16 2007/11/21 19:09:24 erikgreenwald Exp $ (BRL)";
a139 6
#if !defined(HAVE_VPRINTF)
	(void)fprintf( stderr, format,	/* kludge city */
		       ((int *)ap)[0], ((int *)ap)[1],
		       ((int *)ap)[2], ((int *)ap)[3]
		     );
#else
a140 1
#endif
@


14.16
log
@exit->bu_exit where applicable
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.15 2007/09/15 16:23:06 brlcad Exp $ (BRL)";
d204 1
a204 1
	bu_exit( EXIT_FAILURE, "" );
d853 1
a853 1
			bu_exit( EXIT_SUCCESS, "" );
d991 1
a991 1
	bu_exit(1, "");
@


14.15
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.14 2007/04/18 02:54:01 brlcad Exp $ (BRL)";
d204 1
a204 1
	exit( EXIT_FAILURE );
d853 1
a853 1
			exit( EXIT_SUCCESS );
d991 1
a991 1
	exit(1);
@


14.14
log
@rely on EXIT_SUCCESS/FAILURE even if it is c99; use bool_t/1/0 instead of bool/true/false.
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.13 2007/04/14 01:16:02 brlcad Exp $ (BRL)";
a70 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
d75 4
a78 4
#ifdef HAVE_STRING_H
#  include	<string.h>
#else
#  include	<strings.h>
@


14.13
log
@remove the WIN32 conditionals relating to the binary mode specifier on file opens.  just keep the rb/wb mode since ISO/IEC 9899:1990 does specify it.
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.12 2007/01/27 01:41:34 brlcad Exp $ (BRL)";
d97 1
a97 10
#ifndef EXIT_SUCCESS
#define	EXIT_SUCCESS	0
#endif
#ifndef EXIT_FAILURE
#define	EXIT_FAILURE	1
#endif

typedef int	bool;
#define	false	0
#define	true	1
d100 4
a103 4
static bool	clear = true;		/* set iff clear to background wanted */
static bool	ign_cr = false;		/* set iff 8-bit color resoln. forced */
static bool	verbose = false;	/* set for GIF-file info printout */
static bool	do_zoom = false;	/* set to zoom framebuffer */
d113 2
a114 2
static bool	M_bit;			/* set iff color map provided */
static bool	I_bit;			/* set iff image interlaced */
d560 1
a560 1
		register bool	errors = false;
d566 1
a566 1
				errors = true;
d574 1
a574 1
				ign_cr = true;
d582 1
a582 1
				clear = false;
d586 1
a586 1
				verbose = true;
d589 1
a589 1
				do_zoom = true;
@


14.12
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.11 2007/01/23 01:13:31 brlcad Exp $ (BRL)";
a83 1
#  define	RBMODE	"rb"	/* "b" not really necessary for POSIX */
a85 1
#  define	RBMODE	"r"
d614 1
a614 1
		if ( (gfp = fopen( gif_file = argv[bu_optind], RBMODE )) == NULL )
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.10 2007/01/20 14:36:48 brlcad Exp $ (BRL)";
d403 1
a403 1
	            	  		/* LZW code */
@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d66 1
a66 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.9 2006/01/18 06:46:15 brlcad Exp $ (BRL)";
@


14.9
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.8 2005/11/11 21:41:59 brlcad Exp $ (BRL)";
@


14.8
log
@get rid of the NDEBUG hacking, configure provides for it now.  clean up the include/header ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.7 2005/10/23 04:44:30 brlcad Exp $ (BRL)";
@


14.7
log
@trailing ws
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.6 2005/09/21 19:00:27 brlcad Exp $ (BRL)";
a69 3
#define	USAGE	"gif-fb [-F fb_file] [-c] [-i image#] [-o] [-v] [-z] [gif_file]"
#define	OPTSTR	"F:ci:ovz"

d73 1
a73 5
# include <unistd.h>
#endif

#ifndef DEBUG
#define	NDEBUG
d80 1
a80 1
#include	<string.h>
d82 1
a82 1
#include	<strings.h>
d85 2
a86 2
# define	RBMODE	"rb"			/* "b" not really necessary for POSIX */
# include	<stdarg.h>
d88 2
a89 2
# define	RBMODE	"r"
# include	<varargs.h>
d94 5
a98 1
#include "fb.h"			/* BRL-CAD package libfb.a interface */
@


14.6
log
@needs bu.h for bu_getopt
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.5 2005/09/21 17:17:18 brlcad Exp $ (BRL)";
d78 1
a78 1
                                                                                                                                                                            
d413 1
a413 1
		assert(bp < &exp_buffer[2046]);	
@


14.5
log
@use bu_optarg, bu_optind and bu_getopt
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.4 2005/09/09 05:07:46 brlcad Exp $ (BRL)";
d100 1
@


14.4
log
@consistency, BRL-CAD not BRL CAD
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.3 2005/01/30 20:30:21 brlcad Exp $ (BRL)";
d576 1
a576 1
		while ( (c = getopt( argc, argv, OPTSTR )) != EOF )
d584 1
a584 1
				fb_file = optarg;
d592 1
a592 1
				image = atoi( optarg );
d611 1
a611 1
	if ( optind < argc )		/* gif_file */
d613 1
a613 1
		if ( optind < argc - 1 )
d619 1
a619 1
		if ( (gfp = fopen( gif_file = argv[optind], RBMODE )) == NULL )
@


14.3
log
@update copyright to 2005
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif-fb.c,v 14.2 2004/12/18 06:09:12 morrison Exp $ (BRL)";
d100 1
a100 1
#include "fb.h"			/* BRL CAD package libfb.a interface */
@


14.3.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d67 1
a67 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d70 3
d76 5
a80 1
#  include <unistd.h>
d87 1
a87 1
#  include	<string.h>
d89 1
a89 1
#  include	<strings.h>
d92 2
a93 2
#  define	RBMODE	"rb"	/* "b" not really necessary for POSIX */
#  include	<stdarg.h>
d95 2
a96 2
#  define	RBMODE	"r"
#  include	<varargs.h>
d100 1
a100 6
#include "bu.h"
#include "fb.h"


#define	USAGE	"gif-fb [-F fb_file] [-c] [-i image#] [-o] [-v] [-z] [gif_file]"
#define	OPTSTR	"F:ci:ovz"
d412 1
a412 1
		assert(bp < &exp_buffer[2046]);
d576 1
a576 1
		while ( (c = bu_getopt( argc, argv, OPTSTR )) != EOF )
d584 1
a584 1
				fb_file = bu_optarg;
d592 1
a592 1
				image = atoi( bu_optarg );
d611 1
a611 1
	if ( bu_optind < argc )		/* gif_file */
d613 1
a613 1
		if ( bu_optind < argc - 1 )
d619 1
a619 1
		if ( (gfp = fopen( gif_file = argv[bu_optind], RBMODE )) == NULL )
@


14.2
log
@assign copyright and GPL license
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif-fb.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 22
a22 1
/*
d67 1
a67 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif-fb.c,v 1.6 2004/09/08 20:31:24 kermit Exp $ (BRL)";
@


1.6
log
@Added <stdlib.h> to fix implicit cast (for IA64 architecture).
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif-fb.c,v 1.5 2004/09/03 23:30:56 morrison Exp $ (BRL)";
d989 10
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif-fb.c,v 1.4 2004/08/02 23:01:47 morrison Exp $ (BRL)";
d64 1
a76 1

@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif-fb.c,v 1.3 2004/06/09 17:56:22 erikg Exp $ (BRL)";
d64 1
a64 1
#ifdef USE_STRING_H
@


1.3
log
@fix missing header issues
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif-fb.c,v 1.2 2004/06/08 22:04:12 morrison Exp $ (BRL)";
d52 1
a52 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d56 4
a59 2


@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d46 1
a46 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/gif-fb.c,v 11.7 2004/05/10 15:30:42 erikg Exp $ (BRL)";
a78 1
#include "externs.h"
@

