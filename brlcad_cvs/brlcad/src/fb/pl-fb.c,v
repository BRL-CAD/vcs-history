head	14.23;
access;
symbols
	rel-7-10-4:14.17
	STABLE:14.17.0.2
	stable-branch:14.4
	rel-7-10-2:14.17
	rel-7-10-0:14.13
	rel-7-8-4:14.10
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.7
	rel-7-6-2:14.4
	rel-7-6-branch:14.4.0.6
	rel-7-6-0:14.4
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.23
date	2007.12.22.19.51.06;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.12.20.20.31.42;	author bob1961;	state Exp;
branches;
next	14.21;

14.21
date	2007.12.16.15.59.37;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.11.21.20.49.08;	author erikgreenwald;	state Exp;
branches;
next	14.19;

14.19
date	2007.11.21.19.09.24;	author erikgreenwald;	state Exp;
branches;
next	14.18;

14.18
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.07.26.01.13.53;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.05.12.22.23.04;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.05.12.05.59.09;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.05.12.05.53.56;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.27.01.41.34;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.23.01.13.32;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.49;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.23.07.23.37;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.23.05.02.01;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.09.21.19.00.27;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.09.21.17.17.18;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2005.01.30.20.30.21;	author brlcad;	state Exp;
branches
	14.4.6.1;
next	14.3;

14.3
date	2004.12.21.06.38.19;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.06.09.12;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.17.56.22;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.12;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.04;	author morrison;	state Exp;
branches;
next	;

14.4.6.1
date	2005.11.13.13.46.14;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.23
log
@right idea to simplify the loop, but take it a little further.
@
text
@/*                         P L - F B . C
 * BRL-CAD
 *
 * Copyright (c) 1986-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file pl-fb.c
 *
 *	Program to take 3-D UNIX plot data and output on a framebuffer.
 *
 *  Authors -
 *	Joseph C. Pistritto
 *	Michael John Muuss
 *	Douglas A. Gwyn
 *
 * Function:
 * 	Reads device-independent plot data from specified input file;
 * 	for each frame, builds an image file containing raster data then
 * 	sends the frame output to the output device.
 *
 * 	Edge-limiting is done here; use "rot" if clipping is desired.
 *
 * Method:
 * 	Inputs vector data and builds a rasterization descriptor for
 * 	each visible stroke.  (Strokes are limited to frame boundaries.)
 * 	X goes down the page, Y goes from left to right.  To obtain a
 * 	different orientation, pre-process data with the "rot" filter.
 * 	(Quadrant 1 graphics devices)
 *
 * 	The frame image file of SCANS scans is considered artificially
 * 	divided into BANDS bands, each containing lines_per_band scans.
 * 	Each band has a linked list of descriptors for
 * 	not-yet-rasterized strokes that start in the band.
 *
 * 	Space for descriptors is obtained via "malloc".  When no more
 * 	space is available, the image file is updated as follows, then
 * 	"malloc" is tried again ("must" work the second time):
 *
 * 	Each band in increasing X order becomes "active"; if no
 * 	descriptors exist for the band it is skipped, otherwise its
 * 	existing raster data is re-read from the image file into a
 * 	buffer and each descriptor is processed to rasterize its stroke.
 * 	If the stroke terminates in the band its descriptor is freed,
 * 	otherwise the descriptor is linked into the following band's
 * 	list.  When the descriptor list for the active band becomes
 * 	empty (must happen), the band's raster data is flushed back to
 * 	the image file and the next band becomes active.  This process
 * 	continues until all vectors have been input and rasterized.
 *
 * Acknowledgment:
 * 	Based rather heavily on Doug Gwyn's Versatec PLOT rasterizer VPL.C
 * 	which was based on Mike Muuss's Versatec TIGpack interpreter.
 *
 *  Note:
 *	UNIX-Plot files are defined to be machine-independent, with
 *	"little-endian" (eg, VAX) byte-ordering.
 *
 */
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.22 2007/12/20 20:31:42 bob1961 Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "bu.h"
#include "fb.h"
#include "plot3.h"

/*
  Raster device model and image terminology as used herein:

  Frames are delimited in plot data by "erase" codes; each frame looks
  like:


  top of frame
  ---------------------------------------------------------
  |			.				|
  |scan line ->...........................................|
  ^	|			.				|
  |	|			^				|
  |			|				|
  |Y axis							|
  |plot							|
  ^	|^							|
  |	||							|
  ||	X axis						|
  |-----> plot						|
  ---------------------------------------------------------
  bottom of frame


  Each plot-mode scan line consists of exactly BYTES bytes of plot data.

  Each scan line is composed of bytes of color data, for the Red,
  Green, and Blue for each pixel, times the number of pixels desired
  (512 in LORES, 1024 in HIRES)

*/

/*	Device Parameters				 */

/* the following parameter should be tweaked for fine-tuning */
#define	X_CHAR_SIZE	(8)		/* pixels per char horizontal */
#define	Y_CHAR_SIZE	(10)		/* pixels per char vertical */

#define	CLEAR	0			/* value for no intensity */


/*	Program constants computed from device parameters:	*/
#define BANDS	(Nscanlines / lines_per_band)		/* # of "bands" */
#define BANDSLOP	(BANDS+2)		/* # bands in array */
#define BYTES	(Npixels * sizeof(RGBpixel))	/* max data bytes per scan */
#define XMAX	(Npixels - 1)
#define YMAX	(Nscanlines - 1)

/* helper macros */
#define GET_STROKE(vp)    { \
			while( ((vp)=freep) == STROKE_NULL ) \
				get_strokes(); \
			freep = (vp)->freep; \
			CK_STROKE(vp); \
			(vp)->freep = STROKE_NULL; }

#define FREE_STROKE(vp)  { \
			CK_STROKE(vp); \
			(vp)->freep = freep; \
			freep = (vp); }


/*	Data structure definitions:	*/

#ifdef pdp11
typedef char	tiny;			/* for very small numbers */
#else
typedef	short	tiny;			/* for very small numbers */
#endif

typedef int	bool;			/* boolean data type */
#define false	0
#define true	1

RGBpixel	cur_color = { 255, 255, 255 };

typedef struct {
    short		x;
    short		y;
} coords; 				/* Cartesian coordinates */

typedef struct descr {
    long		magic;
    struct descr	*next;		/* next in list, or NULL */
    coords		pixel;		/* starting scan, nib */
    tiny		xsign;		/* 0 or +1 */
    tiny		ysign;		/* -1, 0, or +1 */
    bool		ymajor; 	/* true iff Y is major dir. */
#undef major
#undef minor
    short		major;		/* major dir delta (nonneg) */
    short		minor;		/* minor dir delta (nonneg) */
    short		e;		/* DDA error accumulator */
    short		de;		/* increment for `e' */
    RGBpixel	col;		/* COLOR of this vector */
    struct descr	*freep;		/* next in free list, or NULL */
} stroke; 				/* rasterization descriptor */
#define STROKE_MAGIC	0x12997601	/* Magic number */

#define	CK_STROKE(_sp)	{ \
	if((_sp)->magic != STROKE_MAGIC)  {  \
		fprintf(stderr,"Bad stroke struct, ptr=x%lx, magic was x%lx, s/b=x%lx, at file %s, line %d\n",  \
			(long)(_sp), (long)((_sp)->magic), (long)STROKE_MAGIC,  \
			__FILE__, __LINE__ );  \
		abort();  \
	} }

/*	Global data allocations:	*/

/* Space is used strictly to compute delta and deltao2
 * and to compute integer screen coordinates from them.
 * We thus make these variables only floating point.
 */
static struct {
    double		left;		/* window edges */
    double		bottom;
    double		right;
    double		top;
} space;
static double	delta;			/* larger window dimension */
static double	deltao2;		/* delta / 2 */

struct	relvect {
    short	x,y;			/* x, y values (255,255 is end) */
};

#define	END	-1,-1			/* end of stroke description */
#define	NIL	0,0
#define min(a,b)	((a)<(b)?(a):(b))
/*
 *  These character sets are taken from the Motorola MC6575 Pattern Generator,
 *  page 5-119 of 'The Complete Motorola Microcomputer Data Library'
 */
static struct vectorchar {
    char		ascii;		/* ASCII character emulated */
    struct	relvect	r[10];		/* maximum # of vectors 1 char */
} charset[] = {
    /*ASCII <1>    <2>    <3>    <4>    <5>    <6>    <7>    <8>    <9>    <10> */
    {'0', {{5,0},   {1,0},   {0,1},   {0,7},   {6,1},   {6,7},   {5,8},   {1,8},   {END},   {NIL}}},
    {'1', {{1,2},   {3,0},   {3,8},   {5,8},   {1,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'2', {{0,1},   {1,0},   {5,0},   {6,1},   {6,2},   {4,4},   {2,4},   {0,6},   {0,8},   {6,8}}},
    {'3', {{1,0},   {5,0},   {6,1},   {6,4},   {2,4},   {6,4},   {6,7},   {5,8},   {1,8},   {END}}},
    {'4', {{5,8},   {5,0},   {0,5},   {0,6},   {6,6},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'5', {{6,0},   {0,0},   {0,3},   {4,3},   {6,5},   {6,6},   {4,8},   {1,8},   {0,7},   {END}}},
    {'6', {{5,0},   {2,0},   {0,2},   {0,7},   {1,8},   {5,8},   {6,7},   {6,5},   {5,4},   {1,4}}},
    {'7', {{0,1},   {0,0},   {6,0},   {6,1},   {2,5},   {2,8},   {END},   {NIL},   {NIL},   {NIL}}},
    {'8', {{1,0},   {5,0},   {6,1},   {6,7},   {5,8},   {1,8},   {0,7},   {0,1},   {0,4},   {6,4}}},
    {'9', {{1,8},   {4,8},   {6,6},   {6,1},   {5,0},   {1,0},   {0,1},   {0,3},   {1,4},   {6,4}}},
    {'A', {{0,8},   {0,2},   {2,0},   {4,0},   {6,2},   {6,8},   {6,5},   {0,5},   {END},   {NIL}}},
    {'B', {{6,5},   {6,7},   {5,8},   {0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4}}},
    {'C', {{6,1},   {5,0},   {2,0},   {0,2},   {0,6},   {2,8},   {5,8},   {6,7},   {END},   {NIL}}},
    {'D', {{0,0},   {4,0},   {6,2},   {6,6},   {4,8},   {0,8},   {0,0},   {END},   {NIL},   {NIL}}},
    {'E', {{6,0},   {0,0},   {0,4},   {3,4},   {0,4},   {0,8},   {6,8},   {END},   {NIL},   {NIL}}},
    {'F', {{6,0},   {0,0},   {0,4},   {3,4},   {0,4},   {0,8},   {END},   {NIL},   {NIL},   {NIL}}},
    {'G', {{6,1},   {5,0},   {2,0},   {0,2},   {0,6},   {2,8},   {5,8},   {6,7},   {6,5},   {3,5}}},
    {'H', {{0,0},   {0,8},   {0,4},   {6,4},   {6,0},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
    {'I', {{1,0},   {5,0},   {3,0},   {3,8},   {1,8},   {5,8},   {END},   {NIL},   {NIL},   {NIL}}},
    {'J', {{2,0},   {6,0},   {4,0},   {4,7},   {3,8},   {1,8},   {0,7},   {END},   {NIL},   {NIL}}},
    {'K', {{0,0},   {0,8},   {0,6},   {6,0},   {2,4},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
    {'L', {{0,0},   {0,8},   {6,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'M', {{0,8},   {0,0},   {3,3},   {3,4},   {3,3},   {6,0},   {6,8},   {END},   {NIL},   {NIL}}},
    {'N', {{0,8},   {0,0},   {6,6},   {6,8},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'O', {{0,6},   {0,2},   {2,0},   {4,0},   {6,2},   {6,6},   {4,8},   {2,8},   {0,6},   {END}}},
    {'P', {{0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4},   {END},   {NIL},   {NIL}}},
    {'Q', {{6,6},   {6,2},   {4,0},   {2,0},   {0,2},   {0,6},   {2,8},   {4,8},   {4,6},   {6,8}}},
    {'R', {{0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4},   {2,4},   {6,8},   {END}}},
    {'S', {{6,1},   {5,0},   {1,0},   {0,1},   {0,4},   {5,4},   {6,5},   {6,7},   {5,8},   {0,8}}},
    {'T', {{0,0},   {6,0},   {3,0},   {3,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'U', {{0,0},   {0,7},   {1,8},   {5,8},   {6,7},   {6,0},   {END},   {NIL},   {NIL},   {NIL}}},
    {'V', {{0,0},   {0,2},   {3,8},   {6,2},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'W', {{0,0},   {0,8},   {3,5},   {3,4},   {3,5},   {6,8},   {6,0},   {END},   {NIL},   {NIL}}},
    {'X', {{0,0},   {6,8},   {3,4},   {0,8},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'Y', {{0,0},   {0,1},   {3,4},   {3,8},   {3,4},   {6,1},   {6,0},   {END},   {NIL},   {NIL}}},
    {'Z', {{0,0},   {6,0},   {6,1},   {0,7},   {0,8},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
    {'+', {{0,4},   {6,4},   {3,4},   {3,1},   {3,7},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'-', {{0,4},   {6,4},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'/', {{0,7},   {6,1},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'(', {{4,0},   {2,2},   {2,6},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {')', {{2,0},   {4,2},   {4,6},   {2,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'<', {{4,0},   {0,4},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {'>', {{2,0},   {6,4},   {2,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},

    /* Some needed chars, hastily drawn -MJM */
    {'.', {{4,7},   {3,7},   {3,6},   {4,6},   {4,7},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
    {',', {{4,6},   {3,6},   {3,5},   {4,5},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},

    {'\0'}
};

static int	Nscanlines = 512;
static int	Npixels = 512;
static char	*framebuffer = NULL;
static char	*filename = NULL;

struct band  {
    stroke	*first;
    stroke	*last;
};
static struct band	*band;		/* array of descriptor lists */
static struct band	*bandEnd;

static unsigned char	*buffer;		/* ptr to active band buffer */
static long	buffersize;		/* active band buffer bytes */
static short	ystart = 0;		/* active band starting scan */
static int	debug  = 0;
static int	over = 0;		/* !0 to overlay on existing image */
static int	immediate = 0;		/* !0 to plot immediately */
static int	single_banded = 0;	/* !0 if one fullscreen band */
static short	lines_per_band = 16;	/* scan lines per band */
static short	line_thickness = 1;

/* signals to be caught */
static int sigs[] = {
#ifdef SIGHUP
    SIGHUP,
#endif
#ifdef SIGINT
    SIGINT,
#endif
#ifdef SIGQUIT
    SIGQUIT,
#endif
#ifdef SIGTERM
    SIGTERM,
#endif
    0
};

static FILE	*pfin;		/* input file FIO block ptr */
FBIO	*fbp;			/* Current framebuffer */


/*
 *  Stroke descriptor management.
 *  We malloc these in large blocks and keep our own free list.
 *  Last I looked it took 32 bytes per stroke, so every 32 strokes
 *  is 1KB, or 32K strokes / MByte.
 */
#define	STROKE_NULL	((stroke *)0)

static struct descr	*freep = STROKE_NULL;	/* head of free stroke list */


/*
 *	Dequeue - remove descriptor from band list (do not free space)
 *
 *  Returns addr of descriptor, or NULL if none left.
 */
static stroke *
Dequeue(register struct band *bp, register stroke **hp)
     /* *hp -> first descr in list */
{
    register stroke *vp;		/* -> descriptor */

    if ( (vp = *hp) != NULL )
	*hp = vp->next; 	/* -> next element in list */

    if( vp == NULL )
	bp->last = NULL;

    return vp;			/* may be NULL */
}


/*
 * 	Requeue - enqueue descriptor at END of band list
 */
static void
Requeue(register struct band *bp, register stroke *vp)
{
    CK_STROKE(vp);
    vp->next = NULL;
    if( bp->last )
	bp->last->next = vp;
    else
	bp->first = vp;

    bp->last = vp;
}


/*
 *	Raster - rasterize stroke.
 *
 *  If immediate mode, draw the individual pixel on the frame buffer.
 *  If banded buffered mode, draw the portion in this band.  If it
 *     overflows into next band, requeue; else free the descriptor.
 *
 *  Method:
 *	Modified Bresenham algorithm.  Guaranteed to mark a dot for
 *	a zero-length stroke.  Please do not try to "improve" this code
 *	as it is extremely hard to get all aspects just right.
 */
static void
Raster(register stroke *vp, register struct band *np)
     /* -> rasterization descr */
     /* *np -> next band 1st descr */
{
    register short	dy;		/* raster within active band */

    CK_STROKE(vp);

    /*
     *  Draw the portion within this band.
     */
    for ( dy = vp->pixel.y - ystart; dy < lines_per_band; ) {

	/* set the appropriate pixel in the buffer */
	if( immediate )  {
	    fb_write( fbp, vp->pixel.x, dy, vp->col, 1 );
	}  else  {
	    register unsigned char *pp;

	    pp = (unsigned char *)&buffer[((dy*Npixels) + vp->pixel.x)*sizeof(RGBpixel)];
	    COPYRGB( pp, vp->col );
	}

	if ( vp->major-- == 0 ) { /* done! */
	    FREE_STROKE( vp );	/* return to "malloc" */
	    return;
	}

	if ( vp->e < 0 ) {
	    /* advance major & minor */
	    dy += vp->ysign;
	    vp->pixel.x += vp->xsign;
	    vp->e += vp->de;
	} else {
	    /* advance major only */
	    if ( vp->ymajor )	/* Y is major dir */
		++dy;
	    else			/* X is major dir */
		vp->pixel.x += vp->xsign;
	    vp->e -= vp->minor;
	}
    }

    /* overflow into next band; re-queue */
    vp->pixel.y = ystart + lines_per_band;
    Requeue( np, vp );       /* DDA parameters already set */
}


/*
 *	OutBuild - rasterize all strokes into raster frame image
 */
static bool
OutBuild(void)				/* returns true if successful */
{
    register struct band *hp;	/* *hp -> head of descr list */
    register struct band *np;	/* `hp' for next band */
    register stroke *vp;		/* -> rasterization descr */

    if( single_banded ) {
	if( debug ) fprintf(stderr,"OutBuild:  band y=%d\n", ystart);
	if( fb_write( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
	    return false;	/* can't write image file */
	if( over )  {
	    /* Read back the composite image */
	    if( fb_read( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
		fprintf(stderr,"pl-fb:  band read error\n");
	}
	return true;
    }

    for ( hp = &band[0]; hp < bandEnd; ++hp )
	if ( hp->first != NULL )
	    break;

    if ( hp == bandEnd )
	return true;		/* nothing to do */

    for ( hp = &band[0], np = &band[1], ystart = 0;
	  hp < bandEnd;
	  hp = np++, ystart += lines_per_band
	  )	{
	if(debug) fprintf(stderr,"OutBuild:  band y=%d\n", ystart);
	if( over )  {
	    /* Read in current band */
	    if( fb_read( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
		fprintf(stderr,"pl-fb:  band read error\n");
	} else {
	    /* clear pixels in the band */
	    memset((char *)buffer, 0, buffersize);
	}

	while ( (vp = Dequeue( hp, &hp->first )) != NULL )
	    Raster( vp, np );      /* rasterize stroke */

	/* Raster() either re-queued the descriptor onto the
	   next band list or else it freed the descriptor */

	if(debug) fprintf(stderr,"OutBuild:  fbwrite y=%d\n", ystart);
	if( fb_write( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
	    return false;	/* can't write image file */
    }

    return true;			/* success */
}


/* allocate new strokes to the free list */
static void
get_strokes(void)
{
    register stroke	*sp;
    register char	*cp;
    register int	bytes;

    /* ~32 strokes/KB */
    bytes = 640 * sizeof(stroke);
    if( (cp = malloc(bytes)) == (char *)0 ) {
	/* Attempt to draw/free some vectors and try again */
	OutBuild();
	if( (cp = malloc(bytes)) == (char *)0 ) {
	    fprintf(stderr,"pl-fb: malloc failed!\n");
	    bu_exit( 2, NULL );
	}
    }
    /* link them all into the free list */
    sp = (stroke *)cp;
    while( bytes >= sizeof(stroke) ) {
	sp->freep = freep;
	sp->magic = STROKE_MAGIC;
	freep = sp++;
	bytes -= sizeof(stroke);
    }
}


/*
 *			S X T 1 6
 *
 *  Take a value which is currently considered "unsigned" with 16 bits
 *  of significance, and sign-extend it in a reasonably portable way.
 *  We assume the machine is twos-compliment.
 */
long
sxt16(register long int v)
{
    register long w;
    if( v <= 0x7FFF )  return(v);
    w = -1;
    w &= ~0x7FFF;
    return( w | v );
}

int
get_args(int argc, register char **argv)
{
    register int c;

    while( (c = bu_getopt( argc, argv, "hdoOit:F:s:S:w:W:n:N:" )) != EOF ) {
	switch( c ) {
	    case 't':
		line_thickness = atoi(bu_optarg);
		if( line_thickness <= 0 )
		    line_thickness = 1;
		break;
	    case 'i':
		immediate = 1;
		break;
	    case 'd':
		/* -d given multiple times increases debug level */
		debug++;
		break;
	    case 'O':
	    case 'o':
		over = 1;
		break;
	    case 'F':
		framebuffer = bu_optarg;
		break;
	    case 'h':
		Nscanlines = Npixels = 1024;
		break;
	    case 'S':
	    case 's':
		Nscanlines = Npixels = atoi(bu_optarg);
		break;
	    case 'W':
	    case 'w':
		Npixels = atoi(bu_optarg);
		break;
	    case 'N':
	    case 'n':
		Nscanlines = atoi(bu_optarg);
		break;
	    default:		/* '?' */
		return(0);
	}
    }

    if( bu_optind >= argc ) {
	/* no file name given, use stdin */
	if( isatty(fileno(stdin)) )
	    return(0);
	filename = "-";
	pfin = stdin;
    } else {
	/* open file */
	filename = argv[bu_optind];
	if( (pfin = fopen(filename, "r")) == NULL ) {
	    fprintf( stderr,
		     "pl-fb: Can't open file \"%s\"\n", filename );
	    return(0);
	}
    }

    if( argc > ++bu_optind )
	(void)fprintf( stderr, "pl-fb: excess argument(s) ignored\n" );

    return(1);		/* OK */
}

static char usage[] = "\
Usage: pl-fb [-h -d -o -i] [-t thickness] [-F framebuffer]\n\
	[-S squaresize] [-W width] [-N height] [file.plot]\n";


/*
  InitDesc - initialize stroke descriptor lists
*/
static void
InitDesc(void)
{
    register struct band *bp;	/* *bp -> start of descr list */

    for ( bp = &band[0]; bp < &band[BANDSLOP]; ++bp )  {
	bp->first = NULL;		/* nothing in band yet */
	bp->last  = NULL;
    }
}


/*
  FreeUp - deallocate descriptors
*/
static void
FreeUp(void)
{
    register struct band *bp;
    register stroke *vp;		/* -> rasterization descr */

    for ( bp = &band[0]; bp < bandEnd; ++bp )
	while ( (vp = Dequeue( bp, &bp->first )) != NULL )
	    FREE_STROKE(vp);	/* free storage */
}


/*
  Foo - clean up before return from rasterizer
*/
static int
Foo(int code)				/* returns status code */
{
    if( debug ) fprintf(stderr,"Foo(%d)\n", code);
    fb_close( fbp );		/* release framebuffer */

    FreeUp();			/* deallocate descriptors */

    return code;
}


/*
 *			P R E P _ D D A
 *
 *  Set up multi-band DDA parameters for stroke
 */
static void
prep_dda(register stroke *vp, register coords *pt1, register coords *pt2)
{
    CK_STROKE(vp);
    vp->pixel = *pt1;		/* initial pixel */
    vp->major = pt2->y - vp->pixel.y;	/* always nonnegative */
    vp->ysign = vp->major ? 1 : 0;
    vp->minor = pt2->x - vp->pixel.x;
    COPYRGB( vp->col, cur_color );
    if ( (vp->xsign = vp->minor ? (vp->minor > 0 ? 1 : -1) : 0) < 0 )
	vp->minor = -vp->minor;

    /* if Y is not really major, correct the assignments */
    if ( !(vp->ymajor = vp->minor <= vp->major) )  {
	register short	temp;	/* temporary for swap */

	temp = vp->minor;
	vp->minor = vp->major;
	vp->major = temp;
    }

    vp->e = vp->major / 2 - vp->minor;	/* initial DDA error */
    vp->de = vp->major - vp->minor;
}


/*
 *	BuildStr - set up DDA parameters and queue stroke
 *
 *  Given two end points of a line, allocate and intialize a stroke
 *  descriptor for it.  If we are drawing "thick" lines we generate
 *  several extra stroke descriptors as well.  In immediate or memory
 *  buffered mode we rasterize it and free it right away.  In "regular"
 *  banded buffered mode, we link the descriptor(s) into its starting
 *  point band(s).
 */
static bool
BuildStr(coords *pt1, coords *pt2)		/* returns true or dies */
     /* endpoints */
{
    register stroke *vp;		/* -> rasterization descr */
    register int	thick;

    /* arrange for pt1 to have the smaller Y-coordinate: */
    if ( pt1->y > pt2->y )  {
	register coords *temp;	/* temporary for swap */

	temp = pt1;		/* swap pointers */
	pt1 = pt2;
	pt2 = temp;
    }

    GET_STROKE(vp);			/* alloc a descriptor */
    prep_dda( vp, pt1, pt2 );	/* prep it */

    /* Thicken by advancing alternating pixels in minor direction */
    thick = line_thickness - 1;	/* number of "extra" pixels */
    if( thick >= vp->major && vp->major > 0 )  thick = vp->major-1;
    for( ; thick >= 0; thick-- )  {
	register stroke *v2;

	if( thick == 0 ) {
	    /* last pass, use vp */
	    v2 = vp;
	} else {
	    /* make a new one */
	    GET_STROKE(v2);
	    *v2 = *vp;
	}

	/* Advance minor only */
	if( vp->ymajor )
	    v2->pixel.x += (vp->xsign!=0 ? vp->xsign : 1) *
		((thick&1)==0 ? (thick+1)/2 : (thick+1)/-2 );
	else
	    v2->pixel.y += (vp->ysign!=0 ? vp->ysign : 1) *
		((thick&1)==0 ? (thick+1)/2 : (thick+1)/-2 );

	if( immediate || single_banded )  {
	    ystart = 0;
	    Raster( v2, (struct band *)0 );
	}  else
	    /* link descriptor into band corresponding to starting scan */
	    Requeue( &band[v2->pixel.y / lines_per_band], v2 );
    }
    return true;
}


static bool
GetCoords(register coords *coop)
     /* -> input coordinates */
{
    unsigned char buf[4];
    double	x, y;

    /* read coordinates */
    if ( fread( (char *)buf, (int)sizeof (buf), 1, pfin ) != 1 )
	return false;


    x = sxt16((long)(buf[1]<<8) | buf[0]);
    y = sxt16((long)(buf[3]<<8) | buf[2]);
    if( debug )  fprintf(stderr,"Coord: (%g,%g) ", x, y);

    /* limit left, bottom */
    if ( (x -= space.left) < 0 )
	x = 0;
    if ( (y -= space.bottom) < 0 )
	y = 0;

    /* convert to device pixels */
    coop->x = (short)(x * Npixels / (double)delta + 0.5);
    coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

    /* limit right, top */
    if ( coop->x > XMAX )
	coop->x = XMAX;
    if ( coop->y > YMAX )
	coop->y = YMAX;

    if( debug )
	fprintf( stderr,"Pixel: (%d,%d)\n", coop->x, coop->y);

    return true;
}


/*
  GetCoords - input x,y coordinates and scale into pixels
*/
bool Get3Coords(register coords *coop)
{
    char	trash[2];
    register bool	ret;

    ret = GetCoords( coop );
    fread( trash, sizeof(trash), 1, pfin );
    return( ret );
}


/* IEEE coordinates */
bool Get3DCoords(register coords *coop)
{
    static unsigned char in[3*8];
    static double	out[2];
    register double	x,y;

    /* read coordinates */
    if ( fread( in, sizeof(in), 1, pfin ) != 1 )
	return false;
    ntohd( (unsigned char *)out, in, 2 );
    x = out[0];
    y = out[1];

    /* limit left, bottom */
    if ( (x -= space.left) < 0 )
	x = 0;
    if ( (y -= space.bottom) < 0 )
	y = 0;

    /* convert to device pixels */
    coop->x = (short)(x * Npixels / (double)delta + 0.5);
    coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

    /* limit right, top */
    if ( coop->x > XMAX )
	coop->x = XMAX;
    if ( coop->y > YMAX )
	coop->y = YMAX;

    if( debug )  {
	fprintf(stderr,"Coord3: (%g,%g) ", out[0], out[1]);
	fprintf(stderr,"Pixel3: (%d,%d)\n", coop->x, coop->y);
    }
    return( true );
}


bool
GetDCoords(register coords *coop)
     /* -> input coordinates */
{
    static unsigned char	in[2*8];
    static double	out[2];
    register double	x,y;

    /* read coordinates */
    if ( fread( in, sizeof(in), 1, pfin ) != 1 )
	return false;
    ntohd( (unsigned char *)out, in, 2 );
    x = out[0];
    y = out[1];

    /* limit left, bottom */
    if ( (x -= space.left) < 0 )
	x = 0;
    if ( (y -= space.bottom) < 0 )
	y = 0;

    /* convert to device pixels */
    coop->x = (short)(x * Npixels / (double)delta + 0.5);
    coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

    /* limit right, top */
    if ( coop->x > XMAX )
	coop->x = XMAX;
    if ( coop->y > YMAX )
	coop->y = YMAX;

    if( debug )  {
	fprintf(stderr,"Coord2: (%g,%g) ", out[0], out[1]);
	fprintf(stderr,"Pixel2: (%d,%d)\n", coop->x, coop->y);
    }
    return true;
}


/*
 *	E D G E L I M I T
 *
 *	Limit generated positions to edges of screen
 */
void
edgelimit(register coords *ppos)
{
    if( ppos->x >= Npixels )
	ppos->x = Npixels -1;

    if( ppos->y >= Nscanlines )
	ppos->y = Nscanlines -1;
}


/*
 *	PutVectorChar - Put vectors corresponding to this character out
 * 	into plotting space
 *	Update position to reflect character width.
 */
void
put_vector_char(register char c, register coords *pos)
{
    static coords	start, end;
    register struct vectorchar	*vc;
    register struct relvect		*rv;

    if( !isascii(c) )
	c = '?';
    if( islower(c) )
	c = toupper(c);

    for( vc = &charset[0]; vc->ascii; vc++)
	if( vc->ascii == c )
	    break;

    if( !vc->ascii )  {
	/* Character not found in table -- space over 1/2 char */
	pos->x += X_CHAR_SIZE/2;
	return;
    }

    /* have the correct character entry - start plotting */
    start.x = vc->r[0].x + pos->x;
    start.y = Y_CHAR_SIZE - vc->r[0].y + pos->y;

    for( rv = &vc->r[1]; (rv < &vc->r[10]) && rv->x >= 0; rv++ )  {
	end.x = rv->x + pos->x;
	end.y = Y_CHAR_SIZE - rv->y + pos->y;
	edgelimit( &start );
	edgelimit( &end );
	BuildStr( &start, &end );	/* pixels */
	start = end;
    }
    pos->x += X_CHAR_SIZE;
}


/*
  DoFile - process UNIX plot file

  This routine reads UNIX plot records from the specified file
  and controls the entry of the strokes into the descriptor lists.
  Strokes are limited (not clipped) to fit the frame.

  Upon end of file, erase, or flush, plot data is copied to the device.
  Returns status code:
  < 0	=> catastrophe
  = 0	=> complete success
  > 0	=> line limit hit
*/
static int
DoFile(void)	/* returns vpl status code */
{
    register bool	plotted;	/* false => empty frame image */
    register int	c;		/* input character */
    static coords	newpos; 	/* current input coordinates */
    static coords	virpos; 	/* virtual pen position */
    static unsigned char buf3[6*2];
    static unsigned char buf2[4*2];
    static	bool	firsterase = true;

    /* process each frame into a raster image file */

    for ( ; ; )			/* for each frame */
	{
	    InitDesc();		/* empty descriptor lists */

	    virpos.x = virpos.y = 0;
	    plotted = false;

	    for ( ; ; )		/* read until EOF*/
		{
		    c = getc( pfin );
		    if( debug > 1 )  fprintf(stderr,"%c\n", c);
		    switch ( c )
			{	/* record type */
			    case EOF:
				if( debug ) fprintf( stderr,"EOF\n");

				if ( plotted )  {
				    /* flush strokes */
				    if( debug ) fprintf( stderr,"flushing\n");
				    if ( !OutBuild() )
					return Foo( -6 );
				}
				return Foo( 0 );/* success */

			    case 'e':	/* erase */
				if( debug )  fprintf( stderr,"Erase\n");

				if ( plotted )  {
				    /* flush strokes */
				    if( debug ) fprintf( stderr,"flushing\n");
				    if ( !OutBuild() )
					return Foo( -6 );
				}
				if( !firsterase ) {
				    if( immediate )
					fb_clear( fbp, RGBPIXEL_NULL );
				    over = 0;
				}
				firsterase = false;
				break;	/* next frame */

			    case 'F':	/* flush */
				if( debug )  fprintf( stderr,"Flush\n");

				if ( plotted )  {
				    /* flush strokes */
				    if( debug ) fprintf( stderr,"flushing\n");
				    if ( !OutBuild() )
					return Foo( -6 );
				    if( !immediate )
					over = 1;
				}
				firsterase = false;
				break;	/* next frame */

			    case 'f':	/* linemod */
				if(debug)
				    fprintf( stderr,"linemod\n");
				/* ignore for time being */
				while ( (c = getc( pfin )) != EOF
					&& c != '\n'
					)
				    ;	/* eat string */
				continue;

			    case 'L':
			    case 'M':
				if ( !Get3Coords( &newpos ) )
				    return Foo( -8 );
				virpos = newpos;
				if( c == 'M'  )  {
				    if( debug )
					fprintf( stderr,"Move3\n");
				    continue;
				}
				if( debug )
				    fprintf( stderr,"Line3\n");

			    case 'N':	/* continue3 */
			    case 'P':	/* point3 */
				if ( !Get3Coords( &newpos ) )
				    return Foo( -9 );
				if ( c == 'P' )  {
				    if( debug )
					fprintf( stderr,"point3\n");
				    virpos = newpos;
				} else
				    if( debug )
					fprintf( stderr,"cont3\n");

				if ( !BuildStr( &virpos, &newpos ) )
				    return Foo( -10 );
				plotted = true;
				virpos = newpos;
				continue;

			    case 'l':	/* line */
			    case 'm':	/* move */
				if ( !GetCoords( &newpos ) )
				    return Foo( -8 );
				virpos = newpos;
				if ( c == 'm' )  {
				    if( debug )
					fprintf( stderr,"move\n");
				    continue;
				}
				/* line: fall through */
				if( debug )
				    fprintf( stderr,"line\n");

			    case 'n':	/* cont */
			    case 'p':	/* point */
				if ( !GetCoords( &newpos ) )
				    return Foo( -9 );
				if ( c == 'p' )  {
				    if( debug )
					fprintf( stderr,"point\n");
				    virpos = newpos;
				} else
				    if( debug )
					fprintf( stderr,"cont\n");

				if ( !BuildStr( &virpos, &newpos ) )
				    return Foo( -10 );
				plotted = true;
				virpos = newpos;
				continue;

				/* IEEE */
			    case 'V':
			    case 'O':
				if ( !Get3DCoords( &newpos ) )
				    return Foo( -8 );
				virpos = newpos;
				if( c == 'O'  )  {
				    if( debug )
					fprintf( stderr,"dMove3\n");
				    continue;
				}
				if( debug )
				    fprintf( stderr,"dLine3\n");

			    case 'Q':	/* continue3 */
			    case 'X':	/* point3 */
				if ( !Get3DCoords( &newpos ) )
				    return Foo( -9 );
				if ( c == 'X' )  {
				    if( debug )
					fprintf( stderr,"dpoint3\n");
				    virpos = newpos;
				} else
				    if( debug )
					fprintf( stderr,"dcont3\n");

				if ( !BuildStr( &virpos, &newpos ) )
				    return Foo( -10 );
				plotted = true;
				virpos = newpos;
				continue;

			    case 'v':	/* line */
			    case 'o':	/* move */
				if ( !GetDCoords( &newpos ) )
				    return Foo( -8 );
				virpos = newpos;
				if ( c == 'o' )  {
				    if( debug )
					fprintf( stderr,"dmove\n");
				    continue;
				}
				/* line: fall through */
				if( debug )
				    fprintf( stderr,"dline\n");

			    case 'q':	/* cont */
			    case 'x':	/* point */
				if ( !GetDCoords( &newpos ) )
				    return Foo( -9 );
				if ( c == 'x' )  {
				    if( debug )
					fprintf( stderr,"dpoint\n");
				    virpos = newpos;
				} else
				    if( debug )
					fprintf( stderr,"dcont\n");

				if ( !BuildStr( &virpos, &newpos ) )
				    return Foo( -10 );
				plotted = true;
				virpos = newpos;
				continue;

			    case 'W':
				{
				    unsigned char	in[6*8];
				    double	out[6];
				    if( debug )
					fprintf( stderr,"dspace3\n");
				    if( fread( in, sizeof(in), 1, pfin) != 1 )
					return Foo( -11 );
				    ntohd( (unsigned char *)out, in, 5 );
				    /* Only need X and Y, ignore Z */
				    space.left  = out[0]; /* x1 */
				    space.bottom= out[1]; /* y1 */
				    /* z1 */
				    space.right = out[3]; /* x2 */
				    space.top   = out[4]; /* y2 */
				    /* z2 */
				    goto spacend;
				}

			    case 'w':	/* space */
				{
				    unsigned char	in[4*8];
				    double	out[4];
				    if( debug )
					fprintf( stderr,"dspace\n");
				    if( fread( in, sizeof(in), 1, pfin) != 1 )
					return Foo( -11 );
				    ntohd( (unsigned char *)out, in, 4 );
				    space.left  = out[0]; /* x1 */
				    space.bottom= out[1]; /* y1 */
				    space.right = out[2]; /* x2 */
				    space.top   = out[3]; /* y2 */
				    goto spacend;
				}

			    case 'S':
				{
				    if( debug )
					fprintf( stderr,"space3\n");
				    if( fread( (char *)buf3,
					       (int)sizeof buf3, 1, pfin)
					!= 1
					)
					return Foo( -11 );
				    /* Only need X and Y, ignore Z */
				    space.left  = sxt16((long)(buf3[1]<<8) | buf3[0]); /* x1 */
				    space.bottom= sxt16((long)(buf3[3]<<8) | buf3[2]); /* y1 */
				    /* z1 */
				    space.right = sxt16((long)(buf3[7]<<8) | buf3[6]); /* x2 */
				    space.top   = sxt16((long)(buf3[9]<<8) | buf3[8]); /* y2 */
				    /* z2 */
				    goto spacend;
				}

			    case 's':	/* space */
				if( debug )
				    fprintf( stderr,"space\n");
				{
				    if ( fread( (char *)buf2,
						(int)sizeof buf2, 1, pfin
						) != 1
					 )
					return Foo( -11 );
				    space.left  = sxt16((long)(buf2[1]<<8) | buf2[0]); /* x1 */
				    space.bottom= sxt16((long)(buf2[3]<<8) | buf2[2]); /* y1 */
				    space.right = sxt16((long)(buf2[5]<<8) | buf2[4]); /* x2 */
				    space.top   = sxt16((long)(buf2[7]<<8) | buf2[6]); /* y2 */
				}

			spacend:
				delta = space.right - space.left;
				deltao2 = space.top - space.bottom;
				if ( deltao2 > delta )
				    delta = deltao2;
				if( delta <= 0 )  {
				    fprintf( stderr, "pl-fb: delta = %g, bad space()\n", delta );
				    return Foo( -42 );
				}
				deltao2 = delta / 2.0;
				if( debug )
				    fprintf( stderr,"Space: X=(%g,%g) Y=(%g,%g) delta=%g\n",
					     space.left, space.right,
					     space.bottom, space.top,
					     delta );
				continue;

			    case 'C':	/* color */
				if( fread( cur_color, 1, 3, pfin) != 3 )
				    return Foo( -11 );
				if( debug )
				    fprintf( stderr,"Color is R%d G%d B%d\n",
					     cur_color[RED],
					     cur_color[GRN],
					     cur_color[BLU]);
				continue;

			    case 't':	/* label */
				if( debug )
				    fprintf( stderr,"label: ");

				newpos = virpos;
				while ( (c = getc( pfin )) != EOF && c != '\n'
					)  {
				    /* vectorize the characters */
				    put_vector_char( c, &newpos);

				    if( debug )
					putc( c, stderr );
				}

				plotted = true;
				virpos = newpos;
				continue;

				/* discard the deadwood */
			    case 'c':
				{
				    char buf[3*2];
				    if( fread(buf, sizeof(buf), 1, pfin) != 1 )
					return Foo( -11 );
				    if( debug )
					fprintf( stderr,"circle ignored\n" );
				    continue;
				}
			    case 'i':
				{
				    char buf[3*8];
				    if( fread(buf, sizeof(buf), 1, pfin) != 1 )
					return Foo( -11 );
				    if( debug )
					fprintf( stderr,"d_circle ignored\n" );
				    continue;
				}
			    case 'a':
				{
				    char buf[6*2];
				    if( fread(buf, sizeof(buf), 1, pfin) != 1 )
					return Foo( -11 );
				    if( debug )
					fprintf( stderr,"arc ignored\n" );
				    continue;
				}
			    case 'r':
				{
				    char buf[6*8];
				    if( fread(buf, sizeof(buf), 1, pfin) != 1 )
					return Foo( -11 );
				    if( debug )
					fprintf( stderr,"d_arc ignored\n" );
				    continue;
				}

			    default:
				fprintf( stderr,"bad command '%c' (0x%02x)\n", c, c );

				return Foo( -12 );	/* bad input */
			}
		    break;
		}		/* next input record */
	}			/* next frame */
}


/*
  Catch - invoked on interrupt
*/
static void
Catch(register int sig)
     /* signal number */
{
    register int pid;		/* this process's ID */
    register int *psig;		/* -> sigs[.] */
    register int i;

    for (i = 0; sigs[i]; ++i)
	(void)signal(sigs[i], SIG_IGN);

    (void)Foo( -13 );		/* clean up */

    (void)signal( sig, SIG_DFL );

    pid = bu_process_id();

    if ( pid > 1 ) {
#ifdef HAVE_KILL
	/* (re)signal process */
	(void)kill( pid, sig );
#endif
    }
}


/*
  SetSigs - set up signal catchers
*/
static void
SetSigs(void)
{
    register int	*psig;		/* -> sigs[.] */
    register int i;

    for (i = 0; sigs[i]; ++i) {
	if (signal(sigs[i], SIG_IGN) != SIG_IGN)
	    (void)signal(sigs[i], Catch);
    }
}


/*
 *  M A I N
 *
 *	Parse arguments, valid ones are:
 *		name of file to plot (instead of STDIN)
 *		-d for debugging statements
 *
 *	Default (no arguments) action is to plot STDIN on current FB.
 */
int
main(int argc, char **argv)
{
    Nscanlines = Npixels = 512;

    if ( !get_args( argc, argv ) )  {
	(void)fputs(usage, stderr);
	bu_exit( 1, NULL );
    }

    /* Open frame buffer, adapt to slightly smaller ones */
    if( (fbp = fb_open(framebuffer, Npixels, Nscanlines)) == FBIO_NULL ) {
	fprintf(stderr,"pl-fb: fb_open failed\n");
	bu_exit(1, NULL);
    }
    Npixels = fb_getwidth(fbp);
    Nscanlines = fb_getheight(fbp);
    if( immediate )  {
	lines_per_band = Nscanlines;
	if( !over )
	    fb_clear( fbp, RGBPIXEL_NULL );
    } else if( Nscanlines <= 512 ) {
	/* make one full size band */
	lines_per_band = Nscanlines;
	single_banded = 1;
    }

    /*
     * Handle image-size specific initializations
     */
    if( (Nscanlines % lines_per_band) != 0 )  {
	/* round it down - only necessary if buffered? */
	Nscanlines = (Nscanlines / lines_per_band) * lines_per_band;
    }
    space.left = space.right = 0;
    space.right = Npixels;
    space.top = Nscanlines;
    delta = Nscanlines;
    deltao2 = Nscanlines/2;

    buffersize = lines_per_band*Npixels*sizeof(RGBpixel);
    if( (buffer = (unsigned char *)malloc(buffersize)) == RGBPIXEL_NULL)  {
	fprintf(stderr,"pl-fb:  malloc error\n");
	bu_exit(1, NULL);
    }
    /* Extra band protects against requeueing off the top */
    band = (struct band *)malloc((BANDSLOP)*sizeof(struct band));
    if( band == (struct band *)0 )  {
	fprintf(stderr,"pl-fb: malloc error2\n");
	bu_exit(1, NULL);
    }
    memset((char *)band, 0, (BANDSLOP)*sizeof(struct band));
    bandEnd = &band[BANDS];
    if( single_banded && over ) {
	/* Read in initial screen */
	if( fb_read( fbp, 0, 0, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
	    fprintf(stderr,"pl-fb: band read error\n");
    }
    if( debug )
	fprintf(stderr, "pl-fb output of %s\n", filename);

    SetSigs();			/* set signal catchers */

    (void)DoFile( );	/* plot it */
    bu_exit(0, NULL);
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.22
log
@Mods to get things compiling on windows.
@
text
@d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.21 2007/12/16 15:59:37 brlcad Exp $ (BRL)";
d1334 1
a1334 2
#if 1
    for (i = 0; sigs[i] != 0; ++i)
a1335 7
#else
    for ( psig = &sigs[0];
	  psig < &sigs[sizeof sigs / sizeof sigs[0]];
	  ++psig
	  )
	(void)signal( *psig, SIG_IGN );
#endif
d1361 1
a1361 2
#if 1
    for (i = 0; sigs[i] != 0; ++i)
d1364 1
a1364 8
#else
    for ( psig = &sigs[0];
	  psig < &sigs[sizeof sigs / sizeof sigs[0]];
	  ++psig
	  )
	if ( signal( *psig, SIG_IGN ) != SIG_IGN )
	    (void)signal( *psig, Catch );
#endif
@


14.21
log
@convert all bzero calls to memset
@
text
@d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.20 2007/11/21 20:49:08 erikgreenwald Exp $ (BRL)";
d307 1
d309 2
d312 2
d315 5
a319 1
    SIGTERM
d1330 8
a1337 3
    register int	pid;		/* this process's ID */
    register int	*psig;		/* -> sigs[.] */

d1343 1
d1367 1
d1369 5
d1380 1
@


14.20
log
@pass bu_exit a NULL instead of an empty string
@
text
@d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.19 2007/11/21 19:09:24 erikgreenwald Exp $ (BRL)";
d468 1
a468 1
	    bzero( (char *)buffer, buffersize );
d1422 1
a1422 1
    bzero( (char *)band, (BANDSLOP)*sizeof(struct band) );
@


14.19
log
@exit->bu_exit where applicable
@
text
@d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.18 2007/09/15 16:23:06 brlcad Exp $ (BRL)";
d501 1
a501 1
	    bu_exit( 2, "" );
d1378 1
a1378 1
	bu_exit( 1, "" );
d1384 1
a1384 1
	bu_exit(1, "");
d1414 1
a1414 1
	bu_exit(1, "");
d1420 1
a1420 1
	bu_exit(1, "");
d1435 1
a1435 1
    bu_exit(0, "");
@


14.18
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.17 2007/07/26 01:13:53 brlcad Exp $ (BRL)";
d501 1
a501 1
	    exit( 2 );
d1378 1
a1378 1
	exit( 1 );
d1384 1
a1384 1
	exit(1);
d1414 1
a1414 1
	exit(1);
d1420 1
a1420 1
	exit(1);
d1435 1
a1435 1
    exit(0);
@


14.17
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.16 2007/05/12 22:23:04 brlcad Exp $ (BRL)";
d82 3
a87 6
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
#include <ctype.h>
@


14.16
log
@use new bu_process_id() function to get the pid now
@
text
@a71 5
 *  Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
d74 1
a74 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.15 2007/05/12 05:59:09 brlcad Exp $ (BRL)";
@


14.15
log
@maybe unnecessary as there's much more needed to deal with all the rest of the signal code, but go ahead and wrap getting the right pid
@
text
@d79 1
a79 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.14 2007/05/12 05:53:56 brlcad Exp $ (BRL)";
d1342 1
a1342 5
#ifdef HAVE_UNISTD_H
    pid = getpid();
#else
    pid = (int)GetCurrentProcessId();
#endif
@


14.14
log
@ws and massive reorder so forward declarations aren't necessary
@
text
@d79 1
a79 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.13 2007/01/27 01:41:34 brlcad Exp $ (BRL)";
d1342 12
a1353 2
    if ( (pid = getpid()) > 1 )
	(void)kill( pid, sig ); /* resignal process */
@


14.13
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d79 1
a79 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.12 2007/01/23 01:13:32 brlcad Exp $ (BRL)";
d103 1
a103 1
	Raster device model and image terminology as used herein:
d105 2
a106 2
Frames are delimited in plot data by "erase" codes; each frame looks
like:
d109 22
a130 22
			    top of frame
	---------------------------------------------------------
	|			.				|
	|scan line ->...........................................|
 ^	|			.				|
 |	|			^				|
	|			|				|
	|Y axis							|
	|plot							|
 ^	|^							|
 |	||							|
	||	X axis						|
	|-----> plot						|
	---------------------------------------------------------
			    bottom of frame


Each plot-mode scan line consists of exactly BYTES bytes of plot data.

Each scan line is composed of bytes of color data, for the Red,
Green, and Blue for each pixel, times the number of pixels desired
(512 in LORES, 1024 in HIRES)
a143 1

d150 14
d179 2
a180 2
	short		x;
	short		y;
d184 6
a189 6
	long		magic;
	struct descr	*next;		/* next in list, or NULL */
	coords		pixel;		/* starting scan, nib */
	tiny		xsign;		/* 0 or +1 */
	tiny		ysign;		/* -1, 0, or +1 */
	bool		ymajor; 	/* true iff Y is major dir. */
d192 6
a197 6
	short		major;		/* major dir delta (nonneg) */
	short		minor;		/* minor dir delta (nonneg) */
	short		e;		/* DDA error accumulator */
	short		de;		/* increment for `e' */
	RGBpixel	col;		/* COLOR of this vector */
	struct descr	*freep;		/* next in free list, or NULL */
d216 4
a219 4
	double		left;		/* window edges */
	double		bottom;
	double		right;
	double		top;
d225 1
a225 1
	short	x,y;			/* x, y values (255,255 is end) */
d236 2
a237 2
	char		ascii;		/* ASCII character emulated */
	struct	relvect	r[10];		/* maximum # of vectors 1 char */
d239 48
a286 48
/*ASCII <1>    <2>    <3>    <4>    <5>    <6>    <7>    <8>    <9>    <10> */
   {'0', {{5,0},   {1,0},   {0,1},   {0,7},   {6,1},   {6,7},   {5,8},   {1,8},   {END},   {NIL}}},
   {'1', {{1,2},   {3,0},   {3,8},   {5,8},   {1,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'2', {{0,1},   {1,0},   {5,0},   {6,1},   {6,2},   {4,4},   {2,4},   {0,6},   {0,8},   {6,8}}},
   {'3', {{1,0},   {5,0},   {6,1},   {6,4},   {2,4},   {6,4},   {6,7},   {5,8},   {1,8},   {END}}},
   {'4', {{5,8},   {5,0},   {0,5},   {0,6},   {6,6},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'5', {{6,0},   {0,0},   {0,3},   {4,3},   {6,5},   {6,6},   {4,8},   {1,8},   {0,7},   {END}}},
   {'6', {{5,0},   {2,0},   {0,2},   {0,7},   {1,8},   {5,8},   {6,7},   {6,5},   {5,4},   {1,4}}},
   {'7', {{0,1},   {0,0},   {6,0},   {6,1},   {2,5},   {2,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'8', {{1,0},   {5,0},   {6,1},   {6,7},   {5,8},   {1,8},   {0,7},   {0,1},   {0,4},   {6,4}}},
   {'9', {{1,8},   {4,8},   {6,6},   {6,1},   {5,0},   {1,0},   {0,1},   {0,3},   {1,4},   {6,4}}},
   {'A', {{0,8},   {0,2},   {2,0},   {4,0},   {6,2},   {6,8},   {6,5},   {0,5},   {END},   {NIL}}},
   {'B', {{6,5},   {6,7},   {5,8},   {0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4}}},
   {'C', {{6,1},   {5,0},   {2,0},   {0,2},   {0,6},   {2,8},   {5,8},   {6,7},   {END},   {NIL}}},
   {'D', {{0,0},   {4,0},   {6,2},   {6,6},   {4,8},   {0,8},   {0,0},   {END},   {NIL},   {NIL}}},
   {'E', {{6,0},   {0,0},   {0,4},   {3,4},   {0,4},   {0,8},   {6,8},   {END},   {NIL},   {NIL}}},
   {'F', {{6,0},   {0,0},   {0,4},   {3,4},   {0,4},   {0,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'G', {{6,1},   {5,0},   {2,0},   {0,2},   {0,6},   {2,8},   {5,8},   {6,7},   {6,5},   {3,5}}},
   {'H', {{0,0},   {0,8},   {0,4},   {6,4},   {6,0},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'I', {{1,0},   {5,0},   {3,0},   {3,8},   {1,8},   {5,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'J', {{2,0},   {6,0},   {4,0},   {4,7},   {3,8},   {1,8},   {0,7},   {END},   {NIL},   {NIL}}},
   {'K', {{0,0},   {0,8},   {0,6},   {6,0},   {2,4},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'L', {{0,0},   {0,8},   {6,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'M', {{0,8},   {0,0},   {3,3},   {3,4},   {3,3},   {6,0},   {6,8},   {END},   {NIL},   {NIL}}},
   {'N', {{0,8},   {0,0},   {6,6},   {6,8},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'O', {{0,6},   {0,2},   {2,0},   {4,0},   {6,2},   {6,6},   {4,8},   {2,8},   {0,6},   {END}}},
   {'P', {{0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4},   {END},   {NIL},   {NIL}}},
   {'Q', {{6,6},   {6,2},   {4,0},   {2,0},   {0,2},   {0,6},   {2,8},   {4,8},   {4,6},   {6,8}}},
   {'R', {{0,8},   {0,0},   {5,0},   {6,1},   {6,3},   {5,4},   {0,4},   {2,4},   {6,8},   {END}}},
   {'S', {{6,1},   {5,0},   {1,0},   {0,1},   {0,4},   {5,4},   {6,5},   {6,7},   {5,8},   {0,8}}},
   {'T', {{0,0},   {6,0},   {3,0},   {3,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'U', {{0,0},   {0,7},   {1,8},   {5,8},   {6,7},   {6,0},   {END},   {NIL},   {NIL},   {NIL}}},
   {'V', {{0,0},   {0,2},   {3,8},   {6,2},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'W', {{0,0},   {0,8},   {3,5},   {3,4},   {3,5},   {6,8},   {6,0},   {END},   {NIL},   {NIL}}},
   {'X', {{0,0},   {6,8},   {3,4},   {0,8},   {6,0},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'Y', {{0,0},   {0,1},   {3,4},   {3,8},   {3,4},   {6,1},   {6,0},   {END},   {NIL},   {NIL}}},
   {'Z', {{0,0},   {6,0},   {6,1},   {0,7},   {0,8},   {6,8},   {END},   {NIL},   {NIL},   {NIL}}},
   {'+', {{0,4},   {6,4},   {3,4},   {3,1},   {3,7},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'-', {{0,4},   {6,4},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'/', {{0,7},   {6,1},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'(', {{4,0},   {2,2},   {2,6},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {')', {{2,0},   {4,2},   {4,6},   {2,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'<', {{4,0},   {0,4},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {'>', {{2,0},   {6,4},   {2,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL},   {NIL}}},

/* Some needed chars, hastily drawn -MJM */
   {'.', {{4,7},   {3,7},   {3,6},   {4,6},   {4,7},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
   {',', {{4,6},   {3,6},   {3,5},   {4,5},   {4,8},   {END},   {NIL},   {NIL},   {NIL},   {NIL}}},
d288 1
a288 1
   {'\0'}
d297 2
a298 2
	stroke	*first;
	stroke	*last;
d313 7
a319 10
static int	sigs[] =		/* signals to be caught */
	{
	SIGHUP,
	SIGINT,
	SIGQUIT,
	SIGTERM
	};


/*	Externals:	*/
a321 1

a323 14
/*	Local subroutines:	*/

static int	DoFile(void), Foo(int code);
static stroke	*Dequeue(register struct band *bp, register stroke **hp);
static bool	BuildStr(coords *pt1, coords *pt2), GetCoords(register coords *coop),
		OutBuild(void);
static void	Catch(register int sig), FreeUp(void), InitDesc(void), Requeue(register struct band *bp, register stroke *vp),
		Raster(register stroke *vp, register struct band *np), SetSigs(void);

void		edgelimit(register coords *ppos), put_vector_char(register char c, register coords *pos);

bool	Get3Coords(register coords *coop);
bool	Get3DCoords(register coords *coop);
bool	GetDCoords(register coords *coop);
d335 159
d498 9
a506 6
	register stroke	*sp;
	register char	*cp;
	register int	bytes;

	/* ~32 strokes/KB */
	bytes = 640 * sizeof(stroke);
d508 2
a509 14
		/* Attempt to draw/free some vectors and try again */
		OutBuild();
		if( (cp = malloc(bytes)) == (char *)0 ) {
			fprintf(stderr,"pl-fb: malloc failed!\n");
			exit( 2 );
		}
	}
	/* link them all into the free list */
	sp = (stroke *)cp;
	while( bytes >= sizeof(stroke) ) {
		sp->freep = freep;
		sp->magic = STROKE_MAGIC;
		freep = sp++;
		bytes -= sizeof(stroke);
d511 9
a521 11
#define GET_STROKE(vp)    { \
			while( ((vp)=freep) == STROKE_NULL ) \
				get_strokes(); \
			freep = (vp)->freep; \
			CK_STROKE(vp); \
			(vp)->freep = STROKE_NULL; }

#define FREE_STROKE(vp)  { \
			CK_STROKE(vp); \
			(vp)->freep = freep; \
			freep = (vp); }
d533 5
a537 5
	register long w;
	if( v <= 0x7FFF )  return(v);
	w = -1;
	w &= ~0x7FFF;
	return( w | v );
d543 1
a543 1
	register int c;
d545 54
a598 39
	while( (c = bu_getopt( argc, argv, "hdoOit:F:s:S:w:W:n:N:" )) != EOF ) {
		switch( c ) {
		case 't':
			line_thickness = atoi(bu_optarg);
			if( line_thickness <= 0 )
				line_thickness = 1;
			break;
		case 'i':
			immediate = 1;
			break;
		case 'd':
			/* -d given multiple times increases debug level */
			debug++;
			break;
		case 'O':
		case 'o':
			over = 1;
			break;
		case 'F':
			framebuffer = bu_optarg;
			break;
		case 'h':
			Nscanlines = Npixels = 1024;
			break;
		case 'S':
		case 's':
			Nscanlines = Npixels = atoi(bu_optarg);
			break;
		case 'W':
		case 'w':
			Npixels = atoi(bu_optarg);
			break;
		case 'N':
		case 'n':
			Nscanlines = atoi(bu_optarg);
			break;
		default:		/* '?' */
			return(0);
		}
d600 1
d602 2
a603 15
	if( bu_optind >= argc ) {
		/* no file name given, use stdin */
		if( isatty(fileno(stdin)) )
			return(0);
		filename = "-";
		pfin = stdin;
	} else {
		/* open file */
		filename = argv[bu_optind];
		if( (pfin = fopen(filename, "r")) == NULL ) {
			fprintf( stderr,
			   "pl-fb: Can't open file \"%s\"\n", filename );
			return(0);
		}
	}
d605 1
a605 4
	if( argc > ++bu_optind )
		(void)fprintf( stderr, "pl-fb: excess argument(s) ignored\n" );

	return(1);		/* OK */
d612 16
d629 31
a659 1
 *  M A I N
d661 30
a690 3
 *	Parse arguments, valid ones are:
 *		name of file to plot (instead of STDIN)
 *		-d for debugging statements
d692 6
a697 1
 *	Default (no arguments) action is to plot STDIN on current FB.
d699 3
a701 2
int
main(int argc, char **argv)
d703 2
a704 1
	Nscanlines = Npixels = 512;
d706 25
a730 3
	if ( !get_args( argc, argv ) )  {
		(void)fputs(usage, stderr);
		exit( 1 );
d733 147
a879 16
	/* Open frame buffer, adapt to slightly smaller ones */
	if( (fbp = fb_open(framebuffer, Npixels, Nscanlines)) == FBIO_NULL ) {
		fprintf(stderr,"pl-fb: fb_open failed\n");
		exit(1);
	}
	Npixels = fb_getwidth(fbp);
	Nscanlines = fb_getheight(fbp);
	if( immediate )  {
		lines_per_band = Nscanlines;
		if( !over )
			fb_clear( fbp, RGBPIXEL_NULL );
	} else if( Nscanlines <= 512 ) {
		/* make one full size band */
		lines_per_band = Nscanlines;
		single_banded = 1;
	}
a880 33
	/*
	 * Handle image-size specific initializations
	 */
	if( (Nscanlines % lines_per_band) != 0 )  {
		/* round it down - only necessary if buffered? */
		Nscanlines = (Nscanlines / lines_per_band) * lines_per_band;
	}
	space.left = space.right = 0;
	space.right = Npixels;
	space.top = Nscanlines;
	delta = Nscanlines;
	deltao2 = Nscanlines/2;

	buffersize = lines_per_band*Npixels*sizeof(RGBpixel);
	if( (buffer = (unsigned char *)malloc(buffersize)) == RGBPIXEL_NULL)  {
		fprintf(stderr,"pl-fb:  malloc error\n");
		exit(1);
	}
	/* Extra band protects against requeueing off the top */
	band = (struct band *)malloc((BANDSLOP)*sizeof(struct band));
	if( band == (struct band *)0 )  {
		fprintf(stderr,"pl-fb: malloc error2\n");
		exit(1);
	}
	bzero( (char *)band, (BANDSLOP)*sizeof(struct band) );
	bandEnd = &band[BANDS];
	if( single_banded && over ) {
		/* Read in initial screen */
		if( fb_read( fbp, 0, 0, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
			fprintf(stderr,"pl-fb: band read error\n");
	}
	if( debug )
		fprintf(stderr, "pl-fb output of %s\n", filename);
d882 10
a891 1
	SetSigs();			/* set signal catchers */
d893 2
a894 2
	(void)DoFile( );	/* plot it */
	exit(0);
d899 40
a938 1
	DoFile - process UNIX plot file
a939 3
	This routine reads UNIX plot records from the specified file
	and controls the entry of the strokes into the descriptor lists.
	Strokes are limited (not clipped) to fit the frame.
d941 12
a952 5
	Upon end of file, erase, or flush, plot data is copied to the device.
	Returns status code:
		   < 0	=> catastrophe
		   = 0	=> complete success
		   > 0	=> line limit hit
d957 7
a963 7
	register bool	plotted;	/* false => empty frame image */
	register int	c;		/* input character */
	static coords	newpos; 	/* current input coordinates */
	static coords	virpos; 	/* virtual pen position */
	static unsigned char buf3[6*2];
	static unsigned char buf2[4*2];
	static	bool	firsterase = true;
d965 1
a965 1
	/* process each frame into a raster image file */
d967 1
a967 1
	for ( ; ; )			/* for each frame */
d969 1
a969 1
		InitDesc();		/* empty descriptor lists */
d971 2
a972 2
		virpos.x = virpos.y = 0;
		plotted = false;
d974 1
a974 1
		for ( ; ; )		/* read until EOF*/
d976 3
a978 3
			c = getc( pfin );
			if( debug > 1 )  fprintf(stderr,"%c\n", c);
			switch ( c )
d980 1
a980 1
			case EOF:
d984 4
a987 4
					/* flush strokes */
					if( debug ) fprintf( stderr,"flushing\n");
					if ( !OutBuild() )
						return Foo( -6 );
d991 1
a991 1
			case 'e':	/* erase */
d995 4
a998 4
					/* flush strokes */
					if( debug ) fprintf( stderr,"flushing\n");
					if ( !OutBuild() )
						return Foo( -6 );
d1001 3
a1003 3
					if( immediate )
						fb_clear( fbp, RGBPIXEL_NULL );
					over = 0;
d1008 1
a1008 1
			case 'F':	/* flush */
d1012 6
a1017 6
					/* flush strokes */
					if( debug ) fprintf( stderr,"flushing\n");
					if ( !OutBuild() )
						return Foo( -6 );
					if( !immediate )
						over = 1;
d1022 1
a1022 1
			case 'f':	/* linemod */
d1024 1
a1024 1
					fprintf( stderr,"linemod\n");
d1027 3
a1029 3
				     && c != '\n'
				      )
					;	/* eat string */
d1032 2
a1033 2
			case 'L':
			case 'M':
d1035 1
a1035 1
					return Foo( -8 );
d1038 3
a1040 3
					if( debug )
						fprintf( stderr,"Move3\n");
					continue;
d1043 1
a1043 1
					fprintf( stderr,"Line3\n");
d1045 2
a1046 2
			case 'N':	/* continue3 */
			case 'P':	/* point3 */
d1048 1
a1048 1
					return Foo( -9 );
d1050 3
a1052 3
					if( debug )
						fprintf( stderr,"point3\n");
					virpos = newpos;
d1054 2
a1055 2
					if( debug )
						fprintf( stderr,"cont3\n");
d1058 1
a1058 1
					return Foo( -10 );
d1063 2
a1064 2
			case 'l':	/* line */
			case 'm':	/* move */
d1066 1
a1066 1
					return Foo( -8 );
d1069 3
a1071 3
					if( debug )
						fprintf( stderr,"move\n");
					continue;
d1075 1
a1075 1
					fprintf( stderr,"line\n");
d1077 2
a1078 2
			case 'n':	/* cont */
			case 'p':	/* point */
d1080 1
a1080 1
					return Foo( -9 );
d1082 3
a1084 3
					if( debug )
						fprintf( stderr,"point\n");
					virpos = newpos;
d1086 2
a1087 2
					if( debug )
						fprintf( stderr,"cont\n");
d1090 1
a1090 1
					return Foo( -10 );
d1095 3
a1097 3
			/* IEEE */
			case 'V':
			case 'O':
d1099 1
a1099 1
					return Foo( -8 );
d1102 3
a1104 3
					if( debug )
						fprintf( stderr,"dMove3\n");
					continue;
d1107 1
a1107 1
					fprintf( stderr,"dLine3\n");
d1109 2
a1110 2
			case 'Q':	/* continue3 */
			case 'X':	/* point3 */
d1112 1
a1112 1
					return Foo( -9 );
d1114 3
a1116 3
					if( debug )
						fprintf( stderr,"dpoint3\n");
					virpos = newpos;
d1118 2
a1119 2
					if( debug )
						fprintf( stderr,"dcont3\n");
d1122 1
a1122 1
					return Foo( -10 );
d1127 2
a1128 2
			case 'v':	/* line */
			case 'o':	/* move */
d1130 1
a1130 1
					return Foo( -8 );
d1133 3
a1135 3
					if( debug )
						fprintf( stderr,"dmove\n");
					continue;
d1139 1
a1139 1
					fprintf( stderr,"dline\n");
d1141 2
a1142 2
			case 'q':	/* cont */
			case 'x':	/* point */
d1144 1
a1144 1
					return Foo( -9 );
d1146 3
a1148 3
					if( debug )
						fprintf( stderr,"dpoint\n");
					virpos = newpos;
d1150 2
a1151 2
					if( debug )
						fprintf( stderr,"dcont\n");
d1154 1
a1154 1
					return Foo( -10 );
d1159 1
a1159 1
			case 'W':
d1161 3
a1163 3
				unsigned char	in[6*8];
				double	out[6];
				if( debug )
d1165 1
a1165 1
				if( fread( in, sizeof(in), 1, pfin) != 1 )
d1167 9
a1175 9
				ntohd( (unsigned char *)out, in, 5 );
				/* Only need X and Y, ignore Z */
				space.left  = out[0]; /* x1 */
				space.bottom= out[1]; /* y1 */
				/* z1 */
				space.right = out[3]; /* x2 */
				space.top   = out[4]; /* y2 */
				/* z2 */
				goto spacend;
d1178 1
a1178 1
			case 'w':	/* space */
d1180 3
a1182 3
				unsigned char	in[4*8];
				double	out[4];
				if( debug )
d1184 1
a1184 1
				if( fread( in, sizeof(in), 1, pfin) != 1 )
d1186 6
a1191 6
				ntohd( (unsigned char *)out, in, 4 );
				space.left  = out[0]; /* x1 */
				space.bottom= out[1]; /* y1 */
				space.right = out[2]; /* x2 */
				space.top   = out[3]; /* y2 */
				goto spacend;
d1194 1
a1194 1
			case 'S':
d1196 1
a1196 1
				if( debug )
d1198 4
a1201 4
				if( fread( (char *)buf3,
					   (int)sizeof buf3, 1, pfin)
					   != 1
				  )
d1203 8
a1210 8
				/* Only need X and Y, ignore Z */
				space.left  = sxt16((long)(buf3[1]<<8) | buf3[0]); /* x1 */
				space.bottom= sxt16((long)(buf3[3]<<8) | buf3[2]); /* y1 */
				/* z1 */
				space.right = sxt16((long)(buf3[7]<<8) | buf3[6]); /* x2 */
				space.top   = sxt16((long)(buf3[9]<<8) | buf3[8]); /* y2 */
				/* z2 */
				goto spacend;
d1213 1
a1213 1
			case 's':	/* space */
d1215 1
a1215 1
					fprintf( stderr,"space\n");
d1217 4
a1220 4
				if ( fread( (char *)buf2,
					    (int)sizeof buf2, 1, pfin
					  ) != 1
				   )
d1222 4
a1225 4
				space.left  = sxt16((long)(buf2[1]<<8) | buf2[0]); /* x1 */
				space.bottom= sxt16((long)(buf2[3]<<8) | buf2[2]); /* y1 */
				space.right = sxt16((long)(buf2[5]<<8) | buf2[4]); /* x2 */
				space.top   = sxt16((long)(buf2[7]<<8) | buf2[6]); /* y2 */
d1228 1
a1228 1
spacend:
d1232 1
a1232 1
					delta = deltao2;
d1234 2
a1235 2
					fprintf( stderr, "pl-fb: delta = %g, bad space()\n", delta );
					return Foo( -42 );
d1239 4
a1242 4
					fprintf( stderr,"Space: X=(%g,%g) Y=(%g,%g) delta=%g\n",
						space.left, space.right,
						space.bottom, space.top,
						delta );
d1245 1
a1245 1
			case 'C':	/* color */
d1247 1
a1247 1
					return Foo( -11 );
d1249 4
a1252 4
					fprintf( stderr,"Color is R%d G%d B%d\n",
						cur_color[RED],
						cur_color[GRN],
						cur_color[BLU]);
d1255 1
a1255 1
			case 't':	/* label */
d1257 1
a1257 1
					fprintf( stderr,"label: ");
d1261 7
a1267 7
				      )  {
					/* vectorize the characters */
					put_vector_char( c, &newpos);

					if( debug )
						putc( c, stderr );
				      }
d1273 2
a1274 2
			/* discard the deadwood */
			case 'c':
d1276 2
a1277 2
				char buf[3*2];
				if( fread(buf, sizeof(buf), 1, pfin) != 1 )
d1279 1
a1279 1
				if( debug )
d1281 1
a1281 1
				continue;
d1283 1
a1283 1
			case 'i':
d1285 2
a1286 2
				char buf[3*8];
				if( fread(buf, sizeof(buf), 1, pfin) != 1 )
d1288 1
a1288 1
				if( debug )
d1290 1
a1290 1
				continue;
d1292 1
a1292 1
			case 'a':
d1294 2
a1295 2
				char buf[6*2];
				if( fread(buf, sizeof(buf), 1, pfin) != 1 )
d1297 1
a1297 1
				if( debug )
d1299 1
a1299 1
				continue;
d1301 1
a1301 1
			case 'r':
d1303 2
a1304 2
				char buf[6*8];
				if( fread(buf, sizeof(buf), 1, pfin) != 1 )
d1306 1
a1306 1
				if( debug )
d1308 1
a1308 1
				continue;
d1311 1
a1311 1
			default:
d1316 1
a1316 1
			break;
a1320 182
/*
 *	PutVectorChar - Put vectors corresponding to this character out
 * 	into plotting space
 *	Update position to reflect character width.
 */
void
put_vector_char(register char c, register coords *pos)
{
	static coords	start, end;
	register struct vectorchar	*vc;
	register struct relvect		*rv;

	if( !isascii(c) )
		c = '?';
	if( islower(c) )
		c = toupper(c);

	for( vc = &charset[0]; vc->ascii; vc++)
		if( vc->ascii == c )
			break;

	if( !vc->ascii )  {
		/* Character not found in table -- space over 1/2 char */
		pos->x += X_CHAR_SIZE/2;
		return;
	}

	/* have the correct character entry - start plotting */
	start.x = vc->r[0].x + pos->x;
	start.y = Y_CHAR_SIZE - vc->r[0].y + pos->y;

	for( rv = &vc->r[1]; (rv < &vc->r[10]) && rv->x >= 0; rv++ )  {
		end.x = rv->x + pos->x;
		end.y = Y_CHAR_SIZE - rv->y + pos->y;
		edgelimit( &start );
		edgelimit( &end );
		BuildStr( &start, &end );	/* pixels */
		start = end;
	}
	pos->x += X_CHAR_SIZE;
}

/*
 *	E D G E L I M I T
 *
 *	Limit generated positions to edges of screen
 */
void
edgelimit(register coords *ppos)
{
	if( ppos->x >= Npixels )
		ppos->x = Npixels -1;

	if( ppos->y >= Nscanlines )
		ppos->y = Nscanlines -1;
}

/*
	GetCoords - input x,y coordinates and scale into pixels
*/
bool Get3Coords(register coords *coop)
{
	char	trash[2];
	register bool	ret;

	ret = GetCoords( coop );
	fread( trash, sizeof(trash), 1, pfin );
	return( ret );
}

static bool
GetCoords(register coords *coop)
				/* -> input coordinates */
{
	unsigned char buf[4];
	double	x, y;

	/* read coordinates */
	if ( fread( (char *)buf, (int)sizeof (buf), 1, pfin ) != 1 )
		return false;


	x = sxt16((long)(buf[1]<<8) | buf[0]);
	y = sxt16((long)(buf[3]<<8) | buf[2]);
	if( debug )  fprintf(stderr,"Coord: (%g,%g) ", x, y);

	/* limit left, bottom */
	if ( (x -= space.left) < 0 )
		x = 0;
	if ( (y -= space.bottom) < 0 )
		y = 0;

	/* convert to device pixels */
	coop->x = (short)(x * Npixels / (double)delta + 0.5);
	coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

	/* limit right, top */
	if ( coop->x > XMAX )
		coop->x = XMAX;
	if ( coop->y > YMAX )
		coop->y = YMAX;

	if( debug )
		fprintf( stderr,"Pixel: (%d,%d)\n", coop->x, coop->y);

	return true;
}

/* IEEE coordinates */
bool Get3DCoords(register coords *coop)
{
	static unsigned char in[3*8];
	static double	out[2];
	register double	x,y;

	/* read coordinates */
	if ( fread( in, sizeof(in), 1, pfin ) != 1 )
		return false;
	ntohd( (unsigned char *)out, in, 2 );
	x = out[0];
	y = out[1];

	/* limit left, bottom */
	if ( (x -= space.left) < 0 )
		x = 0;
	if ( (y -= space.bottom) < 0 )
		y = 0;

	/* convert to device pixels */
	coop->x = (short)(x * Npixels / (double)delta + 0.5);
	coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

	/* limit right, top */
	if ( coop->x > XMAX )
		coop->x = XMAX;
	if ( coop->y > YMAX )
		coop->y = YMAX;

	if( debug )  {
		fprintf(stderr,"Coord3: (%g,%g) ", out[0], out[1]);
		fprintf(stderr,"Pixel3: (%d,%d)\n", coop->x, coop->y);
	}
	return( true );
}

bool
GetDCoords(register coords *coop)
				/* -> input coordinates */
{
	static unsigned char	in[2*8];
	static double	out[2];
	register double	x,y;

	/* read coordinates */
	if ( fread( in, sizeof(in), 1, pfin ) != 1 )
		return false;
	ntohd( (unsigned char *)out, in, 2 );
	x = out[0];
	y = out[1];

	/* limit left, bottom */
	if ( (x -= space.left) < 0 )
		x = 0;
	if ( (y -= space.bottom) < 0 )
		y = 0;

	/* convert to device pixels */
	coop->x = (short)(x * Npixels / (double)delta + 0.5);
	coop->y = (short)(y * Nscanlines / (double)delta + 0.5);

	/* limit right, top */
	if ( coop->x > XMAX )
		coop->x = XMAX;
	if ( coop->y > YMAX )
		coop->y = YMAX;

	if( debug )  {
		fprintf(stderr,"Coord2: (%g,%g) ", out[0], out[1]);
		fprintf(stderr,"Pixel2: (%d,%d)\n", coop->x, coop->y);
	}
	return true;
}
d1323 1
a1323 1
	InitDesc - initialize stroke descriptor lists
a1324 1

d1326 2
a1327 1
InitDesc(void)
d1329 2
a1330 32
	register struct band *bp;	/* *bp -> start of descr list */

	for ( bp = &band[0]; bp < &band[BANDSLOP]; ++bp )  {
		bp->first = NULL;		/* nothing in band yet */
		bp->last  = NULL;
	}
}


/*
 * 	Requeue - enqueue descriptor at END of band list
 */
static void
Requeue(register struct band *bp, register stroke *vp)
{
	CK_STROKE(vp);
	vp->next = NULL;
	if( bp->last )
		bp->last->next = vp;
	else
		bp->first = vp;

	bp->last = vp;
}

/*
 *	Dequeue - remove descriptor from band list (do not free space)
 *
 *  Returns addr of descriptor, or NULL if none left.
 */
static stroke *
Dequeue(register struct band *bp, register stroke **hp)
d1332 5
a1336 3
				/* *hp -> first descr in list */
{
	register stroke *vp;		/* -> descriptor */
d1338 1
a1338 2
	if ( (vp = *hp) != NULL )
		*hp = vp->next; 	/* -> next element in list */
d1340 1
a1340 2
	if( vp == NULL )
		bp->last = NULL;
d1342 2
a1343 1
	return vp;			/* may be NULL */
d1348 1
a1348 1
	FreeUp - deallocate descriptors
a1349 1

d1351 1
a1351 17
FreeUp(void)
{
	register struct band *bp;
	register stroke *vp;		/* -> rasterization descr */

	for ( bp = &band[0]; bp < bandEnd; ++bp )
		while ( (vp = Dequeue( bp, &bp->first )) != NULL )
			FREE_STROKE(vp);	/* free storage */
	}

/*
 *			P R E P _ D D A
 *
 *  Set up multi-band DDA parameters for stroke
 */
static void
prep_dda(register stroke *vp, register coords *pt1, register coords *pt2)
d1353 1
a1353 17
	CK_STROKE(vp);
	vp->pixel = *pt1;		/* initial pixel */
	vp->major = pt2->y - vp->pixel.y;	/* always nonnegative */
	vp->ysign = vp->major ? 1 : 0;
	vp->minor = pt2->x - vp->pixel.x;
	COPYRGB( vp->col, cur_color );
	if ( (vp->xsign = vp->minor ? (vp->minor > 0 ? 1 : -1) : 0) < 0 )
		vp->minor = -vp->minor;

	/* if Y is not really major, correct the assignments */
	if ( !(vp->ymajor = vp->minor <= vp->major) )  {
		register short	temp;	/* temporary for swap */

		temp = vp->minor;
		vp->minor = vp->major;
		vp->major = temp;
	}
d1355 6
a1360 2
	vp->e = vp->major / 2 - vp->minor;	/* initial DDA error */
	vp->de = vp->major - vp->minor;
a1362 61
/*
 *	BuildStr - set up DDA parameters and queue stroke
 *
 *  Given two end points of a line, allocate and intialize a stroke
 *  descriptor for it.  If we are drawing "thick" lines we generate
 *  several extra stroke descriptors as well.  In immediate or memory
 *  buffered mode we rasterize it and free it right away.  In "regular"
 *  banded buffered mode, we link the descriptor(s) into its starting
 *  point band(s).
 */
static bool
BuildStr(coords *pt1, coords *pt2)		/* returns true or dies */
				/* endpoints */
{
	register stroke *vp;		/* -> rasterization descr */
	register int	thick;

	/* arrange for pt1 to have the smaller Y-coordinate: */
	if ( pt1->y > pt2->y )  {
		register coords *temp;	/* temporary for swap */

		temp = pt1;		/* swap pointers */
		pt1 = pt2;
		pt2 = temp;
	}

	GET_STROKE(vp);			/* alloc a descriptor */
	prep_dda( vp, pt1, pt2 );	/* prep it */

	/* Thicken by advancing alternating pixels in minor direction */
	thick = line_thickness - 1;	/* number of "extra" pixels */
	if( thick >= vp->major && vp->major > 0 )  thick = vp->major-1;
	for( ; thick >= 0; thick-- )  {
		register stroke *v2;

		if( thick == 0 ) {
			/* last pass, use vp */
			v2 = vp;
		} else {
			/* make a new one */
			GET_STROKE(v2);
			*v2 = *vp;
		}

		/* Advance minor only */
		if( vp->ymajor )
			v2->pixel.x += (vp->xsign!=0 ? vp->xsign : 1) *
				((thick&1)==0 ? (thick+1)/2 : (thick+1)/-2 );
		else
			v2->pixel.y += (vp->ysign!=0 ? vp->ysign : 1) *
				((thick&1)==0 ? (thick+1)/2 : (thick+1)/-2 );

		if( immediate || single_banded )  {
			ystart = 0;
			Raster( v2, (struct band *)0 );
		}  else
			/* link descriptor into band corresponding to starting scan */
			Requeue( &band[v2->pixel.y / lines_per_band], v2 );
	}
	return true;
}
d1365 1
a1365 58
 *	OutBuild - rasterize all strokes into raster frame image
 */
static bool
OutBuild(void)				/* returns true if successful */
{
	register struct band *hp;	/* *hp -> head of descr list */
	register struct band *np;	/* `hp' for next band */
	register stroke *vp;		/* -> rasterization descr */

	if( single_banded ) {
		if( debug ) fprintf(stderr,"OutBuild:  band y=%d\n", ystart);
		if( fb_write( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
			return false;	/* can't write image file */
		if( over )  {
			/* Read back the composite image */
			if( fb_read( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
				fprintf(stderr,"pl-fb:  band read error\n");
		}
		return true;
	}

	for ( hp = &band[0]; hp < bandEnd; ++hp )
		if ( hp->first != NULL )
			break;

	if ( hp == bandEnd )
		return true;		/* nothing to do */

	for ( hp = &band[0], np = &band[1], ystart = 0;
	      hp < bandEnd;
	      hp = np++, ystart += lines_per_band
	    )	{
		if(debug) fprintf(stderr,"OutBuild:  band y=%d\n", ystart);
		if( over )  {
			/* Read in current band */
			if( fb_read( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
				fprintf(stderr,"pl-fb:  band read error\n");
		} else {
			/* clear pixels in the band */
			bzero( (char *)buffer, buffersize );
		}

		while ( (vp = Dequeue( hp, &hp->first )) != NULL )
			Raster( vp, np );      /* rasterize stroke */

		/* Raster() either re-queued the descriptor onto the
		   next band list or else it freed the descriptor */

		if(debug) fprintf(stderr,"OutBuild:  fbwrite y=%d\n", ystart);
		if( fb_write( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
			return false;	/* can't write image file */
	}

	return true;			/* success */
}

/*
 *	Raster - rasterize stroke.
d1367 3
a1369 3
 *  If immediate mode, draw the individual pixel on the frame buffer.
 *  If banded buffered mode, draw the portion in this band.  If it
 *     overflows into next band, requeue; else free the descriptor.
d1371 1
a1371 4
 *  Method:
 *	Modified Bresenham algorithm.  Guaranteed to mark a dot for
 *	a zero-length stroke.  Please do not try to "improve" this code
 *	as it is extremely hard to get all aspects just right.
d1373 2
a1374 4
static void
Raster(register stroke *vp, register struct band *np)
				/* -> rasterization descr */
				/* *np -> next band 1st descr */
d1376 1
a1376 1
	register short	dy;		/* raster within active band */
d1378 55
a1432 1
	CK_STROKE(vp);
d1434 1
a1434 34
	/*
	 *  Draw the portion within this band.
	 */
	for ( dy = vp->pixel.y - ystart; dy < lines_per_band; ) {

		/* set the appropriate pixel in the buffer */
		if( immediate )  {
			fb_write( fbp, vp->pixel.x, dy, vp->col, 1 );
		}  else  {
			register unsigned char *pp;

			pp = (unsigned char *)&buffer[((dy*Npixels) + vp->pixel.x)*sizeof(RGBpixel)];
			COPYRGB( pp, vp->col );
		}

		if ( vp->major-- == 0 ) { /* done! */
			FREE_STROKE( vp );	/* return to "malloc" */
			return;
		}

		if ( vp->e < 0 ) {
			/* advance major & minor */
			dy += vp->ysign;
			vp->pixel.x += vp->xsign;
			vp->e += vp->de;
		} else {
			/* advance major only */
			if ( vp->ymajor )	/* Y is major dir */
				++dy;
			else			/* X is major dir */
				vp->pixel.x += vp->xsign;
			vp->e -= vp->minor;
		}
	}
d1436 2
a1437 3
	/* overflow into next band; re-queue */
	vp->pixel.y = ystart + lines_per_band;
	Requeue( np, vp );       /* DDA parameters already set */
a1439 57
/*
	Foo - clean up before return from rasterizer
*/

static int
Foo(int code)				/* returns status code */
					/* status code */
	{
	if( debug ) fprintf(stderr,"Foo(%d)\n", code);
	fb_close( fbp );		/* release framebuffer */

	FreeUp();			/* deallocate descriptors */

	return code;
	}

/*
	SetSigs - set up signal catchers
*/
static void
SetSigs(void)
{
	register int	*psig;		/* -> sigs[.] */

	for ( psig = &sigs[0];
	      psig < &sigs[sizeof sigs / sizeof sigs[0]];
	      ++psig
	    )
		if ( signal( *psig, SIG_IGN ) != SIG_IGN )
			(void)signal( *psig, Catch );
	}


/*
	Catch - invoked on interrupt
*/

static void
Catch(register int sig)
					/* signal number */
	{
	register int	pid;		/* this process's ID */
	register int	*psig;		/* -> sigs[.] */

	for ( psig = &sigs[0];
	      psig < &sigs[sizeof sigs / sizeof sigs[0]];
	      ++psig
	    )
		(void)signal( *psig, SIG_IGN );

	(void)Foo( -13 );		/* clean up */

	(void)signal( sig, SIG_DFL );

	if ( (pid = getpid()) > 1 )
		(void)kill( pid, sig ); /* resignal process */
	}
@


14.12
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d79 1
a79 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.11 2007/01/20 14:36:49 brlcad Exp $ (BRL)";
d467 1
a467 1
        [-S squaresize] [-W width] [-N height] [file.plot]\n";
d532 4
a535 4
    		/* Read in initial screen */
	    	if( fb_read( fbp, 0, 0, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
    			fprintf(stderr,"pl-fb: band read error\n");
    	}
d771 1
a771 1
				  	return Foo( -11 );
d790 1
a790 1
				  	return Foo( -11 );
d807 1
a807 1
				  	return Foo( -11 );
d998 1
a998 1
               	      		/* -> input coordinates */
d1073 1
a1073 1
               	      		/* -> input coordinates */
d1149 1
a1149 1
                     		/* *hp -> first descr in list */
d1220 1
a1220 1
      	           		/* endpoints */
d1303 6
a1308 6
	    	if(debug) fprintf(stderr,"OutBuild:  band y=%d\n", ystart);
	    	if( over )  {
	    		/* Read in current band */
		    	if( fb_read( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
	    			fprintf(stderr,"pl-fb:  band read error\n");
	    	} else {
d1311 1
a1311 1
	    	}
d1319 2
a1320 2
	    	if(debug) fprintf(stderr,"OutBuild:  fbwrite y=%d\n", ystart);
	    	if( fb_write( fbp, 0, ystart, buffer, buffersize/sizeof(RGBpixel) ) <= 0 )
d1341 2
a1342 2
                    		/* -> rasterization descr */
                         	/* *np -> next band 1st descr */
d1394 1
a1394 1
	   	     			/* status code */
d1427 1
a1427 1
	            	    		/* signal number */
@


14.11
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d79 1
a79 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.10 2006/01/23 07:23:37 brlcad Exp $ (BRL)";
@


14.10
log
@STATIC to static
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2006 United States Government as represented by
d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.9 2006/01/23 05:02:01 brlcad Exp $ (BRL)";
@


14.9
log
@stdlib.h for malloc and friends, not using libbu management as there is failure recovery code
@
text
@d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.8 2006/01/18 06:46:15 brlcad Exp $ (BRL)";
d203 1
a203 1
STATIC struct {
d209 2
a210 2
STATIC double	delta;			/* larger window dimension */
STATIC double	deltao2;		/* delta / 2 */
d223 1
a223 1
STATIC struct vectorchar {
d279 4
a282 4
STATIC int	Nscanlines = 512;
STATIC int	Npixels = 512;
STATIC char	*framebuffer = NULL;
STATIC char	*filename = NULL;
d288 2
a289 2
STATIC struct band	*band;		/* array of descriptor lists */
STATIC struct band	*bandEnd;
d291 9
a299 9
STATIC unsigned char	*buffer;		/* ptr to active band buffer */
STATIC long	buffersize;		/* active band buffer bytes */
STATIC short	ystart = 0;		/* active band starting scan */
STATIC int	debug  = 0;
STATIC int	over = 0;		/* !0 to overlay on existing image */
STATIC int	immediate = 0;		/* !0 to plot immediately */
STATIC int	single_banded = 0;	/* !0 if one fullscreen band */
STATIC short	lines_per_band = 16;	/* scan lines per band */
STATIC short	line_thickness = 1;
d301 1
a301 1
STATIC int	sigs[] =		/* signals to be caught */
d312 1
a312 1
STATIC FILE	*pfin;		/* input file FIO block ptr */
d318 3
a320 3
STATIC int	DoFile(void), Foo(int code);
STATIC stroke	*Dequeue(register struct band *bp, register stroke **hp);
STATIC bool	BuildStr(coords *pt1, coords *pt2), GetCoords(register coords *coop),
d322 1
a322 1
STATIC void	Catch(register int sig), FreeUp(void), InitDesc(void), Requeue(register struct band *bp, register stroke *vp),
d339 1
a339 1
STATIC struct descr	*freep = STROKE_NULL;	/* head of free stroke list */
d342 1
a342 1
STATIC void
d560 1
a560 1
STATIC int
d997 1
a997 1
STATIC bool
d1114 1
a1114 1
STATIC void
d1129 1
a1129 1
STATIC void
d1147 1
a1147 1
STATIC stroke *
d1168 1
a1168 1
STATIC void
d1184 1
a1184 1
STATIC void
d1219 1
a1219 1
STATIC bool
d1274 1
a1274 1
STATIC bool
d1340 1
a1340 1
STATIC void
d1393 1
a1393 1
STATIC int
d1408 1
a1408 1
STATIC void
d1426 1
a1426 1
STATIC void
@


14.8
log
@update copyright to 2006
@
text
@d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.7 2005/10/23 04:44:30 brlcad Exp $ (BRL)";
d85 3
d89 1
a89 7
# include <unistd.h>
#endif

#if DEBUG
# define STATIC	/* nothing, for debugging */
#else
# define STATIC	static
a90 3

#include <signal.h>
#include <stdio.h>
d92 1
a92 1
#include <string.h>
d94 1
a94 1
#include <strings.h>
d97 1
@


14.7
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1986-2005 United States Government as represented by
d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.6 2005/09/21 19:00:27 brlcad Exp $ (BRL)";
@


14.6
log
@needs bu.h for bu_getopt
@
text
@d35 1
a35 1
 * 
d37 1
a37 1
 * 
d44 1
a44 1
 * 
d49 1
a49 1
 * 
d53 1
a53 1
 * 
d64 1
a64 1
 * 
d72 1
a72 1
 *  
d77 1
a77 1
 *  
d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.5 2005/09/21 17:17:18 brlcad Exp $ (BRL)";
d88 1
a88 1
                                                                                                                                                                            
d314 1
a314 1
 
d593 1
a593 1
					
d673 1
a673 1
			
d737 1
a737 1
			
d788 1
a788 1
				
d823 1
a823 1
				
d865 1
a865 1
						
d870 1
a870 1
				newpos = virpos;			
d875 1
a875 1
				
d924 1
a924 1
					
d948 1
a948 1
	
d1036 1
a1036 1
		
d1143 1
a1143 1
		
d1154 1
a1154 1
                         
d1164 1
a1164 1
		
@


14.5
log
@use bu_optarg, bu_optind and bu_getopt
@
text
@d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.4 2005/01/30 20:30:21 brlcad Exp $ (BRL)";
d104 1
@


14.4
log
@update copyright to 2005
@
text
@d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/pl-fb.c,v 14.3 2004/12/21 06:38:19 morrison Exp $ (BRL)";
d407 1
a407 1
	while( (c = getopt( argc, argv, "hdoOit:F:s:S:w:W:n:N:" )) != EOF ) {
d410 1
a410 1
			line_thickness = atoi(optarg);
d426 1
a426 1
			framebuffer = optarg;
d433 1
a433 1
			Nscanlines = Npixels = atoi(optarg);
d437 1
a437 1
			Npixels = atoi(optarg);
d441 1
a441 1
			Nscanlines = atoi(optarg);
d448 1
a448 1
	if( optind >= argc ) {
d456 1
a456 1
		filename = argv[optind];
d464 1
a464 1
	if( argc > ++optind )
@


14.4.6.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d35 1
a35 1
 *
d37 1
a37 1
 *
d44 1
a44 1
 *
d49 1
a49 1
 *
d53 1
a53 1
 *
d64 1
a64 1
 *
d72 1
a72 1
 *
d77 1
a77 1
 *
d80 1
a80 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d88 1
a88 1

a103 1
#include "bu.h"
d313 1
a313 1

d407 1
a407 1
	while( (c = bu_getopt( argc, argv, "hdoOit:F:s:S:w:W:n:N:" )) != EOF ) {
d410 1
a410 1
			line_thickness = atoi(bu_optarg);
d426 1
a426 1
			framebuffer = bu_optarg;
d433 1
a433 1
			Nscanlines = Npixels = atoi(bu_optarg);
d437 1
a437 1
			Npixels = atoi(bu_optarg);
d441 1
a441 1
			Nscanlines = atoi(bu_optarg);
d448 1
a448 1
	if( bu_optind >= argc ) {
d456 1
a456 1
		filename = argv[bu_optind];
d464 1
a464 1
	if( argc > ++bu_optind )
d592 1
a592 1

d672 1
a672 1

d736 1
a736 1

d787 1
a787 1

d822 1
a822 1

d864 1
a864 1

d869 1
a869 1
				newpos = virpos;
d874 1
a874 1

d923 1
a923 1

d947 1
a947 1

d1035 1
a1035 1

d1142 1
a1142 1

d1153 1
a1153 1

d1163 1
a1163 1

@


14.3
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2004 United States Government as represented by
d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/pl-fb.c,v 14.2 2004/12/18 06:09:12 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL license
@
text
@a77 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
d80 1
a80 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/pl-fb.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 22
a22 2
/*
 *			P L - F B . C
d83 1
a83 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/pl-fb.c,v 1.5 2004/09/03 23:30:56 morrison Exp $ (BRL)";
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/pl-fb.c,v 1.4 2004/08/02 23:01:47 morrison Exp $ (BRL)";
d1433 10
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/pl-fb.c,v 1.3 2004/06/09 17:56:22 erikg Exp $ (BRL)";
d80 1
a80 1
#ifdef USE_STRING_H
@


1.3
log
@fix missing header issues
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/pl-fb.c,v 1.2 2004/06/08 22:04:12 morrison Exp $ (BRL)";
d66 1
a66 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d70 4
a73 2


@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d63 1
a63 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/pl-fb.c,v 11.11 2004/05/10 15:30:42 erikg Exp $ (BRL)";
a87 1
#include "externs.h"
@

