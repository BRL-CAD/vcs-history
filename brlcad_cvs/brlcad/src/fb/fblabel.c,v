head	14.16;
access;
symbols
	rel-7-10-4:14.12
	STABLE:14.12.0.2
	stable-branch:14.4
	rel-7-10-2:14.12
	rel-7-10-0:14.12
	rel-7-8-4:14.9
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.5
	rel-7-6-branch:14.5.0.2
	rel-7-6-0:14.5
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.16
date	2007.12.16.15.59.37;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.11.21.20.49.07;	author erikgreenwald;	state Exp;
branches;
next	14.14;

14.14
date	2007.11.21.19.09.24;	author erikgreenwald;	state Exp;
branches;
next	14.13;

14.13
date	2007.09.15.16.23.06;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.27.01.41.34;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.27;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.36.48;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.09.21.19.00.27;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.09.21.17.17.18;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.08.21.13.51.43;	author brlcad;	state Exp;
branches
	14.5.2.1;
next	14.4;

14.4
date	2005.01.30.20.30.21;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.06.38.19;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.06.09.12;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.56;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.17.56.22;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.12;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.02;	author morrison;	state Exp;
branches;
next	;

14.5.2.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@convert all bzero calls to memset
@
text
@/*                       F B L A B E L . C
 * BRL-CAD
 *
 * Copyright (c) 1986-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file fblabel.c
 *
 *  Function -
 *	Draw a Label on a Frame buffer image.
 *
 *  Author -
 *	Paul Randal Stay
 *
 *  Source -
 * 	SECAD/VLD Computing Consortium, Bldg 394
 *	The U.S. Army Ballistic Research Laboratory
 * 	Aberdeen Proving Ground, Maryland 21005
 *
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "bu.h"
#include "fb.h"
#include "vfont-if.h"


#define FONTBUFSZ 200

static char	*framebuffer = NULL;
static char	*font1 = NULL;

FBIO		*fbp;

static char usage[] = "\
Usage: fblabel [-h -c -a] [-F framebuffer] [-C r/g/b]\n\
	[-S scr_squaresize] [-W scr_width] [-N scr_height]\n\
	[-f fontstring] xpos ypos textstring\n";

/* Variables controlling the font itself */

int		width = 0;	/* Size of current character.		*/
int		height = 0;

static int	filterbuf[FONTBUFSZ][FONTBUFSZ];

static int	scr_width = 0;		/* default input width */
static int	scr_height = 0;	/* default input height */
static int	clear = 0;

static RGBpixel	pixcolor;
static int	xpos;
static int	ypos;
static char	*textstring;
static int	debug;
static int	alias_off;

void	do_char(struct vfont *vfp, struct vfont_dispatch *vdp, int x, int y), do_line(register struct vfont *vfp, register char *line), squash(register int *buf0, register int *buf1, register int *buf2, register float *ret_buf, register int n), fill_buf(register int wid, register int *buf, register char *bitrow);

int
get_args(int argc, register char **argv)
{

	register int c;

	pixcolor[RED]  = 255;
	pixcolor[GRN]  = 255;
	pixcolor[BLU]  = 255;

	while ( (c = bu_getopt( argc, argv, "adhcF:f:r:g:b:C:s:S:w:W:n:N:" )) != EOF )  {
		switch( c )  {
		case 'a':
			alias_off = 1;
			break;
		case 'd':
			debug = 1;
			break;
		case 'h':
			/* high-res */
			scr_height = scr_width = 1024;
			break;
		case 's':
		case 'S':
			/* square size */
			scr_height = scr_width = atoi( bu_optarg );
			break;
		case 'w':
		case 'W':
			scr_width = atoi( bu_optarg );
			break;
		case 'n':
		case 'N':
			scr_height = atoi( bu_optarg );
			break;
		case 'c':
			clear = 1;
			break;
		case 'F':
			framebuffer = bu_optarg;
			break;
		case 'f':
			font1 = bu_optarg;
			break;
		case 'C':
			{
				register char *cp = bu_optarg;
				register unsigned char *conp
					= (unsigned char *)pixcolor;

				/* premature null => atoi gives zeros */
				for( c=0; c < 3; c++ )  {
					*conp++ = atoi(cp);
					while( *cp && *cp++ != '/' ) ;
				}
			}
			break;
		/* backword compatability */
		case 'r':
			pixcolor[RED] = atoi( bu_optarg );
			break;
		case 'g':
			pixcolor[GRN] = atoi( bu_optarg );
			break;
		case 'b':
			pixcolor[BLU] = atoi( bu_optarg );
			break;
		default:		/* '?' */
			return(0);
		}
	}

	if( bu_optind+3 > argc )
		return(0);
	xpos = atoi( argv[bu_optind++]);
	ypos = atoi( argv[bu_optind++]);
	textstring = argv[bu_optind++];
	if(debug) (void)fprintf(stderr,"fblabel %d %d %s\n", xpos, ypos, textstring);

	if ( argc > bu_optind )
		(void)fprintf( stderr, "fblabel: excess argument(s) ignored\n" );

	return(1);		/* OK */
}


int
main(int argc, char **argv)
{
	struct	vfont	*vfp;

	if ( !get_args( argc, argv ) ) {
		fputs( usage, stderr);
		bu_exit(1, NULL);
	}

	if( (fbp = fb_open( framebuffer, scr_width, scr_height )) == NULL )  {
		fprintf(stderr, "fblabel:  Unable to open framebuffer %s\n", framebuffer);
		bu_exit(12, NULL);
	}

	if( clear ) {
		fb_clear( fbp, PIXEL_NULL);
	}

	if( (vfp = vfont_get(font1)) == VFONT_NULL )  {
		fprintf(stderr, "fblabel:  Can't get font \"%s\"\n",
			font1 == NULL ? "(null)" : font1);
		bu_exit(1, NULL);
	}

	do_line( vfp, textstring );

	fb_close( fbp );
	bu_exit(0, NULL);
}

void
do_line(register struct vfont *vfp, register char *line)
{
	register int    currx;
	register int    char_count, char_id;
	register int	len = strlen( line );

	if( vfp == VFONT_NULL )  return;

	currx = xpos;

	for( char_count = 0; char_count < len; char_count++ )  {
		register struct vfont_dispatch	*vdp;

		char_id = (int) line[char_count] & 0377;

		/* Obtain the dimensions for the character */
		vdp = &vfp->vf_dispatch[char_id];
		width = vdp->vd_left + vdp->vd_right;
		height = vdp->vd_up + vdp->vd_down;
		if(debug) fprintf(stderr,"%c w=%2d h=%2d, currx=%d\n", char_id, width, height, currx);

		/*
		 *  Space characters are frequently not represented
		 *  in the font set, so leave white space here.
		 */
		if( width <= 1 )  {
			char_id = 'n';	/* 1-en space */
			vdp = &vfp->vf_dispatch[char_id];
			width = vdp->vd_left + vdp->vd_right;
			if( width <= 1 )  {
				char_id = 'N';	/* 1-en space */
				vdp = &vfp->vf_dispatch[char_id];
				width = vdp->vd_left + vdp->vd_right;
				if( width <= 1 )
					width = 16;	/* punt */
			}
			currx += width;
			continue;
		}

		if( currx + width > fb_getwidth(fbp) - 1 )  {
			fprintf(stderr,"fblabel:  Ran off screen\n");
			break;
		}

		do_char( vfp, vdp, currx, ypos );
		currx += vdp->vd_width + 2;
	 }
}

void
do_char(struct vfont *vfp, struct vfont_dispatch *vdp, int x, int y)
{
	register int    i, j;
	int		base;
	int     	totwid = width;
	int		ln;
	static float	resbuf[FONTBUFSZ];
	static RGBpixel	fbline[FONTBUFSZ];
	int		bytes_wide;	/* # bytes/row in bitmap */

	bytes_wide = (width+7)>>3;

	 /* Read in the character bit map, with two blank lines on each end. */
	 for (i = 0; i < 2; i++)
		memset((char *)&filterbuf[i][0], 0, (totwid+4)*sizeof(int));

	 for ( ln=0, i = height + 1; i >= 2; i--, ln++)
		 fill_buf (width, &filterbuf[i][0],
			&vfp->vf_bits[vdp->vd_addr + bytes_wide*ln] );

	 for (i = height + 2; i < height + 4; i++)
		memset((char *)&filterbuf[i][0], 0, (totwid+4)*sizeof(int));

	 /* Initial base line for filtering depends on odd flag. */
	if( vdp->vd_down % 2 )
		base = 1;
	else
		base = 2;

	 /* Produce a RGBpixel buffer from a description of the character and
	  * the read back data from the frame buffer for anti-aliasing.
	  */
	 for (i = height + base; i >= base; i--)  {
		 squash(	filterbuf[i - 1],	/* filter info */
			 filterbuf[i],
			 filterbuf[i + 1],
			 resbuf,
			 totwid + 4
		     );
		 fb_read( fbp, x, y - vdp->vd_down + i, (unsigned char *)fbline, totwid+3);
		 for (j = 0; j < (totwid + 3) - 1; j++)  {
			 register int	tmp;
			 /* EDITOR'S NOTE : do not rearrange this code,
			  * the SUN compiler can't handle more
			  * complex expressions.
			  */

			 tmp = fbline[j][RED] & 0377;
			 fbline[j][RED] =
			     (int)(pixcolor[RED]*resbuf[j]+(1-resbuf[j])*tmp);
			 fbline[j][RED] &= 0377;
			 tmp = fbline[j][GRN] & 0377;
			 fbline[j][GRN] =
			     (int)(pixcolor[GRN]*resbuf[j]+(1-resbuf[j])*tmp);
			 fbline[j][GRN] &= 0377;
			 tmp = fbline[j][BLU] & 0377;
			 fbline[j][BLU] =
			     (int)(pixcolor[BLU]*resbuf[j]+(1-resbuf[j])*tmp);
			 fbline[j][BLU] &= 0377;
		}
		if( fb_write( fbp, x, y-vdp->vd_down+i, (unsigned char *)fbline, totwid+3 ) < totwid+3 )  {
			fprintf(stderr, "fblabel: pixel write error\n");
			bu_exit(1, NULL);
		}
	 }
}


 /*	b i t x ( )
	 Extract a bit field from a bit string.
  */
int
bitx(register char *bitstring, register int posn)
{
	for (; posn >= 8; posn -= 8, bitstring++);
#if defined( CANT_DO_ZERO_SHIFT )
	if (posn == 0)
		return (int) (*bitstring) & 1;
	else
#endif
		return (int) (*bitstring) & (1 << posn);
}

/*
 * squash - Filter super-sampled image for one scan line
 */

/* Cone filtering weights.
 * #define CNTR_WT 0.23971778
 * #define MID_WT  0.11985889
 * #define CRNR_WT 0.07021166
 */

/* Gaussian filtering weights. */
#define CNTR_WT 0.3011592441
#define MID_WT 0.1238102667
#define CRNR_WT 0.0508999223

/*	Squash takes three super-sampled "bit arrays", and returns an array
	of intensities at half the resolution.  N is the size of the bit
	arrays.  The "bit arrays" are actually int arrays whose values are
	assumed to be only 0 or 1.
 */
void
squash(register int *buf0, register int *buf1, register int *buf2, register float *ret_buf, register int n)
{
	register int    j;

	for (j = 1; j < n - 1; j++) {
		if (alias_off)
		{
			ret_buf[j] = buf1[j];
		}
		else
		{
			ret_buf[j] =
				(
				 buf2[j - 1] * CRNR_WT +
				 buf2[j] * MID_WT +
				 buf2[j + 1] * CRNR_WT +
				 buf1[j - 1] * MID_WT +
				 buf1[j] * CNTR_WT +
				 buf1[j + 1] * MID_WT +
				 buf0[j - 1] * CRNR_WT +
				 buf0[j] * MID_WT +
				 buf0[j + 1] * CRNR_WT
				);
		}
	}
}

/*	f i l l _ b u f ( )
	Fills in the buffer by reading a row of a bitmap from the
	character font file.  The file pointer is assumed to be in the
	correct position.
 */
void
fill_buf(register int wid, register int *buf, register char *bitrow)
{
	register int    j;

	/*
	 * For each bit in the row, set the array value to 1 if it's on. The
	 * bitx routine extracts the bit value.  Can't just use the j-th bit
	 * because the bytes are backwards.
	 */
	for (j = 0; j < wid; j++)
		if (bitx(bitrow, (j & ~7) + (7 - (j & 7))))
			buf[j + 2] = 1;
		else
			buf[j + 2] = 0;

	/*
	 * Need two samples worth of background on either end to make the
	 * filtering come out right without special casing the filtering.
	 */
	buf[0] = buf[1] = buf[wid + 2] = buf[wid + 3] = 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@pass bu_exit a NULL instead of an empty string
@
text
@d268 1
a268 1
		bzero( (char *)&filterbuf[i][0], (totwid+4)*sizeof(int) );
d275 1
a275 1
		bzero( (char *)&filterbuf[i][0], (totwid+4)*sizeof(int) );
@


14.14
log
@exit->bu_exit where applicable
@
text
@d178 1
a178 1
		bu_exit(1, "");
d183 1
a183 1
		bu_exit(12, "");
d193 1
a193 1
		bu_exit(1, "");
d199 1
a199 1
	bu_exit(0, "");
d316 1
a316 1
			bu_exit(1, "");
@


14.13
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d178 1
a178 1
		exit(1);
d183 1
a183 1
		exit(12);
d193 1
a193 1
		exit(1);
d199 1
a199 1
	exit(0);
d316 1
a316 1
			exit(1);
@


14.12
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@a35 1

d39 4
a45 7
#include <stdio.h>
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
#include <ctype.h>
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d148 1
a148 1
		        pixcolor[RED] = atoi( bu_optarg );
d151 1
a151 1
		        pixcolor[GRN] = atoi( bu_optarg );
d154 1
a154 1
		        pixcolor[BLU] = atoi( bu_optarg );
d232 2
a233 2
	 	if( width <= 1 )  {
	 		char_id = 'n';	/* 1-en space */
d236 2
a237 2
	 		if( width <= 1 )  {
		 		char_id = 'N';	/* 1-en space */
d240 6
a245 6
	 			if( width <= 1 )
	 				width = 16;	/* punt */
	 		}
	 		currx += width;
	 		continue;
	 	}
@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
@


14.9
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2006 United States Government as represented by
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1986-2005 United States Government as represented by
@


14.7
log
@needs bu.h for bu_getopt
@
text
@d29 1
a29 1
 * 
d260 1
a260 1
{	
d342 1
a342 1
/* 
d346 1
a346 1
/* Cone filtering weights. 
d403 1
a403 1
	 * because the bytes are backwards. 
d413 1
a413 1
	 * filtering come out right without special casing the filtering. 
@


14.6
log
@use bu_optarg, bu_optind and bu_getopt
@
text
@d53 1
@


14.5
log
@add missing headers
@
text
@d99 1
a99 1
	while ( (c = getopt( argc, argv, "adhcF:f:r:g:b:C:s:S:w:W:n:N:" )) != EOF )  {
d114 1
a114 1
			scr_height = scr_width = atoi( optarg );
d118 1
a118 1
			scr_width = atoi( optarg );
d122 1
a122 1
			scr_height = atoi( optarg );
d128 1
a128 1
			framebuffer = optarg;
d131 1
a131 1
			font1 = optarg;
d135 1
a135 1
				register char *cp = optarg;
d148 1
a148 1
		        pixcolor[RED] = atoi( optarg );
d151 1
a151 1
		        pixcolor[GRN] = atoi( optarg );
d154 1
a154 1
		        pixcolor[BLU] = atoi( optarg );
d161 1
a161 1
	if( optind+3 > argc )
d163 3
a165 3
	xpos = atoi( argv[optind++]);
	ypos = atoi( argv[optind++]);
	textstring = argv[optind++];
d168 1
a168 1
	if ( argc > optind )
@


14.5.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
a52 1
#include "bu.h"
d99 1
a99 1
	while ( (c = bu_getopt( argc, argv, "adhcF:f:r:g:b:C:s:S:w:W:n:N:" )) != EOF )  {
d114 1
a114 1
			scr_height = scr_width = atoi( bu_optarg );
d118 1
a118 1
			scr_width = atoi( bu_optarg );
d122 1
a122 1
			scr_height = atoi( bu_optarg );
d128 1
a128 1
			framebuffer = bu_optarg;
d131 1
a131 1
			font1 = bu_optarg;
d135 1
a135 1
				register char *cp = bu_optarg;
d148 1
a148 1
		        pixcolor[RED] = atoi( bu_optarg );
d151 1
a151 1
		        pixcolor[GRN] = atoi( bu_optarg );
d154 1
a154 1
		        pixcolor[BLU] = atoi( bu_optarg );
d161 1
a161 1
	if( bu_optind+3 > argc )
d163 3
a165 3
	xpos = atoi( argv[bu_optind++]);
	ypos = atoi( argv[bu_optind++]);
	textstring = argv[bu_optind++];
d168 1
a168 1
	if ( argc > bu_optind )
d259 1
a259 1
{
d341 1
a341 1
/*
d345 1
a345 1
/* Cone filtering weights.
d402 1
a402 1
	 * because the bytes are backwards.
d412 1
a412 1
	 * filtering come out right without special casing the filtering.
@


14.4
log
@update copyright to 2005
@
text
@d40 1
d42 1
a42 1
# include <unistd.h>
a43 1
                                                                                                                                                                            
d46 1
a46 1
#include <string.h>
d48 1
a48 1
#include <strings.h>
d51 1
d56 1
@


14.3
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1986-2004 United States Government as represented by
@


14.2
log
@assign copyright and GPL license
@
text
@a34 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1986-2004 by the United States Army.
 *	All rights reserved.
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 22
a22 2
/*
 *			F B L A B E L . C
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d397 10
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d28 1
a28 1
#ifdef USE_STRING_H
@


1.3
log
@fix missing header issues
@
text
@d21 1
a21 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d25 4
a28 2


@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@a34 1
#include "externs.h"
@

