head	14.14;
access;
symbols
	rel-7-10-4:14.12
	STABLE:14.12.0.2
	stable-branch:14.4
	rel-7-10-2:14.12
	rel-7-10-0:14.12
	rel-7-8-4:14.9
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.4
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.5
	rel-7-6-branch:14.5.0.2
	rel-7-6-0:14.5
	rel-7-4-2:14.4
	rel-7-4-branch:14.4.0.4
	bobWinPort:14.4.0.2
	rel-7-4-0:14.4
	rel-7-2-6:14.4
	rel-7-2-4:14.4
	rel-7-2-2:14.4
	rel-7-2-0:14.4
	rel-7-0-4:14.3
	rel-7-0-2:14.3
	rel-7-0-1:14.3
	opensource-post:14.3
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.14
date	2007.11.21.20.49.07;	author erikgreenwald;	state Exp;
branches;
next	14.13;

14.13
date	2007.11.21.19.09.24;	author erikgreenwald;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.27.01.41.34;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.23.01.13.31;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2007.01.20.14.36.48;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.15;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.30;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.09.21.19.00.27;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.09.21.17.17.18;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2005.08.21.13.51.43;	author brlcad;	state Exp;
branches
	14.5.2.1;
next	14.4;

14.4
date	2005.01.30.20.30.21;	author brlcad;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.18.06.09.12;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.23.01.47;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.09.17.56.22;	author erikg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.22.04.12;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.03;	author morrison;	state Exp;
branches;
next	;

14.5.2.1
date	2005.11.13.13.46.13;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.14
log
@pass bu_exit a NULL instead of an empty string
@
text
@/*                        G I F 2 F B . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 *
 */
/** @@file gif2fb.c
 *
 */

/*	G I F - F B	Gif to Frame Buffer
 *
 * Gif-fb takes a GIF file and writes it to a frame buffer.
 * GIF files contain one or more 1,2,4, or 8 bit deep pictures
 * with one or more color maps. Gif-fb will select the correct
 * color map and display the first picture on the frame-buffer.
 *
 * Entry:
 *	FB_FILE		name of the frame buffer to use.
 *	-i		invert color map.
 *	name		name of the file to display.
 *
 * Exit:
 *	the named gif file has been displayed
 *
 * Author:
 *	Christopher T. Johnson - 89/02/23
 *	The decompress algorithem was taken from compress.c
 *
 * Source:
 *	SECAD/VLD Computing Consortium, Bldg 394
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
 *
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.13 2007/11/21 19:09:24 erikgreenwald Exp $ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#include <stdio.h>

#include "machine.h"
#include "bu.h"
#include "fb.h"


#define	LSB	0	/* Least Signifigent Byte */
#define MSB	1	/* Most Signifigent Byte */

struct GIF_head {
	char		GH_Magic[6];
	unsigned char	GH_ScreenWidth[2];	/* MSB, LSB */
	unsigned char	GH_ScreenHeight[2];	/* MSB, LSB */
	unsigned char	GH_Flags;
	unsigned char	GH_Background;
	unsigned char	GH_EOB;
	};

struct GIF_Image {
	char		IH_Magic;
	unsigned char	IH_Left[2];		/* MSB, LSB */
	unsigned char	IH_Top[2];		/* MSB, LSB */
	unsigned char	IH_Width[2];		/* MSB, LSB */
	unsigned char	IH_Height[2];		/* MSB, LSB */
	unsigned char	IH_Flags;
	};

struct acolor {
	unsigned char	red;
	unsigned char	green;
	unsigned char	blue;
	};

#define WORD(x)	(((int)x[MSB]<<8)+(int)x[LSB])

int ScreenWidth, ScreenHeight;
int GlobalMap;
int CR;
int GlobalPixels;
int Background;

int MinBits;
int Bits;
int Fresh=1;

struct acolor	GlobalColors[256];
struct acolor	LocalColors[256];

struct GIF_head Header;
struct GIF_Image Im;

char *framebuffer=NULL;

void usage(char **argv);
int getByte(FILE *inp);

int
main(int argc, char **argv)
{
	int	 i,idx,n;
	int	maxcolors;
	int	code;
	int	verbose=0;
	int	headers=0;
	int	interlaced;
	char	*file_name;

	unsigned char line[3*2048];
	unsigned char *lp;

	int lineNumber,lineInc,lineIdx;
	static int lace[4] = {8,8,4,2};
	static int offs[4] = {0,4,2,1};

	FBIO *fbp;
	FILE *fp;

	while ((code = bu_getopt(argc,argv,"vFh")) != EOF){
		switch (code) {
		case 'h':
			headers=1;
			break;
		case 'v':
			verbose=1;
			break;
		case 'F':
			framebuffer = bu_optarg;
			break;
		default:	/* '?' */
			usage(argv);
			bu_exit(1, NULL);
		}
	}

	if( bu_optind >= argc )  {
		if( isatty(fileno(stdin)) ) {
			(void) fprintf(stderr, "%s: No input file.\n",argv[0]);
			usage(argv);
			bu_exit(1, NULL);
		}
		file_name = "-";
		fp = stdin;
	} else {
		file_name = argv[bu_optind];
		if( (fp = fopen(file_name, "r")) == NULL )  {
			(void)fprintf( stderr,
			    "%s: cannot open \"%s\" for reading\n",argv[0],
			    file_name );
			usage(argv);
			bu_exit(1, NULL);
		}
	}
/*
 * read in the Header and then check for consitence.
 */
	n= fread(&Header, 1, 13, fp);

	if (n != 13) {
		fprintf(stderr,"%s: only %d bytes in header.\n",argv[0],n);
		bu_exit(1, NULL);
	}

	ScreenWidth = WORD(Header.GH_ScreenWidth);
	ScreenHeight= WORD(Header.GH_ScreenHeight);
	GlobalMap   = (Header.GH_Flags>>7);
	CR	    = (Header.GH_Flags>>4) & 0x07;
	GlobalPixels= (Header.GH_Flags&0x07) + 1;
	if (headers) {
		fprintf(stderr,"-w%d -n%d\n", ScreenWidth, ScreenHeight);
		bu_exit(0, NULL);
	}
/*
 * In verbose mode, output a message before checking to allow the
 * "smarter" user look over the header even if the header is barfO.
 */
	if (verbose) {
		fprintf(stderr,"Magic=%.6s, -w%d -n%d, M=%d, cr=%d, pixel=%d, bg=%d\n",
		    Header.GH_Magic, ScreenWidth, ScreenHeight, GlobalMap,
		    CR, GlobalPixels, Header.GH_Background);
	}

	if (Header.GH_EOB) {
		fprintf(stderr,"%s: missing EOB in header.\n",argv[0]);
		bu_exit(1, NULL);
	}
	maxcolors = 1 << GlobalPixels;

/*
 * Read in the Global color map.
 */
	for (i=0;i<maxcolors;i++) {
		n = fread(&GlobalColors[i], 1, 3, fp);
		if (n != 3) {
			fprintf(stdout,"%s: only read %d global colors.\n",
			    argv[0], i);
			bu_exit(1, NULL);
		}
	}
/*
 * Read in the image header.
 */
	n= fread(&Im, 1, sizeof(Im), fp);

	if (n != sizeof(Im)) {
		fprintf(stderr,"%s: only %d bytes in image header.\n",
		    argv[0], n);
		bu_exit(1, NULL);
	}
	if (verbose) {
		fprintf(stderr,"Magic=%c, left=%d, top=%d, Width=%d, Height=%d\n",
		    Im.IH_Magic, WORD(Im.IH_Left), WORD(Im.IH_Top), WORD(Im.IH_Width),
		    WORD(Im.IH_Height));
		fprintf(stderr,"Map=%d, Interlaced=%d, pixel=%d\n",
		    Im.IH_Flags>>7, (Im.IH_Flags>>6)&0x01, Im.IH_Flags&0x03);
	}

	interlaced = (Im.IH_Flags>>6)&0x01;

/*
 * Read the image color map if any.
 */
	if (Im.IH_Flags>>7) {
		GlobalPixels= (Im.IH_Flags&0x07) + 1;
		for (i=0;i<maxcolors;i++) {
			n = fread(&GlobalColors[i], 1, 3, fp);
			if (n != 3) {
				fprintf(stdout,
				    "%s: only read %d global colors.\n",
				    argv[0], i);
				bu_exit(1, NULL);
			}
		}
	}

	if (WORD(Im.IH_Width) > 2048) {
		fprintf(stderr, "%s: Input line greater than internal buffer!\n",
		    argv[0]);
		bu_exit(1, NULL);
	}

	MinBits = getc(fp) + 1;

	if (verbose) {
		fprintf(stderr,"MinBits=%d\n", MinBits);
	}

	if (interlaced ) {
		lineIdx = 0;

		lineNumber = offs[lineIdx];
		lineInc= lace[lineIdx];
	} else {
		lineIdx = 4;
		lineNumber = 0;
		lineInc = 1;
	}
/*
 * Open the frame buffer.
 */
	fbp = fb_open(framebuffer,WORD(Im.IH_Width),
	    WORD(Im.IH_Height));

/*
 * The speed of this loop can be greatly increased by moving all of
 * the WORD macro calls out of the loop.
 */
	for (i=0; i<WORD(Im.IH_Height);i++) {
		int k;
		lp = line;
		for (k=0;k<WORD(Im.IH_Width);k++) {
			idx = getByte(fp);
			*lp++ = GlobalColors[idx].red;
			*lp++ = GlobalColors[idx].green;
			*lp++ = GlobalColors[idx].blue;
		}
		fb_write(fbp,0,WORD(Im.IH_Height)-lineNumber,line,
		    WORD(Im.IH_Width));
		fb_flush(fbp);
		lineNumber += lineInc;
		if (lineNumber >= WORD(Im.IH_Height)) {
			++lineIdx;
			lineInc = lace[lineIdx];
			lineNumber = offs[lineIdx];
		}
	}
	fb_close(fbp);
	return(0);
}
/* getcode - Get a LWZ "code"
 *
 * getcode returns an LWZ code.  The code size is always less than
 * 12 bits but could be as small as 2 bits.  This implies that reading
 * one code may not "read" anything from a file.
 *
 * Entry:
 *	inp	a FILE pointer to the input stream.
 *
 * Exit:
 *	returns one code.
 *
 * Uses:
 *	Bits		global variable containing the size of a code.
 *	bitsleft	number of bits left in this byte.
 *	count		number of BYTES left in this Block.
 *	lastbits	the left over bits form the last getcode call.
 *
 * Calls:
 * 	none.
 *
 * Method:
 *	while not enough bits for a code do
 *		read another byte (8 bits)
 *	endwhile
 *	extract the code.
 *	clean up the state variables.
 *
 * N.B.!!!	This code depends on the '>>' operator zero filling
 *		from the left.
 */
int
getcode(FILE *inp)
{
	static unsigned int lastbits = 0;
	static int bitsleft = 0;
	static int count=0;
	int code;


	while (bitsleft < Bits) {
/*
 * get a new block counter if needed.
 */
		if (--count <= 0) {
			count = (unsigned char) getc(inp);
			if (count == 0) return(-1);
		}
/*
 * stuff another byte into last bits.
 */
		lastbits |= (unsigned char) getc(inp) << bitsleft;
		bitsleft += 8;
	}
	code = (1<<Bits)-1;	/* make mask */
	code &= lastbits;	/* extract the code */
/*
 * clean up the state variables.
 */
	bitsleft -= Bits;
	lastbits = lastbits >> Bits;
	return(code);
}

/* getByte	get a byte from the input stream decompressing as we go.
 *
 * getByte uses the somewhat standard LWZ decompress algorthem.  Most
 * of this subroutine is based on "compress.c".  I've added some and
 * deleted others but I do NOT claim that this is original code.
 *
 * Entry:
 *	inp	the input stream point
 *
 * Exit:
 *	returns a "byte".
 *
 * Calls:
 *	getcode		to get the next code from the input stream.
 *
 * Uses:
 *	Bits	current size of the code.
 *	minBits	the min. size of the code.
 *
 * Method:
 *	Being unable to read the papers that everybody else points to,
 *	I had to decipher the compress code.  This is how I thing this
 *	compression algorithem works.
 *	if this is the first time the routine has been called then
 *		initialize the code sizes
 *		set the "tree" so that all "characters" are at the root.
 *	endif
 *	get a new code
 *	if the new code is greater than the current max code then
 *		add last(?) code to the tree.
 *		follow the tree from the leaf to the root outputing
 *		    a "byte" for each node of the tree.
 *	endif
 */
int getByte(FILE *inp)
{
	int code,incode;
	static int	firstcode,oldcode;
	static int	firstTime = 1;
	static int	clear_code,end_code;
	static int	max_code,next_ent;
#define	PREFIX	0
#define SUFIX	1
	static int	table[2][1<<12];
	static int	stack[1<<13],*sp;

	int i;

	if (firstTime) {
		firstTime = 0;
		Bits = MinBits;
		clear_code = 1 << (Bits-1);
		end_code = clear_code+1;
		max_code=clear_code<<1;
		next_ent = clear_code+2;

		for (i=0;i<clear_code;i++) {
			table[PREFIX][i] = 0;
			table[SUFIX][i]  = i;
		}

		sp = stack;

		do {
			firstcode=oldcode=getcode(inp);
		} while (firstcode == clear_code);
		return(firstcode);
	}

	if (sp > stack) return(*--sp);

	while ((code=getcode(inp)) >= 0) {
		if (code == clear_code) {
			for (i=0;i<clear_code;i++) {
				table[PREFIX][i] = 0;
				table[SUFIX][i]  = i;
			}
			Bits = MinBits;
			max_code = clear_code<<1;
			next_ent = clear_code+2;
			sp=stack;
			firstcode=oldcode=getcode(inp);
			return(firstcode);
		} else if (code == end_code) {
			return (-1);
		}

		incode = code;

		if (code >= next_ent) {
			*sp++ =firstcode;
			code = oldcode;
		}

		while (code >= clear_code) {
			*sp++ = table[SUFIX][code];
			code = table[PREFIX][code];
		}

		*sp++ = firstcode = table[SUFIX][code];

		if ((code=next_ent) < (1<<12)) {
			table[PREFIX][code] = oldcode;
			table[SUFIX][code]  = firstcode;
			next_ent++;
			if ((next_ent >= max_code) &&
			    (max_code < (1<<12))) {
				max_code *= 2;
				Bits++;
			}
		}

		oldcode = incode;

		if (sp >stack) return(*--sp);
	}
	return(code);
}
void
usage(char **argv)
{
	fprintf(stderr,"%s [-h] [-v] [-F frame_buffer] [gif_file]\n",argv[0]);
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.13
log
@exit->bu_exit where applicable
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.12 2007/01/27 01:41:34 brlcad Exp $ (BRL)";
d152 1
a152 1
			bu_exit(1, "");
d160 1
a160 1
			bu_exit(1, "");
d171 1
a171 1
			bu_exit(1, "");
d181 1
a181 1
		bu_exit(1, "");
d191 1
a191 1
		bu_exit(0, "");
d205 1
a205 1
		bu_exit(1, "");
d217 1
a217 1
			bu_exit(1, "");
d228 1
a228 1
		bu_exit(1, "");
d251 1
a251 1
				bu_exit(1, "");
d259 1
a259 1
		bu_exit(1, "");
@


14.12
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.11 2007/01/23 01:13:31 brlcad Exp $ (BRL)";
d152 1
a152 1
			exit(1);
d160 1
a160 1
			exit(1);
d171 1
a171 1
			exit(1);
d181 1
a181 1
		exit(1);
d191 1
a191 1
		exit(0);
d205 1
a205 1
		exit(1);
d217 1
a217 1
			exit(1);
d228 1
a228 1
		exit(1);
d251 1
a251 1
				exit(1);
d259 1
a259 1
		exit(1);
@


14.11
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.10 2007/01/20 14:36:48 brlcad Exp $ (BRL)";
d481 2
a482 2
			    	max_code *= 2;
			    	Bits++;
@


14.10
log
@update copyright to 2007
@
text
@d8 2
a9 3
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
d14 1
a14 1
 * General Public License for more details.
d16 2
a17 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d52 1
a52 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.9 2006/01/18 06:46:15 brlcad Exp $ (BRL)";
@


14.9
log
@update copyright to 2006
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.8 2005/10/23 04:44:30 brlcad Exp $ (BRL)";
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.7 2005/09/21 19:00:27 brlcad Exp $ (BRL)";
@


14.7
log
@needs bu.h for bu_getopt
@
text
@d49 1
a49 1
 *  
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.6 2005/09/21 17:17:18 brlcad Exp $ (BRL)";
d203 1
a203 1
	
d313 1
a313 1
 * getcode returns an LWZ code.  The code size is always less than 
@


14.6
log
@use bu_optarg, bu_optind and bu_getopt
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.5 2005/08/21 13:51:43 brlcad Exp $ (BRL)";
d65 1
@


14.5
log
@add missing headers
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.4 2005/01/30 20:30:21 brlcad Exp $ (BRL)";
d139 1
a139 1
	while ((code = getopt(argc,argv,"vFh")) != EOF){
d148 1
a148 1
			framebuffer = optarg;
d156 1
a156 1
	if( optind >= argc )  {
d165 1
a165 1
		file_name = argv[optind];
@


14.5.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d49 1
a49 1
 *
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
a64 1
#include "bu.h"
d139 1
a139 1
	while ((code = bu_getopt(argc,argv,"vFh")) != EOF){
d148 1
a148 1
			framebuffer = bu_optarg;
d156 1
a156 1
	if( bu_optind >= argc )  {
d165 1
a165 1
		file_name = argv[bu_optind];
d202 1
a202 1

d312 1
a312 1
 * getcode returns an LWZ code.  The code size is always less than
@


14.4
log
@update copyright to 2005
@
text
@d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/fb/gif2fb.c,v 14.3 2004/12/21 07:18:57 morrison Exp $ (BRL)";
d58 1
d60 1
a60 1
# include <unistd.h>
a61 1
                                                                                                                                                                            
d67 1
@


14.3
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif2fb.c,v 14.2 2004/12/18 06:09:12 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and GPL license
@
text
@a49 2
 * Distribution Status:
 *	Public Domain, Distribution Unlimitied.
d53 1
a53 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif2fb.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 25
d55 1
a55 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif2fb.c,v 1.4 2004/08/02 23:01:47 morrison Exp $ (BRL)";
@


1.4
log
@replace the wrapped config.h block with common.h
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif2fb.c,v 1.3 2004/06/09 17:56:22 erikg Exp $ (BRL)";
d473 10
@


1.3
log
@fix missing header issues
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/fb/gif2fb.c,v 1.2 2004/06/08 22:04:12 morrison Exp $ (BRL)";
d33 1
a33 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.2
log
@obliterate externs.h
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d37 4
a40 2


@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d30 1
a30 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/fb/gif2fb.c,v 11.8 2004/05/10 15:30:42 erikg Exp $ (BRL)";
a41 1
#include "externs.h"			/* For getopt */
@

