head	14.26;
access;
symbols
	rel-7-10-4:14.22
	STABLE:14.22.0.2
	stable-branch:14.9
	rel-7-10-2:14.22
	rel-7-10-0:14.19
	rel-7-8-4:14.15
	rel-7-8-2:14.14
	rel-7-8-0:14.14
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.12
	bobWinPort-20051223-freeze:14.11
	postmerge-20051223-bobWinPort:14.12
	premerge-20051223-bobWinPort:14.12
	rel-7-6-6:14.12
	rel-7-6-4:14.12
	rel-7-6-2:14.11
	rel-7-6-branch:14.11.0.4
	rel-7-6-0:14.11
	rel-7-4-2:14.10
	rel-7-4-branch:14.10.0.2
	bobWinPort:14.11.0.2
	rel-7-4-0:14.10
	rel-7-2-6:14.9
	rel-7-2-4:14.9
	rel-7-2-2:14.9
	rel-7-2-0:14.8
	rel-7-0-4:14.7
	rel-7-0-2:14.7
	rel-7-0-1:14.7
	opensource-post:14.7
	opensource-pre:1.6
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.26
date	2007.12.06.16.11.27;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.10.01.07.54.50;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.09.15.16.23.08;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.06.27.02.36.21;	author johnranderson;	state Exp;
branches;
next	14.21;

14.21
date	2007.05.31.18.40.42;	author erikgreenwald;	state Exp;
branches;
next	14.20;

14.20
date	2007.04.16.21.15.36;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.31.05.50.24;	author lbutler;	state Exp;
branches;
next	14.14;

14.14
date	2006.03.24.19.59.08;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches
	14.13.2.1;
next	14.12;

14.12
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.11.4.1;
next	14.10;

14.10
date	2005.07.08.00.04.08;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.03.24.16.08.12;	author bob1961;	state Exp;
branches;
next	14.8;

14.8
date	2005.01.30.20.30.45;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.32.30;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.32;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.14.21.54.33;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.15.05.39.14;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.07.22.39.28;	author kermit;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.31;	author morrison;	state Exp;
branches;
next	;

14.11.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.13.2.1
date	2006.04.07.19.30.15;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.26
log
@finally obsolete bu_brlcad_path() and bu_tcl_brlcad_path(), which were marked deprecated back in 7.4; callers should now be using bu_brlcad_data() and bu_brlcad_root() depending on the nature of the lookup.
@
text
@/*                        B U _ T C L . C
 * BRL-CAD
 *
 * Copyright (c) 1998-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup butcl */
/** @@{ */
/** @@file bu_tcl.c
 *
 * @@brief
 *	Tcl interfaces to all the LIBBU Basic BRL-CAD Utility routines.
 *
 *	Remember that in MGED you need to say "set glob_compat_mode 0"
 *	to get [] to work with TCL semantics rather than MGED glob semantics.
 *
 * @@author Michael John Muuss
 *
 * @@par Source -
 *	The U. S. Army Research Laboratory			@@n
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.25 2007/10/22 20:59:55 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#include "tcl.h"
#include "machine.h"
#include "cmd.h"		/* this includes bu.h */
#include "vmath.h"
#include "bn.h"
#include "bu.h"

#define TINYBUFSIZ	32
#define SMALLBUFSIZ	256

/* defined in libbu/cmdhist_obj.c */
extern int Cho_Init(Tcl_Interp *interp);

static struct bu_cmdtab bu_cmds[] = {
	{"bu_units_conversion",		bu_tcl_units_conversion},
	{"bu_brlcad_data",		bu_tcl_brlcad_data},
	{"bu_brlcad_root",		bu_tcl_brlcad_root},
	{"bu_mem_barriercheck",		bu_tcl_mem_barriercheck},
	{"bu_ck_malloc_ptr",		bu_tcl_ck_malloc_ptr},
	{"bu_malloc_len_roundup",	bu_tcl_malloc_len_roundup},
	{"bu_prmem",			bu_tcl_prmem},
	{"bu_printb",			bu_tcl_printb,},
	{"bu_get_all_keyword_values",	bu_get_all_keyword_values},
	{"bu_get_value_by_keyword",	bu_get_value_by_keyword},
	{"bu_rgb_to_hsv",		bu_tcl_rgb_to_hsv},
	{"bu_hsv_to_rgb",		bu_tcl_hsv_to_rgb},
	{"bu_key_eq_to_key_val",	bu_tcl_key_eq_to_key_val},
	{"bu_shader_to_tcl_list",	bu_tcl_shader_to_key_val},
	{"bu_key_val_to_key_eq",	bu_tcl_key_val_to_key_eq},
	{"bu_shader_to_key_eq",		bu_tcl_shader_to_key_eq},
	{(char *)NULL,	(int (*)())0 }
};


/**
 *	b u _ b a d m a g i c _ t c l
 *
 * 	Support routine for BU_CKMAG_TCL macro. As used by
 *	BU_CKMAG_TCL, this routine is not called unless there
 *	is trouble with the pointer. When called, an appropriate
 *	message is added to interp indicating the problem.
 *
 *	@@param interp	- tcl interpreter where result is stored
 *	@@param ptr	- pointer to a data structure
 *	@@param magic	- the correct/desired magic number
 *	@@param str	- usually indicates the data structure name
 *	@@param file	- file where this routine was called
 *	@@param line	- line number in the above file
 *
 * 	@@return
 *		void
 */

void
bu_badmagic_tcl(Tcl_Interp	*interp,
		const long	*ptr,
		unsigned long	magic,
		const char	*str,
		const char	*file,
		int		line)
{
	char	buf[SMALLBUFSIZ];

	if (!(ptr)) {
		snprintf(buf, SMALLBUFSIZ, "ERROR: NULL %s pointer in TCL interface, file %s, line %d\n",
			str, file, line);
		Tcl_AppendResult(interp, buf, NULL);
		return;
	}
	if (*((long *)(ptr)) != (magic)) {
		snprintf(buf, SMALLBUFSIZ, "ERROR: bad pointer in TCL interface x%lx: s/b %s(x%lx), was %s(x%lx), file %s, line %d\n",
			(long)ptr,
			str, magic,
			bu_identify_magic( *(ptr) ), *(ptr),
			file, line);
		Tcl_AppendResult(interp, buf, NULL);
		return;
	}
	Tcl_AppendResult(interp, "bu_badmagic_tcl() mysterious error condition, ", str, " pointer, ", file, "\n", NULL);
}


/**
 *	bu_structparse_get_terse_form
 *
 *	Convert the "form" of a bu_structparse table into a TCL result string,
 *	with parameter-name data-type pairs:
 *
 *		V {%f %f %f} A {%f %f %f}
 *
 *	A different routine should build a more general 'form', along the
 *	lines of {V {%f %f %f} default {help}} {A {%f %f %f} default# {help}}
 *
 *	@@param interp	- tcl interpreter
 *	@@param sp	- structparse table
 *
 * 	@@return
 *		void
 */
void
bu_structparse_get_terse_form(Tcl_Interp			*interp,
			      const struct bu_structparse	*sp)
{
	struct bu_vls	str;
	int		i;

	bu_vls_init(&str);

	while (sp->sp_name != NULL) {
		Tcl_AppendElement(interp, sp->sp_name);
		bu_vls_trunc(&str, 0);
		/* These types are specified by lengths, e.g. %80s */
		if (strcmp(sp->sp_fmt, "%c") == 0 ||
		    strcmp(sp->sp_fmt, "%s") == 0 ||
		    strcmp(sp->sp_fmt, "%S") == 0) {
			if (sp->sp_count > 1) {
				/* Make them all look like %###s */
				bu_vls_printf(&str, "%%%lds", sp->sp_count);
			} else {
				/* Singletons are specified by their actual character */
				bu_vls_printf(&str, "%%c");
			}
		} else {
			/* Vectors are specified by repetition, e.g. {%f %f %f} */
			bu_vls_printf(&str, "%s", sp->sp_fmt);
			for (i = 1; i < sp->sp_count; i++)
				bu_vls_printf(&str, " %s", sp->sp_fmt);
		}
		Tcl_AppendElement(interp, bu_vls_addr(&str));
		++sp;
	}
	bu_vls_free(&str);
}

/**
 *	BU_SP_SKIP_SEP
 *
 *	Skip the separator(s) (i.e. whitespace and open-braces)
 *
 *	@@param _cp	- character pointer
 */
#define BU_SP_SKIP_SEP(_cp)	\
	{ while( *(_cp) && (*(_cp) == ' ' || *(_cp) == '\n' || \
		*(_cp) == '\t' || *(_cp) == '{' ) )  ++(_cp); }


/**
 *	bu_structparse_argv
 *
 *	Support routine for db adjust and db put.  Much like the bu_struct_parse routine
 *	which takes its input as a bu_vls. This routine, however, takes the arguments
 *	as lists, a more Tcl-friendly method. Also knows about the Tcl result string,
 *	so it can make more informative error messages.
 *
 *	Operates on argv[0] and argv[1], then on argv[2] and argv[3], ...
 *
 *
 *	@@param interp	- tcl interpreter
 *	@@param argc	- number of elements in argv
 *	@@param argv	- contains the keyword-value pairs
 *	@@param desc	- structure description
 *	@@param base	- base addr of users struct
 *
 * 	@@retval TCL_OK if successful,
 *	@@retval TCL_ERROR on failure
 */
int
bu_structparse_argv(Tcl_Interp			*interp,
		    int				argc,
		    char			**argv,
		    const struct bu_structparse	*desc,
		    char			*base)
{
	register char				*cp, *loc;
	register const struct bu_structparse	*sdp;
	register int				 j;
	register int				ii;
	struct bu_vls				 str;

	if (desc == (struct bu_structparse *)NULL) {
		bu_log("bu_structparse_argv: NULL desc pointer\n");
		Tcl_AppendResult(interp, "NULL desc pointer", (char *)NULL);
		return TCL_ERROR;
	}

	/* Run through each of the attributes and their arguments. */

	bu_vls_init(&str);
	while (argc > 0) {
		/* Find the attribute which matches this argument. */
		for (sdp = desc; sdp->sp_name != NULL; sdp++) {
			if (strcmp(sdp->sp_name, *argv) != 0)
				continue;

			/* if we get this far, we've got a name match
			 * with a name in the structure description
			 */
			loc = (char *)(base+((int)sdp->sp_offset));
			if (sdp->sp_fmt[0] != '%') {
				bu_log("bu_structparse_argv: unknown format\n");
				bu_vls_free(&str);
				Tcl_AppendResult(interp, "unknown format",
						 (char *)NULL);
				return TCL_ERROR;
			}

			--argc;
			++argv;

			switch (sdp->sp_fmt[1]) {
			case 'c':
			case 's':
				/* copy the string, converting escaped
				 * double quotes to just double quotes
				 */
				if (argc < 1) {
					bu_vls_trunc(&str, 0);
					bu_vls_printf(&str,
						      "not enough values for \"%s\" argument: should be %ld",
						      sdp->sp_name,
						      sdp->sp_count);
					Tcl_AppendResult(interp,
							 bu_vls_addr(&str),
							 (char *)NULL);
					bu_vls_free(&str);
					return TCL_ERROR;
				}
				for (ii = j = 0;
				     j < sdp->sp_count && argv[0][ii] != '\0';
				     loc[j++] = argv[0][ii++])
					;
				if (ii < sdp->sp_count)
					loc[ii] = '\0';
				if (sdp->sp_count > 1) {
					loc[sdp->sp_count-1] = '\0';
					Tcl_AppendResult(interp,
							 sdp->sp_name, " ",
							 loc, " ",
							 (char *)NULL);
				} else {
					bu_vls_trunc(&str, 0);
					bu_vls_printf(&str, "%s %c ",
						      sdp->sp_name, *loc);
					Tcl_AppendResult(interp,
							 bu_vls_addr(&str),
							 (char *)NULL);
				}
				break;
			case 'S': {
				struct bu_vls *vls = (struct bu_vls *)loc;
				bu_vls_init_if_uninit( vls );
				bu_vls_strcpy(vls, *argv);
				break;
			}
			case 'i':
#if 0
				bu_log(
			 "Error: %%i not implemented. Contact developers.\n" );
				Tcl_AppendResult( interp,
						  "%%i not implemented yet",
						  (char *)NULL );
				bu_vls_free( &str );
				return TCL_ERROR;
#else
				{
				register short *sh = (short *)loc;
				register int tmpi;
				register char const *cp;

				if( argc < 1 ) { /* XXX - when was ii defined */
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
      "not enough values for \"%s\" argument: should have %ld",
						       sdp->sp_name,
						       sdp->sp_count);
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}

				Tcl_AppendResult( interp, sdp->sp_name, " ",
						  (char *)NULL );

				/* Special case:  '=!' toggles a boolean */
				if( argv[0][0] == '!' ) {
					*sh = *sh ? 0 : 1;
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str, "%hd ", *sh );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					break;
				}
				/* Normal case: an integer */
				cp = *argv;
				for( ii = 0; ii < sdp->sp_count; ++ii ) {
					if( *cp == '\0' ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
		      "not enough values for \"%s\" argument: should have %ld",
							       sdp->sp_name,
							       sdp->sp_count );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					BU_SP_SKIP_SEP(cp);
					tmpi = atoi( cp );
					if( *cp && (*cp == '+' || *cp == '-') )
						cp++;
					while( *cp && isdigit(*cp) )
						cp++;
					/* make sure we actually had an
					 * integer out there
					 */

					if( cp == *argv ||
					    (cp == *argv+1 &&
					     (argv[0][0] == '+' ||
					      argv[0][0] == '-')) ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
			       "value \"%s\" to argument %s isn't an integer",
							       argv[0],
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					} else {
						*(sh++) = tmpi;
					}
					BU_SP_SKIP_SEP(cp);
				}
				Tcl_AppendResult( interp,
						  sdp->sp_count > 1 ? "{" : "",
						  argv[0],
						  sdp->sp_count > 1 ? "}" : "",
						  " ", (char *)NULL);
				break; }

#endif
			case 'd': {
				register int *ip = (int *)loc;
				register int tmpi;
				register char const *cp;

				if( argc < 1 ) { /* XXX - when was ii defined */
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
      "not enough values for \"%s\" argument: should have %ld",
						       sdp->sp_name,
						       sdp->sp_count);
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}

				Tcl_AppendResult( interp, sdp->sp_name, " ",
						  (char *)NULL );

				/* Special case:  '=!' toggles a boolean */
				if( argv[0][0] == '!' ) {
					*ip = *ip ? 0 : 1;
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str, "%d ", *ip );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					break;
				}
				/* Normal case: an integer */
				cp = *argv;
				for( ii = 0; ii < sdp->sp_count; ++ii ) {
					if( *cp == '\0' ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
		      "not enough values for \"%s\" argument: should have %ld",
							       sdp->sp_name,
							       sdp->sp_count );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					BU_SP_SKIP_SEP(cp);
					tmpi = atoi( cp );
					if( *cp && (*cp == '+' || *cp == '-') )
						cp++;
					while( *cp && isdigit(*cp) )
						cp++;
					/* make sure we actually had an
					 * integer out there
					 */

					if( cp == *argv ||
					    (cp == *argv+1 &&
					     (argv[0][0] == '+' ||
					      argv[0][0] == '-')) ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
			       "value \"%s\" to argument %s isn't an integer",
							       argv[0],
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					} else {
						*(ip++) = tmpi;
					}
					BU_SP_SKIP_SEP(cp);
				}
				Tcl_AppendResult( interp,
						  sdp->sp_count > 1 ? "{" : "",
						  argv[0],
						  sdp->sp_count > 1 ? "}" : "",
						  " ", (char *)NULL);
				break; }
			case 'f': {
				int		dot_seen;
				double		tmp_double;
				register double *dp;
				char		*numstart;

				dp = (double *)loc;

				if( argc < 1 ) {
					bu_vls_trunc( &str, 0 );
					bu_vls_printf( &str,
       "not enough values for \"%s\" argument: should have %ld, only %d given",
						       sdp->sp_name,
						       sdp->sp_count, argc );
					Tcl_AppendResult( interp,
							  bu_vls_addr(&str),
							  (char *)NULL );
					bu_vls_free( &str );
					return TCL_ERROR;
				}

				Tcl_AppendResult( interp, sdp->sp_name, " ",
						  (char *)NULL );

				cp = *argv;
				for( ii = 0; ii < sdp->sp_count; ii++ ) {
					if( *cp == '\0' ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
       "not enough values for \"%s\" argument: should have %ld, only %d given",
							       sdp->sp_name,
							       sdp->sp_count,
							       ii );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					BU_SP_SKIP_SEP(cp);
					numstart = cp;
					if( *cp == '-' || *cp == '+' ) cp++;

					/* skip matissa */
					dot_seen = 0;
					for( ; *cp ; cp++ ) {
						if( *cp == '.' && !dot_seen ) {
							dot_seen = 1;
							continue;
						}
						if( !isdigit(*cp) )
							break;
					}

					/* If no mantissa seen,
					   then there is no float here */
					if( cp == (numstart + dot_seen) ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
				   "value \"%s\" to argument %s isn't a float",
							       argv[0],
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					/* there was a mantissa,
					   so we may have an exponent */
					if( *cp == 'E' || *cp == 'e' ) {
						cp++;

						/* skip exponent sign */
						if (*cp == '+' || *cp == '-')
							cp++;
						while( isdigit(*cp) )
							cp++;
					}

					bu_vls_trunc( &str, 0 );
					bu_vls_strcpy( &str, numstart );
					bu_vls_trunc( &str, cp-numstart );
					if( sscanf(bu_vls_addr(&str),
						   "%lf", &tmp_double) != 1 ) {
						bu_vls_trunc( &str, 0 );
						bu_vls_printf( &str,
				  "value \"%s\" to argument %s isn't a float",
							       numstart,
							       sdp->sp_name );
						Tcl_AppendResult( interp,
							    bu_vls_addr(&str),
							    (char *)NULL );
						bu_vls_free( &str );
						return TCL_ERROR;
					}

					*dp++ = tmp_double;

					BU_SP_SKIP_SEP(cp);
				}
				Tcl_AppendResult( interp,
						  sdp->sp_count > 1 ? "{" : "",
						  argv[0],
						  sdp->sp_count > 1 ? "}" : "",
						  " ", (char *)NULL );
				break; }
			default: {
				struct bu_vls vls;

				bu_vls_init(&vls);
				bu_vls_printf(&vls,
				"%s line:%d Parse error, unknown format: '%s' for element \"%s\"",
				__FILE__, __LINE__, sdp->sp_fmt,
				sdp->sp_name);

				Tcl_AppendResult( interp, bu_vls_addr(&vls),
					(char *)NULL );

				bu_vls_free( &vls );
				return TCL_ERROR;
				}
			}

			if( sdp->sp_hook )  {
				sdp->sp_hook( sdp, sdp->sp_name, base, *argv);

			}
			--argc;
			++argv;


			break;
		}


		if( sdp->sp_name == NULL ) {
			bu_vls_trunc( &str, 0 );
			bu_vls_printf( &str, "invalid attribute %s\n", argv[0] );
			Tcl_AppendResult( interp, bu_vls_addr(&str),
					  (char *)NULL );
			bu_vls_free( &str );
			return TCL_ERROR;
		}
	}
	return TCL_OK;
}


/**
 *	bu_tcl_mem_barriercheck
 *
 *	A tcl wrapper for bu_mem_barriercheck.
 *
 * @@param clientData	- associated data/state
 * @@param interp		- tcl interpreter in which this command was registered.
 * @@param argc		- number of elements in argv
 * @@param argv		- command name and arguments
 *
 * @@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_mem_barriercheck(ClientData	clientData,
			Tcl_Interp	*interp,
			int		argc,
			char		**argv)
{
	int	ret;

	ret = bu_mem_barriercheck();
	if (ret < 0) {
		Tcl_AppendResult(interp, "bu_mem_barriercheck() failed\n", NULL);
		return TCL_ERROR;
	}
	return TCL_OK;
}


/**
 *	bu_tcl_ck_malloc_ptr
 *
 *	A tcl wrapper for bu_ck_malloc_ptr.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_ck_malloc_ptr(ClientData		clientData,
		     Tcl_Interp		*interp,
		     int		argc,
		     char		**argv)
{
	if( argc != 3 )  {
		Tcl_AppendResult( interp, "Usage: bu_ck_malloc_ptr ascii-ptr description\n");
		return TCL_ERROR;
	}
	bu_ck_malloc_ptr( (genptr_t)atol(argv[1]), argv[2] );
	return TCL_OK;
}


/**
 * 	bu_tcl_malloc_len_roundup
 *
 *	A tcl wrapper for bu_malloc_len_roundup.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@Return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_malloc_len_roundup(ClientData	clientData,
			  Tcl_Interp	*interp,
			  int		argc,
			  char		**argv)
{
	int	val;

	if( argc != 2 )  {
		Tcl_AppendResult(interp, "Usage: bu_malloc_len_roundup nbytes\n", NULL);
		return TCL_ERROR;
	}
	val = bu_malloc_len_roundup(atoi(argv[1]));
	Tcl_SetObjResult( interp, Tcl_NewIntObj(val) );
	return TCL_OK;
}


/**
 *	bu_tcl_prmem
 *
 *	A tcl wrapper for bu_prmem. Prints map of
 *	memory currently in use, to stderr.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_prmem(ClientData	clientData,
	     Tcl_Interp	*interp,
	     int	argc,
	     char	**argv)
{
	if (argc != 2) {
		Tcl_AppendResult(interp, "Usage: bu_prmem title\n");
		return TCL_ERROR;
	}
	bu_prmem(argv[1]);
	return TCL_OK;
}


/**
 *	bu_tcl_printb
 *
 *	A tcl wrapper for bu_vls_printb.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_printb(ClientData	clientData,
	      Tcl_Interp	*interp,
	      int		argc,
	      char		**argv)
{
	struct bu_vls	str;

	if (argc != 4) {
		Tcl_AppendResult(interp, "Usage: bu_printb title integer-to-format bit-format-string\n", NULL);
		return TCL_ERROR;
	}
	bu_vls_init(&str);
	bu_vls_printb(&str, argv[1], atoi(argv[2]), argv[3]);
	Tcl_SetResult(interp, bu_vls_addr(&str), TCL_VOLATILE);
	bu_vls_free(&str);
	return TCL_OK;
}


/**
 *	bu_get_value_by_keyword
 *
 *	Given arguments of alternating keywords and values
 *	and a specific keyword ("Iwant"),
 *	return the value associated with that keyword.
 *
 *	example:  bu_get_value_by_keyword Iwant az 35 elev 25 temp 9.6
 *
 *	If only one argument is given after the search keyword, it is interpreted
 *	as a list in the same format.
 *
 *	example:  bu_get_value_by_keyword Iwant {az 35 elev 25 temp 9.6}
 *
 *	Search order is left-to-right, only first match is returned.
 *
 *	Sample use:
 *		bu_get_value_by_keyword V8 [concat type [.inmem get box.s]]
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_get_value_by_keyword(ClientData	clientData,
			Tcl_Interp	*interp,
			int		argc,
			char		**argv)
{
	int	listc;
	char	**listv;
	register char	*iwant;
	char	**tofree = (char **)NULL;
	int	i;

	if( argc < 3 )  {
		char	buf[TINYBUFSIZ];
		snprintf(buf, TINYBUFSIZ, "%d", argc);
		Tcl_AppendResult( interp,
			"bu_get_value_by_keyword: wrong # of args (", buf, ").\n",
			"Usage: bu_get_value_by_keyword iwant {list}\n",
			"Usage: bu_get_value_by_keyword iwant key1 val1 key2 val2 ... keyN valN\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	iwant = argv[1];

	if( argc == 3 )  {
		if( Tcl_SplitList( interp, argv[2], &listc, (const char ***)&listv ) != TCL_OK )  {
			Tcl_AppendResult( interp,
				"bu_get_value_by_keyword: iwant='", iwant,
				"', unable to split '",
				argv[2], "'\n", (char *)NULL );
			return TCL_ERROR;
		}
		tofree = listv;
	} else {
		/* Take search list from remaining arguments */
		listc = argc - 2;
		listv = argv + 2;
	}

	if( (listc & 1) != 0 )  {
		char	buf[TINYBUFSIZ];
		snprintf(buf, TINYBUFSIZ, "%d", listc);
		Tcl_AppendResult( interp,
			"bu_get_value_by_keyword: odd # of items in list (", buf, ").\n",
			(char *)NULL );
		if(tofree) free( (char *)tofree );	/* not bu_free() */
		return TCL_ERROR;
	}

	for( i=0; i < listc; i += 2 )  {
		if( strcmp( iwant, listv[i] ) == 0 )  {
			/* If value is a list, don't nest it in another list */
			if( listv[i+1][0] == '{' )  {
				struct bu_vls	str;
				bu_vls_init( &str );
				/* Skip leading { */
				bu_vls_strcat( &str, &listv[i+1][1] );
				/* Trim trailing } */
				bu_vls_trunc( &str, -1 );
				Tcl_AppendResult( interp,
					bu_vls_addr(&str), (char *)NULL );
				bu_vls_free( &str );
			} else {
				Tcl_AppendResult( interp, listv[i+1], (char *)NULL );
			}
			if(tofree) free( (char *)tofree );	/* not bu_free() */
			return TCL_OK;
		}
	}

	/* Not found */
	Tcl_AppendResult( interp, "bu_get_value_by_keyword: keyword '",
		iwant, "' not found in list\n", (char *)NULL );
	if(tofree) free( (char *)tofree );	/* not bu_free() */
	return TCL_ERROR;
}


/**
 *	bu_get_all_keyword_values
 *
 *	Given arguments of alternating keywords and values,
 *	establish local variables named after the keywords, with the
 *	indicated values. Returns in interp a list of the variable
 *	names that were assigned to. This lets you detect at runtime
 *	what assignments were actually performed.
 *
 *	example:  bu_get_all_keyword_values az 35 elev 25 temp 9.6
 *
 *	This is much faster than writing this in raw Tcl 8 as:
 *
 *	foreach {keyword value} $list {
 *		set $keyword $value
 *		lappend retval $keyword
 *	}
 *
 *	If only one argument is given it is interpreted
 *	as a list in the same format.
 *
 *	example:  bu_get_all_keyword_values {az 35 elev 25 temp 9.6}
 *
 *	For security reasons, the name of the local variable assigned to
 *	is that of the input keyword with "key_" prepended.
 *	This prevents a playful user from overriding variables inside
 *	the function, e.g. loop iterator "i", etc.
 *	This could be even worse when called in global context.
 *
 *	Processing order is left-to-right, rightmost value for a repeated
 *	keyword will be the one used.
 *
 *	Sample use:
 *		bu_get_all_keyword_values [concat type [.inmem get box.s]]
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_get_all_keyword_values(ClientData	clientData,
			  Tcl_Interp	*interp,
			  int		argc,
			  char		**argv)
{
	struct bu_vls	variable;
	int	listc;
	char	**listv;
	char	**tofree = (char **)NULL;
	int	i;

	if( argc < 2 )  {
		char	buf[TINYBUFSIZ];
		snprintf(buf, TINYBUFSIZ, "%d", argc);
		Tcl_AppendResult( interp,
			"bu_get_all_keyword_values: wrong # of args (", buf, ").\n",
			"Usage: bu_get_all_keyword_values {list}\n",
			"Usage: bu_get_all_keyword_values key1 val1 key2 val2 ... keyN valN\n",
			(char *)NULL );
		return TCL_ERROR;
	}

	if( argc == 2 )  {
		if( Tcl_SplitList( interp, argv[1], &listc, (const char ***)&listv ) != TCL_OK )  {
			Tcl_AppendResult( interp,
				"bu_get_all_keyword_values: unable to split '",
				argv[1], "'\n", (char *)NULL );
			return TCL_ERROR;
		}
		tofree = listv;
	} else {
		/* Take search list from remaining arguments */
		listc = argc - 1;
		listv = argv + 1;
	}

	if( (listc & 1) != 0 )  {
		char	buf[TINYBUFSIZ];
		snprintf(buf, TINYBUFSIZ, "%d", listc);
		Tcl_AppendResult( interp,
			"bu_get_all_keyword_values: odd # of items in list (",
			buf, "), aborting.\n",
			(char *)NULL );
		if(tofree) free( (char *)tofree );	/* not bu_free() */
		return TCL_ERROR;
	}


	/* Process all the pairs */
	bu_vls_init( &variable );
	for( i=0; i < listc; i += 2 )  {
		bu_vls_strcpy( &variable, "key_" );
		bu_vls_strcat( &variable, listv[i] );
		/* If value is a list, don't nest it in another list */
		if( listv[i+1][0] == '{' )  {
			struct bu_vls	str;
			bu_vls_init( &str );
			/* Skip leading { */
			bu_vls_strcat( &str, &listv[i+1][1] );
			/* Trim trailing } */
			bu_vls_trunc( &str, -1 );
			Tcl_SetVar( interp, bu_vls_addr(&variable),
				bu_vls_addr(&str), 0);
			bu_vls_free( &str );
		} else {
			Tcl_SetVar( interp, bu_vls_addr(&variable),
				listv[i+1], 0 );
		}
		Tcl_AppendResult( interp, bu_vls_addr(&variable),
			" ", (char *)NULL );
		bu_vls_trunc( &variable, 0 );
	}

	/* All done */
	bu_vls_free( &variable );
	if(tofree) free( (char *)tofree );	/* not bu_free() */
	return TCL_OK;
}


/**
 *	bu_tcl_rgb_to_hsv
 *
 *	A tcl wrapper for bu_rgb_to_hsv.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_rgb_to_hsv(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	int		rgb_int[3];
	unsigned char	rgb[3];
	fastf_t		hsv[3];
	struct bu_vls	result;

	bu_vls_init(&result);
	if( argc != 4 )  {
		Tcl_AppendResult( interp, "Usage: bu_rgb_to_hsv R G B\n",
		    (char *)NULL );
		return TCL_ERROR;
	}
	if (( Tcl_GetInt( interp, argv[1], &rgb_int[0] ) != TCL_OK )
	    || ( Tcl_GetInt( interp, argv[2], &rgb_int[1] ) != TCL_OK )
	    || ( Tcl_GetInt( interp, argv[3], &rgb_int[2] ) != TCL_OK )
	    || ( rgb_int[0] < 0 ) || ( rgb_int[0] > 255 )
	    || ( rgb_int[1] < 0 ) || ( rgb_int[1] > 255 )
	    || ( rgb_int[2] < 0 ) || ( rgb_int[2] > 255 )) {
		bu_vls_printf(&result, "bu_rgb_to_hsv: Bad RGB (%s, %s, %s)\n",
			      argv[1], argv[2], argv[3]);
		Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
		bu_vls_free(&result);
		return TCL_ERROR;
	}
	rgb[0] = rgb_int[0];
	rgb[1] = rgb_int[1];
	rgb[2] = rgb_int[2];

	bu_rgb_to_hsv( rgb, hsv );
	bu_vls_printf(&result, "%g %g %g", V3ARGS(hsv));
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;

}


/**
 *	bu_tcl_hsv_to_rgb
 *
 *	A tcl wrapper for bu_hsv_to_rgb.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_hsv_to_rgb(ClientData	clientData,
		  Tcl_Interp	*interp,
		  int		argc,
		  char		**argv)
{
	fastf_t		hsv[3];
	unsigned char	rgb[3];
	struct bu_vls	result;

	if( argc != 4 )  {
		Tcl_AppendResult( interp, "Usage: bu_hsv_to_rgb H S V\n",
		    (char *)NULL );
		return TCL_ERROR;
	}
	bu_vls_init(&result);
	if (( Tcl_GetDouble( interp, argv[1], &hsv[0] ) != TCL_OK )
	 || ( Tcl_GetDouble( interp, argv[2], &hsv[1] ) != TCL_OK )
	 || ( Tcl_GetDouble( interp, argv[3], &hsv[2] ) != TCL_OK )
	 || ( bu_hsv_to_rgb( hsv, rgb ) == 0) ) {
		bu_vls_printf(&result, "bu_hsv_to_rgb: Bad HSV (%s, %s, %s)\n",
		    argv[1], argv[2], argv[3]);
		Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
		bu_vls_free(&result);
		return TCL_ERROR;
	}

	bu_vls_printf(&result, "%d %d %d", V3ARGS(rgb));
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;

}


/**
 *	bu_tcl_key_eq_to_key_val
 *
 *	Converts key=val to "key val" pairs.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_key_eq_to_key_val(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv)
{
	struct bu_vls vls;
	char *next;
	int i=0;

	bu_vls_init( &vls );

	while( ++i < argc )
	{
		if( bu_key_eq_to_key_val( argv[i], &next, &vls ) )
		{
			bu_vls_free( &vls );
			return TCL_ERROR;
		}

		if( i < argc - 1 )
			Tcl_AppendResult(interp, bu_vls_addr( &vls ) , " ", NULL );
		else
			Tcl_AppendResult(interp, bu_vls_addr( &vls ), NULL );

		bu_vls_trunc( &vls, 0 );
	}

	bu_vls_free( &vls );
	return TCL_OK;

}


/**
 *	bu_tcl_shader_to_key_val
 *
 *	Converts a shader string to a tcl list.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_shader_to_key_val(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv)
{
	struct bu_vls vls;

	bu_vls_init( &vls );

	if( bu_shader_to_tcl_list( argv[1], &vls ) )
	{
		bu_vls_free( &vls );
		return( TCL_ERROR );
	}

	Tcl_AppendResult(interp, bu_vls_addr( &vls ), NULL );

	bu_vls_free( &vls );

	return TCL_OK;

}


/**
 *	bu_tcl_key_val_to_key_eq
 *
 *	Converts "key value" pairs to key=value.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_key_val_to_key_eq(ClientData	clientData,
			 Tcl_Interp	*interp,
			 int		argc,
			 char		**argv)
{
	int i=0;

	for( i=1 ; i<argc ; i += 2 )
	{
		if( i+1 < argc-1 )
			Tcl_AppendResult(interp, argv[i], "=", argv[i+1], " ", NULL );
		else
			Tcl_AppendResult(interp, argv[i], "=", argv[i+1], NULL );

	}
	return TCL_OK;

}


/**
 *	bu_tcl_shader_to_key_eq
 *
 *	Converts a shader tcl list into a shader string.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_shader_to_key_eq(ClientData	clientData,
			Tcl_Interp	*interp,
			int		argc,
			char		**argv)
{
	struct bu_vls vls;


	bu_vls_init( &vls );

	if( bu_shader_to_key_eq( argv[1], &vls ) )
	{
		bu_vls_free( &vls );
		return TCL_ERROR;
	}

	Tcl_AppendResult(interp, bu_vls_addr( &vls ), NULL );

	bu_vls_free( &vls );

	return TCL_OK;
}


/**
 *	bu_tcl_brlcad_root
 *
 *	A tcl wrapper for bu_brlcad_root.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_brlcad_root(ClientData	clientData,
		   Tcl_Interp	*interp,
		   int		 argc,
		   char		**argv)
{
	if (argc != 2) {
		Tcl_AppendResult(interp, "Usage: bu_brlcad_root subdir\n",
				 (char *)NULL);
		return TCL_ERROR;
	}
	Tcl_AppendResult(interp, bu_brlcad_root(argv[1], 1), NULL);
	return TCL_OK;
}


/**
 *	bu_tcl_brlcad_data
 *
 *	A tcl wrapper for bu_brlcad_data.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_brlcad_data(ClientData	clientData,
		   Tcl_Interp	*interp,
		   int		 argc,
		   char		**argv)
{
	if (argc != 2) {
		Tcl_AppendResult(interp, "Usage: bu_brlcad_data subdir\n",
				 (char *)NULL);
		return TCL_ERROR;
	}
	Tcl_AppendResult(interp, bu_brlcad_data(argv[1], 1), NULL);
	return TCL_OK;
}


/**
 *	bu_tcl_units_conversion
 *
 *	A tcl wrapper for bu_units_conversion.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_units_conversion(ClientData	clientData,
			Tcl_Interp	*interp,
			int		argc,
			char		**argv)
{
	double conv_factor;
	struct bu_vls result;

	if (argc != 2) {
		Tcl_AppendResult(interp, "Usage: bu_units_conversion units_string\n",
				 (char *)NULL);
		return TCL_ERROR;
	}

	conv_factor = bu_units_conversion(argv[1]);
	if (conv_factor == 0.0) {
		Tcl_AppendResult(interp, "ERROR: bu_units_conversion: Unrecognized units string: ",
				 argv[1], "\n", (char *)NULL);
		return TCL_ERROR;
	}

	bu_vls_init(&result);
	bu_vls_printf(&result, "%.12e", conv_factor);
	Tcl_AppendResult(interp, bu_vls_addr(&result), (char *)NULL);
	bu_vls_free(&result);
	return TCL_OK;
}

/**
 *	bu_tcl_setup
 *
 *	Add all the supported Tcl interfaces to LIBBU routines to
 *	the list of commands known by the given interpreter.
 *
 *	@@param interp		- tcl interpreter in which this command was registered.
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
void
bu_tcl_setup(Tcl_Interp *interp)
{
	bu_register_cmds(interp, bu_cmds);

	Tcl_SetVar(interp, "BU_DEBUG_FORMAT", BU_DEBUG_FORMAT, TCL_GLOBAL_ONLY);
	Tcl_LinkVar(interp, "bu_debug", (char *)&bu_debug, TCL_LINK_INT );

	/* initialize command history objects */
	Cho_Init(interp);
}

/**
 *	Bu_Init
 *
 *	Allows LIBBU to be dynamically loaded to a vanilla tclsh/wish with
 *	"load /usr/brlcad/lib/libbu.so"
 *
 *	@@param interp		- tcl interpreter in which this command was registered.
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
#ifdef BRLCAD_DEBUG
Bu_d_Init(Tcl_Interp *interp)
#else
Bu_Init(Tcl_Interp *interp)
#endif
{
	bu_tcl_setup(interp);
#if 0
	bu_hook_list_init(&bu_log_hook_list);
	bu_hook_list_init(&bu_bomb_hook_list);
#endif
	return TCL_OK;
}
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.25
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.24 2007/10/01 07:54:50 brlcad Exp $ (ARL)";
a64 1
	{"bu_brlcad_path",		bu_tcl_brlcad_path},
a1314 28
 *	bu_tcl_brlcad_path
 *
 *	A tcl wrapper for bu_brlcad_path.
 *
 *	@@param clientData	- associated data/state
 *	@@param interp		- tcl interpreter in which this command was registered.
 *	@@param argc		- number of elements in argv
 *	@@param argv		- command name and arguments
 *
 *	@@return TCL_OK if successful, otherwise, TCL_ERROR.
 */
int
bu_tcl_brlcad_path(ClientData	clientData,
		   Tcl_Interp	*interp,
		   int		 argc,
		   char		**argv)
{
	if (argc != 2) {
		Tcl_AppendResult(interp, "Usage: bu_brlcad_path subdir\n",
				 (char *)NULL);
		return TCL_ERROR;
	}
	Tcl_AppendResult(interp, bu_brlcad_path(argv[1], 0), NULL);
	return TCL_OK;
}


/**
@


14.24
log
@fail quietly with bu_brlcad_data and bu_brlcad_root instead of verbosely ... could later add a --verbose option if it's really needed in scripting-land.
@
text
@d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.23 2007/09/15 16:23:08 brlcad Exp $ (ARL)";
a246 4

#if CRAY && !__STDC__
			loc = (char *)(base+((int)sdp->sp_offset*sizeof(int)));
#else
a247 1
#endif
@


14.23
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.22 2007/06/27 02:36:21 johnranderson Exp $ (ARL)";
d1287 1
a1287 1
	Tcl_AppendResult(interp, bu_brlcad_root(argv[1], 0), NULL);
d1315 1
a1315 1
	Tcl_AppendResult(interp, bu_brlcad_data(argv[1], 0), NULL);
@


14.22
log
@Eliminated more direct access of interp->result
@
text
@d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.21 2007/05/31 18:40:42 erikgreenwald Exp $ (ARL)";
d46 1
a46 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.21
log
@some sprintf->snprintf and some minor cleanup of magic numbers
@
text
@d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.20 2007/04/16 21:15:36 brlcad Exp $ (ARL)";
d721 1
a721 1
	sprintf(interp->result, "%d", val);
@


14.20
log
@revamp BRL-CAD's versioning setup.  no longer rely upon the vers.sh script, allowing for a more unified cross-platform configuration.  instead of globals, provide per-library functions that return the version string.  the version numbers are now stored in files in include/conf/.
@
text
@d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.19 2007/01/27 01:41:36 brlcad Exp $ (ARL)";
d60 2
d115 1
a115 1
	char	buf[256];
d118 1
a118 1
		sprintf(buf, "ERROR: NULL %s pointer in TCL interface, file %s, line %d\n",
d124 1
a124 1
		sprintf(buf, "ERROR: bad pointer in TCL interface x%lx: s/b %s(x%lx), was %s(x%lx), file %s, line %d\n",
d825 2
a826 2
		char	buf[32];
		sprintf(buf, "%d", argc);
d853 2
a854 2
		char	buf[32];
		sprintf(buf, "%d", listc);
d946 2
a947 2
		char	buf[32];
		sprintf(buf, "%d", argc);
d971 2
a972 2
		char	buf[32];
		sprintf(buf, "%d", listc);
@


14.19
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.18 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d60 1
d85 1
a93 1
 *
a134 2
 *
 *
a136 1
 *
a144 1
 *
a186 2
 *
 * NAME
d197 1
a198 1
 *
a200 1
 *
d637 1
a638 1
 *
a642 1
 *
d666 1
a667 1
 *
d693 1
a694 1
 *
a696 1
 *
a698 1
 *
a703 1
 *
d723 1
a724 2
 *
 *
a726 1
 *
a729 1
 *
a734 1
 *
d751 1
a752 2
 *
 *
a754 1
 *
a756 1
 *
d783 1
a784 2
 *
 *
a786 1
 *
a802 1
 *
a807 1
 *
d888 2
a889 3
/*****f* libbu/bu_tcl.c
 *
 *
a891 1
 *
a923 1
 *
a928 1
 *
d1011 1
a1012 2
 *
 *
a1014 1
 *
a1016 1
 *
d1065 1
a1066 2
 *
 *
a1068 1
 *
a1070 1
 *
a1075 1
 *
d1112 1
a1113 2
 *
 *
a1115 1
 *
a1117 1
 *
d1158 1
a1159 2
 *
 *
a1161 1
 *
a1163 1
 *
a1168 1
 *
d1195 1
a1196 2
 *
 *
a1198 1
 *
a1200 1
 *
a1205 1
 *
d1228 1
a1229 2
 *
 *
a1231 1
 *
a1233 1
 *
a1238 1
 *
a1266 2
 *
 *
a1268 1
 *
a1270 1
 *
a1294 2
 *
 *
a1296 1
 *
a1298 1
 *
a1322 2
 *
 *
a1324 1
 *
a1326 1
 *
a1350 2
 *
 *
a1352 1
 *
a1354 1
 *
a1391 2
 *
 *
a1393 1
 *
a1396 1
 *
a1398 1
 *
a1405 1
	Tcl_SetVar(interp, "bu_version", (char *)bu_version+5, TCL_GLOBAL_ONLY);	/* from vers.c */
a1413 2
 *
 *
a1415 1
 *
a1418 1
 *
a1420 1
 *
@


14.18
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.17 2007/01/21 04:45:41 brlcad Exp $ (ARL)";
d86 1
a86 1
 * 
d92 1
a92 1
 * 
d135 1
a135 1
 * 
d138 1
a138 1
 * 
d147 1
a147 1
 * 
d193 1
a193 1
 * 
d195 1
a195 1
 * 
d206 1
a206 1
 * 
d214 1
a214 1
 * 
d221 1
a221 1
 * 	@@retval TCL_OK if successful, 
d553 1
a553 1
	                           "value \"%s\" to argument %s isn't a float",
d649 1
a649 1
 * 
d683 1
a683 1
 * 
d704 1
a704 1
 * 
d707 1
a707 1
 * 
d713 1
a713 1
 * 
d735 1
a735 1
 * 
d738 1
a738 1
 * 
d742 1
a742 1
 * 
d748 1
a748 1
 * 
d767 1
a767 1
 * 
d770 1
a770 1
 * 
d773 1
a773 1
 * 
d778 1
a778 1
 * 
d802 1
a802 1
 * 
d805 1
a805 1
 * 
d822 1
a822 1
 * 
d828 1
a828 1
 * 
d911 1
a911 1
 * 
d914 1
a914 1
 * 
d947 1
a947 1
 * 
d953 1
a953 1
 * 
d1038 1
a1038 1
 * 
d1041 1
a1041 1
 * 
d1044 1
a1044 1
 * 
d1049 1
a1049 1
 * 
d1095 1
a1095 1
 * 
d1098 1
a1098 1
 * 
d1101 1
a1101 1
 * 
d1107 1
a1107 1
 * 
d1146 1
a1146 1
 * 
d1149 1
a1149 1
 * 
d1152 1
a1152 1
 * 
d1157 1
a1157 1
 * 
d1195 1
a1195 1
 * 
d1198 1
a1198 1
 * 
d1201 1
a1201 1
 * 
d1207 1
a1207 1
 * 
d1236 1
a1236 1
 * 
d1239 1
a1239 1
 * 
d1242 1
a1242 1
 * 
d1248 1
a1248 1
 * 
d1273 1
a1273 1
 * 
d1276 1
a1276 1
 * 
d1279 1
a1279 1
 * 
d1285 1
a1285 1
 * 
d1315 1
a1315 1
 * 
d1318 1
a1318 1
 * 
d1321 1
a1321 1
 * 
d1326 1
a1326 1
 * 
d1347 1
a1347 1
 * 
d1350 1
a1350 1
 * 
d1353 1
a1353 1
 * 
d1358 1
a1358 1
 * 
d1379 1
a1379 1
 * 
d1382 1
a1382 1
 * 
d1385 1
a1385 1
 * 
d1390 1
a1390 1
 * 
d1411 1
a1411 1
 * 
d1414 1
a1414 1
 * 
d1417 1
a1417 1
 * 
d1422 1
a1422 1
 * 
d1456 1
a1456 1
 * 
d1459 1
a1459 1
 * 
d1463 1
a1463 1
 * 
d1466 1
a1466 1
 * 
d1484 1
a1484 1
 * 
d1487 1
a1487 1
 * 
d1491 1
a1491 1
 * 
d1494 1
a1494 1
 * 
@


14.17
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.16 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.16
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup butcl */
/*@@{*/
d24 1
d39 1
a39 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.15 2006/08/31 05:50:24 lbutler Exp $ (ARL)";
d1512 1
a1512 1
/*@@}*/
@


14.15
log
@Mostly doxygen formatting.
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2006 United States Government as represented by
d39 1
a39 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.14 2006/03/24 19:59:08 brlcad Exp $ (ARL)";
@


14.14
log
@argument is incompatible with corresponding format string conversion, quell warnings by using long format specifiers instead
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d25 1
d31 1
a31 2
 * Author -
 *	Michael John Muuss
d33 2
a34 2
 * Source -
 *	The U. S. Army Research Laboratory
a36 1
/*@@}*/
d39 1
a39 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.13 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d85 3
a87 6
/*****f* libbu/bu_tcl.c
 *
 * NAME
 *	bu_badmagic_tcl
 *
 * SYNOPSIS
d93 7
a99 7
 * PARAMETERS
 *	interp	- tcl interpreter where result is stored
 *	ptr	- pointer to a data structure
 *	magic	- the correct/desired magic number
 *	str	- usually indicates the data structure name
 *	file	- file where this routine was called
 *	line	- line number in the above file
d101 2
a102 2
 * RETURN
 *	void
d134 1
a134 1
/*****f* libbu/bu_tcl.c
d136 1
a136 1
 * NAME
d139 1
a139 1
 * SYNOPSIS
d148 3
a150 3
 * PARAMETERS
 *	interp	- tcl interpreter
 *	sp	- structparse table
d152 2
a153 2
 * RETURN
 *	void
d190 1
a190 1
/*****d* libbu/bu_tcl.c
d194 1
a194 2
 *
 * SYNOPSIS
d196 2
a197 3
 *
 * PARAMETERS
 *	_cp	- character pointer
d203 1
a203 1
/*****f* libbu/bu_tcl.c
a204 1
 * NAME
d207 1
a207 1
 * SYNOPSIS
d215 6
a220 6
 * PARAMETERS
 *	interp	- tcl interpreter
 *	argc	- number of elements in argv
 *	argv	- contains the keyword-value pairs
 *	desc	- structure description
 *	base	- base addr of users struct
d222 2
a223 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d644 1
a644 1
/*****f* libbu/bu_tcl.c
a645 1
 * NAME
a647 1
 * SYNOPSIS
d650 5
a654 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d656 1
a656 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d674 1
a674 1
/*****f* libbu/bu_tcl.c
a675 1
 * NAME
a677 1
 * SYNOPSIS
d680 6
a685 8
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d701 1
a701 1
/*****f* libbu/bu_tcl.c
d703 1
a703 2
 * NAME
 *	bu_tcl_malloc_len_roundup
d705 1
a705 1
 * SYNOPSIS
d708 5
a712 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d714 2
a715 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d734 1
a734 1
/*****f* libbu/bu_tcl.c
d736 1
a736 1
 * NAME
d739 1
a739 1
 * SYNOPSIS
d743 5
a747 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d749 2
a750 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d766 1
a766 1
/*****f* libbu/bu_tcl.c
d768 1
a768 1
 * NAME
d771 1
a771 1
 * SYNOPSIS
d774 7
a780 8
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d801 1
a801 1
/*****f* libbu/bu_tcl.c
d803 1
a803 1
 * NAME
d806 1
a806 1
 * SYNOPSIS
d823 5
a827 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d829 2
a830 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d912 1
a912 1
 * NAME
d915 1
a915 1
 * SYNOPSIS
d948 5
a952 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d954 2
a955 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1037 1
a1037 1
/*****f* libbu/bu_tcl.c
d1039 1
a1039 1
 * NAME
d1042 1
a1042 1
 * SYNOPSIS
d1045 7
a1051 11
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
 */
/*
 *			B U _ T C L _ R G B _ T O _ H S V
d1094 1
a1094 1
/*****f* libbu/bu_tcl.c
d1096 1
a1096 1
 * NAME
d1099 1
a1099 1
 * SYNOPSIS
d1102 5
a1106 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d1108 2
a1109 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1145 1
a1145 1
/*****f* libbu/bu_tcl.c
d1147 1
a1147 1
 * NAME
d1150 1
a1150 1
 * SYNOPSIS
d1153 7
a1159 8
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1194 1
a1194 1
/*****f* libbu/bu_tcl.c
d1196 1
a1196 1
 * NAME
d1199 1
a1199 1
 * SYNOPSIS
d1202 5
a1206 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d1208 2
a1209 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1235 1
a1235 1
/*****f* libbu/bu_tcl.c
d1237 1
a1237 1
 * NAME
d1240 1
a1240 1
 * SYNOPSIS
d1243 5
a1247 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d1249 2
a1250 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1272 1
a1272 1
/*****f* libbu/bu_tcl.c
d1274 1
a1274 1
 * NAME
d1277 1
a1277 1
 * SYNOPSIS
d1280 5
a1284 5
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
d1286 2
a1287 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1314 1
a1314 1
/*****f* libbu/bu_tcl.c
d1316 1
a1316 1
 * NAME
d1319 1
a1319 1
 * SYNOPSIS
d1322 7
a1328 8
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1346 1
a1346 1
/*****f* libbu/bu_tcl.c
d1348 1
a1348 1
 * NAME
d1351 1
a1351 1
 * SYNOPSIS
d1354 7
a1360 8
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1378 1
a1378 1
/*****f* libbu/bu_tcl.c
d1380 1
a1380 1
 * NAME
d1383 1
a1383 1
 * SYNOPSIS
d1386 7
a1392 8
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1410 1
a1410 1
/*****f* libbu/bu_tcl.c
d1412 1
a1412 1
 * NAME
d1415 1
a1415 1
 * SYNOPSIS
d1418 7
a1424 8
 * PARAMETERS
 *	clientData	- associated data/state
 *	interp		- tcl interpreter in which this command was registered.
 *	argc		- number of elements in argv
 *	argv		- command name and arguments
 *
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1455 1
a1455 1
/*****f* libbu/bu_tcl.c
d1457 1
a1457 1
 * NAME
d1460 1
a1460 1
 * SYNOPSIS
d1464 2
a1465 2
 * PARAMETERS
 *	interp		- tcl interpreter in which this command was registered.
d1467 2
a1468 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1483 1
a1483 1
/*****f* libbu/bu_tcl.c
d1485 1
a1485 1
 * NAME
d1488 1
a1488 1
 * SYNOPSIS
d1492 2
a1493 2
 * PARAMETERS
 *	interp		- tcl interpreter in which this command was registered.
d1495 2
a1496 2
 * RETURN
 *	Returns TCL_OK if successful, otherwise, TCL_ERROR.
d1512 1
a1512 1

@


14.13
log
@update copyright to 2006
@
text
@d40 1
a40 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.12 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d177 1
a177 1
				bu_vls_printf(&str, "%%%ds", sp->sp_count);
d289 1
a289 1
						      "not enough values for \"%s\" argument: should be %d",
d343 1
a343 1
      "not enough values for \"%s\" argument: should have %d",
d372 1
a372 1
		      "not enough values for \"%s\" argument: should have %d",
d399 1
a399 1
							       argv,
d427 1
a427 1
      "not enough values for \"%s\" argument: should have %d",
d456 1
a456 1
		      "not enough values for \"%s\" argument: should have %d",
d483 1
a483 1
							       argv,
d512 1
a512 1
       "not enough values for \"%s\" argument: should have %d, only %d given",
d530 1
a530 1
       "not enough values for \"%s\" argument: should have %d, only %d given",
@


14.13.2.1
log
@update from HEAD
@
text
@d40 1
a40 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.13 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d177 1
a177 1
				bu_vls_printf(&str, "%%%lds", sp->sp_count);
d289 1
a289 1
						      "not enough values for \"%s\" argument: should be %ld",
d343 1
a343 1
      "not enough values for \"%s\" argument: should have %ld",
d372 1
a372 1
		      "not enough values for \"%s\" argument: should have %ld",
d399 1
a399 1
							       argv[0],
d427 1
a427 1
      "not enough values for \"%s\" argument: should have %ld",
d456 1
a456 1
		      "not enough values for \"%s\" argument: should have %ld",
d483 1
a483 1
							       argv[0],
d512 1
a512 1
       "not enough values for \"%s\" argument: should have %ld, only %d given",
d530 1
a530 1
       "not enough values for \"%s\" argument: should have %ld, only %d given",
@


14.12
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1998-2005 United States Government as represented by
d40 1
a40 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.11 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.11
log
@Doxygen changes
@
text
@d32 1
a32 1
 *  
d40 1
a40 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.10 2005/07/08 00:04:08 brlcad Exp $ (ARL)";
d119 3
a121 3
	if (!(ptr)) { 
		sprintf(buf, "ERROR: NULL %s pointer in TCL interface, file %s, line %d\n", 
			str, file, line); 
d125 2
a126 2
	if (*((long *)(ptr)) != (magic)) { 
		sprintf(buf, "ERROR: bad pointer in TCL interface x%lx: s/b %s(x%lx), was %s(x%lx), file %s, line %d\n", 
d130 1
a130 1
			file, line); 
d387 1
a387 1
						cp++; 
d397 1
a397 1
						bu_vls_printf( &str, 
d471 1
a471 1
						cp++; 
d481 1
a481 1
						bu_vls_printf( &str, 
d540 1
a540 1
					
d560 1
a560 1
						bu_vls_printf( &str, 
d589 1
a589 1
						bu_vls_printf( &str, 
d599 1
a599 1
					
d637 1
a637 1
		
d918 1
a918 1
	
d1046 1
a1046 1
	
d1111 1
a1111 1
	
d1162 1
a1162 1
	
@


14.11.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d32 1
a32 1
 *
d40 1
a40 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header$ (ARL)";
d119 3
a121 3
	if (!(ptr)) {
		sprintf(buf, "ERROR: NULL %s pointer in TCL interface, file %s, line %d\n",
			str, file, line);
d125 2
a126 2
	if (*((long *)(ptr)) != (magic)) {
		sprintf(buf, "ERROR: bad pointer in TCL interface x%lx: s/b %s(x%lx), was %s(x%lx), file %s, line %d\n",
d130 1
a130 1
			file, line);
d387 1
a387 1
						cp++;
d397 1
a397 1
						bu_vls_printf( &str,
d471 1
a471 1
						cp++;
d481 1
a481 1
						bu_vls_printf( &str,
d540 1
a540 1

d560 1
a560 1
						bu_vls_printf( &str,
d589 1
a589 1
						bu_vls_printf( &str,
d599 1
a599 1

d637 1
a637 1

d918 1
a918 1

d1046 1
a1046 1

d1111 1
a1111 1

d1162 1
a1162 1

@


14.10
log
@add tcl hook functions for bu_tcl_brlcad_root and bu_tcl_brlcad_data for their corresponding tcl commands
@
text
@d21 3
a24 1
 *
d37 2
d40 1
a40 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.9 2005/03/24 16:08:12 bob1961 Exp $ (ARL)";
@


14.9
log
@Add cpp directives to optionally compile Bu_d_Init
@
text
@d36 1
a36 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.8 2005/01/30 20:30:45 brlcad Exp $ (ARL)";
a38 1

d45 1
a45 1
#include <string.h>
d47 1
a47 1
#include <strings.h>
a51 1

d56 1
d63 1
d65 1
d1330 67
d1429 1
@


14.8
log
@update copyright to 2005
@
text
@d36 1
a36 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bu_tcl.c,v 14.7 2004/12/21 07:32:30 morrison Exp $ (ARL)";
d1451 3
d1455 1
@


14.7
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 United States Government as represented by
d36 1
a36 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 14.6 2004/12/21 06:58:42 morrison Exp $ (ARL)";
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a33 2
 *  
 *
d36 1
a36 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 14.5 2004/12/21 06:44:32 morrison Exp $ (ARL)";
@


14.5
log
@remove the old distribution notice section
@
text
@a35 3
 * Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d38 1
a38 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a34 4
 * Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
d41 1
a41 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 14.3 2004/12/21 05:45:20 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d45 1
a45 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d45 1
a45 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 2
a2 1
/*****h* libbu/cmd.c
d4 18
a21 2
 * NAME
 *	B U _ T C L . C
a22 1
 * SYNOPSIS
d45 1
a45 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 1.6 2004/10/14 21:54:33 morrison Exp $ (ARL)";
@


1.6
log
@missed one of the little bu_brlcad_path buggers
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 1.5 2004/09/15 05:39:14 morrison Exp $ (ARL)";
d1453 10
@


1.5
log
@make bu_structparse_get_terse_form() take a constant pointer to quell warnings
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 1.4 2004/09/07 22:39:28 kermit Exp $ (ARL)";
d1350 1
a1350 1
	Tcl_AppendResult(interp, bu_brlcad_path(argv[1]), NULL);
@


1.4
log
@Changed atoi to atol to accomodate IA64.  What a hack, converting pointers
from integers from strings, crazy mon.
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 1.3 2004/09/03 23:30:57 morrison Exp $ (ARL)";
d149 1
a149 1
			      register struct bu_structparse	*sp)
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 1.2 2004/08/02 23:01:48 morrison Exp $ (ARL)";
d35 1
a35 2


d699 1
a699 1
	bu_ck_malloc_ptr( (void *)atoi(argv[1]), argv[2] );
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bu_tcl.c,v 1.1 2004/05/20 15:19:31 morrison Exp $ (ARL)";
d39 1
a39 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d29 1
a29 1
static const char libbu_bu_tcl_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/bu_tcl.c,v 1.38 2004/05/10 15:30:44 erikg Exp $ (ARL)";
d33 1
a33 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

