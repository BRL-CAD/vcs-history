head	14.24;
access;
symbols
	rel-7-10-4:14.20
	STABLE:14.20.0.2
	stable-branch:14.6
	rel-7-10-2:14.20
	rel-7-10-0:14.17
	rel-7-8-4:14.14
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.7
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.24
date	2007.12.14.13.21.48;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.12.09.00.37.55;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.12.07.05.17.52;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.10.22.14.25.06;	author erikgreenwald;	state Exp;
branches;
next	14.20;

14.20
date	2007.06.03.00.19.31;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.05.25.01.07.29;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.21.04.19.41;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2006.09.03.15.14.07;	author lbutler;	state Exp;
branches;
next	14.13;

14.13
date	2006.08.31.23.16.39;	author lbutler;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.22.18.37.08;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.9.4.1;
next	14.8;

14.8
date	2005.06.15.04.34.52;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.05.28.02.14.50;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.46;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.28.33;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.35;	author morrison;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.24
log
@use bu_temp_file instead of mkstemp directly, ws on sgi section
@
text
@/*                     S E M A P H O R E . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup thread */
/** @@{ */
/** @@file semaphore.c
 *
 *  @@brief semaphore implementation
 *
 *  Machine-specific routines for parallel processing.
 *  Primarily for handling semaphores for critical sections.
 *
 *  The new paradigm:  semaphores are referred to, not by a pointer,
 *  but by a small integer.  This module is now responsible for obtaining
 *  whatever storage is needed to implement each semaphore.
 *
 *  Note that these routines can't use bu_log() for error logging,
 *  because bu_log() accquires semaphore #0 (BU_SEM_SYSCALL).
 */


#ifndef lint
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.23 2007/12/09 00:37:55 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include "machine.h"
#include "bu.h"

#ifdef CRAY
# include <sys/category.h>
# include <sys/resource.h>
# include <sys/types.h>
# ifdef CRAY1
#  include <sys/machd.h>	/* For HZ */
# endif
struct bu_semaphores {
	long	magic;
	long	p;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

#ifdef CRAY2
#undef MAXINT
# include <sys/param.h>
#endif

#if defined(alliant) && !defined(i860)
/* Alliant FX/8 */
# include <cncall.h>
struct bu_semaphores {
	long	magic;
	char	c;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

#if (defined(sgi) && defined(mips)) || (defined(__sgi) && defined(__mips))
# define SGI_4D	1
# define _SGI_SOURCE	1	/* IRIX 5.0.1 needs this to def M_BLKSZ */
# define _BSD_TYPES	1	/* IRIX 5.0.1 botch in sys/prctl.h */
# include <sys/types.h>
# include <ulocks.h>
/* ulocks.h #include's <limits.h> and <malloc.h> */
/* ulocks.h #include's <task.h> for getpid stuff */
/* task.h #include's <sys/prctl.h> */
# include <malloc.h>
/* <malloc.h> #include's <stddef.h> */

#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif

static char bu_lockfile[MAXPATHLEN] = {0};

static usptr_t		*bu_lockstuff = 0;
extern int		_utrace;

struct bu_semaphores {
	long	magic;
	ulock_t	ltp;
};
# define DEFINED_BU_SEMAPHORES	1
#endif /* SGI_4D */

/* XXX Probably need to set _SGI_MP_SOURCE in machine.h */

#ifdef ardent
#	include <thread.h>
struct bu_semaphores {
	long	magic;
	char	sem;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

#if defined(convex) || defined(__convex__)
struct bu_semaphores {
	long	magic;
	long	sem;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

#if defined(n16)
#	include <parallel.h>
#	include <sys/sysadmin.h>
struct bu_semaphores {
	long	magic;
	char	sem;
};
# define DEFINED_BU_SEMAPHORES	1
#endif

/*
 * multithreading support for SunOS 5.X / Solaris 2.x
 */
#if SUNOS >= 52
#	include <sys/unistd.h>
#	include <thread.h>
#	include <synch.h>
struct bu_semaphores {
	long	magic;
	mutex_t	mu;
};
# define DEFINED_BU_SEMAPHORES	1
#endif	/* SUNOS */

/*
 * multithread support built on POSIX Threads (pthread) library.
 */
#ifdef HAVE_UNISTD_H
#	include	<unistd.h>
#else
#  ifdef HAVE_SYS_UNISTD_H
#	include <sys/unistd.h>
#  endif
#endif
#ifdef HAVE_PTHREAD_H
#	include <pthread.h>
#  if !defined(sgi)
struct bu_semaphores {
	long	magic;
	pthread_mutex_t	mu;
};
#	define DEFINED_BU_SEMAPHORES	1
#  endif
#endif


#define	BU_SEMAPHORE_MAGIC		0x62757365

#if defined(SGI_4D)
/**
 *			 B U _ S E M A P H O R E _ S G I _ I N I T
 */
static void
bu_semaphore_sgi_init()
{
    FILE *fp;
    /*
     *  First time through.
     *  Use this opportunity to tune malloc().  It needs it!
     *  Default for M_BLKSZ is 8k.
     */
    if (mallopt( M_BLKSZ, 128*1024) != 0) {
	fprintf(stderr, "bu_semaphore_sgi_init: mallopt() failed\n");
    }
    
    /* Now, set up the lock arena */
    fp = bu_temp_file(bu_lockfile, MAXPATHLEN);
    
    if( bu_debug & BU_DEBUG_PARALLEL )  {
	if( usconfig( CONF_LOCKTYPE, _USDEBUGPLUS ) == -1 )
	    perror("usconfig CONF_LOCKTYPE");
    }
    /*
     *  Note that libc mp debugging to stderr can be enabled by saying
     *	int _utrace=1;
     */
    
    /* Cause lock file to vanish on exit */
    usconfig(CONF_ARENATYPE, US_SHAREDONLY);
    
    /* Set maximum number of procs that can share this arena */
    usconfig(CONF_INITUSERS, bu_avail_cpus()+1);
    
    if( bu_debug & BU_DEBUG_PARALLEL )  {
	/* This is a big performance hit, but may find bugs */
	usconfig(CONF_LOCKTYPE, US_DEBUG);
    } else {
	usconfig(CONF_LOCKTYPE, US_NODEBUG);
    }
    
    /* Initialize arena */
    bu_lockstuff = usinit(bu_lockfile);
    if (bu_lockstuff == 0) {
	perror("usinit");
	fprintf(stderr, "bu_semaphore_sgi_init: usinit(%s) failed, unable to allocate lock space\n", bu_lockfile);
	bu_bomb("fatal semaphore initialization failure");
    }
}
#endif

#if defined(convex) || defined(__convex__)
/**
 *			B U _ C O N V E X _ A C Q U I R E
 */
static void
bu_convex_acquire(p)
register long *p;
{
	asm("getlck:");
	asm("	tas	@@0(ap)");	/* try to set the lock */
	asm("	jbra.f	getlck");	/* loop until successful */
}
#endif /* convex */

#if defined(PARALLEL) || defined(DEFINED_BU_SEMAPHORES)
static unsigned int		bu_nsemaphores = 0;
static struct bu_semaphores	*bu_semaphores = (struct bu_semaphores *)NULL;
#endif

/**
 *			B U _ S E M A P H O R E _ I N I T
 *
 *  Prepare 'nsemaphores' independent critical section semaphores.
 *  Die on error.
 *  Takes the place of 'n' separate calls to old RES_INIT().
 *  Start by allocating array of "struct bu_semaphores", which has been
 *  arranged to contain whatever this system needs.
 *
 */
void
bu_semaphore_init(unsigned int nsemaphores)
{
#if !defined(PARALLEL) && !defined(DEFINED_BU_SEMAPHORES)
	return;					/* No support on this hardware */
#else
	unsigned int	i;

	if( bu_nsemaphores != 0 )  return;	/* Already called */
	bu_semaphores = (struct bu_semaphores *)calloc(nsemaphores, sizeof(struct bu_semaphores) );
	if( !bu_semaphores )  {
		fprintf(stderr, "bu_semaphore_init(): could not allocate space for %d semaphores of len %ld\n",
			nsemaphores, (long)sizeof(struct bu_semaphores));
		exit(2);
	}

	/*
	 *  Begin vendor-specific initialization sections.
	 */

#	if defined(alliant)
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		(void) initialize_lock( &bu_semaphores[i].c );
	}
#	endif

#	ifdef ardent
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		bu_semaphores[i].sem = 1;	/* mark as released */
	}
#	endif

#	if defined(convex) || defined(__convex__)
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		bu_semaphores[i].sem = 0;	/* mark as released */
	}
#	endif

#	ifdef CRAY
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		LOCKASGN( &bu_semaphores[i].p );
	}
#	endif /* CRAY */

#	if defined(n16)
	/*
	 *			Encore MultiMax.
	 *  While the manual suggests that one should use spin_create()
	 *  to aquire a new control structure for spin locking, it turns
	 *  out that the library support for that simply malloc()s a 1-byte
	 *  area to contain the lock, and sets it to PAR_UNLOCKED.
	 */
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		bu_semaphores[i].sem = PAR_UNLOCKED;
	}
#	endif

#	ifdef SGI_4D
	bu_semaphore_sgi_init();
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		if( (bu_semaphores[i].ltp = usnewlock(bu_lockstuff)) == NULL )  {
			perror("usnewlock");
			fprintf(stderr, "bu_semaphore_init: usnewlock() failed, unable to allocate lock [%d]\n", i);
			bu_bomb("fatal semaphore initialization failure");
		}
	}
#	endif

#	if SUNOS
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		if (mutex_init( &bu_semaphores[i].mu, USYNC_THREAD, NULL)) {
			fprintf(stderr, "bu_semaphore_init(): mutex_init() failed on [%d]\n", i);
			bu_bomb("fatal semaphore acquisition failure");
		}

	}
#	endif
#	if defined(HAVE_PTHREAD_H) && !defined(sgi)
	for( i=0; i < nsemaphores; i++ )  {
		bu_semaphores[i].magic = BU_SEMAPHORE_MAGIC;
		if (pthread_mutex_init( &bu_semaphores[i].mu,  NULL)) {
			fprintf(stderr, "bu_semaphore_init(): pthread_mutex_init() failed on [%d]\n", i);
			bu_bomb("fatal semaphore acquisition failure");
		}
	}
#	endif

	/*
	 *  This should be last thing done before returning, so that
	 *  any subroutines called (e.g. bu_calloc()) won't think that
	 *  parallel operation has begun yet, and do acquire/release.
	 */
	bu_nsemaphores = nsemaphores;
#endif	/* PARALLEL */
}

/**
 *			B U _ S E M A P H O R E _ A C Q U I R E
 */
void
bu_semaphore_acquire(unsigned int i)
{
#if !defined(PARALLEL) && !defined(DEFINED_BU_SEMAPHORES)
	return;					/* No support on this hardware */
#else
	if (bu_semaphores == NULL) {
		/* Semaphores not initialized yet.  Must be non-parallel */
		return;
	}

	BU_CKMAG(bu_semaphores, BU_SEMAPHORE_MAGIC, "bu_semaphore");

	if (i >= bu_nsemaphores) {
		fprintf(stderr, "bu_semaphore_acquire(%d): semaphore # exceeds max of %d\n",
			i, bu_nsemaphores - 1);
		bu_bomb("fatal semaphore acquisition failure");
	}

	BU_CKMAG(&bu_semaphores[i], BU_SEMAPHORE_MAGIC, "bu_semaphore");

	/*
	 *  Begin vendor-specific initialization sections.
	 */

#	if defined(alliant)
	(void) lock( &bu_semaphores[i].c );
#	endif

#	ifdef ardent
	{
		register long	*p = &bu_semaphores[i].sem;
		while( SYNCH_Adr = p, !SYNCH_Val )  while( !*p );
	}
#	endif

#	if defined(convex) || defined(__convex__)
	bu_convex_acquire( &bu_semaphores[i].sem );
#	endif

#	ifdef CRAY
	LOCKON( &bu_semaphores[i].p );
#	endif /* CRAY */

#	if defined(n16)
	(void)spin_lock( (LOCK *)&bu_semaphores[i].sem );
#	endif

#	ifdef SGI_4D
	uswsetlock( bu_semaphores[i].ltp, 1000);
#	endif

#	if SUNOS
	if (mutex_lock(&bu_semaphores[i].mu)) {
		fprintf(stderr, "bu_semaphore_acquire(): mutex_lock() failed on [%d]\n", i);
		bu_bomb("fatal semaphore acquisition failure");
	}
#	endif
#	if defined(HAVE_PTHREAD_H) && !defined(sgi)
	if (pthread_mutex_lock(&bu_semaphores[i].mu)) {
		fprintf(stderr, "bu_semaphore_acquire(): pthread_mutex_lock() failed on [%d]\n", i);
		bu_bomb("fatal semaphore acquisition failure");
	}
#	endif

#endif
}

/**
 *			B U _ S E M A P H O R E _ R E L E A S E
 */
void
bu_semaphore_release(unsigned int i)
{
#if !defined(PARALLEL) && !defined(DEFINED_BU_SEMAPHORES)
	return;					/* No support on this hardware */
#else
	if( bu_semaphores == NULL )  {
		/* Semaphores not initialized yet.  Must be non-parallel */
		return;
	}

	BU_CKMAG(bu_semaphores, BU_SEMAPHORE_MAGIC, "bu_semaphore");

	if( i >= bu_nsemaphores )  {
		fprintf(stderr, "bu_semaphore_release(%d): semaphore # exceeds max of %d\n",
			i, bu_nsemaphores - 1);
		exit(3);
	}

	BU_CKMAG(&bu_semaphores[i], BU_SEMAPHORE_MAGIC, "bu_semaphore");

	/*
	 *  Begin vendor-specific initialization sections.
	 */

#	if defined(alliant)
	(void) unlock( &bu_semaphores[i].c );
#	endif

#	ifdef ardent
	bu_semaphores[i].sem = 1;	/* release */
#	endif

#	if defined(convex) || defined(__convex__)
	bu_semaphores[i].sem = 0;	/* release */
#	endif

#	ifdef CRAY
	LOCKOFF( &bu_semaphores[i].p );
#	endif /* CRAY */

#	if defined(n16)
	(void)spin_unlock( (LOCK *)&bu_semaphores[i].sem );
#	endif

#	ifdef SGI_4D
	usunsetlock( bu_semaphores[i].ltp );
#	endif

#	if SUNOS
	if( mutex_unlock( &bu_semaphores[i].mu ) )  {
		fprintf(stderr, "bu_semaphore_acquire(): mutex_unlock() failed on [%d]\n", i);
		bu_bomb("fatal semaphore acquisition failure");
	}
#	endif
#	if defined(HAVE_PTHREAD_H) && !defined (sgi)
	if( pthread_mutex_unlock( &bu_semaphores[i].mu ) )  {
		fprintf(stderr, "bu_semaphore_acquire(): pthread_mutex_unlock() failed on [%d]\n", i);
		bu_bomb("fatal semaphore acquisition failure");
	}
#	endif
#endif
}

/* XXX need a routine to pair up with _init() to delete the semaphore structures */
#if 0
void
bu_semaphore_free() {
    if (bu_semaphores) {
        free(bu_semaphores);
	bu_semaphores = (struct bu_semaphores *)NULL;
    }
}
#endif

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@use mkstemp instead of mktemp since we can (old sgi section)
@
text
@d39 1
a39 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.22 2007/12/07 05:17:52 brlcad Exp $ (ARL)";
d96 1
a96 5
#ifdef _WIN32
static char		bu_lockfile[] = "C:\\bu_lockXXXXXX";
#else
static char		bu_lockfile[] = "/usr/tmp/bu_lockXXXXXX";
#endif
d182 6
a187 5
	/*
	 *  First time through.
	 *  Use this opportunity to tune malloc().  It needs it!
	 *  Default for M_BLKSZ is 8k.
	 */
d191 33
a223 32

	/* Now, set up the lock arena */
	mkstemp(bu_lockfile);
	if( bu_debug & BU_DEBUG_PARALLEL )  {
		if( usconfig( CONF_LOCKTYPE, _USDEBUGPLUS ) == -1 )
			perror("usconfig CONF_LOCKTYPE");
	}
	/*
	 *  Note that libc mp debugging to stderr can be enabled by saying
	 *	int _utrace=1;
	 */

	/* Cause lock file to vanish on exit */
	usconfig(CONF_ARENATYPE, US_SHAREDONLY);

	/* Set maximum number of procs that can share this arena */
	usconfig(CONF_INITUSERS, bu_avail_cpus()+1);

	if( bu_debug & BU_DEBUG_PARALLEL )  {
		/* This is a big performance hit, but may find bugs */
		usconfig(CONF_LOCKTYPE, US_DEBUG);
	} else {
		usconfig(CONF_LOCKTYPE, US_NODEBUG);
	}

	/* Initialize arena */
	bu_lockstuff = usinit(bu_lockfile);
	if (bu_lockstuff == 0) {
		perror("usinit");
		fprintf(stderr, "bu_semaphore_sgi_init: usinit(%s) failed, unable to allocate lock space\n", bu_lockfile);
		bu_bomb("fatal semaphore initialization failure");
	}
@


14.22
log
@don't mention compat4.h
@
text
@d39 1
a39 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.21 2007/10/22 14:25:06 erikgreenwald Exp $ (ARL)";
d196 1
a196 1
	(void)mktemp(bu_lockfile);
@


14.21
log
@make i unsigned to match nsemaphores
@
text
@a34 10
 *
 *  For code conversion hints, see "h/compat4.h"
 *
 *  @@author
 *	Michael John Muuss
 *
 *  @@par Source -
 *	The U. S. Army Research Laboratory
 * @@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
d39 1
a39 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.20 2007/06/03 00:19:31 brlcad Exp $ (ARL)";
@


14.20
log
@should be fine to use bu_bomb instead of abort as bu_bomb should not attempt to acquire a semaphore (it doesn't use bu_log).
@
text
@d49 1
a49 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.19 2007/05/25 01:07:29 brlcad Exp $ (ARL)";
d274 1
a274 1
	int	i;
@


14.19
log
@fix raytrace synchronization bug introduced via valgrinding.  release pairs up with acquire, not init.  need some other (new) routine to release the memory allocated during init and probably some atexit() handler to free that memory.
@
text
@d49 1
a49 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.18 2007/05/21 04:19:41 brlcad Exp $ (ARL)";
d201 3
a203 2
	if( mallopt( M_BLKSZ, 128*1024 ) != 0 )
		fprintf(stderr, "bu_semaphore_sgi_init: mallopt() failed\n");
d234 1
a234 1
		exit(2);
d336 2
a337 2
			fprintf(stderr, "bu_semaphore_init: usnewlock() failed, unable to allocate lock %d\n", i);
			exit(2);
d346 2
a347 2
			fprintf(stderr, "bu_semaphore_init(): mutex_init() failed on %d\n", i);
			abort();
d356 2
a357 2
			fprintf(stderr, "bu_semaphore_init(): pthread_mutex_init() failed on %d\n", i);
			abort();
d380 1
a380 1
	if( bu_semaphores == NULL )  {
d387 1
a387 1
	if( i >= bu_nsemaphores )  {
d389 2
a390 2
			i, bu_nsemaphores);
		abort();
d427 3
a429 3
	if( mutex_lock( &bu_semaphores[i].mu ) )  {
		fprintf(stderr, "bu_semaphore_acquire(): mutex_lock() failed on %d\n", i);
		abort();
d433 3
a435 3
	if( pthread_mutex_lock( &bu_semaphores[i].mu ) )  {
		fprintf(stderr, "bu_semaphore_acquire(): pthread_mutex_lock() failed on %d\n", i);
		abort();
d460 1
a460 1
			i, bu_nsemaphores);
d496 2
a497 2
		fprintf(stderr, "bu_semaphore_acquire(): mutex_unlock() failed on %d\n", i);
		abort();
d502 2
a503 2
		fprintf(stderr, "bu_semaphore_acquire(): pthread_mutex_unlock() failed on %d\n", i);
		abort();
@


14.18
log
@free the semaphore structures we allocated
@
text
@d49 1
a49 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.17 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d505 2
d508 9
a516 4
	if (bu_semaphores) {
	    free(bu_semaphores);
	    bu_semaphores = (struct bu_semaphores *)NULL;
	}
d518 1
a518 1
}
@


14.17
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d49 1
a49 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.16 2007/01/21 04:45:42 brlcad Exp $ (ARL)";
d276 1
a276 3
	bu_semaphores = (struct bu_semaphores *)calloc(
		nsemaphores,
		sizeof(struct bu_semaphores) );
d505 5
@


14.16
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d49 1
a49 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.15 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.15
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup thread */
/*@@{*/
d24 2
a25 1
 *@@brief semaphore implementation
d50 1
a50 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.14 2006/09/03 15:14:07 lbutler Exp $ (ARL)";
d510 1
a510 1
/*@@}*/
@


14.14
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d50 1
a50 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.13 2006/08/31 23:16:39 lbutler Exp $ (ARL)";
@


14.13
log
@Doxygen comments
@
text
@d25 2
d50 1
a50 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.12 2006/01/22 18:37:08 brlcad Exp $ (ARL)";
@


14.12
log
@missing stdlib.h for malloc (only a few files that should be using malloc instead of bu_malloc)
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d37 1
a37 1
 *  Author -
d40 1
a40 1
 *  Source -
d42 1
a42 1
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
d45 1
a45 1
/*@@}*/
d48 1
a48 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.11 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d189 1
a189 1
/*
d238 1
a238 1
/*
d256 1
a256 1
/*
d371 1
a371 1
/*
d442 1
a442 1
/*
d508 1
a508 1

@


14.11
log
@update copyright to 2006
@
text
@d48 1
a48 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.10 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d53 1
a53 2


@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d48 1
a48 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.9 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.9
log
@Doxygen changes
@
text
@d39 1
a39 1
 *  
d43 1
a43 1
 *  
d48 1
a48 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.8 2005/06/15 04:34:52 brlcad Exp $ (ARL)";
d289 1
a289 1
#	if defined(alliant)	
d350 1
a350 1
		
d400 1
a400 1
#	if defined(alliant)	
d471 1
a471 1
#	if defined(alliant)	
@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d39 1
a39 1
 *
d43 1
a43 1
 *
d48 1
a48 1
static const char RCSsemaphore[] = "@@(#)$Header$ (ARL)";
d289 1
a289 1
#	if defined(alliant)
d350 1
a350 1

d400 1
a400 1
#	if defined(alliant)
d471 1
a471 1
#	if defined(alliant)
@


14.8
log
@protect the sys/wait.h headers with HAVE_SYS_WAIT_H since not all systems (e.g. mingw) have it.
@
text
@d21 3
a24 1
 *
d45 2
d48 1
a48 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.7 2005/05/28 02:14:50 brlcad Exp $ (ARL)";
@


14.7
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d44 1
a44 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.6 2005/01/30 20:30:46 brlcad Exp $ (ARL)";
d98 3
a100 1
#include <sys/wait.h>
@


14.6
log
@update copyright to 2005
@
text
@d44 1
a44 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/semaphore.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
d100 3
a102 1
#ifndef WIN32
a103 2
#else
static char		bu_lockfile[] = "C:\\bu_lockXXXXXX";
d105 1
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d44 1
a44 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvs/brlcad/src/libbu/semaphore.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a41 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d44 1
a44 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvs/brlcad/src/libbu/semaphore.c,v 14.3 2004/12/21 05:45:21 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d46 1
a46 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvs/brlcad/src/libbu/semaphore.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d46 1
a46 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvs/brlcad/src/libbu/semaphore.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			S E M A P H O R E . C
d46 1
a46 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvs/brlcad/src/libbu/semaphore.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (ARL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvs/brlcad/src/libbu/semaphore.c,v 1.2 2004/06/08 19:28:33 morrison Exp $ (ARL)";
d485 10
@


1.2
log
@use HAVE_UNISTD_H and HAVE_PTHREAD_H instead of generic HAS_POSIX_THREADS
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header$ (ARL)";
d30 1
a30 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d27 1
a27 1
static const char RCSsemaphore[] = "@@(#)$Header: /cvs/brlcad/libbu/semaphore.c,v 1.20 2004/05/10 15:30:44 erikg Exp $ (ARL)";
a39 1
#include "externs.h"
d143 4
a146 2
#if defined(HAS_POSIX_THREADS)
#ifdef __sp3__
d149 1
d151 1
d153 1
d155 1
d160 4
a163 2
# define DEFINED_BU_SEMAPHORES	1
#endif	/* HAS_POSIX_THREADS */
d331 1
a331 1
#	if HAS_POSIX_THREADS
d411 1
a411 1
#	if HAS_POSIX_THREADS
d479 1
a479 1
#	if HAS_POSIX_THREADS
@

