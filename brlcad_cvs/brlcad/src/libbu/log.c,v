head	14.24;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.6
	rel-7-10-2:14.16
	rel-7-10-0:14.16
	rel-7-8-4:14.12
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.4
	rel-7-6-0:14.8
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.2
	bobWinPort:14.8.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.24
date	2007.12.19.23.02.20;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.12.19.22.29.22;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.12.19.21.44.50;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.12.04.01.36.14;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.12.03.22.57.58;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.22.00.55.09;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.10.17.01.28.47;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.09;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.09.03.15.14.07;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.31.23.16.38;	author lbutler;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.8.4.1;
next	14.7;

14.7
date	2005.06.30.05.57.36;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.45;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.28.50;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.33;	author morrison;	state Exp;
branches;
next	;

14.8.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.24
log
@do the same protections to bu_putchar that bu_log had to try stdout if stderr fails or is unavailable.  instead of blindly trying stdout/stderr, make sure they're not NULL FILE pointers first and fail accordingly.
@
text
@/*                           L O G . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup bu_log */
/** @@{ */
/** @@file log.c
 *
 * @@brief parallel safe version of fprintf for logging
 *
 *  BRL-CAD support library, error logging routine.
 *  Note that the user may provide his own logging routine,
 *  by replacing these functions.  That is why this is in file of it's own.
 *  For example, LGT and RTSRV take advantage of this.
 *
 * @@par  Primary Functions (replacements MUST implement all these) -
 * @@n	bu_log			Called to log library events.
 * @@n	bu_log_indent_delta	Change global indentation level
 * @@n	bu_log_indent_vls	Apply indentation level (used by librt/pr.c)
 *
 * @@par Specialty Functions -
 *	bu_log_add_hook		Start catching log events (used by mged/cmd.c)
 * @@n	bu_putchar
 *
 *  @@author	Michael John Muuss
 *  @@author	Glenn Durfee
 *
 * @@par  Source -
 *	The U. S. Army Research Laboratory
 * @@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.23 2007/12/19 22:29:22 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdarg.h>

#include "machine.h"
#include "bu.h"

BU_EXTERN(void	bu_vls_vprintf, (struct bu_vls *vls, const char *fmt, va_list ap));

static int	bu_log_indent_cur_level = 0; /* formerly rt_g.rtg_logindent */
/**
 *			B U _ L O G _ I N D E N T _ D E L T A
 *
 *  Change indentation level by indicated number of characters.
 *  Call with a large negative number to cancel all indentation.
 */
void
bu_log_indent_delta(int delta)
{
	if( (bu_log_indent_cur_level += delta) < 0 )
		bu_log_indent_cur_level = 0;
}

/**
 *			B U _ L O G _ I N D E N T _ V L S
 *
 *  For multi-line vls generators, honor logindent level like bu_log() does,
 *  and prefix the proper number of spaces.
 *  Should be called at the front of each new line.
 */
void
bu_log_indent_vls(struct bu_vls *v)
{
	bu_vls_spaces( v, bu_log_indent_cur_level );
}

#if 1
struct bu_hook_list bu_log_hook_list = {
	{	BU_LIST_HEAD_MAGIC,
		&bu_log_hook_list.l,
		&bu_log_hook_list.l
	},
	BUHOOK_NULL,
	GENPTR_NULL
};
#else
struct bu_hook_list bu_log_hook_list;
#endif

static int bu_log_first_time = 1;
static int bu_log_hooks_called = 0;

/**
 *			B U _ L O G _ A D D _ H O O K
 *
 *  Adds a hook to the list of bu_log hooks.  The top (newest) one of these
 *  will be called with its associated client data and a string to be
 *  processed.  Typcially, these hook functions will display the output
 *  (possibly in an X window) or record it.
 *
 *  XXX The hook functions are all non-PARALLEL.
 */

void
bu_log_add_hook(bu_hook_t func, genptr_t clientdata)
{
#if 0
    struct bu_hook_list *toadd;

    /* Grab a hunk of memory for a new node, and put it at the head of the
       list */

    BU_GETSTRUCT(toadd, bu_hook_list);
    toadd->hookfunc = func;
    toadd->clientdata = clientdata;
    toadd->l.magic = BUHOOK_LIST_MAGIC;

    BU_LIST_APPEND( &(bu_log_hook_list.l), &(toadd->l) );
#else
    bu_add_hook(&bu_log_hook_list, func, clientdata);
#endif
}


/**
 *			B U _ L O G _ D E L E T E _ H O O K
 *
 *  Removes the hook matching the function and clientdata parameters from
 *  the hook list.  Note that it is not necessarily the active (top) hook.
 */
void
bu_log_delete_hook(bu_hook_t func, genptr_t clientdata)
{
#if 0
    struct bu_hook_list *cur = &bu_log_hook_list;

    for ( BU_LIST_FOR( cur, bu_hook_list, &(bu_log_hook_list.l) ) ) {
	if ( cur->hookfunc == func && cur->clientdata == clientdata) {
	    struct bu_hook_list *old = BU_LIST_PLAST(bu_hook_list, cur);
	    BU_LIST_DEQUEUE( &(cur->l) );
	    bu_free((genptr_t)cur, "bu_log hook");
	    cur = old;
	}
    }
#else
    bu_delete_hook(&bu_log_hook_list, func, clientdata);
#endif
}

#if 1
HIDDEN void
bu_log_call_hooks(genptr_t buf)
{
#if 0
    bu_hook_t hookfunc;		/* for clarity */
    genptr_t clientdata;
#endif

    bu_log_hooks_called = 1;

#if 0
    hookfunc = BU_LIST_FIRST(bu_hook_list, &(bu_log_hook_list.l))->hookfunc;
    clientdata = BU_LIST_FIRST(bu_hook_list, &(bu_log_hook_list.l))->clientdata;

    (hookfunc)( clientdata, buf);
#else
    bu_call_hook(&bu_log_hook_list, buf);
#endif

    bu_log_hooks_called = 0;
}
#endif

/**
 *			B U _ L O G _ D O _ I N D E N T _ L E V E L
 *
 *  This subroutine is used to append bu_log_indent_cur_level spaces
 *  into a printf() format specifier string, after each newline
 *  character is encountered.
 *  It exists primarily for bu_shootray() to affect the indentation
 *  level of all messages at that recursion level, even if the calls
 *  to bu_log come from non-librt routines.
 */

HIDDEN void
bu_log_do_indent_level(struct bu_vls *new, register char *old)
{
    register int i;

    while (*old) {
	bu_vls_putc(new, (int)(*old));
	if (*old == '\n') {
	    i = bu_log_indent_cur_level;
	    while (i-- > 0)
		bu_vls_putc(new, ' ');
	}
	++old;
    }
}

/**
 *			B U _ P U T C H A R
 *
 * Log a single character with no flushing.
 */

void
bu_putchar(int c)
{
    int ret = EOF;

    if ( BU_LIST_IS_EMPTY( &(bu_log_hook_list.l) ) ) {

	if (stderr) {
	    ret = fputc(c, stderr);
	}

	if (ret == EOF && stdout) {
	    ret = fputc(c, stdout);
	}

	if (ret == EOF) {
	    bu_bomb("bu_putchar: write error");
	}
	    
    } else {
	char buf[2];
	buf[0] = (char)c;
	buf[1] = '\0';
#if 1
	bu_log_call_hooks(buf);
#else
	bu_call_hook(&bu_log_hook_list, (genptr_t)buf);
#endif
    }

    if (bu_log_indent_cur_level > 0 && c == '\n') {
	int i;

	i = bu_log_indent_cur_level;
	while (i-- > 0)
	    bu_putchar(' ');
    }
}


/**
 *  			B U _ L O G
 *
 *  Log a library event in the Standard way.
 */
void
bu_log(char *fmt, ...)
{
    va_list ap;

    struct bu_vls output;

    bu_vls_init(&output);

    if (!fmt || strlen(fmt) == 0) {
	return;
    }

    va_start(ap, fmt);

    if (bu_log_indent_cur_level > 0) {
	struct bu_vls newfmt;

	bu_vls_init(&newfmt);
	bu_log_do_indent_level(&newfmt, fmt);
	bu_vls_vprintf(&output, bu_vls_addr(&newfmt), ap);
	bu_vls_free(&newfmt);
    } else {
	bu_vls_vprintf(&output, fmt, ap);
    }

    va_end(ap);

    if ( BU_LIST_IS_EMPTY(&(bu_log_hook_list.l)) || bu_log_hooks_called) {
	int ret = EOF;
	size_t len;

	if (bu_log_first_time) {
	    bu_setlinebuf(stderr);
	    bu_log_first_time = 0;
	}

	len = bu_vls_strlen(&output);
	if (len <= 0) {
	    return;
	}

	if (stderr) {
	    bu_semaphore_acquire(BU_SEM_SYSCALL);
	    ret = fwrite( bu_vls_addr(&output), len, 1, stderr );
	    fflush(stderr);
	    bu_semaphore_release(BU_SEM_SYSCALL);
	}

	if (!ret && stdout) {
	    /* if stderr fails, try stdout instead */
	    bu_semaphore_acquire(BU_SEM_SYSCALL);
	    ret = fwrite(bu_vls_addr(&output), len, 1, stdout );
	    fflush(stdout);
	    bu_semaphore_release(BU_SEM_SYSCALL);
	}

	if (ret != 1) {
 	    bu_semaphore_acquire(BU_SEM_SYSCALL);
	    perror("fwrite failed");
	    bu_semaphore_release(BU_SEM_SYSCALL);
	    bu_bomb("bu_log: write error");
	}

    } else {
#if 1
	    bu_log_call_hooks(bu_vls_addr(&output));
#else
	    bu_call_hook(&bu_log_hook_list, (genptr_t)bu_vls_addr(&output));
#endif
    }

    bu_vls_free(&output);
}


/**
 *  			B U _ F L O G
 *
 *  Log a library event in the Standard way, to a specified file.
 */
void
bu_flog(FILE *fp, char *fmt, ...)
{
    va_list ap;

    struct bu_vls output;

    bu_vls_init(&output);

    va_start(ap, fmt);
    if (bu_log_indent_cur_level > 0) {
	struct bu_vls newfmt;

	bu_vls_init(&newfmt);
	bu_log_do_indent_level(&newfmt, fmt);
	bu_vls_vprintf(&output, bu_vls_addr(&newfmt), ap);
	bu_vls_free(&newfmt);
    } else {
	bu_vls_vprintf(&output, fmt, ap);
    }

    if ( BU_LIST_IS_EMPTY( &(bu_log_hook_list.l) ) || bu_log_hooks_called) {
	int ret;
	size_t len;

	len = bu_vls_strlen(&output);
	if(len){
	  bu_semaphore_acquire(BU_SEM_SYSCALL);
	  ret = fwrite( bu_vls_addr(&output), len, 1, fp );
	  bu_semaphore_release(BU_SEM_SYSCALL);
	  if( ret != 1 )  bu_bomb("bu_flog: write error");
	}

    } else {
#if 1
	    bu_log_call_hooks(bu_vls_addr(&output));
#else
	    bu_call_hook(&bu_log_hook_list, (genptr_t)bu_vls_addr(&output));
#endif
    }

    va_end(ap);

    bu_vls_free(&output);
}

/** @@} */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.23
log
@try stdout just in case something is wrong with stderr when logging before fatally aborting the app.  there's probably something wrong either way, but until we can set/redirect bu_log -- try harder to not fail.
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.22 2007/12/19 21:44:50 brlcad Exp $ (ARL)";
d224 2
d227 13
a239 1
	fputc(c, stderr);
d292 2
d295 1
a295 1
	int ret;
d304 24
a327 17
	if (len) {
	  bu_semaphore_acquire(BU_SEM_SYSCALL);
	  ret = fwrite( bu_vls_addr(&output), len, 1, stderr );
	  (void)fflush(stderr);
	  bu_semaphore_release(BU_SEM_SYSCALL);
	  if (ret != 1) {
	      bu_semaphore_acquire(BU_SEM_SYSCALL);
	      ret = fwrite(bu_vls_addr(&output), len, 1, stdout );
	      (void)fflush(stderr);
	      bu_semaphore_release(BU_SEM_SYSCALL);
	      if (ret != 1) {
		  bu_semaphore_acquire(BU_SEM_SYSCALL);
		  perror("fwrite failed");
		  bu_semaphore_release(BU_SEM_SYSCALL);
		  bu_bomb("bu_log: write error");
	      }
	  }
a337 2
    va_end(ap);

@


14.22
log
@ws
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.21 2007/12/04 01:36:14 brlcad Exp $ (ARL)";
d293 12
a304 2
	  if ( ret != 1 )
	      bu_bomb("bu_log: write error");
@


14.21
log
@remove the last traces of stdarg/vararg testing.  c89 conformance provides the stdarg interface.
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.20 2007/12/03 22:57:58 brlcad Exp $ (ARL)";
d278 1
a278 1
    if ( BU_LIST_IS_EMPTY( &(bu_log_hook_list.l) )  || bu_log_hooks_called) {
d288 1
a288 1
	if(len){
d293 2
a294 1
	  if( ret != 1 )  bu_bomb("bu_log: write error");
d310 1
@


14.20
log
@c89 simplification.  assume stdarg is a given.
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.19 2007/10/22 00:55:09 brlcad Exp $ (ARL)";
a252 2
#if defined(HAVE_STDARG_H)
/* ANSI C */
a255 15
#else
#  if defined(HAVE_VARARGS_H)
/* VARARGS */
bu_log(va_alist)
va_dcl
{
    va_list ap;
    char *fmt;
#  else
/* Cray XMP */
bu_log(fmt, a,b,c,d,e,f,g,h,i,j)
char *fmt;
{
#  endif
#endif
a260 3
#if defined(HAVE_STDARG_H)
/* ANSI C */

a276 38
#else
#  if defined(HAVE_VARARGS_H)
/* VARARGS */
    va_start(ap);
    fmt = va_arg(ap, char *);

    if (!fmt || strlen(fmt) == 0) {
	return;
    }

    if (bu_log_indent_cur_level > 0) {
	struct bu_vls newfmt;

	bu_vls_init(&newfmt);
	bu_log_do_indent_level(&newfmt, fmt);
	bu_vls_vprintf(&output, bu_vls_addr(&newfmt), ap);
	bu_vls_free(&newfmt);
    } else {
	bu_vls_vprintf(&output, fmt, ap);
    }
#  else
/* Cray XMP */
    if (!fmt || strlen(fmt) == 0) {
	return;
    }

    if (bu_log_indent_cur_level > 0) {
	struct bu_vls newfmt;

	bu_vls_init(&newfmt);
	bu_log_do_indent_level(&newfmt, fmt);
	bu_vls_printf(&output, bu_vls_addr(&newfmt), a,b,c,d,e,f,g,h,i,j);
	bu_vls_free(&newfmt);
    } else {
	bu_vls_printf(&output, fmt, a,b,c,d,e,f,g,h,i,j);
    }
#  endif
#endif
a303 1
#if defined(HAVE_STDARG_H) || defined(HAVE_VARARGS_H)
a304 1
#endif
a314 2
#if defined(HAVE_STDARG_H)
/* ANSI C */
a317 17
#else
#  if defined(HAVE_VARARGS_H)
/* VARARGS */
bu_flog(va_alist)
va_dcl
{
    va_list ap;
    FILE *fp;
    char *fmt;
#  else
/* Cray XMP */
bu_flog(fp, fmt, a,b,c,d,e,f,g,h,i,j)
FILE *fp;
char *fmt;
{
#  endif
#endif
a322 2
#if defined(HAVE_STDARG_H)
/* ANSI C */
a333 30
#else
#  if defined(HAVE_VARARGS_H)
/* VARARGS */
    va_start(ap);
    fp = va_arg(ap, FILE *);
    fmt = va_arg(ap, char *);
    if (bu_log_indent_cur_level > 0) {
	struct bu_vls newfmt;

	bu_vls_init(&newfmt);
	bu_log_do_indent_level(&newfmt, fmt);
	bu_vls_vprintf(&output, bu_vls_addr(&newfmt), ap);
	bu_vls_free(&newfmt);
    } else {
	bu_vls_vprintf(&output, fmt, ap);
    }
#  else
/* Cray XMP */
    if (bu_log_indent_cur_level > 0) {
	struct bu_vls newfmt;

	bu_vls_init(&newfmt);
	bu_log_do_indent_level(&newfmt, fmt);
	bu_vls_printf(&output, bu_vls_addr(&newfmt), a,b,c,d,e,f,g,h,i,j);
	bu_vls_free(&newfmt);
    } else {
	bu_vls_printf(&output, fmt, a,b,c,d,e,f,g,h,i,j);
    }
#  endif
#endif
a354 1
#if defined(HAVE_STDARG_H) || defined(HAVE_VARARGS_H)
a355 1
#endif
@


14.19
log
@don't call va_start until after making sure it's not a null format
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.18 2007/10/17 01:28:47 brlcad Exp $ (ARL)";
d57 1
a57 8

#if defined(HAVE_STDARG_H)
# include <stdarg.h>
#else
#  if defined(HAVE_VARARGS_H)
#    include <varargs.h>
#  endif
#endif
a61 1
#if defined(HAVE_VARARGS_H) || defined(HAVE_STDARG_H)
a62 1
#endif
@


14.18
log
@put comments on their own line.  was going to add code to bu_log() to try and detect when there are no ... args, but it does not seem to work (at least on mac os x) as va_arg keeps scanning past the end giving the wrong count!
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.17 2007/09/15 16:23:09 brlcad Exp $ (ARL)";
a289 2
    va_start(ap, fmt);

d294 2
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.16 2007/01/27 01:41:36 brlcad Exp $ (ARL)";
d255 1
d263 2
a264 1
bu_log(char *fmt, ...)                      /* ANSI C */
d269 2
a270 1
bu_log(va_alist)                            /* VARARGS */
d276 2
a277 1
bu_log(fmt, a,b,c,d,e,f,g,h,i,j)            /* Cray XMP */
d287 3
a289 1
#if defined(HAVE_STDARG_H)                  /* ANSI C */
d304 1
a304 1
	bu_vls_vprintf(&output, fmt, ap);   /* VARARGS */
d308 1
d326 2
a327 1
#  else                                     /* Cray XMP */
d385 2
a386 1
bu_flog(FILE *fp, char *fmt, ...)                      /* ANSI C */
d391 2
a392 1
bu_flog(va_alist)                            /* VARARGS */
d399 2
a400 1
bu_flog(fp, fmt, a,b,c,d,e,f,g,h,i,j)            /* Cray XMP */
d411 2
a412 1
#if defined(HAVE_STDARG_H)                  /* ANSI C */
d422 1
a422 1
	bu_vls_vprintf(&output, fmt, ap);   /* VARARGS */
d426 1
d440 2
a441 1
#  else                                     /* Cray XMP */
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.15 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d56 2
a64 3
#ifdef HAVE_STRING_H
#  include <string.h>
#endif
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.14 2007/01/21 04:45:42 brlcad Exp $ (ARL)";
d162 1
a162 1
        if ( cur->hookfunc == func && cur->clientdata == clientdata) {
d339 1
a339 1
    	int ret;
d443 1
a443 1
    	int ret;
@


14.14
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d49 1
a49 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.13 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.13
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup bu_log */
/*@@{*/
d24 1
d50 1
a50 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.12 2006/09/03 15:14:07 lbutler Exp $ (ARL)";
d470 1
a470 1
/*@@}*/
@


14.12
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d50 1
a50 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.11 2006/08/31 23:16:38 lbutler Exp $ (ARL)";
@


14.11
log
@Doxygen comments
@
text
@d25 2
a38 1
 * @@n	bu_log_delete_hook
a40 1
 *
d50 1
a50 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.10 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
@


14.10
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d30 4
a33 4
 *  Primary Functions (replacements MUST implement all these) -
 *	bu_log			Called to log library events.
 *	bu_log_indent_delta	Change global indentation level
 *	bu_log_indent_vls	Apply indentation level (used by librt/pr.c)
d35 1
a35 1
 *  Specialty Functions -
d37 2
a38 2
 *	bu_log_delete_hook
 *	bu_putchar
a39 3
 *  Authors -
 *	Michael John Muuss
 *	Glenn Durfee
d41 4
a44 1
 *  Source -
d46 1
a46 2
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
a47 1
/*@@}*/
d50 1
a50 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.9 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d76 1
a76 1
/*
d89 1
a89 1
/*
d118 1
a118 1
/*
d150 1
a150 1
/*
d199 1
a199 1
/*
d226 1
a226 1
/*
d257 1
a257 1
/*
d372 1
a372 1
/*
d470 2
@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d52 1
a52 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.8 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.8
log
@Doxygen changes
@
text
@d43 1
a43 1
 *  
d47 1
a47 1
 *  
d52 1
a52 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.7 2005/06/30 05:57:36 brlcad Exp $ (ARL)";
d106 2
a107 2
	{	BU_LIST_HEAD_MAGIC, 
		&bu_log_hook_list.l, 
d109 1
a109 1
	}, 
d171 1
a171 1
    }    
d261 1
a261 1
 *  
d340 1
a340 1
    
d376 1
a376 1
 *  
d444 1
a444 1
    
@


14.8.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d43 1
a43 1
 *
d47 1
a47 1
 *
d52 1
a52 1
static const char RCSlog[] = "@@(#)$Header$ (ARL)";
d106 2
a107 2
	{	BU_LIST_HEAD_MAGIC,
		&bu_log_hook_list.l,
d109 1
a109 1
	},
d171 1
a171 1
    }
d261 1
a261 1
 *
d340 1
a340 1

d376 1
a376 1
 *
d444 1
a444 1

@


14.7
log
@return from logging early if the fmt is somehow empty.  would probably be good to bu_bomb on such an argument in order to discover who might be doing that but that shall be shelved for later testing.
@
text
@d21 3
a24 1
 *
d49 2
d52 1
a52 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.6 2005/01/30 20:30:45 brlcad Exp $ (ARL)";
@


14.6
log
@update copyright to 2005
@
text
@d48 1
a48 1
static const char RCSlog[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/log.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
a52 2


d62 3
d285 5
d304 5
d320 4
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d48 1
a48 1
static const char RCSlog[] = "@@(#)$Header: /cvs/brlcad/src/libbu/log.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a45 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d48 1
a48 1
static const char RCSlog[] = "@@(#)$Header: /cvs/brlcad/src/libbu/log.c,v 14.3 2004/12/21 05:45:21 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d50 1
a50 1
static const char RCSlog[] = "@@(#)$Header: /cvs/brlcad/src/libbu/log.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d50 1
a50 1
static const char RCSlog[] = "@@(#)$Header: /cvs/brlcad/src/libbu/log.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			L O G . C
d50 1
a50 1
static const char RCSlog[] = "@@(#)$Header: /cvs/brlcad/src/libbu/log.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (ARL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d31 1
a31 1
static const char RCSlog[] = "@@(#)$Header: /cvs/brlcad/src/libbu/log.c,v 1.2 2004/06/08 19:28:50 morrison Exp $ (ARL)";
d435 10
@


1.2
log
@poof goes the silly externs.h
@
text
@d31 1
a31 1
static const char RCSlog[] = "@@(#)$Header$ (ARL)";
d34 1
a34 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d31 1
a31 1
static const char RCSlog[] = "@@(#)$Header: /cvs/brlcad/libbu/log.c,v 1.17 2004/05/10 15:30:44 erikg Exp $ (ARL)";
a50 1
#include "externs.h"
@

