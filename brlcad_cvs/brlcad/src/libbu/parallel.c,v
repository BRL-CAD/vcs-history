head	14.45;
access;
symbols
	rel-7-10-4:14.38
	STABLE:14.38.0.2
	stable-branch:14.8
	rel-7-10-2:14.34
	rel-7-10-0:14.28
	rel-7-8-4:14.22
	rel-7-8-2:14.17
	rel-7-8-0:14.17
	trimnurbs-branch:14.17.0.2
	help:14.17
	temp_tag:14.16
	bobWinPort-20051223-freeze:14.12
	postmerge-20051223-bobWinPort:14.16
	premerge-20051223-bobWinPort:14.16
	rel-7-6-6:14.16
	rel-7-6-4:14.16
	rel-7-6-2:14.12
	rel-7-6-branch:14.12.0.4
	rel-7-6-0:14.12
	rel-7-4-2:14.11
	rel-7-4-branch:14.11.0.2
	bobWinPort:14.12.0.2
	rel-7-4-0:14.11
	rel-7-2-6:14.9
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.45
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.44;

14.44
date	2007.12.15.17.20.22;	author brlcad;	state Exp;
branches;
next	14.43;

14.43
date	2007.12.06.15.49.16;	author brlcad;	state Exp;
branches;
next	14.42;

14.42
date	2007.12.01.21.47.12;	author brlcad;	state Exp;
branches;
next	14.41;

14.41
date	2007.09.15.16.23.09;	author brlcad;	state Exp;
branches;
next	14.40;

14.40
date	2007.09.15.03.26.47;	author brlcad;	state Exp;
branches;
next	14.39;

14.39
date	2007.09.14.20.06.49;	author brlcad;	state Exp;
branches;
next	14.38;

14.38
date	2007.08.30.19.19.00;	author erikgreenwald;	state Exp;
branches;
next	14.37;

14.37
date	2007.08.29.21.26.21;	author erikgreenwald;	state Exp;
branches;
next	14.36;

14.36
date	2007.08.29.19.06.30;	author erikgreenwald;	state Exp;
branches;
next	14.35;

14.35
date	2007.08.18.00.22.58;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2007.05.31.19.51.09;	author erikgreenwald;	state Exp;
branches;
next	14.33;

14.33
date	2007.05.27.21.48.56;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.05.12.22.23.04;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2007.05.12.05.30.38;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.05.12.05.16.18;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.04.14.23.58.54;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.03.09.19.04.34;	author erikgreenwald;	state Exp;
branches;
next	14.27;

14.27
date	2007.02.20.08.19.48;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.25;

14.25
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2006.09.03.15.14.07;	author lbutler;	state Exp;
branches;
next	14.21;

14.21
date	2006.08.31.23.16.38;	author lbutler;	state Exp;
branches;
next	14.20;

14.20
date	2006.08.01.14.48.18;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2006.07.29.21.49.18;	author lbutler;	state Exp;
branches;
next	14.18;

14.18
date	2006.07.10.19.06.22;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2005.11.12.02.50.33;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.10.30.21.37.29;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.09.22.12.18.19;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.12.4.1;
next	14.11;

14.11
date	2005.06.21.07.10.12;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.06.15.04.34.52;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.05.28.02.14.50;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.03.24.07.07.28;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.03.23.06.15.57;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.46;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.15.05.11.15;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.03.20.42.29;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.28.33;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.34;	author morrison;	state Exp;
branches;
next	;

14.12.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.45
log
@convert all bzero calls to memset
@
text
@/*                      P A R A L L E L . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup thread */
/** @@{ */
/** @@file parallel.c
 *
 *  @@brief routines for parallel processing
 *
 *  Machine-specific routines for parallel processing.
 *  Primarily calling functions in multiple threads on multiple CPUs.
 *
 *  @@author  Michael John Muuss
 *
 *
 *  @@par Source -
 *	The U. S. Army Research Laboratory
 *  @@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */

#include "common.h"

/* XXX header mess needs cleaned up */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>
#include <string.h>
#include <signal.h>

#include "machine.h"
#include "bu.h"

#ifdef linux
#  include <sys/time.h>
#  include <sys/types.h>
#  include <sys/resource.h>
#  ifdef HAVE_SYS_WAIT_H
#    include <sys/wait.h>
#  endif
#  include <sys/stat.h>
#  include <sys/sysinfo.h>
#endif

#ifdef __FreeBSD__
#  include <sys/types.h>
#  include <sys/time.h>
#  include <sys/resource.h>
#  include <sys/sysctl.h>
#  ifdef HAVE_SYS_WAIT_H
#    include <sys/wait.h>
#  endif
#  include <sys/stat.h>
#endif

#ifdef __APPLE__
#  include <sys/types.h>
#  include <sys/time.h>
#  include <sys/resource.h>
#  ifdef HAVE_SYS_WAIT_H
#    include <sys/wait.h>
#  endif
#  include <sys/stat.h>
#  include <sys/param.h>
#  include <sys/sysctl.h>
#endif

#ifdef __sp3__
#  include <sys/types.h>
#  include <sys/sysconfig.h>
#  include <sys/var.h>
#endif

#ifdef CRAY
#  include <sys/category.h>
#  include <sys/resource.h>
#  include <sys/types.h>
#  ifdef CRAY1
#    include <sys/machd.h>	/* For HZ */
#  endif
#endif

#ifdef CRAY2
#  undef MAXINT
#  include <sys/param.h>
#endif

#ifdef HEP
#  include <synch.h>
#  undef stderr
#  define stderr stdout
#endif /* HEP */

#if defined(alliant) && !defined(i860)
/* Alliant FX/8 */
#  include <cncall.h>
#endif

#if (defined(sgi) && defined(mips)) || (defined(__sgi) && defined(__mips))
/* XXX hack that should eventually go away when it can be verified */
#  define SGI_4D	1
#  define _SGI_SOURCE	1	/* IRIX 5.0.1 needs this to def M_BLKSZ */
#  define _BSD_TYPES	1	/* IRIX 5.0.1 botch in sys/prctl.h */
#endif

#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_ULOCKS_H
#  include <ulocks.h>
#endif
#ifdef HAVE_SYS_SYSMP_H
#  include <sys/sysmp.h> /* for sysmp() */
#endif

#ifdef HAVE_SYS_WAIT_H
#  include <sys/wait.h>
#endif

#ifdef HAVE_SCHED_H
#  include <sched.h>
#else
#  ifdef HAVE_SYS_SCHED_H
#    include <sys/sched.h>
#  endif
#endif
#if defined(IRIX64) && IRIX64 >= 64
static struct sched_param bu_param;
#endif

#ifdef ardent
#  include <thread.h>
#endif

#if defined(n16)
#  include <parallel.h>
#  include <sys/sysadmin.h>
#endif

/*
 * multithreading support for SunOS 5.X / Solaris 2.x
 */
#if defined(SUNOS) && SUNOS >= 52
#  include <sys/unistd.h>
#  include <thread.h>
#  include <synch.h>
#  define rt_thread_t	thread_t
#endif	/* SUNOS */

/*
 * multithread support built on POSIX Threads (pthread) library.
 */
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#else
#  ifdef HAVE_SYS_UNISTD_H
#    include <sys/unistd.h>
#  endif
#endif
#ifdef HAVE_PTHREAD_H
#  include <pthread.h>
#  define rt_thread_t	pthread_t
#endif

#ifdef CRAY
struct taskcontrol {
    int	tsk_len;
    int	tsk_id;
    int	tsk_value;
} bu_taskcontrol[MAX_PSW];
#endif

/**
 *			B U _ N I C E _ S E T
 *
 *  Without knowing what the current UNIX "nice" value is,
 *  change to a new absolute "nice" value.
 *  (The system routine makes a relative change).
 */
void
bu_nice_set(int newnice)
{
#ifdef HAVE_SETPRIORITY
    int opri, npri;

#  ifndef PRIO_PROCESS  /* necessary for linux */
#    define PRIO_PROCESS  0	/* From /usr/include/sys/resource.h */
#  endif
    opri = getpriority( PRIO_PROCESS, 0 );
    setpriority( PRIO_PROCESS, 0, newnice );
    npri = getpriority( PRIO_PROCESS, 0 );

    if( bu_debug ) {
	bu_log("bu_nice_set() Priority changed from %d to %d\n", opri, npri);
    }

#else /* !HAVE_SETPRIORITY */
    /* no known means to change the nice value */
    if (bu_debug) {
	bu_log("bu_nice_set() Priority NOT changed\n");
    }
#endif  /* _WIN32 */
}


/**
 *			B U _ C P U L I M I T _ G E T
 *
 *  Return the current CPU limit, in seconds.
 *  Zero or negative return indicates that limits are not in effect.
 */
int
bu_cpulimit_get(void)
{
#ifdef CRAY
    long	old;			/* 64-bit clock counts */
    extern long limit();

    if( (old = limit( C_PROC, 0, L_CPU, -1 )) < 0 )  {
	perror("bu_cpulimit_get(): CPU limit(get)");
    }
    if( old <= 0 )
	return(999999);		/* virtually unlimited */
    return( (old + HZ - 1) / HZ );
#else
    return(-1);
#endif
}

/**
 *			B U _ C P U L I M I T _ S E T
 *
 *  Set CPU time limit, in seconds.
 */
/* ARGSUSED */
void
bu_cpulimit_set(int sec)
{
#ifdef CRAY
    long	old;		/* seconds */
    long	new;		/* seconds */
    long	newtick;	/* 64-bit clock counts */
    extern long limit();

    old = bu_cpulimit_get();
    new = old + sec;
    if( new <= 0 || new > 999999 )
	new = 999999;	/* no limit, for practical purposes */
    newtick = new * HZ;
    if( limit( C_PROC, 0, L_CPU, newtick ) < 0 )  {
	perror("bu_cpulimit_set: CPU limit(set)");
    }
    bu_log("Cray CPU limit changed from %d to %d seconds\n",
	   old, newtick/HZ );

    /* Eliminate any memory limit */
    if( limit( C_PROC, 0, L_MEM, 0 ) < 0 )  {
	/* Hopefully, not fatal if memory limits are imposed */
	perror("bu_cpulimit_set: MEM limit(set)");
    }
#endif
    if (sec < 0) sec = 0;
}


/**
 *			B U _ A V A I L _ C P U S
 *
 *  Return the maximum number of physical CPUs that are considered to be
 *  available to this process now.
 */
int
bu_avail_cpus(void)
{
    int ncpu = -1;


#if defined(_SC_NPROCESSORS_ONLN)
    /* SUNOS and linux */
    ncpu = sysconf(_SC_NPROCESSORS_ONLN);
    if (ncpu < 0) {
	perror("Unable to get the number of available CPUs");
	ncpu = 1;
    }
    goto DONE_NCPU;
#elif defined(_SC_NPROC_ONLN)
    ncpu = sysconf(_SC_NPROC_ONLN);
    if (ncpu < 0) {
	perror("Unable to get the number of available CPUs");
	ncpu = 1;
    }
    goto DONE_NCPU;
#elif defined(_SC_CRAY_NCPU)
    /* cray */
    ncpu = sysconf(_SC_CRAY_NCPU);
    if (ncpu < 0) {
	perror("Unable to get the number of available CPUs");
	ncpu = 1;
    }
    goto DONE_NCPU;
#endif


#ifdef SGI_4D
    /* XXX LAB 04 June 2002
     * The call prctl(PR_MAXPPROCS) is supposed to indicate the number
     * of processors this process can use.  Unfortuantely, this returns
     * 0 when running under a CPU set.  A bug report has been filed with
     * SGI.
     *
     * The sysmp(MP_NPROCS) call returns the number of physically
     * configured processors.  This will have to suffice until SGI
     * comes up with a fix.
     */
#  ifdef HAVE_SYSMP
    ncpu = sysmp(MP_NPROCS);
#  elif defined(HAVE_PRCTL)
    ncpu = (int)prctl(PR_MAXPPROCS);
#  endif
    goto DONE_NCPU;
#endif /* SGI_4D */


#ifdef alliant
    {
	long	memsize, ipnum, cenum, detnum, attnum;

#  if !defined(i860)
	/* FX/8 */
	lib_syscfg( &memsize, &ipnum, &cenum, &detnum, &attnum );
#  else
	/* FX/2800 */
	attnum = 28;
#  endif /* i860 */
	ncpu = attnum;		/* # of CEs attached to parallel Complex */
	goto DONE_NCPU;
    }
#endif /* alliant */


#if defined(__sp3__)
    {
	int status;
	int cmd;
	int parmlen;
	struct var p;

	cmd = SYS_GETPARMS;
	parmlen = sizeof(struct var);
	if ( sysconfig(cmd, &p, parmlen) != 0 ) {
	    bu_bomb("bu_parallel(): sysconfig error for sp3");
	}
	ncpu = p.v_ncpus;
	goto DONE_NCPU;
    }
#endif	/* __sp3__ */


#if defined(n16)
    if( (ncpu = sysadmin( SADMIN_NUMCPUS, 0 )) < 0 )
	perror("sysadmin");
    goto DONE_NCPU;
#endif /* n16 */


#ifdef __FreeBSD__
    {
	int maxproc;
	size_t len;
	len = 4;
	if (sysctlbyname("hw.ncpu", &maxproc, &len, NULL, 0) == -1) {
	    ncpu = 1;
	    perror("sysctlbyname");
	} else {
	    ncpu = maxproc;
	}
	goto DONE_NCPU;
    }
#endif


#if defined(__APPLE__)
    {
	int mib[2], maxproc;
	size_t len;

	mib[0] = CTL_HW;
	mib[1] = HW_AVAILCPU;
	len = sizeof(maxproc);
	if (sysctl(mib, 2, &maxproc, &len, NULL, 0) == -1) {
	    ncpu = 1;
	    perror("sysctl");
	} else {
	    ncpu = maxproc; /* should be able to get sysctl to return maxproc */
	}
	goto DONE_NCPU;
    }
#endif /* __ppc__ */


#if defined(HAVE_GET_NPROCS)
    ncpu = get_nprocs(); /* GNU extension from sys/sysinfo.h */
    goto DONE_NCPU;
#endif


#if defined(linux) && 0
    {
	/* old retired linux method */
	/*
	 * Ultra-kludgey way to determine the number of cpus in a
	 * linux box--count the number of processor entries in
	 * /proc/cpuinfo!
	 */

#	define CPUINFO_FILE "/proc/cpuinfo"
	FILE *fp;
	char buf[128];

	ncpu = 0;

	fp = fopen (CPUINFO_FILE,"r");

	if (fp == NULL) {
	    ncpu = 1;
	    perror (CPUINFO_FILE);
	} else {
	    while (bu_fgets(buf, 80, fp) != NULL) {
		if (strncmp (buf, "processor",9) == 0) {
		    ++ ncpu;
		}
	    }
	    fclose (fp);

	    if (ncpu <= 0) {
		ncpu = 1;
	    }
	}
	goto DONE_NCPU;
    }
#endif

#if defined(_WIN32)
    /* Windows */
    {
	SYSTEM_INFO sysinfo;

	GetSystemInfo(&sysinfo);
	ncpu = (int)sysinfo.dwNumberOfProcessors;
	goto DONE_NCPU;
    }
#endif

 DONE_NCPU:  ; /* allows debug and final validity check */


#if defined(HAVE_PTHREAD_H)
    /* if they have threading and we could not detect properly, claim two */
    if (ncpu < 0) {
	ncpu = 2;
    }
#endif

    if (bu_debug & BU_DEBUG_PARALLEL) {
	/* do not use bu_log() here, this can get called before semaphores are initialized */
	fprintf( stderr, "bu_avail_cpus: counted %d cpus.\n", ncpu);
    }

    if (ncpu > 0) {
	return ncpu;
    }

    return( DEFAULT_PSW );
}


/**
 *			B U _ G E T _ L O A D _ A V E R A G E
 *
 *  A generally portable method for obtaining the 1-minute load average.
 *  Vendor-specific methods which don't involve a fork/exec sequence
 *  would be preferable.
 *  Alas, very very few systems put the load average in /proc,
 *  most still grunge the avenrun[3] array out of /dev/kmem,
 *  which requires special privleges to open.
 */
fastf_t
bu_get_load_average(void)
{
    double	load = -1.0;

    bu_log("DEPRECATED: bu_get_load_average is deprecated and will be removed in a future release.\n");

#ifndef _WIN32
    FILE	*fp;

    /* XXX - wow. eek. */
    fp = popen("PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd; export PATH; uptime|sed -e 's/.*average: //' -e 's/,.*//' ", "r");
    if( !fp )
	return -1.0;

    fscanf( fp, "%lf", &load );
    fclose(fp);

    while( wait(NULL) != -1 )  ;	/* NIL */
#endif
    return load;
}

/**
 *			B U _ G E T _ P U B L I C _ C P U S
 *
 *  A general mechanism for non-privleged users of a server system to control
 *  how many processors of their server get consumed by multi-thread
 *  cruncher processes, by leaving a world-writable file.
 *
 *  If the number in the file is negative, it means "all but that many."
 *
 *  Returns the number of processors presently available for "public" use.
 */
#ifndef _WIN32
#  define PUBLIC_CPUS1	"/var/tmp/public_cpus"
#  define PUBLIC_CPUS2	"/usr/tmp/public_cpus"
#endif
int
bu_get_public_cpus(void)
{
    int	avail_cpus = bu_avail_cpus();
#ifndef _WIN32
    int	public_cpus = 1;
    FILE	*fp;

    if( (fp = fopen(PUBLIC_CPUS1, "r")) != NULL ||
	(fp = fopen(PUBLIC_CPUS2, "r")) != NULL
	)  {
	(void)fscanf( fp, "%d", &public_cpus );
	fclose(fp);
	if( public_cpus < 0 )  public_cpus = avail_cpus + public_cpus;
	if( public_cpus > avail_cpus )  public_cpus = avail_cpus;
	return public_cpus;
    }

    (void)unlink(PUBLIC_CPUS1);
    (void)unlink(PUBLIC_CPUS2);
    if( (fp = fopen(PUBLIC_CPUS1, "w")) != NULL ||
	(fp = fopen(PUBLIC_CPUS2, "w")) != NULL
	)  {
	fprintf(fp, "%d\n", avail_cpus);
	fchmod(fileno(fp), 0666);
	fclose(fp);
    }
#endif
    return avail_cpus;
}

/**
 *			B U _ S E T _ R E A L T I M E
 *
 *  If possible, mark this process for real-time scheduler priority.
 *  Will often need root privs to succeed.
 *
 *  Returns -
 *	1	realtime priority obtained
 *	0	running with non-realtime scheduler behavior
 */
int
bu_set_realtime(void)
{
#	if defined(IRIX64) && IRIX64 >= 64
    {
	int	policy;

	if( (policy = sched_getscheduler(0)) >= 0 )  {
	    if( policy == SCHED_RR || policy == SCHED_FIFO )
		return 1;
	}

	sched_getparam( 0, &bu_param );

	if ( sched_setscheduler( 0,
				 SCHED_RR,		/* policy */
				 &bu_param
				 ) >= 0 )  {
	    return 1;		/* realtime */
	}
	/* Fall through to return 0 */
    }
#	endif
    return 0;
}

/**********************************************************************/

/*
 * Cray is known to wander among various pids, perhaps others.
 */
#if defined(unix) || defined(__unix)
#  define CHECK_PIDS 1
#endif


#if defined(PARALLEL)

/* bu_worker_tbl_not_empty and bu_kill_workers are only used by the sgi arch */
#  ifdef SGI_4D

/**
 *			B U _ W O R K E R _ T B L _ N O T _ E M P T Y
 */
static int
bu_worker_tbl_not_empty(tbl)
     int tbl[MAX_PSW];
{
    register int i;
    register int children=0;

    for (i=1 ; i < MAX_PSW ; ++i)
	if (tbl[i]) children++;

    return(children);
}

/**
 *			B U _ K I L L _ W O R K E R S
 */
static void
bu_kill_workers(tbl)
     int tbl[MAX_PSW];
{
    register int i;

    for (i=1 ; i < MAX_PSW ; ++i) {
	if ( tbl[i] ) {
	    if( kill(tbl[i], 9) ) {
		perror("bu_kill_workers(): SIGKILL to child process");
	    }
	    else {
		bu_log("bu_kill_workers(): child pid %d killed\n", tbl[i]);
	    }
	}
    }

    memset((char *)tbl, 0, sizeof(tbl));
}
#  endif   /* end check if sgi_4d defined */

extern int	bu_pid_of_initiating_thread;	/* From ispar.c */

static int	bu_nthreads_started = 0;	/* # threads started */
static int	bu_nthreads_finished = 0;	/* # threads properly finished */
static void	(*bu_parallel_func) BU_ARGS((int,genptr_t));	/* user function to run in parallel */
static genptr_t	bu_parallel_arg;		/* User's arg to his threads */


/**
 *			B U _ P A R A L L E L _ I N T E R F A C E
 *
 *  Interface layer between bu_parallel and the user's function.
 *  Necessary so that we can provide unique thread numbers as a
 *  parameter to the user's function, and to decrement the global
 *  counter when the user's function returns to us (as opposed to
 *  dumping core or longjmp'ing too far).
 *
 *  Note that not all architectures can pass an argument
 *  (e.g. the pointer to the user's function), so we depend on
 *  using a global variable to communicate this.
 *  This is no problem, since only one copy of bu_parallel()
 *  may be active at any one time.
 */
static void
bu_parallel_interface(void)
{
    register int	cpu;		/* our CPU (thread) number */

#if 0
#ifdef HAVE_PTHREAD_H
    {
	pthread_t	pt;
	pt = pthread_self();
	fprintf(stderr,"bu_parallel_interface, Thread ID = 0x%x\n", (unsigned int)pt);
    }
#endif
#endif
    bu_semaphore_acquire( BU_SEM_SYSCALL );
    cpu = bu_nthreads_started++;
    bu_semaphore_release( BU_SEM_SYSCALL );

    (*bu_parallel_func)(cpu, bu_parallel_arg);

    bu_semaphore_acquire( BU_SEM_SYSCALL );
    bu_nthreads_finished++;
    bu_semaphore_release( BU_SEM_SYSCALL );

#  if defined(SGI_4D) || defined(IRIX)
    /*
     *  On an SGI, a process/thread created with the "sproc" syscall has
     *  all of it's file descriptors closed when it "returns" to sproc.
     *  Since this trashes file descriptors which may still be in use by
     *  other processes, we avoid ever returning to sproc.
     */
    if(cpu) _exit(0);
#  endif /* SGI */
}
#endif /* PARALLEL */

#ifdef SGI_4D
/**
 *			B U _ P R _ F I L E
 *
 *  SGI-specific.  Formatted printing of stdio's FILE struct.
 */
void
bu_pr_FILE(title, fp)
     char	*title;
     FILE	*fp;
{
    bu_log("FILE structure '%s', at x%x:\n", title, fp );
    bu_log(" _cnt = x%x\n", fp->_cnt);
    bu_log(" _ptr = x%x\n", fp->_ptr);
    bu_log(" _base = x%x\n", fp->_base);
    bu_log(" _file = x%x\n", fp->_file);
    bu_printb(" _flag ", fp->_flag & 0xFF,
	      "\010\010_IORW\7_100\6_IOERR\5_IOEOF\4_IOMYBUF\3_004\2_IOWRT\1_IOREAD" );
    bu_log("\n");
}
#endif


/**
 *			B U _ P A R A L L E L
 *
 *  Create 'ncpu' copies of function 'func' all running in parallel,
 *  with private stack areas.  Locking and work dispatching are
 *  handled by 'func' using a "self-dispatching" paradigm.
 *
 *  'func' is called with one parameter, it's thread number.
 *  Threads are given increasing numbers, starting with zero.
 *
 *  This function will not return control until all invocations
 *  of the subroutine are finished.
 *
 *  Don't use registers in this function (bu_parallel).  At least on the Alliant,
 *  register context is NOT preserved when exiting the parallel mode,
 *  because the serial portion resumes on some arbitrary processor,
 *  not necessarily the one that serial execution started on.
 *  The registers are not shared.
 */
void
bu_parallel( func, ncpu, arg )
     void		(*func) BU_ARGS((int, genptr_t));
     int		ncpu;
     genptr_t	arg;
{
#if defined(PARALLEL)
    int	avail_cpus;

#  if defined(alliant) && !defined(i860) && !__STDC__
    register int d7;	/* known to be in d7 */
    register int d6 = ncpu;	/* known to be in d6 */
#  endif
    int x;

#  if defined(SGI_4D) || defined(CRAY)
    int	new;
#  endif

#  ifdef sgi
    long	stdin_pos;
    FILE	stdin_save;
    int	worker_pid_tbl[MAX_PSW] = {0};
#  endif

    /*
     * multithreading support for SunOS 5.X / Solaris 2.x
     */
#  if defined(SUNOS) && SUNOS >= 52
    static int	concurrency = 0; /* Max concurrency we have set */
#  endif
#  if (defined(SUNOS) && SUNOS >= 52) || defined(HAVE_PTHREAD_H)
    int		nthreadc;
    int		nthreade;
    rt_thread_t	thread;
    rt_thread_t	thread_tbl[MAX_PSW];
    int		i;
#  endif	/* SUNOS */

#  ifdef sgi
    memset(worker_pid_tbl, 0, MAX_PSW * sizeof(int));
#  endif

    if( bu_debug & BU_DEBUG_PARALLEL )
	bu_log("bu_parallel(0x%lx, %d, x%lx)\n", (long)func, ncpu, (long)arg );

    if( bu_pid_of_initiating_thread )
	bu_bomb("bu_parallel() called from within parallel section\n");

    bu_pid_of_initiating_thread = bu_process_id();

    if (ncpu > MAX_PSW) {
	bu_log("WARNING: bu_parallel() ncpu(%d) > MAX_PSW(%d), adjusting ncpu\n", ncpu, MAX_PSW);
	ncpu = MAX_PSW;
    }
    bu_nthreads_started = 0;
    bu_nthreads_finished = 0;
    bu_parallel_func = func;
    bu_parallel_arg = arg;

    /* if we're in debug mode, allow additional cpus */
    if (!(bu_debug & BU_DEBUG_PARALLEL)) {
	avail_cpus = bu_avail_cpus();
	if( ncpu > avail_cpus ) {
	    bu_log( "%d cpus requested, but only %d available\n", ncpu, avail_cpus );
	    ncpu = avail_cpus;
	}
    }

#  ifdef HEP
    bu_nthreads_started = 1;
    bu_nthreads_finished = 1;
    for( x=1; x<ncpu; x++ )  {
	/* This is more expensive when GEMINUS>1 */
	Dcreate( bu_parallel_interface );
    }
    (*func)(0,arg);	/* avoid wasting this task */
#  endif /* HEP */

#  ifdef CRAY
    bu_nthreads_started = 1;
    bu_nthreads_finished = 1;
    /* Create any extra worker tasks */
    for( x=1; x<ncpu; x++ ) {
	bu_taskcontrol[x].tsk_len = 3;
	bu_taskcontrol[x].tsk_value = x;
	TSKSTART( &bu_taskcontrol[x], bu_parallel_interface );
    }
    (*func)(0,arg);	/* avoid wasting this task */

    /* Wait for them to finish */
    for( x=1; x<ncpu; x++ )  {
	TSKWAIT( &bu_taskcontrol[x] );
    }
    /* There needs to be some way to kill the tfork()'ed processes here */
#  endif

#  if defined(alliant) && !defined(i860)
#	if defined(__STDC__)	/* fxc defines it == 0 !! */
#	undef __STDC__
#	define __STDC__	2

    /* Calls bu_parallel_interface in parallel "ncpu" times */
    concurrent_call(CNCALL_COUNT|CNCALL_NO_QUIT, bu_parallel_interface, ncpu);

#	else
    {
	asm("	movl		d6,d0");
	asm("	subql		#1,d0");
	asm("	cstart		d0");
	asm("super_loop:");
	bu_parallel_interface();		/* d7 has current index, like magic */
	asm("	crepeat		super_loop");
    }
#	endif
#  endif

#  if defined(alliant) && defined(i860)
#pragma loop cncall
    for( x=0; x<ncpu; x++) {
	bu_parallel_interface();
    }
#  endif

#  if defined(convex) || defined(__convex__)
    /*$dir force_parallel */
    for( x=0; x<ncpu; x++ )  {
	bu_parallel_interface();
    }
#  endif /* convex */

#  ifdef ardent
    /* The stack size parameter is pure guesswork */
    parstack( bu_parallel_interface, 1024*1024, ncpu );
#  endif /* ardent */

#  ifdef SGI_4D
    stdin_pos = ftell(stdin);
    stdin_save = *(stdin);		/* struct copy */
    bu_nthreads_started = 1;
    bu_nthreads_finished = 1;

    /* Note:  it may be beneficial to call prctl(PR_SETEXITSIG); */
    /* prctl(PR_TERMCHILD) could help when parent dies.  But SIGHUP??? hmmm */
    for( x = 1; x < ncpu; x++)  {
	/*
	 *  Start a share-group process, sharing ALL resources.
	 *  This direct sys-call can be used because none of the
	 *  task-management services of, eg, taskcreate() are needed.
	 */
#    if defined(IRIX) && IRIX <= 4
	/*  Stack size per proc comes from RLIMIT_STACK (typ 64MBytes). */
	new = sproc( bu_parallel_interface, PR_SALL, 0 );
#    else
	/* State maximum stack size.
	 * Be generous, as this mainly costs address space.
	 * RAM is allocated only to those pages used.
	 * On the other hand, don't be too generous, because each
	 * proc needs this much space on, e.g. a 64 processor system.
	 * Don't go quite for an even number of megabytes,
	 * in the hopes of creating a small 32k "buffer zone"
	 * to catch stack overflows.
	 */
	new = sprocsp( (void (*)(void *, size_t))bu_parallel_interface,
		       PR_SALL, 0, NULL,
#      if defined(IRIX64)
		       64*1024*1024 - 32*1024
#      else
		       4*1024*1024 - 32*1024
#      endif
		       );
#    endif
	if( new < 0 )  {
	    perror("sproc");
	    bu_log("ERROR bu_parallel(): sproc(x%x, x%x, )=%d failed on processor %d\n",
		   bu_parallel_interface, PR_SALL,
		   new, x );
	    bu_log("sbrk(0)=x%x\n", sbrk(0) );
	    bu_bomb("bu_parallel() failure");
	} else {
	    worker_pid_tbl[x] = new;
	}

    }
    (*func)(0,arg);	/* don't waste this thread */
    {
	int	pid;
	int	pstat;
	int	children;

	/*
	 * Make sure all children are done.
	 */
	while ( children=bu_worker_tbl_not_empty(worker_pid_tbl) ) {
	    pstat = 0;
	    if ( (pid = wait(&pstat)) < 0) {
		perror("bu_parallel() wait()");
		bu_kill_workers(worker_pid_tbl);
		bu_bomb("parallelism error");
	    } else if (pid == 0) {
		bu_log("bu_parallel() wait() == 0 with %d children remaining\n", children);
		bu_kill_workers(worker_pid_tbl);
		bu_bomb("Missing worker");
	    } else {
		if( (pstat & 0xFF) != 0 )  {
		    bu_log("***ERROR: bu_parallel() worker %d exited with status x%x!\n", pid, pstat);
		    /* XXX How to cope with this;  can't back out work that was lost at this level. */
#    ifdef IRIX
		    if (WIFEXITED(pstat))
			bu_log ("Child terminated normally with status %d 0x%0x\n",
				WEXITSTATUS(pstat));

		    if (WIFSIGNALED(pstat)) {
			bu_log("child terminated on signal %d %0x\n", WTERMSIG(pstat));
			if (pstat & 0200)
			    bu_log("core dumped\n");
			else
			    bu_log("No core dump\n");
		    }
		    if (WIFSTOPPED(pstat))
			bu_log("child is stopped on signal %d 0x%x\n", WSTOPSIG(pstat));

		    if ( (pstat & 0177777) == 0177777 )
			bu_log("child has continued\n");

#    endif
		    bu_kill_workers(worker_pid_tbl);
		    bu_bomb("A worker blew out");
		}
		/* remove pid from worker_pid_tbl */
		for (x=1 ; x < ncpu ; x++)
		    if (worker_pid_tbl[x] == pid) {
			worker_pid_tbl[x] = 0;
			break;
		    }

		if (x >= ncpu) {
		    bu_log("WARNING: bu_parallel(): wait() returned non-child process, pid %d\n", pid);
		}
	    }
	}
    }
    if( ftell(stdin) != stdin_pos )  {
	/*
	 *  Gross SGI bug:  when a thread is finished, it returns
	 *  to the stack frame created by sproc(), which
	 *  just calls exit(0), resulting in all STDIO file buffers
	 *  being fflush()ed.  This zaps the stdin position, and
	 *  may wreak additional havoc.
	 *  Exists in IRIX 3.3.1, Irix 4.0.5,
	 *  should be fixed in a later release.  Maybe.
	 */
	bu_log("\nWarning:  stdin file pointer has been corrupted by SGI multi-processor bug!\n");
	if( bu_debug & BU_DEBUG_PARALLEL )  {
	    bu_log("Original position was x%x, now position is x%x!\n", stdin_pos, ftell(stdin) );
	    bu_pr_FILE("saved stdin", &stdin_save);
	    bu_pr_FILE("current stdin", stdin);
	}
	fseek(stdin, stdin_pos, SEEK_SET);
	if( ftell(stdin) != stdin_pos )  {
	    bu_log("WARNING: fseek() did not recover proper position.\n");
	} else {
	    bu_log("It was fixed by fseek()\n");
	}
    }
#  endif /* sgi */

#  if defined(n16)
    /* The shared memory size requirement is sheer guesswork */
    /* The stack size is also guesswork */
    if( task_init( 8*1024*1024, ncpu, bu_parallel_interface, 128*1024, 0 ) < 0 )
	perror("bu_parallel()/task_init()");
#  endif

    /*
     * multithreading support for SunOS 5.X / Solaris 2.x
     */
#  if defined(SUNOS) && SUNOS >= 52

    thread = 0;
    nthreadc = 0;

    /* Give the thread system a hint... */
    if (ncpu > concurrency) {
	if (thr_setconcurrency(ncpu)) {
	    fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_setconcurrency(%d) failed\n",
		    ncpu);
	    bu_log("ERROR parallel.c/bu_parallel(): thr_setconcurrency(%d) failed\n",
		   ncpu);
	    /* Not much to do, lump it */
	} else {
	    concurrency = ncpu;
	}
    }

    /* Create the threads */
    for (x = 0; x < ncpu; x++)  {

	if (thr_create(0, 0, (void *(*)(void *))bu_parallel_interface, 0, 0, &thread)) {
	    fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
		    bu_parallel_interface, &thread, x);
	    bu_log("ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
		   bu_parallel_interface, &thread, x);
	    /* Not much to do, lump it */
	} else {
	    if( bu_debug & BU_DEBUG_PARALLEL )
		bu_log("bu_parallel(): created thread: (thread: 0x%x) (loop:%d) (nthreadc:%d)\n",
		       thread, x, nthreadc);

	    thread_tbl[nthreadc] = thread;
	    nthreadc++;
	}
    }

    if( bu_debug & BU_DEBUG_PARALLEL )
	for (i = 0; i < nthreadc; i++)
	    bu_log("bu_parallel(): thread_tbl[%d] = 0x%x\n",
		   i, thread_tbl[i]);

    /*
     * Wait for completion of all threads.  We don't wait for
     * threads in order.  We wait for any old thread but we keep
     * track of how many have returned and whether it is one that we
     * started
     */
    thread = 0;
    nthreade = 0;
    for (x = 0; x < nthreadc; x++)  {
	if( bu_debug & BU_DEBUG_PARALLEL )
	    bu_log("bu_parallel(): waiting for thread to complete:\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
		   x, nthreadc, nthreade);

	if (thr_join((rt_thread_t)0, &thread, NULL)) {
	    /* badness happened */
	    fprintf(stderr, "thr_join()");
	}

	/* Check to see if this is one the threads we created */
	for (i = 0; i < nthreadc; i++) {
	    if (thread_tbl[i] == thread) {
		thread_tbl[i] = (rt_thread_t)-1;
		nthreade++;
		break;
	    }
	}

	if ((thread_tbl[i] != (rt_thread_t)-1) && i < nthreadc) {
	    bu_log("bu_parallel(): unknown thread %d completed.\n",
		   thread);
	}

	if( bu_debug & BU_DEBUG_PARALLEL )
	    bu_log("bu_parallel(): thread completed: (thread: %d)\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
		   thread, x, nthreadc, nthreade);
    }

    if( bu_debug & BU_DEBUG_PARALLEL )
	bu_log("bu_parallel(): %d threads created.  %d threads exited.\n",
	       nthreadc, nthreade);
#  endif	/* SUNOS */

#  if defined(HAVE_PTHREAD_H) && !defined(sgi)

    thread = 0;
    nthreadc = 0;

    /* XXX How to advise thread library that we need 'ncpu' processors? */

    /* Create the threads */
    for (x = 0; x < ncpu; x++)  {
	pthread_attr_t attrs;
	pthread_attr_init(&attrs);
	pthread_attr_setstacksize(&attrs,10*1024*1024);

	if (pthread_create(&thread, &attrs,
			   (void *(*)(void *))bu_parallel_interface, NULL)) {
	    fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%lx, 0x0, 0, 0x%lx) failed on processor %d\n",
		    (unsigned long int)bu_parallel_interface, (unsigned long int)&thread, x);
	    bu_log("ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
		   bu_parallel_interface, &thread, x);
	    /* Not much to do, lump it */
	} else {
	    if( bu_debug & BU_DEBUG_PARALLEL ) {
		bu_log("bu_parallel(): created thread: (thread: %d) (loop:%d) (nthreadc:%d)\n",
		       thread, x, nthreadc);
	    }

	    thread_tbl[nthreadc] = thread;
	    nthreadc++;
	}
    }


    if( bu_debug & BU_DEBUG_PARALLEL ) {
	for (i = 0; i < nthreadc; i++) {
	    bu_log("bu_parallel(): thread_tbl[%d] = %d\n",
		   i, thread_tbl[i]);
	}
#    ifdef SIGINFO
	/* may be BSD-only (calls _thread_dump_info()) */
	raise(SIGINFO);
#    endif
    }

    /*
     * Wait for completion of all threads.
     * Wait for them in order.
     */
    thread = 0;
    nthreade = 0;
    for (x = 0; x < nthreadc; x++)  {
	int ret;

	if( bu_debug & BU_DEBUG_PARALLEL )
	    bu_log("bu_parallel(): waiting for thread x%x to complete:\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
		   thread_tbl[x], x, nthreadc, nthreade);

	if ( (ret = pthread_join(thread_tbl[x], NULL)) != 0) {
	    /* badness happened */
	    fprintf(stderr, "pthread_join(thread_tbl[%d]=0x%lx) ret=%d\n", x, (size_t)thread_tbl[x], ret);
	}
	nthreade++;
	thread_tbl[x] = (rt_thread_t)-1;

	if( bu_debug & BU_DEBUG_PARALLEL )
	    bu_log("bu_parallel(): thread completed: (thread: %d)\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
		   thread, x, nthreadc, nthreade);
    }

    if( bu_debug & BU_DEBUG_PARALLEL )
	bu_log("bu_parallel(): %d threads created.  %d threads exited.\n",
	       nthreadc, nthreade);

#  endif /* end if posix threads */

    /*
     *  Ensure that all the threads are REALLY finished.
     *  On some systems, if threads core dump, the rest of
     *  the gang keeps going, so this can actually happen (sigh).
     */
    if( bu_nthreads_finished != bu_nthreads_started )  {
	bu_log("*** ERROR bu_parallel(%d): %d workers did not finish!\n\n",
	       ncpu, ncpu - bu_nthreads_finished);
    }
    if( bu_nthreads_started != ncpu )  {
	bu_log("bu_parallel() NOTICE:  only %d workers started, expected %d\n",
	       bu_nthreads_started, ncpu );
    }

    if( bu_debug & BU_DEBUG_PARALLEL )
	bu_log("bu_parallel(%d) complete, now serial\n", ncpu);

#  ifdef CHECK_PIDS
    /*
     * At this point, all multi-tasking activity should have ceased,
     * and we should be just a single UNIX process with our original
     * PID and open file table (kernel struct u).  If not, then any
     * output may be written into the wrong file.
     */
    x = bu_process_id();
    if (bu_pid_of_initiating_thread != x) {
	bu_log("WARNING: bu_parallel():  PID of initiating thread changed from %d to %d, open file table may be botched!\n",
	       bu_pid_of_initiating_thread, x );
    }
#  endif
    bu_pid_of_initiating_thread = 0;	/* No threads any more */

#else	/* PARALLEL */
    bu_log("bu_parallel( x%lx, %d., x%lx ):  Not compiled for PARALLEL machine, running single-threaded\n", (long)func, ncpu, (long)arg );
    /* do the work anyways */
    (*func)(0,arg);
#endif	/* PARALLEL */

    return;
}

/** @@} */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.44
log
@raise() works on windows and is c89, so bye bye
@
text
@d661 1
a661 1
    bzero( (char *)tbl, sizeof(tbl) );
@


14.43
log
@bu_get_load_average() has a horrible implementation but fortunately we don't even use it.  mark it deprecated.
@
text
@d47 1
d1164 1
a1164 1
#    if defined(HAVE_RAISE) && defined(SIGINFO)
@


14.42
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@d508 3
@


14.41
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d511 1
@


14.40
log
@limits.h, locale.h, setjmp.g, and signal.h now all assumed as well as part of ongoing c89 migration.
@
text
@a37 4
#ifndef lint
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.39 2007/09/14 20:06:49 brlcad Exp $ (ARL)";
#endif

a42 1

a43 1

d46 2
a47 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.39
log
@The c89 headers are all fair game since it's been a requirement since the move to ANSI c89 compliance.  So.. remove the HAVE_STDLIB_H checks and just use the header.  The headers <complex.h>, <fenv.h>, <inttypes.h>, <stdbool.h>, <stdint.h>, and <tgmath.h> were added with C99 and still need to be checked.  There are several other c89 headers that we could just use, though, that are still being checked.
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.38 2007/08/30 19:19:00 erikgreenwald Exp $ (ARL)";
a51 3
#ifdef HAVE_SIGNAL_H
#  include <signal.h>
#endif
@


14.38
log
@added missing header for fbsd. changed chmod() to fchmod() (flawfinder).
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.37 2007/08/29 21:26:21 erikgreenwald Exp $ (ARL)";
d48 1
a48 5
#ifdef HAVE_STDLIB_H
# include <stdlib.h>
#elif defined(HAVE_MALLOC_H)
# include <malloc.h>
#endif
@


14.37
log
@Remove unnecessary __ppc__ test (use __APPLE__ to do both PPC and Intel).
Get the number of available CPU's instead of present CPU's on a Mac.
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.36 2007/08/29 19:06:30 erikgreenwald Exp $ (ARL)";
d82 1
d578 1
a579 2
	(void)chmod(PUBLIC_CPUS1, 0666);
	(void)chmod(PUBLIC_CPUS2, 0666);
d1196 1
a1196 1
	    fprintf(stderr, "pthread_join(thread_tbl[%d]=0x%x) ret=%d\n", x, (size_t)thread_tbl[x], ret);
@


14.36
log
@Allow intel macs to see more than 2 from bu_avail_cpus().. PR#1784346
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.35 2007/08/18 00:22:58 brlcad Exp $ (ARL)";
d414 1
a414 1
#if defined(__ppc__) || defined(__APPLE__)
d420 1
a420 1
	mib[1] = HW_NCPU;
@


14.35
log
@allow the ray-tracers to use more than the available cpus for debugging and testing purposes.  this was previously only possible via compile-time modifications, but now is possible via the BU_DEBUG_PARALLEL debug flag (-\!10 on most of the raytracers).
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.34 2007/05/31 19:51:09 erikgreenwald Exp $ (ARL)";
d414 1
a414 1
#if defined(__ppc__)
@


14.34
log
@use size_t instead of unsigned int for casting a pointer to an int (warning on 64b opteron/fbsd)
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.33 2007/05/27 21:48:56 brlcad Exp $ (ARL)";
d836 8
a843 4
    avail_cpus = bu_avail_cpus();
    if( ncpu > avail_cpus ) {
	bu_log( "%d cpus requested, but only %d available\n", ncpu, avail_cpus );
	ncpu = avail_cpus;
a845 1

@


14.33
log
@it's an array of ints, so sizeof accordingly
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.32 2007/05/12 22:23:04 brlcad Exp $ (ARL)";
d1193 1
a1193 1
	    fprintf(stderr, "pthread_join(thread_tbl[%d]=0x%x) ret=%d\n", x, (unsigned int)thread_tbl[x], ret);
@


14.32
log
@use new bu_process_id() function to get the pid now
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.31 2007/05/12 05:30:38 brlcad Exp $ (ARL)";
d817 1
a817 1
    memset(worker_pid_tbl, 0, MAX_PSW * sizeof(rt_thread_t));
@


14.31
log
@ws and minor dead code cleanup
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.30 2007/05/12 05:16:18 brlcad Exp $ (ARL)";
d826 1
a826 5
#  ifdef HAVE_UNISTD_H
    bu_pid_of_initiating_thread = getpid();
#  else
    bu_pid_of_initiating_thread = (int)GetCurrentProcessId();
#  endif
d1233 1
a1233 5
#  ifdef HAVE_UNISTD_H
    x = getpid();
#  else
    x = (int)GetCurrentProcessId();
#  endif
@


14.30
log
@add getpid() equivalence for win32 ala GetCurrentProcessId() so that parallel stuff can be closer to working native
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.29 2007/04/14 23:58:54 brlcad Exp $ (ARL)";
d199 3
a201 3
	int	tsk_len;
	int	tsk_id;
	int	tsk_value;
d216 1
a216 1
  int opri, npri;
d221 7
a227 7
  opri = getpriority( PRIO_PROCESS, 0 );
  setpriority( PRIO_PROCESS, 0, newnice );
  npri = getpriority( PRIO_PROCESS, 0 );

  if( bu_debug ) {
      bu_log("bu_nice_set() Priority changed from %d to %d\n", opri, npri);
  }
d230 4
a233 4
  /* no known means to change the nice value */
  if (bu_debug) {
    bu_log("bu_nice_set() Priority NOT changed\n");
  }
d248 2
a249 2
	long	old;			/* 64-bit clock counts */
	extern long limit();
d251 6
a256 6
	if( (old = limit( C_PROC, 0, L_CPU, -1 )) < 0 )  {
		perror("bu_cpulimit_get(): CPU limit(get)");
	}
	if( old <= 0 )
		return(999999);		/* virtually unlimited */
	return( (old + HZ - 1) / HZ );
d258 1
a258 1
	return(-1);
d272 15
a286 15
	long	old;		/* seconds */
	long	new;		/* seconds */
	long	newtick;	/* 64-bit clock counts */
	extern long limit();

	old = bu_cpulimit_get();
	new = old + sec;
	if( new <= 0 || new > 999999 )
		new = 999999;	/* no limit, for practical purposes */
	newtick = new * HZ;
	if( limit( C_PROC, 0, L_CPU, newtick ) < 0 )  {
		perror("bu_cpulimit_set: CPU limit(set)");
	}
	bu_log("Cray CPU limit changed from %d to %d seconds\n",
		old, newtick/HZ );
d288 5
a292 5
	/* Eliminate any memory limit */
	if( limit( C_PROC, 0, L_MEM, 0 ) < 0 )  {
		/* Hopefully, not fatal if memory limits are imposed */
		perror("bu_cpulimit_set: MEM limit(set)");
	}
d294 1
a294 1
	if (sec < 0) sec = 0;
d307 1
a307 1
	int ncpu = -1;
d311 7
a317 7
	/* SUNOS and linux */
	ncpu = sysconf(_SC_NPROCESSORS_ONLN);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
d319 6
a324 6
	ncpu = sysconf(_SC_NPROC_ONLN);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
d326 7
a332 7
	/* cray */
	ncpu = sysconf(_SC_CRAY_NCPU);
	if (ncpu < 0) {
		perror("Unable to get the number of available CPUs");
		ncpu = 1;
	}
	goto DONE_NCPU;
d337 10
a346 10
	/* XXX LAB 04 June 2002
	 * The call prctl(PR_MAXPPROCS) is supposed to indicate the number
	 * of processors this process can use.  Unfortuantely, this returns
	 * 0 when running under a CPU set.  A bug report has been filed with
	 * SGI.
	 *
	 * The sysmp(MP_NPROCS) call returns the number of physically
	 * configured processors.  This will have to suffice until SGI
	 * comes up with a fix.
	 */
d348 1
a348 1
	ncpu = sysmp(MP_NPROCS);
d350 1
a350 1
	ncpu = (int)prctl(PR_MAXPPROCS);
d352 1
a352 1
	goto DONE_NCPU;
d357 2
a358 2
	{
	  long	memsize, ipnum, cenum, detnum, attnum;
d361 2
a362 2
	  /* FX/8 */
	  lib_syscfg( &memsize, &ipnum, &cenum, &detnum, &attnum );
d364 2
a365 2
	  /* FX/2800 */
	  attnum = 28;
d367 3
a369 3
	  ncpu = attnum;		/* # of CEs attached to parallel Complex */
	  goto DONE_NCPU;
	}
d374 9
a382 9
	{
	  int status;
	  int cmd;
	  int parmlen;
	  struct var p;

	  cmd = SYS_GETPARMS;
	  parmlen = sizeof(struct var);
	  if ( sysconfig(cmd, &p, parmlen) != 0 ) {
a383 3
	  }
	  ncpu = p.v_ncpus;
	  goto DONE_NCPU;
d385 3
d392 3
a394 3
	if( (ncpu = sysadmin( SADMIN_NUMCPUS, 0 )) < 0 )
	  perror("sysadmin");
	goto DONE_NCPU;
d399 5
a403 5
	{
	  int maxproc;
	  size_t len;
	  len = 4;
	  if (sysctlbyname("hw.ncpu", &maxproc, &len, NULL, 0) == -1) {
d406 1
a406 1
	  } else {
a407 2
	  }
	  goto DONE_NCPU;
d409 2
d415 8
a422 8
	{
	  int mib[2], maxproc;
	  size_t len;

	  mib[0] = CTL_HW;
	  mib[1] = HW_NCPU;
	  len = sizeof(maxproc);
	  if (sysctl(mib, 2, &maxproc, &len, NULL, 0) == -1) {
d425 1
a425 1
	  } else {
a426 2
	  }
	  goto DONE_NCPU;
d428 2
d434 2
a435 2
	ncpu = get_nprocs(); /* GNU extension from sys/sysinfo.h */
	goto DONE_NCPU;
d440 7
a446 7
	{
	  /* old retired linux method */
	  /*
	   * Ultra-kludgey way to determine the number of cpus in a
	   * linux box--count the number of processor entries in
	   * /proc/cpuinfo!
	   */
d449 2
a450 2
	  FILE *fp;
	  char buf[128];
d452 1
a452 1
	  ncpu = 0;
d454 1
a454 1
	  fp = fopen (CPUINFO_FILE,"r");
d456 1
a456 1
	  if (fp == NULL) {
d459 1
a459 1
	  } else {
d461 3
a463 3
	      if (strncmp (buf, "processor",9) == 0) {
		++ ncpu;
	      }
d468 1
a468 1
	      ncpu = 1;
a469 2
	  }
	  goto DONE_NCPU;
d471 2
d476 8
a483 8
	/* Windows */
	{
	    SYSTEM_INFO sysinfo;

	    GetSystemInfo(&sysinfo);
	    ncpu = (int)sysinfo.dwNumberOfProcessors;
	    goto DONE_NCPU;
	}
d486 1
a486 1
DONE_NCPU:  ; /* allows debug and final validity check */
d490 4
a493 4
	/* if they have threading and we could not detect properly, claim two */
	if (ncpu < 0) {
		ncpu = 2;
	}
d496 4
a499 4
	if (bu_debug & BU_DEBUG_PARALLEL) {
		/* do not use bu_log() here, this can get called before semaphores are initialized */
		fprintf( stderr, "bu_avail_cpus: counted %d cpus.\n", ncpu);
	}
d501 3
a503 3
	if (ncpu > 0) {
		return ncpu;
	}
d505 1
a505 1
	return( DEFAULT_PSW );
d522 1
a522 1
	double	load = -1.0;
d524 1
a524 1
	FILE	*fp;
d526 3
a528 3
	fp = popen("PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd; export PATH; uptime|sed -e 's/.*average: //' -e 's/,.*//' ", "r");
	if( !fp )
		return -1.0;
d530 2
a531 2
	fscanf( fp, "%lf", &load );
	fclose(fp);
d533 1
a533 1
	while( wait(NULL) != -1 )  ;	/* NIL */
d535 1
a535 1
	return load;
d556 1
a556 1
	int	avail_cpus = bu_avail_cpus();
d558 2
a559 2
	int	public_cpus = 1;
	FILE	*fp;
d561 2
a562 2
	if( (fp = fopen(PUBLIC_CPUS1, "r")) != NULL ||
	    (fp = fopen(PUBLIC_CPUS2, "r")) != NULL
d564 6
a569 6
		(void)fscanf( fp, "%d", &public_cpus );
		fclose(fp);
		if( public_cpus < 0 )  public_cpus = avail_cpus + public_cpus;
		if( public_cpus > avail_cpus )  public_cpus = avail_cpus;
		return public_cpus;
	}
d571 4
a574 4
	(void)unlink(PUBLIC_CPUS1);
	(void)unlink(PUBLIC_CPUS2);
	if( (fp = fopen(PUBLIC_CPUS1, "w")) != NULL ||
	    (fp = fopen(PUBLIC_CPUS2, "w")) != NULL
d576 5
a580 5
		fprintf(fp, "%d\n", avail_cpus);
		fclose(fp);
		(void)chmod(PUBLIC_CPUS1, 0666);
		(void)chmod(PUBLIC_CPUS2, 0666);
	}
d582 1
a582 1
	return avail_cpus;
d599 2
a600 2
	{
		int	policy;
d602 4
a605 4
		if( (policy = sched_getscheduler(0)) >= 0 )  {
			if( policy == SCHED_RR || policy == SCHED_FIFO )
				return 1;
		}
d607 1
a607 1
		sched_getparam( 0, &bu_param );
d609 5
a613 7
		if ( sched_setscheduler( 0,
			SCHED_RR,		/* policy */
			&bu_param
		    ) >= 0 )  {
			return 1;		/* realtime */
		}
		/* Fall through to return 0 */
d615 2
d618 1
a618 1
	return 0;
d623 3
d627 1
a627 4
	/*
	 * Cray is known to wander among various pids, perhaps others.
	 */
#	define	CHECK_PIDS	1
d630 1
d641 1
a641 1
int tbl[MAX_PSW];
d643 2
a644 2
	register int i;
	register int children=0;
d646 2
a647 2
	for (i=1 ; i < MAX_PSW ; ++i)
		if (tbl[i]) children++;
d649 1
a649 1
	return(children);
d657 1
a657 1
int tbl[MAX_PSW];
d659 1
a659 1
  register int i;
d661 9
a669 8
  for (i=1 ; i < MAX_PSW ; ++i) {
    if ( tbl[i] ) {
      if( kill(tbl[i], 9) ) {
	perror("bu_kill_workers(): SIGKILL to child process");
      }
      else {
	bu_log("bu_kill_workers(): child pid %d killed\n", tbl[i]);
      }
a670 1
  }
d672 1
a672 1
  bzero( (char *)tbl, sizeof(tbl) );
d683 1
d702 1
a702 1
	register int	cpu;		/* our CPU (thread) number */
d706 5
a710 5
	{
		pthread_t	pt;
		pt = pthread_self();
		fprintf(stderr,"bu_parallel_interface, Thread ID = 0x%x\n", (unsigned int)pt);
	}
d713 19
a731 19
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	cpu = bu_nthreads_started++;
	bu_semaphore_release( BU_SEM_SYSCALL );

	(*bu_parallel_func)(cpu, bu_parallel_arg);

	bu_semaphore_acquire( BU_SEM_SYSCALL );
	bu_nthreads_finished++;
	bu_semaphore_release( BU_SEM_SYSCALL );

#	if defined(SGI_4D) || defined(IRIX)
	/*
	 *  On an SGI, a process/thread created with the "sproc" syscall has
	 *  all of it's file descriptors closed when it "returns" to sproc.
	 *  Since this trashes file descriptors which may still be in use by
	 *  other processes, we avoid ever returning to sproc.
	 */
	if(cpu) _exit(0);
#	endif /* SGI */
d743 2
a744 2
char	*title;
FILE	*fp;
d746 8
a753 8
	bu_log("FILE structure '%s', at x%x:\n", title, fp );
	bu_log(" _cnt = x%x\n", fp->_cnt);
	bu_log(" _ptr = x%x\n", fp->_ptr);
	bu_log(" _base = x%x\n", fp->_base);
	bu_log(" _file = x%x\n", fp->_file);
	bu_printb(" _flag ", fp->_flag & 0xFF,
		"\010\010_IORW\7_100\6_IOERR\5_IOEOF\4_IOMYBUF\3_004\2_IOWRT\1_IOREAD" );
	bu_log("\n");
d757 1
d779 3
a781 3
void		(*func) BU_ARGS((int, genptr_t));
int		ncpu;
genptr_t	arg;
d784 1
a784 1
	int	avail_cpus;
d787 2
a788 2
	register int d7;	/* known to be in d7 */
	register int d6 = ncpu;	/* known to be in d6 */
d790 1
a790 1
	int x;
d793 1
a793 1
	int	new;
d797 3
a799 3
	long	stdin_pos;
	FILE	stdin_save;
	int	worker_pid_tbl[MAX_PSW];
d802 3
a804 3
/*
 * multithreading support for SunOS 5.X / Solaris 2.x
 */
d806 1
a806 1
	static int	concurrency = 0; /* Max concurrency we have set */
d809 5
a813 5
	int		nthreadc;
	int		nthreade;
	rt_thread_t	thread;
	rt_thread_t	thread_tbl[MAX_PSW];
	int		i;
d817 1
a817 1
	bzero(worker_pid_tbl, sizeof(worker_pid_tbl) );
d820 2
a821 2
	if( bu_debug & BU_DEBUG_PARALLEL )
		bu_log("bu_parallel(0x%lx, %d, x%lx)\n", (long)func, ncpu, (long)arg );
d823 2
a824 2
	if( bu_pid_of_initiating_thread )
		bu_bomb("bu_parallel() called from within parallel section\n");
d827 1
a827 1
	bu_pid_of_initiating_thread = getpid();
d829 1
a829 1
	bu_pid_of_initiating_thread = (int)GetCurrentProcessId();
d832 13
a844 13
	if (ncpu > MAX_PSW) {
		bu_log("WARNING: bu_parallel() ncpu(%d) > MAX_PSW(%d), adjusting ncpu\n", ncpu, MAX_PSW);
		ncpu = MAX_PSW;
	}
	bu_nthreads_started = 0;
	bu_nthreads_finished = 0;
	bu_parallel_func = func;
	bu_parallel_arg = arg;
	avail_cpus = bu_avail_cpus();
	if( ncpu > avail_cpus ) {
		bu_log( "%d cpus requested, but only %d available\n", ncpu, avail_cpus );
		ncpu = avail_cpus;
	}
d848 7
a854 7
	bu_nthreads_started = 1;
	bu_nthreads_finished = 1;
	for( x=1; x<ncpu; x++ )  {
		/* This is more expensive when GEMINUS>1 */
		Dcreate( bu_parallel_interface );
	}
	(*func)(0,arg);	/* avoid wasting this task */
d858 9
a866 5
#    if 0
	/* Try to give up processors as soon as they are un needed */
	new = 0;
	TSKTUNE( "DBRELEAS", &new );
#    endif
d868 5
a872 15
	bu_nthreads_started = 1;
	bu_nthreads_finished = 1;
	/* Create any extra worker tasks */
	for( x=1; x<ncpu; x++ ) {
		bu_taskcontrol[x].tsk_len = 3;
		bu_taskcontrol[x].tsk_value = x;
		TSKSTART( &bu_taskcontrol[x], bu_parallel_interface );
	}
	(*func)(0,arg);	/* avoid wasting this task */

	/* Wait for them to finish */
	for( x=1; x<ncpu; x++ )  {
		TSKWAIT( &bu_taskcontrol[x] );
	}
	/* There needs to be some way to kill the tfork()'ed processes here */
d880 2
a881 2
	/* Calls bu_parallel_interface in parallel "ncpu" times */
	concurrent_call(CNCALL_COUNT|CNCALL_NO_QUIT, bu_parallel_interface, ncpu);
d884 8
a891 8
	{
		asm("	movl		d6,d0");
		asm("	subql		#1,d0");
		asm("	cstart		d0");
		asm("super_loop:");
		bu_parallel_interface();		/* d7 has current index, like magic */
		asm("	crepeat		super_loop");
	}
d896 4
a899 4
	#pragma loop cncall
	for( x=0; x<ncpu; x++) {
		bu_parallel_interface();
	}
d903 4
a906 4
	/*$dir force_parallel */
	for( x=0; x<ncpu; x++ )  {
		bu_parallel_interface();
	}
d910 2
a911 2
	/* The stack size parameter is pure guesswork */
	parstack( bu_parallel_interface, 1024*1024, ncpu );
d915 13
a927 13
	stdin_pos = ftell(stdin);
	stdin_save = *(stdin);		/* struct copy */
	bu_nthreads_started = 1;
	bu_nthreads_finished = 1;

	/* Note:  it may be beneficial to call prctl(PR_SETEXITSIG); */
	/* prctl(PR_TERMCHILD) could help when parent dies.  But SIGHUP??? hmmm */
	for( x = 1; x < ncpu; x++)  {
		/*
		 *  Start a share-group process, sharing ALL resources.
		 *  This direct sys-call can be used because none of the
		 *  task-management services of, eg, taskcreate() are needed.
		 */
d929 2
a930 2
		/*  Stack size per proc comes from RLIMIT_STACK (typ 64MBytes). */
		new = sproc( bu_parallel_interface, PR_SALL, 0 );
d932 17
a948 17
		/* State maximum stack size.
		 * Be generous, as this mainly costs address space.
		 * RAM is allocated only to those pages used.
		 * On the other hand, don't be too generous, because each
		 * proc needs this much space on, e.g. a 64 processor system.
		 * Don't go quite for an even number of megabytes,
		 * in the hopes of creating a small 32k "buffer zone"
		 * to catch stack overflows.
		 */
		new = sprocsp( (void (*)(void *, size_t))bu_parallel_interface,
			PR_SALL, 0, NULL,
#			if defined(IRIX64)
				64*1024*1024 - 32*1024
#			else
				4*1024*1024 - 32*1024
#			endif
			);
d950 17
a966 10
		if( new < 0 )  {
			perror("sproc");
			bu_log("ERROR bu_parallel(): sproc(x%x, x%x, )=%d failed on processor %d\n",
				bu_parallel_interface, PR_SALL,
				new, x );
			bu_log("sbrk(0)=x%x\n", sbrk(0) );
			bu_bomb("bu_parallel() failure");
		} else {
			worker_pid_tbl[x] = new;
		}
d968 17
a984 24
	}
	(*func)(0,arg);	/* don't waste this thread */
	{
		int	pid;
		int	pstat;
		int	children;

		/*
		 * Make sure all children are done.
		 */
		while ( children=bu_worker_tbl_not_empty(worker_pid_tbl) ) {
			pstat = 0;
			if ( (pid = wait(&pstat)) < 0) {
				perror("bu_parallel() wait()");
				bu_kill_workers(worker_pid_tbl);
				bu_bomb("parallelism error");
			} else if (pid == 0) {
				bu_log("bu_parallel() wait() == 0 with %d children remaining\n", children);
				bu_kill_workers(worker_pid_tbl);
				bu_bomb("Missing worker");
			} else {
				if( (pstat & 0xFF) != 0 )  {
					bu_log("***ERROR: bu_parallel() worker %d exited with status x%x!\n", pid, pstat);
					/* XXX How to cope with this;  can't back out work that was lost at this level. */
d986 13
a998 13
	if (WIFEXITED(pstat))
		bu_log ("Child terminated normally with status %d 0x%0x\n",
			WEXITSTATUS(pstat));

	if (WIFSIGNALED(pstat)) {
		bu_log("child terminated on signal %d %0x\n", WTERMSIG(pstat));
		if (pstat & 0200)
			bu_log("core dumped\n");
		else
			bu_log("No core dump\n");
	}
	if (WIFSTOPPED(pstat))
		bu_log("child is stopped on signal %d 0x%x\n", WSTOPSIG(pstat));
d1000 2
a1001 2
	if ( (pstat & 0177777) == 0177777 )
		bu_log("child has continued\n");
d1004 2
a1005 14
					bu_kill_workers(worker_pid_tbl);
					bu_bomb("A worker blew out");
				}
				/* remove pid from worker_pid_tbl */
				for (x=1 ; x < ncpu ; x++)
					if (worker_pid_tbl[x] == pid) {
						worker_pid_tbl[x] = 0;
						break;
					}

				if (x >= ncpu) {
					bu_log("WARNING: bu_parallel(): wait() returned non-child process, pid %d\n", pid);
				}
			}
d1007 11
d1019 18
d1038 3
a1040 21
		/*
		 *  Gross SGI bug:  when a thread is finished, it returns
		 *  to the stack frame created by sproc(), which
		 *  just calls exit(0), resulting in all STDIO file buffers
		 *  being fflush()ed.  This zaps the stdin position, and
		 *  may wreak additional havoc.
		 *  Exists in IRIX 3.3.1, Irix 4.0.5,
		 *  should be fixed in a later release.  Maybe.
		 */
		bu_log("\nWarning:  stdin file pointer has been corrupted by SGI multi-processor bug!\n");
		if( bu_debug & BU_DEBUG_PARALLEL )  {
			bu_log("Original position was x%x, now position is x%x!\n", stdin_pos, ftell(stdin) );
			bu_pr_FILE("saved stdin", &stdin_save);
			bu_pr_FILE("current stdin", stdin);
		}
		fseek(stdin, stdin_pos, SEEK_SET);
		if( ftell(stdin) != stdin_pos )  {
			bu_log("WARNING: fseek() did not recover proper position.\n");
		} else {
			bu_log("It was fixed by fseek()\n");
		}
d1042 1
d1046 4
a1049 4
	/* The shared memory size requirement is sheer guesswork */
	/* The stack size is also guesswork */
	if( task_init( 8*1024*1024, ncpu, bu_parallel_interface, 128*1024, 0 ) < 0 )
		perror("bu_parallel()/task_init()");
d1052 3
a1054 3
	/*
	 * multithreading support for SunOS 5.X / Solaris 2.x
	 */
d1057 2
a1058 2
	thread = 0;
	nthreadc = 0;
d1060 10
a1069 11
	/* Give the thread system a hint... */
	if (ncpu > concurrency) {
		if (thr_setconcurrency(ncpu)) {
			fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_setconcurrency(%d) failed\n",
				ncpu);
			bu_log("ERROR parallel.c/bu_parallel(): thr_setconcurrency(%d) failed\n",
			       ncpu);
			/* Not much to do, lump it */
		} else {
			concurrency = ncpu;
		}
d1071 1
d1073 2
a1074 2
	/* Create the threads */
	for (x = 0; x < ncpu; x++)  {
d1076 10
a1085 10
		if (thr_create(0, 0, (void *(*)(void *))bu_parallel_interface, 0, 0, &thread)) {
			fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
				bu_parallel_interface, &thread, x);
			bu_log("ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
				bu_parallel_interface, &thread, x);
			/* Not much to do, lump it */
		} else {
			if( bu_debug & BU_DEBUG_PARALLEL )
				bu_log("bu_parallel(): created thread: (thread: 0x%x) (loop:%d) (nthreadc:%d)\n",
				       thread, x, nthreadc);
d1087 2
a1088 3
			thread_tbl[nthreadc] = thread;
			nthreadc++;
		}
d1090 1
d1092 14
d1107 2
a1108 3
		for (i = 0; i < nthreadc; i++)
			bu_log("bu_parallel(): thread_tbl[%d] = 0x%x\n",
			       i, thread_tbl[i]);
d1110 4
a1113 17
	/*
	 * Wait for completion of all threads.  We don't wait for
	 * threads in order.  We wait for any old thread but we keep
	 * track of how many have returned and whether it is one that we
	 * started
	 */
	thread = 0;
	nthreade = 0;
	for (x = 0; x < nthreadc; x++)  {
		if( bu_debug & BU_DEBUG_PARALLEL )
			bu_log("bu_parallel(): waiting for thread to complete:\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
			       x, nthreadc, nthreade);

		if (thr_join((rt_thread_t)0, &thread, NULL)) {
			/* badness happened */
			fprintf(stderr, "thr_join()");
		}
d1115 8
a1122 8
		/* Check to see if this is one the threads we created */
		for (i = 0; i < nthreadc; i++) {
			if (thread_tbl[i] == thread) {
				thread_tbl[i] = (rt_thread_t)-1;
				nthreade++;
				break;
			}
		}
d1124 3
a1126 8
		if ((thread_tbl[i] != (rt_thread_t)-1) && i < nthreadc) {
			bu_log("bu_parallel(): unknown thread %d completed.\n",
			       thread);
		}

		if( bu_debug & BU_DEBUG_PARALLEL )
			bu_log("bu_parallel(): thread completed: (thread: %d)\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
			       thread, x, nthreadc, nthreade);
d1130 7
a1136 2
		bu_log("bu_parallel(): %d threads created.  %d threads exited.\n",
		       nthreadc, nthreade);
d1141 2
a1142 2
	thread = 0;
	nthreadc = 0;
d1144 1
a1144 1
	/* XXX How to advise thread library that we need 'ncpu' processors? */
d1146 18
a1163 18
	/* Create the threads */
	for (x = 0; x < ncpu; x++)  {
		pthread_attr_t attrs;
		pthread_attr_init(&attrs);
		pthread_attr_setstacksize(&attrs,10*1024*1024);

		if (pthread_create(&thread, &attrs,
		    (void *(*)(void *))bu_parallel_interface, NULL)) {
			fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%lx, 0x0, 0, 0x%lx) failed on processor %d\n",
				(unsigned long int)bu_parallel_interface, (unsigned long int)&thread, x);
			bu_log("ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
				bu_parallel_interface, &thread, x);
			/* Not much to do, lump it */
		} else {
			if( bu_debug & BU_DEBUG_PARALLEL ) {
				bu_log("bu_parallel(): created thread: (thread: %d) (loop:%d) (nthreadc:%d)\n",
				       thread, x, nthreadc);
			}
d1165 2
a1166 3
			thread_tbl[nthreadc] = thread;
			nthreadc++;
		}
d1168 1
d1171 5
a1175 5
	if( bu_debug & BU_DEBUG_PARALLEL ) {
		for (i = 0; i < nthreadc; i++) {
			bu_log("bu_parallel(): thread_tbl[%d] = %d\n",
			       i, thread_tbl[i]);
		}
d1177 2
a1178 2
		/* may be BSD-only (calls _thread_dump_info()) */
		raise(SIGINFO);
d1180 10
a1189 1
	}
d1191 3
a1193 19
	/*
	 * Wait for completion of all threads.
	 * Wait for them in order.
	 */
	thread = 0;
	nthreade = 0;
	for (x = 0; x < nthreadc; x++)  {
		int ret;

		if( bu_debug & BU_DEBUG_PARALLEL )
			bu_log("bu_parallel(): waiting for thread x%x to complete:\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
				thread_tbl[x], x, nthreadc, nthreade);

		if ( (ret = pthread_join(thread_tbl[x], NULL)) != 0) {
			/* badness happened */
			fprintf(stderr, "pthread_join(thread_tbl[%d]=0x%x) ret=%d\n", x, (unsigned int)thread_tbl[x], ret);
		}
		nthreade++;
		thread_tbl[x] = (rt_thread_t)-1;
d1195 3
a1197 3
		if( bu_debug & BU_DEBUG_PARALLEL )
			bu_log("bu_parallel(): thread completed: (thread: %d)\t(loop:%d) (nthreadc:%d) (nthreade:%d)\n",
			       thread, x, nthreadc, nthreade);
d1199 2
d1203 7
a1209 2
		bu_log("bu_parallel(): %d threads created.  %d threads exited.\n",
		       nthreadc, nthreade);
d1213 13
a1225 13
	/*
	 *  Ensure that all the threads are REALLY finished.
	 *  On some systems, if threads core dump, the rest of
	 *  the gang keeps going, so this can actually happen (sigh).
	 */
	if( bu_nthreads_finished != bu_nthreads_started )  {
		bu_log("*** ERROR bu_parallel(%d): %d workers did not finish!\n\n",
			ncpu, ncpu - bu_nthreads_finished);
	}
	if( bu_nthreads_started != ncpu )  {
		bu_log("bu_parallel() NOTICE:  only %d workers started, expected %d\n",
			bu_nthreads_started, ncpu );
	}
d1227 2
a1228 2
	if( bu_debug & BU_DEBUG_PARALLEL )
		bu_log("bu_parallel(%d) complete, now serial\n", ncpu);
d1231 6
a1236 6
	/*
	 * At this point, all multi-tasking activity should have ceased,
	 * and we should be just a single UNIX process with our original
	 * PID and open file table (kernel struct u).  If not, then any
	 * output may be written into the wrong file.
	 */
d1238 1
a1238 1
	x = getpid();
d1240 1
a1240 1
	x = (int)GetCurrentProcessId();
d1242 4
a1245 4
	if (bu_pid_of_initiating_thread != x) {
	    bu_log("WARNING: bu_parallel():  PID of initiating thread changed from %d to %d, open file table may be botched!\n",
		   bu_pid_of_initiating_thread, x );
	}
d1247 1
a1247 1
	bu_pid_of_initiating_thread = 0;	/* No threads any more */
d1250 3
a1252 3
	bu_log("bu_parallel( x%lx, %d., x%lx ):  Not compiled for PARALLEL machine, running single-threaded\n", (long)func, ncpu, (long)arg );
	/* do the work anyways */
	(*func)(0,arg);
d1255 1
a1255 11
	return;
}


#if defined(sgi) && !defined(mips)
/* Horrible bug in 3.3.1 and 3.4 and 3.5 -- hypot ruins stack! */
long float
hypot(a,b)
double a,b;
{
	return(sqrt(a*a+b*b));
a1256 1
#endif /* sgi */
@


14.29
log
@restructure bu_nice_set() so we don't get an error (seen at least under cygwin/mingw) about 'SysV error:  wanted nice 10! check bias=0' .. getting rid of the obsoleted sysv code that used nice() to try to set a value.
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.28 2007/03/09 19:04:34 erikgreenwald Exp $ (ARL)";
d787 1
a787 1
	int	x;
d823 1
d825 3
d1240 8
a1247 3
	if( bu_pid_of_initiating_thread != (x=getpid()) )  {
		bu_log("WARNING: bu_parallel():  PID of initiating thread changed from %d to %d, open file table may be botched!\n",
			bu_pid_of_initiating_thread, x );
d1251 1
d1261 1
@


14.28
log
@malloc.h was superceded by stdlib.h no later than c89, so try stdlib.h first
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.27 2007/02/20 08:19:48 brlcad Exp $ (ARL)";
d215 1
a215 7
#ifdef _WIN32
  if (bu_debug)
    bu_log("bu_nice_set() Priority NOT changed\n");

  return;

#else  /* not _WIN32 */
d218 3
a220 4
#  ifdef BSD
#    ifndef PRIO_PROCESS  /* necessary for linux */
#      define PRIO_PROCESS  0	/* From /usr/include/sys/resource.h */
#    endif
d225 3
a227 15
#  else  /* not BSD */
  int bias, chg;

  /* " nice adds the value of incr to the nice value of the process" */
  /* "The default nice value is 20" */
  /* "Upon completion, nice returns the new nice value minus 20" */
  bias = 0;
  opri = nice(0) - bias;
  chg = newnice - opri;
  (void)nice(chg);
  npri = nice(0) - bias;
  if( npri != newnice )  bu_log("bu_nice_set() SysV error:  wanted nice %d! check bias=%d\n", newnice, bias );
#  endif  /* BSD */

  if( bu_debug ) bu_log("bu_nice_set() Priority changed from %d to %d\n", opri, npri);
d229 5
@


14.27
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.26 2007/01/27 01:41:37 brlcad Exp $ (ARL)";
d47 7
a146 3
#ifdef HAVE_MALLOC_H
#  include <malloc.h>
#endif
@


14.26
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.25 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d470 1
a470 1
	    while (fgets (buf, 80, fp) != NULL) {
@


14.25
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d30 1
a30 1
 *	
d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.24 2007/01/21 04:45:42 brlcad Exp $ (ARL)";
a307 1

d623 1
a623 1
		    	return 1;		/* realtime */
d905 2
a906 2
        #pragma loop cncall
        for( x=0; x<ncpu; x++) {
d908 1
a908 1
        }
@


14.24
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.23 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.23
log
@update copyright to 2007
@
text
@d21 2
a22 4

/** \addtogroup thread */
/*@@{*/

d25 1
a25 1
 * @@brief routines for parallel processing
d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.22 2006/09/03 15:14:07 lbutler Exp $ (ARL)";
d1273 1
a1273 1
/*@@}*/
@


14.22
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d42 1
a42 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.21 2006/08/31 23:16:38 lbutler Exp $ (ARL)";
@


14.21
log
@Doxygen comments
@
text
@d26 3
d42 1
a42 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.20 2006/08/01 14:48:18 brlcad Exp $ (ARL)";
@


14.20
log
@run the provided function single-threaded even if bu_parallel() is called on a system that doesn't have PARALLEL support compiled in
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d29 2
a30 2
 *  Author -
 *	Michael John Muuss
d32 1
a32 1
 *  Source -
d34 1
a34 1
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
a36 1
/*@@}*/
d39 1
a39 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.19 2006/07/29 21:49:18 lbutler Exp $ (ARL)";
d201 1
a201 1
/*
d248 1
a248 1
/*
d272 1
a272 1
/*
d309 1
a309 1
/*
d520 1
a520 1
/*
d549 1
a549 1
/*
d596 1
a596 1
/*
d646 1
a646 1
/*
d662 1
a662 1
/*
d693 1
a693 1
/*
d745 1
a745 1
/*
d766 1
a766 1
/*
d1272 2
@


14.19
log
@changes to support Intel Mac parallel code
@
text
@d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.18 2006/07/10 19:06:22 brlcad Exp $ (ARL)";
d1255 3
a1257 2
	bu_log("bu_parallel( x%lx, %d., x%lx ):  Not compiled for PARALLEL machine\n",
		(long)func, ncpu, (long)arg );
d1260 1
a1260 1

@


14.18
log
@refactor away the old BSD block defines among other simple cleanup
@
text
@d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.17 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d82 1
a82 1
#ifdef __ppc__
@


14.17
log
@update copyright to 2006
@
text
@d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.16 2005/11/12 02:50:33 brlcad Exp $ (ARL)";
d90 1
a90 7
#  ifdef BSD
#    define __BSDbackup BSD
#    undef BSD
#    include <sys/param.h>
#    undef BSD
#    define BSD __BSDbackup
#  endif
@


14.16
log
@move the bu_param for irix 64 outside the block so it gets defined, also fix a typo in a ppc section where sysctl return value wasn't getting checked correctly
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.15 2005/10/30 21:37:29 brlcad Exp $ (ARL)";
@


14.15
log
@include sched.h if it's available instead of sys/sched.h (aix fix)
@
text
@d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.14 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d160 3
a163 1
#  endif
d440 1
a440 1
	  if (sysctl(mib, 2, &maxproc, &len, NULL, NULL == -1)) {
@


14.14
log
@trailing ws
@
text
@d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.13 2005/09/22 12:18:19 brlcad Exp $ (ARL)";
d155 5
a159 2
#ifdef HAVE_SYS_SCHED_H
#  include <sys/sched.h>
d161 1
@


14.13
log
@Daniel Eischen on the FreeBSD project suggested using SIGINFO instead of calling the the private _thread_dump_info() function.  _thread_dump_info is/was provided by the bsd c_r library which is not used in certain 5.* versions of bsd (e.g. 5.4 on amd64) when using the -pthread option.  since _thread_dump_info is called when a SIGINFO is raised, it should be equivalent.  probably drops support for older bsd systems that predate sysinfo, but they'll probably require more work regardless
@
text
@d31 1
a31 1
 *  
d35 1
a35 1
 *  
d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.12 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
d215 1
a215 1
  
d228 1
a228 1
  
d355 1
a355 1
	 * The sysmp(MP_NPROCS) call returns the number of physically 
d455 2
a456 2
	   * Ultra-kludgey way to determine the number of cpus in a 
	   * linux box--count the number of processor entries in 
d465 1
a465 1
	
d467 1
a467 1
	
d469 1
a469 1
	    ncpu = 1; 
d477 2
a478 2
	    fclose (fp);	
	  
d671 1
a671 1
	
d682 1
a682 1
  
d971 1
a971 1
		
d979 1
a979 1
		/* 
d1158 1
a1158 1
	for (x = 0; x < ncpu; x++)  { 
@


14.12
log
@Doxygen changes
@
text
@d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.11 2005/06/21 07:10:12 brlcad Exp $ (ARL)";
d50 3
a79 1
#  include <signal.h>
a89 1
#  include <signal.h>
d1187 3
a1189 3
#    if defined(__FreeBSD__)
		/* Is this FreeBSD-only? */
		_thread_dump_info();
@


14.12.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d31 1
a31 1
 *
d35 1
a35 1
 *
d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header$ (ARL)";
a49 3
#ifdef HAVE_SIGNAL_H
#  include <signal.h>
#endif
d77 1
d88 1
d154 2
a155 8
#ifdef HAVE_SCHED_H
#  include <sched.h>
#else
#  ifdef HAVE_SYS_SCHED_H
#    include <sys/sched.h>
#  endif
#endif
#if defined(IRIX64) && IRIX64 >= 64
d214 1
a214 1

d227 1
a227 1

d354 1
a354 1
	 * The sysmp(MP_NPROCS) call returns the number of physically
d433 1
a433 1
	  if (sysctl(mib, 2, &maxproc, &len, NULL, 0) == -1) {
d454 2
a455 2
	   * Ultra-kludgey way to determine the number of cpus in a
	   * linux box--count the number of processor entries in
d464 1
a464 1

d466 1
a466 1

d468 1
a468 1
	    ncpu = 1;
d476 2
a477 2
	    fclose (fp);

d670 1
a670 1

d681 1
a681 1

d970 1
a970 1

d978 1
a978 1
		/*
d1157 1
a1157 1
	for (x = 0; x < ncpu; x++)  {
d1186 3
a1188 3
#    if defined(HAVE_RAISE) && defined(SIGINFO)
		/* may be BSD-only (calls _thread_dump_info()) */
		raise(SIGINFO);
@


14.11
log
@make sure IRIX and IRIX64 are defined before checking their value
@
text
@d21 4
a25 1
 *
d37 2
d40 1
a40 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.10 2005/06/15 04:34:52 brlcad Exp $ (ARL)";
@


14.10
log
@protect the sys/wait.h headers with HAVE_SYS_WAIT_H since not all systems (e.g. mingw) have it.
@
text
@d35 1
a35 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.9 2005/05/28 02:14:50 brlcad Exp $ (ARL)";
d933 1
a933 1
#    if IRIX <= 4
d948 1
a948 1
#			if IRIX64
@


14.9
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d35 1
a35 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.8 2005/03/24 07:07:28 brlcad Exp $ (ARL)";
d57 3
a59 1
#  include <sys/wait.h>
d68 3
a70 1
#  include <sys/wait.h>
d79 3
a81 1
#  include <sys/wait.h>
@


14.8
log
@oops, restore killed comment
@
text
@d35 1
a35 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.7 2005/03/23 06:15:57 brlcad Exp $ (ARL)";
d200 1
a200 1
#ifdef WIN32
d206 1
a206 1
#else  /* not WIN32 */
d233 1
a233 1
#endif  /* WIN32 */
d523 1
a523 1
#ifndef WIN32
d549 3
a551 3
#ifndef WIN32
#define PUBLIC_CPUS1	"/var/tmp/public_cpus"
#define PUBLIC_CPUS2	"/usr/tmp/public_cpus"
d557 1
a557 1
#ifndef WIN32
@


14.7
log
@ugh, so much to do in this file.. -- use some of the new header and function checks
@
text
@d35 1
a35 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.6 2005/01/30 20:30:46 brlcad Exp $ (ARL)";
d723 1
a723 1
	 *  On an SGI
@


14.6
log
@update copyright to 2005
@
text
@d35 1
a35 1
static const char RCSparallel[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parallel.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
d40 2
d120 1
d124 3
d128 2
d131 2
d134 2
a135 3
/* ulocks.h #include's <limits.h> and <malloc.h> */
/* ulocks.h #include's <task.h> for getpid stuff */
/* task.h #include's <sys/prctl.h> */
d137 1
a137 1
/* <malloc.h> #include's <stddef.h> */
d139 1
d141 4
a144 2
#  if IRIX64 >= 64
#    include <sys/sched.h>
d146 1
a146 5
#  endif

#endif /* SGI_4D */

/* XXX Probably need to set _SGI_MP_SOURCE in machine.h */
d347 3
a349 1
#  if 0
a350 2
#  else
	ncpu = sysmp(MP_NPROCS);
d723 1
a723 1
	 *  On an SGI, a process/thread created with the "sproc" syscall has
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d35 1
a35 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parallel.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a32 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d35 1
a35 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parallel.c,v 14.3 2004/12/21 05:45:21 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d37 1
a37 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parallel.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d37 1
a37 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parallel.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			P A R A L L E L . C
d37 1
a37 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parallel.c,v 1.5 2004/09/15 05:11:15 morrison Exp $ (ARL)";
@


1.5
log
@use unsigned long ints and long hex to deal with potentially 64-bit addresses (from ia64); also clean up bu_nice_set #mess; also indentify header inclusions
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parallel.c,v 1.4 2004/08/03 20:42:29 morrison Exp $ (ARL)";
d1234 10
@


1.4
log
@apply Bob's provided patches from 20040630.  this includes itcl namespace scoping, windows DLL exporting, and wdb arb edit support
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parallel.c,v 1.2 2004/06/08 19:28:33 morrison Exp $ (ARL)";
a22 2


d27 1
a27 1
#include <string.h>
d29 1
a29 1
#include <strings.h>
d35 6
a40 6
#include <sys/time.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/sysinfo.h>
d44 6
a49 6
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <signal.h>
d53 14
a66 14
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <signal.h>
#ifdef BSD
#  define __BSDbackup BSD
#  undef BSD
#  include <sys/param.h>
#  undef BSD
#  define BSD __BSDbackup
#endif
#include <sys/sysctl.h>
d70 3
a72 3
#include <sys/types.h>
#include <sys/sysconfig.h>
#include <sys/var.h>
d76 6
a81 6
# include <sys/category.h>
# include <sys/resource.h>
# include <sys/types.h>
# ifdef CRAY1
#  include <sys/machd.h>	/* For HZ */
# endif
d85 2
a86 2
#undef MAXINT
# include <sys/param.h>
d90 3
a92 3
# include <synch.h>
# undef stderr
# define stderr stdout
d97 1
a97 1
# include <cncall.h>
d101 6
a106 6
# define SGI_4D	1
# define _SGI_SOURCE	1	/* IRIX 5.0.1 needs this to def M_BLKSZ */
# define _BSD_TYPES	1	/* IRIX 5.0.1 botch in sys/prctl.h */
# include <sys/types.h>
# include <ulocks.h>
# include <sys/sysmp.h> /* for sysmp() */
d110 1
a110 1
# include <malloc.h>
d113 3
a115 3
#include <sys/wait.h>
#if IRIX64 >= 64
# include <sys/sched.h>
d117 1
a117 1
#endif
d124 1
a124 1
#	include <thread.h>
d128 2
a129 2
#	include <parallel.h>
#	include <sys/sysadmin.h>
d136 4
a139 4
#	include <sys/unistd.h>
#	include <thread.h>
#	include <synch.h>
#define rt_thread_t	thread_t
d146 1
a146 1
#	include	<unistd.h>
d149 1
a149 1
#	include <sys/unistd.h>
d153 2
a154 2
#	include <pthread.h>
#	define rt_thread_t	pthread_t
a171 1
#ifndef WIN32
d175 8
a182 1
	int opri, npri;
d184 23
a206 9
#ifdef BSD
#ifndef PRIO_PROCESS	/* necessary for linux */
#define	PRIO_PROCESS	0	/* From /usr/include/sys/resource.h */
#endif
	opri = getpriority( PRIO_PROCESS, 0 );
	setpriority( PRIO_PROCESS, 0, newnice );
	npri = getpriority( PRIO_PROCESS, 0 );
#else
	int bias, chg;
d208 1
a208 11
	/* " nice adds the value of incr to the nice value of the process" */
	/* "The default nice value is 20" */
	/* "Upon completion, nice returns the new nice value minus 20" */
	bias = 0;
	opri = nice(0) - bias;
	chg = newnice - opri;
	(void)nice(chg);
	npri = nice(0) - bias;
	if( npri != newnice )  bu_log("bu_nice_set() SysV error:  wanted nice %d! check bias=%d\n", newnice, bias );
#endif
	if( bu_debug ) bu_log("bu_nice_set() Priority changed from %d to %d\n", opri, npri);
a209 6
#else
void
bu_nice_set(int newnice)
{
    if (bu_debug)
	bu_log("bu_nice_set() Priority NOT changed\n");
a210 3
    return;
}
#endif
d1128 2
a1129 2
			fprintf(stderr, "ERROR parallel.c/bu_parallel(): thr_create(0x0, 0x0, 0x%x, 0x0, 0, 0x%x) failed on processor %d\n",
				(unsigned int)bu_parallel_interface, (unsigned int)&thread, x);
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d174 1
d202 10
d454 5
a458 3
	  GetSystemInfo(&sysinfo);
	  ncpu = (int)sysinfo.dwNumberOfProcessors;
	  goto DONE_NCPU;
d498 2
a500 1
	double	load = -1.0;
d510 1
d525 1
d528 1
d532 3
a535 4
	int	avail_cpus;
	int	public_cpus = 1;

	avail_cpus = bu_avail_cpus();
d557 1
@


1.2
log
@use HAVE_UNISTD_H and HAVE_PTHREAD_H instead of generic HAS_POSIX_THREADS
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header$ (ARL)";
d21 1
a21 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d18 1
a18 1
static const char RCSparallel[] = "@@(#)$Header: /cvs/brlcad/libbu/parallel.c,v 1.46 2004/05/10 15:30:44 erikg Exp $ (ARL)";
a35 1
#include "externs.h"
d149 1
a149 2
#ifdef HAS_POSIX_THREADS
#ifdef __sp3__
d152 1
d154 1
d156 1
d158 2
a159 2
#define rt_thread_t	pthread_t
#endif	/* HAS_POSIX_THREADS */
d454 2
a455 2
#if defined(HAS_POSIX_THREADS)
	/* if they have threading and we could not detect properly, use two */
d459 1
a459 1
#endif /* HAS_POSIX_THREADS */
d664 1
a664 1
#ifdef HAS_POSIX_THREADS
a757 2

	bzero(worker_pid_tbl, sizeof(worker_pid_tbl) );
d766 1
a766 1
#  if (defined(SUNOS) && SUNOS >= 52) || defined(HAS_POSIX_THREADS)
d774 4
d1099 1
a1099 1
#  if defined(HAS_POSIX_THREADS)
@

