head	14.17;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.5
	rel-7-10-2:14.15
	rel-7-10-0:14.15
	rel-7-8-4:14.11
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.7
	bobWinPort-20051223-freeze:14.6
	postmerge-20051223-bobWinPort:14.7
	premerge-20051223-bobWinPort:14.7
	rel-7-6-6:14.7
	rel-7-6-4:14.7
	rel-7-6-2:14.6
	rel-7-6-branch:14.6.0.4
	rel-7-6-0:14.6
	rel-7-4-2:14.5
	rel-7-4-branch:14.5.0.2
	bobWinPort:14.6.0.2
	rel-7-4-0:14.5
	rel-7-2-6:14.5
	rel-7-2-4:14.5
	rel-7-2-2:14.5
	rel-7-2-0:14.5
	rel-7-0-4:14.4
	rel-7-0-2:14.4
	rel-7-0-1:14.4
	opensource-post:14.4
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.17
date	2007.12.16.18.53.48;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.09.15.16.23.08;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.31.05.50.24;	author lbutler;	state Exp;
branches;
next	14.10;

14.10
date	2006.08.28.18.33.03;	author johnranderson;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.22.21.23.15;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.6.4.1;
next	14.5;

14.5
date	2005.01.30.20.30.45;	author brlcad;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.15.04.55.20;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.15.04.42.01;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.32;	author morrison;	state Exp;
branches;
next	;

14.6.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.17
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                          H A S H . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup bu_hash */
/** @@{ */
/** @@file hash.c
 *
 * @@brief
 *	An implimentation of hash tables.
 */

#ifndef lint
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.16 2007/09/15 16:23:08 brlcad Exp $";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "machine.h"
#include "bu.h"


/**		B U _ H A S H
 * the hashing function
 */
unsigned long
bu_hash(unsigned char *str, int len)
{
	unsigned long hash = 5381;
	int i, c;

	c = *str;
	for( i=0 ; i<len ; i++ ) {
		c = *str;
		hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
		str++;
	}

	return hash;
}

/**			B U _ C R E A T E _ H A S H _ T B L
 *@@brief
 *	Create an empty hash table
 *	The input is the number of desired hash bins.
 *	This number will be rounded up to the nearest power of two.
 */
struct bu_hash_tbl *
bu_create_hash_tbl( unsigned long tbl_size )
{
	struct bu_hash_tbl *hsh_tbl;
	unsigned long power_of_two=64;
	int power=6;
	int max_power=(sizeof( unsigned long ) * 8) - 1;

	/* allocate the table structure (do not use bu_malloc() as this may be used for MEM_DEBUG) */
	hsh_tbl = (struct bu_hash_tbl *)malloc( sizeof( struct bu_hash_tbl ) );
	if( !hsh_tbl ) {
		fprintf( stderr, "Failed to allocate hash table\n" );
		return( (struct bu_hash_tbl *)NULL );
	}

	/* the number of bins in the hash table will be a power of two */
	while( power_of_two < tbl_size && power < max_power ) {
		power_of_two = power_of_two << 1;
		power++;
	}

	if( power == max_power ) {
		int i;

		hsh_tbl->mask = 1;
		for( i=1 ; i<max_power ; i++ ) {
			hsh_tbl->mask = (hsh_tbl->mask << 1) + 1;
		}
		hsh_tbl->num_lists = hsh_tbl->mask + 1;
	} else {
		hsh_tbl->num_lists = power_of_two;
		hsh_tbl->mask = power_of_two - 1;
	}

	/* allocate the bins (do not use bu_malloc() as this may be used for MEM_DEBUG) */
	hsh_tbl->lists = (struct bu_hash_entry **)calloc( hsh_tbl->num_lists, sizeof( struct bu_hash_entry *) );

	hsh_tbl->num_entries = 0;
	hsh_tbl->magic = BU_HASH_TBL_MAGIC;

	return( hsh_tbl );
}

/**			B U _ F I N D _ H A S H _ E N T R Y
 *
 * @@brief
 *	Find the hash table entry corresponding to the provided key
 *
 *
 * @@param[in] hsh_tbl - The hash table to look in
 * @@param[in] key - the key to look for
 * @@param[in] key_len - the length of the key in bytes
 *
 * Output:
 * @@param[out] prev - the previous hash table entry (non-null for entries that not the first in hash bin)
 * @@param[out] index - the index of the hash bin for this key
 *
 * @@return
 *	the hash table entry corresponding to the provided key, or NULL if not found
 */
struct bu_hash_entry *
bu_find_hash_entry( struct bu_hash_tbl *hsh_tbl, unsigned char *key, int key_len, struct bu_hash_entry **prev, unsigned long *index )
{
	struct bu_hash_entry *hsh_entry=NULL;
	int found=0;

	BU_CK_HASH_TBL( hsh_tbl );

	/* calculate the index into the bin array */
	*index = bu_hash( key, key_len ) & hsh_tbl->mask;
	if( *index >= hsh_tbl->num_lists ) {
		fprintf( stderr, "hash function returned too large value (%ld), only have %ld lists\n",
			 *index, hsh_tbl->num_lists );
		*prev = NULL;
		return( (struct bu_hash_entry *)NULL );
	}

	/* look for the provided key in the list of entries in this bin */
	*prev = NULL;
	if( hsh_tbl->lists[*index] ) {
		*prev = NULL;
		hsh_entry = hsh_tbl->lists[*index];
		while( hsh_entry ) {
			unsigned char *c1, *c2;
			int i;

			/* compare key lengths first for performance */
			if( hsh_entry->key_len != key_len ) {
				*prev = hsh_entry;
				hsh_entry = hsh_entry->next;
				continue;
			}

			/* key lengths are the same, now compare the actual keys */
			found = 1;
			c1 = key;
			c2 = hsh_entry->key;
			for( i=0 ; i<key_len ; i++ ) {
				if( *c1 != *c2 ) {
					found = 0;
					break;
				}
				c1++;
				c2++;
			}

			/* if we have a match, get out of this loop */
			if( found ) break;

			/* step to next entry in this bin */
			*prev = hsh_entry;
			hsh_entry = hsh_entry->next;
		}
	}

	if( found ) {
		/* return the found entry */
		return( hsh_entry );
	} else {
		/* did not find the entry, return NULL */
		return( (struct bu_hash_entry *)NULL );
	}
}


/**			B U _ S E T _ H A S H _ V A L U E
 *@@brief
 *	Set the value for a hash table entry
 *
 *	Note that this is just a pointer copy, the hash table does not maintain its own copy
 *	of this value.
 */
void
bu_set_hash_value( struct bu_hash_entry *hsh_entry, unsigned char *value )
{
	BU_CK_HASH_ENTRY( hsh_entry );

	/* just copy a pointer */
	hsh_entry->value = value;
}

/**			B U _ G E T _ H A S H _ V A L U E
 *
 *	get the value pointer stored for the specified hash table entry
 */
unsigned char *
bu_get_hash_value( struct bu_hash_entry *hsh_entry )
{
	BU_CK_HASH_ENTRY( hsh_entry );

	return( hsh_entry->value );
}

/**			B U _ G E T _ H A S H _ K E Y
 *
 *	get the key pointer stored for the specified hash table entry
 */
unsigned char *
bu_get_hash_key( struct bu_hash_entry *hsh_entry )
{
	BU_CK_HASH_ENTRY( hsh_entry );

	return( hsh_entry->key );
}


/**			B U _ H A S H _ A D D _ E N T R Y
 *
 *	Add an new entry to a hash table
 *
 *
 * @@param[in] hsh_tbl - the hash table to accept thye new entry
 * @@param[in] key - the key (any byte string)
 * @@param[in] key_len - the number of bytes in the key
 *
 * @@param[out] new - a flag, non-zero indicates that a new entry was created.
 *	              zero indicates that an entry already exists with the specified key and key length
 *
 * @@return
 *	a hash table entry. If "new" is non-zero, a new, empty entry is returned.
 *	if "new" is zero, the returned entry is the one matching the specified key and key_len
 */
struct bu_hash_entry *
bu_hash_add_entry( struct bu_hash_tbl *hsh_tbl, unsigned char *key, int key_len, int *new )
{
	struct bu_hash_entry *hsh_entry, *prev;
	unsigned long index;

	BU_CK_HASH_TBL( hsh_tbl );

	/* do a find for three reasons
	 * does this key already exist in the table?
	 * get the hash bin index for this key
	 * find the previous entry to link the new one to
	 */
	hsh_entry = bu_find_hash_entry( hsh_tbl, key, key_len, &prev, &index );

	if( hsh_entry ) {
		/* this key is already in the table, return the entry, with flag set to 0 */
		*new = 0;
		return( hsh_entry );
	}

	if( prev ) {
		/* already have an entry in this bin, just link to it */
		prev->next = (struct bu_hash_entry *)calloc( 1, sizeof( struct bu_hash_entry ) );
		hsh_entry = prev->next;
	} else {
		/* first entry in this bin */
		hsh_entry = (struct bu_hash_entry *)calloc( 1, sizeof( struct bu_hash_entry ) );
		hsh_tbl->lists[index] = hsh_entry;
	}

	/* fill in the structure */
	hsh_entry->next = NULL;
	hsh_entry->value = NULL;
	hsh_entry->key_len = key_len;
	hsh_entry->magic = BU_HASH_ENTRY_MAGIC;

	/* make a copy of the key */
	hsh_entry->key = (unsigned char *)malloc( key_len );
	memcpy(hsh_entry->key, key, key_len);

	/* set "new" flag, increment count of entries, and return new entry */
	*new = 1;
	hsh_tbl->num_entries++;
	return( hsh_entry );
}

/**			B U _ H A S H _ T B L _ P R
 *@@brief
 *	Print the specified hash table to stderr.
 *	(Note that the keys and values are printed as pointers)
 */
void
bu_hash_tbl_pr( struct bu_hash_tbl *hsh_tbl, char *str )
{
	unsigned long index;
	struct bu_hash_entry *hsh_entry;

	BU_CK_HASH_TBL( hsh_tbl );

	fprintf( stderr, "%s\n", str );
	fprintf( stderr, "bu_hash_table (%ld entries):\n", hsh_tbl->num_entries );

	/* visit all the entries in this table */
	for( index=0 ; index<hsh_tbl->num_lists ; index++ ) {
		hsh_entry = hsh_tbl->lists[index];
		while( hsh_entry ) {
			BU_CK_HASH_ENTRY( hsh_entry );
			fprintf( stderr, "\tindex=%ld, key=x%lx, value=x%lx\n", index, (unsigned long int)hsh_entry->key, (unsigned long int)hsh_entry->value );
			hsh_entry = hsh_entry->next;
		}
	}
}

/**			B U _ H A S H _ T B L _ F R E E
 *@@brief
 *	Free all the memory associated with the specified hash table.
 *	Note that the keys are freed (they are copies), but the "values" are not freed.
 *	(The values are merely pointers)
 */
void
bu_hash_tbl_free( struct bu_hash_tbl *hsh_tbl )
{
	unsigned long index;
	struct bu_hash_entry *hsh_entry, *tmp;

	BU_CK_HASH_TBL( hsh_tbl );

	/* loop through all the bins in this hash table */
	for( index=0 ; index<hsh_tbl->num_lists ; index++ ) {
		/* traverse all the entries in the list for this bin */
		hsh_entry = hsh_tbl->lists[index];
		while( hsh_entry ) {
			BU_CK_HASH_ENTRY( hsh_entry );
			tmp = hsh_entry->next;

			/* free the copy of the key, and this entry */
			free( hsh_entry->key );
			free( hsh_entry );

			/* step to next entry in libnked list */
			hsh_entry = tmp;
		}
	}

	/* free the array of bins */
	free( hsh_tbl->lists );

	/* free the actual hash table structure */
	free( hsh_tbl );
}


/**			B U _ H A S H _ T B L _ F I R S T
 *@@brief
 *	get the "first" entry in a hash table
 *
 *
 * @@param[in] hsh_tbl - the hash table of interest
 * @@param[in] rec - an empty "bu_hash_record" structure for use by this routine and "bu_hash_tbl_next"
 *
 * @@return
 *	the first non-null entry in the hash table, or NULL if there are no entries
 *	(Note that the order of enties is not likely to have any significance)
 */
struct bu_hash_entry *
bu_hash_tbl_first( struct bu_hash_tbl *hsh_tbl, struct bu_hash_record *rec )
{
	BU_CK_HASH_TBL( hsh_tbl );

	/* initialize the record structure */
	rec->magic = BU_HASH_RECORD_MAGIC;
	rec->tbl = hsh_tbl;
	rec->index = -1;
	rec->hsh_entry = (struct bu_hash_entry *)NULL;

	if( hsh_tbl->num_entries == 0 ) {
		/* this table is empty */
		return( (struct bu_hash_entry *)NULL );
	}

	/* loop through all the bins in this hash table, looking for a non-null entry */
	for( rec->index=0 ; rec->index < hsh_tbl->num_lists ; rec->index++ ) {
		rec->hsh_entry = hsh_tbl->lists[rec->index];
		if( rec->hsh_entry ) {
			return( rec->hsh_entry );
		}
	}

	/* no entry found, return NULL */
	return( (struct bu_hash_entry *)NULL );
}

/**			B U _ H A S H _ T B L _ N E X T
 *
 *	get the "next" entry in a hash table
 *
 * input:
 *	rec - the "bu_hash_record" structure that was passed to "bu_hash_tbl_first"
 *
 * return:
 *	the "next" non-null hash entry in this hash table
 */
struct bu_hash_entry *
bu_hash_tbl_next( struct bu_hash_record *rec )
{
	struct bu_hash_tbl *hsh_tbl;

	BU_CK_HASH_RECORD( rec );
	hsh_tbl = rec->tbl;
	BU_CK_HASH_TBL( hsh_tbl );

	/* if the entry in the record structure has a non-null "next",
	 * return it, and update the record structure
	 */
	if( rec->hsh_entry ) {
		rec->hsh_entry = rec->hsh_entry->next;
		if( rec->hsh_entry ) {
			return( rec->hsh_entry );
		}
	}

	/* must move to a new bin to find another entry */
	for( rec->index++ ; rec->index < hsh_tbl->num_lists ; rec->index++ ) {
		rec->hsh_entry = hsh_tbl->lists[rec->index];
		if( rec->hsh_entry ) {
			return( rec->hsh_entry );
		}
	}

	/* no more entries, return NULL */
	return( (struct bu_hash_entry *)NULL );
}
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d29 1
a29 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.15 2007/01/27 01:41:36 brlcad Exp $";
d289 1
a289 1
	memcpy( hsh_entry->key, key, key_len );
@


14.15
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d29 1
a29 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.14 2007/01/23 01:13:34 brlcad Exp $";
d37 2
a38 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.14
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d29 1
a29 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.13 2007/01/21 04:45:41 brlcad Exp $";
d52 2
a53 2
        unsigned long hash = 5381;
        int i, c;
d62 1
a62 1
        return hash;
d119 1
a119 1
 * 
d241 1
a241 1
 * 
@


14.13
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d29 1
a29 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.12 2007/01/20 14:36:51 brlcad Exp $";
@


14.12
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup bu_hash */
/*@@{*/
d30 1
a30 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.11 2006/08/31 05:50:24 lbutler Exp $";
d447 1
a447 1
/*@@}*/
@


14.11
log
@Mostly doxygen formatting.
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d31 1
a31 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.10 2006/08/28 18:33:03 johnranderson Exp $";
@


14.10
log
@Added bu_get_hash_key()
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d25 2
a28 1
/*@@}*/
d31 1
a31 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.9 2006/01/22 21:23:15 brlcad Exp $";
d48 1
a48 1
/*		B U _ H A S H
d67 2
a68 2
/*			B U _ C R E A T E _ H A S H _ T B L
 *
d116 1
a116 1
/*			B U _ F I N D _ H A S H _ E N T R Y
d118 1
d121 4
a124 4
 * Input:
 *	hsh_tbl - The hash table to look in
 *	key - the key to look for
 *	key_len - the length of the key in bytes
d127 2
a128 2
 *	prev - the previous hash table entry (non-null for entries that not the first in hash bin)
 *	index - the index of the hash bin for this key
d130 1
a130 1
 * Return:
d198 3
a200 1
/*			B U _ S E T _ H A S H _ V A L U E
a201 1
 *	Set the value for a hash table entry
d214 1
a214 1
/*			B U _ G E T _ H A S H _ V A L U E
d226 1
a226 1
/*			B U _ G E T _ H A S H _ K E Y
d239 1
a239 1
/*			B U _ H A S H _ A D D _ E N T R Y
d243 4
a246 4
 * input:
 *	hsh_tbl - the hash table to accept thye new entry
 *	key - the key (any byte string)
 *	key_len - the number of bytes in the key
d248 1
a248 2
 * output:
 *	new - a flag, non-zero indicates that a new entry was created.
d251 1
a251 1
 * return:
d302 3
a304 3
/*			B U _ H A S H _ T B L _ P R
 *
 *	Print the specified hash table to stderr
d329 2
a330 2
/*			B U _ H A S H _ T B L _ F R E E
 *
d368 3
a370 1
/*			B U _ H A S H _ T B L _ F I R S T
a371 1
 *	get the "first" entry in a hash table
d373 2
a374 3
 * input:
 *	hsh_tbl - the hash table of interest
 *	rec - an empty "bu_hash_record" structure for use by this routine and "bu_hash_tbl_next"
d376 1
a376 1
 * return:
d408 1
a408 1
/*			B U _ H A S H _ T B L _ N E X T
d448 1
a448 1

@


14.9
log
@include stdlib.h for malloc (cannot use bu_malloc() as the hash table may be used for MEM_DEBUG)
@
text
@d30 1
a30 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.8 2006/01/18 06:46:16 brlcad Exp $";
d223 13
@


14.8
log
@update copyright to 2006
@
text
@d30 1
a30 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.7 2005/10/23 04:44:32 brlcad Exp $";
d35 1
@


14.7
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d30 1
a30 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.6 2005/08/12 22:29:23 lbutler Exp $";
@


14.6
log
@Doxygen changes
@
text
@d30 1
a30 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.5 2005/01/30 20:30:45 brlcad Exp $";
d377 1
a377 1
		return( (struct bu_hash_entry *)NULL );	
@


14.6.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d30 1
a30 1
static const char libbu_hash_RCSid[] = "@@(#) $Header$";
d377 1
a377 1
		return( (struct bu_hash_entry *)NULL );
@


14.5
log
@update copyright to 2005
@
text
@d21 3
d25 1
a25 2
 *
 *	An implimentation of hash tables
d27 1
d30 1
a30 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/hash.c,v 14.4 2004/12/21 06:18:43 morrison Exp $";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d27 1
a27 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/hash.c,v 14.3 2004/12/21 05:45:20 morrison Exp $";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d27 1
a27 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/hash.c,v 14.2 2004/12/21 03:49:00 morrison Exp $";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d27 1
a27 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/hash.c,v 14.1 2004/11/16 19:42:14 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			H A S H . C
d27 1
a27 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/hash.c,v 1.5 2004/09/15 04:55:20 morrison Exp $";
@


1.5
log
@long hexadecimal will work better (and correctly) for potentially 64-bit addresses (form ia64 quelling)
@
text
@d8 1
a8 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/hash.c,v 1.4 2004/09/15 04:42:01 morrison Exp $";
d410 10
@


1.4
log
@quell cast warning for ia64
@
text
@d8 1
a8 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/hash.c,v 1.3 2004/09/03 23:30:57 morrison Exp $";
d285 1
a285 1
			fprintf( stderr, "\tindex=%ld, key=x%x, value=x%x\n", index, hsh_entry->key, hsh_entry->value );
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@a6 1

d8 1
a8 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/hash.c,v 1.2 2004/08/02 23:01:48 morrison Exp $";
a12 2


d16 1
a16 1
#include <string.h>
d18 1
a18 1
#include <strings.h>
d23 1
d285 1
a285 1
			fprintf( stderr, "\tindex=%ld, key=x%x, value=x%x\n", index, (unsigned int)hsh_entry->key, (unsigned int)hsh_entry->value );
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d9 1
a9 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/hash.c,v 1.1 2004/05/20 15:19:32 morrison Exp $";
d18 1
a18 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d9 1
a9 1
static const char libbu_hash_RCSid[] = "@@(#) $Header: /cvs/brlcad/libbu/hash.c,v 11.2 2004/05/10 15:30:44 erikg Exp $";
d12 1
a12 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

