head	14.18;
access;
symbols
	rel-7-10-4:14.17
	STABLE:14.17.0.2
	stable-branch:14.6
	rel-7-10-2:14.17
	rel-7-10-0:14.16
	rel-7-8-4:14.11
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.9
	bobWinPort-20051223-freeze:14.8
	postmerge-20051223-bobWinPort:14.9
	premerge-20051223-bobWinPort:14.9
	rel-7-6-6:14.9
	rel-7-6-4:14.9
	rel-7-6-2:14.8
	rel-7-6-branch:14.8.0.4
	rel-7-6-0:14.8
	rel-7-4-2:14.7
	rel-7-4-branch:14.7.0.2
	bobWinPort:14.8.0.2
	rel-7-4-0:14.7
	rel-7-2-6:14.7
	rel-7-2-4:14.7
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.18
date	2007.09.15.16.23.08;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.18.23.35.00;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.33;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.17.19.36.49;	author erikgreenwald;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.31.05.50.24;	author lbutler;	state Exp;
branches;
next	14.10;

14.10
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.8.4.1;
next	14.7;

14.7
date	2005.05.11.02.33.34;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.45;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.31;	author morrison;	state Exp;
branches;
next	;

14.8.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.18
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                           A V S . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup avs */
/** @@{ */
/** @@file avs.c
 *
 *  @@brief
 *  Routines to manage attribute/value sets.
 *
 *  @@Author Michael John Muuss
 *
 *  @@par Source -
 *	The U. S. Army Research Laboratory			@@n
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.17 2007/05/18 23:35:00 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdio.h>
#include <string.h>

#include "machine.h"
#include "bu.h"

#define AVS_ALLOCATION_INCREMENT 32

/**
 *	B U _ A V S _ I N I T _ E M P T Y
 *
 *	initialize an empty avs
 */
void
bu_avs_init_empty( struct bu_attribute_value_set *avsp )
{
	avsp->magic = BU_AVS_MAGIC;
	avsp->count = 0;
	avsp->max = 0;
	avsp->avp = (struct bu_attribute_value_pair *)NULL;
	avsp->readonly_min = avsp->readonly_max = NULL;
}

/**
 *	B U _ A V S _ I N I T
 *
 *	initialize avs with storage for len entries
 */
void
bu_avs_init(struct bu_attribute_value_set *avsp, int len, const char *str)
{
	if (bu_debug & BU_DEBUG_AVS)
		bu_log("bu_avs_init(%8x, len=%d, %s)\n", avsp, len, str);

	avsp->magic = BU_AVS_MAGIC;
	if( len <= 0 )  len = AVS_ALLOCATION_INCREMENT + AVS_ALLOCATION_INCREMENT;
	avsp->count = 0;
	avsp->max = len;
	avsp->avp = (struct bu_attribute_value_pair *)bu_calloc(avsp->max,
		sizeof(struct bu_attribute_value_pair), str);
	avsp->readonly_min = avsp->readonly_max = NULL;
}

/**
 *	B U _ A V S _ N E W
 *
 *	Allocate storage for a new attribute/value set, with at least
 *	'len' slots pre-allocated.
 */
struct bu_attribute_value_set	*
bu_avs_new(int len, const char *str)
{
	struct bu_attribute_value_set	*avsp;

	BU_GETSTRUCT( avsp, bu_attribute_value_set );
	bu_avs_init( avsp, len, "bu_avs_new" );

	if (bu_debug & BU_DEBUG_AVS)
		bu_log("bu_avs_new(len=%d, %s) = x%x\n", len, str, avsp);

	return avsp;
}

/**
 *  B U _ A V S _ A D D
 *
 *  If the given attribute exists it will recieve the new value,
 *  othwise the set will be extended to have a new attribute/value pair.
 *
 *  Returns -
 *      0	some error occured
 *	1	existing attribute updated with new value
 *	2	set extended with new attribute/value pair
 */
int
bu_avs_add(struct bu_attribute_value_set *avsp, const char *name, const char *value)
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(avsp);

	if (!name) {
	    bu_log("WARNING: bu_avs_add() received a null attribute name\n");
	    return 0;
	}

	if (avsp->count) {
		for (BU_AVS_FOR(app, avsp)) {
			if (strcmp(app->name, name) != 0) continue;

			/* found a match, replace it fully */
			if (app->name && AVS_IS_FREEABLE(avsp, app->name))
				bu_free((genptr_t)app->name, "app->name");
			if (app->value && AVS_IS_FREEABLE(avsp, app->value))
				bu_free((genptr_t)app->value, "app->value");
			app->name = bu_strdup(name);
			if (value) {
				app->value = bu_strdup(value);
			} else {
				app->value = (char *)NULL;
			}
			return 1;
		}
	}

	if( avsp->count >= avsp->max )  {
		/* Allocate more space first */
		avsp->max += AVS_ALLOCATION_INCREMENT;
		if( avsp->avp ) {
			avsp->avp = (struct bu_attribute_value_pair *)bu_realloc(
			  avsp->avp,  avsp->max * sizeof(struct bu_attribute_value_pair),
				"attribute_value_pair.avp[] (add)" );
		} else {
			avsp->avp = (struct bu_attribute_value_pair *)bu_calloc(
				avsp->max, sizeof(struct bu_attribute_value_pair ),
			       "attribute_value_pair.avp[] (add)" );
		}
	}

	app = &avsp->avp[avsp->count++];
	app->name = bu_strdup(name);
	if( value ) {
		app->value = bu_strdup(value);
	} else {
		app->value = (char *)NULL;
	}
	return 2;
}

/**
 * B U _ A V S _ A D D _ V L S
 *
 * Add a bu_vls string as an attribute to a given attribute set.
 */
int
bu_avs_add_vls(struct bu_attribute_value_set *avsp, const char *name, const struct bu_vls *value_vls)
{
	BU_CK_AVS(avsp);
	BU_CK_VLS(value_vls);

	return bu_avs_add( avsp, name, bu_vls_addr(value_vls) );
}

/**
 *  B U _ A V S _ M E R G E
 *
 *  Take all the attributes from 'src' and merge them into 'dest' by
 *  replacing an attribute if it already exists.
 */
void
bu_avs_merge( struct bu_attribute_value_set *dest, const struct bu_attribute_value_set *src )
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(dest);
	BU_CK_AVS(src);

	if( src->count ) {
		for( BU_AVS_FOR( app, src ) )  {
			(void)bu_avs_add( dest, app->name, app->value );
		}
	}
}

/**
 * B U _ A V S _ G E T
 *
 * Get the value of a given attribute from an attribute set.
 */
const char *
bu_avs_get( const struct bu_attribute_value_set *avsp, const char *name )
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(avsp);

	if (avsp->count < 1)
	    return NULL;

	if (!name)
	    return NULL;

	for (BU_AVS_FOR(app, avsp)) {
	    if (strcmp( app->name, name ) != 0) {
		continue;
	    }
	    return app->value;
	}
	return NULL;
}

/**
 * B U _ A V S _ R E M O V E
 *
 * Remove the given attribute from an attribute set.
 *
 * @@Return
 *	-1	attribute not found in set
 * @@Return
 *	 0	OK
 */
int
bu_avs_remove(struct bu_attribute_value_set *avsp, const char *name)
{
	struct bu_attribute_value_pair *app, *epp;

	BU_CK_AVS(avsp);

	if (!name) {
	    return -1;
	}

	if( avsp->count ) {
		for( BU_AVS_FOR(app, avsp) )  {
			if( strcmp( app->name, name ) != 0 )  continue;
			if( app->name && AVS_IS_FREEABLE( avsp, app->name ) )
				bu_free( (genptr_t)app->name, "app->name" );
			app->name = NULL;	/* sanity */
			if( app->value && AVS_IS_FREEABLE( avsp, app->value ) )
				bu_free( (genptr_t)app->value, "app->value" );
			app->value = NULL;	/* sanity */

			/* Move last one down to replace it */
			epp = &avsp->avp[--avsp->count];
			if( app != epp )  {
				*app = *epp;		/* struct copy */
			}
			epp->name = NULL;			/* sanity */
			epp->value = NULL;
			return 0;
		}
	}
	return -1;
}


/**
 * B U _ A V S _ F R E E
 *
 * Release all attributes in an attribute set.
 */
void
bu_avs_free( struct bu_attribute_value_set *avsp )
{
    struct bu_attribute_value_pair *app;

    BU_CK_AVS(avsp);

    if( avsp->max < 1 )
	return;

    if( avsp->count ) {
	for( BU_AVS_FOR(app, avsp) )  {
	    if( app->name && AVS_IS_FREEABLE( avsp, app->name ) ) {
		bu_free( (genptr_t)app->name, "app->name" );
	    }
	    app->name = NULL;	/* sanity */
	    if( app->value && AVS_IS_FREEABLE( avsp, app->value ) ) {
		bu_free( (genptr_t)app->value, "app->value" );
	    }
	    app->value = NULL;	/* sanity */
	}
	avsp->count = 0;
    }
    if ( avsp->avp ) {
	bu_free( (genptr_t)avsp->avp, "bu_avs_free avsp->avp" );
	avsp->avp = NULL; /* sanity */
	avsp->max = 0;
    }
}


/**
 * B U _ A V S _ P R I N T
 *
 * Print all attributes in an attribute set in "name = value" form,
 * using the provided title.
 */
void
bu_avs_print( const struct bu_attribute_value_set *avsp, const char *title )
{
	struct bu_attribute_value_pair	*avpp;
	unsigned int i;

	BU_CK_AVS(avsp);

	if (title) {
	    bu_log("%s: %d attributes:\n", title, avsp->count);
	}

	avpp = avsp->avp;
	for( i = 0; i < avsp->count; i++, avpp++ )  {
	    bu_log("  %s = %s\n",
		   avpp->name ? avpp->name : "NULL",
		   avpp->value ? avpp->value : "NULL");
	}
}


/**
 * B U _ A V S _ A D D _ N O N U N I Q U E
 *
 * Add a name/value pair even if the name already exists in this AVS.
 */
void
bu_avs_add_nonunique( struct bu_attribute_value_set *avsp, char *name, char *value )
{
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(avsp);

	/* don't even try */
	if (!name) {
	    if (value) {
		bu_log("WARNING: bu_avs_add_nonunique given NULL name and non-null value\n");
	    }
	    return;
	}

	if (avsp->count >= avsp->max) {
		/* Allocate more space first */
		avsp->max += AVS_ALLOCATION_INCREMENT;
		if (avsp->avp) {
			avsp->avp = (struct bu_attribute_value_pair *)bu_realloc(
			  avsp->avp,  avsp->max * sizeof(struct bu_attribute_value_pair),
				"attribute_value_pair.avp[] (add)" );
		} else {
			avsp->avp = (struct bu_attribute_value_pair *)bu_malloc(
				avsp->max * sizeof(struct bu_attribute_value_pair ),
			       "attribute_value_pair.avp[] (add)" );
		}
	}

	app = &avsp->avp[avsp->count++];
	app->name = bu_strdup(name);
	if (value) {
		app->value = bu_strdup(value);
	} else {
		app->value = (char *)NULL;
	}
}
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.17
log
@first stab at fixing a memory leak on attribute names -- appears to be during a merge, where adding to an existing doesn't free the existing name (when a new one is provided).  clean up the avs printing summary and doxygen comments too.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.16 2007/01/27 01:41:36 brlcad Exp $ (ARL)";
d41 1
a41 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.15 2007/01/23 01:13:33 brlcad Exp $ (ARL)";
d50 1
d53 1
a53 1
 *			B U _ A V S _ I N I T _ E M P T Y
a54 1
 * @@brief
d68 1
a68 1
 *			B U _ A V S _ I N I T
a69 1
 * @@brief
d79 1
a79 1
	if( len <= 0 )  len = 32;
d87 2
a88 1
/**			B U _ A V S _ N E W
a89 1
 *  @@brief
d108 1
a108 1
 *			B U _ A V S _ A D D
d114 1
d119 1
a119 1
bu_avs_add(struct bu_attribute_value_set *avsp, const char *attribute, const char *value)
d125 18
a142 8
	if( avsp->count ) {
		for( BU_AVS_FOR(app, avsp) )  {
			if( strcmp( app->name, attribute ) != 0 )  continue;
			if( app->value && AVS_IS_FREEABLE(avsp, app->value) )
				bu_free( (genptr_t)app->value, "app->value" );
			if( value )
				app->value = bu_strdup( value );
			else
d144 1
d151 1
a151 1
		avsp->max += 4;
d164 2
a165 2
	app->name = bu_strdup(attribute);
	if( value )
d167 1
a167 1
	else
d169 1
d173 4
a176 2
/*
 *			B U _ A V S _ A D D _ V L S
d179 1
a179 1
bu_avs_add_vls(struct bu_attribute_value_set *avsp, const char *attribute, const struct bu_vls *value_vls)
d184 1
a184 1
	return bu_avs_add( avsp, attribute, bu_vls_addr(value_vls) );
d188 1
a188 1
 *			B U _ A V S _ M E R G E
d190 2
a191 2
 *  @@brief
 *	Take all the attributes from 'src' and merge them into 'dest'.
d208 4
a211 2
/*
 *			B U _ A V S _ G E T
d214 1
a214 1
bu_avs_get( const struct bu_attribute_value_set *avsp, const char *attribute )
d220 5
a224 2
	if( avsp->count < 1 )
		return NULL;
d226 5
a230 3
	for( BU_AVS_FOR(app, avsp) )  {
		if( strcmp( app->name, attribute ) != 0 )  continue;
		return app->value;
d236 1
a236 1
 *			B U _ A V S _ R E M O V E
d238 1
a238 2
 * @@brief
 *	Remove the given attribute from the set
d246 1
a246 1
bu_avs_remove(struct bu_attribute_value_set *avsp, const char *attribute)
d252 4
d258 1
a258 1
			if( strcmp( app->name, attribute ) != 0 )  continue;
d279 5
a283 2
/*
 *			B U _ A V S _ F R E E
d316 5
a320 2
/*
 *			B U _ A V S _ P R I N T
d330 3
a332 1
	bu_log("bu_avs_print: %s\n", title);
d336 3
a338 1
		bu_log(" %s = %s\n", avpp->name, avpp->value );
d342 1
d344 1
a344 1
 *			B U _ A V S _ A D D _ N O N U N I Q U E
d346 1
a346 2
 * @@brief
 *	Add a name/value pair even if the name already exists in this AVS
d349 1
a349 1
bu_avs_add_nonunique( struct bu_attribute_value_set *avsp, char *attribute, char *value )
d355 9
a363 1
	if( avsp->count >= avsp->max )  {
d365 2
a366 2
		avsp->max += 4;
		if( avsp->avp ) {
d378 2
a379 2
	app->name = bu_strdup(attribute);
	if( value )
d381 1
a381 1
	else
d383 1
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.14 2007/01/21 04:45:41 brlcad Exp $ (ARL)";
d54 1
a54 1
 * @@brief 
d70 1
a70 1
 * @@brief 
d90 1
a90 1
 *  @@brief 
d176 1
a176 1
 *  @@brief 
@


14.14
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d35 1
a35 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.13 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.13
log
@update copyright to 2007
@
text
@a20 1

d22 1
a22 1
/*@@{*/
d24 1
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.12 2007/01/17 19:36:49 erikgreenwald Exp $ (ARL)";
d343 1
a343 1
/*@@}*/
@


14.12
log
@type fixes (size_t isn't necessarily unsigned int, signed vs unsigned, etc)
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.11 2006/08/31 05:50:24 lbutler Exp $ (ARL)";
@


14.11
log
@Mostly doxygen formatting.
@
text
@d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.10 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d297 1
a297 1
	int i;
@


14.10
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d25 1
d28 1
a28 2
 *  Author -
 *	Michael John Muuss
d30 2
a31 2
 *  Source -
 *	The U. S. Army Research Laboratory
a32 1
 *
a33 1
/*@@}*/
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.9 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d52 1
a52 1
/*
d54 3
d68 1
a68 1
/*
d70 3
d89 1
a89 2
/*
 *			B U _ A V S _ N E W
d91 3
a93 2
 *  Allocate storage for a new attribute/value set, with at least
 *  'len' slots pre-allocated.
d109 1
a109 1
/*
d174 1
a174 1
/*
d177 2
a178 1
 *  Take all the attributes from 'src' and merge them into 'dest'.
d215 1
a215 1
/*
d218 4
a221 1
 *  Returns -
d223 1
d309 1
a309 1
/*
d312 1
d343 1
a343 1

@


14.9
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.8 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.8
log
@Doxygen changes
@
text
@d29 1
a29 1
 *  
d33 1
a33 1
 *  
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.7 2005/05/11 02:33:34 brlcad Exp $ (ARL)";
d233 1
a233 1
			
d254 1
a254 1
    
d256 1
a256 1
    
d259 1
a259 1
    
@


14.8.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d33 1
a33 1
 *
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header$ (ARL)";
d233 1
a233 1

d254 1
a254 1

d256 1
a256 1

d259 1
a259 1

@


14.7
log
@make sure we're not trying to free null avs pointers. also set the counters to zero/null when we're done just in case.
@
text
@d21 3
a24 1
 *
d35 2
d38 1
a38 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.6 2005/01/30 20:30:45 brlcad Exp $ (ARL)";
@


14.6
log
@update copyright to 2005
@
text
@d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/avs.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
a38 2


d41 1
a41 1
#include <string.h>
d43 1
a43 1
#include <strings.h>
d49 1
d139 2
a140 2
			avsp->avp = (struct bu_attribute_value_pair *)bu_malloc(
				avsp->max * sizeof(struct bu_attribute_value_pair ),
d223 1
a223 1
			if( AVS_IS_FREEABLE( avsp, app->name ) )
d226 1
a226 1
			if( AVS_IS_FREEABLE( avsp, app->value ) )
d249 17
a265 16
	struct bu_attribute_value_pair *app;

	BU_CK_AVS(avsp);

	if( avsp->max < 1 )
		return;

	if( avsp->count ) {
		for( BU_AVS_FOR(app, avsp) )  {
			if( AVS_IS_FREEABLE( avsp, app->name ) )
				bu_free( (genptr_t)app->name, "app->name" );
			app->name = NULL;	/* sanity */
			if( app->value && AVS_IS_FREEABLE( avsp, app->value ) )
				bu_free( (genptr_t)app->value, "app->value" );
			app->value = NULL;	/* sanity */
		}
d267 3
d271 3
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/avs.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a31 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d34 1
a34 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/avs.c,v 14.3 2004/12/21 05:45:20 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/avs.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/avs.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			A V S . C
d36 1
a36 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/avs.c,v 1.3 2004/09/03 23:30:57 morrison Exp $ (ARL)";
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/avs.c,v 1.2 2004/08/02 23:01:48 morrison Exp $ (ARL)";
d306 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/avs.c,v 1.1 2004/05/20 15:19:31 morrison Exp $ (ARL)";
d25 1
a25 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d17 1
a17 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/avs.c,v 1.21 2004/05/10 15:30:44 erikg Exp $ (ARL)";
d20 1
a20 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

