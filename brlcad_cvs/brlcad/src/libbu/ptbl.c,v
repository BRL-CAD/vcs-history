head	14.20;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.6
	rel-7-10-2:14.16
	rel-7-10-0:14.16
	rel-7-8-4:14.12
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.20
date	2007.12.16.18.53.48;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.10.22.21.06.48;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.09;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.09.03.15.14.07;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.08.31.23.16.38;	author lbutler;	state Exp;
branches;
next	14.10;

14.10
date	2006.02.04.01.01.52;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.46;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.15.06.54.56;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.35;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.20
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@/*                          P T B L . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup ptbl */
/** @@{ */
/** @@file ptbl.c
 *
 *  @@brief Support for generalized "pointer tables"
 *
 *  Support for generalized "pointer tables",
 *  kept compactly in a dynamic array.
 *
 *  The table is currently un-ordered, and is merely a array of pointers.
 *  The support routine nmg_tbl manipulates the array for you.
 *  Pointers to be operated on (inserted, deleted,
 *  searched for) are passed as a "pointer to long".
 *
 *
 *  @@authors	Lee A. Butler
 *  @@authors	Michael John Muuss
 *
 * @@par  Source -
 *	The U. S. Army Research Laboratory
 *@@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */


#ifndef lint
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.19 2007/12/16 15:59:38 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdio.h>
#include <string.h>

#include "machine.h"
#include "bu.h"


/**
 *			B U _ P T B L _ I N I T
 *
 *  Initialize struct & get storage for table.
 *  Recommend 8 or 64 for initial len.
 */
void
bu_ptbl_init(struct bu_ptbl *b, int len, const char *str)
{
	if (bu_debug & BU_DEBUG_PTBL)
		bu_log("bu_ptbl_init(%8x, len=%d, %s)\n", b, len, str);
	BU_LIST_INIT(&b->l);
	b->l.magic = BU_PTBL_MAGIC;
	if( len <= 0 )  len = 64;
	b->blen = len;
	b->buffer = (long **)bu_calloc(b->blen, sizeof(long *), str);
	b->end = 0;
}


/**
 *			B U _ P T B L _ R E S E T
 *
 *  Reset the table to have no elements, but retain any existing storage.
 */
void
bu_ptbl_reset(struct bu_ptbl *b)
{
	BU_CK_PTBL(b);
	if (bu_debug & BU_DEBUG_PTBL)
		bu_log("bu_ptbl_reset(%8x)\n", b);
	b->end = 0;
	memset((char *)b->buffer, 0, b->blen*sizeof(long *));	/* no peeking */
}


/**
 *			B U _ P T B L _ I N S
 *
 *  Append/Insert a (long *) item to/into the table.
 */
int
bu_ptbl_ins(struct bu_ptbl *b, long int *p)
{
	register int i;

	BU_CK_PTBL(b);

	if (bu_debug & BU_DEBUG_PTBL)
		bu_log("bu_ptbl_ins(%8x, %8x)\n", b, p);

	if (b->blen == 0) bu_ptbl_init(b, 64, "bu_ptbl_ins() buffer");
	if (b->end >= b->blen)  {
		b->buffer = (long **)bu_realloc( (char *)b->buffer,
		    sizeof(p)*(b->blen *= 4),
		    "bu_ptbl.buffer[] (ins)" );
	}

	i=b->end++;
	b->buffer[i] = p;
	return(i);
}


/**
 *			B U _ P T B L _ L O C A T E
 *
 *  locate a (long *) in an existing table
 *
 *
 * @@return	index of first matching element in array, if found
 * @@return	-1	if not found
 *
 * We do this a great deal, so make it go as fast as possible.
 * this is the biggest argument I can make for changing to an
 * ordered list.  Someday....
 */
int
bu_ptbl_locate(const struct bu_ptbl *b, const long int *p)
{
	register int		k;
	register const long	**pp;

	BU_CK_PTBL(b);
	pp = (const long **)b->buffer;
	for( k = b->end-1; k >= 0; k-- )
		if (pp[k] == p) return(k);

	return(-1);
}


/**
 *			B U _ P T B L _ Z E R O
 *
 *  Set all occurrences of "p" in the table to zero.
 *  This is different than deleting them.
 */
void
bu_ptbl_zero(struct bu_ptbl *b, const long int *p)
{
	register int		k;
	register const long	**pp;

	BU_CK_PTBL(b);
	pp = (const long **)b->buffer;
	for( k = b->end-1; k >= 0; k-- )
		if (pp[k] == p) pp[k] = (long *)0;
}


/**
 *			B U _ P T B L _ I N S _ U N I Q U E
 *
 *  Append item to table, if not already present.  Unique insert.
 *
 *
 *  @@return	index of first matchine element in array, if found.  (table unchanged)
 *  @@return	-1	if table extended to hold new element
 *
 * We do this a great deal, so make it go as fast as possible.
 * this is the biggest argument I can make for changing to an
 * ordered list.  Someday....
 */
int
bu_ptbl_ins_unique(struct bu_ptbl *b, long int *p)
{
	register int	k;
	register long	**pp = b->buffer;

	BU_CK_PTBL(b);

	/* search for existing */
	for( k = b->end-1; k >= 0; k-- )
		if (pp[k] == p) return(k);

	if (bu_debug & BU_DEBUG_PTBL)
		bu_log("bu_ptbl_ins_unique(%8x, %8x)\n", b, p);

	if (b->blen <= 0 || b->end >= b->blen)  {
		/* Table needs to grow */
		bu_ptbl_ins( b, p );
		return -1;	/* To signal that it was added */
	}

	b->buffer[k=b->end++] = p;
	return(-1);		/* To signal that it was added */
}


/**
 *			B U _ P T B L _ R M
 *
 *  Remove all occurrences of an item from a table
 *
 *
 *  @@return	Number of copies of 'p' that were removed from the table.
 *  @@return	0 if none found.
 *
 * we go backwards down the table looking for occurrences
 * of p to delete.  We do it backwards to reduce the amount
 * of data moved when there is more than one occurrence of p
 * in the table.  A pittance savings, unless you're doing a
 * lot of it.
 */
int
bu_ptbl_rm(struct bu_ptbl *b, const long int *p)
{
	register int end = b->end, j, k, l;
	register long **pp = b->buffer;
	int	ndel = 0;

	BU_CK_PTBL(b);
	for (l = b->end-1 ; l >= 0 ; --l)  {
		if (pp[l] == p){
			/* delete consecutive occurrence(s) of p */
			ndel++;

			j=l+1;
			while (l >= 1 && pp[l-1] == p) --l, ndel++;
			/* pp[l] through pp[j-1] match p */

			end -= j - l;
			for(k=l ; j < b->end ;)
				b->buffer[k++] = b->buffer[j++];
			b->end = end;
		}
	}
	if (bu_debug & BU_DEBUG_PTBL)
		bu_log("bu_ptbl_rm(%8x, %8x) ndel=%d\n", b, p, ndel);
	return ndel;
}


/**
 *			B U _ P T B L _ C A T
 *
 *  Catenate one table onto end of another.
 *  There is no checking for duplication.
 */
void
bu_ptbl_cat(struct bu_ptbl *dest, const struct bu_ptbl *src)
{
	BU_CK_PTBL(dest);
	BU_CK_PTBL(src);
	if (bu_debug & BU_DEBUG_PTBL)
		bu_log("bu_ptbl_cat(%8x, %8x)\n", dest, src);

	if ((dest->blen - dest->end) < src->end) {
		dest->blen = (dest->blen + src->end) * 2 + 8;
		dest->buffer = (long **)bu_realloc( (char *)dest->buffer,
			dest->blen * sizeof(long *),
			"bu_ptbl.buffer[] (cat)");
	}
	memcpy((char *)&dest->buffer[dest->end], (char *)src->buffer, src->end*sizeof(long *));
	dest->end += src->end;
}


/**
 *			B U _ P T B L _ C A T _ U N I Q
 *
 *  Catenate one table onto end of another,
 *  ensuring that no entry is duplicated.
 *  Duplications between multiple items in 'src' are not caught.
 *  The search is a nasty n**2 one.  The tables are expected to be short.
 */
void
bu_ptbl_cat_uniq(struct bu_ptbl *dest, const struct bu_ptbl *src)
{
	register long	**p;

	BU_CK_PTBL(dest);
	BU_CK_PTBL(src);
	if (bu_debug & BU_DEBUG_PTBL)
		bu_log("bu_ptbl_cat_uniq(%8x, %8x)\n", dest, src);

	/* Assume the worst, ensure sufficient space to add all 'src' items */
	if ((dest->blen - dest->end) < src->end) {
		dest->buffer = (long **)bu_realloc( (char *)dest->buffer,
			sizeof(long *)*(dest->blen += src->blen + 8),
			"bu_ptbl.buffer[] (cat_uniq)");
	}
	for( BU_PTBL_FOR( p, (long **), src ) )  {
		bu_ptbl_ins_unique( dest, *p );
	}
}


/**
 *			B U _ P T B L _ F R E E
 *
 *  Deallocate dynamic buffer associated with a table,
 *  and render this table unusable without a subsequent bu_ptbl_init().
 */
void
bu_ptbl_free(struct bu_ptbl *b)
{
	BU_CK_PTBL(b);

	bu_free((genptr_t)b->buffer, "bu_ptbl.buffer[]");
	memset((char *)b, 0, sizeof(struct bu_ptbl));	/* sanity */

	if (bu_debug & BU_DEBUG_PTBL)
		bu_log("bu_ptbl_free(%8x)\n", b);
}


/**
 *			B U _ P T B L
 *
 *  This version maintained for source compatibility with existing NMG code.
 */
int
bu_ptbl(struct bu_ptbl *b, int func, long int *p)
{
	if (func == BU_PTBL_INIT) {
		bu_ptbl_init(b, 64, "bu_ptbl() buffer[]");
		return 0;
	} else if (func == BU_PTBL_RST) {
		bu_ptbl_reset(b);
		return 0;
	} else if (func == BU_PTBL_INS) {
		return bu_ptbl_ins(b, p);
	} else if (func == BU_PTBL_LOC) {
		return bu_ptbl_locate(b, p);
	} else if( func == BU_PTBL_ZERO ) {
		bu_ptbl_zero(b, p);
		return( 0 );
	} else if (func == BU_PTBL_INS_UNIQUE) {
		return bu_ptbl_ins_unique(b, p);
	} else if (func == BU_PTBL_RM) {
		return bu_ptbl_rm(b, p);
	} else if (func == BU_PTBL_CAT) {
		bu_ptbl_cat( b, (const struct bu_ptbl *)p );
		return(0);
	} else if (func == BU_PTBL_FREE) {
		bu_ptbl_free(b);
		return (0);
	} else {
		BU_CK_PTBL(b);
		bu_log("bu_ptbl(%8x) Unknown table function %d\n", b, func);
		bu_bomb("bu_ptbl");
	}
	return(-1);/* this is here to keep lint happy */
}


/**
 *			B U _ P R _ P T B L
 *
 *  Print a bu_ptbl array for inspection.
 */
void
bu_pr_ptbl(const char *title, const struct bu_ptbl *tbl, int verbose)
{
	register long	**lp;

	BU_CK_PTBL(tbl);
	bu_log("%s: bu_ptbl array with %d entries\n",
		title, tbl->end );

	if( !verbose )  return;

	/* Go in ascending order */
	for( lp = (long **)BU_PTBL_BASEADDR(tbl);
	     lp <= (long **)BU_PTBL_LASTADDR(tbl); lp++
	)  {
		if( *lp == 0 )  {
			bu_log("  %.8x NULL entry\n", *lp);
			continue;
		}
		bu_log("  %.8x %s\n", *lp, bu_identify_magic(**lp) );
	}
}


/**
 *			B U _ P T B L _ T R U N C
 *
 *	truncate a bu_ptbl
 */
void
bu_ptbl_trunc(struct bu_ptbl *tbl, int end)
{
	BU_CK_PTBL(tbl);

	if( tbl->end <= end )
		return;

	tbl->end = end;
	return;
}
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.19
log
@convert all bzero calls to memset
@
text
@d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.18 2007/10/22 21:06:48 brlcad Exp $ (ARL)";
d272 1
a272 2
	bcopy( (char *)src->buffer, (char *)&dest->buffer[dest->end],
		src->end*sizeof(long *));
@


14.18
log
@removed the non-ansi/stc compliant noalias.h and noalias-prag.h headers that were used with the cray (and alliant) to make pragma decls before loops.  made obsolete long ago with the move to ansi compliance.
@
text
@d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.17 2007/09/15 16:23:09 brlcad Exp $ (ARL)";
d90 1
a90 1
	memset( (char *)b->buffer, 0, b->blen*sizeof(long *) );	/* no peeking */
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.16 2007/01/27 01:41:37 brlcad Exp $ (ARL)";
a142 1
#	include "noalias.h"
a163 1
#	include "noalias.h"
a189 2
#	include "noalias.h"

a240 1
#			include "noalias.h"
@


14.16
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.15 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d52 1
a52 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.14 2007/01/21 04:45:42 brlcad Exp $ (ARL)";
d131 1
a131 1
 *  
@


14.14
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.13 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.13
log
@update copyright to 2007
@
text
@d21 2
a22 4

/** \addtogroup ptbl */
/*@@{*/

d25 1
a25 1
 * @@brief Support for generalized "pointer tables"
d47 1
a47 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.12 2006/09/03 15:14:07 lbutler Exp $ (ARL)";
d422 1
a422 1
/*@@}*/
@


14.12
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d49 1
a49 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.11 2006/08/31 23:16:38 lbutler Exp $ (ARL)";
@


14.11
log
@Doxygen comments
@
text
@d26 3
d49 1
a49 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.10 2006/02/04 01:01:52 brlcad Exp $ (ARL)";
@


14.10
log
@cleanup, doxygenify
@
text
@d22 1
a22 1
/** \addtogroup libbu */
a33 3
 *  Authors -
 *	Lee A. Butler
 *	Michael John Muuss
d35 4
a38 1
 *  Source -
d40 1
a40 1
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
d43 1
a43 1
/*@@}*/
d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d131 3
a133 3
 *  Returns -
 *	index of first matching element in array, if found
 *	-1	if not found
d180 3
a182 3
 *  Returns -
 *	index of first matchine element in array, if found.  (table unchanged)
 *	-1	if table extended to hold new element
d221 3
a223 3
 *  Returns -
 *	Number of copies of 'p' that were removed from the table.
 *	0 if none found.
d421 1
a421 1

@


14.9
log
@update copyright to 2006
@
text
@d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.8 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
a50 1

a51 2
#include "machine.h"
#include "bu.h"
d53 1
a53 1
#include <string.h>
d55 1
a55 1
#include <strings.h>
d58 5
a62 1
/*
d65 2
a66 1
 *  Initialize struct & get storage for table
a69 3

   		    		/* initial len.  Recommend 8 or 64 */

d81 2
a82 1
/*
a90 1
	b->end = 0;
d93 1
d97 2
a98 1
/*
d101 1
a101 2
 *  Append a (long *) item to the table.
 *  Called "insert", for unknown reasons.
d108 2
d113 1
a113 3
	BU_CK_PTBL(b);

	if (b->blen == 0) bu_ptbl_init(b, 8, "bu_ptbl_ins() buffer");
d120 2
a121 1
	b->buffer[i=b->end++] = p;
d125 2
a126 1
/*
d154 2
a155 1
/*
d174 2
a175 1
/*
d198 1
d215 2
a216 1
/*
d260 2
a261 1
/*
d286 2
a287 1
/*
d316 2
a317 1
/*
d336 1
a336 2

/*
d375 2
a376 1
/*
d404 3
a406 1
/*			B U _ P T B L _ T R U N C
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.7 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.7
log
@Doxygen changes
@
text
@d37 1
a37 1
 *  
d41 1
a41 1
 *  
d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.6 2005/01/30 20:30:46 brlcad Exp $ (ARL)";
d68 1
a68 1
              	   
d70 1
a70 1
          	     
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header$ (ARL)";
d68 1
a68 1

d70 1
a70 1

@


14.6
log
@update copyright to 2005
@
text
@d21 4
a25 1
 *
d43 2
d46 1
a46 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/ptbl.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d41 1
a41 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/ptbl.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a38 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d41 1
a41 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/ptbl.c,v 14.3 2004/12/21 05:45:21 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d43 1
a43 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/ptbl.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d43 1
a43 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/ptbl.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			P T B L . C
d43 1
a43 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/ptbl.c,v 1.3 2004/09/15 06:54:56 morrison Exp $ (ARL)";
@


1.3
log
@put some space around the nasty in-lined header..
@
text
@d24 1
a24 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/ptbl.c,v 1.2 2004/08/02 23:01:48 morrison Exp $ (ARL)";
d388 10
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/ptbl.c,v 1.1 2004/05/20 15:19:35 morrison Exp $ (ARL)";
d169 1
d171 1
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char libbu_ptbl_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/ptbl.c,v 1.17 2004/05/10 15:30:44 erikg Exp $ (ARL)";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

