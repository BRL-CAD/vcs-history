head	14.22;
access;
symbols
	rel-7-10-4:14.21
	STABLE:14.21.0.2
	stable-branch:14.6
	rel-7-10-2:14.21
	rel-7-10-0:14.20
	rel-7-8-4:14.16
	rel-7-8-2:14.13
	rel-7-8-0:14.13
	trimnurbs-branch:14.13.0.2
	help:14.13
	temp_tag:14.11
	bobWinPort-20051223-freeze:14.10
	postmerge-20051223-bobWinPort:14.11
	premerge-20051223-bobWinPort:14.11
	rel-7-6-6:14.11
	rel-7-6-4:14.11
	rel-7-6-2:14.10
	rel-7-6-branch:14.10.0.4
	rel-7-6-0:14.10
	rel-7-4-2:14.9
	rel-7-4-branch:14.9.0.2
	bobWinPort:14.10.0.2
	rel-7-4-0:14.9
	rel-7-2-6:14.9
	rel-7-2-4:14.8
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.22
date	2007.09.15.16.23.09;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.04.14.01.16.02;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.09.03.15.14.07;	author lbutler;	state Exp;
branches;
next	14.15;

14.15
date	2006.08.31.23.16.38;	author lbutler;	state Exp;
branches;
next	14.14;

14.14
date	2006.07.09.18.25.31;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.01.21.00.22.23;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.10.4.1;
next	14.9;

14.9
date	2005.05.28.02.14.50;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.05.04.03.17.04;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.04.27.02.38.52;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.46;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.03.20.42.29;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.34;	author morrison;	state Exp;
branches;
next	;

14.10.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.22
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@/*                    M A P P E D F I L E . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup mf */
/** @@{ */
/** @@file mappedfile.c
 *
 * @@brief
 *  Routines for sharing large read-only data files.
 *
 *  Routines for sharing large read-only data files
 *  like height fields, bit map solids, texture maps, etc.
 *  Uses memory mapped files where available.
 *
 *  Each instance of the file has the raw data available as element "buf".
 *  If a particular application needs to transform the raw data in a
 *  manner that is identical across all uses of that application
 *  (e.g. height fields, EBMs, etc), then the application should
 *  provide a non-null "appl" string, to tag the format of the "apbuf".
 *  This will keep different applications from sharing that instance
 *  of the file.
 *  Thus, if the same filename is opened for interpretation as both
 *  an EBM and a height field, they will be assigned different mapped file
 *  structures, so that the "apbuf" pointers are distinct.
 *
 *
 *  @@author	Michael John Muuss
 *
 *  @@par Source -
 *	The U. S. Army Research Laboratory
 * @@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */

#ifndef lint
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.21 2007/04/14 01:16:02 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdio.h>
#include <math.h>
#include <fcntl.h>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_UNIX_IO
#  include <sys/types.h>
#  include <sys/stat.h>
#endif
#ifdef HAVE_SYS_MMAN_H
#  include <sys/mman.h>
#  if !defined(MAP_FAILED)
#    define MAP_FAILED	((void *)-1)	/* Error return from mmap() */
#  endif
#endif

#include "machine.h"
#include "bu.h"


static struct bu_list	bu_mapped_file_list = {
	0,
	(struct bu_list *)NULL,
	(struct bu_list *)NULL
};	/* list of currently open mapped files */

/**
 *			B U _ O P E N _ M A P P E D _ F I L E
 *
 *  If the file can not be opened, as descriptive an error message as
 *  possible will be printed, to simplify code handling in the caller.
 *
 *  Mapped files are always opened read-only.
 *
 *  If the system does not support mapped files, the data is read into memory.
 */
struct bu_mapped_file *
bu_open_mapped_file(const char *name, const char *appl)
				/* file name */
				/* non-null only when app. will use 'apbuf' */
{
	struct bu_mapped_file	*mp = (struct bu_mapped_file *)NULL;
#ifdef HAVE_UNIX_IO
	struct stat		sb;
	int			fd;	/* unix file descriptor */
#else
	FILE			*fp = (FILE *)NULL;	/* stdio file pointer */
#endif
	int			ret;

	if( bu_debug&BU_DEBUG_MAPPED_FILE )
#ifdef HAVE_SBRK
		bu_log("bu_open_mapped_file(%s, %s) sbrk=x%lx\n", name, appl?appl:"(NIL)", (long)sbrk(0));
#else
		bu_log("bu_open_mapped_file(%s, %s)\n", name, appl?appl:"(NIL)");
#endif

	/* See if file has already been mapped, and can be shared */
	bu_semaphore_acquire(BU_SEM_MAPPEDFILE);
	if( BU_LIST_UNINITIALIZED( &bu_mapped_file_list ) )  {
		BU_LIST_INIT( &bu_mapped_file_list );
	}
	for( BU_LIST_FOR( mp, bu_mapped_file, &bu_mapped_file_list ) )  {
		BU_CK_MAPPED_FILE(mp);
		if( strcmp( name, mp->name ) )  continue;
		if( appl && strcmp( appl, mp->appl ) )
			continue;
		/* File is already mapped -- verify size and modtime */
#ifdef HAVE_UNIX_IO
		if( !mp->dont_restat )  {
			bu_semaphore_acquire(BU_SEM_SYSCALL);
			ret = stat( name, &sb );
			bu_semaphore_release(BU_SEM_SYSCALL);
			if( ret < 0 )  goto do_reuse;	/* File vanished from disk, mapped copy still OK */
			if( sb.st_size != mp->buflen )  {
				bu_log("bu_open_mapped_file(%s) WARNING: File size changed from %ld to %ld, opening new version.\n",
					name, (long)mp->buflen, (long)sb.st_size );
				goto dont_reuse;
			}
			if( (long)sb.st_mtime != mp->modtime )  {
				bu_log("bu_open_mapped_file(%s) WARNING: File modified since last mapped, opening new version.\n",
					name);
				goto dont_reuse;
			}
			/* To be completely safe, should check st_dev and st_inum */
		}
#endif
do_reuse:
		/* It is safe to reuse mp */
		mp->uses++;
		bu_semaphore_release(BU_SEM_MAPPEDFILE);
		if( bu_debug&BU_DEBUG_MAPPED_FILE )
			bu_pr_mapped_file("open_reused", mp);
		return mp;
dont_reuse:
		/* mp doesn't reflect the file any longer.  Invalidate. */
		mp->appl = "__STALE__";
		/* Can't invalidate old copy, it may still be in use. */
		/* Fall through, and open the new version */
	}
	bu_semaphore_release(BU_SEM_MAPPEDFILE);
	mp = (struct bu_mapped_file *)NULL;

	/* File is not yet mapped, open file read only. */
#ifdef HAVE_UNIX_IO
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fd = open( name, O_RDONLY );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( fd < 0 )  {
		if (bu_debug&BU_DEBUG_DB)
			perror(name);
		goto fail;
	}

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	ret = fstat( fd, &sb );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( ret < 0 )  {
		perror(name);
		goto fail;
	}

	if( sb.st_size == 0 )  {
		bu_log("bu_open_mapped_file(%s) 0-length file\n", name);
		goto fail;
	}
#endif /* HAVE_UNIX_IO */

	/* Optimisticly assume that things will proceed OK */
	BU_GETSTRUCT( mp, bu_mapped_file );
	mp->name = bu_strdup( name );
	if( appl ) mp->appl = bu_strdup( appl );

#ifdef HAVE_UNIX_IO
	mp->buflen = (size_t)sb.st_size;
	mp->modtime = (long)sb.st_mtime;
#  ifdef HAVE_SYS_MMAN_H

	/* Attempt to access as memory-mapped file */
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	mp->buf = mmap((caddr_t)0, (size_t)sb.st_size, PROT_READ, MAP_PRIVATE, fd, (off_t)0 );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( mp->buf == MAP_FAILED )  perror(name);
	if( mp->buf != MAP_FAILED )  {
		/* OK, it's memory mapped in! */
		mp->is_mapped = 1;
		/* It's safe to close the fd now, the manuals say */
	} else
#  endif /* HAVE_SYS_MMAN_H */
	{
		/* Allocate a local buffer, and slurp it in */
		mp->buf = bu_malloc( (size_t)sb.st_size, name );

		bu_semaphore_acquire(BU_SEM_SYSCALL);
		ret = read( fd, mp->buf, (size_t)sb.st_size );
		bu_semaphore_release(BU_SEM_SYSCALL);

		if( ret != sb.st_size )  {
			perror(name);
			bu_free( mp->buf, name );
			bu_semaphore_acquire(BU_SEM_SYSCALL);
			(void)close(fd);
			bu_semaphore_release(BU_SEM_SYSCALL);
			goto fail;
		}
	}

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	(void)close(fd);
	bu_semaphore_release(BU_SEM_SYSCALL);

#else /* !HAVE_UNIX_IO */

	/* Read it in with stdio, with no clue how big it is */
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fp = fopen( name, "rb");
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( fp == NULL )  {
		perror(name);
		goto fail;
	}
	/* Read it once to see how large it is */
	{
		char	buf[32768] = {0};
		int	got;
		mp->buflen = 0;

		bu_semaphore_acquire(BU_SEM_SYSCALL);
		while( (got = fread( buf, 1, sizeof(buf), fp )) > 0 )
			mp->buflen += got;
		rewind(fp);
		bu_semaphore_release(BU_SEM_SYSCALL);

	}
	/* Malloc the necessary buffer */
	mp->buf = bu_malloc( mp->buflen, name );

	/* Read it again into the buffer */
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	ret = fread( mp->buf, mp->buflen, 1, fp );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( ret != 1 )  {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		perror("fread");
		fclose(fp);
		bu_semaphore_release(BU_SEM_SYSCALL);

		bu_log("bu_open_mapped_file() 2nd fread failed? len=%d\n", mp->buflen);
		bu_free( mp->buf, "non-unix fread buf" );
		goto fail;
	}

	bu_semaphore_acquire(BU_SEM_SYSCALL);
	fclose(fp);
	bu_semaphore_release(BU_SEM_SYSCALL);
#endif

	mp->uses = 1;
	mp->l.magic = BU_MAPPED_FILE_MAGIC;

	bu_semaphore_acquire(BU_SEM_MAPPEDFILE);
	BU_LIST_APPEND( &bu_mapped_file_list, &mp->l );
	bu_semaphore_release(BU_SEM_MAPPEDFILE);

	if( bu_debug&BU_DEBUG_MAPPED_FILE )  {
		bu_pr_mapped_file("1st_open", mp);
#ifdef HAVE_SBRK
		bu_log("bu_open_mapped_file() sbrk=x%lx\n", (long)sbrk(0));
#endif
	}
	return mp;

fail:
	if( mp )  {
		bu_free( mp->name, "mp->name" );
		if( mp->appl ) bu_free( mp->appl, "mp->appl" );
		/* Don't free mp->buf here, it might not be bu_malloced but mmaped */
		bu_free( mp, "mp from bu_open_mapped_file fail");
	}

	if (bu_debug&BU_DEBUG_DB)
	  bu_log("bu_open_mapped_file(%s, %s) can't open file\n",
		 name, appl?appl:"(NIL)" );

	return (struct bu_mapped_file *)NULL;
}

/**
 *			B U _ C L O S E _ M A P P E D _ F I L E
 *
 *  Release a use of a mapped file.
 *  Because it may be re-used shortly, e.g. by the next frame of
 *  an animation, don't release the memory even on final close,
 *  so that it's available when next needed.
 *  Call bu_free_mapped_files() after final close to reclaim space.
 *  But only do that if you're SURE that ALL these files will never again
 *  need to be mapped by this process.  Such as when running multi-frame
 *  animations.
 */
void
bu_close_mapped_file(struct bu_mapped_file *mp)
{
	BU_CK_MAPPED_FILE(mp);

	if( bu_debug&BU_DEBUG_MAPPED_FILE )
		bu_pr_mapped_file("close:uses--", mp);

	if (! mp) {
	    bu_log("bu_close_mapped_file() called with null pointer\n");
	    return;
	}

	bu_semaphore_acquire(BU_SEM_MAPPEDFILE);
	--mp->uses;
	bu_semaphore_release(BU_SEM_MAPPEDFILE);
}

/**
 *			B U _ P R _ M A P P E D _ F I L E
 */
void
bu_pr_mapped_file(const char *title, const struct bu_mapped_file *mp)
{
	BU_CK_MAPPED_FILE(mp);

	bu_log("%8lx mapped_file %s %lx len=%ld mapped=%d, uses=%d %s\n",
		(long)mp, mp->name, (long)mp->buf, mp->buflen,
		mp->is_mapped, mp->uses,
		title );
}

/**
 *			B U _ F R E E _ M A P P E D _ F I L E S
 *
 *  Release storage being used by mapped files with no remaining users.
 *  This entire routine runs inside a critical section, for parallel protection.
 *  Only call this routine if you're SURE that ALL these files will never
 *  again need to be mapped by this process.  Such as when running multi-frame
 *  animations.
 */
void
bu_free_mapped_files(int verbose)
{
	struct bu_mapped_file	*mp, *next;

	if( bu_debug&BU_DEBUG_MAPPED_FILE )
		bu_log("bu_free_mapped_files(verbose=%d)\n", verbose);

	bu_semaphore_acquire(BU_SEM_MAPPEDFILE);

	next = BU_LIST_FIRST( bu_mapped_file, &bu_mapped_file_list );
	while( BU_LIST_NOT_HEAD( next, &bu_mapped_file_list ) )  {
		BU_CK_MAPPED_FILE(next);
		mp = next;
		next = BU_LIST_NEXT( bu_mapped_file, &mp->l );

		if( mp->uses > 0 )  continue;

		/* Found one that needs to have storage released */
		if(verbose || (bu_debug&BU_DEBUG_MAPPED_FILE))
			bu_pr_mapped_file( "freeing", mp );

		BU_LIST_DEQUEUE( &mp->l );

		/* If application pointed mp->apbuf at mp->buf, break that
		 * association so we don't double-free the buffer.
		 */
		if( mp->apbuf == mp->buf )  mp->apbuf = (genptr_t)NULL;

#ifdef HAVE_SYS_MMAN_H
		if( mp->is_mapped )  {
			int	ret;
			bu_semaphore_acquire(BU_SEM_SYSCALL);
			ret = munmap( mp->buf, (size_t)mp->buflen );
			bu_semaphore_release(BU_SEM_SYSCALL);
			if( ret < 0 )  perror("munmap");
			/* XXX How to get this chunk of address space back to malloc()? */
		} else
#endif
		{
			bu_free( mp->buf, "bu_mapped_file.buf[]" );
		}
		mp->buf = (genptr_t)NULL;		/* sanity */
		bu_free( (genptr_t)mp->name, "bu_mapped_file.name" );
		if( mp->appl )  bu_free( (genptr_t)mp->appl, "bu_mapped_file.appl" );
		bu_free( (genptr_t)mp, "struct bu_mapped_file" );
	}
	bu_semaphore_release(BU_SEM_MAPPEDFILE);
}

/**
 *	B U _ O P E N _ M A P P E D _ F I L E _ W I T H _ P A T H
 *
 *  A wrapper for bu_open_mapped_file() which uses a search path
 *  to locate the file.
 *  The search path is specified as a normal C argv array,
 *  terminated by a null string pointer.
 *  If the file name begins with a slash ('/') the path is not used.
 */
struct bu_mapped_file *
bu_open_mapped_file_with_path(char *const *path, const char *name, const char *appl)

				/* file name */
				/* non-null only when app. will use 'apbuf' */
{
	char	* const *pathp = path;
	struct bu_vls	str;
	struct bu_mapped_file	*ret;

	BU_ASSERT_PTR( name, !=, NULL );
	BU_ASSERT_PTR( pathp, !=, NULL );

	/* Do not resort to path for a rooted filename */
	if( name[0] == '/' )
		return bu_open_mapped_file( name, appl );

	bu_vls_init(&str);

	/* Try each path prefix in sequence */
	for( ; *pathp != NULL; pathp++ )  {
		bu_vls_strcpy( &str, *pathp );
		bu_vls_putc( &str, '/' );
		bu_vls_strcat( &str, name );

		ret = bu_open_mapped_file( bu_vls_addr(&str), appl );
		if( ret )  {
			bu_vls_free( &str );
			return ret;
		}
	}

	/* Failure, none of the opens succeeded */
	bu_vls_free( &str );
	return (struct bu_mapped_file *)NULL;
}

/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@remove the WIN32 conditionals relating to the binary mode specifier on file opens.  just keep the rb/wb mode since ISO/IEC 9899:1990 does specify it.
@
text
@d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.20 2007/01/27 01:41:36 brlcad Exp $ (ARL)";
d60 2
a64 8
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif

#include "machine.h"

a68 1

d76 1
@


14.20
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.19 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
a243 1
#if defined(_WIN32) && !defined(__CYGWIN__)
a244 3
#else
	fp = fopen( name, "r");
#endif
@


14.19
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.18 2007/01/21 04:45:42 brlcad Exp $ (ARL)";
d104 2
a105 2
          	      		/* file name */
          	      		/* non-null only when app. will use 'apbuf' */
d213 3
a215 3
	    	/* OK, it's memory mapped in! */
	    	mp->is_mapped = 1;
	    	/* It's safe to close the fd now, the manuals say */
d437 2
a438 2
          	      		/* file name */
          	      		/* non-null only when app. will use 'apbuf' */
@


14.18
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.17 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.17
log
@update copyright to 2007
@
text
@d21 2
a22 4

/** \addtogroup mf */
/*@@{*/

d24 3
a26 1
 * @@brief Routines for sharing large read-only data files.
d53 1
a53 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.16 2006/09/03 15:14:07 lbutler Exp $ (ARL)";
d472 1
a472 1
/*@@}*/
@


14.16
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d53 1
a53 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.15 2006/08/31 23:16:38 lbutler Exp $ (ARL)";
@


14.15
log
@Doxygen comments
@
text
@d26 2
d53 1
a53 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.14 2006/07/09 18:25:31 brlcad Exp $ (ARL)";
@


14.14
log
@add additional error checking to make sure a -1 return value from read() is handled
@
text
@d22 1
a22 1
/** \addtogroup libbu */
a40 2
 *  Author -
 *	Michael John Muuss
d42 3
a44 1
 *  Source -
d46 1
a46 1
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
a48 1
/*@@}*/
d51 1
a51 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.13 2006/01/21 00:22:23 brlcad Exp $ (ARL)";
d91 1
a91 1
/*
d321 1
a321 1
/*
d351 1
a351 1
/*
d365 1
a365 1
/*
d424 1
a424 1
/*
d470 1
@


14.13
log
@cast the time_t to a long so we don't need to necessarily stash a time_t in the mappedfile structure any more
@
text
@d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.12 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d112 1
a112 1
	FILE			*fp;	/* stdio file pointer */
d208 1
a208 3
	mp->buf = mmap(
		(caddr_t)0, (size_t)sb.st_size, PROT_READ, MAP_PRIVATE,
		fd, (off_t)0 );
d211 1
a211 1
	if( mp->buf == MAP_FAILED )  perror(mp->name);
d220 1
a220 1
		mp->buf = bu_malloc( (size_t)sb.st_size, mp->name );
d227 5
a231 2
			perror("read");
			bu_free( mp->buf, mp->name );
d237 1
a237 1
	close(fd);
d257 1
a257 1
		char	buf[32768];
d269 1
a269 1
	mp->buf = bu_malloc( mp->buflen, mp->name );
@


14.12
log
@update copyright to 2006
@
text
@d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.11 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d145 1
a145 1
			if( sb.st_mtime != mp->modtime )  {
d203 1
a203 1
	mp->modtime = sb.st_mtime;
@


14.11
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.10 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.10
log
@Doxygen changes
@
text
@d43 1
a43 1
 *  
d47 1
a47 1
 *  
d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.9 2005/05/28 02:14:50 brlcad Exp $ (ARL)";
d435 1
a435 1
                   
@


14.10.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d43 1
a43 1
 *
d47 1
a47 1
 *
d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header$ (ARL)";
d435 1
a435 1

@


14.9
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d21 4
a25 1
 *
d49 2
d52 1
a52 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.8 2005/05/04 03:17:04 brlcad Exp $ (ARL)";
@


14.8
log
@cast stat size to a safe type for printing/saving in case off_t is a 64bit type in st_size
@
text
@d47 1
a47 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.7 2005/04/27 02:38:52 brlcad Exp $ (ARL)";
d238 1
a238 1
#if defined(WIN32) && !defined(__CYGWIN__)
@


14.7
log
@replace HAVE_SBRK_DECL with the HAVE_SBRK configure check name
@
text
@d47 1
a47 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.6 2005/01/30 20:30:46 brlcad Exp $ (ARL)";
a51 2


d56 1
a56 1
#include <unistd.h>
d59 1
a59 1
#include <string.h>
d61 1
a61 1
#include <strings.h>
d67 2
a68 2
# include <sys/types.h>
# include <sys/stat.h>
d72 2
a73 2
# include <sys/mman.h>
# if !defined(MAP_FAILED)
d75 1
a75 1
# endif
d80 1
d137 1
a137 1
					name, mp->buflen, sb.st_size );
d197 1
a197 1
	mp->buflen = sb.st_size;
@


14.6
log
@update copyright to 2005
@
text
@d47 1
a47 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/mappedfile.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
d113 2
a114 4
		bu_log("bu_open_mapped_file(%s, %s) sbrk=x%lx\n",
			name, appl?appl:"(NIL)",
#ifdef HAVE_SBRK_DECL
			(long)sbrk(0)
d116 1
a116 1
			0
a117 1
			);
d296 2
a297 5
		bu_log("bu_open_mapped_file() sbrk=x%lx\n",
#ifdef HAVE_SBRK_DECL
			(long)sbrk(0)
#else
			0
a298 1
			);
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d47 1
a47 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/mappedfile.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a44 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d47 1
a47 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/mappedfile.c,v 14.3 2004/12/21 05:45:21 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d49 1
a49 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/mappedfile.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d49 1
a49 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/mappedfile.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			M A P P E D F I L E . C
d49 1
a49 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/mappedfile.c,v 1.4 2004/09/03 23:30:57 morrison Exp $ (ARL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/mappedfile.c,v 1.3 2004/08/03 20:42:29 morrison Exp $ (ARL)";
d455 10
@


1.3
log
@apply Bob's provided patches from 20040630.  this includes itcl namespace scoping, windows DLL exporting, and wdb arb edit support
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/mappedfile.c,v 1.1 2004/05/20 15:19:34 morrison Exp $ (ARL)";
d43 1
a43 1
#ifdef USE_STRING_H
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@a88 2
#endif
	int			ret;
d90 1
a90 1
#ifndef HAVE_UNIX_IO
d93 1
d225 3
d229 1
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d30 1
a30 1
static const char libbu_mappedfile_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/mappedfile.c,v 1.29 2004/05/10 15:30:44 erikg Exp $ (ARL)";
d33 1
a33 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

