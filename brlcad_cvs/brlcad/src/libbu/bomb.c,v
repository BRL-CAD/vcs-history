head	14.31;
access;
symbols
	rel-7-10-4:14.26
	STABLE:14.26.0.2
	stable-branch:14.6
	rel-7-10-2:14.24
	rel-7-10-0:14.15
	rel-7-8-4:14.12
	rel-7-8-2:14.11
	rel-7-8-0:14.10
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.3
	rel-7-0-branch:1.3.0.2
	rel-7-0:1.3;
locks; strict;
comment	@ * @;


14.31
date	2007.12.31.17.44.24;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.11.14.06.57.37;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.10.22.01.02.58;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.10.22.00.58.04;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.09.15.16.23.08;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.08.30.19.14.52;	author erikgreenwald;	state Exp;
branches;
next	14.25;

14.25
date	2007.08.30.19.04.44;	author erikgreenwald;	state Exp;
branches;
next	14.24;

14.24
date	2007.07.10.18.35.54;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.06.03.01.09.49;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.05.26.14.26.47;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.05.16.04.07.03;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.05.13.08.22.53;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.05.12.22.23.04;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.05.12.04.29.49;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.05.12.04.28.29;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.05.12.01.06.45;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.31.05.50.24;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.06.01.22.37.27;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.02.27.07.17.12;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.45;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.28.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.31;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.31
log
@fix at least one race-condition problem with parallel crash report generation.  acquire a semaphore when printing into the tracefile filename and acquire the BU_SEM_SYSCALL semaphore when printing so we don't interleave with other printing that may be going on.  do the same when printing the intentional core dump message.
@
text
@/*                          B O M B . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup bu_log */
/** @@{ */
/** @@file ./libbu/bomb.c
 *
 *  The bu_bomb routine is called on a fatal error, generally where no
 *  recovery is possible.  Error handlers may, however, be registered
 *  with BU_SETJMP.  This routine intentionally limits calls to other
 *  functions and intentionally uses no stack variables.  Just in case
 *  the application is out of memory, bu_bomb deallocates a small
 *  buffer of memory.
 *
 *  @@par Functions -
 *    bu_bomb		Called during unexpected fatal errors.
 *    bu_exit		Causes termination of the application.
 *
 *  @@author -
 *    Michael John Muuss
 *    Christopher Sean Morrison
 */

#ifndef lint
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.30 2007/11/14 06:57:37 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdarg.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_UNIX_IO
#  include <fcntl.h>
#endif

#include "machine.h"
#include "bu.h"


struct bu_hook_list bu_bomb_hook_list = {
    {	BU_LIST_HEAD_MAGIC,
	&bu_bomb_hook_list.l,
	&bu_bomb_hook_list.l
    },
    BUHOOK_NULL,
    GENPTR_NULL
};


/*
 * These variables are global because BU_SETJUMP() *must* be a macro.
 * If you replace this version of bu_bomb() with one of your own,
 * you must also provide these variables, even if you don't use them.
 */
int		bu_setjmp_valid = 0;	/**< @@brief !0 = bu_jmpbuf is valid */
jmp_buf		bu_jmpbuf;		/**< @@brief for BU_SETJMP() */


/** failsafe storage to help ensure graceful shutdown */
static char *_bu_bomb_failsafe = NULL;

/* used for tty printing */
static int fd = -1;

/* used for crash reporting */
static char tracefile[512] = {0};

/* release memory on application exit */
static void
_free_bu_bomb_failsafe()
{
    if (_bu_bomb_failsafe) {
	free(_bu_bomb_failsafe);
	_bu_bomb_failsafe = NULL;
    }
}


int
bu_bomb_failsafe_init()
{
    if (_bu_bomb_failsafe) {
	return 1;
    }
    /* cannot use bu_*alloc here */
    _bu_bomb_failsafe = malloc(65536);
    atexit(_free_bu_bomb_failsafe);
    return 1;
}


/**
 *			B U _ B O M B
 *@@brief
 * Abort the program with a message.
 *
 * Only produce a core-dump when that debugging bit is set.  Note that
 * this function is meant to be a last resort graceful abort.  It
 * should not attempt to allocate anything on the stack or heap.
 *
 * This routine should never return unless there is a bu_setjmp
 * handler registered.
 */
void
bu_bomb(const char *str)
{

    /* First thing, always always always try to print the string.
     * Avoid passing additional format arguments so as to avoid
     * buffer allocations inside fprintf().
     */
    if (str && (strlen(str) > 0)) {
	fputc('\n', stderr);
	fputs(str, stderr);
	fputc('\n', stderr);
	fflush(stderr);
    }

    /* release the failsafe allocation to help get through to the end */
    _free_bu_bomb_failsafe();

    /* MGED would like to be able to additional logging, do callbacks. */
    if (BU_LIST_NON_EMPTY(&bu_bomb_hook_list.l)) {
	bu_call_hook(&bu_bomb_hook_list, (genptr_t)str);
    }

    if( bu_setjmp_valid )  {
	/* Application is catching fatal errors */
	if( bu_is_parallel() )  {
	    fprintf(stderr,"bu_bomb(): in parallel mode, could not longjmp up to application handler\n");
	} else {
	    /* Application is non-parallel, so this is safe */
	    longjmp( (void *)(bu_jmpbuf), 1 );
	    /* NOTREACHED */
	}
    }

#if defined(HAVE_UNIX_IO)
    /*
     * No application level error handling,
     * go to extra pains to ensure that user gets to see this message.
     * For example, mged hijacks output sent to stderr.
     */
    {
	fd = open("/dev/tty", 1);
	if (fd > 0) {
	    if (str && (strlen(str) > 0)) {
		write(fd, str, strlen(str));
		write(fd, "\n", 1);
	    }
	    close(fd);
	}
    }
#endif

#if defined(DEBUG)
    /* save a backtrace, should hopefully have debug symbols */
    {
	/* if the file already exists, there's probably another thread
	 * writing out a report for the current process. acquire a
	 * mapped file semaphore so we only have one thread writing to
	 * the file at a time (can't just use BU_SEM_SYSCALL).
	 */
	bu_semaphore_acquire( BU_SEM_MAPPEDFILE );
	snprintf(tracefile, 512, "%s-%d-bomb.log", bu_getprogname(), bu_process_id());
	if (!bu_file_exists(tracefile)) {
	    bu_semaphore_acquire( BU_SEM_SYSCALL );
	    fputs("Saving stack trace to ", stderr);
	    fputs(tracefile, stderr);
	    fputs(str, stderr);
	    fputs(str, stderr);
	    fputs(str, stderr);
	    fputc('\n', stderr);
	    fflush(stderr);
	    bu_semaphore_release( BU_SEM_SYSCALL );

	    bu_crashreport(tracefile);
	}
	bu_semaphore_release( BU_SEM_MAPPEDFILE );
    }
#endif

    /* If in parallel mode, try to signal the leader to die. */
    bu_kill_parallel();

    /* try to save a core dump */
    if( bu_debug & BU_DEBUG_COREDUMP )  {
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	fputs("Causing intentional core dump due to debug flag\n", stdout);
	fputs("Causing intentional core dump due to debug flag\n", stderr);
	fflush(stdout);
	fflush(stderr);
	bu_semaphore_release( BU_SEM_SYSCALL );

	fd = open("/dev/tty", 1);
	if (fd > 0) {
	    write(fd, "Causing intentional core dump due to debug flag\n", 48);
	    close(fd);
	}
	abort();	/* should dump if ulimit is non-zero */
    }

    exit(12);
}


/**
 * b u _ e x i t
 *
 * Semi-graceful termination of the application that doesn't cause a
 * stack trace, exiting with the specified status after printing the
 * given message.  It's okay for this routine to use the stack,
 * contrary to bu_bomb's behavior since it should be called for
 * expected termination situations.  This routine should never return.
 */
void
bu_exit(int status, const char *fmt, ...)
{
    va_list ap;
    struct bu_vls message;

    bu_vls_init(&message);

    if (fmt && strlen(fmt) > 0) {
	va_start(ap, fmt);
	bu_vls_vprintf(&message, fmt, ap);

	if (!BU_SETJUMP) {
	    bu_bomb(bu_vls_addr(&message));
	}
	BU_UNSETJUMP;
    }

    bu_vls_free(&message);

    exit(status);
}


/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.30
log
@semaphore protect the crash report being generated on bomb so that only one thread/process is writing out to the log file at a time.  only allow one of them to write to the file, depending on whether the log file for that process already exists.  we use BU_SEM_MAPPEDFILE since that really shouldn't be in use during bombing.
@
text
@d41 1
a41 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.29 2007/10/22 01:02:58 brlcad Exp $ (ARL)";
a181 2
	snprintf(tracefile, 512, "%s-%d-bomb.log", bu_getprogname(), bu_process_id());

d185 1
a185 1
	 * the file at a time (can't use BU_SEM_SYSCALL).
d188 1
d190 1
d193 3
d198 1
d211 1
d216 2
@


14.29
log
@stfu about the longjmp handler being taken.  the user doesn't care and the message is rather misleading.
@
text
@d41 1
a41 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.28 2007/10/22 00:58:04 brlcad Exp $ (ARL)";
d184 11
a194 4
	fputs("Saving stack trace to ", stderr);
	fputs(tracefile, stderr);
	fputc('\n', stderr);
	fflush(stderr);
d196 3
a198 1
	bu_crashreport(tracefile);
@


14.28
log
@add a new bu_exit() function that never returns.  this function differs from bu_bomb() in that it supports an error code and printf style arguments.  it should not be used for 'exceptional' exit conditions where stability and validity are in question; it should be used when you simply want to politely exit the application after printing a message (like printing application usage and exiting).
@
text
@d41 1
a41 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.27 2007/09/15 16:23:08 brlcad Exp $ (ARL)";
a155 1
	    fprintf(stderr,"bu_bomb(): taking longjmp up to application handler\n");
@


14.27
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d32 2
a33 1
 *    bu_bomb		Called upon fatal error.
d41 1
a41 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.26 2007/08/30 19:14:52 erikgreenwald Exp $ (ARL)";
d50 1
d118 1
a118 1
 *  Abort the program with a message.
d120 6
a125 3
 *  Only produce a core-dump when that debugging bit is set.  Note
 *  that this function is meant to be a last resort graceful abort.
 *  It should not attempt to allocate anything on the stack or heap.
d213 35
@


14.26
log
@typos.
@
text
@d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.25 2007/08/30 19:04:44 erikgreenwald Exp $ (ARL)";
d48 2
a52 3
#ifdef HAVE_STRING_H
#  include <string.h>
#endif
@


14.25
log
@change fprintf to fputs/fputc to further reduce allocation possibilities
@
text
@d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.24 2007/07/10 18:35:54 brlcad Exp $ (ARL)";
d182 2
a183 2
	fputs(racefile, stderr);
	fputc('\n', stderr, "\n");
@


14.24
log
@make sure the string we're trying to print isn't null or empty, don't write the stacktrace message to the tty.
@
text
@d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.23 2007/06/03 01:09:49 brlcad Exp $ (ARL)";
d132 3
a134 3
	fprintf(stderr, "\n");
	fprintf(stderr, str);
	fprintf(stderr, "\n");
d181 3
a183 3
	fprintf(stderr, "Saving stack trace to ");
	fprintf(stderr, tracefile);
	fprintf(stderr, "\n");
d195 2
a196 2
	fprintf(stdout,"Causing intentional core dump due to debug flag\n");
	fprintf(stderr,"Causing intentional core dump due to debug flag\n");
@


14.23
log
@add comment docs on bu_bomb usage and add name given extensive changes over time.
@
text
@d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.22 2007/05/26 14:26:47 brlcad Exp $ (ARL)";
d131 6
a136 4
    fprintf(stderr, "\n");
    fprintf(stderr, str);
    fprintf(stderr, "\n");
    fflush(stderr);
d167 4
a170 2
	    write(fd, str, strlen(str));
	    write(fd, "\n", 1);
a179 1
	fd = open("/dev/tty", 1);
a181 4
	if (fd > 0) {
	    write(fd, "Saving stack trace to ", 22);
	}

a182 4
	if (fd > 0) {
	    write(fd, tracefile, strlen(tracefile));
	}

d184 1
a184 4
	if (fd > 0) {
	    write(fd, "\n", 1);
	    close(fd);
	}
a185 1
	fflush(stderr);
@


14.22
log
@move the variables off the stack, making them static globals, just to be more safe.  Also, be more assertive about informing the user that a stack trace has been saved (since mged captures std output).
@
text
@d24 6
a29 2
 *  This routine is called on a fatal
 *  error, where no recovery is possible.
d32 1
a32 7
 *	bu_bomb		Called upon fatal error.
 *
 *  @@author	Michael John Muuss
 *
 *  @@par Source -
 *	The U. S. Army Research Laboratory			@@n
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
d34 3
d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.21 2007/05/16 04:07:03 brlcad Exp $ (ARL)";
@


14.21
log
@instead of just dumping the backtrace, dump a full crash report .. but only do this if DEBUG is defined so we have a better chance at having debug symbols in the stack trace.
@
text
@d39 1
a39 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.20 2007/05/13 08:22:53 brlcad Exp $ (ARL)";
d83 6
d162 2
a163 2
	int fd = open("/dev/tty", 1);
	if (fd) {
a173 2
	FILE *fp = NULL;
	char tracefile[512] = {0};
d175 2
d178 4
d183 4
d188 5
d207 5
@


14.20
log
@add a memory buffer failsafe to bu_bomb() that will release an allocation (64k) prior to performing the shutdown calls (some syscalls, some others may have tiny allocations of their own even for string/print processing).  this is of course down to give the app a tiny bit of breathing room so that hopefully there's enough room to shutdown cleanly.
@
text
@d39 1
a39 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.19 2007/05/12 22:23:04 brlcad Exp $ (ARL)";
d165 2
a166 1
    /* save a backtrace */
d171 3
a173 1
	fprintf(stderr, "Saving stack trace to %s\n", tracefile);
d175 1
a175 3
	fp = fopen(tracefile, "a");
	bu_backtrace(fp);
	(void)fclose(fp);
d177 1
d184 1
@


14.19
log
@use new bu_process_id() function to get the pid now
@
text
@d39 1
a39 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.18 2007/05/12 04:29:49 brlcad Exp $ (ARL)";
d80 27
d129 3
d158 2
a159 1
	    write( fd, str, strlen(str) );
@


14.18
log
@ws, stdc
@
text
@d39 1
a39 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.17 2007/05/12 04:28:29 brlcad Exp $ (ARL)";
d138 1
a138 1
	snprintf(tracefile, 512, "%s-%d-bomb.log", bu_getprogname(), getpid());
@


14.17
log
@Initial support for extracting a stack backtrace during run-time from the current execution environment.  Hooked into bu_bomb() for starters, which is just set up to write the backtrace out to a file for now.
@
text
@d39 1
a39 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.16 2007/05/12 01:06:45 brlcad Exp $ (ARL)";
d62 6
a67 6
	{	BU_LIST_HEAD_MAGIC,
		&bu_bomb_hook_list.l,
		&bu_bomb_hook_list.l
	},
	BUHOOK_NULL,
	GENPTR_NULL
d93 23
a115 28
	/* First thing, always always always try to print the string.
	 * Avoid passing additional format arguments so as to avoid
	 * buffer allocations inside fprintf().
	 */
	fprintf(stderr, "\n");
	fprintf(stderr, str);
	fprintf(stderr, "\n");
	fflush(stderr);

	/* MGED would like to be able to additional logging, do callbacks. */
	if (BU_LIST_NON_EMPTY(&bu_bomb_hook_list.l)) {
		bu_call_hook(&bu_bomb_hook_list, (genptr_t)str);
	}

	if( bu_setjmp_valid )  {
		/* Application is catching fatal errors */
		if( bu_is_parallel() )  {
			fprintf(stderr,"bu_bomb(): in parallel mode, could not longjmp up to application handler\n");
		} else {
			/* Application is non-parallel, so this is safe */
			fprintf(stderr,"bu_bomb(): taking longjmp up to application handler\n");
#if __STDC__
			longjmp( (void *)(bu_jmpbuf), 1 );
#else
			longjmp( (int *)(bu_jmpbuf), 1 );
#endif
			/* NOTREACHED */
		}
d117 1
d120 10
a129 11
	/*
	 * No application level error handling,
	 * go to extra pains to ensure that user gets to see this message.
	 * For example, mged hijacks output sent to stderr.
	 */
	{
		int fd = open("/dev/tty", 1);
		if (fd) {
			write( fd, str, strlen(str) );
			close(fd);
		}
d131 1
d134 22
a155 22
	/* save a backtrace */
	{
	    FILE *fp = NULL;
	    char tracefile[512] = {0};
	    snprintf(tracefile, 512, "%s-%d-bomb.log", bu_getprogname(), getpid());
	    fprintf(stderr, "Saving stack trace to %s\n", tracefile);
	    fflush(stderr);
	    fp = fopen(tracefile, "a");
	    bu_backtrace(fp);
	    (void)fclose(fp);
	}

	/* If in parallel mode, try to signal the leader to die. */
	bu_kill_parallel();

	/* try to save a core dump */
	if( bu_debug & BU_DEBUG_COREDUMP )  {
		fprintf(stderr,"Causing intentional core dump due to debug flag\n");
		fflush(stdout);
		fflush(stderr);
		abort();	/* should dump if ulimit is non-zero */
	}
d157 1
a157 1
	exit(12);
@


14.16
log
@stub out the backtrace section
@
text
@d39 1
a39 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.15 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d60 1
a60 1
#if 1
d69 1
a69 3
#else
struct bu_hook_list bu_bomb_hook_list;
#endif
d79 1
d130 1
a130 1
		int	fd = open("/dev/tty", 1);
a137 1
#if 0
d143 1
a143 1
	    fprintf(stderr, "bu_bomb saving stack trace to %s\n", tracefile);
a148 1
#endif
d155 1
a155 1
		fprintf(stderr,"bu_bomb causing intentional core dump due to debug flag\n");
@


14.15
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d39 1
a39 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.14 2007/01/21 04:45:41 brlcad Exp $ (ARL)";
d132 1
a132 1
		if( fd >= 0 )  {
d139 14
d156 1
@


14.14
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d39 1
a39 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.13 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.13
log
@update copyright to 2007
@
text
@d21 3
a23 4

/** \addtogroup bu_log */
/*@@{*/
/**  @@file ./libbu/bomb.c
d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.12 2006/08/31 05:50:24 lbutler Exp $ (ARL)";
d152 1
a152 1
/*@@}*/
@


14.12
log
@Mostly doxygen formatting.
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d41 1
a41 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.11 2006/06/01 22:37:27 brlcad Exp $ (ARL)";
@


14.11
log
@avoid passing additional format arguments to fprintf() to avoid potential buffer allocations. very nominal benefit, but can conceivably help with certain crashes and implementations of fprintf().
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d24 2
a25 1
/** @@file ./libbu/bomb.c
d29 1
a29 1
 *  Functions -
d32 1
a32 2
 *  Author -
 *	Michael John Muuss
d34 2
a35 2
 *  Source -
 *	The U. S. Army Research Laboratory
a38 1
/*@@}*/
d41 1
a41 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.10 2006/02/27 07:17:12 brlcad Exp $ (ARL)";
d80 2
a81 2
int		bu_setjmp_valid = 0;	/* !0 = bu_jmpbuf is valid */
jmp_buf		bu_jmpbuf;		/* for BU_SETJMP() */
d83 1
a83 1
/*
d85 1
a85 1
 *
d153 1
a153 1

@


14.10
log
@need stdlib.h for exit(), flush streams before abort.
@
text
@d42 1
a42 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d88 4
a91 1
 *  Only produce a core-dump when that debugging bit is set.
d97 7
a103 2
	/* First thing, always always always try to print the string */
	fprintf(stderr,"\n%s\n", str);
@


14.9
log
@update copyright to 2006
@
text
@d42 1
a42 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.8 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d47 1
a47 2


d51 1
a51 1
#include <unistd.h>
d54 4
a57 1
#include <string.h>
d59 1
a62 4
#ifdef HAVE_UNIX_IO
#include <fcntl.h>
#endif

d139 3
a141 1
		abort();	/* should dump */
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d42 1
a42 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.7 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.7
log
@Doxygen changes
@
text
@d33 1
a33 1
 *  
d37 1
a37 1
 *  
d42 1
a42 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.6 2005/01/30 20:30:45 brlcad Exp $ (ARL)";
d66 2
a67 2
	{	BU_LIST_HEAD_MAGIC, 
		&bu_bomb_hook_list.l, 
d69 1
a69 1
	}, 
d87 1
a87 1
 *  
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d33 1
a33 1
 *
d37 1
a37 1
 *
d42 1
a42 1
static const char RCSbomb[] = "@@(#)$Header$ (ARL)";
d66 2
a67 2
	{	BU_LIST_HEAD_MAGIC,
		&bu_bomb_hook_list.l,
d69 1
a69 1
	},
d87 1
a87 1
 *
@


14.6
log
@update copyright to 2005
@
text
@d21 4
a24 2
/** @@file bomb.c
 *
d39 2
d42 1
a42 1
static const char RCSbomb[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bomb.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d38 1
a38 1
static const char RCSbomb[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bomb.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a35 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d38 1
a38 1
static const char RCSbomb[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bomb.c,v 14.3 2004/12/21 05:45:20 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bomb.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bomb.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			B O M B . C
d40 1
a40 1
static const char RCSbomb[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bomb.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (ARL)";
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d21 1
a21 1
static const char RCSbomb[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bomb.c,v 1.2 2004/06/08 19:28:49 morrison Exp $ (ARL)";
d124 10
@


1.2
log
@poof goes the silly externs.h
@
text
@d21 1
a21 1
static const char RCSbomb[] = "@@(#)$Header$ (ARL)";
d24 1
a24 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d21 1
a21 1
static const char RCSbomb[] = "@@(#)$Header: /cvs/brlcad/libbu/bomb.c,v 1.21 2004/05/10 15:30:44 erikg Exp $ (ARL)";
a38 1
#include "externs.h"
@

