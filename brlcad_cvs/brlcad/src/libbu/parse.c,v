head	14.22;
access;
symbols
	rel-7-10-4:14.17
	STABLE:14.17.0.2
	stable-branch:14.6
	rel-7-10-2:14.17
	rel-7-10-0:14.17
	rel-7-8-4:14.13
	rel-7-8-2:14.11
	rel-7-8-0:14.11
	trimnurbs-branch:14.10.0.2
	help:14.10
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.22
date	2007.12.18.07.07.12;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.12.16.18.53.48;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2007.12.01.21.47.12;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2007.10.22.20.59.55;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.09.15.16.23.09;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.01.27.01.41.37;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.09.03.15.14.07;	author lbutler;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.31.23.16.38;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.03.24.22.08.27;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.02.27.07.42.49;	author brlcad;	state Exp;
branches
	14.10.2.1;
next	14.9;

14.9
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.46;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.38.20;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.15.22.48.33;	author butler;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.28.50;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.34;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.10.2.1
date	2006.04.07.19.30.15;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.22
log
@null-terminate strncat'd buffers for sanity sake since we don't usually check if we filled/truncated
@
text
@/*                         P A R S E . C
 * BRL-CAD
 *
 * Copyright (c) 1989-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup parse */
/** @@{ */
/** @@file ./libbu/parse.c
 *
 * @@brief routines for parsing arbitrary structures
 *
 *  Routines to assign values to elements of arbitrary structures.
 *  The layout of a structure to be processed is described by
 *  a structure of type "bu_structparse", giving element names, element
 *  formats, an offset from the beginning of the structure, and
 *  a pointer to an optional "hooked" function that is called whenever
 *  that structure element is changed.
 *
 *  @@par There are four basic operations supported:
 *  @@arg	print	struct elements to ASCII
 *  @@arg	parse	ASCII to struct elements
 *  @@arg	export	struct elements to machine-independent binary
 *  @@arg	import	machine-independent binary to struct elements
 *
 *
 *
 *  @@authors	Michael John Muuss
 *  @@authors	Lee A. Butler
 *
 *  @@par Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 * @@n	The U. S. Army Ballistic Research Laboratory
 * @@n	Aberdeen Proving Ground, Maryland  21005
 *
 */

#ifndef lint
static const char RCSparse[] = "@@(#)$Header$ (BRL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <string.h>

#include "machine.h"
#include "bu.h"


#define CKMEM( _len )	{  \
	register int	offset; \
	if( (offset = (ep - cp) - (_len)) < 0 )  { \
		do  { \
			offset += ext->ext_nbytes;	/* decr by new growth */ \
			ext->ext_nbytes <<= 1; \
		} while( offset < 0 ); \
		offset = cp - (char *)ext->ext_buf; \
		ext->ext_buf = (genptr_t)bu_realloc( (char *) ext->ext_buf, \
		     ext->ext_nbytes, "bu_struct_export" ); \
		ep = (char *) ext->ext_buf + ext->ext_nbytes; \
		cp = (char *) ext->ext_buf + offset; \
	} }

#define	BU_GETPUT_MAGIC_1	0x15cb
#define BU_GETPUT_MAGIC_2	0xbc51
#define BU_INIT_GETPUT_1(_p)	{ \
	BU_CK_EXTERNAL(_p); \
	((unsigned char *) _p->ext_buf)[1] = (BU_GETPUT_MAGIC_1 & 0xFF); \
	((unsigned char *) _p->ext_buf)[0] = (BU_GETPUT_MAGIC_1 >> 8) & 0xFF; \
	}
#define BU_INIT_GETPUT_2(_p,_l)	{\
	BU_CK_EXTERNAL(_p); \
	((unsigned char *) _p->ext_buf)[_l-1] = (BU_GETPUT_MAGIC_2 & 0xFF); \
	((unsigned char *) _p->ext_buf)[_l-2] = (BU_GETPUT_MAGIC_2 >> 8) & 0xFF; \
	}

#define	BU_CK_GETPUT(_p) {\
	register long _i; \
	register long _len; \
	BU_CK_EXTERNAL(_p); \
	if ( !(_p->ext_buf) ) { \
		bu_log("ERROR: BU_CK_GETPUT null ext_buf, file %s, line %d\n", \
		    __FILE__, __LINE__); \
		bu_bomb("NULL pointer"); \
	} \
	if ( _p->ext_nbytes < 6 ) { \
		bu_log("ERROR: BU_CK_GETPUT buffer only %d bytes, file %s, line %d\n", \
		    _p->ext_nbytes, __FILE__, __LINE__); \
		bu_bomb("getput buffer too small"); \
	} \
	_i = (((unsigned char *)(_p->ext_buf))[0] << 8) | \
	      ((unsigned char *)(_p->ext_buf))[1]; \
	if ( _i != BU_GETPUT_MAGIC_1)  { \
		bu_log("ERROR: BU_CK_GETPUT buffer x%x, magic1 s/b x%x, was %s(x%x), file %s, line %d\n", \
		    _p->ext_buf, BU_GETPUT_MAGIC_1, \
		    bu_identify_magic( _i), _i, __FILE__, __LINE__); \
		bu_bomb("Bad getput buffer"); \
	} \
	_len = (((unsigned char *)(_p->ext_buf))[2] << 24) | \
	       (((unsigned char *)(_p->ext_buf))[3] << 16) | \
	       (((unsigned char *)(_p->ext_buf))[4] <<  8) | \
		((unsigned char *)(_p->ext_buf))[5]; \
	if (_len > _p->ext_nbytes) { \
		bu_log("ERROR: BU_CK_GETPUT buffer x%x, expected len=%d, ext_nbytes=%d, file %s, line %d\n", \
		    _p->ext_buf, _len, _p->ext_nbytes, \
		    __FILE__, __LINE__); \
		bu_bomb("Bad getput buffer"); \
	} \
	_i = (((unsigned char *)(_p->ext_buf))[_len-2] << 8) | \
	      ((unsigned char *)(_p->ext_buf))[_len-1]; \
	if ( _i != BU_GETPUT_MAGIC_2) { \
		bu_log("ERROR: BU_CK_GETPUT buffer x%x, magic2 s/b x%x, was %s(x%x), file %s, line %d\n", \
		    _p->ext_buf, BU_GETPUT_MAGIC_2, \
		    bu_identify_magic( _i), _i, __FILE__, __LINE__); \
		bu_bomb("Bad getput buffer"); \
	} \
}

/**
 *			B U _ S T R U C T _ E X P O R T
 */
int
bu_struct_export(struct bu_external *ext, const genptr_t base, const struct bu_structparse *imp)
{
	register char	*cp;		/* current possition in buffer */
	char		*ep;		/* &ext->ext_buf[ext->ext_nbytes] */
	const struct bu_structparse *ip;	/* current imexport structure */
	char		*loc;		/* where host-format data is */
	int		len;
	register int	i;

	BU_INIT_EXTERNAL(ext);

	ext->ext_nbytes = 480;
	ext->ext_buf = (genptr_t)bu_malloc( ext->ext_nbytes,
	    "bu_struct_export output ext->ext_buf" );
	BU_INIT_GETPUT_1(ext);
	cp = (char *) ext->ext_buf + 6; /* skip magic and length */
	ep = cp + ext->ext_nbytes;

	for( ip = imp; ip->sp_fmt[0] != '\0'; ip++ )  {

		loc = ((char *)base) + ip->sp_offset;

		switch( ip->sp_fmt[0] )  {
		case 'i':
			/* Indirect to another structure */
			/* deferred */
			bu_free( (char *) ext->ext_buf, "output ext_buf" );
			return( 0 );
		case '%':
			/* See below */
			break;
		default:
			/* Unknown */
			bu_free( (char *) ext->ext_buf, "output ext_buf" );
			return( 0 );
		}
		/* [0] == '%', use printf-like format char */
		switch( ip->sp_fmt[1] )  {
		case 'f':
			/* Double-precision floating point */
			len = ip->sp_count * 8;
			CKMEM( len );
			htond( (unsigned char *)cp, (unsigned char *)loc, ip->sp_count );
			cp += len;
			continue;
		case 'd':
			/* 32-bit network integer, from "int" */
			CKMEM( ip->sp_count * 4 );
			{
				register unsigned long	l;
				for( i = ip->sp_count-1; i >= 0; i-- )  {
					l = *((int *)loc);
					cp[3] = l;
					cp[2] = l >> 8;
					cp[1] = l >> 16;
					cp[0] = l >> 24;
					loc += sizeof(int);
					cp += 4;
				}
			}
			continue;
		case 'i':
			/* 16-bit integer, from "int" */
			CKMEM( ip->sp_count * 2 );
			{
				register unsigned short	s;
				for( i = ip->sp_count-1; i >= 0; i-- )  {
					s = *((int *)loc);
					cp[1] = s;
					cp[0] = s >> 8;
					loc += sizeof(int); /* XXX */
					cp += 2;
				}
			}
			continue;
		case 's':
			{
				/* char array is transmitted as a
				 * 4 byte character count, followed by a
				 * null terminated, word padded char array.
				 * The count includes any pad bytes,
				 * but not the count itself.
				 *
				 * ip->sp_count == sizeof(char array)
				 */
				register int lenstr;

				/* include the terminating null */
				lenstr = strlen( loc ) + 1;

				len = lenstr;

				/* output an integer number of words */
				if ((len & 0x03) != 0)
					len += 4 - (len & 0x03);

				CKMEM( len + 4 );

				/* put the length on the front
				 * of the string
				 */
				cp[3] = len;
				cp[2] = len >> 8;
				cp[1] = len >> 16;
				cp[0] = len >> 24;

				cp += 4;

				memcpy(cp, loc, lenstr);
				cp += lenstr;
				while (lenstr++ < len) *cp++ = '\0';
			}
			continue;
		case 'c':
			{
				CKMEM( ip->sp_count + 4 );
				cp[3] = ip->sp_count;
				cp[2] = ip->sp_count >> 8;
				cp[1] = ip->sp_count >> 16;
				cp[0] = ip->sp_count >> 24;
				cp += 4;
				memcpy(cp, loc, ip->sp_count);
				cp += ip->sp_count;
			}
			continue;
		default:
			bu_free( (char *) ext->ext_buf, "output ext_buf" );
			return( 0 );
		}
	}
	CKMEM( 2);	/* get room for the trailing magic number */
	cp += 2;

	i = cp - (char *)ext->ext_buf;
	/* Fill in length in external buffer */
	((char *)ext->ext_buf)[5] = i;
	((char *)ext->ext_buf)[4] = i >> 8;
	((char *)ext->ext_buf)[3] = i >>16;
	((char *)ext->ext_buf)[2] = i >>24;
	BU_INIT_GETPUT_2(ext, i);
	ext->ext_nbytes = i;	/* XXX this changes nbytes if i < 480 ? */
	return( 1 );
}

/**
 *			B U _ S T R U C T _ I M P O R T
 */
int
bu_struct_import(genptr_t base, const struct bu_structparse *imp, const struct bu_external *ext)
{
	register const unsigned char	*cp;	/* current possition in buffer */
	const struct bu_structparse	*ip;	/* current imexport structure */
	char		*loc;		/* where host-format data is */
	int		len;
	int		bytes_used;
	register int	i;

	BU_CK_GETPUT(ext);

	cp = (unsigned char *)ext->ext_buf+6;
	bytes_used = 0;
	for( ip = imp; ip->sp_fmt[0] != '\0'; ip++ )  {

		loc = ((char *)base) + ip->sp_offset;

		switch( ip->sp_fmt[0] )  {
		case 'i':
			/* Indirect to another structure */
			/* deferred */
			return( -1 );
		case '%':
			/* See below */
			break;
		default:
			/* Unknown */
			return( -1 );
		}
		/* [0] == '%', use printf-like format char */
		switch( ip->sp_fmt[1] )  {
		case 'f':
			/* Double-precision floating point */
			len = ip->sp_count * 8;
			ntohd( (unsigned char *)loc, cp, ip->sp_count );
			cp += len;
			bytes_used += len;
			break;
		case 'd':
			/* 32-bit network integer, from "int" */
			{
				register long	l;
				for( i = ip->sp_count-1; i >= 0; i-- )  {
					l =	(cp[0] << 24) |
						(cp[1] << 16) |
						(cp[2] <<  8) |
						 cp[3];
					*(int *)loc = l;
					loc += sizeof(int); /* XXX */
					cp += 4;
				}
				bytes_used += ip->sp_count * 4;
			}
			break;
		case 'i':
			/* 16-bit integer, from "int" */
			for( i = ip->sp_count-1; i >= 0; i-- )  {
				*(int *)loc =	(cp[0] <<  8) |
						 cp[1];
				loc += sizeof(int); /* XXX */
				cp += 2;
			}
			bytes_used += ip->sp_count * 2;
			break;
		case 's':
			{	/* char array transmitted as a
				 * 4 byte character count, followed by a
				 * null terminated, word padded char array
				 *
				 * ip->sp_count == sizeof(char array)
				 */
				register unsigned long lenstr;

				lenstr = (cp[0] << 24) |
					 (cp[1] << 16) |
					 (cp[2] <<  8) |
					  cp[3];

				cp += 4;

				/* don't read more than the buffer can hold */
				if (ip->sp_count < lenstr)
					memcpy(loc, cp, ip->sp_count);
				else
					memcpy(loc, cp, lenstr);

				/* ensure proper null termination */
				loc[ip->sp_count-1] = '\0';

				cp += lenstr;
				bytes_used += lenstr;
			}
			break;
		case 'c':
			{
				register unsigned long lenarray;

				lenarray = (cp[0] << 24) |
					   (cp[1] << 16) |
					   (cp[2] <<  8) |
					    cp[3];
				cp += 4;

				if (ip->sp_count < lenarray) {
					memcpy(loc, cp, ip->sp_count);
				} else {
					memcpy(loc, cp, lenarray);
				}
				cp += lenarray;
				bytes_used += lenarray;
			}
			break;
		default:
			return( -1 );
		}
		if ( ip->sp_hook ) {

			ip->sp_hook (ip, ip->sp_name, base, (char *)NULL);
		}
	}

	/* This number may differ from that stored as "claimed_length" */
	return( bytes_used );
}

/**
 *			B U _ S T R U C T _ P U T
 *
 *  Put a structure in external form to a stdio file.
 *  All formatting must have been accomplished previously.
 */
int
bu_struct_put(FILE *fp, const struct bu_external *ext)
{
	BU_CK_GETPUT(ext);

	return(fwrite(ext->ext_buf, 1, ext->ext_nbytes, fp));
}

/**
 *			B U _ S T R U C T _ G E T
 *
 *  Obtain the next structure in external form from a stdio file.
 */
int
bu_struct_get(struct bu_external *ext, FILE *fp)
{
	register long i, len;

	BU_INIT_EXTERNAL(ext);
	ext->ext_buf = (genptr_t) bu_malloc( 6, "bu_struct_get buffer head");
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */

	i=fread( (char *) ext->ext_buf, 1, 6, fp);	/* res_syscall */
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */

	if (i != 6 ) {
		if (i == 0) return(0);
		bu_log("ERROR: bu_struct_get bad fread (%d), file %s, line %d\n",
		    i, __FILE__, __LINE__);
		bu_bomb("Bad fread");
	}
	i = (((unsigned char *)(ext->ext_buf))[0] << 8) |
	     ((unsigned char *)(ext->ext_buf))[1];
	len = (((unsigned char *)(ext->ext_buf))[2] << 24) |
	      (((unsigned char *)(ext->ext_buf))[3] << 16) |
	      (((unsigned char *)(ext->ext_buf))[4] <<  8) |
	       ((unsigned char *)(ext->ext_buf))[5];
	if ( i != BU_GETPUT_MAGIC_1) {
		bu_log("ERROR: bad getput buffer header x%x, s/b x%x, was %s(x%x), file %s, line %d\n",
		    ext->ext_buf, BU_GETPUT_MAGIC_1,
		    bu_identify_magic( i), i, __FILE__, __LINE__);
		bu_bomb("bad getput buffer");
	}
	ext->ext_nbytes = len;
	ext->ext_buf = (genptr_t) bu_realloc((char *) ext->ext_buf, len,
	    "bu_struct_get full buffer");
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	i=fread((char *) ext->ext_buf + 6, 1 , len-6, fp);	/* res_syscall */
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	if (i != len-6) {
		bu_log("ERROR: bu_struct_get bad fread (%d), file %s, line %d\n",
		    i, __FILE__, __LINE__);
		bu_bomb("Bad fread");
	}
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) |
	     ((unsigned char *)(ext->ext_buf))[len-1];
	if ( i != BU_GETPUT_MAGIC_2) {
		bu_log("ERROR: bad getput buffer x%x, s/b x%x, was %s(x%x), file %s, line %d\n",
		    ext->ext_buf, BU_GETPUT_MAGIC_2,
		    bu_identify_magic( i), i, __FILE__, __LINE__);
		bu_bomb("Bad getput buffer");
	}
	return(1);
}

/**
 *			B U _ S T R U C T _ B U F
 *
 *  Given a buffer with an external representation of a structure
 *  (e.g. the ext_buf portion of the output from bu_struct_export),
 *  check it for damage in shipment, and if it's OK,
 *  wrap it up in an bu_external structure, suitable for passing
 *  to bu_struct_import().
 */
void
bu_struct_wrap_buf(struct bu_external *ext, genptr_t buf)
{
	register long i, len;

	BU_INIT_EXTERNAL(ext);
	ext->ext_buf = buf;
	i = (((unsigned char *)(ext->ext_buf))[0] << 8) |
	     ((unsigned char *)(ext->ext_buf))[1];
	len = (((unsigned char *)(ext->ext_buf))[2] << 24) |
	      (((unsigned char *)(ext->ext_buf))[3] << 16) |
	      (((unsigned char *)(ext->ext_buf))[4] <<  8) |
	       ((unsigned char *)(ext->ext_buf))[5];
	if ( i != BU_GETPUT_MAGIC_1) {
		bu_log("ERROR: bad getput buffer header x%x, s/b x%x, was %s(x%x), file %s, line %d\n",
		    ext->ext_buf, BU_GETPUT_MAGIC_1,
		    bu_identify_magic( i), i, __FILE__, __LINE__);
		bu_bomb("bad getput buffer");
	}
	ext->ext_nbytes = len;
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) |
	     ((unsigned char *)(ext->ext_buf))[len-1];
	if ( i != BU_GETPUT_MAGIC_2) {
		bu_log("ERROR: bad getput buffer x%x, s/b x%x, was %s(x%x), file %s, line %s\n",
		    ext->ext_buf, BU_GETPUT_MAGIC_2,
		    bu_identify_magic( i), i, __FILE__, __LINE__);
		bu_bomb("Bad getput buffer");
	}
}


/**
 *			B U _ P A R S E _ D O U B L E
 *
 *  Parse an array of one or more doubles.
 *  Return value: 0 when successful
 *               <0 upon failure
 */
HIDDEN int
bu_parse_double(const char *str, long int count, double *loc)
{
	long	i;
	int	dot_seen;
	const char	*numstart;
	double	tmp_double;
	char	buf[128];
	int	len;

	for (i=0 ; i < count && *str ; ++i){
		numstart = str;

		/* skip sign */
		if (*str == '-' || *str == '+') str++;

		/* skip matissa */
		dot_seen = 0;
		for ( ; *str ; str++ ) {
			if (*str == '.' && !dot_seen) {
				dot_seen = 1;
				continue;
			}
			if (!isdigit(*str))
				break;

		}

		/* If no mantissa seen, then there is no float here */
		if (str == (numstart + dot_seen) )
			return -1;

		/* there was a mantissa, so we may have an exponent */
		if  (*str == 'E' || *str == 'e') {
			str++;

			/* skip exponent sign */
			if (*str == '+' || *str == '-') str++;

			while (isdigit(*str)) str++;
		}

		len = str - numstart;
		if( len > sizeof(buf)-1 )  len = sizeof(buf)-1;
		strncpy( buf, numstart, len );
		buf[len] = '\0';

		if( sscanf( buf, "%lf", &tmp_double ) != 1 )
			return -1;

		*loc++ = tmp_double;

		/* skip the separator */
		if (*str) str++;
	}
	return 0;
}

/**
 *			B U _ S T R U C T _ L O O K U P
 *
 *
 *  @@return     -2      parse error
 *  @@return	-1	not found
 *  @@return	 0	entry found and processed
 */
HIDDEN int
bu_struct_lookup(register const struct bu_structparse *sdp, register const char *name, const char *base, const char *const value)
						/* structure description */
						/* struct member name */
						/* begining of structure */
						/* string containing value */
{
	register char *loc;
	int i, retval = 0;

	for( ; sdp->sp_name != (char *)0; sdp++ )  {

		if( strcmp( sdp->sp_name, name ) != 0	/* no name match */
		    && sdp->sp_fmt[0] != 'i' )		/* no include desc */

		    continue;

		/* if we get this far, we've got a name match
		 * with a name in the structure description
		 */

		loc = (char *)(base + sdp->sp_offset);

		if (sdp->sp_fmt[0] == 'i') {
			/* Indirect to another structure */
			if( bu_struct_lookup(
				(struct bu_structparse *)sdp->sp_count,
				name, base, value )
			    == 0 )
				return(0);	/* found */
			else
				continue;
		}
		if (sdp->sp_fmt[0] != '%') {
			bu_log("bu_struct_lookup(%s): unknown format '%s'\n",
				name, sdp->sp_fmt );
			return(-1);
		}

		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			{	register int i, j;

				/* copy the string, converting escaped
				 * double quotes to just double quotes
				 */
				for(i=j=0 ;
				    j < sdp->sp_count && value[i] != '\0' ;
				    loc[j++] = value[i++])
					if (value[i] == '\\' &&
					    value[i+1] == '"')
						++i;

				/* Don't null terminate chars, only strings */
				if (sdp->sp_count > 1)  {
					/* OK, it's a string */
					if( j < sdp->sp_count-1 )
						loc[j] = '\0';
					else
						loc[sdp->sp_count-1] = '\0';
				}
			}
			break;
		case 'S':
			{	struct bu_vls *vls = (struct bu_vls *)loc;
				bu_vls_init_if_uninit( vls );
				bu_vls_strcpy(vls, value);
			}
			break;
		case 'i':
			{	register short *ip = (short *)loc;
				register short tmpi;
				register const char *cp;
				register const char *pv = value;

				for (i=0 ; i < sdp->sp_count && *pv ; ++i){
					tmpi = atoi( pv );

					cp = pv;
					if (*cp && (*cp == '+' || *cp == '-'))
						cp++;

					while (*cp && isdigit(*cp) )
						cp++;

					/* make sure we actually had an
					 * integer out there
					 */
					if (cp == pv ||
					    (cp == pv+1 &&
					    (*pv == '+' || *pv == '-'))){
					    retval = -2;
					    break;
					} else {
						*(ip++) = tmpi;
						pv = cp;
					}
					/* skip the separator */
					if (*pv) pv++;
				}
			}
			break;
		case 'd':
			{	register int *ip = (int *)loc;
				register int tmpi;
				register char const *cp;
				register const char *pv = value;

				/* Special case:  '=!' toggles a boolean */
				if( *pv == '!' )  {
					*ip = *ip ? 0 : 1;
					pv++;
					break;
				}
				/* Normal case: an integer */
				for (i=0 ; i < sdp->sp_count && *pv ; ++i){
					tmpi = atoi( pv );

					cp = pv;
					if (*cp && (*cp == '+' || *cp == '-'))
						cp++;

					while (*cp && isdigit(*cp) )
						cp++;

					/* make sure we actually had an
					 * integer out there
					 */
					if (cp == pv ||
					    (cp == pv+1 &&
					    (*pv == '+' || *pv == '-'))){
					    retval = -2;
					    break;
					} else {
						*(ip++) = tmpi;
						pv = cp;
					}
					/* skip the separator */
					if (*pv) pv++;
				}
			}
			break;
		case 'f':
			retval = bu_parse_double(value, sdp->sp_count,
						 (double *)loc);
			break;
		default:
			bu_log("bu_struct_lookup(%s): unknown format '%s'\n",
				name, sdp->sp_fmt );
			return(-1);
		}
		if( sdp->sp_hook )  {
			sdp->sp_hook( sdp, name, base, value );
		}
		return(retval);		/* OK or parse error */
	}
	return(-1);			/* Not found */
}

/**
 *			B U _ S T R U C T P A R S E
 *
 *	Parse the structure element description in the vls string "vls"
 *	according to the structure description in "parsetab"
 *
 *
 *  @@return	<0	failure
 *  @@return	 0	OK
 */
int
bu_struct_parse(const struct bu_vls *in_vls, const struct bu_structparse *desc, const char *base)
						/* string to parse through */
						/* structure description */
						/* base addr of users struct */
{
	struct bu_vls	vls;
	register char *cp;
	char	*name;
	char	*value;
	int retval;

	BU_CK_VLS(in_vls);
	if (desc == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return(-1);
	}

	/* Duplicate the input string.  This algorithm is destructive. */
	bu_vls_init( &vls );
	bu_vls_vlscat( &vls, in_vls );
	cp = bu_vls_addr( &vls );

	while( *cp )  {
		/* NAME = VALUE white-space-separator */

		/* skip any leading whitespace */
		while( *cp != '\0' && isascii(*cp) && isspace(*cp) )
			cp++;

		/* Find equal sign */
		name = cp;
		while ( *cp != '\0' && *cp != '=' )
			cp++;

		if( *cp == '\0' )  {
			if( name == cp ) break;

			/* end of string in middle of arg */
			bu_log("bu_structparse: input keyword '%s' is not followed by '=' in '%s'\nInput must be in keyword=value format.\n",
				name, bu_vls_addr(in_vls) );
			bu_vls_free( &vls );
			return(-2);
		}

		*cp++ = '\0';

		/* Find end of value. */
		if (*cp == '"')	{
			/* strings are double-quote (") delimited
			 * skip leading " & find terminating "
			 * while skipping escaped quotes (\")
			 */
			for (value = ++cp ; *cp != '\0' ; ++cp)
				if (*cp == '"' &&
				    (cp == value || *(cp-1) != '\\') )
					break;

			if (*cp != '"') {
				bu_log("bu_structparse: keyword '%s'=\" without closing \"\n",
					name);
				bu_vls_free( &vls );
				return(-3);
			}
		} else {
			/* non-strings are white-space delimited */
			value = cp;
			while( *cp != '\0' && isascii(*cp) && !isspace(*cp) )
				cp++;
		}

		if( *cp != '\0' )
			*cp++ = '\0';

		/* Lookup name in desc table and modify */
		retval = bu_struct_lookup( desc, name, base, value );
		if( retval == -1 ) {
		    bu_log("bu_structparse:  '%s=%s', keyword not found in:\n",
			   name, value);
		    bu_struct_print( "troublesome one", desc, base );
		} else if( retval == -2 ) {
		    bu_vls_free( &vls );
		    return -2;
		}

	}
	bu_vls_free( &vls );
	return(0);
}


/**
 *			B U _ M A T P R I N T
 *
 *	XXX Should this be here, or could it be with the matrix support?
 *	pretty-print a matrix
 */
HIDDEN void
bu_matprint(const char *name, register const double *mat)
{
	int	delta = strlen(name)+2;

	/* indent the body of the matrix */
	bu_log_indent_delta(delta);

	bu_log(" %s=%12E %12E %12E %12E\n",
		name, mat[0], mat[1], mat[2], mat[3]);

	bu_log("%12E %12E %12E %12E\n",
		mat[4], mat[5], mat[6], mat[7]);

	bu_log("%12E %12E %12E %12E\n",
		mat[8], mat[9], mat[10], mat[11]);

	bu_log_indent_delta(-delta);

	bu_log("%12E %12E %12E %12E\n",
		mat[12], mat[13], mat[14], mat[15]);
}

/**
 *
 */
HIDDEN void
bu_vls_matprint(struct bu_vls		*vls,
		const char		*name,
		register const double	*mat)
{
	int	delta = strlen(name)+2;

	/* indent the body of the matrix */
	bu_log_indent_delta(delta);

	bu_vls_printf(vls, " %s=%12E %12E %12E %12E\n",
		      name, mat[0], mat[1], mat[2], mat[3]);
	bu_log_indent_vls(vls);

	bu_vls_printf(vls, "%12E %12E %12E %12E\n",
		      mat[4], mat[5], mat[6], mat[7]);
	bu_log_indent_vls(vls);

	bu_vls_printf(vls, "%12E %12E %12E %12E\n",
		      mat[8], mat[9], mat[10], mat[11]);
	bu_log_indent_vls(vls);

	bu_log_indent_delta(-delta);

	bu_vls_printf(vls, "%12E %12E %12E %12E\n",
		      mat[12], mat[13], mat[14], mat[15]);
}

/**
 *
 *	Convert a structure element (indicated by sdp) to its ASCII
 *	representation in a VLS
 */
void
bu_vls_struct_item(struct bu_vls *vp, const struct bu_structparse *sdp, const char *base, int sep_char)

				     /* item description */
				  /* base address of users structure */
				 /* value separator */
{
    register char *loc;

    if (sdp == (struct bu_structparse *)NULL) {
	bu_log( "Null \"struct bu_structparse\" pointer\n");
	return;
    }

    loc = (char *)(base + sdp->sp_offset);

    if (sdp->sp_fmt[0] == 'i' )  {
	bu_log( "Cannot print type 'i' yet!\n" );
	return;
    }

    if ( sdp->sp_fmt[0] != '%')  {
	bu_log("bu_vls_struct_item:  %s: unknown format '%s'\n",
	       sdp->sp_name, sdp->sp_fmt );
	return;
    }

    switch( sdp->sp_fmt[1] )  {
    case 'c':
    case 's':
	if (sdp->sp_count < 1)
	    break;
	if (sdp->sp_count == 1)
	    bu_vls_printf( vp, "%c", *loc );
	else
	    bu_vls_printf( vp, "%s", (char *)loc );
	break;
    case 'S': {
	register struct bu_vls *vls = (struct bu_vls *)loc;

	bu_vls_vlscat( vp, vls ); }
	break;
    case 'i': {
	register int i = sdp->sp_count;
	register short *sp = (short *)loc;

	bu_vls_printf( vp, "%d", *sp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%d", sep_char, *sp++ ); }
	break;
    case 'd': {
	register int i = sdp->sp_count;
	register int *dp = (int *)loc;

	bu_vls_printf( vp, "%d", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%d", sep_char, *dp++ ); }
	break;
    case 'f': {
	register int i = sdp->sp_count;
	register double *dp = (double *)loc;

	bu_vls_printf( vp, "%.25G", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%.25G", sep_char, *dp++ ); }
	break;
    case 'x': {
	register int i = sdp->sp_count;
	register int *dp = (int *)loc;

	bu_vls_printf( vp, "%08x", *dp++ );
	while( --i > 0 ) bu_vls_printf( vp, "%c%08x", sep_char, *dp++ );  }
	break;
    default:
	break;
    }
}


/**
 *	B U _ V L S _ S T R U C T _ I T E M _ N A M E D
 *
 *	Convert a structure element called "name" to an ASCII representation
 *	in a VLS.
 */
int
bu_vls_struct_item_named(struct bu_vls *vp, const struct bu_structparse *parsetab, const char *name, const char *base, int sep_char)
{
    register const struct bu_structparse *sdp;

    for( sdp = parsetab; sdp->sp_name != NULL; sdp++ )
	if( strcmp(sdp->sp_name, name) == 0 ) {
	    bu_vls_struct_item( vp, sdp, base, sep_char );
	    return 0;
	}

    return -1;
}


/**
 *			B U _ S T R U C T P R I N T
 */
void
bu_struct_print(const char *title, const struct bu_structparse *parsetab, const char *base)

					  /* structure description */
					  /* base address of users structure */
{
	register const struct bu_structparse	*sdp;
	register char			*loc;
	register int			lastoff = -1;

	bu_log( "%s\n", title );
	if (parsetab == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return;
	}
	for( sdp = parsetab; sdp->sp_name != (char *)0; sdp++ )  {

		/* Skip alternate keywords for same value */
		if( lastoff == sdp->sp_offset )
			continue;
		lastoff = sdp->sp_offset;

		loc = (char *)(base + sdp->sp_offset);

		if (sdp->sp_fmt[0] == 'i' )  {
			bu_struct_print( sdp->sp_name,
				(struct bu_structparse *)sdp->sp_count,
				base );
			continue;
		}

		if ( sdp->sp_fmt[0] != '%')  {
			bu_log("bu_struct_print:  %s: unknown format '%s'\n",
				sdp->sp_name, sdp->sp_fmt );
			continue;
		}
#if 0
		bu_vls_trunc( &vls, 0 );
		bu_vls_struct_item( &vls, sdp, base, ',' );
		bu_log( " %s=%s\n", sdp->sp_name, bu_vls_addr(&vls) );
#else
		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1)
				bu_log( " %s='%c'\n", sdp->sp_name, *loc);
			else
				bu_log( " %s=\"%s\"\n", sdp->sp_name,
					(char *)loc );
			break;
		case 'S':
			{
				int delta = strlen(sdp->sp_name)+2;
				register struct bu_vls *vls =
					(struct bu_vls *)loc;

				bu_log_indent_delta(delta);
				bu_log(" %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
					sdp->sp_name, vls->vls_magic,
					vls->vls_offset,
					vls->vls_len, vls->vls_max);
				bu_log_indent_delta(-delta);
				bu_log("\"%s\"\n", vls->vls_str+vls->vls_offset);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;

				bu_log( " %s=%d", sdp->sp_name, *sp++ );

				while (--i > 0) bu_log( ",%d", *sp++ );

				bu_log("\n");
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%d", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%d", *dp++ );

				bu_log("\n");
			}
			break;
		case 'f':
			{	register int i = sdp->sp_count;
				register double *dp = (double *)loc;

				if (sdp->sp_count == 16) {
					bu_matprint(sdp->sp_name, dp);
				} else if (sdp->sp_count <= 3){
					bu_log( " %s=%.25G", sdp->sp_name, *dp++ );

					while (--i > 0)
						bu_log( ",%.25G", *dp++ );

					bu_log("\n");
				}else  {
					int delta = strlen(sdp->sp_name)+2;

					bu_log_indent_delta(delta);

					bu_log( " %s=%.25G\n", sdp->sp_name, *dp++ );

					while (--i > 1)
						bu_log( "%.25G\n", *dp++ );

					bu_log_indent_delta(-delta);
					bu_log( "%.25G\n", *dp );
				}
			}
			break;
		case 'x':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_log( " %s=%08x", sdp->sp_name, *dp++ );

				while (--i > 0) bu_log( ",%08x", *dp++ );

				bu_log("\n");
			}
			break;
		default:
			bu_log( " bu_struct_print: Unknown format: %s=%s??\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}
#endif
	}
}

/**
 *			B U _ V L S _ P R I N T _ D O U B L E
 */
HIDDEN void
bu_vls_print_double(struct bu_vls *vls, const char *name, register long int count, register const double *dp)
{
	register int tmpi;
	register char *cp;

	int increase = strlen(name) + 3 + 32 * count;
	bu_vls_extend(vls, increase);

	cp = vls->vls_str + vls->vls_offset + vls->vls_len;
	snprintf(cp, increase, "%s%s=%.27G", (vls->vls_len?" ":""), name, *dp++);
	tmpi = strlen(cp);
	vls->vls_len += tmpi;

	while (--count > 0) {
		cp += tmpi;
		sprintf(cp, ",%.27G", *dp++);
		tmpi = strlen(cp);
		vls->vls_len += tmpi;
	}
}

/**
 *			B U _ V L S _ S T R U C T P R I N T
 *
 *	This differs from bu_struct_print in that this output is less readable
 *	by humans, but easier to parse with the computer.
 */
void
bu_vls_struct_print(struct bu_vls *vls, register const struct bu_structparse *sdp, const char *base)
						/* vls to print into */
						/* structure description */
						/* structure ponter */
{
	register char			*loc;
	register int			lastoff = -1;
	register char			*cp;
	int increase;

	BU_CK_VLS(vls);

	if (sdp == (struct bu_structparse *)NULL) {
		bu_log( "Null \"struct bu_structparse\" pointer\n");
		return;
	}

	for ( ; sdp->sp_name != (char*)NULL ; sdp++) {
		/* Skip alternate keywords for same value */

		if( lastoff == sdp->sp_offset )
			continue;
		lastoff = sdp->sp_offset;

		loc = (char *)(base + sdp->sp_offset);

		if (sdp->sp_fmt[0] == 'i')  {
			struct bu_vls sub_str;

			bu_vls_init(&sub_str);
			bu_vls_struct_print( &sub_str,
				(struct bu_structparse *)sdp->sp_count,
				base );

			bu_vls_vlscat(vls, &sub_str);
			bu_vls_free( &sub_str );
			continue;
		}

		if ( sdp->sp_fmt[0] != '%' )  {
			bu_log("bu_struct_print:  %s: unknown format '%s'\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}

		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1) {
			        increase = strlen(sdp->sp_name)+6;
				bu_vls_extend(vls, increase);
				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				if (*loc == '"')
					snprintf(cp, increase, "%s%s=\"%s\"",
						(vls->vls_len?" ":""),
						sdp->sp_name, "\\\"");
				else
					snprintf(cp, increase, "%s%s=\"%c\"",
						(vls->vls_len?" ":""),
						sdp->sp_name,
						*loc);
			} else {
				register char *p;
				register int count=0;

				/* count the quote characters */
				p = loc;
				while ((p=strchr(p, '"')) != (char *)NULL) {
					++p;
					++count;
				}
				increase = strlen(sdp->sp_name)+strlen(loc)+5+count;
				bu_vls_extend(vls, increase);

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				if (vls->vls_len) (void)strcat(cp, " ");
				(void)strncat(cp, sdp->sp_name, increase-1);
				(void)strncat(cp, "=\"", increase-strlen(sdp->sp_name)-1);
				cp[vls->vls_offset + vls->vls_len - 1] = '\0';

				/* copy the string, escaping all the internal
				 * double quote (") characters
				 */
				p = &cp[strlen(cp)];
				while (*loc) {
					if (*loc == '"') {
						*p++ = '\\';
					}
					*p++ = *loc++;
				}
				*p++ = '"';
				*p = '\0';
			}
			vls->vls_len += strlen(cp);
			break;
		case 'S':
			{	
			    register struct bu_vls *vls_p = (struct bu_vls *)loc;
			    
			    increase =  bu_vls_strlen(vls_p) + 5 + strlen(sdp->sp_name);
			    bu_vls_extend(vls, increase);

			    cp = vls->vls_str + vls->vls_offset + vls->vls_len;
			    snprintf(cp, increase, "%s%s=\"%s\"",
					(vls->vls_len?" ":""),
					sdp->sp_name,
					bu_vls_addr(vls_p) );
			    vls->vls_len += strlen(cp);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;
				register int tmpi;

				increase = 64 * i + strlen(sdp->sp_name) + 3;
				bu_vls_extend(vls, increase);
					

				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				snprintf(cp, increase, "%s%s=%d",
						(vls->vls_len?" ":""),
						 sdp->sp_name, *sp++);
				tmpi = strlen(cp);
				vls->vls_len += tmpi;

				while (--i > 0) {
					cp += tmpi;
					sprintf(cp, ",%d", *sp++);
					tmpi = strlen(cp);
					vls->vls_len += tmpi;
				}
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;
				register int tmpi;

				increase = 64 * i + strlen(sdp->sp_name) + 3;
				bu_vls_extend(vls, increase);
					
				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				snprintf(cp, increase, "%s%s=%d",
					(vls->vls_len?" ":""),
					sdp->sp_name, *dp++);
				tmpi = strlen(cp);
				vls->vls_len += tmpi;

				while (--i > 0) {
					cp += tmpi;
					sprintf(cp, ",%d", *dp++);
					tmpi = strlen(cp);
					vls->vls_len += tmpi;
				}
			}
			break;
		case 'f':
			bu_vls_print_double(vls, sdp->sp_name, sdp->sp_count,
				(double *)loc);
			break;
		default:
			bu_log( " %s=%s??\n", sdp->sp_name, sdp->sp_fmt );
			bu_bomb("unexpected case encountered in bu_vls_struct_print\n");
			break;
		}
	}
}


/**
 *			B U _ V L S _ S T R U C T P R I N T 2
 *
 *	This differs from bu_struct_print in that it prints to a vls.
 */
void
bu_vls_struct_print2(struct bu_vls			*vls_out,
		     const char				*title,
		     const struct bu_structparse	*parsetab,	/* structure description */
		     const char				*base)	  	/* base address of users structure */
{
	register const struct bu_structparse	*sdp;
	register char			*loc;
	register int			lastoff = -1;

	bu_vls_printf(vls_out, "%s\n", title);
	if (parsetab == (struct bu_structparse *)NULL) {
		bu_vls_printf(vls_out, "Null \"struct bu_structparse\" pointer\n");
		return;
	}

	for (sdp = parsetab; sdp->sp_name != (char *)0; sdp++) {

		/* Skip alternate keywords for same value */
		if (lastoff == sdp->sp_offset)
			continue;
		lastoff = sdp->sp_offset;

		loc = (char *)(base + sdp->sp_offset);

		if (sdp->sp_fmt[0] == 'i' )  {
			bu_vls_struct_print2(vls_out, sdp->sp_name,
					     (struct bu_structparse *)sdp->sp_count,
					     base);
			continue;
		}

		if (sdp->sp_fmt[0] != '%') {
			bu_vls_printf(vls_out, "bu_vls_struct_print:  %s: unknown format '%s'\n",
			       sdp->sp_name, sdp->sp_fmt );
			continue;
		}

		switch( sdp->sp_fmt[1] )  {
		case 'c':
		case 's':
			if (sdp->sp_count < 1)
				break;
			if (sdp->sp_count == 1)
				bu_vls_printf(vls_out, " %s='%c'\n", sdp->sp_name, *loc);
			else
				bu_vls_printf(vls_out, " %s=\"%s\"\n", sdp->sp_name,
					(char *)loc );
			break;
		case 'S':
			{
				int delta = strlen(sdp->sp_name)+2;
				register struct bu_vls *vls =
					(struct bu_vls *)loc;

				bu_log_indent_delta(delta);
				bu_vls_printf(vls_out, " %s=(vls_magic)%ld (vls_offset)%d (vls_len)%d (vls_max)%d\n",
					sdp->sp_name, vls->vls_magic,
					vls->vls_offset,
					vls->vls_len, vls->vls_max);
				bu_log_indent_vls(vls_out);
				bu_log_indent_delta(-delta);
				bu_vls_printf(vls_out, "\"%s\"\n", vls->vls_str+vls->vls_offset);
			}
			break;
		case 'i':
			{	register int i = sdp->sp_count;
				register short *sp = (short *)loc;

				bu_vls_printf(vls_out, " %s=%d", sdp->sp_name, *sp++ );

				while (--i > 0)
					bu_vls_printf(vls_out, ",%d", *sp++ );

				bu_vls_printf(vls_out, "\n");
			}
			break;
		case 'd':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_vls_printf(vls_out, " %s=%d", sdp->sp_name, *dp++ );

				while (--i > 0)
					bu_vls_printf(vls_out, ",%d", *dp++ );

				bu_vls_printf(vls_out, "\n");
			}
			break;
		case 'f':
			{	register int i = sdp->sp_count;
				register double *dp = (double *)loc;

				if (sdp->sp_count == 16) {
					bu_vls_matprint(vls_out, sdp->sp_name, dp);
				} else if (sdp->sp_count <= 3){
					bu_vls_printf(vls_out, " %s=%.25G", sdp->sp_name, *dp++ );

					while (--i > 0)
						bu_vls_printf(vls_out, ",%.25G", *dp++ );

					bu_vls_printf(vls_out, "\n");
				}else  {
					int delta = strlen(sdp->sp_name)+2;

					bu_log_indent_delta(delta);
					bu_vls_printf(vls_out, " %s=%.25G\n", sdp->sp_name, *dp++ );
					bu_log_indent_vls(vls_out);

					while (--i > 1) {
						bu_vls_printf(vls_out, "%.25G\n", *dp++ );
						bu_log_indent_vls(vls_out);
					}

					bu_log_indent_delta(-delta);
					bu_vls_printf(vls_out, "%.25G\n", *dp );
				}
			}
			break;
		case 'x':
			{	register int i = sdp->sp_count;
				register int *dp = (int *)loc;

				bu_vls_printf(vls_out, " %s=%08x", sdp->sp_name, *dp++ );

				while (--i > 0)
					bu_vls_printf(vls_out, ",%08x", *dp++ );

				bu_vls_printf(vls_out, "\n");
			}
			break;
		default:
			bu_vls_printf(vls_out, " bu_vls_struct_print2: Unknown format: %s=%s??\n",
				sdp->sp_name, sdp->sp_fmt );
			break;
		}
	}
}


/**
 * This allows us to specify the "size" parameter as values like ".5m"
 * or "27in" rather than using mm all the time.
 */
void
bu_parse_mm(register const struct bu_structparse *sdp, register const char *name, char *base, const char *value)
						/* structure description */
						/* struct member name */
						/* begining of structure */
						/* string containing value */
{
	double *p = (double *)(base+sdp->sp_offset);

	/* reconvert with optional units */
	*p = bu_mm_value(value);
}

#define STATE_UNKNOWN		0
#define STATE_IN_KEYWORD	1
#define STATE_IN_VALUE		2
#define STATE_IN_QUOTED_VALUE	3

/**
 *
 */
int
bu_key_eq_to_key_val(char *in, char **next, struct bu_vls *vls)
{
	char *iptr=in;
	char *start;
	int state=STATE_IN_KEYWORD;

	BU_CK_VLS( vls );

	*next = NULL;

	while ( *iptr )
	{
		char *prev='\0';

		switch( state )
		{
			case STATE_IN_KEYWORD:
				/* skip leading white space */
				while( isspace( *iptr ) )
					iptr++;

				if( !(*iptr) )
					break;

				if( *iptr == ';' )
				{
					/* found end of a stack element */
					*next = iptr+1;
					return( 0 );
				}

				/* copy keyword up to '=' */
				start = iptr;
				while( *iptr && *iptr != '=' )
					iptr++;

				bu_vls_strncat( vls, start, iptr - start );

				/* add a single space after keyword */
				bu_vls_putc( vls, ' ' );

				if( !*iptr )
					break;

				/* skip over '=' in input */
				iptr++;

				/* switch to value state */
				state = STATE_IN_VALUE;

				break;
			case STATE_IN_VALUE:
				/* skip excess white space */
				while( isspace( *iptr ) )
					iptr++;

				/* check for quoted value */
				if( *iptr == '"' )
				{
					/* switch to quoted value state */
					state = STATE_IN_QUOTED_VALUE;

					/* skip over '"' */
					iptr++;

					break;
				}

				/* copy value up to next white space or end of string */
				start = iptr;
				while( *iptr && *iptr != ';' && !isspace( *iptr ) )
					iptr++;

				bu_vls_strncat( vls, start, iptr - start );

				if( *iptr ) /* more to come */
				{
					bu_vls_putc( vls, ' ' );

					/* switch back to keyword state */
					state = STATE_IN_KEYWORD;
				}

				break;
			case STATE_IN_QUOTED_VALUE:
				/* copy byte-for-byte to end quote (watch out for escaped quote)
				 * replace quotes with '{' '}' */

				bu_vls_strcat( vls, " {" );
				while( 1 )
				{
					if( *iptr == '"' && *prev != '\\' )
					{
						bu_vls_putc( vls, '}' );
						iptr++;
						break;
					}
					bu_vls_putc( vls, *iptr );
					prev = iptr++;
				}

				if( *iptr && *iptr != ';' ) /* more to come */
					bu_vls_putc( vls, ' ' );

				/* switch back to keyword state */
				state = STATE_IN_KEYWORD;

				break;
		}
	}
	return( 0 );
}

/**
 *			B U _ S H A D E R _ T O _ T C L _ L I S T
 *
 *  Take an old v4 shader specification of the form
 *
 *	shadername arg1=value1 arg2=value2 color=1/2/3
 *
 *  and convert it into the v5 Tcl-list form
 *
 *	shadername {arg1 value1 arg2 value2 color 1/2/3}
 *
 *  Note -- the input string is smashed with nulls.
 *
 *  Note -- the v5 version is used everywhere internally, and in v5
 *  databases.
 *
 *
 *  @@return	1	error
 *  @@return	0	OK
 */
int
bu_shader_to_tcl_list(char *in, struct bu_vls *vls)
{
	char *iptr;
	char *next=in;
	char *shader;
	int shader_name_len=0;
	int is_stack=0;
	int len;


	BU_CK_VLS( vls );

	while( next )
	{
		iptr = next;

		/* skip over white space */
		while( isspace( *iptr ) )
			iptr++;

		/* this is start of shader name */
		shader = iptr;

		/* find end of shader name */
		while( *iptr && !isspace( *iptr ) && *iptr != ';' )
			iptr++;
		shader_name_len = iptr - shader;

		if( !strncmp( shader, "stack", 5 ) )
		{
			/* stack shader, loop through all shaders in stack */
			int done=0;

			bu_vls_strcat( vls, "stack {" );

			while( !done )
			{
				char *shade1;

				while( isspace( *iptr ) )
					iptr++;
				if( *iptr == '\0' )
					break;
				shade1 = iptr;
				while( *iptr && *iptr != ';' )
					iptr++;
				if( *iptr == '\0' )
					done = 1;
				*iptr = '\0';

				bu_vls_putc( vls, '{' );

				if( bu_shader_to_tcl_list( shade1, vls ) )
					return( 1 );

				bu_vls_strcat( vls, "} " );

				if( !done )
					iptr++;
			}
			bu_vls_putc( vls, '}' );
			return( 0 );
		}
		else if( !strncmp( shader, "envmap", 6 ) )
		{
			bu_vls_strcat( vls, "envmap {" );
			if( bu_shader_to_tcl_list( iptr, vls ) )
				return( 1 );
			bu_vls_putc( vls, '}' );
			return( 0 );
		}

		if( is_stack )
			bu_vls_strcat( vls, " {" );

		bu_vls_strncat( vls, shader, shader_name_len );

		/* skip more white space */
		while( *iptr && isspace( *iptr ) )
			iptr++;

		/* iptr now points at start of parameters, if any */
		if( *iptr && *iptr != ';' )
		{
			bu_vls_strcat( vls, " {" );
			len = bu_vls_strlen( vls );
			if( bu_key_eq_to_key_val( iptr, &next, vls ) )
				return( 1 );
			if( bu_vls_strlen( vls ) > len )
				bu_vls_putc( vls, '}' );
			else
				bu_vls_trunc( vls, len-2 );
		}
		else if( *iptr && *iptr == ';' )
			next = ++iptr;
		else
			next = (char *)NULL;

		if( is_stack )
			bu_vls_putc( vls, '}' );
	}

	if( is_stack )
		bu_vls_putc( vls, '}' );

	return( 0 );
}

/**
 *			B U _ L I S T _ E L E M
 *
 *  Given a Tcl list, return a copy of the 'index'th entry,
 *  which may itself be a list.
 *
 *
 *  Note -- the caller is responsible for freeing the returned string.
 */
char *
bu_list_elem( const char *in, int index )
{
	int depth=0;
	int count=0;
	int len=0;
	const char *ptr=in;
	const char *prev=NULL;
	const char *start=NULL;
	const char *end=NULL;
	char *out=NULL;

	while( *ptr )
	{
		/* skip leading white space */
		while( *ptr && isspace( *ptr ) )
		{
			prev = ptr;
			ptr++;
		}

		if( !*ptr )
			break;

		if( depth == 0 && count == index )
			start = ptr;

		if( *ptr == '{' )
		{
			depth++;
			prev = ptr;
			ptr++;
		}
		else if( *ptr == '}' )
		{
			depth--;
			if( depth == 0 )
				count++;
			if( start && depth == 0 )
			{
				end = ptr;
				break;
			}
			prev = ptr;
			ptr++;
		}
		else
		{
			while( *ptr &&
				(!isspace( *ptr ) || *prev == '\\') &&
				(*ptr != '}' || *prev == '\\') &&
				(*ptr != '{' || *prev == '\\') )
			{
				prev = ptr;
				ptr++;
			}
			if( depth == 0 )
				count++;

			if( start && depth == 0 )
			{
				end = ptr-1;
				break;
			}
		}
	}

	if( !start )
		return( (char *)NULL );

	if( *start == '{' )
	{
		if( !end || *end != '}' )
		{
			bu_log( "Error in list (uneven braces?): %s\n", in );
			return( (char *)NULL );
		}

		/* remove enclosing braces */
		start++;
		while( start < end && isspace( *start ) )
			start++;

		end--;
		while( end > start && isspace( *end ) && *(end-1) != '\\' )
			end--;

		if( start == end )
			return( (char *)NULL );
	}

	len = end - start + 1;
	out = bu_malloc( len+1, "bu_list_elem:out" );
	strncpy( out, start, len );
	*(out + len) = '\0';

	return( out );
}

/**
 *			B U _ T C L _ L I S T _ L E N G T H
 *
 *  Return number of items in a string, interpreted as a Tcl list.
 */
int
bu_tcl_list_length( const char *in )
{
	int count=0;
	int depth=0;
	const char *ptr=in;
	const char *prev=NULL;

	while( *ptr )
	{
		/* skip leading white space */
		while( *ptr && isspace( *ptr ) )
		{
			prev = ptr;
			ptr++;
		}

		if( !*ptr )
			break;

		if( *ptr == '{' )
		{
			if( depth == 0 )
				count++;
			depth++;
			prev = ptr;
			ptr++;
		}
		else if( *ptr == '}' )
		{
			depth--;
			prev = ptr;
			ptr++;
		}
		else
		{
			if( depth == 0 )
				count++;

			while( *ptr &&
				(!isspace( *ptr ) || *prev == '\\') &&
				(*ptr != '}' || *prev == '\\') &&
				(*ptr != '{' || *prev == '\\') )
			{
				prev = ptr;
				ptr++;
			}
		}
	}

	return( count );
}

/**
 *
 */
int
bu_key_val_to_vls(struct bu_vls *vls, char *params)
{
	int len;
	int j;

	len = bu_tcl_list_length( params );

	if( len == 1 )
	{
		bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, params );
		return( 0 );
	}

	if( len%2 )
	{
		bu_log( "bu_key_val_to_vls: Error: shader parameters must be even numbered!!\n\t%s\n", params );
		return( 1 );
	}

	for( j=0 ; j<len ; j += 2 )
	{
		char *keyword;
		char *value;

		keyword = bu_list_elem( params, j );
		value = bu_list_elem( params, j+1 );

		bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, keyword );
		bu_vls_putc( vls, '=' );
		if( bu_tcl_list_length( value ) > 1  )
		{
			bu_vls_putc( vls, '"' );
			bu_vls_strcat( vls, value );
			bu_vls_putc( vls, '"' );
		}
		else
			bu_vls_strcat( vls, value );

		bu_free( keyword, "bu_key_val_to_vls() keyword");
		bu_free( value, "bu_key_val_to_vls() value");

	}
	return( 0 );
}

/**
 *			B U _ S H A D E R _ T O _ K E Y _ E Q
 */
int
bu_shader_to_key_eq(char *in, struct bu_vls *vls)
{
	int len;
	int ret=0;
	char *shader;
	char *params;

	BU_CK_VLS( vls );

	len = bu_tcl_list_length( in );

	if( len == 0 )
		return( 0 );

	if( len == 1 )
	{
		/* shader with no parameters */
		if( bu_vls_strlen( vls ) )
			bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, in );
		return( 0 );
	}

	if( len != 2 )
	{
		bu_log( "bu_shader_to_key_eq: Error: shader must have two elements (not %d)!!\n\t%s\n", len, in );
		return 1;
	}

	shader = bu_list_elem( in, 0 );
	params = bu_list_elem( in, 1 );

	if( !strcmp( shader, "envmap" ) )
	{
		/* environment map */

		if( bu_vls_strlen( vls ) )
			bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, "envmap" );

		bu_shader_to_key_eq( params, vls );
	}
	else if( !strcmp( shader, "stack" ) )
	{
		/* stacked shaders */

		int i;

		if( bu_vls_strlen( vls ) )
			bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, "stack" );

		/* get number of shaders in the stack */
		len = bu_tcl_list_length( params );

		/* process each shader in the stack */
		for( i=0 ; i<len ; i++ )
		{
			char *shader1;

			/* each parameter must be a shader specification in itself */
			shader1 = bu_list_elem( params, i );

			if( i > 0 )
				bu_vls_putc( vls, ';' );
			bu_shader_to_key_eq( shader1, vls );
			bu_free( shader1, "shader1" );
		}
	}
	else
	{
		if( bu_vls_strlen( vls ) )
			bu_vls_putc( vls, ' ' );
		bu_vls_strcat( vls, shader );
		ret = bu_key_val_to_vls( vls, params );
	}

	bu_free( shader, "shader" );
	bu_free( params, "params" );

	return( ret );
}

/**
 *
 *			B U _ F W R I T E _ E X T E R N A L
 *
 *  Take a block of memory, and write it into a file.
 *
 *  Caller is responsible for freeing memory of external representation,
 *  using bu_free_external().
 *
 *
 *  @@return	<0	error
 *  @@return	0	OK
 */
int
bu_fwrite_external( FILE *fp, const struct bu_external *ep )
{
	size_t	got;

	BU_CK_EXTERNAL(ep);

	if( (got = fwrite( ep->ext_buf, 1, ep->ext_nbytes, fp )) != ep->ext_nbytes )  {
		perror("fwrite");
		bu_log("bu_fwrite_external() attempted to write %ld, got %ld\n", (long)ep->ext_nbytes, (long)got );
		return -1;
	}
	return 0;
}

/**
 *			B U _ H E X D U M P _ E X T E R N A L
 */
void
bu_hexdump_external( FILE *fp, const struct bu_external *ep, const char *str)
{
	const unsigned char	*cp;
	const unsigned char	*endp;
	int i, j, k;

	BU_CK_EXTERNAL(ep);

	fprintf(fp, "%s:\n", str);
	if( ep->ext_nbytes <= 0 )  fprintf(fp, "\tWarning: 0 length external buffer\n");

	cp = ep->ext_buf;
	endp = cp + ep->ext_nbytes;
	for( i=0; i < ep->ext_nbytes; i += 16 )  {
		const unsigned char	*sp = cp;

		for( j=0; j < 4; j++ )  {
			for( k=0; k < 4; k++ )  {
				if( cp >= endp )
					fprintf(fp, "   ");
				else
					fprintf(fp, "%2.2x ", *cp++ );
			}
			fprintf(fp, " ");
		}
		fprintf(fp, " |");

		for( j=0; j < 16; j++,sp++ )  {
			if( sp >= endp )  break;
			if( isprint(*sp) )
				putc(*sp, fp);
			else
				putc('.', fp);
		}

		fprintf(fp, "|\n");
	}
}

/**
 *			B U _ F R E E _ E X T E R N A L
 */
void
bu_free_external( register struct bu_external *ep)
{
	BU_CK_EXTERNAL(ep);
	if( ep->ext_buf )  {
		bu_free( ep->ext_buf, "bu_external ext_buf" );
		ep->ext_buf = GENPTR_NULL;
	}
}

/**
 *			B U _ C O P Y _ E X T E R N A L
 */
void
bu_copy_external(struct bu_external *op, const struct bu_external *ip)
{
	BU_CK_EXTERNAL(ip);
	BU_INIT_EXTERNAL(op);

	if( op == ip )  return;

	op->ext_nbytes = ip->ext_nbytes;
	op->ext_buf = bu_malloc( ip->ext_nbytes, "bu_copy_external" );
	memcpy(op->ext_buf, ip->ext_buf, ip->ext_nbytes);
}

/**
 *			B U _ N E X T _ T O K E N
 *
 *  Advance pointer through string over current token,
 *  across white space, to beginning of next token.
 */
char *
bu_next_token( char *str )
{
  char *ret;

  ret = str;
  while( !isspace( *ret ) && *ret !='\0' )
    ret++;
  while( isspace( *ret ) )
    ret++;

  return( ret );
}
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.21
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@d52 1
a52 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.20 2007/12/01 21:47:12 brlcad Exp $ (BRL)";
d1272 1
@


14.20
log
@more flawfinder level 4 quellage, mostly str*() buffer boundary limits.
@
text
@d52 1
a52 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.19 2007/10/22 20:59:55 brlcad Exp $ (BRL)";
d248 1
a248 1
				bcopy( loc, cp, lenstr );
d261 1
a261 1
				bcopy( loc, cp, ip->sp_count);
d370 1
a370 1
					bcopy( cp, loc, ip->sp_count);
d372 1
a372 1
					bcopy( cp, loc, lenstr );
d392 1
a392 1
					bcopy( cp, loc, ip->sp_count);
d394 1
a394 1
					bcopy( cp, loc, lenarray );
d2177 1
a2177 1
	bcopy( ip->ext_buf, op->ext_buf, ip->ext_nbytes );
@


14.19
log
@the old cray cos and unicos code for the cray xmp and friends finally became a burden to maintain while resolving various flawfinder issues.  remove the old code, particularly that which wasn't __STDC__.  however, intentionally leave the code for calculating byteoffsets and converting float formats to/from network order .. could still come in handy at some point down the road.
@
text
@d52 1
a52 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.18 2007/09/15 16:23:09 brlcad Exp $ (BRL)";
d1169 2
a1170 1
	bu_vls_extend(vls, strlen(name) + 3 + 32 * count);
d1173 1
a1173 1
	sprintf(cp, "%s%s=%.27G", (vls->vls_len?" ":""), name, *dp++);
d1200 1
d1243 2
a1244 1
				bu_vls_extend(vls, strlen(sdp->sp_name)+6);
d1247 1
a1247 1
					sprintf(cp, "%s%s=\"%s\"",
d1251 1
a1251 1
					sprintf(cp, "%s%s=\"%c\"",
d1265 2
a1266 2
				bu_vls_extend(vls, strlen(sdp->sp_name)+
					strlen(loc)+5+count);
d1270 2
a1271 2
				(void)strcat(cp, sdp->sp_name);
				(void)strcat(cp, "=\"");
d1289 5
a1293 5
			{	register struct bu_vls *vls_p =
					(struct bu_vls *)loc;

				bu_vls_extend(vls, bu_vls_strlen(vls_p) + 5 +
					strlen(sdp->sp_name) );
d1295 2
a1296 2
				cp = vls->vls_str + vls->vls_offset + vls->vls_len;
				sprintf(cp, "%s%s=\"%s\"",
d1300 1
a1300 1
				vls->vls_len += strlen(cp);
d1308 3
a1310 2
				bu_vls_extend(vls,
					64 * i + strlen(sdp->sp_name) + 3 );
d1313 1
a1313 1
				sprintf(cp, "%s%s=%d",
d1332 3
a1334 3
				bu_vls_extend(vls,
					64 * i + strlen(sdp->sp_name) + 3 );

d1336 1
a1336 1
				sprintf(cp, "%s%s=%d",
@


14.18
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d52 1
a52 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.17 2007/01/27 01:41:37 brlcad Exp $ (BRL)";
a159 3
#if CRAY && !__STDC__
		loc = ((char *)base) + ((int)ip->sp_offset*sizeof(int));
#else
a160 1
#endif
a302 3
#if CRAY && !__STDC__
		loc = ((char *)base) + ((int)ip->sp_offset*sizeof(int));
#else
a303 1
#endif
a617 3
#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
a618 1
#endif
a936 3
#if CRAY && !__STDC__
    loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
a937 1
#endif
a1044 3
#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
a1045 1
#endif
a1213 3
#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
a1214 1
#endif
a1386 3
#if CRAY && !__STDC__
		loc = (char *)(base + ((int)sdp->sp_offset*sizeof(int)));
#else
a1387 1
#endif
@


14.17
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d52 1
a52 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.16 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
d61 1
a61 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d52 1
a52 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.15 2007/01/21 04:45:42 brlcad Exp $ (BRL)";
a535 8








d580 1
a580 1
		    	if (*str == '+' || *str == '-') str++;
d611 4
a614 4
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          			       	      	/* string containing value */
d665 1
a665 1
					    	++i;
d785 3
a787 3
                   		        	/* string to parse through */
                           	      		/* structure description */
    				      		/* base addr of users struct */
d942 3
a944 3
                                     /* item description */
                                  /* base address of users structure */
                                 /* value separator */
a1018 1

d1046 2
a1047 2
                           	          /* structure description */
          			      	  /* base address of users structure */
d1216 3
a1218 3
      	      				     	/* vls to print into */
                                    	     	/* structure description */
          				      	/* structure ponter */
d1542 4
a1545 4
                                    	     	/* structure description */
                   			      	/* struct member name */
    					      	/* begining of structure */
          				       	/* string containing value */
@


14.15
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d52 1
a52 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.14 2007/01/20 14:36:51 brlcad Exp $ (BRL)";
@


14.14
log
@update copyright to 2007
@
text
@d21 2
a22 4

/** \addtogroup parse */
/*@@{*/

d53 1
a53 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.13 2006/09/03 15:14:07 lbutler Exp $ (BRL)";
d2237 1
a2237 1
/*@@}*/
@


14.13
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2006 United States Government as represented by
d55 1
a55 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.12 2006/08/31 23:16:38 lbutler Exp $ (BRL)";
@


14.12
log
@Doxygen comments
@
text
@d26 3
d55 1
a55 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.11 2006/03/24 22:08:27 brlcad Exp $ (BRL)";
@


14.11
log
@quell intel 9 compiler on altix warnings
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d33 5
a37 5
 *  There are four basic operations supported:
 *	print	struct elements to ASCII
 *	parse	ASCII to struct elements
 *	export	struct elements to machine-independent binary
 *	import	machine-independent binary to struct elements
a39 3
 *  Authors -
 *	Michael John Muuss
 *	Lee A. Butler
d41 4
a44 1
 *  Source -
d46 2
a47 2
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005
a49 1
/*@@}*/
d52 1
a52 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.10 2006/02/27 07:42:49 brlcad Exp $ (BRL)";
d140 1
a140 1
/*
d292 1
a292 1
/*
d425 1
a425 1
/*
d439 1
a439 1
/*
d496 1
a496 1
/*
d544 1
a544 1
/*
d609 1
a609 1
/*
d612 4
a615 4
 *  Returns -
 *      -2      parse error
 *	-1	not found
 *	 0	entry found and processed
d781 1
a781 1
/*
d787 3
a789 3
 *  Returns -
 *	<0	failure
 *	 0	OK
d882 1
a882 1
/*
d911 3
d942 1
a942 1
/*
d1028 1
a1028 1
/*
d1049 1
a1049 1
/*
d1193 1
a1193 1
/*
d1217 1
a1217 1
/*
d1396 1
a1396 1
/*
d1545 2
a1546 1
/* This allows us to specify the "size" parameter as values like ".5m"
d1567 3
d1684 1
a1684 1
/*
d1700 3
a1702 3
 *  Returns -
 *	1	error
 *	0	OK
d1813 1
a1813 1
/*
d1921 1
a1921 1
/*
d1979 3
d2030 1
a2030 1
/*
d2117 1
a2117 1
/*
d2126 3
a2128 3
 *  Returns -
 *	<0	error
 *	0	OK
d2145 1
a2145 1
/*
d2188 1
a2188 1
/*
d2201 1
a2201 1
/*
d2217 1
a2217 1
/*
d2236 1
a2236 1

@


14.10
log
@quell warnings, need stdlib.h for exit routines
@
text
@d53 1
a53 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
d1459 1
a1459 1
				bu_vls_printf(vls_out, " %s=(vls_magic)%d (vls_offset)%d (vls_len)%d (vls_max)%d\n",
@


14.10.2.1
log
@update from HEAD
@
text
@d53 1
a53 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.10 2006/02/27 07:42:49 brlcad Exp $ (BRL)";
d1459 1
a1459 1
				bu_vls_printf(vls_out, " %s=(vls_magic)%ld (vls_offset)%d (vls_len)%d (vls_max)%d\n",
@


14.9
log
@update copyright to 2006
@
text
@d53 1
a53 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.8 2005/10/23 04:44:32 brlcad Exp $ (BRL)";
d58 1
a58 2


d63 1
a63 1
# include <string.h>
d65 1
a65 1
# include <strings.h>
d1387 1
a1387 1
			abort();
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1989-2005 United States Government as represented by
d53 1
a53 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.7 2005/08/12 22:29:23 lbutler Exp $ (BRL)";
@


14.7
log
@Doxygen changes
@
text
@d48 1
a48 1
 *  
d53 1
a53 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.6 2005/01/30 20:30:46 brlcad Exp $ (BRL)";
d141 1
a141 1
	
d197 1
a197 1
			CKMEM( ip->sp_count * 4 ); 
d308 1
a308 1
	
d366 1
a366 1
		case 's': 
d487 1
a487 1
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) | 
d527 1
a527 1
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) | 
d560 1
a560 1
	char	buf[128];	
d578 1
a578 1
			
d707 1
a707 1
						cp++; 
d747 1
a747 1
						cp++; 
d900 1
a900 1
					
d942 1
a942 1
 *	
d948 1
a948 1
                  
d1053 1
a1053 1
          			       
d1286 1
a1286 1
						sdp->sp_name, 
d1289 1
a1289 1
				register char *p; 
d1341 1
a1341 1
				bu_vls_extend(vls, 
d1364 1
a1364 1
				bu_vls_extend(vls, 
d1368 1
a1368 1
				sprintf(cp, "%s%s=%d", 
d1401 1
a1401 1
bu_vls_struct_print2(struct bu_vls			*vls_out,     
d2089 1
a2089 1
			if( i > 0 ) 
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d48 1
a48 1
 *
d53 1
a53 1
static const char RCSparse[] = "@@(#)$Header$ (BRL)";
d141 1
a141 1

d197 1
a197 1
			CKMEM( ip->sp_count * 4 );
d308 1
a308 1

d366 1
a366 1
		case 's':
d487 1
a487 1
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) |
d527 1
a527 1
	i = (((unsigned char *)(ext->ext_buf))[len-2] <<8) |
d560 1
a560 1
	char	buf[128];
d578 1
a578 1

d707 1
a707 1
						cp++;
d747 1
a747 1
						cp++;
d900 1
a900 1

d942 1
a942 1
 *
d948 1
a948 1

d1053 1
a1053 1

d1286 1
a1286 1
						sdp->sp_name,
d1289 1
a1289 1
				register char *p;
d1341 1
a1341 1
				bu_vls_extend(vls,
d1364 1
a1364 1
				bu_vls_extend(vls,
d1368 1
a1368 1
				sprintf(cp, "%s%s=%d",
d1401 1
a1401 1
bu_vls_struct_print2(struct bu_vls			*vls_out,
d2089 1
a2089 1
			if( i > 0 )
@


14.6
log
@update copyright to 2005
@
text
@d21 5
a25 2
/** @@file parse.c
 *
d50 2
d53 1
a53 1
static const char RCSparse[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/parse.c,v 14.5 2004/12/21 06:38:20 morrison Exp $ (BRL)";
@


14.5
log
@remove the old copyright notice section
@
text
@d4 1
a4 1
 * Copyright (c) 1989-2004 United States Government as represented by
d48 1
a48 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parse.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a45 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1989-2004 by the United States Army.
 *	All rights reserved.
d48 1
a48 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parse.c,v 14.3 2004/12/21 05:45:21 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d51 1
a51 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parse.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d51 1
a51 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parse.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			P A R S E . C
d51 1
a51 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parse.c,v 1.5 2004/10/15 22:48:33 butler Exp $ (BRL)";
@


1.5
log
@There several more locations where we were adding "base + (int)sdp->sp_offset"
This doesn't work on the Athlon systems.
The more correct code (and now ubiquitous) is "base + sdp->sp_offset"
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parse.c,v 1.4 2004/09/03 23:30:57 morrison Exp $ (BRL)";
d2207 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parse.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
d148 1
a148 1
		loc = ((char *)base) + ((int)ip->sp_offset);
d295 1
a295 1
		loc = ((char *)base) + ((int)ip->sp_offset);
d622 1
a622 1
		loc = (char *)(base + ((int)sdp->sp_offset));
d942 1
a942 1
    loc = (char *)(base + ((int)sdp->sp_offset));
d1055 1
a1055 1
		loc = (char *)(base + ((int)sdp->sp_offset));
d1228 1
a1228 1
		loc = (char *)(base + ((int)sdp->sp_offset));
d1405 1
a1405 1
		loc = (char *)(base + ((int)sdp->sp_offset));
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/src/libbu/parse.c,v 1.2 2004/06/08 19:28:50 morrison Exp $ (BRL)";
d42 1
a42 1
#ifdef USE_STRING_H
@


1.2
log
@poof goes the silly externs.h
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header$ (BRL)";
d35 1
a35 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d32 1
a32 1
static const char RCSparse[] = "@@(#)$Header: /cvs/brlcad/libbu/parse.c,v 1.51 2004/05/10 15:30:44 erikg Exp $ (BRL)";
a50 1
#include "externs.h"
@

