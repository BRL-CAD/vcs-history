head	14.19;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.6
	rel-7-10-2:14.16
	rel-7-10-0:14.16
	rel-7-8-4:14.12
	rel-7-8-2:14.10
	rel-7-8-0:14.10
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.19
date	2007.12.16.16.05.14;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2007.10.22.21.06.48;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2007.09.15.16.23.08;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.01.23.01.13.33;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.17.19.36.49;	author erikgreenwald;	state Exp;
branches;
next	14.12;

14.12
date	2006.08.31.05.50.24;	author lbutler;	state Exp;
branches;
next	14.11;

14.11
date	2006.06.22.13.58.35;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.03.24.19.53.51;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches
	14.9.2.1;
next	14.8;

14.8
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.45;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.28.49;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.31;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.9.2.1
date	2006.04.07.19.30.15;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.19
log
@few multiline bzero to memset stragglers
@
text
@/*                          B I T V . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup bitv */
/** @@{ */
/** @@file bitv.c
 *
 * @@brief
 *  Routines for managing bit vectors of arbitrary length.
 *
 *  The basic type "bitv_t" is defined in h/machine.h; it is the
 *  widest integer datatype for which efficient hardware support exists.
 *  BITV_SHIFT and BITV_MASK are also defined in machine.h
 *
 *  These bit vectors are "little endian", bit 0 is in the right hand
 *  side of the [0] word.
 *
 *  @@author Michael John Muuss
 *
 *  @@par Source -
 *	The U. S. Army Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 *
 */

#ifndef lint
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.18 2007/10/22 21:06:48 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "machine.h"
#include "bu.h"

/**
 *			B U _ B I T V _ N E W
 * @@brief
 *  Allocate storage for a new bit vector of at least 'nbits' in length.
 *  For efficiency, the bit vector itself is not initialized.
 */
struct bu_bitv *
bu_bitv_new(unsigned int nbits)
{
    struct bu_bitv	*bv;
    int		bv_bytes;
    int		total_bytes;

    bv_bytes = BU_BITS2BYTES(nbits);
    total_bytes = sizeof(struct bu_bitv) - 2*sizeof(bitv_t) + bv_bytes;

    bv = (struct bu_bitv *)bu_malloc( (size_t)total_bytes, "struct bu_bitv" );
    BU_LIST_INIT( &bv->l );
    bv->l.magic = BU_BITV_MAGIC;
    bv->nbits = bv_bytes * 8;
    return bv;
}

/**
 *			B U _ B I T V _ F R E E
 * @@brief
 *  Release all internal storage for this bit vector.
 *
 *  It is the caller's responsibility to not use the pointer 'bv' any longer.
 *  It is the caller's responsibility to dequeue from any linked list first.
 */
void
bu_bitv_free(struct bu_bitv *bv)
{
    BU_CK_BITV(bv);

    bv->l.forw = bv->l.back = BU_LIST_NULL;	/* sanity */
    bu_free( (char *)bv, "struct bu_bitv" );
}

/**
 *			B U _ B I T V _ C L E A R
 * @@brief
 *  Set all the bits in the bit vector to zero.
 *
 *  Also available as a macro if you don't desire the pointer checking.
 */
void
bu_bitv_clear(struct bu_bitv *bv)
{
    BU_CK_BITV(bv);

    BU_BITV_ZEROALL(bv);
}

/**
 *			B U _ B I T V _ O R
 */
void
bu_bitv_or(struct bu_bitv *ov, const struct bu_bitv *iv)
{
    register bitv_t		*out;
    register const bitv_t	*in;
    register int		words;

    if( ov->nbits != iv->nbits )  bu_bomb("bu_bitv_or: length mis-match");
    out = ov->bits;
    in = iv->bits;
    words = BU_BITS2WORDS(iv->nbits);
#ifdef VECTORIZE
    for( --words; words >= 0; words-- )
	out[words] |= in[words];
#else
    while( words-- > 0 )
	*out++ |= *in++;
#endif
}

/*
 *			B U _ B I T V _ A N D
 */
void
bu_bitv_and(struct bu_bitv *ov, const struct bu_bitv *iv)
{
    register bitv_t		*out;
    register const bitv_t	*in;
    register int		words;

    if( ov->nbits != iv->nbits )  bu_bomb("bu_bitv_and: length mis-match");
    out = ov->bits;
    in = iv->bits;
    words = BU_BITS2WORDS(iv->nbits);
#ifdef VECTORIZE
    for( --words; words >= 0; words-- )
	out[words] &= in[words];
#else
    while( words-- > 0 )
	*out++ &= *in++;
#endif
}

/**
 *			B U _ B I T V _ V L S
 * @@brief
 *  Print the bits set in a bit vector.
 */
void
bu_bitv_vls(struct bu_vls *v, register const struct bu_bitv *bv)
{
    int		seen = 0;
    register int	i;
    int		len;

    BU_CK_VLS( v );
    BU_CK_BITV( bv );

    len = bv->nbits;

    bu_vls_strcat( v, "(" );

    /* Visit all the bits in ascending order */
    for( i=0; i<len; i++ )  {
	if( BU_BITTEST(bv, i) == 0 )  continue;
	if( seen )  bu_vls_strcat( v, ", " );
	bu_vls_printf( v, "%d", i );
	seen = 1;
    }
    bu_vls_strcat( v, ") " );
}

/**
 *			B U _ P R _ B I T V
 * @@brief
 *  Print the bits set in a bit vector.
 *  Use bu_vls stuff, to make only a single call to bu_log().
 */
void
bu_pr_bitv(const char *str, register const struct bu_bitv *bv)
{
    struct bu_vls	v;

    BU_CK_BITV(bv)
	bu_vls_init( &v );
    bu_vls_strcat( &v, str );
    bu_vls_strcat( &v, ": " );
    bu_bitv_vls( &v, bv );
    bu_log("%s", bu_vls_addr( &v ) );
    bu_vls_free( &v );
}

/**
 *			B U _ B I T V _ T O _ H E X
 * @@brief
 *	Convert a bit vector to an ascii string of hex digits.
 *	The string is from MSB to LSB (bytes and bits).
 */
void
bu_bitv_to_hex(struct bu_vls *v, register const struct bu_bitv *bv)
{
    unsigned int word_count, byte_no;

    BU_CK_VLS( v );
    BU_CK_BITV( bv );

    word_count = bv->nbits/8/sizeof( bitv_t );
    byte_no = sizeof( bitv_t );

    bu_vls_extend( v, word_count * (unsigned int)sizeof( bitv_t ) * 2 + 1 );
    while( word_count-- )
	{
	    while( byte_no-- )
		{
		    bu_vls_printf( v, "%02lx",
				   ((bv->bits[word_count] & (((bitv_t)0xff)<<(byte_no*8))) >> (byte_no*8)) & (bitv_t)0xff );
		}
	    byte_no = sizeof( bitv_t );
	}
}

/**
 *			B U _ H E X _ T O _ B I T V
 * @@brief
 *	Convert a string of HEX digits (as produces by bu_bitv_to_hex) into a bit vector.
 */
struct bu_bitv *
bu_hex_to_bitv(const char *str)
{
    char abyte[3];
    const char *str_start;
    unsigned int len=0;
    int bytes;
    struct bu_bitv *bv;
    unsigned long c;
    int word_count, byte_no;

    abyte[2] = '\0';

    /* skip over any initial white space */
    while( isspace( *str ) )
	str++;

    str_start = str;
    /* count hex digits */
    while( isxdigit( *str ) )
	str++;

    len = str - str_start;

    if( len < 2 || len%2 )
	{
	    /* Must be two digits per byte */
	    bu_log( "bu_hex_to_bitv: illegal hex bitv (%s)\n", str_start );
	    return( (struct bu_bitv *)NULL );
	}

    bytes = len / 2; /* two hex digits per byte */
    bv = bu_bitv_new( len * 4 ); /* 4 bits per hex digit */
    bu_bitv_clear( bv );
    word_count = bytes/sizeof( bitv_t );
    byte_no = bytes % sizeof( bitv_t );
    if( !byte_no )
	byte_no = sizeof( bitv_t );
    else
	word_count++;

    str = str_start;
    while( word_count-- )
	{
	    while( byte_no-- )
		{
		    /* get next two hex digits from string */
		    abyte[0] = *str++;
		    abyte[1] = *str++;

		    /* convert into an unsigned long */
		    c = strtoul( abyte, (char **)NULL, 16 );

		    /* set the appropriate bits in the bit vector */
		    bv->bits[word_count] |= (bitv_t)c<<(byte_no*8);
		}
	    byte_no = sizeof( bitv_t );
	}

    return( bv );
}

/**
 *			B U _ B I T V _ D U P
 * @@brief
 *	Make a copy of a bit vector
 */
struct bu_bitv *
bu_bitv_dup(register const struct bu_bitv *bv)
{
    struct bu_bitv *bv2;

    bv2 = bu_bitv_new( bv->nbits );
    bu_bitv_clear( bv2 );
    bu_bitv_or( bv2, bv );

    return( bv2 );
}
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.18
log
@removed the non-ansi/stc compliant noalias.h and noalias-prag.h headers that were used with the cray (and alliant) to make pragma decls before loops.  made obsolete long ago with the move to ansi compliance.
@
text
@d43 1
a43 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.17 2007/09/15 16:23:08 brlcad Exp $ (ARL)";
d50 1
a50 1
#include <string.h>		/* for bzero() */
@


14.17
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d43 1
a43 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.16 2007/01/23 01:13:33 brlcad Exp $ (ARL)";
a125 1
#	include "noalias.h"
a148 1
#	include "noalias.h"
@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d43 1
a43 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.15 2007/01/21 04:45:41 brlcad Exp $ (ARL)";
d50 1
a50 5
#ifdef HAVE_STRING_H
#  include <string.h>		/* for bzero() */
#else
#  include <strings.h>
#endif
d52 1
@


14.15
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d43 1
a43 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.14 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.14
log
@update copyright to 2007
@
text
@d21 4
a24 4

/** \addtogroup bitv */
/*@@{*/
/**  @@file bitv.c
d44 1
a44 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.13 2007/01/17 19:36:49 erikgreenwald Exp $ (ARL)";
d324 1
a324 1
/*@@}*/
@


14.13
log
@type fixes (size_t isn't necessarily unsigned int, signed vs unsigned, etc)
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d44 1
a44 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.12 2006/08/31 05:50:24 lbutler Exp $ (ARL)";
@


14.12
log
@Mostly doxygen formatting.
@
text
@d44 1
a44 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.11 2006/06/22 13:58:35 brlcad Exp $ (ARL)";
d229 1
a229 1
    bu_vls_extend( v, word_count * sizeof( bitv_t ) * 2 + 1 );
@


14.11
log
@ws
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d24 2
a25 2

/** @@file bitv.c
d35 1
a35 2
 *  Author -
 *	Michael John Muuss
d37 1
a37 1
 *  Source -
a41 1
/*@@}*/
d44 1
a44 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.10 2006/03/24 19:53:51 brlcad Exp $ (ARL)";
d60 1
a60 1
/*
d62 1
a62 1
 *
d83 1
a83 1
/*
d85 2
a87 1
 *  Release all internal storage for this bit vector.
d100 1
a100 1
/*
d102 1
a102 1
 *
d115 1
a115 1
/*
d163 1
a163 1
/*
d165 1
a165 1
 *
d192 1
a192 1
/*
d194 1
a194 1
 *
d212 1
a212 1
/*
d214 1
a214 1
 *
d241 1
a241 1
/*
d243 1
a243 1
 *
d308 1
a308 1
/*
d310 1
a310 1
 *
d324 1
a324 1

@


14.10
log
@argument is incompatible with corresponding format string conversion, go with %lx (might still need a cast on the value now for 32-bit systems), add missing stdlib.h header
@
text
@d46 1
a46 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d71 12
a82 12
	struct bu_bitv	*bv;
	int		bv_bytes;
	int		total_bytes;

	bv_bytes = BU_BITS2BYTES(nbits);
	total_bytes = sizeof(struct bu_bitv) - 2*sizeof(bitv_t) + bv_bytes;

	bv = (struct bu_bitv *)bu_malloc( (size_t)total_bytes, "struct bu_bitv" );
	BU_LIST_INIT( &bv->l );
	bv->l.magic = BU_BITV_MAGIC;
	bv->nbits = bv_bytes * 8;
	return bv;
d95 1
a95 1
	BU_CK_BITV(bv);
d97 2
a98 2
	bv->l.forw = bv->l.back = BU_LIST_NULL;	/* sanity */
	bu_free( (char *)bv, "struct bu_bitv" );
d111 1
a111 1
	BU_CK_BITV(bv);
d113 1
a113 1
	BU_BITV_ZEROALL(bv);
d122 8
a129 8
	register bitv_t		*out;
	register const bitv_t	*in;
	register int		words;

	if( ov->nbits != iv->nbits )  bu_bomb("bu_bitv_or: length mis-match");
	out = ov->bits;
	in = iv->bits;
	words = BU_BITS2WORDS(iv->nbits);
d132 2
a133 2
	for( --words; words >= 0; words-- )
		out[words] |= in[words];
d135 2
a136 2
	while( words-- > 0 )
		*out++ |= *in++;
d146 8
a153 8
	register bitv_t		*out;
	register const bitv_t	*in;
	register int		words;

	if( ov->nbits != iv->nbits )  bu_bomb("bu_bitv_and: length mis-match");
	out = ov->bits;
	in = iv->bits;
	words = BU_BITS2WORDS(iv->nbits);
d156 2
a157 2
	for( --words; words >= 0; words-- )
		out[words] &= in[words];
d159 2
a160 2
	while( words-- > 0 )
		*out++ &= *in++;
d172 19
a190 19
	int		seen = 0;
	register int	i;
	int		len;

	BU_CK_VLS( v );
	BU_CK_BITV( bv );

	len = bv->nbits;

	bu_vls_strcat( v, "(" );

	/* Visit all the bits in ascending order */
	for( i=0; i<len; i++ )  {
		if( BU_BITTEST(bv, i) == 0 )  continue;
		if( seen )  bu_vls_strcat( v, ", " );
		bu_vls_printf( v, "%d", i );
		seen = 1;
	}
	bu_vls_strcat( v, ") " );
d202 1
a202 1
	struct bu_vls	v;
d204 1
a204 1
	BU_CK_BITV(bv)
d206 5
a210 5
	bu_vls_strcat( &v, str );
	bu_vls_strcat( &v, ": " );
	bu_bitv_vls( &v, bv );
	bu_log("%s", bu_vls_addr( &v ) );
	bu_vls_free( &v );
d222 1
a222 1
	unsigned int word_count, byte_no;
d224 2
a225 2
	BU_CK_VLS( v );
	BU_CK_BITV( bv );
d227 2
a228 2
	word_count = bv->nbits/8/sizeof( bitv_t );
	byte_no = sizeof( bitv_t );
d230 2
a231 2
	bu_vls_extend( v, word_count * sizeof( bitv_t ) * 2 + 1 );
	while( word_count-- )
d233 1
a233 1
		while( byte_no-- )
d235 2
a236 2
			bu_vls_printf( v, "%02lx",
				       ((bv->bits[word_count] & (((bitv_t)0xff)<<(byte_no*8))) >> (byte_no*8)) & (bitv_t)0xff );
d238 1
a238 1
		byte_no = sizeof( bitv_t );
d250 18
a267 18
	char abyte[3];
	const char *str_start;
	unsigned int len=0;
	int bytes;
	struct bu_bitv *bv;
	unsigned long c;
	int word_count, byte_no;

	abyte[2] = '\0';

	/* skip over any initial white space */
	while( isspace( *str ) )
		str++;

	str_start = str;
	/* count hex digits */
	while( isxdigit( *str ) )
		str++;
d269 1
a269 1
	len = str - str_start;
d271 1
a271 1
	if( len < 2 || len%2 )
d273 3
a275 3
		/* Must be two digits per byte */
		bu_log( "bu_hex_to_bitv: illegal hex bitv (%s)\n", str_start );
		return( (struct bu_bitv *)NULL );
d278 9
a286 9
	bytes = len / 2; /* two hex digits per byte */
	bv = bu_bitv_new( len * 4 ); /* 4 bits per hex digit */
	bu_bitv_clear( bv );
	word_count = bytes/sizeof( bitv_t );
	byte_no = bytes % sizeof( bitv_t );
	if( !byte_no )
		byte_no = sizeof( bitv_t );
	else
		word_count++;
d288 2
a289 2
	str = str_start;
	while( word_count-- )
d291 1
a291 1
		while( byte_no-- )
d293 3
a295 3
			/* get next two hex digits from string */
			abyte[0] = *str++;
			abyte[1] = *str++;
d297 2
a298 2
			/* convert into an unsigned long */
			c = strtoul( abyte, (char **)NULL, 16 );
d300 2
a301 2
			/* set the appropriate bits in the bit vector */
			bv->bits[word_count] |= (bitv_t)c<<(byte_no*8);
d303 1
a303 1
		byte_no = sizeof( bitv_t );
d306 1
a306 1
	return( bv );
d317 1
a317 1
	struct bu_bitv *bv2;
d319 3
a321 3
	bv2 = bu_bitv_new( bv->nbits );
	bu_bitv_clear( bv2 );
	bu_bitv_or( bv2, bv );
d323 1
a323 1
	return( bv2 );
@


14.9
log
@update copyright to 2006
@
text
@d46 1
a46 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.8 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
a50 1

d52 1
d54 1
a54 1
#include <string.h>		/* for bzero() */
d56 1
a56 1
#include <strings.h>
d235 1
a235 1
			bu_vls_printf( v, "%02x",
@


14.9.2.1
log
@update from HEAD
@
text
@d46 1
a46 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d51 1
a52 1
#include <stdlib.h>
d54 1
a54 1
#  include <string.h>		/* for bzero() */
d56 1
a56 1
#  include <strings.h>
d235 1
a235 1
			bu_vls_printf( v, "%02lx",
@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d46 1
a46 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.7 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.7
log
@Doxygen changes
@
text
@d37 1
a37 1
 *  
d41 1
a41 1
 *  
d46 1
a46 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.6 2005/01/30 20:30:45 brlcad Exp $ (ARL)";
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d46 1
a46 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header$ (ARL)";
@


14.6
log
@update copyright to 2005
@
text
@d21 4
a25 1
 *
d43 2
d46 1
a46 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/bitv.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d41 1
a41 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bitv.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a38 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d41 1
a41 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bitv.c,v 14.3 2004/12/21 05:45:20 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d43 1
a43 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bitv.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d43 1
a43 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bitv.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			B I T V . C
d43 1
a43 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bitv.c,v 1.4 2004/09/03 23:30:57 morrison Exp $ (ARL)";
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bitv.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (ARL)";
d303 10
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/bitv.c,v 1.2 2004/06/08 19:28:49 morrison Exp $ (ARL)";
d31 1
a31 1
#ifdef USE_STRING_H
@


1.2
log
@poof goes the silly externs.h
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header$ (ARL)";
d27 1
a27 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d24 1
a24 1
static const char libbu_bitv_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/bitv.c,v 1.16 2004/05/10 15:30:44 erikg Exp $ (ARL)";
a39 1
#include "externs.h"
@

