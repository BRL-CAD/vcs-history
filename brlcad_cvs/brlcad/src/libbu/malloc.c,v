head	14.45;
access;
symbols
	rel-7-10-4:14.37
	STABLE:14.37.0.2
	stable-branch:14.9
	rel-7-10-2:14.36
	rel-7-10-0:14.35
	rel-7-8-4:14.26
	rel-7-8-2:14.22
	rel-7-8-0:14.22
	trimnurbs-branch:14.21.0.2
	help:14.21
	temp_tag:14.19
	bobWinPort-20051223-freeze:14.17
	postmerge-20051223-bobWinPort:14.19
	premerge-20051223-bobWinPort:14.19
	rel-7-6-6:14.19
	rel-7-6-4:14.19
	rel-7-6-2:14.18
	rel-7-6-branch:14.18.0.2
	rel-7-6-0:14.18
	rel-7-4-2:14.13.2.1
	rel-7-4-branch:14.13.0.2
	bobWinPort:14.17.0.2
	rel-7-4-0:14.13
	rel-7-2-6:14.12
	rel-7-2-4:14.10
	rel-7-2-2:14.9
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.7
	rel-7-0-branch:1.6.0.2
	rel-7-0:1.6;
locks; strict;
comment	@ * @;


14.45
date	2007.12.31.19.15.02;	author brlcad;	state Exp;
branches;
next	14.44;

14.44
date	2007.12.31.17.53.01;	author brlcad;	state Exp;
branches;
next	14.43;

14.43
date	2007.12.16.21.27.15;	author brlcad;	state Exp;
branches;
next	14.42;

14.42
date	2007.12.16.18.53.48;	author brlcad;	state Exp;
branches;
next	14.41;

14.41
date	2007.12.16.16.05.14;	author brlcad;	state Exp;
branches;
next	14.40;

14.40
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.39;

14.39
date	2007.12.15.07.53.56;	author brlcad;	state Exp;
branches;
next	14.38;

14.38
date	2007.09.15.16.23.09;	author brlcad;	state Exp;
branches;
next	14.37;

14.37
date	2007.08.30.19.20.36;	author erikgreenwald;	state Exp;
branches;
next	14.36;

14.36
date	2007.05.13.08.22.53;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2007.02.20.01.14.18;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2007.02.20.01.06.31;	author brlcad;	state Exp;
branches;
next	14.33;

14.33
date	2007.01.31.21.40.17;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.28;

14.28
date	2007.01.17.19.36.49;	author erikgreenwald;	state Exp;
branches;
next	14.27;

14.27
date	2006.10.28.14.58.30;	author d_rossberg;	state Exp;
branches;
next	14.26;

14.26
date	2006.08.31.23.16.38;	author lbutler;	state Exp;
branches;
next	14.25;

14.25
date	2006.08.31.05.50.25;	author lbutler;	state Exp;
branches;
next	14.24;

14.24
date	2006.08.28.03.07.35;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2006.08.23.01.49.18;	author lbutler;	state Exp;
branches;
next	14.22;

14.22
date	2006.03.24.21.49.34;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2006.01.22.18.37.08;	author brlcad;	state Exp;
branches
	14.21.2.1;
next	14.20;

14.20
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.19;

14.19
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.18;

14.18
date	2005.08.21.07.56.53;	author brlcad;	state Exp;
branches
	14.18.2.1;
next	14.17;

14.17
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches;
next	14.16;

14.16
date	2005.07.26.03.02.22;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2005.07.26.01.51.31;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.07.24.19.28.45;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.06.14.16.00.38;	author bob1961;	state Exp;
branches
	14.13.2.1;
next	14.12;

14.12
date	2005.05.28.02.14.50;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.05.15.04.32.03;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.05.11.02.30.34;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.03.23.19.29.15;	author bob1961;	state Exp;
branches;
next	14.8;

14.8
date	2005.03.23.15.55.32;	author lbutler;	state Exp;
branches;
next	14.7;

14.7
date	2005.03.22.14.38.09;	author bob1961;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.46;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.09.20.34.30;	author morrison;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.28.13.52.47;	author butler;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.03.20.42.29;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.28.50;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.34;	author morrison;	state Exp;
branches;
next	;

14.13.2.1
date	2005.08.16.21.03.49;	author brlcad;	state Exp;
branches;
next	;

14.18.2.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.21.2.1
date	2006.04.07.19.30.15;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.45
log
@moved bu_strdupm() to new src/libbu/str.c file
@
text
@/*                        M A L L O C . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup malloc */
/** @@{ */
/**
 * @@file malloc.c
 *
 * @@brief
 *  Parallel-protected debugging-enhanced wrapper around system malloc().
 *
 *  The bu_malloc() routines can't use bu_log() because that uses
 *  the bu_vls() routines which depend on bu_malloc().  So it goes direct
 *  to stderr, semaphore protected.
 *
 * @@par  Functions
 *	bu_malloc	Allocate storage, with visibility & checking
 * @@n	bu_free		Similarly, free storage
 * @@n	bu_realloc	Reallocate storage, with visibility & checking
 * @@n	bu_calloc	Allocate zero'ed storage
 * @@n	bu_prmem	When debugging, print memory map
 * @@n	bu_malloc_len_roundup	Optimize sizing of malloc() requests
 * @@n	bu_free_array	free elements of an array
 *
 *
 *  @@author	Michael John Muuss
 *  @@author      Christopher Sean Morrison
 *
 * @@par  Source -
 *	The U. S. Army Research Laboratory
 * @@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.44 2007/12/31 17:53:01 brlcad Exp $ (ARL)";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "bu.h"

/** this variable controls the libbu debug level */
int	bu_debug = 0;


/** used by the memory allocation routines passed to bu_alloc by
 * default to indicate whether allocated memory should be zero'd
 * first.
 */
typedef enum {
  MALLOC,
  CALLOC
} alloc_t;


/* These counters are not semaphore-protected, and thus are only estimates */
long	bu_n_malloc = 0;
long	bu_n_free = 0;
long	bu_n_realloc = 0;

#define MDB_MAGIC	0x12348969
struct memdebug {
	long		magic;		/* corruption can be everywhere */
	genptr_t	mdb_addr;
	const char	*mdb_str;
	int		mdb_len;
};
static struct memdebug	*bu_memdebug = (struct memdebug *)NULL;
static struct memdebug	*bu_memdebug_lowat = (struct memdebug *)NULL;
static size_t		bu_memdebug_len = 0;
#define MEMDEBUG_NULL	((struct memdebug *)0)

struct memqdebug {
	struct bu_list	q;
	struct memdebug	m;
};

static struct bu_list *bu_memq = BU_LIST_NULL;
static struct bu_list bu_memqhd;
#define MEMQDEBUG_NULL	((struct memqdebug *)0)

/* from vls.c */
extern const char bu_vls_message[];
extern const char bu_strdup_message[];


#ifdef _WIN32
char *sbrk(i)
{
	return( (char *)0 );
}
#endif


/**
 *			B U _ M E M D E B U G _ A D D
 *
 *  Add another entry to the memory debug table
 */
HIDDEN void
bu_memdebug_add(char *ptr, unsigned int cnt, const char *str)
{
	register struct memdebug *mp;
top:
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	if( bu_memdebug )  {
		mp = &bu_memdebug[bu_memdebug_len-1];
		if( bu_memdebug_lowat > bu_memdebug &&
		    bu_memdebug_lowat < mp )  {
			mp = bu_memdebug_lowat;
		} else {
			bu_memdebug_lowat = mp;
		}
again:
		for( ; mp >= bu_memdebug; mp-- )  {
			/* Search for an empty slot */
			if( mp->mdb_len > 0 )  continue;
			mp->magic = MDB_MAGIC;
			mp->mdb_addr = ptr;
			mp->mdb_len = cnt;
			mp->mdb_str = str;
			bu_memdebug_lowat = mp-1;
			bu_semaphore_release( BU_SEM_SYSCALL );
			return;
		}
		/* Didn't find a slot.  If started in middle, go again */
		mp = &bu_memdebug[bu_memdebug_len-1];
		if( bu_memdebug_lowat != mp )  {
			bu_memdebug_lowat = mp;
			goto again;
		}
	}

	/* Need to make more slots */
	if( bu_memdebug_len <= 0 )  {
		bu_memdebug_len = 5120-2;
		bu_memdebug = (struct memdebug *)calloc(
			bu_memdebug_len, sizeof(struct memdebug) );
		if( bu_memdebug == (struct memdebug *)0 )
			bu_bomb("bu_memdebug_add() malloc failure\n");
	} else {
		size_t	old_len = bu_memdebug_len;
		bu_memdebug_len *= 16;
		bu_memdebug = (struct memdebug *)realloc(
			(char *)bu_memdebug,
			sizeof(struct memdebug) * bu_memdebug_len );
		if( bu_memdebug == (struct memdebug *)0 )
			bu_bomb("bu_memdebug_add() malloc failure\n");
		memset((char *)&bu_memdebug[old_len], 0,
		       (bu_memdebug_len-old_len) * sizeof(struct memdebug) );
	}
	bu_semaphore_release( BU_SEM_SYSCALL );

	goto top;
}

/**
 *			B U _ M E M D E B U G _ C H E C K
 *
 *  Check an entry against the memory debug table, based upon it's address.
 */
HIDDEN struct memdebug *
bu_memdebug_check(register char *ptr, const char *str)
{
	register struct memdebug *mp = &bu_memdebug[bu_memdebug_len-1];
	register long	*ip;

	if( bu_memdebug == (struct memdebug *)0 )  {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		fprintf(stderr,"bu_memdebug_check(x%lx, %s)  no memdebug table yet\n",
			(long)ptr, str);
		bu_semaphore_release(BU_SEM_SYSCALL);
		return MEMDEBUG_NULL;
	}
	for( ; mp >= bu_memdebug; mp-- )  {
		if( !mp->magic )  continue;
		if( mp->magic != MDB_MAGIC )  bu_bomb("bu_memdebug_check() malloc tracing table corrupted!\n");
		if( mp->mdb_len <= 0 )  continue;
		if( mp->mdb_addr != ptr )  continue;
		ip = (long *)(ptr+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			bu_semaphore_acquire(BU_SEM_SYSCALL);
			fprintf(stderr,"ERROR bu_memdebug_check(x%lx, %s) %s, barrier word corrupted!\nbarrier at x%lx was=x%lx s/b=x%x, len=%d\n",
				(long)ptr, str, mp->mdb_str,
				(long)ip, *ip, MDB_MAGIC, mp->mdb_len);
			bu_semaphore_release(BU_SEM_SYSCALL);
			bu_bomb("bu_memdebug_check() memory corruption\n");
		}
		return(mp);		/* OK */
	}
	return MEMDEBUG_NULL;
}


/**
 *			B U _ A L L O C
 *
 *  This routine only returns on successful allocation.
 *  We promise never to return a NULL pointer; caller doesn't have to check.
 *
 *  Requesting allocation of zero bytes is considered a irrecoverable
 *  mistake in order to fulfill the non-NULL promise.
 *
 *  Failure results in bu_bomb() being called.
 *
 *  type is 0 for malloc, 1 for calloc
 */
static genptr_t
bu_alloc(alloc_t type, unsigned int cnt, unsigned int sz, const char *str)
{
	register genptr_t ptr = 0;
	register unsigned long int size = cnt * sz;

	extern int bu_bomb_failsafe_init();
	static int failsafe_init = 0;

	/* bu_bomb hook to recover from memory problems */
	if (!failsafe_init) {
	    failsafe_init = bu_bomb_failsafe_init();
	}

	if( size == 0 )  {
		fprintf(stderr,"ERROR: bu_alloc size=0 (cnt=%d, sz=%d) %s\n", cnt, sz, str );
		bu_bomb("ERROR: bu_malloc(0)\n");
	}

	if( size < sizeof( int ) ) {
		size = sizeof( int );
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
		/* Pad, plus full int for magic number */
		size = (size+2*sizeof(long)-1)&(~(sizeof(long)-1));
	} else if (bu_debug&BU_DEBUG_MEM_QCHECK ) {
		size = (size+2*sizeof(struct memqdebug)-1)
			&(~(sizeof(struct memqdebug)-1));
	}

#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_acquire( BU_SEM_SYSCALL );
#endif

	switch (type) {
	    case MALLOC:
		ptr = malloc(size);
		break;
	    case CALLOC:
		/* if we're debugging, we need a slightly larger
		 * allocation size for debug tracking.
		 */
		if( bu_debug&(BU_DEBUG_MEM_CHECK|BU_DEBUG_MEM_QCHECK) )  {
		    ptr = malloc(size);
		    memset(ptr, 0, size);
		} else {
		    ptr = calloc(cnt, sz);
		}
		break;
	    default:
		bu_bomb("ERROR: bu_alloc with unknown type\n");
	}

	if( ptr==(char *)0 || bu_debug&BU_DEBUG_MEM_LOG )  {
		fprintf(stderr, "%8lx malloc%7ld %s\n", (long)ptr, size, str);
	}
#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_release( BU_SEM_SYSCALL );
#endif

	if( ptr==(char *)0 )  {
		fprintf(stderr,"bu_malloc: Insufficient memory available, sbrk(0)=x%lx\n", (long)sbrk(0));
		bu_bomb("bu_malloc: malloc failure");
	}
	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
		bu_memdebug_add( ptr, size, str );

		/* Install a barrier word at the end of the dynamic arena */
		/* Correct location depends on 'size' being rounded up, above */

		*((long *)(((char *)ptr)+size-sizeof(long))) = MDB_MAGIC;
	} else if (bu_debug&BU_DEBUG_MEM_QCHECK ) {
		struct memqdebug *mp = (struct memqdebug *)ptr;
		ptr = (genptr_t)(((struct memqdebug *)ptr)+1);
		mp->m.magic = MDB_MAGIC;
		mp->m.mdb_addr = ptr;
		mp->m.mdb_len = size;
		mp->m.mdb_str = str;
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		if (bu_memq == BU_LIST_NULL) {
			bu_memq = &bu_memqhd;
			BU_LIST_INIT(bu_memq);
		}
		BU_LIST_APPEND(bu_memq,&(mp->q));
		BU_LIST_MAGIC_SET(&(mp->q),MDB_MAGIC);
		bu_semaphore_release(BU_SEM_SYSCALL);
	}
	bu_n_malloc++;
	return(ptr);
}

/**
 *			B U _ M A L L O C
 *
 *  This routine only returns on successful allocation.
 *  We promise never to return a NULL pointer; caller doesn't have to check.
 *  Failure results in bu_bomb() being called.
w */
genptr_t
bu_malloc(size_t size, const char *str)
{
  return bu_alloc(MALLOC, 1, size, str);
}


/**
 *			B U _ C A L L O C
 *
 *  This routine only returns on successful allocation.
 *  We promise never to return a NULL pointer; caller doesn't have to check.
 *  Failure results in bu_bomb() being called.
 */
genptr_t
bu_calloc(unsigned int nelem, size_t elsize, const char *str)
{
  return bu_alloc(CALLOC, nelem, elsize, str);
}


/*
 *			B U _ F R E E
 */
void
bu_free(genptr_t ptr, const char *str)
{
	if(bu_debug&BU_DEBUG_MEM_LOG) {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		fprintf(stderr, "%8lx free          %s\n", (long)ptr, str);
		bu_semaphore_release(BU_SEM_SYSCALL);
	}
	if(ptr == (char *)0 || ptr == (char *)(-1L) )  {
		fprintf(stderr,"%8lx free ERROR %s\n", (long)ptr, str);
		return;
	}
	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
		struct memdebug	*mp;
		if( (mp = bu_memdebug_check( ptr, str )) == MEMDEBUG_NULL )  {
		    fprintf(stderr,"ERROR bu_free(x%lx, %s) pointer bad, or not allocated with bu_malloc!  Ignored.\n", (long)ptr, str);
		} else {
		    mp->mdb_len = 0;	/* successful delete */
		}
	} else if (bu_debug&BU_DEBUG_MEM_QCHECK ) {
		struct memqdebug *mp = ((struct memqdebug *)ptr)-1;
		if (BU_LIST_MAGIC_WRONG(&(mp->q),MDB_MAGIC)) {
		    fprintf(stderr,"ERROR bu_free(x%lx, %s) pointer bad, or not allocated with bu_malloc!  Ignored.\n", (long)ptr, str);
		} else {
		    ptr = (genptr_t)mp;
		    bu_semaphore_acquire(BU_SEM_SYSCALL);
		    BU_LIST_DEQUEUE(&(mp->q));
		    bu_semaphore_release(BU_SEM_SYSCALL);
		}
	}

#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_acquire(BU_SEM_SYSCALL);
#endif
/* Windows does not like */
#ifndef _WIN32
	*((int *)ptr) = -1;	/* zappo! */
#endif
	free(ptr);
#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_release(BU_SEM_SYSCALL);
#endif
	bu_n_free++;
}

/**
 *			B U _ R E A L L O C
 *
 *  bu_malloc()/bu_free() compatible wrapper for realloc().
 *
 *  While the string 'str' is provided for the log messages, don't
 *  disturb the mdb_str value, so that this storage allocation can be
 *  tracked back to it's original creator.
 */
genptr_t
bu_realloc(register genptr_t ptr, size_t cnt, const char *str)
{
	struct memdebug		*mp=NULL;
	char	*original_ptr;

	if ( ! ptr ) {
	    /* This is so we are compatible with system realloc.
	     * It seems like an odd behaviour, but some non-BRL-CAD
	     * code relies on this.
	     */
	    return bu_malloc(cnt, str);
	}

	if( bu_debug&BU_DEBUG_MEM_CHECK )  {
		if( ptr && (mp = bu_memdebug_check( ptr, str )) == MEMDEBUG_NULL )  {
			fprintf(stderr,"%8lx realloc%6d %s ** barrier check failure\n",
				(long)ptr, (int)cnt, str );
		}
		/* Pad, plus full long for magic number */
		cnt = (cnt+2*sizeof(long)-1)&(~(sizeof(long)-1));
	} else if ( bu_debug&BU_DEBUG_MEM_QCHECK ) {
		struct memqdebug *mp = ((struct memqdebug *)ptr)-1;

		cnt = (cnt + 2*sizeof(struct memqdebug) - 1)
		    &(~(sizeof(struct memqdebug)-1));

		if (BU_LIST_MAGIC_WRONG(&(mp->q),MDB_MAGIC)) {
			fprintf(stderr,"ERROR bu_realloc(x%lx, %s) pointer bad, "
				"or not allocated with bu_malloc!  Ignored.\n",
				(long)ptr, str);
			/*
			 * Since we're ignoring this, atleast return
			 * the pointer that was passed in. We should
			 * probably return NULL.
			 */
			return ptr;
		}
		ptr = (genptr_t)mp;
		BU_LIST_DEQUEUE(&(mp->q));
	}

	original_ptr = ptr;

#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_acquire(BU_SEM_SYSCALL);
#endif
	ptr = realloc(ptr,cnt);
#if defined(MALLOC_NOT_MP_SAFE)
	bu_semaphore_release(BU_SEM_SYSCALL);
#endif

	if( ptr==(char *)0 || bu_debug&BU_DEBUG_MEM_LOG )  {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		if (ptr == original_ptr) {
			fprintf(stderr,"%8lx realloc%6d %s [grew in place]\n",
				   (long)ptr, (int)cnt, str );
		} else {
			fprintf(stderr,"%8lx realloc%6d %s [moved from %8lx]\n",
				   (long)ptr, (int)cnt, str, (long unsigned int)original_ptr);
		}

		bu_semaphore_release(BU_SEM_SYSCALL);
	}
	if( ptr==(char *)0 && cnt > 0 )  {
		fprintf(stderr,"bu_realloc: Insufficient memory available, sbrk(0)=x%lx\n", (long)sbrk(0));
		bu_bomb("bu_realloc: malloc failure");
	}
	if( bu_debug&BU_DEBUG_MEM_CHECK && ptr )  {
		/* Even if ptr didn't change, need to update cnt & barrier */
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		mp->mdb_addr = ptr;
		mp->mdb_len = cnt;

		/* Install a barrier word at the new end of the dynamic arena */
		/* Correct location depends on 'cnt' being rounded up, above */
		*((long *)(((char *)ptr)+cnt-sizeof(long))) = MDB_MAGIC;
		bu_semaphore_release(BU_SEM_SYSCALL);
	} else if ( bu_debug&BU_DEBUG_MEM_QCHECK && ptr ) {
		struct memqdebug *mp;
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		mp = (struct memqdebug *)ptr;
		ptr = (genptr_t)(((struct memqdebug *)ptr)+1);
		mp->m.magic = MDB_MAGIC;
		mp->m.mdb_addr = ptr;
		mp->m.mdb_len = cnt;
		mp->m.mdb_str = str;
		BU_ASSERT(bu_memq != BU_LIST_NULL);
		BU_LIST_APPEND(bu_memq,&(mp->q));
		BU_LIST_MAGIC_SET(&(mp->q),MDB_MAGIC);
		bu_semaphore_release(BU_SEM_SYSCALL);
	}
	bu_n_realloc++;
	return(ptr);
}


/**
 *			B U _ P R M E M
 *
 *  Print map of memory currently in use.
 */
void
bu_prmem(const char *str)
{
    register struct memdebug *mp;
    register struct memqdebug *mqp;
    register long *ip;
    register size_t count = 0;

    fprintf(stderr,"\nbu_prmem(): dynamic memory use (%s)\n", str);
    if( (bu_debug&(BU_DEBUG_MEM_CHECK|BU_DEBUG_MEM_QCHECK)) == 0 )  {
	fprintf(stderr,"\tMemory debugging is now OFF\n");
    }
#if 0
    fprintf(stderr,"\t%ld slots in memdebug table (not # of allocs)\n Address Length Purpose\n",
	    (long)bu_memdebug_len);
#else
    fprintf(stderr," Address Length Purpose\n");
#endif
    if( bu_memdebug_len > 0 )  {
	mp = &bu_memdebug[bu_memdebug_len-1];
	for( ; mp >= bu_memdebug; mp-- )  {
	    if( !mp->magic )  continue;
	    if( mp->magic != MDB_MAGIC )  bu_bomb("bu_memdebug_check() malloc tracing table corrupted!\n");
	    if( mp->mdb_len <= 0 )  continue;

	    count++;
	    ip = (long *)(((char *)mp->mdb_addr)+mp->mdb_len-sizeof(long));
	    if( mp->mdb_str == bu_strdup_message )  {
		fprintf(stderr,"%8lx %6d bu_strdup: \"%s\"\n",
			(long)(mp->mdb_addr), mp->mdb_len,
			((char *)mp->mdb_addr) );
	    } else if( mp->mdb_str == bu_vls_message )  {
		fprintf(stderr,"%8lx %6d bu_vls: \"%s\"\n",
			(long)(mp->mdb_addr), mp->mdb_len,
			((char *)mp->mdb_addr) );
	    } else {
		fprintf(stderr,"%8lx %6d %s\n",
			(long)(mp->mdb_addr), mp->mdb_len,
			mp->mdb_str);
	    }
	    if( *ip != MDB_MAGIC )  {
		fprintf(stderr,"\tCorrupted end marker was=x%lx\ts/b=x%x\n",
			*ip, MDB_MAGIC);
	    }
	}
    }


    if (bu_memq != BU_LIST_NULL)  {
	fprintf(stderr,"memdebug queue\n Address Length Purpose\n");
	BU_LIST_EACH(bu_memq, mqp, struct memqdebug) {
	    if (BU_LIST_MAGIC_WRONG(&(mqp->q),MDB_MAGIC)
		|| BU_LIST_MAGIC_WRONG(&(mqp->m),MDB_MAGIC))
		bu_bomb("bu_prmem() malloc tracing queue corrupted!\n");
	    if( mqp->m.mdb_str == bu_strdup_message )  {
		fprintf(stderr,"%8lx %6d bu_strdup: \"%s\"\n",
			(long)(mqp->m.mdb_addr), mqp->m.mdb_len,
			((char *)mqp->m.mdb_addr) );
	    } else if( mqp->m.mdb_str == bu_vls_message )  {
		fprintf(stderr,"%8lx %6d bu_vls: \"%s\"\n",
			(long)(mqp->m.mdb_addr), mqp->m.mdb_len,
			((char *)mqp->m.mdb_addr) );
	    } else {
		fprintf(stderr,"%8lx %6d %s\n",
			(long)(mqp->m.mdb_addr), mqp->m.mdb_len,
			mqp->m.mdb_str);
	    }
	}
    }

    fprintf(stderr, "%lu allocation entries\n", count);


}


/**
 *  		B U _ M A L L O C _ L E N _ R O U N D U P
 *
 *  On systems with the CalTech malloc(), the amount of storage
 *  ACTUALLY ALLOCATED is the amount requested rounded UP to the
 *  nearest power of two.  For structures which are acquired and
 *  released often, this works well, but for structures which will
 *  remain unchanged for the duration of the program, this wastes
 *  as much as 50% of the address space (and usually memory as well).
 *  Here, we round up a byte size to the nearest power of two,
 *  leaving off the malloc header, so as to ask for storage without
 *  wasting any.
 *
 *  On systems with the traditional malloc(), this strategy will just
 *  consume the memory in somewhat larger chunks, but overall little
 *  unused memory will be consumed.
 */
int
bu_malloc_len_roundup(register int nbytes)
{
#if !defined(HAVE_CALTECH_MALLOC)
	return(nbytes);
#else
	static int pagesz;
	register int n;
	register int amt;

	if (pagesz == 0)
		pagesz = getpagesize();

#define OVERHEAD	(4*sizeof(unsigned char) + \
			2*sizeof(unsigned short) + \
			sizeof(unsigned int) )
	n = pagesz - OVERHEAD;
	if (nbytes <= n)
		return(n);
	amt = pagesz;

	while (nbytes > amt + n) {
		amt <<= 1;
	}
	return(amt-OVERHEAD-sizeof(int));
#endif
}

/**
 *			B U _ C K _ M A L L O C _ P T R
 *
 *	For a given pointer allocated by bu_malloc(),
 *	Check the magic number stored after the allocation area
 *	when BU_DEBUG_MEM_CHECK is set.
 *
 *	This is the individual version of bu_mem_barriercheck().
 *
 *	returns if pointer good or BU_DEBUG_MEM_CHECK not set,
 *	bombs if memory is corrupted.
 */
void
bu_ck_malloc_ptr(genptr_t ptr, const char *str)
{
	register struct memdebug *mp = &bu_memdebug[bu_memdebug_len-1];
	register long	*ip;


	if (ptr == (char *)NULL) {
		fprintf(stderr,"bu_ck_malloc_ptr(x%lx, %s) null pointer\n\n", (long)ptr, str);
		bu_bomb("Goodbye");
	}

	if (bu_debug&BU_DEBUG_MEM_CHECK) {
	if( bu_memdebug == (struct memdebug *)0 )  {
		fprintf(stderr,"bu_ck_malloc_ptr(x%lx, %s)  no memdebug table yet\n",
			(long)ptr, str);
		/* warning only -- the program is just getting started */
		return;
	}

	for( ; mp >= bu_memdebug; mp-- )  {
		if( !mp->magic )  continue;
		if( mp->magic != MDB_MAGIC )  bu_bomb("bu_ck_malloc_ptr() malloc tracing table corrupted!\n");
		if( mp->mdb_len <= 0 || mp->mdb_addr != ptr )  continue;

		/* Found the relevant entry */
		ip = (long *)(((char *)ptr)+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			fprintf(stderr,"ERROR bu_ck_malloc_ptr(x%lx, %s) barrier word corrupted! was=x%lx s/b=x%x\n",
				(long)ptr, str, (long)*ip, MDB_MAGIC);
			bu_bomb("bu_ck_malloc_ptr\n");
		}
		return;		/* OK */
	}
	fprintf(stderr,"WARNING: bu_ck_malloc_ptr(x%lx, %s)\
	pointer not in table of allocated memory.\n", (long)ptr, str);
	} else if (bu_debug&BU_DEBUG_MEM_QCHECK) {
		struct memqdebug *mp = (struct memqdebug *)ptr;
		if (BU_LIST_MAGIC_WRONG(&(mp->q),MDB_MAGIC)
		    || mp->m.magic != MDB_MAGIC) {
			fprintf(stderr,"WARNING: bu_ck_malloc_ptr(x%lx, %s)"
				" memory corrupted.\n", (long)ptr, str);
		}
	}
}

/**
 *			B U _ M E M _ B A R R I E R C H E C K
 *
 *  Check *all* entries in the memory debug table for barrier word
 *  corruption.
 *  Intended to be called periodicly through an application during debugging.
 *  Has to run single-threaded, to prevent table mutation.
 *
 *  This is the bulk version of bu_ck_malloc_ptr()
 *
 *  Returns -
 *	-1	something is wrong
 *	 0	all is OK;
 */
int
bu_mem_barriercheck(void)
{
	register struct memdebug *mp = &bu_memdebug[bu_memdebug_len-1];
	register long	*ip;

	if( bu_memdebug == (struct memdebug *)0 )  {
		fprintf(stderr,"bu_mem_barriercheck()  no memdebug table yet\n");
		return 0;
	}
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	for( ; mp >= bu_memdebug; mp-- )  {
		if( !mp->magic )  continue;
		if( mp->magic != MDB_MAGIC )  {
			bu_semaphore_release( BU_SEM_SYSCALL );
			fprintf(stderr,"  mp->magic = x%lx, s/b=x%x\n", (long)(mp->magic), MDB_MAGIC );
			bu_bomb("bu_mem_barriercheck() malloc tracing table corrupted!\n");
		}
		if( mp->mdb_len <= 0 )  continue;
		ip = (long *)(((char *)mp->mdb_addr)+mp->mdb_len-sizeof(long));
		if( *ip != MDB_MAGIC )  {
			bu_semaphore_release( BU_SEM_SYSCALL );
			fprintf(stderr,"ERROR bu_mem_barriercheck(x%lx, len=%d) barrier word corrupted!\n\tbarrier at x%lx was=x%lx s/b=x%x %s\n",
				(long)mp->mdb_addr, mp->mdb_len,
				(long)ip, *ip, MDB_MAGIC, mp->mdb_str);
			return -1;	/* FAIL */
		}
	}
	bu_semaphore_release( BU_SEM_SYSCALL );
	return 0;			/* OK */
}


/** b u _ f r e e _ a r r a y
 *
 * free up to argc elements of memory allocated to an array without
 * free'ing the array itself.
 */
void bu_free_array(int argc, char *argv[], const char *str)
{
  int count = 0;

  if (!argv || argc <= 0) {
    return;
  }

  while (count < argc) {
    if (argv[count]) {
      bu_free(argv[count], str);
      argv[count] = NULL;
    }
    count++;
  }

  return;
}

/** @@} */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.44
log
@move bu_strdup_message out of malloc.c and into vls.c, add bu_vls_strcmp() and bu_vls_strncmp() as new functions instead of macros so the sanity checks can be added.
@
text
@a37 1
 * @@n	bu_strdup_body	Duplicate a string in dynamic memory
d51 1
a51 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.43 2007/12/16 21:27:15 brlcad Exp $ (ARL)";
a586 28
/**
 *		B U _ S T R D U P  / B U _ S T R D U P M
 *
 * Given a string, allocate enough memory to hold it using bu_malloc(),
 * duplicate the strings, returns a pointer to the new string.
 *
 * bu_strdup() is a macro that includes the current file name and line
 * number that can be used when bu debugging is enabled.
 */
char *
bu_strdupm(register const char *cp, const char *label)
{
	register char	*base;
	register size_t	len;

	len = strlen( cp )+1;
	base = bu_malloc( len, label);

	if(bu_debug&BU_DEBUG_MEM_LOG) {
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		fprintf(stderr, "%8lx strdup%7ld \"%s\"\n", (long)base, (long)len, cp );
		bu_semaphore_release(BU_SEM_SYSCALL);
	}

	memcpy(base, cp, len);
	return(base);
}

@


14.43
log
@memset missing comma
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.42 2007/12/16 18:53:48 brlcad Exp $ (ARL)";
d108 3
a110 2
const char bu_strdup_message[] = "bu_strdup string";
extern const char bu_vls_message[];	/* from vls.c */
@


14.42
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.41 2007/12/16 16:05:14 brlcad Exp $ (ARL)";
d174 1
a174 1
		memset((char *)&bu_memdebug[old_len], 0
@


14.41
log
@few multiline bzero to memset stragglers
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.40 2007/12/16 15:59:38 brlcad Exp $ (ARL)";
d611 1
a611 1
	memcpy( base, cp, len );
@


14.40
log
@convert all bzero calls to memset
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.39 2007/12/15 07:53:56 brlcad Exp $ (ARL)";
d174 2
a175 2
		bzero( (char *)&bu_memdebug[old_len],
			(bu_memdebug_len-old_len) * sizeof(struct memdebug) );
@


14.39
log
@consider calloc() a given with c89
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.38 2007/09/15 16:23:09 brlcad Exp $ (ARL)";
d278 1
a278 1
		    bzero(ptr, size);
@


14.38
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.37 2007/08/30 19:20:36 erikgreenwald Exp $ (ARL)";
d269 16
a284 21
	  case MALLOC:
	    ptr = malloc(size);
	    break;
	  case CALLOC:
#if defined(HAVE_CALLOC)
	      /* if we're debugging, we need a slightly larger
	       * allocation size for debug tracking.
	       */
	      if( bu_debug&(BU_DEBUG_MEM_CHECK|BU_DEBUG_MEM_QCHECK) )  {
		  ptr = malloc(size);
		  bzero(ptr, size);
	      } else {
		  ptr = calloc(cnt, sz);
	      }
#else
	    ptr = malloc(size);
	    bzero(ptr, size);
#endif
	    break;
	  default:
	    bu_bomb("ERROR: bu_alloc with unknown type\n");
@


14.37
log
@minor casting and default value (-Wall)
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.36 2007/05/13 08:22:53 brlcad Exp $ (ARL)";
d59 2
a60 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
@


14.36
log
@add a memory buffer failsafe to bu_bomb() that will release an allocation (64k) prior to performing the shutdown calls (some syscalls, some others may have tiny allocations of their own even for string/print processing).  this is of course down to give the app a tiny bit of breathing room so that hopefully there's enough room to shutdown cleanly.
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.35 2007/02/20 01:14:18 brlcad Exp $ (ARL)";
d239 1
a239 1
	register genptr_t ptr;
d435 1
a435 1
				(long)ptr, cnt, str );
d474 1
a474 1
				   (long)ptr,       cnt, str );
d477 1
a477 1
				   (long)ptr,       cnt, str, original_ptr);
@


14.35
log
@get rid of the bu_strdup() dead code and comment how it's really an interface macro pass through that provides file:line info when bu debugging is enabled
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.34 2007/02/20 01:06:31 brlcad Exp $ (ARL)";
d242 8
@


14.34
log
@remove bu_dirname(), was moved to new file dirname.c.
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.33 2007/01/31 21:40:17 brlcad Exp $ (ARL)";
d588 1
a588 1
 *			B U _ S T R D U P
d592 3
a595 7
#if 0
char *
bu_strdup(register const char *cp)
{
	return bu_strdupm(cp, bu_strdup_message);
}
#endif
d617 1
a617 1
 *  			B U _ M A L L O C _ L E N _ R O U N D U P
@


14.33
log
@consistency on BRL-CAD name use, s/BRLCAD/BRL-CAD/
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.32 2007/01/27 01:41:36 brlcad Exp $ (ARL)";
a618 56
/**
 *			B U _ D I R N A M E
 *
 *  Given a filesystem pathname, return a pointer to a dynamic string
 *  which is the parent directory of that file/directory.
 *
 *	/usr/dir/file	/usr/dir
 * @@n	/usr/dir/	/usr
 * @@n	/usr/file	/usr
 * @@n	/usr/		/
 * @@n	/usr		/
 * @@n	/		/
 * @@n	.		.
 * @@n	..		.
 * @@n	usr		.
 * @@n	a/b		a
 * @@n	a/		.
 * @@n	../a/b		../a
 */
char *
bu_dirname(const char *cp)
{
	char	*ret;
	char	*slash;
	int	len;

	/* Special cases */
	if( cp == NULL )  return bu_strdup(".");
	if( strcmp( cp, "/" ) == 0 )
		return bu_strdup("/");
	if( strcmp( cp, "." ) == 0 ||
	    strcmp( cp, ".." ) == 0 ||
	    strrchr(cp, '/') == NULL )
		return bu_strdup(".");

	/* Make a duplicate copy of the string, and shorten it in place */
	ret = bu_strdup(cp);

	/* A trailing slash doesn't count */
	len = strlen(ret);
	if( ret[len-1] == '/' )  ret[len-1] = '\0';

	/* If no slashes remain, return "." */
	if( (slash = strrchr(ret, '/')) == NULL )  {
		bu_free( ret, "bu_dirname" );
		return bu_strdup(".");
	}

	/* Remove trailing slash, unless it's at front */
	if( slash == ret )
		ret[1] = '\0';		/* ret == "/" */
	else
		*slash = '\0';

	return ret;
}
@


14.32
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.31 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d418 1
a418 1
	     * It seems like an odd behaviour, but some non-BRLCAD
@


14.31
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d22 1
a22 1
/** 
d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.30 2007/01/21 04:45:42 brlcad Exp $ (ARL)";
d138 1
a138 1
		    	mp = bu_memdebug_lowat;
@


14.30
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.29 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.29
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup malloc */
/*@@{*/
d26 1
a26 1
 *@@brief
d53 1
a53 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.28 2007/01/17 19:36:49 erikgreenwald Exp $ (ARL)";
d851 1
a851 1
/*@@}*/
@


14.28
log
@type fixes (size_t isn't necessarily unsigned int, signed vs unsigned, etc)
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d54 1
a54 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.27 2006/10/28 14:58:30 d_rossberg Exp $ (ARL)";
@


14.27
log
@array bounds read error in bu_strdupm fixed
@
text
@d54 1
a54 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.26 2006/08/31 23:16:38 lbutler Exp $ (ARL)";
d335 1
a335 1
bu_malloc(unsigned int size, const char *str)
d349 1
a349 1
bu_calloc(unsigned int nelem, unsigned int elsize, const char *str)
d413 1
a413 1
bu_realloc(register genptr_t ptr, unsigned int cnt, const char *str)
@


14.26
log
@Doxygen comments
@
text
@d54 1
a54 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.25 2006/08/31 05:50:25 lbutler Exp $ (ARL)";
d608 1
a608 1
	len = strlen( cp )+2;
@


14.25
log
@Mostly doxygen formatting.
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d24 4
a27 1
/** @@file malloc.c
d34 1
a34 1
 *  Functions -
d36 8
a43 11
 *	bu_free		Similarly, free storage
 *	bu_realloc	Reallocate storage, with visibility & checking
 *	bu_calloc	Allocate zero'ed storage
 *	bu_prmem	When debugging, print memory map
 *	bu_strdup_body	Duplicate a string in dynamic memory
 *	bu_malloc_len_roundup	Optimize sizing of malloc() requests
 *      bu_free_array	free elements of an array
 *
 *  Author -
 *	Michael John Muuss
 *      Christopher Sean Morrison
d45 4
a48 1
 *  Source -
d50 1
a50 1
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
a51 1
/*@@}*/
d54 1
a54 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.24 2006/08/28 03:07:35 brlcad Exp $ (ARL)";
d125 1
a125 1
/*
d187 1
a187 1
/*
d327 1
a327 1
/*
d341 1
a341 1
/*
d403 1
a403 1
/*
d509 1
a509 1
/*
d589 1
a589 1
/*
d621 1
a621 1
/*
d628 11
a638 11
 *	/usr/dir/	/usr
 *	/usr/file	/usr
 *	/usr/		/
 *	/usr		/
 *	/		/
 *	.		.
 *	..		.
 *	usr		.
 *	a/b		a
 *	a/		.
 *	../a/b		../a
d678 1
a678 1
/*
d723 1
a723 1
/*
d781 1
a781 1
/*
d852 1
@


14.24
log
@even if we're in debug mode, don't abort the requested task (i.e. free'ing memory) else invoke the wrath of corrupted leaky memory
@
text
@d37 1
a37 1
 *	bu_strdup	Duplicate a string in dynamic memory
d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.23 2006/08/23 01:49:18 lbutler Exp $ (ARL)";
d518 1
d536 2
d559 1
d581 4
d593 1
d599 1
@


14.23
log
@bu_prmem() was printing the number of available slots in the memory debug
table.  This was easily mis-interpreted as the number of memory allocations.
Since this is a diagnostic for how the memory debug table is being manipulated
and not something the average user/programmer wants to see, the value
was removed from bu_prmem()'s output.  Minor benefit:  The table now prints
one less line, so output is more compact.
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.22 2006/03/24 21:49:34 brlcad Exp $ (ARL)";
d371 1
a371 3
			fprintf(stderr,"ERROR bu_free(x%lx, %s) pointer bad, or not allocated with bu_malloc!  Ignored.\n",
				(long)ptr, str);
			return;
d373 1
a373 1
			mp->mdb_len = 0;	/* successful delete */
d378 6
a383 4
			fprintf(stderr,"ERROR bu_free(x%lx, %s) pointer bad, "
				"or not allocated with bu_malloc!  Ignored.\n",
				(long)ptr, str);
			return;
a384 4
		ptr = (genptr_t)mp;
		bu_semaphore_acquire(BU_SEM_SYSCALL);
		BU_LIST_DEQUEUE(&(mp->q));
		bu_semaphore_release(BU_SEM_SYSCALL);
@


14.22
log
@quell some intel compiler warnings
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.21 2006/01/22 18:37:08 brlcad Exp $ (ARL)";
d527 2
a528 1
    fprintf(stderr,"\t%ld elements in memdebug table\n Address Length Purpose\n",
d530 3
a532 1

@


14.21
log
@missing stdlib.h for malloc (only a few files that should be using malloc instead of bu_malloc)
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.20 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
d64 3
d288 1
a288 1
		fprintf(stderr, "%8lx malloc%7d %s\n", (long)ptr, size, str);
d602 1
a602 1
		fprintf(stderr, "%8lx strdup%7d \"%s\"\n", (long)base, len, cp );
@


14.21.2.1
log
@update from HEAD
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.21 2006/01/22 18:37:08 brlcad Exp $ (ARL)";
a63 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
d285 1
a285 1
		fprintf(stderr, "%8lx malloc%7ld %s\n", (long)ptr, size, str);
d599 1
a599 1
		fprintf(stderr, "%8lx strdup%7ld \"%s\"\n", (long)base, (long)len, cp );
@


14.20
log
@update copyright to 2006
@
text
@d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.19 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d57 1
@


14.19
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.18 2005/08/21 07:56:53 brlcad Exp $ (ARL)";
@


14.18
log
@merge version changes from 7.4.2 (from rel-7-4-branch)
@
text
@d44 1
a44 1
 *  
d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.17 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
d509 1
a509 1
 * 
d665 1
a665 1
 *  
d675 1
a675 1
 *  
@


14.18.2.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d44 1
a44 1
 *
d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header$ (ARL)";
d509 1
a509 1
 *
d665 1
a665 1
 *
d675 1
a675 1
 *
@


14.17
log
@Doxygen changes
@
text
@d32 8
a39 8
 *	- bu_malloc	Allocate storage, with visibility & checking
 *	- bu_free		Similarly, free storage
 *	- bu_realloc	Reallocate storage, with visibility & checking
 *	- bu_calloc	Allocate zero'ed storage
 *	- bu_prmem	When debugging, print memory map
 *	- bu_strdup	Duplicate a string in dynamic memory
 *	- bu_malloc_len_roundup	Optimize sizing of malloc() requests
 *      - bu_free_array	free elements of an array
d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.16 2005/07/26 03:02:22 brlcad Exp $ (ARL)";
@


14.16
log
@apply jim hunt's quick memory debugging fixes (ajem scr 675).  the chunk size was not recomputed correctly and insufficient memroy was reallocated potentially resulting in memory corruption and application program crash.
@
text
@d21 3
a24 1
 *
d32 8
a39 8
 *	bu_malloc	Allocate storage, with visibility & checking
 *	bu_free		Similarly, free storage
 *	bu_realloc	Reallocate storage, with visibility & checking
 *	bu_calloc	Allocate zero'ed storage
 *	bu_prmem	When debugging, print memory map
 *	bu_strdup	Duplicate a string in dynamic memory
 *	bu_malloc_len_roundup	Optimize sizing of malloc() requests
 *      bu_free_array	free elements of an array
d49 2
d52 1
a52 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.15 2005/07/26 01:51:31 brlcad Exp $ (ARL)";
@


14.15
log
@comment on requesting an allocation of zero bytes being considered a mistake/error -- libbu's allocation routines will never return null; allocating zero bytes in a cross-platform manner is not achievable.
@
text
@d48 1
a48 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.14 2005/07/24 19:28:45 brlcad Exp $ (ARL)";
d410 1
a410 1
	char	*original_ptr = ptr;
d429 4
d448 2
@


14.14
log
@add a simple bu_free_array convenience routine to free the elements of an array without freeing the array itself
@
text
@d48 1
a48 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.13 2005/06/14 16:00:38 bob1961 Exp $ (ARL)";
d215 1
a215 1
/*
d220 4
@


14.13
log
@bu_realloc() always needs to return a value
@
text
@d37 1
d41 1
a45 1
 *  
d48 1
a48 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.12 2005/05/28 02:14:50 brlcad Exp $ (ARL)";
a52 2


d55 1
a55 1
# include <string.h>
d57 1
a57 1
# include <strings.h>
d63 1
d66 5
d76 1
d798 26
@


14.13.2.1
log
@merge in changes through Aug10 for 7.4.2 release
@
text
@a36 1
 *      bu_free_array	free elements of an array
a39 1
 *      Christopher Sean Morrison
d44 1
d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.16 2005/07/26 03:02:22 brlcad Exp $ (ARL)";
d52 2
d56 1
a56 1
#  include <string.h>
d58 1
a58 1
#  include <strings.h>
a63 1
/** this variable controls the libbu debug level */
a65 5

/** used by the memory allocation routines passed to bu_alloc by
 * default to indicate whether allocated memory should be zero'd
 * first.
 */
a70 1

d209 1
a209 1
/**
a213 4
 *
 *  Requesting allocation of zero bytes is considered a irrecoverable
 *  mistake in order to fulfill the non-NULL promise.
 *
d400 1
a400 1
	char	*original_ptr;
a418 4

		cnt = (cnt + 2*sizeof(struct memqdebug) - 1)
		    &(~(sizeof(struct memqdebug)-1));

a433 2
	original_ptr = ptr;

a791 26

/** b u _ f r e e _ a r r a y
 *
 * free up to argc elements of memory allocated to an array without
 * free'ing the array itself.
 */
void bu_free_array(int argc, char *argv[], const char *str)
{
  int count = 0;

  if (!argv || argc <= 0) {
    return;
  }

  while (count < argc) {
    if (argv[count]) {
      bu_free(argv[count], str);
      argv[count] = NULL;
    }
    count++;
  }

  return;
}


@


14.12
log
@convert WIN32 define checks to _WIN32 since the latter is one of the defaults provided by MSVC whereas the prior is not.  remove some of them related to header inclusions using HAVE_ defines instead.
@
text
@d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.11 2005/05/15 04:32:03 brlcad Exp $ (ARL)";
d423 6
a428 1
			return;
@


14.11
log
@comment on the different allocation choice
@
text
@d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.10 2005/05/11 02:30:34 brlcad Exp $ (ARL)";
d101 1
a101 1
#ifdef WIN32
d377 1
a377 1
#ifndef WIN32
@


14.10
log
@fix bu_debug memory checking.. if run-time debugging is enabled, we cannot simply call calloc since we need to allocate the extra space for BU_DEBUG_CHECK and BU_DEBUG_MEM_QCHECK.  this of course prevents bu barriercheck corruption and false-positives. (this fixes sf bug 1163383 and 1198866)
@
text
@d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.9 2005/03/23 19:29:15 bob1961 Exp $ (ARL)";
d251 3
@


14.9
log
@*- removed duplicate lines of code (this wouldn't compile on Windows)
@
text
@d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.8 2005/03/23 15:55:32 lbutler Exp $ (ARL)";
d251 6
a256 1
	    ptr = calloc(cnt, sz);
@


14.8
log
@Changes to support Jim Hunt's fast memory debugging
@
text
@d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.7 2005/03/22 14:38:09 bob1961 Exp $ (ARL)";
a96 8
struct memqdebug {
	struct bu_list	q;
	struct memdebug	m;
};
static struct bu_list *bu_memq = BU_LIST_NULL;
static struct bu_list bu_memqhd;
#define MEMQDEBUG_NULL	((struct memqdebug *)0)

@


14.7
log
@*- call to bzero requires two arguments
@
text
@d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.6 2005/01/30 20:30:46 brlcad Exp $ (ARL)";
d88 17
d244 3
d287 15
d359 12
d417 10
d463 13
d490 10
a499 10
	register struct memdebug *mp;
	register long *ip;

	fprintf(stderr,"\nbu_prmem(): dynamic memory use (%s)\n", str);
	if( (bu_debug&BU_DEBUG_MEM_CHECK) == 0 )  {
		fprintf(stderr,"\tMemory debugging is now OFF\n");
	}
	fprintf(stderr,"\t%ld elements in memdebug table\n Address Length Purpose\n",
		(long)bu_memdebug_len);
	if( bu_memdebug_len <= 0 )  return;
d501 1
d504 43
a546 21
		if( !mp->magic )  continue;
		if( mp->magic != MDB_MAGIC )  bu_bomb("bu_memdebug_check() malloc tracing table corrupted!\n");
		if( mp->mdb_len <= 0 )  continue;
		ip = (long *)(((char *)mp->mdb_addr)+mp->mdb_len-sizeof(long));
		if( mp->mdb_str == bu_strdup_message )  {
			fprintf(stderr,"%8lx %6d bu_strdup: \"%s\"\n",
				(long)(mp->mdb_addr), mp->mdb_len,
				((char *)mp->mdb_addr) );
		} else if( mp->mdb_str == bu_vls_message )  {
			fprintf(stderr,"%8lx %6d bu_vls: \"%s\"\n",
				(long)(mp->mdb_addr), mp->mdb_len,
				((char *)mp->mdb_addr) );
		} else {
			fprintf(stderr,"%8lx %6d %s\n",
				(long)(mp->mdb_addr), mp->mdb_len,
				mp->mdb_str);
		}
		if( *ip != MDB_MAGIC )  {
			fprintf(stderr,"\tCorrupted end marker was=x%lx\ts/b=x%x\n",
				*ip, MDB_MAGIC);
		}
d548 1
a701 6
	/* if memory debugging isn't turned on, we have no way
	 * of knowing if the pointer is good or not
	 */
	if ((bu_debug&BU_DEBUG_MEM_CHECK) == 0) return;


d707 1
d731 8
@


14.6
log
@update copyright to 2005
@
text
@d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/malloc.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
d242 1
a242 1
	    bzero(ptr);
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/src/libbu/malloc.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a44 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d47 1
a47 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/src/libbu/malloc.c,v 14.3 2004/12/21 05:45:21 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d49 1
a49 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/src/libbu/malloc.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d49 1
a49 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/src/libbu/malloc.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			M A L L O C . C
d49 1
a49 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/src/libbu/malloc.c,v 1.7 2004/11/09 20:34:30 morrison Exp $ (ARL)";
@


1.7
log
@provide a means for calloc to be used if it exists for bu_calloc().  bu_malloc() is reworked as bu_alloc() accepting an argument for whether to get memory as malloc or calloc.  some systems can provide zero'd memory faster than we can malloc and bzero it.
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /n/xoff/cvs/brlcad/src/libbu/malloc.c,v 1.6 2004/09/28 13:52:47 butler Exp $ (ARL)";
d672 10
@


1.6
log
@added bu_strdupm() which takes a purpose string in addition to the ptr to be dup'd, so that the reporting can be
similar to bu_malloc() and friends when debugging is turned on.

Changed the logging in bu_realloc() so that it reports the old address as well when realloc() moves the memory.  This helps people who are manually looking through the logs at memory usage patterns.
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/src/libbu/malloc.c,v 1.5 2004/09/03 23:30:57 morrison Exp $ (ARL)";
d49 5
d74 1
d81 2
d182 1
d184 1
a184 1
 *			B U _ M A L L O C
d189 2
d192 2
a193 2
genptr_t
bu_malloc(unsigned int cnt, const char *str)
d196 1
d198 2
a199 2
	if( cnt == 0 )  {
		fprintf(stderr,"ERROR: bu_malloc count=0 %s\n", str );
d203 2
a204 2
	if( cnt < sizeof( int ) ) {
		cnt = sizeof( int );
d209 1
a209 1
		cnt = (cnt+2*sizeof(long)-1)&(~(sizeof(long)-1));
d215 17
a231 1
	ptr = malloc(cnt);
d233 1
a233 1
		fprintf(stderr, "%8lx malloc%7d %s\n", (long)ptr, cnt, str);
d244 1
a244 1
		bu_memdebug_add( ptr, cnt, str );
d247 1
a247 1
		/* Correct location depends on 'cnt' being rounded up, above */
d249 1
a249 1
		*((long *)(((char *)ptr)+cnt-sizeof(long))) = MDB_MAGIC;
d256 28
a393 16
/*
 *			B U _ C A L L O C
 */
genptr_t
bu_calloc(unsigned int nelem,
	  unsigned int elsize,
	  const char *str)
{
	unsigned	len;
	genptr_t	ret;

	len = nelem*elsize;
	ret = bu_malloc( len, str );
	bzero( ret, len );
	return ret;
}
@


1.5
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/src/libbu/malloc.c,v 1.4 2004/08/03 20:42:29 morrison Exp $ (ARL)";
d309 8
a316 2
		fprintf(stderr,"%8lx realloc%6d %s %s\n", (long)ptr, cnt, str,
			ptr == original_ptr ? "[grew in place]" : "[moved]" );
d409 5
d418 1
a418 1
	base = bu_malloc( len, bu_strdup_message );
@


1.4
log
@apply Bob's provided patches from 20040630.  this includes itcl namespace scoping, windows DLL exporting, and wdb arb edit support
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/src/libbu/malloc.c,v 1.2 2004/06/08 19:28:50 morrison Exp $ (ARL)";
d38 1
a38 1
#ifdef USE_STRING_H
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d336 3
a338 1
bu_calloc(unsigned int nelem, unsigned int elsize, const char *str)
@


1.2
log
@poof goes the silly externs.h
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header$ (ARL)";
d33 1
a33 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d30 1
a30 1
static const char RCSmalloc[] = "@@(#)$Header: /cvs/brlcad/libbu/malloc.c,v 1.27 2004/05/10 15:30:44 erikg Exp $ (ARL)";
a46 1
#include "externs.h"
@

