head	14.36;
access;
symbols
	rel-7-10-4:14.27
	STABLE:14.27.0.2
	stable-branch:14.8
	rel-7-10-2:14.27
	rel-7-10-0:14.25
	rel-7-8-4:14.20
	rel-7-8-2:14.18
	rel-7-8-0:14.18
	trimnurbs-branch:14.16.0.2
	help:14.16
	temp_tag:14.15
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.15
	premerge-20051223-bobWinPort:14.15
	rel-7-6-6:14.15
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.8
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.5
	rel-7-0-branch:1.5.0.2
	rel-7-0:1.5;
locks; strict;
comment	@ * @;


14.36
date	2007.12.31.17.53.01;	author brlcad;	state Exp;
branches;
next	14.35;

14.35
date	2007.12.19.22.27.03;	author brlcad;	state Exp;
branches;
next	14.34;

14.34
date	2007.12.19.22.13.18;	author brlcad;	state Exp;
branches;
next	14.33;

14.33
date	2007.12.16.18.53.48;	author brlcad;	state Exp;
branches;
next	14.32;

14.32
date	2007.12.16.15.59.38;	author brlcad;	state Exp;
branches;
next	14.31;

14.31
date	2007.12.04.01.36.14;	author brlcad;	state Exp;
branches;
next	14.30;

14.30
date	2007.12.03.22.57.58;	author brlcad;	state Exp;
branches;
next	14.29;

14.29
date	2007.11.13.09.41.15;	author d_rossberg;	state Exp;
branches;
next	14.28;

14.28
date	2007.09.15.16.23.09;	author brlcad;	state Exp;
branches;
next	14.27;

14.27
date	2007.07.26.01.13.56;	author brlcad;	state Exp;
branches;
next	14.26;

14.26
date	2007.05.31.18.41.22;	author erikgreenwald;	state Exp;
branches;
next	14.25;

14.25
date	2007.02.20.08.19.48;	author brlcad;	state Exp;
branches;
next	14.24;

14.24
date	2007.02.01.22.15.40;	author brlcad;	state Exp;
branches;
next	14.23;

14.23
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.22;

14.22
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.21;

14.21
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.20;

14.20
date	2006.09.03.15.14.07;	author lbutler;	state Exp;
branches;
next	14.19;

14.19
date	2006.08.31.23.16.39;	author lbutler;	state Exp;
branches;
next	14.18;

14.18
date	2006.03.24.22.17.35;	author brlcad;	state Exp;
branches;
next	14.17;

14.17
date	2006.03.24.22.08.27;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches
	14.16.2.1;
next	14.15;

14.15
date	2005.12.18.20.24.22;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2005.12.18.16.24.57;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2005.12.17.19.27.28;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2005.12.14.02.27.05;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2005.12.13.21.34.35;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.9.4.1;
next	14.8;

14.8
date	2005.02.12.19.34.25;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.02.12.19.24.22;	author brlcad;	state Exp;
branches;
next	14.6;

14.6
date	2005.01.30.20.30.46;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.16.06.31.10;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.08.19.28.50;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.36;	author morrison;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;

14.16.2.1
date	2006.04.07.19.30.15;	author jlowenz;	state Exp;
branches;
next	;


desc
@@


14.36
log
@move bu_strdup_message out of malloc.c and into vls.c, add bu_vls_strcmp() and bu_vls_strncmp() as new functions instead of macros so the sanity checks can be added.
@
text
@/*                           V L S . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup vls */
/** @@{ */
/** @@file vls.c
 *
 *  @@brief The variable length string package.
 *
 *  The variable length string package.
 *
 *  Assumption:  libc-provided sprintf() function is safe to use in parallel,
 *  on parallel systems.
 *
 *  Authors -
 *	Michael John Muuss
 *	Christopher Sean Morrison
 */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdarg.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include "machine.h"
#include "bu.h"


const char bu_vls_message[] = "bu_vls_str";
const char bu_strdup_message[] = "bu_strdup string";

/**
 *			B U _ V L S _ I N I T
 *
 *  No storage should be allocated at this point,
 *  and bu_vls_addr() must be able to live with that.
 */
void
bu_vls_init(register struct bu_vls *vp)
{
    if (vp == (struct bu_vls  *)NULL)
	bu_bomb("bu_vls_init() passed NULL pointer");

    /* if it's already a vls, perform a sanity check that we're not
     * leaking memory.
     */
#if defined(DEBUG) && 0
    if (vp->vls_magic == BU_VLS_MAGIC) {
	if (vp->vls_str && vp->vls_len > 0 && vp->vls_max > 0) {
	    bu_log("bu_vls_init potential leak [%s] (vls_len=%d)\n", vp->vls_str, vp->vls_len);
	}
    }
#endif
    vp->vls_magic = BU_VLS_MAGIC;
    vp->vls_str = (char *)0;
    vp->vls_len = vp->vls_max = vp->vls_offset = 0;
}

/**
 *			B U _ V L S _ I N I T _ I F _ U N I N I T
 *
 *  If a VLS is unitialized, initialize it.
 *  If it is already initialized, leave it alone, caller wants to
 *  append to it.
 */
void
bu_vls_init_if_uninit(register struct bu_vls *vp)
{
    if (vp == (struct bu_vls  *)NULL)
	bu_bomb("bu_vls_init_if_uninit() passed NULL pointer");

    if( vp->vls_magic == BU_VLS_MAGIC )  return;
    bu_vls_init( vp );
}


/**
 *			B U _ V L S _ V L S I N I T
 *
 *  Allocate storage for a struct bu_vls, call bu_vls_init on it, and return
 *  the result.  Allows for creation of dynamically allocated vls strings.
 */
struct bu_vls *
bu_vls_vlsinit(void)
{
    register struct bu_vls	*vp;

    vp = (struct bu_vls *)bu_malloc(sizeof(struct bu_vls), "bu_vls_vlsinit struct");
    bu_vls_init(vp);

    return vp;
}

/**
 *			B U _ V L S _ A D D R
 *
 *  Return a pointer to the null-terminated string in the vls array.
 *  If no storage has been allocated yet, give back a valid string.
 */
char *
bu_vls_addr(register const struct bu_vls *vp)
{
    static char	nullbuf[4];

    BU_CK_VLS(vp);

    if( vp->vls_max == 0 || vp->vls_str == (char *)NULL )  {
	/* A zero-length VLS is a null string */
	nullbuf[0] = '\0';
	return(nullbuf);
    }

    /* Sanity checking */
    if( vp->vls_max < 0 ||
	vp->vls_len < 0 ||
	vp->vls_offset < 0 ||
	vp->vls_str == (char *)NULL ||
	vp->vls_len + vp->vls_offset >= vp->vls_max )  {
	bu_log("bu_vls_addr: bad VLS.  max=%d, len=%d, offset=%d\n",
	       vp->vls_max, vp->vls_len, vp->vls_offset);
	bu_bomb("bu_vls_addr\n");
    }

    return( vp->vls_str+vp->vls_offset );
}

/**
 *			B U _ V L S _ E X T E N D
 */
void
bu_vls_extend(register struct bu_vls *vp, unsigned int extra)
{
    BU_CK_VLS(vp);
    if( extra < 40 )  extra = 40;
    if( vp->vls_max <= 0 || vp->vls_str == (char *)0 )  {
	vp->vls_max = extra;
	vp->vls_str = (char *)bu_malloc( vp->vls_max, bu_vls_message );
	vp->vls_len = 0;
	vp->vls_offset = 0;
	*vp->vls_str = '\0';
	return;
    }
    if( vp->vls_offset + vp->vls_len + extra >= vp->vls_max )  {
	vp->vls_max += extra;
	if( vp->vls_max < 120 )  vp->vls_max = 120;
	vp->vls_str = (char *)bu_realloc( vp->vls_str, vp->vls_max,
					  bu_vls_message );
    }
}

/**
 *			B U _ V L S _ S E T L E N
 *
 *  Ensure that the vls has a length of at least 'newlen', and make
 *  that the current length.
 *  Useful for subroutines that are planning on mucking with the data
 *  array themselves.  Not advisable, but occasionally useful.
 *  Does not change the offset from the front of the buffer, if any.
 *  Does not initialize the value of any of the new bytes.
 */
void
bu_vls_setlen(struct bu_vls *vp, int newlen)
{
    BU_CK_VLS(vp);
    if( vp->vls_len >= newlen )  return;
    bu_vls_extend( vp, newlen - vp->vls_len );
    vp->vls_len = newlen;
}

/**
 *			B U _ V L S _ S T R L E N
 *
 *  Return length of the string, in bytes, not including the null terminator.
 */
int
bu_vls_strlen(register const struct bu_vls *vp)
{
    BU_CK_VLS(vp);
    if( vp->vls_len <= 0 )  return  0;
    return  vp->vls_len;
}

/**
 *			B U _ V L S _ T R U N C
 *
 *  Truncate string to at most 'len' characters.
 *  If 'len' is negative, trim off that many from the end.
 *  If 'len' is zero, don't release storage -- user is probably
 *  just going to refill it again, e.g. with bu_vls_gets().
 */
void
bu_vls_trunc(register struct bu_vls *vp, int len)
{
    BU_CK_VLS(vp);
    if( len < 0 )  len = vp->vls_len + len;	/* now an absolute length */
    if( vp->vls_len <= len )  return;
    if( len == 0 )  vp->vls_offset = 0;
    vp->vls_str[len+vp->vls_offset] = '\0';	/* force null termination */
    vp->vls_len = len;
}

/**
 *			B U _ V L S _ T R U N C 2
 *
 *  Son of bu_vls_trunc.
 *  Same as bu_vls_trunc except that it doesn't take negative len.
 */
void
bu_vls_trunc2(register struct bu_vls *vp, int len)
{
    BU_CK_VLS(vp);
    if( vp->vls_len <= len )  return;
    if( len < 0 )  len = 0;
    if( len == 0 )  vp->vls_offset = 0;
    vp->vls_str[len+vp->vls_offset] = '\0';	/* force null termination */
    vp->vls_len = len;
}

/**
 *			B U _ V L S _ N I B B L E
 *
 *  "Nibble" 'len' characters off the front of the string.
 *  Changes the length and offset;  no data is copied.
 *  'len' may be positive or negative.
 *  If negative, characters are un-nibbled.
 */
void
bu_vls_nibble(register struct bu_vls *vp, int len)
{
    BU_CK_VLS(vp);
    if( len < 0 && (-len) > vp->vls_offset )  len = -vp->vls_offset;
    if (len >= vp->vls_len) {
	bu_vls_trunc( vp, 0 );
	return;
    }
    vp->vls_len -= len;
    vp->vls_offset += len;
}

/**
 *			B U _ V L S _ F R E E
 *
 *  Releases the memory used for the string buffer.
 */
void
bu_vls_free(register struct bu_vls *vp)
{
    BU_CK_VLS(vp);
    if( vp->vls_str )  {
	vp->vls_str[0] = '?';		/* Sanity */
	bu_free( vp->vls_str, "bu_vls_free" );
	vp->vls_str = (char *)0;
    }
    vp->vls_offset = vp->vls_len = vp->vls_max = 0;
}

/**
 *			B U _ V L S _ V L S F R E E
 *
 *  Releases the memory used for the string buffer and the memory for
 *  the vls structure
 */
void
bu_vls_vlsfree(register struct bu_vls *vp)
{
    if ( *(long *)vp != BU_VLS_MAGIC) return;

    bu_vls_free( vp );
    bu_free( vp, "bu_vls_vlsfree" );
}

/**
 *			B U _ V L S _ S T R D U P
 *
 *  Make an "ordinary" string copy of a vls string.  Storage for the regular
 *  string is acquired using malloc.
 *  The source string is not affected.
 */
char *
bu_vls_strdup(register const struct bu_vls *vp)
{
    register char *str;
    register int len;

    len = bu_vls_strlen(vp);
    str = bu_malloc(len+1, bu_strdup_message );
    strncpy(str, bu_vls_addr(vp), len);
    str[len] = '\0';
    return str;
}

/**
 *			B U _ V L S _ S T R G R A B
 *
 *  Like bu_vls_strdup(), but destructively grab the string from the
 *  source argument 'vp'.  This is more efficient than bu_vls_strdup() for
 *  those instances where the source argument 'vp' is no longer needed
 *  by the caller, as it avoides a potentially long buffer copy.
 *
 *  The source string is destroyed, as if bu_vls_free() had been called.
 */
char *
bu_vls_strgrab(register struct bu_vls *vp)
{
    register char *str;

    BU_CK_VLS(vp);
    if( vp->vls_offset != 0 )  {
	str = bu_vls_strdup( vp );
	bu_vls_free( vp );
	return str;
    }

    str = bu_vls_addr( vp );
    vp->vls_str = (char *)0;
    vp->vls_offset = vp->vls_len = vp->vls_max = 0;
    return str;
}

/**
 *			B U _ V L S _ S T R C P Y
 *
 *  Empty the vls string, and copy in a regular string.
 */
void
bu_vls_strcpy(register struct bu_vls *vp, const char *s)
{
    register int	len;

    BU_CK_VLS(vp);
    if( s == (const char *)NULL )  return;
    if( (len = strlen(s)) <= 0 )  {
	vp->vls_len = 0;
	vp->vls_offset = 0;
	if(vp->vls_max > 0)
	    vp->vls_str[0] = '\0';
	return;
    }
    vp->vls_offset = 0;		/* cancel offset before extending */
    if( len+1 >= vp->vls_max )  bu_vls_extend( vp, len+1 );
    memcpy(vp->vls_str, s, len+1);		/* include null */
    vp->vls_len = len;
}

/**
 *			B U _ V L S _ S T R N C P Y
 *
 *  Empty the vls string, and copy in a regular string, up to N bytes long.
 */
void
bu_vls_strncpy(register struct bu_vls *vp, const char *s, long int n)
{
    register int	len;

    BU_CK_VLS(vp);
    if( s == (const char *)NULL )  return;
    len = strlen(s);
    if( len > n )  len = n;
    if( len <= 0 )  {
	vp->vls_len = 0;	/* ensure string is empty */
	return;
    }
    vp->vls_offset = 0;		/* cancel offset before extending */
    if( len+1 >= vp->vls_max )  bu_vls_extend( vp, len+1 );
    memcpy(vp->vls_str, s, len);
    vp->vls_str[len] = '\0';		/* force null termination */
    vp->vls_len = len;
}

/**
 *			B U _ V L S _ S T R C A T
 *
 *  Concatenate a new string onto the end of the existing vls string.
 */
void
bu_vls_strcat(register struct bu_vls *vp, const char *s)
{
    register int	len;

    BU_CK_VLS(vp);
    if( s == (const char *)NULL )  return;
    if( (len = strlen(s)) <= 0 )  return;
    if( vp->vls_offset + vp->vls_len + len+1 >= vp->vls_max )
	bu_vls_extend( vp, len+1 );
    memcpy(vp->vls_str +vp->vls_offset + vp->vls_len, s, len+1);	/* include null */
    vp->vls_len += len;
}

/**
 *			B U _ V L S _ S T R N C A T
 *
 *  Concatenate a new string onto the end of the existing vls string.
 */
void
bu_vls_strncat(register struct bu_vls *vp, const char *s, long int n)
{
    register int	len;

    BU_CK_VLS(vp);
    if( s == (const char *)NULL )  return;
    len = strlen(s);
    if( len > n )  len = n;
    if( len <= 0 )  return;			/* do nothing */
    if( vp->vls_offset + vp->vls_len + len+1 >= vp->vls_max )
	bu_vls_extend( vp, len+1 );
    memcpy(vp->vls_str + vp->vls_offset + vp->vls_len, s, len);
    vp->vls_len += len;
    vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
}


/**
 *			B U _ V L S _ V L S C A T
 *
 *  Concatenate a new vls string onto the end of an existing vls string.
 *  The storage of the source string is not affected.
 */
void
bu_vls_vlscat(register struct bu_vls *dest, register const struct bu_vls *src)
{
    BU_CK_VLS(src);
    BU_CK_VLS(dest);
    if( src->vls_len <= 0 )  return;
    if( dest->vls_offset + dest->vls_len + src->vls_len+1 >= dest->vls_max )
	bu_vls_extend( dest, src->vls_len+1 );
    /* copy source string, including null */
    memcpy(dest->vls_str +dest->vls_offset + dest->vls_len, src->vls_str+src->vls_offset, src->vls_len+1);
    dest->vls_len += src->vls_len;
}

/**
 *			V L S _ V L S C A T Z A P
 *
 *  Concatenate a new vls string onto the end of an existing vls string.
 *  The storage of the source string is released (zapped).
 */
void
bu_vls_vlscatzap(register struct bu_vls *dest, register struct bu_vls *src)
{
    BU_CK_VLS(src);
    BU_CK_VLS(dest);
    if( src->vls_len <= 0 )  return;
    bu_vls_vlscat( dest, src );
    bu_vls_trunc( src, 0 );
}


/**
 * b u _ v l s _ s t r c m p
 *
 * Lexicographically compare to vls strings.  Returns an integer
 * greater than, equal to, or less than 0, according as the string s1
 * is greater than, equal to, or less than the string s2.
 */
int
bu_vls_strcmp(struct bu_vls *s1, struct bu_vls *s2)
{
    BU_CK_VLS(s1);
    BU_CK_VLS(s2);

    return strcmp(s1->vls_str+s1->vls_offset, s2->vls_str+s2->vls_offset);
}


/**
 * b u _ v l s _ s t r n c m p
 *
 * Lexicographically compare two vls strings up to n characters.
 * Returns an integer greater than, equal to, or less than 0,
 * according as the string s1 is greater than, equal to, or less than
 * the string s2.
 */
int
bu_vls_strncmp(struct bu_vls *s1, struct bu_vls *s2, long n)
{
    BU_CK_VLS(s1);
    BU_CK_VLS(s2);

    if (n <= 0) {
	/* they match at zero chars */
	return 0;
    }

    return strncmp(s1->vls_str+s1->vls_offset, s2->vls_str+s2->vls_offset, n);
}


/**
 *			B U _ V L S _ F R O M _ A R G V
 *
 *  Given and argc & argv pair, convert them into a vls string of space-
 *  separated words.
 */
void
bu_vls_from_argv(register struct bu_vls *vp, int argc, const char *argv[])
{
    BU_CK_VLS(vp);
    for( ; argc > 0; argc--, argv++ )  {
	bu_vls_strcat( vp, *argv );
	if( argc > 1 )  bu_vls_strcat( vp, " " );
    }
}

/**
 *			B U _ A R G V _ F R O M _ S T R I N G
 *
 *  Build argv[] array from input buffer, by splitting whitespace
 *  separated "words" into null terminated strings.
 *  The input buffer is altered by this process.
 *  The argv[] array points into the input buffer.
 *  The input buffer should not be freed until argv has been freed
 *  or passes out of scope.
 *
 *  'lim' indicates the number of elements in the argv[] array.
 *
 *  Returns -
 *	 0	no words in input
 *	nwords	number of words of input, now in argv[]
 *
 *  Built from rt_split_cmd(), but without the shell escape support.
 */
int
bu_argv_from_string(char **argv, int lim, register char *lp)
{
    register int	nwords;			/* number of words seen */
    register char	*lp1;

    argv[0] = "_NIL_";		/* sanity */

    while( *lp != '\0' && isspace( *lp ) )
	lp++;

    if( *lp == '\0' )
	return 0;		/* No words */

    /* some non-space string has been seen, argv[0] is set */
    nwords = 1;
    argv[0] = lp;

    for( ; *lp != '\0'; lp++ )  {
	if( !isspace( *lp ) )
	    continue;	/* skip over current word */

	*lp = '\0';		/* terminate current word */
	lp1 = lp + 1;
	if( *lp1 != '\0' && !isspace( *lp1 ) )  {
	    /* Begin next word */
	    if( nwords >= lim-1 )
		break;	/* argv[] full */

	    argv[nwords++] = lp1;
	}
    }
    argv[nwords] = (char *)0;	/* safety */
    return nwords;
}

/**
 *			B U _ V L S _ F W R I T E
 */
void
bu_vls_fwrite(FILE *fp, const struct bu_vls *vp)
{
    int status;

    BU_CK_VLS(vp);
    if( vp->vls_len <= 0 )  return;

    bu_semaphore_acquire(BU_SEM_SYSCALL);
    status = fwrite( vp->vls_str + vp->vls_offset, vp->vls_len, 1, fp );
    bu_semaphore_release(BU_SEM_SYSCALL);

    if( status != 1 ) {
	perror("fwrite");
	bu_bomb("bu_vls_fwrite() write error\n");
    }
}

/**
 *			B U _ V L S _ W R I T E
 */
void
bu_vls_write( int fd, const struct bu_vls *vp )
{

    BU_CK_VLS(vp);
    if( vp->vls_len <= 0 )  return;

#if !defined(HAVE_UNIX_IO)
    bu_bomb("bu_vls_write(): This isn't UNIX\n");
#else
    {
	int status;
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	status = write( fd, vp->vls_str + vp->vls_offset, vp->vls_len );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( status != vp->vls_len ) {
	    perror("write");
	    bu_bomb("bu_vls_write() write error\n");
	}
    }
#endif
}

/**
 *			B U _ V L S _ R E A D
 *
 *  Read the remainder of a UNIX file onto the end of a vls.
 *
 *  Returns -
 *	nread	number of characters read
 *	0	if EOF encountered immediately
 *	-1	read error
 */
int
bu_vls_read( struct bu_vls *vp, int fd )
{
    int	ret = 0;

    BU_CK_VLS(vp);

#if !defined(HAVE_UNIX_IO)
    bu_bomb("bu_vls_read(): This isn't UNIX\n");
#else
    {
	int	todo;
	int	got;
	for(;;)  {
	    bu_vls_extend( vp, 4096 );
	    todo = vp->vls_max - vp->vls_len - vp->vls_offset - 1;

	    bu_semaphore_acquire(BU_SEM_SYSCALL);
	    got = read(fd, vp->vls_str+vp->vls_offset+vp->vls_len, todo );
	    bu_semaphore_release(BU_SEM_SYSCALL);

	    if( got < 0 )  {
		/* Read error, abandon the read */
		return -1;
	    }
	    if(got == 0)  break;
	    vp->vls_len += got;
	    ret += got;
	}

	/* force null termination */
	vp->vls_str[vp->vls_len+vp->vls_offset] = '\0';
    }
#endif
    return ret;
}

/**
 *			B U _ V L S _ G E T S
 *
 *  Append a newline-terminated string from the file pointed to by "fp"
 *  to the end of the vls pointed to by "vp".
 *  The newline from the file is read, but not stored into the vls.
 *
 *  The most common error is to forget to bu_vls_trunc(vp,0) before
 *  reading the next line into the vls.
 *
 *  Returns -
 *	>=0	the length of the resulting vls
 *	 -1	on EOF where no characters were added to the vls.
 */
int
bu_vls_gets(register struct bu_vls *vp, register FILE *fp)
{
    int	startlen;
    int	c;

    BU_CK_VLS(vp);

    startlen = bu_vls_strlen(vp);
    bu_vls_extend( vp, 80 );		/* Ensure room to grow */
    for( ;; )  {
	/* Talk about inefficiency... */
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	c = getc(fp);
	bu_semaphore_release( BU_SEM_SYSCALL );

	/* XXX Alternatively, code up something with bu_fgets(), chunking */

	if( c == EOF || c == '\n' )  break;
	bu_vls_putc( vp, c );
    }
    if( c == EOF && bu_vls_strlen(vp) <= startlen )  return -1;
    vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
    return bu_vls_strlen(vp);
}

/**
 *                      B U _ V L S _ P U T C
 *
 *  Append the given character to the vls.
 */
void
bu_vls_putc(register struct bu_vls *vp, int c)
{
    BU_CK_VLS(vp);

    if( vp->vls_offset + vp->vls_len+1 >= vp->vls_max )  bu_vls_extend( vp, 80 );
    vp->vls_str[vp->vls_offset + vp->vls_len++] = (char)c;
    vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
}

/**
 *			B U _ V L S _ T R I M S P A C E
 *
 *  Remove leading and trailing white space from a vls string.
 */
void
bu_vls_trimspace( struct bu_vls *vp )
{
    BU_CK_VLS(vp);

    /* Remove trailing white space */
    while( isspace( bu_vls_addr(vp)[bu_vls_strlen(vp)-1] ) )
	bu_vls_trunc( vp, -1 );

    /* Remove leading white space */
    while( isspace( *bu_vls_addr(vp) ) )
	bu_vls_nibble( vp, 1 );
}

/**
 *  			B U _ V L S _ V P R I N T F
 *
 *  Format a string into a vls.  This version should work on practically
 *  any machine, but it serves to highlight the the grossness of the varargs
 *  package requiring the size of a parameter to be known at compile time.
 *
 *  %s continues to be a regular 'C' string, null terminated.
 *  %S is a pointer to a (struct bu_vls *) string.
 *
 *  This routine appends to the given vls similar to how vprintf
 *  appends to stdout (see bu_vls_vsprintf for overwriting the vls).
 */
void
bu_vls_vprintf(struct bu_vls *vls, const char *fmt, va_list ap)
{
    register const char	*sp;			/* start pointer */
    register const char	*ep;			/* end pointer */
    register int len;

#define LONGINT  0x001
#define FIELDLEN 0x002
#define SHORTINT 0x003

    int flags;
    int fieldlen=-1;
    char fbuf[64] = {0}, buf[BUFSIZ] = {0};			/* % format buffer */

    if (!vls || !fmt || fmt[0] == '\0') {
	/* nothing to print to or from */
	return;
    }

    BU_CK_VLS(vls);
    bu_vls_extend(vls, 96);

    sp = fmt;
    while( *sp ) {
	/* Initial state:  just printing chars */
	fmt = sp;
	while (*sp != '%' && *sp)
	    sp++;

	if (sp != fmt)
	    bu_vls_strncat(vls, fmt, sp-fmt);

	if (*sp == '\0')
	    break;

	/* Saw a percent sign, find end of fmt specifier */

	flags = 0;
	ep = sp;
	while( *ep )  {
	    ++ep;
	    if (*ep == ' ' || *ep == '#' || *ep == '-' ||
		*ep == '+' || *ep == '.' || isdigit(*ep))
		continue;
	    else if (*ep == 'l' || *ep == 'U' || *ep == 'O')
		flags |= LONGINT;
	    else if (*ep == '*') {
		fieldlen = va_arg(ap, int);
		flags |= FIELDLEN;
	    } else if (*ep == 'h') {
		flags |= SHORTINT;
	    } else
		/* Anything else must be the end of the fmt specifier */
		break;
	}

	/* Copy off the format string */
	len = ep-sp+1;
	if (len > sizeof(fbuf)-1) len = sizeof(fbuf)-1;
	strncpy(fbuf, sp, len);
	fbuf[len] = '\0'; /* ensure null termination */

	/* Grab parameter from arg list, and print it */
	switch( *ep ) {
	    case 's':
		{
		    register char *str;

		    str = va_arg(ap, char *);
		    if (str)  {
			if (flags & FIELDLEN) {
			    int	stringlen = strlen(str);
			    int	left_justify;

			    if ((left_justify = (fieldlen < 0)))
				fieldlen *= -1;

			    if (stringlen >= fieldlen)
				bu_vls_strncat(vls, str, fieldlen);
			    else {
				struct bu_vls		padded;
				int			i;

				bu_vls_init(&padded);
				if (left_justify)
				    bu_vls_strcat(&padded, str);
				for (i = 0; i < fieldlen - stringlen; ++i)
				    bu_vls_putc(&padded, ' ');
				if (!left_justify)
				    bu_vls_strcat(&padded, str);
				bu_vls_vlscat(vls, &padded);
			    }
			} else {
			    bu_vls_strcat(vls, str);
			}
		    }  else  {
			if (flags & FIELDLEN)
			    bu_vls_strncat(vls, "(null)", fieldlen);
			else
			    bu_vls_strcat(vls, "(null)");
		    }
		}
		break;
	    case 'S':
		{
		    register struct bu_vls *vp;

		    vp = va_arg(ap, struct bu_vls *);
		    if (vp) {
			BU_CK_VLS(vp);
			if (flags & FIELDLEN) {
			    int	stringlen = bu_vls_strlen(vp);
			    int	left_justify;

			    if ((left_justify = (fieldlen < 0)))
				fieldlen *= -1;

			    if (stringlen >= fieldlen)
				bu_vls_strncat(vls, bu_vls_addr(vp), fieldlen);
			    else {
				struct bu_vls		padded;
				int			i;

				bu_vls_init(&padded);
				if (left_justify)
				    bu_vls_vlscat(&padded, vp);
				for (i = 0; i < fieldlen - stringlen; ++i)
				    bu_vls_putc(&padded, ' ');
				if (!left_justify)
				    bu_vls_vlscat(&padded, vp);
				bu_vls_vlscat(vls, &padded);
			    }
			} else {
			    bu_vls_vlscat(vls, vp);
			}
		    }  else  {
			if (flags & FIELDLEN)
			    bu_vls_strncat(vls, "(null)", fieldlen);
			else
			    bu_vls_strcat(vls, "(null)");
		    }
		}
		break;
	    case 'e':
	    case 'E':
	    case 'f':
	    case 'g':
	    case 'G':
		/* All floating point ==> "double" */
#if defined(LONGDBL)
		if (flags & LONGDBL) {
		    register long double ld;

		    ld = va_arg(ap, long double);
		    if (flags & FIELDLEN)
			snprintf(buf, BUFSIZ, fbuf, fieldlen, ld);
		    else
			snprintf(buf, BUFSIZ, fbuf, ld);
		    bu_vls_strcat(vls, buf);
		} else
#endif
		    {
			register double d;

			d = va_arg(ap, double);
			if (flags & FIELDLEN)
			    snprintf(buf, BUFSIZ, fbuf, fieldlen, d);
			else
			    snprintf(buf, BUFSIZ, fbuf, d);
			bu_vls_strcat(vls, buf);
		    }
		break;
	    case 'd':
	    case 'x':
		if (flags & LONGINT) {
		    /* Long int */
		    register long ll;

		    ll = va_arg(ap, long);
		    if (flags & FIELDLEN)
			snprintf(buf, BUFSIZ, fbuf, fieldlen, ll);
		    else
			snprintf(buf, BUFSIZ, fbuf, ll);
		    bu_vls_strcat(vls, buf);
		} else if (flags & SHORTINT) {
		    /* short int */
		    register short int sh;
		    sh = (short int)va_arg(ap, int);
		    if (flags & FIELDLEN)
			snprintf(buf, BUFSIZ, fbuf, fieldlen, sh);
		    else
			snprintf(buf, BUFSIZ, fbuf, sh);
		    bu_vls_strcat(vls, buf);
		} else {
		    /* Regular int */
		    register int j;

		    j = va_arg(ap, int);
		    if (flags & FIELDLEN)
			snprintf(buf, BUFSIZ, fbuf, fieldlen, j);
		    else
			snprintf(buf, BUFSIZ, fbuf, j);
		    bu_vls_strcat(vls, buf);
		}
		break;
	    case '%':
		bu_vls_putc(vls, '%');
		break;
	    default:  /* Something weird, maybe %c */
		{
		    register int j;

		    /* We hope, whatever it is, it fits in an int and the resulting
		       stringlet is smaller than sizeof(buf) bytes */

		    j = va_arg(ap, int);
		    if (flags & FIELDLEN)
			snprintf(buf, BUFSIZ, fbuf, fieldlen, j);
		    else
			snprintf(buf, BUFSIZ, fbuf, j);
		    bu_vls_strcat(vls, buf);
		    break;
		}
	}
	sp = ep+1;
    }

    va_end(ap);
}


/**
 *                 B U _ V L S _ P R I N T F
 *
 * Initializes the va_list, then calls the above bu_vls_vprintf.
 */
void
bu_vls_printf(struct bu_vls *vls, char *fmt, ...)  /* ANSI C */
{
    va_list ap;
    va_start(ap, fmt);
    BU_CK_VLS(vls);
    bu_vls_vprintf(vls, fmt, ap);
    va_end(ap);
}


/**
 *  			B U _ V L S _ S P R I N T F
 *
 *  Format a string into a vls, setting the vls to the given print
 *  specifier expansion.  This routine truncates any existing vls
 *  contents beforehand (i.e. it doesn't append, see bu_vls_vprintf
 *  for appending to the vls).
 *
 *  %s continues to be a regular 'C' string, null terminated.
 *  %S is a pointer to a (struct bu_vls *) string.
 */
void
bu_vls_sprintf(struct bu_vls *vls, char *fmt, ...)  /* ANSI C */
{
    va_list ap;
    va_start(ap, fmt);
    BU_CK_VLS(vls);
    bu_vls_trunc(vls, 0); /* poof */
    bu_vls_vprintf(vls, fmt, ap);
    va_end(ap);
}


/**
 *			B U _ V L S _ S P A C E S
 *
 *  Efficiently append 'cnt' spaces to the current vls.
 */
void
bu_vls_spaces(register struct bu_vls *vp, int cnt)
{
    BU_CK_VLS(vp);
    if( cnt <= 0 )  return;
    if( vp->vls_offset + vp->vls_len + cnt+1 >= vp->vls_max )
	bu_vls_extend( vp, cnt );
    memset(vp->vls_str + vp->vls_offset + vp->vls_len, ' ', cnt);
    vp->vls_len += cnt;
}

/**
 *			B U _ V L S _ P R I N T _ P O S I T I O N S _ U S E D
 *
 *  Returns number of printed spaces used on final output line of a
 *  potentially multi-line vls.  Useful for making decisions on when
 *  to line-wrap.
 *  Accounts for normal UNIX tab-expansion:
 *	         1         2         3         4
 *	1234567890123456789012345678901234567890
 *	        x       x       x       x
 *
 *	0-7 --> 8, 8-15 --> 16, 16-23 --> 24, etc.
 */
int
bu_vls_print_positions_used(const struct bu_vls *vp)
{
    char	*start;
    int	used;

    BU_CK_VLS(vp);

    if( (start = strrchr( bu_vls_addr(vp), '\n' )) == NULL )
	start = bu_vls_addr(vp);
    used = 0;
    while( *start != '\0' )  {
	if( *start == '\t' )  {
	    used += 8 - (used % 8);
	} else {
	    used++;
	}
	start++;
    }
    return used;
}

/**
 *			B U _ V L S _ D E T A B
 *
 *  Given a vls, return a version of that string which has had all
 *  "tab" characters converted to the appropriate number of spaces
 *  according to the UNIX tab convention.
 */
void
bu_vls_detab(struct bu_vls *vp)
{
    struct bu_vls	src;
    register char	*cp;
    int		used;

    BU_CK_VLS(vp);
    bu_vls_init( &src );
    bu_vls_vlscatzap( &src, vp );	/* make temporary copy of src */
    bu_vls_extend( vp, bu_vls_strlen(&src)+50 );

    cp = bu_vls_addr( &src );
    used = 0;
    while( *cp != '\0' )  {
	if( *cp == '\t' )  {
	    int	todo;
	    todo = 8 - (used % 8);
	    bu_vls_spaces( vp, todo );
	    used += todo;
	} else if( *cp == '\n' )  {
	    bu_vls_putc( vp, '\n' );
	    used = 0;
	} else {
	    bu_vls_putc( vp, *cp );
	    used++;
	}
	cp++;
    }
    bu_vls_free( &src );
}

/**
 *		B U _ V L S _ P R E P E N D
 *
 *  Add a string to the begining of the vls.
 */
void
bu_vls_prepend(struct bu_vls *vp, char *str)
{
    int len = strlen(str);

    bu_vls_extend(vp, len);

    /* memmove is supposed to be safe even if strings overlap */
    memmove( vp->vls_str+vp->vls_offset+len, vp->vls_str+vp->vls_offset, vp->vls_len );

    /* insert the data at the head of the string */
    memcpy(vp->vls_str+vp->vls_offset, str, len);
}
/** @@} */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.35
log
@gah, I'm making a habit of this lately or apparently too much shell scripting, haven't made these typos in years
@
text
@d31 1
a31 1
 *  @@author
d33 1
a33 1
 *
a35 2
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.34 2007/12/19 22:13:18 brlcad Exp $ (BRL)";

d53 1
a53 1
extern const char bu_strdup_message[];
d434 1
d470 41
@


14.34
log
@return gracefully instead of bombing if there is nothing to print into, or nothing to print in bu_vls_vprintf
@
text
@d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.33 2007/12/16 18:53:48 brlcad Exp $ (BRL)";
d738 1
a738 1
    if (!vls || !fmt || fmt[0] = '\0') {
@


14.33
log
@convert usages of bcopy to memcpy throughout.  although none of them should be buffers that overlap per machine.h history, all calls were individually checked regardless. new code should not use bzero/bcopy any more.
@
text
@d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.32 2007/12/16 15:59:38 brlcad Exp $ (BRL)";
d738 5
@


14.32
log
@convert all bzero calls to memset
@
text
@d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.31 2007/12/04 01:36:14 brlcad Exp $ (BRL)";
d366 1
a366 1
    bcopy( s, vp->vls_str, len+1 );		/* include null */
d390 1
a390 1
    bcopy( s, vp->vls_str, len );
d410 1
a410 1
    bcopy( s, vp->vls_str +vp->vls_offset + vp->vls_len, len+1 );	/* include null */
d431 1
a431 1
    bcopy( s, vp->vls_str + vp->vls_offset + vp->vls_len, len );
d451 1
a451 3
    bcopy( src->vls_str+src->vls_offset,
	   dest->vls_str +dest->vls_offset + dest->vls_len,
	   src->vls_len+1 );
d1095 1
a1095 1
    memcpy( vp->vls_str+vp->vls_offset, str, len);
@


14.31
log
@remove the last traces of stdarg/vararg testing.  c89 conformance provides the stdarg interface.
@
text
@d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.30 2007/12/03 22:57:58 brlcad Exp $ (BRL)";
d1003 1
a1003 1
    memset( vp->vls_str + vp->vls_offset + vp->vls_len, ' ', cnt );
@


14.30
log
@c89 simplification.  assume stdarg is a given.
@
text
@d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.29 2007/11/13 09:41:15 d_rossberg Exp $ (BRL)";
a45 3
#if !defined(HAVE_STDARG_H) && defined(HAVE_VARARGS_H)
#  include <varargs.h>
#endif
a711 1
#if defined(HAVE_VARARGS_H) || defined(HAVE_STDARG_H)
a949 3
#else
#  error "No implementation provided for bu_vls_vprintf()"
#endif  /* !defined(HAVE_VARARGS_H) && !defined(HAVE_STDARG_H) */
a951 1
#if defined(HAVE_STDARG_H)
a966 42
#else  /* !HAVE_STDARG_H */
#  if defined(HAVE_VARARGS_H)

void
bu_vls_printf(va_dcl va_alist)                            /* VARARGS */
{
    va_list ap;
    struct bu_vls *vls;
    char *fmt;

    va_start(ap);
    vls = va_arg(ap, struct bu_vls *);
    fmt = va_arg(ap, char *);
    BU_CK_VLS(vls);
    bu_vls_vprintf(vls, fmt, ap);
    va_end(ap);
}

#  else  /* !HAVE_VARARGS_H */

void
bu_vls_printf(struct bu_vls *vls, char *fmt, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j)       /* Cray XMP */
{
    char append_buf[65536] = {0};   /* yuck -- fixed length buffer. */

    BU_CK_VLS(vls);
    snprintf(append_buf, 65536, fmt, a,b,c,d,e,f,g,h,i,j);
    if (append_buf[sizeof(append_buf)-1] != '\0') {
	/* Attempting to bu_log() the WHOLE append_buf would just overflow again */
	append_buf[120] = '\0';
	bu_log("bu_vls_printf buffer overflow\nWhile building string '%s'...\n",
	       append_buf);
	bu_bomb("bu_vls_printf buffer overflow\n");
    }

    bu_vls_strcat(vls, append_buf);
}
#  endif  /* HAVE_VARARGS_H */
#endif  /* HAVE_STDARG_H */


#if defined(HAVE_STDARG_H)
a989 30
#else  /* !HAVE_STDARG_H */
#  if defined(HAVE_VARARGS_H)

void
bu_vls_sprintf(va_dcl va_alist)                            /* VARARGS */
{
    va_list ap;
    struct bu_vls *vls;
    char *fmt;

    va_start(ap);
    vls = va_arg(ap, struct bu_vls *);
    fmt = va_arg(ap, char *);
    BU_CK_VLS(vls);
    bu_vls_trunc(vls, 0); /* poof */
    bu_vls_vprintf(vls, fmt, ap);
    va_end(ap);
}

#  else  /* !HAVE_VARARGS_H */

void
bu_vls_sprintf(struct bu_vls *vls, char *fmt, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j)       /* Cray XMP */
{
    BU_CK_VLS(vls);
    bu_vls_trunc(vls, 0); /* poof */
    bu_vls_printf(vls, fmt, a, b, c, d, e, f, g, h, i, j);
}
#  endif  /* HAVE_VARARGS_H */
#endif  /* HAVE_STDARG_H */
@


14.29
log
@protect the vararg function declaration in bu.h with the same defines as used in the definition in libbu/vls.c
remove redundant declaration in libbu/vls.c
@
text
@d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.28 2007/09/15 16:23:09 brlcad Exp $ (BRL)";
d44 1
a45 3
#if defined(HAVE_STDARG_H)
#  include <stdarg.h>
#endif
@


14.28
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.27 2007/07/26 01:13:56 brlcad Exp $ (BRL)";
a57 3
#if defined(HAVE_VARARGS_H) || defined(HAVE_STDARG_H)
BU_EXTERN(void	bu_vls_vprintf, (struct bu_vls *vls, const char *fmt, va_list ap));
#endif
@


14.27
log
@remove ephemeral data like phone numbers and addresses, including the misleading 'source' statements on code that is continually evolving and receiving contributions from many many sources
@
text
@d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.26 2007/05/31 18:41:22 erikgreenwald Exp $ (BRL)";
d43 2
a44 5
#ifdef HAVE_STRING_H
#  include <string.h>
#else
#  include <strings.h>
#endif
a45 1
/* ANSI C */
a48 1
/* VARARGS */
@


14.26
log
@some sprintf->snprintf
@
text
@a33 5
 *  @@par Source -
 *	SECAD/VLD Computing Consortium, Bldg 394
 *@@n	The U. S. Army Ballistic Research Laboratory
 *@@n	Aberdeen Proving Ground, Maryland  21005-5066
 *
d36 1
a36 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.25 2007/02/20 08:19:48 brlcad Exp $ (BRL)";
@


14.25
log
@update all usages of fgets() to instead use john's swanktastic bu_fgets() that behaves as one would generally want regardless of the line ending type of the compilation platform or of the input files.  bu_fgets() responds to input files that use CR (usually old mac), LF (usually unix, new mac), or CR/LF (usually windows) for the line ending so now these file do too effectivley squashing buggish/bad behavior.
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.24 2007/02/01 22:15:40 brlcad Exp $ (BRL)";
d757 1
a757 1
    char fbuf[64] = {0}, buf[1024] = {0};			/* % format buffer */
d895 1
a895 1
			sprintf(buf, fbuf, fieldlen, ld);
d897 1
a897 1
			sprintf(buf, fbuf, ld);
d906 1
a906 1
			    sprintf(buf, fbuf, fieldlen, d);
d908 1
a908 1
			    sprintf(buf, fbuf, d);
d920 1
a920 1
			sprintf(buf, fbuf, fieldlen, ll);
d922 1
a922 1
			sprintf(buf, fbuf, ll);
d929 1
a929 1
			sprintf(buf, fbuf, fieldlen, sh);
d931 1
a931 1
			sprintf(buf, fbuf, sh);
d939 1
a939 1
			sprintf(buf, fbuf, fieldlen, j);
d941 1
a941 1
			sprintf(buf, fbuf, j);
d957 1
a957 1
			sprintf(buf, fbuf, fieldlen, j);
d959 1
a959 1
			sprintf(buf, fbuf, j);
d1016 1
a1016 1
    sprintf(append_buf, fmt, a,b,c,d,e,f,g,h,i,j);
@


14.24
log
@provide types for the cray func prototype for bu_vls_printf and bu_vls_sprintf now that the function is unk&rified
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.23 2007/01/23 01:13:34 brlcad Exp $ (BRL)";
d686 1
a686 1
	/* XXX Alternatively, code up something with fgets(), chunking */
@


14.23
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.22 2007/01/21 04:45:42 brlcad Exp $ (BRL)";
d1011 1
a1011 1
bu_vls_printf(struct bu_vls *vls, char *fmt, a,b,c,d,e,f,g,h,i,j)       /* Cray XMP */
d1077 1
a1077 1
bu_vls_sprintf(struct bu_vls *vls, char *fmt, a,b,c,d,e,f,g,h,i,j)       /* Cray XMP */
@


14.22
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.21 2007/01/20 14:36:51 brlcad Exp $ (BRL)";
@


14.21
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup vls */
/*@@{*/
d42 1
a42 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.20 2006/09/03 15:14:07 lbutler Exp $ (BRL)";
d1195 1
a1195 1
/*@@}*/
@


14.20
log
@Doxygen updates
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d43 1
a43 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.19 2006/08/31 23:16:39 lbutler Exp $ (BRL)";
@


14.19
log
@Doxygen comments
@
text
@d25 3
d43 1
a43 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.18 2006/03/24 22:17:35 brlcad Exp $ (BRL)";
@


14.18
log
@final touches, missing header
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d30 1
a30 1
 *  Author -
d33 1
a33 1
 *  Source -
d35 2
a36 2
 *	The U. S. Army Ballistic Research Laboratory
 *	Aberdeen Proving Ground, Maryland  21005-5066
a38 1
/*@@}*/
d40 1
a40 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.17 2006/03/24 22:08:27 brlcad Exp $ (BRL)";
d1193 1
@


14.17
log
@quell intel 9 compiler on altix warnings
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.16 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
d61 3
@


14.16
log
@update copyright to 2006
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.15 2005/12/18 20:24:22 brlcad Exp $ (BRL)";
d45 1
@


14.16.2.1
log
@update from HEAD
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.16 2006/01/18 06:46:16 brlcad Exp $ (BRL)";
a44 1
#include <stdlib.h>
a59 3
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
@


14.15
log
@there are apparently a lot of these, so disable the check for now until it's determined why this happens
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.14 2005/12/18 16:24:57 brlcad Exp $ (BRL)";
@


14.14
log
@revert the free'ing of memory on bu_vls_init -- instead report on the issue so that those callers may be fixed.
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.13 2005/12/17 19:27:28 brlcad Exp $ (BRL)";
d86 1
d89 1
a89 1
	    bu_log("bu_vls_init potential leak [%s]", vp->vls_str);
d92 1
@


14.13
log
@add a bu_vls_sprintf() that differs from bu_vls_printf() in that it truncates the vls before printing into it, whereas the printf variant appends. doxygenify the existing comments while we're in here.
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.12 2005/12/14 02:27:05 brlcad Exp $ (BRL)";
d83 2
a84 2
    /* if it's already a vls, make sure we free any associated
     * string space allocated.
d88 1
a88 2
	    vp->vls_str[0] = '?'; /* sanity */
	    bu_free(vp->vls_str, "bu_vls_init");
d751 1
a751 1
    char fbuf[64], buf[1024];			/* % format buffer */
@


14.12
log
@make sure the supposedly valid vls string pointer is actually allocated some space before trying to free it on the offchance that the magic was set and no space was allocated yet.
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.11 2005/12/13 21:34:35 brlcad Exp $ (BRL)";
d71 1
a71 1
/*
d97 1
a97 1
/*
d115 1
a115 1
/*
d132 1
a132 1
/*
d165 1
a165 1
/*
d189 1
a189 1
/*
d208 1
a208 1
/*
d221 1
a221 1
/*
d240 1
a240 1
/*
d257 1
a257 1
/*
d277 2
a278 1
/*
d295 1
a295 1
/*
d310 2
a311 1
/*			B U _ V L S _ S T R D U P
d330 1
a330 1
/*
d358 1
a358 1
/*
d383 1
a383 1
/*
d408 1
a408 1
/*
d427 1
a427 1
/*
d449 1
a449 1
/*
d470 1
a470 1
/*
d486 1
a486 1
/*
d502 1
a502 1
/*
d556 1
a556 1
/*
d577 1
a577 1
/*
d604 1
a604 1
/*
d651 1
a651 1
/*
d691 1
a691 1
/*
d706 1
a706 1
/*
d726 1
a726 2

/*
d735 3
a738 1

d964 3
a967 1
#endif
d969 2
a970 1
/*
a974 3

#if defined(HAVE_STDARG_H)

d985 1
a985 1
#else
d989 1
a989 2
bu_vls_printf(va_alist)                            /* VARARGS */
     va_dcl
d1003 1
a1003 1
#  else
d1006 1
a1006 3
bu_vls_printf(vls, fmt, a,b,c,d,e,f,g,h,i,j)       /* Cray XMP */
     struct bu_vls *vls;
     char *fmt;
d1022 27
d1050 30
a1079 2
#  endif
#endif
d1081 1
a1081 1
/*
d1097 1
a1097 1
/*
d1132 1
a1132 1
/*
d1171 2
a1172 1
/*		B U _ V L S _ P R E P E N D
@


14.11
log
@if bu_vls_init is called on a vls that already has space allocated, be sure to free that space before wiping out the pointer to prevent memory leaks and safely allow multiple init calls
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.10 2005/10/23 04:44:32 brlcad Exp $ (BRL)";
d87 1
a87 1
	if (vp->vls_str) {
@


14.10
log
@trailing ws
@
text
@d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.9 2005/08/12 22:29:23 lbutler Exp $ (BRL)";
d83 9
d94 1
a94 2
    vp->vls_len = vp->vls_max = 0;
    vp->vls_offset = 0;
@


14.9
log
@Doxygen changes
@
text
@d37 1
a37 1
 *  
d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.8 2005/02/12 19:34:25 brlcad Exp $ (BRL)";
d116 1
a116 1
    register struct bu_vls	*vp;	
d561 1
a561 1
    if( status != 1 ) {    
d586 1
a586 1
	if( status != vp->vls_len ) {    
d719 1
a719 1
 *  
d785 1
a785 1
		
d788 1
a788 1
	    case 's': 
d827 1
a827 1
	    case 'S': 
d901 1
a901 1
		
d920 1
a920 1
		
d938 1
a938 1
		
d973 1
a973 1
	
d1011 1
a1011 1
	
@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d37 1
a37 1
 *
d41 1
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header$ (BRL)";
d116 1
a116 1
    register struct bu_vls	*vp;
d561 1
a561 1
    if( status != 1 ) {
d586 1
a586 1
	if( status != vp->vls_len ) {
d719 1
a719 1
 *
d785 1
a785 1

d788 1
a788 1
	    case 's':
d827 1
a827 1
	    case 'S':
d901 1
a901 1

d920 1
a920 1

d938 1
a938 1

d973 1
a973 1

d1011 1
a1011 1

@


14.8
log
@more indent testing -- misplaced braces are nasty
@
text
@d21 3
a24 1
 *
d39 3
a41 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.7 2005/02/12 19:24:22 brlcad Exp $ (BRL)";
@


14.7
log
@M-x indent-region
@
text
@d37 1
a37 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.6 2005/01/30 20:30:46 brlcad Exp $ (BRL)";
a40 2


d44 1
a44 1
#include <string.h>
d46 1
a46 1
#include <strings.h>
d50 1
a50 1
# include <stdarg.h>
d54 1
a54 1
# include <varargs.h>
d783 4
a786 4
	switch( *ep )  {
	case 's':
	    {
		register char *str;
d788 3
a790 4
		str = va_arg(ap, char *);
		if (str)  {
		    if (flags & FIELDLEN)
			{
d799 13
a811 14
			    else
				{
				    struct bu_vls		padded;
				    int			i;

				    bu_vls_init(&padded);
				    if (left_justify)
					bu_vls_strcat(&padded, str);
				    for (i = 0; i < fieldlen - stringlen; ++i)
					bu_vls_putc(&padded, ' ');
				    if (!left_justify)
					bu_vls_strcat(&padded, str);
				    bu_vls_vlscat(vls, &padded);
				}
d815 6
a820 5
		}  else  {
		    if (flags & FIELDLEN)
			bu_vls_strncat(vls, "(null)", fieldlen);
		    else
			bu_vls_strcat(vls, "(null)");
d822 4
a825 5
	    }
	    break;
	case 'S':
	    {
		register struct bu_vls *vp;
d827 2
a828 3
		vp = va_arg(ap, struct bu_vls *);
		if (vp)
		    {
d830 21
a850 26
			if (flags & FIELDLEN)
			    {
				int	stringlen = bu_vls_strlen(vp);
				int	left_justify;

				if ((left_justify = (fieldlen < 0)))
				    fieldlen *= -1;

				if (stringlen >= fieldlen)
				    bu_vls_strncat(vls, bu_vls_addr(vp), fieldlen);
				else
				    {
					struct bu_vls		padded;
					int			i;

					bu_vls_init(&padded);
					if (left_justify)
					    bu_vls_vlscat(&padded, vp);
					for (i = 0; i < fieldlen - stringlen; ++i)
					    bu_vls_putc(&padded, ' ');
					if (!left_justify)
					    bu_vls_vlscat(&padded, vp);
					bu_vls_vlscat(vls, &padded);
				    }
			    } else {
				bu_vls_vlscat(vls, vp);
d852 3
d861 8
a868 8
	    }
	    break;
	case 'e':
	case 'E':
	case 'f':
	case 'g':
	case 'G':
	    /* All floating point ==> "double" */
d870 2
a871 2
	    if (flags & LONGDBL) {
		register long double ld;
d873 7
a879 7
		ld = va_arg(ap, long double);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, ld);
		else
		    sprintf(buf, fbuf, ld);
		bu_vls_strcat(vls, buf);
	    } else
d881 2
a882 2
		{
		    register double d;
d884 34
a917 1
		    d = va_arg(ap, double);
d919 1
a919 1
			sprintf(buf, fbuf, fieldlen, d);
d921 1
a921 1
			sprintf(buf, fbuf, d);
d924 7
a930 40
	    break;
	case 'd':
	case 'x':
	    if (flags & LONGINT) {
		/* Long int */
		register long ll;
		
		ll = va_arg(ap, long);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, ll);
		else
		    sprintf(buf, fbuf, ll);
		bu_vls_strcat(vls, buf);
	    } else if (flags & SHORTINT) {
		/* short int */
		register short int sh;
		sh = (short int)va_arg(ap, int);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, sh);
		else
		    sprintf(buf, fbuf, sh);
		bu_vls_strcat(vls, buf);
	    } else {
		/* Regular int */
		register int j;
		
		j = va_arg(ap, int);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, j);
		else
		    sprintf(buf, fbuf, j);
		bu_vls_strcat(vls, buf);
	    }
	    break;
	case '%':
	    bu_vls_putc(vls, '%');
	    break;
	default:  /* Something weird, maybe %c */
	    {
		register int j;
d932 2
a933 2
		/* We hope, whatever it is, it fits in an int and the resulting
		   stringlet is smaller than sizeof(buf) bytes */
d935 8
a942 8
		j = va_arg(ap, int);
		if (flags & FIELDLEN)
		    sprintf(buf, fbuf, fieldlen, j);
		else
		    sprintf(buf, fbuf, j);
		bu_vls_strcat(vls, buf);
		break;
	    }
@


14.6
log
@update copyright to 2005
@
text
@d37 1
a37 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/vls.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (BRL)";
d78 2
a79 2
	if (vp == (struct bu_vls  *)NULL)
		bu_bomb("bu_vls_init() passed NULL pointer");
d81 4
a84 4
	vp->vls_magic = BU_VLS_MAGIC;
	vp->vls_str = (char *)0;
	vp->vls_len = vp->vls_max = 0;
	vp->vls_offset = 0;
d97 2
a98 2
	if (vp == (struct bu_vls  *)NULL)
		bu_bomb("bu_vls_init_if_uninit() passed NULL pointer");
d100 2
a101 2
	if( vp->vls_magic == BU_VLS_MAGIC )  return;
	bu_vls_init( vp );
d114 1
a114 1
	register struct bu_vls	*vp;	
d116 2
a117 2
	vp = (struct bu_vls *)bu_malloc(sizeof(struct bu_vls), "bu_vls_vlsinit struct");
	bu_vls_init(vp);
d119 1
a119 1
	return vp;
d131 1
a131 1
	static char	nullbuf[4];
d133 1
a133 1
	BU_CK_VLS(vp);
d135 5
a139 5
	if( vp->vls_max == 0 || vp->vls_str == (char *)NULL )  {
		/* A zero-length VLS is a null string */
		nullbuf[0] = '\0';
		return(nullbuf);
	}
d141 10
a150 10
	/* Sanity checking */
	if( vp->vls_max < 0 ||
		vp->vls_len < 0 ||
		vp->vls_offset < 0 ||
		vp->vls_str == (char *)NULL ||
		vp->vls_len + vp->vls_offset >= vp->vls_max )  {
		bu_log("bu_vls_addr: bad VLS.  max=%d, len=%d, offset=%d\n",
		   vp->vls_max, vp->vls_len, vp->vls_offset);
		bu_bomb("bu_vls_addr\n");
	}
d152 1
a152 1
	return( vp->vls_str+vp->vls_offset );
d161 16
a176 16
	BU_CK_VLS(vp);
	if( extra < 40 )  extra = 40;
	if( vp->vls_max <= 0 || vp->vls_str == (char *)0 )  {
		vp->vls_max = extra;
		vp->vls_str = (char *)bu_malloc( vp->vls_max, bu_vls_message );
		vp->vls_len = 0;
		vp->vls_offset = 0;
		*vp->vls_str = '\0';
		return;
	}
	if( vp->vls_offset + vp->vls_len + extra >= vp->vls_max )  {
		vp->vls_max += extra;
		if( vp->vls_max < 120 )  vp->vls_max = 120;
		vp->vls_str = (char *)bu_realloc( vp->vls_str, vp->vls_max,
			bu_vls_message );
	}
d192 4
a195 4
	BU_CK_VLS(vp);
	if( vp->vls_len >= newlen )  return;
	bu_vls_extend( vp, newlen - vp->vls_len );
	vp->vls_len = newlen;
d206 3
a208 3
	BU_CK_VLS(vp);
	if( vp->vls_len <= 0 )  return  0;
	return  vp->vls_len;
d222 6
a227 6
	BU_CK_VLS(vp);
	if( len < 0 )  len = vp->vls_len + len;	/* now an absolute length */
	if( vp->vls_len <= len )  return;
	if( len == 0 )  vp->vls_offset = 0;
	vp->vls_str[len+vp->vls_offset] = '\0';	/* force null termination */
	vp->vls_len = len;
d239 6
a244 6
	BU_CK_VLS(vp);
	if( vp->vls_len <= len )  return;
	if( len < 0 )  len = 0;
	if( len == 0 )  vp->vls_offset = 0;
	vp->vls_str[len+vp->vls_offset] = '\0';	/* force null termination */
	vp->vls_len = len;
d258 8
a265 8
	BU_CK_VLS(vp);
	if( len < 0 && (-len) > vp->vls_offset )  len = -vp->vls_offset;
	if (len >= vp->vls_len) {
		bu_vls_trunc( vp, 0 );
		return;
	}
	vp->vls_len -= len;
	vp->vls_offset += len;
d275 7
a281 7
	BU_CK_VLS(vp);
	if( vp->vls_str )  {
		vp->vls_str[0] = '?';		/* Sanity */
		bu_free( vp->vls_str, "bu_vls_free" );
		vp->vls_str = (char *)0;
	}
	vp->vls_offset = vp->vls_len = vp->vls_max = 0;
d293 1
a293 1
	if ( *(long *)vp != BU_VLS_MAGIC) return;
d295 2
a296 2
	bu_vls_free( vp );
	bu_free( vp, "bu_vls_vlsfree" );
d308 2
a309 2
	register char *str;
	register int len;
d311 5
a315 5
	len = bu_vls_strlen(vp);
	str = bu_malloc(len+1, bu_strdup_message );
	strncpy(str, bu_vls_addr(vp), len);
	str[len] = '\0';
	return str;
d331 1
a331 1
	register char *str;
d333 6
a338 6
	BU_CK_VLS(vp);
	if( vp->vls_offset != 0 )  {
		str = bu_vls_strdup( vp );
		bu_vls_free( vp );
		return str;
	}
d340 4
a343 4
	str = bu_vls_addr( vp );
	vp->vls_str = (char *)0;
	vp->vls_offset = vp->vls_len = vp->vls_max = 0;
	return str;
d354 1
a354 1
	register int	len;
d356 13
a368 13
	BU_CK_VLS(vp);
	if( s == (const char *)NULL )  return;
	if( (len = strlen(s)) <= 0 )  {
		vp->vls_len = 0;
		vp->vls_offset = 0;
		if(vp->vls_max > 0)
			vp->vls_str[0] = '\0';
		return;
	}
	vp->vls_offset = 0;		/* cancel offset before extending */
	if( len+1 >= vp->vls_max )  bu_vls_extend( vp, len+1 );
	bcopy( s, vp->vls_str, len+1 );		/* include null */
	vp->vls_len = len;
d379 1
a379 1
	register int	len;
d381 13
a393 13
	BU_CK_VLS(vp);
	if( s == (const char *)NULL )  return;
	len = strlen(s);
	if( len > n )  len = n;
	if( len <= 0 )  {
		vp->vls_len = 0;	/* ensure string is empty */
		return;
	}
	vp->vls_offset = 0;		/* cancel offset before extending */
	if( len+1 >= vp->vls_max )  bu_vls_extend( vp, len+1 );
	bcopy( s, vp->vls_str, len );
	vp->vls_str[len] = '\0';		/* force null termination */
	vp->vls_len = len;
d404 1
a404 1
	register int	len;
d406 7
a412 7
	BU_CK_VLS(vp);
	if( s == (const char *)NULL )  return;
	if( (len = strlen(s)) <= 0 )  return;
	if( vp->vls_offset + vp->vls_len + len+1 >= vp->vls_max )
		bu_vls_extend( vp, len+1 );
	bcopy( s, vp->vls_str +vp->vls_offset + vp->vls_len, len+1 );	/* include null */
	vp->vls_len += len;
d423 1
a423 1
	register int	len;
d425 10
a434 10
	BU_CK_VLS(vp);
	if( s == (const char *)NULL )  return;
	len = strlen(s);
	if( len > n )  len = n;
	if( len <= 0 )  return;			/* do nothing */
	if( vp->vls_offset + vp->vls_len + len+1 >= vp->vls_max )
		bu_vls_extend( vp, len+1 );
	bcopy( s, vp->vls_str + vp->vls_offset + vp->vls_len, len );
	vp->vls_len += len;
	vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
d446 10
a455 10
	BU_CK_VLS(src);
	BU_CK_VLS(dest);
	if( src->vls_len <= 0 )  return;
	if( dest->vls_offset + dest->vls_len + src->vls_len+1 >= dest->vls_max )
		bu_vls_extend( dest, src->vls_len+1 );
	/* copy source string, including null */
	bcopy( src->vls_str+src->vls_offset,
		dest->vls_str +dest->vls_offset + dest->vls_len,
		src->vls_len+1 );
	dest->vls_len += src->vls_len;
d467 5
a471 5
	BU_CK_VLS(src);
	BU_CK_VLS(dest);
	if( src->vls_len <= 0 )  return;
	bu_vls_vlscat( dest, src );
	bu_vls_trunc( src, 0 );
d483 5
a487 5
	BU_CK_VLS(vp);
	for( ; argc > 0; argc--, argv++ )  {
		bu_vls_strcat( vp, *argv );
		if( argc > 1 )  bu_vls_strcat( vp, " " );
	}
d511 2
a512 2
	register int	nwords;			/* number of words seen */
	register char	*lp1;
d514 1
a514 1
	argv[0] = "_NIL_";		/* sanity */
d516 2
a517 2
	while( *lp != '\0' && isspace( *lp ) )
		lp++;
d519 2
a520 2
	if( *lp == '\0' )
		return 0;		/* No words */
d522 3
a524 3
	/* some non-space string has been seen, argv[0] is set */
	nwords = 1;
	argv[0] = lp;
d526 3
a528 3
	for( ; *lp != '\0'; lp++ )  {
		if( !isspace( *lp ) )
			continue;	/* skip over current word */
d530 6
a535 6
		*lp = '\0';		/* terminate current word */
		lp1 = lp + 1;
		if( *lp1 != '\0' && !isspace( *lp1 ) )  {
			/* Begin next word */
			if( nwords >= lim-1 )
				break;	/* argv[] full */
d537 1
a537 2
			argv[nwords++] = lp1;
		}
d539 3
a541 2
	argv[nwords] = (char *)0;	/* safety */
	return nwords;
d550 1
a550 1
	int status;
d552 2
a553 2
	BU_CK_VLS(vp);
	if( vp->vls_len <= 0 )  return;
d555 8
a562 8
	bu_semaphore_acquire(BU_SEM_SYSCALL);
	status = fwrite( vp->vls_str + vp->vls_offset, vp->vls_len, 1, fp );
	bu_semaphore_release(BU_SEM_SYSCALL);

	if( status != 1 ) {    
		perror("fwrite");
		bu_bomb("bu_vls_fwrite() write error\n");
	}
d572 2
a573 2
	BU_CK_VLS(vp);
	if( vp->vls_len <= 0 )  return;
d576 1
a576 1
	bu_bomb("bu_vls_write(): This isn't UNIX\n");
d578 5
a582 5
	{
	    int status;
	    bu_semaphore_acquire(BU_SEM_SYSCALL);
	    status = write( fd, vp->vls_str + vp->vls_offset, vp->vls_len );
	    bu_semaphore_release(BU_SEM_SYSCALL);
d584 3
a586 4
	    if( status != vp->vls_len ) {    
		perror("write");
		bu_bomb("bu_vls_write() write error\n");
	    }
d588 1
d605 1
a605 1
	int	ret = 0;
d607 1
a607 1
	BU_CK_VLS(vp);
d610 1
a610 1
	bu_bomb("bu_vls_read(): This isn't UNIX\n");
d612 14
a625 18
	{
	    int	todo;
	    int	got;
	    for(;;)  {
		bu_vls_extend( vp, 4096 );
		todo = vp->vls_max - vp->vls_len - vp->vls_offset - 1;

		bu_semaphore_acquire(BU_SEM_SYSCALL);
		got = read(fd, vp->vls_str+vp->vls_offset+vp->vls_len, todo );
		bu_semaphore_release(BU_SEM_SYSCALL);

		if( got < 0 )  {
			/* Read error, abandon the read */
			return -1;
		}
		if(got == 0)  break;
		vp->vls_len += got;
		ret += got;
d627 4
d632 3
a634 3
	    /* force null termination */
	    vp->vls_str[vp->vls_len+vp->vls_offset] = '\0';
	}
d636 1
a636 1
	return ret;
d656 2
a657 2
	int	startlen;
	int	c;
d659 1
a659 1
	BU_CK_VLS(vp);
d661 7
a667 7
	startlen = bu_vls_strlen(vp);
	bu_vls_extend( vp, 80 );		/* Ensure room to grow */
	for( ;; )  {
		/* Talk about inefficiency... */
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		c = getc(fp);
		bu_semaphore_release( BU_SEM_SYSCALL );
d669 1
a669 1
		/* XXX Alternatively, code up something with fgets(), chunking */
d671 6
a676 6
		if( c == EOF || c == '\n' )  break;
		bu_vls_putc( vp, c );
	}
	if( c == EOF && bu_vls_strlen(vp) <= startlen )  return -1;
	vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
	return bu_vls_strlen(vp);
d687 1
a687 1
	BU_CK_VLS(vp);
d689 3
a691 3
	if( vp->vls_offset + vp->vls_len+1 >= vp->vls_max )  bu_vls_extend( vp, 80 );
	vp->vls_str[vp->vls_offset + vp->vls_len++] = (char)c;
	vp->vls_str[vp->vls_offset + vp->vls_len] = '\0';	/* force null termination */
d702 1
a702 1
	BU_CK_VLS(vp);
d704 7
a710 7
	/* Remove trailing white space */
	while( isspace( bu_vls_addr(vp)[bu_vls_strlen(vp)-1] ) )
		bu_vls_trunc( vp, -1 );

	/* Remove leading white space */
	while( isspace( *bu_vls_addr(vp) ) )
		bu_vls_nibble( vp, 1 );
d749 1
a749 1
		sp++;
d752 1
a752 1
		bu_vls_strncat(vls, fmt, sp-fmt);
d755 1
a755 1
		break;
d762 14
a775 14
		++ep;
		if (*ep == ' ' || *ep == '#' || *ep == '-' ||
		    *ep == '+' || *ep == '.' || isdigit(*ep))
			continue;
		else if (*ep == 'l' || *ep == 'U' || *ep == 'O')
			flags |= LONGINT;
		else if (*ep == '*') {
			fieldlen = va_arg(ap, int);
			flags |= FIELDLEN;
		} else if (*ep == 'h') {
		        flags |= SHORTINT;
		} else
			/* Anything else must be the end of the fmt specifier */
			break;
d787 1
a787 1
	{
d792 1
a792 1
			if (flags & FIELDLEN)
d794 2
a795 2
				int	stringlen = strlen(str);
				int	left_justify;
d797 2
a798 2
				if ((left_justify = (fieldlen < 0)))
					fieldlen *= -1;
d800 3
a802 3
				if (stringlen >= fieldlen)
					bu_vls_strncat(vls, str, fieldlen);
				else
d804 2
a805 2
					struct bu_vls		padded;
					int			i;
d807 8
a814 8
					bu_vls_init(&padded);
					if (left_justify)
						bu_vls_strcat(&padded, str);
					for (i = 0; i < fieldlen - stringlen; ++i)
						bu_vls_putc(&padded, ' ');
					if (!left_justify)
						bu_vls_strcat(&padded, str);
					bu_vls_vlscat(vls, &padded);
d817 1
a817 1
				bu_vls_strcat(vls, str);
d820 4
a823 4
			if (flags & FIELDLEN)
				bu_vls_strncat(vls, "(null)", fieldlen);
			else
				bu_vls_strcat(vls, "(null)");
d825 2
a826 2
	}
		break;
d828 1
a828 1
	{
d833 1
a833 1
		{
d836 1
a836 1
			{
d841 1
a841 1
					fieldlen *= -1;
d844 1
a844 1
					bu_vls_strncat(vls, bu_vls_addr(vp), fieldlen);
d846 1
a846 1
				{
d852 1
a852 1
						bu_vls_vlscat(&padded, vp);
d854 1
a854 1
						bu_vls_putc(&padded, ' ');
d856 1
a856 1
						bu_vls_vlscat(&padded, vp);
d858 2
a859 2
				}
			} else {
d861 2
a862 2
			}
		}  else  {
d864 1
a864 1
				bu_vls_strncat(vls, "(null)", fieldlen);
d866 4
a869 4
				bu_vls_strcat(vls, "(null)");
		}
	}
		break;
d875 1
a875 1
		/* All floating point ==> "double" */
d877 2
a878 2
		if (flags & LONGDBL) {
			register long double ld;
d880 7
a886 7
			ld = va_arg(ap, long double);
			if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, ld);
			else
				sprintf(buf, fbuf, ld);
			bu_vls_strcat(vls, buf);
		} else
d889 1
a889 1
			register double d;
d891 6
a896 6
			d = va_arg(ap, double);
			if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, d);
			else
				sprintf(buf, fbuf, d);
			bu_vls_strcat(vls, buf);
d898 1
a898 1
		break;
d901 3
a903 3
		if (flags & LONGINT) {
			/* Long int */
			register long ll;
d905 18
a922 18
			ll = va_arg(ap, long);
			if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, ll);
			else
				sprintf(buf, fbuf, ll);
			bu_vls_strcat(vls, buf);
		} else if (flags & SHORTINT) {
		    /* short int */
		    register short int sh;
		    sh = (short int)va_arg(ap, int);
		    if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, sh);
			else
				sprintf(buf, fbuf, sh);
			bu_vls_strcat(vls, buf);
		} else {
			/* Regular int */
			register int j;
d924 8
a931 8
			j = va_arg(ap, int);
			if (flags & FIELDLEN)
				sprintf(buf, fbuf, fieldlen, j);
			else
				sprintf(buf, fbuf, j);
			bu_vls_strcat(vls, buf);
		}
		break;
d933 2
a934 2
		bu_vls_putc(vls, '%');
		break;
d936 1
a936 1
	  {
d944 1
a944 1
		sprintf(buf, fbuf, fieldlen, j);
d946 1
a946 1
		sprintf(buf, fbuf, j);
d949 1
a949 1
	  }
d970 5
a974 5
	va_list ap;
	va_start(ap, fmt);
	BU_CK_VLS(vls);
	bu_vls_vprintf(vls, fmt, ap);
	va_end(ap);
d982 1
a982 1
va_dcl
d984 10
a993 10
	va_list ap;
	struct bu_vls *vls;
	char *fmt;

	va_start(ap);
	vls = va_arg(ap, struct bu_vls *);
	fmt = va_arg(ap, char *);
	BU_CK_VLS(vls);
	bu_vls_vprintf(vls, fmt, ap);
	va_end(ap);
d1000 2
a1001 2
struct bu_vls *vls;
char *fmt;
d1003 1
a1003 1
	char append_buf[65536] = {0};   /* yuck -- fixed length buffer. */
d1005 9
a1013 9
	BU_CK_VLS(vls);
	sprintf(append_buf, fmt, a,b,c,d,e,f,g,h,i,j);
	if (append_buf[sizeof(append_buf)-1] != '\0') {
		/* Attempting to bu_log() the WHOLE append_buf would just overflow again */
		append_buf[120] = '\0';
		bu_log("bu_vls_printf buffer overflow\nWhile building string '%s'...\n",
			   append_buf);
		bu_bomb("bu_vls_printf buffer overflow\n");
	}
d1015 1
a1015 1
	bu_vls_strcat(vls, append_buf);
d1029 6
a1034 6
	BU_CK_VLS(vp);
	if( cnt <= 0 )  return;
	if( vp->vls_offset + vp->vls_len + cnt+1 >= vp->vls_max )
		bu_vls_extend( vp, cnt );
	memset( vp->vls_str + vp->vls_offset + vp->vls_len, ' ', cnt );
	vp->vls_len += cnt;
d1053 2
a1054 2
	char	*start;
	int	used;
d1056 1
a1056 1
	BU_CK_VLS(vp);
d1058 8
a1065 10
	if( (start = strrchr( bu_vls_addr(vp), '\n' )) == NULL )
		start = bu_vls_addr(vp);
	used = 0;
	while( *start != '\0' )  {
		if( *start == '\t' )  {
			used += 8 - (used % 8);
		} else {
			used++;
		}
		start++;
d1067 3
a1069 1
	return used;
d1082 23
a1104 25
	struct bu_vls	src;
	register char	*cp;
	int		used;

	BU_CK_VLS(vp);
	bu_vls_init( &src );
	bu_vls_vlscatzap( &src, vp );	/* make temporary copy of src */
	bu_vls_extend( vp, bu_vls_strlen(&src)+50 );

	cp = bu_vls_addr( &src );
	used = 0;
	while( *cp != '\0' )  {
		if( *cp == '\t' )  {
			int	todo;
			todo = 8 - (used % 8);
			bu_vls_spaces( vp, todo );
			used += todo;
		} else if( *cp == '\n' )  {
			bu_vls_putc( vp, '\n' );
			used = 0;
		} else {
			bu_vls_putc( vp, *cp );
			used++;
		}
		cp++;
d1106 3
a1108 1
	bu_vls_free( &src );
d1118 1
a1118 1
	int len = strlen(str);
d1120 1
a1120 1
	bu_vls_extend(vp, len);
d1122 2
a1123 2
	/* memmove is supposed to be safe even if strings overlap */
	memmove( vp->vls_str+vp->vls_offset+len, vp->vls_str+vp->vls_offset, vp->vls_len );
d1125 2
a1126 2
	/* insert the data at the head of the string */
	memcpy( vp->vls_str+vp->vls_offset, str, len);
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d37 1
a37 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/vls.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (BRL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a35 2
 *  Distribution Status -
 *      Public Domain, Distribution Unlimitied.
d37 1
a37 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/vls.c,v 14.3 2004/12/21 05:45:21 morrison Exp $ (BRL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d39 1
a39 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/vls.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (BRL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d39 1
a39 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/vls.c,v 14.1 2004/11/16 19:42:14 morrison Exp $ (BRL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			V L S . C
d39 1
a39 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/vls.c,v 1.5 2004/09/16 06:31:10 morrison Exp $ (BRL)";
@


1.5
log
@const char *[]
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/vls.c,v 1.4 2004/09/03 23:30:57 morrison Exp $ (BRL)";
d1111 10
@


1.4
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/vls.c,v 1.3 2004/08/02 23:01:48 morrison Exp $ (BRL)";
d464 1
a464 1
bu_vls_from_argv(register struct bu_vls *vp, int argc, char **argv)
@


1.3
log
@replace the wrapped config.h block with common.h
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/vls.c,v 1.2 2004/06/08 19:28:50 morrison Exp $ (BRL)";
d28 1
a28 1
#ifdef USE_STRING_H
@


1.2
log
@poof goes the silly externs.h
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header$ (BRL)";
d22 1
a22 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d20 1
a20 1
static const char libbu_vls_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/vls.c,v 1.34 2004/05/10 15:30:44 erikg Exp $ (BRL)";
a44 1
#include "externs.h"
@

