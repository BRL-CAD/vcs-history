head	14.17;
access;
symbols
	rel-7-10-4:14.15
	STABLE:14.15.0.2
	stable-branch:14.6
	rel-7-10-2:14.15
	rel-7-10-0:14.14
	rel-7-8-4:14.10
	rel-7-8-2:14.9
	rel-7-8-0:14.9
	trimnurbs-branch:14.9.0.2
	help:14.9
	temp_tag:14.8
	bobWinPort-20051223-freeze:14.7
	postmerge-20051223-bobWinPort:14.8
	premerge-20051223-bobWinPort:14.8
	rel-7-6-6:14.8
	rel-7-6-4:14.8
	rel-7-6-2:14.7
	rel-7-6-branch:14.7.0.4
	rel-7-6-0:14.7
	rel-7-4-2:14.6
	rel-7-4-branch:14.6.0.2
	bobWinPort:14.7.0.2
	rel-7-4-0:14.6
	rel-7-2-6:14.6
	rel-7-2-4:14.6
	rel-7-2-2:14.6
	rel-7-2-0:14.6
	rel-7-0-4:14.5
	rel-7-0-2:14.5
	rel-7-0-1:14.5
	opensource-post:14.5
	opensource-pre:1.4
	rel-7-0-branch:1.4.0.2
	rel-7-0:1.4;
locks; strict;
comment	@ * @;


14.17
date	2007.12.16.16.48.35;	author brlcad;	state Exp;
branches;
next	14.16;

14.16
date	2007.09.15.16.23.08;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.05.31.18.41.22;	author erikgreenwald;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.27.01.41.36;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.12;

14.12
date	2007.01.21.04.45.41;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2006.08.31.05.50.24;	author lbutler;	state Exp;
branches;
next	14.9;

14.9
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.8;

14.8
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.7.4.1;
next	14.6;

14.6
date	2005.01.30.20.30.45;	author brlcad;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.07.18.57;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.20;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.13;	author morrison;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.26.20.38.46;	author butler;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.23.30.57;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.32;	author morrison;	state Exp;
branches;
next	;

14.7.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.17
log
@not clear whether the two regions can overlap, so convert bcopy to memmove
@
text
@/*                       C O N V E R T . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup conv */
/** @@{ */
/** @@file convert.c
 *
 * @@brief
 * Routines to translate data formats.  The data formats are:
 *
 * \li Host/Network		is the data in host format or local format
 * \li  signed/unsigned		Is the data signed?
 * \li char/short/int/long/double
 *				Is the data 8bits, 16bits, 32bits, 64bits
 *				or a double?
 *
 * The method of conversion is to convert up to double then back down the
 * the expected output format.
 *
 * @@author Christopher T. Johnson
 *
 *  @@par Source
 *	The U. S. Army Research Laboratory			@@n
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#include "common.h"

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "machine.h"
#include "vmath.h"
#include "bu.h"


/* bu_cv_cookie
 *
 * @@brief
 * Set's a bit vector after parsing an input string.
 *
 * Set up the conversion tables/flags for vert.
 *
 * @@param in	format description.
 *
 * @@return a 32 bit vector.
 *
 * Format description:
 *	[channels][h|n][s|u] c|s|i|l|d|8|16|32|64 [N|C|L]
 *
 * @@n channels must be null or 1
 * @@n Host | Network
 * @@n signed | unsigned
 * @@n char | short | integer | long | double | number of bits of integer
 * @@n Normalize | Clip | low-order
 */
int
bu_cv_cookie(char *in)			/* input format */
{
	char *p;
	int collector;
	int result = 0x0000;	/* zero/one channel, Net, unsigned, char, clip */

	if (!in) return 0;
	if (!*in) return 0;


	collector = 0;
	for (p=in; *p && isdigit(*p); ++p) collector = collector*10 + (*p - '0');
	if (collector > 255) {
		collector = 255;
	} else if (collector == 0) {
		collector = 1;
	}
	result = collector;	/* number of channels set '|=' */

	if (!*p) return 0;

	if (*p == 'h') {
		result |= CV_HOST_MASK;
		++p;
	} else if (*p == 'n') {
		++p;
	}

	if (!*p) return 0;
	if (*p == 'u') {
		++p;
	} else if (*p == 's') {	/* could be 'signed' or 'short' */
		char *p2;
		p2 = p+1;
		if (*p2 && (islower(*p2) || isdigit(*p2))) {
			result |= CV_SIGNED_MASK;
			++p;
		}
	}

	if (!*p) return 0;
	switch (*p) {
	case 'c':
	case '8':
		result |= CV_8;
		break;
	case '1':
		p++;
		if (*p != '6') return 0;
		/* fall through */
	case 's':
		result |= CV_16;
		break;
	case '3':
		p++;
		if (*p != '2') return 0;
		/* fall through */
	case 'i':
		result |= CV_32;
		break;
	case '6':
		p++;
		if (*p != '4') return 0;
		/* fall through */
	case 'l':
		result |= CV_64;
		break;
	case 'd':
		result |= CV_D;
		break;
	default:
		return 0;
	}
	p++;

	if (!*p) return(result);
	if (*p == 'N') {
		result |= CV_NORMAL;
	} else if (*p == 'C') {
		result |= CV_CLIP;
	} else if (*p == 'L') {
		result |= CV_LIT;
	} else {
		return 0;
	}
	return(result);
}

/**
 *
 */
void
bu_cv_fmt_cookie( char * buf, size_t buflen, int cookie )
{
	register char *cp = buf;
	unsigned int	len;

	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	buflen--;
	if( cookie == 0 )  {
		strncpy( cp, "bogus!", buflen );
		return;
	}

	snprintf( cp, buflen, "%d", cookie & CV_CHANNEL_MASK );
	len = strlen(cp);
	cp += len;
	if( buflen < len )
	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	buflen -= len;

	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	if( cookie & CV_HOST_MASK )  {
		*cp++ = 'h';
		buflen--;
	} else {
		*cp++ = 'n';
		buflen--;
	}

	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	if( cookie & CV_SIGNED_MASK )  {
		*cp++ = 's';
		buflen--;
	} else {
		*cp++ = 'u';
		buflen--;
	}

	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	switch( cookie & CV_TYPE_MASK )  {
	case CV_8:
		*cp++ = '8';
		buflen--;
		break;
	case CV_16:
		strncpy( cp, "16", buflen );
		cp += 2;
		buflen -= 2;
		break;
	case CV_32:
		strncpy( cp, "32", buflen );
		cp += 2;
		buflen -= 2;
		break;
	case CV_64:
		strncpy( cp, "64", buflen );
		cp += 2;
		buflen -= 2;
		break;
	case CV_D:
		*cp++ = 'd';
		buflen -= 1;
		break;
	default:
		*cp++ = '?';
		buflen -= 1;
		break;
	}

	if( buflen == 0 )	{
		fprintf( stderr, "bu_cv_pr_cookie:  call me with a bigger buffer\n");
		return;
	}
	switch( cookie & CV_CONVERT_MASK )  {
	case CV_CLIP:
		*cp++ = 'C';
		buflen -= 1;
		break;
	case CV_NORMAL:
		*cp++ = 'N';
		buflen -= 1;
		break;
	case CV_LIT:
		*cp++ = 'L';
		buflen -= 1;
		break;
	default:
		*cp++ = 'X';
		buflen -= 1;
		break;
	}
	*cp = '\0';
}

/**
 *
 *
 */
void
bu_cv_pr_cookie( char *title, int cookie )
{
	char	buf[128];

	bu_cv_fmt_cookie( buf, sizeof(buf), cookie );
	fprintf( stderr, "%s cookie '%s' (x%x)\n", title, buf, cookie );
}

/**		c v
 * @@brief
 * convert from one format to another.
 *
 *
 * @@param in	input pointer
 * @@param out	output pointer
 * @@param count	number of entries to convert.
 * @@param size	size of output buffer.
 * @@param infmt	input format
 * @@param outfmt	output format
 *
 */
int
cv(genptr_t out, char *outfmt, size_t size, genptr_t in, char *infmt, int count)
{
	int	incookie, outcookie;
	incookie = bu_cv_cookie(infmt);
	outcookie = bu_cv_cookie(outfmt);
	return(bu_cv_w_cookie(out, outcookie, size, in, incookie, count));
}

/**
 *			C V _ O P T I M I Z E
 *
 *  It is always more efficient to handle host data, rather than network.
 *  If host and network formats are the same, and the request was for
 *  network format, modify the cookie to request host format.
 */
int
bu_cv_optimize(register int cookie)
{
	static int Indian = IND_NOTSET;
	int	fmt;

	if( cookie & CV_HOST_MASK )
		return cookie;		/* already in most efficient form */

	/* This is a network format request */
	fmt  =  cookie & CV_TYPE_MASK;

	/* Run time check:  which kind of integers does this machine have? */
	if (Indian == IND_NOTSET) {
		size_t soli = sizeof(long int);
		unsigned long int	testval = 0;
		register int		i;
		for (i=0; i<4; i++) {
			((char *)&testval)[i] = i+1;
		}

		if (soli == 8) {
			Indian = IND_CRAY;	/* is this good enough? */
			if ( ( (testval >> 31) >> 1 ) == 0x01020304) {
				Indian = IND_BIG; /* XXX 64bit */
			} else if (testval == 0x04030201) {
				Indian = IND_LITTLE;	/* 64 bit */
			} else {
				bu_bomb("bu_cv_optimize: can not tell indian of host.\n");
			}
		} else if (testval == 0x01020304) {
			Indian = IND_BIG;
		} else if (testval == 0x04030201) {
			Indian = IND_LITTLE;
		} else if (testval == 0x02010403) {
			Indian = IND_ILL;
		}
	}

	switch(fmt)  {
	case CV_D:
#		if IEEE_FLOAT
			cookie |= CV_HOST_MASK;	/* host uses network fmt */
#		endif
		return cookie;
	case CV_8:
		return cookie | CV_HOST_MASK;	/* bytes already host format */
	case CV_16:
	case CV_32:
	case CV_64:
		/* host is big-endian, so is network */
		if( Indian == IND_BIG )
			cookie |= CV_HOST_MASK;
		return cookie;
	}
	return 0;			/* ERROR */
}

/**
 *			C V _ I T E M L E N
 *
 *  Returns the number of bytes each "item" of type "cookie" occupies.
 */
int
bu_cv_itemlen(register int cookie)
{
	register int	fmt = (cookie & CV_TYPE_MASK) >> CV_TYPE_SHIFT;
	static int host_size_table[8] = {0, sizeof(char),
																	 sizeof(short), sizeof(int),
																	 sizeof(long int), sizeof(double)};
	static int net_size_table[8] = {0,1,2,4,8,8};

	if( cookie & CV_HOST_MASK )
		return host_size_table[fmt];
	return net_size_table[fmt];
}


/**	bu_cv_ntohss
 *
 * @@brief
 * Network TO Host Signed Short
 *
 * It is assumed that this routine will only be called if there is
 * real work to do.  Ntohs does no checking to see if it is reasonable
 * to do any conversions.
 *
 *
 * @@param in	generic pointer for input.
 * @@param count	number of shorts to be generated.
 * @@param out	short pointer for output
 * @@param size	number of bytes of space reserved for out.
 *
 *
 * @@return	number of conversions done.
 */
int
bu_cv_ntohss(register short int *out, size_t size, register genptr_t in, int count)
{
	int limit;
	register int i;

	limit = size / sizeof(signed short);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((signed char *)in)[0] << 8 | ((unsigned char *)in)[1];
		/* XXX This needs sign extension here for the case of
		 * XXX a negative 2-byte input on a 4 or 8 byte machine.
		 * XXX The "signed char" trick isn't enough.
		 * XXX Use your Cyber trick w/magic numbers or something.
		 */
		in = ((char *)in) + 2;
	}
	return(count);
}

/**
 *
 *
 */
int
bu_cv_ntohus(register short unsigned int *out, size_t size, register genptr_t in, int count)
{
	int limit;
	register int i;

	limit = size / sizeof(unsigned short);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((unsigned char *)in)[0]<<8 |
			((unsigned char *)in)[1];
		in = ((char *)in) + 2;
	}
	return(count);
}
/**
 *
 *
 */
int
bu_cv_ntohsl(register long int *out, size_t size, register genptr_t in, int count)
{
	int limit;
	register int i;

	limit = size / sizeof(signed long int);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((signed char *)in)[0] << 24 |
		    ((unsigned char *)in)[1] << 16 |
		    ((unsigned char *)in)[2] << 8  |
		    ((unsigned char *)in)[3];
		/* XXX Sign extension here */
		in = ((char *)in) + 4;
	}

	return(count);
}
/**
 *
 *
 */
int
bu_cv_ntohul(register long unsigned int *out, size_t size, register genptr_t in, int count)
{
	int limit;
	register int i;

	limit = size / sizeof(unsigned long int);
	if (limit < count) count = limit;

	for (i=0; i<count; i++) {
		*out++ = ((unsigned char *)in)[0] << 24 |
			((unsigned char *)in)[1] << 16 |
		    ((unsigned char *)in)[2] <<  8 |
			((unsigned char *)in)[3];
		in = ((char *)in) + 4;
	}
	return(count);
}

/*****/
/**
 *
 *
 */
int
bu_cv_htonss(genptr_t out, size_t size, register short int *in, int count)
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register int	val;

	limit = size / 2;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>8;
		*cp++ = val;
	}
	return(count);
}
/**
 *
 *
 */
int
bu_cv_htonus(genptr_t out, size_t size, register short unsigned int *in, int count)
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register int	val;

	limit = size / 2;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>8;
		*cp++ = val;
	}
	return(count);
}
/**
 *
 *
 */
int
bu_cv_htonsl(genptr_t out, size_t size, register long int *in, int count)
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register long	val;

	limit = size / 4;
	if( count > limit )  count = limit;

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>24;
		*cp++ = val>>16;
		*cp++ = val>> 8;
		*cp++ = val;
	}
	return(count);
}
/**
 *
 *
 */
int
bu_cv_htonul(genptr_t out, size_t size, register long unsigned int *in, int count)
{
	int		limit;
	register int	i;
	register unsigned char *cp = (unsigned char *)out;
	register long	val;

	limit = size / 4;
	if( count > limit ) {
		count = limit;
	}

	for (i=0; i<count; i++) {
		*cp++ = (val = *in++)>>24;
		*cp++ = val>>16;
		*cp++ = val>> 8;
		*cp++ = val;
	}
	return(count);
}


/** bu_cv_w_cookie
 *
 * @@brief
 * convert with cookie
 *
 * @@param in		input pointer
 * @@param incookie	input format cookie.
 * @@param count		number of entries to convert.
 * @@param out		output pointer.
 * @@param outcookie	output format cookie.
 * @@param size		size of output buffer in bytes;
 *
 *
 * A worst case would be:	ns16 on vax to ns32
@@code
 *	ns16 	-> hs16
 *		-> hd
 *		-> hs32
 *		-> ns32
@@endcode
 * The worst case is probably the easiest to deal with because all steps are
 * done.  The more difficult cases are when only a subset of steps need to
 * be done.
 *
 * @@par Method:
@@code
 *	HOSTDBL defined as true or false
 *	if ! hostother then
 *		hostother = (Indian == IND_BIG) ? SAME : DIFFERENT;
 *	fi
 *	if (infmt == double) then
 *		if (HOSTDBL == SAME) {
 *			inIsHost = host;
 *		fi
 *	else
 *		if (hostother == SAME) {
 *			inIsHost = host;
 *		fi
 *	fi
 *	if (outfmt == double) then
 *		if (HOSTDBL == SAME) {
 *			outIsHost == host;
 *	else
 *		if (hostother == SAME) {
 *			outIsHost = host;
 *		fi
 *	fi
 *	if (infmt == outfmt) {
 *		if (inIsHost == outIsHost) {
 *			copy(in,out)
 *			exit
 *		else if (inIsHost == net) {
 *			ntoh?(in,out);
 *			exit
 *		else
 *			hton?(in,out);
 *			exit
 *		fi
 *	fi
 *
 *	while not done {
 *		from = in;
 *
 *		if (inIsHost == net) {
 *			ntoh?(from,t1);
 *			from = t1;
 *		fi
 *		if (infmt != double ) {
 *			if (outIsHost == host) {
 *				to = out;
 *			else
 *				to = t2;
 *			fi
 *			castdbl(from,to);
 *			from = to;
 *		fi
 *
 *		if (outfmt == double ) {
 *			if (outIsHost == net) {
 *				hton?(from,out);
 *			fi
 *		else
 *			if (outIsHost == host) {
 *				dblcast(from,out);
 *			else
 *				dblcast(from,t3);
 *				hton?(t3,out);
 *			fi
 *		fi
 *	done
@@endcode
 */
int
bu_cv_w_cookie(genptr_t out, int outcookie, size_t size, genptr_t in,  int incookie,  int	count)
{
	int	work_count = 4096;
	int	number_done = 0;
	int	inIsHost,outIsHost,infmt,outfmt,insize,outsize;
	size_t	bufsize;
	genptr_t	t1,t2,t3;
	genptr_t	from;
	genptr_t	to;
	genptr_t	hold;
	register int i;

	/*
	 * Work_count is the size of the working buffer.  If count is smaller
	 * than the default work_count (4096) use the smaller number.
	 */

	if (work_count > count)
		work_count = count;

	incookie = bu_cv_optimize( incookie );
	outcookie = bu_cv_optimize( outcookie );

	/*
	 * break out the conversion code and the format code.
	 * Conversion is net<-->host.
	 * Format is 8/16/32/64/D casting.
	 */
	inIsHost = incookie & CV_HOST_MASK;	/* not zero if host */
	outIsHost= outcookie& CV_HOST_MASK;
	infmt  =  incookie & CV_TYPE_MASK;
	outfmt = outcookie & CV_TYPE_MASK;
	/*
	 * Find the number of bytes required for one item of each kind.
	 */
	outsize = bu_cv_itemlen( outcookie );
	insize = bu_cv_itemlen( incookie );

	/*
	 * If the input format is the same as the output format then the
	 * most that has to be done is a host to net or net to host conversion.
	 */
	if (infmt == outfmt) {

		/*
		 * Input format is the same as output format, do we need to do a
		 * host/net conversion?
		 */
		if (inIsHost == outIsHost) {

			/*
			 * No conversion required.
			 * Check the amount of space remaining before doing the memmove.
			 */
			if ((unsigned int)count * outsize > size) {
		    number_done = size / outsize;
			} else {
		    number_done = count;
			}

			/*
			 * This is the simplest case, binary copy and out.
			 */
			memmove((genptr_t)out, (genptr_t)in, (size_t)number_done * outsize);
			return(number_done);

			/*
			 * Well it's still the same format but the conversion are different.
			 * Only one of the *vert variables can be HOST therefore if
			 * inIsHost != HOST then outIsHost must be host format.
			 */

		} else if (inIsHost != CV_HOST_MASK) { /* net format */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
		    return(	bu_cv_ntohss((signed short *)out, size, in, count));
			case CV_16:
		    return( bu_cv_ntohus((unsigned short *)out, size, in, count));
			case CV_SIGNED_MASK | CV_32:
		    return( bu_cv_ntohsl((signed long *)out, size, in, count));
			case CV_32:
		    return( bu_cv_ntohul((unsigned long *)out, size, in, count));
			case CV_D:
		    (void) ntohd((unsigned char *)out, (unsigned char *)in, count);
		    return(count);
			}

			/*
			 * Since inIsHost != outIsHost and inIsHost == HOST then outIsHost must
			 * be in net format.  call the correct subroutine to do the conversion.
			 */
		} else {
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
		    return(	bu_cv_htonss(out, size, (short *)in, count));
			case CV_16:
		    return( bu_cv_htonus(out, size, (unsigned short *)in, count));
			case CV_SIGNED_MASK | CV_32:
		    return( bu_cv_htonsl(out, size, (long *)in, count));
			case CV_32:
		    return( bu_cv_htonul(out, size, (unsigned long *)in, count));
			case CV_D:
		    (void) htond((unsigned char *)out, (unsigned char *)in, count);
		    return(count);
			}
		}
	}
	/*
	 * If we get to this point then the input format is known to be
	 * of a diffrent type than the output format.  This will require
	 * a cast to, from or to and from double.
	 *
	 * Because the number of steps is not known initially, we get
	 * three working buffers.  The size of a double is the largest of
	 * any of the sizes we may be dealing with.
	 */

	bufsize = work_count * sizeof(double);
	t1 = (genptr_t) bu_malloc(bufsize, "vert.c: t1");
	t2 = (genptr_t) bu_malloc(bufsize, "vert.c: t2");
	t3 = (genptr_t) bu_malloc(bufsize, "vert.c: t3");

	/*
	 * From here on we will be working on a chunk of process at a time.
	 */
	while ( size >= (unsigned int)outsize  && number_done < count) {
		int remaining;

		/*
		 * Size is the number of bytes that the caller said was available.
		 * We need the check to make sure that we will not convert too many
		 * entries, overflowing the output buffer.
		 */

		/*
		 * Get number of full entries that can be converted
		 */
		remaining = size / outsize;

		/*
		 * If number of entries that would fit in the output buffer is
		 * larger than the number of entries left to convert(based on
		 * count and number done), set remaining to request count minus
		 * the number of conversions already completed.
		 */
		if (remaining > count - number_done) {
			remaining = count - number_done;
		}
		/*
		 * If we are in the last chunk, set the work count to take up
		 * the slack.
		 */
		if (remaining < work_count) work_count = remaining;

		/*
		 * All input at any stage will come from the "from" pointer.  We
		 * start with the from pointer pointing to the input buffer.
		 */
		from = in;

		/*
		 * We will be processing work_count entries of insize bytes each, so
		 * we set the in pointer to be ready for the next time through the loop.
		 */
		in = ((char *) in) + work_count * insize;

		/*
		 * If the input is in net format convert it host format.
		 * Because we know that the input format is not equal to the output
		 * this means that there will be at least two conversions taking place
		 * if the input is in net format.  (from net to host then at least one cast)
		 */
		if (inIsHost != CV_HOST_MASK) { /* net format */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_16:
				(void) bu_cv_ntohss((short *)t1, bufsize , from, work_count);
				break;
			case CV_16:
				(void) bu_cv_ntohus((unsigned short *)t1, bufsize , from, work_count);
				break;
			case CV_SIGNED_MASK | CV_32:
				(void) bu_cv_ntohsl((long *)t1, bufsize , from, work_count);
				break;
			case CV_32:
				(void) bu_cv_ntohul((unsigned long *)t1, bufsize , from, work_count);
				break;
			case CV_D:
				(void) ntohd((unsigned char *)t1, (unsigned char *)from, work_count);
				break;
			}
			/*
			 * Point the "from" pointer to the host format.
			 */
			from = t1;
		}


		/*
		 * "From" is a pointer to a HOST format buffer.
		 */

		/*
		 * If the input format is not double then there must be a cast to
		 * double.
		 */
		if (infmt != CV_D) {

			/*
			 * if the output conversion is HOST and output format is DOUBLE
			 * then this will be the last step.
			 */
			if (outIsHost == CV_HOST_MASK && outfmt == CV_D) {
		    to = out;
			} else {
		    to = t2;
			}

			hold = to;
			/*
			 * Cast the input format to double.
			 */
			switch(incookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_8:
		    for (i=0; i< work_count; i++) {
					*((double *)to) = *((signed char *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = ((char *)from) + 1;
		    }
		    break;
			case CV_8:
		    for(i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned char *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned char *)from) + 1);
		    }
		    break;
			case CV_SIGNED_MASK | CV_16:
		    for (i=0; i < work_count; i++) {
					*((double *)to) = *((signed short *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((signed short *)from) + 1);
		    }
		    break;
			case CV_16:
		    for (i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned short *)from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned short *)from) + 1);
		    }
		    break;
			case CV_SIGNED_MASK | CV_32:
		    for (i=0; i < work_count; i++) {
					*((double *)to) = *((signed long int *)from);
					to = (genptr_t)(((double *)to) + 1);
					from =  (genptr_t)(((signed long int *)from) + 1);
		    }
		    break;
			case CV_32:
		    for (i=0; i < work_count; i++) {
					*((double *)to) = *((unsigned long int *) from);
					to = (genptr_t)(((double *)to) + 1);
					from = (genptr_t)(((unsigned long int *)from) + 1);
		    }
		    break;
			default:
				fprintf( stderr, "Unimplemented input format\n");
				break;
			}
			from = hold;
		}

		if (outfmt != CV_D) {
			/*
			 * The input point is now pointing to a double in host format.  If the
			 * output is also in host format then the next conversion will be
			 * the last conversion, set the destination to reflect this.
			 */

			if (outIsHost == CV_HOST_MASK) {
		    to = out;
			} else {
		    to = t3;
			}

			/*
			 * The ouput format is something other than DOUBLE (tested for earlier),
			 * do a cast from double to requested format.
			 */
			hold = to;

			switch (outcookie & (CV_SIGNED_MASK | CV_TYPE_MASK)) {
			case CV_SIGNED_MASK | CV_8:
		    for (i=0; i<work_count; i++) {
					*((signed char *)to) = *((double *)from);
					to = (genptr_t)(((signed char *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_8:
		    for (i=0; i<work_count; i++) {
					*((unsigned char *)to) =
						(unsigned char)(*((double *)from));
					to = (genptr_t)(((unsigned char *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_SIGNED_MASK | CV_16:
		    for (i=0; i<work_count; i++) {
					*((signed short int *)to) =
						*((double *)from);
					to = (genptr_t)(((signed short int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_16:
		    for (i=0; i<work_count; i++) {
					*((unsigned short int *)to) =
						*((double *)from);
					to = (genptr_t)(((unsigned short int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_SIGNED_MASK | CV_32:
		    for (i=0; i<work_count; i++) {
					*((signed long int *)to) =
						*((double *)from);
					to = (genptr_t)(((signed long int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			case CV_32:
		    for (i=0; i<work_count; i++) {
					*((unsigned long int *)to) =
						*((double *)from);
					to = (genptr_t)(((unsigned long int *)to) + 1);
					from = (genptr_t)(((double *)from) + 1);
		    }
		    break;
			default:
				fprintf( stderr, "Unimplemented output format\n");
				break;

			}
			from = hold;
			/*
			 * The input is now pointing to a host formated buffer of the requested
			 * output format.
			 */

			/*
			 * If the output conversion is network then do a host to net call
			 * for either 16 or 32 bit values using Host TO Network All Short | Long
			 */
			if (outIsHost != CV_HOST_MASK) {
				switch (outfmt) {
				case CV_D:
					(void) htond((unsigned char *)out,
											 (unsigned char *)from,
											 work_count);
					break;
				case CV_16 | CV_SIGNED_MASK:
					(void) bu_cv_htonss(out, bufsize, from,
															work_count);
					break;
				case CV_16:
					(void) bu_cv_htonus(out, bufsize, from,
															work_count);
					break;
				case CV_32 | CV_SIGNED_MASK:
					(void) bu_cv_htonsl(out, bufsize, from,
															work_count);
					break;
				case CV_32:
					(void) bu_cv_htonul(out, bufsize, from,
															work_count);
					break;
				}
			}

		}
		/*
		 * move the output pointer.
		 * reduce the amount of space remaining in the output buffer.
		 * Increment the count of values converted.
		 */
		out = ((char *)out) + work_count * outsize;
		size -= work_count * outsize;
		number_done += work_count;
	}
	/*
	 * All Done!  Clean up and leave.
	 */
	bu_free(t1, "vert.c: t1");
	bu_free(t2, "vert.c: t2");
	bu_free(t3, "vert.c: t3");
	return(number_done);
}
/** @@} */
/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.16
log
@more c89 embracing.  c89 provides string.h for all of the various str*() and mem*() functions, so remove the check for its presence.  there is still likely to be work required for strict c89 conformance for the various bsd strings.h functions that may be in use.
@
text
@d739 1
a739 1
			 * Check the amount of space remaining before doing the bcopy.
d750 1
a750 1
			(void) bcopy((genptr_t) in, (genptr_t) out, (size_t)number_done * outsize);
@


14.15
log
@some sprintf->snprintf
@
text
@a42 4
#ifndef lint
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.14 2007/01/27 01:41:36 brlcad Exp $ (ARL)";
#endif

a44 1

a46 1
#ifdef HAVE_STRING_H
d48 1
a48 3
#else
#include <strings.h>
#endif
@


14.14
log
@ws. lots and lots of ws.  see sh/ws.sh for details (cases 'abcdeg').
@
text
@d44 1
a44 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.13 2007/01/23 01:13:34 brlcad Exp $ (ARL)";
d190 1
a190 1
	sprintf( cp, "%d", cookie & CV_CHANNEL_MASK );
@


14.13
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@d23 1
a23 1
 * 
d44 1
a44 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.12 2007/01/21 04:45:41 brlcad Exp $ (ARL)";
a49 1

d62 1
a62 1
/* bu_cv_cookie	
d68 1
a68 1
 * 
d70 1
a70 1
 * 
d300 1
a300 1
 * 
d621 1
a621 1
@@endcode 
@


14.12
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d44 1
a44 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.11 2007/01/20 14:36:51 brlcad Exp $ (ARL)";
@


14.11
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup conv */
/*@@{*/
d45 1
a45 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.10 2006/08/31 05:50:24 lbutler Exp $ (ARL)";
d1094 1
a1094 1
/*@@}*/
@


14.10
log
@Mostly doxygen formatting.
@
text
@d4 1
a4 1
 * Copyright (c) 2004-2006 United States Government as represented by
d46 1
a46 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.9 2006/01/18 06:46:16 brlcad Exp $ (ARL)";
@


14.9
log
@update copyright to 2006
@
text
@d22 1
a22 1
/** \addtogroup libbu */
d25 2
d29 3
a31 3
 *	- Host/Network		is the data in host format or local format
 *	- signed/unsigned		Is the data signed?
 *	- char/short/int/long/double
d38 1
a38 2
 * Author -
 *	Christopher T. Johnson
d40 2
a41 2
 *  Source -
 *	The U. S. Army Research Laboratory
a42 1
 *
a43 1
/*@@}*/
d46 1
a46 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.8 2005/10/23 04:44:32 brlcad Exp $ (ARL)";
d65 4
a68 1
/* bu_cv_cookie	Set's a bit vector after parsing an input string.
d71 4
a74 6
 *
 * Entry:
 *	in	format description.
 *
 * Exit:
 *	returns a 32 bit vector.
d79 5
a83 5
 * channels must be null or 1
 * Host | Network
 * signed | unsigned
 * char | short | integer | long | double | number of bits of integer
 * Normalize | Clip | low-order
d174 3
d286 4
d299 11
a309 9
/* cv - convert from one format to another.
 *
 * Entry:
 *	in	input pointer
 *	out	output pointer
 *	count	number of entries to convert.
 *	size	size of output buffer.
 *	infmt	input format
 *	outfmt	output format
d321 1
a321 1
/*
d386 1
a386 1
/*
d406 4
a409 1
/*	bu_cv_ntohss	Network TO Host Signed Short
a414 5
 * Entry:
 *	in	generic pointer for input.
 *	count	number of shorts to be generated.
 *	out	short pointer for output
 *	size	number of bytes of space reserved for out.
d416 4
a419 2
 * Exit:
 *	returns	number of conversions done.
a420 2
 * Calls:
 *	none.
d422 1
a422 2
 * Method:
 *	Straight-forward.
d444 5
d465 4
d489 4
d513 4
d534 4
d555 4
d578 4
d605 4
a608 1
/* bu_cv_w_cookie - convert with cookie
d610 6
a615 7
 * Entry:
 *	in		input pointer
 *	incookie	input format cookie.
 *	count		number of entries to convert.
 *	out		output pointer.
 *	outcookie	output format cookie.
 *	size		size of output buffer in bytes;
d619 1
d624 1
d629 2
a630 1
 * Method:
d695 1
d1095 1
a1095 1

@


14.8
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 2004-2005 United States Government as represented by
d47 1
a47 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.7 2005/08/12 22:29:23 lbutler Exp $ (ARL)";
@


14.7
log
@Doxygen changes
@
text
@d29 1
a29 1
 *	- char/short/int/long/double 
d38 1
a38 1
 *  
d42 1
a42 1
 *  
d47 1
a47 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.6 2005/01/30 20:30:45 brlcad Exp $ (ARL)";
d91 1
a91 1
	
d94 2
a95 2
	
	
d104 1
a104 1
	
d106 1
a106 1
	
d113 1
a113 1
	
d125 1
a125 1
	
d160 1
a160 1
	
d179 1
a179 1
	
d189 1
a189 1
	
d199 1
a199 1
	
d211 1
a211 1
	
d223 1
a223 1
	
d257 1
a257 1
	
d287 1
a287 1
	
d327 1
a327 1
	
d330 1
a330 1
	
d339 1
a339 1
		
d342 1
a342 1
			if ( ( (testval >> 31) >> 1 ) == 0x01020304) { 
d357 1
a357 1
	
d423 1
a423 1
	
d426 1
a426 1
	
d443 1
a443 1
	
d446 1
a446 1
	
d465 1
a465 1
		    ((unsigned char *)in)[1] << 16 | 
d479 1
a479 1
	
d504 1
a504 1
	
d535 1
a535 1
	
d538 1
a538 1
	
d554 1
a554 1
	
d646 1
a646 1
 *		else 
d674 1
a674 1
	if (work_count > count) 
d679 1
a679 1
	
d700 1
a700 1
		
d706 1
a706 1
			
d716 1
a716 1
			
d722 1
a722 1
			
d728 1
a728 1
			
d743 1
a743 1
			
d773 1
a773 1
	
d778 1
a778 1
	
d784 1
a784 1
		
d790 1
a790 1
		
d795 1
a795 1
		
d810 1
a810 1
		
d816 1
a816 1
		
d822 1
a822 1
		
d852 2
a853 2
		
		
d857 1
a857 1
		
d863 1
a863 1
			
d873 1
a873 1
			
d927 1
a927 1
		
d934 1
a934 1
			
d940 1
a940 1
			
d946 1
a946 1
			
d998 1
a998 1
				
d1005 1
a1005 1
			
d1035 1
a1035 1
			
@


14.7.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *	- char/short/int/long/double
d38 1
a38 1
 *
d42 1
a42 1
 *
d47 1
a47 1
static const char libbu_convert_RCSid[] = "@@(#)$Header$ (ARL)";
d91 1
a91 1

d94 2
a95 2


d104 1
a104 1

d106 1
a106 1

d113 1
a113 1

d125 1
a125 1

d160 1
a160 1

d179 1
a179 1

d189 1
a189 1

d199 1
a199 1

d211 1
a211 1

d223 1
a223 1

d257 1
a257 1

d287 1
a287 1

d327 1
a327 1

d330 1
a330 1

d339 1
a339 1

d342 1
a342 1
			if ( ( (testval >> 31) >> 1 ) == 0x01020304) {
d357 1
a357 1

d423 1
a423 1

d426 1
a426 1

d443 1
a443 1

d446 1
a446 1

d465 1
a465 1
		    ((unsigned char *)in)[1] << 16 |
d479 1
a479 1

d504 1
a504 1

d535 1
a535 1

d538 1
a538 1

d554 1
a554 1

d646 1
a646 1
 *		else
d674 1
a674 1
	if (work_count > count)
d679 1
a679 1

d700 1
a700 1

d706 1
a706 1

d716 1
a716 1

d722 1
a722 1

d728 1
a728 1

d743 1
a743 1

d773 1
a773 1

d778 1
a778 1

d784 1
a784 1

d790 1
a790 1

d795 1
a795 1

d810 1
a810 1

d816 1
a816 1

d822 1
a822 1

d852 2
a853 2


d857 1
a857 1

d863 1
a863 1

d873 1
a873 1

d927 1
a927 1

d934 1
a934 1

d940 1
a940 1

d946 1
a946 1

d998 1
a998 1

d1005 1
a1005 1

d1035 1
a1035 1

@


14.6
log
@update copyright to 2005
@
text
@d21 3
a24 1
 *
d27 3
a29 3
 *	Host/Network		is the data in host format or local format
 *	signed/unsigned		Is the data signed?
 *	char/short/int/long/double
d44 2
d47 1
a47 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvsroot/brlcad/brlcad/src/libbu/convert.c,v 14.5 2004/12/21 07:18:57 morrison Exp $ (ARL)";
@


14.5
log
@the significantly modified pd files are incorporated as new works and assigned copyright, so remove the old statement.
@
text
@d4 2
a5 2
 * Copyright (c) 2004 United States Government as represented by the
 * U.S. Army Research Laboratory.
d43 1
a43 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/convert.c,v 14.4 2004/12/21 06:18:43 morrison Exp $ (ARL)";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a40 2
 *  Distribution Status -
 *	Public Domain, Distribution Unlimited.
d43 1
a43 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/convert.c,v 14.3 2004/12/21 05:45:20 morrison Exp $ (ARL)";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d45 1
a45 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/convert.c,v 14.2 2004/12/21 03:49:00 morrison Exp $ (ARL)";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d45 1
a45 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/convert.c,v 14.1 2004/11/16 19:42:13 morrison Exp $ (ARL)";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 21
a21 2
/*
 *			C O N V E R T . C
d45 1
a45 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/convert.c,v 1.4 2004/10/26 20:38:46 butler Exp $ (ARL)";
@


1.4
log
@testval was not being cleared before the pattern was inserted.  This
mean that on 64bit machines, there could be garbage in the end of
the value, hence we could not decide what "indian" (snerk) the machine
used.
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/convert.c,v 1.3 2004/09/03 23:30:57 morrison Exp $ (ARL)";
d1033 10
@


1.3
log
@USE_STRING_H is no more.. it's HAVE_STRING_H
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/convert.c,v 1.2 2004/08/02 23:01:48 morrison Exp $ (ARL)";
d313 1
a313 1
		unsigned long int	testval;
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/src/libbu/convert.c,v 1.1 2004/05/20 15:19:32 morrison Exp $ (ARL)";
d35 1
a35 1
#ifdef USE_STRING_H
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d26 1
a26 1
static const char libbu_convert_RCSid[] = "@@(#)$Header: /cvs/brlcad/libbu/convert.c,v 11.21 2004/05/10 15:30:44 erikg Exp $ (ARL)";
d29 1
a29 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

