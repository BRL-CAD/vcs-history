head	14.16;
access;
symbols
	rel-7-10-4:14.16
	STABLE:14.16.0.2
	stable-branch:14.8
	rel-7-10-2:14.16
	rel-7-10-0:14.16
	rel-7-8-4:14.13
	rel-7-8-2:14.12
	rel-7-8-0:14.12
	trimnurbs-branch:14.12.0.2
	help:14.12
	temp_tag:14.10
	bobWinPort-20051223-freeze:14.9
	postmerge-20051223-bobWinPort:14.10
	premerge-20051223-bobWinPort:14.10
	rel-7-6-6:14.10
	rel-7-6-4:14.10
	rel-7-6-2:14.9
	rel-7-6-branch:14.9.0.4
	rel-7-6-0:14.9
	rel-7-4-2:14.8
	rel-7-4-branch:14.8.0.2
	bobWinPort:14.9.0.2
	rel-7-4-0:14.8
	rel-7-2-6:14.8
	rel-7-2-4:14.8
	rel-7-2-2:14.8
	rel-7-2-0:14.8
	rel-7-0-4:14.7
	rel-7-0-2:14.7
	rel-7-0-1:14.7
	opensource-post:14.7
	opensource-pre:1.2
	rel-7-0-branch:1.2.0.2
	rel-7-0:1.2;
locks; strict;
comment	@ * @;


14.16
date	2007.01.23.01.13.34;	author brlcad;	state Exp;
branches;
next	14.15;

14.15
date	2007.01.21.04.45.42;	author brlcad;	state Exp;
branches;
next	14.14;

14.14
date	2007.01.20.14.36.51;	author brlcad;	state Exp;
branches;
next	14.13;

14.13
date	2006.08.31.23.16.38;	author lbutler;	state Exp;
branches;
next	14.12;

14.12
date	2006.02.27.07.42.49;	author brlcad;	state Exp;
branches;
next	14.11;

14.11
date	2006.01.18.06.46.16;	author brlcad;	state Exp;
branches;
next	14.10;

14.10
date	2005.10.23.04.44.32;	author brlcad;	state Exp;
branches;
next	14.9;

14.9
date	2005.08.12.22.29.23;	author lbutler;	state Exp;
branches
	14.9.4.1;
next	14.8;

14.8
date	2005.01.30.20.30.46;	author brlcad;	state Exp;
branches;
next	14.7;

14.7
date	2004.12.21.07.32.30;	author morrison;	state Exp;
branches;
next	14.6;

14.6
date	2004.12.21.06.58.42;	author morrison;	state Exp;
branches;
next	14.5;

14.5
date	2004.12.21.06.44.32;	author morrison;	state Exp;
branches;
next	14.4;

14.4
date	2004.12.21.06.18.43;	author morrison;	state Exp;
branches;
next	14.3;

14.3
date	2004.12.21.05.45.21;	author morrison;	state Exp;
branches;
next	14.2;

14.2
date	2004.12.21.03.49.00;	author morrison;	state Exp;
branches;
next	14.1;

14.1
date	2004.11.16.19.42.14;	author morrison;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.23.01.48;	author morrison;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.15.19.35;	author morrison;	state Exp;
branches;
next	;

14.9.4.1
date	2005.11.13.13.46.15;	author brlcad;	state Exp;
branches;
next	;


desc
@@


14.16
log
@Sweeping license updates.  Documentation is fully relicensed to the BSD Documentation License (a minor variant of the FreeBSD Documentation License and BSD License).  All GPL code (mostly application code) is converted to the LGPL and now also specifically declares version 2.1, revoking the blank check to the FSF.  The intent of these sweeping changes are to simplify the licensing terms and increase overall flexibility of use, both externally (to users for their purposes) and internally (to allow application code to be migrated to libraries without creating GPL libraries).  As a collective work, BRL-CAD is now LGPL.
@
text
@/*                     R B _ I N S E R T . C
 * BRL-CAD
 *
 * Copyright (c) 1998-2007 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @@addtogroup rb */
/** @@{ */
/** @@file rb_insert.c
 *
 *		Routines to insert into a red-black tree
 *
 *  @@author
 *	Paul J. Tanenbaum
 *
 * @@par Source -
 *	The U. S. Army Research Laboratory
 * @@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
 */

#ifndef lint
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.15 2007/01/21 04:45:42 brlcad Exp $";
#endif

#include "common.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "machine.h"
#include "bu.h"
#include "./rb_internals.h"


/**			_ R B _ I N S E R T ( )
 *
 *	    Insert a node into one linear order of a red-black tree
 *
 *	This function has three parameters: the tree and linear order into
 *	which to insert the new node and the new node itself.  If the node
 *	is equal (modulo the linear order) to a node already in the tree,
 *	_rb_insert() returns 1.  Otherwise, it returns 0.
 */
static int _rb_insert (bu_rb_tree *tree, int order, struct bu_rb_node *new_node)
{
    struct bu_rb_node	*node;
    struct bu_rb_node	*parent;
    struct bu_rb_node	*grand_parent;
    struct bu_rb_node	*y;
    int			(*compare)();
    int			comparison=0xdeadbeef;
    int			direction;
    int			result = 0;


    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);
    BU_CKMAG(new_node, BU_RB_NODE_MAGIC, "red-black node");

    /*
     *	Initialize the new node
     */
    bu_rb_parent(new_node, order) =
    bu_rb_left_child(new_node, order) =
    bu_rb_right_child(new_node, order) = bu_rb_null(tree);
    bu_rb_size(new_node, order) = 1;
    if (tree -> rbt_debug & BU_RB_DEBUG_OS)
	bu_log("_rb_insert(%x): size(%x, %d)=%d\n",
	    new_node, new_node, order, bu_rb_size(new_node, order));

    /*
     *	Perform vanilla-flavored binary-tree insertion
     */
    parent = bu_rb_null(tree);
    node = bu_rb_root(tree, order);
    compare = bu_rb_order_func(tree, order);
    while (node != bu_rb_null(tree))
    {
	parent = node;
	++bu_rb_size(parent, order);
	if (tree -> rbt_debug & BU_RB_DEBUG_OS)
	    bu_log("_rb_insert(%x): size(%x, %d)=%d\n",
		new_node, parent, order, bu_rb_size(parent, order));
	comparison = (*compare)(bu_rb_data(new_node, order),
				bu_rb_data(node, order));
	if (comparison < 0)
	{
	    if (tree -> rbt_debug & BU_RB_DEBUG_INSERT)
		bu_log("_rb_insert(%x): <_%d <%x>, going left\n",
		    new_node, order, node);
	    node = bu_rb_left_child(node, order);
	}
	else
	{
	    if (tree -> rbt_debug & BU_RB_DEBUG_INSERT)
		bu_log("_rb_insert(%x): >=_%d <%x>, going right\n",
		    new_node, order, node);
	    node = bu_rb_right_child(node, order);
	    if (comparison == 0)
		result = 1;
	}
    }
    bu_rb_parent(new_node, order) = parent;
    if (parent == bu_rb_null(tree))
	bu_rb_root(tree, order) = new_node;
    else if ((*compare)(bu_rb_data(new_node, order),
			bu_rb_data(parent, order)) < 0)
	bu_rb_left_child(parent, order) = new_node;
    else
	bu_rb_right_child(parent, order) = new_node;

    /*
     *	Reestablish the red-black properties, as necessary
     */
    bu_rb_set_color(new_node, order, BU_RB_RED);
    node = new_node;
    parent = bu_rb_parent(node, order);
    grand_parent = bu_rb_parent(parent, order);
    while ((node != bu_rb_root(tree, order))
	&& (bu_rb_get_color(parent, order) == BU_RB_RED))
    {
	if (parent == bu_rb_left_child(grand_parent, order))
	    direction = BU_RB_LEFT;
	else
	    direction = BU_RB_RIGHT;

	y = bu_rb_other_child(grand_parent, order, direction);
	if (bu_rb_get_color(y, order) == BU_RB_RED)
	{
	    bu_rb_set_color(parent, order, BU_RB_BLACK);
	    bu_rb_set_color(y, order, BU_RB_BLACK);
	    bu_rb_set_color(grand_parent, order, BU_RB_RED);
	    node = grand_parent;
	    parent = bu_rb_parent(node, order);
	    grand_parent = bu_rb_parent(parent, order);
	}
	else
	{
	    if (node == bu_rb_other_child(parent, order, direction))
	    {
		node = parent;
		bu_rb_rotate(node, order, direction);
		parent = bu_rb_parent(node, order);
		grand_parent = bu_rb_parent(parent, order);
	    }
	    bu_rb_set_color(parent, order, BU_RB_BLACK);
	    bu_rb_set_color(grand_parent, order, BU_RB_RED);
	    bu_rb_other_rotate(grand_parent, order, direction);
	}
    }
    bu_rb_set_color(bu_rb_root(tree, order), order, BU_RB_BLACK);

    if (tree -> rbt_debug & BU_RB_DEBUG_INSERT)
	bu_log("_rb_insert(%x): comparison = %d, returning %d\n",
	    new_node, comparison, result);

    return (result);
}

/**			B U _ R B _ I N S E R T ( )
 *
 *		Applications interface to _rb_insert()
 *
 *	This function has two parameters: the tree into which to insert
 *	the new node and the contents of the node.  If a uniqueness
 *	requirement would be violated, bu_rb_insert() does nothing but return
 *	a number from the set {-1, -2, ..., -nm_orders} of which the
 *	absolute value is the first order for which a violation exists.
 *	Otherwise, it returns the number of orders for which the new node
 *	was equal to a node already in the tree.
 */
int bu_rb_insert (bu_rb_tree *tree, void *data)
{
    int				nm_orders;
    int				order;
    int				result = 0;
    struct bu_rb_node		*node;
    struct bu_rb_package	*package;
    struct bu_rb_list		*rblp;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");

    nm_orders = tree -> rbt_nm_orders;

    /*
     *	Enforce uniqueness
     *
     *	NOTE: The approach is that for each order that requires uniqueness,
     *	    we look for a match.  This is not the most efficient way to do
     *	    things, since _rb_insert() is just going to turn around and
     *	    search the tree all over again.
     */
    for (order = 0; order < nm_orders; ++order)
	if (bu_rb_get_uniqueness(tree, order) &&
	    (bu_rb_search(tree, order, data) != NULL))
	{
	    if (tree -> rbt_debug & BU_RB_DEBUG_UNIQ)
		bu_log("bu_rb_insert(<%x>, <%x>, TBD) will return %d\n",
		    tree, data, -(order + 1));
	    return (-(order + 1));
	}

    /*
     *	Make a new package
     *	and add it to the list of all packages.
     */
    package = (struct bu_rb_package *)
		bu_malloc(sizeof(struct bu_rb_package), "red-black package");
    package -> rbp_node = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black package nodes");
    rblp = (struct bu_rb_list *)
		bu_malloc(sizeof(struct bu_rb_list),
			    "red-black list element");
    rblp -> rbl_magic = BU_RB_LIST_MAGIC;
    rblp -> rbl_package = package;
    BU_LIST_PUSH(&(tree -> rbt_packages.l), rblp);
    package -> rbp_list_pos = rblp;

    /*
     *	Make a new node
     *	and add it to the list of all nodes.
     */
    node = (struct bu_rb_node *)
		bu_malloc(sizeof(struct bu_rb_node), "red-black node");
    node -> rbn_parent = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black parents");
    node -> rbn_left = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black left children");
    node -> rbn_right = (struct bu_rb_node **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_node *),
			    "red-black right children");
    node -> rbn_color = (char *)
		bu_malloc((size_t) ceil((double) (nm_orders / 8.0)),
			    "red-black colors");
    node -> rbn_size = (int *)
		bu_malloc(nm_orders * sizeof(int),
			    "red-black subtree sizes");
    node -> rbn_package = (struct bu_rb_package **)
		bu_malloc(nm_orders * sizeof(struct bu_rb_package *),
			    "red-black packages");
    rblp = (struct bu_rb_list *)
		bu_malloc(sizeof(struct bu_rb_list),
			    "red-black list element");
    rblp -> rbl_magic = BU_RB_LIST_MAGIC;
    rblp -> rbl_node = node;
    BU_LIST_PUSH(&(tree -> rbt_nodes.l), rblp);
    node -> rbn_list_pos = rblp;

    /*
     *	Fill in the package
     */
    package -> rbp_magic = BU_RB_PKG_MAGIC;
    package -> rbp_data = data;
    for (order = 0; order < nm_orders; ++order)
	(package -> rbp_node)[order] = node;

    /*
     *	Fill in the node
     */
    node -> rbn_magic = BU_RB_NODE_MAGIC;
    node -> rbn_tree = tree;
    for (order = 0; order < nm_orders; ++order)
	(node -> rbn_package)[order] = package;
    node -> rbn_pkg_refs = nm_orders;

    /*
     *	If the tree was empty, install this node as the root
     *	and give it a null parent and null children
     */
    if (bu_rb_root(tree, 0) == bu_rb_null(tree))
	for (order = 0; order < nm_orders; ++order)
	{
	    bu_rb_root(tree, order) = node;
	    bu_rb_parent(node, order) =
	    bu_rb_left_child(node, order) =
	    bu_rb_right_child(node, order) = bu_rb_null(tree);
	    bu_rb_set_color(node, order, BU_RB_BLACK);
	    bu_rb_size(node, order) = 1;
	    if (tree -> rbt_debug & BU_RB_DEBUG_OS)
		bu_log("bu_rb_insert(<%x>, <%x>, <%x>): size(%x, %d)=%d\n",
		    tree, data, node, node, order, bu_rb_size(node, order));
	}
    /*	Otherwise, insert the node into the tree */
    else
    {
	for (order = 0; order < nm_orders; ++order)
	    result += _rb_insert(tree, order, node);
	if (tree -> rbt_debug & BU_RB_DEBUG_UNIQ)
	    bu_log("bu_rb_insert(<%x>, <%x>, <%x>) will return %d\n",
		tree, data, node, result);
    }

    ++(tree -> rbt_nm_nodes);
    bu_rb_current(tree) = node;
    return (result);
}

/**		        _ R B _ S E T _ U N I Q ( )
 *
 *	    Raise or lower the uniqueness flag for one linear order
 *			    of a red-black tree
 *
 *	This function has three parameters: the tree, the order for which
 *	to modify the flag, and the new value for the flag.  _rb_set_uniq()
 *	sets the specified flag to the specified value and returns the
 *	previous value of the flag.
 */
static int _rb_set_uniq (bu_rb_tree *tree, int order, int new_value)
{
    int	prev_value;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);
    new_value = (new_value != 0);

    prev_value = bu_rb_get_uniqueness(tree, order);
    bu_rb_set_uniqueness(tree, order, new_value);
    return (prev_value);
}

/*		         B U _ R B _ U N I Q _ O N ( )
 *		        B U _ R B _ U N I Q _ O F F ( )
 *
 *		Applications interface to _rb_set_uniq()
 *
 *	These functions have two parameters: the tree and the order for
 *	which to require uniqueness/permit nonuniqueness.  Each sets the
 *	specified flag to the specified value and returns the previous
 *	value of the flag.
 */
int bu_rb_uniq_on (bu_rb_tree *tree, int order)
{
    return (_rb_set_uniq(tree, order, 1));
}

int bu_rb_uniq_off (bu_rb_tree *tree, int order)
{
    return (_rb_set_uniq(tree, order, 0));
}

/**		         B U _ R B _ I S _ U N I Q ( )
 *
 *	  Query the uniqueness flag for one order of a red-black tree
 *
 *	This function has two parameters: the tree and the order for
 *	which to query uniqueness.
 */
int bu_rb_is_uniq (bu_rb_tree *tree, int order)
{
    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    BU_RB_CKORDER(tree, order);

    return(bu_rb_get_uniqueness(tree, order));
}

/**		        B U _ R B _ S E T _ U N I Q V ( )
 *
 *	    Set the uniqueness flags for all the linear orders
 *			    of a red-black tree
 *
 *	This function has two parameters: the tree and a bitv_t
 *	encoding the flag values.  bu_rb_set_uniqv() sets the flags
 *	according to the bits in flag_rep.  For example, if
 *	flag_rep = 1011_2, then the first, second, and fourth
 *	orders are specified unique, and the third is specified
 *	not-necessarily unique.
 */
void bu_rb_set_uniqv (bu_rb_tree *tree, bitv_t flag_rep)
{
    int	nm_orders;
    int	order;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");

    nm_orders = tree -> rbt_nm_orders;
    for (order = 0; order < nm_orders; ++order)
	bu_rb_set_uniqueness(tree, order, 0);

    for (order = 0; (flag_rep != 0) && (order < nm_orders); flag_rep >>= 1,
							    ++order)
	if (flag_rep & 0x1)
	    bu_rb_set_uniqueness(tree, order, 1);

    if (flag_rep != 0)
	bu_log("bu_rb_set_uniqv(): Ignoring bits beyond rightmost %d\n",
	    nm_orders);
}

/**		    _ R B _ S E T _ U N I Q _ A L L ( )
 *
 *	    Raise or lower the uniqueness flags for all the linear orders
 *			    of a red-black tree
 *
 *	This function has two parameters: the tree, and the new value
 *	for all the flags.
 */
static void _rb_set_uniq_all (bu_rb_tree *tree, int new_value)
{
    int	nm_orders;
    int	order;

    BU_CKMAG(tree, BU_RB_TREE_MAGIC, "red-black tree");
    new_value = (new_value != 0);

    nm_orders = tree -> rbt_nm_orders;
    for (order = 0; order < nm_orders; ++order)
	bu_rb_set_uniqueness(tree, order, new_value);
}

/**		     B U _ R B _ U N I Q _ A L L _ O N ( )
 *		    B U _ R B _ U N I Q _ A L L _ O F F ( )
 *
 *	      Applications interface to _rb_set_uniq_all()
 *
 *	These functions have one parameter: the tree for which to
 *	require uniqueness/permit nonuniqueness.
 */
void bu_rb_uniq_all_on (bu_rb_tree *tree)
{
    _rb_set_uniq_all(tree, 1);
}

void bu_rb_uniq_all_off (bu_rb_tree *tree)
{
    _rb_set_uniq_all(tree, 0);
}
/** @@} */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
@


14.15
log
@ugh, what tedium.  put some effort towards cleaning up the doxygen labels and making the headers more consistent.  also exclusively using @@ for doxygen instead of \ to try to keep things more consistent.
@
text
@d9 1
a9 2
 * as published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
d14 1
a14 1
 * Library General Public License for more details.
d35 1
a35 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.14 2007/01/20 14:36:51 brlcad Exp $";
@


14.14
log
@update copyright to 2007
@
text
@d21 2
a22 3

/** \addtogroup rb */
/*@@{*/
d24 1
d32 1
a32 1
 *@@n	Aberdeen Proving Ground, Maryland  21005-5068  USA
d36 1
a36 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.13 2006/08/31 23:16:38 lbutler Exp $";
d445 1
a445 1
/*@@}*/
@


14.13
log
@Doxygen comments
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2006 United States Government as represented by
d36 1
a36 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.12 2006/02/27 07:42:49 brlcad Exp $";
@


14.12
log
@quell warnings, need stdlib.h for exit routines
@
text
@d27 1
a27 1
 *  Author -
d30 1
a30 1
 *  Source -
d32 1
a32 1
 *	Aberdeen Proving Ground, Maryland  21005-5068  USA
a33 1
/*@@}*/
d36 1
a36 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.11 2006/01/18 06:46:16 brlcad Exp $";
d50 1
a50 1
/*			_ R B _ I N S E R T ( )
d175 1
a175 1
/*			B U _ R B _ I N S E R T ( )
d316 1
a316 1
/*		        _ R B _ S E T _ U N I Q ( )
d359 1
a359 1
/*		         B U _ R B _ I S _ U N I Q ( )
d374 1
a374 1
/*		        B U _ R B _ S E T _ U N I Q V ( )
d407 1
a407 1
/*		    _ R B _ S E T _ U N I Q _ A L L ( )
d428 1
a428 1
/*		     B U _ R B _ U N I Q _ A L L _ O N ( )
d445 1
@


14.11
log
@update copyright to 2006
@
text
@d37 1
a37 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.10 2005/10/23 04:44:32 brlcad Exp $";
d42 1
a42 2


d45 1
d50 1
@


14.10
log
@trailing ws
@
text
@d4 1
a4 1
 * Copyright (C) 1998-2005 United States Government as represented by
d37 1
a37 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.9 2005/08/12 22:29:23 lbutler Exp $";
@


14.9
log
@Doxygen changes
@
text
@d29 1
a29 1
 *  
d37 1
a37 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.8 2005/01/30 20:30:46 brlcad Exp $";
d396 1
a396 1
    
@


14.9.4.1
log
@merge changes from HEAD aka rel-7-6-4 to the rel-7-6-branch just in case someone peeks a gander or tries to continue/build the branch
@
text
@d29 1
a29 1
 *
d37 1
a37 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header$";
d396 1
a396 1

@


14.8
log
@update copyright to 2005
@
text
@d21 3
d34 2
d37 1
a37 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvsroot/brlcad/brlcad/src/libbu/rb_insert.c,v 14.7 2004/12/21 07:32:30 morrison Exp $";
@


14.7
log
@tidy up a lil bit
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 United States Government as represented by
d32 1
a32 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/rb_insert.c,v 14.6 2004/12/21 06:58:42 morrison Exp $";
@


14.6
log
@remove the old copyright notice section as it's been supplanted (and copyright is now claimable in the us via assignmgent)
@
text
@a29 2
 *  
 *
d32 1
a32 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/rb_insert.c,v 14.5 2004/12/21 06:44:32 morrison Exp $";
@


14.5
log
@remove the old distribution notice section
@
text
@a31 3
 *  Copyright Notice -
 *	This software is Copyright (C) 1998-2004 by the United States Army
 *	in all countries except the USA.  All rights reserved.
d34 1
a34 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/rb_insert.c,v 14.4 2004/12/21 06:18:43 morrison Exp $";
@


14.4
log
@they should have received a copy of the LGPL with LGPL'd files
@
text
@a30 4
 *  Distribution Notice -
 *	Re-distribution of this software is restricted, as described in
 *	your "Statement of Terms and Conditions for the Release of
 *	The BRL-CAD Package" agreement.
d37 1
a37 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/rb_insert.c,v 14.3 2004/12/21 05:45:21 morrison Exp $";
@


14.3
log
@s/GNU Library General/GNU Lesser General/g
@
text
@d17 2
a18 2
 * You should have received a copy of the GNU General Public License
 * along with this file; see the file named COPYING for more
d41 1
a41 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/rb_insert.c,v 14.2 2004/12/21 03:49:00 morrison Exp $";
@


14.2
log
@assign copyright and LGPL
@
text
@d8 1
a8 1
 * modify it under the terms of the GNU Library General Public License
d41 1
a41 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/rb_insert.c,v 14.1 2004/11/16 19:42:14 morrison Exp $";
@


14.1
log
@dawn of a new revision.  it shall be numbered 14 to match release 7.  begin the convergence by adding emacs/vi local variable footer blocks to encourage consistent formatting.
@
text
@d1 2
a2 1
/*			R B _ I N S E R T . C
d4 18
d41 1
a41 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/rb_insert.c,v 1.2 2004/08/02 23:01:48 morrison Exp $";
@


1.2
log
@replace the wrapped config.h block with common.h
@
text
@d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/src/libbu/rb_insert.c,v 1.1 2004/05/20 15:19:35 morrison Exp $";
d430 10
@


1.1
log
@Vast reorganization begins.  Sources moved from top-level directories into src/.
@
text
@d22 1
a22 1
static const char libbu_rb_insert_RCSid[] = "@@(#) $Header: /cvs/brlcad/libbu/rb_insert.c,v 11.17 2004/05/10 15:30:44 erikg Exp $";
d25 1
a25 3
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
@

