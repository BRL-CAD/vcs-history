head	11.10;
access;
symbols
	ansi-20040405-merged:11.7.2.1
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.7
	premerge-autoconf:11.7
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.7
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.2
	offsite-5-3-pre:11.4
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.16.38.46;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.05.46.00;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.08.48;	author jra;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2002.08.15.20.56.00;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.04.20.22.31.26;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.24.22.51.10;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.22.46.18;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.17.17.00.59;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.20.32;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	94.12.01.19.54.11;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.08.11.20.08.48;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.16.44.47;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.52.15;	author mike;	state Rel4_0;
branches;
next	1.1;

1.1
date	91.01.24.20.33.54;	author butler;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.02.27;	author morrison;	state Exp;
branches;
next	;


desc
@Original distribution of Rel. 3 patchlevel 2
@


11.10
log
@moved to src/tools/
@
text
@/*
 * This software is copyrighted as noted below.  It may be freely copied,
 * modified, and redistributed, provided that the copyright notice is 
 * preserved on all copies.
 * 
 * There is no warranty or other guarantee of fitness for this software,
 * it is provided solely "as is".  Bug reports or fixes may be sent
 * to the author, who may or may not act on them as he desires.
 *
 * You may not include this software in a program or other software product
 * without supplying the source, or without informing the end-user that the 
 * source is available for no extra charge.
 *
 * If you modify this software, you should include a notice giving the
 * name of the person performing the modification, the date of modification,
 * and the reason for such modification.
 */
/* +------------------------------------------------------------------+ */
/* | Copyright 1989, David Koblas.                                    | */
/* |   You may copy this file in whole or in part as long as you      | */
/* |   don't try to make money off it, or pretend that you wrote it.  | */
/* +------------------------------------------------------------------+ */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include	<stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"
#include "rle.h"

#ifndef lint
static const char rcsid[] = "$Id: giftorle.c,v 11.9 2004/05/10 15:30:50 erikg Exp $";
#endif

#define	MAXCOLORMAPSIZE		256

#ifndef TRUE
#define	TRUE	1
#endif
#ifndef FALSE
#define	FALSE	0
#endif

#define CM_RED		0
#define CM_GREEN	1
#define CM_BLUE		2

#define	MAX_LWZ_BITS		12

#define	ReadOK(file,buffer,len)	(fread(buffer,len,1,file)!=0)
#define	EasyFail(str,status)	{fprintf(stderr,str);return(status);}
#define	HardFail(str,status)	{fprintf(stderr,str);exit  (status);}

#define LM_to_uint(a,b)			(((b)<<8)|(a))

int ReadGIF(char *filename);
int ReadColorMap(FILE *fd, int number, unsigned char (*buffer)[MAXCOLORMAPSIZE]);
int IgnoreExtention(FILE *fd), GetCode(FILE *fd, int code_size, int flag);
int LWZReadByte(FILE *fd, int flag, int input_code_size);
int ReadInterlaced(FILE *fd, int len, int height, unsigned char (*cmap)[MAXCOLORMAPSIZE]);
int ReadRaster(FILE *fd, int len, int height, unsigned char (*cmap)[MAXCOLORMAPSIZE]);

static rle_map out_map[3*(1<<8)];

const char *MY_NAME = "giftorle";

FILE *outfile;

struct {
	unsigned int		Width;
	unsigned int		Height;
	unsigned char		ColorMap[3][MAXCOLORMAPSIZE];
	unsigned int		BitPixel;
	unsigned int		ColorResolution;
	unsigned int		Background;
} Screen;

static int output_colormap = FALSE;

int
main(int argc, char **argv)
{
    int		oflag = 0, 
    nfname = 0;
    char	       *outfname = NULL, 
    **infname = NULL;

    MY_NAME = cmd_name( argv );

    if ( scanargs( argc, argv, "% c%- o%-outfile.rle!s infile.gif%*s",
		   &output_colormap, &oflag, &outfname,
		   &nfname, &infname ) == 0 )
	exit( 1 );

    outfile = rle_open_f( MY_NAME, outfname, "w" );
    rle_addhist( argv, (rle_hdr *)0, &rle_dflt_hdr );

    /* Always read at least one (standard input). */
    if ( nfname == 0 )
	(void)ReadGIF( NULL );

    while ( nfname-- > 0 )
	(void)ReadGIF( *infname++ );
    return 0;
}

int
ReadGIF(char *filename)
{
    unsigned char	buf[16];
    unsigned char	c;
    unsigned char	LocalColorMap[3][MAXCOLORMAPSIZE];
    FILE			*fd;
    int				use_global_colormap;
    int				bit_pixel;
    int				count=0;

    fd = rle_open_f( MY_NAME, filename, "r" );

    if (! ReadOK(fd,buf,6))
	EasyFail("error reading magic number\n",TRUE);
    if (strncmp((char *)buf,"GIF87a",6)!=0)
	EasyFail("bad magic number (version mismatch?)\n",TRUE);
    if (! ReadOK(fd,buf,7))
	EasyFail("error reading screen descriptor\n",TRUE);
    Screen.Width           = LM_to_uint(buf[0],buf[1]);
    Screen.Height          = LM_to_uint(buf[2],buf[3]);
    Screen.BitPixel        = 2<<(buf[4]&0x07);
    Screen.ColorResolution = (((unsigned)(buf[4]&0x70)>>3)+1);
    Screen.Background      = buf[5];
    if ((buf[4]&0x80)==0x80) {
	if (ReadColorMap(fd,Screen.BitPixel,Screen.ColorMap))
	    return (TRUE);
    }

    while (1) {
	if (! ReadOK(fd,&c,1))
	    EasyFail("No image data -- EOF\n",TRUE);
	if (c == ';') 
	    return FALSE;
	if (c == '!') {
	    if (! ReadOK(fd,&c,1))
		EasyFail("No extention function code -- EOF\n",TRUE);
	    if (IgnoreExtention(fd))
		return(TRUE);
	}
	if (c != ',') {
	    fprintf(stderr,"Bogus character ignoring '%c'\n",c);
	    continue;
	}
	if (count == 1)
	    HardFail("This file contains more than one image! FAILING\n",1);
	count++;

	if (! ReadOK(fd,buf,9))
	    EasyFail("Couldn't read left/top/width/height\n",TRUE);
	if ((buf[8]&0x80)==0x80)
	    use_global_colormap = FALSE ;
	else
	    use_global_colormap = TRUE ;

	bit_pixel = 1<<((buf[8]&0x07)+1);

	if (! use_global_colormap) {
	    if (ReadColorMap(fd,bit_pixel,LocalColorMap))
		return TRUE;
	}

	if ((buf[8]&0x40)==0x40) {
	    if (ReadInterlaced(fd,LM_to_uint(buf[4],buf[5]),
			       LM_to_uint(buf[6],buf[7]),
			       use_global_colormap?Screen.ColorMap:LocalColorMap))
		return TRUE;
	} else {
	    if (ReadRaster(fd,LM_to_uint(buf[4],buf[5]),
			   LM_to_uint(buf[6],buf[7]),
			   use_global_colormap?Screen.ColorMap:LocalColorMap))
		return TRUE;
	}
    }
}

int
ReadColorMap(FILE *fd, int number, unsigned char (*buffer)[MAXCOLORMAPSIZE])
{
    int				i;
    unsigned char	rgb[3];

    for (i=0;i<number;i++) {
	if (! ReadOK(fd,rgb,sizeof(rgb)))
	    EasyFail("Bogus colormap\n",TRUE);
	buffer[CM_RED][i] = rgb[0] ;
	buffer[CM_GREEN][i] = rgb[1] ;
	buffer[CM_BLUE][i] = rgb[2] ;
    }
    return FALSE;
}

int
IgnoreExtention(FILE *fd)
{
    static char		buf[256];
    unsigned char	c;

    while (1) {
	if (! ReadOK(fd,&c,1))
	    EasyFail("EOF in extention\n",TRUE);
	if (c == 0)
	    return FALSE;
	if (read(fileno(fd),buf,(int) c)!=(int) c) 
	    EasyFail("EOF in extention\n",TRUE);
    }
}

int
GetCode(FILE *fd, int code_size, int flag)
{
    static unsigned char	buf[280];
    static int				curbit,lastbit,done,last_byte;
    int						i, j, ret;
    unsigned char			count;

    if (flag) {
	curbit = 0;
	lastbit = 0;
	done = FALSE;
	return 0;
    }

    if ( (curbit+code_size) >= lastbit) {
	if (done) {
	    if (curbit>=lastbit)
		EasyFail("Ran off the end of my bits\n",-1);
	}
	buf[0] = buf[last_byte-2];
	buf[1] = buf[last_byte-1];
	if (! ReadOK(fd,&count,1)) {
	    EasyFail("Error in getting buffer size\n",-1);
	}
	if (count == 0) {
	    done = TRUE;
	} else if (! ReadOK(fd,&buf[2],count))
	    EasyFail("Error in getting buffer\n",-1);
	last_byte = 2 + count;
	curbit = (curbit - lastbit) + 16;
	lastbit = (2+count)*8 ;
    }

    ret = 0;
    for( i = curbit, j = 0; j < code_size; i++, j++ ) 
	ret |= ((buf[ i / 8 ] & (1 << (i % 8))) != 0) << j;

    curbit += code_size;

    return ret;
}

int
LWZReadByte(FILE *fd, int flag, int input_code_size)
{
    static int		fresh=FALSE;
    int				code,incode;
    static int		code_size,set_code_size;
    static int		max_code,max_code_size;
    static int		firstcode,oldcode;
    static int		clear_code,end_code;
    static int		table[2][(1<< MAX_LWZ_BITS)];
    static int		stack[(1<<(MAX_LWZ_BITS))*2],*sp;
    register int	i;

    if (flag) {
	set_code_size = input_code_size;
	code_size = set_code_size+1;
	clear_code = 1 << set_code_size ;
	end_code = clear_code + 1;
	max_code_size = 2*clear_code;
	max_code = clear_code+2;

	GetCode(fd,0,TRUE);
		
	fresh=TRUE;

	for (i=0;i<clear_code;i++) {
	    table[0][i] = 0;
	    table[1][i] = i;
	}
	for (;i<(1<<MAX_LWZ_BITS);i++)
	    table[0][i] = table[1][0] = 0;

	sp=stack;

	return 0;
    } else if (fresh) {
	fresh = FALSE;
	do {
	    firstcode=oldcode=
		GetCode(fd, code_size, FALSE);
	} while (firstcode == clear_code);
	return firstcode;
    }

    if (sp > stack) 
	return *--sp;

    while ((code=GetCode(fd,code_size,FALSE))>=0) {
	if (code == clear_code) {
	    for (i=0;i<clear_code;i++) {
		table[0][i] = 0;
		table[1][i] = i;
	    }
	    for (;i<(1<<MAX_LWZ_BITS);i++)
		table[0][i] = table[1][i] = 0;
	    code_size = set_code_size+1;
	    max_code_size = 2*clear_code;
	    max_code = clear_code+2;
	    sp=stack; 
	    firstcode=oldcode=
		GetCode(fd,code_size,FALSE);
	    return firstcode;
	} else if (code == end_code) {
	    unsigned char		count;
	    unsigned char		junk;

	    while (ReadOK(fd,&count,1) && (count!=0))
		while (count-->0 && ReadOK(fd,&junk,1));
	    if (count!=0)
		EasyFail("missing EOD in data stream (common occurance)\n",-3);
	    return -2;
	}

	incode = code;

	if (code >= max_code) {
	    *sp++ = firstcode;
	    code = oldcode;
	}

	while (code >= clear_code) {
	    *sp++ = table[1][code];
	    if (code == table[0][code])
		EasyFail("Circular table entry BIG ERROR\n",-1);
	    code = table[0][code];
	}

	*sp++ = firstcode = table[1][code];

	if ((code=max_code)<(1<<MAX_LWZ_BITS)) {
	    table[0][code] = oldcode;
	    table[1][code] = firstcode;
	    max_code++;
	    if ((max_code >= max_code_size) && 
		(max_code_size < (1<<MAX_LWZ_BITS))) {
		max_code_size *= 2;
		code_size++;
	    }
	}

	oldcode = incode;

	if (sp > stack) 
	    return *--sp;
    }
    return code;
}

int
ReadInterlaced(FILE *fd, int len, int height, unsigned char (*cmap)[MAXCOLORMAPSIZE])
{
    unsigned char		c;	
    int					v;
    int					xpos=0;
    rle_pixel			**scanline[3];
    rle_pixel			*ptr[3] ;
    rle_hdr	hdr;
    int					i,j;
    int					ypos=0,pass=0;


    for (j=0;j<(output_colormap?1:3);j++) {
	if ((scanline[j]=(rle_pixel **)
	     malloc(height*sizeof(rle_pixel *)))==NULL)
	    EasyFail("Unable to malloc space for pixels #1\n",1);
	for (i=0;i<height;i++) {
	    if ((scanline[j][i]=(rle_pixel *)
		 malloc(len*sizeof(rle_pixel)))==NULL) {
		for (;j>=0;j--)
		    for (;i>=0;i--)
			if (scanline[j][i]!=NULL) free(scanline[i]);
		EasyFail("Unable to malloc space for pixels #2\n",1);
	    }
	}
    }

    hdr = rle_dflt_hdr;

    if (output_colormap) {
	hdr.ncolors =  1;
	hdr.ncmap = 3;
	hdr.cmaplen = 8;
	hdr.cmap = out_map;
	for (i=0;i<(1<<8);i++) {
	    out_map[i+(0<<8)] = cmap[CM_RED][i] << 8;
	    out_map[i+(1<<8)] = cmap[CM_GREEN][i] << 8;
	    out_map[i+(2<<8)] = cmap[CM_BLUE][i] << 8;
	}
    } else {
	RLE_SET_BIT(hdr, RLE_RED);
	RLE_SET_BIT(hdr, RLE_GREEN);
	RLE_SET_BIT(hdr, RLE_BLUE);
	hdr.ncolors =  3;
    }
    hdr.rle_file = outfile ;
    hdr.xmax = len - 1;
    hdr.ymax = height - 1;

    rle_put_setup(&hdr);

    if (! ReadOK(fd,&c,1))
	EasyFail("Bogus image data -- EOF\n",TRUE);
    if (LWZReadByte(fd,TRUE,c)<0)
	return TRUE;

    while ((v=LWZReadByte(fd,FALSE,c))>=0) {
	if (output_colormap) {
	    scanline[RLE_RED][ypos][xpos]   = v ;
	} else {
	    scanline[RLE_RED][ypos][xpos]   = cmap[CM_RED][v] ;
	    scanline[RLE_GREEN][ypos][xpos] = cmap[CM_GREEN][v] ;
	    scanline[RLE_BLUE][ypos][xpos]  = cmap[CM_BLUE][v] ;
	}
	xpos++;
	if (xpos==len) {
	    xpos = 0;
	    switch (pass) {
	    case 0: 
	    case 1:
		ypos += 8; break;
	    case 2:
		ypos += 4; break;
	    case 3:
		ypos += 2; break;
	    }
	    if (ypos >= height) {
		pass++;
		switch (pass) {
		case 1:
		    ypos = 4; break;
		case 2:
		    ypos = 2; break;
		case 3:
		    ypos = 1; break;
		}
	    }
	}
    }

    for (i=0;i<height;i++) {
	ptr[0] = scanline[RLE_RED][i] ;
	if (! output_colormap) {
	    ptr[1] = scanline[RLE_GREEN][i] ;
	    ptr[2] = scanline[RLE_BLUE][i] ;
	}
	rle_putrow(ptr,len,&hdr);
    }

    rle_puteof(&hdr);

    for (i=0;i<height;i++) {
	if (scanline[0][i]!=NULL) free(scanline[0][i]);
	if (output_colormap) continue;

	if (scanline[1][i]!=NULL) free(scanline[1][i]);
	if (scanline[2][i]!=NULL) free(scanline[2][i]);
    }
    free(scanline[0]);
    if (! output_colormap) {
	free(scanline[1]); 
	free(scanline[2]);
    }

    if (v==(-2))
	return FALSE;
    return TRUE;
}

int
ReadRaster(FILE *fd, int len, int height, unsigned char (*cmap)[MAXCOLORMAPSIZE])
{
    unsigned char		c;	
    int					v;
    int					xpos=0;
    rle_pixel			*scanline[3];
    rle_hdr	hdr ;
    int					i;

    if (((scanline[0]=(rle_pixel *)malloc(len*sizeof(rle_pixel)))==NULL) ||
	((scanline[1]=(rle_pixel *)malloc(len*sizeof(rle_pixel)))==NULL) ||
	((scanline[2]=(rle_pixel *)malloc(len*sizeof(rle_pixel)))==NULL))
	EasyFail("Unable to malloc space for pixels\n",1);

    hdr = rle_dflt_hdr;

    if (output_colormap) {
	hdr.ncolors =  1;
	hdr.ncmap = 3;
	hdr.cmaplen = 8;
	hdr.cmap = out_map;
	for (i=0;i<(1<<8);i++) {
	    out_map[i+(0<<8)] = cmap[CM_RED][i] << 8;
	    out_map[i+(1<<8)] = cmap[CM_GREEN][i] << 8;
	    out_map[i+(2<<8)] = cmap[CM_BLUE][i] << 8;
	}
    } else {
	RLE_SET_BIT(hdr, RLE_RED);
	RLE_SET_BIT(hdr, RLE_GREEN);
	RLE_SET_BIT(hdr, RLE_BLUE);
	hdr.ncolors =  3;
    }
    hdr.rle_file = outfile ;
    hdr.xmax = len - 1;
    hdr.ymax = height - 1;

    rle_put_setup(&hdr);

    if (! ReadOK(fd,&c,1))
	EasyFail("Bogus image data -- EOF\n",TRUE);
    if (LWZReadByte(fd,TRUE,c)<0)
	return TRUE;

    while ((v=LWZReadByte(fd,FALSE,c))>=0) {
	if (output_colormap) {
	    scanline[RLE_RED][xpos]   = v ;
	} else {
	    scanline[RLE_RED][xpos]   = cmap[CM_RED][v] ;
	    scanline[RLE_GREEN][xpos] = cmap[CM_GREEN][v] ;
	    scanline[RLE_BLUE][xpos]  = cmap[CM_BLUE][v] ;
	}
	xpos++;
	if (xpos==len) {
	    rle_putrow(scanline,len,&hdr);
	    xpos=0;
	}
    }

    if (xpos!=0) 
	rle_putrow(scanline,xpos,&hdr);

    rle_puteof(&hdr);

    free(scanline[0]);
    free(scanline[1]);
    free(scanline[2]);

    if (v==(-2))
	return FALSE;
    return TRUE;
}
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d42 1
a42 1
static const char rcsid[] = "$Id: giftorle.c,v 11.8 2004/04/05 05:46:00 morrison Exp $";
@


11.8
log
@merge of ansi-6-0-branch into head
@
text
@d24 5
a28 1
#include "conf.h"
d42 1
a42 1
static const char rcsid[] = "$Id$";
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d38 1
a38 1
static const char rcsid[] = "$Id: giftorle.c,v 11.5 2001/04/20 22:31:26 morrison Exp $";
d62 6
a67 3
int ReadGIF();
int ReadColorMap(), IgnoreExtention(), GetCode(), LWZReadByte();
int ReadInterlaced(), ReadRaster();
d87 1
a87 3
main(argc,argv)
int	argc;
char	**argv;
d114 1
a114 2
ReadGIF(filename)
char	*filename;
d190 1
a190 4
ReadColorMap(fd,number,buffer)
FILE			*fd;
int				number;
unsigned char	buffer[3][MAXCOLORMAPSIZE];
d206 1
a206 2
IgnoreExtention(fd)
FILE	*fd;
d222 1
a222 4
GetCode(fd, code_size, flag)
FILE	*fd;
int		code_size;
int		flag;
d265 1
a265 4
LWZReadByte(fd,flag,input_code_size)
FILE	*fd;
int		flag;
int		input_code_size;
d373 1
a373 4
ReadInterlaced(fd,len,height,cmap)
FILE	*fd;
int		len,height;
char	cmap[3][MAXCOLORMAPSIZE];
d493 1
a493 4
ReadRaster(fd,len,height,cmap)
FILE	*fd;
int		len,height;
char	cmap[3][MAXCOLORMAPSIZE];
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d38 1
a38 1
static const char rcsid[] = "$Id: giftorle.c,v 11.7 2002/08/20 17:08:48 jra Exp $";
d62 3
a64 6
int ReadGIF(char *filename);
int ReadColorMap(FILE *fd, int number, unsigned char (*buffer)[256]);
int IgnoreExtention(FILE *fd), GetCode(FILE *fd, int code_size, int flag);
int LWZReadByte(FILE *fd, int flag, int input_code_size);
int ReadInterlaced(FILE *fd, int len, int height, unsigned char (*cmap)[256]);
int ReadRaster(FILE *fd, int len, int height, unsigned char (*cmap)[256]);
d84 3
a86 1
main(int argc, char **argv)
d113 2
a114 1
ReadGIF(char *filename)
d190 4
a193 1
ReadColorMap(FILE *fd, int number, unsigned char (*buffer)[256])
d209 2
a210 1
IgnoreExtention(FILE *fd)
d226 4
a229 1
GetCode(FILE *fd, int code_size, int flag)
d272 4
a275 1
LWZReadByte(FILE *fd, int flag, int input_code_size)
d383 4
a386 1
ReadInterlaced(FILE *fd, int len, int height, unsigned char (*cmap)[256])
d506 4
a509 1
ReadRaster(FILE *fd, int len, int height, unsigned char (*cmap)[256])
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d62 3
a64 6
int ReadGIF(char *filename);
int ReadColorMap(FILE *fd, int number, unsigned char (*buffer)[256]);
int IgnoreExtention(FILE *fd), GetCode(FILE *fd, int code_size, int flag);
int LWZReadByte(FILE *fd, int flag, int input_code_size);
int ReadInterlaced(FILE *fd, int len, int height, unsigned char (*cmap)[256]);
int ReadRaster(FILE *fd, int len, int height, unsigned char (*cmap)[256]);
d84 3
a86 1
main(int argc, char **argv)
d113 2
a114 1
ReadGIF(char *filename)
d190 4
a193 1
ReadColorMap(FILE *fd, int number, unsigned char (*buffer)[256])
d209 2
a210 1
IgnoreExtention(FILE *fd)
d226 4
a229 1
GetCode(FILE *fd, int code_size, int flag)
d272 4
a275 1
LWZReadByte(FILE *fd, int flag, int input_code_size)
d383 4
a386 1
ReadInterlaced(FILE *fd, int len, int height, unsigned char (*cmap)[256])
d506 4
a509 1
ReadRaster(FILE *fd, int len, int height, unsigned char (*cmap)[256])
@


11.5
log
@CONST to const
@
text
@d38 1
a38 1
static const char rcsid[] = "$Id: giftorle.c,v 11.4 2000/08/24 22:51:10 mike Exp $";
d62 6
a67 3
int ReadGIF();
int ReadColorMap(), IgnoreExtention(), GetCode(), LWZReadByte();
int ReadInterlaced(), ReadRaster();
d87 1
a87 3
main(argc,argv)
int	argc;
char	**argv;
d114 1
a114 2
ReadGIF(filename)
char	*filename;
d190 1
a190 4
ReadColorMap(fd,number,buffer)
FILE			*fd;
int				number;
unsigned char	buffer[3][MAXCOLORMAPSIZE];
d206 1
a206 2
IgnoreExtention(fd)
FILE	*fd;
d222 1
a222 4
GetCode(fd, code_size, flag)
FILE	*fd;
int		code_size;
int		flag;
d265 1
a265 4
LWZReadByte(fd,flag,input_code_size)
FILE	*fd;
int		flag;
int		input_code_size;
d373 1
a373 4
ReadInterlaced(fd,len,height,cmap)
FILE	*fd;
int		len,height;
char	cmap[3][MAXCOLORMAPSIZE];
d493 1
a493 4
ReadRaster(fd,len,height,cmap)
FILE	*fd;
int		len,height;
char	cmap[3][MAXCOLORMAPSIZE];
@


11.4
log
@
lint
@
text
@d38 1
a38 1
static const char rcsid[] = "$Id: giftorle.c,v 11.3 2000/08/24 22:46:18 mike Exp $";
d68 1
a68 1
CONST char *MY_NAME = "giftorle";
@


11.3
log
@
lint
@
text
@d38 1
a38 1
static const char rcsid[] = "$Id: giftorle.c,v 11.2 1996/07/17 17:00:59 jra Exp $";
d109 1
@


11.2
log
@Minor Mods for IRIX 6.2
@
text
@d38 1
a38 1
static char rcsid[] = "$Id: giftorle.c,v 11.1 1995/01/04 10:20:32 mike Rel4_4 jra $";
d83 1
a83 1
void
@


11.1
log
@Release_4.4
@
text
@d38 1
a38 1
static char rcsid[] = "$Id: giftorle.c,v 10.4 94/12/01 19:54:11 mike Exp $";
d294 1
a294 1
	GetCode(fd,NULL,TRUE);
@


10.4
log
@Solaris ANSI
@
text
@d38 1
a38 1
static char rcsid[] = "$Id: giftorle.c,v 10.3 94/08/11 20:08:48 gdurf Exp Locker: mike $";
@


10.3
log
@Altered #defines and #includes to conform to BRL-CAD standards
@
text
@d38 1
a38 1
static char rcsid[] = "$Id: giftorle.c,v 10.2 1994/08/11 16:44:47 gdurf Exp gdurf $";
d134 1
a134 1
    Screen.ColorResolution = (((buf[4]&0x70)>>3)+1);
@


10.2
log
@Altered #defines and #includes to conform to BRL-CAD standards
@
text
@d35 1
a35 1
#include	"rle.h"
d38 1
a38 1
static char rcsid[] = "$Id: giftorle.c,v 10.1 1991/10/12 06:52:15 mike Rel4_0 gdurf $";
d68 1
a68 1
CONST_DECL char *MY_NAME = "giftorle";
d219 1
a219 1
	if (read(fd,buf,(int) c)!=(int) c) 
@


10.1
log
@Release_4.0
@
text
@d24 2
a26 6
#include	"rle.h"

#ifdef USE_STDLIB_H
#include <stdlib.h>
#else

d33 3
a35 8
#ifdef VOID_STAR
extern void *malloc();
#else
extern char *malloc();
#endif
extern void free();

#endif /* USE_STDLIB_H */
d38 1
a38 1
static char rcsid[] = "$Id: giftorle.c,v 3.1 90/08/15 13:24:45 spencer Exp $";
d43 1
d45 2
d48 1
@


1.1
log
@Initial revision
@
text
@@
