head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.16.39.01;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.05.46.01;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.08.51;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.56.03;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2001.08.10.20.44.36;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.22.46.24;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.21.33;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.11.20.09.24;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.53.07;	author mike;	state Rel4_0;
branches;
next	1.1;

1.1
date	91.01.24.20.34.11;	author butler;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.02.31;	author morrison;	state Exp;
branches;
next	;


desc
@Original distribution of Rel. 3 patchlevel 2
@


11.8
log
@moved to src/tools/
@
text
@/*
 * This software is copyrighted as noted below.  It may be freely copied,
 * modified, and redistributed, provided that the copyright notice is
 * preserved on all copies.
 *
 * There is no warranty or other guarantee of fitness for this software,
 * it is provided solely "as is".  Bug reports or fixes may be sent
 * to the author, who may or may not act on them as he desires.
 *
 * You may not include this software in a program or other software product
 * without supplying the source, or without informing the end-user that the
 * source is available for no extra charge.
 *
 * If you modify this software, you should include a notice giving the
 * name of the person performing the modification, the date of modification,
 * and the reason for such modification.
 *
 * Copyright (c) 1986, John W. Peterson
 */

/* 
 * targatorle.c - Convert TIPS (Targa, AT&T format #2) images to RLE.
 * Modified from painttorle.c
 * Note that color map in the targa file is ignored in this routine.
 * 
 * Author:	Hann-Bin Chuang
 * 		Department of Chemistry
 *		Boston University
 * Date:	Tue. Aug 25 1987
 *
 * Usage is:
 *   targatorle  [-h header.lis] [-o outfile.rle] [infile.tga] 
 *
 * -h header.lis	write the targa header information to file "header.lis"
 * -o outfile.rle	instead of stdout, use outfile.rle as output.
 *
 * rleflip is not necessary because Targa images and RLE both use
 * the last line (in the file) as the upper left of the image.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <sys/types.h>

#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#include "machine.h"
#include "externs.h"			/* For malloc and free */
#include "rle.h"

/*
 * Description of header for files containing targa type 2 images
 */
struct targafile {
  unsigned char   num_char_id,    /* Number of Characters in ID Field */
    cmap_type,      /* Color Map Type */
    image_type;     /* Image Type Code */
  unsigned short  cmap_origin,    /* Color Map Origin */
    cmap_length;    /* Color Map Length */
  unsigned char   cmap_size;      /* Color Map Entry Size */
  unsigned short  image_x_origin, /* X-Origin of Image */
    image_y_origin, /* Y-Origin of Image */
    image_width,    /* Width of Image */
    image_height;   /* Height of Image */
  unsigned char   image_pix_size, /* Image Pixel Size */
    image_descriptor;       /* Image Descriptor Byte */
  unsigned char   *image_id;      /* Image ID Field */
  unsigned char   *cmap_data;     /* color Map data */
};

/*
 *	Nb. all quantities in the float structure are right justified.
 *	I.e., sign == 0 || sign == 1
 */

struct fstruct {
  unsigned short  sign;
  unsigned short  exp;
  unsigned long   mant;
};



/* Default color values */
unsigned char	in_line[512];
unsigned char	*outrows[4];
unsigned char	redline[512], grnline[512], bluline[512], alfline[512];

unsigned short *svaxswap(unsigned short int *sptr, long int nshort);
long *lvaxswap(long int *lptr, long int nlong);
void fvaxget(struct fstruct *fsptr, caddr_t fptr);
void fsunput(float *fptr, struct fstruct *fsptr);
void fsunget(struct fstruct *fsptr, float *fptr);
void fvaxput(caddr_t fptr, struct fstruct *fsptr);

int
main(int argc, char **argv)
{ 
  FILE *infile;	
  FILE *outfile;
  FILE *hdrfile=NULL;
  char *infname=NULL;
  char *outfname=NULL;
  char *hdrfname=NULL;
  int oflag=0;
  int hflag=0;
  int i;
  int j;
  struct targafile tga_head;

  if ( scanargs( argc,argv, "% h%-hdrfile!s o%-outfile!s infile%s",
		 &hflag, &hdrfname, &oflag, &outfname, &infname ) == 0 )
    exit(1);


  infile  = rle_open_f("targatorle", infname, "r");
  if ( hflag )
    hdrfile = rle_open_f("targatorle", hdrfname, "w");
  outfile = rle_open_f("targatorle", outfname, "w");
  /* Check that hdrfile and outfile aren't the same. */
  if ( hdrfile == outfile )
    {
      fprintf( stderr,
	       "targatorle: Can't write header and RLE data to same file.\n" );
      exit( 1 );
    }

  fread (&tga_head, 3, 1, infile);
  if (hflag) {
    fprintf (hdrfile, "num_char_id = %d \n", (int)tga_head.num_char_id);
    fprintf (hdrfile, "cmap_type   = %d \n", (int)tga_head.cmap_type);
    fprintf (hdrfile, "image_type  = %d \n", (int)tga_head.image_type);
  }

  if ((int)tga_head.cmap_type==0) { 
    if (hflag) {
      fprintf (hdrfile, "Color Map Type = 0 \n");
    }
  }
  else if ((int)tga_head.cmap_type==1) {
    fread (&(tga_head.cmap_origin), 5, 1, infile);
    svaxswap(&(tga_head.cmap_origin), 2);
    if (hflag) {
      fprintf (hdrfile, "cmap_origin = %d \n",
	       (int)tga_head.cmap_origin);
      fprintf (hdrfile, "cmap_length = %d \n",
	       (int)tga_head.cmap_length);
      fprintf (hdrfile, "cmap_size   = %d \n",
	       (int)tga_head.cmap_size);
    }
  }
  else {
    perror ("Invalid Color Map Type for RGB (UNMAPPED) IMAGES\n");
    exit (1);
  }

  fread (&(tga_head.image_x_origin), 10, 1, infile);
  svaxswap(&(tga_head.image_x_origin), 4);
  if (hflag) {
    fprintf (hdrfile, "image_x_origin = %d \n",
	     (int)tga_head.image_x_origin);
    fprintf (hdrfile, "image_y_origin = %d \n",
	     (int)tga_head.image_y_origin);
    fprintf (hdrfile, "image_width    = %d \n",
	     (int)tga_head.image_width);
    fprintf (hdrfile, "image_height   = %d \n",
	     (int)tga_head.image_height);
    fprintf (hdrfile, "image_pix_size = %d \n",
	     (int)tga_head.image_pix_size);
  }

  if ((i=(int)tga_head.num_char_id)>=1) {
    tga_head.image_id = (unsigned char *)malloc(i);
    fread (tga_head.image_id, i, 1, infile);
  }

  if ((int)tga_head.cmap_type==1) {
    if ((int)tga_head.cmap_size==24) {
      i=24*256/8;
      tga_head.cmap_data = (unsigned char *)malloc(i);
      fread (tga_head.cmap_data, i, 1, infile);
    }
    else {
      perror ("Invalid color map length \n");
      exit(1);
    }
  }
          
  RLE_SET_BIT(rle_dflt_hdr, RLE_RED);
  RLE_SET_BIT(rle_dflt_hdr, RLE_GREEN);
  RLE_SET_BIT(rle_dflt_hdr, RLE_BLUE);
  RLE_SET_BIT(rle_dflt_hdr, RLE_ALPHA);
  rle_dflt_hdr.rle_file = outfile;
  rle_dflt_hdr.xmax = (int)tga_head.image_width-1;
  rle_dflt_hdr.ymax = (int)tga_head.image_height-1;
  rle_dflt_hdr.alpha = 1;

  outrows[0] = alfline;
  outrows[1] = redline;
  outrows[2] = grnline;
  outrows[3] = bluline;

  rle_addhist( argv, (rle_hdr *)NULL, &rle_dflt_hdr );
  rle_put_setup( &rle_dflt_hdr );

  /* read and process each of the tga_head.image_height targa scan lines */
  for (i=0;i<(int)tga_head.image_height;i++) {
    for (j=0;j<(int)tga_head.image_width;j++) {
      bluline[j]=getc(infile);
      grnline[j]=getc(infile);
      redline[j]=getc(infile);
      alfline[j]=getc(infile);
    }
    rle_putrow (&outrows[1], (int)tga_head.image_width, &rle_dflt_hdr);
  }
  rle_puteof( &rle_dflt_hdr );
  return 0;
}

/*
 *	long  *
 *	lvaxswap( lptr, nlong )
 *	long  *lptr;
 *	long   nlong;
 *
 *	lvaxswap converts an array of nlong long ints pointed to by lptr
 *	from VAX byte order to MC680n0 byte order or vice versa.
 *	It returns a pointer to the location immediately following
 *	the last position swapped.
 *
 *
 *	short  *
 *	svaxswap( sptr, nshort )
 *	short  *sptr;
 *	long   nshort;
 *
 *	svaxswap converts an array of nshort short ints pointed to by sptr
 *	from VAX byte order to MC680n0 byte order or vice versa.
 *	It returns a pointer to the location immediately following
 *	the last position swapped.
 *
 *
 *	float  *
 *	fvaxtosun( fptr, nfloat )
 *	c_addr  *fptr;
 *	long     nfloat;
 *
 *	fvaxtosun converts an array of nfloat VAX format F*4 data into
 *	their corresponding MC68020 equivalents in place.  fptr is declared
 *	as a caddr_t to remind the user that the VAX format floats may well
 *	not represent valid Sun floating point values before conversion.
 *	It returns a pointer to the location immediately following
 *	the last position swapped.
 *
 *	float *
 *	fsuntovax( fptr, nfloat )
 *	float  *fptr;
 *	long    nfloat;
 *
 *	fsuntovax converts an array of nfloat MC68020 format floats
 *	into their VAX format equivalents in place.  It returns a pointer
 *	to the location immediately following the last position swapped.
 */


/*
 *	Use a union to insure proper allignment
 */
union l_byt {
  unsigned char   lbs[4];
  long            llong;
};

long           *
lvaxswap(long int *lptr, long int nlong)
{
  long            i;
  unsigned char   tbyte;
  union l_byt     lb;
  unsigned char  *lbytes = lb.lbs;
  long           *Lbytes = &lb.llong;

  for (i = 0; i < nlong; i++) {
    *Lbytes = lptr[i];
    tbyte = lbytes[0];
    lbytes[0] = lbytes[3];
    lbytes[3] = tbyte;
    tbyte = lbytes[1];
    lbytes[1] = lbytes[2];
    lbytes[2] = tbyte;
    lptr[i] = *Lbytes;
  }
  return (&lptr[nlong]);
}


/*
 *	Use a union to insure proper allignment
 */
union s_byt {
  unsigned char   sbs[2];
  short           sshort;
};

unsigned short          *
svaxswap(unsigned short int *sptr, long int nshort)
{
  long            i;
  unsigned char   tbyte;
  union s_byt     sb;
  unsigned char  *sbytes = sb.sbs;
  short          *Sbytes = &sb.sshort;

  for (i = 0; i < nshort; i++) {
    *Sbytes = sptr[i];
    tbyte = sbytes[0];
    sbytes[0] = sbytes[1];
    sbytes[1] = tbyte;
    sptr[i] = *Sbytes;
  }
  return (&(sptr[nshort]));
}


/*
 *	Floating point conversion:
 *
 *	1)  The general format is the same,
 *		1 bit sign,
 *		8 bit exponent, and
 *		23 bit normalized mantissa with a leading 1 understood.
 *	2)  The exponents have different biases:
 *		On VAX, exp = true exponent + 128;
 *		on Sun, exp = true exponent + 127.
 *	3)  VAX normalized mantissa represents binary fraction
 *		0.1{mant}
 *	    Sun normalized mantissa represents 1.{mant}
 *	4)  Sun format allows two representations for 0: 0 exp, 0 mant,
 *		and positive OR negative sign bit.  VAX representation
 *		allows only the former.
 *	5)  Sun byte order leads to the following representation
 *		(from most significant to least significant):
 *		sign bit -- 8 bit exponent -- 23 bit mantissa.
 *	6)  VAX byte order leads to the following representation
 *		of a VAX F*4 on the Sun (from most significant
 *		to least significant where exp = e0 - e7 and mant =
 *		m0 - m22 ):
 *		    e7m0-m6,se0-e6,m15-m22,m7-m14
 */

float          *
fvaxtosun(caddr_t fptr, long int nfloat)
{
  struct fstruct  fs;
  long            i;
  caddr_t         tptr;

  tptr = fptr;
  for (i = 0; i < nfloat; i++) {
    fvaxget(&fs, tptr);
    if (fs.exp > 1)
      fs.exp -= 2;
    else
      fs.exp = 0;		/* subnormal */
    fsunput((float *) tptr, &fs);
    tptr += 4;
  }
  return ((float *) tptr);
}

float          *
fsuntovax(float *fptr, long int nfloat)
{
  struct fstruct  fs;
  long            i;

  for (i = 0; i < nfloat; i++) {
    fsunget(&fs, &fptr[i]);
    if (fs.exp == 0)
      fs.sign = 0;	/* VAX 0 must be positive */
    else if (fs.exp > 253)
      fs.exp = 255;
    else
      fs.exp += 2;
    fvaxput((caddr_t) & fptr[i], &fs);
  }
  return (&fptr[nfloat]);
}

void
fvaxget(struct fstruct *fsptr, caddr_t fptr)
{
  register unsigned long ltmp;

  ltmp = *(unsigned long *) fptr;
  fsptr->mant = (ltmp << 8) & 0177400L;
  ltmp >>= 8;
  fsptr->mant |= ltmp & 037600377L;
  ltmp >>= 7;
  fsptr->exp = ltmp & 0376;
  ltmp >>= 8;
  fsptr->sign = ltmp & 01;
  fsptr->exp |= (ltmp >> 8) & 01;
}

void
fsunget(struct fstruct *fsptr, float *fptr)
{
  register unsigned long ltmp;

  ltmp = *(unsigned long *) fptr;
  fsptr->mant = ltmp & 037777777L;
  ltmp >>= 23;
  fsptr->exp = ltmp & 0377;
  fsptr->sign = (ltmp >> 8) & 01;
}

void
fvaxput(caddr_t fptr, struct fstruct *fsptr)
{
  register unsigned long ltmp;

  ltmp = fsptr->exp & 01;
  ltmp <<= 8;
  ltmp |= fsptr->sign;
  ltmp <<= 8;
  ltmp |= fsptr->exp & 0376;
  ltmp <<= 7;
  ltmp |= fsptr->mant & 037600377;
  ltmp <<= 8;
  ltmp |= (fsptr->mant >> 8) & 0377;
  *(unsigned long *) fptr = ltmp;
}

void
fsunput(float *fptr, struct fstruct *fsptr)
{
  register unsigned ltmp;

  ltmp = fsptr->sign & 01;
  ltmp <<= 8;
  ltmp |= fsptr->exp & 0377;
  ltmp <<= 23;
  ltmp |= fsptr->mant & 037777777L;
  *(unsigned long *) fptr = ltmp;
}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@@


11.6
log
@merge of ansi-6-0-branch into head
@
text
@d41 5
a45 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d60 28
a87 15
      unsigned char   num_char_id,    /* Number of Characters in ID Field */
                      cmap_type,      /* Color Map Type */
                      image_type;     /* Image Type Code */
      unsigned short  cmap_origin,    /* Color Map Origin */
                      cmap_length;    /* Color Map Length */
      unsigned char   cmap_size;      /* Color Map Entry Size */
      unsigned short  image_x_origin, /* X-Origin of Image */
                      image_y_origin, /* Y-Origin of Image */
                      image_width,    /* Width of Image */
                      image_height;   /* Height of Image */
      unsigned char   image_pix_size, /* Image Pixel Size */
                      image_descriptor;       /* Image Descriptor Byte */
      unsigned char   *image_id;      /* Image ID Field */
      unsigned char   *cmap_data;     /* color Map data */
      };
d94 6
a99 3
short *svaxswap();
long *lvaxswap();
void fvaxget(), fsunput(), fsunget(), fvaxput();
d102 1
a102 3
main(argc,argv) 
int argc;
char *argv[];
d104 23
a126 22
    FILE       *infile,
    	       *outfile,
    	       *hdrfile=NULL;
    char       *infname=NULL, 
    	       *outfname=NULL, 
    	       *hdrfname=NULL;
    int		oflag=0,
    		hflag=0;
    int		i, j;
    struct targafile tga_head;

    if ( scanargs( argc,argv, "% h%-hdrfile!s o%-outfile!s infile%s",
		   &hflag, &hdrfname, &oflag, &outfname, &infname ) == 0 )
	exit(1);


    infile  = rle_open_f("targatorle", infname, "r");
    if ( hflag )
	hdrfile = rle_open_f("targatorle", hdrfname, "w");
    outfile = rle_open_f("targatorle", outfname, "w");
    /* Check that hdrfile and outfile aren't the same. */
    if ( hdrfile == outfile )
d128 1
a128 1
	fprintf( stderr,
d130 1
a130 1
	exit( 1 );
d133 8
a140 1
    fread (&tga_head, 3, 1, infile);
d142 1
a142 3
	fprintf (hdrfile, "num_char_id = %d \n", (int)tga_head.num_char_id);
	fprintf (hdrfile, "cmap_type   = %d \n", (int)tga_head.cmap_type);
	fprintf (hdrfile, "image_type  = %d \n", (int)tga_head.image_type);
d144 43
a186 17

    if ((int)tga_head.cmap_type==0) { 
	if (hflag) {
	    fprintf (hdrfile, "Color Map Type = 0 \n");
	}
    }
    else if ((int)tga_head.cmap_type==1) {
	fread (&(tga_head.cmap_origin), 5, 1, infile);
	svaxswap(&(tga_head.cmap_origin), 2);
	if (hflag) {
	    fprintf (hdrfile, "cmap_origin = %d \n",
		     (int)tga_head.cmap_origin);
	    fprintf (hdrfile, "cmap_length = %d \n",
		     (int)tga_head.cmap_length);
	    fprintf (hdrfile, "cmap_size   = %d \n",
		     (int)tga_head.cmap_size);
	}
d189 2
a190 34
	perror ("Invalid Color Map Type for RGB (UNMAPPED) IMAGES\n");
	exit (1);
    }

    fread (&(tga_head.image_x_origin), 10, 1, infile);
    svaxswap(&(tga_head.image_x_origin), 4);
    if (hflag) {
	fprintf (hdrfile, "image_x_origin = %d \n",
		 (int)tga_head.image_x_origin);
	fprintf (hdrfile, "image_y_origin = %d \n",
		 (int)tga_head.image_y_origin);
	fprintf (hdrfile, "image_width    = %d \n",
		 (int)tga_head.image_width);
	fprintf (hdrfile, "image_height   = %d \n",
		 (int)tga_head.image_height);
	fprintf (hdrfile, "image_pix_size = %d \n",
		 (int)tga_head.image_pix_size);
    }

    if ((i=(int)tga_head.num_char_id)>=1) {
	tga_head.image_id = (unsigned char *)malloc(i);
	fread (tga_head.image_id, i, 1, infile);
    }

    if ((int)tga_head.cmap_type==1) {
	if ((int)tga_head.cmap_size==24) {
	    i=24*256/8;
	    tga_head.cmap_data = (unsigned char *)malloc(i);
	    fread (tga_head.cmap_data, i, 1, infile);
	}
	else {
	    perror ("Invalid color map length \n");
	    exit(1);
	}
d192 1
d194 29
a222 29
    RLE_SET_BIT(rle_dflt_hdr, RLE_RED);
    RLE_SET_BIT(rle_dflt_hdr, RLE_GREEN);
    RLE_SET_BIT(rle_dflt_hdr, RLE_BLUE);
    RLE_SET_BIT(rle_dflt_hdr, RLE_ALPHA);
    rle_dflt_hdr.rle_file = outfile;
    rle_dflt_hdr.xmax = (int)tga_head.image_width-1;
    rle_dflt_hdr.ymax = (int)tga_head.image_height-1;
    rle_dflt_hdr.alpha = 1;

    outrows[0] = alfline;
    outrows[1] = redline;
    outrows[2] = grnline;
    outrows[3] = bluline;

    rle_addhist( argv, (rle_hdr *)NULL, &rle_dflt_hdr );
    rle_put_setup( &rle_dflt_hdr );

    /* read and process each of the tga_head.image_height targa scan lines */
    for (i=0;i<(int)tga_head.image_height;i++) {
	for (j=0;j<(int)tga_head.image_width;j++) {
	    bluline[j]=getc(infile);
	    grnline[j]=getc(infile);
	    redline[j]=getc(infile);
	    alfline[j]=getc(infile);
	}
	rle_putrow (&outrows[1], (int)tga_head.image_width, &rle_dflt_hdr);
    }
    rle_puteof( &rle_dflt_hdr );
    return 0;
d275 2
a276 2
    unsigned char   lbs[4];
    long            llong;
d280 1
a280 3
lvaxswap(lptr, nlong)
long           *lptr;
long            nlong;
d282 17
a298 17
    long            i;
    unsigned char   tbyte;
    union l_byt     lb;
    unsigned char  *lbytes = lb.lbs;
    long           *Lbytes = &lb.llong;

    for (i = 0; i < nlong; i++) {
	*Lbytes = lptr[i];
	tbyte = lbytes[0];
	lbytes[0] = lbytes[3];
	lbytes[3] = tbyte;
	tbyte = lbytes[1];
	lbytes[1] = lbytes[2];
	lbytes[2] = tbyte;
	lptr[i] = *Lbytes;
    }
    return (&lptr[nlong]);
d306 2
a307 2
    unsigned char   sbs[2];
    short           sshort;
d310 2
a311 4
short          *
svaxswap(sptr, nshort)
short          *sptr;
long            nshort;
d313 14
a326 14
    long            i;
    unsigned char   tbyte;
    union s_byt     sb;
    unsigned char  *sbytes = sb.sbs;
    short          *Sbytes = &sb.sshort;

    for (i = 0; i < nshort; i++) {
	*Sbytes = sptr[i];
	tbyte = sbytes[0];
	sbytes[0] = sbytes[1];
	sbytes[1] = tbyte;
	sptr[i] = *Sbytes;
    }
    return (&sptr[nshort]);
a355 12
/*
 *	Nb. all quantities in the float structure are right justified.
 *	I.e., sign == 0 || sign == 1
 */

struct fstruct {
    unsigned short  sign;
    unsigned short  exp;
    unsigned long   mant;
};


d357 1
a357 3
fvaxtosun(fptr, nfloat)
caddr_t         fptr;
long            nfloat;
d359 15
a373 15
    struct fstruct  fs;
    long            i;
    caddr_t         tptr;

    tptr = fptr;
    for (i = 0; i < nfloat; i++) {
	fvaxget(&fs, tptr);
	if (fs.exp > 1)
	    fs.exp -= 2;
	else
	    fs.exp = 0;		/* subnormal */
	fsunput((float *) tptr, &fs);
	tptr += 4;
    }
    return ((float *) tptr);
d377 1
a377 3
fsuntovax(fptr, nfloat)
float          *fptr;
long            nfloat;
d379 2
a380 2
    struct fstruct  fs;
    long            i;
d382 11
a392 11
    for (i = 0; i < nfloat; i++) {
	fsunget(&fs, &fptr[i]);
	if (fs.exp == 0)
	    fs.sign = 0;	/* VAX 0 must be positive */
	else if (fs.exp > 253)
	    fs.exp = 255;
	else
	    fs.exp += 2;
	fvaxput((caddr_t) & fptr[i], &fs);
    }
    return (&fptr[nfloat]);
d396 1
a396 3
fvaxget(fsptr, fptr)
struct fstruct *fsptr;
caddr_t         fptr;
d398 1
a398 1
    register unsigned long ltmp;
d400 9
a408 9
    ltmp = *(unsigned long *) fptr;
    fsptr->mant = (ltmp << 8) & 0177400L;
    ltmp >>= 8;
    fsptr->mant |= ltmp & 037600377L;
    ltmp >>= 7;
    fsptr->exp = ltmp & 0376;
    ltmp >>= 8;
    fsptr->sign = ltmp & 01;
    fsptr->exp |= (ltmp >> 8) & 01;
d412 1
a412 3
fsunget(fsptr, fptr)
struct fstruct *fsptr;
float          *fptr;
d414 1
a414 1
    register unsigned long ltmp;
d416 5
a420 5
    ltmp = *(unsigned long *) fptr;
    fsptr->mant = ltmp & 037777777L;
    ltmp >>= 23;
    fsptr->exp = ltmp & 0377;
    fsptr->sign = (ltmp >> 8) & 01;
d424 1
a424 3
fvaxput(fptr, fsptr)
caddr_t         fptr;
struct fstruct *fsptr;
d426 1
a426 1
    register unsigned long ltmp;
d428 10
a437 10
    ltmp = fsptr->exp & 01;
    ltmp <<= 8;
    ltmp |= fsptr->sign;
    ltmp <<= 8;
    ltmp |= fsptr->exp & 0376;
    ltmp <<= 7;
    ltmp |= fsptr->mant & 037600377;
    ltmp <<= 8;
    ltmp |= (fsptr->mant >> 8) & 0377;
    *(unsigned long *) fptr = ltmp;
d441 1
a441 3
fsunput(fptr, fsptr)
float          *fptr;
struct fstruct *fsptr;
d443 1
a443 1
    register unsigned ltmp;
d445 6
a450 6
    ltmp = fsptr->sign & 01;
    ltmp <<= 8;
    ltmp |= fsptr->exp & 0377;
    ltmp <<= 23;
    ltmp |= fsptr->mant & 037777777L;
    *(unsigned long *) fptr = ltmp;
@


11.5.2.1
log
@Initial ANSIfication
@
text
@a75 13
/*
 *	Nb. all quantities in the float structure are right justified.
 *	I.e., sign == 0 || sign == 1
 */

struct fstruct {
    unsigned short  sign;
    unsigned short  exp;
    unsigned long   mant;
};



d81 3
a83 3
unsigned short *svaxswap(unsigned short int *sptr, long int nshort);
long *lvaxswap(long int *lptr, long int nlong);
void fvaxget(struct fstruct *fsptr, caddr_t fptr), fsunput(float *fptr, struct fstruct *fsptr), fsunget(struct fstruct *fsptr, float *fptr), fvaxput(caddr_t fptr, struct fstruct *fsptr);
d86 3
a88 1
main(int argc, char **argv)
d265 3
a267 1
lvaxswap(long int *lptr, long int nlong)
d297 4
a300 2
unsigned short          *
svaxswap(unsigned short int *sptr, long int nshort)
d315 1
a315 1
    return (&(sptr[nshort]));
d345 12
d358 3
a360 1
fvaxtosun(caddr_t fptr, long int nfloat)
d380 3
a382 1
fsuntovax(float *fptr, long int nfloat)
d401 3
a403 1
fvaxget(struct fstruct *fsptr, caddr_t fptr)
d419 3
a421 1
fsunget(struct fstruct *fsptr, float *fptr)
d433 3
a435 1
fvaxput(caddr_t fptr, struct fstruct *fsptr)
d452 3
a454 1
fsunput(float *fptr, struct fstruct *fsptr)
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@a75 13
/*
 *	Nb. all quantities in the float structure are right justified.
 *	I.e., sign == 0 || sign == 1
 */

struct fstruct {
    unsigned short  sign;
    unsigned short  exp;
    unsigned long   mant;
};



d81 3
a83 3
unsigned short *svaxswap(unsigned short int *sptr, long int nshort);
long *lvaxswap(long int *lptr, long int nlong);
void fvaxget(struct fstruct *fsptr, caddr_t fptr), fsunput(float *fptr, struct fstruct *fsptr), fsunget(struct fstruct *fsptr, float *fptr), fvaxput(caddr_t fptr, struct fstruct *fsptr);
d86 3
a88 1
main(int argc, char **argv)
d265 3
a267 1
lvaxswap(long int *lptr, long int nlong)
d297 4
a300 2
unsigned short          *
svaxswap(unsigned short int *sptr, long int nshort)
d315 1
a315 1
    return (&(sptr[nshort]));
d345 12
d358 3
a360 1
fvaxtosun(caddr_t fptr, long int nfloat)
d380 3
a382 1
fsuntovax(float *fptr, long int nfloat)
d401 3
a403 1
fvaxget(struct fstruct *fsptr, caddr_t fptr)
d419 3
a421 1
fsunget(struct fstruct *fsptr, float *fptr)
d433 3
a435 1
fvaxput(caddr_t fptr, struct fstruct *fsptr)
d452 3
a454 1
fsunput(float *fptr, struct fstruct *fsptr)
@


11.3
log
@lint
@
text
@d76 13
d94 3
a96 3
short *svaxswap();
long *lvaxswap();
void fvaxget(), fsunput(), fsunget(), fvaxput();
d99 1
a99 3
main(argc,argv) 
int argc;
char *argv[];
d276 1
a276 3
lvaxswap(lptr, nlong)
long           *lptr;
long            nlong;
d306 2
a307 4
short          *
svaxswap(sptr, nshort)
short          *sptr;
long            nshort;
d322 1
a322 1
    return (&sptr[nshort]);
a351 12
/*
 *	Nb. all quantities in the float structure are right justified.
 *	I.e., sign == 0 || sign == 1
 */

struct fstruct {
    unsigned short  sign;
    unsigned short  exp;
    unsigned long   mant;
};


d353 1
a353 3
fvaxtosun(fptr, nfloat)
caddr_t         fptr;
long            nfloat;
d373 1
a373 3
fsuntovax(fptr, nfloat)
float          *fptr;
long            nfloat;
d392 1
a392 3
fvaxget(fsptr, fptr)
struct fstruct *fsptr;
caddr_t         fptr;
d408 1
a408 3
fsunget(fsptr, fptr)
struct fstruct *fsptr;
float          *fptr;
d420 1
a420 3
fvaxput(fptr, fsptr)
caddr_t         fptr;
struct fstruct *fsptr;
d437 1
a437 3
fsunput(fptr, fsptr)
float          *fptr;
struct fstruct *fsptr;
@


11.2
log
@
lint
@
text
@d46 6
d207 1
@


11.1
log
@Release_4.4
@
text
@d79 1
a79 1
void
@


10.2
log
@Altered #defines and #includes to conform to BRL-CAD standards
@
text
@@


10.1
log
@Release_4.0
@
text
@d41 2
d45 3
a48 13

#ifdef USE_STDLIB_H
#include <stdlib.h>
#else

#ifdef VOID_STAR
extern void *malloc();
#else
extern char *malloc();
#endif
extern void free();

#endif /* USE_STDLIB_H */
@


1.1
log
@Initial revision
@
text
@@
