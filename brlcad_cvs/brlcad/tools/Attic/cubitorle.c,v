head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.1
	offsite-5-3-pre:11.3
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.16.38.45;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.50;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.05.46.00;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.08.48;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.56.00;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.22.51.09;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.22.46.18;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.20.28;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.12.01.19.50.26;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.11.16.41.18;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.51.58;	author mike;	state Rel4_0;
branches;
next	1.1;

1.1
date	91.01.24.20.33.28;	author butler;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.02.27;	author morrison;	state Exp;
branches;
next	;


desc
@Original distribution of Rel. 3 patchlevel 2
@


11.8
log
@moved to src/tools/
@
text
@/*
 * This software is copyrighted as noted below.  It may be freely copied,
 * modified, and redistributed, provided that the copyright notice is 
 * preserved on all copies.
 * 
 * There is no warranty or other guarantee of fitness for this software,
 * it is provided solely "as is".  Bug reports or fixes may be sent
 * to the author, who may or may not act on them as he desires.
 *
 * You may not include this software in a program or other software product
 * without supplying the source, or without informing the end-user that the 
 * source is available for no extra charge.
 *
 * If you modify this software, you should include a notice giving the
 * name of the person performing the modification, the date of modification,
 * and the reason for such modification.
 */
/* 
 * cubitorle.c - Convert cubicomp image to an RLE file.
 * 
 * Author:	Rod Bogart
 * 		Computer Science Dept.
 * 		University of Utah
 * Date:	Thu Nov  6 1986
 * Copyright (c) 1986 Rod Bogart
 * 
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#include "machine.h"
#include "externs.h"
#include "rle.h"

void read_cubi_hdr(FILE **cubifiles, short int *xlen, short int *ylen);
void read_cubi_row(FILE **cubifiles, rle_pixel **rows);
void read_cubi_chan(FILE *infile, rle_pixel **rows, int chan);
void bit_read(FILE *infile, char headchar, int bit, rle_pixel **rows, int chan, int *xpos);

int
main(int argc, char **argv)
{
    FILE *cubifiles[4];
    int i, j, oflag=0;
    rle_pixel ** rows;
    int xlen;
    short int cubi_xlen, cubi_ylen;
    char *infname = NULL, *outfname = NULL;
    char filename[256];

    if ( scanargs( argc, argv,
		  "% o%-outfile!s inprefix!s",
		  &oflag, &outfname, &infname ) == 0 )
	exit( 1 );
    rle_dflt_hdr.rle_file = rle_open_f("cubitorle", outfname, "w");

    for ( i = 0; i < 3; i++ )
    {
	sprintf( filename, "%s.%c8", infname, "rgb"[i] );
	cubifiles[i] = rle_open_f( "cubitorle", filename, "r" );
    }

    read_cubi_hdr(cubifiles, &cubi_xlen, &cubi_ylen);

    rle_dflt_hdr.alpha = 0;
    rle_dflt_hdr.ncolors = 3;
    rle_dflt_hdr.xmin = 0;
    rle_dflt_hdr.xmax = cubi_xlen - 1;
    rle_dflt_hdr.ymin = 0;
    rle_dflt_hdr.ymax = cubi_ylen - 1;
    xlen = rle_dflt_hdr.xmax - rle_dflt_hdr.xmin + 1;

    rle_addhist( argv, (rle_hdr *)NULL, &rle_dflt_hdr );
    rle_put_setup( &rle_dflt_hdr );

    if (rle_row_alloc( &rle_dflt_hdr, &rows ))
    {
	fprintf( stderr, "cubitorle: malloc failed\n" );
	exit( -2 );
    }

    for (j=rle_dflt_hdr.ymin; j <= rle_dflt_hdr.ymax; j++)
    {
	read_cubi_row( cubifiles, rows );
	rle_putrow( rows, xlen, &rle_dflt_hdr);
    }
    return 0;
}

void
read_cubi_hdr(FILE **cubifiles, short int *xlen, short int *ylen)
{
    char junk[128];
    short xmin, ymin, xmax, ymax;

    fread(junk, sizeof(char), 12, cubifiles[0]);
    fread(xlen, sizeof(short), 1, cubifiles[0]);
    fread(ylen, sizeof(short), 1, cubifiles[0]);
    fread(&xmin, sizeof(short), 1, cubifiles[0]);
    fread(&ymin, sizeof(short), 1, cubifiles[0]);
    fread(&xmax, sizeof(short), 1, cubifiles[0]);
    fread(&ymax, sizeof(short), 1, cubifiles[0]);
    fread(junk, sizeof(char), 104, cubifiles[0]);

    fread(junk, sizeof(char), 128, cubifiles[1]);
    fread(junk, sizeof(char), 128, cubifiles[2]);
}

void
read_cubi_row(FILE **cubifiles, rle_pixel **rows)
{
    read_cubi_chan(cubifiles[0],rows,0);
    read_cubi_chan(cubifiles[1],rows,1);
    read_cubi_chan(cubifiles[2],rows,2);
}

void
read_cubi_chan(FILE *infile, rle_pixel **rows, int chan)
{
    static char headchar[3];
    static int scanfull[3] = {-1, -1, -1};
    int xpos = 0, bit;

    while (xpos < 512)
    {
	if (scanfull[chan] == -1)
	    headchar[chan] = fgetc(infile);

	for (bit = 0; bit < 8; bit++)
	    if (scanfull[chan] <= bit)
	    {
		bit_read(infile, headchar[chan], bit, rows, chan, &xpos);
		if (xpos >= 512) 
		{
		    scanfull[chan] = bit + 1;
		    break;
		}
	    }
	if (bit >= 7) scanfull[chan] = -1;
    }
}

void
bit_read(FILE *infile, char headchar, int bit, rle_pixel **rows, int chan, int *xpos)
{
    unsigned char runlength, rundata, bytedata;
    int i;

    if (headchar & (1 << bit))
    {
	/* bit set, run data */
	rundata = fgetc(infile);
	runlength = fgetc(infile);
	for (i=(*xpos); i < (int)runlength+(*xpos); i++)
	    rows[chan][i] = rundata;
	*xpos += (int) runlength;
    }
    else
    {
	/* bit not set, byte data */
	bytedata = fgetc(infile);
	rows[chan][*xpos] = bytedata;
	(*xpos)++;
    }
}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@@


11.6
log
@merge of ansi-6-0-branch into head
@
text
@d29 5
a33 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d37 4
a40 1
void read_cubi_hdr(), read_cubi_row(), read_cubi_chan(), bit_read();
d43 1
a43 3
main(argc, argv)
int	argc;
char	*argv[];
d49 1
a49 1
    int cubi_xlen, cubi_ylen;
d93 1
a93 3
read_cubi_hdr(cubifiles, xlen, ylen)
FILE *cubifiles[];
short *xlen, *ylen;
d112 1
a112 3
read_cubi_row(cubifiles, rows)
FILE *cubifiles[];
rle_pixel ** rows;
d120 1
a120 4
read_cubi_chan(infile, rows, chan)
FILE * infile;
rle_pixel **rows;
int chan;
d146 1
a146 5
bit_read(infile, headchar, bit, rows, chan, xpos)
FILE * infile;
char headchar;
int bit, chan, *xpos;
rle_pixel **rows;
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d37 1
a37 1
void read_cubi_hdr(FILE **cubifiles, short int *xlen, short int *ylen), read_cubi_row(FILE **cubifiles, rle_pixel **rows), read_cubi_chan(FILE *infile, rle_pixel **rows, int chan), bit_read(FILE *infile, char headchar, int bit, rle_pixel **rows, int chan, int *xpos);
d40 3
a42 1
main(int argc, char **argv)
d48 1
a48 1
    short int cubi_xlen, cubi_ylen;
d92 3
a94 1
read_cubi_hdr(FILE **cubifiles, short int *xlen, short int *ylen)
d113 3
a115 1
read_cubi_row(FILE **cubifiles, rle_pixel **rows)
d123 4
a126 1
read_cubi_chan(FILE *infile, rle_pixel **rows, int chan)
d152 5
a156 1
bit_read(FILE *infile, char headchar, int bit, rle_pixel **rows, int chan, int *xpos)
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d37 1
a37 1
void read_cubi_hdr(FILE **cubifiles, short int *xlen, short int *ylen), read_cubi_row(FILE **cubifiles, rle_pixel **rows), read_cubi_chan(FILE *infile, rle_pixel **rows, int chan), bit_read(FILE *infile, char headchar, int bit, rle_pixel **rows, int chan, int *xpos);
d40 3
a42 1
main(int argc, char **argv)
d48 1
a48 1
    short int cubi_xlen, cubi_ylen;
d92 3
a94 1
read_cubi_hdr(FILE **cubifiles, short int *xlen, short int *ylen)
d113 3
a115 1
read_cubi_row(FILE **cubifiles, rle_pixel **rows)
d123 4
a126 1
read_cubi_chan(FILE *infile, rle_pixel **rows, int chan)
d152 5
a156 1
bit_read(FILE *infile, char headchar, int bit, rle_pixel **rows, int chan, int *xpos)
@


11.3
log
@
lint
@
text
@d37 1
a37 1
void read_cubi_hdr(), read_cubi_row(), read_cubi_chan(), bit_read();
d40 1
a40 3
main(argc, argv)
int	argc;
char	*argv[];
d46 1
a46 1
    int cubi_xlen, cubi_ylen;
d90 1
a90 3
read_cubi_hdr(cubifiles, xlen, ylen)
FILE *cubifiles[];
short *xlen, *ylen;
d109 1
a109 3
read_cubi_row(cubifiles, rows)
FILE *cubifiles[];
rle_pixel ** rows;
d117 1
a117 4
read_cubi_chan(infile, rows, chan)
FILE * infile;
rle_pixel **rows;
int chan;
d143 1
a143 5
bit_read(infile, headchar, bit, rows, chan, xpos)
FILE * infile;
char headchar;
int bit, chan, *xpos;
rle_pixel **rows;
@


11.2
log
@
lint
@
text
@d88 1
a88 1

@


11.1
log
@Release_4.4
@
text
@d39 1
a39 1
void
@


10.3
log
@Solaris ANSI
@
text
@@


10.2
log
@Altered #defines and #includes to conform to BRL-CAD standards
@
text
@d166 1
a166 1
	for (i=(*xpos); i < runlength+(*xpos); i++)
@


10.1
log
@Release_4.0
@
text
@d29 2
d32 4
a35 1
#include <rle.h>
@


1.1
log
@Initial revision
@
text
@@
