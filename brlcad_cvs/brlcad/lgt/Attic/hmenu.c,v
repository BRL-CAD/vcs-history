head	11.11;
access;
symbols
	ansi-20040405-merged:11.8.2.1
	postmerge-20040405-ansi:11.9
	premerge-20040404-ansi:11.8
	postmerge-autoconf:11.8
	autoconf-freeze:11.8
	premerge-autoconf:11.8
	ansi-20040316-freeze:11.8.2.1
	postmerge-20040315-windows:11.8
	premerge-20040315-windows:11.8
	windows-20040315-freeze:11.8
	autoconf-20031203:11.8
	autoconf-20031202:11.8
	autoconf-branch:11.8.0.10
	phong-branch:11.8.0.8
	photonmap-branch:11.8.0.6
	rel-6-1-DP:11.8
	windows-branch:11.8.0.4
	rel-6-0-2:11.6
	ansi-branch:11.8.0.2
	rel-6-0-1-branch:11.6.0.2
	hartley-6-0-post:11.7
	hartley-6-0-pre:11.6
	rel-6-0-1:11.6
	rel-6-0:11.6
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.3
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1;
locks; strict;
comment	@ * @;


11.11
date	2004.05.21.17.48.15;	author morrison;	state dead;
branches;
next	11.10;

11.10
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.9;

11.9
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.8;

11.8
date	2002.08.20.17.07.33;	author jra;	state Exp;
branches
	11.8.2.1;
next	11.7;

11.7
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.6;

11.6
date	2001.08.09.16.42.52;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.24.22.55.51;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	2000.01.31.16.06.37;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	98.09.14.15.59.15;	author bparker;	state Exp;
branches;
next	11.2;

11.2
date	96.07.17.13.03.43;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.49;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.24.13.35.04;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.04;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.13.11;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.05.12.23.27.29;	author moss;	state Exp;
branches;
next	8.3;

8.3
date	89.04.14.12.24.06;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	89.03.07.13.05.26;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.51.52;	author mike;	state Rel3_0;
branches;
next	7.4;

7.4
date	88.09.20.15.53.32;	author moss;	state Exp;
branches;
next	7.3;

7.3
date	88.06.23.09.29.21;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	87.12.09.13.50.33;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.07;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.11.02.20.55.51;	author mike;	state Exp;
branches;
next	1.2;

1.2
date	87.10.29.08.51.35;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.10.15.10.06.51;	author moss;	state Exp;
branches;
next	;

11.8.2.1
date	2002.09.19.18.01.03;	author morrison;	state Exp;
branches;
next	;


desc
@This code also exists in a library, but is included here for convenience.
It was derived from AT&T manual pages on hmenuhit, but is extended and
modified somewhat.
@


11.11
log
@moved to src/lgt/
@
text
@/*
	SCCS id:	%Z% %M%	%I%
	Modified: 	%G% at %U%
	Retrieved: 	%H% at %T%
	SCCS archive:	%P%

	Authors:	Gary S. Moss
			Douglas A. Gwyn
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647

	This code is derived in part from menuhit(9.3) in AT&T 9th Edition UNIX,
		Version 1 Programmer's Manual.

*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/hmenu.c,v 11.10 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
extern int	LI, CO;
#ifndef STATIC
#define STATIC static
#endif
#define MAX_PROMPT	10
#define Alloc(p_,t_,s_)\
		if( ((p_) = (t_ *) malloc((unsigned)(s_))) == (t_ *) 0 )\
		{\
		(void) fprintf( stderr, "\"%s\"(%d): Alloc of %ld bytes failed.\n",\
				__FILE__, __LINE__, (long int)s_ );\
		exit( 1 );\
		} else	 ;
#ifndef Max
#define Max(_a,_b)	((_a)<(_b)?(_b):(_a))
#define Min(_a,_b)	((_a)>(_b)?(_b):(_a))
#endif
#define ring_Bell()	putchar( '\07' ),  (void) fflush( stdout )
#define M_UP		'u'
#define M_DOWN		'd'
#define M_HELP		'h'
#define M_SELECT	' '
#define M_RETURN	'\r'
#define M_NOSELECT	'q'

#define P_OFF		(0)
#define P_ON		(1)
#define P_FORCE		(1<<1)

#define  PutMenuChar(_c,_co,_ro,_map,_bit)\
		{	static int	lro = -1, lco = -1;\
		if( (_map) & (_bit) || (_bit) == 0 )\
			{\
			if( lco++ != (_co)-1 || lro != (_ro) )\
				{\
				MvCursor( _co, _ro );\
				lco = _co;\
				}\
			putchar( (_c) );\
			}\
		(_bit) <<= 1;\
		(_co)++;\
		}


int		hm_dirty = 0;
static HWindow	*windows = 0;

#define ENTRY	(itemp-win->menup->item)
typedef struct nmllist HMllist;
struct nmllist
	{
	HMitem	*itemp;
	HMllist	*next;
	};

STATIC void
prnt_HMitem(HMitem *itemp)
{
	if( itemp->text == NULL )
		return;
	(void) fprintf( stderr, "text=\"%s\"\n", itemp->text );
	(void) fprintf( stderr, "help=\"%s\"\n", itemp->help == NULL ? "(null)" : itemp->help );
	(void) fprintf( stderr, "next=0x%lx\n", (long unsigned int)itemp->next );
#ifndef sgi
	(void) fprintf( stderr, "dfn=0x%x\n", (unsigned int)itemp->dfn );
	(void) fprintf( stderr, "bfn=0x%x\n", (unsigned int)itemp->bfn );
#endif
	(void) fprintf( stderr, "hfn=0x%lx\n", (long unsigned int)itemp->hfn );
	(void) fprintf( stderr, "data=%ld\n--\n", itemp->data );
	return;
	}

STATIC void
prnt_HMllist(HMllist *listp)
{
	if( listp == (HMllist *) 0 )
		return;
	prnt_HMitem( listp->itemp );
	prnt_HMllist( listp->next );
	return;
	}

STATIC void
free_HMitems(HMitem *itemp)
{	register HMitem	*citemp;
	for( citemp = itemp; citemp->text != NULL; citemp++ )
		{
		free( citemp->text );
		if( citemp->help != NULL )
			free( citemp->help );
		}
	free( (char *) itemp );
	return;
	}

STATIC void
free_HMllist(HMllist *listp)
{
	if( listp == (HMllist *) 0 )
		return;
	free_HMllist( listp->next );
	free( (char *) listp->itemp );
	free( (char *) listp );
	return;
	}

STATIC void
hm_Put_Item(register HWindow *win, register HMitem *itemp, int flag)
{	register int	label_len = strlen( itemp->text );
			static char	buf[MAXLINE];
			register char	*p = buf;
			register int	col = win->menux;
			register int	row = win->menuy+(ENTRY-win->menup->prevtop)+1;
			register int	width = win->width;
			register int	bitmap = flag & P_FORCE ?
						~0 : win->dirty[ENTRY+1];
			register int	bit = 1;
			register int	writemask = 0;
		if( bitmap == 0 )
			return;

		/* Pad text on left.					*/
		if( itemp->text[0] & 0200 )	/* right-justified */
			{	register int	i;
			for( i = 0; i < width - label_len; i++ )
				*p++ = ' ';
			for( i = 1; itemp->text[i] != '\0'; i++ )
				*p++ = itemp->text[i];
			}
		else				/* left-justified */
		if( itemp->text[label_len-1] & 0200 )
			{	register int	i;
			for( i = 0; !(itemp->text[i] & 0200); i++ )
				*p++ = itemp->text[i];
			for( ; i < width; i++ )
				*p++ = ' ';
			}
		else				/* centered */
			{	register int	i, j;
			for( i = 0; i < (width - label_len + 1)/2; i++ )
				*p++ = ' ';
			for( j = 0; itemp->text[j] != '\0'; j++ )
				*p++ = itemp->text[j];
			for( i += j; i < width; i++ )
				*p++ = ' ';
			}
		*p = '\0';

		PutMenuChar( '|', col, row, bitmap, bit );
		if( flag & P_ON )
		 	(void) SetStandout();
		else
			(void) ClrStandout();

		/* Optimized printing of entry.				*/
		{
		if( bitmap == ~0 )
			{
			(void) fputs( buf, stdout );
			col += p-buf;
			bit <<= p-buf;
			}
		else
			{	register int	i;
			for( i = 0; i < p-buf; i++ )
				writemask |= 1<<(i+1);
			for( i = 0; i < p-buf; i++ )
				{
				if( (bitmap & writemask) == writemask )
					break;
				writemask &= ~bit;
				PutMenuChar( buf[i], col, row, bitmap, bit );
				}
			if( i < p-buf )
				{
				MvCursor( col, row );
				(void) fputs( &buf[i], stdout );
				col += (p-buf) - i;
				bit <<= (p-buf) - i;
				}
			}
		}

		if( flag & P_ON )
			(void) ClrStandout();
		PutMenuChar( '|', col, row, bitmap, bit );
		return;
		}

STATIC void
hm_Put_Border(register HWindow *win, register int row, char mark)
{	register int	i;
		register int	bit = 1;
		register int	col = win->menux;
		register int	bitmap = win->dirty[row - win->menuy];
		static char	buf[MAXLINE];
		register char	*p = buf;
	*p++ = mark; 
	for( i = 0; i < win->width; i++ )
		*p++ = '-';
	*p++ = mark;
	*p = '\0';
	if( bitmap == ~0 )
		{
		MvCursor( col, row );
		(void) fputs( buf, stdout );
		}
	else
	for( i = 0; i < p - buf; i++ )
		PutMenuChar( buf[i], col, row, bitmap, bit );
	return;
	}

STATIC void
hm_Setbit(register HWindow *win, int col, int row)
{	register int	bit = col - win->menux;
	win->dirty[row-(win->menuy-win->menup->prevtop)] |= bit == 0 ? 1 : 1 << bit;
	return;
	}

STATIC void
hm_Clrmap(HWindow *win)
{	register int	row;
	for( row = 0; row <= win->height+1; row++ )
		win->dirty[row] = 0;
	return;
	}

STATIC void
hm_Setmap(HWindow *win)
{	register int	row;
	for( row = 0; row <= win->height+1; row++ )
		win->dirty[row] = ~0; /* 0xffff... */
	return;
	}

STATIC HWindow	*
hm_In_Win(register int x, register int y, register HWindow *win)
{
	for( ; win != (HWindow *) 0; win = win->next )
		{	register int	height = Min( win->height, MAXVISABLE );
		if( !	(x < win->menux || x > win->menux + win->width + 1 ||
			y < win->menuy || y > win->menuy + height + 1)
			)
			return	win;
		}
	return	(HWindow *) 0;
	}

STATIC void
hm_Draw_Win(register HWindow *win)
{	register HMitem	*itemp;
		int	height;
	hm_Put_Border( win, win->menuy, win->menup->prevtop > 0 ? '^' : '+' );
	for(	itemp = win->menup->item + win->menup->prevtop;
		ENTRY-win->menup->prevtop < MAXVISABLE && itemp->text != NULL;
		itemp++
		)
		hm_Put_Item(	win, itemp,
				ENTRY == win->menup->prevhit ? P_ON : P_OFF
				);
	height = Min( MAXVISABLE, win->height );
	hm_Put_Border( win, win->menuy+height+1, ENTRY < win->height ? 'v' : '+' );
	hm_Clrmap( win );
	(void) fflush( stdout );
	return;
	}

STATIC void
hm_Redraw_Win(HWindow *win)
{
	if( win == (HWindow *) 0 )
		{
		hm_dirty = 0;
		return;
		}
	hm_Redraw_Win( win->next );
	hm_Draw_Win( win );
	return;
	}

STATIC void
hm_Help(register HWindow *win, int entry)
{	int	bottomline = 1;
		register HWindow	*curwin;
	for( curwin = windows; curwin != (HWindow *) 0; curwin = curwin->next )
		{
		if( curwin->height > MAXVISABLE )
			{
			bottomline = curwin->menuy + MAXVISABLE + 1;
			break;
			}
		bottomline = Max( bottomline, curwin->menuy + curwin->height + 1 );
		}
	MvCursor( 0, bottomline+1 );
	(void) ClrEOL();
	(void) SetStandout();
	(void) printf( "%s", win->menup->item[entry].help );
	(void) ClrStandout();
	(void) fflush( stdout );
	(void) hm_ungetchar( hm_getchar() );
	MvCursor( 0, bottomline+1 );
	(void) ClrEOL();
	return;
	}

STATIC void
hm_Lift_Win(register HWindow *win)
{	register int	row, col;
		register int	lastcol = -1, lastrow = -1;
		register int	endcol = win->menux + win->width + 2;
		register int	endrow = win->menuy +
				  Min( win->height, MAXVISABLE ) + 2;
	for( row = win->menuy; row < endrow; row++ )
		{
		for( col = win->menux; col < endcol; col++ )
			{	register HWindow	*olwin;
			if( (olwin = hm_In_Win( col, row, win->next ))
				== (HWindow *) 0
				)
				{
				if( lastcol != col-1 || lastrow != row )
					MvCursor( col, row );
				lastcol = col; lastrow = row;
				putchar( ' ' );
				}
			else
				{
				hm_Setbit( olwin, col, row );
				hm_dirty = 1;
				}
			}
		}
	(void) fflush( stdout );
	return;
	}

void
hmredraw(void)
{	register HWindow	*win;
	for( win = windows; win != (HWindow *) 0; win = win->next )
		hm_Setmap( win );
	hm_dirty = 1;
	return;
	}

HMitem *
hmenuhit(HMenu *menup, int menux, int menuy)
     	       			/* -> first HMitem in array.		*/
   	             
	{	register HMitem	*itemp;
		HMitem		*retitemp = 0;
		HWindow		*win;
		register int	done = 0;
		int		dynamic = 0;
		static int	hmlevel = 0;

	if( ++hmlevel == 1 )
		{
		save_Tty( 0 );
		set_Cbreak( 0 );
		clr_Echo( 0 );
		}

	/* If generator function is provided, dynamically allocate the
		menu items.
	 */
	if( (dynamic = (menup->item == (HMitem *) 0)) )
		{	register int	i;
			register HMitem	*gitemp;
			HMllist	llhead, **listp;
		for(	i = 0, listp = &llhead.next;
			;
			i++, listp = &(*listp)->next
			)
			{
			Alloc( *listp, HMllist, sizeof(HMllist) );
			Alloc( (*listp)->itemp, HMitem, sizeof(HMitem) );
			itemp = (*listp)->itemp;
			if( (gitemp = (*menup->generator)( i )) == (HMitem *) 0 )
				{
				itemp->text = NULL;
				(*listp)->next = 0;
				break;
				}
			if( gitemp->text != NULL )
				{
				Alloc( itemp->text, char, strlen( gitemp->text ) + 1 );
				(void) strcpy( itemp->text, gitemp->text );
				}
			else
				itemp->text = NULL;
			if( gitemp->help != NULL )
				{
				Alloc( itemp->help, char, strlen( gitemp->help ) + 1 );
				(void) strcpy( itemp->help, gitemp->help );
				}
			else
				itemp->help = NULL;
			itemp->next = gitemp->next;
			itemp->dfn = gitemp->dfn;
			itemp->bfn = gitemp->bfn;
			itemp->hfn = gitemp->hfn;
			itemp->data = gitemp->data;
			}
		/*prnt_HMllist( llhead.next );*/

		/* Steal the field that the user isn't using temporarily to
			emmulate the static allocation of menu items.
		 */
		if( i > 0 )
			{
			Alloc( menup->item, HMitem, (i+1)*sizeof(HMitem) );
			for(	i = 0, listp = &llhead.next;
				(*listp) != (HMllist *) 0;
				i++,   listp = &(*listp)->next
				)
				menup->item[i] = *(*listp)->itemp;
			}
		free_HMllist( llhead.next );
		if( i == 0 ) /* Zero items, so return NULL */
			{
			if( hmlevel-- == 1 )
				reset_Tty( 0 );
				return	(HMitem *) 0;
			}
		}
	Alloc( win, HWindow, sizeof(HWindow) );
	win->menup = menup;
	win->width = 0;
	win->next = windows;
	windows = win;

	/* Determine width of menu, allowing for border.		*/
	for( itemp = menup->item; itemp->text != NULL; itemp++ )
		{	register int	len = 0;
			register int	i;
		for( i = 0; itemp->text[i] != '\0' ; i++ )
			if( ! (itemp->text[i] & 0200) )
				len++;
		win->width = Max( win->width, len );
		}
	win->height = ENTRY;

	/* Determine origin (top-left corner) of menu.			*/
	if( win->next != (HWindow *) 0 )
		{
		win->menux = win->next->menux + win->next->width + 2;
		win->menuy = win->next->menuy;
		if( win->menux + win->width + 2 > CO )
			{ /* Wrap-around screen. */
			win->menux = menux += 2;
			win->menuy = menuy += 2;
			}
		}
	else /* Top-level menu. */
		{
		win->menux = menux;
		win->menuy = menuy;
		}
	if( menup->prevhit < 0 || menup->prevhit >= win->height )
		menup->prevhit = 0;
	itemp = &menup->item[menup->prevhit];

	Alloc( win->dirty, int, (win->height+2)*sizeof(int) );
	hm_Setmap( win );
	hm_Draw_Win( win );
	while( ! done )
		{
		if( hm_dirty )
			hm_Redraw_Win( windows );
		MvCursor( win->menux+win->width+2, win->menuy+(ENTRY-win->menup->prevtop)+1 );
		(void) fflush( stdout );
		switch( hm_getchar() )
			{
		case M_UP :
			if( ENTRY == 0 )
				ring_Bell();
			else
				{
				hm_Put_Item( win, itemp, P_OFF | P_FORCE );
				itemp--;
				menup->prevhit = ENTRY;
				if( ENTRY < win->menup->prevtop )
					{
					win->menup->prevtop -=
						ENTRY > MAXVISABLE/2 ?
						MAXVISABLE/2 : ENTRY;
					win->menup->prevtop--;
					hm_Setmap( win );
					hm_Draw_Win( win );
					}
				else
					hm_Put_Item( win, itemp, P_ON | P_FORCE );
				}
			break;
		case M_DOWN :
			if( ENTRY >= win->height-1 )
				ring_Bell();
			else
				{
				hm_Put_Item( win, itemp, P_OFF | P_FORCE );
				itemp++;
				menup->prevhit = ENTRY;
				if( ENTRY - win->menup->prevtop >= MAXVISABLE )
					{
					win->menup->prevtop +=
						win->height-ENTRY > MAXVISABLE/2 ?
						MAXVISABLE/2 : win->height-ENTRY;
					hm_Setmap( win );
					hm_Draw_Win( win );
					}
				else
					hm_Put_Item( win, itemp, P_ON | P_FORCE );
				}
			break;
		case '?' :
		case M_HELP :
			hm_Help( win, (int)ENTRY );
			break;
		case M_SELECT :
		case M_RETURN :
			if( itemp->next != (HMenu *) 0 )
				{	HMitem	*subitemp;
				if( itemp->dfn != (void (*)()) 0 )
					(*itemp->dfn)( itemp );
				subitemp = hmenuhit( itemp->next, menux, menuy );
				if( itemp->bfn != (void (*)()) 0 )
					(*itemp->bfn)( itemp );
				if( subitemp != (HMitem *) 0 )
					{
					retitemp = subitemp;
					done = !menup->sticky;
					}
				}
			else
				{	int	level = hmlevel;
				retitemp = itemp;
				if( itemp->hfn != (int (*)()) 0 )
					{
					reset_Tty( 0 );
					hmlevel = 0;
					retitemp->data = (*itemp->hfn)( itemp, (char **) NULL );
					hmlevel = level;
					set_Cbreak( 0 );
					clr_Echo( 0 );
					}
				done = ! menup->sticky;
				if( menup->func != (void (*)()) 0 )
					{
					reset_Tty( 0 );
					hmlevel = 0;
					(*menup->func)();
					hmlevel = level;
					set_Cbreak( 0 );
					clr_Echo( 0 );
					}
				}
			break;
		case M_NOSELECT :
			done = 1;
			break;
		default :
			MvCursor( 1, LI-1 );
			(void) fflush( stdout );
			prnt_Scroll( "Type 'd' down, 'u' up, 'h' help, <space> to select, 'q' no selection." );
			break;
			}
		(void) fflush( stdout );
		}
	/* Free storage of dynamic menu.				*/
	if( dynamic )
		{
		free_HMitems( menup->item );
		menup->item = 0;
		}
	hm_Lift_Win( win );
	windows = win->next;
	free( (char *) win->dirty );
	free( (char *) win );
	if( hmlevel-- == 1 )
		reset_Tty( 0 );
	return	retitemp;
	}
@


11.10
log
@change conf.h to a wrapped config.h
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/hmenu.c,v 11.9 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.9
log
@merge of ansi-6-0-branch into HEAD
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d22 5
a26 1
#include "conf.h"
@


11.8
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/hmenu.c,v 11.6 2001/08/09 16:42:52 jra Exp $ (BRL)";
d96 2
a97 3
prnt_HMitem( itemp )
HMitem	*itemp;
	{
d113 2
a114 3
prnt_HMllist( listp )
HMllist	*listp;
	{
d123 2
a124 3
free_HMitems( itemp )
HMitem	*itemp;
	{	register HMitem	*citemp;
d136 2
a137 3
free_HMllist( listp )
HMllist	*listp;
	{
d147 2
a148 6
hm_Put_Item( win, itemp, flag )
register HWindow	*win;
register HMitem		*itemp;
int			flag;

		{	register int	label_len = strlen( itemp->text );
d230 2
a231 5
hm_Put_Border( win, row, mark )
register HWindow	*win;
register int		row;
char			mark;
	{	register int	i;
d254 2
a255 4
hm_Setbit( win, col, row )
register HWindow	*win;
int			col, row;
	{	register int	bit = col - win->menux;
d261 2
a262 3
hm_Clrmap( win )
HWindow	*win;
	{	register int	row;
d269 2
a270 3
hm_Setmap( win )
HWindow	*win;
	{	register int	row;
d277 2
a278 4
hm_In_Win( x, y, win )
register int		x, y;
register HWindow	*win;
	{
d290 2
a291 3
hm_Draw_Win( win )
register HWindow	*win;
	{	register HMitem	*itemp;
d309 2
a310 3
hm_Redraw_Win( win )
HWindow	*win;
	{
d322 2
a323 4
hm_Help( win, entry )
register HWindow	*win;
int	entry;
	{	int	bottomline = 1;
d347 2
a348 3
hm_Lift_Win( win )
register HWindow	*win;
	{	register int	row, col;
d378 2
a379 2
hmredraw()
	{	register HWindow	*win;
d387 3
a389 3
hmenuhit( menup, menux, menuy )
HMenu	*menup;			/* -> first HMitem in array.		*/
int	menux, menuy;
@


11.8.2.1
log
@Initial ANSIfication
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/hmenu.c,v 11.8 2002/08/20 17:07:33 jra Exp $ (BRL)";
d96 3
a98 2
prnt_HMitem(HMitem *itemp)
{
d114 3
a116 2
prnt_HMllist(HMllist *listp)
{
d125 3
a127 2
free_HMitems(HMitem *itemp)
{	register HMitem	*citemp;
d139 3
a141 2
free_HMllist(HMllist *listp)
{
d151 6
a156 2
hm_Put_Item(register HWindow *win, register HMitem *itemp, int flag)
{	register int	label_len = strlen( itemp->text );
d238 5
a242 2
hm_Put_Border(register HWindow *win, register int row, char mark)
{	register int	i;
d265 4
a268 2
hm_Setbit(register HWindow *win, int col, int row)
{	register int	bit = col - win->menux;
d274 3
a276 2
hm_Clrmap(HWindow *win)
{	register int	row;
d283 3
a285 2
hm_Setmap(HWindow *win)
{	register int	row;
d292 4
a295 2
hm_In_Win(register int x, register int y, register HWindow *win)
{
d307 3
a309 2
hm_Draw_Win(register HWindow *win)
{	register HMitem	*itemp;
d327 3
a329 2
hm_Redraw_Win(HWindow *win)
{
d341 4
a344 2
hm_Help(register HWindow *win, int entry)
{	int	bottomline = 1;
d368 3
a370 2
hm_Lift_Win(register HWindow *win)
{	register int	row, col;
d400 2
a401 2
hmredraw(void)
{	register HWindow	*win;
d409 3
a411 3
hmenuhit(HMenu *menup, int menux, int menuy)
     	       			/* -> first HMitem in array.		*/
   	             
@


11.7
log
@Converted from K&R to ANSI C - RFH
@
text
@d96 3
a98 2
prnt_HMitem(HMitem *itemp)
{
d114 3
a116 2
prnt_HMllist(HMllist *listp)
{
d125 3
a127 2
free_HMitems(HMitem *itemp)
{	register HMitem	*citemp;
d139 3
a141 2
free_HMllist(HMllist *listp)
{
d151 6
a156 2
hm_Put_Item(register HWindow *win, register HMitem *itemp, int flag)
{	register int	label_len = strlen( itemp->text );
d238 5
a242 2
hm_Put_Border(register HWindow *win, register int row, char mark)
{	register int	i;
d265 4
a268 2
hm_Setbit(register HWindow *win, int col, int row)
{	register int	bit = col - win->menux;
d274 3
a276 2
hm_Clrmap(HWindow *win)
{	register int	row;
d283 3
a285 2
hm_Setmap(HWindow *win)
{	register int	row;
d292 4
a295 2
hm_In_Win(register int x, register int y, register HWindow *win)
{
d307 3
a309 2
hm_Draw_Win(register HWindow *win)
{	register HMitem	*itemp;
d327 3
a329 2
hm_Redraw_Win(HWindow *win)
{
d341 4
a344 2
hm_Help(register HWindow *win, int entry)
{	int	bottomline = 1;
d368 3
a370 2
hm_Lift_Win(register HWindow *win)
{	register int	row, col;
d400 2
a401 2
hmredraw(void)
{	register HWindow	*win;
d409 3
a411 3
hmenuhit(HMenu *menup, int menux, int menuy)
     	       			/* -> first HMitem in array.		*/
   	             
@


11.6
log
@lint
@
text
@d19 1
a19 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/hmenu.c,v 11.5 2000/08/24 22:55:51 mike Exp $ (BRL)";
d96 2
a97 3
prnt_HMitem( itemp )
HMitem	*itemp;
	{
d113 2
a114 3
prnt_HMllist( listp )
HMllist	*listp;
	{
d123 2
a124 3
free_HMitems( itemp )
HMitem	*itemp;
	{	register HMitem	*citemp;
d136 2
a137 3
free_HMllist( listp )
HMllist	*listp;
	{
d147 2
a148 6
hm_Put_Item( win, itemp, flag )
register HWindow	*win;
register HMitem		*itemp;
int			flag;

		{	register int	label_len = strlen( itemp->text );
d230 2
a231 5
hm_Put_Border( win, row, mark )
register HWindow	*win;
register int		row;
char			mark;
	{	register int	i;
d254 2
a255 4
hm_Setbit( win, col, row )
register HWindow	*win;
int			col, row;
	{	register int	bit = col - win->menux;
d261 2
a262 3
hm_Clrmap( win )
HWindow	*win;
	{	register int	row;
d269 2
a270 3
hm_Setmap( win )
HWindow	*win;
	{	register int	row;
d277 2
a278 4
hm_In_Win( x, y, win )
register int		x, y;
register HWindow	*win;
	{
d290 2
a291 3
hm_Draw_Win( win )
register HWindow	*win;
	{	register HMitem	*itemp;
d309 2
a310 3
hm_Redraw_Win( win )
HWindow	*win;
	{
d322 2
a323 4
hm_Help( win, entry )
register HWindow	*win;
int	entry;
	{	int	bottomline = 1;
d347 2
a348 3
hm_Lift_Win( win )
register HWindow	*win;
	{	register int	row, col;
d378 2
a379 2
hmredraw()
	{	register HWindow	*win;
d387 3
a389 3
hmenuhit( menup, menux, menuy )
HMenu	*menup;			/* -> first HMitem in array.		*/
int	menux, menuy;
@


11.5
log
@
RCSid
@
text
@d19 1
a19 2
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/hmenu.c,v 11.4 2000/01/31 16:06:37 jra Exp $ (BRL)";
static char sccsTag[] = "%Z% %M% %I%, modified %G% at %U%, archive %P%";
d49 1
a49 1
				__FILE__, __LINE__, s_ );\
d103 1
a103 1
	(void) fprintf( stderr, "next=0x%lx\n", itemp->next );
d105 2
a106 2
	(void) fprintf( stderr, "dfn=0x%x\n", itemp->dfn );
	(void) fprintf( stderr, "bfn=0x%x\n", itemp->bfn );
d108 1
a108 1
	(void) fprintf( stderr, "hfn=0x%lx\n", itemp->hfn );
d429 1
a429 1
	if( dynamic = menup->item == (HMitem *) 0 )
@


11.4
log
@Eliminated some unused variables
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/hmenu.c,v 11.3 1998/09/14 15:59:15 bparker Exp $ (BRL)";
@


11.3
log
@*- fix typos
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/hmenu.c,v 11.2 1996/07/17 13:03:43 jra Exp $ (BRL)";
d602 1
a602 1
					{	static char	*locargv[MAXARGS];
@


11.2
log
@MinorMods for IRIX 6.2
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/hmenu.c,v 11.1 1995/01/04 10:17:49 mike Rel4_4 jra $ (BRL)";
d49 1
a49 1
		(void) fprintf( stderr, "\"%s\"(%d): Alloc of %d bytes failed.\n",\
d104 1
a104 1
	(void) fprintf( stderr, "next=0x%x\n", itemp->next );
d109 2
a110 2
	(void) fprintf( stderr, "hfn=0x%x\n", itemp->hfn );
	(void) fprintf( stderr, "data=%d\n--\n", itemp->data );
@


11.1
log
@Release_4.4
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/hmenu.c,v 10.2 94/08/24 13:35:04 gdurf Exp $ (BRL)";
d104 1
a104 1
	(void) fprintf( stderr, "next=0x%x\n", (int) itemp->next );
d106 2
a107 2
	(void) fprintf( stderr, "dfn=0x%x\n", (int) itemp->dfn );
	(void) fprintf( stderr, "bfn=0x%x\n", (int) itemp->bfn );
d109 1
a109 1
	(void) fprintf( stderr, "hfn=0x%x\n", (int) itemp->hfn );
d581 1
a581 1
			hm_Help( win, ENTRY );
@


10.2
log
@Made includes explicit, factored ifdefs
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/hmenu.c,v 10.1 1991/10/12 06:50:04 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/hmenu.c,v 9.1 89/05/19 06:13:11 mike Rel3_5 $ (BRL)";
d23 2
d26 3
a28 1
#ifdef BSD
a29 2
#else
#include <string.h>
d31 9
a40 1
#include "./hmenu.h"
@


9.1
log
@Release_3.5
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 8.4 89/05/12 23:27:29 moss Exp $ (BRL)";
@


8.4
log
@pre release changes
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 8.3 89/04/14 12:24:06 moss Exp $ (BRL)";
@


8.3
log
@Fixed declaration of malloc() to agree with ANSI C, and neatened up C
library function declarations by including <stdlib.h> when appropriate.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 8.2 89/03/07 13:05:26 moss Locked $ (BRL)";
d32 2
a33 2
#ifndef _LOCAL_
#define _LOCAL_ static
d86 1
a86 1
_LOCAL_ void
d104 1
a104 1
_LOCAL_ void
d115 1
a115 1
_LOCAL_ void
d129 1
a129 1
_LOCAL_ void
d141 1
a141 1
_LOCAL_ void
d228 1
a228 1
_LOCAL_ void
d255 1
a255 1
_LOCAL_ void
d264 1
a264 1
_LOCAL_ void
d273 1
a273 1
_LOCAL_ void
d282 1
a282 1
_LOCAL_ HWindow	*
d297 1
a297 1
_LOCAL_ void
d317 1
a317 1
_LOCAL_ void
d331 1
a331 1
_LOCAL_ void
d358 1
a358 1
_LOCAL_ void
@


8.2
log
@Removed '\' from last line of PutMenuChar macro definition.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 8.1 88/10/05 00:51:52 moss Locked $ (BRL)";
d29 1
a30 1
extern char	*malloc();
@


8.1
log
@Release_3.0
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 7.4 88/09/20 15:53:32 moss Exp $ (BRL)";
d32 3
d72 2
a73 2
		}\
		
@


7.4
log
@Fixed help message for menu control to disallow <return> as a synonym
for <space>.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 7.2 87/12/09 13:50:33 moss Exp $ (BRL)";
@


7.3
log
@Smoothing out menu and prompting interface.
@
text
@d615 1
a615 1
			prnt_Scroll( "Type 'd' down, 'u' up, 'h' help, <space> or <return> to select, 'q' no selection." );
@


7.2
log
@Fixed wrong key error message to use prnt_Scroll.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 7.1 87/11/03 00:25:07 moss Locked $ (BRL)";
d24 3
d28 1
a74 33
_LOCAL_ int
get_Args( args, prompt, x, y )
char	*args[], *prompt;
int	x, y;
	{	static char	inbuf[MAXLINE];
		register int	i;
	if( prompt == NULL )
		{
		args[0] = NULL;
		args[1] = NULL;
		return	1;
		}
	args[0] = "#";
	MvCursor( x, y );
	(void) printf( "%s: ", prompt );
	(void) fflush( stdout );
	if(	fgets( inbuf, MAXLINE, stdin ) == NULL
	    ||	inbuf[0] == '\n'
		)
		{
		MvCursor( x, y );
		ClrEOL();
		return	0;
		}
	inbuf[strlen(inbuf)-1] = '\0';	/* Clobber new-line. */
	args[1] = strtok( inbuf, " \t" );
	for( i = 2; args[i-1] != NULL; ++i )
		args[i] = strtok( (char *) NULL, " \t," );
	MvCursor( x, y );
	ClrEOL();
	return	1;
	}

a90 1
	(void) fprintf( stderr, "prompt=\"%s\"\n", itemp->prompt == NULL ? "(null)" : itemp->prompt );
a120 2
		if( citemp->prompt != NULL )
			free( citemp->prompt );
a448 7
			if( gitemp->prompt != NULL )
				{
				Alloc( itemp->prompt, char, strlen( gitemp->prompt ) + 1 );
				(void) strcpy( itemp->prompt, gitemp->prompt );
				}
			else
				itemp->prompt = NULL;
d496 1
a496 1
		{	register int	max_prompt = 0;
d499 1
a499 4
		for( itemp = menup->item; itemp->text != NULL; itemp++ )
			if( itemp->prompt != NULL )
				max_prompt = MAX_PROMPT;
		if( win->menux + win->width + 2 + max_prompt > CO )
d592 1
a592 2
					if( get_Args( locargv, itemp->prompt, win->menux+win->width+2, win->menuy+ENTRY+1 ) )
						retitemp->data = (*itemp->hfn)( itemp, locargv );
@


7.1
log
@Release 2.3
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 1.3 87/11/02 20:55:51 mike Exp $ (BRL)";
d658 1
a658 2
			(void) fprintf( stderr,
					"Type 'd' down, 'u' up, 'h' help, <space> or <return> to select, 'q' no selection." );
@


1.3
log
@Hack for SGI problem with pointers to void functions.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header: hmenu.c,v 1.2 87/10/29 08:51:35 mike Locked $ (BRL)";
@


1.2
log
@Ready for release 2.1 of BRL CAD.
@
text
@d19 1
a19 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d122 1
d125 1
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
		if( ((p_) = (t_ *) malloc(s_)) == (t_ *) 0 )\
a306 9
	}

_LOCAL_ int
hm_Overlap( win1, win2 )
register HWindow	*win1, *win2;
	{
	return	!(win1->menux+win1->width < win2->menux	||
		  win1->menux > win2->menux + win2->width);
		
@
