head	11.13;
access;
symbols
	ansi-20040405-merged:11.10.2.1
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.10
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.10
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.3
	rel-4-5:11.3
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.17.48.16;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.10.2.1;
next	11.9;

11.9
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.10.15.19.39.20;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2001.08.09.16.42.52;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	2001.08.08.21.02.04;	author jra;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.24.22.55.51;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.06.03.21.40.50;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.12.16.00.50.49;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.12.16.00.25.39;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.53;	author mike;	state Rel4_4;
branches;
next	10.8;

10.8
date	94.12.28.08.43.14;	author stay;	state Exp;
branches;
next	10.7;

10.7
date	94.12.12.22.10.57;	author mike;	state Exp;
branches;
next	10.6;

10.6
date	94.08.24.13.35.46;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	93.09.22.11.22.20;	author moss;	state Exp;
branches;
next	10.4;

10.4
date	93.07.09.10.31.34;	author moss;	state Exp;
branches;
next	10.3;

10.3
date	92.10.13.10.18.18;	author moss;	state Exp;
branches;
next	10.2;

10.2
date	92.03.27.12.08.38;	author moss;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.08;	author mike;	state Rel4_0;
branches;
next	9.8;

9.8
date	91.09.20.23.43.38;	author mike;	state Exp;
branches;
next	9.7;

9.7
date	91.07.09.02.55.37;	author mike;	state Exp;
branches;
next	9.6;

9.6
date	91.07.02.14.56.08;	author moss;	state Exp;
branches;
next	9.5;

9.5
date	91.05.01.15.34.51;	author moss;	state Exp;
branches;
next	9.4;

9.4
date	90.03.27.14.22.19;	author moss;	state Exp;
branches;
next	9.3;

9.3
date	90.02.13.10.15.28;	author moss;	state Exp;
branches;
next	9.2;

9.2
date	89.08.02.13.59.27;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.17;	author mike;	state Rel3_5;
branches;
next	8.6;

8.6
date	89.05.12.23.27.34;	author moss;	state Exp;
branches;
next	8.5;

8.5
date	89.03.13.16.41.33;	author moss;	state Exp;
branches;
next	8.4;

8.4
date	89.03.13.14.46.24;	author moss;	state Exp;
branches;
next	8.3;

8.3
date	88.12.20.17.32.43;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	88.12.20.14.23.28;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.51.57;	author mike;	state Rel3_0;
branches;
next	7.8;

7.8
date	88.09.22.12.25.40;	author moss;	state Exp;
branches;
next	7.7;

7.7
date	88.09.20.15.54.54;	author moss;	state Exp;
branches;
next	7.6;

7.6
date	88.09.01.11.46.44;	author moss;	state Exp;
branches;
next	7.5;

7.5
date	88.08.30.10.23.06;	author moss;	state Exp;
branches;
next	7.4;

7.4
date	88.08.09.12.53.47;	author moss;	state Exp;
branches;
next	7.3;

7.3
date	88.06.23.09.29.28;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	87.12.09.13.43.40;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.20;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.10.29.08.51.50;	author moss;	state Exp;
branches;
next	6.2;

6.2
date	87.10.15.10.27.19;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.15.54;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.47.29;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.31.37;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.27.13;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.14.57;	author moss;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.04;	author morrison;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.13
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/lgt.c,v 11.12 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <fcntl.h>
#include <math.h>
#include <signal.h>
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./screen.h"

#if defined( CRAY )
#include <sys/category.h>
#include <sys/resource.h>
#include <sys/types.h>
# if defined( CRAY1 )
#  include <sys/machd.h>	/* For HZ */
# endif
#if defined( CRAY2 )
#undef MAXINT
#include <sys/param.h>
#endif
#define MAX_CPU_TICKS	(200000*HZ) /* Max ticks = seconds * ticks/sec.	*/
#define NICENESS	-6 /* should bring it down from 16 to 10 */
#endif	/* Cray */

#if !defined(NSIG)
# define NSIG	64		/* conservative */
#endif

int	ready_Output_Device(int frame);
void	close_Output_Device(int frame);
#if STD_SIGNAL_DECLS
STATIC void	intr_sig(int sig);
#else
STATIC int	intr_sig();
#endif
STATIC void	init_Lgts(void);
void		exit_Neatly(int status);
int		key_Frame(void);

STATIC int
substr(char *str, char *pattern)
{
	if( *str == '\0' )
		return	FALSE;
	if( *str != *pattern || strncmp( str, pattern, strlen( pattern ) ) )
		return	substr( str+1, pattern );
	return	TRUE;
	}

/*	m a i n ( )							*/
int
main(int argc, char **argv)
{	register int	i;
#if ! defined( BSD ) && ! defined( sgi ) && ! defined( CRAY2 )
	(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#endif
	beginptr = (char *) sbrk(0);

	bu_log( "\n\nThis program is deprecated and will not be supported in future releases\n" );
	bu_log( "\tPlease use \"rtedge\" instead\n" );
	bu_log( "\tPlease notify \"cad@@arl.army.mil\" if you need enhancements to \"rtedge\"\n" );
	bu_log( "\nPress \"Enter\" to continue\n\n" );
	(void)getchar();
	npsw = bu_avail_cpus();
	if( npsw > MAX_PSW )
		npsw = MAX_PSW;
	if( npsw > 1 )
		rt_g.rtg_parallel = 1;
	else
		rt_g.rtg_parallel = 0;
	bu_semaphore_init( RT_SEM_LAST );

#if defined( CRAY )
	{	int	newnice;
		long	oldlimit;
		long	newlimit;
	if( (newnice = nicem( C_PROC, 0, NICENESS )) == -1 )
		perror( "nicem" );
	else
		bu_log( "Program niced to %d.\n", newnice - 20 );
	oldlimit = limit( C_PROC, 0, L_CPU, MAX_CPU_TICKS );
	newlimit = limit( C_PROC, 0, L_CPU, -1 );
	bu_log(	"CPU time limit: was %d seconds, now set to %d seconds.\n",
		oldlimit/HZ,
		newlimit/HZ
		);
	bu_log(	"Memory limit set to %dKW.\n",
		limit( C_PROC, 0, L_MEM, -1 ) );
	}
#endif
	
	init_Lgts();

	if( ! pars_Argv( argc, argv ) )
		{
		prnt_Usage();
		return	1;
		}

/* XXX - ismex() uses dgl on SGI servers which causes problems when client
	machine does not grant access to server via 'xhost'. */
#if 0
	if( ismex() && tty )
		{
		sgi_console = substr( getenv( "TERM" ), "iris" );
		(void) sprintf( prompt,
				"Do you want to use the IRIS mouse ? [y|n](%c) ",
				sgi_usemouse ? 'y' : 'n'
				);
		if( get_Input( input_ln, MAX_LN, prompt ) != NULL )
			sgi_usemouse = input_ln[0] != 'n';
		if( sgi_usemouse )			
			sgi_Init_Popup_Menu();
		}
#endif
	for( i = 0; i < NSIG; i++ )
		switch( i )
			{
		case SIGINT :
			if( (norml_sig = signal( i, SIG_IGN )) == SIG_IGN )
				{
				if( ! tty )
					abort_sig = SIG_IGN;
				else
					{ /* MEX windows on IRIS (other than
						the console) ignore SIGINT. */
					prnt_Scroll( "WARNING: Signal 1 was being ignored!" );
					goto	tty_sig;
					}
				}
			else
				{
tty_sig:
				norml_sig = intr_sig;
				abort_sig = abort_RT;
				(void) signal( i,  norml_sig );
				}
			break;
#ifdef SIGCHLD
		case SIGCHLD :
			break; /* Leave SIGCHLD alone. */
#endif
#if defined(SIGCLD) && (SIGCLD != SIGCHLD)
		case SIGCLD :
			break; /* Leave SIGCLD alone. */
#endif
		case SIGPIPE :
			(void) signal( i, SIG_IGN );
			break;
		case SIGQUIT :
			break;
#if ! defined( SYSV )
#if ! defined( SIGTSTP )
#define SIGTSTP	18
#endif
		case SIGTSTP :
			(void) signal( i, stop_sig );
			break;
#endif
			}
	/* Main loop.							*/
	user_Interaction();
	/*NOTREACHED*/
	return	99; /* Stupid UTX compiler considers this as reachable. */
	}

/*	i n t e r p o l a t e _ F r a m e ( )				*/
int
interpolate_Frame(int frame)
{	fastf_t	rel_frame = (fastf_t) frame / movie.m_noframes;
	if( movie.m_noframes == 1 )
		return	TRUE;
	if( ! movie.m_fullscreen )
		{	register int	frames_across;
			register int	size;
		size = MovieSize( movie.m_frame_sz, movie.m_noframes );
		frames_across = size / movie.m_frame_sz;
		x_fb_origin = (frame % frames_across) * movie.m_frame_sz;
		y_fb_origin = (frame / frames_across) * movie.m_frame_sz;
		}
	bu_log( "Frame %d:\n", frame );
	if( movie.m_keys )
		return	key_Frame() == -1 ? FALSE : TRUE;
	lgts[0].azim = movie.m_azim_beg +
			rel_frame * (movie.m_azim_end - movie.m_azim_beg);
	lgts[0].elev = movie.m_elev_beg +
			rel_frame * (movie.m_elev_end - movie.m_elev_beg);
	grid_roll = movie.m_roll_beg +
			rel_frame * (movie.m_roll_end - movie.m_roll_beg);
	bu_log( "\tview azimuth\t%g\n", lgts[0].azim*DEGRAD );
	bu_log( "\tview elevation\t%g\n", lgts[0].elev*DEGRAD );
	bu_log( "\tview roll\t%g\n", grid_roll*DEGRAD );
	if( movie.m_over )
		{
		lgts[0].over = TRUE;
		lgts[0].dist = movie.m_dist_beg +
			rel_frame * (movie.m_dist_end - movie.m_dist_beg);
		grid_dist = movie.m_grid_beg +
			rel_frame * (movie.m_grid_end - movie.m_grid_beg);
		bu_log( "\teye distance\t%g\n", lgts[0].dist );
		bu_log( "\tgrid distance\t%g\n", grid_dist );
		}
	else
		{
		lgts[0].over = FALSE;
		if( movie.m_pers_beg == 0.0 && movie.m_pers_end == 0.0 )
			{
			rel_perspective = 0.0;
			grid_dist = movie.m_grid_beg +
			     rel_frame * (movie.m_grid_end - movie.m_grid_beg);
			bu_log( "\tgrid distance\t%g\n", grid_dist );
			}
		else
		if( movie.m_pers_beg >= 0.0 )
			rel_perspective = movie.m_pers_beg +
			rel_frame * (movie.m_pers_end - movie.m_pers_beg);
		bu_log( "\tperspective\t%g\n", rel_perspective );
		}
	return	TRUE;
	}

/*	e x i t _ N e a t l y ( )					*/
void
exit_Neatly(int status)
{
	prnt_Event( "Quitting...\n" );
	exit( status );
	}

/*	r e a d y _ O u t p u t _ D e v i c e ( )			*/
int
ready_Output_Device(int frame)
{	int size;
	if( force_cellsz )
		{
		grid_sz = (int)(view_size / cell_sz);
		grid_sz = Max( grid_sz, 1 ); /* must be non-zero */
		setGridSize( grid_sz );
		prnt_Status();
		}
	/* Calculate size of frame buffer image (pixels across square image). */
	if( movie.m_noframes > 1 && ! movie.m_fullscreen )
		/* Fit frames of movie. */
		size = MovieSize( grid_sz, movie.m_noframes );
	else
	if( force_fbsz && ! DiskFile(fb_file) )
		size = fb_size; /* user-specified size */
	else
		size = grid_sz; /* just 1 pixel/ray */
	if( movie.m_noframes > 1 && movie.m_fullscreen )
		{	char	framefile[MAX_LN];
		/* We must be doing full-screen frames. */
		size = grid_sz;
		(void) sprintf( framefile, "%s.%04d", prefix, frame );
		if( ! fb_Setup( framefile, size ) )
			return	0;
		}
	else
		{
		if( frame == movie.m_curframe && ! fb_Setup( fb_file, size ) )
			return	0;
		fb_Zoom_Window();
		}
	return	1;
	}

/*	c l o s e _ O u t p u t _ D e v i c e ( )			*/
void
close_Output_Device(int frame)
{
	assert( fbiop != FBIO_NULL );
#if SGI_WINCLOSE_BUG
	if( strncmp( fbiop->if_name, "/dev/sgi", 8 ) != 0 )
#endif
	if(	(movie.m_noframes > 1 && movie.m_fullscreen)
	    ||	frame == movie.m_endframe )
		{
		(void) fb_close( fbiop );
		fbiop = FBIO_NULL;
		}
	return;
	}

#if STD_SIGNAL_DECLS
STATIC void
#else
STATIC int
#endif
/*ARGSUSED*/
intr_sig(int sig)
{
	(void) signal( SIGINT, intr_sig );
#if STD_SIGNAL_DECLS
	return;
#else
	return	sig;
#endif
	}

/*	i n i t _ L g t s ( )
	Set certain default lighting info.
 */
STATIC void
init_Lgts(void)
{
	/* Ambient lighting.						*/
	(void) strcpy( lgts[0].name, "EYE" );
	lgts[0].beam = FALSE;
	lgts[0].over = FALSE;
	lgts[0].rgb[0] = 255;
	lgts[0].rgb[1] = 255;
	lgts[0].rgb[2] = 255;
	lgts[0].azim = 30.0/DEGRAD;
	lgts[0].elev = 30.0/DEGRAD;
	lgts[0].dist = 0.0;
	lgts[0].energy = 0.4;
	lgts[0].stp = SOLTAB_NULL;

	/* Primary lighting.						*/
	(void) strcpy( lgts[1].name, "LIGHT" );
	lgts[1].beam = FALSE;
	lgts[1].over = TRUE;
	lgts[1].rgb[0] = 255;
	lgts[1].rgb[1] = 255;
	lgts[1].rgb[2] = 255;
	lgts[1].azim = 60.0/DEGRAD;
	lgts[1].elev = 60.0/DEGRAD;
	lgts[1].dist = 10000.0;
	lgts[1].energy = 1.0;
	lgts[1].stp = SOLTAB_NULL;

	lgt_db_size = 2;
	return;
	}
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/lgt.c,v 11.11 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 5
a16 1
#include "conf.h"
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt.c,v 11.8 2001/10/15 19:39:20 morrison Exp $ (BRL)";
d55 2
a56 2
int	ready_Output_Device();
void	close_Output_Device();
d58 1
a58 1
STATIC void	intr_sig();
d62 3
a64 3
STATIC void	init_Lgts();
void		exit_Neatly();
int		key_Frame();
d67 2
a68 3
substr( str, pattern )
char	*str, *pattern;
	{
d78 1
a78 2
main( argc, argv )
char	*argv[];
d195 2
a196 3
interpolate_Frame( frame )
int	frame;
	{	fastf_t	rel_frame = (fastf_t) frame / movie.m_noframes;
d250 2
a251 3
exit_Neatly( status )
int	status;
	{
d258 2
a259 3
ready_Output_Device( frame )
int	frame;
	{	int size;
d295 2
a296 3
close_Output_Device( frame )
int frame;
	{
d316 2
a317 3
intr_sig( sig )
int	sig;
	{
d330 2
a331 2
init_Lgts()
	{
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt.c,v 11.10 2002/08/20 17:07:34 jra Exp $ (BRL)";
d55 2
a56 2
int	ready_Output_Device(int frame);
void	close_Output_Device(int frame);
d58 1
a58 1
STATIC void	intr_sig(int sig);
d62 3
a64 3
STATIC void	init_Lgts(void);
void		exit_Neatly(int status);
int		key_Frame(void);
d67 3
a69 2
substr(char *str, char *pattern)
{
d79 2
a80 1
main(int argc, char **argv)
d197 3
a199 2
interpolate_Frame(int frame)
{	fastf_t	rel_frame = (fastf_t) frame / movie.m_noframes;
d253 3
a255 2
exit_Neatly(int status)
{
d262 3
a264 2
ready_Output_Device(int frame)
{	int size;
d300 3
a302 2
close_Output_Device(int frame)
{
d322 3
a324 2
intr_sig(int sig)
{
d337 2
a338 2
init_Lgts(void)
{
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d55 2
a56 2
int	ready_Output_Device(int frame);
void	close_Output_Device(int frame);
d58 1
a58 1
STATIC void	intr_sig(int sig);
d62 3
a64 3
STATIC void	init_Lgts(void);
void		exit_Neatly(int status);
int		key_Frame(void);
d67 3
a69 2
substr(char *str, char *pattern)
{
d79 2
a80 1
main(int argc, char **argv)
d197 3
a199 2
interpolate_Frame(int frame)
{	fastf_t	rel_frame = (fastf_t) frame / movie.m_noframes;
d253 3
a255 2
exit_Neatly(int status)
{
d262 3
a264 2
ready_Output_Device(int frame)
{	int size;
d300 3
a302 2
close_Output_Device(int frame)
{
d322 3
a324 2
intr_sig(int sig)
{
d337 2
a338 2
init_Lgts(void)
{
@


11.8
log
@plurality of release comment
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt.c,v 11.7 2001/08/09 16:42:52 jra Exp $ (BRL)";
d55 2
a56 2
int	ready_Output_Device();
void	close_Output_Device();
d58 1
a58 1
STATIC void	intr_sig();
d62 3
a64 3
STATIC void	init_Lgts();
void		exit_Neatly();
int		key_Frame();
d67 2
a68 3
substr( str, pattern )
char	*str, *pattern;
	{
d78 1
a78 2
main( argc, argv )
char	*argv[];
d195 2
a196 3
interpolate_Frame( frame )
int	frame;
	{	fastf_t	rel_frame = (fastf_t) frame / movie.m_noframes;
d250 2
a251 3
exit_Neatly( status )
int	status;
	{
d258 2
a259 3
ready_Output_Device( frame )
int	frame;
	{	int size;
d295 2
a296 3
close_Output_Device( frame )
int frame;
	{
d316 2
a317 3
intr_sig( sig )
int	sig;
	{
d330 2
a331 2
init_Lgts()
	{
@


11.7
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt.c,v 11.6 2001/08/08 21:02:04 jra Exp $ (BRL)";
d87 1
a87 1
	bu_log( "\n\nThis program is deprecated and will not be supported in future release\n" );
@


11.6
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt.c,v 11.5 2000/08/24 22:55:51 mike Exp $ (BRL)";
d87 5
@


11.5
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt.c,v 11.4 1999/06/03 21:40:50 mike Exp $ (BRL)";
d64 1
d78 1
@


11.4
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt.c,v 11.3 1997/12/16 00:50:49 mike Exp $ (BRL)";
@


11.3
log
@Changed to use new symbol RT_SEM_LAST
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 11.2 1997/12/16 00:25:39 mike Exp mike $ (BRL)";
d85 1
a85 1
	npsw = rt_avail_cpus();
d101 1
a101 1
		rt_log( "Program niced to %d.\n", newnice - 20 );
d104 1
a104 1
	rt_log(	"CPU time limit: was %d seconds, now set to %d seconds.\n",
d108 1
a108 1
	rt_log(	"Memory limit set to %dKW.\n",
d203 1
a203 1
	rt_log( "Frame %d:\n", frame );
d212 3
a214 3
	rt_log( "\tview azimuth\t%g\n", lgts[0].azim*DEGRAD );
	rt_log( "\tview elevation\t%g\n", lgts[0].elev*DEGRAD );
	rt_log( "\tview roll\t%g\n", grid_roll*DEGRAD );
d222 2
a223 2
		rt_log( "\teye distance\t%g\n", lgts[0].dist );
		rt_log( "\tgrid distance\t%g\n", grid_dist );
d233 1
a233 1
			rt_log( "\tgrid distance\t%g\n", grid_dist );
d239 1
a239 1
		rt_log( "\tperspective\t%g\n", rel_perspective );
@


11.2
log
@Converted to bu_semaphore_acquire()
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 11.1 1995/01/04 10:17:53 mike Rel4_4 mike $ (BRL)";
d92 1
a92 1
	bu_semaphore_init( BU_SEM_LAST );
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 10.8 94/12/28 08:43:14 stay Exp $ (BRL)";
d92 1
a92 5
	RES_INIT( &rt_g.res_model );
	RES_INIT( &rt_g.res_results );
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_syscall );
	RES_INIT( &rt_g.res_worker );
@


10.8
log
@fix call to sbrk with a (char *) in front
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 10.7 94/12/12 22:10:57 mike Exp Locker: stay $ (BRL)";
@


10.7
log
@string(s).h for Linux
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 10.6 94/08/24 13:35:46 gdurf Exp Locker: mike $ (BRL)";
d83 1
a83 1
	beginptr = sbrk(0);
@


10.6
log
@Made includes explicit, factored ifdefs
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 10.5 1993/09/22 11:22:20 moss Exp gdurf $ (BRL)";
d15 5
@


10.5
log
@SIGCLD not defined under IRIX5.0.1.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 10.4 93/07/09 10:31:34 moss Exp Locker: moss $ (BRL)";
d12 2
d18 9
d163 1
a163 1
#ifdef SIGCLD
@


10.4
log
@Fixed grid_sz to be non-zero when computed as viewsize/cellsize.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/lgt.c,v 10.3 92/10/13 10:18:18 moss Exp Locker: moss $ (BRL)";
d148 1
a148 1
#if defined( BSD )
d150 3
a152 1
#else
d154 1
a155 1
			break; /* Leave SIGCLD alone.			*/
@


10.3
log
@Disabled use of mouse menus.  The ismex() routine now uses 'dgl' which
causes errors if access to an SGI server is not granted via xhost on
the client.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/lgt.c,v 10.2 92/03/27 12:08:38 moss Exp Locker: moss $ (BRL)";
d247 1
@


10.2
log
@Fixed bugs relating to using an eye and grid solid.
	These solids are now skipped in the partition list of the hit routine.
	The vertical grid vector is now properly calculated.
	The eye and grid location are reported as well as the view direction
		when using this feature.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/lgt.c,v 10.1 91/10/12 06:50:08 mike Rel4_0 $ (BRL)";
d109 3
a111 1
#ifdef sgi
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 9.8 91/09/20 23:43:38 mike Exp $ (BRL)";
d339 1
a339 1
	lgts[0].stp = SOLTAB_NULL;
@


9.8
log
@Added sys/machd.h, for UNICOS 6.0, per Dick Wiley <dick@@arista.ta52.lanl.gov>
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 9.7 91/07/09 02:55:37 mike Exp $ (BRL)";
@


9.7
log
@If NSIG not defined, set it to 64
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 9.6 91/07/02 14:56:08 moss Exp $ (BRL)";
d24 3
@


9.6
log
@Added RES_INIT of res_model semaphore.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt.c,v 9.5 91/05/01 15:34:51 moss Exp $ (BRL)";
d19 1
d30 4
d35 1
@


9.5
log
@Improved movie generation to allow animation of slicing distance.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 9.1 89/05/19 06:13:17 mike Rel3_5 $ (BRL)";
d67 3
a71 2
	RES_INIT( &rt_g.res_stats );
	RES_INIT( &rt_g.res_results );
@


9.4
log
@Now use rt_avail_cpus().  Also set viewport properly from f_Movie().
@
text
@d181 1
a181 1
				rel_frame * (movie.m_azim_end - movie.m_azim_beg);
d183 1
a183 1
				rel_frame * (movie.m_elev_end - movie.m_elev_beg);
d185 4
a188 1
				rel_frame * (movie.m_roll_end - movie.m_roll_beg);
d193 1
a193 1
				rel_frame * (movie.m_dist_end - movie.m_dist_beg);
d195 3
a197 1
				rel_frame * (movie.m_grid_end - movie.m_grid_beg);
d202 8
d213 1
a214 10
	rt_log( "\tview azimuth\t%g\n", lgts[0].azim*DEGRAD );
	rt_log( "\tview elevation\t%g\n", lgts[0].elev*DEGRAD );
	rt_log( "\tview roll\t%g\n", grid_roll*DEGRAD );
	if( movie.m_over )
		{
		rt_log( "\teye distance\t%g\n", lgts[0].dist );
		rt_log( "\tgrid distance\t%g\n", grid_dist );
		}
	else
		rt_log( "\tperspective\t%g\n", rel_perspective );
@


9.3
log
@Just tidying up.
@
text
@d60 3
@


9.2
log
@Fixed bug in shadowing when light source is closer than object.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 8.5 89/03/13 16:41:33 moss Exp $ (BRL)";
a18 1

d30 2
a31 3

int ready_Output_Device();
void close_Output_Device();
d33 1
a33 1
STATIC void intr_sig();
d35 1
a35 1
STATIC int intr_sig();
d37 2
a38 2
STATIC void init_Lgts();
void exit_Neatly();
d51 1
a51 3
/*
	int main( int argc, char *argv[] )
 */
d53 2
a54 3
int argc;
char *argv[];
	{	register int i;
d70 3
a72 3
	{	int newnice;
		long oldlimit;
		long newlimit;
d159 1
a159 3
/*
	int interpolate_Frame( int frame )
 */
d162 1
a162 1
int frame;
d178 1
a178 1
			rel_frame * (movie.m_azim_end - movie.m_azim_beg);
d180 1
a180 1
			rel_frame * (movie.m_elev_end - movie.m_elev_beg);
d182 1
a182 1
			rel_frame * (movie.m_roll_end - movie.m_roll_beg);
d187 1
a187 1
			rel_frame * (movie.m_dist_end - movie.m_dist_beg);
d189 1
a189 1
			rel_frame * (movie.m_grid_end - movie.m_grid_beg);
d211 1
a211 3
/*
	void exit_Neatly( int status )
 */
d220 1
a220 3
/*
	int ready_Output_Device( int frame )
 */
d223 1
a223 1
int frame;
d257 1
a257 3
/*
	void close_Output_Device( int frame )
 */
d292 2
a293 4
/*
	void init_Lgts( void )

	Set certain default lighting information.
d298 1
a298 1
	/* Ambient lighting. */
d311 1
a311 1
	/* Primary lighting. */
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 8.6 89/05/12 23:27:34 moss Exp $ (BRL)";
d19 1
d31 3
a33 2
int	ready_Output_Device();
void	close_Output_Device();
d35 1
a35 1
STATIC void	intr_sig();
d37 1
a37 1
STATIC int	intr_sig();
d39 2
a40 2
STATIC void	init_Lgts();
void		exit_Neatly();
d53 3
a55 1
/*	m a i n ( )							*/
d57 3
a59 2
char	*argv[];
{	register int	i;
d75 3
a77 3
	{	int	newnice;
		long	oldlimit;
		long	newlimit;
d164 3
a166 1
/*	i n t e r p o l a t e _ F r a m e ( )				*/
d169 1
a169 1
int	frame;
d185 1
a185 1
				rel_frame * (movie.m_azim_end - movie.m_azim_beg);
d187 1
a187 1
				rel_frame * (movie.m_elev_end - movie.m_elev_beg);
d189 1
a189 1
				rel_frame * (movie.m_roll_end - movie.m_roll_beg);
d194 1
a194 1
				rel_frame * (movie.m_dist_end - movie.m_dist_beg);
d196 1
a196 1
				rel_frame * (movie.m_grid_end - movie.m_grid_beg);
d218 3
a220 1
/*	e x i t _ N e a t l y ( )					*/
d229 3
a231 1
/*	r e a d y _ O u t p u t _ D e v i c e ( )			*/
d234 1
a234 1
int	frame;
d268 3
a270 1
/*	c l o s e _ O u t p u t _ D e v i c e ( )			*/
d305 4
a308 2
/*	i n i t _ L g t s ( )
	Set certain default lighting info.
d313 1
a313 1
	/* Ambient lighting.						*/
d326 1
a326 1
	/* Primary lighting.						*/
@


8.6
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 8.5 89/03/13 16:41:33 moss Exp $ (BRL)";
@


8.5
log
@Fixed signal handler declarations.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 8.4 89/03/13 14:46:24 moss Locked $ (BRL)";
d16 1
a16 4
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
a17 1
#include "./lgt.h"
a18 1
#include "./extern.h"
d33 1
a33 3
_LOCAL_ void	intr_sig();
void		(*norml_sig)(), (*abort_sig)();
extern void	stop_sig();
d35 1
a35 3
_LOCAL_ int	intr_sig();
int		(*norml_sig)(), (*abort_sig)();
extern int	stop_sig();
d37 1
a37 1
_LOCAL_ void	init_Lgts();
d40 1
a40 1
_LOCAL_ int
d169 1
a169 1
		size = (int) sqrt( (double) movie.m_noframes + 0.5 ) * movie.m_frame_sz;
d224 16
a239 2
	{	int	size =
		(int) sqrt( (double) movie.m_noframes + 0.5 ) * grid_sz;
d241 1
a241 1
		{	char	frame_file[MAX_LN];
d243 3
a245 2
		(void) sprintf( frame_file, "%s.%04d", fb_file, frame );
		if( ! fb_Setup( frame_file, grid_sz ) )
d250 1
a250 1
		if( ! fb_Setup( fb_file, size ) )
d259 2
a260 1
close_Output_Device()
d262 2
d265 4
d270 2
d276 1
a276 1
_LOCAL_ void
d278 1
a278 1
_LOCAL_ int
d295 1
a295 1
_LOCAL_ void
@


8.4
log
@Changed limit command in print statement to remove memory usage limit.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 8.3 88/12/20 17:32:43 moss Locked $ (BRL)";
d37 5
a41 1
#if defined( BSD ) || (defined( SYSV ) && ! defined( mips ))
a44 4
#else
_LOCAL_ void	intr_sig();
void		(*norml_sig)(), (*abort_sig)();
extern void	stop_sig();
d260 3
a262 1
#if defined( BSD ) || (defined( SYSV ) && ! defined( mips ))
a263 2
#else
_LOCAL_ void
d270 3
a272 1
#if defined( BSD )
a273 2
#else
	return;
@


8.3
log
@Enabled setting of limits and nice value on crays.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 8.2 88/12/20 14:23:28 moss Exp $ (BRL)";
d92 2
a93 1
	rt_log(	"Memory limit set to %dKW.\n", limit( C_PROC, 0, L_MEM, 0 ) );
@


8.2
log
@Enabled setting of nice number and cpu limit on crays.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 8.1 88/10/05 00:51:57 moss Locked $ (BRL)";
d33 1
a33 1
#define NICENESS	10
d79 12
a90 7
	nicem( C_PROC, 0, NICENESS );
	rt_log( "Program niced to %d.\n", NICENESS );
	limit( C_PROC, 0, L_CPU, MAX_CPU_TICKS );
	rt_log(	"CPU limit set to %d ticks (at %d/sec that's %d seconds).\n",
		MAX_CPU_TICKS,
		HZ,
		MAX_CPU_TICKS/HZ
d92 2
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 7.8 88/09/22 12:25:40 moss Exp $ (BRL)";
d24 1
a24 1
#if 0
d32 2
a33 2
#define MAX_CPU_TICKS	(100000*HZ) /* Max ticks = seconds * ticks/sec.	*/
#define NICENESS	12
d78 1
a78 1
#if 0
@


7.8
log
@Added "return 99" at end of main() since UTX/32 2.0 compiler didn't
recognize the /*NOTREACHED*/ directive.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 7.2 87/12/09 13:43:40 moss Locked $ (BRL)";
@


7.7
log
@Changed exit( 1 ) to return	1.
@
text
@d157 1
@


7.6
log
@See comment in other modules about addition of shadow switch, being
	inside a solid, and converting to use librt/machine.c.
@
text
@d94 1
a94 1
		exit( 1 );
@


7.5
log
@Did away with texture file commands, and added textures to material
properties data base.
@
text
@a68 2
#ifdef PARALLEL
#ifndef alliant
a72 1
#endif
a76 1
#endif
@


7.4
log
@
@
text
@d106 1
a106 1
				"Do you want to use the IRIS mouse and keyboard ? [y|n](%c) ",
@


7.3
log
@Smoothing out menu and prompting interface.
@
text
@d106 1
a106 1
				"Do you want to use the mouse ? [y|n](%c) ",
@


7.2
log
@Improvements to IR modeling interface.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 7.1 87/11/03 00:25:20 moss Locked $ (BRL)";
d37 1
a37 1
#if defined( BSD ) || defined( SYSV )
d49 11
d69 7
d79 3
d102 12
a113 2
	if( ismex() & tty )
		sgi_Init_Popup_Menu();
d167 1
a167 3
	{	register int	frames_across;
		register int	size;
		fastf_t		rel_frame = (fastf_t) frame / movie.m_noframes;
d169 9
a177 5
		return	1;
	size = (int) sqrt( (double) movie.m_noframes + 0.5 ) * movie.m_frame_sz;
	frames_across = size / movie.m_frame_sz;
	x_fb_origin = (frame % frames_across) * movie.m_frame_sz;
	y_fb_origin = (frame / frames_across) * movie.m_frame_sz;
d179 2
a180 2
	if( movie.m_keys_bool )
		return	key_Frame() == -1 ? 0 : 1;
d187 1
a187 1
	if( movie.m_over_bool )
d205 1
a205 1
	if( movie.m_over_bool )
d212 1
a212 1
	return	1;
d220 1
a220 2
	if( tty )
		prnt_Event( "Quitting...\n" );
d226 2
a227 1
ready_Output_Device()
d230 13
a242 5
	if( tty )
		prnt_Event( "Opening device..." );
	if( ! fb_Setup( fb_file, size ) )
		return	0;
	fb_Zoom_Window();
d255 1
a255 1
#if defined( BSD ) || defined( SYSV )
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 6.3 87/10/29 08:51:50 moss Exp $ (BRL)";
a10 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) lgt.c	2.3
		Modified: 	2/4/87 at 08:50:41	G S M
		Retrieved: 	2/4/87 at 08:53:05
		SCCS archive:	/vld/moss/src/lgt/s.lgt.c
*/
d89 10
a98 1
				abort_sig = SIG_IGN;
d101 1
@


6.3
log
@Ready for release 2.1 of BRL CAD.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 6.2 87/10/15 10:27:19 moss Locked $ (BRL)";
@


6.2
log
@Moved location of setvbuf to front of main, disallowed for Cray-2 because
	of bug (later fixed, but why take chances).
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 5.1 87/06/24 22:47:29 mike Rel $ (BRL)";
a213 1
/*ARGSUSED*/
d216 1
d219 1
a219 1
	{	char	buf[10];
d235 1
a235 1
	strcpy( lgts[0].name, "EYE" );
d248 1
a248 1
	strcpy( lgts[1].name, "LIGHT" );
@


6.1
log
@Release 2.0
@
text
@d31 1
a31 1
#ifdef cray
d35 5
a39 1
#define MAX_CPU_TICKS	(200000*HZ) /* Max ticks = seconds * ticks/sec.	*/
d60 4
a64 1
	beginptr = sbrk(0);
d68 1
a68 1
#if cray
a78 4
#if ! defined( BSD ) && ! defined( sgi )
	(void) setvbuf( stderr, (char *) NULL, _IOLBF, BUFSIZ );
#endif

a125 1
	exit_Neatly( 0 );
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 1.3 87/06/23 12:31:37 moss Exp $ (BRL)";
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 1.2 87/02/06 12:27:13 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes, pulled prnt_* functions out into module "prnt.c".
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt.c,v 1.1 87/02/04 15:14:57 moss Locked $ (BRL)";
d31 7
d40 1
a40 1
#if defined( BSD ) || defined( sgi )
d58 1
a58 1
	RES_INIT( &rt_g.res_malloc );
d61 10
a87 1

d112 1
a112 1
#if ! defined( sgi )
d124 1
d141 1
a141 1
	if( movie.m_keys_flg )
d149 1
a149 1
	if( movie.m_over_flg )
d167 1
a167 1
	if( movie.m_over_flg )
d209 1
a209 1
#if defined( BSD ) || defined( sgi )
a218 3
	(void) get_Input( buf, sizeof(buf), "Really quit ? " );
	if( buf[0] != 'n' )
		user_interrupt = 1;
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d23 6
a28 7
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
#include <std.h>
#include <fb.h>
#include <vecmath.h>
#include <lgt.h>
a165 1
		{
a166 2
		(void) fflush( stdout );
		}
d175 2
@
