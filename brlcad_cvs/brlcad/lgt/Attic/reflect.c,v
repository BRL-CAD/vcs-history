head	11.26;
access;
symbols
	ansi-20040405-merged:11.23.2.1
	postmerge-20040405-ansi:11.24
	premerge-20040404-ansi:11.23
	postmerge-autoconf:11.23
	autoconf-freeze:11.23
	premerge-autoconf:11.23
	ansi-20040316-freeze:11.23.2.1
	postmerge-20040315-windows:11.23
	premerge-20040315-windows:11.23
	windows-20040315-freeze:11.23
	autoconf-20031203:11.23
	autoconf-20031202:11.23
	autoconf-branch:11.23.0.10
	phong-branch:11.23.0.8
	photonmap-branch:11.23.0.6
	rel-6-1-DP:11.23
	windows-branch:11.23.0.4
	rel-6-0-2:11.21
	ansi-branch:11.23.0.2
	rel-6-0-1-branch:11.21.0.2
	hartley-6-0-post:11.22
	hartley-6-0-pre:11.21
	rel-6-0-1:11.21
	rel-6-0:11.21
	rel-5-4:11.15.2.1
	offsite-5-3-pre:11.16
	rel-5-3:11.15
	rel-5-2:11.15
	rel-5-1-branch:11.15.0.2
	rel-5-1:11.15
	rel-5-0:11.13
	rel-5-0-beta:11.12
	rel-4-5:11.9
	ctj-4-5-post:11.6
	ctj-4-5-pre:11.6
	rel-4-4:11.2
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.26
date	2004.05.21.17.48.16;	author morrison;	state dead;
branches;
next	11.25;

11.25
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.24;

11.24
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.23;

11.23
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.23.2.1;
next	11.22;

11.22
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.21;

11.21
date	2001.11.05.21.20.06;	author morrison;	state Exp;
branches;
next	11.20;

11.20
date	2001.08.10.02.36.24;	author jra;	state Exp;
branches;
next	11.19;

11.19
date	2001.08.09.16.42.52;	author jra;	state Exp;
branches;
next	11.18;

11.18
date	2001.05.17.20.05.16;	author morrison;	state Exp;
branches;
next	11.17;

11.17
date	2001.03.26.20.53.25;	author jra;	state Exp;
branches;
next	11.16;

11.16
date	2000.08.24.22.55.52;	author mike;	state Exp;
branches;
next	11.15;

11.15
date	2000.01.31.16.06.37;	author jra;	state Exp;
branches
	11.15.2.1;
next	11.14;

11.14
date	99.12.23.05.27.26;	author mike;	state Exp;
branches;
next	11.13;

11.13
date	99.06.03.21.40.51;	author mike;	state Exp;
branches;
next	11.12;

11.12
date	99.05.10.21.45.16;	author mike;	state Exp;
branches;
next	11.11;

11.11
date	98.04.15.05.24.19;	author mike;	state Exp;
branches;
next	11.10;

11.10
date	98.03.27.07.35.23;	author mike;	state Exp;
branches;
next	11.9;

11.9
date	97.12.16.00.25.39;	author mike;	state Exp;
branches;
next	11.8;

11.8
date	97.09.11.20.39.10;	author jra;	state Exp;
branches;
next	11.7;

11.7
date	97.06.17.21.05.38;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	96.12.04.03.21.32;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	96.10.19.06.20.46;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	96.08.20.12.01.40;	author moss;	state Exp;
branches;
next	11.3;

11.3
date	96.07.17.13.03.43;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	95.01.05.01.26.59;	author mike;	state Rel4_4;
branches;
next	11.1;

11.1
date	95.01.04.10.18.00;	author mike;	state Rel4_4;
branches;
next	10.7;

10.7
date	95.01.03.09.53.13;	author jra;	state Exp;
branches;
next	10.6;

10.6
date	94.08.24.13.37.00;	author gdurf;	state Exp;
branches;
next	10.5;

10.5
date	92.03.27.12.08.31;	author moss;	state Exp;
branches;
next	10.4;

10.4
date	92.02.28.09.18.26;	author moss;	state Exp;
branches;
next	10.3;

10.3
date	91.12.20.10.24.09;	author moss;	state Exp;
branches;
next	10.2;

10.2
date	91.12.12.17.03.59;	author moss;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.13;	author mike;	state Rel4_0;
branches;
next	9.12;

9.12
date	91.08.30.21.15.49;	author mike;	state Exp;
branches;
next	9.11;

9.11
date	91.07.23.17.08.54;	author moss;	state Exp;
branches;
next	9.10;

9.10
date	91.07.23.17.03.12;	author moss;	state Exp;
branches;
next	9.9;

9.9
date	91.05.01.15.35.01;	author moss;	state Exp;
branches;
next	9.8;

9.8
date	91.02.05.14.13.26;	author moss;	state Exp;
branches;
next	9.7;

9.7
date	90.12.10.10.24.31;	author moss;	state Exp;
branches;
next	9.6;

9.6
date	90.02.13.10.15.51;	author moss;	state Exp;
branches;
next	9.5;

9.5
date	89.12.05.09.46.55;	author moss;	state Exp;
branches;
next	9.4;

9.4
date	89.08.02.14.00.02;	author moss;	state Exp;
branches;
next	9.3;

9.3
date	89.05.22.12.42.23;	author moss;	state Exp;
branches;
next	9.2;

9.2
date	89.05.22.12.24.39;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.29;	author mike;	state Rel3_5;
branches;
next	8.9;

8.9
date	89.05.12.23.27.46;	author moss;	state Exp;
branches;
next	8.8;

8.8
date	89.04.14.12.20.55;	author moss;	state Exp;
branches;
next	8.7;

8.7
date	89.03.13.16.41.38;	author moss;	state Exp;
branches;
next	8.6;

8.6
date	89.03.08.17.03.43;	author moss;	state Exp;
branches;
next	8.5;

8.5
date	88.12.15.16.11.21;	author moss;	state Exp;
branches;
next	8.4;

8.4
date	88.10.19.15.19.06;	author moss;	state Exp;
branches;
next	8.3;

8.3
date	88.10.19.11.00.06;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	88.10.12.14.28.59;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.52.09;	author mike;	state Rel3_0;
branches;
next	7.13;

7.13
date	88.10.04.13.13.43;	author wm;	state Exp;
branches;
next	7.12;

7.12
date	88.10.04.11.09.36;	author moss;	state Exp;
branches;
next	7.11;

7.11
date	88.09.22.11.43.19;	author moss;	state Exp;
branches;
next	7.10;

7.10
date	88.09.22.11.18.28;	author moss;	state Exp;
branches;
next	7.9;

7.9
date	88.09.20.15.56.30;	author moss;	state Exp;
branches;
next	7.8;

7.8
date	88.09.01.11.48.17;	author moss;	state Exp;
branches;
next	7.7;

7.7
date	88.08.30.10.23.19;	author moss;	state Exp;
branches;
next	7.6;

7.6
date	88.08.09.12.57.11;	author moss;	state Exp;
branches;
next	7.5;

7.5
date	88.06.24.15.21.45;	author moss;	state Exp;
branches;
next	7.4;

7.4
date	88.06.23.09.30.12;	author moss;	state Exp;
branches;
next	7.3;

7.3
date	88.01.07.12.04.57;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	87.12.09.13.43.17;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.41;	author mike;	state Rel;
branches;
next	5.3;

5.3
date	87.10.29.08.52.10;	author moss;	state Exp;
branches;
next	5.2;

5.2
date	87.10.15.10.02.10;	author moss;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.48.00;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.32.46;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.29.17;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.15.03;	author moss;	state Exp;
branches;
next	;

11.15.2.1
date	2001.03.28.14.18.13;	author jra;	state Exp;
branches;
next	;

11.23.2.1
date	2002.09.19.18.01.05;	author morrison;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.26
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066

	Thanks to Edwin O. Davisson and Robert Shnidman for contributions
	to the refraction algorithm.
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/reflect.c,v 11.25 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <math.h>
#ifdef USE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./mat_db.h"
#include "./tree.h"
#include "./screen.h"
#define TWO_PI		6.28318530717958647692528676655900576839433879875022
#define RI_AIR		1.0  /* refractive index of air */

/* These are used by the hidden-line drawing routines. */
#define COSTOL		0.91	/* normals differ if dot product < COSTOL */
#define OBLTOL		0.1	/* high obliquity if cosine of angle < OBLTOL */
#define is_Odd(_a)	((_a)&01)
#define ARCTAN_87	19.08

#ifndef FLIPPED_NORMALS_BUG
#define FLIPPED_NORMALS_BUG	0 /* Keep an eye out for dark spots. */
#endif

#if FLIPPED_NORMALS_BUG
#define Check_Iflip( _pp, _normal, _rdir, _stp )\
	{ fastf_t	f = Dot( _rdir, _normal );\
	if( f >= 0.0 )\
		{\
		if( ! _pp->pt_inflip && (RT_G_DEBUG&DEBUG_NORML) )\
			{\
			V_Print( "Fixed flipped entry normal, was",\
				_normal, bu_log );\
			bu_log( "Primitive type %d\n", _stp->st_id );\
			}\
		VREVERSE( _normal, _normal );\
		}\
	}
#else
#define Check_Iflip( _pp, _normal, _rdir, _stp )	;
#endif

#if FLIPPED_NORMALS_BUG
#define Check_Oflip( _pp, _normal, _rdir, _stp )\
	{	fastf_t	f = Dot( _rdir, _normal );\
	if( f <= 0.0 )\
		{\
		if( ! _pp->pt_outflip && (RT_G_DEBUG&DEBUG_NORML) )\
			{\
			V_Print( "Fixed flipped exit normal, was",\
				_normal, bu_log );\
			bu_log( "Primitive type %d\n", _stp->st_id );\
			}\
		VREVERSE( _normal, _normal );\
		}\
	}
#else
#define Check_Oflip( _pp, _normal, _rdir, _stp )	;
#endif

/* default material property entry */
static Mat_Db_Entry mat_tmp_entry =
				{
				0,		/* Material id. */
				4,		/* Shininess. */
				0.6,		/* Specular weight. */
				0.4,		/* Diffuse weight. */
				0.0,		/* Reflectivity. */
				0.0,		/* Transmission. */
				1.0,		/* Refractive index. */
				{255, 255, 255},/* Diffuse RGB values. */
				MF_USED,	/* Mode flag. */
				"(default)"	/* Material name. */
				};

/* Collect statistics on refraction. */
static int refrac_missed;
static int refrac_inside;
static int refrac_total;

/* Collect statistics on shadowing. */
static int hits_shadowed;
static int hits_lit;

/* Local communication with render_Scan(). */
static int curr_scan;	  /* current scan line number */
static int last_scan;	  /* last scan */
static int a_gridsz;	  /* grid size taking anti-aliasing into account */
static fastf_t a_cellsz;  /* cell size taking anti-aliasing into account */
static fastf_t grid_dh[3], grid_dv[3];
static struct application ag;	/* global application structure */

/* Bit map for hidden line drawing. */
#ifndef BITSPERBYTE
#define BITSPERBYTE	8
#endif
#define HL_BITVBITS		(sizeof(bitv_t)*BITSPERBYTE)
#define HL_BITVMASK(_x)	((_x) == 0 ? 1 : 1L<<(_x)%HL_BITVBITS)
#define HL_BITVWORD(_x,_y)	hl_bits[_y][(_x)/HL_BITVBITS]
#define HL_SETBIT(_x,_y)	HL_BITVWORD(_x,_y) |= HL_BITVMASK(_x)
#define HL_CLRBIT(_x,_y)	HL_BITVWORD(_x,_y) &= ~HL_BITVMASK(_x)
#define HL_TSTBIT(_x,_y)	(HL_BITVWORD(_x,_y) & HL_BITVMASK(_x))
#define ZeroPixel(_p)		((_p)[RED]==0 && (_p)[GRN]==0 && (_p)[BLU]==0)
static bitv_t hl_bits[MAX_HL_SIZE][MAX_HL_SIZE/HL_BITVBITS];
static RGBpixel *hl_normap = NULL;
static short *hl_regmap = NULL;
static unsigned short *hl_dstmap = NULL;

/* Is object behind me.  Using values smaller than .01 cause bogus shadows
	on single-precision math library machines like the IRIS 3030.  This
	is because in shooting from a surface to the light source, we
	actually nick the surface because of floating point inaccuracies
	in the root finder.  BEHIND_ME_TOL must be larger than the distance
	to the exit from these thin segments.
 */
#ifndef BEHIND_ME_TOL
#define BEHIND_ME_TOL	0.01
#endif
#define PT_EMPTY	0
#define PT_OHIT		1
#define PT_BEHIND	2
#define PT_EYE		3
#define PT_GRID		4

#define Get_Partition( ap, pp, pt_headp, func )\
	{	int failure;\
	for(	pp = pt_headp->pt_forw;\
		(failure=PT_EMPTY, pp != pt_headp)\
	    &&	(failure=PT_OHIT, pp->pt_outhit != (struct hit *) NULL)\
	    && ((failure=PT_BEHIND, pp->pt_outhit->hit_dist < BEHIND_ME_TOL)\
	     || (failure=PT_EYE, pp->pt_inseg->seg_stp == lgts[0].stp)\
	     ||	(failure=PT_GRID, lgts[0].stp != NULL &&\
		 !strcmp( pp->pt_inseg->seg_stp->st_name, "GRID" )));\
		pp = pp->pt_forw\
		)\
		{ struct partition *pt_back = pp->pt_back;\
		DEQUEUE_PT( pp );\
		FREE_PT( pp, ap->a_resource );\
		pp = pt_back;\
		}\
	switch( failure )\
		{\
	case PT_EMPTY :\
		return	ap->a_miss( ap );\
	case PT_OHIT :\
		bu_log( "BUG:%s: Bad partition returned by rt_shootray!\n",\
			func );\
		bu_log( "\tlevel=%d grid=<%d,%d>\n",\
			ap->a_level, ap->a_x, ap->a_y );\
		return	ap->a_miss( ap );\
	case PT_BEHIND :\
	case PT_EYE :\
	case PT_GRID :\
		break;\
		}\
	}

STATIC bool hi_Obliq(RGBpixel (*pix));

STATIC fastf_t myIpow(register fastf_t d, register int n);
STATIC fastf_t correct_Lgt(register struct application *ap, register struct partition *pp, register Lgt_Source *lgt_entry);

/* "Hit" application routines to pass to "rt_shootray()". */
STATIC int f_Model(register struct application *ap, struct partition *pt_headp), f_Probe(register struct application *ap, struct partition *pt_headp), f_Shadow(register struct application *ap, struct partition *pt_headp), f_HL_Hit(register struct application *ap, struct partition *pt_headp), f_Region(register struct application *ap, struct partition *pt_headp);
/* "Miss" application routines to pass to "rt_shootray()". */
STATIC int f_Backgr(register struct application *ap), f_Error(register struct application *ap), f_Lit(register struct application *ap), f_HL_Miss(register struct application *ap), f_R_Miss(register struct application *ap);
/* "Overlap" application routines to pass to "rt_shootray()". */
STATIC int f_Overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2), f_NulOverlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2);

STATIC int refract(register fastf_t *v_1, register fastf_t *norml, fastf_t ri_1, fastf_t ri_2, register fastf_t *v_2);

STATIC void hl_Postprocess(void);
STATIC void mirror_Reflect(register struct application *ap, register struct partition *pp, register fastf_t *mirror_coefs, fastf_t *normal);
STATIC void model_Reflectance(register struct application *ap, struct partition *pp, Mat_Db_Entry *mdb_entry, register Lgt_Source *lgt_entry, fastf_t *view_dir, register fastf_t *norml);
STATIC void glass_Refract(register struct application *ap, register struct partition *pp, register Mat_Db_Entry *entry, fastf_t *normal);
STATIC void view_pix(register struct application *ap, RGBpixel (*scanbuf), vect_t (*aliasbuf)), view_bol(register struct application *ap), view_eol(register struct application *ap, RGBpixel (*scanbuf)), view_end(void);

void cons_Vector(register fastf_t *vec, fastf_t azim, fastf_t elev);
void render_Model(int frame);
void render_Scan(int cpu, genptr_t arg);

/*
	void getCellSize( int gsize )
 */
STATIC void
getCellSize(int gsize)
{
	if( save_view_flag )
		{ /* Saved view from GED, match view size. */
		if( rel_perspective != 0.0 )
			/* Animation sequence, perspective gridding. */
			cell_sz = EYE_SIZE / (fastf_t) gsize;
		else
			cell_sz = view_size / (fastf_t) gsize;
		}
	else
		cell_sz = view_size / (fastf_t) gsize;
	return;
	}

/*
	void getCenter( void )

 */
STATIC int
getCenter(void)
{
	switch( type_grid )
		{
	case GT_RPP_CENTERED :
		modl_cntr[X] = (rt_ip->mdl_max[X] + rt_ip->mdl_min[X]) / 2.0;
		modl_cntr[Y] = (rt_ip->mdl_max[Y] + rt_ip->mdl_min[Y]) / 2.0;
		modl_cntr[Z] = (rt_ip->mdl_max[Z] + rt_ip->mdl_min[Z]) / 2.0;
		break;
	case GT_ORG_CENTERED :
		VSETALL( modl_cntr, 0.0 );
		break;
	default :
		bu_log( "Illegal grid type %d\n", type_grid );
		return	false;
		}
	return	true;
	}

/*
	void render_Model( int frame )
 */
void
render_Model(int frame)
{
	(void) signal( SIGINT, abort_sig );
	if( npsw > 1 )
		pix_buffered = B_LINE;

	if( aperture_sz < 1 )
		aperture_sz = 1;
	a_gridsz = anti_aliasing ? grid_sz * aperture_sz : grid_sz;

	if( ir_mapping & IR_OCTREE )
		{
		ag.a_hit = f_IR_Model;
		ag.a_miss = f_IR_Backgr;
		}
	else
	if( query_region )
		{
		ag.a_hit = f_Region;
		ag.a_miss = f_R_Miss;
		ag.a_overlap = report_overlaps ? f_Overlap : f_NulOverlap;
		ag.a_logoverlap =rt_silent_logoverlap; 
		ag.a_onehit = false;
		}
	else
	if( hiddenln_draw )
		{
		if( a_gridsz > MAX_HL_SIZE )
			{
			bu_log( "%s is %dx%d pixels.\n",
				"Max. size for hidden-line images",
				MAX_HL_SIZE, MAX_HL_SIZE );
			return;
			}
		if( (hl_normap = (RGBpixel *)
		       malloc( (unsigned)(a_gridsz*a_gridsz)*sizeof(RGBpixel) ))
			== NULL
			)
			bu_log( "Warning, no memory for normal map.\n" );
		if( (hl_regmap = (short *)
			malloc( (unsigned)(a_gridsz*a_gridsz)*sizeof(short) ))
			== NULL
			)
			bu_log( "Warning, no memory for region map.\n" );
		if( (hl_dstmap = (unsigned short *)
			malloc( (unsigned)
				(a_gridsz*a_gridsz)*sizeof(unsigned short) ))
			== NULL
			)
			bu_log( "Warning, no memory for distance map.\n" );
		ag.a_hit = f_HL_Hit;
		ag.a_miss = f_HL_Miss;
		ag.a_logoverlap =rt_silent_logoverlap; 
		ag.a_overlap = report_overlaps ? f_Overlap : f_NulOverlap;
		ag.a_onehit = true;
		}
	else
		{
		ag.a_hit = f_Model;
		ag.a_miss = f_Backgr;
		ag.a_logoverlap =rt_silent_logoverlap; 
		ag.a_overlap = report_overlaps ? f_Overlap : f_NulOverlap;
		ag.a_onehit = ! (max_bounce > 0);
		}
	ag.a_rt_i = rt_ip;
	ag.a_rbeam = modl_radius / grid_sz;
	ag.a_diverge = 0.0;

	/* Compute center of view. */
	if( ! getCenter() )
		return;

	/* Compute light source positions. */
	if( ! setup_Lgts( frame ) )
		{
		(void) signal( SIGINT, norml_sig );
		return;
		}
	/* Compute grid vectors of magnitude of one cell.
		These will be the delta vectors between adjacent cells.
	 */
	if( force_cellsz )
		a_cellsz = anti_aliasing ? cell_sz / aperture_sz : cell_sz;
	else
		{
		getCellSize( a_gridsz );
		a_cellsz = cell_sz;
		}

	if( RT_G_DEBUG & DEBUG_CELLSIZE )
		bu_log( "Cell size is %g mm.\n", cell_sz );
	Scale2Vec( grid_hor, a_cellsz, grid_dh );
	Scale2Vec( grid_ver, a_cellsz, grid_dv );

	/* Statistics for refraction tuning. */ 
	refrac_missed = 0;
	refrac_inside = 0;
	refrac_total = 0;

	/* Statistics for shadowing. */
	hits_shadowed = 0;
	hits_lit = 0;

	fatal_error = false;

	/* Get starting and ending scan line number. */
	if( grid_x_fin >= fb_getwidth( fbiop ) )
		grid_x_fin = fb_getwidth( fbiop ) - 1;
	if( grid_y_fin >= fb_getheight( fbiop ) )
		grid_y_fin = fb_getheight( fbiop ) - 1;
	curr_scan = grid_y_org;
	last_scan = grid_y_fin;

	if( tty )
		{
		rt_prep_timer();
		(void) sprintf( FRAME_NO_PTR, "%04d", frame_no );
		prnt_Event( "Raytracing..." );
		SCROLL_DL_MOVE();
		(void) fflush( stdout );
		}
	if( ! rt_g.rtg_parallel )
		{
		/*
		 * SERIAL case -- one CPU does all the work.
		 */
		render_Scan(0, NULL);
		view_end();
		(void) signal( SIGINT, norml_sig );
		return;
		}
	/*
	 *  Parallel case.
	 */
	bu_parallel( render_Scan, npsw, NULL );
	view_end();
	(void) signal( SIGINT, norml_sig );
	return;
	}

void
render_Scan(int cpu, genptr_t arg)
{	fastf_t grid_y_inc[3], grid_x_inc[3];
		RGBpixel scanbuf[MAX_SCANSIZE];	/* private to CPU */
		vect_t aliasbuf[MAX_SCANSIZE];	/* private to CPU */
		register int com;
		
	/* Must have local copy of application structure for parallel
		threads of execution, so make copy. */
		struct application a;

	resource[cpu].re_cpu = cpu;
#ifdef RESOURCE_MAGIC
	if( BU_LIST_UNINITIALIZED( &resource[cpu].re_parthead ) )
		rt_init_resource( &resource[cpu], cpu, rt_ip );
#endif

	for( ; ! user_interrupt; )
		{
		bu_semaphore_acquire( RT_SEM_WORKER );
		com = curr_scan++;
		bu_semaphore_release( RT_SEM_WORKER );

		if( com > last_scan )
			break;
		a = ag; /* Eeek, look out for those struct copy bugs. */
		assert( a.a_hit == ag.a_hit );
		assert( a.a_miss == ag.a_miss );
		assert( a.a_overlap == ag.a_overlap );
		assert( a.a_rt_i == ag.a_rt_i );
		assert( a.a_rbeam == ag.a_rbeam );
		assert( a.a_diverge == ag.a_diverge );
		a.a_x = grid_x_org;
		a.a_y = com;
		a.a_onehit = false;
		a.a_resource = &resource[cpu];
		a.a_purpose = "render_Scan";
		if( anti_aliasing )
			{
			a.a_x *= aperture_sz;
			a.a_y *= aperture_sz;
			}
		for(	;
			! user_interrupt
		     &&	a.a_y < (com+1) * aperture_sz;
			view_eol( &a, (RGBpixel *) scanbuf ), a.a_y++
			)
			{
			view_bol( &a );

			/* Compute vectors from center to origin (bottom-left)
				of grid. */
			Scale2Vec( grid_dv, (fastf_t)(-a_gridsz/2)+a.a_y, grid_y_inc );
			Scale2Vec( grid_dh, (fastf_t)(-a_gridsz/2)+a.a_x, grid_x_inc );
			for(	;
				! user_interrupt
			     &&	a.a_x < (grid_x_fin+1) * aperture_sz;
				view_pix( &a, scanbuf, aliasbuf ), a.a_x++
				)
				{	fastf_t aim_pt[3];
				if( rel_perspective == 0.0 )
					{
					/* Parallel rays emanating from grid. */
					Add2Vec( grid_loc, grid_y_inc, aim_pt );
					Add2Vec( aim_pt, grid_x_inc, a.a_ray.r_pt );
					VREVERSE( a.a_ray.r_dir, lgts[0].dir );
					}
				else	
					/* Fire a ray at model from the zeroth
					point light source position lgts[0].loc
					through each grid cell. The closer the
					source is to the grid, the more perspec-
					tive there will be;
					 */
					{
					VMOVE( a.a_ray.r_pt, lgts[0].loc );
					/* Compute ray direction. */
					Add2Vec( grid_loc, grid_y_inc, aim_pt );
					AddVec( aim_pt, grid_x_inc );
					Diff2Vec( aim_pt, lgts[0].loc, a.a_ray.r_dir );
					VUNITIZE( a.a_ray.r_dir );
					}
				a.a_level = 0; /* Recursion level (bounces). */
#ifdef VDEBUG
				bu_log( "r_dir=<%g,%g,%g>\n",
					a.a_ray.r_dir[X],
					a.a_ray.r_dir[Y],
					a.a_ray.r_dir[Z] );
#endif
				if( ir_mapping & IR_OCTREE )
					{
					if( ir_shootray_octree( &a ) == -1 )
						{
						/* Fatal error in application
							routine. */
						bu_log( "Fatal error: %s.\n",
							"raytracing aborted" );
						return;
						}
					}
				else
				if( rt_shootray( &a ) == -1 && fatal_error )
					{
					/* Fatal error in application
						routine. */
					bu_log( "Fatal error: %s.\n",
						"raytracing aborted" );
					return;
					}
				AddVec( grid_x_inc, grid_dh );
				}
			}
		}
	return;
	}

/*ARGSUSED*/
STATIC int
f_R_Miss(register struct application *ap)
{
	prnt_Scroll( "Missed model.\n" );
	return	0;
	}

STATIC int
f_Region(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
		register struct region *regp;
		register struct soltab *stp;
		register struct xray *rp;
		register struct hit *ihitp;
		point_t	normal;
	Get_Partition( ap, pp, pt_headp, "f_Region" );
	regp = pp->pt_regionp;
	stp = pp->pt_inseg->seg_stp;
	rp = &ap->a_ray;
	ihitp = pp->pt_inhit;
	if( ihitp->hit_dist < BEHIND_ME_TOL )
		{ /* We are inside a solid, so slice it. */
		VJOIN1( ihitp->hit_point, rp->r_pt, ihitp->hit_dist,
			rp->r_dir );
		VSCALE( normal, rp->r_dir, -1.0 );
		}
	else
		{
		RT_HIT_NORMAL( normal, ihitp, stp, rp, pp->pt_inflip );
		}
	prnt_Scroll(	"Hit region \"%s\"\n", regp->reg_name );
	prnt_Scroll(	"\timpact point: <%8.2f,%8.2f,%8.2f>\n",
			ihitp->hit_point[X],
			ihitp->hit_point[Y],
			ihitp->hit_point[Z]
			);
	prnt_Scroll(	"\tsurface normal: <%8.2f,%8.2f,%8.2f>\n",
			normal[X],
			normal[Y],
			normal[Z]
			);
	prnt_Scroll(	"\tid: %d, aircode: %d, material: %d, LOS: %d\n",
			regp->reg_regionid,
			regp->reg_aircode,
			regp->reg_gmater,
			regp->reg_los
			);
	if( regp->reg_mater.ma_shader && regp->reg_mater.ma_shader[0] != '\0' )
		{
		prnt_Scroll(	"\tmaterial info \"%s\"\n",
				regp->reg_mater.ma_shader
				);
		if( regp->reg_mater.ma_color_valid )
			prnt_Scroll(	"\t\t\tcolor: {%5.2f,%5.2f,%5.2f}\n",
					regp->reg_mater.ma_color[0],
					regp->reg_mater.ma_color[1],
					regp->reg_mater.ma_color[2]
					);
		}
	return	1;
	}

STATIC int
f_HL_Miss(register struct application *ap)
{
	VSETALL( ap->a_color, 0.0 );
	if( hl_normap != NULL )
		{
		hl_normap[ap->a_y*a_gridsz+ap->a_x][RED] = 0;
		hl_normap[ap->a_y*a_gridsz+ap->a_x][GRN] = 0;
		hl_normap[ap->a_y*a_gridsz+ap->a_x][BLU] = 0;
		}
	if( hl_regmap != NULL )
		hl_regmap[ap->a_y*a_gridsz+ap->a_x] = 0;
	if( hl_dstmap != NULL )
		hl_dstmap[ap->a_y*a_gridsz+ap->a_x] = 0;
	return	0;
	}

STATIC int
f_HL_Hit(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
		register struct soltab *stp;
		register struct hit *ihitp;
		point_t normal;
	Get_Partition( ap, pp, pt_headp, "f_HL_Hit" );
	stp = pp->pt_inseg->seg_stp;
	ihitp = pp->pt_inhit;
	RT_HIT_NORMAL( normal, ihitp, stp, &(ap->a_ray), pp->pt_inflip );
	ap->a_color[RED] = (normal[X] + 1.0) / 2.0;
	ap->a_color[GRN] = (normal[Y] + 1.0) / 2.0;
	ap->a_color[BLU] = (normal[Z] + 1.0) / 2.0;
	if( RT_G_DEBUG )
		{
		V_Print( "normal", normal, bu_log );
		V_Print( "acolor", ap->a_color, bu_log );
		}
	if( hl_normap != NULL )
		{
		hl_normap[ap->a_y*a_gridsz+ap->a_x][RED] =
			ap->a_color[RED] * 255;
		hl_normap[ap->a_y*a_gridsz+ap->a_x][GRN] =
			ap->a_color[GRN] * 255;
		hl_normap[ap->a_y*a_gridsz+ap->a_x][BLU] =
			ap->a_color[BLU] * 255;
		}
	if( hl_regmap != NULL )
		hl_regmap[ap->a_y*a_gridsz+ap->a_x] =
			pp->pt_regionp->reg_regionid;
	if( hl_dstmap != NULL )
		hl_dstmap[ap->a_y*a_gridsz+ap->a_x] =
			(unsigned short) ihitp->hit_dist;
	return	1;
	}

#define MA_WHITESP ", \t"	/* seperators for parameter list */
#define MA_MID	   "mid"
/*
	bool getMaMID( struct mater_info *map, int *id )

	This is a kludge to permit material ids to be assigned to groups
	in 'mged'.  Since the mater_info struct can be inherited down the
	tree, we will use it.  If the string MA_MID=<digits> appears in the
	ma_matparm array, we will assign those digits to the material id
	of this region.
 */
STATIC bool
getMaMID(struct mater_info *map, int *id)
{
		char *copy;
		register char *p;
		int len;
		int i;
		int mid_len;

	if( !map->ma_shader )
		return false;
	if( map->ma_shader && map->ma_shader[0] == '\0' )
		return	false;
	/* copy parameter string to scratch buffer and null terminate */
	copy = bu_strdup( map->ma_shader );

	mid_len = strlen( MA_MID );
	p = copy;
	len = strlen( copy );
	while( *p != '\0' )
	{
		if( strchr( MA_WHITESP, *p ) )
			*p = '\0';
		p++;
	}
	i = 0;
	p = copy;
	while( i < len )
	{
		if( p[i] == '\0' )
			i++;
		else
		{
			if( strncmp( &p[i], MA_MID, mid_len ) )
			{
				while( ++i < len && p[i] != '\0' );
			}
			else
			{
				/* found MA_MID */
				/* find '=' */
				i += (mid_len - 1);
				while( ++i < len && p[i] != '=' );
				if( p[i] != '=' )
				{
					/* cannot find '=' */
					bu_free( (genptr_t)copy, "getMaMID" );
					return  false;
				}

				/* found '=', now get value */
				while( ++i < len && p[i] == '\0' );
				if( p[i] == '\0' )
				{
					/* cannot find value */
					bu_free( (genptr_t)copy, "getMaMID" );
					return  false;
				}

				*id = atoi( &p[i] );
				bu_free( (genptr_t)copy, "getMaMID" );
				return  true;
			}
		}
	}
	bu_free( (genptr_t)copy, "getMaMID" );
	return	false;		

	}


/*
	int f_Model( register struct application *ap,
			struct partition *pt_headp )

	'Hit' application specific routine for 'rt_shootray()' from
	observer or a bounced ray.

 */
STATIC int
f_Model(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
		register Mat_Db_Entry *entry;
		register struct soltab *stp;
		register struct hit *ihitp;
		register struct xray *rp = &ap->a_ray;
		int material_id;
		fastf_t rgb_coefs[3];
		vect_t normal;
	Get_Partition( ap, pp, pt_headp, "f_Model" );
	stp = pp->pt_inseg->seg_stp;
	ihitp = pp->pt_inhit;
	if( ihitp->hit_dist < BEHIND_ME_TOL )
		{ /* We are inside a solid, so slice it. */
		VJOIN1( ihitp->hit_point, rp->r_pt, ihitp->hit_dist,
			rp->r_dir );
		VSCALE( normal, rp->r_dir, -1.0 );
		}
	else
		{
		RT_HIT_NORMAL( normal, ihitp, stp, rp, pp->pt_inflip );
		}

	/* See if we hit a light source. */
	{	register int i;
	for(	i = 1;
		i < lgt_db_size && stp != lgts[i].stp;
		i++
		)
		;
	if( i < lgt_db_size && lgts[i].energy > 0.0 )
		{ /* Maximum light coming from light source. */
		ap->a_color[0] = lgts[i].rgb[0];
		ap->a_color[1] = lgts[i].rgb[1];
		ap->a_color[2] = lgts[i].rgb[2];
		return	1;
		}
	}

	/* Get material id as index into material database. */
	if( ! getMaMID( &pp->pt_regionp->reg_mater, &material_id ) )
		material_id = (int)(pp->pt_regionp->reg_gmater);

	/* Get material database entry. */
	if( ir_mapping )
		{ /* We are mapping temperatures into an octree. */
			Trie *triep;
			Octree *octreep=NULL;
			int fahrenheit;
		if( ! ir_Chk_Table() )
			{
			fatal_error = true;
			return	-1;
			}
		entry = &mat_tmp_entry;
		if( ir_mapping & IR_READONLY )
			{	int ir_level = 0;
			bu_semaphore_acquire( RT_SEM_WORKER );
			octreep = find_Octant(	&ir_octree,
						ihitp->hit_point,
						&ir_level
						);
			bu_semaphore_release( RT_SEM_WORKER );
			}
		else
		if( ir_mapping & IR_EDIT )
			{
			if( ir_offset )
				{	RGBpixel pixel;
					int x = ap->a_x + x_fb_origin - ir_mapx;
					int y = ap->a_y + y_fb_origin - ir_mapy;
				/* Map temperature from IR image using
					offsets. */
				bu_semaphore_acquire( RT_SEM_STATS );
				if(	x < 0 || y < 0
				    ||	fb_read( fbiop, x, y, pixel, 1 ) == -1
					)
					fahrenheit = AMBIENT-1;
				else
					fahrenheit =
					    pixel_To_Temp( (RGBpixel *) pixel );
				bu_semaphore_release( RT_SEM_STATS );
				}
			else
			if( ir_doing_paint )
				/* User specified temp. of current rectangle. */
				fahrenheit = ir_paint;
			else
				/* Unknown temperature, use out-of-band
					value. */
				fahrenheit = AMBIENT-1;
			bu_semaphore_acquire( RT_SEM_WORKER );
			triep = add_Trie( pp->pt_regionp->reg_name,
						&reg_triep );
			octreep = add_Region_Octree(	&ir_octree,
							ihitp->hit_point,
							triep,
							fahrenheit,
							0
							);
			if( octreep != OCTREE_NULL )
				append_Octp( triep, octreep );
			else
			if( fatal_error )
				{
				bu_semaphore_release( RT_SEM_WORKER );
				return	-1;
				}
			bu_semaphore_release( RT_SEM_WORKER );
			}
		if( octreep != OCTREE_NULL )
			{	register int index;
			index = octreep->o_temp - ir_min;
			index = index < 0 ? 0 : index;
			COPYRGB( entry->df_rgb, ir_table[index] );
			}
		}
	else
	/* Get material attributes from database. */
	if(	(entry = mat_Get_Db_Entry( material_id )) == MAT_DB_NULL
	   || ! (entry->mode_flag & MF_USED)
		)
		entry = &mat_dfl_entry;
	/* If texture mapping replace color with texture map look up. */
	if( strncmp( TEX_KEYWORD, entry->name, TEX_KEYLEN ) == 0 )
		{	struct uvcoord uv;
			Mat_Db_Entry loc_entry;
		/* Solid has a frame buffer image map. */
		rt_functab[stp->st_id].ft_uv( ap, stp, ihitp, &uv );
		loc_entry = *entry;
		if( tex_Entry( &uv, &loc_entry ) )
			entry = &loc_entry;
		}
	if( lgts[0].energy < 0.0 )
		{	fastf_t	f = RGB_INVERSE;
			/* Scale RGB values to coeffs (0.0 .. 1.0 ) */
		/* Negative intensity on ambient light is a flag meaning
			do not calculate lighting effects at all, but
			produce a flat, pseudo-color mapping.
		 */
		ap->a_color[0] = entry->df_rgb[0] * f;
		ap->a_color[1] = entry->df_rgb[1] * f;
		ap->a_color[2] = entry->df_rgb[2] * f;
		return	1;
		}

	/* Compute contribution from this surface. */
	{	fastf_t	f;
		register int i;
		auto fastf_t view_dir[3];

	/* Calculate view direction. */
	VREVERSE( view_dir, ap->a_ray.r_dir );

	rgb_coefs[0] = rgb_coefs[1] = rgb_coefs[2] = 0.0;
	if( (f = 1.0 - (entry->reflectivity + entry->transparency)) > 0.0 )
		{
		for( i = 0; i < lgt_db_size; i++ )
			{ /* All light sources. */
			if( lgts[i].energy > 0.0 )
				{
				ap->a_user = i;
				model_Reflectance( ap, pp, entry, &lgts[i],
							view_dir,
							normal
							);
				VJOIN1(	rgb_coefs, rgb_coefs, f, ap->a_color );
				if( RT_G_DEBUG & DEBUG_SHADOW )
					{
					bu_log( "\t\tcontribution from light %d:\n", i );
					V_Print( "\t\treflectance coeffs", ap->a_color, bu_log );
					V_Print( "\t\taccumulated coeffs", rgb_coefs, bu_log );
					}
				}
			}
		}
	}

	/* Recursion is used to do multiple bounces for mirror reflections
		and transparency.  The level of recursion is stored in
		'a_level' and is controlled via the variable 'max_bounce'.
	 */
	if( ap->a_level + 1 <= max_bounce )
		{
		ap->a_user = material_id;
		if( entry->reflectivity > 0.0 )
			{	fastf_t mirror_coefs[3];
			mirror_Reflect( ap, pp, mirror_coefs, normal );

			/* Compute mirror reflection. */
			VJOIN1(	rgb_coefs,
				rgb_coefs,
				entry->reflectivity,
				mirror_coefs
				);
			if( RT_G_DEBUG & DEBUG_RGB )
				{
				V_Print( "mirror", mirror_coefs, bu_log );
				V_Print( "rgb_coefs", rgb_coefs, bu_log );
				}
			}
		if( entry->transparency > 0.0 )
			{
			glass_Refract( ap, pp, entry, normal );
			/* Compute transmission through glass. */
			VJOIN1( rgb_coefs,
				rgb_coefs,
				entry->transparency,
				ap->a_color
				);
			if( RT_G_DEBUG & DEBUG_RGB )
				{
				V_Print( "glass", ap->a_color, bu_log );
				V_Print( "rgb_coefs", rgb_coefs, bu_log );
				}
			}
		}
	/* Pass result in application struct. */
	VMOVE( ap->a_color, rgb_coefs );
	if( RT_G_DEBUG & DEBUG_RGB )
		{
		V_Print( "ap->a_color", ap->a_color, bu_log );
		}
	return	1;
	}

/*
	fastf_t correct_Lgt( register struct application *ap,
				register struct partition *pp,
				register Lgt_Source *lgt_entry )

	Shoot a ray to the light source to determine if surface
	is shadowed, return corrected light source intensity.
 */
STATIC fastf_t
correct_Lgt(register struct application *ap, register struct partition *pp, register Lgt_Source *lgt_entry)
{	fastf_t	energy_attenuation = 1.0;
		fastf_t	lgt_dir[3];
	if( ! shadowing && ! lgt_entry->beam )
		return	lgt_entry->energy;

	/* Vector to light src from surface contact pt. */
	Diff2Vec( lgt_entry->loc, pp->pt_inhit->hit_point, lgt_dir );
	VUNITIZE( lgt_dir );
	if( shadowing )
		{	struct application ap_hit;
		/* Set up appl. struct for 'rt_shootray()' to light src. */
		ap_hit = *ap; /* Watch out for struct copy bugs. */
		assert( ap_hit.a_overlap == ap->a_overlap );
		assert( ap_hit.a_level == ap->a_level );
		ap_hit.a_onehit = false; /* Go all the way to the light. */
		ap_hit.a_hit = f_Shadow; /* Handle shadowed pixels. */
		ap_hit.a_miss = f_Lit;   /* Handle illuminated pixels. */
		ap_hit.a_level++;	 /* Increment recursion level. */
	
		if( RT_G_DEBUG & DEBUG_SHADOW )
			{
			bu_log( "\tcorrect_Lgt()\n" );
			V_Print( "\t\tlgt source location",
				lgt_entry->loc, bu_log );
			}
		/* Set up ray direction to light source. */
		VMOVE( ap_hit.a_ray.r_dir, lgt_dir );

		/* Set up ray origin at surface contact point. */
		VMOVE( ap_hit.a_ray.r_pt, pp->pt_inhit->hit_point );
	
		/* Pass distance to light source to hit routine. */
		ap_hit.a_cumlen =
			Dist3d( pp->pt_inhit->hit_point, lgt_entry->loc );

		if( RT_G_DEBUG & DEBUG_SHADOW )
			{
			V_Print( "\t\tdir. of ray to light",
				ap_hit.a_ray.r_dir, bu_log );
			V_Print( "\t\torigin of ray to lgt",
				ap_hit.a_ray.r_pt, bu_log );
			}
		/* Fetch attenuated lgt intensity into "ap_hit.a_diverge". */
		(void) rt_shootray( &ap_hit );
		energy_attenuation = ap_hit.a_diverge;
		if( energy_attenuation == 0.0 )
			/* Shadowed by opaque object(s). */
			return	energy_attenuation;
		}

	/* Light is either full intensity or attenuated by transparent
		object(s). */
	if( lgt_entry->beam )
		/* Apply gaussian intensity distribution. */
		{	fastf_t lgt_cntr[3];
			fastf_t ang_dist, rel_radius;
			fastf_t	cos_angl;
			fastf_t	gauss_Wgt_Func(fastf_t R);
		if( lgt_entry->stp == SOLTAB_NULL )
			cons_Vector( lgt_cntr, lgt_entry->azim, lgt_entry->elev );
		else
			{
			Diff2Vec( lgt_entry->loc, modl_cntr, lgt_cntr );
			VUNITIZE( lgt_cntr );
			}
		cos_angl = Dot( lgt_cntr, lgt_dir );
		if( NEAR_ZERO( cos_angl, EPSILON ) )
			/* Negligable intensity. */
			return	0.0;
		ang_dist = sqrt( 1.0 - Sqr( cos_angl ) );
		rel_radius = lgt_entry->radius / pp->pt_inhit->hit_dist;
		if( RT_G_DEBUG & DEBUG_RGB )
			{
			bu_log( "\t\tcos. of angle to lgt center = %g\n", cos_angl );
			bu_log( "\t\t	   angular distance = %g\n", ang_dist );
			bu_log( "\t\t	    relative radius = %g\n", rel_radius );
			bu_log( "\t\t	relative distance = %g\n", ang_dist/rel_radius );
			}
		/* Return weighted and attenuated light intensity. */
		return	gauss_Wgt_Func( ang_dist/rel_radius ) *
			lgt_entry->energy * energy_attenuation;
		}
	else	/* Return attenuated light intensity. */
		return	lgt_entry->energy * energy_attenuation;
	}

/*
	void mirror_Reflect( register struct application *ap,
			     register struct partition *pp,
			     register fastf_t *mirror_coefs )	
 */
STATIC void
mirror_Reflect(register struct application *ap, register struct partition *pp, register fastf_t *mirror_coefs, fastf_t *normal)
{	fastf_t r_dir[3];
		struct application ap_hit;
	ap_hit = *ap;		/* Same as initial application. */
	ap_hit.a_onehit = false;
	ap_hit.a_level++;	/* Increment recursion level. */

	if( RT_G_DEBUG & DEBUG_RGB )
		{
		bu_log( "\tmirror_Reflect: level %d grid <%d,%d>\n",
			ap_hit.a_level, ap_hit.a_x, ap_hit.a_y
			);
		bu_log( "\t\tOne hit flag is %s\n",
			ap_hit.a_onehit ? "ON" : "OFF" );
		}
	/* Calculate reflected incident ray. */
	VREVERSE( r_dir, ap->a_ray.r_dir );

	{	fastf_t	f = 2.0	* Dot( r_dir, normal );
		fastf_t tmp_dir[3];
	Scale2Vec( normal, f, tmp_dir );
	Diff2Vec( tmp_dir, r_dir, ap_hit.a_ray.r_dir );
	}
	/* Set up ray origin at surface contact point. */
	VMOVE( ap_hit.a_ray.r_pt, pp->pt_inhit->hit_point );
	(void) rt_shootray( &ap_hit );
	mirror_coefs[RED] = ap_hit.a_color[RED];
	mirror_coefs[GRN] = ap_hit.a_color[GRN];
	mirror_coefs[BLU] = ap_hit.a_color[BLU];
	}

/*
	void glass_Refract( register struct application	*ap,
				register struct partition *pp,
				register Mat_Db_Entry *entry )
 */
STATIC void
glass_Refract(register struct application *ap, register struct partition *pp, register Mat_Db_Entry *entry, fastf_t *normal)
{	struct application ap_hit;	/* To shoot ray beyond. */
		struct application ap_ref;	/* For getting thru. */
	/* Application structure for refracted ray. */
	ap_ref = *ap;
	ap_ref.a_hit =  f_Probe;	/* Find exit from glass. */
	ap_ref.a_miss = f_Error;	/* Bad news. */
	assert( ap_ref.a_overlap == ap->a_overlap );
	ap_ref.a_onehit = true;
	ap_ref.a_level++;		/* Increment recursion level. */

	/* Application structure for exiting ray. */
	ap_hit = *ap;
	ap_hit.a_onehit = false;
	ap_hit.a_level++;

	if( RT_G_DEBUG & DEBUG_REFRACT )
		{
		bu_log( "\tEntering glass_Refract(), level %d grid <%d,%d>\n",
			ap->a_level, ap->a_x, ap->a_y
			);
		V_Print( "\t\tincident ray pnt", ap->a_ray.r_pt, bu_log );
		V_Print( "\t\tincident ray dir", ap->a_ray.r_dir, bu_log );
		}
	refrac_total++;

	/* Guard against zero refractive index. */
	if( entry->refrac_index < 0.001 )
		entry->refrac_index = 1.0;

	if( entry->refrac_index == RI_AIR )
		{ /* No refraction necessary. */
			struct partition *pt_headp = pp->pt_back;
		if( RT_G_DEBUG & DEBUG_REFRACT )
			bu_log( "\t\tNo refraction on entry.\n" );
		/* Ray direction stays the same, and so does ray origin,
			because we are using existing partitions with
			hit distances relative to the ray origin.
		 */
		VMOVE( ap_hit.a_ray.r_dir, ap->a_ray.r_dir );
		VMOVE( ap_hit.a_ray.r_pt, ap->a_ray.r_pt );
		if( pp->pt_forw != pt_headp )
			{
			/* We have more partitions, so use them, but first
				toss out the current one because we must
				always pass the hit routine the head of the
				partition chain, so we can detect the end
				of the circular-doubly-linked list.
			 */
			DEQUEUE_PT( pp );
			FREE_PT( pp, ap->a_resource );
			f_Model( &ap_hit, pt_headp );
			VMOVE( ap->a_color, ap_hit.a_color );
			if( RT_G_DEBUG & DEBUG_REFRACT )
				{
				V_Print( "\t\tf_Model returned coeffs",
					ap->a_color, bu_log );
				}
			return;	
			}
		else
			{
			f_Backgr( &ap_hit );
			VMOVE( ap->a_color, ap_hit.a_color );
			if( RT_G_DEBUG & DEBUG_REFRACT )
				{
				bu_log( "\t\tOne hit flag is %s\n",
					ap->a_onehit ? "ON" : "OFF" );
				V_Print( "\t\tf_Backgr returned coeffs",
					ap->a_color, bu_log );
				}
			return;
			}
		}
	else
		/* Set up ray-trace to find new exit point. */
		{ /* Calculate refraction at entrance. */
		if( pp->pt_inhit->hit_dist < 0.0 )
			{
			if( RT_G_DEBUG & DEBUG_REFRACT )
				bu_log( "\t\tRefracting inside solid.\n" );
			VMOVE( ap_ref.a_ray.r_pt, ap->a_ray.r_pt );
			VMOVE( ap_ref.a_ray.r_dir, ap->a_ray.r_dir );
			goto	inside_ray;
			}
		if( ! refract(	ap->a_ray.r_dir,   /* Incident ray. */
				normal,
				RI_AIR,		   /* Air ref. index. */
				entry->refrac_index,
				ap_ref.a_ray.r_dir /* Refracted ray. */
				)
			)
			{ /* Past critical angle, reflected back out. */
			VMOVE( ap_hit.a_ray.r_pt, pp->pt_inhit->hit_point );
			VMOVE( ap_hit.a_ray.r_dir, ap_ref.a_ray.r_dir );
			if( RT_G_DEBUG & DEBUG_REFRACT )
				bu_log( "\t\tPast critical angle on entry!\n" );
			goto	exiting_ray;
			}
		}
	/* Fire from entry point. */
	VMOVE( ap_ref.a_ray.r_pt, pp->pt_inhit->hit_point );

inside_ray :
	/* Find exit of refracted ray, exit normal (reversed) returned in
		ap_ref.a_uvec, and exit point returned in ap_ref.a_color.
	 */
	if( ! rt_shootray( &ap_ref ) )
		{ /* Refracted ray missed, solid!  This should not occur,
			but if it does we will skip the refraction.
		   */
		if( RT_G_DEBUG & DEBUG_REFRACT )
			{
			bu_log( "\t\tRefracted ray missed:\n" );
			V_Print( "\t\trefracted ray pnt", ap_ref.a_ray.r_pt, bu_log );
			V_Print( "\t\trefracted ray dir", ap_ref.a_ray.r_dir, bu_log );
			}
		refrac_missed++;
		VMOVE( ap_hit.a_ray.r_pt, pp->pt_outhit->hit_point );
		VMOVE( ap_hit.a_ray.r_dir, ap->a_ray.r_dir );
		goto	exiting_ray;
		}
	else
		{
		if( RT_G_DEBUG & DEBUG_REFRACT )
			bu_log( "\t\tRefracted ray hit.\n" );
		}

	/* Calculate refraction at exit. */
	if( ap_ref.a_level <= max_bounce )
		{
		/* Reversed exit normal in a_uvec. */
		if( ! refract(	ap_ref.a_ray.r_dir,
				ap_ref.a_uvec,
				entry->refrac_index,
				RI_AIR,
				ap_hit.a_ray.r_dir
				)
			)
			{ /* Past critical angle, internal reflection. */
			if( RT_G_DEBUG & DEBUG_REFRACT )
				bu_log( "\t\tInternal reflection, recursion level (%d)\n", ap_ref.a_level );
			ap_ref.a_level++;
			VMOVE( ap_ref.a_ray.r_dir, ap_hit.a_ray.r_dir );
			/* Refracted ray exit point in a_color. */
			VMOVE( ap_ref.a_ray.r_pt, ap_ref.a_color );
			goto	inside_ray;
			}
		}
	else
		{ /* Exceeded max bounces, total absorbtion of light. */
		VSETALL( ap->a_color, 0.0 );
		if( RT_G_DEBUG & DEBUG_REFRACT )
			bu_log( "\t\tExceeded max bounces with internal reflections, recursion level (%d)\n", ap_ref.a_level );
		refrac_inside++;
		return;
		}
	/* Refracted ray exit point in a_color. */
	VMOVE( ap_hit.a_ray.r_pt, ap_ref.a_color );

exiting_ray :
	/* Shoot from exit point in direction of refracted ray. */
	if( RT_G_DEBUG & DEBUG_REFRACT )
		{
		bu_log( "\t\tExiting ray from glass.\n" );
		V_Print( "\t\t   ray origin", ap_hit.a_ray.r_pt, bu_log );
		V_Print( "\t\tray direction", ap_hit.a_ray.r_dir, bu_log );
		bu_log( "\t\tOne hit flag is %s\n", ap_hit.a_onehit ? "ON" : "OFF" );
		}
	(void) rt_shootray( &ap_hit );
	VMOVE( ap->a_color, ap_hit.a_color );
	return;
	}

/*
	int f_Backgr( register struct application *ap )

	'Miss' application specific routine for 'rt_shootray()' from
	observer or a bounced ray.
 */
STATIC int
f_Backgr(register struct application *ap)
{	register int i;
	/* Base-line color is same as background. */
	VMOVE( ap->a_color, bg_coefs );

	if( RT_G_DEBUG & DEBUG_RGB )
		{
		bu_log( "\tRay missed model.\n" );
		V_Print( "\tbackground coeffs", ap->a_color, bu_log );
		}

	/* If this is a reflection, we may see each light source. */
	if( ap->a_level )
		{	Mat_Db_Entry *mdb_entry;
		if( (mdb_entry = mat_Get_Db_Entry( ap->a_user ))
			== MAT_DB_NULL
		   || ! (mdb_entry->mode_flag & MF_USED)
			)
			mdb_entry = &mat_dfl_entry;
		for( i = 1; i < lgt_db_size; i++ )
			{	auto fastf_t real_l_1[3];
				register fastf_t specular;
				fastf_t cos_s;
			if( lgts[i].energy <= 0.0 )
				continue;
			Diff2Vec( lgts[i].loc, ap->a_ray.r_pt, real_l_1 );
			VUNITIZE( real_l_1 );
			if(	(cos_s = Dot( ap->a_ray.r_dir, real_l_1 ))
				> 0.0
			    &&	cos_s <= 1.0
				)
				{
				specular = mdb_entry->wgt_specular *
					lgts[i].energy *
					myIpow( cos_s, mdb_entry->shine );
				/* Add reflected light source. */
				VJOIN1(	ap->a_color,
					ap->a_color,
					specular,
					lgts[i].coef );
				}
			}
		}
	if( RT_G_DEBUG & DEBUG_RGB )
		{
		V_Print( "coeffs returned from background", ap->a_color, bu_log );
		}
	return	0;
	}

/*
	int f_Error( register struct application *ap )
 */
/*ARGSUSED*/
STATIC int
f_Error(register struct application *ap)
{
	if( RT_G_DEBUG & DEBUG_RGB )
		bu_log( "f_Error()\n" );
	return	0;
	}

/*
	int f_Lit( register struct application *ap )

	'Miss' application specific routine for 'rt_shootray()' to
	light source for shadowing.  Return full intensity in "ap->a_diverge".
 */
STATIC int
f_Lit(register struct application *ap)
{	
	if( RT_G_DEBUG & DEBUG_SHADOW )
		bu_log( "\t\tSurface is illuminated.\n" );
	ap->a_diverge = 1.0;
	hits_lit++;
	return	0;
	}

/*
	int f_Probe( register struct application *ap,
			struct partition *pt_headp )
*/
STATIC int
f_Probe(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
		register struct hit *hitp;
		register struct soltab *stp;
	if( RT_G_DEBUG & DEBUG_RGB )
		bu_log( "f_Probe()\n" );
	Get_Partition( ap, pp, pt_headp, "f_Probe" );
	stp = pp->pt_outseg->seg_stp;
	hitp = pp->pt_outhit;
	RT_HIT_NORMAL( ap->a_uvec, hitp, stp, &(ap->a_ray), pp->pt_outflip );
	VMOVE( ap->a_color, hitp->hit_point );
	return	1;
	}

/*
	int refract( register fastf_t *v_1, register fastf_t *norml,
			fastf_t ri_1, fastf_t ri_2,
			register fastf_t *v_2 )

	Compute the refracted ray 'v_2' from the incident ray 'v_1' with
	the refractive indices 'ri_2' and 'ri_1' respectively.

	Using Snell's Law

		theta_1 = angle of v_1 with surface normal
		theta_2 = angle of v_2 with reversed surface normal
		ri_1 * sin( theta_1 ) = ri_2 * sin( theta_2 )

		sin( theta_2 ) = ri_1/ri_2 * sin( theta_1 )
		
	The above condition is undefined for ri_1/ri_2 * sin( theta_1 )
	being greater than 1, and this represents the condition for total
	reflection, the 'critical angle' is the angle theta_1 for which
	ri_1/ri_2 * sin( theta_1 ) equals 1.
 */
STATIC int
refract(register fastf_t *v_1, register fastf_t *norml, fastf_t ri_1, fastf_t ri_2, register fastf_t *v_2)
{	fastf_t	w[3], u[3];	/* Intermediate vectors. */
		fastf_t	beta;		/* Intermediate scalar. */
	if( RT_G_DEBUG & DEBUG_REFRACT )
		{
		V_Print( "\tEntering refract(), incident ray", v_1, bu_log );
		V_Print( "\t\tentrance normal", norml, bu_log );
		bu_log( "\t\trefractive indices leaving:%g, entering:%g\n",
			ri_1, ri_2 );
		}
	if( ri_2 < 0.001 || ri_1 < 0.001 )
		{ /* User probably forgot to specify refractive index. */
		bu_log( "\tBUG: Zero or negative refractive index, should have been caught earlier.\n" );
		VMOVE( v_2, v_1 ); /* Just return ray unchanged. */
		return	1;
		}
	beta = ri_1 / ri_2;
	Scale2Vec( v_1, beta, w );	
	CrossProd( w, norml, u );
	/*	|w X norml| = |w||norml| * sin( theta_1 )
		        |u| = ri_1/ri_2 * sin( theta_1 ) = sin( theta_2 )
	 */
	if( (beta = Dot( u, u )) > 1.0 ) /* beta = sin( theta_2 )^^2. */
		{ /* Past critical angle, total reflection.
			Calculate reflected (bounced) incident ray.
		   */
		VREVERSE( u, v_1 );
		beta = 2.0 * Dot( u, norml );
		Scale2Vec( norml, beta, w );
		Diff2Vec( w, u, v_2 );
		if( RT_G_DEBUG & DEBUG_REFRACT )
			{
			V_Print( "\tdeflected refracted ray", v_2, bu_log );
			}
		return	0;
		}
	else
		{
		/* 1 - beta = 1 - sin( theta_2 )^^2
			    = cos( theta_2 )^^2.
		       beta = -1.0 * cos( theta_2 ) - Dot( w, norml ).
		 */
		beta = -sqrt( 1.0 - beta ) - Dot( w, norml );
		Scale2Vec( norml, beta, u );
		Add2Vec( w, u, v_2 );
		if( RT_G_DEBUG & DEBUG_REFRACT )
			{
			V_Print( "\trefracted ray", v_2, bu_log );
			}
		return	1;
		}
	/*NOTREACHED*/
	}

/*
	int f_Shadow( register struct application *ap,
			struct partition *pt_headp )

	'Hit' application specific routine for 'rt_shootray()' to
	light source for shadowing. Returns attenuated light intensity in
	"ap->a_diverge".
 */
STATIC int
f_Shadow(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
		register Mat_Db_Entry *entry;
	Get_Partition( ap, pp, pt_headp, "f_Shadow" );
	if( RT_G_DEBUG & DEBUG_SHADOW )
		{	register struct hit *ihitp, *ohitp;
			register struct soltab *istp;
			point_t inormal;
		bu_log( "Shadowed by :\n" );
		istp = pp->pt_inseg->seg_stp;
		ihitp = pp->pt_inhit;
		ohitp = pp->pt_outhit;
		RT_HIT_NORMAL( inormal, ihitp, istp, &(ap->a_ray), pp->pt_inflip );
		V_Print( "entry normal", inormal, bu_log );
		V_Print( "entry point", ihitp->hit_point, bu_log );
		bu_log( "partition[start %g end %g]\n",
			ihitp->hit_dist, ohitp->hit_dist
			);
		bu_log( "solid name (%s)\n", pp->pt_inseg->seg_stp->st_name );
		}
	ap->a_diverge = 1.0;
	if( pp->pt_inseg->seg_stp == lgts[ap->a_user].stp )
		{ /* Have hit the EXPLICIT light source, no shadow. */
		if( RT_G_DEBUG & DEBUG_SHADOW )
			bu_log( "Unobstructed path to explicit light.\n" );
		return	ap->a_miss( ap );
		}
	for( ; pp != pt_headp; pp = pp->pt_forw )
		{
		if( pp->pt_inseg->seg_stp == lgts[ap->a_user].stp )
			/* Have hit the EXPLICIT light source. */
			break;
		else
		if( pp->pt_inhit->hit_dist > ap->a_cumlen )
			/* Don't look beyond the light source. */
			break;
		if(	(entry =
			mat_Get_Db_Entry( (int)(pp->pt_regionp->reg_gmater) ))
				== MAT_DB_NULL
		   || ! (entry->mode_flag & MF_USED)
			)
			entry = &mat_dfl_entry;
		if( (ap->a_diverge -= 1.0 - entry->transparency) <= 0.0 )
			/* Light is totally eclipsed. */
			{
			ap->a_diverge = 0.0;
			break;
			}
		}
	if( ap->a_diverge != 1.0 )
		/* Light source is obstructed, object shadowed. */
		{
		if( RT_G_DEBUG & DEBUG_SHADOW )
			bu_log( "Lgt source obstructed, object shadowed\n" );
		hits_shadowed++;
		return	1;
		}
	else	/* Full intensity of light source. */
		{
		if( RT_G_DEBUG & DEBUG_SHADOW )
			bu_log( "Full intensity of light source, no shadow\n" );
		return	ap->a_miss( ap );
		}
	}

/*

	void model_Reflectance( register struct application *ap,
				struct partition *pp,
				Mat_Db_Entry *mdb_entry,
				register Lgt_Source *lgt_entry,
				fastf_t *view_dir )

	This is the heart of the lighting model which is based on a model
	developed by Bui-Tuong Phong, [see Wm M. Newman and R. F. Sproull,
	"Principles of Interactive Computer Graphics", 	McGraw-Hill, 1979]
	
	Er = Ra(m)*cos(Ia) + Rd(m)*cos(Il) + W(Il,m)*cos(s)^^n
	where,
 
	Er	is the energy reflected in the observer's direction.
	Ra	is the diffuse reflectance coefficient at the point
		of intersection due to ambient lighting.
	Ia	is the angle of incidence associated with the ambient
		light source (angle between ray direction (negated) and
		surface normal).
	Rd	is the diffuse reflectance coefficient at the point
		of intersection due to lighting.
	Il	is the angle of incidence associated with the
		light source (angle between light source direction and
		surface normal).
	m	is the material identification code.
	W	is the specular reflectance coefficient,
		a function of the angle of incidence, range 0.0 to 1.0,
		for the material.
	s	is the angle between the reflected ray and the observer.
	n	'Shininess' of the material,  range 1 to 10.

	The RGB result is returned implicitly in "ap->a_color".
 */
STATIC void
model_Reflectance(register struct application *ap, struct partition *pp, Mat_Db_Entry *mdb_entry, register Lgt_Source *lgt_entry, fastf_t *view_dir, register fastf_t *norml)
{	/* Compute attenuation of light source intensity. */
		register fastf_t ff;		/* temporary */
		fastf_t lgt_energy;
		fastf_t cos_il; 	/* cosine incident angle */
		auto fastf_t lgt_dir[3];

	if( RT_G_DEBUG & DEBUG_RGB )
		bu_log( "\nmodel_Reflectance(): level %d grid <%d,%d>\n",
			ap->a_level, ap->a_x, ap->a_y
			);

	if( ap->a_user == 0 )		/* Ambient lighting. */
		{
		lgt_energy = lgt_entry->energy;
		VMOVE( lgt_dir, view_dir );
		}
	else
		{	
		/* Compute attenuated light intensity due to shadowing. */
		if( (lgt_energy = correct_Lgt( ap, pp, lgt_entry )) == 0.0 )
			{
			/* Shadowed by an opaque object. */
			VSETALL( ap->a_color, 0.0 );
			return;
			}
		/* Direction unit vector to light source from hit pt. */
		Diff2Vec( lgt_entry->loc, pp->pt_inhit->hit_point, lgt_dir );
		VUNITIZE( lgt_dir );
		}

	/* Calculate diffuse reflectance from light source. */
	if( (cos_il = Dot( norml, lgt_dir )) < 0.0 )
		cos_il = 0.0;
	/* Facter in light source intensity and diffuse weighting. */
	ff = cos_il * lgt_energy * mdb_entry->wgt_diffuse;
	/* Facter in light source color. */
	Scale2Vec( lgt_entry->coef, ff, ap->a_color );
	if( RT_G_DEBUG & DEBUG_RGB )
		{
		bu_log( "\tDiffuse reflectance:\n" );
		V_Print( "\tsurface normal", norml, bu_log );
		V_Print( "\t dir. of light", lgt_dir, bu_log );
		bu_log( "\t cosine of incident angle = %g\n", cos_il );
		bu_log( "\tintensity of light source = %g\n", lgt_energy );
		bu_log( "\t diffuse weighting coeff. = %g\n",
			mdb_entry->wgt_diffuse );
		V_Print( "\tdiffuse coeffs", ap->a_color, bu_log );
		}
	/* Facter in material color (diffuse reflectance coeffs) */
	ff = RGB_INVERSE; /* Scale RGB values to coeffs (0.0 .. 1.0 ) */
	ap->a_color[0] *= mdb_entry->df_rgb[0] * ff;
	ap->a_color[1] *= mdb_entry->df_rgb[1] * ff;
	ap->a_color[2] *= mdb_entry->df_rgb[2] * ff;

	if( ap->a_user != 0 )
		/* Calculate specular reflectance, if not ambient light.
		 	Reflected ray = (2 * cos(i) * Normal) - Incident ray.
		 	Cos(s) = dot product of Reflected ray with Incident ray.
		 */
		{	auto fastf_t lgt_reflect[3], tmp_dir[3];
			register fastf_t specular;
			fastf_t cos_s;
		ff = 2.0 * cos_il;
		Scale2Vec( norml, ff, tmp_dir );
		Diff2Vec( tmp_dir, lgt_dir, lgt_reflect );
		if( RT_G_DEBUG & DEBUG_RGB )
			{
			bu_log( "\tSpecular reflectance:\n" );
			V_Print( "\t           dir of eye", view_dir, bu_log );
			V_Print( "\tdir reflected lgt ray", lgt_reflect, bu_log );
			}
		if(	(cos_s = Dot( view_dir, lgt_reflect )) > 0.0
		    &&	cos_s <= 1.0
			)
			{ /* We have a significant specular component. */
			specular = mdb_entry->wgt_specular * lgt_energy *
					myIpow( cos_s, mdb_entry->shine );
			/* Add specular component. */
			VJOIN1( ap->a_color, ap->a_color, specular, lgt_entry->coef );
			if( RT_G_DEBUG & DEBUG_RGB )
				{
				bu_log( "\tcosine of specular angle = %g\n",
					cos_s );
				bu_log( "\t      specular component = %g\n",
					specular );
				V_Print( "\tdiff+spec coeffs", ap->a_color, bu_log );
				}
			}
		else
		if( cos_s > 1.0 )
			{	struct soltab *stp = pp->pt_inseg->seg_stp;
			bu_log( "\"%s\"(%d) : solid \"%s\" type %d cos(s)=%g grid <%d,%d>!\n",
				__FILE__, __LINE__, stp->st_name, stp->st_id,
				cos_s, ap->a_x, ap->a_y
				);
			V_Print( "Surface normal", norml, bu_log );
			}
		}
	return;
	}

/*
	void cons_Vector( register fastf_t *vec, fastf_t azim, fastf_t elev )

	Construct a direction vector out of azimuth and elevation angles
	in radians, allocating storage for it and returning its address.
 */
void
cons_Vector(register fastf_t *vec, fastf_t azim, fastf_t elev)
{ /* Store cosine of the elevation to save calculating twice. */
		fastf_t	cosE;
	cosE = cos( elev );
	vec[0] = cos( azim ) * cosE;
	vec[1] = sin( azim ) * cosE;
	vec[2] = sin( elev );
	return;
	}

/*
	void abort_RT( int sig )
 */
/*ARGSUSED*/
#if STD_SIGNAL_DECLS
void
#else
int
#endif
abort_RT(int sig)
{
	bu_semaphore_acquire( BU_SEM_SYSCALL );
	(void) signal( SIGINT, abort_RT );
	(void) fb_flush( fbiop );
	user_interrupt = true;
	bu_semaphore_release( BU_SEM_SYSCALL );
#if STD_SIGNAL_DECLS
	return;
#else
	return	sig;
#endif
	}

/*
	fastf_t myIpow( register fastf_t d, register int n )

	Integer exponent pow() function.
	Returns 'd' to the 'n'th power.
 */
STATIC fastf_t
myIpow(register fastf_t d, register int n)
{	register fastf_t result = 1.0;
	if( d == 0.0 )
		return	0.0;
	while( n-- > 0 )
		result *= d;
	return	result;
	}
int
hl_Dst_Diff(register int x0, register int y0, register int x1, register int y1, register short unsigned int maxdist)
{	short distance;
	distance = hl_dstmap[y0*a_gridsz+x0] - hl_dstmap[y1*a_gridsz+x1];
	distance = Abs( distance );
	return (unsigned short)(distance) > maxdist;
	}
int
hl_Reg_Diff(register int x0, register int y0, register int x1, register int y1)
{
	return	hl_regmap[y0*a_gridsz+x0] != hl_regmap[y1*a_gridsz+x1];
	}
int
hl_Norm_Diff(register RGBpixel (*pix1), register RGBpixel (*pix2))
{	fastf_t	dir1[3], dir2[3];
		static fastf_t conv = 2.0/255.0;
	if( ZeroPixel( *pix1 ) )
		{
		if( ZeroPixel( *pix2 ) )
			return	0;
		else
			return	1;
		}
	else
	if( ZeroPixel( *pix2 ) )
		return	1;
	dir1[X] = (*pix1)[RED] * conv;
	dir1[Y] = (*pix1)[GRN] * conv;
	dir1[Z] = (*pix1)[BLU] * conv;
	dir2[X] = (*pix2)[RED] * conv;
	dir2[Y] = (*pix2)[GRN] * conv;
	dir2[Z] = (*pix2)[BLU] * conv;
	dir1[X] -= 1.0;
	dir1[Y] -= 1.0;
	dir1[Z] -= 1.0;
	dir2[X] -= 1.0;
	dir2[Y] -= 1.0;
	dir2[Z] -= 1.0;
	return	Dot( dir1, dir2 ) < COSTOL;
	}


void
prnt_Pixel(register RGBpixel (*pixelp), int x, int y)
{
	bu_log( "Pixel:<%3d,%3d,%3d>(%4d,%4d)\n",
		(*pixelp)[RED],
		(*pixelp)[GRN],
		(*pixelp)[BLU],
		x, y
		);
	return;
	}

STATIC bool
hi_Obliq(RGBpixel (*pix))
{	fastf_t	dir[3];
		static fastf_t conv = 2.0/255.0;
	if( ZeroPixel( *pix ) )
		return false;
	dir[X] = (*pix)[RED] * conv;
	dir[Y] = (*pix)[GRN] * conv;
	dir[Z] = (*pix)[BLU] * conv;
	dir[X] -= 1.0;
	dir[Y] -= 1.0;
	dir[Z] -= 1.0;
	return Dot( dir, lgts[0].dir ) < OBLTOL;
	}

STATIC void
hl_Postprocess(void)
{	register int yc; /* frame buffer space indices */
		register int xi, yi; /* bitmap/array space indices */
		unsigned short maxdist = (cell_sz*ARCTAN_87)+2;
	prnt_Event( "Making hidden-line drawing..." );
	/* Build bitmap from normal, region and distance maps. */
	for(	yi = 0;
		yi < a_gridsz && ! user_interrupt;
		yi++ )
		{
		for(	xi = 0;
			xi < a_gridsz && ! user_interrupt;
			xi++ )
			{
			if( xi == 0 )
				HL_CLRBIT( xi, yi );
			else
			if( yi == 0 )
				if( hl_Norm_Diff( (RGBpixel *)&hl_normap[xi][0],
							(RGBpixel *)&hl_normap[xi-1][0] ) )
					HL_SETBIT( xi, yi );
				else
					HL_CLRBIT( xi, yi );
			else
			if(  (hl_regmap != NULL &&
				(hl_Reg_Diff( xi, yi, xi-1, yi )
			     ||	 hl_Reg_Diff( xi, yi, xi, yi-1 )))
			  ||	hl_Norm_Diff( (RGBpixel *)&hl_normap[yi*a_gridsz+xi][0],
						(RGBpixel *)&hl_normap[yi*a_gridsz+(xi-1)][0] )
			  ||	hl_Norm_Diff( (RGBpixel *)&hl_normap[yi*a_gridsz+xi][0],
						(RGBpixel *)&hl_normap[(yi-1)*a_gridsz+xi][0] )
			  || (	hl_dstmap != NULL
			     && ! hi_Obliq( (RGBpixel *)&hl_normap[yi*a_gridsz+xi][0] )
			     && (hl_Dst_Diff( xi, yi, xi-1, yi, maxdist )
			     ||	 hl_Dst_Diff( xi, yi, xi, yi-1, maxdist )))
				)
				HL_SETBIT( xi, yi );
			else
				HL_CLRBIT( xi, yi );
			}
		}
	/* Translate bitmap to frame buffer image and display it. */
	for(	yi = 0, yc = y_fb_origin;
		yi < grid_sz && ! user_interrupt;
		yi++, yc++ )
		{	static RGBpixel black_pixel = { 0, 0, 0 };
			static RGBpixel white_pixel = { 255, 255, 255 };
			register RGBpixel *bgp = (RGBpixel *)
				(reverse_video ? black_pixel : white_pixel);
			register RGBpixel *fgp = (RGBpixel *)
				(reverse_video ? white_pixel : black_pixel);

		(void) fb_seek( fbiop, x_fb_origin, yc );
		for(	xi = 0;
			xi < grid_sz && ! user_interrupt;
			xi++ )
			{	register bool on = false;
			/* Output pixel based on bitmap value.  If bit is
				ON, pixel should be ON. */
			if( anti_aliasing )
				{ /* NOTE: the 3030 compiler barfs on
				     HL_TSTBIT if we use registers here. */
					register int xa, ya, xn, yn;
				/* Anti-aliasing, map square matrix to pixel.
					If one bit is ON, turn pixel ON. */
				for(	ya = 0, yn = yi*aperture_sz;
					!on && ya < aperture_sz;
					ya++, yn++ )
					for(	xa = 0, xn = xi*aperture_sz;
						!on && xa < aperture_sz;
						xa++, xn++ )
						on = HL_TSTBIT( xn, yn ) != 0;
				}
			else	/* no anti-aliasing */
				on = HL_TSTBIT( xi, yi ) != 0;
			/* Output foreground or background pixel. */
			if( on )
				{
				FB_WPIXEL( fbiop, *fgp );
				}
			else
				{
				FB_WPIXEL( fbiop, *bgp );
				}
			}
		}
	(void) fb_flush( fbiop );
	}

/*
	void view_pix( register struct application *ap,
			RGBpixel scanbuf[], vect_t aliasbuf[] )
 */
STATIC void
view_pix(register struct application *ap, RGBpixel (*scanbuf), vect_t (*aliasbuf))
{	RGBpixel pixel;
		int x;
		int y;
	if( RT_G_DEBUG && tty )
		{
		bu_semaphore_acquire( BU_SEM_SYSCALL );
		(void) sprintf( GRID_PIX_PTR, " [%04d-", ap->a_x/aperture_sz );
		prnt_Timer( (char *) NULL );
		IDLE_MOVE();
		(void) fflush( stdout );
		bu_semaphore_release( BU_SEM_SYSCALL );
		}
	if( hiddenln_draw )
		return;

	if( anti_aliasing )
		{	int xmod = ap->a_x % aperture_sz;
			int ymod = ap->a_y % aperture_sz;
			register vectp_t aliasp;
		/* translate to image coords */
		x = ap->a_x / aperture_sz;
		y = ap->a_y / aperture_sz;

		/* offset into alias buffer */
		aliasp = aliasbuf[x];

		if( xmod == 0 && ymod == 0 )
			{ /* First hit on this pixel. */
			VMOVE( aliasp, ap->a_color );
			return;
			}
		else
			{ /* Add to pixel value. */
			VADD2( aliasp, aliasp, ap->a_color );
			if( xmod == aperture_sz - 1 && ymod == aperture_sz - 1 )
				{
				/* Finish up this pixel. */
				ap->a_color[RED] = aliasp[RED]/sample_sz;
				ap->a_color[GRN] = aliasp[GRN]/sample_sz;
				ap->a_color[BLU] = aliasp[BLU]/sample_sz;
				}
			else
				return;
			}
		}

	/* Translate grid coordinates to frame buffer coords. */
	x = ap->a_x/aperture_sz + x_fb_origin;
	y = ap->a_y/aperture_sz + y_fb_origin;
	/* Image translation can necessitate clipping. */
	if( x < 0 || y < 0 )
		goto failed;

	/* Clip relative intensity on each gun to range 0.0 to 1.0;
		then scale to RGB values. */
	pixel[RED] = ap->a_color[RED] > 1.0 ? 255 :
			(ap->a_color[RED] < 0.0 ? 0 : ap->a_color[RED] * 255);
	pixel[GRN] = ap->a_color[GRN] > 1.0 ? 255 :
			(ap->a_color[GRN] < 0.0 ? 0 : ap->a_color[GRN] * 255);
	pixel[BLU] = ap->a_color[BLU] > 1.0 ? 255 :
			(ap->a_color[BLU] < 0.0 ? 0 : ap->a_color[BLU] * 255);
	/* Write out pixel, depending on buffering scheme. */
	if( query_region )
		return;
	switch( pix_buffered )
		{
	case B_PIO :	/* Programmed I/O to frame buffer (if possible).*/
		/* Image translation can necessitate clipping. */
		if( x >= fb_getwidth( fbiop ) || y >= fb_getheight( fbiop ) )
			goto failed;
		if( fb_write( fbiop, x, y, pixel, 1 ) != -1 )
			return;
		break;
	case B_PAGE :	/* Buffered writes to frame buffer. */
		/* Image translation can necessitate clipping. */
		if( x >= fb_getwidth( fbiop ) || y >= fb_getheight( fbiop ) )
			goto failed;
		if( fb_seek( fbiop, x, y ) != -1 )
			{ /* WARNING: no error checking. */
			FB_WPIXEL( fbiop, pixel );
			return;
			}
		break;
	case B_LINE :	/* Line buffering. */
		/* Image translation can necessitate clipping. */
		if( x >= MAX_SCANSIZE )
			goto failed;
		COPYRGB( scanbuf[x], pixel );
		return;
	default :
		bu_log( "unknown buffering scheme %d\n",
			pix_buffered );
		return;
		}
failed:
#ifdef DEBUG
	bu_log( "Write failed to pixel <%d,%d>.\n", x, y );
#endif
	return;
	}

/*
	void view_bol( register struct application *ap )
 */
STATIC void
view_bol(register struct application *ap)
{	int x = grid_x_org + x_fb_origin;
		int y = ap->a_y/aperture_sz + y_fb_origin;
	if( tracking_cursor )
		{
		bu_semaphore_acquire( RT_SEM_STATS );
		(void) fb_cursor( fbiop, 1, x, y );
		bu_semaphore_release( RT_SEM_STATS );
		}
	if( tty )
		{
		bu_semaphore_acquire( RT_SEM_STATS );
		(void) sprintf( GRID_SCN_PTR, "%04d-", ap->a_y/aperture_sz );
		(void) sprintf( GRID_PIX_PTR, " [%04d-", ap->a_x/aperture_sz );
		update_Screen();
		bu_semaphore_release( RT_SEM_STATS );
		}
	return;
	}

/*
	void view_eol( register struct application *ap, RGBpixel scanbuf[] )
 */
STATIC void
view_eol(register struct application *ap, RGBpixel (*scanbuf))
{	int x = grid_x_org + x_fb_origin;
		int y = ap->a_y/aperture_sz + y_fb_origin;
		int ct = (ap->a_x - grid_x_org)/aperture_sz;
	/* Clip image, necessary due to image translation command. */
	if( y < 0 )
		return;
	if( x < 0 )
		{
		if( (ct += x) <= 0 )
			return;
		x = 0;
		}

	/* Reset horizontal pixel position. */
	ap->a_x = grid_x_org * aperture_sz;

	if( tty )
		{
		bu_semaphore_acquire( RT_SEM_STATS );
		prnt_Timer( (char *) NULL );
		IDLE_MOVE();
		(void) fflush( stdout );
		bu_semaphore_release( RT_SEM_STATS );
		}
	else
		{	char	grid_y[5];
		bu_semaphore_acquire( RT_SEM_STATS );
		(void) sprintf( grid_y, "%04d", ap->a_y/aperture_sz );
		prnt_Timer( grid_y );
		bu_semaphore_release( RT_SEM_STATS );
		}
	if( query_region )
		return;
	if( hiddenln_draw )
		return;
	if( anti_aliasing && ap->a_y % aperture_sz != aperture_sz - 1 )
		return;
	if( pix_buffered == B_LINE )
		{
		bu_semaphore_acquire( RT_SEM_STATS );
		if( strcmp( fb_file, "/dev/remote" ) == 0 )
			{	char ystr[5];
			(void) sprintf( ystr, "%04d", ap->a_y );
			if(	write( 1, ystr, 4 ) != 4
			    ||	write(	1,
					(char *)(scanbuf+x),
					ct*sizeof(RGBpixel)
					) != ct*sizeof(RGBpixel)
				)
				{
				bu_log( "Write of scan line %d failed.\n",
					ap->a_y );
				perror( "write" );
				}
			}
		else
		if( fb_write( fbiop, x, y, (unsigned char *)(scanbuf+x), ct ) == -1 )
			bu_log( "Write of scan line (%d) failed.\n", ap->a_y );
		bu_semaphore_release( RT_SEM_STATS );
		}
	return;
	}

/*
	void view_end( void )
 */
STATIC void
view_end(void)
{
	if( pix_buffered == B_PAGE )
		fb_flush( fbiop );
	if( RT_G_DEBUG & DEBUG_REFRACT )
		bu_log( "%s : hits=%d misses=%d inside=%d total=%d\n",
			"Refraction stats",
			refrac_total-(refrac_missed+refrac_inside),
			refrac_missed, refrac_inside, refrac_total
			);
	if( RT_G_DEBUG & DEBUG_SHADOW )
		bu_log( "Shadowing stats : lit=%d shadowed=%d total=%d\n",
			hits_lit, hits_shadowed, hits_lit+hits_shadowed
			);
	if( hiddenln_draw )
		{
		if( ! user_interrupt )
			hl_Postprocess();
		if( hl_normap != NULL )
			{
			free( (char *) hl_normap );
			hl_normap = NULL;
			}
		if( hl_regmap != NULL )
			{
			free( (char *) hl_regmap );
			hl_regmap = NULL;
			}
		if( hl_dstmap != NULL )
			{
			free( (char *) hl_dstmap );
			hl_dstmap = NULL;
			}
		}
	prnt_Timer( "VIEW" );
	return;
	}

#define	SIGMA	1/(sqrt(2)*1.13794)
/*
	fastf_t gauss_Wgt_Func( fastf_t	R )

	Author: Douglas A. Gwyn
	Gaussian weighting function.

	r = distance from center of beam
	B = beam finite radius (contains 90% of the total energy)

	R = r / B	definition

	I = intensity of beam at desired position
	  =  e^(- R^2 / log10(e)) / (log10(e) * Pi)

	Note that the intensity at the center of the beam is not 1 but
	rather log(10)/Pi.  This is because the intensity is normalized
	so that its integral over the infinite plane is 1.
 */
fastf_t
gauss_Wgt_Func(fastf_t R)
{
	return	exp( - Sqr( R ) / LOG10E ) / (LOG10E * PI);
	}

STATIC int
f_Overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2)
{	point_t	pt;
		fastf_t	depth = pp->pt_outhit->hit_dist-pp->pt_inhit->hit_dist;
	if( depth < OVERLAPTOL )
		return	1;
	VJOIN1( pt, ap->a_ray.r_pt, pp->pt_inhit->hit_dist,
		ap->a_ray.r_dir );
	bu_log( "OVERLAP:\n" );
	bu_log( "reg=%s sol=%s,\n",
		reg1->reg_name, pp->pt_inseg->seg_stp->st_name
		);
	bu_log( "reg=%s sol=%s,\n",
		reg2->reg_name, pp->pt_outseg->seg_stp->st_name
		);
	bu_log( "(x%d y%d lvl%d) depth %gmm at (%g,%g,%g)\n",
		ap->a_x, ap->a_y, ap->a_level,
		depth,
		pt[X], pt[Y], pt[Z]
		);
	return	1;
	}

STATIC int
/*ARGSUSED*/
f_NulOverlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
{
	return	1;
	}
@


11.25
log
@change conf.h to a wrapped config.h
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/reflect.c,v 11.24 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.24
log
@merge of ansi-6-0-branch into HEAD
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d14 5
a18 1
#include "conf.h"
@


11.23
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.21 2001/11/05 21:20:06 morrison Exp $ (BRL)";
d185 1
a185 1
STATIC bool hi_Obliq();
d187 2
a188 2
STATIC fastf_t myIpow();
STATIC fastf_t correct_Lgt();
d191 1
a191 1
STATIC int f_Model(), f_Probe(), f_Shadow(), f_HL_Hit(), f_Region();
d193 1
a193 1
STATIC int f_Backgr(), f_Error(), f_Lit(), f_HL_Miss(), f_R_Miss();
d195 1
a195 1
STATIC int f_Overlap(), f_NulOverlap();
d197 1
a197 1
STATIC int refract();
d199 9
a207 9
STATIC void hl_Postprocess();
STATIC void mirror_Reflect();
STATIC void model_Reflectance();
STATIC void glass_Refract();
STATIC void view_pix(), view_bol(), view_eol(), view_end();

void cons_Vector();
void render_Model();
void render_Scan();
d213 2
a214 3
getCellSize( gsize )
int gsize;
	{
d233 2
a234 2
getCenter()
	{
d256 2
a257 3
render_Model( frame )
int frame;
	{
d397 2
a398 4
render_Scan(cpu, arg)
int cpu;
genptr_t arg;
	{	fastf_t grid_y_inc[3], grid_x_inc[3];
d514 2
a515 3
f_R_Miss( ap )
register struct application *ap;
	{
d521 2
a522 4
f_Region( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d576 2
a577 3
f_HL_Miss( ap )
register struct application *ap;
	{
d593 2
a594 4
f_HL_Hit( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d640 2
a641 4
getMaMID( map, id )
struct mater_info *map;
int *id;
	{
d719 2
a720 4
f_Model( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d954 2
a955 5
correct_Lgt( ap, pp, lgt_entry )
register struct application *ap;
register struct partition *pp;
register Lgt_Source *lgt_entry;
	{	fastf_t	energy_attenuation = 1.0;
d1012 1
a1012 1
			fastf_t	gauss_Wgt_Func();
d1047 2
a1048 6
mirror_Reflect( ap, pp, mirror_coefs, normal )
register struct application *ap;
register struct partition *pp;
register fastf_t *mirror_coefs;
vect_t normal;
	{	fastf_t r_dir[3];
d1084 2
a1085 6
glass_Refract( ap, pp, entry, normal )
register struct application *ap;
register struct partition *pp;
register Mat_Db_Entry *entry;
vect_t normal;
	{	struct application ap_hit;	/* To shoot ray beyond. */
d1265 2
a1266 3
f_Backgr( ap )
register struct application *ap;
	{	register int i;
d1320 2
a1321 3
f_Error( ap )
register struct application *ap;
	{
d1334 2
a1335 3
f_Lit( ap )
register struct application *ap;
	{	
d1348 2
a1349 4
f_Probe( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d1384 2
a1385 5
refract( v_1, norml, ri_1, ri_2, v_2 )
register fastf_t *v_1, *norml;
fastf_t ri_1, ri_2;
register fastf_t *v_2;
	{	fastf_t	w[3], u[3];	/* Intermediate vectors. */
d1447 2
a1448 4
f_Shadow( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d1548 2
a1549 8
model_Reflectance( ap, pp, mdb_entry, lgt_entry, view_dir, norml )
register struct application *ap;
struct partition *pp;
Mat_Db_Entry *mdb_entry;
register Lgt_Source *lgt_entry;
fastf_t *view_dir;
register fastf_t *norml;
	{	/* Compute attenuation of light source intensity. */
d1657 2
a1658 4
cons_Vector( vec, azim, elev )
register fastf_t *vec;
fastf_t	azim, elev;
	{ /* Store cosine of the elevation to save calculating twice. */
d1676 2
a1677 3
abort_RT( sig )
int sig;
	{
d1697 2
a1698 4
myIpow( d, n )
register fastf_t d;
register int n;
	{	register fastf_t result = 1.0;
d1706 2
a1707 4
hl_Dst_Diff( x0, y0, x1, y1, maxdist )
register int x0, y0, x1, y1;
register unsigned short	maxdist;
	{	short distance;
d1713 2
a1714 3
hl_Reg_Diff( x0, y0, x1, y1 )
register int x0, y0, x1, y1;
	{
d1718 2
a1719 3
hl_Norm_Diff( pix1, pix2 )
register RGBpixel *pix1, *pix2;
	{	fastf_t	dir1[3], dir2[3];
d1748 2
a1749 4
prnt_Pixel( pixelp, x, y )
register RGBpixel *pixelp;
int x, y;
	{
d1760 2
a1761 3
hi_Obliq( pix )
RGBpixel *pix;
	{	fastf_t	dir[3];
d1775 2
a1776 2
hl_Postprocess()
	{	register int yc; /* frame buffer space indices */
d1869 2
a1870 5
view_pix( ap, scanbuf, aliasbuf )
register struct application *ap;
RGBpixel scanbuf[];
vect_t aliasbuf[];
	{	RGBpixel pixel;
d1975 2
a1976 3
view_bol( ap )
register struct application	*ap;
	{	int x = grid_x_org + x_fb_origin;
d1999 2
a2000 4
view_eol( ap, scanbuf )
register struct application *ap;
RGBpixel scanbuf[];
	{	int x = grid_x_org + x_fb_origin;
d2067 2
a2068 2
view_end()
	{
d2125 2
a2126 3
gauss_Wgt_Func( R )
fastf_t	R;
	{
d2131 2
a2132 5
f_Overlap( ap, pp, reg1, reg2 )
register struct application *ap;
register struct partition *pp;
struct region *reg1, *reg2;
	{	point_t	pt;
d2155 2
a2156 5
f_NulOverlap( ap, pp, reg1, reg2 )
struct application *ap;
struct partition *pp;
struct region *reg1, *reg2;
	{
@


11.23.2.1
log
@Initial ANSIfication
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.23 2002/08/20 17:07:34 jra Exp $ (BRL)";
d185 1
a185 1
STATIC bool hi_Obliq(RGBpixel (*pix));
d187 2
a188 2
STATIC fastf_t myIpow(register fastf_t d, register int n);
STATIC fastf_t correct_Lgt(register struct application *ap, register struct partition *pp, register Lgt_Source *lgt_entry);
d191 1
a191 1
STATIC int f_Model(register struct application *ap, struct partition *pt_headp), f_Probe(register struct application *ap, struct partition *pt_headp), f_Shadow(register struct application *ap, struct partition *pt_headp), f_HL_Hit(register struct application *ap, struct partition *pt_headp), f_Region(register struct application *ap, struct partition *pt_headp);
d193 1
a193 1
STATIC int f_Backgr(register struct application *ap), f_Error(register struct application *ap), f_Lit(register struct application *ap), f_HL_Miss(register struct application *ap), f_R_Miss(register struct application *ap);
d195 1
a195 1
STATIC int f_Overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2), f_NulOverlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2);
d197 1
a197 1
STATIC int refract(register fastf_t *v_1, register fastf_t *norml, fastf_t ri_1, fastf_t ri_2, register fastf_t *v_2);
d199 9
a207 9
STATIC void hl_Postprocess(void);
STATIC void mirror_Reflect(register struct application *ap, register struct partition *pp, register fastf_t *mirror_coefs, fastf_t *normal);
STATIC void model_Reflectance(register struct application *ap, struct partition *pp, Mat_Db_Entry *mdb_entry, register Lgt_Source *lgt_entry, fastf_t *view_dir, register fastf_t *norml);
STATIC void glass_Refract(register struct application *ap, register struct partition *pp, register Mat_Db_Entry *entry, fastf_t *normal);
STATIC void view_pix(register struct application *ap, RGBpixel (*scanbuf), vect_t (*aliasbuf)), view_bol(register struct application *ap), view_eol(register struct application *ap, RGBpixel (*scanbuf)), view_end(void);

void cons_Vector(register fastf_t *vec, fastf_t azim, fastf_t elev);
void render_Model(int frame);
void render_Scan(int cpu, genptr_t arg);
d213 3
a215 2
getCellSize(int gsize)
{
d234 2
a235 2
getCenter(void)
{
d257 3
a259 2
render_Model(int frame)
{
d399 4
a402 2
render_Scan(int cpu, genptr_t arg)
{	fastf_t grid_y_inc[3], grid_x_inc[3];
d518 3
a520 2
f_R_Miss(register struct application *ap)
{
d526 4
a529 2
f_Region(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d583 3
a585 2
f_HL_Miss(register struct application *ap)
{
d601 4
a604 2
f_HL_Hit(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d650 4
a653 2
getMaMID(struct mater_info *map, int *id)
{
d731 4
a734 2
f_Model(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d968 5
a972 2
correct_Lgt(register struct application *ap, register struct partition *pp, register Lgt_Source *lgt_entry)
{	fastf_t	energy_attenuation = 1.0;
d1029 1
a1029 1
			fastf_t	gauss_Wgt_Func(fastf_t R);
d1064 6
a1069 2
mirror_Reflect(register struct application *ap, register struct partition *pp, register fastf_t *mirror_coefs, fastf_t *normal)
{	fastf_t r_dir[3];
d1105 6
a1110 2
glass_Refract(register struct application *ap, register struct partition *pp, register Mat_Db_Entry *entry, fastf_t *normal)
{	struct application ap_hit;	/* To shoot ray beyond. */
d1290 3
a1292 2
f_Backgr(register struct application *ap)
{	register int i;
d1346 3
a1348 2
f_Error(register struct application *ap)
{
d1361 3
a1363 2
f_Lit(register struct application *ap)
{	
d1376 4
a1379 2
f_Probe(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d1414 5
a1418 2
refract(register fastf_t *v_1, register fastf_t *norml, fastf_t ri_1, fastf_t ri_2, register fastf_t *v_2)
{	fastf_t	w[3], u[3];	/* Intermediate vectors. */
d1480 4
a1483 2
f_Shadow(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d1583 8
a1590 2
model_Reflectance(register struct application *ap, struct partition *pp, Mat_Db_Entry *mdb_entry, register Lgt_Source *lgt_entry, fastf_t *view_dir, register fastf_t *norml)
{	/* Compute attenuation of light source intensity. */
d1698 4
a1701 2
cons_Vector(register fastf_t *vec, fastf_t azim, fastf_t elev)
{ /* Store cosine of the elevation to save calculating twice. */
d1719 3
a1721 2
abort_RT(int sig)
{
d1741 4
a1744 2
myIpow(register fastf_t d, register int n)
{	register fastf_t result = 1.0;
d1752 4
a1755 2
hl_Dst_Diff(register int x0, register int y0, register int x1, register int y1, register short unsigned int maxdist)
{	short distance;
d1761 3
a1763 2
hl_Reg_Diff(register int x0, register int y0, register int x1, register int y1)
{
d1767 3
a1769 2
hl_Norm_Diff(register RGBpixel (*pix1), register RGBpixel (*pix2))
{	fastf_t	dir1[3], dir2[3];
d1798 4
a1801 2
prnt_Pixel(register RGBpixel (*pixelp), int x, int y)
{
d1812 3
a1814 2
hi_Obliq(RGBpixel (*pix))
{	fastf_t	dir[3];
d1828 2
a1829 2
hl_Postprocess(void)
{	register int yc; /* frame buffer space indices */
d1922 5
a1926 2
view_pix(register struct application *ap, RGBpixel (*scanbuf), vect_t (*aliasbuf))
{	RGBpixel pixel;
d2031 3
a2033 2
view_bol(register struct application *ap)
{	int x = grid_x_org + x_fb_origin;
d2056 4
a2059 2
view_eol(register struct application *ap, RGBpixel (*scanbuf))
{	int x = grid_x_org + x_fb_origin;
d2126 2
a2127 2
view_end(void)
{
d2184 3
a2186 2
gauss_Wgt_Func(fastf_t R)
{
d2191 5
a2195 2
f_Overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2)
{	point_t	pt;
d2218 5
a2222 2
f_NulOverlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
{
@


11.22
log
@Converted from K&R to ANSI C - RFH
@
text
@d185 1
a185 1
STATIC bool hi_Obliq(RGBpixel (*pix));
d187 2
a188 2
STATIC fastf_t myIpow(register fastf_t d, register int n);
STATIC fastf_t correct_Lgt(register struct application *ap, register struct partition *pp, register Lgt_Source *lgt_entry);
d191 1
a191 1
STATIC int f_Model(register struct application *ap, struct partition *pt_headp), f_Probe(register struct application *ap, struct partition *pt_headp), f_Shadow(register struct application *ap, struct partition *pt_headp), f_HL_Hit(register struct application *ap, struct partition *pt_headp), f_Region(register struct application *ap, struct partition *pt_headp);
d193 1
a193 1
STATIC int f_Backgr(register struct application *ap), f_Error(register struct application *ap), f_Lit(register struct application *ap), f_HL_Miss(register struct application *ap), f_R_Miss(register struct application *ap);
d195 1
a195 1
STATIC int f_Overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2), f_NulOverlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2);
d197 1
a197 1
STATIC int refract(register fastf_t *v_1, register fastf_t *norml, fastf_t ri_1, fastf_t ri_2, register fastf_t *v_2);
d199 9
a207 9
STATIC void hl_Postprocess(void);
STATIC void mirror_Reflect(register struct application *ap, register struct partition *pp, register fastf_t *mirror_coefs, fastf_t *normal);
STATIC void model_Reflectance(register struct application *ap, struct partition *pp, Mat_Db_Entry *mdb_entry, register Lgt_Source *lgt_entry, fastf_t *view_dir, register fastf_t *norml);
STATIC void glass_Refract(register struct application *ap, register struct partition *pp, register Mat_Db_Entry *entry, fastf_t *normal);
STATIC void view_pix(register struct application *ap, RGBpixel (*scanbuf), vect_t (*aliasbuf)), view_bol(register struct application *ap), view_eol(register struct application *ap, RGBpixel (*scanbuf)), view_end(void);

void cons_Vector(register fastf_t *vec, fastf_t azim, fastf_t elev);
void render_Model(int frame);
void render_Scan(int cpu, genptr_t arg);
d213 3
a215 2
getCellSize(int gsize)
{
d234 2
a235 2
getCenter(void)
{
d257 3
a259 2
render_Model(int frame)
{
d399 4
a402 2
render_Scan(int cpu, genptr_t arg)
{	fastf_t grid_y_inc[3], grid_x_inc[3];
d518 3
a520 2
f_R_Miss(register struct application *ap)
{
d526 4
a529 2
f_Region(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d583 3
a585 2
f_HL_Miss(register struct application *ap)
{
d601 4
a604 2
f_HL_Hit(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d650 4
a653 2
getMaMID(struct mater_info *map, int *id)
{
d731 4
a734 2
f_Model(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d968 5
a972 2
correct_Lgt(register struct application *ap, register struct partition *pp, register Lgt_Source *lgt_entry)
{	fastf_t	energy_attenuation = 1.0;
d1029 1
a1029 1
			fastf_t	gauss_Wgt_Func(fastf_t R);
d1064 6
a1069 2
mirror_Reflect(register struct application *ap, register struct partition *pp, register fastf_t *mirror_coefs, fastf_t *normal)
{	fastf_t r_dir[3];
d1105 6
a1110 2
glass_Refract(register struct application *ap, register struct partition *pp, register Mat_Db_Entry *entry, fastf_t *normal)
{	struct application ap_hit;	/* To shoot ray beyond. */
d1290 3
a1292 2
f_Backgr(register struct application *ap)
{	register int i;
d1346 3
a1348 2
f_Error(register struct application *ap)
{
d1361 3
a1363 2
f_Lit(register struct application *ap)
{	
d1376 4
a1379 2
f_Probe(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d1414 5
a1418 2
refract(register fastf_t *v_1, register fastf_t *norml, fastf_t ri_1, fastf_t ri_2, register fastf_t *v_2)
{	fastf_t	w[3], u[3];	/* Intermediate vectors. */
d1480 4
a1483 2
f_Shadow(register struct application *ap, struct partition *pt_headp)
{	register struct partition *pp;
d1583 8
a1590 2
model_Reflectance(register struct application *ap, struct partition *pp, Mat_Db_Entry *mdb_entry, register Lgt_Source *lgt_entry, fastf_t *view_dir, register fastf_t *norml)
{	/* Compute attenuation of light source intensity. */
d1698 4
a1701 2
cons_Vector(register fastf_t *vec, fastf_t azim, fastf_t elev)
{ /* Store cosine of the elevation to save calculating twice. */
d1719 3
a1721 2
abort_RT(int sig)
{
d1741 4
a1744 2
myIpow(register fastf_t d, register int n)
{	register fastf_t result = 1.0;
d1752 4
a1755 2
hl_Dst_Diff(register int x0, register int y0, register int x1, register int y1, register short unsigned int maxdist)
{	short distance;
d1761 3
a1763 2
hl_Reg_Diff(register int x0, register int y0, register int x1, register int y1)
{
d1767 3
a1769 2
hl_Norm_Diff(register RGBpixel (*pix1), register RGBpixel (*pix2))
{	fastf_t	dir1[3], dir2[3];
d1798 4
a1801 2
prnt_Pixel(register RGBpixel (*pixelp), int x, int y)
{
d1812 3
a1814 2
hi_Obliq(RGBpixel (*pix))
{	fastf_t	dir[3];
d1828 2
a1829 2
hl_Postprocess(void)
{	register int yc; /* frame buffer space indices */
d1922 5
a1926 2
view_pix(register struct application *ap, RGBpixel (*scanbuf), vect_t (*aliasbuf))
{	RGBpixel pixel;
d2031 3
a2033 2
view_bol(register struct application *ap)
{	int x = grid_x_org + x_fb_origin;
d2056 4
a2059 2
view_eol(register struct application *ap, RGBpixel (*scanbuf))
{	int x = grid_x_org + x_fb_origin;
d2126 2
a2127 2
view_end(void)
{
d2184 3
a2186 2
gauss_Wgt_Func(fastf_t R)
{
d2191 5
a2195 2
f_Overlap(register struct application *ap, register struct partition *pp, struct region *reg1, struct region *reg2)
{	point_t	pt;
d2218 5
a2222 2
f_NulOverlap(struct application *ap, struct partition *pp, struct region *reg1, struct region *reg2)
{
@


11.21
log
@Solid to Primitive naming convention conversions
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.20 2001/08/10 02:36:24 jra Exp $ (BRL)";
d185 1
a185 1
STATIC bool hi_Obliq();
d187 2
a188 2
STATIC fastf_t myIpow();
STATIC fastf_t correct_Lgt();
d191 1
a191 1
STATIC int f_Model(), f_Probe(), f_Shadow(), f_HL_Hit(), f_Region();
d193 1
a193 1
STATIC int f_Backgr(), f_Error(), f_Lit(), f_HL_Miss(), f_R_Miss();
d195 1
a195 1
STATIC int f_Overlap(), f_NulOverlap();
d197 1
a197 1
STATIC int refract();
d199 9
a207 9
STATIC void hl_Postprocess();
STATIC void mirror_Reflect();
STATIC void model_Reflectance();
STATIC void glass_Refract();
STATIC void view_pix(), view_bol(), view_eol(), view_end();

void cons_Vector();
void render_Model();
void render_Scan();
d213 2
a214 3
getCellSize( gsize )
int gsize;
	{
d233 2
a234 2
getCenter()
	{
d256 2
a257 3
render_Model( frame )
int frame;
	{
d397 2
a398 4
render_Scan(cpu, arg)
int cpu;
genptr_t arg;
	{	fastf_t grid_y_inc[3], grid_x_inc[3];
d514 2
a515 3
f_R_Miss( ap )
register struct application *ap;
	{
d521 2
a522 4
f_Region( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d576 2
a577 3
f_HL_Miss( ap )
register struct application *ap;
	{
d593 2
a594 4
f_HL_Hit( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d640 2
a641 4
getMaMID( map, id )
struct mater_info *map;
int *id;
	{
d719 2
a720 4
f_Model( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d954 2
a955 5
correct_Lgt( ap, pp, lgt_entry )
register struct application *ap;
register struct partition *pp;
register Lgt_Source *lgt_entry;
	{	fastf_t	energy_attenuation = 1.0;
d1012 1
a1012 1
			fastf_t	gauss_Wgt_Func();
d1047 2
a1048 6
mirror_Reflect( ap, pp, mirror_coefs, normal )
register struct application *ap;
register struct partition *pp;
register fastf_t *mirror_coefs;
vect_t normal;
	{	fastf_t r_dir[3];
d1084 2
a1085 6
glass_Refract( ap, pp, entry, normal )
register struct application *ap;
register struct partition *pp;
register Mat_Db_Entry *entry;
vect_t normal;
	{	struct application ap_hit;	/* To shoot ray beyond. */
d1265 2
a1266 3
f_Backgr( ap )
register struct application *ap;
	{	register int i;
d1320 2
a1321 3
f_Error( ap )
register struct application *ap;
	{
d1334 2
a1335 3
f_Lit( ap )
register struct application *ap;
	{	
d1348 2
a1349 4
f_Probe( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d1384 2
a1385 5
refract( v_1, norml, ri_1, ri_2, v_2 )
register fastf_t *v_1, *norml;
fastf_t ri_1, ri_2;
register fastf_t *v_2;
	{	fastf_t	w[3], u[3];	/* Intermediate vectors. */
d1447 2
a1448 4
f_Shadow( ap, pt_headp )
register struct application *ap;
struct partition *pt_headp;
	{	register struct partition *pp;
d1548 2
a1549 8
model_Reflectance( ap, pp, mdb_entry, lgt_entry, view_dir, norml )
register struct application *ap;
struct partition *pp;
Mat_Db_Entry *mdb_entry;
register Lgt_Source *lgt_entry;
fastf_t *view_dir;
register fastf_t *norml;
	{	/* Compute attenuation of light source intensity. */
d1657 2
a1658 4
cons_Vector( vec, azim, elev )
register fastf_t *vec;
fastf_t	azim, elev;
	{ /* Store cosine of the elevation to save calculating twice. */
d1676 2
a1677 3
abort_RT( sig )
int sig;
	{
d1697 2
a1698 4
myIpow( d, n )
register fastf_t d;
register int n;
	{	register fastf_t result = 1.0;
d1706 2
a1707 4
hl_Dst_Diff( x0, y0, x1, y1, maxdist )
register int x0, y0, x1, y1;
register unsigned short	maxdist;
	{	short distance;
d1713 2
a1714 3
hl_Reg_Diff( x0, y0, x1, y1 )
register int x0, y0, x1, y1;
	{
d1718 2
a1719 3
hl_Norm_Diff( pix1, pix2 )
register RGBpixel *pix1, *pix2;
	{	fastf_t	dir1[3], dir2[3];
d1748 2
a1749 4
prnt_Pixel( pixelp, x, y )
register RGBpixel *pixelp;
int x, y;
	{
d1760 2
a1761 3
hi_Obliq( pix )
RGBpixel *pix;
	{	fastf_t	dir[3];
d1775 2
a1776 2
hl_Postprocess()
	{	register int yc; /* frame buffer space indices */
d1869 2
a1870 5
view_pix( ap, scanbuf, aliasbuf )
register struct application *ap;
RGBpixel scanbuf[];
vect_t aliasbuf[];
	{	RGBpixel pixel;
d1975 2
a1976 3
view_bol( ap )
register struct application	*ap;
	{	int x = grid_x_org + x_fb_origin;
d1999 2
a2000 4
view_eol( ap, scanbuf )
register struct application *ap;
RGBpixel scanbuf[];
	{	int x = grid_x_org + x_fb_origin;
d2067 2
a2068 2
view_end()
	{
d2125 2
a2126 3
gauss_Wgt_Func( R )
fastf_t	R;
	{
d2131 2
a2132 5
f_Overlap( ap, pp, reg1, reg2 )
register struct application *ap;
register struct partition *pp;
struct region *reg1, *reg2;
	{	point_t	pt;
d2155 2
a2156 5
f_NulOverlap( ap, pp, reg1, reg2 )
struct application *ap;
struct partition *pp;
struct region *reg1, *reg2;
	{
@


11.20
log
@added call to "rt_init_resource"
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.19 2001/08/09 16:42:52 jra Exp $ (BRL)";
d61 1
a61 1
			bu_log( "Solid type %d\n", _stp->st_id );\
d79 1
a79 1
			bu_log( "Solid type %d\n", _stp->st_id );\
@


11.19
log
@lint
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.18 2001/05/17 20:05:16 morrison Exp $ (BRL)";
d413 2
a414 1
	resource[cpu].re_magic = RESOURCE_MAGIC;
@


11.18
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.17 2001/03/26 20:53:25 jra Exp $ (BRL)";
d98 1
a98 1
				255, 255, 255,	/* Diffuse RGB values. */
d779 1
a779 1
			Octree *octreep;
d1750 1
a1750 1

d1759 1
a1759 1

d1765 1
a1765 1

@


11.17
log
@Needed a_logoverlap set to the silent overlap logger
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.16 2000/08/24 22:55:52 mike Exp $ (BRL)";
d57 1
a57 1
		if( ! _pp->pt_inflip && (rt_g.debug&DEBUG_NORML) )\
d75 1
a75 1
		if( ! _pp->pt_outflip && (rt_g.debug&DEBUG_NORML) )\
d347 1
a347 1
	if( rt_g.debug & DEBUG_CELLSIZE )
d614 1
a614 1
	if( rt_g.debug )
d899 1
a899 1
				if( rt_g.debug & DEBUG_SHADOW )
d927 1
a927 1
			if( rt_g.debug & DEBUG_RGB )
d942 1
a942 1
			if( rt_g.debug & DEBUG_RGB )
d951 1
a951 1
	if( rt_g.debug & DEBUG_RGB )
d990 1
a990 1
		if( rt_g.debug & DEBUG_SHADOW )
d1006 1
a1006 1
		if( rt_g.debug & DEBUG_SHADOW )
d1042 1
a1042 1
		if( rt_g.debug & DEBUG_RGB )
d1074 1
a1074 1
	if( rt_g.debug & DEBUG_RGB )
d1124 1
a1124 1
	if( rt_g.debug & DEBUG_REFRACT )
d1141 1
a1141 1
		if( rt_g.debug & DEBUG_REFRACT )
d1161 1
a1161 1
			if( rt_g.debug & DEBUG_REFRACT )
d1172 1
a1172 1
			if( rt_g.debug & DEBUG_REFRACT )
d1187 1
a1187 1
			if( rt_g.debug & DEBUG_REFRACT )
d1203 1
a1203 1
			if( rt_g.debug & DEBUG_REFRACT )
d1219 1
a1219 1
		if( rt_g.debug & DEBUG_REFRACT )
d1232 1
a1232 1
		if( rt_g.debug & DEBUG_REFRACT )
d1248 1
a1248 1
			if( rt_g.debug & DEBUG_REFRACT )
d1260 1
a1260 1
		if( rt_g.debug & DEBUG_REFRACT )
d1270 1
a1270 1
	if( rt_g.debug & DEBUG_REFRACT )
d1295 1
a1295 1
	if( rt_g.debug & DEBUG_RGB )
d1333 1
a1333 1
	if( rt_g.debug & DEBUG_RGB )
d1348 1
a1348 1
	if( rt_g.debug & DEBUG_RGB )
d1363 1
a1363 1
	if( rt_g.debug & DEBUG_SHADOW )
d1381 1
a1381 1
	if( rt_g.debug & DEBUG_RGB )
d1419 1
a1419 1
	if( rt_g.debug & DEBUG_REFRACT )
d1446 1
a1446 1
		if( rt_g.debug & DEBUG_REFRACT )
d1461 1
a1461 1
		if( rt_g.debug & DEBUG_REFRACT )
d1485 1
a1485 1
	if( rt_g.debug & DEBUG_SHADOW )
d1504 1
a1504 1
		if( rt_g.debug & DEBUG_SHADOW )
d1533 1
a1533 1
		if( rt_g.debug & DEBUG_SHADOW )
d1540 1
a1540 1
		if( rt_g.debug & DEBUG_SHADOW )
d1595 1
a1595 1
	if( rt_g.debug & DEBUG_RGB )
d1626 1
a1626 1
	if( rt_g.debug & DEBUG_RGB )
d1654 1
a1654 1
		if( rt_g.debug & DEBUG_RGB )
d1668 1
a1668 1
			if( rt_g.debug & DEBUG_RGB )
d1928 1
a1928 1
	if( rt_g.debug && tty )
d2129 1
a2129 1
	if( rt_g.debug & DEBUG_REFRACT )
d2135 1
a2135 1
	if( rt_g.debug & DEBUG_SHADOW )
@


11.16
log
@
RCSid
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.15 2000/01/31 16:06:37 jra Exp $ (BRL)";
d279 1
d310 1
d318 1
@


11.15
log
@Eliminated some unused variables
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.14 1999/12/23 05:27:26 mike Exp $ (BRL)";
@


11.15.2.1
log
@Needed a_logoverlap set to the silent overlap logger.
@
text
@d11 1
a11 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.17 2001/03/26 20:53:25 jra Exp $ (BRL)";
a278 1
		ag.a_logoverlap =rt_silent_logoverlap; 
a308 1
		ag.a_logoverlap =rt_silent_logoverlap; 
a315 1
		ag.a_logoverlap =rt_silent_logoverlap; 
@


11.14
log
@
Dead variable
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.13 1999/06/03 21:40:51 mike Exp $ (BRL)";
d259 1
a259 1
	{	int x;
a650 2
		char *name;
		char *value;
@


11.13
log
@
sed4
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.12 1999/05/10 21:45:16 mike Exp $ (BRL)";
d1486 1
a1486 1
			register struct soltab *istp, *ostp;
a1490 1
		ostp = pp->pt_outseg->seg_stp;
@


11.12
log
@ma_override to ma_color_valid
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/reflect.c,v 11.11 1998/04/15 05:24:19 mike Exp $ (BRL)";
d60 2
a61 2
				_normal, rt_log );\
			rt_log( "Solid type %d\n", _stp->st_id );\
d78 2
a79 2
				_normal, rt_log );\
			rt_log( "Solid type %d\n", _stp->st_id );\
d173 1
a173 1
		rt_log( "BUG:%s: Bad partition returned by rt_shootray!\n",\
d175 1
a175 1
		rt_log( "\tlevel=%d grid=<%d,%d>\n",\
d247 1
a247 1
		rt_log( "Illegal grid type %d\n", type_grid );
d286 1
a286 1
			rt_log( "%s is %dx%d pixels.\n",
d295 1
a295 1
			rt_log( "Warning, no memory for normal map.\n" );
d300 1
a300 1
			rt_log( "Warning, no memory for region map.\n" );
d306 1
a306 1
			rt_log( "Warning, no memory for distance map.\n" );
d345 1
a345 1
		rt_log( "Cell size is %g mm.\n", cell_sz );
d480 1
a480 1
				rt_log( "r_dir=<%g,%g,%g>\n",
d491 1
a491 1
						rt_log( "Fatal error: %s.\n",
d501 1
a501 1
					rt_log( "Fatal error: %s.\n",
d613 2
a614 2
		V_Print( "normal", normal, rt_log );
		V_Print( "acolor", ap->a_color, rt_log );
d900 3
a902 3
					rt_log( "\t\tcontribution from light %d:\n", i );
					V_Print( "\t\treflectance coeffs", ap->a_color, rt_log );
					V_Print( "\t\taccumulated coeffs", rgb_coefs, rt_log );
d928 2
a929 2
				V_Print( "mirror", mirror_coefs, rt_log );
				V_Print( "rgb_coefs", rgb_coefs, rt_log );
d943 2
a944 2
				V_Print( "glass", ap->a_color, rt_log );
				V_Print( "rgb_coefs", rgb_coefs, rt_log );
d952 1
a952 1
		V_Print( "ap->a_color", ap->a_color, rt_log );
d991 1
a991 1
			rt_log( "\tcorrect_Lgt()\n" );
d993 1
a993 1
				lgt_entry->loc, rt_log );
d1008 1
a1008 1
				ap_hit.a_ray.r_dir, rt_log );
d1010 1
a1010 1
				ap_hit.a_ray.r_pt, rt_log );
d1043 4
a1046 4
			rt_log( "\t\tcos. of angle to lgt center = %g\n", cos_angl );
			rt_log( "\t\t	   angular distance = %g\n", ang_dist );
			rt_log( "\t\t	    relative radius = %g\n", rel_radius );
			rt_log( "\t\t	relative distance = %g\n", ang_dist/rel_radius );
d1075 1
a1075 1
		rt_log( "\tmirror_Reflect: level %d grid <%d,%d>\n",
d1078 1
a1078 1
		rt_log( "\t\tOne hit flag is %s\n",
d1125 1
a1125 1
		rt_log( "\tEntering glass_Refract(), level %d grid <%d,%d>\n",
d1128 2
a1129 2
		V_Print( "\t\tincident ray pnt", ap->a_ray.r_pt, rt_log );
		V_Print( "\t\tincident ray dir", ap->a_ray.r_dir, rt_log );
d1141 1
a1141 1
			rt_log( "\t\tNo refraction on entry.\n" );
d1163 1
a1163 1
					ap->a_color, rt_log );
d1173 1
a1173 1
				rt_log( "\t\tOne hit flag is %s\n",
d1176 1
a1176 1
					ap->a_color, rt_log );
d1187 1
a1187 1
				rt_log( "\t\tRefracting inside solid.\n" );
d1203 1
a1203 1
				rt_log( "\t\tPast critical angle on entry!\n" );
d1220 3
a1222 3
			rt_log( "\t\tRefracted ray missed:\n" );
			V_Print( "\t\trefracted ray pnt", ap_ref.a_ray.r_pt, rt_log );
			V_Print( "\t\trefracted ray dir", ap_ref.a_ray.r_dir, rt_log );
d1232 1
a1232 1
			rt_log( "\t\tRefracted ray hit.\n" );
d1248 1
a1248 1
				rt_log( "\t\tInternal reflection, recursion level (%d)\n", ap_ref.a_level );
d1260 1
a1260 1
			rt_log( "\t\tExceeded max bounces with internal reflections, recursion level (%d)\n", ap_ref.a_level );
d1271 4
a1274 4
		rt_log( "\t\tExiting ray from glass.\n" );
		V_Print( "\t\t   ray origin", ap_hit.a_ray.r_pt, rt_log );
		V_Print( "\t\tray direction", ap_hit.a_ray.r_dir, rt_log );
		rt_log( "\t\tOne hit flag is %s\n", ap_hit.a_onehit ? "ON" : "OFF" );
d1296 2
a1297 2
		rt_log( "\tRay missed model.\n" );
		V_Print( "\tbackground coeffs", ap->a_color, rt_log );
d1334 1
a1334 1
		V_Print( "coeffs returned from background", ap->a_color, rt_log );
d1348 1
a1348 1
		rt_log( "f_Error()\n" );
d1363 1
a1363 1
		rt_log( "\t\tSurface is illuminated.\n" );
d1381 1
a1381 1
		rt_log( "f_Probe()\n" );
d1420 3
a1422 3
		V_Print( "\tEntering refract(), incident ray", v_1, rt_log );
		V_Print( "\t\tentrance normal", norml, rt_log );
		rt_log( "\t\trefractive indices leaving:%g, entering:%g\n",
d1427 1
a1427 1
		rt_log( "\tBUG: Zero or negative refractive index, should have been caught earlier.\n" );
d1447 1
a1447 1
			V_Print( "\tdeflected refracted ray", v_2, rt_log );
d1462 1
a1462 1
			V_Print( "\trefracted ray", v_2, rt_log );
d1488 1
a1488 1
		rt_log( "Shadowed by :\n" );
d1494 3
a1496 3
		V_Print( "entry normal", inormal, rt_log );
		V_Print( "entry point", ihitp->hit_point, rt_log );
		rt_log( "partition[start %g end %g]\n",
d1499 1
a1499 1
		rt_log( "solid name (%s)\n", pp->pt_inseg->seg_stp->st_name );
d1505 1
a1505 1
			rt_log( "Unobstructed path to explicit light.\n" );
d1534 1
a1534 1
			rt_log( "Lgt source obstructed, object shadowed\n" );
d1541 1
a1541 1
			rt_log( "Full intensity of light source, no shadow\n" );
d1596 1
a1596 1
		rt_log( "\nmodel_Reflectance(): level %d grid <%d,%d>\n",
d1628 6
a1633 6
		rt_log( "\tDiffuse reflectance:\n" );
		V_Print( "\tsurface normal", norml, rt_log );
		V_Print( "\t dir. of light", lgt_dir, rt_log );
		rt_log( "\t cosine of incident angle = %g\n", cos_il );
		rt_log( "\tintensity of light source = %g\n", lgt_energy );
		rt_log( "\t diffuse weighting coeff. = %g\n",
d1635 1
a1635 1
		V_Print( "\tdiffuse coeffs", ap->a_color, rt_log );
d1656 3
a1658 3
			rt_log( "\tSpecular reflectance:\n" );
			V_Print( "\t           dir of eye", view_dir, rt_log );
			V_Print( "\tdir reflected lgt ray", lgt_reflect, rt_log );
d1670 1
a1670 1
				rt_log( "\tcosine of specular angle = %g\n",
d1672 1
a1672 1
				rt_log( "\t      specular component = %g\n",
d1674 1
a1674 1
				V_Print( "\tdiff+spec coeffs", ap->a_color, rt_log );
d1680 1
a1680 1
			rt_log( "\"%s\"(%d) : solid \"%s\" type %d cos(s)=%g grid <%d,%d>!\n",
d1684 1
a1684 1
			V_Print( "Surface normal", norml, rt_log );
d1801 1
a1801 1
	rt_log( "Pixel:<%3d,%3d,%3d>(%4d,%4d)\n",
d2015 1
a2015 1
		rt_log( "unknown buffering scheme %d\n",
d2021 1
a2021 1
	rt_log( "Write failed to pixel <%d,%d>.\n", x, y );
d2108 1
a2108 1
				rt_log( "Write of scan line %d failed.\n",
d2115 1
a2115 1
			rt_log( "Write of scan line (%d) failed.\n", ap->a_y );
d2130 1
a2130 1
		rt_log( "%s : hits=%d misses=%d inside=%d total=%d\n",
d2136 1
a2136 1
		rt_log( "Shadowing stats : lit=%d shadowed=%d total=%d\n",
d2200 2
a2201 2
	rt_log( "OVERLAP:\n" );
	rt_log( "reg=%s sol=%s,\n",
d2204 1
a2204 1
	rt_log( "reg=%s sol=%s,\n",
d2207 1
a2207 1
	rt_log( "(x%d y%d lvl%d) depth %gmm at (%g,%g,%g)\n",
@


11.11
log
@Modified to account for new calling sequence of bu_parallel()
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.10 1998/03/27 07:35:23 mike Exp mike $ (BRL)";
d568 1
a568 1
		if( regp->reg_mater.ma_override )
@


11.10
log
@Modified to not use RT_HIT_NORM() but to use RT_HIT_NORMAL(),
with local variables to hold the normal vectors.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.9 1997/12/16 00:25:39 mike Exp mike $ (BRL)";
a114 1
static int nworkers;	  /* number of workers now running */
d381 1
a381 1
		render_Scan();
d389 1
a389 10
	nworkers = 0;
	rt_parallel( render_Scan, npsw );

	/* ensure that all the workers are REALLY dead */
	for( x = 0; nworkers > 0; x++ )
		;
	if( x > 0 )
		rt_log( "render_Model: termination took %d extra loops\n",
			x );	

d396 3
a398 1
render_Scan()
a402 1
		int cpu;		/* local CPU number */
a407 4
	bu_semaphore_acquire( RT_SEM_WORKER );
	cpu = nworkers++;
	bu_semaphore_release( RT_SEM_WORKER );

a508 3
	bu_semaphore_acquire( RT_SEM_WORKER );
	nworkers--;
	bu_semaphore_release( RT_SEM_WORKER );
@


11.9
log
@Converted to bu_semaphore_acquire()
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.8 1997/09/11 20:39:10 jra Exp mike $ (BRL)";
a50 9
#define Fix_Iflip( _pp, _normal, _rdir, _stp )\
	{\
	if( _pp->pt_inflip )\
		{\
		VREVERSE( _normal, _normal );\
		_pp->pt_inflip = 0;\
		}\
	Check_Iflip( _pp, _normal, _rdir, _stp );\
	}
a69 10
#define Fix_Oflip( _pp, _normal, _rdir, _stp )\
	{\
	if( _pp->pt_outflip )\
		{\
		VREVERSE( _normal, _normal );\
		_pp->pt_outflip = 0;\
		}\
	Check_Oflip( _pp, _normal, _rdir, _stp );\
	}

d546 1
d556 1
a556 1
		VSCALE( ihitp->hit_normal, rp->r_dir, -1.0 );
d560 1
a560 2
		RT_HIT_NORM( ihitp, stp, rp );
		Fix_Iflip( pp, ihitp->hit_normal, ap->a_ray.r_dir, stp );
d569 3
a571 3
			ihitp->hit_normal[X],
			ihitp->hit_normal[Y],
			ihitp->hit_normal[Z]
d619 1
d623 4
a626 5
	RT_HIT_NORM( ihitp, stp, &(ap->a_ray) );
	Fix_Iflip( pp, ihitp->hit_normal, ap->a_ray.r_dir, stp );
	ap->a_color[RED] = (ihitp->hit_normal[X] + 1.0) / 2.0;
	ap->a_color[GRN] = (ihitp->hit_normal[Y] + 1.0) / 2.0;
	ap->a_color[BLU] = (ihitp->hit_normal[Z] + 1.0) / 2.0;
d629 1
a629 1
		V_Print( "normal", ihitp->hit_normal, rt_log );
d755 1
d763 1
a763 1
		VSCALE( ihitp->hit_normal, rp->r_dir, -1.0 );
d767 1
a767 2
		RT_HIT_NORM( ihitp, stp, rp );
		Fix_Iflip( pp, ihitp->hit_normal, ap->a_ray.r_dir, stp );
d910 2
a911 1
							view_dir
d934 1
a934 1
			mirror_Reflect( ap, pp, mirror_coefs );
d950 1
a950 1
			glass_Refract( ap, pp, entry );
d1078 1
a1078 1
mirror_Reflect( ap, pp, mirror_coefs )
d1082 1
d1100 1
a1100 1
	{	fastf_t	f = 2.0	* Dot( r_dir, pp->pt_inhit->hit_normal );
d1102 1
a1102 1
	Scale2Vec( pp->pt_inhit->hit_normal, f, tmp_dir );
d1119 1
a1119 1
glass_Refract( ap, pp, entry )
d1123 1
d1209 1
a1209 1
				pp->pt_inhit->hit_normal,
d1401 1
a1401 3
	RT_HIT_NORM( hitp, stp, &(ap->a_ray) );
	Fix_Oflip( pp, hitp->hit_normal, ap->a_ray.r_dir, stp );
	VMOVE( ap->a_uvec, hitp->hit_normal );
a1402 4
	if( ! pp->pt_outflip )
		{ /* For refraction, want exit normal to point inward. */
		VREVERSE( ap->a_uvec, ap->a_uvec );
		}
d1503 1
d1509 2
a1510 5
		RT_HIT_NORM( ihitp, istp, &(ap->a_ray) );
		Fix_Iflip( pp, ihitp->hit_normal, ap->a_ray.r_dir, istp );
		RT_HIT_NORM( ohitp, ostp, &(ap->a_ray) );
		Fix_Oflip( pp, ohitp->hit_normal, ap->a_ray.r_dir, ostp );
		V_Print( "entry normal", ihitp->hit_normal, rt_log );
d1598 1
a1598 1
model_Reflectance( ap, pp, mdb_entry, lgt_entry, view_dir )
d1604 1
a1605 1
		register fastf_t *norml = pp->pt_inhit->hit_normal;
@


11.8
log
@getMaMID() was protected by RES_ACQUIRE, but used bu_strdup().
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.7 1997/06/17 21:05:38 jra Exp jra $ (BRL)";
d436 1
a436 1
	RES_ACQUIRE( &rt_g.res_worker );
d438 1
a438 1
	RES_RELEASE( &rt_g.res_worker );
d447 1
a447 1
		RES_ACQUIRE( &rt_g.res_worker );
d449 1
a449 1
		RES_RELEASE( &rt_g.res_worker );
d541 1
a541 1
	RES_ACQUIRE( &rt_g.res_worker );
d543 1
a543 1
	RES_RELEASE( &rt_g.res_worker );
d823 1
a823 1
			RES_ACQUIRE( &rt_g.res_worker );
d828 1
a828 1
			RES_RELEASE( &rt_g.res_worker );
d839 1
a839 1
				RES_ACQUIRE( &rt_g.res_stats );
d847 1
a847 1
				RES_RELEASE( &rt_g.res_stats );
d857 1
a857 1
			RES_ACQUIRE( &rt_g.res_worker );
d871 1
a871 1
				RES_RELEASE( &rt_g.res_worker );
d874 1
a874 1
			RES_RELEASE( &rt_g.res_worker );
d1761 1
a1761 1
	RES_ACQUIRE( &rt_g.res_syscall );
d1765 1
a1765 1
	RES_RELEASE( &rt_g.res_syscall );
d1970 1
a1970 1
		RES_ACQUIRE( &rt_g.res_syscall );
d1975 1
a1975 1
		RES_RELEASE( &rt_g.res_syscall );
d2076 1
a2076 1
		RES_ACQUIRE( &rt_g.res_stats );
d2078 1
a2078 1
		RES_RELEASE( &rt_g.res_stats );
d2082 1
a2082 1
		RES_ACQUIRE( &rt_g.res_stats );
d2086 1
a2086 1
		RES_RELEASE( &rt_g.res_stats );
d2116 1
a2116 1
		RES_ACQUIRE( &rt_g.res_stats );
d2120 1
a2120 1
		RES_RELEASE( &rt_g.res_stats );
d2124 1
a2124 1
		RES_ACQUIRE( &rt_g.res_stats );
d2127 1
a2127 1
		RES_RELEASE( &rt_g.res_stats );
d2137 1
a2137 1
		RES_ACQUIRE( &rt_g.res_stats );
d2156 1
a2156 1
		RES_RELEASE( &rt_g.res_stats );
@


11.7
log
@getMaMID() failed on NULL shaders.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.6 1996/12/04 03:21:32 mike Exp jra $ (BRL)";
d689 4
d699 17
a715 2
	/* get <name>=<value> string */
	if( (name = strtok( copy, MA_WHITESP )) == NULL )
d717 20
a736 10
		bu_free( (genptr_t)copy, "getMaMID" );
		return	false;
		}
	do
		{
		/* break it down into name and value */
again:
		value = NULL;
		for( p = name; *p != '\0'; p++ )
			if( *p == '=' )
d738 3
a740 3
				value = p+1;
				*p = '\0';
				break;
d742 4
a745 8
		if( value == NULL )
			continue; /* No '=' in input token. */
		/* if we have a material id, get it and return */
		if(	strcmp( name, MA_MID ) == 0
		    &&	sscanf( value, "%d", id ) == 1 )
			{
			bu_free( (genptr_t)copy, "getMaMID" );
			return	true;
d748 1
a748 2
	/* keep trying for rest of parameter string */
	while( (name = strtok( NULL, MA_WHITESP )) != NULL );
d751 1
a805 1
	RES_ACQUIRE( &rt_g.res_syscall ); /* protect use of strtok() */
a807 1
	RES_RELEASE( &rt_g.res_syscall );
@


11.6
log
@ma_matname changed to ma_shader
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.5 1996/10/19 06:20:46 mike Exp mike $ (BRL)";
d689 2
@


11.5
log
@Changed to reflect that ma_matparm is now a pointer, not an array.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.4 1996/08/20 12:01:40 moss Exp mike $ (BRL)";
d598 1
a598 1
	if( regp->reg_mater.ma_matname && regp->reg_mater.ma_matname[0] != '\0' )
d600 2
a601 2
		prnt_Scroll(	"\tmaterial info \"%.32s\"\n",
				regp->reg_mater.ma_matname
a608 4
		if( regp->reg_mater.ma_matparm && regp->reg_mater.ma_matparm[0] != '\0' )
			prnt_Scroll(	"\t\t\tparameters: \"%.60s\"\n",
					regp->reg_mater.ma_matparm
					);
a670 5
#define MA_LENPARM 512 /* Must be 1 byte longer than length of ma_matparm
			field of mater_info struct in raytrace.h; last
			time I looked it was 60, but I anticipate that
			we will outgrow that soon.  A defined constant
			in raytrace.h would be nice, but no-o-o-o. */
d684 2
a685 1
	{	char matparm[MA_LENPARM];
d689 1
a689 2
		unsigned lenparm = MA_LENPARM-1;
	if( map->ma_matname && map->ma_matname[0] == '\0' )
d691 4
a694 2
	/* guard against changes to length of ma_matparm field */
	if( lenparm > MA_LENPARM-1 )
d696 1
a696 2
		rt_log( "BUG: Must lengthen MA_LENPARM to be %u bytes.\n",
			lenparm );
a698 6
	/* copy parameter string to scratch buffer and null terminate */
	(void) strncpy( matparm, map->ma_matparm, lenparm );
	matparm[lenparm] = '\0';
	/* get <name>=<value> string */
	if( (name = strtok( matparm, MA_WHITESP )) == NULL )
		return	false;
d702 1
d716 2
d719 1
d723 1
@


11.4
log
@Fixed return of local variable in mirror_Reflect().
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.3 1996/07/17 13:03:43 jra Exp moss $ (BRL)";
d598 1
a598 1
	if( regp->reg_mater.ma_matname[0] != '\0' )
d609 1
a609 1
		if( regp->reg_mater.ma_matparm[0] != '\0' )
d697 2
a698 2
		unsigned lenparm = sizeof(map->ma_matparm);
	if( map->ma_matname[0] == '\0' )
@


11.3
log
@MinorMods for IRIX 6.2
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.2 1995/01/05 01:26:59 mike Rel4_4 jra $ (BRL)";
a208 1
STATIC fastf_t *mirror_Reflect();
d220 1
d935 3
a937 2
			{	register fastf_t *mirror_coefs =
						mirror_Reflect( ap, pp );
d1075 6
a1080 4
	fastf_t *mirror_Reflect( register struct application *ap,
				register struct partition *pp )			 */
STATIC fastf_t *
mirror_Reflect( ap, pp )
d1083 1
d1109 3
a1111 1
	return	ap_hit.a_color;
@


11.2
log
@Sun-3:  "../lgt/reflect.c", line 1877: warning: & before array or function: ignored
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 11.1 95/01/04 10:18:00 mike Rel4_4 Locker: mike $ (BRL)";
d1863 2
a1864 2
				if( hl_Norm_Diff( &hl_normap[xi][0],
							&hl_normap[xi-1][0] ) )
d1872 4
a1875 4
			  ||	hl_Norm_Diff( &hl_normap[yi*a_gridsz+xi][0],
						&hl_normap[yi*a_gridsz+(xi-1)][0] )
			  ||	hl_Norm_Diff( &hl_normap[yi*a_gridsz+xi][0],
						&hl_normap[(yi-1)*a_gridsz+xi][0] )
d1877 1
a1877 1
			     && ! hi_Obliq( &hl_normap[yi*a_gridsz+xi][0] )
@


11.1
log
@Release_4.4
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 10.7 95/01/03 09:53:13 jra Exp $ (BRL)";
d1863 2
a1864 2
				if( hl_Norm_Diff( &hl_normap[xi],
							&hl_normap[xi-1] ) )
d1872 4
a1875 4
			  ||	hl_Norm_Diff( &hl_normap[yi*a_gridsz+xi],
						&hl_normap[yi*a_gridsz+(xi-1)] )
			  ||	hl_Norm_Diff( &hl_normap[yi*a_gridsz+xi],
						&hl_normap[(yi-1)*a_gridsz+xi] )
d1877 1
a1877 1
			     && ! hi_Obliq( &hl_normap[yi*a_gridsz+xi] )
@


10.7
log
@Added "&" to args of hl_Norm_Diff and hi_Obliq.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/reflect.c,v 10.6 94/08/24 13:37:00 gdurf Exp Locker: jra $ (BRL)";
@


10.6
log
@Made includes explcit
Factored ifdefs
Added cast to (unsigned char *) from RGBpixel
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 10.5 1992/03/27 12:08:31 moss Exp gdurf $ (BRL)";
d1863 2
a1864 2
				if( hl_Norm_Diff( hl_normap[xi],
							hl_normap[xi-1] ) )
d1872 4
a1875 4
			  ||	hl_Norm_Diff( hl_normap[yi*a_gridsz+xi],
						hl_normap[yi*a_gridsz+(xi-1)] )
			  ||	hl_Norm_Diff( hl_normap[yi*a_gridsz+xi],
						hl_normap[(yi-1)*a_gridsz+xi] )
d1877 1
a1877 1
			     && ! hi_Obliq( hl_normap[yi*a_gridsz+xi] )
@


10.5
log
@Fixed bugs relating to using an eye and grid solid.
	These solids are now skipped in the partition list of the hit routine.
	The vertical grid vector is now properly calculated.
	The eye and grid location are reported as well as the view direction
		when using this feature.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/reflect.c,v 10.4 92/02/28 09:18:26 moss Exp $ (BRL)";
d14 2
d20 3
a22 1
#ifdef BSD
a23 2
#else
#include <string.h>
d25 9
a1906 3
#if defined(sgi) && ! defined(mips)
					int xa, ya, xn, yn;
#else
a1907 1
#endif
d2132 1
a2132 1
		if( fb_write( fbiop, x, y, scanbuf+x, ct ) == -1 )
@


10.4
log
@Added test for high obliquity before doing distance discriminant.
This fixes the problem of getting black on highly oblique plates.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/reflect.c,v 10.3 91/12/20 10:24:09 moss Exp $ (BRL)";
d158 2
d166 4
a169 1
	    &&	(failure=PT_BEHIND, pp->pt_outhit->hit_dist < BEHIND_ME_TOL);\
d188 2
d288 1
a288 1
		ag.a_onehit = true;
d500 6
a758 8
#if 0
	{	register struct hit *ohitp;
	stp = pp->pt_outseg->seg_stp;
	ohitp = pp->pt_outhit;
	RT_HIT_NORM( ohitp, stp, &(ap->a_ray) );
	Fix_Oflip( pp, ohitp->hit_normal, ap->a_ray.r_dir, stp );
	}
#endif
@


10.3
log
@Fixed bug in extraction of "mid" string from mged parameter string.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/reflect.c,v 10.2 91/12/12 17:03:59 moss Exp $ (BRL)";
d32 2
a33 1
#define COSTOL		0.91
a36 1

d187 2
d202 1
d1812 17
a1855 3
			  || (hl_dstmap != NULL &&
				(hl_Dst_Diff( xi, yi, xi-1, yi, maxdist )
			     ||	 hl_Dst_Diff( xi, yi, xi, yi-1, maxdist )))
d1860 4
a1919 1
	return;
@


10.2
log
@Protected function which gets material id from MGED param string with
semaphores because it uses strtok().  Using multiple processors on the
SGI would cause strtok() to dump core.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/reflect.c,v 10.1 91/10/12 06:50:13 mike Rel4_0 $ (BRL)";
d694 1
@


10.1
log
@Release_4.0
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 9.12 91/08/30 21:15:49 mike Exp $ (BRL)";
a693 1
				*p = '\0';
d768 1
d771 1
@


9.12
log
@Stardent ANSI C lint
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 9.11 91/07/23 17:08:54 moss Exp $ (BRL)";
@


9.11
log
@Added comment to 3030 workaround.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 9.10 91/07/23 17:03:12 moss Exp $ (BRL)";
d1754 1
a1754 1
	return distance > maxdist;
@


9.10
log
@Added workaround for 3030s, the compiler couldn't digest the HL_TSTBIT
macro, but changing some register variables to regular ints fixed it.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/reflect.c,v 9.9 91/05/01 15:35:01 moss Exp $ (BRL)";
d1866 2
a1867 1
				{
@


9.9
log
@Enlarged MAX_HL_SIZE and fixed bug in diagnostic when limit is overrun.
@
text
@d11 1
a11 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 9.4 89/08/02 14:00:02 moss Locked $ (BRL)";
d1866 6
a1871 1
				{	register int xa, ya, xn, yn;
@


9.8
log
@Added BEHIND_ME_TOL configuration to the Cakefile.
@
text
@d283 7
a1811 6
	if( a_gridsz > MAX_HL_SIZE )
		{
		rt_log( "Max. size for hidden-line images is %dx%d pixels.\n",
			MAX_HL_SIZE );
		return;
		}
@


9.7
log
@Added initializations of auto variables to make Cray compiler happy.
@
text
@d152 1
d154 1
@


9.6
log
@Added clipping of image to permit negative image offsets.
@
text
@a5 1
			(301)278-6651 or AV-298-6651
d661 1
d665 1
a665 1
	if( sizeof(map->ma_matparm) > MA_LENPARM-1 )
d668 1
a668 1
			sizeof( map->ma_matparm ) );
d672 2
a673 2
	(void) strncpy( matparm, map->ma_matparm, sizeof(map->ma_matparm) );
	matparm[sizeof(map->ma_matparm)] = '\0';
d680 1
d688 2
d957 1
a957 1
	{	fastf_t	energy_attenuation;
d959 3
a961 6
	if( ! shadowing )
		{
		energy_attenuation = 1.0;
		if( ! lgt_entry->beam )
			return	lgt_entry->energy;
		}
@


9.5
log
@Improved hidden line stuff.  Normals now stored in memory rather than
in frame buffer.  Anti-aliasing now done in double precision, also
using memory rather than the frame buffer.
@
text
@d1949 3
d1966 4
a1969 1
	case B_PIO :
a1970 1
			/* Programmed I/O to frame buffer (if possible).*/
d1973 4
a1976 2
	case B_PAGE :
		/* Buffered writes to frame buffer. */
d1983 4
a1986 1
	case B_LINE :
d1994 2
d1997 1
d2036 10
@


9.4
log
@Fixed bug in shadowing when light source is closer than object.
@
text
@d6 1
a6 1
			(301)278-6647 or AV-298-6647
d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 9.3 89/05/22 12:42:23 moss Exp $ (BRL)";
d39 1
a39 1
#define FLIPPED_NORMALS_BUG	FALSE /* Keep an eye out for dark spots. */
d98 1
a98 1
static Mat_Db_Entry	mat_tmp_entry =
d141 2
a142 1
static bitv_t hl_bits[1024][1024/HL_BITVBITS];
d159 1
a159 1
	{	int	failure;\
d190 1
a190 1
/* "Hit" application routines to pass to "rt_shootray()".		*/
d192 1
a192 1
/* "Miss" application routines to pass to "rt_shootray()".		*/
d194 1
a194 1
/* "Overlap" application routines to pass to "rt_shootray()".		*/
d246 1
a246 1
		return	FALSE;
d248 1
a248 1
	return	TRUE;
d264 2
d277 1
a277 1
		ag.a_onehit = TRUE;
d282 5
d288 2
a289 2
			malloc( (unsigned)(grid_sz*grid_sz)*sizeof(short) ))
			== (short *) NULL
d294 2
a295 2
				(grid_sz*grid_sz)*sizeof(unsigned short) ))
			== (unsigned short *) NULL
d301 1
a301 1
		ag.a_onehit = TRUE;
d318 1
a318 1
	/* Compute light source positions.				*/
a326 1
	a_gridsz = anti_aliasing ? grid_sz * aperture_sz : grid_sz;
d340 1
a340 1
	/* Statistics for refraction tuning.				*/ 
d345 1
a345 1
	/* Statistics for shadowing.					*/
d349 1
a349 1
	fatal_error = FALSE;
d351 1
a351 1
	/* Get starting and ending scan line number.			*/
d398 2
a399 1
		RGBpixel scanbuf[1024];
d401 1
a401 1
		int cpu;	/* local CPU number */
d404 1
a404 1
		threads of execution, so make copy.			*/
d433 1
a433 1
		a.a_onehit = FALSE;
d450 1
a450 1
				 of grid. */
d456 1
a456 1
				view_pix( &a, scanbuf ), a.a_x++
d458 1
a458 1
				{	fastf_t		aim_pt[3];
d486 4
a489 2
						/* Fatal error in application routine.	*/
						rt_log( "Fatal error: raytracing aborted.\n" );
d496 4
a499 2
					/* Fatal error in application routine.	*/
					rt_log( "Fatal error: raytracing aborted.\n" );
d587 6
d594 1
a594 1
		hl_regmap[ap->a_y*grid_sz+ap->a_x] = 0;
d596 1
a596 1
		hl_dstmap[ap->a_y*grid_sz+ap->a_x] = 0;
d604 3
a606 3
	{	register struct partition	*pp;
		register struct soltab		*stp;
		register struct hit		*ihitp;
d620 9
d630 1
a630 1
		hl_regmap[ap->a_y*grid_sz+ap->a_x] =
d633 1
a633 1
		hl_dstmap[ap->a_y*grid_sz+ap->a_x] =
d698 4
a701 1
/*	f _ M o d e l ( )
d710 7
a716 7
	{	register struct partition	*pp;
		register Mat_Db_Entry		*entry;
		register struct soltab		*stp;
		register struct hit		*ihitp;
		register struct xray		*rp = &ap->a_ray;
		int				material_id;
		fastf_t				rgb_coefs[3];
d732 1
a732 1
	{	register struct hit	*ohitp;
d740 2
a741 2
	/* See if we hit a light source.				*/
	{	register int	i;
d748 1
a748 1
		{ /* Maximum light coming from light source.		*/
d756 1
a756 1
	/* Get material id as index into material database.		*/
d760 1
a760 1
	/* Get material database entry.					*/
d762 4
a765 4
		{ /* We are mapping temperatures into an octree.	*/
			Trie		*triep;
			Octree		*octreep;
			int		fahrenheit;
d768 1
a768 1
			fatal_error = TRUE;
d773 1
a773 1
			{	int	ir_level = 0;
d785 5
a789 4
				{	RGBpixel	pixel;
					int	x = ap->a_x + x_fb_origin - ir_mapx;
					int	y = ap->a_y + y_fb_origin - ir_mapy;
				/* Map temperature from IR image using offsets.	*/
d796 2
a797 1
					fahrenheit = pixel_To_Temp( (RGBpixel *) pixel );
d802 1
a802 1
				/* User specified temp. of current rectangle.	*/
d805 2
a806 1
				/* Unknown temperature, use out-of-band value.	*/
d809 2
a810 1
			triep = add_Trie( pp->pt_regionp->reg_name, &reg_triep );
d828 1
a828 1
			{	register int	index;
d835 1
a835 1
	/* Get material attributes from database.		*/
d842 3
a844 3
		{	struct uvcoord		uv;
			Mat_Db_Entry		loc_entry;
		/* Solid has a frame buffer image map.		*/
d852 1
a852 1
			/* Scale RGB values to coeffs (0.0 .. 1.0 )	*/
d863 1
a863 1
	/* Compute contribution from this surface.			*/
d865 2
a866 2
		register int	i;
		auto fastf_t	view_dir[3];
d868 1
a868 1
	/* Calculate view direction.					*/
d875 1
a875 1
			{ /* All light sources.				*/
d904 1
a904 1
			/* Compute mirror reflection.			*/
d919 1
a919 1
			/* Compute transmission through glass.		*/
d932 1
a932 1
	/* Pass result in application struct.				*/
d941 5
a945 1
/*	c o r r e c t _ L g t ( )
d951 3
a953 3
register struct application	*ap;
register struct partition	*pp;
register Lgt_Source		*lgt_entry;
d966 1
a966 1
		{	struct application	ap_hit;
d971 1
a971 1
		ap_hit.a_onehit = FALSE; /* Go all the way to the light. */
d987 1
a987 1

d1010 1
a1010 1
		/* Apply gaussian intensity distribution.		*/
d1016 1
a1016 2
			cons_Vector( lgt_cntr,
					lgt_entry->azim, lgt_entry->elev );
d1024 1
a1024 1
			/* Negligable intensity.			*/
d1030 1
a1030 2
			rt_log( "\t\tcos. of angle to lgt center = %g\n",
				cos_angl );
d1032 2
a1033 4
			rt_log( "\t\t	    relative radius = %g\n",
				rel_radius );
			rt_log( "\t\t	relative distance = %g\n",
				ang_dist/rel_radius );
d1043 3
a1045 1
/*	m i r r o r _ R e f l e c t ( )					*/
d1048 7
a1054 7
register struct application	*ap;
register struct partition	*pp;
	{	fastf_t			r_dir[3];
		struct application	ap_hit;
	ap_hit = *ap;		/* Same as initial application.		*/
	ap_hit.a_onehit = FALSE;
	ap_hit.a_level++;	/* Increment recursion level.		*/
d1064 1
a1064 1
	/* Calculate reflected incident ray.				*/
d1072 1
a1072 1
	/* Set up ray origin at surface contact point.			*/
d1078 5
a1082 1
/*	g l a s s _ R e f r a c t ( )					*/
d1085 6
a1090 6
register struct application	*ap;
register struct partition	*pp;
register Mat_Db_Entry		*entry;
	{	struct application	ap_hit;	/* To shoot ray beyond.	*/
		struct application	ap_ref; /* For getting thru.	*/
	/* Application structure for refracted ray.			*/
d1092 2
a1093 2
	ap_ref.a_hit =  f_Probe;	/* Find exit from glass.	*/
	ap_ref.a_miss = f_Error;	/* Bad news.			*/
d1095 2
a1096 2
	ap_ref.a_onehit = TRUE;
	ap_ref.a_level++;		/* Increment recursion level.	*/
d1098 1
a1098 1
	/* Application structure for exiting ray.			*/
d1100 1
a1100 1
	ap_hit.a_onehit = FALSE;
d1118 2
a1119 2
		{ /* No refraction necessary.				*/
			struct partition	*pt_headp = pp->pt_back;
d1162 2
a1163 2
		/* Set up ray-trace to find new exit point.		*/
		{ /* Calculate refraction at entrance.			*/
d1172 1
a1172 1
		if( ! refract(	ap->a_ray.r_dir,   /* Incident ray.	*/
d1174 1
a1174 1
				RI_AIR,		   /* Air ref. index.	*/
d1176 1
a1176 1
				ap_ref.a_ray.r_dir /* Refracted ray.	*/
d1179 1
a1179 1
			{ /* Past critical angle, reflected back out.	*/
d1187 1
a1187 1
	/* Fire from entry point.					*/
d1215 1
a1215 1
	/* Calculate refraction at exit.				*/
d1218 1
a1218 1
		/* Reversed exit normal in a_uvec.			*/
d1226 1
a1226 1
			{ /* Past critical angle, internal reflection.	*/
d1231 1
a1231 1
			/* Refracted ray exit point in a_color.		*/
d1237 2
a1238 2
		{ /* Exceeded max bounces, total absorbtion of light.	*/
		ap->a_color[0] = ap->a_color[1] = ap->a_color[2] = 0.0;
d1244 1
a1244 1
	/* Refracted ray exit point in a_color.				*/
d1248 1
a1248 1
	/* Shoot from exit point in direction of refracted ray.		*/
d1261 3
a1263 1
/*	f _ B a c k g r ( )
d1270 2
a1271 2
	{	register int	i;
	/* Base-line color is same as background.			*/
d1280 1
a1280 1
	/* If this is a reflection, we may see each light source.	*/
d1282 1
a1282 1
		{	Mat_Db_Entry	*mdb_entry;
d1289 3
a1291 3
			{	auto fastf_t		real_l_1[3];
				register fastf_t	specular;
				fastf_t			cos_s;
d1304 1
a1304 1
				/* Add reflected light source.		*/
d1319 3
a1321 1
/*	f _ E r r o r ( )						*/
d1332 3
a1334 1
/*	f _ L i t ( )
d1349 4
a1352 1
/*	f _ P r o b e ( )						*/
d1357 3
a1359 3
	{	register struct partition	*pp;
		register struct hit		*hitp;
		register struct soltab		*stp;
d1370 1
a1370 1
		{ /* For refraction, want exit normal to point inward.	*/
d1376 5
a1380 1
/*	r e f r a c t ( )
d1399 5
a1403 5
register fastf_t	*v_1, *norml;
fastf_t			ri_1, ri_2;
register fastf_t	*v_2;
	{	fastf_t	w[3], u[3];	/* Intermediate vectors.	*/
		fastf_t	beta;		/* Intermediate scalar.		*/
d1408 2
a1409 1
		rt_log( "\t\trefractive indices leaving:%g, entering:%g\n", ri_1, ri_2 );
d1412 1
a1412 1
		{ /* User probably forgot to specify refractive index.	*/
d1414 1
a1414 1
		VMOVE( v_2, v_1 ); /* Just return ray unchanged.	*/
d1423 1
a1423 1
	if( (beta = Dot( u, u )) > 1.0 ) /* beta = sin( theta_2 )^^2.	*/
d1455 4
a1458 1
/*	f _ S h a d o w ( )
d1467 2
a1468 2
	{	register struct partition	*pp;
		register Mat_Db_Entry		*entry;
d1471 2
a1472 2
		{	register struct hit	*ihitp, *ohitp;
			register struct soltab	*istp, *ostp;
d1512 1
a1512 1
			/* Light is totally eclipsed.			*/
d1534 8
a1541 1
/*	m o d e l _ R e f l e c t a n c e ( )
d1576 1
a1576 1
	{	/* Compute attenuation of light source intensity.	*/
d1578 1
a1578 1
		register fastf_t ff;		/* temp */
d1580 1
a1580 1
		fastf_t cos_il;		 /* cosine incident angle */
d1588 1
a1588 1
	if( ap->a_user == 0 )		/* Ambient lighting.		*/
d1595 1
a1595 1
		/* Compute attenuated light intensity due to shadowing.	*/
d1598 2
a1599 2
			/* Shadowed by an opaque object.		*/
			ap->a_color[0] = ap->a_color[1] = ap->a_color[2] = 0.0;
d1602 1
a1602 1
		/* Direction unit vector to light source from hit pt.	*/
d1607 1
a1607 1
	/* Calculate diffuse reflectance from light source.		*/
d1610 1
a1610 1
	/* Facter in light source intensity and diffuse weighting.	*/
d1612 1
a1612 1
	/* Facter in light source color.				*/
d1621 2
a1622 1
		rt_log( "\t diffuse weighting coeff. = %g\n", mdb_entry->wgt_diffuse );
d1625 2
a1626 2
	/* Facter in material color (diffuse reflectance coeffs)	*/
	ff = RGB_INVERSE; /* Scale RGB values to coeffs (0.0 .. 1.0 )	*/
d1636 3
a1638 3
		{	auto fastf_t		lgt_reflect[3], tmp_dir[3];
			register fastf_t	specular;
			fastf_t			cos_s;
d1651 1
a1651 1
			{ /* We have a significant specular component.	*/
d1654 1
a1654 1
			/* Add specular component.			*/
d1658 4
a1661 2
				rt_log( "\tcosine of specular angle = %g\n", cos_s );
				rt_log( "\t      specular component = %g\n", specular );
d1667 1
a1667 1
			{	struct soltab	*stp = pp->pt_inseg->seg_stp;
d1678 3
a1680 1
/*	c o n s _ V e c t o r ( )
d1686 1
a1686 1
register fastf_t	*vec;
d1688 1
a1688 1
	{ /* Store cosine of the elevation to save calculating twice.	*/
d1697 3
a1699 1
/*	a b o r t _ R T ( )						*/
d1707 1
a1707 1
int	sig;
d1712 1
a1712 1
	user_interrupt = 1;
d1721 3
a1723 1
/*	i p o w ( )
d1729 3
a1731 3
register fastf_t	d;
register int	n;
	{	register fastf_t	result = 1.0;
d1740 1
a1740 1
register int	x0, y0, x1, y1;
d1742 2
a1743 2
	{	short	distance;
	distance = hl_dstmap[y0*grid_sz+x0] - hl_dstmap[y1*grid_sz+x1];
a1744 10
#if FALSE
	if( y0 == grid_sz/2 )
	rt_log( "hl_Dst_Diff({<%4d,%4d>,<%4d,%4d>}) %4d-%4d=%4d > %d?\n",
		x0, y0, x1, y1,
		hl_dstmap[y0*grid_sz+x0],
		hl_dstmap[y1*grid_sz+x1],
		distance,
		maxdist
		);
#endif
d1749 1
a1749 1
register int	x0, y0, x1, y1;
d1751 1
a1751 8
#if FALSE
	rt_log( "hl_Reg_Diff({<%4d,%4d>,<%4d,%4d>}) %4d != %4d\n",
		x0, y0, x1, y1,
		hl_regmap[y0*grid_sz+x0],
		hl_regmap[y1*grid_sz+x1]
		);
#endif
	return	hl_regmap[y0*grid_sz+x0] != hl_regmap[y1*grid_sz+x1];
d1755 1
a1755 1
register RGBpixel	*pix1, *pix2;
d1757 1
a1757 9
		static fastf_t	conv = 2.0/255.0;
#if 0
#ifdef cray
	rt_log( "hl_Norm_Diff(0x%x,0x%x)\n", pix1, pix2 );
#endif
	rt_log( "hl_Norm_Diff(<%d,%d,%d>,<%d,%d,%d>)\n",
		(*pix1)[0], (*pix1)[1], (*pix1)[2],
		(*pix2)[0], (*pix2)[1], (*pix2)[2] );
#endif
d1786 2
a1787 2
register RGBpixel	*pixelp;
int	x, y;
d1799 3
a1801 9
	{	static RGBpixel	black_pixel = { 0, 0, 0 };
		static RGBpixel	white_pixel = { 255, 255, 255 };
		register RGBpixel *fgp = (RGBpixel *)
				(reverse_video ? black_pixel : white_pixel);
		register RGBpixel *bgp = (RGBpixel *)
				(reverse_video ? white_pixel : black_pixel);
		static RGBpixel bufa[1024], bufb[1024];
		register int	x, y;
		unsigned short	maxdist = (cell_sz*ARCTAN_87)+2;
d1803 14
a1816 11
	for( y = 0; y < grid_sz && ! user_interrupt; y++ )
		{	static RGBpixel	*rpixp;
			static RGBpixel	*lpixp;
			
		rpixp = is_Odd(y) ? bufb : bufa;
		lpixp = is_Odd(y) ? bufa : bufb;
		(void) fb_seek( fbiop, 0, y );
		for(	x = 0;
			x < grid_sz && ! user_interrupt;
			x++
			)
d1818 2
a1819 10
			if( fb_rpixel( fbiop, (RGBpixel *)(rpixp[x]) ) == -1 )
				{
				fb_log(
			"hl_Postprocess: Failed to read pixel <%d,%d>\n",
					x, y );
				return;
				}
			/*prnt_Pixel( rpixp[x], x, y );*/
			if( x == 0 )
				HL_SETBIT( x, y );
d1821 4
a1824 3
			if( y == 0 )
				if( hl_Norm_Diff( rpixp[x], rpixp[x-1] ) )
					HL_CLRBIT( x, y );
d1826 1
a1826 1
					HL_SETBIT( x, y );
d1829 2
a1830 2
				(hl_Reg_Diff( x, y, x-1, y )
			     ||	 hl_Reg_Diff( x, y, x, y-1 )))
d1832 6
a1837 4
				(hl_Dst_Diff( x, y, x-1, y, maxdist )
			     ||	 hl_Dst_Diff( x, y, x, y-1, maxdist )))
			  ||	hl_Norm_Diff( rpixp[x], rpixp[x-1] )
			  ||	hl_Norm_Diff( rpixp[x], lpixp[x] )
d1839 1
a1839 1
				HL_CLRBIT( x, y );
d1841 1
a1841 1
				HL_SETBIT( x, y );
d1844 34
a1877 6
	for( y = 0; y < grid_sz && ! user_interrupt; y++ )
		{
		(void) fb_seek( fbiop, 0, y );
		for( x = 0; x < grid_sz && ! user_interrupt; x++ )
			{
			if( HL_TSTBIT( x, y ) )
d1891 4
a1894 1
/*	v i e w _ p i x ( )						*/
d1896 7
a1902 6
view_pix( ap, scanbuf )
register struct application	*ap;
RGBpixel		scanbuf[];
	{	RGBpixel	pixel;
		int		x = ap->a_x + x_fb_origin;
		int		y = ap->a_y + y_fb_origin;
d1912 3
a1914 8
	/* Clip relative intensity on each gun to range 0.0 to 1.0;
		then scale to RGB values.				*/
	pixel[RED] = ap->a_color[0] > 1.0 ? 255 :
			(ap->a_color[0] < 0.0 ? 0 : ap->a_color[0] * 255);
	pixel[GRN] = ap->a_color[1] > 1.0 ? 255 :
			(ap->a_color[1] < 0.0 ? 0 : ap->a_color[1] * 255);
	pixel[BLU] = ap->a_color[2] > 1.0 ? 255 :
			(ap->a_color[2] < 0.0 ? 0 : ap->a_color[2] * 255);
d1916 19
a1934 10
		{
		x = ap->a_x / aperture_sz + x_fb_origin;
		y = ap->a_y / aperture_sz + y_fb_origin;
		pixel[RED] = (int)((fastf_t) pixel[RED] / sample_sz);
		pixel[GRN] = (int)((fastf_t) pixel[GRN] / sample_sz);
		pixel[BLU] = (int)((fastf_t) pixel[BLU] / sample_sz);
		if( ap->a_x % aperture_sz || ap->a_y % aperture_sz )
			{	RGBpixel	tpixel;
			/* Read accumulator pixel per buffering scheme.	*/
			switch( pix_buffered )
d1936 6
a1941 27
			case B_PIO :
				if( fb_read( fbiop, x, y, tpixel, 1 ) == -1 )
					{
					rt_log( "Read failed from pixel <%d,%d>.\n",
						x, y
						);
					return;
					}
				break;
			case B_PAGE :
				if(	fb_seek( fbiop, x, y ) == -1
				    ||	fb_rpixel( fbiop, (RGBpixel *)tpixel )
						== -1
					)
					{
					rt_log( "Read failed from pixel <%d,%d>.\n",
						x, y
						);
					return;
					}
				break;
			case B_LINE :
				COPYRGB( tpixel, scanbuf[x] );
				break;
			default :
				rt_log( "unknown buffering scheme %d\n",
					pix_buffered );
a1942 5
				}
			/* Add current RGB values to accumulator pixel.	*/
			pixel[RED] += tpixel[RED];
			pixel[GRN] += tpixel[GRN];
			pixel[BLU] += tpixel[BLU];
d1945 14
a1958 1
	/* Write out pixel, depending on buffering scheme.		*/
d1969 1
a1969 1
		/* Buffered writes to frame buffer.			*/
d1988 3
a1990 1
/*	v i e w _ b o l ( )						*/
d1994 2
a1995 2
	{	int	x = grid_x_org + x_fb_origin;
		int	y = ap->a_y/aperture_sz + y_fb_origin;
d2013 3
a2015 1
/*	v i e w _ e o l ( )						*/
d2018 6
a2023 6
register struct application	*ap;
RGBpixel			scanbuf[];
	{	int	x = grid_x_org + x_fb_origin;
		int	y = ap->a_y/aperture_sz + y_fb_origin;
		int	ct = (ap->a_x - grid_x_org)/aperture_sz;
	/* Reset horizontal pixel position.				*/
d2043 4
d2051 1
a2051 1
			{	char	ystr[5];
d2060 2
a2061 1
				rt_log( "Write of scan line %d failed.\n", ap->a_y );
d2073 3
a2075 1
/*	v i e w _ e n d ( )						*/
d2082 2
a2083 1
		rt_log( "Refraction stats : hits=%d misses=%d inside=%d total=%d\n",
d2095 5
d2116 4
a2119 1
/*	g a u s s_ w g t _ f u n c ( ) by Douglas A. Gwyn
d2143 3
a2145 3
register struct application	*ap;
register struct partition	*pp;
struct region			*reg1, *reg2;
d2147 1
a2147 1
		fastf_t	depth = pp->pt_outhit->hit_dist - pp->pt_inhit->hit_dist;
d2170 3
a2172 3
struct application	*ap;
struct partition	*pp;
struct region		*reg1, *reg2;
@


9.3
log
@Changed the 2nd arg to fb_[rw]pixel to be a ptr. rather than just an
	RGBpixel.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 9.2 89/05/22 12:24:39 moss Locked $ (BRL)";
d113 3
a115 3
static int		refrac_missed;
static int		refrac_inside;
static int		refrac_total;
d118 2
a119 2
static int		hits_shadowed;
static int		hits_lit;
d126 2
a127 2
static fastf_t	a_cellsz; /* cell size taking anti-aliasing into account */
static fastf_t	grid_dh[3], grid_dv[3];
d141 3
a143 3
static bitv_t	hl_bits[1024][1024/HL_BITVBITS];
static short		*hl_regmap = NULL;
static unsigned short	*hl_dstmap = NULL;
d185 3
a187 3
STATIC fastf_t		myIpow();
STATIC fastf_t		correct_Lgt();
STATIC fastf_t		*mirror_Reflect();
d190 1
a190 1
STATIC int		f_Model(), f_Probe(), f_Shadow(), f_HL_Hit(), f_Region();
d192 1
a192 1
STATIC int		f_Backgr(), f_Error(), f_Lit(), f_HL_Miss(), f_R_Miss();
d194 1
a194 1
STATIC int		f_Overlap(), f_NulOverlap();
d196 1
a196 1
STATIC int		refract();
d198 3
a200 3
STATIC void		model_Reflectance();
STATIC void		glass_Refract();
STATIC void		view_pix(), view_bol(), view_eol(), view_end();
d202 3
a204 3
void			cons_Vector();
void			render_Model();
void			render_Scan();
a205 12
#if defined( cray ) && 0
#define BYTE_OFFSET(p)	(((long)(p)&0xE000000000000000)>>61)
#define WORD_ADDR(p)	((long)(p)&0xFFFFFF)
/* Work around for loop-optimization bug.				*/
incr_Ptr( pp )
RGBpixel	**pp;
	{
	(*pp)++;
	return;
	}
#endif

d222 1
a222 1
		cell_sz = view_size/ (fastf_t) gsize;
d250 3
a252 1
/*	r e n d e r _ M o d e l ( )					*/
d255 2
a256 2
int	frame;
	{	int	x;
d390 4
a393 4
	{	fastf_t		grid_y_inc[3], grid_x_inc[3];
		RGBpixel	scanbuf[1024];
		register int	com;
		int		cpu;	/* local CPU number */
d397 1
a397 1
		struct application	a;
d441 2
a442 1
			/* Compute vectors from center to origin (bottom-left) of grid.	*/
d452 2
a453 1
					{ /* Parallel rays emanating from grid.	*/
d459 6
a464 5
				/* Fire a ray at model from the zeroth point-light-
					source position "lgts[0].loc" through each
					grid cell. The closer the source is to the
					grid, the more perspective there will be;
				 */
d467 1
a467 1
					/* Compute ray direction.		*/
d473 1
a473 1
				a.a_level = 0;	 /* Recursion level (bounces).	*/
d513 5
a517 5
	{	register struct partition	*pp;
		register struct region		*regp;
		register struct soltab		*stp;
		register struct xray		*rp;
		register struct hit		*ihitp;
d949 5
a953 1
	
d978 2
a979 1
			cons_Vector( lgt_cntr, lgt_entry->azim, lgt_entry->elev );
d993 2
a994 1
			rt_log( "\t\tcos. of angle to lgt center = %g\n", cos_angl );
d996 4
a999 2
			rt_log( "\t\t	    relative radius = %g\n", rel_radius );
			rt_log( "\t\t	relative distance = %g\n", ang_dist/rel_radius );
d1001 1
a1001 1
		/* Return weighted and attenuated light intensity.	*/
d1005 1
a1005 1
	else	/* Return attenuated light intensity.			*/
d1434 1
a1434 1
		{ /* Have hit the EXPLICIT light source, no shadow.	*/
d1442 1
a1442 1
			/* Have hit the EXPLICIT light source.		*/
d1444 4
d1462 1
a1462 1
		/* Light source is obstructed, object shadowed.		*/
d1469 1
a1469 1
	else	/* Full intensity of light source.			*/
d1507 5
a1511 5
register struct application	*ap;
struct partition		*pp;
Mat_Db_Entry			*mdb_entry;
register Lgt_Source		*lgt_entry;
fastf_t				*view_dir;
d1513 5
a1517 5
		register fastf_t	*norml = pp->pt_inhit->hit_normal;
		register fastf_t	ff;		/* temp */
		fastf_t			lgt_energy;
		fastf_t			cos_il; /* Cos. incident angle.	*/
		auto fastf_t		lgt_dir[3];
@


9.2
log
@Changed the name of ipow() to myIpow() to prevent name collision on
	Convex systems.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 9.1 89/05/19 06:13:29 moss Locked $ (BRL)";
d1768 1
a1768 1
			if( fb_rpixel( fbiop, rpixp[x] ) == -1 )
d1866 2
a1867 1
				    ||	fb_rpixel( fbiop, tpixel ) == -1
@


9.1
log
@Release_3.5
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 8.9 89/05/12 23:27:46 moss Exp $ (BRL)";
d185 1
a185 1
STATIC fastf_t		ipow();
d1260 1
a1260 1
					ipow( cos_s, mdb_entry->shine );
d1583 1
a1583 1
					ipow( cos_s, mdb_entry->shine );
d1650 1
a1650 1
ipow( d, n )
@


8.9
log
@pre release changes
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 8.8 89/04/14 12:20:55 moss Exp $ (BRL)";
@


8.8
log
@Fixed declaration of render_Scan to type 'void'.  Rt_parallel is now
declared as taking a function of type 'void'.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 8.7 89/03/13 16:41:38 moss Locked $ (BRL)";
d24 1
a24 4
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
a25 1
#include "./lgt.h"
a28 1
#include "./extern.h"
d122 5
a126 4
static int curr_scan;		/* current scan line number */
static int last_scan;		/* last scan */
static int nworkers;		/* number of workers now running */
static int a_gridsz;
d185 3
a187 3
_LOCAL_ fastf_t		ipow();
_LOCAL_ fastf_t		correct_Lgt();
_LOCAL_ fastf_t		*mirror_Reflect();
d190 1
a190 1
_LOCAL_ int		f_Model(), f_Probe(), f_Shadow(), f_HL_Hit(), f_Region();
d192 1
a192 1
_LOCAL_ int		f_Backgr(), f_Error(), f_Lit(), f_HL_Miss(), f_R_Miss();
d194 1
a194 1
_LOCAL_ int		f_Overlap(), f_NulOverlap();
d196 1
a196 1
_LOCAL_ int		refract();
d198 3
a200 3
_LOCAL_ void		model_Reflectance();
_LOCAL_ void		glass_Refract();
_LOCAL_ void		view_pix(), view_bol(), view_eol(), view_end();
d218 44
a276 1
		ag.a_overlap = report_overlaps ? f_Overlap : f_NulOverlap;
d284 1
d303 1
a303 1
		max_bounce = 0;
d310 1
a312 1
	ag.a_onehit = max_bounce > 0 ? 0 : 1;
d316 4
d330 6
a335 7
	if( save_view_flag )
		{ /* Saved view from GED, match view size.		*/
		if( rel_perspective != 0.0 )
			/* Animation sequence, perspective gridding.	*/
			cell_sz = EYE_SIZE / (fastf_t) a_gridsz;
		else
			cell_sz = view_size / (fastf_t) a_gridsz;
d337 1
a337 2
	else
		cell_sz = modl_radius * 2.0/ (fastf_t) a_gridsz * grid_scale;
d340 2
a342 3
	Scale2Vec( grid_hor, cell_sz, grid_dh );
	Scale2Vec( grid_ver, cell_sz, grid_dv );

d414 3
d426 7
a434 3
		a.a_hit = ag.a_hit;
		a.a_miss = ag.a_miss;
		a.a_overlap = ag.a_overlap;
a435 3
		a.a_rt_i = ag.a_rt_i;
		a.a_rbeam = ag.a_rbeam;
		a.a_diverge = ag.a_diverge;
d508 1
a508 1
_LOCAL_ int
d516 1
a516 1
_LOCAL_ int
d577 1
a577 1
_LOCAL_ int
d589 1
a589 1
_LOCAL_ int
d634 1
a634 1
_LOCAL_ bool
d683 1
a683 1
_LOCAL_ int
d918 1
a918 1
_LOCAL_ fastf_t
d937 3
a939 1
		ap_hit = *ap;
a942 1
		ap_hit.a_overlap = ap->a_overlap;
d1009 1
a1009 1
_LOCAL_ fastf_t *
d1042 1
a1042 1
_LOCAL_ void
d1053 1
a1053 1
	ap_ref.a_overlap = ap->a_overlap;
d1224 1
a1224 1
_LOCAL_ int
d1278 1
a1278 1
_LOCAL_ int
d1291 1
a1291 1
_LOCAL_ int
d1303 1
a1303 1
_LOCAL_ int
d1343 1
a1343 1
_LOCAL_ int
d1405 1
a1405 1
_LOCAL_ int
d1500 1
a1500 1
_LOCAL_ void
d1649 1
a1649 1
_LOCAL_ fastf_t
d1748 4
d1759 1
d1770 3
a1772 1
				fb_log( "hl_Postprocess: Failed to read pixel <%d,%d>\n", x, y );
d1806 1
a1806 1
				FB_WPIXEL( fbiop, white_pixel );
d1810 1
a1810 1
				FB_WPIXEL( fbiop, black_pixel );
d1819 1
a1819 1
_LOCAL_ void
d1920 1
a1920 1
_LOCAL_ void
d1943 1
a1943 1
_LOCAL_ void
d1996 1
a1996 1
_LOCAL_ void
d2052 1
a2052 1
_LOCAL_ int
d2078 1
a2078 1
_LOCAL_ int
@


8.7
log
@Fixed signal handler declarations.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 8.6 89/03/08 17:03:43 moss Locked $ (BRL)";
d208 1
d357 1
@


8.6
log
@Enlarged BEHIND_ME_TOL to 0.01 to allow the single-precision math library
on the IRIS 3030 to discount bogus shadows, etc.  Hopefully this is safe
in the general case.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 8.5 88/12/15 16:11:21 moss Locked $ (BRL)";
a207 5
#if defined( BSD ) || (defined( SYSV ) && ! defined( mips ))
int	abort_RT();
#else
void	abort_RT();
#endif
a208 1

a1575 3
#if defined( BSD ) || (defined( SYSV ) && ! defined( mips ))
int
#else
d1577 1
d1579 2
d1590 3
a1592 1
#if defined( BSD )
a1593 2
#else
	return;
@


8.5
log
@Fixed the material id lookup logic to check for a reg_mater entry with
mid=<digits> as part of the parameter string.  If found, this is used
as the material id rather than looking in reg_gmater.
This capability allows material id to be inherited from groups downward
rather than necessitating creating super-regions.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 8.4 88/10/19 15:19:06 moss Exp $ (BRL)";
d149 8
a156 1
#define BEHIND_ME_TOL	0.001	/* Is object behind me. */
@


8.4
log
@Adapted to changes in multi-tasking support of LIBRT by calling render_Scan
	without an argument.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 8.3 88/10/19 11:00:06 moss Locked $ (BRL)";
d19 5
d570 60
d686 2
a687 1
	material_id = (int)(pp->pt_regionp->reg_gmater);
@


8.3
log
@Added distance discriminant map to hiddenline drawing model.
About to change to new interface for "worker" processes in multi-tasking
	support.  The new interface has no argument passed to the "worker"
	function.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 7.3 88/01/07 12:04:57 moss Locked $ (BRL)";
d121 4
a124 4
/* Local communication with worker(). */
static int curr_scan;		/* Current scan line number. */
static int last_scan;		/* Last scan. */
static int nworkers;		/* Number of workers now running. */
d127 1
a127 1
static struct application ag;	/* Global application structure. */
d219 1
a219 1
	{
d327 1
a327 1
		render_Scan(0);
d338 7
d350 1
a350 2
render_Scan( cpu )
int	cpu;
d353 2
a359 1
		register int com;
d361 1
a361 1
	com = nworkers++;
@


8.2
log
@Fixed bug in turning off shadows, was circumventing correct_Lgt()
	which is still necessary for gaussian beam weighting.
@
text
@d29 2
a30 1
extern void	rt_parallel();
d32 6
d97 1
a97 2
#define TWO_PI		6.28318530717958647692528676655900576839433879875022
#define RI_AIR		1.0	/* Refractive index of air.		*/
d100 10
a109 10
				0,		/* Material id.		*/
				4,		/* Shininess.		*/
				0.6,		/* Specular weight.	*/
				0.3,		/* Diffuse weight.	*/
				0.0,		/* Reflectivity.	*/
				0.0,		/* Transmission.	*/
				1.0,		/* Refractive index.	*/
				255, 255, 255,	/* Diffuse RGB values.	*/
				MF_USED,	/* Mode flag.		*/
				"(default)"	/* Material name.	*/
d112 1
a112 1
/* Collect statistics on refraction.					*/
d117 1
a117 1
/* Collect statistics on shadowing.					*/
d121 4
a124 4
/* Local communication with worker().					*/
static int curr_scan;		/* Current scan line number.		*/
static int last_scan;		/* Last scan.				*/
static int nworkers;		/* Number of workers now running.	*/
d127 1
a127 1
static struct application ag;	/* Global application structure.	*/
d129 1
a129 1
/* Bit map for hidden line drawing.					*/
d141 2
a142 1
static short	*hl_regmap = NULL;
d242 2
a243 1
		if( (hl_regmap = (short *) malloc( (unsigned)(grid_sz*grid_sz)*sizeof(short) ))
d246 7
a252 4
			{
			Malloc_Bomb( grid_sz*grid_sz*sizeof(short) );
			return;
			}
d522 4
a525 1
	hl_regmap[ap->a_y*grid_sz+ap->a_x] = 0;
d549 6
a554 1
	hl_regmap[ap->a_y*grid_sz+ap->a_x] = pp->pt_regionp->reg_regionid;
d1539 18
a1556 2
#define COSTOL	0.91
#define is_Odd(_a)	((_a)&01)
d1561 1
a1561 1
#if 0
d1628 1
d1656 8
a1663 4
			if(	hl_Reg_Diff( x, y, x-1, y )
			     ||	hl_Reg_Diff( x, y, x, y-1 )
			     ||	hl_Norm_Diff( rpixp[x], rpixp[x-1] )
			     ||	hl_Norm_Diff( rpixp[x], lpixp[x] )
d1885 10
a1894 1
		free( (char *) hl_regmap );
@


8.1
log
@Release_3.0
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 7.13 88/10/04 13:13:43 moss Locked $ (BRL)";
d783 3
a785 10
	{	struct application	ap_hit;
	/* Set up application struct for 'rt_shootray()' to light source.	*/
	ap_hit = *ap;
	ap_hit.a_onehit = FALSE;  /* Go all the way to the light.	*/
	ap_hit.a_hit = f_Shadow; /* Handle shadowed pixels.		*/
	ap_hit.a_miss = f_Lit;   /* Handle illuminated pixels.		*/
	ap_hit.a_overlap = ap->a_overlap;
	ap_hit.a_level++;	  /* Increment recursion level.		*/

	if( rt_g.debug & DEBUG_SHADOW )
d787 3
a789 2
		rt_log( "\tcorrect_Lgt()\n" );
		V_Print( "\t\tlgt source location", lgt_entry->loc, rt_log );
d791 21
a811 6
	/* Vector to light src from surface contact pt.	 		*/
	Diff2Vec(	lgt_entry->loc,
			pp->pt_inhit->hit_point,
			ap_hit.a_ray.r_dir
			);
	VUNITIZE( ap_hit.a_ray.r_dir );
d813 17
a829 2
	/* Set up ray origin at surface contact point.			*/
	VMOVE( ap_hit.a_ray.r_pt, pp->pt_inhit->hit_point );
a830 10
	if( rt_g.debug & DEBUG_SHADOW )
		{
		V_Print( "\t\tdir. of ray to light", ap_hit.a_ray.r_dir, rt_log );
		V_Print( "\t\torigin of ray to lgt", ap_hit.a_ray.r_pt, rt_log );
		}
	/* Fetch attenuated light intensity into "ap_hit.a_diverge".	*/
	(void) rt_shootray( &ap_hit );
	if( ap_hit.a_diverge == 0.0 )
		/* Shadowed by opaque object(s).			*/
		return	0.0;
d832 1
a832 2
		object(s).
	 */
d846 1
a846 1
		cos_angl = Dot( lgt_cntr, ap_hit.a_ray.r_dir );
d861 1
a861 1
			lgt_entry->energy * ap_hit.a_diverge;
d864 1
a864 1
		return	lgt_entry->energy * ap_hit.a_diverge;
a1384 3
		if( ! shadowing ) /* No shadows. */
			lgt_energy = lgt_entry->energy;
		else
@


7.13
log
@Trying to unlock from RCS.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 7.12 88/10/04 11:09:36 wm Locked $ (BRL)";
@


7.12
log
@Fixed bug in placement of view_end() in non-parallel case.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 7.3 88/01/07 12:04:57 moss Locked $ (BRL)";
@


7.11
log
@Turned OFF FLIPPED_NORMALS_BUG define.
@
text
@d317 2
@


7.10
log
@Turned on FLIPPED_NORMALS_BUG since it still exists.
@
text
@d32 1
a32 1
#define FLIPPED_NORMALS_BUG	TRUE /* Keep an eye out for dark spots. */
@


7.9
log
@Added more checking for flipped normals.
Added support for distributed processing (/dev/remote).
Converted some ScaleVec and Scale2Vec macro calls to VREVERSE.
@
text
@d32 1
a32 1
#define FLIPPED_NORMALS_BUG	FALSE /* Keep an eye out for dark spots. */
@


7.8
log
@See comment in other modules about addition of shadow switch, being
	inside a solid, and converting to use librt/machine.c.
@
text
@d30 6
a35 4
/* WARNING: These checks are still necessary in ARSes because of bug in LIBRT
	which flips normals */
#define Check_Iflip( _pp, _normal, _rdir, _stp )\
	{	fastf_t	f;\
d38 1
a38 1
		ScaleVec( _normal, -1.0 );\
d41 6
a46 1
	f = Dot( _rdir, _normal );\
d51 2
a52 1
			V_Print( "Fixed flipped entry normal, was", _normal, rt_log );\
d55 1
a55 1
		ScaleVec( _normal, -1.0 );\
d58 3
d62 2
a63 4
/* WARNING: These checks are still necessary in ARSes because of bug in LIBRT
	which flips normals */
#define Check_Oflip( _pp, _normal, _rdir, _stp )\
	{	fastf_t	f;\
d66 1
a66 1
		ScaleVec( _normal, -1.0 );\
d69 6
a74 1
	f = Dot( _rdir, _normal );\
d79 2
a80 1
			V_Print( "Fixed flipped exit normal, was", _normal, rt_log );\
d83 1
a83 1
		ScaleVec( _normal, -1.0 );\
d86 3
d196 1
a196 1
#ifdef cray
d391 1
a391 1
					Scale2Vec( lgts[0].dir, -1.0, a.a_ray.r_dir );
d466 1
d524 1
a524 1
	Check_Iflip( pp, ihitp->hit_normal, ap->a_ray.r_dir, stp );
d565 1
a566 1
	Check_Iflip( pp, ihitp->hit_normal, ap->a_ray.r_dir, stp );
d572 1
a572 1
	Check_Oflip( pp, ohitp->hit_normal, ap->a_ray.r_dir, stp );
d700 1
a700 1
	Scale2Vec( ap->a_ray.r_dir, -1.0, view_dir );
d868 2
a869 1
		rt_log( "\t\tOne hit flag is %s\n", ap_hit.a_onehit ? "ON" : "OFF" );
d872 2
a873 1
	Scale2Vec( ap->a_ray.r_dir, -1.0, r_dir );
d1160 1
d1165 1
a1165 1
		ScaleVec( ap->a_uvec, -1.0 );
d1216 1
a1216 1
		Scale2Vec( v_1, -1.0, u );
d1265 1
d1267 1
d1792 15
@


7.7
log
@Did away with texture file commands, and added textures to material
properties data base.
@
text
@d29 1
a99 1
#ifdef PARALLEL
a100 1
#endif
a151 9
#ifdef cray
int	render_Scan();
struct taskcontrol {
	int	tsk_len;
	int	tsk_id;
	int	tsk_value;
} taskcontrol[MAX_PSW];
#endif

a194 6
#ifdef alliant
	register int	d7;	/* known to be in d7 */
#endif
#ifdef PARALLEL
	int		a, x;
#endif
a195 1
#ifdef PARALLEL
d198 1
a198 1
#endif
d293 8
a300 1
#ifdef PARALLEL
a302 1
	 *  The workers are started and terminated here.
d305 2
a306 37
#ifdef cray
	/* Create any extra worker tasks */
RES_ACQUIRE( &rt_g.res_worker );
	for( x=1; x<npsw; x++ ) {
		taskcontrol[x].tsk_len = 3;
		taskcontrol[x].tsk_value = x;
		TSKSTART( &taskcontrol[x], render_Scan, x );
	}
for( x=0; x<1000000; x++ ) a=x+1;	/* take time to get started */
RES_RELEASE( &rt_g.res_worker );
	render_Scan(0);	/* avoid wasting this task */
	/* Wait for them to finish */
	for( x=1; x<npsw; x++ )  {
		TSKWAIT( &taskcontrol[x] );
	}
#endif
#ifdef alliant
	{
		asm("	movl		_npsw,d0");
		asm("	subql		#1,d0");
		asm("	cstart		d0");
		asm("super_loop:");
		render_Scan(d7);	/* d7 has current index, like magic */
		asm("	crepeat		super_loop");
	}
#endif
	/* Ensure that all the workers are REALLY dead */
	x = 0;
	while( nworkers > 0 )  x++;
	if( x > 0 )
		rt_log( "Termination took %d extra loops\n", x );
#else
	/*
	 * SERIAL case -- one CPU does all the work.
	 */
	render_Scan( 0 );
#endif
a321 1
#ifdef PARALLEL
a325 1
	a.a_resource = &resource[cpu];
d327 1
a327 3
#else
	a.a_resource = RESOURCE_NULL;
#endif
d345 2
a409 1
#ifdef PARALLEL
a412 1
#endif
d431 2
a432 1
		register struct xray		*rayp;
d436 2
a437 1
	rayp = &ap->a_ray;
d439 10
a448 1
	VJOIN1( ihitp->hit_point, rayp->r_pt, ihitp->hit_dist, rayp->r_dir );
d455 5
d531 1
d537 10
a546 1
	RT_HIT_NORM( ihitp, stp, &(ap->a_ray) );
a547 1

d821 3
a823 3
			rt_log( "\t\t           angular distance = %g\n", ang_dist );
			rt_log( "\t\t            relative radius = %g\n", rel_radius );
			rt_log( "\t\t        relative distance = %g\n", ang_dist/rel_radius );
d1346 3
@


7.6
log
@Fixed bug in hit routines: by using a tolerance of 0.1 mm for hits
behind the ray origin and tossing them out small objects were not
being rendered.  Also, the logic for recovering from this could
cause the pt_outhit of the pt_headp to be accessed erroneously.
The tolerance was decreased to 0.01mm and placed in BEHIND_ME_TOL
with common macro Get_Partition used everywhere.
@
text
@d120 1
a120 1
#define BEHIND_ME_TOL	0.01	/* Is object behind me. */
d125 1
a125 1
#define Get_Partition( pp, pt_headp )\
d133 5
a137 1
		;\
d143 4
a146 1
		rt_log( "BUG: f_Model: Bad partition returned by rt_shootray!\n" );\
d483 1
a483 1
	Get_Partition( pp, pt_headp );
d535 1
a535 1
	Get_Partition( pp, pt_headp );
d567 1
a567 1
	Get_Partition( pp, pt_headp );
d599 1
a599 10
#ifndef cray
	if( icon_mapping && strncmp( stp->st_name, "TM_", 3 ) == 0 )
		{ /* Solid has a texture map.				*/
			struct uvcoord	uv;
		rt_functab[stp->st_id].ft_uv( ap, stp, ihitp, &uv );
		material_id = txtr_Val( &uv );
		}
	else
#endif
		material_id = (int)(pp->pt_regionp->reg_gmater);
d672 1
a672 8
	if( fb_mapping && strncmp( stp->st_name, "FB_", 3 ) == 0 )
		{ /* Solid has a frame buffer image map.		*/
			struct uvcoord	uv;
		rt_functab[stp->st_id].ft_uv( ap, stp, ihitp, &uv );
		if( (entry = fb_Entry( &uv )) == MAT_DB_NULL )
			entry = &mat_dfl_entry;
		}
	else	/* Get material attributes from database.		*/
d677 10
a686 1

d949 2
a950 1
				V_Print( "\t\tf_Model returned coeffs", ap->a_color, rt_log );
d962 2
a963 1
				V_Print( "\t\tf_Backgr returned coeffs", ap->a_color, rt_log );
d1160 1
a1160 1
	Get_Partition( pp, pt_headp );
d1177 1
a1177 1
	Using Schnell's Law
d1258 1
a1258 1
	Get_Partition( pp, pt_headp );
d1478 1
a1478 1
RES_ACQUIRE( &rt_g.res_syscall );
d1482 1
a1482 1
RES_RELEASE( &rt_g.res_syscall );
@


7.5
log
@Beefed up the checking for zero refractive indices.
@
text
@d72 1
a72 2
#define RI_AIR		1.0    /* Refractive index of air.		*/

d120 26
d476 1
a476 8
	for(	pp = pt_headp->pt_forw;
		pp != pt_headp
	    &&	pp->pt_outhit->hit_dist < 0.1;
		pp = pp->pt_forw
		) 
		;
	if( pp == pt_headp || pp->pt_outhit->hit_dist < 0.1 )
		return	ap->a_miss( ap );
d528 1
a528 10

	for(	pp = pt_headp->pt_forw;
		pp != pt_headp
	    &&	pp->pt_outhit->hit_dist < 0.1;
		pp = pp->pt_forw
		) 
		;
	if( pp == pt_headp || pp->pt_outhit->hit_dist < 0.1 )
		return	ap->a_miss( ap );

d560 1
a560 10

	for(	pp = pt_headp->pt_forw;
		pp != pt_headp
	    &&	pp->pt_outhit->hit_dist < 0.1;
		pp = pp->pt_forw
		) 
		;
	if( pp == pt_headp || pp->pt_outhit->hit_dist < 0.1 )
		return	ap->a_miss( ap );

d1158 1
a1158 12
	for(	pp = pt_headp->pt_forw;
		pp != pt_headp
	    &&	pp->pt_outhit->hit_dist < 0.1;
		pp = pp->pt_forw
		) 
		;
	if( pp == pt_headp || pp->pt_outhit->hit_dist < 0.1 )
		{
		if( rt_g.debug & DEBUG_REFRACT )
			rt_log( "partition behind ray origin, no exit\n" );
		return	ap->a_miss( ap );
		}
d1256 1
a1256 12
	for(	pp = pt_headp->pt_forw;
		pp != pt_headp
	    &&	pp->pt_outhit->hit_dist < 0.1;
		pp = pp->pt_forw
		) 
		;
	if( pp == pt_headp || pp->pt_outhit->hit_dist < 0.1 )
		{
		if( rt_g.debug & DEBUG_SHADOW )
			rt_log( "partition behind ray origin, no shadow\n" );
		return	ap->a_miss( ap );
		}
@


7.4
log
@Smoothing out menu and prompting interface.
@
text
@d920 4
d1212 1
a1212 1
	if( ri_2 == 0.0 )
d1214 1
a1214 1
		rt_log( "\tZero refractive index." );
@


7.3
log
@Removed debug writes left in the hidden line stuff by mistake.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 7.2 87/12/09 13:43:17 moss Locked $ (BRL)";
d149 1
a149 1
#if defined( BSD ) || defined( SYSV )
d170 2
a171 1
render_Model()
d226 1
a226 1
	if( ! setup_Lgts() )
d263 4
d273 1
d1485 1
a1485 1
#if defined( BSD ) || defined( SYSV )
@


7.2
log
@Improvements to IR modeling interface.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 7.1 87/11/03 00:25:41 moss Locked $ (BRL)";
d1522 1
d1528 1
d1536 1
d1543 1
@


7.1
log
@Release 2.3
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 5.3 87/10/29 08:52:10 moss Exp $ (BRL)";
a13 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) reflect.c	2.3
		Modified: 	1/30/87 at 17:20:16	G S M
		Retrieved: 	2/4/87 at 08:52:40
		SCCS archive:	/vld/moss/src/lgt/s.reflect.c
*/
d29 2
d32 1
a32 1
	{\
a37 4
	}
#if 0 /* WARNING: These checks are still necessary in ARSes because of bug in LIBRT
		which flips normals */
	{	fastf_t	f;\
d41 1
a41 1
		if( ! _pp->pt_inflip && rt_g.debug )\
d48 1
a48 1
	}\
d50 2
a51 2
#endif

d53 1
a53 1
	{\
a58 4
	}
#if 0 /* WARNING: These checks are still necessary in ARSes because of bug in LIBRT
		which flips normals */
	{	fastf_t	f;\
d62 1
a62 1
		if( ! _pp->pt_outflip && rt_g.debug )\
d69 1
a69 1
	}\
a70 2
#endif

d139 1
a139 1
_LOCAL_ int		f_Overlap();
d189 1
a189 1
		ag.a_overlap = report_overlaps ? NULL : f_Overlap;
d196 1
a196 1
		ag.a_overlap = report_overlaps ? NULL : f_Overlap;
d210 1
a210 1
		ag.a_overlap = report_overlaps ? NULL : f_Overlap;
d217 1
a217 1
		ag.a_overlap = report_overlaps ? NULL : f_Overlap;
d244 1
a244 1
	if( rt_g.debug )
d603 1
a603 22
		if( ir_offset )
			{	RGBpixel	pixel;
				int	x = ap->a_x + x_fb_origin - ir_mapx;
				int	y = ap->a_y + y_fb_origin - ir_mapy;
			/* Map temperature from IR image using offsets.	*/
			RES_ACQUIRE( &rt_g.res_stats );
			if(	x < 0 || y < 0
			    ||	fb_read( fbiop, x, y, pixel, 1 ) == -1
				)
				fahrenheit = AMBIENT-1;
			else
				fahrenheit = pixel_To_Temp( (RGBpixel *) pixel );
			RES_RELEASE( &rt_g.res_stats );
			}
		else
		if( ir_doing_paint )
			/* User specified temp. of current rectangle.	*/
			fahrenheit = ir_paint;
		else
			/* Unknown temperature, use out-of-band value.	*/
			fahrenheit = AMBIENT-1;
		if( ir_table == PIXEL_NULL )
a604 1
			rt_log( "Must read real IR data or IR data base first.\n" );
d621 21
d837 1
a837 1
		if( rt_g.debug & DEBUG_GAUSS )
d1852 26
d1879 1
a1879 1
f_Overlap( ap, pp, reg1, reg2 )
@


5.3
log
@Ready for release 2.1 of BRL CAD.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 5.2 87/10/15 10:02:10 moss Locked $ (BRL)";
@


5.2
log
@Overlap function now takes ptrs to region structures rather than region names.
Fixed some bugs in hidden-line stuff, including workaround for Cray bug
	involving sign extension in integer expressions.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 5.1 87/06/24 22:48:00 mike Rel $ (BRL)";
d37 1
a37 1
	{	fastf_t	f;\
d44 3
a46 1
#if 0
d57 1
d62 1
a62 1
	{	fastf_t	f;\
d69 3
a71 1
#if 0
d82 1
d190 1
d192 1
a192 1

d216 1
a216 1
		if( (hl_regmap = (short *) malloc( grid_sz*grid_sz*sizeof(short) ))
d443 1
d518 1
a518 1
		register struct hit		*ihitp, *ohitp;
d557 1
a557 1
		register struct hit		*ihitp, *ohitp;
d576 1
d581 1
d629 1
a629 1
				fahrenheit = pixel_To_Temp( pixel );
a1128 1
/*ARGSUSED*/
@


5.1
log
@Release 1.24
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 1.3 87/06/23 12:32:46 moss Exp $ (BRL)";
d120 2
a121 2
#define HL_BITVBITS	(sizeof(bitv_t)*BITSPERBYTE)
#define HL_BITVMASK(_x)	((_x) == 0 ? 1 : 1<<(_x)%HL_BITVBITS)
d126 1
d144 1
a144 1
_LOCAL_ int		f_Model(), f_Probe(), f_Shadow(), f_HL_Hit();
d146 1
a146 1
_LOCAL_ int		f_Backgr(), f_Error(), f_Lit(), f_HL_Miss();
d200 7
d252 2
a253 1
	rt_log( "Cell size is %g mm.\n", cell_sz );
d437 59
d613 1
d615 1
a615 2
			    ||	fb_seek( fbiop, x, y ) == -1
			    ||	fb_rpixel( fbiop, pixel ) == -1
d620 1
d638 1
d643 1
d648 1
d660 2
d663 2
d1495 1
d1499 1
d1529 5
d1538 1
a1538 1
register RGBpixel	pix1, pix2;
d1541 7
a1547 1
	if( ! NonZeroVec( pix1 ) )
d1549 1
a1549 1
		if( ! NonZeroVec( pix2 ) )
d1555 1
a1555 1
	if( ! NonZeroVec( pix2 ) )
d1557 6
a1562 2
	Scale2Vec( pix1, conv, dir1 );
	Scale2Vec( pix2, conv, dir2 );
d1572 15
d1594 4
a1597 2
		{	register RGBpixel	*rpixp = is_Odd(y) ? bufb : bufa;
			register RGBpixel	*lpixp = is_Odd(y) ? bufa : bufb;
d1599 4
a1602 1
		for( x = 0; x < grid_sz && ! user_interrupt; x++ )
d1609 1
d1612 1
d1659 1
a1660 4
		(void) SetStandout();
		GRID_PIX_MOVE();
		(void) printf( " [%04d-", ap->a_x/aperture_sz );
		(void) ClrStandout();
d1720 2
d1764 3
a1766 7
		(void) SetStandout();
		GRID_SCN_MOVE();
		(void) printf( "%04d-", ap->a_y/aperture_sz );
		GRID_PIX_MOVE();
		(void) printf( " [%04d-", ap->a_x/aperture_sz );
		(void) ClrStandout();
		(void) fflush( stdout );
d1798 2
d1860 4
a1863 5
f_Overlap( ap, pp, name1, name2 )
register struct application	*ap;
register struct partition	*pp;
char				*name1;
char				*name2;
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 1.2 87/02/06 12:29:17 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes.
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header: reflect.c,v 1.1 87/02/04 15:15:03 moss Locked $ (BRL)";
d36 19
d56 24
d98 3
a100 3
static int		refract_missed;
static int		refract_inside;
static int		refract_total;
d116 13
d130 1
d143 1
a143 1
_LOCAL_ int		do_Model(), do_Probe(), do_Shadow();
d145 3
a147 1
_LOCAL_ int		do_Backgr(), do_Error(), do_Lit();
d153 1
a153 1
_LOCAL_ void		view_pix(), view_eol(), view_end();
d157 1
a157 1
#if defined( BSD ) || defined( sgi )
d164 12
d184 2
d187 2
a188 1
	pix_buffered = B_LINE;
d194 3
a196 2
		ag.a_hit = do_IR_Model;
		ag.a_miss = do_IR_Backgr;
d199 1
d201 11
a211 2
		ag.a_hit = do_Model;
		ag.a_miss = do_Backgr;
d213 7
a219 1
	ag.a_rt_i = &rt_i;
d226 2
d229 1
a229 1

d244 2
d250 3
a252 3
	refract_missed = 0;
	refract_inside = 0;
	refract_total = 0;
d315 1
a322 1
		RGBpixel	*scanp;	/* Pointer into line buffer.	*/
d351 2
d364 1
a364 1
			view_eol( &a, (RGBpixel *) scanbuf, scanp ), a.a_y++
d367 2
a371 1
			scanp = scanbuf;
d375 1
a375 1
				view_pix( &a, scanp ), a.a_x++
a377 9
				if( anti_aliasing )
					{
					if( a.a_x > grid_x_org * aperture_sz
					    &&	a.a_x % aperture_sz == 0
						)
						scanp++;
					}
				else
					scanp++;
d415 1
a415 1
				AddVec( grid_x_inc, grid_dh )
d427 43
a469 1
/*	d o _ M o d e l ( )
d475 1
a475 1
do_Model( ap, PartHeadp )
d477 1
a477 1
struct partition *PartHeadp;
d484 3
a486 2
	for(	pp = PartHeadp->pt_forw;
		pp != PartHeadp
d491 1
a491 1
	if( pp == PartHeadp || pp->pt_outhit->hit_dist < 0.1 )
d493 1
d497 1
d499 1
a499 6
	/* Check for flipped normal and fix.				*/
	if( pp->pt_inflip )
		{
		ScaleVec( ihitp->hit_normal, -1.0 );
		pp->pt_inflip = 0;
		}
d503 2
a504 5
	if( pp->pt_outflip )
		{
		ScaleVec( ohitp->hit_normal, -1.0 );
		pp->pt_outflip = 0;
		}
a505 9
	{	fastf_t f = Dot( ap->a_ray.r_dir, ihitp->hit_normal );
	if( f >= 0.0 )
		{
		ScaleVec( ihitp->hit_normal, -1.0 );
		if( rt_g.debug )
			rt_log( "Fixed flipped entry normal\n" );
		}
	}

d523 1
d528 1
a528 1
		material_id = texture_Val( &uv );
d531 1
d554 1
a554 1
		if( ir_paint_flag )
a608 4
		{
		rt_log( "No material database entry for %d, using default.\n",
			material_id
			);
a609 1
		}
d646 3
a648 3
					rt_log( "light %d returns\n", i );
					V_Print( "ap->a_color", ap->a_color, rt_log );
					V_Print( "rgb_coefs", rgb_coefs, rt_log );
d714 4
a717 3
	ap_hit.a_onehit = 0;	  /* Go all the way to the light.	*/
	ap_hit.a_hit = do_Shadow; /* Handle shadowed pixels.		*/
	ap_hit.a_miss = do_Lit;   /* Handle illuminated pixels.		*/
d722 2
a723 2
		rt_log( "correct_Lgt()\n" );
		V_Print( "light loc", lgt_entry->loc, rt_log );
d737 2
a738 2
		V_Print( "ray to light", ap_hit.a_ray.r_dir, rt_log );
		V_Print( "origin of ray", ap_hit.a_ray.r_pt, rt_log );
d769 4
a772 4
			rt_log( "cos_angl=%g\n", cos_angl );
			rt_log( "ang_dist=%g\n", ang_dist );
			rt_log( "rel_radius=%g\n", rel_radius );
			rt_log( "rel_dist=%g\n", ang_dist/rel_radius );
d790 1
d794 6
a799 2
		rt_log( "mirror_Reflect()\n" );

d823 4
a826 2
	ap_ref.a_hit =  do_Probe;	/* Find exit from glass.	*/
	ap_ref.a_miss = do_Error;	/* Bad news.			*/
d831 1
d836 1
a836 1
		rt_log( "Entering glass_Refract(), level %d grid <%d,%d>\n",
d839 2
a840 2
		V_Print( "\tincident ray pnt", ap->a_ray.r_pt, rt_log );
		V_Print( "\tincident ray dir", ap->a_ray.r_dir, rt_log );
d842 1
a842 1
	refract_total++;
d846 1
d848 5
a852 2
			rt_log( "\tNo refraction on entry.\n" );
		/* Ray direction stays the same, origin becomes exit pt.*/
d854 31
a884 2
		VMOVE( ap_hit.a_ray.r_pt, pp->pt_outhit->hit_point );
		goto	exiting_ray;
d892 1
a892 1
				rt_log( "\tRefracting inside solid.\n" );
d908 1
a908 1
				rt_log( "\tPast critical angle on entry!\n" );
d925 3
a927 3
			rt_log( "\tRefracted ray missed!\n" );
			V_Print( "\trefracted ray pnt", ap_ref.a_ray.r_pt, rt_log );
			V_Print( "\trefracted ray dir", ap_ref.a_ray.r_dir, rt_log );
d929 1
a929 1
		refract_missed++;
d937 1
a937 1
			rt_log( "\tRefracted ray hit.\n" );
d953 1
a953 1
				rt_log( "\tInternal reflection, recursion level (%d)\n", ap_ref.a_level );
d965 2
a966 2
			rt_log( "\tExceeded max bounces with internal reflections, recursion level (%d)\n", ap_ref.a_level );
		refract_inside++;
d974 7
d986 1
a986 1
/*	d o _ B a c k g r ( )
d991 1
a991 1
do_Backgr( ap )
d999 2
a1000 2
		rt_log( "do_Backgr()\n" );
		V_Print( "bg_coefs", ap->a_color, rt_log );
d1005 6
a1010 2
		{	Mat_Db_Entry	*mdb_entry =
					mat_Get_Db_Entry( ap->a_user );
d1037 1
a1037 1
		V_Print( "ap->color final", ap->a_color, rt_log );
d1042 1
a1042 1
/*	d o _ E r r o r ( )						*/
d1044 1
d1046 1
a1046 1
do_Error( ap )
d1050 1
a1050 1
		rt_log( "do_Error()\n" );
d1054 1
a1054 1
/*	d o _ L i t ( )
d1059 1
a1059 1
do_Lit( ap )
d1063 1
a1063 1
		rt_log( "do_Lit()\n" );
d1069 1
a1069 1
/*	d o _ P r o b e ( )						*/
d1071 1
a1071 1
do_Probe( ap, PartHeadp )
d1073 1
a1073 1
struct partition *PartHeadp;
d1078 3
a1080 3
		rt_log( "do_Probe()\n" );
	for(	pp = PartHeadp->pt_forw;
		pp != PartHeadp
d1085 1
a1085 1
	if( pp == PartHeadp || pp->pt_outhit->hit_dist < 0.1 )
d1129 3
a1131 3
		V_Print( "Entering refract(), incident ray", v_1, rt_log );
		V_Print( "\tentrance normal", norml, rt_log );
		rt_log( "\trefractive indices leaving:%g, entering:%g\n", ri_1, ri_2 );
d1177 1
a1177 1
/*	d o _ S h a d o w ( )
d1183 1
a1183 1
do_Shadow( ap, PartHeadp )
d1185 1
a1185 1
struct partition *PartHeadp;
d1188 2
a1189 2
	for(	pp = PartHeadp->pt_forw;
		pp != PartHeadp
d1194 1
a1194 1
	if( pp == PartHeadp || pp->pt_outhit->hit_dist < 0.1 )
a1210 1
		V_Print( "exit normal", ohitp->hit_normal, rt_log );
a1211 1
		V_Print( "exit point", ohitp->hit_point, rt_log );
d1224 1
a1224 1
	for( ; pp != PartHeadp; pp = pp->pt_forw )
d1229 6
a1234 1
		entry = mat_Get_Db_Entry( (int)(pp->pt_regionp->reg_gmater) );
d1301 3
a1303 1
		rt_log( "model_Reflectance()\n" );
d1333 7
a1339 6
		V_Print( "norml", norml, rt_log );
		V_Print( "lgt_dir", lgt_dir, rt_log );
		rt_log( "cos_il=%g\n", cos_il );
		rt_log( "lgt_energy=%g\n", lgt_energy );
		rt_log( "wgt_diffuse=%g\n", mdb_entry->wgt_diffuse );
		V_Print( "diffuse reflectance", ap->a_color, rt_log );
d1355 1
a1355 1
		ff = 2 * cos_il;
d1360 3
a1362 2
			V_Print( "view_dir", view_dir, rt_log );
			V_Print( "lgt_reflect", lgt_reflect, rt_log );
d1374 3
a1376 3
				rt_log( "cos_s=%g\n", cos_s );
				rt_log( "specular=%g\n", specular );
				V_Print( "w/ specular", ap->a_color, rt_log );
d1381 6
a1386 3
			{
			rt_log( "model_Reflectance() : cos(s) > 1.0 (%g)!\n", cos_s );
			V_Print( "norml", norml, rt_log );
d1410 1
a1410 1
#if defined( BSD ) || defined( sgi )
a1419 2
	if( tty )
		prnt_Event( "Aborted raytrace." );
d1445 88
d1535 1
a1535 1
view_pix( ap, scanp )
d1537 1
a1537 1
register RGBpixel		*scanp;
d1543 1
a1543 1
		RES_ACQUIRE( &rt_g.res_malloc );
d1551 1
a1551 1
		RES_RELEASE( &rt_g.res_malloc );
d1594 1
a1594 1
				COPYRGB( tpixel, *scanp );
d1616 4
a1619 4
		if(	fb_seek( fbiop, x, y ) != -1
		    &&	fb_wpixel( fbiop, pixel ) != -1
			)
			/* Buffered writes to frame buffer.		*/
d1621 1
d1624 1
a1624 1
		COPYRGB( *scanp, pixel );
d1635 1
a1635 1
/*	v i e w _ e o l ( )						*/
d1637 1
a1637 1
view_eol( ap, scanbuf, scanp )
a1638 1
register RGBpixel		*scanbuf, *scanp;
d1644 1
a1644 1
		(void) fb_cursor( fbiop, 1, x_fb_origin, y );
a1646 3
	/* Reset horizontal pixel position.				*/
	ap->a_x = grid_x_org * aperture_sz;

a1649 1
		prnt_Timer( (char *) NULL );
d1656 21
d1691 1
a1691 1
		if( fb_write( fbiop, x, y, scanbuf, scanp-scanbuf+1 ) == -1 )
d1706 2
a1707 2
			refract_total-(refract_missed+refract_inside),
			refract_missed, refract_inside, refract_total
d1713 6
a1718 1
	RES_ACQUIRE( &rt_g.res_malloc );
a1719 1
	RES_RELEASE( &rt_g.res_malloc );
d1744 11
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a23 1
#include <std.h>
a24 1
#include <fb.h>
d26 7
a32 6
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
#include <mat_db.h>
#include <vecmath.h>
#include <lgt.h>
d34 1
a35 1
#include "./screen.h"
a112 7
	if( tty )
		{
		rt_prep_timer();
		prnt_Event( "Raytracing..." );
		SCROLL_DL_MOVE();
		(void) fflush( stdout );
		}
d169 7
a1242 1
		{
a1243 2
		(void) fflush( stdout );
		}
@
