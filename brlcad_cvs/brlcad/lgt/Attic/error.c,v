head	11.13;
access;
symbols
	ansi-20040405-merged:11.10.2.1
	postmerge-20040405-ansi:11.11
	premerge-20040404-ansi:11.10
	postmerge-autoconf:11.10
	autoconf-freeze:11.10
	premerge-autoconf:11.10
	ansi-20040316-freeze:11.10.2.1
	postmerge-20040315-windows:11.10
	premerge-20040315-windows:11.10
	windows-20040315-freeze:11.10
	autoconf-20031203:11.10
	autoconf-20031202:11.10
	autoconf-branch:11.10.0.10
	phong-branch:11.10.0.8
	photonmap-branch:11.10.0.6
	rel-6-1-DP:11.10
	windows-branch:11.10.0.4
	rel-6-0-2:11.8
	ansi-branch:11.10.0.2
	rel-6-0-1-branch:11.8.0.2
	hartley-6-0-post:11.9
	hartley-6-0-pre:11.8
	rel-6-0-1:11.8
	rel-6-0:11.8
	rel-5-4:11.6
	offsite-5-3-pre:11.7
	rel-5-3:11.6
	rel-5-2:11.6
	rel-5-1-branch:11.6.0.2
	rel-5-1:11.6
	rel-5-0:11.5
	rel-5-0-beta:11.4
	rel-4-5:11.4
	ctj-4-5-post:11.3
	ctj-4-5-pre:11.3
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.2
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.13
date	2004.05.21.17.48.15;	author morrison;	state dead;
branches;
next	11.12;

11.12
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.11;

11.11
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.10;

11.10
date	2002.08.20.17.07.33;	author jra;	state Exp;
branches
	11.10.2.1;
next	11.9;

11.9
date	2002.08.15.20.54.45;	author hartley;	state Exp;
branches;
next	11.8;

11.8
date	2001.04.05.19.35.24;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2000.08.24.22.55.50;	author mike;	state Exp;
branches;
next	11.6;

11.6
date	2000.03.15.22.55.17;	author mike;	state Exp;
branches;
next	11.5;

11.5
date	99.06.03.21.40.50;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	97.12.16.00.25.39;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	97.03.26.18.38.50;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	96.08.27.05.45.08;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.44;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.12.21.21.58.23;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.24.13.32.31;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.49.59;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.13.01;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.05.12.23.27.17;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.51.42;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.09.20.15.51.33;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	88.04.07.11.40.04;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.12.04;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.10.15.10.21.26;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.15.33;	author mike;	state Rel;
branches;
next	5.2;

5.2
date	87.07.01.13.37.54;	author moss;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.47.03;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.29.53;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.24.02;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.12.21;	author moss;	state Exp;
branches;
next	;

11.10.2.1
date	2002.09.19.18.01.02;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.13
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/error.c,v 11.12 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif
/*
 *			E R R O R
 *
 *  Ray Tracing library and Framebuffer library, error handling routines.
 *
 *  Functions -
 *	rt_bomb		Called upon fatal RT library error.
 *	bu_log		Called to log RT library events.
 *	fb_log		Called to log FB library events.
 *
 *	Idea originated by Mike John Muuss
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#if defined(HAVE_STDARG_H)
#  include <stdarg.h>
#else
#  if defined(HAVE_VARARGS_H)
#    include <varargs.h>
#  endif
#endif
#include <assert.h>

#include "machine.h"
#include "vmath.h"
#include "bu.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./screen.h"
/*
 *  		B U _ B O M B
 *  
 *  Abort the LIBRT library
 */
int		bu_setjmp_valid = 0;	/* !0 = bu_jmpbuf is valid */
jmp_buf		bu_jmpbuf;		/* for BU_SETJMP() */

void
bu_bomb(const char *str)
{
	bu_log( "%s (librt.a) : Fatal error, aborting!\n", str );
	(void) fflush( stdout );
	prnt_Timer( "DUMP" );
	if( pix_buffered == B_PAGE )
		(void) fb_flush( fbiop ); /* Write out buffered image.	*/
	(void) abort();			  /* Should dump.		*/
#if !__STDC__
	exit(12);
#endif
	}

#if defined(HAVE_STDARG_H)
void
fb_log( char *fmt, ... )
	{
	va_list ap;
	/* We use the same lock as malloc.  Sys-call or mem lock, really */
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start( ap, fmt );
	if( tty && (err_file[0] == '\0' || ! strcmp( err_file, "/dev/tty" )) )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) vfprintf( stdout, fmt, ap );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) vfprintf( stdout, fmt, ap );
			}
		else
			(void) vfprintf( stdout, fmt, ap );
		(void) fflush( stdout );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		{
		(void) vfprintf( stderr, fmt, ap );
		(void) fflush( stderr );
		}
	va_end( ap );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	return;
	}
#else 

#if !defined( HAVE_VARARGS_H )
/* VARARGS */
void
fb_log(fmt, a,b,c,d,e,f,g,h,i)
char *fmt;
	{
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	if( tty && (err_file[0] == '\0' || ! strcmp( err_file, "/dev/tty" )) )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
			}
		else
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
		(void) fflush( stdout );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		(void) fprintf( stderr, fmt, a,b,c,d,e,f,g,h,i );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	}
#else 

/*
 *  		R T _  L O G
 *  
 *  Log an RT library event
 */
/* VARARGS */
void
fb_log( fmt, va_alist )
char	*fmt;
va_dcl
	{	va_list		ap;
	/* We use the same lock as malloc.  Sys-call or mem lock, really */
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start( ap );
	if( tty && (err_file[0] == '\0' || ! strcmp( err_file, "/dev/tty" )) )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) _doprnt( fmt, ap, stdout );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) _doprnt( fmt, ap, stdout );
			}
		else
			(void) _doprnt( fmt, ap, stdout );
		(void) fflush( stdout );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		{
		(void) _doprnt( fmt, ap, stderr );
		(void) fflush( stderr );
		}
	va_end( ap );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	return;
	}
#endif
#endif /* HAVE_STDARG_H */
@


11.12
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/error.c,v 11.11 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.11
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d24 5
a28 1
#include "conf.h"
@


11.10
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/error.c,v 11.8 2001/04/05 19:35:24 morrison Exp $ (BRL)";
d54 2
a55 3
bu_bomb(str)
const char *str;
	{
@


11.10.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/error.c,v 11.10 2002/08/20 17:07:33 jra Exp $ (BRL)";
d54 3
a56 2
bu_bomb(const char *str)
{
@


11.9
log
@Converted from K&R to ANSI C - RFH
@
text
@d54 3
a56 2
bu_bomb(const char *str)
{
@


11.8
log
@updated SIGNED to signed
updated CONST to const
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/error.c,v 11.7 2000/08/24 22:55:50 mike Exp $ (BRL)";
d54 2
a55 3
bu_bomb(str)
const char *str;
	{
@


11.7
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/error.c,v 11.6 2000/03/15 22:55:17 mike Exp $ (BRL)";
d55 1
a55 1
CONST char *str;
@


11.6
log
@
Since we have a custom bu_bomb, need to have the variables too.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/error.c,v 11.5 1999/06/03 21:40:50 mike Exp $ (BRL)";
@


11.5
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/error.c,v 11.4 1997/12/16 00:25:39 mike Exp $ (BRL)";
d48 1
a48 1
 *  Abort the RT library
d50 3
@


11.4
log
@Converted to bu_semaphore_acquire()
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/error.c,v 11.3 1997/03/26 18:38:50 jra Exp mike $ (BRL)";
d18 1
a18 1
 *	rt_log		Called to log RT library events.
d54 1
a54 1
	rt_log( "%s (librt.a) : Fatal error, aborting!\n", str );
@


11.3
log
@removed duplication of bu_log().
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/error.c,v 11.2 1996/08/27 05:45:08 mike Exp jra $ (BRL)";
d71 1
a71 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d112 1
a112 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d123 1
a123 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d159 1
a159 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d175 1
a175 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d216 1
a216 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
@


11.2
log
@bu.h
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/error.c,v 11.1 1995/01/04 10:17:44 mike Rel4_4 mike $ (BRL)";
a63 157

#if defined(HAVE_STDARG_H)
void
bu_log( char *fmt, ... )
	{
	va_list ap;
	/* We use the same lock as malloc.  Sys-call or mem lock, really */
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	va_start( ap, fmt );
	if( tty && (err_file[0] == '\0' || ! strcmp( err_file, "/dev/tty" )) )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) vfprintf( stdout, fmt, ap );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) vfprintf( stdout, fmt, ap );
			}
		else
			(void) vfprintf( stdout, fmt, ap );
		(void) fflush( stdout );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		{
		(void) vfprintf( stderr, fmt, ap );
		(void) fflush( stderr );
		}
	va_end( ap );
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
	return;
	}
#else /* __STDC__ */

#if !defined(HAVE_VARARGS_H)
/* VARARGS */
void
bu_log(fmt, a,b,c,d,e,f,g,h,i)
char *fmt;
	{
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	if( tty && (err_file[0] == '\0' || ! strcmp( err_file, "/dev/tty" )) )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
			}
		else
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
		(void) fflush( stdout );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		(void) fprintf( stderr, fmt, a,b,c,d,e,f,g,h,i );
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
	}
#else

/*
 *  		R T _  L O G
 *  
 *  Log an RT library event
 */
/* VARARGS */
void
bu_log( fmt, va_alist )
char	*fmt;
va_dcl
	{	va_list		ap;
	/* We use the same lock as malloc.  Sys-call or mem lock, really */
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
	va_start( ap );
	if( tty && (err_file[0] == '\0' || ! strcmp( err_file, "/dev/tty" )) )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) _doprnt( fmt, ap, stdout );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) _doprnt( fmt, ap, stdout );
			}
		else
			(void) _doprnt( fmt, ap, stdout );
		(void) fflush( stdout );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		{
		(void) _doprnt( fmt, ap, stderr );
		(void) fflush( stderr );
		}
	va_end( ap );
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
	return;
	}
#endif
#endif /* HAVE_STDARG_H */
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/error.c,v 10.3 94/12/21 21:58:23 mike Exp $ (BRL)";
d38 1
d46 1
a46 1
 *  		R T _ B O M B
d51 2
a52 2
rt_bomb(str)
char *str;
d67 1
a67 1
rt_log( char *fmt, ... )
d120 1
a120 1
rt_log(fmt, a,b,c,d,e,f,g,h,i)
d170 1
a170 1
rt_log( fmt, va_alist )
@


10.3
log
@Eliminated use of ANSI-only #elif directive.
Also eliminated "statement not reached" warning.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/error.c,v 10.2 94/08/24 13:32:31 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Made includes explicit, factored ifdefs
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/error.c,v 10.1 1991/10/12 06:49:59 mike Rel4_0 gdurf $ (BRL)";
d28 5
a32 3
#include <stdarg.h>
#elif defined(HAVE_VARARGS_H)
#include <varargs.h>
d59 1
d61 1
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/error.c,v 9.1 89/05/19 06:13:01 mike Rel3_5 $ (BRL)";
d24 2
d27 1
a27 1
#if __STDC__
d29 1
a29 1
#else
d32 8
a41 1
extern int	_doprnt();
d60 1
a60 1
#if __STDC__
a103 1
#ifdef sun
a104 1
#endif
d112 1
a112 1
#if defined( CRAY1 )
d156 1
a156 1
#else /* CRAY1 */
a207 1
#ifdef sun
a208 1
#endif
d214 2
a215 2
#endif /* CRAY1 */
#endif /* __STDC__ */
d217 1
a217 1
#if __STDC__
a260 1
#ifdef sun
a261 1
#endif
d267 1
a267 1
#else /* __STDC__ */
d269 1
a269 1
#if defined( CRAY1 )
d313 1
a313 1
#else /* CRAY1 */
a364 1
#ifdef sun
a365 1
#endif
d371 2
a372 2
#endif /* CRAY1 */
#endif /* __STDC__ */
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 8.2 89/05/12 23:27:17 moss Exp $ (BRL)";
@


8.2
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 7.2 88/04/07 11:40:04 moss Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 7.3 88/09/20 15:51:33 moss Exp $ (BRL)";
d25 3
d29 2
a30 4
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./lgt.h"
a31 1
#include "./extern.h"
d51 54
d149 2
a150 1
#else
d209 49
d259 6
d273 35
a307 1
	fprintf(stderr, fmt, a,b,c,d,e,f,g,h,i );
a308 1
	hmredraw();
d310 2
a311 1
#else
d313 1
a313 1
 *		F B _ L O G
d315 1
a315 1
 *  Log an FB library event
d370 2
a371 2
#endif

@


7.3
log
@Changed #if defined( cray ) && ! defined( CRAY2 ) to #if defined( CRAY1 ).
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 7.2 88/04/07 11:40:04 moss Locked $ (BRL)";
@


7.2
log
@Added fflush( stdout ) to fb_log and fflush( stderr ) to both rt_log
	and fb_log when on a Sun.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 7.1 87/11/03 00:12:04 moss Locked $ (BRL)";
d51 1
a51 1
#if defined( cray ) && ! defined( CRAY2 )
d156 1
a156 1
#if defined( cray ) && ! defined( CRAY2 )
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 6.2 87/10/15 10:21:26 moss Exp $ (BRL)";
a11 7
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) error.c	2.2
		Modified: 	1/30/87 at 17:22:25	G S M
		Retrieved: 	2/4/87 at 08:53:34
		SCCS archive:	/vld/moss/src/lgt/s.error.c
*/
/*
d144 1
d146 4
d210 1
d216 1
d218 4
@


6.2
log
@Ported to Cray-2, added hmenu support.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 5.1 87/06/24 22:47:03 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 5.2 87/07/01 13:37:54 moss Exp $ (BRL)";
d39 1
a39 1

d58 1
a58 1
#ifdef cray
d63 1
a63 1
{
d96 1
d101 1
a101 1
}
d148 1
d158 1
a158 1
#ifdef cray
d163 1
a163 1
{
d167 2
a168 1
}
d214 1
@


5.2
log
@Fixes to IR module resulting from changes in LIBFB and the restructuring
of the gridding loop for parallel architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 5.1 87/06/24 22:47:03 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 1.3 87/06/23 12:29:53 moss Exp $ (BRL)";
d93 1
d144 1
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 1.2 87/02/06 12:24:02 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes, pulled prnt_* functions out into module "prnt.c".
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: error.c,v 1.1 87/02/04 15:12:21 moss Locked $ (BRL)";
d58 43
d113 1
a113 1
	RES_ACQUIRE( &rt_g.res_malloc );		/* lock */
d149 1
a149 1
	RES_RELEASE( &rt_g.res_malloc );		/* unlock */
d152 1
d154 11
d177 1
a177 1
	RES_ACQUIRE( &rt_g.res_malloc );		/* lock */
d213 1
a213 1
	RES_RELEASE( &rt_g.res_malloc );		/* unlock */
d216 2
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d33 4
a36 3
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
@
