head	11.12;
access;
symbols
	ansi-20040405-merged:11.9.2.1
	postmerge-20040405-ansi:11.10
	premerge-20040404-ansi:11.9
	postmerge-autoconf:11.9
	autoconf-freeze:11.9
	premerge-autoconf:11.9
	ansi-20040316-freeze:11.9.2.1
	postmerge-20040315-windows:11.9
	premerge-20040315-windows:11.9
	windows-20040315-freeze:11.9
	autoconf-20031203:11.9
	autoconf-20031202:11.9
	autoconf-branch:11.9.0.10
	phong-branch:11.9.0.8
	photonmap-branch:11.9.0.6
	rel-6-1-DP:11.9
	windows-branch:11.9.0.4
	rel-6-0-2:11.7
	ansi-branch:11.9.0.2
	rel-6-0-1-branch:11.7.0.2
	hartley-6-0-post:11.8
	hartley-6-0-pre:11.7
	rel-6-0-1:11.7
	rel-6-0:11.7
	rel-5-4:11.4
	offsite-5-3-pre:11.5
	rel-5-3:11.4
	rel-5-2:11.4
	rel-5-1-branch:11.4.0.2
	rel-5-1:11.4
	rel-5-0:11.4
	rel-5-0-beta:11.3
	rel-4-5:11.2
	ctj-4-5-post:11.2
	ctj-4-5-pre:11.2
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.12
date	2004.05.21.17.48.16;	author morrison;	state dead;
branches;
next	11.11;

11.11
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.10;

11.10
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.9;

11.9
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.9.2.1;
next	11.8;

11.8
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.7;

11.7
date	2001.08.09.16.42.52;	author jra;	state Exp;
branches;
next	11.6;

11.6
date	2001.05.17.20.05.16;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2000.08.24.22.55.52;	author mike;	state Exp;
branches;
next	11.4;

11.4
date	99.06.03.21.40.51;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	98.03.19.04.33.36;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	96.07.17.13.03.43;	author jra;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.58;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.09.21.21.56.50;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.24.13.36.29;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.11;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.06.12.22.56.38;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.24;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.05.12.23.27.41;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.52.04;	author mike;	state Rel3_0;
branches;
next	7.1;

7.1
date	87.11.03.00.25.30;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.16.08;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.47.45;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.32.03;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.28.39;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.15.02;	author moss;	state Exp;
branches;
next	;

11.9.2.1
date	2002.09.19.18.01.04;	author morrison;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.12
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/octree.c,v 11.11 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) octree.c	2.1
		Modified: 	12/10/86 at 16:03:58	G S M
		Retrieved: 	2/4/87 at 08:53:45
		SCCS archive:	/vld/moss/src/lgt/s.octree.c
*/

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./tree.h"

/* Error incurred while converting from double to float and back.	*/
#define F2D_EPSILON	1.0e-1
#define SamePoint( p, q, e ) \
	 	(	Abs((p)[X]-(q)[X]) < (e) \
		    &&	Abs((p)[Y]-(q)[Y]) < (e) \
		    &&	Abs((p)[Z]-(q)[Z]) < (e) \
		)
#define NewPoint( p ) \
		(((p) = (PtList *) malloc(sizeof(PtList))) != PTLIST_NULL)
#define NewOctree( p ) \
		(((p) = (Octree *) malloc(sizeof(Octree))) != OCTREE_NULL)
STATIC int	subdivide_Octree(register Octree *parentp, int level);

Octree	*
new_Octant(Octree *parentp, Octree **childpp, int bitv, int level)
{	register Octree	*childp;
		fastf_t	delta = modl_radius / pow_Of_2( level );
		register float	*origin = parentp->o_points->c_point;
	/* Create child node, filling in parent's pointer.		*/
	if( ! NewOctree( *childpp ) )
		{
	 	Malloc_Bomb(sizeof(Octree));
		fatal_error = TRUE;
		return	OCTREE_NULL;
		}
	/* Fill in fields in child node.				*/
	childp = *childpp;
	childp->o_bitv = bitv;
	childp->o_temp = ABSOLUTE_ZERO;   /* Unclaimed by temperature.	*/
	childp->o_triep = TRIE_NULL;	  /* Unclaimed by region.	*/
	childp->o_sibling = OCTREE_NULL;  /* End of sibling chain.	*/
	childp->o_child = OCTREE_NULL;	  /* No children yet.		*/

	/* Create list node for origin of leaf octant.			*/
	if( ! NewPoint( childp->o_points ) )
		{
		Malloc_Bomb(sizeof(PtList));
		fatal_error = TRUE;
		return	OCTREE_NULL;
		}
	childp->o_points->c_next = PTLIST_NULL; /* End of pt. chain.	*/
	/* Compute origin relative to parent, based on bit vector.	*/
	if( bitv & 1<<X )
		childp->o_points->c_point[X] = origin[X] + delta;
	else
		childp->o_points->c_point[X] = origin[X] - delta;
	if( bitv & 1<<Y )
		childp->o_points->c_point[Y] = origin[Y] + delta;
	else
		childp->o_points->c_point[Y] = origin[Y] - delta;
	if( bitv & 1<<Z )
		childp->o_points->c_point[Z] = origin[Z] + delta;
	else
		childp->o_points->c_point[Z] = origin[Z] - delta;
	return	childp;
	}

/*	f i n d _ O c t a n t ( )
	Starting at "parentp" and descending, locate octree node suitable
	for insertion of "pt".  Implicit return of tree level in "levelp".
	Return node's address.
 */
Octree	*
find_Octant(register Octree *parentp, register fastf_t *pt, register int *levelp)
{
	if( parentp == OCTREE_NULL )
		{
		bu_log( "find_Octant() parent node is NULL\n" );
		return	OCTREE_NULL;
		}
	do
		{	register int	bitv = 0;
			register Octree	**childpp;
			register float	*origin = parentp->o_points->c_point;
		/* Build bit vector to determine target octant.		*/
		bitv |= (pt[X] > origin[X]) << X;
		bitv |= (pt[Y] > origin[Y]) << Y;
		bitv |= (pt[Z] > origin[Z]) << Z;
		/* Search linked-list for target bit vector.		*/
		for(	childpp = &parentp->o_child;
			*childpp != OCTREE_NULL && (*childpp)->o_bitv != bitv;
			childpp = &(*childpp)->o_sibling
			)
			;
		if( *childpp != OCTREE_NULL )
			{ /* Found target octant, go next level.	*/
			parentp = *childpp;
			(*levelp)++;
			}
		else	/* Target octant doesn't exist yet.		*/
			return	new_Octant( parentp, childpp, bitv, ++(*levelp) );
		}
	while( parentp->o_child != OCTREE_NULL );
	return	parentp;	/* Returning leaf node.			*/
	}

Octree	*
add_Region_Octree(Octree *parentp, fastf_t *pt, Trie *triep, int temp, int level)
{	Octree	*newp;
	/* Traverse to octant leaf node containing "pt".		*/
	if( (newp = find_Octant( parentp, pt, &level )) == OCTREE_NULL )
		{
		bu_log( "find_Octant() returned NULL!\n" );
		return	OCTREE_NULL;
		}

	/* Decide where to put datum.					*/
	if( newp->o_points->c_next == PTLIST_NULL )
		{ /* Octant empty, so place region here.		*/
		newp->o_triep = triep;
		if( ! NewPoint( newp->o_points->c_next ) )
			{
			Malloc_Bomb(sizeof(PtList));
			fatal_error = TRUE;
			return	OCTREE_NULL;
			}
		VMOVE( newp->o_points->c_next->c_point, pt );
		newp->o_points->c_next->c_next = PTLIST_NULL;
		if( temp != AMBIENT-1 )
			newp->o_temp = temp;
		return	newp;
		}
	else	  /* Octant occupied.					*/
	if( triep != newp->o_triep )
		{ /* Region collision, must subdivide octant.		*/
		if( ! subdivide_Octree(	newp, level ))
			return	OCTREE_NULL;
		return	add_Region_Octree( newp, pt, triep, temp, level );
		}
	else
	if( temp != AMBIENT-1 )
		{
		/* We are assigning a temperature.			*/
		if( newp->o_temp < AMBIENT )
			{ /* Temperature not assigned yet.		*/
			newp->o_temp = temp;
			if( ! append_PtList( pt, newp->o_points ) )
				return	OCTREE_NULL;
			}
		else
		if( Abs(newp->o_temp - temp) < ir_noise )
			{ /* Temperatures close enough.			*/
			if( ! append_PtList( pt, newp->o_points ) )
				return	OCTREE_NULL;
			}
		else
		if(	newp->o_points->c_next->c_next == PTLIST_NULL
		     &&	SamePoint(	newp->o_points->c_next->c_point,
					pt,
					F2D_EPSILON
					)
			) /* Only point in leaf node is this point.	*/
			newp->o_temp = temp;
		else
			{ /* Temperature collision, must subdivide.	*/
			if( ! subdivide_Octree(	newp, level ) )
				return	OCTREE_NULL;
			return	add_Region_Octree( newp, pt, triep, temp, level );
			}
		}
	else	/* Region pointers match, so append coordinate to list.	*/
	if( ! append_PtList( pt, newp->o_points ) )
		return	OCTREE_NULL;
	return	newp;
	}
int
append_PtList(fastf_t *pt, PtList *ptlist)
{
	for( ; ptlist->c_next != PTLIST_NULL; ptlist = ptlist->c_next )
		{
		if( SamePoint( ptlist->c_next->c_point, pt, F2D_EPSILON ) )
			{ /* Point already in list.		*/
			return	1;
			}
		}
	if( ! NewPoint( ptlist->c_next ) )
		{
		Malloc_Bomb(sizeof(PtList));
		fatal_error = TRUE;
		return	0;
		}
	ptlist = ptlist->c_next;
	VMOVE( ptlist->c_point, pt );
	ptlist->c_next = PTLIST_NULL;
	return	1;
	}

void
delete_PtList(PtList **ptlistp)
{	register PtList	*pp = *ptlistp, *np;
	*ptlistp = PTLIST_NULL;
	for( ; pp != PTLIST_NULL; pp = np )
		{
		np = pp->c_next;
		free( (char *) pp );
		}
	}

#define L_MAX_POWER_TWO		31

STATIC int
subdivide_Octree(register Octree *parentp, int level)
{	PtList		*points = parentp->o_points->c_next;
		Trie		*triep = parentp->o_triep;
		int		temp = parentp->o_temp;
	/* Ward against integer overflow in 2^level.			*/
	if( level > L_MAX_POWER_TWO )
		{
		bu_log( "Can not subdivide, level = %d\n", level );
		prnt_Octree( &ir_octree, 0 );
		return	0;
		}
	/* Remove datum from parent, it only belongs in leaves.		*/
	parentp->o_triep = TRIE_NULL;
	parentp->o_temp = ABSOLUTE_ZERO;
	parentp->o_points->c_next = PTLIST_NULL;
	/* Delete reference in trie tree to parent node.		*/
	delete_Node_OcList( &triep->l.t_octp, parentp );
	{	register PtList	*cp;
	/* Shove data down to sub-levels.				*/
	for( cp = points; cp != PTLIST_NULL; cp = cp->c_next )
		{	fastf_t	c_point[3];
			Octree	*octreep;
		VMOVE( c_point, cp->c_point );
		if(	(octreep =
		  	add_Region_Octree( parentp, c_point, triep, temp, level )
			) != OCTREE_NULL
			)
			append_Octp( triep, octreep );
		else
			return	0;
		}
	}
	delete_PtList( &points );
	return	1;
	}

fastf_t
pow_Of_2(register int power)
{	register long	value = 1;
	for( ; power > 0; power-- )
		value *= 2;
	return	(fastf_t) value;
	}

void
prnt_Node_Octree(Octree *parentp, int level)
{	register PtList	*ptp;
		register int ptcount = 0;
	bu_log( "%s[%2d](%8.3f,%8.3f,%8.3f)bits=0%o temp=%04d trie=%05x sibling=%05x child=%05x\n",
		parentp->o_child != OCTREE_NULL ? "NODE" : "LEAF",
		level,
		parentp->o_points->c_point[X],
		parentp->o_points->c_point[Y],
		parentp->o_points->c_point[Z],
		parentp->o_bitv,
		parentp->o_temp,
		parentp->o_triep,
		parentp->o_sibling,
		parentp->o_child
		);
	for( ptp = parentp->o_points->c_next; ptp != PTLIST_NULL; ptp = ptp->c_next )
		{
		if( RT_G_DEBUG )
			bu_log( "\t%8.3f,%8.3f,%8.3f\n",
				ptp->c_point[X],
				ptp->c_point[Y],
				ptp->c_point[Z]
				);
		ptcount++;
		}
	bu_log( "\t%d points\n", ptcount );
	return;
	}

void
prnt_Octree(Octree *parentp, int level)
{	register Octree	*siblingp;
	/* Print each octant at this level.				*/
	for(	siblingp = parentp;
		siblingp != OCTREE_NULL;
		siblingp = siblingp->o_sibling
		)
		prnt_Node_Octree( siblingp, level );
	/* Print each octant at this level.				*/
	for(	siblingp = parentp;
		siblingp != OCTREE_NULL;
		siblingp = siblingp->o_sibling
		)
		prnt_Octree( siblingp->o_child, level+1 );
	return;
	}

int
write_Octree(Octree *parentp, FILE *fp)
{	register PtList	*ptp;
		F_Hdr_Ptlist	hdr_ptlist;	
		long		addr = ftell( fp );
	/* Write temperature and bogus number of points for this leaf.	*/
	hdr_ptlist.f_temp = parentp->o_temp;
	hdr_ptlist.f_length = 0;
	if( fwrite( (char *) &hdr_ptlist, sizeof(F_Hdr_Ptlist), 1, fp ) != 1 )
		{
		bu_log( "\"%s\"(%d) Write failed!\n", __FILE__, __LINE__ );
		return	0;
		}
	/* Write out list of points.					*/
	for( ptp = parentp->o_points->c_next; ptp != PTLIST_NULL; ptp = ptp->c_next )
		{
		hdr_ptlist.f_length++;
		if( fwrite( (char *) ptp->c_point, sizeof(ptp->c_point), 1, fp )
			!= 1
			)
			{
			bu_log( "\"%s\"(%d) Write failed.\n", __FILE__, __LINE__ );
			return	0;
			}
		}
	if( hdr_ptlist.f_length > 0 )
		{
		/* Go back and fudge point count.			*/
		if( fseek( fp, addr, 0 ) )
			{
			bu_log( "\"%s\"(%d) Fseek failed.\n", __FILE__, __LINE__ );
			return	0;
			}
		if( fwrite( (char *) &hdr_ptlist, sizeof(hdr_ptlist), 1, fp )
			!= 1
			)
			{
			bu_log( "\"%s\"(%d) Write failed!\n", __FILE__, __LINE__ );
			return	0;
			}
		/* Re-position write pointer to end-of-file.		*/
		if( fseek( fp, 0L, 2 ) )
			{
			bu_log( "\"%s\"(%d) Fseek failed.\n", __FILE__, __LINE__ );
			return	0;
			}
		}
	return	1;
	}

STATIC void
hit_octant(struct application *ap, register Octree *op, register Octree **lpp, fastf_t *inv_dir, int level)
{
	for( ; op != OCTREE_NULL; op = op->o_sibling )
		{	fastf_t	octnt_min[3], octnt_max[3];
			fastf_t	delta = modl_radius / pow_Of_2( level );
		/* See if ray hits the octant RPP.			*/
		octnt_min[X] = op->o_points->c_point[X] - delta;
		octnt_min[Y] = op->o_points->c_point[Y] - delta;
		octnt_min[Z] = op->o_points->c_point[Z] - delta;
		octnt_max[X] = op->o_points->c_point[X] + delta;
		octnt_max[Y] = op->o_points->c_point[Y] + delta;
		octnt_max[Z] = op->o_points->c_point[Z] + delta;
		if( rt_in_rpp( &ap->a_ray, inv_dir, octnt_min, octnt_max ) )
			{ /* Hit octant.				*/
			if( op->o_child == OCTREE_NULL )
				{ /* We are at a leaf node.		*/
				if( ap->a_uvec[0] > ap->a_ray.r_min )
					{ /* Closest, so far.		*/
					ap->a_uvec[0] = ap->a_ray.r_min;
					ap->a_level = level;
					*lpp = op;
					}
				}
			else	  /* We must descend to lower level.	*/
				hit_octant( ap, op->o_child, lpp, inv_dir, level+1 );
			}
		}
	/* No more octants at this level.				*/
	return;
	}
int
ir_shootray_octree(struct application *ap)
{	vect_t	inv_dir;	/* Inverses of ap->a_ray.r_dir	*/
		Octree	*leafp = NULL;	/* Intersected octree leaf.	*/
	inv_dir[X] = inv_dir[Y] = inv_dir[Z] = INFINITY;
	if( ap->a_ray.r_dir[X] != 0.0 )
		inv_dir[X] = 1.0 / ap->a_ray.r_dir[X];
	if( ap->a_ray.r_dir[Y] != 0.0 )
		inv_dir[Y] = 1.0 / ap->a_ray.r_dir[Y];
	if( ap->a_ray.r_dir[Z] != 0.0 )
		inv_dir[Z] = 1.0 / ap->a_ray.r_dir[Z];
	/* Descend octree from root to find the closest intersected leaf node.
		Store minimum hit distance in "a_uvec[0]" field of application
		structure.  Implicitly return the leaf node in "leafp".
 	 */
	ap->a_uvec[0] = INFINITY; /* Minimum hit point, safe distance.	*/
	hit_octant( ap, &ir_octree, &leafp, inv_dir, 0 );
	if( leafp != OCTREE_NULL )
		/* Hit model.						*/
		/* a_hit is f_IR_Model(), uses 2nd arg as (Octree *) */
		return	ap->a_hit( ap, (struct partition *)leafp, RT_SEG_NULL );
	else	/* Missed it.						*/
		return	ap->a_miss( ap );		
	}
@


11.11
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/octree.c,v 11.10 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.10
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d19 5
a23 1
#include "conf.h"
@


11.9
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/octree.c,v 11.7 2001/08/09 16:42:52 jra Exp $ (BRL)";
d47 1
a47 1
STATIC int	subdivide_Octree();
d50 2
a51 5
new_Octant( parentp, childpp, bitv, level )
Octree	*parentp;
Octree	**childpp;
int	bitv, level;
	{	register Octree	*childp;
d99 2
a100 5
find_Octant( parentp, pt, levelp )
register Octree		*parentp;
register fastf_t	*pt;
register int		*levelp;
	{
d133 2
a134 7
add_Region_Octree( parentp, pt, triep, temp, level )
Octree		*parentp;
fastf_t		*pt;
Trie		*triep;
int		temp;
int		level;
	{	Octree	*newp;
d202 2
a203 4
append_PtList( pt, ptlist )
fastf_t	*pt;
PtList	*ptlist;
	{
d224 2
a225 3
delete_PtList( ptlistp )
PtList	**ptlistp;
	{	register PtList	*pp = *ptlistp, *np;
d237 2
a238 4
subdivide_Octree( parentp, level )
register Octree	*parentp;
int		level;
	{	PtList		*points = parentp->o_points->c_next;
d274 2
a275 3
pow_Of_2( power )
register int	power;
	{	register long	value = 1;
d282 2
a283 4
prnt_Node_Octree( parentp, level )
Octree	*parentp;
int	level;
	{	register PtList	*ptp;
d312 2
a313 4
prnt_Octree( parentp, level )
Octree	*parentp;
int	level;
	{	register Octree	*siblingp;
d330 2
a331 4
write_Octree( parentp, fp )
Octree	*parentp;
FILE	*fp;
	{	register PtList	*ptp;
d380 2
a381 6
hit_octant( ap, op, lpp, inv_dir, level )
struct application	*ap;
register Octree		*op, **lpp;
fastf_t			*inv_dir;
int			level;
	{
d411 2
a412 3
ir_shootray_octree( ap )
struct application	*ap;
	{	vect_t	inv_dir;	/* Inverses of ap->a_ray.r_dir	*/
@


11.9.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/octree.c,v 11.9 2002/08/20 17:07:34 jra Exp $ (BRL)";
d47 1
a47 1
STATIC int	subdivide_Octree(register Octree *parentp, int level);
d50 5
a54 2
new_Octant(Octree *parentp, Octree **childpp, int bitv, int level)
{	register Octree	*childp;
d102 5
a106 2
find_Octant(register Octree *parentp, register fastf_t *pt, register int *levelp)
{
d139 7
a145 2
add_Region_Octree(Octree *parentp, fastf_t *pt, Trie *triep, int temp, int level)
{	Octree	*newp;
d213 4
a216 2
append_PtList(fastf_t *pt, PtList *ptlist)
{
d237 3
a239 2
delete_PtList(PtList **ptlistp)
{	register PtList	*pp = *ptlistp, *np;
d251 4
a254 2
subdivide_Octree(register Octree *parentp, int level)
{	PtList		*points = parentp->o_points->c_next;
d290 3
a292 2
pow_Of_2(register int power)
{	register long	value = 1;
d299 4
a302 2
prnt_Node_Octree(Octree *parentp, int level)
{	register PtList	*ptp;
d331 4
a334 2
prnt_Octree(Octree *parentp, int level)
{	register Octree	*siblingp;
d351 4
a354 2
write_Octree(Octree *parentp, FILE *fp)
{	register PtList	*ptp;
d403 6
a408 2
hit_octant(struct application *ap, register Octree *op, register Octree **lpp, fastf_t *inv_dir, int level)
{
d438 3
a440 2
ir_shootray_octree(struct application *ap)
{	vect_t	inv_dir;	/* Inverses of ap->a_ray.r_dir	*/
@


11.8
log
@Converted from K&R to ANSI C - RFH
@
text
@d47 1
a47 1
STATIC int	subdivide_Octree(register Octree *parentp, int level);
d50 5
a54 2
new_Octant(Octree *parentp, Octree **childpp, int bitv, int level)
{	register Octree	*childp;
d102 5
a106 2
find_Octant(register Octree *parentp, register fastf_t *pt, register int *levelp)
{
d139 7
a145 2
add_Region_Octree(Octree *parentp, fastf_t *pt, Trie *triep, int temp, int level)
{	Octree	*newp;
d213 4
a216 2
append_PtList(fastf_t *pt, PtList *ptlist)
{
d237 3
a239 2
delete_PtList(PtList **ptlistp)
{	register PtList	*pp = *ptlistp, *np;
d251 4
a254 2
subdivide_Octree(register Octree *parentp, int level)
{	PtList		*points = parentp->o_points->c_next;
d290 3
a292 2
pow_Of_2(register int power)
{	register long	value = 1;
d299 4
a302 2
prnt_Node_Octree(Octree *parentp, int level)
{	register PtList	*ptp;
d331 4
a334 2
prnt_Octree(Octree *parentp, int level)
{	register Octree	*siblingp;
d351 4
a354 2
write_Octree(Octree *parentp, FILE *fp)
{	register PtList	*ptp;
d403 6
a408 2
hit_octant(struct application *ap, register Octree *op, register Octree **lpp, fastf_t *inv_dir, int level)
{
d438 3
a440 2
ir_shootray_octree(struct application *ap)
{	vect_t	inv_dir;	/* Inverses of ap->a_ray.r_dir	*/
@


11.7
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/octree.c,v 11.6 2001/05/17 20:05:16 morrison Exp $ (BRL)";
d47 1
a47 1
STATIC int	subdivide_Octree();
d50 2
a51 5
new_Octant( parentp, childpp, bitv, level )
Octree	*parentp;
Octree	**childpp;
int	bitv, level;
	{	register Octree	*childp;
d99 2
a100 5
find_Octant( parentp, pt, levelp )
register Octree		*parentp;
register fastf_t	*pt;
register int		*levelp;
	{
d133 2
a134 7
add_Region_Octree( parentp, pt, triep, temp, level )
Octree		*parentp;
fastf_t		*pt;
Trie		*triep;
int		temp;
int		level;
	{	Octree	*newp;
d202 2
a203 4
append_PtList( pt, ptlist )
fastf_t	*pt;
PtList	*ptlist;
	{
d224 2
a225 3
delete_PtList( ptlistp )
PtList	**ptlistp;
	{	register PtList	*pp = *ptlistp, *np;
d237 2
a238 4
subdivide_Octree( parentp, level )
register Octree	*parentp;
int		level;
	{	PtList		*points = parentp->o_points->c_next;
d274 2
a275 3
pow_Of_2( power )
register int	power;
	{	register long	value = 1;
d282 2
a283 4
prnt_Node_Octree( parentp, level )
Octree	*parentp;
int	level;
	{	register PtList	*ptp;
d312 2
a313 4
prnt_Octree( parentp, level )
Octree	*parentp;
int	level;
	{	register Octree	*siblingp;
d330 2
a331 4
write_Octree( parentp, fp )
Octree	*parentp;
FILE	*fp;
	{	register PtList	*ptp;
d380 2
a381 6
hit_octant( ap, op, lpp, inv_dir, level )
struct application	*ap;
register Octree		*op, **lpp;
fastf_t			*inv_dir;
int			level;
	{
d411 2
a412 3
ir_shootray_octree( ap )
struct application	*ap;
	{	vect_t	inv_dir;	/* Inverses of ap->a_ray.r_dir	*/
@


11.6
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/octree.c,v 11.5 2000/08/24 22:55:52 mike Exp $ (BRL)";
d212 1
a212 1

d437 1
a437 1

@


11.5
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/octree.c,v 11.4 1999/06/03 21:40:51 mike Exp $ (BRL)";
d318 1
a318 1
		if( rt_g.debug )
@


11.4
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/octree.c,v 11.3 1998/03/19 04:33:36 mike Exp $ (BRL)";
@


11.3
log
@fixed a_hit() args
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/octree.c,v 11.2 1996/07/17 13:03:43 jra Exp mike $ (BRL)";
d109 1
a109 1
		rt_log( "find_Octant() parent node is NULL\n" );
d149 1
a149 1
		rt_log( "find_Octant() returned NULL!\n" );
d260 1
a260 1
		rt_log( "Can not subdivide, level = %d\n", level );
d304 1
a304 1
	rt_log( "%s[%2d](%8.3f,%8.3f,%8.3f)bits=0%o temp=%04d trie=%05x sibling=%05x child=%05x\n",
d319 1
a319 1
			rt_log( "\t%8.3f,%8.3f,%8.3f\n",
d326 1
a326 1
	rt_log( "\t%d points\n", ptcount );
d362 1
a362 1
		rt_log( "\"%s\"(%d) Write failed!\n", __FILE__, __LINE__ );
d373 1
a373 1
			rt_log( "\"%s\"(%d) Write failed.\n", __FILE__, __LINE__ );
d382 1
a382 1
			rt_log( "\"%s\"(%d) Fseek failed.\n", __FILE__, __LINE__ );
d389 1
a389 1
			rt_log( "\"%s\"(%d) Write failed!\n", __FILE__, __LINE__ );
d395 1
a395 1
			rt_log( "\"%s\"(%d) Fseek failed.\n", __FILE__, __LINE__ );
@


11.2
log
@MinorMods for IRIX 6.2
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/octree.c,v 11.1 1995/01/04 10:17:58 mike Rel4_4 jra $ (BRL)";
d457 2
a458 1
		return	ap->a_hit( ap, leafp );
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/octree.c,v 10.3 94/09/21 21:56:50 mike Exp $ (BRL)";
d236 1
d303 1
a303 1
		register ptcount = 0;
@


10.3
log
@IRIX 5 warning
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/octree.c,v 10.2 94/08/24 13:36:29 gdurf Exp Locker: mike $ (BRL)";
@


10.2
log
@Made includes explicit, factored ifdefs
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/octree.c,v 10.1 1991/10/12 06:50:11 mike Rel4_0 gdurf $ (BRL)";
a244 1
	return;
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/octree.c,v 9.2 91/06/12 22:56:38 mike Exp $ (BRL)";
d19 2
d22 10
@


9.2
log
@lint
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/octree.c,v 9.1 89/05/19 06:13:24 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: octree.c,v 8.2 89/05/12 23:27:41 moss Exp $ (BRL)";
a343 1
		extern long	ftell();
@


8.2
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: octree.c,v 7.1 87/11/03 00:25:30 mike Rel $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: octree.c,v 7.1 87/11/03 00:25:30 moss Locked $ (BRL)";
d20 1
a20 4
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
a21 1
#include "./lgt.h"
a22 1
#include "./extern.h"
d35 1
a35 1
_LOCAL_ int	subdivide_Octree();
d238 1
a238 1
_LOCAL_ int
d391 1
a391 1
_LOCAL_ void
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: octree.c,v 6.1 87/07/11 08:16:08 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: octree.c,v 5.1 87/06/24 22:47:45 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: octree.c,v 1.3 87/06/23 12:32:03 moss Exp $ (BRL)";
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: octree.c,v 1.2 87/02/06 12:28:39 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: octree.c,v 1.1 87/02/04 15:15:02 moss Locked $ (BRL)";
d404 1
a404 1
		{	fastf_t	octant_min[3], octant_max[3];
d407 7
a413 7
		octant_min[X] = op->o_points->c_point[X] - delta;
		octant_min[Y] = op->o_points->c_point[Y] - delta;
		octant_min[Z] = op->o_points->c_point[Z] - delta;
		octant_max[X] = op->o_points->c_point[X] + delta;
		octant_max[Y] = op->o_points->c_point[Y] + delta;
		octant_max[Z] = op->o_points->c_point[Z] + delta;
		if( rt_in_rpp( &ap->a_ray, inv_dir, octant_min, octant_max ) )
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d20 6
a25 6
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
#include <vecmath.h>
#include <fb.h>
#include <lgt.h>
@
