head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:1.3
	rel-1-24:1.2
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.17.48.17;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.54.47;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.22.55.53;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.06.03.21.40.51;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.08;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.24.13.38.07;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.19;	author mike;	state Rel4_0;
branches;
next	9.3;

9.3
date	91.07.23.14.41.29;	author moss;	state Exp;
branches;
next	9.2;

9.2
date	90.12.10.10.24.33;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.41;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.05.12.23.27.59;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	89.04.14.12.24.03;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.52.28;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	87.12.09.13.43.32;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.26.04;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.10.15.10.45.50;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.16.34;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.07.01.13.36.16;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.30.09;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.15.11;	author moss;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.01.07;	author morrison;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.8
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/trie.c,v 11.7 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./ascii.h"
#include "./tree.h"
#define NewTrie( p ) \
		if( ((p) = (Trie *) malloc( sizeof(Trie) )) == TRIE_NULL ) \
			{ \
			Malloc_Bomb(sizeof(Trie)); \
			fatal_error = TRUE; \
			return	TRIE_NULL; \
			}
#define NewOcList( p ) \
		if( ((p) = (OcList *) malloc( sizeof(OcList) )) == OCLIST_NULL ) \
			{ \
			Malloc_Bomb(sizeof(OcList)); \
			fatal_error = TRUE; \
			return; \
			}
STATIC OcList	*copy_OcList(register OcList *orp);
STATIC OcList	*match_Trie(register Trie *triep);

void
append_Octp(Trie *triep, Octree *octp)
{	register OcList	**opp = &triep->l.t_octp;
	if( octp == OCTREE_NULL )
		return;
	for( ; *opp != OCLIST_NULL; opp = &(*opp)->p_next )
		{
		if( (*opp)->p_octp == octp )
			{
			/* Octree pointer already in list.	*/
			return;
			}
		}
	NewOcList( *opp );
	(*opp)->p_octp = octp;
	(*opp)->p_next = OCLIST_NULL;
	return;
	}

int
delete_Node_OcList(register OcList **oclistp, register Octree *octreep)
{
	for( ; *oclistp != OCLIST_NULL; oclistp = &(*oclistp)->p_next )
		if( (*oclistp)->p_octp == octreep )
			{	register OcList	*tmp = *oclistp;
			*oclistp = (*oclistp)->p_next;
			free( (char *) tmp );
			return	1;
			}
	bu_log( "\"%s\"(%d) Couldn't find node.\n", __FILE__, __LINE__ );
	return	0;
	}
void
delete_OcList(OcList **oclistp)
{	register OcList	*op = *oclistp, *np;
	*oclistp = OCLIST_NULL;
	for( ; op != OCLIST_NULL; op = np )
		{
		np = op->p_next;
		free( (char *) op );
		}
	return;
	}

Trie	*
add_Trie(register char *name, register Trie **triepp)
{	register Trie	*curp;
	if( *name == NUL )
		{ /* See if name already exists.			*/
		if( *triepp == TRIE_NULL )
			{ /* Name does not exist, make leaf node.	*/
			NewTrie( *triepp );
			(*triepp)->l.t_altr = (*triepp)->l.t_next = TRIE_NULL;
			(*triepp)->l.t_octp = OCLIST_NULL;
			}
		else
		if( (*triepp)->n.t_next != TRIE_NULL )
			{ /* Name is subset of another name.		*/
			return	add_Trie( name, &(*triepp)->n.t_altr );
			}
		else	
			; /* Name already inserted, so do nothing.	*/
		return	*triepp;
		}
	for(	curp = *triepp;
		curp != TRIE_NULL && *name != curp->n.t_char;
		curp = curp->n.t_altr
		)
		;
	if( curp == TRIE_NULL )
		{ /* No Match, this level, so create new alternate.	*/
		curp = *triepp;
		NewTrie( *triepp );
		(*triepp)->n.t_altr = curp;
		(*triepp)->n.t_char = *name;
		(*triepp)->n.t_next = TRIE_NULL;
		return	add_Trie( ++name, &(*triepp)->n.t_next );
		}
	else
		/* Found matching character.				*/
		return	add_Trie( ++name, &curp->n.t_next );
	}

OcList	*
get_Trie(register char *name, register Trie *triep)
{	register Trie *curp = triep; /* initialize to shutup compiler */
	assert( triep != NULL );
	/* Traverse next links to end of region name.			*/
	for( ; triep != TRIE_NULL; triep = triep->n.t_next )
		{
		curp = triep;
		if( *name == NUL )
			{ /* End of user-typed name.			*/
			if( triep->n.t_altr != TRIE_NULL )
				/* Ambiguous at this point.		*/
				return	OCLIST_NULL;
			else	  /* Complete next character.		*/
				{
				*name++ = triep->n.t_char;
				*name = NUL;
				}
			}
		else
		if( *name == '*' )
			return	match_Trie( triep );
		else	/* Not at end of user-typed name yet, traverse
				alternate list to find current letter.
			 */
			{
			for(	;
				triep != TRIE_NULL && *name != triep->n.t_char;
				triep = triep->n.t_altr
				)
				;
			if( triep == TRIE_NULL )
				/* Non-existant name, truncate bad part.*/
				{
				*name = NUL;
				return	OCLIST_NULL;
				}
			else
				name++;
			}
		}

	/* Clobber key-stroke, and return it. */
	--name;
	*name = NUL;
	/* It is caller's responsibility to free this linked-list. */
	assert( curp != NULL );
	return copy_OcList( curp->l.t_octp );
	}

STATIC OcList	*
match_Trie(register Trie *triep)
{	OcList	*oclist = OCLIST_NULL;
		register OcList	**oclistp = &oclist;
	if( triep == TRIE_NULL )
		return	OCLIST_NULL;
	if( triep->n.t_altr != TRIE_NULL )
		 /* Traverse alternate character pointer.		*/
		*oclistp = match_Trie( triep->n.t_altr );
	/* Advance ptr to end of list.					*/
	for(	;
		*oclistp != OCLIST_NULL;
		oclistp = &(*oclistp)->p_next
		)
		;
	if( triep->n.t_next == TRIE_NULL )
		/* At leaf node, return copy of list.			*/
		*oclistp = copy_OcList( triep->l.t_octp );
	else
		/* Traverse next character pointer.			*/
		*oclistp = match_Trie( triep->n.t_next );
	return	oclist;
	}


STATIC OcList	*
copy_OcList(register OcList *orp)
               	     			/* Input list read pointer.	*/
	{	OcList *oclistp = OCLIST_NULL;	/* Output list pointer.	*/
		register OcList	**owpp = &oclistp; /* Write pointer.	*/
	/* Make copy of Octree pointer list.				*/
	for(	owpp = &oclistp;
		orp != OCLIST_NULL;
		orp = orp->p_next,
		owpp = &(*owpp)->p_next
		)
		{
		if( (*owpp = (OcList *) malloc( sizeof(OcList) )) == OCLIST_NULL )
			{
			Malloc_Bomb(sizeof(OcList));
			fatal_error = TRUE;
			return	OCLIST_NULL;
			}
		(*owpp)->p_octp = orp->p_octp;
		(*owpp)->p_next = OCLIST_NULL;
		}
	return	oclistp;
	}

#define MAX_TRIE_LEVEL	(32*16)

void
prnt_Trie(Trie *triep, int level)
{	register Trie	*tp = triep;
		static char	name_buf[MAX_TRIE_LEVEL+1], *namep;
	/*bu_log( "prnt_Trie(triep=0x%x,level=%d)\n", triep, level );*/
	if( tp == TRIE_NULL )
		return;
	if( tp->n.t_altr != TRIE_NULL )
		prnt_Trie( tp->n.t_altr, level );
	if( level == 0 )
		namep = name_buf;
	*namep = tp->n.t_char;
	if( tp->n.t_next == TRIE_NULL )
		{	register OcList	*op, *ip;
		/* At end of name, so print it out.			*/
		*namep = NUL;
		bu_log( "%s: ", name_buf );
		for( op = tp->l.t_octp; op != OCLIST_NULL; op = op->p_next )
			{
			for( ip = tp->l.t_octp; ip != op; ip = ip->p_next )
				if( ip->p_octp->o_temp == op->p_octp->o_temp )
					/* Already printed this temp.	*/
					break;
			if( ip == op )
				/* This temperature not printed yet.	*/
				bu_log( "%d,", op->p_octp->o_temp );
			}
		bu_log( "\n" );
		}
	else
		{
		namep++;
		prnt_Trie( tp->n.t_next, level+1 );
		namep--;
		}
	return;
	}

int
write_Trie(Trie *triep, int level, FILE *fp)
{	register Trie	*tp = triep;
		static char	name_buf[MAX_TRIE_LEVEL+1], *namep;
	if( tp == TRIE_NULL )
		return	1;
	if( tp->n.t_altr != TRIE_NULL )
		(void) write_Trie( tp->n.t_altr, level, fp );
	if( level == 0 )
		{
		if(	fwrite( (char *) &ir_min, (int) sizeof(int), 1, fp ) != 1
		    ||	fwrite( (char *) &ir_max, (int) sizeof(int), 1, fp ) != 1
			)
			{
			bu_log( "\"%s\"(%d) Write failed!\n", __FILE__, __LINE__ );
			return	0;
			}			
		namep = name_buf;
		}
	*namep = tp->n.t_char;
	if( tp->n.t_next == TRIE_NULL )
		{	register OcList	*op;
		/* At end of name, so print it out.			*/
		*namep = NUL;
		for( op = tp->l.t_octp; op != OCLIST_NULL; op = op->p_next )
			{
			(void) fprintf(	fp, "%s\n", name_buf );
			if( ! write_Octree( op->p_octp, fp ) )
				return	0;
			}
		}
	else
		{
		namep++;
		(void) write_Trie( tp->n.t_next, level+1, fp );
		namep--;
		}
	return	1;
	}

int
read_Trie(FILE *fp)
{	static char	name_buf[MAX_TRIE_LEVEL+1];
		register Trie	*triep;
		F_Hdr_Ptlist	hdr_ptlist;	
		int		min, max;
		extern Trie	*reg_triep;
	/* Read temperature range information.				*/
	if(	fread( (char *) &min, (int) sizeof(int), 1, fp ) != 1
	     ||	fread( (char *) &max, (int) sizeof(int), 1, fp ) != 1
		)
		{
		bu_log( "Could not read min/max info.\n" );
		rewind( fp );
		}
	else
		{
		bu_log( "IR data base temperature range is %d to %d\n",
			min, max
			);
		if( ir_min == ABSOLUTE_ZERO )
			{ /* Temperature range not set.			*/
			ir_min = min;
			ir_max = max;
			}
		else 
			{ /* Merge with existing range.			*/
			ir_min = Min( ir_min, min );
			ir_max = Max( ir_max, max );
			bu_log(	"Global temperature range is %d to %d\n",
				ir_min, ir_max
				);
			(void) fflush( stdout );
			}
		}
	if( ! init_Temp_To_RGB() )
		{
		return	0;
		}
	while( fgets( name_buf, MAX_TRIE_LEVEL, fp ) != NULL )
		{
		name_buf[strlen(name_buf)-1] = '\0'; /* Clobber new-line.*/
		triep = add_Trie( name_buf, &reg_triep );
		if( fread( (char *) &hdr_ptlist, (int) sizeof(F_Hdr_Ptlist), 1, fp )
			!= 1
			)
			{
			bu_log( "\"%s\"(%d) Read failed!\n", __FILE__, __LINE__ );
			return	0;
			}
		for( ; hdr_ptlist.f_length > 0; hdr_ptlist.f_length-- )
			{	fastf_t		point[3];
				float		c_point[3];
				Octree		*octreep;
			if( fread( (char *) c_point, (int) sizeof(c_point), 1, fp ) != 1 )
				{
				bu_log(	"\"%s\"(%d) Read failed.\n",
					__FILE__, __LINE__ );
				return	0;
				}
			VMOVE( point, c_point );
			if( (octreep = add_Region_Octree(	&ir_octree,
								point,
								triep,
								hdr_ptlist.f_temp,
								0
								)
				) != OCTREE_NULL
				)
				append_Octp( triep, octreep );
			}
		}
	return	1;
	}

void
ring_Bell(void)
{
	(void) putchar( BEL );
	return;
	}

char	*
char_To_String(int i)
{	static char	buf[4];
	if( i >= SP && i < DEL )
		{
		buf[0] = i;
		buf[1] = NUL;
		}
	else
	if( i >= NUL && i < SP )
		{
		buf[0] = '^';
		buf[1] = i + 64;
		buf[2] = NUL;
		}
	else
	if( i == DEL )
		return	"DL";
	else
		return	"EOF";
	return	buf;
	}

/*	g e t _ R e g i o n _ N a m e ( )
	TENEX-style name completion.
	Returns a linked-list of pointers to octree leaf nodes.
 */
OcList	*
get_Region_Name(char *inbuf, int bufsz, char *msg)
{	static char	buffer[BUFSIZ];
		register char	*p = buffer;
		register int	c;
		OcList		*oclistp = OCLIST_NULL;
		extern Trie	*reg_triep;
		extern int	tty;
	if( tty )
		{
		save_Tty( 0 );
		set_Raw( 0 );
		clr_Echo( 0 );
		}
	prnt_Prompt( msg );
	*p = NUL;
	do
		{
		(void) fflush( stdout );
		c = hm_getchar();
		switch( c )
			{
		case SP :
			{
			if(	reg_triep == TRIE_NULL
			    ||	(oclistp = get_Trie( buffer, reg_triep ))
				== OCLIST_NULL
				)
				(void) putchar( BEL );
			for( ; p > buffer; p-- )
				(void) putchar( BS );
			(void) printf( "%s", buffer );
			(void) ClrEOL();
			(void) fflush( stdout );
			p += strlen( buffer );
			break;
			}
		case Ctrl('A') : /* Cursor to beginning of line.	*/
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			for( ; p > buffer; p-- )
				(void) putchar( BS );
			break;
		case Ctrl('B') :
		case BS : /* Move cursor back one character.		*/
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			(void) putchar( BS );
			--p;
			break;
		case Ctrl('D') : /* Delete character under cursor.	*/
			{	register char	*q = p;
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			for( ; *q != NUL; ++q )
				{
				*q = *(q+1);
				(void) putchar( *q != NUL ? *q : SP );
				}
			for( ; q > p; --q )
				(void) putchar( BS );
			break;
			}
		case Ctrl('E') : /* Cursor to end of line.		*/
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			(void) printf( "%s", p );
			p += strlen( p );
			break;
		case Ctrl('F') : /* Cursor forward one character.	*/
			if( *p == NUL || p-buffer >= bufsz-2 )
				{
				ring_Bell();
				break;
				}
			(void) putchar( *p++ );
			break;
		case Ctrl('G') : /* Abort input.			*/
			ring_Bell();
			prnt_Event( "Aborted." );
			goto	clean_return;
		case Ctrl('K') : /* Erase from cursor to end of line.	*/
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			ClrEOL();
			*p = NUL;
			break;
		case Ctrl('P') : /* Yank previous contents of "inbuf".	*/
			{	register int	len = strlen( inbuf );
			if( (p + len) - buffer >= BUFSIZ )
				{
				ring_Bell();
				break;
				}
			(void) strncpy( p, inbuf, bufsz );
			(void) printf( "%s", p );
			p += len;
			break;
			}
		case Ctrl('U') : /* Erase from start of line to cursor.	*/
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			for( ; p > buffer; --p )
				{	register char	*q = p;
				(void) putchar( BS );
				for( ; *(q-1) != NUL; ++q )
					{
					*(q-1) = *q;
					(void) putchar( *q != NUL ? *q : SP );
					}
				for( ; q > p; --q )
					(void) putchar( BS );
				}
			break;
		case Ctrl('R') : /* Print line, cursor doesn't move.	*/
			{	register int	i;
			if( buffer[0] == NUL )
				break;
			for( i = p - buffer; i > 0; i-- )
				(void) putchar( BS );
			(void) printf( "%s", buffer );
			for( i = strlen( buffer ) - (p - buffer); i > 0; i-- )
				(void) putchar( BS );
			break;
			}
		case DEL : /* Delete character behind cursor.		*/
			{	register char	*q = p;
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			(void) putchar( BS );
			for( ; *(q-1) != NUL; ++q )
				{
				*(q-1) = *q;
				(void) putchar( *q != NUL ? *q : SP );
				}
			for( ; q > p; --q )
				(void) putchar( BS );
			p--;
			break;
			}
		case CR :
		case LF :
		case EOF :
			if(	reg_triep == TRIE_NULL
			    ||	(oclistp = get_Trie( buffer, reg_triep ))
				== OCLIST_NULL
				)
				{
				(void) putchar( BEL );
				break;
				}
			else
				{
				(void) strncpy( inbuf, buffer, bufsz );
				prnt_Event( "" );
				goto clean_return;
				}
		case Ctrl('V') :
			/* Escape character, do not process next char.	*/
			c = hm_getchar();
			/* Fall through to default case!		*/
		default : /* Insert character at cursor.		*/
			{	register char	*q = p;
				register int	len = strlen( p );
			/* Scroll characters forward.			*/
			if( c >= NUL && c < SP )
				(void) printf( "%s", char_To_String( c ) );
			else
				(void) putchar( c );
			for( ; len >= 0; len--, q++ )
				(void) putchar( *q == NUL ? SP : *q );
			for( ; q > p; q-- )
				{
				(void) putchar( BS );
				*q = *(q-1);
				}
			*p++ = c;
			break;
			}
			} /* End switch. */
		}
	while( strlen( buffer ) < BUFSIZ);
	ring_Bell();
	prnt_Event( "Buffer full." );
clean_return :
	prnt_Prompt( "" );
	if( tty )
		reset_Tty( 0 );
	return	oclistp;
	}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/trie.c,v 11.6 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 5
a16 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/trie.c,v 11.3 2000/08/24 22:55:53 mike Exp $ (BRL)";
d43 2
a44 2
STATIC OcList	*copy_OcList();
STATIC OcList	*match_Trie();
d47 2
a48 4
append_Octp( triep, octp )
Trie	*triep;
Octree	*octp;
	{	register OcList	**opp = &triep->l.t_octp;
d66 2
a67 4
delete_Node_OcList( oclistp, octreep )
register OcList	**oclistp;
register Octree	*octreep;
	{
d79 2
a80 3
delete_OcList( oclistp )
OcList	**oclistp;
	{	register OcList	*op = *oclistp, *np;
d91 2
a92 4
add_Trie( name, triepp )
register char	*name;
register Trie	**triepp;
	{	register Trie	*curp;
d130 2
a131 4
get_Trie( name, triep )
register char	*name;
register Trie	*triep;
	{	register Trie *curp = triep; /* initialize to shutup compiler */
d180 2
a181 3
match_Trie( triep )
register Trie	*triep;
	{	OcList	*oclist = OCLIST_NULL;
d205 2
a206 2
copy_OcList( orp )
register OcList	*orp;			/* Input list read pointer.	*/
d231 2
a232 4
prnt_Trie( triep, level )
Trie	*triep;
int	level;
	{	register Trie	*tp = triep;
d269 2
a270 5
write_Trie( triep, level, fp )
Trie	*triep;
int	level;
FILE	*fp;
	{	register Trie	*tp = triep;
d309 2
a310 3
read_Trie( fp )
FILE	*fp;
	{	static char	name_buf[MAX_TRIE_LEVEL+1];
d384 2
a385 2
ring_Bell()
	{
d391 2
a392 3
char_To_String( i )
int	i;
	{	static char	buf[4];
d418 2
a419 5
get_Region_Name( inbuf, bufsz, msg )
char	 *inbuf;
int	 bufsz;
char	*msg;
	{	static char	buffer[BUFSIZ];
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/trie.c,v 11.5 2002/08/20 17:07:34 jra Exp $ (BRL)";
d43 2
a44 2
STATIC OcList	*copy_OcList(register OcList *orp);
STATIC OcList	*match_Trie(register Trie *triep);
d47 4
a50 2
append_Octp(Trie *triep, Octree *octp)
{	register OcList	**opp = &triep->l.t_octp;
d68 4
a71 2
delete_Node_OcList(register OcList **oclistp, register Octree *octreep)
{
d83 3
a85 2
delete_OcList(OcList **oclistp)
{	register OcList	*op = *oclistp, *np;
d96 4
a99 2
add_Trie(register char *name, register Trie **triepp)
{	register Trie	*curp;
d137 4
a140 2
get_Trie(register char *name, register Trie *triep)
{	register Trie *curp = triep; /* initialize to shutup compiler */
d189 3
a191 2
match_Trie(register Trie *triep)
{	OcList	*oclist = OCLIST_NULL;
d215 2
a216 2
copy_OcList(register OcList *orp)
               	     			/* Input list read pointer.	*/
d241 4
a244 2
prnt_Trie(Trie *triep, int level)
{	register Trie	*tp = triep;
d281 5
a285 2
write_Trie(Trie *triep, int level, FILE *fp)
{	register Trie	*tp = triep;
d324 3
a326 2
read_Trie(FILE *fp)
{	static char	name_buf[MAX_TRIE_LEVEL+1];
d400 2
a401 2
ring_Bell(void)
{
d407 3
a409 2
char_To_String(int i)
{	static char	buf[4];
d435 5
a439 2
get_Region_Name(char *inbuf, int bufsz, char *msg)
{	static char	buffer[BUFSIZ];
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d43 2
a44 2
STATIC OcList	*copy_OcList(register OcList *orp);
STATIC OcList	*match_Trie(register Trie *triep);
d47 4
a50 2
append_Octp(Trie *triep, Octree *octp)
{	register OcList	**opp = &triep->l.t_octp;
d68 4
a71 2
delete_Node_OcList(register OcList **oclistp, register Octree *octreep)
{
d83 3
a85 2
delete_OcList(OcList **oclistp)
{	register OcList	*op = *oclistp, *np;
d96 4
a99 2
add_Trie(register char *name, register Trie **triepp)
{	register Trie	*curp;
d137 4
a140 2
get_Trie(register char *name, register Trie *triep)
{	register Trie *curp = triep; /* initialize to shutup compiler */
d189 3
a191 2
match_Trie(register Trie *triep)
{	OcList	*oclist = OCLIST_NULL;
d215 2
a216 2
copy_OcList(register OcList *orp)
               	     			/* Input list read pointer.	*/
d241 4
a244 2
prnt_Trie(Trie *triep, int level)
{	register Trie	*tp = triep;
d281 5
a285 2
write_Trie(Trie *triep, int level, FILE *fp)
{	register Trie	*tp = triep;
d324 3
a326 2
read_Trie(FILE *fp)
{	static char	name_buf[MAX_TRIE_LEVEL+1];
d400 2
a401 2
ring_Bell(void)
{
d407 3
a409 2
char_To_String(int i)
{	static char	buf[4];
d435 5
a439 2
get_Region_Name(char *inbuf, int bufsz, char *msg)
{	static char	buffer[BUFSIZ];
@


11.3
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/trie.c,v 11.2 1999/06/03 21:40:51 mike Exp $ (BRL)";
d43 2
a44 2
STATIC OcList	*copy_OcList();
STATIC OcList	*match_Trie();
d47 2
a48 4
append_Octp( triep, octp )
Trie	*triep;
Octree	*octp;
	{	register OcList	**opp = &triep->l.t_octp;
d66 2
a67 4
delete_Node_OcList( oclistp, octreep )
register OcList	**oclistp;
register Octree	*octreep;
	{
d79 2
a80 3
delete_OcList( oclistp )
OcList	**oclistp;
	{	register OcList	*op = *oclistp, *np;
d91 2
a92 4
add_Trie( name, triepp )
register char	*name;
register Trie	**triepp;
	{	register Trie	*curp;
d130 2
a131 4
get_Trie( name, triep )
register char	*name;
register Trie	*triep;
	{	register Trie *curp = triep; /* initialize to shutup compiler */
d180 2
a181 3
match_Trie( triep )
register Trie	*triep;
	{	OcList	*oclist = OCLIST_NULL;
d205 2
a206 2
copy_OcList( orp )
register OcList	*orp;			/* Input list read pointer.	*/
d231 2
a232 4
prnt_Trie( triep, level )
Trie	*triep;
int	level;
	{	register Trie	*tp = triep;
d269 2
a270 5
write_Trie( triep, level, fp )
Trie	*triep;
int	level;
FILE	*fp;
	{	register Trie	*tp = triep;
d309 2
a310 3
read_Trie( fp )
FILE	*fp;
	{	static char	name_buf[MAX_TRIE_LEVEL+1];
d384 2
a385 2
ring_Bell()
	{
d391 2
a392 3
char_To_String( i )
int	i;
	{	static char	buf[4];
d418 2
a419 5
get_Region_Name( inbuf, bufsz, msg )
char	 *inbuf;
int	 bufsz;
char	*msg;
	{	static char	buffer[BUFSIZ];
@


11.2
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/trie.c,v 11.1 1995/01/04 10:18:08 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/trie.c,v 10.2 94/08/24 13:38:07 gdurf Exp $ (BRL)";
d79 1
a79 1
	rt_log( "\"%s\"(%d) Couldn't find node.\n", __FILE__, __LINE__ );
d246 1
a246 1
	/*rt_log( "prnt_Trie(triep=0x%x,level=%d)\n", triep, level );*/
d258 1
a258 1
		rt_log( "%s: ", name_buf );
d267 1
a267 1
				rt_log( "%d,", op->p_octp->o_temp );
d269 1
a269 1
		rt_log( "\n" );
d297 1
a297 1
			rt_log( "\"%s\"(%d) Write failed!\n", __FILE__, __LINE__ );
d336 1
a336 1
		rt_log( "Could not read min/max info.\n" );
d341 1
a341 1
		rt_log( "IR data base temperature range is %d to %d\n",
d353 1
a353 1
			rt_log(	"Global temperature range is %d to %d\n",
d371 1
a371 1
			rt_log( "\"%s\"(%d) Read failed!\n", __FILE__, __LINE__ );
d380 1
a380 1
				rt_log(	"\"%s\"(%d) Read failed.\n",
@


10.2
log
@Made includes explicit
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/trie.c,v 10.1 1991/10/12 06:50:19 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/trie.c,v 9.3 91/07/23 14:41:29 moss Exp $ (BRL)";
d12 2
d15 11
a25 1
#include "./extern.h"	/* includes <assert.h> */
@


9.3
log
@Removed include of assert.h since it is included in extern.h.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/trie.c,v 9.2 90/12/10 10:24:33 moss Exp $ (BRL)";
@


9.2
log
@Added initializations of auto variables to make Cray compiler happy.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 9.1 89/05/19 06:13:41 mike Rel3_5 $ (BRL)";
d13 1
a13 2
#include <assert.h>
#include "./extern.h"
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 8.3 89/05/12 23:27:59 moss Exp $ (BRL)";
d13 1
d129 2
a130 1
	{	register Trie	*curp;
d168 2
a169 1
	/* Clobber key-stroke, and return it.				*/
d172 3
a174 2
	/* It is caller's responsibility to free this linked-list.	*/
	return	copy_OcList( curp->l.t_octp );
@


8.3
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 8.2 89/04/14 12:24:03 moss Exp $ (BRL)";
@


8.2
log
@Fixed declaration of malloc() to agree with ANSI C, and neatened up C
library function declarations by including <stdlib.h> when appropriate.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 8.1 88/10/05 00:52:28 moss Locked $ (BRL)";
d13 1
a13 4
#include "machine.h"
#include "vmath.h"
#include "fb.h"
#include "./lgt.h"
a16 1
#include "./extern.h"
d31 2
a32 2
_LOCAL_ OcList	*copy_OcList();
_LOCAL_ OcList	*match_Trie();
d173 1
a173 1
_LOCAL_ OcList	*
d199 1
a199 1
_LOCAL_ OcList	*
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 7.2 87/12/09 13:43:32 moss Locked $ (BRL)";
a34 1
extern char	*malloc();
@


7.2
log
@Improvements to IR modeling interface.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 7.1 87/11/03 00:26:04 moss Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 6.2 87/10/15 10:45:50 moss Exp $ (BRL)";
a10 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) trie.c	2.1
		Modified: 	12/10/86 at 16:04:07	G S M
		Retrieved: 	2/4/87 at 08:53:47
		SCCS archive:	/vld/moss/src/lgt/s.trie.c
*/
d350 1
d352 1
d451 2
a452 1
			if( (oclistp = get_Trie( buffer, reg_triep ))
d591 2
a592 1
			if( (oclistp = get_Trie( buffer, reg_triep ))
@


6.2
log
@Changed calls to get_Char to hm_getchar for hmenu compatibility.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 1.2 87/02/06 12:30:09 moss Locked $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 1.3 87/07/01 13:36:16 moss Exp $ (BRL)";
d451 1
a451 1
		c = get_Char();
d610 1
a610 1
			c = get_Char();
@


1.3
log
@Fixes to IR module resulting from changes in LIBFB and the restructuring
of the gridding loop for parallel architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 1.2 87/02/06 12:30:09 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: trie.c,v 1.1 87/02/04 15:15:11 moss Locked $ (BRL)";
d243 1
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d20 6
a25 6
#include <ascii.h>
#include <machine.h>
#include <vmath.h>
#include <vecmath.h>
#include <fb.h>
#include <lgt.h>
@
