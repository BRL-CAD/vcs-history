head	11.5;
access;
symbols
	ansi-20040405-merged:11.3
	postmerge-20040405-ansi:11.3
	premerge-20040404-ansi:11.3
	postmerge-autoconf:11.3
	autoconf-freeze:11.3
	premerge-autoconf:11.3
	ansi-20040316-freeze:11.3
	postmerge-20040315-windows:11.3
	premerge-20040315-windows:11.3
	windows-20040315-freeze:11.3
	autoconf-20031203:11.3
	autoconf-20031202:11.3
	autoconf-branch:11.3.0.12
	phong-branch:11.3.0.10
	photonmap-branch:11.3.0.8
	rel-6-1-DP:11.3
	windows-branch:11.3.0.6
	rel-6-0-2:11.3
	ansi-branch:11.3.0.4
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.5
date	2004.05.21.17.48.16;	author morrison;	state dead;
branches;
next	11.4;

11.4
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.22.55.53;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.06.03.21.40.51;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.04;	author mike;	state Rel4_4;
branches;
next	10.5;

10.5
date	94.12.14.20.08.42;	author mike;	state Exp;
branches;
next	10.4;

10.4
date	94.11.24.02.27.03;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.09.21.21.58.19;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.24.13.37.48;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.16;	author mike;	state Rel4_0;
branches;
next	9.5;

9.5
date	91.08.27.14.33.05;	author stay;	state Exp;
branches;
next	9.4;

9.4
date	90.03.29.13.02.25;	author moss;	state Exp;
branches;
next	9.3;

9.3
date	89.12.05.09.46.12;	author moss;	state Exp;
branches;
next	9.2;

9.2
date	89.11.01.16.30.13;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.34;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.05.12.23.27.52;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	89.03.31.16.10.44;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.52.17;	author mike;	state Rel3_0;
branches;
next	7.6;

7.6
date	88.08.30.10.30.01;	author moss;	state Exp;
branches;
next	7.5;

7.5
date	88.08.30.10.23.27;	author moss;	state Exp;
branches;
next	7.4;

7.4
date	88.06.24.15.24.51;	author moss;	state Exp;
branches;
next	7.3;

7.3
date	88.06.23.09.30.20;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	87.12.09.13.43.11;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.54;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.11.02.20.49.00;	author mike;	state Exp;
branches;
next	6.2;

6.2
date	87.10.15.10.43.03;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.16.24;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.48.19;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.33.16;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.29.48;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.15.07;	author moss;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.5
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6651 or AV-298-6651

	SGI specific routines.  NOTE (XXX) getorigin() doesn't work for
		remote frame buffers.  This should be changed to use libfb
		only.
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/sgi_dep.c,v 11.4 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>

#if HAS_SGIGL
#include <gl.h>
#include <device.h>
#include <string.h>
#undef RED
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./ascii.h"
#include "./vecmath.h"
#include "./lgt.h"

#define WINBORDER	4  /* Thickness of window border. */
#define WINBANNER	16 /* Thickness of window title bar. */
#define MAXSTRS		6
#define CHARHGT		WINBANNER
#define PUPWID		(375+WINBORDER*2)
#define PUPHGT		(WINBANNER*MAXSTRS+WINBORDER*2)
static char	**pupstr;
static char	*menupupstr[] =
			{
			"Pop-up menus are available in this or the",
			"frame buffer window by holding down the",
			"right mouse button.",
			(char *) NULL
			};
static char	*sweepupstr[] =
			{
			"Hold down the middle button to sweep",
			"a rectangle.",
			"Click the right mouse button to quit.",
			(char *) NULL
			};
static char	*tagpupstr[] =
			{
			"Click the middle mouse button to tag",
			"the screen position under the cursor.",
			"Click the right mouse button to quit.",
			(char *) NULL
			};
static char	*winpupstr[] =
			{
			"Hold down the middle button to adjust",
			"the window frame.",
			"Click the right mouse button to quit.",
			(char *) NULL
			};

/*
	bool tryGetOrigin( long *xp, long *yp )

	There is no way to inquire as to the frame buffer window origin
	through the frame buffer library (libfb(3)), so we need to use
	the SGI Graphics Library call getorigin(), but it will dump core
	if winopen() has not been called.  This is indeed the case if a
	remote frame buffer window is being used.  This routine simply
	tests as to whether the current frame buffer is remote.  This
	test could easily break if libfb changes its name for the remote
	frame buffer since it doesn't advertise the values returned by
	fb_gettype().
 */
STATIC bool
tryGetOrigin( xp, yp )
long *xp, *yp;
	{	char *fbtype = fb_gettype( fbiop );
	if( strcmp( fbtype, "Remote Device Interface" ) == 0 )	/* trouble */
		{
		prnt_Scroll( "Can't get window origin from remote device.\n" );
		return false;
		}
	getorigin( xp, yp );
	return true;
	}

STATIC void
sgi_Rect( x0, y0, x1, y1 )
int	x0, y0, x1, y1;
	{
#ifndef mips
	cursoff();
#endif
	recti( (Icoord) x0, (Icoord) y0, (Icoord) x1, (Icoord) y1 );
#ifndef mips
	curson();
#endif
	return;
	}

STATIC void
sgi_OL_Transparent()
	{
#ifdef mips
	color( 0 );
#else
	pupcolor( PUP_CLEAR );
#endif
	return;
	}

STATIC void
sgi_OL_Opaque()
	{
#ifdef mips
	color( 1 );
#else
	pupcolor( PUP_WHITE );
#endif
	return;
	}

STATIC void
sgi_OL_Start()
	{
#ifdef mips
	drawmode( OVERDRAW );
#else
	pupmode();
#endif
	return;
	}

STATIC void
sgi_OL_End()
	{
#ifdef mips
	drawmode( NORMALDRAW );
#else
	endpupmode();
#endif
	return;
	}

STATIC void
sgi_OL_Erase()
	{
#ifndef mips
	cursoff();
#endif
	sgi_OL_Transparent();
	clear();
#ifndef mips
	curson();
#endif
	return;
	}

extern char	*get_Input();
long		main_menu;
long		buffering_menu;
long		cursorect_menu;
long		debugging_menu;
long		irflags_menu;
long		irpaint_menu;
long		grid_size_menu;
long		lgts_edit_menu;
long		lgts_prnt_menu;
long		mat_index_menu;
long		mat_pindex_menu;
long		mat_eindex_menu;
long		max_ray_menu;
long		movie_fps_menu;
long		two_digit_menu;
static long	popup_gid = -1;

void		sgi_Animate();
STATIC void	sgi_Pt_Select();
STATIC void	sgi_Read_Keyboard();

STATIC int
mips_Animate( fps )
int	fps;
	{
	sgi_Animate( fps < 0 ? 1 : (fps > 64 ? 64 : fps) );
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_IR_Flags( flag )
int	flag;
	{
	set_IRmapping( flag );
	note_IRmapping();
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_IR_Paint( flag )
int	flag;
	{
	ir_doing_paint = flag;
	if( ir_doing_paint )
		{
		get_Input( input_ln, MAX_LN, "Enter temperature : " );
		if( sscanf( input_ln, "%d", &ir_paint ) != 1 )
			ir_doing_paint = FALSE;
		}
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_Mat_Print( flag )
int	flag;
	{
	if( flag != -1 )
		(void) mat_Print_Db( flag );
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_Max_Ray( flag )
int	flag;
	{
	if( ir_mapping )
		bu_log( "Multiple bounces disallowed during IR mapping.\n" );
	else
		max_bounce = flag;	
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_Mat_Edit( flag )
int	flag;
	{
	(void) mat_Edit_Db_Entry( flag );
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_Lgt_Print( flag )
int	flag;
	{
	(void) lgt_Print_Db( flag );
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_Lgt_Edit( flag )
int	flag;
	{
	(void) lgt_Edit_Db_Entry( flag );
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_Buffering( flag )
int	flag;
	{
	pix_buffered = flag;
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_Debugging( flag )
int	flag;
	{
	if( flag > 0 )
		rt_g.debug |= flag;
	else
	if( flag == 0 )
		rt_g.debug = 0;
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC int
mips_Size_Grid( size )
int	size;
	{
	grid_sz = size;
	setGridSize( grid_sz );	
	return	'#'; /* For backward compatibility with SGI menu interface. */
	}

STATIC void
sgi_Pup_Strs()
	{	register int	i, ypos = PUPHGT-WINBANNER-WINBORDER;
		long	gid = winget();
	winset( popup_gid );
	color( CYAN );
	clear();
	color( BLACK );
	for( i = 0; i < MAXSTRS && pupstr[i] != NULL; i++, ypos -= CHARHGT )
		{
		cmov2i( 10, ypos );
		charstr( pupstr[i] );
		}
	winset( gid );
	}

STATIC void
sgi_Pt_Select( x, y, xp, yp, originp )
register int	x, y, *xp, *yp, *originp;
	{	char		*args[3];
		char		buf1[5], buf2[5];
		long		xwin, ywin;
	if( ! tryGetOrigin( &xwin, &ywin ) )
		return; /* XXX */
	args[1] = buf1;
	args[2] = buf2;
	if( *originp )
		{
		*xp = x;
		*yp = y;
		(void) sprintf( args[1], "%d", SGI_XCVT( x ) + x_fb_origin );
		(void) sprintf( args[2], "%d", grid_x_fin );
		(void) f_Grid_X_Pos( (HMitem *) 0, args );
		(void) sprintf( args[1], "%d", SGI_YCVT( y ) + y_fb_origin );
		(void) sprintf( args[2], "%d", grid_y_fin );
		(void) f_Grid_Y_Pos( (HMitem *) 0, args );
		}
	else
		{	int	x_fin, y_fin;
		x_fin = SGI_XCVT( x ) + x_fb_origin;
		y_fin = SGI_YCVT( y ) + y_fb_origin;
		if( x_fin < grid_x_org )
			{
			Swap_Integers( x_fin, grid_x_org );
			}
		if( y_fin < grid_y_org )
			{
			Swap_Integers( y_fin, grid_y_org );
			}
		(void) sprintf( args[1], "%d", grid_x_org );
		(void) sprintf( args[2], "%d", x_fin );
		(void) f_Grid_X_Pos( (HMitem *) 0, args );
		(void) sprintf( args[1], "%d", grid_y_org );
		(void) sprintf( args[2], "%d", y_fin );
		(void) f_Grid_Y_Pos( (HMitem *) 0, args );
		}
	Toggle( *originp );
	return;
	}

STATIC void
sgi_Pup_Redraw()
	{	long	gid = winget();
	winset( popup_gid );
	reshapeviewport();
	sgi_Pup_Strs();
	winset( gid );
	return;
	}

STATIC int
sgi_Tag_Pixel( origin, x, y, x0, y0 )
int	origin, x, y, x0, y0;
	{	short	val;
		long	xwin, ywin;
		int	flag = tracking_cursor;
	tracking_cursor = FALSE; /* Disable tracking cursor.		*/
	qdevice( MOUSEX );
	qdevice( MOUSEY );
	qdevice( MIDDLEMOUSE );
	if( ! tryGetOrigin( &xwin, &ywin ) )
		return -1; /* XXX */
	(void) fb_setcursor( fbiop, target1, 16, 16, 8, 8 );
	(void) fb_cursor( fbiop, 1, x, y );
	pupstr = tagpupstr;
	sgi_Pup_Strs();
	for( ; ; )
		{
		if( ! qtest() )
			continue;
		switch( qread( &val ) )
			{
		case MENUBUTTON :
			/* Wait for user to let go.			*/
			for( ; ! qtest() || qread( &val ) != MENUBUTTON; )
				;
			unqdevice( MOUSEX );
			unqdevice( MOUSEY );
			unqdevice( MIDDLEMOUSE );
			qreset();
			tracking_cursor = flag;
			return	1;
		case MIDDLEMOUSE :
			/* Wait for user to let go.			*/
			for( ; ! qtest() || qread( &val ) != MIDDLEMOUSE; )
				;
			sgi_Pt_Select( x, y, &x0, &y0, &origin );
			sgi_Pt_Select( x, y, &x0, &y0, &origin );
			user_interrupt = FALSE;
			render_Model( 0 );
			prnt_Event( (char *) NULL );
			qreset();
			break;
		case MOUSEX :
			x = val;
			break;
		case MOUSEY :
			y = val;
			break;
		case KEYBD :
			qenter( KEYBD, val );
			unqdevice( MOUSEX );
			unqdevice( MOUSEY );
			unqdevice( MIDDLEMOUSE );
			tracking_cursor = flag;
			return	0;
		case REDRAW :
			sgi_Pup_Redraw();
		case INPUTCHANGE :
			break;
			}
		}
	}

STATIC int
sgi_Sweep_Rect( origin, x, y, x0, y0 )
int	origin, x, y, x0, y0;
	{	short	val;
		long	xwin, ywin;
	if( ! tryGetOrigin( &xwin, &ywin ) )
		return -1; /* XXX */
	qdevice( MOUSEX );
	qdevice( MOUSEY );
	qdevice( MIDDLEMOUSE );
#ifdef mips
	overlay( 2 );
	gconfig();
#endif
	(void) fb_setcursor( fbiop, target1, 16, 16, 8, 8 );
	(void) fb_cursor( fbiop, 1, x, y );
	pupstr = sweepupstr;
	sgi_Pup_Strs();
	sgi_OL_Start();
	for( ; ; )
		{
		if( ! qtest() )
			continue;
		switch( qread( &val ) )
			{
		case MENUBUTTON :
			/* Wait for user to let go.	*/
			for(	;
			      !	qtest()
			    ||	qread( &val ) != MENUBUTTON;
				)
				;
			sgi_OL_End();
			unqdevice( MOUSEX );
			unqdevice( MOUSEY );
			unqdevice( MIDDLEMOUSE );
			qreset();
			return	1;
		case MIDDLEMOUSE :
			sgi_Pt_Select( x, y, &x0, &y0, &origin );
			if( origin )
				/* Done sweeping.	*/
				(void) fb_setcursor( fbiop, target1, 16, 16, 8, 8 );
			else
				{ /* Sweeping a rectangle.*/
				sgi_OL_Erase();
				(void) fb_setcursor( fbiop, sweeportrack, 16, 16, 0, 15 );
				}
			break;
		case MOUSEX :
			if( ! origin )
				{
				sgi_OL_Erase();
				x = val;
				sgi_OL_Opaque();
				sgi_Rect( x0-xwin, y0-ywin, x-xwin, y-ywin );
				}
			else
				x = val;
			break;
		case MOUSEY :
			if( ! origin )
				{
				sgi_OL_Erase();
				y = val;
				sgi_OL_Opaque();
				sgi_Rect( x0-xwin, y0-ywin, x-xwin, y-ywin );
				}
			else
				y = val;
			break;
		case KEYBD :
			sgi_OL_End();
			qenter( KEYBD, val );
			unqdevice( MOUSEX );
			unqdevice( MOUSEY );
			unqdevice( MIDDLEMOUSE );
			return	0;
		case REDRAW :
			sgi_Pup_Redraw();
		case INPUTCHANGE :
			break;
			}
		}
	}

STATIC int
sgi_Window_In( origin, x, y, x0, y0, out_flag )
int	origin, x, y, x0, y0, out_flag;
	{	short		val;
		register long	dx = 0, dy = 0, dw = 0;
		double		relscale;
		double		x_translate, y_translate;
		long		xwin, ywin;
	if( ! tryGetOrigin( &xwin, &ywin ) )
		return -1; /* XXX */
	qdevice( MOUSEX );
	qdevice( MOUSEY );
	qdevice( MIDDLEMOUSE );
#ifdef mips
	overlay( 2 );
	gconfig();
#endif
	(void) fb_setcursor( fbiop, target1, 16, 16, 8, 8 );
	(void) fb_cursor( fbiop, 1, x, y );
	pupstr = winpupstr;
	sgi_Pup_Strs();
	sgi_OL_Start();
	for( ; ; )
		{
		if( ! qtest() )
			continue;
		switch( qread( &val ) )
			{
		case MENUBUTTON :
			/* Wait for user to let go.	*/
			for(	;
			      !	qtest()
			    ||	qread( &val ) != MENUBUTTON;
				)
				;
#define Pixel2Grid(x_) ((x_)/((double)fb_getwidth(fbiop)/grid_sz))
#define Grid2Model(x_) ((x_)*cell_sz)
			relscale = Pixel2Grid( dw*2.0 )/ (double)(grid_sz);
			if( out_flag )
				relscale = 1.0 / relscale;
			x_translate = (x0-xwin) - (fb_getwidth(fbiop)/2);
			x_translate = Pixel2Grid( x_translate );
			x_translate = Grid2Model( x_translate );
			y_translate = (y0-ywin) - (fb_getheight(fbiop)/2);
			y_translate = Pixel2Grid( y_translate );
			y_translate = Grid2Model( y_translate );
			if( out_flag )
				{
				x_grid_offset -= x_translate;
				y_grid_offset -= y_translate;
				}
			else
				{
				x_grid_offset += x_translate;
				y_grid_offset += y_translate;
				}
			view_size *= relscale;	/* Scale down view size. */
			sgi_OL_Erase();
			sgi_OL_End();
			unqdevice( MOUSEX );
			unqdevice( MOUSEY );
			unqdevice( MIDDLEMOUSE );
			qreset();
			return	1;
		case MIDDLEMOUSE :
			Toggle( origin );
			if( origin )
				{ /* Done framing window. */
				(void) fb_setcursor( fbiop, target1, 16, 16, 8, 8 );
				}
			else
				{ /* Framing a window. */
				x0 = x;
				y0 = y;
				sgi_OL_Erase();
				(void) fb_setcursor( fbiop, sweeportrack, 16, 16, 0, 16 );
				}
			break;
		case MOUSEX :
			if( ! origin )
				{
				sgi_OL_Erase();
				x = val;
				dx = x - x0;
				dx = Abs( dx );
				dw = Max( dx, dy );
				sgi_OL_Opaque();
				sgi_Rect( x0+dw-xwin, y0+dw-ywin, x0-dw-xwin, y0-dw-ywin );
				}
			else
				x = val;
			break;
		case MOUSEY :
			if( ! origin )
				{
				sgi_OL_Erase();
				y = val;
				dy = y - y0;
				dy = Abs( dy );
				dw = Max( dx, dy );
				sgi_OL_Opaque();
				sgi_Rect( x0+dw-xwin, y0+dw-ywin, x0-dw-xwin, y0-dw-ywin );
				}
			else
				y = val;
			break;
		case KEYBD :
			sgi_OL_End();
			qenter( KEYBD, val );
			unqdevice( MOUSEX );
			unqdevice( MOUSEY );
			unqdevice( MIDDLEMOUSE );
			return	0;
		case REDRAW :
			sgi_Pup_Redraw();
		case INPUTCHANGE :
			break;
			}
		}
	}

int
sgi_User_Input( args )
char	**args;
	{
	prnt_Status();
	for( ; ; )
		{
		if( qtest() )
			{	short	val;
				long	dev = qread( &val );
			switch( dev )
				{
			case MENUBUTTON :
				if( ! user_Pop( dopup( main_menu ) ) )
					return 0;
				prnt_Event( "" );
				prnt_Prompt( "" );
				(void) fflush( stdout );
				qreset();
				break;
			case MOUSEX :
				fb_log( "Mouse x = %d\n", (int) val );
				break;
			case MOUSEY :
				fb_log( "Mouse y = %d\n", (int) val );
				break;
			case KEYBD :
				break;
			case INPUTCHANGE :
				break;
			case REDRAW :
				sgi_Pup_Redraw();
				break;
			default :
				fb_log( "dev=%d val=%d\n", (int) dev, (int) val );
				break;
				}
			prnt_Status();
			}
		}
	}

int
sgi_Cursor_Input( x, y, mxp, myp, xx0, yy0, origin )
register int	x, y, *mxp, *myp;
int	xx0, yy0;
int	origin;
	{
	winset( (long) fbiop->if_fd );
	(void) winattach();
	for( ; ; )
		{
		(void) fb_setcursor( fbiop, menucursor, 16, 16, 0, 0 );
		if( qtest() )
			{	short	val;
				long	dev = qread( &val );
				int	ret;
			switch( dev )
				{
			case MENUBUTTON :
				(void) fb_setcursor( fbiop, arrowcursor, 16, 16, 0, 0 );
				switch( dopup( cursorect_menu ) )
					{
				case C_TAGPIXEL : /* Tag pixel. */
					*mxp = XSCR2MEM( x );
					*myp = YSCR2MEM( y );
					if( sgi_Tag_Pixel( origin, *mxp, *myp, xx0, yy0 ) )
						goto	hit_menubutton;
					else
						ret = 2;
					break;
				case C_SWEEPREC : /* Sweep rectangle. */
					*mxp = XSCR2MEM( x );
					*myp = YSCR2MEM( y );
					if( sgi_Sweep_Rect( origin, *mxp, *myp, xx0, yy0 ) )
						goto	hit_menubutton;
					else
						ret = 2;
					break;
				case C_I_WINDOW : /* Window in. */
					*mxp = XSCR2MEM( x );
					*myp = YSCR2MEM( y );
					if( rel_perspective > 0.0 )
						{
						prnt_Scroll( "Windowing does not yet work WITH perspective.\n" );
						prnt_Scroll( "Set perspective to zero or negative.\n" );
						}
					else
					if( sgi_Window_In( origin, *mxp, *myp, xx0, yy0, 0 ) )
						goto	hit_menubutton;
					else
						ret = 2;
					break;
				case C_O_WINDOW : /* Window out. */
					*mxp = XSCR2MEM( x );
					*myp = YSCR2MEM( y );
					if( rel_perspective > 0.0 )
						{
						prnt_Scroll( "Windowing does not yet work WITH perspective.\n" );
						prnt_Scroll( "Set perspective to zero or negative.\n" );
						}
					else
					if( sgi_Window_In( origin, *mxp, *myp, xx0, yy0, 1 ) )
						goto	hit_menubutton;
					else
						ret = 2;
					break;
				case C_QUERYREG : /* Query region. */
					*mxp = XSCR2MEM( x );
					*myp = YSCR2MEM( y );
					Toggle( query_region );
					if( sgi_Tag_Pixel( origin, *mxp, *myp, xx0, yy0 ) )
						goto	hit_menubutton;
					else
						ret = 2;
					break;
				default :
				hit_menubutton :
					ret = 3;
					break;
					}
				pupstr = menupupstr;
				sgi_Pup_Strs();
				qreset();
				(void) fb_setcursor( fbiop, arrowcursor, 16, 16, 0, 0 );
				(void) fb_cursor( fbiop, 1, grid_sz/2, grid_sz/2 );
				return	ret;
			case MOUSEX :
				fb_log( "Mouse x = %d\n", (int) val );
				break;
			case MOUSEY :
				fb_log( "Mouse y = %d\n", (int) val );
				break;
			case KEYBD :
				qenter( KEYBD, val );
				return	2;
			case INPUTCHANGE :
				break;
			case REDRAW :
				sgi_Pup_Redraw();
				break;
			default :
				fb_log( "dev=%d val=%d\n", (int) dev, (int) val );
				break;
				}
			}
		}
	}

/*
nul  0	soh  1	stx  2	etx  3	eot  4	enq  5	ack  6	bel  7
bs   8	ht   9	nl  10	vt  11	np  12	cr  13	so  14	si  15
dle 16	dc1 17	dc2 18	dc3 19	dc4 20	nak 21  syn 22	etb 23
can 24	em  25	sub 26	esc 27	fs  28	gs  29	rs  30	us  31
sp  32	!   33	"   34	#   35	$   36	%   37	&   38	'   39
(   40	)   41	*   42  +   43	,   44	-   45	.   46	/   47
0   48	1   49	2   50	3   51	4   52	5   53	6   54	7   55
8   56	9   57	:   58	;   59	<   60	=   61	>   62	?   63
@@   64	A   65	B   66	C   67	D   68	E   69	F   70	G   71
H   72	I   73	J   74	K   75	L   76	M   77	N   78	O   79
P   80	Q   81	R   82	S   83	T   84	U   85	V   86	W   87
X   88	Y   89	Z   90  [   91  \   92  ]   93  ^   94  _   95
`   96	a   97	b   98	c   99	d  100	e  101	f  102	g  103
h  104	i  105	j  106	k  107	l  108	m  109	n  110	o  111
p  112	q  113	r  114	s  115	t  116	u  117	v  118	w  119
x  120	y  121	z  122
 */
int
sgi_Init_Popup_Menu()
	{	long	grid_cntl_menu;
		long	file_name_menu;
		long	light_src_menu;
		long	special_menu;
		long	infrared_menu;
		long	materials_menu;
		long	raytracer_menu;
		long	one_digit_menu;
		long	tens_menu;
		long	twenties_menu;
		long	thirties_menu;
		long	forties_menu;
		long	fifties_menu;
		long	sixties_menu;
		long	sixties_partial_menu;
		long	seventies_menu;
		long	eighties_menu;
		long	nineties_menu;
	prefsize( PUPWID, PUPHGT );
	foreground();
	if( (popup_gid = winopen( "pop up menus" )) == -1 )
		{
		fb_log( "No more graphics ports available.\n" );
		return	-1;
		}
	wintitle( "pop up menus" );
	winconstraints(); /* Free window of constraints.		*/
	singlebuffer();
	pupstr = menupupstr;
	sgi_Pup_Strs();
	winattach();
	cursorect_menu = defpup( "cursor input %t|tag pixel %x0|sweep rectangle %x1|window in %x2|window out %x3|query region %x4" );
	one_digit_menu = defpup( "0..9 %t|0 %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9" );
	tens_menu =      defpup( "10..19 %t|10 %x10|11 %x11|12 %x12|13 %x13|14 %x14|15 %x15|16 %x16|17 %x17|18 %x18|19 %x19" );
	twenties_menu =  defpup( "20..29 %t|20 %x20|21 %x21|22 %x22|23 %x23|24 %x24|25 %x25|26 %x26|27 %x27|28 %x28|29 %x29" );
	thirties_menu =  defpup( "30..39 %t|30 %x30|31 %x31|32 %x32|33 %x33|34 %x34|35 %x35|36 %x36|37 %x37|38 %x38|39 %x39" );
	forties_menu =   defpup( "40..49 %t|40 %x40|41 %x41|42 %x42|43 %x43|44 %x44|45 %x45|46 %x46|47 %x47|48 %x48|49 %x49" );
	fifties_menu =   defpup( "50..59 %t|50 %x50|51 %x51|52 %x52|53 %x53|54 %x54|55 %x55|56 %x56|57 %x57|58 %x58|59 %x59" );
	sixties_menu =   defpup( "60..69 %t|60 %x60|61 %x61|62 %x62|63 %x63|64 %x64|65 %x65|66 %x66|67 %x67|68 %x68|69 %x69" );
	sixties_partial_menu =   defpup( "60..64 %t|60 %x60|61 %x61|62 %x62|63 %x63|64 %x64" );
	seventies_menu = defpup( "70..79 %t|70 %x70|71 %x71|72 %x72|73 %x73|74 %x74|75 %x75|76 %x76|77 %x77|78 %x78|79 %x79" );
	eighties_menu =  defpup( "80..89 %t|80 %x80|81 %x81|82 %x82|83 %x83|84 %x84|85 %x85|86 %x86|87 %x87|88 %x88|89 %x89" );
	nineties_menu =  defpup( "90..99 %t|90 %x90|91 %x91|92 %x92|93 %x93|94 %x94|95 %x95|96 %x96|97 %x97|98 %x98|99 %x99" );
#ifdef mips
	movie_fps_menu = defpup( "fps %t %F|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..64 %m %x-1",
				mips_Animate,
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_partial_menu
				);
	irflags_menu = defpup( "infrared module flags %t %F|read only %x1|edit %x2|octree rendering %x4|reset all flags %x0", mips_IR_Flags );
	irpaint_menu = defpup( "temperature painting from cursor module %t %F|ON %x1|OFF %x0", mips_IR_Paint );
	debugging_menu = defpup( "debugging %t %F|reset all flags %x0|all rays %x1|shoot %x2|db %x16|solids %x32|regions %x64|arb8 %x128|spline %x256|roots %x4096|partitioning %x8192|cut %x16384|boxing %x32768|memory allocation %x65536|testing %x131072|fdiff %x262144|RGB %x524288|refraction %x1048576|normals %x2097152|shadows %x4194304|cell size %x8388608|octree %x16777216", mips_Debugging );
	buffering_menu = defpup( "buffering %t %F|unbuffered %x0|paged buffering %x1|scan line buffered%x2", mips_Buffering );
	grid_size_menu = defpup( "resolution %t %F|16-by-16 %x16|32-by-32 %x32|64-by-64 %x64|128-by-128 %x128|256-by-256 %x256|512-by-512 %x512|1024-by-1024 %x1024", mips_Size_Grid );
	grid_cntl_menu = defpup( "gridding parameters %t|resolution %m %x71|distance to model centroid %x102|perspective %x112|roll %x97|field of view %x103|image translation %x68|grid translation %x116|anti-aliasing %x65|key-frame input %x106|movie set up %x74", grid_size_menu );
	lgts_prnt_menu = defpup( "light index %t %F|all %x-1|eye (ambient) %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9", mips_Lgt_Print );
	lgts_edit_menu = defpup( "light index %t %F|eye (ambient) %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9", mips_Lgt_Edit );
	light_src_menu = defpup( "light sources %t|print entry %m %x108|modify entry %m %x76|read database %x118|write database %x86", lgts_prnt_menu, lgts_edit_menu );
	mat_eindex_menu = defpup( "0..99 %t %F|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..69 %m %x-1|70..79 %m %x-1|80..89 %m %x-1|90..99 %m %x-1",
				mips_Mat_Edit,
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_menu,
				seventies_menu,
				eighties_menu,
				nineties_menu
				);
	mat_pindex_menu = defpup( "0..99 %t %F|all %x-2|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..69 %m %x-1|70..79 %m %x-1|80..89 %m %x-1|90..99 %m %x-1",
				mips_Mat_Print,
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_menu,
				seventies_menu,
				eighties_menu,
				nineties_menu
				);
	materials_menu = defpup( "material attributes %t|print entry %m %x109|modify entry %m %x77|read database %x119|write database %x87", mat_pindex_menu, mat_eindex_menu );
	max_ray_menu = defpup( "0..99 %t %F|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..69 %m %x-1|70..79 %m %x-1|80..89 %m %x-1|90..99 %m %x-1",
				mips_Max_Ray,
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_menu,
				seventies_menu,
				eighties_menu,
				nineties_menu
				);
	infrared_menu = defpup( "infrared module %t|set flags %m %x115|read real IR data %x73|read IR data base %x117|write IR data base %x85|disable automatic mapping offsets %x100|specify noise threshold %x105|set temperature %m %x78|assign temperature by region %x81|print temperatures by region %x80|display color assignment legend %x90", irflags_menu, irpaint_menu );
#else
	movie_fps_menu = defpup( "fps %t|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..64 %m %x-1",
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_partial_menu
				);
	irflags_menu = defpup( "infrared module flags %t|read only %x1|edit %x2|octree rendering %x4|reset all flags %x0" );
	irpaint_menu = defpup( "temperature painting from cursor module %t|ON %x1|OFF %x0" );
	debugging_menu = defpup( "debugging %t|reset all flags %x0|all rays %x1|shoot %x2|db %x16|solids %x32|regions %x64|arb8 %x128|spline %x256|roots %x4096|partitioning %x8192|cut %x16384|boxing %x32768|memory allocation %x65536|testing %x131072|fdiff %x262144|RGB %x524288|refraction %x1048576|normals %x2097152|shadows %x4194304|cell size %x8388608|octree %x16777216" );
	buffering_menu = defpup( "buffering %t|unbuffered %x0|paged buffering %x1|scan line buffered%x2" );
	grid_size_menu = defpup( "resolution %t|16-by-16 %x16|32-by-32 %x32|64-by-64 %x64|128-by-128 %x128|256-by-256 %x256|512-by-512 %x512|1024-by-1024 %x1024" );
	grid_cntl_menu = defpup( "gridding parameters %t|resolution %x71|distance to model centroid %x102|perspective %x112|roll %x97|field of view %x103|image translation %x68|grid translation %x116|anti-aliasing %x65|key-frame input %x106|movie set up %x74" );
	lgts_prnt_menu = defpup( "light index %t|all %x-1|eye (ambient) %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9" );
	lgts_edit_menu = defpup( "light index %t|eye (ambient) %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9" );
	light_src_menu = defpup( "light sources %t|print entry %x108|modify entry %x76|read database %x118|write database %x86" );
	two_digit_menu = defpup( "0..99 %t|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..69 %m %x-1|70..79 %m %x-1|80..89 %m %x-1|90..99 %m %x-1",
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_menu,
				seventies_menu,
				eighties_menu,
				nineties_menu
				);
	mat_index_menu = defpup( "0..99 %t|all %x-2|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..69 %m %x-1|70..79 %m %x-1|80..89 %m %x-1|90..99 %m %x-1",
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_menu,
				seventies_menu,
				eighties_menu,
				nineties_menu
				);
	materials_menu = defpup( "material attributes %t|print entry %x109|modify entry %x77|read database %x119|write database %x87" );
	infrared_menu = defpup( "infrared module %t|set flags %x115|read real IR data %x73|read IR data base %x117|write IR data base %x85|automatic mapping offsets %x100|specify noise threshold %x105|set temperature %x78|assign temperature by region %x81|print temperatures by region %x80|display color assignment legend %x90" );
#endif
	file_name_menu = defpup( "files %t|frame buffer %x111|error/debug log %x79|write script %x83|save image %x72|read image %x104" );
	raytracer_menu = defpup( "raytrace %t|go %x82|submit batch run %x66" );
	special_menu = defpup( "special applications %t|infrared modeling %m %x35|hidden-line drawing %x107",
				infrared_menu
				);
#ifdef mips
	main_menu = defpup( "main menu %t|raytrace %m %x35|animate %x70|gridding parameters %m %x35|buffering %m %x46|debugging %m %x101|shell escape %x33|background color %x98|maximum ray bounces %m %x75|tracking cursor (on/off) %x99|overlap reporting (on/off) %x88|cursor input %x67|clear frame buffer %x69|redraw text %x114|light sources %m %x35|material attributes %m %x35|files %m %x35|special applications %m %x35|quit %x113",
				raytracer_menu,
				grid_cntl_menu,
				buffering_menu,
				debugging_menu,
				max_ray_menu,
				light_src_menu,
				materials_menu,
				file_name_menu,
				special_menu
				);
#else
	main_menu = defpup( "main menu %t|raytrace %m %x35|animate %x70|gridding parameters %m %x35|buffering %x46|debugging %x101|shell escape %x33|background color %x98|maximum ray bounces %x75|tracking cursor (on/off) %x99|overlap reporting (on/off) %x88|cursor input %x67|clear frame buffer %x69|redraw text %x114|light sources %m %x35|material attributes %m %x35|files %m %x35|special applications %m %x35|quit %x113",
				raytracer_menu,
				grid_cntl_menu,
				light_src_menu,
				materials_menu,
				file_name_menu,
				special_menu
				);
#endif
	qdevice(MENUBUTTON);
	qdevice(KEYBD);
	qdevice(INPUTCHANGE);
	return	1;
	}

#ifdef mips
#include <sys/param.h>
#else
#include <machine/param.h>
#endif
void
sgi_Animate( framesz, fps )
int	framesz;
int	fps;
	{	register int	i, j;
		register int	wid;
		register int	xpos, ypos;
		static long	movie_gid = -1;
		long		xwin, ywin, xsiz, ysiz;
		long		movie_xwin, movie_ywin;
	if( fps < 1 )
		fps = 1;
	if( fps > HZ )
		fps = HZ;

	/* Get origin of frame buffer window (source). */
	if( ! tryGetOrigin( &xwin, &ywin ) )
		return; /* XXX */

	/* Get size of frame buffer window (source). */
	/* getsize( &xsiz, &ysiz ); */
	xsiz = fb_getwidth( fbiop );
	ysiz = fb_getheight( fbiop );

	wid = xsiz / framesz;
	xpos = ypos = xsiz / 2;
	zoom = 1;
	if( fb_zoom( fbiop, zoom, zoom ) == -1 )
		bu_log( "Can not set zoom <%d,%d>.\n", zoom, zoom );
	if( fb_viewport( fbiop, 0, 0, xsiz, ysiz ) == -1 )
		bu_log( "Can not set viewport {<%d,%d>,<%d,%d>}.\n",
			0, 0, xsiz, ysiz
			);
	if( fb_window( fbiop, xpos, ypos ) == -1 )
		bu_log( "Can not set window <%d,%d>.\n", xpos, ypos );

	/* Create destination window for movie, with user positioning. */
	prefsize( framesz, framesz );
	if( (movie_gid = winopen( "movie" )) == -1 )
		{
		fb_log( "No more graphics ports available.\n" );
		return;
		}
	/* Adjust window position optimally for fast "rectcopy()". */
	if( ! tryGetOrigin( &movie_xwin, &movie_ywin ) )
		return; /* XXX */
	if( ((xwin - movie_xwin) % 16) != 0 )
		movie_xwin += (xwin - movie_xwin) % 16;
	while( movie_xwin > XMAXSCREEN - framesz )
		movie_xwin -= 16;
	winmove( movie_xwin, movie_ywin );

	fullscrn();
	RGBmode();	/* By pass color table, interpret pixel RGB values. */
	gconfig();

	qdevice( MIDDLEMOUSE );
	for( ; ; )
	for( i = 0; i < wid; i++ )
		{
		for( j = 0; j < wid; j++ )
			{
			sginap( HZ/(long)fps );
			if( qtest() )
				{	short	val;
				switch( qread( &val ) )
					{
				case MENUBUTTON :
					/* Wait for user to let go.	*/
					for(	;
					      !	qtest()
					    ||	qread( &val ) != MENUBUTTON;
						)
						;
					break;	
				case MIDDLEMOUSE :
					/* Wait for user to let go.	*/
					for(	;
					      !	qtest()
					    ||	qread( &val ) != MIDDLEMOUSE;
						)
						;
					endfullscrn();
					unqdevice( MIDDLEMOUSE );
					winclose( movie_gid );
					winset( fbiop->if_fd );
					return;
					}
				}
			rectcopy((Screencoord)(xwin+j*framesz),
				 (Screencoord)(ywin+i*framesz),
				 (Screencoord)(xwin+(j+1)*framesz)-1,
				 (Screencoord)(ywin+(i+1)*framesz)-1,
				 (Screencoord) movie_xwin,
				 (Screencoord) movie_ywin
				 );
			}
		}
	}

char *
sgi_GetInput( inbuf, bufsz, msg )
char	 *inbuf;
int	 bufsz;
char	*msg;
	{	static char	buffer[BUFSIZ];
		register char	*p = buffer;
		register int	c;
	prnt_Prompt( msg );
	*p = NUL;
	do
		{		(void) fflush( stdout );
		c = hm_getchar();
		switch( c )
			{
		case Ctrl('A') : /* Cursor to beginning of line.	*/
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			for( ; p > buffer; p-- )
				(void) putchar( BS );
			break;
		case Ctrl('B') :
		case BS : /* Move cursor back one character.		*/
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			(void) putchar( BS );
			--p;
			break;
		case Ctrl('D') : /* Delete character under cursor.	*/
			{	register char	*q = p;
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			for( ; *q != NUL; ++q )
				{
				*q = *(q+1);
				(void) putchar( *q != NUL ? *q : SP );
				}
			for( ; q > p; --q )
				(void) putchar( BS );
			break;
			}
		case Ctrl('E') : /* Cursor to end of line.		*/
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			(void) printf( "%s", p );
			p += strlen( p );
			break;
		case Ctrl('F') : /* Cursor forward one character.	*/
			if( *p == NUL || p-buffer >= bufsz-2 )
				{
				ring_Bell();
				break;
				}
			putchar( *p++ );
			break;
		case Ctrl('G') : /* Abort input.			*/
			ring_Bell();
			prnt_Event( "Aborted." );
			prnt_Prompt( "" );
			return	NULL;
		case Ctrl('K') : /* Erase from cursor to end of line.	*/
			if( *p == NUL )
				{
				ring_Bell();
				break;
				}
			ClrEOL();
			*p = NUL;
			break;
		case Ctrl('P') : /* Yank previous contents of "inbuf".	*/
			{	register int	len = strlen( inbuf );
			if( (p + len) - buffer >= BUFSIZ )
				{
				ring_Bell();
				break;
				}
			(void) strncpy( p, inbuf, bufsz );
			(void) printf( "%s", p );
			p += len;
			break;
			}
		case Ctrl('U') : /* Erase from start of line to cursor.	*/
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			for( ; p > buffer; --p )
				{	register char	*q = p;
				(void) putchar( BS );
				for( ; *(q-1) != NUL; ++q )
					{
					*(q-1) = *q;
					(void) putchar( *q != NUL ? *q : SP );
					}
				for( ; q > p; --q )
					(void) putchar( BS );
				}
			break;
		case Ctrl('R') : /* Print line, cursor doesn't move.	*/
			{	register int	i;
			if( buffer[0] == NUL )
				break;
			for( i = p - buffer; i > 0; i-- )
				(void) putchar( BS );
			(void) printf( "%s", buffer );
			for( i = strlen( buffer ) - (p - buffer); i > 0; i-- )
				(void) putchar( BS );
			break;
			}
		case DEL : /* Delete character behind cursor.		*/
			{	register char	*q = p;
			if( p == buffer )
				{
				ring_Bell();
				break;
				}
			(void) putchar( BS );
			for( ; *(q-1) != NUL; ++q )
				{
				*(q-1) = *q;
				(void) putchar( *q != NUL ? *q : SP );
				}
			for( ; q > p; --q )
				(void) putchar( BS );
			p--;
			break;
			}
		case CR :
		case LF :
		case EOF :
			(void) strncpy( inbuf, buffer, bufsz );
			prnt_Prompt( "" );
			if( inbuf[0] == '\0' )
				return	NULL;
			else
				return	inbuf;
		case Ctrl('V') :
			/* Escape character, do not process next char.	*/
			c = hm_getchar();
			/* Fall through to default case!		*/
		default : /* Insert character at cursor.		*/
			{	register char	*q = p;
				register int	len = strlen( p );
			/* Print control characters as strings.		*/
			if( c >= NUL && c < SP )
				(void) printf( "%s", char_To_String( c ) );
			else
				(void) putchar( c );
			/* Scroll characters forward.			*/
			for( ; len >= 0; len--, q++ )
				(void) putchar( *q == NUL ? SP : *q );
			for( ; q > p; q-- )
				{
				(void) putchar( BS );
				*q = *(q-1);
				}
			*p++ = c;
			break;
			}
			} /* End switch. */
		}
	while( strlen( buffer ) < BUFSIZ );
	(void) strncpy( inbuf, buffer, bufsz );
	ring_Bell();
	prnt_Event( "Buffer full." );
	prnt_Prompt( "" );
	return	inbuf;
	}

STATIC void
sgi_Read_Keyboard( args )
char	**args;
	{	register int	i;
		register char	*eof_flag;
	(void) get_Input( input_ln, BUFSIZ, ": " );
	if( (args[0] = strtok( input_ln, " \t" )) == NULL )
		{
		args[0] = "#";
		args[1] = NULL;
		return;
		}
	for( i = 1; args[i-1] != NULL ; ++i )
		args[i] = strtok( (char *) NULL, " \t" );
	return;
	}

int
sgi_Getchar()
	{	short	val;
	(void) winattach();
	while( ! qtest() || qread( &val ) != KEYBD )
		;
	return	(int) val;
	}

int
sgi_Ungetchar( c )
int	c;
	{	short	val = c;
	qenter( KEYBD, val );
	return c;
	}
#endif
@


11.4
log
@change conf.h to a wrapped config.h
@
text
@d13 1
a13 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/sgi_dep.c,v 11.3 2000/08/24 22:55:53 mike Exp $ (BRL)";
@


11.3
log
@
RCSid
@
text
@d13 1
a13 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/sgi_dep.c,v 11.2 1999/06/03 21:40:51 mike Exp $ (BRL)";
d16 5
a20 1
#include "conf.h"
@


11.2
log
@
sed4
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/sgi_dep.c,v 11.1 1995/01/04 10:18:04 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/sgi_dep.c,v 10.5 94/12/14 20:08:42 mike Exp $ (BRL)";
d240 1
a240 1
		rt_log( "Multiple bounces disallowed during IR mapping.\n" );
d1025 1
a1025 1
		rt_log( "Can not set zoom <%d,%d>.\n", zoom, zoom );
d1027 1
a1027 1
		rt_log( "Can not set viewport {<%d,%d>,<%d,%d>}.\n",
d1031 1
a1031 1
		rt_log( "Can not set window <%d,%d>.\n", xpos, ypos );
@


10.5
log
@Oops.
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/sgi_dep.c,v 10.4 94/11/24 02:27:03 mike Exp Locker: mike $ (BRL)";
@


10.4
log
@GL
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/sgi_dep.c,v 10.3 94/09/21 21:58:19 mike Exp Locker: mike $ (BRL)";
d16 4
a20 1
#include <stdio.h>
@


10.3
log
@IRIX 5 warnings.
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/sgi_dep.c,v 10.2 94/08/24 13:37:48 gdurf Exp Locker: mike $ (BRL)";
d16 1
a16 1
#if defined(sgi) || defined(__sgi)
@


10.2
log
@Made includes explicit
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/sgi_dep.c,v 10.1 1991/10/12 06:50:16 mike Rel4_0 gdurf $ (BRL)";
d651 1
a651 1
					return;
@


10.1
log
@Release_4.0
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/sgi_dep.c,v 9.5 91/08/27 14:33:05 stay Exp $ (BRL)";
d22 9
@


9.5
log
@added an __sgi for Irix 4.0 
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/sgi_dep.c,v 9.4 90/03/29 13:02:25 moss Exp $ (BRL)";
@


9.4
log
@Fixed animation on SGIs, and other routines using getorigin() to check
the device type to make sure that /dev/sgi* is being used.  This prevents
core dumps associated with calling getorigin() when the remote frame
buffer is being used.
@
text
@d13 1
a13 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 9.2 89/11/01 16:30:13 moss Locked $ (BRL)";
d16 1
a16 1
#ifdef sgi
@


9.3
log
@Added comment.
@
text
@d25 1
d63 26
a161 1
extern void	sgi_Pt_Select();
d180 1
d304 44
d367 2
a368 1
	getorigin( &xwin, &ywin );
d426 2
a427 1
	getorigin( &xwin, &ywin );
d515 2
a516 1
	getorigin( &xwin, &ywin );
d1001 2
a1002 1
	getorigin( &xwin, &ywin );
d1029 2
a1030 1
	getorigin( &movie_xwin, &movie_ywin );
@


9.2
log
@Added call to RGBmode() in sgi_Animate.
Uses fb_get[width|height] rather than getsize().
@
text
@d6 5
a10 1
			(301)278-6647 or AV-298-6647
d13 1
a13 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 9.1 89/05/19 06:13:34 moss Locked $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 8.3 89/05/12 23:27:52 moss Exp $ (BRL)";
d922 1
a922 1
	/* Get origin of frame buffer window (source).			*/
d925 5
a929 2
	/* Get size of frame buffer window (source).			*/
	getsize( &xsiz, &ysiz );
d942 1
a942 1
	/* Create destination window for movie, with user positioning.	*/
d949 1
a949 1
	/* Adjust window position optimally for fast "rectcopy()".	*/
d958 3
@


8.3
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 8.1 88/10/05 00:52:17 moss Locked $ (BRL)";
@


8.2
log
@Removed local declarations of input_ln since the global copy is available.
@
text
@d17 2
a18 4
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./lgt.h"
a20 2
#undef RED
#include "./extern.h"
d58 1
a58 1
_LOCAL_ void
d72 1
a72 1
_LOCAL_ void
d83 1
a83 1
_LOCAL_ void
d94 1
a94 1
_LOCAL_ void
d105 1
a105 1
_LOCAL_ void
d116 1
a116 1
_LOCAL_ void
d150 1
a150 1
_LOCAL_ void	sgi_Read_Keyboard();
d152 1
a152 1
_LOCAL_ int
d160 1
a160 1
_LOCAL_ int
d169 1
a169 1
_LOCAL_ int
d183 1
a183 1
_LOCAL_ int
d192 1
a192 1
_LOCAL_ int
d203 1
a203 1
_LOCAL_ int
d211 1
a211 1
_LOCAL_ int
d219 1
a219 1
_LOCAL_ int
d227 1
a227 1
_LOCAL_ int
d235 1
a235 1
_LOCAL_ int
d247 1
a247 1
_LOCAL_ int
d252 1
a252 1
	set_Size_Grid( grid_sz );	
d256 1
a256 1
_LOCAL_ void
d272 1
a272 1
_LOCAL_ void
d282 1
a282 1
_LOCAL_ int
d345 1
a345 1
_LOCAL_ int
d430 1
a430 1
_LOCAL_ int
d464 1
a464 1
#define Pixel2Grid(x_) ((x_)/((double)fbiop->if_width/grid_sz))
d469 1
a469 1
			x_translate = (x0-xwin) - (fbiop->if_width/2);
d472 1
a472 1
			y_translate = (y0-ywin) - (fbiop->if_height/2);
d485 1
a485 1
			grid_scale *= relscale;	/* Scale down grid.	*/
d496 1
a496 1
				{ /* Done framing window.	*/
d500 1
a500 1
				{ /* Framing a window.		*/
d1181 1
a1181 1
_LOCAL_ void
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 7.6 88/08/30 10:30:01 moss Locked $ (BRL)";
d179 1
a179 1
		{	char	input_ln[MAX_LN];
d1188 1
a1188 2
	{	char		input_ln[BUFSIZ];
		register int	i;
@


7.6
log
@Removed texture file command from SGI menus.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 7.2 87/12/09 13:43:11 moss Locked $ (BRL)";
@


7.5
log
@Did away with texture file commands, and added textures to material
properties data base.
@
text
@d873 1
a873 1
	file_name_menu = defpup( "files %t|frame buffer %x111|error/debug log %x79|write script %x83|save image %x72|read image %x104|texture map %x84" );
@


7.4
log
@Added menu entry for accessing f_Overlaps.
@
text
@d21 1
a580 7
				qenter( KEYBD, val );
				sgi_Read_Keyboard( args );
				if( ! user_Cmd( args ) )
					return;
				prnt_Event( "" );
				prnt_Prompt( "" );
				(void) fflush( stdout );
d1003 182
d1191 1
a1191 1
	get_Input( input_ln, BUFSIZ, ": " );
@


7.3
log
@Smoothing out menu and prompting interface.
@
text
@d885 1
a885 1
	main_menu = defpup( "main menu %t|raytrace %m %x35|animate %x70|gridding parameters %m %x35|buffering %m %x46|debugging %m %x101|shell escape %x33|background color %x98|maximum ray bounces %m %x75|tracking cursor (on/off) %x99|cursor input %x67|clear frame buffer %x69|redraw text %x114|light sources %m %x35|material attributes %m %x35|files %m %x35|special applications %m %x35|quit %x113",
d897 1
a897 1
	main_menu = defpup( "main menu %t|raytrace %m %x35|animate %x70|gridding parameters %m %x35|buffering %x46|debugging %x101|shell escape %x33|background color %x98|maximum ray bounces %x75|tracking cursor (on/off) %x99|cursor input %x67|clear frame buffer %x69|redraw text %x114|light sources %m %x35|material attributes %m %x35|files %m %x35|special applications %m %x35|quit %x113",
@


7.2
log
@Improvements to IR modeling interface.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 7.1 87/11/03 00:25:54 moss Locked $ (BRL)";
d19 1
d24 109
d145 3
d152 1
d155 3
a157 3
int
sgi_User_Input( args )
char	**args;
d159 23
a181 41
	prnt_Status();
	for( ; ; )
		{
		if( qtest() )
			{	short	val;
				long	dev = qread( &val );
			switch( dev )
				{
			case MENUBUTTON :
				if( ! user_Pop( dopup( main_menu ) ) )
					return;
				prnt_Event( "" );
				prnt_Prompt( "" );
				(void) fflush( stdout );
				qreset();
				break;
			case MOUSEX :
				fb_log( "Mouse x = %d\n", (int) val );
				break;
			case MOUSEY :
				fb_log( "Mouse y = %d\n", (int) val );
				break;
			case KEYBD :
				qenter( KEYBD, val );
				sgi_Read_Keyboard( args );
				if( ! user_Cmd( args ) )
					return;
				prnt_Event( "" );
				prnt_Prompt( "" );
				(void) fflush( stdout );
				break;
			case INPUTCHANGE :
				break;
			case REDRAW :
				break;
			default :
				fb_log( "dev=%d val=%d\n", (int) dev, (int) val );
				break;
				}
			prnt_Status();
			}
d183 1
d186 82
a267 43
/*
nul  0	soh  1	stx  2	etx  3	eot  4	enq  5	ack  6	bel  7
bs   8	ht   9	nl  10	vt  11	np  12	cr  13	so  14	si  15
dle 16	dc1 17	dc2 18	dc3 19	dc4 20	nak 21  syn 22	etb 23
can 24	em  25	sub 26	esc 27	fs  28	gs  29	rs  30	us  31
sp  32	!   33	"   34	#   35	$   36	%   37	&   38	'   39
(   40	)   41	*   42  +   43	,   44	-   45	.   46	/   47
0   48	1   49	2   50	3   51	4   52	5   53	6   54	7   55
8   56	9   57	:   58	;   59	<   60	=   61	>   62	?   63
@@   64	A   65	B   66	C   67	D   68	E   69	F   70	G   71
H   72	I   73	J   74	K   75	L   76	M   77	N   78	O   79
P   80	Q   81	R   82	S   83	T   84	U   85	V   86	W   87
X   88	Y   89	Z   90  [   91  \   92  ]   93  ^   94  _   95
`   96	a   97	b   98	c   99	d  100	e  101	f  102	g  103
h  104	i  105	j  106	k  107	l  108	m  109	n  110	o  111
p  112	q  113	r  114	s  115	t  116	u  117	v  118	w  119
x  120	y  121	z  122
 */
int
sgi_Init_Popup_Menu()
	{	long	grid_cntl_menu;
		long	file_name_menu;
		long	light_src_menu;
		long	special_menu;
		long	infrared_menu;
		long	materials_menu;
		long	raytracer_menu;
		long	one_digit_menu;
		long	tens_menu;
		long	twenties_menu;
		long	thirties_menu;
		long	forties_menu;
		long	fifties_menu;
		long	sixties_menu;
		long	sixties_partial_menu;
		long	seventies_menu;
		long	eighties_menu;
		long	nineties_menu;
#define MARGIN	4
#define PUPSZ	(140+MARGIN)
	prefposition( 1024-PUPSZ, 1023-MARGIN, 768-PUPSZ, 768-MARGIN-20 );
	foreground();
	if( (popup_gid = winopen( "pop up menus" )) == -1 )
d269 2
a270 2
		fb_log( "No more graphics ports available.\n" );
		return	-1;
d272 1
a272 76
	wintitle( "pop up menus" );
	winconstraints(); /* Free window of constraints.		*/
	winattach();
	buffering_menu = defpup( "buffering %t|unbuffered %x0|paged buffering %x1|scan line buffered%x2" );
	cursorect_menu = defpup( "cursor input %t|tag pixel %x0|sweep rectangle %x1|window in %x2|window out %x3|query region %x4" );
	debugging_menu = defpup( "debugging %t|reset all flags %x0|all rays %x1|shoot %x2|db %x16|solids %x32|regions %x64|arb8 %x128|spline %x256|roots %x4096|partitioning %x8192|cut %x16384|boxing %x32768|memory allocation %x65536|testing %x131072|fdiff %x262144|RGB %x524288|refraction %x1048576|normals %x2097152|shadows %x4194304|cell size %x8388608|octree %x16777216" );
	irpaint_menu = defpup( "temperature painting from cursor module %t|ON %x1|OFF %x0" );
	irflags_menu = defpup( "infrared module flags %t|read only %x1|edit %x2|octree rendering %x4|reset all flags %x0" );
	grid_cntl_menu = defpup( "gridding parameters %t|resolution %x71|distance to model centroid %x102|perspective %x112|roll %x97|field of view %x103|image translation %x68|grid translation %x116|over sampling factor %x65|key frame input %x106|movie setup %x74|animate %x70" );
	grid_size_menu = defpup( "resolution %t|16-by-16 %x16|32-by-32 %x32|64-by-64 %x64|128-by-128 %x128|256-by-256 %x256|512-by-512 %x512|1024-by-1024 %x1024" );
	file_name_menu = defpup( "files %t|frame buffer %x111|error/debug log %x79|write script %x83|save image %x72|read image %x104|texture map %x84" );
	light_src_menu = defpup( "light sources %t|print entry %x108|modify entry %x76|read database %x118|write database %x86" );
	lgts_edit_menu = defpup( "light index %t|eye (ambient) %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9" );
	lgts_prnt_menu = defpup( "light index %t|all %x-1|eye (ambient) %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9" );
	one_digit_menu = defpup( "0..9 %t|0 %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9" );
	tens_menu =      defpup( "10..19 %t|10 %x10|11 %x11|12 %x12|13 %x13|14 %x14|15 %x15|16 %x16|17 %x17|18 %x18|19 %x19" );
	twenties_menu =  defpup( "20..29 %t|20 %x20|21 %x21|22 %x22|23 %x23|24 %x24|25 %x25|26 %x26|27 %x27|28 %x28|29 %x29" );
	thirties_menu =  defpup( "30..39 %t|30 %x30|31 %x31|32 %x32|33 %x33|34 %x34|35 %x35|36 %x36|37 %x37|38 %x38|39 %x39" );
	forties_menu =   defpup( "40..49 %t|40 %x40|41 %x41|42 %x42|43 %x43|44 %x44|45 %x45|46 %x46|47 %x47|48 %x48|49 %x49" );
	fifties_menu =   defpup( "50..59 %t|50 %x50|51 %x51|52 %x52|53 %x53|54 %x54|55 %x55|56 %x56|57 %x57|58 %x58|59 %x59" );
	sixties_menu =   defpup( "60..69 %t|60 %x60|61 %x61|62 %x62|63 %x63|64 %x64|65 %x65|66 %x66|67 %x67|68 %x68|69 %x69" );
	sixties_partial_menu =   defpup( "60..64 %t|60 %x60|61 %x61|62 %x62|63 %x63|64 %x64" );
	seventies_menu = defpup( "70..79 %t|70 %x70|71 %x71|72 %x72|73 %x73|74 %x74|75 %x75|76 %x76|77 %x77|78 %x78|79 %x79" );
	eighties_menu =  defpup( "80..89 %t|80 %x80|81 %x81|82 %x82|83 %x83|84 %x84|85 %x85|86 %x86|87 %x87|88 %x88|89 %x89" );
	nineties_menu =  defpup( "90..99 %t|90 %x90|91 %x91|92 %x92|93 %x93|94 %x94|95 %x95|96 %x96|97 %x97|98 %x98|99 %x99" );
	two_digit_menu = defpup( "0..99 %t|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..69 %m %x-1|70..79 %m %x-1|80..89 %m %x-1|90..99 %m %x-1",
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_menu,
				seventies_menu,
				eighties_menu,
				nineties_menu
				);
	mat_index_menu = defpup( "0..99 %t|all %x-2|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..69 %m %x-1|70..79 %m %x-1|80..89 %m %x-1|90..99 %m %x-1",
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_menu,
				seventies_menu,
				eighties_menu,
				nineties_menu
				);
	movie_fps_menu = defpup( "fps %t|0..9 %m %x-1|10..19 %m %x-1|20..29 %m %x-1|30..39 %m %x-1|40..49 %m %x-1|50..59 %m %x-1|60..64 %m %x-1",
				one_digit_menu,
				tens_menu,
				twenties_menu,
				thirties_menu,
				forties_menu,
				fifties_menu,
				sixties_partial_menu
				);
	infrared_menu = defpup( "infrared module %t|set flags %x115|read real IR data %x73|read IR data base %x117|write IR data base %x85|automatic mapping offsets %x100|specify noise threshold %x105|set temperature %x78|assign temperature by region %x81|print temperatures by region %x80|display color assignment legend %x90" );
	raytracer_menu = defpup( "raytrace %t|go %x82|submit batch run %x66" );
	materials_menu = defpup( "material attributes %t|print entry %x109|modify entry %x77|read database %x119|write database %x87" );
	special_menu = defpup( "special applications %t|infrared modeling %m %x35|hidden-line drawing %x107",
				infrared_menu
				);
	main_menu = defpup( "main menu %t|raytrace %m %x35|gridding parameters %m %x35|buffering %x46|debugging %x101|shell escape %x33|background color %x98|maximum ray bounces %x75|tracking cursor (on/off) %x99|cursor input %x67|clear frame buffer %x69|redraw text %x114|light sources %m %x35|material attributes %m %x35|files %m %x35|special applications %m %x35|quit %x113",
				raytracer_menu,
				grid_cntl_menu,
				light_src_menu,
				materials_menu,
				file_name_menu,
				special_menu
				);
	qdevice(MENUBUTTON);
	qdevice(KEYBD);
	qdevice(INPUTCHANGE);
	return	1;
d275 12
a286 2
int
sgi_Sweep_Rect( origin, x, y, x0, y0 )
d290 2
a291 1
	getorigin( &xwin, &ywin );
d295 1
d298 2
d307 2
a308 5
			/* Wait for user to let go.	*/
			for(	;
			      !	qtest()
			    ||	qread( &val ) != MENUBUTTON;
				)
d314 1
a314 2
			(void) fb_setcursor( fbiop, arrowcursor, 16, 16, 0, 0 );
			(void) fb_cursor( fbiop, tracking_cursor, grid_sz/2, grid_sz/2 );
d317 3
d321 5
a325 13
			if( origin )
				/* Done sweeping.	*/
				(void) fb_setcursor( fbiop, target1, 16, 16, 8, 8 );
			else
				{ /* Sweeping a rectangle.*/
				cursoff();
				pupmode();
				pupcolor( PUP_CLEAR );
				clear();
				endpupmode();
				curson();
				(void) fb_setcursor( fbiop, sweeportrack, 16, 16, 0, 15 );
				}
d328 1
a328 14
			if( ! origin )
				{
				cursoff();
				pupmode();
				pupcolor( PUP_CLEAR );
				recti( x0-xwin, y0-ywin, x-xwin, y-ywin );
				x = val;
				pupcolor( PUP_WHITE );
				recti( x0-xwin, y0-ywin, x-xwin, y-ywin );
				endpupmode();
				curson();
				}
			else
				x = val;
d331 1
a331 14
			if( ! origin )
				{
				cursoff();
				pupmode();
				pupcolor( PUP_CLEAR );
				recti( x0-xwin, y0-ywin, x-xwin, y-ywin );
				y = val;
				pupcolor( PUP_WHITE );
				recti( x0-xwin, y0-ywin, x-xwin, y-ywin );
				endpupmode();
				curson();
				}
			else
				y = val;
d338 1
d340 2
d348 2
a349 3

int
sgi_Tag_Pixel( origin, x, y, x0, y0 )
d353 1
a353 2
		int	flag = tracking_cursor;
	tracking_cursor = FALSE; /* Disable tracking cursor.		*/
d357 4
a360 1
	getorigin( &xwin, &ywin );
d363 3
d373 5
a377 2
			/* Wait for user to let go.			*/
			for( ; ! qtest() || qread( &val ) != MENUBUTTON; )
d379 1
a383 3
			tracking_cursor = flag;
			(void) fb_setcursor( fbiop, arrowcursor, 16, 16, 0, 0 );
			(void) fb_cursor( fbiop, tracking_cursor, grid_sz/2, grid_sz/2 );
a385 3
			/* Wait for user to let go.			*/
			for( ; ! qtest() || qread( &val ) != MIDDLEMOUSE; )
				;
d387 8
a394 4
			sgi_Pt_Select( x, y, &x0, &y0, &origin );
			user_interrupt = FALSE;
			render_Model();
			qreset();
d397 9
a405 1
			x = val;
d408 9
a416 1
			y = val;
d419 1
a423 1
			tracking_cursor = flag;
d425 2
d433 1
a433 1
int
d437 2
a438 2
		register int	dx = 0, dy = 0, dw = 0;
		double		scale;
d445 4
d451 3
d469 1
a469 1
			scale = Pixel2Grid( dw*2.0 )/ (double)(grid_sz);
d471 1
a471 1
				scale = 1.0 / scale;
d488 3
a490 7
			grid_scale *= scale;	/* Scale down grid.	*/
			cursoff();
			pupmode();
			pupcolor( PUP_CLEAR );
			clear();
			endpupmode();
			curson();
a494 2
			(void) fb_setcursor( fbiop, arrowcursor, 16, 16, 0, 0 );
			(void) fb_cursor( fbiop, tracking_cursor, grid_sz/2, grid_sz/2 );
d506 1
a506 6
				cursoff();
				pupmode();
				pupcolor( PUP_CLEAR );
				clear();
				endpupmode();
				curson();
d513 1
a513 4
				cursoff();
				pupmode();
				pupcolor( PUP_CLEAR );
				recti( x0-dw-xwin, y0-dw-ywin, x0+dw-xwin, y0+dw-ywin );
d518 2
a519 4
				pupcolor( PUP_WHITE );
				recti( x0-dw-xwin, y0-dw-ywin, x0+dw-xwin, y0+dw-ywin );
				endpupmode();
				curson();
d527 1
a527 4
				cursoff();
				pupmode();
				pupcolor( PUP_CLEAR );
				recti( x0-dw-xwin, y0-dw-ywin, x0+dw-xwin, y0+dw-ywin );
d532 2
a533 4
				pupcolor( PUP_WHITE );
				recti( x0-dw-xwin, y0-dw-ywin, x0+dw-xwin, y0+dw-ywin );
				endpupmode();
				curson();
d539 1
d545 2
d553 362
d916 1
d918 2
a919 1
sgi_Animate( fps )
d923 1
d925 1
a925 1
		long		xwin, ywin;
a930 1
	wid = 512 / grid_sz;
d935 14
d950 1
a950 1
	prefsize( grid_sz, grid_sz );
d960 1
a960 1
	while( movie_xwin > XMAXSCREEN - grid_sz )
d998 4
a1001 4
			rectcopy((Screencoord)(xwin+j*grid_sz),
				 (Screencoord)(ywin+i*grid_sz),
				 (Screencoord)(xwin+(j+1)*grid_sz)-1,
				 (Screencoord)(ywin+(i+1)*grid_sz)-1,
d1030 1
a1030 1
	winattach();
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 6.3 87/11/02 20:49:00 mike Exp $ (BRL)";
a10 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) sgi_dep.c	2.2
		Modified: 	1/30/87 at 17:22:18	G S M
		Retrieved: 	2/4/87 at 08:53:30
		SCCS archive:	/vld/moss/src/lgt/s.sgi_dep.c
*/
d29 2
d45 1
a47 1
		prnt_Status();
d84 1
a84 1
			(void) fflush( stdout ); /* Debugging */
d112 2
d141 3
a143 1
	debugging_menu = defpup( "debugging %t|reset all flags %x0|all rays %x1|shoot %x2|db %x16|solids %x32|regions %x64|arb8 %x128|spline %x256|roots %x4096|partitioning %x8192|cut %x16384|boxing %x32768|memory allocation %x65536|testing %x131072|fdiff %x262144|RGB %x524288|refraction %x1048576|normals %x2097152|shadows %x4194304|gaussian beam %x8388608|octree %x16777216" );
d194 2
d197 4
a200 2
	raytracer_menu = defpup( "raytrace %t|go %x82|submit batch run %x66" );
	main_menu = defpup( "main menu %t|raytrace %m %x35|gridding parameters %m %x35|buffering %x46|debugging %x101|shell escape %x33|background color %x98|maximum ray bounces %x75|tracking cursor (on/off) %x99|cursor input %x67|clear frame buffer %x69|redraw text %x114|light sources %m %x35|material attributes %m %x35|files %m %x35|quit %x113",
d205 2
a206 1
				file_name_menu
a243 1
			close_Output_Device();
d327 1
a327 4
			for(	;
			      !	qtest()
			    ||	qread( &val ) != MENUBUTTON;
				)
a335 1
			close_Output_Device();
d338 3
a426 1
			close_Output_Device();
@


6.3
log
@Fixed return from sgi_Ungetchar().  qenter() is a void-valued function.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 6.2 87/10/15 10:43:03 mike Locked $ (BRL)";
@


6.2
log
@Accommodated changes to librt DEBUG_* defines.
Added minor support for hmenu compatibility.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 5.1 87/06/24 22:48:19 mike Rel $ (BRL)";
d605 2
a606 1
	return	qenter( KEYBD, val );
@


6.1
log
@Release 2.0
@
text
@d52 1
d143 2
a144 2
	cursorect_menu = defpup( "cursor input %t|tag pixel %x0|sweep rectangle %x1|window in %x2|window out %x3" );
	debugging_menu = defpup( "debugging %t|reset all flags %x0|solids %x1|hits %x2|all shots %x4|rootfinder %x8|regions and booleans %x16|arb8 %x32|partitioning %x64|space subdivision %x128|box checking %x256|shootray processing %x512|plot(3) of bounding RPPs %x1024|ray(4V) output %x2048|splines %x4096|database %x8192|RGB %x65536|refraction %x131072|normals %x262144|shadows %x524288|gaussian beam %x1048576|octree %x2097152" );
d341 3
a343 1
			(void) ray_Trace();
d601 6
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 1.3 87/06/23 12:33:16 moss Exp $ (BRL)";
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 1.2 87/02/06 12:29:48 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: sgi_dep.c,v 1.1 87/02/04 15:15:07 moss Locked $ (BRL)";
d37 3
a39 1
long		lgt_index_menu;
d148 2
a149 1
	lgt_index_menu = defpup( "light index %t|eye (ambient) %x0|1 %x1|2 %x2|3 %x3|4 %x4|5 %x5|6 %x6|7 %x7|8 %x8|9 %x9" );
d173 12
d388 2
a389 2
#define Pixel2Grid(x_) (x_/((double)fbiop->if_width/grid_sz))
#define Grid2Model(x_) (x_*cell_sz)
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
a22 1
#include <std.h>
d24 4
a42 13

#if 0
#include <bsd/sys/time.h>
#include <bsd/sys/types.h>
void
loc_Nap( secs )
double	secs;
	{	static struct timeval	timeout = { 0L, 0L };
	timeout.tv_usec = (long)(secs*1.0e+06);
	(void) select( 0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &timeout );
	return;
	}
#endif
@
