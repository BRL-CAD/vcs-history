head	11.9;
access;
symbols
	ansi-20040405-merged:11.6.2.1
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.6
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.6
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.9
date	2004.05.21.17.48.17;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.24.22.55.53;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.06.03.21.40.51;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.12.16.00.25.39;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.06;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.24.13.37.56;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.18;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.13.38;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.05.12.23.27.57;	author moss;	state Exp;
branches;
next	8.3;

8.3
date	89.03.31.15.48.45;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	89.03.23.11.43.25;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.52.23;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.08.30.10.23.31;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.26.01;	author mike;	state Rel;
branches;
next	6.2;

6.2
date	87.10.15.10.44.49;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.16.29;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.48.26;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.33.26;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.29.56;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.15.08;	author moss;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.06;	author morrison;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.9
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/texture.c,v 11.8 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <fcntl.h>
#include <assert.h>
#include <math.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./mat_db.h"

#define DEBUG_TEXTURE	0

typedef unsigned short	icon_t;
#define BIT_TEST( w, b )	(b == 0 ? (int)(w)&1 : (int)(w)&(1<<(b)))
#define Fb_Lookup( fbp, u, v )	(fbp->map + (v) * fbp->wid + (u))
#define BITS_PER_BYTE	8
#define BYTES_WIDE	(wid/BITS_PER_BYTE)
#define ITEMS_WIDE	(BYTES_WIDE/sizeof(icon_t))
#define ICON_SUFFIX	"icon"
#define FB_SUFFIX	"pix"

struct icon_texture
	{
	char			*filenm;
	icon_t			*map;
	int			wid;
	int			hgt;
	struct icon_texture	*next;
	}
*icons = NULL;

struct fb_texture
	{
	char			*filenm;
	RGBpixel		*map;
	int			wid;
	int			hgt;
	struct fb_texture	*next;
	}
*fbs = NULL;

STATIC char	*
suffix(register char *str)
{	register char	*p = str + strlen( str ) - 1;
	while( *p != '.' && p != str )
		p--;
	if( *p == '.' )
		return	p+1;
	else
		return	p;
	}

STATIC RGBpixel	*
icon_Lookup( iconp, u, v )
struct icon_texture	*iconp;
int	u, v;
	{	static int	word_sz = sizeof(icon_t) * BITS_PER_BYTE;
		static RGBpixel	black_pixel = { 0, 0, 0 };
		static RGBpixel	white_pixel = { 255, 255, 255 };
		int	offset = (iconp->hgt-1-v)*iconp->wid/word_sz + u/word_sz;
		int	bit = (word_sz-1) - (u % word_sz);	
		icon_t	word = iconp->map[offset];
	if( BIT_TEST( word, bit ) )
		return	(RGBpixel *) black_pixel;
	else
		return	(RGBpixel *) white_pixel;
	}

STATIC struct icon_texture	*
init_Icon_Texture(char *file, Mat_Db_Entry *entry)
{	FILE	*iconfp;
		register struct icon_texture	*iconp;
		icon_t	*iconmap;
		int	wid = entry->df_rgb[0] << 3;
		int	hgt = entry->df_rgb[1] << 3;
	if( (iconfp = fopen( file, "r" )) == NULL )
		{
		bu_log( "Can't open icon texture \"%s\" for reading.\n",
			file );
		return	NULL;
		}
	if(	(iconmap =
		(icon_t *) malloc( BYTES_WIDE*hgt ))
		== (icon_t *) 0
		)
		{
		bu_log( "No space for icon texture map.\n" );
		return	NULL;
		}
#if DEBUG_TEXTURE
	bu_log( "init_Icon_Texture(%s) wid=%d hgt=%d\n", file, wid, hgt );
	bu_log( "%d bytes allocated for texture map.\n",
		BYTES_WIDE*hgt );
#endif
	if( fread( iconmap, sizeof(icon_t), ITEMS_WIDE*hgt, iconfp )
		== -1 )
		{
		bu_log( "Read of icon texture map failed.\n" );
		return	NULL;
		}
	if(	(iconp =
		(struct icon_texture *) malloc( sizeof( struct icon_texture ) ))
	    ==	(struct icon_texture *) 0
		)
		{
		bu_log( "No space for icon texture.\n" );
		return	NULL;
		}
	if( (iconp->filenm = malloc( strlen(file)+1 )) == NULL )
		{
		bu_log( "init_Icon_Texture: no space for file name.\n" );
		return	NULL;
		}
	(void) strcpy( iconp->filenm, file );
	iconp->map = iconmap;
	iconp->wid = wid;
	iconp->hgt = hgt;
	iconp->next = icons;
	icons = iconp;
#if DEBUG_TEXTURE
	{ register int	u, v;
	for( v = 0; v < hgt; v++ )
		for( u = 0; u < wid; u++ )
			{	RGBpixel	*pixel;
			pixel = icon_Lookup( iconp, u, v );
			prnt_Pixel( *pixel, u, v );
			}
	}
#endif
	(void) fclose( iconfp );
	return	iconp;
	}

STATIC struct fb_texture	*
init_Fb_Texture(char *file, Mat_Db_Entry *entry)
{	FBIO		*txfbiop;
		register struct fb_texture	*fbp;
		RGBpixel	*fbmap;
		int		wid = entry->df_rgb[0] << 3;
		int		hgt = entry->df_rgb[1] << 3;
	if( (txfbiop = fb_open( file, wid, hgt )) == FBIO_NULL )
		return	NULL;
	if(	(fbmap =
		(RGBpixel *) malloc( wid*hgt*sizeof(RGBpixel) ))
		== (RGBpixel *) 0
		)
		{
		bu_log( "No space for frame buffer texture map.\n" );
		return	NULL;
		}
#if DEBUG_TEXTURE
	bu_log( "init_Fb_Texture(%s) wid=%d hgt=%d\n", file, wid, hgt );
	bu_log( "%d bytes allocated for texture map.\n",
		wid*hgt*sizeof(RGBpixel) );
#endif
	if( fb_read( txfbiop, 0, 0, (unsigned char *)fbmap, wid*hgt ) == -1 )
		{
		bu_log( "Read of frame buffer texture failed.\n" );
		return	NULL;
		}
	if(	(fbp =
		(struct fb_texture *) malloc( sizeof( struct fb_texture ) ))
	    ==	(struct fb_texture *) 0
		)
		{
		bu_log( "No space for fb texture.\n" );
		return	NULL;
		}
	if( (fbp->filenm = malloc( strlen(file)+1 )) == NULL )
		{
		bu_log( "init_Fb_Texture: no space for file name.\n" );
		return	NULL;
		}
	(void) strcpy( fbp->filenm, file );
	fbp->map = fbmap;
	fbp->wid = wid;
	fbp->hgt = hgt;
	fbp->next = fbs;
	fbs = fbp;
#if DEBUG_TEXTURE
	{ register int	u, v;
	for( v = 0; v < hgt; v++ )
		for( u = 0; u < wid; u++ )
			{	RGBpixel	*pixel;
			pixel = Fb_Lookup( fbp, u, v );
			prnt_Pixel( pixel, u, v );
			}
	}
#endif
	(void) fb_close( txfbiop );
	return	fbp;
	}

int
tex_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{
	if( strcmp( ICON_SUFFIX, suffix( entry->name ) ) == 0 )
		return	icon_Entry( uvp, entry );
	else
	if( strcmp( FB_SUFFIX, suffix( entry->name ) ) == 0 )
		return	fb_Entry( uvp, entry );
	else
		return	0;
	}

int
icon_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{	int	ui;
		int	vi;
		register RGBpixel		*pixel;
		register struct icon_texture	*iconp;
		char				*file = entry->name + TEX_KEYLEN;
	bu_semaphore_acquire( RT_SEM_RESULTS );
	for(	iconp = icons;
		iconp != NULL && strcmp( iconp->filenm, file ) != 0;
		iconp = iconp->next )
		;
	if( iconp == NULL )
		iconp = init_Icon_Texture( file, entry );
	bu_semaphore_release( RT_SEM_RESULTS );
	if( iconp == NULL )
		return	0;
	if(	uvp->uv_u > 1.0 || uvp->uv_u < 0.0
	     ||	uvp->uv_v > 1.0 || uvp->uv_v < 0.0
		)
		{
		bu_log( "uv coordinates out of range: u=%g v=%g\n",
			uvp->uv_u, uvp->uv_v );
		return	0;
		}
	ui = uvp->uv_u * iconp->wid;
	vi = uvp->uv_v * iconp->hgt;
#if DEBUG_TEXTURE
	bu_log( "uvp->uv_u=%g ui=%d uvp->uv_v=%g vi=%d\n",
		uvp->uv_u, ui, uvp->uv_v, vi );
#endif
	pixel = icon_Lookup( iconp, ui, vi );
	COPYRGB( entry->df_rgb, *pixel );
	return	1;
	}

int
fb_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{	int				ui;
		int				vi;
		register RGBpixel		*pixel;
		register struct fb_texture	*fbp;
		char				*file = entry->name + TEX_KEYLEN;
	bu_semaphore_acquire( RT_SEM_RESULTS );
	for(	fbp = fbs;
		fbp != NULL && strcmp( fbp->filenm, file ) != 0 ;
		fbp = fbp->next )
		;
	if( fbp == NULL )
		fbp = init_Fb_Texture( file, entry );
	bu_semaphore_release( RT_SEM_RESULTS );
	if( fbp == NULL )
		return	0;
	if(	uvp->uv_u > 1.0 || uvp->uv_u < 0.0
	     ||	uvp->uv_v > 1.0 || uvp->uv_v < 0.0
		)
		{
		bu_log( "uv coordinates out of range: u=%g v=%g\n",
			uvp->uv_u, uvp->uv_v );
		return	0;
		}
	ui = uvp->uv_u * fbp->wid;
	vi = uvp->uv_v * fbp->hgt;
	pixel = Fb_Lookup( fbp, ui, vi );
	COPYRGB( entry->df_rgb, *pixel );
#if DEBUG_TEXTURE
	bu_log( "uvp->uv_u=%g uvp->uv_v=%g\n",
		uvp->uv_u, uvp->uv_v );
	bu_log( "fbp->map[%d]=<%d,%d,%d>\n",
		vi*fbp->wid + ui,
		(*(fbp->map+vi*fbp->wid+ui))[0],	
		(*(fbp->map+vi*fbp->wid+ui))[1],	
		(*(fbp->map+vi*fbp->wid+ui))[2] );	
	prnt_Pixel( pixel, ui, vi );
#endif
	return	1;
	}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/texture.c,v 11.7 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d11 5
a15 1
#include "conf.h"
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/texture.c,v 11.4 2000/08/24 22:55:53 mike Exp $ (BRL)";
d60 2
a61 3
suffix( str )
register char	*str;
	{	register char	*p = str + strlen( str ) - 1;
d87 2
a88 4
init_Icon_Texture( file, entry )
char		*file;
Mat_Db_Entry	*entry;
	{	FILE	*iconfp;
d152 2
a153 4
init_Fb_Texture( file, entry )
char	*file;
Mat_Db_Entry	*entry;
	{	FBIO		*txfbiop;
d212 2
a213 4
tex_Entry( uvp, entry )
struct uvcoord	*uvp;
Mat_Db_Entry	*entry;
	{
d224 2
a225 4
icon_Entry( uvp, entry )
struct uvcoord	*uvp;
Mat_Db_Entry	*entry;
	{	int	ui;
d260 2
a261 4
fb_Entry( uvp, entry )
struct uvcoord	*uvp;
Mat_Db_Entry	*entry;
	{	int				ui;
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/texture.c,v 11.6 2002/08/20 17:07:34 jra Exp $ (BRL)";
d60 3
a62 2
suffix(register char *str)
{	register char	*p = str + strlen( str ) - 1;
d88 4
a91 2
init_Icon_Texture(char *file, Mat_Db_Entry *entry)
{	FILE	*iconfp;
d155 4
a158 2
init_Fb_Texture(char *file, Mat_Db_Entry *entry)
{	FBIO		*txfbiop;
d217 4
a220 2
tex_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{
d231 4
a234 2
icon_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{	int	ui;
d269 4
a272 2
fb_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{	int				ui;
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d60 3
a62 2
suffix(register char *str)
{	register char	*p = str + strlen( str ) - 1;
d88 4
a91 2
init_Icon_Texture(char *file, Mat_Db_Entry *entry)
{	FILE	*iconfp;
d155 4
a158 2
init_Fb_Texture(char *file, Mat_Db_Entry *entry)
{	FBIO		*txfbiop;
d217 4
a220 2
tex_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{
d231 4
a234 2
icon_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{	int	ui;
d269 4
a272 2
fb_Entry(struct uvcoord *uvp, Mat_Db_Entry *entry)
{	int				ui;
@


11.4
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/texture.c,v 11.3 1999/06/03 21:40:51 mike Exp $ (BRL)";
d60 2
a61 3
suffix( str )
register char	*str;
	{	register char	*p = str + strlen( str ) - 1;
d87 2
a88 4
init_Icon_Texture( file, entry )
char		*file;
Mat_Db_Entry	*entry;
	{	FILE	*iconfp;
d152 2
a153 4
init_Fb_Texture( file, entry )
char	*file;
Mat_Db_Entry	*entry;
	{	FBIO		*txfbiop;
d212 2
a213 4
tex_Entry( uvp, entry )
struct uvcoord	*uvp;
Mat_Db_Entry	*entry;
	{
d224 2
a225 4
icon_Entry( uvp, entry )
struct uvcoord	*uvp;
Mat_Db_Entry	*entry;
	{	int	ui;
d260 2
a261 4
fb_Entry( uvp, entry )
struct uvcoord	*uvp;
Mat_Db_Entry	*entry;
	{	int				ui;
@


11.3
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/texture.c,v 11.2 1997/12/16 00:25:39 mike Exp $ (BRL)";
@


11.2
log
@Converted to bu_semaphore_acquire()
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/texture.c,v 11.1 1995/01/04 10:18:06 mike Rel4_4 mike $ (BRL)";
d98 1
a98 1
		rt_log( "Can't open icon texture \"%s\" for reading.\n",
d107 1
a107 1
		rt_log( "No space for icon texture map.\n" );
d111 2
a112 2
	rt_log( "init_Icon_Texture(%s) wid=%d hgt=%d\n", file, wid, hgt );
	rt_log( "%d bytes allocated for texture map.\n",
d118 1
a118 1
		rt_log( "Read of icon texture map failed.\n" );
d126 1
a126 1
		rt_log( "No space for icon texture.\n" );
d131 1
a131 1
		rt_log( "init_Icon_Texture: no space for file name.\n" );
d170 1
a170 1
		rt_log( "No space for frame buffer texture map.\n" );
d174 2
a175 2
	rt_log( "init_Fb_Texture(%s) wid=%d hgt=%d\n", file, wid, hgt );
	rt_log( "%d bytes allocated for texture map.\n",
d180 1
a180 1
		rt_log( "Read of frame buffer texture failed.\n" );
d188 1
a188 1
		rt_log( "No space for fb texture.\n" );
d193 1
a193 1
		rt_log( "init_Fb_Texture: no space for file name.\n" );
d253 1
a253 1
		rt_log( "uv coordinates out of range: u=%g v=%g\n",
d260 1
a260 1
	rt_log( "uvp->uv_u=%g ui=%d uvp->uv_v=%g vi=%d\n",
d291 1
a291 1
		rt_log( "uv coordinates out of range: u=%g v=%g\n",
d300 1
a300 1
	rt_log( "uvp->uv_u=%g uvp->uv_v=%g\n",
d302 1
a302 1
	rt_log( "fbp->map[%d]=<%d,%d,%d>\n",
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/texture.c,v 10.2 94/08/24 13:37:56 gdurf Exp $ (BRL)";
d239 1
a239 1
	RES_ACQUIRE( &rt_g.res_results );
d246 1
a246 1
	RES_RELEASE( &rt_g.res_results );
d277 1
a277 1
	RES_ACQUIRE( &rt_g.res_results );
d284 1
a284 1
	RES_RELEASE( &rt_g.res_results );
@


10.2
log
@Made includes explicit
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/texture.c,v 10.1 1991/10/12 06:50:18 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/texture.c,v 9.1 89/05/19 06:13:38 mike Rel3_5 $ (BRL)";
d11 2
d15 10
d178 1
a178 1
	if( fb_read( txfbiop, 0, 0, fbmap, wid*hgt ) == -1 )
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 8.4 89/05/12 23:27:57 moss Exp $ (BRL)";
@


8.4
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 8.2 89/03/23 11:43:25 moss Locked $ (BRL)";
@


8.3
log
@Changed texture width and height to be shifted by 3 bits rather than 2
when stuffing into df_rfb[0] and [1] so that 1024 images would fit.
@
text
@d13 1
a13 4
#include "machine.h"
#include "fb.h"
#include "vmath.h"
#include "raytrace.h"
a14 1
#include "./extern.h"
d47 1
a47 1
_LOCAL_ char	*
d59 1
a59 1
_LOCAL_ RGBpixel	*
d75 1
a75 1
_LOCAL_ struct icon_texture	*
d142 1
a142 1
_LOCAL_ struct fb_texture	*
@


8.2
log
@Fixed assignment of pix file height in init_Fb_Texture to use df_rgb[1]
rather than df_rgb[0] which is the width parameter.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 8.1 88/10/05 00:52:23 moss Locked $ (BRL)";
d86 2
a87 2
		int	wid = entry->df_rgb[0] << 2;
		int	hgt = entry->df_rgb[1] << 2;
d153 2
a154 2
		int		wid = entry->df_rgb[0] << 2;
		int		hgt = entry->df_rgb[1] << 2;
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 7.2 88/08/30 10:23:31 moss Locked $ (BRL)";
d154 1
a154 1
		int		hgt = entry->df_rgb[0] << 2;
@


7.2
log
@Did away with texture file commands, and added textures to material
properties data base.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 7.1 87/11/03 00:26:01 mike Rel $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 6.2 87/10/15 10:44:49 moss Exp $ (BRL)";
a10 8
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) texture.c	2.1
		Modified: 	12/10/86 at 16:03:53	G S M
		Retrieved: 	2/4/87 at 08:53:42
		SCCS archive:	/vld/moss/src/lgt/s.texture.c
*/

d19 6
d26 4
a29 4
#define BITS_WIDE	48
#define FB_MAP		"map.fb"
	
FBIO	*txtr_ifp = FBIO_NULL;
d31 58
a88 2
#if ! defined( cray )
short	texture[BITS_WIDE][BITS_WIDE/(sizeof(short)*BITS_PER_BYTE)] =
d90 16
a105 2
#include "./texture.h"
		};
d107 38
d146 56
a201 12
#if ! defined( cray )
txtr_Val( uvp )
register struct uvcoord	*uvp;
	{	register int	ui = uvp->uv_u * BITS_WIDE;
		register int	vi = uvp->uv_v * BITS_WIDE;
		static int	word_sz = sizeof(short) * BITS_PER_BYTE;
		short		word;
	word = texture[vi-1][ui/word_sz];
	ui = ui % word_sz;
/*	rt_log( "word=0x%x ui=%d\n", word, ui );
	rt_log( "word >> ui = 0x%x\n", (int) word >> ui );*/
	return	(int) word & (1 << ui) ? 1 : 0;
d204 3
d208 4
a211 2
init_Fb_Val( fbfile )
char	*fbfile;
d213 6
a218 7
	if( fbfile == NULL )
		fbfile = FB_MAP;
	if( txtr_ifp != FBIO_NULL )
		(void) fb_close( txtr_ifp );
	if( (txtr_ifp = fb_open( fbfile, fb_width, fb_width ))
		== FBIO_NULL
		) 
d220 37
a256 1
	(void) fb_ioinit( txtr_ifp );
d260 21
a280 21
Mat_Db_Entry *
fb_Entry( uvp )
register struct uvcoord	*uvp;
	{	register int	ui = uvp->uv_u * fb_ulen;
		register int	vi = uvp->uv_v * fb_vlen;
		RGBpixel	pixel;
		static Mat_Db_Entry entry =
				{
				0,		/* Material id.		*/
				1,		/* Shininess.		*/
				0.1,		/* Specular weight.	*/
				0.9,		/* Diffuse weight.	*/
				0.0,		/* Transparency.	*/
				0.0,		/* Reflectivity.	*/
				1.0,		/* Refractive index.	*/
				0, 0, 0,	/* Diffuse RGB values.	*/
				MF_USED,	/* Mode flag.		*/
				"fb mapping"	/* Material name.	*/
				};
	if(	fb_seek( txtr_ifp, ui, (fb_vlen-1)-vi ) == -1
	    ||	fb_rpixel( txtr_ifp, pixel ) == -1
d282 20
a301 5
		return	MAT_DB_NULL;
	/*rt_log( "uv_u=%g uv_v=%g ui=%d vi=%d\n", uvp->uv_u, uvp->uv_v, ui, vi );
	rt_log( "pixel=(%u,%u,%u)\n", pixel[RED], pixel[GRN], pixel[BLU] );*/
	COPYRGB( entry.df_rgb, pixel );
	return	&entry;
@


6.2
log
@Slight porting changes for Cray-2.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 5.1 87/06/24 22:48:26 mike Rel $ (BRL)";
@


6.1
log
@Release 2.0
@
text
@d33 1
a33 1
#ifndef cray
d40 1
a40 1
#ifndef cray
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 1.3 87/06/23 12:33:26 moss Exp $ (BRL)";
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 1.2 87/02/06 12:29:56 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: texture.c,v 1.1 87/02/04 15:15:08 moss Locked $ (BRL)";
d31 3
a33 1
FBIO	*texture_ifp = FBIO_NULL;
d38 1
d40 2
a41 1
texture_Val( uvp )
d53 1
d57 1
a57 1
	{	register int	x, y;
d60 3
a62 3
	if( texture_ifp != FBIO_NULL )
		(void) fb_close( texture_ifp );
	if( (texture_ifp = fb_open( fbfile, fb_width, fb_width ))
d66 1
a66 1
	(void) fb_ioinit( texture_ifp );
d89 2
a90 2
	if(	fb_seek( texture_ifp, ui, (fb_vlen-1)-vi ) == -1
	    ||	fb_rpixel( texture_ifp, pixel ) == -1
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d21 5
a25 5
#include <machine.h>
#include <fb.h>
#include <vmath.h>
#include <raytrace.h>
#include <mat_db.h>
@
