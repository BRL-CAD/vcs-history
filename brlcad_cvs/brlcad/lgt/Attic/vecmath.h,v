head	11.2;
access;
symbols
	ansi-20040405-merged:11.1
	postmerge-20040405-ansi:11.1
	premerge-20040404-ansi:11.1
	postmerge-autoconf:11.1
	autoconf-freeze:11.1
	premerge-autoconf:11.1
	ansi-20040316-freeze:11.1
	postmerge-20040315-windows:11.1
	premerge-20040315-windows:11.1
	windows-20040315-freeze:11.1
	autoconf-20031203:11.1
	autoconf-20031202:11.1
	autoconf-branch:11.1.0.14
	phong-branch:11.1.0.12
	photonmap-branch:11.1.0.10
	rel-6-1-DP:11.1
	windows-branch:11.1.0.8
	rel-6-0-2:11.1
	ansi-branch:11.1.0.6
	rel-6-0-1-branch:11.1.0.4
	hartley-6-0-post:11.1
	hartley-6-0-pre:11.1
	rel-6-0-1:11.1
	rel-6-0:11.1
	rel-5-4:11.1
	offsite-5-3-pre:11.1
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:1.2
	rel-1-24:1.2
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.2
date	2004.05.21.17.48.17;	author morrison;	state dead;
branches;
next	11.1;

11.1
date	95.01.04.10.18.08;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.12.12.22.01.13;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.24.13.38.19;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.20;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.13.43;	author mike;	state Rel3_5;
branches;
next	8.1;

8.1
date	88.10.05.00.52.31;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.09.22.11.24.50;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.23.59;	author mike;	state Rel;
branches;
next	1.2;

1.2
date	87.02.06.12.30.15;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.15.13;	author moss;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.2
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef Abs
#define Abs( a )		((a) > 0 ? (a) : -(a))
#endif
#define AbsDotProd( A, B )	(Abs( Dot( A, B ) ))
#define AddVec( A, B )        { (A)[X] += (B)[X]; \
				(A)[Y] += (B)[Y]; \
				(A)[Z] += (B)[Z]; }
#define Add2Vec( A, B, C )    { (C)[X] = (A)[X]+(B)[X]; \
				(C)[Y] = (A)[Y]+(B)[Y]; \
				(C)[Z] = (A)[Z]+(B)[Z]; }
#define AproxEq( a, b, e )	(Abs( (a)-(b) ) < (e))
#define AproxEqVec( A, B, e ) ( AproxEq((A)[X],(B)[X],(e)) && \
				AproxEq((A)[Y],(B)[Y],(e)) && \
				AproxEq((A)[Z],(B)[Z],(e)) )
#define CopyVec( A, B )	      { (A)[X] = (B)[X]; \
				(A)[Y] = (B)[Y]; \
				(A)[Z] = (B)[Z]; }
#define CrossProd( A, B, C )  {	(C)[X] = (A)[Y]*(B)[Z]-(A)[Z]*(B)[Y]; \
				(C)[Y] = (A)[Z]*(B)[X]-(A)[X]*(B)[Z]; \
				(C)[Z] = (A)[X]*(B)[Y]-(A)[Y]*(B)[X]; }
#define DEGRAD	57.2957795130823208767981548141051703324054724665642
					/* degrees per radian */
#define DiffVec( A, B )       { (A)[X] -= (B)[X]; \
				(A)[Y] -= (B)[Y]; \
				(A)[Z] -= (B)[Z]; }
#define Diff2Vec( A, B, C )   { (C)[X] = (A)[X]-(B)[X]; \
				(C)[Y] = (A)[Y]-(B)[Y]; \
				(C)[Z] = (A)[Z]-(B)[Z]; }
#define Dist3d( A, B )		(sqrt(	Sqr((A)[X]-(B)[X])+\
					Sqr((A)[Y]-(B)[Y])+\
					Sqr((A)[Z]-(B)[Z]))\
				)
#define DivideVec( A, S )     { (A)[X] /= (S); \
				(A)[Y] /= (S); \
				(A)[Z] /= (S); }
#define Dot( A, B )		((A)[X]*(B)[X]+(A)[Y]*(B)[Y]+(A)[Z]*(B)[Z])
#ifndef	EPSILON
#define EPSILON	0.000001
#endif
#define Expand_Vec_Int( V )	(int)(V)[X], (int)(V)[Y], (int)(V)[Z]
#define LOG10E	0.43429448190325182765112891891660508229439700580367
					/* log of e to the base 10 */
#define Mag( A )	      	sqrt( AbsDotProd(A,A) )
#define Mag3(a1,a2,a3)		(sqrt(Sqr(a1)+Sqr(a2)+Sqr(a3)))
#ifndef Min
#define Min( a, b )		((a) < (b) ? (a) : (b))
#define Max( a, b )		((a) > (b) ? (a) : (b))
#endif
#define MinMax( m, M, a )    { m = Min( m, a ); M = Max( M, a ); }
#define MinMaxVec( A, B, C ) { (A)[X] = Min( (A)[X], (C)[X] ); \
			       (A)[Y] = Min( (A)[Y], (C)[Y] ); \
			       (A)[Z] = Min( (A)[Z], (C)[Z] ); \
			       (B)[X] = Max( (B)[X], (C)[X] ); \
			       (B)[Y] = Max( (B)[Y], (C)[Y] ); \
			       (B)[Z] = Max( (B)[Z], (C)[Z] ); }
#define NearZero( a )		((a) < EPSILON && (a) > -EPSILON)
#define NonZeroVec( V )	(!NearZero((V)[X]) || !NearZero((V)[Y])|| !NearZero((V)[Z]))
#if !defined(PI)
#define PI	3.14159265358979323846264338327950288419716939937511
					/* ratio of circumf. to diam. */
#endif
#define RelDist3d( A, B )	(Sqr((A)[X]-(B)[X])+\
				 Sqr((A)[Y]-(B)[Y])+\
				 Sqr((A)[Z]-(B)[Z]))
#define ScaleVec( A, s )      { (A)[X] *= (s); \
				(A)[Y] *= (s); \
				(A)[Z] *= (s); }
#define Scale2Vec( A, s, B )   { (B)[X] = (A)[X] * (s); \
				(B)[Y] = (A)[Y] * (s); \
				(B)[Z] = (A)[Z] * (s); }
#define Sqr(a)			((a)*(a))
#define TWO_PI		6.28318530717958647692528676655900576839433879875022
/* Scale vector 'a' to have magnitude 'l'.				*/
#define V_Length( a, l ) \
		{	double f, m; \
		if( (m=Mag(a)) == 0.0 ) \
			(void) fprintf( stderr, "Magnitude is zero!\n" ); \
		else \
			{ \
			f = (l)/m; \
			(a)[X] *= f; (a)[Y] *= f; (a)[Z] *= f; \
			} \
		}

#define V_Print(a,b,func) \
		func( "%s\t<%12.6f,%12.6f,%12.6f>\n", a, (b)[0], (b)[1], (b)[2] )
#ifndef X
#define X		0
#define Y		1
#define Z		2
#endif
@


11.1
log
@Release_4.4
@
text
@@


10.3
log
@Linux defines PI
@
text
@@


10.2
log
@Made includes explicit
@
text
@d65 1
d68 1
@


10.1
log
@Release_4.0
@
text
@a7 3
#ifndef _POLY9
#include <math.h>
#endif
@


9.1
log
@Release_3.5
@
text
@@


8.1
log
@Release_3.0
@
text
@@


7.2
log
@Removed external declaration of sqrt().
@
text
@@


7.1
log
@Release
@
text
@a7 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) vecmath.h	1.14
		Last edit: 	9/4/86 at 12:19:40	G S M
		Retrieved: 	9/4/86 at 12:19:46
		SCCS archive:	/vld/moss/src/vecmath/s.vecmath.h
*/
a10 1
extern double	sqrt();
@


1.2
log
@Reorganized includes.
@
text
@@


1.1
log
@Initial revision
@
text
@d39 2
d59 2
d76 2
a107 1
typedef double	Matrix[3][3];
@
