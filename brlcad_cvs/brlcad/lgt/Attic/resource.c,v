head	11.4;
access;
symbols
	ansi-20040405-merged:11.3
	postmerge-20040405-ansi:11.3
	premerge-20040404-ansi:11.3
	postmerge-autoconf:11.3
	autoconf-freeze:11.3
	premerge-autoconf:11.3
	ansi-20040316-freeze:11.3
	postmerge-20040315-windows:11.3
	premerge-20040315-windows:11.3
	windows-20040315-freeze:11.3
	autoconf-20031203:11.3
	autoconf-20031202:11.3
	autoconf-branch:11.3.0.12
	phong-branch:11.3.0.10
	photonmap-branch:11.3.0.8
	rel-6-1-DP:11.3
	windows-branch:11.3.0.6
	rel-6-0-2:11.3
	ansi-branch:11.3.0.4
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.3
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:8.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.1;
locks; strict;
comment	@ * @;


11.4
date	2004.05.21.17.48.16;	author morrison;	state dead;
branches;
next	11.3;

11.3
date	2000.08.24.22.55.53;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.12.16.00.24.11;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.18.02;	author mike;	state Rel4_4;
branches;
next	10.1;

10.1
date	91.10.12.06.50.15;	author mike;	state Rel4_0;
branches;
next	8.1;

8.1
date	88.10.05.00.52.14;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.06.23.09.30.17;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.51;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.16.21;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.48.15;	author mike;	state Rel;
branches;
next	1.2;

1.2
date	87.06.23.12.33.07;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.15.05;	author moss;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.4
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/resource.c,v 11.3 2000/08/24 22:55:53 mike Exp $ (BRL)";
#endif
#include <stdio.h>
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
#include "./extern.h"
#ifdef PARALLEL
static int	lock_tab[12];		/* Lock usage counters */
static char	*all_title[12] = {
	"malloc",
	"worker",
	"stats",
	"results",
	"model refinement",
	"???"
};

/*
 *			L O C K _ P R
 */
lock_pr()
{
	register int i;
	for( i=0; i<3; i++ )  {
		if(lock_tab[i] == 0)  continue;
		(void) fprintf( stderr, "%10d %s\n", lock_tab[i], all_title[i] );
	}
}

/*
 *			R E S _ P R
 */
res_pr()
{
	register struct resource *res;
	register int i;

	res = &resource[0];
	for( i=0; i<npsw; i++, res++ )  {
		(void) fprintf( stderr, "cpu%d seg  len=%10d get=%10d free=%10d\n",
			i,
			res->re_seglen, res->re_segget, res->re_segfree );
		(void) fprintf( stderr, "cpu%d part len=%10d get=%10d free=%10d\n",
			i,
			res->re_partlen, res->re_partget, res->re_partfree );
		(void) fprintf( stderr, "cpu%d bitv len=%10d get=%10d free=%10d\n",
			i,
			res->re_bitvlen, res->re_bitvget, res->re_bitvfree );
	}
}
#endif PARALLEL
@


11.3
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/resource.c,v 11.2 1997/12/16 00:24:11 mike Exp $ (BRL)";
@


11.2
log
@All the parallel support is in the library
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/resource.c,v 11.1 1995/01/04 10:18:02 mike Rel4_4 mike $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/resource.c,v 10.1 91/10/12 06:50:15 mike Rel4_0 $ (BRL)";
a60 157

#ifdef cray
#ifdef PARALLEL
RES_INIT(p)
register int *p;
{
	if( !rt_g.rtg_parallel )  return;
	LOCKASGN(p);
}

RES_ACQUIRE(p)
register int *p;
{
	register int i = p - (&rt_g.res_syscall);
	if( !rt_g.rtg_parallel )  return;
	if( i < 0 || i > 12 )  {
		(void) fprintf( stderr, "RES_ACQUIRE(0%o)? p-0%o=%d?\n",
				p, &rt_g.res_syscall, i);
		abort();
	}
	lock_tab[i]++;		/* Not interlocked */
	LOCKON(p);
}

RES_RELEASE(p)
register int *p;
{
	if( !rt_g.rtg_parallel )  return;
	LOCKOFF(p);
}
#else
RES_INIT() {}
RES_ACQUIRE() {}
RES_RELEASE() {}
#endif PARALLEL
#endif cray

#ifdef sgi
/* Horrible bug in 3.3.1 and 3.4 and 3.5 -- hypot ruins stack! */
long float
hypot(a,b)
double a,b;
{
	return(sqrt(a*a+b*b));
}
#endif

#ifdef alliant
RES_ACQUIRE(p)
register int *p;		/* known to be a5 */
{
	register int i;
	i = p - (&rt_g.res_syscall);

	asm("loop:");
	do  {
		/* Just wasting time anyways, so log it */
		lock_tab[i]++;	/* non-interlocked */
	} while( *p );
	asm("	tas	a5@@");
	asm("	bne	loop");
}

#ifdef never
MAT4X3PNT( o, m, i )
register fastf_t *o;	/* a5 */
register fastf_t *m;	/* a4 */
register fastf_t *i;	/* a3 */
{
#ifdef NON_VECTOR
	FAST fastf_t f;
	f = 1.0/((m)[12]*(i)[X] + (m)[13]*(i)[Y] + (m)[14]*(i)[Z] + (m)[15]);
	(o)[X]=((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z] + (m)[3]) * f;
	(o)[Y]=((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z] + (m)[7]) * f;
	(o)[Z]=((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z] + (m)[11])* f;
#else
	register int i;		/* d7 */
	register int vm;	/* d6, vector mask */
	register int vi;	/* d5, vector increment */
	register int vl;	/* d4, vector length */

	vm = -1;
	vi = 4;
	vl = 4;

	asm("fmoved	a3@@, fp0");
	asm("vmuld	a4@@, fp0, v7");

	asm("fmoved	a3@@(8), fp0");
	asm("vmuadd	fp0, a4@@(8), v7, v7");

	asm("fmoved	a3@@(16), fp0");
	asm("vmuadd	fp0, a4@@(16), v7, v7");

	asm("vaddd	a4@@(24), v7, v7");

#ifdef RECIPROCAL
	asm("moveq	#1, d0");
	asm("fmoveld	d0, fp0");
	asm("fdivd	a4@@(120), fp0, fp0");
	asm("vmuld	v7, fp0, v7");
#else
	asm("fmovedd	a4@@(120), fp7");
	asm("vrdivd	v7, fp7, v7");
#endif

	vi = 1;
	asm("vmoved	v7, a5@@");
#endif
}
/* Apply a 4x4 matrix to a 3-tuple which is a relative Vector in space */
MAT4X3VEC( o, m, i )
register fastf_t *o;
register fastf_t *m;
register fastf_t *i;
{
#ifdef NON_VECTOR
	FAST fastf_t f;
	f = 1.0/((m)[15]);
	(o)[X] = ((m)[0]*(i)[X] + (m)[1]*(i)[Y] + (m)[ 2]*(i)[Z]) * f;
	(o)[Y] = ((m)[4]*(i)[X] + (m)[5]*(i)[Y] + (m)[ 6]*(i)[Z]) * f;
	(o)[Z] = ((m)[8]*(i)[X] + (m)[9]*(i)[Y] + (m)[10]*(i)[Z]) * f;
#else
	register int i;		/* d7 */
	register int vm;	/* d6, vector mask */
	register int vi;	/* d5, vector increment */
	register int vl;	/* d4, vector length */

	vm = -1;
	vi = 4;
	vl = 3;

	asm("fmoved	a3@@, fp0");
	asm("vmuld	a4@@, fp0, v7");

	asm("fmoved	a3@@(8), fp0");
	asm("vmuadd	fp0, a4@@(8), v7, v7");

	asm("fmoved	a3@@(16), fp0");
	asm("vmuadd	fp0, a4@@(16), v7, v7");

#ifdef RECIPROCAL
	asm("moveq	#1, d0");
	asm("fmoveld	d0, fp0");
	asm("fdivd	a4@@(120), fp0, fp0");
	asm("vmuld	v7, fp0, v7");
#else
	asm("fmovedd	a4@@(120), fp7");
	asm("vrdivd	v7, fp7, v7");
#endif

	vi = 1;
	asm("vmoved	v7, a5@@");
#endif
}
#endif never
#endif
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/resource.c,v 8.1 88/10/05 00:52:14 mike Rel3_0 $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: resource.c,v 7.2 88/06/23 09:30:17 moss Locked $ (BRL)";
@


7.2
log
@Smoothing out menu and prompting interface.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: resource.c,v 7.1 87/11/03 00:25:51 moss Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: resource.c,v 6.1 87/07/11 08:16:21 mike Rel $ (BRL)";
d22 2
d67 1
a67 3
	register int i = p - (&rt_g.res_syscall);
/*	if(rdebug&RDEBUG_PARALLEL) 
		(void) fprintf( stderr, "RES_INIT 0%o, i=%d, rt_g=0%o\n", p, i, &rt_g);*/
a68 2
/*	if(rdebug&RDEBUG_PARALLEL) 
		(void) fprintf( stderr, "    start value = 0%o\n", *p );*/
d70 1
d75 1
d77 2
a78 1
		(void) fprintf( stderr, "RES_ACQUIRE(0%o)? %d?\n", p, i);
a81 1
/*	if(rdebug&RDEBUG_PARALLEL) fputc( 'A'+i, stderr );*/
a82 1
/*	if(rdebug&RDEBUG_PARALLEL) fputc( '0'+i, stderr );*/
d84 1
d88 1
a88 2
	register int i = p - (&rt_g.res_syscall);
/*	if(rdebug&RDEBUG_PARALLEL) fputc( 'a'+i, stderr );*/
a89 1
/*	if(rdebug&RDEBUG_PARALLEL) fputc( '\n', stderr);*/
d114 1
a114 1
#ifdef PARALLEL
a121 1
#endif
@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: resource.c,v 5.1 87/06/24 22:48:15 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: resource.c,v 1.2 87/06/23 12:33:07 moss Exp $ (BRL)";
@


1.2
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: resource.c,v 1.1 87/02/04 15:15:05 moss Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d15 1
a15 1

a16 2
extern int	npsw;
struct resource	resource[MAX_PSW];	/* memory resources */
d65 1
a65 1
	register int i = p - (&rt_g.res_malloc);
d75 1
a75 1
	register int i = p - (&rt_g.res_malloc);
d88 1
a88 1
	register int i = p - (&rt_g.res_malloc);
d115 1
a115 1
	i = p - (&rt_g.res_malloc);
@
