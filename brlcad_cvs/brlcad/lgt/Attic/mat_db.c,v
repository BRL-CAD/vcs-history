head	11.9;
access;
symbols
	ansi-20040405-merged:11.6.2.1
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.6
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.6
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.2
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.9
date	2004.05.21.17.48.16;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.08.09.16.42.52;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.22.55.52;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.06.03.21.40.50;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.56;	author mike;	state Rel4_4;
branches;
next	10.3;

10.3
date	94.08.24.13.36.17;	author gdurf;	state Exp;
branches;
next	10.2;

10.2
date	91.12.31.13.44.01;	author moss;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.10;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.13.22;	author mike;	state Rel3_5;
branches;
next	8.3;

8.3
date	89.05.12.23.27.39;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	89.03.31.15.49.58;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.52.01;	author mike;	state Rel3_0;
branches;
next	7.3;

7.3
date	88.08.30.10.23.11;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	88.06.23.09.29.33;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.26;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.10.29.08.51.59;	author moss;	state Exp;
branches;
next	6.2;

6.2
date	87.10.15.10.36.38;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.16.02;	author mike;	state Rel;
branches;
next	5.2;

5.2
date	87.06.26.10.16.30;	author moss;	state Exp;
branches;
next	5.1;

5.1
date	87.06.24.22.47.38;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.31.51;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.28.20;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.14.59;	author moss;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.04;	author morrison;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.9
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/mat_db.c,v 11.8 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./mat_db.h"
#include "./screen.h"

static Mat_Db_Entry	mat_db_table[MAX_MAT_DB];
static int		mat_db_size = 0;
Mat_Db_Entry		mat_dfl_entry =
				{
				0,		/* Material id.		*/
				4,		/* Shininess.		*/
				0.6,		/* Specular weight.	*/
				0.4,		/* Diffuse weight.	*/
				0.0,		/* Reflectivity.	*/
				0.0,		/* Transmission.	*/
				1.0,		/* Refractive index.	*/
				{255, 255, 255},/* Diffuse RGB values.	*/
				MF_USED,	/* Mode flag.		*/
				"(default)"	/* Material name.	*/
				};
Mat_Db_Entry		mat_nul_entry =
				{
				0,		/* Material id.		*/
				0,		/* Shininess.		*/
				0.0,		/* Specular weight.	*/
				0.0,		/* Diffuse weight.	*/
				0.0,		/* Reflectivity.	*/
				0.0,		/* Transmission.	*/
				0.0,		/* Refractive index.	*/
				{0, 0, 0},	/* Diffuse RGB values.	*/
				MF_NULL,	/* Mode flag.		*/
				"(null)"	/* Material name.	*/
				};
STATIC int	get_Mat_Entry(register Mat_Db_Entry *entry, FILE *fp), put_Mat_Entry(register Mat_Db_Entry *entry, register FILE *fp);

/*	m a t _ R d _ D b ( )
	Open material database and read entries into table,
	return number of entries successfully read.
 */
int
mat_Rd_Db(char *file)
{	register Mat_Db_Entry	*entry;
		register FILE		*fp;
	if( (fp = fopen( file, "r" )) == NULL )
		return	0;
	/* Mark all entries as NULL.					*/
	for( entry = mat_db_table; entry < &mat_db_table[MAX_MAT_DB]; entry++ )
		entry->mode_flag = MF_NULL;
	mat_db_size = 0;
	for(	entry = mat_db_table;
		entry < &mat_db_table[MAX_MAT_DB]
	     && get_Mat_Entry( entry, fp );
		++entry
		)
		mat_db_size++;
	(void) fclose( fp );
	return	mat_db_size;
	}

/*	m a t _ P r i n t _ D b ( )
	Print material database entry.
 */
int
mat_Print_Db(int material_id)
{	register Mat_Db_Entry	*entry;
		register int		stop;
		register int		success = 0;
		int			lines =	(PROMPT_LINE-TOP_SCROLL_WIN);
	if( material_id >= MAX_MAT_DB )
		{
		bu_log( "Material data base only has %d entries.\n",
			MAX_MAT_DB
			);
		bu_log( "If this is not enough, notify the support staff.\n" );
		return	success;
		}
	else
	if( material_id < 0 )
		{
		stop = MAX_MAT_DB - 1;
		material_id = 0;
		}
	else
		stop = material_id;
	for( ; material_id <= stop; material_id++, lines-- )
		{
		entry = &mat_db_table[material_id];
		if( entry->mode_flag == MF_NULL )
			continue;
		success = 1;
		if( lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "\n" );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "MATERIAL [%d] %s\n",
				material_id,
				entry->name[0] == '\0' ? "(untitled)" : entry->name
				);
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "        shininess\t\t(%d)\n", entry->shine );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "        specular weight\t\t(%g)\n", entry->wgt_specular );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "        diffuse weight\t\t(%g)\n", entry->wgt_diffuse );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "        transparency\t\t(%g)\n", entry->transparency );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "        reflectivity\t\t(%g)\n", entry->reflectivity );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "        refractive index\t(%g)\n", entry->refrac_index );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		if( strncmp( TEX_KEYWORD, entry->name, TEX_KEYLEN ) != 0 )
			prnt_Scroll( "        diffuse color\t\t(%d %d %d)\n",
					entry->df_rgb[0],
					entry->df_rgb[1],
					entry->df_rgb[2]
					);
		else
			prnt_Scroll( "        texture map : width=%d height=%d\n",
					entry->df_rgb[0] << 3,
					entry->df_rgb[1] << 3
					);
		}
	return	success;
	}

/*	m a t _ S a v e _ D b ( )
	Write ASCII material database from table.
	Return 1 for success, 0 for failure.
 */
int
mat_Save_Db(char *file)
{	register Mat_Db_Entry	*entry;
		register FILE		*fp;
	if( (fp = fopen( file, "w" )) == NULL )
		return	0;
	setbuf( fp, malloc( BUFSIZ ) );
	for(	entry = mat_db_table;
		entry < &mat_db_table[mat_db_size]
	     && put_Mat_Entry( entry, fp );
		++entry
		)
		;
	(void) fclose( fp );
	if( entry != &mat_db_table[mat_db_size] )
		return	0;
	return	1;
	}


/*	m a t _ E d i t _ D b _ E n t r y ( )
	Create or overwrite entry in material table.
 */
int
mat_Edit_Db_Entry(int id)
{	register Mat_Db_Entry	*entry;
		char			input_buf[MAX_LN];
		char			prompt[MAX_LN];
		int			red, grn, blu;
	if( id < 0 )
		return	-1;
	if( id < MAX_MAT_DB )
		{
		entry = &mat_db_table[id];
		entry->id = id;
		}
	else
		{
		bu_log( "Material table full, MAX_DB_ENTRY too small.\n" );
		return	0;
		}
	(void) sprintf( prompt, "material name ? (%s) ", entry->name );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		(void) strncpy( entry->name, input_buf, MAX_MAT_NM );
	(void) sprintf( prompt, "shine ? [1 to n](%d) ", entry->shine );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		(void) sscanf( input_buf, "%d", &entry->shine );
	(void) sprintf( prompt, "specular weighting ? [0.0 to 1.0](%g) ",
			entry->wgt_specular );
	if( get_Input( input_buf, MAX_LN, prompt  ) != NULL )
		(void) sscanf( input_buf, "%lf", &entry->wgt_specular );
	(void) sprintf( prompt, "diffuse weighting ? [0.0 to 1.0](%g) ",
			entry->wgt_diffuse );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		(void) sscanf( input_buf, "%lf", &entry->wgt_diffuse );
	(void) sprintf( prompt, "transparency ? [0.0 to 1.0](%g) ",
			entry->transparency );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		(void) sscanf( input_buf, "%lf", &entry->transparency );
	(void) sprintf( prompt, "reflectivity ? [0.0 to 1.0](%g) ",
			entry->reflectivity );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		(void) sscanf( input_buf, "%lf", &entry->reflectivity );
	(void) sprintf( prompt, "refractive index ? [0.9 to 5.0](%g) ",
			entry->refrac_index );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		(void) sscanf( input_buf, "%lf", &entry->refrac_index );

	if( strncmp( TEX_KEYWORD, entry->name, TEX_KEYLEN ) != 0 )
		{
		(void) sprintf( prompt, "diffuse RGB values ? [0 to 255](%d %d %d) ",
				entry->df_rgb[RED],
				entry->df_rgb[GRN],
				entry->df_rgb[BLU]
				);
		if(	get_Input( input_buf, MAX_LN, prompt ) != NULL
		     &&	sscanf( input_buf, "%d %d %d", &red, &grn, &blu ) == 3
			)
			{
			entry->df_rgb[0] = red;
			entry->df_rgb[1] = grn;
			entry->df_rgb[2] = blu;
			}
		}
	else
		{
		(void) sprintf( prompt, "texture : width and height? [0 to 1024](%d %d) ",
				entry->df_rgb[0]<<3,
				entry->df_rgb[1]<<3
				);
		if(	get_Input( input_buf, MAX_LN, prompt ) != NULL
	 	    &&	sscanf( input_buf, "%d %d", &red, &grn ) == 2
			)
			{
			entry->df_rgb[0] = red >> 3;
			entry->df_rgb[1] = grn >> 3;
			}
		}
	entry->mode_flag = MF_USED;
	mat_db_size = Max( mat_db_size, id+1 );
	return	1;
	}

/*	m a t _ G e t _ D b _ E n t r y ( )
	Return pointer to entry indexed by id or NULL.
 */
Mat_Db_Entry *
mat_Get_Db_Entry(int id)
{
	if( id < 0 )
		return	MAT_DB_NULL;
	if( id < mat_db_size )
		return	&mat_db_table[id];
	else
		return	MAT_DB_NULL;
	}

STATIC int
get_Mat_Entry(register Mat_Db_Entry *entry, FILE *fp)
{	register char	*ptr;
		int		items;
		int		red, grn, blu, mode;
	if( fgets( entry->name, MAX_MAT_NM, fp ) == NULL )
		return	0;
	ptr = &entry->name[strlen(entry->name) - 1];
	if( *ptr == '\n' )
		/* Read entire line.					*/
		*ptr = '\0';
	else	/* Skip rest of line.					*/
		while( getc( fp ) != '\n' )
			;
	if( (items = fscanf( fp, "%d %d", &entry->id, &entry->shine )) != 2 )
		{
		(void) fprintf( stderr, "Could not read integers (%d read)!\n", items );
		return	0;
		}
	if(	fscanf(	fp,
			"%lf %lf %lf %lf %lf",
			&entry->wgt_specular,
			&entry->wgt_diffuse,
			&entry->transparency,
			&entry->reflectivity,
			&entry->refrac_index
			) != 5
		)
		{
		(void) fprintf( stderr, "Could not read floats!\n" );
		return	0;
		}
	if( fscanf( fp, "%d %d %d", &red, &grn, &blu ) != 3 )
		{
		(void) fprintf( stderr, "Could not read chars!\n" );
		return	0;
		}
	entry->df_rgb[0] = red;
	entry->df_rgb[1] = grn;
	entry->df_rgb[2] = blu;
	if( fscanf( fp, "%d", &mode ) != 1 )
		{
		(void) fprintf( stderr,
				"get_Mat_Entry(): Could not read mode_flag!\n"
				);
		return	0;
		}
	entry->mode_flag = mode;
	while( getc( fp ) != '\n' )
		; /* Gobble rest of line.				*/
	return	1;
	}

STATIC int
put_Mat_Entry(register Mat_Db_Entry *entry, register FILE *fp)
{
	if( entry->mode_flag == MF_NULL )
		entry = &mat_nul_entry;
	(void) fprintf( fp, "%s\n", entry->name );
	(void) fprintf( fp, "%d\n%d\n", entry->id, entry->shine );
	(void) fprintf(	fp,
			"%f\n%f\n%f\n%f\n%f\n",
			entry->wgt_specular,
			entry->wgt_diffuse,
			entry->transparency,
			entry->reflectivity,
			entry->refrac_index
			);
	(void) fprintf(	fp,
			"%u %u %u\n",
			(unsigned) entry->df_rgb[0],
			(unsigned) entry->df_rgb[1],
			(unsigned) entry->df_rgb[2]
			);
	(void) fprintf( fp, "%u\n", (unsigned) entry->mode_flag );
	return	1;
	}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/mat_db.c,v 11.7 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 5
a16 1
#include "conf.h"
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/mat_db.c,v 11.4 2001/08/09 16:42:52 jra Exp $ (BRL)";
d58 1
a58 1
STATIC int	get_Mat_Entry(), put_Mat_Entry();
d65 2
a66 3
mat_Rd_Db( file )
char	*file;
	{	register Mat_Db_Entry	*entry;
d88 2
a89 3
mat_Print_Db( material_id )
int		material_id;
	{	register Mat_Db_Entry	*entry;
d164 2
a165 3
mat_Save_Db( file )
char	*file;
	{	register Mat_Db_Entry	*entry;
d187 2
a188 3
mat_Edit_Db_Entry( id )
int	id;
	{	register Mat_Db_Entry	*entry;
d270 2
a271 3
mat_Get_Db_Entry( id )
int	id;
	{
d281 2
a282 4
get_Mat_Entry( entry, fp )
register Mat_Db_Entry	*entry;
FILE	*fp;
	{	register char	*ptr;
d334 2
a335 4
put_Mat_Entry( entry, fp )
register Mat_Db_Entry	*entry;
register FILE		*fp;
	{
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/mat_db.c,v 11.6 2002/08/20 17:07:34 jra Exp $ (BRL)";
d58 1
a58 1
STATIC int	get_Mat_Entry(register Mat_Db_Entry *entry, FILE *fp), put_Mat_Entry(register Mat_Db_Entry *entry, register FILE *fp);
d65 3
a67 2
mat_Rd_Db(char *file)
{	register Mat_Db_Entry	*entry;
d89 3
a91 2
mat_Print_Db(int material_id)
{	register Mat_Db_Entry	*entry;
d166 3
a168 2
mat_Save_Db(char *file)
{	register Mat_Db_Entry	*entry;
d190 3
a192 2
mat_Edit_Db_Entry(int id)
{	register Mat_Db_Entry	*entry;
d274 3
a276 2
mat_Get_Db_Entry(int id)
{
d286 4
a289 2
get_Mat_Entry(register Mat_Db_Entry *entry, FILE *fp)
{	register char	*ptr;
d341 4
a344 2
put_Mat_Entry(register Mat_Db_Entry *entry, register FILE *fp)
{
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d58 1
a58 1
STATIC int	get_Mat_Entry(register Mat_Db_Entry *entry, FILE *fp), put_Mat_Entry(register Mat_Db_Entry *entry, register FILE *fp);
d65 3
a67 2
mat_Rd_Db(char *file)
{	register Mat_Db_Entry	*entry;
d89 3
a91 2
mat_Print_Db(int material_id)
{	register Mat_Db_Entry	*entry;
d166 3
a168 2
mat_Save_Db(char *file)
{	register Mat_Db_Entry	*entry;
d190 3
a192 2
mat_Edit_Db_Entry(int id)
{	register Mat_Db_Entry	*entry;
d274 3
a276 2
mat_Get_Db_Entry(int id)
{
d286 4
a289 2
get_Mat_Entry(register Mat_Db_Entry *entry, FILE *fp)
{	register char	*ptr;
d341 4
a344 2
put_Mat_Entry(register Mat_Db_Entry *entry, register FILE *fp)
{
@


11.4
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/mat_db.c,v 11.3 2000/08/24 22:55:52 mike Exp $ (BRL)";
d58 1
a58 1
STATIC int	get_Mat_Entry(), put_Mat_Entry();
d65 2
a66 3
mat_Rd_Db( file )
char	*file;
	{	register Mat_Db_Entry	*entry;
d88 2
a89 3
mat_Print_Db( material_id )
int		material_id;
	{	register Mat_Db_Entry	*entry;
d164 2
a165 3
mat_Save_Db( file )
char	*file;
	{	register Mat_Db_Entry	*entry;
d187 2
a188 3
mat_Edit_Db_Entry( id )
int	id;
	{	register Mat_Db_Entry	*entry;
d270 2
a271 3
mat_Get_Db_Entry( id )
int	id;
	{
d281 2
a282 4
get_Mat_Entry( entry, fp )
register Mat_Db_Entry	*entry;
FILE	*fp;
	{	register char	*ptr;
d334 2
a335 4
put_Mat_Entry( entry, fp )
register Mat_Db_Entry	*entry;
register FILE		*fp;
	{
@


11.3
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/mat_db.c,v 11.2 1999/06/03 21:40:50 mike Exp $ (BRL)";
d41 1
a41 1
				255, 255, 255,	/* Diffuse RGB values.	*/
d54 1
a54 1
				0, 0, 0,	/* Diffuse RGB values.	*/
d64 1
d88 1
d165 1
d189 1
d285 1
a285 1
STATIC
d340 1
a340 1
STATIC
@


11.2
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/mat_db.c,v 11.1 1995/01/04 10:17:56 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/mat_db.c,v 10.3 94/08/24 13:36:17 gdurf Exp $ (BRL)";
d95 1
a95 1
		rt_log( "Material data base only has %d entries.\n",
d98 1
a98 1
		rt_log( "If this is not enough, notify the support staff.\n" );
d201 1
a201 1
		rt_log( "Material table full, MAX_DB_ENTRY too small.\n" );
@


10.3
log
@Made includes explicit, factored ifdefs
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/mat_db.c,v 10.2 1991/12/31 13:44:01 moss Exp gdurf $ (BRL)";
@


10.2
log
@Changed to use TEX_KEYWORD and TEX_KEYLEN.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /n/wolf/m/cad/lgt/RCS/mat_db.c,v 10.1 91/10/12 06:50:10 mike Rel4_0 $ (BRL)";
d12 2
d15 10
d29 1
a212 3
#if defined( sgi ) && ! defined( mips )
		(void) sscanf( input_buf, "%f", &entry->wgt_specular );
#else
a213 1
#endif
a216 3
#if defined( sgi ) && ! defined( mips )
		(void) sscanf( input_buf, "%f", &entry->wgt_diffuse );
#else
a217 1
#endif
a220 3
#if defined( sgi ) && ! defined( mips )
		(void) sscanf( input_buf, "%f", &entry->transparency );
#else	
a221 1
#endif
a224 3
#if defined( sgi ) && ! defined( mips )
		(void) sscanf( input_buf, "%f", &entry->reflectivity );
#else
a225 1
#endif
a228 3
#if defined( sgi ) && ! defined( mips )
		(void) sscanf( input_buf, "%f", &entry->refrac_index );
#else
d230 1
a230 1
#endif
a302 3
#if defined( sgi ) && ! defined( mips )
			"%f %f %f %f %f",
#else
a303 1
#endif
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/mat_db.c,v 9.1 89/05/19 06:13:22 mike Rel3_5 $ (BRL)";
d131 1
a131 1
		if( strncmp( "texture ", entry->name, 8 ) != 0 )
d237 1
a237 1
	if( strncmp( "texture ", entry->name, 8 ) != 0 )
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 8.3 89/05/12 23:27:39 moss Exp $ (BRL)";
@


8.3
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 8.2 89/03/31 15:49:58 moss Exp $ (BRL)";
@


8.2
log
@Changed texture width and height to be shifted by 3 bits rather than 2
when stuffing into df_rfb[0] and [1] so that 1024 images would fit.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 8.1 88/10/05 00:52:01 moss Locked $ (BRL)";
d13 1
a16 2
#include "./extern.h"
#include "./lgt.h"
d45 1
a45 1
_LOCAL_ int	get_Mat_Entry(), put_Mat_Entry();
d287 1
a287 1
_LOCAL_
d346 1
a346 1
_LOCAL_
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 7.3 88/08/30 10:23:11 moss Locked $ (BRL)";
d46 1
a46 1
_LOCAL_ int	get_Mat_Entry(), put_Entry();
d140 2
a141 2
					entry->df_rgb[0] << 2,
					entry->df_rgb[1] << 2
d257 2
a258 2
				entry->df_rgb[0]<<2,
				entry->df_rgb[1]<<2
d264 2
a265 2
			entry->df_rgb[0] = red >> 2;
			entry->df_rgb[1] = grn >> 2;
@


7.3
log
@Did away with texture file commands, and added textures to material
properties data base.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 7.1 87/11/03 00:25:26 moss Locked $ (BRL)";
@


7.2
log
@Smoothing out menu and prompting interface.
@
text
@d132 11
a142 5
		prnt_Scroll( "        diffuse color\t\t(%d %d %d)\n",
				entry->df_rgb[0],
				entry->df_rgb[1],
				entry->df_rgb[2]
				);
d238 1
a238 8
	(void) sprintf( prompt, "diffuse RGB values ? [0 to 255](%d %d %d) ",
			entry->df_rgb[RED],
			entry->df_rgb[GRN],
			entry->df_rgb[BLU]
			);
	if(	get_Input( input_buf, MAX_LN, prompt ) != NULL
	     &&	sscanf( input_buf, "%d %d %d", &red, &grn, &blu ) == 3
		)
d240 27
a266 3
		entry->df_rgb[0] = red;
		entry->df_rgb[1] = grn;
		entry->df_rgb[2] = blu;
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 6.3 87/10/29 08:51:59 moss Exp $ (BRL)";
a10 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) mat_db.c	1.10
		Last edit: 	2/4/87 at 12:18:02
		Retrieved: 	2/4/87 at 12:18:20
		SCCS archive:	/vld/moss/src/libmatdb/s.mat_db.c
*/
d17 1
d171 2
a172 1
		static char		input_buf[BUFSIZ];
d183 1
a183 3
		(void) fprintf( stderr,
			"Material table full, MAX_DB_ENTRY too small.\n"
				);
d186 2
a187 3
	if( get_Input( input_buf, BUFSIZ, "material name : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
d189 2
a190 3
	if( get_Input( input_buf, BUFSIZ, "shine : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
d192 4
a195 4
	if( get_Input( input_buf, BUFSIZ, "specular weighting [0.0 .. 1.0] : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
#ifdef sgi
d200 4
a203 4
	if( get_Input( input_buf, BUFSIZ, "diffuse weighting [0.0 .. 1.0] : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
#ifdef sgi
d208 4
a211 4
	if( get_Input( input_buf, BUFSIZ, "transparency [0.0 .. 1.0] : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
#ifdef sgi
d216 4
a219 4
	if( get_Input( input_buf, BUFSIZ, "reflectivity [0.0 .. 1.0] : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
#ifdef sgi
d224 4
a227 4
	if( get_Input( input_buf, BUFSIZ, "refractive index [0.9 .. 5.0] : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
#ifdef sgi
d232 6
a237 3
	if( get_Input( input_buf, BUFSIZ, "diffuse RGB values [0 .. 255] : " ) == NULL )
		return	0;
	if(	input_buf[0] != '\0'
d287 1
a287 1
#ifdef sgi
@


6.3
log
@Ready for release 2.1 of BRL CAD.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 6.2 87/10/15 10:36:38 moss Locked $ (BRL)";
@


6.2
log
@Change in return code from printing routine to indicate whether or not
	anything was actually output.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 5.2 87/06/26 10:16:30 moss Exp $ (BRL)";
a23 1
static FILE		*matdb_fp;
@


6.1
log
@Release 2.0
@
text
@d86 1
d94 1
a94 1
		return	-1;
d109 1
d145 1
a145 1
	return	1;
@


5.2
log
@Modified material data base handling to allow readonly access, like the
lighting data base was being handled.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 5.1 87/06/24 22:47:38 moss Locked $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 1.3 87/06/23 12:31:51 moss Exp $ (BRL)";
d53 1
a53 2
_LOCAL_ int	get_Entry(), put_Entry();
_LOCAL_ int	mat_W_Open();
d55 3
a57 2
/*	m a t _ O p e n _ D b ( )
	Open file, return file pointer or NULL.
d59 6
a64 6
FILE *
mat_Open_Db( mat_db_file )
char	*mat_db_file;
	{	register	Mat_Db_Entry	*entry;
	if( (matdb_fp = fopen( mat_db_file, "r+" )) == (FILE *) NULL )
		return	matdb_fp; /* NULL */
d68 9
a76 1
	return	matdb_fp;
a78 8
/*	m a t _ C l o s e _ D b ( )
	Close material database input file.  Return success or failure.
 */
mat_Close_Db()
	{
	return	fclose( matdb_fp );
	}

a145 16
/*	m a t _ R d _ D b ( )
	Read ASCII material database into table, return number of entries.
 */
mat_Rd_Db()
	{	Mat_Db_Entry	*entry;
	mat_db_size = 0;
	for(	entry = mat_db_table;
		entry < &mat_db_table[MAX_MAT_DB]
	     && get_Entry( entry );
		++entry
		)
		mat_db_size++;
	return	mat_db_size;
	}


d147 2
a148 3
	Write ASCII material database from table.  If 'file' is NULL,
	overwrite input file, otherwise open or create 'file'.  Return success
	or failure.
d153 2
a154 1
	if( ! mat_W_Open( file ) )
d156 1
d159 1
a159 1
	     && put_Entry( entry );
d163 1
a165 1
	(void) fflush( matdb_fp );
d170 1
a170 1
/*	m a t _ P u t _ D b _ E n t r y ( )
d173 2
a174 2
mat_Put_Db_Entry( material_id )
int	material_id;
d178 1
a178 1
	if( material_id < 0 )
d180 1
a180 1
	if( material_id < MAX_MAT_DB )
d182 2
a183 2
		entry = &mat_db_table[material_id];
		entry->id = material_id;
d251 1
a251 1
	mat_db_size = Max( mat_db_size, material_id+1 );
d259 2
a260 2
mat_Get_Db_Entry( material_id )
int	material_id;
d262 1
a262 1
	if( material_id < 0 )
d264 2
a265 2
	if( material_id < mat_db_size )
		return	&mat_db_table[material_id];
d271 1
a271 1
get_Entry( entry )
d273 1
d277 1
a277 1
	if( fgets( entry->name, MAX_MAT_NM, matdb_fp ) == NULL )
d284 1
a284 1
		while( getc( matdb_fp ) != '\n' )
d286 1
a286 1
	if( (items = fscanf( matdb_fp, "%d %d", &entry->id, &entry->shine )) != 2 )
d291 1
a291 1
	if(	fscanf(	matdb_fp,
d308 1
a308 1
	if( fscanf( matdb_fp, "%d %d %d", &red, &grn, &blu ) != 3 )
d316 1
a316 1
	if( fscanf( matdb_fp, "%d", &mode ) != 1 )
d319 1
a319 1
				"get_Entry(): Could not read mode_flag!\n"
d324 1
a324 1
	while( getc( matdb_fp ) != '\n' )
d330 1
a330 1
put_Entry( entry )
d332 1
d336 3
a338 3
	(void) fprintf( matdb_fp, "%s\n", entry->name );
	(void) fprintf( matdb_fp, "%d\n%d\n", entry->id, entry->shine );
	(void) fprintf(	matdb_fp,
d346 1
a346 1
	(void) fprintf(	matdb_fp,
d352 1
a352 1
	(void) fprintf( matdb_fp, "%u\n", (unsigned) entry->mode_flag );
a353 20
	}

_LOCAL_
mat_W_Open( file )
char	*file;
	{
	if( file != NULL )
		{	register FILE	*fp;
		if( (fp = fopen( file, "w+" )) == NULL )
			return	0;
		else
			{
			matdb_fp = fp;
			setbuf( matdb_fp, malloc( BUFSIZ ) );
			}
		}
	/* else default to last database accessed.			*/
	if( matdb_fp == NULL )
		return	0;
	return	fseek( matdb_fp, 0L, 0 ) == 0;
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 1.2 87/02/06 12:28:20 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes.
Added paging to print function, and ability to print entire data base.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: mat_db.c,v 1.1 87/02/04 15:14:59 moss Locked $ (BRL)";
d23 2
a24 1
static FILE		*mat_db_fp;
d63 2
a64 2
	if( (mat_db_fp = fopen( mat_db_file, "r+" )) == NULL )
		return	mat_db_fp; /* NULL */
d68 1
a68 1
	return	mat_db_fp;
d76 1
a76 1
	return	fclose( mat_db_fp );
d119 1
a119 1
		prnt_Scroll( "\tshininess\t\t(%d)\n", entry->shine );
d122 1
a122 1
		prnt_Scroll( "\tspecular weight\t\t(%g)\n", entry->wgt_specular );
d125 1
a125 1
		prnt_Scroll( "\tdiffuse weight\t\t(%g)\n", entry->wgt_diffuse );
d128 1
a128 1
		prnt_Scroll( "\ttransparency\t\t(%g)\n", entry->transparency );
d131 1
a131 1
		prnt_Scroll( "\treflectivity\t\t(%g)\n", entry->reflectivity );
d134 1
a134 1
		prnt_Scroll( "\trefractive index\t(%g)\n", entry->refrac_index );
d137 1
a137 1
		prnt_Scroll( "\tdiffuse color\t\t(%d %d %d)\n",
d146 1
a146 1
/*	m a t _ A s c _ R e a d _ D b ( )
d149 1
a149 1
mat_Asc_Read_Db()
a160 14
/*	m a t _ B i n _ R e a d _ D b ( )
	Read binary material database into table, return number of entries.
 */
mat_Bin_Read_Db()
	{	Mat_Db_Entry	*entry;
	mat_db_size = 0;
	for(	entry = mat_db_table;
		entry < &mat_db_table[MAX_MAT_DB]
	     && fread( (char *) entry, sizeof(Mat_Db_Entry), 1, mat_db_fp ) == 1;
		++entry
		)
		mat_db_size++;
	return	mat_db_size;
	}
d162 1
a162 1
/*	m a t _ A s c _ S a v e _ D b ( )
d167 1
a167 1
mat_Asc_Save_Db( file )
d180 1
a180 1
	(void) fflush( mat_db_fp );
a183 21
/*	m a t _ B i n _ S a v e _ D b ( )
	Write binary material database from table.  If 'file' is NULL,
	overwrite input file, otherwise open or create 'file'.  Return success
	or failure.
 */
mat_Bin_Save_Db( file )
char	*file;
	{	register Mat_Db_Entry	*entry;
	if( ! mat_W_Open( file ) )
		return	0;
	for(	entry = mat_db_table;
		entry < &mat_db_table[mat_db_size]
	     && fwrite( (char *) entry, sizeof(Mat_Db_Entry), 1, mat_db_fp ) == 1;
		++entry
		)
		;
	if( entry != &mat_db_table[mat_db_size] )
		return	0;
	(void) fflush( mat_db_fp );
	return	1;
	}
d291 1
a291 1
	if( fgets( entry->name, MAX_MAT_NM, mat_db_fp ) == NULL )
d298 1
a298 1
		while( getc( mat_db_fp ) != '\n' )
d300 1
a300 1
	if( (items = fscanf( mat_db_fp, "%d %d", &entry->id, &entry->shine )) != 2 )
d305 1
a305 1
	if(	fscanf(	mat_db_fp,
d322 1
a322 1
	if( fscanf( mat_db_fp, "%d %d %d", &red, &grn, &blu ) != 3 )
d330 1
a330 1
	if( fscanf( mat_db_fp, "%d", &mode ) != 1 )
d338 1
a338 1
	while( getc( mat_db_fp ) != '\n' )
d349 3
a351 3
	(void) fprintf( mat_db_fp, "%s\n", entry->name );
	(void) fprintf( mat_db_fp, "%d\n%d\n", entry->id, entry->shine );
	(void) fprintf(	mat_db_fp,
d359 1
a359 1
	(void) fprintf(	mat_db_fp,
d365 1
a365 1
	(void) fprintf( mat_db_fp, "%u\n", (unsigned) entry->mode_flag );
d379 2
a380 2
			mat_db_fp = fp;
			setbuf( mat_db_fp, malloc( BUFSIZ ) );
d384 1
a384 1
	if( mat_db_fp == NULL )
d386 1
a386 1
	return	fseek( mat_db_fp, 0L, 0 ) == 0;
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d20 1
a20 1
#include <std.h>
d22 1
d31 1
a31 1
				0.3,		/* Diffuse weight.	*/
d52 2
a53 2
LOCAL int	get_Entry(), put_Entry();
LOCAL int	mat_W_Open();
a79 1
	'prnt_func' must be a varargs function.
d81 1
a81 1
mat_Print_Db( material_id, prnt_func )
a82 1
void		(*prnt_func)();
d84 11
a94 1
		
d96 8
a103 2
		return	-1;
	if( material_id < MAX_MAT_DB )
d105 37
a141 20
	else 
		return	-1;
	if( entry->mode_flag == MF_NULL )
		entry = &mat_nul_entry;
	(*prnt_func)( "\n" );
	(*prnt_func)( "MATERIAL [%d] %s\n",
			material_id,
			entry->name[0] == '\0' ? "(untitled)" : entry->name
			);
	(*prnt_func)( "\tshininess\t\t(%d)\n", entry->shine );
	(*prnt_func)( "\tspecular weight\t\t(%g)\n", entry->wgt_specular );
	(*prnt_func)( "\tdiffuse weight\t\t(%g)\n", entry->wgt_diffuse );
	(*prnt_func)( "\ttransparency\t\t(%g)\n", entry->transparency );
	(*prnt_func)( "\treflectivity\t\t(%g)\n", entry->reflectivity );
	(*prnt_func)( "\trefractive index\t(%g)\n", entry->refrac_index );
	(*prnt_func)( "\tdiffuse color\t\t(%d %d %d)\n",
			entry->df_rgb[0],
			entry->df_rgb[1],
			entry->df_rgb[2]
			);
d319 1
a319 1
LOCAL
d377 1
a377 1
LOCAL
d403 1
a403 1
LOCAL
@
