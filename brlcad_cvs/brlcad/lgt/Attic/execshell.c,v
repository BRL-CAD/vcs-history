head	11.8;
access;
symbols
	ansi-20040405-merged:11.5.2.1
	postmerge-20040405-ansi:11.6
	premerge-20040404-ansi:11.5
	postmerge-autoconf:11.5
	autoconf-freeze:11.5
	premerge-autoconf:11.5
	ansi-20040316-freeze:11.5.2.1
	postmerge-20040315-windows:11.5
	premerge-20040315-windows:11.5
	windows-20040315-freeze:11.5
	autoconf-20031203:11.5
	autoconf-20031202:11.5
	autoconf-branch:11.5.0.10
	phong-branch:11.5.0.8
	photonmap-branch:11.5.0.6
	rel-6-1-DP:11.5
	windows-branch:11.5.0.4
	rel-6-0-2:11.3
	ansi-branch:11.5.0.2
	rel-6-0-1-branch:11.3.0.2
	hartley-6-0-post:11.4
	hartley-6-0-pre:11.3
	rel-6-0-1:11.3
	rel-6-0:11.3
	rel-5-4:11.2
	offsite-5-3-pre:11.3
	rel-5-3:11.2
	rel-5-2:11.2
	rel-5-1-branch:11.2.0.2
	rel-5-1:11.2
	rel-5-0:11.2
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.1;
locks; strict;
comment	@ * @;


11.8
date	2004.05.21.17.48.15;	author morrison;	state dead;
branches;
next	11.7;

11.7
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.6;

11.6
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.5;

11.5
date	2002.08.20.17.07.33;	author jra;	state Exp;
branches
	11.5.2.1;
next	11.4;

11.4
date	2002.08.15.20.54.45;	author hartley;	state Exp;
branches;
next	11.3;

11.3
date	2000.08.24.22.55.50;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	99.06.03.21.40.50;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.44;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.24.13.33.48;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.00;	author mike;	state Rel4_0;
branches;
next	9.1;

9.1
date	89.05.19.06.13.02;	author mike;	state Rel3_5;
branches;
next	8.4;

8.4
date	89.03.13.16.41.36;	author moss;	state Exp;
branches;
next	8.3;

8.3
date	89.03.08.09.45.24;	author moss;	state Exp;
branches;
next	8.2;

8.2
date	89.03.07.12.15.35;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.51.43;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.06.23.09.21.03;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.12.06;	author mike;	state Rel;
branches;
next	6.1;

6.1
date	87.07.11.08.15.36;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.47.08;	author mike;	state Rel;
branches;
next	1.2;

1.2
date	87.06.23.12.31.05;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.12.29;	author moss;	state Exp;
branches;
next	;

11.5.2.1
date	2002.09.19.18.01.02;	author morrison;	state Exp;
branches;
next	;


desc
@@


11.8
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/execshell.c,v 11.7 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"

#define DFL_SHELL	"/bin/sh"
#define CSH		"/bin/csh"
#define TCSH		"/usr/brl/bin/tcsh"
#define	PERROR_RET() \
	(void) sprintf( error_buf, "\"%s\" (%d)", __FILE__, __LINE__ ); \
	loc_Perror( error_buf ); \
	return	-1;

void
loc_Perror(char *msg)
{
	if( errno >= 0 && errno < sys_nerr )
		bu_log( "%s: %s\n", msg, sys_errlist[errno] );
	else
		bu_log( "\"%s\" (%d), errno not set, shouldn't call perror.\n",
			__FILE__, __LINE__
			);
	return;
	}

/*	e x e c _ S h e l l ( )
	If args[0] is NULL, spawn a shell, otherwise execute the specified
	command line.
	Return the exit status of the program, or -1 if wait() or fork()
	return an error.
 */
int
exec_Shell(char **args)
{	register int child_pid;
		static char error_buf[32];
#if STD_SIGNAL_DECLS
		void (*intr_sig)(), (*quit_sig)();
#else
		int (*intr_sig)(), (*quit_sig)();
#endif
	if( args[0] == NULL )
		{ char	*arg_sh = getenv( "SHELL" );
		/* $SHELL, if set, DFL_SHELL otherwise.			*/
		if(	arg_sh == NULL
		/* Work around for process group problem.		*/
		    ||	strcmp( arg_sh, TCSH ) == 0
		    ||	strcmp( arg_sh, CSH ) == 0
			)
			arg_sh = DFL_SHELL;
		args[0] = arg_sh;
		args[1] = NULL;
		}
	intr_sig = signal( SIGINT,  SIG_IGN );
	quit_sig = signal( SIGQUIT, SIG_IGN );
	switch( child_pid = fork() )
		{
		case -1 :
			PERROR_RET();
		case  0 : /* Child process - execute.		*/
			{ int	tmp_fd;
			if(	(tmp_fd =
				open( "/dev/tty", O_WRONLY )) == -1
				)
				{
				PERROR_RET();
				}
			(void) close( 2 );
			if( fcntl( tmp_fd, F_DUPFD, 2 ) == -1 )
				{
				PERROR_RET();
				}
			(void) execvp( args[0], args );
			loc_Perror( args[0] );
			exit( errno );
			}
		default :
			{	register int	pid;
				int		stat_loc;
			while(	(pid = wait( &stat_loc )) != -1
			     && pid != child_pid
				)
				;
			prnt_Event( "\n" );
			(void) signal( SIGINT,  intr_sig );
			(void) signal( SIGQUIT, quit_sig );
			if( pid == -1 )
				{ /* No children.			*/
				loc_Perror( "wait" );
				return	errno;
				}
			switch( stat_loc & 0377 )
				{
				case 0177 : /* Child stopped.		*/
					bu_log(	"\"%s\" (%d) Child stopped.\n",
						__FILE__,
						__LINE__
						);
					return	(stat_loc >> 8) & 0377;
				case 0 :    /* Child exited.		*/
					return	(stat_loc >> 8) & 0377;
				default :   /* Child terminated.	*/
					bu_log(	"\"%s\" (%d) Child terminated, signal %d, status=0x%x.\n",
						__FILE__,
						__LINE__,
						stat_loc&0177,
						stat_loc
						);
					return	stat_loc&0377;
				}
			}
		}
	}
@


11.7
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/execshell.c,v 11.6 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.6
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 5
a16 1
#include "conf.h"
@


11.5
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/execshell.c,v 11.3 2000/08/24 22:55:50 mike Exp $ (BRL)";
d38 2
a39 3
loc_Perror( msg )
char	*msg;
	{
d56 2
a57 3
exec_Shell( args )
char	*args[];
	{	register int child_pid;
@


11.5.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/execshell.c,v 11.5 2002/08/20 17:07:33 jra Exp $ (BRL)";
d38 3
a40 2
loc_Perror(char *msg)
{
d57 3
a59 2
exec_Shell(char **args)
{	register int child_pid;
@


11.4
log
@Converted from K&R to ANSI C - RFH
@
text
@d38 3
a40 2
loc_Perror(char *msg)
{
d57 3
a59 2
exec_Shell(char **args)
{	register int child_pid;
@


11.3
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/execshell.c,v 11.2 1999/06/03 21:40:50 mike Exp $ (BRL)";
d38 2
a39 3
loc_Perror( msg )
char	*msg;
	{
d56 2
a57 3
exec_Shell( args )
char	*args[];
	{	register int child_pid;
@


11.2
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/execshell.c,v 11.1 1995/01/04 10:17:44 mike Rel4_4 $ (BRL)";
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/execshell.c,v 10.2 94/08/24 13:33:48 gdurf Exp $ (BRL)";
d42 1
a42 1
		rt_log( "%s: %s\n", msg, sys_errlist[errno] );
d44 1
a44 1
		rt_log( "\"%s\" (%d), errno not set, shouldn't call perror.\n",
d119 1
a119 1
					rt_log(	"\"%s\" (%d) Child stopped.\n",
d127 1
a127 1
					rt_log(	"\"%s\" (%d) Child terminated, signal %d, status=0x%x.\n",
@


10.2
log
@Made includes explicit, factored ifdefs
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/execshell.c,v 10.1 1991/10/12 06:50:00 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/execshell.c,v 9.1 89/05/19 06:13:02 mike Rel3_5 $ (BRL)";
d12 2
d17 10
d28 1
a35 6

#include <errno.h>
/* These aren't defined in BSD errno.h.					*/
extern int	errno;
extern int	sys_nerr;
extern char	*sys_errlist[];
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 8.4 89/03/13 16:41:36 moss Exp $ (BRL)";
@


8.4
log
@Fixed signal handler declarations.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 8.3 89/03/08 09:45:24 moss Locked $ (BRL)";
@


8.3
log
@Fixed preprocessor switch for signal handler decls again.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 8.2 89/03/07 12:15:35 moss Locked $ (BRL)";
d54 1
a54 1
#if __STDC__ || defined( SYSV )
@


8.2
log
@Fixed pre-processor switches for signal handler decs to accommodate
	ANSI C define of __STDC__.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 8.1 88/10/05 00:51:43 moss Locked $ (BRL)";
d52 4
a55 4
	{	register int	child_pid;
		static char	error_buf[32];
#if __STDC__ || defined( SYSV ) || defined( mips )
		void		(*intr_sig)(), (*quit_sig)();
d57 1
a57 1
		int		(*intr_sig)(), (*quit_sig)();
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 7.2 88/06/23 09:21:03 moss Locked $ (BRL)";
d54 3
a56 1
#if defined( BSD ) || (defined( SYSV ) && ! defined( mips ))
a57 2
#else
		void		(*intr_sig)(), (*quit_sig)();
@


7.2
log
@Just cleaning up.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 7.1 87/11/03 00:12:06 moss Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 6.1 87/07/11 08:15:36 mike Rel $ (BRL)";
a10 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) execshell.c	2.1
		Modified: 	12/10/86 at 16:04:23	G S M
		Retrieved: 	2/4/87 at 08:53:55
		SCCS archive:	/vld/moss/src/lgt/s.execshell.c
*/
d54 1
a54 1
#if defined( BSD ) || defined( SYSV )
@


6.1
log
@Release 2.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 5.1 87/06/24 22:47:08 mike Rel $ (BRL)";
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 1.2 87/06/23 12:31:05 moss Exp $ (BRL)";
@


1.2
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: execshell.c,v 1.1 87/02/04 15:12:29 moss Locked $ (BRL)";
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d61 1
a61 1
#if defined( BSD ) || defined( sgi )
a65 1
		register int	i;
@
