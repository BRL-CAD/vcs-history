head	11.9;
access;
symbols
	ansi-20040405-merged:11.6.2.1
	postmerge-20040405-ansi:11.7
	premerge-20040404-ansi:11.6
	postmerge-autoconf:11.6
	autoconf-freeze:11.6
	premerge-autoconf:11.6
	ansi-20040316-freeze:11.6.2.1
	postmerge-20040315-windows:11.6
	premerge-20040315-windows:11.6
	windows-20040315-freeze:11.6
	autoconf-20031203:11.6
	autoconf-20031202:11.6
	autoconf-branch:11.6.0.10
	phong-branch:11.6.0.8
	photonmap-branch:11.6.0.6
	rel-6-1-DP:11.6
	windows-branch:11.6.0.4
	rel-6-0-2:11.4
	ansi-branch:11.6.0.2
	rel-6-0-1-branch:11.4.0.2
	hartley-6-0-post:11.5
	hartley-6-0-pre:11.4
	rel-6-0-1:11.4
	rel-6-0:11.4
	rel-5-4:11.1
	offsite-5-3-pre:11.2
	rel-5-3:11.1
	rel-5-2:11.1
	rel-5-1-branch:11.1.0.2
	rel-5-1:11.1
	rel-5-0:11.1
	rel-5-0-beta:11.1
	rel-4-5:11.1
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.9
date	2004.05.21.17.48.16;	author morrison;	state dead;
branches;
next	11.8;

11.8
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.7;

11.7
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.6;

11.6
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.6.2.1;
next	11.5;

11.5
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.4;

11.4
date	2001.08.09.16.42.52;	author jra;	state Exp;
branches;
next	11.3;

11.3
date	2001.08.08.21.02.04;	author jra;	state Exp;
branches;
next	11.2;

11.2
date	2000.08.24.22.55.52;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.55;	author mike;	state Rel4_4;
branches;
next	10.2;

10.2
date	94.08.24.13.36.08;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.09;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	90.09.20.16.09.02;	author moss;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.20;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.05.12.23.27.36;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.51.59;	author mike;	state Rel3_0;
branches;
next	7.2;

7.2
date	88.06.23.09.29.31;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.23;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.10.29.08.51.55;	author moss;	state Exp;
branches;
next	6.2;

6.2
date	87.10.15.10.34.28;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.15.59;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.47.35;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.31.45;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.27.20;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.04.15.14.58;	author moss;	state Exp;
branches;
next	;

11.6.2.1
date	2002.09.19.18.01.04;	author morrison;	state Exp;
branches;
next	;


desc
@This is the initial version as far as the BRL/CAD distribution is concerned.
It is extracted from SCCS archives.
@


11.9
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/lgt_db.c,v 11.8 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <assert.h>

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./screen.h"
STATIC int	get_Lgt_Entry(register Lgt_Source *entry, FILE *fp), put_Lgt_Entry(register Lgt_Source *entry, FILE *fp);

/*	l g t _ P r i n t _ D b ( )
	Print light source database entry.
 */
int
lgt_Print_Db(int id)
{	register Lgt_Source	*entry;
		register int		stop;
		int			lines =	(PROMPT_LINE-TOP_SCROLL_WIN);
	if( id >= lgt_db_size )
		return	0;
	else
	if( id < 0 )
		{
		stop = lgt_db_size - 1;
		id = 0;
		}
	else
		stop = id;
	for( ; id <= stop; id++, lines-- ) 
		{
		entry = &lgts[id];
		if( lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "\n" );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "LIGHT SOURCE [%d] %s\n", id, entry->name );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "       manual override\t(%s)\n", entry->over ? "ON" : "OFF" );
		if( entry->stp == SOLTAB_NULL || entry->over )
			{
			if( --lines <= 0 && ! do_More( &lines ) )
				break;
			prnt_Scroll( "       azimuth\t\t(%g)\n", entry->azim*DEGRAD );
			if( --lines <= 0 && ! do_More( &lines ) )
				break;
			prnt_Scroll( "       elevation\t(%g)\n", entry->elev*DEGRAD );
			}
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "       distance\t\t(%g)\n", entry->dist );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "       location\t\t<%g,%g,%g>\n",
				entry->loc[X], entry->loc[Y], entry->loc[Z]
				);
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "       gaussian beam\t(%s)\n", entry->beam ? "ON" : "OFF" );
		if( entry->beam )
			{
			if( --lines <= 0 && ! do_More( &lines ) )
				break;
			prnt_Scroll( "       beam radius\t(%g)\n", entry->radius );
			}
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "       intensity\t(%g)\n", entry->energy );
		if( --lines <= 0 && ! do_More( &lines ) )
			break;
		prnt_Scroll( "       color\t\t(%d %d %d)\n",
				entry->rgb[0], entry->rgb[1], entry->rgb[2]
				);
		}
	(void) fflush( stdout );
	return	1;
	}

/*	l g t _ R e a d _ D b ( )
	Open light source database and read entries into table,
	return number of entries successfully read.
 */
int
lgt_Rd_Db(char *file)
{	register Lgt_Source	*entry;
		register FILE		*fp;
	if( (fp = fopen( file, "r" )) == NULL )
		return	0;
	lgt_db_size = 0;
	for(	entry = lgts;
		entry < &lgts[MAX_LGTS]
	     && get_Lgt_Entry( entry, fp );
		++entry
		)
		lgt_db_size++;
	(void) fclose( fp );
	return	lgt_db_size;
	}

/*	l g t _ S a v e _ D b ( )
	Write ASCII light source database from table.
	Return 1 for success, 0 for failure.
 */
int
lgt_Save_Db(char *file)
{
	register Lgt_Source	*entry;
	register FILE		*fp;

	if( (fp = fopen( file, "w" )) == NULL )
		return	0;
	setbuf( fp, malloc( BUFSIZ ) );
	for(	entry = lgts;
		entry < &lgts[lgt_db_size]
	     && put_Lgt_Entry( entry, fp );
		++entry
		)
		;
	(void) fclose( fp );
	if( entry != &lgts[lgt_db_size] )
		return	0;
	return	1;
	}

/*	l g t _ E d i t _ D b _ E n t r y ( )
	Create or overwrite entry in light source table.
 */
int
lgt_Edit_Db_Entry(int id)
{	register Lgt_Source	*entry;
		char			input_buf[MAX_LN];
		char			prompt[MAX_LN];
		int			red, grn, blu;
	if( id < 0 || id >= MAX_LGTS )
		return	-1;
	lgt_db_size = Max( lgt_db_size, id+1 );
	entry = &lgts[id];
	(void) sprintf( prompt, "light source name ? (%s) ", entry->name );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		(void) strncpy( entry->name, input_buf, MAX_LGT_NM-1 );
	(void) sprintf( prompt, "manual override ? [y|n](%c) ",
			entry->over ? 'y' : 'n' );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		entry->over = input_buf[0] != 'n';
	if( entry->over || entry->stp == SOLTAB_NULL )
		{
		(void) sprintf( prompt, "azimuth ? (%g) ",
				entry->azim*DEGRAD );
		if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
			{
			(void) sscanf( input_buf, "%lf", &entry->azim );
			entry->azim /= DEGRAD;
			}
		(void) sprintf( prompt, "elevation ? (%g) ",
				entry->elev*DEGRAD );
		if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
			{
			(void) sscanf( input_buf, "%lf", &entry->elev );
			entry->elev /= DEGRAD;
			}
		(void) sprintf( prompt, "distance ? (%g) ", entry->dist );
		if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
			(void) sscanf( input_buf, "%lf", &entry->dist );
		}
	(void) sprintf( prompt, "gaussian beam ? [y|n](%c) ",
			entry->beam ? 'y' : 'n' );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		entry->beam = input_buf[0] != 'n';
	if( entry->beam )
		{
		(void) sprintf( prompt, "radius of beam ? (%g) ",
				entry->radius );
		if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
			(void) sscanf( input_buf, "%lf", &entry->radius );
		}
	(void) sprintf( prompt, "intensity ? [0.0 to 1.0](%g) ",
			entry->energy );
	if( get_Input( input_buf, MAX_LN, prompt ) != NULL )
		(void) sscanf( input_buf, "%lf", &entry->energy );
	(void) sprintf( prompt, "color ? [0 to 255](%d %d %d) ",
			entry->rgb[RED],
			entry->rgb[GRN],
			entry->rgb[BLU]
			);
	if(	get_Input( input_buf, MAX_LN, prompt ) != NULL
	     &&	sscanf( input_buf, "%d %d %d", &red, &grn, &blu ) == 3
		)
		{
		entry->rgb[RED] = red;
		entry->rgb[GRN] = grn;
		entry->rgb[BLU] = blu;
		}
	return	1;
	}

STATIC int
get_Lgt_Entry(register Lgt_Source *entry, FILE *fp)
{	register char	*ptr;
		int		red, grn, blu;
	if( fgets( entry->name, MAX_LGT_NM, fp ) == NULL )
		return	0;
	ptr = &entry->name[strlen(entry->name) - 1];
	if( *ptr == '\n' )
		/* Read entire line.					*/
		*ptr = '\0';
	else	/* Skip rest of line.					*/
		while( getc( fp ) != '\n' )
			;
	if( fscanf( fp, "%d %d", &entry->beam, &entry->over ) != 2 )
		return	0;
	if( fscanf( fp, "%d %d %d", &red, &grn, &blu ) != 3 )
		return	0;
	entry->rgb[0] = red;
	entry->rgb[1] = grn;
	entry->rgb[2] = blu;
	if(	fscanf(	fp,
			"%lf %lf %lf %lf %lf",
			&entry->azim,
			&entry->elev,
			&entry->dist,
			&entry->energy,
			&entry->radius
			) != 5
		)
		return	0;
	while( getc( fp ) != '\n' )
		; /* Gobble rest of line.				*/
	return	1;
	}

STATIC int
put_Lgt_Entry(register Lgt_Source *entry, FILE *fp)
{
	(void) fprintf( fp, "%s\n", entry->name );
	(void) fprintf(	fp,
			"%d\n%d\n%u %u %u\n",
			entry->beam,
			entry->over,
			(unsigned) entry->rgb[0],
			(unsigned) entry->rgb[1],
			(unsigned) entry->rgb[2]
			);
	(void) fprintf( fp,
			"%f\n%f\n%f\n%f\n%f\n",
			entry->azim,
			entry->elev,
			entry->dist,
			entry->energy,
			entry->radius
			);
	return	1;
	}
@


11.8
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/lgt_db.c,v 11.7 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.7
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 5
a16 1
#include "conf.h"
@


11.6
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt_db.c,v 11.4 2001/08/09 16:42:52 jra Exp $ (BRL)";
d28 1
a28 1
STATIC int	get_Lgt_Entry(), put_Lgt_Entry();
d34 2
a35 3
lgt_Print_Db( id )
int		id;
	{	register Lgt_Source	*entry;
d104 2
a105 3
lgt_Rd_Db( file )
char	*file;
	{	register Lgt_Source	*entry;
d125 2
a126 3
lgt_Save_Db( file )
char	*file;
	{
d149 2
a150 3
lgt_Edit_Db_Entry( id )
int	id;
	{	register Lgt_Source	*entry;
d217 2
a218 4
get_Lgt_Entry( entry, fp )
register Lgt_Source	*entry;
FILE			*fp;
	{	register char	*ptr;
d252 2
a253 4
put_Lgt_Entry( entry, fp )
register Lgt_Source	*entry;
FILE			*fp;
	{
@


11.6.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt_db.c,v 11.6 2002/08/20 17:07:34 jra Exp $ (BRL)";
d28 1
a28 1
STATIC int	get_Lgt_Entry(register Lgt_Source *entry, FILE *fp), put_Lgt_Entry(register Lgt_Source *entry, FILE *fp);
d34 3
a36 2
lgt_Print_Db(int id)
{	register Lgt_Source	*entry;
d105 3
a107 2
lgt_Rd_Db(char *file)
{	register Lgt_Source	*entry;
d127 3
a129 2
lgt_Save_Db(char *file)
{
d152 3
a154 2
lgt_Edit_Db_Entry(int id)
{	register Lgt_Source	*entry;
d221 4
a224 2
get_Lgt_Entry(register Lgt_Source *entry, FILE *fp)
{	register char	*ptr;
d258 4
a261 2
put_Lgt_Entry(register Lgt_Source *entry, FILE *fp)
{
@


11.5
log
@Converted from K&R to ANSI C - RFH
@
text
@d28 1
a28 1
STATIC int	get_Lgt_Entry(register Lgt_Source *entry, FILE *fp), put_Lgt_Entry(register Lgt_Source *entry, FILE *fp);
d34 3
a36 2
lgt_Print_Db(int id)
{	register Lgt_Source	*entry;
d105 3
a107 2
lgt_Rd_Db(char *file)
{	register Lgt_Source	*entry;
d127 3
a129 2
lgt_Save_Db(char *file)
{
d152 3
a154 2
lgt_Edit_Db_Entry(int id)
{	register Lgt_Source	*entry;
d221 4
a224 2
get_Lgt_Entry(register Lgt_Source *entry, FILE *fp)
{	register char	*ptr;
d258 4
a261 2
put_Lgt_Entry(register Lgt_Source *entry, FILE *fp)
{
@


11.4
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt_db.c,v 11.3 2001/08/08 21:02:04 jra Exp $ (BRL)";
d28 1
a28 1
STATIC int	get_Lgt_Entry(), put_Lgt_Entry();
d34 2
a35 3
lgt_Print_Db( id )
int		id;
	{	register Lgt_Source	*entry;
d104 2
a105 3
lgt_Rd_Db( file )
char	*file;
	{	register Lgt_Source	*entry;
d125 2
a126 3
lgt_Save_Db( file )
char	*file;
	{
d149 2
a150 3
lgt_Edit_Db_Entry( id )
int	id;
	{	register Lgt_Source	*entry;
d217 2
a218 4
get_Lgt_Entry( entry, fp )
register Lgt_Source	*entry;
FILE			*fp;
	{	register char	*ptr;
d252 2
a253 4
put_Lgt_Entry( entry, fp )
register Lgt_Source	*entry;
FILE			*fp;
	{
@


11.3
log
@lint
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt_db.c,v 11.2 2000/08/24 22:55:52 mike Exp $ (BRL)";
d33 1
d151 1
@


11.2
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/lgt_db.c,v 11.1 1995/01/04 10:17:55 mike Rel4_4 $ (BRL)";
d103 1
d125 1
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt_db.c,v 10.2 94/08/24 13:36:08 gdurf Exp $ (BRL)";
@


10.2
log
@Made includes explicit, factored ifdefs
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt_db.c,v 10.1 1991/10/12 06:50:09 mike Rel4_0 gdurf $ (BRL)";
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/lgt_db.c,v 9.2 90/09/20 16:09:02 moss Exp $ (BRL)";
d12 2
d15 10
a170 3
#if defined( sgi ) && ! defined( mips )
			(void) sscanf( input_buf, "%f", &entry->azim );
#else
a171 1
#endif
a177 3
#if defined( sgi ) && ! defined( mips )
			(void) sscanf( input_buf, "%f", &entry->elev );
#else
a178 1
#endif
a182 3
#if defined( sgi ) && ! defined( mips )
			(void) sscanf( input_buf, "%f", &entry->dist );
#else
a183 1
#endif
a193 3
#if defined( sgi ) && ! defined( mips )
			(void) sscanf( input_buf, "%f", &entry->radius );
#else
a194 1
#endif
a198 3
#if defined( sgi ) && ! defined( mips )
		(void) sscanf( input_buf, "%f", &entry->energy );
#else
a199 1
#endif
a238 3
#if defined( sgi ) && ! defined( mips )
			"%f %f %f %f %f",
#else
a239 1
#endif
@


9.2
log
@Fixed spelling: overide->override.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 9.1 89/05/19 06:13:20 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 8.2 89/05/12 23:27:36 moss Exp $ (BRL)";
d47 1
a47 1
		prnt_Scroll( "       manual overide\t(%s)\n", entry->over ? "ON" : "OFF" );
d149 1
a149 1
	(void) sprintf( prompt, "manual overide ? [y|n](%c) ",
@


8.2
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 7.1 87/11/03 00:25:23 moss Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 7.2 88/06/23 09:29:31 moss Locked $ (BRL)";
d13 1
a13 3
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
a14 1
#include "./lgt.h"
d16 1
a16 2
#include "./extern.h"
_LOCAL_ int	get_Lgt_Entry(), put_Lgt_Entry();
d224 1
a224 1
_LOCAL_ int
d265 1
a265 1
_LOCAL_ int
@


7.2
log
@Smoothing out menu and prompting interface.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 7.1 87/11/03 00:25:23 moss Locked $ (BRL)";
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 6.3 87/10/29 08:51:55 moss Exp $ (BRL)";
a10 7
/*
	Originally extracted from SCCS archive:
		SCCS id:	@@(#) lgt_db.c	2.2
		Modified: 	1/30/87 at 17:22:29	G S M
		Retrieved: 	2/4/87 at 08:53:39
		SCCS archive:	/vld/moss/src/lgt/s.lgt_db.c
*/
d143 2
a144 1
		static char		input_buf[BUFSIZ];
d150 2
a151 3
	if( get_Input( input_buf, BUFSIZ, "light source name : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
d153 4
a156 4
	if( get_Input( input_buf, BUFSIZ, "manual overide : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
		(void) sscanf( input_buf, "%d", &entry->over );
d159 3
a161 3
		if( get_Input( input_buf, BUFSIZ, "azimuth : " ) == NULL )
			return	0;
		if( input_buf[0] != '\0' )
d163 1
a163 1
#ifdef sgi
d170 3
a172 3
		if( get_Input( input_buf, BUFSIZ, "elevation : " ) == NULL )
			return	0;
		if( input_buf[0] != '\0' )
d174 1
a174 1
#ifdef sgi
d181 3
a183 4
		if( get_Input( input_buf, BUFSIZ, "distance : " ) == NULL )
			return	0;
		if( input_buf[0] != '\0' )
#ifdef sgi
d189 4
a192 4
	if( get_Input( input_buf, BUFSIZ, "gaussian beam : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
		(void) sscanf( input_buf, "%d", &entry->beam );
d195 4
a198 4
		if( get_Input( input_buf, BUFSIZ, "radius of beam : " ) == NULL )
			return	0;
		if( input_buf[0] != '\0' )
#ifdef sgi
d204 4
a207 4
	if( get_Input( input_buf, BUFSIZ, "intensity : " ) == NULL )
		return	0;
	if( input_buf[0] != '\0' )
#ifdef sgi
d212 6
a217 3
	if( get_Input( input_buf, BUFSIZ, "color : " ) == NULL )
		return	0;
	if(	input_buf[0] != '\0'
d221 3
a223 3
		entry->rgb[0] = red;
		entry->rgb[1] = grn;
		entry->rgb[2] = blu;
d251 1
a251 1
#ifdef sgi
@


6.3
log
@Ready for release 2.1 of BRL CAD.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 6.2 87/10/15 10:34:28 moss Locked $ (BRL)";
@


6.2
log
@Change in return code from printing routine to indicate whether or not
anything was actually printed.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 5.1 87/06/24 22:47:35 mike Rel $ (BRL)";
a230 13
	}

/*	l g t _ G e t _ D b _ E n t r y ( )
	Return pointer to entry indexed by id or NULL.
 */
Lgt_Source *
lgt_Get_Db_Entry( lgt_id )
int	lgt_id;
	{
	if( lgt_id >= 0 && lgt_id < lgt_db_size )
		return	&lgts[lgt_id];
	else
		return	LGT_NULL;
@


6.1
log
@Release 2.0
@
text
@d38 1
a38 1
		return	-1;
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 1.3 87/06/23 12:31:45 moss Exp $ (BRL)";
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 1.2 87/02/06 12:27:20 moss Locked $ (BRL)";
@


1.2
log
@Reorganized includes.
Added paging to print function, and ability to print entire data base.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: lgt_db.c,v 1.1 87/02/04 15:14:58 moss Locked $ (BRL)";
d58 1
a58 1
		prnt_Scroll( "\tmanual overide\t(%s)\n", entry->over ? "ON" : "OFF" );
d63 1
a63 1
			prnt_Scroll( "\tazimuth\t\t(%g)\n", entry->azim*DEGRAD );
d66 1
a66 1
			prnt_Scroll( "\televation\t(%g)\n", entry->elev*DEGRAD );
d70 1
a70 1
		prnt_Scroll( "\tdistance\t(%g)\n", entry->dist );
d73 1
a73 1
		prnt_Scroll( "\tlocation\t<%g,%g,%g>\n",
d78 1
a78 1
		prnt_Scroll( "\tgaussian beam\t(%s)\n", entry->beam ? "ON" : "OFF" );
d83 1
a83 1
			prnt_Scroll( "\tbeam radius\t(%g)\n", entry->radius );
d87 1
a87 1
		prnt_Scroll( "\tintensity\t(%g)\n", entry->energy );
d90 1
a90 1
		prnt_Scroll( "\tcolor\t\t(%d %d %d)\n",
d102 1
a102 1
lgt_Read_Db( file )
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d20 6
a25 6
#include <std.h>
#include <machine.h>
#include <vmath.h>
#include <raytrace.h>
#include <vecmath.h>
#include <lgt.h>
a30 1
	'prnt_func' must be a varargs function.
d32 1
a32 1
lgt_Print_Db( id, prnt_func )
a33 1
void		(*prnt_func)();
d35 3
a37 1
	if( id < 0 || id >= lgt_db_size )
d39 2
a40 5
	entry = &lgts[id];
	(*prnt_func)( "\n" );
	(*prnt_func)( "LIGHT SOURCE [%d] %s\n", id, entry->name );
	(*prnt_func)( "\tmanual overide\t(%s)\n", entry->over ? "ON" : "OFF" );
	if( entry->stp == SOLTAB_NULL || entry->over )
d42 2
a43 3
		(*prnt_func)( "\tazimuth\t\t(%g)\n", entry->azim*DEGRAD );
		(*prnt_func)( "\televation\t(%g)\n", entry->elev*DEGRAD );
		
d45 50
a94 9
	(*prnt_func)( "\tdistance\t(%g)\n", entry->dist );
	V_Print( "\tlocation", entry->loc, prnt_Scroll );
	(*prnt_func)( "\tgaussian beam\t(%s)\n", entry->beam ? "ON" : "OFF" );
	if( entry->beam )
		(*prnt_func)( "\tbeam radius\t(%g)\n", entry->radius );
	(*prnt_func)( "\tintensity\t(%g)\n", entry->energy );
	(*prnt_func)( "\tcolor\t\t(%d %d %d)\n",
			entry->rgb[0], entry->rgb[1], entry->rgb[2]
			);
@
