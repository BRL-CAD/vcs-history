head	11.10;
access;
symbols
	ansi-20040405-merged:11.7.2.1
	postmerge-20040405-ansi:11.8
	premerge-20040404-ansi:11.7
	postmerge-autoconf:11.7
	autoconf-freeze:11.7
	premerge-autoconf:11.7
	ansi-20040316-freeze:11.7.2.1
	postmerge-20040315-windows:11.7
	premerge-20040315-windows:11.7
	windows-20040315-freeze:11.7
	autoconf-20031203:11.7
	autoconf-20031202:11.7
	autoconf-branch:11.7.0.10
	phong-branch:11.7.0.8
	photonmap-branch:11.7.0.6
	rel-6-1-DP:11.7
	windows-branch:11.7.0.4
	rel-6-0-2:11.5
	ansi-branch:11.7.0.2
	rel-6-0-1-branch:11.5.0.2
	hartley-6-0-post:11.6
	hartley-6-0-pre:11.5
	rel-6-0-1:11.5
	rel-6-0:11.5
	rel-5-4:11.3
	offsite-5-3-pre:11.4
	rel-5-3:11.3
	rel-5-2:11.3
	rel-5-1-branch:11.3.0.2
	rel-5-1:11.3
	rel-5-0:11.3
	rel-5-0-beta:11.2
	rel-4-5:11.2
	ctj-4-5-post:11.1
	ctj-4-5-pre:11.1
	rel-4-4:11.1
	rel-4-0:10.1
	rel-3-5:9.1
	rel-3-0:8.1
	rel-2-3:7.1
	rel-2-0:5.1
	rel-1-24:5.1
	rel-1-20:1.2;
locks; strict;
comment	@ * @;


11.10
date	2004.05.21.17.48.16;	author morrison;	state dead;
branches;
next	11.9;

11.9
date	2004.05.10.15.30.43;	author erikg;	state Exp;
branches;
next	11.8;

11.8
date	2004.04.05.07.46.59;	author morrison;	state Exp;
branches;
next	11.7;

11.7
date	2002.08.20.17.07.34;	author jra;	state Exp;
branches
	11.7.2.1;
next	11.6;

11.6
date	2002.08.15.20.54.46;	author hartley;	state Exp;
branches;
next	11.5;

11.5
date	2001.05.17.20.05.16;	author morrison;	state Exp;
branches;
next	11.4;

11.4
date	2000.08.24.22.55.52;	author mike;	state Exp;
branches;
next	11.3;

11.3
date	99.06.03.21.40.51;	author mike;	state Exp;
branches;
next	11.2;

11.2
date	97.12.16.00.25.39;	author mike;	state Exp;
branches;
next	11.1;

11.1
date	95.01.04.10.17.59;	author mike;	state Rel4_4;
branches;
next	10.4;

10.4
date	95.01.04.10.17.13;	author mike;	state Exp;
branches;
next	10.3;

10.3
date	94.12.20.15.27.06;	author mike;	state Exp;
branches;
next	10.2;

10.2
date	94.08.24.13.36.49;	author gdurf;	state Exp;
branches;
next	10.1;

10.1
date	91.10.12.06.50.12;	author mike;	state Rel4_0;
branches;
next	9.2;

9.2
date	91.08.30.21.14.36;	author mike;	state Exp;
branches;
next	9.1;

9.1
date	89.05.19.06.13.26;	author mike;	state Rel3_5;
branches;
next	8.2;

8.2
date	89.05.12.23.27.43;	author moss;	state Exp;
branches;
next	8.1;

8.1
date	88.10.05.00.52.07;	author mike;	state Rel3_0;
branches;
next	7.5;

7.5
date	88.09.20.15.55.39;	author moss;	state Exp;
branches;
next	7.4;

7.4
date	88.08.30.10.23.16;	author moss;	state Exp;
branches;
next	7.3;

7.3
date	88.08.09.12.57.00;	author moss;	state Exp;
branches;
next	7.2;

7.2
date	88.06.23.09.30.09;	author moss;	state Exp;
branches;
next	7.1;

7.1
date	87.11.03.00.25.37;	author mike;	state Rel;
branches;
next	6.3;

6.3
date	87.10.29.08.52.05;	author moss;	state Exp;
branches;
next	6.2;

6.2
date	87.10.15.10.41.47;	author moss;	state Exp;
branches;
next	6.1;

6.1
date	87.07.11.08.16.15;	author mike;	state Rel;
branches;
next	5.1;

5.1
date	87.06.24.22.47.55;	author mike;	state Rel;
branches;
next	1.3;

1.3
date	87.06.23.12.32.37;	author moss;	state Exp;
branches;
next	1.2;

1.2
date	87.02.06.12.28.55;	author moss;	state Exp;
branches;
next	1.1;

1.1
date	87.02.05.17.18.25;	author moss;	state Exp;
branches;
next	;

11.7.2.1
date	2002.09.19.18.01.05;	author morrison;	state Exp;
branches;
next	;


desc
@Consolidate all printing functions (prnt_*).
@


11.10
log
@moved to src/lgt/
@
text
@/*
	Author:		Gary S. Moss
			U. S. Army Ballistic Research Laboratory
			Aberdeen Proving Ground
			Maryland 21005-5066
			(301)278-6647 or AV-298-6647
*/
#ifndef lint
static const char RCSid[] = "@@(#)$Header: /n/xoff/cvs/brlcad/lgt/prnt.c,v 11.9 2004/05/10 15:30:43 erikg Exp $ (BRL)";
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif



#include <stdio.h>
#include <math.h>
#include <assert.h>
#if defined(HAVE_STDARG_H)
#include <stdarg.h>
#elif defined(HAVE_VARARGS_H)
#include <varargs.h>
#endif

#include "machine.h"
#include "externs.h"
#include "vmath.h"
#include "raytrace.h"
#include "fb.h"
#include "./hmenu.h"
#include "./lgt.h"
#include "./extern.h"
#include "./vecmath.h"
#include "./tree.h"
#include "./screen.h"
#include "./ascii.h"

static char	*usage[] =
	{
"",
"Usage:",
"",
"lgt [-IOjovw file][-AGKTXacefiknps n][-G \"s c g v\"][-b \"R G B\"][-dtD \"x y\"][-xy \"a b\"] file.g object...",
"",
"The options may appear in any order; however, their parameters must",
"be present, are positional, and if there is more than one parameter",
"for an option, they must be supplied as a single argument (e.g.,",
"inside double-quotes as shown).",
"",
0
	};
static char	*lgt_menu[] =
	{
"                BRL Lighting Model (LGT) : global command set",
"",
"A factor             anti-aliasing thru over-sampling by factor (i.e. 2)",
"a roll               specify roll (angle around viewing axis) rotation to grid",
"B                    submit batch run using current context",
"b R G B              specify background-color",
"C                    use cursor input module",
"c flag               enable or disable tracking cursor",
"D x y                translate image when raytracing (WRT viewport)",
"E                    clear display",
"e bitmask            set debug flag (hexidecimal bitmask)",
"F                    animate",
"f distance           specify distance from origin of grid to model centroid",
"G size cflag gflag view_size    grid configuration",
"        if cflag == 0, size refers to no. of rays across image (default)",
"        otherwise it refers to cell size (ray separation) in millimeters.",
"        if gflag == 0, grid origin will be aligned WRT model RPP (default)",
"        otherwise it will be aligned WRT model origin",
"        if viewsize > 0.0 the field of view will be set accordingly",
"        otherwise it will be set relative to the model RPP (default)",
"H file               save frame buffer image",
"h file               read frame buffer image",
"J                    make a movie (prompts for parameters)",
"j file               input key-frame from file (as output by mged(1))",
"K bounces            maximum level of recursion in raytracing",
"k flag               enable or disable hidden line drawing",
"        if flag == 0, a lighting model image is produced (default)",
"        otherwise a hidden line drawing is produced",
"        if flag == 2, a reverse video (white-on-black) drawing is generated",
"L id                 modify light source entry id (0 to 10)",
"l id                 print light source entry id (0 to 10) or all",
"M id                 modify material data base entry id (0 to 99)",
"m id                 print material data base entry id (0 to 99) or all",
"n processors         number of processors to use (parallel environment)",
"O file               re-direct errors to specified output file",
"o file               image (output file for picture)",
"p factor             adjust perspective (0.0 to infinity)",
"q or ^D              quit",
"R                    raytrace (generate image) within current rectangle",
"r                    redraw screen",
"S file               script (save current option settings in file)",
"s                    enter infrared module",
"T size               size of frame buffer display (pixels across)",
"        By default the display window fits the grid size.  If zooming",
"        is desired, size should be a multiple of the grid size. To turn",
"        off manual sizing, set size to zero.",
"t x y                translate grid when raytracing (WRT model)",
"V file               write light source data base",
"v file               read light source data base",
"W file               write material attribute data base",
"w file               read material attribute data base",
"X flag               enable or disable reporting of overlaps",
"x start finish       set left and right border of current rectangle",
"y start finish       set bottom and top border of current rectangle",
"z ulen vlen width    size of texture map (plus width of padded lines)",
"?                    print this menu",
"! arg(s)             feed arg(s) to /bin/sh or $SHELL if set",
". flag               set buffered pixel I/O flag",
"# anything           comment or NOP (useful in preparing input files)",
	NULL
	};
static char	*ir_menu[] =
	{
"",
"                       Infrared Module: local commands",
"",
"d x y                specify automatic IR mapping offsets",
"I file               read and display IR data",
"i noise              specify noise threshold for IR data",
"N temperature        specify temperature for IR painting",
"P                    print GED regions and associated IR mappings",
"Q                    enter temperature for GED region or group",
"s                    exit IR module",
"U file               write IR data base file",
"u file               read IR data base file",
"Z                    display pseudo-color IR mapping scale",
	NULL
	};

char	screen[TOP_SCROLL_WIN+1][TEMPLATE_COLS+1];

/*	pad_Strcpy -- WARNING: this routine does NOT nul-terminate the
	destination buffer, but pads it with blanks.
 */
STATIC void
pad_Strcpy(register char *des, register char *src, register int len)
{
	while( len > 0 && *src != '\0' )
		{
		*des++ = *src++;
		len--;
		}
	while( len-- > 0 )
		*des++ = ' ';
	return;
	}

/*	i n i t _ S t a t u s ( )					*/
void
init_Status(void)
{	register int	row, col;
	for( row = 0; row <= TOP_SCROLL_WIN; row++ )
		for( col = 0; col <= TEMPLATE_COLS; col++ )
			screen[row][col] = '\0';
	return;
	}

/*	p r n t _ S t a t u s ( )					*/
void
prnt_Status(void)
{	static char	scratchbuf[TEMPLATE_COLS+1];
	pad_Strcpy( TITLE_PTR, title, TITLE_LEN - 1 );
	pad_Strcpy( TIMER_PTR, timer, TIMER_LEN - 1 );
	pad_Strcpy( F_SCRIPT_PTR, script_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", view_size );
	(void) strncpy( VU_SIZE_PTR, scratchbuf, strlen( scratchbuf ) );
	pad_Strcpy( F_ERRORS_PTR, err_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", grid_dist );
	(void) strncpy( GRID_DIS_PTR, scratchbuf, strlen( scratchbuf ) );
	pad_Strcpy( F_MAT_DB_PTR, mat_db_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", x_grid_offset );
	(void) strncpy( GRID_XOF_PTR, scratchbuf, strlen( scratchbuf ) );
	pad_Strcpy( F_LGT_DB_PTR, lgt_db_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", y_grid_offset );
	(void) strncpy( GRID_YOF_PTR, scratchbuf, strlen( scratchbuf ) );
	pad_Strcpy( F_RASTER_PTR, fb_file, 32 );
	(void) sprintf( scratchbuf, "%11.4f", modl_radius );
	(void) strncpy( MODEL_RA_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%3d %3d %3d",
			background[0], background[1], background[2] );
	(void) strncpy( BACKGROU_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf,
			"%4s",	pix_buffered == B_PAGE ? "PAGE" :
				pix_buffered == B_PIO ? "PIO" :
				pix_buffered == B_LINE ? "LINE" : "?"
				);
	(void) strncpy( BUFFERED_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "0x%06x", RT_G_DEBUG );
	(void) strncpy( DEBUGGER_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%-2d", max_bounce );
	(void) strncpy( MAX_BOUN_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, " LGT %s", version );
	(void) strncpy( PROGRAM_NM_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, " %s ",
			ged_file == NULL ? "(null)" : ged_file );
	(void) strncpy( F_GED_DB_PTR, scratchbuf,
			Min( strlen( scratchbuf ), 26 ) );
	(void) sprintf( scratchbuf, " [%04d-", grid_x_org );
	(void) strncpy( GRID_PIX_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%04d,", grid_x_fin );
	(void) strncpy( GRID_SIZ_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%04d-", grid_y_org );
	(void) strncpy( GRID_SCN_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%04d:", grid_y_fin );
	(void) strncpy( GRID_FIN_PTR, scratchbuf, strlen( scratchbuf ) );
	(void) sprintf( scratchbuf, "%04d] ", frame_no );
	(void) strncpy( FRAME_NO_PTR, scratchbuf, strlen( scratchbuf ) );
	update_Screen();
	return;
	}

void
update_Screen(void)
{	register int	tem_co, row, col;
	tem_co = Min( co, TEMPLATE_COLS );
	for( row = 0; template[row][0] != '\0'; row++ )
		{	register int	lastcol = -2;
		if( template[row+1] == NULL )
			(void) SetStandout();
		for( col = 0; col < tem_co; col++ )
			if( screen[row][col] != template[row][col] )
				{
				if( col != lastcol+1 )
					MvCursor( col+1, row+1 );
				lastcol = col;
				(void) putchar( template[row][col] );
				screen[row][col] = template[row][col];
				}
		}
	(void) ClrStandout();
	EVENT_MOVE();
	(void) fflush( stdout );
	return;
	}

/*	p r n t _ P a g e d _ M e n u ( )				*/
void
prnt_Paged_Menu(register char **menu)
{	register int	done = FALSE;
		int		lines =	(PROMPT_LINE-TOP_SCROLL_WIN);
	if( ! tty )
		{
		for( ; *menu != NULL; menu++ )
			bu_log( "%s\n", *menu );
		return;
		}
	for( ; *menu != NULL && ! done;  )
		{
		for( ; lines > 0 && *menu != NULL; menu++, --lines )
			prnt_Scroll( "%-*s\n", co, *menu );
		if( *menu != NULL )
			done = ! do_More( &lines );
		prnt_Prompt( "" );
		}
	(void) fflush( stdout );
	return;
	}

int
do_More(int *linesp)
{	register int	ret = TRUE;
	if( ! tty )
		return	TRUE;
	save_Tty( 0 );
	set_Raw( 0 );
	clr_Echo( 0 );
	SetStandout();
	prnt_Prompt( "More ? [n|<return>|<space>] " );
	ClrStandout();
	(void) fflush( stdout );
	switch( hm_getchar() )
		{
	case 'Q' :
	case 'q' :
	case 'N' :
	case 'n' :
		ret = FALSE;
		break;
	case LF :
	case CR :
		*linesp = 1;
		break;
	default :
		*linesp = (PROMPT_LINE-TOP_SCROLL_WIN);
		break;
		}
	reset_Tty( 0 );
	return	ret;
	}


/*	p r n t _ M e n u ( )						*/
void
prnt_Menu(void)
{
	prnt_Paged_Menu( lgt_menu );
	if( ir_mapping )
		prnt_Paged_Menu( ir_menu );
	hmredraw();
	return;
	}

/*	p r n t _ P r o m p t ( )					*/
void
prnt_Prompt(char *prompt)
{
	if( tty )
		{
		PROMPT_MOVE();
		(void) ClrEOL();
		(void) SetStandout();
		(void) printf( "%s", prompt );
		(void) ClrStandout();
		(void) fflush( stdout );
		}
	return;
	}

/*	p r n t _ T i m e r ( )						*/
void
prnt_Timer(char *eventstr)
{
	(void) rt_read_timer( timer, TIMER_LEN-1 );
	if( tty )
		{
		pad_Strcpy( TIMER_PTR, timer, TIMER_LEN-1 );
		update_Screen();
		}
	else
		bu_log( "(%s) %s\n", eventstr == NULL ? "(null)" : eventstr, timer );
	return;
	}

/*	p r n t _ E v e n t ( )						*/
void
prnt_Event(char *s)
{	static int	lastlen = 0;
		register int	i;
	if( ! tty )
		return;
	EVENT_MOVE();	
	if( s != NULL )
		{	register int len = strlen( s );
		(void) fputs( s, stdout );
		/* Erase last message. */
		for( i = len; i < lastlen; i++ )
			(void) putchar( ' ' );
		lastlen = len;
		}
	else
		{
		/* Erase last message. */
		for( i = 0; i < lastlen; i++ )
			(void) putchar( ' ' );
		lastlen = 0;
		}
	IDLE_MOVE();
	(void) fflush( stdout );
	return;
	}

/*	p r n t _ T i t l e ( )						*/
void
prnt_Title(char *titleptr)
{
	if( ! tty || RT_G_DEBUG )
		bu_log( "%s\n", titleptr == NULL ? "(null)" : titleptr );
	return;
	}

/*	p r n t _ U s a g e ( )
	Print usage message.
 */
void
prnt_Usage(void)
{	register char	**p = usage;
	while( *p != NULL )
		(void) fprintf( stderr, "%s\n", *p++ );
	return;
	}

#if defined(HAVE_STDARG_H)
/*	p r n t _ S c r o l l ( )					*/
/* VARARGS */
void
prnt_Scroll( char *fmt, ... )
	{	va_list		ap;
	/* We use the same lock as malloc.  Sys-call or mem lock, really */
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start( ap, fmt );
	if( tty )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void)vfprintf( stdout, fmt, ap );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void)vfprintf( stdout, fmt, ap );
			}
		else
			(void)vfprintf( stdout, fmt, ap );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		(void)vfprintf( stderr, fmt, ap );
	va_end( ap );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	return;
	}

#elif !defined(HAVE_VARARGS_H)

void
prnt_Scroll(fmt, a,b,c,d,e,f,g,h,i)
char *fmt;
{
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	if( tty )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
			}
		else
			(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		(void) fprintf( stdout, fmt, a,b,c,d,e,f,g,h,i );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
}
#else
/*	p r n t _ S c r o l l ( )					*/
/* VARARGS */
void
prnt_Scroll( fmt, va_alist )
char	*fmt;
va_dcl
	{	va_list		ap;
	/* We use the same lock as malloc.  Sys-call or mem lock, really */
	bu_semaphore_acquire( BU_SEM_SYSCALL );		/* lock */
	va_start( ap );
	if( tty )
		{ /* Only move cursor and scroll if newline is output.	*/
			static int	newline = 1;
		if( CS != NULL )
			{
			(void) SetScrlReg( TOP_SCROLL_WIN, PROMPT_LINE - 1 );
			if( newline )
				{
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) _doprnt( fmt, ap, stdout );
			(void) ResetScrlReg();
			}
		else
		if( DL != NULL )
			{
			if( newline )
				{
				SCROLL_DL_MOVE();
				(void) DeleteLn();
				SCROLL_PR_MOVE();
				(void) ClrEOL();
				}
			(void) _doprnt( fmt, ap, stdout );
			}
		else
			(void) _doprnt( fmt, ap, stdout );
		/* End of line detected by existance of a newline.	*/
		newline = fmt[strlen( fmt )-1] == '\n';
		hmredraw();
		}
	else
		(void) _doprnt( fmt, ap, stderr );
	va_end( ap );
	bu_semaphore_release( BU_SEM_SYSCALL );		/* unlock */
	return;
	}
#endif /* HAVE_STDARG_H */
@


11.9
log
@change conf.h to a wrapped config.h
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /cvs/brlcad/lgt/prnt.c,v 11.8 2004/04/05 07:46:59 morrison Exp $ (BRL)";
@


11.8
log
@merge of ansi-6-0-branch into HEAD
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header$ (BRL)";
d12 5
a16 1
#include "conf.h"
@


11.7
log
@Restoration of entire source tree to Pre-Hartley state
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/prnt.c,v 11.5 2001/05/17 20:05:16 morrison Exp $ (BRL)";
d137 2
a138 4
pad_Strcpy( des, src, len )
register char	*des, *src;
register int	len;
	{
d151 2
a152 2
init_Status()
	{	register int	row, col;
d161 2
a162 2
prnt_Status()
	{	static char	scratchbuf[TEMPLATE_COLS+1];
d214 2
a215 2
update_Screen()
	{	register int	tem_co, row, col;
d239 2
a240 3
prnt_Paged_Menu( menu )
register char	**menu;
	{	register int	done = FALSE;
d261 2
a262 3
do_More( linesp )
int	*linesp;
	{	register int	ret = TRUE;
d295 2
a296 2
prnt_Menu()
	{
d306 2
a307 3
prnt_Prompt( prompt )
char	*prompt;
	{
d322 2
a323 3
prnt_Timer( eventstr )
char	*eventstr;
	{
d337 2
a338 3
prnt_Event( s )
char	*s;
	{	static int	lastlen = 0;
d365 2
a366 3
prnt_Title( titleptr )
char	*titleptr;
	{
d376 2
a377 2
prnt_Usage()
	{	register char	**p = usage;
@


11.7.2.1
log
@Initial ANSIfication
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/prnt.c,v 11.7 2002/08/20 17:07:34 jra Exp $ (BRL)";
d137 4
a140 2
pad_Strcpy(register char *des, register char *src, register int len)
{
d153 2
a154 2
init_Status(void)
{	register int	row, col;
d163 2
a164 2
prnt_Status(void)
{	static char	scratchbuf[TEMPLATE_COLS+1];
d216 2
a217 2
update_Screen(void)
{	register int	tem_co, row, col;
d241 3
a243 2
prnt_Paged_Menu(register char **menu)
{	register int	done = FALSE;
d264 3
a266 2
do_More(int *linesp)
{	register int	ret = TRUE;
d299 2
a300 2
prnt_Menu(void)
{
d310 3
a312 2
prnt_Prompt(char *prompt)
{
d327 3
a329 2
prnt_Timer(char *eventstr)
{
d343 3
a345 2
prnt_Event(char *s)
{	static int	lastlen = 0;
d372 3
a374 2
prnt_Title(char *titleptr)
{
d384 2
a385 2
prnt_Usage(void)
{	register char	**p = usage;
@


11.6
log
@Converted from K&R to ANSI C - RFH
@
text
@d137 4
a140 2
pad_Strcpy(register char *des, register char *src, register int len)
{
d153 2
a154 2
init_Status(void)
{	register int	row, col;
d163 2
a164 2
prnt_Status(void)
{	static char	scratchbuf[TEMPLATE_COLS+1];
d216 2
a217 2
update_Screen(void)
{	register int	tem_co, row, col;
d241 3
a243 2
prnt_Paged_Menu(register char **menu)
{	register int	done = FALSE;
d264 3
a266 2
do_More(int *linesp)
{	register int	ret = TRUE;
d299 2
a300 2
prnt_Menu(void)
{
d310 3
a312 2
prnt_Prompt(char *prompt)
{
d327 3
a329 2
prnt_Timer(char *eventstr)
{
d343 3
a345 2
prnt_Event(char *s)
{	static int	lastlen = 0;
d372 3
a374 2
prnt_Title(char *titleptr)
{
d384 2
a385 2
prnt_Usage(void)
{	register char	**p = usage;
@


11.5
log
@rt_g.debug -> RT_G_DEBUG
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/prnt.c,v 11.4 2000/08/24 22:55:52 mike Exp $ (BRL)";
d137 2
a138 4
pad_Strcpy( des, src, len )
register char	*des, *src;
register int	len;
	{
d151 2
a152 2
init_Status()
	{	register int	row, col;
d161 2
a162 2
prnt_Status()
	{	static char	scratchbuf[TEMPLATE_COLS+1];
d214 2
a215 2
update_Screen()
	{	register int	tem_co, row, col;
d239 2
a240 3
prnt_Paged_Menu( menu )
register char	**menu;
	{	register int	done = FALSE;
d261 2
a262 3
do_More( linesp )
int	*linesp;
	{	register int	ret = TRUE;
d295 2
a296 2
prnt_Menu()
	{
d306 2
a307 3
prnt_Prompt( prompt )
char	*prompt;
	{
d322 2
a323 3
prnt_Timer( eventstr )
char	*eventstr;
	{
d337 2
a338 3
prnt_Event( s )
char	*s;
	{	static int	lastlen = 0;
d365 2
a366 3
prnt_Title( titleptr )
char	*titleptr;
	{
d376 2
a377 2
prnt_Usage()
	{	register char	**p = usage;
@


11.4
log
@
RCSid
@
text
@d9 1
a9 1
static const char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/prnt.c,v 11.3 1999/06/03 21:40:51 mike Exp $ (BRL)";
d191 1
a191 1
	(void) sprintf( scratchbuf, "0x%06x", rt_g.debug );
d375 1
a375 1
	if( ! tty || rt_g.debug )
@


11.3
log
@
sed4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /c/CVS/brlcad/lgt/prnt.c,v 11.2 1997/12/16 00:25:39 mike Exp $ (BRL)";
@


11.2
log
@Converted to bu_semaphore_acquire()
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/prnt.c,v 11.1 1995/01/04 10:17:59 mike Rel4_4 mike $ (BRL)";
d248 1
a248 1
			rt_log( "%s\n", *menu );
d337 1
a337 1
		rt_log( "(%s) %s\n", eventstr == NULL ? "(null)" : eventstr, timer );
d376 1
a376 1
		rt_log( "%s\n", titleptr == NULL ? "(null)" : titleptr );
@


11.1
log
@Release_4.4
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/prnt.c,v 10.3 94/12/20 15:27:06 mike Exp $ (BRL)";
d398 1
a398 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d435 1
a435 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d445 1
a445 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d480 1
a480 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
d491 1
a491 1
	RES_ACQUIRE( &rt_g.res_syscall );		/* lock */
d528 1
a528 1
	RES_RELEASE( &rt_g.res_syscall );		/* unlock */
@


10.4
log
@No #elif on non-ANSI compilers
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/prnt.c,v 10.3 94/12/20 15:27:06 mike Exp Locker: mike $ (BRL)";
d18 3
a20 5
#  include <stdarg.h>
#else
#  if defined(HAVE_VARARGS_H)
#    include <varargs.h>
#  endif
d439 1
a439 2
#else	/* defined(HAVE_STDARG_H) */
#  if !defined(HAVE_VARARGS_H)
d482 1
a482 1
#  else	/* defined(HAVE_VARARGS_H) */
d531 1
a531 2
#  endif	/* !defined(HAVE_VARARGS_H) */
#endif		/* HAVE_STDARG_H */
@


10.3
log
@Changed definition of "template" array so that it would be in
writable memory.  Newer compilers place the bytes of quoted strings
into read-only memory pages.  In the case of "template", that
prevented the "fill-in-the-blanks" operations from succeeding.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/prnt.c,v 10.2 94/08/24 13:36:49 gdurf Exp Locker: mike $ (BRL)";
d18 5
a22 3
#include <stdarg.h>
#elif defined(HAVE_VARARGS_H)
#include <varargs.h>
d441 2
a442 1
#elif !defined(HAVE_VARARGS_H)
d485 1
a485 1
#else
d534 2
a535 1
#endif /* HAVE_STDARG_H */
@


10.2
log
@Made includes explicit, factored ifdefs
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/prnt.c,v 10.1 1991/10/12 06:50:12 mike Rel4_0 gdurf $ (BRL)";
d219 1
a219 1
	for( row = 0; template[row] != NULL; row++ )
@


10.1
log
@Release_4.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/prnt.c,v 9.2 91/08/30 21:14:36 mike Exp $ (BRL)";
d11 3
d15 15
d391 1
a391 2
#if __STDC__
# include <stdarg.h>
d439 1
a439 1
#else /* !__STDC__ */
a440 2
#if defined( CRAY1 )
/* VARARGS */
a482 1
# include <varargs.h>
d531 1
a531 2
#endif /* !CRAY */
#endif /* !__STDC__ */
@


9.2
log
@Added STDC version of prnt_Scroll()
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: /m/cad/lgt/RCS/prnt.c,v 9.1 89/05/19 06:13:26 mike Rel3_5 $ (BRL)";
@


9.1
log
@Release_3.5
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 8.2 89/05/12 23:27:43 moss Exp $ (BRL)";
d373 51
a423 1
#include <varargs.h>
d468 1
d517 2
a518 1
#endif
@


8.2
log
@pre release changes
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 7.1 87/11/03 00:25:37 moss Locked $ (BRL)";
@


8.1
log
@Release_3.0
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 7.5 88/09/20 15:55:39 moss Exp $ (BRL)";
d12 1
a12 3
#include "machine.h"
#include "vmath.h"
#include "raytrace.h"
a13 1
#include "./lgt.h"
a16 1
#include "./extern.h"
d23 1
a23 1
"lgt [-IOTovw file][-AGKXacefgiknps n][-b \"R G B\"][-dtD \"x y\"][-xy \"a b\"] file.g object...",
d36 1
a36 1
"A factor             anti-aliasing thru over-sampling by factor",
d47 7
a53 2
"G size               grid resolution (# of rays along edge of square grid)",
"g fov                field of view (1.0 = entire model)",
d60 3
d74 1
a74 1
"S file               script (save current option settings in file) ",
d76 4
a79 1
"T file               read texture map file",
d118 1
a118 1
_LOCAL_ void
d150 2
a151 2
	(void) sprintf( scratchbuf, "%6.4f", grid_scale );
	(void) strncpy( FIELD_OF_VU_PTR, scratchbuf, strlen( scratchbuf ) );
d164 2
a165 1
	(void) sprintf( scratchbuf, "%3d %3d %3d", background[0], background[1], background[2] );
d179 4
a182 2
	(void) sprintf( scratchbuf, " %s ", ged_file == NULL ? "(null)" : ged_file );
	(void) strncpy( F_GED_DB_PTR, scratchbuf, Min( strlen( scratchbuf ), 26 ) );
@


7.5
log
@Changed #if defined( cray ) && ! defined( CRAY2 )
to #if defined( CRAY1 ).
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 7.1 87/11/03 00:25:37 moss Locked $ (BRL)";
@


7.4
log
@Did away with texture file commands, and added textures to material
properties data base.
@
text
@d364 1
a364 1
#if defined( cray ) && ! defined( CRAY2 )
@


7.3
log
@
@
text
@a156 1
	pad_Strcpy( F_TEXTURE_PTR, txtr_file, 32 );
@


7.2
log
@Smoothing out menu and prompting interface.
@
text
@d45 1
a45 1
"c [flag]             enable or disable tracking cursor",
d53 2
a54 2
"H [file]             save frame buffer image",
"h [file]             read frame buffer image",
d56 1
a56 1
"j [file]             input key-frame from file (as output by mged(1B))",
d58 1
a58 1
"k [flag]             enable or disable hidden line drawing",
d60 1
a60 1
"l [id]               print light source entry id (0 to 10) or all",
d62 4
a65 4
"m [id]               print material data base entry id (0 to 99) or all",
"n [processors]       number of processors to use (parallel environment)",
"O [file]             re-direct errors to specified output file",
"o [file]             image (output file for picture)",
d70 1
a70 1
"S [file]             script (save current option settings in file) ",
d72 1
a72 1
"T [file]             read texture map file",
d74 8
a81 8
"V [file]             write light source data base",
"v [file]             read light source data base",
"W [file]             write material attribute data base",
"w [file]             read material attribute data base",
"X [flag]             enable or disable reporting of overlaps",
"x start [finish]     set left and right border of current rectangle",
"y start [finish]     set top and bottom border of current rectangle",
"z ulen vlen [width]  size of texture map (plus width of padded lines)",
d83 3
a85 3
"! [arg(s)]           feed arg(s) to /bin/sh or $SHELL if set",
". [flag]             set buffered pixel I/O flag",
"# [anything]         comment or NOP (useful in preparing input files)",
d94 1
a94 1
"I [file]             read and display IR data",
d96 1
a96 1
"N [temperature]      specify temperature for IR painting",
d100 2
a101 2
"U [file]             write IR data base file",
"u [file]             read IR data base file",
@


7.1
log
@Release 2.3
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 6.3 87/10/29 08:52:05 moss Exp $ (BRL)";
d173 1
a173 1
	(void) strncpy( F_GED_DB_PTR, scratchbuf, strlen( scratchbuf ) );
d180 1
a180 1
	(void) sprintf( scratchbuf, "%04d] ", grid_y_fin );
d182 2
d246 1
a246 1
	prnt_Prompt( "-- More -- " );
d251 1
d253 1
d318 2
a319 1
	{
d322 1
a322 2
	EVENT_MOVE();
	(void) ClrEOL();
d324 1
d326 12
@


6.3
log
@Ready for release 2.1 of BRL CAD.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 6.2 87/10/15 10:41:47 moss Locked $ (BRL)";
@


6.2
log
@Added screen update optimization.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 5.1 87/06/24 22:47:55 mike Rel $ (BRL)";
d328 2
a329 2
prnt_Title( title )
char	*title;
d332 1
a332 1
		rt_log( "%s\n", title == NULL ? "(null)" : title );
@


6.1
log
@Release 2.0
@
text
@d15 1
d21 1
d106 9
a114 3
/*	p r n t _ S t a t u s ( )					*/
void
prnt_Status()
d116 7
a122 4
	if( ir_mapping )
		prnt_IR_Status();
	else
		prnt_Lgt_Status();
d126 1
a126 1
/*	p r n t _ L g t _ S t a t u s ( )				*/
d128 34
a161 44
prnt_Lgt_Status()
	{
	TITLE_MOVE();
	(void) fputs( title, stdout );
	TIMER_MOVE();
	(void) fputs( timer, stdout );
	F_SCRIPT_MOVE();
	(void) fputs( script_file, stdout );
	FIELD_OF_VU_MOVE();
	(void) printf( "%6.4f", grid_scale );
	if( err_file[0] != '\0' )
		{
		F_ERRORS_MOVE();
		(void) printf( "%-32s", err_file );
		}
	GRID_DIS_MOVE();
	(void) printf( "%11.4f", grid_dist );
	if( mat_db_file[0] != '\0' )
		{
		F_MAT_DB_MOVE();
		(void) printf( "%-32s", mat_db_file );
		}
	GRID_XOF_MOVE();
	(void) printf( "%11.4f", x_grid_offset );
	if( lgt_db_file[0] != '\0' )
		{
		F_LGT_DB_MOVE();
		(void) printf( "%-32s", lgt_db_file );
		}
	GRID_YOF_MOVE();
	(void) printf( "%11.4f", y_grid_offset );
	if( fb_file[0] != '\0' )
		{
		F_RASTER_MOVE();
		(void) printf( "%-32s", fb_file );
		}
	MODEL_RA_MOVE();
	(void) printf( "%11.4f", modl_radius );
	F_TEXTURE_MOVE();
	(void) printf( "%-32s", txtr_file );
	BACKGROU_MOVE();
	(void) printf( "%3d %3d %3d", background[0], background[1], background[2] );
	BUFFERED_MOVE();
	(void) printf( "%4s",	pix_buffered == B_PAGE ? "PAGE" :
d165 18
a182 21
	DEBUGGER_MOVE();
	(void) printf( "0x%06x", rt_g.debug );
	MAX_BOUN_MOVE();
	(void) printf( "%-2d", max_bounce );
	(void) SetStandout();
	PROGRAM_NM_MOVE();
	(void) printf( " LGT %s", version );
	if( ged_file != NULL )
		{
		F_GED_DB_MOVE();
		(void) printf( " %s ", ged_file );
		}
	GRID_PIX_MOVE();
	(void) printf( " [%04d-", grid_x_org );
	GRID_SIZ_MOVE();
	(void) printf( "%04d,", grid_x_fin );
	GRID_SCN_MOVE();
	(void) printf( "%04d-", grid_y_org );
	GRID_FIN_MOVE();
	(void) printf( "%04d] ", grid_y_fin );
	(void) ClrStandout();
a185 1
/*	p r n t _ I R _ S t a t u s ( )					*/
d187 16
a202 14
prnt_IR_Status()
	{
	TITLE_MOVE();
	(void) fputs( title, stdout );
	TIMER_MOVE();
	(void) fputs( timer, stdout );
	F_SCRIPT_MOVE();
	(void) fputs( script_file, stdout );
	FIELD_OF_VU_MOVE();
	(void) printf( "%6.4f", grid_scale );
	if( err_file[0] != '\0' )
		{
		F_ERRORS_MOVE();
		(void) printf( "%-32s", err_file );
a203 53
	GRID_DIS_MOVE();
	(void) printf( "%11.4f", grid_dist );
	if( ir_file[0] != '\0' )
		{
		F_MAT_DB_MOVE();
		(void) printf( "%-32s", ir_file );
		}
	GRID_XOF_MOVE();
	(void) printf( "%11.4f", x_grid_offset );
	if( lgt_db_file[0] != '\0' )
		{
		F_LGT_DB_MOVE();
		(void) printf( "%-32s", lgt_db_file );
		}
	GRID_YOF_MOVE();
	(void) printf( "%11.4f", y_grid_offset );
	if( fb_file[0] != '\0' )
		{
		F_RASTER_MOVE();
		(void) printf( "%-32s", fb_file );
		}
	MODEL_RA_MOVE();
	(void) printf( "%11.4f", modl_radius );
	BACKGROU_MOVE();
	(void) printf( "%3d %3d %3d", background[0], background[1], background[2] );
	BUFFERED_MOVE();
	(void) printf( "%4s",	pix_buffered == B_PAGE ? "PAGE" :
				pix_buffered == B_PIO ? "PIO" :
				pix_buffered == B_LINE ? "LINE" : "?"
				);
	DEBUGGER_MOVE();
	(void) printf( "0x%06x", rt_g.debug );
	IR_AUTO_MAP_MOVE();
	(void) printf( "%4s", 	ir_offset == 1 ? "ON" : "OFF" );
	IR_PAINT_MOVE();
	if( ir_doing_paint )
		(void) printf( "%4d", ir_paint );
	else
		(void) printf( "none" );
	(void) SetStandout();
	PROGRAM_NM_MOVE();
	(void) printf(	" LGT (%s) IR Module [%s] ",
			*version == '%' ? "EXP" : version,
			ir_mapping & IR_READONLY ? "readonly" : "editmode"
			);
	GRID_PIX_MOVE();
	(void) printf( " [%04d-", grid_x_org );
	GRID_SIZ_MOVE();
	(void) printf( "%04d,", grid_x_fin );
	GRID_SCN_MOVE();
	(void) printf( "%04d-", grid_y_org );
	GRID_FIN_MOVE();
	(void) printf( "%04d] ", grid_y_fin );
d205 2
d247 1
a247 1
	switch( get_Char() )
d273 1
d296 2
a297 2
prnt_Timer( s )
char	*s;
d301 3
a303 6
		{	register int	nblanks;
		nblanks = (TIMER_LEN-1) - strlen( timer );
		TIMER_MOVE();
		(void) fputs( timer, stdout );
		while( nblanks-- > 0 )
			(void) putc( ' ', stdout );
d306 1
a306 1
		rt_log( "(%s) %s\n", s == NULL ? "(null)" : s, timer );
a311 1

d328 2
a329 2
prnt_Title( s )
char	*s;
d331 2
a332 7
	if( tty && ! rt_g.debug )
		{
		TITLE_MOVE();
		(void) fputs( s, stdout );
		}
	else
		rt_log( "%s\n", s == NULL ? "(null)" : s );
d348 1
a348 1
#ifdef cray
d385 1
d432 1
@


5.1
log
@Release 1.24
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 1.3 87/06/23 12:32:37 moss Exp $ (BRL)";
@


1.3
log
@Ready for release 1.23.  This includes the a_overlap function support,
and return to 128 byte records on IEEE floating point architectures.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 1.2 87/02/06 12:28:55 moss Locked $ (BRL)";
@


1.2
log
@Added paging to scrolling prints.
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header: prnt.c,v 1.1 87/02/05 17:18:25 moss Locked $ (BRL)";
d25 1
a25 1
"lgt [-IOTovw file][-AGKacefginps n][-b \"R G B\"][-dtD \"x y\"][-xy \"a b\"] file.g object...",
d56 5
a60 4
"L id                 modify light source entry for id (0 to 10)",
"l id                 print light source entry for id (0 to 10)",
"M id                 modify material data base entry for id (0 to 99)",
"m id                 print material data base entry for id (0 to 99)",
d76 1
d156 1
a156 1
	(void) printf( "%-32s", texture_file );
d240 1
a240 1
	if( ir_paint_flag )
d408 43
d459 1
a459 1
	RES_ACQUIRE( &rt_g.res_malloc );		/* lock */
d495 1
a495 1
	RES_RELEASE( &rt_g.res_malloc );		/* unlock */
d498 1
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
static char RCSid[] = "@@(#)$Header$ (BRL)";
d18 1
a22 2
"l g t (2.3)",
"",
d168 1
a168 1
	(void) printf( " LGT (%s) ",  *version == '%' ? "EXP" : version );
d260 56
d319 2
a320 3
	{	register char	**p;
	for( p = lgt_menu; *p != NULL; p++ )
		prnt_Scroll( "%-*s\n", co, *p );
d322 1
a322 3
		for( p = ir_menu; *p != NULL; p++ )
			prnt_Scroll( "%-*s\n", co, *p );
	(void) fflush( stdout );
d447 2
@
